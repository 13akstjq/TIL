<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>TIL</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//posts/1" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="TIL" data-gatsby-head="true"/><meta property="og:title" content="TIL" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//posts/1" data-gatsby-head="true"/><meta name="twitter:title" content="TIL" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/7978fe7362f7d4c9.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/7978fe7362f7d4c9.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/873-eb138c3217d71553.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/posts/%5Bpage%5D-de1dc5579188f9be.js" defer=""></script><script src="/TIL/_next/static/o6AmBAY_j9v9JmbaRA39X/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/o6AmBAY_j9v9JmbaRA39X/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Next.js 15에서 generateMetadata 함수로 SEO 메타데이터 자동 생성하는 방법" href="/TIL/post/2025-04-22-generateMetadata"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15에서 generateMetadata 함수로 SEO 메타데이터 자동 생성하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15에서 generateMetadata 함수로 SEO 메타데이터 자동 생성하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15에서 generateMetadata 함수로 SEO 메타데이터 자동 생성하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">9 hours ago</span><span class="PostList_reading_time__6CBMQ">84<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js 15에서 generateImageMetadata 함수 사용하는 방법" href="/TIL/post/2025-04-22-generateImageMetadata"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15에서 generateImageMetadata 함수 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15에서 generateImageMetadata 함수 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15에서 generateImageMetadata 함수 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">9 hours ago</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js 15에서 Forbidden 에러 해결하는 방법" href="/TIL/post/2025-04-22-forbidden"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15에서 Forbidden 에러 해결하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15에서 Forbidden 에러 해결하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15에서 Forbidden 에러 해결하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">9 hours ago</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nextjs 15에서 draftMode 기능 사용 방법" href="/TIL/post/2025-04-22-draftMode"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nextjs 15에서 draftMode 기능 사용 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nextjs 15에서 draftMode 기능 사용 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Nextjs 15에서 draftMode 기능 사용 방법</strong><div class="PostList_meta__VCFLX"><span class="date">9 hours ago</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js 15에서 fetch API 활용하는 최신 방법" href="/TIL/post/2025-04-22-fetch"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15에서 fetch API 활용하는 최신 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15에서 fetch API 활용하는 최신 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15에서 fetch API 활용하는 최신 방법</strong><div class="PostList_meta__VCFLX"><span class="date">9 hours ago</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js 15에서 쿠키 쉽게 다루는 방법" href="/TIL/post/2025-04-22-cookies"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15에서 쿠키 쉽게 다루는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15에서 쿠키 쉽게 다루는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15에서 쿠키 쉽게 다루는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">9 hours ago</span><span class="PostList_reading_time__6CBMQ">20<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js 15에서 cacheTag 사용해서 효율적으로 캐시 관리하는 방법" href="/TIL/post/2025-04-22-cacheTag"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15에서 cacheTag 사용해서 효율적으로 캐시 관리하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15에서 cacheTag 사용해서 효율적으로 캐시 관리하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15에서 cacheTag 사용해서 효율적으로 캐시 관리하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">9 hours ago</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js 15에서 Connection 관리하는 방법" href="/TIL/post/2025-04-22-connection"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15에서 Connection 관리하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15에서 Connection 관리하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15에서 Connection 관리하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">9 hours ago</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js 15에서 cacheLife 설정하는 방법 및 캐시 수명 관리 방법 정리" href="/TIL/post/2025-04-22-cacheLife"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15에서 cacheLife 설정하는 방법 및 캐시 수명 관리 방법 정리" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15에서 cacheLife 설정하는 방법 및 캐시 수명 관리 방법 정리" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15에서 cacheLife 설정하는 방법 및 캐시 수명 관리 방법 정리</strong><div class="PostList_meta__VCFLX"><span class="date">9 hours ago</span><span class="PostList_reading_time__6CBMQ">17<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js 15에서 after 메서드 활용하는 최신 방법 2025" href="/TIL/post/2025-04-22-after"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15에서 after 메서드 활용하는 최신 방법 2025" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15에서 after 메서드 활용하는 최신 방법 2025" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15에서 after 메서드 활용하는 최신 방법 2025</strong><div class="PostList_meta__VCFLX"><span class="date">9 hours ago</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link posts_-active__YVJEi" href="/TIL/posts/1">1</a><a class="link" href="/TIL/posts/2">2</a><a class="link" href="/TIL/posts/3">3</a><a class="link" href="/TIL/posts/4">4</a><a class="link" href="/TIL/posts/5">5</a><a class="link" href="/TIL/posts/6">6</a><a class="link" href="/TIL/posts/7">7</a><a class="link" href="/TIL/posts/8">8</a><a class="link" href="/TIL/posts/9">9</a><a class="link" href="/TIL/posts/10">10</a><a class="link" href="/TIL/posts/11">11</a><a class="link" href="/TIL/posts/12">12</a><a class="link" href="/TIL/posts/13">13</a><a class="link" href="/TIL/posts/14">14</a><a class="link" href="/TIL/posts/15">15</a><a class="link" href="/TIL/posts/16">16</a><a class="link" href="/TIL/posts/17">17</a><a class="link" href="/TIL/posts/18">18</a><a class="link" href="/TIL/posts/19">19</a><a class="link" href="/TIL/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Next.js 15에서 generateMetadata 함수로 SEO 메타데이터 자동 생성하는 방법","description":"","date":"2025-04-22 03:05","slug":"2025-04-22-generateMetadata","content":"\n\n# generateMetadata\n\n이번 글에서는 Next.js에서 메타데이터를 설정하는 방법 중 Config 기반 메타데이터 옵션인 `generateMetadata`와 정적인 `metadata` 객체에 대해 알아볼게요.\n\n```js\nimport type { Metadata } from 'next'\n\n// 정적 메타데이터 예시\nexport const metadata: Metadata = {\n  title: '홈페이지 제목',\n}\n\n// 동적 메타데이터 예시\nexport async function generateMetadata({ params }) {\n  return {\n    title: '동적 페이지 제목',\n  }\n}\n```\n\n\u003e 알아두면 좋은 점:\n\u003e - `metadata` 객체와 `generateMetadata` 함수는 **서버 컴포넌트**에서만 지원돼요.\n\u003e - 한 라우트 세그먼트에서 `metadata` 객체와 `generateMetadata` 함수를 동시에 내보낼 수는 없습니다.\n\n---\n\n### 좀 더 자세히 설명해볼게요!\n\nNext.js 13부터는 페이지별 메타데이터를 쉽게 설정하는 방법으로 `metadata` 객체 또는 `generateMetadata` 함수를 제공해요.\n\n- **`metadata` 객체**: 빌드 시점에 정적으로 설정되는 메타데이터로, 변하지 않는 값을 넣을 때 사용해요.\n- **`generateMetadata` 함수**: 요청에 따라 동적으로 값을 만들거나, API 데이터 등을 기반으로 메타데이터를 생성해야 할 때 사용해요.\n\n예를 들면 블로그 게시글 같은 경우, 글 ID를 URL 파라미터로 받아서 `generateMetadata`에서 제목과 설명을 동적으로 세팅할 수 있죠.\n\n```js\nexport async function generateMetadata({ params }) {\n  const post = await getPost(params.id);\n  return {\n    title: post.title,\n    description: post.summary,\n  }\n}\n```\n\n---\n\n### 참고사항\n\n- 이 기능들은 **서버 컴포넌트(Server Components)**에서만 동작해요. 클라이언트 컴포넌트에서는 지원되지 않으니 주의하세요.\n- 한 경로에서 `metadata`와 `generateMetadata`를 동시에 export하면 충돌이 나므로, 하나만 골라서 사용해야 합니다.\n\n메타데이터는 SEO에 매우 중요한 역할을 하니, 빌드시점에 고정 값으로 넣을지, 동적으로 데이터를 가져와서 세팅할지 상황에 맞게 잘 선택해 사용하면 좋겠죠?\n\n다음 글에서는 실제 프로젝트에서 어떻게 활용하는지 더 구체적인 예제도 소개해볼게요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 메타데이터 객체\n\nNext.js에서 정적인 메타데이터를 정의할 때는 `layout.js`나 `page.js` 파일에서 `Metadata` 객체를 export 하면 됩니다.\n\n```js\nimport type { Metadata } from 'next'\n\nexport const metadata: Metadata = {\n  title: '내 멋진 페이지 제목',\n  description: '페이지에 대한 간단한 설명을 적어주세요',\n}\n\nexport default function Page() {}\n```\n\n이렇게 하면 해당 페이지에 맞는 SEO-friendly한 메타데이터가 자동으로 적용돼서, 검색 엔진 최적화(SEO)에 도움이 되고, 소셜 미디어에 공유될 때도 깔끔하게 노출돼요.\n\n### 참고로\n`.metadata` 객체에는 더 많은 필드들이 있어요. 예를 들어 `keywords`, `author`, `openGraph`, `twitter` 같은 다양한 메타데이터 옵션을 넣을 수 있는데요, 이것들은 페이지를 더 풍부하게 만들어주고 SNS 공유 시 미리보기 정보를 더 세밀하게 제어할 수 있어요.\n\n아래는 자주 사용하는 메타데이터 필드를 간단히 정리한 표예요:\n\n| 필드명        | 설명                                  |\n| ------------- | ------------------------------------- |\n| `title`       | 페이지 제목                           |\n| `description` | 페이지 설명                           |\n| `keywords`    | SEO를 위한 키워드 배열                |\n| `author`      | 페이지 제작자 정보                    |\n| `openGraph`   | 오픈 그래프 프로토콜에 따른 메타데이터 |\n| `twitter`     | 트위터 카드용 메타데이터              |\n\n더 자세한 내용은 공식 문서의 [Metadata Fields](https://nextjs.org/docs/app/api-reference/functions/generate-metadata#fields) 항목을 참고하면 좋아요.\n\n---\n\n정리하자면, Next.js에서 페이지별 메타데이터를 간단하게 관리하려면 `metadata` 객체를 export하는 것만으로 충분합니다. 이렇게 하면 최신 SEO 기술도 쉽게 적용할 수 있어서, 별도의 헤드 태그를 직접 조작하는 번거로움을 줄일 수 있어요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## generateMetadata 함수란?\n\nNext.js에서 동적인 메타데이터를 설정할 때, 현재 라우트의 파라미터나 외부 데이터, 부모 컴포넌트의 메타데이터 정보를 기반으로 설정할 수 있어요. 이를 위해 `generateMetadata`라는 함수를 export해서 메타데이터 객체를 반환하면 됩니다.\n\n예를 들어, 상품 페이지에서 URL 파라미터로 받은 상품 ID를 활용해 서버에서 상품 데이터를 가져와서 타이틀이나 Open Graph 이미지 정보를 동적으로 세팅할 수 있죠.\n\n```js\nimport type { Metadata, ResolvingMetadata } from 'next'\n\n// Props 타입 정의 - params와 검색 파라미터가 Promise로 들어오는 걸 확인하세요\ntype Props = {\n  params: Promise\u003c{ id: string }\u003e\n  searchParams: Promise\u003c{ [key: string]: string | string[] | undefined }\u003e\n}\n\nexport async function generateMetadata(\n  { params, searchParams }: Props,\n  parent: ResolvingMetadata\n): Promise\u003cMetadata\u003e {\n  // 라우트 파라미터 읽기\n  const { id } = await params\n\n  // 외부 API에서 상품 정보 가져오기\n  const product = await fetch(`https://.../${id}`).then((res) =\u003e res.json())\n\n  // 부모 메타데이터의 Open Graph 이미지 배열 불러오기 (없으면 빈 배열)\n  const previousImages = (await parent).openGraph?.images || []\n\n  // 동적으로 메타데이터 설정 (기존 이미지는 유지하면서 새 이미지 추가)\n  return {\n    title: product.title,\n    openGraph: {\n      images: ['/some-specific-page-image.jpg', ...previousImages],\n    },\n  }\n}\n\n// Page 컴포넌트 예시 - params, searchParams 받아올 수 있음\nexport default function Page({ params, searchParams }: Props) {}\n```\n\n### 주요 파라미터 설명\n\n| 파라미터 | 설명 |\n| -------- | ---- |\n| `params` | URL 라우트 파라미터(예: `/product/[id]`에서 `id`). Promise로 감싸져서 옵니다. |\n| `searchParams` | URL 쿼리스트링 파라미터 (`?category=shoes` 등). Promise 타입입니다. |\n| `parent` | 부모 레이아웃 혹은 상위 컴포넌트에 설정된 메타데이터를 받아올 수 있어요. 기존 메타데이터를 활용해 확장할 때 유용합니다. |\n\n---\n\n\u003e **꿀팁!**  \n\u003e `generateMetadata` 함수 내부에서 필요할 때 외부 API를 호출해 정보를 받아올 수 있기 때문에, 페이지마다 SEO 최적화된 메타 태그를 동적으로 설정할 수 있어요.  \n\u003e  \n\u003e 다만, 이 함수는 서버에서만 실행되므로, 클라이언트 전용 상태나 이벤트는 사용할 수 없고, 비동기 작업도 서버에서 처리됩니다.  \n\u003e  \n\u003e 그리고 `params`와 `searchParams`가 Promise 형태라는 점도 헷갈리지 말아요! `await`를 꼭 붙여서 값을 받아야 합니다.\n\n---\n\n이제 `generateMetadata`를 잘 활용해서, 검색 엔진 최적화와 SNS 공유에 딱 맞는 메타데이터를 페이지 단위로 동적 생성할 수 있겠죠? 계산된 데이터를 기반으로 메타데이터를 만드는 저만의 SEO 전략을 코딩에 적용해 보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\ngenerateMetadata 함수에 대해 알아볼게요! 이 함수는 Next.js 같은 프레임워크에서 페이지별로 메타데이터를 동적으로 생성할 때 많이 사용됩니다. 조금 더 쉽게 설명하고, 함수가 받는 파라미터와 반환값에 대해 정리해볼게요.\n\n---\n\n## generateMetadata 함수 파라미터 설명\n\n이 함수는 다음과 같은 파라미터를 받습니다. 보통 하나의 `props` 객체로 전달되는데, 그 안에 여러 속성이 들어 있어요.\n\n| 파라미터명    | 설명                                                                                                              | 예시                                                                                 |\n|---------------|-------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------|\n| `params`      | 현재 라우트에서 동적 세그먼트(즉, URL 경로에서 동적으로 변하는 부분)들의 값을 모아놓은 객체.                       | `/shop/1` → `{ slug: '1' }` \u003cbr\u003e `/shop/1/2` → `{ tag: '1', item: '2' }` \u003cbr\u003e `/shop/1/2` (catch-all) → `{ slug: ['1', '2'] }` |\n| `searchParams`| URL 쿼리스트링(검색 파라미터)의 값들을 담은 객체입니다. 여러 개일 경우 배열로 들어올 수도 있어요.                  | `/shop?a=1` → `{ a: '1' }` \u003cbr\u003e `/shop?a=1\u0026b=2` → `{ a: '1', b: '2' }` \u003cbr\u003e `/shop?a=1\u0026a=2` → `{ a: ['1', '2'] }`              |\n| `parent`      | 상위 라우트(segment)에서 이미 계산된 메타데이터를 Promise 형태로 받습니다. 상위의 메타데이터를 기반으로 추가 가공할 때 유용해요. | —                                                                                    |\n\n---\n\n## 참고 및 중요 포인트\n\n- `params` 객체는 URL 경로의 동적 부분을 잡아주기 때문에, 예를 들어 `[slug]` 같은 동적 경로 세그먼트에 해당하는 값이 들어옵니다.\n- `[...slug]` 같은 catch-all 세그먼트의 경우 배열로 넘어옵니다.\n- `searchParams`는 쿼리스트링에서 하나뿐 아니라 여러 값도 받을 수 있어서 배열로 표현될 수도 있어요.\n- `parent`는 재귀적 메타데이터 생성이 필요한 경우에 상위 메타데이터를 가져오는데, `await`을 사용해서 비동기 처리합니다.\n- 반환값은 `Metadata` 객체로, 보통 `title`, `description`, `openGraph` 같은 SEO 관련 메타데이터를 포함시킵니다.\n\n---\n\n## `generateMetadata` 반환값 예시\n\n다음은 `generateMetadata`가 반환할 수 있는 간단한 메타데이터 객체의 예시입니다.\n\n```ts\n{\n  title: 'Shop - ' + params.slug,\n  description: `This is the shop page for item ${params.slug}`,\n  openGraph: {\n    title: 'Shop OG Title',\n    description: 'Open graph description',\n    url: `https://example.com/shop/${params.slug}`,\n  },\n}\n```\n\n---\n\n이 함수로 동적 라우팅에 맞춰 SEO 최적화나 페이지별 메타데이터 세팅이 가능해서 Next.js의 중요한 기능 중 하나예요! 만약 상위 메타데이터와 합칠 필요가 있다면 `parent`를 `await`해서 가져와서 병합해주면 되고요.\n\n궁금한 점 있으면 언제든 질문해 주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003e 알아두면 좋은 점:\n- 메타데이터가 런타임 정보에 의존하지 않는다면, generateMetadata 대신 static metadata 객체를 사용하는 게 좋아요.\n- fetch 요청은 generateMetadata, generateStaticParams, Layout, Page, Server Component 등에서 같은 데이터를 요청할 땐 자동으로 메모이제이션(캐싱)됩니다. 만약 fetch를 쓸 수 없는 상황이라면 React cache를 활용할 수 있어요.\n- searchParams는 오직 page.js 세그먼트에서만 사용 가능합니다.\n- Next.js의 redirect()와 notFound() 메서드는 generateMetadata 안에서도 사용할 수 있어요.\n\n## 메타데이터 필드\n\n### title\n\ntitle 속성은 문서의 제목을 설정하는 데 사용됩니다. 단순 문자열로 지정할 수도 있고, 선택적으로 템플릿 객체 형태로 정의할 수도 있어요.\n\n---\n\n여기서 조금 더 팁을 드리자면, Next.js에서 페이지 타이틀을 동적으로 관리할 때 템플릿 객체를 활용하면 일관된 제목 포맷을 유지하는 데 아주 유용합니다. 예를 들어, 모든 페이지 제목 뒤에 ‘ | 내사이트명’을 붙이고 싶다면 템플릿을 써보세요. 각 페이지에서 제목만 넘겨주면 되니까 관리가 훨씬 편해진답니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n#### 문자열 (String)\n\nNext.js나 React를 사용할 때, 주로 문자열을 다루는 방법에 대해 간단히 정리해볼게요!\n\n예를 들어, 아래처럼 `metadata`라는 객체 안에 `title`이라는 문자열을 설정하는 코드가 있어요.\n\n```js\nexport const metadata = {\n  title: 'Next.js',\n}\n```\n\n이 코드는 주로 페이지의 메타데이터를 설정할 때 씁니다. 예를 들면, 브라우저 탭에 표시되는 제목 같은 내용을 여기서 정의하죠.\n\n그리고 HTML에서는 이렇게 `\u003ctitle\u003e` 태그 안에 직접 문자열을 넣어서 페이지 제목을 설정합니다.\n\n```js\n\u003ctitle\u003eNext.js\u003c/title\u003e\n```\n\n이 두 가지 방식이 결국 같은 목적, 즉 ‘페이지 제목’을 설정하는 거라 이해하면 쉬워요.\n\n---\n\n### 조금 더 알아볼까요?\n\n- **`metadata` 객체**: Next.js에서는 페이지별 메타데이터를 객체 형태로 내보내는 게 일반적이에요. 이렇게 하면 SEO 최적화나 소셜 미디어 공유 시에 필요한 정보를 손쉽게 관리할 수 있어요.\n- **템플릿 객체 (Template object)**: 보통 ‘템플릿 객체’란 UI 요소나 설정값 등을 미리 정해놓은 객체 형태로 관리하는 것을 말해요. 예를 들면, 페이지마다 `metadata`를 객체로 만들어서 사용하는 게 좋은 예죠.\n\n---\n\n### 간단 정리\n\n| 개념               | 설명                                                    |\n|------------------|-------------------------------------------------------|\n| 문자열 (String)     | 코드나 HTML 안에서 텍스트 데이터를 나타내는 기본 단위                    |\n| `metadata` 객체     | 페이지 정보(제목, 설명 등)를 담는 JSON 형식의 설정 객체                       |\n| `\u003ctitle\u003e` 태그       | HTML 문서의 제목을 브라우저 탭에 표시해주는 태그                         |\n| 템플릿 객체 (Template object) | 미리 정의된 설정이나 데이터를 객체 형태로 만들어서 재사용하는 패턴        |\n\n---\n\n그러니까, 개발할 때는 문자열을 단순히 “글자”로 생각하지 말고, 객체나 태그와 같이 어디에 어떻게 쓸지, 또 왜 필요한지 항상 생각하면서 다루면 훨씬 효율적인 코드를 만들 수 있어요! 필요하면 문자열 조작 함수나 템플릿 리터럴로 동적 텍스트를 만들 수도 있고요.\n\n궁금한 점 있으면 언제든 질문해주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 `metadata` 객체를 이용해 페이지의 메타 정보를 설정할 때, `title` 속성은 여러 가지 형태로 설정할 수 있어요. 그중에서 `title.default`는 자식 라우트 세그먼트가 별도로 제목(title)을 정의하지 않았을 때 사용할 ‘기본 제목(fallback title)’ 역할을 해요.\n\n예를 들어, 이런 코드가 있다고 가정해볼게요:\n\n```js\nimport type { Metadata } from 'next'\n\nexport const metadata: Metadata = {\n  title: {\n    default: 'Acme',\n  },\n}\n```\n\n위와 같이 `default` 값을 지정하면, 자식 페이지에서 `title`을 따로 정의하지 않아도 `\u003ctitle\u003eAcme\u003c/title\u003e`로 기본 타이틀이 세팅됩니다.\n\n---\n\n### 정리해볼게요!\n\n| 옵션       | 설명                                                      | 예시                         |\n|------------|-----------------------------------------------------------|------------------------------|\n| `title.default` | 자식 라우트에서 제목을 지정하지 않을 때 보여지는 기본 타이틀 | `'Acme'`                     |\n| `title.template`| 페이지 제목을 포맷팅할 때 쓰는 템플릿                      | `'%s | My Site'`              |\n| `title.absolute`| 절대 제목으로 설정, 템플릿과 관계없이 고정된 제목 사용       | `'Welcome to Acme'`          |\n\n예를 들어, `title.template`을 활용하면 동적인 제목을 예쁘게 꾸밀 수 있죠.\n\n```js\nexport const metadata: Metadata = {\n  title: {\n    template: '%s | Acme',\n    default: 'Acme',\n  },\n};\n```\n\n- `/about` 페이지에서 `title`을 `About Us`로 지정하면, `\u003ctitle\u003eAbout Us | Acme\u003c/title\u003e`가 되고,\n- `/contact` 같은 다른 자식 라우트가 타이틀을 따로 지정하지 않으면 `\u003ctitle\u003eAcme\u003c/title\u003e`가 됩니다.\n\n### 좀 더 팁!\n\n1. `title.absolute`는 특정 페이지에서 무조건 고정된 타이틀을 써야할 때 쓸 수 있어요. 템플릿 무시하고 딱 하나의 제목만 보여줘야 할 때 유용합니다.\n2. `title.default`는 여러 자식 라우트에 일괄적인 기본 타이틀을 넣고 싶을 때 딱이죠.\n3. SEO 관점에서 각 페이지에 맞는 고유한 타이틀을 갖는 것이 좋지만, 없을 때 기본 타이틀을 두는 것도 좋은 습관입니다.\n\n이렇게 `metadata`의 `title` 옵션을 잘 활용하면, 중복되는 코드 없이 깔끔하게 제목을 관리할 수 있어서 프로젝트가 더 효율적으로 운영돼요. 다음 번 Next.js 프로젝트에 꼭 적용해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 title.template을 활용하면 자식 라우트 세그먼트에 정의된 타이틀에 접두사나 접미사를 쉽게 붙일 수 있어요. 예를 들어, 자식 페이지의 타이틀에 ' | Acme'라는 접미사를 자동으로 붙이는 방식이죠.\n\n```js\nimport type { Metadata } from 'next'\n\nexport const metadata: Metadata = {\n  title: {\n    template: '%s | Acme',\n    default: 'Acme', // template을 쓸 때는 default 타이틀이 꼭 필요해요.\n  },\n}\n```\n\n그리고 자식 라우트에서는 이렇게 타이틀을 선언하면 아래처럼 렌더링 됩니다:\n\n```js\nimport type { Metadata } from 'next'\n\nexport const metadata: Metadata = {\n  title: 'About',\n}\n\n// 결과 : \u003ctitle\u003eAbout | Acme\u003c/title\u003e\n```\n\n### 이 점 꼭 기억하세요!\n- `title.template`은 자기 자신이 속한 라우트 세그먼트가 아니라 *자식* 라우트 세그먼트에만 적용돼요.\n- 그래서 template을 사용할 때는 `title.default`를 반드시 설정해야 합니다.\n- `layout.js` 안에서 `title.template`을 정의해도, 같은 라우트 세그먼트에 있는 `page.js`의 타이틀에는 적용되지 않아요.\n- `page.js`에서 `title.template`을 정의해봤자 무의미해요, 페이지는 항상 마지막 세그먼트이기 때문이죠. 즉, 자식 라우트가 없으니 template이 적용될 곳이 없다는 이야기입니다.\n- 타이틀이나 기본 타이틀(`title` 또는 `title.default`)을 아예 정의하지 않은 라우트에는 template이 먹히지 않아요.\n\n---\n\n### 추가 팁!\n`title.template`을 잘 활용하면 사이트 전체의 타이틀 포맷을 통일하기 쉽고, SEO 관리에도 유리합니다. 예를 들어, 블로그 포스트마다 글 제목 뒤에 ' | 내 블로그명'을 붙이고 싶을 때 유용하죠. 게다가 유지보수하기도 정말 편해져요. 타이틀 형식을 하나만 바꾸면 모든 자식 페이지에 바로 반영되니까요.\n\n혹시 라우트 구조가 복잡해서 타이틀 설정이 어려운 경우, `layout.js`와 `page.js`의 역할을 다시 한 번 점검해보면서 어느 위치에 타이틀 관련 코드를 넣어야 할지 고민해보는 걸 추천드려요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n`title.absolute`는 부모 세그먼트에 설정된 `title.template`을 무시하고, 절대적인 제목을 지정할 때 사용할 수 있어요. 쉽게 말해, 부모에서 정의한 제목 형식을 적용하지 않고 내가 원하는 제목을 딱 하나만 보여줄 수 있다는 뜻이죠.\n\n예를 들어, 아래처럼 `metadata`에 `template`을 설정해 두면…\n\n```js\nimport type { Metadata } from 'next'\n\nexport const metadata: Metadata = {\n  title: {\n    template: '%s | Acme',\n  },\n}\n```\n\n아래처럼 `absolute`를 쓰면, 부모가 세팅한 `%s | Acme` 형식을 무시하고 그냥 'About'이라는 제목만 보여줍니다.\n\n```js\nimport type { Metadata } from 'next'\n\nexport const metadata: Metadata = {\n  title: {\n    absolute: 'About',\n  },\n}\n\n// 출력 결과: \u003ctitle\u003eAbout\u003c/title\u003e\n```\n\n---\n\n### 알아두면 좋은 점 정리\n\n| 위치       | 속성              | 설명                                                                                                                                                         |\n|------------|-------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **layout.js** | `title` (string), `title.default` | 자식 세그먼트 중 제목을 따로 정하지 않은 곳에 기본 제목을 제공합니다. 부모의 `title.template`이 있으면 그 형식을 덧붙여서 보여줘요.                              |\n|            | `title.absolute`  | 자식 세그먼트에 기본 제목을 설정하지만, 부모의 `title.template`을 무시합니다. 즉, 깔끔하게 절대 제목만 보여줘요.                                                  |\n|            | `title.template`  | 자식 세그먼트용 새로운 제목 템플릿을 정의합니다.                                                                                                               |\n| **page.js**  | `title` (string)  | 페이지(라우트)의 제목을 정의합니다. 부모의 `title.template`이 있으면 같이 적용돼요.                                                                           |\n|            | `title.absolute`  | 페이지 제목을 절대적으로 지정하며, 부모의 `title.template`을 무시합니다.                                                                                       |\n|            | `title.template`  | 적용되지 않습니다. 페이지는 항상 라우트의 마지막 세그먼트여서 템플릿을 사용할 수 없어요.                                                                        |\n\n---\n\n### 좀 더 살펴보기!\n\n- `title.template`은 `%s` 자리에 해당 제목이 들어가도록 포맷을 만들어 줄 때 씁니다. 예를 들어, `'%s | 내 사이트'` 같은 형태죠. 그래서 자식 세그먼트에서 제목만 정의하면 자동으로 `| 내 사이트`가 붙어요.\n- 반면 `title.absolute`는 그냥 깨끗하게 제목을 바꿔야 할 때 편리합니다. 예를 들어, \"특별한 이벤트 페이지\" 같이 이름만 딱 보여줘야 할 때 `title.template`을 쓰면 `특별한 이벤트 페이지 | 내 사이트`처럼 길어질 수 있는데 그걸 막아줍니다.\n- layout 단위에서 잘 설계하면, 사이트 전체 제목 구조를 관리하기가 훨씬 수월해져요. 기본 템플릿은 내비두고, 특수 페이지에서만 `absolute`로 자유롭게 제목을 정하는 게 흔한 패턴입니다.\n\n다시 요약하자면, `title.absolute`는 부모 제목 템플릿을 무시하고 딱 하나의 제목을 화면에 보여주고 싶을 때 사용하는 옵션이에요. next.js 앱에서 제목 관리할 때 요긴하게 쓰이니 기억해 두시면 좋아요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### description 설명\n\n```js\nexport const metadata = {\n  description: 'The React Framework for the Web',\n}\n```\n\n위 코드는 자바스크립트에서 `metadata`라는 객체에 웹 페이지나 앱의 설명(description)을 정의한 예시입니다. React나 Next.js 같은 프레임워크에서 메타데이터를 설정할 때 흔히 볼 수 있죠.\n\n```html\n\u003cmeta name=\"description\" content=\"The React Framework for the Web\" /\u003e\n```\n\n위 태그는 HTML `\u003chead\u003e` 영역에 들어가는 메타 태그로, 브라우저나 검색엔진이 페이지를 이해할 때 참고하는 설명을 담고 있어요. SEO(Search Engine Optimization)에도 꼭 필요한 부분이죠.\n\n---\n\n### 왜 description이 중요할까?\n\n- **검색 결과 노출**: 구글이나 네이버 같은 검색엔진에서 내 페이지가 어떤 내용을 담고 있는지 설명해주기 때문에 검색 결과에 노출될 때 보이는 요약문으로 활용돼요.\n- **사용자 클릭 유도**: 매력적인 설명은 검색 사용자들이 내 페이지를 클릭하도록 유도할 수 있어요.\n- **공유 시 정보 제공**: SNS나 메신저에 링크를 공유할 때도 이 description이 설명으로 사용됩니다.\n\n---\n\n### Basic Fields\n\n웹 메타데이터에는 description 외에도 여러 기본 필드들이 있어요. 대표적인 기본 필드를 표로 정리해볼게요.\n\n| 필드명          | 설명                             | 예시                                |\n|----------------|--------------------------------|-----------------------------------|\n| title          | 페이지의 제목                   | \"React로 만드는 웹 어플리케이션\"   |\n| description    | 페이지 설명                    | \"The React Framework for the Web\" |\n| keywords       | 검색 키워드 (요즘엔 덜 쓰임)  | \"React, JavaScript, Web Framework\"|\n| author         | 작성자 이름                   | \"홍길동\"                           |\n| viewport       | 화면 크기의 기본 설정          | \"width=device-width, initial-scale=1\" |\n\n---\n\n### 팁: 메타데이터 잘 활용하는 법\n\n1. **각 페이지마다 고유한 description 작성하기**  \n   똑같은 설명을 여러 페이지에 쓰면 SEO에 좋지 않아요. 페이지마다 내용을 잘 반영해서 개성있게 써보세요.\n\n2. **길이 조절**  \n   너무 길면 검색 결과에서 잘리니까 150~160자 정도로 간결하게 작성하세요.\n\n3. **중요 키워드 포함하기**  \n   설명 안에 주요 키워드를 자연스럽게 넣으면 검색엔진에서 더 잘 인식합니다.\n\n---\n\n이렇게 메타테이터의 `description` 필드는 쉽지만 굉장히 중요한 부분이에요. 제대로 설정해두면 검색엔진에서의 인지도도 쑥쑥 올라가니 꼭 신경 써주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안녕하세요! 오늘은 Next.js에서 메타데이터를 관리하는 방법에 대해서 이야기해볼게요. 특히 metadata 객체를 통해 SEO에 중요한 여러 정보를 한 번에 설정하는 방법과, 이 정보가 실제로 HTML 메타 태그로 어떻게 변환되는지 살펴보겠습니다.\n\n먼저, Next.js에서 사용하는 metadata 객체를 보면 다음과 같아요:\n\n```js\nexport const metadata = {\n  generator: 'Next.js',\n  applicationName: 'Next.js',\n  referrer: 'origin-when-cross-origin',\n  keywords: ['Next.js', 'React', 'JavaScript'],\n  authors: [{ name: 'Seb' }, { name: 'Josh', url: 'https://nextjs.org' }],\n  creator: 'Jiachi Liu',\n  publisher: 'Sebastian Markbåge',\n  formatDetection: {\n    email: false,\n    address: false,\n    telephone: false,\n  },\n}\n```\n\n이렇게 설정해 주면 Next.js가 내부적으로 아래와 같은 메타 태그로 변환해주게 되죠:\n\n| 태그 종류               | 내용                                                             |\n|----------------------|----------------------------------------------------------------|\n| `\u003cmeta name=\"application-name\" content=\"Next.js\" /\u003e` | 애플리케이션 이름을 지정해요.                                      |\n| `\u003cmeta name=\"author\" content=\"Seb\" /\u003e`               | 저자 이름 (Seb)                                                  |\n| `\u003clink rel=\"author\" href=\"https://nextjs.org\" /\u003e`    | 저자 관련 URL (Josh의 프로필 링크)                               |\n| `\u003cmeta name=\"author\" content=\"Josh\" /\u003e`               | 저자 이름 (Josh)                                                 |\n| `\u003cmeta name=\"generator\" content=\"Next.js\" /\u003e`        | 생성 도구 (Next.js)                                              |\n| `\u003cmeta name=\"keywords\" content=\"Next.js,React,JavaScript\" /\u003e` | 주요 키워드                                                    |\n| `\u003cmeta name=\"referrer\" content=\"origin-when-cross-origin\" /\u003e` | 리퍼러 정책 설정                                               |\n| `\u003cmeta name=\"color-scheme\" content=\"dark\" /\u003e`        | 컬러 스킴 (다크 모드)                                            |\n| `\u003cmeta name=\"creator\" content=\"Jiachi Liu\" /\u003e`        | 콘텐츠 제작자                                                     |\n| `\u003cmeta name=\"publisher\" content=\"Sebastian Markbåge\" /\u003e` | 콘텐츠 배급자                                                  |\n| `\u003cmeta name=\"format-detection\" content=\"telephone=no, address=no, email=no\" /\u003e` | 자동 전화번호, 주소, 이메일 인식 비활성화 |\n\n### 여기서 중요한 점!\n\n- `authors` 배열 안에 객체를 넣으면 저자 정보뿐 아니라, URL 같은 추가 속성도 넣을 수 있다는 점!\n- `formatDetection` 설정은 요즘 모바일에서 전화번호, 주소, 이메일 자동 링크 걸리는 걸 방지할 때 많이 쓰여요. 예를 들어, 아이폰은 자동으로 전화번호 인식을 하는데, 이걸 끄고 싶으면 metadata에 이렇게 설정하면 돼요.\n- `referrer`는 보안을 위해서 추천하는 정책 중 하나예요.\n\n---\n\n### metadataBase란?\n\n마지막으로 metadataBase라는 옵션에 대해 간단히 짚고 넘어갈게요.\n\nmetadataBase는 메타데이터에 사용하는 URL들이 절대 경로(완전한 URL)를 요구할 때, 기본 URL을 한 번에 지정해주는 편리한 옵션이에요.\n\n예를 들어, 메타 태그에 이미지 URL을 넣거나 OG(Open Graph) 태그에 링크를 넣을 때 다음처럼 활용할 수 있죠:\n\n```js\nexport const metadataBase = new URL('https://example.com')\n```\n\n이렇게 설정하면 상대 경로인 `/image.png`가 자동으로 `https://example.com/image.png`로 변환되어서 출력됩니다. 굉장히 편하죠?\n\n---\n\n### 맺으며\n\nNext.js의 메타데이터 설정은 기본적인 SEO는 물론이고, 사용자 경험 개선에도 큰 도움이 됩니다. 이런 메타 정보를 꼼꼼하게 관리하는 습관이 좋은 웹사이트를 만드는 첫걸음이니 꼭 활용해보세요!\n\n필요하다면 Open Graph, Twitter Card 같은 SNS용 메타 태그도 같이 설정할 수 있으니, 다음 글에서는 그런 부분도 다뤄볼게요~!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nmetadataBase 옵션에 대해 한 번 쉽게 정리해볼게요!\n\n---\n\n### metadataBase가 뭘까?\n\n`metadataBase`는 URL 기반 메타데이터를 만들 때, **절대 URL 대신 상대 경로를 쓸 수 있게 해주는 옵션**이에요.  \n예를 들어 `images: '/og-image.png'`라고 하면, 이 상대 경로가 `metadataBase`에 써둔 기본 URL과 합쳐져서 완전한 URL(`https://acme.com/og-image.png`)을 만들어줍니다.\n\n---\n\n### 사용 예시\n\n```js\nexport const metadata = {\n  metadataBase: new URL('https://acme.com'),\n  alternates: {\n    canonical: '/',\n    languages: {\n      'en-US': '/en-US',\n      'de-DE': '/de-DE',\n    },\n  },\n  openGraph: {\n    images: '/og-image.png',\n  },\n}\n```\n\n위처럼 쓰면 Next.js가 최종 HTML에 다음과 같이 출력해줘요:\n\n```html\n\u003clink rel=\"canonical\" href=\"https://acme.com\" /\u003e\n\u003clink rel=\"alternate\" hreflang=\"en-US\" href=\"https://acme.com/en-US\" /\u003e\n\u003clink rel=\"alternate\" hreflang=\"de-DE\" href=\"https://acme.com/de-DE\" /\u003e\n\u003cmeta property=\"og:image\" content=\"https://acme.com/og-image.png\" /\u003e\n```\n\n---\n\n### 알아두면 좋은 팁!\n\n| 내용 | 설명 |\n|---|---|\n| 일반적으로 어디에 설정하나요? | `metadataBase`는 보통 `root app/layout.js`에 설정해서 모든 라우트에 적용합니다. |\n| 어떤 필드에 적용되나요? | 절대 URL이 필요한 URL 기반 메타데이터들에 적용돼요. (Open Graph 이미지, canonical 링크, hreflang 등) |\n| 복잡한 URL도 가능해요 | 서브도메인 포함(`https://app.acme.com`)이나, 베이스 경로 포함도 가능(`https://acme.com/start/from/here`)해요. |\n| 절대 URL 쓰면? | 해당 필드는 `metadataBase`를 무시하고 절대 URL을 그대로 씁니다. |\n| `metadataBase` 없으면 어떻게 되나요? | 상대 경로를 쓸 때 에러가 납니다. 빌드 오류가 나니까 꼭 설정해줘야 해요! |\n| 슬래시 중복 처리 | `metadataBase`가 끝에 슬래시(`/`) 있어도, 상대경로가 앞에 슬래시 있어도 자동으로 정리해서 `//`가 생기지 않아요! |\n\n---\n\n### 마무리\n\n`metadataBase`는 앱 전체 메타데이터를 관리할 때 정말 편리한 옵션이에요.  \n특히 도메인이 바뀌거나 서브도메인이 추가될 때 한 곳만 바꾸면 되니까 유지보수도 쉬워집니다!\n\n---\n\n도움이 됐다면 좋겠네요~ 다음에 더 재미있는 개발 이야기로 찾아올게요! 😄\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n#### 기본값(Default value)\n\n`metadataBase`를 따로 설정하지 않으면 기본값이 자동으로 지정돼요.\n\n\u003e **Vercel 환경 기준:**\n\u003e - 프로덕션 배포에서는 `VERCEL_PROJECT_PRODUCTION_URL` 값을 사용해요.\n\u003e - 프리뷰 배포에서는 `VERCEL_BRANCH_URL`이 우선시 되고, 이 값이 없으면 `VERCEL_URL`을 사용합니다.\n\u003e \n\u003e 만약 위 환경 변수들이 없다면 기본값은 `http://localhost:${process.env.PORT || 3000}`이 됩니다. 이 덕분에 Open Graph 이미지가 로컬 환경에서 테스트할 때부터 Vercel 프리뷰, 프로덕션 환경 모두에서 잘 작동해요.\n\u003e\n\u003e 기본값을 덮어쓰고 싶다면, 환경 변수를 이용해 URL을 컴퓨팅하는 걸 추천해요. 이렇게 하면 개발(local), 스테이징, 프로덕션 환경에 맞춰 유동적으로 URL을 관리할 수 있어서 훨씬 편리하답니다.\n\u003e \n\u003e 참고로, Vercel 관련 환경 변수는 [System Environment Variables](https://vercel.com/docs/concepts/projects/environment-variables#system-environment-variables) 문서에서 자세히 확인할 수 있어요.\n\n#### URL 구성(URL Composition)  \n(여기에서는 URL을 어떻게 조합하는지에 관한 내용이 나올 것 같네요. 필요하면 추가 설명해 드릴게요!)\n\n---\n\n추가 팁:  \n`metadataBase`를 잘 활용하면 SEO, 소셜 미디어 공유 등에 쓰이는 Open Graph, Twitter Card 메타데이터 설정이 훨씬 편리해집니다. 특히, 여러 환경에 맞게 URL이 자동으로 바뀌니까 관리 부담도 줄어들죠!  \n환경 변수 설정을 깜빡하지 말고, `.env` 파일 같은 곳에서 꼼꼼히 관리해 주세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nURL 구성을 할 때, 개발자가 의도한 경로를 우선시하는 특징이 있습니다. 여기서 기본 디렉토리 탐색 방식과는 다르게 작동한다고 보면 돼요.\n\n- `metadataBase`와 `metadata` 필드 사이에 있는 **슬래시(/)**는 자동으로 정리(정규화)돼요. 그래서 경로가 어색하게 겹치거나 빠지는 일이 없죠.\n- 그리고 일반적으로 URL 전체 경로를 대체하는 절대 경로(`/`로 시작하는 경로)가 들어와도, 이걸 \"상대 경로\"로 해석해서 `metadataBase`의 끝부분부터 시작하는 경로로 간주해요.\n\n### 예를 들어, 아래처럼 `metadataBase`를 설정했다고 가정해보죠:\n\n```js\nimport type { Metadata } from 'next'\n\nexport const metadata: Metadata = {\n  metadataBase: new URL('https://acme.com'),\n}\n```\n\n이 경우, 만약 `metadata` 안에서 절대 경로처럼 보이는 `/about`이나 `/team` 같은 경로를 넣더라도, 실제로는 `https://acme.com/about`, `https://acme.com/team` 이런 식으로 `metadataBase`를 바탕으로 경로가 완성됩니다. \n\n이는 URL 조합 시 헷갈릴 수 있는 슬래시 중복 문제나, 경로가 엉뚱하게 바뀌는 문제를 방지해줘서 개발자가 의도한 URL을 정확하게 만들 수 있도록 도와줍니다.\n\n---\n\n추가로, Next.js에서 `metadataBase`를 사용하는 이유는 **SEO 최적화와 메타데이터 관리**를 좀 더 깔끔하고 명확하게 하기 위해서예요. 이걸 잘 활용하면 외부 링크나 공유할 때도 주소가 예상대로 동작해서 유용하니, 프로젝트에 맞게 꼭 써보길 추천합니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위에서 설명한 `metadataBase`를 상속받아 개별 메타데이터 필드가 자신의 값을 설정할 때, URL은 다음과 같이 해석돼요:\n\n| `metadata` 필드      | 해석된 URL                       |\n|---------------------|---------------------------------|\n| `/`                 | `https://acme.com`               |\n| `./`                | `https://acme.com`               |\n| `payments`          | `https://acme.com/payments`      |\n| `/payments`         | `https://acme.com/payments`      |\n| `./payments`        | `https://acme.com/payments`      |\n| `../payments`       | `https://acme.com/payments`      |\n| `https://beta.acme.com/payments` | `https://beta.acme.com/payments` |\n\n즉, 상대 경로를 적더라도 `metadataBase`가 `https://acme.com`이라면, 결국 그 기준에서 최종 URL이 해석된다는 뜻이에요. 완전한 절대 URL을 제공하면 그대로 사용되고, 상대 경로라면 기본 베이스를 기준으로 합쳐지게 되죠.\n\n---\n\n### openGraph 메타데이터 예시\n\n```js\nexport const metadata = {\n  openGraph: {\n    title: 'Next.js',\n    description: 'The React Framework for the Web',\n    url: 'https://nextjs.org',\n    siteName: 'Next.js',\n    images: [\n      {\n        url: 'https://nextjs.org/og.png', // 반드시 절대 URL이어야 해요.\n        width: 800,\n        height: 600,\n      },\n      {\n        url: 'https://nextjs.org/og-alt.png',\n        width: 1800,\n        height: 1600,\n        alt: 'My custom alt', // 이미지가 로드 안 될 때 대체 텍스트용\n      },\n    ],\n    videos: [\n      {\n        url: 'https://nextjs.org/video.mp4', // 절대 URL 필수\n        width: 800,\n        height: 600,\n      },\n    ],\n    audio: [\n      {\n        url: 'https://nextjs.org/audio.mp3', // 절대 URL이어야 함\n      },\n    ],\n    locale: 'en_US',\n    type: 'website',\n  },\n}\n```\n\nOpen Graph 메타데이터는 페이스북, 트위터 같은 소셜 미디어에서 공유할 때 정보가 풍부하게 나타나도록 도와줘요. 예를 들어, 사이트 제목, 설명, 메인 URL 뿐만 아니라 이미지, 동영상, 오디오까지 확장해서 넣을 수 있죠. 특히 이미지의 경우, 절대경로 URL을 사용하는 게 중요하고, 크기 정보와 대체 텍스트도 넣어주는 게 좋아요. 그래야 소셜 미디어가 올바르게 콘텐츠를 표시하거든요.\n\n또, `locale` 속성은 콘텐츠 언어나 지역을 지정하는데, 이를 통해 다른 국가나 언어권에서 맞춤형으로 보이게 할 수 있어요. `type`은 공유하는 콘텐츠의 유형을 지정하는데, 예를 들어 `website`, `article`, `video.movie` 등이 있어요.\n\n이렇게 메타데이터를 꼼꼼히 설정하면, 검색엔진 최적화(SEO)와 소셜 미디어에서의 콘텐츠 노출이 훨씬 좋아지니 꼭 활용해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n오늘은 웹 페이스북, 트위터 등 소셜 미디어에서 내 사이트가 어떻게 보일지 정하는 데 핵심 역할을 하는 'Open Graph(OG) 메타태그'에 대해 얘기해보려고 해요. 그리고 Next.js에서 이걸 어떻게 손쉽게 다룰 수 있을지도 소개합니다.\n\n---\n\n## 1. 기본적인 Open Graph 메타태그 구조\n\n웹 문서 `\u003chead\u003e` 안에 아래처럼 메타 태그를 넣으면, SNS에서 내 페이지가 공유될 때 제목, 설명, 이미지, 사이트 이름 등 다양한 정보를 잘 보여줄 수 있어요.\n\n```html\n\u003cmeta property=\"og:title\" content=\"Next.js\" /\u003e\n\u003cmeta property=\"og:description\" content=\"The React Framework for the Web\" /\u003e\n\u003cmeta property=\"og:url\" content=\"https://nextjs.org/\" /\u003e\n\u003cmeta property=\"og:site_name\" content=\"Next.js\" /\u003e\n\u003cmeta property=\"og:locale\" content=\"en_US\" /\u003e\n\u003cmeta property=\"og:image\" content=\"https://nextjs.org/og.png\" /\u003e\n\u003cmeta property=\"og:image:width\" content=\"800\" /\u003e\n\u003cmeta property=\"og:image:height\" content=\"600\" /\u003e\n\u003cmeta property=\"og:image\" content=\"https://nextjs.org/og-alt.png\" /\u003e\n\u003cmeta property=\"og:image:width\" content=\"1800\" /\u003e\n\u003cmeta property=\"og:image:height\" content=\"1600\" /\u003e\n\u003cmeta property=\"og:image:alt\" content=\"My custom alt\" /\u003e\n\u003cmeta property=\"og:video\" content=\"https://nextjs.org/video.mp4\" /\u003e\n\u003cmeta property=\"og:video:width\" content=\"800\" /\u003e\n\u003cmeta property=\"og:video:height\" content=\"600\" /\u003e\n\u003cmeta property=\"og:audio\" content=\"https://nextjs.org/audio.mp3\" /\u003e\n\u003cmeta property=\"og:type\" content=\"website\" /\u003e\n```\n\n\u003e 여기서 중요한 점은 여러 개의 og:image 태그를 넣을 수 있다는 거예요! 이렇게 하면 SNS에서 선택적으로 보여줄 이미지가 다양해져서 좀 더 풍성한 미리보기를 만들 수 있죠.\n\n---\n\n## 2. 포스트 형식 메타태그 예시\n\n블로그 글이나 뉴스 같은 ‘article’ 타입엔 아래처럼 좀 더 구체적인 메타 정보(작성일, 작성자 등)를 추가할 수 있어요.\n\n```html\n\u003cmeta property=\"og:title\" content=\"Next.js\" /\u003e\n\u003cmeta property=\"og:description\" content=\"The React Framework for the Web\" /\u003e\n\u003cmeta property=\"og:type\" content=\"article\" /\u003e\n\u003cmeta property=\"article:published_time\" content=\"2023-01-01T00:00:00.000Z\" /\u003e\n\u003cmeta property=\"article:author\" content=\"Seb\" /\u003e\n\u003cmeta property=\"article:author\" content=\"Josh\" /\u003e\n```\n\n여기서도 작성자가 여러 명일 경우, author 태그를 여러 개 넣으면 됩니다.\n\n---\n\n## 3. Next.js 메타데이터 API로 간단하게 쓰기\n\nNext.js 13부터 파일 기반 메타데이터 API 덕분에 이런 메타 태그를 자바스크립트 오브젝트 형태로 쉽게 선언 가능해요:\n\n```js\nexport const metadata = {\n  openGraph: {\n    title: 'Next.js',\n    description: 'The React Framework for the Web',\n    type: 'article',\n    publishedTime: '2023-01-01T00:00:00.000Z',\n    authors: ['Seb', 'Josh'],\n  },\n}\n```\n\n이렇게만 하면 Next.js가 알아서 위의 `\u003cmeta\u003e` 태그들을 자동으로 만들어 줍니다. 훨씬 편하죠?\n\n---\n\n## 4. 꿀팁: 이미지 메타데이터는 파일 기반 API 활용하기\n\nOpen Graph 이미지 메타정보를 직접 관리하는 건 정말 귀찮거든요. 예를 들어 이미지 파일이 바뀌거나 경로가 바뀌면 메타데이터도 수동으로 바꿔줘야 해서 실수가 잦아요.\n\nNext.js 파일 기반 메타데이터 API를 사용하면:\n\n- 실제 파일 시스템에서 이미지를 가져와서 맞는 크기, 타입 등을 자동으로 계산해줘요.\n- 중복되거나 엉뚱한 메타 태그 생성을 방지해줘서 안정적입니다.\n\n공식 문서를 참고해서 이미지 파일을 같이 관리하는 패턴으로 바꾸면 개발 생산성이 올라가니 꼭 써보세요!\n\n---\n\n## 마무리\n\n- OG 태그는 SNS 공유 시 내 사이트가 멋지게 보이도록 만드는 필수 요소예요.\n- 기본 태그부터 기사형 태그까지 상황에 맞게 넣으면 좋아요.\n- Next.js 13 이상의 메타데이터 API를 활용하면 작업이 훨씬 수월해집니다.\n- 이미지 메타 정보는 파일 기반 API를 이용해 관리하세요.\n\n웹사이트를 좀 더 프로페셔널하게 보이게 만드는 작은 팁! 여러분의 프로젝트에도 꼭 적용해 보시길 바랍니다. 다음에도 좋은 웹 개발 이야기로 찾아올게요! 😄\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### robots 메타 태그 설정하기\n\nNext.js에서 SEO를 신경 쓸 때, `metadata` 객체의 `robots` 속성을 잘 활용하면 구글봇 같은 검색 엔진 크롤러들에게 페이지 인덱싱 방법을 알려줄 수 있어요. 예를 들어 아래처럼 설정할 수 있죠:\n\n```js\nimport type { Metadata } from 'next'\n \nexport const metadata: Metadata = {\n  robots: {\n    index: true, // 페이지를 인덱싱 하라고 명시\n    follow: true, // 페이지 내 링크들도 크롤링 하도록 허용\n    nocache: false, // 캐싱 하지 말라는 지시어(false면 캐시 가능)\n    googleBot: { // 구글봇에 대한 세부 설정\n      index: true,\n      follow: true,\n      noimageindex: false, // 이미지 인덱싱 허용\n      'max-video-preview': -1, // 비디오 미리보기 무제한\n      'max-image-preview': 'large', // 큰 이미지 미리보기 허용\n      'max-snippet': -1, // 스니펫 길이 제한 없음\n    },\n  },\n}\n```\n\n이걸 HTML meta 태그로 나타내면 아래와 같아요:\n\n```html\n\u003cmeta name=\"robots\" content=\"index, follow\" /\u003e\n\u003cmeta\n  name=\"googlebot\"\n  content=\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"\n/\u003e\n```\n\n\u003e **팁!**  \n\u003e robots 메타 태그는 SEO에 아주 중요한 역할을 해요.  \n\u003e - `index, follow`는 기본적으로 페이지와 링크들을 모두 크롤링해서 인덱싱하라는 뜻이고,  \n\u003e - `noindex`를 쓰면 검색결과에서 제외되기도 하니 주의가 필요해요.  \n\u003e  \n\u003e 구글봇에 따로 설정을 줄 수 있다는 점도 기억해두면 좋습니다.  \n\u003e 맞춤형 SEO가 필요할 때 활용하기 딱 좋거든요.\n\n다음은 아이콘 관련 설정으로 넘어가 볼게요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n좋은 소식! 아이콘 설정할 때 되도록이면 파일 기반의 Metadata API를 사용하는 걸 추천해요. 설정 파일과 실제 아이콘 파일을 일일이 맞출 필요 없이, 이 API가 알아서 올바른 메타데이터를 생성해주거든요. 덕분에 실수도 줄고 관리도 편해져요.\n\n예를 들어, 아래처럼 간단하게 아이콘 경로만 지정해주면:\n\n```js\nexport const metadata = {\n  icons: {\n    icon: '/icon.png',\n    shortcut: '/shortcut-icon.png',\n    apple: '/apple-icon.png',\n    other: {\n      rel: 'apple-touch-icon-precomposed',\n      url: '/apple-touch-icon-precomposed.png',\n    },\n  },\n}\n```\n\n이렇게 실제 HTML 메타 태그가 자동으로 생성되죠:\n\n```html\n\u003clink rel=\"shortcut icon\" href=\"/shortcut-icon.png\" /\u003e\n\u003clink rel=\"icon\" href=\"/icon.png\" /\u003e\n\u003clink rel=\"apple-touch-icon\" href=\"/apple-icon.png\" /\u003e\n\u003clink rel=\"apple-touch-icon-precomposed\" href=\"/apple-touch-icon-precomposed.png\" /\u003e\n```\n\n여기서 아이콘을 더 다양한 상황에 맞게 세분화해서 지정할 수도 있어요. 예를 들면 다크모드용 아이콘이나 여러 크기의 아이콘 등도 말이죠:\n\n```js\nexport const metadata = {\n  icons: {\n    icon: [\n      { url: '/icon.png' },\n      new URL('/icon.png', 'https://example.com'), // 절대 URL도 가능해요\n      { url: '/icon-dark.png', media: '(prefers-color-scheme: dark)' }, // 다크모드 전용 아이콘\n    ],\n    shortcut: ['/shortcut-icon.png'], // 배열 형태로도 지원하고\n    apple: [\n      { url: '/apple-icon.png' },\n      { url: '/apple-icon-x3.png', sizes: '180x180', type: 'image/png' }, // 크기와 타입 지정\n    ],\n    other: [\n      {\n        rel: 'apple-touch-icon-precomposed',\n        url: '/apple-touch-icon-precomposed.png',\n      },\n    ],\n  },\n}\n```\n\n잘 보시면, 각 아이콘에 크기, 미디어 쿼리, 타입 등 상황에 맞는 세부 옵션을 넣을 수 있어서 훨씬 유연하게 아이콘을 관리할 수 있어요. 특히 요즘 다크모드 지원이 필수인 만큼 `(prefers-color-scheme: dark)` 같은 미디어 쿼리를 활용하는 게 중요합니다.\n\n아이콘 설정은 웹사이트의 첫인상에도 영향을 주니 꼼꼼하게 세팅해두면 좋아요! 나중에 favicon이 제대로 안 보인다고 당황하지 말고, 이런 메타데이터 API를 활용해보세요. 관리가 훨씬 쉬워질 거랍니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위 코드는 웹사이트에서 자주 사용하는 아이콘과 메타 태그 설정 부분인데요, HTML `\u003clink\u003e` 태그를 이용해 파비콘(favicon), 애플 터치 아이콘을 등록하는 예시입니다.\n\n간단히 설명드리자면,\n\n- `\u003clink rel=\"shortcut icon\" href=\"/shortcut-icon.png\" /\u003e`: 가장 일반적인 파비콘 설정.\n- `\u003clink rel=\"icon\" href=\"/icon.png\" /\u003e`: 파비콘 설정 (기본).\n- `\u003clink rel=\"icon\" href=\"https://example.com/icon.png\" /\u003e`: 외부 URL에 있는 아이콘 설정 가능.\n- `\u003clink rel=\"icon\" href=\"/icon-dark.png\" media=\"(prefers-color-scheme: dark)\" /\u003e`: 다크 모드일 때 사용할 파비콘.\n- `\u003clink rel=\"apple-touch-icon\" href=\"/apple-icon.png\" /\u003e` 및 관련 태그들: 아이폰, 아이패드 등 iOS 기기 홈 화면에 추가할 때 쓰이는 아이콘.\n\n이 부분에서 알아두면 좋은 점 몇 가지!\n\n| 항목 | 설명 |\n| --- | --- |\n| msapplication-* 메타 태그 | MS Edge(Chromium 기반)에서는 더 이상 지원하지 않으니 추가할 필요 없음 |\n| themeColor 옵션 | Next.js 14부터는 `themeColor`가 deprecated 되었고, 대신 `viewport` 설정을 권장 |\n\n📌 특히 다크 모드용으로 별도 파비콘을 설정한다든지, 애플 터치 아이콘에 사이즈를 명시해서 다양한 기기 대응을 하는 점이 요즘 트렌드고, 사용자 경험을 더 좋게 만듭니다.\n\n---\n\n\u003e **추가 팁!**  \n\u003e 아이콘은 해상도가 높은 걸 준비하는 게 유리해요. 예를 들어 180x180 사이즈 정도면 모바일 기기에서 깨끗하게 보이고, 더 큰 아이콘을 준비하면 고화질 디스플레이에서 유용하죠.  \n\u003e 또, `manifest.json` 파일과 연동해 PWA(Progressive Web App)를 만들 때에도 아이콘 설정이 중요합니다.\n\n이렇게 설정을 해두면, 다양한 브라우저와 디바이스에서 잘 작동하는 멋진 사이트 아이콘을 가질 수 있습니다! 필요하다면 상황에 맞게 `rel`이나 `sizes` 같은 속성도 조절해 보세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### colorScheme\n\n\u003e 더 이상 권장되지 않아요: Next.js 14부터는 metadata에서 `colorScheme` 옵션이 deprecated 되었어요. 대신에 **viewport 설정**을 사용하라고 하네요.\n\n사실 `colorScheme`은 라이트 모드, 다크 모드 같은 테마를 간단하게 지정할 때 쓰였는데, 이제는 Next.js가 좀 더 유연하게 뷰포트 기반으로 처리하기 때문에 바뀐 거예요. 만약 이전에 `colorScheme` 쓰고 있었다면, 이제는 `viewport` 설정을 어떻게 주는지 살펴보는 걸 추천해요!\n\n---\n\n### manifest\n\n웹 애플리케이션 매니페스트(manifest)는 웹 앱이 네이티브 앱처럼 동작할 수 있도록 도와주는 **설정 파일**이에요.  \n말 그대로, 앱 이름, 아이콘, 시작 URL, 화면 회전 방식 등 사용자 경험에 관련된 여러 정보를 JSON 형태로 정의해두는 거죠.\n\n이 매니페스트는 [Web Application Manifest 사양](https://developer.mozilla.org/en-US/docs/Web/Manifest)을 따르는데, 이를 통해 브라우저가 앱 설치 시 어떤 모습으로 표시할지, 시작할 때 어떤 화면크기로 열지 같은 걸 알 수 있어요.\n\n---\n\n추가로, Next.js에서 이 매니페스트를 다룰 때는 `public` 폴더에 `manifest.json` 파일을 넣고, 이걸 기본 HTML에 링크해주면 끝!  \n```html\n\u003clink rel=\"manifest\" href=\"/manifest.json\" /\u003e\n```\n\n이렇게 하면 PWA(Progressive Web App)로서 한 단계 더 발전시킬 수 있으니, 관심 있으면 한번 도전해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안녕하세요 여러분! 이번에는 웹앱이나 사이트에서 자주 사용되는 `manifest` 관련 설정과 트위터 메타데이터에 대해 살펴볼게요.\n\n---\n\n먼저, Next.js 같은 프레임워크에서 `manifest`를 설정하는 방법입니다. 아래 코드는 `metadata` 객체 안에 `manifest` 속성을 넣는 예시인데요,\n\n```js\nexport const metadata = {\n  manifest: 'https://nextjs.org/manifest.json',\n}\n```\n\n이렇게 하면 Next.js가 이 `manifest.json` 파일을 웹 앱의 매니페스트로 인식해줍니다.\n\n---\n\n기존 HTML에서는 아래처럼 `\u003clink\u003e` 태그로 `manifest`를 연결했죠.\n\n```js\n\u003clink rel=\"manifest\" href=\"https://nextjs.org/manifest.json\" /\u003e\n```\n\n즉, `manifest`는 PWA(Progressive Web App)를 만들 때 필수적인 구성 요소로, 앱의 아이콘, 이름, 시작 URL, 색상 같은 정보를 담고 있어요. 그래서 브라우저가 앱을 어떻게 실행할지, 어떤 버튼을 보여줄지 등의 정보를 확인할 수 있답니다.\n\n---\n\n### Twitter 메타데이터 (트위터 카드)\n\n흥미로운 점은, 트위터의 메타데이터 스펙이 실제로는 X(예전 트위터)뿐만 아니라 여러 플랫폼에서 활용된다는 거예요.\n\n예를 들어, `twitter:card`, `twitter:title`, `twitter:description` 같은 태그를 넣으면 트윗이 공유될 때 예쁘게 카드 형태로 보이고, 검색 엔진에도 긍정적인 영향을 미칩니다.\n\n추가 팁으로는 아래처럼 Next.js의 `metadata` 객체에 `twitter` 속성을 활용할 수도 있어요:\n\n```js\nexport const metadata = {\n  twitter: {\n    card: 'summary_large_image',\n    site: '@your_twitter_handle',\n    title: '이 페이지의 제목',\n    description: '페이지 설명을 적어주세요',\n    images: ['https://example.com/image.png'],\n  },\n}\n```\n\n이렇게 하면 별도의 `\u003cmeta\u003e` 태그를 일일이 작성하지 않아도 되니 훨씬 편리합니다.\n\n---\n\n### 요약\n\n아래 표에 간략히 정리해봤어요!\n\n| 설정 방법          | 설명                                     |\n|-------------------|----------------------------------------|\n| `metadata.manifest` | Next.js에서 PWA 매니페스트 JSON 파일 경로 설정  |\n| `\u003clink rel=\"manifest\" ... /\u003e` | 전통적인 HTML에서 매니페스트 연결 태그          |\n| `metadata.twitter` | 트위터(X) 카드 메타데이터 자동 생성 및 관리      |\n\n---\n\n오늘은 여기까지! PWA나 소셜 공유 시 내 사이트를 더 멋지게 보이게 만들고 싶다면 `manifest` 설정과 트위터 카드 메타데이터를 꼭 활용해보세요. 질문 있으면 댓글로 남겨주세요~ :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n트위터 카드를 활용해서 여러분의 웹페이지가 트위터에서 더 멋지게 보이도록 할 수 있어요. 특히 링크가 공유될 때 이미지, 제목, 설명 등이 깔끔하게 표시되어서 클릭률도 올라가겠죠?\n\n이번에 소개할 건 Next.js 공식 문서 기준으로 작성한 Twitter Card 메타 태그예요. Next.js에서 `metadata` 객체 안에 트위터 정보를 넣는 방식인데, 이걸 페이지에 적용하면 트위터가 이 정보를 보고 카드 형태로 링크를 꾸며줍니다.\n\n---\n\n### 1. `summary_large_image` 카드 타입  \n트윗에 큰 이미지와 함께 짧은 제목, 설명을 노출하는 카드 타입이에요.\n\n```jsx\nexport const metadata = {\n  twitter: {\n    card: 'summary_large_image',            // 카드 타입 지정\n    title: 'Next.js',                        // 카드 제목\n    description: 'The React Framework for the Web', // 카드 설명\n    siteId: '1467726470533754880',          // 사이트 트위터 ID (숫자)\n    creator: '@nextjs',                      // 작성자 트위터 계정\n    creatorId: '1467726470533754880',       // 작성자 트위터 ID (숫자)\n    images: ['https://nextjs.org/og.png'],  // 반드시 절대 URL로 이미지 지정\n  },\n}\n```\n\n위처럼 설정하면 내부적으로는 아래처럼 메타 태그가 생성됩니다:\n\n```html\n\u003cmeta name=\"twitter:card\" content=\"summary_large_image\" /\u003e\n\u003cmeta name=\"twitter:site:id\" content=\"1467726470533754880\" /\u003e\n\u003cmeta name=\"twitter:creator\" content=\"@nextjs\" /\u003e\n\u003cmeta name=\"twitter:creator:id\" content=\"1467726470533754880\" /\u003e\n\u003cmeta name=\"twitter:title\" content=\"Next.js\" /\u003e\n\u003cmeta name=\"twitter:description\" content=\"The React Framework for the Web\" /\u003e\n\u003cmeta name=\"twitter:image\" content=\"https://nextjs.org/og.png\" /\u003e\n```\n\n\u003e **팁:** `images`는 배열로 받지만, URL은 반드시 절대 경로(https://~~)여야 하므로 로컬 경로나 상대 경로는 사용하면 안 됩니다.\n\n---\n\n### 2. `app` 카드 타입  \n앱 카드 타입은 모바일 앱 링크를 추가해 앱 설치를 유도할 때 유용해요. 예를 들어 iPhone, iPad, 구글플레이 각각에 맞는 앱 스토어 URL을 넣을 수 있죠.\n\n```jsx\nexport const metadata = {\n  twitter: {\n    card: 'app',\n    title: 'Next.js',\n    description: 'The React Framework for the Web',\n    siteId: '1467726470533754880',\n    creator: '@nextjs',\n    creatorId: '1467726470533754880',\n    images: {\n      url: 'https://nextjs.org/og.png',\n      alt: 'Next.js Logo',                  // 이미지 대체 텍스트도 넣으면 좋아요\n    },\n    app: {\n      name: 'twitter_app',\n      id: {\n        iphone: 'twitter_app://iphone',    // 앱 아이디 스킴\n        ipad: 'twitter_app://ipad',\n        googleplay: 'twitter_app://googleplay',\n      },\n      url: {\n        iphone: 'https://iphone_url',      // iOS 앱스토어 URL\n        ipad: 'https://ipad_url',          // iPad용 URL\n      },\n    },\n  },\n}\n```\n\n요런 식으로 하면 트위터 카드에 앱 다운로드 링크도 함께 추가되어 사용자가 트윗에서 바로 앱 설치 페이지로 이동할 수 있답니다.  \n\n---\n\n## 한눈에 보는 트위터 카드 옵션 정리\n\n| 속성           | 설명                                        | 비고                         |\n| -------------- | ------------------------------------------- | ---------------------------- |\n| `card`         | 카드 유형 지정 (`summary_large_image`, `app` 등) | 타입에 따라 보이는 형태 변동 |\n| `title`        | 카드 제목                                    | 70자 이내 권장               |\n| `description`  | 카드에 보이는 간단 설명                       | 200자 이내 권장              |\n| `siteId`       | 사이트 소유 트위터 ID                         | 숫자만 입력                  |\n| `creator`      | 작성자 트위터 핸들 (예: `@nextjs`)          | 선택사항                    |\n| `creatorId`    | 작성자 트위터 ID                              | 숫자만 입력                  |\n| `images`       | 대표 이미지 URL (또는 객체로 `url`, `alt` 포함)| 반드시 절대 URL              |\n| `app`          | 모바일 앱 정보 (앱 이름, ID, URL 등)          | 앱 카드 타입에서 사용         |\n\n---\n\n### 마무리\n\n트위터 카드는 단순한 텍스트 링크보다 훨씬 풍성한 정보를 제공합니다. 블로그, 뉴스, 제품 소개 페이지 등 모든 공유 콘텐츠에 기본으로 적용하면 좋고, 특히 모바일 앱을 홍보할 때는 `app` 카드가 효과적이에요.\n\n참고로, 메타 태그가 제대로 작동하는지 꼭 [Twitter Card Validator](https://cards-dev.twitter.com/validator)에서 테스트해보세요! URL을 입력하면 트위터에서 어떻게 보일지 미리 확인할 수 있으니까요.\n\n자, 이제 여러분 웹사이트에 멋진 트위터 카드를 달아서 SNS 유입도 올리고, 사용자 경험도 업그레이드 해보세요! 필요하면 Next.js 공식 문서도 같이 참고하시길 추천합니다. 🚀\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번에 살펴볼 내용은 Next.js 프로젝트 안에서 Twitter 카드 메타 태그 설정과 관련된 부분이에요. 그리고 Next.js 14에서 바뀐 `viewport` 설정에 대한 알림도 함께 다뤄볼게요.\n\n우선, 코드에서 메타 태그를 보면 주로 Twitter 카드용으로 쓰이는 정보들이 담겨 있어요. 트위터 카드란, 트위터에 URL을 공유할 때 보이는 미리보기 박스 같은 거죠. 여기서 중요한 속성들을 한 번 정리해볼게요.\n\n| 메타 태그 속성명                 | 설명                                    |\n|--------------------------------|---------------------------------------|\n| `twitter:site:id`               | 트위터 사이트(계정) 고유 ID             |\n| `twitter:creator`               | 컨텐츠를 만든 사람의 트위터 핸들         |\n| `twitter:title`                 | 공유할 때 보여질 제목                     |\n| `twitter:description`           | 공유할 때 보여질 설명                     |\n| `twitter:card`                  | 카드 타입 (예: summary, app 등)          |\n| `twitter:image`                 | 미리보기 이미지 URL                      |\n| `twitter:image:alt`             | 이미지 대체 텍스트                       |\n| `twitter:app:name:iphone`       | 아이폰 앱 이름                           |\n| `twitter:app:id:iphone`         | 아이폰 앱 고유 ID/URI                    |\n| `twitter:app:url:iphone`        | 아이폰 앱 연결 URL                       |\n| (ipad, googleplay 관련 항목도 동일한 역할을 함)                |\n\n이렇게 여러 플랫폼(iPhone, iPad, Android/GooglePlay) 별로 앱 이름과 URL을 명시해 주는 게 특징이에요. 만약 여러분 앱이 여러 플랫폼에서 동작한다면, 이런 메타 태그를 꼭 넣어주는 게 좋아요. 그럼 트위터가 공유 시 앱을 바로 연결해주니까요.\n\n---\n\n### Next.js 14부터 달라진 viewport 설정\n\n그리고 예고처럼, Next.js 14부터는 `metadata` 안에서 `viewport` 옵션을 직접 쓰는 게 deprecated(사용 중단) 되었어요. 대신, Next.js는 이제 `next.config.js` 또는 `app/layout.tsx` 등에서 별도의 viewport 설정을 권장합니다.\n\n예를 들어, 기존엔 이렇게 썼다면:\n\n```js\nexport const metadata = {\n  viewport: 'width=device-width, initial-scale=1',\n};\n```\n\n이제는 HTML `\u003chead\u003e` 안에 직접 `\u003cmeta name=\"viewport\" content=\"...\"\u003e` 를 넣거나, Next.js가 제공하는 새로운 방식대로 설정하라는 거죠.\n\n이 부분은 반응형 웹 개발 시 매우 중요한 설정이라 꼭 알아두세요!\n\n---\n\n### 추가 팁! Twitter Card Validator\n\n트위터에서 내가 설정한 카드가 제대로 나오는지 확인하고 싶다면 [Twitter Card Validator](https://cards-dev.twitter.com/validator) 를 사용해보세요. URL 입력하면 실제 카드가 어떻게 나오는지 미리 보여줍니다.\n\n---\n\n그럼 오늘은 여기까지! 메타 태그 잘 활용해서 SNS 공유 효과도 쑥쑥 올려보세요~\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n요즘 웹사이트 최적화할 때 꼭 챙겨야 하는 메타 태그들, 여러분도 많이 들어보셨죠? 구글, 야ндекс, 야후 같은 검색엔진 인증부터, 애플 웹 앱 설정까지 다양한 메타 정보를 자바스크립트 객체 형태로 관리할 수 있는데요. 제가 한 번 직접 정리해보고, 어떤 식으로 활용하는지 쉽게 설명해 드릴게요!\n\n---\n\n## 1. 검색엔진 인증 메타 태그 관리하기\n\n웹사이트를 운영하면 구글, 야ндекс, 야후 등 다양한 검색엔진에 ‘내 사이트 인증’ 절차를 거쳐야 하죠. 이렇게 해야 검색 결과에 잘 노출되고, 통계도 정확하게 받아볼 수 있어요.\n\n```js\nexport const metadata = {\n  verification: {\n    google: 'google',           // 구글 사이트 인증 코드\n    yandex: 'yandex',           // 야ндекс 사이트 인증 코드\n    yahoo: 'yahoo',             // 야후 사이트 인증 코드\n    other: {\n      me: ['my-email', 'my-link'], // 기타 인증용 메타 정보\n    },\n  },\n}\n```\n\n위처럼 `verification` 객체 안에 각 인증 키를 넣으면, 실제 HTML 메타 태그로 이렇게 변환됩니다:\n\n```html\n\u003cmeta name=\"google-site-verification\" content=\"google\" /\u003e\n\u003cmeta name=\"y_key\" content=\"yahoo\" /\u003e\n\u003cmeta name=\"yandex-verification\" content=\"yandex\" /\u003e\n\u003cmeta name=\"me\" content=\"my-email\" /\u003e\n\u003cmeta name=\"me\" content=\"my-link\" /\u003e\n```\n\n\u003e **TIP:** `me` 메타 태그는 주로 이메일이나 개인 프로필 URL을 나타낼 때 사용해요. 검색엔진 최적화(SEO)를 넘어서 사이트 신뢰도에 도움 됩니다.\n\n---\n\n## 2. Apple Web App 을 위한 메타 태그 구성하기\n\n아이폰, 아이패드 사용자 대상으로 웹 앱 모양을 좀 더 자연스럽게 만들고 싶다면 ‘appleWebApp’ 메타 정보가 매우 중요해요. 홈 화면에 웹 앱을 추가했을 때, 앱처럼 보여지는 설정들을 여기에 담을 수 있어요.\n\n```js\nexport const metadata = {\n  itunes: {\n    appId: 'myAppStoreID',          // 앱스토어 ID\n    appArgument: 'myAppArgument',   // 앱 열 때 전달하는 인자 (URL 스킴 등)\n  },\n  appleWebApp: {\n    title: 'Apple Web App',         // 웹 앱 이름\n    statusBarStyle: 'black-translucent', // 상태바 스타일(투명하거나 색상 지정)\n    startupImage: [                 // 시작화면 이미지\n      '/assets/startup/apple-touch-startup-image-768x1004.png',\n      {\n        url: '/assets/startup/apple-touch-startup-image-1536x2008.png',\n        media: '(device-width: 768px) and (device-height: 1024px)',\n      },\n    ],\n  },\n}\n```\n\n위 설정을 넣으면, 애플 기기에서 다음과 같은 경험을 쉽게 만들 수 있어요:\n\n- 홈 화면에 아이콘 추가했을 때 앱 이름과 상태바 모양 조정\n- 앱 시작 시 딜레이 없이 로딩 화면(스플래시 이미지) 띄우기\n- 앱스토어 연동해서 사용자 유입 매끄럽게\n\n---\n\n### 정리: 메타 태그는 ‘웹사이트를 검색엔진과 스마트 기기 환경에 맞게 최적화하는 히든 챔피언’\n\n하나하나 보면 어렵거나 귀찮을 수 있지만, `metadata` 객체로 잘 구조화하면 관리도 편하고 재사용도 쉬워집니다. 특히 최신 프레임워크(Next.js 같은)에서는 이런 식으로 메타 정보를 코드로 정의하는 걸 권장하죠.\n\n혹시 여러분도 사이트 SEO, 혹은 PWA/Apple Web App 최적화를 생각 중이라면, 위처럼 메타 태그 전략부터 차근차근 시작해 보시길 추천합니다!\n\n---\n\n참고로 다음 시간에는 이 `metadata` 객체를 실제로 어떻게 HTML `\u003chead\u003e`에 심고, 렌더링하는지 예제를 상세히 보여드릴게요. 기대 많이 해 주세요~\n\n---\n\n필요하다면 제가 직접 만든 메타 태그 템플릿도 공유해 드릴 수 있으니, 언제든 편하게 물어봐 주세요! 😊\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n메타 태그와 링크 태그를 통해 앱 관련 정보와 웹 앱 설정, 그리고 SEO에 중요한 alternates(대체 링크)를 어떻게 다루는지 예시를 보여드릴게요.\n\n---\n\n## 1. iOS/앱 관련 메타 태그 예시\n\n```html\n\u003cmeta\n  name=\"apple-itunes-app\"\n  content=\"app-id=myAppStoreID, app-argument=myAppArgument\"\n/\u003e\n\u003cmeta name=\"mobile-web-app-capable\" content=\"yes\" /\u003e\n\u003cmeta name=\"apple-mobile-web-app-title\" content=\"Apple Web App\" /\u003e\n\u003clink\n  href=\"/assets/startup/apple-touch-startup-image-768x1004.png\"\n  rel=\"apple-touch-startup-image\"\n/\u003e\n\u003clink\n  href=\"/assets/startup/apple-touch-startup-image-1536x2008.png\"\n  media=\"(device-width: 768px) and (device-height: 1024px)\"\n  rel=\"apple-touch-startup-image\"\n/\u003e\n\u003cmeta\n  name=\"apple-mobile-web-app-status-bar-style\"\n  content=\"black-translucent\"\n/\u003e\n```\n\n### 설명!\n\n- `apple-itunes-app`: 스토어 앱 아이디와 호출할 매개변수를 넣어, iOS에서 앱으로 바로 연결할 수 있게 해줍니다.\n- `mobile-web-app-capable`: 웹앱을 홈화면에 추가하면 네이티브 앱처럼 풀스크린으로 보여주도록 설정.\n- `apple-mobile-web-app-title`: 홈화면 아이콘 밑에 표시될 이름.\n- `apple-touch-startup-image`: 앱 실행 시 보여줄 스플래시 이미지를 기기별 해상도와 맞춰서 지정해줄 수 있어요.\n- `apple-mobile-web-app-status-bar-style`: 상태바 스타일을 지정하는데 `black-translucent`는 반투명 검정색을 의미.\n\n---\n\n## 2. SEO에 도움되는 alternates 설정\n\nNext.js 등에서 `metadata` 객체를 활용하면 좀 더 깔끔하게 메타 태그를 관리할 수 있습니다.\n\n### metadata 예시 (자바스크립트)\n\n```js\nexport const metadata = {\n  alternates: {\n    canonical: 'https://nextjs.org',\n    languages: {\n      'en-US': 'https://nextjs.org/en-US',\n      'de-DE': 'https://nextjs.org/de-DE',\n    },\n    media: {\n      'only screen and (max-width: 600px)': 'https://nextjs.org/mobile',\n    },\n    types: {\n      'application/rss+xml': 'https://nextjs.org/rss',\n    },\n  },\n}\n```\n\n### 실제 HTML로 변환 시\n\n```html\n\u003clink rel=\"canonical\" href=\"https://nextjs.org\" /\u003e\n\u003clink rel=\"alternate\" hreflang=\"en-US\" href=\"https://nextjs.org/en-US\" /\u003e\n\u003clink rel=\"alternate\" hreflang=\"de-DE\" href=\"https://nextjs.org/de-DE\" /\u003e\n\u003clink\n  rel=\"alternate\"\n  media=\"only screen and (max-width: 600px)\"\n  href=\"https://nextjs.org/mobile\"\n/\u003e\n\u003clink\n  rel=\"alternate\"\n  type=\"application/rss+xml\"\n  href=\"https://nextjs.org/rss\"\n/\u003e\n```\n\n### 설명!\n\n- `canonical`: 중복되는 콘텐츠가 있을 때 대표 주소를 검색 엔진에 알려줘 SEO에 유리!\n- `hreflang`: 언어별 페이지가 있을 때, 사용자 언어에 맞는 페이지로 안내해줍니다.\n- `media`: 특정 미디어쿼리 조건에 맞는 별도의 페이지를 지정할 수 있어 반응형 페이지를 분리할 때 유용.\n- `type`: RSS 피드 같은 타입별 대체 리소스 링크도 연결할 수 있습니다.\n\n---\n\n## 추가 팁!\n\n- iOS 홈 화면 아이콘(`apple-touch-icon`)이나 안드로이드 웹앱 설정도 같이 해주면 모바일 환경에서 훨씬 앱 같은 느낌을 낼 수 있어요.\n- SEO에서 `alternates`는 다국어 사이트, 반응형 사이트 운영 시 꼭 챙겨야 할 부분입니다.\n- Next.js나 React 같은 프레임워크에선 `head` 혹은 `metadata` 설정을 통해 위 태그를 동적으로 관리하면 편리해요.\n\n---\n\n필요한 메타 태그나 링크 설정 어떻게 쓰는지 궁금하다면 언제든 물어봐주세요! 제가 직접 해보고 쓰는 만큼 친근하게 알려드릴게요 :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### appLinks: 메타데이터에서 앱 링크 설정하기\n\n안녕하세요 여러분! 오늘은 메타데이터(metadata) 안에 `appLinks`를 설정하는 방법에 대해서 쉽게 알려드릴게요. 여러분이 Next.js 같은 최신 프레임워크에서 앱과 웹을 연결할 때 꽤 유용한 부분이랍니다.\n\n먼저, 아래 `appLinks` 객체를 보시면 iOS, Android, 그리고 Web을 위한 링크 설정을 각각 해 놓은 걸 볼 수 있어요.\n\n```js\nexport const metadata = {\n  appLinks: {\n    ios: {\n      url: 'https://nextjs.org/ios',\n      app_store_id: 'app_store_id',\n    },\n    android: {\n      package: 'com.example.android/package',\n      app_name: 'app_name_android',\n    },\n    web: {\n      url: 'https://nextjs.org/web',\n      should_fallback: true,\n    },\n  },\n}\n```\n\n- `ios`: 여기서는 iOS 앱 스토어 링크와 앱 ID가 들어가 있어요. 사용자가 iOS 디바이스에서 해당 링크를 열면 앱이 연결되거나 앱스토어로 이동하게 되죠.\n- `android`: 패키지 이름과 앱 이름이 들어가 있습니다. 마찬가지로 안드로이드 사용자를 위한 정보예요.\n- `web`: 웹 URL과 `should_fallback`이라는 옵션이 있어요. 이거는 모바일 앱이 설치 안 돼 있을 때 웹 사이트로 자동으로 넘어가게 하는 역할을 합니다.\n\n그리고 이렇게 설정한 내용은 결국 아래처럼 HTML `\u003cmeta\u003e` 태그로 변환이 됩니다. 이 메타 태그들은 Open Graph 프로토콜에 기반한 앱 링크 정보를 담고 있어서 SNS나 브라우저가 앱과 웹을 적절히 연결하게 해줍니다.\n\n| 태그 속성                    | 내용                          |\n|----------------------------|-----------------------------|\n| `\u003cmeta property=\"al:ios:url\" content=\"https://nextjs.org/ios\" /\u003e`         | iOS 앱으로 연결되는 URL          |\n| `\u003cmeta property=\"al:ios:app_store_id\" content=\"app_store_id\" /\u003e`          | iOS 앱스토어 ID                  |\n| `\u003cmeta property=\"al:android:package\" content=\"com.example.android/package\" /\u003e` | 안드로이드 앱 패키지 이름          |\n| `\u003cmeta property=\"al:android:app_name\" content=\"app_name_android\" /\u003e`      | 안드로이드 앱 이름                |\n| `\u003cmeta property=\"al:web:url\" content=\"https://nextjs.org/web\" /\u003e`         | 웹 URL                         |\n| `\u003cmeta property=\"al:web:should_fallback\" content=\"true\" /\u003e`               | 웹 fallback 허용 여부             |\n\n---\n\n### 추가 팁!\n\n- **앱 링크 설정의 중요성:** 요즘은 SNS나 모바일 브라우저에서 링크를 누르면 바로 앱이 뜨길 원하시잖아요? 이런 `appLinks` 덕분에 사용자 경험이 확실히 좋아집니다.\n- **앱이 없을 때 웹 fallback:** `should_fallback`을 `true`로 두면 사용자의 기기에 앱이 없어도 자연스럽게 웹으로 넘어가서 끊김없는 경험을 제공합니다.\n- **아이콘이나 스플래시 스크린 같은 추가 설정도 가능**하니, 앱을 홍보할 때 같이 챙기시면 좋겠죠?\n\n앱과 웹을 유기적으로 연결하고 싶을 때, 위처럼 `appLinks` 설정하는 것 잊지 마세요! 도움이 되셨다면 좋아요와 구독 부탁드려요~ 다음에 또 유용한 개발 정보로 찾아뵙겠습니다. :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\"archives\"라는 건 역사적인 가치가 있는 기록, 문서, 혹은 기타 자료들을 모아놓은 컬렉션을 의미해요. 예를 들어, 오래된 사진, 편지, 공식 문서 같은 것들이 여기에 속하죠.\n\n위에 있는 코드를 보면 두 가지 형태로 \"archives\"를 지정하는 방법이 나와 있어요.\n\n첫 번째는 자바스크립트 객체 형태로, `metadata`라는 변수 안에 `archives`라는 배열 속성으로 URL을 넣고 있고요.\n\n```js\nexport const metadata = {\n  archives: ['https://nextjs.org/13'],\n}\n```\n\n두 번째는 HTML의 `\u003clink\u003e` 태그를 써서 `\"archives\"`라는 관계를 명시하는 방법이에요.\n\n```js\n\u003clink rel=\"archives\" href=\"https://nextjs.org/13\" /\u003e\n```\n\n이런 방식으로 사이트나 문서가 참조하는 중요한 역사적 자료 링크를 연결할 수 있죠.\n\n### assets(에셋)\n\n여기서 `archives`와 비슷하게 많이 쓰이는 `assets`라는 용어도 알아두면 좋아요. `assets`는 이미지, 스타일시트, 스크립트 등 웹사이트에서 사용하는 모든 '자산'들을 의미해요. 즉, 웹사이트를 구성하는 데 필요한 리소스 파일들이죠.\n\n아래는 `assets`를 나타낼 때 사용하는 간단한 메타데이터 예시예요.\n\n```js\nexport const metadata = {\n  assets: ['https://example.com/assets/logo.png'],\n}\n```\n\n---\n\n추가로, 보통 역사적 기록이나 자료들을 다룰 때는 메타데이터를 잘 작성해두면 나중에 자료들을 검색하거나 관리하는 데 큰 도움이 돼요. 그래서 링크 태그나 자바스크립트 객체를 활용해 이런 정보를 명확하게 표시하는 게 중요합니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 `metadata`를 사용해서 페이지에 다양한 메타 정보를 추가할 수 있어요. 근데 `assets`와 `bookmarks`를 어떻게 쓰는지는 조금 헷갈릴 수 있죠. 여기서 간단하게 설명하고 예제도 보여드릴게요.\n\n---\n\n### 1. `assets` 설정하기\n\n```js\nexport const metadata = {\n  assets: ['https://nextjs.org/assets'],\n}\n```\n\n`assets`는 페이지에서 사용할 외부 리소스(이미지, 폰트, 아이콘 등)를 미리 선언하는 역할을 해요. 이게 있으면, 브라우저가 미리 해당 리소스를 캐싱하거나 최적화된 방식으로 로딩할 수 있게 도와줍니다.\n\n브라우저에 직접 `\u003clink rel=\"assets\" ... /\u003e` 태그를 추가하는 코드도 있는데, 보통 Next.js에서는 `metadata`를 통해 쉽게 설정할 수 있어요.\n\n이걸 HTML로 보면 이렇게 생겼죠:\n\n```html\n\u003clink rel=\"assets\" href=\"https://nextjs.org/assets\" /\u003e\n```\n\n---\n\n### 2. `bookmarks` 설정하기\n\n```js\nexport const metadata = {\n  bookmarks: ['https://nextjs.org/13'],\n}\n```\n\n`bookmarks`는 웹 브라우저에서 사용하는 북마크 리소스를 지정하는 메타데이터인데, 사실 웹 표준이나 브라우저 지원 면에서는 아직 널리 쓰이지 않는 편이에요. 그래서 굳이 사용할 필요는 없고, 특수한 경우가 아니라면 안 써도 무방합니다.\n\n---\n\n### 간단 정리\n\n| 키워드    | 용도                                      | 브라우저 지원 및 유용성                  |\n|----------|-----------------------------------------|----------------------------------------|\n| `assets` | 외부 리소스를 사전에 선언해 최적화 지원            | Next.js에서 공식 지원, 실사용에서 유용함   |\n| `bookmarks` | 북마크 관련 리소스 지정 (특정 브라우저에서 사용 가능) | 아직 표준 널리 쓰이지 않음, 보통 안 써도 됨 |\n\n---\n\n### 참고로\n\n- Next.js에서 `metadata`는 SEO나 사용자 경험 개선에 중요한 역할을 해요.\n- 공식 문서에서 지원하는 키만 사용하는 게 안전하고, `assets`는 그중 하나입니다.\n- HTML `\u003clink\u003e` 태그를 직접 다룰 필요 없이, Next.js가 알아서 `metadata`를 바탕으로 최적의 구조로 만들어줍니다.\n\n---\n\n이렇게 `metadata`를 잘 활용하면 페이지가 더 빠르게 로드되거나, 검색 엔진 최적화에도 도움 될 수 있어요. 혹시 더 궁금한 점 있으면 알려주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안녕하세요! 오늘은 HTML과 Next.js 메타데이터에 대해서 간단히 살펴볼게요. 코드 예시들을 보면서 자연스럽게 이해할 수 있도록 설명해 드릴게요.\n\n먼저, `\u003clink\u003e` 태그로 북마크(bookmarks) 같은 걸 지정하는 부분인데요:\n\n```html\n\u003clink rel=\"bookmarks\" href=\"https://nextjs.org/13\" /\u003e\n```\n\n여기서 `rel=\"bookmarks\"`는 링크가 북마크 관련 링크임을 알려주는 역할이에요. 하지만 보통 웹 개발에서 이 속성은 잘 사용하지 않는 편이라, 만약 북마크를 위한 링크를 넣고 싶다면 보통 사용자 브라우저나 북마크 기능을 활용하는 게 좋겠죠.\n\n---\n\n다음은 Next.js에서 메타데이터(metadata)를 설정하는 부분입니다.\n\n```js\nexport const metadata = {\n  category: 'technology',\n}\n```\n\n이 코드처럼 `metadata` 객체로 카테고리 같은 정보를 지정할 수 있어요. Next.js 13 버전부터 이런 식으로 페이지나 컴포넌트 단위 메타데이터 설정이 가능해져서 SEO(검색엔진최적화)에 아주 유용합니다.\n\n---\n\n그리고 보통 HTML 문서에는 다음처럼 `\u003cmeta\u003e` 태그를 써서 카테고리를 명시하기도 하죠:\n\n```html\n\u003cmeta name=\"category\" content=\"technology\" /\u003e\n```\n\n이 메타 태그는 검색엔진이나 소셜 미디어가 내용을 이해하는 데 도움을 줄 수 있어요.\n\n---\n\n### 쉽게 정리한 내용\n\n| 태그/코드                   | 역할 및 설명                                   |\n|-----------------------------|----------------------------------------------|\n| `\u003clink rel=\"bookmarks\" ...\u003e` | 북마크 관련 링크를 지정 (실제로는 잘 쓰이지 않음) |\n| `export const metadata = {...}` | Next.js에서 페이지 메타데이터 설정 (추천)          |\n| `\u003cmeta name=\"category\" ...\u003e` | HTML 문서에서 카테고리 같은 메타 정보 명시          |\n\n---\n\n참고로, HTML 메타태그는 SEO를 위해 꼭 필요한 요소입니다. 특히 `description`, `keywords`, `author` 같은 태그들도 추가해주면 더 좋죠. Next.js 13부터는 이런 메타데이터를 코드 안에서 직접 관리할 수 있어 개발 생산성이 훨씬 올라가니 꼭 한 번 써보세요!\n\n그럼 오늘 내용은 여기까지~ 즐거운 개발 되세요! 😊\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 페이스북 연동하기\n\n웹페이지에 페이스북 앱이나 페이스북 계정을 연결해서 페이스북 소셜 플러그인(Facebook Social Plugins)을 활용할 수 있어요. 공식 페이스북 문서에서 더 자세한 내용을 확인할 수 있답니다.\n\n\u003e 참고할 점: `appId`와 `admins` 옵션은 둘 다 쓸 수 없고, 한 가지만 선택해서 써야 해요.\n\n간단한 예시 코드를 보면 이렇게 구성할 수 있어요:\n\n```js\nexport const metadata = {\n  facebook: {\n    appId: '12345678',  // 본인의 페이스북 앱 ID를 여기에 입력하세요\n  },\n}\n```\n\n---\n\n#### 추가 팁!\n\n- **appId**는 페이스북 개발자 페이지에서 앱을 생성하면 얻을 수 있어요. 이 ID를 넣으면 페이스북 로그인, 공유 버튼 등 다양한 플러그인을 웹에 쉽게 적용할 수 있답니다.\n- 만약 개인 또는 조직의 페이스북 계정이 관리자로서 관련 페이지를 관리한다면 `admins` 옵션을 사용할 수도 있어요. 하지만 `appId`와 `admins`는 동시에 넣을 수 없으니 주의하세요.\n- 페이스북 소셜 플러그인을 적용할 때는 도메인 설정도 잘 맞춰줘야 오류 없이 작동해요.\n\n웹에 페이스북 기능을 심플하게 넣고 싶다면 이 설정부터 시작해 보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여러분, 페이스북과 연동할 때 사용하는 메타 태그에 대해 이야기해볼게요.\n\n---\n\n먼저, 페이스북 앱 ID를 지정하는 태그는 이렇게 생겼어요:\n\n```html\n\u003cmeta property=\"fb:app_id\" content=\"12345678\" /\u003e\n```\n\n이건 페이스북 앱과 내 사이트를 연결할 때 자주 사용되는 태그입니다. 특히, 페이스북에서 제공하는 소셜 플러그인이나 오픈그래프(Open Graph) 기능을 쓸 때 꼭 필요해요.\n\n---\n\n그리고 또 하나, 페이스북 관리자 권한을 명시할 때는 이렇게 할 수 있어요:\n\n```js\nexport const metadata = {\n  facebook: {\n    admins: '12345678',\n  },\n}\n```\n\n혹은 HTML에서는 다음처럼 쓸 수 있죠:\n\n```html\n\u003cmeta property=\"fb:admins\" content=\"12345678\" /\u003e\n```\n\n여기서 '12345678'은 페이스북 사용자 ID입니다. 이렇게 적어놓으면, 내가 해당 페이지에 대한 페이스북 통계나 관리를 더 쉽게 할 수 있어요.\n\n---\n\n추가로, 만약 여러 명의 fb:admins를 설정하고 싶다면, 배열을 사용하면 됩니다. 예를 들어 이렇게요:\n\n```js\nexport const metadata = {\n  facebook: {\n    admins: ['12345678', '87654321', '11223344'],\n  },\n}\n```\n\n이 경우, 페이스북에서 여러 사람에게 관리자 권한을 줄 수 있어 협업 시에 아주 유용하죠.\n\n---\n\n정리하자면,\n\n| 태그 종류          | 역할                        | 예시                                        |\n|-------------------|----------------------------|-------------------------------------------|\n| fb:app_id         | 앱 ID 등록, 페이스북 연동 필수    | `\u003cmeta property=\"fb:app_id\" content=\"12345678\" /\u003e` |\n| fb:admins         | 페이지 관리자 지정               | `\u003cmeta property=\"fb:admins\" content=\"12345678\" /\u003e`   |\n| fb:admins (배열)  | 여러 명의 관리자 지정            | admins: ['12345678', '87654321']             |\n\n---\n\n마지막으로 팁! 메타 태그는 HTML 헤드(head) 태그 안에 넣어야 제대로 작동하니, 꼭 위치를 신경 써주세요. 더불어 페이스북 디버거 툴 (Facebook Sharing Debugger)을 사용하면 제대로 설정됐는지 검증 가능하니 활용해 보시길 추천해요!\n\n필요한 부분 있으면 댓글로 물어봐 주세요~ :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안녕하세요! 이번에는 페이스북과 핀터레스트 같은 SNS 메타 태그를 다루는 방법을 간단히 살펴볼게요. 웹 개발할 때 메타데이터를 어떻게 설정하는지는 SEO나 소셜 미디어에서 내 콘텐츠가 어떻게 보일지에 큰 영향을 줍니다.\n\n## Facebook 메타 태그 설정하기\n\n먼저 `metadata` 객체를 사용해 페이스북의 `fb:admins`를 등록하는 예시입니다. 이 코드는 여러분이 페이스북 페이지의 관리자임을 인증하는 데 도움을 줘요.\n\n```js\nexport const metadata = {\n  facebook: {\n    admins: ['12345678', '87654321'],\n  },\n}\n```\n\n이걸 HTML 메타 태그로 변환하면 이렇게 됩니다:\n\n```html\n\u003cmeta property=\"fb:admins\" content=\"12345678\" /\u003e\n\u003cmeta property=\"fb:admins\" content=\"87654321\" /\u003e\n```\n\n페이스북에서 여러 명의 관리자를 등록할 때는 `\u003cmeta\u003e` 태그를 각각 추가하는 형식이죠. 이 값들은 페이스북 개발자 페이지에서 본인 계정을 식별할 때 필요해요. 특히 오픈 그래프(Open Graph) 태그와 함께 쓴다면 내 페이지가 페이스북에 공유될 때 멋지게 표시할 수 있습니다.\n\nTip!  \n`fb:admins` 외에도 `fb:app_id`(앱 ID)를 추가해주면 더 강력한 통계와 함께 페이스북 기능을 사용할 수 있어요.\n\n## Pinterest Rich Pins 활성화하기\n\n다음으로, 핀터레스트에서는 \"Rich Pins\"(리치 핀)이라는 기능이 있는데요, 이걸 통해 내가 만든 웹사이트 콘텐츠가 핀터레스트에서 더 풍부한 정보를 담아 보여질 수 있어요.\n\n\u003e 리치 핀은 예를 들면 상품, 레시피, 기사 등의 추가 정보가 포함되어서 사용자에게 더 많은 가치를 제공합니다.\n\n웹페이지에서 리치 핀을 사용할지 말지를 설정할 수 있는데, 간단히 메타 태그를 추가하거나 핀터레스트 개발자 도구를 통해 활성화할 수 있어요.\n\n예시로는 이런 식으로 메타 태그를 넣게 되죠:\n\n```html\n\u003cmeta property=\"og:type\" content=\"product\" /\u003e\n\u003cmeta property=\"og:title\" content=\"Awesome Product\" /\u003e\n\u003cmeta property=\"og:description\" content=\"This product is really awesome because...\" /\u003e\n\u003cmeta property=\"og:image\" content=\"https://example.com/product-image.jpg\" /\u003e\n\u003clink rel=\"canonical\" href=\"https://example.com/product-page\" /\u003e\n```\n\n이런 오픈 그래프 태그들이 핀터레스트가 내 콘텐츠를 정확히 이해하고 풍성하게 보이도록 도와줍니다.\n\n---\n\n### 요약 정리\n\n| 소셜 서비스 | 설정 방법                          | 주요 역할                                  |\n|-------------|----------------------------------|-------------------------------------------|\n| Facebook    | `\u003cmeta property=\"fb:admins\" /\u003e` | 관리자 인증 및 공유 시 페이지 신뢰성 향상  |\n| Pinterest   | 오픈 그래프 태그 추가           | 리치 핀 활성화로 콘텐츠 정보 풍성하게 표시 |\n\n---\n\n메타 태그를 잘 활용하면 내 사이트가 SNS에서 더 멋지게 보이고, 방문자에게 신뢰감을 줄 수 있어요. 블로그나 쇼핑몰을 운영하신다면 꼭 챙겨야 할 부분이니 한번 적용해보시길 추천드릴게요! 필요하면 오픈 그래프 태그, 트위터 카드 태그 같은 다른 메타 데이터도 같이 공부해보면 좋습니다 :)\n\n궁금한 점 있으면 언제든 물어보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자바스크립트 코드에서 메타데이터를 설정하는 방법과 HTML 메타 태그를 직접 작성하는 방법을 비교해볼게요.\n\n```js\nexport const metadata = {\n  pinterest: {\n    richPin: true,\n  },\n}\n```\n\n위 코드는 프로젝트 안에서 메타데이터를 설정하는 대표적인 예입니다. 여기서는 Pinterest의 Rich Pin 기능을 활성화 한다는 걸 나타내죠.\n\n반면에 HTML에서는 이렇게 작성할 수 있겠죠:\n\n```html\n\u003cmeta name=\"pinterest-rich-pin\" content=\"true\" /\u003e\n```\n\n이렇게 하면 브라우저나 크롤러가 해당 페이지에서 Rich Pin 기능을 인식할 수 있어요.\n\n---\n\n그리고 여기서 중요한 점! \n\n\u003e **other** 옵션을 활용하면 프로젝트에서 기본적으로 지원하지 않는 커스텀 메타 태그들도 추가할 수 있어요.\n\n즉, 공식적으로 제공되는 메타데이터 옵션 외에 브랜드에서 특별하게 필요한 메타 태그가 있거나, 아직 최신 메타 태그가 공식 지원되기 전에 먼저 써야 하는 상황에도 유용하답니다.\n\n---\n\n참고로 메타데이터는 검색 엔진 최적화(SEO), SNS 공유, 웹사이트의 기능 확장 등 다양한 용도로 활용되기 때문에, 어떤 메타 태그를 쓸지 꼼꼼하게 고민해보는 게 좋아요. 특히 Pinterest 같은 SNS 메타 태그는 이미지 노출과 관련된 중요한 역할을 하니까, 꼭 신경 써서 세팅해보시길 바랍니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 내용은 React나 Next.js 같은 프레임워크에서 메타 태그(metadata)를 설정하는 방법에 관한 거예요. 메타 태그는 웹페이지의 정보를 검색 엔진이나 브라우저에 알려주는 중요한 역할을 하죠.\n\n우선, `metadata` 객체에서 `other`라는 키로 커스텀 메타 태그를 정의할 수 있어요.\n\n```js\nexport const metadata = {\n  other: {\n    custom: 'meta',\n  },\n}\n```\n\n위 코드는 결국 HTML로 변환될 때 아래처럼 된다고 볼 수 있어요.\n\n```html\n\u003cmeta name=\"custom\" content=\"meta\" /\u003e\n```\n\n만약 같은 이름의 메타 태그를 여러 개 만들어야 한다면, 값에 배열을 넣으면 됩니다.\n\n```js\nexport const metadata = {\n  other: {\n    custom: ['meta1', 'meta2'],\n  },\n}\n```\n\n이렇게 하면 HTML에서는 다음과 같이 두 개의 메타 태그가 만들어져요:\n\n```html\n\u003cmeta name=\"custom\" content=\"meta1\" /\u003e\n\u003cmeta name=\"custom\" content=\"meta2\" /\u003e\n```\n\n---\n\n### 추가 팁!\n\n1. **메타 태그에 다양한 정보 넣기**  \n   `name`과 `content` 외에도 `http-equiv`나 `charset` 등의 속성도 있는데, 프레임워크 문서에서 지원하는 범위 내에서 활용해보세요.\n\n2. **여러 메타 태그 관리하기**  \n   SEO 최적화와 SNS 공유를 위한 `og:title`, `og:description`, `twitter:card` 같은 메타 태그도 함께 작성해야 한다면, `metadata` 객체 안에 따로 정의해놓고 관리하면 편리해요.\n\n3. **동적 메타 태그**  \n   만약 페이지마다 동적으로 메타 태그를 바꿔야 할 때는, 정적인 `export const metadata`뿐 아니라 React의 상태(state)나 훅을 사용해서 동적으로 설정하는 방법도 공부해보세요.\n\n메타 태그를 잘 활용하면 사용자 경험과 검색엔진에서의 가시성 모두 향상시킬 수 있으니, 꼭 챙겨서 활용해보시길 바랍니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n\u003cmeta name=\"custom\" content=\"meta1\" /\u003e \u003cmeta name=\"custom\" content=\"meta2\" /\u003e\n```\n\n## 지원하지 않는 메타데이터 유형\n\n아래 메타데이터 타입들은 현재 Next.js에서 내장 지원을 하지 않아요. 하지만 그렇다고 아예 사용할 수 없는 건 아니에요. 이런 메타 태그들은 레이아웃(layout)이나 개별 페이지 내부에서 직접 렌더링할 수 있습니다.\n\n| 메타데이터                    | 권장 방법                                                                                       |\n|------------------------------|------------------------------------------------------------------------------------------------|\n| `\u003cmeta http-equiv=\"...\"\u003e`     | `\u003cmeta http-equiv\u003e`는 HTTP 헤더 역할을 하는데, 여기서는 직접 태그 사용보다는 \u003ca href=\"/docs/app/api-reference/functions/redirect\"\u003e\u003ccode\u003eredirect()\u003c/code\u003e\u003c/a\u003e, \u003ca href=\"/docs/app/building-your-application/routing/middleware#nextresponse\"\u003e미들웨어\u003c/a\u003e, \u003ca href=\"/docs/app/api-reference/config/next-config-js/headers\"\u003e보안 헤더 설정\u003c/a\u003e 같은 방법으로 대응하는 걸 권장해요. |\n| `\u003cbase\u003e`                     | `\u003cbase\u003e` 태그는 레이아웃이나 페이지 컴포넌트 안에서 직접 렌더링하세요.                                |\n| `\u003cnoscript\u003e`                 | `\u003cnoscript\u003e` 태그 역시 레이아웃이나 페이지 내에서 렌더링하는 게 좋아요.                              |\n| `\u003cstyle\u003e`                   | Next.js에서 스타일을 적용하는 방법에 대해선 \u003ca href=\"/docs/app/building-your-application/styling/css\"\u003e여기\u003c/a\u003e서 확인해보세요.                         |\n| `\u003cscript\u003e`                  | 스크립트 사용에 관한 자세한 내용은 \u003ca href=\"/docs/app/building-your-application/optimizing/scripts\"\u003e이 문서\u003c/a\u003e에서 다룹니다.                          |\n| `\u003clink rel=\"stylesheet\" /\u003e`  | 스타일시트는 레이아웃 또는 페이지에서 직접 `import` 하여 적용하는 것을 권장합니다.                    |\n| `\u003clink rel=\"preload\" /\u003e`     | React에서 preload를 사용하려면 \u003ca href=\"#link-relpreload\"\u003eReactDOM preload 메서드\u003c/a\u003e를 활용하세요.           |\n| `\u003clink rel=\"preconnect\" /\u003e`  | 비슷하게 preconnect가 필요하면 \u003ca href=\"#link-relpreconnect\"\u003eReactDOM preconnect 메서드\u003c/a\u003e를 사용하세요.      |\n| `\u003clink rel=\"dns-prefetch\" /\u003e`| DNS 미리 조회가 필요할 때는 \u003ca href=\"#link-reldns-prefetch\"\u003eReactDOM prefetchDNS 메서드\u003c/a\u003e를 참고하면 됩니다.     |\n\n---\n\n### 조금 더 쉽게 이해하기\n\nNext.js가 내부적으로 지원하지 않는 태그들은 꼭 페이지나 레이아웃 컴포넌트에서 직접 넣어야 한다고 기억해 주세요. 그리고 `\u003cmeta http-equiv\u003e` 같은 헤더 관련 태그들은 서버 설정이나 Next.js의 자체 헤더 설정 기능으로 대체하는 편이 훨씬 안정적이고 최적화된 방법입니다.\n\n또한 CSS나 스크립트 같은 리소스들은 `import`나 Next.js에서 권장하는 관리 방식을 따르는 게 가장 좋은데요, 이렇게 하면 빌드 과정에서 최적화가 자연스럽게 따라와서 성능에 큰 도움이 된답니다.\n\n저도 처음에는 `\u003cstyle\u003e`이나 `\u003cscript\u003e`, `\u003cmeta\u003e` 태그 작성하는 게 익숙치 않았는데, 공식 문서들을 보면서 Next.js 스타일에 맞게 사용하는 방법을 익히니 프로젝트 관리가 훨씬 편해졌어요. 여러분도 Next.js와 함께라면 점점 더 깔끔하고 빠른 웹 앱을 만들 수 있을 거예요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 리소스 힌트(Resource hints)란?\n\n웹 페이지를 빠르게 불러오기 위해 브라우저에 외부 리소스가 곧 필요할 거라는 신호를 줄 수 있어요. 이때 사용하는 게 바로 `\u003clink\u003e` 태그의 `rel` 속성 키워드들이에요. 예를 들어, `preload`, `preconnect`, `dns-prefetch` 같은 것들이 있죠. 브라우저는 이 힌트를 받으면 미리 리소스를 준비해서 페이지 로딩 속도를 확 끌어올려준답니다.\n\n그런데 보통 이런 힌트는 메타데이터 API에 직접 포함하기 어려워요. 하지만 React에서 새롭게 제공하는 ReactDOM 메서드를 통해 문서의 `\u003chead\u003e`에 안전하게 이 힌트를 삽입할 수 있어요. 아래처럼 사용하면 되죠!\n\n```jsx\n'use client'\n\nimport ReactDOM from 'react-dom'\n\nexport function PreloadResources() {\n  ReactDOM.preload('https://example.com/script.js', { as: 'script' })        // 스크립트 미리 로드\n  ReactDOM.preconnect('https://fonts.googleapis.com', { crossOrigin: 'anonymous' }) // 사전에 서버 연결\n  ReactDOM.prefetchDNS('https://cdn.example.com')                          // DNS 조회 미리하기\n\n  return null\n}\n```\n\n#### 각 메서드가 하는 일 정리\n\n| 메서드             | 역할 설명                           | 자주 쓰는 용도                         |\n|------------------|---------------------------------|---------------------------------|\n| `ReactDOM.preload`    | 해당 리소스를 미리 다운로드해서 준비 | 스크립트, 스타일시트, 폰트 선로딩           |\n| `ReactDOM.preconnect` | 리소스를 제공하는 서버와 미리 연결       | 외부 폰트, API 서버 등 네트워크 연결 앞당기기    |\n| `ReactDOM.prefetchDNS`| 도메인 이름 해석(DNS 조회)을 미리해서 속도 향상 | 외부 CDN, API 서버 DNS 조회 시간 단축         |\n\n---\n\n### 추가 팁!\n\n- **preload**는 실제 리소스를 미리 다운받기 때문에, 정말 필요한 리소스에만 적용하는 게 좋아요. 너무 많이 사용하면 오히려 네트워크에 부담이 될 수 있거든요.\n- **preconnect**와 **prefetchDNS**는 리소스 요청 자체보다는 연결을 준비하는 단계라서 비용이 적은 편이에요. 많이 사용해도 크게 문제없지만 무조건 남발하는 건 피하는 게 좋아요.\n- React 18부터 ReactDOM에 이런 메서드가 생기면서, 서버 컴포넌트나 클라이언트 컴포넌트에서 동적으로 리소스 선로딩을 관리하기 훨씬 편해졌답니다.\n\n리소스 최적화가 생각보다 쉽지 않은데, 이런 기능으로 페이지 속도를 한층 끌어올려 보세요! 😊\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n웹 페이지를 렌더링하는 동안 리소스를 미리 불러오는 방법에 대해 알아볼게요. 조금 더 빠르게 페이지를 띄우고 싶을 때 유용한 팁입니다!\n\n---\n\n### React에서 리소스 미리 불러오기\n\nReact에서 `ReactDOM.preload` 함수를 사용하면, 특정 자원을 미리 로드할 수 있어요.\n\n```js\nReactDOM.preload(href: string, options: { as: string })\n```\n\n- `href`: 미리 불러올 리소스 URL\n- `options.as`: 리소스 타입(ex. `script`, `style`, `image` 등)\n\n이렇게 하면 해당 리소스가 실제로 필요할 때보다 훨씬 일찍 다운로드가 시작돼서, 렌더링 속도가 빨라져요.\n\n---\n\n### HTML `\u003clink rel=\"preload\"\u003e` 태그\n\n브라우저 표준으로 미리 불러오기 할 때는 `\u003clink\u003e` 태그를 사용해요.\n\n```html\n\u003clink rel=\"preload\" href=\"...\" as=\"...\" /\u003e\n```\n\n- `href`: 리소스 주소\n- `as`: 불러올 리소스 종류(ex. `script`, `style`, `image`, `font` 등)\n\n이 방법도 리소스를 빠르게 준비시키는 데 효과적입니다.\n\n---\n\n### 추가 팁: preconnect\n\n리소스를 미리 불러오기 전에, 네트워크 연결부터 미리 열어두는 방법도 있어요. `preconnect`를 사용하면 DNS 조회나 TLS 핸드쉐이크 같은 초기 연결 과정을 미리 수행해서 연결 시간을 줄일 수 있답니다.\n\n```html\n\u003clink rel=\"preconnect\" href=\"https://example.com\" /\u003e\n```\n\n이렇게 하면 브라우저가 해당 도메인과의 초기 연결을 미리 처리해줘서, 리소스를 실제로 요청할 때 더 빠르게 받을 수 있어요.\n\n---\n\n### 마무리\n\n- **preload**: 리소스 자체를 미리 다운로드 시작\n- **preconnect**: 해당 도메인과의 네트워크 연결을 미리 시작\n\n둘 다 적절히 활용하면, 페이지 로딩 시간 단축에 큰 도움이 돼요. 특히, 외부 CDN에서 스크립트나 폰트, 이미지 같은 무거운 리소스를 불러올 때 효과가 좋으니 참고하세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여러분, 웹 페이지를 좀 더 빠르게 로딩하고 싶을 때 사용할 수 있는 기술 중에 '프리커넥트(preconnect)'와 '프리페치(prefetch)'가 있어요. 이번 글에서는 React에서 해당 기능을 어떻게 활용할 수 있는지 간단하게 정리해볼게요.\n\n---\n\n### 1. Preconnect (도메인 미리 연결하기)\n\n웹 브라우저가 리소스를 요청하기 전에 DNS 조회, TCP 핸드셰이크, TLS 협상 등을 미리 처리하도록 하는 기능입니다. 쉽게 말해서 \"아, 곧 여기서 리소스를 받아올 거니까 미리 연결 준비 해둘게!\"라는 거죠.\n\nHTML에서는 보통 이렇게 사용해요:\n\n```html\n\u003clink rel=\"preconnect\" href=\"https://example.com\" crossorigin /\u003e\n```\n\nReact에서는 다음과 같이 사용할 수 있습니다:\n\n```js\nReactDOM.preconnect('https://example.com', { crossOrigin: 'anonymous' });\n```\n\n`crossOrigin` 옵션은 리소스가 CORS 정책에 따라 로드돼야 할 때 설정해주면 되고, 보통 `anonymous`나 `use-credentials` 중 하나를 골라 사용합니다.\n\n---\n\n### 2. Prefetch DNS (도메인 이름 해석 미리 하기)\n\n이건 조금 더 가볍게 DNS 조회만 미리 해두는 기능이에요. 브라우저가 도메인 주소를 미리 해석해서 나중에 리소스를 요청할 때 시간을 절약할 수 있죠.\n\nReact에서 이렇게 사용 가능해요:\n\n```js\nReactDOM.prefetchDNS('https://example.com');\n```\n\n---\n\n### 👉 왜 이런 기능들을 써야 할까?\n\n- **로딩 속도 개선**: 외부 리소스(이미지, 폰트, 스크립트 등)를 불러올 때 필요한 연결 과정을 미리 끝내서 사용자 체감 속도를 높일 수 있어요.\n- **경쟁 상태 완화**: 여러 리소스를 동시에 요청하는 상황에서 연결 비용을 줄여서 네트워크 경합을 줄여줍니다.\n\n---\n\n### 참고로 알아두면 좋은 점!\n\n- `preconnect`는 HTTPS, 크로스오리진 리소스에서 특히 효과적이에요.\n- 너무 많이 쓰면 오히려 오버헤드가 발생할 수 있으니 꼭 필요한 도메인에만 적용하세요.\n- `prefetchDNS`는 프리커넥트보다는 가벼운 작업입니다. 가능하면 `preconnect`를 먼저 고려하세요.\n\n---\n\n요즘은 React 자체에서 이런 네트워크 최적화 기능을 간편하게 지원해 준다는 점이 참 편리하고, 서버 사이드 렌더링(SSR) 환경이나 Next.js 같은 프레임워크에서도 적절히 활용하면 더욱 좋습니다.\n\n다음에는 실제 프로젝트에 적용하면서 생길 수 있는 팁이나 주의사항도 공유할게요! 궁금한 점 있으면 댓글로 남겨주세요~ 😊\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n\u003clink rel=\"dns-prefetch\" href=\"...\" /\u003e\n```\n\n\u003e 알아두면 좋은 점:  \n이 메서드들은 현재 클라이언트 컴포넌트에서만 지원됩니다. 하지만 초기 페이지 로드는 여전히 서버 사이드 렌더링으로 이루어집니다.  \nNext.js에 내장된 기능들(예: next/font, next/image, next/script)은 관련 리소스 힌트를 자동으로 처리해주니 참고하세요.\n\n## 타입 종류\n\n메타데이터에 타입 안정성을 추가하고 싶다면 `Metadata` 타입을 사용할 수 있습니다.  \nIDE에서 내장된 TypeScript 플러그인을 사용 중이라면 타입을 따로 명시할 필요는 없지만, 명시적으로 추가하고 싶다면 그렇게 해도 괜찮습니다.\n\n---\n\n### 추가 팁!  \n`dns-prefetch`는 브라우저가 DNS 조회를 미리 해두게 해서 첫 요청 시간을 줄여주는 역할이에요.  \n외부 리소스를 많이 사용하는 페이지에서는 이걸 적절히 활용하면 로딩 속도 체감에 큰 도움이 됩니다!  \n그리고 Next.js가 자동으로 대부분 처리해주긴 하지만, 커스텀 도메인이나 특수한 경우에는 직접 넣어줘야 할 수도 있어요.  \n\n---\n\n필요하면 저도 다음 글에서 `preconnect`, `prefetch`, `preload` 같은 리소스 힌트 비교와 함께 실제 사용법도 자세히 다뤄볼게요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### metadata 객체\n\n```js\nimport type { Metadata } from 'next'\n\nexport const metadata: Metadata = {\n  title: 'Next.js',\n}\n```\n\nNext.js에서 페이지에 메타데이터를 설정할 때 `metadata` 객체를 이렇게 정의할 수 있어요. 예를 들어, `title`을 지정해서 브라우저 탭에 표시되는 제목을 쉽게 바꿀 수 있죠. 정적으로 고정된 메타데이터가 필요할 때 주로 활용합니다.\n\n### generateMetadata 함수\n\n#### 일반 함수(Regular function)\n\ngenerateMetadata 함수는 동적으로 메타데이터를 생성할 때 사용하는데, 페이지가 렌더링되기 전에 호출돼서 필요한 정보를 가져오거나 계산해서 메타데이터를 만들 수 있답니다. 예를 들어, API에서 데이터를 불러와서 제목이나 설명을 동적으로 넣을 때 유용하죠.\n\n```js\nimport type { Metadata } from 'next'\nimport type { Params } from 'next/navigation'\n\nexport async function generateMetadata({ params }: Params): Promise\u003cMetadata\u003e {\n  const data = await fetch(`https://api.example.com/posts/${params.id}`)\n  const post = await data.json()\n\n  return {\n    title: post.title,\n    description: post.summary,\n  }\n}\n```\n\n\u003e 이렇게 하면 각 게시글마다 고유한 제목과 설명을 메타데이터에 넣을 수 있어 SEO에도 좋아요!\n\n\u003e 참고로, `generateMetadata`는 페이지가 서버에서 렌더링될 때만 동작하기 때문에, 클라이언트 사이드에서 동적으로 변경하는 메타데이터와는 목적이 조금 다르다는 점 기억해 주세요.\n\n요약하자면:  \n- **metadata 객체**는 정적인 메타데이터용  \n- **generateMetadata 함수**는 동적으로 메타데이터를 생성할 때 사용  \n\n다음에는 `generateMetadata`의 화살표 함수 버전이나 비동기 처리에 대해 또 얘기해볼게요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 `generateMetadata` 함수는 페이지 메타데이터(예: 제목, 설명 등)를 정의할 때 사용돼요. 이 함수는 동기 혹은 비동기 형태로 작성할 수 있는데, 어떤 차이가 있는지 한 번 살펴볼게요.\n\n---\n\n## 기본 동기 함수\n\n```js\nimport type { Metadata } from 'next'\n \nexport function generateMetadata(): Metadata {\n  return {\n    title: 'Next.js',\n  }\n}\n```\n\n여기서는 `generateMetadata`를 동기 함수로 정의했어요. 단순히 객체를 반환하니까, 렌더링 과정에서 바로 메타 데이터를 사용할 수 있죠. 페이지 제목만 간단히 설정할 때 유용해요.\n\n---\n\n## 비동기 함수 (Async)\n\n```js\nimport type { Metadata } from 'next'\n \nexport async function generateMetadata(): Promise\u003cMetadata\u003e {\n  return {\n    title: 'Next.js',\n  }\n}\n```\n\n메타데이터 생성에 API 호출이나 DB 조회 같은 비동기 작업이 필요할 땐, async 함수로 정의할 수 있어요. Promise를 반환하면 Next.js가 알아서 기다려 준답니다.\n\n---\n\n## 세그먼트 Props와 함께 사용하기\n\nNext.js에서는 라우트 세그먼트(예: `[slug]` 같은 동적 경로)의 정보를 `generateMetadata`에 넘겨줄 수 있어요. 이를 통해 각 페이지마다 맞춤 메타데이터 생성이 가능하죠.\n\n```ts\nimport type { Metadata } from 'next'\n\ntype Params = {\n  params: {\n    slug: string\n  }\n}\n\nexport function generateMetadata({ params }: Params): Metadata {\n  return {\n    title: `Post - ${params.slug}`,\n  }\n}\n```\n\n이렇게 하면 URL 경로에 따라 적절한 제목을 동적으로 설정할 수 있어 편리합니다.\n\n---\n\n### 요약 📌\n\n| 형태            | 특징                          | 사용 상황                       |\n|-----------------|-----------------------------|------------------------------|\n| 동기 함수       | 즉시 메타데이터 반환           | 간단한 메타데이터 설정           |\n| 비동기 함수     | Promise 반환, await 가능       | API 호출 등 비동기 로직 필요 시  |\n| 세그먼트 포함    | 라우트 파라미터 활용 가능       | 동적 경로에 따라 메타데이터 달리할 때 |\n\n---\n\nNext.js에서 메타데이터를 유연하게 다루는 방법, 어렵지 않죠? 페이지마다 맞춤형 SEO 설정을 할 때 이 기능을 꼭 활용해 보세요! 필요하면 next.js 공식 문서도 참고하면 도움이 많이 될 거예요. 😊\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n요즘 Next.js에서 메타데이터를 다루는 방법이 많이 바뀌었죠? 이번 글에서는 Next.js에서 메타데이터를 생성하고 사용하는 기본적인 방법과, 부모 메타데이터를 활용하는 방법까지 간단하게 살펴볼게요.\n\n---\n\n## 기본 메타데이터 생성하기\n\n아래 코드를 보시면 `generateMetadata`라는 함수를 정의해서 메타데이터를 리턴하고 있어요.\n\n```js\nimport type { Metadata } from 'next'\n \ntype Props = {\n  params: Promise\u003c{ id: string }\u003e\n  searchParams: Promise\u003c{ [key: string]: string | string[] | undefined }\u003e\n}\n \nexport function generateMetadata({ params, searchParams }: Props): Metadata {\n  return {\n    title: 'Next.js',\n  }\n}\n \nexport default function Page({ params, searchParams }: Props) {}\n```\n\n여기서 중요한 점은:\n\n- `generateMetadata` 함수가 `Metadata` 타입 객체를 반환한다는 것\n- 이 메타데이터는 페이지 렌더링 시 Next.js가 자동으로 HTML `\u003chead\u003e`에 넣어준다는 것\n\n`params`나 `searchParams`를 사용해 동적으로 메타데이터를 바꿀 수도 있어요.\n\n---\n\n## 부모 메타데이터와 합치기\n\nNext.js는 중첩된 레이아웃이나 페이지 구조를 지원하기 때문에, 상위 레이아웃에서 정의한 메타데이터와 병합해서 사용하는 경우가 많죠. 이런 경우엔 `generateMetadata` 함수에서 `parent`라는 인자를 받아서 처리할 수 있어요.\n\n```js\nimport type { Metadata, ResolvingMetadata } from 'next'\n \nexport async function generateMetadata(\n  { params, searchParams }: Props,\n  parent: ResolvingMetadata\n): Promise\u003cMetadata\u003e {\n  return {\n    title: 'Next.js',\n  }\n}\n```\n\n- `parent`는 상위 레이아웃이 전달하는 메타데이터를 포함한 객체라서, 이 데이터를 참고하거나 확장해서 메타데이터를 만들 수 있어요.\n- 보통 `async` 함수로 작성하는데, `parent` 메타데이터를 비동기로 받아오기 때문이에요.\n\n---\n\n## 자바스크립트 프로젝트에서 활용하기\n\n타입스크립트를 사용하지 않는 자바스크립트 프로젝트에서도 거의 같은 방식으로 사용할 수 있어요. 타입 선언 부분을 제외하면 되고, `generateMetadata` 함수만 잘 활용하면 되죠.\n\n```js\nexport async function generateMetadata({ params, searchParams }, parent) {\n  return {\n    title: 'Next.js',\n  }\n}\n```\n\n---\n\n### 추가 팁!\n\n- 메타데이터는 `title` 뿐만 아니라 `description`, `openGraph`, `icons` 등 다양한 속성을 설정할 수 있어요.\n- Next.js 13 이상부터 공식 지원하는 메타데이터 API라서, SEO나 SNS 공유 시 훨씬 효율적이에요.\n- 페이지나 레이아웃 단위로 메타데이터를 구분해서 작성하면 유지보수가 편해지니 꼭 활용해 보세요.\n\n---\n\n| 구분            | 설명                                                      |\n| --------------- | --------------------------------------------------------- |\n| `generateMetadata` | 페이지나 레이아웃에서 메타데이터를 생성하는 함수               |\n| `params`        | URL 파라미터 정보를 담고 있음                               |\n| `searchParams`  | URL 쿼리스트링 정보를 담고 있음                             |\n| `parent`        | 상위 레이아웃의 메타데이터 정보를 포함하는 객체 (비동기 가능) |\n\n---\n\n다음번에는 메타데이터 속성별 구체적 예시와 SEO에 어떻게 활용할 수 있는지 알려드릴게요. 필요하면 궁금한 점 편하게 질문해주세요! 😄\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nJavaScript 프로젝트에서 타입 안정성을 높이고 싶을 때, JSDoc을 활용할 수 있어요.\n\n```js\n/** @type {import(\"next\").Metadata} */\nexport const metadata = {\n  title: 'Next.js',\n}\n```\n\n위 예시는 Next.js 프로젝트에서 메타데이터 객체에 타입을 지정하는 방법이에요. 이렇게 하면 에디터에서 자동 완성도 지원되고, 실수로 메타데이터 키를 잘못 작성하는 실수를 줄일 수 있답니다.\n\n---\n\n## 스트리밍 메타데이터(Streaming metadata)\n\nNext.js에서 `generateMetadata` 함수가 반환하는 메타데이터는 클라이언트에게 스트리밍 방식으로 전송돼요. 즉, 메타데이터가 준비되는 즉시 HTML에 주입되기 때문에 페이지 로딩 속도나 SEO 측면에서 유리하답니다.\n\n이 방식 덕분에 페이지가 완전히 렌더링되기 전에 메타데이터가 미리 전달되면서 브라우저와 검색엔진이 올바른 정보를 빠르게 인식할 수 있어요.\n\n추가로, 스트리밍 방식 덕분에 대규모 프로젝트에서 메타데이터 처리도 효율적으로 수행되니, Next.js를 사용할 때 꼭 기억해두면 좋은 팁입니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n페이지 메타데이터는 주로 봇이나 크롤러를 대상으로 하기 때문에, Next.js는 JavaScript를 실행하고 전체 페이지 DOM을 검사할 수 있는 봇(예: Googlebot)에 대해 메타데이터를 스트리밍 방식으로 제공합니다. 하지만 메타데이터가 없으면 안 되는 HTML 제한 봇(예: Twitterbot)에게는 여전히 페이지 렌더링을 막는 블로킹 방식으로 메타데이터를 제공하게 됩니다. 이런 봇들은 크롤링할 때 JavaScript를 실행할 수 없기 때문이죠.\n\nNext.js는 자동으로 들어오는 요청의 유저 에이전트(User Agent)를 감지해서 스트리밍 메타데이터를 줄지, 아니면 블로킹 메타데이터를 줄지 판단합니다.\n\n그런데, 혹시 Next.js가 기본으로 인식하는 봇 리스트 외에 내가 원하는 봇을 따로 지정하고 싶다면, next.config.js 파일 안에 `htmlLimitedBots` 옵션을 써서 직접 정할 수 있어요. 이 옵션에 정규표현식 패턴으로 유저 에이전트를 지정하면, 일치하는 봇들은 페이지를 요청할 때 무조건 블로킹 메타데이터를 받게 됩니다.\n\n예를 들어, `MySpecialBot`, `MyAnotherSpecialBot`, `SimpleCrawler`라는 봇을 직접 지정하려면 이렇게 작성하면 됩니다:\n\n```js\nimport type { NextConfig } from 'next'\n\nconst config: NextConfig = {\n  htmlLimitedBots: 'MySpecialBot|MyAnotherSpecialBot|SimpleCrawler',\n}\n\nexport default config\n```\n\n### 추가로 알아두면 좋은 점!\n- 이 기능 덕분에 트위터 같은 JavaScript를 실행하지 못하는 봇들이 페이지 메타데이터를 제대로 받아갈 수 있어, 공유 시에 미리보기 정보가 깨지지 않아요.\n- `htmlLimitedBots` 옵션에 너무 많은 봇을 넣으면 서버 리소스가 더 소모될 수 있으니 꼭 필요한 봇만 추가하는 게 좋습니다.\n- Next.js 13 이상의 App Router에서 적용되는 중요한 설정이며, 메타데이터 처리 최적화를 통해 SEO와 소셜 공유 품질을 높이고 싶을 때 활용해보세요!\n\n필요한 봇 패턴을 유연하게 커스터마이징해서, 내 웹사이트가 다양한 봇 환경에서도 깔끔하게 잘 작동하도록 만드는 팁이었습니다 :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nhtmlLimitedBots 설정을 지정하면 Next.js의 기본 유저 에이전트(user agent) 리스트를 덮어쓰게 되어, 어떤 봇이 이 동작을 선택할지 완전히 제어할 수 있습니다. 이 기능은 다소 고급스러운 설정이므로, 대부분의 경우 기본값으로도 충분합니다.\n\n아래는 버전별 주요 변경사항입니다:\n\n| 버전       | 변경사항                                                                                                                   |\n|------------|----------------------------------------------------------------------------------------------------------------------------|\n| v15.2.0    | `generateMetadata`에 스트리밍 지원이 도입되었습니다.                                                                          |\n| v13.2.0    | `viewport`, `themeColor`, `colorScheme` 설정이 더 이상 권장되지 않고, 대신 [viewport 구성](https://nextjs.org/docs/app/api-reference/functions/generate-viewport) 방식으로 대체되었습니다.  |\n| v13.2.0    | `metadata`와 `generateMetadata` 기능이 새롭게 도입되었습니다.                                                                 |\n\n덧붙여서, Next.js에서 메타데이터 관련 기능들이 점점 세분화되고 발전하면서, 메타데이터를 동적으로 생성하거나 스트리밍하는 기능들도 지원하고 있어 SEO 최적화나 성능 향상에 도움을 줄 수 있답니다. 앞으로 최신 Next.js 기능을 다룰 때는 이런 변화들을 잘 활용해보시는 걸 추천드려요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":84},{"title":"Next.js 15에서 generateImageMetadata 함수 사용하는 방법","description":"","date":"2025-04-22 03:04","slug":"2025-04-22-generateImageMetadata","content":"\n\n# generateImageMetadata 함수 소개\n\n여러분, 이미지 메타데이터를 다룰 때 직접 하나하나 값을 하드코딩하기 귀찮거나, 여러 버전의 이미지를 한꺼번에 처리하고 싶었던 적 있으신가요? 바로 그럴 때 `generateImageMetadata` 함수를 활용하면 정말 편리해요!\n\n이 함수는 하나의 이미지를 다양한 버전으로 만들어내거나, 한 라우트 세그먼트에 여러 이미지를 반환할 수 있도록 도와줘요. 특히 아이콘 같이 자주 쓰이면서도 크기나 형식이 달라지는 이미지 작업에 아주 유용하답니다.\n\n## 파라미터 (Parameters)\n\n`generateImageMetadata` 함수에 넘겨줄 수 있는 주요 파라미터들은 아래와 같아요:\n\n| 파라미터 이름 | 설명 |\n| --- | --- |\n| `src` | 기본 이미지 경로 또는 URL (필수) |\n| `sizes` | 생성할 이미지 크기 배열 (예: `[16, 32, 64]`) |\n| `formats` | 생성할 이미지 형식 배열 (예: `['png', 'webp']`) |\n| `outputDir` | 변환 이미지가 저장될 디렉터리 경로 |\n| `quality` | 이미지 압축 품질 (0~100) |\n| `background` | 배경색 설정 (특히 투명하지 않은 이미지에 유용) |\n\n위 내용은 가장 기본적이고 자주 사용하는 옵션들을 포함하고 있어요. 이외에도 상황에 따라 추가 설정이 가능하니 공식 문서를 참고하면 더 깊이 이해할 수 있습니다.\n\n---\n\n### 실무에서 이렇게 활용해보세요!\n\n1. **아이콘 다양화**  \n   앱이나 웹사이트 내에서 동일한 아이콘을 크기별, 포맷별로 자동 생성해서 사용하면 코드가 더 깔끔해지고, 다양한 기기 대응이 쉬워져요.\n\n2. **SEO와 성능 최적화**  \n   다양한 해상도와 포맷(WebP 등)을 지원하면 사용자의 네트워크 환경이나 브라우저에 맞춰 최적화된 이미지를 제공할 수 있어, 페이지 로딩 속도와 SEO에 도움이 됩니다.\n\n다음번에는 이 함수를 실제 코드 예제와 함께 '어떻게 사용하는지' 자세히 다뤄볼게요! 질문이나 궁금한 점 있으면 언제든 댓글 남겨주세요 :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n#### params (선택 사항)\n\n`params`는 동적 라우트 매개변수를 포함하는 객체인데요, 이 객체는 루트 세그먼트에서부터 `generateImageMetadata` 함수가 호출된 세그먼트까지의 매개변수를 담고 있어요.\n\n예를 들어, 아래처럼 `generateImageMetadata` 함수에 `params`를 전달받을 수 있습니다.\n\n```js\nexport function generateImageMetadata({\n  params,\n}: {\n  params: { slug: string }\n}) {\n  // ...\n}\n```\n\n이때, 라우트와 URL, 그리고 `params`의 예시는 다음 표처럼 이해하시면 편해요.\n\n| Route                       | URL        | params              |\n|-----------------------------|------------|---------------------|\n| `app/shop/icon.js`           | `/shop`    | `undefined`         |\n| `app/shop/[slug]/icon.js`    | `/shop/1`  | `{ slug: '1' }`     |\n| `app/shop/[tag]/[item]/icon.js` | `/shop/1/2` | `{ tag: '1', item: '2' }` |\n\n즉, URL 경로에 따라 `params` 객체 안에 전달되는 키와 값이 달라지는 거죠.\n\n참고로, Next.js 같은 프레임워크에서는 이 `params`를 통해 동적으로 페이지를 구성할 때 유용하게 쓰여요. 특히 여러 단계의 동적 세그먼트가 있을 경우, 이 객체를 활용해 필요한 데이터를 가져오거나 메타데이터를 생성할 수 있답니다.\n\n또 한 가지 팁을 드리자면, `params`가 `undefined`인 경우도 있으니 함수 내에서 안전하게 처리해주는 게 좋아요! 예를 들면 다음과 같이요:\n\n```js\nexport function generateImageMetadata({ params }) {\n  const slug = params?.slug ?? 'default';\n  // slug를 안전하게 사용\n}\n```\n\n이렇게 하면 예상치 못한 에러를 방지할 수 있답니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 리턴값 설명\n\n`generateImageMetadata` 함수는 이미지 메타데이터를 담은 객체들의 배열을 반환해야 합니다. 여기서 각 객체는 이미지의 대체 텍스트(`alt`), 크기(`size`) 같은 정보를 포함하고 있어요. 그리고 꼭 포함해야 할 값 중 하나가 `id`인데, 이 값은 이미지 생성 컴포넌트에서 props로 전달받게 됩니다.\n\n아래는 반환하는 객체 구조를 간단히 정리한 표예요:\n\n| Image Metadata Object | Type                      |\n|----------------------|---------------------------|\n| `id`                 | `string` (필수)            |\n| `alt`                | `string`                   |\n| `size`               | `{ width: number; height: number }` |\n| `contentType`        | `string`                   |\n\n### 예제 코드\n\n```js\nimport { ImageResponse } from 'next/og'\n \nexport function generateImageMetadata() {\n  return [\n    {\n      contentType: 'image/png',\n      size: { width: 48, height: 48 },\n      id: 'small',\n    },\n    {\n      contentType: 'image/png',\n      size: { width: 72, height: 72 },\n      id: 'medium',\n    },\n  ]\n}\n \nexport default function Icon({ id }: { id: string }) {\n  return new ImageResponse(\n    (\n      \u003cdiv\n        style={{\n          width: '100%',\n          height: '100%',\n          display: 'flex',\n          alignItems: 'center',\n          justifyContent: 'center',\n          fontSize: 88,\n          background: '#000',\n          color: '#fafafa',\n        }}\n      \u003e\n        Icon {id}\n      \u003c/div\u003e\n    )\n  )\n}\n```\n\n---\n\n### 조금 더 설명을 덧붙이자면\n\n- `generateImageMetadata` 함수는 이미지가 다양할 때 각각에 맞는 메타정보를 한꺼번에 관리할 수 있어 편리합니다.\n- 각 이미지별 `id`는 컴포넌트에서 어떤 이미지를 렌더할지 구분하는 역할을 해요. 이 `id`를 이용해 동적으로 이미지 내용을 바꾸거나 다르게 스타일링할 수 있습니다.\n- `contentType`은 보통 이미지 포맷을 지정하는데, 예를 들어 `image/png`나 `image/jpeg` 등을 쓸 수 있어요.\n- `alt` 값은 UI 접근성을 높이기 위해 넣으면 좋습니다. 이미지 로딩 실패 시나 스크린 리더 사용자의 이해를 도와주니까요.\n\n그리고 스타일링 부분에서, 인라인 스타일에 중괄호 `{}`를 빼먹을 수 있는데 꼭 유의하세요! 예제 코드처럼 객체형태로 잘 감싸야 합니다.\n\n필요에 따라 더 다양한 메타데이터를 포함시켜 유연하게 확장하는 것도 추천드려요~!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 예제\n\n#### 외부 데이터를 활용한 이미지 생성\n\n이번 예제에서는 `params` 객체와 외부 데이터를 사용해 라우트 세그먼트에 대해 여러 개의 Open Graph 이미지를 생성하는 방법을 보여드릴게요.\n\n```js\nimport { ImageResponse } from 'next/og'\nimport { getCaptionForImage, getOGImages } from '@/app/utils/images'\n\nexport async function generateImageMetadata({\n  params,\n}: {\n  params: { id: string }\n}) {\n  const images = await getOGImages(params.id)\n\n  return images.map((image, idx) =\u003e ({\n    id: idx,\n    size: { width: 1200, height: 600 },\n    alt: image.text,\n    contentType: 'image/png',\n  }))\n}\n\nexport default async function Image({\n  params,\n  id,\n}: {\n  params: { id: string }\n  id: number\n}) {\n  const productId = (await params).id\n  const imageId = id\n  const text = await getCaptionForImage(productId, imageId)\n\n  return new ImageResponse(\n    (\n      \u003cdiv\n        style={\n          {\n            // ...\n          }\n        }\n      \u003e\n        {text}\n      \u003c/div\u003e\n    )\n  )\n}\n```\n\n---\n\n위 예제는 `params.id`를 기반으로 여러 Open Graph 이미지를 생성해주는 방식이에요. 먼저 `generateImageMetadata` 함수에서 외부 유틸 함수 `getOGImages`를 호출해 이미지 메타데이터들을 불러옵니다. 그리고 각각의 이미지를 원하는 크기와 alt 텍스트, 콘텐츠 타입과 함께 반환하죠.\n\n또한, 이미지 생성 함수 `Image`에서는 각각의 이미지 ID와 제품 ID를 받아서 해당 이미지에 들어갈 텍스트 캡션을 외부에서 가져와 렌더링합니다.\n\n\u003e 참고로 이런 방식을 사용하면 한 가지 라우트에 여러 OG 이미지를 동적으로 생성할 수 있어서, SNS에서 링크를 공유할 때 다양한 시각적 표현이 가능해집니다.  \n\u003e  \n\u003e 그리고 `ImageResponse`는 Next.js의 `next/og` 모듈에서 제공하는 기능으로, JSX를 기반으로 이미지를 그릴 수 있게 해줘요. 평소 HTML이나 React를 다루는 것처럼 편하게 이미지 레이아웃도 조절 가능하니 참 편리합니다.\n\n여기에 좀 더 스타일을 입히거나, 이미지 안에 다른 컴포넌트나 아이콘, 배경색 등을 넣어서 더욱 멋진 OG 이미지를 만들 수도 있겠네요. 이렇게 동적으로 메타데이터와 이미지를 생성하는 것은 SEO뿐만 아니라, 사용자 경험 향상에도 크게 도움을 줄 수 있습니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 버전 히스토리\n\n| 버전      | 변경 사항                       |\n|-----------|-------------------------------|\n| v13.3.0   | `generateImageMetadata` 기능 추가 |\n\n여기서 `generateImageMetadata`라는 기능이 새롭게 도입된 걸 확인할 수 있어요. 혹시 이미지 처리나 메타데이터 자동 생성과 관련된 작업을 한다면, 이 기능이 꽤 유용할 거예요. 나중에 직접 사용해보고 어떤 점이 좋은지, 어떻게 활용할 수 있는지도 다뤄볼게요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":8},{"title":"Next.js 15에서 Forbidden 에러 해결하는 방법","description":"","date":"2025-04-22 03:03","slug":"2025-04-22-forbidden","content":"\n\n# forbidden 함수 사용법과 설정 가이드\n\n안녕하세요! 오늘은 Next.js에서 권한 오류를 처리할 때 아주 유용한 `forbidden` 함수에 대해 알아볼게요. 이 함수는 권한이 없을 때 403 에러 페이지를 띄워주는데, 기본 제공 UI를 `forbidden.js` 파일로 직접 커스터마이징할 수도 있어서 유용하답니다.\n\n## forbidden 함수란?\n\n`forbidden` 함수는 사용자가 접근 권한이 없을 때 호출하면, Next.js가 자동으로 403 에러 페이지를 렌더링해 줍니다. 보통 로그인 상태나 권한 상태를 체크할 때 유용하게 쓸 수 있어요.\n\n## 설정 방법\n\n`forbidden` 함수를 쓰려면 먼저 `next.config.js`에서 실험적 기능인 `authInterrupts` 옵션을 활성화해야 합니다. 아래처럼 설정해 주세요:\n\n```js\nimport type { NextConfig } from 'next'\n\nconst nextConfig: NextConfig = {\n  experimental: {\n    authInterrupts: true,\n  },\n}\n\nexport default nextConfig\n```\n\n이 설정을 하면 `forbidden` 함수를 호출했을 때 Next.js가 자동으로 권한 부족 화면을 보여주게 됩니다.\n\n## forbidden.js로 UI 커스터마이징하기\n\n기본 403 화면 대신 회사나 프로젝트에 맞는 디자인으로 꾸미고 싶다면, 앱 루트에 `forbidden.js` 파일을 만들어서 커스텀 UI를 구현할 수 있어요.\n\n예를 들어:\n\n```jsx\nexport default function Forbidden() {\n  return (\n    \u003cdiv style={{ textAlign: 'center', padding: '2rem' }}\u003e\n      \u003ch1\u003e403 - 접근 금지\u003c/h1\u003e\n      \u003cp\u003e죄송합니다만, 이 페이지에 접근할 권한이 없습니다.\u003c/p\u003e\n      \u003cbutton onClick={() =\u003e window.location.href = '/login'}\u003e\n        로그인 페이지로 가기\n      \u003c/button\u003e\n    \u003c/div\u003e\n  )\n}\n```\n\n이런 식으로 친근한 UI를 만들어 놓으면 사용자 경험이 더 좋아질 거예요.\n\n## 팁: 권한 체크 로직과 연동하기\n\n실제로는 서버나 클라이언트에서 인증 정보를 확인한 후, 권한이 없으면 `forbidden()`을 호출하는 식으로 동작합니다. 예를 들어:\n\n```js\nimport { forbidden } from 'next/dist/server/api-utils'\n\nexport async function getServerSideProps(context) {\n  const user = await getUserFromSession(context.req)\n\n  if (!user || !user.hasAccess) {\n    throw forbidden()\n  }\n\n  return { props: { user } }\n}\n```\n\n이렇게 하면 권한이 없는 사용자에겐 자동으로 403 페이지가 렌더링됩니다.\n\n---\n\nNext.js에서 권한 관련 에러 처리를 깔끔히 하고 싶다면 `forbidden` 함수와 `authInterrupts` 설정을 적극 활용해 보세요. 기본 UI는 귀찮으면 그대로 써도 좋고, 필요하면 `forbidden.js`로 멋지게 꾸며 보시고요!\n\n필요한 내용 있으면 언제든 질문 남겨 주세요~ :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nnext.js에서 `forbidden` 함수는 Server Components, Server Actions, 그리고 Route Handlers 안에서만 호출할 수 있어요. 이 함수는 권한이 없는 사용자가 특정 페이지에 접근하려 할 때 간단하게 403 상태 코드를 반환하도록 도와주는데요, 예를 들어 관리자 페이지 같은 경우에 유용하게 사용할 수 있죠.\n\n아래 예시를 한번 보세요:\n\n```jsx\nimport { verifySession } from '@/app/lib/dal'\nimport { forbidden } from 'next/navigation'\n \nexport default async function AdminPage() {\n  const session = await verifySession()\n \n  // 사용자가 'admin' 역할인지 확인\n  if (session.role !== 'admin') {\n    forbidden() // 권한 없으면 403 에러를 발생시켜요.\n  }\n \n  // 권한이 있으면 관리자 페이지 렌더링\n  return \u003c\u003e\u003c/\u003e\n}\n```\n\n여기서 `verifySession()`은 사용자 세션을 확인하고, 세션에 포함된 `role` 정보를 바탕으로 권한 검사를 하게 됩니다. 만약 역할이 'admin'이 아니라면 `forbidden()` 함수를 호출해서 접근을 차단하는 거죠.\n\n### 알고 있으면 좋은 점\n- `forbidden` 함수는 루트 레이아웃(root layout)에서는 호출할 수 없어요. 루트 레이아웃에서 호출하면 에러가 발생하니 주의하세요.\n- `forbidden()` 이 호출되면 HTTP 상태 코드 403이 자동으로 반환되고, 페이지는 더 이상 렌더링되지 않습니다.\n- 이 방법은 클라이언트 사이드가 아닌 서버 사이드에서 권한 체크가 진행되기 때문에 보안적으로 훨씬 안전합니다.\n\n요약하면, Next.js에서 권한 제어를 할 때 서버 컴포넌트나 서버 액션, 라우트 핸들러에서 `forbidden()`을 이용해 간편하고 안전하게 접근을 제한할 수 있다는 점 기억하세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 예제\n\n### 역할(role) 기반 라우트 보호\n\n`forbidden` 함수를 사용하면 유저의 역할에 따라 특정 페이지 접근을 제한할 수 있어요. 인증은 되었지만 권한이 없는 사용자가 중요한 페이지에 들어오는 걸 막는 데 아주 유용하답니다.\n\n```js\nimport { verifySession } from '@/app/lib/dal'\nimport { forbidden } from 'next/navigation'\n\nexport default async function AdminPage() {\n  const session = await verifySession()\n\n  // 유저의 역할이 'admin'인지 확인하기\n  if (session.role !== 'admin') {\n    forbidden()  // 권한 없으면 접근 금지 처리\n  }\n\n  // 권한이 확인된 사용자에게 관리자 페이지 렌더링\n  return (\n    \u003cmain\u003e\n      \u003ch1\u003eAdmin Dashboard\u003c/h1\u003e\n      \u003cp\u003eWelcome, {session.user.name}!\u003c/p\u003e\n    \u003c/main\u003e\n  )\n}\n```\n\n---\n\n### 조금 더 설명을 덧붙이자면\n\n- `verifySession()` 같은 함수는 보통 로그인 상태와 사용자 정보를 서버에서 확인하는 역할을 해요.\n- `forbidden()`이 호출되면 Next.js가 자동으로 403 상태 코드를 반환하면서 페이지 렌더링을 막아요.\n- 이 구조를 응용하면 관리자뿐만 아니라 일반 회원, VIP 등 다양한 권한 기반 페이지 구성이 깔끔하게 가능하답니다.\n- 클라이언트 쪽이 아니라 서버 사이드에서 권한 검사를 하기에 보안도 한층 강해지죠.\n\n이런 식으로 `forbidden()`을 적절히 써서 중요한 페이지에 사용자 권한을 확실히 적용할 수 있답니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### Server Actions에서의 Mutation 사용하기\n\n서버 액션(Server Actions)으로 뮤테이션(mutation)을 구현할 때, 민감한 데이터를 업데이트하는 작업은 꼭 특정 권한이 있는 사용자만 할 수 있도록 제한하는 게 중요해요. 예를 들어, 관리자(admin)만 역할(role)을 변경할 수 있게 막는 방법을 살펴볼게요.\n\n```js\n'use server'\n\nimport { verifySession } from '@/app/lib/dal'\nimport { forbidden } from 'next/navigation'\nimport db from '@/app/lib/db'\n\nexport async function updateRole(formData: FormData) {\n  const session = await verifySession()\n\n  // 관리자만 역할 변경 권한을 부여\n  if (session.role !== 'admin') {\n    forbidden()\n  }\n\n  // 권한 확인 후 역할 업데이트 로직 수행\n  // ...\n}\n```\n\n여기서 중요한 건 `verifySession()` 함수를 통해 현재 사용자의 세션 정보를 받아와서, 역할(role)이 'admin'인지 확인하는 부분이에요. 만약 관리자가 아니라면, `forbidden()` 함수를 호출해서 접근을 막아요. 이 함수는 Next.js의 내비게이션에서 권한을 제한할 때 쓰이는 함수로, 권한이 없으면 클라이언트에 적절한 에러 페이지를 보여줍니다.\n\n---\n\n### 덧붙여서!\n\n- **세션 검증은 꼭 서버에서!**  \n  세션이나 권한 체크 등 보안과 관련된 로직은 클라이언트가 아니라 서버에서 처리해야 안전합니다.\n\n- **forbidden() 외 에러 처리**  \n  상황에 따라서는 `forbidden()` 대신 직접 403 응답을 커스텀할 수도 있지만, Next.js 내장 함수 사용이 더 간편하고 안전하죠.\n\n- **코드 구조 고민하기**  \n  `updateRole` 같은 함수는 재사용성, 테스트 용이성 측면에서 최대한 작게, 명확하게 작성하는 게 좋아요.\n\n- **db 연동**  \n  주석 처리된 부분에는 실제 데이터베이스 업데이트 로직을 넣으면 되는데, 예를 들어 Prisma 같은 ORM을 사용한다면, `db.user.update()` 같은 함수를 호출해서 처리할 수 있어요.\n\n서버 액션에서 뮤테이션을 처리할 때 권한 체크를 깔끔하게 하는 방법, 참고가 되었으면 좋겠습니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 위의 HTML table 태그를 Markdown 형식으로 바꾼 내용입니다.\n\n| Version   | Changes                   |\n|-----------|---------------------------|\n| `v15.1.0` | `forbidden` introduced.   |\n\n여기서 `forbidden`이라는 새 기능이 v15.1.0 버전에 추가됐다고 하는데요, 보통 이런 변화는 특정 상황에서 접근을 제한하거나 권한을 관리할 때 활용되곤 합니다. 만약 여러분이 API나 설정에서 권한 관련 처리를 한다면, `forbidden` 옵션이 어떤 역할을 하는지 한번 체크해보는 것도 좋겠네요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":7},{"title":"Nextjs 15에서 draftMode 기능 사용 방법","description":"","date":"2025-04-22 03:02","slug":"2025-04-22-draftMode","content":"\n\n# draftMode\n\n이번에 소개할 기능은 Next.js에서 제공하는 `draftMode`라는 async 함수입니다. 이 함수는 서버 컴포넌트(Server Component) 내에서 Draft Mode를 켜고 끌 수 있게 해주고, 현재 Draft Mode가 활성화되어 있는지도 확인할 수 있어요.\n\n```js\nimport { draftMode } from 'next/headers'\n\nexport default async function Page() {\n  const { isEnabled } = await draftMode()\n  // isEnabled가 true면 Draft Mode가 활성화된 상태,\n  // false면 비활성화 상태입니다.\n}\n```\n\n## Draft Mode란?\n\nNext.js에서 Draft Mode는 관리자나 콘텐츠 작성자가 실제 공개된 페이지와는 별개로 콘텐츠를 미리보기하거나 테스트할 때 유용합니다. 보통 CMS(Content Management System)와 연동해서, 아직 퍼블리시되지 않은 글이나 변경사항을 미리 볼 때 많이 활용되죠.\n\n## draftMode 함수 주요 기능\n\n- **활성화**: Draft Mode 켜기\n- **비활성화**: Draft Mode 끄기\n- **상태확인**: 현재 Draft Mode가 켜져 있는지 확인\n\n### 예를 들어 Draft Mode를 켜고 끄는 방법\n\n아래처럼 `enable()`과 `disable()` 메서드를 쓸 수 있어요.\n\n```js\nimport { draftMode } from 'next/headers'\n\nexport default async function Page() {\n  const draft = await draftMode()\n\n  // Draft Mode 활성화\n  draft.enable()\n\n  // Draft Mode 비활성화 (필요시)\n  // draft.disable()\n\n  const { isEnabled } = await draftMode()\n  console.log('Draft Mode 활성화 여부:', isEnabled)\n}\n```\n\n## 참고할 점\n\n- `draftMode()`는 서버 컴포넌트에서만 쓸 수 있습니다. 클라이언트 컴포넌트에서는 동작하지 않아요.\n- 주로 CMS와 함께 사용해, 콘텐츠 미리보기를 간단하게 구현할 때 유용합니다.\n- Draft Mode가 켜져 있으면, 예를 들어 API 요청 시 비공개 상태인 콘텐츠도 가져오도록 설정할 수 있죠.\n\n요즘 Next.js가 점점 서버 기능과 콘텐츠 관리 기능을 강화하는데, Draft Mode는 그 중에서도 굉장히 실용적인 기능이니 꼭 한번 써보시길 추천합니다!  \n\n---\n\n## Reference\n\n- [Next.js Documentation - draftMode](https://nextjs.org/docs/app/building-your-application/configuration/draft-mode) (공식 문서 링크)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음은 Draft Mode에서 사용할 수 있는 메서드와 프로퍼티들입니다:\n\n| 메서드         | 설명                                                         |\n| -------------- | ------------------------------------------------------------ |\n| `isEnabled`    | Draft Mode가 활성화되어 있는지 여부를 나타내는 boolean 값입니다. |\n| `enable()`     | Route Handler에서 Draft Mode를 활성화하며, 이때 `__prerender_bypass` 쿠키를 설정합니다. |\n| `disable()`    | Route Handler에서 Draft Mode를 비활성화하며, 쿠키를 삭제합니다. |\n\n---\n\n## 알아두면 좋은 팁\n\n- `draftMode` 함수는 비동기 함수로, Promise를 반환합니다. 따라서 `async/await`를 사용하거나 React의 `use` 함수를 사용해야 해요.  \n  예전(Next.js 14버전 이하)에는 `draftMode`가 동기 함수였는데, 15버전에서는 하위 호환성을 위해 동기 접근도 가능하지만 곧 Deprecated될 예정입니다.\n\n- `next build`를 할 때마다 새로운 우회 쿠키 값이 생성되기 때문에, 이 쿠키 값을 예측하기 어렵습니다. 보안 측면에서 좋은 변화죠!\n\n- 로컬에서 Draft Mode를 HTTP로 테스트할 때는 브라우저 설정에서 **서드파티 쿠키 허용** 및 **로컬 스토리지 접근 허용**이 필요하니 참고하세요.\n\n---\n\n### 좀 더 자세한 설명!\n\n`Draft Mode`는 쉽게 말해 \"임시 저장\" 모드 같은 개념인데요, 보통은 빌드된 정적 페이지를 보여주지만, 이 모드를 켜면 실시간으로 수정 중인 데이터를 확인할 수 있어 개발할 때 정말 유용합니다. 예를 들어, CMS에서 콘텐츠를 수정하며 바로바로 결과를 확인하고 싶을 때 많이 쓰이죠.\n\n`enable()`을 호출하면 내부적으로 `__prerender_bypass`라는 쿠키가 설정되고, Next.js 서버는 이 쿠키를 보고 캐시된 정적 파일 대신 최신 서버 데이터를 반환합니다. 그리고 개발이 끝났으면 `disable()`을 호출해서 쿠키를 삭제해 다시 캐싱된 페이지를 보여주도록 해요.\n\n마지막으로, 비동기 함수라는 점을 꼭 주의하세요. Next.js가 점점 비동기 패턴을 밀고 있기 때문에, 예전처럼 동기적으로 호출하면 버그가 날 수 있으니 async/await 사용을 권장합니다.\n\n이 글이 Draft Mode를 이해하는 데 도움이 됐길 바라요! 개발하면서 궁금한 점 있으면 언제든 물어보세요~\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 예제\n\n### Draft Mode 활성화하기\n\nDraft Mode를 사용하려면 새로운 Route Handler를 만들고 `enable()` 메서드를 호출하면 돼요. 이렇게 하면 임시로 수정 중인 내용을 확인할 수 있답니다.\n\n```js\nimport { draftMode } from 'next/headers'\n\nexport async function GET(request: Request) {\n  const draft = await draftMode()\n  draft.enable()\n  return new Response('Draft mode is enabled')\n}\n```\n\n---\n\n### 조금 더 설명하자면?\n\n`draftMode()` 함수는 현재 요청에서 Draft Mode의 상태를 제어할 수 있는 객체를 반환해줘요. 그 객체의 `enable()` 메서드를 호출하면 그 사용자의 세션에 Draft Mode가 활성화돼서, 보통은 비공개로 관리되는 수정 중인 콘텐츠들을 볼 수 있게 되죠.\n\n예를 들어, 컨텐츠 수정 중인 페이지를 실시간으로 확인하고 싶을 때 엄청 편리해요. 반대로 `disable()` 메서드를 호출하면 Draft Mode가 해제됩니다.\n\nNext.js를 사용 중이라면 이 기능을 활용해서 콘텐츠 검수나 개발 중인 기능 확인도 쉽게 할 수 있으니, 꼭 한 번 써보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### Draft Mode 끄기\n\n기본적으로 Draft Mode는 브라우저를 닫으면 세션이 종료돼요.\n\n하지만 직접 Draft Mode를 끄고 싶다면, Route Handler 안에서 `disable()` 메서드를 사용하면 돼요. 예를 들어:\n\n```js\nimport { draftMode } from 'next/headers'\n\nexport async function GET(request: Request) {\n  const draft = await draftMode()\n  draft.disable()\n  return new Response('Draft mode is disabled')\n}\n```\n\n이렇게 하면 현재 세션에서 Draft Mode가 비활성화돼서, 더 이상 임시 콘텐츠나 수정된 내용을 확인할 수 없게 돼요.\n\n여기서 한 가지 팁! 보통 Draft Mode는 테스트나 미리보기용으로 많이 쓰이니, 실제 서비스에선 잘 꺼두는 게 좋아요. Draft Mode가 켜진 상태에서는 캐싱이나 일부 기능이 동작하지 않을 수 있으니까요.\n\n참고로, Next.js의 `draftMode()`는 클라이언트-서버 환경 모두에서 사용 가능해, 서버에서 조건에 따라 쉽게 Draft Mode를 켜고 끌 수 있다는 점도 기억해두세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여러분, Next.js에서 Route Handler를 호출할 때 주의할 점이 있어요! 만약 `Link` 컴포넌트를 이용해서 라우트를 호출한다면, `prefetch='false'`를 꼭 넘겨줘야 해요. 이걸 안 하면 prefetch 과정에서 쿠키가 의도치않게 삭제될 수 있거든요. \n\n---\n\n### Draft Mode가 켜져 있는지 확인하는 방법\n\n서버 컴포넌트(Server Component)에서 Draft Mode가 활성화되어 있는지 확인하고 싶을 때는, `next/headers` 모듈의 `draftMode` 함수를 사용하면 돼요. 이 함수는 `isEnabled`라는 프로퍼티를 반환하는데, 이걸 통해 현재 Draft Mode 상태를 알 수 있죠.\n\n아래 코드를 한 번 보세요:\n\n```js\nimport { draftMode } from 'next/headers'\n\nexport default async function Page() {\n  const { isEnabled } = await draftMode()\n  return (\n    \u003cmain\u003e\n      \u003ch1\u003eMy Blog Post\u003c/h1\u003e\n      \u003cp\u003eDraft Mode is currently {isEnabled ? 'Enabled' : 'Disabled'}\u003c/p\u003e\n    \u003c/main\u003e\n  )\n}\n```\n\n이렇게 하면 페이지를 렌더링할 때 Draft Mode가 켜져 있는지 바로 확인할 수 있어요. \n\n\u003e 팁 하나 더! Draft Mode는 예를 들어 컨텐츠를 작성하거나 수정할 때 유용해요. 실제로 배포된 최종 버전에 반영되기 전에 미리 볼 수 있게 해주는 기능이라, 가끔 이 상태가 켜져 있는지 확인해 보는 것이 중요하답니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 버전 히스토리\n\n| 버전           | 변경사항                                                                                 |\n| -------------- | ---------------------------------------------------------------------------------------- |\n| `v15.0.0-RC`   | `draftMode`가 이제 비동기 함수(async function)로 변경되었습니다. 관련 [코드모드(codemod)](/docs/app/guides/upgrading/codemods#150)도 제공 중이에요. |\n| `v13.4.0`      | `draftMode` 기능이 처음 도입되었습니다.                                                  |\n\n---\n\n여기서 잠깐! `draftMode`라는 기능이 뭔지 궁금하신 분들도 계실텐데요, 쉽게 말해서 Next.js에서 \"초안 모드\"처럼 작동해서 페이지가 캐시되지 않고 항상 최신 상태를 유지하도록 도와주는 기능이에요. 특히 서버사이드 렌더링하거나 ISR(Incremental Static Regeneration)을 사용할 때 실시간 업데이트가 필요할 때 유용하답니다.\n\n그리고 `v15.0.0-RC`부터는 이 `draftMode` 함수가 async로 바뀌면서, 내부에서 비동기 작업이 가능해졌어요. 만약 이전 버전에서 사용 중이라면 코드 모드를 통해 자동으로 변환할 수 있으니 큰 걱정 하지 않아도 됩니다! \n\nNext.js 같은 프레임워크가 계속 발전하면서 이런 세세한 변경사항도 꼭 챙겨 두시는 게 좋아요. 개발할 때 버전별 차이로 헷갈리는 일이 줄어들 거예요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":8},{"title":"Next.js 15에서 fetch API 활용하는 최신 방법","description":"","date":"2025-04-22 03:02","slug":"2025-04-22-fetch","content":"\n\n# fetch\n\nNext.js에서는 기본 웹 fetch() API를 확장해서, 서버에서 각 요청마다 고유한 지속 캐싱(persistent caching)과 재검증(revalidation) 규칙을 설정할 수 있도록 했어요.\n\n브라우저에서는 fetch 요청 시 cache 옵션이 브라우저 HTTP 캐시와 어떻게 상호작용할지를 지정하잖아요? 그런데 Next.js의 확장된 fetch에서는 서버 사이드에서 할 때 이 cache 옵션이 프레임워크가 관리하는 지속 데이터 캐시(persistent Data Cache)와 어떻게 상호작용할지를 결정해줘요.\n\n즉, 서버 컴포넌트 안에서 async/await와 함께 그냥 fetch를 호출해도, 이 캐시 전략들이 작동하면서 성능 향상 및 데이터 최신성을 관리해준다는 뜻이에요.\n\n---\n\n### 추가 설명\n\n- **지속 데이터 캐시란?**  \n  서버에서 한 번 가져온 데이터를 일정 시간 동안 저장해서, 같은 데이터를 재요청할 때 네트워크 호출을 줄여주는 역할을 해요. 그래서 유저 입장에선 페이지가 더 빨리 로드되고, 서버 부담도 줄어들죠.\n\n- **재검증(revalidation)이 뭐예요?**  \n  캐시된 데이터가 오래되었는지 주기적으로 체크해서, 최신 데이터가 필요하면 다시 fetch를 하는 거예요.\n\n- **서버 컴포넌트에서 fetch를 쓴다?**  \n  Next.js 13부터 도입된 서버 컴포넌트 덕분에, 서버에서 비동기적으로 데이터를 패칭하고 바로 렌더링할 수 있어요. 클라이언트에서 데이터 로딩 처리하는 걸 줄일 수 있죠.\n\n---\n\n### 예시 코드\n\n```jsx\n// 서버 컴포넌트 내에서 fetch 사용\nexport default async function Page() {\n  const res = await fetch('https://api.example.com/data', {\n    cache: 'force-cache'  // 고정된 캐시 전략 적용\n  });\n  const data = await res.json();\n\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003e서버에서 가져온 데이터\u003c/h1\u003e\n      \u003cpre\u003e{JSON.stringify(data, null, 2)}\u003c/pre\u003e\n    \u003c/div\u003e\n  )\n}\n```\n\nNext.js의 fetch API 확장 덕분에 서버 쪽 데이터 요청을 더 똑똑하게 관리할 수 있으니, 다음 프로젝트에 꼭 활용해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여러분, Next.js에서 데이터를 불러오는 방법에 대해 이야기해볼게요. 위에 있는 코드를 보시면, `fetch` 함수로 외부 API에서 데이터를 받아와서 화면에 포스트 리스트를 렌더링하는 아주 기본적인 예제입니다.\n\n```jsx\nexport default async function Page() {\n  let data = await fetch('https://api.vercel.app/blog')\n  let posts = await data.json()\n  return (\n    \u003cul\u003e\n      {posts.map((post) =\u003e (\n        \u003cli key={post.id}\u003e{post.title}\u003c/li\u003e\n      ))}\n    \u003c/ul\u003e\n  )\n}\n```\n\n### Next.js의 fetch() API 활용\n\nNext.js는 기본적으로 웹의 `fetch()` API를 확장해서 제공하는데요, 그래서 우리가 익숙한 `fetch` 옵션들을 그대로 사용할 수 있다는 점이 편리해요. 이번에 살펴볼 옵션 중 하나가 `cache` 옵션입니다.\n\n### `options.cache`\n\n`cache` 옵션은 데이터를 어떻게 캐싱할지를 결정하는 역할을 해요. 예를 들어, 기본적으로는 서버 컴포넌트에서 데이터를 패칭할 때 `cache`가 적용되어, 다음에 같은 요청이 오면 캐시된 데이터를 바로 사용할 수 있도록 돼 있죠. 이걸 조절하면, 실시간 데이터가 중요하거나, 너무 자주 데이터를 갱신할 필요가 있을 때 유용해요.\n\n- `\"default\"`: 기본 캐싱 정책을 따릅니다.\n- `\"no-cache\"`: 매번 네트워크에서 새 데이터를 받아옵니다.\n- `\"force-cache\"`: 캐시된 데이터만 사용하고 네트워크 요청은 안 합니다.\n- `\"only-if-cached\"`: 캐시된 데이터가 없으면 실패합니다.\n\n예를 들어, 이렇게 쓸 수 있어요:\n\n```js\nlet data = await fetch('https://api.vercel.app/blog', { cache: 'no-cache' })\n```\n\n이렇게 하면 무조건 최신 데이터를 받아오기 때문에, 실시간 뉴스나 가격 정보처럼 자주 업데이트되는 데이터에 적합합니다.\n\n---\n\n### 한 가지 꿀팁!\n\nNext.js 13부터는 `fetch`에 `next` 옵션도 함께 쓸 수 있는데요, 굉장히 강력합니다. 예를 들어 `next: { revalidate: 10 }` 옵션을 넣으면, 데이터를 받아와서 10초마다 캐시를 리프레시하도록 할 수 있어요. 이렇게 하면 서버 부하도 줄이고, 사용자는 어느 정도 최신 데이터를 볼 수 있죠.\n\n```js\nlet data = await fetch('https://api.vercel.app/blog', {\n  next: { revalidate: 10 }\n})\n```\n\n한마디로, 여러분 프로젝트 상황에 맞게 캐시 전략을 유연하게 조절해 보세요. 그럼 데이터 패칭도 똑똑하게 할 수 있답니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 요청이 데이터 캐시와 어떻게 상호작용할지 설정하는 방법에 대해 설명해드릴게요.\n\n```js\nfetch(`https://...`, { cache: 'force-cache' | 'no-store' })\n```\n\n여기서 cache 옵션은 세 가지 주요 상태가 있어요:\n\n| 옵션          | 동작 설명                                                                                           |\n|---------------|---------------------------------------------------------------------------------------------------|\n| auto (기본값) | 개발 환경에서는 매 요청마다 원격 서버에서 데이터를 가져와요. 하지만 빌드 시점에 페이지가 정적으로 사전 렌더링되면 그때 한 번만 가져와요. 그리고 동적 API가 감지되면 매 요청마다 데이터를 가져오죠. |\n| no-store      | 동적 API 여부와 상관없이 항상 매 요청마다 원격 서버에서 데이터를 가져와요. 캐시를 사용하지 않는 느낌이에요.                    |\n| force-cache   | Next.js의 데이터 캐시에서 일치하는 요청이 있는지 찾아요. ‘신선한’ 캐시가 있으면 캐시에서 바로 반환하고, 없거나 오래된 캐시라면 원격 서버에서 새로 데이터를 받아와 캐시를 업데이트해요.  |\n\n### 추가 꿀팁!\n\n- 캐시가 ‘신선한(fresh)’하다는 말은 캐시된 데이터가 아직 유효하다는 뜻이에요. 이를 판단하는 기준은 Next.js 내부 정책이나 `revalidate` 옵션에 따라 달라집니다.\n- `force-cache`를 사용하면 빌드 시점의 데이터를 최대한 활용하면서도, 변경사항이 있을 때만 서버에서 최신 데이터를 받을 수 있어서 효율적이에요.\n- 개발 중에는 기본 `auto` 모드가 편리하지만, 프로덕션 환경에서는 상황에 맞게 `no-store` (실시간 업데이트 필요 시)나 `force-cache` (최소한의 요청으로 성능 최적화 시)를 선택하는 게 좋아요.\n\n### options.next.revalidate\n\n이 옵션은 캐시를 갱신하는 주기를 설정할 때 쓰입니다. 예를 들어, \n\n```js\nfetch('https://...', { next: { revalidate: 60 } })\n```\n\n이렇게 설정하면, 캐시된 데이터가 60초가 지나면 다음 요청 때 새로 갱신해요. 다시 말해, 1분마다 데이터를 새로고침하는 것과 같죠.\n\n이걸 적절히 활용하면 새로 고침의 빈도와 SEO 최적화를 균형 있게 맞출 수 있습니다.\n\n---\n\nNext.js의 데이터 캐시는 페이지 성능과 사용자 경험에 큰 영향을 주니, 개발 환경과 서비스 특성에 맞게 잘 설정해 보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nfetch 함수에 `next: { revalidate: ... }` 옵션을 주면 리소스의 캐시 수명을 초 단위로 설정할 수 있어요. 쉽게 말해, 캐시가 얼마 동안 유지될지 정하는 거죠. 이 옵션에 따라 캐싱 동작이 달라집니다.\n\n| revalidate 값 | 의미                                                         |\n|---------------|--------------------------------------------------------------|\n| false         | 리소스를 무한정 캐시해요. (사실상 revalidate: Infinity와 같아요.) HTTP 캐시는 오랫동안 쓰다가 오래된 캐시를 지울 순 있지만, 기본적으로 무제한으로 저장합니다. |\n| 0             | 캐시를 절대 하지 않아요. 항상 리소스를 새롭게 받아옵니다.       |\n| number        | 숫자(초)만큼 캐시 생명주기를 정해요. 예를 들어 60이면 60초간 캐시 유지. |\n\n### 좀 더 알아두면 좋은 점\n\n- 특정 fetch 요청에서 설정한 `revalidate` 값이 라우트(route) 기본 값보다 작으면, 라우트 전체의 리밸리데이트 간격도 그만큼 줄어듭니다.\n- 같은 URL을 가진 두 개의 fetch 요청이 각각 다른 `revalidate` 값을 가지고 있다면, 더 짧은 시간(낮은 값)이 적용됩니다.\n- `revalidate`를 숫자로 주면 따로 `cache` 옵션을 설정하지 않아도 돼요.\n- `revalidate`와 `cache` 옵션이 모순되는 설정(예: `revalidate: 3600`인데 `cache: 'no-store'`)을 하면 에러가 발생해요.\n\n### 참고로,\n이 옵션은 Next.js에서 제공하는 기능으로, 서버 측 데이터 패칭 시 자동으로 ISR(Incremental Static Regeneration)을 조절하는데 유용합니다. 개발할 때 캐시 정책을 유연하게 조절하면, 페이지 성능과 최신성 사이에서 좋은 균형을 맞출 수 있어요.\n\n혹시 어떻게 쓰는지 구체적인 예시가 궁금하다면 알려주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### options.next.tags\n\n```js\nfetch(`https://...`, { next: { tags: ['collection'] } })\n```\n\n`options.next.tags`는 요청에 캐시 태그(cache tags)를 설정하는 옵션이에요. 캐시 태그를 지정해두면, 나중에 `revalidateTag` API를 사용해서 해당 태그가 붙은 데이터만 선택적으로 갱신할 수 있답니다. 이렇게 하면 불필요하게 전체 데이터를 다시 받아오지 않아도 되니까 성능 최적화에 큰 도움이 되죠.\n\n- **태그 길이 제한**: 각 태그는 최대 256자까지만 작성할 수 있어요.\n- **태그 개수 제한**: 한 요청당 최대 128개의 태그를 설정할 수 있어요.\n\n---\n\n### 추가 팁!\n\n`revalidateTag`를 사용하면 페이지나 일부 컴포넌트에서 특정 태그를 기반으로 데이터를 갱신할 수 있어서 리얼타임 데이터 반영이나, 변경이 잦은 부분만 업데이트할 때 매우 유용해요.\n\n예를 들어, 쇼핑몰에서 ‘상품 컬렉션(collection)’ 태그를 붙인 데이터만 따로 갱신하고 싶을 때 편리하겠죠? 커스텀 태그를 잘 활용해서 앱 성능과 사용자 경험을 한층 개선해 보세요! \n\n---\n\n## 문제 해결 (Troubleshooting)\n\n| 문제 상황                        | 해결 방법                                 |\n|-------------------------------|----------------------------------------|\n| 태그가 너무 길 때               | 태그 길이를 256자 이내로 줄이세요.        |\n| 태그 개수가 128개를 초과할 때   | 필요 없는 태그를 제거하거나 그룹화하세요. |\n| 데이터가 갱신되지 않을 때       | `revalidateTag`가 올바르게 호출되었는지 확인하세요. |\n| 캐시가 정상 동작하지 않을 때   | fetch 옵션과 캐시 정책을 다시 점검해보세요.   |\n\n혹시 캐시 관련해서 더 궁금한 점이나, 특정 상황에서 어떻게 활용하면 좋은지 알고 싶다면 언제든 질문해 주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### Fetch 기본 자동 no-store와 캐시: `no-store`가 개발 환경에서 최신 데이터를 보여주지 않는 이유\n\nNext.js에서 개발할 때, 특히 **Server Components**를 사용할 때 조금 특이한 캐싱 동작이 있어요. 바로 HMR(Hot Module Replacement) 과정에서 fetch 응답을 캐시에 저장한다는 점입니다. 이 덕분에 빠른 응답 속도와 함께, API 호출 비용도 아낄 수 있죠.\n\n그런데 여기서 중요한 점! HMR 캐시는 기본적으로 모든 fetch 요청에 적용되는데, 심지어 `cache: 'no-store'` 옵션을 넣어도 마찬가지라는 거예요. 즉, 기본값인 `no-cache`나 `cache: 'no-store'`를 사용해도 HMR 중에는 캐시가 유지되어서 **최신 데이터가 바로바로 안 보일 수 있습니다**. \n\n하지만 실제로 페이지를 새로고침하거나 다른 경로로 이동할 때는 캐시가 깨져서 다시 최신 데이터를 가져오게 돼요.\n\n이게 개발할 때 가끔 데이터를 바로바로 바꿔서 테스트하는 과정에서 헷갈리게 할 수 있으니 주의해야 합니다.\n\n추가로 궁금하다면 [serverComponentsHmrCache 문서](https://nextjs.org/docs/advanced-features/react-18/server-components#hot-module-replacement-cache)도 확인해보세요!\n\n---\n\n### 참고로 알아두면 좋은 점\n\n- `cache: 'no-store'` 옵션은 **프로덕션 환경에선 실제로 캐시를 안 해서 무조건 최신 데이터를 가져오지만**,\n- 개발 모드에서만 HMR 캐시가 이를 덮어씌웁니다.\n- 이 때문에 개발 중에는 **fetch 요청이 예상과 다르게 동작할 수 있으니 주의**해야 해요.\n- 만약 진짜 최신 데이터를 계속 보고 싶다면, [페이지를 새로고침하거나 다른 경로로 이동하는 방법](https://nextjs.org/docs/basic-features/data-fetching#refreshing-data-on-client-navigation)을 쓰는 게 좋습니다.\n\n이런 Next.js 내부 동작 방식을 살펴보는 건 개발 생산성을 높이고, 예상치 못한 버그를 막는 데 큰 도움이 됩니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 버전 히스토리\n\n| 버전       | 변경 사항           |\n|------------|---------------------|\n| `v13.0.0`  | `fetch` 기능 추가됨 |\n\n여기서 `fetch`는 데이터를 서버에서 가져올 때 자주 사용하는 기능인데, 이 버전부터 공식적으로 도입됐다는 뜻이에요. 개발할 때 API 호출이 필요하면 이 기능을 활용해보세요. 예전에는 XMLHttpRequest나 다른 라이브러리를 많이 썼는데, `fetch`는 Promise 기반이라 비동기 처리가 훨씬 깔끔해져서 요즘은 표준처럼 쓰이고 있답니다.","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":10},{"title":"Next.js 15에서 쿠키 쉽게 다루는 방법","description":"","date":"2025-04-22 03:00","slug":"2025-04-22-cookies","content":"\n# Cookies (쿠키)\n\n`cookies`는 Server Components에서 들어오는 HTTP 요청의 쿠키를 읽고, Server Actions나 Route Handlers에서는 나가는 요청의 쿠키를 읽거나 쓸 수 있게 해주는 비동기 함수입니다.\n\n간단히 말해서, 서버 측에서 쿠키를 다루고 싶을 때 아주 유용한 도구에요. 예를 들어, 사용자가 설정한 테마값을 쿠키로 저장하고, 페이지를 렌더링할 때 이 값을 가져와서 다르게 보여주고 싶을 때 사용할 수 있죠.\n\n```js\nimport { cookies } from \"next/headers\";\n\nexport default async function Page() {\n  const cookieStore = await cookies(); // 쿠키 저장소를 비동기적으로 가져옵니다.\n  const theme = cookieStore.get(\"theme\"); // 'theme'이라는 이름의 쿠키를 읽어옵니다.\n  return \"...\";\n}\n```\n\n위 예제에서 `cookieStore`는 실제 쿠키 데이터를 다룰 수 있는 객체를 반환해줘요. `get` 메서드를 통해 특정 쿠키 값을 읽을 수 있죠.\n\n---\n\n## 추가 팁 - 쿠키 다루기\n\n- **읽기 \u0026 쓰기**: Server Actions나 Route Handlers에서는 `cookieStore.set('name', 'value', options)`를 사용해 쿠키를 설정할 수 있어요. 예를 들어, 사용자 로그인 후 세션 정보를 쿠키로 저장하는 경우처럼요.\n- **옵션 설정**: 쿠키 설정 시 `path`, `httpOnly`, `secure`, `maxAge` 등 다양한 옵션을 줄 수 있습니다. 이를 통해 보안이나 쿠키 유효 기간 등을 조절할 수 있죠.\n\n- **실제 활용 예시**:\n\n```js\nimport { cookies } from \"next/headers\";\n\nexport async function POST() {\n  const cookieStore = cookies();\n  cookieStore.set(\"token\", \"abc123\", { httpOnly: true, maxAge: 60 * 60 * 24 }); // 1일 동안 유효한 쿠키\n  return new Response(\"쿠키가 설정되었습니다.\");\n}\n```\n\n---\n\n`cookies` 함수는 Next.js 최신 버전에서 Server Components, Server Actions, Route Handlers 같은 서버 환경에서 쿠키를 안전하고 편리하게 다룰 수 있게 설계된 기능입니다. 클라이언트에서 document.cookie를 직접 만지는 것보다 훨씬 안전하고 깔끔하니, 서버에서 쿠키 작업이 필요할 때 적극 활용해 보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 메서드 소개\n\n아래는 사용할 수 있는 메서드들입니다:\n\n| 메서드                      | 반환 타입 | 설명                                                             |\n| --------------------------- | --------- | ---------------------------------------------------------------- |\n| `get('name')`               | Object    | 쿠키 이름을 받아서 그 이름과 값이 담긴 객체를 반환해요.          |\n| `getAll()`                  | 객체 배열 | 이름이 일치하는 모든 쿠키를 배열로 반환해줍니다.                 |\n| `has('name')`               | Boolean   | 쿠키 이름을 받아서 해당 쿠키가 존재하는지 true/false로 알려줘요. |\n| `set(name, value, options)` | -         | 쿠키 이름, 값, 옵션을 받아서 요청하는 쿠키를 설정합니다.         |\n| `delete(name)`              | -         | 쿠키 이름을 받아서 해당 쿠키를 삭제해줘요.                       |\n| `clear()`                   | -         | 모든 쿠키를 한 번에 삭제합니다.                                  |\n| `toString()`                | String    | 현재 쿠키들을 문자열 포맷으로 반환해줘요.                        |\n\n---\n\n직접 개발하다 보면 쿠키를 다루는 일이 꽤 잦을텐데, 이런 메서드들이 있으면 정말 편리하겠죠? 예를 들어, `has('name')` 메서드로 쿠키가 있는지 딱 체크해서 조건문을 쓰기도 쉽고, `getAll()` 메서드로 같은 이름을 가진 여러 쿠키를 모두 가져올 수도 있으니까 상황에 맞게 유용하게 쓸 수 있답니다.\n\n쿠키를 설정할 때는 `set()` 메서드에 옵션을 함께 넘겨주면, 유효 기간, 경로, 도메인 같은 세부 설정도 가능해서 제어가 한층 더 세밀해져요.\n\n이렇게 메서드들을 잘 활용하면 쿠키 관리를 훨씬 깔끔하게 할 수 있으니 참고하세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n쿠키(cookie)를 설정할 때 옵션 객체에서 사용할 수 있는 속성들은 아래와 같아요:\n\n| 옵션              | 타입                                   | 설명                                                                                    |\n| ----------------- | -------------------------------------- | --------------------------------------------------------------------------------------- |\n| `name`            | String                                 | 쿠키의 이름을 지정합니다.                                                               |\n| `value`           | String                                 | 쿠키에 저장할 값을 지정합니다.                                                          |\n| `expires`         | Date                                   | 쿠키 만료일을 정확하게 설정합니다.                                                      |\n| `maxAge`          | Number                                 | 쿠키의 수명(초 단위)을 설정합니다.                                                      |\n| `domain`          | String                                 | 쿠키가 유효한 도메인을 지정합니다.                                                      |\n| `path`            | String, 기본값: `'/'`                  | 쿠키의 유효 경로를 지정해 특정 경로 내에서만 쿠키가 사용되도록 제한할 수 있습니다.      |\n| `secure`          | Boolean                                | HTTPS 연결에서만 쿠키가 전송되도록 하여 보안을 강화합니다.                              |\n| `httpOnly`        | Boolean                                | 클라이언트 자바스크립트에서 쿠키 접근을 차단해 HTTP 요청에만 쿠키 사용을 제한합니다.    |\n| `sameSite`        | Boolean, `'lax'`, `'strict'`, `'none'` | 크로스 사이트 요청에 대한 쿠키 동작 방식을 제어합니다.                                  |\n| `priority`        | String (`\"low\"`, `\"medium\"`, `\"high\"`) | 쿠키의 우선순위를 지정합니다.                                                           |\n| `encode('value')` | Function                               | 쿠키 값을 인코딩하는 데 사용할 함수를 지정할 수 있습니다.                               |\n| `partitioned`     | Boolean                                | 쿠키가 [Partitioned Cookies](https://github.com/privacycg/CHIPS)인지 여부를 나타냅니다. |\n\n\u003e 여기서 `path` 옵션은 기본값이 `'/'`로 설정되어 있으니, 특정 경로에서만 쿠키가 유효하게 하려면 다른 값을 명시해줘야 해요.\n\n---\n\n### 좀 더 알려드릴 게 있어요!\n\n- **`secure` 옵션을 꼭 써야 하는 이유**  \n  쿠키가 HTTPS를 통해서만 전송될 수 있게 하는 `secure` 옵션은 민감한 정보 전송 시 보안을 크게 높여줍니다. 꼭 HTTPS 환경에서만 쿠키를 사용해야 할 경우 꼭 활성화해 주세요.\n\n- **`httpOnly`가 왜 중요한가?**  \n  `httpOnly` 속성을 활성화하면, 클라이언트 측 자바스크립트가 쿠키에 접근하지 못해서 XSS 공격에 의한 쿠키 탈취 위험을 줄일 수 있어요.\n\n- **`sameSite` 옵션으로 CSRF 방어하기**  \n  요즘은 크로스 사이트 요청 위조(CSRF) 공격 문제가 많기 때문에, `sameSite` 옵션을 `'lax'` 또는 `'strict'`로 설정하는 것이 보안에 도움이 됩니다.\n\n- **Partitioned Cookies**  \n  아직 상대적으로 최신 기술인 partitioned cookies는 브라우저별로 쿠키 저장소를 분리해서 사용자 간 추적을 어렵게 만드는 방향으로 연구되고 있습니다. 관심 있다면 GitHub 링크를 참고해 보세요!\n\n---\n\n쿠키 설정에 대해 더 자세한 내용은 [MDN 웹 문서](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies)에서 확인하실 수 있어요. 여기에 다양한 사례와 권장하는 보안 설정 방법도 소개되어 있으니 참고하면 큰 도움이 됩니다!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 알아두면 좋은 팁들\n\n- `cookies` 함수는 비동기 함수이며, Promise를 반환해요. 그래서 `async/await`를 사용하거나 React의 `use` 함수를 활용해서 값을 받아와야 합니다.  \n  참고로 Next.js 14 버전 이전까지는 동기 함수였는데, Next.js 15 버전에서도 이전 버전 호환을 위해 동기 방식으로 사용하는 게 가능하지만, 앞으로 이 방식은 사라질 예정입니다.\n\n- `cookies` 함수는 동적 API에 속해 있어요. 반환값을 미리 알 수 없기 때문에, 레이아웃(layout)이나 페이지에서 사용하게 되면 해당 라우트(route)가 동적 렌더링(dynamic rendering)으로 변환됩니다.\n\n- `.delete` 메서드는 아래 조건에서만 사용할 수 있습니다:\n\n  1. 서버 액션(Server Action)이나 라우트 핸들러(Route Handler) 안에서 호출해야 합니다.\n  2. `.set`을 호출한 같은 도메인이어야 합니다. 만약 와일드카드 도메인(wildcard domain)을 사용한다면, 세부 서브도메인이 정확히 일치해야 하며, 같은 프로토콜(HTTP 또는 HTTPS)에서 실행되어야 합니다.\n\n- HTTP 프로토콜 특성상 스트리밍(streaming) 시작 이후에는 쿠키 설정이 불가능하므로, 쿠키를 설정할 때는 서버 액션이나 라우트 핸들러 내에서 `.set` 메서드를 호출해야 해요.\n\n---\n\n## 서버 컴포넌트에서 쿠키 동작 이해하기\n\n서버 컴포넌트(Server Components)에서 쿠키를 다룰 때 기억해야 할 점은, 쿠키가 기본적으로 **클라이언트 쪽 저장소**라는 사실입니다. 즉, 쿠키는 브라우저에 저장되어서 HTTP 요청과 함께 서버에 전달되는 데이터인데, 서버 컴포넌트는 서버에서 렌더링되기 때문에 쿠키 정보를 정확히 반영하기 위해선 쿠키를 비동기적으로 불러와야 해요.\n\n### 여기서 조금 더!\n\n서버 컴포넌트에서는 쿠키 데이터에 접근할 때마다 클라이언트(브라우저)에서 전송된 쿠키를 읽는 느낌이라고 생각하면 편합니다. 그래서 쿠키가 바뀌면 서버 컴포넌트도 동적으로 다시 렌더링할 수밖에 없어요. 이 과정이 바로 Next.js가 동적 API로 취급하는 이유죠.\n\n또한, 서버 컴포넌트 내에서 `cookies().get()` 같은 API를 편리하게 호출할 수 있게 됐지만, 이 과정이 비동기적 처리임을 잊지 마세요. 그래서 `async` 함수 안에서 쿠키를 다뤄야 하며, 그렇게 해서 받아온 값으로 컴포넌트를 렌더링해야 합니다.\n\n---\n\n이런 점들을 잘 이해하고 사용하면, Next.js에서 쿠키 기반 인증이나 세션 관리 같은 기능을 더 안정적이고 자연스럽게 구현할 수 있습니다! 궁금한 점 있으면 언제든 물어보세요! 😊\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 서버 컴포넌트(Server Components)에서 쿠키를 읽을 수 있는 이유는 클라이언트(브라우저)가 HTTP 요청 헤더에 쿠키 데이터를 함께 보내기 때문이에요. 즉, 서버 쪽에서 요청이 올 때 쿠키 정보를 받을 수 있는 거죠.\n- 하지만 서버 컴포넌트에서 쿠키를 직접 설정(set)하는 건 불가능해요. 심지어 라우트 핸들러(Route Handler)나 서버 액션(Server Action)을 써도 마찬가지예요. 왜냐하면 쿠키는 실제로 서버가 아니라 클라이언트, 즉 브라우저가 저장하기 때문입니다.\n\n서버는 클라이언트(브라우저)에게 `Set-Cookie`라는 응답 헤더를 통해 \"이 쿠키를 저장해 달라\"는 명령만 보낼 수 있어요. 쿠키 저장 자체는 브라우저가 처리하죠. 그래서 쿠키 상태를 변경하는 작업(예: `.set`, `.delete`, `.clear`)은 반드시 라우트 핸들러나 서버 액션 내에서 해야 해요. 그래야 응답 헤더를 통해 적절한 쿠키 저장 명령을 포함시킬 수 있기 때문입니다.\n\n---\n\n## 예제들\n\n### 쿠키 가져오기 (Getting a cookie)\n\n```tsx\nimport { cookies } from \"next/headers\";\n\nexport default function ServerComponent() {\n  const cookieStore = cookies();\n  const token = cookieStore.get(\"token\")?.value;\n\n  return \u003cdiv\u003e{token ? `토큰 값: ${token}` : \"토큰이 없습니다.\"}\u003c/div\u003e;\n}\n```\n\n위 예시는 서버 컴포넌트에서 쿠키를 읽는 간단한 방법을 보여줘요. 요청 헤더에서 쿠키 데이터를 받아서 `token`이라는 이름의 쿠키가 있으면 값을 보여주고, 없으면 '토큰이 없습니다'라는 메시지를 띄우는 식이죠.\n\n---\n\n### 쿠키 설정하기 (Setting a cookie) - 라우트 핸들러 예시\n\n```tsx\nimport { NextResponse } from \"next/server\";\n\nexport async function POST() {\n  const response = NextResponse.json({ message: \"쿠키가 설정되었습니다!\" });\n  response.cookies.set(\"token\", \"abc123\", { httpOnly: true, maxAge: 60 * 60 * 24 });\n\n  return response;\n}\n```\n\n쿠키를 설정하고 싶을 땐 서버 컴포넌트가 아니라 이런 라우트 핸들러에서 응답 헤더에 `Set-Cookie`를 포함시켜서 브라우저에게 전달해야 해요. `httpOnly` 옵션을 쓰면 자바스크립트에서 쿠키가 조작되는걸 막아 보안성을 높일 수도 있어요.\n\n---\n\n### 팁: 쿠키 사용 시 주의사항\n\n- 쿠키는 용량 제한(보통 4KB)이 있어 너무 많은 데이터를 넣으면 안 돼요.\n- 인증용 토큰 같은 민감한 정보는 `httpOnly`와 `secure` 옵션을 설정해 보안을 강화하세요.\n- 클라이언트에서 `document.cookie`로 접근 가능한 쿠키와 서버에서 읽는 쿠키가 다를 수 있으니 목적에 맞는 쿠키 설정이 필요합니다.\n\n---\n\n쿠키는 웹에서 사용자 상태와 인증 정보를 관리하는 데 정말 중요해요. 서버와 클라이언트가 함께 작동해야 하니까 이 점 꼭 기억하면서 코딩해 보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 쿠키를 다룰 때 `await cookies()` 메서드를 사용하면 편리하게 쿠키 값을 가져올 수 있어요.\n\n예를 들어, 특정 이름을 가진 쿠키 하나만 가져오고 싶다면 아래처럼 하면 됩니다:\n\n```js\nimport { cookies } from \"next/headers\";\n\nexport default async function Page() {\n  const cookieStore = await cookies();\n  const theme = cookieStore.get(\"theme\"); // 'theme'이라는 이름의 쿠키 가져오기\n  return \"...\";\n}\n```\n\n`cookieStore.get('name')`은 해당 이름을 가진 첫 번째 쿠키를 반환하고, 만약 쿠키가 없으면 `undefined`를 돌려주니 존재 여부를 꼭 체크해주는 게 좋아요.\n\n---\n\n### 여러 개 혹은 모든 쿠키 가져오기\n\n만약 특정 이름에 해당하는 쿠키가 여러 개 있거나, 아예 전부 다 가져오고 싶다면 `getAll()` 메서드를 사용하면 됩니다. 아래처럼 쓰면 되죠:\n\n```js\nconst allThemeCookies = cookieStore.getAll(\"theme\"); // 'theme'이라는 이름의 모든 쿠키 가져오기\nconst allCookies = cookieStore.getAll(); // 이름 지정 없이 모든 쿠키 가져오기\n```\n\n`getAll()`은 배열을 반환해주기 때문에, 여러 개의 같은 이름 쿠키를 한 번에 다루거나 쿠키를 일괄 처리할 때 유용해요.\n\n---\n\n### 참고 팁!\n\n- 서버 컴포넌트에서만 `next/headers` 모듈의 `cookies()`를 쓸 수 있습니다.\n- 클라이언트 사이드에서 쿠키를 읽으려면 일반적인 JavaScript `document.cookie`를 써야 한다는 점도 기억하세요.\n- 보안상 쿠키를 다룰 땐 HttpOnly, Secure 옵션들도 잘 설정하는 습관이 필요합니다.\n\n필요한 쿠키를 깔끔하게 가져와서 편리한 상태 관리나 유저 테마 설정 등에 활용해 보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자, Next.js 13에서 Cookies API를 사용하는 방법에 대해 이야기해볼게요. Server Component나 서버 관련 코드에서 쿠키를 쉽게 조회하고, 설정할 수 있는 예제인데요.\n\n먼저, 쿠키를 읽어오는 코드입니다:\n\n```jsx\nimport { cookies } from \"next/headers\";\n\nexport default async function Page() {\n  // 쿠키 스토어를 불러오고\n  const cookieStore = await cookies();\n\n  // 모든 쿠키를 가져와서 JSX로 렌더링합니다\n  return cookieStore.getAll().map((cookie) =\u003e (\n    \u003cdiv key={cookie.name}\u003e\n      \u003cp\u003eName: {cookie.name}\u003c/p\u003e\n      \u003cp\u003eValue: {cookie.value}\u003c/p\u003e\n    \u003c/div\u003e\n  ));\n}\n```\n\n여기서 `cookies()` 함수는 서버에서 현재 요청에 포함된 쿠키들을 읽어오는 API예요. `getAll()`을 호출하면 모든 쿠키가 배열로 반환되고, 각 쿠키는 이름과 값뿐만 아니라 추가 옵션들도 포함할 수 있어요. 이걸 React 컴포넌트에서 렌더링하는 거죠.\n\n---\n\n### 쿠키 설정하기\n\n이제 쿠키를 새로 설정하는 방법입니다. Next.js에서는 서버 액션이나 Route Handler 내부에서 `cookies().set()` 메서드를 사용해서 쿠키를 만들 수 있어요.\n\n```js\n\"use server\";\n\nimport { cookies } from \"next/headers\";\n\nexport async function create(data) {\n  const cookieStore = await cookies();\n\n  // 기본적으로 name이라는 이름과 'lee'라는 값으로 쿠키 설정\n  cookieStore.set(\"name\", \"lee\");\n\n  // secure 옵션(HTTPS에서만 전송)\n  cookieStore.set(\"name\", \"lee\", { secure: true });\n\n  // 좀 더 상세 옵션 지정 가능 (httpOnly, path 등)\n  cookieStore.set({\n    name: \"name\",\n    value: \"lee\",\n    httpOnly: true,\n    path: \"/\",\n  });\n}\n```\n\n여기서 `httpOnly` 옵션은 클라이언트 JavaScript에서 쿠키에 접근하는 걸 막아서 보안에 도움이 되고, `secure` 옵션은 HTTPS 연결에서만 쿠키가 전송되도록 하는 거예요. 또, `path` 옵션을 지정하면 쿠키가 특정 경로에서만 유효하도록 할 수 있답니다.\n\n---\n\n### 알아두면 좋은 팁\n\n- 이 API는 서버 측에서만 동작하기 때문에, 클라이언트 측에서 쿠키를 다루려면 `document.cookie`를 사용해야 해요.\n- 쿠키는 보통 사용자 인증, 세션 관리, UI 상태 유지 등에 쓰이는데, 민감한 정보는 꼭 `httpOnly`나 `secure` 옵션을 함께 설정해서 노출되거나 탈취되지 않도록 주의하세요.\n- Next.js 13부터 도입된 이 `cookies` API는 사용하기 훨씬 편리해졌는데, 기존의 `set-cookie` 헤더 직접 조작보다 안정적이고 직관적이랍니다.\n\n---\n\n쿠키 다루기가 어려울 수 있는데, 이렇게 서버 컴포넌트 안에서 직관적으로 쓰니까 훨씬 편리해졌죠? 필요에 따라 쿠키를 갖고 놀아보세요! 혹시 더 궁금한 거 있으면 알려주세요.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 쿠키가 존재하는지 확인하기\n\nNext.js에서 쿠키가 있는지 확인하고 싶을 때는 `await cookies()` 메서드와 `has(name)` 메서드를 조합해서 사용하면 됩니다.\n\n```js\nimport { cookies } from \"next/headers\";\n\nexport default async function Page() {\n  const cookieStore = await cookies();\n  const hasCookie = cookieStore.has(\"theme\"); // 'theme' 쿠키가 있는지 확인\n  return hasCookie ? \"쿠키가 존재해요!\" : \"쿠키가 없어요!\";\n}\n```\n\n위 코드처럼 간단하게 특정 이름의 쿠키가 있는지 true/false로 확인할 수 있어요. 서버 컴포넌트에서 쿠키를 읽거나 분기 처리를 해야 할 때 유용하죠.\n\n---\n\n### 쿠키 삭제하기\n\n쿠키를 삭제하려면 기본적으로는 만료일자를 과거로 설정해줘야 해요. 서버 측에서 쿠키를 삭제하는 방법을 살펴볼게요.\n\n```js\nimport { cookies } from \"next/headers\";\n\nexport async function DELETE() {\n  const cookieStore = cookies();\n  cookieStore.delete(\"theme\", { path: \"/\" }); // 'theme' 쿠키 삭제\n  return new Response(\"쿠키 삭제됨\", { status: 200 });\n}\n```\n\n- `cookieStore.delete()` 메서드로 삭제할 쿠키 이름과 경로를 지정해주면 됩니다.\n- 쿠키가 특정 경로나 도메인에 묶여 있다면, 삭제할 때도 그 경로나 도메인을 맞춰줘야 완전히 삭제가 돼요.\n- 만약 클라이언트 쪽에서 쿠키를 삭제하고 싶다면, 자바스크립트의 `document.cookie = \"name=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;\"` 같은 방법을 쓰면 됩니다.\n\n---\n\n### 조금 더 알아두면 좋은 점\n\n- Next.js의 `cookies()`는 서버 컴포넌트나 API 라우트 등 서버 측에서만 사용할 수 있어요.\n- 쿠키는 보안상 중요한 정보를 담기보다는 세션식별자나 사용자 선호 설정 정도로 사용하는 게 좋아요.\n- `Secure`, `HttpOnly`, `SameSite` 같은 옵션도 꼭 설정해서 보안을 강화하는 습관을 들이면 좋답니다!\n\n다음에 쿠키 관련해서 직접 실습하면서 또 도움이 될 만한 팁을 공유할게요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n쿠키를 삭제하는 방법에는 크게 세 가지가 있어요. 여기서는 그 중 두 가지를 소개해드릴게요.\n\n### 1. `delete()` 메서드 사용하기\n\nNext.js에서 제공하는 `cookies` 객체에 있는 `delete()` 메서드를 사용해서 간단하게 쿠키를 지울 수 있어요.\n\n```js\n\"use server\";\n\nimport { cookies } from \"next/headers\";\n\nexport async function deleteCookie() {\n  (await cookies()).delete(\"name\"); // 'name'이라는 이름의 쿠키를 삭제해요.\n}\n```\n\n- `await cookies()`를 호출해서 현재 쿠키 객체를 받아오고, 그 안에서 `delete('name')`을 호출해서 특정 쿠키를 삭제합니다.\n- 서버 컴포넌트 또는 서버 함수 안에서만 쓸 수 있다는 점 참고하세요.\n\n### 2. 같은 이름으로 빈 값 설정하기\n\n사실, 쿠키를 삭제하는 또 다른 방법은 같은 이름으로 빈 값을 설정하고 만료 시간을 과거로 설정하는 거예요. 이렇게 하면 브라우저가 해당 쿠키를 지우게 됩니다.\n\n```js\nimport { cookies } from \"next/headers\";\n\nexport async function deleteCookieBySetting() {\n  (await cookies()).set({\n    name: \"name\",\n    value: \"\", // 빈 값으로 설정\n    expires: new Date(0), // 만료 시간을 과거로 설정해서 즉시 만료\n    path: \"/\",\n  });\n}\n```\n\n- `set()` 메서드를 이용해 만료 시점을 과거로 지정하면 쿠키가 삭제된 것과 같은 효과를 냅니다.\n- 직접 쿠키 값을 칼같이 삭제하지 않아도 되니, 간단한 상황에 유용하죠.\n\n---\n\n### 참고: 쿠키 삭제 시 주의할 점\n\n- 쿠키는 도메인, 경로(path), 보안 설정(secure, httpOnly)에 따라 영향을 받습니다.\n- 쿠키를 삭제할 때도 같은 도메인과 경로를 명시해줘야 확실히 삭제할 수 있어요.\n- 만약 삭제가 제대로 안 된다면, 해당 쿠키의 `path`나 `domain` 설정을 다시 한 번 확인해 보세요.\n\n---\n\n쿠키를 다룰 때는 이렇게 여러 방법이 있으니, 상황에 맞게 골라 쓰시면 됩니다. 서버에서 직접 쿠키를 관리하는 경우라면 `delete()`를, 클라이언트 쪽에서는 빈 값과 만료 시간을 조정하는 방법이 인기가 많아요.\n\n필요하면 다음에 세 번째 방법도 알려드릴게요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n`Next.js`의 서버 컴포넌트에서 쿠키를 삭제하는 방법에 대해 알아볼게요. 보통 쿠키를 \"삭제\"하려면, 해당 쿠키의 만료 시간을 즉시 만료시키거나, 빈 값으로 덮어쓰는 두 가지 방법을 사용해요.\n\n---\n\n### 1. 쿠키를 빈 값으로 덮어쓰기\n\n아래 코드는 `cookies().set()` 메서드를 사용해서 쿠키 이름을 빈 문자열로 설정하는 예시입니다.\n이렇게 하면 쿠키 값이 빈 문자열로 바뀌지만, 실제로 쿠키는 브라우저에 그대로 남아 있을 수 있어요.\n\n```js\n'use server'\n\nimport { cookies } from 'next/headers'\n\nexport async function delete(data) {\n  (await cookies()).set('name', '')\n}\n```\n\n---\n\n### 2. maxAge를 0으로 설정해 바로 만료시키기\n\n쿠키를 완전히 삭제하려면 `maxAge` 옵션을 0으로 설정해서 쿠키 만료 시간을 즉시 지난 값으로 설정하는 방법이 더 확실해요.\n\n```js\n'use server'\n\nimport { cookies } from 'next/headers'\n\nexport async function delete(data) {\n  (await cookies()).set('name', 'value', { maxAge: 0 })\n}\n```\n\n`maxAge`는 초 단위로 시간을 받기 때문에 `0`을 주면 곧바로 만료 처리되는 거죠.\n\n---\n\n## 흔히 묻는 질문\n\n| 질문                                    | 답변                                                                                          |\n| --------------------------------------- | --------------------------------------------------------------------------------------------- |\n| `maxAge` 대신 `expires`를 써도 되나요?  | 네, 가능합니다. `expires`는 날짜 객체를 받아서 쿠키 만료 시간을 설정하는 방법이에요.          |\n| 빈 문자열로 설정하면 쿠키가 삭제되나요? | 사실상 값만 비워질 뿐 구버전 브라우저나 일부 환경에서는 쿠키가 살아 있을 수 있어요.           |\n| `maxAge: 0` 와 `maxAge: -1` 차이는?     | 둘 다 쿠키를 즉시 만료시키지만, 보통 `0`을 사용해요. 음수는 브라우저에 따라 달라질 수 있어요. |\n\n---\n\n### 마무리\n\n`Next.js` 13 서버 컴포넌트 기능에서 새로 제공하는 `cookies` API는 훨씬 간편하게 쿠키를 다룰 수 있도록 도와주지만, 조금만 주의하면 쿠키 삭제도 깔끔하게 할 수 있어요!\n\n쿠키를 삭제할 땐 꼭 제대로 만료 시간을 설정해서, 원하지 않는 쿠키가 백그라운드에 남지 않도록 관리해주세요. 쿠키 조작에 대해 더 궁금한 점 있으면 언제든 물어봐주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 `cookies` 관련 변경 사항을 정리한 표예요.\n\n| Version      | Changes                                                                                                                                                     |\n| ------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `v15.0.0-RC` | `cookies`가 이제 비동기(async) 함수로 변경되었어요. 업그레이드할 때 도움이 되는 \u003ca href=\"/docs/app/guides/upgrading/codemods#150\"\u003ecodemod\u003c/a\u003e도 제공됩니다. |\n| `v13.0.0`    | `cookies` 기능이 처음 도입되었어요.                                                                                                                         |\n\n참고로, `cookies`가 비동기 함수가 된 이유는 서버에서 쿠키를 처리할 때 비동기 작업이 필요한 경우가 많기 때문이에요. 예를 들어, 데이터베이스 조회나 외부 API 호출을 하면서 쿠키 값을 확인하거나 수정할 때 자연스럽게 비동기로 처리하는 게 더 효율적이죠.\n\n이런 변경사항을 반영하지 않으면 기존에 동기 함수처럼 호출하던 코드에서 문제가 발생할 수 있으니, 꼭 공식 codemod를 활용해서 코드를 자동 변환해 보는 걸 추천드려요!\n","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":20},{"title":"Next.js 15에서 cacheTag 사용해서 효율적으로 캐시 관리하는 방법","description":"","date":"2025-04-22 02:59","slug":"2025-04-22-cacheTag","content":"\n# cacheTag\n\ncacheTag 함수는 캐시된 데이터를 태그로 관리해서 필요한 순간에만 캐시를 지우거나 갱신할 수 있게 도와줘요. 태그를 캐시 항목에 붙여두면, 전체 캐시를 지우는 대신 특정 태그가 붙은 데이터만 골라서 재검증하거나 삭제할 수 있답니다. 이 기능 덕분에 캐시 관리가 훨씬 스마트해지고 효율적이죠!\n\n## 사용 방법\n\ncacheTag를 사용하려면, 먼저 프로젝트의 `next.config.js` 파일에서 `dynamicIO` 플래그를 활성화해야 해요. 이렇게요:\n\n```js\n// next.config.js\nmodule.exports = {\n  experimental: {\n    dynamicIO: true,\n  },\n};\n```\n\n\u003e `dynamicIO` 옵션은 아직 실험적인 기능이라, 안정성이 필요한 프로젝트에서는 신중하게 적용하는 게 좋아요.\n\n이 설정을 한 다음, 원하는 캐시 데이터에 태그를 달아서 관리할 수 있습니다.\n\n---\n\n### 참고로 더!\n\n- 태그 관리 덕분에 특정 부분만 업데이트해야 할 때, 서버 성능과 사용자 경험이 크게 개선됩니다.\n- 이 기능은 특히 데이터가 자주 바뀌면서도 전체를 다시 로드하는 건 비효율적인 서비스(예: 뉴스 피드, 실시간 데이터 보여주는 앱 등)에 유용해요.\n- `cacheTag`를 사용하면서 동시에 어떻게 캐시 무효화 전략을 세울지 고민해보면 프로젝트의 퍼포먼스 최적화에 큰 도움이 됩니다.\n\n필요하면 다음에 캐시 사용 예제에 대해서도 알려줄게요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 새롭게 제공하는 캐시 태그(cacheTag) 기능을 재미있게 활용해볼까요? 이번에 소개할 코드는 캐시를 더 세밀하게 관리할 수 있게 도와주는 설정과 함수예요.\n\n### 1. next.config.js 설정\n\n먼저 `next.config.js` 파일에서 실험적 기능인 `dynamicIO`를 활성화해야 해요. 이 옵션을 켜면 Next.js가 새로운 캐시 태그 기능을 사용할 수 있도록 준비된답니다.\n\n```js\nimport type { NextConfig } from \"next\";\n\nconst nextConfig: NextConfig = {\n  experimental: {\n    dynamicIO: true,\n  },\n};\n\nexport default nextConfig;\n```\n\n여기서 `dynamicIO`는 아직 완전히 안정화된 기능은 아니지만, 캐시 제어나 데이터 페칭에 좀 더 유연한 방식으로 접근할 수 있게 해줘요.\n\n---\n\n### 2. 캐시 태그 지정하기 - `cacheTag`\n\n이제 함수 안에서 `cacheTag` 함수를 써보죠! 이 함수는 하나의 문자열 태그, 혹은 문자열 배열로 캐시 태그를 지정할 수 있어요.\n\n```js\nimport { unstable_cacheTag as cacheTag } from \"next/cache\";\n\nexport async function getData() {\n  \"use cache\";\n  cacheTag(\"my-data\");\n  const data = await fetch(\"/api/data\");\n  return data;\n}\n```\n\n- 먼저 함수 최상단 `'use cache'` 디렉티브를 호출해 캐시 기능을 활성화해줍니다.\n- `cacheTag('my-data')`로 해당 함수가 사용하는 캐시 태그를 지정하죠.\n- 이렇게 하면 `my-data`라는 태그를 기준으로 캐싱되고, 이 태그만 선택적으로 무효화할 수 있습니다.\n\n이게 뭐가 좋느냐면, 데이터를 전체 페이지가 아니라 세부 단위별로 새로고침할 수 있다는 점이에요. 예를 들어, 특정 API 데이터를 업데이트해야 할 때 전체 페이지를 빌드할 필요 없이 해당 데이터만 캐시를 지우고 재생성할 수 있게 되는 거죠.\n\n---\n\n### 3. 캐시 무효화 (Cache Purge) - `revalidateTag`\n\n캐시가 오래되었거나, 데이터를 리프레시하려면 태그 단위로 캐시를 무효화하는 게 중요한데요. Next.js는 `revalidateTag` API로 이걸 쉽게 지원합니다.\n\n```js\nimport { revalidateTag } from \"next/cache\";\n\nexport async function POST() {\n  // 예: API 라우트에서 데이터가 변경될 때 해당 캐시 태그를 무효화\n  await doDataUpdate();\n  revalidateTag(\"my-data\");\n  return new Response('Cache cleared for \"my-data\" tag');\n}\n```\n\n- 위 예시처럼, 서버측 함수에서 데이터 수정 후 `revalidateTag('my-data')`를 호출하면 `'my-data'` 관련된 캐시가 모두 무효화됩니다.\n- 그러면 다음 요청 시점에 다시 최신 데이터를 받아서 캐쉬를 갱신하게 되죠.\n\n---\n\n## 요약\n\n| 기능                     | 설명                                                       |\n| ------------------------ | ---------------------------------------------------------- |\n| `experimental.dynamicIO` | Next.js에서 캐시 태그 사용을 위한 실험적 설정              |\n| `cacheTag`               | 함수 내에서 캐시 태그를 지정, 데이터 단위별 캐시 제어 가능 |\n| `revalidateTag`          | 특정 태그에 해당하는 캐시를 서버에서 강제로 무효화         |\n\n---\n\n## 한마디\n\n이번에 소개한 캐시 태그 기능은 특히 데이터가 자주 업데이트되는 상황에서 유용해요. API 응답이나 UI 컴포넌트의 일부를 효과적으로 갱신할 수 있으니, 무조건 페이지 전체를 다시 빌드하는 구조에서 벗어나고 싶다면 한 번 꼭 시도해보세요. 실험적이라 공식 문서와 버전이 바뀌는지는 꾸준히 체크하는 것도 잊지 마시고요!\n\n더 궁금한 점 있으면 언제든 댓글로 남겨주세요. 같이 공부해봐요! 😊\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위 코드는 Next.js의 서버 컴포넌트에서 캐시를 제어할 때 사용하는 예제입니다. 여기서 핵심은 revalidateTag라는 함수로 특정 캐시 태그를 재검증(revalidate)해서, 데이터가 바뀌었을 때 최신 상태로 유지하게 만드는 거예요.\n\n```js\n\"use server\";\n\nimport { revalidateTag } from \"next/cache\";\n\nexport default async function submit() {\n  await addPost(); // 새로운 포스트를 추가하는 비동기 함수\n  revalidateTag(\"my-data\"); // 'my-data'라는 태그가 붙은 캐시를 재검증해서 최신으로 업데이트\n}\n```\n\n위 코드에서 addPost()가 끝나면, 'my-data'라는 태그를 가진 캐시는 재검증돼서 이전 데이터가 아닌 새 데이터를 가져오도록 만드는 역할이에요.\n\n---\n\n## 알아두면 좋은 팁\n\n| 내용            | 설명                                                                               |\n| --------------- | ---------------------------------------------------------------------------------- |\n| Idempotent Tags | 동일한 태그를 여러 번 적용해도 추가적인 효과가 없어요. 중복 적용해도 무방해요.     |\n| Multiple Tags   | 한 캐시 엔트리에 여러 태그를 붙일 수 있어요. 배열 형태로 태그들을 넘겨주면 됩니다. |\n\n예를 들어 이렇게 사용해요:\n\n```js\ncacheTag(\"tag-one\", \"tag-two\");\n```\n\n위와 같이 여러 태그를 한 번에 붙이면, 이 캐시 항목이 두 가지 태그에 묶여서 둘 중 하나라도 변경될 경우 재검증됩니다.\n\n---\n\n### 개인적으로 추가로 알려드릴 점!\n\n캐시 태그를 이렇게 사용하면 무조건 캐시 무효화(invalidation)를 하느니, 필요한 부분만 선별적으로 업데이트하는 '스마트 캐싱' 전략을 세우기 좋아요. 데이터가 자주 변하는 서비스에서는 서버 성능과 유저 경험을 둘 다 잡기 위해 꼭 익혀야 하는 기능입니다.\n\nNext.js 13+ 버전에서 제공하는 이 기능을 잘 활용하면, SSR(Server Side Rendering) 혹은 ISR(Incremental Static Regeneration) 환경에서도 원하는 타이밍에 효율적으로 데이터를 업데이트할 수 있어요. 번거로운 캐시 조작을 줄이고, 최신 데이터도 놓치지 않게 해주는 아주 쓸모 있는 기능이죠!\n\n필요하시면 addPost() 같은 함수 내부 구현도 같이 다뤄볼테니, 언제든 질문 주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 예제\n\n### 컴포넌트나 함수에 태그 달기\n\n캐시된 함수나 컴포넌트 안에서 `cacheTag`를 호출해서 캐시 데이터를 태그할 수 있어요. 이렇게 하면 캐시 관리가 좀 더 편리해지고, 특정 태그를 기준으로 캐시를 재검증하거나 삭제할 수 있답니다.\n\n```js\nimport { unstable_cacheTag as cacheTag } from \"next/cache\";\n\ninterface BookingsProps {\n  type: string;\n}\n\nexport async function Bookings({ type = \"haircut\" }: BookingsProps) {\n  \"use cache\";\n  cacheTag(\"bookings-data\");\n\n  async function getBookingsData() {\n    const data = await fetch(`/api/bookings?type=${encodeURIComponent(type)}`);\n    return data;\n  }\n\n  return; //...\n}\n```\n\n---\n\n여기서 중요한 포인트는 `'use cache'`라는 디렉티브를 함수 최상단에 써서 이 함수가 캐싱 기능을 사용할 거라고 알려준다는 점이에요. 그리고 `cacheTag('bookings-data')`를 호출해서 이 함수가 반환하는 데이터에 `bookings-data`라는 태그를 붙이는 거죠.\n\n이렇게 태그를 달아두면, 나중에 `bookings-data` 태그가 붙은 캐시들을 한꺼번에 무효화하거나 업데이트할 때 훨씬 편리해져요.\n\n또한 참고할 점은, 이 기능이 아직 불안정(`unstable`)한 API이므로, 앞으로 변경될 가능성이 있다는 점이에요. 그래도 Next.js 같은 최신 프레임워크에서 제공하는 기능을 미리 써보면서 경험해보는 것도 좋겠죠?\n\n추가로, 만약 다양한 타입의 예약 데이터를 관리해야 한다면 태그 이름을 `bookings-data:${type}` 같은 식으로 동적으로 생성하는 것도 좋은 방법이에요. 이렇게 하면 특정 타입만 골라서 캐시를 제어할 수 있거든요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 외부 데이터로부터 태그 만들기\n\n비동기 함수(async function)에서 반환된 데이터를 이용해서 캐시 항목에 태그를 붙일 수 있어요.\n\n```js\nimport { unstable_cacheTag as cacheTag } from \"next/cache\";\n\ninterface BookingsProps {\n  type: string;\n}\n\nexport async function Bookings({ type = \"haircut\" }: BookingsProps) {\n  async function getBookingsData() {\n    \"use cache\"; // 캐시 활용을 위한 지시어\n    const data = await fetch(`/api/bookings?type=${encodeURIComponent(type)}`);\n    cacheTag(\"bookings-data\", data.id); // 받은 데이터의 id를 태그값으로 지정\n    return data;\n  }\n  return; //...\n}\n```\n\n여기서 중요한 포인트는 `cacheTag`를 사용해 데이터를 태그함으로써 특정 조건에 따라 캐시를 더 정밀하게 관리할 수 있다는 거예요. 예를 들어, 예약 타입별로 캐시를 구분하거나 데이터 ID별로 캐시 무효화를 쉽게 할 수 있죠.\n\n그리고 `use cache`라는 키워드가 보이죠? 이건 Next.js가 이 함수 결과를 캐싱하도록 알려주는 역할을 합니다. 실제 프로젝트에서는 이렇게 재사용 가능한 데이터를 효율적으로 다룰 때 꼭 활용해보세요!\n\n### 태그된 캐시 무효화하기\n\n작성한 태그를 기반으로 캐시를 무효화해 특정 데이터가 변경되었을 때 최신 상태를 유지할 수 있어요.\n\n```js\nimport { unstable_invalidateCacheTag as invalidateCacheTag } from \"next/cache\";\n\nexport async function invalidateBookingCache(id: string) {\n  // 'bookings-data'라는 태그에 id 값으로 붙인 캐시를 무효화합니다.\n  invalidateCacheTag(\"bookings-data\", id);\n}\n```\n\n이렇게 태그 단위로 캐시를 무효화하면, 불필요한 전체 캐시 초기화 없이 원하는 부분만 갱신 가능해져서 효율적이에요. 만약 데이터 변경 이벤트가 발생하면 이 함수를 호출해 관련 캐시를 리프레시하는 방식으로 활용하면 됩니다.\n\n캐시 태그 활용법은 Next.js 13버전 이후의 캐시 전략에서 굉장히 강력한 기능 중 하나이니 꼭 익혀두세요! 개발하며 때때로 캐시 데이터가 꼬일 때 이 방법으로 깔끔하게 관리할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n'revalidateTag'를 사용하면 필요한 시점에 특정 태그의 캐시를 무효화해서 최신 데이터를 반영할 수 있어요. 예를 들어, 아래 코드처럼 'bookings-data'라는 태그에 달려있는 캐시를 갱신해줄 수 있죠.\n\n```js\n\"use server\";\n\nimport { revalidateTag } from \"next/cache\";\n\nexport async function updateBookings() {\n  await updateBookingData();\n  revalidateTag(\"bookings-data\");\n}\n```\n\n간단히 말해, updateBookingData() 함수가 예약 데이터를 업데이트한 뒤에 revalidateTag('bookings-data')를 호출하면, Next.js가 그 태그에 연결된 캐시를 무효화해서 사용자들에게 최신 정보를 보여주게 됩니다.\n\n여기서 중요한 점은, 캐시 무효화를 태그 단위로 관리할 수 있다는 거예요. 덕분에 전체 페이지 캐시를 다 날리지 않고도, 특정 데이터 부분만 신속하게 업데이트할 수 있으니 효율적이죠!\n\n추가로, revalidateTag는 서버 컴포넌트나 API 라우트 등 서버 측 코드에서만 사용 가능하다는 점도 기억해 주세요. 클라이언트 측에서는 사용할 수 없고, 반드시 'use server' directive가 있어야 합니다.\n","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":9},{"title":"Next.js 15에서 Connection 관리하는 방법","description":"","date":"2025-04-22 02:59","slug":"2025-04-22-connection","content":"\n# connection 함수 살펴보기\n\n오늘은 Next.js에서 제공하는 `connection()` 함수에 대해 이야기해볼게요. 이 함수는 이름만 들으면 네트워크 연결처럼 느껴지지만, 실제로는 렌더링 시점을 제어하는 역할을 한답니다.\n\n## connection() 함수가 뭐예요?\n\n쉽게 말해, `connection()` 함수는 렌더링을 잠시 멈췄다가 **유저의 요청이 들어올 때까지 기다렸다가** 렌더링을 계속하도록 해줘요.\n\n왜 이런 기능이 필요하냐고요? 보통 컴포넌트들은 프리렌더링(빌드 타임에 미리 화면을 만들어두는 것)을 하거든요. 그런데 우리가 원하는 건 프리렌더링이 아니라, **실시간으로 변화하는 값**을 화면에 보여주는 거라면 다르게 처리해야 해요.\n\n예를 들면 `Math.random()`이나 `new Date()`처럼 매번 다른 결과를 내는 값들이 그러하죠. 이런 값들은 빌드할 때 계산해버리면, 그 결과가 계속 고정되어 버리잖아요? 그래서 유저가 접속할 때마다 새로 계산해서 보여줘야 하는 경우가 있어요.\n\n이럴 때 `connection()` 함수를 쓰면, 빌드 타임에 렌더링하는 대신 유저 요청 시점에 렌더링하도록 하는 거죠.\n\n## 간단한 예제 코드\n\n```jsx\nimport { connection } from \"next/server\";\n\nexport default async function Page() {\n  await connection();\n  // 이 아래에서 작성한 코드는 빌드 시점이 아니라,\n  // 실제 요청이 들어올 때 실행돼요!\n  const rand = Math.random();\n  return \u003cspan\u003e{rand}\u003c/span\u003e;\n}\n```\n\n보시면 `await connection()`을 호출하는 순간부터 아래 코드는 빌드 타임에 무시되고, 유저가 페이지를 요청했을 때 실행된답니다.\n\n## 이런 점도 알아두면 좋아요!\n\n- `connection()`은 서버에서만 동작해요. 그래서 클라이언트 쪽 코드에서는 사용할 수 없고, 주로 서버 컴포넌트 안에서 써요.\n- 프리렌더링을 완전히 안 하니까, 렌더링 속도는 약간 느릴 수 있어요. 그러니 꼭 필요할 때만 사용하는 게 좋아요.\n- `connection()` 없이도 `force-dynamic` 같은 옵션으로도 비슷한 효과를 낼 수 있는데, 사용 의도에 따라 적절하게 선택하면 돼요.\n\n## 마무리\n\n정리하자면, `connection()`은 **빌드 타임이 아닌 요청 시점에 렌더링을 하도록 만들어주는 함수**에요. 그래서 동적인 데이터를 실시간에 가깝게 보여야 할 때 정말 유용하답니다.\n\nNext.js를 쓸 때 이 함수가 왜 필요한지, 어떻게 쓰는지 이해하면 좀 더 유연한 서버 컴포넌트를 만들 수 있어요. 나중에 실시간 데이터 처리 혹은 매번 변하는 값을 렌더링해야 할 때 한 번 써보면 좋겠습니다!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 참고 자료\n\n### 함수 타입\n\n```js\nfunction connection(): Promise\u003cvoid\u003e\n```\n\n### 파라미터\n\n이 함수는 딱히 파라미터를 받지 않아요. 그냥 연결을 시도하고, 연결이 성공하면 `Promise`가 해결되고, 실패하면 에러가 발생하는 구조입니다.\n\n---\n\n함수 이름인 `connection`으로 봤을 때, 아마도 데이터베이스 연결이나 네트워크 연결 같은 걸 담당하는 함수가 아닐까 싶은데요. 실제로 이런 함수는 비동기 작업이 많기 때문에 `Promise\u003cvoid\u003e`를 반환하는 게 일반적입니다.\n\n`Promise\u003cvoid\u003e`라는 건, 작업이 성공적으로 끝나면 별다른 값을 반환하지 않는다는 뜻이에요. 그래서 이 함수를 사용할 때는 `await connection()` 처럼 쓰거나, `.then()`을 사용해서 연결이 끝난 후에 실행할 코드를 작성하면 됩니다.\n\n```js\nasync function initApp() {\n  try {\n    await connection();\n    console.log(\"연결 완료!\");\n  } catch (error) {\n    console.error(\"연결 실패:\", error);\n  }\n}\n```\n\n연결이 성공했는지 여부에 따라서 애플리케이션 로직이 달라질 수 있기 때문에, 꼭 `try-catch` 문이나 `.catch()`를 활용해 에러 처리를 해주시는 게 좋아요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 이 함수는 어떠한 매개변수도 받지 않습니다.\n\n### 반환 값\n\n- 함수는 void를 반환하는 Promise를 리턴합니다. 즉, 호출자가 결과 값을 활용하도록 설계된 함수가 아니에요.\n\n## 알아두면 좋은 점\n\n이런 타입의 함수는 보통 내부에서 비동기 작업을 처리하지만, 결과를 직접적으로 반환하거나 전달하지 않고 그냥 처리만 하고 끝나는 경우에 많이 쓰여요. 예를 들어 로그를 저장하거나, 캐시를 비우는 작업처럼 \"결과가 있으면 좋지만 없어도 되는\" 경우에요.\n\n만약 함수의 처리가 실패할 수 있다면, Promise를 리턴하니 async/await나 then/catch로 에러를 잡아주는 걸 잊지 마세요! 그래야 앱이 예기치 않게 멈추는 걸 막을 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- connection이 unstable_noStore를 대체해서, 앞으로 Next.js의 방향에 더 잘 맞게 업데이트되었어요.\n- 이 함수는 동적 렌더링이 꼭 필요할 때만 사용하면 되며, 일반적인 Dynamic API들을 사용할 경우에는 필요하지 않아요.\n\n### 버전 히스토리\n\n| 버전         | 변경사항                 |\n| ------------ | ------------------------ |\n| `v15.0.0`    | `connection`가 안정화됨. |\n| `v15.0.0-RC` | `connection` 도입됨.     |\n\n참고로, Next.js가 점점 더 SSR(서버 사이드 렌더링)과 SSG(정적 사이트 생성)을 효율적으로 처리할 수 있도록 많은 개선을 하고 있어서, 이런 함수들이 안정화되는 게 개발자 입장에서 꽤 반가운 소식이에요. 특히 동적 콘텐츠를 다룰 때 성능과 안정성을 높이는 데 도움이 된답니다!\n","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":4},{"title":"Next.js 15에서 cacheLife 설정하는 방법 및 캐시 수명 관리 방법 정리","description":"","date":"2025-04-22 02:57","slug":"2025-04-22-cacheLife","content":"\n# cacheLife 함수 알아보기\n\n안녕하세요, 개발 블로거입니다! 오늘은 `cacheLife`라는 함수에 대해 이야기해보려고 해요. 이 함수는 함수나 컴포넌트의 캐시 수명을 설정하는 데 쓰여요. 캐시 수명이란, 쉽게 말해 '데이터를 얼마나 오래 저장해서 재사용할지'를 결정하는 시간이죠.\n\n이 `cacheLife` 함수는 `use cache` 지시어와 함께 사용해야 하며, 반드시 함수나 컴포넌트의 범위 안에서 호출해야 한다는 점 기억하세요.\n\n## 사용법\n\n`cacheLife`를 사용하려면 우선 프로젝트 설정 파일인 `next.config.js`에 `dynamicIO` 플래그를 활성화해야 합니다:\n\n```js\n// next.config.js\nmodule.exports = {\n  experimental: {\n    dynamicIO: true,\n  },\n};\n```\n\n왜 이렇게 설정해야 하냐면, `dynamicIO` 플래그가 켜져야 동적인 입출력 처리와 캐싱 기능이 제대로 작동하기 때문이에요.\n\n### 참고로!\n\n만약 캐시를 너무 오래 유지하면 데이터가 오래된 상태일 수 있으니, 적절한 캐시 수명을 설정하는 게 중요해요. 반대로 너무 짧게 설정하면 캐시 효과가 떨어지고 서버 부하가 늘 수 있답니다.\n\n추가로, React나 Next.js와 같은 프레임워크를 사용 중이라면, `cacheLife` 설정과 `use cache` 관련 지시어를 적절히 조합해 컴포넌트 렌더링 최적화를 도모할 수 있습니다.\n\n다음에 좀 더 구체적인 사용 예제와 실전 팁을 공유할게요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번에 Next.js에서 소개된 새로운 기능 중 하나인 `dynamicIO`와 `cacheLife`에 대해 간단히 살펴볼게요. 직접 써보고 정리한 내용이니 참고해서 프로젝트에 적용해봐도 좋을 것 같아요!\n\n---\n\n### `dynamicIO` Experimental 옵션 설정하기\n\nNext.js는 계속 발전 중이라 실험적인 기능도 종종 나옵니다. `dynamicIO`는 그중 하나인데, 이걸 켜면 IO 작업을 더 동적으로 처리할 수 있는 환경을 만들어줍니다.\n\n```js\nimport type { NextConfig } from \"next\";\n\nconst nextConfig: NextConfig = {\n  experimental: {\n    dynamicIO: true,\n  },\n};\n\nexport default nextConfig;\n```\n\n- 위처럼 `next.config.js` 혹은 `next.config.ts`에서 `experimental.dynamicIO` 옵션을 `true`로 설정하면 돼요.\n- 공식 문서에서는 이 옵션이 아직 실험 단계라서, 실제 서비스에서는 좀 더 안정화될 때까지 조심스럽게 사용하는 걸 권장합니다.\n\n---\n\n### `cacheLife` 함수 사용하기\n\n`cacheLife`는 Next.js에서 새롭게 제공하는 캐싱 관련 유틸리티예요. 특히 서버 컴포넌트나 함수 내에서 캐싱 수명을 관리할 때 유용하죠.\n\n```js\n\"use cache\";\nimport { unstable_cacheLife as cacheLife } from \"next/cache\";\n\nexport default async function Page() {\n  // cacheLife를 이용해 캐시 수명을 조절하는 로직 구현 가능\n  return \u003cdiv\u003ePage\u003c/div\u003e;\n}\n```\n\n- 여기서 `use cache`라는 디렉티브도 눈에 띄는데, 이건 Next.js가 해당 모듈을 캐싱 대상으로 인식하게 해줘요.\n- `unstable_cacheLife`는 아직 실험적인 API라는 뜻이라, 이름 앞에 `unstable_`가 붙어 있어요.\n- 이 함수를 활용하면, 필요한 부분의 캐시 유지 시간을 섬세하게 조절할 수 있어요. 예를 들어, 데이터 페칭 결과를 일정 시간 동안만 캐싱하고 싶을 때 유용하답니다.\n\n---\n\n### 참고사항 및 팁\n\n| 내용                                | 설명                                                               |\n| ----------------------------------- | ------------------------------------------------------------------ |\n| `dynamicIO` 기능의 목적             | I/O 작업을 더 동적으로 처리하여 효율적인 데이터 페칭과 렌더링 가능 |\n| `cacheLife` 활용법                  | 캐시 수명을 직접 설정해 보다 세밀한 리소스 관리 가능               |\n| 'unstable\\_' 접두사 의미            | 아직 안정화되지 않은 API, 앞으로 변경될 가능성 있음                |\n| Next.js 실험적 기능 활용시 주의사항 | 실제 서비스에 적용할 때는 충분한 테스트 후 사용하는 것이 좋음      |\n\n혹시 이 기능들을 실제로 프로젝트에 적용해보고 어려운 점이나 궁금한 점이 있으면 댓글로 남겨주세요! 저도 더 공부해서 좋은 팁들 공유할게요. Next.js 계속 발전하는 만큼, 우리도 함께 성장해보자구요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 기본 캐시 프로필 소개\n\nNext.js에서는 다양한 시간대에 맞춘 이름 있는 캐시 프로필 세트를 제공해요. 만약 `use cache` 디렉티브와 함께 `cacheLife` 함수에 캐시 프로필을 지정하지 않으면, Next.js가 기본 캐시 프로필을 자동으로 적용해줍니다.\n\n하지만 저는 항상 `use cache`를 사용할 때는 명시적으로 캐시 프로필을 지정해주는 걸 추천해요. 그래야 내가 원하는 캐싱 동작을 확실히 정의할 수 있거든요!\n\n아래는 Next.js가 제공하는 기본 캐시 프로필들의 종류와 각 프로필이 가진 `stale`, `revalidate`, `expire` 타임라인, 그리고 설명입니다.\n\n| 프로필    | stale | revalidate | expire | 설명                                                                   |\n| --------- | ----- | ---------- | ------ | ---------------------------------------------------------------------- |\n| `default` | 5분   | 15분       | 1년    | 자주 업데이트 필요 없는 콘텐츠에 적합한 기본 프로필                    |\n| `seconds` | 0     | 1초        | 1초    | 거의 실시간 업데이트가 필요한 빠르게 변하는 콘텐츠에 적합              |\n| `minutes` | 5분   | 1분        | 1시간  | 한 시간 내 자주 업데이트되는 콘텐츠에 적합                             |\n| `hours`   | 5분   | 1시간      | 1일    | 하루 단위로 업데이트되며 약간 오래된 캐시가 허용되는 콘텐츠에 적합     |\n| `days`    | 5분   | 1일        | 1주일  | 주 단위로 업데이트되며 하루 정도 오래된 캐시 정도 괜찮은 콘텐츠에 적합 |\n| `weeks`   | 5분   | 1주일      | 30일   | 월 단위 업데이트이며 일주일 정도 캐시가 오래돼도 괜찮은 콘텐츠에 적합  |\n| `max`     | 5분   | 30일       | 1년    | 거의 변경되지 않는 매우 안정적인 콘텐츠에 적합                         |\n\n---\n\n### 덧붙여서...\n\n- `stale` 기간이란, 캐시된 데이터가 구식(stale)으로 간주되기 전까지의 시간입니다. 이 기간 동안은 캐시된 데이터를 사용하지만, `revalidate` 시점에는 백그라운드에서 새로운 데이터를 받아와서 캐시를 갱신하게 돼요.\n- `revalidate`는 백그라운드에서 데이터를 다시 요청하는 시기를 뜻해요. 이때 응답은 즉시 캐시된 값으로 처리하고, 서버에서 신규 데이터를 받아 업데이트합니다.\n- `expire`는 캐시가 완전히 만료되어 더 이상 사용할 수 없는 시점을 의미합니다.\n\n만약 자주 업데이트가 필요한 뉴스 사이트나 주식 시세, 실시간 스포츠 결과 같은 데이터라면 `seconds`나 `minutes` 프로필을, 변화가 거의 없는 블로그 포스트나 정적인 이미지 리소스라면 `max` 프로필 같은 장기 캐싱을 선택하는 게 효율적이에요.\n\nNext.js 캐시 기능은 이렇게 시간 기반 프로필을 잘 활용하면 사용자 경험도 개선하고 서버 부하도 줄일 수 있으니, 꼭 적절하게 설정해서 활용해 보시길 바랍니다!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n캐시 프로필을 참조할 때 사용하는 문자열 값들은 그 자체로 특별한 의미를 가지기보다는, 코드 내에서 의미를 부여하는 라벨 역할을 해요. 덕분에 캐시된 콘텐츠를 더 쉽고 직관적으로 관리할 수 있답니다.\n\n\u003e 참고할 점: staleTimes와 expireTime 설정을 변경하면 기본 캐시 프로필의 stale과 expire 속성도 함께 업데이트돼요. 즉, 일관성 있게 캐시 설정을 관리할 수 있다는 뜻이죠.\n\n### 커스텀 캐시 프로필 만들기\n\nNext.js 프로젝트에서 커스텀 캐시 프로필을 만들어 사용하고 싶다면, `next.config.ts` 파일 내의 `cacheLife` 옵션에 직접 추가하면 돼요. 이렇게 하면 프로젝트 요구사항에 맞게 캐시 정책을 세밀하게 조정할 수 있답니다.\n\n아래는 `cacheLife` 옵션을 활용해 여러 캐시 프로필을 정의하는 예시입니다:\n\n```typescript\n// next.config.ts\nexport default {\n  experimental: {\n    cacheLife: {\n      shortCache: { staleTime: 60, expireTime: 120 }, // 짧게 유지되는 캐시 예시 (초단위)\n      longCache: { staleTime: 3600, expireTime: 7200 }, // 오래 유지되는 캐시 예시\n      noCache: { staleTime: 0, expireTime: 0 }, // 캐시를 사용하지 않는 프로필\n    },\n  },\n};\n```\n\n이렇게 프로필을 만들고 나면, 데이터 요청이나 페이지 캐싱 시에 해당 프로필 이름(`shortCache`, `longCache` 등)을 참조해 필요한 캐시 정책을 간편하게 적용할 수 있죠.\n\n\u003e 팁! 캐시를 적절히 활용하면 서버 부하도 줄이고, 사용자 경험도 크게 향상시킬 수 있어요. 하지만 너무 오래된 캐시는 오히려 구버전 콘텐츠를 보여줄 수 있으니, 상황에 따라 적절한 `staleTime`과 `expireTime` 설정이 중요하답니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nCache profiles는 캐시와 관련된 몇 가지 속성을 담고 있는 객체입니다. 각 속성은 캐시가 어떻게 동작하는지 세밀하게 조절할 수 있게 도와주죠. 아래 표를 보면서 살펴볼게요.\n\n| Property     | Value  | Description                                                                                                                                   | Requirement                          |\n| ------------ | ------ | --------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------ |\n| `stale`      | number | 클라이언트가 서버에 확인하지 않고 값을 캐시에 저장해두는 기간입니다.                                                                          | 선택 사항                            |\n| `revalidate` | number | 서버에서 캐시를 새로 고칠 주기입니다. 리밸리데이트 중에는 오래된 값(stale)을 보여줄 수 있어요.                                                | 선택 사항                            |\n| `expire`     | number | 값이 오래된 상태(stale)로 유지될 수 있는 최대 기간입니다. 이 기간이 지나면 동적(fetch)으로 전환됩니다. 반드시 `revalidate`보다 길어야 합니다. | 선택 사항 – `revalidate`보다 커야 함 |\n\n---\n\n여기서 조금 혼동될 수 있는 부분이 `stale` 속성과 `staleTimes` 설정인데요, 간단히 말씀드리면:\n\n- `stale`은 클라이언트 사이드 라우터 쪽 캐시만 제어합니다. 즉, 특정 함수나 경로(route)별로 직접 '얼마 동안 캐싱할지'를 정할 수 있다는 거죠.\n- 반면에 `staleTimes`는 전역(globa) 설정으로, 동적(dynamic) 데이터와 정적(static) 데이터 모두에 영향을 미칩니다.\n\n---\n\n그리고 한 가지 팁!  \n`stale` 속성은 **Cache-control: max-age** HTTP 헤더 값을 설정하는 게 아닙니다. 이건 서버에서 보내는 캐시 지시자(header)이지만, `stale`은 오로지 클라이언트 라우터의 로컬 캐시 관리를 위한 설정이라는 점, 꼭 기억하세요.\n\n이런 캐시 컨트롤 방법은 앱을 더 빠르게 만들면서도 최신 데이터를 적절히 유지하는 데 아주 유용해요. 각 상황에 맞게 잘 조절해보면서 퍼포먼스 최적화에 활용해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 예시\n\n### 재사용 가능한 캐시 프로필 정의하기\n\nnext.config.ts 파일에서 재사용 가능한 캐시 프로필을 정의할 수 있어요. 프로필 이름은 사용 목적에 맞게 지정하고, `stale`, `revalidate`, `expire` 속성들을 설정해주면 됩니다. 필요한 만큼 여러 개의 커스텀 캐시 프로필을 만들어 사용할 수 있어요. 각 프로필은 이름을 문자열로 `cacheLife` 함수에 전달해서 참조할 수 있답니다.\n\n아래 예시는 14일간 캐시를 유지하고, 1일마다 재검증을 수행하는 `biweekly`라는 캐시 프로필을 정의한 코드입니다.\n\n```typescript\nimport type { NextConfig } from \"next\";\n\nconst nextConfig: NextConfig = {\n  experimental: {\n    dynamicIO: true,\n    cacheLife: {\n      biweekly: {\n        stale: 60 * 60 * 24 * 14, // 14일 동안 stale 상태 유지\n        revalidate: 60 * 60 * 24, // 1일 간격으로 재검증\n        expire: 60 * 60 * 24 * 14, // 14일 후 캐시 만료\n      },\n    },\n  },\n};\n\nmodule.exports = nextConfig;\n```\n\n---\n\n**참고로 캐시 관련 설정을 잘 해두면, 페이지 로딩 속도가 크게 향상되고 서버 부하도 줄일 수 있어요.** 특히 자주 변하지 않는 데이터라면 이런 캐시 프로필을 적극 활용해서 효율적인 서비스 운영을 할 수 있답니다.\n\n단, `stale`, `revalidate`, `expire` 값은 상황에 맞게 조절해야 해요. 예측 가능한 사용자 트래픽, 데이터 갱신 빈도 등을 고려해 보세요. 너무 길게 설정하면 오래된 데이터가 노출될 수도 있으니까 주의가 필요해요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위 예시는 14일 동안 캐시를 유지하고, 매일 업데이트를 확인하며, 14일이 지나면 캐시가 만료되도록 설정한 거예요. 이렇게 만든 캐시 프로필은 애플리케이션 전반에서 이름으로 참조해서 사용할 수 있답니다.\n\n```js\n\"use cache\";\nimport { unstable_cacheLife as cacheLife } from \"next/cache\";\n\nexport default async function Page() {\n  return \u003cdiv\u003ePage\u003c/div\u003e;\n}\n```\n\n### 기본 캐시 프로필 덮어쓰기(오버라이딩)\n\nNext.js에서 제공하는 기본 캐시 프로필은 캐시된 데이터가 얼마나 신선한지, 혹은 얼마나 오래된 것인지를 결정하는 데 도움을 줘요. 그런데 어떤 애플리케이션은 기본 프로필보다 더 세분화된 캐싱 전략이 필요할 수 있죠. 이럴 때는 내 입맛에 맞게 이름이 붙은(즉, 커스텀) 캐시 프로필을 만들어서 쓸 수 있어요.\n\n예를 들어, 자주 업데이트되는 뉴스 섹션엔 'shortCache', 변경이 거의 없는 공지사항엔 'longCache' 같은 이름을 붙여서 관리하면 더 효율적이고 관리하기도 편하답니다. 이렇게 하면 빠른 캐시 만료가 필요한 곳과 오래 두어도 무방한 부분을 명확히 구분할 수 있어요.\n\n\u003e **참고 팁:** 캐시 프로필을 세밀하게 관리하면, 서버 부담을 줄이면서도 사용자에게 항상 신선한 콘텐츠를 제공할 수 있어요. 너무 보수적으로 캐시 기간을 설정하면 빈번한 요청 처리로 서버에 부담이 갈 수 있으니, 애플리케이션 특성에 맞게 적절히 조절하는 게 중요합니다!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nnext.js에서 기본으로 제공하는 캐시 프로필(named cache profiles)을 커스텀하고 싶을 때, 같은 이름으로 새 설정을 만들어서 덮어쓸 수 있다는 점, 알고 계셨나요? 기본 프로필을 그대로 쓰는 것도 좋지만, 프로젝트 상황에 맞게 적절히 조정하면 효율적인 캐시 관리가 가능해집니다.\n\n예를 들어, 기본 “days” 캐시 프로필을 이렇게 오버라이딩할 수 있어요:\n\n```js\nconst nextConfig = {\n  experimental: {\n    dynamicIO: true,\n    cacheLife: {\n      days: {\n        stale: 3600, // 1시간 동안 stale 상태 유지\n        revalidate: 900, // 15분마다 재검증\n        expire: 86400, // 1일 후 만료\n      },\n    },\n  },\n};\n\nmodule.exports = nextConfig;\n```\n\n여기서 좀 더 설명을 드리자면,\n\n- `stale`: 캐시된 데이터가 조금 오래됐어도 바로 폐기하지 않고, 이 시간만큼은 stale 상태로 허용합니다. (즉, 약간 낡은 데이터도 사용할 수 있게끔 시간을 설정하는 거예요.)\n- `revalidate`: 재검증(interval) 주기로, 이 시간이 지나면 캐시를 백그라운드에서 새로고침합니다.\n- `expire`: 캐시가 완전히 만료되는 시간으로, 이 시간이 지나면 캐시를 폐기하고 새 데이터를 받아옵니다.\n\n이런 설정 덕분에 데이터를 너무 자주 다시 받느라 리소스를 낭비하지 않고, 살짝 오래된 데이터도 쓸 수 있게 해서 효율성을 높일 수 있답니다.\n\n### 캐시 프로필 직접 정의하기 (Defining cache profiles inline)\n\n기본 프로필이 아니라 완전히 새롭게 캐시 프로필을 정의하고 싶을 때도 있습니다. 예를 들어, 'hours'라는 이름으로 6시간 단위의 캐시 전략을 직접 만들어볼 수 있죠.\n\n```js\nconst nextConfig = {\n  experimental: {\n    dynamicIO: true,\n    cacheLife: {\n      hours: {\n        stale: 600, // 10분간 stale 허용\n        revalidate: 300, // 5분마다 재검증\n        expire: 21600, // 6시간 후 만료\n      },\n    },\n  },\n};\n\nmodule.exports = nextConfig;\n```\n\n이렇게 나만의 캐시 전략을 만들어두면, 복잡한 프로젝트에서 여러 페이지나 API에 맞게 캐시 설정을 다양하게 적용할 수 있어서 매우 유용해요.\n\n\u003e **팁:** 캐싱 전략을 짤 때, 너무 짧은 expire는 서버 부담을 늘리고, 너무 긴 expire는 사용자에게 오래된 데이터를 보여줄 위험이 생기므로 적절한 균형이 중요합니다!\n\n필요에 따라 값들을 튜닝하면서 최적의 캐시 전략을 찾아가 보세요. 앞으로도 이런 유용한 실전 팁 계속 소개할게요! 궁금한 점 있으면 언제든 물어봐 주세요 :)\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번에는 Next.js에서 캐싱을 좀 더 세밀하게 제어하는 방법에 대해 이야기해볼게요. 특히 `cacheLife` 함수를 사용해서 원하는 캐시 프로필을 직접 설정하는 방법을 다뤄보겠습니다.\n\n```js\n\"use cache\";\nimport { unstable_cacheLife as cacheLife } from \"next/cache\";\n\nexport default async function Page() {\n  return \u003cdiv\u003ePage\u003c/div\u003e;\n}\n```\n\n위 코드는 기본적인 캐시 설정 예시예요. 여기서 `cacheLife` 함수에 객체 형태의 설정값을 넘기면 내가 원하는 캐시 정책을 직접 만들 수 있어요. 그런데 중요한 점은 이렇게 만든 캐시 프로필은 해당 함수나 파일에 한해서만 적용된다는 거예요.\n\n만약 여러분의 앱 전체에서 같은 캐시 정책을 반복해서 쓰고 싶다면, 매번 이렇게 작성하는 대신 `next.config.ts` 파일 안에 `cacheLife` 속성을 추가하는 게 좋은 방법입니다. 그러면 전역적으로 일관된 캐싱 전략을 관리할 수 있거든요.\n\n---\n\n### 좀 더 살펴보는 `use cache`와 `cacheLife`의 중첩 사용법\n\n`'use cache'`는 Next.js에서 함수가 캐시 가능하다는 걸 알려주는 지시문이고, `cacheLife`는 그 캐시의 수명과 동작 정책을 좀 더 구체적으로 설정해주는 역할을 해요.\n\n```js\n\"use cache\";\nimport { unstable_cacheLife as cacheLife } from \"next/cache\";\n\n// 예를 들어, 캐시 수명을 60초로 지정하고 싶을 때\nconst myCacheConfig = cacheLife({ maxAge: 60 });\n\nexport default myCacheConfig(async function Page() {\n  return \u003cdiv\u003e캐시가 60초 동안 유지됩니다.\u003c/div\u003e;\n});\n```\n\n위처럼 `cacheLife`가 반환하는 함수로 래핑하면, 그 안 함수는 해당 캐시 정책을 따르게 됩니다.\n\n---\n\n### 추가 팁!\n\n- **maxAge**: 캐시 데이터가 얼마동안 살아있을지 초 단위로 지정해요.\n- **staleWhileRevalidate**: 캐시가 만료되더라도 새 데이터를 받아올 때까지 옛날 캐시를 계속 보여주는 설정이에요.\n- **캐시 무효화**: 필요할 땐 특정 조건이나 API 호출 시 캐시를 초기화해줄 수도 있는데, 이 부분도 꼭 체크해보시면 좋아요.\n\nReact 컴포넌트나 API 라우트에서 잘 활용하면, 불필요한 데이터 재요청을 줄이고 사용자 경험을 개선할 수 있답니다.\n\n필요하면 다음에 더 자세한 캐시 전략이나 예제도 정리해서 소개할게요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n같은 경로나 컴포넌트 트리 안에서 여러 캐싱 동작(caching behavior)을 정의할 때, 안쪽(내부) 캐시가 자신만의 cacheLife 프로필을 지정하면, 바깥쪽(외부) 캐시는 그 중 가장 짧은 캐시 지속시간을 자동으로 따르게 돼요. 단, 이건 바깥쪽 캐시가 명시적으로 cacheLife 프로필을 지정하지 않은 경우에만 적용됩니다.\n\n예를 들어, 페이지에 `use cache` 지시어를 붙이면서 별도로 캐시 프로필을 지정하지 않으면, 기본값인 `cacheLife(\"default\")`가 암묵적으로 적용돼요. 그런데 이 페이지에 불러오는 컴포넌트가 자체 캐시 프로필을 가진 `use cache`를 사용한다면, 내부와 외부 캐시 프로필이 비교되어서, 가장 짧은 시간이 적용됩니다.\n\n간단히 말해, 여러 레이어의 캐시가 있으면 \"가장 짧은 시간 기준\"으로 캐싱 기간을 설정해서, 데이터를 너무 오래 쓰지 않도록 조절해 준다는 거죠.\n\n---\n\n예를 들어서 본 부모 컴포넌트 코드를 한번 보면:\n\n```js\n// Parent component\nimport { unstable_cacheLife as cacheLife } from \"next/cache\";\nimport { ChildComponent } from \"./child\";\n\ncacheLife(\"days\"); // \"days\" 기준 캐싱 지속시간 지정\n\nreturn (\n  \u003cdiv\u003e\n    \u003cChildComponent /\u003e\n  \u003c/div\u003e\n);\n```\n\n그리고 별도의 파일에서 임포트한 자식 컴포넌트는 다음처럼 정의해요.\n\n(자식 컴포넌트 코드는 다음에 나올 거랍니다!)\n\n---\n\n### 추가 팁!\n\n- 캐시 지속 시간을 지정할 때는 `\"hours\"`, `\"minutes\"`, `\"seconds\"`처럼 구체적으로 설정하셔도 되고, 직접 숫자 단위(예: `cacheLife(60 * 60 * 24)`)로 초 단위 값을 줄 수도 있습니다.\n- 내부 컴포넌트의 캐시가 더 짧으면, 전체적으로 데이터 최신성이 더 잘 유지되기 때문에 업데이트 반영 속도가 빨라지죠.\n- 반대로 외부에서 명시적으로 긴 cacheLife를 지정하면 내부 캐시는 무시되고 외부 걸린 시간 기준으로 유지돼요. 따라서 캐시가 꼬이지 않도록 캐시 설정을 꼼꼼하게 관리하는 게 중요합니다.\n\n다음 메시지에 자식 컴포넌트 코드를 소개할게요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안녕하세요! 오늘은 Next.js에서 제공하는 `unstable_cacheLife` 함수에 대해 살펴볼게요. 이 함수는 캐시 수명을 설정할 때 사용되는데, 아직 공식적으로 안정화되지 않은 기능이라 `unstable_` 접두사가 붙어 있답니다.\n\n예시 코드가 주어졌는데, 쉽게 설명해볼게요.\n\n```js\n// Child 컴포넌트에서\nimport { unstable_cacheLife as cacheLife } from \"next/cache\";\n\ncacheLife(\"hours\");\nreturn \u003cdiv\u003eChild Content\u003c/div\u003e;\n\n// 이 컴포넌트의 캐시는 'hours' 프로필 기준으로 관리됩니다.\n```\n\n여기서 `cacheLife('hours')`라고 설정하면, 이 컴포넌트는 상대적으로 짧은 시간 단위인 'hours' 기준으로 캐시가 유지돼요. 즉, 더 빨리 캐시가 만료된다는 뜻이죠.\n\n### 참고할 점!\n\n- `cacheLife` 안에 들어갈 수 있는 프로필은 보통 'seconds', 'minutes', 'hours', 'days' 등이 있어요.\n- 이 기능은 아직 실험 단계라 문서가 계속 업데이트되고, API도 바뀔 수 있어요.\n- 캐시 수명을 적절히 조정하면 사용자 경험을 향상시키면서 서버 부하도 줄일 수 있다는 점에서 유용해요!\n\n### 마치며\n\nNext.js에서 캐시를 더 세밀하게 제어하고 싶을 때 `unstable_cacheLife`를 써볼 수 있지만, 아직 완전 안정적이지 않은 점을 기억하세요. 프로덕션에서는 주의해서 사용하고, 공식 문서 업데이트를 꾸준히 확인하는 걸 추천드립니다!\n\n도움이 되셨다면 좋겠네요. 다음에도 유용한 팁으로 찾아올게요! 😊\n","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":17},{"title":"Next.js 15에서 after 메서드 활용하는 최신 방법 2025","description":"","date":"2025-04-22 02:56","slug":"2025-04-22-after","content":"\n\n# after\n\n`after`는 응답(response)이나 프리렌더(prerender)가 완료된 후에 작업을 예약해서 실행할 수 있게 해주는 기능입니다. 쉽게 말해, 사용자에게 응답을 보내는 데 방해가 되지 않아야 하는 작업들—예를 들어 로그 기록, 분석 데이터 수집 같은 부수 효과들—을 뒤로 미룰 때 유용해요.\n\n이 기능은 Server Components (예: `generateMetadata` 포함), Server Actions, Route Handlers, 그리고 Middleware에서도 사용할 수 있습니다.\n\n사용법은 간단해요. `after` 함수에 콜백 함수를 넘겨주면, 응답이 끝난 뒤에 그 콜백이 실행됩니다. 그래서 응답 속도를 늦추지 않고도 필요한 작업을 뒤에서 처리할 수 있죠.\n\n---\n\n### 추가 팁!\n- 예를 들어, 사용자의 방문 기록을 DB에 저장하는 로직을 `after`로 실행하면, 방문자 입장에선 페이지가 빠르게 로드되고, 백엔드에서는 기록 작업이 조용히 이루어져 좋은 UX를 만들 수 있어요.\n- 하지만 너무 무거운 작업을 `after`에 넣으면 서버 자원을 불필요하게 잡아먹을 수 있으니, 적절한 용도로 사용해야 합니다.\n- 만약 처리 중 에러가 나도 응답에는 영향을 주지 않습니다. 에러 핸들링도 따로 챙겨주면 좋아요.\n\n---\n\n필요하면 예제 코드도 공유해 드릴게요—함께 공부해봅시다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안녕하세요! 오늘은 Next.js의 서버 컴포넌트에서 `after` 함수를 어떻게 활용할 수 있는지 간단하게 알려드릴게요.\n\n```js\nimport { after } from 'next/server'\n// 커스텀 로깅 함수\nimport { log } from '@/app/utils'\n\nexport default function Layout({ children }: { children: React.ReactNode }) {\n  after(() =\u003e {\n    // 레이아웃이 렌더링되고 사용자에게 전송된 후에 실행됩니다.\n    log()\n  })\n  return \u003c\u003e{children}\u003c/\u003e\n}\n```\n\n### 핵심 포인트!  \n`after` 함수는 렌더링이 끝난 다음, 클라이언트에게 응답을 보낸 후 콜백 함수를 실행시키는 역할을 해요. 예를 들면, 로그를 남기거나 데이터를 트래킹할 때 유용하겠죠.\n\n\u003e **참고:** `after`는 동적 API가 아니에요. 그러니까 이걸 호출한다고 해서 페이지가 자동으로 동적 라우트(dynamic route)가 되는 건 아닙니다.  \n\u003e 만약 static page 내에서 사용하면, 이 콜백 함수는 빌드 타임이나 페이지가 다시 검증(revalidate) 될 때 실행됩니다.\n\n---\n\n## `after` 함수 주요 특징 정리!\n\n| 파라미터 | 설명 |\n|---------|------|\n| 콜백 함수 | 렌더링 직후 실행할 함수. 비동기 콜백도 지원하지만, 응답을 막지는 않음 |\n\n---\n\n### 더 알아두면 좋은 점  \n- 서버 컴포넌트라서 클라이언트에서 확인할 수 없는 서버 정보도 수집하기 편합니다.  \n- 로그 외에도 꼭 필요한 후처리를 비동기적으로 깔끔하게 처리하고 싶을 때 좋습니다.  \n- `after`의 콜백은 사용자에게 페이지가 전달된 후 실행되니 렌더링 성능에 영향을 주지 않고, 부담 없이 후처리를 맡길 수 있어요.\n\n---\n\nNext.js로 서버 사이드 렌더링을 다룰 때 이런 후처리 방법을 알고 있으면 성능 튜닝이나 디버깅에 큰 도움이 됩니다. 오늘도 좋은 개발하시길 바라요! 😊\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 응답(또는 프리렌더링)이 완료된 후 실행될 콜백 함수입니다.\n\n### 실행 시간(Duration)\n\n`after` 함수는 기본적으로 플랫폼에서 설정된 최대 실행 시간(또는 라우트별로 설정된 최대 지속 시간) 동안 실행됩니다. 만약 사용하는 플랫폼이 지원한다면, 라우트의 `maxDuration` 설정을 통해 타임아웃 제한을 조절할 수 있어요.\n\n## 참고하면 좋은 점\n\n- 콜백 함수가 너무 오래 실행되면 타임아웃이 발생할 수 있으니, 작업이 오래 걸리는 경우 최대 실행 시간을 적절히 설정하는 것이 중요합니다.\n- 이 기능은 서버리스 환경이나 프리렌더링 작업에서 특히 유용해요. 예를 들어, 데이터를 미리 가져오거나 로깅 작업을 비동기적으로 처리할 때 활용할 수 있답니다.\n- `maxDuration` 설정이 없는 경우에는 플랫폼 기본값이 적용되니, 꼭 확인해 보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- after는 응답이 정상적으로 완료되지 않아도 실행이 됩니다. 에러가 발생하거나 notFound 또는 redirect가 호출된 경우에도 마찬가지에요.\n- React 캐시를 활용해서 after 내부에서 호출되는 함수들의 중복 실행을 방지할 수 있어요.\n- after는 중첩해서 사용할 수도 있어요. 예를 들어, after 호출을 감싸는 유틸리티 함수를 만들어서 추가 기능을 덧붙일 수도 있죠.\n\n## 대안들\n\nafter의 주된 용도는 주 응답을 막지 않고 부수적인 작업을 처리하는 거예요. 이 점에서 플랫폼의 waitUntil()이나 프로미스에서 await을 빼는 것과 비슷하지만, 중요한 차이점이 있어요:\n\n| 구분           | 설명                                                                                                                                              |\n|----------------|--------------------------------------------------------------------------------------------------------------------------------------------------|\n| waitUntil()    | 프로미스를 받아서 요청 수명주기 동안 실행할 작업을 예약해요.                                                                                         |\n| after          | 응답이 완전히 끝난 후에 실행할 콜백을 받아요.                                                                                                      |\n| await 제거     | 응답 중에 실행을 시작해 리소스를 이용해요. 또한 서버리스 환경에서는 응답 후 함수 실행을 바로 멈추기 때문에 작업이 중단될 위험이 있어요.               |\n\n쉽게 말해서 waitUntil()은 백그라운드에서 요청과 함께 작업을 처리하지만 after는 응답이 끝난 후에 작업을 처리해요. await을 쓰지 않는 건 리소스 낭비와 안정성 문제를 초래할 수 있으니 상황에 맞게 선택하는 게 중요해요.\n\n참고로, 서버리스 환경에서는 특히 이런 비동기 작업이 응답 직후에 중단될 위험이 크기 때문에 after나 waitUntil() 같은 명확한 처리방식을 사용하는 게 좋아요. 그리고 React 캐시를 적극 활용하면 함수 호출 중복도 줄이고 성능도 높일 수 있으니 꼭 활용해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서는 'after'를 사용하는 걸 추천해요. 이유는 'after'가 Next.js의 다른 API나 컨텍스트들을 잘 고려해서 설계되었기 때문이죠. 즉, 더 안정적이고 일관성 있게 동작할 수 있다는 뜻이에요.\n\n## 예제\n\n### 요청(Request) API와 함께 사용하기\n\n서버 액션(Server Actions)이나 라우트 핸들러(Route Handlers) 내에서 'after' 블록 안에 쿠키(cookies)나 헤더(headers) 같은 요청 관련 API를 사용할 수 있어요. 예를 들어, 어떤 데이터 변경(mutation) 작업 후에 활동 기록을 로그로 남기고 싶을 때 유용하답니다.\n\n실제로 이걸 어떻게 활용할 수 있는지 살짝 보여드릴게요. 간단한 예제로, 사용자가 데이터를 변경한 뒤에 로그를 남기는 경우를 생각해 볼 수 있죠.\n\n(여기에 간단한 코드 예제가 들어가면 더 이해가 쏙쏙 될 텐데, 혹시 필요하면 알려주세요! 제가 바로 준비해드릴게요.)\n\n---\n\n참고로, Next.js에서 이렇게 'after'를 활용하면 요청에 대한 응답 처리 후에 후처리를 자연스럽게 할 수 있어서, 코드가 깔끔해지고 유지보수도 쉬워진답니다. 여러분도 프로젝트에 적용해 보시면 좋을 것 같아요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js의 `after` 훅을 활용해서 서버 액션 후에 로깅 작업을 진행하는 예제를 보여드렸는데요, 여기서 주의할 점이 있어요.\n\n```js\nimport { after } from 'next/server'\nimport { logUserAction } from '@/app/utils'\n\nexport async function POST(request: Request) {\n  // Perform mutation\n  after(async () =\u003e {\n    const userAgent = (await headers().get('user-agent')) || 'unknown'\n    const sessionCookie =\n      (await cookies().get('session-id'))?.value || 'anonymous'\n\n    logUserAction({ sessionCookie, userAgent })\n  })\n\n  return new Response(JSON.stringify({ status: 'success' }), {\n    status: 200,\n    headers: { 'Content-Type': 'application/json' },\n  })\n}\n```\n\n문제는 `after`에서 `headers()`나 `cookies()` 같은 request API를 사용할 수 없다는 점이에요. 왜냐하면 Next.js는 Partial Prerendering(부분 프리렌더링)을 지원하기 위해 요청 API를 어떤 컴포넌트가 사용하는지 알아야 하는데, `after` 훅은 React 렌더링 라이프사이클 이후에 실행되기 때문에 그 제약에 걸려버립니다.\n\n즉, `after` 내부에서는 요청 관련 API를 호출하면 에러가 발생할 수 있으니 꼭 다른 곳에서 요청 정보를 추출하고, `after`에는 순수히 후처리 로직만 넣어주는 게 안전해요.\n\n아래는 간단히 Next.js 버전별 `after` 훅 관련 히스토리를 정리한 표입니다.\n\n| Version History | Description                      |\n|-----------------|---------------------------------|\n| `v15.1.0`       | `after`가 안정화됨 (stable)      |\n| `v15.0.0-rc`    | `unstable_after`가 도입됨        |\n\n이 내용 참고하셔서, `after` 훅을 활용할 때는 request API 접근 제한을 명심하고, 코드를 설계해보세요. 혹시 `after`에서 request 정보를 꼭 사용해야 할 경우엔, 요청 데이터를 미리 받고 전달하는 구조로 만들어야 작업이 가능하답니다.\n\n더불어, 이런 구조적 제한은 Next.js가 최적화를 위해 도입한 부분이라, Partial Prerendering 덕분에 페이지 로딩 성능이 좋아지는 장점도 있으니 이해하고 활용하면 유용해요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":8}],"page":"1","totalPageCount":41,"totalPageGroupCount":3,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"1"},"buildId":"o6AmBAY_j9v9JmbaRA39X","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>