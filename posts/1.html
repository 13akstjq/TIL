<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>TIL</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//posts/1" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="TIL" data-gatsby-head="true"/><meta property="og:title" content="TIL" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//posts/1" data-gatsby-head="true"/><meta name="twitter:title" content="TIL" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/7978fe7362f7d4c9.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/7978fe7362f7d4c9.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/TIL/_next/static/chunks/463-925361deb4cec4b1.js" defer=""></script><script src="/TIL/_next/static/chunks/873-2eda6d845ad1e69e.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/posts/%5Bpage%5D-350e448526ad5efa.js" defer=""></script><script src="/TIL/_next/static/xwOwpfNxF5xANgUpiyc2H/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/xwOwpfNxF5xANgUpiyc2H/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="BlockNote의 Text-To-Speech 기능 구현 방법 - Nextjs 사용 " href="/TIL/post/2024-07-14-ImplementingText-To-SpeechFunctionalityForBlockNoteInNextJs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="BlockNote의 Text-To-Speech 기능 구현 방법 - Nextjs 사용 " loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-ImplementingText-To-SpeechFunctionalityForBlockNoteInNextJs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="BlockNote의 Text-To-Speech 기능 구현 방법 - Nextjs 사용 " loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">BlockNote의 Text-To-Speech 기능 구현 방법 - Nextjs 사용 </strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="초보자를 위한 TypeScript 데이터 구조 배우기 Part 2" href="/TIL/post/2024-07-14-LearningDataStructureinTypeScriptforBeginnerPart2"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="초보자를 위한 TypeScript 데이터 구조 배우기 Part 2" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-LearningDataStructureinTypeScriptforBeginnerPart2_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="초보자를 위한 TypeScript 데이터 구조 배우기 Part 2" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">초보자를 위한 TypeScript 데이터 구조 배우기 Part 2</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="TypeScript 코드를 더 잘 쓰는 방법" href="/TIL/post/2024-07-14-HowtowritebetterTypescriptcodes"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="TypeScript 코드를 더 잘 쓰는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-HowtowritebetterTypescriptcodes_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="TypeScript 코드를 더 잘 쓰는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">TypeScript 코드를 더 잘 쓰는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="프로덕션에서 절대 사용하지 않을 9가지 Python 안티 패턴" href="/TIL/post/2024-07-14-9PythonAntiPatternsThatIWillNeverApplyinProduction"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="프로덕션에서 절대 사용하지 않을 9가지 Python 안티 패턴" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-9PythonAntiPatternsThatIWillNeverApplyinProduction_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="프로덕션에서 절대 사용하지 않을 9가지 Python 안티 패턴" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">프로덕션에서 절대 사용하지 않을 9가지 Python 안티 패턴</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="당신의 첫 LLM 앱을 개발하는 데 필요한 모든 것" href="/TIL/post/2024-07-14-AllYouNeedtoKnowtoBuildYourFirstLLMApp"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="당신의 첫 LLM 앱을 개발하는 데 필요한 모든 것" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-AllYouNeedtoKnowtoBuildYourFirstLLMApp_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="당신의 첫 LLM 앱을 개발하는 데 필요한 모든 것" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">당신의 첫 LLM 앱을 개발하는 데 필요한 모든 것</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">39<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="장고에서 파이썬 데코레이터의 강력한 기능 알아보기" href="/TIL/post/2024-07-14-ThePowerofDecoratorsinPythonDjango"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="장고에서 파이썬 데코레이터의 강력한 기능 알아보기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/no-image.jpg"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="장고에서 파이썬 데코레이터의 강력한 기능 알아보기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">장고에서 파이썬 데코레이터의 강력한 기능 알아보기</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="파이썬 데이터 분석을 위한 반드시 알아야 할 10가지 판다스 기술" href="/TIL/post/2024-07-14-10Must-KnowPandasTechniquesforPythonDataAnalysis"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="파이썬 데이터 분석을 위한 반드시 알아야 할 10가지 판다스 기술" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/no-image.jpg"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="파이썬 데이터 분석을 위한 반드시 알아야 할 10가지 판다스 기술" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">파이썬 데이터 분석을 위한 반드시 알아야 할 10가지 판다스 기술</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="알아두면 유용한 파이썬 프로그래밍 문법 10가지" href="/TIL/post/2024-07-14-PeculiarPythonProgrammingSyntax"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="알아두면 유용한 파이썬 프로그래밍 문법 10가지" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-PeculiarPythonProgrammingSyntax_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="알아두면 유용한 파이썬 프로그래밍 문법 10가지" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">알아두면 유용한 파이썬 프로그래밍 문법 10가지</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">20<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="당신이 놓쳤을 7가지 미친 파이썬 이스터 에그" href="/TIL/post/2024-07-14-7CrazyPythonEasterEggsYouProbablyHaventSeen"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="당신이 놓쳤을 7가지 미친 파이썬 이스터 에그" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-7CrazyPythonEasterEggsYouProbablyHaventSeen_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="당신이 놓쳤을 7가지 미친 파이썬 이스터 에그" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">당신이 놓쳤을 7가지 미친 파이썬 이스터 에그</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="오늘 바로 해킹의 첫 걸음 내딛기" href="/TIL/post/2024-07-14-Takeyourfirststepinhackingtoday"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="오늘 바로 해킹의 첫 걸음 내딛기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-Takeyourfirststepinhackingtoday_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="오늘 바로 해킹의 첫 걸음 내딛기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">오늘 바로 해킹의 첫 걸음 내딛기</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link posts_-active__YVJEi" href="/TIL/posts/1">1</a><a class="link" href="/TIL/posts/2">2</a><a class="link" href="/TIL/posts/3">3</a><a class="link" href="/TIL/posts/4">4</a><a class="link" href="/TIL/posts/5">5</a><a class="link" href="/TIL/posts/6">6</a><a class="link" href="/TIL/posts/7">7</a><a class="link" href="/TIL/posts/8">8</a><a class="link" href="/TIL/posts/9">9</a><a class="link" href="/TIL/posts/10">10</a><a class="link" href="/TIL/posts/11">11</a><a class="link" href="/TIL/posts/12">12</a><a class="link" href="/TIL/posts/13">13</a><a class="link" href="/TIL/posts/14">14</a><a class="link" href="/TIL/posts/15">15</a><a class="link" href="/TIL/posts/16">16</a><a class="link" href="/TIL/posts/17">17</a><a class="link" href="/TIL/posts/18">18</a><a class="link" href="/TIL/posts/19">19</a><a class="link" href="/TIL/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"BlockNote의 Text-To-Speech 기능 구현 방법 - Nextjs 사용 ","description":"","date":"2024-07-14 20:49","slug":"2024-07-14-ImplementingText-To-SpeechFunctionalityForBlockNoteInNextJs","content":"\n\n## 와우: WYSIWYG 편집기로 텍스트 음성 변환 기능!\n\n로켓 과학을 해결했습니다! 물론 거짓말이에요. BlockNote에 텍스트 음성 변환 기능을 Next.Js에서 어떻게 구현할지 알아냈습니다. BlockNote를 모르시면, Next.js에서 WYSIWYG 편집기 문제에 대한 해결책을 발견한 기사를 읽어보세요.\n\n그러니까 읽어보세요. 하지만 여러분의 지식 부족함에도 불구하고, 저는 계속 이 기사를 쓸 겁니다. BlockNote를 아는 여러분은 이 기사로 들어가 봅시다. 출발!\n\n![이미지](/TIL/assets/img/2024-07-14-ImplementingText-To-SpeechFunctionalityForBlockNoteInNextJs_0.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 요약\n\n우리는 블록을 HTML로 변환하여 Firebase에 BlockNote 데이터를 저장하는 방법을 배웠어요. 그 기사를 읽었다면 가상으로 엄지척을 할게요. 그럼, 코드는 지금 이렇게 보일 거예요:\n\n```js\n'use client';\nimport React, { useState, useEffect, useRef, ChangeEvent, useCallback } from 'react';\nimport { useSearchParams } from 'next/navigation';\nimport { firestore } from '../../../../../firebase';\nimport { getDoc, doc, updateDoc } from 'firebase/firestore';\nimport \"@blocknote/core/fonts/inter.css\";\nimport { useCreateBlockNote } from \"@blocknote/react\";\nimport { BlockNoteView } from \"@blocknote/mantine\";\nimport \"@blocknote/mantine/style.css\";\nimport { Block } from \"@blocknote/core\";\n\nfunction Document() {\n const params = useSearchParams();\n const docId = params.get(\"id\");\n const [title, setTitle] = useState('');\n const [value, setValue] = useState('');\n const [blocks, setBlocks] = useState\u003cBlock[]\u003e([]);\n\n   useEffect(() =\u003e {\n   const fetchDocument = async () =\u003e {\n     if (!docId) return;\n\n     const docRef = doc(firestore, `documents/${docId}`);\n     try {\n       const docSnap = await getDoc(docRef);\n       if (docSnap.exists()) {\n         const data = docSnap.data();\n         setTitle(data.title || '');\n         setValue(data.content || '');\n       } else {\n         console.log('Document does not exist');\n       }\n     } catch (error) {\n       console.error('Error fetching document: ', error);\n     }\n   };\n\n   fetchDocument();\n }, [docId]);\n\n const editor = useCreateBlockNote();\n\n useEffect(() =\u003e {\n   async function loadInitialHTML() {\n     const blocks = await editor.tryParseHTMLToBlocks(value);\n     editor.replaceBlocks(editor.document, blocks);\n   }\n   loadInitialHTML();\n }, [editor, value]);\n\n const saveDocument = async () =\u003e {\n   if (!docId) return;\n\n   const content = await editor.blocksToHTMLLossy(blocks);\n\n   try {\n     await updateDoc(doc(firestore, `documents/${docId}`), {\n       content: content,\n     });\n\n     console.log('Document saved successfully');\n   } catch (error) {\n     console.error('Error saving document: ', error);\n   }\n };\n\n return (\n   \u003cdiv\u003e\n     \u003ch1\u003e{title}\u003c/h1\u003e\n     \u003cBlockNoteView editor={editor} onChange={() =\u003e { setBlocks(editor.document); }} /\u003e\n     \u003cbutton onClick={saveDocument}\u003eSave Document\u003c/button\u003e\n   \u003c/div\u003e\n );\n}\n\nexport default Document;\n```\n\n우리가 머릿속을 새롭게 한 이제, 뭔가 추가해봐요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 이것을 어떻게 할 건가요???\n\n좋은 질문이네요! 제가 떠올렸기 때문에 알고 있어요. 웹 스피치 API를 사용하여 텍스트 음성 변환 기능을 구현할 거에요.\n\n웹 스피치 API를 활용하면 음성 데이터를 웹 앱에 통합할 수 있어요. 이 경우는 Next.js 애플리케이션에서 사용할 거에요.\n\n이러한 종류의 기능을 추가하기 위해 SpeechSynthesis라고 불리는 Web 스피치 API의 인터페이스를 사용할 거에요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 구현\n\n우리의 코드에는 단지 한 가지 함수와 버튼을 추가하면 됩니다. 그게 다에요. 코드에 다음 함수를 추가하세요:\n\n```js\nfunction speak() {\n  const text = blocks\n  .map(block =\u003e block?.content)\n  .filter(content =\u003e content !== undefined)\n  .flatMap(content =\u003e {\n    if (Array.isArray(content)) {\n      return content\n        .filter(contentItem =\u003e contentItem.type === 'text')\n        .map(contentItem =\u003e contentItem.text);\n    } else {\n      return [];\n    }\n  })\n  .join(' ');\n  let utterance = new SpeechSynthesisUtterance(text);\n  let voicesArray = speechSynthesis.getVoices();\n  utterance.voice = voicesArray[2];\n  speechSynthesis.speak(utterance);\n}\n```\n\n이 함수는 문서에서 콘텐츠를 가져와서 콘텐츠가 텍스트 유형인 경우 에디터 내용을 말합니다. 간단하죠. 이제 '말하기' 버튼을 화면에 표시하세요:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```jsx\n\u003cbutton onClick={speak}\u003eSpeak\u003c/button\u003e\n```\n\n# 더 깊이 파고들기\n\n만약 음성 합성의 피치, 속도, 볼륨을 변경하여 사용자 정의하고 싶다면 어떻게 할까요? 잘하셨어요! 이제 이에 대해 알아볼게요. 이 뒤에 광고가 나와야죠! 농담이죠: 여기는 유튜브가 아니에요.\n\n피치 변경하기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n음 높이를 조절하려면 이 줄을 추가하세요:\n\n```js\nutterance.pitch = 4; // 원하는 값으로 숫자를 변경하세요\n```\n\n속도 변경하기\n\n속도를 조절하려면 이 줄을 추가하세요:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nutterance.rate= 5; // 원하는 값으로 숫자를 변경해주세요\n```\n\n볼륨 조절하기\n\n```js\nutterance.volume= 0.4; // 원하는 값으로 소수를 변경해주세요\n```\n\n지금까지 코드에 텍스트 음성 변환 기능을 구현하는 단 기사를 마무리 지어보았습니다. 만약 이 기사가 도움이 되었다면 박수를 보내주세요, 팔로우를 눌러주세요, 또는 응답을 달아주세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n행복한 코딩하세요!","ogImage":{"url":"/TIL/assets/img/2024-07-14-ImplementingText-To-SpeechFunctionalityForBlockNoteInNextJs_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-ImplementingText-To-SpeechFunctionalityForBlockNoteInNextJs_0.png","tag":["Tech"],"readingTime":7},{"title":"초보자를 위한 TypeScript 데이터 구조 배우기 Part 2","description":"","date":"2024-07-14 20:48","slug":"2024-07-14-LearningDataStructureinTypeScriptforBeginnerPart2","content":"\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-LearningDataStructureinTypeScriptforBeginnerPart2_0.png\" /\u003e\n\n# 소개\n\n이전 글에서 기본 데이터 구조에 대해 논의했습니다.\n\n- 이 글에서는 몇 가지 일반적인 데이터 구조 (연결 리스트, 큐, 스택, 해시 테이블, 이진 트리, 이진 힙)의 JavaScript 구현을 살펴보았습니다.\n- 이 시리즈에서는 프린스턴의 기본 데이터 구조에 대한 구체적인 내용을 Java 구현을 통해 배웠습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기본 데이터 구조 이외에도 여전히 유용한 데이터 구조가 있습니다. 이러한 데이터 구조들은 우리 애플리케이션의 성능을 향상시키는 데 도움이 될 수 있습니다.\n\n## 안내\n\n본 글에서는 두 가지 데이터 구조를 고려하여 실제 프론트엔드 애플리케이션 사례를 개선해보겠습니다.\n\n- Trie (접두사 트리)\n- 그래프 — 인접 리스트 표현\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 1. Trie (접두사 트리)\n\n다음 스크린샷은 자동 완성 검색 바에서 가져온 것입니다. 제가 배열에 단어들을 넣어 후보 제시 항목으로 사용했어요. 실제로 목록에서 단어를 검색할 때 성능이 아주 좋지 않다고 해요. (소스 코드를 확인해주세요)\n\n성능을 향상시킬 수 있는 방법이 있을까요?\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-LearningDataStructureinTypeScriptforBeginnerPart2_1.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 위 케이스의 원본 솔루션은 후보 항목을 배열에 저장하는 것입니다. 배열을 필터링하여 동일한 접두사를 가진 항목을 검색하는 데 걸리는 시간은 O(L)입니다. 여기서 L은 배열의 길이입니다.\n- 성능을 개선하기 위해 후보 항목을 Trie 구조에 저장할 수 있습니다. 이 경우 단어의 길이를 나타내는 n에 대해 O(n)이 걸립니다.\n\n## Trie의 정의\n\n![Trie 구조 이미지](/TIL/assets/img/2024-07-14-LearningDataStructureinTypeScriptforBeginnerPart2_2.png)\n\n## 구현 방법\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nTypeScript에서 어떻게 작동하는지 확인해 보겠습니다.\n\n1. TrieNode 구조 만들기\n\n- 역할\n  - 1. HashTable을 사용하여 자식을 효율적으로 저장, 검색 및 나열함 (O(1))\n  - 2. addChild는 쉽게 단일 가지를 탐색할 수 있도록 자식을 반환해야 함\n  - 3. 문자가 단어의 끝인 경우 isCompleted를 true로 표시합니다. 그 노드 아래에 새로운 자식이 추가될 때 업데이트됩니다.\n\n2. Trie 구조 만들기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 책임\n- TrieNode의 인스턴스를 소유하여 단어 삽입, 단어 검색 및 특정 접두사로 단어 확인 수행\n\n2. Trie에 단어 삽입\n\n- addWord는 자식을 재귀적으로 추가하는 것을 목표로 한다.\n- 이는 연결 리스트를 탐색하는 방법과 유사하다. 자식을 추가하고 입력 문자열의 끝에 도달할 때까지 포인터를 자식으로 이동시킨다.\n- 성능\n- 시간 복잡도: O(n), n은 단어의 길이이다.\n- 공간 복잡도: O(1)\n\n3. Trie에서 단어 검색\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- getLastCharacterNode 함수는 입력 문자열의 끝에 도달했을 때에만 노드를 검색하고, 그 외의 경우에는 null을 반환합니다.\n- 성능\n- 시간 복잡도: O(n), 여기서 n은 문자열의 길이입니다.\n- 공간 복잡도: O(1)\n\n4. Trie에서 단어 검색하기 (DFS 사용)\n\n- getLastCharacterNode를 사용하여 검색하는 단점은 다음 자식 노드를 찾을 수 없다면 작동을 멈출 수 있다는 것입니다.\n- 예를 들어, abc를 삽입한 후 a.c인 경우 true를 반환해야 하는 새로운 요구 사항이 있다고 가정해보겠습니다.\n- 대안적인 해결책은 다음 글자가 .인 경우에는 모든 다음 자식을 시도하는 것입니다.\n\n5. Trie에서 특정 접두어를 가진 단어가 있는지 확인하기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 마지막 문자 노드를 얻은 후 getSuggestedNextCharacters 목록의 자식 키\n- 성능\n- 시간 복잡성: O(n), n은 단어의 길이입니다.\n- 공간 복잡성: O(1)\n\n## 2. 그래프 — 인접 리스트 표현\n\n그래프 시각화 예시가 있습니다. 이 그래프를 탐색하는 새로운 요구 사항이 있다면 우리 코드의 성능이 나빠질 수 있습니다. (소스 코드 확인)\n\n성능을 향상시킬 방법이 있을까요?\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![이미지](/TIL/assets/img/2024-07-14-LearningDataStructureinTypeScriptforBeginnerPart2_3.png)\n\n- 현재 소스 코드에는 순회 알고리즘이 구현되어 있지 않습니다. 만약 구현해야 한다면, O(V * E)가 걸릴 것입니다. 여기서 V는 노드의 수이고, E는 간선의 수입니다(각 노드마다 해당 노드의 이웃 노드를 얻기 위해 모든 간선을 확인해야 합니다).\n- 성능을 개선하기 위해 데이터 구조를 재구성하고 인접 리스트를 만듭니다. 이는 O(V + E)가 소요됩니다. 여기서 V는 노드의 수이고, E는 그래프 순회에 필요한 간선의 수입니다.\n\n## 정의\n\n![이미지](/TIL/assets/img/2024-07-14-LearningDataStructureinTypeScriptforBeginnerPart2_4.png)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 구현\n\nTypeScript에서 어떻게 작동하는지 확인해 봐요.\n\n1. Edge 구조체를 만들기\n\n- Edge는 두 개의 노드 사이의 연결이에요\n- 역할\n    - 노드와의 관계 확인: hasSourceNode 및 hasTargetNode는 노드가 Edge의 일부인지 아닌지 확인할 수 있어요 (라인 14 ~ 20)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2. 노드 구조 생성하기\n\n- 노드는 엣지의 출발지 또는 도착지입니다.\n- 책임\n  - 1. 링크드 리스트를 사용하여 이웃 엣지를 효율적으로 저장 및 검색합니다 (O(n)) (라인 26 ~ 42)\n  - 2. 노드와의 관계를 기반으로 차수, 인바운드 차수, 아웃바운드 차수를 제공합니다 (라인 8 ~ 20)\n\n3. 그래프 구조\n\n- 그래프는 노드와 엣지로 이루어진 비선형 데이터 구조입니다.\n- 책임\n  - 1. 노드와 엣지를 저장합니다.\n  - 2. 노드와 엣지에 대한 작업을 수행합니다 (예: 추가, 탐색 등).\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n4. 그래프 순회\n\n두 가지 종류의 순회가 있습니다. 너비 우선 탐색 (라인 7~31)과 깊이 우선 탐색 (라인 36~51).\n\n- 목적:\n- BFS: 다음 레이어 방문 전에 모든 이웃을 걸어다닌다\n- DFS: 모든 이웃을 걸어다니기 전에 가장 먼 레이어에 도착\n- 시간 복잡도:\n- BFS, 너비 우선 탐색: O(V + E), V는 노드 수, E는 간선 수\n- DFS, 깊이 우선 탐색: O(V + E), V는 노드 수, E는 간선 수\n- 공간 복잡도:\n- BFS, 너비 우선 탐색: O(V), V는 노드 수\n- DFS, 깊이 우선 탐색: O(V), V는 노드 수\n\n# 참고\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Trie 데이터 구조 이해하기\n- 해시 테이블 대 트라이 (접두사 트리)\n- 트라이 데이터 구조 | 삽입 및 검색\n- 그래프 알고리즘 재방문\n- 그래프\n\n# 요약\n\n기다려 주셔서 감사합니다. 저는 션입니다. 소프트웨어 엔지니어로 일하고 있어요.\n\n이 글은 제 노트입니다. 만약에 어떤 실수가 있다면 자유롭게 조언해주세요. 당신의 피드백을 기다리고 있어요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 저를 구독해 주세요\n\n- 기사를 공유하는 페이스북 페이지\n\n- 최신 사이드 프로젝트: 매일 학습\n\n# 관련 주제\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n두방향 바인딩을 Knout.js와 ReactJS에서 어떻게 사용하는지 알아보세요!\n\nSignalR을 사용하여 채팅방 애플리케이션을 만드는 방법을 배워보세요.\n\n'효과적인 SQL'에 대한 내 반성: \n\nIT 및 네트워크:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n데이터베이스:","ogImage":{"url":"/TIL/assets/img/2024-07-14-LearningDataStructureinTypeScriptforBeginnerPart2_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-LearningDataStructureinTypeScriptforBeginnerPart2_0.png","tag":["Tech"],"readingTime":9},{"title":"TypeScript 코드를 더 잘 쓰는 방법","description":"","date":"2024-07-14 20:46","slug":"2024-07-14-HowtowritebetterTypescriptcodes","content":"\n\n## TYPESCRIPT\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-HowtowritebetterTypescriptcodes_0.png\" /\u003e\n\n## #1 Optional Chaining (?.):\n\nOptional chaining(?.)은 중첩된 프로퍼티 또는 메소드에 안전하게 접근할 수 있게 해줍니다. null 또는 undefined 값에 대해 걱정할 필요가 없습니다. 중간 프로퍼티 중 하나라도 null 또는 undefined이면 평가가 중단됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nconst user = {\n  name: 'Piotr',\n  address: {\n    city: 'Warsaw',\n    postalCode: '00-240'\n  }\n};\n\n\nconst postalCode = user.address?.postalCode;\nconsole.log(postalCode); // 00-240\n\nconst invalidCode = user.address?.postalCode?.toLowerCase();\nconsole.log(invalidCode); // Output: undefined\n```\n\n## #2 Use Mapped Types for Transformation\n\nMapped types allow you to create new types by transforming properties of existing types.\n\n```js\ntype Readonly\u003cT\u003e = {\n  readonly [P in keyof T]: T[P];\n};\ntype Partial\u003cT\u003e = {\n  [P in keyof T]?: T[P];\n};\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## #3 유틸리티 유형\n\nTypeScript는 일반적인 유형 변환을 돕기 위해 여러 유틸리티 유형을 제공합니다.\n\ni) Partial`T`: 모든 속성을 선택적으로 만듭니다.\nii) Required`T`: 모든 속성을 필수로 만듭니다.\niii) Readonly`T`: 모든 속성을 읽기 전용으로 만듭니다.\niv) Record`K, T`: 키가 K이고 유형이 T인 유형을 생성합니다.\n\n```js\ntype Person = {\n  name: string;\n  age: number;\n};\ntype PartialPerson = Partial\u003cPerson\u003e;\ntype ReadonlyPerson = Readonly\u003cPerson\u003e;\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## #4 타입 가드\n\n타입 가드를 사용하여 조건 블록 내에서 타입을 좁힐 수 있습니다.\n\n```js\nfunction isString(value: unknown): value is string {\n  return typeof value === 'string';\n}\n```\n\n## #5 템플릿 리터럴 타입\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n표 태그를 마크다운 형식으로 변경해주세요.\n\n\nTese allow you to create new string types by combining string literals.\n\n```js\ntype EventName = 'click' | 'hover';\ntype EventHandlerName = `${EventName}Handler`; // 'clickHandler' | 'hoverHandler'\n```\n\n## #6 Indexed Access Types\n\nUse indexed access types to extract the type of a property.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n유형 Person = { 이름: string; 나이: number };\n유형 NameType = Person['name']; // string\n```\n\n## #7 키 리매핑을 통한 Mapped Types\n\n새로운 유형을 생성하는 동안 키를 변환합니다.\n\n```js\n유형 PrefixKeys\u003cT, P extends string\u003e = {\n  [K in keyof T as `${P}${K \u0026 string}`]: T[K]\n};\n유형 PrefixedPerson = PrefixKeys\u003c{ 이름: string; 나이: number }, 'prefix_'\u003e;\n// { prefix_name: string; prefix_age: number }\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## #8 공용체\n\n이들은 서로 다른 유형의 조합을 만들고 유형 안전한(타입 세이프) 공용체를 만드는 데 도움을 줍니다.\n\n```js\ntype Shape =\n  | { kind: 'circle'; radius: number }\n  | { kind: 'square'; side: number };\n\nfunction getArea(shape: Shape) {\n  switch (shape.kind) {\n    case 'circle': return Math.PI * shape.radius ** 2;\n    case 'square': return shape.side ** 2;\n  }\n}\n```\n\n## #9 제네릭에서 추론된 유형\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n`infer`를 사용하여 조건형 내에서 타입을 추출하고 사용하세요.\n\n```js\ntype ReturnType\u003cT\u003e = T extends (...args: any[]) =\u003e infer R ? R : any;\ntype Fn = () =\u003e number;\ntype Result = ReturnType\u003cFn\u003e; // number\n```\n\n## #10 모듈 확장\n\n기존 모듈에 새로운 기능을 추가하세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```typescript\n// augmentations.ts\nimport 'express';\ndeclare module 'express' {\n  interface Request {\n    user?: { id: string; role: string };\n  }\n}\n```\n\n## #11 Declare Merged Interfaces\n\nMerge interfaces to extend types, especially useful with third-party libraries.\n\n```typescript\ninterface Window {\n  myCustomProperty: string;\n}\nwindow.myCustomProperty = 'Hello!';\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## #12 기능 오버로딩\n\n더 나은 유형 확인을 위해 여러 함수 시그니처를 제공합니다.\n\n```js\nfunction createDate(timestamp: number): Date;\nfunction createDate(year: number, month: number, day: number): Date;\nfunction createDate(x: number, y?: number, z?: number): Date {\n  return y !== undefined \u0026\u0026 z !== undefined ? new Date(x, y, z) : new Date(x);\n}\n```\n\n## #13 브랜드된 타입\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n브랜드화된 타입을 사용하여 명목적 타이핑을 만들어봐요.\n\n```js\ntype UserId = string \u0026 { _brand: 'UserId' };\nfunction createUserId(id: string): UserId {\n  return id as UserId;\n}\n```\n\n## #14 템플릿 리터럴 타입과 컨디셔널 타입\n\n템플릿 리터럴 타입과 컨디셔널 타입을 결합하여 고급 문자열 조작을 해보세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ntype ExtractRouteParams\u003cT extends string\u003e = T extends `/${infer Param}/${infer Rest}`\n  ? { param: Param } \u0026 ExtractRouteParams\u003c`/${Rest}`\u003e\n  : {};\n\ntype Params = ExtractRouteParams\u003c'/user/:id/posts/:postId'\u003e;\n// { param: 'user' } \u0026 { param: 'posts' }\n```\n\n#15 Variadic Tuple Types\n\nTypescript 4+는 가변 튜플 타입을 지원하여 튜플이 배열의 나머지 부분을 캡처할 수 있도록 합니다.\n\n```js\ntype Push\u003cT extends any[], V\u003e = [...T, V];\ntype Result = Push\u003c[1, 2, 3], 4]; // [1, 2, 3, 4]\n```","ogImage":{"url":"/TIL/assets/img/2024-07-14-HowtowritebetterTypescriptcodes_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-HowtowritebetterTypescriptcodes_0.png","tag":["Tech"],"readingTime":8},{"title":"프로덕션에서 절대 사용하지 않을 9가지 Python 안티 패턴","description":"","date":"2024-07-14 20:45","slug":"2024-07-14-9PythonAntiPatternsThatIWillNeverApplyinProduction","content":"\n\n## 파이썬\n\n![Python Anti-Patterns](/TIL/assets/img/2024-07-14-9PythonAntiPatternsThatIWillNeverApplyinProduction_0.png)\n\n어떤 언어든, 오래된 만큼 반드시 몇 가지 안티-패턴 기능과 이해하기 어려운 구문이 있습니다.\n\n파이썬이 우아한 언어라고 하더라도 이 운명에서 벗어날 수 없습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n소프트웨어 개발자로서 우리가 할 수 있는 것은 지식을 최신 상태로 유지하고 오래된 또는 부적절한 기능을 사용하지 않는 것입니다.\n\n이 기사는 가독성, 보안 및 디버깅에 해로운 9가지 Python 안티 패턴에 대해 상기시킬 것입니다. 경험 많은 Python 엔지니어는 제품 개발 시 이러한 패턴을 적용해서는 안 됩니다.\n\n# 1. For-Else 구조\n\nPython에는 매우 특별한 구문인 for-else가 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nif-else가 아니라 for 루프 후에 \"else\"가 있다는 거야!\n\n```js\nleaders = [\"Elon\", \"Tim\", \"Warren\"]\n\nfor i in leaders:\n    if i == \"Yang\":\n        print(\"Yang is a leader!\")\n        break\nelse:\n    print(\"Yang을 찾을 수 없어요!\")\n\n# Yang을 찾을 수 없어요!\n```\n\n위의 코드에서 보듯이 leaders 리스트에는 Yang이 없지만 Yang 또한 지도자입니다. 따라서 for 루프에 break가 없어요.\n\n이 경우, for 루프 뒤에 있는 \"else\" 블록이 실행되었어요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그 로직은 간단합니다. \"else\" 블록은 루프에 중단점이 없을 때만 실행됩니다.\n\n그러나 다른 프로그래밍 언어에서는 else 문을 이렇게 사용할 수 없기 때문에, 이 for-else 구조는 파이썬 원어민이 아닌 대부분의 동료들을 혼란스럽게 만들 수 있습니다.\n\n동료들이 파이썬 마스터라 하더라도, 이 기능이 100% 필요하지 않고, 사용하는 사람이 많지 않으므로, 제품에 적용하는 것은 전혀 좋은 생각이 아닙니다. 그렇지 않으면, 코드베이스의 가독성이 극도로 떨어질 수 있습니다.\n\n그렇다면, for-else 구조 없이 예시 코드를 다시 작성하는 방법은 무엇일까요?\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테이블 태그를 마크다운 형식으로 변경해주세요:\n\n\nleaders = [\"Elon\", \"Tim\", \"Warren\"]\nfound_yang = False\n\nfor i in leaders:\n    if i == \"Yang\":\n        print(\"Yang is a leader!\")\n        found_yang = True\n        break\n\nif not found_yang:\n    print(\"Not found Yang!\")\n\n\n## 2. eval() 또는 exec() 함수\n\n처음 보면, eval() 함수의 힘을 활용하면 일부 기능을 구현하는 것이 더 쉬워 보입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예를 들어, 다음 함수는 eval() 함수의 도움을 받아 한 줄의 코드로 기본 계산기를 구현합니다:\n\n```js\ndef calculator(a, b, op):\n    return eval(f'{a} {op} {b}')\n\nprint(calculator(2, 3, '+'))\n# 5\nprint(calculator(6, 5, '-'))\n# 1\nprint(calculator(7, 8, '*'))\n# 56\nprint(calculator(8, 2, '/'))\n# 4.0\n```\n\n깔끔하고 간결하죠?\n\n사이버 공격자들도 eval() 함수를 좋아합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그 이름에서 알 수 있듯이, eval() 함수는 Python 식을 평가하는 데 사용됩니다.\n\n그러나 입력이 시스템을 해킹하도록 특별히 설계된 경우, eval() 함수는 모든 악의의 근원이 될 수 있습니다.\n\n예를 들어, 누군가 이전의 계산기를 다음과 같은 방식으로 사용한다면, 쉽게 현재 위치의 폴더와 파일 목록을 가져올 수 있습니다:\n\n```js\ndef calculator(a, b, op):\n    return eval(f'{a} {op} {b}')\n\n\nprint(calculator(\"__import__('os').system('ls')\",'',''))\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음과 같이 입력을 변경해보는 건 어떨까요:\n\n```js\nprint(calculator(\"__import__('os').system('rm -rf *')\",'',''))\n```\n\n따라서, 제작 환경에서는 evel() 함수를 사용하지 않는 것이 가장 좋습니다.\n\nevel() 함수와 유사하게, exec()는 Python 프로그램 코드를 동적으로 실행하는 또 다른 내장 함수입니다. 보안 문제로 인해 이 역시 제작 환경에서 사용하지 않는 것이 좋습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 3. 깊게 중첩된 루프\n\n어떤 복잡한 경우에는 중첩된 루프를 사용할 수밖에 없는 것처럼 보입니다:\n\n```js\nlist_a = [1, 2020, 70]\nlist_b = [2, 4, 7, 2000]\nlist_c = [3, 70, 7]\n\nfor a in list_a:\n    for b in list_b:\n        for c in list_c:\n            if a + b + c == 2077:\n                print(a, b, c)\n# 70 2000 7\n```\n\n하지만 깊게 중첩된 루프는 읽기 어렵고 파이썬다운 방식이 아닙니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n나쁜 코딩에서 나오는 안티 패턴입니다. 파이썬은 이 문제를 해결하기 위한 내장 도구를 제공합니다:\n\n```python\nfrom itertools import product\n\nlist_a = [1, 2020, 70]\nlist_b = [2, 4, 7, 2000]\nlist_c = [3, 70, 7]\n\nfor a, b, c in product(list_a, list_b, list_c):\n    if a + b + c == 2077:\n        print(a, b, c)\n# 70 2000 7\n```\n\n위의 예시에서 보다시피, itertools.product() 함수의 도움을 받아 이전 프로그램은 중첩된 루프를 완전히 피할 수 있습니다. 이 함수는 입력 이터러블의 카테시안 곱을 얻기 위한 방법입니다.\n\n# 4. 와일드카드로 모두 가져오기(import)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n와일드카드 임포트(from module import *)는 이름 충돌과 코드 불명확성의 근본이 됩니다.\n\n이것은 모듈에서 모든 객체를 현재 네임스페이스로 가져오기 때문에 어디서 변수 또는 함수가 정의되었는지 추적하기 어렵습니다. 모듈에 의해 소개된 모든 이름을 기억하기 어려울 뿐만 아니라, 특히 대규모 타사 모듈의 경우 더욱 문제입니다.\n\n네임스페이스 오염을 피하기 위해, 우리가 명시적으로 필요한 것만 가져오는 것이 최선의 실천 방법입니다:\n\n```js\nfrom module import func_a, func_b\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 5. 멋진 한 줄 요약\n\n한 줄 요약은 프로그래밍의 재미난 부분을 보여줍니다. 재미로 작성하는 건 괜찮아요.\n\n하지만 제품용 코드에 넣는 건 재앙이 될 수 있습니다.\n\n이것은 퀵 정렬의 파이썬 한 줄 요약입니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n퀵정렬 = lambda l: 퀵정렬([i for i in l[1:] if i \u003c l[0]]) + [l[0]] + 퀵정렬([j for j in l[1:] if j \u003e= l[0]]) if l else []\n```\n\n이 코드는 잘 작동하지만 코드의 로직을 얼마나 빨리 이해할 수 있습니까?\n\n당신만큼 빨리 동료들도 이해할 수 있을까요?\n\n그리고 람다 함수는 많은 멋진 파이썬 한 줄짜리 코드의 기반입니다. 우리는 매우 간단한 함수에만 사용해야 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 6. 깊은 상속 계층 구조와 복잡한 믹스인\n\n객체 지향 프로그래밍은 어떤 면에서는 두 각도로 양날의 검입니다.\n\n때로는 메서드의 목적을 이해하기 위해 매우 복잡한 상속 계층을 추적해야 할 수도 있습니다.\n\n게다가 Python은 믹스인을 지원하는데, 이는 객체를 이해하기 어렵게 만들 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n동료들이 편리하게 일할 수 있도록 상속 체인을 간소화하는 것을 고려해보세요.\n\n# 7. 변경 가능한 기본 인수\n\n파이썬은 값에 의한 호출(call-by-name)도 아니고 참조에 의한 호출(call-by-reference)도 아니며, 공유에 의한 호출(call-by-sharing)이다.\n\n이는 변경 가능한 기본 인수를 정의할 경우 혼란스러운 코드로 이어질 수 있습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ndef get_leaders(element, leader_list=[]):\n    leader_list.append(element)\n    return leader_list\n\n\nprint(get_leaders('Elon'))\n# ['Elon']\nprint(get_leaders('Yang'))\n# ['Elon', 'Yang']\nprint(get_leaders('Warren'))\n# ['Elon', 'Yang', 'Warren']\n```\n\n위의 함수는 함수를 3번 독립적으로 호출해도 항상 동일한 목록을 사용합니다.\n\n이제 leader_list의 기본 값을 None으로 변경하고 결과를 확인해봅시다:\n\n```js\ndef get_leaders(element, leader_list=None):\n    if leader_list is None:\n        leader_list = []\n    leader_list.append(element)\n    return leader_list\n\n\nprint(get_leaders('Elon'))\n# ['Elon']\nprint(get_leaders('Yang'))\n# ['Yang']\nprint(get_leaders('Warren'))\n# ['Warren']\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n매번 함수 호출할 때마다 새로운 목록이 생성됩니다.\n\n실제로 Python 함수에서 가변 기본 인수를 사용하는 것은 Python이 가변 및 불변 데이터 구조를 처리하는 방식으로 인해 안티 패턴으로 간주됩니다. 이 동작은 종종 예상치 못한 결과와 찾기 어려운 버그로 이어집니다.\n\n# 8. If-Else가 모든 곳에서 등장합니다\n\nPython 3.10 이전에는 때때로 많은 if-else 문을 작성해야 했습니다. 왜냐하면 Python은 아직 match-case 구문을 지원하지 않았기 때문입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파이썬 3.10 이후로 구조적 패턴 매칭 기술이 소개되면서 if-else 문을 반복적으로 작성하는 불편을 피할 수 있게 되었습니다:\n\n```js\ndef handle_http_status(status_code):\n    match status_code:\n        case 200:\n            return \"성공!\"\n        case 400:\n            return \"잘못된 요청\"\n        case 401:\n            return \"권한 없음\"\n        case 404:\n            return \"찾을 수 없음\"\n        case 500:\n            return \"내부 서버 오류\"\n\n\nprint(handle_http_status(200))\n# 성공!\nprint(handle_http_status(404))\n# 찾을 수 없음\nprint(handle_http_status(2077))\n# None\n```\n\n위 프로그램에서 보듯이, match-case 구문을 사용하여 각각 다른 입력을 처리할 수 있습니다. 모든 경우에 if-else 문이 필요하지 않다는 것을 알 수 있습니다.\n\n# 9. C-스타일 문자열 포맷팅\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파이썬의 매우 오래된 버전에서는 문자열 포맷팅 연산이 C 프로그래밍 언어와 같았습니다:\n\n```js\nname = 'Yang'\nprint(\"Hi, %s\" % name)\n# Hi, Yang\n```\n\n그러나 파이썬이 많이 발전함에 따라 이전 구문은 여전히 사용할 수 있지만, 그 낡은 면모를 보여주고 있습니다:\n\n지금은 이 오래된 기술을 피하고 모든 문자열 포맷팅에 f-string 구문을 적용해야 합니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\nname = 'Yang'\ndesc = 'amazing'\nprint(f\"Hi, {name}! You are {desc}!\")\n# Hi, Yang! You are amazing!\n\n\n# 결론\n\n어떤 프로그래밍 언어도 완벽하지 않습니다.\n\n자바보다 오래된 파이썬은 불가피하게 몇 가지 나쁜 설계로 인해 안티 패턴을 유발합니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n경험 많은 Python 개발자로서, 우리는 문제가 있는 곳을 파악하고 그것들을 피하는 것이 중요해요. 동시에, 최신 구문을 활용하기 위해 새로운 Python 버전의 업데이트를 주시하면 도움이 될 거예요.\n\n읽어 주셔서 감사합니다. ❤️ 만약 마음에 드셨다면, 연락해 보아요:\n\n- Linkedin\n- Medium\n\n제가 작성한 더 많은 Python 자습서들:","ogImage":{"url":"/TIL/assets/img/2024-07-14-9PythonAntiPatternsThatIWillNeverApplyinProduction_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-9PythonAntiPatternsThatIWillNeverApplyinProduction_0.png","tag":["Tech"],"readingTime":13},{"title":"당신의 첫 LLM 앱을 개발하는 데 필요한 모든 것","description":"","date":"2024-07-14 20:41","slug":"2024-07-14-AllYouNeedtoKnowtoBuildYourFirstLLMApp","content":"\n\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-AllYouNeedtoKnowtoBuildYourFirstLLMApp_0.png\" /\u003e\n\n## 목차\n\n소개\n\nLLM이 필요한 이유\n미세 조정 vs. 컨텍스트 주입\nLangChain이란 무엇인가요?\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n**단계별 튜토리얼**\n\n1. LangChain을 사용하여 문서를 로드합니다.\n2. 문서를 텍스트 청크로 분할합니다.\n3. 텍스트 청크에서 임베딩으로 변환합니다.\n4. 사용할 LLM을 정의합니다.\n5. 프롬프트 템플릿을 정의합니다.\n6. 벡터 스토어를 생성합니다.\n\n![이미지](/TIL/assets/img/2024-07-14-AllYouNeedtoKnowtoBuildYourFirstLLMApp_1.png)\n\n# LLM이 필요한 이유\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n언어의 진화는 우리를 오늘날까지 끌어올렸습니다. 우리는 이를 통해 지식을 효율적으로 공유하고 협력할 수 있게 되었습니다. 결과적으로, 대부분의 집단적인 지식은 미구조화된 채로 기록된 텍스트를 통해 유지되고 전달됩니다.\n\n지난 20년 동안 정보와 프로세스를 디지털화하기 위한 노력들은 주로 관계형 데이터베이스에 계속해서 더 많은 데이터를 축적하는 데 초점을 맞췄습니다. 이 방식은 전통적인 분석 기계 학습 알고리즘들이 데이터를 처리하고 이해하는 데 도움이 됩니다.\n\n그러나 구조화된 방식으로 점점 더 많은 데이터를 저장하는 데 쏟아지는 지속적인 노력에도 불구하고, 우리는 여전히 우리의 지식 전체를 포착하고 처리하는 데 한계를 겪고 있습니다.\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-AllYouNeedtoKnowtoBuildYourFirstLLMApp_2.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nGPT3.5의 개발과 발전은 우리에게 다양한 데이터셋을 효과적으로 해석하고 분석할 수 있는 엄청난 성과를 나타내는 중요한 이정표입니다. 요즘엔 텍스트, 이미지, 오디오 파일 등 다양한 형식의 콘텐츠를 이해하고 생성할 수 있는 모델들이 있죠.\n\n# 파인 튜닝 vs. 컨텍스트 주입\n\n일반적으로, 대형 언어 모델이 모르는 질문에 대답할 수 있도록 하는 두 가지 근본적으로 다른 접근 방식이 있습니다: 모델 파인 튜닝 및 컨텍스트 주입\n\n## 파인 튜닝\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n세밀 조정은 기존 언어 모델을 추가 데이터로 훈련하여 특정 작업에 최적화하는 것을 의미합니다.\n\n처음부터 언어 모델을 훈련시키는 대신 BERT 또는 LLama와 같은 사전 훈련된 모델을 사용하고, 그런 다음 사용 사례별 훈련 데이터를 추가하여 특정 작업의 요구 사항에 맞게 조정합니다.\n\n스탠포드 대학교 팀은 LLM Llama를 사용했고 사용자/모델 상호 작용이 어떻게 보일 수 있는지에 대한 50,000개의 예제를 사용하여 세밀 조정했습니다. 결과는 사용자와 상호 작용하고 쿼리에 응답하는 챗봇이 되었습니다. 이 세밀 조정 단계는 모델이 최종 사용자와 상호 작용하는 방식을 변경했습니다.\n\n→ 세밀 조정에 대한 오해\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nPLLMs(Pre-trained Language Models)의 세밀 조정은 특정 작업에 모델을 맞추는 방법이지만, 모델에 자체 도메인 지식을 주입할 수는 없습니다. 이는 모델이 이미 방대한 양의 일반 언어 데이터로 교육되었으며, 특정 도메인 데이터는 대부분 이미 학습한 내용을 덮어쓸 정도로 충분하지 않기 때문입니다.\n\n따라서 모델을 세밀 조정할 때 가끔 올바른 답변을 제공할 수 있지만, 사전 훈련 중 학습한 정보에 크게 의존하기 때문에 종종 실패할 수 있습니다. 이 정보들이 특정 작업에 정확하거나 관련성 있는지 여부가 제대로 반영되어 있지 않을 수도 있기 때문입니다. 다시 말해, 세밀 조정은 모델이 어떻게 의사소통하는 방식에 적응하는 데 도움이 되지만, 그것이 무엇을 의사소통하는지에 대해서는 그렇지 않을 수도 있습니다. (Porsche AG, 2023)\n\n이것이 맥락 주입이 중요한 이유입니다.\n\n## 맥락 중심 학습 / 맥락 주입\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n컨텍스트 주입을 사용할 때, 우리는 LLM을 수정하지 않고 프롬프트 자체에 주제와 관련된 컨텍스트를 주입하는 데 집중합니다.\n\n따라서 우리는 어떻게 적절한 정보를 포함시킬지에 대해 고려해야 합니다. 아래 그림에서 전체적으로 어떻게 작동하는지에 대해 간략히 볼 수 있습니다. 우리는 가장 관련 있는 데이터를 식별할 수 있는 프로세스가 필요합니다. 이를 위해 컴퓨터가 텍스트 조각끼리 비교할 수 있도록 하는 것이 필요합니다.\n\n이 작업은 임베딩을 통해 수행될 수 있습니다. 임베딩을 사용하면 텍스트를 벡터로 변환하여 텍스트를 다차원 임베딩 공간에서 나타낼 수 있습니다. 공간에서 서로 가까운 점들은 종종 동일한 문맥에서 사용됩니다. 이 유사성 검색이 영원히 걸리지 않도록하기 위해 벡터를 벡터 데이터베이스에 저장하고 인덱싱합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 기사의 목적은 우리 자신의 텍스트와 문서를 분석할 수 있는 간단한 솔루션을 만들고, 이를 통해 획득한 통찰을 사용하여 해결책이 사용자에게 돌아가도록 하는 과정을 보여주는 것입니다. 종단간 솔루션을 구현하는 데 필요한 모든 단계와 구성 요소를 설명하겠습니다.\n\n그렇다면 LLMs의 기능을 어떻게 활용하여 우리의 요구를 충족시킬 수 있을까요? 한 단계씩 살펴보겠습니다.\n\n## 단계별 자습서 - 여러분의 첫 번째 LLM 앱\n\n이어지는 내용에서는 LLMs를 활용하여 우리의 개인 데이터에 대한 질문에 대답하는 데 사용하려고 합니다. 이를 위해 우리의 개인 데이터 내용을 벡터 데이터베이스로 전송하여 시작하겠습니다. 이 단계는 텍스트 내에서 관련 섹션을 효율적으로 찾을 수 있도록 함으로써 중요합니다. 우리는 이 데이터와 LLMs의 기능을 사용하여 텍스트를 해석하고 사용자의 질문에 답변할 것입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리는 챗봇이 제공한 데이터를 기반으로 한 질문에만 답변하도록 안내할 수도 있습니다. 이렇게 함으로써 챗봇이 주어진 데이터에 집중하고 정확하고 관련성 있는 응답을 제공할 수 있도록 할 수 있어요.\n\n우리의 사용 사례를 구현하기 위해 LangChain에 많이 의존할 것입니다.\n\n# LangChain이란?\n\n\"LangChain은 언어 모델을 기반으로 한 애플리케이션을 개발하기 위한 프레임워크입니다.\" (Langchain, 2023)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n따라서, LangChain은 채팅봇, 요약 도구 및 기본적으로 LangChain의 강점을 활용하여 작성하고자 하는 도구와 같은 다양한 LLM 애플리케이션의 생성을 지원하기 위해 설계된 Python 프레임워크입니다. 이 라이브러리는 필요한 다양한 구성 요소를 결합합니다. 이러한 구성 요소를 이른바 \"체인\"이라고 불리는 것으로 연결할 수 있습니다.\n\nLangChain의 가장 중요한 모듈은 다음과 같습니다 (Langchain, 2023):\n\n- Models: 다양한 모델 유형에 대한 인터페이스\n- Prompts: 프롬프트 관리, 프롬프트 최적화 및 프롬프트 직렬화\n- Indexes: 문서 로더, 텍스트 분할기, 벡터 저장소 - 데이터에 빠르고 효율적으로 액세스 가능하게 함\n- Chains: 체인은 단일 LLM 호출을 넘어서 호출 시퀀스를 설정할 수 있게 합니다\n\n아래 이미지에서는 이러한 구성 요소들이 어떻게 작용하는지 확인할 수 있습니다. 문서 로더 및 텍스트 분할기를 사용하여 우리만의 비구조화된 데이터를로드하고 처리합니다. 프롬프트 모듈을 사용하여 발견된 콘텐츠를 프롬프트 템플릿에 삽입하고 마지막으로 모델 모듈을 사용하여 프롬프트를 모델로 전송합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![이미지](/TIL/assets/img/2024-07-14-AllYouNeedtoKnowtoBuildYourFirstLLMApp_4.png)\n\n5. 에이전트: 에이전트는 LLM을 사용하여 어떤 조치를 취할지 결정하는 개체입니다. 조치를 취한 후에는 그 조치의 결과를 관찰하고 그 작업이 완료될 때까지 이 과정을 반복합니다.\n\n![이미지](/TIL/assets/img/2024-07-14-AllYouNeedtoKnowtoBuildYourFirstLLMApp_5.png)\n\n우리는 문서를 로드하고 분석하며 효율적으로 검색할 수 있도록 만들기 위해 첫 번째 단계에서 Langchain을 사용합니다. 텍스트를 색인화한 후에는 사용자의 질문에 대답하기 위해 관련 텍스트 조각을 인식하는 것이 훨씬 더 효율적이어야 합니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리 간단한 응용 프로그램에 필요한 것은 물론 LLM입니다. 우리는 OpenAI API를 통해 GPT3.5를 사용할 것입니다. 그런 다음 LLM에 우리 자신의 데이터를 공급할 수 있게 해주는 벡터 저장소가 필요합니다. 그리고 각 쿼리마다 다른 작업을 수행하려면 각 쿼리에 대해 무엇이 발생해야 하는지 결정하는 에이전트가 필요합니다.\n\n우리가 시작해 보죠. 먼저 우리 자신의 문서를 가져와야 합니다.\n\n다음 섹션에서는 LangChain의 Loader Module에 포함된 모듈에 대해 설명하여 다른 출처에서 다양한 유형의 문서를 로드하는 방법을 설명합니다.\n\n# 1. LangChain을 사용하여 문서 로드하기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nLangChain은 다양한 소스에서 문서를 로드할 수 있습니다. LangChain 문서에서 가능한 문서 로더 목록을 찾을 수 있습니다. 그중에는 HTML 페이지, S3 버킷, PDF, Notion, Google 드라이브 등의 로더가 포함되어 있습니다.\n\n간단한 예제에서는 GPT3.5의 훈련 데이터에 포함되지 않은 데이터를 사용합니다. GPT4에 관한 위키피디아 문서를 사용하겠습니다. GPT3.5가 GPT4에 대해 제한된 지식을 가지고 있을 것으로 가정합니다.\n\n이 간단한 예제에서 LangChain 로더 중 하나를 사용하지 않고, BeautifulSoup을 사용하여 위키피디아에서 텍스트를 직접 가져오겠습니다.\n\n```js\nimport requests\nfrom bs4 import BeautifulSoup\n\nurl = \"https://en.wikipedia.org/wiki/GPT-4\"\nresponse = requests.get(url)\n\nsoup = BeautifulSoup(response.content, 'html.parser')\n\n# 페이지의 모든 텍스트 찾기\ntext = soup.get_text()\n\n# 콘텐츠 div 찾기\ncontent_div = soup.find('div', {'class': 'mw-parser-output'})\n\n# div에서 원치 않는 요소 제거\nunwanted_tags = ['sup', 'span', 'table', 'ul', 'ol']\nfor tag in unwanted_tags:\n    for match in content_div.findAll(tag):\n        match.extract()\n\nprint(content_div.get_text())\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/TIL/assets/img/2024-07-14-AllYouNeedtoKnowtoBuildYourFirstLLMApp_6.png)\n\n## 2. 문서를 텍스트 조각으로 분할하기\n\n다음으로, 우리는 텍스트를 텍스트 청크라 불리는 작은 섹션으로 나눠야 합니다. 각 텍스트 청크는 임베딩 공간에서 데이터 포인트를 나타내며, 컴퓨터가 이러한 청크들 간의 유사성을 결정할 수 있게 합니다.\n\n다음 텍스트 스니펫은 langchain의 텍스트 분할 모듈을 활용하고 있습니다. 특정 사례에서는 크기가 100이고 오버랩이 20인 청크를 지정하고 있습니다. 일반적으로 더 큰 텍스트 청크를 사용하는 것이 흔하지만, 사용 사례에 최적화된 크기를 찾기 위해 조금 실험할 수 있습니다. 단, 각 LLM에는 토큰 제한이 있다는 것을 기억해야 합니다 (GPT 3.5의 경우 4000 토큰). 우리는 텍스트 블록을 프롬프트에 삽입하고 있기 때문에 전체 프롬프트가 4000 토큰 이하인지 확인해야 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```javascript\nfrom langchain.text_splitter import RecursiveCharacterTextSplitter\n\n\narticle_text = content_div.get_text()\n\n\ntext_splitter = RecursiveCharacterTextSplitter(\n    # 매우 작은 청크 크기로 설정하여 표시합니다.\n    chunk_size = 100,\n    chunk_overlap  = 20,\n    length_function = len,\n)\n\n\ntexts = text_splitter.create_documents([article_text])\nprint(texts[0])\nprint(texts[1])\n```\n\n![이미지](/TIL/assets/img/2024-07-14-AllYouNeedtoKnowtoBuildYourFirstLLMApp_7.png)\n\n전체 텍스트가 다음과 같이 분할됩니다:\n\n![이미지](/TIL/assets/img/2024-07-14-AllYouNeedtoKnowtoBuildYourFirstLLMApp_8.png)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 3. 텍스트 청크에서 임베딩으로\n\n이제 텍스트 구성 요소를 알고리즘과 비교할 수 있도록 이해하기 쉽고 비교할 수 있는 형태로 바꿔야 합니다. 우리는 인간의 언어를 비트와 바이트로 나타내는 디지털 형태로 변환할 방법을 찾아야 합니다.\n\n이 그림은 대부분의 사람에게 명백해 보일 수 있는 간단한 예를 제시합니다. 그러나 우리는 컴퓨터가 \"찰스\"라는 이름이 여성이 아닌 남성과 관련되어 있음을 이해할 수 있는 방법을 찾아야 하며, 찰스가 남자이면 왕이고 여왕이 아님을 학습시켜야 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지난 몇 년 동안 새로운 방법과 모델이 등장했는데, 그 방법이 바로 이겁니다. 우리가 원하는 것은 단어의 의미를 n차원 공간으로 변환하여 텍스트 청크를 서로 비교하고 유사성을 측정할 수 있는 방법입니다. 임베딩 모델은 일반적으로 단어가 사용되는 문맥을 분석함으로써 정확히 이를 학습하려고 노력합니다. 차, 커피, 아침이 종종 동일한 문맥에서 사용되기 때문에 이러한 단어들은 예를 들어 차와 콩보다 n차원 공간에서 서로 더 가깝습니다. 차와 콩은 발음은 비슷하지만 함께 사용되는 경우가 거의 없습니다. 임베딩 모델은 각 단어에 대한 벡터를 제공해주어 임베딩 공간에서 단어를 나타낼 수 있습니다. 마지막으로, 벡터를 사용하여 단어 사이의 유사성을 계산하는 등의 수학적 계산을 수행할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](/TIL/assets/img/2024-07-14-AllYouNeedtoKnowtoBuildYourFirstLLMApp_11.png)\n\n텍스트를 임베딩으로 변환하는 방법에는 Word2Vec, GloVe, fastText 또는 ELMo 등 여러 가지가 있습니다.\n\n임베딩 모델\n\n단어 간 유사성을 포착하기 위해 Word2Vec은 간단한 신경망을 사용합니다. 우리는 이 모델을 대량의 텍스트 데이터로 훈련시키고 각 단어에 n차원 임베딩 공간에서 점을 할당하고 따라서 단어의 의미를 벡터 형식으로 설명할 수 있는 모델을 만들고자 합니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n훈련 과정에서 우리는 데이터 세트의 각 고유한 단어에 입력 레이어의 뉴런을 할당합니다. 아래 이미지에서 간단한 예시를 확인할 수 있어요. 이 경우, 은닉 레이어에는 두 개의 뉴런만이 포함되어 있습니다. 두 개인 이유는 단어를 2차원 임베딩 공간에 매핑하려고 하기 때문이에요. (실제로 기존 모델은 훨씬 더 크며, 단어를 더 높은 차원 공간에 표현합니다. - 예를 들어, OpenAI의 Ada 임베딩 모델은 1536 차원을 사용합니다.) 훈련 과정 후 개별 가중치는 임베딩 공간에서의 위치를 나타냅니다.\n\n이 예시에서는 데이터 세트가 \"Google is a tech company.\"라는 단일 문장으로 구성되어 있습니다. 문장의 각 단어는 신경망(NN)의 입력으로 작용합니다. 결과적으로 우리 네트워크는 다섯 개의 입력 뉴런을 갖게 됩니다.\n\n훈련 과정에서 각 입력 단어의 다음 단어를 예측하는 데 초점을 맞춥니다. 문장의 시작에서 시작할 때, \"Google\"이라는 단어에 해당하는 입력 뉴런은 값 1을 받고, 나머지 뉴런은 값 0을 받습니다. 이 특정 시나리오에서 네트워크를 \"is\" 단어를 예측할 수 있도록 훈련하는 것이 목표입니다. \n\n![image](/TIL/assets/img/2024-07-14-AllYouNeedtoKnowtoBuildYourFirstLLMApp_12.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n실제로 임베딩 모델을 학습하는 여러 가지 방법이 있습니다. 각각은 학습 과정 중 출력을 예측하는 독특한 방식을 가지고 있어요. 두 가지 흔히 사용되는 방법은 CBOW(Continuous Bag of Words)와 Skip-gram입니다.\n\nCBOW에서는 주변 단어를 입력으로 삼아 중심 단어를 예측하려고 합니다. 반대로 Skip-gram에서는 중심 단어를 입력으로 삼아 좌우에 등장하는 단어를 예측하려고 합니다. 하지만 이러한 방법들의 복잡한 부분에 대해서는 자세히 다루지 않겠어요. 이러한 방식들은 단어들 사이의 관계를 잡아내는 표현인 임베딩을 제공해줍니다. 이를 통해 방대한 양의 텍스트 데이터의 맥락을 분석합니다.\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-AllYouNeedtoKnowtoBuildYourFirstLLMApp_13.png\" /\u003e\n\n더 많은 임베딩 정보를 원한다면 인터넷에 다양한 정보가 많이 있어요. 그러나 시각적이고 단계별 안내를 선호한다면 Josh Starmer의 StatQuest 영상인 'Word Embedding and Word2Vec'을 시청하면 도움이 될 수 있어요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n모델 삽입으로 돌아가기\n\n간단한 예제를 사용하여 설명한 것이 2차원 임베딩 공간에서 적용되는 것 뿐만 아니라 더 큰 모델에도 적용됩니다. 예를 들어, 표준 Word2Vec 벡터는 300차원이고, OpenAI의 Ada 모델은 1536차원을 가지고 있습니다. 이러한 사전 훈련된 벡터는 단어간의 관계와 의미를 정밀하게 포착하여 계산을 수행할 수 있도록 합니다. 예를 들어, 이러한 벡터를 사용하여 France + Berlin - Germany = Paris, 또는 faster + warm - fast = warmer와 같은 결과를 얻을 수 있습니다. (Tazzyman, n.d.)\n\n![이미지](/TIL/assets/img/2024-07-14-AllYouNeedtoKnowtoBuildYourFirstLLMApp_14.png)\n\n다음에서는 OpenAI API를 사용하여 OpenAI의 LLM뿐만 아니라 임베딩 모델도 활용하려고 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n참고: Embedding 모델과 LLM의 차이점은 Embedding 모델이 단어나 구절의 의미와 관련성을 포착하기 위해 벡터 표현을 생성하는 데 중점을 두는 반면, LLM은 제공된 프롬프트나 쿼리를 기반으로 일관성 있고 맥락에 부합하는 텍스트를 생성하도록 훈련된 다목적 모델입니다.\n\nOpenAI Embedding 모델\n\nOpenAI의 다양한 LLM과 마찬가지로, Ada, Davinci, Curie 및 Babbage와 같은 다양한 임베딩 모델 중에서 선택할 수 있습니다. 이 중 Ada-002는 현재 가장 빠르고 비용 효율적인 모델이며, Davinci는 일반적으로 가장 높은 정확도와 성능을 제공합니다. 그러나 사용 사례에 가장 적합한 모델을 찾으려면 직접 시도해보세요. OpenAI Embedding에 대해 자세히 이해하고 싶다면 OpenAI 문서를 참조할 수 있습니다.\n\nEmbedding 모델에 대한 우리의 목표는 텍스트 청크를 벡터로 변환하는 것입니다. 두 번째 세대의 Ada의 경우, 이러한 벡터는 1536개의 출력 차원을 갖고 있어서 1536차원 공간 내에서 특정 위치나 방향을 나타냅니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nOpenAI에서는 이 임베딩 벡터를 다음과 같이 설명합니다:\n\n“숫자적으로 유사한 임베딩은 의미적으로도 유사합니다. 예를 들어, \"canine companions say\"의 임베딩 벡터와 \"woof\"의 임베딩 벡터는 \"meow\"보다 더 유사할 것입니다.\" (OpenAI, 2022)\n\n한 번 시도해 보겠습니다. 우리는 OpenAI의 API를 사용하여 텍스트 스니펫을 임베딩으로 변환합니다.\n\n```js\nimport openai\n\n\nprint(texts[0])\n\n\nembedding = openai.Embedding.create(\n    input=texts[0].page_content, model=\"text-embedding-ada-002\"\n)[\"data\"][0][\"embedding\"]\n\n\nlen(embedding)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![Image](/TIL/assets/img/2024-07-14-AllYouNeedtoKnowtoBuildYourFirstLLMApp_15.png)\n\n우리는 \"2023 텍스트 생성 언어 모델\"이라는 첫 번째 텍스트 청크를 1536 차원의 벡터로 변환합니다. 각 텍스트 청크에 대해 이 작업을 수행함으로써, 우리는 1536 차원의 공간에서 어떤 텍스트 청크가 서로에게 더 가깝고 유사한지 관찰할 수 있습니다.\n\n한번 해보세요. 우리는 사용자의 질문을 텍스트 청크와 비교하기 위해 질문에 대한 임베딩을 생성한 다음, 이를 공간 내의 다른 데이터 포인트와 비교합니다.\n\n![Image](/TIL/assets/img/2024-07-14-AllYouNeedtoKnowtoBuildYourFirstLLMApp_16.png)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n텍스트 청크와 사용자 질문을 벡터로 표현하면, 다양한 수학적 가능성을 탐색할 수 있어요. 두 데이터 포인트 간 유사성을 결정하려면, 다차원 공간에서 이들의 근접성을 계산해야 합니다. 이는 거리 측정 방법을 사용하여 달성됩니다. 점들 사이의 거리를 계산하기 위해 사용할 수 있는 여러 가지 방법이 있어요. Maarten Grootendorst는 그의 Medium 포스팅 중 하나에서 이들 중 아홉 가지를 요약해뒀어요.\n\n일반적으로 사용되는 거리 측정 방법 중 하나는 코사인 유사도에요. 그러니 사용자의 질문과 텍스트 청크 사이의 코사인 유사도를 계산해보겠습니다:\n\n```js\nimport numpy as np\nfrom numpy.linalg import norm\nfrom langchain.text_splitter import RecursiveCharacterTextSplitter\nimport requests\nfrom bs4 import BeautifulSoup\nimport pandas as pd\nimport openai\n\n####################################################################\n# 문서 불러오기\n####################################################################\n# 스크랩할 위키피디아 페이지 URL\nurl = 'https://en.wikipedia.org/wiki/Prime_Minister_of_the_United_Kingdom'\n\n# URL로 GET 요청 보내기\nresponse = requests.get(url)\n\n# BeautifulSoup을 사용하여 HTML 내용 파싱\nsoup = BeautifulSoup(response.content, 'html.parser')\n\n# 페이지의 모든 텍스트 찾기\ntext = soup.get_text()\n\n####################################################################\n# 텍스트 분할\n####################################################################\ntext_splitter = RecursiveCharacterTextSplitter(\n    # 아주 작은 청크 크기 설정, 예시용\n    chunk_size = 100,\n    chunk_overlap  = 20,\n    length_function = len,\n)\n\ntexts = text_splitter.create_documents([text])\n\n####################################################################\n# 임베딩 계산\n####################################################################\n# 새로운 리스트에 모든 텍스트 청크 추가\ntext_chunks=[]\n\nfor text in texts:\n    text_chunks.append(text.page_content)\n\ndf = pd.DataFrame({'text_chunks': text_chunks})\n\n####################################################################\n# 텍스트 임베딩 얻기\n####################################################################\ndef get_embedding(text, model=\"text-embedding-ada-002\"):\n   text = text.replace(\"\\n\", \" \")\n   return openai.Embedding.create(input = [text], model=model)['data'][0]['embedding']\n\ndf['ada_embedding'] = df.text_chunks.apply(lambda x: get_embedding(x, model='text-embedding-ada-002'))\n\n####################################################################\n# 사용자 질문에 대한 임베딩 계산\n####################################################################\nusers_question = \"What is GPT-4?\"\n\nquestion_embedding = get_embedding(text=users_question, model=\"text-embedding-ada-002\")\n\n# 계산된 코사인 유사도를 저장할 리스트 생성\ncos_sim = []\n\nfor index, row in df.iterrows():\n   A = row.ada_embedding\n   B = question_embedding\n\n   # 코사인 유사도 계산\n   cosine = np.dot(A,B)/(norm(A)*norm(B))\n\n   cos_sim.append(cosine)\n\ndf[\"cos_sim\"] = cos_sim\ndf.sort_values(by=[\"cos_sim\"], ascending=False)\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-AllYouNeedtoKnowtoBuildYourFirstLLMApp_17.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 우리는 질문에 답변하기 위해 LLM에 제공할 텍스트 청크의 수를 선택할 수 있는 옵션이 있습니다.\n\n다음 단계는 사용하고 싶은 LLM을 결정하는 것입니다.\n\n# 4. 사용할 모델 정의하기\n\nLangchain은 OpenAI의 GPT 및 Huggingface를 포함한 다양한 모델 및 통합을 제공합니다. 우리가 OpenAI의 GPT를 Large Language Model로 사용하기로 결정하면, 첫 번째 단계는 API 키를 정의하는 것입니다. 현재 OpenAI는 일정량의 무료 사용 용량을 제공하지만, 한 달에 일정 토큰 수를 초과하면 유료 계정으로 전환해야 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 우리가 GPT를 사용하여 Google을 사용하는 방식과 유사한 짧은 질문에 답하는 데 사용한다면, 비용이 비교적 낮게 유지됩니다. 그러나 개인 데이터와 같이 방대한 맥락을 제공해야 하는 질문에 GPT를 사용한다면, 쿼리가 빠르게 수천 개의 토큰으로 늘어날 수 있습니다. 이로 인해 비용이 상당히 증가합니다. 하지만 걱정하지 마세요, 비용 한도를 설정할 수 있습니다.\n\n토큰이란 무엇인가요?\n\n더 간단히 말하면, 토큰은 기본적으로 단어나 단어 그룹입니다. 그러나 영어에서는 동사 시제, 복수형 또는 복합 단어와 같이 단어가 각기 다른 형태를 가질 수 있습니다. 이를 처리하기 위해 우리는 하위 단어 토크나이제이션을 사용할 수 있으며, 이는 단어를 뿌리, 접두사, 접미사 및 다른 언어적 요소와 같은 작은 부분으로 나누는 것을 의미합니다. 예를 들어, \"tiresome\"이라는 단어는 \"tire\"와 \"some\"으로 분할될 수 있으며, \"tired\"는 \"tire\"와 \"d.\"로 나눌 수 있습니다. 이렇게 함으로써, 우리는 \"tiresome\"과 \"tired\"가 동일한 뿌리를 공유하고 유사한 유도를 가졌음을 인식할 수 있습니다. (Wang, 2023)\n\nOpenAI는 토큰화기를 제공하여 어떤 것이 토큰으로 간주되는지 감을 잡을 수 있습니다. OpenAI에 따르면, 일반 영어 텍스트에 대한 하나의 토큰은 일반적으로 ~4개의 문자에 해당합니다. 이는 대략 ¾ 단어에 해당합니다 (따라서 100개의 토큰은 약 75단어와 동일합니다). OpenAI의 웹사이트에서 토큰화 앱을 찾아서 실제로 토큰으로 간주되는 것을 알아볼 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n오픈AI에서 사용자 계정에서 API 키를 찾을 수 있어요. 가장 간단한 방법은 구글에서 \"OpenAI API 키\"로 검색하는 것이에요. 이렇게 하면 새 키를 생성할 수 있는 설정 페이지로 바로 이동해요.\n\n파이썬에서 사용하려면, 키를 \"OPENAI_API_KEY\"라는 새 환경 변수로 저장해야 해요:\n\n```python\nimport os\nos.environ[\"OPENAI_API_KEY\"] = \"testapikey213412\"\n```\n\n원하는 LLM을 선택한 후에는 몇 가지 매개변수를 미리 설정할 수 있어요. 오픈AI 플레이그라운드에서는 다양한 매개변수를 조정해보고 원하는 설정을 결정하기 전에 여러 가지로 놀 수 있는 기회가 주어져요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nPlayground WebUI의 오른쪽에는 오픈AI에서 제공하는 여러 매개변수가 있습니다. 이 매개변수들을 사용하여 LLM의 출력에 영향을 미칠 수 있습니다. 살펴볼 가치 있는 두 가지 매개변수는 모델 선택과 온도입니다.\n\n다양한 다른 모델 중에서 선택할 수 있습니다. Text-davinci-003 모델은 현재 가장 크고 강력합니다. 반면에 Text-ada-001과 같은 모델은 더 작고 빠르며 비용 효율적입니다.\n\n아래는 OpenAI의 가격표 요약을 볼 수 있습니다. 에이다는 가장 강력한 다빈치 모델보다 싸며 성능이 충분하다면 비용을 절약하고 더 빠른 응답 시간을 달성할 수 있습니다.\n\n먼저 다빈치를 사용하여 시작하고, 에이다로도 충분한 결과를 얻을 수 있는지 평가할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자, Jupyter Notebook에서 시도해봅시다. 우리는 langchain을 사용하여 GPT에 연결하고 있어요.\n\n```js\nfrom langchain.llms import OpenAI\n\nllm = OpenAI(temperature=0.7)\n```\n\n만약 모든 속성을 포함한 리스트를 보고 싶다면 __dict__를 사용해주세요:\n\n```js\nllm.__dict__\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![Image 1](/TIL/assets/img/2024-07-14-AllYouNeedtoKnowtoBuildYourFirstLLMApp_18.png)\n\n만약 특정 모델을 지정하지 않으면, langchain 커넥터는 기본적으로 \"text-davinci-003\"을 사용합니다.\n\n이제 Python에서 모델을 직접 호출할 수 있습니다. 단순히 llm 함수를 호출하고 입력으로 프롬프트를 제공하면 됩니다.\n\n![Image 2](/TIL/assets/img/2024-07-14-AllYouNeedtoKnowtoBuildYourFirstLLMApp_19.png)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n일반적인 인류 지식에 대해 GPT에게 물어볼 수 있습니다.\n\n![image](/TIL/assets/img/2024-07-14-AllYouNeedtoKnowtoBuildYourFirstLLMApp_20.png)\n\nGPT는 훈련 데이터에 포함되지 않은 주제에 대해서는 제한된 정보만 제공할 수 있습니다. 이는 공개적으로 이용할 수 없는 구체적인 세부 사항이나 훈련 데이터가 마지막으로 업데이트된 후 발생한 사건을 포함합니다.\n\n![image](/TIL/assets/img/2024-07-14-AllYouNeedtoKnowtoBuildYourFirstLLMApp_21.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러면 모델이 최신 이슈에 대한 질문에 대답할 수 있도록 어떻게 할 수 있을까요?\n\n이전에 언급했던 것처럼 이를 수행할 수 있는 방법이 있습니다. 우리는 모델에 필요한 정보를 prompt 안에 주입해주어야 합니다.\n\n영국의 현 장권자에 대한 질문에 답하기 위해, \"영국 총리 목록\" 위키피디아 문서에서 정보를 prompt에 넣어줍니다. 이 과정을 요약하면 다음과 같습니다:\n\n- 문서를 불러옵니다\n- 텍스트를 텍스트 청크로 분할합니다\n- 텍스트 청크에 대한 임베딩을 계산합니다\n- 모든 텍스트 청크와 사용자의 질문 사이의 유사성을 계산합니다\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport requests\nfrom bs4 import BeautifulSoup\nfrom langchain.text_splitter import RecursiveCharacterTextSplitter\nimport numpy as np\nfrom numpy.linalg import norm\nimport pandas as pd\nimport openai\n\n####################################################################\n# 문서 로드\n####################################################################\n# 스크레이핑할 위키피디아 페이지 URL\nurl = 'https://en.wikipedia.org/wiki/Prime_Minister_of_the_United_Kingdom'\n\n# URL로 GET 요청 보내기\nresponse = requests.get(url)\n\n# BeautifulSoup을 사용하여 HTML 컨텐츠 파싱\nsoup = BeautifulSoup(response.content, 'html.parser')\n\n# 페이지의 모든 텍스트 찾기\ntext = soup.get_text()\n\n####################################################################\n# 텍스트 분할\n####################################################################\ntext_splitter = RecursiveCharacterTextSplitter(\n    # 아주 작은 청크 크기 설정(강조 용도)\n    chunk_size=100,\n    chunk_overlap=20,\n    length_function=len,\n)\n\ntexts = text_splitter.create_documents([text])\n\n####################################################################\n# 임베딩 계산\n####################################################################\n# 모든 텍스트 청크를 포함하는 새 리스트 생성\ntext_chunks = []\n\nfor text in texts:\n    text_chunks.append(text.page_content)\n\ndf = pd.DataFrame({'text_chunks': text_chunks})\n\n# text-embedding-ada 모델에서 임베딩 가져오기\ndef get_embedding(text, model=\"text-embedding-ada-002\"):\n    text = text.replace(\"\\n\", \" \")\n    return openai.Embedding.create(input=[text], model=model)['data'][0]['embedding']\n\ndf['ada_embedding'] = df.text_chunks.apply(lambda x: get_embedding(x, model='text-embedding-ada-002'))\n\n####################################################################\n# 사용자 질문과의 유사도 계산\n####################################################################\n# 사용자 질문에 대한 임베딩 계산\nusers_question = \"영국의 현 재 총리는 누구인가요?\"\nquestion_embedding = get_embedding(text=users_question, model=\"text-embedding-ada-002\")\r\n```\n\n이제 사용자 질문과 가장 유사한 텍스트 청크를 찾아보겠습니다:\n\n```js\r\nfrom langchain import PromptTemplate\nfrom langchain.llms import OpenAI\n\n# 사용자 질문에 대한 임베딩 계산\nusers_question = \"영국의 현 재 총리는 누구인가요?\"\nquestion_embedding = get_embedding(text=users_question, model=\"text-embedding-ada-002\")\n\n# 계산된 코사인 유사도를 저장할 리스트 생성\ncos_sim = []\n\nfor index, row in df.iterrows():\n    A = row.ada_embedding\n    B = question_embedding\n\n    # 코사인 유사도 계산\n    cosine = np.dot(A, B) / (norm(A) * norm(B))\n\n    cos_sim.append(cosine)\n\ndf[\"cos_sim\"] = cos_sim\ndf.sort_values(by=[\"cos_sim\"], ascending=False)\r\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-AllYouNeedtoKnowtoBuildYourFirstLLMApp_22.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n텍스트 조각들이 좀 어수선해 보이지만, 한번 시도해 보자면서 텍스트 세그먼트를 식별했구나.\n\n우리 모델이 질문에 대답할 수 있는 능력이 있는지 테스트해볼까? 이를 위해서는 모델에게 원하는 작업을 명확히 전달하는 방식으로 prompt를 구성해야 해.\n\n# 5. Prompt 템플릿 정의\n\n이제 우리가 찾고자 하는 정보가 포함된 텍스트 조각들이 있으니, prompt를 작성해야 해. prompt 내에서도 모델이 질문에 답변하도록 원하는 방식을 지정해야 해. 우리가 모드를 정의할 때는, LLM이 답변을 생성하는 원하는 동작 스타일을 명시하는 것이다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nLLM은 다양한 작업에 활용될 수 있으며, 가능한 여러 가지 예시를 살펴보겠습니다:\n\n- 요약: \"다음 텍스트를 임원들을 위해 3단락으로 요약해주세요: [TEXT]\"\n- 지식 추출: \"다음 기사를 기반으로, 사람들이 집을 구매하기 전에 고려해야 할 사항은 무엇인가요?\"\n- 콘텐츠 작성 (이메일, 메시지, 코드 등): \"프로젝트 문서에 대한 업데이트를 요청하는 이메일을 Jane에게 작성해주세요. 비공식적이고 친근한 톤을 사용해주세요.\"\n- 문법 및 스타일 개선: \"표준 영어로 수정하고 친근한 톤으로 변경해주세요: [TEXT]\"\n- 분류: \"각 메시지를 지원 티켓 유형으로 분류해주세요: [TEXT]\"\n\n이 예시를 통해, Wikipedia에서 데이터를 추출하고 사용자와 대화하는 것처럼 상호작용하는 솔루션을 구현하고 싶습니다. 이를 통해 원동력을 부여하고 도움을 주는 헬프 데스크 전문가처럼 질문에 답변하길 원합니다.\n\nLLM을 올바른 방향으로 안내하기 위해, 다음 지시사항을 프롬프트에 추가하겠습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 정보를 Markdown 형식으로 표로 변경하세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n해당 템플릿을 사용하여 우리의 프롬프트에 맥락과 사용자의 질문을 모두 통합하고 있습니다. 그 결과로 나온 응답은 다음과 같습니다:\n\n![이미지](/TIL/assets/img/2024-07-14-AllYouNeedtoKnowtoBuildYourFirstLLMApp_23.png)\n\n의왹으로, 심지어 이 간단한 구현으로도 어느 정도 만족스러운 결과물이 만들어졌습니다. 영국 총리들에 관해 시스템에 몇 가지 추가 질문을 해보도록 하겠습니다. 모든 것을 그대로 유지하고 사용자의 질문만 대체해 보겠습니다:\n\n```js\nusers_question = \"영국의 첫 번째 총리는 누구였나요?\"\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![Image](/TIL/assets/img/2024-07-14-AllYouNeedtoKnowtoBuildYourFirstLLMApp_24.png)\n\n기능은 일부 정상적으로 작동하는 것으로 보입니다. 그러나 저희의 목표는 이 느린 프로세스를 견고하고 효율적인 것으로 변환하는 것입니다. 이를 달성하기 위해 임베딩 및 인덱스를 벡터 저장소에 저장하는 인덱싱 단계를 도입합니다. 이를 통해 전체 성능을 향상시키고 응답 시간을 줄일 수 있습니다.\n\n## 6. 벡터 저장소 생성 (벡터 데이터베이스)\n\n벡터 저장소는 벡터로 표현할 수 있는 대량의 데이터를 저장하고 검색하는 데 최적화된 데이터 저장소 유형입니다. 이러한 유형의 데이터베이스는 유사성 측정이나 다른 수학적 연산과 같은 다양한 기준에 따라 데이터의 하위 집합을 효율적으로 질의하고 검색할 수 있습니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n텍스트 데이터를 벡터로 변환하는 것은 첫 번째 단계입니다. 그러나 우리의 요구 사항에 충분하지는 않습니다. 만약 우리가 벡터를 데이터 프레임에 저장하고 매번 쿼리를 받을 때마다 단어 간 유사성을 단계별로 확인하여 검색한다면, 전체 프로세스는 매우 느려질 것입니다.\n\n임베딩을 효율적으로 검색하기 위해서는 인덱싱이 필요합니다. 인덱싱은 벡터 데이터베이스의 두 번째 중요한 구성 요소입니다. 인덱스는 각 쿼리를 모든 문서 또는 항목과의 유사성을 계산할 필요 없이 가장 관련성 있는 문서나 항목에 매핑하는 방법을 제공합니다.\n\n최근 몇 년간 다양한 벡터 저장소가 출시되었습니다. 특히 LLMs 분야에서는 벡터 저장소에 대한 주목이 급증했습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 한 가지를 선택해서 우리의 사용 사례에 적용해 보겠습니다. 이전 섹션에서 한 것과 비슷하게, 우리는 다시 임베딩을 계산하고 벡터 저장소에 저장합니다. 이를 위해 LangChain과 chroma에서 적합한 모듈을 사용하고 있습니다.\n\n- 사용자의 질문에 답변하기 위해 사용할 데이터를 수집하세요:\n\n![이미지](/TIL/assets/img/2024-07-14-AllYouNeedtoKnowtoBuildYourFirstLLMApp_26.png)\n\n```python\nimport requests\nfrom bs4 import BeautifulSoup\nfrom langchain.embeddings.openai import OpenAIEmbeddings\nfrom langchain.text_splitter import CharacterTextSplitter\nfrom langchain.vectorstores import Chroma\nfrom langchain.document_loaders import TextLoader\n\n# 스크래핑할 위키피디아 페이지의 URL\nurl = 'https://en.wikipedia.org/wiki/Prime_Minister_of_the_United_Kingdom'\n\n# URL로 GET 요청 보내기\nresponse = requests.get(url)\n\n# BeautifulSoup을 사용하여 HTML 콘텐츠 파싱\nsoup = BeautifulSoup(response.content, 'html.parser')\n\n# 페이지에서 모든 텍스트 찾기\ntext = soup.get_text()\ntext = text.replace('\\n', '')\n\n# 쓰기 모드로 'output.txt'라는 새 파일 열고 파일 객체를 변수에 저장\nwith open('output.txt', 'w', encoding='utf-8') as file:\n    # 문자열을 파일에 작성\n    file.write(text)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2. 데이터를 로드하고 데이터를 텍스트 청크로 나누는 방법을 정의하세요.\n\n```js\nfrom langchain.text_splitter import RecursiveCharacterTextSplitter\n\n# 문서를 로드합니다.\nwith open('./output.txt', encoding='utf-8') as f:\n    text = f.read()\n\n# 텍스트 스플리터를 정의합니다.\ntext_splitter = RecursiveCharacterTextSplitter(    \n    chunk_size = 500,\n    chunk_overlap  = 100,\n    length_function = len,\n)\n\ntexts = text_splitter.create_documents([text])\n```\n\n3. 텍스트 청크에 대한 임베딩을 계산하고 벡터 저장소에 저장할 임베딩 모델을 정의하세요 (여기서는 Chroma를 사용합니다).\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 테이블 태그를 Markdown 형식으로 변환한 코드입니다.\n\n```css\n\u003cimg src=\"/TIL/assets/img/2024-07-14-AllYouNeedtoKnowtoBuildYourFirstLLMApp_28.png\" /\u003e\n\nfrom langchain.embeddings.openai import OpenAIEmbeddings\nfrom langchain.vectorstores import Chroma\n\n# 임베딩 모델 정의\nembeddings = OpenAIEmbeddings()\n\n# 텍스트 청크 및 임베딩 모델을 사용하여 벡터 스토어 채우기\ndb = Chroma.from_documents(texts, embeddings)\n\n4. 사용자 질문에 대한 임베딩 계산, 벡터 스토어에서 유사한 텍스트 청크 찾아서 사용하여 프롬프트 만들기\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-AllYouNeedtoKnowtoBuildYourFirstLLMApp_29.png\" /\u003e\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nfrom langchain.llms import OpenAI\nfrom langchain import PromptTemplate\n\nusers_question = \"영국의 현 재 총리는 누구입니까?\"\n\n# 우리의 벡터 저장소를 사용하여 유사한 텍스트 청크를 찾습니다\nresults = db.similarity_search(\n    query=user_question,\n    n_results=5\n)\n\n# 프롬프트 템플릿 정의\ntemplate = \"\"\"\n당신은 도움을 주는 채팅 봇입니다! 다음 컨텍스트 섹션을 고려하여 질문에 답하십시오.\n주어진 컨텍스트만 사용하세요. 확실하지 않은 경우와 답변이 문서에 명시적으로 기재되어\n있지 않은 경우 \"죄송합니다, 해당 내용을 도와드릴 방법을 모르겠어요\" 라고 말해주세요.\n\n컨텍스트 섹션:\n{context}\n\n질문:\n{users_question}\n\n답변:\n\"\"\"\n\nprompt = PromptTemplate(template=template, input_variables=[\"context\", \"users_question\"])\n\n# 프롬프트 템플릿 채우기\nprompt_text = prompt.format(context = results, users_question = users_question)\n\n# 정의된 LLM에 요청하기\nllm(prompt_text)\n```\n\n![이미지](/TIL/assets/img/2024-07-14-AllYouNeedtoKnowtoBuildYourFirstLLMApp_30.png)\n\n# 요약\n\nLLM이 데이터에 관한 질문을 분석하고 답변할 수 있도록 하려면 보통 모델을 세밀 조정하지 않습니다. 대신, 세밀 조정 과정에서의 목표는 모델의 특정 작업에 효과적으로 응답할 수 있는 능력을 향상시키는 것입니다. 새로운 정보를 가르치는 대신입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n알파카 7B의 경우, LLM (LLaMA)은 챗봇처럼 행동하고 상호작용하도록 세밀하게 조정되었습니다. 모델의 응답을 개선하는 데 초점을 맞추었으며 완전히 새로운 정보를 가르치는 데 중점을 두지는 않았습니다.\n\n따라서 우리 자체 데이터에 대한 질문에 답변할 수 있도록 Context Injection 접근 방식을 사용합니다. Context Injection을 사용한 LLM 앱을 만드는 것은 비교적 간단한 과정입니다. 주요 도전 과제는 데이터를 벡터 데이터베이스에 저장하도록 조직화하고 형식을 맞추는 것에 있습니다. 이 단계는 컨텍스트적으로 유사한 정보를 효율적으로 검색하고 신뢰할 수 있는 결과를 보장하는 데 중요합니다.\n\n이 기사의 목표는 임베딩 모델, 벡터 스토어 및 LLM을 사용하여 사용자 쿼리를 처리할 때의 미니멀리스트 접근 방식을 보여주는 것이었습니다. 이 기술들이 어떻게 함께 작동하여 계속 변화하는 사실에도 관련성 있고 정확한 답변을 제공할 수 있는지 보여줍니다.\n\n- 무료로 구독하여 새로운 이야기를 발행할 때 알림을 받으세요.\n- 한 달에 3개 이상의 무료 이야기를 읽고 싶으세요? — 월 5달러로 미디움 회원이 되세요. 가입할 때 제 추천 링크를 사용하면 저를 지원할 수 있습니다. 추가 비용은 없습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 참고 자료\n\nAssemblyAI (감독). (2022, 1월 5일). 단어 임베딩에 대한 완전한 개요. [YouTube 동영상 링크](https://www.youtube.com/watch?v=5MaWmXwxFNQ)\n\nGrootendorst, M. (2021, 12월 7일). 데이터 과학에서의 9가지 거리 측정 방법. Medium. [링크](https://towardsdatascience.com/9-distance-measures-in-data-science-918109d069fa)\n\nLangchain. (2023). LangChain에 오신 것을 환영합니다 - 🦜🔗 LangChain 0.0.189. [링크](https://python.langchain.com/en/latest/index.html)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNelson, P. (2023). Search and Unstructured Data Analytics Trends | Accenture. Search and Content Analytics Blog. [링크](https://www.accenture.com/us-en/blogs/search-and-content-analytics-blog/search-unstructured-data-analytics-trends)\n\nOpenAI. (2022). Introducing text and code embeddings. [링크](https://openai.com/blog/introducing-text-and-code-embeddings)\n\nOpenAI (Director). (2023, March 14). What can you do with GPT-4? [링크](https://www.youtube.com/watch?v=oc6RV5c1yd0)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nPorche AG. (2023, 5월 17일). ChatGPT 및 기업 지식: \"내 비즈니스 부문을 위한 챗봇을 어떻게 만들 수 있을까?\" #NextLevelGermanEngineering. [링크](https://medium.com/next-level-german-engineering/chatgpt-enterprise-knowledge-how-can-i-create-a-chatbot-for-my-business-unit-4380f7b3d4c0)\n\nTazzyman, S. (2023). 신경망 모델. NLP-Guidance. [링크](https://moj-analytical-services.github.io/NLP-guidance/NNmodels.html)\n\nWang, W. (2023, 4월 12일). 트랜스포머 기반 모델에 대한 심층적인 분석. Medium.","ogImage":{"url":"/TIL/assets/img/2024-07-14-AllYouNeedtoKnowtoBuildYourFirstLLMApp_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-AllYouNeedtoKnowtoBuildYourFirstLLMApp_0.png","tag":["Tech"],"readingTime":39},{"title":"장고에서 파이썬 데코레이터의 강력한 기능 알아보기","description":"","date":"2024-07-14 20:39","slug":"2024-07-14-ThePowerofDecoratorsinPythonDjango","content":"\n\n# TL;TR\n\n데코레이터는 파이썬에서 강력한 기능으로, 실제 코드를 변경하지 않고 함수 또는 메서드의 동작을 수정할 수 있게 해줍니다. Django에서는 인증, 권한 부여 및 요청 처리와 같은 반복적인 작업을 간소화하고 관리하기 위해 데코레이터가 널리 사용됩니다. 이 기사에서는 파이썬과 Django에서 데코레이터의 중요성을 탐색하고, 그들의 강력함을 강조하며 효과적인 사용을 위한 모베스트 프랙티스를 제공합니다.\n\n# 데코레이터의 기본\n\n파이썬에서 데코레이터는 다른 함수나 메서드를 감싸서 동작을 수정하는 함수입니다. @decorator_name 구문을 사용하여 함수 정의 위에 적용됩니다. 다음은 간단한 예시입니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\ndef my_decorator(func):\n    def wrapper():\n        print(\"함수 호출 전\")\n        func()\n        print(\"함수 호출 후\")\n    return wrapper\n\n@my_decorator\ndef say_hello():\n    print(\"안녕!\")\n\nsay_hello()\r\n```\n\nsay_hello가 호출되면 다음과 같이 출력됩니다:\n\n```python\n함수 호출 전\n안녕!\n함수 호출 후\n```\n\n# 장고에서의 데코레이터들\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n장고에서는 데코레이터가 뷰를 관리하고 공통 웹 개발 작업을 처리하는 데 중요한 역할을 합니다:\n\n## 인증 데코레이터\n\n- @login_required: 뷰에 접근하기 전에 사용자가 인증되었는지 확인합니다.\n\n```python\nfrom django.contrib.auth.decorators import login_required\n\n@login_required\ndef dashboard(request):\n    return HttpResponse(\"대시보드에 오신 것을 환영합니다!\")\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 허가 데코레이터\n\n- @permission_required: 사용자가 특정 권한을 갖고 있는지 확인합니다.\n\n```python\nfrom django.contrib.auth.decorators import permission_required\n\n@permission_required('app.view_dashboard')\ndef dashboard(request):\n    return HttpResponse(\"대시보드를 볼 수 있는 권한이 있습니다!\")\n```\n\n## 메서드 데코레이터\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- @require_http_methods: 뷰에 허용된 HTTP 메소드를 제한합니다.\n\n```js\nfrom django.views.decorators.http import require_http_methods\n\n@require_http_methods([\"GET\", \"POST\"])\ndef submit_form(request):\n    if request.method == 'POST':\n        return HttpResponse(\"Form submitted!\")\n    return HttpResponse(\"Submit the form.\")\n```\n\n# Django에서 사용자 정의 데코레이터\n\nDjango에서 사용자 정의 데코레이터를 생성하면 재사용 가능한 기능을 캡슐화할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예시: 뷰로의 접근 로깅\n\n```python\nimport logging\nfrom django.http import HttpResponse\n\nlogger = logging.getLogger(__name__)\n\ndef log_access(func):\n    def wrapper(request, *args, **kwargs):\n        logger.info(f\"뷰에 접근 중: {func.__name__}\")\n        return func(request, *args, **kwargs)\n    return wrapper\n\n@log_access\ndef dashboard(request):\n    return HttpResponse(\"대시보드입니다\")\n```\n\n# 데코레이터 사용시 권장 사항\n\n파이썬과 장고에서 데코레이터를 사용할 때, 유지보수 가능하고 효율적인 코드를 보장하기 위해 다음과 같은 권장 사항을 고려해보세요:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 1. 데코레이터를 간단하고 명확하게 유지해주세요\n\n데코레이터는 한 가지 일을 잘 하는 것이 중요합니다. 복잡한 로직을 피하고 데코레이터를 이해하기 쉽고 유지보수가능하도록 유지해주세요.\n\n## 2. 데코레이터를 명확하게 문서화해주세요\n\n사용자 정의 데코레이터에 대해 명확한 설명서를 제공하여 그 목적과 사용법을 설명해주세요. 이는 가독성과 유용성을 유지하는 데 중요합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 3. 가능한 경우 내장 데코레이터 사용하기\n\n인증 및 메소드 제한과 같은 일반 작업에 대해 Django의 내장 데코레이터를 활용하세요. 이들은 제대로 시험된 상태이며 유지관리가 잘 되어 있습니다.\n\n## 4. 적절하게 데코레이터를 스택해야 합니다\n\n여러 데코레이터를 사용할 때 의도하지 않은 동작을 피하기 위해 논리적인 순서로 스택하십시오. 예를 들어:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\n@login_required\n@require_http_methods([\"POST\"])\ndef secure_submit(request):\n    return HttpResponse(\"안전하게 제출된 양식!\")\n```\n\n## 5. Gracefully 처리되는 예외 핸들링\n\n데코레이터가 예외를 정상적으로 처리하고 의미 있는 오류 메시지 또는 대체 매커니즘을 제공하도록 확실히 합니다.\n\n## 6. 데코레이터 철저히 테스트하기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n커스텀 데코레이터에 대한 유닛 테스트를 작성하여 다양한 시나리오에서 예상대로 작동하는지 확인하세요.\n\n# 결론\n\n데코레이터는 Python 및 Django에서 강력한 도구로, 개발자들이 반복적인 작업을 추상화하여 더 깔끔하고 유지보수가 쉬운 코드를 작성할 수 있게 해줍니다. 이러한 데코레이터의 전체 잠재력을 활용하기 위해 개발자들은 그것을 간단하게 유지하고 철저히 문서화하며 내장 솔루션을 활용하는 등의 최상의 방법을 따라야 합니다.\n\n# 저를 따라오세요\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 내 랜딩 페이지\n- 내 Youtube 채널\n- 내 SaaS 서비스\n- 내 GitHub\n\n# 간단히 말해서 🚀\n\nIn Plain English 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 글쓴이를 클랩하고 팔로우 해 주세요 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문: CoFeed | Differ\n- PlainEnglish.io에서 더 많은 콘텐츠 확인하기","ogImage":{"url":"/TIL/assets/no-image.jpg"},"coverImage":"/TIL/assets/no-image.jpg","tag":["Tech"],"readingTime":7},{"title":"파이썬 데이터 분석을 위한 반드시 알아야 할 10가지 판다스 기술","description":"","date":"2024-07-14 20:38","slug":"2024-07-14-10Must-KnowPandasTechniquesforPythonDataAnalysis","content":"\n\n## 판다스(Pandas)로 파이썬 데이터 분석 능력을 향상시켜요\n\n안녕하세요! 오늘은 Pandas를 사용하여 데이터 분석 능력을 향상시키는 방법에 대해 알려 드릴게요!\n\n# 1. 빠른 데이터 가져오기 및 미리보기\n\n```python\nimport pandas as pd\n# \"data.csv\"라는 파일이 있다고 가정합니다\ndf = pd.read_csv('data.csv')\n# 첫 5개 행을 미리보기, 마치 미지를 드러내는 것처럼\nprint(df.head())\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 단계는 새 서점에 들어가서 목차를 훑는 것과 비슷합니다.\n\nDataFrame은 판다스의 핵심입니다. `read_csv`를 사용하면 CSV 파일을 테이블로 변환할 수 있고, `head()`를 사용하면 미리보기를 볼 수 있습니다.\n\n# 2. 데이터 정리: 누락된 값 처리\n\n```js\n# 누락된 값 확인\nprint(df.isnull().sum())\n# 누락된 값들을 해당 열의 평균값으로 채우기\ndf.fillna(df.mean(), inplace=True)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n데이터 정리는 먼지가 쌓인 보석을 닦는 것과 같아요. `isnull().sum()`은 먼지가 있는 곳을 보여주는데, `fillna`은 보석을 깨끗이 닦는 도구에요. 평균을 활용해서 닦습니다.\n\n# 3. 선택과 필터링: 정확한 대상 선정\n\n```js\n# 'Age' 열 선택\nage_column = df['Age']\n# 나이가 25보다 큰 행 필터링\nadults = df[df['Age'] \u003e 25]\n```\n\n슈퍼마켓 통로를 걷고 있는 것처럼 상상해봐요. `df[‘Age’]`은 라벨을 확인하는 것처럼, `df[df[‘Age’] \u003e 25]`는 기준을 충족하는 항목을 고르는 것과 같아요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 4. 탐색적 데이터 분석: 기술 통계\n\n```js\n# 개요를 위한 기술 통계\nprint(df.describe())\n```\n\n이것은 건강 진단과 같아요. 평균값, 최댓값 등을 보여줘서 데이터 상태를 알려줘요.\n\n# 5. 데이터 병합: 퍼즐 게임\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 가정: df2는 또 다른 DataFrame이라고 가정합니다.\nmerged_df = pd.concat([df, df2], axis=0)  # 수직으로 쌓기\nmerged_df = pd.merge(df, df2, on='공통_컬럼')  # 공통 열을 기준으로 조인\n\n```\n\n데이터 병합은 퍼즐 조각을 맞추는 것과 비슷합니다. `concat`은 쌓고, `merge`는 키 열을 기반으로 결합합니다.\n\n# 6. 그룹화: 패턴 찾기\n\n```js\n# 성별로 그룹화하여 평균 나이 계산\naverage_age_by_gender = df.groupby('성별')['나이'].mean()\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그룹화는 데이터 마이닝의 시작입니다. 비슷한 항목을 그룹화하고 그들의 평균 무게를 측정하는 것과 같아요. `groupby`는 분석에 깊이를 더해줍니다.\n\n## 7. 데이터 형태 변형: 큐브 회전\n\n```js\n# 다른 관점을 위해 데이터 전치\ndf_transposed = df.T\n# 유연한 분석을 위한 피벗 테이블\npivot_table = df.pivot_table(index='Gender', values='Age', aggfunc='mean')\n```\n\n데이터 형태 변형은 루빅 큐브를 돌리는 것과 같아요. `T`는 측면을 보여주고, `pivot_table`은 다차원 분석을 위한 사용자 정의 관점을 제공해줘요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 8. 조건부 필터링: 정밀 타겟팅\n\n```js\n# Filter rows where age is between 25 and 30 and city is 'New York'\nfiltered_df = df[(df['Age'] \u003e 25) \u0026 (df['Age'] \u003c 30) \u0026 (df['City'] == 'New York')]\n```\n\n조건부 필터링은 마치 목표를 정확하게 조준하는 것과 같아요. 논리 연산자 `\u0026` (그리고)와 `|` (또는)를 사용하여 필요한 데이터를 정밀하게 찾을 수 있어요.\n\n# 9. 데이터 정렬: 누가 선두일까요?\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 나이를 오름차순으로 정렬합니다\nsorted_df = df.sort_values(by='나이')\n# 혹은 내림차순으로 정렬할 수도 있습니다\nsorted_df_desc = df.sort_values(by='나이', ascending=False)\n```\n\n정렬은 마치 경쟁에서 순위 매기는 것과 같아요. `sort_values`는 지정된 열을 기준으로 데이터를 정렬해주는데, `ascending=False`는 가장 빠른 선수들을 보여줘요.\n\n# 10. 데이터 시각화: 즉각적인 통찰\n\n판다스로 직접 제공되지는 않지만, 맷플롯립이나 시본과 결합하면 데이터가 생동각을 불어넣어줄 수 있어요!\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\nimport matplotlib.pyplot as plt\n# 나이에 대한 히스토그램 그리기\ndf['Age'].hist()\nplt.title('나이 분포')\nplt.show()\n\n\n시각화는 데이터 분석의 하이라이트에요. 히스토그램, 산점도... `hist()` 함수를 사용하면 한눈에 나이 분포 패턴을 확인할 수 있어요. 제목을 추가하고 차트를 표시하면, 여러분의 이야기가 살아날 거예요!\n\n이 10가지 판다스 팁은 데이터 분석을 위한 10가지 마법 주문 같아요. 이를 마스터하면 데이터 바다를 탐험하며 더 많은 비밀을 발견할 수 있어요. 이제 파이썬을 실행하고 데이터를 춤추게 해보세요!\n\n최신 인공지능 이야기에 대한 소식을 받으려면 Substack에서 저희와 연락하세요.함께 인공지능의 미래를 만들어가요!\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저희와 함께 파이썬 이야기를 업데이트 받으려면 Substack에서 연락을 유지하세요. 함께 파이썬을 배워봐요!","ogImage":{"url":"/TIL/assets/no-image.jpg"},"coverImage":"/TIL/assets/no-image.jpg","tag":["Tech"],"readingTime":6},{"title":"알아두면 유용한 파이썬 프로그래밍 문법 10가지","description":"","date":"2024-07-14 20:37","slug":"2024-07-14-PeculiarPythonProgrammingSyntax","content":"\n\n## 프로그래밍 언어 배우기\n\n![Peculiar Python Programming Syntax](/TIL/assets/img/2024-07-14-PeculiarPythonProgrammingSyntax_0.png)\n\n만약 C++, Java 또는 Kotlin을 알고 있다면, Python을 배우는 것은 비교적 쉬울 것입니다. 그러나 Python에는 그 언어들에서는 만나지 못할 독특한 프로그래밍 규칙이 몇 가지 있습니다. 이를 공식적인 학습 없이 발견하기란 거의 불가능할 것입니다.\n\nPython의 이러한 특징에 익숙해지는 것은 유익하지만, 모두를 발견하려면 공식 Python 3 튜토리얼 (글쓴 시점에서 Python 3.12.3 사용중)을 살펴보는 것은 꽤 지루할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 프로세스를 편리하게 만들기 위해, C++, Java 또는 Kotlin을 배우며 접하지 못한 Python의 독특한 기능과 관용구 목록을 정리해왔어요. Python 프로그래밍의 독특한 측면을 이해하려는 누구에게나 이 개요가 도움이 되기를 바랍니다.\n\n이 목록이 모두를 포함하지 않을 수 있고, 다른 언어에도 몇 가지 기능이 존재할 수 있음을 주의해 주세요. Python에만 해당되는 것이 아닐 수 있는 누락 사항이나 사항에 대한 피드백을 환영합니다.\n\n# Python Repl 사용\n\n## 마지막으로 출력된 값 할당\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n인터랙티브 모드에서는 마지막으로 출력된 표현식이 변수 `_`에 할당됩니다. 이는 Python을 계산기로 사용할 때 계산을 계속하기가 다소 쉽다는 것을 의미합니다. 예를 들어:\n\n```js\n\u003e\u003e\u003e tax = 12.5 / 100\n\u003e\u003e\u003e price = 100.50\n\u003e\u003e\u003e price * tax\n12.5625\n\u003e\u003e\u003e price + _\n113.0625\n\u003e\u003e\u003e round(_, 2)\n113.06\n```\n\n# 텍스트\n\n## Raw String (이스케이프 문자 \\ 사용 안 함)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 \\로 시작하는 문자를 특수 문자로 해석하지 않으려면, 첫 따옴표 앞에 r을 추가하여 raw 문자열을 사용할 수 있어요:\n\n```js\n\u003e\u003e\u003e print('C:\\some\\name')  # 여기서 \\n은 새 줄을 의미해요!\nC:\\some\name\n\u003e\u003e\u003e print(r'C:\\some\\name')  # 따옴표 앞의 r을 주목해 주세요\nC:\\some\\name\n```\n\n## 문자열 곱하기\n\n문자열은 + 연산자로 이어붙이거나 *를 통해 반복할 수 있어요:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n\u003e\u003e\u003e # 3번의 'un', 그리고 'ium'이 이어집니다\n\u003e\u003e\u003e 3 * 'un' + 'ium'\n'unununium'\n```\n\n## 연산자를 사용한 문자열 결합\n\n따옴표로 둘러싸인 두 개 이상의 문자열 리터럴은 자동으로 연결됩니다. 이 기능은 변수에는 적용되지 않습니다.\n\n```js\n\u003e\u003e\u003e 'Py' 'thon'\n'Python'\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 문자열 색인화\n\n문자열이 할당되었을 때...\n\n```js\n\u003e\u003e\u003e word = 'Python'\n```\n\n다음과 같이 색인화됩니다\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n +---+---+---+---+---+---+\n | P | y | t | h | o | n |\n +---+---+---+---+---+---+\n 0   1   2   3   4   5   6\n-6  -5  -4  -3  -2  -1\n\n\n다양한 흥미로운 예시들을 통해 접근하는 방법을 살펴보겠습니다.\n\n```js\n\u003e\u003e\u003e word[0]  # 위치 0에 있는 문자\n'P'\n\u003e\u003e\u003e word[5]  # 위치 5에 있는 문자\n'n'\n\u003e\u003e\u003e word[-1]  # 마지막 문자\n'n'\n\u003e\u003e\u003e word[-2]  # 끝에서 두 번째 문자\n'o'\n\u003e\u003e\u003e word[-6]\n'P'\n\u003e\u003e\u003e word[0:2]  # 위치 0부터 (포함) 2까지 (미포함)의 문자\n'Py'\n\u003e\u003e\u003e word[2:5]  # 위치 2부터 (포함) 5까지 (미포함)의 문자\n'tho'\n\u003e\u003e\u003e word[:2]   # 시작부터 위치 2까지 (미포함)의 문자\n'Py'\n\u003e\u003e\u003e word[4:]   # 위치 4부터 (포함) 끝까지의 문자\n'on'\n\u003e\u003e\u003e word[-2:]  # 끝에서 두 번째부터 (포함) 끝까지의 문자\n'on'\n\u003e\u003e\u003e word[:2] + word[2:]\n'Python'\n\u003e\u003e\u003e word[:4] + word[4:]\n'Python'\n\u003e\u003e\u003e word[4:42]\n'on'\n\u003e\u003e\u003e word[42:]\n''\n\u003e\u003e\u003e word[42]  # 단어는 6개의 문자만 있습니다\nTraceback (most recent call last):\n  File \"\u003cstdin\u003e\", line 1, in \u003cmodule\u003e\nIndexError: string index out of range\n```\n\n## 참고 및 얕은 복사\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n보통의 할당은 참조를 할당합니다.\n\n```js\n\u003e\u003e\u003e rgb = [\"Red\", \"Green\", \"Blue\"]\n\u003e\u003e\u003e rgba = rgb\n\u003e\u003e\u003e id(rgb) == id(rgba)  # 같은 객체를 참조합니다\nTrue\n\u003e\u003e\u003e rgba.append(\"Alph\")\n\u003e\u003e\u003e rgb\n[\"Red\", \"Green\", \"Blue\", \"Alph\"]\n```\n\n하지만 = 와 [:] 를 사용하면 얕은 복사가 됩니다.\n\n```js\n\u003e\u003e\u003e correct_rgba = rgba[:]\n\u003e\u003e\u003e correct_rgba[-1] = \"Alpha\"\n\u003e\u003e\u003e correct_rgba\n[\"Red\", \"Green\", \"Blue\", \"Alpha\"]\n\u003e\u003e\u003e rgba\n[\"Red\", \"Green\", \"Blue\", \"Alph\"]\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 프로그래밍으로 나아가는 첫걸음\n\n## 더 짧은 피보나치 알고리즘\n\n동일한 라인 할당을 사용하면 피보나치 알고리즘을 훨씬 더 짧게 작성할 수 있습니다.\n\n```js\n\u003e\u003e\u003e a, b = 0, 1\n\u003e\u003e\u003e while a \u003c 1000:\n...     print(a, end=',')\n...     a, b = b, a+b\n...\n0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## print 문에서의 자동 공백 삽입\n\nprint 문을 사용할 때, 입력값들 사이에 자동으로 공백이 추가됩니다. 즉, '이것의 값은'과 'i' 사이에 자동으로 공백이 추가됩니다.\n\n```js\n\u003e\u003e\u003e i = 256*256\n\u003e\u003e\u003e print('이것의 값은', i)\n이것의 값은 65536\n```\n\n# 제어 흐름 도구 더 알아보기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## For - Else Flow Control\n\nIf-Else에 대해 들어보셨나요? Kotlin에서 소수를 확인하는 것과 같이, 찾아낸 소수가 아닌 경우 멈출 수 있는 방법이 있습니다. 불리언 변수 `isPrime`를 false로 설정할 수 있어요.\n\n```js\nfor (n in 2..9) { \n    var isPrime = true\n    for (x in 2 until n) { \n        if (n % x == 0) {\n            println(\"$n equals $x * ${n / x}\")\n            isPrime = false\n            break\n        }\n    }\n    if (isPrime) {\n        println(\"$n is a prime number\")\n    } \n}\n```\n\n하지만 Python에서는 For-Else를 사용해 isPrime 변수를 생략할 수 있어요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n\u003e\u003e\u003e for n in range(2, 10):\n...    for x in range(2, n):\n...       if n % x == 0:\n...          print(n, 'equals', x, '*', n//x)\n...          break\n...    else:\n...       print(n, 'is a prime number')\n\n2 is a prime number\n3 is a prime number\n4 equals 2 * 2\n5 is a prime number\n6 equals 2 * 3\n7 is a prime number\n8 equals 2 * 4\n9 equals 3 * 3\n```\n\n## Pass Flow Control\n\nThe pass keyword is just to let Python know it’s doing nothing, than thinking it’s a syntax error\n\n```js\n\u003e\u003e\u003e while True:\n...    pass  # Busy-wait for keyboard interrupt (Ctrl+C)\n\n\u003e\u003e\u003e class MyEmptyClass:\n...    pass\n\n\u003e\u003e\u003e def initlog(*args):\n...    pass   # Remember to implement this!\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Match Statements\n\n파이썬에서 `match`는 C++이나 Java에서의 `switch`와 Kotlin의 `when`과 유사합니다. 그러나 이는 패턴 매칭과 언패킹 할당에서 더 강력합니다. 주어진 사전의 패턴을 매칭하고 결과를 변수에 언패킹할 수 있습니다.\n\n```js\ndef process_sequence(seq):\n    match seq:\n        case [\"first\", (left, right), _, *rest]:\n            print(f\"Matched pattern:\")\n            print(f\"First element: 'first'\")\n            print(f\"Tuple: ({left}, {right})\")\n            print(f\"Rest of the list: {rest}\")\n        case _:\n            print(\"No match found\")\n\n# Example sequences\nsequence1 = [\"first\", (1, 2), 3, 4, 5, 6]\nsequence2 = [\"first\", (10, 20), \"x\", \"y\", \"z\"]\nsequence3 = [\"second\", (1, 2), 3, 4, 5]\n\n# Process sequences\nprocess_sequence(sequence1)\nprocess_sequence(sequence2)\nprocess_sequence(sequence3)\n```\n\n결과는 아래와 같습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n일치하는 패턴:\n첫 번째 요소: 'first'\n튜플: (1, 2)\n나머지 목록: [4, 5, 6]\n일치하는 패턴:\n첫 번째 요소: 'first'\n튜플: (10, 20)\n나머지 목록: ['y', 'z']\n일치하는 항목이 없습니다\n```\n\n이 스마트한 패턴 매칭은 데이터 추출 로직을 효과적으로 처리했습니다. 더 많은 통찰을 위해 PEP646 튜토리얼을 참조해보세요.\n\n## 함수 매개변수 제어\n\n이전 언어에서는 함수의 매개변수가 엄격히 위치에 따라 정해졌습니다. 최신 언어에서는 매개변수를 키워드로 할당하고 위치 요구 사항을 무시할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파이썬은 개발자들이 원하는 대로 선택할 수 있게 해줘요.\n\n```js\n#############################\n## 기본값: 위치 및 키워드 모두 허용\n#############################\n\u003e\u003e\u003e def standard_arg(arg):\n...    print(arg)\n\n\u003e\u003e\u003e standard_arg(2)\n2\n\n\u003e\u003e\u003e standard_arg(arg=2)\n2\n\n#############################\n## 위치 전용\n#############################\n\u003e\u003e\u003e def pos_only_arg(arg, /):\n...    print(arg)\n\n\u003e\u003e\u003e pos_only_arg(1)\n1\n\n\u003e\u003e\u003e pos_only_arg(arg=1)\nTraceback (most recent call last):\n  File \"\u003cstdin\u003e\", line 1, in \u003cmodule\u003e\nTypeError: pos_only_arg() got some positional-only arguments passed as keyword arguments: 'arg'\n\n#############################\n## 키워드 전용\n#############################\n\u003e\u003e\u003e def kwd_only_arg(*, arg):\n...    print(arg)\n\n\u003e\u003e\u003e kwd_only_arg(3)\nTraceback (most recent call last):\n  File \"\u003cstdin\u003e\", line 1, in \u003cmodule\u003e\nTypeError: kwd_only_arg() takes 0 positional arguments but 1 was given\n\n\u003e\u003e\u003e kwd_only_arg(arg=3)\n3\n\n#############################\n## 결합된 키워드 및 위치\n#############################\n\n\u003e\u003e\u003e def combined_example(pos_only, /, standard, *, kwd_only):\n...    print(pos_only, standard, kwd_only)\n\n\u003e\u003e\u003e combined_example(1, 2, 3)\nTraceback (most recent call last):\n  File \"\u003cstdin\u003e\", line 1, in \u003cmodule\u003e\nTypeError: combined_example() takes 2 positional arguments but 3 were given\n\n\u003e\u003e\u003e combined_example(1, 2, kwd_only=3)\n1 2 3\n\n\u003e\u003e\u003e combined_example(1, standard=2, kwd_only=3)\n1 2 3\n\n\u003e\u003e\u003e combined_example(pos_only=1, standard=2, kwd_only=3)\nTraceback (most recent call last):\n  File \"\u003cstdin\u003e\", line 1, in \u003cmodule\u003e\nTypeError: combined_example() got some positional-only arguments passed as keyword arguments: 'pos_only'\r\n```\n\n## 임의 매개변수 뒤에 매개변수\n\nC++, Java 및 Kotlin에서 임의 매개변수를 허용하지만, 그 뒤에 가능한 고정 매개변수를 누가 상상할까요?\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하지만 Python으로는 아래와 같이 가능합니다. 여기서 sep은 임의의 매개변수 뒤에 고정된 매개변수입니다.\n\n```python\n\u003e\u003e\u003e def concat(*args, sep=\"/\"):\n...    return sep.join(args)\n\n\u003e\u003e\u003e concat(\"earth\", \"mars\", \"venus\")\n'earth/mars/venus'\n\u003e\u003e\u003e concat(\"earth\", \"mars\", \"venus\", sep=\".\")\n'earth.mars.venus'\n```\n\n## JSON 처리 함수 매개변수\n\n함수에 JSON을 제공하고 모든 것을 처리할 수 있다면 멋지지 않을까요?\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파이썬을 사용하면 함수 매개변수로 보내는 변수에 **를 사용하여 가능합니다.\n\n```python\n\u003e\u003e\u003e def testing(voltage, state='a stiff', action='voom'):\n...    print(\"action =\", action)\n...    print(\"voltage =\", voltage)\n...    print(\"state =\", state)\n\n\u003e\u003e\u003e d = {\"voltage\": \"four million\", \"state\": \"bleedin' demised\", \"action\": \"VOOM\"}\n\u003e\u003e\u003e testing(**d)\n\naction = VOOM\nvoltage = four million\nstate = bleedin' demised\n```\n\n## 람다: 한 줄 함수\n\n우리는 Java 8 및 Kotlin에서 Lambda에 대해 배웠지만, lambda 키워드는 사용되지 않았습니다. 대신 Lambda로 함수 포인터가 보내지고, 일반적으로 그 함수를 정의해야 했습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파이썬에서는 lambda 키워드를 사용하여 해당 함수를 정의할 수 있어요\n\n예시\n\n```js\ndef getKey(pair):\n    return pair[1]\n\n# 같은 효과를 내는 코드입니다    \ngetKey_lambda = lambda pair: pair[1]\n```\n\n다음과 같이 간단한 사용 사례가 있어요. 람다 함수를 별도로 정의할 필요가 없는 경우입니다\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n\u003e\u003e\u003e # 튜플 리스트\n\u003e\u003e\u003e pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]\n\n\u003e\u003e\u003e # 각 튜플의 두 번째 요소를 기준으로 리스트 정렬하기 (람다 사용)\n\u003e\u003e\u003e pairs.sort(key=lambda pair: pair[1])\n\n\u003e\u003e\u003e print(pairs)\n[(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')]\n```\n\n## 함수 설명서 출력하기\n\n일반적으로 주석은 프로그래밍 코드의 일부가 아닙니다. 그러나 Python에서는 함수.__doc__을 사용하여 함수 설명서를 출력할 수 있습니다.\n\n```js\n\u003e\u003e\u003e def my_function():\n...    \"\"\"아무것도 하지 않지만 문서화합니다.\n...\n...    정말로, 아무것도 실행하지 않습니다.\n...    \"\"\"\n...    pass\n\n\u003e\u003e\u003e print(my_function.__doc__)\n아무것도 하지 않지만 문서화합니다.\n\n    정말로, 아무것도 실행하지 않습니다.\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하지만 매개변수만 알고 싶다면 .__annotations__를 사용할 수 있어요.\n\n```python\n\u003e\u003e\u003e def f(ham: str, eggs: str = 'eggs') -\u003e str:\n...    print(\"Annotations:\", f.__annotations__)\n...    print(\"Arguments:\", ham, eggs)\n...    return ham + ' and ' + eggs\n\n\u003e\u003e\u003e f('spam')\nAnnotations: {'ham': \u003cclass 'str'\u003e, 'return': \u003cclass 'str'\u003e, 'eggs': \u003cclass 'str'\u003e}\nArguments: spam eggs\n'spam and eggs'\n```\n\n# 데이터 구조\n\n## 리스트 내포\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n코드를 훨씬 간략하게 만들어주는 목록 내 항목을 이해해요.\n\n```js\n\u003e\u003e\u003e squares = [x**2 for x in range(10)]\n\u003e\u003e\u003e print(squares)\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n\n\u003e\u003e\u003e [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]\n[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]\n```\n\n이를 통해 우리는 리스트를 변환하거나 필터링하는 등 알고리즘 함수를 수행할 수 있어요. 예를 들어,\n\n```js\n\u003e\u003e\u003e vec = [-4, -2, 0, 2, 4]\n\u003e\u003e\u003e # 값이 두 배인 새 리스트 생성\n\u003e\u003e\u003e [x*2 for x in vec]\n[-8, -4, 0, 4, 8]\n\n\u003e\u003e\u003e # 음수를 제외한 리스트 필터링\n\u003e\u003e\u003e [x for x in vec if x \u003e= 0]\n[0, 2, 4]\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 콤마 할당은 튜플을 만듭니다\n\n할당 뒤에 쉼표(,)를 추가하면 전체 할당이 튜플 유형이 됩니다.\n\n```js\n\u003e\u003e\u003e noComma = '안녕하세요'\n\u003e\u003e\u003e withComma = '안녕하세요',\n\n\u003e\u003e\u003e print(len(noComma))\n5\n\u003e\u003e\u003e print(len(withComma))\n1\n\n\u003e\u003e\u003e print(noComma)\n안녕하세요\n\u003e\u003e\u003e print(withComma)\n('안녕하세요',)\n```\n\n## 튜플 언패킹\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n튜플에서의 역 언패킹 할당은 가능합니다.\n\n```js\n\u003e\u003e\u003e # 튜플 만들기\n\u003e\u003e\u003e t = 12345, 54321, 'hello!'\n\n\u003e\u003e\u003e # 튜플을 3개의 변수로 언패킹 (튜플의 크기와 정확히 일치해야 함)\n\u003e\u003e\u003e x, y, z = t\n```\n\n## 집합: 고유한 목록\n\n중복을 없애는 리스트와 유사합니다. 꺽은 괄호 `{}`를 사용합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n\u003e\u003e\u003e a = set('abracadabra')\n\u003e\u003e\u003e b = set('alacazam')\n\u003e\u003e\u003e a                                  # a 안의 고유한 문자\n{'a', 'r', 'b', 'c', 'd'}\n\u003e\u003e\u003e a - b                              # a에만 있는 문자\n{'r', 'd', 'b'}\n\u003e\u003e\u003e a | b                              # a나 b 또는 둘 다에 있는 문자\n{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}\n\u003e\u003e\u003e a \u0026 b                              # a와 b에 모두 있는 문자\n{'a', 'c'}\n\u003e\u003e\u003e a ^ b                              # a나 b에만 있는 문자\n{'r', 'd', 'b', 'm', 'z', 'l'}\r\n```\n\n이것이 사전의 기초를 이룹니다.\n\n## 문자열 불리언 비교\n\n파이썬에서는 문자열을 비교하여 결과로 참/거짓 값을 얻을 수 있으며, 결과는 불리언으로 평가된 마지막 변수를 반환합니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n\u003e\u003e\u003e string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'\n\u003e\u003e\u003e non_null = string1 or string2 or string3\n\u003e\u003e\u003e # 'Trondheim'가 출력됩니다. 첫 번째로 true를 반환한 OR 연산자\n\u003e\u003e\u003e print(non_null)\n'Trondheim'\n\n\n\u003e\u003e\u003e string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'\n\u003e\u003e\u003e non_null = string1 and string2 and string3\n\u003e\u003e\u003e # 빈 문자열이 하나라도 있으면 아무것도 출력되지 않습니다\n\u003e\u003e\u003e print(non_null) \n\n\n\u003e\u003e\u003e string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'\n\u003e\u003e\u003e non_null = string1 and string2 and string3\n\u003e\u003e\u003e # 'Hammer Dance'가 출력됩니다. true를 반환하는 마지막 AND 연산자\n\u003e\u003e\u003e print(non_null)\nHammer Dance\r\n```\n\n# 입력과 출력\n\n## “=”를 사용하여 print 출력 결과 포맷팅하기\n\n```js\n\u003e\u003e\u003e bugs = 'roaches'\n\u003e\u003e\u003e count = 13\n\u003e\u003e\u003e area = 'living room'\n\u003e\u003e\u003e print(f'Debugging {bugs=} {count=} {area=}')\nDebugging bugs='roaches' count=13 area='living room'\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 클래스\n\n## 데이터 멤버는 외부에서 생성할 수 있습니다\n\n데이터 멤버는 클래스 외부에서 생성하고 삭제할 수 있습니다.\n\n```js\n\u003e\u003e\u003e class MyClass:\n...    \"\"\"간단한 예제 클래스\"\"\"\n...    def f(self):\n...        return 'hello world'\n\n\u003e\u003e\u003e x = MyClass()        \n\u003e\u003e\u003e x.counter = 1\n\u003e\u003e\u003e print(x.counter)\n1\n\n\u003e\u003e\u003e del x.counter\n\n\u003e\u003e\u003e try:\n...    print(x.counter)\n... except:\n...    print(\"x.counter가 더 이상 존재하지 않습니다\")\nx.counter가 더 이상 존재하지 않습니다\n```  \n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 도움이 되었으면 좋겣습니다! AI를 배우기 시작할 수 있는 프로그래밍 언어인 Python을 즐겁게 배우세요!","ogImage":{"url":"/TIL/assets/img/2024-07-14-PeculiarPythonProgrammingSyntax_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-PeculiarPythonProgrammingSyntax_0.png","tag":["Tech"],"readingTime":20},{"title":"당신이 놓쳤을 7가지 미친 파이썬 이스터 에그","description":"","date":"2024-07-14 20:36","slug":"2024-07-14-7CrazyPythonEasterEggsYouProbablyHaventSeen","content":"\n\n![이미지](/TIL/assets/img/2024-07-14-7CrazyPythonEasterEggsYouProbablyHaventSeen_0.png)\n\nPython은 기술 세계에서 가장 인기 있는 프로그래밍 언어 중 하나로, 요약하면 코딩 왕국의 석탄왕입니다. Python은 사용하기 쉬운 구문과 다재다능성으로 개발자들의 마음 속에 특별한 자리를 꽂아왔습니다. 그러나 실용적인 응용 분야를 넘어 숨겨진 재미있는 이스터 에그들로 가득 찬 비밀의 놀이터가 기다리고 있습니다. 이 블로그에서는 아마 본 적이 없는 몇 가지 미친 Python 이스터 에그를 공유하려고 합니다.\n\n## 1. .py 확장자는 크게 상관이 없어요 🐍\n\nPython에 관한 모든 책, 모든 튜토리얼, 그리고 모든 기사는 Python 프로그램을 저장할 때 항상 .py 확장자를 사용해야 한다고 말할 것입니다. 이것은 사실이고, 항상 이 윤리적으로 해야 하지만, 이 기사는 Python 윤리에 관한 것이 아니라 이스터 에그에 관한 것입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](https://miro.medium.com/v2/resize:fit:996/1*s-gIoYmgwo4NNlTBsTniZw.gif)\n\n파이썬 파일을 저장할 때는 .cow, .cat 또는 .mango와 같은 모든 종류의 확장자를 사용할 수 있습니다. 스크립트가 유효하다면 원하는 출력을 제공하고 실행될 것입니다.\n\n```js\n# 간단한 CLI 계산기\n# cli_calc.cow\n\ndef add(x, y):\n  return x + y\ndef subtract(x, y):\n    return x - y\ndef multiply(x, y):\n    return x * y\ndef divide(x, y):\n    if y == 0:\n        return \"오류: 0으로 나눌 수 없습니다!\"\n    else:\n        return x / y\n\nprint(\"연산을 선택하세요:\")\nprint(\"1. 더하기\")\nprint(\"2. 빼기\")\nprint(\"3. 곱하기\")\nprint(\"4. 나누기\")\n\nwhile True:\n    choice = input(\"선택하세요 (1/2/3/4): \")\n    if choice in ('1', '2', '3', '4'):\n        num1 = float(input(\"첫 번째 숫자를 입력하세요: \"))\n        num2 = float(input(\"두 번째 숫자를 입력하세요: \"))\n\n        if choice == '1':\n            print(\"결과:\", add(num1, num2))\n        elif choice == '2':\n            print(\"결과:\", subtract(num1, num2))\n        elif choice == '3':\n            print(\"결과:\", multiply(num1, num2))\n        elif choice == '4':\n            print(\"결과:\", divide(num1, num2))\n        break\n    else:\n        print(\"유효하지 않은 입력입니다. 유효한 숫자를 입력하세요 (1/2/3/4).\")\n```\n\n![image](https://miro.medium.com/v2/resize:fit:1200/1*bRH0ZnSKG-kaCv-gr8fonA.gif)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 2. 파이썬에서 무한대는 도달 가능합니다\n\n정말 그렇습니다.\n파이썬에서는 float(`inf`)를 사용하여 양의 무한대를 나타내고, float(`-inf`)를 사용하여 음의 무한대를 나타낼 수 있습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:324/1*0KTkloaq_LLwl7esTS_dbQ.gif)\n\n아래는 간단한 예제 사용 사례입니다...\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\r\ndef find_max(numbers):\n    if not numbers:\n        return float('-inf')  # 빈 리스트에는 음의 무한대를 반환합니다.\n    else:\n        max_value = float('-inf')  # max_value를 음의 무한대로 초기화합니다.\n        for num in numbers:\n            if num \u003e max_value:\n                max_value = num\n        return max_value\n\n# 예시 사용법:\nnumbers_list = [5, 9, 2, 11, 6]\nprint(\"최댓값:\", find_max(numbers_list))\n\nempty_list = []\nprint(\"빈 리스트의 최댓값:\", find_max(empty_list))\n\n----------------------------\n최댓값: 11\r\n```\n\n## 3. The OG 😎\n\n“Python의 기초”는 Python 프로그램을 작성하는 지침의 모음입니다. 이것들은 Tim Peters가 쓴 것으로 Python 해석기에 \"이스터 에그\"로 포함되어 있습니다. Python 인터프리터에서 import this를 입력하여 확인할 수 있습니다.\n\n```js\r\n\u003e\u003e\u003e import this\nThe Zen of Python, by Tim Peters\n\nBeautiful is better than ugly.\nExplicit is better than implicit.\nSimple is better than complex.\nComplex is better than complicated.\nFlat is better than nested.\nSparse is better than dense.\nReadability counts.\nSpecial cases aren't special enough to break the rules.\nAlthough practicality beats purity.\nErrors should never pass silently.\nUnless explicitly silenced.\nIn the face of ambiguity, refuse the temptation to guess.\nThere should be one-- and preferably only one --obvious way to do it.\nAlthough that way may not be obvious at first unless you're Dutch.\nNow is better than never.\nAlthough never is often better than *right* now.\nIf the implementation is hard to explain, it's a bad idea.\nIf the implementation is easy to explain, it may be a good idea.\nNamespaces are one honking great idea -- let's do more of those!\r\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nPEP 20(Python Enhancement Proposal 20)은 팀 피터스가 저술한 Python의 철학인 Zen of Python을 처음 소개했습니다. 20개의 금언이라고 불리지만, 실제로는 PEP에 명시된 것은 19개 뿐입니다. 이 작은 차이는 적혀 있는 것과 인용된 것 사이의 흥미로운 측면 중 하나입니다. \n\n![image](https://miro.medium.com/v2/resize:fit:200/0*zT7m0MwnO2vf35uK.gif)\n\n## 4. \"한치의 여지도 없다\"\n\nPython에는 Python 2와 Python 3 모두와 호환성을 유지하기 위해 개발자가 사용하는 __future__ 패키지가 있습니다. 이를 통해 Python 2와 Python 3를 모두 지원하는 단일하고 깨끗한 Python 3.x 호환 코드베이스를 최소한의 오버헤드로 사용할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n음... 좋아! 이 패키지에는 오류와 클래스에서 유머로 가득찬 은박이 숨겨져 있어요.\n\n```js\nfrom __future__ import braces\n\n  File \"\u003cstdin\u003e\", line 1\nSyntaxError: not a chance\n```\n\n미래에서 중괄호를 가져오려고 하면 '흥! 그럴 리가' 라는 재미있는 오류가 발생할 거에요. 이 부분은 Python이 C, Java, 또는 JavaScript와 같은 다른 프로그래밍 언어와 달리 중괄호 ''를 블록 구분에 사용하지 않는다는 사실을 유머스럽게 표현한 장난이나 은박이로 의도적으로 만들어졌어요.\n\n## 5. Chinese As Var Names\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n네, 올바르게 이해하셨어요!!!\n\nPython에서는 변수 이름으로 중국어 문자나 유니코드 문자를 사용할 수 있어요. Python은 언어 전반에 걸쳐 유니코드를 지원해요.\n\n```js\n# 변수 이름으로 중국어 문자 사용하기\n大人弓戈 = \"Hello\"\nprint(大人弓戈)  # 출력: Hello\n\n金竹戈女日 = \"World\"\nprint(金竹戈女日)  # 출력: World\n\n# 함수 이름에 중국어 문자 사용하기\ndef 心口戈弓廿尸日廿日():\n    print(\"心卜廿竹人弓戈尸中人女水\")\n\n心口戈弓廿尸日廿日()\n```\n\n## 6. Antigravity\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파이썬의 재미있는 이스터에그 중 하나는 \"Python\"이라는 XKCD 만화를 참조한 것입니다. 이 만화에는 어떤 복잡한 작업도 쉽게 느껴지게 만들 수 있는 캐릭터 이야기가 포함되어 있어 파이썬의 간결함과 가독성을 강조합니다.\n\n```js\nimport antigravity\n```\n\n## 7. 이상한 임포트\n\n파이썬에는 30만 개 이상의 패키지가 있습니다. 그 중 일부는 내장되어 있고 놀라운 파이썬 커뮤니티가 외부에서 몇 가지 생성합니다. 각 패키지는 고유한 능력 집합을 갖고 있지만 일부는 파이썬의 재미를 한 단계 더 높여줍니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport __hello__\n\n\u003e\u003e Hello World!\n```\n\n__hello__ 모듈은 파이썬에서 특별한 모듈로, 파이썬 패키지를 만들고 배포하는 간단한 데모로 사용됩니다. 실제 기능은 포함하고 있지 않지만, 파이썬 패키지의 구조와 레이아웃을 보여줍니다.\n\n여기까지 읽어주셔서 감사합니다. 내 컨텐츠가 마음에 들고, 지원하고 싶다면 다음이 최고 방법입니다 —\n\n- Clap👋을 남기고 생각을 💬 댓글로 남겨주세요.\n- 제 Medium 팔로우하기.\n- LinkedIn에서 나와 연결하기.\n- 내 이메일 목록에 가입하여 다른 글을 놓치지 마세요.","ogImage":{"url":"/TIL/assets/img/2024-07-14-7CrazyPythonEasterEggsYouProbablyHaventSeen_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-7CrazyPythonEasterEggsYouProbablyHaventSeen_0.png","tag":["Tech"],"readingTime":8},{"title":"오늘 바로 해킹의 첫 걸음 내딛기","description":"","date":"2024-07-14 20:35","slug":"2024-07-14-Takeyourfirststepinhackingtoday","content":"\n\n만약 좋고 전문적인 방법으로 해킹을 배우고 싶다면, 해킹의 첫 걸음을 따라가는데 도움 될 수 있는 몇 가지 항목을 배워야 할 수도 있습니다. 이미 사이버 보안 자격증이나 학사 학위를 취득했다면 더 좋습니다.\n\n# 버전 0.01 :\n\n모든 문서는 기본 버전이며 매 번 업데이트되므로 방문할 때마다 최신 정보를 얻을 수 있습니다.\n\n# 작은 걸음\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 리눅스, 윈도우, macOS를 위한 명령어\n- 디렉토리 이동\n- 웹 또는 데스크톱 애플리케이션 지식\n- 데이터베이스 관리 시스템 작동 방식\n- 페이로드와 그 효과\n- 요청 유형\n- 진입하는 세 가지 방법\n\n# 리눅스, 윈도우, macOS를 위한 명령어,\n\n해킹을 배우려는 사람이라면 명령어 이해가 매우 중요합니다. 때로는 여러 가지가 여러분에게 열려 있지만 들어가려고 노력해야 할 때가 있습니다.\n\n# Curl 요청에 대한 매우 간단한 예제\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 명령어는 매우 간단해요. curl을 사용해서 명령어를 실행하면 되요.\n\n![사진](/TIL/assets/img/2024-07-14-Takeyourfirststepinhackingtoday_0.png)\n\nGabriel Heinzer님의 Unsplash에서 제공된 사진입니다.\n\n```js\ncurl -X POST -H \"Content-Type: application/json\" -d '{\"username\":\"exampleuser\",\"password\":\"examplepass\"}' http://example.com/api/login\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\ncURL 명령어의 구성 요소를 살펴보겠습니다.\n\nCurl은 -X POST를 사용하여 Curl과 함께 사용하는 요청 방법을 말합니다. `Post`를 사용하여 입력 정보를 서버로 제출합니다.\n\n# 웹 또는 데스크톱 애플리케이션 지식.\n\n웹 테스팅을 배우고 싶다면 웹사이트 해킹을 하려는 것이 중요합니다. 모든 것을 잘 알아야 하는 것이 중요한 것은 아닙니다. 작은 단계로 배워야 합니다. 예를 들어,\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n온라인 오픈 웹 서버를 탐험하고 사이버 보안 직업으로 이끌어주는 중이시군요.\n\n웹 애플리케이션에서 버그나 취약점을 찾는 것은 누구에게나 쉬울 수 있어요. 몇 가지 간단한 방법을 사용하면 됩니다.\n\nGoogle Dorks를 이용해 공개 서버의 데이터를 탐색할 수 있어요. 구글 해킹 데이터베이스\n\n```js\nintitle:index.of intext:crm.zip\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 간단한 구글 스트링은 귀하의 첫 번째 단계를 이끌어주는 데 도움이 될 수 있습니다. 이렇게 쉬울 것이라고 생각하실 수도 있습니다. 네, 맞습니다. 그러나 이러한 종류의 스트링을 사용하여 많은 중요한 정보를 발견했습니다.\n\n[Takeyourfirststepinhackingtoday_1.png 이미지](/TIL/assets/img/2024-07-14-Takeyourfirststepinhackingtoday_1.png)\n\nBernd 📷 Dittrich의 Unsplash에서 제공하는 사진입니다.\n\n웹 애플리케이션이 데이터베이스와 함께 작동하는 방식에 관심이 있다면 이 문서를 확인해보세요. 웹에 대한 기본 지식만 있다면 더 잘 이해할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 데이터베이스에서 외래 키 관계를 정의할 때 마주칠 수 있는 문제\n\n# 여러분은 아마도 외래 키가 일반적으로 데이터베이스의 두 테이블 사이에 연결을 설정하는 데 사용된다는 것을 알고 있을 겁니다...\n\nmedium.com\n\n# 공격적인 경로 vs 방어적인 경로:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n사이버 보안을 향한 당신의 길은 이미 분명해야 합니다. 제가 강의에서 언급한 것처럼, 프로그래밍이 잘되어야 하는 경우도 있습니다. 복잡한 문제를 해결할 수 없습니다. 방어 분야에서 활동하고 싶다면 다음과 같은 것들에 대한 좋은 이해가 있어야 합니다.\n\n- 사이버 보안 소개\n- 네트워크 보안\n- 안전한 코딩과 응용 프로그램 보안\n- 암호학\n- 사이버 위협 인텔리전스\n- 사고 대응과 관리\n- 위험 관리와 준수\n- 윤리적 해킹 및 침투 테스트\n- 디지털 포렌식\n- 보안 운영 및 모니터링\n- 안전한 시스템 및 인프라\n- 개인 정보 보호\n\n만약 공격적 보안에 관심이 있다면 이해해야 할 내용들은 다음과 같습니다.\n\n- 윤리적 해킹\n- 침투 테스팅\n- 취약점 평가\n- 익스플로잇 개발\n- 레드팀\n- 사회 공학\n- 무선 네트워크 해킹\n- 웹 애플리케이션 해킹\n- 네트워크 스캐닝 및 열거\n- 암호 해독\n- 역공학\n- 악성 코드 분석\n- OS 및 네트워크 공격\n- 사후 공격 기술\n- 위협 인텔리전스 수집\n- 적대적 전술, 기술 및 절차 (TTP)\n- 물리적 보안 평가\n- 무선 네트워크 감사\n- 클라우드 보안 평가\n- IoT 보안 테스트\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n나의 마스터 클래스에 참여하신 모든 분들께, 마스터 또는 박사 과정 학생 또는 초심자들 모두 모든 것을 얻을 수 있어요. 이것은 여러분이 완전한 사람으로 성장하는 데 도움이 될 거예요.\n\n더 많은 정보를 원하시면 계속해서 함께해주세요...","ogImage":{"url":"/TIL/assets/img/2024-07-14-Takeyourfirststepinhackingtoday_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-Takeyourfirststepinhackingtoday_0.png","tag":["Tech"],"readingTime":5}],"page":"1","totalPageCount":33,"totalPageGroupCount":2,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"1"},"buildId":"xwOwpfNxF5xANgUpiyc2H","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>