<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>TIL</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//posts/1" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="TIL" data-gatsby-head="true"/><meta property="og:title" content="TIL" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//posts/1" data-gatsby-head="true"/><meta name="twitter:title" content="TIL" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/7978fe7362f7d4c9.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/7978fe7362f7d4c9.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/TIL/_next/static/chunks/463-925361deb4cec4b1.js" defer=""></script><script src="/TIL/_next/static/chunks/873-2eda6d845ad1e69e.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/posts/%5Bpage%5D-350e448526ad5efa.js" defer=""></script><script src="/TIL/_next/static/71zJMhK9mFbQV7s02rMGq/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/71zJMhK9mFbQV7s02rMGq/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="의사결정자들이 수학을 더 배워야 하는 이유" href="/TIL/post/2024-07-12-DecisionMakersNeedMoreMath"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="의사결정자들이 수학을 더 배워야 하는 이유" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-12-DecisionMakersNeedMoreMath_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="의사결정자들이 수학을 더 배워야 하는 이유" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">의사결정자들이 수학을 더 배워야 하는 이유</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 12, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="빅데이터 처리를 위한 Python 사용 방법" href="/TIL/post/2024-07-12-PythonforBigData"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="빅데이터 처리를 위한 Python 사용 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-12-PythonforBigData_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="빅데이터 처리를 위한 Python 사용 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">빅데이터 처리를 위한 Python 사용 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 12, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리소스가 제한된 시스템을 위한 Quantized Mistral 7B vs TinyLlama 비교분석" href="/TIL/post/2024-07-12-QuantizedMistral7BvsTinyLlamaforResource-ConstrainedSystems"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리소스가 제한된 시스템을 위한 Quantized Mistral 7B vs TinyLlama 비교분석" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-12-QuantizedMistral7BvsTinyLlamaforResource-ConstrainedSystems_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리소스가 제한된 시스템을 위한 Quantized Mistral 7B vs TinyLlama 비교분석" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">리소스가 제한된 시스템을 위한 Quantized Mistral 7B vs TinyLlama 비교분석</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 12, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Pandas DataFrame에 데이터 로드하는 방법" href="/TIL/post/2024-07-12-PandasLoadingdataintoaDataFrame"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Pandas DataFrame에 데이터 로드하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-12-PandasLoadingdataintoaDataFrame_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Pandas DataFrame에 데이터 로드하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Pandas DataFrame에 데이터 로드하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 12, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="이진 트리 출력용 파이썬 패키지 제작기 재미로 했어요" href="/TIL/post/2024-07-12-ICreatedAPythonPackageToPrintBinaryTreesForFun"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="이진 트리 출력용 파이썬 패키지 제작기 재미로 했어요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-12-ICreatedAPythonPackageToPrintBinaryTreesForFun_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="이진 트리 출력용 파이썬 패키지 제작기 재미로 했어요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">이진 트리 출력용 파이썬 패키지 제작기 재미로 했어요</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 12, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="파이썬으로 AI를 사용해 과학 지식 자동으로 가져오는 방법" href="/TIL/post/2024-07-12-AutomatingScientificKnowledgeRetrievalwithAIinPython"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="파이썬으로 AI를 사용해 과학 지식 자동으로 가져오는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-12-AutomatingScientificKnowledgeRetrievalwithAIinPython_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="파이썬으로 AI를 사용해 과학 지식 자동으로 가져오는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">파이썬으로 AI를 사용해 과학 지식 자동으로 가져오는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 12, 2024</span><span class="PostList_reading_time__6CBMQ">24<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="코딩 없이 바로 사용할 수 있는 실용적인 파이썬 팁 5가지" href="/TIL/post/2024-07-12-5PracticalPythonTipsNoCodingRequiredReadytoUse"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="코딩 없이 바로 사용할 수 있는 실용적인 파이썬 팁 5가지" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-12-5PracticalPythonTipsNoCodingRequiredReadytoUse_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="코딩 없이 바로 사용할 수 있는 실용적인 파이썬 팁 5가지" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">코딩 없이 바로 사용할 수 있는 실용적인 파이썬 팁 5가지</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 12, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="형태학적 이미지 처리 실용 가이드" href="/TIL/post/2024-07-12-Apracticalguidetomorphologicalimageprocessing"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="형태학적 이미지 처리 실용 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="형태학적 이미지 처리 실용 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">형태학적 이미지 처리 실용 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 12, 2024</span><span class="PostList_reading_time__6CBMQ">15<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="게으른 개발자를 위한 필수 효율적인 파이썬 데코레이터 5가지" href="/TIL/post/2024-07-12-EssentialforLazyDevelopersFiveEfficientPythonDecorators"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="게으른 개발자를 위한 필수 효율적인 파이썬 데코레이터 5가지" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-12-EssentialforLazyDevelopersFiveEfficientPythonDecorators_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="게으른 개발자를 위한 필수 효율적인 파이썬 데코레이터 5가지" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">게으른 개발자를 위한 필수 효율적인 파이썬 데코레이터 5가지</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 12, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="위성으로 보이지 않는 용암 흐름과 활활 타오르는 산불을 어떻게 포착할 수 있을까 Python 사용법" href="/TIL/post/2024-07-12-SatellitesCanSeeInvisibleLavaFlowsandActiveWildfiresButHowPython"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="위성으로 보이지 않는 용암 흐름과 활활 타오르는 산불을 어떻게 포착할 수 있을까 Python 사용법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-12-SatellitesCanSeeInvisibleLavaFlowsandActiveWildfiresButHowPython_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="위성으로 보이지 않는 용암 흐름과 활활 타오르는 산불을 어떻게 포착할 수 있을까 Python 사용법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">위성으로 보이지 않는 용암 흐름과 활활 타오르는 산불을 어떻게 포착할 수 있을까 Python 사용법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 12, 2024</span><span class="PostList_reading_time__6CBMQ">23<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link posts_-active__YVJEi" href="/TIL/posts/1">1</a><a class="link" href="/TIL/posts/2">2</a><a class="link" href="/TIL/posts/3">3</a><a class="link" href="/TIL/posts/4">4</a><a class="link" href="/TIL/posts/5">5</a><a class="link" href="/TIL/posts/6">6</a><a class="link" href="/TIL/posts/7">7</a><a class="link" href="/TIL/posts/8">8</a><a class="link" href="/TIL/posts/9">9</a><a class="link" href="/TIL/posts/10">10</a><a class="link" href="/TIL/posts/11">11</a><a class="link" href="/TIL/posts/12">12</a><a class="link" href="/TIL/posts/13">13</a><a class="link" href="/TIL/posts/14">14</a><a class="link" href="/TIL/posts/15">15</a><a class="link" href="/TIL/posts/16">16</a><a class="link" href="/TIL/posts/17">17</a><a class="link" href="/TIL/posts/18">18</a><a class="link" href="/TIL/posts/19">19</a><a class="link" href="/TIL/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"의사결정자들이 수학을 더 배워야 하는 이유","description":"","date":"2024-07-12 21:05","slug":"2024-07-12-DecisionMakersNeedMoreMath","content":"\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-DecisionMakersNeedMoreMath_0.png\" /\u003e\n\n최근에 직장에서 일에 대해 곤란해하는 친구와 대화를 나누었어요. 그 친구는 자신이 판매 인력부에서 주도하는 주요 소프트웨어 롤아웃에 책임이 있었지만, 그 일에 대해 믿지 않았어요. 사실 그의 동료들도 그렇게 생각하지 않았다고 해요. 그가 묘사한 상황은 정말 안좋고 동기 부여가 안 되는 상황 같았어요.\n\n나는 당연하게도 어떻게 이런 상황이 발생했는지 물어보았어요. 그 친구는 롤아웃을 추진할 결정이 경영진 사이에서 유포된 '킬러 차트'에서 비롯되었다고 설명했어요. 차트는 두 그룹의 판매 결과를 비교하여 특정 소프트웨어 제품을 현장에서 사용한 한 그룹이 더 효과적이라는 결론을 내렸다고 해요.\n\n내가 한 질문은 두가지였어요. 먼저, 그들이 두 그룹의 차이가 우연 때문이 아닌지 확인했느냐 물어보았고, 그 다음으로 소프트웨어 사용이 그 차이를 일으켰다는 것이 결정적으로 입증되었는지 확인했느냐 물었어요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n말끔히 당황했다. 그는 우연히 차이가 발생할 수 있다는 것을 전혀 몰랐다며 원인과 결과에 대한 질문은 심지어 논의되지 않았다고 말했다. 그는 경영진이 단지 차트를 삼켜버리고 숫자들과 그 의미에 대한 추가 논쟁 없이 결정을 내렸다고 설명했다.\n\n우리가 도출한 결론은 이 모든 것이 그룹 내에서 수학에 대해 아무도 모르기 때문에 발생했다는 것이었다! 분석 자료 한 조각이 그룹 전체를 휩쓴 바 있었고, 관련된 사람들은 모두 그것을 올바르게 비평할 경험이나 지식이 없었다.\n\n나는 이러한 상황이 급속히 확대되고 있고, 그로 인해 수백만 달러의 잘못된 결정이 이루어지고 있다는 것을 우려한다.\n\n## 왜 수학이 더 중요해지고 있는 것일까?\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n간단히 말하면, 데이터의 양이 많이 증가했습니다. IBM에 따르면, 우리는 이제 매일 2.5 퀸틸리언 바이트 이상의 데이터를 생성하고 있습니다. 이러한 추세가 계속될 것으로 보여주는 다양한 통계가 있습니다:\n\n- McKinsey의 연구에 따르면, 거의 50%의 영업 및 마케팅 기능이 자신들을 '분석 및 빅데이터에 의해 변형되었다'고 설명하고 있습니다.\n- Statista에 따르면, 빅데이터 시장은 다음 10년 동안 연간 10% 이상 성장할 것으로 보고 있습니다.\n- 최근 업무 설문 조사에 따르면, 기업의 84%가 고급 분석 및 빅데이터 프로젝트를 시작하여 의사 결정을 개선하고 있습니다.\n\n명확한 사실은 의사 결정자들이 10년이나 20년 전보다 훨씬 많은 데이터 주도 문서와 차트를 마주하게 될 것이라는 것입니다. 하지만 이러한 데이터 풍부한 환경에서 정확한 결정을 내릴 수 있는 능력을 가진 의사 결정자들이 더 잘 갖추어져 있는지 궁금합니다.\n\n![이미지](/TIL/assets/img/2024-07-12-DecisionMakersNeedMoreMath_1.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 수학 능력은 높아지고 있지만 기술은 부족합니다\n\n데이터 중심의 의사 결정과 분석 붐으로 인해 경영진의 수학 능력도 함께 높아져야 합니다. 분석을 의심하고 비평할 수 있는 능력이 없다면 의사 결정자들은 판촉 활동과 편향된 의도에 휘둘릴 수밖에 없습니다. 상관 관계, 회귀, 통계적 유의성 및 예측 정확도와 같은 개념들이 언급되고 있지만, 의사 결정자들이 그것들을 이해할 만큼 충분히 잘 갖추고 있는지에 대한 증거가 없습니다.\n\n- 영국의 케임브리지 평가 연구에 따르면, 고도의 데이터 중심인 것이 아닌 직무에서도 고용주들은 수리능력을 중요시하며, 그러나 현재의 업무 인원은 이를 충족시키기에 적절한 수준이 되지 못하고 있다고 강조합니다.\n- 미국 노동부는 다음 10년 동안 수학 관련 직종이 다른 직종보다 4배 빠른 속도로 성장할 것으로 예상되지만, OECD에 따르면 미국은 성인의 수리 능력 평균으로 볼 때 30개국 중 24위를 차지합니다.\n- 최근 하버드 대학의 연구에 따르면, 미래 직업 시장에서 수학은 가장 필수적인 기술 중 하나가 될 것으로 예상되며, 최근의 가장 큰 일자리 증가는 수학이 필요한 포지션으로 집중되고 있다는 것을 보여줍니다.\n\n# 의사 결정자들이 알아야 할 것은 무엇인가요?\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n세련된 매크로 요소와 트렌드 가운데, 데이터 중심 환경에서 의사 결정자가 알아야 할 몇 가지 기본적인 요소들이 있다고 생각이 듭니다:\n\n- 상관 관계의 의미와 다양한 유형의 데이터에 대한 상관 계수 측정 방법\n- 인과 관계의 의미, 상관 관계와의 차이, 그리고 인과 관계를 증명하는 방법\n- 가설 검증의 통계적 방법과 가설 검정에 기반한 통계적 조건\n\n데이터 중심 환경에서 일하고 계시는데 이러한 것들에 대해 충분히 이해하고 있다고 느끼지 않으시다면, 지금이라도 대책을 세우도록 권장드립니다. 더불어 동료 의사 결정자들도 비슷한 입장에 있다고 느낀다면, 상황은 더욱 시급해진다고 할 수 있습니다.\n\n매년마다 직장에서 수학적 지식이 더욱 중요해지는 건 의심할 여지가 없습니다. 우리가 좋아하든 안 하든, 노력을 기울여 학습을 해 나가야 할 필요가 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n수학이 당신의 업무에서 얼마나 중요한가요? 자유롭게 의견을 남겨주세요.","ogImage":{"url":"/TIL/assets/img/2024-07-12-DecisionMakersNeedMoreMath_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-DecisionMakersNeedMoreMath_0.png","tag":["Tech"],"readingTime":4},{"title":"빅데이터 처리를 위한 Python 사용 방법","description":"","date":"2024-07-12 21:01","slug":"2024-07-12-PythonforBigData","content":"\n\n빅 데이터는 인간의 행동과 상호 작용과 관련된 패턴, 동향 및 관련성을 밝히기 위해 계산적으로 분석할 수 있는 극도로 큰 데이터 세트를 가리킵니다. 네 가지 V - Volume, Velocity, Variety, 그리고 Veracity. 이러한 V는 빅 데이터를 특징 짓는데, 함께 간단하게 알아보도록 하죠:\n\n- Volume: 매초 생성되는 데이터의 양은 엄청나게 많습니다. 소셜 미디어 업데이트부터 거래 기록까지 규모는 거대합니다.\n- Velocity: 데이터는 이례적으로 빠른 속도로 생성되며, 실시간 또는 거의 실시간 처리가 요구됩니다.\n- Variety: 데이터는 다양한 형식으로 제공됩니다 - 구조화된, 반구조화된 그리고 비구조화된 데이터 형식으로, 텍스트, 이미지, 비디오 등이 있습니다.\n- Veracity: 데이터의 품질과 정확도는 매우 다양할 수 있으며, 신중한 데이터 관리 및 처리 기술이 필요합니다.\n\nPython은 간단함과 데이터 처리 및 분석을 위한 강력한 라이브러리가 많이 제공되어 인기 있는 언어입니다. Python이 빅 데이터 기술과 어떻게 결합되는지 알아봅시다.\n\n![Python을 위한 빅 데이터 이미지](/TIL/assets/img/2024-07-12-PythonforBigData_0.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 대용량 데이터 처리를 위해 PySpark와 같은 라이브러리 사용하기\n\n## PySpark 소개\n\nPySpark는 대규모 데이터 처리를 위한 오픈 소스 통합 분석 엔진인 Apache Spark의 파이썬 API입니다. Spark는 암시적 데이터 병렬 처리와 오류 허용을 통해 전체 클러스터를 프로그래밍하는 인터페이스를 제공합니다.\n\n## PySpark 설정하기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nPySpark을 사용하려면 먼저 설치해야 합니다. PySpark는 다음과 같이 pip을 통해 설치할 수 있습니다:\n\n```js\npip install pyspark\n```\n\n## PySpark을 사용한 기본 작업\n\nPySpark를 사용하여 몇 가지 기본 작업을 살펴보겠습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nSparkSession을 초기화하는 방법:\n\n```python\nfrom pyspark.sql import SparkSession\n\nspark = SparkSession.builder \\\n    .appName(\"BigDataWithPySpark\") \\\n    .getOrCreate()\n```\n\n데이터 읽기:\n\n다양한 소스에서 데이터를 읽을 수 있습니다. CSV 파일을 읽는 예제는 다음과 같습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ndf = spark.read.csv(\"파일경로/당신의/csv파일.csv\", header=True, inferSchema=True)\n```\n\n데이터 변환 수행하기:\n\nPySpark 데이터프레임은 강력한 데이터 처리 기능을 제공합니다. 여기에 일반적인 변환 작업 몇 가지가 있습니다:\n\n```js\n# 특정 열 선택\ndf_selected = df.select(\"column1\", \"column2\")\n\n# 행 필터링\ndf_filtered = df.filter(df[\"column1\"] \u003e 50)\n\n# 그룹화 및 집계\ndf_grouped = df.groupBy(\"column2\").agg({\"column1\": \"mean\"})\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n실행 중인 작업:\n\n작업은 DataFrame에 대한 변환 실행을 트리거합니다:\n\n```js\n# DataFrame 표시\ndf.show()\n\n# 결과를 로컬 리스트로 수집\ndata = df.collect()\n```\n\n예시: PySpark를 사용한 단어 카운트\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n큰 데이터 처리의 고전적인 예로 단어 수 세기 문제가 있습니다.\n\n```python\n# 텍스트 파일에서 RDD 생성\ntext_file = spark.sparkContext.textFile(\"경로/텍스트파일.txt\")\n\n# 단어 수 세기 수행\nword_counts = text_file.flatMap(lambda line: line.split(\" \")) \\\n    .map(lambda word: (word, 1)) \\\n    .reduceByKey(lambda a, b: a + b)\n\n# 결과 수집\nresults = word_counts.collect()\nfor word, count in results:\n    print(f\"{word}: {count}\")\n```\n\n## 파이썬을 하둡 및 다른 빅데이터 기술과 통합하기\n### 하둡 및 HDFS\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하둡은 대규모 데이터 집합의 분산 처리를 위해 컴퓨터 클러스터 간에 사용되는 프레임워크입니다. 하둡 분산 파일 시스템 (HDFS)은 방대한 양의 데이터를 저장하고 고 처리량 액세스를 제공하기 위해 설계되었습니다.\n\n## PyArrow를 사용하여 HDFS에 액세스하기\n\nPyArrow는 인메모리 데이터를 처리하기 위한 크로스-언어 개발 플랫폼입니다. 이를 사용하여 HDFS와 상호작용할 수 있습니다.\n\nPyArrow 설치 방법:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\npip install pyarrow\n```\n\nHDFS와 상호 작용하기:\n\n```js\nimport pyarrow.fs as fs\n\n# HDFS에 연결하기\nhdfs = fs.HadoopFileSystem('hdfs://your-hdfs-namenode:8020')\n\n# HDFS 디렉토리의 파일 목록 가져오기\nfiles = hdfs.get_file_info(fs.FileSelector('/path/in/hdfs'))\n\nfor file in files:\n    print(file)\n```\n\n## Apache Hive 통합\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nHive은 SQL을 사용하여 분산 저장소에 저장된 대규모 데이터 세트의 읽기, 쓰기 및 관리를 용이하게 하는 데이터 웨어하우스 소프트웨어입니다.\n\n## PyHive를 사용하여 Hive에 연결하는 방법\n\nPyHive 설치하기:\n\n```js\npip install pyhive\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파이썬에서 Hive 쿼리하기:\n\n```js\nfrom pyhive import hive\n\n# Hive에 연결\nconn = hive.Connection(host='your-hive-server', port=10000, username='your-username')\n\n# 쿼리 실행\ncursor = conn.cursor()\ncursor.execute(\"SELECT * FROM your_table LIMIT 10\")\n\n# 결과 가져오기\nresults = cursor.fetchall()\nfor row in results:\n    print(row)\n```\n\n## Apache Kafka와 통합\n\nKafka는 하루에 수조 건의 이벤트를 처리할 수 있는 분산 이벤트 스트리밍 플랫폼입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Kafka 통합을 위한 Kafka-Python 사용하기\n\nKafka-Python 설치:\n\n```js\npip install kafka-python\n```\n\n메시지 생성 및 소비:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nfrom kafka import KafkaProducer, KafkaConsumer\n\n# Kafka 프로듀서 생성\nproducer = KafkaProducer(bootstrap_servers='your-kafka-broker:9092')\nproducer.send('your_topic', b'This is a test message')\n\n# Kafka 컨슈머 생성\nconsumer = KafkaConsumer('your_topic', bootstrap_servers='your-kafka-broker:9092')\nfor message in consumer:\n    print(message.value.decode('utf-8'))\n```\n\n## Python이 대용량 데이터 처리에 적합한 이유\n\n다양한 생태계: Python은 복잡한 데이터 처리 작업을 간단하게 만드는 라이브러리와 프레임워크가 풍부한 생태계를 자랑합니다. 예를 들어, PySpark는 Apache Spark의 강력한 기능을 활용하여 대규모 데이터 처리를 쉽게 처리하고, PyArrow는 HDFS와의 원활한 상호작용을 용이하게 합니다.\n\n학습과 사용의 용이성: Python의 문법은 깨끗하고 배우기 쉬워 초보자부터 숙련된 프로그래머까지 접근하기 쉽습니다. 이러한 사용의 용이성은 개발 프로세스를 가속화시켜 빠른 프로토타이핑과 반복을 가능하게 합니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n확장성: 파이썬은 하둡, 하이브, 카프카와 같은 강력한 빅데이터 기술과 통합되어 있어, 응용 프로그램이 대규모 데이터 세트의 요구를 충족하기 위해 확장 가능합니다. 이 확장성은 실시간으로 데이터를 처리하고 분석해야 하는 비즈니스에 중요합니다.\n\n커뮤니티 지원: 파이썬 커뮤니티는 크고 활발하여 지속적으로 새로운 도구를 개발하고 기존 도구를 개선하고 있습니다. 이 활기찬 커뮤니티 지원은 파이썬이 빅데이터 기술 분야의 기술적 발전을 선도하고 있음을 의미합니다.\n\n## 실용적인 응용분야\n\n파이썬이 빅데이터 분야에서 활용되는 실용적인 응용분야는 매우 다양하고 광범위합니다. 각 산업의 기업들이 파이썬을 활용하여 데이터로부터 통찰을 얻고 있습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n금융: 금융 기관은 부정 행위 감지, 리스크 관리 및 알고리즘 거래에 파이썬을 사용합니다. 거래 및 시장 데이터의 대량 데이터 세트를 처리하고 분석하여 패턴을 식별하고 신중한 결정을 내립니다.\n\n건강 관리: 의료 분야에서는 예측 분석, 환자 데이터 관리 및 맞춤 의료에 파이썬을 사용합니다. 의료 기록과 연구 데이터의 대량을 분석하여 환자 결과를 개선하고 운영을 최적화합니다.\n\n소매: 소매업체는 고객 행동을 분석하고 재고를 관리하며 마케팅을 맞춤화하는 데 파이썬을 사용합니다. 빅데이터 분석을 통해 구매 패턴을 이해하고 고객 경험을 향상시킵니다.\n\n제조업: 제조업체는 예측 유지보수, 공급망 최적화 및 품질 관리를 위해 파이썬을 활용합니다. 센서 데이터와 생산 지표를 분석하여 효율성을 향상시키고 다운타임을 줄이는 데 도움을 줍니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 미래 전망\n\n데이터 양이 기하급수적으로 증가함에 따라 효율적이고 확장 가능한 데이터 처리 솔루션이 더욱 중요해질 것입니다. Python은 계속해서 이러한 변화하는 환경에서 중심적인 역할을 하게 될 것입니다.\n\n머신 러닝과 인공 지능: Python은 TensorFlow, Keras, scikit-learn과 같은 머신 러닝 라이브러리와의 통합을 통해 고급 분석 및 대용량 데이터로부터 학습하는 AI 모델의 개발을 가능케 합니다.\n\n실시간 분석: 실시간 분석의 필요성이 더욱 두드러지게 되고 있습니다. Python은 Apache Kafka와 같은 스트리밍 데이터 플랫폼과 작업할 수 있는 능력을 통해 기업이 데이터가 도착하는 대로 신속하게 반응하여 적시에 통찰력과 조치를 제공할 수 있도록 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n데이터 프라이버시와 보안: 데이터 프라이버시와 보안에 대한 관심이 증가함에 따라, Python은 데이터 마스킹, 암호화 및 규정 준수 기능에 대한 능력이 더욱 중요해지고 있습니다. 데이터가 안전하게 처리되고 저장되는 동시에 규정 준수를 유지하는 것이 매우 중요합니다.\n\n클라우드 통합: 데이터 저장 및 처리를 위한 클라우드 기반 솔루션으로의 이전이 계속해서 확대되고 있습니다. Python의 AWS, Azure, Google Cloud와 호환되는 특성은 확장 가능하고 비용 효율적인 빅 데이터 솔루션을 제공합니다.\n\n요약하면, Python은 빅 데이터 분야에서 다양하고 지속적으로 확장되는 역할을 하고 있습니다. 견고한 생태계, 사용 편의성 및 강력한 통합을 통해 대규모 데이터 처리 작업에 대한 필수 언어가 되었습니다. 분산 컴퓨팅을 위한 PySpark, HDFS 상호작용을 위한 PyArrow, 대규모 데이터 쿼리를 위한 PyHive, 이벤트 스트림 처리를 위한 Kafka-Python을 통해 Python은 데이터 전문가가 방대한 데이터 집합에서 의미 있는 통찰을 얻을 수 있도록 도와줍니다.\n\n산업이 빅 데이터의 파워를 활용할수록, Python은 데이터 분석의 중심요소로 남아 있을 것이며 혁신을 주도하고 더 스마트한 의사 결정을 가능하게 합니다. Python의 새로운 기술과 트렌드에 대한 적응력은 빅 데이터 분석 분야에서 매우 중요한 도구로 남을 것을 보장합니다. 빅 데이터를 위해 Python을 수용함으로써 현재의 데이터 문제를 해결할뿐만 아니라 미래 기술 발전을 이용해 지속적인 성장과 경쟁 우위를 확보할 수 있도록 조직을 준비시킬 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n귀하는 소중한 지원을 해주셨습니다. 만약 이 글이 유익하거나 통찰력을 준다면 박수를 부탁드리겠습니다. 제 작품을 계속해서 업데이트하려면 저를 Medium에서 팔로우해주세요. 읽어주시고 글에 참여해주셔서 감사드립니다!","ogImage":{"url":"/TIL/assets/img/2024-07-12-PythonforBigData_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-PythonforBigData_0.png","tag":["Tech"],"readingTime":12},{"title":"리소스가 제한된 시스템을 위한 Quantized Mistral 7B vs TinyLlama 비교분석","description":"","date":"2024-07-12 20:59","slug":"2024-07-12-QuantizedMistral7BvsTinyLlamaforResource-ConstrainedSystems","content":"\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-QuantizedMistral7BvsTinyLlamaforResource-ConstrainedSystems_0.png\" /\u003e\n\n프랑스 스타트업인 Mistral이 공개한 오픈 소스 언어 모델 Mistral 7B를 소개하면서 ChatGPT나 claude.ai와 같은 전용 모델이 보여준 놀라운 성능이 오픈 소스 커뮤니티에서도 이용 가능해졌습니다. 이 모델을 리소스가 제한된 시스템에서 사용할 수 있는 가능성을 탐색하기 위해 양자화된 버전은 훌륭한 성능을 유지했습니다.\n\n이전 연구에서 2비트 양자화된 Mistral 7B 모델이 정확성 테스트를 훌륭히 통과했지만, 맥에서 질문에 대한 평균 응답 시간이 약 2분이 걸리는 문제가 있었습니다. 그래서 Llama 2와 동일한 아키텍처와 토크나이저를 사용한 3조 토큰으로 사전학습된 1.1B 언어 모델인 TinyLlama[1]이 출시되었습니다. 이 모델은 더 많은 리소스가 제한된 환경을 위해 고안되었습니다.\n\n이 기사에서는 양자화된 Mistral 7B와 양자화된 TinyLlama 1.1B의 질문-응답 능력의 정확성과 응답 시간 성능을 앙상블 검색 증강 생성 (RAG) 설정에서 비교할 것입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n목차\n- 활성화 기술\n- 시스템 아키텍처\n- 환경 설정\n- 구현\n- 결과 및 토론\n- 최종 생각\n\n## 활성화 기술\n\n이 테스트는 8GB RAM을 장착한 MacBook Air M1에서 수행됩니다. 계산 및 메모리 자원이 제한되어 있기 때문에 우리는 이 LLM들의 양자화된 버전들을 채택하고 있습니다. 본질적으로 양자화란 모델의 매개변수를 더 적은 비트로 표현하는 것을 의미하며, 이는 모델을 압축하는 효과를 냅니다. 이 압축은 메모리 사용량을 줄이고 더 빠른 실행 시간 및 증가된 에너지 효율성을 가져오지만 정확도를 희생해야 합니다. 이 연구에서는 2비트 양자화된 Mistral 7B Instruct 및 5비트 양자화된 TinyLlama 1.1B Chat 모델을 GGUF 형식으로 사용할 것입니다. GGUF는 모델의 빠른 로딩과 저장을 위해 설계된 이진 형식입니다. 이러한 GGUF 모델을 로드하기 위해 llama-cpp-python 라이브러리를 사용할 것입니다. llama-cpp-python은 llama.cpp 라이브러리에 대한 Python 바인딩입니다.\n\n검색 증가 생성 (RAG)은 LLM의 출력을 향상시키는 과정으로, 응답 생성 이전에 교육 데이터 소스 외부의 신뢰할 수 있는 지식 베이스를 참조하는 것입니다. RAG 응용 프로그램은 문헌에서 관련 문서 조각을 검색하기 위한 검색기 시스템과, 검색된 조각을 컨텍스트로 사용하여 응답을 생성하는 LLM으로 구성됩니다. 검색기는 RAG의 주요 요소이며, 전체 질문-답변 (QA) 시스템의 성능에 상당한 영향을 미칩니다. LLM과 함께 작업할 수 있는 강력한 프레임워크 라이브러리인 LangChain은 재견러(EnsembleRetriever)를 포함하고 있습니다. 재견러는 입력으로 검색기 목록을 받아 상호 순위 조합 알고리즘을 기반으로 결과를 조합하고 재정렬합니다. 서로 다른 알고리즘의 장점을 활용함으로써, 과거에 더 높은 정확도를 달성했다는 것을 보여주었습니다. 본 문서에서 우리는 앙상블을 위해 BM25 검색기와 FAISS 검색기를 0.3:0.7 비율로 결합할 것입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이러한 지원 요소를 모두 함께 가져오기 위해 시스템 아키텍처를 살펴보겠습니다.\n\n# 시스템 아키텍처\n\n이전 글에서 소개한 모듈식 아키텍처를 재사용할 것입니다. 아래와 같이: \n\n![아키텍처 이미지](/TIL/assets/img/2024-07-12-QuantizedMistral7BvsTinyLlamaforResource-ConstrainedSystems_1.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 QA 시스템에는 세 가지 모듈이 있습니다:\n\n- 첫 번째 모듈은 온라인 PDF 문서를 로드하고 벡터화하는 작업을 포함합니다.\n- 두 번째 모듈은 양자화된 LLM을 로드하고 FAISS 리트리버를 인스턴스화하며 FAISS와 BM25 리트리버로 구성된 앙상블 리트리버 인스턴스를 만드는 작업을 포함합니다. 이후 LLM, 앙상블 및 사용자 정의 프롬프트를 포함하는 리트리버 체인을 생성합니다.\n- 세 번째 모듈은 이 RAG를 위한 도우미 모듈로 작동합니다. 이 모듈은 코사인 유사도 및 모델 응답 시간을 계산하여 질문 세트 전체에서 LLM 성능을客客하게하게 합니다.\n\n구현을 살펴보기 전에, 환경 설정을 먼저 해보겠습니다.\n\n# 환경 설정\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기서 사용하는 Python 버전은 3.10.5입니다. 이 프로젝트를 관리하기 위해 가상 환경을 생성할 거에요. 환경을 생성하고 활성화하기 위해 다음 단계를 따라봐요:\n\n```bash\npython3.10 -m venv mychat\nsource mychat/bin/activate\n```\n\n이제 모든 필요한 라이브러리를 설치하러 가볼까요? (의존 라이브러리도 함께 설치됩니다):\n\n```bash\npip install langchain==0.0.259\npip install faiss-cpu\npip install rank_bm25\npip install sentence_transformers\nCMAKE_ARGS=\"-DLLAMA_METAL=on\" FORCE_CMAKE=1 pip install --upgrade --force-reinstall llama-cpp-python --no-cache-dir\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n최근에 langchain이 리팩토링되었기 때문에 코드에 사용된 특정 버전이 위에 표시되어 있습니다. M1 프로세서에서 하드웨어 가속화를 사용하여 llama-cpp-python 라이브러리를 사용하려면 위의 마지막 설치 명령어는 Metal 지원을 활성화합니다. Metal을 사용하면 연산이 GPU에서 실행됩니다.\n\nfaiss-cpu는 GPU가 아닌 CPU를 사용하여 밀도가 높은 벡터의 유사성 검색 및 클러스터링을 위한 효율적인 라이브러리입니다. Okapi BM25로도 알려진 rank_bm25는 문서가 주어진 검색 쿼리와 얼마나 관련되는지를 추정하는 랭킹 함수입니다. sentence-transformers는 문장 및 기타 것들의 임베딩을 계산하는 간단한 방법을 제공합니다.\n\n이제 코드를 살펴볼 준비가 되었습니다.\n\n# 구현\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저희 시스템 아키텍처에 따르면 LoadVectorize, LLMPerfMonitor 및 주요 모듈이 총 3개의 모듈이 있습니다. 처음 두 모듈은 수정 없이 이전 연구에서 재사용되었습니다. 첫 번째 모듈에서 로드된 샘플 문서는 최근 출시된 600페이지 이상의 가속화 장치 가이드인 SteelHead입니다.\n\nLLM을 로드하기 위해 LlamaCpp 인스턴스를 일반적인 모델 매개변수로 인스턴스화할 것입니다. 모델 GGUF 파일은 이미 미리 다운로드되어 특정 디렉토리에 저장되어 있습니다. Mistral 7B Instruct 또는 TinyLlama Chat 모델을 로드하려면 LlamaCpp 인스턴스의 model_path 속성에 다른 값이 지정되어야 합니다. 그런 다음 FAISS와 BM25 리트리버가 함께 하는 EnsembleRetriever 인스턴스를 생성할 것입니다. 마지막으로 LLamaCpp 인스턴스, EnsembleRetriever 및 프롬프트로 RetrievalQA 체인을 생성할 것입니다.\n\nMistral 프롬프트는 다음 템플릿을 따릅니다:\n\n`s`[INST] 'context' [/INST]`/s`'question'\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nTinyLlama 프롬프트는 다음과 같습니다:\n\n\n|system| 'context' \u003c/s\u003e |user| 'question' \u003c/s\u003e |assistant|\n\n\n따라서, 아래 코드 목록은 TinyLlama 애플리케이션의 메인 모듈을 나타냅니다.\n\n```python\n# main.py\nfrom langchain.retrievers import EnsembleRetriever\nfrom langchain.chains import RetrievalQA\nfrom langchain.prompts import PromptTemplate\nfrom langchain.llms import LlamaCpp\nimport LoadVectorize\nimport LLMPerfMonitor\nimport timeit\n\n# Prompt template \nqa_template = \"\"\"\u003c|system|\u003e\nYou are a friendly chatbot who always responds in a precise manner. If answer is \nunknown to you, you will politely say so.\nUse the following context to answer the question below:\n{context}\u003c/s\u003e\n\u003c|user|\u003e\n{question}\u003c/s\u003e\n\u003c|assistant|\u003e\n\"\"\"\n\n# Create a prompt instance \nQA_PROMPT = PromptTemplate.from_template(qa_template)\n\nllm = LlamaCpp(\n    model_path=\"../models/tinyllama_gguf/tinyllama-1.1b-chat-v1.0.Q5_K_M.gguf\",\n    temperature=0.01,\n    max_tokens=2000,\n    top_p=1,\n    verbose=False,\n    n_ctx=2048\n)\n# load doc, vectorize and create retrievers\ndb,bm25_r = LoadVectorize.load_db()\nfaiss_retriever = db.as_retriever(search_type=\"mmr\", search_kwargs={'fetch_k': 3}, max_tokens_limit=1000)\nr = 0.3 # ensemble ratio\nensemble_retriever = EnsembleRetriever(retrievers=[bm25_r,faiss_retriever],weights=[r,1-r])\n# Custom QA Chain \nqa_chain = RetrievalQA.from_chain_type(\n    llm,\n    retriever=ensemble_retriever,\n    chain_type_kwargs={\"prompt\": QA_PROMPT}\n)\n\n# List of questions \nqa_list = LLMPerfMonitor_EN.get_questions_answers()\nprint('model;question;cosine;resp_time')\nfor i,query in enumerate(qa_list[::2]):\n   start = timeit.default_timer()\n   result = qa_chain({\"query\": query})\n   cos_sim = LLMPerfMonitor_EN.calc_similarity(qa_list[i*2+1],result[\"result\"])\n   time = timeit.default_timer() - start # seconds\n   print(f'bm25-{r:.1f}_f-{1-r:.1f};Q{i+1};{cos_sim:.5};{time:.2f}')\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결과 및 토의\n\n응답의 정확성을 이해하기 위해 모델 응답과 전문가의 샘플 답변 사이의 코사인 유사도를 계산했습니다. 예를 들어, 다음은 두 모델에 대해 질문을 제시한 것입니다:\n\n이 질문에 대한 답변은 SteelHead RiOS v9.7입니다. 각 모델의 응답은 아래와 같습니다.\n\n두 LLM이 올바른 코드 버전을 식별할 수 있었습니다. 그러나 둘 다 추가 세부 정보를 포함한 응답이 완전히 정확하지는 않습니다. 특히 TinyLlama에 대해서는 좋은 결과입니다. 10개의 질문에 대한 정확도는 도형 2에 트리맵 차트로 나타냈습니다. Treemap은 내재적 분류 체계를 사용하여 데이터를 효과적으로 표현할 수 있으며 선택한 측정 항목의 크기와 색상 음영을 사용하여 구분할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 표는 마크다운 형식으로 변환해 주세요.\n\n이미지는 래이블을 명시해 볼 수는 있지만, Markdown은 이미 HTML인 요소보다 더 적합하고, 깨끗한 마크업을 보여주는 방법입니다. 역할에 따라 Markdown의 사용은 더 효과적일 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n선택한 질문에 대한 결과를 기반으로 보면, TinyLlama는 정확성 측면에서 꽤 잘 수행했습니다. 더 중요한 점은 더 정확한 Mistral 7B 모델보다 훨씬 더 빠르게 응답할 수 있었습니다. 주장대로라면, TinyLlama는 자원이 제한된 시스템에서 좋은 성능을 보이는 모델로 보입니다.\n\n#최종 생각\n\n몇 달 전 Mistral 7B 모델이 소개된 이후, 오픈 소스 LLM은 정확도에서 큰 발전을 이루었습니다. 내부 문서에서 이 모델이 훈련되지 않았더라도, 우리는 검색 보감 생성(RAG) 설정에서 이 능력을 활용할 수 있습니다. 그러나 이러한 대형 모델을 자원이 제한된 환경에서 실행하는 것은 완전히 현실적이지는 않습니다. 이 곳에서 양자화는 모델의 매개변수에 사용된 비트 수를 줄이는 데 도움이 됩니다. 게다가, 자원 풋프린트가 작은 모델들이 이러한 제한된 환경을 위해 소개되었고, TinyLlama가 그러한 모델 중 하나입니다.\n\n이 기사에서 우리는 정량화된 Mistral 7B Instruct와 TinyLlama 1.1B Chat의 정확성과 질문 응답 시간을 비교했습니다. 정확성 측면에서 큰 모델 Mistral 7B가 TinyLlama보다 여전히 우수하지만, 응답 시간 측면에서 TinyLlama의 응답이 Mistral 7B보다 훨씬 빨랐습니다. 한 예에서 TinyLlama의 응답 시간이 Mistral 7B보다 17배 빨랐습니다. 따라서 정확도에 약간의 하락이 허용되는 애플리케이션의 경우, TinyLlama는 자원이 제한된 시스템에 완벽하게 적합합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안녕하세요!\n\n# 참고 자료\n\n[1] https://huggingface.co/TinyLlama/TinyLlama-1.1B-Chat-v1.0\n[2] https://python.langchain.com/docs/modules/data_connection/retrievers/ensemble\n[3] Mistral 7B를 사용하여 앙상블 리트리버의 컨텍스트와 함께 내부 문서 조사하기","ogImage":{"url":"/TIL/assets/img/2024-07-12-QuantizedMistral7BvsTinyLlamaforResource-ConstrainedSystems_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-QuantizedMistral7BvsTinyLlamaforResource-ConstrainedSystems_0.png","tag":["Tech"],"readingTime":11},{"title":"Pandas DataFrame에 데이터 로드하는 방법","description":"","date":"2024-07-12 20:58","slug":"2024-07-12-PandasLoadingdataintoaDataFrame","content":"\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-PandasLoadingdataintoaDataFrame_0.png\" /\u003e\n\n판다스는 파이썬 데이터 라이브러리 중 주축에 서 있으며, 데이터 조작을 위한 다양한 함수 보물 묶음을 제공합니다. 핵심은 데이터프레임(DataFrame)으로, 이를 사용하여 테이블 형식의 데이터를 쉽게 저장하고 조작할 수 있습니다.\n\n## 타이타닉 데이터셋 불러오기\n\n다음은 캐글(Kaggle)에서 다운로드할 수 있는 데이터셋 링크입니다. [링크 바로가기](https://www.kaggle.com/competitions/titanic/data?select=train.csv)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![Pandas Loading Data into a DataFrame](/TIL/assets/img/2024-07-12-PandasLoadingdataintoaDataFrame_1.png)\n\n타이타닉 데이터셋은 카글에서 제공하는 클래식한 챌린지로, 비극적인 타이타닉 호에 탑승한 승객들에 대한 데이터를 제공합니다. 이 데이터셋을 Pandas DataFrame으로 로드해보겠습니다:\n\n```python\nimport pandas as pd\n# 타이타닉 데이터셋 로드\ntitanic_df = pd.read_csv('train.csv')\n# 처음 몇 행 확인\nprint(titanic_df.head())\n```\n\n이 코드 조각은 타이타닉 CSV 파일을 DataFrame으로 읽어와 우리가 분석할 데이터를 엿볼 수 있도록 해줍니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n더 깊게 파기\n\n이제, 판다스를 사용하여 타이타닉 데이터셋에서 수행할 수 있는 몇 가지 더 많은 작업을 살펴봅시다:\n\n생존율 분석\n\n타이타닉에 관한 가장 감동적인 질문 중 하나는 생존과 관련이 있습니다. 우리는 판다스를 사용하여 다양한 기능에 기반한 생존율을 분석할 수 있습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 클래스별 생존률 계산\n생존률 = titanic_df.groupby('Pclass')['Survived'].mean()\nprint(생존률)\n```\n\n이 코드는 승객 클래스별로 데이터를 그룹화하고 각 클래스의 평균 생존률을 계산합니다.\n\n기능 엔지니어링: 가족 규모 열 생성\n\n기존 데이터에서 새로운 기능을 만들어 추가 정보를 얻을 수 있습니다. 예를 들어 'FamilySize' 열을 만들어보겠습니다:\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# Create a new column for family size\ntitanic_df['FamilySize'] = titanic_df['SibSp'] + titanic_df['Parch'] + 1\n# Analyze survival rates by family size\nfamily_survival = titanic_df.groupby('FamilySize')['Survived'].mean()\nprint(family_survival)\n```\n\n이 코드 블록은 DataFrame에 새 열을 추가하고, 그런 다음 가족 규모별로 데이터를 그룹화하여 생존율에 영향을 미쳤는지 확인합니다.\n\n로딩 매개변수 조정\n\n데이터를 로드하는 방식을 더 세밀하게 조정해야 할 때가 있습니다. Pandas는 이 과정을 세밀하게 조정할 수 있는 많은 매개변수를 제공합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 행을 건너뛰고 누락된 값 설정 및 열 제한을 위한 매개변수 조정\ndf = pd.read_csv('train.csv', skiprows=4, na_values=['?'], usecols=['Name', 'Sex', 'Age'])\n```\n\n여러분은 행을 건너뛰고 누락된 값 처리를 할 수 있으며 특정 열만을 선택하여 로드할 수 있습니다.\n\nDataFrame 미리보기\n\n로드된 후에는 모든 것이 올바르게 보이는지 확인하기 위해 DataFrame을 미리보는 것이 좋습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\n# DataFrame의 첫 몇 행 미리보기\nprint(df.head())\n# DataFrame의 마지막 몇 행 미리보기\nprint(df.tail())\n```\n\n이러한 방법들은 데이터를 로드한 후 빠르게 데이터의 개요를 제공해줍니다.\n\n요약 통계량 사용하기\n\n판다스는 요약 통계량을 통해 데이터의 포괄적인 개요를 제공하는 데 뛰어납니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n# Get summary statistics for numerical columns\nprint(df.describe())\n# Get summary statistics for all columns including categorical\nprint(df.describe(include='all'))\n\n\n이 명령어들은 데이터셋의 중심 경향성, 분산 및 형태를 요약하는 기술통계를 생성합니다.\n\n# 동물원 프로젝트의 더 많은 예제\n\n배운 내용을 더 실용적으로 적용해 보겠습니다 — 동물원 프로젝트입니다. 데이터를 로드하고 정리한 다음, 각 동물 종에 대한 평균 식량 필요량을 계산해 봅시다:\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 동물원 데이터 분석\nzoo_df = pd.read_csv('zoo_data.csv')\n# 데이터 정제\nzoo_df.dropna(inplace=True)\n# 종 별 평균 사료 소비량 계산\naverage_food = zoo_df.groupby('species')['food_per_day'].mean()\nprint(average_food)\n```\n\n메소드 체이닝: 코드를 더 깔끔하게 작성하는 방법\n\n판다스의 메소드 체이닝을 사용하면 한 줄 안에 여러 작업을 쉽게 수행할 수 있습니다. 각 메소드가 다음으로 자연스럽게 이어지는 책의 장이라고 생각해보세요.\n\n```js\nimport pandas as pd\n# 샘플 동물원 데이터\ndata = {\n    'Animal': ['사자', '호랑이', '곰', '얼룩말'],\n    '이름': ['레오', '줄무늬', '발루', '자라'],\n    '나이': [5, 7, 3, 4],\n    '무게': [250, 220, 350, 380]\n}\nzoo_df = pd.DataFrame(data)\n# 메소드 체이닝 예시\nzoo_df.assign(월령=lambda x: x['나이'] * 12).sort_values(by='나이')\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 예에서 우리는 먼저 나이를 월로 변환한 다음 나이를 기준으로 DataFrame을 정렬합니다. 이 모든 작업을 한 표현식으로 처리합니다. 이렇게 하면 코드가 더 깔끔해지고 더 효율적으로 됩니다. \n\n```js\n결과\n  동물 이름   나이   무게  월 단위 나이\n2 Bear   Baloo   3   350       36\n3 Zebra  Zara    4   380       48\n0 Lion   Leo     5   250       60\n1 Tiger  Stripes 7   220       84\n```\n\n데이터 정렬 및 순위 매기기: 데이터 조직화\n\n데이터를 정렬하는 것은 가장 중요한 항목이나 덜 중요한 항목을 분석할 때 중요합니다. 판다스는 이러한 작업을 위해 sort_values() 및 sort_index()를 제공합니다. 반면에 순위 매기기는 데이터에 순위를 할당하여 리더보드와 유사하게 만듭니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 체중순으로 정렬\nsorted_zoo = zoo_df.sort_values(by='Weight', ascending=False)\n# 나이순으로 동물 순위 매기기\nzoo_df['Age_rank'] = zoo_df['Age'].rank(method='min', ascending=False)\n```\n\n데이터 걸러내기 및 그룹화: 데이터 살펴보기\n\n필터링을 통해 특정 기준을 충족하는 데이터만 볼 수 있습니다. groupby()와 함께 사용되는 그룹화로 카테고리화된 데이터에 대한 작업을 수행할 수 있습니다.\n\n```js\n# 300 파운드 이상의 동물 필터링\nheavy_animals = zoo_df[zoo_df['Weight'] \u003e 300]\n# 동물 종류별로 그룹핑하여 평균 체중 계산\navg_weight_by_animal = zoo_df.groupby('Animal')['Weight'].mean()\n우리의 동물 데이터셋에 대한 통찰을 제공하기 위해 동물공원 프로젝트를 위한 복잡한 코드 예제를 함께 구성해 보겠습니다. 동물원 주민을 필터링, 정렬, 순위 매기는 메소드를 연쇄적으로 적용하여 데이터를 처리할 것입니다.\n# 동물원 프로젝트를 위한 복잡한 메소드 체이닝\n(zoo_df\n  .query('Weight \u003e= 200')\n  .assign(Age_in_months=lambda x: x['Age'] * 12)\n  .sort_values(by=['Animal', 'Age_in_months'], ascending=[True, False])\n  .groupby('Animal')\n  .agg({'Name': 'first', 'Age_in_months': 'max', 'Weight': 'mean'})\n  .rename(columns={'Name': 'Oldest_Animal', 'Age_in_months': 'Oldest_Age', 'Weight': 'Avg_Weight'})\n  .reset_index()\n)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n결과\n    동물      가장 나이 많은 동물    가장 나이     평균 무게\n0    곰       발루           36            50.0\n1    사자      레오           60           250.0\n2    호랑이    스트라이프     84           220.0\n3    얼룩말    자라           48           380.0\n```\n\n이 블록에서는 200 파운드보다 무겁지 않은 동물을 걸러내고, 나이를 개월로 변환하며, 동물 유형과 나이순으로 정렬하여 동물 유형별로 그룹화한 다음, 가장 나이 많은 동물과 평균 무게를 찾기 위해 집계합니다. 이를 통해 데이터를 명확하고 조직적으로 볼 수 있으며, 추가 분석이나 보고에 이상적입니다.\n\n계속해서 찾아주시기 바랍니다 (-̀ᴗ-́ )و\n\n이전 포스트: `- Pandas: 파이썬에서 데이터 분석의 중추`\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음 - Pandas: 데이터 정리 및 변형","ogImage":{"url":"/TIL/assets/img/2024-07-12-PandasLoadingdataintoaDataFrame_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-PandasLoadingdataintoaDataFrame_0.png","tag":["Tech"],"readingTime":9},{"title":"이진 트리 출력용 파이썬 패키지 제작기 재미로 했어요","description":"","date":"2024-07-12 20:57","slug":"2024-07-12-ICreatedAPythonPackageToPrintBinaryTreesForFun","content":"\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-ICreatedAPythonPackageToPrintBinaryTreesForFun_0.png\" /\u003e\n\n이번에 이진 트리와 힙을 다루다가, 나만의 트리를 빠르고 쉽게 표시하고 시각화하는 방법이 필요했어요.\n\n그래서 온라인에서 Python 패키지를 검색해보니 몇 개가 그 역할을 해줄 수 있었어요. 그래도 사용하기가 귀찮은 경우가 많았어요.\n\n기존 솔루션을 사용하고 코드를 약간 더 써가며 내 시간을 낭비하는 대신, 개발자들이 흔히 하는 것처럼, 몇 일을 허비해서 처음부터 내가 직접 패키지를 만들기로 결정했죠.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 내 패키지 — print-btree\n\n내 패키지를 설치하는 방법:\n\n```js\npip install print-btree\n```\n\nGithub: https://github.com/zlliu246/print_btree\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 기본 사용 방법\n\n```js\nfrom print_btree import print_btree\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\n# 이진 트리를 만드세요\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\n\nprint_btree(root)\n\n'''\n\n __1__\n |   |\n_2_  3 \n| |    \n4 5   \n\n'''\n```\n\n만약 이진 트리 Node가 .val .left 및 .right를 사용한다면, print_btree 함수를 간단히 가져와 트리를 출력할 수 있습니다\n\n# 노드가 다른 이름을 사용하는 경우 어떻게 하나요?\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nfrom print_btree import print_btree\n\nclass BNode:\n    def __init__(self, value):\n        self.value = value\n        self.left_node = None\n        self.right_node = None\n\nroot = BNode(1)\nroot.left_node = BNode(2)\nroot.right_node = BNode(3)\nroot.left_node.left_node = BNode(4)\nroot.left_node.right_node = BNode(5)\nroot.right_node.right_node = BNode(100)\n\n# we pass in the names here\nprint_btree(root, \n            val='value',\n            left='left_node',\n            right='right_node')\n\n'''\n\n __1__\n |   |\n_2_  3__\n| |    |\n4 5   100\n\n'''\n```\n\n저희 클래스는 다음과 같이 사용합니다:\n\n- 노드 대신 BNode\n- .val 대신 .value\n- .left 대신 .left_node\n- .right 대신 .right_node\n\n문제없이 이 이름들을 print_btree에 전달할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 일부로 매우 긴 값 이름을 지원합니다\n\n```js\nfrom print_btree import print_btree\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nroot = Node('apple')\nroot.left = Node('pie')\nroot.right = Node('juice')\nroot.left.left = Node('pear')\nroot.left.right = Node('pineapplejuice')\nroot.right.right = Node('durian')\n\nprint_btree(root)\n\n'''\n       ________apple________\n       |                   |\n _____pie_____           juice_\n |           |                |\npear   pineapplejuice       durian\n\n'''\n```\n\n물론, Node(`appleorangepearwithcherriesontop`) 같은 값이 들어있는 경우, 출력된 이진 트리 모양은 여전히 잘못 보일 수 있어요\n\n# 빠른 논리 요약\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n가정하에 이진 트리를 출력해야 한다고 가정합시다.\n\n```python\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nroot = Node('apple')\nroot.left = Node('pie')\nroot.right = Node('juice')\nroot.left.left = Node('pear')\nroot.left.right = Node('pineapplejuice')\nroot.right.right = Node('durian')\n\n'''\n       ________apple________\n       |                   |\n _____pie_____           juice_\n |           |                |\npear   pineapplejuice       durian\n'''\n```\n\n단계 1) 이진 트리를 2D 리스트로 변환하세요.\n\n```python\n# 입력\nroot\n\n# 출력\n[\n    ['apple'],\n    ['pie', 'juice'],\n    ['pear', 'pineapplejuice', None, 'durian']\n]\n\n# 참고: None 값은 순서를 유지하기 위해 유지됩니다.\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테이블 태그를 마크다운 형식으로 변경해주세요.\n\nStep 2) 가장 아래에 있는 목록에서 문자열 생성하기\n\n```js\n['pear', 'pineapplejuice', None, 'durian']\n\n# 다음과 같은 형태로 변환\n\n'pear   pineapplejuice  ?   durian'\n\n# None 값은 ?으로 변환됩니다\n```\n\nStep 3) 이전 문자열에서 값과 일치하는 파이프 |를 포함하는 문자열 생성하기\n\n```js\n# 다음과 같은 문자열에서\n'pear   pineapplejuice  ?   durian'\n\n# 다음을 생성\n' |           |          |    |'\n\n\n# 현재는 트리의 기초만 갖추어져 있습니다\n'''\n |           |         |     |\npear   pineapplejuice  ?   durian\n'''\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\"4단계) 다음으로 아래에 있는 목록에서 문자열 생성하기\n\n```js\n# from \n['pie', 'juice']    # 그리고\n' |        |      |      |  '\n\n# generate\n' _____pie_____           juice_'\n\n\n# 현재 우리가 가지고 있는 것\n'''\n _____pie_____          _juice_\n |           |          |     |\npear   pineapplejuice   ?   durian\n'''\n```\n\n5단계) 루트에 도달할 때까지 단계 3과 4 반복하기\n\n```js\n'''\n _____pie_____          _juice_\n |           |          |     |\npear   pineapplejuice   ?   durian\n'''\n\n# 다음으로\n\n'''\n       |                   |\n _____pie_____          _juice_\n |           |          |     |\npear   pineapplejuice   ?   durian\n'''\n\n# 그리고 아래처럼 변환됩니다\n\n'''\n       ________apple________\n       |                   |\n _____pie_____          _juice_\n |           |          |     |\npear   pineapplejuice   ?   durian\n'''\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론\n\n이 작은 프로젝트가 이진 트리와 힙 등을 다룰 때 조금이나마 도움이 되었으면 좋겠어요.\n\n만약 버그를 발견하거나 이 패키지에 대한 제안이 있으시다면 언제든지 알려주세요!\n\n응원합니다\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 만약 제가 만든 작품을 지원하고 싶다면\n\n- 제 책을 구입해주세요! — 101가지 파이썬에 대해 몰랐던 것들\n- 구입처: [여기를 클릭하세요](https://payhip.com/b/vywcf)\n- 이 이야기에 박수를 50번 치십시오\n- 여러분의 생각을 댓글로 나누어 주세요\n- 이야기 중에서 가장 좋아하는 부분을 강조해 주세요\n\n감사합니다! 이런 작은 동작들이 큰 도움이 되고, 저는 정말로 감사하게 생각합니다!\n\nYouTube: [여기를 클릭하세요](https://www.youtube.com/@zlliu246)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nLinkedIn: [https://www.linkedin.com/in/zlliu/](https://www.linkedin.com/in/zlliu/)","ogImage":{"url":"/TIL/assets/img/2024-07-12-ICreatedAPythonPackageToPrintBinaryTreesForFun_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-ICreatedAPythonPackageToPrintBinaryTreesForFun_0.png","tag":["Tech"],"readingTime":8},{"title":"파이썬으로 AI를 사용해 과학 지식 자동으로 가져오는 방법","description":"","date":"2024-07-12 20:53","slug":"2024-07-12-AutomatingScientificKnowledgeRetrievalwithAIinPython","content":"\n\n\n![Automating Scientific Knowledge Retrieval with AI in Python](/TIL/assets/img/2024-07-12-AutomatingScientificKnowledgeRetrievalwithAIinPython_0.png)\n\n과학 논문, 데이터 집합 및 학술 논문의 거대한 양은 오늘날 연구원, 학자 및 전문가들에게 그들의 분야에서 최신 개발 동향을 따라가기 위한 어려움을 제기합니다.\n\n이러한 도전은 과학적 지식 검색 프로세스를 효율적이고 효과적으로 만드는 혁신적인 접근 방식의 필요성을 강조합니다.\n\nAI 및 의미 검색은 정보 접근 및 상호 작용 방식을 변혁하는 데 놀라운 가능성을 보여 주었습니다. 이러한 혁신의 선두에서는 OpenAI 함수의 응용이 있으며, 자연어 입력을 구조화된 출력이나 함수 호출로 변환합니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예를 들어, 최신 재생 에너지 기술에 대한 질문을 처리해야 할 때 OpenAI의 모델은 최근 논문을 살펴보고 주요 논문과 결과물을 식별하여 연구 트렌드를 요약할 수 있습니다. 특정 키워드에 국한되지 않고 작동할 수 있어요.\n\n이 능력은 연구 과정을 가속화할 뿐만 아니라, 전통적인 검색 방법으로는 즉시 발견하기 어렵거나 연결점과 통찰을 발견하는 데 도움이 됩니다.\n\n이 기사의 목적은 OpenAI 기능과 arXiv API를 활용하여 학술 연구 결과물의 검색, 요약 및 제시를 간소화하는 데 사용할 수 있는 Python 코드를 제공하는 것입니다.\n\n이 안내서의 구성은 다음과 같습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 1. 솔루션 아키텍처\n\n연구 챗봇을 위한 솔루션 아키텍처는 사용자에게 과학적 지식을 처리하고 전달하기 위한 다층 접근 방식을 구체화합니다.\n\n워크플로우는 복잡한 사용자 쿼리를 처리하고 외부 API와 상호작용하여 정보를 제공하는 데 설계되었습니다.\n\n이 아키텍처는 초기 사용자 입력부터 최종 응답 전달까지의 정보 흐름을 용이하게 하는 다양한 구성 요소를 통합합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*fjRg85xwRpokyLaOjM3USg.gif)\n\n1. 사용자 인터페이스 (UI): 사용자는 이 인터페이스를 통해 쿼리를 제출합니다. 이 경우 주피터 노트북에서 제출됩니다.\n\n2. 대화 관리: 이 모듈은 대화를 처리하여 사용자 상호작용 중에 문맥이 유지되도록 합니다.\n\n3. 쿼리 처리: 사용자의 쿼리는 이곳에서 해석되며, 의도를 이해하고 후속 조치를 위해 준비됩니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n4. OpenAI API 통합 (임베딩 및 완성):\n\n- 완성 부분은 일부 쿼리에 대해 즉시 응답을 생성하는 쿼리를 직접 처리합니다.\n- 임베딩 요청은 학술 논문 검색이 필요한 쿼리에 사용되며 관련 문서를 찾기 위한 벡터를 생성합니다.\n\n5. 외부 API (arXiv): 이 부분은 챗봇이 쿼리를 기반으로 arXiv와 같은 외부 데이터베이스와 상호작용하여 과학 논문을 가져오는 곳입니다.\n\n6. 기사 가져오기 \u0026 요약: 이 기능은 기사를 검색한 후 쿼리의 맥락에 따라 요약할 기사를 우선순위로 설정하기 위해 임베딩을 사용합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n7. PDF 처리, 텍스트 추출 및 청킹: 자세한 정보가 필요한 경우, 시스템은 PDF를 처리하고 텍스트를 추출하여 작은 조각으로 나누어 요약 작업을 준비합니다.\n\n8. 응답 생성:\n   - OpenAI API Completion 서비스에서 응답을 통합합니다.\n   - arXiv API에서 검색하고 처리된 논문 요약을 포함하며, 이는 이전에 생성된 임베딩을 기반으로 합니다.\n\n9. 사용자에게 제공: AI가 생성한 답변과 논문 요약을 결합한 응집된 응답이 사용자에게 제공되는 마지막 단계입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 2. Python 시작하기\n\n## 2.1 필수 라이브러리 설치\n\n우리는 다양한 Python 라이브러리를 활용하며, 각각이 특정 기능을 제공하여 과학적 지식의 검색 및 처리를 용이하게 합니다. 각 라이브러리와 역할에 대한 개요는 다음과 같습니다:\n\n- scipy: 과학 계산에 필수적이며, 최적화, 선형 대수, 적분 등을 위한 모듈을 제공합니다.\n- tenacity: 실패한 작업을 다시 시도하는 기능을 제공하며, 외부 API 또는 데이터베이스에 안정적으로 요청을 보내는 데 유용합니다.\n- token: OpenAI 모델과 함께 사용하기 위해 설계된 빠른 BPE 토크나이저로, GPT-4와 같은 AI 모델을 처리하기 위한 텍스트의 효율적인 토큰화를 용이하게 합니다.\n- termcolor: 컬러링된 터미널 출력을 가능하게 하여, 로그 메시지나 디버깅을 편하게 구분할 수 있습니다.\n- openai: GPT-3와 같은 OpenAI API와 상호 작용하기 위한 공식 라이브러리로, AI 모델 응답을 쿼리하고 수신하는 데 중요합니다.\n- requests: 웹 서비스 또는 API에 HTTP 요청을 보내기 위한 라이브러리로, 데이터 검색이나 과학 자원과의 상호 작용에 활용될 수 있습니다.\n- arxiv: arXiv.org의 과학 논문을 검색, 가져오기 및 관리를 간소화합니다.\n- pandas: 대용량 데이터 처리 및 분석에 중요한 역할을 하며, 대규모 데이터 세트를 처리하는 데 사용되는 구조 및 기능을 제공합니다.\n- PyPDF2: PDF 파일로부터 텍스트를 추출할 수 있도록 하며, PDF 형식의 과학 논문을 처리하는 데 필수적입니다.\n- tqdm: 루프나 장기 실행 프로세스에 대한 진행 표시 막대를 생성하여 사용자 경험을 향상시킵니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 2.2 환경 설정하기\n\n먼저 OpenAI 플랫폼에 계정을 만들고 계정 설정의 API 섹션에서 API 키를 얻어야 합니다.\n\n```js\nopenai.api_key = \"API_KEY\"\n\nGPT_MODEL = \"gpt-3.5-turbo-0613\"\nEMBEDDING_MODEL = \"text-embedding-ada-002\"\n```\n\n## 2.3 프로젝트 설정\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다운로드한 논문이나 데이터를 관리하기 위한 구조화된 디렉토리를 만드는 것은 조직화와 쉬운 접근성을 위해 매우 중요합니다. 필요한 디렉토리를 설정하는 방법을 알려드리겠습니다:\n\n- 디렉토리 구조 생성: 프로젝트의 필요에 맞는 구조를 결정하세요. 다운로드한 논문을 관리하기 위해 ./data/papers 디렉토리가 제안됩니다.\n- 구현: Python의 os 라이브러리를 사용하여 이러한 디렉토리의 존재 여부를 확인하고 없는 경우 생성하세요:\n\n```python\nimport os\n\ndirectory = './data/papers'\nif not os.path.exists(directory):\n    os.makedirs(directory)\n```\n\n이 코드 조각을 통해 스크립트가 수동 디렉토리 설정 없이 모든 시스템에서 실행될 수 있도록 보장하여 프로젝트의 이식성과 사용자 친화성을 높일 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 3. 핵심 기능\n\n과학 지식 검색을 용이하게 하는 것을 목적으로 설계된 연구 챗봇은 여러 가지 핵심 기능을 통합하고 있습니다.\n\n자연어 쿼리 처리, 학술 콘텐츠 검색 및 요약, 그리고 고급 NLP 기법을 활용하여 사용자 상호작용을 향상하는 것이 중심입니다.\n\n아래에서는 이러한 기능들을 자세히 설명하며, 그 구현을 보여주는 구체적인 코드 조각을 강조하겠습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 3.1 임베딩 생성\n\n사용자 쿼리를 효과적으로 이해하고 처리하기 위해 챗봇은 임베딩을 활용합니다. 임베딩은 텍스트의 의미를 포착하는 수치적인 표현으로, 이는 과학 논문과 쿼리 간의 관련성을 결정하는 작업에 중요합니다.\n\n```js\n@retry(wait=wait_random_exponential(min=1, max=40), stop=stop_after_attempt(3))\ndef embedding_request(text):\n    response = openai.Embedding.create(input=text, model=EMBEDDING_MODEL)\n    return response['data']['embeddings']\n```\n\n이 함수는 재시도 메커니즘으로 OpenAI API에서 임베딩을 요청하며, 잠재적인 API 오류나 요청 한도에 대응하여 견고성을 보장합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 3.2 학술 논문 검색\n\n쿼리를 이해한 후, 챗봇은 arXiv와 같은 외부 데이터베이스와 직접 통신하는 능력을 보여주며 관련 학술 논문을 가져옵니다.\n\n```js\n# arXiv에서 기사 가져오는 함수\ndef get_articles(query, library=paper_dir_filepath, top_k=5):\n    \"\"\"\n    사용자 쿼리와 관련 있는 상위 'k'개의 학술 논문을 arXiv 데이터베이스에서 검색하고 가져옵니다.\n    이 함수는 arXiv API를 사용하여 논문을 검색하는데, 검색 기준은 사용자 쿼리이고 결과 수는 'top_k'로 제한됩니다.\n    찾은 각 논문에는 제목, 요약, URL과 같은 관련 정보를 리스트에 저장합니다.\n    또한 각 논문의 PDF를 다운로드하고, 제목, 다운로드 경로, 논문 제목의 임베딩을 포함한 참조를 'library'로 지정된 CSV 파일에 저장합니다.\n    나중에 검색 및 분석을 위해 논문과 임베딩을 기록하는 데 유용합니다.\n    이 함수는 read_article_and_summarize에서 사용됩니다.\n    \"\"\"\n    search = arxiv.Search(\n        query=query, max_results=top_k, sort_by=arxiv.SortCriterion.Relevance\n    )\n    result_list = []\n    for result in search.results():\n        result_dict = {}\n        result_dict.update({\"title\": result.title})\n        result_dict.update({\"summary\": result.summary})\n\n        # 첫 번째로 제공된 URL 사용\n        result_dict.update({\"article_url\": [x.href for x in result.links][0]})\n        result_dict.update({\"pdf_url\": [x.href for x in result.links][1]})\n        result_list.append(result_dict)\n\n        # 참조를 라이브러리 파일에 저장\n        response = embedding_request(text=result.title)\n        file_reference = [\n            result.title,\n            result.download_pdf(data_dir),\n            response[\"data\"][0][\"embedding\"],\n        ]\n\n        # 파일에 기록\n        with open(library, \"a\") as f_object:\n            writer_object = writer(f_object)\n            writer_object.writerow(file_reference)\n            f_object.close()\n    return result_list\n```\n\n## 3.3 순위 매기기 및 요약하기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n해당 논문을 손에 쥐고 있으면 시스템은 쿼리와 관련성에 따라 그들을 순위를 매기고 내용을 요약하여 사용자에게 간결하고 통찰력 있는 정보를 제공합니다.\n\n```python\n# 쿼리 문자열과 관련성을 기준으로 문자열을 순위 매기는 함수\ndef strings_ranked_by_relatedness(\n    query: str,\n    df: pd.DataFrame,\n    relatedness_fn=lambda x, y: 1 - spatial.distance.cosine(x, y),\n    top_n: int = 100,\n) -\u003e list[str]:\n\n    \"\"\"\n    함수는 주어진 쿼리 문자열과 관련성을 기준으로 DataFrame에서 문자열 목록을 순위 매기고 반환합니다.\n    함수는 먼저 쿼리 문자열에 대한 임베딩을 얻습니다. 그런 다음 DataFrame의 각 문자열과의 관련성을 계산합니다.\n    여기서 제공된 'relatedness_fn'을 사용하여 쿼리와의 관련성을 계산하며, 기본값은 임베딩 간의 코사인 유사도를 계산합니다.\n    이러한 문자열을 관련성에 따라 내림차순으로 정렬하여 상위 'n'개의 문자열을 반환합니다.\n    \"\"\"\n    query_embedding_response = embedding_request(query)\n    query_embedding = query_embedding_response[\"data\"][0][\"embedding\"]\n\n    strings_and_relatednesses = [\n        (row[\"filepath\"], relatedness_fn(query_embedding, row[\"embedding\"]))\n        for i, row in df.iterrows()\n    ]\n    \n    strings_and_relatednesses.sort(key=lambda x: x[1], reverse=True)\n    strings, relatednesses = zip(*strings_and_relatednesses)\n    return strings[:top_n]\n```\n\n## 3.4 학술 논문 요약\n\n관련 논문을 식별한 후, 챗봇은 과학 문서의 본질을 요약하는 과정을 사용합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\n# 청크를 요약하고 종합 요약을 반환하는 함수\ndef summarize_text(query):\n    \"\"\"\n    사용자 쿼리와 관련된 학술 논문을 요약하는 프로세스를 자동화합니다. 다음을 포함합니다:\n    1. 데이터 읽기: 논문 및 임베딩 정보가 포함된 'arxiv_library.csv'를 읽습니다.\n    2. 관련 논문 식별: 쿼리의 임베딩을 CSV 파일의 임베딩과 비교하여 가장 유사한 항목을 찾습니다.\n    3. 텍스트 추출: 식별된 논문의 PDF를 읽어 내용을 문자열로 변환합니다.\n    4. 텍스트 청킹: 효율적인 처리를 위해 추출된 텍스트를 관리 가능한 청크로 나눕니다.\n    5. 청킹 요약: 각 텍스트 청크는 'extract_chunk' 함수를 사용하여 병렬로 요약됩니다.\n    6. 요약 병합: 개별 요약을 최종 종합 요약으로 결합합니다.\n    7. 요약 제공: 사용자 쿼리와 관련된 주요 통찰을 중점으로 한 논문의 간략한 개요를 제공합니다.\n    \"\"\"\n\n    # 입력된 논문을 재귀적으로 요약하는 방법을 지시하는 메시지\n    summary_prompt = \"\"\"학술 논문의 텍스트를 요약하세요. 이유와 함께 중요한 요점을 추출하세요.\\n\\n내용:\"\"\"\n\n    # 라이브러리가 비어 있는 경우(아직 검색된 항목이 없는 경우) 한 번 수행하고 결과를 다운로드합니다.\n    library_df = pd.read_csv(paper_dir_filepath).reset_index()\n    if len(library_df) == 0:\n        print(\"아직 검색된 논문이 없습니다. 처음으로 다운로드합니다.\")\n        get_articles(query)\n        print(\"논문 다운로드 완료, 계속 진행합니다.\")\n        library_df = pd.read_csv(paper_dir_filepath).reset_index()\n    library_df.columns = [\"title\", \"filepath\", \"embedding\"]\n    library_df[\"embedding\"] = library_df[\"embedding\"].apply(ast.literal_eval)\n    strings = strings_ranked_by_relatedness(query, library_df, top_n=1)\n    print(\"논문에서 텍스트 청킹\")\n    pdf_text = read_pdf(strings[0])\n\n    # 토크나이저 초기화\n    tokenizer = tiktoken.get_encoding(\"cl100k_base\")\n    results = \"\"\n\n    # 문서를 1500 토큰 청크로 분할\n    chunks = create_chunks(pdf_text, 1500, tokenizer)\n    text_chunks = [tokenizer.decode(chunk) for chunk in chunks]\n    print(\"각 텍스트 청크를 요약합니다.\")\n\n    # 요약을 병렬 처리합니다.\n    with concurrent.futures.ThreadPoolExecutor(\n        max_workers=len(text_chunks)\n    ) as executor:\n        futures = [\n            executor.submit(extract_chunk, chunk, summary_prompt)\n            for chunk in text_chunks\n        ]\n        with tqdm(total=len(text_chunks)) as pbar:\n            for _ in concurrent.futures.as_completed(futures):\n                pbar.update(1)\n        for future in futures:\n            data = future.result()\n            results += data\n\n    # 최종 요약\n    print(\"전체 요약으로 요약합니다.\")\n    response = openai.ChatCompletion.create(\n        model=GPT_MODEL,\n        messages=[\n            {\n                \"role\": \"user\",\n                \"content\": f\"\"\"학술 논문에서 추출한 주요 요점을 바탕으로 종합된 요약을 작성합니다.\n                        요약은 핵심 주장, 결론 및 증거를 강조하고 사용자 쿼리에 답변해야 합니다.\n                        사용자 쿼리: {query}\n                        요약은 Core Argument, Evidence, 그리고 Conclusions의 제목을 따라 목록으로 구성되어야 합니다.\n                        주요 요점:\\n{results}\\nSummary:\\n\"\"\",\n            }\n        ],\n        temperature=0,\n    )\n    return response\n```\n\n## 3.5 OpenAI 함수의 통합과 사용\n\n연구용 챗봇은 OpenAI 함수를 활용하여 복잡한 쿼리를 처리하고 응답하기 위한 능력을 향상시킵니다.\n\n이러한 함수들은 챗봇과 다양한 외부 데이터 소스 및 도구 간의 원활한 상호작용을 허용하여 사용자에게 자세하고 정확하며 맥락에 맞는 정보를 제공하여 사용자 경험을 크게 향상시킵니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nOpenAI 함수들은 외부 계산 또는 데이터 검색을 모델의 처리 과정에 직접 통합하여 OpenAI 모델의 기능을 확장하는 데 사용됩니다.\n\n### 3.5.1 사용자 정의 OpenAI 함수\n\n- **get_articles 함수**: 사용자의 쿼리와 관련된 학술 논문을 arXiv 데이터베이스에서 검색하여, 챗봇이 외부 소스에서 실시간 데이터에 접근하는 능력을 보여줍니다.\n- **read_article_and_summarize 함수**: 사용자의 쿼리와 관련된 학술 논문을 arXiv 데이터베이스에서 검색하여, 챗봇이 외부 소스에서 실시간 데이터에 접근하는 능력을 보여줍니다.\n\n구현:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# Function to initiate our get_articles and read_article_and_summarize functions\narxiv_functions = [\n    {\n        \"name\": \"get_articles\",\n        \"description\": \"\"\"Use this function to get academic papers from arXiv to answer user questions.\"\"\",\n        \"parameters\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"query\": {\n                    \"type\": \"string\",\n                    \"description\": f\"\"\"\n                            User query in JSON. Responses should be summarized and should include the article URL reference\n                            \"\"\",\n                }\n            },\n            \"required\": [\"query\"],\n        },\n    },\n    {\n        \"name\": \"read_article_and_summarize\",\n        \"description\": \"\"\"Use this function to read whole papers and provide a summary for users.\n        You should NEVER call this function before get_articles has been called in the conversation.\"\"\",\n        \"parameters\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"query\": {\n                    \"type\": \"string\",\n                    \"description\": f\"\"\"\n                            Description of the article in plain text based on the user's query\n                            \"\"\",\n                }\n            },\n            \"required\": [\"query\"],\n        },\n    }\n]\r\n```\n\n이러한 기능을 챗봇의 작업 흐름에 통합하면 OpenAI의 API의 고급 사용 사례를 보여줍니다. 여기서는 대화 컨텍스트에 따라 특정 작업(예: 학술 조사)에 맞게 맞춤형 함수가 실행됩니다.\n\n## 3.6 완전한 코드\n\n필요한 함수 및 대화형 챗봇 상호작용이 포함된 전체 코드를 참조하세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 프로젝트 유형뿐만 아니라 AI, 데이터 과학 및 기술 분야의 다양한 혁신적인 데이터 기반 이니셔티브에 대해 www.entreprenerdly.com의 다양한 자원을 살펴보기를 권장합니다.\n\n![image](/TIL/assets/img/2024-07-12-AutomatingScientificKnowledgeRetrievalwithAIinPython_1.png)\n\n## 4. 연구 챗봇과 상호작용하기\n\n이 섹션에서는 사용자-시스템 상호작용 흐름을 설명하는 예제들과 함께 연구 챗봇의 구현과 기능에 대해 깊이 파고들어 논의합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 4.1 구현 개요\n\n챗봇은 OpenAI API를 기반으로 구축되었으며, GPT-3 또는 GPT-4와 같은 모델을 활용하여 복잡한 쿼리를 이해하고 사람과 유사한 답변을 생성할 수 있습니다.\n\n구현은 사용자가 쿼리를 입력할 수 있는 인터페이스(명령줄 인터페이스 또는 웹 기반 UI)를 설정하는 것을 포함합니다. 그런 다음 시스템은 이러한 쿼리를 처리하고 OpenAI API와 상호 작용하여 사용자에게 다시 응답을 제시합니다.\n\n## 4.2 기능\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n연구 챗봇의 핵심 기능은 다음과 같습니다:\n\n- 질의 이해: 챗봇은 먼저 사용자의 질문을 해석하여 OpenAI 모델의 이해 능력을 활용하여 질문 뒤에 숨은 맥락과 의도를 파악합니다.\n- 정보 검색: 챗봇은 질의에 따라 교육된 지식베이스를 활용하여 직접 답변을 생성하거나 관련 과학 논문과 문서를 가져와 응답을 작성할 수 있습니다.\n- 응답 생성: 챗봇은 검색하거나 생성한 정보를 일관되고 간결한 답변으로 종합하여 사용자에게 제시합니다.\n\n## 4.3 사용자-시스템 상호작용 흐름\n\n- 사용자 질의 예시: 사용자가 “양자 컴퓨팅의 최신 발전은 무엇인가요?”라고 묻습니다. 질의 처리:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nresponse = openai.Completion.create(\n  engine=\"davinci\",\n  prompt=\"양자 컴퓨팅의 최신 발전 사항은 무엇입니까?\",\n  max_tokens=100\n)\n```\n\n- 답변 생성: 시스템은 답변을 구성하여 양자 컴퓨팅의 최근의 폭발적인 발전을 요약할 수 있습니다.\n- 답변 제시: 챗봇은 사용자의 이해를 돕기 위해 합성된 정보를 출력합니다.\n\n## 4.3.1 관련 논문 검색\n\n이 단계는 사용자가 챗봇에게 특정 주제에 대한 논문을 식별하고 검색하는 것을 포함합니다.  \n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 시스템 메시지로 시작합니다\npaper_system_message = \"\"\"안녕하세요, 저는 arXivGPT입니다. 사용자의 질문에 답변하기 위해 학술 논문을 가져오는 유용한 도우미입니다.\n논문을 명확하게 요약하여 고객이 질문에 대한 답변을 얻기 위해 어떤 논문을 읽어야 하는지 결정할 수 있도록 도와드립니다.\n사용자가 논문의 이름을 이해하고 액세스하려면 항상 article_url과 title을 제공합니다.\n시작하세요!\"\"\"\npaper_conversation = Conversation()\npaper_conversation.add_message(\"system\", paper_system_message)\n\n\n# 사용자 메시지 추가\npaper_conversation.add_message(\"user\", \"시장 효율성에 대한 최신 정보는 무엇인가요?\") # PPO 강화 학습은 어떻게 작동하나요?\nchat_response = chat_completion_with_function_execution(\n    paper_conversation.conversation_history, functions=arxiv_functions\n)\n\nassistant_message = chat_response[\"choices\"][0][\"message\"][\"content\"]\npaper_conversation.add_message(\"assistant\", assistant_message)\ndisplay(Markdown(assistant_message))\n```\n\n## 4.3.2 논문 요약하기\n\n적절한 논문을 가져온 후, 챗봇은 사용자의 요청을 더 처리하여 특정 논문의 내용을 요약하여 제공함으로써 간결하고 통찰에 풍부한 요약을 제공하며 상호작용을 개선합니다.\n\n```js\n# 두 번째 도구를 사용하도록 시스템을 유도하기 위해 다른 사용자 메시지 추가\npaper_conversation.add_message(\n    \"user\",\n    \"시장 효율적 교차 시장 추천을 위한 시장-인식 모델 논문을 읽고 요약을 제공해줄 수 있나요?\",\n)\nupdated_response = chat_completion_with_function_execution(\n    paper_conversation.conversation_history, functions=arxiv_functions\n)\ndisplay(Markdown(updated_response[\"choices\"][0][\"message\"][\"content\"]))\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 5. 도전과 솔루션\n\n## 5.1 다양한 데이터 소스 통합\n\n- 도전: 과학적 지식은 학술 저널부터 프리프린트 서버 및 기관 저장소까지 다양한 플랫폼과 형식으로 분산되어 있습니다.\n- 솔루션: 여러 소스에서 데이터를 가져와 정규화하기 위해 다양한 API 및 웹 스크래핑 기술과 연결할 수 있는 모듈식 데이터 수집 프레임워크를 개발해야 합니다.\n\n## 5.2 사용자-시스템 상호 작용 흐름\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 도전: 특히 다단계 정보 검색 및 처리가 필요한 복잡한 쿼리에 대해 대화 플로우를 자연스럽고 매력적으로 유지하는 것이 도전입니다.\n- 해결책: 사용자 경험을 향상시키기 위해, 챗봇이 사용자와 상호 작용하는 동안 정보 검색을 백그라운드에서 처리하면서 상호 작용적인 세션을 유지할 수 있는 멀티 스레드 요청 처리 시스템을 구현할 수 있습니다.\n\n## 5.3 연속적인 학습과 개선 보장\n\n- 도전: 챗봇이 사용자 상호작용에서 지속적으로 학습하고 개선하여 시간이 지남에 따라 정확도와 효과성을 향상시키는 것입니다.\n- 해결책: 사용자가 챗봇의 응답의 relevance 및 정확도를 평가할 수 있는 피드백 루프 메커니즘을 구현합니다. 이 피드백은 모델을 세밀하게 조정하고 응답 품질을 향상시키는 데 사용됩니다.\n\n## 5.4 실시간 데이터 동기화\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 도전 과제: 챗봇의 데이터베이스를 실시간으로 최신 과학 논문과 동기화하는 것. 새로운 연구가 계속 발표되고 있기 때문에, 챗봇이 가장 최신 정보를 제공하는 것은 상당한 도전입니다.\n- 해결책: 대형 과학 논문 데이터베이스의 웹훅과 RSS 피드를 사용하여 실시간 데이터 동기화 매커니즘을 구현할 수 있습니다. 이를 통해 새로운 논문이 제공되는 즉시 시스템이 자동으로 레포지토리를 업데이트할 수 있습니다.\n\n## 6. 실용적 응용\n\n### 6.1 학술 연구\n\n다양한 학문 분야의 연구자들은 이 시스템을 활용하여 문헌 검토 과정을 간소화하고 효율적으로 관련 연구를 찾을 수 있습니다. 연구 주제와 관련된 구체적인 쿼리를 입력함으로써, 시스템은 과학 논문을 신속히 검색하여 주요 결과, 방법론 및 결과를 식별하고 요약할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 6.2 산업 연구 및 개발\n\n제약, 공학 및 기술 연구개발 부서의 빠른 환경에서는 최신 과학적 발견에 대한 최신 정보를 충분히 파악하는 것이 혁신과 경쟁 우위를 유지하는 데 중요합니다. 시스템은 이러한 산업에 최신 연구, 실험 결과 및 기술 발전을 신속하게 접근할 수 있는 강력한 도구를 제공합니다.\n\n## 6.3 교육\n\n교육자와 학생 모두 시스템을 활용하여 학습 경험을 풍부하게 하고 학업 연구를 지원할 수 있습니다. 교사들은 강의를 준비하기 위한 최신 정보를 찾아 수업 내용을 현재와 관련성 있게 전달할 수 있습니다. 마찬가지로 학생들은 에세이, 프로젝트 또는 논문을 위한 소스, 참고 자료 및 사례 연구를 찾기 위해 시스템을 활용할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 6.4 데이터 과학 및 AI\n\n데이터 과학가와 AI 연구원들에게는 시스템이 데이터 세트를 확보하고 복잡한 알고리즘을 이해하며 기존 연구에 대한 벤치마킹을 제공하는 중요한 자원으로 작용합니다. 사용자들은 시스템에서 특정 프로젝트에 가장 최근이고 관련성 있는 데이터 세트를 쿼리할 수 있으며, 데이터 세트의 크기, 다양성 및 응용에 대한 자세한 정보를 얻을 수 있습니다.\n\n# 결론과 향후 작업\n\n이 연구 및 과학적 지식 검색 시스템의 개발과 구현은 인공지능의 변혁적 잠재력을 강조하며, 과학적 조사의 접근성과 효율성을 향상시키는 데 중요한 역할을 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n미래 작업은 AI 및 기계 학습의 최신 발전을 활용하여 식별된 과제에 대응하며, 시스템이 최첨단 기술 선두에 머무르고 다양한 사용자들의 요구를 계속 충족할 수 있도록 보장하는 데 초점을 맞추게 될 것입니다.\n\n읽어 주셔서 감사합니다. 만약 이 글이 유익했다면 앞으로의 콘텐츠 지원을 위해 박수를 부탁드립니다. 👏\n\nEntreprenerdly.com에는 행동 가능한 지식을 제공하기 위해 설계된 전체 자습서, 코드 및 전략이 제공됩니다.\n\n![2024-07-12-AutomatingScientificKnowledgeRetrievalwithAIinPython_2.png](/TIL/assets/img/2024-07-12-AutomatingScientificKnowledgeRetrievalwithAIinPython_2.png)","ogImage":{"url":"/TIL/assets/img/2024-07-12-AutomatingScientificKnowledgeRetrievalwithAIinPython_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-AutomatingScientificKnowledgeRetrievalwithAIinPython_0.png","tag":["Tech"],"readingTime":24},{"title":"코딩 없이 바로 사용할 수 있는 실용적인 파이썬 팁 5가지","description":"","date":"2024-07-12 20:52","slug":"2024-07-12-5PracticalPythonTipsNoCodingRequiredReadytoUse","content":"\n\n## 파이썬 기술\n\n요즘에는 Python이 복잡한 기능을 달성하기 위해 더 적은 코드를 작성할 수 있도록 해서 인기를 얻었습니다. Python 개발자 커뮤니티는 복잡한 구현을 캡슐화하면서도 사용자 친화적인 도구를 환영합니다.\n\n그러나 Python의 단순함은 여기서 끝나지 않습니다. 아무 코드도 작성하지 않고 Python을 사용할 수 있다고 믿을 수 있나요? 다음 기사에서는 코드를 작성하지 않고 Python의 내장 기능을 사용하는 다섯 가지 예제를 소개하겠습니다.\n\n# Python CLI \"-m\" 매개변수\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파이썬 CLI (명령줄 인터페이스)로 시작해봅시다. 나중에 언급할 기능들을 사용하기 위해 코드를 작성할 필요는 없지만, 파이썬이 우리가 무엇을 하고 싶은지 알 수 있도록 파이썬 명령줄을 사용해야 합니다.\n\n컴퓨터에 파이썬이 설치되어 있다면, 파이썬 명령줄에 `python --help`를 입력하여 지원되는 모든 매개변수를 표시할 수 있습니다.\n\n![이미지](/TIL/assets/img/2024-07-12-5PracticalPythonTipsNoCodingRequiredReadytoUse_0.png)\n\n출력이 길기 때문에 위 이미지는 일부만 보여줍니다. 여기서 강조하고 싶은 것은 `-m mod` 매개변수인데, 이는 파이썬 모듈을 스크립트로 실행합니다. 모듈이 명령줄 작업을 지원한다면, 해당 모듈을 명령줄에서 바로 사용할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 서버 포트 테스트\n\n가끔은 IP 포트의 아웃바운드 네트워크 트래픽을 테스트하고 싶을 때가 있습니다. 보통 telnet 명령어를 사용하는 것이 좋습니다. Windows에서는 telnet이 기본적으로 설치되어 있지 않아 수동으로 설치해야 합니다. 간단한 테스트를 위해서 telnet을 설치하는 것은 자원의 낭비일 수도 있습니다.\n\n하지만 Python이 설치되어 있다면 별도로 telnet을 설치할 필요가 없습니다. Python에 내장된 모듈이 있기 때문입니다. Google 검색 사이트의 443 포트를 테스트할 수 있습니다.\n\n```js\npython -m telnetlib -d 142.250.70.174 443\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 로컬 웹 서버 시작하기\n\n많은 Python 사용자들은 처음에 이 소식을 듣고 놀랍습니다. 네, Python을 사용하여 어떤 코드도 작성하지 않고도 웹 서버를 시작할 수 있습니다. 명령줄에서 다음 명령을 실행하기만 하면 됩니다.\n\n```js\npython -m http.server\n```\n\n실행한 후에는 서비스가 로컬 8000 포트에서 수신 대기합니다. 그런 다음 브라우저에서 http://localhost:8000/을 통해 접속할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![2024-07-12-5PracticalPythonTipsNoCodingRequiredReadytoUse_1](/TIL/assets/img/2024-07-12-5PracticalPythonTipsNoCodingRequiredReadytoUse_1.png)\n\n이 웹 서버는 로컬 파일 시스템을 명령 시작 경로의 루트 디렉토리로 표시합니다. 다시 말해서 우리는 그의 상위 디렉토리에 액세스할 수 없습니다.\n\n이 기능의 사용처는 무엇인가요? 예를 들어, 컴퓨터의 디렉토리에서 많은 텍스트/PDF/이미지 파일/하위 디렉토리를 친구들과 공유하려고 한다면, 이 방법을 사용하면 쉽습니다.\n\n![2024-07-12-5PracticalPythonTipsNoCodingRequiredReadytoUse_2](/TIL/assets/img/2024-07-12-5PracticalPythonTipsNoCodingRequiredReadytoUse_2.png)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# JSON 문자열 확인 및 서식 지정\n\nJSON 문자열이 매우 길고 서식이 지정되지 않았다면, 읽기가 어려울 수 있습니다. 보통 저는 Sublime이나 VS Code와 같은 JSON 플러그인이 있는 텍스트 편집기를 사용하여 JSON 문자열을 서식 지정합니다. 하지만 이러한 도구를 사용할 수 없는 경우, Python이 일시적인 해결책이 될 수 있습니다. 아래는 짧은 JSON 문자열을 사용한 예제입니다.\n\n```js\necho '{\"name\": {\"first_name\":\"Chris\", \"last_name\":\"Tao\"} \"age\":33}'\n```\n\n위 명령줄 도구로는 원래의 형식으로 표시되지만, Python의 `json.tool` 도구를 사용하면 JSON 문자열이 잘 서식이 지정됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n죄송합니다! JSON 문자열이 잘못되었네요. `json.tool`을 사용하면 문제를 파악할 수 있어요. \"name\" 객체 뒤에 쉼표를 빠뜨렸네요. 쉼표를 추가하면 JSON이 올바르게 됩니다.\n\n이제 JSON 문자열은 완벽히 들여쓰기된 형식으로 출력되어 가독성이 좋아졌어요.\n\n# 텍스트 에디터 만들기\n\n맞아요, Python을 사용하여 텍스트 에디터를 \"만들\" 수 있어요. 물론 기능이 제한적이지만, 더 나은 옵션이 없을 때 유용해요. Vim이나 Nano와 기능 면에서 비교할 수 없지만, 명령줄 텍스트 에디터가 아닌 UI 에디터에요. 이 에디터는 Tkinter를 기반으로 한 `idlelib` 모듈에 의해 만들어졌기 때문에 크로스 플랫폼이에요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n간단한 Python 프로그램을 작성하여 현재 시간을 표시하려고 합니다. 큰 코드 편집기를 다운로드하고 설치하지 않고 빠르게 코드를 작성하려면 다음 명령을 실행해 봅시다.\n\n```js\nmkdir get_time_app\npython -m idlelib get_time_app/print_time.py\n```\n\n파일 디렉토리가 존재하지 않으면 `idlelib`가 생성할 수 없으므로 필요한 경우 직접 만들어야 합니다. 명령을 실행한 후 `print_time.py` 파일은 저장되어 로컬에만 생성됩니다. 이제 편집기가 나타나며 구문 강조 기능이 있는 코드를 작성할 수 있습니다.\n\n![Image](/TIL/assets/img/2024-07-12-5PracticalPythonTipsNoCodingRequiredReadytoUse_3.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n`ctrl+s`를 사용하여 코드를 저장하고 편집기를 닫으세요. 명령줄에서 편집된 코드 파일을 확인하고 문제가 없어야 합니다.\n\n```js\ncat get_time_app/print_time.py\n```\n\n# 실행 가능한 애플리케이션 만들기\n\n현재 시간을 가져오는 간단한 애플리케이션을 만들고 싶다면, PyInstaller와 같은 서드파티 도구가 필요하지 않습니다. Python의 내장 Zipapp을 사용할 수 있습니다. \"현재 시간 가져오기\" 애플리케이션으로 패키지하려면, 명령줄에서 다음 명령을 실행하세요.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\npython -m zipapp get_time_app -m \"print_time:main\"\n\n\n우리는 `zipapp` 이름을 `get_time_app`으로 설정하고, 파이썬 프로그램의 진입 파일과 진입 함수를 지정하기만 하면 됩니다. `.pyz` 확장자를 가진 파일이 우리가 만든 애플리케이션입니다. 이 프로젝트를 폴더가 아닌 단일 파일로 배포할 수 있습니다.\n\n![image](/TIL/assets/img/2024-07-12-5PracticalPythonTipsNoCodingRequiredReadytoUse_4.png)\n\n프로그램을 실행하는 것은 간단합니다. Python을 사용하여 직접 호출하면 됩니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\npython get_time_app.pyz\r\n```\r\n\r\n안녕하세요! 제가 \"Medium에서 빠르게 팔로워를 얻는 방법\"에 관한 이북을 쓰고 있습니다. 저는 최고의 증거이기 때문에 말이죠. 딱 한 달 만에 5,000명 이상의 팔로워를 얻었습니다. 계속해서 소식을 지켜봐 주세요!\r\n\r\n저는 Substack에서 \"GPT 소개\" 시리즈를 쓰고 있어요. 관심이 있으시면 팔로우 해주세요!\r\n\r\n총 10편의 글 중 8번째 글이 이미 완료되었습니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 글을 읽어 주셔서 감사합니다!📖 형광펜으로 강조해 주시고🖍️ 박수를 보내 주시고👏 댓글을 남겨 주시고💬 공유해 주셔서 감사합니다🗣️. \"미디엄의 친구\"로서 매일 열심히 노력하고 있습니다.\n\n또한, 뉴스레터를 구독하여 제가 위와 같은 멋진 콘텐츠를 게시할 때마다 알림을 받을 수 있습니다📰. 고맙습니다, 친애하는 챔프!🤓\n\n최신 Python 이야기를 따르려면 Substack에서 저희와 연락하십시오. 함께 Python의 미래를 함께 만들어 봅시다!\n\n# 즐기세요","ogImage":{"url":"/TIL/assets/img/2024-07-12-5PracticalPythonTipsNoCodingRequiredReadytoUse_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-5PracticalPythonTipsNoCodingRequiredReadytoUse_0.png","tag":["Tech"],"readingTime":8},{"title":"형태학적 이미지 처리 실용 가이드","description":"","date":"2024-07-12 20:50","slug":"2024-07-12-Apracticalguidetomorphologicalimageprocessing","content":"\n\n## | 인공지능 | 컴퓨터 비전 | 전처리 |\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_0.png\" /\u003e\n\nPython에서 모폴로지 연산을 어떻게 구현하는지 및 왜 디지털 이미지 처리에서 중요한지에 대해 설명하는 가이드입니다.\n\n이전 시리즈의 기사는 다음과 같습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 형태학 소개\n\n![이미지](/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_1.png)\n\n형태학(가끔 수학적 형태학으로도 불립니다)은 이웃 처리의 한 분야로 여겨질 수 있습니다. 1964년 Georges Matheron과 Jean Serra에 의해 개발되었으며, 광물 단면의 특성을 정량화하기 위해 고안되었지만 다른 다양한 응용 분야에서도 가치가 있다는 것이 입증되었습니다. 일반적으로 형태학은 이미지에 일관된 노출이 없는 경우에 발생하는 노이즈를 제거하는 데 사용할 수 있습니다. 실제로 형태학은 역처리로 얻은 바이너리 이미지와 매우 잘 작동하지만(하지만 그레이스케일 이미지에서도 사용할 수 있습니다).\n\n예를 들어, 임계 처리 후 몇 가지 상황이 발생할 수 있고, 이를 형태학으로 해결할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![A practical guide to morphological image processing](/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_2.png)\n\n여기서 나는 히트 또는 핏 연산, 팽창, 침식을 적용했는데, 이에 대해 자세히 알아볼 것이다.\n\n형태학은 다양한 흥미로운 응용 프로그램을 갖고 있습니다. 예를 들어 광학 문자 인식(OCR)의 전처리 단계로 사용되며, 바코드 및 자동차 번호판은 감지하는 데 사용됩니다. 형태학 연산은 간단하고 계산 비용이 적고 결합하여 효율적으로 사용할 수 있어 시간과 계산 자원을 절약할 수 있습니다. 실제로 여러 가지 작업을 수행하기 위해 복잡한 알고리즘이 필요하지 않을 때가 많으며, 적은 고급 기술도 우아하고 효율적인 솔루션으로 이어질 수 있습니다. 또한, 이러한 연산은 다양한 컴퓨터 비전 알고리즘에서 매우 유용하며 실제로 학습할 가치가 있습니다.\n\n# 형태학\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_3.png)\n\n임계처리는 전역 작업으로 (이미지의 모든 픽셀에 대해) 지역 위치를 고려하지 않고 수행되며, 결과적으로 과소 세분화 또는 과대 세분화된 영역을 유발할 수 있습니다.\n\n대신, 형태학은 이웃 처리와 비슷하게 적용됩니다. 이 경우에는 값이 아닌 모양이 중요합니다 (상자 모양 커널은 날카로운 모서리를 보존하고 둥근/디스크 모양 커널은 모서리를 둥글게 만듭니다).\n\n![image](/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_4.png)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 커널은 이미지에있는 객체 (또는 요소)에만 적용됩니다. 따라서 커널이 클수록 이미지에 미치는 영향도 커집니다. 이러한 절차는 일반적으로 1이 전경을 나타내고 0이 배경을 나타내는 바이너리 이미지에서 수행됩니다.\n\n## 맞추기와 맞추기\n\n이 알고리즘에서는 위에서 본 것과 같은 모양의 커널을 특정 위치에 놓은 다음 커널에 의해 커버되는 픽셀의 값을 고려합니다. 아이디어는 커널을 고려할 때, 특정 위치에있는 픽셀이 커널에도 1이면 1로 설정하려는 것입니다 (이를 '맞춤'이라고 함). 일치하는 경우 출력 이미지의 픽셀이 1로 설정됩니다. 맞춤 (또는 맞춤)에서 이미지 전체를 스캔하는 것이 아니라 특정 위치와 커널을 선택하고 커널 및 해당 위치의 픽셀의 일치 여부를 확인합니다.\n\n맞춤의 경우에는 커널에있는 것처럼 동일한 위치의 모든 픽셀이 1인지 확인합니다 (참이면 이미지가 맞는 것입니다). 모든 픽셀에 대해 일치하는 경우, 모든 픽셀을 출력 이미지에서 1로 설정하고, 그렇지 않은 경우 모두 0으로 설정합니다. 아래 두 위치에 맞춤 또는 맞춤을 적용합니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![풍부한 이진화와 침식](/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_5.png)\n\n## 팽창과 침식\n\n전체 이미지에 히트를 적용하는 것을 '팽창'이라고 합니다. 왜냐하면 그 이미지의 요소들이 변환 후에 크기가 증가하기 때문입니다. 또한, 작은 구멍이 닫히고 일부 객체가 병합됩니다. 증가량은 커널 요소의 크기에 따라 달라지거나, 대안으로 작은 커널을 반복적으로 적용할 수 있습니다. 문제는 잡음이 있는 객체도 확대될 수 있다는 것입니다. 커널 k를 사용한 방정식은 다음과 같습니다:\n\n![팽창과 침식](/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_6.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n⊕은 벡터 하위 공간의 합을 나타냅니다.\n\n말했듯이, 커널 크기는 영향을 미치며 작은 커널을 반복적으로 적용할 때 영향이 유사합니다 (예: 6x6 커널은 3x3 커널을 2배 적용한 것과 유사한 효과를 줍니다). 이미지에 다른 커널의 효과를 시도해 보겠습니다. 우선 이전 튜토리얼에서 언급했던대로 이미지에 Otsu의 임계값 처리를 적용한 이미지로 시작하겠습니다 (이는 일정 임계값 이상인 픽셀이 255 또는 흰색이 되고 나머지는 0인 바이너리 이미지를 반환합니다).\n\n![image](/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_7.png)\n\n그런 다음 이 바이너리 이미지에 다양한 커널 크기와 팽창을 적용합니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\n# 확장\nfrom scipy import ndimage\nfrom skimage.filters import threshold_otsu\nfrom skimage.morphology import disk\nfrom skimage.morphology import erosion\n\nfig, axes = plt.subplots(ncols=4, nrows=1, sharex=True, sharey=True, figsize=(12, 5))\n\nimage = im\nthresh = threshold_otsu(image)\nbinary = image \u003e thresh\n\ndilated = ndimage.binary_dilation(binary, structure=np.ones((3,3)))\ndilated1 = ndimage.binary_dilation(binary, structure=np.ones((5,5)))\ndilated2 = ndimage.binary_dilation(binary, structure=np.ones((9,9)))\n```\n\n![image](/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_8.png)\n\n물체가 커지고 이미지의 구멍이 메꿔지며 일부 잡음 요소가 확대되는 것을 알 수 있습니다.\n\n침식은 확장과 정반대입니다. 이 경우에는 모든 이미지에 대해 맞추고 있습니다. 효과는 객체 크기의 일반적인 축소와 작은 객체의 제거로 이어집니다. 더불어 종종 더 큰 객체가 더 작은 객체로 분할됩니다. 우리는 잡음을 제거하지만 관심 대상 객체는 파손됩니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기 방정식입니다:\n\n![equation](/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_9.png)\n\n여기에 Python 구현이 있습니다:\n\n```python\n#침식\n\nfig, axes = plt.subplots(ncols=4, nrows=1, sharex=True, sharey=True, figsize=(12, 5))\n\nimage = im\nthresh = threshold_otsu(image)\nbinary = image \u003e thresh\n\neroded = ndimage.binary_erosion(binary, structure=np.ones((3,3)))\neroded1 = ndimage.binary_erosion(binary, structure=np.ones((5,5)))\neroded2 = ndimage.binary_erosion(binary, structure=np.ones((9,9)))\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래의 표를 마크다운 형식으로 바꿔보세요.\n\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_10.png\" /\u003e\n\n주의할 점은 작은 물체가 사라지는 것과, 관심 대상물체에 구멍이 형성되는 것입니다.\n\n침식과 팽창의 조합으로 우리는 개방, 폐쇄, 경계 감지와 같은 복합 연산을 유도합니다.\n\n## 폐쇄와 개방\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n보통 클로징은 구멍을 메우는 연산입니다. 팽창에 이어 침식이 이루어지면 얻을 수 있습니다. 이미지 내부의 구멍은 보통 이 작업 이후에 닫힙니다. 팽창을 사용하여 객체의 크기 (그리고 잡음의 크기)를 키우고 출력 객체는 입력 크기와 같습니다. 따라서 클로징이 이 문제를 해결합니다. 다음 작업을 위한 커널의 크기도 동일합니다. 클로징 연산은 항등성을 갖고 있어 한 번만 사용할 수 있습니다. 그렇지 않으면 이미지 전체를 축소시키는 것만 일어나서 뚜렷한 효과가 없습니다 (경계 문제). 아래 방정식을 볼 수 있습니다:\n\n![](/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_11.png)\n\n여기서 커널의 크기를 다르게 사용하는 경우 무슨 일이 일어나는지 주목해 보세요:\n\n```js\nclosed = ndimage.binary_closing(binary, structure=np.ones((3,3)))\nclosed1 = ndimage.binary_closing(binary, structure=np.ones((5,5)))\nclosed2 = ndimage.binary_closing(binary, structure=np.ones((9,9)))\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![Opening operation](/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_12.png)\n\nOpening is generally used to avoid fractioning bigger objects when removing the noise. In this case, we use first erosion and then dilation. The output image presents an object with the original size but the noise is removed. Another idempotent transformation and the equation is:\n\n![Idempotent transformation](/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_13.png)\n\nLet’s also test the opening operation to see what is happening:\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nopened = ndimage.binary_opening(binary, structure=np.ones((3,3)))\nopened1 = ndimage.binary_opening(binary, structure=np.ones((5,5)))\nopened2 = ndimage.binary_opening(binary, structure=np.ones((9,9)))\n```\n\n![Image](/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_14.png)\n\n두 가지 과정을 결합할 수도 있지만, 커널은 서로 달라야 합니다 (opening에 사용되는 것과 closing에 사용되는 것이 서로 다른 커널이어야 함)\n\n5x5 커널을 사용하여 모든 연산을 함께 확인해보겠습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_15.png)\n\nBoundary detection is an edge detection technique on binary images, where you subtract the eroded image, obtaining the boundary. The idea is that with eroding we are obtaining a smaller version of the object and if we subtract the image only the boundary will remain. In formula:\n\n![formula](/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_16.png)\n\n```js\neroded = ndimage.binary_erosion(binary, structure=np.ones((3,3)))\nboundary =binary ^ eroded\n``` \n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_17.png\" /\u003e\n\n뺄셈이 아니라 두 개의 논리 마스크 (참/거짓)를 사용하기 때문에 논리 연산자 AND를 사용하는 것에 유의하세요. 그렇지 않으면 Numpy가 오류를 반환합니다. (하지만 원리는 같습니다)\n\n## 약간의 실제 예시\n\n마이크로스코프 이미지에서 핵 윤곽선을 선택하여 분석을 수행하려면 몇 가지 조작만으로 가능합니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 핵을 선택하려고 합니다.\n# 따라서, 파란색 부분만 선택합니다.\nim = a[:,:,2]\nimage = im\nthresh = threshold_otsu(image)\nbinary = image \u003e thresh\neroded = ndimage.binary_erosion(binary, structure=np.ones((7,7)))\nopening = ndimage.binary_opening(eroded, structure=np.ones((11,11)))\nboundary = binary ^ opening\n```\n\n![image](/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_18.png)\n\n보너스 예제: 자동차 이미지의 번호판을 읽고 싶다면, 복잡한 딥 러닝 모델 대신 간단한 전처리 단계로 시작할 수 있습니다. 하얀색과 검은색 모자(흰색은 회색 이미지에서 개방 이미지를 뺀 것이고 검은색은 회색 입력 이미지에서 닫힘을 뺀 것)와 같은 몇 가지 간단한 연산을 사용할 수 있습니다. 여기서 우리는 번호판이 가로보다 세로가 길기 때문에 사각형 커널을 사용했습니다. 그리고 임의의 크기의 커널을 사용할 수 있습니다. 몇 가지 간단한 작업만으로도 결과가 꽤 좋아집니다.\n\n```js\nimage = im\nthresh = threshold_otsu(image)\nbinary = image \u003e thresh\nopening = ndimage.binary_opening(binary, structure=np.ones((13,5)))\nclosing = ndimage.binary_closing(binary, structure=np.ones((13,5)))\nblack_hat =  im - closing\nwhite_hat = im - opening\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_19.png\" /\u003e\n\n# 마무리\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_20.png\" /\u003e\n\n우리는 간단한 연산으로 다양한 결과를 얻을 수 있는 형태학적 연산이 얼마나 강력한지 보았습니다. 각 연산에는 그만의 반대가 있다는 것을 주목할 가치가 있으며, 이들을 결합하여 더 정교한 작업을 수행할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n합성에서는 침식 기법을 사용하여 물체를 연결하는 작은 링크를 제거하거나 작은 잡음 물체를 제거하고 바이너리 이미지에서 경계를 감지할 수 있습니다. 반면 팽창은 이미지의 부분을 연결하는 데 유용합니다. 열림은 물체를 파괴하지 않고 작은 물체를 제거할 수 있게 하며, 폐쇄는 물체 크기를 늘리지 않으면서 구멍을 메울 수 있습니다. 그리고 이러한 작업을 필요에 맞게 반복 및 조합할 수도 있습니다. 간단한 작업에 대해 나쁘지 않죠?\n\n이전 글은 여기서 확인할 수 있습니다. 여기에서는 핵심 코드만을 보여줬지만, 사용된 모든 코드는 여기에 있습니다.\n\n## 어떻게 생각하세요? 이러한 작업을 시도해 보셨나요? 댓글로 알려주세요.\n\n# 흥미로우셨다면:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n제 다른 글을 찾아보실 수 있고, LinkedIn에서 연락이나 소통할 수도 있습니다. 매주 업데이트되는 머신 러닝 및 인공 지능 뉴스가 포함된 이 저장소를 확인해보세요. 협업 및 프로젝트에 대해 열려 있으며 LinkedIn에서 저에게 연락할 수 있습니다.\n\n제 GitHub 저장소 링크는 다음과 같습니다. 거기에는 머신 러닝, 인공 지능 등과 관련된 코드와 다양한 자료를 모아두고 있습니다.\n\n또는 최근 글 중 하나에 관심이 있을 수도 있습니다:\n\n## 추가 자료\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 형태학 연산에 대해: 일반적으로 (여기, 여기, 여기) 및 OpenCV로 (여기, 여기, 여기)\n- 화이트와 블랙 햇에 관해: 여기\n\n# 평문으로 이해하기 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 계속 진행하기 전에:\n\n- 작가를 박수 치고 팔로우해 주세요 👏\n- 팔로우: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문: Stackademic | CoFeed | Venture\n- PlainEnglish.io에서 더 많은 콘텐츠 확인하기","ogImage":{"url":"/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_0.png","tag":["Tech"],"readingTime":15},{"title":"게으른 개발자를 위한 필수 효율적인 파이썬 데코레이터 5가지","description":"","date":"2024-07-12 20:47","slug":"2024-07-12-EssentialforLazyDevelopersFiveEfficientPythonDecorators","content":"\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-EssentialforLazyDevelopersFiveEfficientPythonDecorators_0.png\" /\u003e\n\n파이썬은 가독성이 뛰어나고 데이터 분석 및 웹 개발과 같은 여러 분야에서 강력한 응용 프로그램을 제공하여 개인적으로 가장 좋아하는 프로그래밍 언어입니다.\n\n하지만, 충분한 코드를 작성하고 있음에도 불구하고, 제가 절대적으로 필요한 경우가 아닌 한 @staticmethod를 사용하여 클래스 내의 정적 메서드를 꾸미는 데코레이터를 거의 사용하지 않습니다.\n\n그러나 코드 리뷰 중에 코드에 소개된 예외 처리 데코레이터를 발견했는데, 이는 제 생각을 바꾸어 코드를 더 읽기 쉽게 만들었으며 간결한 형태로 강력한 기능을 제공했습니다. 이것이 나의 호기심을 자극하여 데코레이터의 다른 기능을 탐구하게 만들었으므로, 이 글에서는 데코레이터의 개념을 깊이 탐구하고 우리의 파이썬 코드를 개선하는 데 도움이 되는 다섯 가지 실용적인 데코레이터를 소개하겠습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 데코레이터란\n\n![image](/TIL/assets/img/2024-07-12-EssentialforLazyDevelopersFiveEfficientPythonDecorators_1.png)\n\n데코레이터는 파이썬의 강력한 언어 기능으로, 원본 함수 코드를 수정하지 않고도 기능을 동적으로 추가하거나 함수 동작을 수정할 수 있게 해줍니다. 데코레이터는 다른 함수나 클래스를 매개변수로 받아 새로운 함수나 클래스를 반환하는 함수입니다.\n\n데코레이터는 함수를 수정, 확장 또는 래핑하여 코드를 보다 가독성 있고 유지보수하기 쉽게 만드는 간결하고 우아한 방법을 제공합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n데코레이터는 일반적으로 다음과 같은 시나리오에서 사용됩니다:\n\n- 추가 기능 또는 로직 추가, 로깅, 성능 분석, 입력 유효성 검사 등;\n- 함수의 동작 수정, 결과 캐싱, 재시도 메커니즘 추가 또는 입력 매개변수를 가로채서 매개변수를 확인하고 많은 assert 문을 사용하는 대신;\n- 관심을 분리하고 자르로 자르로 사용되는 관심사항을 핵심 비즈니스 로직과 분리합니다.\n\n# 5 매우 간단하지만 유용한 데코레이터\n\n## 01 타이머: 함수 실행 시간 측정\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n코드 성능 최적화는 매우 중요합니다. 이 데코레이터는 특정 함수의 실행 시간을 추적하고 경과 시간을 출력하는 데 도움을 줍니다. 이 데코레이터로 함수를 감싸면 병목 현상을 신속하게 식별하고 코드의 핵심 부분을 최적화할 수 있습니다.\n\n```js\nimport time\n\ndef timer(func):\n    def wrapper(*args, **kwargs):\n        # 타이머 시작\n        start_time = time.time()\n        # 데코레이트된 함수 호출\n        result = func(*args, **kwargs)\n        # 시간 다시 측정\n        end_time = time.time()\n        # 경과 시간 계산 및 출력\n        execution_time = end_time - start_time\n        print(f\"실행 시간: {execution_time} 초\")\n        # 데코레이트된 함수 실행 결과 반환\n        return result\n    # wrapper 함수에 대한 참조 반환\n    return wrapper\n```\n\n파이썬에서 데코레이터를 만들려면 timer라는 함수를 정의해야 합니다. 이 함수는 데코레이터 함수임을 나타내는 func라는 매개변수를 받습니다. timer 함수 내부에서는 원하는 함수를 데코레이트하기 위해 매개변수를 일반적으로 전달하는 wrapper라는 다른 함수를 정의합니다.\n\nwrapper 함수 내에서는 제공된 인수를 사용하여 필요한 함수를 호출합니다. 이렇게 할 수 있습니다: result = func(*args, **kwargs).\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마지막으로, 래퍼 함수는 장식된 함수의 실행 결과를 반환합니다. 데코레이터 함수는 방금 만든 래퍼 함수에 대한 참조를 반환해야 합니다.\n\n데코레이터를 활용하기 위해서는 원하는 함수에 @ 기호를 사용하여 적용하면 됩니다.\n\n```js\n@timer\ndef train_model():\n    print(\"Starting the model training function...\")\n    # 프로그램을 5초간 일시 중지하여 함수 실행을 시뮬레이션합니다\n    print(\"Model training completed!\")\n\ntrain_model()\n```\n\n## 02 debugger: Make Debug Easier\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n유용한 추가 래퍼 함수를 만들어 디버깅을 용이하게 할 수 있습니다. 각 함수의 입력 및 출력을 출력하여 실행 흐름을 확인할 수 있습니다. 이 방법을 통해 복수의 print 문으로 애플리케이션을 혼란스럽게 만들 필요가 없습니다.\n\n```python\ndef debugger(func):\n    def wrapper(*args, **kwargs):\n        # 함수 이름과 인수 출력\n        print(f\"Calling {func.__name__} with args: {args} kwargs: {kwargs}\")\n        # 함수 호출\n        result = func(*args, **kwargs)\n        # 결과 출력\n        print(f\"{func.__name__} returned: {result}\")\n        return result\n    return wrapper\n```\n\n호출된 함수의 이름을 가져오기 위해 __name__ 매개변수를 사용할 수 있으며, args와 kwargs 매개변수를 사용하여 전달된 내용을 출력할 수 있습니다.\n\n```python\n@debugger\ndef add_numbers(x, y):\n    return x + y\nadd_numbers(7, y=5)  \n# 출력: Calling add_numbers with args: (7,) kwargs: {'y': 5}\n# add_numbers returned: 12\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 03 memoize: 반환 결과 캐시\n\n우리는 코드 베이스에서 특정 코드 조각들의 동작을 거의 변경하지 않습니다. 그러나 이러한 코드들의 반복 실행은 상당한 컴퓨팅 자원을 소비할 수 있습니다. 이 경우 memoize 데코레이터를 사용하여 함수 호출을 캐시할 수 있습니다.\n\n이 시점에서 입력이 동일하면 함수는 한 번만 실행됩니다. 각 후속 실행에서는 결과가 캐시에서 가져옵니다. 따라서 비용이 많이 드는 계산을 항상 수행할 필요가 없습니다.\n\n```js\ndef memoize(func):\n    cache = {}\n    def wrapper(*args):\n        if args in cache:\n            return cache[args]\n        else:\n            result = func(*args)\n            cache[args] = result\n            return result\n    return wrapper\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n데코레이터는 함수 매개변수와 반환 값을 저장하는 사전(dictionary)을 사용합니다. 이 함수를 실행할 때, 데코레이터는 이전 결과 사전을 확인합니다. 저장된 값이 없을 때만 실제 함수가 호출됩니다.\n\n아래는 피보나치 수 계산 함수입니다. 이 함수는 재귀적으로 작동하므로 동일한 함수가 여러 번 실행됩니다. 그러나 캐싱을 사용하면 이 과정을 빠르게 만들 수 있습니다.\n\n```js\n@memoize\ndef fibonacci(n):\n    if n \u003c= 1:\n        return n\n    else:\n        return fibonacci(n-1) + fibonacci(n-2)\n```\n\n이 함수의 실행 시간을 캐시를 사용하거나 사용하지 않을 때 각각 측정한 결과입니다. 캐시된 버전은 실행에 몇 밀리초만 소요되지만, 캐시되지 않은 버전은 거의 1분이 소요됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이전 실행 결과를 저장할 때 사전을 사용하는 것은 간단하고 직관적인 방법입니다. 더 강력한 기능을 제공하기 위해 데이터를 캐시하는 인메모리 데이터베이스인 Redis나 Memcache와 같은 것을 사용할 수 있습니다.\n\n## 04 재시도: 실행 재시도\n\n데이터 과학과 소프트웨어 개발에서는 종종 외부 시스템에 의존하지만 모든 외부 시스템이 신뢰성있는 것은 아닙니다.\n\n예기치 않은 이벤트가 발생할 때 코드가 일정 시간을 기다려 외부 시스템이 복구되기를 기다리고 다시 시도할 수 있기를 원할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그런 retry 로직을 Python 데코레이터로 구현하는 것이 좋습니다. 이렇게 하면 재시도 동작을 어떤 함수에든 적용할 수 있어요.\n\n```python\nimport time\n\ndef retry(max_attempts, delay=1):\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            attempts = 0\n            while attempts \u003c max_attempts:\n                try:\n                    return func(*args, **kwargs)\n                except Exception as e:\n                    attempts += 1\n                    print(f\"Attempt {attempts} failed: {e}\")\n                    time.sleep(delay)\n            print(f\"Function failed after {max_attempts} attempts\")\n        return wrapper\n    return decorator\n```\n\n우리는 데코레이터에 대한 다른 래퍼 함수를 정의할 수 있어요. 이전 예제와 유사하게 구현해요. 그러나 이번에는 검증 함수를 입력 변수로 전달하는 대신 max_attempts와 delay와 같은 특정 매개변수를 전달해요.\n\n데코레이터 함수가 호출되면 wrapper 함수가 호출돼요. 이 함수는 시도 횟수(0부터 시작)를 기록하고 while 루프에 진입해요. 루프는 장식된 함수를 실행하려고 시도하고, 성공하면 결과를 즉시 반환해요. 그러나 예외가 발생하면 시도 횟수를 증가시키고, 시도 횟수와 발생한 특정 예외를 나타내는 오류 메시지를 출력해요. 지정된 지연 시간 동안 함수를 다시 시도하기 전에 time.sleep을 사용해요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 함수를 호출하려면 각 함수 호출 사이의 최대 시도 횟수와 시간 간격(초)을 지정할 수 있습니다.\n\n```js\n@retry(max_attempts=3, delay=2)\ndef fetch_data(url):\n    print(\"데이터를 가져오는 중..\")\n    # 서버 응답 없음을 모의하기 위해 시간 초과 오류 발생..\n    raise TimeoutError(\"서버가 응답하지 않습니다.\")\nfetch_data(\"https://example.com/data\")  \n# 시도 간격이 2초인 3번 재시도\n```\n\n## 05 exception_handler: Graceful Exception Handling\n\nexception_handler는 함수에서 발생한 모든 예외를 잡아 적절히 처리할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n요구 사항에 맞게 래퍼 함수에서 예외 처리를 사용자 정의할 수 있습니다. 예를 들어 예외를 로깅하거나 추가 오류 처리 단계를 수행할 수 있습니다.\n\n```js\ndef exception_handler(func):\n    def wrapper(*args, **kwargs):\n        try:\n            return func(*args, **kwargs)\n        except Exception as e:\n            # 예외 처리\n            print(f\"예외가 발생했습니다: {str(e)}\")\n            # 선택적으로 추가 오류 처리 또는 로깅 수행\n            # 필요한 경우 예외를 다시 발생시킵니다.\n    return wrapper\n```\n\n이것은 우리의 코드를 간소화하고 예외 처리 및 오류 로깅을 처리하는 통합된 절차를 수립하는 데 매우 유용합니다.\n\n```js\n@exception_handler\ndef divide(x, y):\n    result = x / y\n    return result\ndivide(10, 0)  \n# 출력: 예외가 발생했습니다: division by zero\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 요약\n\n![이미지](/TIL/assets/img/2024-07-12-EssentialforLazyDevelopersFiveEfficientPythonDecorators_2.png)\n\n데코레이터는 함수에 새로운 동작을 쉽게 적용할 수 있는 매우 편리한 방법입니다. 래퍼(wrapper)를 사용하여 복잡한 작업을 간소화하고 코드 가독성을 높이며 생산성을 향상시킬 수 있습니다.\n\n![이미지](/TIL/assets/img/2024-07-12-EssentialforLazyDevelopersFiveEfficientPythonDecorators_3.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 👋 만약 이 게시물이 도움이 된다면, 작가를 지원하는 의미로 아래 👏 버튼을 클릭해 주세요 \n\n## 🚀 FAUN 개발자 커뮤니티에 가입하고 매주 이메일로 유사한 이야기를 받아보세요","ogImage":{"url":"/TIL/assets/img/2024-07-12-EssentialforLazyDevelopersFiveEfficientPythonDecorators_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-EssentialforLazyDevelopersFiveEfficientPythonDecorators_0.png","tag":["Tech"],"readingTime":11},{"title":"위성으로 보이지 않는 용암 흐름과 활활 타오르는 산불을 어떻게 포착할 수 있을까 Python 사용법","description":"","date":"2024-07-12 20:44","slug":"2024-07-12-SatellitesCanSeeInvisibleLavaFlowsandActiveWildfiresButHowPython","content":"\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-SatellitesCanSeeInvisibleLavaFlowsandActiveWildfiresButHowPython_0.png\" /\u003e\n\n# 목차\n\n- 🌟 소개\n- 🔍 Sentinel-2 (분광대역)\n- 🌐 Sentinel-2 이미지 다운로드\n- ⚙️ Sentinel-2 이미지 처리 (클리핑 및 리샘플링)\n- 🌋 Sentinel-2 이미지 시각화 (화산)\n- 🔥 Sentinel-2 이미지 시각화 (산불)\n- 📄 결론\n- 📚 참고 자료\n\n## 🌟 소개\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n알고 계실지 모르겠지만, 우리 눈은 가시 영역(파란색, 녹색, 빨간색의 밴드)의 물체만 볼 수 있어요. 하지만 빛이 물체에 닿아 반사되면, 적외선과 같은 다른 스펙트럼 영역의 정보도 담고 있어요. 적외선 빛은 짙은 가스, 예를 들어 연기와 같은 것을 통과해 명확한 시야를 제공하죠. 하지만 우리 눈은 일부 동물들(뱀 등)과 달리 적외선 영역에 있는 물체를 보지 못해요. 지난 수십 년 동안 적외선 빛을 탐지하는 센서 개발에 상당한 진전이 있었어요. 이러한 센서들은 실용적인 응용에 활용되고 있어요.\n\n나는 항상 위성이 가시 영역에서는 볼 수 없는 적외선 영역에서 중요한 정보를 감지할 수 있는 좋은 예시를 찾고 있었어요. 지난 주에는 2023년 12월 이후 세 번째로 활동을 시작한 아이슬란드 화산에 대해 읽었어요. 그것은 나에게 위성이 촬영한 화산의 이미지를 확인하고 싶다는 생각을 일으켰어요. 나는 운이 좋아서 화산으로부터 올라오는 연기를 보여주는 선명한 위성 이미지를 발견할 수 있다면 좋겠다고 바랬어요. 그것은 가시 영역에서 빛이 흩어지는 것과 적외선 영역에서 연기를 통과해 용암 흐름을 드러내는 모습을 보여줄 수 있는 완벽한 예시가 될 것 같았죠.\n\n내가 확인한 여러 위성 중 하나가 완벽한 타이밍으로 있었어요! 화산은 2월 8일 목요일 아침에 폭발했고, Sentinel-2가 2월 8일 정오쯤에 지나갔어요. 나는 이것이 위성 이미지가 가시 영역에선 흐리더라도 적외선 영역의 센서로 장착된 위성 이미지가 우리에게 화산을 모니터링하고 화산재를 탐지하는 데 어떻게 도움이 되는지 보여주는 완벽한 예시가 될 수 있다고 생각했어요.\n\n매우 짙은 연기가 있는 상황에서 적외선 밴드의 응용을 탐구하려고, 나는 캘리포니아에서 발생한 2020년 최대 화재 중 하나를 캡처한 또 다른 Sentinel-2 이미지를 시각화하기로 결정했어요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 이야기에서는 아이슬란드 레이키아네스 반도의 화산과 2020년 캘리포니아의 크릭 파이어를 위해 캡처된 두 개의 센티넬-2 이미지를 다운로드할 것입니다. 우리는 파이썬을 사용하여 이 두 이미지를 시각화하기 위해 시각적 및 적외선 지역의 다른 밴드 조합을 사용할 것입니다. 적외선 정보가 활동 중인 용암 흐름 및 화재 지점을 보여줄 수 있음을 알 수 있을 것입니다. 이것이 흥미롭게 들린다면 계속 읽어보세요!\n\n## 🔍 센티넬-2 (분광대 업무)\n\n센티넬-2 미션은 유럽 우주국 (ESA)가 Copernicus 프로그램의 일환으로 개발한 쌍둥이 위성인 센티넬-2A와 센티넬-2B로 구성되어 있습니다. 센티넬-2 위성에는 데이터를 캡처하는 다중 스펙트럼 장비가 있습니다. 각 밴드는 특정 파장 범위를 갖고 있어 다양한 지구 관측 응용프로그램을 지원합니다. 이 게시물에서는 가시 지역의 밴드와 적외선 영역의 세 개의 밴드를 사용할 것입니다. 여기에는 이러한 밴드 목록이 있습니다:\nBand 2 (Blue): 496.6 nm\nBand 3 (Green): 560.0 nm\nBand 4 (Red): 664.5 nm\nBand 8 (NIR - 근적외선): 835.1 nm\nBand 11 (SWIR1- 단파 적외선): 1613.7 nm\nBand 12 (SWIR2- 단파 적외선): 2202.4 nm\n\nBand 2 (Blue), 3 (Green), 4 (Red), 및 8 (NIR)의 공간 해상도는 10 미터이며, Band 11 및 12 (단파 적외선)은 20 미터입니다. 이는 화산 및 산불을 시각화하는 데 충분합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 🌐 센티넬-2 이미지 다운로드\n\n이미 Python 및 R에서 센티넬-2 이미지를 다운로드하는 두 가지 튜토리얼을 작성했어요. 회원가입하는 방법, 자격 증명을 설정하고 이미지를 다운로드하는 방법을 알고 싶다면, 다음 게시물들을 참조하세요. 이번 게시물에서 이미지 다운로드를 위한 코드의 필요한 수정 사항을 설명했습니다:\n\n해당 스크립트를 바탕으로 관심 영역의 좌표, 이미지 날짜, 그리고 화산 및 산불을 위한 파란색, 녹색, 빨간색, 근적외선 및 단파대역을 다운로드해야 합니다.\n\n각 사례에 필요한 정보는 다음과 같아요:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 아이슬란드 화산:\n\n```js\n위성 = \"SENTINEL-2\"\n레벨 = \"S2MSI1C\"\n\n관심지점 = \"POINT(-22.411503 63.892295)\"\n\n시작일 = \"2024-02-07\"\n종료일 = \"2024-02-10\"\n```\n## 크리크 산불:\n\n```js\n위성 = \"SENTINEL-2\"\n레벨 = \"S2MSI1C\"\n\n관심지점 = \"POINT(-119.26 37.1914)\"\n\n시작일 = \"2020-09-07\"\n종료일 = \"2020-09-10\"\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이슬란드 화산:\n\n![이슬란드 화산](/TIL/assets/img/2024-07-12-SatellitesCanSeeInvisibleLavaFlowsandActiveWildfiresButHowPython_1.png)\n\n화산 분화는 현지 시간으로 2월 8일 목요일 오전 5시 30분에 발생했으며, 화면 캡처에 표시된 바와 같이 분화 후 정확히 7시간 후인 2월 8일 13:03 UTC(현지 시간 12시 30분)에 촬영된 이미지가 하나만 가능합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 크릭 파이어:\n\n![크릭 파이어](/TIL/assets/img/2024-07-12-SatellitesCanSeeInvisibleLavaFlowsandActiveWildfiresButHowPython_2.png)\n\n크릭 파이어는 9월 4일에 발생했으며 12월 24일에 소멸되었습니다. 목록의 두 이미지 모두 8일에 촬영되었습니다 (산불 발생 후 4일이 지난 후), 그러나 두 번째 이미지의 컨텐츠 길이는 0입니다. 따라서, 이 게시물에서는 첫 번째 이미지 (S2A_MSIL1C_20200908T183921_N0500_R070_T11SKB_20230309T124945)를 사용하겠습니다.\n\n두 블로그 게시물에서 Sentinel-2 이미지를 다운로드하는 코드를 실행하기 전에 시각 영역 (파랑, 초록, 빨강)에서 세 개의 밴드와 적외선 영역 (근적외선 및 단파적 외선 밴드)에서 세 개의 밴드를 포함해야 합니다. 다음 라인은 이러한 밴드에 해당됩니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nf\"{product_name}/{root[0][0][12][0][0][12].text}.jp2\" # Blue\nf\"{product_name}/{root[0][0][12][0][0][12].text}.jp2\" # Green\nf\"{product_name}/{root[0][0][12][0][0][12].text}.jp2\" # Red\nf\"{product_name}/{root[0][0][12][0][0][12].text}.jp2\" # Near-infrared\nf\"{product_name}/{root[0][0][12][0][0][12].text}.jp2\" # Shortwave infrared-1\nf\"{product_name}/{root[0][0][12][0][0][12].text}.jp2\" # Shortwave infrared-2\n```\n\n위 단계를 올바르게 따라왔다면, 각 예제당 아래 파일들이 디렉토리에 저장되어 있어야 합니다:\n\n## 아이슬란드 화산:\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-SatellitesCanSeeInvisibleLavaFlowsandActiveWildfiresButHowPython_3.png\" /\u003e\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Creek Fire:\n\n![Creek Fire Image](/TIL/assets/img/2024-07-12-SatellitesCanSeeInvisibleLavaFlowsandActiveWildfiresButHowPython_4.png)\n\n⚙️ Processing Sentinel-2 Images (Clipping and Downscaling)\n\nAfter downloading those images, we need to clip each band for the area of interest (AOI) around the volcano and the wildfire. Since we have the coordinates for each incident, we can create a buffer polygon (3 km for the volcano and 10 km for the wildfire) using this function:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport math\n\ndef calculate_new_coordinates(center_lat, center_lon, distance, bearing):\n    # 지구 반지름 (킬로미터)\n    earth_radius = 6371.0\n\n    # 좌표를 라디안으로 변환\n    center_lat_rad = math.radians(center_lat)\n    center_lon_rad = math.radians(center_lon)\n\n    # 새로운 위도 계산\n    new_lat_rad = math.asin(math.sin(center_lat_rad) * math.cos(distance / earth_radius) +\n                            math.cos(center_lat_rad) * math.sin(distance / earth_radius) * math.cos(bearing))\n\n    # 새로운 경도 계산\n    new_lon_rad = center_lon_rad + math.atan2(math.sin(bearing) * math.sin(distance / earth_radius) * math.cos(center_lat_rad),\n                                              math.cos(distance / earth_radius) - math.sin(center_lat_rad) * math.sin(new_lat_rad))\n\n    # 다시 도 단위로 변환\n    new_lat = math.degrees(new_lat_rad)\n    new_lon = math.degrees(new_lon_rad)\n\n    return new_lon, new_lat \n```\n\n## 아이슬란드 화산(AOI)을 위해 위의 함수 사용하기:\n\n```js\n# 중심 좌표\ncenter_lat = 63.892295\ncenter_lon = -22.411503\n\n# 버퍼 거리 (킬로미터)\nbuffer_distance = 3\n\n# 네 모퉁이의 좌표 계산\nnorth_lon, north_lat = calculate_new_coordinates(center_lat, center_lon, buffer_distance, 0)\nsouth_lon, south_lat = calculate_new_coordinates(center_lat, center_lon, buffer_distance, math.pi)\neast_lon, east_lat = calculate_new_coordinates(center_lat, center_lon, buffer_distance, math.pi / 2)\nwest_lon, west_lat = calculate_new_coordinates(center_lat, center_lon, buffer_distance, -math.pi / 2)\n\n# 원하는 형식으로 좌표 출력\nprint(f\"({west_lon:.4f} {north_lat:.4f}, {east_lon:.4f} {north_lat:.4f}, {east_lon:.4f} {south_lat:.4f}, {west_lon:.4f} {south_lat:.4f}, {west_lon:.4f} {north_lat:.4f})\")\n```\n\n```js\n# 출력:\n(-22.4728 63.9193, -22.3502 63.9193, -22.3502 63.8653, -22.4728 63.8653, -22.4728 63.9193)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Creek Fire (AOI)에 대한 위의 함수를 사용하십시오:\n\n```js\n# 중심 좌표\ncenter_lat = 37.19147\ncenter_lon = -119.261175\n\n# 킬로미터 단위의 버퍼 거리\nbuffer_distance = 10\n\n# 네 꼭지점의 좌표 계산\nnorth_lon, north_lat = calculate_new_coordinates(center_lat, center_lon, buffer_distance, 0)\nsouth_lon, south_lat = calculate_new_coordinates(center_lat, center_lon, buffer_distance, math.pi)\neast_lon, east_lat = calculate_new_coordinates(center_lat, center_lon, buffer_distance, math.pi / 2)\nwest_lon, west_lat = calculate_new_coordinates(center_lat, center_lon, buffer_distance, -math.pi / 2)\n\n# 원하는 형식으로 좌표 출력\nprint(f\"({west_lon:.4f} {north_lat:.4f}, {east_lon:.4f} {north_lat:.4f}, {east_lon:.4f} {south_lat:.4f}, {west_lon:.4f} {south_lat:.4f}, {west_lon:.4f} {north_lat:.4f})\")\n```\n\n```js\n# 결과:\n(-119.3741 37.2814, -119.1483 37.2814, -119.1483 37.1015, -119.3741 37.1015, -119.3741 37.2814)\n```\n\n그런 다음 jp2 파일을 클리핑하기 위해 \"aoi_polygon_wkt\"에 이러한 좌표를 사용할 수 있습니다. 이는 본 게시물의 \"AOI에 스택 형식으로 변환하고 클리핑하기\" 섹션에서 설명한 대로입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# Volcano: 다각형 WKT\naoi_polygon_wkt = \"POLYGON ((-22.4728 63.9193, -22.3502 63.9193, -22.3502 63.8653, -22.4728 63.8653, -22.4728 63.9193))\"\n\n# Wildfire: 다각형 WKT\naoi_polygon_wkt = \"POLYGON ((-119.3741 37.2814, -119.1483 37.2814, -119.1483 37.1015, -119.3741 37.1015, -119.3741 37.2814))\"\n```\n\n이 다각형들을 사용하여 JP2 파일을 AOI에 맞게 자를 수 있습니다. 그러나 시각화 부분에서 이 레이어를 쌓기 전에, 다른 밴드들 (파랑, 녹색, 빨강 및 근적외선)의 크기와 호환되도록 단파적적 적외선 밴드를 20m에서 10m로 축소해야 합니다. 이를 수행하는 함수는 다음과 같습니다:\n\n```js\nimport rasterio\nfrom scipy.ndimage import zoom\n\ndef downscale_raster(input_path, output_path, scale_factor):\n    with rasterio.open(input_path) as src:\n        # 데이터 읽기\n        data = src.read(1)\n\n        # 새로운 치수 계산\n        new_height = int(src.height / scale_factor)\n        new_width = int(src.width / scale_factor)\n\n        # 리샘플링을 위해 scipy의 zoom 함수 사용\n        resampled_data = zoom(data, 1/scale_factor, order=3)\n\n        # 새 래스터의 메타데이터 업데이트\n        transform = src.transform * src.transform.scale(\n            (src.width / resampled_data.shape[1]),\n            (src.height / resampled_data.shape[0])\n        )\n\n        new_profile = src.profile\n        new_profile.update({\n            'driver': 'JP2OpenJPEG',\n            'height': new_height,\n            'width': new_width,\n            'transform': transform\n        })\n\n        # 새 파일에 리샘플된 래스터 작성\n        with rasterio.open(output_path, 'w', **new_profile) as dst:\n            dst.write(resampled_data, 1)\n```\n\n그런 다음, 각 사용 사례에 대해 20m에서 10m로 단파 밴드를 축소하는 데 이 함수를 적용할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 아이슬란드 화산에 대한 위 함수 사용:\n\n```js\n# 사용법\ninput_band_path_B11 = \"/content/T27VVL_20240208T130311_B11.jp2\"\noutput_band_path_B11 = \"/content/T27VVL_20240208T130311_B11_resampled.jp2\"\n\ninput_band_path_B12 = \"/content/T27VVL_20240208T130311_B12.jp2\"\noutput_band_path_B12 = \"/content/T27VVL_20240208T130311_B12_resampled.jp2\"\n\nscale_factor = 1/2  # 20m to 10m\n\ndownscale_raster(input_band_path_B11, output_band_path_B11, scale_factor)\ndownscale_raster(input_band_path_B12, output_band_path_B12, scale_factor)\n```\n\n## 크릭 파이어에 대한 위 함수 사용:\n\n```js\n# 사용법\ninput_band_path_B11 = \"/content/T11SKB_20200908T183921_B11.jp2\"\noutput_band_path_B11 = \"/content/T11SKB_20200908T183921_B11_resampled.jp2\"\n\ninput_band_path_B12 = \"/content/T11SKB_20200908T183921_B12.jp2\"\noutput_band_path_B12 = \"/content/T11SKB_20200908T183921_B12_resampled.jp2\"\n\nscale_factor = 1/2  # 20m to 10m\n\ndownscale_raster(input_band_path_B11, output_band_path_B11, scale_factor)\ndownscale_raster(input_band_path_B12, output_band_path_B12, scale_factor)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 단계를 마치면 디렉토리에 두 개의 파일이 더 생겼어요:\n\n## Iceland Volcano:\n\n![Iceland Volcano](/TIL/assets/img/2024-07-12-SatellitesCanSeeInvisibleLavaFlowsandActiveWildfiresButHowPython_5.png)\n\n## Creek Fire:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-SatellitesCanSeeInvisibleLavaFlowsandActiveWildfiresButHowPython_6.png\" /\u003e\n\n같은 차원의 모든 밴드를 가지고 있으므로 이제 이 게시물의 \"스택, Geotiff로 변환한 다음 AOI( TOA)에 자르기\" 섹션을 기반으로 스택 파일을 생성할 수 있습니다.\n\n## 🌋 센티넬-2 이미지 시각화 (화산)\n\n이제 화산 사건을 위한 하나의 스택 파일과 산불 사건을 위한 다른 하나의 스택 파일이 있다면, 각각을 다른 밴드 조합을 사용하여 플로팅할 수 있습니다. 구체적으로, 우리는 세 가지 플롯을 만들 것입니다. 하나는 오직 가시적인 밴드(빨강, 초록, 파랑)을 기반으로 하고, 다른 하나는 가시적 및 근적외선 밴드(초록, 빨강, 그리고 근적외선)의 결합을 기반으로 하며, 세 번째는 적외선 영역에만 초점을 맞춘 것입니다(근적외선 및 단파 밴드) 데이터를 적외선 영역의 데이터를 생략한다면 어떤 정보를 놓칠 수 있는지 이해하기 위함입니다. 아래에 표시된 플롯과 비슷한 플롯을 생성하려면 이 게시물의 \"TOA 및 표면 반사 이미지의 실제 색상 플로팅\" 섹션을 참조하실 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 아이슬란드 화산:\n\n![아이슬란드 화산](/TIL/assets/img/2024-07-12-SatellitesCanSeeInvisibleLavaFlowsandActiveWildfiresButHowPython_7.png)\n\n이 그림은 시각적 영역에서 기록된 것으로, 화산 주변에 용암이 퍼져 있음을 볼 수 있습니다 (검은 픽셀), 화산의 연기 기둥, 그리고 몇 가지 매우 작은 빨간색 영역은 활성 용암을 보여줍니다. 앞에서 언급한 대로, 시각 대역에서 빛은 쉽게 산란되어, 우리는 이 이미지에서 연기 기둥을 흰색 픽셀로 볼 수 있습니다. 시각 대역에서 빛의 산란은 물체를 가리는데, 연기 아래에 있는 활성 용암을 관측하기 어렵게 만듭니다. 스크립트의 밝기를 제어하는 이득 매개변수를 조정해도 (스크립트의 이득 매개변수), 서쪽으로 흐르는 용암 흐름만 볼 수 있습니다:\n\n![활성 용암을 볼 수 있나요?](/TIL/assets/img/2024-07-12-SatellitesCanSeeInvisibleLavaFlowsandActiveWildfiresButHowPython_8.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n가시 스펙트럼에서 조정된 이득 매개 변수로 인해 화산재가 서쪽으로 이동하는 것을 더 명확하게 볼 수 있습니다. 하지만 여전히 연기 구름 아래에서 무슨 일이 일어나고 있는지는 모릅니다. 이번에는 근적외선 정보를 추가하여 이미지를 다시 그려보겠습니다.\n\n![image](/TIL/assets/img/2024-07-12-SatellitesCanSeeInvisibleLavaFlowsandActiveWildfiresButHowPython_9.png)\n\n이것을 통해 해당 시간에 두 개의 활동적인 용암 흐름이 있었음을 알 수 있습니다. 하나는 서쪽으로 향하는 것으로서 가시 스펙트럼에서 어느 정도 감지할 수 있었으며, 다른 하나는 남쪽으로 이동하고 있었는데 이는 근적외선 빛을 통해 확인되었습니다. 남쪽으로 향하는 흐름은 그리인다비크 근처에 있었는데, 해당 지역은 이전 11월의 분출 이후 대피된 지역입니다.\n\n소개에서 언급했지만, 이에 대한 주요 이유는 적외선 빛이 가시 파장 대비 더 긴 파장을 가지고 있다는 것입니다. 이것은 가시 파장과 달리 미립자와 같은 미립현을 통과하여 흩어지지 않고 밀집된 가스와 연기를 통과할 수 있게 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n앞으로 나아가서 이미지를 다시 그려봅시다. 이번에는 단파적 초적외선 및 근적외선 대역만 사용하겠습니다:\n\n![image](/TIL/assets/img/2024-07-12-SatellitesCanSeeInvisibleLavaFlowsandActiveWildfiresButHowPython_10.png)\n\n단파적 초적외선을 추가함으로써 이미지에 또 다른 정보가 더해졌음을 확인할 수 있습니다. 화산재를 나타내는 더 밝은 픽셀에 더해, 첫 번째와 두 번째 이미지의 검은 용암이 이제 두 영역으로 분리되었음을 보실 수 있습니다: 붉은색과 검은색. 붉은 영역은 새롭게 화재가 발생한 지역을 나타내며, 단파적 대역에서 더 많이 반사되는 온한 용암을 포함하고 있을 가능성이 높습니다. 나머지 부분은 활동이 없는 용암을 보여줍니다.\n\n## 🔥 Sentinel-2 이미지 시각화 (산불)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이전 섹션과 유사하게, 화재를 위한 센티넬-2 이미지를 플로팅할 것인데요. 이를 위해 가시 파장대 (적색, 청색, 녹색), 가시 및 근적외선 파장대 (녹색, 적색, 근적외선), 그리고 적외선 파장대(단파 및 근적외선)을 결합하여 사용할 거에요. 우선 가시 영역부터 시작해보죠:\n\n![Sentinel-2 이미지](/TIL/assets/img/2024-07-12-SatellitesCanSeeInvisibleLavaFlowsandActiveWildfiresButHowPython_11.png)\n\n이 사진은 Creek Fire를 위한 가시 파장대를 사용해 촬영한 센티넬-2 이미지입니다. 앞서 언급한 대로 이 지역에서 빛은 쉽게 산란되기 때문에, 보이는 것은 불타는 지역으로부터 대기로 솟아 오르는 매우 밀도 높은 연기 구름뿐입니다. 그러나 화산 예시와 같이, 적외선 영역의 빛은 연기로 투과할 수 있어 가시 영역에서 보이지 않는 것을 드러낼 수 있습니다. 연기 속 상황을 평가하기 위해, 가까운 적외선과 가시 파장대를 사용해 이미지를 플로팅하여 연기 아래에서 무슨 일이 일어나고 있는지 알아봅시다:\n\n![Sentinel-2 이미지](/TIL/assets/img/2024-07-12-SatellitesCanSeeInvisibleLavaFlowsandActiveWildfiresButHowPython_12.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n별 차이가 없네요!!\n\n여기에 설명된 대로, 화산 상황과는 달리 근적외선은 가시적인 대역과 유사하게 산란되어 연기 아래에서 무슨 일이 일어나는지 밝혀내기에 유용하지 않았습니다. Sentinel-2에는 근적외선보다 파장이 긴 두 개의 단파장 적외선 대역이 있기 때문에, 이 이미지를 그 두 개의 단파장 적외선 대역과 근적외선을 사용하여 한 번 더 그려보고 시각화에서 가시 대역을 제거했습니다:\n\n![이미지](/TIL/assets/img/2024-07-12-SatellitesCanSeeInvisibleLavaFlowsandActiveWildfiresButHowPython_13.png)\n\n인상적이지 않나요?\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n단파적 적외선 대역은 짙은 연기를 관통하여 불 타는 지역(반짝이고 황금빛 픽셀)을 굵은 연기층 아래서 보여줄 수 있었습니다. 이러한 지역을 찾는 것은 적외선 대역만으로 또는 가시적 및 근적외선 영역의 조합으로는 볼 수 없었던 것들을 고 관리 및 산불 모니터링에 중요할 수 있습니다.\n\n마지막 단계로, 이들을 함께 모아서 이 템플릿을 사용하여 예시별 이미지를 옆에 놓고 그림을 그리겠습니다:\n\n```js\nimport rasterio\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# 쌓인 이미지 플로팅\nwith rasterio.open(\"stacked_TOA.tif\") as src:\n    # 밴드 인덱스 정의\n    blue_band = 1\n    green_band = 2\n    red_band = 3\n    nir_band = 4\n    swir1_band = 5\n    swir2_band = 6\n\n    # 밴드 읽기\n    red = src.read(red_band)\n    green = src.read(green_band)\n    blue = src.read(blue_band)\n    nir = src.read(nir_band)\n    swir1 = src.read(swir1_band)\n    swir2 = src.read(swir2_band)\n\n    # 게인 적용\n    gain = 2\n    red_n = np.clip(red * gain / 10000, 0, 1)\n    green_n = np.clip(green * gain / 10000, 0, 1)\n    blue_n = np.clip(blue * gain / 10000, 0, 1)\n    nir_n = np.clip(nir * gain / 10000, 0, 1)\n    swir1_n = np.clip(swir1 * gain / 10000, 0, 1)\n    swir2_n = np.clip(swir2 * gain / 10000, 0, 1)\n\n    # 다른 컴포지트 생성\n    rgb_composite = np.dstack((red_n, green_n, blue_n))\n    nir_composite = np.dstack((nir_n, red_n, green_n))\n    swir_composite = np.dstack((swir2_n, swir1_n, nir_n))\n\n    # 컴포지트 플로팅\n    plt.figure(figsize=(24, 8))\n\n    plt.subplot(131)\n    plt.title('Red, Green and Blue', fontsize=18, fontweight='bold')\n    plt.imshow(rgb_composite)\n    plt.axis('off')\n\n    plt.subplot(132)\n    plt.title('Near-infrared, Red, Green', fontsize=18, fontweight='bold')\n    plt.imshow(nir_composite)\n    plt.axis('off')\n\n    plt.subplot(133)\n    plt.title('Infrared Bands: Shortwave and Near-infrared', fontsize=18, fontweight='bold')\n    plt.imshow(swir_composite)\n    plt.axis('off')\n    \n    # 플롯 저장\n    plt.savefig('composite_plot.png')\n\n    plt.show()\r\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-SatellitesCanSeeInvisibleLavaFlowsandActiveWildfiresButHowPython_14.png\" /\u003e\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-SatellitesCanSeeInvisibleLavaFlowsandActiveWildfiresButHowPython_15.png\" /\u003e\n\nSentinel-2 섹션에서 언급했듯이, 이 위성은 13개의 밴드를 가지고 있으며, 이 중 9개는 적외선 영역에 해당됩니다. 우리는 연기 아래 숨겨진 물체들을 드러내기 위해 적외선 영역의 세 밴드만 사용했습니다. 다른 적외선 밴드들인 레드 엣지(Band 5, 6, 7, 그리고 8A)를 사용하여 용암이나 화재가 발생한 지역의 시각화를 탐색해보세요. 그 결과에 미치는 영향을 관찰해보세요.\n\n## 📄 결론\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이미지 비교 — 하나는 가시 영역에서 촬영되었고 다른 것들은 적외선 대역에서 촬영된 것입니다. 이 비교를 통해 다양한 전자기 스펙트럼에서 눈과 센서를 가지고 있는 능력과 중요성이 드러났습니다. 적외선 데이터의 추가적인 레이어는 RGB 이미지에서 보이지 않던 활성화된 용암 흐름과 화재 지역을 명확하게 식별하고 매핑할 수 있게 해줍니다. 가시광에 비해 적외선 대역의 우수한 침투력은 센서가 연기로 가려져있는 활성 용암과 활성 화재와 같은 물체의 존재를 감지할 수 있게 합니다. 이 능력은 이러한 사건들의 잠재적 위험을 평가하고 재난 완화를 위한 적시의 결정을 내릴 수 있는 능력을 향상시킵니다.\n\n## 📚 참고 자료\n\nCopernicus Sentinel 데이터 [2024]에 대한 Sentinel 데이터\n\nCopernicus 서비스 정보 [2024]에 대한 Copernicus 서비스 정보\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n📱 저와 더 많은 콘텐츠를 공유하기 위해 다른 플랫폼에서 저와 연결해보세요! LinkedIn, ResearchGate, Github, 그리고 Twitter.\n\n이 링크를 통해 확인할 수 있는 관련 게시물이 있습니다:","ogImage":{"url":"/TIL/assets/img/2024-07-12-SatellitesCanSeeInvisibleLavaFlowsandActiveWildfiresButHowPython_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-SatellitesCanSeeInvisibleLavaFlowsandActiveWildfiresButHowPython_0.png","tag":["Tech"],"readingTime":23}],"page":"1","totalPageCount":24,"totalPageGroupCount":2,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"1"},"buildId":"71zJMhK9mFbQV7s02rMGq","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>