<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>TIL</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//posts/15" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="TIL" data-gatsby-head="true"/><meta property="og:title" content="TIL" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//posts/15" data-gatsby-head="true"/><meta name="twitter:title" content="TIL" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/7978fe7362f7d4c9.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/7978fe7362f7d4c9.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/873-eb138c3217d71553.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/posts/%5Bpage%5D-de1dc5579188f9be.js" defer=""></script><script src="/TIL/_next/static/o6AmBAY_j9v9JmbaRA39X/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/o6AmBAY_j9v9JmbaRA39X/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="첫 로컬 LLM 실행 방법 " href="/TIL/post/2024-07-13-HowtorunyourfirstlocalLLMs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="첫 로컬 LLM 실행 방법 " loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="첫 로컬 LLM 실행 방법 " loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">첫 로컬 LLM 실행 방법 </strong><div class="PostList_meta__VCFLX"><span class="date">Jul 13, 2024</span><span class="PostList_reading_time__6CBMQ">22<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="PapersWithCode와 채팅할 수 있는 LLM-Powered 앱 만드는 방법" href="/TIL/post/2024-07-13-HowToBuildanLLM-PoweredAppToChatwithPapersWithCode"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="PapersWithCode와 채팅할 수 있는 LLM-Powered 앱 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-13-HowToBuildanLLM-PoweredAppToChatwithPapersWithCode_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="PapersWithCode와 채팅할 수 있는 LLM-Powered 앱 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">PapersWithCode와 채팅할 수 있는 LLM-Powered 앱 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 13, 2024</span><span class="PostList_reading_time__6CBMQ">18<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Python __all__ 이해하기 - 15초 설명" href="/TIL/post/2024-07-13-__all__inPythonExplainedin15Seconds"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Python __all__ 이해하기 - 15초 설명" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-13-__all__inPythonExplainedin15Seconds_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Python __all__ 이해하기 - 15초 설명" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Python __all__ 이해하기 - 15초 설명</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 13, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="초보자를 위한 실용적 GPT-4 프롬프트 안내 쉽게 만드는 No-Code 지도와 보고서" href="/TIL/post/2024-07-13-PragmaticGPT-4PromptingNiftyNo-CodeMapsandReportsforNoobs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="초보자를 위한 실용적 GPT-4 프롬프트 안내 쉽게 만드는 No-Code 지도와 보고서" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-13-PragmaticGPT-4PromptingNiftyNo-CodeMapsandReportsforNoobs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="초보자를 위한 실용적 GPT-4 프롬프트 안내 쉽게 만드는 No-Code 지도와 보고서" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">초보자를 위한 실용적 GPT-4 프롬프트 안내 쉽게 만드는 No-Code 지도와 보고서</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 13, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="ETF 데이터 분석을 위한 Python 활용 금융 정보를 가져오고 분석하고 시각화하는 방법" href="/TIL/post/2024-07-13-PythonforETFDataAnalysisHowtoFetchAnalyzeandVisualizeFinancialInformation"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="ETF 데이터 분석을 위한 Python 활용 금융 정보를 가져오고 분석하고 시각화하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-13-PythonforETFDataAnalysisHowtoFetchAnalyzeandVisualizeFinancialInformation_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="ETF 데이터 분석을 위한 Python 활용 금융 정보를 가져오고 분석하고 시각화하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">ETF 데이터 분석을 위한 Python 활용 금융 정보를 가져오고 분석하고 시각화하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 13, 2024</span><span class="PostList_reading_time__6CBMQ">23<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="데이터 시각화 갓템, Quad-Tile Chart와 Squaremap 사용법 소개" href="/TIL/post/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="데이터 시각화 갓템, Quad-Tile Chart와 Squaremap 사용법 소개" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="데이터 시각화 갓템, Quad-Tile Chart와 Squaremap 사용법 소개" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">데이터 시각화 갓템, Quad-Tile Chart와 Squaremap 사용법 소개</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 13, 2024</span><span class="PostList_reading_time__6CBMQ">59<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="FB Prophet과 하이퍼파라미터 최적화를 사용한 BTC-USD 가격 예측, 교차 검증 QC, 수정된 알고리즘 거래 전략" href="/TIL/post/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="FB Prophet과 하이퍼파라미터 최적화를 사용한 BTC-USD 가격 예측, 교차 검증 QC, 수정된 알고리즘 거래 전략" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="FB Prophet과 하이퍼파라미터 최적화를 사용한 BTC-USD 가격 예측, 교차 검증 QC, 수정된 알고리즘 거래 전략" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">FB Prophet과 하이퍼파라미터 최적화를 사용한 BTC-USD 가격 예측, 교차 검증 QC, 수정된 알고리즘 거래 전략</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 13, 2024</span><span class="PostList_reading_time__6CBMQ">39<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="비용 없이 AI 도구만으로 ChatGPT를 능가하는 챗봇을 구축한 방법" href="/TIL/post/2024-07-13-HowIBuiltaChatbotthatCrushedChatGPTwithZeroCostAITools"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="비용 없이 AI 도구만으로 ChatGPT를 능가하는 챗봇을 구축한 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-13-HowIBuiltaChatbotthatCrushedChatGPTwithZeroCostAITools_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="비용 없이 AI 도구만으로 ChatGPT를 능가하는 챗봇을 구축한 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">비용 없이 AI 도구만으로 ChatGPT를 능가하는 챗봇을 구축한 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 13, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="딥러닝 메모리 관리 혁명 Torch Memoryadaptive Algorithms TOMA의 비밀" href="/TIL/post/2024-07-13-TorchMemoryadaptiveAlgorithmsTOMARevolutionizingMemoryManagementinDeepLearning"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="딥러닝 메모리 관리 혁명 Torch Memoryadaptive Algorithms TOMA의 비밀" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-13-TorchMemoryadaptiveAlgorithmsTOMARevolutionizingMemoryManagementinDeepLearning_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="딥러닝 메모리 관리 혁명 Torch Memoryadaptive Algorithms TOMA의 비밀" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">딥러닝 메모리 관리 혁명 Torch Memoryadaptive Algorithms TOMA의 비밀</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 13, 2024</span><span class="PostList_reading_time__6CBMQ">14<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="몰랐던 Jupyter의 숨겨진 해킹 5가지" href="/TIL/post/2024-07-13-5JupyterHacksThatYouNeverKnewEvenExisted"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="몰랐던 Jupyter의 숨겨진 해킹 5가지" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-13-5JupyterHacksThatYouNeverKnewEvenExisted_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="몰랐던 Jupyter의 숨겨진 해킹 5가지" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">몰랐던 Jupyter의 숨겨진 해킹 5가지</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 13, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/TIL/posts/1">1</a><a class="link" href="/TIL/posts/2">2</a><a class="link" href="/TIL/posts/3">3</a><a class="link" href="/TIL/posts/4">4</a><a class="link" href="/TIL/posts/5">5</a><a class="link" href="/TIL/posts/6">6</a><a class="link" href="/TIL/posts/7">7</a><a class="link" href="/TIL/posts/8">8</a><a class="link" href="/TIL/posts/9">9</a><a class="link" href="/TIL/posts/10">10</a><a class="link" href="/TIL/posts/11">11</a><a class="link" href="/TIL/posts/12">12</a><a class="link" href="/TIL/posts/13">13</a><a class="link" href="/TIL/posts/14">14</a><a class="link posts_-active__YVJEi" href="/TIL/posts/15">15</a><a class="link" href="/TIL/posts/16">16</a><a class="link" href="/TIL/posts/17">17</a><a class="link" href="/TIL/posts/18">18</a><a class="link" href="/TIL/posts/19">19</a><a class="link" href="/TIL/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"첫 로컬 LLM 실행 방법 ","description":"","date":"2024-07-13 20:12","slug":"2024-07-13-HowtorunyourfirstlocalLLMs","content":"\n\n![How to run your first local LLMs](/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_0.png)\n\n작년 동안 (2024년에 이 글을 쓰고 있기 때문에) 대형 언어 모델(LLMs)은 전문적인 환경과 작업 수행 방식을 변화시켰습니다.\n\nChat GPT와 그들의 Chat 버전에 익숙하실 것입니다. 당신은 Chat GPT Plus 사용자(OpenAI의 유료 플랜)일 수도 있습니다. 또는 Anthropic이나 Google Bard와 같은 다른 유사한 제공 업체를 사용해본 적이 있을 수도 있습니다. 심지어 OpenAI와 경쟁 업체 모두 강력한 도구를 제공하지만, 여기 몇 가지 이유가 있어서 LLMs를 로컬에서 실행해 보려고 하는 것을 고려해볼만 합니다 (더 많을 수 있습니다!):\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 생태계에 대해 더 알고 새로운 모델을 시도하며 자신만의 경험을 소유하고 싶다면.\n- 딥 러닝과 LLMs에 대해 배우고 싶지만 시작할 곳을 모르겠거나 더 알고 싶다면; 오픈 소스 모델을 로컬에서 실행하는 것이 훌륭한 시작점이 될 수 있습니다.\n- 개인 정보를 오픈AI나 구글과 같은 대기업에 제공하고 싶지 않다면.\n- 인터넷 연결이 필요하지 않고 오프라인에서 실행할 수 있는 채팅 애플리케이션을 원한다면.\n- 금융이나 문학 작성과 같은 특정 작업을 위해 더 작고 특화된 모델로 실험하고 싶다면.\n\n얼마 전 나 또한 모든 이러한 요구 사항을 만족시켰습니다. 모든 이 기술 주변의 정보 양에 압도되었다고 느꼈습니다. 일반적인 조언으로 말할 때 목표가 오르막길처럼 느껴진다면 산만 바라보지 말고 가능한 한 빨리 첫 번째 발을 내딛어 올라가세요. 그리고 계속 그렇게 계단을 올라가다 보면 다음 산이 보이게 될 것입니다 (ㅋ).\n\n이 여정에서 첫 단계를 내딛도록 도와드리기 위해 프로세스를 아래 네 부분으로 나누어 설명했습니다:\n\n- 기본 개념 몇 가지: 이 섹션에서는 미리 알려진 지식을 가정하지 않고 자습서 전반에 걸쳐 사용되는 주요 용어와 아이디어를 소개합니다.\n- GPT4All에서 모델 실행: 오픈 소스 GUI 애플리케이션을 사용하여 로컬에서 모델을 실행합니다.\n- Jupyter 노트북에서 LangChain을 사용하여 로컬 LLMs 실행, Python 프로그래밍 기술은 필요하지만 LLMs에 대한 사전 경험이 없어도 됩니다.\n- LangChain과 Taipy를 사용하여 챗봇 생성.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n책임의 한계:\n\n- 이는 \"초보자용\" 접근법이므로 텍스트 생성 모델에 대해 작성하겠습니다.\n- 일부 모델은 기술적으로 로컬에서 실행할 수 있지만 자원을 많이 소비합니다(일반 가정용 컴퓨터나 노트북에서는 적어요). 만약 컴퓨터에 4GB의 RAM이 있다면, 실행 가능한 모델을 찾기 어려울 것입니다(그래도 여전히 몇 가지 모델을 즐겁게 시도해 볼 수 있습니다). 8GB(현재 대부분의 컴퓨터에 탑재된 메모리)가 있으면 여러 모델을 찾을 수 있지만 여전히 도전적 일 것입니다. 7GB에서 10GB 사이의 RAM이 필요한 모델을 찾기 쉽습니다.\n- 로컬에서 모델을 실행할 때 컴퓨터 소리가 전투기가 이륙하는 것처럼 들릴 수 있습니다. 이는 정상입니다.\n- GGUF 모델을 CPU로 로컬 컴퓨터에서 실행하는 방법에 대해 이야기하며 이것이 내가 알고 있는 가장 쉬운 옵션입니다. 입문자에게 100% 친숙합니다.\n- 모든 내용은 Windows 10에서 작동합니다.\n\n![그림링크](/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_1.png)\n\n# 몇 가지 기본 개념\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nLLM 랜드스케이프는 수십 개(아마 수백 개)의 새로운 용어, 용어, 개념 및 약어들을 가져왔어요. 쉽게 길을 잃을 수 있습니다. 이 섹션의 목표는 로컬에서 첫 번째 오픈 소스 모델을 사용하는 데 중요한 일부 주요 개념을 간단하게 설명하는 것입니다.\n\n- GGML 파일 : 이 파일 시스템은 이제 구식입니다(AI 세계는 빠르게 변화해요!), 하지만 여전히 주변에서 찾을 수 있습니다(그리고 이에 대한 튜토리얼도 많습니다). GPT-생성된 모델 언어를 나타냅니다. 이제 GGUF 모델을 다운로드해야 합니다.\n- GPT4All : 로컬(컴퓨터에서)에서 실행되는 그래픽 사용자 인터페이스(GUI)입니다. 챗 GPT 인터페이스와 비슷해요. 이 인터페이스를 사용하여 LLM을 로컬에서 실행할 수 있어요.\n- GGUF (GPT-생성된 통일 형식) 파일 : 로컬로 다운로드하고 실행할 수 있는 LLM 모델을 포함하는 파일입니다.\n- Hugging Face : 자연어 처리(NLP)에 초점을 맞춘 이익을 위한 회사로서, 최신 LLM의 개발 및 사용을 위한 플랫폼을 제공합니다. 이 플랫폼을 Hugging Face로도 참조할 수 있습니다. 이 플랫폼에서 많은 모델을 찾을 수 있어요(일부 모델은 로컬에서 실행할 수 있습니다).\n- LangChain : LLM 응용 프로그램을 만들기 위해 프레임워크를 개발한 회사입니다. 대부분의 경우 LangChain을 프레임워크를 가리키는 데 사용합니다. 이것은 LLM API(또는 로컬 파일!), 데이터베이스 연결, HTML 및 문서 파서에 연결할 수 있는 도구상자입니다. LangChain에는 Python API가 있습니다. 이 튜토리얼의 3부와 4부에서 사용할 겁니다.\n- 양자화 : 모델의 가중치와 바이어스의 정밀도를 줄여서 리소스가 제한된 장치에서 더 효율적으로 사용할 수 있도록 하는 것으로, 메모리 및 계산 요구 사항에 도움을 줍니다. 예를 들어, 2.45는 2.45 236987의 양자화 된 버전입니다. 덜 정확하지만 공간을 적게 차지하고 계산이 더 쉬운 숫자에 대해 더 적은 비트를 저장할 수 있습니다.\n\n## Hugging Face\n\nHugging Face은 다양한 LLM 모델을 다운로드할 수 있는 한 곳(주요한 곳?)입니다(다른 LLM 관련 도구들과 함께). 여기 목표는:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- GGUF 모델을 다운로드하는 방법을 안내해 드릴게요.\n- 다운로드하기 전에 확인해야 할 중요한 사항들을 몇 가지 소개해 드릴게요.\n\n이 글의 다음 부분에서는 GPT4all의 인터페이스에서 모델을 직접 다운로드하는 방법을 설명할 거에요. 따라서 가능한 더 적은 귀찮음을 원하신다면, 직접 그쪽으로 가셔서 모델을 다운로드할 수 있지만, 거기서는 다운로드할 수 있는 모델들이 적기 때문에, 적어도 이 글의 이 부분을 일반적인 지식으로 읽어보길 권장해 드려요.\n\n컴퓨터에서 로컬로 실행되는 GGUF 모델을 가져오려면, 먼저 모델 페이지로 이동해주세요.\n\n다음 단계는 모델을 필터링해서 GGUF 파일만 표시되도록 하는 것입니다. 페이지의 왼쪽 상단에 \"라이브러리\"를 선택하고 GGUF를 클릭하면 됩니다. 아래 이미지와 같이 하시면 되요:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![이미지](/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_2.png)\n\n아마도 많은 모델들이 특정 사용자 \"The Bloke\"로부터 온 것을 알게 될 것입니다. 다음 자습서에서는 그의 모델 중 일부를 사용할 것이지만, 선호하는 다른 모델을 선택해도 괜찮습니다!\n\nThe Bloke가 제공하는 GGUF 모델은 다른 모델의 양자화 버전입니다.\n\n이 예에서는 Mistral 7B Instruct v0.2 — GGUF라는 모델을 사용할 것입니다 (그리고 이외에도 1개의 아주 작은 모델이 있습니다. 아래 참조).\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 모델은 Mistral-7B-Instruct-v0.2라고 하는 원래 모델의 양자화된 버전입니다. 해당 Hugging Face 페이지를 확인할 수 있습니다 (해당 페이지에서 파일을 다운로드하지 마세요!) 및 Readme 페이지(주 페이지)의 정보, 파일 확장명 등을 양자화된 모델의 정보와 비교할 수 있습니다. 이 모델은 오픈 소스 LLMs 분야에서 중요한 역할을 하는 Mistral이 개발한 것입니다.\n\n다시 양자화된 모델 페이지(Mistral 7B Instruct v0.2 - GGUF)로 돌아가면, 다양한 크기의 버전을 다운로드할 수 있으며 필요한 최대 RAM을 확인할 수 있습니다. 4GB 컴퓨터로는 이 모델을 실행하기 어려울 것으로 보입니다 (이 섹션 맨 끝에 작은 모델을 나열해 두겠습니다). 8GB 컴퓨터를 사용하는 경우, 가장 무거운 모델을 실행할 수 없을 것입니다. 제 경우에는 mistral-7b-instruct-v0.2.Q4_K_M.gguf를 다운로드하기로 결정했습니다:\n\n- Q4_K_M은 양자화 방법입니다.\n- 파일 크기는 4.37GB입니다.\n- 6.87GB의 RAM이 필요합니다.\n\n![이미지](/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_3.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 더 작은 모델\n\n더 작은 모델을 사용하려면 TinyLlama-1.1B-Chat-v1.0-GGUF를 시도해볼 수 있어요.\n\n저도 사용할 거에요 (Taipy 앱을 위해), 왜냐하면 더 가벼우니까요 (더 빠르고... 그리고 덜 정확하죠). Mistral 7B Instruct v0.2 — GGUF와 똑같은 과정이에요.\n\n## 모델과 대화하기 위한 일부 Python 라이브러리\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 파이썬 방식에 따라 가시려면, 여기 몇 가지 라이브러리를 소개해 드릴게요. 이 라이브러리들을 사용하면 로컬 또는 비로컬로 간단한 채팅 인터페이스를 만들 수 있어요:\n\n- Taipy : 이 글의 마지막 부분에서 로컬 모델을 위한 매우 간단한 Taipy 채팅을 어떻게 만드는지 보여드릴 거에요.\n- Streamlit : Streamlit 애플리케이션을 만드는 것도 쉬워요. 다양한 튜토리얼이 많이 있어요.\n- Gradio : Gradio 앱은 Hugging Face 생태계에서 인기가 있어요. 이것을 아직은 제가 잘 알지 못하긴 한데요.\n\n# GPT4All 사용하기\n\nGPT4All은 로컬 컴퓨터에서 실행되는 채팅 인터페이스에요. 홈페이지에서 직접 설치 파일을 다운로드할 수 있어요. Windows용으로는 .exe 파일이며, 열어서 설치하면 되요... 그렇게 간단해요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위 이미지를 보시면 ChatGPT의 인터페이스와 비슷하게 보입니다:\n\n![ChatGPT Interface](/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_4.png)\n\n상당히 직관적인 것 같아요. 그러나 위 그림에 있는 것과 같이 3가지 중요한 요소를 언급하고 싶어요:\n\n- 프롬프팅 존... 이용하기 전에 모델을 로드해야 해요!\n- 왼쪽 상단의 \"버거 메뉴\"를 통해 채팅 기록을 확인할 수 있고, 해당 채팅에 사용한 모델을 기억합니다... 여기서 인터페이스에서 모델을 직접 다운로드할 수도 있어요.\n- 설정 버튼. 여기서 HuggingFace나 다른 곳에서 GGUF 파일을 다운로드할 디렉토리를 볼 수 있어요. 올바른 폴더에 다운로드하면 GPT4all이 그 파일들을 \"인식\"할 거예요.\n- 폴더에 여러 모델이 있는 경우, GUI 상단 중앙의 메뉴로 선택할 수 있어요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## GPT4All에서 모델 다운로드하기\n\nGPT4All에서 모델을 다운로드하려면 화면 오른쪽 상단의 버거 메뉴로 이동하십시오. 그리고 \"다운로드\"를 선택하십시오.\n\n![다운로드](/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_5.png)\n\n선택할 모델 목록이 표시됩니다. 원하는 모델을 선택하고 \"다운로드\"를 클릭하면 첫 번째 모델을 사용할 수 있습니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n미스트랄의 OpenOrca를 사용하고 있는데, 이 채팅 봇은 상당히 좋아요. 여기에서는 API 키를 제공하여 ChatGPT 모델을 선택할 수도 있습니다. 이 마지막 옵션은 아직 시도해보지 않았는데, 개인적으로는 의미가 없다고 생각해요.\n\n![이미지](/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_6.png)\n\n## 다른 모델을 다운로드할 GPT4All 폴더 선택하기\n\nHuggingFace와 같은 다른 모델을 사용하고 싶다면, 그 모델이 GPT4All이 모델을 찾는 폴더에 다운로드하면 됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n해당 위치를 찾으려면 설정 메뉴(오른쪽 상단의 작은 휠)를 클릭하세요. \"애플리케이션\"을 선택합니다. 로컬 폴더 경로는 \"다운로드 경로\" 옆에 있습니다:\n\n![이미지](/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_7.png)\n\n첫 번째 LLM 모델을 로컬에서 실행하는 가장 쉬운 방법은 아니더라도 가깝습니다! 즐겁게 사용하시길 바랍니다!\n\n# LangChain 사용하기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n알림: 이 방법은 Python의 기본적인 이해가 필요하지만 따르기 쉬워요. 노트북 사용자들(Jupyter Notebook, JupyterLab...)에 적합해요.\n\nLangChain은 LLM (Language Model)을 사용하여 LLM 애플리케이션을 만들 수 있게 해주는 Python 라이브러리에요 (당연한 얘기겠지만... LangChain과 LLM이 없이도 앱을 만들 수는 있어요. 다만, 그것들은 LLM 앱이 아닐 뿐이죠). LangChain은 데이터베이스에 연결하거나 문서나 웹을 파싱하거나 다양한 서비스에 쿼리를 날리는 API 클라이언트 등 Python 라이브러리들과 연결할 수 있어요.\n\n이번에는 LangChain을 사용하여 GGUF 파일을 가져와 대화하는 방법을 알려드릴게요.\n\nLangChain을 사용하기 위해 다음이 필요해요: \n\n- Langchain_community: Langchain을 위한 타사 통합 기능을 포함하고 있어요.\n- llama_cpp_python: llama.cpp를 위한 Python 바인더에요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nLlama.cpp은 다른 파일들과 함께 GGUF 파일을 다룰 수 있게 해줍니다!\n\n여기 나타난 예시를 보면, 단순히 llama_cpp_python만 사용할 수도 있지만, LangChain을 익히는 것이 더 좋은 아이디어이며 복잡성을 더하는 일이 거의 없습니다.\n\nJupyterLab을 사용하여 LLM 모델을 호출할 것이고, 이 작업은 다른 어떤 노트북이나 ^Python 파일에서도 작동해야 합니다.\n\n먼저 라이브러리를 가져와주세요:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nfrom langchain.callbacks.manager import CallbackManager\nfrom langchain.callbacks.streaming_stdout import StreamingStdOutCallbackHandler\nfrom langchain.prompts import PromptTemplate\nfrom langchain_community.llms import LlamaCpp\n```\n\n그 후, GGUF 파일로 모델 변수를 만들어보세요. 선택적으로 callback_manager도 만들 수 있습니다:\n\n```python\nmodel = \"path/to/model/mistral-7b-instruct-v0.2.Q4_K_M.ggu\"\n\n# Callbacks support token-wise streaming\ncallback_manager = CallbackManager([StreamingStdOutCallbackHandler()])\n```\n\n이제, prompts를 인수로 받아 답변을 생성할 llm 객체를 만들 수 있습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nllm = LlamaCpp(\n    model_path=model,\n    callback_manager=callback_manager, #Optional, streams the response as it is generated\n    verbose=True,  # Verbose is required to pass to the callback manager\n)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nprompt_addon = \"\u003cs\u003e[INST]파이썬 명령어를 만들어 'hello world'를 출력하도록 합니다[/INST]print('hello world')\u003c/s\u003e\"\nprompt = \"\"\"\n주어진 숫자까지의 피보나치 수열을 반환하는 파이썬 함수를 작성하십시오. 독스트링을 추가하세요.\n\"\"\"\nllm.invoke(f\"{prompt_addon}[INST]{prompt}[/INST]\")\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_8.png\" /\u003e\n\n# Taipy를 사용하여 작은 채팅 인터페이스 만들기\n\nLangChain 보드 대신에, Taipy와 같은 Python 웹 애플리케이션 빌더와 함께 사용할 수 있습니다. 이 라이브러리에 대해 더 알고 싶으시다면, 이전에 관련한 기사를 썼었지만, 라이브러리에 대해 많이 알지 못해도 어플리케이션을 작동시킬 수 있을 것입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저는 다음 예시를 Taipy 팀의 튜토리얼에서 수정했어요. 그래서 많은 창의성은 그들에게 돌아갑니다. 다른 점은 OpenAI의 GPT 모델(그들의 API로) 대신 로컬 모델을 사용한다는 것이에요.\n\n위 예시의 라이브러리들(LangChain와 Llama_Cpp)이 필요하고 당연히 Taipy를 설치해야 해요 ( pip install taipy ).\n\nPython 함수와 Taipy 코드를 모두 넣을 main.py 라는 파일을 만들어야 해요.\n\n첫째, 라이브러리를 가져와요. 앱이 채팅을 표시할 것이기 때문에 출력을 스트리밍할 필요 없어요. 그냥 가져오세요:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nfrom langchain.callbacks.manager import CallbackManager\nfrom langchain_community.llms import LlamaCpp\nfrom taipy.gui import Gui, State\n```\n\n타이피(Taipy)에서 상태(State)는 앱에서 변수의 \"현재 상태\"를 가리킵니다. 이러한 변수에 초기 값을 할당한 후, 그 값은 앱에서 변경됩니다: 사용자가 값 변경하거나 함수의 결과로 값이 변경될 수 있습니다.\n\n두 개의 변수, conversation(대화)와 current_user_message(현재 사용자 메시지)를 만들어 봅시다. 대화는 대화창에 보낸 메시지와 그에 대한 답변의 기록입니다. current_user_message는 사용자가 프롬프트로 입력할 메시지를 나타냅니다.\n\n성능상의 이유로 tinyllama-1.1b-chat-v1.0.Q4_K_M 모델을 사용하겠습니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n대화 = {\n    \"Conversation\": [\n        \"너 누구니?\",\n        \"안녕! 나는 작은 LLama야. 너의 컴퓨터에서 돌아가는 모델이지. 오늘 어떻게 도와줄까?\",\n    ]\n}\n\ncurrent_user_message = \"\"\n```\n\n다음으로, 모델을 실행하는 함수를 만들어보겠어요. 여기서 예시로 Tiny LLama 모델 GGUF 파일을 사용합니다.\n\n```js\n모델 = (\n    \"경로/모델/tinyllama-1.1b-chat-v1.0.Q4_K_M.gguf\"\n)\n\nllm = LlamaCpp(model_path=모델)\n```\n\n그런 다음, 채팅을 처리하는 2개의 함수를 만들 수 있어요. 먼저, 모델에 질문을 보내고 답변을 받는 request()라는 함수를 정의해주세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n**Note:** The function generates a prompt based on the model specified in the documentation. According to the documentation, you should follow the prompt template \"Zephyr\", which is different from the one used for Mistral 7B shown above:\n\n```js\n\u003c|system|\u003e\n{system_message}\u003c/s\u003e\n\u003c|user|\u003e\n{prompt}\u003c/s\u003e\n\u003c|assistant|\u003e\n```\n\nBelow is the function:\n\n```js\ndef request(state: State, prompt: str, conv_list: list) -\u003e str:\n    \"\"\"\n    Send a prompt to the local LLM and return the response.\n\n    Args:\n        - state: The current state.\n        - prompt: The prompt to send to the LLM.\n\n    Returns:\n        The response from the LLM.\n    \"\"\"\n\n    # Get the previous conversations to create the prompt history\n    system_message = \"\u003c|system|\u003e\\nYou are a geography expert and assist users by answering their questions\u003c/s\u003e\\n\"\n    # Get the previous conversations to create the prompt history\n    history_prompt = \"\"\n    for index, conv_element in enumerate(conv_list):\n        if index % 2 == 0:\n            history_prompt += f\"\u003c|user|\u003e\\n{conv_element}\u003c/s\u003e\\n\"\n        else:\n            history_prompt += f\"\u003c|assistant|\u003e\\n{conv_element}\u003c/s\u003e\\n\"\n    full_prompt = (\n        f\"{system_message}{history_prompt}\u003c|user|\u003e\\n{prompt}\u003c/s\u003e\\n\u003c|assistant|\u003e\"\n    )\n\n    response = state.llm(full_prompt)\n\n    return response\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그리고 이제 Taipy GUI 인터페이스와 상호 작용하는 send_message() 함수를 정의할 수 있습니다:\n\n```js\ndef send_message(state: State) -\u003e None:\n    \"\"\"\n    사용자의 메시지를 llm 함수로 전송합니다.\n    Args:\n        - state: 현재 상태.\n    \"\"\"\n    # 입력 필드 지우기\n    conv = state.conversation._dict.copy()\n\n    # 사용자 질문을 지역 LLM 모델에 요청합니다.\n    conv_list = conv[\"Conversation\"]\n    answer = request(state, state.current_user_message, conv_list).replace(\"\\n\", \"\")\n\n    conv[\"Conversation\"] += [state.current_user_message, answer]\n    state.current_user_message = \"\"\n    state.conversation = conv\n```\n\n## 사용자 인터페이스 만들기\n\n페이지를 초기화하려면 아래 코드를 추가하면 됩니다. 페이지 객체는 페이지 구조를 정의합니다. 원하신다면 markdown 구문을 추가할 수 있습니다(제목 또는 원하는 내용). 여기에는 없습니다. 그리고 Taipy 요소를 `|...|` 사이에 추가할 수 있습니다. 더 자세한 정보가 필요하다면 Taipy에 관한 다른 글을 참조하는 것을 권장합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\npage = \"\"\"\n\u003c|{대화}|table|show_all|\u003e\n\u003c|{current_user_message}|input|label=메시지를 입력하세요...|on_action=send_message|class_name=fullwidth|\u003e\n\"\"\"\n\nif __name__ == \"__main__\":\n    Gui(page).run(dark_mode=True, title=\"Taipy와 지역 LLM 채팅\")\n```\n\n## 선택 사항: CSS 변경\n\nTaipy의 튜토리얼에는 CSS 코드와 적용하는 함수가 있습니다. 여기에 완벽한 지침이 있도록 무심코 그것을 복사합니다. 이 부분에 대해 100%의 크레딧은 그들에게 갑니다.\n\nmain.py 파일 옆에 main.css 파일을 만들어 다음 코드를 붙여넣으세요:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n.gpt_message td {\n    margin-left: 30px;\n    margin-bottom: 20px;\n    margin-top: 20px;\n    position: relative;\n    display: inline-block;\n    padding: 20px;\n    background-color: #ff462b;\n    border-radius: 20px;\n    max-width: 80%;\n    box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);\n    font-size: large;\n}\n\n.user_message td {\n    margin-right: 30px;\n    margin-bottom: 20px;\n    margin-top: 20px;\n    position: relative;\n    display: inline-block;\n    padding: 20px;\n    background-color: #140a1e;\n    border-radius: 20px;\n    max-width: 80%;\n    float: right;\n    box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);\n    font-size: large;\n}\n```\n\n그리고 다음 Python 함수를 만들어주세요. 해당 함수는 main.py 파일에 위치시키실 수 있습니다. 이 함수는 페이지에 스타일을 적용합니다:\n\n```js\ndef style_conv(state: State, idx: int, row: int) -\u003e str:\n    \"\"\"\n    Apply a style to the conversation table depending on the message's author.\n\n    Args:\n        - state: The current state of the app.\n        - idx: The index of the message in the table.\n        - row: The row of the message in the table.\n\n    Returns:\n        The style to apply to the message.\n    \"\"\"\n    if idx is None:\n        return None\n    elif idx % 2 == 0:\n        return \"user_message\"\n    else:\n        return \"gpt_message\"\n```\n\n다음으로, 페이지 객체를 수정하시어 스타일이 적용되도록 하실 수 있습니다. 아래와 같이 conversation 요소에 style=style_conv|를 추가해주세요:\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n페이지 = \"\"\"\n\u003c|{conversation}|표|모든_표시|스타일=style_conv|\u003e\n\u003c|{current_user_message}|입력|레이블=여기에 메시지를 입력하세요...|작업=send_message|클래스_이름=전체너비|\u003e\n\"\"\"\n```\n\n## 앱 실행하기\n\n앱을 실행하려면 main.py 파일을 다른 Python 파일처럼 호출하면 됩니다!\n\n아래 이미지에서 보시다시피, 작은 모델이 좋지 않고 지리가 주 용도가 아닌 것 같습니다. 하지만 한 가지 확실한 것은 웹 앱에서 로컬 모델이 실행되고 있다는 것이며, 이것은 정말 멋집니다!\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_9.png)\n\nThank you for reading!\n\nIf you enjoyed my content and would like to connect:\n\n👉 You can connect with me on LinkedIn\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n👉 제 개인 웹사이트를 확인해보세요","ogImage":{"url":"/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_0.png","tag":["Tech"],"readingTime":22},{"title":"PapersWithCode와 채팅할 수 있는 LLM-Powered 앱 만드는 방법","description":"","date":"2024-07-13 20:10","slug":"2024-07-13-HowToBuildanLLM-PoweredAppToChatwithPapersWithCode","content":"\n\n최신 기계 학습 연구 소식을 따라가기 어려우신가요? LLMs, 벡터 데이터베이스 또는 RAGs에 관한 논문 양에 압도당하셨나요?\n\n백엔드 쪽에서는, 이 어시스턴트는 RAG(Retrieval Augmented Generation) 프레임워크로 구동될 것입니다. 이는 확장 가능한 서버리스 벡터 데이터베이스, VertexAI의 임베딩 모델, 그리고 OpenAI의 LLM을 활용합니다.\n\n프론트엔드 쪽에서는 이 어시스턴트가 Streamlit으로 제작된 인터랙티브하고 쉽게 배포 가능한 웹 애플리케이션에 통합될 것입니다.\n\n이 프로세스의 모든 단계는 아래에서 자세히 설명되며, 재사용하고 수정할 수 있는 동반되는 소스 코드가 함께 제공됩니다👇.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n준비되셨나요? 함께 알아봐요 🔍.\n\n독자 분들께서 독해를 시작하기 전에, 여기 Github에서 전체 소스 코드를 확인하실 수 있어요.\n\n# 1 — Papers With Code로부터 데이터 수집\n\nPapers With Code(일명 PWC)는 연구원과 실무자들을 위한 무료 웹사이트로, 최신의 최첨단 머신러닝 논문, 소스 코드, 데이터 세트를 찾고 따르는 곳이에요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-HowToBuildanLLM-PoweredAppToChatwithPapersWithCode_0.png\" /\u003e\n\n다행히도, PWC와 상호 작용하여 연구 논문을 프로그래밍 방식으로 검색할 수도 있습니다. 이 Swagger UI를 살펴보면 모든 사용 가능한 엔드포인트를 찾고 시도해 볼 수 있습니다.\n\n예를 들어, 특정 키워드로 논문을 검색해 보겠습니다.\n\n인터페이스에서 이렇게 할 수 있습니다: papers/ 엔드포인트를 찾아 쿼리( q ) 인자를 채웁니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n표 태그를 Markdown 형식으로 바꾸세요.\n\n그리고 실행 버튼을 클릭하세요.\n\n동등하게, 이 동일한 검색을 수행하려면 다음 URL을 클릭하면 됩니다.\n\n출력 응답은 결과의 첫 페이지만을 보여줍니다. 다음 페이지는 \"next\" 키에 접근하여 이용할 수 있습니다.\n\n이 구조를 이용하면 \"대형 언어 모델\"에 일치하는 7200개의 논문을 검색할 수 있습니다. URL을 요청하는 함수를 이용하여 모든 페이지에 대해 루프를 돌림으로써 간단히 수행할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nimport requests\nimport urllib.parse\nfrom tqdm import tqdm\n\ndef extract_papers(query: str):\n    query = urllib.parse.quote(query)\n    url = f\"https://paperswithcode.com/api/v1/papers/?q={query}\"\n    response = requests.get(url)\n    response = response.json()\n    count = response[\"count\"]\n    results = []\n    results += response[\"results\"]\n\n    num_pages = count // 50\n    for page in tqdm(range(2, num_pages)):\n        url = f\"https://paperswithcode.com/api/v1/papers/?page={page}\u0026q={query}\"\n        response = requests.get(url)\n        response = response.json()\n        results += response[\"results\"]\n    return results\n\nquery = \"Large Language Models\"\n\nresults = extract_papers(query)\n\nprint(len(results))\n# 7200\n```\n\n결과를 추출하면 해당 결과를 기반이로 LangChain 문서로 변환하여 단순히 청크화하고 색인화합니다.\n\n문서 객체에는 두 개의 매개변수가 있습니다:\n\n- page_content (str): 논문 초록의 텍스트를 저장하는 매개변수\n- metadata (dict): 추가 정보를 저장하는 매개변수. 우리의 사용 사례에서는 id, arxiv_id, url_pdf, 타이틀, 저자, 발표일을 유지할 것입니다\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nfrom langchain.docstore.document import Document\n\ndocuments = [\n    Document(\n        page_content=result[\"abstract\"],\n        metadata={\n            \"id\": result[\"id\"] if result[\"id\"] else \"\",\n            \"arxiv_id\": result[\"arxiv_id\"] if result[\"arxiv_id\"] else \"\",\n            \"url_pdf\": result[\"url_pdf\"] if result[\"url_pdf\"] else \"\",\n            \"title\": result[\"title\"] if result[\"title\"] else \"\",\n            \"authors\": result[\"authors\"] if result[\"authors\"] else \"\",\n            \"published\": result[\"published\"] if result[\"published\"] else \"\",\n        },\n    )\n    for result in results\n]\n```\n\n문서를 임베드하기 전에 작은 조각들로 나눠야 합니다. 이렇게 하면 LLMs의 입력 토큰 관련 제한을 극복할 수 있고 각 조각마다 세부 정보를 제공할 수 있습니다.\n\n우리는 길이가 1200 자이며 chunk_overlap가 200 인 Chunking을 통해 문서를 나누었더니 11,000개가 넘는 조각들이 생성되었습니다.\n\n```python\ntext_splitter = RecursiveCharacterTextSplitter(\n    chunk_size=1200,\n    chunk_overlap=200,\n    separators=[\".\"],\n)\nsplits = text_splitter.split_documents(documents)\n\nlen(splits)\n# 11308\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 2 — 업스태시에서 인덱스 생성하기\n\n문서 임베딩(및 메타데이터)을 저장하기 위해서는 먼저 인덱스를 생성해야 합니다.\n\n이 튜토리얼에서는 서버리스 데이터베이스인 업스태시를 사용할 것입니다.\n\n인덱스를 생성하려면 여기에 로그인하고 몇 가지 매개변수를 입력하는 지침을 따르면 됩니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 지역: 근처에 위치한 지역을 선택해주세요.\n- 차원 = 768로 설정하세요(VertexAI의 임베딩 차원)\n- 거리 메트릭 = 코사인으로 설정하세요.\n\n인덱스를 만든 후에는 upstash-vector를 설치해야 합니다.\n\n```js\npip install upstash-vector\n```\n\n이를 통해 인덱스에 연결을 설정할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nfrom upstash_vector import Index\n\nindex = Index(\n    url=\"\u003cUPSTASH_URL\u003e\", \n    token=\"\u003cUPSTASH_TOKEN\u003e\"\n)\n```\n\n# 3 — Embed the chunks and index them into Upstash\n\nTo embed the chunks and index them into the vector db, we’ll create a simple class that imitates LangChain Vectorstore implementation.\n\nThis class will be named UpstashVectorStore and will have the following methods:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Upstash Vector Store 클래스의 __init__ 생성자는 Upstash Index와 Embeddings 객체를 예상합니다.\n- 문서를 임베딩하고 일괄적으로 색인에 추가하려면 add_documents 를 사용합니다.\n- similarity_search_with_score 를 사용하여 인덱스를 쿼리하고 상위 k개의 가장 관련성 높은 문서 및 해당 점수를 검색합니다.\n\n다음은 전체 구현입니다:\n\n```js\nfrom typing import List, Optional, Tuple, Union\nfrom uuid import uuid4\nfrom langchain.docstore.document import Document\nfrom langchain.embeddings.base import Embeddings\nfrom tqdm import tqdm\nfrom upstash_vector import Index\n\n\nclass UpstashVectorStore:\n    def __init__(self, index: Index, embeddings: Embeddings):\n        self.index = index\n        self.embeddings = embeddings\n\n    def delete_vectors(\n        self,\n        ids: Union[str, List[str]] = None,\n        delete_all: bool = None,\n    ):\n        if delete_all:\n            self.index.reset()\n        else:\n            self.index.delete(ids)\n\n    def add_documents(\n        self,\n        documents: List[Document],\n        ids: Optional[List[str]] = None,\n        batch_size: int = 32,\n    ):\n        texts = []\n        metadatas = []\n        all_ids = []\n\n        for document in tqdm(documents):\n            text = document.page_content\n            metadata = document.metadata\n            metadata = {\"context\": text, **metadata}\n            texts.append(text)\n            metadatas.append(metadata)\n\n            if len(texts) \u003e= batch_size:\n                ids = [str(uuid4()) for _ in range(len(texts))]\n                all_ids += ids\n                embeddings = self.embeddings.embed_documents(texts, batch_size=250)\n                self.index.upsert(\n                    vectors=zip(ids, embeddings, metadatas),\n                )\n                texts = []\n                metadatas = []\n\n        if len(texts) \u003e 0:\n            ids = [str(uuid4()) for _ in range(len(texts))]\n            all_ids += ids\n            embeddings = self.embeddings.embed_documents(texts)\n            self.index.upsert(\n                vectors=zip(ids, embeddings, metadatas),\n            )\n\n        n = len(all_ids)\n        print(f\"Successfully indexed {n} dense vectors to Upstash.\")\n        print(self.index.stats())\n        return all_ids\n\n    def similarity_search_with_score(\n        self,\n        query: str,\n        k: int = 4,\n    ) -\u003e List[Tuple[Document, float]]:\n        query_embedding = self.embeddings.embed_query(query)\n        query_results = self.index.query(\n            query_embedding,\n            top_k=k,\n            include_metadata=True,\n        )\n        output = []\n        for query_result in query_results:\n            score = query_result.score\n            metadata = query_result.metadata\n            context = metadata.pop(\"context\")\n            doc = Document(\n                page_content=context,\n                metadata=metadata,\n            )\n            output.append((doc, score))\n        return output\n```\n\n이 클래스를 사용하여 청크를 색인화해 봅시다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nfrom langchain.embeddings import VertexAIEmbeddings\nfrom upstash_vector import Index\n\nindex = Index(\n    url=\"\u003cUPSTASH_URL\u003e\",\n    token=\"\u003cUPSTASH_TOKEN\u003e\",\n)\nembeddings = VertexAIEmbeddings(model_name=\"textembedding-gecko@003\")\n\nupstash_vector_store = UpstashVectorStore(index, embeddings)\nids = upstash_vector_store.add_documents(splits, batch_size=25)\n```\n\n이 과정은 분할 수, 연결 속도 및 선택한 배치 크기에 따라 시간이 걸릴 수 있습니다.\n\n색인 프로세스가 완료되면 UI에서 벡터 및 해당 메타데이터를 확인할 수 있습니다: 이는 레코드의 빠른 검사와 쉬운 관리(예: 삭제)에 도움이 됩니다.\n\n# 4 — 색인 된 논문에 대한 질문하기\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n추상이 올바르게 Upstash에 색인된 상태로, 이제 자연어로 상호작용하며 ML 주제에 대한 구체적인 질문을 할 수 있습니다.\n\n이게 생각보다 훨씬 쉽습니다.\n\n이를 위해 먼저, 질문을 받아 관련 문서를 벡터 저장소에서 검색하고 이를 사용하여 프롬프트를 작성하는 함수를 정의합시다.\n\n```js\ndef get_context(query, vector_store):\n    results = vector_store.similarity_search_with_score(query)\n    context = \"\"\n\n    for doc, score in results:\n        context += doc.page_content + \"\\n===\\n\"\n    return context\n\ndef get_prompt(question, context):\n    template = \"\"\"\n    주어진 문맥을 사용하여 질문에 답하는 것이 여러분의 작업입니다.\n\n    문맥 외의 것을 꾸며내지 마세요.\n    적어도 350자 이상으로 대답해 주세요.\n\n    %CONTEXT%\n    {context}\n\n    %Question%\n    {question}\n\n    Hint: 문맥을 그대로 복사하지 마세요. 여러분만의 말로 표현해 주세요.\n    \n    대답:\n    \"\"\"\n    prompt = template.format(question=question, context=context)\n    return prompt\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n영감이 떨어질 때가 있죠? 시작하는 데 도움이 될 질문이에요:\n\n```js\nquery = (\n    \"Retrieval Augmented Generation (RAG) 프레임워크 뒤의 문제는 무엇인가요?\"\n)\n\ncontext = get_context(query, upstash_vector_store)\nprompt = get_prompt(query, context)\n```\n\n다음은 문맥을 받은 후의 프롬프트 모습입니다:\n\n```js\n주어진 문맥을 활용해 질문에 답해 보는 것이 당신의 과제입니다.\n\n문맥 밖의 것은 광장을 만들지 마세요.\n적어도 350자 이상으로 답하세요.\n\n%CONTEXT%\n\nRetrieval-Augmented Generation (RAG)은 대규모 언어 모델의 환각을 완화하기 위한 \n유망한 접근 방식입니다. 그러나 기존 연구는 서로 다른 대규모 언어 모델에 대한 \n검색 증강 생성의 영향에 대한 철저한 평가가 부족하여, 서로 다른 대규모 언어 모델에 \n대한 RAG의 능력에 대한 잠재적 병목 현상을 식별하는 것이 어려운 상황입니다. \n우리는 이 논문에서 Retrieval-Augmented Generation이 대규모 언어 모델에 미치는 영향을 \n체계적으로 조사합니다. RAG가 요구하는 4가지 기본 능력인 노이즈 강건성, 부정 거부, \n정보 통합 및 반사적 강건성에 대한 다양한 대규모 언어 모델의 성능을 분석합니다. \n이를 위해 RAG 평가를 위한 새로운 말뭉치인 Retrieval-Augmented Generation \nBenchmark (RGB)를 설정합니다. 이 RGB는 영어와 중국어 모두에서 RAG 평가에 사용되는 \n새로운 말뭉치로, 해당 말뭉치 내의 인스턴스를 의미 있는 능력에 따라 4개의 별도의 \n테스트베드로 분류합니다. 그런 다음 RGB에서 6개의 대표적인 대규모 언어 모델을 \n평가하여 RAG를 적용할 때 현재 대규모 언어 모델의 도전에 대해 진단합니다.\n===\n대단한 능력을 갖고 있지만 대규모 언어 모델(LM)은 종적으로 알려진 정보에만 의존하여 \n사실적인 정확성을 가지지 않는 응답을 종종 생성합니다. Retrieval-Augmented Generation \n(RAG)은 LM을 관련 지식 검색으로 보완하는 무작위 접근법으로 이러한 문제를 줄입니다. \n그러나 검색이 필요한지, 또는 지식이 관련성이 있는지 여부에 상관없이 일정 수의 검색 \n내용을 무작위로 가져와 포함한다면, LM의 다양성이 감소하거나 도움이 되지 않는 \n응답 생성으로 이어질 수 있습니다. 우리는 Self-Reflective Retrieval-Augmented \nGeneration(Self-RAG)이라는 새로운 프레임워크를 소개합니다. 이 프레임워크는 검색 및 \n자기 반성을 통해 LM의 품질과 정확성을 향상시킵니다. 우리의 프레임워크는 필요 시 \n검색 결과를 가져와 동적으로 변화시키며, 특수 토큰인 반성 토큰을 사용하여 검색 결과와 \nLM의 생성물을 생성하고 반성합니다. 반성 토큰을 생성하면 LM이 추론 단계에서 조절 가능해져 \n다양한 작업 요구에 맞게 동작할 수 있습니다.\n...\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 LLM에게 대답 생성을 요청해보세요.\n\n```js\nfrom langchain.chat_models import AzureChatOpenAI\n\nllm = AzureChatOpenAI(\n    azure_deployment=\"\u003cAZURE_DEPLOYMENT\u003e\",\n    model=\"\u003cMODEL_NAME\u003e\",\n)\n\nanswer = llm.predict(prompt)\n```\n\n왔쪄요! 🥁\n\n```js\n검색 증강 생성 (RAG) 프레임워크는 핍을 피할 수 없는 검색 및 필요하지 않거나 관련성 없는 단락을 포함하여 도움이 되지 않는 응답 생성으로 이어질 수 있는 문제와 같은 문제가 있을 수 있습니다. 또한, 기존 연구는 RAG가 다양한 대형 언어 모델 (LLM)에 미치는 영향을 철저히 평가하지 않아 RAG의 다양한 LLM에 대한 기능 병목 현상을 식별하기 어렵게 만들고 있습니다. 이러한 문제를 해결하기 위해, 연구자들은 자기 반성 검색 증강 생성(Self-RAG) 프레임워크를 제안했으며, 이 프레임워크는 검색 및 자기 반성을 통해 LM의 품질과 사실성을 향상시킵니다. LLM의 다른 문제점 중 하나는 그들의 잊기죽임입니다. 그들은 시간이 흐를수록 개선되지 않거나 인간처럼 새로운 지식을 습득하지 않습니다. 이를 해결하기 위해, 연구자들은 RAG를 사용하여 문제 해결 성능을 향상시키는 방법을 탐구하고, ARM-RAG 시스템을 제안했습니다. 이 시스템은 높은 훈련 비용이 필요 없이 성공을 통해 학습합니다.\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n꽤 괜찮지 않아요?\n\n## 이 다이어그램으로 전체 워크플로우를 요약해 볼게요.\n\n# 5— Streamlit 애플리케이션에 통합하기\n\nUI에서 RAG와 상호 작용하기 위해 Streamlit 애플리케이션에 통합할 수 있어요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음은 Markdown 형식으로 변환한 것입니다:\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*zFIzwP4z8xmmvXSZFdnM8w.gif)\n\n혹시 앱을 로컬에서 시도해보고 코드를 만져보고 싶으시면 언제든지 환영합니다.\n\n# 몇 가지 핵심 포인트\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n많은 분들이 이미 자료와 대화하는 RAGs를 구축하셨습니다.\n\n제가 실제로 그러한 프로젝트의 실용성에 대해 솔직한 피드백을 드리겠습니다. 제 목표는 여러분이 RAGs를 만들지 않도록 방해하는 것이 아니라 이러한 솔루션에 대한 과대광고를 완화시키기 위해 세심한 의견을 제공하는 것입니다.\n\n우선 이점에서 시작해보겠습니다:\n\n- RAGs를 통해 외부 자료에 접근할 수 있습니다. 예를 들어, 저희가 개발한 앱은 Mistral이나 LLama2와 같은 최근 오픈 소스 LLM에 대한 정확한 답변을 제공합니다.\nChatGPT에 이러한 모델에 대해 질문을 하면 얻을 수 있는 것들을 확인해보세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n\n![RAGs 사용 예시](/TIL/assets/img/2024-07-13-HowToBuildanLLM-PoweredAppToChatwithPapersWithCode_1.png)\n\n- RAG를 사용하면 생성된 응답을 지탱하는 소스 문서를 인용할 수 있습니다. 이는 사용자 신뢰를 높이고 디버깅 및 해석 가능성에 도움을 줍니다.\n- RAG는 답변을 지탱하기 위해 외부 데이터만 활용하므로 LLM의 환형 경향을 제한합니다.\n- RAG는 상대적으로 쉽게 구축할 수 있습니다. 모델을 훈련하거나 세부 조정할 필요가 없기 때문에 비싼 컴퓨팅 자원이 필요하지 않습니다.\n\n그러나 RAG는 마법같이 즉시 해결되는 해결책은 아닙니다. \"기업\" 세계에서 이를 산업화하려면 고려해야 할 중요한 측면이 있습니다.\n\n- 그들의 영향력은 제공된 데이터에 따라 달라집니다. 예시 앱에서 우리는 논문 초록만 사용했습니다. 이는 일반적인 질문에 답변하는 데 좋은 시작점을 제공하지만 쿼리가 너무 복잡하고 전체 텍스트에 액세스가 필요한 경우에는 도움이 되지 않습니다.\n- 외부 구현된 RAG는 잘 작동하는 경우가 드뭅니다. 데모 목적으로는 좋지만 답변을 심층적으로 조사하기 시작하면 품질이 실망스러움을 빨리 깨닫게 됩니다. 그래서 철저한 조정, 평가 지표 및 인간의 개입이 필요합니다.\n- RAG는 모든 것에 대한 해결책이 아닙니다. 스타일 복사와 같은 일부 응용 프로그램은 모델 세부 조정으로 수행하는 것이 더 나은 결과를 보입니다.\n- RAG는 LLM의 컨텍스트 크기에 의해 제한됩니다. LLM의 컨텍스트 크기가 1백만 토큰이 되더라도 해당 데이터 양으로 프롬프트하는 것이 좋은 아이디어는 아닙니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론\n\n지금까지 읽어주셔서 감사합니다.\n\n만약 이 어시스턴트를 향상시키고 다음 단계로 나아가길 원한다면, 아래 아이디어를 탐색하거나 구현해 보세요.\n\n- 요약이 아닌 전체 텍스트 사용\n- 메타데이터 필터링과 벡터 검색 보완\n- 밀도 검색이 아닌 하이브리드 검색 시도하기: 키워드 검색이 의왜 검색을 놀랍게 향상시킵니다.\n- 검색 후 문서 재랭크: 이를 통해 보다 많은 문서를 검색하고 중요한 것들을 자세히 살펴볼 수 있습니다.\n- 사용자 쿼리 확장\n- 임베딩 세밀 조정\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이전에 작성한 개선된 검색 기술에 관한 글이에요.\n\n여기 👇에서 확인해보세요.\n\n읽어 주셔서 감사합니다 📖.","ogImage":{"url":"/TIL/assets/img/2024-07-13-HowToBuildanLLM-PoweredAppToChatwithPapersWithCode_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-HowToBuildanLLM-PoweredAppToChatwithPapersWithCode_0.png","tag":["Tech"],"readingTime":18},{"title":"Python __all__ 이해하기 - 15초 설명","description":"","date":"2024-07-13 20:09","slug":"2024-07-13-__all__inPythonExplainedin15Seconds","content":"\n\n\n![image](/TIL/assets/img/2024-07-13-__all__inPythonExplainedin15Seconds_0.png)\n\n## Case 1: No __all__\n\n```python\n# a.py\n\na = 'apple'\nb = 'boy'\nc = 'cat'\nd = 'donkey'\ne = 'elephant'\nf = 'fish'\n```\n\n```python\n# b.py\n\nfrom a import *\n\nprint(dir())\n\n# [..., 'a', 'b', 'c', 'd', 'e', 'f']\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기서 from a import *는 a.py에서 모든 항목을 b.py로 가져옵니다. 이것이 b.py의 dir()에 a, b, c, d, e 및 f가 나타나는 이유입니다.\n\n# Case 2: __all__이 정의된 경우\n\n```python\n# a.py\n\na = 'apple'\nb = 'boy'\nc = 'cat'\nd = 'donkey'\ne = 'elephant'\nf = 'fish'\n\n__all__ = ['a', 'b']\n```\n\n```python\n# b.py\n\nfrom a import *\n\nprint(dir())\n\n# [..., 'a', 'b']\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위에서 \"from a import *\"은 a와 b만 가져옵니다. 이는 a.py의 __all__ 때문에 b.py에게 a와 b만 가져와야 한다고 알려주기 때문입니다.\n\n참고 - 이 작업은 \"from a import *\"에서만 작동합니다. 여전히 from a import c, d, e, f를 사용할 수 있습니다.\n\n# 왜/언제 사용해야 하는가\n\n만약 a.py에 무작위로 많은 것이 들어있지만 우리가 '내보낼' 것은 a와 b뿐이라면, 우리가 from a import *를 사용할 때 실수로 많은 불필요한 것들을 가져오지 않도록 하기 위해 __all__을 사용해야 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론\n\n이해하기 쉽고 명확했길 바랍니다.\n\n# 만약 제작자로서 저를 지원하고 싶다면\n\n- 이 이야기에 대해 50번 박수를 치세요\n- 귀하의 생각을 나에게 알려주는 댓글을 남겨주세요\n- 이야기 중 가장 좋아하는 부분을 강조해주세요\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n감사합니다! 이런 작은 조치들이 큰 도움이 되고, 정말 감사합니다!\n\nYouTube: [https://www.youtube.com/@zlliu246](https://www.youtube.com/@zlliu246)\n\nLinkedIn: [https://www.linkedin.com/in/zlliu/](https://www.linkedin.com/in/zlliu/)","ogImage":{"url":"/TIL/assets/img/2024-07-13-__all__inPythonExplainedin15Seconds_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-__all__inPythonExplainedin15Seconds_0.png","tag":["Tech"],"readingTime":3},{"title":"초보자를 위한 실용적 GPT-4 프롬프트 안내 쉽게 만드는 No-Code 지도와 보고서","description":"","date":"2024-07-13 20:08","slug":"2024-07-13-PragmaticGPT-4PromptingNiftyNo-CodeMapsandReportsforNoobs","content":"\n\n\n![Image](/TIL/assets/img/2024-07-13-PragmaticGPT-4PromptingNiftyNo-CodeMapsandReportsforNoobs_0.png)\n\n20년 이상의 컴퓨터 과학 교수로서, 데이터 시각화를 위해 Python 코딩을 하는 데 풍부한 경험이 있습니다.\n\n최근까지 아름다운 데이터 시각화 생성은 저와 같은 사람들 - 컴퓨터 프로그래머 및 데이터 분석가만의 영역이었습니다.\n\n그러나 지금은 GPT-4 채팅 인터페이스에 통합된 새로운 데이터 분석 도구들로 이것이 변화했습니다. 이제 실시간으로 지도와 차트를 생성할 수 있고, 그것들을 전체 PDF 보고서에 포함시킬 수 있습니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n태그를 Markdown 형식으로 변경하시면 됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n평화와 경제에 대한 비전을 갖춘 인스티튜트가 제공하는 경제와 평화에 관한 데이터는 Global Peace Index에서 다운로드할 수 있습니다.\n\n지금은 GPT-4가 오늘의 상태에서 데이터 파일을 다운로드할 수 없습니다. 이것이 이 LLM의 향후 버전에서 업데이트되길 희망하고 있습니다.\n\n이 링크에서 다운로드를 시작할 수 있습니다 (XSLX 형식). \n\n[![이미지](/TIL/assets/img/2024-07-13-PragmaticGPT-4PromptingNiftyNo-CodeMapsandReportsforNoobs_1.png)](링크)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파일을 다운로드하면 Excel(또는 Numbers)에서 열어서 \"Overall Scores\" 탭을 클릭할 수 있습니다. 다음과 같은 내용을 볼 수 있어요:\n\n![Overall Scores](/TIL/assets/img/2024-07-13-PragmaticGPT-4PromptingNiftyNo-CodeMapsandReportsforNoobs_2.png)\n\n다음으로는 이미지에서 강조된 첫 3행을 선택하여 삭제하고, 이 행들을 제거한 후에 이 시트를 global_peace_index.csv라는 CSV 파일로 내보낼 수 있어요. \n\n이제 GPT-4를 시작할 준비가 되었습니다. 채팅 창을 열고, 주 채팅 창에서 첨부 파일 아이콘을 클릭하세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-PragmaticGPT-4PromptingNiftyNo-CodeMapsandReportsforNoobs_3.png\" /\u003e\n\n컴퓨터에서 파일을 업로드하라는 메시지가 표시됩니다. 새로 만든 global_peace_index.csv 파일을 찾아 열기를 클릭해주세요.\n\nGPT-4가 이 파일에 액세스할 수 있게 되면, 파일에 대해 질문을 시작할 수 있습니다. 우선, GPT-4에게 이 CSV 파일에 대한 간단한 개요와 각 필드에 대한 설명을 요청해보겠습니다.\n\nGPT-4에게 요청하는 내용: 이 CSV 파일의 간단한 개요와 각 필드에 대한 설명을 제공해주시겠어요?\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nGPT-4의 응답:\n\n![이미지](/TIL/assets/img/2024-07-13-PragmaticGPT-4PromptingNiftyNo-CodeMapsandReportsforNoobs_4.png)\n\n와우! 지금까지 모든 것이 잘 진행 중입니다! 이제 데이터 시각화를 위해 프롬프트를 시작할 수 있을 거에요.\n\n하지만 어디서 시작해야 할까요? 우리가 알고 싶은 것은 무엇일까요? 잘 모르시나요? GPT-4에게 물어볼까요? 아마 여기서 좋은 아이디어가 있을지도 몰라요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n확실해요! 이 데이터세트에서 제공된 필드만 사용해서 데이터 시각화를 위한 5가지 좋은 아이디어를 제공할게요:\n\n- 시계열 분석: 특정 국가들의 GPI 점수 추이를 보여주기 위해 2008년부터 2022년까지 라인 차트를 만듭니다. 비교를 위해 세계 평균 선을 포함할 수 있습니다.\n- 세계 지도를 이용한 GPI 점수 시각화: 각 국가의 GPI 점수를 선택한 연도를 기준으로 시각적으로 나타내기 위해 세계 지도를 활용합니다. 사용자가 연도를 변경하고 세계 평화의 변화를 확인할 수 있는 인터랙티브 기능이 포함될 수 있습니다.\n- 지역평화 추세에 대한 비교 막대그래프: 국가들을 지역(유럽, 아시아, 아프리카 등)별로 그룹화하고 막대그래프를 사용하여 평균 GPI 점수를 표시합니다. 이를 통해 다양한 지역 간의 평화 수준을 비교할 수 있습니다.\n- 연도별 GPI 점수 분포를 위한 상자그림 분석: 각 연도별로 전체적인 GPI 점수 분포를 보여줍니다.\n- GPI 점수 변화를 나타내는 열지도: 각 국가의 2008년부터 2022년까지의 GPI 점수 변화를 시각화하기 위해 열지도를 생성합니다.\n\n좋은 아이디어들이에요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 GPT-4가 무엇을 생산할 수 있고 할 수 없는지 알고있는 지식이 유용할 때입니다. \n\n저는 이를 많이, 정말 많이 해봤기 때문에 이 결과를 기반으로 안내할 수 있어요. 이 5개의 응답에 대해 제가 아는 것은 다음과 같아요:\n\n- 아이디어 #2 — GPT-4는 아직 순간적으로 상호작용하는 시각화를 만들 수 없어요.\n- 아이디어 #3 — GPT-4는 가정을 했어요 — CSV 파일에는 데이터 그룹화가 없기 때문에 추가 데이터가 필요할 거에요.\n- 아이디어 #5 — GPT-4는 데이터 시각화의 최상의 관행을 명확하게 이해하고 있지 않아요. 히트맵을 만드는 데 추가적인 안내가 필요할 거예요.\n\n참고: 여기서 중요한 점은 GPT-4를 작업에 집중하도록 유도하는 것인데, LLM이 데이터셋의 필드를 사용하는 예제만 만들 수 있다는 것을 명확히 해야 해요. 그렇지 않으면 사용 가능한 필드로는 불가능한 가정을 할 가능성이 높아요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아이디어 #2는 좋은 시작점 같아요! 그럼 전세계 지도 시각화를 만들어볼까요?\n\n# 코로플레스 맵 생성\n\n코로플레스 맵은 나라별 전세계 평화 지수를 시각화하는 훌륭한 방법이에요.\n\n코로플레스 맵은 미리 정의된 지리적 영역에서 특정 데이터 변수를 나타내기 위해 다양한 음영/색상을 사용하는 테마틱 맵입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nGPT-4는 쉽게 코로플레스 맵을 만들 수 있어요. 깔끔하고 쉽죠.\n\nGPT-4에게 제시된 내용: 좋아요, 이제 아이디어 #2를 사용해서 2008년 GPI 점수의 전 세계 지도를 만들어 주세요.\n\nGPT-4의 응답:\n\n![GPI scores for 2008](/TIL/assets/img/2024-07-13-PragmaticGPT-4PromptingNiftyNo-CodeMapsandReportsforNoobs_5.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n와우, 그거 정말 쉬웠죠? 코드를 한 줄도 쓰지 않으셨나요? 전혀 안 썼네요.\n\n전문가 팁: 다른 색상 구성표를 사용하고 싶다면 프롬프트에 이 내용을 추가할 수 있어요. 예를 들어 \"RdOrYl 색상 구성표 사용하기\"\n\n이제 2022년을 분석해보기 위해 숫자들을 살펴볼까요?\n\nGPT-4에게 프롬프트: 멋져요, 이제 같은 지도를 2022년용으로 만들어주세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nGPT-4의 답변:\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-PragmaticGPT-4PromptingNiftyNo-CodeMapsandReportsforNoobs_6.png\" /\u003e\n\n좋아요! 이제 14년 차이가 나는 2개의 지도가 있어요. 빠른 비교 분석을 하면, 어떤 나라들이 시간이 지남에 따라 변화했는지(긍정적으로든 부정적으로든) 확인할 수 있어요.\n\n14년 동안 특정 결과를 얻기 위해, 어떤 나라가 평화로움이 점점 높아지거나 낮아지는지를 보여주기 위해 해당 변화를 명확히 보여주는 지도를 표시하는 것도 가능해요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그래요.\n\nGPT-4에게 알려주세요: 이제 각 국가별로 2008년부터 2022년까지의 평화 지수 차이를 보여주는 지도를 만들어주세요.\n\nGPT-4의 응답:\n\n![map](/TIL/assets/img/2024-07-13-PragmaticGPT-4PromptingNiftyNo-CodeMapsandReportsforNoobs_7.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n쉽죠! 이제 2008년부터 2022년까지 각 나라의 변화에 대한 비교 분석이 있어요.\n\n하지만 대부분의 나라가 파란색으로 표시된다는 것을 보셨을 겁니다 — 조금 오해의 소지가 있어요. 몇 가지 특이치가 있어서 데이터가 한쪽으로 치우쳐져 보일 수 있으니, 이 시각화를 조금 더 \"현실적\"으로 보이도록 GPT-4에게 수정해 달라고 요청해 볼게요.\n\nGPT-4에게 제시할 내용:\n몇 가지 특이치가 있으므로 색상 체계의 중간값을 0으로 설정하고, 전체 색상 범위를 더 생생하고 대조적으로 만드세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![해당 이미지는 훨씬 좋네요. 지난 14년 동안 불안정한 상황에서 있는 국가들을 명확히 식별할 수 있습니다. 멋진 작업이네요! 그리고 마지막으로, GPT-4의 새로운 내장 기능 중 하나는 방금 생성된 데이터 시각화와 제공된 분석을 포함한 원격 PDF 파일을 실시간으로 생성할 수 있는 기능입니다.](/TIL/assets/img/2024-07-13-PragmaticGPT-4PromptingNiftyNo-CodeMapsandReportsforNoobs_8.png)\n\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# PDF 보고서 실시간 생성\n\nGPT-4에게 방금 생성한 지도 시각화물을 모두 포함한 PDF 보고서를 생성하도록 요청할 수 있습니다.\n\nGPT-4에게 요청: 좋아요, 이제 2008년의 첫 번째 지도, 2022년의 두 번째 지도, 그리고 방금 생성한 지수 변화(2008-2022) 지도를 생성한 후, 각 지도에 대한 분석을 포함하는 PDF 보고서(소개, 분석, 결론 포함)를 만들어 주세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/TIL/assets/img/2024-07-13-PragmaticGPT-4PromptingNiftyNo-CodeMapsandReportsforNoobs_9.png)\n\n**전문가 팁:** GPT-4에게 먼저 지도를 재생성하도록 유도해야 합니다. 그렇지 않으면 이미지에 액세스할 수 없다고 불평하고 실패할 수 있습니다.\n\nGPT-4에 의해 동적으로 생성된 PDF 보고서의 스크린샷:\n\n![이미지](/TIL/assets/img/2024-07-13-PragmaticGPT-4PromptingNiftyNo-CodeMapsandReportsforNoobs_10.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n와우, 정말 인상적이에요. 데이터셋에서 데이터 시각화와 분석이 포함된 PDF 보고서까지!\n\n소소한 팁: 포맷팅이 마음에 들지 않는다면 GPT-4를 다시 실행하여 굵은 큰 제목, 헤더, 푸터 등을 추가할 수 있어요.\n\n그리고 이 모든 작업을 하기 위해 얼마나 많은 코딩이 필요했나요?\n\n음 — 전혀요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n얼마나 좋은가요?\n\n# 개요…\n\n복잡한 시각화 자동화 및 실시간 PDF 보고서 생성을 통해 GPT-4는 초보 데이터 분석가를 위한 데이터 시각화 및 보고 프로세스를 크게 간소화합니다.\n\n아직 완벽한 상황은 아닙니다. GPT-4에서 구현해야 할 업데이트와 개선 사항이 있습니다. 예를 들어 데이터셋에 대한 분석은 더 심층적이지 않을 수 있으며 PDF 서식 조정이 필요합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테이블 태그를 마크다운 형식으로 변경해보세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 이 유형의 이야기가 당신에게 딱 맞고, 저를 작가로서 지원하고 싶다면, 제 Substack에 구독해주세요.\n\nSubstack에서는 다른 플랫폼에서는 찾을 수 없는 뉴스레터와 기사를 게시합니다.\n\n당신의 의견/댓글을 듣고 싶어요!","ogImage":{"url":"/TIL/assets/img/2024-07-13-PragmaticGPT-4PromptingNiftyNo-CodeMapsandReportsforNoobs_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-PragmaticGPT-4PromptingNiftyNo-CodeMapsandReportsforNoobs_0.png","tag":["Tech"],"readingTime":12},{"title":"ETF 데이터 분석을 위한 Python 활용 금융 정보를 가져오고 분석하고 시각화하는 방법","description":"","date":"2024-07-13 20:05","slug":"2024-07-13-PythonforETFDataAnalysisHowtoFetchAnalyzeandVisualizeFinancialInformation","content":"\n\n금융 분석을 위한 Python의 힘을 발견하는 여정에 나서보세요! 이 포괄적인 안내서는 CSV 보고서를 작성하거나 대화형 Flask 대시보드를 생성하려는지 여부에 관계없이 Exchange-Traded Funds (ETFs) 데이터를 가져오고 분석하고 시각화하는 단계를 안내해 드립니다. 금융 애호가와 신진 개발자 모두에게 이 이야기는 Python을 사용한 ETF 데이터 분석을 숙달하는 길로 안내해주는 열쇠입니다.\n\nETFs의 매력을 발견해보세요\n\n금융 시장의 끝없는 미로 속에서 변동성의 용이 불을 내뿜고 불확실성의 그림자가 크게 드리우는 곳에서, 투자 성공의 황금 보물을 찾아 나설 때 위험은 수없이 많습니다. 그러나 이러한 도전 속에 희망과 기회의 빛도 있습니다: Exchange-Traded Funds (ETFs). ETFs를 다양한 갑판에 탑승할 기회를 제공하는, 격동하는 주식 시장의 엉터리 바다를 항해하는 다재다능한 배로 상상해보세요. 시장의 경험 많은 선원이거나 막시 시작한 갑판원이든, ETFs를 이해하는 것은 낡은 먼지 덮인 병에 숨겨진 보물 지도를 발견하는 것과 같습니다.\n\n그런데 이야기의 전개에는 한 가지 반전이 있습니다: 금융 데이터의 방대한 바다를 항해하는 것은 단순히 지도를 가지고 하는 것 이상을 요구합니다; 강력한 신비한 도구가 필요합니다. 현대의 요술사의 지팡이인 Python이 나타납니다. Python이 곁에 있다면, 당신은 수동적인 여행자가 아닌, 시장 트렌드와 투자 기회의 파도를 헤치며 운명을 결정하는 선장이 됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\"왜 ETFs에게 그토록 주목해야 하는지 궁금해하실 수 있습니다. 이러한 금융 자산은 여러 가지 이유로 매력적입니다:\n\n- 한 병 속의 다양성: ETFs는 다양한 종목, 채권 또는 상품을 포괄하는 작은 함대와 같습니다. 이 다양성은 귀하의 위험을 분산시켜주어 투자의 궤변에 고립되는 것을 방지합니다.\n- 용이한 항해: ETFs 거래는 개별 주식 거래처럼 간편합니다. 시장 가격에서 거래일 내내 거래할 수 있는 유연성을 제공하여 친근한 영혼을 소환하거나 보내는 것과 같은 간단한 일입니다.\n- 다양한 옵션의 보물 상자: 대담한 모험가들을 위해 ETFs와 함께 하는 옵션 거래는 자체적인 미로를 제시합니다. 큰 보상의 약속을 가지고 있지만, 위험으로 가득한 길이며 예리한 눈과 안정된 손이 필요한 길입니다.\n\n이 안내서에서는 ETF 데이터 분석을 위해 Python의 힘을 활용하기 위한 여정을 떠납니다. CSV 보고서 형태로 상세한 보물 지도를 만들거나 실시간으로 금융 우주의 비밀을 해제하는 마법의 Flask 대시보드를 작성하려는 목표가 있다면, 이 글은 당신의 나침반이자 항로가 될 것입니다. 파이썬과 유머 한 조각을 더한 채 ETFs의 세계로 떠나보세요. 금융 결정의 능란한 조류를 뚫고 평온한 물들로 향해 갑니다.\"\n\n![이미지](/TIL/assets/img/2024-07-13-PythonforETFDataAnalysisHowtoFetchAnalyzeandVisualizeFinancialInformation_0.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n당신의 퀘스트 설정하기\n\n금융 데이터 분석의 심오한 모험에 떠나기 전에, 당신의 무기함을 준비하는 것이 중요합니다. 파이썬을 당신의 충실한 말, 코딩의 땅을 횡단하는 여정에서의 존귀한 동반자로 생각해보세요. 여정을 떠날 준비가 되지 않은 상태라면 파이썬 웹사이트로 가서 파이썬을 다운로드하고 설치해주세요. 이를 통해 당신의 평범한 PC가 마법사의 탑이 되어 마법(코딩)이 일어나는 곳이 될 것입니다.\n\n당신의 모험가 툴킷은 다음을 포함해야 합니다:\n\n- 용기: 코드의 알려지지 않은 영역으로 모험을 떠날 용기, 그곳에는 아직 거의 없었던 사람들이 있습니다. 도전에 맞설 용기를 가져주세요.\n- 인내심: 프로그래밍의 세계나 좋은 모험에서도 시행 착오와 반대 상황을 경험하게 될 것입니다. 기억해주세요, 코드가 반격을 할 수 있지만 모든 오류 메시지는 보물에 한 발 다가갈 수 있는 단서입니다.\n- yfinance: 금융 영역의 마법사들에 의해 창조된 이 마법책은 몇 줄의 코드로만 금융 데이터를 불러올 수 있는 마법을 부리는 것을 가능하게 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하지만 여정은 여기서 끝나지 않아요. 데이터의 무성한 숲을 헤치고 분석의 산등성이를 오를 때, 여러분의 가방에는 몇 가지 도구가 더 필요할 거에요:\n\n- pandas: 마치 마법처럼 작용하는 이 책은 여러분의 지도와 나침반 역할을 할 거에요. 데이터를 정리하고 숫자의 안개 속을 숙련된 항해사처럼 안내해 줄 거에요.\n- numpy: 이 부적은 여러분의 능력을 향상시켜 더 복잡한 수학적 의식을 손쉽게 수행할 수 있게 해 주는데, 마치 마법으로 데이터를 변형하고 조작하는 것 같아요.\n- Flask: 세계와 여러분의 통찰을 공유하고 싶다면, 이 마법의 두루마리는 다른 사람이 여러분이 발견한 경이로움을 엿볼 수 있는 포털(웹 어플리케이션)을 만들 수 있게 도와 줄 거에요.\n\n도구를 준비하고 말을 타기 위해 거의 출발 준비가 끝났어요. 하지만 먼저, 여정에 대비하기 위해 환경을 준비해야 해요:\n\n- 터미널이나 명령 프롬프트를 열고 마법의 주문인 pip install yfinance pandas numpy Flask을 속삭여 주세요. 이 주문은 필요한 라이브러리를 거대한 Python 패키지 인덱스(PyPI)에서 불러오고 환경에 설치할 거에요.\n- 작업 디렉토리에 etfs.txt라는 텍스트 파일을 준비하세요. 파일 안에 탐구하고자 하는 ETF의 심볼을 한 줄씩 나열해 주세요. 이 문서는 여러분의 탐구를 안내해 줄 것이며, yfinance에게 건너뛴다는 트레져를 찾을 것을 알려줄 거에요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n준비가 완료되어 위대한 모험의 시작점에 서게 되었군요. 깊게 숨을 들이마시세요, 모험가 여러분. 여러분은 해독하지 못한 수수께끼 속으로 들어가게 될 것입니다. 우리는 이 목표를 달성하기 위해 기록해 두겠습니다.\n\n범위 설명\n사용자로서, 특정 ETF 성과에 대한 신뢰할 수 있는 지표 세트를 원하며 데이터 분석을 위해 시간에 따른 움직임의 곡선을 이해하고 싶습니다.\n\n- ETF의 최신 가격: 최신 가격은 바다를 가로지르는 배의 현재 위치를 알기와 같습니다. 현재 ETF의 위치를 알려줌으로써 시장의 광대한 바다에서 즉각적인 위치를 파악할 수 있습니다. 그것이 물결을 타고 높이 올라가고 있는지, 물결의 골짜기에 있어서 낮은 입장점을 찾을 수 있는 기회가 있는지를 보여줍니다.\n- 52주 최고가 및 최저가: 이러한 지표들은 어둠의 가운데에서 당신을 안내하는 등대입니다. 52주 최고가는 지난 일 년 동안 ETF가 오른 산봉우리를 나타내며 강점 또는 잠재적인 저항을 시그널합니다. 반면, 52주 최저가는 이 ETF가 건너온 가장 깊은 계곡을 보여줌으로써 가능한 지지도나 궁핍 포인트를 나타냅니다. 이 둘이 함께 ETF의 여정을 구성하여 변동성과 안정성에 대한 통찰을 제공합니다.\n- 1년, 3년, 5년 수익률: 과거 모험 이야기로 상상해 보세요. 보물의 성장을 시간이 지남에 따라 증명하는 것입니다. 일 년 수익률은 지난 일 년 동안 ETF가 얼마나 성장했는지 또는 줄었는지를 말해줍니다. 셋과 다섯 년 수익률은 이 이야기를 연장하여 더 긴 여정 동안의 성과를 보여줍니다. 이러한 지표들은 ETF 성장의 일관성을 이해하도록 도와주며 여정에 함께 할 가치 있는 선박인지 여부에 대한 결정을 안내합니다.\n- 자산 운용액 (AUM): 보물 상자의 크기입니다. 더 큰 AUM은 더 많은 투자자에게 신뢰받는, 잠재적으로 안정된 ETF를 의미합니다. 또한 이것은 더 많은 유동성을 의미하며, 가격에 영향을 미치지 않고 거래하기가 더 쉽습니다.\n- 배당 수익률: 이 수치는 ETF 일부를 보유하고 있기만 해도 받는 보물의 일부를 대표합니다. 높은 배당 수익률은 투자로 인해 더 많은 수익을 얻게 해 주어 안정적인 수입을 제공하게 됩니다.\n- 평균 거래량: 이것은 시장 광장에서 활발한 활동으로 상상해 보세요. 하루 평균으로 거래되는 ETF 주식 수를 알려줍니다. 높은 거래량은 더 많은 활동을 의미하며 유동성과 ETF에 대한 관심을 나타냅니다. 이는 가격에 큰 영향을 미치지 않고도 진입하고 위치를 떠날 수 있음을 의미합니다.\n- 풋 카운트, 콜 카운트, 그리고 옵션 만기일: 이러한 지표들은 ETF에 대한 옵션 시장의 여론을 엿볼 수 있게 합니다. 더 높은 풋 카운트는 하강을 예상하는 투자자가 더 많음을 나타내고, 더 높은 콜 카운트는 상승에 대한 낙관을 시사합니다. 만기일은 이러한 여론에 대한 맥락을 제공하여 ETF의 성과에 대한 시장 기대에 대한 단서를 제시합니다.\n- 트렌드 (상승 또는 하락): 풋 카운트와 콜 카운트에서 유래된 이 지표는 시장 여론을 한 단어로 요약합니다. 상승 트렌드는 낙관을 시사하며 상승 궤적을 나타내며, 하락 트렌드는 비관심과 잠재적인 하강을 암시합니다. 시장에서의 주요 희망을 빠르게 파악할 수 있습니다.\n\n이러한 지표들이 여러분의 투자 여정을 안내할 지도가 됩니다. ETF가 밟아온 길, 싸운 전투, 그리고 이겨낸 승리를 보여줌으로써 재물 영광을 위한 여행길에 함께할 가치 있는 동반자인지 여부를 결정할 수 있습니다. 이 지식을 무장하고 이제 ETF 세계가 여러분을 기다리고 있습니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n**코드를 이해하는 여정을 떠나다**\n\n재정적 통찰력을 얻기 위해 파이썬을 믿음직한 전투말, 플라스크를 마법의 주문으로 선택하셨군요. 우리 주문의 초기 단계를 살펴봅시다:\n\n- 호출\n\n```js\nfrom flask import Flask, render_template_string\nimport yfinance as yf\nimport pandas as pd\nimport numpy as np\n\napp = Flask(__name__)\n\ndef fetch_options_data(symbol):\n    etf = yf.Ticker(symbol)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리의 동맹들을 모으는 중이에요. Flask는 마법같은 대시보드를 만들어줄 거에요, yfinance는 금융 데이터의 세계로 들어가는 당신의 게이트웨이입니다, pandas는 이 데이터를 정리하는 데 도움을 주고, numpy는 당신이 필요로 할 어떤 숫자적 마법도 지원할 거에요. fetch_options_data 이 함수는 마치 요술사와 상담을 하는 것과도 같아요. 당신이 ETF의 심볼을 제공함으로써, 옵션 데이터를 통해 선물 시장에 대한 정보를 찾고 있습니다. yf.Ticker(symbol)의 주문은 당신이 선택한 ETF에 대한 정보를 불러올 거에요.\n\n2. 요술사의 통찰력\n\n```js\ntry:\n    expiration_dates = etf.options\n    if expiration_dates:\n        first_expiration_date = expiration_dates[0]\n        options_chain = etf.option_chain(first_expiration_date)\n        puts = options_chain.puts\n        calls = options_chain.calls\n        return len(puts), len(calls), first_expiration_date\n```\n\n이 세그먼트에서는 시간의 안개를 통해 거래자들이 베팅한 선물을 엿볼 거에요. etf.options는 옵션의 존재하는 미래 날짜를 보여주며, 시장 관련자들의 기대를 엿볼 수 있게 도와줍니다. 첫 번째 만기일의 옵션 체인을 조사함으로써, ETF에 대한 베팅을 풀어내는 puts(ETF에 대한 베팅)와 calls(ETF를 위한 베팅)의 수를 알아냅니다. 이 숫자들과 만기일은 시장의 심리를 암시하는 보물이 되어요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n3. 미지의 처리:\n\n```python\ntry:\n    except Exception as e:\n        print(f\"심볼 {symbol}에 대한 옵션 데이터를 가져올 수 없습니다: {e}\")\n    return None, None, None\n```\n\n최강의 마법도 가끔은 실패할 수 있어요. 여기서는 예기치 못한 상황에 대비합니다. 만약 예언자가 침묵을 지키거나 안개가 너무 짙다면, 당신은 우아하게 미지를 받아들여 앞이 가려져 있다고 신호를 보냅니다.\n\n이 코드는 ETF와 옵션의 신비로운 세계로의 첫 걸음입니다. 여러분은 지식을 찾고, 불확실성에 대비하며 시장의 속삭임을 해석하는 법을 배우게 될 거예요. 우리 여정이 깊어질수록 기억해 주세요: 가장 위대한 마법사들도 한 때는 단지 수습생에 불과했으며, 그 힘은 호기심, 성실함, 그리고 시작할 용기를 통해 형성되었어요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자산 총액 형식화\n\n당신이 찾는 보물의 규모를 이해하는 것은 중요합니다. 여기에서는 단순한 죽염(예를 들어 EFT의 총 자산)을 이해할 수 있는 언어로 번역하는 format_assets라는 주문이 있습니다. format_assets는 EFT의 왕국인 총 자산의 광대함에 초점을 맞춘 마법 같은 돋보기로 생각할 수 있습니다. 이 주문은 이 왕국의 크기를 모험가와 거래자들이 이해하기 쉬운 용어로 전달하려 합니다. 만약 보물의 규모가 수십억을 넘는다면 이 주문은 숫자를 수십억 단위(B)로 표현하여 표시합니다. 이는 \"이 EFT는 10억 골드 코인 이상 가치가 있는 영토를 통제하고 있습니다\" 라고 말하는 것과 같습니다. 수십억에 미치지는 못하지만 부유한 영토들에 대해서는 그들의 부를 백만 단위(M)로 표시합니다. 이는 그들의 자산이 상당하지만 엄청난 규모에 미치지는 못할 것을 존중해줍니다. 그리고 그리 희귀하지 않은 소중한 마음에, 이 주문은 그대로 그 가치를 명시함으로써 작은 명보라도 우리의 대모험에서 간과되지 않도록 합니다.\n\n```js\ndef format_assets(assets):\n    if assets \u003e= 1e9:  # 10억 이상\n        return f\"{assets / 1e9:.2f}B\"\n    elif assets \u003e= 1e6:  # 100만 이상\n        return f\"{assets / 1e6:.2f}M\"\n    return str(assets)\n```\n\n마법 도서관 공개: EFT 데이터 가져오기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리의 모험은 yfinance의 마법 도서관 심층으로 이어집니다. 거기에는 방대한 지식의 두루마리가 기다리고 있습니다. fetch_data 주문은 우리가 탐험하고자 하는 어떤 ETF 심볼에 대한 비밀을 해제하는 열쇠입니다. 이 강력한 주문이 어떻게 작동하는지 알아봅시다:\n\n```js\ndef fetch_data(symbol):\n    etf = yf.Ticker(symbol) # 해당 ETF의 본질을 활성화시키고, yfinance 영역 내에서 그 영혼에 직접 연결하는 것입니다. 늘 살아있는 데이터로 뛰어드는 ETF의 마음에 직접 연결된 것과 같습니다.\n    info = etf.info # 해당 ETF에 대한 알려진 모든 지식을 수집합니다. 이에는 해당 ETF의 역사, 능력, 그리고 금융 왕국에서의 현재 위치가 포함됩니다.\n    puts_count, calls_count, first_expiration_date = fetch_options_data(symbol)\n    # 옵션의 비밀스러운 세계로 들어가 우리 ETF에 대한 시장의 감정을 나타내는 징조를 찾습니다. 이는 금융 마법사들을 위한 차례불을 읽는 것과 같습니다.\n\n    latest_price = info.get('previousClose', np.nan)  # 최신 가격을 위한 올바른 키\n    # ETF의 최신 종가 스냅샷, 거대한 시장에서의 현재 상태에 대한 중요한 단서\n\n    # 비교 전에 puts_count와 calls_count가 None이 아닌지 확인합니다.\n    if puts_count is not None and calls_count is not None:\n        trend = \"Bearish\" if puts_count \u003e calls_count else \"Bullish\"\n    else:\n        trend = \"Unknown\"  # 두 카운트 중 하나라도 None이면 중립 값입니다.\n\n    # 추가적인 지표 (무수한 반환값 및 총 자산을 위해 None 값을 적절히 처리해야 합니다.)\n    one_year_return = round(info.get('ytdReturn', np.nan) * 100, 2) if info.get('ytdReturn') is not None else \"N/A\"\n    three_year_return = round(info.get('threeYearAverageReturn', np.nan) * 100, 2) if info.get('threeYearAverageReturn') is not None else \"N/A\"\n    five_year_return = round(info.get('fiveYearAverageReturn', np.nan) * 100, 2) if info.get('fiveYearAverageReturn') is not None else \"N/A\"\n    total_assets = format_assets(info.get('totalAssets', np.nan)) if info.get('totalAssets') is not None else \"N/A\"\n\n    return {\n        'Symbol': symbol,\n        'Name': info.get('longName', 'N/A'),\n        'Latest Price': f\"${latest_price}\",\n        '52W High': f\"${round(info.get('fiftyTwoWeekHigh', np.nan), 2)}\",\n        '52W Low': f\"${round(info.get('fiftyTwoWeekLow', np.nan), 2)}\",\n        '1 Year Return': one_year_return,\n        '3 Year Return': three_year_return,\n        '5 Year Return': five_year_return,\n        'Total Assets': total_assets,\n        'Dividend Yield': f\"{round(info.get('yield', np.nan) * 100, 2)}%\" if info.get('yield') is not None else \"N/A\",\n        'Average Volume': info.get('averageVolume', 'N/A'),\n        'Puts Count': puts_count,\n        'Calls Count': calls_count,\n        'Option Expire': first_expiration_date,\n        'Trend': trend\n    }\n```\n\n우리는 옵션의 징조를 해석하여 바람이 베어들을 지지하는지, 아니면 불들을 지지하는지를 분별합니다. 이는 ETF의 미래 경로를 예측하는 데 도움이 되는 중요한 통찰력입니다.\n\n- 수익률과 자산의 보물 지도: 그리고 주문은 이후 1년, 3년, 5년 동안의 수익률과 함께 총 자산을 계산합니다. 이는 보물이 어디에 있을지뿐만 아니라 시간이 지남에 따라 어떻게 자라냈는지를 나타내는 보물 지도를 펼치는 것과 같습니다.\n- 지식의 두루마리 제작: 마지막으로, 우리의 주문은 이 모든 지혜를 쉽게 읽을 수 있는 형식으로 나열한 자세한 두루마리를 만듭니다. 이에는 ETF의 이름, 최신 가격, 고점과 저점, 수익률 등이 포함됩니다. 각 정보 조각은 모험가들이 금융 모험에서 정보된 결정을 내릴 수 있도록 도와주는 단서입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n포탈 제작: Flask가 데이터를 살려 냅니다\n\n코드를 통한 여정이 Flask에 의해 촉발되어 ETF 데이터 스크롤이 전 세계가 볼 수 있는 모습으로 화려하게 펼쳐지는 마법의 포탈을 만들어 냈습니다. 이 마법을 어떻게 구현하는지 살펴봅시다:\n\n```js\n@app.route('/')\ndef etf_data():\n```\n\n이 말을 통해 우리는 디지털 영역에서 공간을 만들어내고, ETF 데이터가 공개될 전용 성소를 조성하게 됩니다. 마치 숨겨진 보물이 가득한 방문을 열듯 합니다. 그런 다음, 우리는 ETF 심볼 목록을 소환하고, 시장의 수수께끼를 푸는 열쇠로 이어지는 각각의 심볼을 확인하기 위한 안내서로 활용합니다. 이 목록은 우리의 안내자이자, 원하는 스크롤로 이끌어주는 길잡이입니다. 리스트가 제시되면, 하나씩, 우리는 각 ETF 심볼의 데이터를 호출하여 지식의 포괄적인 두루미를 펼쳐 냅니다. 마치 우리가 고대의 원고를 수집하는 듯한데요, 각각이 통찰과 비밀로 가득한 원고입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음은 무엇일까요? 다음 단계는 수집한 데이터를 시각적인 형태인 테이블로 변환하는 것입니다. 네비게이션하기 쉽고 눈에 즐겁게 보기 좋은 테이블입니다. 그것은 생 데이터를 숫자와 사실들로 짜여진 아름다운 속삭임으로 만드는 주문입니다.\n\netf_data 함수와 함께, 우리는 단숴분야를 분석한 것뿐만 아니라 코드의 세계와 시각적 이해의 영역 사이에 다리를 만들었습니다. 우리의 Flask 포털은 동료 모험가들을 위한 길잡이가 되어, ETF의 복잡함을 용이하고 통찰력 있게 안내합니다.\n\n```js\n    with open('etfs.txt', 'r') as file:\n        symbols = file.read().splitlines()\n\n    data = [fetch_data(symbol) for symbol in symbols]\n    df = pd.DataFrame(data)\n\n    # Convert DataFrame to HTML without index\n    df_html = df.to_html(classes='table table-striped', index=False)\n```\n\n마지막 부분은 tricky합니다: 우리는 데이터를 csv 형식으로 다운로드하거나 Flask 대시보드로 이동할 수 있습니다. 따라서 Flask를 가져오고 활성화할 필요가 없습니다. 웹페이지에 표시하는 것이 더 멋지게 보여서 대시보드를 선택할 예정입니다 (개인적인 지각).\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nhtml_template = \"\"\"\n    \u003c!DOCTYPE html\u003e\n    \u003chtml\u003e\n    \u003chead\u003e\n    \u003ctitle\u003eETF Data\u003c/title\u003e\n    \u003clink rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css\"\u003e\n    \u003c/head\u003e\n    \u003cbody\u003e\n    \u003cdiv class=\"container\"\u003e\n        \u003ch1\u003eETF Data\u003c/h1\u003e\n        { df_html | safe }\n    \u003c/div\u003e\n    \u003c/body\u003e\n    \u003c/html\u003e\n    \"\"\"\n    return render_template_string(html_template, df_html=df_html)\n\nif __name__ == '__main__':\n    app.run(debug=True)\n```\n\nETF의 난해한 지식을 이해하기 쉽고 접근 가능하게 만들기 위한 여정에서 우리는 마지막 단계에 도달했습니다. 디지털 태피스트리의 실을 짜기 위해 주문을 외우는 곳입니다. 여기서 우리는 Flask 앱의 형태를 만드는 주문을 외우면서, 기능적이면서 시각적으로 매력적인 포털을 만들어냅니다. 다음으로 포털의 기초를 다지기 위해 나아갑니다. 맨 위에 새긴 제목은 위대한 도서관의 이름처럼 지식 탐구자를 초대합니다. 그리고 우리는 Bootstrap의 힘을 소환합니다. 이 마법은 우리의 태피스트리가 시각적으로 매력적이면서도 정보를 효과적으로 제공한다는 것을 보장합니다.\nHTML의 몸체 안에서 우리는 소중한 데이터를 담는 컨테이너로 사용되는 웅장한 홀, div를 세웁니다. \"ETF 데이터\"라는 제목은 내부에 담긴 지식의 풍부함을 시그널하는 깃발처럼 자랑스럽게 들려줍니다. 그 아래에는 데이터 표가 배치되어 있으며 HTML로 변환되어 안전하게 표시됩니다. 이곳에서 우리의 ETF 데이터는 한때 복잡성의 안개에 감춰져 있던 곳에서 모든 영광을 뽐내며 드러납니다.\n그리고 최종 주문을 외우며 포털에 생명을 불어넣고, 이를 가동시킵니다. 이제 준비가 끝났으며, 인터넷의 문턱에서 지식 탐구자들이 문을 통과하기를 기다립니다.\n\n코드가 실행되고 서버가 활성화되는 동안 이것을 생각해보세요. 당신이 만든 것은 단순히 Flask 앱이 아닙니다. 이것은 재정 데이터의 광대한 바다를 항해하는 사람들을 위한 등대입니다. 각각의 ETF를 탐험하며, 각 지표를 이해함으로써, 당신은 숫자를 분석하는 것뿐만 아니라 길을 밝히며, 결정을 이끌며, 아마도 미래를 바꾸고 있습니다.\n\n그래서, 코드가 준비되었습니다. 실행할 수 있고 결과를 볼 수 있습니다.\n브라우저를 열고 URL을 입력하세요: http://127.0.0.1:5000/.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 귀하가 원하는 코드를 Markdown 형식으로 변경한 것입니다.\n\n\n![Python for ETF Data Analysis - How to Fetch, Analyze, and Visualize Financial Information](/TIL/assets/img/2024-07-13-PythonforETFDataAnalysisHowtoFetchAnalyzeandVisualizeFinancialInformation_1.png)\n\nUPD: 아래의 코멘트에 제안된 대로, 직접 구현하고 테스트할 수 있는 전체 코드를 추가했습니다 :)\n\n```python\nfrom flask import Flask, render_template_string\nimport yfinance as yf\nimport pandas as pd\nimport numpy as np\n\napp = Flask(__name__)\n\n# 옵션 데이터를 가져오는 함수\ndef fetch_options_data(symbol):\n    etf = yf.Ticker(symbol)\n    try:\n        expiration_dates = etf.options\n        if expiration_dates:\n            first_expiration_date = expiration_dates[0]\n            options_chain = etf.option_chain(first_expiration_date)\n            puts = options_chain.puts\n            calls = options_chain.calls\n            return len(puts), len(calls), first_expiration_date\n    except Exception as e:\n        print(f\"{symbol}에 대한 옵션 데이터를 가져올 수 없음: {e}\")\n    return None, None, None\n\n# 쉽게 파악할 수 있도록 총 자산을 포맷하는(helper) 함수\ndef format_assets(assets):\n    if assets \u003e= 1e9:  # 10억 이상\n        return f\"{assets / 1e9:.2f}B\"\n    elif assets \u003e= 1e6:  # 1백만 이상\n        return f\"{assets / 1e6:.2f}M\"\n    return str(assets)\n\n# 수정된 fetch_data 함수에 모든 수정 사항을 포함\ndef fetch_data(symbol):\n    etf = yf.Ticker(symbol)\n    info = etf.info\n    puts_count, calls_count, first_expiration_date = fetch_options_data(symbol)\n    latest_price = info.get('previousClose', np.nan)  # 최신 가격을 위한 올바른 키\n\n    # puts_count 및 calls_count를 비교하기 전에 None이 아닌지 확인합니다\n    if puts_count is not None and calls_count is not None:\n        trend = \"Bearish\" if puts_count \u003e calls_count else \"Bullish\"\n    else:\n        trend = \"Unknown\"  # 어느 하나가 None인 경우 중립 값을 설정\n\n    # 추가 지표 (수익 및 총 자산에 대한 None 값의 적절한 처리 확인)\n    one_year_return = round(info.get('ytdReturn', np.nan) * 100, 2) if info.get('ytdReturn') is not None else \"N/A\"\n    three_year_return = round(info.get('threeYearAverageReturn', np.nan) * 100, 2) if info.get('threeYearAverageReturn') is not None else \"N/A\"\n    five_year_return = round(info.get('fiveYearAverageReturn', np.nan) * 100, 2) if info.get('fiveYearAverageReturn') is not None else \"N/A\"\n    total_assets = format_assets(info.get('totalAssets', np.nan)) if info.get('totalAssets') is not None else \"N/A\"\n\n    return {\n        '심볼': symbol,\n        '이름': info.get('longName', 'N/A'),\n        '최신 가격': f\"${latest_price}\",\n        '52주 최고가': f\"${round(info.get('fiftyTwoWeekHigh', np.nan), 2)}\",\n        '52주 최저가': f\"${round(info.get('fiftyTwoWeekLow', np.nan), 2)}\",\n        '1년 수익률': one_year_return,\n        '3년 수익률': three_year_return,\n        '5년 수익률': five_year_return,\n        '총 자산': total_assets,\n        '배당 수익률': f\"{round(info.get('yield', np.nan) * 100, 2)}%\" if info.get('yield') is not None else \"N/A\",\n        '평균 거래량': info.get('averageVolume', 'N/A'),\n        '풋 거래 수': puts_count,\n        '콜 거래 수': calls_count,\n        '옵션 만기일': first_expiration_date,\n        '추세': trend\n    }\n\n# Flask를 URL 구조가 보이게 설정: 127.0.0.1:5000/\n@app.route('/')\ndef etf_data():\n    with open('etfs.txt', 'r') as file:\n        symbols = file.read().splitlines()\n\n    data = [fetch_data(symbol) for symbol in symbols]\n    df = pd.DataFrame(data)\n\n    # 인덱스 없이 DataFrame을 HTML로 변환\n    df_html = df.to_html(classes='table table-striped', index=False)\n\n    html_template = \"\"\"\n    \u003c!DOCTYPE html\u003e\n    \u003chtml\u003e\n    \u003chead\u003e\n    \u003ctitle\u003eETF Data\u003c/title\u003e\n    \u003clink rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css\"\u003e\n    \u003c/head\u003e\n    \u003cbody\u003e\n    \u003cdiv class=\"container\"\u003e\n        \u003ch1\u003eETF Data\u003c/h1\u003e\n        { df_html | safe }\n    \u003c/div\u003e\n    \u003c/body\u003e\n    \u003c/html\u003e\n    \"\"\"\n    return render_template_string(html_template, df_html=df_html)\n\nif __name__ == '__main__':\n    app.run(debug=True)\n```\n\nThe Treasure Unveiled: What We Have Achieved\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n축하합니다, 친애하는 모험가 여러분! 여러분은 금융 데이터의 미로를 헤쳐나가며, 파이썬의 마법을 휘둘러 ETF의 비밀을 플라스크 대시보드의 투명한 화면을 통해 밝혀내었습니다. 이제 우리가 발견한 보물에 놀라보는 시간을 가져봅시다:\n\n- 지식의 지도: 우리의 여정의 핵심에는 ETF 세계의 전경을 제공하는 강력한 대시보드가 있습니다. 최신 가격, 52주 최고/최저 및 수익률(1년, 3년, 5년)과 같은 지표들을 통해 숫자를 이해뿐만 아니라 시장의 격동하는 수역을 탐험하기 위한 나침반이 되었습니다.\n- 숫자 너머의 통찰: 저희 대시보드는 숫자를 표시하는 데 그치지 않고 통찰력을 제공합니다. 풋과 콜을 비교함으로써 투자자에게 시장 심리를 엿보여, 순수한 데이터를 실행 가능한 정보로 바꾸었습니다.\n- 미래로의 문: 각 ETF의 데이터가 꼼꼼하게 분류되어 있는 상태에서 우리의 플라스크 앱은 투자자가 잠재적인 미래를 엿볼 수 있는 창문으로 서 있어, 금융용 악마로부터 멀리하고 황금잡이 기회로 나아가는데 도움이 되고자 합니다.\n\n다음 단계: 어떻게 더 나아갈까요?\n\n기반을 다지고 배를 준비한 상태에서, 우리는 여기서 어디로 항해해야 할까요? 금융과 코딩의 영역은 방대하며, 발굴되지 않은 미스터리가 무수히 많습니다. 다음은 여러분이 떠날 수 있는 잠재적인 항해들입니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 대시보드를 embold: 우리의 Flask 앱은 기능적이지만, 웹 디자인의 영역에서 아름다움은 힘이 될 수 있어요. 대시보드를 시각적으로 멋진 걸작으로 변신시키기 위해 CSS 마법과 JavaScript 마법을 활용해 보세요. 모든 방문자를 사로잡는 멋진 대시보드로 만들어 보세요.\n\n- Metrics을 확장하다: 금융 세계는 끊임없이 변화하며, 시장의 안개 속에서 나타나는 새로운 지표들이 등장합니다. 대시보드에 더 많은 metrics를 추가하는 것을 고려해 보세요. 샤프 비율, 알파, 베타 등을 추가하여 각 ETF의 성과와 위험 프로필에 대한 더 깊은 통찰력을 제공할 수 있습니다.\n\n- 개인화 및 상호 작용: 시청자를 알아차리는 대시보드를 상상해 보세요. 개인의 투자 성향이나 위험 허용도에 맞게 인사이트를 맞춤화할 수 있는 대시보드를 추가하는 것이 어떨까요? 사용자 계정, 사용자 정의 뷰, 상호 작용 요소를 추가함으로써 당신의 앱을 도구에서 신뢰할 수 있는 자문자로 변신시킬 수 있습니다.\n\n- 실시간 데이터 통합: 현재 대시보드는 한 순간을 포착합니다. 금융의 바다는 항상 변동하기 때문에 실시간 데이터 피드를 통합함으로써 대시보드를 실시간 맵으로 변환할 수 있습니다. 시장의 최신 풍향과 조류로 끊임없이 업데이트되는 대시보드로 만들어 보세요.\n\n- 새로운 해안 탐험: ETF에서 멈추지 마세요. 금융 세계는 암호화폐부터 상품, 주식부터 채권까지 기회의 섬으로 가득합니다. 대시보드를 확장하여 이러한 영역을 다루는 것은 전체 금융 우주를 탐색하는 데 필수적인 나침반으로 만들 수 있습니다.\n\n그래서 여기에서 출발할 때 차트를 손에 쥐고 Python을 가까이 가져 두세요. 금융의 바다는 넓고 야생적이지만, 당신은 능숙한 항해사임이 이미 증명되었습니다. 당신의 투자가 번창하고, 데이터가 정확하며 알고리즘이 효율적하기를 바랍니다.\n\n다시 만나는 그 순간까지, 용감한 모험가여, 이만 작별하겠습니다. 행운의 바람이 당신을 이끌어주길 바라며, 당신이 항상 지혜와 번창의 해안에 도착할 수 있기를 바랍니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n인 플레인 영어 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 반경하고 팔로우해주세요 👏\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io에서 더 많은 콘텐츠 확인하기","ogImage":{"url":"/TIL/assets/img/2024-07-13-PythonforETFDataAnalysisHowtoFetchAnalyzeandVisualizeFinancialInformation_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-PythonforETFDataAnalysisHowtoFetchAnalyzeandVisualizeFinancialInformation_0.png","tag":["Tech"],"readingTime":23},{"title":"데이터 시각화 갓템, Quad-Tile Chart와 Squaremap 사용법 소개","description":"","date":"2024-07-13 19:59","slug":"2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData","content":"\n\n![2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_0](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_0.png)\n\n# 소개\n\n데이터 시각화에서 사용 가능한 캔버스의 크기와 모양은 항상 중요한 요소입니다. 이것은 공간을 절약하기 위한 수단으로 두 축 접근법을 사용하는 Crystal Bar Chart라는 차트를 최근 다른 기사에서 다룬 주제입니다.\n\n이 기사에서는 값을 정사각형으로 시각화하고 볼록 다각형 또는 단순 오목 다각형 형태의 컨테이너를 가득 채우는 공간 절약 방법을 탐구하겠습니다. 또한 이 탐구 과정에 코드를 많이 활용해 보았으니, 다른 유용한 기술과 시각화 유형에 대한 재미있는 자습서로 제공될 수 있기를 희망합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 기사를 통해 달성하고자 하는 목표는 일반적이고 비표준적인 컨테이너 모양(아래 그림 참조)을 고려하고, 이와 유사한 모양의 값 집합을 제시하여 사용 가능한 공간을 최적화하고 직관적인 크기 비교를 제공하며 데이터를 사각형 모양으로 표현하는 것입니다!\n\n![image](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_1.png)\n\n새로운 축 없이 접근하기 전에, 결과를 측정할 좋은 기준을 찾을 수 있는 기존 축 기반 및 축 없는 방법에 대해 생각해 봅시다. 예를 들어, Wikipedia에서 제공하는 동물 중 상위 20마리의 최고 속도를 나타내는 정보를 활용하겠습니다. \n\n## 축 기반 데이터 시리즈 시각화\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\ny-축이 항목의 값을 나타내는 경우, 정렬된 막대 차트와 경쟁하기 어려울 수 있어요. 먼저 그것을 플롯하고, 저의 vizmath 패키지를 사용하여 몇 가지 더 축 기반의 차트를 만들어 보겠습니다.\n\n막대 차트\n\n```js\n# https://en.wikipedia.org/wiki/Fastest_animals (2024년 1월 26일 기준)\n# 20대 최고 빠른 동물 (최고속도, mph)\n\n데이터 = {\n    'id' : [str(i) for i in range(1, 21)],\n    'speed' : [242,200,105,100,100,95,92.5,88,80,79,\n        75,67.85,61.06,60,56,55,55,55,50,50]\n}\n\n# 막대 차트 (데이터는 이미 정렬되어 있음)\nimport matplotlib.pyplot as plt\n\nplt.figure(figsize=(7, 1.5))\n막대 = plt.bar(range(1, 21), 데이터['speed'], edgecolor='black',\n    color='white', linewidth=1)\nplt.xticks([])\nplt.grid(False)\nplt.show()\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_2.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n크리스털 막대 차트\n\n```python\nfrom vizmath.crystal_bar_chart import crystals\nimport pandas as pd\n\n# 데이터: 위를 참조하십시오\n\ndf = pd.DataFrame(data)\ncbc = crystals(df, 'id', 'speed', height_range=5, width_override=5,\n    rotation=90, offset=50, bottom_up=True)\ncbc.cbc_plot(legend=False, alternate_color=True, color=False)\n```\n\n![이미지](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_3.png)\n\n비스웜 플롯\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nfrom vizmath.beeswarm import swarm\nimport pandas as pd\n\n# 데이터: 위 참조\n\ndf = pd.DataFrame(data)\ndiameter = 5\nbs = swarm(df, 'id', 'speed', None, size_override=pi*(diameter/2)**2)\nbs.beeswarm_plot(color=False)\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_4.png\" /\u003e\n\n각각의 메소드들은 값의 크기를 반영하는 모양과 위치를 제공하면서 데이터 집합의 밀도 프로필을 제공하는 독특한 방식을 제공합니다.\n\n이제 같은 값 세트를 사용하여 상대적인 크기 비교에 중점을 둔 축 없는 예제로 넘어가며 일부 반응형 Bubble Chart를 그려 Quad-Tile Chart 알고리즘을 미리보겠습니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 축 없이 데이터 시각화\n\n축 없이 도메인을 표현하기 위해 한 수준의 트리맵(저의 Radial Treemap에 관심이 있는 경우 해당 문서를 확인해보세요!)을 포함하고, 이어서 Bubble 차트를 추가해 봅시다.\n\n트리맵 (한 수준의 파이, 도넛, 직사각형)\n\n```js\nfrom vizmath.radial_treemap import rad_treemap as rt\nimport pandas as pd\n\n# 데이터: 위의 데이터를 참조하세요\n\n# 파이 트리맵\ndf = pd.DataFrame(data)\no_rt = rt(df, ['speed'], 'speed', r1=0)\no_rt.plot_levels()\n\n# 도넛 트리맵\ndf = pd.DataFrame(data)\no_rt = rt(df, ['speed'], 'speed')\no_rt.plot_levels()\n\n# 트리맵\ndf = pd.DataFrame(data)\no_rt = rt(df, ['speed'], 'speed', r1=0, r2=1,\n    a1=0, a2=1, rectangular=True)\no_rt.plot_levels()\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![Bubble Chart (grid)](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_5.png)\n\n```js\nimport numpy as np\nimport pandas as pd\n\n# data: 위에서 참조\n\ndf = pd.DataFrame(data)\n\ndef grid_bubbles(values, size_by='area', rows=2, cols=10, buffer=0.1):\n    fig, ax = plt.subplots(rows, cols, figsize=(7, 1.5))\n    sorted_values = np.sort(values)[::-1]\n    if size_by == 'area':\n        sizes = np.sqrt(sorted_values) # 반지름 입력 고려\n    elif size_by == 'diameter':\n        sizes = sorted_values # 반지름에 비례\n    max_size = np.max(sizes)\n    b = max_size*buffer\n    max_size += b\n    index = 0\n    for i in range(rows):\n        for j in range(cols):\n            # Matplotlib의 Circle을 위한 반지름 입력\n            circle = plt.Circle((0.5, 0.5), sizes[index]/max_size/2,\n                color='black', fill=False, linewidth=2)\n            ax[i, j].add_artist(circle)\n            ax[i, j].set_xlim(0, 1)\n            ax[i, j].set_ylim(0, 1)\n            ax[i, j].axis('off')\n            index += 1\n    plt.tight_layout()\n    plt.show()\n\ngrid_bubbles(data['speed'], size_by='area')\ngrid_bubbles(data['speed'], size_by='diameter')\n```\n\n![Bubble Chart (grid)](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_6.png)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n버블 차트 (내 새로운 Quad-Tile 차트 알고리즘을 사용하여 반 정렬)\n\n```js\nfrom vizmath.quadtile_chart import polyquadtile as pq\nimport pandas as pd\n\n# 데이터: 위를 참조하세요\n\n# 면적에 따라 크기 조정\ndf = pd.DataFrame(data)\ndf['speed'] = df['speed']/df['speed'].max()*3.5\no_pq = pq(df,'id','speed',buffer=0.0, collapse=True,\n    constraints=[(2,1)], auto=False)\no_pq.polyquadtile_plot(show_constraints=True, poly_color='w',\n    poly_line='black', squares_off=True, circles=True)\nprint(o_pq.multiplier)\n\n# 지름에 따라 크기 조정\ndf = pd.DataFrame(data)\ndf['speed'] = df['speed']**2 # 지름 비율에 맞게 조정\ndf['speed'] = df['speed']/df['speed'].max()*3.5\no_pq = pq(df,'id','speed',buffer=0.0, collapse=True,\n    constraints=[(2,1)], auto=False)\no_pq.polyquadtile_plot(show_constraints=True, poly_color='w',\n    poly_line='black', squares_off=True, circles=True)\n```\n\n![이미지](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_7.png)\n\n이러한 방법들은 값이 어떤 크기인지 직접적인 참조를 제공하는 축이 없어서 위치 변경 기능이 작동합니다. 따라서 값의 모양, 크기 및 레이아웃이 데이터 인사이트를 수집하는 데 중요합니다. 값 표현 간의 공간을 보존하는 방식으로 이러한 차트를 유용하게 만드는 파라미터 조정이 중요합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n숫자 축 기반 차트의 경우 멀리 떨어져 있는 값 모양을 나란히 보여줄 수 있지만, 축 없는 차트를 사용하면 값 모양을 옆으로 보여줄 수 있어요. 데이터와 사용 사례에 따라, 축 없는 방법의 시각화 압축은 축 기반 방법보다 상당한 장점이 될 수 있어요.\n\n위의 버블 차트에서는 면적 및 지름별 크기 설정도 포함했어요. 크기 설정 메커니즘은 종종 간과될 수 있지만, 두 결과 간의 차이는 상당할 수 있어요! 데이터의 성겁과 시각화의 내러티브 맥락에 따라, 시각화 도구에서 크기 설정이 무엇을 기반으로 하는지 항상 알고 있으면, 정보에 기반한 선택을 할 수 있어요.\n\n기본 케이스 (경쟁사)\n\n위의 예시를 리뷰하면 버블 차트가 사용 가능한 공간을 보존하면서 비슷한 형태의 값 세트를 적절히 크기에 맞게 표현하는 우리의 초기 목표를 이루는 경쟁자임을 알 수 있어요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n포장된 Bubble Chart(컨테이너)는 결과를 측정하기 위한 경쟁 상대가 될 것입니다. 그러나 아쉽게도 내가 찾은 구현 (아래에 표시됨)은 원형 레이아웃만 나타내므로 다른 컨테이너 모양을 탐색할 때 완벽한 비교 사례가 되지 않을 것입니다.\n\n```js\n# circlify\nimport circlify\ncircles_circlify = circlify.circlify(data['speed'], show_enclosure=False)\ncircles = [c for c in circles_circlify]\nmax_radius = max(circle.r for circle in circles)\nxlim = max(abs(circle.x) + max_radius for circle in circles)\nylim = max(abs(circle.y) + max_radius for circle in circles)\nlimit = max(xlim, ylim)\nfig, axs = plt.subplots(figsize=(8, 8))\naxs.axis('off')\nplt.xlim(-limit, limit)\nplt.ylim(-limit, limit)\nfor circle in circles:\n    axs.add_patch(plt.Circle((circle.x, circle.y), circle.r,\n        edgecolor='black', facecolor='white', linewidth=2))\nplt.show()\n\n# packcircles\nimport packcircles\ncircles_packcircles = packcircles.pack(data['speed'])\ncircles = [c for c in circles_packcircles]\n# circles\nmax_radius = max(radius for (_, _, radius) in circles)\nxlim = max(abs(x) + max_radius for (x, _, _) in circles)\nylim = max(abs(y) + max_radius for (_, y, _) in circles)\nlimit = max(xlim, ylim)\nfig, axs = plt.subplots(figsize=(8, 8))\naxs.axis('off')\nplt.xlim(-limit, limit)\nplt.ylim(-limit, limit)\nfor (x, y, radius) in circles:\n    axs.add_patch(plt.Circle((x, y), radius,\n        edgecolor='black', facecolor='white', linewidth=2))\nplt.show()\n\n# Tableau Public:\nimport pandas as pd\nimport os\ndf = pd.DataFrame(data)\ndf.to_csv(os.path.dirname(__file__) + '/circles.csv',\n    encoding='utf-8', index=False)\n# select packed bubbles -\u003e Size by [Speed], [Id] on Detail\r\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_8.png\" /\u003e\n\n경쟁 상대를 선택했으니 이제 포장된 Bubble Chart가 홀로 서 있는지 또는 컨테이너 포장 목표를 충족하는 상대적 가치 비교를 위해 활용할 수 있는 다른 단순한 모양이 있는지 살펴보겠습니다. 이제 정사각형의 응용을 탐색해 보겠습니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 왜 Squarify를 사용해야 할까요?\n\n이미 패킹된 원들을 조사하는 무대를 마련했으니, 짧게 쉬어가며 질문을 해보는 게 좋을 것 같아요. 패킹된 원들이 존재하는데 왜 사각형에 관심을 가질까요?\n\n데이터 시각화에서 이미 패킹된 원들이 널리 사용되고 있으므로 사람들은 원을 좋아하는 것으로 보입니다. 다양한 패킹된 버블 차트 구현은 다양한 프로그래밍 언어 및 소프트웨어에서 쉽게 찾을 수 있어요. 사실, Quad-Tile 차트를 만든 후 가장 먼저 한 일은 동그라미를 그리는 데 사용했어요 (소개 부분에 나와 있음). 그래서 동그라미의 매력은 실재해요!\n\n하지만 사각형은 어떨까요? 다른 가능한 모양들과 비교했을 때 패킹된 사각형은 상대적으로 무해해 보이지만, 확실한 패킹된 사각형 차트 구현을 찾는 것은 어렵습니다. 왜 그럴까요...\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n간단한 비교를 하고 어떤 것을 발견해 봅시다:\n\n![image](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_9.png)\n\n위의 경우 1:2 비율을 사용하여 넓이나 길이를 비교하는 데 둥근 모양이나 사각형 모두 다른 것보다 직관성을 제공하지 않는 것으로 보입니다. 하지만 원은 더 부드럽고 사각형은 더 날카로운 것 같아요.\n\n그렇다면, 나는 스퀘어리파이를 하는 이유가 다음과 같습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 패킹된 사각형 구현은 존재하지 않는 것 같아서 시각적으로 얼마나 매력적인지 알기가 어렵습니다(패킹된 원의 대체물로). 따라서 조사할 가치가 있습니다.\n- 파이썬의 사용 가능한 패킹된 원 구현물에서는 컨테이너를 활용할 수 있는 능력이 일반적으로 부족합니다(모두 원의 수가 증가함에 따라 원형 레이아웃만 제공하는 것으로 보입니다).\n- 사각형의 단순성은 알고리즘을 통해 사각형을 채우려고 시도하면 수학적 연산이 직관적일 것으로 보입니다. 따라서 빠른 개념 증명이 가능할 수도 있습니다.\n\n스퀘어화를 추구하는 동기를 제시했으니, 이제 사각형 패킹 노력의 핵심 구성 요소인 패킹을 살펴보고, 사각형이 원에 어떻게 대응하는지 확인해봅시다.\n\n# 모양 패킹 \u0026 컨테이너 패킹\n\n## 타일링과 함께\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n수사 목적으로 명백한 것을 언급할 가치가 있습니다. 사각형은 가장을 가지고 있지만 원은 그렇지 않습니다. 이 특성은 유사한 크기의 사각형들을 테셀레이션할 수 있게 해주어, 패킹이라는 유용한 개념이 될 수 있습니다.\n\n```js\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\n\n# 도형과 공간을 사용하여 다이아몬드 테셀레이션 모의실험을 해봅시다.\ndef diamond_tessellation(rows, cols):\n    fig, ax = plt.subplots()\n    ax.set_aspect('equal', adjustable='box')\n    plt.axis('off')\n    for row in range(rows):\n        for col in range(cols):\n            diamond = patches.Polygon([\n                (col + 0.5, row), \n                (col + 1, row + 0.5), \n                (col + 0.5, row + 1), \n                (col, row + 0.5)\n                ], edgecolor='grey', facecolor='whitesmoke')\n            ax.add_patch(diamond)\n    ax.set_xlim(0, cols)\n    ax.set_ylim(0, rows)\n    plt.show()\n\ndiamond_tessellation(2, 9)\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_10.png\" /\u003e\n\n유감스럽게도, 테셀레이션은 데이터셋의 값이 동일하거나 편리한 비율을 가지는 것으로 가정하는 것이 현실적이지 않기 때문에 일반적인 해결책은 아닙니다. 그러나 간격이 없는 가장의 개념은 원보다 잠재적인 이점으로 더 탐구할 가치가 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 최적화로\n\n최적화 방법은 두 개의 모양을 비교하는 메커니즘으로 다음 단계로 가치 있는 것처럼 보입니다. 그래서 원과 정사각형 사이에 가능한 균일하게 적용할 수 있는 간단한 목적 함수에 집중하여 결과를 검토해 봅시다.\n\n먼저, 목적 함수의 요소를 식별해야 합니다. 우리는 모양의 중첩을 방지하는 메커니즘과 밀접하게 패킹하려는 반대 힘이 필요합니다. 각각을 자세히 살펴보겠습니다.\n\n- 중첩 방지 (밀어내기) - 중첩을 방지하기 위해 모양들의 총 중첩 영역을 고려하고, 다른 모양에 완전히 포함되는 모양에 대해 추가 벌칙을 부과하여 작은 모양의 중첩 방지를 촉진합니다.\n- 패킹 촉진 (가까이 끌어모으기) - 패킹을 촉진하기 위해 모양을 특정 관심 지점으로 끌어당기는 것을 보상할 것입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지금은 컨테이너를 무시하고 도형 패킹에 초점을 맞춰 각 도형의 기하학적 특징을 살펴봅시다. 이제 식별된 재료로 구현할 함수를 설정해 봅시다.\n\n```js\nfrom shapely.geometry import Point, Polygon\nfrom shapely.ops import unary_union\n\n# 셰이프의 중심에서 관심 지점까지의 거리를 더하여 당김 힘을 설정합시다\ndef calc_distance_from_point(shapes, shape_type, origin):\n    penalty = 0\n    ref_point = Point(origin)\n    if shape_type == 'circle':\n        for x, y, _ in shapes:\n            centroid = Point(x, y)\n            penalty += centroid.distance(ref_point)\n    elif shape_type == 'square':\n        for x, y, side in shapes:\n            centroid = Polygon([(x, y), (x + side, y),\n                (x + side, y + side), (x, y + side)]).centroid\n            penalty += centroid.distance(ref_point)\n    return penalty\n\n# 이제 첫 번째 당김 힘을 설정하여 한 도형이 다른 도형 안에 포함되어 있는지 여부를 파악하고 발생 횟수를 더합시다\ndef calc_containment(shapes, shape_type):\n    penalty = 0\n    shapely_shapes = []\n    if shape_type == 'circle':\n        shapely_shapes = [Point(x, y).buffer(r) \n            for x, y, r in shapes]\n    elif shape_type == 'square':\n        shapely_shapes = [Polygon([(x, y), (x + side, y),\n            (x + side, y + side), (x, y + side)]) \n            for x, y, side in shapes]\n    for i, shape1 in enumerate(shapely_shapes):\n        for j, shape2 in enumerate(shapely_shapes):\n            if i != j and shape1.contains(shape2):\n                penalty += 1\n    return penalty\n\n# 당김 힘을 완성하기 위해 전체 도형 중첩 영역을 계산합시다\ndef calc_overlap_area(shapes, shape_type):\n    if shape_type == 'circle':\n        shapely_shapes = [Point(s[0], s[1]).buffer(s[2]) \n            for s in shapes]\n    elif shape_type == 'square':\n        shapely_shapes = [Polygon([(s[0], s[1]), (s[0] + s[2], s[1]), \n            (s[0] + s[2], s[1] + s[2]), (s[0], s[1] + s[2])]) \n            for s in shapes]\n    merged_area = unary_union(shapely_shapes).area\n    individual_areas = sum(shape.area for shape in shapely_shapes)\n    return abs(individual_areas - merged_area)\n\n# 마지막으로, 힘을 종합하여 목적 함수로 만들어봅시다\ndef objective_function(variables, shapes, shape_type, \n    origin=(0,0), prevent_overlap_factor=2):\n    for i, shape in enumerate(shapes):\n        shapes[i] = (variables[i*2], variables[i*2 + 1], shape[2])\n    overlap_area = calc_overlap_area(shapes, shape_type)\n    contained = calc_containment(shapes, shape_type)\n    sum_distance = calc_distance_from_point(shapes, shape_type, origin)\n    return overlap_area * prevent_overlap_factor * (1 + contained) + sum_distance\n```\n\n목적 함수에서는 도형의 겹치는 영역을 포함하는 모양의 수와 곱하여 당김 패널티를 집중시키기로 선택했습니다. 그리고 당김 정도를 조절하는 'prevent_overlap_factor' 가중치를 추가했습니다.\n\n이제 목적 함수가 준비되었으니, 이전의 예제 데이터를 사용하여 원과 사각형 패킹 최적화 루틴을 설정해 봅시다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\r\n# 이전 예시 데이터:\r\ndata = {\r\n    'id' : [str(i) for i in range(1, 21)],\r\n    'speed' : [242,200,105,100,100,95,92.5,88,80,79,\r\n        75,67.85,61.06,60,56,55,55,55,50,50]\r\n}\r\n\r\n# 원하는 크기 창(Window) (계수)와 모양의 반복 가능한 랜덤 위치를 위한 시드를 설정해봅시다.\r\n\r\n계수 = 10\r\n시드 = 123\r\n\r\n최대속도 = np.max(data['speed'])\r\nnp.random.seed(시드)\r\n\r\n모양들 = [(np.random.uniform(0, 계수*1.5),\r\n    np.random.uniform(0, 계수*1.5),\r\n    v/최대속도*계수) for v in data['speed']]\r\n```\r\n\r\n이제, 원과 사각형의 입력을 분리하고 최적화 메서드에 전달할 경계를 추가해봅시다.\r\n\r\n```js\r\nimport numpy as np\r\nimport copy\r\nfrom math import sqrt\r\n\r\n# 각 모양에 대해 최적화하기 위해 복사본을 만듭시다.\r\n원들 = copy.deepcopy(모양들)\r\n사각형들 = copy.deepcopy(모양들)\r\n\r\n# 위치를 최적화하기 위해 좌표를 평면으로 펼쳐봅시다\r\n초기_위치 = [val for s in 모양들 for val in s[:2]]\r\n\r\n# 이제 각 모양의 경계를 계산하여 최적화 함수에 전달합시다\r\ndef calc_bounds(모양들, 모양_유형):\r\n    총_면적 = 0\r\n    if 모양_유형 == '원':\r\n        총_면적 = sum(np.pi * (r**2) for _, _, r in 모양들)\r\n    elif 모양_유형 == '사각형':\r\n        총_면적 = sum(side**2 for _, _, side in 모양들)\r\n    추정된_한변의_길이 = sqrt(총_면적)\r\n    패딩 = 추정된_한변의_길이 / 2\r\n    하한 = 0 - 패딩\r\n    상한 = 추정된_한변의_길이 + 패딩\r\n    return (하한, 상한)\r\n\r\n# 원과 사각형에 대한 경계 계산\r\n원의_경계 = calc_bounds(원들, '원')\r\n사각형의_경계 = calc_bounds(사각형들, '사각형')\r\n\r\n# 각 모양에 경계를 적용하여 최적화하기\r\n원_경계들 = [(원의_경계[0], 원의_경계[1]) \r\n    for _ in range(len(초기_위치))]\r\n사각형_경계들 = [(사각형의_경계[0], 사각형의_경계[1])\r\n    for _ in range(len(초기_위치))]\r\n\r\n# 풀 힘을 위한 접힘점을 설정하기 위해 경계를 사용\r\n원의_접힘점 = (원의_경계[1]-원의_경계[0])/2+원의_경계[0]\r\n사각형의_접힘점 = (사각형의_경계[1]-사각형의_경계[0])/2+사각형의_경계[0]\r\n원의_접힘점들 = (원의_접힘점, 원의_접힘점)\r\n사각형의_접힘점들 = (사각형의_접힘점, 사각형의_접힘점)\r\n```\r\n\r\n마지막으로, 결과를 시각화하기 위한 플로팅 함수를 설정하고 각 모양에 대해 최적화를 실행해보겠습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\nfrom math import inf\nfrom scipy.optimize import minimize\n\n# 결과를 확인할 수 있는 plotting 함수를 만들어봅시다.\ndef plot_shapes(shapes, shape_type):\n    fig, ax = plt.subplots()\n    min_x, min_y, max_x, max_y = 0.,0.,0.,0.\n    for s in shapes:\n        if shape_type == 'circle':\n            circle = patches.Circle((s[0], s[1]), s[2],\n                facecolor='lightgrey', edgecolor='black')\n            ax.add_patch(circle)\n            min_x = min(min_x, s[0] - s[2])\n            min_y = min(min_y, s[1] - s[2])\n            max_x = max(max_x, s[0] + s[2])\n            max_y = max(max_y, s[1] + s[2])\n        elif shape_type == 'square':\n            square = patches.Rectangle((s[0], s[1]), s[2], s[2],\n                facecolor='lightgrey', edgecolor='black')\n            ax.add_patch(square)\n            min_x = min(min_x, s[0])\n            min_y = min(min_y, s[1])\n            max_x = max(max_x, s[0] + s[2])\n            max_y = max(max_y, s[1] + s[2])\n    padding = 1\n    ax.set_xlim(min_x - padding, max_x + padding)\n    ax.set_ylim(min_y - padding, max_y + padding)\n    ax.set_aspect('equal', 'box')\n    plt.show()\n\n# 마지막으로 반복을 모니터링하는 콜백 함수를 설정해봅시다.\ndef callback(i):\n    global iteration\n    iteration += 1\n    print(f'반복 {iteration}')\n\n# 원 최적화 실행:\niteration = 0\noptimized_circles = minimize(objective_function, initial_positions,\n    args=(circles, 'circle', origin_circles), method='L-BFGS-B',\n    bounds=bounds_circles, callback=callback,\n    options={'maxiter': 300, 'maxfun': inf, 'ftol': 0, 'gtol': 0})\npacked_circles = [(optimized_circles.x[i*2],\n    optimized_circles.x[i*2 + 1], circles[i][2])\n    for i in range(len(circles))]\n# plot_shapes(shapes, 'circle') # 초기 위치를 보려면 주석 해제\nplot_shapes(packed_circles, 'circle')\n\n# 사각형 최적화 실행:\niteration = 0\noptimized_squares = minimize(objective_function, initial_positions,\n    args=(squares, 'square', origin_squares), method='L-BFGS-B',\n    bounds=bounds_squares, callback=callback,\n    options={'maxiter': 300, 'maxfun': inf, 'ftol': 0, 'gtol': 0})\npacked_squares = [(optimized_squares.x[i*2],\n    optimized_squares.x[i*2 + 1], squares[i][2])\n    for i in range(len(squares))]\n# plot_shapes(shapes, 'square') # 초기 위치를 보려면 주석 해제\nplot_shapes(packed_squares, 'square')\r\n```\n\n위 코드에서는 'L-BFGS-B' 메서드를 선택하여 scipy의 'minimize' 함수에서 반복 횟수를 300으로 설정했습니다. 초기 위치를 제어하는 난수 시드는 결과에 영향을 미칠 수 있으므로 두 모양에 대해 각각 3가지 다른 시드를 살펴봅시다.\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_11.png\" /\u003e\n\n각 테스트 케이스를 생성하는 데 랩톱에서 약 5분이 걸렸으므로, 이 방법의 시간 요구 사항은 고려해야 할 불안정한 요소입니다. 이미 긴 대기 시간 때문에 컨테이너 중첩 비용을 목적 함수에 추가하여 컨테이너 패킹 통찰을 검토하는 것은 현재 필요하지 않은 것으로 보입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지면 배치 관련해서 원들이 더 조밀하게 배열되어 있는 것 같습니다. 이것이 데이터 시각화에서 패킹된 원이 패킹된 정사각형보다 흔한 이유를 설명하는 첫 번째 증거가 될 수 있습니다.\n\n하지만 포기하기 전에, 정사각형에 맞춤화된 알고리즘을 사용한 최종 평가로 넘어가 봅시다!\n\n## 알고리즘을 통해\n\n위의 실험에서 얻은 주요 결론은:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 일반 최적화 구현을 사용하여 단순 목적 함수에 따라 패킹된 모양을 생성하는 것은 어느 정도 작동하는 것 같아요.\n- 그러나 이것은 정말 느리고 대규모 데이터셋을 처리하기에 부적합하죠.\n- 원형 배열들이 (적어도 컨테이너 패킹 없이는) 사각형 배열보다 더 융합되어 보였어요.\n\n우리는 대규모 데이터셋에서 성능이 우수하며 더 매력적인 사각형 배열을 생성할 수 있고, 컨테이너 패킹을 구현할 수 있는 특수화된 알고리즘이 필요하다는 것이 분명해요. 이 방식을 일반적인 최적화 프레임워크와 구분짓기 위해 사각형의 특정 특성을 활용하고, 포장 기회를 탐색할 필요가 있어요.\n\n우리가 활용할 수 있는 사각형의 몇 가지 기하학적 요소를 나열하여 시작해봐요:\n\n- 형태: 네 개의 직각을 감싸고 있는 같은 길이의 네 변을 가지며, 화면을 기준으로 회전할 수 있어 다른 외형이 될 수 있는\n- 패킹: 간격 없이 사각형 사이에 이웃할 수 있는 능력\n- 배치: 각 사각형의 각 변은 4개의 가능한 꼭지점 중 하나에서 시작하여 이웃할 사각형에게 이웃할 수 있는 평면적인 2차원 공간을 무한대로 제공함\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음에는 패킹된 사각형이 패킹된 원과 어떻게 경쟁할 수 있는지 이해하기 위해 Quad-Tile 차트라는 새로운 시각화 기술에 사용되는 알고리즘을 설명할 것입니다.\n\n## Quad-Tile 차트\n\n### 영감\n\n몇 년 전 어떤 사람이 패킹된 버블 차트는 대부분 쓸모없다고 말했습니다. 무슨 이유에서인지 그 말이 나에게 영감을 주어 패킹된 사각형 차트를 만들게 되었습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n첫 번째 버전을 개발하고 Tableau Public 시각화와 몇 가지 다른 기술과 함께 구체화된 결과물을 시험해 보았어요. 여기에는 18개의 사각형을 포함하는 Voronoi Treemaps가 있는 (v1) Quad-Tile Chart가 표시된 발췌본이 있어요. (Voronoi Treemaps는 D3.js를 사용하여 계산되었어요).\n\n![Quad-Tile Chart](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_12.png)\n\n아래에서는 이 알고리즘에 대해 설명하고, 몇 일 전에 다시 시작했을 때 최종적으로 채택한 방식을 설명할게요.\n\n## (초기) 알고리즘 v1\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n내 초기 접근 방식인 2022년 초에는 컨테이너를 고려하지 않았습니다. 가장 큰 정사각형부터 시작하여 중앙에 배치한 후 모든 정사각형이 중심 정사각형 주변에 감싸지도록 연속적으로 나열하려고 노력했습니다. 가장 작은 정사각형은 가장 중심부터 먼 위치에 배치되었습니다.\n\n마디 있는 정사각형 배열에 관해 스케치한 후에 나에게 온 개념 중에는 다음과 같은 것들이 있습니다:\n\n- 사분면 - 조사한 결과, 정사각형은 연속적인 사각형들을 분산하기 위한 4개의 오프셋 평면을 제공합니다.\n- 자기 조직화 정사각형 배치 - 한 평면의 잠재적 너비와 오프셋 평면의 차지된 높이를 연관시킴으로써 자기 조직화를 가능케하도록 하며, 이는 공유 경계(분할된 세그먼트로 실행됨)를 구현함으로써 이루어집니다.\n- 측면 전환 - 크기에 따라 정사각형들을 고르게 분산하기 위해, 원하는 순서로 하나를 배치한 후 측면을 전환합니다. (나는 기본적으로 윗쪽-오른쪽-아래쪽-왼쪽으로 전환했습니다.)\n- 사용자 정의 - 이 방법은 값 정렬을 배제하지만, 일련의 규칙에 따라 다음 측면을 선택할 수 있는 기능을 구현할 수 있는 능력을 제공합니다.\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_13.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nv1 알고리즘은 다음과 같아요:\n- 먼저 양수 값들로 이루어진 집합부터 내림차순으로 정렬해요. 예를 들어, 9.4, 7.4, 1.5, 0.2\n- 값을 패딩하기 위해 각 사각형 주변의 공간을 추가한 후 (예를 들어 0.5)\n- 첫번째 (가장 큰) 사각형을 설정하고, 중앙 사각형 주변의 각 사분면을 위한 세그먼트 저장 메커니즘을 생성해요.\n- 초기 세그먼트를 중앙 사각형의 변으로 설정하고, 각 사분면에 하나씩 배정해요.\n- 옆면 순서 (기본값은 위, 오른쪽, 아래, 왼쪽)가 주어지면, 각 면을 반복하면서 작은 사각형을 배치해요. 각 사분면의 첫 번째 사각형은 해당 사분면 평면의 원점과 정렬되어, 해당 사분면의 초기 세그먼트 시작 위치에서 시작해요.\n- 위쪽 면에 사각형을 배치하려면 (정렬 및 배치 요구 사항을 고려하여), 세그먼트를 가장 짧은 y값별로 정렬하고 가장 긴 길이를 가지는 세그먼트에서, 사각형의 너비 ≤ 세그먼트 길이인 첫 번째 세그먼트에 사각형을 배치해요.\n- 사각형을 배치하면, 해당 사각형이 차지한 공간을 세그먼트에서 조절하여 세그먼트의 시작 위치 및 길이를 조정하고, 새로운 세그먼트를 만들어요.\n- 배치된 사각형의 시작 위치가 사분면 평면의 오프셋 경계와 정렬되면 (중앙 사각형의 축에 수직인 경계), 중앙 사각형 주변의 자기 조직화 성장을 가능하게 하기 위해 영향을 받는 세그먼트의 세그먼트 길이를 연장해요.\n- 원하는 스택 구성을 위해 필요한 측 선택 메커니즘을 구현해요.\n- 사각형을 버퍼로 다시 원래 크기로 바꾸고, 원하는 회전으로 사각형을 회전시켜요 (기본값은 45도).\n\n아래 다이어그램은 세그먼트 기반 접근 방법을 보여줘요. 각 세그먼트는 다음과 같이 될 거에요:\n- 원래 위치에서 한 방향으로 효과적으로 이동시켜져요 (사각형의 너비가 세그먼트 길이와 같은 경우)\n- 두 섹션으로 분할돼요 (하나는 배치된 사각형의 너비를 따르고, 다른 하나는 시작 위치와 길이가 변경된 원래 세그먼트일거에요).\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_14.png\" /\u003e\n\n재미로, 몇 가지 측면 선택 옵션을 구현했는데 'constraints' 입력란은 다각형을 받아들이고 외곽을 벗어나면 측면을 전환하려고 시도하여 다각형과 겹치는 특정 영역에서의 성장을 촉진합니다.\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_15.png\" /\u003e\n\n이것이 제 두 번째 영감으로 이어집니다. Quad-Tile Chart v1을 내 vizmath 패키지에 통합할 때 다각형 입력과 더 많은 작업을 할 수 있는지 생각하기 시작했습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n일부 실험 끝에, 주어진 다각형 내에 꼭지점이 깔끔하게 맞는 완전히 기능적인 컨테이너 패킹 구현이 재미있을 것이라고 결정하고 처음부터 알고리즘을 완전히 개편해보기로 했습니다! 다음에 해당하는 알고리즘을 확인해 봅시다: Quad-Tile Chart v2\n\n## (최종) 알고리즘 v2\n\n이 알고리즘의 두 번째 버전은 v1의 일부 핵심 요소를 확장하고 쿼드런트-세그먼트 접근 방식을 유사하게 사용하면서 몇 가지 수정 사항과 컨테이너 패킹을 수용하기 위한 몇 가지 새로운 기능을 추가합니다.\n\nv2에 대한 주요 세부 내용은 다음과 같습니다. 특별한 점을 확인해 보세요:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Bridge Segments(컨테이너 채우기)\n- Backward Segment Extension(‘축소’ 옵션)\n- Value Multiplier Bisection Optimization(컨테이너 패킹)\n\n![image](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_16.png)\n\n다음은 v2 알고리즘입니다:\n\n- 단계 1~5는 v1과 동일하지만 2가지 세그먼트 속성(세그먼트 높이 및 세그먼트가 활성화되어 있는지), 3가지 사분면 레벨 속성(최소 바닥과 천장 및 해당 사분면 전체가 방을 다 쓴 것인지) 및 배치된 사각형에 대한 속성(왼쪽 아래 모서리 좌표 및 너비)가 추가됩니다.\n- 이터레이터(처음에 0으로 설정)가 놓여야 하는 사각형 수보다 작을 동안 다음 절차가 수행됩니다:\n- 마지막 바닥 세그먼트(LFS)를 찾습니다: max(segments: 'y=floor', sort: 'x')\n- 정렬된 세그먼트 목록을 만듭니다: (segments: 'is active', sort: 'height, x')\n- 정렬된 세그먼트를 루프합니다(아래에서 '세그먼트' 및 루프 반복 '세그먼트'로 참조됨) 및 진행합니다.\n- 만약 사각형의 모퉁이가 다각형 내에 있고 사각형의 '너비'와 '높이'가 세그먼트의 '너비'와 '높이'에 맞는다면 사각형은 배치됩니다. 그렇지 않으면 세그먼트를 '비활성화'로 설정합니다.\n- 세그먼트의 'y' 값이 사분면의 '바닥'과 같다면 사각형의 '너비'를 추가하여 '바닥'을 업데이트합니다.\n- 사각형이 배치되면 사각형의 너비와 세그먼트 길이에 따라 현재 세그먼트를 대체할 1개 또는 2개의 새 세그먼트를 생성합니다.\n- 축소가 활성화된 경우 다음 절차가 수행됩니다:\n- 세그먼트를 새로 생성된 세그먼트 중 가장 왼쪽으로 설정(NLS).\n- 확장할 세그먼트를 찾습니다: max(segments: 'x + 길이 = NLS.x', 'y = NLS.y', sort: 'x')\n- 확장할 세그먼트가 존재하는 경우, NLS 길이를 추가하고 NLS를 제거합니다.\n- 그렇지 않은 경우, 왼쪽 사각형(LS)을 찾습니다: max(squares: 'x+w≤NLS.x', 'y≤NLS.y', 'y+x≥NLS.y', sort: 'x')\n- 왼쪽 사각형(LS)이 존재하면 LS.x + LS.w ≤ NLS.x를 확인하여 갭이 있는지 확인합니다.\n- 그렇다면, 커버된 세그먼트(CS)를 확인합니다: max(segments: 'y=LS.y', 'x`NLS.x', sort: 'x')\n- 커버된 세그먼트가 존재하는 경우, 세그먼트 높이를 사각형 너비와 동일하게 설정하고 병합 세그먼트를 확인합니다: max(segments: 'x+길이+CS.length = NLS.x', 'y=NLS.y', sort: x)\n- 병합 세그먼트가 존재하는 경우, 사각형 너비와 CS.length를 추가하여 길이를 확장합니다.\n- 그렇지 않은 경우, LS.x + LS.w ≤ NLS.x - 사각형 너비라면 NLS.x = LS.x+LS.w 및 NLS.길이 = CS.length으로 NLS를 조정합니다.\n- 세그먼트가 LFS와 같고 배치되지 않았으며 사분면의 바닥이 천장과 다른 경우 다리 세그먼트를 생성합니다. 다음 절차를 따릅니다:\n- LFS.높이 및 사분면 바닥을 사분면 천장으로 업데이트합니다.\n- 천장 세그먼트(CS)가 천장에서 존재하는지 확인합니다: max(segments: 'y=ceiling', sort: x)\n- 존재하는 경우, 그 길이를 다각형 경계까지 확장합니다.\n- 그렇지 않은 경우, (세그먼트.x, 천장)에 새 세그먼트를 생성하고 해당 지점과 다각형 경계 사이의 거리로 길이를 설정합니다.\n- 마지막으로, 모든 세그먼트를 '활성화'로 설정하고 루프를 종료합니다.\n- 그렇지 않은 경우, 사각형이 배치되면 사각형을 사각형 목록에 추가하고 해당 속성을 설정하고 사분면을 '방이있음'으로 설정하고 세그먼트가 마지막 세그먼트인 경우 모든 세그먼트를 '활성화'로 설정하고 이터레이터를 1 증가시키고 다음 측면을 설정하고 루프를 종료합니다.\n- 그렇지 않은 경우, 마지막 세그먼트에 도달하면 가능한 경우 더 많은 다리 세그먼트를 추가하려 시도합니다. 다음 절차를 따릅니다:\n- 다리 사각형(BS)을 확인합니다: 첫번째(squares: 'x+w=LFS.x', 'y=LFS.y')\n- 있으면, LFS.높이 = BS.x로 설정하고 사분면 바닥을 BS.w만큼 증가시키고 사분면 천장을 바닥으로 설정합니다.\n- 다리 사각형 세그먼트를 확인합니다: max(segments: 'y=floor', sort: x)\n- 하나가 존재한다면, 그 길이를 다각형 경계까지 확장합니다.\n- 그렇지 않은 경우, (BS.x+BS.w, 바닥)에 새 세그먼트를 생성하고 해당 지점과 다각형 경계 사이의 거리로 길이를 설정합니다.\n- 마지막으로, 모든 세그먼트를 '활성화'로 설정하고 루프를 종료합니다.\n- BS를 찾지 못한 경우, 사분면을 '방이없음'으로 설정하고 모든 세그먼트를 '활성화'로 설정하고 다음 측면을 설정하고 모든 사분면이 방이없으면 이터레이터를 놓여야 하는 사각형 수로 설정(사실상 외부 while 루프를 종료합니다).\n- v1의 단계 10을 반복하며 각 사분면을 올바른 방향으로 회전합니다.\n- 자동 배열 옵션이 선택된 경우(컨테이너 패킹), 변환된 값들\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nv2 알고리즘은 컨테이너 패킹을 맞추기 위해 훨씬 더 많은 작업을 필요로했기 때문에 v1 알고리즘의 간단함에 비해 더 많은 노력이 필요했습니다. 하지만 정말 그만한 가치가 있었어요! v2에서 몇 가지 레이아웃 예제를 살펴봅시다.\n\n![이미지](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_17.png)\n\n위의 원 형태의 외곽선은 '축소' 기능을 사용하여 참조용으로 포함했습니다. v2의 이론적 한계는 아마도 자기 자신을 내부로 돌리는 다각형들일 것입니다 (이는 사분면의 타일링 평면에서 고유 다각형 갭을 처리하기 위한 향상된 세그먼트 논리가 필요할 것입니다).\n\n다음으로, Python에서 Quad-Tile 차트를 구축하는 방법을 살펴보겠습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 파이썬 구현\n\n저는 제 Quad-Tile Chart 알고리즘 v1 및 v2를 파이썬에서 사용할 수 있도록 vizmath 패키지를 통해 구현했습니다. PyPI에서 제공됩니다. 소개에서 시작하는 초기 예제를 사용하여 몇 가지 추가 옵션을 살펴보고 입력 및 출력을 설명하겠습니다. 먼저 v1로 시작합니다:\n\n```js\n# Quad-Tile Chart v1\n# pip install vizmath==0.0.22\nfrom vizmath.quadtile_chart import quadtile as qt\nimport pandas as pd\n\ndata = {\n    'id' : [str(i) for i in range(1, 21)],\n    'speed' : [242,200,105,100,100,95,92.5,88,80,79,\n        75,67.85,61.06,60,56,55,55,55,50,50]\n}\ndf = pd.DataFrame(data)\n\n# 쿼드타일 객체 생성\n#   \u003e df: 데이터와 id 필드가 있는 DataFrame\n#   \u003e id_field: 필수 식별자 필드 (더미값 사용 가능)\n#   \u003e value_field: 필수 값 열\n#   \u003e xo: x축 기준점\n#   \u003e yo: y축 기준점\n#   \u003e packing: 패킹 방법 ('auto','inc','num','max','min')\n#   \u003e overflow: 'num', 'max', 'min' 패킹을 위한 정수 임계값\n#   \u003e buffer: 사각형 크기에 추가 값\n#   \u003e rotate: 차트 회전 각도\n#   \u003e constraints: 둘레 내부 성장을 촉진하는 다각형\n#   \u003e size_by: 'area' 또는 'width'\n#   \u003e poly_sort: 다각형 정점 정렬 활성화/비활성화 (참, 거짓)\nqt_o_area = qt(df,'id','speed', size_by='area', buffer=0)\nqt_o_width = qt(df,'id','speed', size_by='width', buffer=0)\n\n# 차트 그리기 (면적 및 너비에 따라 크기 조절)\nqt_o_area.quadtile_plot(color='quad', cw=0.75, opacity=.9)\nqt_o_width.quadtile_plot(color='quad', cw=0.75, opacity=.9)\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_18.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 v2를 사용해 봅시다:\n\n```js\n# Quad-Tile Chart v2\n# pip install vizmath==0.0.22\nfrom vizmath.quadtile_chart import polyquadtile as pqt\nimport pandas as pd\n\ndata = {\n    'id': [str(i) for i in range(1, 21)],\n    'speed': [242, 200, 105, 100, 100, 95, 92.5, 88, 80, 79, 75, 67.85, 61.06, 60, 56, 55, 55, 55, 50, 50]\n}\ndf = pd.DataFrame(data)\n\n# 쿼드타일 객체 생성\n#   \u003e df: 데이터를 포함하고 있는 DataFrame, 숫자형 데이터 컬럼과 id 필드를 가져야 함\n#   \u003e id_field: 필수 식별자 필드 (더미 값 사용 가능)\n#   \u003e value_field: 필수 값 컬럼\n#   \u003e xo: x축 원점\n#   \u003e yo: y축 원점\n#   \u003e buffer: 사각형 크기를 조절하는 보정값\n#   \u003e rotate: 차트 회전 각도\n#   \u003e sides: 포함시킬 변 선택 ('top', 'right', 'bottom', 'left')\n#   \u003e collapse: 축소/확대 설정 (True, False)\n#   \u003e constraints: 패킹할 다각형 컨테이너\n#   \u003e xc: x축 컨테이너 오프셋 값\n#   \u003e yc: y축 컨테이너 오프셋 값\n#   \u003e size_by: 'area' 또는 'width'\n#   \u003e auto: 자동 패킹 활성화/비활성화 (True, False)\n#   \u003e auto_max_iter: 자동 패킹 반복 횟수\n#   \u003e auto_min_val: 자동 패킹 최소 배수\n#   \u003e auto_max_val: 자동 패킹 최대 배수\n#   \u003e poly_sort: 다각형 꼭지점 정렬 활성화/비활성화 (True, False)\npqt_o_area = pqt(df, 'id', 'speed', size_by='area', buffer=0)\npqt_o_width = pqt(df, 'id', 'speed', size_by='width', buffer=0)\n\n# 차트 그리기 (면적 및 폭에 따라 사이즈가 지정된 차트)\npqt_o_area.polyquadtile_plot(color='quad', cw=0.75, opacity=0.9)\npqt_o_width.polyquadtile_plot(color='quad', cw=0.75, opacity=0.9)\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_19.png\" /\u003e\n\n이제 v1 및 v2의 랜덤 초기화 옵션을 포함한 몇 가지 추가 옵션을 조사해 봅시다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 1000개의 임의 크기 사각형을 테스트해봅시다:\nfrom vizmath.quadtile_chart import quadtile as qt\nfrom vizmath.quadtile_chart import polyquadtile as pqt\n\n# 상단 좌측에 회전된 Quad-Tile Chart v1\nqt_o1 = qt.random_quadtile(1000, rotate=45)\nqt_o1.quadtile_plot(color='quad', cw=0.75, opacity=.9)\n\n# 상단 우측에 비회전 Quad-Tile Chart v1\nqt_o2 = qt.random_quadtile(1000, rotate=0)\nqt_o2.quadtile_plot(color='quad', cw=0.75, opacity=.9)\n\n# 하단 좌측에 정사각형 컨테이너를 사용한 Quad-Tile Chart v2\npoly = [(-10,-10),(-10,10),(10,10),(10,-10)] # 다각형 컨테이너\npqt_o1 = pqt.random_polyquadtile(1000, constraints=poly, buffer=0)\npqt_o1.polyquadtile_plot(color='quad', cw=0.75, opacity=.9)\n\n# 중앙에 가로 세로 비율이 1:1인 Quad-Tile Chart v2\npqt_o2 = pqt.random_polyquadtile(1000, constraints=[(1,1)], buffer=0)\npqt_o2.polyquadtile_plot(color='quad', cw=0.75, opacity=.9)\n\n# 하단 우측에 가로 세로 비율이 1:1인 Quad-Tile Chart v2\npqt_o3 = pqt.random_polyquadtile(1000, constraints=[(1,1)],\n    buffer=0, rotate=0)\npqt_o3.polyquadtile_plot(color='quad', cw=0.75, opacity=.9, circles=False)\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_20.png\" /\u003e\n\n위 내용은 각 버전 간 배치 방법의 미묘한 차이를 보여줍니다 (v1은 y값이 가장 낮고 가장 긴 길이로 선택된 세그먼트, v2는 계단식 접근 방식). 또한 v2에 대한 무작위 초기화는 무작위 볼록 다각형을 생성할 것입니다 — 무엇이 나올지 아무도 모릅니다!\n\n```js\nfrom vizmath.quadtile_chart import polyquadtile as pqt\n\npqt_o = pqt.random_polyquadtile(100, collapse=True)\npqt_o.polyquadtile_plot(color='quad', cw=0.75, opacity=.9, circles=True,\n    show_constraints=True)\n\n# 계속해서 무작위 크기 사각형을 사용한 무작위 컨테이너 실행\r\n```  \n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_21.png\" /\u003e\n\n그리고 끝으로, 우리는 중심점을 사용하여 부모 사각형의 경계 상자 크기에 맞는 모든 모양으로 플롯할 수 있음을 기억하세요. 원형 차트의 경우에는 반소형 Bubble Chart만 플로팅한다는 소개를 참조하세요!\n\n이제 Quad-Tile Chart 알고리즘으로 생성된 사분면 다각형과 사분면 중심점 출력을 검토해 봅시다.\n\n사분면 다각형 출력:\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- item — ‘id’ 입력 필드로 지정된 수신 식별자\n- a — 사각형의 상대적 면적 (버퍼는 포함되지 않음)\n- w — 할당된 공간의 너비: 사각형의 너비 + 버퍼*2\n- x, y — 레이아웃 내의 점에 대한 직교 좌표\n- path — 폴리곤을 둘러싼 경로를 나타내는 정수 순서 집합으로, Crystal Bar Chart의 각 크리스탈 ID 및 면에 대해 각각의 (x, y) 점과 함께 사용됨: 1부터 N까지\n\n```js\nfrom vizmath.quadtile_chart import polyquadtile as pqt\nimport pandas as pd\n\n# 컨테이너에 맞게 크기 조정 없이 초기 예제 데이터 사용:\ndata = {\n    'id' : [str(i) for i in range(1, 21)],\n    'speed' : [242,200,105,100,100,95,92.5,88,80,79,75,67.85,61.06,60,56,55,55,55,50,50]\n}\npoly = [(-1000,-1000),(-1000,1000),(1000,1000),(1000,-1000)] # 설명 예제 출력을 위한 충분히 큰 컨테이너\ndf = pd.DataFrame(data)\no_pq1 = pqt(df,'id','speed',buffer=5.0, collapse=True, constraints=poly, auto=False)\no_pq2 = pqt(df,'id','speed',buffer=5.0, collapse=True, constraints=poly, auto=False, size_by='width')\n\n# 면적에 따라 크기 조정:\no_pq1.o_polyquadtile_chart.df[['id','item','a','w','x','y','path']].head()\n# 너비에 따라 크기 조정:\no_pq2.o_polyquadtile_chart.df[['id','item','a','w','x','y','path']].head()\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_22.png\" /\u003e\n\n사각형 중심점은 'id' 대신 'item'으로 동일한 속성으로 추출될 수도 있습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n# 넓이 별 크기:\no_pq1.o_polysquares.df[['id','a','w','x','y']].head()\n\n# 너비 별 크기:\no_pq2.o_polysquares.df[['id','a','w','x','y']].head()\n\n\n![이미지](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_23.png)\n\n이제 Quad-Tile 차트로 무엇을 더 할 수 있는지 알아봅시다.\n\n## 확장성\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n캔버스 레이아웃을 활용하는 원래의 목표를 표준 및 비표준 컨테이너와 함께 다시 살펴보겠습니다. 볼록 다각형과 간단한 오목 다각형을 수용할 수 있는 방법을 보여드렸고, 이제는 소개에서 소개된 레이아웃을 채워봤습니다. 각각 100개의 정사각형이 들어가는 컨테이너에 대해 다양한 회전을 적용했습니다.\n\n![image](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_24.png)\n\n가장 일반적인 캔버스 레이아웃은 직사각형 컨테이너일 것이므로, 원하는 종횡비를 간단하게 전달하는 것이 유용합니다. 다음은 너비를 다양하게 조절한 예시입니다 (높이 조절 방법도 동일합니다):\n\n```js\nfrom vizmath.quadtile_chart import polyquadtile as pqt\n\naspect_ratio = (1,1) #(2,1) (3,1) (4,1)\npqt_o = pqt.random_polyquadtile(100, constraints=[aspect_ratio], \n    rotate=45, collapse=True, buffer=.02)\npqt_o.polyquadtile_plot(color='quad', cw=0.75, opacity=.9)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_25.png)\n\nExtensibility의 또 다른 흥미로운 측면은 계층적 데이터를 포함하는 것입니다. 기존 방법의 일부 단점은 다음과 같습니다:\n\n- 중첩된 원은 레벨별로 정확한 상대적인 면적을 유지할 수 없습니다. 이를 위해 중첩된 Radial이나 Voronoi Treemaps가 필요합니다.\n- Treemaps는 상위 레벨에서 불규칙한 차원을 가질 가능성이 있습니다. (사각형, 원형, 또는 Voronoi일 경우)\n\nQuad-Tile Chart는 계층의 상위 수준을 유사한 모양으로 캡처하여 초기 크기 비교를 제공함으로써 두 번째 문제를 우아하게 처리할 수 있습니다.🌟\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n첫 번째 문제에 대해 말씀드리면, 중첩된 Quad-Tile Charts는 중첩된 패킹된 원(타일 섹션에서 언급된대로)과 동일한 단점을 가지고 있지만, 전통적인 직사각형 Treemaps(또는 Voronoi Treemaps)으로 나무 전체에 대한 정확한 면적을 유지하는 대안을 제공합니다. 중첩된 직사각형 Treemaps은 부모 정사각형의 변을 사용하여 보다 직관적인 자식 직사각형 비교를 할 수 있어 원하는 경우가 있습니다.\n\n다음 단계의 직사각형 Treemaps에 대한 예시 몇 가지를 함께 공유드리겠습니다. 상위 수준에 정사각형을 포함한 Quad-Tile Chart에 중첩된 이들을 제가 “Squaremaps”라고 부르겠습니다!\n\n![Squaremaps](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_26.png)\n\n제가 vizmath에서 Squaremaps에 대한 구현을 다음과 같이 작성했습니다(그리고 필요 시 계층적 데이터를 동적으로 생성하는 기능도 추가했습니다!):\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\r\nimport pandas as pd\nfrom vizmath.quadtile_chart import squaremap as sm\n\n# 랜덤한 스퀘어 맵 생성\no_sm1 = sm.random_squaremap(num_levels=3, items_range=(2,4), \n    value_range=(1,1000), sig=0.8)\no_sm1.o_squaremap.plot_levels(level=3, fill='w')\n\n# 계층적 데이터를 사용하여 스퀘어 맵 생성\ndata = [\n    ['a1', 'b1', 'c1', 9.3],\n    ['a1', 'b1', 'c2', 6.7],\n    ['a1', 'b1', 'c3', 2.4],\n    ['a1', 'b2', 'c1', 4.5],\n    ['a1', 'b2', 'c2', 3.1],\n\n    ['a2', 'b1', 'c1', 5.9],\n    ['a2', 'b1', 'c2', 32.3],\n    ['a2', 'b1', 'c3', 12.3],\n    ['a2', 'b1', 'c4', 2.3],\n    ['a2', 'b2', 'c1', 9.1],\n    ['a2', 'b2', 'c2', 17.3],\n    ['a2', 'b2', 'c3', 6.7],\n    ['a2', 'b2', 'c4', 4.4],\n    ['a2', 'b2', 'c5', 11.3],\n\n    ['a3', 'b1', 'c1', 7.5],\n    ['a3', 'b1', 'c2', 9.5],\n    ['a3', 'b2', 'c3', 17.1],\n\n    ['a4', 'b2', 'c1', 5.1],\n    ['a4', 'b2', 'c2', 2.1],\n    ['a4', 'b2', 'c3', 11.1],\n    ['a4', 'b2', 'c4', 1.5]]\ndf = pd.DataFrame(data, columns = ['a', 'b', 'c', 'value'])\no_sm2 = sm(df, ['a','b','c'], 'value', constraints=[(1,1)], buffer=.2)\no_sm2.o_squaremap.plot_levels(level=3, fill='w')\r\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_27.png\" /\u003e\n\n## Tableau Public Implementation\n\n파이썬에서 Quad-Tile Chart를 소개했으며 계층적 확장에 대한 Squaremap을 포함하였습니다. 이어서 Tableau Public (v 2023.3.1)에서 양쪽 모두를 구현하는 방법을 보여드리겠습니다! 우선 간단한 Squaremap 구현부터 시작하여 대화형으로 만드는 더 체계적인 Quad-Tile Chart 구축으로 넘어가보겠습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nTableau Public에서 Squaremap 구현\n\n더 자세한 안내를 위해서는, 저의 Radial Treemaps에 관한 글이 있습니다. 해당 글은 상호작용 가능한 계층을 만드는 방법에 대해 더 상세히 안내하며, 이를 위해 Squaremap과 동일한 그림 출력을 사용합니다! 지금은 임의의 입력을 생성하고 단순한 Tableau 예제에 대비한 그림 출력 데이터를 준비해보겠습니다.\n\n```js\nfrom vizmath.quadtile_chart import squaremap as sm\n\n# 임의의 계층 데이터 생성 및 Squaremap 작성\no_sm = sm.random_squaremap(num_levels=3, num_top_level_items=120,\n    items_range=(2,4), value_range=(1,10), sig=0.75, \n    collapse=True, buffer=0.05)\n# 초기 플롯 검토\no_sm.o_squaremap.plot_level(level=3)\n# 출력의 미리보기 (그림 데이터)\no_sm.o_squaremap.df_rad_treemap.head(10)\n# 데이터로 그림 객체 설정\no_sm.o_squaremap.o_rad_treemap.df = o_sm.o_squaremap.df_rad_treemap\n# Tableau에서 지도 레이어를 활용하기 위한 데이터 재조정\no_sm.o_squaremap.o_rad_treemap.dataframe_rescale(\n    xmin=-5, xmax=5, ymin=-5, ymax=5)\n# 데이터를 csv로 작성\no_sm.o_squaremap.o_rad_treemap.dataframe_to_csv('squaremap')\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_28.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테이블 태그를 Markdown 형식으로 변경해주세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- [Group]을 Marks 아래 Detail로 드래그하세요.\n- Marks 드롭다운 메뉴에서 Polygon을 선택하세요 (이 시점에서 이상하게 보인다고 걱정하지 마세요).\n- [Path]를 Marks 아래 Path로 드래그하고 현재 SUM(Path)인 항목을 우클릭하여 Dimension으로 선택하세요.\n- [Value]를 Color로 드래그하고 Dimension으로 변환하는 작업을 반복하세요.\n- Color 아래에서 \"색상 편집...\"을 선택하고 다음 옵션으로 구성하세요: '반전, 고급: (시작: 0, 끝: 10)'\n\n이제 더 재미를 위해 더 한 개의 레이어를 추가하여 색상을 변경해 봅시다:\n\n- [Treemap]을 지도 영역으로 드래그하면 팝업이 나타납니다: Marks 레이어 추가 - 이를 클릭하여 새로운 지도 레이어를 생성하세요.\n- 위의 단계를 반복하되 이제 [Side]를 Color로 사용하세요.\n- Color 아래에서 검은 테두리를 선택하고 투명도를 15%로 설정하세요.\n\n이제 아래와 유사한 차트가 나타날 것입니다 (입력의 무작위성으로 인해 고유한 것이 될 것입니다!). 이제 [Level]로 필터링하거나 필요에 맞는 상호 작용을 설정할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_29.png) \n\n이 Squaremap 구현이 당신의 계층적 데이터를 더 자세히 탐색하는 데 유용한 시작점이 되길 바랍니다!\n\nTableau Public에서 Quad-Tile Chart 구현\n\n이제 더 자세한 Quad-Tile Chart 구현에 초점을 맞추고 Tableau Public에서 상호작용형 시각화를 만들어 보겠습니다. 강 체계에 대한 위키피디아 데이터 일부로 시작해서 파일에 저장해보죠.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport pandas as pd\n\n# 위키백과에서 (2024년 1월 26일 기준) 상위 50개의 강 시스템 목록\n# https://en.wikipedia.org/wiki/List_of_river_systems_by_length\ndata = {\n    '강' : [str(i) for i in range(1, 51)],\n    '길이_km' : [\n        6650,6400,6300,6275,5539,5464,5410,4880,4700,4444,4400,4350,4241,\n        4200,3969,3672,3650,3645,3610,3596,3380,3211,3185,3180,3078,3060,\n        3058,3057,2989,2888,2809,2740,2720,2704,2620,2615,2570,2549,2513,\n        2500,2490,2450,2428,2410,2348,2333,2292,2287,2273,2270],\n    '길이_m' : [\n        4130,3976,3917,3902,3445,3395,3364,3030,2922,2763,2736,2705,2637,\n        2611,2466,2282,2270,2266,2250,2236,2100,1995,1980,1976,1913,1901,\n        1900,1900,1857,1795,1745.8,1703,1700,1690,1628,1625,1597,1584,\n        1562,1553,1547,1522,1509,1498,1459,1450,1424,1421,1412,1410],\n    '배수지역_km2' : [\n        3254555,7000000,1800000,2980000,2580000,745000,2990000,2582672,\n        3680000,1855000,2490000,810000,1790000,2090000,712035,1061000,\n        950000,1380000,960000,884000,1485200,63166,850000,610000,219000,\n        324000,1030000,570000,473000,817000,404200,1330000,454000,1024000,\n        534739,242259,1093000,900000,644000,270000,1547,1522,1509,1498,\n        1459,1450,1424,1421,1412,1410],\n    '평균유출량_m3_s' : [\n        2800,209000,30166,16792,18050,2571,12475,22000,41800,11400,15500,\n        16000,10300,5589,19800,767,13598,8080,7160,856,31200,8400,6210,\n        3300,703,3153,10100,82,3600,7130,13000,4880,1480,12037,1400,6000,\n        2575,4300,3800,270000,1547,1522,1509,1498,1459,1450,1424,1421,\n        1412,1410],\n    '방출지' : [\n        '지중해','대서양','동해','멕시코만',\n        '카라해','보해','오블만','리오데라플라타',\n        '대서양','오호츠크해','랩테프해','남중국해',\n        '보퍼트해','기니만','간지스','남쪽의해',\n        '대서양(마라조 만), 아마존 델타','카스피해',\n        '아라비아해','페르시아만','아마존','아마존','베링해',\n        '대서양','아랄해','안다만해','세인트로렌스만',\n        '멕시코만','예니세이강','흑해','안다만해',\n        '모잠비크해협','레나강','벵갈만','아랄해','아마존',\n        '헛슨만','파라나강','동시베리아해','파라과이강','옵강','이르티시강',\n        '카스피해','아마존','미시시피강','캘리포니아만',\n        '랩테프해','흑해','레나강','콩고'],\n    '이름': [\n        '나일–화이트나일–카게라–냐바롱고–모고고–루카라라',\n        '아마존–우카야리–탐보–에네–만타롤',\n        '창강–금샤강–통티안강–당쿠강 (장강)',\n        '미시시피–미주리–제퍼슨–비버헤드–레드락–헬로링',\n        '예니세이강–앙가라강–셀렝가강–이더','황허강',\n        '오블강–이르티시강','리오데라플라타–파라나강–리오그란데',\n        '콩고강–잠베시 (자이료)',\n        '두문강–아르군강–헤를런 (흑룽강)','레나강','메콩 (랑창강)',\n        '맥케너지강–스레이브강–피스강–핀레이','니제르강','브라마푸트라–얀룽창포',\n        '머리–달링–컬고아–발론–콘다믄','토칸찐스–아라구아이아',\n        '볼가','인다스–생거 장보','샤트알아랍–유프라테스–무랏',\n        '마데이라–마모레–그랜데–케인–로차','푸르스','유곤','상프란시스코',\n        '시르다리야–나린','살윈 (누강)',\n        '세인트로렌스–나이아가라–디트로이트–세인트클레어–세인트\\\n        메리스–세인트루이스–노스 (그레이트레이크스)','리오그란데','하횡강',\n        f\"도나우–브렉','두네르','두롱강–납마이강–둘롱강–케라올올루–가다쿠\",\n        '잠베지 (잠베지)','빌류이','간지스–후글리–팜다 (강가)',\n        '아무다리아–판즈','자푸라 (까퀘타)','넬슨–사스카추완',\n        '파라과이 (리오파라과이)','콜룸마','필코마요','상횡강–카툰',\n        '이심','우랄','주루아','아칸소어스','콜로라도 (미 서부)',\n        '올레니오크','드니프르','알단','우방기–우엘']\n}\n\ndf = pd.DataFrame(data)\ndf.to_csv('강_시스템.csv')\n```\n\n길이 (\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이것은 좋아 보이네요. Tableau에서 지도 레이어를 활용하기 위해 차트 다각형 및 중심점의 출력 데이터를 저장해봅시다. 나중에 사용할 삼각형의 좌표도 출력하여 나준합니다.\n\n```js\n# 출력 파일 (Tableau에서 지도 레이어를 활용하기 위해 데이터 재조정)\n\n# Quad-Tile 차트 다각형 출력\no_pqt.o_polyquadtile_chart.dataframe_rescale(-3,3,-2,4)\no_pqt.o_polyquadtile_chart.df = pd.merge(\n    o_pqt.o_polyquadtile_chart.df, df, left_on='item', right_on='river')\no_pqt.o_polyquadtile_chart.df = o_pqt.o_polyquadtile_chart.df[\n    ['river','side','x','y','path','length_km','length_m',\n    'drainage_area_km2','average_discharge_m3_s','outflow','name']]\no_pqt.o_polyquadtile_chart.dataframe_to_csv('quadtile')\n\n# Quad-Tile 차트 중심점 출력\no_pqt.o_polysquares.dataframe_rescale(-3,3,-2,4)\no_pqt.o_polysquares.df = pd.merge(\n    o_pqt.o_polysquares.df, df, left_on='id', right_on='river')\no_pqt.o_polysquares.df = o_pqt.o_polysquares.df[\n    ['river','side','x','y','length_km','length_m',\n    'drainage_area_km2','average_discharge_m3_s','outflow','name']]\no_pqt.o_polysquares.dataframe_to_csv('quadtile_centroids')\n\n# 삼각형 컨테이너 좌표\npoly = o_pqt.constraints\nrs_poly_yx = [(vf.rescale(y, -2, 4, -1, 1),\n    vf.rescale(x, -3, 3, -1, 1)) for x,y in poly]\nprint(rs_poly_yx)\n# 결과:\n# [(-0.691813852924281, -0.9166666666666669), \n# (0.8615194804090525, 0.0), \n# (-0.691813852924281, 0.9166666666666667)]\r\n```\n\n마지막으로, 상호 작용을 더 활성화하기 위해 범례를 생성해봅시다.\n\n```js\r\n#%% 범례 플롯\ndf_legend = df.groupby('outflow')['name'].count().reset_index()\no_pqt_legend = pqt(df_legend,'outflow','name', \n    constraints=[(4,1)], collapse=True,\n    rotate=45, buffer=.1, size_by='width', sides=['top','right'])\no_pqt_legend.polyquadtile_plot(show_constraints=True)\n\n#%% 범례 데이터\no_pqt_legend.o_polyquadtile_chart.dataframe_rescale(-2,6,-4,4)\no_pqt_legend.o_polyquadtile_chart.df = pd.merge(\n    o_pqt_legend.o_polyquadtile_chart.df, df_legend, \n    left_on='item', right_on='outflow')\no_pqt_legend.o_polyquadtile_chart.df = o_pqt_legend.o_polyquadtile_chart.df[\n    ['outflow','side','x','y','path','name']]\no_pqt_legend.o_polyquadtile_chart.dataframe_to_csv('quadtile_legend')\r\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![그림](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_31.png)\n\n이제 Tableau를 준비했으니, 다음 3개 파일을 모두 가져오기 위해 텍스트 파일 옵션을 사용하여 시작해보겠습니다. Sheet 1로 이동한 다음, 상단 왼쪽 데이터 탭에서 쿼드타일 데이터 소스를 선택하고 다음과 같은 계산 열을 생성하세요:\n\n먼저 맵 영역에서 마우스를 오른쪽 클릭하여 배경 레이어를 선택하고 다음 옵션을 조정해보세요:\n\n- 모든 배경 맵 레이어 (베이스, 랜드 커버 등)을 선택 해제하세요.\n- 이제 맵 영역에서 마우스를 오른쪽 클릭하고 맵 옵션을 선택한 다음, 패널에서 모든 옵션을 선택 해제하세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n배경 레이어를 닫고 다음 단계를 계속해 보세요:\n\n- [Side]를 Marks 하위에 Detail로 드래그합니다.\n- Marks 드롭다운 메뉴에서 Polygon을 선택합니다.\n- Color 하위에서 검은색 테두리 색상을 선택하고 불투명도를 40%로 조절한 다음 색상을 연한 파랑색으로 설정합니다.\n\n다음으로, 사각형에 대한 윤곽선 레이어를 추가해 봅시다:\n\n- [Squares]를 맵 영역으로 드래그하면 팝업이 나타납니다: Marks 레이어 추가 - 이를 클릭하여 새 맵 레이어를 만듭니다.\n- 팝업 메뉴에서 드롭다운 메뉴를 통해 필드를 'Outlines'로 이름을 변경합니다.\n- [River]를 이 새로운 맵 레이어의 Marks 하위 Detail로 드래그합니다.\n- Marks 드롭다운 메뉴에서 Line을 선택합니다 (이 시점에서 이상하게 보인다 해도 걱정하지 마세요).\n- [Path]를 Marks 하위 Path로 드래그하고 차원으로 변환하는 프로세스를 반복합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n메인 스퀘어 레이어에 대해 Marks 드롭다운 메뉴에서 Polygon을 선택하여 새 레이어에 대해 위 과정을 반복하고, [Drainage Area Km2]로 색을 입힙니다. '시작: 0, 끝: 3,000,000'으로 설정해주세요.\n\n마지막으로, 데이터 탭에서 quadtile_centroids를 선택하여 중심점을 사용하는 레이어를 추가하고, 다음과 같은 계산된 열을 추가해주세요:\n\nTableau에서 올바른 크기 조정을 위해 길이를 제곱한 것을 알 수 있습니다. 이를 다음 단계에서 사용할 것입니다:\n\n- [Centroids]를 지도 영역으로 드래그하면 팝업이 표시됩니다: Marks 레이어 추가 - 피말을 해당 위치에 드래그하여 새 지도 레이어를 생성합니다.\n- 이 새 지도 레이어에서 Marks 아래 Detail로 [River]를 드래그합니다.\n- Marks 드롭다운 메뉴에서 Circle을 선택합니다.\n- [Size]를 Marks 아래 Size로 드래그하고 이를 차원으로 변환하는 과정과 크기 틱을 두 번째 해시로 설정합니다.\n- [Average Discharge M3 S]를 Color로 드래그하고 하얀 테두리를 추가하고 '시작: 0, 끝: 50,000'으로 설정해주세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n오른쪽 하단에 널 경고 표시가 나타납니다. 이를 마우스 오른쪽 단추로 클릭하고 숨김 표시를 선택할 수 있습니다. 이 시점에서 상호작용 및 레이블을 나중에 구현하기 위해 아래에 표시된 몇 가지 다른 세부 정보와 속성을 추가한 것처럼 보일 것입니다:\n\n![image](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_32.png)\n\n이제 대시보드의 소스 자료를 완성하기 위해 세 개의 시트를 추가해 보겠습니다. 설정을 위해 이미지를 참조하십시오.\n\n- \"Bars\" - quadtile_centroids 데이터 소스를 사용します.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![이미지](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_33.png)\n\n- “범례” - quadtile_legend 데이터 소스 사용\n\n![이미지](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_34.png)\n\n- “강” - quadtile_centroids 데이터 소스 사용, [이름]을 '정렬 기준: 필드, 정렬 순서: 내림차순, 필드 이름: [길이 Km], 집계: 최대값'으로 정렬 ('이름' 항목을 오른쪽 클릭하여 정렬... 선택)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_35.png\" /\u003e\n\n마지막 단계로, 이제 4개의 시트를 대시보드에 정리하고 대시보드 `동작` 아래의 상단 메뉴에서 몇 가지 동작을 설정해보겠습니다. 대시보드 `동작` 아래의 추가 동작 드롭다운을 클릭하고 `하이라이트`를 선택합니다. 대상 하이라이트에서 `선택한 필드`를 선택하고 [Outflow]과 [River] 필드를 선택합니다 ([Outflow]가 상기 시트에 세부사항으로 추가되었는지 확인). 마지막으로 오른쪽 상단의 `실행 동작` 아래에서 `가리키기` 옵션을 선택합니다.\n\n마지막 동작으로 추가 동작 드롭다운을 클릭하고 다음 옵션을 사용하여 필터를 선택합니다: '소스 시트: 범례, 대상 시트: 강, 선택한 필드: Outflow `quadtile_centroids` Outflow, 실행 동작: 선택시 실행, 선택 해제 시 모든 값 제외'. 이제 대시보드는 모든 시트에서 요청시 하이라이트를 표시하고 범례 시트에서 선택된 값에 대해 필터를 제외할 것입니다!\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1200/1*4CSKItCTjLiMaB7s09zolQ.gif\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 결론\n\n이 글에서 우리는 정방형이 원에 비해 채워진 도형 시각화에서 어떻게 성능을 발휘할 수 있는지 알아보기 위한 여정을 떠났습니다. 저희는 정방형의 적용을 테스트하기 위해 고수준 비교를 위한 최적화 프레임워크를 구현했고, 결국 정방형의 잠재력을 최대한 활용하기 위해 사용자 정의 알고리즘을 활용하기로 결정했습니다.\n\n저는 \"쿼드-타일 차트\"라고 명명한 것에 대한 상세한 안내서를 제공합니다. 이 차트는 값 세트를 시각화하는 데 사용되며, 또한 값 ​​계층 구조를 시각화하거나 시각화 캔버스의 사용 가능한 공간을 고려해 원하는 다각형 컨테이너 내에 정방형을 패킹하는 기능을 제공하는 \"스퀘어맵\"으로 확장됩니다.\n\n현재 데이터 시각화 공간에서 사용되는 주요 원 패킹 구현과는 다르게 다각형 컨테이너는 주요 장점으로 작용하며, Squaremap을 통해 계층 데이터는 새로운 집을 찾을 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n가능하면, Quad-Tile Chart의 사각형 배열은 시각적으로 매력적으로 보입니다 (원과 경쟁하기 위해 필수적입니다!) 그리고 사각형은 원의 중심에 배치된 원들과 서로 바꿔 쓸 수 있습니다 (반응형인 Bubble Chart를 위해) 이것은 데이터를 사각형으로 구성하는 경향을 정당화하기 위한 우리의 노력의 승리로 결론내릴 수 있습니다.\n\n각종 데이터 시리즈와 계층이 모든 코너를 도발하고 있을 때, 여러분이 이러한 시각화 기술을 데이터 탐색 여정에서 유용한 도구로 활용하길 바랍니다!\n\n## 참고 자료\n\n본 문서에 포함된 모든 이미지는 별도로 명시하지 않은 한 저자가 제작했습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n[1] 위키백과 (CC BY-SA), “최고의 빠른 동물” (기준일: 2024년 1월 26일)\n\n[2] 위키백과 (CC BY-SA), “길이별 강 시스템 목록” (기준일: 2024년 1월 26일)\n\n관련 기사\n\n- 복잡한 집합 관계를 시각화하는 Multi-Chord Diagram 소개","ogImage":{"url":"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_0.png","tag":["Tech"],"readingTime":59},{"title":"FB Prophet과 하이퍼파라미터 최적화를 사용한 BTC-USD 가격 예측, 교차 검증 QC, 수정된 알고리즘 거래 전략","description":"","date":"2024-07-13 19:54","slug":"2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies","content":"\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_0.png\" /\u003e\n\n- 본 글은 이전 연구를 이어가며, Python에서 Facebook의 Prophet을 활용한 BTC-USD 가격 예측에 대한 자세한 프레임워크를 개발하는 것을 목표로 합니다 [1–5] (참고 문헌).\n- 현재의 비교 분석은 시간 시리즈 교차 검증 QC를 기반으로 한 히스토리컬 데이터를 사용하여 예측 오차를 측정하는 HPO 또는 모델 튜닝에 대해 자세히 살펴봅니다.\n- 시뮬레이션된 BTC 예측에 추가되어, FB Prophet을 사용하여 크립토 알고트레이딩 전략을 최적화하는 방법에 대해 Buy \u0026 Hold 기준과 비교하여 설명합니다. 자세한 내용은 여기에서 확인하세요.\n\n## 비즈니스 케이스\n\n- 적절한 암호화폐 예측은 크립토 트레이더들에게 큰 이익을 가져다줄 수 있으며 효과적인 리스크 관리를 제공할 수 있습니다.\n- 최근 BTC는 많은 가격 예측의 주제가 되었습니다.\n- CoinCodex: BTC의 역사적인 가격 변동과 BTC 하프 사이클을 기반으로, BTC가 상한 가격 대상에 도달한다면 2025년까지 201.59%의 이익을 올릴 수 있습니다. 한편, BTC의 가격은 내년에 $173,833까지 상승할 것으로 예측됩니다.\n- 하지만 비트코인 가격이 2030년까지 1백만 달러에 도달할까요?\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## FB Prophet에 대해\n\n- FB Prophet은 추세/계절성 모델링과 베이지안 추론에 기초한 시계열 데이터 예측 절차입니다.\n- 강한 계절 효과가 있는 시계열에 가장 적합하며, 누락 된 데이터, 이상치 및 추세 변동에 견고합니다.\n- 예측 모델은 다음과 같은 4가지 구성 요소로 구성됩니다: 추세(장기간 동안의 변화), 계절성(주기적 또는 단기 변화), 휴일 및 특정 비즈니스에만 해당되는 조건부 변경 사항.\n- 새로운 사용자에게 특히 흥미롭습니다. 모델의 하이퍼파라미터를 자동으로 찾아내는 능력과 쉬운 사용성으로 유명합니다.\n- 추가적인 회귀 변수, 곱셈 계절성, 비일일 데이터, 불확실성 측정 및 진단이 포함됩니다.\n\n이 라이브러리를 사용하여 BTC-USD 가격 예측의 구체적 내용을 살펴봅시다.\n\n## 주요 설치 방법\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- pip은 저희가 선호하는 설치 프로그램입니다. Python 3.4부터 Python 이진 설치 프로그램에 기본적으로 포함되어 있습니다.\n- Jupyter Notebook을 실행하고 필수 Python 라이브러리를 설치합니다.\n\n```python\n!pip install statsmodels, math, yfinance, prophet, plotly,matplotlib, itertools\n```\n\n## Imports \u0026 Settings\n\n- 코드를 성공적으로 실행할 수 있도록 필요한 라이브러리 및 종속성이 제대로 설치되어 있는지 확인하세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport pandas as pd\nimport plotly.express as px\nimport requests\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom math import floor\nfrom termcolor import colored as cl\nimport yfinance as yf\nimport datetime\nfrom datetime import date, timedelta\n\n# Prophet 라이브러리 불러오기\nfrom prophet import Prophet\n\nplt.rcParams['figure.figsize'] = (12, 6)\nplt.style.use('fivethirtyeight')\n\nimport os\nos.chdir('작업경로')    # 작업 디렉토리 설정\nos.getcwd()\n```\n\n## 주식 데이터 입력\n\n- 730일의 BTC-USD 이력 데이터 입력\n\n```js\ntoday = date.today()\n\nd1 = today.strftime(\"%Y-%m-%d\")\nend_date = d1\nd2 = date.today() - timedelta(days=730)\nd2 = d2.strftime(\"%Y-%m-%d\")\nstart_date = d2\n\ndata = yf.download('BTC-USD', \n                      start=start_date, \n                      end=end_date, \n                      progress=False)\ndata[\"Date\"] = data.index\ndata = data[[\"Date\", \"Open\", \"High\", \"Low\", \"Close\", \"Adj Close\", \"Volume\"]]\ndata.reset_index(drop=True, inplace=True)\ndata.tail()\n\n|   Date    |    Open    |    High    |   Low    |   Close    |  Adj Close  |   Volume      |\n|----------|------------|------------|---------|------------|-------------|--------------|\n|2024-07-02| 62,844.41  | 63,203.36  | 61,752.75|   62,029.02 |  62,029.02  |  20151616992  |\n|2024-07-03| 62,034.33  | 62,187.70  | 59,419.39|   60,173.92 |  60,173.92  |  29756701685  |\n|2024-07-04| 60,147.14  | 60,399.68  | 56,777.80|   56,977.70 |  56,977.70  |  41149609230  |\n|2024-07-05| 57,022.81  | 57,497.15  | 53,717.38|   56,662.38 |  56,662.38  |  55417544033  |\n|2024-07-06| 56,659.07  | 58,472.55  | 56,038.96|   58,303.54 |  58,303.54  |  20610320577  |\n```   \n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 종가 그래프 그리기\n\n```js\nplt.plot(data['Date'], data['Close'])\nplt.xlabel('날짜')\nplt.ylabel('종가(USD)')\nplt.title('BTC-USD 종가')\n```\n\n![BTC-USD Close Price](/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_1.png)\n\n## 데이터 준비\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Box Cox 변환을 사용하여 비정규적인 종속 변수인 Close 가격을 정규분포 형태로 변환합니다.\n\n```js\n### Box Cox 변환\nfrom statsmodels.base.transform import BoxCox\n\nbc = BoxCox()\ndata[\"Close\"], lmbda = bc.transform_boxcox(data[\"Close\"])\n```\n\n- Prophet에 입력 데이터 만들기\n\n```js\ndata1 = data[[\"Date\", \"Close\"]]\ndata1.columns = [\"ds\", \"y\"]\n\ndata1.tail()\n\n    ds          y\n725 2024-07-02 42.381398\n726 2024-07-03 42.086488\n727 2024-07-04 41.560999\n728 2024-07-05 41.507898\n729 2024-07-06 41.781750\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Prophet에 입력해야 하는 것은 항상 ds와 y 두 개의 열이 있는 데이터프레임입니다. ds (날짜) 열은 Pandas에서 예상하는 형식이어야 합니다. 날짜의 경우 YYYY-MM-DD이고, 타임스탬프의 경우 YYYY-MM-DD HH:MM:SS입니다. y 열은 숫자이어야 하며, 예측하려는 측정 값을 나타냅니다.\n\n## Max Cap과 5% 표준편차를 사용한 Prophet\n\n- 매년 곱셈 계절성과 로지스틱 성장이 있는 모델 매개변수 목록을 생성합니다.\n\n```js\nmodel_param = {\n    \"daily_seasonality\": False,\n    \"weekly_seasonality\": False,\n    \"yearly_seasonality\": True,\n    \"seasonality_mode\": \"multiplicative\",\n    \"growth\": \"logistic\"\n}\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 기본적으로 Prophet은 가법 계절성 모델을 적합시키며, 계절성의 영향이 예측을 얻기 위해 추세에 더해집니다. 위 모델에서 계절성은 Prophet이 가정한 것처럼 일정한 가법적 요소가 아니라 추세와 함께 증가하는 다중 계절성입니다.\n- 기본적으로 Prophet은 예측을 위해 선형 모델을 사용합니다. 성장을 예측할 때 일반적으로 일정한 최대 달성 가능 지점이 있습니다: 총 시장 규모 등. 이를 운반 용량이라고하며, 예측은 이 지점에서 포화되어야 합니다. Prophet은 지정된 운반 용량을 갖춘 로지스틱 성장 트렌드 모델을 사용하여 예측을 수행할 수 있습니다.\n- 모델 실행\n\n```js\nmodel = Prophet(**model_param)\n```\n\n- 로지스틱 성장을 사용하기 때문에 예측에 대한 상한선 또는 상한 값을 설정합니다. 상한값은 가격의 최대값에 표준편차의 5%를 더하는 것입니다.\n\n```js\ndata1['cap'] = data1[\"y\"].max() + data1[\"y\"].std() * 0.05\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 모델을 맞추는 중\n\n```js\nmodel.fit(data1)\n```\n\n- 위의 캡을 사용하여 샘플 내부 및 1년 장기 예측 생성\n\n```js\nfuture= model.make_future_dataframe(periods=365)\n\nfuture['cap'] = data1['cap'].max()\n\nforecast= model.predict(future)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 중요한 구성 요소를 사용하여 (ds-y) 도메인 예측을 플로팅합니다.\n\n```js\nmodel.plot(forecast,figsize=(14, 8))\n```\n\n![BTC-USD 가격 예측](/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_2.png)\n\n```js\nmodel.plot_components(forecast,figsize=(16, 10));\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이전에 사용하던 table tag를 Markdown 형식으로 변경해보세요.\n\n## Prophet with Monthly/Quarterly Seasonality \u0026 US Holidays\n\n- Prophet를 월별/분기별 계절성 및 미국 공휴일과 함께 실행 중\n\n```js\nmodel = Prophet(**model_param)\n\nmodel.add_seasonality(name=\"monthly\", period=30, fourier_order=10)\nmodel.add_seasonality(name=\"quarterly\", period=92.25, fourier_order=10)\n\nmodel.add_country_holidays(\"US\")\n\nmodel.fit(data1)\n\n# 미래 데이터프레임 생성\nfuture = model.make_future_dataframe(periods=365)\nfuture['cap'] = data1['cap'].max()\n\nforecast = model.predict(future)\n\nfrom prophet.plot import plot\n\nplot(model, forecast, figsize=(14, 8))\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nfrom prophet.plot import plot_components\n\nplot_components(model, forecast, figsize=(10, 12))\n```\n\n위의 코드 블록은 Prophet 모델을 사용하여 예측한 데이터의 구성요소를 시각화하는 부분입니다. 코드를 실행하여 예측 결과를 확인해보세요! 🚀\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 원래 가격을 얻기 위해 역 Box-Cox 변환을 수행합니다\n\n```js\nforecast[\"yhat\"]=bc.untransform_boxcox(x=forecast[\"yhat\"], lmbda=lmbda)\nforecast[\"yhat_lower\"]=bc.untransform_boxcox(x=forecast[\"yhat_lower\"], lmbda=lmbda)\nforecast[\"yhat_upper\"]=bc.untransform_boxcox(x=forecast[\"yhat_upper\"], lmbda=lmbda)\nforecast.plot(x=\"ds\", y=[\"yhat_lower\", \"yhat\", \"yhat_upper\"])\n```\n\n![BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_7](/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_7.png)\n\n- 수동으로 선택한 cutoff를 사용하여 예측 성능의 몇 가지 유용한 통계를 계산합니다\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nfrom prophet.diagnostics import cross_validation, performance_metrics\nfrom prophet.plot import plot_cross_validation_metric\ndf_cv = cross_validation(model, initial=\"600 days\", period=\"30 days\", horizon=\"90 days\")\ncutoffs = pd.to_datetime(['2022-09-01', '2023-05-01', '2024-03-01'])\ndf_cv2 = cross_validation(model, cutoffs=cutoffs, horizon='90 days')\nfig = plot_cross_validation_metric(df_cv2, metric='rmse')\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_8.png\" /\u003e\n\n- 성능 메트릭 요약 정보 출력\n\n```js\ndf_p = performance_metrics(df_cv2)\ndf_p.head()\n\n    horizon mse      rmse       mae       mape     mdape   smape coverage\n0 9 days 3805.462369 61.688430 29.520999 0.893692 0.118312 0.355870 0.0\n1 10 days 5382.793620 73.367524 37.768231 1.140719 0.168333 0.425770 0.0\n2 11 days 6754.735216 82.187196 45.409934 1.368028 0.286148 0.491224 0.0\n3 12 days 7678.053041 87.624500 51.465541 1.551664 0.352840 0.546114 0.0\n4 13 days 8071.329465 89.840578 55.027843 1.658574 0.426625 0.584601 0.0\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- MAPE 그래프 그리기\n\n```js\nfig = plot_cross_validation_metric(df_cv2, metric='mape')\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_9.png\" /\u003e\n\n- MAE 그래프 그리기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nfig = plot_cross_validation_metric(df_cv2, metric='mae')\n```\n\n![BTC-USD Price Prediction using FB Prophet with Hyperparameter Optimization Cross-Validation QC Modified Algorithm Trading Strategies](/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_10.png)\n\n## Hyperparameter Optimization (HPO)\n\n- Running HPO by adding monthly/quarterly seasonality and US holidays\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nrmses = list()\n\n# 각 조합을 순회합니다.\nfor params in all_params:\n    m = Prophet(**params)\n    \n    m = m.add_seasonality(name='monthly', period=30, fourier_order=5)\n    m = m.add_seasonality(name='quarterly', period=92.25, fourier_order=10)\n\n    m.add_country_holidays(country_name='US')\n    \n    m.fit(data1)\n    \n    df_cv = cross_validation(m, initial='500 days', period='180 days', horizon='90 days')\n    \n    df_p = performance_metrics(df_cv, rolling_window=1)\n    \n    rmses.append(df_p['rmse'].values[0])\n    \n# 최적의 매개변수를 찾습니다.\nbest_params = all_params[np.argmin(rmses)]\n    \nprint(\"\\n최적의 매개변수는:\", best_params)\n```\n\n- 최적화된 모델을 피팅하고 해당하는 예측 생성\n\n```js\nmodel_param1 = {\n    'daily_seasonality': False,\n    'weekly_seasonality': False,\n    'yearly_seasonality': True,\n    'seasonality_mode': 'multiplicative',\n    'growth': 'logistic',\n    'seasonality_prior_scale': 0.1,\n    'changepoint_prior_scale': 0.01\n}\n\nmodel1 = Prophet(**model_param1)\n\nmodel1.add_country_holidays('US')\n\nmodel1.fit(data1)\n\n# 향후 데이터 프레임 생성\nfuture = model1.make_future_dataframe(periods=365)\nfuture['cap'] = data1['cap'].max()\n\nforecast = model1.predict(future)\n```\n\n- 원래 가격을 얻기 위해 역 Box-Cox 변환을 적용합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n js\nforecast[\"yhat\"]=bc.untransform_boxcox(x=forecast[\"yhat\"], lmbda=lmbda)\nforecast[\"yhat_lower\"]=bc.untransform_boxcox(x=forecast[\"yhat_lower\"], lmbda=lmbda)\nforecast[\"yhat_upper\"]=bc.untransform_boxcox(x=forecast[\"yhat_upper\"], lmbda=lmbda)\nforecast.plot(x=\"ds\", y=[\"yhat_lower\", \"yhat\", \"yhat_upper\"])\n\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_11.png\" /\u003e\n\n- 수동 cutoff로 교차 검증 QC 실행 중\n\n```js\ncutoffs = pd.to_datetime(['2022-09-01', '2023-05-01', '2024-03-01'])\ndf_cv2 = cross_validation(model1, cutoffs=cutoffs, horizon='90 days')\nfig = plot_cross_validation_metric(df_cv2, metric='rmse')\n``` \n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_12.png)\n\n\n```js\nfig = plot_cross_validation_metric(df_cv2, metric='mape')\n```\n\n![image](/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_13.png)\n\n```js\nfig = plot_cross_validation_metric(df_cv2, metric='mae')\n``` \n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![BTC-USD Price Prediction](/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_14.png)\n\n## 2020년부터 2024년까지 BTC-USD 역사적 데이터 준비\n\n- 박스-콕스(Box-Cox) 변환을 하지 않고 2020년 01월 01일부터 2024년 07월 07일까지의 BTC-USD 역사적 데이터를 준비합니다.\n\n```js\nimport pandas as pd\nimport numpy as np\nfrom prophet import Prophet\nimport matplotlib.pyplot as plt\nfrom functools import reduce\n\n%matplotlib inline\nimport warnings\nwarnings.filterwarnings('ignore')\n\npd.options.display.float_format = \"{:,.2f}\".format\n\nimport yfinance as yf\n\nticker = 'BTC-USD'\nstart_date = '2020-01-01'\n\nstock_price = yf.download(ticker, start=start_date)\nstock_price[\"날짜\"] = stock_price.index\nstock_price.tail()\n\n           Open      High      Low       Close    Adj Close   Volume      날짜\nDate       \n2024-07-03 62,034.33 62,187.70 59,419.39 60,173.92 60,173.92 29756701685 2024-07-03\n2024-07-04 60,147.14 60,399.68 56,777.80 56,977.70 56,977.70 41149609230 2024-07-04\n2024-07-05 57,022.81 57,497.15 53,717.38 56,662.38 56,662.38 55417544033 2024-07-05\n2024-07-06 56,659.07 58,472.55 56,038.96 58,303.54 58,303.54 20610320577 2024-07-06\n2024-07-07 58,239.43 58,367.18 56,644.89 57,198.04 57,198.04 19585976320 2024-07-07\n\nstock_price = stock_price[['날짜','Adj Close']]\n\nstock_price.columns = ['ds', 'y']\nstock_price.tail()\n\n           ds          y\nDate  \n2024-07-03 2024-07-03 60,173.92\n2024-07-04 2024-07-04 56,977.70\n2024-07-05 2024-07-05 56,662.38\n2024-07-06 2024-07-06 58,303.54\n2024-07-07 2024-07-07 57,198.04\n```\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 기본 Prophet 모델을 적합시키고 2027년 7월 7일까지의 예측을 생성합니다.\n\n```js\nmodel = Prophet()\nmodel.fit(stock_price)\nfuture = model.make_future_dataframe(1095, freq='d')\n\nfuture_boolean = future['ds'].map(lambda x : True if x.weekday() in range(0, 5) else False)\nfuture = future[future_boolean] \n\nfuture.tail()\nds\n2738 2027-07-01\n2739 2027-07-02\n2742 2027-07-05\n2743 2027-07-06\n2744 2027-07-07\n\nforecast = model.predict(future)\n#forecast.tail()\n\nmodel.plot(forecast);\r\n```\n\n![BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_15](/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_15.png)\n\n- 주요 구성 요소를 플롯합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\nmodel.plot_components(forecast);\n\n\n![Forecast Plot](/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_16.png)\n\n- 원래 가격과 예측을 신뢰 구간과 함께 그래픽으로 표시합니다.\n\n```python\nstock_price_forecast = forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']]\ndf = pd.merge(stock_price, stock_price_forecast, on='ds', how='right')\ndf.set_index('ds').plot(figsize=(16,8), color=['royalblue', \"#34495e\", \"#e74c3c\", \"#e74c3c\"], grid=True);\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_17.png)\n\n- Date 열을 3 부분(연/월/일)으로 분할하고 Prophet 모델을 fitting합니다.\n\n```python\nstock_price['dayname'] = stock_price['ds'].dt.day_name()\nstock_price['month'] = stock_price['ds'].dt.month\nstock_price['year'] = stock_price['ds'].dt.year\nstock_price['month/year'] = stock_price['month'].map(str) + '/' + stock_price['year'].map(str) \n\nstock_price = pd.merge(stock_price, \n                       stock_price['month/year'].drop_duplicates().reset_index(drop=True).reset_index(),\n                       on='month/year',\n                       how='left')\n\nstock_price = stock_price.rename(columns={'index':'month/year_index'})\n\nloop_list = stock_price['month/year'].unique().tolist()\nmax_num = len(loop_list) - 1\nforecast_frames = []\n\nfor num, item in enumerate(loop_list):\n\n    if  num == max_num:\n        pass\n    else:\n        df = stock_price.set_index('ds')[\n             stock_price[stock_price['month/year'] == loop_list[0]]['ds'].min():\\\n             stock_price[stock_price['month/year'] == item]['ds'].max()]\n        \n        df = df.reset_index()[['ds', 'y']]\n        \n        model = Prophet()\n        model.fit(df)\n        \n        future = stock_price[stock_price['month/year_index'] == (num + 1)][['ds']]\n\n        forecast = model.predict(future)\n        forecast_frames.append(forecast)\n```\n\n- In-sample forecast와 원래 가격을 비교하는 그래프 그리기\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\n주가 예측 = reduce(lambda top, bottom: pd.concat([top, bottom], sort=False), 예측_프레임)\n주가 예측 = 주가 예측[['일자', '예측값', '예측값_하한', '예측값_상한']]\n\n데이터프레임 = pd.merge(주가[['일자','실제가격', '월/연도_인덱스']], 주가 예측, on='일자')\n데이터프레임['변동률'] = 데이터프레임['실제가격'].pct_change()\n데이터프레임.set_index('일자')[['실제가격', '예측값', '예측값_하한', '예측값_상한']].plot(figsize=(16,8), color=['royalblue', \"#34495e\", \"#e74c3c\", \"#e74c3c\"], grid=True)\n```\n\n![이미지](/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_18.png)\n\n- 교차 검증 수행 중\n\n```python\nfrom prophet.diagnostics import performance_metrics\n성능_메트릭스 = performance_metrics(df_cv)\n성능_메트릭스.head()\n\n  horizon  mse          rmse      mae     mape mdape smape coverage\n0 37 일    40,821,715.40 6,389.19 4,890.31 0.18 0.12 0.22 0.55\n1 38 일    41,109,990.95 6,411.71 4,913.96 0.18 0.12 0.22 0.55\n2 39 일    41,311,288.83 6,427.39 4,922.43 0.19 0.12 0.22 0.55\n3 40 일    41,641,137.72 6,452.99 4,943.99 0.19 0.12 0.22 0.55\n4 41 일    42,299,834.63 6,503.83 5,003.53 0.19 0.12 0.23 0.54\n\nfrom prophet.plot import plot_cross_validation_metric\n그래프 = plot_cross_validation_metric(df_cv, metric='rmse')\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![Plotting MAPE](/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_19.png)\n\n- MAPE 플로팅\n\n```js\nfig = plot_cross_validation_metric(df_cv, metric='mape')\n```\n\n![MAPE Plot](/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_20.png)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- MAE 그래프 플로팅하기\n\n```js\nfig = plot_cross_validation_metric(df_cv, metric='mae')\n```\n\n![MAE Plot](/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_21.png)\n\n- 그리드 검색 하이퍼파라미터 최적화 구현 및 MAE를 사용하여 모델 평가하기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 하이퍼파라미터 그리드 정의\nfrom sklearn.metrics import mean_absolute_error\nparam_grid = {\n    'seasonality_mode': ['additive', 'multiplicative'],\n    'changepoint_prior_scale': [0.01, 0.1, 1, 10],\n    'seasonality_prior_scale': [0.01, 0.1, 1, 10],\n}\n\n# 모델을 평가하기 위한 도우미 함수\ndef evaluate_model(model, metric_func):\n    df_cv = cross_validation(model, initial='1125 days', period='180 days', horizon='365 days')\n    return metric_func(df_cv['y'], df_cv['yhat'])\n\n# 그리드 서치\nbest_params = {}\nbest_score = float('inf')\n\nfor mode in param_grid['seasonality_mode']:\n    for cps in param_grid['changepoint_prior_scale']:\n        for sps in param_grid['seasonality_prior_scale']:\n            # 현재 하이퍼파라미터를 사용하여 모델 생성\n            m = Prophet(seasonality_mode=mode, changepoint_prior_scale=cps, seasonality_prior_scale=sps)\n            m.fit(stock_price)\n\n            # 평가 지표로 평가 모델(Mean Absolute Error 사용)\n            score = evaluate_model(m, mean_absolute_error)\n\n            # 필요 시 최적의 매개변수 업데이트\n            if score \u003c best_score:\n                best_score = score\n                best_params = {\n                    'seasonality_mode': mode,\n                    'changepoint_prior_scale': cps,\n                    'seasonality_prior_scale': sps\n                }\n\nprint(best_params)\n\n{'seasonality_mode': 'additive', 'changepoint_prior_scale': 0.1, 'seasonality_prior_scale': 10}\n\nprint(best_score)\n8675.430008099349\n```\n\n- 최적화된 모델을 적합하고 1년 예측 생성\n\n```js\n# 최적의 매개변수로 모델 생성\nm_best = Prophet(seasonality_mode='additive', changepoint_prior_scale=0.1, seasonality_prior_scale=10)\nm_best.fit(stock_price)\n\n# 365일을 포함한 예측을 위한 데이터프레임\nfuture_best = m_best.make_future_dataframe(periods=365)\nforecast_best = m_best.predict(future_best)\n\n# 예측 데이터와 함께 그래프 그리기\nfig1 = m.plot(forecast_best)\nax = fig1.gca()\nax.set_title(\"BTC-USD 주가 예측\", size=25)\nax.set_xlabel(\"날짜\", size=15)\nax.set_ylabel(\"가격\", size=15)\n```\n\n![BTC-USD Stock Price Forecast](/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_22.png)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- scikit-learn과 Prophet 지표를 사용하여 교차 검증 QC 수행 중\n\n```js\n# 교차 검증 실행\nfrom sklearn.metrics import mean_squared_error\ndf_cv = cross_validation(m_best, initial='1125 days', period='180 days', horizon='365 days')\n\n# 성능 지표 계산\ndf_metrics = performance_metrics(df_cv)\n\n# MAE, MSE 및 RMSE 계산\nmae = mean_absolute_error(df_cv['y'], df_cv['yhat'])\nmse = mean_squared_error(df_cv['y'], df_cv['yhat'])\nrmse = np.sqrt(mse)\n\nprint(f'평균 절대 오차: {mae:.2f}')\nprint(f'평균 제곱 오차: {mse:.2f}')\nprint(f'제곱근 평균 제곱 오차: {rmse:.2f}')\n\n평균 절대 오차: 8675.43\n평균 제곱 오차: 107375840.73\n제곱근 평균 제곱 오차: 10362.23\n\nfrom prophet.plot import plot_cross_validation_metric\ndf_cv = cross_validation(m_best, initial='1125 days', period='180 days', horizon='365 days')\nfig = plot_cross_validation_metric(df_cv, metric='rmse')\r\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_23.png\" /\u003e\n\n- MAPE 플로팅하기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nfig = plot_cross_validation_metric(df_cv, metric='mape')\n```\n\n![image](/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_24.png)\n\n- MAE 그리기\n\n```python\nfig = plot_cross_validation_metric(df_cv, metric='mae')\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_25.png\" /\u003e\n\n- In-Sample 및 Out-of-Sample 1년 Prophet 예측과 신뢰 구간을 동시에 플로팅합니다 (원래 스케일)\n\n```js\nloop_list = stock_price['month/year'].unique().tolist()\nmax_num = len(loop_list) - 1\nforecast_frames = []\n\nfor num, item in enumerate(loop_list):\n\n    if num == max_num:\n        pass\n    else:\n        df = stock_price.set_index('ds')[\n             stock_price[stock_price['month/year'] == loop_list[0]]['ds'].min():\\\n             stock_price[stock_price['month/year'] == item]['ds'].max()]\n        \n        df = df.reset_index()[['ds', 'y']]\n        \n        future = stock_price[stock_price['month/year_index'] == (num + 1)][['ds']]\n\n        forecast = m_best.predict(future)\n        forecast_frames.append(forecast)\n\nstock_price_forecast1 = reduce(lambda top, bottom: pd.concat([top, bottom], sort=False), forecast_frames)\nstock_price_forecast1 = stock_price_forecast1[['ds', 'yhat', 'yhat_lower', 'yhat_upper']]\n\ndf1 = pd.merge(stock_price[['ds','y', 'month/year_index']], stock_price_forecast1, on='ds')\ndf1['Percent Change'] = df1['y'].pct_change()\ndf1.set_index('ds')[['y', 'yhat', 'yhat_lower', 'yhat_upper']].plot(figsize=(16,8), color=['royalblue', \"#34495e\", \"#e74c3c\", \"#e74c3c\"], grid=True)\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_26.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 수정된 암호화폐 알고리즘 트레이딩 전략\n\n- 다음과 같이 Prophet를 기반으로 한 암호화폐 알고리즘 트레이딩 전략을 수정합시다.\n\n```js\n#트레이딩 알고리즘\ndf=df1.copy()\ndf['Hold'] = (df['Percent Change'] + 1).cumprod()\ndf['Prophet'] = ((df['yhat'].shift(-1) \u003e df['yhat']).shift(1) * (df['Percent Change']) + 1).cumprod()\ndf['Prophet Thresh'] = ((df['y'] \u003c df['yhat_upper']).shift(1) * (df['Percent Change']) + 1).cumprod()\ndf['Seasonality'] = ((~df['ds'].dt.month.isin([8,9])).shift(1) * (df['Percent Change']) + 1).cumprod()\n\n(df.dropna().set_index('ds')[['Hold', 'Prophet', 'Prophet Thresh','Seasonality']] * 1000).plot(figsize=(16,8), grid=True)\n\nprint(f\"Hold = {df['Hold'].iloc[-1]*1000:,.0f}\")\nprint(f\"Prophet = {df['Prophet'].iloc[-1]*1000:,.0f}\")\nprint(f\"Prophet Thresh = {df['Prophet Thresh'].iloc[-1]*1000:,.0f}\")\nprint(f\"Seasonality = {df['Seasonality'].iloc[-1]*1000:,.0f}\")\n\nHold = 6,090\nProphet = 87,595\nProphet Thresh = 18,681\nSeasonality = 7,172\n```\n\n![이미지](/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_27.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 여기에서 Prophet Thresh df['y']` df['yhat_lower'] 를 조건 df['y']` df['yhat_upper'] 로 바꿔 더 높은 예상 수익을 얻을 수 있었습니다.\n- 위의 Prophet 임계값을 최적화해 봅시다.\n\n```js\nperformance = {}\n\nfor x in np.linspace(.9,.99,10):\n    y = ((df['y'] \u003c df['yhat_upper']*x).shift(1)* (df['퍼센트 변화']) + 1).cumprod()\n    performance[x] = y\n    \nbest_yhat = pd.DataFrame(performance).max().idxmax()\npd.DataFrame(performance).plot(figsize=(16,8), grid=True);\nf'최적의 Yhat = {best_yhat:,.2f}'\n\n'최적의 Yhat = 0.92'\n```\n\n![이미지](/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_28.png)\n\n- Best Yhat = 0.92로 백테스트 실행중\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\r\ndf['Optimized Prophet Thresh'] = ((df['y'] \u003c df['yhat_upper'] * best_yhat).shift(1) * \r\n                                  (df['Percent Change']) + 1).cumprod()\r\n\r\n(df.dropna().set_index('ds')[['Hold', 'Prophet', 'Prophet Thresh', \r\n                              'Seasonality', 'Optimized Prophet Thresh']] * 1000).plot(figsize=(16,8), grid=True)\r\n\r\nprint(f\"Hold = {df['Hold'].iloc[-1]*1000:,.0f}\")\r\nprint(f\"Prophet = {df['Prophet'].iloc[-1]*1000:,.0f}\")\r\nprint(f\"Prophet Thresh = {df['Prophet Thresh'].iloc[-1]*1000:,.0f}\")\r\nprint(f\"Seasonality = {df['Seasonality'].iloc[-1]*1000:,.0f}\")\r\nprint(f\"Optimized Prophet Thresh = {df['Optimized Prophet Thresh'].iloc[-1]*1000:,.0f}\")\r\n\r\nHold = 6,090\r\nProphet = 87,595\r\nProphet Thresh = 18,681\r\nSeasonality = 7,172\r\nOptimized Prophet Thresh = 36,769\r\n```\r\n\r\n\u003cimg src=\"/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_29.png\" /\u003e\r\n\r\n- 요약:\r\n    - ROI(Prophet)/ROI(Optimized Prophet Thresh) 약 2.4배\r\n    - ROI(Prophet)/ROI(Hold) 약 14.0배\r\n    - ROI(Optimized Prophet Thresh)/ROI(Prophet Thresh) 약 2.0배\r\n    - ROI(Prophet Thresh)/ROI(Seasonality) 약 2.5배\r\n    - ROI(Seasonality)/ROI(Hold) 약 1.0배\r\n\r\n## 프로핏 플롯리 시각화와 변경 지점들\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Prophet Plotly 시각화 옵션을 살펴봅시다.\n\n```js\nmydf=stock_price[['ds','y']]\nmm = Prophet()\nmm.fit(mydf)\nfuture = mm.make_future_dataframe(periods=365)\nforecast = mm.predict(future)\nfrom prophet.plot import plot_plotly\n\nplot_plotly(mm, forecast)\n```\n\n![Prophet Plotly Visualization](/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_30.png)\n\n- Plotly를 사용하여 Prophet 예측값과 변화점을 시각화합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nfrom prophet.plot import plot_plotly\n\nplot_plotly(mm, forecast, changepoints=True)\n```\n\n![BTC-USD Price Prediction](/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_31.png)\n\n## 결론\n\n- 이 포스트에서는 Prophet (Facebook의 시계열 예측 라이브러리)를 사용하여 BTC-USD 가격을 예측하는 방법을 분석했습니다.\n- Yahoo Finance Python을 사용하여 2 개의 데이터 세트를 다운로드했습니다: (1) 2024-07-06까지 730 일 동안; (2) 2020-01-01부터 2024-07-07까지.\n- 데이터 세트 1을 사용하여 Box-Cox 변환과 미국의 휴일을 고려한 HPO를 테스트했습니다.\n- 데이터 세트 2를 다운로드하여 Prophet HPO 예측을 3 부분(연도, 월, 일)으로 분할 한 후 루프를 통해 다중 계절성 처리의 가치를 보여주었습니다.\n- Prophet 교차 검증 기능에 대한 자세한 내용을 탐구하여 두 데이터 세트에 대한 RMSE, MAPE 및 MAE와 같은 여러 주요 지표를 비교했습니다.\n- 데이터 세트 2: 최종 인샘플 Prophet 오류 지표는 다음과 같습니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nMean Absolute Error: 8675.43\nMean Squared Error: 107375840.73\nRoot Mean Squared Error: 10362.23\n```\n\n- 데이터 집합 2: 350일 주기의 외부 샘플 Prophet HPO 오류 메트릭\n\n```js\nMAPE 약 0.2-0.4, (MAE, RMSE) 약 10k-15k\n```\n\n- Plotly를 사용하여 Prophet 예측 시점의 변화를 그래픽으로 표현하는 가치를 설명했습니다.\n- 마지막으로, 데이터 집합 2를 사용하여 여러 유용한 Prophet 기반 백테스팅 암호화 알고리즘 트레이딩 전략을 Hold 벤치마크에 대해 탐색했습니다.\n- 백테스팅 결과는 ROI(Prophet)/ROI(Hold) 약 14.0임을 보여주었습니다.\n- 테스트 결과, Prophet 추세가 외부 데이터 없이도 정확히 추정될 수 있음을 확인했습니다. 시계열이 강력한 계절적 사업주기를 따른다는 것을 고려할 때, Prophet가 상당히 잘 작동한다는 것을 발견했습니다.\n- Prophet의 다른 통계 모델 및 기계 학습보다 중요한 장점 중 하나는 해석 가능성입니다. Prophet은 시간 기능을 따로 만들 필요가 없기 때문에 빠르게 좋은 기준을 제공합니다.\n- 전반적으로, 시계열이 비즈니스 주기를 따라간다면 Prophet를 기준 모델로 사용할 가치가 있다는 결론을 내립니다 (참고 자료 참조).\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 참고 자료\n\n- Facebook Prophet를 사용한 주식 가격 예측\n- Prophet 진단\n- Facebook Prophet 시작하기\n- Facebook Prophet로 시계열 예측\n- FB Prophet를 사용한 BTC 가격 예측\n\n## 연락처\n\n- 웹사이트\n- GitHub\n- Facebook\n- X/Twitter\n- Pinterest\n- Mastodon\n- Tumblr\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 고지사항\n\n- 다음 고지는 본 글의 정보가 교육 목적으로만 제공되었음을 명확히하며, 재정 또는 투자 자문으로 간주되어서는 안 된다는 것을 명시합니다.\n- 제공된 정보는 귀하 개인의 재정 상황, 목표 또는 리스크 허용도를 고려하지 않습니다.\n- 귀하가 취하는 투자 결정이나 조치는 전적으로 귀하의 책임입니다.\n- 재정 목표, 리스크 허용도 및 투자 기간에 따라 어떠한 투자의 적합성을 독립적으로 평가해야 합니다.\n- 특정 요구 사항에 맞는 맞춤 가이드 제공이 가능한 자격을 갖춘 재무 전문가의 조언을 구하는 것이 권장됩니다.\n- 제공된 도구, 데이터, 콘텐츠, 정보는 맞춤화되지 않았으며 어떤 개인의 투자 요구 사항에 부합하도록 제공된 것이 아니므로 정보 및 교육 목적만을 위해 제공됩니다.\n\n## 자료\n\nhttps://www.kaggle.com/code/alexkaggle95/stock-prices-forecast-plotly-prophet 나쁨\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nhttps://www.kaggle.com/code/ghazanfarali/stock-price-analysis-and-forecasting 페이지를 방문해 보세요! 해당 페이지에는 주식 가격 분석 및 예측과 관련된 정보가 있습니다. 좋은 정보를 얻을 수 있을 거예요!","ogImage":{"url":"/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_0.png","tag":["Tech"],"readingTime":39},{"title":"비용 없이 AI 도구만으로 ChatGPT를 능가하는 챗봇을 구축한 방법","description":"","date":"2024-07-13 19:52","slug":"2024-07-13-HowIBuiltaChatbotthatCrushedChatGPTwithZeroCostAITools","content":"\n\n챗봇은 고객과 상호작용하고 정보를 제공하며 사용자를 즐겁게 해주는 방법으로 점점 더 인기를 얻고 있습니다. 그러나 자연스럽고 매력적인 대화를 나눌 수 있는 AI 애플리케이션을 구축하는 것은 쉬운 일이 아닙니다.\n\n많은 챗봇 개발자들이 ChatGPT와 같은 비싼 독점 AI 모델을 활용하고 있습니다.\n\n하지만 무료 및 오픈 소스 AI 도구를 사용하여 ChatGPT와 어울리는 챗봇을 만들 수 있다면 어떨까요?\n\n저는 그것을 해냈고, 이 글에서 그 방법을 공유하려고 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 도전과 탐험\n\n이 도전에 도전하게 된 이유에 대해 궁금해 할 수도 있어요. 그 이유는 모두 오픈 소스 언어 모델의 성능에 대해 회의적인 중도 독자로부터 받은 메시지에서 시작되었어요.\n\n중도 독자가 ChatGPT를 사용한 질문/답변 세션을 보내줬고, 오픈 소스 도구를 사용하여 동일한 수준의 품질과 일관성을 실현할 수 있는지 물었어요.\n\n그 질문에 흥미를 느껴서 도전해보기로 결정했어요. 몇 일 동안 Hugging Face의 다양한 오픈 소스 AI 도구를 연구하고 실험하며 조정하는 시간을 보냈어요. 나만의 소규모 전문가 팀을 결성하여 ChatGPT를 넘어서거나 심지어 뛰어넘길 수 있기를 바랬는데, 결과가 궁금하게요?\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nWell done! You've done amazing work by creating a chatbot that can engage in fluent and diverse conversations. What's even more impressive is that you accomplished this on your own computer without relying on external cloud services or APIs. This allowed you to maintain full control and privacy over your data and model.\n\n![Image](/TIL/assets/img/2024-07-13-HowIBuiltaChatbotthatCrushedChatGPTwithZeroCostAITools_0.png)\n\n## The Issue\n\nWith the article \"Apple's iOS App Store announces sweeping changes in the EU,\" the objective is to identify the key question implied by the headline (or let the user ask it) and then provide a concise answer based on the article text.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기 ChatGPT에서 받은 결과입니다...\n\n# ChatGPT 결과\n\n![이미지](/TIL/assets/img/2024-07-13-HowIBuiltaChatbotthatCrushedChatGPTwithZeroCostAITools_1.png)\n\n# 우리의 개인 AI가 지역에서 이것을 어떻게 할까요?\n\n음, 당신은 아마도 이것에는 최소한 Mistral-7B만큼 좋은 수퍼 모델이 필요할 것이라고 생각할 수 있습니다. 물론 당신이 좋은 NVidia GPU나 16GB의 메모리, 그리고 양자화된 버전을 갖고 있지 않는 이상 일반 노트북에서 실행할 수 없습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그런 일은 없어요. 내가 구글 콜랩에서 실행하는 Mixtures of Experts (SoMoE)를 만들기로 결정했어. 또한 내 미니PC(130 달러짜리 팬리스 컴퓨터로 윈도우 11이 돌아가며 16GB RAM과 7세대 Intel 4코어 4스레드를 가지고 있는)에서도 테스트했어. 그래서 결론적으로 누구나 내 SoMoE를 실행할 수 있어.\n\n![이미지](/TIL/assets/img/2024-07-13-HowIBuiltaChatbotthatCrushedChatGPTwithZeroCostAITools_2.png)\n\n비밀 조리법? 작은 T5 모델이 텍스트를 요약하고 문서의 주요 질문을 제안하며, StableLM-Zephyr-3B의 양자화 버전이 질문에 대답하고 해당 문서에 대한 챗봇 역할을 한다는 것. 모든 것을 연결하기 위해 영어에만 BAAI/bge-base-en-v1.5 임베딩을 사용해서 벡터 데이터베이스를 만들고 유사성 검색 및 관련성 재랭킹에 작동시키고 있어.\n\n![이미지](/TIL/assets/img/2024-07-13-HowIBuiltaChatbotthatCrushedChatGPTwithZeroCostAITools_3.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 쉬운 방법\n\n간단히 말하면, 기사의 텍스트 길이는 꽤 짧습니다. 4k 토큰 콘텍스트 길이를 가진 모델은 쉽게 전체 로드를 처리하고 텍스트를 처리할 수 있습니다.\n\nGoogle Colab의 무료 티어(오직 CPU와 12GB RAM만 사용 가능)에서 다음을 수행할 수 있습니다:\n\n```js\n#Dependencies 설치 및 stablelm-zephyr-3b-GGUF 다운로드\n!pip install transformers -U --no-cache-dir\n!pip install llama-cpp-python==0.2.34\n!pip install rich\n!huggingface-cli download TheBloke/stablelm-zephyr-3b-GGUF stablelm-zephyr-3b.Q5_K_S.gguf --local-dir . --local-dir-use-symlinks False\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\neditedtext = \"\"\"Apple의 iOS 앱 스토어가 EU에서 대대적인 변화를 발표했습니다.\nhttps://www.axios.com/2024/01/25/apple-app-store-eu-changes\n저자: Ashley Gold, Axios Pro의 저자\nApple은 유럽의 디지털 시장 법안을 준수하기 위해 알 터 내 앱 스토어 및 앱 개발자를 위한 다른 새로운 옵션을 허용할 것이라고 회사가 목요일 밝혔습니다.\n뉴스 주도: 3월 7일에 발효될 예정인 유럽의 주요 기술 경쟁 법은 개발자들이 배포 및 결제 처리를 위해 앱 스토어에 의존해야 하는 엄격한 규정을 완화하기를 Apple에 요구합니다.\nApple은 오랫동안 ...\"\"\"\n```\n\n```js\nfrom rich.panel import Panel\nimport datetime\nfrom rich.console import Console\nconsole = Console(width=110)\nwith console.status(\"Loading ✅✅✅✅ stablelm-zephyr-3b with LLAMA.CPP...\",\n                    spinner=\"dots12\"):\n    llm = Llama(\n        model_path=\"/content/stablelm-zephyr-3b.Q5_K_S.gguf\",  # 먼저 모델 파일을 다운로드하세요\n        n_ctx=4096,  # 사용할 최대 시퀀스 길이 - 더 긴 시퀀스 길이는 더 많은 리소스를 필요로 함을 참고하세요\n        n_threads=2,  # 사용할 CPU 스레드 수, 시스템 및 결과 성능에 맞게 조정하세요\n    )\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안녕하세요! 아래 텍스트를 참고해주세요:\n\n```js\ncontext = editedtext # 주로 전체 문서입니다\nquery = \"유럽 디지털 시장법에 대응하여 EU 앱 스토어에서 Apple이 시행하는 주요 변경 사항은 무엇인가요?\"\ntemplate = f\"\"\"\u003c|user|\u003e\\n주어진 텍스트 일부는 다음과 같습니다:\\n-----\n              {context}\\n-----\\n\n              질문에 대한 답변을 해주세요. 답변은 정보를 제공하고 목록 형식으로 구성되어야 합니다. 답변할 수 없는 경우, \"답변 불가\"라고 말해주세요.\\n\n              질문: {query}\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```\n![Image](/TIL/assets/img/2024-07-13-HowIBuiltaChatbotthatCrushedChatGPTwithZeroCostAITools_4.png)\n\n# The SoMoE way\n\nI think that the best way to approach a text we don’t know anything about consists at least of 2 steps:\n\n- read a summary\n- get an idea of the main questions about that text\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이러한 이유로 우리는 2개의 함수가 필요합니다: 하나는 텍스트를 요약하는 함수이고, 다른 하나는 텍스트에 대해 통찰력있는 질문을 제공하여 추천 시스템을 구축할 것입니다.\n\n# 🦙 LaMini-Flan-T5–77M — 요약\n\nFlan-T5 패밀리는 인코더-디코더 모델 그룹입니다. 이들은 텍스트 조작과 이해에서 뛰어나게 빠릅니다. 자세한 내용은 여기에서 확인할 수 있어요...\n\n제한 사항은 문맥 크기에 있습니다: 모두 512개의 토큰 이상을 처리할 수 없습니다. 그래서 우리는 Langchain을 사용할 것입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 단계에서는 텍스트 스플릿터만 사용할 것입니다: 큰 텍스트 말뭉치를 작은 조각들로 나누는 도구와 전략입니다. 일반적으로 문단 수준으로 분할하라고 가르치는 자습서를 찾을 수 있지만, 여기서는 토큰만 사용할 것입니다(512 글자 제한이 있기 때문에).\n\n```js\n# 텍스트 파일 읽기\nwith open(\"/content/Article-edited.txt\") as f:\n  editedtext = f.read()\nf.close()\n# 토큰별로 나누기\nfrom langchain.text_splitter import TokenTextSplitter\nTOKENtext_splitter = TokenTextSplitter(chunk_size=430, chunk_overlap=20)\nsplitted_text_sum = TOKENtext_splitter.split_text(editedtext)  # 리스트 생성\n```\n\n이제 LaMini 모델에게 각 조각에 대한 간단한 요약을 생성해 달라고 요청하고 모든 요약을 결합할 수 있습니다.\n\n```js\n# 모델을 파이프라인으로 로드하기\nfrom transformers import pipeline\nmodel77 = pipeline('text2text-generation',model=\"MBZUAI/LaMini-Flan-T5-77M\")\nsummary =\"요약:\\n\"\n# 조각을 순환하며\nfor item in splitted_text_sum:\n  text = item\n  template_summary = f'''텍스트: {text}\n\n위 텍스트에 대한 명확한 요약을 작성하세요.\n'''\n  res = model77(template_summary, temperature=0.3, repetition_penalty=1.3, max_length=300, do_sample=True)[0]['generated_text']\n  summary = summary + res + '\\n'\nprint(summary)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n매우 쉬워요! 몇 가지 테스트를 진행해 보시는 걸 권장해요.\n\n# 🦙 LaMini-Flan-T5–77M — 질문 생성기\n\n다음 단계는 주요 질문들을 추출하는 것이에요: 이것은 학교 교과서에서 일반적으로 찾을 수 있는 질문들과 동일한 것이죠 (좋은 교과서들에요): 챕터나 섹션 뒤에 작가들이 공부하는 데 도움이 되는 몇 가지 질문을 제공해요.\n\nLaMini를 사용하면 매우 쉬워요, 프롬프트에 몇 가지 속임수만 있으면 돼요. 차별화된 점은 Text-Splitter의 정밀도를 높이는 것이에요. 우리는 크고 일반적인 질문만 원하는 게 아니에요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nTOKENtext_splitter = TokenTextSplitter(chunk_size=280, chunk_overlap=20)\nsplitted_text_qg = TOKENtext_splitter.split_text(editedtext) # 리스트 생성\n\nfor item in splitted_text_qg:\n  text = item\n  template_qg = f'''{text}\\n\\n\n위의 텍스트에 대한 중요한 두 가지 질문을 작성하세요.\n질문:\n1.\n2.\n'''\n  res = model(template_qg, temperature=0.3, repetition_penalty=1.3, max_length=250, do_sample=True)[0]['generated_text']\n  ed_res = res.replace('? ','?#')\n  list_res = ed_res.split('#')\n  for i in list_res:\n     quest2.append(i[3:])\n```\n\n280 토큰 단위로 청크가 생성되었습니다. 요약에 사용된 430 토큰과는 다릅니다.\n\n# 최종 결과\n\nGitHub 저장소에서 Google Colab 노트북 2개를 찾을 수 있습니다. 하나는 CPU만으로 실행되고, 다른 하나는 무료 T4 인스턴스(GPU)를 사용할 수 있는 노트북입니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n오픈 소스 LLM이 여기 있고, 당신이 그것을 사용할 때 꼭 고루가 아니어도 됩니다.\n\n가장 많이 사용하는 작업에 대한 몇 가지 함수를 만들면, 어떤 사용 사례에도 사용할 수 있는 스위스 아미 나이프를 갖게 됩니다.\n\n그저 시작하는 용기만 있으면 됩니다!\n\n이 기사를 즐겼기를 바랍니다. 만약 이 이야기가 가치를 제공하고 조금이라도 지원을 보여주고 싶다면 다음과 같은 방법을 사용할 수 있습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 이 이야기에 대해 많이 박수를 치세요\n- 기억할 가치가 있는 부분을 강조하세요 (나중에 찾기 쉽고 더 나은 기사를 쓰기 위해)\n- 직접 AI를 만들어보기 시작하는 방법을 배운다면, 무료 eBook을 다운로드하세요\n- 무제한 Medium 이야기를 읽기 위해 월 $5를 내고 Medium 멤버십에 가입하세요\n- Medium에서 나를 팔로우하세요\n- 내 최신 기사를 읽어보세요 https://medium.com/@fabio.matricardi\n\n더 많은 정보를 원한다면, 다음은 로컬 AI를 문서와 함께 사용하는 아이디어입니다:\n\nWRITER at MLearning.ai / Midjourney ALPHA / 180K+ AI Art Prompts","ogImage":{"url":"/TIL/assets/img/2024-07-13-HowIBuiltaChatbotthatCrushedChatGPTwithZeroCostAITools_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-HowIBuiltaChatbotthatCrushedChatGPTwithZeroCostAITools_0.png","tag":["Tech"],"readingTime":11},{"title":"딥러닝 메모리 관리 혁명 Torch Memoryadaptive Algorithms TOMA의 비밀","description":"","date":"2024-07-13 19:50","slug":"2024-07-13-TorchMemoryadaptiveAlgorithmsTOMARevolutionizingMemoryManagementinDeepLearning","content":"\n\n# 요약\n\n배경: 딥러닝에서는 메모리를 효율적으로 관리하는 것이 중요합니다. 특히 대규모이고 복잡한 신경망을 훈련할 때 이는 중요합니다. 자원 제약으로 인해 메모리 부족 오류가 발생하고 모델의 확장성이 제한될 수 있습니다.\n\n문제: 전통적인 메모리 관리 방법은 종종 정적이고 비효율적이며 훈련 중에 불안정성을 초래하고 세련된 모델의 개발을 방해할 수 있습니다. 이 병목현상은 동적으로 메모리 사용량을 최적화하기 위한 혁신적인 솔루션을 필수로 합니다.\n\n접근 방식: 본 에세이는 PyTorch를 기반으로 구축된 Torch Memoryadaptive Algorithms (TOMA)를 소개합니다. TOMA는 훈련 및 추론 중 메모리 할당을 동적으로 조정하는 것을 목적으로 설계되었습니다. TOMA는 적응형 기울기 체크포인팅, 최적화된 데이터 로딩, 그리고 모델 가지치기 및 양자화를 활용하여 메모리 효율성을 향상시킵니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n결과: 합성 데이터세트를 사용하여 TOMA의 적용은 우수한 성능을 보여주었습니다. 최상의 교차 확인 RMSE가 0.1138이고 R2 점수가 0.9844였습니다. 이 모델은 테스트 RMSE가 0.1129이고 R2 점수가 0.9848로 안정적인 일반화와 높은 예측 정확도를 보여주었습니다. 실제 값 대 예측값의 산점도는 강한 선형 관계를 나타내며 모델의 효과를 더욱 확증했습니다.\n\n결론: TOMA는 딥 러닝에서 메모리 관리를 혁신적으로 향상시켜, 자원에 제한된 하드웨어에서 더 큰 모델을 학습할 수 있도록 합니다. 결과는 TOMA가 모델의 안정성, 확장성, 효율성을 향상시키는 잠재력을 강조하며, AI 커뮤니티의 연구원과 실무자들에게 가치 있는 도구로 자리잡을 수 있다는 것을 보여줍니다.\n\n키워드: 동적 메모리 관리; 신경망 최적화; PyTorch TOMA 프레임워크; 효율적인 딥 러닝; 적응형 그래디언트 체크포인팅.\n\n# 소개\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n상상해보세요. 당신의 최첨단 GPU 메모리에 맞기 어려운 정도로 방대한 신경망을 훈련한다고 상상해봅시다. 훈련 중에 메모리 부족 오류가 발생하여 진행이 멈추고 모델을 축소하거나 하드웨어를 업그레이드해야 하는 상황입니다. 그러나 메모리를 적응적으로 관리하여 가장 복잡한 모델들에도 원만하고 효율적인 훈련을 보장할 수 있는 방법이 있다면 어떨까요? Torch Memoryadaptive Algorithms (TOMA) [1]가 바로 그 메모리 최적화의 게임 체인저입니다.\n\n![이미지](/TIL/assets/img/2024-07-13-TorchMemoryadaptiveAlgorithmsTOMARevolutionizingMemoryManagementinDeepLearning_0.png)\n\n# 메모리 병목 현상: 흔한 장애물\n\n딥러닝 모델은 점점 더 복잡해지면서 더 많은 계산 성능과 메모리를 요구합니다. AI가 어디까지 가능한지의 한계를 끌어올리는 동시에, 이러한 경향은 상당한 어려움을 야기합니다. 기존 방법론은 종종 고성능 GPU에 제한된 연구원과 실무자들이 계속해서 따라잡기 어렵도록 만들어버립니다. 메모리 병목 현상은 흔하게 발생하며 훈련 과정을 충돌시키거나 상당히 느리게 만들어버립니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# TOMA: 적응형 메모리 관리\n\nTorch Memoryadaptive Algorithms (TOMA)은 이러한 도전에 직면하여 대응합니다. 다재다능한 PyTorch 프레임워크 위에 구축된 TOMA는 훈련과 추론 중에 메모리 사용량을 동적으로 조정합니다. 이러한 적응성은 자원이 효율적으로 할당되어 메모리 부족 오류가 발생할 가능성을 줄이며 모델의 전반적인 안정성과 확장성을 향상시킵니다.\n\n## 동적 메모리 할당: 효율성 극대화\n\nTOMA의 핵심 기능 중 하나는 현재 훈련 상태를 기반으로 메모리를 동적으로 할당하는 능력입니다. 낭비되고 비효율적일 수 있는 정적 할당 방법과 달리 TOMA는 메모리 사용량을 지속적으로 모니터하고 할당을 실시간으로 조정합니다. 이 방법은 자원 활용률을 최적화하고 기존 하드웨어에서 더 큰 모델을 훈련할 수 있도록 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 적응형 그래디언트 체크포인팅: 메모리와 계산의 균형 유지\n\nTOMA의 또 다른 혁신적인 측면은 적응형 그래디언트 체크포인팅 기술입니다. TOMA는 중간 활성화값을 선택적으로 저장하고 다시 계산함으로써 계산 효율성을 훼손하지 않으면서 메모리 소비를 크게 줄입니다. 이 균형은 메모리 절약이 성능과 확장성을 크게 향상시킬 수 있는 딥 뉴럴 네트워크 학습에 중요합니다.\n\n## 최적화된 데이터로딩: 안정적인 데이터 흐름 보장\n\n데이터 로딩은 딥러닝 훈련에서 종종 간과되는 부분입니다. 비효율적인 데이터 전송이 병목 현상을 일으켜 전체 프로세스를 늦추는 경우가 있습니다. TOMA는 사전 로딩 및 데이터 일괄 처리를 위한 최적화된 데이터 로딩 전략을 통합함으로써 이 문제에 대처합니다. 이를 통해 GPU로 안정적인 데이터 흐름을 보장하고 지연을 최소화하여 전반적인 훈련 효율성을 향상시킵니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 모델 가지치기 및 양자화: 풋프린트 축소\n\nTOMA는 메모리 사용량을 더욱 최적화하기 위해 모델 가지치기 및 양자화 기술을 포함하고 있습니다. 가지치기는 중복 매개변수를 제거하며, 양자화는 가중치의 정밀도를 감소시킵니다. 이러한 방법들은 모델의 정확도를 유지하면서 메모리 풋프린트를 크게 줄여줌으로써, 자원이 제한된 기기에 복잡한 모델을 배포하는 것이 가능해집니다.\n\n## 실시간 모니터링 및 프로파일링: 투명성 및 제어\n\n효율적인 메모리 관리에는 투명성과 제어가 중요합니다. TOMA는 실시간 메모리 모니터링 및 프로파일링 도구를 제공하여, 개발자들이 교육 과정 전반에 걸쳐 사용량을 추적할 수 있도록 합니다. 이러한 가시성은 메모리 병목 현상을 식별하고 해결함으로써, 더 효율적이고 신뢰할 수 있는 교육 실행을 이끌어냅니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 실용적인 응용: 연구부터 엣지 컴퓨팅까지\n\nTOMA의 장점은 다양한 분야에 걸쳐 확장됩니다. 연구에서는 새로운 신경망 구조의 신속한 프로토타이핑과 테스트를 지원합니다. 엣지 컴퓨팅 및 사물 인터넷(IoT) 장치를 다루는 실무자들에게는, TOMA가 제한된 메모리와 처리 능력을 갖춘 장치에 정교한 AI 모델을 배포하는 것을 가능하게 합니다. TOMA는 메모리 사용량을 최적화하고 엣지에서 실시간 추론과 의사 결정을 용이하게 해주어, 지능적인 응용 프로그램에 대한 새로운 가능성을 열어줍니다.\n\n# 실용적인 예제\n\n아래는 합성 데이터셋을 사용하여 Torch Memoryadaptive Algorithms (TOMA)를 시연하는 완전한 Python 코드 예제입니다. 이 예제는 데이터 생성, 피처 엔지니어링, 초모수 조정을 통한 모델 훈련, 교차 검증, 예측 및 평가를 다룹니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport torch\nimport torch.nn as nn\nimport torch.optim as optim\nfrom torch.utils.data import DataLoader, TensorDataset\nfrom sklearn.model_selection import train_test_split, KFold\nfrom sklearn.metrics import mean_squared_error, r2_score\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# 합성 데이터셋 생성\ndef generate_synthetic_data(n_samples=1000, n_features=10):\n    X = np.random.rand(n_samples, n_features)\n    y = np.sum(X, axis=1) + np.random.randn(n_samples) * 0.1  # 단순한 선형 관계에 노이즈 추가\n    return X, y\n\n# 특성 엔지니어링 (다항 특성 추가)\ndef feature_engineering(X):\n    poly_features = X ** 2\n    return np.hstack([X, poly_features])\n\n# 간단한 신경망 모델\nclass SimpleNN(nn.Module):\n    def __init__(self, input_dim):\n        super(SimpleNN, self).__init__()\n        self.fc1 = nn.Linear(input_dim, 64)\n        self.fc2 = nn.Linear(64, 32)\n        self.fc3 = nn.Linear(32, 1)\n\n    def forward(self, x):\n        x = torch.relu(self.fc1(x))\n        x = torch.relu(self.fc2(x))\n        x = self.fc3(x)\n        return x\n\n# 훈련 함수\ndef train_model(model, train_loader, criterion, optimizer, n_epochs=100):\n    model.train()\n    for epoch in range(n_epochs):\n        for data, target in train_loader:\n            optimizer.zero_grad()\n            output = model(data)\n            loss = criterion(output, target.view(-1, 1))\n            loss.backward()\n            optimizer.step()\n\n# 교차 검증과 하이퍼파라미터 튜닝\ndef cross_validate(X, y, k=5, lr=0.001, n_epochs=100):\n    kf = KFold(n_splits=k)\n    rmses = []\n    r2s = []\n\n    for train_index, val_index in kf.split(X):\n        X_train, X_val = X[train_index], X[val_index]\n        y_train, y_val = y[train_index], y[val_index]\n\n        train_dataset = TensorDataset(torch.tensor(X_train, dtype=torch.float32), torch.tensor(y_train, dtype=torch.float32))\n        val_dataset = TensorDataset(torch.tensor(X_val, dtype=torch.float32), torch.tensor(y_val, dtype=torch.float32))\n\n        train_loader = DataLoader(train_dataset, batch_size=32, shuffle=True)\n        val_loader = DataLoader(val_dataset, batch_size=32, shuffle=False)\n\n        model = SimpleNN(X_train.shape[1])\n        criterion = nn.MSELoss()\n        optimizer = optim.Adam(model.parameters(), lr=lr)\n\n        train_model(model, train_loader, criterion, optimizer, n_epochs)\n\n        model.eval()\n        val_preds = []\n        val_targets = []\n\n        with torch.no_grad():\n            for data, target in val_loader:\n                output = model(data)\n                val_preds.extend(output.view(-1).tolist())\n                val_targets.extend(target.tolist())\n\n        rmse = mean_squared_error(val_targets, val_preds, squared=False)\n        r2 = r2_score(val_targets, val_preds)\n        rmses.append(rmse)\n        r2s.append(r2)\n\n    return np.mean(rmses), np.mean(r2s)\n\n# 주 스크립트\nif __name__ == \"__main__\":\n    X, y = generate_synthetic_data()\n    X = feature_engineering(X)\n\n    # 데이터를 훈련 및 테스트 세트로 분할\n    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n\n    # 하이퍼파라미터 튜닝\n    best_lr = 0.001\n    best_rmse, best_r2 = cross_validate(X_train, y_train, k=5, lr=best_lr, n_epochs=100)\n\n    # 전체 훈련 세트에서 최종 모델 훈련\n    train_dataset = TensorDataset(torch.tensor(X_train, dtype=torch.float32), torch.tensor(y_train, dtype=torch.float32))\n    train_loader = DataLoader(train_dataset, batch_size=32, shuffle=True)\n\n    final_model = SimpleNN(X_train.shape[1])\n    criterion = nn.MSELoss()\n    optimizer = optim.Adam(final_model.parameters(), lr=best_lr)\n\n    train_model(final_model, train_loader, criterion, optimizer, n_epochs=100)\n\n    # 테스트 세트에서 평가\n    final_model.eval()\n    test_preds = []\n    with torch.no_grad():\n        test_preds = final_model(torch.tensor(X_test, dtype=torch.float32)).view(-1).tolist()\n\n    rmse = mean_squared_error(y_test, test_preds, squared=False)\n    r2 = r2_score(y_test, test_preds)\n\n    # 결과 및 해석\n    print(f\"최고 교차 확인 RMSE: {best_rmse:.4f}\")\n    print(f\"최고 교차 확인 R2: {best_r2:.4f}\")\n    print(f\"테스트 RMSE: {rmse:.4f}\")\n    print(f\"테스트 R2: {r2:.4f}\")\n\n    # 결과 그래프\n    plt.figure(figsize=(10, 5))\n    plt.scatter(y_test, test_preds, alpha=0.7)\n    plt.plot([min(y_test), max(y_test)], [min(y_test), max(y_test)], color='red')\n    plt.xlabel(\"실제 값\")\n    plt.ylabel(\"예측 값\")\n    plt.title(\"실제 값 대 예측 값\")\n    plt.show()\n```\n\n## 설명\n\n- 데이터 생성: 선형 관계와 노이즈가 포함된 가상 데이터셋 생성\n- 특성 엔지니어링: 모델 용량을 높이기 위해 다항 특성 추가\n- 모델 정의: PyTorch를 사용하여 간단한 신경망 모델 정의\n- 훈련 함수: 주어진 데이터셋과 옵티마이저를 사용하여 모델 훈련\n- 교차 검증 및 하이퍼파라미터 튜닝: K-Fold 교차 검증을 통해 하이퍼파라미터를 튜닝하고 모델 성능 평가\n- 주 스크립트: 데이터 분할, 하이퍼파라미터 튜닝, 최종 모델 훈련, 테스트 세트 평가 등을 실행하는 스크립트\n- 결과 및 그래프: 성능 지표 (RMSE, R2)를 출력하고 실제 값과 예측값을 비교하는 산점도 그래프 표시\n\nTorch Memoryadaptive Algorithms (TOMA)을 활용하여 신경망을 효율적으로 훈련하고 평가하는 포괄적인 예제 코드입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-TorchMemoryadaptiveAlgorithmsTOMARevolutionizingMemoryManagementinDeepLearning_1.png\" /\u003e\n\n모델의 성능 지표와 산점도 결과는 모델의 성능을 얼마나 잘 평가했는지에 대한 소중한 통찰력을 제공합니다. 여기에 결과에 대한 해석이 있습니다:\n\n## 성능 지표\n\n- Best Cross-Validated RMSE: 0.1138: Root Mean Squared Error (RMSE)는 모델이 예측한 값과 실제 값 사이의 차이를 측정합니다. 낮은 RMSE는 더 좋은 성능을 나타냅니다. 여기서 교차 확인을 통해 0.1138의 값은 검증 데이터에서 모델이 잘 수행되고 예측이 실제 값에 가깝다는 것을 시사합니다.\n- Best Cross-Validated R2: 0.9844: R-squared (R2) 점수는 모델이 대상 변수의 분산을 얼마나 잘 설명하는지를 나타냅니다. R2 점수가 1에 가까울수록 모델이 대상 변수의 분산의 많은 부분을 설명한다는 것을 의미합니다. 0.9844의 교차 확인된 R2 점수는 모델이 데이터의 기저 패턴을 매우 잘 포착한다는 것을 시사합니다.\n- Test RMSE: 0.1129: 시험 RMSE가 교차 확인된 RMSE보다 약간 낮은 것은 모델이 보이지 않은 데이터에도 잘 일반화된다는 것을 나타냅니다. 이는 훈련 과정 중에 과적합이 심하지 않았으며, 시험 세트에서의 모델 성능이 교차 확인 중에 보인 성능과 일관성이 있다는 것을 시사합니다.\n- Test R2: 0.9848: 0.9848의 시험 R2 점수는 교차 확인된 R2 점수에 매우 가까운 것으로, 모델이 견고하고 새로운 데이터에도 잘 일반화된다는 것을 확인합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 산점도 해석\n\n\"True Values vs Predictions\"라는 제목이 붙은 산점도는 실제 값과 모델이 예측한 값 사이의 관계를 보여줍니다.\n\n- 최적 선 (빨간 선): 빨간 선은 예측이 실제 값과 완벽하게 일치하는 이상적인 상황을 나타냅니다 (즉, 원점을 통과하는 45도 직선). 파란 점들이 빨간 선에 가까울수록 모델의 예측이 더 좋습니다.\n- 데이터 점 (파란 점): 파란 점들은 모델이 한 실제 예측을 나타냅니다. 이러한 점들이 빨간 선 주변에 밀집되어 있음은 모델의 예측이 높은 정확도를 가지고 있다는 것을 나타냅니다.\n- 실제 값과 예측값 사이의 일관된 선형 관계는 모델이 합성 데이터셋의 기본 선형 패턴을 효과적으로 포착했다는 것을 시사합니다.\n\n```js\n최적 교차 확인 RMSE: 0.1138\n최적 교차 확인 R2: 0.9844\n테스트 RMSE: 0.1129\n테스트 R2: 0.9848\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 전반적 해석\n\n교차 검증 및 테스트 세트에서 낮은 RMSE 값과 높은 R2 점수의 조합은 모델이 매우 우수한 성능을 발휘했음을 나타냅니다. 산점도는 예측값이 실제 값과 매우 가까운 것을 보여주어 이를 더욱 뒷받침합니다.\n\n- 모델 정확도: 높은 R2 점수와 낮은 RMSE 값은 모델이 특성으로부터 대상 변수를 매우 정확하게 예측한다는 것을 시사합니다.\n- 일반화: 교차 확인 및 테스트 지표 간의 일관성은 모델이 보이지 않은 데이터에도 잘 일반화되며, 이는 실용적인 응용 프로그램에 매우 중요합니다.\n- 실용적 영향: 실용적 시나리오에서 이러한 강력한 성능은 모델이 비슷한 맥락에서 예측 작업에 신뢰할 수 있게 사용될 수 있음을 의미하며, 예측이 실제 결과에 근접하게 하여 더 나은 의사 결정이 가능합니다.\n\n결론적으로, Torch Memoryadaptive Algorithms (TOMA)은 합성 데이터셋에서 메모리 관리와 신경망 성능 향상의 효과를 입증했습니다. 결과는 TOMA가 실제 응용 분야에서 효율적이고 정확한 예측 모델 개발에 유용한 도구가 될 수 있다는 것을 보여줍니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론: 딥 러닝의 경계를 넓히는 TOMA\n\nTorch Memoryadaptive Algorithms (TOMA)는 메모리 관리의 중요한 과제를 해결하는 딥 러닝의 중요한 진전입니다. TOMA는 메모리 할당을 동적으로 조정하고 적응형 그래디언트 체크포인팅을 이용하며 데이터 로딩을 최적화하고 가지치기 및 양자화 기술을 통합함으로써 신경망의 효율성, 확장성 및 안정성을 향상시킵니다. 연구원과 실무자들에게 TOMA는 가능한 한계를 초월할 수 있는 강력한 도구로 작용하며, 메모리 제약이 있는 환경에서도 고급 AI를 활용할 수 있도록 합니다. 딥 러닝이 발전함에 따라, TOMA와 같은 혁신은 진전을 이끄는 데 중요하며 기술적 돌파구를 가능하게 합니다.\n\n딥 러닝에서 동적 메모리 관리의 영향에 대한 생각이 있으신가요? 프로젝트에서 메모리 제약이 있었나요? 아래 댓글에 여러분의 경험과 의견을 공유해 주세요! 도움이 되었다면 이 글을 꼭 여러분의 네트워크와 공유하세요!\n\n# 참고문헌","ogImage":{"url":"/TIL/assets/img/2024-07-13-TorchMemoryadaptiveAlgorithmsTOMARevolutionizingMemoryManagementinDeepLearning_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-TorchMemoryadaptiveAlgorithmsTOMARevolutionizingMemoryManagementinDeepLearning_0.png","tag":["Tech"],"readingTime":14},{"title":"몰랐던 Jupyter의 숨겨진 해킹 5가지","description":"","date":"2024-07-13 19:49","slug":"2024-07-13-5JupyterHacksThatYouNeverKnewEvenExisted","content":"\n\n아래는 이 기사의 코드입니다.\n\nJupyter Notebook은 데이터 과학, 머신 러닝, 과학 계산 및 기타 Python 중심 프로그래밍 작업에 가장 인기 있는 IDE 중 하나입니다.\n\n대화식 코딩 기능으로 초심자뿐만 아니라 전문가들에게도 가장 많이 사용되는 도구로 자리 잡고 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하지만 널리 사용되고 있지만, 많은 사용자들이 그 가능성을 충분히 활용하지 못하고 있습니다.\n\n결과적으로, 그들은 주피터를 기본 인터페이스/기능을 이용하여 사용하는데, 내 의견으로는 이를 향상시켜 더욱 풍부한 경험을 제공할 수 있습니다.\n\n그래서 이 글에서는 아마 당신이 전혀 몰랐을 것으로 생각되는 5가지 멋진 주피터 해킹을 소개하겠습니다.\n\n이를 통해 당신은 이 강력한 도구로 새로운 생산성과 창의력을 발휘할 수 있을 것입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n시작해봅시다 🚀!\n\n## 1. 데이터프레임의 원시 데이터 미리보기 중지\n\nJupyter에서 데이터프레임을 로드할 때 종종 출력을 통해 미리보기합니다. 아래의 내용을 확인할 수 있습니다: \n\n![데이터프레임 미리보기](/TIL/assets/img/2024-07-13-5JupyterHacksThatYouNeverKnewEvenExisted_1.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러나 이것은 이 데이터에 내장된 내용에 대해 거의 어떤 정보도 전달하지 않습니다.\n\n결과적으로 분석을 통해 더 깊이 파고들어야 할 필요가 있습니다. 그리고 이는 간단하면서 반복적인 코드를 포함합니다.\n\n대신 Jupyter-DataTables을 사용하세요. 다음과 같이 설치할 수 있습니다:\n\n사용하려면 Jupyter에서 다음 코드를 실행하세요:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nDataFrame의 기본 미리보기를 많은 유용한 기능으로 확장합니다.\n\n결과적으로 DataFrame을 출력할 때 아래와 같이 훨씬 더 우아하게 나타납니다.\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*vtDNomuoHOnqE46HGF61rA.gif)\n\n이 풍부한 미리보기는 정렬, 필터링, 내보내기 및 페이지네이션 작업을 제공하며 열 분포 및 데이터 유형도 제공합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 데이터에 레이블을 붙이는 클릭 한 번으로!\n\n모든 데이터가 미리 레이블이 달려 온 것은 아닙니다.\n\n따라서 레이블이 없는 데이터의 경우, 주로 약간의 시간을 들여 주석을 다는 작업을 해야 할 수도 있습니다.\n\n파일을 외부에서 미리보고 레이블을 붙이거나 복잡한 주석 생성 파이프라인을 만드는 대신, **ipynnotate**를 사용하여 몇 줄의 코드로 주석을 달 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 문구를 번역하면 다음과 같습니다:\n\n데이터 주석을 위한 특별한 Jupyter 위젯을 제공합니다.\n\n다음 명령을 실행하여 설치합니다:\n\n버튼을 클릭하여 데이터 주석을 쉽게 할 수 있습니다. 따라서 ipyannotate를 사용하면 버튼에 데이터 레이블을 부착할 수 있습니다.\n\n고양이와 개의 이미지가 있는 경우(라벨이 없음) 주석 처리 파이프라인을 다음과 같이 생성할 수 있습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*HyBsbKP8jtnB-srveBSDwA.gif\" /\u003e\n\n위에 표시된 것처럼 해당 버튼을 클릭하기만 하면 데이터를 주석으로 달 수 있습니다.\n\n더불어, 레이블을 검색하고 필요에 따라 데이터 파이프라인에 사용할 수도 있습니다.\n\n# #3 주피터에서 문서 보기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nJupyter에서 작업할 때 함수의 매개변수를 잊기 쉽고 공식 문서(또는 StackOverflow)를 방문하는 것이 일반적입니다.\n\n그러나 노트북 자체에서 문서를 볼 수 있습니다.\n\nShift-Tab 키를 누르면 문서 패널이 열립니다. 이 기능은 매우 유용하며 공식 문서를 매번 열 필요가 없어 시간을 절약할 수 있습니다.\n\n아래에서 데모를 보여드립니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*BoRuu6MfmFfjACuXrPpjrg.gif)\n\nThis feature also works for your custom functions.\n\n## 4. Get Notified When Jupyter Cell Has Executed\n\nAfter running some code in a Jupyter cell, we often navigate away to do some other work in the meantime.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기에서는 셀이 실행되었는지 여부를 확인하기 위해 반복적으로 주피터 탭으로 돌아가야 합니다.\n\n이를 피하기 위해, 주피터 노트북 확장 기능인 %%notify 매직 명령어를 사용할 수 있습니다.\n\n이름에서 알 수 있듯이, 이 매직 명령은 Jupyter 셀의 완료(성공 또는 실패) 시에 브라우저 알림을 통해 사용자에게 알려줍니다.\n\n설치하려면 다음 명령을 실행하세요:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음으로, 확장 기능을 로드하세요:\n\n그리고 끝났어요!\n\n이제 원하는 경우 알림을 받으려면 셀 맨 위에 다음의 매직 명령어를 입력하십시오:\n\n해당 셀이 실행을 완료하면 다음과 같은 알림을 받게 됩니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 마크다운 형식으로 된 테이블입니다.\n\n클릭하면 알림이 발생하여 Jupyter 탭으로 돌아갑니다.\n\n# #5 Jupyter Notebook에서 런타임 중 셀 출력 지우기\n\nJupyter를 사용하면 코드 진행 상황을 추적하기 위해 일반적으로 많은 세부 정보를 출력합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러나 출력 패널에 많은 세부 정보가 누적된 경우, 가장 최근의 출력만 관심이 있는 경우가 있기 때문에 짜증이 날 수 있습니다.\n\n게다가 매번 출력 맨 아래로 스크롤하는 것도 짜증스러울 수 있어요.\n\n셀의 출력을 지우려면 IPython 패키지에서 clear_output 메서드를 사용할 수 있어요.\n\nPython에 IPython이 미리 설치되어 있기 때문에 설치가 필요하지 않아요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래와 같이 해당 메서드를 가져올 수 있습니다:\n\n호출하면 셀의 현재 출력이 제거되며, 그 후에 최신 세부 정보를 출력할 수 있습니다.\n\n다음은 데모가 표시됩니다:\n\n![데모](https://miro.medium.com/v2/resize:fit:1400/1*HLiihJXmkIXB0vZg2DbTtA.gif)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위에서 보여드린 대로, 우리는 셀에서 가장 최근 출력만 볼 수 있습니다. 이전 출력물들은 지워집니다.\n\n# 보너스 팁\n\n위에서 언급한 팁들은 주피터를 더욱 풍요롭게 만들어줄 것이지만, 주피터에서 아직까지 해결하기 어려운 부분들이 많습니다.\n\n예를 들어, 주피터는 협업에 적합하지 않습니다. 로컬에서 실행되기 때문에, 실시간 협업 기능을 주피터에 내장하는 것이 불가능하며, 팀원들이 함께 작업하고, 댓글을 추가하고, 진행 상황을 추적하는 등의 작업을 할 수 없습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n게다가, 공유하기도 똑같이 까다로워요. 노트북을 누군가와 공유해야 한다면, 그럴 수 있는 방법은 그들에게 이메일을 보내거나 GitHub와 같은 온라인 서비스에 호스팅하여 링크를 공유하는 것뿐입니다.\n\n마지막으로, 많은 데이터 과학 작업은 파이썬으로만 제한되지 않아요. 그 작업에는 SQL도 불가피하게 관련되어 있는데, 이는 주로 조직의 데이터베이스와 상호작용하는 데 사용돼요.\n\n하지만, Jupyter에 SQL을 통합하는 것은 가능하지만 번거로운 과정이에요.\n\n## 해결책\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 한계에 좌절하며 대안을 찾기 시작했는데, Deepnote를 발견해서 정말 다행이었습니다.\n\nDeepnote는 제이퍼의 모든 한계를 쉽게 해결해 주었고, 기존의 제이퍼와 유사한 풍부한 경험을 제공해 주었습니다. 새로운 것을 배우지 않아도 되는 Deepnote를 사용하면, SQL 사용, 코드 없이 차트 생성, 데이터베이스 연결 등 모든 것이 원활하게 통합되어 있습니다.\n\n제이퍼가 모든 파이썬 사용자에게 일반화된 경험을 제공하려고 하는 것을 이해하지만, 데이터 과학자들의 고통 포인트를 전혀 해결하지 못한다는 사실을 이해합니다. 특히 팀으로 작업하는 데이터 과학자들에게는 더 그렇습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nDeepnote은 내 의견으로는 모든 데이터 주도 프로젝트에 대한 Jupyter의 초고속 버전입니다. 꼭 확인해보세요.\n\n# 결론\n\n이로써, 이 블로그의 끝에 도달했습니다.\n\nJupyter 노트북을 위한 멋진 팁 몇 가지를 배워 축하드립니다. 이 정보들이 여러분의 Python 프로그래밍 생산성을 높여줄 것이라고 확신합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저도 여러분이 주피터 노트북을 사용할 때 어떤 좋은 팁이 있나요? \n\n언제나 읽어 주셔서 감사합니다!\n\n🚀 오늘 구독하시면 320개 이상의 게시물과 550페이지 이상의 무료 데이터 과학 PDF를 받을 수 있습니다:\n\n![image](https://miro.medium.com/v2/resize:fit:1400/0*oW2adl2lbMY8ZplS.gif)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nDataDrivenInvestor.com에서 저희를 방문해 주세요.\n\nDDIntel을 여기에서 구독하실 수 있습니다.\n\n공유하고 싶은 독특한 이야기가 있나요? DDIntel로 제출해 주세요.\n\n저희 창조자 생태계에 여기서 참여해 보세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nDDIntel은 우리의 주요 사이트와 인기 있는 DDI Medium 출판물에서 주목할 만한 기사를 소개합니다. 우리 커뮤니티로부터 더 많은 통찰력 있는 작품을 확인해보세요.\n\nDDI 공식 텔레그램 채널: [링크](https://t.me/+tafUp6ecEys4YjQ1)\n\nLinkedIn, Twitter, YouTube, 그리고 Facebook에서 팔로우해주세요.","ogImage":{"url":"/TIL/assets/img/2024-07-13-5JupyterHacksThatYouNeverKnewEvenExisted_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-5JupyterHacksThatYouNeverKnewEvenExisted_0.png","tag":["Tech"],"readingTime":11}],"page":"15","totalPageCount":41,"totalPageGroupCount":3,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"15"},"buildId":"o6AmBAY_j9v9JmbaRA39X","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>