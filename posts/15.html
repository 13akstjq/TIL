<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>TIL</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//posts/15" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="TIL" data-gatsby-head="true"/><meta property="og:title" content="TIL" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//posts/15" data-gatsby-head="true"/><meta name="twitter:title" content="TIL" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/7978fe7362f7d4c9.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/7978fe7362f7d4c9.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/873-eb138c3217d71553.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/posts/%5Bpage%5D-de1dc5579188f9be.js" defer=""></script><script src="/TIL/_next/static/X4OrKfmLtU3-3BijwfHe6/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/X4OrKfmLtU3-3BijwfHe6/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Next.js 15 웹사이트 배포하는 5가지 방법" href="/TIL/post/2025-04-22-HowtodeployyourNextjsapplication"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15 웹사이트 배포하는 5가지 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15 웹사이트 배포하는 5가지 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15 웹사이트 배포하는 5가지 방법</strong><div class="PostList_meta__VCFLX"><span class="date">20 hours ago</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js 15에서 메타데이터 추가 및 OG 이미지 생성하는 방법" href="/TIL/post/2025-04-22-HowtoaddmetadataandcreateOGimages"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15에서 메타데이터 추가 및 OG 이미지 생성하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15에서 메타데이터 추가 및 OG 이미지 생성하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15에서 메타데이터 추가 및 OG 이미지 생성하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">20 hours ago</span><span class="PostList_reading_time__6CBMQ">15<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="TypeScript와 ReactJS에서 에러 처리하는 5가지 방법" href="/TIL/post/2025-04-22-Howtohandleerrors"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="TypeScript와 ReactJS에서 에러 처리하는 5가지 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="TypeScript와 ReactJS에서 에러 처리하는 5가지 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">TypeScript와 ReactJS에서 에러 처리하는 5가지 방법</strong><div class="PostList_meta__VCFLX"><span class="date">20 hours ago</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="nextjs 15 서버 컴포넌트에서 데이터 업데이트 하는 방법 " href="/TIL/post/2025-04-22-Howtoupdatedata"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="nextjs 15 서버 컴포넌트에서 데이터 업데이트 하는 방법 " loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="nextjs 15 서버 컴포넌트에서 데이터 업데이트 하는 방법 " loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">nextjs 15 서버 컴포넌트에서 데이터 업데이트 하는 방법 </strong><div class="PostList_meta__VCFLX"><span class="date">20 hours ago</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js 15에서 데이터 fetch하는 방법" href="/TIL/post/2025-04-22-Howtofetchdataandstream"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15에서 데이터 fetch하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15에서 데이터 fetch하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15에서 데이터 fetch하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">20 hours ago</span><span class="PostList_reading_time__6CBMQ">17<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="2025년 ReactJS와 Next.js에서 CSS를 가장 쉽게 사용하는 방법" href="/TIL/post/2025-04-22-HowtouseCSSinyourapplication"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="2025년 ReactJS와 Next.js에서 CSS를 가장 쉽게 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="2025년 ReactJS와 Next.js에서 CSS를 가장 쉽게 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">2025년 ReactJS와 Next.js에서 CSS를 가장 쉽게 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">20 hours ago</span><span class="PostList_reading_time__6CBMQ">25<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nextjs 15에서 이미지와 폰트 최적화하는 방법" href="/TIL/post/2025-04-22-Howtooptimizeimagesandfonts"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nextjs 15에서 이미지와 폰트 최적화하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nextjs 15에서 이미지와 폰트 최적화하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Nextjs 15에서 이미지와 폰트 최적화하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">20 hours ago</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js 15에서 레이아웃과 페이지 쉽게 만드는 방법" href="/TIL/post/2025-04-22-Howtocreatelayoutsandpages"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15에서 레이아웃과 페이지 쉽게 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15에서 레이아웃과 페이지 쉽게 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15에서 레이아웃과 페이지 쉽게 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">20 hours ago</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js 15 프로젝트 폴더 설계 방법" href="/TIL/post/2025-04-22-Projectstructureandorganization"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15 프로젝트 폴더 설계 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15 프로젝트 폴더 설계 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15 프로젝트 폴더 설계 방법</strong><div class="PostList_meta__VCFLX"><span class="date">20 hours ago</span><span class="PostList_reading_time__6CBMQ">20<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js 14 2025년 최신 프로젝트 세팅 방법" href="/TIL/post/2025-04-22-HowtosetupanewNextjsproject"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 14 2025년 최신 프로젝트 세팅 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 14 2025년 최신 프로젝트 세팅 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 14 2025년 최신 프로젝트 세팅 방법</strong><div class="PostList_meta__VCFLX"><span class="date">20 hours ago</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/TIL/posts/1">1</a><a class="link" href="/TIL/posts/2">2</a><a class="link" href="/TIL/posts/3">3</a><a class="link" href="/TIL/posts/4">4</a><a class="link" href="/TIL/posts/5">5</a><a class="link" href="/TIL/posts/6">6</a><a class="link" href="/TIL/posts/7">7</a><a class="link" href="/TIL/posts/8">8</a><a class="link" href="/TIL/posts/9">9</a><a class="link" href="/TIL/posts/10">10</a><a class="link" href="/TIL/posts/11">11</a><a class="link" href="/TIL/posts/12">12</a><a class="link" href="/TIL/posts/13">13</a><a class="link" href="/TIL/posts/14">14</a><a class="link posts_-active__YVJEi" href="/TIL/posts/15">15</a><a class="link" href="/TIL/posts/16">16</a><a class="link" href="/TIL/posts/17">17</a><a class="link" href="/TIL/posts/18">18</a><a class="link" href="/TIL/posts/19">19</a><a class="link" href="/TIL/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Next.js 15 웹사이트 배포하는 5가지 방법","description":"","date":"2025-04-22 01:19","slug":"2025-04-22-HowtodeployyourNextjsapplication","content":"\n\n# Next.js 애플리케이션 배포하는 방법\n\nNext.js 앱 개발을 끝내고 배포할 준비가 됐다면, 크게 두 가지 방법이 있어요. 하나는 관리형 인프라 제공업체(Managed Infrastructure Provider)를 이용하는 거고, 다른 하나는 직접 서버를 세팅해서 호스팅하는 방법이죠.\n\n## 관리형 인프라 제공업체 이용하기\n\n관리형 플랫폼은 Next.js 앱 배포할 때 꽤 편리한 선택이에요. 이 업체들은 호스팅부터 서버 설정, 스케일링(트래픽에 맞춰 서버 용량 자동 조절)까지 알아서 해주기 때문에 개발자는 코드에만 집중할 수 있거든요.\n\n예를 들어, Vercel, Netlify, AWS Amplify 같은 곳이 대표적이에요. 특히 Next.js를 만든 회사가 운영하는 Vercel은 Next.js 최적화가 잘 돼 있어서 배포가 아주 간편하죠.\n\n관리형 플랫폼의 장점은:\n\n- 별도의 서버 관리 없이 빠른 배포 가능\n- 트래픽 변화에 따라 자동으로 스케일링\n- HTTPS, CDN 등 보안과 퍼포먼스도 기본 제공  \n- CI/CD (코드 변경 시 자동 배포)도 쉽게 설정할 수 있어요\n\n사실 초보자나 소규모 프로젝트에는 관리형 플랫폼이 가장 추천되는 방법입니다. 물론 비용은 트래픽과 사용량에 따라 달라지니 참고하세요!\n\n---\n\n다음은 직접 서버를 세팅해서 호스팅하는 방법도 있는데, 그 부분도 궁금하면 알려드릴게요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nVercel은 Next.js의 제작자이자 유지 관리자이며, 별도의 설정 없이도 풀 기능을 지원하는 애플리케이션 배포를 할 수 있게 도와줍니다.\n\n- Vercel에서 Next.js에 대해 더 알아보기  \n- Vercel에서 템플릿을 배포해 Next.js를 직접 사용해보기  \n\n그리고 커뮤니티에서 관리하는 배포 템플릿도 준비되어 있는데요, 다음 플랫폼들을 지원합니다:\n\n| 플랫폼 이름    | 설명                   |\n|---------------|------------------------|\n| Deno          | 최신 자바스크립트와 타임스크립트 런타임 |\n| Flightcontrol | 서버리스 배포 관리 도구 |\n| Railway       | 간편한 클라우드 인프라 서비스 |\n| Render        | 풀 매니지드 클라우드 플랫폼 |\n| SST           | 서버리스 스택 개발 프레임워크 |\n\nVercel을 이용하면 복잡한 설정 없이도 Next.js 앱뿐만 아니라, 다양한 환경에서 쉽게 배포할 수 있어서 개발 생산성이 쑥쑥 올라가요. 특히 요즘처럼 빠르게 웹 애플리케이션을 배포하고 테스트해야 할 때는 정말 유용하니 한 번 써보시길 추천합니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js를 사용할 때, 각 클라우드 제공업체마다 지원하는 기능들이 조금씩 다르니 꼭 해당 업체의 문서를 참고하는 게 좋아요.\n\n## 직접 호스팅(Self-Hosting)이란?\n\n직접 호스팅은 서버를 직접 준비하고, 컨테이너를 관리하며, 트래픽에 맞춰 확장하는 모든 걸 직접 책임져야 한다는 뜻이에요. 직접 호스팅하는 방법은 크게 세 가지가 있어요:\n\n| 직접 호스팅 방식        | 설명                                           |\n|------------------|----------------------------------------------|\n| Node.js 서버       | Next.js 앱을 직접 Node.js 서버에서 실행해요.        |\n| Docker 컨테이너    | Next.js 앱을 Docker 컨테이너 안에서 실행해 관리해요.    |\n| 정적 내보내기(Static Export) | Next.js를 정적 사이트로 빌드해, 서버 없이도 배포해요.     |\n\n이 중에서 어떤 방식을 선택하느냐는 프로젝트의 필요와 리소스에 따라 달라져요. 예를 들어, 실시간 데이터 처리나 서버 사이드 렌더링이 필요하면 Node.js 서버나 Docker를 사용하는 게 좋고, 콘텐츠가 주로 정적인 경우라면 정적 내보내기를 고려해볼 수 있겠죠.\n\n참고로 Docker를 사용하면 배포가 좀 더 일관되고, 확장하거나 환경을 맞추기도 쉬워서 최근 많이 선호되는 편이에요. 혹시 직접 서버 세팅이 부담된다면, 서버리스(서버 없는) 플랫폼들도 있으니 다음에 다뤄볼게요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n커뮤니티에서 관리하는 다양한 셀프 호스팅 예제들이 있어요. 아래는 대표적인 셀프 호스팅 제공업체들이에요:\n\n- DigitalOcean\n- Fly.io\n- GitHub Pages\n- Google Cloud Run\n\n그리고 참고할 만한 영상도 추천해드릴게요! Next.js를 셀프 호스팅하는 방법을 45분 동안 자세히 알려주는 유튜브 영상이에요. 직접 셀프 호스팅에 도전해보고 싶다면 꼭 한번 보세요! 🎥\n\n---\n셀프 호스팅을 하면서 각 플랫폼마다 특징이 조금씩 달라요. 예를 들어, DigitalOcean은 가상 서버를 직접 관리하는 느낌이고, Fly.io는 글로벌 엣지 네트워크를 활용할 수 있어서 빠른 응답 속도를 자랑합니다. GitHub Pages는 정적 사이트 배포에 딱 좋고, Google Cloud Run은 컨테이너 기반 서비스라 자동 확장에 유리하답니다.\n\n혹시 셀프 호스팅이 처음이라면, 본인이 원하는 서비스 규모와 관리 난이도에 맞는 플랫폼 선택이 중요해요. 또, 배포 자동화를 위해 GitHub Actions나 CI/CD 도구들을 같이 사용하는 것도 좋은 팁이니 참고해보세요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":4},{"title":"Next.js 15에서 메타데이터 추가 및 OG 이미지 생성하는 방법","description":"","date":"2025-04-22 01:18","slug":"2025-04-22-HowtoaddmetadataandcreateOGimages","content":"\n# 메타데이터 추가와 OG 이미지 만들기 방법\n\n웹 개발하다 보면 SEO(검색 엔진 최적화)나 SNS 공유 시 내 페이지가 더 멋지게 보이도록 메타데이터와 OG(Open Graph) 이미지를 설정하는 게 정말 중요하죠. Next.js에서는 이런 걸 엄청 쉽게 할 수 있도록 메타데이터용 API들을 제공해요.\n\n예를 들면,\n\n- **정적 메타데이터 객체(static metadata object)**\n- **동적으로 메타데이터를 생성하는 함수(generateMetadata)**\n- 그리고 정적 혹은 동적으로 생성되는 파비콘(favicon)이나 OG 이미지를 넣기 위한 특별한 파일 규칙\n\n이런 옵션들을 사용해서, Next.js가 알아서 해당 페이지에 필요한 `\u003chead\u003e` 태그를 생성해줘요. 그래서 개발자 도구에서 살펴보면 자동으로 쭉 생성된 걸 확인할 수 있답니다.\n\n---\n\n## 좀 더 자세히 설명해볼게요!\n\n### 1. 정적 메타데이터 객체 (Static Metadata)\n\n간단하게 `metadata`라는 객체를 만들고, 그 안에 title, description, og:image 같은 정보를 딱 고정시켜 넣을 수 있어요.\n\n```js\nexport const metadata = {\n  title: \"내 Awesome 페이지\",\n  description: \"여기는 내 멋진 Next.js 앱이에요.\",\n  openGraph: {\n    images: [\"/og-image.png\"],\n  },\n};\n```\n\n이렇게 해놓으면 해당 정보가 자동으로 `\u003chead\u003e` 안에 들어가서 SEO 효과도 보고, 페이스북이나 트위터에 공유할 때 예쁜 카드로 나와요.\n\n### 2. 동적 메타데이터 생성 (Dynamic generateMetadata)\n\n예를 들어, 블로그 포스트마다 제목이나 설명이 다를 때, 함수 형태로 만들면 요청할 때마다 데이터를 받아서 메타데이터를 바꿔줄 수 있어요.\n\n```js\nexport async function generateMetadata({ params }) {\n  const post = await getPostData(params.id);\n\n  return {\n    title: post.title,\n    description: post.summary,\n    openGraph: {\n      images: [post.ogImage],\n    },\n  };\n}\n```\n\n이렇게 하면 매번 해당 글에 맞는 메타데이터가 동적으로 들어가니까, SEO랑 SNS 공유가 훨씬 좋아지죠.\n\n### 3. 파비콘과 OG 이미지 자동설정\n\nNext.js에서는 `favicon.ico` 같은 파일을 프로젝트 루트에 두거나, OG 이미지를 특정 경로에 두면 자동으로 인식해줘요.\n\n특히, OG 이미지는 요즘 꼭 넣어야 하는데, 일부러 직접 `\u003cmeta property=\"og:image\" ...\u003e` 태그 안 넣어도 Next.js가 알아서 해주는 점이 편리해요.\n\n---\n\n## 함께 알아두면 좋은 팁\n\n- **OG 이미지 사이즈**: 일반적으로 1200x630 픽셀 정도가 적당해요. 너무 작으면 카드가 깔끔하게 안 나오고, 너무 크면 로딩에 부담이 돼요.\n- **SEO와 UX도 같이 챙기자**: 메타데이터는 검색 결과뿐만 아니라, 실제 사용자가 공유 링크를 클릭하는 경험에도 영향을 줘요. 좋은 제목과 설명, 이미지가 방문자 증가로 이어질 수 있어요.\n- **Next.js 문서 참고**: Next.js 공식 문서에 메타데이터 관련 가이드가 아주 잘 정리되어 있으니, 실습해보면서 익히면 더 도움이 될 거예요.\n\n---\n\n메타데이터와 OG 이미지를 신경 쓰면, 우리 앱이나 웹사이트가 한층 더 프로페셔널하고, 사용자에게 친숙하게 다가갈 수 있으니 꼭 적용해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 기본 필드 (Default fields)\n\n웹사이트를 만들 때, 라우트(route)에 메타데이터(metadata)를 따로 정의하지 않아도 자동으로 추가되는 기본 메타 태그(meta tag)가 두 가지 있어요. 이 두 가지는 웹 페이지가 제대로 보이고 작동하는 데 꼭 필요한 친구들입니다.\n\n- **`\u003cmeta charset=\"utf-8\" /\u003e`**\n  - 이 태그는 웹페이지에서 사용되는 문자 인코딩을 UTF-8로 설정해줘요.\n  - UTF-8은 한글, 영어, 이모지 등 다양한 문자를 모두 지원하기 때문에 대부분의 웹사이트에서 기본으로 사용하고 있답니다.\n- **`\u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /\u003e`**\n  - 스마트폰이나 태블릿 같은 다양한 디바이스에서 화면 크기와 초기 확대 비율(scale)을 조절해주는 태그예요.\n  - 만약 이 태그가 없다면, 모바일 화면에서 회원가입 폼이나 메뉴가 너무 작게 보이거나, 반대로 너무 커져서 사용하기 어려워질 수 있어요.\n\n```html\n\u003cmeta charset=\"utf-8\" /\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /\u003e\n```\n\n\u003e 참고로, 다양한 메타 태그들이 있지만 이 두 개는 모든 HTML 문서에 꼭 넣어줘야 하는 기본 중의 기본입니다. 덕분에 사용자들이 어느 디바이스로 접속해도 글자가 깨지지 않고, 화면도 적절하게 보여서 사용자 경험(UX)이 좋아지죠!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n메타데이터(metadata)를 다룰 때, 정적인 메타데이터(static metadata)와 동적으로 생성되는 메타데이터(generated metadata)를 정의하는 방법이 있어요. 정적인 메타데이터는 정해진 값 그대로 사용하고, 동적인 메타데이터는 컴포넌트 내 함수로 데이터를 생성해서 설정할 수 있죠.\n\n---\n\n## 정적 메타데이터 (Static Metadata)\n\n정적 메타데이터를 만들고 싶다면, `layout.js`나 `page.js` 같은 정적인 파일에서 `Metadata` 객체를 `export` 하면 됩니다. 예를 들어, 블로그 페이지에 제목과 설명을 추가하고 싶을 때 코드는 이렇게 작성할 수 있어요:\n\n```js\nimport type { Metadata } from \"next\";\n\nexport const metadata: Metadata = {\n  title: \"My Blog\",\n  description: \"...\",\n};\n\nexport default function Page() {}\n```\n\n위 코드를 보면 `metadata`라는 이름으로 메타데이터를 내보내고 있고, 타입도 명확히 `Metadata`로 지정해줬습니다. 이렇게 하면 Next.js가 해당 페이지를 렌더링할 때 이 메타데이터를 자동으로 인식해서 `\u003chead\u003e` 태그에 적절한 메타 정보를 넣어주죠.\n\n---\n\n### 추가 팁!\n\n- `title`은 화면의 탭 제목으로도 노출되니, 페이지별로 명확하고 간결하게 작성하는 게 좋아요.\n- `description`은 SEO에 중요한 역할을 하니까, 페이지 내용과 맞는 적절한 설명을 넣어줘야 합니다.\n- 메타데이터는 페이지가 최초로 로드될 때만 적용되므로, 자주 바뀌는 값은 동적 메타데이터 방식을 사용하세요.\n\n정리하자면, 페이지마다 변하지 않는 고정된 정보(예: 사이트 이름, 정적 설명)를 넣을 땐 `metadata` 객체를 이용하는 것이 가장 손쉽고 직관적입니다. 다음에는 동적으로 메타데이터를 생성하는 방법도 알려드릴게요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\ngenerateMetadata 함수로 동적인 메타데이터를 쉽게 가져올 수 있어요. 예를 들어 특정 블로그 포스트의 제목과 설명을 API에서 받아오고 싶다면 이렇게 작성하면 됩니다:\n\n```js\nimport type { Metadata, ResolvingMetadata } from 'next'\n\ntype Props = {\n  params: Promise\u003c{ id: string }\u003e\n  searchParams: Promise\u003c{ [key: string]: string | string[] | undefined }\u003e\n}\n\nexport async function generateMetadata(\n  { params, searchParams }: Props,\n  parent: ResolvingMetadata\n): Promise\u003cMetadata\u003e {\n  const slug = (await params).slug\n\n  // API에서 포스트 정보 가져오기\n  const post = await fetch(`https://api.vercel.app/blog/${slug}`).then(res =\u003e\n    res.json()\n  )\n\n  return {\n    title: post.title,\n    description: post.description,\n  }\n}\n\nexport default function Page({ params, searchParams }: Props) {}\n```\n\n### 여기서 조금 더 알려드리자면\n\n- `generateMetadata`는 Next.js에서 페이지에 필요한 메타 정보를 서버사이드에서 미리 가져와서 SEO에 유리하게 사용할 수 있게 해줘요.\n- `params`와 `searchParams`는 라우팅 정보와 쿼리 스트링 정보를 Promise 형태로 받아오는데, 이걸 `await` 해서 실제 값을 꺼내 써야 합니다.\n- 메타데이터엔 `title`, `description` 외에도 `openGraph`, `twitter` 같은 소셜 미디어용 메타 정보도 포함할 수 있어요.\n- 만약 API가 느리거나, 자주 바뀌지 않는 경우엔 캐싱 전략도 고민해보세요. 서버 부담도 줄이면서 사용자 경험을 더 좋게 만들 수 있답니다.\n\n이렇게 `generateMetadata`를 잘 활용하면 각 페이지마다 동적인 메타데이터를 쉽게 관리할 수 있어서 SEO 최적화에 큰 도움이 돼요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js 내부에서는 메타데이터를 UI와 별도로 스트리밍하고, 메타데이터가 준비되는 대로 HTML에 바로 주입하는 방식으로 동작해요. 덕분에 사용자에게 더 빠르게 정보를 보여줄 수 있답니다.\n\n### 데이터 요청 memoization (메모이제이션)\n\n메타데이터를 렌더링할 때와 페이지를 렌더링할 때 동일한 데이터를 여러 번 요청해야 하는 상황이 생길 수 있어요. 이럴 때 매번 중복해서 데이터를 요청하면 비효율적이죠. 그래서 React의 `cache` 함수를 활용해 데이터를 한번만 가져오고 결과를 메모이제이션해서 재사용할 수 있어요.\n\n예를 들어, 블로그 포스트 정보를 메타데이터 생성과 페이지 렌더링에 모두 사용해야 할 때 이렇게 작성할 수 있습니다:\n\n```js\nimport { cache } from \"react\";\nimport { db } from \"@/app/lib/db\";\n\n// getPost 함수는 두 번 호출되지만, 실제로는 한 번만 실행돼요\nconst getPost = cache(async (slug) =\u003e {\n  const res = await db.query.posts.findFirst({ where: eq(posts.slug, slug) });\n  return res;\n});\n```\n\n이렇게 하면 같은 `slug`에 대해 여러 번 호출해도 데이터베이스 쿼리는 한 번만 실행되니까 성능이 쑥~ 좋아지죠.\n\n---\n\n추가로, Next.js 13 이상부터 데이터 패칭에서 이런 memoization을 자주 활용할 텐데, 이 기능 덕분에 서버 측 렌더링 시 효율적으로 데이터를 관리할 수 있어요. 만약 `getPost`를 여러 컴포넌트에서 공유하고 싶다면 별도의 유틸 파일에 묶어두고 재사용하는 것도 좋은 패턴입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자, 이번에는 Next.js에서 동적으로 메타데이터를 생성하는 방법과 함께 파비콘(Favicon)을 추가하는 기본적인 방법에 대해 살펴보려고 해요.\n\n---\n\n## 1. 동적 메타데이터 생성하기\n\n```tsx\nimport { getPost } from \"@/app/lib/data\";\n\nexport async function generateMetadata({ params }: { params: { slug: string } }) {\n  // URL 파라미터(slug)를 이용해서 해당 게시글 데이터를 가져와요\n  const post = await getPost(params.slug);\n  return {\n    title: post.title, // 동적으로 페이지 타이틀 설정\n    description: post.description, // 동적으로 메타 설명 설정\n  };\n}\n\nexport default async function Page({ params }: { params: { slug: string } }) {\n  const post = await getPost(params.slug);\n  return \u003cdiv\u003e{post.title}\u003c/div\u003e;\n}\n```\n\n위 코드는 Next.js 13의 새로운 라우팅 방식에서 메타 태그를 동적으로 생성하는 대표적인 예시예요. `params.slug`를 통해 URL에 맞는 글 내용을 서버 사이드에서 불러온 다음, 해당 글 제목과 설명을 메타 태그에 넣어 주는 방식이죠.\n\n\u003e 🔥 참고: `generateMetadata` 함수는 페이지 렌더링 전에 호출되므로, SEO 최적화에 아주 유리합니다.\n\n---\n\n## 2. 파비콘(Favicon) 추가하기\n\n파비콘은 웹 브라우저 탭이나 북마크에 표시되는 작은 아이콘이에요. 사이트의 아이덴티티를 표현하는 데 아주 중요한 역할을 하죠. 간단하게 적용하는 방법을 알려드릴게요.\n\n### 방법\n\n- `favicon.ico` 파일을 프로젝트의 **루트 폴더 (`app` 폴더)**에 넣어주세요.\n- Next.js는 기본적으로 루트에 있는 `favicon.ico`를 자동으로 인식해서 `\u003chead\u003e`에 추가해 줍니다.\n\n만약 `favicon.ico` 대신 PNG 등 다른 형식을 쓴다면, `app/head.tsx` 혹은 `app/layout.tsx` 내에서 직접 설정해야 해요.\n\n```tsx\n// app/head.tsx 예시\nexport default function Head() {\n  return (\n    \u003c\u003e\n      \u003clink rel=\"icon\" href=\"/favicon.ico\" /\u003e\n      {/* 다른 메타 태그들도 여기에 추가 가능 */}\n    \u003c/\u003e\n  );\n}\n```\n\n---\n\n## 추가 팁!\n\n- 파비콘을 만드는 데 어려움을 겪는다면 [favicon.io](https://favicon.io/) 같은 온라인 툴을 써서 쉽게 만들 수 있어요.\n- 요즘에는 다양한 해상도(16x16, 32x32, 48x48, 64x64 등)로 미리 준비하는 것이 좋고, 모바일 앱 아이콘이나 Apple 터치 아이콘용으로 별도 이미지를 준비하는 경우도 많답니다.\n\n---\n\n## 요약\n\n| 내용                 | 설명                                                                   |\n| -------------------- | ---------------------------------------------------------------------- |\n| 동적 메타데이터 생성 | `generateMetadata` 함수로 SEO 최적화와 동적 페이지 제목/설명 설정 가능 |\n| 파비콘 추가          | `favicon.ico`를 `app` 폴더에 추가하거나 `\u003chead\u003e`에서 직접 링크를 명시  |\n\n---\n\n![파비콘 설정 이미지](/TIL/img/2025-04-22-HowtoaddmetadataandcreateOGimages_0.png)\n\n파비콘과 메타데이터를 제대로 설정하면 SEO뿐 아니라 사용자 경험도 훨씬 좋아지니 꼭 챙겨보시길 바랄게요!  \n필요하면 댓글로 질문 남겨 주세요! 😊\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003e 프로그래밍으로도 파비콘(favicon)을 자동 생성할 수 있어요. 더 자세한 내용은 파비콘 관련 문서를 참고해 보세요.\n\n## 정적 Open Graph 이미지 만들기\n\nOpen Graph(OG) 이미지는 SNS에서 내 사이트를 대표하는 이미지예요. 내 앱에 정적인 OG 이미지를 추가하려면, 앱 폴더(root 디렉토리)에 `opengraph-image.png` 파일을 넣으면 돼요.\n\n예를 들어 이렇게 생긴 이미지가 해당 파일일 수 있겠죠:\n\n| ![Open Graph 이미지 예시](https://your-site.com/assets/img/2025-04-22-HowtoaddmetadataandcreateOGimages_1.png) |\n| :------------------------------------------------------------------------------------------------------------: |\n|                                            _Open Graph 이미지 예시_                                            |\n\n이렇게 OG 이미지를 설정해 두면, 페이스북이나 트위터 같은 SNS에 내 웹사이트 링크를 공유할 때 예쁜 썸네일로 보여줘서 사용자 경험을 훨씬 더 좋게 만들 수 있답니다.\n\n추가로, OG 이미지는 보통 1200x630 픽셀 정도 크기를 권장해요. 그래야 각 SNS에서 최적화되어 잘 보이거든요. 또한, 만약 동적인 OG 이미지를 만들고 싶다면, 코드로 이미지를 생성하는 방법도 있으니, 나중에 활용해 보시면 좋겠네요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n특정 경로에 대해 OG 이미지를 추가하고 싶다면, 해당 경로 폴더 안에 opengraph-image.png 파일을 만들어주면 돼요. 예를 들어, /blog 경로에 맞는 OG 이미지를 추가하고 싶다면 blog 폴더 안에 opengraph-image.jpg 파일을 넣으면 됩니다.\n\n\u003cimg src=\"/TIL/assets/img/2025-04-22-HowtoaddmetadataandcreateOGimages_2.png\" /\u003e\n\n폴더 구조에서 더 깊숙한 경로에 있는 이미지가 우선해서 적용된다는 점, 기억하세요!\n\n\u003e 참고로 jpeg, png, webp 같은 다른 이미지 포맷도 지원되니까 상황에 맞게 사용하면 됩니다. 더 자세한 내용은 Open Graph Image 문서를 참고해 보세요.\n\n추가로 팁을 드리자면, 여러 경로에 공통으로 쓰이는 기본 OG 이미지를 루트 폴더에 넣고, 그 이미지를 기본값처럼 설정해놓으면 관리가 훨씬 수월해요. 필요한 특정 페이지에는 별도의 이미지를 넣어서 덮어쓰면 되고요. 이렇게 하면 SEO 최적화와 SNS 공유 시 더 세련된 미리보기 이미지를 보여줄 수 있답니다!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 동적으로 생성하는 오픈 그래프(Open Graph) 이미지 만들기\n\nOpen Graph 이미지는 페이스북, 트위터 같은 소셜 미디어에 링크를 공유할 때 보이는 미리보기 이미지라고 생각하면 편해요. 이 이미지를 글마다 다르게 자동 생성하면 훨씬 프로페셔널해 보이죠? Next.js의 `ImageResponse` 생성자를 사용하면 JSX와 CSS로 동적인 이미지를 쉽게 만들 수 있어요.\n\n### 사용법 예시\n\n아래 코드는 블로그 포스트마다 고유한 OG 이미지를 생성하는 방법입니다. 블로그 폴더 내에 `opengraph-image.ts` 파일을 만들고, `next/og`에서 `ImageResponse`를 불러와 사용해요.\n\n```js\nimport { ImageResponse } from \"next/og\";\nimport { getPost } from \"@/app/lib/data\";\n\n// 이미지 메타 정보\nexport const size = {\n  width: 1200,\n  height: 630,\n};\n\nexport const contentType = \"image/png\";\n\n// 이미지 생성 함수\nexport default async function Image({ params }: { params: { slug: string } }) {\n  const post = await getPost(params.slug);\n\n  return new ImageResponse(\n    (\n      // ImageResponse에서 그릴 JSX 요소\n      \u003cdiv\n        style={{\n          fontSize: 128,\n          background: \"white\",\n          width: \"100%\",\n          height: \"100%\",\n          display: \"flex\",\n          alignItems: \"center\",\n          justifyContent: \"center\",\n        }}\n      \u003e\n        {post.title}\n      \u003c/div\u003e\n    )\n  );\n}\n```\n\n### 코드 설명\n\n| 항목          | 설명                                                                        |\n| ------------- | --------------------------------------------------------------------------- |\n| `size`        | 생성할 이미지 크기 설정 (픽셀 단위)                                         |\n| `contentType` | 이미지 포맷 (ex. 'image/png')                                               |\n| `Image` 함수  | 요청 파라미터로 슬러그를 받아 포스트 데이터 조회 후, 제목을 이미지로 렌더링 |\n\n### 더 알아두면 좋은 팁들\n\n- **CSS 스타일링 자유자재**  \n  위 예제에선 아주 간단하게 이미지를 그렸지만, `ImageResponse`로는 거의 대부분의 CSS 스타일을 적용할 수 있어요. 배경 색상, 폰트, 레이아웃, 심지어 그림자효과나 그라디언트도 가능하죠.\n\n- **더 정교한 디자인을 원한다면?**  \n  외부 폰트를 사용하거나 SVG 아이콘, 이미지 등을 조합하고 싶다면, `next/og`에서 지원하는 한도 내에서 최대한 활용해보세요. 단, 웹 폰트 로딩 시에는 약간의 설정이 필요할 수 있습니다.\n\n- **이미지 캐싱 고려하기**  \n  동적으로 이미지가 생성되다 보니, 잘못 설정하면 성능이나 비용 측면에서 문제가 될 수 있어요. Next.js의 Incremental Static Regeneration이나 Cache-Control 헤더 등을 적절히 활용해 캐싱 전략을 짜는 걸 추천합니다.\n\n이렇게 동적으로 생성하는 Open Graph 이미지로 SNS에 공유될 때 더 눈에 띄는 내 컨텐츠를 만들어 보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nImageResponse는 flexbox, 절대 위치 지정(absolute positioning), 커스텀 폰트, 텍스트 줄바꿈, 텍스트 중앙 정렬, 중첩 이미지 같은 일반적인 CSS 속성을 지원해요. 어떤 CSS 속성들이 지원되는지 전체 목록도 확인할 수 있으니 필요할 때 참고하면 좋습니다.\n\n\u003e 참고할 점:\n\u003e Vercel OG Playground에서 다양한 예제를 직접 확인해볼 수 있어요.\n\n내부적으로 ImageResponse는 @vercel/og, Satori, 그리고 Resvg 라이브러리를 사용해서 HTML과 CSS를 PNG 이미지로 변환합니다. 다만, flexbox와 일부 CSS 속성만 지원하기 때문에 display: grid 같은 고급 레이아웃은 작동하지 않는다는 점 기억하세요.\n\n쉽게 말해, 복잡한 레이아웃보다는 깔끔하게 정리된 flexbox 기반 레이아웃에 더 적합하다고 보면 됩니다. 만약 이미지 생성에 관심 있다면 Vercel OG Playground에서 실습해보며 감을 잡는 걸 추천해요!\n","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":15},{"title":"TypeScript와 ReactJS에서 에러 처리하는 5가지 방법","description":"","date":"2025-04-22 01:16","slug":"2025-04-22-Howtohandleerrors","content":"\n# 에러 처리하는 법\n\n에러는 크게 두 가지로 나눌 수 있어요: 예상 가능한 에러와 잡히지 않은 예외(uncaught exceptions)죠. 이번 글에서는 Next.js 앱에서 이런 에러들을 어떻게 다룰 수 있는지 쉽게 알려드릴게요.\n\n## 예상 가능한 에러 처리하기\n\n예상 가능한 에러는 앱이 정상적으로 작동하는 중에 발생할 수 있는 에러예요. 예를 들어 서버 쪽 폼 검증에서 실패할 때나, API 요청이 실패하는 경우죠. 이런 에러들은 명확하게 처리해서 클라이언트한테 적절하게 전달해줘야 해요.\n\n사실 이런 에러들은 사용자 경험에도 영향을 많이 주기 때문에, 단순히 ‘문제가 발생했습니다’라고 하는 것보단, 어떤 문제가 있는지 구체적으로 알려주는 게 중요해요. 예를 들어, 폼에서 이메일 형식이 맞지 않으면 \"이메일 형식이 올바르지 않습니다\"라고 바로 알려주면 사용자가 수정할 수 있잖아요?\n\nNext.js에서는 서버 사이드 코드에서 이런 에러들을 try-catch 문으로 잡아서, 적절한 HTTP 상태 코드와 메시지로 응답을 줄 수 있어요. 클라이언트 쪽에서는 그 응답을 받아서 UI에 에러 메시지를 띄우거나, 특정 행동을 유도하도록 하면 됩니다.\n\n혹시 에러를 다루는 게 처음이라면, ‘에러 핸들링 레이어’를 따로 만들어서 코드를 깔끔하게 관리하는 것도 추천해요. 그래야 에러 처리 로직이 여러 군데 흩어지지 않고, 수정도 편리해요.\n\n다음에는 잡히지 않은 예외, 즉 예기치 않은 오류가 발생했을 때 어떻게 대처하는지도 알려드릴게요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 서버 함수에서 예상 에러 처리하기\n\n서버 함수(Server Functions)를 작성할 때, 예상되는 에러를 다루는 방법에 대해 이야기해볼게요. 보통 자바스크립트에서 에러가 발생하면 try/catch로 잡거나 `throw`를 해서 에러를 던지죠? 그런데 서버 함수에서는 이런 방식보다는 **예상 가능한 에러를 반환값(return value)**으로 모델링하는 게 좋아요.\n\n예를 들어, 아래와 같이 `createPost`라는 서버 함수를 만들었을 때, API 호출이 실패하는 경우를 생각해볼게요.\n\n```js\n\"use server\";\n\nexport async function createPost(prevState: any, formData: FormData) {\n  const title = formData.get(\"title\");\n  const content = formData.get(\"content\");\n\n  const res = await fetch(\"https://api.vercel.app/posts\", {\n    method: \"POST\",\n    body: { title, content },\n  });\n  const json = await res.json();\n\n  if (!res.ok) {\n    return { message: \"Failed to create post\" };\n  }\n}\n```\n\n여기서 실패하면 그냥 `throw` 대신 `{ message: 'Failed to create post' }`라는 객체를 반환하고 있죠? 이렇게 하면 클라이언트 쪽에서 이 반환값을 이용해 에러 메시지를 쉽게 표시할 수 있어요.\n\n#### 팁!\n\n- 서버에서 에러를 `throw`하면 클라이언트 입장에선 뭘 잘못했는지 알기 어려울 수 있어요. 그래서 예상 가능한 에러들은 명확하게 데이터로 내려주는 게 UX에도 더 좋아요.\n- 반대로, 정말 예상하지 못한 시스템 에러는 그대로 `throw`해서 호출 스택에서 잡히게 하는 게 관리하기 편합니다.\n- 그리고, `useActionState` 훅을 사용하면 이런 반환값을 쉽게 받아서 처리할 수 있으니 한번 써보세요!\n\n이런 스타일은 점점 더 많은 React 서버 컴포넌트 기반 환경에서 권장되는 패턴이니, 앞으로 서버 함수 작성할 때 참고하면 좋아요.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번 시간에는 React의 `useActionState` 훅을 이용해서 폼 제출 시 발생할 수 있는 에러 메시지를 화면에 표시하는 방법을 함께 알아보겠습니다.\n\n기본적으로 `useActionState`는 액션(action)의 상태를 추적할 수 있도록 도와줘서, 성공 여부나 에러 발생 시 상태를 쉽게 관리할 수 있답니다.\n\n---\n\n## 예제 코드 살펴보기\n\n```jsx\n\"use client\";\n\nimport { useActionState } from \"react\";\nimport { createPost } from \"@/app/actions\";\n\nconst initialState = {\n  message: \"\",\n};\n\nexport function Form() {\n  // useActionState 훅 호출, createPost 액션을 인자로 전달\n  const { state, pending } = useActionState(createPost);\n\n  return (\n    \u003cform action={createPost}\u003e\n      \u003clabel htmlFor=\"title\"\u003eTitle\u003c/label\u003e\n      \u003cinput type=\"text\" id=\"title\" name=\"title\" required /\u003e\n\n      \u003clabel htmlFor=\"content\"\u003eContent\u003c/label\u003e\n      \u003ctextarea id=\"content\" name=\"content\" required /\u003e\n\n      \u003cbutton disabled={pending}\u003eCreate Post\u003c/button\u003e\n\n      {/* 에러 메시지가 있다면 화면에 표시 */}\n      {state?.message \u0026\u0026 \u003cp style={{ color: \"red\" }}\u003e{state.message}\u003c/p\u003e}\n    \u003c/form\u003e\n  );\n}\n```\n\n- `useActionState(createPost)`를 호출하면 액션의 현재 상태(`state`)와 제출 진행 중 여부(`pending`)를 반환해줍니다.\n- `state.message`에 에러 메시지가 담겨 있다면, 이를 사용자에게 보여줄 수 있죠.\n- `button`은 제출하는 동안 중복 전송을 방지하기 위해 `disabled` 처리됩니다.\n\n---\n\n## Server Component에서 에러 핸들링\n\n서버 컴포넌트에서 데이터를 불러올 때도 에러 처리는 중요하죠! 거기서는 서버에서 받은 응답을 활용해 조건부 렌더링을 하거나, 필요시 리다이렉션을 할 수 있습니다.\n\n예를 들어:\n\n```jsx\nexport default async function Page() {\n  try {\n    const data = await fetchData(); // 서버에서 데이터 가져오기\n    return \u003cDisplayData data={data} /\u003e;\n  } catch (error) {\n    // 에러 발생 시 에러 메시지 또는 리다이렉션 처리\n    return \u003cp\u003e데이터를 불러오는 중 오류가 발생했습니다.\u003c/p\u003e;\n  }\n}\n```\n\n이처럼 서버 컴포넌트 내부에서 `try-catch` 문으로 에러를 잡아서 사용자에게 피드백을 줄 수 있습니다.\n\n---\n\n## 정리하자면\n\n- **useActionState** 훅을 활용하면 클라이언트 컴포넌트 내에서 액션 상태를 쉽게 관리하고, 에러 메시지를 화면에 표시할 수 있습니다.\n- 제출 버튼에 진행 상태를 반영해 사용자 경험도 개선할 수 있죠.\n- **서버 컴포넌트**에서는 데이터를 비동기로 가져올 때 에러를 잡아서 적절히 처리해야 하며, 이때 사용자에게 친절하게 에러를 알리는 UI를 만드는 게 중요합니다.\n\n---\n\n혹시 더 자세한 액션 상태 관리나 서버-클라이언트 간 에러 핸들링에 관해 궁금한 점이 있으면 언제든지 물어보세요! 여러분이 더 쉽게 React와 Next.js를 활용할 수 있도록 돕겠습니다 :)\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자, 이번에는 Next.js에서 데이터를 가져오고, 만약 데이터가 없다면 404 페이지를 띄우는 방법에 대해 이야기해볼게요.\n\n먼저, fetch API를 사용해서 데이터를 비동기로 가져오는 기본 예제부터 봅시다.\n\n```js\nexport default async function Page() {\n  const res = await fetch(`https://...`);\n  const data = await res.json();\n\n  if (!res.ok) {\n    return \"There was an error.\"; // 에러 발생 시 간단한 메시지 반환\n  }\n\n  return \"...\"; // 데이터를 성공적으로 받아오면 원하는 UI 반환\n}\n```\n\n여기서 핵심은 서버 API를 호출하고, 응답이 제대로 오지 않으면 에러 메시지를 보여주는 거예요. 그런데, 만약 해당 페이지나 데이터가 없을 때는 ‘404 페이지’를 보여주는 방법도 필요하겠죠?\n\nNext.js에서는 `notFound()` 함수를 이용해서 이런 상황을 처리할 수 있어요. 예를 들어, 블로그 포스트를 주소로 찾는 상황을 가정해보죠.\n\n```js\nimport { notFound } from \"next/navigation\";\nimport { getPostBySlug } from \"@/lib/posts\";\n\nexport default async function Page({ params }: { params: { slug: string } }) {\n  const { slug } = params;\n  const post = getPostBySlug(slug);\n\n  if (!post) {\n    notFound(); // 데이터가 없으면 404 페이지로 이동\n  }\n\n  return \u003cdiv\u003e{post.title}\u003c/div\u003e; // 포스트 타이틀 출력\n}\n```\n\n여기서 중요한 점 몇 가지 짚고 넘어가면:\n\n| 항목            | 설명                                                                                                                                         |\n| --------------- | -------------------------------------------------------------------------------------------------------------------------------------------- |\n| `notFound()`    | Next.js가 제공하는 내장 함수로, 호출 시 해당 페이지 대신 404 UI를 보여줘요. 그냥 반환하는 게 아니라 실제로 404 상태로 페이지가 렌더링됩니다. |\n| `getPostBySlug` | 여긴 예시로 작성한 함수인데, 실제로는 슬러그(게시물 주소)를 기준으로 데이터를 찾아오는 로직입니다. 만약 없으면 `undefined` 혹은 `null` 반환  |\n| `params`        | 동적 라우팅에서 URL 파라미터를 받을 때 사용해요. 예를 들어 `/posts/hello-world` 라면 slug는 `hello-world` 가 되겠죠                          |\n\n추가로, `not-found.js` 또는 `not-found.tsx` 파일을 프로젝트에 만들어서 404 페이지의 UI를 커스터마이징 할 수도 있어요.\n\n```jsx\nexport default function NotFound() {\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003e페이지를 찾을 수 없어요 ㅠㅠ\u003c/h1\u003e\n      \u003cp\u003e요청하신 페이지가 존재하지 않거나 삭제되었습니다.\u003c/p\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n이렇게 하면 프로젝트 전반에서 공통으로 쓰이는 404 페이지가 알아서 뜹니다.\n\n정리해보면, 데이터가 없거나 잘못된 URL을 요청했을 때 사용자에게 잘못된 접근임을 알려주는 방법으로 `notFound()` 호출과 맞춤형 404 페이지를 함께 사용하면 훨씬 깔끔한 사용자 경험을 만들 수 있다는 점! 꼭 기억하세요~\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```jsx\nexport default function NotFound() {\n  return \u003cdiv\u003e404 - Page Not Found\u003c/div\u003e;\n}\n```\n\n## 처리하지 않은 예외(uncaught exceptions) 다루기\n\n처리하지 않은 예외란, 애플리케이션의 정상적인 흐름에서는 발생하지 말아야 할 예상치 못한 오류를 뜻해요. 이런 예외들은 보통 에러를 던져서(error throwing) 처리하는데, 이 에러를 '에러 바운더리(Error Boundary)'에서 잡아내서 적절히 대응해주는 방식이 일반적입니다.\n\n에러 바운더리는 리액트 컴포넌트에서 흔히 사용되는데, UI가 깨지지 않고 사용자에게 친절한 에러 메시지를 보여주거나, 로그를 남기거나, 대체 UI로 전환하는 데 활용할 수 있답니다.\n\n### 중첩된 에러 바운더리(Nested error boundaries)\n\n에러 바운더리를 한 군데만 두는 것보다, 애플리케이션 구조에 따라 여러 단계로 중첩시켜서 중요한 UI 부분별로 별도의 에러 처리 영역을 만드는 게 좋아요. 예를 들어, 페이지 전체를 감싸는 바운더리가 있고, 그 안에 각각의 위젯이나 컴포넌트 단위로 또 다른 바운더리가 존재하면, 특정 위젯에서 문제가 생겨도 페이지 전체가 깨지지 않고 해당 위젯 부분만 에러 UI로 교체할 수 있거든요.\n\n이렇게 하면 사용자 경험도 개선되고, 디버깅할 때도 어떤 컴포넌트에서 문제가 발생했는지를 좀 더 명확히 파악할 수 있습니다.\n\n---\n\n참고로, 리액트에서 에러 바운더리를 구현할 때는 다음과 같은 라이프사이클 메서드를 활용해요:\n\n- `static getDerivedStateFromError(error)`: 에러가 발생했을 때 상태를 업데이트하여 대체 UI를 렌더할 준비를 함\n- `componentDidCatch(error, info)`: 에러 로깅 등 부가 작업 수행\n\n그리고 함수형 컴포넌트만 쓴다면 `Error Boundary`는 아직 클래스 컴포넌트로 작성해야 한다는 점 기억하세요!  \n리액트가 앞으로 훅 기반 에러 바운더리를 지원하면 훨씬 편리해지겠죠?\n\n필요하면 에러 바운더리 예제도 공유해 드릴게요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서는 에러 바운더리(Error Boundaries)를 이용해 예기치 못한 에러를 잡아냅니다. 에러 바운더리는 자식 컴포넌트에서 발생한 오류를 잡아내서, 부러진 컴포넌트 트리 대신에 대체 UI(일종의 에러 화면)를 보여주게 해주죠.\n\n이걸 구현하려면, 라우트 세그먼트(route segment) 안에 `error.js` 파일을 만들고 React 컴포넌트를 내보내면 됩니다. 예시는 아래와 같아요:\n\n```js\n'use client' // 에러 바운더리는 클라이언트 컴포넌트여야 합니다\n\nimport { useEffect } from 'react'\n\nexport default function Error({\n  error,\n  reset,\n}: {\n  error: Error \u0026 { digest?: string }\n  reset: () =\u003e void\n}) {\n  useEffect(() =\u003e {\n    // 에러 리포팅 서비스에 로그를 보낸다고 생각해보세요\n    console.error(error)\n  }, [error])\n\n  return (\n    \u003cdiv\u003e\n      \u003ch2\u003e문제가 발생했어요!\u003c/h2\u003e\n      \u003cbutton\n        onClick={\n          // 다시 렌더링 시도해서 복구를 노립니다\n          () =\u003e reset()\n        }\n      \u003e\n        다시 시도\n      \u003c/button\u003e\n    \u003c/div\u003e\n  )\n}\n```\n\n여기서 핵심은 `reset` 함수예요. 이 버튼을 누르면 해당 세그먼트를 다시 렌더링하면서 문제가 해결됐는지 재시도합니다.\n\n그리고 재미있는 점! 에러는 가장 가까운 상위 에러 바운더리로 올라가서 처리돼요. 덕분에, 라우트 트리 계층별로 `error.js`를 여러 개 둬서 세밀하게 에러 처리를 할 수 있습니다. 예를 들어, 특정 페이지에서만 보여줄 맞춤형 에러 화면도 가능하다는 뜻이죠.\n\n---\n\n추가로 알려드리자면, Next.js에서는 페이지나 레이아웃 단위로 에러를 다룰 수 있어서 사용자 경험을 더 세련되게 만드는 데 큰 도움이 됩니당. 단, 에러 바운더리는 무조건 클라이언트 컴포넌트여야 하는 점은 꼭 기억해주세요!\n\n꼭 한 가지 깜빡하지 말아야 할 팁은, 에러 바운더리 안에서도 에러는 다시 던져지지 않으니, 중요한 로그나 오류 추적(예: Sentry 같은 도구 활용)은 `useEffect` 같은 곳에서 해주는 게 베스트입니다.\n\n필요할 때마다 `error.js` 만들어서 우아한 에러 처리를 해보세요! 사용자도, 개발자도 모두 행복해질 거예요 :)\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2025-04-22-Howtohandleerrors_0.png\" /\u003e\n\n### 전역 에러 처리하기 (Global errors)\n\n에러 처리하면 보통 각 컴포넌트 단위에서 하게 되지만, root 레이아웃 단계에서 전역적으로 에러를 잡고 싶을 때가 있어요. 이런 경우에는 `app` 루트 디렉터리에 `global-error.js` 파일을 만들어서 처리할 수 있습니다. 특히 다국어 지원 같은 국제화(i18n)를 적용해도 똑같이 쓸 수 있다는 점도 참고하세요.\n\n이 전역 에러 UI 컴포넌트는 root 레이아웃이나 템플릿을 완전히 대체하는 역할을 하기 때문에, 직접 `html`과 `body` 태그를 포함해야 해요. 없으면 브라우저가 제대로 렌더링하지 않기 때문에 꼭 넣어줘야 합니다.\n\n```js\n'use client' // 에러 바운더리는 클라이언트 컴포넌트여야 합니다\n\nexport default function GlobalError({\n  error,\n  reset,\n}: {\n  error: Error \u0026 { digest?: string }\n  reset: () =\u003e void\n}) {\n  return (\n    \u003chtml\u003e\n      \u003cbody\u003e\n        \u003ch2\u003e문제가 발생했어요!\u003c/h2\u003e\n        \u003cbutton onClick={() =\u003e reset()}\u003e다시 시도\u003c/button\u003e\n      \u003c/body\u003e\n    \u003c/html\u003e\n  )\n}\n```\n\n### 핵심 포인트\n\n- `'use client'` 선언으로 클라이언트 컴포넌트로 만들어야 에러 경계(Error Boundaries)가 정상 동작해요.\n- 에러를 화면에 보여주고, 사용자가 다시 시도할 수 있도록 reset 함수도 전달받아 꼭 활용하세요.\n- 전역 에러 UI는 root 레이아웃을 완전히 대체하므로 `html, body` 태그를 반드시 포함!\n\n### 살짝 더!\n\n만약 이 전역 에러 화면에 스타일을 입히고 싶다면, 전역 CSS를 불러오거나 `style` 태그를 넣는 방법이 있어요. 그리고 모던 웹 앱에서는 에러가 발생했을 때 단순히 메시지 보여주는 것 말고, 사용자 피드백을 받아 서버로 리포트 하거나, 자동 리프레시 기능을 추가하는 것도 생각해볼 만합니다.\n\n즉, 전역 에러 처리는 앱 안정성을 향상시키는 훌륭한 도구니 적극 활용해보세요!\n","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":12},{"title":"nextjs 15 서버 컴포넌트에서 데이터 업데이트 하는 방법 ","description":"","date":"2025-04-22 01:15","slug":"2025-04-22-Howtoupdatedata","content":"\n\n# 데이터 업데이트하는 방법\n\nNext.js에서 데이터를 업데이트할 때는 React의 Server Functions를 활용할 수 있어요. 이번 글에서는 Server Functions를 어떻게 만들고, 호출하는지 쉽고 간단하게 살펴볼게요.\n\n## Server Functions 만들기\n\nServer Function은 `use server`라는 지시어(directive)를 사용해서 정의할 수 있어요. `async` 함수 맨 위에 `use server`를 적으면 그 함수가 Server Function으로 인식돼요. 또는 파일 맨 위에 `use server`를 적으면, 그 파일이 내보내는(export) 모든 함수들이 Server Function으로 동작하게 돼요.\n\n---\n\n\u003e 예를 들어, 아래처럼 쓸 수 있습니다.\n\n```js\n'use server'\n\nexport async function updateData() {\n  // 서버에서 실행할 로직\n}\n```\n\n---\n\n이렇게 하면 프론트엔드에서 API를 호출하는 느낌 대신, 마치 서버 안에서 직접 호출하는 것처럼 데이터를 처리할 수 있어요. 서버에서 실행되기 때문에 보안이나 성능 측면에서도 이점이 크고, 코드도 깔끔해집니다.\n\n혹시 여기서 `use server`가 뭔지 궁금할 수도 있는데, 이건 Next.js 13 이후에 도입된 기능으로, React 컴포넌트 내에서 서버 전용 함수를 만드는데 사용하는 문법이에요. 쉽게 말해 서버에서만 실행되는 함수임을 표시하는 태그라고 생각하면 됩니다.\n\n다음엔 이 Server Function을 실제 컴포넌트에서 어떻게 호출하는지도 보여드릴게요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번 글에서는 Next.js 13부터 새롭게 도입된 Server Actions, 즉 서버에서 직접 실행되는 함수 작성법에 대해 살펴볼게요. 특히, Server Functions를 어떻게 작성하고, 이걸 Server Component 안에 어떻게 쉽게 넣을 수 있는지 가볍게 정리해봤습니다.\n\n---\n\n### Server Functions 기본 작성법\n\n예를 들어, 게시글을 생성하거나 삭제하는 함수를 작성할 때 아래처럼 `FormData`를 받아서 처리할 수 있어요.\n\n```js\nexport async function createPost(formData: FormData) {\n  'use server'   // 여기가 포인트! 이 지시어로 서버에서 실행됨을 명시\n  const title = formData.get('title')\n  const content = formData.get('content')\n\n  // 여기서 데이터베이스에 글 저장하거나,\n  // 혹은 캐시를 재검증(revalidate)하는 작업을 할 수 있죠\n}\n\nexport async function deletePost(formData: FormData) {\n  'use server'\n  const id = formData.get('id')\n\n  // 삭제 처리 및 캐시 갱신\n}\n```\n\n`'use server'`를 함수 맨 위에 적으면, 이 함수가 클라이언트가 아닌 서버에서 실행될 함수임을 명확히 하게 됩니다. 이게 Next.js가 Server Actions를 인식하고 별도로 처리하게 만들어주죠.\n\n---\n\n### Server Functions를 Server Component 안에 작성하기\n\n서버 컴포넌트 내부에 이런 Server Action 함수를 바로 써도 OK인데요, 이런 식으로 함수 위에 `'use server'` 지시어를 붙이면 됩니다.\n\n```js\nexport default function Page() {\n  // 서버에서 실행될 함수 (Server Action)\n  async function createPost(formData: FormData) {\n    'use server'\n    // ...게시글 생성 로직\n  }\n\n  return \u003c\u003e\u003c/\u003e\n}\n```\n\n이렇게 하면 해당 함수를 컴포넌트 바깥으로 따로 빼지 않아도 되고, 컴포넌트와 함수의 관계를 내비치기 좋아요.\n\n---\n\n### 알아두면 좋은 팁\n\n- Server Actions로 넘겨받는 `formData`는 `\u003cform\u003e`에서 전송한 데이터를 쉽게 받아서 쓸 수 있어서, API 엔드포인트 없이도 폼 제출을 깔끔하게 처리할 수 있어요.\n- 서버 함수는 클라이언트 코드에 포함되지 않으니, 보안상 민감한 작업을 하기에 좋아요.\n- 데이터 변경 후에는 꼭 필요한 경우 `revalidatePath()` 같은 Next.js의 캐시 재검증 함수를 호출해 UI에 최신 상태가 반영되게 만들어야 해요.\n\n---\n\n다음 포스팅에서는 Server Actions를 실제 폼과 연동해서 구현하는 간단한 예시도 준비해볼게요. 서버와 클라이언트 경계를 넘나드는 작업이 점점 더 좋아지고 있어 기대해 주세요! 😊\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 클라이언트 컴포넌트(Client Components)\n\n서버 함수(Server Functions)는 클라이언트 컴포넌트 안에서 직접 정의할 수는 없어요. 하지만 서버 함수가 담긴 파일에 `'use server'`라는 지시어를 맨 위에 붙여서 내보내면, 클라이언트 컴포넌트에서 이 함수를 불러와서 실행할 수 있답니다!\n\n예를 들어, 이런 식으로 서버 함수가 정의되어 있어요:\n\n```js\n'use server'\n\nexport async function createPost() {\n  // 서버에서 처리할 로직\n}\n```\n\n그리고 클라이언트 컴포넌트에서는 이렇게 import해서 사용할 수 있죠:\n\n```js\n'use client'\n\nimport { createPost } from '@/app/actions'\n\nexport function Button() {\n  return \u003cbutton formAction={createPost}\u003eCreate\u003c/button\u003e\n}\n```\n\n여기서 핵심은, `createPost` 같은 함수는 실제로는 서버에서 작동하지만, 클라이언트 컴포넌트가 그 함수를 호출하는 이벤트를 연결해준다는 점이에요. 덕분에 UI는 클라이언트에서 매끄럽게 돌아가면서도, 중요한 데이터 처리나 DB 작업 등은 안전하게 서버에서 수행할 수 있죠.\n\n추가로 알아두면 좋은 점!\n- `'use server'` 디렉티브가 있는 파일은 Next.js가 서버 전용이라는 걸 인지해서 클라이언트 번들에서 제외해줘서 코드가 더 깔끔해져요.\n- `formAction` prop을 사용하면 폼 제출 시 서버 함수를 바로 트리거할 수 있어서 React의 상태 관리 없이도 서버와 통신하기 편해요.\n- 이렇게 Server Function을 클라이언트 컴포넌트에서 활용하면, 복잡한 API 라우트 없이도 양방향 데이터 흐름을 간단히 구현할 수 있습니다.\n\n이 방식 덕분에 Next.js에서 서버/클라이언트 코드 구분이 더 명확하고, 개발자는 로직을 더 효율적으로 나눌 수 있답니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 서버 함수 호출하기\n\n서버 함수를 호출하는 방법은 크게 두 가지가 있어요:\n\n- 서버 컴포넌트와 클라이언트 컴포넌트에서의 폼(form) 사용\n- 클라이언트 컴포넌트에서 이벤트 핸들러 사용\n\n### 폼(Form)이용하기\n\n폼 태그는 HTML에서 서버와 데이터를 주고받을 때 가장 기본적인 방법 중 하나인데요, Next.js 같은 프레임워크에서 서버 컴포넌트나 클라이언트 컴포넌트 내에서 쉽게 사용할 수 있어요. 폼이 제출되면 지정한 서버 함수가 호출되고, 그 서버 함수 안에서 데이터를 처리할 수 있죠.\n\n예를 들어, 간단한 로그인 폼을 만들어 서버 함수로 데이터를 보내는 경우를 생각해보면 이해가 쉬워요. 폼 안에 input 필드를 넣고, submit 버튼을 누르면 서버 함수가 자동으로 실행되는 거죠.\n\n또한, 요즘은 fetch API나 axios 같은 클라이언트 사이드 호출 방식을 많이 쓰긴 하지만, 폼을 이용한 방법은 여전히 직관적이고 간단하게 서버에 데이터를 보내는 좋은 방법이에요. 특히 서버 컴포넌트가 지원되는 환경에서는 폼을 통해 자연스럽게 서버 함수를 호출할 수 있다는 점 꼭 기억하세요!\n\n필요하면 다음에 폼 예제 코드를 공유할게요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nReact에서 `form` 태그를 확장해서 Server Function을 HTML `action` 속성으로 바로 호출할 수 있다는 사실, 알고 계셨나요?\n\n보통 우리가 폼을 제출할 때는 프론트엔드에서 이벤트 핸들러를 따로 만들어서 처리하곤 하죠. 하지만 React에서는 폼의 `action` 속성에 서버에서 실행할 함수를 직접 연결할 수 있어요. 이 함수는 폼 제출 시 자동으로 `FormData` 객체를 받아서 안에 담긴 값들을 쉽게 꺼내 쓸 수 있답니다.\n\n예를 들어, 아래처럼 `createPost`라는 서버 함수를 `action`에 할당하면, 폼이 제출될 때 자동으로 `createPost`가 호출되면서 제출한 데이터가 `FormData` 형태로 전달돼요.\n\n```jsx\nimport { createPost } from '@/app/actions'\n\nexport function Form() {\n  return (\n    \u003cform action={createPost}\u003e\n      \u003cinput type=\"text\" name=\"title\" /\u003e\n      \u003cinput type=\"text\" name=\"content\" /\u003e\n      \u003cbutton type=\"submit\"\u003eCreate\u003c/button\u003e\n    \u003c/form\u003e\n  )\n}\n```\n\n서버 함수는 이렇게 작성할 수 있습니다:\n\n```js\n'use server'\n\nexport async function createPost(formData: FormData) {\n  const title = formData.get('title')\n  const content = formData.get('content')\n\n  // 여기서 DB에 저장하거나, 캐시를 재검증하는 작업을 할 수 있어요.\n}\n```\n\n### 조금 더 알아두면 좋은 팁!\n\n- `FormData.get()` 메서드는 반환값이 `FormDataEntryValue | null`이기 때문에, 실제 값이 문자열인지 확인하거나 기본값을 설정하는 게 좋습니다.\n- 서버 함수 내에서는 서버 전용 코드(ex. 데이터베이스 쿼리, 파일 시스템 접근)를 자유롭게 사용할 수 있어요.\n- 클라이언트에서 별도의 API 호출 없이도 서버로 데이터를 보낼 수 있어서 코드가 더 깔끔해지고 유지보수가 쉬워집니다.\n- 물론, 복잡한 폼 유효성 검사나 사용자가 바로 피드백을 받아야 하는 경우엔 클라이언트 측에서 미리 체크하는 걸 추천합니다.\n\n이 방식은 특히 Next.js 같은 React 기반 프레임워크에서 유용하게 쓰이는데요, 서버 함수와 폼을 연동하는 새로운 흐름을 경험해보고 싶다면 한 번 시도해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003e 참고할 점: action prop에 전달될 때 Server Functions는 Server Actions라고도 불러요.\n\n### 이벤트 핸들러(Event Handlers)\n\n클라이언트 컴포넌트에서 서버 기능(Server Function)을 호출할 때는 onClick 같은 이벤트 핸들러를 활용할 수 있어요. 예를 들어, 좋아요 버튼을 만들고 클릭할 때마다 서버에 좋아요 수를 업데이트하는 기능을 구현해볼게요.\n\n```jsx\n'use client'\n\nimport { incrementLike } from './actions'\nimport { useState } from 'react'\n\nexport default function LikeButton({ initialLikes }: { initialLikes: number }) {\n  const [likes, setLikes] = useState(initialLikes)\n\n  return (\n    \u003c\u003e\n      \u003cp\u003eTotal Likes: {likes}\u003c/p\u003e\n      \u003cbutton\n        onClick={async () =\u003e {\n          // 서버에 좋아요 증가 요청을 보내고, 업데이트 된 좋아요 수를 받아서 상태를 갱신해요\n          const updatedLikes = await incrementLike()\n          setLikes(updatedLikes)\n        }}\n      \u003e\n        Like\n      \u003c/button\u003e\n    \u003c/\u003e\n  )\n}\n```\n\n여기서 중요한 점은, 클라이언트 컴포넌트 내부에서 직접 서버 사이드 코드를 호출할 수 없기 때문에, `incrementLike` 같은 서버 기능을 `actions`라는 별도의 파일에서 정의해두고 import해서 사용한다는 거예요. 그리고 비동기 처리를 위해 `async/await`를 활용한 점도 기억해두면 좋아요.\n\n또한, 이렇게 서버 함수 호출 시 상태를 업데이트하는 패턴은 사용자 인터랙션에 실시간 피드백을 주는 데 아주 유용합니다. 만약 서버 함수 호출 중에 로딩 상태 표시가 필요하다면, `useState`로 로딩 상태를 관리해서 버튼을 비활성화하거나 스피너를 보여주는 것도 좋은 UX를 위한 팁이에요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 예시\n\n### 대기 상태 표시하기\n\n서버 함수를 실행하는 동안, React의 `useActionState` 훅을 사용해서 로딩 인디케이터를 보여줄 수 있어요. 이 훅은 `pending`이라는 불리언 값을 반환하는데, 이 값이 `true`일 때는 작업이 진행 중임을 뜻하죠.\n\n예를 들어, 게시글 생성 버튼을 눌렀을 때 로딩 스피너를 보여주는 컴포넌트 코드는 아래와 같습니다:\n\n```js\n'use client'\n\nimport { useActionState } from 'react'\nimport { createPost } from '@/app/actions'\nimport { LoadingSpinner } from '@/app/ui/loading-spinner'\n\nexport function Button() {\n  const [state, action, pending] = useActionState(createPost, false)\n\n  return (\n    \u003cbutton onClick={async () =\u003e action()}\u003e\n      {pending ? \u003cLoadingSpinner /\u003e : 'Create Post'}\n    \u003c/button\u003e\n  )\n}\n```\n\n여기서 중요한 점은 `pending` 값 덕분에 사용자에게 작업이 진행 중이라는 피드백을 줄 수 있다는 거예요. 보통 서버와의 통신이 느릴 때는 이렇게 대기 상태를 표시해주는 게 UX 측면에서 정말 중요하답니다.\n\n또 한 가지 팁을 드리자면, 이 훅은 작업이 끝난 후 결과값이나 에러 상태도 함께 관리할 수 있어서, 로딩뿐만 아니라 성공, 실패 상태에 따른 UI 업데이트도 함께 처리할 수 있어요. 필요에 따라 `state`를 활용해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 캐시 재검증하기\n\n데이터를 업데이트한 뒤, Next.js 캐시를 재검증(revalidate)해서 최신 데이터를 보여주고 싶을 때가 있죠? 그럴 땐 Server Function 내부에서 `revalidatePath`나 `revalidateTag` 함수를 사용하면 간편하게 해결할 수 있어요.\n\n```js\nimport { revalidatePath } from 'next/cache'\n\nexport async function createPost(formData: FormData) {\n  'use server'\n  \n  // 데이터 업데이트 작업 수행\n  // ...\n  \n  // 특정 경로에 대한 캐시를 재검증해서 최신 데이터 반영\n  revalidatePath('/posts')\n}\n```\n\n위 예제처럼, 글을 새로 만들거나 수정한 뒤 `/posts` 경로의 캐시를 재검증하면 사용자에게 항상 최신 게시물 목록을 보여줄 수 있답니다.\n\n\u003e 추가 팁!  \n\u003e 비슷하게 `revalidateTag`를 사용하면 태그 단위로 캐시를 재검증할 수도 있는데, 이 방법은 특정 데이터 그룹을 관리할 때 유용해요. 상황에 맞게 선택해서 사용해보세요.\n\n### 리다이렉트하기\n\n서버 함수에서 작업을 마친 후 사용자를 다른 페이지로 이동시키고 싶을 때는 어떻게 할까요? Next.js에서는 `redirect` 함수를 활용하면 쉽게 처리할 수 있답니다.\n\n예를 들어, 글 작성 후 게시물 목록 페이지로 이동시키고 싶을 때:\n\n```js\nimport { redirect } from 'next/navigation'\n\nexport async function createPost(formData: FormData) {\n  'use server'\n  \n  // 데이터 생성 로직\n  // ...\n  \n  // 작업 후 /posts 페이지로 리다이렉트\n  redirect('/posts')\n}\n```\n\n`redirect` 함수를 호출하면, 클라이언트가 자동으로 지정한 경로로 이동하게 됩니다. 이 방법 덕분에 별도의 클라이언트 사이드 코드 없이도 깔끔한 흐름 제어가 가능해요.\n\n---\n\n이처럼 Next.js의 Server Function 내에서 캐시 재검증과 리다이렉트를 함께 활용하면, 데이터 일관성을 유지하면서 사용자 경험도 한층 좋아지니 꼭 알아두세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n업데이트 작업을 수행한 후에 사용자를 다른 페이지로 이동시키고 싶을 때가 있죠? 그럴 때는 Next.js의 Server Function 안에서 `redirect` 함수를 사용할 수 있어요.\n\n아래 예시 코드를 한 번 볼게요!\n\n```js\n'use server'\n\nimport { redirect } from 'next/navigation'\n\nexport async function createPost(formData: FormData) {\n  // 데이터 업데이트 작업 수행\n  // ...\n  \n  // 업데이트 후 /posts 페이지로 리디렉션\n  redirect('/posts')\n}\n```\n\n여기서 포인트는, `redirect`가 호출되면 그 즉시 클라이언트에게 지정한 URL로 이동하라고 지시한다는 점이에요. 그래서 서버 함수 내에서 업데이트가 끝난 뒤에 자연스럽게 다른 페이지로 사용자를 안내할 수 있죠.\n\n또 한 가지 팁! `redirect`를 사용할 때, 이 함수는 호출과 동시에 훅을 멈추고 이동을 처리하기 때문에 그 이후 코드는 실행되지 않는다는 점 기억해주세요. 만약 안전하게 특정 조건에서만 리디렉션을 하고 싶다면, 조건문 안에 넣어서 사용하면 돼요.\n\n요약하자면, Next.js 13 이상의 서버 함수에서 업데이트 후 바로 페이지 전환을 원할 땐 `redirect`를 활용해보세요. 페이지 새로고침 없이 부드럽게 이동할 수 있어서 사용자 경험도 좋아진답니다!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":12},{"title":"Next.js 15에서 데이터 fetch하는 방법","description":"","date":"2025-04-22 01:13","slug":"2025-04-22-Howtofetchdataandstream","content":"\n# 데이터 가져오기와 스트리밍하는 방법\n\n이번 글에서는 Next.js 같은 환경에서 서버 컴포넌트와 클라이언트 컴포넌트에서 데이터를 가져오는 방법을 알려드릴게요. 그리고 데이터를 기반으로 콘텐츠를 스트리밍하는 방법도 같이 살펴볼 거예요.\n\n## 데이터 가져오기\n\n### 서버 컴포넌트에서 데이터 가져오기\n\n서버 컴포넌트(Server Components)는 서버에서 실행되기 때문에 데이터를 바로 fetch해서 렌더링할 수 있어요. 클라이언트에게는 이미 준비된 결과만 내려주기 때문에 성능도 좋고 보안상 이점도 있죠.\n\n예를 들어, 이렇게 사용할 수 있어요:\n\n```jsx\n// ServerComponent.jsx\nasync function ServerComponent() {\n  const res = await fetch(\"https://api.example.com/data\");\n  const data = await res.json();\n\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003e서버에서 가져온 데이터\u003c/h1\u003e\n      \u003cp\u003e{data.message}\u003c/p\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default ServerComponent;\n```\n\n서버 컴포넌트는 기본적으로 비동기 함수(async function)로 만들 수 있어서, 데이터를 기다렸다가 렌더링하는 것에 전혀 무리가 없답니다.\n\n---\n\n추가 팁!\n\n- fetch를 쓸 때는 캐싱과 관련된 옵션을 꼭 확인하세요. 예를 들어 Next.js에서는 `fetch('url', { next: { revalidate: 60 }})` 처럼 60초마다 다시 가져오게 설정할 수 있어요.\n- 만약 API 호출이 오래 걸리는 경우, React 18 스트리밍 기능과 함께 쓰면 사용자에게 더 빠른 피드백을 줄 수 있어요. 이 부분도 곧 설명할게요!\n\n다음으로, 클라이언트 컴포넌트에서 데이터 가져오는 법과 스트리밍하는 예시를 이어서 다뤄볼게요.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n서버 컴포넌트(Server Components)에서 데이터를 가져올 때는 주로 이렇게 두 가지 방법을 사용해요:\n\n- fetch API 활용하기\n- ORM이나 데이터베이스 직접 호출하기\n\n#### fetch API 사용법\n\nfetch API를 쓰려면 컴포넌트를 비동기 함수(async function)로 만들고, fetch 호출 앞에 await를 붙여서 데이터를 받아오면 돼요. 예시를 살펴볼게요:\n\n```jsx\n// 비동기 함수로 만든 서버 컴포넌트 예시\nexport default async function UserProfile() {\n  const res = await fetch(\"https://api.example.com/user\");\n\n  // 서버 컴포넌트에서 fetch할 때는 기본적으로 캐싱이 되는데,\n  // 필요에 따라 cache 옵션을 조절할 수 있어요.\n  // 예: await fetch(url, { cache: 'no-store' }) // 매번 새로 불러오기\n\n  if (!res.ok) {\n    // 에러 처리도 서버 컴포넌트 내에서 할 수 있답니다.\n    throw new Error(\"사용자 정보를 가져오는데 실패했습니다.\");\n  }\n\n  const user = await res.json();\n\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003e{user.name}님 안녕하세요!\u003c/h1\u003e\n      \u003cp\u003e이메일: {user.email}\u003c/p\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n\u003e 여기서 중요한 팁! Server Components는 클라이언트와 달리 fetch API를 사용할 때 네트워크 요청이 서버에서 처리되기 때문에 API 키 같은 민감한 정보도 안전하게 다룰 수 있어요.\n\n다음 번에는 ORM이나 데이터베이스 직접 호출 방법도 같이 정리해볼게요! 컴포넌트에서 데이터 가져오는 게 이제 좀 감 잡히셨죠?\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번에는 React의 Server Component에서 데이터 가져오는 방법에 대해 살펴보려고 해요. 특히 fetch API를 사용하거나 ORM을 통해 데이터베이스에서 직접 데이터를 불러오는 예제를 함께 보여드릴게요.\n\n먼저, `fetch`를 사용해서 외부 API에서 블로그 글 목록을 가져오는 아주 기본적인 예제입니다.\n\n```jsx\nexport default async function Page() {\n  const data = await fetch(\"https://api.vercel.app/blog\");\n  const posts = await data.json();\n\n  return (\n    \u003cul\u003e\n      {posts.map((post) =\u003e (\n        \u003cli key={post.id}\u003e{post.title}\u003c/li\u003e\n      ))}\n    \u003c/ul\u003e\n  );\n}\n```\n\n서버 컴포넌트는 서버에서 렌더링되기 때문에 async 함수로 만들고 `await`로 데이터를 받아올 수 있는 게 큰 장점이에요. 이렇게 하면 클라이언트에서 별도로 데이터를 가져오는 로직을 짤 필요가 없고, 초기 렌더링 시점에 바로 데이터를 사용할 수 있죠.\n\n---\n\n그리고 조금 더 고급 예제로, ORM이나 직접 데이터베이스 클라이언트를 사용해서 데이터베이스 쿼리를 하는 방법도 있는데요. 예를 들어, Prisma나 Drizzle ORM 같이 JavaScript/TypeScript에서 많이 사용하는 ORM을 쓸 때도 동일한 패턴입니다.\n\n```jsx\nimport { db, posts } from \"@/lib/db\";\n\nexport default async function Page() {\n  const allPosts = await db.select().from(posts);\n\n  return (\n    \u003cul\u003e\n      {allPosts.map((post) =\u003e (\n        \u003cli key={post.id}\u003e{post.title}\u003c/li\u003e\n      ))}\n    \u003c/ul\u003e\n  );\n}\n```\n\n이 경우 `db.select().from(posts)` 같은 쿼리문을 `await` 해서 서버에서 바로 데이터베이스를 조회하고, 그 결과를 UI로 바로 뿌려줄 수 있어요.\n\n---\n\n### 여기서 몇 가지 더 알려드릴 팁!\n\n- **서버 컴포넌트와 클라이언트 컴포넌트의 역할 분리!**  \n  서버 컴포넌트는 데이터를 불러오고, 클라이언트 컴포넌트는 사용자 상호작용(UI 이벤트 등)을 담당하는 식으로 분리하면 앱 구조가 더 깔끔해져요.\n\n- **fetch 캐싱 전략**  \n  `fetch` 호출할 때 `cache: 'no-store'` 옵션을 넣으면 항상 최신 데이터를 받아올 수 있고, 반대로 캐싱 옵션을 활용하면 퍼포먼스를 높일 수도 있어요.\n\n- **환경변수 사용하기**  \n  데이터베이스 연결이나 API 호출 시 민감한 정보(API 키 등)는 .env 파일에 숨기는 게 안전해요.\n\n---\n\n이번 글에서는 React 서버 컴포넌트 내에서 외부 API, ORM으로 데이터 가져오는 기본적인 방법을 정리해보았는데요. 실제 프로젝트에서 서버 사이드 렌더링을 하거나 Next.js와 같은 프레임워크를 사용할 때 꼭 알아두면 유용한 패턴이에요. 편하게 데이터를 다루고 싶을 때 async/await와 서버 컴포넌트를 적극 활용해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 클라이언트 컴포넌트에서 데이터 가져오기\n\n클라이언트 컴포넌트에서 데이터를 가져오는 방법은 크게 두 가지가 있어요.\n\n- React의 `use` 훅 사용하기\n- SWR, React Query 같은 커뮤니티 라이브러리 활용하기\n\n#### 1. React `use` 훅 사용하기\n\nReact 18부터 도입된 `use` 훅을 사용하면 데이터 패칭을 조금 더 간결하게 할 수 있어요. 이 훅은 비동기 함수에서 데이터를 받아와서 컴포넌트가 렌더링되기 전에 데이터 로딩을 처리해주죠.\n\n예를 들면 이렇게 사용할 수 있어요:\n\n```jsx\n\"use client\";\n\nimport { use } from \"react\";\n\nasync function fetchUser() {\n  const res = await fetch(\"/api/user\");\n  if (!res.ok) throw new Error(\"Failed to fetch user\");\n  return res.json();\n}\n\nexport default function UserComponent() {\n  const user = use(fetchUser());\n\n  return \u003cdiv\u003eHello, {user.name}!\u003c/div\u003e;\n}\n```\n\n`use` 훅은 서버 컴포넌트에서는 바로 사용할 수 없고 클라이언트 컴포넌트에서만 지원되니 참고하세요!\n\n#### 2. SWR, React Query 같은 라이브러리 이용하기\n\n`use` 훅이 꽤 편리하지만, 상태 관리, 캐싱, 리페치 같은 점에서 기능이 부족할 때는 SWR이나 React Query가 많이 쓰여요.\n\n이들 라이브러리는 다음과 같은 이점이 있어요:\n\n| 장점                  | 설명                                                         |\n| --------------------- | ------------------------------------------------------------ |\n| 자동 캐싱             | 이전에 가져온 데이터를 캐시해서 빠르게 보여줘요.             |\n| 배경 리페치           | 데이터를 최신 상태로 유지하기 위해 자동으로 재요청해요.      |\n| 로딩과 에러 상태 처리 | 로딩 중인 상태나 에러를 쉽게 관리할 수 있어요.               |\n| 폴링과 리프레시       | 정기적으로 데이터를 갱신하거나 수동으로 새로고침이 가능해요. |\n\n예를 들어 SWR을 쓰면 이렇게 간단하게 데이터를 가져올 수 있죠:\n\n```jsx\n\"use client\";\n\nimport useSWR from \"swr\";\n\nconst fetcher = (url) =\u003e fetch(url).then((res) =\u003e res.json());\n\nexport default function UserComponent() {\n  const { data, error } = useSWR(\"/api/user\", fetcher);\n\n  if (error) return \u003cdiv\u003e에러 발생!\u003c/div\u003e;\n  if (!data) return \u003cdiv\u003e로딩 중...\u003c/div\u003e;\n\n  return \u003cdiv\u003eHello, {data.name}!\u003c/div\u003e;\n}\n```\n\nReact Query 역시 비슷한 방식으로 동작하고, 복잡한 데이터 동기화 문제를 쉽게 해결할 수 있어서 대규모 프로젝트에 많이 사용돼요.\n\n---\n\n데이터를 어떻게 패칭할지는 프로젝트 규모와 요구사항에 따라 선택하면 좋아요. 간단한 경우에는 React `use` 훅만으로도 충분하지만, 상태 관리가 복잡하거나 다양한 기능을 원한다면 SWR이나 React Query를 한 번 써보시길 추천해요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nReact의 새로운 use hook을 활용해서 서버에서 클라이언트로 데이터를 스트리밍하는 방법을 소개할게요. 이걸 쓰면 데이터를 미리 기다리지 않고도 렌더링을 시작할 수 있어서 사용자 경험이 더 좋아져요.\n\n먼저, 서버 컴포넌트에서 데이터를 가져오고, 그 Promise를 클라이언트 컴포넌트에 props로 넘겨줍니다:\n\n```jsx\nimport Posts from \"@/app/ui/posts\";\nimport { Suspense } from \"react\";\n\nexport default function Page() {\n  // 데이터 fetching 함수 호출, 여기서 await는 하지 않아요\n  const posts = getPosts();\n\n  return (\n    \u003cSuspense fallback={\u003cdiv\u003eLoading...\u003c/div\u003e}\u003e\n      \u003cPosts posts={posts} /\u003e\n    \u003c/Suspense\u003e\n  );\n}\n```\n\n여기서 중요한 점! getPosts() 의 Promise를 바로 넘겨주는 거예요. 아직 데이터가 준비되지 않았어도, Suspense로 감싸고 있기 때문에 로딩 UI가 보였다가 데이터가 준비되면 실제 내용이 렌더링됩니다.\n\n그 다음, 클라이언트 컴포넌트에선 `use` hook을 이용해서 Promise를 읽을 수 있어요:\n\n```jsx\n\"use client\";\nimport { use } from \"react\";\n\nexport default function Posts({ posts }: { posts: Promise\u003c{ id: string, title: string }[]\u003e }) {\n  // Promise가 끝날 때까지 기다렸다가 결과를 가져옵니다\n  const allPosts = use(posts);\n\n  return (\n    \u003cul\u003e\n      {allPosts.map((post) =\u003e (\n        \u003cli key={post.id}\u003e{post.title}\u003c/li\u003e\n      ))}\n    \u003c/ul\u003e\n  );\n}\n```\n\n이 방법의 장점은 서버 컴포넌트에서 데이터를 바로 넘겨주기 때문에 클라이언트에서 fetch 코드를 따로 작성할 필요가 없고, Suspense와 함께 쓰면 자연스럽게 로딩 상태도 처리할 수 있다는 점이에요.\n\n\u003e 참고로 `use` hook은 React 18에서 도입된 기능이고 Next.js 13 같은 최신 프레임워크와 아주 잘 맞아요. 만약 여러분이 Next.js 같은 환경에서 작업한다면 적극 활용해보세요!\n\n요약하자면:\n\n| 단계                   | 설명                                            |\n| ---------------------- | ----------------------------------------------- |\n| 1. 서버 컴포넌트       | 데이터를 fetching하고 Promise를 props로 넘기기  |\n| 2. 클라이언트 컴포넌트 | `use` hook으로 Promise 처리해서 데이터 사용하기 |\n| 3. Suspense 적용       | 로딩 UI 관리해서 UX 향상                        |\n\n이렇게 하면 fetch로 데이터를 직접 기다리지 않고도 부드러운 렌더링과 데이터 스트리밍 효과를 낼 수 있답니다. 한번 써보면 React의 새로운 가능성에 감탄하게 될 거예요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위 예제에서 `Posts /` 컴포넌트를 `Suspense` 경계로 감싸줘야 합니다. 이렇게 하면 데이터 로딩 중일 때 fallback UI가 보여지면서 Promise가 해결될 때까지 기다릴 수 있어요. 스트리밍에 대해 더 알고 싶다면 실제 React 공식 문서나 관련 자료를 참고해보세요.\n\n---\n\n### 커뮤니티 라이브러리 활용하기\n\nReact에서 클라이언트 컴포넌트 내 데이터를 가져올 때는 SWR이나 React Query 같은 커뮤니티 라이브러리를 많이 사용합니다. 이 라이브러리들은 캐싱, 스트리밍, 갱신 정책 등 다양한 기능을 제공해서 데이터 패칭을 훨씬 편리하게 만들어줘요.\n\n예를 들어 SWR을 사용한 코드는 다음과 같습니다:\n\n```js\n\"use client\";\nimport useSWR from \"swr\";\n\nconst fetcher = (url) =\u003e fetch(url).then((r) =\u003e r.json());\n\nexport default function BlogPage() {\n  const { data, error, isLoading } = useSWR(\"https://api.vercel.app/blog\", fetcher);\n\n  if (isLoading) return \u003cdiv\u003eLoading...\u003c/div\u003e;\n  if (error) return \u003cdiv\u003eError: {error.message}\u003c/div\u003e;\n\n  return (\n    \u003cul\u003e\n      {data.map((post: { id: string, title: string }) =\u003e (\n        \u003cli key={post.id}\u003e{post.title}\u003c/li\u003e\n      ))}\n    \u003c/ul\u003e\n  );\n}\n```\n\n- 여기서 `useSWR`은 데이터를 쉽게 가져오고 자동으로 캐싱해주며, 필요하면 재요청도 해줍니다.\n- `isLoading`, `error` 상태도 관리해줘서 로딩중이나 에러가 났을 때 사용자에게 알기 쉽게 UI를 보여줄 수 있어요.\n- `Suspense`를 직접 쓰는 대신 SWR이 내부적으로 비슷한 원리(loading 상태 관리)를 처리해준다고 생각하면 편합니다.\n\n---\n\n이 밖에도 React Query는 더 많은 기능과 옵션을 제공하니, 프로젝트 성격에 맞게 골라 써보시면 좋겠죠? 데이터를 클라이언트에서 관리할 때 편리한 도구들이 많으니 적극 활용해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 스트리밍 (Streaming)\n\n\u003e 주의: 아래 내용은 Next.js 15 카나리 버전에서 도입된 dynamicIO 설정 옵션이 활성화되어 있다고 가정한 설명입니다.\n\n서버 컴포넌트(Server Components)에서 async/await를 사용할 때, Next.js는 자동으로 동적 렌더링(dynamic rendering)을 선택하게 돼요. 즉, 매번 사용자 요청이 들어올 때마다 서버에서 데이터를 가져오고 렌더링을 한다는 뜻이죠. 여기서 문제가 되는 점은, 만약 데이터 요청이 느리다면 그 경로 전체가 렌더링 되지 않고 기다리게 된다는 거예요.\n\n이런 상황에서 사용자 경험과 초기 로딩 속도를 개선하기 위해 스트리밍(Streaming)을 사용할 수 있습니다. 스트리밍은 페이지의 HTML 내용을 작고 여러 개의 청크(chunk)로 나누고, 그 청크들을 서버에서 클라이언트로 점진적으로 보내는 방식을 말합니다. 이렇게 하면 사용자에게는 빠르게 일부 콘텐츠가 먼저 보이고, 나머지도 순차적으로 로딩되어 부드러운 경험을 제공할 수 있죠.\n\n---\n\n### 추가 팁: 스트리밍 적용 시 주의할 점\n\n- **콘텐츠 순서 보장**  \n  스트리밍은 HTML을 나누어 보내지만, 클라이언트는 리소스를 받는 순서대로 렌더링해요. 그래서 서버에서 청크를 보내는 순서를 적절히 관리하는 게 중요합니다.\n\n- **상태(state) 관리**  \n  서버에서 각 청크가 독립적으로 렌더링되므로, 상태 관리에 신경 써야 해요. React의 서버 컴포넌트 특성상 상태를 클라이언트와 분리해서 다뤄야 할 때도 있습니다.\n\n- **SEO 영향 고려**  \n  스트리밍은 SEO에도 긍정적입니다. 초기 콘텐츠를 빠르게 보여주기 때문에 검색엔진 크롤러가 콘텐츠를 더 잘 인식할 수 있어요.\n\n---\n\n스트리밍 덕분에 사용자들은 느린 데이터 로딩으로 인한 기다림이 줄어들고, 동시에 서버 자원을 효율적으로 사용할 수 있게 됩니다. Next.js의 스트리밍 기능, 꼭 활용해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2025-04-22-Howtofetchdataandstream_0.png\" /\u003e\n\n애플리케이션에서 스트리밍(streaming)을 구현하는 방법은 크게 두 가지가 있어요:\n\n- `loading.js` 파일을 활용하는 방법\n- React의 `Suspense` 컴포넌트를 사용하는 방법\n\n### loading.js를 활용한 방법\n\nloading.js 파일을 이용하면 컴포넌트가 로딩 중일 때 보여줄 UI를 간단히 처리할 수 있는데요, 이것만 잘 활용해도 로딩 상태 관리가 훨씬 깔끔해집니다. React 18 이후로 서버 컴포넌트를 지원하면서 이 방식이 점점 많이 쓰이고 있죠.\n\n다음에 React `Suspense` 컴포넌트를 활용하는 방법도 한번 살펴볼게요.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여러분, Next.js에서 페이지 데이터를 가져올 때 로딩 상태를 어떻게 더 잘 보여줄 수 있을까요? 바로 `loading.js` 파일을 활용하는 방법입니다!\n\n예를 들어, `app/blog/page.js` 파일과 같은 폴더(`app/blog`)에 `loading.js` 파일을 만들어주면, 페이지 데이터를 가져오는 동안 사용자가 기다리는 모습을 좀 더 깔끔하게 보여줄 수 있어요.\n\n```js\nexport default function Loading() {\n  // 여기서 로딩 화면 UI를 정의해주면 됩니다\n  return \u003cdiv\u003eLoading...\u003c/div\u003e;\n}\n```\n\n이렇게 하면 사용자가 페이지로 이동할 때, 화면은 즉시 레이아웃과 이 로딩 UI를 보여주고, 데이터가 모두 준비되면 자동으로 실제 콘텐츠로 바뀌어요.\n\n참고로, 이런 방식이 좋은 이유는 “빈 화면”이나 갑작스러운 깜빡임 없이 자연스럽게 사용자 경험이 이어진다는 점이에요. 실제로 프로젝트에 적용할 때는 단순 텍스트 대신 스피너 애니메이션이나 뼈대 UI(Skeleton UI)를 넣어주면 더 효과적이랍니다.\n\n아래는 예시 이미지인데, 이런 식으로 로딩 중인 상태를 좀 더 친절하게 보여줄 수 있어요.\n\n| ![로딩 화면 예시](https://yourdomain.com/assets/img/2025-04-22-Howtofetchdataandstream_1.png) |\n| --------------------------------------------------------------------------------------------- |\n\n나중에 `loading.js`에서 다양한 로딩 상태 구현을 고민해보면서, 사용자 경험을 한층 업그레이드 해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2025-04-22-Howtofetchdataandstream_2.png\" /\u003e\n\n뒤에서 보면, `loading.js`는 `layout.js` 내부에 중첩되어 자동으로 `page.js` 파일과 그 아래 자식들을 `Suspense` 경계로 감싸게 돼요.\n\n\u003cimg src=\"/TIL/assets/img/2025-04-22-Howtofetchdataandstream_3.png\" /\u003e\n\n이 방식은 라우트 세그먼트(레이아웃과 페이지)에 잘 맞지만, 더 세밀한 스트리밍이 필요하다면 직접 `Suspense`를 활용하는 게 좋아요.\n\n---\n\n여기서 잠깐! `Suspense`를 사용하면 리액트에서 비동기 데이터를 로딩하는 동안 그 자리를 대체하는 로딩 UI를 보여줄 수 있다는 점이 정말 편해요. 특히 Next.js 13처럼 서버 컴포넌트가 도입된 환경에서는 `loading.js` 같은 파일로 페이지 단위 로딩 처리를 자동으로 해주니까 개발이 훨씬 수월해지죠.\n\n하지만, 한 단계 더 들어가서 페이지 일부만 따로 로딩하고 싶을 때(예를 들어, 큰 리스트 아이템 중 일부만 먼저 보여주고, 나머지는 천천히 로딩하고 싶을 때) `Suspense`를 직접 사용하는 것이 필요해집니다.\n\n즉,\n\n- `loading.js` + `layout.js` = 페이지 단위 자동 로딩 UI 처리\n- `Suspense` = 하위 컴포넌트 단위 세밀한 로딩 UI 제어\n\n이 두 가지를 적절하게 조합해 사용하는 게 개발 생산성을 높이는 좋은 팁이에요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### `Suspense`를 활용한 부분적 스트리밍\n\n`Suspense`는 페이지의 특정 부분만 스트리밍할 수 있게 해줘서, 사용자 경험을 더 부드럽고 빠르게 만들어주는데요. 예를 들어, 전체 페이지 중에서 `Suspense` 경계 밖에 있는 내용은 바로 보여주고, 경계 안에 있는 블로그 목록 같은 무거운 컴포넌트만 나중에 스트리밍해서 로드할 수 있어요.\n\n아래 예제를 보면, 제목과 인사말은 즉시 렌더링되고, 블로그 목록은 `Suspense` 안에서 비동기로 불러와집니다. 로딩 중일 때는 `BlogListSkeleton` 컴포넌트가 대신 보여지겠죠?\n\n```jsx\nimport { Suspense } from \"react\";\nimport BlogList from \"@/components/BlogList\";\nimport BlogListSkeleton from \"@/components/BlogListSkeleton\";\n\nexport default function BlogPage() {\n  return (\n    \u003cdiv\u003e\n      {/* 이 부분은 즉시 클라이언트에게 전송됩니다 */}\n      \u003cheader\u003e\n        \u003ch1\u003eWelcome to the Blog\u003c/h1\u003e\n        \u003cp\u003eRead the latest posts below.\u003c/p\u003e\n      \u003c/header\u003e\n      \u003cmain\u003e\n        {/* Suspense 경계 안의 컴포넌트는 스트리밍 되어 로드됩니다 */}\n        \u003cSuspense fallback={\u003cBlogListSkeleton /\u003e}\u003e\n          \u003cBlogList /\u003e\n        \u003c/Suspense\u003e\n      \u003c/main\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n### 의미 있는 로딩 상태 만들기\n\n`Suspense`를 사용하면 단순히 \"로딩 중\" 텍스트만 보여주는 대신, 실제 콘텐츠 형태를 모방한 스켈레톤 UI를 보여줄 수 있는데요. 이는 사용자에게 페이지가 정말로 반응하고 있다는 느낌을 잘 줍니다. 예를 들어 블로그 목록이라면 개별 목록 아이템이 빈 카드처럼 보이는 스켈레톤 화면을 만드는 거죠.\n\n이런 UX 테크닉을 적용하면, 페이지가 로딩될 때 사용자가 느끼는 대기시간이 훨씬 짧고 부드러워 보여 실제 체감 성능이 높아집니다.\n\n더불어, `Suspense`를 적절히 활용하면 데이터가 준비되는 순서에 따라 UI를 부분별로 제어할 수 있어서, 복잡한 페이지도 단계적으로 로드할 수 있다는 점!\n\n요약하자면,\n\n- 초기 콘텐츠는 지체 없이 보여주기\n- 데이터를 불러오는 부분은 `Suspense`와 fallback UI로 감싸기\n- 스켈레톤 UI 등 의미 있는 로딩 화면 제공하기\n\n이렇게만 해도 사용자 경험은 대폭 개선될 거예요! 😊\n\n필요하다면 Suspense의 fallback 컴포넌트를 직접 커스터마이징해서 브랜드 느낌이나 스타일을 살리는 것도 추천드려요.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n즉시 로딩 상태란, 사용자가 페이지를 이동한 직후 바로 보여주는 대체 UI를 의미해요. 이게 왜 중요하냐면, 사용자가 앱이 반응하고 있다는 걸 바로 알 수 있게 해줘서 불안감을 줄이고 더 나은 사용자 경험을 제공할 수 있기 때문이죠.\n\n가장 좋은 방법은 단순히 로딩 중이라는 표시만 보여주는 게 아니라, 의미 있는 로딩 상태를 디자인하는 거예요. 예를 들어, 뼈대 화면(skeleton)을 보여준다거나, 돌아가는 스피너(spinner)를 사용하는 게 대표적이고요. 좀 더 나아가서는 다음에 보여질 화면의 핵심 요소, 예를 들어 커버 사진이나 제목 같은 작은 부분을 먼저 보여주면 훨씬 자연스러운 느낌을 줄 수 있습니다.\n\n개발 중에는 React Devtools를 활용하면 컴포넌트의 로딩 상태를 미리 보고, 어떻게 동작하는지 자세하게 확인할 수 있어요. 덕분에 사용자에게 완성도 높은 로딩 UI를 더 쉽게 만들 수 있답니다.\n\n간단히 정리해볼게요.\n\n| 팁                    | 설명                                                        |\n| --------------------- | ----------------------------------------------------------- |\n| 즉시 로딩 상태        | 네비게이션 후 바로 보여지는 대체 UI                         |\n| 의미 있는 로딩 디자인 | 스켈레톤, 스피너, 다음 화면 일부 요소(제목, 이미지 등) 활용 |\n| 개발 시 활용 도구     | React Devtools로 로딩 상태 미리보기 및 검사                 |\n\n이런 방식으로 사용자에게 앱이 멈추지 않고 잘 작동 중임을 자연스럽게 알릴 수 있어요. 여러분도 한 번 적용해보세요!\n","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":17},{"title":"2025년 ReactJS와 Next.js에서 CSS를 가장 쉽게 사용하는 방법","description":"","date":"2025-04-22 01:08","slug":"2025-04-22-HowtouseCSSinyourapplication","content":"\n\n# 애플리케이션에서 CSS 사용법 알아보기\n\nNext.js에서는 CSS를 사용하는 여러 가지 방법을 제공하는데요, 대표적으로 다음과 같은 방식들이 있어요:\n\n- CSS 모듈(CSS Modules)\n- 글로벌 CSS(Global CSS)\n- Tailwind CSS\n- Sass\n- CSS-in-JS\n- 외부 스타일시트(External Stylesheets)\n\n이 글에서는 각각의 방법을 어떻게 사용하는지 차근차근 알려드릴게요. 앞으로 여러분 프로젝트에 어떤 방식이 가장 잘 맞을지 선택하는 데 도움이 되길 바랍니다!  \n\n다양한 스타일링 옵션을 활용하면 코드 관리도 쉽고, 유지보수도 편해지니까 꼭 익혀두세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## CSS Modules\n\nCSS Modules는 CSS 클래스 이름을 고유하게 만들어서, 같은 이름의 클래스를 여러 파일에서 마음껏 사용할 수 있게 도와주는 방법이에요. 덕분에 클래스 이름 충돌 걱정 없이 스타일을 관리할 수 있죠.\n\n사용 방법도 간단해요! 스타일 파일을 `.module.css` 확장자로 만들고, 이걸 필요한 컴포넌트에서 import하기만 하면 돼요. 예를 들어:\n\n```css\n/* blog.module.css */\n.blog {\n  padding: 24px;\n}\n```\n\n그리고 컴포넌트에서는 이렇게 불러와서 사용하면 돼요:\n\n```jsx\nimport styles from './blog.module.css';\n\nfunction Blog() {\n  return \u003cdiv className={styles.blog}\u003e안녕하세요, 블로그입니다!\u003c/div\u003e;\n}\n```\n\n여기서 중요한 점! 일반 CSS 파일과는 달리, CSS Modules에서는 클래스를 사용할 때 항상 import한 `styles` 객체를 통해 접근해 주어야 해요. 이렇게 하면 자동으로 클래스 이름이 고유한 문자열로 변환돼서, 다른 컴포넌트의 같은 클래스 이름과 충돌하지 않도록 막아줍니다.\n\n그리고 혹시 CSS Modules가 조금 낯설게 느껴질 수도 있지만, 최근에는 React를 비롯한 여러 프론트엔드 프레임워크에서 기본 지원하거나 쉽게 설정할 수 있어서 많이 쓰이는 추세에요. 특히 프로젝트가 커질수록 스타일 관리가 훨씬 편해지니, 개인 프로젝트나 회사 프로젝트 모두에서 강력 추천합니다!\n\n덧붙여서, CSS Modules는 전역 네임스페이스 오염 없이 컴포넌트 단위 스타일링이 가능해서, 스타일을 쓰면서 발생하는 버그도 줄여준답니다. 다른 방법으로는 styled-components 같은 CSS-in-JS도 있으니, 용도와 선호도에 따라 선택하면 좋아요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport styles from './styles.module.css'\n\nexport default function Page({ children }: { children: React.ReactNode }) {\n  return \u003cmain className={styles.blog}\u003e{children}\u003c/main\u003e\n}\n```\n\n## 글로벌 CSS(Global CSS)\n\n애플리케이션 전체에 스타일을 적용하고 싶을 때는 글로벌 CSS를 사용하면 편리해요.\n\n예를 들어, `app/global.css` 파일을 만들어서 스타일을 작성하고, 이 파일을 루트 레이아웃(root layout) 파일에 import 하면 애플리케이션의 모든 경로(route)에 글로벌 스타일이 적용돼요.\n\n```css\n/* app/global.css 예시 */\nbody {\n  margin: 0;\n  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n  background-color: #f9f9f9;\n  color: #333;\n}\n```\n\n그리고 루트 레이아웃 파일에서는 이렇게 import 해주세요.\n\n```js\nimport './global.css';\n\nexport default function RootLayout({ children }) {\n  return (\n    \u003chtml\u003e\n      \u003cbody\u003e{children}\u003c/body\u003e\n    \u003c/html\u003e\n  );\n}\n```\n\n\u003e 참고로, 글로벌 CSS는 보통 전체적인 기본 스타일(Reset, 폰트, 배경 등)을 적용할 때 사용하고, 각 컴포넌트별 스타일은 CSS 모듈이나 styled-components 같은 방식을 병행해 쓰는 게 유지보수에 좋아요.\n\n추가로 Next.js에서는 글로벌 CSS가 한 번만 import 되어야 하니, 루트 레이아웃이나 앱 컴포넌트에 넣는 걸 추천합니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번에는 Next.js에서 글로벌 스타일과 Tailwind CSS에 대해 간단히 살펴볼게요.\n\n우선, CSS에서 `body` 태그에 아래와 같은 스타일을 적용한 예시가 있어요:\n\n```css\nbody {\n  padding: 20px 20px 60px;\n  max-width: 680px;\n  margin: 0 auto;\n}\n```\n\n이 스타일은 `body`에 패딩을 줘서 콘텐츠 주변에 공간을 만들고, 최대 너비를 680px로 제한해주고, 좌우 여백은 자동으로 가운데 정렬하는 역할을 하죠.\n\n그리고 Next.js 앱에서는 이렇게 글로벌 CSS를 가져와서 모든 페이지에 적용할 수 있어요:\n\n```tsx\n// 이 파일은 루트 레이아웃 컴포넌트입니다.\n// 전체 앱에 글로벌 스타일이 적용되도록 설정해요.\nimport './global.css'\n \nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    \u003chtml lang=\"en\"\u003e\n      \u003cbody\u003e{children}\u003c/body\u003e\n    \u003c/html\u003e\n  )\n}\n```\n\n여기서 `import './global.css'` 부분이 바로 앱 전체에 영향을 주는 글로벌 스타일을 불러오는 부분입니다.\n\n### 알아두면 좋은 점\nNext.js는 React의 스타일 시트 지원 기능과 Suspense를 활용해서 스타일 관리를 하는데요, 문제가 되는 부분은 \"라우트 간 이동 시 스타일 시트가 자동으로 제거되지 않아 충돌(conflicts)이 날 수 있다\"는 거예요.\n\n그래서 권장하는 방법은,\n\n- 정말 앱 전체에 적용되어야 하는 스타일만 글로벌 CSS로 작성하세요.\n- 페이지별, 컴포넌트별로 독립된 스타일이 필요하다면 CSS 모듈(CSS Modules)을 사용하세요.\n\n이렇게 하면 스타일 충돌을 막을 수 있고 관리도 더 쉬워집니다.\n\n---\n\n## Tailwind CSS 이야기\n\n그럼 Tailwind CSS는 어떻게 Next.js와 쓰일까요? Tailwind CSS는 유틸리티 클래스 기반 CSS 프레임워크로, 복잡한 CSS를 손쉽게 작성할 수 있게 도와줘요.\n\n예를 들어, 위에서 했던 `body` 스타일을 Tailwind로 표현하고 싶다면, 다음과 같이 할 수 있죠:\n\n```tsx\n\u003cbody className=\"p-5 pb-15 max-w-xl mx-auto\"\u003e\n  {children}\n\u003c/body\u003e\n```\n\n- `p-5`는 padding 20px (Tailwind 기본 spacing scale에서 대략 1.25rem) 정도를 줍니다.\n- `pb-15`은 padding-bottom 60px 정도를 줘요.\n- `max-w-xl` 은 최대 너비 약 680px에 해당합니다.\n- `mx-auto`는 좌우 마진 자동으로 가운데 정렬을 의미합니다.\n\nTailwind를 활용하면 CSS 파일을 따로 관리하지 않아도 되고, 클래스만 잘 조합해서 손쉽게 반응형 및 스타일 변화를 줄 수 있죠.\n\n---\n\n### 참고\nTailwind CSS도 Next.js에서 쉽게 통합할 수 있으니 관심 있으면 더 자세히 알려드릴게요!  \n그리고 CSS Modules와 같이 쓰면 좀 더 컴포넌트 단위로 깔끔한 스타일링도 가능합니다.\n\n---\n\n요약하자면,\n\n| 내용                      | 설명                                        |\n|-------------------------|-------------------------------------------|\n| 글로벌 CSS              | 앱 전체에 적용되는 기본 스타일, 충돌 주의 필요          |\n| CSS Modules             | 컴포넌트별 국소 스타일링, 충돌 적음                   |\n| Tailwind CSS            | 유틸리티 클래스 기반, 빠른 스타일링 가능               |\n\n필요에 따라 적절한 방법을 골라서 쓰면 되겠습니다!\n\n다음에는 Tailwind CSS 설정법과 활용 팁을 공유할게요. 질문 있으면 부담 없이 알려주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nTailwind CSS는 Next.js와 찰떡같이 잘 어울리는 유틸리티 퍼스트(Utility-First) CSS 프레임워크에요. 쉽게 말해, 미리 만들어진 클래스를 조합해서 빠르고 효율적으로 스타일을 입힐 수 있죠.\n\n### Tailwind 설치하기\n\nTailwind를 바로 써보고 싶다면, 아래 명령어로 필요한 패키지들을 설치하세요:\n\n```bash\nnpm install tailwindcss @tailwindcss/postcss postcss\n```\n\n여기서 `tailwindcss`는 본체이고, `@tailwindcss/postcss`랑 `postcss`는 Tailwind 스타일을 빌드할 때 필요한 도구들이에요. Next.js 프로젝트에서 스타일링할 때 필수라고 생각하면 됩니다.\n\n참고로, 요즘 Next.js 최신 버전에서는 위 패키지 설치 후에 `npx tailwindcss init`으로 설정 파일을 생성해서 Tailwind 설정을 좀 더 커스터마이징할 수 있어요. 스타일을 내가 원하는 대로 바꾸고 싶다면 꼭 해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### Tailwind 설정하기\n\n프로젝트 루트에 `postcss.config.mjs` 파일을 만들어서 PostCSS 설정에 `@tailwindcss/postcss` 플러그인을 추가해보세요! 간단한 설정 하나로 Tailwind CSS의 모든 유틸리티 클래스를 마음껏 사용할 수 있게 됩니다.\n\n예를 들면, `postcss.config.mjs` 파일에 아래처럼 설정을 추가할 수 있어요:\n\n```js\n/** @type {import('tailwindcss').Config} */\nexport default {\n  plugins: {\n    '@tailwindcss/postcss': {},\n  },\n}\n```\n\n\u003e 참고로 Tailwind 설정 파일은 `tailwind.config.js` 혹은 `tailwind.config.mjs`로 따로 만들어져 있어야 합니다. 만약 아직 없다면 기본 설정부터 만들어 놓는 걸 추천드려요. 잘 설정해두면 테마, 색상, 폰트 등 자유롭게 커스터마이징하기도 훨씬 수월합니다.\n\n### Tailwind 사용하기\n\nTailwind를 프로젝트에 제대로 설정했다면, HTML이나 JSX 파일에서 바로 클래스명을 쓰기만 하면 돼요!\n\n```html\n\u003cbutton class=\"bg-blue-500 text-white font-bold py-2 px-4 rounded\"\u003e\n  클릭해봐요!\n\u003c/button\u003e\n```\n\n이렇게 쓰면 버튼에 파란 배경, 하얀 글자, 굵은 글꼴, 약간의 패딩과 둥근 모서리가 한 번에 적용됩니다. 기존 CSS 작성하느라 헷갈릴 필요 없이, 클래스 이름으로 직관적인 스타일링 가능!\n\n\u003e 팁 하나 더! 개발 중에 변경사항이 잘 반영되지 않으면, PostCSS 빌드 프로세스를 재시작하거나 캐시를 지우는 것도 한번 시도해보세요. Tailwind는 JIT(Just-In-Time) 컴파일 기능 덕분에 빠르게 스타일을 적용할 수 있지만 간혹 환경마다 캐시 문제로 반영이 늦을 수 있거든요.\n\n필요한 만큼 쉽고 빠르게 스타일을 적용할 수 있으니 꼭 한번 써보세요! Tailwind는 커뮤니티도 활발해서 다양한 플러그인과 자료들이 많답니다. 앞으로도 더 재미있는 Tailwind 팁들 공유할게요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nTailwind CSS를 Next.js 프로젝트에 적용하려면, 먼저 글로벌 스타일시트에 Tailwind 지시어를 추가해야 해요. 이렇게 하면 Tailwind의 기본 스타일과 유틸리티 클래스들이 전역에서 적용됩니다.\n\n```css\n@import 'tailwindcss';\n```\n\n위 코드를 `globals.css` 같은 전역 스타일 파일에 넣어주세요.\n\n그리고 Next.js 프로젝트의 최상위 레이아웃 파일에서 이 스타일시트를 불러와야 해요. 보통 `app/layout.tsx`나 `app/layout.js`에 아래처럼 `globals.css`를 임포트합니다:\n\n```tsx\nimport type { Metadata } from 'next';\n// 이 스타일들은 애플리케이션의 모든 라우트에 적용됩니다.\nimport './globals.css';\n\nexport const metadata: Metadata = {\n  title: 'Create Next App',\n  description: 'Generated by create next app',\n};\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    \u003chtml lang=\"en\"\u003e\n      \u003cbody\u003e{children}\u003c/body\u003e\n    \u003c/html\u003e\n  );\n}\n```\n\n---\n\n### 조금 더 알아보기\n- 이 `@import 'tailwindcss';`는 Tailwind가 필요한 기본 스타일과 유틸리티 클래스를 불러오는 역할을 해요.\n- 만약 더 세부적으로 `@tailwind base;`, `@tailwind components;`, `@tailwind utilities;` 같은 지시어를 커스텀 스타일시트에 넣는 경우도 있는데, 기본적으로 `@import 'tailwindcss';` 하나로 필요한 부분을 다 가져와요.\n- 그리고 글로벌 스타일을 한 번 적용하면, 각 페이지 컴포넌트에서는 따로 스타일을 임포트할 필요가 없어서 편리하답니다.\n- Tailwind를 제대로 적용했는지 확인하려면, 애플리케이션을 실행 후 개발자 도구에서 클래스들이 잘 붙는지 보고, Tailwind 유틸리티 클래스를 적용해 스타일이 변하는지 테스트해보세요!\n\n이제 Tailwind 스타일이 Next.js 프로젝트 전체에 적용됐으니, 마음껏 유틸리티 클래스를 활용해서 빠르게 스타일링해 보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그럼 이제부터 여러분이 개발하는 애플리케이션에 Tailwind의 유틸리티 클래스를 본격적으로 적용할 수 있어요.\n\n```js\nexport default function Page() {\n  return \u003ch1 className=\"text-3xl font-bold underline\"\u003eHello, Next.js!\u003c/h1\u003e\n}\n```\n\n위 예제처럼 클래스 이름만 쭉 써주면 스타일이 깔끔하게 적용되니 정말 편리하답니다.\n\n---\n\n## Sass 사용하기\n\nNext.js는 Sass와 아주 잘 통합돼 있어서 `.scss`, `.sass` 확장자 둘 다 자유롭게 사용할 수 있어요. \n\nSass는 CSS를 더 효율적이고 구조적으로 관리할 수 있게 해주는 CSS 전처리기인데요, 변수, 중첩, 믹스인 같은 강력한 기능 덕분에 코드 작성이 훨씬 편해진답니다.\n\nNext.js 프로젝트에서 Sass를 사용하려면 일단 `sass` 패키지를 설치해주고 (`npm install sass`), 그다음에 `.scss`나 `.sass` 파일을 임포트해서 바로 스타일을 적용할 수 있어요.\n\n예를 들어,\n\n```scss\n// styles.module.scss\n$primary-color: #4f46e5;\n\n.title {\n  color: $primary-color;\n  font-weight: bold;\n}\n```\n\n```js\nimport styles from './styles.module.scss';\n\nexport default function Page() {\n  return \u003ch1 className={styles.title}\u003eHello, Next.js with Sass!\u003c/h1\u003e;\n}\n```\n\n이렇게 작성하면 Sass가 제공하는 변수 기능도 자연스럽게 쓸 수 있답니다.\n\n---\n\n\u003e 참고로, Sass를 사용하면 CSS 유지보수가 더 쉬워지고, 규모가 큰 프로젝트에서는 특히 효과적이에요. 만약 Tailwind와 Sass 둘 다 같이 쓴다면, Tailwind로 기본 스타일을 빠르게 구성하고, Sass로 좀 더 복잡한 커스텀 스타일을 관리하는 식으로 활용할 수도 있겠죠!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nSass를 컴포넌트 단위로도 사용할 수 있어요. CSS Modules와 함께 `.module.scss`나 `.module.sass` 확장자를 사용하면 되죠. 덕분에 스타일의 범위를 컴포넌트 내부로 한정할 수 있어서, 다른 부분에 영향 주지 않고 스타일을 관리하기 정말 편해집니다.\n\n### Sass 설치 방법\n\nSass를 프로젝트에서 바로 사용하려면 `sass` 패키지를 설치해줘야 해요. 터미널에 아래 명령어만 입력하면 끝!\n\n```bash\nnpm install --save-dev sass\n```\n\n이렇게 하면 `node-sass` 대신 더 빠르고 최신 버전인 `sass`가 설치됩니다. 요즘은 대부분 이 패키지를 추천하고 있으니 꼭 참고하세요!\n\n그리고 Sass를 쓰다 보면 `.scss`와 `.sass` 확장자의 차이가 궁금할 수도 있는데, 간단히 말하면 `.scss`는 CSS 문법과 거의 비슷해서 배우기 쉽고, `.sass`는 들여쓰기를 기반으로 한 문법이에요. 보통 `.scss`를 더 많이 사용한답니다.\n\n만약 Create React App 같은 환경에선 위 설치만 해도 바로 Sass를 쓸 준비가 된 거예요! 컴포넌트별 Sass를 적용하려면 스타일 파일 이름을 `ComponentName.module.scss`처럼 지으면 되고, 이렇게 하면 CSS가 자동으로 모듈화돼서 충돌 없이 안정적입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### Sass 옵션 커스터마이징하기\n\nNext.js에서 Sass 옵션을 설정하고 싶을 때는 `next.config.js` 파일 내에 `sassOptions`를 사용하면 돼요. 예를 들어, 모든 Sass 파일에 공통으로 사용할 변수를 선언하고 싶다면 `additionalData` 옵션을 활용할 수 있어요.\n\n```js\nimport type { NextConfig } from 'next'\n\nconst nextConfig: NextConfig = {\n  sassOptions: {\n    additionalData: `$var: red;`,\n  },\n}\n\nexport default nextConfig\n```\n\n위 예제에서는 Sass 변수 `$var`에 빨간색(`red`) 값을 기본으로 넣어두었어요. 이렇게 설정하면 모든 Sass 파일에서 별도의 선언 없이 `$var` 변수를 바로 사용할 수 있답니다. 덕분에 공통 변수나 믹스인 등을 간편하게 적용할 수 있어요.\n\n\u003e 팁!  \n\u003e `additionalData`는 파일마다 자동으로 추가되는 코드라서, 여러 변수나 스타일 믹스인들을 등록하면 훨씬 효율적으로 Sass를 관리할 수 있어요.  \n\u003e 예를 들어, 공통 색상 팔레트나 폰트 스타일을 미리 정의해두는 식이죠.\n\n---\n\n## CSS-in-JS\n\n(여기서부터 CSS-in-JS에 대해 다룰 예정인데, 추가로 궁금한 부분이 있으면 말씀해 주세요!)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nReact Server Components(RSC)를 사용하다 보면 한 가지 주의할 점이 있어요. 바로 **런타임 시 자바스크립트가 필요한 CSS-in-JS 라이브러리들은 현재 React Server Components에서 지원되지 않는다**는 거죠.\n\n### 왜 이런 제한이 생길까?\nReact Server Components는 서버에서 미리 렌더링하고 클라이언트에서는 최소한의 자바스크립트만 실행하는 방식을 취하기 때문에,\n런타임에 자바스크립트가 꼭 필요한 스타일링 라이브러리들은 당장 호환되기 힘든 상황이에요.\n\n### 그렇다면 어떤 CSS-in-JS 라이브러리는 지금 앱 디렉토리의 Client Components에서 쓸 수 있을까?\n아래는 현재 지원되는 라이브러리 목록입니다. (알파벳순)\n\n| 지원 라이브러리              |\n|-----------------------|\n| ant-design            |\n| chakra-ui             |\n| @fluentui/react-components |\n| kuma-ui               |\n| @mui/material         |\n| @mui/joy              |\n| pandacss              |\n| styled-jsx            |\n| styled-components     |\n| stylex                |\n| tamagui               |\n| tss-react             |\n| vanilla-extract       |\n\n### 지원 관련 고민 중인 라이브러리도 있다!\n현재 React 최신 버전에 맞춰 Server Components와 Streaming 지원을 준비 중인 라이브러리들도 있으니, 앞으로 더 확대될 가능성이 높습니다.\n\n### 추가 팁\n- 만약 CSS-in-JS를 꼭 써야 한다면, Server Component가 아닌 Client Component에서만 해당 라이브러리를 사용하도록 분리하는 방법을 추천해요.\n- 스타일링을 아예 CSS 모듈 또는 vanilla CSS로 관리하거나, `styled-jsx`같이 별도 런타임이 필요 없는 라이트한 스타일러를 고려하는 것도 좋아요.\n\n---\n\nReact 개발하면서 최신 기능들을 써보고 싶은데 스타일링 라이브러리 때문에 고민이라면,\n이 리스트와 팁을 참고해서 내 프로젝트에 맞게 잘 조합해보시길 바라요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- emotion\n\n서버 컴포넌트(Server Components)에 스타일을 입히고 싶다면, CSS 파일을 생성하는 CSS Modules나 Tailwind CSS 같은 솔루션을 사용하는 것을 추천해요. 이 방법들이 서버 컴포넌트와 잘 맞고, 성능 측면에서도 유리하답니다.\n\n### CSS-in-JS 설정하기\n\n만약 CSS-in-JS를 사용하고 싶다면, 다음과 같은 설정이 필요해요: \n\n(여기서는 emotion 같은 CSS-in-JS 라이브러리를 예로 들 수 있겠죠.)\n\n추가로, CSS-in-JS를 사용할 때는 클라이언트 컴포넌트 내에서 스타일 적용이 이뤄지는 경우가 많아서, 서버 컴포넌트에서는 권장되지 않는다는 점을 기억하세요. 상황에 따라 적절한 방식을 선택하는 게 중요해요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nstyle-jsx를 Next.js 같은 React 환경에서 사용할 때 스타일을 깔끔하게 적용하고 수집하는 방법에 대해 알려드릴게요. 보통 SSR(서버 사이드 렌더링)을 하게 되면 스타일이 제대로 적용되는 시점이 중요하거든요. 그래서 스타일을 한 군데 모아 관리하고, 렌더 전에 HTML에 스타일을 주입하는 코드를 작성합니다.\n\n아래는 주요 포인트와 예시 코드입니다.\n\n---\n\n### 스타일 레지스트리 만들기\n\n- `createStyleRegistry()`를 이용해 스타일을 모으는 레지스트리를 만듭니다.\n- 컴포넌트가 처음 렌더될 때 한 번만 생성되도록 `useState`의 lazy initializer 패턴을 씁니다.\n\n### 스타일을 HTML에 주입하기\n\n- `useServerInsertedHTML` 훅을 사용해서 서버에서 렌더링 직전에 스타일 태그를 HTML에 넣어줍니다.\n- 이러면 나중에 페이지가 로드될 때 스타일이 깜빡이거나 지연 없이 바로 적용돼요.\n\n### 클라이언트 컴포넌트에서 래핑하기\n\n- 앱의 최상위 컴포넌트를 스타일 레지스트리로 감싸서 SSR 초기 렌더링할 때 스타일 관리를 집중시킵니다.\n\n---\n\n### Styled-jsx 적용 예시\n\n```jsx\n'use client'\n\nimport React, { useState } from 'react'\nimport { useServerInsertedHTML } from 'next/navigation'\nimport { StyleRegistry, createStyleRegistry } from 'styled-jsx'\n\nexport default function StyledJsxRegistry({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  // 스타일시트를 한 번만 생성 (lazy init)\n  const [jsxStyleRegistry] = useState(() =\u003e createStyleRegistry())\n\n  // 서버 렌더링 시 스타일 태그를 먼저 삽입\n  useServerInsertedHTML(() =\u003e {\n    const styles = jsxStyleRegistry.styles()\n    jsxStyleRegistry.flush()\n    return \u003c\u003e{styles}\u003c/\u003e\n  })\n\n  // 스타일 등록기를 통해 자식 요소들 감싸기\n  return \u003cStyleRegistry registry={jsxStyleRegistry}\u003e{children}\u003c/StyleRegistry\u003e\n}\n```\n\n---\n\n### 부가 팁!\n\n- `StyleRegistry`는 스타일을 수집하고 렌더링하는 역할을 해주기 때문에, 이 컴포넌트로 앱 전체를 감싼다면 스타일 충돌도 관리할 수 있어요.\n- `flush()` 메서드는 수집한 스타일을 비워서 중복 삽입을 막아줍니다.\n- 만약 styled-jsx 외에 Emotion, Styled-components 등 다른 CSS-in-JS 라이브러리를 쓴다면 각각의 서버 스타일 주입 방법이 있으니 참고하세요.\n\n이렇게 하면 서버에서 스타일이 빠르게 적용되어 사용자 경험이 훨씬 좋아집니다! 한 번 적용해 보시면 렌더링 과정에서 스타일이 정확하고 깔끔하게 적용되는 걸 눈으로 확인하실 수 있을 거예요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자, 이제 root layout을 registry로 감싸는 방법을 알려드릴게요.\n\n```js\nimport StyledJsxRegistry from './registry'\n \nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    \u003chtml\u003e\n      \u003cbody\u003e\n        \u003cStyledJsxRegistry\u003e{children}\u003c/StyledJsxRegistry\u003e\n      \u003c/body\u003e\n    \u003c/html\u003e\n  )\n}\n```\n\n이렇게 하면 스타일 관련 문제를 좀 더 깔끔하게 관리할 수 있어요. 특히 여러 컴포넌트에서 스타일이 꼬일 때 유용하죠.\n\n---\n\n### styled-components 사용법\n\n만약 Next.js 프로젝트에서 **styled-components**를 사용하려면, `next.config.js` 파일에서 별도로 활성화해야 해요. 다음과 같이 설정해 주세요:\n\n```js\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  // 기타 설정들...\n\n  compiler: {\n    styledComponents: true,\n  },\n}\n\nmodule.exports = nextConfig\n```\n\n이 설정을 하면 styled-components가 Next.js 컴파일러와 잘 연동되어 SSR (서버사이드 렌더링) 시 스타일이 깨지지 않도록 도와줘요.\n\n---\n\n#### 참고 팁!\n\n- `styled-components` 쓸 때는 Babel 설정도 필요할 수 있는데, Next.js 12 이상이면 위 `compiler` 옵션만으로 대부분 해결돼요.\n- `StyledJsxRegistry` 같은 커스텀 레지스트리를 사용하는 이유는 스타일 충돌을 방지하고, 렌더링 최적화를 위해서입니다.\n- 스타일 관리는 React+Next.js에서 꽤 복잡할 수 있지만, 이런 설정들을 적용하면 훨씬 안정적인 UI를 만들 수 있으니 꼭 적용해 보세요!\n\n궁금한 점 있으면 언제든 물어보세요~\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 `styled-components`를 잘 사용하려면, 기본 설정과 함께 서버 사이드에서 스타일을 제대로 수집하고 HTML `\u003chead\u003e`에 주입하는 작업이 필요해요. 간단히 말해서, SSR 환경에서 스타일이 누락되지 않도록 조치를 취하는 거죠.\n\n### 1. `next.config.js` 설정\n\n일단 Next.js 설정 파일에서 `styledComponents` 플래그를 `true`로 켜줘야 해요. 그렇지 않으면 컴파일러가 스타일드 컴포넌트 문법을 제대로 처리하지 못해요.\n\n```js\nimport type { NextConfig } from 'next';\n\nconst nextConfig: NextConfig = {\n  compiler: {\n    styledComponents: true,\n  },\n};\n\nexport default nextConfig;\n```\n\n이 작업은 CSS 클래스 이름 충돌을 방지하고, 개발 편의성을 높여줘요!\n\n---\n\n### 2. 서버에서 스타일 수집하기: `StyledComponentsRegistry` 컴포넌트\n\n서버 측 렌더링(SSR) 시 모든 스타일 규칙을 모아서 나중에 `\u003chead\u003e` 태그에 삽입해야 해요. 이걸 위해 `ServerStyleSheet`를 사용해서 스타일을 수집하고, `useServerInsertedHTML` 훅으로 클라이언트에 주입합니다.\n\n```js\n'use client';\n\nimport React, { useState } from 'react';\nimport { useServerInsertedHTML } from 'next/navigation';\nimport { ServerStyleSheet, StyleSheetManager } from 'styled-components';\n\nexport default function StyledComponentsRegistry({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  // 스타일시트는 한 번만 생성하도록 lazy 초기화 사용\n  const [styledComponentsStyleSheet] = useState(() =\u003e new ServerStyleSheet());\n\n  useServerInsertedHTML(() =\u003e {\n    const styles = styledComponentsStyleSheet.getStyleElement();\n    styledComponentsStyleSheet.instance.clearTag(); // 기존 태그 초기화\n    return \u003c\u003e{styles}\u003c/\u003e;\n  });\n\n  // 클라이언트에서는 그냥 children만 리턴\n  if (typeof window !== 'undefined') return \u003c\u003e{children}\u003c/\u003e;\n\n  // 서버에서는 StyleSheetManager로 감싸서 스타일 수집\n  return (\n    \u003cStyleSheetManager sheet={styledComponentsStyleSheet.instance}\u003e\n      {children}\n    \u003c/StyleSheetManager\u003e\n  );\n}\n```\n\n#### 핵심 포인트\n\n- `ServerStyleSheet`로 렌더링된 스타일을 묶어서 관리해요.\n- `useServerInsertedHTML` 훅은 서버 호출 시 스타일 태그를 `\u003chead\u003e` 안에 넣어 줍니다.\n- 클라이언트에서는 스타일 수집할 필요가 없으니 그냥 children을 렌더링하죠.\n- 서버에서는 `StyleSheetManager`로 감싸서 스타일링을 추적합니다.\n\n이 구조 덕분에 FOUC(Flash of Unstyled Content, 스타일링 없는 깜빡임)를 없앨 수 있고, SEO와 UX 품질도 깔끔해져요!\n\n---\n\n### 3. 루트 레이아웃에 적용하기\n\n마지막으로 `app/layout.tsx` 같은 루트 레이아웃 파일에서, 기존 children을 `StyledComponentsRegistry`로 감싸주세요.\n\n```tsx\nimport StyledComponentsRegistry from './StyledComponentsRegistry';\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    \u003chtml lang=\"ko\"\u003e\n      \u003chead\u003e{/* 여기에 다른 head 요소들 */}\u003c/head\u003e\n      \u003cbody\u003e\n        \u003cStyledComponentsRegistry\u003e\n          {children}\n        \u003c/StyledComponentsRegistry\u003e\n      \u003c/body\u003e\n    \u003c/html\u003e\n  );\n}\n```\n\n---\n\n## 정리\n\n| 단계                   | 설명                                                                                |\n|------------------------|-----------------------------------------------------------------------------------|\n| 1. next.config.js 설정  | `compiler.styledComponents: true`를 켜서 styled-components 컴파일러를 활성화            |\n| 2. StyledComponentsRegistry 작성 | 서버 스타일 수집용 컴포넌트 작성. `ServerStyleSheet`, `useServerInsertedHTML` 활용  |\n| 3. 루트 레이아웃 감싸기  | 레이아웃에서 모든 children을 위 컴포넌트로 감싸서 SSR 시 스타일 누락 방지                |\n\n---\n\n### 참고 팁\n\n- `styled-components` 이전 버전에서는 `_document.js`에서 SSR 설정을 하곤 했는데, Next.js 13의 App Router에서는 `useServerInsertedHTML` 훅으로 훨씬 더 간편하게 적용할 수 있어요.\n- `ServerStyleSheet` 인스턴스는 꼭 한 번만 생성하고 재사용해야 렌더링 시 메모리 누수를 방지합니다.\n- 개발 중에 styles가 이상하게 보이면 캐시를 삭제하고 다시 빌드해 보는 것도 좋아요.\n\n---\n\n이 방법으로 프로젝트에서 `styled-components`를 깔끔하게 SSR 환경에 맞게 쓸 수 있답니다! 혹시 더 궁금한 점 있으면 언제든 물어봐 주세요~ 🚀\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번 글에서는 React 컴포넌트에서 외부 스타일시트를 다루는 방법과 styled-components를 사용하는 루트 레이아웃 구성을 소개할게요.\n\n먼저, styled-components를 활용한 RootLayout 컴포넌트 모습부터 살펴봅시다.\n\n```jsx\nimport StyledComponentsRegistry from './lib/registry'\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    \u003chtml\u003e\n      \u003cbody\u003e\n        \u003cStyledComponentsRegistry\u003e{children}\u003c/StyledComponentsRegistry\u003e\n      \u003c/body\u003e\n    \u003c/html\u003e\n  )\n}\n```\n\n여기서 StyledComponentsRegistry는 styled-components를 SSR(서버 사이드 렌더링)에서 제대로 작동하게 하도록 도와주는 역할을 해요. 만약 여러분이 Next.js 같은 프레임워크를 사용한다면, SSR 시 스타일 섞임 현상이나 스타일 누락 문제를 줄이는데 아주 유용하죠.\n\n그 다음, 외부 패키지에서 제공하는 CSS 파일을 불러오는 방법입니다. 예시로 Bootstrap CSS를 활용해 볼게요.\n\n```jsx\nimport 'bootstrap/dist/css/bootstrap.css'\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    \u003chtml lang=\"en\"\u003e\n      \u003cbody className=\"container\"\u003e{children}\u003c/body\u003e\n    \u003c/html\u003e\n  )\n}\n```\n\n이렇게 레이아웃 최상위 루트에 Bootstrap을 임포트해서 전체 앱에 적용할 수 있어요. 이렇게 하면 별도로 각 컴포넌트마다 스타일을 임포트하지 않아도 되니 편리합니다.\n\n추가 팁을 드리자면:\n\n- 외부 CSS는 글로벌하게 적용되기 때문에 기본값 덮어쓰기나 클래스 충돌을 염두에 두고 사용하세요.\n- styled-components 같이 CSS-in-JS 방식을 쓰면서 외부 스타일시트를 혼합하는 경우, 스타일 우선순위나 특정성 specificity를 고려해야 합니다.\n- 종종 styled-components로 스타일을 작성하면서 Bootstrap처럼 미리 만들어진 UI 라이브러리 CSS를 함께 쓰면, 코드 재사용성과 개발 생산성을 높일 수 있으니 두 방식을 적절히 섞는 걸 추천합니다!\n\n요약하자면, styled-components SSR 설정을 통해 안정적인 스타일 렌더링을 확보하고, 외부 CSS는 전역에 한번만 불러오는 방식을 취하면 여러분 프로젝트의 스타일 관리가 훨씬 깔끔해질 거예요. 필요한 부분에서는 컴포넌트 단위로 스타일을 나누고, 글로벌 스타일이나 라이브러리는 루트 레이아웃에서 한꺼번에 관리하는 게 좋아요.\n\n이제 여러분도 Next.js 프로젝트나 React 앱에서 스타일시트 관리가 좀 더 수월해지길 바랍니다! 궁금한 점 있으면 언제든 댓글로 알려주세요. :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n외부 스타일시트는 꼭 npm 패키지에서 직접 가져오거나, 파일을 다운받아서 내 프로젝트 코드와 함께 두어야 해요. 그러니까 `\u003clink rel=\"stylesheet\" /\u003e` 태그처럼 외부 URL을 그냥 연결해서 쓰는 방식은 사용할 수 없다는 뜻이죠.\n\n왜 그런 규칙이 있냐면, 보통 이렇게 하면 스타일이 내 프로젝트 안에 완전히 포함되기 때문에 빌드하거나 배포할 때 의존성이 깔끔해지고, 네트워크 지연 없이 더 빠르게 스타일을 적용할 수 있으니까요.\n\n실제로 CSS 가져오는 방법은 크게 두 가지예요:\n\n1. **npm 패키지에서 직접 import**  \n   예를 들어, `import 'package-name/dist/style.css';` 이렇게 사용하면 스타일시트가 내 프로젝트 안에서 관리되니까 편리해요.\n\n2. **파일 다운로드 후 프로젝트에 포함**  \n   필요한 CSS 파일을 직접 다운받아서 `/styles` 같은 디렉터리에 넣고,  \n   `import './styles/custom.css';` 이런식으로 불러옵니다.\n\n이때 주의할 점은, 외부에서 그냥 `\u003clink\u003e` 태그로 불러오면 리액트 같은 프레임워크 환경에서 스타일 관리가 까다로워지고, 로드 타이밍 문제도 생길 수 있으니 가급적 권장하지 않는다는 거예요.\n\n개발할 때 이런 점 참고해서, 스타일 관리도 깔끔하게 하는 습관 들이면 좋아요! 필요하면 이후에 CSS-in-JS 같은 방법도 한번 알아보시는 걸 추천드립니다. 스타일시트와 자바스크립트를 한 곳에서 관리하니까 훨씬 효율적이거든요.","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":25},{"title":"Nextjs 15에서 이미지와 폰트 최적화하는 방법","description":"","date":"2025-04-22 01:05","slug":"2025-04-22-Howtooptimizeimagesandfonts","content":"\n# 이미지와 폰트 최적화하는 방법\n\nNext.js는 이미지와 폰트 최적화를 자동으로 지원해줘요. 이 글에서는 어떻게 이 기능들을 활용할 수 있는지 쉽게 알려드릴게요.\n\n## 이미지 최적화하기\n\nNext.js의 `Image` 컴포넌트는 기본 HTML의 `img` 태그를 확장한 건데요, 여기에는 여러 가지 좋은 점이 있어요:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이미지 최적화는 웹 성능 향상에 정말 중요한 부분인데요! Next.js의 `next/image` 컴포넌트를 사용하면 여러 가지 유용한 기능들을 쉽게 활용할 수 있습니다.\n\n- **크기 최적화 (Size optimization)**: 각 디바이스에 맞게 자동으로 적절한 크기의 이미지를 제공해주고, WebP 같은 최신 이미지 포맷도 지원해서 용량을 줄여줘요.\n- **시각적 안정성 (Visual stability)**: 이미지가 로딩되는 동안 레이아웃이 흔들리거나 이동하지 않도록 자동으로 잡아줍니다.\n- **빠른 페이지 로드 (Faster page loads)**: 뷰포트에 들어올 때까지 이미지를 로드하지 않는 '네이티브 지연 로딩(lazy loading)'을 사용하며, 옵션으로 흐릿한 블러(blur-up) 플레이스홀더도 추가할 수 있어요.\n- **유연한 자산 관리 (Asset flexibility)**: 로컬 이미지뿐만 아니라 원격 서버에 있는 이미지도 필요에 따라 크기를 조절하며 불러올 수 있습니다.\n\n시작하려면 `next/image`에서 `Image`를 import하고, 컴포넌트 안에서 이렇게 사용해보세요.\n\n```js\nimport Image from \"next/image\";\n\nexport default function Page() {\n  return \u003cImage src=\"\" alt=\"\" /\u003e;\n}\n```\n\n- `src` 속성에는 로컬 이미지 경로나 외부 URL 모두 들어갈 수 있어요.\n- `alt` 속성은 이미지 설명으로 SEO와 접근성에 매우 중요하니 꼭 넣어주세요!\n\n---\n\n### 추가 팁!\n\n- `width`와 `height`를 명시해주면 레이아웃이 더 안정적이라 로딩 시 레이아웃 이동(Cumulative Layout Shift)을 방지할 수 있어요.\n- 원격 이미지 URL을 써야 하면 `next.config.js`에 `domains` 설정을 해줘야 로딩이 허용됩니다.\n\n```js\n// next.config.js\nmodule.exports = {\n  images: {\n    domains: [\"example.com\"], // 허용할 원격 이미지 도메인\n  },\n};\n```\n\n- `placeholder=\"blur\"` 옵션을 주면 흐릿한 이미지가 먼저 보이면서 자연스러운 로딩 경험을 줄 수도 있고, 특히 느린 네트워크에서 효과적입니다.\n\n이렇게만 활용해도 페이지 퍼포먼스와 사용자 경험이 꽤 개선될 거예요! 앞으로 프로젝트에 멋지게 적용해 보세요 :)\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 로컬 이미지 사용하기\n\nNext.js에서는 이미지나 폰트 같은 정적 파일을 프로젝트 루트 디렉터리에 `public`이라는 폴더를 만들어서 관리할 수 있어요. 이렇게 `public` 폴더 안에 저장한 파일들은 코드에서 기본 URL(`/`)부터 시작해서 쉽게 불러올 수 있답니다.\n\n예를 들어, `public/assets/img/2025-04-22-Howtooptimizeimagesandfonts_0.png`라는 이미지가 있다면 HTML에서는 이렇게 사용할 수 있어요:\n\n```html\n\u003cimg src=\"/TIL/assets/img/2025-04-22-Howtooptimizeimagesandfonts_0.png\" /\u003e\n```\n\n---\n\n더 나아가 Next.js에서 권장하는 방법인 `next/image` 컴포넌트를 써보면 이렇게 됩니다:\n\n```jsx\nimport Image from \"next/image\";\nimport profilePic from \"./me.png\";\n\nexport default function Page() {\n  return (\n    \u003cImage\n      src={profilePic}\n      alt=\"Picture of the author\"\n      // width={500} 자동으로 제공됨\n      // height={500} 자동으로 제공됨\n      // blurDataURL=\"data:...\" 자동 제공 (로딩 시 블러 효과)\n      // placeholder=\"blur\" // 로딩 중에 흐릿하게 미리보기 하는 옵션 (선택 사항)\n    /\u003e\n  );\n}\n```\n\n`next/image`를 쓰면 이미지 크기 최적화, 자동 레이지 로딩(lazy loading), 웹 최적화 포맷 변환 등 다양한 이점을 누릴 수 있어서 성능 개선에 특히 좋아요.\n\n\u003e TIP: `next/image`는 이미지를 직접 `import`로 불러와야 제대로 작동하니, 프로젝트 내 이미지 파일 경로를 정확히 지정해 주세요!  \n\u003e 그리고 `public` 폴더 내 이미지 파일을 사용할 땐 `src`에 문자열 경로(`/assets/img/example.png`)를 직접 넣으면 되고, import해서 사용하는 경우는 외부나 프로젝트 내부 파일을 가리킬 때 주로 쓰입니다.\n\n이렇게 하면 로컬 이미지 자원을 깔끔하게 관리하면서 Next.js의 최적화 기능도 빵빵하게 사용할 수 있으니 꼭 활용해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js는 이미지 파일을 가져올 때, 이미지의 고유 너비와 높이를 자동으로 판단해줘요. 이 값을 이용해서 이미지 비율을 정하고, 이미지가 로딩되는 동안 발생할 수 있는 레이아웃 흔들림(Cumulative Layout Shift)을 막아줍니다. 덕분에 사용자 경험이 훨씬 좋아지죠.\n\n### 원격 이미지 사용하기\n\n로컬 이미지뿐만 아니라, 원격 서버에 있는 이미지도 사용할 수 있어요. 이때는 `src` 속성에 이미지 URL을 바로 넣어주면 됩니다.\n\n```js\nimport Image from \"next/image\";\n\nexport default function Page() {\n  return (\n    \u003cImage src=\"https://s3.amazonaws.com/my-bucket/profile.png\" alt=\"Picture of the author\" width={500} height={500} /\u003e\n  );\n}\n```\n\n\u003e 참고로, 원격 이미지 URL을 사용할 때도 `width`와 `height`를 꼭 명시해주셔야 합니다. 이렇게 하면 Next.js가 이미지 공간을 미리 확보해서 페이지가 흔들리지 않도록 해주거든요.\n\n혹시 원격 이미지 도메인이 반복적으로 쓰인다면, `next.config.js` 파일에서 도메인을 허용해주는 설정도 해주시면 좋아요. 예를 들어:\n\n```js\n// next.config.js\nmodule.exports = {\n  images: {\n    domains: [\"s3.amazonaws.com\"],\n  },\n};\n```\n\n이 설정을 해줘야 Next.js가 해당 도메인의 이미지를 최적화하고 사용할 수 있으니 꼭 기억하세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js를 사용할 때, 빌드 과정에서 원격(remote) 이미지 파일에 직접 접근할 수 없기 때문에, 이미지 컴포넌트에 width, height 그리고 선택적으로 blurDataURL 같은 속성들을 직접 지정해줘야 해요. 이 width와 height 정보는 이미지가 로딩되면서 화면이 깜빡이거나 레이아웃이 순간적으로 바뀌는 현상(layout shift)을 막아주고, 올바른 비율(aspect ratio)을 유지하는 데 도움이 되죠.\n\n그리고 원격 서버에서 이미지를 안전하게 불러오려면, next.config.js 파일에서 허용할 원격 이미지 URL 패턴을 정확하게 명시해줘야 해요. 이렇게 구체적으로 지정하는 이유는 보안상 악의적인 URL이 들어오는 걸 막기 위함입니다. 예를 들어 아래와 같이 특정 AWS S3 버킷에서만 이미지를 불러오도록 설정할 수 있어요:\n\n```js\nimport { NextConfig } from \"next\";\n\nconst config: NextConfig = {\n  images: {\n    remotePatterns: [\n      {\n        protocol: \"https\",\n        hostname: \"s3.amazonaws.com\",\n        port: \"\",\n        pathname: \"/my-bucket/**\",\n        search: \"\",\n      },\n    ],\n  },\n};\n\nexport default config;\n```\n\n위처럼 설정하면 s3.amazonaws.com 도메인의 /my-bucket 경로 밑에 있는 이미지들만 Next.js 이미지 최적화 기능을 통해 불러올 수 있게 돼요.\n\n---\n\n### 추가로 알려드리는 팁!\n\n- 원격 이미지의 크기를 정확히 알기 어렵다면, 개발자 도구나 디자인 툴에서 미리 가로, 세로 크기를 측정해 넣는 걸 추천합니다.\n- `blurDataURL` 속성은 낮은 해상도의 이미지 베이스64 데이터를 넣어 이미지가 로딩될 때 부드럽게 보여주는 효과를 줍니다. 사용자 경험을 개선하는 데 특히 유용해요.\n- 때로는 이미지를 캐싱하기 위해 CDN을 사용합니다. 이럴 때도 해당 CDN 도메인에 맞게 remotePatterns 설정을 해줘야 하니 참고하세요.\n\n---\n\n## 폰트 최적화하기 (Optimizing Fonts)\n\nNext.js는 기본적으로 디폴트 폰트를 빠르게 로딩하기 위한 몇 가지 기능을 제공하는데요, 웹폰트를 최적화하면 페이지 로딩 속도를 개선하고, 불필요한 폰트 파일 다운로드를 줄일 수 있습니다. 이 주제에 대해서도 곧 상세하게 다뤄볼게요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nnext/font 모듈은 폰트를 자동으로 최적화해주고, 외부 네트워크 요청을 없애서 개인정보 보호와 성능을 동시에 잡아줍니다.\n\n이 모듈은 폰트 파일을 자체 호스팅하는 기능도 내장하고 있어요. 덕분에 웹 폰트를 불러올 때 레이아웃이 흔들리는 현상(레이아웃 시프트) 없이 깔끔하게 로딩할 수 있답니다.\n\n사용법도 간단해요! next/font에서 제공하는 `local` 혹은 `google` 폰트 모듈을 불러오고, 필요한 옵션을 주면서 함수를 호출해서 폰트를 적용할 엘리먼트의 `className`에 할당하면 됩니다.\n\n아래는 구체적인 예시 코드인데요, 제가 좀 더 완성된 형태로 정리해봤어요.\n\n```js\n// 예를 들어 구글 폰트를 불러올 땐 이렇게!\nimport { Roboto } from \"next/font/google\";\n\nconst roboto = Roboto({\n  subsets: [\"latin\"],\n  weight: [\"400\", \"700\"],\n  style: [\"normal\", \"italic\"],\n});\n\nexport default function Layout({ children }: { children: React.ReactNode }) {\n  return (\n    \u003chtml lang=\"ko\"\u003e\n      \u003cbody className={roboto.className}\u003e{children}\u003c/body\u003e\n    \u003c/html\u003e\n  );\n}\n```\n\n여기서 `Roboto`는 구글에서 제공하는 대표적인 구글 폰트 중 하나입니다. 옵션으로는 `subsets` (영문 등 문자 범위), `weight` (폰트 굵기), `style` (normal, italic 등)를 지정할 수 있어요.\n\n- **장점!**\n  - 폰트가 페이지에서 필요한 부분에만 로딩되어 초기 로딩 속도가 빨라집니다.\n  - 폰트를 외부 서버에서 가져오는 대신 자체 서버에서 제공해 개인정보도 안심!\n  - CSS에서 자주 발생하는 폰트 관련 CLS (Layout Shift) 문제를 예방할 수 있어요.\n\n간단하게 `next/font`를 사용하는 방법 알려드렸는데, 실제 프로젝트에 도입해 보면 성능 개선이 꽤 느껴진답니다. 혹시 직접 폰트 파일을 프로젝트에 추가해서 쓰고 싶다면 `next/font/local` 모듈을 참고해보세요. `next/font/google`처럼 쓰되, 폰트 파일 경로를 지정해서 불러올 수 있습니다.\n\n새 프로젝트에 폰트 적용 고민 중이라면, 이 방법 꼭 한 번 써보시길 추천드려요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 구글 폰트 자동 호스팅하기\n\n웹사이트에 예쁜 글꼴을 적용할 때 구글 폰트를 많이 사용하시죠? 근데 여러분, 구글 폰트를 그냥 링크 걸어서 쓰면 사용자의 브라우저가 구글 서버에 직접 요청을 보내서 폰트를 가져오거든요. 이러면 약간 속도가 느려질 수도 있고, 개인정보 측면에서 꺼려질 수도 있죠.\n\n그런데 Next.js에서는 구글 폰트를 배포할 때 자동으로 내 서버에서 직접 호스팅해서 폰트를 제공할 수 있어요. 이렇게 하면 사용자가 우리 사이트에 접속할 때 구글 서버로 요청이 나가지 않고, 우리 도메인에서 바로 폰트를 받으니 더 빠르고 깔끔해집니다.\n\n아래처럼 간단하게 `next/font/google`에서 원하는 폰트를 import하고 설정해주면 끝!\n\n```js\nimport { Geist } from \"next/font/google\";\n\nconst geist = Geist({\n  subsets: [\"latin\"],\n});\n\nexport default function RootLayout({ children }) {\n  return (\n    \u003chtml lang=\"en\" className={geist.className}\u003e\n      \u003cbody\u003e{children}\u003c/body\u003e\n    \u003c/html\u003e\n  );\n}\n```\n\n- `subsets` 옵션은 폰트에서 사용할 문자의 범위를 설정해요. 예를 들어 `latin`은 영어권 문자에 해당하고, 한국어는 `korean` 서브셋을 따로 지원하는 폰트가 많으니 필요하면 추가해주면 됩니다.\n- 이렇게 하면 폰트 파일들이 빌드 때 내 사이트에 포함되고, 별도 요청 없이 바로 렌더링되어 속도도 좋아져요.\n\n참고로, 커스텀 폰트를 쓰거나 구글 폰트 말고 다른 외부 폰트를 사용할 때도 비슷하게 직접 호스팅하는 걸 추천합니다. 사이트 속도도 개선하고, 외부 서버 의존도를 낮출 수 있으니까요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n변수 폰트(variable fonts)를 사용하는 걸 추천해요! 성능도 좋고 유연하게 폰트를 조절할 수 있어서요. 만약 변수 폰트를 쓸 수 없는 상황이라면, 폰트의 굵기(weight)를 꼭 지정해줘야 해요.\n\n예를 들어, Google 폰트인 Roboto를 Next.js에서 사용할 때는 이렇게 작성해요:\n\n```js\nimport { Roboto } from \"next/font/google\";\n\nconst roboto = Roboto({\n  subsets: [\"latin\"],\n});\n\nexport default function RootLayout({ children }: { children: React.ReactNode }) {\n  return (\n    \u003chtml lang=\"en\" className={roboto.className}\u003e\n      \u003cbody\u003e{children}\u003c/body\u003e\n    \u003c/html\u003e\n  );\n}\n```\n\n위 코드에서 `Roboto`는 변수 폰트로 불러와서, 원하는 굵기나 스타일을 쉽게 조절할 수 있답니다.\n\n---\n\n### 로컬 폰트 사용하는 방법\n\n로컬에 저장된 폰트를 사용하고 싶을 땐 `next/font/local`에서 폰트를 임포트하면 돼요. 그리고 폰트 파일(src)의 경로를 꼭 지정해줘야 해요.\n\n```js\nimport localFont from \"next/font/local\";\n\nconst myFont = localFont({\n  src: \"./fonts/MyFont.woff2\",\n  weight: \"400\",\n  style: \"normal\",\n});\n\nexport default function RootLayout({ children }) {\n  return (\n    \u003chtml lang=\"en\" className={myFont.className}\u003e\n      \u003cbody\u003e{children}\u003c/body\u003e\n    \u003c/html\u003e\n  );\n}\n```\n\n여기서 주의할 점은, 로컬 폰트를 쓸 땐 폰트 파일의 형식(woff, woff2, ttf 등)에 따라 브라우저 호환성이 달라질 수 있으니 여러 형식을 같이 넣어주는 것도 좋은 방법이에요.\n\n---\n\n추가로, 변수 폰트를 쓰면 파일 사이즈도 줄일 수 있는데, 왜냐하면 한 파일 내에서 여러 굵기와 스타일을 다룰 수 있기 때문이죠. 기존엔 굵기별로 따로 폰트 파일을 불러와야 했거든요. 그래서 성능 최적화에도 큰 도움이 돼요!\n\n궁금한 점 있으면 댓글로 남겨주세요~\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 `localFont`를 사용해서 로컬 폰트를 불러오는 방법에 대해 이야기해볼게요. 폰트를 프로젝트 안에 직접 넣고 사용할 때 정말 유용한 기능인데요, 예를 들어 아래처럼 간단히 사용할 수 있어요.\n\n```js\nimport localFont from \"next/font/local\";\n\nconst myFont = localFont({\n  src: \"./my-font.woff2\",\n});\n\nexport default function RootLayout({ children }: { children: React.ReactNode }) {\n  return (\n    \u003chtml lang=\"en\" className={myFont.className}\u003e\n      \u003cbody\u003e{children}\u003c/body\u003e\n    \u003c/html\u003e\n  );\n}\n```\n\n이 코드의 핵심은 `localFont`가 폰트 파일 경로를 받아서 내부적으로 `@font-face`를 생성해주고, 관련 CSS 클래스를 제공합니다. `myFont.className`을 html 태그에 넣으면 페이지 전체에 해당 폰트가 적용돼요.\n\n그리고 보통 하나의 폰트 패밀리에는 다양한 스타일과 두께가 있기 마련이죠? 예를 들면 일반체, 이탤릭, 굵은 글씨 등등. 이런 경우에는 `src`를 배열 형태로 넘겨서 각각의 스타일과 무게를 지정할 수 있습니다.\n\n```js\nconst roboto = localFont({\n  src: [\n    {\n      path: \"./Roboto-Regular.woff2\",\n      weight: \"400\",\n      style: \"normal\",\n    },\n    {\n      path: \"./Roboto-Italic.woff2\",\n      weight: \"400\",\n      style: \"italic\",\n    },\n    {\n      path: \"./Roboto-Bold.woff2\",\n      weight: \"700\",\n      style: \"normal\",\n    },\n    {\n      path: \"./Roboto-BoldItalic.woff2\",\n      weight: \"700\",\n      style: \"italic\",\n    },\n  ],\n});\n```\n\n이렇게 하면 폰트를 사용할 때 보통 CSS에서 하는 `font-weight`, `font-style` 같은 속성들도 그대로 적용되니 굉장히 편리해요. 페이지에서 `\u003cp style={{ fontWeight: '700', fontStyle: 'italic' }}\u003e` 이런 식으로 쓰면 `Roboto-BoldItalic.woff2`가 적용되는 거죠.\n\n추가 팁으로, 이 방법은 폰트 파일을 직접 관리하기 때문에 구글 폰트 CDN과 달리 네트워크 지연이나 외부 서비스 의존이 없어서 성능 면에서도 좋고, 개인정보 보호에도 유리하답니다!\n\n### 요약\n\n| 특징                                 | 설명                                              |\n| ------------------------------------ | ------------------------------------------------- |\n| `localFont` 사용법                   | 폰트를 로컬에서 직접 불러옴                       |\n| 단일 파일 폰트 지정                  | `src`에 한 개의 폰트 파일 경로 지정               |\n| 여러 스타일/두께 폰트 지정           | `src`를 배열로 주고 각각의 `weight`, `style` 지정 |\n| 자동으로 클래스 및 `@font-face` 생성 | 폰트를 클래스 이름으로 쉽게 적용 가능             |\n| 성능 및 개인정보 보호                | 외부 호출 없이 빠르고 안전함                      |\n\nNext.js 프로젝트에서 폰트를 더 세밀하게 컨트롤하고 싶다면, 이렇게 `localFont` 사용을 적극 추천해요!\n","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":13},{"title":"Next.js 15에서 레이아웃과 페이지 쉽게 만드는 방법","description":"","date":"2025-04-22 01:01","slug":"2025-04-22-Howtocreatelayoutsandpages","content":"\n# 레이아웃과 페이지 만드는 방법\n\nNext.js는 파일 시스템 기반 라우팅을 사용해요. 즉, 폴더와 파일 구조를 활용해서 라우트를 정의할 수 있다는 거죠. 이번 글에서는 레이아웃과 페이지를 어떻게 만들고 서로 링크하는지 쉽게 알려드릴게요.\n\n## 페이지 만들기\n\n페이지란 특정 경로에서 렌더링되는 UI를 뜻해요. 페이지를 만들려면 `app` 디렉토리 안에 파일을 추가하고, 그 파일에서 React 컴포넌트를 기본 내보내기(default export) 하면 됩니다. 예를 들어, 인덱스 페이지(`/`)를 만들고 싶으면 아래처럼 하면 돼요:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 이미지는 Next.js에서 페이지를 간단하게 만드는 예시 코드와 관련된 내용입니다.\n\n```js\nexport default function Page() {\n  return \u003ch1\u003eHello Next.js!\u003c/h1\u003e;\n}\n```\n\n위 예시처럼 기본적으로 Next.js에서는 함수를 작성해서 간단한 페이지를 만들 수 있어요.\n\n---\n\n## 레이아웃 만들기 (Creating a layout)\n\n레이아웃(layout)이란 여러 페이지에서 공통으로 쓰이는 UI를 의미해요. 예를 들어 네비게이션 바, 사이드 메뉴, 푸터 같은 부분들이 여기에 해당하겠죠.\n\nNext.js의 장점 중 하나는 네비게이션을 할 때 레이아웃이 다시 렌더링되지 않고, 상태를 유지하며 대화형을 계속 유지한다는 점이에요. 덕분에 페이지가 바뀌어도 빠르고 자연스러운 사용자 경험을 제공할 수 있어요.\n\n\u003e **추가 팁!**  \n\u003e 레이아웃을 만들 땐 `app/layout.js` 파일을 활용하면 좋아요. 이 파일에 공통 UI를 정의하면, 그 하위에 있는 모든 페이지에서 레이아웃이 자동으로 적용됩니다. 그래서 중복 코드를 줄이고, 전체 애플리케이션의 구조를 깔끔하게 관리할 수 있답니다.\n\n---\n\n여기까지 Next.js에서 어떻게 간단한 페이지를 만들고, 공통 UI를 위해 레이아웃을 활용하는지 살펴봤어요. 다음에는 레이아웃을 실제로 구현하는 방법에 대해 더 깊게 다뤄볼게요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n리액트에서 레이아웃(Layout)을 정의하는 방법에 대해 이야기해볼게요. 기본적으로 레이아웃 파일에서 React 컴포넌트를 default export 하면 레이아웃으로 사용할 수 있어요. 이 컴포넌트는 꼭 `children` prop을 받아야 하는데요, 이 `children`이 바로 각각의 페이지나 다른 레이아웃이 될 수 있답니다.\n\n예를 들어, `app` 디렉토리 안에 레이아웃 파일을 만들어서, 그 안에 index 페이지를 자식으로 받는 레이아웃을 만들어보는 거죠.\n\n아래 코드를 보면 어떻게 구성되는지 감이 잡히실 거예요.\n\n```jsx\nexport default function DashboardLayout({ children }: { children: React.ReactNode }) {\n  return (\n    \u003chtml lang=\"en\"\u003e\n      \u003cbody\u003e\n        {/* 레이아웃 UI 영역 */}\n        {/* 여기에 children을 넣어서 페이지나 중첩된 레이아웃을 렌더링 */}\n        \u003cmain\u003e{children}\u003c/main\u003e\n      \u003c/body\u003e\n    \u003c/html\u003e\n  );\n}\n```\n\n이렇게 레이아웃 컴포넌트를 만들면, `DashboardLayout`이 감싸는 모든 페이지는 이 레이아웃 UI 안에 렌더링됩니다. 즉, 공통적으로 적용하고 싶은 UI(헤더, 사이드바, 푸터 등)를 레이아웃 컴포넌트 안에 넣으면 유지보수가 훨씬 편해지죠.\n\n더불어, Next.js 13 이상에서는 `app` 폴더 기반 라우팅 시스템에서 이런 레이아웃 정의가 기본으로 사용되니 꼭 익혀두면 좋아요!\n\n참고로, `children`에 들어가는 값이 또 다른 레이아웃일 수도 있어서, 레이아웃을 중첩해서 사용할 수 있다는 점도 기억해두세요.\n\n필요하다면, 레이아웃에 헤더, 네비게이션 바 등을 넣어 사용자 경험이 일관되게 만들어주는 용도로 아주 유용하답니다!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위에 나오는 레이아웃을 '루트 레이아웃(root layout)'이라고 부르는데요, 그 이유는 앱 디렉토리의 최상단(루트)에 정의되기 때문이에요. 루트 레이아웃은 앱에 꼭 필요하고, html 태그와 body 태그를 반드시 포함해야 한다는 점도 기억하세요.\n\n## 중첩 네스트드 라우트(Nested Route) 만들기\n\n네스트드 라우트는 여러 URL 세그먼트로 구성된 경로를 의미해요. 쉽게 말해, URL이 여러 부분으로 나뉘어 있는 구조죠. 예를 들어서, `/blog/[slug]` 라우트는 세 개의 세그먼트로 이루어져 있어요:\n\n| 세그먼트 종류 | 설명                                | 예시     |\n| ------------- | ----------------------------------- | -------- |\n| 루트 세그먼트 | 최상위 경로                         | `/`      |\n| 중간 세그먼트 | 중간 디렉토리경로                   | `blog`   |\n| 리프 세그먼트 | 마지막 세그먼트(동적 세그먼트 포함) | `[slug]` |\n\n여기서 `[slug]`는 동적 세그먼트를 의미하는데, 예를 들어 특정 블로그 글의 고유 주소 부분을 표현할 때 사용돼요.\n\n추가로, 중첩 라우팅을 활용하면 UI를 더 효율적으로 구성할 수 있어요. 예를 들어 공통 레이아웃을 중간 세그먼트인 `blog` 아래에 두고, 각 글은 그 레이아웃 안에서 화면에 표시하는 식이죠. Next.js나 React 기반 프레임워크에서 이런 네스트드 라우팅을 지원해주니까 활용해보시면 좋아요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 라우트를 어떻게 만들고 관리하는지 간단하게 알려줄게요!\n\n---\n\n### Next.js 라우팅 기본 개념\n\n- **폴더**: URL 경로(segment)를 정의하는 역할을 해요.\n- **파일**: 예를 들어 `page.tsx`나 `layout.tsx` 같은 파일은 해당 경로(segment)에 보여질 UI를 담당해요.\n\n---\n\n### 중첩 라우트 만드는 법\n\n중첩 라우트를 만들고 싶으면 폴더 안에 폴더를 계속 넣으면 돼요.\n\n예를 들어, `/blog` 라는 경로를 만들고 싶다고 하면,  \n`app` 폴더 안에 `blog`라는 폴더를 만들면 됩니다.\n\n그리고 `/blog` 경로에서 보여줄 페이지를 만들려면, `blog` 폴더 안에 `page.tsx` 파일을 만들어야 해요.  \n이 `page.tsx`가 실제로 `/blog` 경로에서 렌더링될 UI를 담당하죠.\n\n---\n\n### 구조 예시\n\n| 경로                | 설명                                  |\n| ------------------- | ------------------------------------- |\n| `app/blog/`         | `/blog` 경로(라우트)의 폴더           |\n| `app/blog/page.tsx` | `/blog` 경로에 보여질 페이지 컴포넌트 |\n\n---\n\n### 추가 꿀팁!\n\n- Next.js 13부터는 `app` 디렉토리 기반의 라우팅이 기본이에요. 이전의 `pages` 폴더 스타일보다 훨씬 직관적이고, 레이아웃 관리도 편해졌어요.\n- `layout.tsx` 파일을 같은 위치 혹은 상위 폴더에 두면, 그 경로에 공통으로 적용되는 레이아웃을 만들 수 있답니다.\n- 예를 들어, `app/blog/layout.tsx`를 만들면 `/blog` 아래 모든 페이지가 공통 레이아웃을 가지게 되죠.\n\n---\n\n이미지로 보면 이런 느낌이에요!\n\n![폴더 구조와 page.tsx](/TIL/assets/img/2025-04-22-Howtocreatelayoutsandpages_2.png)  \n(※ 실제 이미지 주소가 다르다면 알맞게 수정해 주세요.)\n\n---\n\nNext.js로 라우팅 구조 짤 때는 folder = URL segment, 그리고 그 segment에 보여줄 UI는 파일로 관리한다!  \n이 공식만 기억하면 중첩 라우팅도 쉽게 할 수 있으니까 꼭 익혀두세요! 😊\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n계속해서 중첩 폴더를 만들어 경로를 중첩해서 관리할 수 있어요. 예를 들어, 블로그 개별 포스트 페이지를 만들고 싶다면 `blog` 폴더 안에 `[slug]`라는 이름의 폴더를 새로 만들고, 그 안에 `page.js` 파일을 추가하면 됩니다.\n\n아래처럼 기본적으로 `generateStaticParams` 함수를 만들어서 어떤 슬러그들이 있을지 미리 정의해줄 수도 있어요.\n\n```js\nfunction generateStaticParams() {\n  // 예: 블로그 글 슬러그들을 담아 리턴\n  return [{ slug: \"my-first-post\" }, { slug: \"hello-world\" }];\n}\n\nexport default function Page() {\n  return \u003ch1\u003eHello, Blog Post Page!\u003c/h1\u003e;\n}\n```\n\n이런 식으로 슬러그를 동적으로 받아서 각각의 블로그 포스트 페이지를 만들 수 있답니다.\n\n---\n\n📌 여기서 잠깐!  \n`[slug]` 폴더명에서 대괄호(`[]`)는 동적 라우트를 의미해요. 즉, URL 경로에 따라 달라지는 부분을 변수처럼 처리한다는 거죠. 예를 들어 `/blog/my-first-post`나 `/blog/hello-world` 같은 주소가 들어오면 각각에 맞는 슬러그 값을 받아 페이지를 렌더링하는 식이에요.\n\n정리하면, 폴더 구조가 URL 구조와 일치하므로 직관적으로 관리하고, 동적 라우팅 덕분에 다양한 경로를 손쉽게 처리할 수 있어요.\n\n이걸 응용하면 포트폴리오, 쇼핑몰 상품 페이지, 유저 프로필 등 여러 상황에 딱 맞는 동적 페이지를 편하게 만들 수 있겠죠? 😄\n\n---\n\n### 추가 팁: `generateStaticParams` 활용하기\n\n- 이 함수는 빌드 시점에 호출되어, 미리 생성할 정적 경로를 알려줍니다.\n- 블로그 글처럼 내용이 자주 바뀌지 않는 경우 미리 정적으로 빌드해두면 성능이 엄청 좋아져요.\n- 반대로 동적으로 내용을 자주 바꾸는 경우엔 서버 사이드 렌더링이나 ISR(Incremental Static Regeneration) 등의 기법도 고려해보세요!\n\n이상으로 Next.js 앱 라우팅에서 중첩 폴더와 동적 라우트 설정하는 법을 간단히 알아봤어요. 궁금한 점 있으면 언제든 질문 주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n폴더 이름을 대괄호([])로 감싸면 예를 들어 [slug]처럼, 이 부분이 동적 라우트 세그먼트(dynamic route segment)가 돼서 데이터 기반으로 여러 페이지를 쉽게 만들어줄 수 있어요. 블로그 포스트나 상품 페이지처럼 같은 구조지만 내용이 다른 여러 페이지를 만들 때 정말 유용하답니다.\n\n## 레이아웃 중첩(Nesting layouts)\n\n기본적으로 폴더 구조에 따라 레이아웃도 중첩돼요. 즉, 부모 레이아웃이 자식 레이아웃을 children 프로퍼티로 감싸는 형태라는 뜻이죠. 이걸 활용해서 특정 라우트(폴더)마다 레이아웃을 따로 지정할 수 있어요.\n\n예를 들어, `/blog` 경로를 위한 레이아웃을 만들고 싶다면 blog 폴더 안에 layout 파일을 추가하면 됩니다. 이렇게 하면 `/blog`와 그 하위 페이지에만 적용되는 레이아웃을 별도로 관리할 수 있어서 더 체계적이고 유지보수도 쉬워져요.\n\n더 덧붙이자면, 이 방식은 여러 페이지의 공통 UI(예: 네비게이션 바, 푸터 등)를 재사용할 때 아주 효과적이에요. 레이아웃을 잘 설계해 놓으면 페이지 개발 속도가 확실히 빨라지고, UI 일관성도 자연스럽게 유지할 수 있답니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n앱을 만들 때 레이아웃을 중첩해서 사용하는 경우가 많아요. 위 코드에서는 `BlogLayout`이라는 컴포넌트를 정의했는데요, 이 컴포넌트가 `children`을 받아서 `\u003csection\u003e` 태그로 감싸고 있죠. 이건 블로그 관련 페이지만 따로 꾸밀 때 유용해요.\n\n예를 들어, 루트 레이아웃인 `app/layout.js`가 전체 앱을 감싸고, 그 안에 `app/blog/layout.js`(즉, 위에서 정의한 `BlogLayout`)가 블로그 관련 페이지를 감싸는 구조라고 생각하면 됩니다. 그리고 실제 블로그 메인 페이지(`app/blog/page.js`)와 개별 포스트 페이지(`app/blog/[slug]/page.js`)가 그 안에 들어가는 식이죠.\n\n이렇게 하면 기본 레이아웃은 유지하면서도, 특정 섹션(여기서는 블로그)만 별도로 스타일이나 구성을 다르게 할 수 있어서 훨씬 관리하기 편해집니다.\n\n---\n\n## 페이지 간 링크 연결하기\n\n페이지들을 만들었으면 이제 서로 연결해줘야겠죠? Next.js에서는 `\u003cLink\u003e` 컴포넌트를 사용해서 페이지 간 이동을 쉽게 할 수 있어요. 예를 들어 블로그 리스트에서 각각의 포스트 페이지로 이동하고 싶을 때 이렇게 할 수 있습니다:\n\n```jsx\nimport Link from \"next/link\";\n\nexport default function BlogList({ posts }) {\n  return (\n    \u003cul\u003e\n      {posts.map((post) =\u003e (\n        \u003cli key={post.slug}\u003e\n          \u003cLink href={`/blog/${post.slug}`}\u003e{post.title}\u003c/Link\u003e\n        \u003c/li\u003e\n      ))}\n    \u003c/ul\u003e\n  );\n}\n```\n\n위 예제는 간단한 블로그 리스트 컴포넌트인데요, `posts` 배열을 받아서 각 포스트 제목에 맞게 링크를 걸어줍니다. 이렇게 하면 Next.js가 자동으로 사전 렌더링과 클라이언트 측 네비게이션을 최적화해줘서 사용자 경험이 훨씬 좋아져요.\n\n---\n\n### 팁!\n\n- 중첩 레이아웃을 쓸 때는 각 레이아웃 파일 이름과 위치가 중요해요. 예를 들어 `app/blog/layout.js`는 `/blog` 경로 하위 모든 페이지에 자동으로 적용됩니다.\n- 레이아웃 안에 헤더나 푸터를 넣어서 반복되는 UI를 한 번만 작성해도 효율적입니다.\n- 링크를 걸 때는 가능한 `next/link`를 써주세요. `\u003ca\u003e` 태그만 쓰면 페이지 전환 시 전체가 새로고침돼서 느릴 수 있어요.\n\n이제 여러분도 레이아웃을 중첩해서 더 구조화된 Next.js 앱을 쉽게 만들 수 있어요! 혹시 더 궁금한 점 있으면 언제든 질문해 주세요~\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 페이지 간 이동을 할 때는 `Link` 컴포넌트를 사용하면 아주 편리해요. `Link`는 HTML의 기본 `a` 태그를 확장한 컴포넌트로, 미리 페이지를 불러오는(prefetching) 기능과 클라이언트 사이드 네비게이션을 지원해줘서 사용자 경험을 훨씬 부드럽게 만들어줍니다.\n\n예를 들어, 블로그 글 목록을 만들고 싶다면, `next/link`에서 `Link`를 임포트(import)한 다음, 각 글의 경로를 `href` 속성에 넘겨주면 돼요.\n\n```js\nimport Link from \"next/link\";\n\nexport default async function PostList() {\n  const posts = await getPosts();\n\n  return (\n    \u003cul\u003e\n      {posts.map((post) =\u003e (\n        \u003cli key={post.slug}\u003e\n          \u003cLink href={`/posts/${post.slug}`}\u003e{post.title}\u003c/Link\u003e\n        \u003c/li\u003e\n      ))}\n    \u003c/ul\u003e\n  );\n}\n```\n\n여기서 주목할 점은, `Link` 컴포넌트는 내부적으로 HTML의 `\u003ca\u003e` 태그를 사용하지만, Next.js가 최적화해주는 사전 로딩과 클라이언트 사이드 라우팅 기능을 추가로 제공한다는 것이에요.\n\n\u003e 참고로, Next.js의 공식 문서에서는 페이지 이동 시 `Link`를 쓰는 것을 권장합니다. 하지만 더 세밀한 라우팅 제어가 필요할 때는 `useRouter` 훅을 사용해 프로그래밍 방식으로 라우팅할 수도 있어요.\n\n더불어 `Link` 내부에 `\u003ca\u003e` 태그를 직접 감싸는 예전 방식도 있었는데, Next.js 13버전부터는 `href`를 바로 `Link`에 넘겨주고 텍스트나 요소를 자식으로 넣는 방식이 표준이에요. 혹시 이전 문서를 참고한다면 이 부분 조금 헷갈릴 수 있으니 주의하세요!\n\n간단하게 정리하면:\n\n| 특징                         | 설명                                                   |\n| ---------------------------- | ------------------------------------------------------ |\n| Link 컴포넌트                | HTML `\u003ca\u003e` 태그에 라우팅 기능이 추가된 컴포넌트        |\n| prefetching                  | 화면에 보이기 전에 미리 페이지를 불러와 빠른 이동 지원 |\n| 클라이언트 사이드 네비게이션 | 전체 페이지 새로고침 없이 부드럽게 라우팅              |\n| useRouter 훅 사용            | 프로그래밍 방식으로 라우팅을 제어할 때 활용 가능       |\n\n이처럼 Next.js에서는 기본적으로 `Link`를 활용해 사용자에게 자연스러운 페이지 전환 경험을 제공하는 게 가장 깔끔한 방법입니다!\n","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":11},{"title":"Next.js 15 프로젝트 폴더 설계 방법","description":"","date":"2025-04-22 00:55","slug":"2025-04-22-Projectstructureandorganization","content":"\n# 프로젝트 구조와 조직 방법\n\n이번 글에서는 Next.js에서 사용하는 폴더와 파일 규칙에 대해 한눈에 정리해 드리고, 프로젝트를 어떻게 잘 구성할지에 대한 팁도 함께 알려드릴게요.\n\n## 폴더와 파일 규칙\n\n### 최상위 폴더\n\n최상위 폴더는 애플리케이션 코드와 정적 자산(이미지, 폰트 등)을 구분해서 관리할 때 사용해요.\n\n![프로젝트 구조 이미지](/TIL/assets/img/2025-04-22-Projectstructureandorganization_0.png)\n\n| 폴더 이름                                                                                  | 설명                                                 |\n| ------------------------------------------------------------------------------------------ | ---------------------------------------------------- |\n| [`app`](https://nextjs.org/docs/app/building-your-application/routing)                     | App Router (Next.js의 새로운 라우팅 방식)            |\n| [`pages`](https://nextjs.org/docs/pages/building-your-application/routing)                 | Pages Router (기존 라우팅 방식)                      |\n| [`public`](https://nextjs.org/docs/app/building-your-application/optimizing/static-assets) | 외부에 서비스할 정적 자산 모음                       |\n| [`src`](https://nextjs.org/docs/app/building-your-application/configuring/src-directory)   | 옵션! 소스코드를 별도 관리하고 싶을 때 사용하는 폴더 |\n\n### 최상위 파일\n\n(여기서부터 다음 내용이 이어집니다.)\n\n---\n\n폴더 구조를 깔끔하게 정리하면 프로젝트 유지보수가 훨씬 수월해져요. 너무 복잡하게 만들지 말고, 자신의 프로젝트에 맞게 심플하게 가져가는 게 가장 좋아요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 최상위(Top-level) 파일들은 여러분의 애플리케이션을 설정하고, 의존성을 관리하며, 미들웨어를 실행하고, 모니터링 도구를 통합하고, 환경 변수를 정의하는 데 사용돼요. 그러니까 프로젝트의 중요한 설정들이 여기서 모여있다고 보면 됩니다.\n\n다음은 각 파일들이 어떤 역할을 하는지 간단히 정리한 표에요:\n\n| 파일명                                                                                                        | 설명                            |\n| ------------------------------------------------------------------------------------------------------------- | ------------------------------- |\n| [`next.config.js`](https://nextjs.org/docs/app/api-reference/config/next-config-js)                           | Next.js 설정 파일               |\n| [`package.json`](https://nextjs.org/docs/app/getting-started/installation#manual-installation)                | 프로젝트 의존성과 스크립트 관리 |\n| [`instrumentation.ts`](https://nextjs.org/docs/app/building-your-application/optimizing/instrumentation)      | OpenTelemetry 및 계측 관련 파일 |\n| [`middleware.ts`](https://nextjs.org/docs/app/building-your-application/routing/middleware)                   | Next.js 요청 미들웨어 파일      |\n| [`.env`](https://nextjs.org/docs/app/building-your-application/configuring/environment-variables)             | 환경 변수 설정 파일             |\n| [`.env.local`](https://nextjs.org/docs/app/building-your-application/configuring/environment-variables)       | 로컬 환경 변수 설정             |\n| [`.env.production`](https://nextjs.org/docs/app/building-your-application/configuring/environment-variables)  | 프로덕션 환경 변수 설정         |\n| [`.env.development`](https://nextjs.org/docs/app/building-your-application/configuring/environment-variables) | 개발 환경 변수 설정             |\n| [`.eslintrc.json`](https://nextjs.org/docs/app/api-reference/config/eslint)                                   | ESLint 설정 파일                |\n| `.gitignore`                                                                                                  | Git에서 무시할 파일/폴더 목록   |\n| `next-env.d.ts`                                                                                               | Next.js용 TypeScript 선언 파일  |\n| `tsconfig.json`                                                                                               | TypeScript 설정 파일            |\n| `jsconfig.json`                                                                                               | JavaScript 설정 파일            |\n\n---\n\n### 라우팅 관련 파일\n\nNext.js에서 앱 라우팅을 구성하는 데 사용되는 파일들을 모아봤어요:\n\n| 파일명                                                                                          | 확장자            | 설명                          |\n| ----------------------------------------------------------------------------------------------- | ----------------- | ----------------------------- |\n| [`layout`](https://nextjs.org/docs/app/api-reference/file-conventions/layout)                   | .js / .jsx / .tsx | 레이아웃 컴포넌트             |\n| [`page`](https://nextjs.org/docs/app/api-reference/file-conventions/page)                       | .js / .jsx / .tsx | 페이지 컴포넌트               |\n| [`loading`](https://nextjs.org/docs/app/api-reference/file-conventions/loading)                 | .js / .jsx / .tsx | 로딩중 UI 컴포넌트            |\n| [`not-found`](https://nextjs.org/docs/app/api-reference/file-conventions/not-found)             | .js / .jsx / .tsx | 404 페이지 UI                 |\n| [`error`](https://nextjs.org/docs/app/api-reference/file-conventions/error)                     | .js / .jsx / .tsx | 에러 UI                       |\n| [`global-error`](https://nextjs.org/docs/app/api-reference/file-conventions/error#global-error) | .js / .jsx / .tsx | 글로벌 에러 UI                |\n| [`route`](https://nextjs.org/docs/app/api-reference/file-conventions/route)                     | .js / .ts         | API 엔드포인트                |\n| [`template`](https://nextjs.org/docs/app/api-reference/file-conventions/template)               | .js / .jsx / .tsx | 다시 렌더링되는 레이아웃      |\n| [`default`](https://nextjs.org/docs/app/api-reference/file-conventions/default)                 | .js / .jsx / .tsx | 병렬 라우트용 fallback 페이지 |\n\n---\n\n### 중첩 라우트 (Nested routes)\n\nNext.js에서는 폴더 구조를 통해 중첩된 라우트를 쉽게 표현할 수 있어요.\n\n| 폴더 구조       | 설명                   |\n| --------------- | ---------------------- |\n| `folder`        | 하나의 라우트 세그먼트 |\n| `folder/folder` | 중첩된 라우트 세그먼트 |\n\n---\n\n### 동적 라우트 (Dynamic routes)\n\n동적 라우팅은 경로에 가변 요소가 포함될 때 사용돼요.\n\n| 경로 표현법                                                                                                                 | 설명                                         |\n| --------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------- |\n| [`[folder]`](https://nextjs.org/docs/app/building-your-application/routing/dynamic-routes#convention)                       | 동적 라우트 세그먼트                         |\n| [`[...folder]`](https://nextjs.org/docs/app/building-your-application/routing/dynamic-routes#catch-all-segments)            | 모든 하위 경로를 잡아내는 catch-all 세그먼트 |\n| [`[[...folder]]`](https://nextjs.org/docs/app/building-your-application/routing/dynamic-routes#optional-catch-all-segments) | 선택적인 catch-all 세그먼트                  |\n\n---\n\n블로그를 보시는 여러분도 Next.js를 쓸 때 이 파일들과 폴더 구조들을 잘 알고 나면, 프로젝트를 더 효율적이고 이해하기 쉽게 관리할 수 있습니다! 필요할 때마다 이 표를 참고하세요~\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### Route Groups와 private 폴더\n\n| 구분       | 설명                                             |\n| ---------- | ------------------------------------------------ |\n| `(folder)` | 라우팅에 영향을 주지 않고 라우트를 그룹화        |\n| `_folder`  | 해당 폴더와 모든 하위 세그먼트를 라우팅에서 제외 |\n\n### 병렬(Parallel) 및 인터셉트(Intercepted) 라우트\n\n| 구분             | 설명                            |\n| ---------------- | ------------------------------- |\n| `@folder`        | 네임드 슬롯(named slot)         |\n| `(.)folder`      | 같은 레벨을 인터셉트(intercept) |\n| `(..)folder`     | 한 단계 위 레벨을 인터셉트      |\n| `(..)(..)folder` | 두 단계 위 레벨을 인터셉트      |\n| `(...)folder`    | 루트에서부터 인터셉트           |\n\n### 메타데이터 파일 규칙\n\n#### 앱 아이콘(App icons)\n\n| 이름         | 확장자                                  | 설명                         |\n| ------------ | --------------------------------------- | ---------------------------- |\n| `favicon`    | `.ico`                                  | 파비콘(favicon) 파일         |\n| `icon`       | `.ico`, `.jpg`, `.jpeg`, `.png`, `.svg` | 앱 아이콘 파일               |\n| `icon`       | `.js`, `.ts`, `.tsx`                    | 코드로 생성된 앱 아이콘      |\n| `apple-icon` | `.jpg`, `.jpeg`, `.png`                 | 애플 앱 아이콘 파일          |\n| `apple-icon` | `.js`, `.ts`, `.tsx`                    | 코드로 생성된 애플 앱 아이콘 |\n\n---\n\n조금 어렵게 느껴질 수 있는 routing 영역에서 폴더명을 활용하는 여러 가지 문법과 파일명 규칙을 정리해봤어요.  \n특히 (folder) 같이 라우팅에는 영향을 주지 않으면서 내부 조직화용으로 많이 쓰이고요, `_folder`는 아예 routing 대상에서 제외하는 용도로 쓴답니다.  \nParallel과 Intercept 라우트는 고급 기능인데, 슬래시 하나, 두 개 등에 따라 라우팅 경로를 제어할 수 있어서 원하는 맞춤 페이지 구성에 도움을 줘요.  \n마지막으로 메타데이터 쪽은 favicon이나 app icon 관련 파일명과 확장자를 정해놓은 내용이니 프로젝트 셋업할 때 참고하면 좋습니다!\n\n필요하시면 더 자세한 설명도 알려드릴게요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 Open Graph 이미지, Twitter 이미지, 그리고 SEO 관련 파일 종류와 확장자, 그리고 용도에 대한 표입니다. Markdown 형식으로 정리해 봤어요!\n\n### Open Graph \u0026 Twitter 이미지 파일\n\n| 이름                                                                                                                                        | 확장자                          | 설명                              |\n| ------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------- | --------------------------------- |\n| [opengraph-image](https://nextjs.org/docs/app/api-reference/file-conventions/metadata/opengraph-image#opengraph-image)                      | `.jpg`, `.jpeg`, `.png`, `.gif` | Open Graph 이미지 파일            |\n| [opengraph-image](https://nextjs.org/docs/app/api-reference/file-conventions/metadata/opengraph-image#generate-images-using-code-js-ts-tsx) | `.js`, `.ts`, `.tsx`            | 코드로 생성하는 Open Graph 이미지 |\n| [twitter-image](https://nextjs.org/docs/app/api-reference/file-conventions/metadata/opengraph-image#twitter-image)                          | `.jpg`, `.jpeg`, `.png`, `.gif` | Twitter에 보여줄 이미지 파일      |\n| [twitter-image](https://nextjs.org/docs/app/api-reference/file-conventions/metadata/opengraph-image#generate-images-using-code-js-ts-tsx)   | `.js`, `.ts`, `.tsx`            | 코드로 생성하는 Twitter 이미지    |\n\n### SEO 관련 파일\n\n| 이름                                                                                                                         | 확장자       | 설명                        |\n| ---------------------------------------------------------------------------------------------------------------------------- | ------------ | --------------------------- |\n| [sitemap](https://nextjs.org/docs/app/api-reference/file-conventions/metadata/sitemap#sitemap-files-xml)                     | `.xml`       | 사이트맵 파일               |\n| [sitemap](https://nextjs.org/docs/app/api-reference/file-conventions/metadata/sitemap#generating-a-sitemap-using-code-js-ts) | `.js`, `.ts` | 코드로 생성하는 사이트맵    |\n| [robots](https://nextjs.org/docs/app/api-reference/file-conventions/metadata/robots#static-robotstxt)                        | `.txt`       | robots.txt 파일             |\n| [robots](https://nextjs.org/docs/app/api-reference/file-conventions/metadata/robots#generate-a-robots-file)                  | `.js`, `.ts` | 코드로 생성하는 robots 파일 |\n\n---\n\n## 프로젝트 구성하기\n\nNext.js에서는 프로젝트 파일을 어떻게 배치할지는 자유롭게 선택할 수 있어요. 딱 정해진 규칙이 있는 건 아니지만, 다음과 같은 기능들이 있어서 편리하게 구성할 수 있답니다.\n\n### 컴포넌트 계층 구조\n\nNext.js 내에서 특별한 이름의 파일들은 아래와 같은 계층 구조를 따라 렌더링됩니다:\n\n- `layout.js` — 페이지 레이아웃 정의\n- `template.js` — 페이지 템플릿\n- `error.js` — React 오류 경계(Error Boundary) 처리\n- `loading.js` — React Suspense 경계로 로딩 UI\n- `not-found.js` — 404 페이지용 에러 경계\n- `page.js` 혹은 nested `layout.js` — 실제 페이지 컴포넌트\n\n이 계층 덕분에 페이지 단위 컴포넌트가 어떻게 조합되고 재사용되는지 명확하게 구조화할 수 있어요. 이를 활용해서 여러분만의 깔끔한 프로젝트 구조를 만들어 보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여러분, 오늘은 Next.js 앱 디렉토리 구조와 라우트 구성에 대해 알아볼게요. 복잡해 보일 수 있지만, 하나씩 차근차근 이해하면 실제로 프로젝트를 더 효율적으로 관리할 수 있답니다.\n\n---\n\n### 라우트 컴포넌트는 계층적으로 렌더링된다\n\n우리가 만든 컴포넌트들은 중첩된 라우트(nested routes)에서 재귀적으로 렌더링돼요. 쉽게 말해, 특정 라우트의 컴포넌트는 그 부모 라우트 컴포넌트 안에 중첩되는 구조입니다.\n\n예를 들어, `/dashboard/settings` 같은 경로가 있다면 `dashboard` 컴포넌트가 먼저 렌더링되고, 그 안에 `settings` 컴포넌트가 들어가는 식이에요.\n\n---\n\n### 라우트는 폴더 구조로 정의한다 — 콜로케이션(colocation)\n\nNext.js 앱 디렉토리 안에서, **중첩된 폴더가 라우트 구조를 뜻해요**. 폴더 하나가 하나의 라우트 세그먼트(route segment)를 나타내고, 이 세그먼트가 URL 경로의 일부로 매핑됩니다.\n\n하지만 중요한 점! 폴더만 있다고 해서 그 경로가 바로 “공개적으로” 접근 가능한 페이지가 되진 않아요. 그 폴더 안에 `page.js` 혹은 `route.js` 파일이 있어야 비로소 해당 라우트가 활성화되고, 방문할 수 있답니다.\n\n---\n\n### 실제 클라이언트에 전송되는 것은?\n\n라우트가 공개되어 있어도, 클라이언트에 보내지는 건 그 라우트의 `page.js`나 `route.js`에서 반환하는 콘텐츠뿐이에요. 부모 라우트 컴포넌트가 중첩되어 렌더링되더라도, 클라이언트에게는 각 세그먼트의 `page.js` 결과물만 전달되니까 참고하세요!\n\n---\n\n정리하면,\n\n- 라우트 구조는 폴더 중첩으로 표현한다.\n- 해당 폴더에 `page.js`나 `route.js` 파일이 있어야 라우트가 활성화된다.\n- 중첩된 라우트는 부모-자식 구조로 렌더링된다.\n- 클라이언트에는 각 세그먼트 라우트 파일에서 반환한 콘텐츠만 전달된다.\n\n이런 구조 덕분에 프로젝트 내 파일과 라우트가 자연스럽게 연관되니, 관리도 쉽고 개발 속도도 빨라진답니다. 여러분도 프로젝트에 적용해 보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n앱 디렉터리 내에서 라우트 구간(route segments) 안에 프로젝트 파일들을 안전하게 함께 둘 수 있다는 뜻이에요. 이렇게 하면 파일들이 실수로 라우트로 잡히는 일을 방지할 수 있답니다.\n\n---\n\n\u003e 참고할 점: 프로젝트 파일들을 꼭 app 폴더 안에 넣어야 하는 건 아니에요. 원한다면 app 디렉터리 밖에 보관해도 무방합니다.\n\n---\n\n### Private 폴더 만들기\n\n폴더 이름 앞에 언더스코어(\\_)를 붙여서 private 폴더를 만들 수 있어요. 예를 들면 `_folderName` 같은 식이죠.\n\n이렇게 하면 라우팅시스템이 이 폴더와 그 하위 폴더들을 무시하니까, 라우트로 작동하지 않는 구현 세부 사항용 폴더로 쓸 수 있어요.\n\n---\n\n관련 그림 첨부해 뒀으니 한 번 참고해 보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n앱 디렉터리 내 파일은 기본적으로 안전하게 한 곳에 모아둘 수 있어서 private 폴더가 꼭 필요한 건 아니에요. 하지만 private 폴더가 있으면 다음과 같은 점에서 도움이 됩니다:\n\n- UI 로직과 라우팅 로직을 분리할 수 있어요.\n- 프로젝트 내 파일 구성과 Next.js 생태계 전반에서 내부 파일을 일관성 있게 정리할 수 있죠.\n- 코드 에디터에서 파일을 분류하고 그룹화하기 쉬워요.\n- 앞으로 나올 Next.js 파일 네이밍 규칙과 겹칠 수 있는 이름 충돌을 방지할 수 있습니다.\n\n\u003e 참고!\n\u003e 비록 Next.js 공식 프레임워크 규칙은 아니지만, private 폴더 외부에 있는 파일들도 언더스코어(\\_) 패턴을 사용해서 \"private\" 임을 표시하는 방식을 고민해볼 수 있어요.  \n\u003e URL 세그먼트가 언더스코어로 시작해야 한다면 URL 인코딩된 형태인 `%5F`를 앞에 붙이면 됩니다. 예를 들어 `%5FfolderName`처럼요.  \n\u003e 만약 private 폴더를 사용하지 않는다면, 예상치 못한 이름 충돌을 막기 위해 Next.js의 특별한 파일 네이밍 규칙을 잘 숙지하는 게 좋겠죠.\n\n### 라우트 그룹(Route groups)\n\n라우트 그룹은 폴더 이름을 괄호로 감싸서 만듭니다: `(folderName)`\n\n이렇게 하면 이 폴더는 단순히 파일 정리를 위한 용도이고, 실제 라우트 URL 경로에는 포함되지 않아요.\n\n![라우트 그룹 예시 이미지](/TIL/assets/img/2025-04-22-Projectstructureandorganization_7.png)\n\n라우트 그룹이 유용한 점은 다음과 같습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 사이트 섹션, 의도, 혹은 팀 단위로 라우트를 정리하기 (예: 마케팅 페이지, 관리자 페이지 등)\n- 같은 라우트 세그먼트 레벨에서 중첩 레이아웃 활성화하기:\n\n  - 같은 세그먼트 내에 여러 개의 중첩 레이아웃 만들기 (여러 개의 루트 레이아웃 포함)\n  - 공통 세그먼트 내 일부 라우트에만 레이아웃 추가하기\n\n- 같은 세그먼트 내에 여러 개의 중첩 레이아웃 만들기 (여러 개의 루트 레이아웃 포함)\n- 공통 세그먼트 내 일부 라우트에만 레이아웃 추가하기\n\n---\n\n### src 디렉토리\n\nNext.js는 app을 포함한 애플리케이션 코드를 선택적으로 `src` 디렉토리 안에 저장하는 것을 지원합니다. 이렇게 하면 프로젝트 루트에 주로 위치하는 설정 파일과 애플리케이션 코드를 깔끔하게 분리할 수 있습니다.\n\n![Project Structure](/TIL/assets/img/2025-04-22-Projectstructureandorganization_8.png)\n\n---\n\n### 예제\n\n아래 섹션은 흔히 사용하는 전략들을 아주 간략히 정리한 내용입니다. 가장 중요한 점은 여러분과 팀에게 맞는 방식을 선택하고, 프로젝트 전반에 걸쳐 일관성 있게 유지하는 것입니다.\n\n\u003e 참고: 아래 예시에서는 `components`와 `lib` 폴더를 일반적인 예시 폴더명으로 사용했으며, 이들의 이름은 프레임워크에서 특별한 의미를 가진 것은 아닙니다. 프로젝트에 따라 `ui`, `utils`, `hooks`, `styles` 등 다양한 이름을 사용해도 무방합니다.\n\n---\n\n#### app 폴더 밖에 프로젝트 파일 저장하기\n\n| 전략 구분               | 설명                                                               |\n| ----------------------- | ------------------------------------------------------------------ |\n| app 폴더 분리           | app 폴더와는 별개로 components, lib 같은 폴더를 루트 혹은 src에 둠 |\n| 역할별 폴더 구성        | 컴포넌트, 유틸리티, 훅 등을 역할에 맞춰 분리함                     |\n| 팀/기능별으로 폴더 분리 | 팀 혹은 기능 단위로 폴더를 나눠 관리함                             |\n\n---\n\n위와 같은 방법으로 프로젝트를 체계적으로 구성하면 협업 효율이 올라가고 유지보수가 쉬워집니다. 꼭 정답은 없으니 팀 상황에 맞게 유연하게 적용해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 전략은 애플리케이션 코드를 프로젝트 루트의 공유 폴더에 모두 저장하고, app 디렉터리는 오로지 라우팅 용도로만 사용하는 방식이에요.\n\n![프로젝트 구조 1](/TIL/assets/img/2025-04-22-Projectstructureandorganization_9.png)\n\n#### app 내부의 최상위 폴더에 프로젝트 파일 저장하기\n\n이 전략은 애플리케이션 코드를 app 디렉터리 루트에 공유 폴더 형태로 모두 저장하는 방식이에요.\n\n![프로젝트 구조 2](/TIL/assets/img/2025-04-22-Projectstructureandorganization_10.png)\n\n#### 기능이나 라우트별로 프로젝트 파일 분리하기\n\n이 전략은 전역에서 공유되는 애플리케이션 코드는 app 디렉터리 루트에 두고, 좀 더 특정한 애플리케이션 코드는 해당 라우트 세그먼트(경로 단위) 안에 나눠서 저장하는 방식이에요.\n\n![프로젝트 구조 3](/TIL/assets/img/2025-04-22-Projectstructureandorganization_11.png)\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### URL 경로에 영향 없이 라우트 정리하기\n\nURL 경로를 변경하지 않고 라우트를 깔끔하게 정리하고 싶다면, 관련된 라우트들을 그룹으로 묶으면 좋아요. 이때, 괄호로 묶은 폴더 이름(예: `(marketing)`, `(shop)`)은 URL에서 제외됩니다.\n\n예를 들어, 아래 구조에서 `(marketing)`과 `(shop)`은 URL에 나타나지 않고, 폴더 내의 라우트들이 그대로 URL에 반영돼요.\n\n![route 그룹 예시](/TIL/assets/img/2025-04-22-Projectstructureandorganization_12.png)\n\n또한 `(marketing)`과 `(shop)` 폴더 안에 `layout.js` 파일을 추가하면, 각각의 그룹마다 개별 레이아웃을 적용할 수 있습니다. 즉, URL 경로는 같아도 레이아웃은 다르게 설정 가능하다는 거죠.\n\n![개별 레이아웃 적용 예시](/TIL/assets/img/2025-04-22-Projectstructureandorganization_13.png)\n\n### 특정 세그먼트만 레이아웃에 포함시키기\n\n특정 라우트만 하나의 레이아웃으로 묶고 싶다면, 해당 라우트들만 새로운 그룹(예: `(shop)`)으로 묶으면 됩니다. 그룹에 포함된 라우트들은 그룹 레이아웃을 공유하고, 밖에 있는 라우트는 영향을 받지 않아요.\n\n예를 들어, `account`와 `cart`는 `(shop)` 그룹에 넣어 레이아웃을 공유하고, `checkout`은 그룹 밖에 둬서 별도의 레이아웃을 유지할 수 있습니다.\n\n![특정 그룹에만 레이아웃 적용 예시](/TIL/assets/img/2025-04-22-Projectstructureandorganization_14.png)\n\n이런 방법을 사용하면 프로젝트 구조를 깔끔하게 유지하면서도 URL 디자인에는 전혀 영향 주지 않을 수 있어서 정말 유용합니다!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 특정 경로에 로딩 스켈레톤 적용하기\n\n특정 라우트에만 로딩 스켈레톤을 적용하고 싶다면, 새로운 라우트 그룹 (예: /(overview))을 만들고 그 안에 loading.tsx 파일을 넣으면 됩니다.\n\n\u003cimg src=\"/TIL/assets/img/2025-04-22-Projectstructureandorganization_15.png\" /\u003e\n\n이렇게 하면 loading.tsx 파일은 대시보드 내의 overview 페이지에만 적용되고, 다른 대시보드 페이지에는 영향을 주지 않으면서 URL 경로 구조도 유지할 수 있어요.\n\n---\n\n### 여러 개의 루트 레이아웃 만들기\n\n여러 루트 레이아웃을 만들고 싶으면 최상위에 있던 layout.js 파일을 제거한 다음, 각 라우트 그룹 내부에 layout.js 파일을 각각 만들어 주면 됩니다. 이렇게 하면 완전히 다른 UI나 경험이 필요한 섹션을 애플리케이션 내에 구분하기 매우 편리해요. 이때 각 루트 레이아웃에는 `html`과 `body` 태그가 반드시 포함되어야 합니다.\n\n\u003cimg src=\"/TIL/assets/img/2025-04-22-Projectstructureandorganization_16.png\" /\u003e\n\n위 예시처럼, (marketing)과 (shop)은 각각 자신만의 루트 레이아웃을 가지고 있게 됩니다.\n","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":20},{"title":"Next.js 14 2025년 최신 프로젝트 세팅 방법","description":"","date":"2025-04-22 00:32","slug":"2025-04-22-HowtosetupanewNextjsproject","content":"\n# 새로운 Next.js 프로젝트 설정 방법\n\n## 시스템 요구 사항\n\n시작하기 전에, 시스템이 다음 요구 사항을 충족하는지 확인하세요:\n\n| 요구 사항 | 설명                                 |\n| --------- | ------------------------------------ |\n| Node.js   | 18.18 버전 이상                      |\n| 운영 체제 | macOS, Windows(WSL 포함), 또는 Linux |\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 자동 설치\n\n새로운 Next.js 앱을 가장 빠르게 만드는 방법은 create-next-app을 사용하는 것입니다. 이 도구가 모든 설정을 자동으로 해줍니다. 프로젝트를 생성하려면 다음 명령어를 실행하세요:\n\n```js\nnpx create-next-app@latest\n```\n\n설치 중에 다음과 같은 프롬프트가 나타납니다:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n| 질문                                                             | 선택지   |\n| ---------------------------------------------------------------- | -------- |\n| What is your project named?                                      | my-app   |\n| Would you like to use TypeScript?                                | No / Yes |\n| Would you like to use ESLint?                                    | No / Yes |\n| Would you like to use Tailwind CSS?                              | No / Yes |\n| Would you like your code inside a `src/` directory?              | No / Yes |\n| Would you like to use App Router? (recommended)                  | No / Yes |\n| Would you like to use Turbopack for `next dev`?                  | No / Yes |\n| Would you like to customize the import alias (`@/*` by default)? | No / Yes |\n| What import alias would you like configured?                     | @/\\*     |\n\n프로젝트 생성 후, create-next-app이 프로젝트 이름으로 된 폴더를 만들고 필요한 의존성들을 설치해 줍니다.\n\n## 수동 설치\n\nNext.js 앱을 수동으로 새로 만들고 싶다면, 필요한 패키지를 설치하세요:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n| 스크립트명 | 설명                                      |\n| ---------- | ----------------------------------------- |\n| dev        | 개발 서버를 실행합니다.                   |\n| build      | 프로덕션용으로 애플리케이션을 빌드합니다. |\n| start      | 빌드된 애플리케이션을 실행합니다.         |\n| lint       | 코드 린팅을 실행합니다.                   |\n\n위 명령어들은 애플리케이션 개발의 각 단계를 위한 스크립트들이에요. `npm install`로 최신 버전의 Next.js와 React를 설치한 뒤, `package.json`에 이 스크립트들을 추가하면 다양한 개발 작업을 쉽게 실행할 수 있답니다!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- next dev: 개발 서버를 시작합니다.\n- next build: 애플리케이션을 프로덕션용으로 빌드합니다.\n- next start: 프로덕션 서버를 시작합니다.\n- next lint: ESLint를 실행합니다.\n\n### 앱 디렉토리 만들기\n\nNext.js는 파일 시스템 라우팅을 사용해, 애플리케이션의 라우트가 파일 구조에 따라 결정됩니다.\n\n`app` 폴더를 만드세요. 그리고 `app` 폴더 안에 `layout.tsx` 파일을 만드세요. 이 파일이 루트 레이아웃이고 꼭 필요하며, `html`과 `body` 태그를 포함해야 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nexport default function RootLayout({ children }: { children: React.ReactNode }) {\n  return (\n    \u003chtml lang=\"en\"\u003e\n      \u003cbody\u003e{children}\u003c/body\u003e\n    \u003c/html\u003e\n  );\n}\n```\n\n홈 페이지 app/page.tsx를 다음과 같이 초기 콘텐츠와 함께 만들어 주세요:\n\n```js\nexport default function Page() {\n  return \u003ch1\u003eHello, Next.js!\u003c/h1\u003e;\n}\n```\n\n사용자가 애플리케이션의 루트 경로 (/)를 방문하면 layout.tsx와 page.tsx 두 파일이 모두 렌더링됩니다.\n\n| 파일명     | 역할                                       |\n| ---------- | ------------------------------------------ |\n| layout.tsx | HTML 구조와 공통 레이아웃 정의             |\n| page.tsx   | 루트 경로에 표시할 초기 페이지 콘텐츠 제공 |\n\n친절하게 궁금한 점 있으면 언제든지 물어보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2025-04-22-HowtosetupanewNextjsproject_0.png\" /\u003e\n\n\u003e 알아두면 좋은 점:\n\u003e 루트 레이아웃(root layout) 파일을 만들지 않아도, next dev 명령어로 개발 서버를 실행할 때 Next.js가 자동으로 이 파일을 생성해 줍니다.  \n\u003e 프로젝트 루트에 src 디렉터리를 만들어 애플리케이션 코드를 구성 파일과 분리해서 관리할 수도 있습니다.\n\n### public 폴더 생성하기 (선택 사항)\n\n프로젝트 루트에 public 폴더를 만들어 이미지, 폰트 등 정적 자산을 저장해 보세요.  \npublic 폴더 안에 있는 파일들은 기본 URL(/)부터 참조할 수 있습니다.\n\n| 폴더명 | 설명                                       |\n| ------ | ------------------------------------------ |\n| public | 정적 자산(이미지, 폰트 등)을 저장하는 폴더 |\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자산은 루트 경로(/)를 사용해 참조할 수 있습니다. 예를 들어, public/profile.png 파일은 /profile.png로 참조할 수 있습니다:\n\n```js\nimport Image from \"next/image\";\n\nexport default function Page() {\n  // 여기에 컴포넌트 내용을 작성하세요\n}\n```\n\n## 개발 서버 실행하기\n\n- npm run dev 명령어로 개발 서버를 시작하세요.\n- http://localhost:3000 에 접속해 애플리케이션을 확인하세요.\n- app/page.tsx 파일을 수정하고 저장하면 브라우저에서 변경된 결과를 즉시 볼 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## TypeScript 설정하기\n\n\u003e 최소 TypeScript 버전: v4.5.2\n\nNext.js는 TypeScript를 기본적으로 지원합니다. 프로젝트에 TypeScript를 추가하려면 파일 이름을 `.ts` 또는 `.tsx`로 변경하고 `next dev`를 실행하세요. 그러면 Next.js가 필요한 종속성을 자동으로 설치하고, 권장 설정이 포함된 `tsconfig.json` 파일을 추가합니다.\n\n### IDE 플러그인\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js는 VSCode와 다른 코드 편집기에서 고급 타입 검사와 자동 완성을 사용할 수 있도록 맞춤형 TypeScript 플러그인과 타입 체크 기능을 포함하고 있어요.\n\nVS Code에서 플러그인을 활성화하려면 다음 단계를 따라 주세요:\n\n- 명령 팔레트 열기 (Ctrl/⌘ + Shift + P)\n- \"TypeScript: Select TypeScript Version\" 검색하기\n- \"Use Workspace Version\" 선택하기\n\n| 단계 | 설명                                         |\n| ---- | -------------------------------------------- |\n| 1    | 명령 팔레트 열기 (Ctrl/⌘ + Shift + P)        |\n| 2    | \"TypeScript: Select TypeScript Version\" 검색 |\n| 3    | \"Use Workspace Version\" 선택                 |\n\n\u003cimg src=\"/TIL/assets/img/2025-04-22-HowtosetupanewNextjsproject_1.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nTypeScript 참고 페이지에서 더 많은 정보를 확인할 수 있어요.\n\n## ESLint 설정하기\n\nNext.js는 내장 ESLint를 제공합니다. create-next-app으로 새 프로젝트를 만들면 필요한 패키지를 자동으로 설치하고 적절한 설정을 구성해 줘요.\n\n기존 프로젝트에 ESLint를 수동으로 추가하려면 package.json에 다음과 같이 next lint 스크립트를 추가하면 됩니다:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n{\n  \"scripts\": {\n    \"lint\": \"next lint\"\n  }\n}\n```\n\n그런 다음, `npm run lint` 명령어를 실행하면 설치 및 설정 과정을 안내받을 수 있습니다.\n\n```js\nnpm run lint\n```\n\n다음과 같은 프롬프트가 나타날 거예요:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003e ? ESLint를 어떻게 설정하시겠어요?\n\u003e ❯ 엄격 모드 (권장)\n\u003e 기본 모드\n\u003e 취소\n\n| 옵션      | 설명                                                                                                                                  |\n| --------- | ------------------------------------------------------------------------------------------------------------------------------------- |\n| 엄격 모드 | Next.js의 기본 ESLint 설정에 더 엄격한 Core Web Vitals 규칙 세트가 포함됩니다. ESLint를 처음 설정하는 개발자에게 권장되는 설정입니다. |\n| 기본 모드 | Next.js의 기본 ESLint 설정이 포함됩니다.                                                                                              |\n| 취소      | 설정을 건너뜁니다. 직접 커스텀 ESLint 설정을 할 계획이라면 이 옵션을 선택하세요.                                                      |\n\n엄격 모드나 기본 모드를 선택하면, Next.js가 자동으로 eslint와 eslint-config-next를 애플리케이션의 종속성으로 설치하고, 프로젝트 루트에 선택한 설정이 포함된 `.eslintrc.json` 파일을 생성합니다.\n\n이제 `next lint` 명령어를 실행하여 ESLint로 오류를 점검할 수 있습니다. ESLint 설정이 완료되면, 빌드할 때마다 (`next build`) 자동으로 ESLint가 실행됩니다. 오류가 있을 경우 빌드가 실패하며, 경고는 빌드에 영향을 주지 않습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nESLint 플러그인 페이지에서 더 많은 정보를 확인할 수 있어요.\n\n## 절대 경로 및 모듈 경로 별칭 설정하기\n\nNext.js는 tsconfig.json과 jsconfig.json 파일의 \"paths\"와 \"baseUrl\" 옵션을 기본적으로 지원해요.\n\n이 옵션들을 통해 프로젝트 디렉터리를 절대 경로로 별칭(alias) 설정할 수 있어서, 모듈을 더 쉽고 깔끔하게 임포트할 수 있답니다. 예를 들어:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n| Before                                                    | After                                              |\n| --------------------------------------------------------- | -------------------------------------------------- |\n| js\u003cbr\u003eimport { Button } from '../../../components/button' | js\u003cbr\u003eimport { Button } from '@/components/button' |\n\n절대 경로(import)를 설정하려면 tsconfig.json 또는 jsconfig.json 파일에 baseUrl 설정 옵션을 추가하세요. 예를 들어:\n\n```js\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \"src/\"\n  }\n}\n```\n\nbaseUrl 경로를 설정하는 것 외에도 \"paths\" 옵션을 사용해 모듈 경로에 별칭(alias)을 지정할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예를 들어, 다음 설정은 @/components/*를 components/*에 매핑합니다:\n\n```js\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \"src/\",\n    \"paths\": {\n      \"@/styles/*\": [\"styles/*\"],\n      \"@/components/*\": [\"components/*\"]\n    }\n  }\n}\n```\n\n\"paths\"에 있는 경로들은 모두 baseUrl 위치를 기준으로 한 상대 경로입니다.\n","ogImage":{"url":"/assets/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":12}],"page":"15","totalPageCount":50,"totalPageGroupCount":3,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"15"},"buildId":"X4OrKfmLtU3-3BijwfHe6","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>