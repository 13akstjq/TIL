<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>TIL</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//posts/8" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="TIL" data-gatsby-head="true"/><meta property="og:title" content="TIL" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//posts/8" data-gatsby-head="true"/><meta name="twitter:title" content="TIL" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/7978fe7362f7d4c9.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/7978fe7362f7d4c9.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/873-eb138c3217d71553.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/posts/%5Bpage%5D-de1dc5579188f9be.js" defer=""></script><script src="/TIL/_next/static/o6AmBAY_j9v9JmbaRA39X/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/o6AmBAY_j9v9JmbaRA39X/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="8-bit vs 16-bit 코드 유닛 프론트엔드와 백엔드를 위한 PHP Symfony와 TypeScript NextJS 비교 이야기" href="/TIL/post/2024-07-15-8-bitvs16-bitcodeunitaPHPSymfonyvsTypeScriptNextJStaleforFrontendandBackend"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="8-bit vs 16-bit 코드 유닛 프론트엔드와 백엔드를 위한 PHP Symfony와 TypeScript NextJS 비교 이야기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-15-8-bitvs16-bitcodeunitaPHPSymfonyvsTypeScriptNextJStaleforFrontendandBackend_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="8-bit vs 16-bit 코드 유닛 프론트엔드와 백엔드를 위한 PHP Symfony와 TypeScript NextJS 비교 이야기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">8-bit vs 16-bit 코드 유닛 프론트엔드와 백엔드를 위한 PHP Symfony와 TypeScript NextJS 비교 이야기</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 15, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="2024년 프로덕션 레디 LLM 애플리케이션을 위한 기술 스택" href="/TIL/post/2024-07-15-TechStackForProduction-ReadyLLMApplicationsIn2024"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="2024년 프로덕션 레디 LLM 애플리케이션을 위한 기술 스택" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-15-TechStackForProduction-ReadyLLMApplicationsIn2024_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="2024년 프로덕션 레디 LLM 애플리케이션을 위한 기술 스택" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">2024년 프로덕션 레디 LLM 애플리케이션을 위한 기술 스택</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 15, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="알고 나서 놀란 Itertools Python의 9가지 비밀" href="/TIL/post/2024-07-15-9ThingsINeverKnewAboutItertoolsPythonUntilRecently"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="알고 나서 놀란 Itertools Python의 9가지 비밀" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-15-9ThingsINeverKnewAboutItertoolsPythonUntilRecently_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="알고 나서 놀란 Itertools Python의 9가지 비밀" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">알고 나서 놀란 Itertools Python의 9가지 비밀</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 15, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="모든 개발자가 알아야 할 고급 파이썬 개념 9가지" href="/TIL/post/2024-07-15-9AdvancedPythonConceptsEveryDeveloperShouldUnderstand"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="모든 개발자가 알아야 할 고급 파이썬 개념 9가지" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-15-9AdvancedPythonConceptsEveryDeveloperShouldUnderstand_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="모든 개발자가 알아야 할 고급 파이썬 개념 9가지" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">모든 개발자가 알아야 할 고급 파이썬 개념 9가지</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 15, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="파이썬 개발자를 위한 PHP  5편  반복문 사용하는 방법" href="/TIL/post/2024-07-15-PHPforPythonDevelopersPart5Loops"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="파이썬 개발자를 위한 PHP  5편  반복문 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-15-PHPforPythonDevelopersPart5Loops_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="파이썬 개발자를 위한 PHP  5편  반복문 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">파이썬 개발자를 위한 PHP  5편  반복문 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 15, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="파이썬으로 밀리초를 시간, 분, 초로 변환하는 방법" href="/TIL/post/2024-07-15-ConvertingMillisecondstoHoursMinutesandSecondsinPython"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="파이썬으로 밀리초를 시간, 분, 초로 변환하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-15-ConvertingMillisecondstoHoursMinutesandSecondsinPython_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="파이썬으로 밀리초를 시간, 분, 초로 변환하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">파이썬으로 밀리초를 시간, 분, 초로 변환하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 15, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="파이썬 API를 사용한 주식 순위를 위한 기본적 분석 방법" href="/TIL/post/2024-07-14-FundamentalAnalysisforrankingStockswithPythonAPI"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="파이썬 API를 사용한 주식 순위를 위한 기본적 분석 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-FundamentalAnalysisforrankingStockswithPythonAPI_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="파이썬 API를 사용한 주식 순위를 위한 기본적 분석 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">파이썬 API를 사용한 주식 순위를 위한 기본적 분석 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">19<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="현재 핫한 GitHub 프로젝트 11선" href="/TIL/post/2024-07-14-11TrendingGithubProjects"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="현재 핫한 GitHub 프로젝트 11선" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-11TrendingGithubProjects_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="현재 핫한 GitHub 프로젝트 11선" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">현재 핫한 GitHub 프로젝트 11선</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="퀀트를 위한 블랙-숄즈 모델 완벽 가이드" href="/TIL/post/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="퀀트를 위한 블랙-숄즈 모델 완벽 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="퀀트를 위한 블랙-숄즈 모델 완벽 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">퀀트를 위한 블랙-숄즈 모델 완벽 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">28<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Python, C, Rust로 직접 만들어보는 ReLU 활성화 함수 단계별 가이드" href="/TIL/post/2024-07-14-CreatingaReLUActivationFunctionfromScratchAStep-by-StepGuideinPythonCandRust"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Python, C, Rust로 직접 만들어보는 ReLU 활성화 함수 단계별 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-CreatingaReLUActivationFunctionfromScratchAStep-by-StepGuideinPythonCandRust_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Python, C, Rust로 직접 만들어보는 ReLU 활성화 함수 단계별 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Python, C, Rust로 직접 만들어보는 ReLU 활성화 함수 단계별 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/TIL/posts/1">1</a><a class="link" href="/TIL/posts/2">2</a><a class="link" href="/TIL/posts/3">3</a><a class="link" href="/TIL/posts/4">4</a><a class="link" href="/TIL/posts/5">5</a><a class="link" href="/TIL/posts/6">6</a><a class="link" href="/TIL/posts/7">7</a><a class="link posts_-active__YVJEi" href="/TIL/posts/8">8</a><a class="link" href="/TIL/posts/9">9</a><a class="link" href="/TIL/posts/10">10</a><a class="link" href="/TIL/posts/11">11</a><a class="link" href="/TIL/posts/12">12</a><a class="link" href="/TIL/posts/13">13</a><a class="link" href="/TIL/posts/14">14</a><a class="link" href="/TIL/posts/15">15</a><a class="link" href="/TIL/posts/16">16</a><a class="link" href="/TIL/posts/17">17</a><a class="link" href="/TIL/posts/18">18</a><a class="link" href="/TIL/posts/19">19</a><a class="link" href="/TIL/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"8-bit vs 16-bit 코드 유닛 프론트엔드와 백엔드를 위한 PHP Symfony와 TypeScript NextJS 비교 이야기","description":"","date":"2024-07-15 00:07","slug":"2024-07-15-8-bitvs16-bitcodeunitaPHPSymfonyvsTypeScriptNextJStaleforFrontendandBackend","content":"\n\n\u003cimg src=\"/TIL/assets/img/2024-07-15-8-bitvs16-bitcodeunitaPHPSymfonyvsTypeScriptNextJStaleforFrontendandBackend_0.png\" /\u003e\n\n만약 국제화 및 번역이 필요한 제품에 작업했다면, 멀티바이트 문자열로 인한 문제에 직면한 적이 있을 것입니다.\n\n게다가, 웹 개발자로 일하고 있다면 PHP 및 JavaScript (또는 TypeScript)에서 멀티바이트 문자열을 어떻게 확인할지 궁금해했을 것입니다.\n\n저는 현재 유럽에 본사를 두고 아시아에 다른 사무실을 둔 회사에서 일하고 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n동아시아 지역에서 많은 사용자가 브라우징하고 있어서, 저희 시스템이 I18N 요구 사항을 충족할 준비가 되어 있는지 확인해야 했습니다.\n\n우리는 먼저 PHP와 Symfony로 모놀리식 프로젝트를 개발했습니다. 그런 다음, 일부 작은 유틸리티를 사용하여 특정 작업을 처리하기 위해 JavaScript로 작성되었고 NodeJS로 구동되는 마이크로 서비스 기반 프로젝트로 전환했습니다.\n\n지금은 동일한 프로젝트를 PHP와 Symfony를 사용하여 Backend API로 다시 만들고 있습니다. Frontend에서는 NextJS를 사용하여 PHP API 및 NextJS API로 HTTP 호출을 처리하며, Symfony, TypeScript 및 Golang 마이크로 서비스를 사용하고 있습니다.\n\n다시 말해, 우리는 각 프로그래밍 언어의 가장 좋은 부분을 활용하고 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다양한 프로그래밍 언어를 사용하면서 주목한 재미난 점 중 하나는 국제화(Internationalisation)가 다르게 처리된다는 것이에요.\n\n저는 PHP와 TypeScript 두 가지 가장 주요한 프로그래밍 언어를 현재 사용하고 있기 때문에, 여러 바이트 문자열을 다룰 때 주요한 차이점을 강조하고 싶어요.\n\nSymfony를 사용하면서, 제가 제출된 데이터의 백엔드 유효성 검사를 수행하기 위해 사용자 정의 Constraints를 만들었어요. 이 Constraints 중 하나는 주어진 문자열이 싱글 바이트(다중 바이트가 아닌)임을 보장하는 것인데, 특정 결제 공급업체 요구 사항 때문에 데이터를 \"다루기 쉬운\" 형식으로 필요하기 때문이에요.\n\n아래는 PHP Symfony에서 백엔드 유효성 검사를 하는 예시 코드입니다.\n\n```js\n// PHP Symfony Backend\n\n// src/Validator/IsSingleByteStringValidator.php\n\npublic function validate($value, Constraint $constraint): void\n{\n    // ...\n\n    $singleByteLength = strlen($value);\n    $multiByteLength = mb_strlen($value);\n\n    if ($singleByteLength !== $multiByteLength) {\n        $this-\u003econtext-\u003ebuildViolation($constraint-\u003emessage)\n            -\u003esetParameter('{ string }', $value)\n            -\u003eaddViolation();\n    }\n}\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이전 유효성 검사를 실행하는 제약 조건을 사용하여 요청 프로세스에서 데이터를 유효성 검사했습니다. 이 모든 것이 #[MapRequestPayload] 속성을 통해 간단히 이루어졌어요.\n\n하지만 JavaScript에 대한 유사한 접근 방식이 없다는 것을 알게 되었고, TypeScript 코드에서 비슷한 방식을 어떻게 달성할 수 있는지 궁금해졌습니다. 내가 발견한 것은 예상보다 더 복잡하면서 더 흥미로운 것이었어요.\n\n또한 PHP와 JavaScript/TypeScript에는 동기적 및 비동기적 접근 방식 외에도 (개발 단계에 직접적으로 영향을 미치는 가장 관련성 있는 포인트 중 하나인) 문자열 처리 시 \"코드 단위\"에 대한 다른 차이점이 있다는 것을 배웠습니다.\n\n```js\n// 예시:\n\n$str1 = \"a\";\n$str2 = \"円\";\n$str3 = \"𠮷\";\n\nvar_dump([\n    $str1 =\u003e ['strlen' =\u003e strlen($str1), 'mb_strlen' =\u003e mb_strlen($str1)],\n    $str2 =\u003e ['strlen' =\u003e strlen($str2), 'mb_strlen' =\u003e mb_strlen($str2)],\n    $str3 =\u003e ['strlen' =\u003e strlen($str3), 'mb_strlen' =\u003e mb_strlen($str3)],\n]);\n\n// 이전 코드는 다음과 같은 출력 값을 반환합니다:\n\narray(3) {\n  'a' =\u003e array(2) {\n    'strlen' =\u003e int(1)\n    'mb_strlen' =\u003e int(1)\n  }\n  '円' =\u003e array(2) {\n    'strlen' =\u003e int(3)\n    'mb_strlen' =\u003e int(1)\n  }\n  '𠮷' =\u003e array(2) {\n    'strlen' =\u003e int(4)\n    'mb_strlen' =\u003e int(1)\n  }\n}\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n보시다시피, 두 개의 아시아 문자(일본어와 간단화된 중국어)를 처리할 때에도, 한 바이트 체크로 바이트 수를 확인하면 다른 결과를 얻지만, 멀티바이트 체크를 실행할 때에는 항상 같은 결과를 얻습니다.\n\n이는 예상한 바와 같지만 여기서 강조해야 할 점은 문자에 따라 3바이트 또는 4바이트를 얻게 된다는 것입니다. 이 차이의 이유는 사용된 문자가 ASCII 관점뿐만 아니라 코드 유닛 관점에서도 다르기 때문입니다:\n\n```javascript\n$str1 = \"a\";    // ASCII 문자\n$str2 = \"円\";   // BMP 내의 싱글 코드 유닛 문자\n$str3 = \"𠮷\";   // 대리 서로쌍 (두 코드 유닛)\n```\n\n그러면 PHP가 이미 단일 문자 체크에서 다른 동작을 제공하는데, JavaScript나 TypeScript의 경우는 어떻게 될까요? 그 답은 서로 다른 시나리오를 직면할 때 더 간단한 작업을 수행한다는 점입니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nconst str1 = \"a\";    // ASCII character\nconst str2 = \"円\";   // Single code unit character in BMP\nconst str3 = \"𠮷\";   // Surrogate pair (two code units)\n\nconsole.log(str1.length); // Output: 1\nconsole.log(str2.length); // Output: 1\nconsole.log(str3.length); // Output: 2\n```\n\n만약 PHP 예제를 다시 확인하면 각각의 경우에 바이트 수가 다른 것을 기억할 것입니다. 그런데 이게 왜 발생하는 걸까요?\n\n- \"a\"는 PHP에서 1바이트이고 JavaScript / TypeScript에서도 1바이트입니다.\n- \"円\"은 PHP에서 3바이트이고 JavaScript / TypeScript에서는 1바이트입니다.\n- \"𠮷\"는 PHP에서 4바이트이고 JavaScript / TypeScript에서는 2바이트입니다.\n\n답은 코드 단위에 있습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- PHP에서 strlen(\"円\")은 2를 반환합니다. 이는 PHP의 strlen() 함수가 바이트를 세기 때문에 \"円\"이 UTF-8로 표현될 때 8비트의 3바이트(E5 86 86)로 계산되기 때문입니다.\n- JavaScript에서 \"円\".length는 16비트 코드 단위의 수를 반환합니다. 따라서 \"円\"에 대해 1을 반환합니다.\n- 다시 말해, PHP는 8비트 논리를 사용하고, JavaScript는 16비트 논리를 사용합니다.\n\n그래서 나는 각 케이스를 더 잘 이해하기 위해 편리하고 효율적으로 에러와 불일치의 개수를 최소화하려고, Frontend가 Backend API 호출을 방지할 수 있도록 초기 단계에서 이상한 것을 감지하면 됩니다.\n\n```js\n// 더 나은 이해를 위한 JavaScript 함수\n\nfunction isSingleCodeUnit(char) {\n    return char.length === 1;\n}\n\nfunction isSurrogatePair(char) {\n    return char.length === 2 \u0026\u0026 char.codePointAt(0) \u003e 0xFFFF;\n}\n\nfunction classifyCharacters(str) {\n    let result = [];\n\n    for (let char of Array.from(str)) {\n        if (isSingleCodeUnit(char)) {\n            result.push({ char, length: 1 });\n        } else if (isSurrogatePair(char)) {\n            result.push({ char, length: 2 });\n        } else {\n            result.push({ char, length: \"Unknown\" });\n        }\n    }\n\n    return result;\n}\n\n// 예제 사용법:\nlet input1 = \"a円𠮷\";\n\nconsole.log(classifyCharacters(input1));\n// [\n//     { char: 'a', length: 1 },\n//     { char: '円', length: 1 },\n//     { char: '𠮷', length: 2 }\n// ]\n```\n\n이 케이스를 더 잘 이해하기 위해 유니코드와 기본 다국어 평면(BMP)과 UTF 인코딩에 대해 더 깊숙히 알아야 할 필요가 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Unicode은 모든 문자체계에서 모든 문자를 포함하고자 하는 표준입니다. 각 문자에는 고유한 코드 포인트가 할당됩니다.\n- 기본 다국어 평면(BMP)은 Unicode 문자 집합의 첫 번째 평면으로, U+0000부터 U+FFFF까지의 코드 포인트를 가진 문자가 포함되어 있습니다. 이에는 라틴 문자, 숫자, 기호 및 다양한 문자 체계의 문자가 포함됩니다.\n- UTF-8: 문자가 1~4바이트 길이일 수 있는 가변 길이 인코딩입니다. ASCII 문자(U+0000부터 U+007F)는 1바이트입니다. U+0080에서 U+FFFF까지는 2바이트 또는 3바이트이며, U+10000에서 U+10FFFF까지의 문자는 4바이트입니다.\n- UTF-16: 문자가 일반적으로 2바이트인 가변 길이 인코딩입니다. 그러나 BMP 밖의 문자(U+10000에서 U+10FFFF)는 대리 쌍을 사용하여 4바이트로 인코딩됩니다.\n- UTF-32: 각 문자가 코드 포인트에 관계없이 4바이트인 고정 길이 인코딩입니다.\n\nBMP(다른 인코딩의 맥락에서의 다중 바이트 문자):\n\n- UTF-8: BMP(U+0000에서 U+FFFF)의 문자는 1, 2 또는 3바이트로 인코딩될 수 있습니다. ASCII 문자(U+0000에서 U+007F)는 1바이트입니다. 기타 BMP 문자(U+0080에서 U+FFFF)는 2 또는 3바이트일 수 있습니다.\n- UTF-16: BMP의 문자는 일반적으로 2바이트로 인코딩됩니다. BMP 밖의 문자만 대리 쌍을 사용하여 4바이트로 인코딩됩니다.\n\n다음은 UTF-8 및 UTF-16에서 다양한 문자가 인코딩되는 방식을 설명하는 몇 가지 예시입니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n[ UTF-8 ] ASCII 문자 (예: ‘A’):\n\n- 코드 포인트: U+0041\n- UTF-8 인코딩: 1바이트 (0x41)\n\n[ UTF-8 ] Latin-1 보충 (예: ‘é’):\n\n- 코드 포인트: U+00E9\n- UTF-8 인코딩: 2바이트 (0xC3 0xA9)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n[ UTF-8 ] CJK 통합 한자 (예: ‘円’):\n\n- 코드 포인트: U+5186\n- UTF-8 인코딩: 3바이트 (0xE5 0x86 0x86)\n\n[ UTF-16 ] ASCII 문자 (예: ‘A’):\n\n- 코드 포인트: U+0041\n- UTF-16 인코딩: 2바이트 (0x0041)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n[ UTF-16 ] 라틴-1 보충 (예 : ‘é’):\n\n- 코드 포인트: U+00E9\n- UTF-16 인코딩: 2바이트 (0x00E9)\n\n[ UTF-16 ] CJK 통합 한자 (예 : ‘円’):\n\n- 코드 포인트: U+5186\n- UTF-16 인코딩: 2바이트 (0x5186)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n[ UTF-16 ] 보충 문자 (예: '𠮷'):\n\n- 코드 포인트: U+20BB7\n- UTF-16 인코딩: 4바이트 (0xD842 0xDFB7) (대리 쌍)\n\n다중 바이트 문자: UTF-8에서는 한 바이트보다 더 많은 바이트가 필요한 모든 문자를 의미합니다. UTF-16에서는 BMP(기본 다중 언어 평면) 내 문자들이 일반적으로 2바이트이지만, BMP 밖의 문자들은 대리 쌍으로 인코딩되어 4바이트를 차지합니다.\n\nBMP 문자: 대부분 일반적인 문자와 기호를 포함하며, UTF-16에서는 보통 2바이트로 표현됩니다. UTF-8에서는 1에서 3바이트까지 길이가 다양합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 박수와 팔로우 부탁드려요!\n\n👏 이 글이 마음에 드셨나요? 아래의 👏 버튼을 눌러 박수를 보내주세요. 여러분의 지원은 저에게 큰 힘이 됩니다!\n\n📚 제 최신 게시물을 계속해서 받고 싶으신가요? \"팔로우\" 버튼을 눌러 저의 커뮤니티에 참여하고 놓치지 마세요.\n\n읽어 주셔서 감사합니다! 여러분의 피드백과 지원이 저에게 더 많은 가치있는 정보를 공유하도록 격려해줍니다. 🙌\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 스택더믹 🎓\n\n끝까지 읽어주셔서 감사합니다. 떠나시기 전에:\n\n- 작가를 클래핑하고 팔로우해주시면 감사하겠습니다! 👏\n- 저희를 팔로우해주세요 X | LinkedIn | YouTube | Discord\n- 다른 플랫폼도 방문해보세요: In Plain English | CoFeed | Differ\n- 더 많은 콘텐츠는 Stackademic.com에서 확인하세요","ogImage":{"url":"/TIL/assets/img/2024-07-15-8-bitvs16-bitcodeunitaPHPSymfonyvsTypeScriptNextJStaleforFrontendandBackend_0.png"},"coverImage":"/TIL/assets/img/2024-07-15-8-bitvs16-bitcodeunitaPHPSymfonyvsTypeScriptNextJStaleforFrontendandBackend_0.png","tag":["Tech"],"readingTime":11},{"title":"2024년 프로덕션 레디 LLM 애플리케이션을 위한 기술 스택","description":"","date":"2024-07-15 00:06","slug":"2024-07-15-TechStackForProduction-ReadyLLMApplicationsIn2024","content":"\n\nML 작업을 6년 이상 한 뒤, AI/LLM 스타트업 3개를 론칭하고 수십 개의 프로젝트와 파이프라인을 구축했습니다. RAG와 Agent 프레임워크부터 적절한 테스트, CI/CD 및 관측성이 있는 LLM 기반 서비스까지 많은 LLM 도구를 실험했습니다.\n\n본문은 다양한 이유로 가장 좋아하는 도구 목록입니다. RAG 데이터베이스와 에이전트에서부터 API 엔드포인트, HTTPS 및 자동 배포 파이프라인, 적절한 관측성까지 전체 LLM 애플리케이션 개발 수명주기를 따라갈 것입니다. 그 과정에서 각 단계의 프레임워크와 도구를 살펴볼 것입니다.\n\n그리고 한 가지 더 — 나의 기술 스택에 동의하지 않을 수 있습니다. 그러나 주로 사용의 간결함을 기반으로 도구를 선택했습니다. 예를 들어, VPS에 배포하는 대신 Azure와 같은 대형 클라우드 제공업체를 사용할 수 있습니다. 그렇게 하면 확장성이 높아지고, out-of-box 서비스가 더 많아지며, 등등의 혜택을 받을 것입니다. 그러나 모든 것을 마스터하기까지 훨씬 더 많은 시간이 소요되며, 벤더 락인될 가능성이 높아집니다. Coolify와 함께 VPS를 사용하면 (나중에 언급할 것입니다), 시작하는 데 약 10분이 걸리고, 데이터베이스, 프론트엔드/백엔드 배포, 자동화된 CI/CD 및 백업이 필요한 모든 것이 직관적이고 사용하기 쉬운 UI로 제공됩니다.\n\n![TechStackForProduction-ReadyLLMApplicationsIn2024](/TIL/assets/img/2024-07-15-TechStackForProduction-ReadyLLMApplicationsIn2024_0.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# LLM API 및 Self Hosted 옵션\n\n대형 언어 모델 API에는 두 가지 주요 옵션이 있습니다:\n\n- 자체 호스팅 버전을 선택하는 경우 Ollama가 그 방법입니다. \"왜 자체 호스팅 LLM이 필요할까요? 더 비싸고 설정하기 어렵며 응답 품질도 떨어집니다\"라고 묻는다면, 답은 간단합니다 — 개인 정보 보호입니다. 이미 개인 정보 보호와 LLM에 대해 썼지만 간단히 말하면, API를 사용하면 데이터를 다른 회사와 공유하며, 그 회사들은 데이터를 더 많은 제3자와 공유합니다. 어떤 프로젝트에서는 이를 용납할 수 없습니다.\n- 프로젝트가 높은 개인 정보 보호와 보안을 요구하지 않는다면, 항상 Openrouter를 사용합니다. 간단하게 다양한 공급 업체 위에 구축된 Openrouter가 항상 다른 어떤 LLM 공급자보다 훨씬 낫습니다. 하나의 LLM에 대한 파이프라인을 작성했다면 요청 문자열을 몇 개 변경함으로써 LLM을 쉽게 변경할 수 있습니다. 추가 라이브러리나 공급 업체 전환 없이 매우 간단합니다. 자세한 내용을 알고 싶다면 Openrouter 안내서를 확인하세요.\n\ntogether.ai, Mistral 등의 다른 LLM 공급 업체도 많지만, Openrouter를 더 선호하는 이유는 간단한 인터페이스와 제공하는 추가 유용한 기능(자동 로깅, 모델 비교, 자동 모델 선택, 무료 평가판 등) 때문입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![이미지](/TIL/assets/img/2024-07-15-TechStackForProduction-ReadyLLMApplicationsIn2024_1.png)\n\n# RAG 데이터베이스\n\n대부분의 LLM은 다음과 같은 문제를 가지고 있습니다:\n\n- 최신 정보가 아님;\n- 도메인 지식이 없음;\n- 환각;\n- 출처를 인용하지 않음;\n- 편향된 응답.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n모든 이 문제들은 적절한 RAG (검색 보완 생성)을 사용하여 해결할 수 있어요. 모든 RAG 알고리즘은 어떠한 형식의 벡터 데이터베이스를 요구해요. 제가 가장 선호하는 선택지는 다음과 같아요:\n  \n- ChromaDB — 프로토타입 및 PoC (개념 증명) 작업에 완벽해요. SQLite를 기반으로 구축되어 있어 설치가 매우 쉽고 (PC의 파일로 구성되어 있어요), 사용법도 매우 직관적이고 문서화가 잘 돼 있어요.\n- 더 심각한 프로젝트를 위해, 저는 Supabase (PostgreSQL 기반)와 PGVector 플러그인을 사용해요. Supabase의 장점은 직관적이고 사용하기 쉬운 UI, 백업, 역할 관리, API 및 Python 패키지와 같은 많은 기능이 있어요. Supabase를 사용하는 방법에 대한 가이드도 많이 있고, 개인적으로 좋아하는 점은 오픈 소스이며 자체 서버에 호스팅할 수 있다는 점이에요.\n\n보통은 사용자 지정 솔루션을 사용하지만, 때로는 LangChain이 RAG 파이프라인 작성에 크게 도움이 될 수 있어요.\n\n![이미지](/TIL/assets/img/2024-07-15-TechStackForProduction-ReadyLLMApplicationsIn2024_2.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 에이전트\n\n더 정교한 LLM 파이프라인을 생성하거나 LLM을 사용하여 어려운 문제를 해결하려면 에이전틱 접근 방식을 사용해야 합니다. LLM 에이전트는 순차적(단계별) 추론을 사용하는 AI 시스템입니다. 기본적으로 LLM에 대한 지침 세트를 정의하는 대신 문제를 해결할 수 있는 자유와 도구 세트를 제공합니다.\n\n저는 에이전트를 생성하기 위해 사용하는 Python 라이브러리들은 다음과 같습니다:\n\n- LangChain — 현재 가장 인기 있는 에이전트용 프레임워크이며, 훌륭한 문서, 거대한 커뮤니티, 그리고 가이드가 많이 포함된 많은 자습서가 있습니다. 제가 권장하는 한 가지는 create_react_agent나 create_json_agent와 같은 새로운 방법 대신 initialize_agent 메서드를 사용하는 것입니다. 이 방법을 선택한 이유는 새로운 방법에는 아직 많은 가이드나 지침이 없어서 제 개인적으로는 조금 혼란스러웠기 때문입니다. initialize_agent 메서드는 사용하기 쉽고 다양한 접근 방법을 가진 가이드가 수십 개 있습니다.\n- LlamaIndex — LangChain의 주요 경쟁 업체로, 인덱싱 및 데이터 검색에서의 우수한 최적화로 알려져 있습니다. 간단히 말해, RAG 파이프라인을 구축할 때, llamaindex가 더 빠르고 나은 옵션일 수 있지만, 더 복잡한 프로젝트와 파이프라인의 경우 LangChain을 사용하는 것이 좋습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n일반적으로, LangChain을 사용하여 LLMs를 학습하는 것이 더 기능이 풍부하고 사용하기 쉽습니다.\n\n# 관찰 가능성\n\n이제 LLM 애플리케이션을 배포했다면, 답변의 품질, 정확성 및 속도를 측정해야합니다. 하지만 LLMs로 어떻게 할 수 있을까요? 저는 추적, 평가, 시각화 및 모니터링을 제공하는 두 개의 오픈 소스 LLM 관찰 가능성 플랫폼을 사용합니다:\n\n- Arize Phoenix\n- LangSmith\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저는 LangSmith를 사용하기가 조금 더 쉬웠어요. 그들은 입력-출력을 추적하는 아주 좋은 방법을 가지고 있고, 평가를 개발하는 것은 꽤 빠릅니다. 그러나 Phoenix는 데이터를 더 많이 추적할 수 있어서 더 나은 무료 티어를 가지고 있습니다. LLM observability로 시작하려면 LangSmith를 꼭 추천드릴 수 있어요 — PoC와 프로토타입에 완벽합니다.\n\n![Tech Stack](/TIL/assets/img/2024-07-15-TechStackForProduction-ReadyLLMApplicationsIn2024_3.png)\n\n# 백엔드\n\n백엔드는 항상 Python, FastAPI, Pydantic를 사용해요. 여기에 사용하는 이유들을 짧게 나열해볼게요:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- FastAPI은 상당히 빠르며 매우 좋은 문서가 제공되며 데이터베이스 ORM, 인증, CORS 및 멀티 스레드 배포와 같이 LLM 애플리케이션 개발에 필요한 모든 기능을 포함하고 있어요.\n- Pydantic은 함수와 엔드포인트에 엄격한 유형을 추가하는 데 도움이 되어 항상 원하는 유형의 모든 변수를 확신할 수 있게 해줘요. 애플리케이션을 에러로부터 보호하는 데 도움이 됩니다.\n\n일반적으로 Gunicorn + Uvicorn 워커와 함께 결합하여 동시에 여러 요청을 처리할 수 있어요.\n\n그럼에도 불구하고 Flask, Django와 같은 모든 백엔드 프레임워크를 사용할 수 있습니다. 이들은 모두 공통 기능을 가지고 있으며 모두 제품 준비가 되어 있습니다.\n\n# 배포\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n배포 작업에 대해서 말씀드리자면, 저는 항상 Docker를 사용하여 애플리케이션을 컨테이너화합니다. 주요 이유는 다음과 같습니다:\n\n- 재현성 — 앱과 함께 Docker 이미지를 빌드하면 어떤 시스템이나 CPU 아키텍처에서도 실행할 수 있습니다;\n- 확장성 — 앱이 도커화되어 있으면 여러 인스턴스를 쉽게 생성하거나 클러스터에 배포할 수 있습니다;\n- 배포 — Docker 이미지를 배포하는 것이 매우 간단합니다. 특히 Docker Compose를 사용하는 경우 더욱 쉬워집니다. 데이터베이스, 리버스 프록시 및 백엔드를 docker-compose.yml 파일에 추가하여 모든 것을 별도로 걱정하지 않고 한꺼번에 배포할 수 있습니다.\n\nDocker 이미지를 배포할 때 Coolify를 사용하고 있습니다 — 이는 배포 프로세스를 크게 단순화해 주는 오픈 소스, 자체 호스팅 플랫폼입니다. 다음과 같은 기능을 제공합니다:\n\n- SSL 인증서 자동 관리 — 백엔드를 https 호환으로 만들 필요가 없습니다;\n- 벤더 잠금 없음 — 모든 제공업체로부터 자유롭게 이점을 취할 수 있는 추상화 계층을 추가하여 Coolify를 어디서든 VPS 또는 클라우드 제공자에 배포할 수 있습니다;\n- 간편한 리버스 프록시 — Coolify에서는 보안과 도메인에 대해 걱정할 필요가 없습니다. 사용하려는 도메인만 Coolify에 작성하면 됩니다;\n- 자동화된 DB 백업 — PostgreSQL, MySQL, Redis 등과 같은 일반 이미지를 사용하는 경우 몇 번의 클릭으로 백업 설정을 할 수 있습니다. 사용자 정의 솔루션을 작성하거나 돈을 지불할 필요가 없습니다.\n- CI/CD 파이프라인 — 깃허브와 연결하여 자동 배포 파이프라인을 무료로 이용할 수 있습니다. 앱을 업데이트하면 자동으로 배포됩니다;\n- 협업 기능 — 팀원들과 Coolify를 공유하고, 서로 다른 측면의 앱에 대해 함께 작업할 수 있습니다. 각 사용자에 대한 권한도 제어할 수 있습니다.\n- 모니터링 및 알림 — Telegram/Discord와 같은 다양한 응용 프로그램 중 하나를 설치해 배포 상황에 변화가 있을 때 알림을 받을 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Tech Stack](/TIL/assets/img/2024-07-15-TechStackForProduction-ReadyLLMApplicationsIn2024_4.png)\n\n# 요약\n\n이 기사에서는 여러분의 LLM 애플리케이션을 작성하기 위한 멋진 기술 스택을 다루었습니다. 이 도구들을 사용함으로써 다음을 얻을 수 있습니다:\n\n- 신뢰할 수 있고 쉽게 사용할 수 있는 벡터 DB;\n- 다양한 크기와 적절한 개인 정보 보호를 갖춘 모든 문제에 대한 LLM;\n- 공급업체 락인 없음;\n- 파이프라인을 위한 적절한 로깅과 모니터링;\n- 애플리케이션을 쉽게 배포할 수 있는 확장 가능하고 유지 보수가능한 방법.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기술 스택을 댓글로 공유해 주세요. 함께 토론하며 최적의 도구 세트를 찾아보겠습니다! 이 글이 마음에 드셨다면 박수를 보내주시고 답글을 남겨주세요. 여러분의 피드백은 저에게 귀중합니다.\n\n마지막으로, 제 스타트업인 비즈니스 아이디어를 검증하는 https://validator.yazero.io 를 방문해 지원해 주시면 감사하겠습니다.\n\n# 참고 소스\n\n- https://www.trychroma.com\n- https://supabase.com\n- https://python.langchain.com/v0.1/docs/modules/agents/\n- https://www.llamaindex.ai\n- https://phoenix.arize.com\n- https://stackshare.io/langsmith\n- https://fastapi.tiangolo.com\n- https://docs.pydantic.dev/latest/\n- https://www.docker.com\n- https://coolify.io\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 친절한 한국어 번역 🚀\n\nIn Plain English 커뮤니티에 참여해 주셔서 감사합니다! 이제 가시기 전에:\n\n- 반드시 박수를 보내고 작가를 팔로우해주세요 👏️️\n- 저희를 팔로우해주세요: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼도 방문해주세요: CoFeed | Differ\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요","ogImage":{"url":"/TIL/assets/img/2024-07-15-TechStackForProduction-ReadyLLMApplicationsIn2024_0.png"},"coverImage":"/TIL/assets/img/2024-07-15-TechStackForProduction-ReadyLLMApplicationsIn2024_0.png","tag":["Tech"],"readingTime":10},{"title":"알고 나서 놀란 Itertools Python의 9가지 비밀","description":"","date":"2024-07-15 00:04","slug":"2024-07-15-9ThingsINeverKnewAboutItertoolsPythonUntilRecently","content":"\n\n이미지 태그를 아래와 같이 수정해주세요.\n\n\n![image](/TIL/assets/img/2024-07-15-9ThingsINeverKnewAboutItertoolsPythonUntilRecently_0.png)\n\n\n비디오 콘텐츠 실험 64일차\n\n## 1) Batched\n\nitertools.batched 함수(파이썬 3.12 이상에서만 사용 가능)를 사용하면 이터러블을 일괄 처리하는 것이 쉬워집니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport itertools\n\nfor i in itertools.batched('abcdefg', 3):\n    print(i)\n\n# ('a', 'b', 'c')\n# ('d', 'e', 'f')\n# ('g',)\n```\n\n^ 문자열을 3개씩 묶어 반복하는 코드입니다. (마지막 묶음은 원소가 부족하므로 1개의 원소만 포함됩니다)\n\n## 2) Pairwise\n\nitertools.pairwise 함수를 사용하면 iterable의 각 이웃하는 두 원소를 비교할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport itertools\n\nfor i in itertools.pairwise('abcdefg'):\n    print(i)\n\n'''\n('a', 'b')\n('b', 'c')\n('c', 'd')\n('d', 'e')\n('e', 'f')\n('f', 'g')\n'''\n```\n\n^우리가 iterable에 있는 각 쌍 (bigram)의 요소를 순회하는 것입니다. 각 요소를 그 다음 요소와 비교해야 할 때 유용합니다.\n\n만약 필요하다면 이 함수를 구현하는 번거로움을 피할 수 있습니다.\n\n# 3) Accumulate\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nitertools.accumulate 함수를 사용하면 다음을 수행할 수 있습니다:\n\n```js\nimport itertools\n\nfor i in itertools.accumulate('abcdefg'):\n    print(i)\n\n'''\na\nab\nabc\nabcd\nabcde\nabcdef\nabcdefg\n'''\n```\n\n# 4) 조합 및 순열\n\nitertools.combinations(iterable, n) 함수를 사용하면 iterable의 요소들 중 길이 n인 모든 조합을 생성할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n`itertools.permutations(iterable, n)` 함수를 사용하면 길이 n의 iterable 요소들의 모든 순열을 생성할 수 있어요.\n\n참고 - 순열에서는 요소의 순서가 중요합니다. 조합에서는 요소의 순서가 중요하지 않아요.\n\n```js\nimport itertools\n\nfor i in itertools.permutations([1, 2, 3, 4], 2):\n    print(i, end=' ')\n\n# (1, 2) (1, 3) (1, 4) (2, 1) (2, 3) (2, 4) (3, 1) (3, 2) (3, 4) (4, 1) (4, 2) (4, 3)\n```\n\n^ [1, 2, 3, 4]의 요소 중에서 길이가 2인 모든 순열을 찾으려면 — 여기에서 [1, 4]와 [4, 1]은 서로 다르게 간주되는 것을 주목해주세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport itertools\n\nfor i in itertools.combinations([1, 2, 3, 4], 2):\n    print(i, end=' ')\n\n# (1, 2) (1, 3) (1, 4) (2, 3) (2, 4) (3, 4)                                                     \n```\n\n^ [1, 2, 3, 4] 요소의 길이가 2인 모든 조합을 찾습니다. [4, 1]은 [1, 4]와 동일하게 간주되어 존재하지 않음을 주목해 주세요.\n\n## 5) 곱셈\n\n```js\nfor i in [1, 2]:\n    for j in [3, 4]:\n        for k in [5, 6]:\n            print(i, j, k)\n\n'''\n1 3 5\n1 3 6\n1 4 5\n1 4 6\n2 3 5\n2 3 6\n2 4 5\n2 4 6\n'''\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nMarkdown 형식으로 표 태그를 변경하려면 다음과 같이 하면 됩니다.\n\n\n^ a triple nested for loop.\n\n```js\nfrom itertools import product\n\nfor i, j, k in product([1, 2], [3, 4], [5, 6]):\n  print(i, j, k)\n\n'''\n1 3 5\n1 3 6\n1 4 5\n1 4 6\n2 3 5\n2 3 6\n2 4 5\n2 4 6\n'''\n```\n\n^ itertools.product를 사용한 위의 삼중 중첩 for 루프와 똑같이 작업을 수행하여 우리는 여러 중첩된 for 루프를 간단하고 우아한 한 줄의 코드로 단축할 수 있습니다.\n\n# 6) Groupby\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nitertools.groupby 함수를 사용하면 함수를 통해 동시에 요소를 반복하고 그룹화할 수 있습니다.\n\n```python\nimport itertools \n\nwords = ['apple', 'ant', 'arm', 'boy', 'bee', 'cat', 'donkey']\n\ndef condition(x):\n  return x[0]  # 요소의 첫 글자를 반환\n\nfor key, group in itertools.groupby(words, condition):\n    print(key, list(group))\n\n'''\na ['apple', 'ant', 'arm']\nb ['boy', 'bee']\nc ['cat']\nd ['donkey']\n'''\n```\n\n^ 첫 글자를 기준으로 요소를 그룹화합니다 — 이를 수행하기 위해 사용자 정의 함수 condition을 전달합니다.\n\n```python\nimport itertools \n\nwords = ['apple', 'ant', 'arm', 'boy', 'bee', 'cat', 'donkey']\nfor key, group in itertools.groupby(words, lambda x:x[0]):\n    print(key, list(group))\n\n'''\na ['apple', 'ant', 'arm']\nb ['boy', 'bee']\nc ['cat']\nd ['donkey']\n'''\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n^ 첫 글자를 기준으로 요소를 그룹화하는 것 (람다 x : x[0]) — 우리는 함수를 정의하기 위해 def 키워드를 사용할 필요가 없도록 작은 익명 함수인 람다 함수를 작성할 수 있습니다.\n\n```js\nimport itertools\n\nwords = ['apple', 'ant', 'arm', 'boy', 'bee', 'cat', 'donkey', 'aa', 'ab']\nfor key, group in itertools.groupby(words, lambda x: x[0]):\n    print(key, list(group))\n\n'''\na ['apple', 'ant', 'arm']\nb ['boy', 'bee']\nc ['cat']\nd ['donkey']\na ['aa', 'ab']\n'''\n```\n\n^ 그룹은 서로 옆에 있어야 합니다 — 여기서 [`aa`, `ab`]는 앞에서 a로 시작하는 그룹에 합류하지 않습니다.\n\n# 7) 압축\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nitertools.compress 함수는 2개의 이터러블을 사용합니다 — 주 이터러블과 True/False 또는 1/0 값을 포함하는 다른 이터러블인데 이 값들은 주 이터러블에서 생성할 요소를 결정합니다.\n\n```js\nimport itertools\n\nfor i in itertools.compress('ABCD', [1,0,0,0]):\n    print(i, end=' ')\n\n# A\n```\n\n```js\nimport itertools\n\nfor i in itertools.compress('ABCD', [1,1,0,0]):\n    print(i, end=' ')\n\n# A B\n```\n\n```js\nimport itertools\n\nfor i in itertools.compress('ABCD', [1,1,1,0]):\n    print(i, end=' ')\n\n# A B C\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n```js\nimport itertools\n\nfor i in itertools.compress('ABCD', [1,1,1,1]):\n    print(i, end=' ')\n\n# A B C D\n```\n\n```js\nimport itertools\n\nfor i in itertools.compress('ABCD', [1,0,1,0]):\n    print(i, end=' ')\n\n# A C \n```\n\n# 8) Zip_longest\n\n```js\nfor i,j,k in zip([1,2,3,4], [5,6,7,8], [9,10]):\n  print(i, j, k)\n\n# 1 5 9\n# 2 6 10\n```\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n^ 일반적인 zip() 함수를 사용할 때, 한 번에 여러 이터러블을 반복할 수 있지만, 가장 짧은 이터러블에 제한을 받습니다. 예를 들어, [9, 10]가 가장 짧은 이터러블이기 때문에 zip()은 2개의 행만 생성합니다.\n\n```js\nfrom itertools import zip_longest\n\nfor i, j, k in zip_longest([1, 2, 3, 4], [5, 6, 7, 8], [9, 10]):\n  print(i, j, k)\n\n# 1 5 9\n# 2 6 10\n# 3 7 None\n# 4 8 None\n```\n\n^ 이 한계를 우회하기 위해 zip_longest로 이를 대체할 수 있으며, 이 경우 가장 긴 이터러블을 통해 zip할 수 있습니다. 그러나 특정한 이터러블에서 값이 부족해지면 None이 사용됩니다.\n\n# 9) 반복 \u0026 사이클\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport itertools\n\nfor i in itertools.repeat('ABC'):\n  print(i)\n\n# ABC\n# ABC\n# ABC\n# ABC\n\n# 무한한 수의 ABC\n\n```\n\n^ itertools.repeat()을 사용하면 무한히 반복할 수 있습니다.\n\n```js\nimport itertools\n\nfor i in itertools.cycle('ABC'):\n  print(i)\n\n# A\n# B\n# C\n# A\n# B\n# C\n# A\n# B\n# C\n\n# 무한한 A, B, C의 순환, 그리고 다시 A로, B로, C로...\n\n```\n\n# 결론\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이해하기 쉽고 명확했길 바랍니다.\n\n# 마무리의 한 마디\n\n만약 이 이야기가 도움이 되었고 조금이라도 지지를 표현하고 싶다면:\n\n- 이 이야기에 대해 50번 박수를 칩니다\n- 어떻게 생각하는지 댓글을 남깁니다\n- 당신에게 공감되는 부분을 강조합니다\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이러한 조치들은 정말로 저를 도와주고, 정말 감사합니다!\n\n제가 쓴 Ebooks: [여기를 클릭하세요!](https://zlliu.co/ebooks)\n\nLinkedIn: [프로필 링크](https://www.linkedin.com/in/zlliu/)","ogImage":{"url":"/TIL/assets/img/2024-07-15-9ThingsINeverKnewAboutItertoolsPythonUntilRecently_0.png"},"coverImage":"/TIL/assets/img/2024-07-15-9ThingsINeverKnewAboutItertoolsPythonUntilRecently_0.png","tag":["Tech"],"readingTime":10},{"title":"모든 개발자가 알아야 할 고급 파이썬 개념 9가지","description":"","date":"2024-07-15 00:03","slug":"2024-07-15-9AdvancedPythonConceptsEveryDeveloperShouldUnderstand","content":"\n\n\n![이미지](/TIL/assets/img/2024-07-15-9AdvancedPythonConceptsEveryDeveloperShouldUnderstand_0.png)\n\nPython은 간단하고 가독성이 좋아 초보자들 사이에서 인기가 높습니다. 그러나 Python의 전체 잠재력을 활용하기 위해 개발자들은 일부 고급 개념을 숙달해야 합니다. 여기 개발자들이 더 효율적이고 유지보수 가능하며 확장 가능한 코드를 작성하기 위해 이해해야 하는 9가지 고급 Python 개념이 소개됩니다.\n\n# 1. 제너레이터와 이터레이터\n\n제너레이터와 이터레이터를 사용하면 게으른(lazy) 평가가 가능하며, 이는 메모리를 절약하고 성능을 향상시킬 수 있습니다. 제너레이터는 함수와 yield 문을 사용하여 이터레이터를 만드는 간단한 방법입니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 이터레이터\n\n이터레이터는 이터레이터 프로토콜을 구현한 객체로, __iter__()와 __next__() 메서드로 구성됩니다.\n\n```js\nclass MyIterator:\n    def __init__(self, data):\n        self.data = data\n        self.index = 0\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        if self.index \u003e= len(self.data):\n            raise StopIteration\n        value = self.data[self.index]\n        self.index += 1\n        return value\n\nmy_iter = MyIterator([1, 2, 3])\nfor item in my_iter:\n    print(item)\n```\n\n# 제너레이터\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n생성기는 반복자를 쉽게 만드는 방법을 제공합니다.\n\n```js\ndef my_generator():\n    yield 1\n    yield 2\n    yield 3\n\ngen = my_generator()\nfor item in gen:\n    print(item)\n```\n\n# 2. 데코레이터\n\n데코레이터는 함수 또는 클래스의 동작을 수정하는 강력한 기능입니다. 주로 로깅, 접근 제어, 측정 및 캐싱에 사용됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\ndef my_decorator(func):\n    def wrapper(*args, **kwargs):\n        print(\"함수 호출 전\")\n        result = func(*args, **kwargs)\n        print(\"함수 호출 후\")\n        return result\n    return wrapper\n\n@my_decorator\ndef say_hello():\n    print(\"안녕!\")\n\nsay_hello()\r\n```\n\n# 3. 컨텍스트 매니저\n\n컨텍스트 매니저는 원하는 시점에 정확히 리소스를 할당하고 해제할 수 있도록 해줍니다. 가장 흔한 컨텍스트 매니저의 사용 방법은 `with` 문과 함께 사용하는 것입니다.\n\n```python\nclass MyContextManager:\n    def __enter__(self):\n        print(\"컨텍스트 진입\")\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        print(\"컨텍스트 종료\")\n\nwith MyContextManager():\n    print(\"컨텍스트 내부\")\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파일 처리는 일반적인 사용 사례입니다.\n\n```python\nwith open('file.txt', 'w') as file:\n    file.write('Hello, World!')\n```\n\n## 4. 메타클래스\n\n메타클래스는 클래스의 동작을 정의하는 방법입니다. 클래스 속성이나 메서드를 정의할 때 클래스를 수정하여 클래스 생성을 사용자 정의할 수 있게 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\r\nclass Meta(type):\n    def __new__(cls, name, bases, attrs):\n        attrs['greet'] = lambda self: f\"Hello from {self.__class__.__name__}\"\n        return super().__new__(cls, name, bases, attrs)\n\nclass MyClass(metaclass=Meta):\n    pass\n\nobj = MyClass()\nprint(obj.greet())\r\n```\n\n# 5.  디스크립터\n\n디스크립터는 클래스 내에서 관리 속성을 만드는 방법입니다. 속성에 대한 액세스, 설정 및 삭제 동작을 정의할 수 있도록 합니다.\n\n```js\r\nclass MyDescriptor:\n    def __init__(self, name=None):\n        self.name = name\n\n    def __get__(self, instance, owner):\n        return instance.__dict__.get(self.name)\n\n    def __set__(self, instance, value):\n        instance.__dict__[self.name] = value\n\n    def __delete__(self, instance):\n        del instance.__dict__[self.name]\n\nclass MyClass:\n    attr = MyDescriptor('attr')\n\nobj = MyClass()\nobj.attr = 42\nprint(obj.attr)\ndel obj.attr\r\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 6. 코루틴과 Asyncio\n\n코루틴과 asyncio 모듈을 사용하면 Python에서 비동기 프로그래밍을 할 수 있어요. 이를 통해 블로킹 되지 않는 I/O 작업을 수행할 수 있는 코드를 작성할 수 있어요.\n\n## 코루틴\n\n코루틴은 실행을 일시 중지하고 다시 시작할 수 있는 함수들이에요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\r\nimport asyncio\n\nasync def my_coroutine():\n    print(\"Start coroutine\")\n    await asyncio.sleep(1)\n    print(\"End coroutine\")\n\nasyncio.run(my_coroutine())\r\n```\n\n# Asyncio\n\nAsyncio는 async/await 구문을 사용하여 동시성 코드를 작성하기 위한 라이브러리입니다.\n\n```js\r\nasync def main():\n    await asyncio.gather(my_coroutine(), my_coroutine())\n\nasyncio.run(main())\r\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 7. 타입 주석\n\n타입 주석은 변수, 함수 매개변수 및 반환 값을 정의하여 코드 가독성을 향상시키고 오류를 초기에 잡아낼 수 있습니다.\n\n```python\ndef greet(name: str) -\u003e str:\n    return f\"Hello, {name}\"\n\ndef add(a: int, b: int) -\u003e int:\n    return a + b\n\nname: str = \"Alice\"\nage: int = 30\n```\n\n# 8. 슬롯\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n인스턴스 속성을 미리 정의된 목록으로 제한하여 메모리를 절약하고 속성 액세스 속도를 높일 수 있는 슬롯은 유용합니다.\n\n```python\nclass MyClass:\n    __slots__ = ['name', 'age']\n\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\nobj = MyClass('Alice', 30)\nprint(obj.name, obj.age)\n```\n\n# 9. Multiprocessing\n\nmultiprocessing 모듈을 사용하면 별도의 프로세스를 생성하고 관리할 수 있어 Python 애플리케이션에서 진정한 병렬 처리를 수행할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nfrom multiprocessing import Process\n\ndef worker(num):\n    print(f'Worker: {num}')\n\nif __name__ == '__main__':\n    processes = []\n    for i in range(5):\n        p = Process(target=worker, args=(i,))\n        processes.append(p)\n        p.start()\n\n    for p in processes:\n        p.join()\n```\n\n이러한 고급 Python 개념을 습득함으로써 더 효율적이고 유지보수가 쉬운 확장 가능한 코드를 작성할 수 있습니다. 이러한 개념은 코딩 기술뿐만 아니라 더 복잡한 문제와 프로젝트에 자신감을 갖고 접근할 수 있도록 도와줍니다. 즐거운 코딩하세요!","ogImage":{"url":"/TIL/assets/img/2024-07-15-9AdvancedPythonConceptsEveryDeveloperShouldUnderstand_0.png"},"coverImage":"/TIL/assets/img/2024-07-15-9AdvancedPythonConceptsEveryDeveloperShouldUnderstand_0.png","tag":["Tech"],"readingTime":8},{"title":"파이썬 개발자를 위한 PHP  5편  반복문 사용하는 방법","description":"","date":"2024-07-15 00:02","slug":"2024-07-15-PHPforPythonDevelopersPart5Loops","content":"\n\n![image](/TIL/assets/img/2024-07-15-PHPforPythonDevelopersPart5Loops_0.png)\n\n# 시리즈의 목적\n\n이 시리즈의 목적은 PHP 8.x를 배우려는 Python 3.x 개발자들에게 체계적인 안내를 제공하는 것입니다. 두 언어 사이의 유사점과 차이점을 강조하며, 원활한 전환을 보장하기 위해 실용적인 예제와 비교를 제공할 것입니다.\n\n본 시리즈는 이미 Python과 핵심 프로그래밍 개념에 익숙하다고 가정합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 소개\n\n반복문은 프로그래밍에 중요한 요소로, 특정 조건에 따라 코드가 반복적으로 실행될 수 있습니다. PHP에서는 다양한 종류의 반복문을 제공하여 더 많은 유연성을 제공합니다.\n\n본 문서에서는 다음을 비교할 것입니다:\n\n- while 루프\n- for 루프\n- foreach 루프\n- do-while 루프\n- break / continue 문장\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# While loop\n\nwhile 루프는 지정된 조건이 참인 경우에만 코드 블록을 반복하고 싶을 때 사용됩니다.\n\n파이썬에서는 while 루프를 다음과 같이 사용합니다:\n\n```python\ncount = 0\nwhile count \u003c 5:\n    print(f\"Count: {count}\")\n    count += 1\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- count은 0부터 시작합니다\n- 루프가 count가 5보다 작은 동안 계속 실행됩니다\n- 루프 내에서 count가 출력되고 증가합니다\n\nPHP에서는 다음과 같이 while 루프를 사용합니다:\n\n```php\n\u003c?php\n$count = 0;\nwhile ($count \u003c 5) {\n    echo \"Count: $count\\n\";\n    $count++;\n}\n?\u003e\n```\n\n- count가 0으로 초기화됩니다\n- 루프는 $count가 5보다 작은 동안 계속 실행됩니다\n- 루프 내에서 count가 출력되고 1씩 증가합니다\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n구문은 매우 유사하며, 로직은 정확히 같습니다.\n\n# for 루프\n\nfor 루프는 일반적으로 반복 횟수가 미리 알려진 경우에 사용됩니다. 두 언어 모두 구별되는 구문을 갖고 있습니다.\n\n파이썬에서:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nfor i in range(5):\n    print(f\"Iteration: {i}\")\n```\n\n- range(5) 함수는 0부터 4까지의 숫자를 생성합니다.\n- 이 범위 내 각 숫자마다 i가 출력됩니다.\n\nPHP에서:\n\n```php\n\u003c?php\nfor ($i = 0; $i \u003c 5; $i++) {\n    echo \"Iteration: $i\\n\";\n}\n?\u003e\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 루프는 $i를 0으로 초기화합니다.\n- $i가 5보다 작은 경우에만 실행됩니다.\n- 각 반복 후에 $i는 1씩 증가합니다.\n\nPHP는 for 루프에 대해 C 스타일 구문을 사용합니다. $i = 0은 for 루프가 실행하는 반복 횟수와 관계없이 한 번만 계산됩니다. $i ` 5는 각 반복의 시작부에서 계산되고, $i++은 각 반복의 끝에서 계산됩니다.\n\n재미있게도, 한 줄로 for 루프를 작성할 수 있지만, 하지 말아주세요. 코드는 실행되겠지만, 모든 해석기가 에러를 발생시킵니다.\n\n파이썬에서:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 표를 마크다운 형식으로 변경해보겠습니다.\n\n\n| Header One | Header Two |\n|------------|------------|\n| Row 1, Col 1 | Row 1, Col 2 |\n| Row 2, Col 1 | Row 2, Col 2 |\n\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n\u003c?php\nfor ($i = 1, $j = 0; $i \u003c= 10; $j += $i, print $i, $i++);\n?\u003e\n```\n\n# Foreach Loop\n\nThe foreach loop is used to iterate over arrays or collections only.\n\nIn Python, we don't have foreach loops, but we can mimic it using the in membership operator and a for loop like this:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```javascript\ncolors = [\"red\", \"green\", \"blue\"];\nfor color in colors:\n    print(f\"Color: {color}\")\n```\n\n- colors는 리스트입니다.\n- for 루프는 각 요소를 순회하며 color에 할당하고 콘솔에 인쇄합니다.\n\nPHP는 foreach 루프를 지원하며 for 루프와는 매우 다른 구문을 사용합니다.\n\n```php\n\u003c?php\n$colors = [\"red\", \"green\", \"blue\"];\nforeach ($colors as $color) {\n    echo \"Color: $color\\n\";\n}\n?\u003e\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- `$colors`은 배열입니다\n- 루프는 `$colors` 배열의 각 요소를 순회하며 현재 요소를 `$color`에 할당하고 콘솔에 출력합니다.\n\n만약 연관 배열(파이썬의 딕셔너리)을 순회하려면 다른 구문을 사용할 수 있습니다:\n\n```js\n\u003c?php\n$color = [\n    \"r\" =\u003e \"red\",\n    \"g\" =\u003e \"green\",\n    \"b\" =\u003e \"blue\",\n];\n\nforeach ($color as $key =\u003e $value) {\n    echo \"The $key is $value\\n\";\n}\n?\u003e\n\n// 결과:\n// The r is red\n// The g is green\n// The b is blue\n```\n\n# Do-While 루프\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nPHP에는 코드 블록이 한 번 이상 실행되도록 보장하는 do-while 루프가 있습니다. Python에는 내장 do-while 루프가 없지만 while 루프와 break 조건을 사용하여 유사한 효과를 얻을 수 있습니다.\n\nPython에서:\n\n```python\ncount = 0\nwhile True:\n    print(f\"Count: {count}\")\n    count += 1\n    if count \u003e= 5:\n        break\n```\n\n- while True 룹은 무한히 실행됩니다.\n- count가 5에 도달하면 break 문으로 루프를 수동으로 중단합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nPHP에서:\n\n```js\n\u003c?php\n$count = 0;\ndo {\n    echo \"Count: $count\\n\";\n    $count++;\n} while ($count \u003c 5);\n?\u003e\n```\n\n- 코드 블록이 먼저 실행됩니다\n- 그 후 $count \u003c 5 조건이 확인됩니다\n- 조건이 참인 동안 반복 실행됩니다\n\nwhile 및 do-while 루프의 주요 차이점은 각 반복에서 진실 식이 시작이 아닌 끝에서 확인된다는 점입니다. 이것이 첫 반복이 항상 보장되는 이유입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# break / continue 문\n\nPHP와 Python 모두 break 및 continue 문을 제공하여 반복문의 흐름을 제어할 수 있습니다.\n\n## break\n\nPython에서는 반복문을 종료하는 방법은 다음과 같습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\r\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nfor number in numbers:\n    if number \u003e 5:\n        break # 숫자가 5보다 크면 룹을 종료합니다.\n    print(f\"Number: {number}\")\r\n```\n\nPHP에서:\n\n```js\r\n\u003c?php\n$numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\nforeach ($numbers as $number) {\n    if ($number \u003e 5) {\n        break; // 숫자가 5보다 크면 룹을 종료합니다.\n    }\n    echo \"Number: $number\\n\";\n}\n?\u003e\r\n```\n\n추가로, PHP에서의 break는 선택적으로 숫자 인수를 허용하며, 이는 몇 개의 중첩된 룹을 탈출할지를 나타냅니다. 기본값은 1입니다. 두 룹을 동시에 탈출하는 방법에 대한 예시는 다음과 같습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n\u003c?php\n$matrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n];\n\n$target = 5;\n$found = false;\n\nforeach ($matrix as $row) {\n    foreach ($row as $value) {\n        if ($value == $target) {\n            echo \"Found target value $target. Breaking out of both loops.\\n\";\n            $found = true;\n            break 2; // Break out of both loops\n        }\n    }\n}\n\nif (!$found) {\n    echo \"Target value $target not found.\\n\";\n}\n?\u003e\n```\n\n이 코드는 매우 유용하네요! Python에 이 기능을 추가해야 할까요?\n\n## continue\n\nPython에서는 다음 반복으로 건너뛰는 방법이 있습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nfor number in numbers:\n    if number % 2 == 0:\n        continue # 짝수를 건너뛰기\n    print(f\"Number: {number}\")\n```\n\nPHP에서 동일한 기능:\n\n```js\n\u003c?php\n$numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\nforeach ($numbers as $number) {\n    if ($number % 2 == 0) {\n        continue; // 짝수를 건너뛰기\n    }\n    echo \"Number: $number\\n\";\n}\n?\u003e\n```\n\ncontinue 문은 중첩된 루프의 끝까지 건너뛰어야 하는 수준을 나타내는 선택적 숫자 인수를 받을 수도 있습니다. 기본 값은 1이며, 따라서 현재 루프의 끝으로 건너뛰게 됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n\u003c?php\n$matrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n];\n\nforeach ($matrix as $row) {\n    foreach ($row as $value) {\n        if ($value % 2 == 0) {\n            echo \"짝수 $value를 만나면 해당 행 건너뛰기.\\n\";\n            continue 2; // 해당 행의 나머지 부분을 건너뛰고 외부 루프의 다음 행으로 이동\n        }\n        echo \"값: $value\\n\";\n    }\n}\n?\u003e\n\n// 출력:\n// 값: 1\n// 짝수 2를 만나면 해당 행 건너뛰기.\n// 짝수 4를 만나면 해당 행 건너뛰기.\n// 값: 7\n// 짝수 8를 만나면 해당 행 건너뛰기.\n```\n\n# 결론\n\n루프는 프로그래밍에서 반복 작업에 필수적입니다. PHP 8 및 Python 3은 각기 다른 문법과 흐름을 가진 다양한 루프 구조를 제공합니다:\n\n- while 루프: 두 언어에서 유사하며 조건에 기반한 반복에 사용됩니다.\n- for 루프: Python에서는 range 함수를 사용하여 더 간단하며, PHP에서는 초기화자, 조건 및 증가자를 사용합니다.\n- foreach 루프: PHP에서 직접 배열에 사용 가능하며, Python에서는 for 루프 기능의 일부입니다.\n- do-while 루프: PHP에서 기본적으로 제공되며, Python에서는 while True 루프와 중단 조건을 사용하여 시뮬레이션할 수 있습니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 만약 이 기사를 읽는 것을 즐기셨거나 도움이 되었다면, 아래와 같이 할 수 있어요:\n\n- 20번 클랩을 눌러주세요\n- 어떻게 도움이 되었는지 댓글을 남겨주세요\n- 파이썬, PHP 및 AI 기사를 더 보려면 팔로우해주세요\n\n여러분의 피드백과 참여가 저에게 글쓰고 가치 있는 콘텐츠를 공유하도록 격려해줍니다. 이 여정의 한 부분이 되어 주셔서 감사합니다!\n\n또한 저를 LinkedIn에서도 만날 수 있어요.","ogImage":{"url":"/TIL/assets/img/2024-07-15-PHPforPythonDevelopersPart5Loops_0.png"},"coverImage":"/TIL/assets/img/2024-07-15-PHPforPythonDevelopersPart5Loops_0.png","tag":["Tech"],"readingTime":12},{"title":"파이썬으로 밀리초를 시간, 분, 초로 변환하는 방법","description":"","date":"2024-07-15 00:01","slug":"2024-07-15-ConvertingMillisecondstoHoursMinutesandSecondsinPython","content":"\n\n안녕하세요!\n\n시간 변환은 프로그래밍에서 흔한 작업 중 하나로, 기본 산술 연산과 문자열 처리에 대한 기본적인 이해를 개발하는 데 도움이 됩니다. 이 글에서는 Python을 사용하여 밀리초를 시간, 분, 초로 변환하는 방법을 살펴보겠습니다. 이 작업을 통해 루프, 조건문 및 함수 설계에 대한 지식을 확립할 수 있을 겁니다.\n\n변환 이해하기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n코드를 시작하기 전에 기본적인 시간 단위를 이해해보겠습니다:\n\n- 1 시간 = 3600000 밀리초\n- 1 분 = 60000 밀리초\n- 1 초 = 1000 밀리초\n\n솔루션 디자인\n\n주어진 밀리초 수를 시간, 분 및 초로 변환하는 것이 목표입니다. 다음은 단계별 접근 방식입니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 입력 유효성 검사: 입력이 0보다 큰 유효한 숫자인지 확인합니다.\n- 변환 로직: 밀리초를 시간, 분 및 초로 분해합니다.\n- 출력 형식 지정: 결과를 읽기 쉬운 형식으로 표시하며, 0이 아닌 시간 단위만 표시합니다.\n- 사용자 상호 작용: 사용자가 \"exit\"을 입력할 때까지 입력을 요청하는 루프를 구현합니다.\n\n구현\n\n시간 변환기 코드를 시작해보겠습니다:\n\n```js\ndef convert_milliseconds(ms):\n    if ms \u003c 1000:\n        return f\"방금 {ms} 밀리초\"\r\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\n    hours = ms // 3600000\n    ms %= 3600000\n    minutes = ms // 60000\n    ms %= 60000\n    seconds = ms // 1000\n    result = []\n    if hours \u003e 0:\n        result.append(f\"{hours} hour/s\")\n    if minutes \u003e 0:\n        result.append(f\"{minutes} minute/s\")\n    if seconds \u003e 0:\n        result.append(f\"{seconds} second/s\")\n    return ' '.join(result)\ndef main():\n    print(\"### 이 프로그램은 밀리초를 시간, 분, 초로 변환합니다 ###\")\n    print('(프로그램을 종료하려면 \"exit\"을 입력하세요)')\n    while True:\n        user_input = input(\"밀리초를 입력하세요 (0보다 커야 합니다): \")\n        if user_input.lower() == \"exit\":\n            print(\"프로그램 종료... 안녕히 가세요\")\n            break\n        try:\n            ms = int(user_input)\n            if ms \u003e 0:\n                print(convert_milliseconds(ms))\n            else:\n                print(\"올바르지 않은 입력입니다 !!!\")\n        except ValueError:\n            print(\"올바르지 않은 입력입니다 !!!\")\nif __name__ == \"__main__\":\n    main()\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 사용자 상호 작용:\n\n  - 주요 기능은 사용자 입력을 처리하고 유효성을 검사합니다.\n  - 사용자에게 밀리초를 요청하고 유효한지 확인한 후 convert_milliseconds 함수를 사용하여 변환합니다.\n  - 사용자가 \"exit\"을 입력할 때까지 루프가 계속됩니다.","ogImage":{"url":"/TIL/assets/img/2024-07-15-ConvertingMillisecondstoHoursMinutesandSecondsinPython_0.png"},"coverImage":"/TIL/assets/img/2024-07-15-ConvertingMillisecondstoHoursMinutesandSecondsinPython_0.png","tag":["Tech"],"readingTime":3},{"title":"파이썬 API를 사용한 주식 순위를 위한 기본적 분석 방법","description":"","date":"2024-07-14 23:59","slug":"2024-07-14-FundamentalAnalysisforrankingStockswithPythonAPI","content":"\n\n이 기사에서는 기초 및 주식 세부 정보에 따라 주식을 순위로 나열할 것입니다. 이 접근 방식은 기존 기사 \"Python API를 사용한 기초 주식 분석\"에서 주식 그룹의 평균과 표준 편차를 기반으로 비율에 대한 점수 방법을 적용합니다.\n\n면책 조항: 여기서 제공된 정보는 정보 목적으로만 제공되며 개인 재정, 투자 또는 기타 조언을 의도한 것이 아닙니다.\n\n이 기사에서 사용되는 주요 비율은 다음과 같습니다:\n\n- EPS (주당순이익) — 회사 이익 중 각 주식에 할당된 부분\n- PE (주가 수익 비율) — 회사의 주가와 주당 순이익 간 관계. 투자자가 해당 섹터의 다른 종목에 비해 주식이 저평가되었는지 또는 고평가되었는지 판단하는 데 도움이 됩니다.\n- PEG (예상 이익 성장률) — 주식의 P/E를 예상된 12개월 수익 성장률로 나눈 것. 일반적으로 1보다 낮은 PEG는 좋은 신호이며, 2보다 높은 PEG는 주식이 과도 가격화될 수 있음을 나타냅니다.\n- PB (주가순자산가치비율) — 1의 비율은 회사의 주식이 순자산가치에 준하는 가격에 거래되고 있음을 나타냅니다. 1보다 높은 P/B는 회사가 순자산가치에 프리미엄을 지불하고 있음을 시사하며, 1보다 낮은 비율은 회사 자산에 비해 저평가된 주식을 나타낼 수 있습니다.\n- ROE (자기자본이익률) — 회사가 자산을 이용하여 이익을 창출하는 데 효과적으로 활용하는 방법을 투자자에게 제공합니다. 더 높은 ROE는 주주 자본을 더 효과적으로 활용하고 주식 수요 증가 및 미래 이익 증가, 그리고 주가 상승으로 이어질 수 있음을 나타냅니다.\n- ROCE (총 자본 대지수이익률) — 모든 자본을 기준으로 회사의 수익성을 측정합니다.\n- FCFY (재무건전도 비율) — 회사가 주당 기대하는 영업현금흐름과 주당 시장가치를 비교하는 지표. 낮은 비율은 덜 매력적인 투자 기회를 나타냅니다.\n- D2E (부채대자본비) — 회사의 총부채를 자기자본과 비교합니다.\n- CR (유동비율) — 회사가 유동자산(1년 이내 지급 예정 금액)으로 현재 부채를 갚을 수 있는 능력을 측정합니다. 비율이 높을수록 회사의 유동성이 더 좋습니다.\n- QR (당좌비율) — 회사가 재고를 판매하거나 추가 자금을 조달하지 않고 현재 부채를 갚을 수 있는 능력을 측정합니다.\n- 자산TO (자산회전율) — 회사 자산이 매출이나 수익을 생성하는 효율성을 측정합니다.\n- DY (배당수익률) — 회사가 매년 배당으로 지급하는 금액을 주가에 상대적으로 측정한 비율. 이는 주식 투자의 배당수익률을 추정한 지표입니다.\n- 베타 — 주식의 시장 전체 대비 변동성을 측정하는 지표. 시장보다 더 많이 변동하는 주식은 1.0보다 높은 베타를 가집니다. 시장보다 변동성이 낮은 주식은 1.0보다 낮은 베타를 가집니다.\n- 52주 범위 — 52주 저점에 가까운 주식과 52주 고점에 가까운 주식을 나타내는 시각화 지표. 예를 들어, 90%는 현재 가격이 52주 고점에 매우 가깝다는 것을 나타냅니다.\n- 점수 — 각 주식의 비율 점수 합계\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 데이터 접근\n\n우리는 yfinance API를 활용하여 Yahoo Finance에서 데이터를 수집할 것입니다. 티커의 info 구성 요소는 여러 구성 요소 중 하나인 (예: 손익 계산서, 현금 흐름 등) 가장 많은 비율들을 제공할 것입니다.\n\n우리는 finviz screener를 웹 스크레이핑하여 관련 주식 심볼 목록을 얻을 것입니다. 연구가 동일 산업의 이상적으로 비슷한 주식 그룹에서 수행되어야 합니다.\n\n코드는 GitHub의 Jupyter 노트북으로 사용 가능합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Python 라이브러리\n\n다음은 필수 Python 라이브러리입니다:\n\n- yfinance — 금융 시장 데이터에 접근하기 위함\n- pandas — 데이터 프레임\n- numpy — np.nan을 사용함\n- requests — http 요청을 만들기 위함\n- BeautifulSoup — 웹 스크래핑에 사용됨\n- statistics — 표준편차와 평균을 계산하기 위함\n\n## 라이브러리 가져오기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\n# 주식 정보 읽기\nimport yfinance as yf\n\n# DataFrame을 위해\nimport pandas as pd\nimport numpy as np\n\n# finviz를 파싱하기 위해\nimport requests\nfrom bs4 import BeautifulSoup\n\n# 표준 편차와 평균을 계산하기 위해\nimport statistics\n```\n\n## 비율 카테고리\n\n비율은 두 그룹으로 나뉩니다: 카테고리 1에는 낮은 값을 선호하는 비율들이 포함되고, 카테고리 2에는 높은 값을 선호하는 비율들이 포함됩니다. 주가 이익비율 (P/E)은 카테고리 1의 예시 비율입니다. 낮은 P/E 비율은 회사가 저렴하거나 역사적 패턴과 비교하여 잘 수행하고 있다는 것을 시사할 수 있습니다. 현금비율 (CR)은 카테고리 2의 예시로, 높은 CR 점수가 바람직합니다. 우리는 거래가 덜 변동적인 회사에 더 관심이 있으므로 베타 점수는 카테고리 1에 속합니다. 그러나 만약 높은 변동성을 가진 회사에 더 관심이 있다면 카테고리 2로 이동할 수 있습니다.\n\n```python\n# 카테고리 1 비율 점수 - 낮을수록 더 좋음\nCAT1_RATIOS = ['D2E', 'PEG', 'PE fwd', 'PB', 'Beta']\n\n# 카테고리 2 비율 점수 - 높을수록 더 좋음\nCAT2_RATIOS = ['ROCE', 'ROE', 'FCFY', 'CR', 'QR', 'Asset TR', 'EPS fwd']\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 주식 심볼\n\n이전에 언급한대로, 관련 주식 심볼 목록을 얻기 위해 finviz 스크리너를 사용할 것입니다. 아래 코드는 예를 들어, 시가총액이 20억 달러 이상인 \"관리되는 가스\" 산업의 \"유틸리티\" 섹터 기업을 위한 필터를 활용하는 것입니다. 요청 매개변수 \"f\"에는 아래와 같이 필터 값을 받습니다.\n\n```js\ndef get_symbols():\n    req = requests.get('https://finviz.com/screener.ashx',\n        params={\n            'v': '111',\n            'f': 'cap_midover,ind_utilitiesregulatedgas',\n            'o': 'company',\n        },\n        headers={\n            'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',\n        })\n    # BeautifulSoup 객체 생성\n    soup = BeautifulSoup(req.text, 'html.parser')\n    \n    # 관심 있는 테이블\n    table = soup.find('table', class_='styled-table-new is-rounded is-tabular-nums w-full screener_table')\n    # 심볼 수집 배열\n    symbols = []\n    for i, row in enumerate(table.find_all('tr')):\n        # 헤더 행은 건너뛰기\n        if i != 0:\n            # 행에서 반복\n            for j, td in enumerate(row.find_all('td')):\n                # 심볼은 두 번째 열에 있음\n                if j == 1:\n                    symbols.append(td.text.strip())\n                    break\n    return symbols\n```\n\n## 주식 심볼 가져오기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 유틸리티 메소드를 호출하여 symbols 변수를 채우세요.\n\n```js\nsymbols = get_symbols()\n```\n\nget_symbols 함수를 사용하지 않고 이미 주식 심볼 집합을 알 경우 symbols 변수를 초기화할 수도 있습니다. 아래와 같이 표시됩니다:\n\n```js\nsymbols = ['ATO', 'NI', ]\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n## 비율 계산하기\n\n먼저 유틸리티를 정의하여 yfinance API의 info 메서드를 활용하여 비율을 계산하고 채워넣습니다.\n\n```python\ndef populate_with_info(data, stock_info):\n    # print(stock_info)\n    data['Symbol'].append(stock_info['symbol'])\n    data['Name'].append(stock_info['longName'])\n    \n    # 숫자를 가독성 좋은 형식으로 변환합니다\n    data['Market Cap'].append(human_format(stock_info['marketCap']))\n    data['Price'].append(stock_info['currentPrice'])\n\n    # 사용 가능한 지표가 없을 수도 있습니다; 그런 경우 NaN을 사용합니다\n    \n    # 가치 평가 비율\n    \n    if 'priceToBook' in stock_info:\n        data['PB'].append(stock_info['priceToBook'])\n    else:\n        data['PB'].append(np.nan)\n    \n    if 'forwardEps' in stock_info:\n        data['EPS fwd'].append(stock_info['forwardEps'])\n    else:\n        data['EPS fwd'].append(np.nan)\n        \n    if 'forwardPE' in stock_info:\n        data['PE fwd'].append(stock_info['forwardPE'])\n    else:\n        data['PE fwd'].append(np.nan)\n        \n    if 'pegRatio' in stock_info:\n        data['PEG'].append(stock_info['pegRatio'])\n    else:\n        data['PEG'].append(np.nan)\n        \n    # 신뢰성 재무 비율\n    \n    if 'debtToEquity' in stock_info:\n        data['D2E'].append(stock_info['debtToEquity'])\n    else:\n        data['D2E'].append(np.nan)\n\n    # 수익성 비율\n    \n    if 'returnOnEquity' in stock_info:\n        data['ROE'].append(stock_info['returnOnEquity'])\n    else:\n        data['ROE'].append(np.nan)\n    \n    if ('freeCashflow' in stock_info) and ('marketCap' in stock_info):\n        fcfy = (stock_info['freeCashflow']/stock_info['marketCap']) * 100\n        data['FCFY'].append(round(fcfy, 2))\n    else:\n        data['FCFY'].append(np.nan)\n\n    # 유동성 비율\n    \n    if 'currentRatio' in stock_info:\n        data['CR'].append(stock_info['currentRatio'])\n    else:\n        data['CR'].append(np.nan)\n\n    if 'quickRatio' in stock_info:\n        data['QR'].append(stock_info['quickRatio'])\n    else:\n        data['CR'].append(np.nan)\n\n    # 기타 정보 (비 비율)\n    \n    if 'dividendYield' in stock_info:\n        data['DY'].append(stock_info['dividendYield']*100)\n    else:\n        data['DY'].append(0.0)\n\n    if 'beta' in stock_info:\n        data['Beta'].append(stock_info['beta'])\n    else:\n        data['Beta'].append(np.nan)\n\n    if 'fiftyTwoWeekLow' in stock_info:\n        data['52w Low'].append(stock_info['fiftyTwoWeekLow'])\n    else:\n        data['52w Low'].append(np.nan)\n        \n    if 'fiftyTwoWeekHigh' in stock_info:    \n        data['52w High'].append(stock_info['fiftyTwoWeekHigh'])\n    else:\n        data['52w High'].append(np.nan)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n비율을 찾을 수 없는 경우, NaN으로 사전에 추가됩니다. 비율이 NaN으로 설정된 주식은 제거됩니다. 또한 이 방법은 숫자를 사람이 읽을 수 있는 형식으로 변환하는 유틸리티 메서드를 활용합니다. 예를 들어, 5B(십억), 5M(백만) 등으로 표시됩니다.\n\n```js\ndef human_format(num):\n    num = float('{:.3g}'.format(num))\n    magnitude = 0\n    while abs(num) \u003e= 1000:\n        magnitude += 1\n        num /= 1000.0\n    return '{}{}'.format('{:f}'.format(num).rstrip('0.'), ['', 'K', 'M', 'B', 'T'][magnitude])\n```\n\n마지막으로, 재무상태표와 손익계산서를 사용하여 비율을 계산하는 추가 기법 집합이 있습니다.\n\n```js\ndef roce(ticker):\n    income_stm = ticker.income_stmt\n    ebit = income_stm.loc['EBIT'].iloc[0]\n    bs = ticker.balance_sheet\n    return ebit/(bs.loc['Total Assets'].iloc[0]-bs.loc['Current Liabilities'].iloc[0])\n\ndef asset_turnover_ratio(ticker):\n    df_bs = ticker.balance_sheet\n    y0, y1 = df_bs.loc['Total Assets'].iloc[0], df_bs.loc['Total Assets'].iloc[1]\n    avg_asset = (y0 + y1)/2\n    tot_rvn_y0 = ticker.income_stmt.loc['Total Revenue'].iloc[0]/avg_asset\n    return tot_rvn_y0\n\ndef investory_turnover_ratio(ticker):\n    df_bs = ticker.balance_sheet\n    y0, y1 = df_bs.loc['Inventory'].iloc[0], df_bs.loc['Inventory'].iloc[1]\n    avg_inventory = (y0 + y1)/2\n    return ticker.income_stmt.loc['Cost Of Revenue'].iloc[0]/avg_inventory\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 지표 수집\n\n주식 심볼에 대한 각 지표를 딕셔너리에 추가해 보겠습니다.\n\n```js\n# 나중에 DF를 만들기 위한 데이터 수집 딕셔너리\ndata = {\n    'Symbol': [],\n    'Name': [],\n    'Market Cap': [],\n    'EPS fwd': [],\n    'PE fwd': [],\n    'PEG': [],\n    'PB': [],\n    'ROE' : [],\n    'ROCE' : [],\n    'FCFY' : [],\n    'D2E' : [],\n    'CR' : [],\n    'QR' : [],\n    'Asset TR': [],\n    'DY' : [],\n    'Beta': [],\n    'Price': [],\n    '52w Low': [],\n    '52w High': []\n    }\nindustry = ''\n\nfor symbol in symbols:\n    ticker = yf.Ticker(symbol)\n    if not industry:\n        industry = ticker.info['industry']\n    else:\n        industry_current = ticker.info['industry'] \n        if industry_current != industry:\n            print(f'다른 산업 {industry_current}을(를) 만났습니다, 이전 산업 {industry}입니다. 중단합니다.')\n            break        \n    populate_with_info(data, ticker.info)\n    data['ROCE'].append(roce(ticker))\n    data['Asset TR'].append(asset_turnover_ratio(ticker))\n```\n\n이전에 언급한대로, 이 방법에는 현재 주식의 산업이 이전 주식의 산업과 다른지 간단히 확인하는 절차가 포함되어 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## DataFrame 생성하기\n\n```js\n# 사전을 사용하여 DF 생성\ndf = pd.DataFrame(data)\n\n# NaN 값을 가진 주식 저장\ndf_exceptions = df[df.isna().any(axis=1)]\n\n# NaN 값을 가진 주식 제거\ndf = df.dropna()\n\n# NaN 값을 가진 행을 삭제한 후 인덱스 재설정\ndf.reset_index(drop=True, inplace=True)\n\n# 52주간 가격 범위 추가\ndf['52주 범위'] = ((df['가격'] - df['52주 최저가']) / (df['52주 최고가'] - df['52주 최저가'])) * 100\n\ndf_exceptions\n```\n\nNaN으로 설정된 비율이 있는 주식은 제거되고, 예외 DataFrame에 저장됩니다. 마지막으로 52주 가격 범위가 포함될 것입니다.\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-FundamentalAnalysisforrankingStockswithPythonAPI_0.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\"그리고 비예외 주식에 대한 결과는:\n\n![Fundamental Analysis](/TIL/assets/img/2024-07-14-FundamentalAnalysisforrankingStockswithPythonAPI_1.png)\n\n## 점수\n\n다음 단계는 원시 데이터에 점수를 적용하는 것입니다.\"\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ndef score(values, value, cat) -\u003e int:\n    '''\n    카테고리에 따라 표준 편차와 평균을 기반으로 점수를 계산합니다. 낮은 값을 선호하는 PE와 같은 비율의 경우, 다음과 같이 점수가 계산됩니다:\n    1. 주어진 PE가 -1 표준 편차와 평균 사이에 있는 경우 1점 반환\n    2. 주어진 PE가 -2 표준 편차와 -1 표준 편차 사이에 있는 경우 2점 반환\n    3. PE가 -2 표준 편차를 벗어나는 경우 3점 반환\n    4. 주어진 PE가 1 표준 편차와 평균 사이에 있는 경우 -1점 반환\n    5. 주어진 PE가 +1 표준 편차와 +2 표준 편차 사이에 있는 경우 -2점 반환\n    6. 주어진 PE가 +2 표준 편차를 벗어나는 경우 -3점 반환\n\n    높은 값을 선호하는 ROE와 같은 비율의 경우, 다음과 같이 점수가 계산됩니다:\n    1. 주어진 ROE가 평균과 +1 표준 편차 사이에 있는 경우 1점 반환\n    2. 주어진 ROE가 +1 표준 편차와 +2 표준 편차 사이에 있는 경우 2점 반환\n    3. ROE가 +2 표준 편차를 벗어나는 경우 3점 반환\n    4. 주어진 ROE가 -1 표준 편차와 평균 사이에 있는 경우 -1점 반환\n    5. 주어진 ROE가 -1 표준 편차와 -2 표준 편차 사이에 있는 경우 -2점 반환\n    6. 주어진 ROE가 -2 표준 편차를 벗어나는 경우 -3점 반환\n\n    Parameters\n    ----------\n    values : 값들의 목록\n    value: 평균, 1 표준 편차, -1 표준 편차, 2 표준 편차 또는 -2 표준 편차 내에 있는지 확인할 값\n    cat: 카테고리 유형, 유효한 값은 1 또는 2입니다.\n        \n    Returns\n    -------\n    score: 주어진 'value'에 대한 점수\n    '''\n    \n    std = statistics.stdev(values)\n    mean = statistics.mean(values)\n\n    if cat == 1:\n        if (mean + (-1 * std)) \u003c value \u003c= mean:\n            return 1\n        elif (mean + (-2 * std)) \u003c value \u003c= (mean + (-1 * std)):\n            return 2\n        elif value \u003c= (mean + (-2 * std)):\n            return 3\n        elif mean \u003c value \u003c= (mean + (1 * std)):\n            return -1\n        elif (mean + (1 * std)) \u003c value \u003c= (mean + (2 * std)):\n            return -2\n        else:\n            return -3\n    else:\n        if mean \u003c= value \u003c (mean + (1 * std)):\n            return 1\n        elif (mean + (1 * std)) \u003c= value \u003c (mean + (2 * std)):\n            return 2\n        elif value \u003e= (mean + (2 * std)):\n            return 3\n        elif (mean + (-1 * std)) \u003c= value \u003c mean:\n            return -1\n        elif (mean + (-2 * std)) \u003c= value \u003c (mean + (-1 * std)):\n            return -2\n        else:\n            return -3\n```\n\n요약하면 다음과 같이 카테고리 1의 비율에 제공되는 값에 대해 다음 점수가 반환됩니다: (평균 - 1 * 표준 편차)과 평균 사이에 비율이 있는 경우 1; (평균 - 2 * 표준 편차)와 (평균 - 1 * 표준 편차) 사이에 비율이 있는 경우 2; (평균 - 2 * 표준 편차)보다 작은 경우 3; 그 반대 경우에는 음수 값이 반환됩니다. 카테고리 2도 비슷한 절차를 따르지만 반대 방향으로 작동합니다. 이러한 점수는 어느 정도 임의적이며, 이상값은 최대 또는 최소 점수를 받습니다. 이상값으로 인한 편향을 제거하려면, 이상값에 대한 점수를 조정하여, 예를 들어 평균 - 2 * 표준 편차보다 낮은 비율의 경우 0을 반환하는 등의 조치를 취할 수 있습니다.\n\n점수 부여를 적용하고, 두 카테고리에 대해 제공된 각 비율에 대한 점수를 합산하는 열을 추가합니다.\n\n```js\ndf_score = df.copy()\n\nfor col in CAT1_RATIOS:\n    for index, value in df[col].items():\n        # print(f'{col} - {index} - {value}')\n        df_score.loc[index, col] = score(df[col], value, 1)\n\nfor col in CAT2_RATIOS:\n    for index, value in df[col].items():\n        # print(f'{col} - {index} - {value}')\n        df_score.loc[index, col] = score(df[col], value, 2)\n\n# 총점을 얻기 위해 순위 점수를 추가\ndf_score['Score'] = df_score[CAT1_RATIOS+CAT2_RATIOS].sum(axis=1)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ndef make_pretty(styler):\n    # 열 형식 지정\n    styler.format({'EPS fwd': '{:.0f}', 'PE fwd': '{:.0f}', 'PEG': '{:.0f}', 'FCFY': '{:.0f}', 'PB': '{:.0f}', 'ROE': '{:.0f}',\n                   'ROCE': '{:.0f}', 'D2E': '{:.0f}', 'CR': '{:.0f}', 'QR': '{:.0f}', 'Asset TR': '{:.0f}', 'DY': '{:.2f}%',\n                   'Beta': '{:.0f}', '52w Low': '${:.2f}', 'Price': '${:.2f}', '52w High': '${:.2f}', '52w Range': '{:.2f}%', 'Score': '{:.0f}'\n                  })\n\n    # 바 시각화 설정\n    styler.bar(subset=['52w Range'], align=\"mid\", color=[\"salmon\", \"cornflowerblue\"])\n\n    # 그리드\n    styler.set_properties(**{'border': '0.1px solid black'})\n\n    # 배경 그라데이션 설정\n    for ratio in CAT1_RATIOS:\n        styler.background_gradient(subset=[ratio], cmap='RdYlGn', gmap=-df[ratio])\n    for ratio in CAT2_RATIOS:\n        styler.background_gradient(subset=[ratio], cmap='RdYlGn')\n    styler.background_gradient(subset=['Score'], cmap='PiYG')\n    \n    # 인덱스 숨기기\n    styler.hide(axis='index')\n\n    # 일부 열에 대해 왼쪽 텍스트 정렬\n    styler.set_properties(subset=['Symbol', 'Name'], **{'text-align': 'left'})\n    styler.set_properties(subset=CAT1_RATIOS + CAT2_RATIOS + ['Market Cap', 'Score'], **{'text-align': 'center'})\n\n    return styler\n```\n\n마지막으로, DataFrame에 스타일을 추가합니다:\n\n```js\n# DF에 테이블 캡션 및 스타일 추가\ndf_score.style.pipe(make_pretty).set_caption(f'{industry} 주식 스크리너').set_table_styles(\n    [{'selector': 'th.col_heading', 'props': 'text-align: center'},\n     {'selector': 'caption', 'props': [('text-align', 'center'),\n                                       ('font-size', '11pt'), ('font-weight', 'bold')]}])\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/TIL/assets/img/2024-07-14-FundamentalAnalysisforrankingStockswithPythonAPI_2.png)\n\n시가총액이 20억 달러 이상인 ATO와 SR은 “Regulated Gas” 산업 중 모든 주식 중에서 가장 높은 점수를 받은 두 가지 유틸리티 섹터 주식입니다. 그러나 ATO의 가격은 현재 52주 최고가에 더 가깝고, SR의 가격은 52주 최저가에 더 가깝습니다.\n\n여러 비율이 현재 주식 가격에 의존하기 때문에 결과는 노트북을 호출하는 시점에 따라 변할 수 있습니다.\n\n## 결론\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 기사에서는 기초 분석 기반의 주식 순위 결정 방법을 설명하며, 이 방법은 주식 그룹의 평균과 표준 편차를 기반으로 각 비율에 점수를 할당합니다.\n\n분석 목적상, 대부분의 비율은 비슷한 주식 그룹 내에서만 의미가 있는 경우가 많으므로 관련된 주식 그룹을 선택하는 것이 중요합니다.\n\n평가 시스템이 임의적이지만, 이 포스트가 가중 점수와 같은 다른 점수 시스템을 탐구하는 기초를 제시한다고 생각합니다.\n\n정보가 유익하게 느껴졌길 바라며, 피드백을 소중히 여깁니다.","ogImage":{"url":"/TIL/assets/img/2024-07-14-FundamentalAnalysisforrankingStockswithPythonAPI_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-FundamentalAnalysisforrankingStockswithPythonAPI_0.png","tag":["Tech"],"readingTime":19},{"title":"현재 핫한 GitHub 프로젝트 11선","description":"","date":"2024-07-14 23:58","slug":"2024-07-14-11TrendingGithubProjects","content":"\n\n오픈 소스 프로젝트는 현대 소프트웨어 생태계의 중요한 부분입니다. 이러한 이니셔티브는 소스 코드를 자유롭게 볼 수 있고 수정하고 배포할 수 있는 곳으로, 기술 산업 전반에 걸쳐 혁신과 협력을 촉진합니다.\n\n오픈 소스는 유용할 뿐만 아니라 필수적입니다. 이는 투명성을 촉진하여 동료 검토와 보안 취약성의 신속한 식별을 가능하게 합니다. 오픈 소스는 공유 지식의 문화를 조성하여 개발자들이 서로의 작업에서 배우고 발전할 수 있도록 돕습니다.\n\n## 추가로 읽어볼 내용:\n\n기본 기술 습득\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n6월 말을 위한 8가지 GitHub 프로젝트\n\n새롭고 인기 있는 엘릭서 저장소들\n\n인기있는 9가지 GitHub 프로젝트\n\n그리고 구독이 무료인 AI 뉴스레터 BrainScriblr도 운영 중이에요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저가 작성한 AI 노트 앱을 다룬 포스트가 있어요.\n\n## Graphrag\n\nMicrosoft Research에서 개발한 GraphRAG는 대규모 언어 모델(LLM)의 검색 및 생성 능력을 향상시키는 고급 검색-증강 생성(RAG) 기술입니다. 이는 지식 그래프를 활용하여 생성된 응답의 품질과 관련성을 개선합니다.\n\n벡터 데이터베이스에만 의존하는 대신, GraphRAG는 구조화된 지식 그래프를 활용하여 생성된 응답의 품질과 관련성을 개선합니다. 이는 텍스트 추출, 네트워크 분석, LLM 프롬프팅 및 요약을 통합한 단일 시스템으로, 복잡한 데이터 분석 및 자연어 처리 애플리케이션에 강력한 도구로 작용합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nGraphRAG의 중요한 기능 중 하나는 텍스트에서 계층적 지식 그래프를 구축하는 것이며, Leiden 알고리즘과 같은 계층적 클러스터링 기술을 사용하여 정보를 요약하며, 질의 시간에 LLM에게 환경적으로 풍부하고 관련성 높은 정보를 제공하는 향상된 검색 기능이 있습니다.\n\n이 접근 방식은 기본 RAG에 비해 상당한 장점을 제공합니다. 개선된 환경 이해력, 응답에 대한 증거 출처, 전체 데이터 질병 추론 수행 능력 등이 있습니다. 이는 비공개 데이터 집합을 분석하고 복잡한 질문을 처리하는 데 유용하며, 고급 챗봇, 가상 어시스턴트 및 상세한 데이터 분석 도구에 적합합니다.\n\n## Claude 엔지니어\n\nClaude 엔지니어는 Anthropic의 Claude-3.5-Sonnet 모델을 활용하는 명령줄 인터페이스(CLI)로, 소프트웨어 개발 작업을 보조합니다. Anthropic에 의해 개발되었으며, 상호작용형 채팅, 파일 시스템 작업, 웹 검색, 구문 강조, 프로젝트 구조 관리 및 코드 분석과 같은 기능이 통합되어 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nClaude Engineer는 다양한 기능을 강력한 CLI로 통합하여 작업 흐름을 최적화하고 생산성을 향상시키며 전반적인 소프트웨어 개발 경험을 개선합니다.\n\n## TorToiSe\n\nTortoise TTS는 neonbjb에 의해 개발된 오픈 소스 텍스트 음성 변환(TTS) 시스템입니다. 이 도구는 강력한 다중 음성 기능을 갖추어 매우 현실적이고 표현력이 풍부한 음성 합성을 생성하도록 설계되었습니다.\n\n이 시스템은 자동 회귀 및 확산 모델의 조합을 활용하여 텍스트를 자연스러운 음성으로 변환하며, 다양한 억양과 억양에 중점을 두고 있습니다. 또한 Tortoise TTS는 여러 언어를 지원하며 각각의 언어에 대해 많은 훈련 데이터가 필요하지 않고도 다양한 목소리를 모방할 수 있어 다양한 응용 프로그램에 유연하게 활용할 수 있는 도구입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nTortoise TTS의 주요 기능은 제로샷 다중 음성 기능, 현실적인 프로소디와 억양, 몇 가지 예시를 기반으로 한 음성 클론 등이 있습니다. 또한 프로젝트 구조의 생성 및 관리를 지원하여 이 도구의 다재다능성을 향상시킵니다. Tortoise TTS는 높은 품질의 음성 합성으로 알려져 있지만, 처리 파이프라인이 복잡하기 때문에 병렬 TTS 모델에 비해 비교적 느립니다.\n\n## Omniparse\n\nOmniparse는 비구조적 데이터를 구조화된 형식으로 변환하여 AI 응용 프로그램에 최적화된 오픈 소스 플랫폼입니다.\n\n중요한 기능:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 다양한 데이터 유형 (문서, 이미지, 오디오, 비디오, 웹 페이지) 처리합니다.\n- 데이터 개인 정보 보호를 위해 로컬에서 작동합니다.\n- Docker 및 Skypilot을 통해 배포할 수 있습니다.\n- 사용자 친화적인 Gradio 인터페이스를 제공합니다.\n- OCR, 레이아웃 감지 및 전사용 고급 모델을 사용합니다.\n\n기능에는 테이블 추출, 이미지 캡션, 오디오/비디오 전사, 웹 크롤링, 스키마 기반 변환이 포함됩니다. 문서 처리, 미디어 분석, 웹 데이터 추출 및 AI 모델 준비에 이상적입니다.\n\nOmniparse는 Linux 시스템에 설치하고 Docker를 사용하여 실행할 수 있습니다. 생성적 AI 및 대규모 언어 모델이 포함된 응용 프로그램에 특히 유용합니다.\n\n![이미지](/TIL/assets/img/2024-07-14-11TrendingGithubProjects_0.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## OmniParser\n\n안녕하세요! OmniParser는 다양한 데이터 형식을 처리하기 위한 Go 언어의 오픈 소스 ETL 라이브러리입니다.\n\n중요한 기능:\n\n- 다양한 입력 형식 지원 (CSV, XML, EDI, JSON 등)\n- 성능을 위한 원시 Go 구현\n- 효율적인 처리를 위한 스트리밍 파서\n- 스키마 기반 변환\n- 복잡한 변환을 위한 사용자 정의 함수\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아주 유용한 내용이에요! 데이터 통합, ETL 프로세스, 데이터 정리, 그리고 API 데이터 처리에 활용할 수 있어요.\n\n이 프로젝트는 포괄적인 문서와 커뮤니티 기여를 환영해요.\n\n## Autogroq\n\nAutoGroq은 Autogen 및 CrewAI와 호환되는 플랫폼을 위해 AI 에이전트를 생성하고 관리할 수 있는 오픈 소스 도구에요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n시스템은 문제 분석 및 에이전트 생성을 위해 자연어 처리를 활용합니다. 다양한 언어 모델 및 내보내기 형식을 쉽게 통합할 수 있는 모듈식 아키텍처를 채택했습니다.\n\nAutoGroq는 온라인 데모(autogroq.streamlit.app)와 로컬 설치용 GitHub 저장소로 제공됩니다. 작동을 위해서 Groq 개발자 API 키가 필요합니다.\n\n이 도구의 아키텍처는 빠른 프로토타이핑, 워크플로 최적화 및 특화된 에이전트 생성을 용이하게 합니다. AI 기반 프로젝트 개발 및 테스트에 가치가 있는 도구입니다.\n\n![이미지](/TIL/assets/img/2024-07-14-11TrendingGithubProjects_1.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## OpenAGI\n\n오픈AGI는 자유로운 소스 플랫폼으로, 자율적 AI 에이전트의 개발과 배포를 진보시키기 위해 설계되었으며, 특히 대형 언어 모델 (LLMs)과 도메인 특화 전문 모델을 통합하는 데 중점을 두고 있습니다.\n\n오픈AGI는 LLMs의 기능과 계획, 추론, 자립적 행동이 가능한 자율 에이전트에 대한 필요 사이의 간극을 줄이려고 노력하고 있습니다. 이는 실제 세계 상황에서 복잡한 다단계 작업을 처리할 수 있는 AI 에이전트의 생성을 용이하게 하는 데 목표를 두고 있습니다.\n\n여기에는 OpenAGI의 작동 방식을 설명하는 논문이 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Vanna\n\nVanna는 자연어를 사용하여 SQL 쿼리를 생성하는 오픈 소스 Python 프레임워크입니다. RAG(retrieval-augmented generation)를 사용하여 복잡한 데이터 세트에서 높은 정확도를 제공하며 데이터 프라이버시를 유지하고 다양한 SQL 데이터베이스를 지원합니다. Vanna는 데이터베이스 스키마와 샘플 쿼리를 학습하는 RAG 모델을 통해 자연어 질문에서 SQL을 생성합니다.\n\n이 프레임워크는 pip를 통해 쉽게 설치할 수 있으며 다양한 LLMs 및 벡터 데이터베이스와 함께 사용할 수 있습니다. Jupyter 노트북 및 Streamlit 앱을 포함한 여러 사용자 인터페이스 옵션을 제공합니다. Vanna는 LLMs나 벡터 데이터베이스의 사용자 지정 구현을 허용하도록 설계되어 확장 가능합니다.\n\nVanna는 활발한 커뮤니티 개발과 포괄적인 문서화를 통해 비기술적 사용자를 위한 데이터베이스 쿼리 작업을 간소화하고 신속한 프로토 타이핑을 용이하게 하며 데이터 분석 워크플로우를 향상시키는 것을 목표로 합니다. 데이터베이스 상호 작용을 보다 접근 가능하게 만드는 중요한 단계를 나타냅니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](/TIL/assets/img/2024-07-14-11TrendingGithubProjects_2.png)\n\n## Fine-tuning llama 3\n\nThis is a concept and not an open source project, but it is important to know this if you are building your own LLMs.\n\nFine-tuning Llama 3:\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 8B 및 70B 매개변수 버전으로 사용 가능\n- MMLU 및 HumanEval과 같은 벤치마크에서 높은 성능\n- 파인튜닝 방법: Full Parameter, LoRA, QLoRA\n- 도구: Unsloth, PyTorch FSDP, TRL\n- 과제: 베이스 모델 문제, 프롬프트 민감도\n- 권장 사항: LoRA/QLoRA부터 시작하고, 학습률과 배치 크기 최적화\n- 응용: 고객 지원 자동화, 의도 분류\n- 자원: Hugging Face, Unsloth, YouTube에서 제공하는 튜토리얼\n- 배포 시 윤리적 고려 사항 중요\n\nLlama 3의 파인튜닝은 과업별 모델의 가능성을 제공하지만, 적절한 하드웨어 및 방법 선택과 적절한 데이터 준비가 필요합니다.\n\n## TensorRT\n\nTensorRT는 NVIDIA가 개발한 오픈소스 딥러닝 추론 최적화 및 런타임 도구입니다. NVIDIA GPU에서 성능을 향상시키도록 설계되었으며, ONNX 및 TensorFlow SavedModel과 같은 다양한 입력 형식을 지원합니다. 이 소프트웨어는 레이어 퓨전 및 정밀도 보정과 같은 최적화 기술을 제공하며, C++ 및 Python API를 모두 지원합니다. 별도의 프로젝트인 TensorRT-LLM은 대규모 언어 모델의 최적화에 초점을 맞춥니다. 최신 버전인 TensorRT 10.1.0에는 파서, 플러그인 및 샘플 업데이트가 포함되어 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n커뮤니티 프로젝트들이 TensorRT의 기능을 확장하여 PyTorch와 같은 프레임워크와 통합했습니다. TensorRT 자체는 프로프리어터리이지만, 오픈 소스 구성 요소는 다양한 라이선스로 제공됩니다. NVIDIA 하드웨어에서 딥 러닝 추론을 최적화하려는 개발자들에게 TensorRT는 강력한 해결책을 제공하며, 강력한 커뮤니티 지원과 지속적인 개발을 제공합니다.\n\n## 홈 어시스턴트 코어\n\n홈 어시스턴트 코어는 홈 어시스턴트 생태계의 기반이되는 오픈 소스 홈 자동화 플랫폼으로서, 로컬 제어 및 개인 정보 보호에 중점을 두고 있습니다.\n\n다양한 운영 체제에서 스마트 홈 기기를 추적, 제어 및 자동화하는 Python 기반 프로그램입니다. 홈 어시스턴트 코어는 로컬 작동, 다양한 기기 지원, 자동화 기능 및 사용자 정의 대시보드를 제공합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n사용자들은 홈 어시스턴트 코어를 홈 어시스턴트 운영 시스템, 컨테이너 기반 설치, 지도된 설치, 또는 Python 가상 환경을 사용한 수동 설정과 같은 다양한 방법으로 설치할 수 있습니다. 해당 프로젝트는 강력한 커뮤니티를 가지고 있으며, GitHub에서 소스 코드를 제공하고 정기적으로 업데이트됩니다.\n\n오픈 소스 프로젝트는 소프트웨어 산업에서 계속해서 주요 동력이 되고 있습니다. 이들은 협업, 투명성, 혁신이라는 기본적인 원칙을 구현하며 기술 발전을 위해 필수적인 가치를 내포하고 있습니다.\n\n다양한 프로젝트들을 통해 확인할 수 있듯이, 오픈 소스 솔루션은 종종 품질, 보안, 기능 면에서 사유 소스 제품을 능가하거나 맞먹습니다.\n\n오픈 소스 모델은 개인 개발자와 기업 뿐만 아니라 기술 커뮤니티와 사회 전반에도 이익을 제공합니다. 강력한 도구와 기술에 대한 접근성을 둘려주며, 모든 규모의 개인 및 조직들이 혁신하고 경쟁할 수 있는 수준 playing field에서 수행할 수 있도록 합니다.","ogImage":{"url":"/TIL/assets/img/2024-07-14-11TrendingGithubProjects_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-11TrendingGithubProjects_0.png","tag":["Tech"],"readingTime":11},{"title":"퀀트를 위한 블랙-숄즈 모델 완벽 가이드","description":"","date":"2024-07-14 23:55","slug":"2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants","content":"\n\n\n![Black-Scholes Model for Options Pricing](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_0.png)\n\n백만 달러의 방정식: 옵션 가격에 대한 블랙-숄즈 모델입니다. 금융 분야에서 일하거나 공부한 적이 있다면, 아마도 이 이름을 듣거나 귀띔해 본 적이 있을 것입니다. 전문화 수준에 따라 옵션의 가격을 근사하거나, 투자 결정을 내리는 데 직접 사용했을 수도 있습니다. 다음과 같은 방정식 중에서 가장 익숙한 것은 다음과 같을 것입니다:\n\n![Equation 1](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_1.png)\n\n![Equation 2](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_2.png)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n비록 다소 복잡한 방정식으로 보일 수 있지만, 원칙적으로는 실제로 사용하기 굉장히 간단합니다: 플러그 앤 플레이 방식이죠. 매개변수를 알고 있거나 추정할 수 있다면, 방정식에 그 값들을 넣어서 콜옵션이나 풋옵션의 해당 가격을 얻을 수 있습니다. 그리고 이 정보를 활용해서 시장 가격과 비교하거나, 다양한 매개변수로 다양한 투자 시나리오를 시뮬레이션하고, 떠오르는 모든 아이디어들을 실행할 수 있습니다.\n\n그렇지만 만약 저처럼 좀 호기심 많은 사람이거나, 양자 분야에 관심이 있거나, 양자 세계에 진출하고 싶다면 한 가지 의문을 품고 계셨을 것입니다: 이 방정식은 어째서 나왔는 걸까요?\n\n본 문서에서는 양자의 시각에서 블랙-숄즈 모델에 대한 깊은 탐구를 할 것입니다. 주의: 앞으로 많은 수학이 나옵니다! 만약 실용적인 투자 기술을 찾고 있다면, 유감스럽지만 이 글은 아닙니다. 그러나 양자 인터뷰를 준비하고 있거나, 양자금융에 관심이 있으며 주제에 대한 깊은 이해를 원한다면 당신을 위한 이야기가 될 것입니다. 확률 미적분 및 금융 수학에 대한 일정 수준의 지식이 필요합니다. 함께 시작해봐요!\n\n## 블랙-숄즈 SDE\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n옵션 가격 측정에 들어가기 전에, Black-Scholes 모델에서 가정된 기초 자산 가격 프로세스의 확률적 동역학을 먼저 살펴봅시다:\n\n![이미지1](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_3.png)\n\n![이미지2](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_4.png)\n\n이 확률적 미분 방정식(SDE)을 이해하는 방법은 다음과 같습니다: 기초 자산 S의 가격(LHS)의 연속적인 변화는 결정적 시간 구성요소(드리프트)와 확률적 구성 요소(확산)에 의존합니다. 이 가격 모델은 기하 브라운 운동(GBM)으로도 알려져 있습니다. 비교적 간단하지만 올바르게 사용할 때 시장에서 관측되는 가격과 유사한 확률 과정을 근사화해줍니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_5.png)\n\n특정 시간 t에서의 가격에 대한 명시적 공식을 유도할 수 있다는 사실을 알 수 있습니다:\n\n![image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_6.png)\n\n이 형태에서 브라운 운동의 특성을 기반으로 분포를 추론할 수 있습니다. 그러나 이 공식을 어떻게 얻을 수 있을까요? 여기서 우리의 친구인 확률 미적분학의 이토 레마가 도움이 됩니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Black-Scholes SDE 해결하기\n\nSDE를 해결하기 위해서 가장 사용하기 좋은 도구는 보통 이토의 렘마입니다. 이토 프로세스를 고려해 봅시다:\n\n![image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_7.png)\n\n이전과 매우 유사한 가격 역학을 보여주지 않나요? 이토의 렘마는 다음과 같이 규정합니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![이미지](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_8.png)\n\n따라서 우리가 연속적이고 두 번 미분 가능한 함수 f의 올바른 선택을 찾을 수 있다면 S_t에 대한 식을 구할 수 있습니다. 이전의 SDE를 한 번 더 살펴봅시다:\n\n![이미지](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_9.png)\n\n![이미지](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_10.png)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nIto의 보조정리를 적용하면 f(s) = ln(s)일 때,\n\n![image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_11.png)\n\n에서 우리가 사용해야 하는 도함수들이 있습니다. 이를 공식에 대입하고 간소화하면 다음과 같은 해답이 도출됩니다:\n\n![image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_12.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이곳에서 하는 일은 모든 용어를 매칭하고 미분을 대체하는 것입니다. 세 번째 줄에서는 어디에나 적분을 한 다음 남은 적분을 해결합니다. 브라운 운동에 대한 적분은 W_u에 의존하지 않습니다. 따라서 그 자체로 B.M.이 됩니다. 확률적 적분 및 미분에 익숙하지 않다면 Quantstart의 멋진 글을 읽어보세요.\n\n결과적인 가격의 중요한 특성 중 하나는 로그-정규 분포를 따른다는 것이며, S_t의 로그가 정규 분포를 따른다는 것으로 나타낼 수 있습니다:\n\n![image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_13.png)\n\n추신으로, 로그 수익도 정규 분포를 따릅니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_14.png)\n\nAlthough I won’t go through the derivations here, this will be important in deriving the actual Black-Scholes pricing formulas that we saw at the beginning.\n\nRisk-Neutral Stochastic Dynamics\n\nWhen pricing derivatives, financial mathematics and stochastic calculus tell us that we can assume that all assets grow and can be discounted at the risk-free rate, giving a “fair price”. To understand how this works from a practical point of view, I recommend reading this article. From a theoretical perspective, this corresponds to the The First Fundamental Theorem of Asset Pricing. Thus, in order to price anything, we need to transform our price model to the risk-neutral world.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n두 가지 주요 개념을 기억해 봅시다: Radon-Nykodym 도함수 과정과 Girsanov의 정리.\n\n![image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_15.png)\n\nMeasure 변경 정리는 위의 속성을 가진 확률 변수가 존재하여 실제 확률 측도 P를 기반으로 한 확률 측도 Q(\"리스크 중립\" 측도)를 구성할 수 있다는 것을 말해줍니다. 그러나 이것을 일반적인 확률 과정에 확장하는 방법은 어떻게 될까요? 다음 정리는 Radon-Nykodym 도함수를 기반으로 한 과정의 존재를 알려줍니다:\n\n![image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_16.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n본 정의는 각 시간 단계 t에서 Radon-Nykodym 도함수가 적용되며, 더 나아가 이 도함수는 항상 마팅게일입니다.\n\n그래서 이제 위험 중립적 측도로 전환하기 위해 이러한 확률과정이 존재한다는 걸 알게 되었는데, 정확히 어떻게 이 변화를 수행해야 할까요? Girsanov의 정리는 이 구성을 제공하고 결과적인 과정이 여전히 유효한 마틴게일임을 보장합니다. 이는 금융 수학 분야의 여러 응용프로그램에 필수적인 조건으로, 특히 이 연구와 같은 위험 중립 파생상품 가격 산출에 적용됩니다.\n\n![image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_17.png)\n\n이제 우리의 문제에 이를 어떻게 적용하는지 살펴봅시다. 원래의 실세계 측도 P 하에서의 원래 동역학을 상기해보세요:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![Image 1](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_18.png)\n\n![Image 2](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_19.png)\n\n![Image 3](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_20.png)\n\nTo achieve this, we set\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![Image 1](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_21.png)\n\nBy plugging this into the measure and with some simple manipulations, the dynamics of S_t under the risk-neutral measure Q become:\n\n![Image 2](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_22.png)\n\nAlso, we have by Girsanov’s that\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_23.png)\n\n![image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_24.png)\n\n따라서, Girsanov의 정리는 위험 중립 측도 Q 하에서 할인된 프로세스가 Martingale임을 보장합니다. 이로부터 금융 수학의 여러 정리와 결과를 통해 위험 중립 동역학 하에서 파생상품을 가격 지정할 때 \"공정 가격\"을 찾을 수 있다.\n\n## 옵션 프로세스의 블랙-숄즈 모델 도출\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_25.png)\n\nThe idea is pretty clear: if we want to price a derivative say, at inception (t=0) it’s value should be the potential (expected) payoff we should get from it at maturity, adjusted via the risk-free rate today.\n\nThus, for an European Call and Put option at time t from inception respectively is given by:\n\n![image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_26.png)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 표를 다음과 같이 마크다운 형식으로 변경해주세요.\n\n\nNotice that the expectation is taken under the risk-neutral measure. In order to solve this expectation, let’s revisit the stochastic dynamics and distribution for S(T):\n\n![equation 27](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_27.png)\n\nwhich implies that\n\n![equation 28](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_28.png)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위에서 W_T에 물결표시(~)가 있는 경우, 그것은 위험중립 측도 아래의 브라운 운동입니다.\n\n이제 위험중립 측도 아래 콜 옵션의 페이오프의 기대값은 다음과 같습니다:\n\n![image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_29.png)\n\n여기서 함수 phi(z)는 표준 정규 분포의 확률밀도함수입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 호출 옵션이 가치를 가지는 경우는 있음을 주목해 주세요.\n\n![image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_30.png)\n\n이 조건은 다음과 같이 번역됩니다.\n\n![image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_31.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n따라서, 적분에서 값의 오른쪽 위 부분만 0이 아닙니다:\n\n![image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_32.png)\n\n다음으로, 적분을 두 부분으로 나눌 수 있다는 것에 유의하세요:\n\n![image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_33.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![Image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_34.png)\n\nCombining the both parts and applying the discount factor we obtain:\n\n![Image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_35.png)\n\n, where\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_36.png)\n\n, 이것은 잘 알려진 Black-Scholes 공식입니다. Put에 대한 유도는 유사하지만, Put-Call Parity가 항상 성립한다는 것을 기억하세요, 즉:\n\n![](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_37.png)\n\nBlack-Scholes PDE\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리가 블랙-숄즈 모델에 대한 수학적 분석을 완료한 것은 아직이에요. 위키백과의 글을 확인하면 다음과 같은 방정식을 만나게 될 거에요:\n\n![블랙-숄즈 모델 방정식](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_38.png)\n\n이 방정식이 의미하는 바를 이해하고 해석하는 방법을 이해하려면, 재무 해석을 통해 확률 해석을 통한 유도를 살펴보는 게 좋아요:\n\n![블랙-숄즈 모델 유도](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_39.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래와 같이 도함수(derivatives)가 제공됩니다:\n\n![image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_40.png)\n\n따라서:\n\n![image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_41.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n, 세 번째 단계는 다음 사실에서 나온다.\n\n![image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_42.png)\n\n포트폴리오가 자율자금화되어 있으며(즉, 초기 자본 외에는 자본을 투입하지 않는다) 무위험이어야 하므로(어떠한 황폐도도 없음), 포트폴리오 가치의 변화는 무위험 이자율에 초기 포트폴리오 가치를 곱한 것이어야 한다:\n\n![image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_43.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제, 기억하시나요?\n\n![Equation 44](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_44.png)\n\n이전 방정식에 대체하면,\n\n![Equation 45](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_45.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 블랙-숄즈 PDE의 정확한 수식입니다. 따라서, 우리는 우리가 가정한 확률 동역학과 무위험 및 위험 중립 원칙에서 완전히 유도된 이 방정식을 명확히 볼 수 있습니다.\n\n## 블랙-숄즈 가격 표면\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n보너스로 블랙-숄즈 가격 결정 표면을 시각화할 수 있습니다. 이것은 글의 시작 부분에서 보았던 것입니다. 아래는 그림을 생성하는 코드입니다:\n\n![Source](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_48.png)\n\n그리스\n\n블랙-숄즈 편미분 방정식에서 중요한 파생 변수 몇 가지를 분석할 수 있습니다. 이는 일반적으로 그리스(Greeks)라고 알려진 것들입니다. 그리스는 블랙-숄즈 방정식에서 직접 취할 수 있거나 유래된 구성 요소들로, 옵션 가격 공식의 도함수는 옵션 가격 및 다른 것들이 다른 매개변수가 변할 때(나머지는 일정한 상태에서) 어떻게 변하는지 알려줍니다. 이것은 별도의 주제이므로, 오늘은 델타, 감마, 세타 및 베가에 대한 개요, 그리고 옵션 포트폴리오에서 처음 두 가지를 헷징하는 방법에 대해서만 다룰 것입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 내용을 따를 때 Black-Scholes 옵션 가격 산식을 상기해 봅시다:\n\n![Image 1](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_49.png)\n\n![Image 2](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_50.png)\n\n옵션의 델타는 옵션 가격이 기초 자산 가격의 변화에 대해 변하는 속도를 측정합니다. 수학적으로, 다음과 같이 쉽게 볼 수 있습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![Image description](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_51.png)\n\nAs a side note, for a portfolio of options, the delta of the portfolio is simply the aggregated deltas in that porfolio:\n\n![Image description](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_52.png)\n\nThe question is: what do we do with this information?\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n델타 헷지\n\n![이미지](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_53.png)\n\n이제 이에 대한 구체적인 예시를 살펴보겠습니다:\n\n![이미지](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_54.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n헷지를 적용하면 포트폴리오 가치가 대부분 일정하게 유지되는 것을 확인할 수 있어요! 헷지 없이는, 옵션의 변동폭이 0.04달러가 아닌 0.56달러가 될 거예요!\n\n파이썬 예제로 설명해볼게요:\n\n```js\n시나리오 1 (S_new = 50):\n  델타 헷지 없이 포트폴리오 가치: 2.769931697559578\n  델타 헷지를 취한 포트폴리오 가치: 5.377939867417446\n\n시나리오 2 (S_new = 52):\n  델타 헷지 없이 포트폴리오 가치: 9.230279902656218\n  델타 헷지를 취한 포트폴리오 가치: 17.05430441222985\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_55.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nΓ는 Δ가 기초 자산 가격 S의 변동에 민감하게 반응하는 정도를 측정하는 지표입니다. 수학적으로는:\n\n![equation1](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_56.png)\n\n여기서\n\n![equation2](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_57.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n일부 특성:\n\n![Image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_58.png)\n\n![Image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_59.png)\n\n포트폴리오의 전체 감마가 제로가 되도록 가중치 w_'T_1'를 선택합니다 (이를 연습으로 확인할 수 있습니다). 그러나 결과적인 포트폴리오가 델타-중립성을 유지하는 것은 아닐 수도 있습니다. 추가된 요소로 델타 중립성이 해칠 수 있습니다! 다행히도 이를 상대적으로 간단하게 해결할 수 있습니다. 추기하는 방법으로 델타 중립성의 불일치를 다시 조정함으로써.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![Image 1](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_60.png)\n\nunits of the underlying, that is:\n\n![Image 2](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_61.png)\n\nLet’s see a worked out example for illustration:\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![Image 1](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_62.png)\n\n![Image 2](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_63.png)\n\n![Image 3](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_64.png)\n\nJust as before, let’s illustrate this with a Python example:\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n초기 값:\n  콜 옵션 가격 (C): 2.4004610869656666\n  델타 (Δ): 0.5216016339715761\n  감마 (Γ): 0.06554537725247868\n  헷지용 콜 옵션 가격 (C1): 2.87445202228551\n  헷지용 감마 (Γ1): 0.05725608663849005\n  헷지 가중치 (w_T1): 1.1447757103332348\n\n주식 가격 변화: 1\n헷지가 없는 포트폴리오 가치: -0.5539863395119156\n델타-감마 헷지 적용 후 포트폴리오 가치: -0.0642348870027587\n```\n\n이 예시를 통해 델타와 감마의 변화로 인한 큰 손실을 피하도록 도와준 델타-감마 헷지로 인해 손실을 줄일 수 있음을 확인할 수 있습니다.\n\n![image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_65.png)\n\n세타는 다른 요인들이 일정한 상황에서 만기가 줄어들 때 옵션 가치가 얼마나 줄어드는지를 나타냅니다. 이는 종종 옵션의 \"시간 감소\"로 불리며 수학적으로 다음과 같이 표현됩니다:\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![Theta for a call and a put](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_67.png)\n![Theta for a put option on a non-dividend-paying stock](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_68.png)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n일부 특성:\n\n- 장기 포지션의 경우 세타는 보통 음수입니다. 다른 모든 요인이 일정하다면 시간이 흐름에 따라 옵션의 가치가 감소하기 때문입니다.\n- 단기 포지션의 경우 세타는 양수이며, 시간이 지남에 따라 가치가 증가함을 반영합니다.\n- 세타는 대체로 ATM(행사가격과 현재 주가가 동일한) 옵션에 대해 높으며, ITM(행사가격보다 주가가 높은) 및 OTM(행사가격보다 주가가 낮은) 옵션에 대해 감소합니다.\n- 만기가 다가올수록 ATM 옵션의 경우 세타가 증가하여 시간 가치의 가속화된 감쇠를 반영합니다.\n\n예시를 살펴봅시다. 다음과 같은 매개변수를 갖는 유러피언 콜 옵션이 있다고 가정해봅시다:\n\n[옵션 파라미터 이미지](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_69.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![Image 1](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_70.png)\n\n이 예는 시간이 중요한 전략인 캘린더 스프레드 또는 시간 퇴조 전략과 같이 Theta가 유용한 정보를 제공하는 방식을 보여줍니다.\n\n![Image 2](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_71.png)\n\n이 기사에서 제시된 중요한 그리스 중 마지막으로 소개된 것은 Vega입니다. Vega는 기초 자산의 내재 변동성이 1% 변할 때 옵션 가격이 얼마나 변화하는지를 정량화하여, 다른 모든 요소가 일정하다고 가정합니다. 수학적으로:\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_72.png\" /\u003e\n\nFor both call and put options, Vega can be expressed using the Black-Scholes formula as:\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_73.png\" /\u003e\n\nSome characteristics:\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 베가는 항상 양수입니다. 변동성이 증가하면 콜 옵션과 풋 옵션의 가치가 모두 증가합니다.\n- 베가는 동일가격에서 가장 높으며, 이후 옵션이 더 많이 더 옵션으로 변화될수록 감소합니다.\n- 만기일이 다가감에 따라 베가도 증가하며, 장기적인 옵션에 대한 변동성의 영향이 더 크게 나타납니다.\n\n이와 유사하게, 예시를 살펴봅시다:\n\n![Example](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_74.png)\n\n콜 옵션의 베가는 대략 6.825이며, 기초 자산의 변동성이 1% 증가한다면 (30%에서 31%로), 모든 조건이 동일한 상태에서 콜 옵션의 가격이 대략 $6.825 증가할 것으로 예상됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 결론\n\n블랙-숄즈 모델은 실제로는 상당히 간단한 근사치이지만, 해당 모델의 연구를 통해 옵션 가격 측정의 여러 동역학과 함의를 수학적으로 이해할 수 있으며, 이러한 것들이 어떻게 유용하고 통찰력 있는 특성들과 관련이 있는지 알 수 있습니다. 이 글에서는 블랙-숄즈 모델에서 가정된 위험 자산의 기초 가격 모델을 다루었으며, 확률적 미적분학과 금융 수학을 사용하여 블랙-숄즈 SDE 및 PDE의 유도를 연구했으며, 가장 중요한 그리스 부분을 다루고 이러한 부분들이 SDE 및 PDE 방정식과 어떻게 관련되는지 살펴보았습니다. 여기서 다루지 않은 많은 내용 (다른 그리스 부분, 내재 변동성 등)이 있지만, 이 글이 해당 모델에 대한 여러 관점을 하나의 글에서 소개할 것이라고 기대합니다.\n\n즐거운 학습되시길 바랍니다!\n\n## Follow me at\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- [LinkedIn](https://www.linkedin.com/in/hair-parra-526ba19b/)\n- [GitHub](https://github.com/JairParra)\n- [Medium](https://medium.com/@hair.parra)","ogImage":{"url":"/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_0.png","tag":["Tech"],"readingTime":28},{"title":"Python, C, Rust로 직접 만들어보는 ReLU 활성화 함수 단계별 가이드","description":"","date":"2024-07-14 23:51","slug":"2024-07-14-CreatingaReLUActivationFunctionfromScratchAStep-by-StepGuideinPythonCandRust","content":"\n\n\n![image](/TIL/assets/img/2024-07-14-CreatingaReLUActivationFunctionfromScratchAStep-by-StepGuideinPythonCandRust_0.png)\n\n# 소개\n\n신경망 세계에서 활성화 함수는 모델의 출력을 결정하는 데 중요한 역할을 합니다. 가장 인기 있는 활성화 함수 중 하나는 ReLU(렉티파이드 루 linear Unit)입니다. 간단함과 효과적임으로 유명한 ReLU는 많은 딥러닝 모델에서 표준 선택지가 되었습니다. 이 안내서에서는 Python, C 및 Rust 세 가지 다른 프로그래밍 언어로부터 ReLU 활성화 함수를 처음부터 만드는 과정을 안내합니다. 이를 통해 다양한 플랫폼에서의 구현과 이점에 대한 명확한 이해를 제공할 것입니다.\n\n# ReLU란 무엇인가요?\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nReLU은 Rectified Linear Unit의 약자입니다. 이는 입력 값을 반환하는 활성화 함수로 정의됩니다:\n\n![ReLU Activation Function](/TIL/assets/img/2024-07-14-CreatingaReLUActivationFunctionfromScratchAStep-by-StepGuideinPythonCandRust_1.png)\n\n더 간단히 말하면, 입력 값이 양수인 경우 입력 값을 반환하고, 그렇지 않으면 0을 반환합니다. ReLU 함수는 수학적으로 다음과 같이 표현됩니다:\n\n![ReLU Formula](/TIL/assets/img/2024-07-14-CreatingaReLUActivationFunctionfromScratchAStep-by-StepGuideinPythonCandRust_2.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# ReLU를 사용하는 이유?\n\n- 단순성: ReLU 함수는 0을 기준으로 한 간단한 임계값 처리를 포함하기 때문에 계산 효율적입니다.\n- 비선형성: 선형 함수처럼 보이지만 ReLU는 비선형성을 도입하여 복잡한 패턴을 학습하는 데 필수적입니다.\n- 희소 활성화: ReLU는 희소한 활성화를 생성하는 경향이 있어서 (많은 뉴런이 0을 출력) 네트워크를 더 효율적으로 만듭니다.\n\n# Python에서 ReLU 및 신경망 레이어 구현하기\n\n파이썬에서 ReLU 활성화 함수와 간단한 신경망 레이어를 구현해보겠습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 파이썬 구현\n\n## 단계 1: ReLU 함수 정의\n\n먼저, 간단한 파이썬 함수를 사용하여 ReLU 함수를 정의해 보겠습니다.\n\n```python\ndef relu(x):\n    return max(0, x)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 단계 2: 배열에 ReLU 적용하기\n\n우리는 NumPy를 사용하여 배열을 처리할 수 있는 ReLU 함수를 확장할 것입니다.\n\n```python\nimport numpy as np\n\ndef relu_array(arr):\n    return np.maximum(0, arr)\n```\n\n## 단계 3: 간단한 신경 계층 정의하기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자, 이제 간단한 신경망 레이어 클래스를 만들어봅시다.\n\n```js\nclass SimpleNeuralLayer:\n    def __init__(self, input_size, output_size):\n        self.weights = np.random.randn(input_size, output_size)\n        self.biases = np.zeros(output_size)\n\n    def forward(self, inputs):\n        z = np.dot(inputs, self.weights) + self.biases\n        return relu_array(z)\n```\n\n## 단계 4: 신경망 레이어 테스트\n\n```js\n# 예제 사용법\nlayer = SimpleNeuralLayer(3, 2)\ninputs = np.array([1, 2, -1])\noutput = layer.forward(inputs)\nprint(output)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# C에서 ReLU 및 신경 계층 구현\n\n이제 C에서 ReLU 함수와 간단한 신경망 계층을 구현해 보겠습니다.\n\n# C 구현\n\n## 단계 1: ReLU 함수 정의\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n#include \u003cstdio.h\u003e\n\ndouble relu(double x) {\n    return x \u003e 0 ? x : 0;\n}\n```\n\n## 단계 2: 배열에 ReLU 적용하기\n\n```js\n#include \u003cstdio.h\u003e\n\nvoid relu_array(double* arr, int size) {\n    for (int i = 0; i \u003c size; i++) {\n        arr[i] = arr[i] \u003e 0 ? arr[i] : 0;\n    }\n}\n```\n\n## 단계 3: 간단한 신경망 레이어 정의하기\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n## 단계 4: 신경망 레이어 테스트\n\n```js\n#include \u003cstdio.h\u003e\n#include \u003cstdlib.h\u003e\n#include \u003ctime.h\u003e\n\nint main() {\n    srand(time(NULL));\n    SimpleNeuralLayer layer = create_layer(3, 2);\n    double inputs[] = {1, 2, -1};\n    double output[2];\n    forward(layer, inputs, output);\n    printf(\"Output: %f %f\\n\", output[0], output[1]);\n    free(layer.weights);\n    free(layer.biases);\n    return 0;\n}\n```\n\n# ReLU 및 신경망 레이어 구현하기\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마침내, ReLU 함수와 간단한 신경망 레이어를 Rust로 구현해 봅시다.\n\n# Rust 구현\n\n## 단계 1: ReLU 함수 정의\n\n```rust\nfn relu(x: f64) -\u003e f64 {\n    if x \u003e 0.0 { x } else { 0.0 }\n}\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 단계 2: 배열에 ReLU 적용하기\n\n```js\nfn relu_array(arr: \u0026mut [f64]) {\n    for x in arr.iter_mut() {\n        *x = if *x \u003e 0.0 { *x } else { 0.0 };\n    }\n}\n```\n\n## 단계 3: 간단한 신경망 계층 정의\n\n```js\nuse rand::Rng;\n\nstruct SimpleNeuralLayer {\n    weights: Vec\u003cVec\u003cf64\u003e\u003e,\n    biases: Vec\u003cf64\u003e,\n}\n\nimpl SimpleNeuralLayer {\n    fn new(input_size: usize, output_size: usize) -\u003e Self {\n        let mut rng = rand::thread_rng();\n        let weights = (0..input_size)\n            .map(|_| (0..output_size).map(|_| rng.gen_range(-1.0..1.0)).collect())\n            .collect();\n        let biases = vec![0.0; output_size];\n        \n        SimpleNeuralLayer { weights, biases }\n    }\n\n    fn forward(\u0026self, inputs: \u0026[f64]) -\u003e Vec\u003cf64\u003e {\n        let mut output = vec![0.0; self.biases.len()];\n        \n        for (i, \u0026bias) in self.biases.iter().enumerate() {\n            output[i] = inputs.iter()\n                .zip(\u0026self.weights)\n                .map(|(\u0026input, weight_row)| input * weight_row[i])\n                .sum::\u003cf64\u003e() + bias;\n            output[i] = relu(output[i]);\n        }\n        output\n    }\n}\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 단계 4: 신경 계층 테스트\n\n```js\nfn main() {\n    let layer = SimpleNeuralLayer::new(3, 2);\n    let inputs = [1.0, 2.0, -1.0];\n    let output = layer.forward(\u0026inputs);\n    \n    for value in output {\n        print!(\"{} \", value);\n    }\n    // 출력: 0 0\n}\n```\n\n# 결론\n\nReLU 활성화 함수를 만들고 간단한 신경망 계층에 통합하는 것은 신경망 작업에 대한 기본 개념을 강조합니다. Python, C 및 Rust에서 ReLU를 구현함으로써, 여러 플랫폼에서 딥러닝 모델의 성공을 이끌어내는 주요 구성 요소 중 하나에 대한 통찰을 얻을 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기계 학습 초보자이거나 경험이 풍부한 실무자이든 ReLU와 같은 활성화 함수의 내부 작업을 이해하는 것이 중요합니다. 이 지식을 통해 다양한 응용 프로그램을 위해 신경망을 더 잘 설계, 디버그 및 최적화할 수 있습니다.\n\n좋은 코딩되세요!\n\n![image](/TIL/assets/img/2024-07-14-CreatingaReLUActivationFunctionfromScratchAStep-by-StepGuideinPythonCandRust_3.png)","ogImage":{"url":"/TIL/assets/img/2024-07-14-CreatingaReLUActivationFunctionfromScratchAStep-by-StepGuideinPythonCandRust_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-CreatingaReLUActivationFunctionfromScratchAStep-by-StepGuideinPythonCandRust_0.png","tag":["Tech"],"readingTime":9}],"page":"8","totalPageCount":41,"totalPageGroupCount":3,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"8"},"buildId":"o6AmBAY_j9v9JmbaRA39X","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>