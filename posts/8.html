<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>TIL</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//posts/8" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="TIL" data-gatsby-head="true"/><meta property="og:title" content="TIL" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//posts/8" data-gatsby-head="true"/><meta name="twitter:title" content="TIL" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/7978fe7362f7d4c9.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/7978fe7362f7d4c9.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/873-eb138c3217d71553.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/posts/%5Bpage%5D-de1dc5579188f9be.js" defer=""></script><script src="/TIL/_next/static/Suu-uTE6tpVjS7rqQHkw3/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/Suu-uTE6tpVjS7rqQHkw3/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Python의 가장 강력한 데코레이터" href="/TIL/post/2024-07-13-PythonsMostPowerfulDecorator"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Python의 가장 강력한 데코레이터" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-13-PythonsMostPowerfulDecorator_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Python의 가장 강력한 데코레이터" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Python의 가장 강력한 데코레이터</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 13, 2024</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="파이썬으로 랜덤 포레스트 직접 구현하는 방법" href="/TIL/post/2024-07-13-BuildingaRandomForestbyHandinPython"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="파이썬으로 랜덤 포레스트 직접 구현하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-13-BuildingaRandomForestbyHandinPython_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="파이썬으로 랜덤 포레스트 직접 구현하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">파이썬으로 랜덤 포레스트 직접 구현하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 13, 2024</span><span class="PostList_reading_time__6CBMQ">26<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="알려주는 대신 물어보세요 호기심이 이끄는 대화형 AI의 시대" href="/TIL/post/2024-07-13-DontjustTellAskTheriseofconversationalAIwhereCuriosityleadstheway"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="알려주는 대신 물어보세요 호기심이 이끄는 대화형 AI의 시대" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-13-DontjustTellAskTheriseofconversationalAIwhereCuriosityleadstheway_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="알려주는 대신 물어보세요 호기심이 이끄는 대화형 AI의 시대" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">알려주는 대신 물어보세요 호기심이 이끄는 대화형 AI의 시대</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 13, 2024</span><span class="PostList_reading_time__6CBMQ">15<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="첫 로컬 LLM 실행 방법 " href="/TIL/post/2024-07-13-HowtorunyourfirstlocalLLMs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="첫 로컬 LLM 실행 방법 " loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="첫 로컬 LLM 실행 방법 " loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">첫 로컬 LLM 실행 방법 </strong><div class="PostList_meta__VCFLX"><span class="date">Jul 13, 2024</span><span class="PostList_reading_time__6CBMQ">22<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="PapersWithCode와 채팅할 수 있는 LLM-Powered 앱 만드는 방법" href="/TIL/post/2024-07-13-HowToBuildanLLM-PoweredAppToChatwithPapersWithCode"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="PapersWithCode와 채팅할 수 있는 LLM-Powered 앱 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-13-HowToBuildanLLM-PoweredAppToChatwithPapersWithCode_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="PapersWithCode와 채팅할 수 있는 LLM-Powered 앱 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">PapersWithCode와 채팅할 수 있는 LLM-Powered 앱 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 13, 2024</span><span class="PostList_reading_time__6CBMQ">18<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Python __all__ 이해하기 - 15초 설명" href="/TIL/post/2024-07-13-__all__inPythonExplainedin15Seconds"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Python __all__ 이해하기 - 15초 설명" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-13-__all__inPythonExplainedin15Seconds_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Python __all__ 이해하기 - 15초 설명" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Python __all__ 이해하기 - 15초 설명</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 13, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="초보자를 위한 실용적 GPT-4 프롬프트 안내 쉽게 만드는 No-Code 지도와 보고서" href="/TIL/post/2024-07-13-PragmaticGPT-4PromptingNiftyNo-CodeMapsandReportsforNoobs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="초보자를 위한 실용적 GPT-4 프롬프트 안내 쉽게 만드는 No-Code 지도와 보고서" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-13-PragmaticGPT-4PromptingNiftyNo-CodeMapsandReportsforNoobs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="초보자를 위한 실용적 GPT-4 프롬프트 안내 쉽게 만드는 No-Code 지도와 보고서" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">초보자를 위한 실용적 GPT-4 프롬프트 안내 쉽게 만드는 No-Code 지도와 보고서</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 13, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="ETF 데이터 분석을 위한 Python 활용 금융 정보를 가져오고 분석하고 시각화하는 방법" href="/TIL/post/2024-07-13-PythonforETFDataAnalysisHowtoFetchAnalyzeandVisualizeFinancialInformation"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="ETF 데이터 분석을 위한 Python 활용 금융 정보를 가져오고 분석하고 시각화하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-13-PythonforETFDataAnalysisHowtoFetchAnalyzeandVisualizeFinancialInformation_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="ETF 데이터 분석을 위한 Python 활용 금융 정보를 가져오고 분석하고 시각화하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">ETF 데이터 분석을 위한 Python 활용 금융 정보를 가져오고 분석하고 시각화하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 13, 2024</span><span class="PostList_reading_time__6CBMQ">23<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="데이터 시각화 갓템, Quad-Tile Chart와 Squaremap 사용법 소개" href="/TIL/post/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="데이터 시각화 갓템, Quad-Tile Chart와 Squaremap 사용법 소개" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="데이터 시각화 갓템, Quad-Tile Chart와 Squaremap 사용법 소개" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">데이터 시각화 갓템, Quad-Tile Chart와 Squaremap 사용법 소개</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 13, 2024</span><span class="PostList_reading_time__6CBMQ">59<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="FB Prophet과 하이퍼파라미터 최적화를 사용한 BTC-USD 가격 예측, 교차 검증 QC, 수정된 알고리즘 거래 전략" href="/TIL/post/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="FB Prophet과 하이퍼파라미터 최적화를 사용한 BTC-USD 가격 예측, 교차 검증 QC, 수정된 알고리즘 거래 전략" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="FB Prophet과 하이퍼파라미터 최적화를 사용한 BTC-USD 가격 예측, 교차 검증 QC, 수정된 알고리즘 거래 전략" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">FB Prophet과 하이퍼파라미터 최적화를 사용한 BTC-USD 가격 예측, 교차 검증 QC, 수정된 알고리즘 거래 전략</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 13, 2024</span><span class="PostList_reading_time__6CBMQ">39<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/TIL/posts/1">1</a><a class="link" href="/TIL/posts/2">2</a><a class="link" href="/TIL/posts/3">3</a><a class="link" href="/TIL/posts/4">4</a><a class="link" href="/TIL/posts/5">5</a><a class="link" href="/TIL/posts/6">6</a><a class="link" href="/TIL/posts/7">7</a><a class="link posts_-active__YVJEi" href="/TIL/posts/8">8</a><a class="link" href="/TIL/posts/9">9</a><a class="link" href="/TIL/posts/10">10</a><a class="link" href="/TIL/posts/11">11</a><a class="link" href="/TIL/posts/12">12</a><a class="link" href="/TIL/posts/13">13</a><a class="link" href="/TIL/posts/14">14</a><a class="link" href="/TIL/posts/15">15</a><a class="link" href="/TIL/posts/16">16</a><a class="link" href="/TIL/posts/17">17</a><a class="link" href="/TIL/posts/18">18</a><a class="link" href="/TIL/posts/19">19</a><a class="link" href="/TIL/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Python의 가장 강력한 데코레이터","description":"","date":"2024-07-13 20:21","slug":"2024-07-13-PythonsMostPowerfulDecorator","content":"\n\n![파이썬의 강력한 데코레이터](/TIL/assets/img/2024-07-13-PythonsMostPowerfulDecorator_0.png)\n\n@property는 파이썬에서 제일 좋아하는 데코레이터입니다. 여러 해 동안 파이썬을 사용해왔는데, 매년마다 언어에 대한 전문 지식과 편안함이 조금씩 쌓여왔어요. 이렇게 오랜 기간 동안 배운 기술과 트릭 가운데, property 데코레이터는 두드러지는 효과를 발휘했습니다. 이 데코레이터는 복잡한 문제 해결을 도와주고 깔끔하고 효율적이며 우아한 코드를 작성하는 데 지속적으로 도움을 주고 있어요.\n\n@property 데코레이터는 클래스 속성과 상호작용하는 방식을 향상시키는 엄청난 기능입니다. 속성을 연결하고 의존성을 만드는 강력한 방법이 될 수 있어요. 이 초보자 친화적인 안내서에서 속성의 기본 개념을 탐구하고 클래스를 강화하기 위해 5가지 다른 방법에 대해 알아볼 거에요. 또한 데이터 과학과 기계 학습 분야의 실용적인 예제를 통해 이해를 더욱 견고하게 할 거예요.\n\n팁: 파이썬 애호가에게 처음으로 속성을 소개할 때 그들 눈 속에서 반짝임을 볼 때 너무 흥분돼요. 처음 알게 될 때도 그대로 반짝이길 바래요! 이미 경험 많은 개발자이고 개념에 익숙하다면, 이 포스트에서 새로운 것을 발견했으면 좋겠어요. 어찌되었든, 설명이 더 잘 될 수 있는 부분이 있거나 놓칠법한 중요한 사용 사례가 있다면 댓글에서 알려주시면 감사하겠습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 속성 간단 안내서\n\n한 마디로 말하자면, 파이썬에서 속성(property)은 객체의 특정 측면에 대한 제어된 액세스를 허용하는 특수한 속성입니다. 다음과 같이 이름과 클래스라는 두 가지 간단한 속성을 정의하는 학생(Student) 클래스를 고려해보십시오. 우리는 인스턴스화하고 다음과 같이 이름 속성에 액세스할 수 있습니다:\n\n학생의 이름을 요청하고 이름 속성에 액세스하여 출력할 수 있습니다. 모두 좋습니다! 이제 학생들에게 이름을 요청할 때마다 일어서도록 강제하고 싶다고 상상해보십시오. 다음과 같이 속성 데코레이터를 사용하여 코드를 다시 포매팅함으로써 쉽게 이를 달성할 수 있습니다:\n\n여기서 @property를 사용하여 이름 속성에 액세스하기 전에 추가 작업을 할 수 있었습니다! 이름 속성의 기술용어는 getter입니다: 속성을 \"가져오기\"하기 전에 작업을 수행할 수 있는 방법이라고 생각해보세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기본적으로 속성은 Python에서 getter 메서드를 생성할 수 있게 해주는 바로가기로 생각할 수 있어요. 객체에 대한 정보를 안전하게 접근할 수 있는 방법을 제공해줍니다. @property를 통해 구현된 getter 메서드를 통해 비공개 또는 보호된 속성에 안전하게 접근할 수 있게 됩니다. 위 예시에서 볼 수 있듯이, \"비공개\" 속성 _name을 정의하고 getter 메서드인 name 속성을 통해 접근하고 있어요.\n\n속성의 가장 중요한 기능은 속성을 읽기 전용으로 만들어 값을 덮어쓰기하는 것을 막는다는 점이에요. 아래 예시를 살펴보세요:\n\nname이 속성으로 설정되어 있기 때문에 보통의 속성처럼 어떤 값을 간단히 덮어쓸 수 없어요. 이렇게 함으로써 속성의 무결성과 기능성이 애플리케이션 전반에 걸쳐 유지되도록 보장할 수 있어요.\n\n요약하자면, 속성은 속성을 읽기 전용으로 만들어주고 실제 속성에 접근하기 전에 다른 작업을 수행할 수 있도록 해줍니다. 실제 예시를 통해 자세히 살펴보겠지만, 지금은 속성 데코레이터가 어떻게 작동하는지에 대한 대략적인 개념을 이해하셨으면 좋겠어요. 계속 진행하기 전에 한 가지 알아보고 넘어가기 위해 속성이 어떻게 작동하는지와 속성이 작동하는 기본 개념인 디스크립터에 대해 간단히 살펴보겠습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 뒷면에서: 속성과 디스크립터\n\n속성은 속성이 어떻게 접근, 수정 또는 삭제되는지를 결정하는 객체인 디스크립터 개념과 밀접한 관련이 있습니다. 여기서는 \"접근\" 부분에만 초점을 맞춥니다. 디스크립터는 클래스 내의 속성에 대한 특정 규칙과 조건을 정의할 수 있습니다. 일반적으로 이를 통해 코드와 객체/클래스의 동작을 더 잘 제어하고 유연하게 조작할 수 있습니다. 속성은 내부적으로 디스크립터를 활용하여 클래스에 이를 녹여내어 객체/클래스의 기능을 향상시킬 수 있습니다.\n\n메소드에 @property 데코레이터를 사용하면 getter 디스크립터가 생성됩니다. 속성에 접근할 때 디스크립터의 __get__ 메소드가 호출되어 속성 값을 반환하기 전에 추가 동작을 수행할 수 있습니다. 실제로 @property 데코레이터는 getter 디스크립터를 만드는 간편한 방법입니다.\n\n디스크립터의 작동 방식에 대한 자세한 내용은 이 글의 범위를 벗어나지만, 파이썬 참조 문서와 Real Python의 훌륭한 기사를 참조하여 더 자세히 알아볼 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 데이터 처리 및 기계 학습의 맥락에서 속성을 사용하는 5가지 다른 방법을 살펴보겠습니다.\n\n# 1. 데이터 또는 모델 속성이 덮어쓰기되는 것으로부터 보호하기\n\n![이미지](/TIL/assets/img/2024-07-13-PythonsMostPowerfulDecorator_1.png)\n\n우리가 토론한 대로, 속성은 직접 할당을 제한하여 클래스 속성이 덮어쓰기되는 것을 방지하는 강력한 메커니즘을 제공합니다. 이 기능은 데이터 과학 및 기계 학습 응용 프로그램에서 데이터 및 모델의 무결성이 중요한 경우에 특히 가치가 있습니다. @property 데코레이터를 활용하여 읽기 전용 속성을 생성할 수 있으며, 이를 통해 속성에 액세스할 수 있지만 수정할 수는 없습니다. 이는 우연한 오류 발생 가능성이 적은 견고한 데이터 및 모델 객체를 생성하는 데 매우 유용할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n클래스 속성이 데이터셋을 나타낼 때는 덮어쓰기를 방지하는 것이 매우 중요합니다. 이렇게 함으로써 데이터의 일관성과 신뢰성을 보장할 수 있습니다. 데이터 과학과 기계 학습 워크플로우에서 데이터셋은 종종 외부 소스에서 로드되거나 복잡한 계산을 통해 생성됩니다. 한 번 데이터가 로드되거나 계산된 후에는 그 무결성을 유지하는 것이 중요합니다. 이를 통해 후속 분석이나 모델에서 오류나 불일치를 방지할 수 있습니다.\n\n예를 들어, 간단한 데이터 로더 클래스를 고려해 보겠습니다. 이 클래스는 경로를 입력으로 받아들이고 해당 경로에 포함된 데이터를 로드합니다(간소화된 예시로 Parquet 파일을 가정합니다).\n\n여기서 주된 문제는 예시에서 보여준 것처럼 데이터셋 속성을 덮어쓸 수 있다는 것입니다. 데이터를 실수로 수정하여 원본 경로에 더 이상 해당하지 않음을 깨닫지 못한 채로 파이프라인에 문제가 발생할 수 있습니다. 게다가 클래스에서 다른 속성(카운트 또는 평균 및 통계와 같은 일반 통계치)을 계산하고 있고 데이터가 실수로 덮어써진 경우, 여전히 통계치가 데이터에 해당한다고 잘못 가정할 수 있습니다.\n\n이 문제를 개선하기 위해 dataset을 호출할 때 경로를 로드하는 메서드로 변환하는 방법이 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n혹시 load_dataset() 메서드를 호출하기 위해 seemingly redundant 한 dataset() 메서드를 정의하는지 혼란스러워 하신다면, 곧 알게 될 거예요.\n\n여기서 전체 아이디어는 이제 file_path 속성 대신 데이터가 항상 dataset() 메서드를 통해 가져와진다는 것입니다. 이것은 완벽한 해결책은 아니지만, dataset() 메서드가 속성이 아닌 메서드이기 때문에 (1) 그렇게 완벽하지는 않고, (2) 여전히 실수로 덮어쓸 수 있습니다. @property 데코레이터를 사용하면 이 두 문제를 동시에 해결할 수 있어요.\n\n매직! 이전 코드 스니펫과 거의 동일하지만 데코레이터 하나를 추가함으로써 두 문제를 해결했어요. dataset은 이제 사실상 읽기 전용 속성이 됐어요.\n\n지금까지 좋아요, 하지만 또 다른 문제가 생겼어요. 이 특정 구현은 데이터셋 속성을 호출할 때마다 데이터를 불러오기 위해 pd.read_parquet() 함수를 호출합니다. 이것은 매우 비효율적일 수 있으며, 중대한 크기의 데이터셋에도 적합하지 않을 수 있어요. 데이터셋 메서드에 캐싱을 구현해야 합니다. 이것이 다음 세그먼트의 주제입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n작업을 계속하기 전에, 이 세그먼트를 요약해보겠습니다. 클래스 속성이 덮어쓰여지는 것을 방지하는 속성을 사용함으로써, 데이터 과학과 머신 러닝 애플리케이션에서 데이터의 일관성과 신뢰성을 보장할 수 있습니다. 이는 모델의 무결성을 유지하고 오류를 방지하며 정확한 분석과 예측을 촉진하는 데 도움이 됩니다.\n\n이제 @property를 사용하여 클래스를 강화할 수 있는 몇 가지 다른 방법을 살펴보겠습니다.\n\n# 2. 비싼 속성의 캐싱 및 최적화\n\n![이미지](/TIL/assets/img/2024-07-13-PythonsMostPowerfulDecorator_2.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n속성은 성능을 최적화하고 런타임을 줄이는 캐싱 메커니즘으로 사용할 수 있습니다. 이는 특히 속성의 계산이 자원을 많이 사용하고 결과가 자주 변하지 않는 시나리오에서 이점을 제공합니다.\n\n이전 세그먼트에서는 데이터셋 속성을 호출할 때마다 클래스가 디스크에서 데이터프레임을 로드하는 문제가 발생했습니다. 그러나 최초로 로드된 후 데이터셋을 캐시하기 위해 프라이빗 속성 _dataset을 추가함으로써 이를 완화할 수 있습니다.\n\n이 업데이트로 데이터셋이 처음 호출될 때 데이터는 한 번 파일에서 내부 _dataset 속성으로 로드됩니다. 데이터셋을 이후에 사용할 때는 간단히 메모리에서 데이터를 로드합니다.\n\n더 안전하게 하기 위해 file_path도 속성으로 변경할 수 있지만, 실제 사용 사례에 따라 달라집니다. 각 로더 인스턴스가 특정 파일 경로 또는 데이터셋에만 해당하도록 하려면 file_path를 읽기 전용으로 만들어야 합니다. 그렇지 않으면 파일 경로가 동적으로 변경될 수 있는 더 유연한 범용 데이터 로딩 클래스가 필요한 경우, 그대로 두면 됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n완전성을 위해 머신 러닝과 관련된 예제도 고려해 봅시다. 하이퍼파라미터를 갖지 않고 피쳐와 타겟 데이터셋을 입력으로 받아 모델을 훈련하는 간단한 머신 러닝 모델을 구축해 봅시다. 아래 구현은 두 가지 속성을 갖고 있습니다: trained는 모델이 훈련되었는지 여부를 나타내며 model_parameters는 훈련 후에 모델 파라미터를 \"캐싱\"하여 덮어쓰기 방지 기능을 제공합니다.\n\n여기서는 trained 상태와 모델 파라미터를 읽기 전용 속성으로 변환하기 위해 속성을 사용하고 있습니다. 이 접근 방식을 통해 모델의 훈련 여부를 쉽게 확인하고, 훈련된 파라미터를 검색할 수 있습니다.\n\n요약하자면: 자원 집약적인 계산 결과를 캐싱함으로써, 속성은 불필요한 계산을 피하고 코드 실행 효율성을 향상시켜줍니다. 특히 속성의 결과가 자주 변경되지 않을 때 특히 유용합니다. 예시로는 대규모 데이터셋부터 ML 모델 파라미터까지 다양한 경우가 있습니다.\n\n# 3. 자주 사용되는 속성의 동적 계산\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![그림](/TIL/assets/img/2024-07-13-PythonsMostPowerfulDecorator_3.png)\n\n속성은 동적 계산에 사용될 수 있으며, 속성 값의 계산을 실시간으로 가능하게 합니다. 특히 속성 값이 다른 속성이나 외부 요인에 의존하는 경우에 유용합니다. 다음과 같은 간단하고 흔한 예제를 고려해보세요:\n\n면적(area) 및 둘레(circumference) 속성은 현재 반지름 속성의 값에 기초하여 면적 및 둘레를 동적으로 계산합니다. 이는 속성이 계산을 속성 내부에 캡슐화할 수 있도록 하여, 추가적인 메서드를 정의하고 실행한 다음 출력을 변수에 할당하지 않아도 되게 합니다.\n\n데이터 처리 문맥에서 더 실용적인 예제는 다음과 같이 설명됩니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 예에서 DataProcessor 클래스는 팬더스 DataFrame을 입력으로 받아 \"계산\"에 대한 속성을 제공합니다. 동적 계산을 위해 속성을 사용하면 데이터에 대한 정보를 수동으로 매번 계산할 필요 없이 쉽게 가져올 수 있습니다. 이는 특히 대규모 데이터셋을 처리하거나 반복적인 계산을 수행할 때 시간과 노력을 절약하는 데 도움이 됩니다.\n\n계산이 비용이 많이 드는 경우 해당 계산을 변수에 캐싱하여 속성에 대한 긴 액세스 시간을 방지하는 것이 좋습니다. 반면에 계산 결과가 많고 많은 메모리를 차지할 경우, 해당 결과를 속성에 보유하면 불필요한 메모리 오버로드를 유발할 수 있으므로 캐싱할 내용에 대해 주의해야 합니다.\n\n요약하면: 속성을 사용하여 계산을 속성 내에 캡슐화하면 다른 속성이나 외부 요인을 기반으로 값의 동적 계산이 가능해지며 별도의 메서드를 연쇄적으로 실행하고 결과를 변수에 할당할 필요가 없어집니다.\n\n# 4. Setter와 결합하여 새 값 할당의 유효성 검사하기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](/TIL/assets/img/2024-07-13-PythonsMostPowerfulDecorator_4.png)\n\n속성 데코레이터를 추가하여 속성을 읽기 전용으로 만드는 이유는 변수에 getter 메서드를 도입하고 setter 메서드를 도입하지 않기 때문입니다. 따라서 해당 속성은 새 값으로 \"설정\"될 수 없습니다. 그러나 단순히 @`속성`.setter를 추가함으로써 변수에 setter 메서드를 도입할 수 있으며, 이를 통해 속성에 새 값 할당 전에 추가 코드(예: 정상성 검사 또는 다른 수동 개입)를 실행할 수 있습니다.\n\n@property와 @`속성`.setter의 조합은 Python에서 속성의 값 설정 시 사용자 지정 유효성 검사를 가능하게 하는 강력한 기능을 제공합니다. 이 조합을 활용하면 속성에 할당되는 데이터가 유효하고 적절한 데이터만 할당되도록 한 클래스의 견고성과 신뢰성을 향상시킬 수 있습니다. 이렇게하면 코드베이스의 전반적인 무결성이 향상되며 잠재적인 버그나 잘못된 데이터가 속성에 할당되는 것을 방지할 수 있습니다. 다음 예제를 확인해보세요:\n\nscaling_factor 속성은 이제 setter 메서드가 정의되어 있기 때문에 더 이상 읽기 전용이 아닙니다. 그러나 긍정적인 측면은 이제 속성에 할당하기 전에 체크를 수행하여 새 값을 유효한지 확인할 수 있다는 것입니다. 예를 들어, 여기서 스케일 요인에 할당된 값을 항상 양수인지 확인하는 것을 보여드리겠습니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위 예제에서 확인할 수 있듯이, 유효하지 않은 (0 또는 음수) 값을 할당하려고 하면 ValueError가 발생합니다. 이는 클래스 속성에 문제가 있는 값을 실수로 할당하여 발생하는 오류를 찾는 데 매우 유용할 수 있습니다.\n\n요약하자면: 게터와 세터를 최대한 활용하면 클래스를 더 견고하고 임의의 값이 아닌 에러에 덜 민감하게 만드는 데 매우 강력할 수 있습니다. 또한 이를 사용하여 값뿐만 아니라 데이터 유형인지도 확인할 수 있습니다.\n\n# 5. 무거운 속성들의 지연로딩 및 메모리 최적화\n\n![image](/TIL/assets/img/2024-07-13-PythonsMostPowerfulDecorator_5.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n속성은 클래스 내에서 메모리 집중형 에셋 및 속성을 게으르게 로드할 수 있는 방법을 제공하여, 필요한 시점까지 미루는 것을 가능하게 합니다. 이 기능은 방대한 데이터 세트나 자원 집약적인 작업을 다룰 때 특히 유용합니다. 이러한 자원들을 실제로 필요한 시점까지 로드를 미룸으로써, 시스템의 전반적인 성능과 효율성을 크게 향상시킬 수 있습니다. 게으르게 로딩을 통해 오직 필요한 자원만 필요한 시점에 메모리에 로드되므로, 불필요한 오버헤드를 줄일 수 있어 메모리를 절약하고 자원 할당을 최적화할 수 있습니다.\n\n저희는 이미 이를 섹션 2의 예제에서 수동으로 구현했습니다. 데이터는 DataLoader 클래스에 초기화 시 로딩되는 것이 아니라 데이터셋 속성에 처음 접근할 때 로드됩니다. 캐싱을 위해 우리는 비공개 속성 _dataset을 정의하고 None으로 인스턴스화하고, 처음으로 접근할 때 이 데이터를로드하도록했습니다. 너무 많은 단계처럼 들립니다. functools 라이브러리는 @property 대신 @cached_property 데코레이터를 사용하여 모든 보일러플레이트 코드를 간단히 없애는 편리한 방법을 제공합니다. 예시를 보겠습니다:\n\n훨씬 깔끔하죠! 누구나 보일러플레이트 코드를 좋아하지 않아요.\n\n게으르게 로드되는 속성들은 데이터 클래스를 보다 메모리 효율적으로 만들 수 있습니다. Python에서 메모리 효율적인 클래스를 작성하는 다른 방법에 대해 자세히 알아보려면 이 글을 확인해보세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n요약하자면: 속성의 게으른 로딩 활용은 성능 향상, 리소스 사용 최적화 및 코드의 전반적 효율성 향상 이점을 제공합니다. @cached_property 데코레이터를 사용하여 이를 쉽게 달성할 수 있습니다.\n\n오늘은 속성에 대해 많은 것을 배웠습니다 (또는 저처럼 느린 독자라면 여러 날 동안). 파이썬의 속성은 설명자의 기본 개념을 기반으로 한 clean하고 유연한 방식으로 클래스에서 속성 액세스를 관리합니다. 속성은 코드 가독성을 향상시키며 변수 보호, 동적 계산, 유효성 검사, 캐싱 및 게으른 로딩을 위한 다양한 기능을 제공합니다. 데이터 과학 및 머신 러닝에서 파이썬 개발을 계속하면 속성 습득이 확실히 프로그래밍 도구 상 중요한 기술이 될 것입니다.\n\n자 이제 멋진 것을 만들어 보고 그것에 대해 여기나 LinkedIn에서 저에게 알려주세요!","ogImage":{"url":"/TIL/assets/img/2024-07-13-PythonsMostPowerfulDecorator_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-PythonsMostPowerfulDecorator_0.png","tag":["Tech"],"readingTime":13},{"title":"파이썬으로 랜덤 포레스트 직접 구현하는 방법","description":"","date":"2024-07-13 20:17","slug":"2024-07-13-BuildingaRandomForestbyHandinPython","content":"\n\n![Building a Random Forest by Hand in Python](/TIL/assets/img/2024-07-13-BuildingaRandomForestbyHandinPython_0.png)\n\n약물 발견에서 종 분류, 신용 점수 매기기, 사이버 보안 등 랜덤 포레스트는 복잡한 세상을 모델링하는 인기 있고 강력한 알고리즘입니다. 그 다양성과 예측 능력은 첨단 복잡성을 필요로 할 것 같지만, 랜덤 포레스트가 실제로 무엇인지 파헤쳐보면 놀랍게 간단한 일련의 반복 단계들로 이뤄져 있습니다.\n\n저는 무엇인가를 배우는 가장 좋은 방법은 그것과 놀아보는 것이라고 생각합니다. 그러므로 랜덤 포레스트가 어떻게 작동하는지 직관을 얻기 위해 Python으로 직접 포레스트를 만들어 봅시다. 의사 결정 트리에서 시작하여 완전한 포레스트로 확장해보겠습니다. 우리는 분류와 회귀 모두에 대해 이 알고리즘이 얼마나 유연하고 해석 가능한지 직접 확인할 것입니다. 이 프로젝트가 복잡해 들리더라도 실제로 우리가 배워야 할 핵심 개념은 1) 데이터를 순차적으로 분할하는 방법, 2) 데이터가 얼마나 잘 분할되었는지를 어떻게 정량화 하는가 입니다.\n\n# 배경\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 의사 결정 트리 추론\n\n의사 결정 트리는 피처를 레이블과 매핑하는 이진 규칙 집합을 식별하는 지도 학습 알고리즘입니다. 로지스틱 회귀와 같은 알고리즘과 달리 출력이 방정식인 것이 아니라 의사 결정 트리 알고리즘은 비모수적이므로 피처와 레이블 간의 관계에 강한 가정을 하지 않습니다. 이는 의사 결정 트리가 훈련 데이터를 최적으로 분할하는 방식으로 자유롭게 성장할 수 있기 때문에 결과적인 구조가 데이터 집합에 따라 다양하다는 것을 의미합니다.\n\n의사 결정 트리의 주요 장점 중 하나는 해석 가능성입니다. 분류를 위해 카테고리를 예측하는 트리가나 회귀를 위해 연속 값을 예측하는 각 단계는 트리 노드에서 확인할 수 있습니다. 예를 들어, 온라인에서 본 제품을 구매할지 예측하는 모델은 다음과 같이 보일 수 있습니다.\n\n![의사 결정 트리](/TIL/assets/img/2024-07-13-BuildingaRandomForestbyHandinPython_1.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n루트부터 시작하여, 트리의 각 노드는 이진 질문을 하며 (예: \"세션 길이가 5분보다 길었습니까?\"), 답변에 따라 피처 벡터를 두 개의 자식 노드 중 하나로 전달합니다. 자식 노드가 없는 경우 - 즉, 리프 노드에 도달한 경우 - 트리는 응답을 반환합니다.\n\n![image](/TIL/assets/img/2024-07-13-BuildingaRandomForestbyHandinPython_2.png)\n\n(이 블로그 포스트에서는 분류에 초점을 맞추겠지만, 의사 결정 트리 회귀기는 순차적 값이 아닌 클래스 레이블이 아닌 연속 값을 반환하게 됩니다.)\n\n## 의사 결정 트리 학습\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n유추 또는 이 예측 프로세스는 꽤 간단합니다. 그러나 이 트리를 구축하는 것은 훨씬 명백하지 않습니다. 각 노드의 이진 규칙은 어떻게 결정되는 걸까요? 트리에 사용되는 특성들은 무엇이며, 어떤 순서로 사용되는 걸까요? 0.5 또는 1과 같은 임계값은 어떻게 결정되는 걸까요?\n\n의사 결정 트리가 어떻게 구축되는지 이해하기 위해, 우리가 모양(사각형과 삼각형)의 대형 데이터 세트를 특징에 기반하여 사각형만 또는 삼각형만 포함하는 작은 데이터 세트로 분할하려고 한다고 상상해 봅시다. 이상적인 경우에는 모양을 완벽하게 분리하는 몇몇 범주형 특성이 있습니다.\n\n하지만 항상 그렇게 간단하지는 않습니다. 행운이 따르면, 대신 모양을 완벽하게 분리하는 어떤 임계값을 가진 연속적인 특성이 있을 수도 있습니다. 정확한 임계값을 찾기 위해 몇 번의 시도가 필요하지만, 그런 다음 완벽한 분할이 이루어집니다. (휴!)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![이미지](/TIL/assets/img/2024-07-13-BuildingaRandomForestbyHandinPython_4.png)\n\n그렇게 간단하지는 않죠. 이 장난감 예제에서는 모든 삼각형과 사각형이 동일하기 때문에 그들의 특성 벡터를 분리하는 것이 쉬워요. (하나의 삼각형에 대해 작동하는 규칙이 모든 삼각형에 적용됩니다!)\n\n하지만 실제 세상에서는 특성이 레이블로 깔끔하게 매핑되지 않습니다. 전자 상거래 예제로 돌아가서, 세션에서 사이트에 보낸 시간과 같은 특성은 어떤 임계값에서도 클래스를 완벽하게 분할하지 못할 수도 있어요.\n\n![이미지](/TIL/assets/img/2024-07-13-BuildingaRandomForestbyHandinPython_5.png)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 어떤 임계값에서도 데이터를 완벽하게 분리할 수 있는 특성이 없다면 어떻게 해야 할까요? 이 경우, 레이블 집합이 얼마나 \"혼합된\"지를 측정하는 방법이 필요합니다. 일반적으로 사용하는 지표 중 하나가 지니 불순도인데, 다음 식으로 계산됩니다:\n\n\nGini = 1 - Σ(pk)^2\n\n\n여기서 pk는 우리의 m개 클래스 중 하나에 속할 확률입니다. 제곱과 1의 합이 1이 되어야 하므로, 두 가지 클래스인 사각형과 삼각형의 경우, 이 식을 pk로 정의할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 p✓, 집합에서 양성 레이블을 무작위로 선택할 확률에 따른 지니 불순도의 시각적 표현입니다. [1] (우리는 pk를 p✓로 대체하여 확인 표지가 양성 클래스임을 나타냈습니다.) 집합의 요소가 모두 확인 표지가 아닌 경우(즉, x인 경우) 또는 모두 확인 표지인 경우에 지니 불순도가 가장 낮습니다. 지니 불순도는 x와 확인 표지가 같은 수 일 때 최대치에 도달합니다.\n\n![image](/TIL/assets/img/2024-07-13-BuildingaRandomForestbyHandinPython_8.png)\n\n그렇기 때문에 클래스를 분할하기 위해 규칙을 식별할 때, 우리는 단순히 각 하위 집합의 가중치를 고려해 지니 불순도를 최소화하는 분할을 선택할 수 있습니다. (각 하위 집합은 고유의 불순도를 가지고 있으므로 각 하위 집합의 샘플 수로 가중 평균을 취합니다.) 주어진 특성에 대해, 해당 특성의 모든 가능한 값으로 데이터를 분할하고, 하위 집합의 가중치가 적용된 지니 불순도를 기록한 다음, 가장 낮은 불순도를 초래한 특성 값을 선택할 수 있습니다.\n\n아래에서, 계정 연령 특성을 35일을 기준으로 분할하면, 제품을 구매하는 사용자와 구매하지 않는 사용자를 가장 잘 분리할 수 있습니다 (상상의 데이터셋에서).\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/TIL/assets/img/2024-07-13-BuildingaRandomForestbyHandinPython_9.png)\n\n우리는 모든 특성에 대해 이 과정을 반복하고, 최적 분할 결과 지니 불순도가 가장 낮은 특성을 선택할 수 있습니다. 아래에서 세션 길이의 최적 분할이 계정 연령과 빈번한 쇼핑객에 대한 최적 분할보다 낮은 지니 불순도를 보여줍니다. 빈번한 쇼핑객은 이진 특성이므로 분할할 값이 하나뿐입니다.\n\n![이미지](/TIL/assets/img/2024-07-13-BuildingaRandomForestbyHandinPython_10.png)\n\n세션 길이에 대한 분할 ` 5분`이 우리 결정 트리에서 첫 번째 분기가 됩니다. 그런 다음 특성 및 값 반복 프로세스를 반복하고 각 부분집합, 그들의 하위 부분집합 등에 대해 데이터를 최적으로 분할하는 최상의 특성을 선택합니다. 이렇게 완벽하게 분할된 데이터가 필요하거나 트리가 허용된 최대 깊이에 도달할 때까지 진행합니다. (다음 섹션에서 자세히 설명하겠습니다.)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기에 앞서 본 트리가 나타난 것이지만 각 노드에 훈련 데이터가 표시되어 있습니다. 트리를 아래로 이동할수록 양성 및 음성 클래스가 점점 분리되는 것을 주목하세요. 트리의 맨 아래에 도달하면 잎 노드는 데이터 하위 집합에서의 과반 클래스를 출력합니다. (우리의 경우에는 유일한 클래스입니다.)\n\n![image](/TIL/assets/img/2024-07-13-BuildingaRandomForestbyHandinPython_11.png)\n\n## 랜덤 포레스트\n\n위의 결정 트리는 데이터를 하나의 클래스 레이블만 포함하도록 분할합니다 (즉, Gini 불순도 = 0). 이렇게 함으로써 모델이 훈련 데이터를 설명하는 능력을 최대화하지만, 모델을 데이터에 과적합할 위험이 있습니다. 모델이 모든 특징-레이블 조합을 외우는 것이 아니라 근본적인 패턴을 학습하는 대신에 기억하는 것처럼 생각해보세요. 과적합된 모델은 일반화하기 어렵고, 일반적으로 모델링의 목표인 새로운 데이터에 대한 일반화가 어려워집니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n과적합을 방지하는 몇 가지 방법이 있습니다. 한 가지 방법은 트리의 깊이를 제한하는 것입니다. 예를 들어 위의 트리를 두 레벨로 제한하면 왼쪽 가지를 자주 쇼핑 고객 분할에서 끝낼 수 있습니다.\n\n![image](/TIL/assets/img/2024-07-13-BuildingaRandomForestbyHandinPython_12.png)\n\n이제 왼쪽 가지의 잎 노드에는 자신들의 하위 집합에서 혼합된 레이블이 있습니다. 이 \"불순도\"를 허용하는 것은 비최적적으로 보일 수 있지만, 이는 잡음이 있는 피쳐에 대한 강력한 방어 수단입니다. 예를 들어, 훈련 데이터에서 Time idle과 Age of account가 우연히 예측력이 있었다면, 해당 피쳐를 제외한 모델이 새 데이터에 대해 일반화하는 데 더 좋을 것입니다.\n\n트리 깊이 제한은 효과적입니다. 하지만 더 강력한 전략과 함께 사용할 수 있습니다: 앙상블 학습. 머신러닝에서 - 그리고 동물 집단에서도 - 일련의 예측을 집계하면 종종 개별 예측보다 더 높은 정확도를 달성할 수 있습니다. 개별 모델의 오류가 상쇄되어 모델링되는 데이터의 기본 패턴을 더 명확하게 볼 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![Image](/TIL/assets/img/2024-07-13-BuildingaRandomForestbyHandinPython_13.png)\n\n이거 굉장히 좋은데, 전체 모델 예측에 변동이 있어야 앙상블이 유용해집니다. 지난 섹션에서 설명한 알고리즘 - 모든 피처의 모든 값에 대해 Gini 불순도가 가장 낮은 지점에서 분할 - 은 결정론적입니다. 주어진 데이터 세트에 대해 저희 알고리즘은 항상 동일한 의사결정 나무 [2]를 출력하므로, 앙상블로 10개 또는 100개의 트리를 학습시켜도 실제로 아무것도 이루지 못할 것입니다. 그렇다면 왜 숲이 단일 트리보다 나은가요?\n\n여기서 랜덤성이 등장합니다. 랜덤 포레스트 내의 트리들 사이에는 데이터 분할 방식 및 데이터 자체의 변화가 있어서 모델 예측에 변동이 생기고, 오버피팅에 대한 더 큰 방어 기능을 제공합니다.\n\n우선 데이터로 시작해보죠. 부스트랩을 사용하여 데이터를 샘플링하거나 대체로써 모델에 영향을 미치는 아웃라이어들이 무의미한 상관 관계를 가로채는 것을 방지할 수 있습니다. 아이디어는 아웃라이어가 희박하기 때문에 실제 피처와 레이블 간의 진짜 관계를 반영하는 샘플보다 덜 무작위로 선택될 가능성이 높다는 것입니다. 부스트랩을 사용하면 숲 내의 각 의사결정 트리에 약간 다른 데이터 세트를 제공할 수 있어서 여전히 동일한 일반적인 경향을 포함할 것입니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-BuildingaRandomForestbyHandinPython_14.png\" /\u003e\n\n두 번째 방법은 랜덤 포레스트가 데이터를 분할할 때 일부 기능의 임계값을 찾을 때 무작위로 기능의 서브셋만 선택한다는 것입니다. 예를 들어, scikit-learn의 RandomForestClassifier는 지니 불순도를 최소화하는 임계값을 찾을 때 기능 수의 제곱근만 고려합니다.\n\n이 방법들은 이상하게 보일 수 있습니다. 왜 우리가 모든 기능을 사용하지 않는 걸까요? 그리고 왜 의도적으로 데이터에서 행을 중복하거나 삭제할까요? 실제로, 이 방식으로 생성하는 각 개별 트리는 종종 보통의 결정 트리보다 예측 능력이 상당히 떨어집니다. 그러나 수십 개의 이러한 Swiss-cheese 트리를 집계하면 놀라운 결과가 나타납니다: 원래의 결정 트리보다 더 정확한 랜덤 포레스트가 형성됩니다.\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-BuildingaRandomForestbyHandinPython_15.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 구현\n\n이제 직접 Python에서 랜덤 포레스트를 구현해 봅시다. 트리의 노드부터 시작해서 의사 결정 트리, 마지막으로 랜덤 포레스트까지 구현해 보겠습니다.\n\n## 노드\n\n먼저, 의사 결정 트리에서 노드 역할을 하는 클래스를 만들어 봅시다. 이 클래스는 훈련에 사용되는 다음과 같은 속성을 가지고 있을 것입니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 데이터의 하위 집합(또는 루트 노드의 전체 데이터 세트)\n- 이 하위 집합의 양성 레이블 비율과 Gini 불순도\n- 왼쪽과 오른쪽 자식 노드를 가리키는 포인터(노드가 잎인 경우 None으로 설정)\n\n이 클래스는 새 데이터를 분류하는 데 사용되는 다음 속성도 갖추고 있습니다:\n\n- 입력을 왼쪽이나 오른쪽 자식 노드로 이동시키는 데 사용되는 특징 이름과 임계값(노드가 잎이 아닌 경우)\n- (노드가 잎일 경우) 반환할 레이블\n\n이러한 기준을 충족하는 Node 클래스를 아래 코드로 만들 수 있습니다. GitHub의 소스 코드에는 더 철저한 독스트링과 입력 유효성 검사가 포함되어 있지만, 가독성을 위해 여기서 간소화된 버전을 공유하겠습니다. 참고로 이 파일을 node.py로 명명하고 이후 파일에서 참조할 것입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\r\nimport numpy as np\nimport pandas as pd\nfrom typing_extensions import Self\n\nclass Node:\n    \"\"\"\n    의사 결정 트리의 노드입니다.\n    \"\"\"\n    def __init__(\n        self,\n        df: pd.DataFrame,\n        target_col: str\n    ) -\u003e None:\n        # 훈련용\n        self.df = df\n        self.target_col = target_col\n        self.pk = self._set_pk()\n        self.gini = self._set_gini()\n\n        # 훈련/추론용\n        self.left = None\n        self.right = None\n\n        # 추론용\n        self.feature = None\n        self.threshold = None\n\n    def _set_pk(self) -\u003e float:\n        \"\"\"\n        pk를 설정합니다. 양성 클래스인 샘플의 비율입니다.\n        샘플은 양성 클래스가 1이고 음성 클래스가 0인 int 배열로 가정합니다.\n        \"\"\"\n        return np.mean(self.df[self.target_col].values)\n\n    def _set_gini(self) -\u003e float:\n        \"\"\"\n        지니 불순도를 설정합니다.\n        \"\"\"\n        return 1 - self.pk**2 - (1 - self.pk)**2\r\n```\n\n현재까지 코드는 가벼운 내용입니다. 데이터프레임(df)과 레이블을 포함하는 열(target_col)을 지정하여 노드를 인스턴스화합니다. 좌측과 우측 자식 노드(self.left, self.right) 및 추론에 사용되는 feature 및 threshold 값을 가진 빈 속성을 생성합니다. 마지막으로, pk(타겟 열에서 1의 비율)와 _set_pk 및 _set_gini 메서드를 사용하여 Gini 불순도를 계산합니다.\n\n이제 기능을 추가하여 특정 feature의 값들을 반복하고 자식 노드에서 최소 지니 불순도를 최소화하는 임계값을 식별하는 논리를 추가해봅시다. split_on_feature 함수는 각 feature의 고유한 값에 대해 _process_split 도우미 함수를 실행합니다. 값 중에 null을 제거한 후 남은 값들이 있으면(잎 노드의 경우 목록이 비어있을 수 있음), 가장 낮은 불순도를 갖는 분할에 대한 Gini 불순도, feature 임계값, 좌우 자식 노드를 반환합니다.\n\n```js\r\nclass Node:\n    ...\n    def split_on_feature(\n        self,\n        feature: str\n    ) -\u003e tuple[float, int|float, Self, Self]:\n        \"\"\"\n        특정 feature의 값을 반복하고 자식 노드에서 가중 Gini 불순도를 최소화하는 분할을 식별합니다.\n        가중 Gini 불순도, feature 임계값, 좌우 자식 노드의 튜플을 반환합니다.\n        \"\"\"\n        values = []\n\n        for thresh in self.df[feature].unique():\n            values.append(self._process_split(feature, thresh))\n\n        values = [v for v in values if v[1] is not None]\n        if values:\n            return min(values, key=lambda x: x[0])\n        return None, None, None, None\r\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이것이 실제 작업을 수행하는 _process_split입니다. 우리는 self.df를 feature 임계값에 따라 분할하고, 어느 하위 데이터 세트가 비어 있는 경우 일찍 종료하며, 하위 데이터로 자식 노드를 생성하고, 마지막으로 가중 Gini 불순도를 계산합니다.\n\n```python\nclass Node:\n    ...\n    def _process_split(\n        self,\n        feature: str,\n        threshold: int|float\n    ) -\u003e tuple[float, int|float, Self|None, Self|None]:\n        \"\"\"\n        feature 임계값에 따라 데이터 프레임을 분할합니다. 가중 Gini 불순도를 반환하고, 입력된 임계값 및 자식 노드를 반환합니다.\n        분할 결과가 빈 하위 집합으로 이어지면 Gini 불순도와 None을 반환합니다.\n        \"\"\"\n        df_lower = self.df[self.df[feature] \u003c= threshold]\n        df_upper = self.df[self.df[feature] \u003e threshold]\n\n        # 임계값이 데이터를 전혀 분할하지 않을 경우 일찍 종료\n        if len(df_lower) == 0 or len(df_upper) == 0:\n            return self.gini, None, None, None\n\n        node_lower = Node(df_lower, self.target_col)\n        node_upper = Node(df_upper, self.target_col)\n\n        prop_lower = len(df_lower) / len(self.df)\n        prop_upper = len(df_upper) / len(self.df)\n\n        weighted_gini = node_lower.gini * prop_lower \\\n          + node_upper.gini * prop_upper\n\n        return weighted_gini, threshold, node_lower, node_upper\n```\n\n빠르게 테스트해 봅시다. 아래에서 노드를 인스턴스화하고 데이터에 대해 최적의 분할을 찾도록 합니다. split_on_feature는 자식 노드에서 0.0의 가중 Gini 불순도를 반환합니다. 왜냐하면 레이블을 완벽하게 값 2에서 분할할 수 있기 때문입니다. 세 번째 및 네 번째 값은 분할로 생성된 왼쪽 및 오른쪽 자식 노드입니다.\n\n```python\nimport pandas as pd\n\ndf = pd.DataFrame({'feature': [1, 2, 3], 'label': [0, 0, 1]})\nnode = Node(df, 'label')\n\nprint(f\"pk: {round(node.pk, 2)}, gini: {round(node.gini, 2)}\")\n# pk: 0.33, gini: 0.44\n\nprint(node.split_on_feature('feature'))\n# (0.0, 2,\n# \u003c__main__.Node object at 0x137c279d0\u003e,\n# \u003c__main__.Node object at 0x137c24160\u003e)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 의사 결정 트리\n\n다음 단계는 트레이닝 데이터를 가장 잘 분할하고 새로운 데이터를 가장 정확하게 분류하기 위해 노드를 트리에 배열하는 것입니다. 먼저 기본 구조부터 시작하여 분류기를 학습하고(즉, 트리를 구축하고) 예측을 생성할 수 있는 능력을 살펴봅시다. 우리는 decision_tree.py 파일을 node.py와 동일한 디렉토리에 저장하고 파일에서 Node를 가져옵니다.\n\n우리의 DecisionTree 클래스는 루트 노드로 시작하는데, 이는 df와 target_col로 인스턴스화하는 Node입니다. feature_select은 랜덤 포레스트의 트리를 트레이닝할 때 사용할 feature의 비율을 제어합니다. 기본 의사 결정 트리 클래스에서는 특성의 100%를 기본값으로 사용할 것입니다. max_depth는 트리가 성장할 수 있는 최대 깊이를 지정하는데, 이는 과적합을 방지하는 데 도움이 됩니다.\n\n```js\r\nimport numpy as np\nimport pandas as pd\n\nfrom .node import Node\n\nclass DecisionTree:\n    \"\"\"\n    의사 결정 트리 분류기, Node로 구성됨\n    \"\"\"\n    def __init__(\n        self,\n        df: pd.DataFrame,\n        target_col: str,\n        feature_select: float = 1.0,\n        max_depth: int = 4\n    ) -\u003e None:\n        self.root = Node(df, target_col)\n        self.features = list(df)\n        self.features.remove(target_col)\n        self.feature_select = feature_select\n        self.max_depth = max_depth\r\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 트리를 구축하는 논리를 작성해 봅시다. 코딩 면접뿐만 아니라 Leetcode에서 공부한 모든 것이 유용하다는 것을 증명하기 위해 스택을 사용하여 깊이 우선 탐색을 수행하고, 각 노드에서 _process_node를 반복적으로 호출하고 해당 노드의 자식을 스택에 추가합니다. 또한 현재 깊이를 확인하여 self.max_depth를 초과하지 않도록 확인합니다. 모든 노드를 처리한 후에는 DecisionTree 인스턴스를 반환합니다.\n\n```js\nclass DecisionTree:\n    ...\n    def build_tree(self) -\u003e None:\n        \"\"\"\n        깊이 우선 탐색을 사용하여 트리를 구축합니다.\n        \"\"\"\n        stack = [(self.root, 0)]\n        \n        while stack:\n            current_node, depth = stack.pop()\n            \n            if depth \u003c= self.max_depth:\n                left, right = self._process_node(current_node)\n                \n                if left and right:\n                    current_node.left = left\n                    current_node.right = right\n                    stack.append((right, depth+1))\n                    stack.append((left, depth+1))\n        \n        return self\n```\n\n_process_node에서 실제로 무엇이 발생할까요? 우리는 먼저 특징의 하위 집합을 무작위로 선택한 다음 (또는 self.feature_select가 1.0이면 모든 특징을 선택합니다), 해당 특징을 반복하여 노드의 split_on_feature 메소드를 호출하여 그 특징의 최적 분할을 찾습니다. 그런 다음 자식 노드에서 지니 불순도가 가장 낮아지는 특징을 찾아 현재 노드의 불순도와 비교합니다. 최적의 분할이 더 낮은 불순도를 유발한다면 자식 노드를 반환하고, 그렇지 않으면 순회를 중지해야 함을 나타내기 위해 None을 반환합니다.\n\n```js\nclass DecisionTree:\n    ...\n    def _process_node(\n        self,\n        node: Node\n    ) -\u003e tuple[Node|None, Node|None]:\n        \"\"\"\n        특징을 반복하여 자식 노드에서 지니 불순도를 최소화하는 분할을 식별하고\n        지니 불순도를 가장 많이 줄이는 특징을 식별한 후 해당 특징에 대해\n        분할된 자식 노드를 반환합니다.\n        \"\"\"\n        # 무작위로 특징을 선택합니다. self.feature_select = 1.0이면\n        # 무작위로 선택되지 않습니다 (기본값).\n        features = list(\n            np.random.choice(\n                self.features,\n                int(self.feature_select*len(self.features)),\n                replace=False\n            )\n        )\n\n        # 각 열에 대한 최상의 분할을 위한 지니 불순도 가져오기\n        d = {}\n        for col in features:\n            feature_info = node.split_on_feature(col)\n            if feature_info[0] is not None\n                d[col] = feature_info\n\n        # 분할할 최적의 열 선택하기\n        min_gini = np.inf\n        best_feature = None\n        for col, tup in d.items():\n            if tup[0] \u003c min_gini:\n                min_gini = tup[0]\n                best_feature = col\n\n        # 최상의 분할이 불순도를 줄이는 경우에만 업데이트\n        if min_gini \u003c node.gini:\n            # 노드 업데이트\n            node.feature = best_feature\n            node.threshold = d[col][1]\n            return d[col][2:]\n\n        return None, None\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 코드는 트리를 구축하는 데 사용됩니다. 이제 예측을 생성하는 코드를 작성해 봅시다. classify 함수는 _classify 도우미 함수를 감싸는 래퍼일 뿐이며 한 번에 하나씩이 아닌 피처 벡터의 데이터프레임에 대해 예측을 생성할 수 있도록 합니다. 실제 작업은 _classify에서 수행되는데, 이 함수는 피처 벡터가 노드의 임계값과 비교에 따라 왼쪽이나 오른쪽 자식 노드로 재귀적으로 이동합니다. 잎 노드는 피처와 임계값 속성이 모두 None이므로, 노드의 pk가 0.5보다 크면 1을 반환하고 그렇지 않으면 0을 반환합니다.\n\n```python\nclass DecisionTree:\n    ...\n    def classify(self, feature_df: pd.DataFrame) -\u003e list[int]:\n        \"\"\"\n        각 행이 피처 벡터인 데이터프레임이 주어졌을 때, 트리를 탐색하여 예측 레이블을 생성합니다.\n        \"\"\"\n        return [\n          self._classify(self.root, f) for i, f in feature_df.iterrows()\n        ]\n\n    def _classify(self, node: Node, features: pd.Series) -\u003e int:\n        \"\"\"\n        피처 벡터가 주어졌을 때, 노드의 자식을 탐색하여 잎에 도달할 때까지 이동한 후, 노드에서 가장 빈번한 클래스를 반환합니다.\n        긍정적인 레이블과 부정적인 레이블이 동일한 수일 경우, 부정 클래스를 예측합니다.\n        \"\"\"\n        # 자식 노드\n        if node.feature is None or node.threshold is None:\n            return int(node.pk \u003e 0.5)\n\n        if features[node.feature] \u003c node.threshold:\n            return self._classify(node.left, features)\n        return self._classify(node.right, features)\n```\n\n## Random Forest\n\n이제 결정 트리 분류기에 필요한 모든 것을 갖추었습니다! 가장 어려운 작업은 이미 모두 끝났습니다. 분류기를 랜덤 포레스트로 확장하는 것은 이미 _process_node에서 최소화된 피처 선택을 구현했기 때문에 부트스트랩된 데이터에 여러 개의 트리를 생성하는 것만 필요합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n랜덤 포레스트를 구현한 random_forest.py 파일을 만들어봅시다. 이 파일에는 RandomForest 클래스가 포함되어 있습니다. 항상처럼, 우리는 클래스를 데이터프레임(df)과 타깃 열로 초기화하고 DecisionTree 클래스와 마찬가지로 feature_select 및 max_depth 매개변수를 가지고 있습니다. 이제 추가로 n_trees 매개변수도 전달합니다.\n\nMarkdown 형식으로 테이블 태그를 변경하세요.\n\n```python\nimport pandas as pd\n\nfrom .decision_tree import DecisionTree\n\nclass RandomForest:\n    \"\"\"\n    다수의 의사 결정 트리로 구성된 포레스트.\n    \"\"\"\n    def __init__(\n        self,\n        df: pd.DataFrame,\n        target_col: str,\n        n_trees: int = 100,\n        feature_select: float = 0.5,\n        max_depth: int = 4\n    ) -\u003e None:\n        self.df = df\n        self.target_col = target_col\n        self.n_trees = n_trees\n        self.feature_select = feature_select\n        self.max_depth = max_depth\n        self.forest = []\n```\n\n학습은 간단합니다. 우리는 n_trees 개의 부트스트랩 데이터프레임을 생성하고, 각각에 대해 DecisionTree를 인스턴스화한 다음 각 의사 결정 트리를 훈련시키기 위해 .build_tree를 호출합니다.\n\n```python\nclass RandomForest:\n    ...\n    def train(self) -\u003e None:\n        \"\"\"\n        self.df에 대해 포레스트를 학습합니다.\n        \"\"\"\n        bootstrap_dfs = [self._bootstrap() for _ in range(self.n_trees)]\n        self.forest = [\n            DecisionTree(\n              bdf,\n              self.target_col,\n              self.feature_select,\n              self.max_depth\n            )\n            for bdf in bootstrap_dfs\n        ]\n        self.forest = [tree.build_tree() for tree in self.forest]\n        return None\n\n    def _bootstrap(self) -\u003e pd.DataFrame:\n        \"\"\"\n        self.df에서 복원 추출을 통해 행을 샘플링합니다.\n        \"\"\"\n        return self.df.sample(len(self.df), replace=True)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n분류 또한 간단합니다: 우리는 숲 속의 각 트리가 입력된 feature_df를 분류하고, 각 행에 대해 가장 일반적인 예측 레이블을 반환하도록 합니다. 이 작업을 하는 가장 쉬운 방법은 예측을 데이터프레임으로 변환한 다음, 최빈값을 취하는 것이었습니다.\n\n```python\nclass RandomForest\n    ...\n    def classify(self, feature_df: pd.DataFrame) -\u003e int:\n        \"\"\"\n        입력된 feature 벡터를 분류합니다. 숲 속의 각 트리는 예측 레이블을 생성하고,\n        각 feature 벡터에 대해 가장 일반적인 레이블이 반환됩니다.\n        \"\"\"\n        preds = pd.DataFrame(\n          [tree.classify(feature_df) for tree in self.forest]\n        )\n        # 가장 일반적인 예측 레이블 반환\n        return list(preds.mode().iloc[0])\n```\n\n그리고... 이게 전부입니다! run.py 스크립트를 실행하면 DecisionTree 분류기, RandomForest의 평균 트리, 전체 RandomForest, 그리고 scikit-learn의 RandomForestClassifier의 정확도를 비교할 수 있습니다. 결과는 데이터셋, 숲당 트리 수 등에 따라 다를 수 있지만, 우리가 한 결정 트리가 숲의 평균 트리보다 더 높은 정확도를 가지고 있고, 전체 랜덤 포레스트가 개별 트리보다 훨씬 강하다는 것을 볼 수 있습니다. 역시 scikit-learn이 가장 높은 정확도를 보여주죠... 하지만 우리도 나쁘지 않았습니다!\n\n```python\n정확도\n * 단일 의사결정 트리:   0.61\n * 평균 랜덤 포레스트 트리: 0.595\n * 전체 랜덤 포레스트:     0.81\n * scikit-learn 랜덤 포레스트:    0.89\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![img](/TIL/assets/img/2024-07-13-BuildingaRandomForestbyHandinPython_16.png)\n\n# 결론\n\n이 게시물에서는 랜덤 포레스트(Random Forest)라는 가장 인기 있고 강력한 머신 러닝 알고리즘 중 하나를 다루었습니다. 이론부터 시작하여 결정 트리가 데이터 세트를 분할하는 데 가장 적합한 기능 값을 식별하기 위해 Gini 불순도와 같은 지표를 사용하는 방법을 설명했습니다. 그리고 Gini 불순도를 가장 많이 감소시키는 최적 분할 기능을 반복적으로 식별하여 트리를 구축하는 방법을 보여주었습니다. 또한 무작위 특성 선택 및 부트스트랩 데이터 세트를 사용하여 수십 개의 결정 트리로 구성된 랜덤 포레스트를 구축하는 방법을 설명했습니다. 마지막으로 몇 가지 코드를 작성하여 해당 이론을 테스트했습니다.\n\n더 알고 싶다면 미니 프로젝트가 많이 있습니다. 동일한 기능이 대상 변수와 매우 비선형적인 관계를 가질 경우 트리에서 여러 번 사용될 수 있는 방법을 시각화해 볼 수 있습니다. 이 게시물에서 회귀에 대해 다루지 않았지만, 연속적인 대상을 처리할 수 있도록 코드를 수정하는 것은 그리 어렵지 않을 것입니다. 데이터 양과 열의 수에 따른 일반 DecisionTree, 평균 랜덤 포레스트 트리 및 전체 포레스트의 예측력이 어떻게 달라지는지 확인하는 것도 흥미로울 것입니다. 마지막으로, RandomForest가 어떻게 트리를 학습하는지를 병렬화하고 싶은 사람이 있다면 PR을 제출해 주시기 바랍니다. 😜\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n친절하게 읽어 주셔서 감사합니다!\nMatt\n\n# 1. 의사 결정 트리 훈련\n\n이 그림은 정말 마음을 쏙 들인 작품이었습니다. 곡선과 원들이 한 색에서 다른 색으로 전환되는 방법을 알아내는 것이 어려웠는데, 놀랍게도 가장 어려웠던 부분은 x와 체크 마크를 원 안에 깔끔하게 유지하면서 너무 많이 뭉쳐지지 않게 하는 것이었습니다. 이 그림의 아이콘과 색상을 너무 많이 바꿔서 결국 스크립트를 작성해서 생성하는 것으로 끝이 났죠.\n\n여기에는 장난감 예제(분할 모양)와 포스트의 주요 예제(전자 상거래)와 더 명확한 시각적 구분이 필요하다고 생각하기 전까지 일부 버전의 그림이 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-BuildingaRandomForestbyHandinPython_17.png\" /\u003e\n\n## 2. 랜덤 포레스트\n\n아래 코드를 사용하여 동일한 데이터 세트에 대해 sklearn이 동일한 결정 트리를 출력하는지 직접 확인할 수 있습니다. 랜덤 상태를 동일하게 지정해야한다는 점을 주의하세요.\n\n```js\nimport numpy as np\nimport pandas as pd\nfrom sklearn.tree import DecisionTreeClassifier\n\n# 매개변수\nrandom_state = 42\n\n# 데이터 생성\ndf = pd.DataFrame(\n    {\n        'feature_1': np.random.normal(0, 1, 100),\n        'feature_2': np.random.normal(1, 1, 100),\n        'label': np.random.choice([0, 1], 100)\n    }\n)\n\nmod1 = DecisionTreeClassifier(random_state=random_state)\nmod1.fit(df[['feature_1', 'feature_2']], df['label'])\n\nmod2 = DecisionTreeClassifier(random_state=42)\nmod2.fit(df[['feature_1', 'feature_2']], df['label'])\n\ncomparison = (mod1.tree_.value == mod2.tree_.value)\nprint(comparison.all())\n# True\n```","ogImage":{"url":"/TIL/assets/img/2024-07-13-BuildingaRandomForestbyHandinPython_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-BuildingaRandomForestbyHandinPython_0.png","tag":["Tech"],"readingTime":26},{"title":"알려주는 대신 물어보세요 호기심이 이끄는 대화형 AI의 시대","description":"","date":"2024-07-13 20:14","slug":"2024-07-13-DontjustTellAskTheriseofconversationalAIwhereCuriosityleadstheway","content":"\n\n제가 항상 궁금해했던 것 중 하나는 제안 시스템이에요. 검색 엔진을 열고 검색어를 입력하면 갑자기 여러 가지 완성 제안이 나온다니까요!\n\n그것을 보면서 저는 자주 생각해봤어요: 이걸 어떻게 만들었을까? 나도 같은 것을 할 수 있을까? 필요한 기술과 자원은 무엇일까요? 이런 생각이 들었죠...\n\n처음에는 그에 대해 큰 언어 모델이 필요할 것이라고 생각했는데요... 근데 알고 보니 전혀 그렇지 않았어요!\n\n저는 개인 문서용 챗봇을 만들고 싶어요. 그 챗봇은 문서에 대해 몇 가지 질문을 \"제안\"할 수 있는 거죠. 새 문서인지 구식 문서인지를 미리 알 필요가 없어요. 함께 LLM(언어 모델 학습)을 사용하여 문서에서 질문을 생성하는 방법에 대해 알아봐요. 이 모든 것은 Hugging Face의 LLM과 파이썬을 사용하며(무료 Google Colab 노트북에서 실행) 오픈 소스 도구만 사용해서 이룰 수 있어요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# ESA: 탐사 능력 분석\n\n목표를 달성하기 위해 필요한 노하우를 얻기 위한 여정을 시작했습니다. 항상 선생님으로서 (더 이상 학교에서 가르치지는 않지만...) 질문에 집중했습니다. 만약 AI가 텍스트나 문서에 대해 질문을 하는 경우는 어떨까요? AI에게 문서를 제공한 다음에 그 문서에 대해 무슨 질문을 할 수 있는지 제안을 요청하는 것처럼 말이죠! 마치 우리가 게임 규칙을 뒤바꾸는 것 같은 느낌입니다!\n\n첫 번째 단계는 어떻게 질문을 생성하는지, 필요한 어떤 리소스가 있는지... 기본적으로 배워야 할 어떤 기술이 있는지를 이해하는 것입니다.\n\n오픈 소스 접근 방식을 원하므로 Hugging Face Hub에서 해당 작업에 전용 모델이 있는지 검색을 시작했습니다. 발견한 것은 기대 이상이었습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n허깅 페이스에서는 질문 생성을 위한 모델이 여러 개 있어요! 그 중에 valhalla/t5-small-e2e-qg를 선택하기로 결정했어요. Patil Suraj의 GitHub 레포지토리에서는 이 NLP 작업에 대한 연구를 탐구하고 있어요.\n\n허깅 페이스에서 모델 카드를 찾을 수 있어요.\n\n질문 생성은 텍스트 단락에서 질문을 자동으로 생성하는 작업입니다. 최근 논문들 중에는 UniLM과 ProphetNet이 QG에 대한 SOTA 사전 훈련 가중치를 제공하고 있지만 사용법이 다소 복잡해 보여요.\n\n이 프로젝트는 사전 훈련된 트랜스포머(특히 seq-2-seq 모델)를 사용하여 복잡한 파이프라인 없이 간단한 엔드 투 엔드 방법으로 질문 생성에 대한 오픈 소스 연구를 목표로 하고 있어요. 간소화된 데이터 처리 및 훈련 스크립트를 제공하고 추론을 위한 쉬운 파이프라인을 구축하는 것이 목표입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![Image](/TIL/assets/img/2024-07-13-DontjustTellAskTheriseofconversationalAIwhereCuriosityleadstheway_0.png)\n\n그리고 실제로 그렇습니다! 초기 훈련에서는 이 작업을 수행하기 위해 3가지 다른 모델이 필요했지만 논문 'Transformer-based End-to-End Question Generation'에서 제안된 방법을 사용할 것입니다.\n\n이것은 End-to-End 질문 생성(답변에 중립적)입니다. 여기서 모델은 답변을 제공하지 않고도 질문을 생성하도록 요청됩니다. 우리는 T5 패밀리 모델을 사용할 것이기 때문에 가능합니다. T5 모델(Text-to-Text Transfer Transformer의 약자)은 여러 NLP 작업을 수행할 수 있기 때문에 놀라운 모델입니다:\n\n번역, 질문 응답 및 분류를 포함한 모든 작업은 입력으로 모델 텍스트를 공급하고 어떤 대상 텍스트를 생성하도록 훈련시키는 것으로 표현됩니다. 이를 통해 우리는 다양한 작업 세트에 걸쳐 동일한 모델, 손실 함수, 하이퍼파라미터 등을 사용할 수 있습니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n알겠어요, 이제 소개는 여기까지하고 코딩하면서 더 많은 내용을 추가해봐요.\n\n## 어떤 단계가 있을까요…\n\n이 여정은 생각보다 쉽습니다: 함께 코딩하거나 GitHub 레포지토리에서 단계를 따라하기도 가능해요. 거기에서 Colab 노트북 파일을 찾을 수 있어요.\n\n```js\n필요한 라이브러리 모두 설치하기\n모델 가중치 다운로드하기 (torch 버전)\n질문 생성 추론 테스트하기\n문서에서 질문 생성하기 (지금은 텍스트 파일로)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n보시다시피, 여기서 Document Loaders나 Langchain을 너무 깊게 파고들지 않을 거에요. 목표는 텍스트에서 질문을 생성할 수 있는 AI를 갖는 것입니다.\n\n# 필요한 모든 라이브러리 설치하기\n\nGoogle Colab 노트북을 열고 이름을 지어주세요. 이 프로젝트에 특별한 런타임이 필요하지 않아요: 기본 런타임이 충분합니다.\n\n```js\n%%capture\n!pip install transformers\n!pip install nltk\n!pip install sentencepiece\n!pip install langchain\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n%%capture 매직은 Jupyter 기반 인터페이스에서 명령의 출력을 숨기는 기능을 제공합니다. 이 경우에는 verbose 콘솔 출력 없이 pip를 사용하여 모든 종속성을 설치할 것입니다.\n\n- nltk는 질문 생성을 위한 특수 end-to-end 파이프라인에 사용되는 기본 라이브러리입니다.\n- sentencepiece는 Neural Network 기반 텍스트 생성 시 사전에 어휘 크기가 미리 결정된 비지도 학습 텍스트 토크나이저 및 디토크나이저입니다. (SentencePiece를 사용하면 언어별 전/후 처리에 의존하지 않는 순수한 end-to-end 시스템을 구축할 수 있습니다)\n- transformers는 Hugging Face 모델과 상호 작용해야 할 때 필요합니다.\n- langchain은 외부 자원과의 상호 작용 및 LLMs와 연결하는 놀라운 기능을 갖춘 도구 상자입니다. 우리는 여기서 텍스트 분리 도구로만 사용할 것입니다.\n- pytorch는 모델 가중치를 로드하고 읽을 수 있는 라이브러리입니다. Google Colab 무료 티어에는 이미 Pytorch가 설치되어 있으므로 목록에서 볼 수 없습니다.\n\ntorch를 사용하여 Hugging Face에서 .bin 파일 형식 모델을 읽는 핵심 라이브러리가 있습니다: 이제 이론적으로 torch 형식으로 저장된 Hugging Face 모델 중 아무 모델이나 다운로드하고 사용할 수 있습니다. (텐서 플로우가 아닌)...\n\n마지막 단계는 질문 생성 전용 파이프라인을 다운로드하는 것입니다. 이는 Patil Suraj Repo에서 가져온 파이썬 파일인 pipelines.py입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n%%capture\n!wget https://github.com/patil-suraj/question_generation/raw/master/pipelines.py\n```\n\n![Image](/TIL/assets/img/2024-07-13-DontjustTellAskTheriseofconversationalAIwhereCuriosityleadstheway_1.png)\n\n# 질문 생성 추론 테스트\n\n시작해 볼까요?\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n의존성이 모두 준비되었으면, 파이프라인을 처음으로 생성할 때 모델을 다운로드합니다 (Colab이 대신 처리해 줄 거에요). 이제 몇 가지 질문 생성 추론을 해볼 수 있습니다.\n\n```js\nfrom pipelines import pipeline\n\nrepo = 'valhalla/t5-small-e2e-qg'\nnlp = pipeline(\"e2e-qg\", model=repo, tokenizer=repo)\n\nques = nlp(\"Python is a programming language. Created by Guido van Rossum and first released in 1991.\")\nprint(ques)\nprint(\"---\")\ntext2 =  \"이미지 형성 과정을 잡음 제거 오토인코더의 순차 적용으로 분해하여 확산 모델(DMs)은 이미지 데이터 및 그 이상의 합성 결과에서 최고 수준의 성과를 달성합니다. 또한, 이들의 정의는 이미지 생성 과정을 다시 훈련하지 않고 제어할 수 있는 안내 메커니즘을 제공합니다. 그러나 이 모델들은 일반적으로 픽셀 공간에서 직접 작동하기 때문에 강력한 DM의 최적화는 종종 수백 개의 GPU 일을 소모하고 순차적 평가로 인해 추론 비용이 많이든다. 계산 리소스가 제한된 상황에서 강력한 DM의 훈련을 가능하게 하면서도 그들의 품질과 유연성을 유지하기 위해 우리는 강력한 미리 훈련된 오토인코더의 잠재 공간에서 그들을 적용합니다. 이러한 표현에 대한 확산 모델의 훈련은 복잡성 축소와 세부 정보 보존 사이의 거의 최적점에 처음으로 도달할 수 있도록 하며, 시각적 충실성을 크게 향상시키게 됩니다. 모델 아키텍처에 교차 어텐션 레이어를 도입함으로써, 우리는 확산 모델을 텍스트나 바운딩 박스와 같은 일반 조건 입력에 대한 강력하고 유연한 생성기로 변형시킵니다. 우리의 잠재 확산 모델(LDM)은 이미지 인페인팅에서 최적점에 도달하고, 무조건 이미지 생성, 시맨틱 씬 합성 및 초해상도를 포함한 다양한 작업에서 매우 경쟁력 있는 성과를 나타내며, 픽셀 기반 DM에 비해 계산 요구 사항을 크게 줄입니다.\"\nques2 = nlp(text2)\nprint(ques2)\nprint(\"---\")\n```\n\n볼 수 있듯이, Pipelines (Patil Suraj의 GiHub Repo에서 생성된 pipelines.py 파일에서 가져온)만 가져오고 있습니다. 이미 모든 필요한 종속성을 로드해 주는 python 파일이기 때문에 이것은 괜찮습니다. 여기에는 정보 전용 추출이 있어요...\n\n```js\nimport itertools\nimport logging\nfrom typing import Optional, Dict, Union\n\nfrom nltk import sent_tokenize\nimport torch\nfrom transformers import(\n    AutoModelForSeq2SeqLM,\n    AutoTokenizer,\n    PreTrainedModel,\n    PreTrainedTokenizer,\n)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n수입 후에는 몇 가지 매개변수를 지정하여 nlp 파이프라인을 생성합니다:\n\n- 파이프라인 유형: \"e2e-qg\"는 훈련된 T5 모델의 능력을 활용하여 답변 없이 질문을 추출할 엔드투엔드 파이프라인입니다.\n- 모델: 로컬로 다운로드한 모델을 사용할 것이므로 필수입니다.\n- 토크나이저: 로컬로 다운로드한 모델을 사용할 것이므로 필수입니다.\n\n이제 nlp 파이프라인을 호출할 때마다 텍스트를 인수로 전달하기만 하면 됩니다. 모델이 결과로 질문을 생성합니다. 생성된 질문이 모두 포함된 리스트가 출력됩니다.\n\n# 예제 번호 1\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nques = nlp(\"파이썬은 프로그래밍 언어입니다. 1991년에 Guido van Rossum에 의해 처음 출시되었습니다.\")\nprint(ques)\n```\n\n이 예제는 모델 카드에서 가져온 것입니다. 결과는 python list로 출력됩니다\n\n```js\n['프로그래밍 언어란 무엇인가요?', '파이썬을 만든 사람은 누구인가요?', '파이썬이 처음 출시된 날짜는 언제인가요?']\n```\n\n# 예제 번호 2\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n제가 귀하의 요청에 따라 테이블 태그를 Markdown 형식으로 변경하겠습니다.\n\n\n| 문제 | 답변 |\n| --- | --- |\n| 어떤 것을 확산 모델이 수행하나요? | 이미지 형성 과정을 노이즈 제거 오토인코더의 순차적 적용으로 분해하여 상태가 좋은 합성 결과를 달성합니다. |\n| 어떤 것이 이미지 생성 과정을 재교육 없이 제어하기위한 가이드 메커니즘인가요? | 그들의 공식은 이미지 생성 과정을 다시 훈련하지 않고 제어 할 수 있습니다. |\n| 강력한 DM의 최적화는 전혀 몇 일이 걸리나요? | 강력한 DM의 최적화는 보통 GPU 수백 일을 소비하며 시퀀셜 평가로 인해 추론 비용이 높습니다. |\n\n이렇게 해서 테이블을 마크다운 형식으로 변환하였습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여러분 안녕하세요! 오랜 텍스트 파일이나 역사 교과서의 한 장을 처리해야 한다면 어떻게 해야 할까요? 혹은 거대한 논문을 다뤄야 한다면요?\n\n너무 복잡하게 생각하지 말고 함께 알아보겠습니다.\n\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-DontjustTellAskTheriseofconversationalAIwhereCuriosityleadstheway_2.png\" /\u003e\n\n\n# 문서(지금은 텍스트 파일)로부터 질문 생성하기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n텍스트 파일(텍스트만 포함됨)을 사용할 거에요. 이 텍스트 파일은 Medium 기사인 'BERT: 초심자 친화적 설명'에서 Pushpam Punjabi가 쓴 것을 가져왔어요. 문장의 의미가 중요한 기술 기사라서 좋은 테스트 케이스예요.\n\n```js\n!wget https://github.com/fabiomatricardi/Abstractive-Extractive/raw/main/BERTexplanation.txt\n```\n\n그러니까 이제 파일을 다운로드 받고 (내 저장소에서) 이를 doc 변수에 문자열로 로드해보죠.\n\n```js\nfname = '/content/BERTexplanation.txt'\nwith open(fname) as f:\n    doc = f.read()\nf.close()\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기사는 약 1800 단어로, 문자 수로는 11032자입니다.\n\n텍스트를 청크로 나누기 위해 LangChain의 RecursiveCharacterTextSplitter를 사용할 것입니다. 각 모델이 가지는 토큰의 최대 수를 초과하지 않도록하기 위함입니다.\n\n텍스트를 나누는 작업을 수행하는 함수를 만들어보겠습니다. 이 함수는 나눌 텍스트, 청크 길이(문자 수), 그리고 오버랩(맥락을 유지하기 위해 필요)을 인자로 받습니다.\n\n```js\ndef mysplit(text,chunk,overlap):\n  from langchain.text_splitter import RecursiveCharacterTextSplitter\n  text_splitter = RecursiveCharacterTextSplitter(\n        # 매우 작은 청크 크기를 설정하여 예시를 보여줍니다.\n        chunk_size = chunk,\n        chunk_overlap = overlap,\n        length_function = len,\n        )\n  texts = text_splitter.split_text(text)\n  return texts\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n나머지 부분은 쉬워요! 우리는 텍스트에 함수를 호출하고 각 청크마다 질문을 표시하기 위해 목록을 반복합니다. 여기서는 6000자를 사용하고 150개의 오버랩이 있는 함수를 사용하고 있어요.\n\n```js\n# 텍스트에 함수를 호출합니다\ntexts = mysplit(doc,6000,150)\n# 각 청크의 질문을 표시하도록 목록을 반복합니다\nfor test in texts:\n  print(\"---\")\n  questions = nlp(test)\n  for i in questions:\n    print('- '+i)\n```\n\n셀을 실행하면 다음과 같은 결과를 얻을 수 있어요.\n\n```js\n---\n- 푸샴 푸잔브이 저자의 책 이름은 무엇인가요?\n- NLP의 주요 구성 요소는 무엇인가요?\n- 기계는 어떻게 인간 언어를 이해하나요?\n- BERT BERT을 이해한 사람은 누구인가요?\n---\n- 다양한 NLP 작업에 유용한 기술은 무엇인가요?\n- BERT는 텍스트 단락의 전반적인 의미와 맥락을 어떻게 더 잘 이해할 수 있나요?\n- 챗봇이나 가상 보조 프로그램과 같은 애플리케이션에서는 인간 언어를 이해하고 해석하는 능력이 정확하고 유용한 응답을 제공하는 데 중요합니다.\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론 (지금까지)\n\n일부 질문들이 정말 간결하지 않다는 것을 알 수 있어요. 또한 제목(BERT)이 있으면 \"누가 이해하기 쉬운 BERT BERT를 개발했는가?\"와 같이 제대로 인식되지 않을 수 있어요.\n\n질문 수를 늘릴 수 있어요. (예를 들어 다음과 같은 방식으로 분할 수를 증가시킬 수 있어요.\n\n```js\ntexts = mysplit(doc,3700,50)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음으로 시도해볼 수 있는 몇 가지 단계가 있습니다:\n\n- 첫 번째는 질문을 짝지어 다른 모델을 사용하여 답변을 생성하는 것입니다.\n- 또 하나는 답변의 품질을 자동으로 검증하는 방법을 찾는 것입니다. 학생들이 온라인 양식으로 질문에 답변하는 경우, 답변의 품질을 평가하기 위해 우리의 AI를 사용할 수 있습니다.\n\n제 GitHub Repo에서 코드와 Google Colab 노트북을 찾을 수 있습니다: [GitHub Repo 링크]\n\n이 기사를 즐겁게 읽어주셨기를 바랍니다. 이 이야기가 가치를 제공하고 조금이라도 지원하고 싶다면, 어떤 지원이든 환영합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 이 이야기를 많이 박수 치세요\n- 기억하기에 더 관련성이 높은 부분을 강조하세요 (나중에 찾기 쉽고 좀 더 나은 기사를 작성하는 데 도움이 될 거예요)\n- 나만의 AI 구축 방법을 배우세요. 무료 eBook 다운로드하러 가기\n- 제 링크를 사용하여 Medium 회원가입하기 ($5/월로 무제한 Medium 이야기 읽기)\n- Medium에서 저를 팔로우하세요\n- 제 최신 기사 읽기 https://medium.com/@fabio.matricardi\n\n더 많은 정보를 원한다면 이곳에서 작은 로컬 모델을 사용한 몇 가지 아이디어가 있어요:\n\n![image](https://yourwebsite.com/TIL/assets/img/2024-07-13-DontjustTellAskTheriseofconversationalAIwhereCuriosityleadstheway_3.png)\n\n이 이야기는 Generative AI에서 게시되었습니다. LinkedIn에서 우리와 연락하고 최신 AI 이야기에 대한 소식을 받으려면 Zeniteq를 팔로우하세요. 함께 AI의 미래를 만들어 갑시다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n![Image](/TIL/assets/img/2024-07-13-DontjustTellAskTheriseofconversationalAIwhereCuriosityleadstheway_4.png)\n```","ogImage":{"url":"/TIL/assets/img/2024-07-13-DontjustTellAskTheriseofconversationalAIwhereCuriosityleadstheway_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-DontjustTellAskTheriseofconversationalAIwhereCuriosityleadstheway_0.png","tag":["Tech"],"readingTime":15},{"title":"첫 로컬 LLM 실행 방법 ","description":"","date":"2024-07-13 20:12","slug":"2024-07-13-HowtorunyourfirstlocalLLMs","content":"\n\n![How to run your first local LLMs](/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_0.png)\n\n작년 동안 (2024년에 이 글을 쓰고 있기 때문에) 대형 언어 모델(LLMs)은 전문적인 환경과 작업 수행 방식을 변화시켰습니다.\n\nChat GPT와 그들의 Chat 버전에 익숙하실 것입니다. 당신은 Chat GPT Plus 사용자(OpenAI의 유료 플랜)일 수도 있습니다. 또는 Anthropic이나 Google Bard와 같은 다른 유사한 제공 업체를 사용해본 적이 있을 수도 있습니다. 심지어 OpenAI와 경쟁 업체 모두 강력한 도구를 제공하지만, 여기 몇 가지 이유가 있어서 LLMs를 로컬에서 실행해 보려고 하는 것을 고려해볼만 합니다 (더 많을 수 있습니다!):\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 생태계에 대해 더 알고 새로운 모델을 시도하며 자신만의 경험을 소유하고 싶다면.\n- 딥 러닝과 LLMs에 대해 배우고 싶지만 시작할 곳을 모르겠거나 더 알고 싶다면; 오픈 소스 모델을 로컬에서 실행하는 것이 훌륭한 시작점이 될 수 있습니다.\n- 개인 정보를 오픈AI나 구글과 같은 대기업에 제공하고 싶지 않다면.\n- 인터넷 연결이 필요하지 않고 오프라인에서 실행할 수 있는 채팅 애플리케이션을 원한다면.\n- 금융이나 문학 작성과 같은 특정 작업을 위해 더 작고 특화된 모델로 실험하고 싶다면.\n\n얼마 전 나 또한 모든 이러한 요구 사항을 만족시켰습니다. 모든 이 기술 주변의 정보 양에 압도되었다고 느꼈습니다. 일반적인 조언으로 말할 때 목표가 오르막길처럼 느껴진다면 산만 바라보지 말고 가능한 한 빨리 첫 번째 발을 내딛어 올라가세요. 그리고 계속 그렇게 계단을 올라가다 보면 다음 산이 보이게 될 것입니다 (ㅋ).\n\n이 여정에서 첫 단계를 내딛도록 도와드리기 위해 프로세스를 아래 네 부분으로 나누어 설명했습니다:\n\n- 기본 개념 몇 가지: 이 섹션에서는 미리 알려진 지식을 가정하지 않고 자습서 전반에 걸쳐 사용되는 주요 용어와 아이디어를 소개합니다.\n- GPT4All에서 모델 실행: 오픈 소스 GUI 애플리케이션을 사용하여 로컬에서 모델을 실행합니다.\n- Jupyter 노트북에서 LangChain을 사용하여 로컬 LLMs 실행, Python 프로그래밍 기술은 필요하지만 LLMs에 대한 사전 경험이 없어도 됩니다.\n- LangChain과 Taipy를 사용하여 챗봇 생성.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n책임의 한계:\n\n- 이는 \"초보자용\" 접근법이므로 텍스트 생성 모델에 대해 작성하겠습니다.\n- 일부 모델은 기술적으로 로컬에서 실행할 수 있지만 자원을 많이 소비합니다(일반 가정용 컴퓨터나 노트북에서는 적어요). 만약 컴퓨터에 4GB의 RAM이 있다면, 실행 가능한 모델을 찾기 어려울 것입니다(그래도 여전히 몇 가지 모델을 즐겁게 시도해 볼 수 있습니다). 8GB(현재 대부분의 컴퓨터에 탑재된 메모리)가 있으면 여러 모델을 찾을 수 있지만 여전히 도전적 일 것입니다. 7GB에서 10GB 사이의 RAM이 필요한 모델을 찾기 쉽습니다.\n- 로컬에서 모델을 실행할 때 컴퓨터 소리가 전투기가 이륙하는 것처럼 들릴 수 있습니다. 이는 정상입니다.\n- GGUF 모델을 CPU로 로컬 컴퓨터에서 실행하는 방법에 대해 이야기하며 이것이 내가 알고 있는 가장 쉬운 옵션입니다. 입문자에게 100% 친숙합니다.\n- 모든 내용은 Windows 10에서 작동합니다.\n\n![그림링크](/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_1.png)\n\n# 몇 가지 기본 개념\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nLLM 랜드스케이프는 수십 개(아마 수백 개)의 새로운 용어, 용어, 개념 및 약어들을 가져왔어요. 쉽게 길을 잃을 수 있습니다. 이 섹션의 목표는 로컬에서 첫 번째 오픈 소스 모델을 사용하는 데 중요한 일부 주요 개념을 간단하게 설명하는 것입니다.\n\n- GGML 파일 : 이 파일 시스템은 이제 구식입니다(AI 세계는 빠르게 변화해요!), 하지만 여전히 주변에서 찾을 수 있습니다(그리고 이에 대한 튜토리얼도 많습니다). GPT-생성된 모델 언어를 나타냅니다. 이제 GGUF 모델을 다운로드해야 합니다.\n- GPT4All : 로컬(컴퓨터에서)에서 실행되는 그래픽 사용자 인터페이스(GUI)입니다. 챗 GPT 인터페이스와 비슷해요. 이 인터페이스를 사용하여 LLM을 로컬에서 실행할 수 있어요.\n- GGUF (GPT-생성된 통일 형식) 파일 : 로컬로 다운로드하고 실행할 수 있는 LLM 모델을 포함하는 파일입니다.\n- Hugging Face : 자연어 처리(NLP)에 초점을 맞춘 이익을 위한 회사로서, 최신 LLM의 개발 및 사용을 위한 플랫폼을 제공합니다. 이 플랫폼을 Hugging Face로도 참조할 수 있습니다. 이 플랫폼에서 많은 모델을 찾을 수 있어요(일부 모델은 로컬에서 실행할 수 있습니다).\n- LangChain : LLM 응용 프로그램을 만들기 위해 프레임워크를 개발한 회사입니다. 대부분의 경우 LangChain을 프레임워크를 가리키는 데 사용합니다. 이것은 LLM API(또는 로컬 파일!), 데이터베이스 연결, HTML 및 문서 파서에 연결할 수 있는 도구상자입니다. LangChain에는 Python API가 있습니다. 이 튜토리얼의 3부와 4부에서 사용할 겁니다.\n- 양자화 : 모델의 가중치와 바이어스의 정밀도를 줄여서 리소스가 제한된 장치에서 더 효율적으로 사용할 수 있도록 하는 것으로, 메모리 및 계산 요구 사항에 도움을 줍니다. 예를 들어, 2.45는 2.45 236987의 양자화 된 버전입니다. 덜 정확하지만 공간을 적게 차지하고 계산이 더 쉬운 숫자에 대해 더 적은 비트를 저장할 수 있습니다.\n\n## Hugging Face\n\nHugging Face은 다양한 LLM 모델을 다운로드할 수 있는 한 곳(주요한 곳?)입니다(다른 LLM 관련 도구들과 함께). 여기 목표는:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- GGUF 모델을 다운로드하는 방법을 안내해 드릴게요.\n- 다운로드하기 전에 확인해야 할 중요한 사항들을 몇 가지 소개해 드릴게요.\n\n이 글의 다음 부분에서는 GPT4all의 인터페이스에서 모델을 직접 다운로드하는 방법을 설명할 거에요. 따라서 가능한 더 적은 귀찮음을 원하신다면, 직접 그쪽으로 가셔서 모델을 다운로드할 수 있지만, 거기서는 다운로드할 수 있는 모델들이 적기 때문에, 적어도 이 글의 이 부분을 일반적인 지식으로 읽어보길 권장해 드려요.\n\n컴퓨터에서 로컬로 실행되는 GGUF 모델을 가져오려면, 먼저 모델 페이지로 이동해주세요.\n\n다음 단계는 모델을 필터링해서 GGUF 파일만 표시되도록 하는 것입니다. 페이지의 왼쪽 상단에 \"라이브러리\"를 선택하고 GGUF를 클릭하면 됩니다. 아래 이미지와 같이 하시면 되요:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![이미지](/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_2.png)\n\n아마도 많은 모델들이 특정 사용자 \"The Bloke\"로부터 온 것을 알게 될 것입니다. 다음 자습서에서는 그의 모델 중 일부를 사용할 것이지만, 선호하는 다른 모델을 선택해도 괜찮습니다!\n\nThe Bloke가 제공하는 GGUF 모델은 다른 모델의 양자화 버전입니다.\n\n이 예에서는 Mistral 7B Instruct v0.2 — GGUF라는 모델을 사용할 것입니다 (그리고 이외에도 1개의 아주 작은 모델이 있습니다. 아래 참조).\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 모델은 Mistral-7B-Instruct-v0.2라고 하는 원래 모델의 양자화된 버전입니다. 해당 Hugging Face 페이지를 확인할 수 있습니다 (해당 페이지에서 파일을 다운로드하지 마세요!) 및 Readme 페이지(주 페이지)의 정보, 파일 확장명 등을 양자화된 모델의 정보와 비교할 수 있습니다. 이 모델은 오픈 소스 LLMs 분야에서 중요한 역할을 하는 Mistral이 개발한 것입니다.\n\n다시 양자화된 모델 페이지(Mistral 7B Instruct v0.2 - GGUF)로 돌아가면, 다양한 크기의 버전을 다운로드할 수 있으며 필요한 최대 RAM을 확인할 수 있습니다. 4GB 컴퓨터로는 이 모델을 실행하기 어려울 것으로 보입니다 (이 섹션 맨 끝에 작은 모델을 나열해 두겠습니다). 8GB 컴퓨터를 사용하는 경우, 가장 무거운 모델을 실행할 수 없을 것입니다. 제 경우에는 mistral-7b-instruct-v0.2.Q4_K_M.gguf를 다운로드하기로 결정했습니다:\n\n- Q4_K_M은 양자화 방법입니다.\n- 파일 크기는 4.37GB입니다.\n- 6.87GB의 RAM이 필요합니다.\n\n![이미지](/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_3.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 더 작은 모델\n\n더 작은 모델을 사용하려면 TinyLlama-1.1B-Chat-v1.0-GGUF를 시도해볼 수 있어요.\n\n저도 사용할 거에요 (Taipy 앱을 위해), 왜냐하면 더 가벼우니까요 (더 빠르고... 그리고 덜 정확하죠). Mistral 7B Instruct v0.2 — GGUF와 똑같은 과정이에요.\n\n## 모델과 대화하기 위한 일부 Python 라이브러리\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 파이썬 방식에 따라 가시려면, 여기 몇 가지 라이브러리를 소개해 드릴게요. 이 라이브러리들을 사용하면 로컬 또는 비로컬로 간단한 채팅 인터페이스를 만들 수 있어요:\n\n- Taipy : 이 글의 마지막 부분에서 로컬 모델을 위한 매우 간단한 Taipy 채팅을 어떻게 만드는지 보여드릴 거에요.\n- Streamlit : Streamlit 애플리케이션을 만드는 것도 쉬워요. 다양한 튜토리얼이 많이 있어요.\n- Gradio : Gradio 앱은 Hugging Face 생태계에서 인기가 있어요. 이것을 아직은 제가 잘 알지 못하긴 한데요.\n\n# GPT4All 사용하기\n\nGPT4All은 로컬 컴퓨터에서 실행되는 채팅 인터페이스에요. 홈페이지에서 직접 설치 파일을 다운로드할 수 있어요. Windows용으로는 .exe 파일이며, 열어서 설치하면 되요... 그렇게 간단해요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위 이미지를 보시면 ChatGPT의 인터페이스와 비슷하게 보입니다:\n\n![ChatGPT Interface](/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_4.png)\n\n상당히 직관적인 것 같아요. 그러나 위 그림에 있는 것과 같이 3가지 중요한 요소를 언급하고 싶어요:\n\n- 프롬프팅 존... 이용하기 전에 모델을 로드해야 해요!\n- 왼쪽 상단의 \"버거 메뉴\"를 통해 채팅 기록을 확인할 수 있고, 해당 채팅에 사용한 모델을 기억합니다... 여기서 인터페이스에서 모델을 직접 다운로드할 수도 있어요.\n- 설정 버튼. 여기서 HuggingFace나 다른 곳에서 GGUF 파일을 다운로드할 디렉토리를 볼 수 있어요. 올바른 폴더에 다운로드하면 GPT4all이 그 파일들을 \"인식\"할 거예요.\n- 폴더에 여러 모델이 있는 경우, GUI 상단 중앙의 메뉴로 선택할 수 있어요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## GPT4All에서 모델 다운로드하기\n\nGPT4All에서 모델을 다운로드하려면 화면 오른쪽 상단의 버거 메뉴로 이동하십시오. 그리고 \"다운로드\"를 선택하십시오.\n\n![다운로드](/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_5.png)\n\n선택할 모델 목록이 표시됩니다. 원하는 모델을 선택하고 \"다운로드\"를 클릭하면 첫 번째 모델을 사용할 수 있습니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n미스트랄의 OpenOrca를 사용하고 있는데, 이 채팅 봇은 상당히 좋아요. 여기에서는 API 키를 제공하여 ChatGPT 모델을 선택할 수도 있습니다. 이 마지막 옵션은 아직 시도해보지 않았는데, 개인적으로는 의미가 없다고 생각해요.\n\n![이미지](/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_6.png)\n\n## 다른 모델을 다운로드할 GPT4All 폴더 선택하기\n\nHuggingFace와 같은 다른 모델을 사용하고 싶다면, 그 모델이 GPT4All이 모델을 찾는 폴더에 다운로드하면 됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n해당 위치를 찾으려면 설정 메뉴(오른쪽 상단의 작은 휠)를 클릭하세요. \"애플리케이션\"을 선택합니다. 로컬 폴더 경로는 \"다운로드 경로\" 옆에 있습니다:\n\n![이미지](/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_7.png)\n\n첫 번째 LLM 모델을 로컬에서 실행하는 가장 쉬운 방법은 아니더라도 가깝습니다! 즐겁게 사용하시길 바랍니다!\n\n# LangChain 사용하기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n알림: 이 방법은 Python의 기본적인 이해가 필요하지만 따르기 쉬워요. 노트북 사용자들(Jupyter Notebook, JupyterLab...)에 적합해요.\n\nLangChain은 LLM (Language Model)을 사용하여 LLM 애플리케이션을 만들 수 있게 해주는 Python 라이브러리에요 (당연한 얘기겠지만... LangChain과 LLM이 없이도 앱을 만들 수는 있어요. 다만, 그것들은 LLM 앱이 아닐 뿐이죠). LangChain은 데이터베이스에 연결하거나 문서나 웹을 파싱하거나 다양한 서비스에 쿼리를 날리는 API 클라이언트 등 Python 라이브러리들과 연결할 수 있어요.\n\n이번에는 LangChain을 사용하여 GGUF 파일을 가져와 대화하는 방법을 알려드릴게요.\n\nLangChain을 사용하기 위해 다음이 필요해요: \n\n- Langchain_community: Langchain을 위한 타사 통합 기능을 포함하고 있어요.\n- llama_cpp_python: llama.cpp를 위한 Python 바인더에요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nLlama.cpp은 다른 파일들과 함께 GGUF 파일을 다룰 수 있게 해줍니다!\n\n여기 나타난 예시를 보면, 단순히 llama_cpp_python만 사용할 수도 있지만, LangChain을 익히는 것이 더 좋은 아이디어이며 복잡성을 더하는 일이 거의 없습니다.\n\nJupyterLab을 사용하여 LLM 모델을 호출할 것이고, 이 작업은 다른 어떤 노트북이나 ^Python 파일에서도 작동해야 합니다.\n\n먼저 라이브러리를 가져와주세요:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nfrom langchain.callbacks.manager import CallbackManager\nfrom langchain.callbacks.streaming_stdout import StreamingStdOutCallbackHandler\nfrom langchain.prompts import PromptTemplate\nfrom langchain_community.llms import LlamaCpp\n```\n\n그 후, GGUF 파일로 모델 변수를 만들어보세요. 선택적으로 callback_manager도 만들 수 있습니다:\n\n```python\nmodel = \"path/to/model/mistral-7b-instruct-v0.2.Q4_K_M.ggu\"\n\n# Callbacks support token-wise streaming\ncallback_manager = CallbackManager([StreamingStdOutCallbackHandler()])\n```\n\n이제, prompts를 인수로 받아 답변을 생성할 llm 객체를 만들 수 있습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nllm = LlamaCpp(\n    model_path=model,\n    callback_manager=callback_manager, #Optional, streams the response as it is generated\n    verbose=True,  # Verbose is required to pass to the callback manager\n)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nprompt_addon = \"\u003cs\u003e[INST]파이썬 명령어를 만들어 'hello world'를 출력하도록 합니다[/INST]print('hello world')\u003c/s\u003e\"\nprompt = \"\"\"\n주어진 숫자까지의 피보나치 수열을 반환하는 파이썬 함수를 작성하십시오. 독스트링을 추가하세요.\n\"\"\"\nllm.invoke(f\"{prompt_addon}[INST]{prompt}[/INST]\")\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_8.png\" /\u003e\n\n# Taipy를 사용하여 작은 채팅 인터페이스 만들기\n\nLangChain 보드 대신에, Taipy와 같은 Python 웹 애플리케이션 빌더와 함께 사용할 수 있습니다. 이 라이브러리에 대해 더 알고 싶으시다면, 이전에 관련한 기사를 썼었지만, 라이브러리에 대해 많이 알지 못해도 어플리케이션을 작동시킬 수 있을 것입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저는 다음 예시를 Taipy 팀의 튜토리얼에서 수정했어요. 그래서 많은 창의성은 그들에게 돌아갑니다. 다른 점은 OpenAI의 GPT 모델(그들의 API로) 대신 로컬 모델을 사용한다는 것이에요.\n\n위 예시의 라이브러리들(LangChain와 Llama_Cpp)이 필요하고 당연히 Taipy를 설치해야 해요 ( pip install taipy ).\n\nPython 함수와 Taipy 코드를 모두 넣을 main.py 라는 파일을 만들어야 해요.\n\n첫째, 라이브러리를 가져와요. 앱이 채팅을 표시할 것이기 때문에 출력을 스트리밍할 필요 없어요. 그냥 가져오세요:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nfrom langchain.callbacks.manager import CallbackManager\nfrom langchain_community.llms import LlamaCpp\nfrom taipy.gui import Gui, State\n```\n\n타이피(Taipy)에서 상태(State)는 앱에서 변수의 \"현재 상태\"를 가리킵니다. 이러한 변수에 초기 값을 할당한 후, 그 값은 앱에서 변경됩니다: 사용자가 값 변경하거나 함수의 결과로 값이 변경될 수 있습니다.\n\n두 개의 변수, conversation(대화)와 current_user_message(현재 사용자 메시지)를 만들어 봅시다. 대화는 대화창에 보낸 메시지와 그에 대한 답변의 기록입니다. current_user_message는 사용자가 프롬프트로 입력할 메시지를 나타냅니다.\n\n성능상의 이유로 tinyllama-1.1b-chat-v1.0.Q4_K_M 모델을 사용하겠습니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n대화 = {\n    \"Conversation\": [\n        \"너 누구니?\",\n        \"안녕! 나는 작은 LLama야. 너의 컴퓨터에서 돌아가는 모델이지. 오늘 어떻게 도와줄까?\",\n    ]\n}\n\ncurrent_user_message = \"\"\n```\n\n다음으로, 모델을 실행하는 함수를 만들어보겠어요. 여기서 예시로 Tiny LLama 모델 GGUF 파일을 사용합니다.\n\n```js\n모델 = (\n    \"경로/모델/tinyllama-1.1b-chat-v1.0.Q4_K_M.gguf\"\n)\n\nllm = LlamaCpp(model_path=모델)\n```\n\n그런 다음, 채팅을 처리하는 2개의 함수를 만들 수 있어요. 먼저, 모델에 질문을 보내고 답변을 받는 request()라는 함수를 정의해주세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n**Note:** The function generates a prompt based on the model specified in the documentation. According to the documentation, you should follow the prompt template \"Zephyr\", which is different from the one used for Mistral 7B shown above:\n\n```js\n\u003c|system|\u003e\n{system_message}\u003c/s\u003e\n\u003c|user|\u003e\n{prompt}\u003c/s\u003e\n\u003c|assistant|\u003e\n```\n\nBelow is the function:\n\n```js\ndef request(state: State, prompt: str, conv_list: list) -\u003e str:\n    \"\"\"\n    Send a prompt to the local LLM and return the response.\n\n    Args:\n        - state: The current state.\n        - prompt: The prompt to send to the LLM.\n\n    Returns:\n        The response from the LLM.\n    \"\"\"\n\n    # Get the previous conversations to create the prompt history\n    system_message = \"\u003c|system|\u003e\\nYou are a geography expert and assist users by answering their questions\u003c/s\u003e\\n\"\n    # Get the previous conversations to create the prompt history\n    history_prompt = \"\"\n    for index, conv_element in enumerate(conv_list):\n        if index % 2 == 0:\n            history_prompt += f\"\u003c|user|\u003e\\n{conv_element}\u003c/s\u003e\\n\"\n        else:\n            history_prompt += f\"\u003c|assistant|\u003e\\n{conv_element}\u003c/s\u003e\\n\"\n    full_prompt = (\n        f\"{system_message}{history_prompt}\u003c|user|\u003e\\n{prompt}\u003c/s\u003e\\n\u003c|assistant|\u003e\"\n    )\n\n    response = state.llm(full_prompt)\n\n    return response\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그리고 이제 Taipy GUI 인터페이스와 상호 작용하는 send_message() 함수를 정의할 수 있습니다:\n\n```js\ndef send_message(state: State) -\u003e None:\n    \"\"\"\n    사용자의 메시지를 llm 함수로 전송합니다.\n    Args:\n        - state: 현재 상태.\n    \"\"\"\n    # 입력 필드 지우기\n    conv = state.conversation._dict.copy()\n\n    # 사용자 질문을 지역 LLM 모델에 요청합니다.\n    conv_list = conv[\"Conversation\"]\n    answer = request(state, state.current_user_message, conv_list).replace(\"\\n\", \"\")\n\n    conv[\"Conversation\"] += [state.current_user_message, answer]\n    state.current_user_message = \"\"\n    state.conversation = conv\n```\n\n## 사용자 인터페이스 만들기\n\n페이지를 초기화하려면 아래 코드를 추가하면 됩니다. 페이지 객체는 페이지 구조를 정의합니다. 원하신다면 markdown 구문을 추가할 수 있습니다(제목 또는 원하는 내용). 여기에는 없습니다. 그리고 Taipy 요소를 `|...|` 사이에 추가할 수 있습니다. 더 자세한 정보가 필요하다면 Taipy에 관한 다른 글을 참조하는 것을 권장합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\npage = \"\"\"\n\u003c|{대화}|table|show_all|\u003e\n\u003c|{current_user_message}|input|label=메시지를 입력하세요...|on_action=send_message|class_name=fullwidth|\u003e\n\"\"\"\n\nif __name__ == \"__main__\":\n    Gui(page).run(dark_mode=True, title=\"Taipy와 지역 LLM 채팅\")\n```\n\n## 선택 사항: CSS 변경\n\nTaipy의 튜토리얼에는 CSS 코드와 적용하는 함수가 있습니다. 여기에 완벽한 지침이 있도록 무심코 그것을 복사합니다. 이 부분에 대해 100%의 크레딧은 그들에게 갑니다.\n\nmain.py 파일 옆에 main.css 파일을 만들어 다음 코드를 붙여넣으세요:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n.gpt_message td {\n    margin-left: 30px;\n    margin-bottom: 20px;\n    margin-top: 20px;\n    position: relative;\n    display: inline-block;\n    padding: 20px;\n    background-color: #ff462b;\n    border-radius: 20px;\n    max-width: 80%;\n    box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);\n    font-size: large;\n}\n\n.user_message td {\n    margin-right: 30px;\n    margin-bottom: 20px;\n    margin-top: 20px;\n    position: relative;\n    display: inline-block;\n    padding: 20px;\n    background-color: #140a1e;\n    border-radius: 20px;\n    max-width: 80%;\n    float: right;\n    box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);\n    font-size: large;\n}\n```\n\n그리고 다음 Python 함수를 만들어주세요. 해당 함수는 main.py 파일에 위치시키실 수 있습니다. 이 함수는 페이지에 스타일을 적용합니다:\n\n```js\ndef style_conv(state: State, idx: int, row: int) -\u003e str:\n    \"\"\"\n    Apply a style to the conversation table depending on the message's author.\n\n    Args:\n        - state: The current state of the app.\n        - idx: The index of the message in the table.\n        - row: The row of the message in the table.\n\n    Returns:\n        The style to apply to the message.\n    \"\"\"\n    if idx is None:\n        return None\n    elif idx % 2 == 0:\n        return \"user_message\"\n    else:\n        return \"gpt_message\"\n```\n\n다음으로, 페이지 객체를 수정하시어 스타일이 적용되도록 하실 수 있습니다. 아래와 같이 conversation 요소에 style=style_conv|를 추가해주세요:\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n페이지 = \"\"\"\n\u003c|{conversation}|표|모든_표시|스타일=style_conv|\u003e\n\u003c|{current_user_message}|입력|레이블=여기에 메시지를 입력하세요...|작업=send_message|클래스_이름=전체너비|\u003e\n\"\"\"\n```\n\n## 앱 실행하기\n\n앱을 실행하려면 main.py 파일을 다른 Python 파일처럼 호출하면 됩니다!\n\n아래 이미지에서 보시다시피, 작은 모델이 좋지 않고 지리가 주 용도가 아닌 것 같습니다. 하지만 한 가지 확실한 것은 웹 앱에서 로컬 모델이 실행되고 있다는 것이며, 이것은 정말 멋집니다!\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_9.png)\n\nThank you for reading!\n\nIf you enjoyed my content and would like to connect:\n\n👉 You can connect with me on LinkedIn\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n👉 제 개인 웹사이트를 확인해보세요","ogImage":{"url":"/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-HowtorunyourfirstlocalLLMs_0.png","tag":["Tech"],"readingTime":22},{"title":"PapersWithCode와 채팅할 수 있는 LLM-Powered 앱 만드는 방법","description":"","date":"2024-07-13 20:10","slug":"2024-07-13-HowToBuildanLLM-PoweredAppToChatwithPapersWithCode","content":"\n\n최신 기계 학습 연구 소식을 따라가기 어려우신가요? LLMs, 벡터 데이터베이스 또는 RAGs에 관한 논문 양에 압도당하셨나요?\n\n백엔드 쪽에서는, 이 어시스턴트는 RAG(Retrieval Augmented Generation) 프레임워크로 구동될 것입니다. 이는 확장 가능한 서버리스 벡터 데이터베이스, VertexAI의 임베딩 모델, 그리고 OpenAI의 LLM을 활용합니다.\n\n프론트엔드 쪽에서는 이 어시스턴트가 Streamlit으로 제작된 인터랙티브하고 쉽게 배포 가능한 웹 애플리케이션에 통합될 것입니다.\n\n이 프로세스의 모든 단계는 아래에서 자세히 설명되며, 재사용하고 수정할 수 있는 동반되는 소스 코드가 함께 제공됩니다👇.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n준비되셨나요? 함께 알아봐요 🔍.\n\n독자 분들께서 독해를 시작하기 전에, 여기 Github에서 전체 소스 코드를 확인하실 수 있어요.\n\n# 1 — Papers With Code로부터 데이터 수집\n\nPapers With Code(일명 PWC)는 연구원과 실무자들을 위한 무료 웹사이트로, 최신의 최첨단 머신러닝 논문, 소스 코드, 데이터 세트를 찾고 따르는 곳이에요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-HowToBuildanLLM-PoweredAppToChatwithPapersWithCode_0.png\" /\u003e\n\n다행히도, PWC와 상호 작용하여 연구 논문을 프로그래밍 방식으로 검색할 수도 있습니다. 이 Swagger UI를 살펴보면 모든 사용 가능한 엔드포인트를 찾고 시도해 볼 수 있습니다.\n\n예를 들어, 특정 키워드로 논문을 검색해 보겠습니다.\n\n인터페이스에서 이렇게 할 수 있습니다: papers/ 엔드포인트를 찾아 쿼리( q ) 인자를 채웁니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n표 태그를 Markdown 형식으로 바꾸세요.\n\n그리고 실행 버튼을 클릭하세요.\n\n동등하게, 이 동일한 검색을 수행하려면 다음 URL을 클릭하면 됩니다.\n\n출력 응답은 결과의 첫 페이지만을 보여줍니다. 다음 페이지는 \"next\" 키에 접근하여 이용할 수 있습니다.\n\n이 구조를 이용하면 \"대형 언어 모델\"에 일치하는 7200개의 논문을 검색할 수 있습니다. URL을 요청하는 함수를 이용하여 모든 페이지에 대해 루프를 돌림으로써 간단히 수행할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nimport requests\nimport urllib.parse\nfrom tqdm import tqdm\n\ndef extract_papers(query: str):\n    query = urllib.parse.quote(query)\n    url = f\"https://paperswithcode.com/api/v1/papers/?q={query}\"\n    response = requests.get(url)\n    response = response.json()\n    count = response[\"count\"]\n    results = []\n    results += response[\"results\"]\n\n    num_pages = count // 50\n    for page in tqdm(range(2, num_pages)):\n        url = f\"https://paperswithcode.com/api/v1/papers/?page={page}\u0026q={query}\"\n        response = requests.get(url)\n        response = response.json()\n        results += response[\"results\"]\n    return results\n\nquery = \"Large Language Models\"\n\nresults = extract_papers(query)\n\nprint(len(results))\n# 7200\n```\n\n결과를 추출하면 해당 결과를 기반이로 LangChain 문서로 변환하여 단순히 청크화하고 색인화합니다.\n\n문서 객체에는 두 개의 매개변수가 있습니다:\n\n- page_content (str): 논문 초록의 텍스트를 저장하는 매개변수\n- metadata (dict): 추가 정보를 저장하는 매개변수. 우리의 사용 사례에서는 id, arxiv_id, url_pdf, 타이틀, 저자, 발표일을 유지할 것입니다\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nfrom langchain.docstore.document import Document\n\ndocuments = [\n    Document(\n        page_content=result[\"abstract\"],\n        metadata={\n            \"id\": result[\"id\"] if result[\"id\"] else \"\",\n            \"arxiv_id\": result[\"arxiv_id\"] if result[\"arxiv_id\"] else \"\",\n            \"url_pdf\": result[\"url_pdf\"] if result[\"url_pdf\"] else \"\",\n            \"title\": result[\"title\"] if result[\"title\"] else \"\",\n            \"authors\": result[\"authors\"] if result[\"authors\"] else \"\",\n            \"published\": result[\"published\"] if result[\"published\"] else \"\",\n        },\n    )\n    for result in results\n]\n```\n\n문서를 임베드하기 전에 작은 조각들로 나눠야 합니다. 이렇게 하면 LLMs의 입력 토큰 관련 제한을 극복할 수 있고 각 조각마다 세부 정보를 제공할 수 있습니다.\n\n우리는 길이가 1200 자이며 chunk_overlap가 200 인 Chunking을 통해 문서를 나누었더니 11,000개가 넘는 조각들이 생성되었습니다.\n\n```python\ntext_splitter = RecursiveCharacterTextSplitter(\n    chunk_size=1200,\n    chunk_overlap=200,\n    separators=[\".\"],\n)\nsplits = text_splitter.split_documents(documents)\n\nlen(splits)\n# 11308\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 2 — 업스태시에서 인덱스 생성하기\n\n문서 임베딩(및 메타데이터)을 저장하기 위해서는 먼저 인덱스를 생성해야 합니다.\n\n이 튜토리얼에서는 서버리스 데이터베이스인 업스태시를 사용할 것입니다.\n\n인덱스를 생성하려면 여기에 로그인하고 몇 가지 매개변수를 입력하는 지침을 따르면 됩니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 지역: 근처에 위치한 지역을 선택해주세요.\n- 차원 = 768로 설정하세요(VertexAI의 임베딩 차원)\n- 거리 메트릭 = 코사인으로 설정하세요.\n\n인덱스를 만든 후에는 upstash-vector를 설치해야 합니다.\n\n```js\npip install upstash-vector\n```\n\n이를 통해 인덱스에 연결을 설정할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nfrom upstash_vector import Index\n\nindex = Index(\n    url=\"\u003cUPSTASH_URL\u003e\", \n    token=\"\u003cUPSTASH_TOKEN\u003e\"\n)\n```\n\n# 3 — Embed the chunks and index them into Upstash\n\nTo embed the chunks and index them into the vector db, we’ll create a simple class that imitates LangChain Vectorstore implementation.\n\nThis class will be named UpstashVectorStore and will have the following methods:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Upstash Vector Store 클래스의 __init__ 생성자는 Upstash Index와 Embeddings 객체를 예상합니다.\n- 문서를 임베딩하고 일괄적으로 색인에 추가하려면 add_documents 를 사용합니다.\n- similarity_search_with_score 를 사용하여 인덱스를 쿼리하고 상위 k개의 가장 관련성 높은 문서 및 해당 점수를 검색합니다.\n\n다음은 전체 구현입니다:\n\n```js\nfrom typing import List, Optional, Tuple, Union\nfrom uuid import uuid4\nfrom langchain.docstore.document import Document\nfrom langchain.embeddings.base import Embeddings\nfrom tqdm import tqdm\nfrom upstash_vector import Index\n\n\nclass UpstashVectorStore:\n    def __init__(self, index: Index, embeddings: Embeddings):\n        self.index = index\n        self.embeddings = embeddings\n\n    def delete_vectors(\n        self,\n        ids: Union[str, List[str]] = None,\n        delete_all: bool = None,\n    ):\n        if delete_all:\n            self.index.reset()\n        else:\n            self.index.delete(ids)\n\n    def add_documents(\n        self,\n        documents: List[Document],\n        ids: Optional[List[str]] = None,\n        batch_size: int = 32,\n    ):\n        texts = []\n        metadatas = []\n        all_ids = []\n\n        for document in tqdm(documents):\n            text = document.page_content\n            metadata = document.metadata\n            metadata = {\"context\": text, **metadata}\n            texts.append(text)\n            metadatas.append(metadata)\n\n            if len(texts) \u003e= batch_size:\n                ids = [str(uuid4()) for _ in range(len(texts))]\n                all_ids += ids\n                embeddings = self.embeddings.embed_documents(texts, batch_size=250)\n                self.index.upsert(\n                    vectors=zip(ids, embeddings, metadatas),\n                )\n                texts = []\n                metadatas = []\n\n        if len(texts) \u003e 0:\n            ids = [str(uuid4()) for _ in range(len(texts))]\n            all_ids += ids\n            embeddings = self.embeddings.embed_documents(texts)\n            self.index.upsert(\n                vectors=zip(ids, embeddings, metadatas),\n            )\n\n        n = len(all_ids)\n        print(f\"Successfully indexed {n} dense vectors to Upstash.\")\n        print(self.index.stats())\n        return all_ids\n\n    def similarity_search_with_score(\n        self,\n        query: str,\n        k: int = 4,\n    ) -\u003e List[Tuple[Document, float]]:\n        query_embedding = self.embeddings.embed_query(query)\n        query_results = self.index.query(\n            query_embedding,\n            top_k=k,\n            include_metadata=True,\n        )\n        output = []\n        for query_result in query_results:\n            score = query_result.score\n            metadata = query_result.metadata\n            context = metadata.pop(\"context\")\n            doc = Document(\n                page_content=context,\n                metadata=metadata,\n            )\n            output.append((doc, score))\n        return output\n```\n\n이 클래스를 사용하여 청크를 색인화해 봅시다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nfrom langchain.embeddings import VertexAIEmbeddings\nfrom upstash_vector import Index\n\nindex = Index(\n    url=\"\u003cUPSTASH_URL\u003e\",\n    token=\"\u003cUPSTASH_TOKEN\u003e\",\n)\nembeddings = VertexAIEmbeddings(model_name=\"textembedding-gecko@003\")\n\nupstash_vector_store = UpstashVectorStore(index, embeddings)\nids = upstash_vector_store.add_documents(splits, batch_size=25)\n```\n\n이 과정은 분할 수, 연결 속도 및 선택한 배치 크기에 따라 시간이 걸릴 수 있습니다.\n\n색인 프로세스가 완료되면 UI에서 벡터 및 해당 메타데이터를 확인할 수 있습니다: 이는 레코드의 빠른 검사와 쉬운 관리(예: 삭제)에 도움이 됩니다.\n\n# 4 — 색인 된 논문에 대한 질문하기\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n추상이 올바르게 Upstash에 색인된 상태로, 이제 자연어로 상호작용하며 ML 주제에 대한 구체적인 질문을 할 수 있습니다.\n\n이게 생각보다 훨씬 쉽습니다.\n\n이를 위해 먼저, 질문을 받아 관련 문서를 벡터 저장소에서 검색하고 이를 사용하여 프롬프트를 작성하는 함수를 정의합시다.\n\n```js\ndef get_context(query, vector_store):\n    results = vector_store.similarity_search_with_score(query)\n    context = \"\"\n\n    for doc, score in results:\n        context += doc.page_content + \"\\n===\\n\"\n    return context\n\ndef get_prompt(question, context):\n    template = \"\"\"\n    주어진 문맥을 사용하여 질문에 답하는 것이 여러분의 작업입니다.\n\n    문맥 외의 것을 꾸며내지 마세요.\n    적어도 350자 이상으로 대답해 주세요.\n\n    %CONTEXT%\n    {context}\n\n    %Question%\n    {question}\n\n    Hint: 문맥을 그대로 복사하지 마세요. 여러분만의 말로 표현해 주세요.\n    \n    대답:\n    \"\"\"\n    prompt = template.format(question=question, context=context)\n    return prompt\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n영감이 떨어질 때가 있죠? 시작하는 데 도움이 될 질문이에요:\n\n```js\nquery = (\n    \"Retrieval Augmented Generation (RAG) 프레임워크 뒤의 문제는 무엇인가요?\"\n)\n\ncontext = get_context(query, upstash_vector_store)\nprompt = get_prompt(query, context)\n```\n\n다음은 문맥을 받은 후의 프롬프트 모습입니다:\n\n```js\n주어진 문맥을 활용해 질문에 답해 보는 것이 당신의 과제입니다.\n\n문맥 밖의 것은 광장을 만들지 마세요.\n적어도 350자 이상으로 답하세요.\n\n%CONTEXT%\n\nRetrieval-Augmented Generation (RAG)은 대규모 언어 모델의 환각을 완화하기 위한 \n유망한 접근 방식입니다. 그러나 기존 연구는 서로 다른 대규모 언어 모델에 대한 \n검색 증강 생성의 영향에 대한 철저한 평가가 부족하여, 서로 다른 대규모 언어 모델에 \n대한 RAG의 능력에 대한 잠재적 병목 현상을 식별하는 것이 어려운 상황입니다. \n우리는 이 논문에서 Retrieval-Augmented Generation이 대규모 언어 모델에 미치는 영향을 \n체계적으로 조사합니다. RAG가 요구하는 4가지 기본 능력인 노이즈 강건성, 부정 거부, \n정보 통합 및 반사적 강건성에 대한 다양한 대규모 언어 모델의 성능을 분석합니다. \n이를 위해 RAG 평가를 위한 새로운 말뭉치인 Retrieval-Augmented Generation \nBenchmark (RGB)를 설정합니다. 이 RGB는 영어와 중국어 모두에서 RAG 평가에 사용되는 \n새로운 말뭉치로, 해당 말뭉치 내의 인스턴스를 의미 있는 능력에 따라 4개의 별도의 \n테스트베드로 분류합니다. 그런 다음 RGB에서 6개의 대표적인 대규모 언어 모델을 \n평가하여 RAG를 적용할 때 현재 대규모 언어 모델의 도전에 대해 진단합니다.\n===\n대단한 능력을 갖고 있지만 대규모 언어 모델(LM)은 종적으로 알려진 정보에만 의존하여 \n사실적인 정확성을 가지지 않는 응답을 종종 생성합니다. Retrieval-Augmented Generation \n(RAG)은 LM을 관련 지식 검색으로 보완하는 무작위 접근법으로 이러한 문제를 줄입니다. \n그러나 검색이 필요한지, 또는 지식이 관련성이 있는지 여부에 상관없이 일정 수의 검색 \n내용을 무작위로 가져와 포함한다면, LM의 다양성이 감소하거나 도움이 되지 않는 \n응답 생성으로 이어질 수 있습니다. 우리는 Self-Reflective Retrieval-Augmented \nGeneration(Self-RAG)이라는 새로운 프레임워크를 소개합니다. 이 프레임워크는 검색 및 \n자기 반성을 통해 LM의 품질과 정확성을 향상시킵니다. 우리의 프레임워크는 필요 시 \n검색 결과를 가져와 동적으로 변화시키며, 특수 토큰인 반성 토큰을 사용하여 검색 결과와 \nLM의 생성물을 생성하고 반성합니다. 반성 토큰을 생성하면 LM이 추론 단계에서 조절 가능해져 \n다양한 작업 요구에 맞게 동작할 수 있습니다.\n...\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 LLM에게 대답 생성을 요청해보세요.\n\n```js\nfrom langchain.chat_models import AzureChatOpenAI\n\nllm = AzureChatOpenAI(\n    azure_deployment=\"\u003cAZURE_DEPLOYMENT\u003e\",\n    model=\"\u003cMODEL_NAME\u003e\",\n)\n\nanswer = llm.predict(prompt)\n```\n\n왔쪄요! 🥁\n\n```js\n검색 증강 생성 (RAG) 프레임워크는 핍을 피할 수 없는 검색 및 필요하지 않거나 관련성 없는 단락을 포함하여 도움이 되지 않는 응답 생성으로 이어질 수 있는 문제와 같은 문제가 있을 수 있습니다. 또한, 기존 연구는 RAG가 다양한 대형 언어 모델 (LLM)에 미치는 영향을 철저히 평가하지 않아 RAG의 다양한 LLM에 대한 기능 병목 현상을 식별하기 어렵게 만들고 있습니다. 이러한 문제를 해결하기 위해, 연구자들은 자기 반성 검색 증강 생성(Self-RAG) 프레임워크를 제안했으며, 이 프레임워크는 검색 및 자기 반성을 통해 LM의 품질과 사실성을 향상시킵니다. LLM의 다른 문제점 중 하나는 그들의 잊기죽임입니다. 그들은 시간이 흐를수록 개선되지 않거나 인간처럼 새로운 지식을 습득하지 않습니다. 이를 해결하기 위해, 연구자들은 RAG를 사용하여 문제 해결 성능을 향상시키는 방법을 탐구하고, ARM-RAG 시스템을 제안했습니다. 이 시스템은 높은 훈련 비용이 필요 없이 성공을 통해 학습합니다.\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n꽤 괜찮지 않아요?\n\n## 이 다이어그램으로 전체 워크플로우를 요약해 볼게요.\n\n# 5— Streamlit 애플리케이션에 통합하기\n\nUI에서 RAG와 상호 작용하기 위해 Streamlit 애플리케이션에 통합할 수 있어요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음은 Markdown 형식으로 변환한 것입니다:\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*zFIzwP4z8xmmvXSZFdnM8w.gif)\n\n혹시 앱을 로컬에서 시도해보고 코드를 만져보고 싶으시면 언제든지 환영합니다.\n\n# 몇 가지 핵심 포인트\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n많은 분들이 이미 자료와 대화하는 RAGs를 구축하셨습니다.\n\n제가 실제로 그러한 프로젝트의 실용성에 대해 솔직한 피드백을 드리겠습니다. 제 목표는 여러분이 RAGs를 만들지 않도록 방해하는 것이 아니라 이러한 솔루션에 대한 과대광고를 완화시키기 위해 세심한 의견을 제공하는 것입니다.\n\n우선 이점에서 시작해보겠습니다:\n\n- RAGs를 통해 외부 자료에 접근할 수 있습니다. 예를 들어, 저희가 개발한 앱은 Mistral이나 LLama2와 같은 최근 오픈 소스 LLM에 대한 정확한 답변을 제공합니다.\nChatGPT에 이러한 모델에 대해 질문을 하면 얻을 수 있는 것들을 확인해보세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n\n![RAGs 사용 예시](/TIL/assets/img/2024-07-13-HowToBuildanLLM-PoweredAppToChatwithPapersWithCode_1.png)\n\n- RAG를 사용하면 생성된 응답을 지탱하는 소스 문서를 인용할 수 있습니다. 이는 사용자 신뢰를 높이고 디버깅 및 해석 가능성에 도움을 줍니다.\n- RAG는 답변을 지탱하기 위해 외부 데이터만 활용하므로 LLM의 환형 경향을 제한합니다.\n- RAG는 상대적으로 쉽게 구축할 수 있습니다. 모델을 훈련하거나 세부 조정할 필요가 없기 때문에 비싼 컴퓨팅 자원이 필요하지 않습니다.\n\n그러나 RAG는 마법같이 즉시 해결되는 해결책은 아닙니다. \"기업\" 세계에서 이를 산업화하려면 고려해야 할 중요한 측면이 있습니다.\n\n- 그들의 영향력은 제공된 데이터에 따라 달라집니다. 예시 앱에서 우리는 논문 초록만 사용했습니다. 이는 일반적인 질문에 답변하는 데 좋은 시작점을 제공하지만 쿼리가 너무 복잡하고 전체 텍스트에 액세스가 필요한 경우에는 도움이 되지 않습니다.\n- 외부 구현된 RAG는 잘 작동하는 경우가 드뭅니다. 데모 목적으로는 좋지만 답변을 심층적으로 조사하기 시작하면 품질이 실망스러움을 빨리 깨닫게 됩니다. 그래서 철저한 조정, 평가 지표 및 인간의 개입이 필요합니다.\n- RAG는 모든 것에 대한 해결책이 아닙니다. 스타일 복사와 같은 일부 응용 프로그램은 모델 세부 조정으로 수행하는 것이 더 나은 결과를 보입니다.\n- RAG는 LLM의 컨텍스트 크기에 의해 제한됩니다. LLM의 컨텍스트 크기가 1백만 토큰이 되더라도 해당 데이터 양으로 프롬프트하는 것이 좋은 아이디어는 아닙니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론\n\n지금까지 읽어주셔서 감사합니다.\n\n만약 이 어시스턴트를 향상시키고 다음 단계로 나아가길 원한다면, 아래 아이디어를 탐색하거나 구현해 보세요.\n\n- 요약이 아닌 전체 텍스트 사용\n- 메타데이터 필터링과 벡터 검색 보완\n- 밀도 검색이 아닌 하이브리드 검색 시도하기: 키워드 검색이 의왜 검색을 놀랍게 향상시킵니다.\n- 검색 후 문서 재랭크: 이를 통해 보다 많은 문서를 검색하고 중요한 것들을 자세히 살펴볼 수 있습니다.\n- 사용자 쿼리 확장\n- 임베딩 세밀 조정\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이전에 작성한 개선된 검색 기술에 관한 글이에요.\n\n여기 👇에서 확인해보세요.\n\n읽어 주셔서 감사합니다 📖.","ogImage":{"url":"/TIL/assets/img/2024-07-13-HowToBuildanLLM-PoweredAppToChatwithPapersWithCode_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-HowToBuildanLLM-PoweredAppToChatwithPapersWithCode_0.png","tag":["Tech"],"readingTime":18},{"title":"Python __all__ 이해하기 - 15초 설명","description":"","date":"2024-07-13 20:09","slug":"2024-07-13-__all__inPythonExplainedin15Seconds","content":"\n\n\n![image](/TIL/assets/img/2024-07-13-__all__inPythonExplainedin15Seconds_0.png)\n\n## Case 1: No __all__\n\n```python\n# a.py\n\na = 'apple'\nb = 'boy'\nc = 'cat'\nd = 'donkey'\ne = 'elephant'\nf = 'fish'\n```\n\n```python\n# b.py\n\nfrom a import *\n\nprint(dir())\n\n# [..., 'a', 'b', 'c', 'd', 'e', 'f']\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기서 from a import *는 a.py에서 모든 항목을 b.py로 가져옵니다. 이것이 b.py의 dir()에 a, b, c, d, e 및 f가 나타나는 이유입니다.\n\n# Case 2: __all__이 정의된 경우\n\n```python\n# a.py\n\na = 'apple'\nb = 'boy'\nc = 'cat'\nd = 'donkey'\ne = 'elephant'\nf = 'fish'\n\n__all__ = ['a', 'b']\n```\n\n```python\n# b.py\n\nfrom a import *\n\nprint(dir())\n\n# [..., 'a', 'b']\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위에서 \"from a import *\"은 a와 b만 가져옵니다. 이는 a.py의 __all__ 때문에 b.py에게 a와 b만 가져와야 한다고 알려주기 때문입니다.\n\n참고 - 이 작업은 \"from a import *\"에서만 작동합니다. 여전히 from a import c, d, e, f를 사용할 수 있습니다.\n\n# 왜/언제 사용해야 하는가\n\n만약 a.py에 무작위로 많은 것이 들어있지만 우리가 '내보낼' 것은 a와 b뿐이라면, 우리가 from a import *를 사용할 때 실수로 많은 불필요한 것들을 가져오지 않도록 하기 위해 __all__을 사용해야 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론\n\n이해하기 쉽고 명확했길 바랍니다.\n\n# 만약 제작자로서 저를 지원하고 싶다면\n\n- 이 이야기에 대해 50번 박수를 치세요\n- 귀하의 생각을 나에게 알려주는 댓글을 남겨주세요\n- 이야기 중 가장 좋아하는 부분을 강조해주세요\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n감사합니다! 이런 작은 조치들이 큰 도움이 되고, 정말 감사합니다!\n\nYouTube: [https://www.youtube.com/@zlliu246](https://www.youtube.com/@zlliu246)\n\nLinkedIn: [https://www.linkedin.com/in/zlliu/](https://www.linkedin.com/in/zlliu/)","ogImage":{"url":"/TIL/assets/img/2024-07-13-__all__inPythonExplainedin15Seconds_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-__all__inPythonExplainedin15Seconds_0.png","tag":["Tech"],"readingTime":3},{"title":"초보자를 위한 실용적 GPT-4 프롬프트 안내 쉽게 만드는 No-Code 지도와 보고서","description":"","date":"2024-07-13 20:08","slug":"2024-07-13-PragmaticGPT-4PromptingNiftyNo-CodeMapsandReportsforNoobs","content":"\n\n\n![Image](/TIL/assets/img/2024-07-13-PragmaticGPT-4PromptingNiftyNo-CodeMapsandReportsforNoobs_0.png)\n\n20년 이상의 컴퓨터 과학 교수로서, 데이터 시각화를 위해 Python 코딩을 하는 데 풍부한 경험이 있습니다.\n\n최근까지 아름다운 데이터 시각화 생성은 저와 같은 사람들 - 컴퓨터 프로그래머 및 데이터 분석가만의 영역이었습니다.\n\n그러나 지금은 GPT-4 채팅 인터페이스에 통합된 새로운 데이터 분석 도구들로 이것이 변화했습니다. 이제 실시간으로 지도와 차트를 생성할 수 있고, 그것들을 전체 PDF 보고서에 포함시킬 수 있습니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n태그를 Markdown 형식으로 변경하시면 됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n평화와 경제에 대한 비전을 갖춘 인스티튜트가 제공하는 경제와 평화에 관한 데이터는 Global Peace Index에서 다운로드할 수 있습니다.\n\n지금은 GPT-4가 오늘의 상태에서 데이터 파일을 다운로드할 수 없습니다. 이것이 이 LLM의 향후 버전에서 업데이트되길 희망하고 있습니다.\n\n이 링크에서 다운로드를 시작할 수 있습니다 (XSLX 형식). \n\n[![이미지](/TIL/assets/img/2024-07-13-PragmaticGPT-4PromptingNiftyNo-CodeMapsandReportsforNoobs_1.png)](링크)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파일을 다운로드하면 Excel(또는 Numbers)에서 열어서 \"Overall Scores\" 탭을 클릭할 수 있습니다. 다음과 같은 내용을 볼 수 있어요:\n\n![Overall Scores](/TIL/assets/img/2024-07-13-PragmaticGPT-4PromptingNiftyNo-CodeMapsandReportsforNoobs_2.png)\n\n다음으로는 이미지에서 강조된 첫 3행을 선택하여 삭제하고, 이 행들을 제거한 후에 이 시트를 global_peace_index.csv라는 CSV 파일로 내보낼 수 있어요. \n\n이제 GPT-4를 시작할 준비가 되었습니다. 채팅 창을 열고, 주 채팅 창에서 첨부 파일 아이콘을 클릭하세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-PragmaticGPT-4PromptingNiftyNo-CodeMapsandReportsforNoobs_3.png\" /\u003e\n\n컴퓨터에서 파일을 업로드하라는 메시지가 표시됩니다. 새로 만든 global_peace_index.csv 파일을 찾아 열기를 클릭해주세요.\n\nGPT-4가 이 파일에 액세스할 수 있게 되면, 파일에 대해 질문을 시작할 수 있습니다. 우선, GPT-4에게 이 CSV 파일에 대한 간단한 개요와 각 필드에 대한 설명을 요청해보겠습니다.\n\nGPT-4에게 요청하는 내용: 이 CSV 파일의 간단한 개요와 각 필드에 대한 설명을 제공해주시겠어요?\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nGPT-4의 응답:\n\n![이미지](/TIL/assets/img/2024-07-13-PragmaticGPT-4PromptingNiftyNo-CodeMapsandReportsforNoobs_4.png)\n\n와우! 지금까지 모든 것이 잘 진행 중입니다! 이제 데이터 시각화를 위해 프롬프트를 시작할 수 있을 거에요.\n\n하지만 어디서 시작해야 할까요? 우리가 알고 싶은 것은 무엇일까요? 잘 모르시나요? GPT-4에게 물어볼까요? 아마 여기서 좋은 아이디어가 있을지도 몰라요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n확실해요! 이 데이터세트에서 제공된 필드만 사용해서 데이터 시각화를 위한 5가지 좋은 아이디어를 제공할게요:\n\n- 시계열 분석: 특정 국가들의 GPI 점수 추이를 보여주기 위해 2008년부터 2022년까지 라인 차트를 만듭니다. 비교를 위해 세계 평균 선을 포함할 수 있습니다.\n- 세계 지도를 이용한 GPI 점수 시각화: 각 국가의 GPI 점수를 선택한 연도를 기준으로 시각적으로 나타내기 위해 세계 지도를 활용합니다. 사용자가 연도를 변경하고 세계 평화의 변화를 확인할 수 있는 인터랙티브 기능이 포함될 수 있습니다.\n- 지역평화 추세에 대한 비교 막대그래프: 국가들을 지역(유럽, 아시아, 아프리카 등)별로 그룹화하고 막대그래프를 사용하여 평균 GPI 점수를 표시합니다. 이를 통해 다양한 지역 간의 평화 수준을 비교할 수 있습니다.\n- 연도별 GPI 점수 분포를 위한 상자그림 분석: 각 연도별로 전체적인 GPI 점수 분포를 보여줍니다.\n- GPI 점수 변화를 나타내는 열지도: 각 국가의 2008년부터 2022년까지의 GPI 점수 변화를 시각화하기 위해 열지도를 생성합니다.\n\n좋은 아이디어들이에요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 GPT-4가 무엇을 생산할 수 있고 할 수 없는지 알고있는 지식이 유용할 때입니다. \n\n저는 이를 많이, 정말 많이 해봤기 때문에 이 결과를 기반으로 안내할 수 있어요. 이 5개의 응답에 대해 제가 아는 것은 다음과 같아요:\n\n- 아이디어 #2 — GPT-4는 아직 순간적으로 상호작용하는 시각화를 만들 수 없어요.\n- 아이디어 #3 — GPT-4는 가정을 했어요 — CSV 파일에는 데이터 그룹화가 없기 때문에 추가 데이터가 필요할 거에요.\n- 아이디어 #5 — GPT-4는 데이터 시각화의 최상의 관행을 명확하게 이해하고 있지 않아요. 히트맵을 만드는 데 추가적인 안내가 필요할 거예요.\n\n참고: 여기서 중요한 점은 GPT-4를 작업에 집중하도록 유도하는 것인데, LLM이 데이터셋의 필드를 사용하는 예제만 만들 수 있다는 것을 명확히 해야 해요. 그렇지 않으면 사용 가능한 필드로는 불가능한 가정을 할 가능성이 높아요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아이디어 #2는 좋은 시작점 같아요! 그럼 전세계 지도 시각화를 만들어볼까요?\n\n# 코로플레스 맵 생성\n\n코로플레스 맵은 나라별 전세계 평화 지수를 시각화하는 훌륭한 방법이에요.\n\n코로플레스 맵은 미리 정의된 지리적 영역에서 특정 데이터 변수를 나타내기 위해 다양한 음영/색상을 사용하는 테마틱 맵입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nGPT-4는 쉽게 코로플레스 맵을 만들 수 있어요. 깔끔하고 쉽죠.\n\nGPT-4에게 제시된 내용: 좋아요, 이제 아이디어 #2를 사용해서 2008년 GPI 점수의 전 세계 지도를 만들어 주세요.\n\nGPT-4의 응답:\n\n![GPI scores for 2008](/TIL/assets/img/2024-07-13-PragmaticGPT-4PromptingNiftyNo-CodeMapsandReportsforNoobs_5.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n와우, 그거 정말 쉬웠죠? 코드를 한 줄도 쓰지 않으셨나요? 전혀 안 썼네요.\n\n전문가 팁: 다른 색상 구성표를 사용하고 싶다면 프롬프트에 이 내용을 추가할 수 있어요. 예를 들어 \"RdOrYl 색상 구성표 사용하기\"\n\n이제 2022년을 분석해보기 위해 숫자들을 살펴볼까요?\n\nGPT-4에게 프롬프트: 멋져요, 이제 같은 지도를 2022년용으로 만들어주세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nGPT-4의 답변:\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-PragmaticGPT-4PromptingNiftyNo-CodeMapsandReportsforNoobs_6.png\" /\u003e\n\n좋아요! 이제 14년 차이가 나는 2개의 지도가 있어요. 빠른 비교 분석을 하면, 어떤 나라들이 시간이 지남에 따라 변화했는지(긍정적으로든 부정적으로든) 확인할 수 있어요.\n\n14년 동안 특정 결과를 얻기 위해, 어떤 나라가 평화로움이 점점 높아지거나 낮아지는지를 보여주기 위해 해당 변화를 명확히 보여주는 지도를 표시하는 것도 가능해요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그래요.\n\nGPT-4에게 알려주세요: 이제 각 국가별로 2008년부터 2022년까지의 평화 지수 차이를 보여주는 지도를 만들어주세요.\n\nGPT-4의 응답:\n\n![map](/TIL/assets/img/2024-07-13-PragmaticGPT-4PromptingNiftyNo-CodeMapsandReportsforNoobs_7.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n쉽죠! 이제 2008년부터 2022년까지 각 나라의 변화에 대한 비교 분석이 있어요.\n\n하지만 대부분의 나라가 파란색으로 표시된다는 것을 보셨을 겁니다 — 조금 오해의 소지가 있어요. 몇 가지 특이치가 있어서 데이터가 한쪽으로 치우쳐져 보일 수 있으니, 이 시각화를 조금 더 \"현실적\"으로 보이도록 GPT-4에게 수정해 달라고 요청해 볼게요.\n\nGPT-4에게 제시할 내용:\n몇 가지 특이치가 있으므로 색상 체계의 중간값을 0으로 설정하고, 전체 색상 범위를 더 생생하고 대조적으로 만드세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![해당 이미지는 훨씬 좋네요. 지난 14년 동안 불안정한 상황에서 있는 국가들을 명확히 식별할 수 있습니다. 멋진 작업이네요! 그리고 마지막으로, GPT-4의 새로운 내장 기능 중 하나는 방금 생성된 데이터 시각화와 제공된 분석을 포함한 원격 PDF 파일을 실시간으로 생성할 수 있는 기능입니다.](/TIL/assets/img/2024-07-13-PragmaticGPT-4PromptingNiftyNo-CodeMapsandReportsforNoobs_8.png)\n\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# PDF 보고서 실시간 생성\n\nGPT-4에게 방금 생성한 지도 시각화물을 모두 포함한 PDF 보고서를 생성하도록 요청할 수 있습니다.\n\nGPT-4에게 요청: 좋아요, 이제 2008년의 첫 번째 지도, 2022년의 두 번째 지도, 그리고 방금 생성한 지수 변화(2008-2022) 지도를 생성한 후, 각 지도에 대한 분석을 포함하는 PDF 보고서(소개, 분석, 결론 포함)를 만들어 주세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/TIL/assets/img/2024-07-13-PragmaticGPT-4PromptingNiftyNo-CodeMapsandReportsforNoobs_9.png)\n\n**전문가 팁:** GPT-4에게 먼저 지도를 재생성하도록 유도해야 합니다. 그렇지 않으면 이미지에 액세스할 수 없다고 불평하고 실패할 수 있습니다.\n\nGPT-4에 의해 동적으로 생성된 PDF 보고서의 스크린샷:\n\n![이미지](/TIL/assets/img/2024-07-13-PragmaticGPT-4PromptingNiftyNo-CodeMapsandReportsforNoobs_10.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n와우, 정말 인상적이에요. 데이터셋에서 데이터 시각화와 분석이 포함된 PDF 보고서까지!\n\n소소한 팁: 포맷팅이 마음에 들지 않는다면 GPT-4를 다시 실행하여 굵은 큰 제목, 헤더, 푸터 등을 추가할 수 있어요.\n\n그리고 이 모든 작업을 하기 위해 얼마나 많은 코딩이 필요했나요?\n\n음 — 전혀요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n얼마나 좋은가요?\n\n# 개요…\n\n복잡한 시각화 자동화 및 실시간 PDF 보고서 생성을 통해 GPT-4는 초보 데이터 분석가를 위한 데이터 시각화 및 보고 프로세스를 크게 간소화합니다.\n\n아직 완벽한 상황은 아닙니다. GPT-4에서 구현해야 할 업데이트와 개선 사항이 있습니다. 예를 들어 데이터셋에 대한 분석은 더 심층적이지 않을 수 있으며 PDF 서식 조정이 필요합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테이블 태그를 마크다운 형식으로 변경해보세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 이 유형의 이야기가 당신에게 딱 맞고, 저를 작가로서 지원하고 싶다면, 제 Substack에 구독해주세요.\n\nSubstack에서는 다른 플랫폼에서는 찾을 수 없는 뉴스레터와 기사를 게시합니다.\n\n당신의 의견/댓글을 듣고 싶어요!","ogImage":{"url":"/TIL/assets/img/2024-07-13-PragmaticGPT-4PromptingNiftyNo-CodeMapsandReportsforNoobs_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-PragmaticGPT-4PromptingNiftyNo-CodeMapsandReportsforNoobs_0.png","tag":["Tech"],"readingTime":12},{"title":"ETF 데이터 분석을 위한 Python 활용 금융 정보를 가져오고 분석하고 시각화하는 방법","description":"","date":"2024-07-13 20:05","slug":"2024-07-13-PythonforETFDataAnalysisHowtoFetchAnalyzeandVisualizeFinancialInformation","content":"\n\n금융 분석을 위한 Python의 힘을 발견하는 여정에 나서보세요! 이 포괄적인 안내서는 CSV 보고서를 작성하거나 대화형 Flask 대시보드를 생성하려는지 여부에 관계없이 Exchange-Traded Funds (ETFs) 데이터를 가져오고 분석하고 시각화하는 단계를 안내해 드립니다. 금융 애호가와 신진 개발자 모두에게 이 이야기는 Python을 사용한 ETF 데이터 분석을 숙달하는 길로 안내해주는 열쇠입니다.\n\nETFs의 매력을 발견해보세요\n\n금융 시장의 끝없는 미로 속에서 변동성의 용이 불을 내뿜고 불확실성의 그림자가 크게 드리우는 곳에서, 투자 성공의 황금 보물을 찾아 나설 때 위험은 수없이 많습니다. 그러나 이러한 도전 속에 희망과 기회의 빛도 있습니다: Exchange-Traded Funds (ETFs). ETFs를 다양한 갑판에 탑승할 기회를 제공하는, 격동하는 주식 시장의 엉터리 바다를 항해하는 다재다능한 배로 상상해보세요. 시장의 경험 많은 선원이거나 막시 시작한 갑판원이든, ETFs를 이해하는 것은 낡은 먼지 덮인 병에 숨겨진 보물 지도를 발견하는 것과 같습니다.\n\n그런데 이야기의 전개에는 한 가지 반전이 있습니다: 금융 데이터의 방대한 바다를 항해하는 것은 단순히 지도를 가지고 하는 것 이상을 요구합니다; 강력한 신비한 도구가 필요합니다. 현대의 요술사의 지팡이인 Python이 나타납니다. Python이 곁에 있다면, 당신은 수동적인 여행자가 아닌, 시장 트렌드와 투자 기회의 파도를 헤치며 운명을 결정하는 선장이 됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\"왜 ETFs에게 그토록 주목해야 하는지 궁금해하실 수 있습니다. 이러한 금융 자산은 여러 가지 이유로 매력적입니다:\n\n- 한 병 속의 다양성: ETFs는 다양한 종목, 채권 또는 상품을 포괄하는 작은 함대와 같습니다. 이 다양성은 귀하의 위험을 분산시켜주어 투자의 궤변에 고립되는 것을 방지합니다.\n- 용이한 항해: ETFs 거래는 개별 주식 거래처럼 간편합니다. 시장 가격에서 거래일 내내 거래할 수 있는 유연성을 제공하여 친근한 영혼을 소환하거나 보내는 것과 같은 간단한 일입니다.\n- 다양한 옵션의 보물 상자: 대담한 모험가들을 위해 ETFs와 함께 하는 옵션 거래는 자체적인 미로를 제시합니다. 큰 보상의 약속을 가지고 있지만, 위험으로 가득한 길이며 예리한 눈과 안정된 손이 필요한 길입니다.\n\n이 안내서에서는 ETF 데이터 분석을 위해 Python의 힘을 활용하기 위한 여정을 떠납니다. CSV 보고서 형태로 상세한 보물 지도를 만들거나 실시간으로 금융 우주의 비밀을 해제하는 마법의 Flask 대시보드를 작성하려는 목표가 있다면, 이 글은 당신의 나침반이자 항로가 될 것입니다. 파이썬과 유머 한 조각을 더한 채 ETFs의 세계로 떠나보세요. 금융 결정의 능란한 조류를 뚫고 평온한 물들로 향해 갑니다.\"\n\n![이미지](/TIL/assets/img/2024-07-13-PythonforETFDataAnalysisHowtoFetchAnalyzeandVisualizeFinancialInformation_0.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n당신의 퀘스트 설정하기\n\n금융 데이터 분석의 심오한 모험에 떠나기 전에, 당신의 무기함을 준비하는 것이 중요합니다. 파이썬을 당신의 충실한 말, 코딩의 땅을 횡단하는 여정에서의 존귀한 동반자로 생각해보세요. 여정을 떠날 준비가 되지 않은 상태라면 파이썬 웹사이트로 가서 파이썬을 다운로드하고 설치해주세요. 이를 통해 당신의 평범한 PC가 마법사의 탑이 되어 마법(코딩)이 일어나는 곳이 될 것입니다.\n\n당신의 모험가 툴킷은 다음을 포함해야 합니다:\n\n- 용기: 코드의 알려지지 않은 영역으로 모험을 떠날 용기, 그곳에는 아직 거의 없었던 사람들이 있습니다. 도전에 맞설 용기를 가져주세요.\n- 인내심: 프로그래밍의 세계나 좋은 모험에서도 시행 착오와 반대 상황을 경험하게 될 것입니다. 기억해주세요, 코드가 반격을 할 수 있지만 모든 오류 메시지는 보물에 한 발 다가갈 수 있는 단서입니다.\n- yfinance: 금융 영역의 마법사들에 의해 창조된 이 마법책은 몇 줄의 코드로만 금융 데이터를 불러올 수 있는 마법을 부리는 것을 가능하게 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하지만 여정은 여기서 끝나지 않아요. 데이터의 무성한 숲을 헤치고 분석의 산등성이를 오를 때, 여러분의 가방에는 몇 가지 도구가 더 필요할 거에요:\n\n- pandas: 마치 마법처럼 작용하는 이 책은 여러분의 지도와 나침반 역할을 할 거에요. 데이터를 정리하고 숫자의 안개 속을 숙련된 항해사처럼 안내해 줄 거에요.\n- numpy: 이 부적은 여러분의 능력을 향상시켜 더 복잡한 수학적 의식을 손쉽게 수행할 수 있게 해 주는데, 마치 마법으로 데이터를 변형하고 조작하는 것 같아요.\n- Flask: 세계와 여러분의 통찰을 공유하고 싶다면, 이 마법의 두루마리는 다른 사람이 여러분이 발견한 경이로움을 엿볼 수 있는 포털(웹 어플리케이션)을 만들 수 있게 도와 줄 거에요.\n\n도구를 준비하고 말을 타기 위해 거의 출발 준비가 끝났어요. 하지만 먼저, 여정에 대비하기 위해 환경을 준비해야 해요:\n\n- 터미널이나 명령 프롬프트를 열고 마법의 주문인 pip install yfinance pandas numpy Flask을 속삭여 주세요. 이 주문은 필요한 라이브러리를 거대한 Python 패키지 인덱스(PyPI)에서 불러오고 환경에 설치할 거에요.\n- 작업 디렉토리에 etfs.txt라는 텍스트 파일을 준비하세요. 파일 안에 탐구하고자 하는 ETF의 심볼을 한 줄씩 나열해 주세요. 이 문서는 여러분의 탐구를 안내해 줄 것이며, yfinance에게 건너뛴다는 트레져를 찾을 것을 알려줄 거에요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n준비가 완료되어 위대한 모험의 시작점에 서게 되었군요. 깊게 숨을 들이마시세요, 모험가 여러분. 여러분은 해독하지 못한 수수께끼 속으로 들어가게 될 것입니다. 우리는 이 목표를 달성하기 위해 기록해 두겠습니다.\n\n범위 설명\n사용자로서, 특정 ETF 성과에 대한 신뢰할 수 있는 지표 세트를 원하며 데이터 분석을 위해 시간에 따른 움직임의 곡선을 이해하고 싶습니다.\n\n- ETF의 최신 가격: 최신 가격은 바다를 가로지르는 배의 현재 위치를 알기와 같습니다. 현재 ETF의 위치를 알려줌으로써 시장의 광대한 바다에서 즉각적인 위치를 파악할 수 있습니다. 그것이 물결을 타고 높이 올라가고 있는지, 물결의 골짜기에 있어서 낮은 입장점을 찾을 수 있는 기회가 있는지를 보여줍니다.\n- 52주 최고가 및 최저가: 이러한 지표들은 어둠의 가운데에서 당신을 안내하는 등대입니다. 52주 최고가는 지난 일 년 동안 ETF가 오른 산봉우리를 나타내며 강점 또는 잠재적인 저항을 시그널합니다. 반면, 52주 최저가는 이 ETF가 건너온 가장 깊은 계곡을 보여줌으로써 가능한 지지도나 궁핍 포인트를 나타냅니다. 이 둘이 함께 ETF의 여정을 구성하여 변동성과 안정성에 대한 통찰을 제공합니다.\n- 1년, 3년, 5년 수익률: 과거 모험 이야기로 상상해 보세요. 보물의 성장을 시간이 지남에 따라 증명하는 것입니다. 일 년 수익률은 지난 일 년 동안 ETF가 얼마나 성장했는지 또는 줄었는지를 말해줍니다. 셋과 다섯 년 수익률은 이 이야기를 연장하여 더 긴 여정 동안의 성과를 보여줍니다. 이러한 지표들은 ETF 성장의 일관성을 이해하도록 도와주며 여정에 함께 할 가치 있는 선박인지 여부에 대한 결정을 안내합니다.\n- 자산 운용액 (AUM): 보물 상자의 크기입니다. 더 큰 AUM은 더 많은 투자자에게 신뢰받는, 잠재적으로 안정된 ETF를 의미합니다. 또한 이것은 더 많은 유동성을 의미하며, 가격에 영향을 미치지 않고 거래하기가 더 쉽습니다.\n- 배당 수익률: 이 수치는 ETF 일부를 보유하고 있기만 해도 받는 보물의 일부를 대표합니다. 높은 배당 수익률은 투자로 인해 더 많은 수익을 얻게 해 주어 안정적인 수입을 제공하게 됩니다.\n- 평균 거래량: 이것은 시장 광장에서 활발한 활동으로 상상해 보세요. 하루 평균으로 거래되는 ETF 주식 수를 알려줍니다. 높은 거래량은 더 많은 활동을 의미하며 유동성과 ETF에 대한 관심을 나타냅니다. 이는 가격에 큰 영향을 미치지 않고도 진입하고 위치를 떠날 수 있음을 의미합니다.\n- 풋 카운트, 콜 카운트, 그리고 옵션 만기일: 이러한 지표들은 ETF에 대한 옵션 시장의 여론을 엿볼 수 있게 합니다. 더 높은 풋 카운트는 하강을 예상하는 투자자가 더 많음을 나타내고, 더 높은 콜 카운트는 상승에 대한 낙관을 시사합니다. 만기일은 이러한 여론에 대한 맥락을 제공하여 ETF의 성과에 대한 시장 기대에 대한 단서를 제시합니다.\n- 트렌드 (상승 또는 하락): 풋 카운트와 콜 카운트에서 유래된 이 지표는 시장 여론을 한 단어로 요약합니다. 상승 트렌드는 낙관을 시사하며 상승 궤적을 나타내며, 하락 트렌드는 비관심과 잠재적인 하강을 암시합니다. 시장에서의 주요 희망을 빠르게 파악할 수 있습니다.\n\n이러한 지표들이 여러분의 투자 여정을 안내할 지도가 됩니다. ETF가 밟아온 길, 싸운 전투, 그리고 이겨낸 승리를 보여줌으로써 재물 영광을 위한 여행길에 함께할 가치 있는 동반자인지 여부를 결정할 수 있습니다. 이 지식을 무장하고 이제 ETF 세계가 여러분을 기다리고 있습니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n**코드를 이해하는 여정을 떠나다**\n\n재정적 통찰력을 얻기 위해 파이썬을 믿음직한 전투말, 플라스크를 마법의 주문으로 선택하셨군요. 우리 주문의 초기 단계를 살펴봅시다:\n\n- 호출\n\n```js\nfrom flask import Flask, render_template_string\nimport yfinance as yf\nimport pandas as pd\nimport numpy as np\n\napp = Flask(__name__)\n\ndef fetch_options_data(symbol):\n    etf = yf.Ticker(symbol)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리의 동맹들을 모으는 중이에요. Flask는 마법같은 대시보드를 만들어줄 거에요, yfinance는 금융 데이터의 세계로 들어가는 당신의 게이트웨이입니다, pandas는 이 데이터를 정리하는 데 도움을 주고, numpy는 당신이 필요로 할 어떤 숫자적 마법도 지원할 거에요. fetch_options_data 이 함수는 마치 요술사와 상담을 하는 것과도 같아요. 당신이 ETF의 심볼을 제공함으로써, 옵션 데이터를 통해 선물 시장에 대한 정보를 찾고 있습니다. yf.Ticker(symbol)의 주문은 당신이 선택한 ETF에 대한 정보를 불러올 거에요.\n\n2. 요술사의 통찰력\n\n```js\ntry:\n    expiration_dates = etf.options\n    if expiration_dates:\n        first_expiration_date = expiration_dates[0]\n        options_chain = etf.option_chain(first_expiration_date)\n        puts = options_chain.puts\n        calls = options_chain.calls\n        return len(puts), len(calls), first_expiration_date\n```\n\n이 세그먼트에서는 시간의 안개를 통해 거래자들이 베팅한 선물을 엿볼 거에요. etf.options는 옵션의 존재하는 미래 날짜를 보여주며, 시장 관련자들의 기대를 엿볼 수 있게 도와줍니다. 첫 번째 만기일의 옵션 체인을 조사함으로써, ETF에 대한 베팅을 풀어내는 puts(ETF에 대한 베팅)와 calls(ETF를 위한 베팅)의 수를 알아냅니다. 이 숫자들과 만기일은 시장의 심리를 암시하는 보물이 되어요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n3. 미지의 처리:\n\n```python\ntry:\n    except Exception as e:\n        print(f\"심볼 {symbol}에 대한 옵션 데이터를 가져올 수 없습니다: {e}\")\n    return None, None, None\n```\n\n최강의 마법도 가끔은 실패할 수 있어요. 여기서는 예기치 못한 상황에 대비합니다. 만약 예언자가 침묵을 지키거나 안개가 너무 짙다면, 당신은 우아하게 미지를 받아들여 앞이 가려져 있다고 신호를 보냅니다.\n\n이 코드는 ETF와 옵션의 신비로운 세계로의 첫 걸음입니다. 여러분은 지식을 찾고, 불확실성에 대비하며 시장의 속삭임을 해석하는 법을 배우게 될 거예요. 우리 여정이 깊어질수록 기억해 주세요: 가장 위대한 마법사들도 한 때는 단지 수습생에 불과했으며, 그 힘은 호기심, 성실함, 그리고 시작할 용기를 통해 형성되었어요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자산 총액 형식화\n\n당신이 찾는 보물의 규모를 이해하는 것은 중요합니다. 여기에서는 단순한 죽염(예를 들어 EFT의 총 자산)을 이해할 수 있는 언어로 번역하는 format_assets라는 주문이 있습니다. format_assets는 EFT의 왕국인 총 자산의 광대함에 초점을 맞춘 마법 같은 돋보기로 생각할 수 있습니다. 이 주문은 이 왕국의 크기를 모험가와 거래자들이 이해하기 쉬운 용어로 전달하려 합니다. 만약 보물의 규모가 수십억을 넘는다면 이 주문은 숫자를 수십억 단위(B)로 표현하여 표시합니다. 이는 \"이 EFT는 10억 골드 코인 이상 가치가 있는 영토를 통제하고 있습니다\" 라고 말하는 것과 같습니다. 수십억에 미치지는 못하지만 부유한 영토들에 대해서는 그들의 부를 백만 단위(M)로 표시합니다. 이는 그들의 자산이 상당하지만 엄청난 규모에 미치지는 못할 것을 존중해줍니다. 그리고 그리 희귀하지 않은 소중한 마음에, 이 주문은 그대로 그 가치를 명시함으로써 작은 명보라도 우리의 대모험에서 간과되지 않도록 합니다.\n\n```js\ndef format_assets(assets):\n    if assets \u003e= 1e9:  # 10억 이상\n        return f\"{assets / 1e9:.2f}B\"\n    elif assets \u003e= 1e6:  # 100만 이상\n        return f\"{assets / 1e6:.2f}M\"\n    return str(assets)\n```\n\n마법 도서관 공개: EFT 데이터 가져오기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리의 모험은 yfinance의 마법 도서관 심층으로 이어집니다. 거기에는 방대한 지식의 두루마리가 기다리고 있습니다. fetch_data 주문은 우리가 탐험하고자 하는 어떤 ETF 심볼에 대한 비밀을 해제하는 열쇠입니다. 이 강력한 주문이 어떻게 작동하는지 알아봅시다:\n\n```js\ndef fetch_data(symbol):\n    etf = yf.Ticker(symbol) # 해당 ETF의 본질을 활성화시키고, yfinance 영역 내에서 그 영혼에 직접 연결하는 것입니다. 늘 살아있는 데이터로 뛰어드는 ETF의 마음에 직접 연결된 것과 같습니다.\n    info = etf.info # 해당 ETF에 대한 알려진 모든 지식을 수집합니다. 이에는 해당 ETF의 역사, 능력, 그리고 금융 왕국에서의 현재 위치가 포함됩니다.\n    puts_count, calls_count, first_expiration_date = fetch_options_data(symbol)\n    # 옵션의 비밀스러운 세계로 들어가 우리 ETF에 대한 시장의 감정을 나타내는 징조를 찾습니다. 이는 금융 마법사들을 위한 차례불을 읽는 것과 같습니다.\n\n    latest_price = info.get('previousClose', np.nan)  # 최신 가격을 위한 올바른 키\n    # ETF의 최신 종가 스냅샷, 거대한 시장에서의 현재 상태에 대한 중요한 단서\n\n    # 비교 전에 puts_count와 calls_count가 None이 아닌지 확인합니다.\n    if puts_count is not None and calls_count is not None:\n        trend = \"Bearish\" if puts_count \u003e calls_count else \"Bullish\"\n    else:\n        trend = \"Unknown\"  # 두 카운트 중 하나라도 None이면 중립 값입니다.\n\n    # 추가적인 지표 (무수한 반환값 및 총 자산을 위해 None 값을 적절히 처리해야 합니다.)\n    one_year_return = round(info.get('ytdReturn', np.nan) * 100, 2) if info.get('ytdReturn') is not None else \"N/A\"\n    three_year_return = round(info.get('threeYearAverageReturn', np.nan) * 100, 2) if info.get('threeYearAverageReturn') is not None else \"N/A\"\n    five_year_return = round(info.get('fiveYearAverageReturn', np.nan) * 100, 2) if info.get('fiveYearAverageReturn') is not None else \"N/A\"\n    total_assets = format_assets(info.get('totalAssets', np.nan)) if info.get('totalAssets') is not None else \"N/A\"\n\n    return {\n        'Symbol': symbol,\n        'Name': info.get('longName', 'N/A'),\n        'Latest Price': f\"${latest_price}\",\n        '52W High': f\"${round(info.get('fiftyTwoWeekHigh', np.nan), 2)}\",\n        '52W Low': f\"${round(info.get('fiftyTwoWeekLow', np.nan), 2)}\",\n        '1 Year Return': one_year_return,\n        '3 Year Return': three_year_return,\n        '5 Year Return': five_year_return,\n        'Total Assets': total_assets,\n        'Dividend Yield': f\"{round(info.get('yield', np.nan) * 100, 2)}%\" if info.get('yield') is not None else \"N/A\",\n        'Average Volume': info.get('averageVolume', 'N/A'),\n        'Puts Count': puts_count,\n        'Calls Count': calls_count,\n        'Option Expire': first_expiration_date,\n        'Trend': trend\n    }\n```\n\n우리는 옵션의 징조를 해석하여 바람이 베어들을 지지하는지, 아니면 불들을 지지하는지를 분별합니다. 이는 ETF의 미래 경로를 예측하는 데 도움이 되는 중요한 통찰력입니다.\n\n- 수익률과 자산의 보물 지도: 그리고 주문은 이후 1년, 3년, 5년 동안의 수익률과 함께 총 자산을 계산합니다. 이는 보물이 어디에 있을지뿐만 아니라 시간이 지남에 따라 어떻게 자라냈는지를 나타내는 보물 지도를 펼치는 것과 같습니다.\n- 지식의 두루마리 제작: 마지막으로, 우리의 주문은 이 모든 지혜를 쉽게 읽을 수 있는 형식으로 나열한 자세한 두루마리를 만듭니다. 이에는 ETF의 이름, 최신 가격, 고점과 저점, 수익률 등이 포함됩니다. 각 정보 조각은 모험가들이 금융 모험에서 정보된 결정을 내릴 수 있도록 도와주는 단서입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n포탈 제작: Flask가 데이터를 살려 냅니다\n\n코드를 통한 여정이 Flask에 의해 촉발되어 ETF 데이터 스크롤이 전 세계가 볼 수 있는 모습으로 화려하게 펼쳐지는 마법의 포탈을 만들어 냈습니다. 이 마법을 어떻게 구현하는지 살펴봅시다:\n\n```js\n@app.route('/')\ndef etf_data():\n```\n\n이 말을 통해 우리는 디지털 영역에서 공간을 만들어내고, ETF 데이터가 공개될 전용 성소를 조성하게 됩니다. 마치 숨겨진 보물이 가득한 방문을 열듯 합니다. 그런 다음, 우리는 ETF 심볼 목록을 소환하고, 시장의 수수께끼를 푸는 열쇠로 이어지는 각각의 심볼을 확인하기 위한 안내서로 활용합니다. 이 목록은 우리의 안내자이자, 원하는 스크롤로 이끌어주는 길잡이입니다. 리스트가 제시되면, 하나씩, 우리는 각 ETF 심볼의 데이터를 호출하여 지식의 포괄적인 두루미를 펼쳐 냅니다. 마치 우리가 고대의 원고를 수집하는 듯한데요, 각각이 통찰과 비밀로 가득한 원고입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음은 무엇일까요? 다음 단계는 수집한 데이터를 시각적인 형태인 테이블로 변환하는 것입니다. 네비게이션하기 쉽고 눈에 즐겁게 보기 좋은 테이블입니다. 그것은 생 데이터를 숫자와 사실들로 짜여진 아름다운 속삭임으로 만드는 주문입니다.\n\netf_data 함수와 함께, 우리는 단숴분야를 분석한 것뿐만 아니라 코드의 세계와 시각적 이해의 영역 사이에 다리를 만들었습니다. 우리의 Flask 포털은 동료 모험가들을 위한 길잡이가 되어, ETF의 복잡함을 용이하고 통찰력 있게 안내합니다.\n\n```js\n    with open('etfs.txt', 'r') as file:\n        symbols = file.read().splitlines()\n\n    data = [fetch_data(symbol) for symbol in symbols]\n    df = pd.DataFrame(data)\n\n    # Convert DataFrame to HTML without index\n    df_html = df.to_html(classes='table table-striped', index=False)\n```\n\n마지막 부분은 tricky합니다: 우리는 데이터를 csv 형식으로 다운로드하거나 Flask 대시보드로 이동할 수 있습니다. 따라서 Flask를 가져오고 활성화할 필요가 없습니다. 웹페이지에 표시하는 것이 더 멋지게 보여서 대시보드를 선택할 예정입니다 (개인적인 지각).\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nhtml_template = \"\"\"\n    \u003c!DOCTYPE html\u003e\n    \u003chtml\u003e\n    \u003chead\u003e\n    \u003ctitle\u003eETF Data\u003c/title\u003e\n    \u003clink rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css\"\u003e\n    \u003c/head\u003e\n    \u003cbody\u003e\n    \u003cdiv class=\"container\"\u003e\n        \u003ch1\u003eETF Data\u003c/h1\u003e\n        { df_html | safe }\n    \u003c/div\u003e\n    \u003c/body\u003e\n    \u003c/html\u003e\n    \"\"\"\n    return render_template_string(html_template, df_html=df_html)\n\nif __name__ == '__main__':\n    app.run(debug=True)\n```\n\nETF의 난해한 지식을 이해하기 쉽고 접근 가능하게 만들기 위한 여정에서 우리는 마지막 단계에 도달했습니다. 디지털 태피스트리의 실을 짜기 위해 주문을 외우는 곳입니다. 여기서 우리는 Flask 앱의 형태를 만드는 주문을 외우면서, 기능적이면서 시각적으로 매력적인 포털을 만들어냅니다. 다음으로 포털의 기초를 다지기 위해 나아갑니다. 맨 위에 새긴 제목은 위대한 도서관의 이름처럼 지식 탐구자를 초대합니다. 그리고 우리는 Bootstrap의 힘을 소환합니다. 이 마법은 우리의 태피스트리가 시각적으로 매력적이면서도 정보를 효과적으로 제공한다는 것을 보장합니다.\nHTML의 몸체 안에서 우리는 소중한 데이터를 담는 컨테이너로 사용되는 웅장한 홀, div를 세웁니다. \"ETF 데이터\"라는 제목은 내부에 담긴 지식의 풍부함을 시그널하는 깃발처럼 자랑스럽게 들려줍니다. 그 아래에는 데이터 표가 배치되어 있으며 HTML로 변환되어 안전하게 표시됩니다. 이곳에서 우리의 ETF 데이터는 한때 복잡성의 안개에 감춰져 있던 곳에서 모든 영광을 뽐내며 드러납니다.\n그리고 최종 주문을 외우며 포털에 생명을 불어넣고, 이를 가동시킵니다. 이제 준비가 끝났으며, 인터넷의 문턱에서 지식 탐구자들이 문을 통과하기를 기다립니다.\n\n코드가 실행되고 서버가 활성화되는 동안 이것을 생각해보세요. 당신이 만든 것은 단순히 Flask 앱이 아닙니다. 이것은 재정 데이터의 광대한 바다를 항해하는 사람들을 위한 등대입니다. 각각의 ETF를 탐험하며, 각 지표를 이해함으로써, 당신은 숫자를 분석하는 것뿐만 아니라 길을 밝히며, 결정을 이끌며, 아마도 미래를 바꾸고 있습니다.\n\n그래서, 코드가 준비되었습니다. 실행할 수 있고 결과를 볼 수 있습니다.\n브라우저를 열고 URL을 입력하세요: http://127.0.0.1:5000/.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 귀하가 원하는 코드를 Markdown 형식으로 변경한 것입니다.\n\n\n![Python for ETF Data Analysis - How to Fetch, Analyze, and Visualize Financial Information](/TIL/assets/img/2024-07-13-PythonforETFDataAnalysisHowtoFetchAnalyzeandVisualizeFinancialInformation_1.png)\n\nUPD: 아래의 코멘트에 제안된 대로, 직접 구현하고 테스트할 수 있는 전체 코드를 추가했습니다 :)\n\n```python\nfrom flask import Flask, render_template_string\nimport yfinance as yf\nimport pandas as pd\nimport numpy as np\n\napp = Flask(__name__)\n\n# 옵션 데이터를 가져오는 함수\ndef fetch_options_data(symbol):\n    etf = yf.Ticker(symbol)\n    try:\n        expiration_dates = etf.options\n        if expiration_dates:\n            first_expiration_date = expiration_dates[0]\n            options_chain = etf.option_chain(first_expiration_date)\n            puts = options_chain.puts\n            calls = options_chain.calls\n            return len(puts), len(calls), first_expiration_date\n    except Exception as e:\n        print(f\"{symbol}에 대한 옵션 데이터를 가져올 수 없음: {e}\")\n    return None, None, None\n\n# 쉽게 파악할 수 있도록 총 자산을 포맷하는(helper) 함수\ndef format_assets(assets):\n    if assets \u003e= 1e9:  # 10억 이상\n        return f\"{assets / 1e9:.2f}B\"\n    elif assets \u003e= 1e6:  # 1백만 이상\n        return f\"{assets / 1e6:.2f}M\"\n    return str(assets)\n\n# 수정된 fetch_data 함수에 모든 수정 사항을 포함\ndef fetch_data(symbol):\n    etf = yf.Ticker(symbol)\n    info = etf.info\n    puts_count, calls_count, first_expiration_date = fetch_options_data(symbol)\n    latest_price = info.get('previousClose', np.nan)  # 최신 가격을 위한 올바른 키\n\n    # puts_count 및 calls_count를 비교하기 전에 None이 아닌지 확인합니다\n    if puts_count is not None and calls_count is not None:\n        trend = \"Bearish\" if puts_count \u003e calls_count else \"Bullish\"\n    else:\n        trend = \"Unknown\"  # 어느 하나가 None인 경우 중립 값을 설정\n\n    # 추가 지표 (수익 및 총 자산에 대한 None 값의 적절한 처리 확인)\n    one_year_return = round(info.get('ytdReturn', np.nan) * 100, 2) if info.get('ytdReturn') is not None else \"N/A\"\n    three_year_return = round(info.get('threeYearAverageReturn', np.nan) * 100, 2) if info.get('threeYearAverageReturn') is not None else \"N/A\"\n    five_year_return = round(info.get('fiveYearAverageReturn', np.nan) * 100, 2) if info.get('fiveYearAverageReturn') is not None else \"N/A\"\n    total_assets = format_assets(info.get('totalAssets', np.nan)) if info.get('totalAssets') is not None else \"N/A\"\n\n    return {\n        '심볼': symbol,\n        '이름': info.get('longName', 'N/A'),\n        '최신 가격': f\"${latest_price}\",\n        '52주 최고가': f\"${round(info.get('fiftyTwoWeekHigh', np.nan), 2)}\",\n        '52주 최저가': f\"${round(info.get('fiftyTwoWeekLow', np.nan), 2)}\",\n        '1년 수익률': one_year_return,\n        '3년 수익률': three_year_return,\n        '5년 수익률': five_year_return,\n        '총 자산': total_assets,\n        '배당 수익률': f\"{round(info.get('yield', np.nan) * 100, 2)}%\" if info.get('yield') is not None else \"N/A\",\n        '평균 거래량': info.get('averageVolume', 'N/A'),\n        '풋 거래 수': puts_count,\n        '콜 거래 수': calls_count,\n        '옵션 만기일': first_expiration_date,\n        '추세': trend\n    }\n\n# Flask를 URL 구조가 보이게 설정: 127.0.0.1:5000/\n@app.route('/')\ndef etf_data():\n    with open('etfs.txt', 'r') as file:\n        symbols = file.read().splitlines()\n\n    data = [fetch_data(symbol) for symbol in symbols]\n    df = pd.DataFrame(data)\n\n    # 인덱스 없이 DataFrame을 HTML로 변환\n    df_html = df.to_html(classes='table table-striped', index=False)\n\n    html_template = \"\"\"\n    \u003c!DOCTYPE html\u003e\n    \u003chtml\u003e\n    \u003chead\u003e\n    \u003ctitle\u003eETF Data\u003c/title\u003e\n    \u003clink rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css\"\u003e\n    \u003c/head\u003e\n    \u003cbody\u003e\n    \u003cdiv class=\"container\"\u003e\n        \u003ch1\u003eETF Data\u003c/h1\u003e\n        { df_html | safe }\n    \u003c/div\u003e\n    \u003c/body\u003e\n    \u003c/html\u003e\n    \"\"\"\n    return render_template_string(html_template, df_html=df_html)\n\nif __name__ == '__main__':\n    app.run(debug=True)\n```\n\nThe Treasure Unveiled: What We Have Achieved\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n축하합니다, 친애하는 모험가 여러분! 여러분은 금융 데이터의 미로를 헤쳐나가며, 파이썬의 마법을 휘둘러 ETF의 비밀을 플라스크 대시보드의 투명한 화면을 통해 밝혀내었습니다. 이제 우리가 발견한 보물에 놀라보는 시간을 가져봅시다:\n\n- 지식의 지도: 우리의 여정의 핵심에는 ETF 세계의 전경을 제공하는 강력한 대시보드가 있습니다. 최신 가격, 52주 최고/최저 및 수익률(1년, 3년, 5년)과 같은 지표들을 통해 숫자를 이해뿐만 아니라 시장의 격동하는 수역을 탐험하기 위한 나침반이 되었습니다.\n- 숫자 너머의 통찰: 저희 대시보드는 숫자를 표시하는 데 그치지 않고 통찰력을 제공합니다. 풋과 콜을 비교함으로써 투자자에게 시장 심리를 엿보여, 순수한 데이터를 실행 가능한 정보로 바꾸었습니다.\n- 미래로의 문: 각 ETF의 데이터가 꼼꼼하게 분류되어 있는 상태에서 우리의 플라스크 앱은 투자자가 잠재적인 미래를 엿볼 수 있는 창문으로 서 있어, 금융용 악마로부터 멀리하고 황금잡이 기회로 나아가는데 도움이 되고자 합니다.\n\n다음 단계: 어떻게 더 나아갈까요?\n\n기반을 다지고 배를 준비한 상태에서, 우리는 여기서 어디로 항해해야 할까요? 금융과 코딩의 영역은 방대하며, 발굴되지 않은 미스터리가 무수히 많습니다. 다음은 여러분이 떠날 수 있는 잠재적인 항해들입니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 대시보드를 embold: 우리의 Flask 앱은 기능적이지만, 웹 디자인의 영역에서 아름다움은 힘이 될 수 있어요. 대시보드를 시각적으로 멋진 걸작으로 변신시키기 위해 CSS 마법과 JavaScript 마법을 활용해 보세요. 모든 방문자를 사로잡는 멋진 대시보드로 만들어 보세요.\n\n- Metrics을 확장하다: 금융 세계는 끊임없이 변화하며, 시장의 안개 속에서 나타나는 새로운 지표들이 등장합니다. 대시보드에 더 많은 metrics를 추가하는 것을 고려해 보세요. 샤프 비율, 알파, 베타 등을 추가하여 각 ETF의 성과와 위험 프로필에 대한 더 깊은 통찰력을 제공할 수 있습니다.\n\n- 개인화 및 상호 작용: 시청자를 알아차리는 대시보드를 상상해 보세요. 개인의 투자 성향이나 위험 허용도에 맞게 인사이트를 맞춤화할 수 있는 대시보드를 추가하는 것이 어떨까요? 사용자 계정, 사용자 정의 뷰, 상호 작용 요소를 추가함으로써 당신의 앱을 도구에서 신뢰할 수 있는 자문자로 변신시킬 수 있습니다.\n\n- 실시간 데이터 통합: 현재 대시보드는 한 순간을 포착합니다. 금융의 바다는 항상 변동하기 때문에 실시간 데이터 피드를 통합함으로써 대시보드를 실시간 맵으로 변환할 수 있습니다. 시장의 최신 풍향과 조류로 끊임없이 업데이트되는 대시보드로 만들어 보세요.\n\n- 새로운 해안 탐험: ETF에서 멈추지 마세요. 금융 세계는 암호화폐부터 상품, 주식부터 채권까지 기회의 섬으로 가득합니다. 대시보드를 확장하여 이러한 영역을 다루는 것은 전체 금융 우주를 탐색하는 데 필수적인 나침반으로 만들 수 있습니다.\n\n그래서 여기에서 출발할 때 차트를 손에 쥐고 Python을 가까이 가져 두세요. 금융의 바다는 넓고 야생적이지만, 당신은 능숙한 항해사임이 이미 증명되었습니다. 당신의 투자가 번창하고, 데이터가 정확하며 알고리즘이 효율적하기를 바랍니다.\n\n다시 만나는 그 순간까지, 용감한 모험가여, 이만 작별하겠습니다. 행운의 바람이 당신을 이끌어주길 바라며, 당신이 항상 지혜와 번창의 해안에 도착할 수 있기를 바랍니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n인 플레인 영어 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 반경하고 팔로우해주세요 👏\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io에서 더 많은 콘텐츠 확인하기","ogImage":{"url":"/TIL/assets/img/2024-07-13-PythonforETFDataAnalysisHowtoFetchAnalyzeandVisualizeFinancialInformation_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-PythonforETFDataAnalysisHowtoFetchAnalyzeandVisualizeFinancialInformation_0.png","tag":["Tech"],"readingTime":23},{"title":"데이터 시각화 갓템, Quad-Tile Chart와 Squaremap 사용법 소개","description":"","date":"2024-07-13 19:59","slug":"2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData","content":"\n\n![2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_0](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_0.png)\n\n# 소개\n\n데이터 시각화에서 사용 가능한 캔버스의 크기와 모양은 항상 중요한 요소입니다. 이것은 공간을 절약하기 위한 수단으로 두 축 접근법을 사용하는 Crystal Bar Chart라는 차트를 최근 다른 기사에서 다룬 주제입니다.\n\n이 기사에서는 값을 정사각형으로 시각화하고 볼록 다각형 또는 단순 오목 다각형 형태의 컨테이너를 가득 채우는 공간 절약 방법을 탐구하겠습니다. 또한 이 탐구 과정에 코드를 많이 활용해 보았으니, 다른 유용한 기술과 시각화 유형에 대한 재미있는 자습서로 제공될 수 있기를 희망합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 기사를 통해 달성하고자 하는 목표는 일반적이고 비표준적인 컨테이너 모양(아래 그림 참조)을 고려하고, 이와 유사한 모양의 값 집합을 제시하여 사용 가능한 공간을 최적화하고 직관적인 크기 비교를 제공하며 데이터를 사각형 모양으로 표현하는 것입니다!\n\n![image](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_1.png)\n\n새로운 축 없이 접근하기 전에, 결과를 측정할 좋은 기준을 찾을 수 있는 기존 축 기반 및 축 없는 방법에 대해 생각해 봅시다. 예를 들어, Wikipedia에서 제공하는 동물 중 상위 20마리의 최고 속도를 나타내는 정보를 활용하겠습니다. \n\n## 축 기반 데이터 시리즈 시각화\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\ny-축이 항목의 값을 나타내는 경우, 정렬된 막대 차트와 경쟁하기 어려울 수 있어요. 먼저 그것을 플롯하고, 저의 vizmath 패키지를 사용하여 몇 가지 더 축 기반의 차트를 만들어 보겠습니다.\n\n막대 차트\n\n```js\n# https://en.wikipedia.org/wiki/Fastest_animals (2024년 1월 26일 기준)\n# 20대 최고 빠른 동물 (최고속도, mph)\n\n데이터 = {\n    'id' : [str(i) for i in range(1, 21)],\n    'speed' : [242,200,105,100,100,95,92.5,88,80,79,\n        75,67.85,61.06,60,56,55,55,55,50,50]\n}\n\n# 막대 차트 (데이터는 이미 정렬되어 있음)\nimport matplotlib.pyplot as plt\n\nplt.figure(figsize=(7, 1.5))\n막대 = plt.bar(range(1, 21), 데이터['speed'], edgecolor='black',\n    color='white', linewidth=1)\nplt.xticks([])\nplt.grid(False)\nplt.show()\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_2.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n크리스털 막대 차트\n\n```python\nfrom vizmath.crystal_bar_chart import crystals\nimport pandas as pd\n\n# 데이터: 위를 참조하십시오\n\ndf = pd.DataFrame(data)\ncbc = crystals(df, 'id', 'speed', height_range=5, width_override=5,\n    rotation=90, offset=50, bottom_up=True)\ncbc.cbc_plot(legend=False, alternate_color=True, color=False)\n```\n\n![이미지](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_3.png)\n\n비스웜 플롯\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nfrom vizmath.beeswarm import swarm\nimport pandas as pd\n\n# 데이터: 위 참조\n\ndf = pd.DataFrame(data)\ndiameter = 5\nbs = swarm(df, 'id', 'speed', None, size_override=pi*(diameter/2)**2)\nbs.beeswarm_plot(color=False)\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_4.png\" /\u003e\n\n각각의 메소드들은 값의 크기를 반영하는 모양과 위치를 제공하면서 데이터 집합의 밀도 프로필을 제공하는 독특한 방식을 제공합니다.\n\n이제 같은 값 세트를 사용하여 상대적인 크기 비교에 중점을 둔 축 없는 예제로 넘어가며 일부 반응형 Bubble Chart를 그려 Quad-Tile Chart 알고리즘을 미리보겠습니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 축 없이 데이터 시각화\n\n축 없이 도메인을 표현하기 위해 한 수준의 트리맵(저의 Radial Treemap에 관심이 있는 경우 해당 문서를 확인해보세요!)을 포함하고, 이어서 Bubble 차트를 추가해 봅시다.\n\n트리맵 (한 수준의 파이, 도넛, 직사각형)\n\n```js\nfrom vizmath.radial_treemap import rad_treemap as rt\nimport pandas as pd\n\n# 데이터: 위의 데이터를 참조하세요\n\n# 파이 트리맵\ndf = pd.DataFrame(data)\no_rt = rt(df, ['speed'], 'speed', r1=0)\no_rt.plot_levels()\n\n# 도넛 트리맵\ndf = pd.DataFrame(data)\no_rt = rt(df, ['speed'], 'speed')\no_rt.plot_levels()\n\n# 트리맵\ndf = pd.DataFrame(data)\no_rt = rt(df, ['speed'], 'speed', r1=0, r2=1,\n    a1=0, a2=1, rectangular=True)\no_rt.plot_levels()\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![Bubble Chart (grid)](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_5.png)\n\n```js\nimport numpy as np\nimport pandas as pd\n\n# data: 위에서 참조\n\ndf = pd.DataFrame(data)\n\ndef grid_bubbles(values, size_by='area', rows=2, cols=10, buffer=0.1):\n    fig, ax = plt.subplots(rows, cols, figsize=(7, 1.5))\n    sorted_values = np.sort(values)[::-1]\n    if size_by == 'area':\n        sizes = np.sqrt(sorted_values) # 반지름 입력 고려\n    elif size_by == 'diameter':\n        sizes = sorted_values # 반지름에 비례\n    max_size = np.max(sizes)\n    b = max_size*buffer\n    max_size += b\n    index = 0\n    for i in range(rows):\n        for j in range(cols):\n            # Matplotlib의 Circle을 위한 반지름 입력\n            circle = plt.Circle((0.5, 0.5), sizes[index]/max_size/2,\n                color='black', fill=False, linewidth=2)\n            ax[i, j].add_artist(circle)\n            ax[i, j].set_xlim(0, 1)\n            ax[i, j].set_ylim(0, 1)\n            ax[i, j].axis('off')\n            index += 1\n    plt.tight_layout()\n    plt.show()\n\ngrid_bubbles(data['speed'], size_by='area')\ngrid_bubbles(data['speed'], size_by='diameter')\n```\n\n![Bubble Chart (grid)](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_6.png)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n버블 차트 (내 새로운 Quad-Tile 차트 알고리즘을 사용하여 반 정렬)\n\n```js\nfrom vizmath.quadtile_chart import polyquadtile as pq\nimport pandas as pd\n\n# 데이터: 위를 참조하세요\n\n# 면적에 따라 크기 조정\ndf = pd.DataFrame(data)\ndf['speed'] = df['speed']/df['speed'].max()*3.5\no_pq = pq(df,'id','speed',buffer=0.0, collapse=True,\n    constraints=[(2,1)], auto=False)\no_pq.polyquadtile_plot(show_constraints=True, poly_color='w',\n    poly_line='black', squares_off=True, circles=True)\nprint(o_pq.multiplier)\n\n# 지름에 따라 크기 조정\ndf = pd.DataFrame(data)\ndf['speed'] = df['speed']**2 # 지름 비율에 맞게 조정\ndf['speed'] = df['speed']/df['speed'].max()*3.5\no_pq = pq(df,'id','speed',buffer=0.0, collapse=True,\n    constraints=[(2,1)], auto=False)\no_pq.polyquadtile_plot(show_constraints=True, poly_color='w',\n    poly_line='black', squares_off=True, circles=True)\n```\n\n![이미지](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_7.png)\n\n이러한 방법들은 값이 어떤 크기인지 직접적인 참조를 제공하는 축이 없어서 위치 변경 기능이 작동합니다. 따라서 값의 모양, 크기 및 레이아웃이 데이터 인사이트를 수집하는 데 중요합니다. 값 표현 간의 공간을 보존하는 방식으로 이러한 차트를 유용하게 만드는 파라미터 조정이 중요합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n숫자 축 기반 차트의 경우 멀리 떨어져 있는 값 모양을 나란히 보여줄 수 있지만, 축 없는 차트를 사용하면 값 모양을 옆으로 보여줄 수 있어요. 데이터와 사용 사례에 따라, 축 없는 방법의 시각화 압축은 축 기반 방법보다 상당한 장점이 될 수 있어요.\n\n위의 버블 차트에서는 면적 및 지름별 크기 설정도 포함했어요. 크기 설정 메커니즘은 종종 간과될 수 있지만, 두 결과 간의 차이는 상당할 수 있어요! 데이터의 성겁과 시각화의 내러티브 맥락에 따라, 시각화 도구에서 크기 설정이 무엇을 기반으로 하는지 항상 알고 있으면, 정보에 기반한 선택을 할 수 있어요.\n\n기본 케이스 (경쟁사)\n\n위의 예시를 리뷰하면 버블 차트가 사용 가능한 공간을 보존하면서 비슷한 형태의 값 세트를 적절히 크기에 맞게 표현하는 우리의 초기 목표를 이루는 경쟁자임을 알 수 있어요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n포장된 Bubble Chart(컨테이너)는 결과를 측정하기 위한 경쟁 상대가 될 것입니다. 그러나 아쉽게도 내가 찾은 구현 (아래에 표시됨)은 원형 레이아웃만 나타내므로 다른 컨테이너 모양을 탐색할 때 완벽한 비교 사례가 되지 않을 것입니다.\n\n```js\n# circlify\nimport circlify\ncircles_circlify = circlify.circlify(data['speed'], show_enclosure=False)\ncircles = [c for c in circles_circlify]\nmax_radius = max(circle.r for circle in circles)\nxlim = max(abs(circle.x) + max_radius for circle in circles)\nylim = max(abs(circle.y) + max_radius for circle in circles)\nlimit = max(xlim, ylim)\nfig, axs = plt.subplots(figsize=(8, 8))\naxs.axis('off')\nplt.xlim(-limit, limit)\nplt.ylim(-limit, limit)\nfor circle in circles:\n    axs.add_patch(plt.Circle((circle.x, circle.y), circle.r,\n        edgecolor='black', facecolor='white', linewidth=2))\nplt.show()\n\n# packcircles\nimport packcircles\ncircles_packcircles = packcircles.pack(data['speed'])\ncircles = [c for c in circles_packcircles]\n# circles\nmax_radius = max(radius for (_, _, radius) in circles)\nxlim = max(abs(x) + max_radius for (x, _, _) in circles)\nylim = max(abs(y) + max_radius for (_, y, _) in circles)\nlimit = max(xlim, ylim)\nfig, axs = plt.subplots(figsize=(8, 8))\naxs.axis('off')\nplt.xlim(-limit, limit)\nplt.ylim(-limit, limit)\nfor (x, y, radius) in circles:\n    axs.add_patch(plt.Circle((x, y), radius,\n        edgecolor='black', facecolor='white', linewidth=2))\nplt.show()\n\n# Tableau Public:\nimport pandas as pd\nimport os\ndf = pd.DataFrame(data)\ndf.to_csv(os.path.dirname(__file__) + '/circles.csv',\n    encoding='utf-8', index=False)\n# select packed bubbles -\u003e Size by [Speed], [Id] on Detail\r\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_8.png\" /\u003e\n\n경쟁 상대를 선택했으니 이제 포장된 Bubble Chart가 홀로 서 있는지 또는 컨테이너 포장 목표를 충족하는 상대적 가치 비교를 위해 활용할 수 있는 다른 단순한 모양이 있는지 살펴보겠습니다. 이제 정사각형의 응용을 탐색해 보겠습니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 왜 Squarify를 사용해야 할까요?\n\n이미 패킹된 원들을 조사하는 무대를 마련했으니, 짧게 쉬어가며 질문을 해보는 게 좋을 것 같아요. 패킹된 원들이 존재하는데 왜 사각형에 관심을 가질까요?\n\n데이터 시각화에서 이미 패킹된 원들이 널리 사용되고 있으므로 사람들은 원을 좋아하는 것으로 보입니다. 다양한 패킹된 버블 차트 구현은 다양한 프로그래밍 언어 및 소프트웨어에서 쉽게 찾을 수 있어요. 사실, Quad-Tile 차트를 만든 후 가장 먼저 한 일은 동그라미를 그리는 데 사용했어요 (소개 부분에 나와 있음). 그래서 동그라미의 매력은 실재해요!\n\n하지만 사각형은 어떨까요? 다른 가능한 모양들과 비교했을 때 패킹된 사각형은 상대적으로 무해해 보이지만, 확실한 패킹된 사각형 차트 구현을 찾는 것은 어렵습니다. 왜 그럴까요...\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n간단한 비교를 하고 어떤 것을 발견해 봅시다:\n\n![image](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_9.png)\n\n위의 경우 1:2 비율을 사용하여 넓이나 길이를 비교하는 데 둥근 모양이나 사각형 모두 다른 것보다 직관성을 제공하지 않는 것으로 보입니다. 하지만 원은 더 부드럽고 사각형은 더 날카로운 것 같아요.\n\n그렇다면, 나는 스퀘어리파이를 하는 이유가 다음과 같습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 패킹된 사각형 구현은 존재하지 않는 것 같아서 시각적으로 얼마나 매력적인지 알기가 어렵습니다(패킹된 원의 대체물로). 따라서 조사할 가치가 있습니다.\n- 파이썬의 사용 가능한 패킹된 원 구현물에서는 컨테이너를 활용할 수 있는 능력이 일반적으로 부족합니다(모두 원의 수가 증가함에 따라 원형 레이아웃만 제공하는 것으로 보입니다).\n- 사각형의 단순성은 알고리즘을 통해 사각형을 채우려고 시도하면 수학적 연산이 직관적일 것으로 보입니다. 따라서 빠른 개념 증명이 가능할 수도 있습니다.\n\n스퀘어화를 추구하는 동기를 제시했으니, 이제 사각형 패킹 노력의 핵심 구성 요소인 패킹을 살펴보고, 사각형이 원에 어떻게 대응하는지 확인해봅시다.\n\n# 모양 패킹 \u0026 컨테이너 패킹\n\n## 타일링과 함께\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n수사 목적으로 명백한 것을 언급할 가치가 있습니다. 사각형은 가장을 가지고 있지만 원은 그렇지 않습니다. 이 특성은 유사한 크기의 사각형들을 테셀레이션할 수 있게 해주어, 패킹이라는 유용한 개념이 될 수 있습니다.\n\n```js\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\n\n# 도형과 공간을 사용하여 다이아몬드 테셀레이션 모의실험을 해봅시다.\ndef diamond_tessellation(rows, cols):\n    fig, ax = plt.subplots()\n    ax.set_aspect('equal', adjustable='box')\n    plt.axis('off')\n    for row in range(rows):\n        for col in range(cols):\n            diamond = patches.Polygon([\n                (col + 0.5, row), \n                (col + 1, row + 0.5), \n                (col + 0.5, row + 1), \n                (col, row + 0.5)\n                ], edgecolor='grey', facecolor='whitesmoke')\n            ax.add_patch(diamond)\n    ax.set_xlim(0, cols)\n    ax.set_ylim(0, rows)\n    plt.show()\n\ndiamond_tessellation(2, 9)\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_10.png\" /\u003e\n\n유감스럽게도, 테셀레이션은 데이터셋의 값이 동일하거나 편리한 비율을 가지는 것으로 가정하는 것이 현실적이지 않기 때문에 일반적인 해결책은 아닙니다. 그러나 간격이 없는 가장의 개념은 원보다 잠재적인 이점으로 더 탐구할 가치가 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 최적화로\n\n최적화 방법은 두 개의 모양을 비교하는 메커니즘으로 다음 단계로 가치 있는 것처럼 보입니다. 그래서 원과 정사각형 사이에 가능한 균일하게 적용할 수 있는 간단한 목적 함수에 집중하여 결과를 검토해 봅시다.\n\n먼저, 목적 함수의 요소를 식별해야 합니다. 우리는 모양의 중첩을 방지하는 메커니즘과 밀접하게 패킹하려는 반대 힘이 필요합니다. 각각을 자세히 살펴보겠습니다.\n\n- 중첩 방지 (밀어내기) - 중첩을 방지하기 위해 모양들의 총 중첩 영역을 고려하고, 다른 모양에 완전히 포함되는 모양에 대해 추가 벌칙을 부과하여 작은 모양의 중첩 방지를 촉진합니다.\n- 패킹 촉진 (가까이 끌어모으기) - 패킹을 촉진하기 위해 모양을 특정 관심 지점으로 끌어당기는 것을 보상할 것입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지금은 컨테이너를 무시하고 도형 패킹에 초점을 맞춰 각 도형의 기하학적 특징을 살펴봅시다. 이제 식별된 재료로 구현할 함수를 설정해 봅시다.\n\n```js\nfrom shapely.geometry import Point, Polygon\nfrom shapely.ops import unary_union\n\n# 셰이프의 중심에서 관심 지점까지의 거리를 더하여 당김 힘을 설정합시다\ndef calc_distance_from_point(shapes, shape_type, origin):\n    penalty = 0\n    ref_point = Point(origin)\n    if shape_type == 'circle':\n        for x, y, _ in shapes:\n            centroid = Point(x, y)\n            penalty += centroid.distance(ref_point)\n    elif shape_type == 'square':\n        for x, y, side in shapes:\n            centroid = Polygon([(x, y), (x + side, y),\n                (x + side, y + side), (x, y + side)]).centroid\n            penalty += centroid.distance(ref_point)\n    return penalty\n\n# 이제 첫 번째 당김 힘을 설정하여 한 도형이 다른 도형 안에 포함되어 있는지 여부를 파악하고 발생 횟수를 더합시다\ndef calc_containment(shapes, shape_type):\n    penalty = 0\n    shapely_shapes = []\n    if shape_type == 'circle':\n        shapely_shapes = [Point(x, y).buffer(r) \n            for x, y, r in shapes]\n    elif shape_type == 'square':\n        shapely_shapes = [Polygon([(x, y), (x + side, y),\n            (x + side, y + side), (x, y + side)]) \n            for x, y, side in shapes]\n    for i, shape1 in enumerate(shapely_shapes):\n        for j, shape2 in enumerate(shapely_shapes):\n            if i != j and shape1.contains(shape2):\n                penalty += 1\n    return penalty\n\n# 당김 힘을 완성하기 위해 전체 도형 중첩 영역을 계산합시다\ndef calc_overlap_area(shapes, shape_type):\n    if shape_type == 'circle':\n        shapely_shapes = [Point(s[0], s[1]).buffer(s[2]) \n            for s in shapes]\n    elif shape_type == 'square':\n        shapely_shapes = [Polygon([(s[0], s[1]), (s[0] + s[2], s[1]), \n            (s[0] + s[2], s[1] + s[2]), (s[0], s[1] + s[2])]) \n            for s in shapes]\n    merged_area = unary_union(shapely_shapes).area\n    individual_areas = sum(shape.area for shape in shapely_shapes)\n    return abs(individual_areas - merged_area)\n\n# 마지막으로, 힘을 종합하여 목적 함수로 만들어봅시다\ndef objective_function(variables, shapes, shape_type, \n    origin=(0,0), prevent_overlap_factor=2):\n    for i, shape in enumerate(shapes):\n        shapes[i] = (variables[i*2], variables[i*2 + 1], shape[2])\n    overlap_area = calc_overlap_area(shapes, shape_type)\n    contained = calc_containment(shapes, shape_type)\n    sum_distance = calc_distance_from_point(shapes, shape_type, origin)\n    return overlap_area * prevent_overlap_factor * (1 + contained) + sum_distance\n```\n\n목적 함수에서는 도형의 겹치는 영역을 포함하는 모양의 수와 곱하여 당김 패널티를 집중시키기로 선택했습니다. 그리고 당김 정도를 조절하는 'prevent_overlap_factor' 가중치를 추가했습니다.\n\n이제 목적 함수가 준비되었으니, 이전의 예제 데이터를 사용하여 원과 사각형 패킹 최적화 루틴을 설정해 봅시다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\r\n# 이전 예시 데이터:\r\ndata = {\r\n    'id' : [str(i) for i in range(1, 21)],\r\n    'speed' : [242,200,105,100,100,95,92.5,88,80,79,\r\n        75,67.85,61.06,60,56,55,55,55,50,50]\r\n}\r\n\r\n# 원하는 크기 창(Window) (계수)와 모양의 반복 가능한 랜덤 위치를 위한 시드를 설정해봅시다.\r\n\r\n계수 = 10\r\n시드 = 123\r\n\r\n최대속도 = np.max(data['speed'])\r\nnp.random.seed(시드)\r\n\r\n모양들 = [(np.random.uniform(0, 계수*1.5),\r\n    np.random.uniform(0, 계수*1.5),\r\n    v/최대속도*계수) for v in data['speed']]\r\n```\r\n\r\n이제, 원과 사각형의 입력을 분리하고 최적화 메서드에 전달할 경계를 추가해봅시다.\r\n\r\n```js\r\nimport numpy as np\r\nimport copy\r\nfrom math import sqrt\r\n\r\n# 각 모양에 대해 최적화하기 위해 복사본을 만듭시다.\r\n원들 = copy.deepcopy(모양들)\r\n사각형들 = copy.deepcopy(모양들)\r\n\r\n# 위치를 최적화하기 위해 좌표를 평면으로 펼쳐봅시다\r\n초기_위치 = [val for s in 모양들 for val in s[:2]]\r\n\r\n# 이제 각 모양의 경계를 계산하여 최적화 함수에 전달합시다\r\ndef calc_bounds(모양들, 모양_유형):\r\n    총_면적 = 0\r\n    if 모양_유형 == '원':\r\n        총_면적 = sum(np.pi * (r**2) for _, _, r in 모양들)\r\n    elif 모양_유형 == '사각형':\r\n        총_면적 = sum(side**2 for _, _, side in 모양들)\r\n    추정된_한변의_길이 = sqrt(총_면적)\r\n    패딩 = 추정된_한변의_길이 / 2\r\n    하한 = 0 - 패딩\r\n    상한 = 추정된_한변의_길이 + 패딩\r\n    return (하한, 상한)\r\n\r\n# 원과 사각형에 대한 경계 계산\r\n원의_경계 = calc_bounds(원들, '원')\r\n사각형의_경계 = calc_bounds(사각형들, '사각형')\r\n\r\n# 각 모양에 경계를 적용하여 최적화하기\r\n원_경계들 = [(원의_경계[0], 원의_경계[1]) \r\n    for _ in range(len(초기_위치))]\r\n사각형_경계들 = [(사각형의_경계[0], 사각형의_경계[1])\r\n    for _ in range(len(초기_위치))]\r\n\r\n# 풀 힘을 위한 접힘점을 설정하기 위해 경계를 사용\r\n원의_접힘점 = (원의_경계[1]-원의_경계[0])/2+원의_경계[0]\r\n사각형의_접힘점 = (사각형의_경계[1]-사각형의_경계[0])/2+사각형의_경계[0]\r\n원의_접힘점들 = (원의_접힘점, 원의_접힘점)\r\n사각형의_접힘점들 = (사각형의_접힘점, 사각형의_접힘점)\r\n```\r\n\r\n마지막으로, 결과를 시각화하기 위한 플로팅 함수를 설정하고 각 모양에 대해 최적화를 실행해보겠습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\nfrom math import inf\nfrom scipy.optimize import minimize\n\n# 결과를 확인할 수 있는 plotting 함수를 만들어봅시다.\ndef plot_shapes(shapes, shape_type):\n    fig, ax = plt.subplots()\n    min_x, min_y, max_x, max_y = 0.,0.,0.,0.\n    for s in shapes:\n        if shape_type == 'circle':\n            circle = patches.Circle((s[0], s[1]), s[2],\n                facecolor='lightgrey', edgecolor='black')\n            ax.add_patch(circle)\n            min_x = min(min_x, s[0] - s[2])\n            min_y = min(min_y, s[1] - s[2])\n            max_x = max(max_x, s[0] + s[2])\n            max_y = max(max_y, s[1] + s[2])\n        elif shape_type == 'square':\n            square = patches.Rectangle((s[0], s[1]), s[2], s[2],\n                facecolor='lightgrey', edgecolor='black')\n            ax.add_patch(square)\n            min_x = min(min_x, s[0])\n            min_y = min(min_y, s[1])\n            max_x = max(max_x, s[0] + s[2])\n            max_y = max(max_y, s[1] + s[2])\n    padding = 1\n    ax.set_xlim(min_x - padding, max_x + padding)\n    ax.set_ylim(min_y - padding, max_y + padding)\n    ax.set_aspect('equal', 'box')\n    plt.show()\n\n# 마지막으로 반복을 모니터링하는 콜백 함수를 설정해봅시다.\ndef callback(i):\n    global iteration\n    iteration += 1\n    print(f'반복 {iteration}')\n\n# 원 최적화 실행:\niteration = 0\noptimized_circles = minimize(objective_function, initial_positions,\n    args=(circles, 'circle', origin_circles), method='L-BFGS-B',\n    bounds=bounds_circles, callback=callback,\n    options={'maxiter': 300, 'maxfun': inf, 'ftol': 0, 'gtol': 0})\npacked_circles = [(optimized_circles.x[i*2],\n    optimized_circles.x[i*2 + 1], circles[i][2])\n    for i in range(len(circles))]\n# plot_shapes(shapes, 'circle') # 초기 위치를 보려면 주석 해제\nplot_shapes(packed_circles, 'circle')\n\n# 사각형 최적화 실행:\niteration = 0\noptimized_squares = minimize(objective_function, initial_positions,\n    args=(squares, 'square', origin_squares), method='L-BFGS-B',\n    bounds=bounds_squares, callback=callback,\n    options={'maxiter': 300, 'maxfun': inf, 'ftol': 0, 'gtol': 0})\npacked_squares = [(optimized_squares.x[i*2],\n    optimized_squares.x[i*2 + 1], squares[i][2])\n    for i in range(len(squares))]\n# plot_shapes(shapes, 'square') # 초기 위치를 보려면 주석 해제\nplot_shapes(packed_squares, 'square')\r\n```\n\n위 코드에서는 'L-BFGS-B' 메서드를 선택하여 scipy의 'minimize' 함수에서 반복 횟수를 300으로 설정했습니다. 초기 위치를 제어하는 난수 시드는 결과에 영향을 미칠 수 있으므로 두 모양에 대해 각각 3가지 다른 시드를 살펴봅시다.\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_11.png\" /\u003e\n\n각 테스트 케이스를 생성하는 데 랩톱에서 약 5분이 걸렸으므로, 이 방법의 시간 요구 사항은 고려해야 할 불안정한 요소입니다. 이미 긴 대기 시간 때문에 컨테이너 중첩 비용을 목적 함수에 추가하여 컨테이너 패킹 통찰을 검토하는 것은 현재 필요하지 않은 것으로 보입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지면 배치 관련해서 원들이 더 조밀하게 배열되어 있는 것 같습니다. 이것이 데이터 시각화에서 패킹된 원이 패킹된 정사각형보다 흔한 이유를 설명하는 첫 번째 증거가 될 수 있습니다.\n\n하지만 포기하기 전에, 정사각형에 맞춤화된 알고리즘을 사용한 최종 평가로 넘어가 봅시다!\n\n## 알고리즘을 통해\n\n위의 실험에서 얻은 주요 결론은:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 일반 최적화 구현을 사용하여 단순 목적 함수에 따라 패킹된 모양을 생성하는 것은 어느 정도 작동하는 것 같아요.\n- 그러나 이것은 정말 느리고 대규모 데이터셋을 처리하기에 부적합하죠.\n- 원형 배열들이 (적어도 컨테이너 패킹 없이는) 사각형 배열보다 더 융합되어 보였어요.\n\n우리는 대규모 데이터셋에서 성능이 우수하며 더 매력적인 사각형 배열을 생성할 수 있고, 컨테이너 패킹을 구현할 수 있는 특수화된 알고리즘이 필요하다는 것이 분명해요. 이 방식을 일반적인 최적화 프레임워크와 구분짓기 위해 사각형의 특정 특성을 활용하고, 포장 기회를 탐색할 필요가 있어요.\n\n우리가 활용할 수 있는 사각형의 몇 가지 기하학적 요소를 나열하여 시작해봐요:\n\n- 형태: 네 개의 직각을 감싸고 있는 같은 길이의 네 변을 가지며, 화면을 기준으로 회전할 수 있어 다른 외형이 될 수 있는\n- 패킹: 간격 없이 사각형 사이에 이웃할 수 있는 능력\n- 배치: 각 사각형의 각 변은 4개의 가능한 꼭지점 중 하나에서 시작하여 이웃할 사각형에게 이웃할 수 있는 평면적인 2차원 공간을 무한대로 제공함\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음에는 패킹된 사각형이 패킹된 원과 어떻게 경쟁할 수 있는지 이해하기 위해 Quad-Tile 차트라는 새로운 시각화 기술에 사용되는 알고리즘을 설명할 것입니다.\n\n## Quad-Tile 차트\n\n### 영감\n\n몇 년 전 어떤 사람이 패킹된 버블 차트는 대부분 쓸모없다고 말했습니다. 무슨 이유에서인지 그 말이 나에게 영감을 주어 패킹된 사각형 차트를 만들게 되었습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n첫 번째 버전을 개발하고 Tableau Public 시각화와 몇 가지 다른 기술과 함께 구체화된 결과물을 시험해 보았어요. 여기에는 18개의 사각형을 포함하는 Voronoi Treemaps가 있는 (v1) Quad-Tile Chart가 표시된 발췌본이 있어요. (Voronoi Treemaps는 D3.js를 사용하여 계산되었어요).\n\n![Quad-Tile Chart](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_12.png)\n\n아래에서는 이 알고리즘에 대해 설명하고, 몇 일 전에 다시 시작했을 때 최종적으로 채택한 방식을 설명할게요.\n\n## (초기) 알고리즘 v1\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n내 초기 접근 방식인 2022년 초에는 컨테이너를 고려하지 않았습니다. 가장 큰 정사각형부터 시작하여 중앙에 배치한 후 모든 정사각형이 중심 정사각형 주변에 감싸지도록 연속적으로 나열하려고 노력했습니다. 가장 작은 정사각형은 가장 중심부터 먼 위치에 배치되었습니다.\n\n마디 있는 정사각형 배열에 관해 스케치한 후에 나에게 온 개념 중에는 다음과 같은 것들이 있습니다:\n\n- 사분면 - 조사한 결과, 정사각형은 연속적인 사각형들을 분산하기 위한 4개의 오프셋 평면을 제공합니다.\n- 자기 조직화 정사각형 배치 - 한 평면의 잠재적 너비와 오프셋 평면의 차지된 높이를 연관시킴으로써 자기 조직화를 가능케하도록 하며, 이는 공유 경계(분할된 세그먼트로 실행됨)를 구현함으로써 이루어집니다.\n- 측면 전환 - 크기에 따라 정사각형들을 고르게 분산하기 위해, 원하는 순서로 하나를 배치한 후 측면을 전환합니다. (나는 기본적으로 윗쪽-오른쪽-아래쪽-왼쪽으로 전환했습니다.)\n- 사용자 정의 - 이 방법은 값 정렬을 배제하지만, 일련의 규칙에 따라 다음 측면을 선택할 수 있는 기능을 구현할 수 있는 능력을 제공합니다.\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_13.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nv1 알고리즘은 다음과 같아요:\n- 먼저 양수 값들로 이루어진 집합부터 내림차순으로 정렬해요. 예를 들어, 9.4, 7.4, 1.5, 0.2\n- 값을 패딩하기 위해 각 사각형 주변의 공간을 추가한 후 (예를 들어 0.5)\n- 첫번째 (가장 큰) 사각형을 설정하고, 중앙 사각형 주변의 각 사분면을 위한 세그먼트 저장 메커니즘을 생성해요.\n- 초기 세그먼트를 중앙 사각형의 변으로 설정하고, 각 사분면에 하나씩 배정해요.\n- 옆면 순서 (기본값은 위, 오른쪽, 아래, 왼쪽)가 주어지면, 각 면을 반복하면서 작은 사각형을 배치해요. 각 사분면의 첫 번째 사각형은 해당 사분면 평면의 원점과 정렬되어, 해당 사분면의 초기 세그먼트 시작 위치에서 시작해요.\n- 위쪽 면에 사각형을 배치하려면 (정렬 및 배치 요구 사항을 고려하여), 세그먼트를 가장 짧은 y값별로 정렬하고 가장 긴 길이를 가지는 세그먼트에서, 사각형의 너비 ≤ 세그먼트 길이인 첫 번째 세그먼트에 사각형을 배치해요.\n- 사각형을 배치하면, 해당 사각형이 차지한 공간을 세그먼트에서 조절하여 세그먼트의 시작 위치 및 길이를 조정하고, 새로운 세그먼트를 만들어요.\n- 배치된 사각형의 시작 위치가 사분면 평면의 오프셋 경계와 정렬되면 (중앙 사각형의 축에 수직인 경계), 중앙 사각형 주변의 자기 조직화 성장을 가능하게 하기 위해 영향을 받는 세그먼트의 세그먼트 길이를 연장해요.\n- 원하는 스택 구성을 위해 필요한 측 선택 메커니즘을 구현해요.\n- 사각형을 버퍼로 다시 원래 크기로 바꾸고, 원하는 회전으로 사각형을 회전시켜요 (기본값은 45도).\n\n아래 다이어그램은 세그먼트 기반 접근 방법을 보여줘요. 각 세그먼트는 다음과 같이 될 거에요:\n- 원래 위치에서 한 방향으로 효과적으로 이동시켜져요 (사각형의 너비가 세그먼트 길이와 같은 경우)\n- 두 섹션으로 분할돼요 (하나는 배치된 사각형의 너비를 따르고, 다른 하나는 시작 위치와 길이가 변경된 원래 세그먼트일거에요).\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_14.png\" /\u003e\n\n재미로, 몇 가지 측면 선택 옵션을 구현했는데 'constraints' 입력란은 다각형을 받아들이고 외곽을 벗어나면 측면을 전환하려고 시도하여 다각형과 겹치는 특정 영역에서의 성장을 촉진합니다.\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_15.png\" /\u003e\n\n이것이 제 두 번째 영감으로 이어집니다. Quad-Tile Chart v1을 내 vizmath 패키지에 통합할 때 다각형 입력과 더 많은 작업을 할 수 있는지 생각하기 시작했습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n일부 실험 끝에, 주어진 다각형 내에 꼭지점이 깔끔하게 맞는 완전히 기능적인 컨테이너 패킹 구현이 재미있을 것이라고 결정하고 처음부터 알고리즘을 완전히 개편해보기로 했습니다! 다음에 해당하는 알고리즘을 확인해 봅시다: Quad-Tile Chart v2\n\n## (최종) 알고리즘 v2\n\n이 알고리즘의 두 번째 버전은 v1의 일부 핵심 요소를 확장하고 쿼드런트-세그먼트 접근 방식을 유사하게 사용하면서 몇 가지 수정 사항과 컨테이너 패킹을 수용하기 위한 몇 가지 새로운 기능을 추가합니다.\n\nv2에 대한 주요 세부 내용은 다음과 같습니다. 특별한 점을 확인해 보세요:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Bridge Segments(컨테이너 채우기)\n- Backward Segment Extension(‘축소’ 옵션)\n- Value Multiplier Bisection Optimization(컨테이너 패킹)\n\n![image](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_16.png)\n\n다음은 v2 알고리즘입니다:\n\n- 단계 1~5는 v1과 동일하지만 2가지 세그먼트 속성(세그먼트 높이 및 세그먼트가 활성화되어 있는지), 3가지 사분면 레벨 속성(최소 바닥과 천장 및 해당 사분면 전체가 방을 다 쓴 것인지) 및 배치된 사각형에 대한 속성(왼쪽 아래 모서리 좌표 및 너비)가 추가됩니다.\n- 이터레이터(처음에 0으로 설정)가 놓여야 하는 사각형 수보다 작을 동안 다음 절차가 수행됩니다:\n- 마지막 바닥 세그먼트(LFS)를 찾습니다: max(segments: 'y=floor', sort: 'x')\n- 정렬된 세그먼트 목록을 만듭니다: (segments: 'is active', sort: 'height, x')\n- 정렬된 세그먼트를 루프합니다(아래에서 '세그먼트' 및 루프 반복 '세그먼트'로 참조됨) 및 진행합니다.\n- 만약 사각형의 모퉁이가 다각형 내에 있고 사각형의 '너비'와 '높이'가 세그먼트의 '너비'와 '높이'에 맞는다면 사각형은 배치됩니다. 그렇지 않으면 세그먼트를 '비활성화'로 설정합니다.\n- 세그먼트의 'y' 값이 사분면의 '바닥'과 같다면 사각형의 '너비'를 추가하여 '바닥'을 업데이트합니다.\n- 사각형이 배치되면 사각형의 너비와 세그먼트 길이에 따라 현재 세그먼트를 대체할 1개 또는 2개의 새 세그먼트를 생성합니다.\n- 축소가 활성화된 경우 다음 절차가 수행됩니다:\n- 세그먼트를 새로 생성된 세그먼트 중 가장 왼쪽으로 설정(NLS).\n- 확장할 세그먼트를 찾습니다: max(segments: 'x + 길이 = NLS.x', 'y = NLS.y', sort: 'x')\n- 확장할 세그먼트가 존재하는 경우, NLS 길이를 추가하고 NLS를 제거합니다.\n- 그렇지 않은 경우, 왼쪽 사각형(LS)을 찾습니다: max(squares: 'x+w≤NLS.x', 'y≤NLS.y', 'y+x≥NLS.y', sort: 'x')\n- 왼쪽 사각형(LS)이 존재하면 LS.x + LS.w ≤ NLS.x를 확인하여 갭이 있는지 확인합니다.\n- 그렇다면, 커버된 세그먼트(CS)를 확인합니다: max(segments: 'y=LS.y', 'x`NLS.x', sort: 'x')\n- 커버된 세그먼트가 존재하는 경우, 세그먼트 높이를 사각형 너비와 동일하게 설정하고 병합 세그먼트를 확인합니다: max(segments: 'x+길이+CS.length = NLS.x', 'y=NLS.y', sort: x)\n- 병합 세그먼트가 존재하는 경우, 사각형 너비와 CS.length를 추가하여 길이를 확장합니다.\n- 그렇지 않은 경우, LS.x + LS.w ≤ NLS.x - 사각형 너비라면 NLS.x = LS.x+LS.w 및 NLS.길이 = CS.length으로 NLS를 조정합니다.\n- 세그먼트가 LFS와 같고 배치되지 않았으며 사분면의 바닥이 천장과 다른 경우 다리 세그먼트를 생성합니다. 다음 절차를 따릅니다:\n- LFS.높이 및 사분면 바닥을 사분면 천장으로 업데이트합니다.\n- 천장 세그먼트(CS)가 천장에서 존재하는지 확인합니다: max(segments: 'y=ceiling', sort: x)\n- 존재하는 경우, 그 길이를 다각형 경계까지 확장합니다.\n- 그렇지 않은 경우, (세그먼트.x, 천장)에 새 세그먼트를 생성하고 해당 지점과 다각형 경계 사이의 거리로 길이를 설정합니다.\n- 마지막으로, 모든 세그먼트를 '활성화'로 설정하고 루프를 종료합니다.\n- 그렇지 않은 경우, 사각형이 배치되면 사각형을 사각형 목록에 추가하고 해당 속성을 설정하고 사분면을 '방이있음'으로 설정하고 세그먼트가 마지막 세그먼트인 경우 모든 세그먼트를 '활성화'로 설정하고 이터레이터를 1 증가시키고 다음 측면을 설정하고 루프를 종료합니다.\n- 그렇지 않은 경우, 마지막 세그먼트에 도달하면 가능한 경우 더 많은 다리 세그먼트를 추가하려 시도합니다. 다음 절차를 따릅니다:\n- 다리 사각형(BS)을 확인합니다: 첫번째(squares: 'x+w=LFS.x', 'y=LFS.y')\n- 있으면, LFS.높이 = BS.x로 설정하고 사분면 바닥을 BS.w만큼 증가시키고 사분면 천장을 바닥으로 설정합니다.\n- 다리 사각형 세그먼트를 확인합니다: max(segments: 'y=floor', sort: x)\n- 하나가 존재한다면, 그 길이를 다각형 경계까지 확장합니다.\n- 그렇지 않은 경우, (BS.x+BS.w, 바닥)에 새 세그먼트를 생성하고 해당 지점과 다각형 경계 사이의 거리로 길이를 설정합니다.\n- 마지막으로, 모든 세그먼트를 '활성화'로 설정하고 루프를 종료합니다.\n- BS를 찾지 못한 경우, 사분면을 '방이없음'으로 설정하고 모든 세그먼트를 '활성화'로 설정하고 다음 측면을 설정하고 모든 사분면이 방이없으면 이터레이터를 놓여야 하는 사각형 수로 설정(사실상 외부 while 루프를 종료합니다).\n- v1의 단계 10을 반복하며 각 사분면을 올바른 방향으로 회전합니다.\n- 자동 배열 옵션이 선택된 경우(컨테이너 패킹), 변환된 값들\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nv2 알고리즘은 컨테이너 패킹을 맞추기 위해 훨씬 더 많은 작업을 필요로했기 때문에 v1 알고리즘의 간단함에 비해 더 많은 노력이 필요했습니다. 하지만 정말 그만한 가치가 있었어요! v2에서 몇 가지 레이아웃 예제를 살펴봅시다.\n\n![이미지](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_17.png)\n\n위의 원 형태의 외곽선은 '축소' 기능을 사용하여 참조용으로 포함했습니다. v2의 이론적 한계는 아마도 자기 자신을 내부로 돌리는 다각형들일 것입니다 (이는 사분면의 타일링 평면에서 고유 다각형 갭을 처리하기 위한 향상된 세그먼트 논리가 필요할 것입니다).\n\n다음으로, Python에서 Quad-Tile 차트를 구축하는 방법을 살펴보겠습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 파이썬 구현\n\n저는 제 Quad-Tile Chart 알고리즘 v1 및 v2를 파이썬에서 사용할 수 있도록 vizmath 패키지를 통해 구현했습니다. PyPI에서 제공됩니다. 소개에서 시작하는 초기 예제를 사용하여 몇 가지 추가 옵션을 살펴보고 입력 및 출력을 설명하겠습니다. 먼저 v1로 시작합니다:\n\n```js\n# Quad-Tile Chart v1\n# pip install vizmath==0.0.22\nfrom vizmath.quadtile_chart import quadtile as qt\nimport pandas as pd\n\ndata = {\n    'id' : [str(i) for i in range(1, 21)],\n    'speed' : [242,200,105,100,100,95,92.5,88,80,79,\n        75,67.85,61.06,60,56,55,55,55,50,50]\n}\ndf = pd.DataFrame(data)\n\n# 쿼드타일 객체 생성\n#   \u003e df: 데이터와 id 필드가 있는 DataFrame\n#   \u003e id_field: 필수 식별자 필드 (더미값 사용 가능)\n#   \u003e value_field: 필수 값 열\n#   \u003e xo: x축 기준점\n#   \u003e yo: y축 기준점\n#   \u003e packing: 패킹 방법 ('auto','inc','num','max','min')\n#   \u003e overflow: 'num', 'max', 'min' 패킹을 위한 정수 임계값\n#   \u003e buffer: 사각형 크기에 추가 값\n#   \u003e rotate: 차트 회전 각도\n#   \u003e constraints: 둘레 내부 성장을 촉진하는 다각형\n#   \u003e size_by: 'area' 또는 'width'\n#   \u003e poly_sort: 다각형 정점 정렬 활성화/비활성화 (참, 거짓)\nqt_o_area = qt(df,'id','speed', size_by='area', buffer=0)\nqt_o_width = qt(df,'id','speed', size_by='width', buffer=0)\n\n# 차트 그리기 (면적 및 너비에 따라 크기 조절)\nqt_o_area.quadtile_plot(color='quad', cw=0.75, opacity=.9)\nqt_o_width.quadtile_plot(color='quad', cw=0.75, opacity=.9)\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_18.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 v2를 사용해 봅시다:\n\n```js\n# Quad-Tile Chart v2\n# pip install vizmath==0.0.22\nfrom vizmath.quadtile_chart import polyquadtile as pqt\nimport pandas as pd\n\ndata = {\n    'id': [str(i) for i in range(1, 21)],\n    'speed': [242, 200, 105, 100, 100, 95, 92.5, 88, 80, 79, 75, 67.85, 61.06, 60, 56, 55, 55, 55, 50, 50]\n}\ndf = pd.DataFrame(data)\n\n# 쿼드타일 객체 생성\n#   \u003e df: 데이터를 포함하고 있는 DataFrame, 숫자형 데이터 컬럼과 id 필드를 가져야 함\n#   \u003e id_field: 필수 식별자 필드 (더미 값 사용 가능)\n#   \u003e value_field: 필수 값 컬럼\n#   \u003e xo: x축 원점\n#   \u003e yo: y축 원점\n#   \u003e buffer: 사각형 크기를 조절하는 보정값\n#   \u003e rotate: 차트 회전 각도\n#   \u003e sides: 포함시킬 변 선택 ('top', 'right', 'bottom', 'left')\n#   \u003e collapse: 축소/확대 설정 (True, False)\n#   \u003e constraints: 패킹할 다각형 컨테이너\n#   \u003e xc: x축 컨테이너 오프셋 값\n#   \u003e yc: y축 컨테이너 오프셋 값\n#   \u003e size_by: 'area' 또는 'width'\n#   \u003e auto: 자동 패킹 활성화/비활성화 (True, False)\n#   \u003e auto_max_iter: 자동 패킹 반복 횟수\n#   \u003e auto_min_val: 자동 패킹 최소 배수\n#   \u003e auto_max_val: 자동 패킹 최대 배수\n#   \u003e poly_sort: 다각형 꼭지점 정렬 활성화/비활성화 (True, False)\npqt_o_area = pqt(df, 'id', 'speed', size_by='area', buffer=0)\npqt_o_width = pqt(df, 'id', 'speed', size_by='width', buffer=0)\n\n# 차트 그리기 (면적 및 폭에 따라 사이즈가 지정된 차트)\npqt_o_area.polyquadtile_plot(color='quad', cw=0.75, opacity=0.9)\npqt_o_width.polyquadtile_plot(color='quad', cw=0.75, opacity=0.9)\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_19.png\" /\u003e\n\n이제 v1 및 v2의 랜덤 초기화 옵션을 포함한 몇 가지 추가 옵션을 조사해 봅시다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 1000개의 임의 크기 사각형을 테스트해봅시다:\nfrom vizmath.quadtile_chart import quadtile as qt\nfrom vizmath.quadtile_chart import polyquadtile as pqt\n\n# 상단 좌측에 회전된 Quad-Tile Chart v1\nqt_o1 = qt.random_quadtile(1000, rotate=45)\nqt_o1.quadtile_plot(color='quad', cw=0.75, opacity=.9)\n\n# 상단 우측에 비회전 Quad-Tile Chart v1\nqt_o2 = qt.random_quadtile(1000, rotate=0)\nqt_o2.quadtile_plot(color='quad', cw=0.75, opacity=.9)\n\n# 하단 좌측에 정사각형 컨테이너를 사용한 Quad-Tile Chart v2\npoly = [(-10,-10),(-10,10),(10,10),(10,-10)] # 다각형 컨테이너\npqt_o1 = pqt.random_polyquadtile(1000, constraints=poly, buffer=0)\npqt_o1.polyquadtile_plot(color='quad', cw=0.75, opacity=.9)\n\n# 중앙에 가로 세로 비율이 1:1인 Quad-Tile Chart v2\npqt_o2 = pqt.random_polyquadtile(1000, constraints=[(1,1)], buffer=0)\npqt_o2.polyquadtile_plot(color='quad', cw=0.75, opacity=.9)\n\n# 하단 우측에 가로 세로 비율이 1:1인 Quad-Tile Chart v2\npqt_o3 = pqt.random_polyquadtile(1000, constraints=[(1,1)],\n    buffer=0, rotate=0)\npqt_o3.polyquadtile_plot(color='quad', cw=0.75, opacity=.9, circles=False)\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_20.png\" /\u003e\n\n위 내용은 각 버전 간 배치 방법의 미묘한 차이를 보여줍니다 (v1은 y값이 가장 낮고 가장 긴 길이로 선택된 세그먼트, v2는 계단식 접근 방식). 또한 v2에 대한 무작위 초기화는 무작위 볼록 다각형을 생성할 것입니다 — 무엇이 나올지 아무도 모릅니다!\n\n```js\nfrom vizmath.quadtile_chart import polyquadtile as pqt\n\npqt_o = pqt.random_polyquadtile(100, collapse=True)\npqt_o.polyquadtile_plot(color='quad', cw=0.75, opacity=.9, circles=True,\n    show_constraints=True)\n\n# 계속해서 무작위 크기 사각형을 사용한 무작위 컨테이너 실행\r\n```  \n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_21.png\" /\u003e\n\n그리고 끝으로, 우리는 중심점을 사용하여 부모 사각형의 경계 상자 크기에 맞는 모든 모양으로 플롯할 수 있음을 기억하세요. 원형 차트의 경우에는 반소형 Bubble Chart만 플로팅한다는 소개를 참조하세요!\n\n이제 Quad-Tile Chart 알고리즘으로 생성된 사분면 다각형과 사분면 중심점 출력을 검토해 봅시다.\n\n사분면 다각형 출력:\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- item — ‘id’ 입력 필드로 지정된 수신 식별자\n- a — 사각형의 상대적 면적 (버퍼는 포함되지 않음)\n- w — 할당된 공간의 너비: 사각형의 너비 + 버퍼*2\n- x, y — 레이아웃 내의 점에 대한 직교 좌표\n- path — 폴리곤을 둘러싼 경로를 나타내는 정수 순서 집합으로, Crystal Bar Chart의 각 크리스탈 ID 및 면에 대해 각각의 (x, y) 점과 함께 사용됨: 1부터 N까지\n\n```js\nfrom vizmath.quadtile_chart import polyquadtile as pqt\nimport pandas as pd\n\n# 컨테이너에 맞게 크기 조정 없이 초기 예제 데이터 사용:\ndata = {\n    'id' : [str(i) for i in range(1, 21)],\n    'speed' : [242,200,105,100,100,95,92.5,88,80,79,75,67.85,61.06,60,56,55,55,55,50,50]\n}\npoly = [(-1000,-1000),(-1000,1000),(1000,1000),(1000,-1000)] # 설명 예제 출력을 위한 충분히 큰 컨테이너\ndf = pd.DataFrame(data)\no_pq1 = pqt(df,'id','speed',buffer=5.0, collapse=True, constraints=poly, auto=False)\no_pq2 = pqt(df,'id','speed',buffer=5.0, collapse=True, constraints=poly, auto=False, size_by='width')\n\n# 면적에 따라 크기 조정:\no_pq1.o_polyquadtile_chart.df[['id','item','a','w','x','y','path']].head()\n# 너비에 따라 크기 조정:\no_pq2.o_polyquadtile_chart.df[['id','item','a','w','x','y','path']].head()\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_22.png\" /\u003e\n\n사각형 중심점은 'id' 대신 'item'으로 동일한 속성으로 추출될 수도 있습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n# 넓이 별 크기:\no_pq1.o_polysquares.df[['id','a','w','x','y']].head()\n\n# 너비 별 크기:\no_pq2.o_polysquares.df[['id','a','w','x','y']].head()\n\n\n![이미지](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_23.png)\n\n이제 Quad-Tile 차트로 무엇을 더 할 수 있는지 알아봅시다.\n\n## 확장성\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n캔버스 레이아웃을 활용하는 원래의 목표를 표준 및 비표준 컨테이너와 함께 다시 살펴보겠습니다. 볼록 다각형과 간단한 오목 다각형을 수용할 수 있는 방법을 보여드렸고, 이제는 소개에서 소개된 레이아웃을 채워봤습니다. 각각 100개의 정사각형이 들어가는 컨테이너에 대해 다양한 회전을 적용했습니다.\n\n![image](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_24.png)\n\n가장 일반적인 캔버스 레이아웃은 직사각형 컨테이너일 것이므로, 원하는 종횡비를 간단하게 전달하는 것이 유용합니다. 다음은 너비를 다양하게 조절한 예시입니다 (높이 조절 방법도 동일합니다):\n\n```js\nfrom vizmath.quadtile_chart import polyquadtile as pqt\n\naspect_ratio = (1,1) #(2,1) (3,1) (4,1)\npqt_o = pqt.random_polyquadtile(100, constraints=[aspect_ratio], \n    rotate=45, collapse=True, buffer=.02)\npqt_o.polyquadtile_plot(color='quad', cw=0.75, opacity=.9)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_25.png)\n\nExtensibility의 또 다른 흥미로운 측면은 계층적 데이터를 포함하는 것입니다. 기존 방법의 일부 단점은 다음과 같습니다:\n\n- 중첩된 원은 레벨별로 정확한 상대적인 면적을 유지할 수 없습니다. 이를 위해 중첩된 Radial이나 Voronoi Treemaps가 필요합니다.\n- Treemaps는 상위 레벨에서 불규칙한 차원을 가질 가능성이 있습니다. (사각형, 원형, 또는 Voronoi일 경우)\n\nQuad-Tile Chart는 계층의 상위 수준을 유사한 모양으로 캡처하여 초기 크기 비교를 제공함으로써 두 번째 문제를 우아하게 처리할 수 있습니다.🌟\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n첫 번째 문제에 대해 말씀드리면, 중첩된 Quad-Tile Charts는 중첩된 패킹된 원(타일 섹션에서 언급된대로)과 동일한 단점을 가지고 있지만, 전통적인 직사각형 Treemaps(또는 Voronoi Treemaps)으로 나무 전체에 대한 정확한 면적을 유지하는 대안을 제공합니다. 중첩된 직사각형 Treemaps은 부모 정사각형의 변을 사용하여 보다 직관적인 자식 직사각형 비교를 할 수 있어 원하는 경우가 있습니다.\n\n다음 단계의 직사각형 Treemaps에 대한 예시 몇 가지를 함께 공유드리겠습니다. 상위 수준에 정사각형을 포함한 Quad-Tile Chart에 중첩된 이들을 제가 “Squaremaps”라고 부르겠습니다!\n\n![Squaremaps](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_26.png)\n\n제가 vizmath에서 Squaremaps에 대한 구현을 다음과 같이 작성했습니다(그리고 필요 시 계층적 데이터를 동적으로 생성하는 기능도 추가했습니다!):\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\r\nimport pandas as pd\nfrom vizmath.quadtile_chart import squaremap as sm\n\n# 랜덤한 스퀘어 맵 생성\no_sm1 = sm.random_squaremap(num_levels=3, items_range=(2,4), \n    value_range=(1,1000), sig=0.8)\no_sm1.o_squaremap.plot_levels(level=3, fill='w')\n\n# 계층적 데이터를 사용하여 스퀘어 맵 생성\ndata = [\n    ['a1', 'b1', 'c1', 9.3],\n    ['a1', 'b1', 'c2', 6.7],\n    ['a1', 'b1', 'c3', 2.4],\n    ['a1', 'b2', 'c1', 4.5],\n    ['a1', 'b2', 'c2', 3.1],\n\n    ['a2', 'b1', 'c1', 5.9],\n    ['a2', 'b1', 'c2', 32.3],\n    ['a2', 'b1', 'c3', 12.3],\n    ['a2', 'b1', 'c4', 2.3],\n    ['a2', 'b2', 'c1', 9.1],\n    ['a2', 'b2', 'c2', 17.3],\n    ['a2', 'b2', 'c3', 6.7],\n    ['a2', 'b2', 'c4', 4.4],\n    ['a2', 'b2', 'c5', 11.3],\n\n    ['a3', 'b1', 'c1', 7.5],\n    ['a3', 'b1', 'c2', 9.5],\n    ['a3', 'b2', 'c3', 17.1],\n\n    ['a4', 'b2', 'c1', 5.1],\n    ['a4', 'b2', 'c2', 2.1],\n    ['a4', 'b2', 'c3', 11.1],\n    ['a4', 'b2', 'c4', 1.5]]\ndf = pd.DataFrame(data, columns = ['a', 'b', 'c', 'value'])\no_sm2 = sm(df, ['a','b','c'], 'value', constraints=[(1,1)], buffer=.2)\no_sm2.o_squaremap.plot_levels(level=3, fill='w')\r\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_27.png\" /\u003e\n\n## Tableau Public Implementation\n\n파이썬에서 Quad-Tile Chart를 소개했으며 계층적 확장에 대한 Squaremap을 포함하였습니다. 이어서 Tableau Public (v 2023.3.1)에서 양쪽 모두를 구현하는 방법을 보여드리겠습니다! 우선 간단한 Squaremap 구현부터 시작하여 대화형으로 만드는 더 체계적인 Quad-Tile Chart 구축으로 넘어가보겠습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nTableau Public에서 Squaremap 구현\n\n더 자세한 안내를 위해서는, 저의 Radial Treemaps에 관한 글이 있습니다. 해당 글은 상호작용 가능한 계층을 만드는 방법에 대해 더 상세히 안내하며, 이를 위해 Squaremap과 동일한 그림 출력을 사용합니다! 지금은 임의의 입력을 생성하고 단순한 Tableau 예제에 대비한 그림 출력 데이터를 준비해보겠습니다.\n\n```js\nfrom vizmath.quadtile_chart import squaremap as sm\n\n# 임의의 계층 데이터 생성 및 Squaremap 작성\no_sm = sm.random_squaremap(num_levels=3, num_top_level_items=120,\n    items_range=(2,4), value_range=(1,10), sig=0.75, \n    collapse=True, buffer=0.05)\n# 초기 플롯 검토\no_sm.o_squaremap.plot_level(level=3)\n# 출력의 미리보기 (그림 데이터)\no_sm.o_squaremap.df_rad_treemap.head(10)\n# 데이터로 그림 객체 설정\no_sm.o_squaremap.o_rad_treemap.df = o_sm.o_squaremap.df_rad_treemap\n# Tableau에서 지도 레이어를 활용하기 위한 데이터 재조정\no_sm.o_squaremap.o_rad_treemap.dataframe_rescale(\n    xmin=-5, xmax=5, ymin=-5, ymax=5)\n# 데이터를 csv로 작성\no_sm.o_squaremap.o_rad_treemap.dataframe_to_csv('squaremap')\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_28.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테이블 태그를 Markdown 형식으로 변경해주세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- [Group]을 Marks 아래 Detail로 드래그하세요.\n- Marks 드롭다운 메뉴에서 Polygon을 선택하세요 (이 시점에서 이상하게 보인다고 걱정하지 마세요).\n- [Path]를 Marks 아래 Path로 드래그하고 현재 SUM(Path)인 항목을 우클릭하여 Dimension으로 선택하세요.\n- [Value]를 Color로 드래그하고 Dimension으로 변환하는 작업을 반복하세요.\n- Color 아래에서 \"색상 편집...\"을 선택하고 다음 옵션으로 구성하세요: '반전, 고급: (시작: 0, 끝: 10)'\n\n이제 더 재미를 위해 더 한 개의 레이어를 추가하여 색상을 변경해 봅시다:\n\n- [Treemap]을 지도 영역으로 드래그하면 팝업이 나타납니다: Marks 레이어 추가 - 이를 클릭하여 새로운 지도 레이어를 생성하세요.\n- 위의 단계를 반복하되 이제 [Side]를 Color로 사용하세요.\n- Color 아래에서 검은 테두리를 선택하고 투명도를 15%로 설정하세요.\n\n이제 아래와 유사한 차트가 나타날 것입니다 (입력의 무작위성으로 인해 고유한 것이 될 것입니다!). 이제 [Level]로 필터링하거나 필요에 맞는 상호 작용을 설정할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_29.png) \n\n이 Squaremap 구현이 당신의 계층적 데이터를 더 자세히 탐색하는 데 유용한 시작점이 되길 바랍니다!\n\nTableau Public에서 Quad-Tile Chart 구현\n\n이제 더 자세한 Quad-Tile Chart 구현에 초점을 맞추고 Tableau Public에서 상호작용형 시각화를 만들어 보겠습니다. 강 체계에 대한 위키피디아 데이터 일부로 시작해서 파일에 저장해보죠.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport pandas as pd\n\n# 위키백과에서 (2024년 1월 26일 기준) 상위 50개의 강 시스템 목록\n# https://en.wikipedia.org/wiki/List_of_river_systems_by_length\ndata = {\n    '강' : [str(i) for i in range(1, 51)],\n    '길이_km' : [\n        6650,6400,6300,6275,5539,5464,5410,4880,4700,4444,4400,4350,4241,\n        4200,3969,3672,3650,3645,3610,3596,3380,3211,3185,3180,3078,3060,\n        3058,3057,2989,2888,2809,2740,2720,2704,2620,2615,2570,2549,2513,\n        2500,2490,2450,2428,2410,2348,2333,2292,2287,2273,2270],\n    '길이_m' : [\n        4130,3976,3917,3902,3445,3395,3364,3030,2922,2763,2736,2705,2637,\n        2611,2466,2282,2270,2266,2250,2236,2100,1995,1980,1976,1913,1901,\n        1900,1900,1857,1795,1745.8,1703,1700,1690,1628,1625,1597,1584,\n        1562,1553,1547,1522,1509,1498,1459,1450,1424,1421,1412,1410],\n    '배수지역_km2' : [\n        3254555,7000000,1800000,2980000,2580000,745000,2990000,2582672,\n        3680000,1855000,2490000,810000,1790000,2090000,712035,1061000,\n        950000,1380000,960000,884000,1485200,63166,850000,610000,219000,\n        324000,1030000,570000,473000,817000,404200,1330000,454000,1024000,\n        534739,242259,1093000,900000,644000,270000,1547,1522,1509,1498,\n        1459,1450,1424,1421,1412,1410],\n    '평균유출량_m3_s' : [\n        2800,209000,30166,16792,18050,2571,12475,22000,41800,11400,15500,\n        16000,10300,5589,19800,767,13598,8080,7160,856,31200,8400,6210,\n        3300,703,3153,10100,82,3600,7130,13000,4880,1480,12037,1400,6000,\n        2575,4300,3800,270000,1547,1522,1509,1498,1459,1450,1424,1421,\n        1412,1410],\n    '방출지' : [\n        '지중해','대서양','동해','멕시코만',\n        '카라해','보해','오블만','리오데라플라타',\n        '대서양','오호츠크해','랩테프해','남중국해',\n        '보퍼트해','기니만','간지스','남쪽의해',\n        '대서양(마라조 만), 아마존 델타','카스피해',\n        '아라비아해','페르시아만','아마존','아마존','베링해',\n        '대서양','아랄해','안다만해','세인트로렌스만',\n        '멕시코만','예니세이강','흑해','안다만해',\n        '모잠비크해협','레나강','벵갈만','아랄해','아마존',\n        '헛슨만','파라나강','동시베리아해','파라과이강','옵강','이르티시강',\n        '카스피해','아마존','미시시피강','캘리포니아만',\n        '랩테프해','흑해','레나강','콩고'],\n    '이름': [\n        '나일–화이트나일–카게라–냐바롱고–모고고–루카라라',\n        '아마존–우카야리–탐보–에네–만타롤',\n        '창강–금샤강–통티안강–당쿠강 (장강)',\n        '미시시피–미주리–제퍼슨–비버헤드–레드락–헬로링',\n        '예니세이강–앙가라강–셀렝가강–이더','황허강',\n        '오블강–이르티시강','리오데라플라타–파라나강–리오그란데',\n        '콩고강–잠베시 (자이료)',\n        '두문강–아르군강–헤를런 (흑룽강)','레나강','메콩 (랑창강)',\n        '맥케너지강–스레이브강–피스강–핀레이','니제르강','브라마푸트라–얀룽창포',\n        '머리–달링–컬고아–발론–콘다믄','토칸찐스–아라구아이아',\n        '볼가','인다스–생거 장보','샤트알아랍–유프라테스–무랏',\n        '마데이라–마모레–그랜데–케인–로차','푸르스','유곤','상프란시스코',\n        '시르다리야–나린','살윈 (누강)',\n        '세인트로렌스–나이아가라–디트로이트–세인트클레어–세인트\\\n        메리스–세인트루이스–노스 (그레이트레이크스)','리오그란데','하횡강',\n        f\"도나우–브렉','두네르','두롱강–납마이강–둘롱강–케라올올루–가다쿠\",\n        '잠베지 (잠베지)','빌류이','간지스–후글리–팜다 (강가)',\n        '아무다리아–판즈','자푸라 (까퀘타)','넬슨–사스카추완',\n        '파라과이 (리오파라과이)','콜룸마','필코마요','상횡강–카툰',\n        '이심','우랄','주루아','아칸소어스','콜로라도 (미 서부)',\n        '올레니오크','드니프르','알단','우방기–우엘']\n}\n\ndf = pd.DataFrame(data)\ndf.to_csv('강_시스템.csv')\n```\n\n길이 (\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이것은 좋아 보이네요. Tableau에서 지도 레이어를 활용하기 위해 차트 다각형 및 중심점의 출력 데이터를 저장해봅시다. 나중에 사용할 삼각형의 좌표도 출력하여 나준합니다.\n\n```js\n# 출력 파일 (Tableau에서 지도 레이어를 활용하기 위해 데이터 재조정)\n\n# Quad-Tile 차트 다각형 출력\no_pqt.o_polyquadtile_chart.dataframe_rescale(-3,3,-2,4)\no_pqt.o_polyquadtile_chart.df = pd.merge(\n    o_pqt.o_polyquadtile_chart.df, df, left_on='item', right_on='river')\no_pqt.o_polyquadtile_chart.df = o_pqt.o_polyquadtile_chart.df[\n    ['river','side','x','y','path','length_km','length_m',\n    'drainage_area_km2','average_discharge_m3_s','outflow','name']]\no_pqt.o_polyquadtile_chart.dataframe_to_csv('quadtile')\n\n# Quad-Tile 차트 중심점 출력\no_pqt.o_polysquares.dataframe_rescale(-3,3,-2,4)\no_pqt.o_polysquares.df = pd.merge(\n    o_pqt.o_polysquares.df, df, left_on='id', right_on='river')\no_pqt.o_polysquares.df = o_pqt.o_polysquares.df[\n    ['river','side','x','y','length_km','length_m',\n    'drainage_area_km2','average_discharge_m3_s','outflow','name']]\no_pqt.o_polysquares.dataframe_to_csv('quadtile_centroids')\n\n# 삼각형 컨테이너 좌표\npoly = o_pqt.constraints\nrs_poly_yx = [(vf.rescale(y, -2, 4, -1, 1),\n    vf.rescale(x, -3, 3, -1, 1)) for x,y in poly]\nprint(rs_poly_yx)\n# 결과:\n# [(-0.691813852924281, -0.9166666666666669), \n# (0.8615194804090525, 0.0), \n# (-0.691813852924281, 0.9166666666666667)]\r\n```\n\n마지막으로, 상호 작용을 더 활성화하기 위해 범례를 생성해봅시다.\n\n```js\r\n#%% 범례 플롯\ndf_legend = df.groupby('outflow')['name'].count().reset_index()\no_pqt_legend = pqt(df_legend,'outflow','name', \n    constraints=[(4,1)], collapse=True,\n    rotate=45, buffer=.1, size_by='width', sides=['top','right'])\no_pqt_legend.polyquadtile_plot(show_constraints=True)\n\n#%% 범례 데이터\no_pqt_legend.o_polyquadtile_chart.dataframe_rescale(-2,6,-4,4)\no_pqt_legend.o_polyquadtile_chart.df = pd.merge(\n    o_pqt_legend.o_polyquadtile_chart.df, df_legend, \n    left_on='item', right_on='outflow')\no_pqt_legend.o_polyquadtile_chart.df = o_pqt_legend.o_polyquadtile_chart.df[\n    ['outflow','side','x','y','path','name']]\no_pqt_legend.o_polyquadtile_chart.dataframe_to_csv('quadtile_legend')\r\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![그림](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_31.png)\n\n이제 Tableau를 준비했으니, 다음 3개 파일을 모두 가져오기 위해 텍스트 파일 옵션을 사용하여 시작해보겠습니다. Sheet 1로 이동한 다음, 상단 왼쪽 데이터 탭에서 쿼드타일 데이터 소스를 선택하고 다음과 같은 계산 열을 생성하세요:\n\n먼저 맵 영역에서 마우스를 오른쪽 클릭하여 배경 레이어를 선택하고 다음 옵션을 조정해보세요:\n\n- 모든 배경 맵 레이어 (베이스, 랜드 커버 등)을 선택 해제하세요.\n- 이제 맵 영역에서 마우스를 오른쪽 클릭하고 맵 옵션을 선택한 다음, 패널에서 모든 옵션을 선택 해제하세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n배경 레이어를 닫고 다음 단계를 계속해 보세요:\n\n- [Side]를 Marks 하위에 Detail로 드래그합니다.\n- Marks 드롭다운 메뉴에서 Polygon을 선택합니다.\n- Color 하위에서 검은색 테두리 색상을 선택하고 불투명도를 40%로 조절한 다음 색상을 연한 파랑색으로 설정합니다.\n\n다음으로, 사각형에 대한 윤곽선 레이어를 추가해 봅시다:\n\n- [Squares]를 맵 영역으로 드래그하면 팝업이 나타납니다: Marks 레이어 추가 - 이를 클릭하여 새 맵 레이어를 만듭니다.\n- 팝업 메뉴에서 드롭다운 메뉴를 통해 필드를 'Outlines'로 이름을 변경합니다.\n- [River]를 이 새로운 맵 레이어의 Marks 하위 Detail로 드래그합니다.\n- Marks 드롭다운 메뉴에서 Line을 선택합니다 (이 시점에서 이상하게 보인다 해도 걱정하지 마세요).\n- [Path]를 Marks 하위 Path로 드래그하고 차원으로 변환하는 프로세스를 반복합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n메인 스퀘어 레이어에 대해 Marks 드롭다운 메뉴에서 Polygon을 선택하여 새 레이어에 대해 위 과정을 반복하고, [Drainage Area Km2]로 색을 입힙니다. '시작: 0, 끝: 3,000,000'으로 설정해주세요.\n\n마지막으로, 데이터 탭에서 quadtile_centroids를 선택하여 중심점을 사용하는 레이어를 추가하고, 다음과 같은 계산된 열을 추가해주세요:\n\nTableau에서 올바른 크기 조정을 위해 길이를 제곱한 것을 알 수 있습니다. 이를 다음 단계에서 사용할 것입니다:\n\n- [Centroids]를 지도 영역으로 드래그하면 팝업이 표시됩니다: Marks 레이어 추가 - 피말을 해당 위치에 드래그하여 새 지도 레이어를 생성합니다.\n- 이 새 지도 레이어에서 Marks 아래 Detail로 [River]를 드래그합니다.\n- Marks 드롭다운 메뉴에서 Circle을 선택합니다.\n- [Size]를 Marks 아래 Size로 드래그하고 이를 차원으로 변환하는 과정과 크기 틱을 두 번째 해시로 설정합니다.\n- [Average Discharge M3 S]를 Color로 드래그하고 하얀 테두리를 추가하고 '시작: 0, 끝: 50,000'으로 설정해주세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n오른쪽 하단에 널 경고 표시가 나타납니다. 이를 마우스 오른쪽 단추로 클릭하고 숨김 표시를 선택할 수 있습니다. 이 시점에서 상호작용 및 레이블을 나중에 구현하기 위해 아래에 표시된 몇 가지 다른 세부 정보와 속성을 추가한 것처럼 보일 것입니다:\n\n![image](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_32.png)\n\n이제 대시보드의 소스 자료를 완성하기 위해 세 개의 시트를 추가해 보겠습니다. 설정을 위해 이미지를 참조하십시오.\n\n- \"Bars\" - quadtile_centroids 데이터 소스를 사용します.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![이미지](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_33.png)\n\n- “범례” - quadtile_legend 데이터 소스 사용\n\n![이미지](/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_34.png)\n\n- “강” - quadtile_centroids 데이터 소스 사용, [이름]을 '정렬 기준: 필드, 정렬 순서: 내림차순, 필드 이름: [길이 Km], 집계: 최대값'으로 정렬 ('이름' 항목을 오른쪽 클릭하여 정렬... 선택)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_35.png\" /\u003e\n\n마지막 단계로, 이제 4개의 시트를 대시보드에 정리하고 대시보드 `동작` 아래의 상단 메뉴에서 몇 가지 동작을 설정해보겠습니다. 대시보드 `동작` 아래의 추가 동작 드롭다운을 클릭하고 `하이라이트`를 선택합니다. 대상 하이라이트에서 `선택한 필드`를 선택하고 [Outflow]과 [River] 필드를 선택합니다 ([Outflow]가 상기 시트에 세부사항으로 추가되었는지 확인). 마지막으로 오른쪽 상단의 `실행 동작` 아래에서 `가리키기` 옵션을 선택합니다.\n\n마지막 동작으로 추가 동작 드롭다운을 클릭하고 다음 옵션을 사용하여 필터를 선택합니다: '소스 시트: 범례, 대상 시트: 강, 선택한 필드: Outflow `quadtile_centroids` Outflow, 실행 동작: 선택시 실행, 선택 해제 시 모든 값 제외'. 이제 대시보드는 모든 시트에서 요청시 하이라이트를 표시하고 범례 시트에서 선택된 값에 대해 필터를 제외할 것입니다!\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1200/1*4CSKItCTjLiMaB7s09zolQ.gif\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 결론\n\n이 글에서 우리는 정방형이 원에 비해 채워진 도형 시각화에서 어떻게 성능을 발휘할 수 있는지 알아보기 위한 여정을 떠났습니다. 저희는 정방형의 적용을 테스트하기 위해 고수준 비교를 위한 최적화 프레임워크를 구현했고, 결국 정방형의 잠재력을 최대한 활용하기 위해 사용자 정의 알고리즘을 활용하기로 결정했습니다.\n\n저는 \"쿼드-타일 차트\"라고 명명한 것에 대한 상세한 안내서를 제공합니다. 이 차트는 값 세트를 시각화하는 데 사용되며, 또한 값 ​​계층 구조를 시각화하거나 시각화 캔버스의 사용 가능한 공간을 고려해 원하는 다각형 컨테이너 내에 정방형을 패킹하는 기능을 제공하는 \"스퀘어맵\"으로 확장됩니다.\n\n현재 데이터 시각화 공간에서 사용되는 주요 원 패킹 구현과는 다르게 다각형 컨테이너는 주요 장점으로 작용하며, Squaremap을 통해 계층 데이터는 새로운 집을 찾을 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n가능하면, Quad-Tile Chart의 사각형 배열은 시각적으로 매력적으로 보입니다 (원과 경쟁하기 위해 필수적입니다!) 그리고 사각형은 원의 중심에 배치된 원들과 서로 바꿔 쓸 수 있습니다 (반응형인 Bubble Chart를 위해) 이것은 데이터를 사각형으로 구성하는 경향을 정당화하기 위한 우리의 노력의 승리로 결론내릴 수 있습니다.\n\n각종 데이터 시리즈와 계층이 모든 코너를 도발하고 있을 때, 여러분이 이러한 시각화 기술을 데이터 탐색 여정에서 유용한 도구로 활용하길 바랍니다!\n\n## 참고 자료\n\n본 문서에 포함된 모든 이미지는 별도로 명시하지 않은 한 저자가 제작했습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n[1] 위키백과 (CC BY-SA), “최고의 빠른 동물” (기준일: 2024년 1월 26일)\n\n[2] 위키백과 (CC BY-SA), “길이별 강 시스템 목록” (기준일: 2024년 1월 26일)\n\n관련 기사\n\n- 복잡한 집합 관계를 시각화하는 Multi-Chord Diagram 소개","ogImage":{"url":"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-IntroducingtheQuad-TileChartSquaremapSquarifyYourData_0.png","tag":["Tech"],"readingTime":59},{"title":"FB Prophet과 하이퍼파라미터 최적화를 사용한 BTC-USD 가격 예측, 교차 검증 QC, 수정된 알고리즘 거래 전략","description":"","date":"2024-07-13 19:54","slug":"2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies","content":"\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_0.png\" /\u003e\n\n- 본 글은 이전 연구를 이어가며, Python에서 Facebook의 Prophet을 활용한 BTC-USD 가격 예측에 대한 자세한 프레임워크를 개발하는 것을 목표로 합니다 [1–5] (참고 문헌).\n- 현재의 비교 분석은 시간 시리즈 교차 검증 QC를 기반으로 한 히스토리컬 데이터를 사용하여 예측 오차를 측정하는 HPO 또는 모델 튜닝에 대해 자세히 살펴봅니다.\n- 시뮬레이션된 BTC 예측에 추가되어, FB Prophet을 사용하여 크립토 알고트레이딩 전략을 최적화하는 방법에 대해 Buy \u0026 Hold 기준과 비교하여 설명합니다. 자세한 내용은 여기에서 확인하세요.\n\n## 비즈니스 케이스\n\n- 적절한 암호화폐 예측은 크립토 트레이더들에게 큰 이익을 가져다줄 수 있으며 효과적인 리스크 관리를 제공할 수 있습니다.\n- 최근 BTC는 많은 가격 예측의 주제가 되었습니다.\n- CoinCodex: BTC의 역사적인 가격 변동과 BTC 하프 사이클을 기반으로, BTC가 상한 가격 대상에 도달한다면 2025년까지 201.59%의 이익을 올릴 수 있습니다. 한편, BTC의 가격은 내년에 $173,833까지 상승할 것으로 예측됩니다.\n- 하지만 비트코인 가격이 2030년까지 1백만 달러에 도달할까요?\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## FB Prophet에 대해\n\n- FB Prophet은 추세/계절성 모델링과 베이지안 추론에 기초한 시계열 데이터 예측 절차입니다.\n- 강한 계절 효과가 있는 시계열에 가장 적합하며, 누락 된 데이터, 이상치 및 추세 변동에 견고합니다.\n- 예측 모델은 다음과 같은 4가지 구성 요소로 구성됩니다: 추세(장기간 동안의 변화), 계절성(주기적 또는 단기 변화), 휴일 및 특정 비즈니스에만 해당되는 조건부 변경 사항.\n- 새로운 사용자에게 특히 흥미롭습니다. 모델의 하이퍼파라미터를 자동으로 찾아내는 능력과 쉬운 사용성으로 유명합니다.\n- 추가적인 회귀 변수, 곱셈 계절성, 비일일 데이터, 불확실성 측정 및 진단이 포함됩니다.\n\n이 라이브러리를 사용하여 BTC-USD 가격 예측의 구체적 내용을 살펴봅시다.\n\n## 주요 설치 방법\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- pip은 저희가 선호하는 설치 프로그램입니다. Python 3.4부터 Python 이진 설치 프로그램에 기본적으로 포함되어 있습니다.\n- Jupyter Notebook을 실행하고 필수 Python 라이브러리를 설치합니다.\n\n```python\n!pip install statsmodels, math, yfinance, prophet, plotly,matplotlib, itertools\n```\n\n## Imports \u0026 Settings\n\n- 코드를 성공적으로 실행할 수 있도록 필요한 라이브러리 및 종속성이 제대로 설치되어 있는지 확인하세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport pandas as pd\nimport plotly.express as px\nimport requests\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom math import floor\nfrom termcolor import colored as cl\nimport yfinance as yf\nimport datetime\nfrom datetime import date, timedelta\n\n# Prophet 라이브러리 불러오기\nfrom prophet import Prophet\n\nplt.rcParams['figure.figsize'] = (12, 6)\nplt.style.use('fivethirtyeight')\n\nimport os\nos.chdir('작업경로')    # 작업 디렉토리 설정\nos.getcwd()\n```\n\n## 주식 데이터 입력\n\n- 730일의 BTC-USD 이력 데이터 입력\n\n```js\ntoday = date.today()\n\nd1 = today.strftime(\"%Y-%m-%d\")\nend_date = d1\nd2 = date.today() - timedelta(days=730)\nd2 = d2.strftime(\"%Y-%m-%d\")\nstart_date = d2\n\ndata = yf.download('BTC-USD', \n                      start=start_date, \n                      end=end_date, \n                      progress=False)\ndata[\"Date\"] = data.index\ndata = data[[\"Date\", \"Open\", \"High\", \"Low\", \"Close\", \"Adj Close\", \"Volume\"]]\ndata.reset_index(drop=True, inplace=True)\ndata.tail()\n\n|   Date    |    Open    |    High    |   Low    |   Close    |  Adj Close  |   Volume      |\n|----------|------------|------------|---------|------------|-------------|--------------|\n|2024-07-02| 62,844.41  | 63,203.36  | 61,752.75|   62,029.02 |  62,029.02  |  20151616992  |\n|2024-07-03| 62,034.33  | 62,187.70  | 59,419.39|   60,173.92 |  60,173.92  |  29756701685  |\n|2024-07-04| 60,147.14  | 60,399.68  | 56,777.80|   56,977.70 |  56,977.70  |  41149609230  |\n|2024-07-05| 57,022.81  | 57,497.15  | 53,717.38|   56,662.38 |  56,662.38  |  55417544033  |\n|2024-07-06| 56,659.07  | 58,472.55  | 56,038.96|   58,303.54 |  58,303.54  |  20610320577  |\n```   \n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 종가 그래프 그리기\n\n```js\nplt.plot(data['Date'], data['Close'])\nplt.xlabel('날짜')\nplt.ylabel('종가(USD)')\nplt.title('BTC-USD 종가')\n```\n\n![BTC-USD Close Price](/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_1.png)\n\n## 데이터 준비\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Box Cox 변환을 사용하여 비정규적인 종속 변수인 Close 가격을 정규분포 형태로 변환합니다.\n\n```js\n### Box Cox 변환\nfrom statsmodels.base.transform import BoxCox\n\nbc = BoxCox()\ndata[\"Close\"], lmbda = bc.transform_boxcox(data[\"Close\"])\n```\n\n- Prophet에 입력 데이터 만들기\n\n```js\ndata1 = data[[\"Date\", \"Close\"]]\ndata1.columns = [\"ds\", \"y\"]\n\ndata1.tail()\n\n    ds          y\n725 2024-07-02 42.381398\n726 2024-07-03 42.086488\n727 2024-07-04 41.560999\n728 2024-07-05 41.507898\n729 2024-07-06 41.781750\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Prophet에 입력해야 하는 것은 항상 ds와 y 두 개의 열이 있는 데이터프레임입니다. ds (날짜) 열은 Pandas에서 예상하는 형식이어야 합니다. 날짜의 경우 YYYY-MM-DD이고, 타임스탬프의 경우 YYYY-MM-DD HH:MM:SS입니다. y 열은 숫자이어야 하며, 예측하려는 측정 값을 나타냅니다.\n\n## Max Cap과 5% 표준편차를 사용한 Prophet\n\n- 매년 곱셈 계절성과 로지스틱 성장이 있는 모델 매개변수 목록을 생성합니다.\n\n```js\nmodel_param = {\n    \"daily_seasonality\": False,\n    \"weekly_seasonality\": False,\n    \"yearly_seasonality\": True,\n    \"seasonality_mode\": \"multiplicative\",\n    \"growth\": \"logistic\"\n}\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 기본적으로 Prophet은 가법 계절성 모델을 적합시키며, 계절성의 영향이 예측을 얻기 위해 추세에 더해집니다. 위 모델에서 계절성은 Prophet이 가정한 것처럼 일정한 가법적 요소가 아니라 추세와 함께 증가하는 다중 계절성입니다.\n- 기본적으로 Prophet은 예측을 위해 선형 모델을 사용합니다. 성장을 예측할 때 일반적으로 일정한 최대 달성 가능 지점이 있습니다: 총 시장 규모 등. 이를 운반 용량이라고하며, 예측은 이 지점에서 포화되어야 합니다. Prophet은 지정된 운반 용량을 갖춘 로지스틱 성장 트렌드 모델을 사용하여 예측을 수행할 수 있습니다.\n- 모델 실행\n\n```js\nmodel = Prophet(**model_param)\n```\n\n- 로지스틱 성장을 사용하기 때문에 예측에 대한 상한선 또는 상한 값을 설정합니다. 상한값은 가격의 최대값에 표준편차의 5%를 더하는 것입니다.\n\n```js\ndata1['cap'] = data1[\"y\"].max() + data1[\"y\"].std() * 0.05\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 모델을 맞추는 중\n\n```js\nmodel.fit(data1)\n```\n\n- 위의 캡을 사용하여 샘플 내부 및 1년 장기 예측 생성\n\n```js\nfuture= model.make_future_dataframe(periods=365)\n\nfuture['cap'] = data1['cap'].max()\n\nforecast= model.predict(future)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 중요한 구성 요소를 사용하여 (ds-y) 도메인 예측을 플로팅합니다.\n\n```js\nmodel.plot(forecast,figsize=(14, 8))\n```\n\n![BTC-USD 가격 예측](/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_2.png)\n\n```js\nmodel.plot_components(forecast,figsize=(16, 10));\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이전에 사용하던 table tag를 Markdown 형식으로 변경해보세요.\n\n## Prophet with Monthly/Quarterly Seasonality \u0026 US Holidays\n\n- Prophet를 월별/분기별 계절성 및 미국 공휴일과 함께 실행 중\n\n```js\nmodel = Prophet(**model_param)\n\nmodel.add_seasonality(name=\"monthly\", period=30, fourier_order=10)\nmodel.add_seasonality(name=\"quarterly\", period=92.25, fourier_order=10)\n\nmodel.add_country_holidays(\"US\")\n\nmodel.fit(data1)\n\n# 미래 데이터프레임 생성\nfuture = model.make_future_dataframe(periods=365)\nfuture['cap'] = data1['cap'].max()\n\nforecast = model.predict(future)\n\nfrom prophet.plot import plot\n\nplot(model, forecast, figsize=(14, 8))\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nfrom prophet.plot import plot_components\n\nplot_components(model, forecast, figsize=(10, 12))\n```\n\n위의 코드 블록은 Prophet 모델을 사용하여 예측한 데이터의 구성요소를 시각화하는 부분입니다. 코드를 실행하여 예측 결과를 확인해보세요! 🚀\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 원래 가격을 얻기 위해 역 Box-Cox 변환을 수행합니다\n\n```js\nforecast[\"yhat\"]=bc.untransform_boxcox(x=forecast[\"yhat\"], lmbda=lmbda)\nforecast[\"yhat_lower\"]=bc.untransform_boxcox(x=forecast[\"yhat_lower\"], lmbda=lmbda)\nforecast[\"yhat_upper\"]=bc.untransform_boxcox(x=forecast[\"yhat_upper\"], lmbda=lmbda)\nforecast.plot(x=\"ds\", y=[\"yhat_lower\", \"yhat\", \"yhat_upper\"])\n```\n\n![BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_7](/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_7.png)\n\n- 수동으로 선택한 cutoff를 사용하여 예측 성능의 몇 가지 유용한 통계를 계산합니다\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nfrom prophet.diagnostics import cross_validation, performance_metrics\nfrom prophet.plot import plot_cross_validation_metric\ndf_cv = cross_validation(model, initial=\"600 days\", period=\"30 days\", horizon=\"90 days\")\ncutoffs = pd.to_datetime(['2022-09-01', '2023-05-01', '2024-03-01'])\ndf_cv2 = cross_validation(model, cutoffs=cutoffs, horizon='90 days')\nfig = plot_cross_validation_metric(df_cv2, metric='rmse')\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_8.png\" /\u003e\n\n- 성능 메트릭 요약 정보 출력\n\n```js\ndf_p = performance_metrics(df_cv2)\ndf_p.head()\n\n    horizon mse      rmse       mae       mape     mdape   smape coverage\n0 9 days 3805.462369 61.688430 29.520999 0.893692 0.118312 0.355870 0.0\n1 10 days 5382.793620 73.367524 37.768231 1.140719 0.168333 0.425770 0.0\n2 11 days 6754.735216 82.187196 45.409934 1.368028 0.286148 0.491224 0.0\n3 12 days 7678.053041 87.624500 51.465541 1.551664 0.352840 0.546114 0.0\n4 13 days 8071.329465 89.840578 55.027843 1.658574 0.426625 0.584601 0.0\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- MAPE 그래프 그리기\n\n```js\nfig = plot_cross_validation_metric(df_cv2, metric='mape')\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_9.png\" /\u003e\n\n- MAE 그래프 그리기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nfig = plot_cross_validation_metric(df_cv2, metric='mae')\n```\n\n![BTC-USD Price Prediction using FB Prophet with Hyperparameter Optimization Cross-Validation QC Modified Algorithm Trading Strategies](/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_10.png)\n\n## Hyperparameter Optimization (HPO)\n\n- Running HPO by adding monthly/quarterly seasonality and US holidays\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nrmses = list()\n\n# 각 조합을 순회합니다.\nfor params in all_params:\n    m = Prophet(**params)\n    \n    m = m.add_seasonality(name='monthly', period=30, fourier_order=5)\n    m = m.add_seasonality(name='quarterly', period=92.25, fourier_order=10)\n\n    m.add_country_holidays(country_name='US')\n    \n    m.fit(data1)\n    \n    df_cv = cross_validation(m, initial='500 days', period='180 days', horizon='90 days')\n    \n    df_p = performance_metrics(df_cv, rolling_window=1)\n    \n    rmses.append(df_p['rmse'].values[0])\n    \n# 최적의 매개변수를 찾습니다.\nbest_params = all_params[np.argmin(rmses)]\n    \nprint(\"\\n최적의 매개변수는:\", best_params)\n```\n\n- 최적화된 모델을 피팅하고 해당하는 예측 생성\n\n```js\nmodel_param1 = {\n    'daily_seasonality': False,\n    'weekly_seasonality': False,\n    'yearly_seasonality': True,\n    'seasonality_mode': 'multiplicative',\n    'growth': 'logistic',\n    'seasonality_prior_scale': 0.1,\n    'changepoint_prior_scale': 0.01\n}\n\nmodel1 = Prophet(**model_param1)\n\nmodel1.add_country_holidays('US')\n\nmodel1.fit(data1)\n\n# 향후 데이터 프레임 생성\nfuture = model1.make_future_dataframe(periods=365)\nfuture['cap'] = data1['cap'].max()\n\nforecast = model1.predict(future)\n```\n\n- 원래 가격을 얻기 위해 역 Box-Cox 변환을 적용합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n js\nforecast[\"yhat\"]=bc.untransform_boxcox(x=forecast[\"yhat\"], lmbda=lmbda)\nforecast[\"yhat_lower\"]=bc.untransform_boxcox(x=forecast[\"yhat_lower\"], lmbda=lmbda)\nforecast[\"yhat_upper\"]=bc.untransform_boxcox(x=forecast[\"yhat_upper\"], lmbda=lmbda)\nforecast.plot(x=\"ds\", y=[\"yhat_lower\", \"yhat\", \"yhat_upper\"])\n\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_11.png\" /\u003e\n\n- 수동 cutoff로 교차 검증 QC 실행 중\n\n```js\ncutoffs = pd.to_datetime(['2022-09-01', '2023-05-01', '2024-03-01'])\ndf_cv2 = cross_validation(model1, cutoffs=cutoffs, horizon='90 days')\nfig = plot_cross_validation_metric(df_cv2, metric='rmse')\n``` \n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_12.png)\n\n\n```js\nfig = plot_cross_validation_metric(df_cv2, metric='mape')\n```\n\n![image](/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_13.png)\n\n```js\nfig = plot_cross_validation_metric(df_cv2, metric='mae')\n``` \n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![BTC-USD Price Prediction](/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_14.png)\n\n## 2020년부터 2024년까지 BTC-USD 역사적 데이터 준비\n\n- 박스-콕스(Box-Cox) 변환을 하지 않고 2020년 01월 01일부터 2024년 07월 07일까지의 BTC-USD 역사적 데이터를 준비합니다.\n\n```js\nimport pandas as pd\nimport numpy as np\nfrom prophet import Prophet\nimport matplotlib.pyplot as plt\nfrom functools import reduce\n\n%matplotlib inline\nimport warnings\nwarnings.filterwarnings('ignore')\n\npd.options.display.float_format = \"{:,.2f}\".format\n\nimport yfinance as yf\n\nticker = 'BTC-USD'\nstart_date = '2020-01-01'\n\nstock_price = yf.download(ticker, start=start_date)\nstock_price[\"날짜\"] = stock_price.index\nstock_price.tail()\n\n           Open      High      Low       Close    Adj Close   Volume      날짜\nDate       \n2024-07-03 62,034.33 62,187.70 59,419.39 60,173.92 60,173.92 29756701685 2024-07-03\n2024-07-04 60,147.14 60,399.68 56,777.80 56,977.70 56,977.70 41149609230 2024-07-04\n2024-07-05 57,022.81 57,497.15 53,717.38 56,662.38 56,662.38 55417544033 2024-07-05\n2024-07-06 56,659.07 58,472.55 56,038.96 58,303.54 58,303.54 20610320577 2024-07-06\n2024-07-07 58,239.43 58,367.18 56,644.89 57,198.04 57,198.04 19585976320 2024-07-07\n\nstock_price = stock_price[['날짜','Adj Close']]\n\nstock_price.columns = ['ds', 'y']\nstock_price.tail()\n\n           ds          y\nDate  \n2024-07-03 2024-07-03 60,173.92\n2024-07-04 2024-07-04 56,977.70\n2024-07-05 2024-07-05 56,662.38\n2024-07-06 2024-07-06 58,303.54\n2024-07-07 2024-07-07 57,198.04\n```\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 기본 Prophet 모델을 적합시키고 2027년 7월 7일까지의 예측을 생성합니다.\n\n```js\nmodel = Prophet()\nmodel.fit(stock_price)\nfuture = model.make_future_dataframe(1095, freq='d')\n\nfuture_boolean = future['ds'].map(lambda x : True if x.weekday() in range(0, 5) else False)\nfuture = future[future_boolean] \n\nfuture.tail()\nds\n2738 2027-07-01\n2739 2027-07-02\n2742 2027-07-05\n2743 2027-07-06\n2744 2027-07-07\n\nforecast = model.predict(future)\n#forecast.tail()\n\nmodel.plot(forecast);\r\n```\n\n![BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_15](/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_15.png)\n\n- 주요 구성 요소를 플롯합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\nmodel.plot_components(forecast);\n\n\n![Forecast Plot](/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_16.png)\n\n- 원래 가격과 예측을 신뢰 구간과 함께 그래픽으로 표시합니다.\n\n```python\nstock_price_forecast = forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']]\ndf = pd.merge(stock_price, stock_price_forecast, on='ds', how='right')\ndf.set_index('ds').plot(figsize=(16,8), color=['royalblue', \"#34495e\", \"#e74c3c\", \"#e74c3c\"], grid=True);\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_17.png)\n\n- Date 열을 3 부분(연/월/일)으로 분할하고 Prophet 모델을 fitting합니다.\n\n```python\nstock_price['dayname'] = stock_price['ds'].dt.day_name()\nstock_price['month'] = stock_price['ds'].dt.month\nstock_price['year'] = stock_price['ds'].dt.year\nstock_price['month/year'] = stock_price['month'].map(str) + '/' + stock_price['year'].map(str) \n\nstock_price = pd.merge(stock_price, \n                       stock_price['month/year'].drop_duplicates().reset_index(drop=True).reset_index(),\n                       on='month/year',\n                       how='left')\n\nstock_price = stock_price.rename(columns={'index':'month/year_index'})\n\nloop_list = stock_price['month/year'].unique().tolist()\nmax_num = len(loop_list) - 1\nforecast_frames = []\n\nfor num, item in enumerate(loop_list):\n\n    if  num == max_num:\n        pass\n    else:\n        df = stock_price.set_index('ds')[\n             stock_price[stock_price['month/year'] == loop_list[0]]['ds'].min():\\\n             stock_price[stock_price['month/year'] == item]['ds'].max()]\n        \n        df = df.reset_index()[['ds', 'y']]\n        \n        model = Prophet()\n        model.fit(df)\n        \n        future = stock_price[stock_price['month/year_index'] == (num + 1)][['ds']]\n\n        forecast = model.predict(future)\n        forecast_frames.append(forecast)\n```\n\n- In-sample forecast와 원래 가격을 비교하는 그래프 그리기\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\n주가 예측 = reduce(lambda top, bottom: pd.concat([top, bottom], sort=False), 예측_프레임)\n주가 예측 = 주가 예측[['일자', '예측값', '예측값_하한', '예측값_상한']]\n\n데이터프레임 = pd.merge(주가[['일자','실제가격', '월/연도_인덱스']], 주가 예측, on='일자')\n데이터프레임['변동률'] = 데이터프레임['실제가격'].pct_change()\n데이터프레임.set_index('일자')[['실제가격', '예측값', '예측값_하한', '예측값_상한']].plot(figsize=(16,8), color=['royalblue', \"#34495e\", \"#e74c3c\", \"#e74c3c\"], grid=True)\n```\n\n![이미지](/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_18.png)\n\n- 교차 검증 수행 중\n\n```python\nfrom prophet.diagnostics import performance_metrics\n성능_메트릭스 = performance_metrics(df_cv)\n성능_메트릭스.head()\n\n  horizon  mse          rmse      mae     mape mdape smape coverage\n0 37 일    40,821,715.40 6,389.19 4,890.31 0.18 0.12 0.22 0.55\n1 38 일    41,109,990.95 6,411.71 4,913.96 0.18 0.12 0.22 0.55\n2 39 일    41,311,288.83 6,427.39 4,922.43 0.19 0.12 0.22 0.55\n3 40 일    41,641,137.72 6,452.99 4,943.99 0.19 0.12 0.22 0.55\n4 41 일    42,299,834.63 6,503.83 5,003.53 0.19 0.12 0.23 0.54\n\nfrom prophet.plot import plot_cross_validation_metric\n그래프 = plot_cross_validation_metric(df_cv, metric='rmse')\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![Plotting MAPE](/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_19.png)\n\n- MAPE 플로팅\n\n```js\nfig = plot_cross_validation_metric(df_cv, metric='mape')\n```\n\n![MAPE Plot](/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_20.png)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- MAE 그래프 플로팅하기\n\n```js\nfig = plot_cross_validation_metric(df_cv, metric='mae')\n```\n\n![MAE Plot](/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_21.png)\n\n- 그리드 검색 하이퍼파라미터 최적화 구현 및 MAE를 사용하여 모델 평가하기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 하이퍼파라미터 그리드 정의\nfrom sklearn.metrics import mean_absolute_error\nparam_grid = {\n    'seasonality_mode': ['additive', 'multiplicative'],\n    'changepoint_prior_scale': [0.01, 0.1, 1, 10],\n    'seasonality_prior_scale': [0.01, 0.1, 1, 10],\n}\n\n# 모델을 평가하기 위한 도우미 함수\ndef evaluate_model(model, metric_func):\n    df_cv = cross_validation(model, initial='1125 days', period='180 days', horizon='365 days')\n    return metric_func(df_cv['y'], df_cv['yhat'])\n\n# 그리드 서치\nbest_params = {}\nbest_score = float('inf')\n\nfor mode in param_grid['seasonality_mode']:\n    for cps in param_grid['changepoint_prior_scale']:\n        for sps in param_grid['seasonality_prior_scale']:\n            # 현재 하이퍼파라미터를 사용하여 모델 생성\n            m = Prophet(seasonality_mode=mode, changepoint_prior_scale=cps, seasonality_prior_scale=sps)\n            m.fit(stock_price)\n\n            # 평가 지표로 평가 모델(Mean Absolute Error 사용)\n            score = evaluate_model(m, mean_absolute_error)\n\n            # 필요 시 최적의 매개변수 업데이트\n            if score \u003c best_score:\n                best_score = score\n                best_params = {\n                    'seasonality_mode': mode,\n                    'changepoint_prior_scale': cps,\n                    'seasonality_prior_scale': sps\n                }\n\nprint(best_params)\n\n{'seasonality_mode': 'additive', 'changepoint_prior_scale': 0.1, 'seasonality_prior_scale': 10}\n\nprint(best_score)\n8675.430008099349\n```\n\n- 최적화된 모델을 적합하고 1년 예측 생성\n\n```js\n# 최적의 매개변수로 모델 생성\nm_best = Prophet(seasonality_mode='additive', changepoint_prior_scale=0.1, seasonality_prior_scale=10)\nm_best.fit(stock_price)\n\n# 365일을 포함한 예측을 위한 데이터프레임\nfuture_best = m_best.make_future_dataframe(periods=365)\nforecast_best = m_best.predict(future_best)\n\n# 예측 데이터와 함께 그래프 그리기\nfig1 = m.plot(forecast_best)\nax = fig1.gca()\nax.set_title(\"BTC-USD 주가 예측\", size=25)\nax.set_xlabel(\"날짜\", size=15)\nax.set_ylabel(\"가격\", size=15)\n```\n\n![BTC-USD Stock Price Forecast](/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_22.png)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- scikit-learn과 Prophet 지표를 사용하여 교차 검증 QC 수행 중\n\n```js\n# 교차 검증 실행\nfrom sklearn.metrics import mean_squared_error\ndf_cv = cross_validation(m_best, initial='1125 days', period='180 days', horizon='365 days')\n\n# 성능 지표 계산\ndf_metrics = performance_metrics(df_cv)\n\n# MAE, MSE 및 RMSE 계산\nmae = mean_absolute_error(df_cv['y'], df_cv['yhat'])\nmse = mean_squared_error(df_cv['y'], df_cv['yhat'])\nrmse = np.sqrt(mse)\n\nprint(f'평균 절대 오차: {mae:.2f}')\nprint(f'평균 제곱 오차: {mse:.2f}')\nprint(f'제곱근 평균 제곱 오차: {rmse:.2f}')\n\n평균 절대 오차: 8675.43\n평균 제곱 오차: 107375840.73\n제곱근 평균 제곱 오차: 10362.23\n\nfrom prophet.plot import plot_cross_validation_metric\ndf_cv = cross_validation(m_best, initial='1125 days', period='180 days', horizon='365 days')\nfig = plot_cross_validation_metric(df_cv, metric='rmse')\r\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_23.png\" /\u003e\n\n- MAPE 플로팅하기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nfig = plot_cross_validation_metric(df_cv, metric='mape')\n```\n\n![image](/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_24.png)\n\n- MAE 그리기\n\n```python\nfig = plot_cross_validation_metric(df_cv, metric='mae')\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_25.png\" /\u003e\n\n- In-Sample 및 Out-of-Sample 1년 Prophet 예측과 신뢰 구간을 동시에 플로팅합니다 (원래 스케일)\n\n```js\nloop_list = stock_price['month/year'].unique().tolist()\nmax_num = len(loop_list) - 1\nforecast_frames = []\n\nfor num, item in enumerate(loop_list):\n\n    if num == max_num:\n        pass\n    else:\n        df = stock_price.set_index('ds')[\n             stock_price[stock_price['month/year'] == loop_list[0]]['ds'].min():\\\n             stock_price[stock_price['month/year'] == item]['ds'].max()]\n        \n        df = df.reset_index()[['ds', 'y']]\n        \n        future = stock_price[stock_price['month/year_index'] == (num + 1)][['ds']]\n\n        forecast = m_best.predict(future)\n        forecast_frames.append(forecast)\n\nstock_price_forecast1 = reduce(lambda top, bottom: pd.concat([top, bottom], sort=False), forecast_frames)\nstock_price_forecast1 = stock_price_forecast1[['ds', 'yhat', 'yhat_lower', 'yhat_upper']]\n\ndf1 = pd.merge(stock_price[['ds','y', 'month/year_index']], stock_price_forecast1, on='ds')\ndf1['Percent Change'] = df1['y'].pct_change()\ndf1.set_index('ds')[['y', 'yhat', 'yhat_lower', 'yhat_upper']].plot(figsize=(16,8), color=['royalblue', \"#34495e\", \"#e74c3c\", \"#e74c3c\"], grid=True)\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_26.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 수정된 암호화폐 알고리즘 트레이딩 전략\n\n- 다음과 같이 Prophet를 기반으로 한 암호화폐 알고리즘 트레이딩 전략을 수정합시다.\n\n```js\n#트레이딩 알고리즘\ndf=df1.copy()\ndf['Hold'] = (df['Percent Change'] + 1).cumprod()\ndf['Prophet'] = ((df['yhat'].shift(-1) \u003e df['yhat']).shift(1) * (df['Percent Change']) + 1).cumprod()\ndf['Prophet Thresh'] = ((df['y'] \u003c df['yhat_upper']).shift(1) * (df['Percent Change']) + 1).cumprod()\ndf['Seasonality'] = ((~df['ds'].dt.month.isin([8,9])).shift(1) * (df['Percent Change']) + 1).cumprod()\n\n(df.dropna().set_index('ds')[['Hold', 'Prophet', 'Prophet Thresh','Seasonality']] * 1000).plot(figsize=(16,8), grid=True)\n\nprint(f\"Hold = {df['Hold'].iloc[-1]*1000:,.0f}\")\nprint(f\"Prophet = {df['Prophet'].iloc[-1]*1000:,.0f}\")\nprint(f\"Prophet Thresh = {df['Prophet Thresh'].iloc[-1]*1000:,.0f}\")\nprint(f\"Seasonality = {df['Seasonality'].iloc[-1]*1000:,.0f}\")\n\nHold = 6,090\nProphet = 87,595\nProphet Thresh = 18,681\nSeasonality = 7,172\n```\n\n![이미지](/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_27.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 여기에서 Prophet Thresh df['y']` df['yhat_lower'] 를 조건 df['y']` df['yhat_upper'] 로 바꿔 더 높은 예상 수익을 얻을 수 있었습니다.\n- 위의 Prophet 임계값을 최적화해 봅시다.\n\n```js\nperformance = {}\n\nfor x in np.linspace(.9,.99,10):\n    y = ((df['y'] \u003c df['yhat_upper']*x).shift(1)* (df['퍼센트 변화']) + 1).cumprod()\n    performance[x] = y\n    \nbest_yhat = pd.DataFrame(performance).max().idxmax()\npd.DataFrame(performance).plot(figsize=(16,8), grid=True);\nf'최적의 Yhat = {best_yhat:,.2f}'\n\n'최적의 Yhat = 0.92'\n```\n\n![이미지](/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_28.png)\n\n- Best Yhat = 0.92로 백테스트 실행중\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\r\ndf['Optimized Prophet Thresh'] = ((df['y'] \u003c df['yhat_upper'] * best_yhat).shift(1) * \r\n                                  (df['Percent Change']) + 1).cumprod()\r\n\r\n(df.dropna().set_index('ds')[['Hold', 'Prophet', 'Prophet Thresh', \r\n                              'Seasonality', 'Optimized Prophet Thresh']] * 1000).plot(figsize=(16,8), grid=True)\r\n\r\nprint(f\"Hold = {df['Hold'].iloc[-1]*1000:,.0f}\")\r\nprint(f\"Prophet = {df['Prophet'].iloc[-1]*1000:,.0f}\")\r\nprint(f\"Prophet Thresh = {df['Prophet Thresh'].iloc[-1]*1000:,.0f}\")\r\nprint(f\"Seasonality = {df['Seasonality'].iloc[-1]*1000:,.0f}\")\r\nprint(f\"Optimized Prophet Thresh = {df['Optimized Prophet Thresh'].iloc[-1]*1000:,.0f}\")\r\n\r\nHold = 6,090\r\nProphet = 87,595\r\nProphet Thresh = 18,681\r\nSeasonality = 7,172\r\nOptimized Prophet Thresh = 36,769\r\n```\r\n\r\n\u003cimg src=\"/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_29.png\" /\u003e\r\n\r\n- 요약:\r\n    - ROI(Prophet)/ROI(Optimized Prophet Thresh) 약 2.4배\r\n    - ROI(Prophet)/ROI(Hold) 약 14.0배\r\n    - ROI(Optimized Prophet Thresh)/ROI(Prophet Thresh) 약 2.0배\r\n    - ROI(Prophet Thresh)/ROI(Seasonality) 약 2.5배\r\n    - ROI(Seasonality)/ROI(Hold) 약 1.0배\r\n\r\n## 프로핏 플롯리 시각화와 변경 지점들\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Prophet Plotly 시각화 옵션을 살펴봅시다.\n\n```js\nmydf=stock_price[['ds','y']]\nmm = Prophet()\nmm.fit(mydf)\nfuture = mm.make_future_dataframe(periods=365)\nforecast = mm.predict(future)\nfrom prophet.plot import plot_plotly\n\nplot_plotly(mm, forecast)\n```\n\n![Prophet Plotly Visualization](/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_30.png)\n\n- Plotly를 사용하여 Prophet 예측값과 변화점을 시각화합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nfrom prophet.plot import plot_plotly\n\nplot_plotly(mm, forecast, changepoints=True)\n```\n\n![BTC-USD Price Prediction](/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_31.png)\n\n## 결론\n\n- 이 포스트에서는 Prophet (Facebook의 시계열 예측 라이브러리)를 사용하여 BTC-USD 가격을 예측하는 방법을 분석했습니다.\n- Yahoo Finance Python을 사용하여 2 개의 데이터 세트를 다운로드했습니다: (1) 2024-07-06까지 730 일 동안; (2) 2020-01-01부터 2024-07-07까지.\n- 데이터 세트 1을 사용하여 Box-Cox 변환과 미국의 휴일을 고려한 HPO를 테스트했습니다.\n- 데이터 세트 2를 다운로드하여 Prophet HPO 예측을 3 부분(연도, 월, 일)으로 분할 한 후 루프를 통해 다중 계절성 처리의 가치를 보여주었습니다.\n- Prophet 교차 검증 기능에 대한 자세한 내용을 탐구하여 두 데이터 세트에 대한 RMSE, MAPE 및 MAE와 같은 여러 주요 지표를 비교했습니다.\n- 데이터 세트 2: 최종 인샘플 Prophet 오류 지표는 다음과 같습니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nMean Absolute Error: 8675.43\nMean Squared Error: 107375840.73\nRoot Mean Squared Error: 10362.23\n```\n\n- 데이터 집합 2: 350일 주기의 외부 샘플 Prophet HPO 오류 메트릭\n\n```js\nMAPE 약 0.2-0.4, (MAE, RMSE) 약 10k-15k\n```\n\n- Plotly를 사용하여 Prophet 예측 시점의 변화를 그래픽으로 표현하는 가치를 설명했습니다.\n- 마지막으로, 데이터 집합 2를 사용하여 여러 유용한 Prophet 기반 백테스팅 암호화 알고리즘 트레이딩 전략을 Hold 벤치마크에 대해 탐색했습니다.\n- 백테스팅 결과는 ROI(Prophet)/ROI(Hold) 약 14.0임을 보여주었습니다.\n- 테스트 결과, Prophet 추세가 외부 데이터 없이도 정확히 추정될 수 있음을 확인했습니다. 시계열이 강력한 계절적 사업주기를 따른다는 것을 고려할 때, Prophet가 상당히 잘 작동한다는 것을 발견했습니다.\n- Prophet의 다른 통계 모델 및 기계 학습보다 중요한 장점 중 하나는 해석 가능성입니다. Prophet은 시간 기능을 따로 만들 필요가 없기 때문에 빠르게 좋은 기준을 제공합니다.\n- 전반적으로, 시계열이 비즈니스 주기를 따라간다면 Prophet를 기준 모델로 사용할 가치가 있다는 결론을 내립니다 (참고 자료 참조).\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 참고 자료\n\n- Facebook Prophet를 사용한 주식 가격 예측\n- Prophet 진단\n- Facebook Prophet 시작하기\n- Facebook Prophet로 시계열 예측\n- FB Prophet를 사용한 BTC 가격 예측\n\n## 연락처\n\n- 웹사이트\n- GitHub\n- Facebook\n- X/Twitter\n- Pinterest\n- Mastodon\n- Tumblr\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 고지사항\n\n- 다음 고지는 본 글의 정보가 교육 목적으로만 제공되었음을 명확히하며, 재정 또는 투자 자문으로 간주되어서는 안 된다는 것을 명시합니다.\n- 제공된 정보는 귀하 개인의 재정 상황, 목표 또는 리스크 허용도를 고려하지 않습니다.\n- 귀하가 취하는 투자 결정이나 조치는 전적으로 귀하의 책임입니다.\n- 재정 목표, 리스크 허용도 및 투자 기간에 따라 어떠한 투자의 적합성을 독립적으로 평가해야 합니다.\n- 특정 요구 사항에 맞는 맞춤 가이드 제공이 가능한 자격을 갖춘 재무 전문가의 조언을 구하는 것이 권장됩니다.\n- 제공된 도구, 데이터, 콘텐츠, 정보는 맞춤화되지 않았으며 어떤 개인의 투자 요구 사항에 부합하도록 제공된 것이 아니므로 정보 및 교육 목적만을 위해 제공됩니다.\n\n## 자료\n\nhttps://www.kaggle.com/code/alexkaggle95/stock-prices-forecast-plotly-prophet 나쁨\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nhttps://www.kaggle.com/code/ghazanfarali/stock-price-analysis-and-forecasting 페이지를 방문해 보세요! 해당 페이지에는 주식 가격 분석 및 예측과 관련된 정보가 있습니다. 좋은 정보를 얻을 수 있을 거예요!","ogImage":{"url":"/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-BTC-USDPricePredictionusingFBProphetwithHyperparameterOptimizationCross-ValidationQCModifiedAlgo-TradingStrategies_0.png","tag":["Tech"],"readingTime":39}],"page":"8","totalPageCount":35,"totalPageGroupCount":2,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"8"},"buildId":"Suu-uTE6tpVjS7rqQHkw3","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>