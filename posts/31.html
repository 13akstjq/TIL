<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>TIL</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//posts/31" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="TIL" data-gatsby-head="true"/><meta property="og:title" content="TIL" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//posts/31" data-gatsby-head="true"/><meta name="twitter:title" content="TIL" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/7978fe7362f7d4c9.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/7978fe7362f7d4c9.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/873-eb138c3217d71553.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/posts/%5Bpage%5D-de1dc5579188f9be.js" defer=""></script><script src="/TIL/_next/static/X4OrKfmLtU3-3BijwfHe6/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/X4OrKfmLtU3-3BijwfHe6/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="암호화폐를 이용한 파이썬 리스크 포트폴리오 관리 방법" href="/TIL/post/2024-07-12-RiskPortfolioManagementinPythonwithCryptos"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="암호화폐를 이용한 파이썬 리스크 포트폴리오 관리 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-12-RiskPortfolioManagementinPythonwithCryptos_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="암호화폐를 이용한 파이썬 리스크 포트폴리오 관리 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">암호화폐를 이용한 파이썬 리스크 포트폴리오 관리 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 12, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="TimeGPT vs TiDE 제로샷 추론이 예측의 미래인가, 단순한 과대광고인가" href="/TIL/post/2024-07-12-TimeGPTvsTiDEIsZero-ShotInferencetheFutureofForecastingorJustHype"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="TimeGPT vs TiDE 제로샷 추론이 예측의 미래인가, 단순한 과대광고인가" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-12-TimeGPTvsTiDEIsZero-ShotInferencetheFutureofForecastingorJustHype_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="TimeGPT vs TiDE 제로샷 추론이 예측의 미래인가, 단순한 과대광고인가" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">TimeGPT vs TiDE 제로샷 추론이 예측의 미래인가, 단순한 과대광고인가</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 12, 2024</span><span class="PostList_reading_time__6CBMQ">19<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="새로운 R 및 Python IDE, Posit Positron 시작하기 사용법 가이드" href="/TIL/post/2024-07-12-GettingStartedWithPositPositronthenewIDEforRandPython"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="새로운 R 및 Python IDE, Posit Positron 시작하기 사용법 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-12-GettingStartedWithPositPositronthenewIDEforRandPython_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="새로운 R 및 Python IDE, Posit Positron 시작하기 사용법 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">새로운 R 및 Python IDE, Posit Positron 시작하기 사용법 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 12, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="시계열 잔차 분석 숨겨진 가치를 찾아라" href="/TIL/post/2024-07-12-Timeseriesresidualsgoldinthemtharhills"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="시계열 잔차 분석 숨겨진 가치를 찾아라" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-12-Timeseriesresidualsgoldinthemtharhills_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="시계열 잔차 분석 숨겨진 가치를 찾아라" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">시계열 잔차 분석 숨겨진 가치를 찾아라</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 12, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="오늘 배운 사실  왜 속성에 바다코끼리 연산자를 사용할 수 없을까" href="/TIL/post/2024-07-12-TodayILearntWeCantUseTheWalrusOperatorOnAttributes"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="오늘 배운 사실  왜 속성에 바다코끼리 연산자를 사용할 수 없을까" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-12-TodayILearntWeCantUseTheWalrusOperatorOnAttributes_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="오늘 배운 사실  왜 속성에 바다코끼리 연산자를 사용할 수 없을까" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">오늘 배운 사실  왜 속성에 바다코끼리 연산자를 사용할 수 없을까</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 12, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Yang-Zhang 방법으로 정확한 변동성 추정하기" href="/TIL/post/2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Yang-Zhang 방법으로 정확한 변동성 추정하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Yang-Zhang 방법으로 정확한 변동성 추정하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Yang-Zhang 방법으로 정확한 변동성 추정하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 12, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="파이썬으로 GenAI 사용하기 LLM과 에이전트 비교" href="/TIL/post/2024-07-12-GenAIwithPythonLLMvsAgents"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="파이썬으로 GenAI 사용하기 LLM과 에이전트 비교" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-12-GenAIwithPythonLLMvsAgents_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="파이썬으로 GenAI 사용하기 LLM과 에이전트 비교" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">파이썬으로 GenAI 사용하기 LLM과 에이전트 비교</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 12, 2024</span><span class="PostList_reading_time__6CBMQ">18<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="RAG에서 성능 및 효율성을 달성하는 방법" href="/TIL/post/2024-07-12-HowAchievingPerformanceandEfficiencyinRAG"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="RAG에서 성능 및 효율성을 달성하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-12-HowAchievingPerformanceandEfficiencyinRAG_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="RAG에서 성능 및 효율성을 달성하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">RAG에서 성능 및 효율성을 달성하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 12, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="로컬 LLMs 실행이 생각보다 더 유용하고 쉬운 이유" href="/TIL/post/2024-07-12-RunningLocalLLMsisMoreUsefulandEasierThanYouThink"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="로컬 LLMs 실행이 생각보다 더 유용하고 쉬운 이유" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-12-RunningLocalLLMsisMoreUsefulandEasierThanYouThink_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="로컬 LLMs 실행이 생각보다 더 유용하고 쉬운 이유" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">로컬 LLMs 실행이 생각보다 더 유용하고 쉬운 이유</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 12, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="코드 변경을 안전하게 하는 커스텀 pre-commit 훅 사용하는 방법" href="/TIL/post/2024-07-09-Custompre-commithooksforsafercodechanges"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="코드 변경을 안전하게 하는 커스텀 pre-commit 훅 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-09-Custompre-commithooksforsafercodechanges_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="코드 변경을 안전하게 하는 커스텀 pre-commit 훅 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">코드 변경을 안전하게 하는 커스텀 pre-commit 훅 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 9, 2024</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/TIL/posts/21">21</a><a class="link" href="/TIL/posts/22">22</a><a class="link" href="/TIL/posts/23">23</a><a class="link" href="/TIL/posts/24">24</a><a class="link" href="/TIL/posts/25">25</a><a class="link" href="/TIL/posts/26">26</a><a class="link" href="/TIL/posts/27">27</a><a class="link" href="/TIL/posts/28">28</a><a class="link" href="/TIL/posts/29">29</a><a class="link" href="/TIL/posts/30">30</a><a class="link" href="/TIL/posts/31">31</a><a class="link" href="/TIL/posts/32">32</a><a class="link" href="/TIL/posts/33">33</a><a class="link" href="/TIL/posts/34">34</a><a class="link" href="/TIL/posts/35">35</a><a class="link" href="/TIL/posts/36">36</a><a class="link" href="/TIL/posts/37">37</a><a class="link" href="/TIL/posts/38">38</a><a class="link" href="/TIL/posts/39">39</a><a class="link" href="/TIL/posts/40">40</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"암호화폐를 이용한 파이썬 리스크 포트폴리오 관리 방법","description":"","date":"2024-07-12 19:42","slug":"2024-07-12-RiskPortfolioManagementinPythonwithCryptos","content":"\n\n디지털 자산이 전례 없는 중요성을 얻는 시대에는 강력하고 효과적인 포트폴리오 관리 전략이 이전보다 중요합니다. 이 기사는 역사적 시장 데이터를 활용하고 첨단 금융 알고리즘을 적용하여 암호화폐 포트폴리오를 최적화하는 Python 스크립트에 대해 심층적으로 다룹니다. 강력한 ccxt 라이브러리를 통합하여 늘어난 암호화폐 거래소에서 역사적 가격 데이터를 가져옵니다. 이를 통해 심층적인 분석과 전략 실행이 가능해집니다. 스크립트의 기능은 이동 평균 교차 전략을 활용하여 최적의 거래 신호를 식별하는 데 도움이 됩니다. 더불어, 위험과 수익을 효율적으로 균형잡는 볼록 최적화 기법을 사용한 포트폴리오 최적화 모듈을 포함하고 있습니다. 이 포괄적인 가이드는 시장 데이터를 획득하고 처리하는 기술적 세부 사항을 보여주는데 그치지 않고, 전략 수립부터 포트폴리오 시각화에 이르기까지의 실용적인 응용에 대한 통찰력을 제공하여 트레이더와 투자자가 암호화폐의 다이내믹한 세계에서 정보에 기반한 결정을 내릴 수 있도록 돕습니다.\n\n# 포트폴리오 리스크 관리 사용의 장점\n\n- 위험 완화: 포트폴리오 리스크 관리는 위험을 식별, 평가 및 완화하여 포트폴리오가 중요한 손실에 대해 보호받도록 돕습니다.\n- 정보기반 결정: 역사적 데이터와 시장 동향을 분석함으로써 투자자는 자산 할당을 최적화하여 보다 정보에 기반한 결정을 내릴 수 있습니다.\n- 수익 향상: 효과적인 리스크 관리를 통해 투자자는 수익을 극대화하고 동시에 위험을 최소화하는 포트폴리오를 달성할 수 있습니다.\n- 다양성: 다양성을 홍보하여 어떤 단일 자산의 불리한 움직임에 대한 영향을 줄입니다.\n- 일관성: 일관된 투자 전략을 유지하여 시장 변동성에 기반한 충동적인 결정을 피합니다.\n- 준수: 규제 요구 사항과 지침을 준수하는 데 도움을 줌으로써 법적과 윤리적 기준을 준수합니다.\n\n# 포트폴리오 리스크 관리 사용의 단점\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 복잡성: 포트폴리오 위험 관리 전략을 구현하는 것은 복잡할 수 있으며, 재무 시장과 금융 상품에 대한 심층적인 이해가 필요합니다.\n- 비용: 위험 관리 도구와 소프트웨어에는 연관된 비용이 있으며, 모든 투자자가 감당할 수 없을 수도 있습니다.\n- 시간 소모: 지속적인 모니터링과 분석이 필요하기 때문에 시간이 많이 소요되며 자원이 많이 소모될 수 있습니다.\n- 과도한 조심: 위험 관리에 과도하게 초점을 맞출 경우, 과도한 보수적인 전략으로 이어질 수 있어 수익을 제한할 수 있습니다.\n- 역사적 데이터에 의존: 위험 관리는 종종 역사적 데이터에 의존하는데, 이는 미래 시장 상황을 정확하게 예측하지 못할 수 있습니다.\n\n# 포트폴리오 위험 관리의 장점\n\n- 안정성 향상: 위험을 효과적으로 관리함으로써 포트폴리오는 더 큰 안정성을 달성할 수 있어 극단적인 손실 가능성을 줄일 수 있습니다.\n- 자본 할당 개선: 더 나은 자본 할당이 가능하며, 자원이 가장 유망한 자산에 투자되도록 보장합니다.\n- 투자자 신뢰 증대: 투자자들이 위험 감소에 초점을 두고 투자를 관리하고 있다는 사실에 대한 신뢰감을 높여줍니다.\n- 전략적 유연성: 전략적 유연성을 제공하여 시장 변화에 따라 전략을 조정할 수 있도록 허용합니다.\n- 성과 모니터링 향상: 지속적인 성과 모니터링을 가능하게 하여 투자자가 필요에 따라 전략을 추적하고 조정할 수 있도록 도와줍니다.\n\n# 포트폴리오 위험 관리의 단점\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 자원 소모가 많음: 효율적으로 구현하고 유지하기 위해서는 상당한 시간, 자금 및 전문지식이 필요합니다.\n- 과도한 최적화 가능성: 리스크를 최소화하는 데 초점을 맞추다 보면 높은 수익 기회가 놓칠 수 있는 과도한 최적화의 위험이 있습니다.\n- 데이터 의존성: 정확하고 최신 데이터에 대한 높은 의존성으로 인해 획득과 유지가 어려울 수 있습니다.\n- 시장의 예측 불가능성: 견고한 리스크 관리 실천에도 불구하고 시장은 예측할 수 없으며 예기치 못한 사건이 포트폴리오에 여전히 영향을 줄 수 있습니다.\n- 소규모 투자자에 대한 적용 범위가 제한적: 복잡성과 비용 제한으로 인해 고급 리스크 관리의 혜택이 소규모 투자자에게 덜 접근하기 어려울 수 있습니다.\n\n![이미지](/TIL/assets/img/2024-07-12-RiskPortfolioManagementinPythonwithCryptos_0.png)\n\n```js\n바이낸스에서의 역사적 데이터 획득 중...\n\n최적화 결과:\nBTC/USDT: 1.0\nETH/USDT: -5.538816095795286e-23\n\n예상 포트폴리오 수익률: 0.0017\n최소 포트폴리오 분산: 0.0195\n```\n\n![이미지](/TIL/assets/img/2024-07-12-RiskPortfolioManagementinPythonwithCryptos_1.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n# 필요한 라이브러리 가져오기\nimport ccxt\nimport pandas as pd\nimport numpy as np\nimport cvxpy as cp\nimport matplotlib.pyplot as plt\nfrom datetime import datetime\n\n# ccxt에서 기록 데이터 가져오는 함수\ndef get_ccxt_data(exchange_name, symbols, timeframe, since):\n    exchange = getattr(ccxt, exchange_name)()\n    data = {}\n\n    for symbol in symbols:\n        ohlcv = exchange.fetch_ohlcv(symbol, timeframe, since=since)\n        \n        if ohlcv:\n            df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])\n            df['time'] = pd.to_datetime(df['timestamp'], unit='ms')\n            df.set_index('time', inplace=True)\n            df.drop(['timestamp', 'open', 'high', 'low', 'volume'], axis=1, inplace=True)\n            \n            # 일일 수익률 계산\n            df['return'] = df['close'].pct_change().fillna(0)\n            \n            # 데이터 사전에 저장\n            data[symbol] = df\n    \n    return data\n\n# 이동평균 교차 전략 적용하는 함수\ndef apply_sma_strategy(data, short_window=12, long_window=26):\n    for symbol, df in data.items():\n        df['SMA_50'] = df['close'].rolling(window=short_window).mean()\n        df['SMA_200'] = df['close'].rolling(window=long_window).mean()\n        df['signal'] = 0\n        df.loc[df.index[short_window:], 'signal'] = np.where(\n            df.loc[df.index[short_window:], 'SMA_50'] \u003e df.loc[df.index[short_window:], 'SMA_200'], 1, 0\n        )\n        df['position'] = df['signal'].shift(1).fillna(0)\n    return data\n\n# 전략에 따라 수익 조정하는 함수\ndef adjust_returns(data):\n    for symbol, df in data.items():\n        df['adjusted_return'] = df['return'] * df['position']\n    return data\n\n# 포트폴리오 최적화하는 함수\ndef optimize_portfolio(data):\n    symbols = list(data.keys())\n    n_assets = len(symbols)\n    \n    # 모든 자산 중 가장 작은 데이터 길이 찾기\n    min_length = min(len(data[symbol]) for symbol in symbols)\n    \n    # 수익 조정하고 정규화하기\n    returns = np.zeros((min_length, n_assets))\n    for i, symbol in enumerate(symbols):\n        # 데이터 길이 조정\n        df = data[symbol].iloc[:min_length]\n        returns[:, i] = df['adjusted_return'].values\n    \n    # 공분산 행렬과 기대수익률 계산\n    cov_matrix = np.cov(returns, rowvar=False)\n    expected_returns = np.mean(returns, axis=0)\n    \n    # 최적화 변수\n    weights = cp.Variable(n_assets)\n    risk = cp.quad_form(weights, cov_matrix)\n    objective = cp.Maximize(expected_returns @ weights - 0.5 * risk)\n    \n    # 제약 조건\n    constraints = [cp.sum(weights) == 1, weights \u003e= 0]\n    \n    # 최적화 문제 해결\n    prob = cp.Problem(objective, constraints)\n    prob.solve()\n    \n    # 최적화 결과 표시\n    print(\"\\n최적화 결과:\")\n    for i, symbol in enumerate(symbols):\n        print(f\"{symbol}: {weights.value[i]}\")\n    \n    # 포트폴리오의 최소 분산과 기대수익률 계산\n    min_variance = cp.sqrt(cp.quad_form(weights.value, cov_matrix)).value\n    expected_return_portfolio = expected_returns @ weights.value\n    \n    print(f\"\\n예상 포트폴리오 수익률: {expected_return_portfolio:.4f}\")\n    print(f\"최소 포트폴리오 분산: {min_variance:.4f}\")\n    \n    return symbols, weights.value\n\n# 결과 시각화하는 함수\ndef visualize_results(symbols, weights):\n    # 포트폴리오의 각 자산 가중치 그래프로 표시\n    plt.figure(figsize=(10, 6))\n    plt.bar(symbols, weights, color='blue')\n    plt.xlabel('자산')\n    plt.ylabel('가중치')\n    plt.title('최적화된 포트폴리오 내 자산 가중치')\n    plt.show()\n\n# 메인 스크립트 실행\nif __name__ == \"__main__\":\n    # 매개변수 정의\n    exchange_name = 'binance'  # 거래소 이름\n    symbols = [\"BTC/USDT\", \"ETH/USDT\"]  # 자산 심볼\n    timeframe = '1d'  # 시간프레임 (1일)\n    since = ccxt.binance().parse8601('2023-01-01T00:00:00Z')  # 시작 날짜\n    \n    # ccxt에서 기록 데이터 가져오기\n    print(f\"{exchange_name}에서 기록 데이터 가져오는 중...\")\n    data = get_ccxt_data(exchange_name, symbols, timeframe, since)\n    \n    if data:\n        # 이동평균 교차 전략 적용\n        data = apply_sma_strategy(data)\n        \n        # 전략에 따라 수익 조정\n        data = adjust_returns(data)\n        \n        # 포트폴리오 최적화\n        symbols, weights = optimize_portfolio(data)\n        \n        # 결과 시각화\n        visualize_results(symbols, weights)\n","ogImage":{"url":"/TIL/assets/img/2024-07-12-RiskPortfolioManagementinPythonwithCryptos_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-RiskPortfolioManagementinPythonwithCryptos_0.png","tag":["Tech"],"readingTime":8},{"title":"TimeGPT vs TiDE 제로샷 추론이 예측의 미래인가, 단순한 과대광고인가","description":"","date":"2024-07-12 19:39","slug":"2024-07-12-TimeGPTvsTiDEIsZero-ShotInferencetheFutureofForecastingorJustHype","content":"\n\n이 게시물은 Rafael Guedes와 공저한 것입니다.\n\n# 소개\n\n예측은 학술 연구 및 산업 응용 분야에서 인공지능(AI)의 핵심 영역 중 하나입니다. 실제로, 이는 모든 산업에 걸쳐 찾아볼 수 있는 가장 보편적인 도전 중 하나일 것입니다. 미래 매출량 및 시장 동향을 정확하게 예측하는 것은 기업이 계획 프로세스를 최적화하기 위해 꼭 필요합니다. 이는 이윤 기여를 향상시키고 낭비를 최소화하며 충분한 재고 수준을 보장하고 공급망 최적화 및 전체 의사 결정을 개선하는 것을 포함합니다.\n\n예측 모델을 개발하는 것은 복잡하고 다면적인 도전입니다. 이는 최첨단(STATE-OF-THE-ART, SOTA) 예측 방법론과 적용 대상인 특정 비즈니스 분야에 대한 깊은 이해를 요구합니다. 또한, 예측 엔진은 기관 내에서 폭넓은 프로세스를 지원하는 중요한 인프라 역할을 할 것입니다. 예를 들어:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 마케팅 팀은 모델을 활용하여 다가오는 기간에 대한 투자 할당에 관한 전략적 의사 결정을 진행합니다. 예를 들어, 다음 달이나 분기에 대한 투자 배정에 대한 결정을 내립니다.\n- 구매 팀은 공급 업체로부터의 매입 수량과 타이밍에 관한 정보에 기초하여 재고 수준을 최적화하고 낭비나 부족을 줄이기 위해 모델을 활용합니다.\n- 운영 팀은 예측을 활용하여 생산 라인을 최적화합니다. 예상 수요를 충족시키기 위해 자원과 인력을 효율적으로 투입하면서 운영 비용을 최소화합니다.\n- 재무 팀은 예산 및 리소스 할당을 위해 모델을 신뢰합니다. 예측 데이터를 활용하여 월별 금융 요구 사항을 예측하고 그에 맞게 자원을 할당합니다.\n- 고객 서비스 팀은 예측을 활용하여 고객 조회량을 예상하며, 고품질의 고객 서비스를 유지하고 대기 시간을 최소화하면서 적정 직원 수를 조정할 수 있습니다.\n\n최근 예측 분야의 발전은 텍스트 (예: ChatGPT), 텍스트-이미지 (예: Midjourney) 및 텍스트-음성 (예: Eleven Labs) 등 여러 도메인에서 기초 모델의 성공적인 개발에 의해 형성되었습니다. 이러한 모델들의 널리 퍼짐으로 인해 이전에 본적이 없던 데이터에 대한 예측을 생성하도록 설계된 TimeGPT [1]와 같은 모델들이 등장했습니다. 이러한 모델들은 텍스트, 이미지 및 음성 분야의 선례를 따르는 방법론과 아키텍처를 활용합니다. 일반적인 사전 훈련된 모델은 예측 작업에 대해 패러다임 변화를 가져올 것입니다. 조직에게 더 접근 가능하게 만들어줄 뿐만 아니라, 계산 복잡성을 줄이고 전반적으로 더 정확하게 만들 것입니다.\n\n이 글에서는 TimeGPT의 가능한 아키텍처에 대해 깊이 있는 설명을 제공합니다. 또한 모델이 제로샷 추론을 수행할 수 있도록 하는 주요 구성 요소를 다룹니다. 이론적 개요를 따라 특정 사용 사례와 데이터셋에 TimeGPT를 적용합니다. 구체적인 구현 세부사항을 다루고 모델 성능을 철저히 분석합니다. 마지막으로 TimeGPT와 TiDE [2]의 성능을 비교하여, 간단한 MLP인 TiDE가 예측 사용 사례에서 Transformer를 이기는 것을 보여줍니다.\n\n![](/TIL/assets/img/2024-07-12-TimeGPTvsTiDEIsZero-ShotInferencetheFutureofForecastingorJustHype_0.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n항상 코드는 저희의 GitHub에서 확인하실 수 있어요.\n\n# TimeGPT\n\nTimeGPT [1]는 시계열 예측을 위한 최초의 기초 모델로, 다양한 도메인을 범위로 일반화할 수 있는 능력으로 특징화되어 있어요. 훈련 단계에서 사용된 데이터 이외의 데이터셋에서도 정확한 예측을 할 수 있어요. 시계열 예측을 위한 기초 모델에 대한 연구 분야는 최근에 크게 성장하고 있어요. 카네기 멜론 대학교(CMU)의 연구자들이 개발한 \"MOMENT\"[3], Google의 \"TimesFM\"[4], Morgan Stanley와 ServiceNow의 공동 연구인 \"Lag-Llama\"[5], 그리고 Salesforce의 \"Moirai\"[6]와 같은 주목할 만한 최근 작업이 있어요. 앞으로 다른 시계열 예측을 위한 기초 모델들에 대해서도 다룰 계획이에요.\n\nTimeGPT는 제로샷 추론 설정에서 우수한 성능을 발휘하기 위해 전이 학습을 활용하고 있어요. 경제, 인구 통계, 의료, 날씨, IoT 센서 데이터, 에너지, 웹 트래픽, 판매, 운송 및 은행 업무 등 다양한 도메인의 대중적으로 제공되는 데이터셋에서 1000억 개의 데이터 포인트를 사용해 훈련되었어요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다양한 도메인의 폭넓은 다양성 덕분에 이 모델은 여러 계절성, 다양한 길이의 주기, 그리고 변화하는 추세와 같은 복잡한 패턴을 잡을 수 있어요. 게다가 데이터셋은 다양한 노이즈 수준, 이상값, 드리프트, 그리고 기타 다양한 특징을 보여줘요. 일부는 규칙적인 패턴이 있는 깨끗한 데이터로 이루어져 있고, 다른 일부는 시간이 흐름에 따라 추세와 패턴이 변동될 수 있는 예상치 못한 사건과 행동을 포함하고 있어요. 이러한 도전들은 모델이 배울 수 있는 많은 시나리오를 제공하여 모델의 견고성과 일반화 능력을 향상시켜요.\n\n![이미지](/TIL/assets/img/2024-07-12-TimeGPTvsTiDEIsZero-ShotInferencetheFutureofForecastingorJustHype_1.png)\n\n## 아키텍처\n\nTimeGPT는 시계열 예측을 위해 특별히 설계된 Transformer 기반 모델로, 인코더-디코더 아키텍처 내부에 self-attention 메커니즘을 통합하고 있어요. self-attention 메커니즘을 활용하여 시계열 내에서 서로 다른 지점의 중요성을 동적으로 가중할 수 있어요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n모델은 입력으로 과거 값(y)과 외생 공변럇(x)의 창을 받습니다. 공변럇에는 추가 시계열 데이터 및/또는 특정 이벤트를 나타내는 이진 변수가 포함될 수 있습니다. 이러한 입력은 지역 위치 임베딩을 통해 순차 정보로 보강됩니다. 이를 통해 모델은 시간 의존성을 인식할 수 있습니다. 저자들이 명시적으로 언급하지는 않았지만, 모든 입력이 위치 인코딩 후 연결된다고 가정하며, 이는 인코더에 공급되는 최종 입력을 생성합니다.\n\n![image](/TIL/assets/img/2024-07-12-TimeGPTvsTiDEIsZero-ShotInferencetheFutureofForecastingorJustHype_2.png)\n\n위치 인코딩은 또한 저자들에 의해 정의되지 않았습니다. 우리는 이들이 기초 변환자 아키텍처 논문의 삼각 함수를 사용한다고 가정합니다. 이러한 함수는 다양한 주파수로 특징 지어지지만 입력 데이터와 동일한 차원을 유지합니다.\n\n![image](/TIL/assets/img/2024-07-12-TimeGPTvsTiDEIsZero-ShotInferencetheFutureofForecastingorJustHype_3.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위치 인코딩과 함께 보강된 입력 벡터는 인코더에 소개됩니다. 인코더 내에서 다중 헤드 어텐션 레이어는 입력 시퀀스 내의 다양한 요소에 가중치를 평가하고 할당하여 그들의 상대적 중요성을 반영합니다. 이 representatino은 이후 완전 연결된 피드 포워드 네트워크에 의해 처리됩니다. 이것은 시퀀스 내 요소들 간의 더 복잡한 관계를 포착하는 representatino을 생성하는 것을 가능하게 합니다. 그런 다음 출력은 아키텍처의 디코더 부분으로 전달됩니다.\n\n![이미지](/TIL/assets/img/2024-07-12-TimeGPTvsTiDEIsZero-ShotInferencetheFutureofForecastingorJustHype_4.png)\n\n인코더의 출력을 처리하는 것 외에도 디코더는 자기 회귀적인 프로세스에서 작동합니다. 이전에 생성된 출력을 통합하여 다음 시간 단계(i+1)의 예측을 생성하기 전에 작동합니다. 이것은 인코더에 의해 생성된 숨겨진 상태들과 이전에 생성된 출력 간의 복잡한 관계를 포착하기 위해 주의 메커니즘을 활용합니다. 이 접근 방식은 디코더가 인코더의 representatino에 포착된 문맥적 및 순차적 정보를 자체 반복적인 예측과 함께 효과적으로 종합할 수 있도록 합니다.\n\n![이미지](/TIL/assets/img/2024-07-12-TimeGPTvsTiDEIsZero-ShotInferencetheFutureofForecastingorJustHype_5.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마지막으로, 선형 레이어는 디코더의 출력을 예측 지향의 길이와 동일한 값 벡터로 매핑하는 역할을 합니다.\n\n![이미지](/TIL/assets/img/2024-07-12-TimeGPTvsTiDEIsZero-ShotInferencetheFutureofForecastingorJustHype_6.png)\n\nTimeGPT는 잠재적 결과물의 확률 분포를 생성할 수 있습니다. 다시 말해, 예측 간격의 추정입니다. 저자들은 기존 오류를 기반으로 하는 조화 예측을 사용하여 예측 간격을 추정했습니다. 전통적인 방법과 달리, 조화 예측은 분포 가정이 필요하지 않으며 다음과 같은 방법으로 수행할 수 있습니다:\n\n- M개의 교육 및 보정 세트 생성;\n- 각 보정 세트를 모델로 예측;\n- 각 예측 시점 h에 대해 모델의 예측 값과 보정 세트 내 실제 결과 간의 절대 잔차 값이 계산됩니다. 이러한 계산된 잔차는 비준수 점수라고 불립니다.\n- 각 예측 시점 h의 비준수 점수의 분포에서 특정 백분위수를 선택합니다. 선택한 백분위수는 예측 간격의 커버리지 수준을 결정하며, 더 높은 백분위수는 더 넓은 간격을 의미합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예측 간격은 예측 값 ± 최종 비준수 점수로 제공됩니다.\n\n![이미지](/TIL/assets/img/2024-07-12-TimeGPTvsTiDEIsZero-ShotInferencetheFutureofForecastingorJustHype_7.png) \n\n# TimeGPT 대 TiDE: 실제 사용 사례에서의 비교\n\n이 섹션에서는 고객 중 한 명의 실제 데이터셋을 사용하여 시간 GPT를 사용하여 매출을 예측하겠습니다. 이후 동일한 분석을 위해 TiDE와 TimeGPT의 예측 성능을 비교합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nTiDE [2]은 새로운 다변량 시계열 모델로, 정적 공변럇수(예: 제품 브랜드) 및 예측 기간 동안(예: 제품 가격) 알려진 또는 알려지지 않은 동적 공변럇수를 사용하여 정확한 예측을 생성할 수 있습니다. 복잡한 Transformer 아키텍처와는 달리, TiDE는 간단한 인코더-디코더 아키텍처와 잔차 연결을 기반으로 합니다:\n\n- 인코더는 과거 타겟 값 및 시계열의 공변럇수를 특성의 밀집 표현으로 매핑하는 역할을 합니다. 먼저 특성 프로젝션을 통해 동적 공변럇수의 차원을 줄입니다. 그런 다음, 밀집 인코더는 특성 프로젝션의 출력과 정적 공변럇수 및 과거 값이 연결된 것을 받아 하나의 임베딩 표현으로 매핑합니다.\n- 디코더는 임베딩 표현을 받아 미래 예측으로 변환합니다. 밀집 디코더는 임베딩 표현을 시간당 하나의 벡터로 매핑합니다. 그 후, 시계열 디코더는 밀집 디코더의 출력을 해당 시간 단계의 특성 프로젝션과 결합하여 예측을 생성합니다.\n- 마지막으로, 잔차 연결은 과거 값을 예측 기간 크기의 벡터로 선형 매핑하여 이를 시간적 디코더의 출력에 추가하여 최종 예측을 생성합니다.\n\n![이미지](/TIL/assets/img/2024-07-12-TimeGPTvsTiDEIsZero-ShotInferencetheFutureofForecastingorJustHype_8.png)\n\n데이터셋에는 미국 시장을 위한 주간 매출 데이터를 상세히 설명하는 195가지 고유한 시계열이 포함되어 있습니다. 역사적인 매출 데이터 외에도, 데이터셋에는 미국 법정 공휴일 및 이진 계절 특성 정보도 있습니다. 우리는 이 데이터셋을 보강하기 위해 이벤트 주(week)와 달(month) 식별자를 사용했습니다. 예측 기간은 16주로, 즉 미래 16주를 예측하고자 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n친구야, 아래와 같이 라이브러리를 가져오는 것으로 시작해요:\n\n```js\nimport matplotlib.pyplot as plt\nimport os\nimport pandas as pd\nimport utils\n\nfrom nixtlats import TimeGPT\nfrom nixtlats.date_features import CountryHolidays\nfrom dotenv import load_dotenv\nfrom sklearn.preprocessing import MinMaxScaler, OrdinalEncoder\n\nload_dotenv()\n```\n\n다음으로, TimeGPT 클래스를 초기화해요. TimeGPT 토큰을 제공하여 시작해요. Nixtla 웹사이트에서 요청하실 수 있어요.\n\n```js\ntimegpt = TimeGPT(token=os.environ.get(\"TIMEGPT_KEY\"))\ntimegpt.validate_token()\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n데이터셋을 로드하기 전에 인증 토큰을 확인한 후 다음을 확인해 주세요:\n\n- 대상 변수는 숫자이어야 하며 결측값이 없어야 합니다.\n- 시작일부터 종료일까지의 날짜 순서에 빈 공간이 없는지 확인하세요.\n- 날짜 열은 Pandas에서 인식할 수 있는 형식이어야 합니다.\n- 문서에 따르면 데이터 정규화는 내부에서 처리되므로 해당 단계를 건너뛰어도 됩니다.\n- 여러 시계열을 예측하는 경우 각 시리즈를 고유하게 식별할 수 있는 열을 포함해야 하며, 이는 예측 함수에서 인수로 사용됩니다.\n- 외생적 특성이 필요한 경우 예측 기간을 위한 별도의 데이터셋이 필요합니다.\n\n```python\n# 데이터 프레임 읽고 날짜를 datetime으로 파싱\ndf = pd.read_csv('data/data.csv', parse_dates=['delivery_week'])\n```\n\n토론한 바와 같이 데이터셋을 보강하기 위해 주간과 월간의 이진 계절성 특성을 추가합니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# df에 주차(week)와 달(month)을 추가합니다.\ndf['week'] = df['delivery_week'].dt.isocalendar().week\ndf['month'] = df['delivery_week'].dt.month\n\n# 주차(week)와 달(month)을 원핫인코딩합니다.\ndf = pd.get_dummies(df, columns=['week', 'month'], dtype=int)\n```\n\n이제 TimeGPT가 예측에 사용할 데이터셋을 만들 준비가 되었습니다. 추가로, 예측 기간 내의 실제 매출 데이터와 해당 기간에 대한 외생 변수 특성을 포함하는 홀드아웃(holdout) 세트를 만들 것입니다.\n\n```js\n# 데이터 프레임을 자릅니다.\nforecast_df = df[df['delivery_week'] \u003c \"2023-10-16\"]\n\n# 홀드아웃(holdout) 세트를 위해 실제 매출 데이터 중 마지막 x 주를 사용합니다.\nholdout_df = df[(df['delivery_week'] \u003e= \"2023-10-16\") \u0026 (df['delivery_week'] \u003c= \"2024-02-05\")]\n```\n\n데이터를 분리한 후, 훈련 및 홀드아웃 데이터셋을 forecast() 함수로 넘겨 예측할 수 있습니다. 다음 매개변수를 설정해야합니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- df - 과거 데이터가 포함된 데이터 프레임입니다.\n- time_col - 시간 정보가 들어 있는 열입니다.\n- target_col - 과거 데이터가 들어 있는 열입니다.\n- X_df - 예측 기간을 위한 외생특징이 포함된 데이터 프레임입니다.\n- date_features - 미국의 공휴일과 같은 새로운 외생 특징의 지정을 허용합니다.\n- h - 예측 기간을 정의합니다.\n- level - 예측 간격 (80% 신뢰 구간)입니다.\n- freq - 데이터의 주기입니다. 우리의 경우 매주 월요일마다 발생합니다.\n- id_col - 다변량 시나리오에서 각 시계열을 식별하는 열입니다.\n- model - TimeGPT에는 단기용과 장기용으로 두 가지 모델이 있습니다. 예측 기간에 계절 주기가 하나 이상인 경우 장기용을 사용해야 합니다.\n- add_history - 과거 데이터의 적합 값이 반환됩니다.\n\n```js\n# 계절적 외부 요인이 포함된 목록 생성\nEXOGENOUS_FAETURES = [x for x in df.columns if ('week_' in x) | ('month_' in x)]\n\ntimegpt_fcst_ex_vars_df = timegpt.forecast(\n    df=forecast_df[['unique_id', 'delivery_week', 'target', 'marketing_events_1', 'marketing_events_2']+EXOGENOUS_FAETURES],\n    time_col='delivery_week',\n    target_col='target',\n    X_df=holdout_df[['unique_id', 'delivery_week', 'marketing_events_1', 'marketing_events_2']+EXOGENOUS_FAETURES],\n    date_features=[CountryHolidays(['US'])],\n    h=17,\n    level=[80],\n    freq='W-MON',\n    id_col='unique_id',\n    model='timegpt-1',\n    add_history=True,\n    )\n```\n\n예측은 몇 분 안에 실행됩니다. 그런 다음, 과거 데이터에 대한 적합 값과 예측 값을 포함하는 데이터 프레임이 반환됩니다. 또한 예측에서 외생 교란 변수의 중요성도 반환됩니다.\n\n```js\ntimegpt.weights_x.head(10).sort_values(by='weights').plot.barh(x='features', y='weights')\nplt.title('특징 중요도 - 상위 10개')\nplt.show()\n```  \n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리는 경우에 가장 중요한 10가지 공변럇값을 추출했는데, 그 중에서 마케팅 이벤트가 가장 중요함을 나타냅니다. 반대로, 계절별 및 휴일 공변랇값은 잔여적인 중요성을 가지고 있습니다.\n\n![이미지](/TIL/assets/img/2024-07-12-TimeGPTvsTiDEIsZero-ShotInferencetheFutureofForecastingorJustHype_9.png)\n\nadd_history=True로 설정했기 때문에 적합값과 예측을 플롯할 수 있습니다. 홀드아웃 세트에서 볼륨이 가장 높은 6개의 시리즈를 선택했습니다. 이들은 비즈니스에 더 관련이 있고 더 안정적인 패턴으로 예측하기가 더 쉬울 것입니다.\n\n```js\n# 볼륨에 따라 정렬된 시리즈 가져오기 \nseries = holdout_df.groupby('unique_id')['target'].sum().reset_index().sort_values(by='target', ascending=False)['unique_id'].tolist()\n\ntimegpt.plot(\n    forecast_df[['unique_id', 'delivery_week', 'target']], \n    timegpt_fcst_ex_vars_df,\n    time_col='delivery_week',\n    target_col='target',\n    unique_ids=series[:6],\n    level=[80], \n)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![Figure 10](/TIL/assets/img/2024-07-12-TimeGPTvsTiDEIsZero-ShotInferencetheFutureofForecastingorJustHype_10.png)\n\nFigure 10을 보면 적합 값이 실제 값과 잘 일치하지만 예측은 일관성이 없습니다. 하나의 경우를 제외하고 대부분의 시계열에서 균일한 패턴을 보여줍니다 (우측 상단에서 확인할 수 있습니다). 또한, 모든 예측에는 우리가 기대하지 않았던 연이은 예상치 이상의 증가가 있습니다.\n\nTimeGPT에서 예측을 얻은 후 TiDE에서 생성된 예측을 로드하고 비교를 위해 예측 성능 지표를 계산할 수 있습니다. 비교 메트릭으로 실제 판매량을 유지하기 위해 평균 절대 백분율 오차(MAPE)를 사용했습니다.\n\n```javascript\n# TiDE와 TimeGPT에서 예측 로드\ntide_model_df = pd.read_csv('data/tide.csv', parse_dates=['delivery_week'])\ntimegpt_fcst_ex_vars_df = pd.read_csv('data/timegpt.csv', parse_dates=['delivery_week'])\n\n# TiDE 예측 및 실제 값을 병합하는 데이터 프레임\nmodel_eval_df = pd.merge(holdout_df[['unique_id', 'delivery_week', 'target']], tide_model_df[['unique_id', 'delivery_week', 'forecast']], on=['unique_id', 'delivery_week'], how='inner')\n\n# TimeGPT 예측 및 실제 값을 병합하는 데이터 프레임\nmodel_eval_df = pd.merge(model_eval_df, timegpt_fcst_ex_vars_df[['unique_id', 'delivery_week', 'TimeGPT']], on=['unique_id', 'delivery_week'], how='inner')\n\nutils.plot_model_comparison(model_eval_df)\n```  \n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음은 Figure 11에 표시된 것과 같습니다. TiDE는 16주 중 15주에 대해 195개의 시계열을 비교할 때 TimeGPT에 비해 평균 MAPE가 낮습니다. 두 모델 모두 동일한 정보에 액세스할 수 있지만, TimeGPT의 제로-숏 추론은 저희가 세밀하게 조정한 모델을 이기지 못했습니다.\n\n# 결론\n\n오늘날의 경쟁적인 환경에서 예측의 중요성은 과대평가될 수 없습니다. 효과적인 예측 방법은 운영 우수성을 추구하는 조직에게 중요하며, 이를 통해 운영을 더 효율적으로 계획하고 관리할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 기사에서는 시계열 예측의 최신 혁신 중 하나 인 foundation models의 발전을 탐구했습니다. 이러한 모델은 전문 지식이 부족한 기관들이 내부에서 SOTA 모델을 개발하는 데 필요한 특수 지식을 갖추지 못한 경우에도 정교한 알고리즘에 대한 접근을 민주화하기 위해 노력하고 있습니다. 이러한 노력은 유망해 보이지만, 우리의 분석에서는 여전히 정확한 예측을 제공하는 데 실패하는 것으로 나타났습니다. 구체적으로, TiDE가 zero-shot 추론 시나리오에서 TimeGPT를 크게 능가했습니다.\n\n그럼에도 불구하고, AI 기업들이 예측의 경계를 넓히기 위해 노력하는 것을 보는 것은 격려되는 일입니다. 컴퓨터 비전 및 NLP와 같은 다른 도메인이 더 많은 관심을 받고 있지만, 기관들에게 있어서 예측의 중요성을 간과해서는 안 됩니다.\n\n# 나에 대해\n\nAI 분야의 시리얼 창업가이자 리더. 기업을 위한 AI 제품을 개발하고 AI 중심 스타트업에 투자합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n창업자 @ ZAAI | LinkedIn | X/Twitter\n\n# 참고 자료\n\n[1] Garza, A., \u0026 Mergenthaler-Canseco, M. (2023). TimeGPT-1. arXiv:2310.03589에서 검색됨.\n\n[2] Abhimanyu Das, Weihao Kong, Andrew Leach, Shaan Mathur, Rajat Sen, Rose Yu. (2023) TiDE를 활용한 장기 예측: Time-series Dense Encoder. arXiv:2304.08424.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n[3] 고스와미, M., 살페르, K., 쵸우드리, A., 카이, Y., 리, S., \u0026 더브라우스키, A. (2024). MOMENT: 개방형 시계열 기반 모델 패밀리. arXiv:2402.03885 (cs.LG)에서 가져옴.\n\n[4] 다스, A., 콩, W., 센, R., \u0026 조우, Y. (2024). 시계열 예측을 위한 디코더 전용 기반 모델. arXiv:2310.10688 (cs.CL)에서 가져옴.\n\n[5] 라술, K., 아쇼크, A., 윌리엄스, A. R., 고니아, H., 바그와트카르, R., 코라사니, A., 다르비시 바이아지, M. J., 아다모푸로스, G., 리아치, R., 하센, N., 비로스, M., 가르그, S., 슈나이더, A., 채파도스, N., 드루앵, A., 잔테데케시, V., 네우미바카, Y., \u0026 리시, I. (2024). Lag-Llama: 확률적 시계열 예측을 위한 기반 모델로. arXiv:2310.08278 (cs.LG)에서 가져옴.\n\n[6] 우, G., 리우, C., 쿠마르, A., 씨옹, C., 사바레세, S., \u0026 사후, D. (2024). 통합된 유니버설 시계열 예측 트랜스포머의 훈련. arXiv:2402.02592 (cs.LG)에서 가져옴.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n[7] Vaswani, A., Shazeer, N., Parmar, N., Uszkoreit, J., Jones, L., Gomez, A. N., Kaiser, L., \u0026 Polosukhin, I. (2017). Attention Is All You Need. arXiv:1706.03762에서 가져옴.\n\n[8] Stankeviciute, K., Alaa, A. M., \u0026 van der Schaar, M. (2021). Conformal time-series forecasting. Advances in Neural Information Processing Systems (Vol. 34, pp. 6216–6228)에 소개됨.","ogImage":{"url":"/TIL/assets/img/2024-07-12-TimeGPTvsTiDEIsZero-ShotInferencetheFutureofForecastingorJustHype_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-TimeGPTvsTiDEIsZero-ShotInferencetheFutureofForecastingorJustHype_0.png","tag":["Tech"],"readingTime":19},{"title":"새로운 R 및 Python IDE, Posit Positron 시작하기 사용법 가이드","description":"","date":"2024-07-12 19:38","slug":"2024-07-12-GettingStartedWithPositPositronthenewIDEforRandPython","content":"\n\n\n![image](/TIL/assets/img/2024-07-12-GettingStartedWithPositPositronthenewIDEforRandPython_0.png)\n\nPositron sounds like the latest Autobot to join Optimus Prime in the Transformer movies (and toys — can’t forget those!!). Instead, it is a new IDE meant to transform programming and data science workflows if its creator Posit has its way.\n\nPositron is an IDE, launched as a surprise Beta product by Posit. The new IDE is designed to allow data scientists to better explore data in both R and Python programs.\n\n## Some Background on Posit\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n포지트의 이름 선택은 흥미로운 역사를 갖고 있어요. 포지트는 주요 제품으로 인해 먼저 RStudio로 알려진 소프트웨어 개발 회사입니다. RStudio는 주로 R 프로그래머들 사이에서 매우 인기 있는 통합 개발 환경(IDE)로, 스크립트, 라이브러리, 시각화 및 생성된 데이터 개체를 표시하는 분할 창 레이아웃으로 유명해졌어요.\n\nRStudio는 reticulate를 실행할 수 있는 기능을 통합하여 Python을 R에서 실행할 수 있게 했어요. 그리고 최신화된 마크다운 스위트인 Quarto가 기능을 더욱 향상시켰어요. 결과적으로, RStudio는 상당한 규모의 Python 개발자들을 끌게 되었어요.\n\n# 시작하기\n\n포지트론을 시작하려면 GitHub 저장소의 릴리스 페이지를 통해 IDE를 다운로드해야 해요. 현재 베타 버전은 Windows 및 맥 OS에서 사용할 수 있어요. 물론, 페이지에서는 요구 사항을 설명하고 있어요 — 포지트가 더 많은 베타 버전을 출시할수록 IDE의 몇 가지 반복 버전을 볼 수 있을 거예요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nR 및 Python 언어는 일반 절차에 따라 설치되어야 합니다. 사용자는 R 버전 4.2 이상과 Python 3.8 이상을 갖추고 있어야 합니다.\n\nPython 사용자는 또한 Python을 실행하기 위한 IPykernel 패키지를 포함해야 합니다. 여기서 다운로드하는 방법을 배울 수 있습니다. 통상 Python 프로토콜을 사용하여 호출할 수 있습니다.\n\n설치된 경우 Positron은 언어 파일을 인식하여 기본 Python 및 R을 위한 패키지 및 라이브러리 설치에 시달리지 않고 시작할 수 있도록 합니다.\n\nPython 환경 설정이 다른 경우 드롭다운 메뉴도 있습니다. IDE 오른쪽 상단에 나타납니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 마크다운 형식으로 컨버팅 된 표입니다.\n\n\n| Tag        | Description                                                                             |\n|------------|-----------------------------------------------------------------------------------------|\n| img        | `\u003cimg\u003e` 태그는 이미지를 삽입할 때 사용합니다.                                                  |\n| div        | `\u003cdiv\u003e` 태그는 문서의 섹션을 나타내거나 스타일을 지정하기 위해 사용됩니다.                             |\n| p          | `\u003cp\u003e` 태그는 단락을 나타내며 텍스트를 그룹화할 때 사용됩니다.                                        |\n| a          | `\u003ca\u003e` 태그는 하이퍼링크를 생성할 때 사용되며 클릭 가능한 링크를 만듭니다.                          |\n| table      | `\u003ctable\u003e` 태그는 표를 만들기 위해 사용되며 여러 행과 열을 가질 수 있습니다.                           |\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nPosit가 Positron을 개발할 때 Visual Studio 코드에 사용된 OSS(오픈 소스 소프트웨어) 아키텍처를 사용했어요. 그런 다음 Positron에는 RStudio와 유사한 데이터 탐색을 위한 목적의 독특한 기능들이 추가되었어요.\n\nRStudio 설정과 유사한 영역에 전용 패널이 있는 플로팅이 가능합니다. 또한 Shiny 앱을 표시하는 데도 작동하며, 사용자는 환경 내에서 R 기반 및 Python 기반 Shiny 앱을 모두 볼 수 있습니다.\n\n왼쪽 메뉴에는 Visual Studio 코드에 나타나는 아이콘과 같은 아이콘이 있어요 — 탐색, 검색, 소스 제어, 실행 및 디버그 아이콘입니다. 주요 차이점은 테스트 아이콘입니다. 이 테스트 아이콘을 사용하여 사용자는 Positron에서 실행된 프로그램을 위한 테스트 프레임워크를 구성할 수 있어요. 이를 통해 환경에서 간단한 테스트를 만드는 데 도움이 될 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 데이터 탐색기를 사용하여 데이터 검사\n\nPositron의 가장 중요한 기능은 변수 검사와 플로팅을 지원하는 RStudio 스타일입니다. 변수 검사 기능을 사용하면 사용자가 데이터 크기 및 최근성에 따라 어떤 변수가 있는지 알 수 있습니다.\n\nGitHub 페이지에 따르면 데이터 탐색기에는 데이터 그리드, 요약 패널 및 필터 막대가 있습니다.\n\n- 데이터 그리드 — 개별 셀 및 열을 표시하는 스프레드시트 형식의 출력입니다. 또한 정렬 기능도 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n**2. 요약 패널** - 각 열 이름, 유형 및 결측 데이터 비율을 보여주는 디스플레이입니다. 탐색적 데이터 분석을 보완하는데 사용되며, 각 열 이름과 그에 해당하는 유형을 나타내는 아이콘을 나란히 표시합니다. 또한 인라인 막대 그래프 내에서 결측 데이터 양을 증가하는 백분율로 표시합니다.\n\n![이미지](/TIL/assets/img/2024-07-12-GettingStartedWithPositPositronthenewIDEforRandPython_3.png)\n\n**3. 필터 막대** - 열의 관측값 유형에 따라 특정 열을 필터링하는 기능을 제공합니다. 예를 들어, 문자열 열은 포함하거나 시작하거나 끝나거나 비어있거나 정확히 일치하는 등의 필터를 가지고 있습니다. 숫자 열은 논리 연산의 필터를 가지고 있어 작거나 크거나, 동일하거나, 두 값 사이에 포함되는 등의 작업을 수행할 수 있습니다.\n\n그림을 생성하기 위해 ggplot, txhousing로부터 데이터를 가져왔습니다. 데이터에는 9개의 열이 있습니다. 왼쪽에는 각 열의 요약 패널을 볼 수 있습니다. 그 옆에 데이터 그리드가 나타납니다. 오른쪽에는 변수 패널 아래에 생성한 변수인 q가 표시됩니다. q 변수는 텍사스 주택 데이터를 포함하는 것뿐입니다. 패널에는 q를 설명하는데 쓰이며, 사용된 데이터 오브젝트 유형(data.frame), 행 수(8602), 열 수(9)를 보여줍니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![Data Explorer Screenshot](/TIL/assets/img/2024-07-12-GettingStartedWithPositPositronthenewIDEforRandPython_4.png)\n\n데이터 익스플로러(Data Explorer)를 사용하면 Python(pandas)이나 R(data.frame, tibble, data.table)에서 해당 데이터 프레임을 표시할 수 있어, 대부분의 데이터 모델링 요구를 보완할 수 있습니다.\n\n또한 다른 데이터 유형인 polars에 대한 실험적 지원이 있습니다. 추가 Python 데이터 프레임 라이브러리도 곧 예상됩니다.\n\n# 확장 기능 추가 가능\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n사용자들은 일반적으로 Visual Studio Code에서 사용하는 동일한 확장 프로그램을 추가할 수 있습니다. 아래 이미지에서 Prettier를 사용하여 Positron 계정에 어두운 테마를 적용했습니다.\n\n확장 프로그램의 가용성을 통해 개발자들은 다양한 상호작용이나 도구에 적응할 필요 없이 보다 개인화된 개발 환경을 구축할 수 있습니다.\n\n그러나 사용자들은 일반적으로 Visual Studio Code에서 필요한 R 및 Python 실행을 위해 어떤 확장 프로그램도 사용하지 않는 것이 좋습니다. 이러한 확장 프로그램에서 이미 필요한 기능이 Positron에 포함되어 있기 때문에 필요하지 않습니다. 이 통합은 VSC에 비해 일부 환경 \"불필요한\" 요소를 저장할 수 있으나, 아마도 VSC는 R 프로그래밍을 실행하기 위한 환경에서 확장 프로그램만이 필요할 것입니다.\n\n또한 Postiron 확장 프로그램을 찾고 설치하기 위해서는 OpenVSX(https://openvsx.org)를 사용해야 합니다. Microsoft Marketplace 대신 사용해야 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# RStudio가 곧 대체될 것으로 기대하지 마세요\n\nPositron에 대한 초기 대중 응답은 긍정적이지만, 아직 IDE가 완전히 RStudio를 대체할 것인지에 대한 의문이 남아 있습니다. Positron을 시도한 대부분의 개발자들은 이를 RStudio의 대체품으로 극찬하고 있습니다.\n\nPosit의 수석 과학자 인 Hadley Wickham은 R 프로그래밍에 대해 방대한 글을 쓴 사람으로, Positron을 사용한 후 계속해서 지원이 가능하며 RStudio의 개발은 장래에 계속될 것이라고 팔로워들에게 안심시켰습니다. 그는 또 다른 게시물에서, 몇 가지 버그 해결이 남아 있기 때문에 처음 공부하는 학습자들에게는 문제가 해결된 IDE가 필요하다는 점을 주의했습니다.\n\n![Getting Started with Posit: Positron, the new IDE for R and Python](/TIL/assets/img/2024-07-12-GettingStartedWithPositPositronthenewIDEforRandPython_5.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n나 또한 Positron이 가져야했던 몇 가지 기능이 RStudio에 있다고 생각합니다. 적어도 변형으로써요. RStudio에서 파일을 빠르게 찾을 수 있고 어떤 라이브러리가 업데이트가 필요한지 확인하고 업데이트를 설치하고 함수 정의를 찾을 수 있는 것이 마음에 듭니다. 하지만 이 모든 것은 현재 R과 Python 사용이 혼합된 상태보다는 R 프로그래밍을 위해 설계되었습니다.\n\nPosit에는 Positron에서 유용한 도구가 있습니다. 이것이 어떻게 더 발전하고 개발자 및 데이터 과학자들 사이에서 어떻게 채택되어 나갈지 흥미롭게 살펴볼 만합니다.","ogImage":{"url":"/TIL/assets/img/2024-07-12-GettingStartedWithPositPositronthenewIDEforRandPython_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-GettingStartedWithPositPositronthenewIDEforRandPython_0.png","tag":["Tech"],"readingTime":9},{"title":"시계열 잔차 분석 숨겨진 가치를 찾아라","description":"","date":"2024-07-12 19:36","slug":"2024-07-12-Timeseriesresidualsgoldinthemtharhills","content":"\n\n![2024-07-12-Timeseriesresidualsgoldinthemtharhills_0.png](/TIL/assets/img/2024-07-12-Timeseriesresidualsgoldinthemtharhills_0.png)\n\n실무자들은 종종 모델이 데이터 집합과 얼마나 잘 맞는지를 평가하는 데 어려움을 겪습니다. 대부분의 경우 이는 여러 손실 지표를 살피는 것을 포함하거나 때로는 세분화된 지표를 살펴보는 것 또는 모델의 약점이나 편향을 식별하기 위해 예상 성능과 실제 성능을 보여주는 끝없는 차트를 살피는 것을 의미합니다.\n\n이와 같은 작업에는 문제가 없으며, 이 모든 과정은 모델링 과정의 중요한 부분입니다. 그러나 모델 맞춤의 자연스러운 이중성인 모델 잔차를 간과하지 않는 것이 중요합니다.\n\n모델 잔차는 모델에서 \"남는 부분\"으로 생각할 수 있습니다. 이론적으로 좋은 모델의 잔차는 '좋은' 모델이 모든 진짜 신호를 잡았기 때문에 무작위 잡음에 불과할 것입니다. 그러나 현실적으로 이는 항상 그렇지 않으며, 잔차는 모델 개선을 위한 통찰력을 제공할 수 있습니다. 일반적으로 인기 있는 그래디언트 부스팅 트리 모델인 XGBoost와 LightGBM은 이를 수행하여 더 나은 모델을 구축합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n오늘은 시계열 잔차가 어떻게 우리가 더 나은 예측 모델을 만드는 데 도움이 되는지 살펴볼 거에요.\n\n- 먼저 실제 데이터를 활용하여 영국의 도로 교통 사고에 대한 간단한 분석을 시작할 거에요.\n- 적은 양의 코딩을 통해 우리는 시계열 모델(및 잔차)을 구축하고 검토할 수 있는 기능을 얻게 될 거에요.\n- 3가지 다른 모델이 어떻게 적합하게 구성되고 그들의 결점이 모델 잔차에서 강조되는지 살펴볼 거에요: 추세만을 고려한 모델은 계절적 효과를 놓치게 되고, 계절성만 고려한 모델은 추세를 놓치게 되며, 추세와 계절성을 모두 고려한 모델은 미세한 세부 사항 중 일부를 놓치게 됩니다.\n\n시작해봐요!\n\n추가 정보: 제가 사용하는 용어나 개념에 어색하거나 조금 녹슬었다면 아래 링크된 지원 문서들을 참고해보세요. 즐거운 독해되세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 데이터\n\n우리는 영국 도로 교통 사고의 월별 발생 건수를 모델링할 것입니다. 이 데이터는 사고 당 세부 정보를 제공하는 STATS19¹ 데이터입니다. 이를 월별 도로 교통 사고 발생 건수로 집계했는데, 다음과 같이 보입니다:\n\n![image](/TIL/assets/img/2024-07-12-Timeseriesresidualsgoldinthemtharhills_1.png)\n\n일부 중요한 점들이 있습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 데이터에서 명백한 추세가 나타나고 있습니다. 1979년부터 2000년까지는 일반적인 하향 추세가 시작되기 전에 시리즈가 상당히 안정적인 것으로 보입니다. 게다가, 2014년쯤에 하향 추세 속도 변화가 보이네요.\n- 데이터에서 규칙적이고 주기적인 변동을 주목해보세요 — 강력한 계절성의 명백한 증거가 있습니다; 간단하게 말해서, 매년 1월마다 사고가 줄어드는 효과와 같이 특정 효과가 일정 주기로 반복된다는 것을 알 수 있어요.\n- 계절적 변동의 크기는 추세의 크기 변화와 함께 다양해 보이며, 이 시리즈를 가장 적절하게 모델링하는 데는 곱셈 모델 구조가 맞을 수 있어요.\n- 상당한 수준의 잡음 또는 무작위 변동이 보이네요. 예측할 수 없는 과정을 모델링 하고 있으며, 외부 환경 조건에 크게 영향을 받는데 이 환경 조건 자체가 변할 수 있으므로 어느 정도의 잡음이 예상된다고 합니다(예: 영국 날씨!).\n\n이제, 간단한 코딩을 해볼게요.\n\n# 산타의 작은 도우미(함수)\n\n작은 모델을 구축하고 모델 맞춤 및 모델 잔차를 그래픽으로 표시하기 위한 함수를 만들어 보죠. 아래와 같은 형태를 가집니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ndef fit_and_visualise_model(\n    X, y, time_index,\n    title_fit='월간 도로 교통사고 건수 (STATS19)',\n    title_resid='상대 잔차'):\n\n    # 여기에 모델을 작성하세요\n    scaler = MinMaxScaler()\n    scaler.fit(X)\n    model = LassoCV(max_iter=2_500)\n    model.fit(scaler.transform(X), np.log(y.values))\n\n    # 예측 및 잔차\n    preds = np.exp(model.predict(scaler.transform(X)))\n    resids = y.values / preds\n\n    # 적합도 시각화\n    fig,ax = plt.subplots(figsize = (22,7.5))\n    plt.plot(\n        time_index, y,\n        label='실제값', color='lightgrey',\n        linewidth=2, alpha=0.45)\n    plt.plot(\n        time_index, preds,\n        label='예측값', color='tab:orange',\n        linewidth=2)\n    plt.gca().xaxis.set_major_locator(\n        mdate.MonthLocator(bymonth=[1]))\n    plt.xticks(rotation=90)\n    plt.gca().yaxis.set_major_formatter(\n        mtick.StrMethodFormatter('{x:,.0f}'))\n    plt.grid(axis='y', which='major', alpha=0.5)\n    plt.legend(loc = 'lower left')\n    plt.title(title_fit)\n    plt.ylabel('건수')\n    plt.show()\n\n    # 잔차 시각화\n    fig,ax = plt.subplots(figsize = (22,7.5))\n    plt.scatter(time_index, resids, color='lightgrey')\n    plt.axhline(1, color='red')\n    plt.gca().xaxis.set_major_locator(mdate.MonthLocator(bymonth=[1]))\n    plt.xticks(rotation=90)\n    plt.grid(axis='y', which='major', alpha=0.5)\n    plt.title(title_resid)\n    plt.ylabel('잔차')\n    plt.show();\n```\n\n너무 복잡하지 않지만 유용한 기능이에요.\n\n# 트렌드를 따라가기\n\n시계열 데이터의 추세만을 포착하는 모델을 구축해보겠어요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래의 차트는 우리가 원하는 것과 정확히 일치하는 것처럼 보이는데요. 하지만 시계열 데이터에는 상당한 계절성이 있고, 모델에 전혀 고려하지 않았기 때문에 실제로 그런지 알 수 없습니다. 모델 residual을 더 자세히 살펴보겠습니다. 지난 5년 동안의 정보를 확대해서 살펴보겠습니다:\n\n![image](/TIL/assets/img/2024-07-12-Timeseriesresidualsgoldinthemtharhills_3.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n잔차에서 파도 모양 패턴을 눈치채셨나요? 패턴이 규칙적이고 주기적임을 볼 수 있으며, 무작위 변동이 몇 개 있는 것을 빼면요. 이것이 모델에서 포착되지 않는 계절성 신호입니다. 더 나은 모델은 이 계절성을 포착해 틈을 메울 것입니다.\n\n# 모든 계절을 위한 모델\n\n이제 시계열의 계절성만을 포착하는 모델을 구축해 봅시다.\n\n![image](/TIL/assets/img/2024-07-12-Timeseriesresidualsgoldinthemtharhills_4.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n가장 강력한 계절 모델은 아니지만, 훈련 기간 끝에서 예측이 조금 엉뚱해 보이는 점을 무시한다면, 모델이 일반적으로 반복적인 계절 효과를 잘 포착한다는 것을 볼 수 있습니다.\n\n지금쯤이면 모델이 거대한 추세 효과를 놓치고 있다는 것을 잘 알기 때문에 잔차를 살펴볼 필요가 없을 것 같지만, 아래 차트가 바로 그겁니다.\n\n# 모든 중요한 점들을 고려해야 합니다.\n\n이제 이를 마저 처리하고, 추세 및 계절성 효과를 모두 포함한 모델을 적합해 봅시다. 우리가 예상한 대로 결과 (그리고 잔차)가 훨씬 더 잘 작동하여, 이 모델이 데이터에서 진짜 신호를 더 많이 포착했다는 것을 보여줍니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![그래프](/TIL/assets/img/2024-07-12-Timeseriesresidualsgoldinthemtharhills_5.png)\n\n잔차에 여전히 패턴이 보이는 것을 주목하세요. 세 가지 구분 시기로 보이는 것: 1994년 이전, 1994년~2008년, 2008년부터.\n\n완벽하지는 않지만, 모델이기 때문에 꽤 괜찮은 수준입니다.\n\n# 감싸고 어슬렁어슬렁\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자세한 내용을 이야기하기 전에 간단히 요약해 볼까요?\n\n## 마무리\n\n모델 잔차가 모델을 개선하는 데 어떻게 도움이 되는지 살펴봤습니다. 이번에는 월별 영국 교통사고를 예측하기 위한 간단한 모델을 만들었습니다.\n\n시계열에서 계절성을 캡처하지 못한 경향 모델이 어떻게 실패했는지, 그리고 이 결점이 모델 잔차에서 파형 신호로 나타났는지 보았습니다. 반면에 계절성 전용 모델은 잔차에서 명확한 추세를 보여주었습니다. 그리고 추세와 계절성 모델은 성능이 좋게 향상되었지만 아직 개선할 여지가 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## \"좋은\" 모델의 잔차는 어떻게 보이나요?\n\n답은 — 약간 귀찮게 — 상황에 따라 다릅니다. 일반적으로, 곱셈(가산) 모델의 경우 잔차는 1(또는 0) 주변에 무작위 노이즈와 같이 보여야 합니다. 잔차에 일관된 패턴이 없어야 하며, 모두 좁고 유한한 범위에 있어야 합니다.\n\n우리가 앞에서 본 것처럼, 패턴은 모델의 결점을 나타낼 수 있습니다. 특히 주의해야 할 패턴 중 하나는 이분산성 또는 분산의 변동이며, 이는 통계적 유의성 검정을 무효화시키는 큰 문제입니다⁵.\n\n## 시계열 모델을 위한 피처 엔지니어링\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저는 위에 언급된 각 모델이 어떻게 구축되었는지 대략적으로 살펴봤어요. 이 내용은 다른 글에서 자세히 다루었지만, 비밀은 간단해요: Lasso 모델에 입력하는 피처를 변경하세요. 계절성만 고려한 모델이 필요하다면, 회귀 모델에 계절성 피처만 사용하세요. 트렌드만 고려한 모델도 동일한 방법이 적용돼요.\n\n우리는 종종 적합하지 않은 모델이나 모델 잔차 패턴에서 벗어날 수 있어요. 트렌드와 계절성을 모두 포함했을 때 모델이 얼마나 개선되는지 확인해보세요. 가끔 모델이 필요로 하는 것이 명확하지 않을 수 있으니, 측면적 사고와 시행착오에 대비해야 해요.\n\n이미 세 가지 주요 시기를 식별했기 때문에 최종 모델이 완벽하지는 않다는 것은 분명해요. 모델을 개선할 빠른 방법이 있을 수 있어요: 몇 개의 변곡점을 추가하거나 피처 간 상호작용을 포함하는 것이 높은 확률로 효과를 볼 수 있어요. 예를 들어, 지표 피처를 추가하면 1994년 이전의 시기의 모델 적합도가 향상될 수 있어요. 이를 통해 이 기간에 적용된 계절성을 효율적으로 조절함으로써 모델 잔차를 축소할 수 있어요.\n\n여기까지! 이 글까지 읽어주셔서 감사합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 이 글을 즐겼고 제 더 많은 이야기들을 보고 싶다면, 여기를 한 번 봐주세요:\n\n다음 시간에 뵙겠습니다.\n\n# 참고 자료와 유용한 자원들\n\n- [Open Government Licence](https://roadtraffic.dft.gov.uk/downloads)을(를) 사용한 자료 (nationalarchives.gov.uk)\n- [시계열(time series) 구성 요소 및 모델 구조: 시계열 분해에 대한 포괄적 가이드 | Towards AI](https://github.com/)\n- [시계열 회귀 모델을 위한 특성 구축: False Prophet: Feature Engineering for Time Series | Towards Data Science](https://github.com/)\n- [False Prophet: 시계열 회귀 모델 | Towards Data Science](https://github.com/)는 이 글에서 사용된 모델 구조와 유사한 회귀 모델에 대한 자세한 내용을 다룹니다.\n- 동분산성 및 이분산성 — 위키백과\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 친절한 한국어 번역 🚀\n\nIn Plain English 커뮤니티에 참여해 주셔서 감사합니다! 다음에 가시기 전에:\n\n- 글쓴이를 칭찬하고 팔로우해 주세요 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요","ogImage":{"url":"/TIL/assets/img/2024-07-12-Timeseriesresidualsgoldinthemtharhills_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-Timeseriesresidualsgoldinthemtharhills_0.png","tag":["Tech"],"readingTime":10},{"title":"오늘 배운 사실  왜 속성에 바다코끼리 연산자를 사용할 수 없을까","description":"","date":"2024-07-12 19:35","slug":"2024-07-12-TodayILearntWeCantUseTheWalrusOperatorOnAttributes","content":"\n\n\n![Example of the walrus operator](/TIL/assets/img/2024-07-12-TodayILearntWeCantUseTheWalrusOperatorOnAttributes_0.png)\r\n\r\nThe walrus operator := can condense 2 lines of code into one.\r\n\r\n```javascript\r\n// without walrus operator\r\n\r\nlet x = 'apple';\r\nif (x == 'apple') {\r\n    console.log('ok');\r\n}\r\n```\r\n\r\n```javascript\r\n// with walrus operator\r\n\r\nif ((x := 'apple') === 'apple') {\r\n    console.log('ok');\r\n}\r\n```\r\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n(x := `apple`)라는 구문에서 2가지 작업이 발생합니다:\n\n- x가 `apple`에 할당됩니다.\n- (x := `apple`) 자체가 `apple` 값을 반환합니다.\n\n# 배악 체이너와 속성\n\n하지만 객체 속성으로 이 작업을 시도할 때 오류가 발생합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nclass Dog:\n    pass\n\ndog = Dog()\n\nif (dog.age = 5) == 5:\n    print('ok')\n\n# SyntaxError: cannot use assignment expressions with attribute\n```\n\n그래서 우리는 dog.age와 같은 속성에 월러스 연산자 :=을 사용할 수 없다는 것을 알 수 있습니다. 저에게는 좀 이상한 것 같네요.\n\n그렇다면 어떻게 한 줄의 코드로 여전히 동일한 효과를 얻을 수 있을까요?\n\n# 해결책\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n먼저 속성을 설정하는 방법에 대해 알아봅시다\n\n```js\ndog.name = 'rocky'\n```\n\n```js\n# 위와 동일합니다\nsetattr(dog, 'name', 'rocky')\n\n# setattr()은 None을 반환합니다\n```\n\n다음으로 x 또는 `hello` 구문을 살펴보겠습니다\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# x은 Truthy 값입니다. 예: 5, 'apple'\n\nx = 'apple'\ny = x 또는 'hello'\n\nprint(y)  # apple\n```\n\n```js\n# x은 Falsy 값입니다. 예: None, 0, ''\n\nx = None\ny = x 또는 'hello'\n\nprint(y)  # hello\n```\n\n^ x 또는 `hello`에서:\n\n- x가 Truthy 값이면, 이 식은 x의 원래 값 반환\n- x가 Falsy 값이면, 이 식은 `hello`를 반환합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기서 이점을 취할 수 있어요:\n\n```js\n# 우리가 이루려고 하는 것 (이건 불법입니다)\n\nif (dog.name := 'rocky') == 'rocky':\n    # 작업\r\n```\n\n```js\n# 우리의 해결책\n\nif (setattr(dog, 'name', 'rocky') or 'rocky') == 'rocky':\n    # 작업\r\n```\n\n# 결론\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 건은 하나의 줄로 코드를 작성하길 원하는 경우에만 필요합니다. 그게 아니라면 2줄로 작성하세요.\n\n참고 - 프로덕션 코드에서는 사용하지 마세요\n\n# 만약 제가 크리에이터로서를 지원하길 원한다면\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 제 책을 구매해주세요! — 파이썬에 대해 전혀 몰랐던 101가지 이야기\n- 찾을 수 있는 곳: [여기를 클릭해주세요](https://payhip.com/b/vywcf)\n- 이 이야기를 칭찬해주세요. 50번!\n- 자신의 생각을 남겨주세요.\n- 이야기 중에서 가장 마음에 드는 부분을 강조해주세요.\n\n감사합니다! 이런 작은 행동들이 큰 변화를 만듭니다. 정말 감사드립니다!\n\nYouTube: [여기를 클릭해주세요](https://www.youtube.com/@zlliu246)\n\nLinkedIn: [여기를 클릭해주세요](https://www.linkedin.com/in/zlliu/)","ogImage":{"url":"/TIL/assets/img/2024-07-12-TodayILearntWeCantUseTheWalrusOperatorOnAttributes_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-TodayILearntWeCantUseTheWalrusOperatorOnAttributes_0.png","tag":["Tech"],"readingTime":4},{"title":"Yang-Zhang 방법으로 정확한 변동성 추정하기","description":"","date":"2024-07-12 19:34","slug":"2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator","content":"\n\n\n![Yang-Zhang volatility estimator](/TIL/assets/img/2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator_0.png)\n\n양-장 변동성 추정자는 초고값 점프나 밤사이 갭을 가진 자산에 특히 유용한 역사적 변동성 측정값입니다. 이 추정자는 이전 게시된 로젤스-사첼과 가만-클라스 추정자의 장점을 결합해 단순한 변동성 측정값에서 발생하는 편향과 오류를 줄이도록 설계되었습니다.\n\n이 기사에서는 이 변동성 측정치를 자세히 소개하고, 파이썬을 사용하여 시계열에 대한 롤링 계산 코드를 어떻게 작성하는지 보여줍니다.\n\n# 양-장 변동성 이해하기\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n복잡한 변동성 모델에 대해 논의하기 전에, 항상 가장 기본적인 변동성 모델(또는 계산) 즉, 역사적 표준 편차에 대해 잘 이해하는 것이 좋습니다. 역사적 방법을 사용한 표준 편차는 금융 상품의 변동성을 측정하는 일반적인 방법으로, 과거 가격 데이터를 기반으로 합니다.\n\n이는 일련의 값들의 변동이나 분산량을 정량화합니다. 금융에서는 일반적으로 일일 수익률이 그들의 평균 주변에서 얼마나 퍼져있는지를 측정합니다. 표준 편차를 계산하는 단계는 다음과 같습니다:\n\n- 차분(첫 번째 함수) 또는 로그 방법(두 번째 함수)을 사용하여 수익률을 계산합니다.\n\n![image](/TIL/assets/img/2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator_1.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![이미지](/TIL/assets/img/2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator_2.png)\n\n- 수익률의 평균(평균)을 계산하세요:\n\n![이미지](/TIL/assets/img/2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator_3.png)\n\n- 일일 수익률의 분산을 계산하세요:\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![이미지](/TIL/assets/img/2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator_4.png)\n\n- 표준 편차는 분산의 제곱근이다:\n\n![이미지](/TIL/assets/img/2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator_5.png)\n\n어떤 통계적 측정 값처럼 장단점이 있습니다. 역사적 표준 편차는 쉽게 계산할 수 있습니다. 스프레드시트 및 프로그래밍 언어에서 쉽게 구현할 수 있는 기본 통계 작업이 필요합니다. 변동성에 대한 공식적인 측정 방법으로 이해되며, 깊은 통계 배경을 갖지 않을 수 있는 이해관계자들에게 쉽게 설명할 수 있습니다. 많은 금융 모델 및 위험 지표(예: 샤프 비율)는 리스크 측정 값으로서 표준 편차를 의존합니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n샘플 크기가 작은 경우, 역사적 표준 편차는 실제 변동성을 과소평가하는 경향이 있습니다. 이 편향은 자산의 리스크에 대한 잘못된 결론으로 이어질 수 있습니다. 이 방법은 분석 기간 동안 자산의 기저 변동성이 일정하다고 가정합니다. 실제로 변동성은 시간이 지남에 따라 변할 수 있으므로 이 가정은 현실적이지 않습니다.\n\n게다가, 금융 수익은 종종 꼬리가 두꺼운 경향(leptokurtosis)과 비뚤림을 나타내며, 이는 정규 분포를 따르지 않음을 의미합니다. 표준 편차는 이러한 특성을 포착하지 못하며, 결과적으로 리스크를 과소평가할 수 있습니다.\n\nNvidia의 일일 수익에 대한 롤링 5일 변동성 측정치를 계산하기 위해 Python에서 다음 코드를 사용해보세요:\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport yfinance as yf\n\ndef calculate_rolling_historical_volatility(data, window):\n    # 수익률 계산 (차분 방법 사용)\n    returns = data['Close'] - data['Close'].shift(1).dropna()\n    \n    # 수익률의 롤링 표준 편차 계산\n    rolling_volatility = returns.rolling(window=window).std()\n    \n    # 표준 편차 측정 값을 포함하는 변수 반환\n    return rolling_volatility\n\n# Nvidia의 역사적 값 다운로드\ndf = yf.download(\"NVDA\", start=\"2022-01-01\", end=\"2024-06-30\")\n\n# 롤링 윈도우 크기 정의\nwindow_size = 5\n\n# 공식 적용 및 변동성 데이터프레임 얻기\nrolling_volatility = calculate_rolling_historical_volatility(df, window=window_size)\n\n# 시간에 따른 변동성 플로팅\nplt.plot(rolling_volatility, color='black', label='5일 주기 역사적 표준 편차')\nplt.legend()\nplt.grid()\nplt.axhline(y=np.mean(rolling_volatility), color='red', linestyle='dashed')\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nYang-Zhang 변동성 추정기는 Rogers-Satchell 및 Garman-Klass 추정기의 장점을 결합한 과거 변동성 측정치이다. 이는 특히 고개를 넘는 높은 가격 변동이나 야간 갭이 있는 자산에 유용하다. 이 추정기는 더 간단한 변동성 추정기에 존재하는 편향 및 오차를 줄이도록 설계되었다.\n\nYang-Zhang 변동성 추정기는 다음 공식을 사용하여 계산된다:\n\n![equation](/TIL/assets/img/2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator_6.png)\n\n참고:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator_7.png\" /\u003e\n\n첫 번째 표준 편차 용어는 open-close 변동성을 나타내고, 두 번째는 close-close 변동성을 나타내며, 세 번째는 Rogers-Satchell 변동성 추정값입니다.\n\nK factor는 open-close 변동성과 close-close 변동성의 기여도를 균형 있게 조정하며, 표본 크기 n에 대한 보정을 합니다. 양-장(Estimators) 추정자는 다른 추정자들과 비교하여 개시 가격의 급등과 종가 변동에 덜 민감하며, 상당한 야간 갭을 경험하는 자산에 대해 더 견고합니다.\n\n더 많은 작업을 보려면, 그림에 첨부된 링크를 따라 가면 PDF 책 카탈로그를 찾을 수 있는 제 웹사이트를 방문해주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](/TIL/assets/img/2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator_8.png)\n\n# Python에서 Yang-Zhang 변동성 계산하기\n\n이제 Python을 사용하여 Yang-Zhang 변동성을 계산해 보겠습니다. 같은 예시를 사용할 것입니다 (즉, lookback 기간이 5인 Nvidia의 일일 수익률):\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport yfinance as yf\nimport math\n\ndef yang_zhang(price_data, window_size=30, periods=252, clean=True):\n\n    log_ho = (price_data[\"High\"] / price_data[\"Open\"]).apply(np.log)\n    log_lo = (price_data[\"Low\"] / price_data[\"Open\"]).apply(np.log)\n    log_co = (price_data[\"Close\"] / price_data[\"Open\"]).apply(np.log)\n\n    log_oc = (price_data[\"Open\"] / price_data[\"Close\"].shift(1)).apply(np.log)\n    log_oc_sq = log_oc ** 2\n\n    log_cc = (price_data[\"Close\"] / price_data[\"Close\"].shift(1)).apply(np.log)\n    log_cc_sq = log_cc ** 2\n\n    rs = log_ho * (log_ho - log_co) + log_lo * (log_lo - log_co)\n\n    close_vol = log_cc_sq.rolling(window=window_size, center=False).sum() * (\n        1.0 / (window_size - 1.0)\n    )\n    open_vol = log_oc_sq.rolling(window=window_size, center=False).sum() * (\n        1.0 / (window_size - 1.0)\n    )\n    window_rs = rs.rolling(window=window_size, center=False).sum() * (1.0 / (window_size - 1.0))\n\n    k = 0.34 / (1.34 + (window_size + 1) / (window_size - 1))\n    result = (open_vol + k * close_vol + (1 - k) * window_rs).apply(\n        np.sqrt\n    ) * math.sqrt(periods)\n\n    if clean:\n        return result.dropna()\n    else:\n        return result\n\n# Nvidia의 과거 값 다운로드\ndf = yf.download(\"NVDA\", start=\"2020-01-01\", end=\"2024-06-30\")\n# Rolling window 크기 정의\nwindow_size = 5\n# 식 적용 및 변동성 데이터 프레임 가져오기\nrolling_volatility = yang_zhang(df)\n# 시간대별 변동성 플롯\nplt.plot(rolling_volatility, color='black', label='5-period Yang-Zhang 변동성')\nplt.legend()\nplt.grid()\nplt.axhline(y=np.mean(rolling_volatility), color='red', linestyle='dashed)\n```\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/TIL/assets/img/2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator_9.png)\n\n과거 표준 편차는 변동성의 유용하고 널리 채택된 측정 방법이며, 간단함, 계산의 용이성 및 금융 산업에서의 일반적인 수용으로 인해 가치가 있습니다. 그러나 작은 표본 크기, 비정상적 변동성 및 수익의 비정규 분포를 처리하는 데 있어서 특히 한계가 있어 조심해서 사용해야 합니다.\n\n정확성이 중요하거나 표본 크기가 작은 경우, 대안적인 변동성 모델이 더 나은 리스크 평가를 제공할 수 있습니다.","ogImage":{"url":"/TIL/assets/img/2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-Yang-ZhangasanAccurateVolatilityEstimator_0.png","tag":["Tech"],"readingTime":8},{"title":"파이썬으로 GenAI 사용하기 LLM과 에이전트 비교","description":"","date":"2024-07-12 19:31","slug":"2024-07-12-GenAIwithPythonLLMvsAgents","content":"\n\n\n![2024-07-12-GenAIwithPythonLLMvsAgents_0.png](/TIL/assets/img/2024-07-12-GenAIwithPythonLLMvsAgents_0.png)\n\n이 글에서는 제너레이티브 인공지능(GenAI) 최첨단 기술인 에이전트를 로컬에서 구축하는 방법을 소개하겠습니다. 일반 LLM과의 차이를 설명하면서요.\n\n![2024-07-12-GenAIwithPythonLLMvsAgents_1.png](/TIL/assets/img/2024-07-12-GenAIwithPythonLLMvsAgents_1.png)\n\n일반적으로, 지능형 에이전트는 환경을 인식할 수 있는 충분한 이해력으로 행동하는 존재로, 특정 목표를 달성하기 위해 자율적으로 행동하고 지식을 습득하며(사람과 같이) 개선합니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기술 분야에서 AI 에이전트는 작업을 수행하고 결정을 내리며 다른 개체와 통신하는 자율 프로그램입니다. 보통, 에이전트에게는 작업을 완료하는 동안 사용할 수 있는 도구 세트가 제공됩니다. 이 개념은 보상을 극대화하기 위해 정의된 일련의 작업 중에서 선택하는 강화 학습을 확장한 것입니다.\n\n대형 언어 모델(LLM)은 에이전트가 아닙니다. LLM은 단어 임베딩과 트랜스포머 아키텍처를 활용하여 고급 자연어 처리를 수행하는 신경망입니다. 인간 언어에 대한 막대한 이해력을 갖고 있지만, 지식 범위를 넘어서는 행동은 수행하지 않습니다.\n\nGenAI에서 에이전트는 순차적 추론을 처리하기 위해 설계된 AI 시스템으로, LLM의 일반 지식이 충분하지 않은 경우 외부 도구(예: 데이터베이스 쿼리, 웹 검색)를 실행할 수 있습니다. 간단히 말해, 일반적인 AI 챗봇은 답변할 수 없는 경우 무작위 텍스트를 생성하지만, 에이전트는 공백을 채우고 구체적인 응답을 제공하기 위해 도구를 활성화합니다.\n\n에이전트가 수행할 수 있는 가장 일반적인 작업은:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 대화 - 일반적인 지식 베이스와 대화하는 것을 의미합니다\n- RAG - 문서와 대화하는 것을 의미합니다\n- 쿼리(즉, SQL 생성) - 데이터베이스와 대화하는 것을 의미합니다\n- 웹 검색 - 인터넷 전체와 대화하는 것을 의미합니다\n\n그러나 가장 매혹적인 측면은 코딩이 가능하다면 어떤 것이든 도구가 될 수 있다는 것입니다. 따라서 에이전트의 기능과 응용 프로그램은 무한합니다.\n\n이 튜토리얼에서는 여러 개의 에이전트를 만들 것입니다. 다른 유사한 경우에 쉽게 적용할 수 있는 유용한 Python 코드를 제시하고 각 코드 라인에 대해 설명이 담긴 주석을 달아 이 예시를 복제할 수 있도록 안내하겠습니다(아래의 전체 코드 링크 참조).\n\n특히 다음을 다룰 것입니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 설정: LangChain + CrewAI + DuckDuckGo.\n- LLM: LLM을 사용하여 데이터를 읽고 시각 작업을 수행합니다.\n- Agent: 단일 Agent으로 동일한 작업 수행.\n- 여러 에이전트: 여럿이 팀을 이루어 동일한 작업 수행.\n\n## 설정\n\n현재, 가장 똑똑한 클로즈드 소스 인공지능(AI) Agents로는 OpenAI의 ChatGPT, Anthropic의 Claude, 그리고 Google의 Gemini가 있습니다. 오픈 소스 쪽에는 많은 초기 단계 라이브러리가 있지만, 시장 리더는 아직 없는 것으로 보입니다(이 주제는 정말 정선 기술이기 때문입니다). 주요 라이브러리는 다음과 같습니다:\n\n- LangChain — 거의 모든 LLM 기능을 포함하는 매쉬업 프레임워크입니다. Agent가 낮은 수준에서 코딩되어야 하는 경우(즉, 어떻게 메모리를 사용할지 결정해야 하는 경우), LangGraph 모듈을 추천드립니다.\n- CrewAI — \"크루\"로 함께 작업할 수 있는 여러 에이전트를 만들기 위해 특별히 설계된 라이브러리입니다.\n- AutoGen — Microsoft에서 개발한 로우코드(거의 노코드) 인터페이스 AutoGen Studio가 함께 제공되는 라이브러리입니다.\n- AnythingLLM — 가장 일반적인 작업을 수행할 수 있는 전혀 노코드 플랫폼입니다.\n- HuggingFace — 첫 번째 LLM 라이브러리이자 모델 저장소입니다.\n- LlamaIndex — Meta의 LLM 라이브러리와 새로운 에이전트 모듈 LLamaAgents가 포함되어 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nLangChain (LLM을 위한)과 CrewAI (에이전트를 위한)의 조합이 매우 사용자 친화적이고 효과적이라고 생각해요.\n\n우선, LLM과 에이전트 사이의 차이를 이해해야 해요. 좋은 예를 보여드릴게요. LLM이 \"간단\"하지만 구체적인 질문에 어떻게 답변하는지 보여줄게요. 언어 모델 실행에 대해선 Ollama 모듈과 Phi3 모델을 사용하는 것을 선호해요. 설정 방법은 이 글을 참고할 수 있어요.\n\n```js\n!pip install langchain #0.1.20\n!pip install langchain-community #0.0.38\n\nfrom langchain_community.llms import Ollama \n\nllm = Ollama(model=\"phi3\")\nres = llm.invoke(input=[\"What day is today?\"]).split(\"\\n\")[0]\nprint(res)\n```\n\n![이미지](/TIL/assets/img/2024-07-12-GenAIwithPythonLLMvsAgents_2.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n당연히 언어 모델은 오늘의 날짜를 알 수 없습니다. 답을 얻는 한 가지 방법은 인터넷에서 검색하는 것입니다. Python에서는 유명한 비공개 브라우저 DuckDuckGo를 사용하여 쉽게 할 수 있습니다.\n\n```python\n!pip install duckduckgo-search #6.1.7\n\nfrom langchain.tools import DuckDuckGoSearchResults \n\nDuckDuckGoSearchResults().run(\"오늘은 무슨 요일인가요?\")\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-GenAIwithPythonLLMvsAgents_3.png\" /\u003e\n\n... 또는 메타데이터 없이 텍스트만 원하면요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nfrom langchain_community.tools import DuckDuckGoSearchRun\n\nDuckDuckGoSearchRun().run(\"What day is today?\")\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-GenAIwithPythonLLMvsAgents_4.png\" /\u003e\n\n이제 첫 번째 에이전트를 만들어봅시다. LLM에게 우리가 방금 한 것처럼 웹을 탐색할 수 있는 기능을 제공하여. 그러면 인공지능은:\n\n- LLM 지식으로는 해당 질문에 대답할 수 없다는 것을 이해해야 합니다.\n- 추가 정보를 얻기 위해 도구를 사용해야 합니다.\n- 결과를 LLM을 통해 처리하고 답변을 생성해야 합니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n말씀드렸듯이, 어떤 것이든 Tool 객체가 될 수 있으며 CrewAI 라이브러리를 사용하여 함수에 데코레이터를 간단히 추가할 수 있습니다.\n\n```js\n!pip install \"crewai[tools]\" #0.4.0\n\nfrom crewai_tools import tool \n\n@tool\ndef tool_browser(q: str) -\u003e str:\n    \"\"\"DuckDuckGo 브라우저\"\"\"\n    return DuckDuckGoSearchRun().run(q)\n```\n\n에이전트 객체를 만들기 위해서는 목표(작업의 간단한 설명)와 배경 이야기(작업에 대한 자세한 설명)를 정의하여 일부 프롬프트 엔지니어링을 해야 합니다. 도구 및 LLM도 지정해야 합니다.\n\n```js\n!pip install crewai #0.35.0\n\nimport crewai\n\nagent = crewai.Agent(\n            role=\"Calendar\", \n            goal=\"오늘의 요일을 확인하세요\",\n            backstory=\"당신은 달력 도우미입니다. 날짜에 관한 정보를 알려줍니다.\",\n            tools=[tool_browser], \n            llm=llm,\n            allow_delegation=False, verbose=False)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그럼, 다시 한 번 목표를 지정하여 Task 객체를 생성해야 합니다.\n\n```js\ntask = crewai.Task(description=\"오늘은 무슨 요일인지 알아내기\",\n                   agent=agent,\n                   expected_output=\"오늘 날짜\")\n```\n\n마지막으로, 이 경우에는 Agent가 한 명뿐인 Crew를 실행해야 합니다.\n\n```js\ncrew = crewai.Crew(agents=[agent], tasks=[task], verbose=False)\nres = crew.kickoff()\nprint(res)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![GenAIwithPythonLLMvsAgents_5](/TIL/assets/img/2024-07-12-GenAIwithPythonLLMvsAgents_5.png)\n\n보시다시피, 에이전트는 LLM이 대답하지 못한 질문에 대답할 수 있어요. 개요를 파악하셨으니, 다음 단계로 넘어가볼까요?\n\n## LLM\n\n이 수영복 브랜드(White Water Atelier)에서는 AI를 활용한 소셜 미디어 전략을 만들어 달라고 했어요... 에이전트에게 딱 맞는 사례죠. 특히, 인스타그램 포스트 작성 프로세스를 자동화할 거에요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n먼저, 데이터(이미지)를 읽어봅시다:\n\n```js\nfrom matplotlib import image, pyplot\nimport os\n\npath = 'data/'\nfolder = [x for x in os.listdir(path) if x.endswith(('.png','.jpg','.jpeg'))]\n\nfig, ax = pyplot.subplots(nrows=1, ncols=len(folder), sharex=False, sharey=False, figsize=(4*len(folder),10))\nfor n,file in enumerate(folder):\n    ax[n].imshow(image.imread(path+file))\n    ax[n].set(title=file)\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-GenAIwithPythonLLMvsAgents_6.png\" /\u003e\n\nLLM에게 게시물을 생성하도록 요청하려면(사진 하나를 선택하고 캡션을 작성하도록 하기 위해서), 이미지는 모델이 처리할 수 있도록 문자열로 인코딩되어야 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\r\nimport base64\n\ndef encode_image(path):\n    with open(path, \"rb\") as file:\n        return base64.b64encode(file.read()).decode('utf-8')\n\nlst_imgs = [encode_image(path+i) for i in folder]\r\n```\n\n적절한 비전 LLM을 사용할 것입니다. Microsoft의 LLaVa는 GPU 없이도 작동할 수 있는 효율적인 선택입니다 (여기에서 시도해보세요).\n\n```js\r\nprompt = '''먼저 인스타그램에서 어떤 사진이 좋아요를 더 많이 받을지 결정해야 합니다. 그리고 선택한 이미지에 기반하여 변환율을 극대화할 캡션을 작성해야 합니다.'''\n\nvision_llm = Ollama(model=\"llava\")\n\nres = vision_llm.invoke(input=[prompt], images=lst_imgs)\nprint(res)\r\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-GenAIwithPythonLLMvsAgents_7.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n꽤 잘했어요. LLM이 두 가지 작업을 완료했고 좋은 설명도 추가했어요. 하지만 캡션이 해시태그가 빠져있어 조금 오래된 것 같아요.\n\n## 에이전트\n\n이전 예제와 마찬가지로, 특정 검색 도구가 제공된 에이전트에게 동일한 작업을 넘길 거에요.\n\n```js\n@tool(\"instagram\")\ndef tool_instagram(q: str) -\u003e str:\n    '''Instagram 검색'''\n    return DuckDuckGoSearchRun().run(f\"site:instagram.com {q}\")\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n과거 에이전트와의 윯 한 가붕, 이번에는 입력 데아터를 전달할 때입니다. 특히, 이미지를 설명하기 위해 비전 LLM을 활용하고 텍스트를 입력으로 사용할 것입네다.\n\n```js\nvision_llm = Ollama(model=\"llava\")\n\ndes = \"\"\nfor n,img in enumerate(lst_imgs):\n    res = vision_llm.invoke(input=[\"이미지를 정확하게 설명하세요\"], images=[img])\n    des = des.strip() + \"\\n\\n\" + f\"이미지{n+1}: \"+res.replace('\\n',' ')\n\nprint(des)\n```\n\n![이미지](/TIL/assets/img/2024-07-12-GenAIwithPythonLLMvsAgents_8.png)\n\nCrewAI에서는 에이전트 실행 시 입력을 제공해야 하며, 'inputs'를 이용하여 프롬프트에서 참조할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nprompt = '''먼저 {images}에서 어떤 이미지가 인스타그램에서 좋아요를 더 많이 받을지 결정해야 합니다. 해당 이미지를 선택한 이유를 설명한 후, 해당 이미지를 기반으로 전환율을 극대화할 캡션을 작성해야 합니다. 현재 계절, 오늘의 날짜, 이번 달의 특별한 이벤트, 트렌드 있는 해시태그 및 이모티콘을 고려하여 완벽한 캡션을 만들어보세요.'''\n\n## Agent\nagent = crewai.Agent(\n            role=\"인플루언서\", \n            goal=prompt,\n            backstory=\"모든 게시물의 전환율을 극대화하는 인플루언서입니다.\",\n            tools=[tool_instagram], \n            llm=llm,\n            allow_delegation=False, verbose=True)\n\n## Task\ntask = crewai.Task(description=prompt, agent=agent,\n                   expected_output='''인스타그램 게시물을 위한 최고의 사진과 캡션''')\n\n## Crew\ncrew = crewai.Crew(agents=[agent], tasks=[task], verbose=True)\nres = crew.kickoff(inputs={\"images\":des})\nprint(\"Res:\", res)\r\n```\n\n로그를 분석하기 위해 verbose=True로 설정했습니다. 에이전트는 요청을 처리하면서 필요한 도구인… \n\n![이미지](/TIL/assets/img/2024-07-12-GenAIwithPythonLLMvsAgents_9.png)\n\n…을 사용해 작업을 시작합니다. 요청 결과를 검토하는 것으로 계속됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-GenAIwithPythonLLMvsAgents_10.png\" /\u003e\n\n... 그러고 나면 최종 답변이 나옵니다.\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-GenAIwithPythonLLMvsAgents_11.png\" /\u003e\n\n그래서 Agents는 LLM과 같은 이미지를 선택하고 더 나은 캡션을 생성했습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 다중 에이전트\n\n성능을 극대화하기 위해 각 에이전트에게 단일 작업을 할당하는 것이 일반적입니다. 따라서 작업을 두 부분(이미지 선택 및 캡션 생성)으로 분할하고 전체 프로세스를 자동화하기 위해 여러 에이전트로 구성된 팀을 만들겠습니다:\n\n- 사진작가 — 입력 설명을 기반으로 최적의 이미지를 선택하는 작업을 맡습니다 (웹에서 검색 가능)\n- 소셜 미디어 매니저 — 사진작가의 결과를 기반으로 최적의 캡션을 작성하는 작업을 맡습니다 (웹에서 검색 가능)\n- 매니저 — 전체 프로세스를 담당하는 작업을 맡습니다. 요청을 이해하고 다른 에이전트에 일을 할당하며 최종 결과가 올바른지 확인해야 합니다 (최종 검증을 위해 사람에게 요청 가능).\n\n각 작업이 실행되는 동안 출력을 확인하기 위해 콜백 함수를 추가하는 것이 유용할 수 있습니다 (이를 Task 객체에 추가해야 함).\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ndef callback_function(output):\n    print(f\"작업 완료: {output.raw_output}\")\n```\n\n처음 두 명의 에이전트는 이전에 코딩한 것과 유사합니다. 그러나 이번에는 각 에이전트가 특정한 하나의 작업만 수행하므로 프롬프트 지침에 더 자세히 설명하겠습니다.\n\n```js\n######################## 1-사진작가 #########################\nprompt = '''{images} 중에서 인스타그램에서 더 많은 좋아요를 받을 사진을 선택하세요.'''\n\n## 에이전트\n에이전트_사진작가 = crewai.Agent(\n    role=\"사진작가\",\n    goal=prompt,\n    backstory='''사진작가로써, 인스타그램에서 더 많은 좋아요를 받을 사진을 이해해야 합니다.\n     게시물로 더 많은 사람들이 상호작용하도록 하고, 전환율을 극대화해야 합니다.\n     현재 계절, 오늘 날짜, 이번 달의 특별한 이벤트에 대해 조사해보세요.\n     ''',\n    tools=[tool_browser, tool_instagram], \n    llm=llm,\n    allow_delegation=False, verbose=False)\n\n## 작업\n작업_사진작가 = crewai.Task(\n    description=prompt,\n    agent=에이전트_사진작가,\n    callback=callback_function,\n    expected_output='''선택한 이미지 및 왜 그것이 가장 좋다고 생각하는지 설명''')\n\n\n######################## 2-소셜 미디어 매니저 ##################\nprompt = '''이미지를 기반으로 인스타그램 게시물의 전환율을 극대화할 캡션을 작성하세요.'''\n\n## 에이전트\n에이전트_소셜 = crewai.Agent(\n    role=\"소셜 미디어 매니저\",\n    goal=prompt,\n    backstory='''소셜 미디어 매니저로서, 사진작가의 결과물을 기반으로 짧은 캡션을 생성해야 합니다.\n     인스타그램에서 더 많은 좋아요를 받고, 게시물로 더 많은 사람들이 상호작용하며 전환율을 극대화해야 합니다. \n     트렌디한 주제, 해시태그 및 이모지 등에 대해 조사해보세요. \n     ''',\n    tools=[tool_browser, tool_instagram], \n    llm=llm,\n    allow_delegation=False,\n    verbose=False)\n\n## 작업\n작업_소셜 = crewai.Task(\n    description=prompt,\n    agent=에이전트_소셜,\n    expected_output='''인스타그램 게시물을 위한 짧은 캡션''')\r\n```\n\n다음 에이전트는 최종 출력물을 감시하고 인간의 검증을 요청해야 합니다. 따라서 프롬프트 설명에서 매우 정확해야 하며 에이전트 객체에서 allow_delegation=True 및 작업 객체에서 human_input=True 매개변수를 사용해야 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n######################## 3-다른 에이전트들의 매니저 #############\nprompt = '''게시물 생성 프로세스를 감독하고, 게시물 좋아요를 극대화하는 최고의 사진을 선택하고, 게시물의 전환율을 극대화하는 최고의 캡션을 작성합니다.'''\n\n## Agent\nagent_manager = crewai.Agent(\n    role=\"다른 에이전트들의 매니저\",\n    goal=prompt,\n    backstory='''프로세스의 매니저로서, 완벽한 인스타그램 게시물을 만들기 위해 모든 단계를 따릅니다:\n     1- 사진작가와 함께 더 많은 인스타그램 좋아요를 받을 사진을 선택합니다.\n     2- 이미지를 기반으로 인스타그램에서 전환율을 극대화할 게시물 캡션을 작성합니다.\n     프로세스의 끝에는 반드시 인간의 최종 승인을 요청해야 합니다. 인간 입력 도구를 사용하세요.\n     ''',\n    llm=llm,\n    allow_delegation=True, verbose=True)\n\n## Task\ntask_manager = crewai.Task(\n    description=prompt, agent=agent_manager,\n    human_input=True,\n    expected_output='''최상의 이미지와 짧은 캡션, 기본적으로 전체 인스타그램 게시물''')\r\n```\n\n마지막으로, 모든 것을 Crew 객체에 넣을 수 있습니다. 이번에는 하나의 에이전트만 프로젝트 전체를 담당해야 한다는 것을 지정할 수 있습니다. 순차 프로세스는 작업이 선형적으로 진행되어 한 작업이 다음 작업을 따르는 것을 보장하며, 계층적 프로세스는 효율적인 작업 위임 및 실행을 위해 전통적인 조직적 계층 구조를 모방합니다.\n\n```js\ncrew = crewai.Crew(agents=[agent_photograper, agent_social], \n                   tasks=[task_photograper, task_social, task_manager], \n                   process=crewai.Process.hierarchical,\n                   manager_agent=agent_manager,\n                   verbose=True)\n\nres = crew.kickoff(inputs={\"images\":des})\r\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-GenAIwithPythonLLMvsAgents_12.png\" /\u003e\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n로그에서 확인할 수 있듯이, 매니저가 요청을 처리하고 첫 번째 작업을 첫 번째 에이전트에게 위임했습니다. 첫 번째 결과는 완벽합니다. AI가 최근 소셜 미디어 트렌드와 인스타그램 알고리즘 논리를 분석했습니다.\n\n![첫 번째 결과](/TIL/assets/img/2024-07-12-GenAIwithPythonLLMvsAgents_13.png)\n\n그러나 두 번째 결과는 약간 납득하기 어렵습니다. 에이전트가 제품에 대한 \"할인\"을 언급했습니다. 요금 및 판매와 같은 주제는 지시에 포함되어 있지 않으며 인간 감독자가 승인해야 합니다 (human_input 매개변수 덕분에).\n\n![두 번째 결과](https://miro.medium.com/v2/resize:fit:1064/1*Ogf4BPBBKolftQIQXd-EQg.gif)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nGitHub에서 전체 코드를 확인할 수 있어요.\n\n## 결론\n\n본 글은 다양한 작업을 수행할 수 있는 에이전트를 구축하는 방법을 보여주는 튜토리얼이었습니다. LLM, LangChain 및 CrewAI를 사용하여 다양한 유형의 데이터를 처리할 수 있는 AI 팀을 만들었습니다. 에이전트는 매우 유연하므로 어떤 용도에도 사용자 정의할 수 있도록 프로세스를 가능한 일반적으로 설명했어요.\n\n즐겁게 읽으셨기를 바랍니다! 궁금한 점이나 피드백이 있으시다면 언제든지 연락해 주시거나 흥미로운 프로젝트를 공유해 주세요.","ogImage":{"url":"/TIL/assets/img/2024-07-12-GenAIwithPythonLLMvsAgents_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-GenAIwithPythonLLMvsAgents_0.png","tag":["Tech"],"readingTime":18},{"title":"RAG에서 성능 및 효율성을 달성하는 방법","description":"","date":"2024-07-12 19:29","slug":"2024-07-12-HowAchievingPerformanceandEfficiencyinRAG","content":"\n\n## | LLM | RAG | BENCHMARK |\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-HowAchievingPerformanceandEfficiencyinRAG_0.png\" /\u003e\n\nLLM들은 답을 모를 때 환각을 일으키곤 합니다. 연구자와 기업에게 가장 큰 머리아픔 중 하나입니다. 특히 민감한 분야를 다룰 때 환각은 참사적인 결과를 초래할 수 있습니다.\n\n그래서 새로운 패러다임인 검색 증강 생성(Retrieval Augmented Generation, RAG)이 발전했습니다. 이 새로운 시스템에서 LLM은 검색된 문맥을 활용하여 응답을 생성합니다. 따라서 RAG는 필요한 문맥을 찾아주며 LLM이 매개변수를 업데이트할 필요가 없도록 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러나 모델에는 고유한 매개 변수 메모리가 있습니다. 때로는 이 매개 변수 메모리와 컨텍스트 간에 충돌이 발생하여 모델은 매개 변수 내의 답변과 RAG에서 제안된 답변 중에서 선택해야 합니다. 이러한 이유로 시스템을 최적화하는 데 사용되는 다양한 기술이 개발되었습니다.\n\n사실, RAG는 여러 부분으로 구성되어 있고, 우리는 능숙하고 최적화된 시스템을 만들고 싶습니다. 따라서 모델이 쿼리를 문맥적으로 설정하는 방법, 가장 유사한 청크를 찾는 방법, 중요도 순서 등을 최적화해야 합니다. 시간이 흐름에 따라 몇 가지 전문 구성 요소가 발전해 왔습니다.\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-HowAchievingPerformanceandEfficiencyinRAG_1.png\" /\u003e\n\n각 단계에 대해 다른 방법들이 있기 때문에 복잡성이 증가합니다. 게다가, 더 정교한 RAG 패러다임은 여러 구성 요소로 구성되어 있으며, 각 단계마다 여러 가지 해결책이 가능합니다. 예를 들어, 다양한 종류의 청크화와 수십 가지 패턴의 임베더가 있습니다. 따라서 실무자는 여러 가지 결정을 내려야 합니다. 이러한 각각의 결정은 검색과 생성 단계에 모두 영향을 미칩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n최근 연구에서는 실증적으로 다양한 구성 요소가 RAG에 미치는 영향을 테스트했습니다.\n\n이 연구에서는 각 단계가 어떻게 영향을 미치는지를 분석하고 각 시나리오에 가장 적합한 전략이 무엇인지 조사했습니다.\n\n이 연구에서는 컴퓨팅 비용을 줄이기 위해:\n\n- 각 RAG 단계에 대한 대표적인 방법을 비교하고 세 가지 최상의 방법을 선택합니다.\n- 그런 다음 다른 구성 요소를 일정하게 유지하면서 각 방법을 개별적으로 테스트합니다.\n- 마지막으로 일부 시나리오에 대해 구성 요소 세트를 테스트합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](/TIL/assets/img/2024-07-12-HowAchievingPerformanceandEfficiencyinRAG_2.png)\n\n모든 쿼리가 검색을 요구하지는 않습니다(이는 LLM이 매개 변수화 메모리를 가지고 있기 때문입니다). RAG도 지연 시간을 늘리고 계산 비용이 발생합니다. 따라서 LLM으로 직접 응답할 쿼리와 RAG가 필요한 쿼리를 선택하는 흥미로운 방법이 있습니다. 실제로, 검색은 모델 매개 변수 이상의 지식 및 작업이 요구하는 것에 대해서만 수행되어야 합니다.\n\n따라서 이 연구에서 저자들은 매개 변수 모델 메모리가 충분한 작업과 충분하지 않은 작업(따라서 검색이 필요할 수 있음)으로 작업을 분류합니다. 저자들은 의사 결정 프로세스를 자동화하기 위해 분류기를 훈련시킵니다.\n\n![image](/TIL/assets/img/2024-07-12-HowAchievingPerformanceandEfficiencyinRAG_3.png)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다양한 종류의 청킹과 관련된 다양한 하이퍼파라미터가 있습니다. 본 연구에서 저자들은 다음을 탐구했습니다:\n\n- 청킹 유형. 토큰 수준 청킹은 가장 간단하지만 종종 성능이 좋지 않습니다. 의미 수준 청킹은 LLMs를 사용하여 분기점을 결정하며 컨텍스트를 보존하지만 계산 비용이 높습니다. 저자들은 문장 수준 청킹이 단순성과 효율성을 균형잡기 때문에 이를 사용합니다.\n- 청킹 크기. 큰 청크는 더 많은 컨텍스트를 제공하지만 처리 시간을 증가시킵니다. 반면, 작은 청크는 검색 재현율을 향상시키지만 올바른 컨텍스트를 부족할 수 있습니다. 올바른 청크를 검색하는 것은 충실성 및 관련성과 같은 메트릭을 균형 있게 맞추어야 합니다.\n- 청킹 기술. 작은 것에서 큰 것으로, 슬라이딩 윈도우와 같은 고급 기술은 블록 간의 관계를 식별할 수 있게 함으로써 검색 품질을 향상시킵니다. 일반적으로 질문과 일치하기 위해 작은 블록이 사용되는 반면, 컨텍스트 정보가 필요한 경우에는 더 큰 블록이 사용됩니다.\n\n의도적으로 너무 크거나 작은 블록은 유익하지 않습니다. 512가 가장 적당한 크기로 보입니다.\n\n![그림](/TIL/assets/img/2024-07-12-HowAchievingPerformanceandEfficiencyinRAG_4.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n슬라이딩 윈도우는 최상의 결과를 제공하는 기법인 것 같아요.\n\n![이미지](/TIL/assets/img/2024-07-12-HowAchievingPerformanceandEfficiencyinRAG_5.png)\n\n작가들은 임베딩을 위해 여러 모델을 시험한 후, 성능과 크기의 균형 때문에 LLM-Embedder를 선택했어요.\n\n![이미지](/TIL/assets/img/2024-07-12-HowAchievingPerformanceandEfficiencyinRAG_6.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n벡터 데이터베이스도 중요합니다. 이 연구에서는 여러 기준을 고려합니다: 다양한 데이터 유형을 지원하는 여러 인덱스 유형, 십억 단위의 벡터 지원 (확장성), 하이브리드 검색 및 클라우드 네이티브 기능을 고려합니다. 보통은 이러한 기준을 선택하여 유연성, 확장성 및 배포 용이성에 미치는 영향을 평가합니다. 그들에게 가장 좋은 것은 Milvus입니다:\n\n![이미지](/TIL/assets/img/2024-07-12-HowAchievingPerformanceandEfficiencyinRAG_7.png)\n\n검색을 위해 임베딩이 수행되면 상위 k개의 문서가 선택되어 생성에 사용됩니다. 원본 쿼리가 최적이 아닐 수 있으므로 쿼리 변환 시스템이 사용됩니다:\n\n- 쿼리 재작성. 이 방법은 쿼리를 다시 작성하여 관련 문서와 더 잘 일치하도록 합니다. LLM이 쿼리를 다시 작성하고 성능을 향상시키는 데 사용됩니다.\n- 쿼리 분해. 대신, 쿼리를 하위 쿼리로 분해하여 문서와 일치하도록 합니다.\n- 의사 문서 생성. 이 방법은 쿼리를 기반으로 가상 문서를 생성하고 해당 임베딩을 사용하여 유사한 문서를 찾습니다 (예: HyDE).\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저자들은 이러한 방법들과 혼합 검색을 테스트하기도 합니다. 여러 가짜 문서를 원본 쿼리와 함께 연결하면 검색 성능을 크게 향상시킬 수 있습니다. 물론 이렇게 하면 지연 비용이 증가하지만, 가상 문서 하나만으로도 충분한 것 같습니다.\n\n[해당 이미지](/TIL/assets/img/2024-07-12-HowAchievingPerformanceandEfficiencyinRAG_8.png)를 확인해보세요.\n\n또한, 저자들은 혼합 검색에 대한 다양한 값들을 테스트합니다 (희소 검색 대 밀집 검색 비율). 결과는 α 값이 0.3일 때 가장 좋은 성능을 보인다는 것을 보여줍니다 (희소 검색의 중요도를 조절하는 하이퍼파라미터).\n\n[해당 이미지](/TIL/assets/img/2024-07-12-HowAchievingPerformanceandEfficiencyinRAG_9.png)도 확인해보세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n검색 결과를 건내 받은 후 문서 재랭킹은 검색 결과의 관련성을 향상시켜줍니다. 저자들은 두 가지 접근 방식을 고려합니다:\n\nmonoT5는 성능과 효율성을 균형 있게 유지하는 것으로 보이며, TILDEv2가 가장 빠릅니다.\n\n![이미지](/TIL/assets/img/2024-07-12-HowAchievingPerformanceandEfficiencyinRAG_10.png)\n\n저자들은 또한 재랭킹 후 문서를 다시 정렬하는 repacking에 대해 고려합니다. 관련성 순서는 생성 성능에 영향을 미칩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n검색은 LLM을 혼란스럽게 만들 수 있는 중복되고 불필요한 정보를 포함하는 문서를 찾을 수 있습니다. 또한, 긴 프롬프트는 효율적이지 않습니다. 저자들은 요약에 대해 탐구합니다(관련 단락을 추출하는 추출적 방식과 정보를 압축하여 요약을 생성하는 추상적 방식 모두):\n\n- Recomp. 추출 압축기는 유용한 문장을 선택하고, 추상적 압축기는 여러 문서에서 정보를 종합합니다.\n- 선택적 콘텍스트. 중복된 정보를 콘텍스트에서 제거합니다.\n\nRecomp이 가장 잘 수행하는 모델로 보입니다:\n\n![이미지](/TIL/assets/img/2024-07-12-HowAchievingPerformanceandEfficiencyinRAG_11.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n작가들은 또한 RAG에 대한 LLM의 세밀한 조정을 탐구합니다. 결과는 모델이 세밀하게 조정되면 특히 교육 중 몇 가지 관련성 있는 문서와 임의로 선택된 문서들로 세밀하게 조정된 경우에 더 잘 작동함을 보여줍니다.\n\n![이미지](/TIL/assets/img/2024-07-12-HowAchievingPerformanceandEfficiencyinRAG_12.png)\n\n이 시점에서, 작가들은 다양한 구성 요소 선택과 관련하여 다양한 도메인인 사실 확인, 다중 점프 및 특수 도메인과 비교를 실시합니다. 또한 더 포괄적인 평가를 위해 여러 지표를 측정합니다.\n\n결과는 다음과 같습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Query Classification Module은 정확도 뿐만 아니라 시스템의 평균 대기 시간도 줄입니다 (모든 쿼리가 RAG로 답변되지는 않습니다).\n- HyDE 하이브리드는 검색에 대한 최고의 성능을 보여주지만 상대적으로 높은 계산 비용이 발생하므로 저자들은 하이브리드나 하이브리드 없는 검색을 권장합니다.\n- 다시 순위 매기는 중요하며 주요 성능 하락으로 이어집니다. MonoT5가 최고의 방법으로 확인됩니다.\n- 재포장은 영향을 미칠 것으로 보이며 문서를 오름차순의 관련성 점수로 정리하는 것이 최선인 해결책입니다.\n- 요약은 결과를 향상시키지만 대기 시간 비용이 듭니다. 요약과 유사한 성능은 여전히 얻을 수 있습니다.\n\n![이미지](/TIL/assets/img/2024-07-12-HowAchievingPerformanceandEfficiencyinRAG_13.png)\n\n재현성을 위해 코드는 여기에 있습니다:\n\nRAG에 대해 깊이 있는 벤치마킹을 수행하는 연구는 거의 없습니다. 이 작업의 가치는 최적의 구성 요소와 시스템을 체계적으로 연구함으로써 다양한 구성 요소에 대해 심층 연구를 수행했다는 점입니다. 저자에게 결론은:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 최상의 성능 실천 방법. 최상의 성능을 위한 조합은 쿼리 분류 모듈, HyDE와의 하이브리드, monoT5, 역 패킹 및 Recomp을 포함합니다. 이 방법은 계산적으로 많은 리소스를 요구할 수 있어 더 높은 대기 시간을 야기할 수 있습니다.\n- 균형있는 효율성 실천. 저자들은 계산 비용을 줄이기 위해 Hybrid with HyDE 및 TILDEv2를 사용하지 않고 재순위 작업을 하지 않는 것을 제안하며 성능에 큰 영향을 끼치지 않습니다.\n\n이 연구는 두 가지 훌륭한 처방을 제시합니다. 계산 비용 문제로 모든 가능한 조합을 탐색하는 것은 불가능할 수 있습니다. 또한 하나의 레시피가 모든 경우에 적용되지 않을 수 있습니다. 서로 다른 레시피가 더 나은 결과를 얻을 수 있는 특정 경우도 있습니다. 또한, 저자들은 RAG 및 생성기의 공동 세밀 조정을 탐구하지 않았으며 이는 성능 (및 환각 감소)에 주목할 만한 영향을 줄 수 있습니다.\n\n## 어떻게 생각하시나요? 두 가지 레시피 중 하나를 시도해 보시겠습니까? 의견을 남겨 주세요.\n\n# 이 흥미로운 내용을 찾으셨다면:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저의 다른 글을 읽어보시고 LinkedIn에서 저와 연결하거나 연락하실 수도 있어요. 매주 업데이트되는 머신 러닝 및 인공 지능 뉴스가 포함된 이 저장소를 확인해보세요. 협업 및 프로젝트에 대해 열려 있으며 LinkedIn을 통해 저에게 연락할 수 있어요. 또한 새로운 이야기를 게시할 때 알림을 받으려면 무료로 구독할 수도 있어요.\n\n저의 GitHub 저장소 링크는 여기 있어요. 거기에는 머신 러닝, 인공 지능 등과 관련된 코드 및 다양한 리소스가 수집되어 있어요.\n\n또는 최근 글 중 하나에 관심이 있을 수도 있어요:\n\n# 참고\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 글을 작성할 때 참고한 주요 참고 자료 목록입니다. 각 문장의 이름은 한 번만 인용됩니다.\n\n- 고우, 2024, 대형 언어 모델을 위한 검색 증강 생성: 조사, 링크\n- 왕, 2024, 검색 증강 생성에서의 최상의 실천법 찾기, 링크\n- 노게이라, 2020, 사전 훈련된 시퀀스-투-시퀀스 모델을 사용한 문서 순위 매김, 링크","ogImage":{"url":"/TIL/assets/img/2024-07-12-HowAchievingPerformanceandEfficiencyinRAG_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-HowAchievingPerformanceandEfficiencyinRAG_0.png","tag":["Tech"],"readingTime":11},{"title":"로컬 LLMs 실행이 생각보다 더 유용하고 쉬운 이유","description":"","date":"2024-07-12 19:27","slug":"2024-07-12-RunningLocalLLMsisMoreUsefulandEasierThanYouThink","content":"\n\n![image](/TIL/assets/img/2024-07-12-RunningLocalLLMsisMoreUsefulandEasierThanYouThink_0.png)  \n\n# #1 로컬 LLM을 사용해야 하는 이유  \n\nChatGPT은 정말 멋지죠. 그런데 한 가지 치명적인 단점이 있습니다: 작성하거나 업로드하는 모든 것이 OpenAI의 서버에 저장됩니다. 이는 많은 경우에는 문제가 되지 않을 수 있지만, 민감한 데이터를 다룰 때 문제가 될 수 있습니다.  \n\n그래서 저는 개인 컴퓨터에서 로컬로 실행할 수 있는 오픈소스 LLM을 탐구하기 시작했습니다. 실제로 그것들이 왜 훌륭한지에 대해 많은 이유가 있다는 것을 발견했습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n1. 데이터 개인 정보 보호: 귀하의 정보는 귀하의 기기에 유지됩니다.\n\n2. 비용 효율적: 가입비나 API 비용이 없으며 무료로 사용할 수 있습니다.\n\n3. 맞춤화: 모델은 귀하의 특정 시스템 프롬프트나 데이터 세트로 세밀하게 조정할 수 있습니다.\n\n4. 오프라인 기능: 인터넷 연결이 필요하지 않습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n5. 제약 사항이 없는 사용: 외부 API에서 부과된 제한이 없습니다.\n\n시작해 봅시다!\n\n## 2. Ollama 설치 및 Llama 3 실행하기\n\nOllama는 개인 컴퓨터에서 쉽게 대형 언어 모델(LLM)을 로컬에서 실행할 수 있게 해주는 오픈 소스 프로젝트입니다. 사용자 친화적이고 매우 가벼우며 Meta(럼마 3)와 구글(젬마 2)의 최신 및 최고의 사전 학습 모델을 포함한 다양한 모델을 제공하는 것으로 알려져 있습니다. 이러한 회사들이 이러한 모델을 교육하는 데 수백만 달러를 투자하여 우리가 자신의 기기에서 재미있게 사용할 수 있도록 했습니다. 대단하지 않나요?\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nOllama는 그 자체로는 빈 껍데기에 불과하며 작동하려면 LLM이 필요합니다.\n\n설치 프로세스에 들어가기 전에 사용 가능한 모델들을 살펴보겠습니다:\n\n![](/TIL/assets/img/2024-07-12-RunningLocalLLMsisMoreUsefulandEasierThanYouThink_1.png)\n\n그리고 더 많은 모델이 있습니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 글에서는 Meta사의 최신 모델인 Llama 3에 초점을 맞추어 놀라운 성능을 약속하는 이 모델이 이 플랫폼에서 가장 인기 있는 모델이라고 합니다. 이 글을 작성하는 시점에 이 모델은 440만 회 이상의 다운로드를 기록하고 있습니다.\n\n![이미지](/TIL/assets/img/2024-07-12-RunningLocalLLMsisMoreUsefulandEasierThanYouThink_2.png)\n\n다음 단계에서는 컴퓨터에 Ollama를 설치하고 Llama3로 공급하여 마침내 그 모델을 ChatGPT처럼 사용하는 방법을 보여줍니다.\n\n단계 1/2:\n1. ollama.com에 가서 \"다운로드\"를 클릭합니다. 저는 macOS를 사용하고 있으므로 이후 튜토리얼에서 이 옵션에 초점을 맞출 것이지만, Linux나 Windows에서 할 때도 크게 다르지 않을 것입니다.\n2. \"macOS용 다운로드\"를 클릭합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마크다운 형식의 표를 사용해보세요.\n\nSTEP 3/4/5:\n다른 앱들과 마찬가지로 매우 간단한 설치 단계를 따르기만 하면 됩니다.\n1. \"설치\"를 클릭합니다.\n2. \"다음\"을 클릭합니다.\n3. 터미널에서 \"ollama run llama3\"을 실행합니다.\n\n마지막 단계에서는 먼저 llama3의 8B 버전(약 4.7GB)을 컴퓨터에 다운로드한 다음 실행됩니다. 이렇게 간단합니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![Running Local LLM is More Useful and Easier Than You Think](/TIL/assets/img/2024-07-12-RunningLocalLLMsisMoreUsefulandEasierThanYouThink_5.png)\n\nAnd this article could stop right here. A few clicks and a line of code later, here we are running an LLM locally!\n\nYou can ask it anything, like explaining the differences between the 8 billion and 70 billion parameters versions of Llama 3.\n\n![Running Local LLM is More Useful and Easier Than You Think](/TIL/assets/img/2024-07-12-RunningLocalLLMsisMoreUsefulandEasierThanYouThink_6.png)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n해당 모델의 응답 시간은 일반적으로 컴퓨터의 GPU / RAM에 의존합니다.\n\n## #3 몇 가지 유용한 명령어\n\n터미널 내에서 계속 LLMs를 사용하고 싶다면 몇 가지 기본 명령어가 필요하다고 생각됩니다:\n\n- ollama run llama3\n이 경우 llama3 모델을 실행합니다.\n- ollama list\n로컬로 이미 설치된 모든 모델을 나열합니다.\n- ollama pull mistral\n플랫폼에서 다른 사용 가능한 모델을 가져옵니다. 이 경우 mistral 모델을 가져옵니다.\n- /clear (모델이 실행 중일 때)\n세션의 컨텍스트를 지워 처음부터 시작합니다.\n- /bye (모델이 실행 중일 때)\nollama를 종료합니다.\n- /? (모델이 실행 중일 때)\n사용 가능한 모든 명령어를 나열합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n더 복잡한 사용 사례를 위해 더 많은 명령이 존재합니다. 새로운 미세 조정 모델을 생성하는 것과 같은 경우가 있습니다. \n\nOllama의 Github 저장소에는 매우 완벽한 설명서가 있습니다.\n\n기본 사용 사례에 대해서는 CLI가 충분할 수도 있지만 더 많은 기능이 있습니다...\n\n# #4 Jupyter Notebook에서 Llama 3\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n터미널을 통해 LLMs를 사용하는 것도 좋지만 파이썬 코드를 통해 모델과 상호 작용하면 더 많은 가능성이 열립니다.\n\n이를 위해 langchain_community 라이브러리를 pip으로 설치해야 합니다 (pip install langchain_community) 그리고 Ollama 패키지를 가져와야 합니다.\n\n예를 들어, 어떤 사람의 이름, 나이, 직업을 제공하여 짧은 자기소개를 만들고 싶다고 가정해봅시다. 이 예제에서는 다음과 같이 코드가 작성됩니다:\n\n```js\n# !pip install langchain_community\n\n# 필요한 패키지 가져오기\nfrom langchain_community.llms import Ollama\n\n# 모델 인스턴스 생성\nllm = Ollama(model=\"llama3\")\n\n# 프롬프트와 함께 모델 사용\nllm.invoke(\"Alice의 나이가 25세이고 엔지니어로 일하는 짧은 2문장 자기소개 생성\")\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n친근한 톤으로 번역해 드릴게요.\n\n조금 더 다듬어보면 더 완벽해질거에요.\n\n단일 인물을 위한 소개를 터미널에서 쉽게 만들 수 있지만, 많은 사람들의 경우엔 파이썬 없이 같은 작업을 반복해야 할 수도 있어요. 파이썬을 사용하면 프롬프트를 매개변수화시키고, 많은 사람들에 대해 자동화된 프로세스를 실행할 수 있어요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예를 들어:\n\n```python\nimport pandas as pd\n\n# 샘플 DataFrame 생성\ndf = pd.DataFrame({\n    'name': ['Alice', 'Bob', 'Charlie'],\n    'age': [25, 30, 35],\n    'occupation': ['Engineer', 'Teacher', 'Artist']\n})\n\n# DataFrame에 적용할 수 있는 함수 생성\ndef generate_bio(name, age, occupation):\n    prompt = f\"{name}님에 대한 간단한 2문장 소개 생성, {age}세이고 {occupation}로 근무 중\"\n    return llm.invoke(prompt)\n\n# DataFrame에 함수 적용\ndf['bio'] = df.apply(lambda row: generate_bio(row['name'], row['age'], row['occupation']), axis=1)\n\ndf.head()\n```\n\n이제 DataFrame의 각 행에 대해 모델이 바이오를 생성합니다!\n\n# 5번째 단계 최종 소견\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 기사의 목적은 Ollama 덕분에 로컬에서 완전히 기능적인 LLM(Large Language Model)을 구현하는 간편함을 강조하는 것이었습니다.\n\n간단한 요청을 위해 터미널을 통해 이 모델을 사용하거나 Python을 사용하여 더 복잡하거나 자동화된 작업을 수행할 수 있습니다. 프로세스는 간단합니다.\n\nOpen WebUI와 같은 오픈 소스 프로젝트 덕분에 우리만의 ChatGPT와 같은 그래픽 인터페이스를 구현할 수도 있습니다.\n\n저는 그저 몇 번의 클릭과 몇 줄의 코드로 이렇게 유용한 것을 얻을 수 있다는 것이 놀라워요! 여러분도 즐기셨으면 좋겠네요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기사 끝까지 읽어 주셔서 감사합니다.\n더 많은 내용을 보려면 팔로우해주세요!\n질문이나 의견이 있으시면 아래에 메시지를 남겨 주시거나 LinkedIn / X를 통해 연락해 주세요!","ogImage":{"url":"/TIL/assets/img/2024-07-12-RunningLocalLLMsisMoreUsefulandEasierThanYouThink_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-RunningLocalLLMsisMoreUsefulandEasierThanYouThink_0.png","tag":["Tech"],"readingTime":9},{"title":"코드 변경을 안전하게 하는 커스텀 pre-commit 훅 사용하는 방법","description":"","date":"2024-07-09 21:03","slug":"2024-07-09-Custompre-commithooksforsafercodechanges","content":"\n## 첫 번째 pre-commit 훅을 작성하는 단계별 가이드\n\n![이미지](/TIL/assets/img/2024-07-09-Custompre-commithooksforsafercodechanges_0.png)\n\n대부분의 소프트웨어는 코드를 업데이트하고 배포하기 위해 git 버전 관리 시스템을 사용하여 개발됩니다. 코드를 협업하여 작성하는 한 가지 어려움은 각 참여자가 깨끗한 코드로 간주되는 것에 대한 자기 스타일과 의견이 있을 때 특정한 표준을 보장하는 것입니다.\n\npre-commit 훅은 코드 변경을 커밋하기 전에 자동으로 실행되는 스크립트나 명령어입니다. 이들은 스타일 가이드를 강제하고 커밋되기 전에 오류를 잡을 수 있으며 더 다양하게 배포할 수 있습니다. 주요한 훅은 구문 오류를 확인하고, import를 정렬하며, 따옴표를 정규화하는 것이 있습니다. 이러한 훅들은 많은 참여자가 있는 오픈 소스 프로젝트를 포함한 모든 프로젝트에 필수적인 도구입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 사용자 정의 pre-commit 훅을 만드는 이유\n\n저는 Python 라이브러리 Hamilton을 위해 데이터플로우 정의를 검증하기 위한 pre-commit 훅을 만드려고 했지만, 대부분의 온라인 자료가 분산되어 있고 기본 사용법에 한정되어 있다는 것을 발견했습니다.\n\n이 게시물에서는 다음을 찾아볼 수 있습니다:\n\n- 프로젝트에서 pre-commit 훅을 사용하기 시작하는 방법\n- 사용자 정의 pre-commit 훅을 개발하기 위한 단계별 튜토리얼\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n토론을 바탕으로, Hamilton을 위해 개발한 사전 커밋 후크를 포함하는 이 GitHub 저장소를 살펴보겠습니다.\n\n# 사전 커밋 후크 사용 시작하기\n\n후크(Hooks)는 git 버전 관리 시스템에 직접 내장된 메커니즘입니다. .git/hooks 디렉토리 아래에서 프로젝트의 후크를 찾을 수 있습니다(기본적으로 숨겨질 수 있습니다). 일반적으로 \"사전 커밋 후크\"라고 불리지만, git 후크는 전체 git 수명 주기를 다룹니다. 예를 들어, 커밋 직후나 푸시하기 직전에 후크를 트리거할 수 있습니다. 또한, 후크는 어떤 프로그래밍 언어로도 작성할 수 있습니다. 흥미롭게도, Ruff 라이브러리는 성능 향상을 위해 많은 Python 기반 후크를 Rust로 재구현했습니다.\n\n코드 동작에 집중하는 소프트웨어 테스트와 비교해볼 때, 후크는 각 파일 저장 시 수행하는 가벼운 체크로 생각할 수 있습니다. 테스트가 코드베이스와 함께 변화하고 진화하는 것을 기대할 수 있는 반면, 코드 작성 가이드라인과 사전 커밋 후크는 고정될 가능성이 높습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 프로젝트 설정\n\n새로운 파이썬 프로젝트를 시작하거나 기존 프로젝트를 사용하는 것으로 가정해 봅시다. 디렉토리 /my-project 에서 작업하려면 pre-commit 후크를 사용하는 선호하는 방법은 pre-commit Python 라이브러리를 사용하는 것입니다. 다음 단계로 설정할 수 있습니다:\n\n- 프로젝트를 위해 git init으로 git 저장소를 만듭니다.\n- pre-commit 라이브러리를 설치하려면 pip install pre-commit을 사용합니다.\n- 저장소에 .pre-commit-config.yaml 파일을 추가합니다. 다음은 예시입니다:\n\n```yaml\n# .pre-commit-config.yaml\nrepos:\n  # 후크 정의가 있는 저장소\n  - repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v2.3.0 # 저장소의 릴리스 버전\n    hooks: # 이 프로젝트에 포함할 저장소의 후크 목록\n      - id: end-of-file-fixer\n      - id: trailing-whitespace\n      - id: check-yaml\n        args: [\"--unsafe\"] # `check-yaml`에 인수 추가\n\n    # 후크가 있는 다른 저장소 다운로드\n  - repo: https://github.com/psf/black\n    rev: 22.10.0\n    hooks:\n      - id: black\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n4. `pre-commit install` 명령어를 사용하여 훅을 설치하세요. 이 몤령어는 .pre-commit-config.yaml 파일에서 지시 사항을 읽고, .git/hooks/pre-commit 폴더 아래 로컬로 훅을 설치합니다.\n\n5. 커밋을 만들거나 `pre-commit run --all-files` 명령어를 수동으로 실행하여 훅을 작동시킬 수 있습니다.\n\n### 사용자 정의 pre-commit 훅 만들기\n\n커뮤니티가 유지보수하는 훅은 유연성을 제공하며 선호하는 코딩 가이드라인에 맞게 맞춤화할 수 있습니다. 이러한 훅은 대부분의 경우 98%의 요구를 충족해야 할 것입니다. 그러나 기본 제공 솔루션은 사용 중인 도구나 팀의 내부 규칙을 알지 못합니다. 예를 들어, 내부 구성을 유효성 검사하거나 프로젝트의 디렉토리 구조를 강제로 지정하는 것과 같은 조치를 취하려고 할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리 케이스에서는, 그들의 Hamilton 데이터 플로우 정의에 대한 Python 코드를 검증하기 위한 후크를 생성하려고 합니다. 우리의 후크 스크립트는 검증을 수행하기 위해 hamilton CLI 도구를 활용하여 간단한 코드 예제를 따라할 수 있게 됩니다.\n\n## 1. pre-commit 후크 저장소 설정\n\n프로젝트 설정 섹션에서 소개된 대로, pre-commit 후크는 .pre-commit-config.yaml에 있어야 하며, 프로젝트가 해당 후크를 참조하고 pre-commit install로 로컬에 설치할 수 있도록 공개 저장소에 존재해야 합니다.\n\n이전에는 프로젝트 디렉토리 /my-project에 있었으며 .pre-commit-config.yaml을 정의하고 후크를 설치했습니다. 이제, /my-hooks 디렉토리를 생성하여 사용자 정의 후크를 정의할 것입니다. 우리의 hamilton-pre-commit 저장소를 참조하여 일반적인 구조를 확인할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2024-07-09-Custompre-commithooksforsafercodechanges_1.png\" /\u003e\n\n## 2. 훅 로직 작성\n\nhooks/ 디렉토리 아래에는 해당 디렉토리를 파이썬 모듈로 찾을 수 있도록 하는 파일 **init**.py와 cli_command.py 스크립트가 있습니다. cli_command.py에는 하나의 main() 함수가 포함되어 있으며, 이 함수는 sys.argv에서 햄릴턴 CLI 명령의 목록을 읽습니다. 그런 다음, 예외 처리가 적용된 서브프로세스로 감싸져 하나씩 실행합니다.\n\n```js\n# hooks/cli_command.py\nimport sys\nimport json\nimport subprocess\n\nPASS = 0\nFAIL = 1\n\ndef main() -\u003e int:\n    \"\"\"햄릴턴 CLI를 사용하여 명령 목록 실행\"\"\"\n    commands = sys.argv[1:]\n\n    if len(commands) == 0:\n        return PASS\n\n    exit_code = PASS\n    for command in commands:\n        try:\n            args = command.split(\" \")\n            # `--json-out`를 삽입하여 적절한 stdout 구문 분석\n            args.insert(1, \"--json-out\")\n            result = subprocess.run(args, stdout=subprocess.PIPE, text=True)\n            response = json.loads(result.stdout)\n\n            if response[\"success\"] is False:\n                raise ValueError\n\n        except Exception:\n            exit_code |= FAIL\n\n    return exit_code\n\nif __name__ == \"__main__\":\n    raise SystemExit(main())\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n처음에는 exit_code를 PASS로 설정하지만, 어떤 예외나 실행되지 못한 명령이 있다면 exit_code를 FAIL로 설정합니다. main() 함수는 exit 코드를 SystemExit 예외에 반환합니다. pre-commit 훅이 성공하려면 모든 명령이 성공한 후에 PASS를 반환해야 합니다. PASS가 0이고 FAIL이 1인 것이 직관적이지 않을 수 있지만, 이 값들은 표준 시스템의 종료 코드를 가리킵니다.\n\n우리는 편의성을 위해 Python을 사용했지만, 이 간단한 논리는 Bash와 같은 가벼운 스크립팅 언어에서도 적용될 수 있습니다. pre-commit 팀이 유지 관리하는 후크를 방문하여 더 많은 예제를 확인할 수 있습니다.\n\n## 3. 후크 진입점 정의하기\n\n이제, 당신의 후크 저장소(/my-hooks)는 설치된 후에 사용할 수 있는 후크들과 그 실행 방법을 지정하는 .pre-commit-hooks.yaml 파일을 포함해야 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- id: cli-command\n  name: '`hamilton` CLI 명령 실행'\n  description: '이 후크는 `hamilton` CLI를 사용하여 명령을 실행합니다.'\n  entry: cli-command\n  language: python\n  types: [python]\n  stages: [pre-commit, pre-merge-commit, manual]\n  pass_filenames: false\n\n우리의 경우, id: cli-command 및 entry: cli-command를 설정하고 몇 가지 메타데이터를 추가하며 프로그래밍 언어는 Python으로 지정했습니다. 중요한 점은 파일 속성이 설정되어 있지 않아 후크가 커밋 당 한 번 실행되게하려면 파일: \"\\*.py\"를 설정해야합니다. 예를 들어 각 수정된 Python 파일에서 후크를 실행하도록 할 수 있습니다 (사용 가능한 옵션에 대해 알아보세요).\n\n지금까지 hooks/cli_command.py 아래 Python 스크립트를 만들고 .pre-commit-hooks.yaml에 cli-command 진입점이있는 후크를 추가했습니다. 그러나 Python 프로젝트 파일 pyproject.toml에서 명시적으로 두 가지를 연결해야합니다.\n\n[project.scripts]\ncli-command = \"hooks.cli_command:main\"\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 줄은 \"입력 지점 cli-command은 hooks.cli_command의 main 함수를 가리킵니다.\"라고 읽습니다.\n\n## 4. 로컬에서 훅을 테스트하는 방법\n\n먼저, 단위 테스트로 훅의 로직을 유효성 검사해야 합니다. 그러나 테스팅에 대해 자세히 다루지는 않겠습니다. 현재 hamilton-pre-commit 저장소에는 이 main Hamilton 저장소에서 테스트 된 기본 CLI가 없기 때문에 테스트가 없습니다. 테스트 예제용으로 공식으로 유지되는 pre-commit 훅을 방문할 수 있습니다.\n\n두 번째로, .pre-commit-hooks.yaml 및 입력 지점이 올바르게 구성되었는지 확인하기 위해 로컬에서 pre-commit 훅을 시도해야 합니다. 이상적으로는 변경 사항을 테스트하기 위해 훅을 실행할 때마다 커밋을 추가하는 것을 피하고 싶습니다. pre-commit 라이브러리는 이 프로세스를 용이하게 하기 위한 유틸리티를 제공하지만 pre-commit GitHub 문제에서 자세히 설명 된 몇 가지 수동 단계가 필요합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 훅을 테스트하고 싶은 디렉토리 /my-project로 이동하세요.\n- pre-commit try-repo ../LOCAL/PATH/TO/my-hooks 명령을 실행하고, 로컬 초기화 메시지가 표시되어야 합니다.\n\n![이미지](/TIL/assets/img/2024-07-09-Custompre-commithooksforsafercodechanges_2.png)\n\n한 가지 제한 사항은이 명령을 통해 훅에 직접 매개변수를 전달할 수 없다는 것입니다.\n\n3. Using config: 하위의 구성을 복사하여 로컬 파일에 추가하고 args 섹션을 추가하세요. 우리는 .local-pre-commit-config.yaml를 생성했지만 원하는 이름을 사용할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```yaml\nrepos:\n  - repo: ../../dagworks/hamilton-pre-commit\n    rev: e4b77a499ba0ff3446a86ebbe4c2cbca82eb54f8\n    hooks:\n      - id: cli-command\n        args: [hamilton build my_func2.py]\n```\n\n4. `pre-commit run --config .local-pre-commit-config.yaml --all-files` 명령어를 사용하여 로컬 후크를 실행하세요. `--all-files` 플래그를 사용하면 현재 스테이징된 파일뿐만 아니라 저장소의 모든 파일에 후크가 적용됩니다.\n\n![Custom Pre-Commit Hooks](/TIL/assets/img/2024-07-09-Custompre-commithooksforsafercodechanges_3.png)\n\n## 5. Pre-Commit 후크 공개하기\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n거의 다 왔어요! 동작하는 후크 스크립트를 테스트하고 git 저장소에 패키징했군요. 이제 그것을 온라인으로 사용할 수 있도록 만들어야 합니다. GitHub 호스팅 프로젝트를 위한 단계를 보여드리겠지만, 당신의 pre-commit 후크는 git clone을 통해 접근 가능한 어디에나 저장할 수 있어요.\n\n- GitHub 저장소에서 Releases 섹션으로 이동하세요\n\n![image](/TIL/assets/img/2024-07-09-Custompre-commithooksforsafercodechanges_4.png)\n\n2. 새 릴리스 초안 작성을 클릭하세요\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/TIL/assets/img/2024-07-09-Custompre-commithooksforsafercodechanges_5.png)\n\n3. 새 릴리스 페이지에서는 버전 태그, 제목 및 설명을 추가해야 합니다. 첫 번째 릴리스인 경우, GitHub에서 권장하는 시맨틱 버전을 따르기 위해 태그를 v0.1.0으로 설정하는 것이 좋습니다.\n\n변경 사항을 만들고 실험 버전을 배포하려는 경우 버전을 v0.1.1-rc로 설정하고 \"릴리스 후보\"로 표시하려면 확인란을 사용하세요.\n\n![이미지](/TIL/assets/img/2024-07-09-Custompre-commithooksforsafercodechanges_6.png)\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n.pre-commit-config.yaml 파일에서 rev 값은 설정한 버전 태그와 일치해야 합니다.\n\n```js\nrepos:\n- repo: https://github.com/DAGWorks-Inc/hamilton-pre-commit\n  rev: v0.1.3rc\n  hooks:\n    - id: cli-command\n      # ...\n```\n\n# 마무리 맺기\n\n축하합니다! 이 글을 읽어나가셨군요! 이제 프로젝트에서 코드 품질을 향상시키기 위해 pre-commit 훅을 사용할 수 있게 되었습니다. 그 내부 원리를 이해했으니 이제 여러분만의 훅을 작성할 수 있습니다!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n바퀴를 다시 발명하기 전에 커뮤니티에서 유지보수하는 많은 후크들을 확인하시기 바랍니다: [https://pre-commit.com/hooks.html](https://pre-commit.com/hooks.html)\n\n파이썬에서 데이터플로우를 작성하기 위해 Hamilton 라이브러리를 확인해보세요!\nLinkedIn에서 저를 찾아보고 DAGWorks 블로그에서 더 많은 포스트를 읽어보세요\n","ogImage":{"url":"/assets/img/2024-07-09-Custompre-commithooksforsafercodechanges_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-Custompre-commithooksforsafercodechanges_0.png","tag":["Tech"],"readingTime":13}],"page":"31","totalPageCount":50,"totalPageGroupCount":3,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"31"},"buildId":"X4OrKfmLtU3-3BijwfHe6","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>