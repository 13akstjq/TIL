<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>TIL</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//posts/22" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="TIL" data-gatsby-head="true"/><meta property="og:title" content="TIL" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//posts/22" data-gatsby-head="true"/><meta name="twitter:title" content="TIL" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/7978fe7362f7d4c9.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/7978fe7362f7d4c9.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/873-eb138c3217d71553.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/posts/%5Bpage%5D-de1dc5579188f9be.js" defer=""></script><script src="/TIL/_next/static/jKAIrnIuHBv4ZHjiQbX6i/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/jKAIrnIuHBv4ZHjiQbX6i/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="빠른 푸리에 변환을 이용한 주식 시장 신호 분석 방법" href="/TIL/post/2024-07-09-StockMarketSignalAnalysisUsingFastFourierTransform"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="빠른 푸리에 변환을 이용한 주식 시장 신호 분석 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-09-StockMarketSignalAnalysisUsingFastFourierTransform_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="빠른 푸리에 변환을 이용한 주식 시장 신호 분석 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">빠른 푸리에 변환을 이용한 주식 시장 신호 분석 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 9, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="NanoLlava 가장 작은 시각적 언어란" href="/TIL/post/2024-07-09-NanoLlavaisthesmallestVisualLanguage"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="NanoLlava 가장 작은 시각적 언어란" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-09-NanoLlavaisthesmallestVisualLanguage_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="NanoLlava 가장 작은 시각적 언어란" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">NanoLlava 가장 작은 시각적 언어란</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 9, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="뉴럴 네트워크 손실 함수 이해 및 구현 방법 기초부터" href="/TIL/post/2024-07-09-UnderstandingImplementingDifferentLossFunctionsofNeuralNetworksfromScratch"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="뉴럴 네트워크 손실 함수 이해 및 구현 방법 기초부터" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-09-UnderstandingImplementingDifferentLossFunctionsofNeuralNetworksfromScratch_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="뉴럴 네트워크 손실 함수 이해 및 구현 방법 기초부터" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">뉴럴 네트워크 손실 함수 이해 및 구현 방법 기초부터</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 9, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Mojo, Python보다 90,000배 빠르다 드디어 오픈소스 공개 출시 즉시 17,000 스타 돌파" href="/TIL/post/2024-07-09-Mojo90000TimesFasterThanPythonFinallyOpenSourcedJustLaunchedAlreadySurpassing17000Stars"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Mojo, Python보다 90,000배 빠르다 드디어 오픈소스 공개 출시 즉시 17,000 스타 돌파" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-09-Mojo90000TimesFasterThanPythonFinallyOpenSourcedJustLaunchedAlreadySurpassing17000Stars_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Mojo, Python보다 90,000배 빠르다 드디어 오픈소스 공개 출시 즉시 17,000 스타 돌파" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Mojo, Python보다 90,000배 빠르다 드디어 오픈소스 공개 출시 즉시 17,000 스타 돌파</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 9, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="PyFilesystem2 OpenCV로 캡처한 프레임을 메모리 파일 시스템에 저장하는 방법" href="/TIL/post/2024-07-09-PyFilesystem2StoringFramesCapturedbyOpenCVinanIn-MemoryFilesystem"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="PyFilesystem2 OpenCV로 캡처한 프레임을 메모리 파일 시스템에 저장하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-09-PyFilesystem2StoringFramesCapturedbyOpenCVinanIn-MemoryFilesystem_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="PyFilesystem2 OpenCV로 캡처한 프레임을 메모리 파일 시스템에 저장하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">PyFilesystem2 OpenCV로 캡처한 프레임을 메모리 파일 시스템에 저장하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 9, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="주식 거래에서 가장 인기 있는 10가지 금융 지표" href="/TIL/post/2024-07-09-TheMostPopularFinancialMetricsinStockTrading"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="주식 거래에서 가장 인기 있는 10가지 금융 지표" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/no-image.jpg"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="주식 거래에서 가장 인기 있는 10가지 금융 지표" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">주식 거래에서 가장 인기 있는 10가지 금융 지표</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 9, 2024</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="NiceGUI를 만나보세요 곧 여러분의 최애 파이썬 UI 라이브러리가 될 이유" href="/TIL/post/2024-07-09-MeettheNiceGUIYourSoon-to-beFavoritePythonUILibrary"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="NiceGUI를 만나보세요 곧 여러분의 최애 파이썬 UI 라이브러리가 될 이유" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-09-MeettheNiceGUIYourSoon-to-beFavoritePythonUILibrary_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="NiceGUI를 만나보세요 곧 여러분의 최애 파이썬 UI 라이브러리가 될 이유" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">NiceGUI를 만나보세요 곧 여러분의 최애 파이썬 UI 라이브러리가 될 이유</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 9, 2024</span><span class="PostList_reading_time__6CBMQ">14<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="GRASP 원칙 견고하고 유지보수 가능한 코드의 기초" href="/TIL/post/2024-07-09-GRASPPrinciplesTheFoundationofRobustandMaintainableCode"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="GRASP 원칙 견고하고 유지보수 가능한 코드의 기초" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-09-GRASPPrinciplesTheFoundationofRobustandMaintainableCode_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="GRASP 원칙 견고하고 유지보수 가능한 코드의 기초" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">GRASP 원칙 견고하고 유지보수 가능한 코드의 기초</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 9, 2024</span><span class="PostList_reading_time__6CBMQ">28<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="2024년, 수학자가 대세가 된 이유" href="/TIL/post/2024-07-09-TheEraoftheMathematicianHasArrived"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="2024년, 수학자가 대세가 된 이유" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-09-TheEraoftheMathematicianHasArrived_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="2024년, 수학자가 대세가 된 이유" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">2024년, 수학자가 대세가 된 이유</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 9, 2024</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="환상적인 네트워크 그래프를 위한 최고의 15가지 Python 도구" href="/TIL/post/2024-07-09-Top15PythonToolsforStunningNetworkGraphs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="환상적인 네트워크 그래프를 위한 최고의 15가지 Python 도구" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-09-Top15PythonToolsforStunningNetworkGraphs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="환상적인 네트워크 그래프를 위한 최고의 15가지 Python 도구" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">환상적인 네트워크 그래프를 위한 최고의 15가지 Python 도구</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 9, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/TIL/posts/21">21</a><a class="link" href="/TIL/posts/22">22</a><a class="link" href="/TIL/posts/23">23</a><a class="link" href="/TIL/posts/24">24</a><a class="link" href="/TIL/posts/25">25</a><a class="link" href="/TIL/posts/26">26</a><a class="link" href="/TIL/posts/27">27</a><a class="link" href="/TIL/posts/28">28</a><a class="link" href="/TIL/posts/29">29</a><a class="link" href="/TIL/posts/30">30</a><a class="link" href="/TIL/posts/31">31</a><a class="link" href="/TIL/posts/32">32</a><a class="link" href="/TIL/posts/33">33</a><a class="link" href="/TIL/posts/34">34</a></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"빠른 푸리에 변환을 이용한 주식 시장 신호 분석 방법","description":"","date":"2024-07-09 15:03","slug":"2024-07-09-StockMarketSignalAnalysisUsingFastFourierTransform","content":"\n# 소개\n\n금융 시장은 본질적으로 소음이 많고 예측할 수 없어서, 수익성 있는 기회를 식별하고 활용하려는 트레이더와 투자자에게 상당한 어려움을 줍니다.\n\n이 복잡성을 해결하기 위해 현대 트레이더들은 수학적 및 통계적 기술을 활용하여 소음을 걸러내고 데이터의 기저 주기/트렌드를 더 명확히 이해하기 위한 다양한 기법을 사용합니다. FFT(Fast Fourier Transform) 알고리즘은 이러한 강력한 도구 중 하나로, 어떤 신호/파형을 주파수가 변하는 사인 성분들의 합으로 표현하는 데 사용되는 알고리즘입니다. 따라서 시간 영역에서 주파수 영역으로 신호를 변환합니다.\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*e-_z80BnbHWyFTfRLblJ_w.gif)\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 기사에서 논의하는 FFT 알고리즘은 신호 처리를 사용하여 가장 중요한 주파수를 감지하고 데이터에서 잡음을 제거합니다.\n\n# FFT를 사용하는 이유?\n\n## 주기와 패턴 감지\n\n주식 가격이나 거래량과 같은 금융 시계열은 다양한 경제 주기, 계절성 또는 투자자 행동으로 인해 주기적인 패턴을 나타내는 경우가 많습니다. 푸리에 변환은 이러한 주기와 해당 주파수를 식별하는 데 도움이 됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 소음 필터링\n\n금융 데이터는 종종 무작위 변동으로 인해 소음이 발생합니다. 데이터를 주파수 영역으로 변환하여 분석가들은 고주파 소음을 제거하여 중요한 저주파수 트렌드에 집중할 수 있습니다.\n\n## 예측 모델링\n\n주파수를 식별함으로써, 분석가들은 역사적인 패턴을 기반으로 미래 가격 변동이나 트렌드에 대한 예측을 할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 기계 학습을 위한 기능 추출\n\nFourier 변환에서 얻은 주파수 구성 요소는 머신 러닝 모델에서 특징으로 사용되어 예측의 정확도를 향상시킬 수 있습니다.\n\n# 코드 및 단계별 분석\n\n## 노트북 설정 및 주식 데이터 수집\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n필요한 기본 주식 데이터 수집 및 데이터 프레임 조작을 위한 라이브러리 가져오기가 첫 번째 단계입니다.\n\n또한, 분석 기간을 1년으로 설정하고 분석할 주식은 Tata Consultancy Services (TCS)입니다. 필요한 주식의 OLHCAV 데이터는 'df'라는 데이터 프레임에 저장되어 있습니다.\n\n```js\n#라이브러리 가져오기\nimport pandas as pd\nfrom pandas_datareader import data as pdr\nimport numpy as np\nimport math\nimport datetime\nimport scipy.stats as stats\nimport matplotlib.pyplot as plt\nimport yfinance as yfin\nyfin.pdr_override()\n\n# 분석 기간 설정\nend_date = datetime.datetime.now()\nstart_date = end_date - datetime.timedelta(365)\nticker = 'TCS'\n\ndf = pdr.get_data_yahoo(ticker + '.NS', start = start_date, end = end_date)\n```\n\n## FFT의 적용\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nnp.fft.fft()을 사용하여 푸리에 변환을 수행할 것이며, np.fft.fftfreq()를 사용하여 주파수를 얻을 것입니다. 가장 중요한 주파수가 나타나는 때를 나타내기 위해 진폭 대 주기를 그래프로 그려볼 수 있습니다.\n\n```js\nfft_result = np.fft.fft(df['Close'])\nfrequencies = np.fft.fftfreq(len(fft_result), d=1)  # assuming daily data, d=1\nmagnitude = np.abs(fft_result)\nperiods = 1 / frequencies\n```\n\n## 가격 및 주파수 영역 표현 시각화\n\n아래의 주파수 플롯은 시계열 내에서 우세한 주파수를 강조합니다. 이러한 주파수는 역 FFT를 수행하거나 원래 시계열을 다시 만들거나 잡음을 줄인 버전을 생성하는 데 사용될 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 가격의 간단한 시각화\nplt.figure(figsize=(10, 8))\nplt.subplot(2, 1, 1)\nplt.plot(df.index, df['Close'])\nplt.title('TCS 시계열')\nplt.xlabel('날짜')\nplt.ylabel('가격')\n\n# 주파수 도메인 표현\nplt.subplot(2, 1, 2)\nplt.plot(periods, magnitude)\nplt.title('TCS의 FFT')\nplt.xlabel('기간 (일)')\nplt.ylabel('크기')\nplt.xlim(0, max(periods[1:]))  # 중요한 주기를 보기 위한 x-축 제한 (큰 주기 무시)\nplt.ylim(0, max(magnitude[1:]) * 1.1)  # 제로 주파수 구성요소 무시\n\nplt.tight_layout()\nplt.show()\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-09-StockMarketSignalAnalysisUsingFastFourierTransform_0.png\" /\u003e\n\n하지만, 이러한 우세 주파수의 중요성은 단순히 시계열을 재구성하는 데서 그치지 않습니다. 이들은 시계열 구조에 영향을 미치는 주요 경제 보고서나 거시경제 사건과 관련될 수 있습니다.\n\n## 원래 주식 시장 데이터 복구하기\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nnp.fft.ifft() 함수를 사용하여 원래의 시계열을 복원할 수 있습니다. 이 함수는 fft_results를 역변환합니다. 아래 그래프에서 볼 수 있듯이 완벽하게 재구성되었습니다.\n\n```js\nrecovered = np.fft.ifft(fft_result);\nplt.figure((figsize = (14, 6)));\nplt.plot(df.index, df[\"Close\"], (label = \"Original\"));\nplt.plot(df.index, recovered, (label = \"Recovered\"));\nplt.title(\"TCS 시계열: FFT 역변환\");\nplt.xlabel(\"날짜\");\nplt.ylabel(\"가격\");\nplt.legend();\nplt.show();\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-09-StockMarketSignalAnalysisUsingFastFourierTransform_1.png\" /\u003e\n\n## 주요 주파수를 갖는 파형의 재구성\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이것은 상위 25개 FFT 주파수만 사용하여 재구성된 신호를 생성합니다. 이것은 데이터의 노이즈 제거를 의미합니다.\n\n```js\ndominant_periods = pd.Series(periods, (index = magnitude)).nlargest(25);\ndominant_periods.to_frame(\"주기 (일)\");\ntop_periods = dominant_periods.index;\ntop_fft_result = fft_result.copy();\ntop_fft_result[np.abs(frequencies) \u003e 1 / top_periods.min()] = 0;\ntop_recovered = np.fft.ifft(top_fft_result);\n\nplt.figure((figsize = (14, 6)));\nplt.plot(df.index, df[\"Close\"], (label = \"원본\"));\nplt.plot(df.index, top_recovered, (label = \"복원된\"));\nplt.title(\"TCS 시계열: FFT 역변환\");\nplt.xlabel(\"날짜\");\nplt.ylabel(\"가격\");\nplt.legend();\nplt.show();\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-09-StockMarketSignalAnalysisUsingFastFourierTransform_2.png\" /\u003e\n\n# 결론\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 문서에서 설명한 알고리즘은 산업 전문가들이 사용하는 분석을 지나치게 단순화한 것입니다. 성능을 개선하기 위해 일반적으로 매일 모델을 조정합니다.\n\n도움이 되었기를 바라며, 여기에 GitHub 파일을 찾을 수 있습니다: [https://github.com/karantha-kur/Signal-Analysis-Using-FFT/tree/main](https://github.com/karantha-kur/Signal-Analysis-Using-FFT/tree/main)\n","ogImage":{"url":"/assets/img/2024-07-09-StockMarketSignalAnalysisUsingFastFourierTransform_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-StockMarketSignalAnalysisUsingFastFourierTransform_0.png","tag":["Tech"],"readingTime":7},{"title":"NanoLlava 가장 작은 시각적 언어란","description":"","date":"2024-07-09 15:02","slug":"2024-07-09-NanoLlavaisthesmallestVisualLanguage","content":"\n![이미지](/TIL/assets/img/2024-07-09-NanoLlavaisthesmallestVisualLanguage_0.png)\n\n요즘 뉴스에는 시각 언어 모델이 많이 등장하고 있어요. 지난 몇 일간의 발표 속에 믿기 어려운 소식이 많았는데, 이미지를 통해 대화를 하려면 돈을 내야 할까요?\n\nGPT-4o, Gemini-flash, PaliGemma, Copilot+PC… 이 모든 것이 1주일 안에 나왔어요!\n\n아무도 알지 못했지만 Abetlen이 GGUF 버전의 가장 작은 언어 모델인 TINIEST을 출시했다는 사실이죠.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n전체 모델은 NanoLlava를 만나실 수 있는 컴퓨터의 2GB 하드 디스크 공간에 저장됩니다.\n\n이 기사에서는 모델을 양자화하여 어떤 컴퓨터에서도 실행하는 방법을 배우게 될 것입니다. 전용 GPU 없이도 작업을 완료할 수 있습니다.\n\n```js\n# 목차\n---\n작고 강력한 모델\n모델을 시각적으로 만드는 것은 무엇인가요?\nPC에서 NanoLlava\n - 환경 설정\nInference call - textual\nStreamlit Application\n```\n\n# 작고 강력한\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n나노라바는 Sub 1B 비전-언어 모델입니다. 네, 정확히 들으셨어요! GPT-4o 수행능력을 기대하지 마세요 (그렇게 할 수는 있지만, ...혹은 소유중인 경우에만 가능합니다.)\n","ogImage":{"url":"/assets/img/2024-07-09-NanoLlavaisthesmallestVisualLanguage_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-NanoLlavaisthesmallestVisualLanguage_0.png","tag":["Tech"],"readingTime":2},{"title":"뉴럴 네트워크 손실 함수 이해 및 구현 방법 기초부터","description":"","date":"2024-07-09 15:01","slug":"2024-07-09-UnderstandingImplementingDifferentLossFunctionsofNeuralNetworksfromScratch","content":"\n\u003cimg src=\"/TIL/assets/img/2024-07-09-UnderstandingImplementingDifferentLossFunctionsofNeuralNetworksfromScratch_0.png\" /\u003e\n\n신경망의 매혹적인 세계에서 손실 함수는 훈련 과정을 정확한 예측으로 이끄는 안내 나침반 같은 역할을 합니다. 이러한 함수들을 숙달하는 것은 딥러닝에 진지하게 임하는 사람들에게 중요합니다. 왜냐하면 손실 함수를 선택하는 것은 모델의 성능에 상당한 영향을 미칠 수 있기 때문입니다. 신진 데이터 과학자든 경험 많은 기계 학습 엔지니어든, 이 블로그는 다양한 손실 함수를 해독하고 그 목적을 설명하며, 처음부터 구현하는 방법을 보여줍니다.\n\n자, 이러한 수학적 도구가 어떻게 신경망 훈련을 변화시킬 수 있는지 알아봅시다!\n\n그래서, 우리 마음에 떠오르는 첫 번째 질문은 '손실 함수란 무엇인가요?'입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/TIL/assets/img/2024-07-09-UnderstandingImplementingDifferentLossFunctionsofNeuralNetworksfromScratch_1.png)\n\n핵심적으로, 손실 함수(J로 표시됨)는 두 개의 매개변수를 입력으로 받는 수학 함수입니다:\n\n- 예측된 출력\n- 실제 출력\n\n이 함수는 모델의 예측 값과 모델이 생성해야 하는 실제 값과 비교하여 모델이 얼마나 잘 작동하는지를 평가하기 위해 사용됩니다. 예측 값이 실제 값과 크게 다를 경우 손실 값은 크게 나타납니다. 반면, 낮은 손실 값은 두 값이 거의 유사할 때 발생합니다. 따라서 효율적인 손실 함수를 사용하여 모델을 올바르게 훈련시키는 것이 중요합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n높은 손실 값은 모델의 예측이 부정확하다는 것을 시사하며, 네트워크를 크게 재조정해야 한다는 것을 의미합니다. 반면에 낮은 손실 값은 모델이 효과적으로 작동하고 있으며, 가중치를 매우 약간만 조정해야 한다는 것을 나타냅니다.\n\n이러한 시나리오는 새로운 요리법을 만드는 것과 유사합니다. 요리물이 실패하면 \"손실\"이 높아지고, 요리사는 다음에 요리물을 개선하기 위해 재료나 조리 방법에 상당한 변화를 해야 합니다. 그러나 요리물이 잘 나오면 이미 효과적인 레시피와 기술이기 때문에 필요한 경우에는 작은 조정만 필요합니다. 이 조정은 향후 블로그에서 논의할 하이퍼파라미터를 조정함으로써 수행할 수 있습니다. 이제 손실 함수가 무엇인지 이해했으므로, 다음으로 궁금한 것은 어떤 종류의 손실 함수가 있고 이를 어떻게 구현하는지에 대한 것입니다.\n\n신경망에서의 손실 함수 유형\n\n회귀 손실 함수\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 평균 제곱 오차 (MSE)\n\nMSE는 회귀 문제에 사용되는 가장 인기 있는 손실 함수 중 하나입니다. 이는 예측 값과 실제 값 사이의 오차의 제곱의 평균을 측정합니다. MSE는 이상치에 민감합니다.\n\n사용 사례: MSE는 주택 가격이나 온도와 같은 연속적인 값을 예측하는 회귀 문제에서 흔히 사용됩니다.\n\n수학적 공식:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 Markdown 형식으로 표시된 내용입니다.\n\n![이미지](/TIL/assets/img/2024-07-09-UnderstandingImplementingDifferentLossFunctionsofNeuralNetworksfromScratch_2.png)\n\nwhere,\n\n![이미지](/TIL/assets/img/2024-07-09-UnderstandingImplementingDifferentLossFunctionsofNeuralNetworksfromScratch_3.png)\n\n코드 구현:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\ndef mean_squared_error(y_true, y_predicted):\n    total_error = 0\n    for yt, yp in zip(y_true, y_predicted):\n        total_error += (yt-yp)**2\n    mse = total_error/len(y_true)\n    return mse\n```\n\n2. Mean Absolute Error (MAE)\n\nMAE는 예측 값과 실제 값 사이의 절대 오차의 평균을 측정합니다. MSE보다 이상치에 민감하지 않습니다.\n\n사용 사례: MAE는 중앙값 주택 가격을 예측하는 경우와 같이, 이상치에 민감하지 않은 손실 함수를 원할 때 사용됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n수학 공식:\n\n![수식](/TIL/assets/img/2024-07-09-UnderstandingImplementingDifferentLossFunctionsofNeuralNetworksfromScratch_4.png)\n\n코드 구현:\n\n```python\ndef mean_abs_error(y_predicted, y_true):\n    total_error = 0\n    for yp, yt in zip(y_predicted, y_true):\n        total_error += abs(yp - yt)\n    mae = total_error/len(y_predicted)\n    return mae\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n3. 휴버 손실\n\n휴버 손실은 MSE와 MAE의 우수한 특성을 결합하여, MSE보다 이상치에 민감하지 않고 MAE보다 원점 주변에서 부드럽습니다.\n\n사용 사례: 휴버 손실은 이상치의 영향을 줄이고 손실 함수를 미분 가능하게 유지하고자 하는 견고한 회귀 문제에서 자주 사용됩니다.\n\n수학적 공식:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Image](/TIL/assets/img/2024-07-09-UnderstandingImplementingDifferentLossFunctionsofNeuralNetworksfromScratch_5.png)\n\n코드 구현:\n\n```python\ndef huber_loss(y_true, y_pred, delta=1.0):\n    n = len(y_true)\n    loss = 0\n    for i in range(n):\n        diff = y_true[i] - y_pred[i]\n        if abs(diff) \u003c= delta:\n            loss += 0.5 * diff ** 2\n        else:\n            loss += delta * (abs(diff) - 0.5 * delta)\n    return loss / n\n```\n\n분류 손실 함수\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n1. Binary Cross-Entropy 손실\n\nBinary Cross-Entropy 손실은 이진 분류 작업에 사용됩니다. 출력이 0과 1 사이의 확률 값인 분류 모델의 성능을 측정합니다.\n\n사용 사례: 스팸 감지나 사기 탐지와 같은 이진 분류 문제에 이 손실 함수가 이상적입니다.\n\n수학적 공식:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이미지 태그를 Markdown 형식으로 변경하세요.\n\n![UnderstandingImplementingDifferentLossFunctionsofNeuralNetworksfromScratch](/TIL/assets/img/2024-07-09-UnderstandingImplementingDifferentLossFunctionsofNeuralNetworksfromScratch_6.png)\n\n코드 구현:\n\n```python\nimport math\n\ndef binary_crossentropy(y_true, y_pred):\n    n = len(y_true)\n    loss = 0\n    for i in range(n):\n        loss += y_true[i] * math.log(y_pred[i]) + (1 - y_true[i]) * math.log(1 - y_pred[i])\n    return -loss / n\n```\n\n2. 범주형 Cross-Entropy Loss\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n범주형 크로스 엔트로피 손실은 다중 클래스 분류 작업에 사용됩니다. 이는 여러 클래스에 대한 확률 분포인 분류 모델의 성능을 측정합니다.\n\n활용 사례: 이 손실 함수는 숫자 인식(MNIST)이나 물체 검출과 같은 다중 클래스 분류 문제에 적합합니다.\n\n수학적 공식:\n\n![수식](/TIL/assets/img/2024-07-09-UnderstandingImplementingDifferentLossFunctionsofNeuralNetworksfromScratch_7.png)\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n구현된 코드:\n\n```js\nimport math\n\ndef categorical_crossentropy(y_true, y_pred):\n    n = len(y_true)\n    c = len(y_true[0])\n    loss = 0\n    for i in range(n):\n        for j in range(c):\n            if y_true[i][j] == 1:\n                loss += y_true[i][j] * math.log(y_pred[i][j])\n    return -loss / n\n```\n\n3. Sparse Categorical Cross-Entropy Loss\n\nSparse Categorical Cross-Entropy는 목표 레이블이 원-핫 인코딩된 벡터가 아닌 정수일 때 사용됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n사용 사례: 이 손실 함수는 타겟 레이블이 one-hot 벡터가 아닌 정수 레이블 형태인 다중 클래스 분류 문제에서 사용됩니다.\n\n수학적 공식:\n\n![이미지](/TIL/assets/img/2024-07-09-UnderstandingImplementingDifferentLossFunctionsofNeuralNetworksfromScratch_8.png)\n\n코드 구현:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ndef sparse_categorical_cross_entropy(y_true, y_pred):\n    n = len(y_true)\n    loss = 0\n    for i in range(n):\n        loss += y_true[i] * math.log(y_pred[i]))\n    return -loss / n\n```\n\n거기에는 몇 가지 더 특별한 손실 함수가 있어요:\n\n- Kullback-Leibler Divergence\n- Cosine Similarity Loss\n- Dice Loss\n- Quantile Loss\n- Hinge Loss\n\n이제 손실 함수에 대해 간결하고 명확하게 이해하셨기를 바랍니다. 다가오는 블로그에서는 특별한 손실 함수, 사용 사례 및 구현에 대해 논의할 예정이에요. 컴퓨터 비전과 딥 러닝에 관한 더 많은 기사를 위해 블로그를 팔로우해 주세요. 궁금한 사항이 있거나 특정 부분에 대한 추가 정보가 필요하면 언제든지 의견을 남겨주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마크다운 형식으로 표 태그를 변경하세요: Linkedin\n","ogImage":{"url":"/assets/img/2024-07-09-UnderstandingImplementingDifferentLossFunctionsofNeuralNetworksfromScratch_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-UnderstandingImplementingDifferentLossFunctionsofNeuralNetworksfromScratch_0.png","tag":["Tech"],"readingTime":10},{"title":"Mojo, Python보다 90,000배 빠르다 드디어 오픈소스 공개 출시 즉시 17,000 스타 돌파","description":"","date":"2024-07-09 15:00","slug":"2024-07-09-Mojo90000TimesFasterThanPythonFinallyOpenSourcedJustLaunchedAlreadySurpassing17000Stars","content":"\n2024년 3월 29일, Modular Inc.은 Mojo의 핵심 구성 요소를 오픈 소스화한다고 발표했습니다.\n\nMojo는 작년 8월에 공식적으로 출시된 인공 지능 소프트웨어를 작성하기 위해 특별히 설계된 프로그래밍 언어입니다. 그 이후로 17만 5천 명 이상의 개발자와 5천 개 이상의 기관이 모아졌습니다.\n\n인공 지능 모델은 종종 여러 프로그래밍 언어로 작성됩니다. 개발자는 일반적으로 가장 간단한 신경망의 일부를 구현하기 위해 Python을 사용합니다. Python은 배우기 쉽지만 비교적 느린 속도 때문에 사용됩니다. 남은 코드는 보통 C++로 작성되며, C++은 더 빠르지만 학습하기에 복잡합니다.\n\nModular은 Mojo를 더 편리한 대안으로 위치시킵니다. Python과 유사한 쉬운 구문을 제공하지만 수천 배 더 빠른 실행 속도를 갖도록 하며, 이를 통해 개발자들은 C++과 같은 복잡한 언어를 배우지 않고도 빠른 AI 모델을 작성할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2024-07-09-Mojo90000TimesFasterThanPythonFinallyOpenSourcedJustLaunchedAlreadySurpassing17000Stars_0.png\" /\u003e\n\n지난해 Mojo가 소개됐을 때, 일부 개발자들은 그 등장에 들뜬 기대를 표현했습니다. 그러나 Chris Lattner은 디스코드에서 오픈 소스 날짜에 대해 물어볼 때 \"알았다면 말했을 거야.\" 라고 말했습니다. 약 1년 동안 많은 개발자들이 관찰하며 의심의 태도를 보였습니다:\n","ogImage":{"url":"/assets/img/2024-07-09-Mojo90000TimesFasterThanPythonFinallyOpenSourcedJustLaunchedAlreadySurpassing17000Stars_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-Mojo90000TimesFasterThanPythonFinallyOpenSourcedJustLaunchedAlreadySurpassing17000Stars_0.png","tag":["Tech"],"readingTime":2},{"title":"PyFilesystem2 OpenCV로 캡처한 프레임을 메모리 파일 시스템에 저장하는 방법","description":"","date":"2024-07-09 14:59","slug":"2024-07-09-PyFilesystem2StoringFramesCapturedbyOpenCVinanIn-MemoryFilesystem","content":"\n\u003cimg src=\"/TIL/assets/img/2024-07-09-PyFilesystem2StoringFramesCapturedbyOpenCVinanIn-MemoryFilesystem_0.png\" /\u003e\n\n소개\nPyFilesystem2은 Python에서 파일 시스템을 다루는 강력하고 유연한 라이브러리로, 개발자들이 파일과 디렉토리를 쉽게 관리할 수 있습니다. PyFilesystem2의 매력적인 기능 중 하나는 인메모리 파일 시스템을 지원한다는 점인데, 이는 테스트, 데이터 캐싱, 빠른 처리 등 다양한 목적에 유용할 수 있습니다. 본 문서에서는 OpenCV로 캡처된 비디오 프레임을 인메모리 파일 시스템에 저장하는 방법을 알아보겠습니다.\n\n필수 조건\n시작하려면 PyFilesystem2 및 OpenCV 두 라이브러리를 설치해야 합니다. 다음 명령어로 pip를 사용하여 이 라이브러리들을 설치할 수 있습니다:\n\n인메모리 파일 시스템 생성\n먼저 인메모리 파일 시스템을 생성해야 합니다. 이 작업은 PyFilesystem2 라이브러리의 `MemoryFS` 클래스를 사용하여 수행할 수 있습니다. 아래는 인메모리 파일 시스템을 생성하고 그 안에 간단한 파일을 저장하는 예제입니다:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nOpenCV을 사용하여 비디오 프레임 캡처하기\n비디오 프레임을 캡처하기 위해 OpenCV 라이브러리를 사용할 것입니다. OpenCV는 이미지 및 비디오 처리에 사용되는 오픈 소스 라이브러리입니다. 카메라 또는 비디오 파일에서 비디오 프레임을 캡처하는 방법은 다음과 같습니다:\n\n인메모리 파일 시스템에 프레임 저장하기\n이제 비디오 프레임을 캡처할 수 있으므로, 이러한 프레임을 인메모리 파일 시스템에 저장해야 합니다. 이를 위해 먼저 프레임을 이미지 형식 (예: PNG)으로 변환한 다음 파일 시스템에 저장합니다.\n\n결론\n본 문서에서는 PyFilesystem2를 사용하여 OpenCV로 캡처한 비디오 프레임을 인메모리 파일 시스템에 저장하는 방법을 살펴보았습니다. 이 접근 방식을 사용하면 실시간 및 임시 처리 작업에 매우 유용한 비디오 프레임을 빠르게 임시로 저장할 수 있습니다. PyFilesystem2는 다양한 유형의 파일 시스템을 쉽게 관리하고 프로젝트에서 활용할 수 있는 강력한 도구입니다.\n","ogImage":{"url":"/assets/img/2024-07-09-PyFilesystem2StoringFramesCapturedbyOpenCVinanIn-MemoryFilesystem_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-PyFilesystem2StoringFramesCapturedbyOpenCVinanIn-MemoryFilesystem_0.png","tag":["Tech"],"readingTime":2},{"title":"주식 거래에서 가장 인기 있는 10가지 금융 지표","description":"","date":"2024-07-09 14:59","slug":"2024-07-09-TheMostPopularFinancialMetricsinStockTrading","content":"\n\n주식 거래에서 사용되는 금융 지표는 많지만, 가장 인기 있는 일부는 다음과 같습니다:\n\n- 주당 순이익 (EPS): 주당 순이익은 기업의 이익 중 주당 주식에 배정된 부분입니다. 기업의 수익성과 성장 잠재력을 평가하는 데 사용되는 주요 지표입니다.\n- 주가 이익 비율 (P/E 비율): 주가 이익 비율은 주식 가격을 주당 이익과 비교하는 가격 평가 비율입니다. 기업의 현재 주가를 이익과 비교하며, 다른 기업의 가치를 비교하는 데 사용됩니다.\n- 배당 수익률: 배당 수익률은 기업의 연간 배당 지급액을 현재 주가로 나눈 값입니다. 주식 투자의 수익 잠재력을 평가하는 데 사용됩니다.\n- 시가 총액: 시가 총액은 기업의 유통 중인 주식의 총 가치입니다. 기업의 규모를 평가하고 다른 기업의 상대적 규모를 비교하는 데 사용됩니다.\n- 자기 자본 수익률 (ROE): 자기 자본 수익률은 기업이 주주 자본 양에 비례하여 얼마나 많은 이익을 창출하는지를 측정하는 수익성 비율입니다. 기업의 수익성과 효율성을 평가하는 데 사용됩니다.\n- 부채 자본 비율: 부채 자본 비율은 기업의 총 부채를 총 자본에 비교하는 금융 비율입니다. 부채 비율을 평가하는 것에 사용됩니다.","ogImage":{"url":"/TIL/assets/no-image.jpg"},"coverImage":"/TIL/assets/no-image.jpg","tag":["Tech"],"readingTime":1},{"title":"NiceGUI를 만나보세요 곧 여러분의 최애 파이썬 UI 라이브러리가 될 이유","description":"","date":"2024-07-09 14:57","slug":"2024-07-09-MeettheNiceGUIYourSoon-to-beFavoritePythonUILibrary","content":"\n## 사용자 정의 웹 앱을 쉽고 빠르게 만드세요\n\n![이미지](/TIL/assets/img/2024-07-09-MeettheNiceGUIYourSoon-to-beFavoritePythonUILibrary_0.png)\n\n만나보세요, NiceGUI! 이 간단한 Python 기반 UI 프레임워크는 웹 브라우저나 데스크톱 앱에서 원활하게 작동합니다. 작은 웹 앱, 대시보드, 또는 로봇 프로젝트를 만들고 있는 중이던 중이든, NiceGUI는 쉬운 인터페이스와 다양한 기능으로 여러분을 도와줄 거예요.\n\n이 글의 목표는 이 라이브러리의 장단점을 나열하고 어떻게 NiceGUI 앱을 만들고 배포할 수 있는지 보여줌으로써 여러분이 한 번 시도해보길 설득하는 것입니다. (이 게시물은 후원받은 것이 아니에요, 그냥 이 라이브러리를 좋아해서 쓴거에요 🙃)\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nStreamlit 대 NiceGUI: 왜 바꾸어야 할까요?\n\nStreamlit은 대화형 앱을 만드는 데 좋지만, 이벤트 및 상태 처리가 어려울 수 있습니다. 특히 큰 프로젝트의 경우 더 그렇습니다. NiceGUI는 다릅니다. NiceGUI를 사용하면 추가적인 단계나 고난한 해결책 없이 상태와 상호작용을 직접 제어할 수 있습니다.\n\n간단한 상태 관리\n\nNiceGUI는 상태를 쉽게 관리할 수 있습니다. Streamlit과 달리 예상치 못한 상태 재설정이 발생하지 않습니다. NiceGUI는 시작 상태든 사용자가 만든 변경 사항이든 모든 것을 안정적으로 유지합니다. 사용자 상호작용을 처리하기 위해 콜백을 사용할 수 있으며 전체 페이지 새로고침으로 인한 괴롭힘 없이 상태 데이터를 유지할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n많은 기능들\n\nNiceGUI에는 여러 가지 멋진 기능들이 많이 있어요:\n\n- 상호 작용을 위한 버튼, 스위치, 슬라이더, 입력 등 다양한 요소들이 있어요.\n- 화면에 요소들을 쉽게 배치할 수 있는 방법이 있어요.\n- 차트, 테이블, 심지어 3D 씬까지 시각화에 사용할 수 있어요.\n- Matplotlib 또는 Plotly와 같은 데이터 시각화 라이브러리와 통합이 되어 있어요.\n- 색상과 스타일을 쉽게 사용자 정의할 수 있어요.\n- 코딩과 테스트에 도움이 되는 도구들이 있어요.\n- 주 개발자들은 항상 질문에 대답할 준비가 되어 있고, GitHub 공간에 피드백을 매우 긍정적으로 반영해요.\n- 인기 있는 프레임워크 위에 구축되어 있어요: FastAPI, Vue3, Tailwind, Quasar.\n- 전체 사이트가 NiceGUI 라이브러리로 제작되었어요: https://nicegui.io/documentation\n\n제한사항\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNiceGUI은 정말 멋지지만, 작은 커뮤니티 규모 때문에 다소 제약이 있을 수 있습니다. Streamlit과 같이 인기 있는 프레임워크보다 학습 곡선이 조금 더 길 수도 있습니다. 라이브러리의 기능을 최대한 활용하려면 CSS와 Tailwind CSS에 익숙해지는 것이 좋습니다. 또한, FastAPI, Vue, 그리고 Quasar에 대한 지식은 더 큰 유연성을 제공하고 구현할 수 있는 기능을 확장할 수 있습니다.\n\n# 실습\n\n이제 NiceGUI의 몇 가지 기능을 탐험하고 데모 앱을 만들고 배포해 봅시다.\n\n## 기본 앱\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n먼저 NiceGUI를 설치해주세요:\n\n```js\npip install nicegui[highcharts]\n```\n\n주요 문서의 예제에서 시작해보겠습니다:\n\n```js\n# https://nicegui.io/documentation/section_data_elements\nfrom nicegui import ui\nfrom random import random\n\nchart = ui.highchart({\n    'title': False,\n    'chart': {'type': 'bar'},\n    'xAxis': {'categories': ['A', 'B']},\n    'series': [\n        {'name': 'Alpha', 'data': [0.1, 0.2]},\n        {'name': 'Beta', 'data': [0.3, 0.4]},\n    ],\n}).classes('w-full h-64')\n\ndef update():\n    chart.options['series'][0]['data'][0] = random()\n    chart.update()\n\nui.button('Update', on_click=update)\n\nui.run()\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기서 UI 모듈은 UI 요소를 만들 수 있도록합니다.\n이 예시에서 먼저 Highchart 요소를 생성하는데, 이에 w-full과 h-64의 tailwind 클래스를 할당합니다. w-full은 반응형으로 화면 전체를 가로로 사용하고 h-64는 높이를 지정합니다.\n\n![image](https://miro.medium.com/v2/resize:fit:1162/1*IbE0mHsejGUzviDgE2He3g.gif)\n\n버튼을 클릭하면 콜백 함수가 트리거됩니다. 이 콜백은 차트에 사용되는 데이터를 업데이트하고 그것을 순조롭게 다시 렌더링합니다.\n\n또한, 새로운 막대를 추가하기 위해 콜백을 변경할 수도 있습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ndef update():\n    chart.options[\"xAxis\"][\"categories\"].append(random.choice(string.ascii_uppercase))\n    for series in chart.options['series']:\n        series[\"data\"].append(random.random())\n    chart.update()\n```\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*P-IGyImlGMvNFut9LluamA.gif)\n\n또한 페이지를 새로 고침해도 데이터가 손실되지 않는다는 것을 알아두세요! 이것은 다른 Python UI 라이브러리로는 할 수 없는 일입니다. 이렇게 작동하는 이유는 데이터가 모든 사용자 사이에서 공유되기 때문이지만, 앱 저장소의 사용자 객체나 앱 저장소 브라우저같은 방법으로 데이터를 사용자별로 유지하는 방법이 많이 있습니다. @ui.page 데코레이터로 감싸기 위해 app.storage.user 객체나 app.storage.browser를 사용할 수 있습니다.\n\n하지만 주기적 타이머를 사용하여 UI를 업데이트하고 싶다면 어떻게 할까요? 쉽습니다! 버튼 요소를 ui.timer로 변경해주기만 하면 됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nui.timer(5, callback=lambda: (update(), ui.notify(\"데이터가 업데이트되었습니다\")))\n```\n\n![gif](https://miro.medium.com/v2/resize:fit:1400/1*wwSF1ib9720JW1FlKDOc0g.gif)\n\n자, 이제 사용자가 범주를 선택한 다음 무작위로 Chuck Norris Fact를 생성할 수 있는 데모 앱을 만들어 봅시다.\n\n먼저, 여기에 메인 코드가 있습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nimport requests  # HTTP 요청을 만들기 위해 requests 라이브러리를 가져옵니다\nfrom nicegui import ui  # NiceGUI 라이브러리에서 UI 구성 요소를 가져옵니다\nfrom nicegui_app.header import add_head_html  # HTML 헤드 내용을 추가하는 함수를 가져옵니다\n\n# Chuck Norris 사실 카테고리 목록\nCATEGORIES = [\n    \"동물\",\n    \"직업\",\n    \"연예인\",\n    \"개발\",\n    \"패션\",\n    \"음식\",\n    \"돈\",\n    \"영화\",\n    \"음악\",\n    \"과학\",\n    \"스포츠\",\n    \"여행\",\n]\n\n# Chuck Norris 사실을 처리하는 클래스\nclass Fact:\n    def __init__(self):\n        self.fact = None  # fact 속성을 None으로 초기화\n\n    # 주어진 카테고리를 기반으로 사실을 업데이트하는 메서드\n    def update_fact(self, category):\n        url = f\"https://api.chucknorris.io/jokes/random?category={category}\"  # Chuck Norris API URL\n\n        for i in range(10):  # 유효한 사실을 가져오려고 최대 10번 시도\n            result = requests.get(url)  # Chuck Norris API로 GET 요청을 보냄\n\n            if result.status_code == 200:  # 요청이 성공하면\n                result_json = result.json()  # JSON 응답을 파싱\n                if self.fact != result_json[\"value\"]:  # 가져온 사실이 현재 사실과 다르면\n                    self.fact = result_json[\"value\"]  # 사실을 업데이트하고\n                    break  # 루프를 종료\n\n# Chuck Norris 사실 UI를 생성하는 함수\ndef chuck():\n    add_head_html()  # NiceGUI 앱에 HTML 헤드 내용 추가\n\n    default_value = CATEGORIES[0]  # Chuck Norris 사실의 기본 카테고리\n\n    fact = Fact()  # Fact 클래스의 인스턴스 생성\n    fact.update_fact(default_value)  # 기본 카테고리로 사실을 업데이트\n\n    # 12개 열을 가진 그리드 레이아웃 생성\n    with ui.grid(columns=12).classes(\"w-full\"):\n        # 카테고리 선택을 위한 열\n        with ui.column().classes(\"col-span-4 sm:col-span-2 space-x-0\"):\n            ui.label(\"사실 카테고리 선택:\")  # 카테고리 선택을 위한 레이블 표시\n            # 카테고리 선택을 위한 라디오 버튼 그룹\n            category = ui.radio(\n                CATEGORIES,\n                value=default_value,\n                on_change=lambda _: fact.update_fact(category.value),  # 카테고리가 변경되면 사실 업데이트\n            ).classes(\"w-full\")\n            # 선택한 카테고리에 대한 사실을 다시 생성하는 버튼\n            ui.button(\n                \"⟳ 다시 생성\", on_click=lambda _: fact.update_fact(category.value)\n            )\n\n        # Chuck Norris 사실을 표시하는 열\n        with ui.column().classes(\n            \"flex col-span-8 sm:col-span-10 w-full justify-center mx-auto max-w-screen-md\"\n        ):\n            # Chuck Norris 사실을 표시하기 위한 레이블, Fact 인스턴스의 fact 속성에 바인딩\n            ui.label().bind_text_from(fact, \"fact\").classes(\n                \"text-lg sm:text-3xl text-gray-800 bg-gray-100 rounded-lg shadow-lg p-6\"\n            )\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nclass Fact:\n    def __init__(self):\n        self.fact = None  # fact 속성을 None으로 초기화합니다.\n\n    # 주어진 카테고리에 따라 팩트를 업데이트하는 메소드\n    def update_fact(self, category):\n        url = f\"https://api.chucknorris.io/jokes/random?category={category}\"  # 척 노리스 API의 URL입니다.\n\n        for i in range(10):  # 유효한 팩트를 가져오기 위해 최대 10번 시도합니다.\n            result = requests.get(url)  # 척 노리스 API에 GET 요청을 보냅니다.\n\n            if result.status_code == 200:  # 요청이 성공한 경우\n                result_json = result.json()  # JSON 응답을 파싱합니다.\n                if self.fact != result_json[\"value\"]:  # 가져온 팩트가 현재 팩트와 다른 경우\n                    self.fact = result_json[\"value\"]  # 팩트 속성을 업데이트합니다.\n                    break  # 루프를 종료합니다\n```\n\n이 클래스는 \"fact\" 속성에 팩트를 저장하고 Chuck Norris 팩트 API를 호출하는 update_fact 메소드를 가지고 있습니다. https://api.chucknorris.io\n\n다음으로, \"chuck\" 함수에서 페이지를 정의합니다. NiceGUI는 여러 모듈과 Python 파일을 거쳐 앱을 정의할 수 있는 모듈식 접근 방식을 채택합니다.\n\n우리는 데이터 클래스의 인스턴스인 fact = Fact()을 정의합니다. 이는 각 사용자별로 구체적인 인스턴스입니다. 그리고 다음으로 update_fact 메소드를 사용하여 팩트를 초기화합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 UI 요소를 정의하기 시작합니다.\n\n두 개의 열을 갖는 그리드를 정의합니다:\n\n- 카테고리 옵션 및 생성 버튼이있는 첫 번째 열입니다. 이 열은 다음과 같은 tailwind 클래스를 갖습니다: col-span-4 sm:col-span-2. 이것은 매우 작은 화면의 경우 화면의 4/12을 사용하고, 그렇지 않으면 화면의 2/12을 사용합니다. 이렇게 함으로써 디자인을 모바일 전화에서도 작동하게 할 수 있습니다.\n- 사실을 표시할 두 번째 열입니다.\n\n첫 번째 열을 위해:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 라디오 메뉴 `ui.radio`.\n- 무작위 사실을 생성하는 버튼이 있습니다.\n\n두 요소 모두 클릭되거나 변경될 때 `fact.update_fact`를 호출하는 콜백을 사용합니다.\n\n두 번째 열에 대해서:\n\n- `fact.fact` 값을 바인딩하는 `ui.label`이 있습니다. 이 변수가 변경될 때마다 디스플레이가 자동으로 업데이트됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래에 있는 테일윈드 클래스를 가진 레이블입니다: text-lg sm:text-3xl 이렇게 하면 텍스트가 작은 화면에서 더 작아집니다.\n\n다음 앱을 얻게 되요:\n\n![앱 이미지](https://miro.medium.com/v2/resize:fit:1400/1*ElNrpcoZndHh1If8Cme9kQ.gif)\n\n멋지죠?\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 배포\n\n앱을 배포하는 것은 쉬워요! 예를 들어 CloudRun을 사용하면 매우 간단해요. Dockerfile을 생성한 다음 다음 gcloud 명령어를 실행하기만 하면 돼요:\n\n```js\nPROJECT_ID=$(gcloud config get-value project)\nREPO=\"demo\"\nLOCATION=\"europe-west1\"\nIMAGE=\"nicegui_app\"\nSERVICE_NAME=\"nicegui-app\"\nVERSION=\"0.0.1\"\nGAR_TAG=$LOCATION-docker.pkg.dev/$PROJECT_ID/$REPO/$IMAGE:$VERSION\n\n# 저장소 생성\ngcloud artifacts repositories create $REPO --repository-format=docker \\\n    --location=$LOCATION --description=\"Docker repository\" \\\n    --project=$PROJECT_ID  || true # 이미 존재하는 경우를 위해 실패해도 괜찮아요\n\n# 이미지 빌드\ngcloud builds submit --tag $GAR_TAG\n\n# Cloud Run 배포\ngcloud run deploy $SERVICE_NAME --image=$GAR_TAG --max-instances=1 --min-instances=0 --port=8080 \\\n --allow-unauthenticated --region=europe-west1 --memory=0.5Gi --cpu=1 -q --no-cpu-throttling --session-affinity\n```\n\n이렇게 하면 클라우드 빌드를 사용하여 도커 이미지를 빌드한 다음 CloudRun에 배포할 수 있어요.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기서 유일한 키큰 옵션은 다음과 같습니다: \"— no-cpu-throttling — session-affinity\". 이를 통해 동일한 사용자가 가능한 경우 동일한 컨테이너로 라우팅되고 요청 사이에 CPU가 활성 상태로 유지됩니다.\n\n마지막으로\n\nNiceGUI는 파이썬을 사용해 빠르고 쉽게 사용자 인터페이스를 만들고 싶을 때 좋은 선택입니다. 여기에서는 내부 상태를 완전히 제어하고 테스트하고 쉽게 배포할 수 있는 강력한 파이썬 앱을 구축할 수 있습니다. 이를 통해 데이터 과학 프로젝트에서도 도구로 제한받지 않고 창의성을 발휘할 수 있을 것입니다.\n\n여기에 표시된 내용은 NiceGUI로 할 수 있는 작은 부분에 불과합니다. 아래 링크를 따라가면 더 많은 것을 배울 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자원:\n\n- Chuck Norris (매우 과장된) 사실 API: [https://api.chucknorris.io/](https://api.chucknorris.io/)\n- NiceGUI 문서: [https://nicegui.io/documentation](https://nicegui.io/documentation)\n- NiceGUI 예제: [https://github.com/zauberzeug/nicegui/tree/main/examples](https://github.com/zauberzeug/nicegui/tree/main/examples)\n- 이 게시물의 코드: [https://github.com/CVxTz/nicegui_tutorial](https://github.com/CVxTz/nicegui_tutorial)\n","ogImage":{"url":"/assets/img/2024-07-09-MeettheNiceGUIYourSoon-to-beFavoritePythonUILibrary_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-MeettheNiceGUIYourSoon-to-beFavoritePythonUILibrary_0.png","tag":["Tech"],"readingTime":14},{"title":"GRASP 원칙 견고하고 유지보수 가능한 코드의 기초","description":"","date":"2024-07-09 14:55","slug":"2024-07-09-GRASPPrinciplesTheFoundationofRobustandMaintainableCode","content":"\n## 일반 책임 할당 소프트웨어 패턴\n\n![그림](/TIL/assets/img/2024-07-09-GRASPPrinciplesTheFoundationofRobustandMaintainableCode_0.png)\n\nGRASP(일반 책임 할당 소프트웨어 패턴) 원칙은 객체지향 설계에서 객체와 클래스에 책임을 할당하는 데 도움이 되는 지침 세트입니다.\n\n이러한 원칙은 처음으로 Craig Larman이 그의 책 \"UML과 패턴 적용\"에서 소개했습니다. 그 책 정말 좋아요; 이전에 읽지 않았다면 읽어보시기를 추천합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2024-07-09-GRASPPrinciplesTheFoundationofRobustandMaintainableCode_1.png\" /\u003e\n\n이러한 패턴들은 개발자가 핵심 객체 지향 설계 원칙을 이해하고 적용하는 데 도움이 되는 교육 도구입니다. 이 패턴들은 개발자들이 책임을 클래스와 객체에 체계적으로 할당하고, 잘 구조화되고 유지보수 가능한 소프트웨어를 촉진하는 데 도움을 줍니다.\n\nGRASP를 따르면, 개발자들은 합리적이고 설명 가능한 설계 결정을 내릴 수 있도록 하여, 시스템의 각 구성 요소가 명확하고 정당화된 역할을 갖도록 보장할 수 있습니다.\n\n## 책임 주도 설계\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nRDD는 소프트웨어 설계 방법으로, 소프트웨어 구성 요소에 명확한 책임을 할당하는 것을 강조합니다. 각 구성 요소(일반적으로 객체 또는 클래스)는 잘 정의된 역할과 다른 구성 요소와의 상호 작용을 갖습니다.\n\nGRASP 패턴의 주요 원칙은 역할을 찾아 객체에 할당하는 것입니다. 즉, 이러한 할당을 안내하는 원칙 세트를 제공합니다.\n\nLarman의 책에서 역할을 두 가지 주요 유형으로 나눕니다:\n\n역할 인식: 객체는\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 그 데이터 또는 상태 (캡슐화)입니다.\n- 그 주변의 기타 관련된 객체들 (결합 등). 누구와 협력하나요?\n- 비즈니스. 무슨 일을 할 건가요? 어떻게 할 건가요?\n\n기능 책임: 객체가 하는 일\n\n- 비즈니스 계산 수행 또는 객체 생성과 같은 동작을 수행합니다. (원자적 작업)\n- 다른 객체에게 작업을 수행하도록 유발합니다.\n- 다른 객체들에서 작업 (비즈니스 프로세스)을 조정합니다. (조정 작업)\n\nGRASP 원칙:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 정보 전문가\n- 생성자\n- 높은 응집도\n- 낮은 결합도\n- 컨트롤러\n- 다형성\n- 순수한 가공물\n- 간접성\n- 보호된 변화\n\n## 정보 전문가\n\n해당 작업을 수행하는 데 필요한 정보를 갖고 있는 클래스에 책임을 할당해야 합니다. 가장 관련성 있는 데이터를 갖고 있는 클래스가 관련된 동작을 처리하는 책임을 져야 합니다.\n\n이는 캡슐화를 강조하고 데이터 결합을 피하기 위한 것입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예를 들어, 작업을 수행하는 메서드를 가지고 있다고 가정해보겠습니다. 이 메서드가 데이터를 사용한다면, 해당 메서드는 데이터가 포함된 클래스에 배치되어야 합니다.\n\n![이미지](/TIL/assets/img/2024-07-09-GRASPPrinciplesTheFoundationofRobustandMaintainableCode_2.png)\n\n제품에 대한 할인을 계산하려고 합니다.\n\n좋지 않은 예: DiscountCalculator 클래스가 제품 클래스에서 데이터를 사용하여 할인 가격을 계산합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nclass Product:\n    def __init__(self, name: str, price: float, discount: float):\n        self.name = name\n        self.price = price\n        self.discount = discount\n\nclass Order:\n    def __init__(self, product: Product, quantity: int):\n        self.product = product\n        self.quantity = quantity\n\n    def calculate_total_price(self) -\u003e float:\n        return self.product.price * self.quantity\n\nclass DiscountCalculator:\n    def calculate_discounted_price(self, order: Order) -\u003e float:\n        discount = order.product.price * (order.product.discount / 100)\n        return order.product.price - discount\n```\n\nDiscountCalculator 클래스가 필요한 정보를 스스로 캡슐화하지 않고 외부 데이터에 의존합니다.\n\nProduct는 책임이 없습니다. 실제 클래스가 아닙니다.\n\n좋은 점: 할인을 계산하는 메서드가 필요한 데이터를 포함한 클래스에 위치합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nclass Product:\n    def __init__(self, name: str, price: float, discount: float):\n        self.name = name\n        self.price = price\n        self.discount = discount\n\n    def calculate_discounted_price(self) -\u003e float:\n        discount = self.price * (self.discount / 100)\n        return self.price - discount\n\nclass Order:\n    def __init__(self, product: Product, quantity: int):\n        self.product = product\n        self.quantity = quantity\n\n    def calculate_total_price(self) -\u003e float:\n        return self.product.calculate_discounted_price() * self.quantity\n```\n\nProduct 클래스에는 할인 가격을 계산하는 calculate_discounted_price 메서드가 있습니다. 이 메서드는 가격과 할인율과 같은 필요한 정보를 포함하는 Product 클래스 내에 위치합니다. 이렇게 함으로써 관련된 동작을 다루는 관련 데이터를 포함하는 클래스가 해당 동작을 처리하므로 정보 전문가 원칙을 따르며 캡슐화를 촉진하고 데이터 결합을 줄입니다.\n\n## Creator\n\n다른 클래스의 인스턴스를 생성하는 책임이 있는 클래스에 대한 지침을 제공합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n창작자 원칙에 따르면 클래스 B는 다음 조건 중 하나 이상이 참일 때 클래스 A의 인스턴스를 생성하는 역할을 수행해야 합니다:\n\n- 집약: B가 A 객체를 집약함.\n- 합성: B가 A 객체를 포함함.\n- 초기화: B가 A 객체를 밀접하게 사용함.\n- 연관: B가 A 객체를 생성하기 위한 초기화 데이터를 가짐.\n- 의존성: B가 A 객체의 인스턴스를 기록함.\n\n이러한 관계를 기억하는 데 도움이 될 수 있습니다:\n\n여러 옵션이 적용되는 경우 집약 또는 포함 (우선 순위가 높음)하는 클래스 B를 선호합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# Class B는 클래스 A의 객체들을 모으는 역할을 합니다.\n\nclass A:\n    def __init__(self, value):\n        self.value = value\n\nclass B:\n    def __init__(self):\n        self.a_objects = []\n\n    def add_a(self, value):\n        a = A(value)  # B가 A를 생성합니다\n        self.a_objects.append(a)\n```\n\n```js\n# Class B는 클래스 A의 객체들을 포함합니다.\n\nclass A:\n    def __init__(self, value):\n        self.value = value\n\nclass B:\n    def __init__(self, value1, value2):\n        self.a1 = A(value1)  # B가 A를 생성합니다\n        self.a2 = A(value2)  # B가 A를 생성합니다\n```\n\n```js\n# Class B는 클래스 A의 객체들을 밀접하게 사용합니다.\n\nclass A:\n    def __init__(self, value):\n        self.value = value\n\nclass B:\n    def __init__(self, value):\n        self.a = A(value)  # B가 A를 생성합니다\n\n    def get_a_value(self):\n        return self.a.value\n```\n\n```js\n# Class B는 클래스 A의 객체를 만들기 위한 초기화 데이터를 갖습니다.\n\nclass A:\n    def __init__(self, value):\n        self.value = value\n\nclass B:\n    def __init__(self, value):\n        self.a = self.create_a(value)  # B가 A를 생성합니다\n\n    def create_a(self, value):\n        return A(value)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# Class B은 Class A의 인스턴스를 기록합니다.\n\nclass A:\n    def __init__(self, value):\n        self.value = value\n\nclass B:\n    def __init__(self):\n        self.a_objects = []\n\n    def add_a(self, value):\n        a = A(value)  # B가 A를 생성\n        self.a_objects.append(a)\n```\n\n위 내용에서 알 수 있듯이, 이 원리는 객체 지향 설계에서 객체를 생성하는 데 특히 책임이 있는 생성 디자인 패턴과 관련이 있습니다.\n\n예를 들어, Factory 디자인 패턴은 슈퍼클래스에서 객체를 생성하는 인터페이스를 제공합니다.\n\nFactory 디자인 패턴에서는 세부 사항을 알 필요가 없습니다. 이 패턴은 \"필요한 데이터를 제공하면 객체를 생성할 테니까\"라고 합니다. 그것은 객체를 만드는 방법을 알지만 그것을 사용하지는 않습니다. 그저 생성합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 높은 응집도 \u0026 낮은 결합도\n\n낮은 결합도는 클래스 간의 의존성을 줄여 시스템을 더 모듈화하고 유지 관리하기 쉽게 만듭니다.\n\n높은 응집도는 각 클래스가 명확한 목적을 갖도록 합니다.\n\n이 두 가지 개념에 대해 이미 다른 게시물에서 설명했기 때문에 여기서 다시 설명하지는 않겠습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Controller\n\n입력 시스템 이벤트가 발생했을 때(예: 사용자가 버튼을 클릭하거나 타이머가 만료되거나 센서가 변경을 감지한 경우), Controller 원칙은 어떤 클래스가 이벤트를 처리해야 하는지 결정하는 데 도움을 줍니다. Controller는 필요한 조치를 조정하고 다른 객체에 작업을 위임할 것입니다.\n\nController는 전체 시스템, 특정 장치 또는 서브시스템을 나타내는 퍼사드 컨트롤러로 작용할 수 있습니다. 이 퍼사드 컨트롤러는 시스템 이벤트를 처리하기 위한 중앙 진입점 역할을 하며, 시스템 내에서 상호 작용을 조정하고 고수준 작업을 관리하는 단순화된 일관된 인터페이스를 제공합니다.\n\n```python\nclass User:\n    def __init__(self, username):\n        self.username = username\n        self.logged_in = False\n\n    def login(self):\n        self.logged_in = True\n        print(f\"{self.username} 님이 로그인했습니다.\")\n\n    def logout(self):\n        self.logged_in = False\n        print(f\"{self.username} 님이 로그아웃했습니다.\")\n\nclass SystemController:\n    def __init__(self):\n        self.users = {}\n\n    def handle_input(self, action, username):\n        if action == \"login\":\n            self.login_user(username)\n        elif action == \"logout\":\n            self.logout_user(username)\n        else:\n            print(\"알 수 없는 동작입니다.\")\n\n    def login_user(self, username):\n        if username not in self.users:\n            self.users[username] = User(username)\n        user = self.users[username]\n        user.login()\n\n    def logout_user(self, username):\n        user = self.users.get(username)\n        if user and user.logged_in:\n            user.logout()\n        else:\n            print(f\"{username} 님은 로그인되어 있지 않거나 존재하지 않습니다.\")\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nSystemController은 퍼사드 컨트롤러 역할을 하며 사용자 로그인 및 로그아웃 작업을 단일화하여 처리합니다. 사용자 사전을 유지하고 시스템 입력의 로그인 및 로그아웃 작업을 처리하는 메서드를 제공합니다.\n\n컨트롤러를 구현하는 다른 방법은 특정 사용 사례나 시나리오를 나타내는 곳에서 시스템 이벤트가 발생하는 것을 나타내는 것입니다. 이 유형의 컨트롤러는 종종 `UseCaseName`Handler, `UseCaseName`Coordinator 또는 `UseCaseName`Session으로 참조됩니다.\n\n이 사용 사례 또는 세션 컨트롤러는 특정 사용 사례와 관련된 작업과 상호 작용의 순서를 관리하여 모든 필요한 단계가 올바르게 실행되고 올바른 순서대로 실행되도록 보장합니다.\n\n```js\nclass User:\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n        self.logged_in = False\n\n    def check_password(self, password):\n        return self.password == password\n\n    def login(self):\n        self.logged_in = True\n        print(f\"{self.username}님이 로그인하였습니다.\")\n\n    def logout(self):\n        self.logged_in = False\n        print(f\"{self.username}님이 로그아웃하였습니다.\")\n\nclass LoginSession:\n    def __init__(self, users):\n        self.users = users\n\n    def handle_login(self, username, password):\n        user = self.users.get(username)\n        if user and user.check_password(password):\n            user.login()\n        else:\n            print(\"유효하지 않은 사용자 이름 또는 비밀번호.\")\n\n    def handle_logout(self, username):\n        user = self.users.get(username)\n        if user and user.logged_in:\n            user.logout()\n        else:\n            print(f\"{username}님은 로그인되어 있지 않거나 사용자가 존재하지 않습니다.\")\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n로그인 세션은 로그인 시나리오를 위한 유즈 케이스 컨트롤러 역할을 합니다. 로그인 및 로그아웃 프로세스를 처리하며 적절한 단계(예: 비밀번호 확인 및 로그인 상태 업데이트)가 따라지도록 합니다.\n\n일반적으로 컨트롤러는 수행해야 하는 작업을 다른 객체에게 위임해야 합니다. 주요 역할은 활동을 조정하거나 관리하는 것입니다. 컨트롤러 자체가 방대한 업무를 수행해서는 안 됩니다.\n\n```js\nclass Worker:\n    def perform_task(self, task_name):\n        print(f\"Worker is performing task: {task_name}\")\n\nclass TaskController:\n    def __init__(self):\n        self.worker = Worker()\n\n    def handle_task(self, task_name):\n        # 컨트롤러는 실제 작업을 Worker에 위임합니다\n        self.worker.perform_task(task_name)\n```\n\n컨트롤러 클래스가 담당해야 할 책임이 너무 많아지고 논리와 기능을 더 다루게 되면 컨트롤러가 부풀어 오르는 상황이 발생합니다. 보통 이런 상황은 컨트롤러가 다른 객체나 클래스에 효과적으로 작업을 위임하지 않아서 발생하며, 관심사의 명확한 분리가 이루어지지 않는 것이 일반적입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 과도한 책임\n- 부적절한 위임\n- 복잡성\n- 유지 관리 도전\n- 재사용성 감소\n\n```js\nclass TaskController:\n    def __init__(self):\n        self.tasks = []\n        self.users = {}\n        self.logged_in_user = None\n\n    # 사용자 관리 메서드\n    def register_user(self, username, password):\n        if username in self.users:\n            print(f\"'{username}' 사용자는 이미 존재합니다.\")\n        else:\n            self.users[username] = password\n            print(f\"'{username}' 사용자가 등록되었습니다.\")\n\n    def login_user(self, username, password):\n        if username in self.users and self.users[username] == password:\n            self.logged_in_user = username\n            print(f\"'{username}' 사용자가 로그인되었습니다.\")\n        else:\n            print(\"유효하지 않은 사용자 이름 또는 비밀번호입니다.\")\n\n    def logout_user(self):\n        if self.logged_in_user:\n            print(f\"'{self.logged_in_user}' 사용자가 로그아웃되었습니다.\")\n            self.logged_in_user = None\n        else:\n            print(\"로그인된 사용자가 없습니다.\")\n\n    # 업무 관리 메서드\n    def add_task(self, task_name):\n        if self.logged_in_user:\n            self.tasks.append((task_name, self.logged_in_user))\n            print(f\"'{task_name}' 작업이 {self.logged_in_user}에 의해 추가되었습니다.\")\n        else:\n            print(\"로그인된 사용자가 없습니다.\")\n\n    def remove_task(self, task_name):\n        if self.logged_in_user:\n            task = next((t for t in self.tasks if t[0] == task_name and t[1] == self.logged_in_user), None)\n            if task:\n                self.tasks.remove(task)\n                print(f\"'{task_name}' 작업이 {self.logged_in_user}에 의해 제거되었습니다.\")\n            else:\n                print(f\"'{task_name}' 작업을 {self.logged_in_user} 사용자가 찾을 수 없습니다.\")\n        else:\n            print(\"로그인된 사용자가 없습니다.\")\n\n    ...\n\n    # 작업 스케줄링 메서드\n    def schedule_task(self, task_name, time):\n        if self.logged_in_user:\n            print(f\"'{task_name}' 작업이 {self.logged_in_user}에 의해 {time}에 예약되었습니다.\")\n        else:\n            print(\"로그인된 사용자가 없습니다.\")\n```\n\nTaskController는 사용자 인증, 작업 관리 및 스케줄링을 처리하므로 지나치게 복잡합니다. (과도한 책임)\n\n모든 로직이 컨트롤러 내에서 처리되어 서로 강하게 결합되어 유지 관리하기 어려운 코드로 이어집니다. (부적절한 위임)\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n컨트롤러의 메서드는 관련 없는 여러 작업을 처리하므로 오류 발생 및 코드 이해가 어려워질 수 있습니다. (높은 복잡성)\n\n사용자 관리, 작업 처리 또는 일정 로직에 대한 변경은 TaskController 수정을 필요로 하여 유지 관리를 복잡하게 하고 기능을 확장합니다. (유지보수 도전)\n\n리팩토링:\n\n```js\nclass User:\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n        self.logged_in = False\n\n    def check_password(self, password):\n        return self.password == password\n\n    def login(self):\n        self.logged_in = True\n        print(f\"{self.username} 로그인되었습니다.\")\n\n    def logout(self):\n        self.logged_in = False\n        print(f\"{self.username} 로그아웃되었습니다.\")\n\nclass Task:\n    def __init__(self, name):\n        self.name = name\n\n    def perform(self):\n        print(f\"작업 수행 중: {self.name}\")\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks = {}\n\n    def add_task(self, task, username):\n        self.tasks[(task.name, username)] = task\n        print(f\"작업 '{task.name}'가 {username}에 의해 추가되었습니다.\")\n\n    def remove_task(self, task_name, username):\n        if (task_name, username) in self.tasks:\n            del self.tasks[(task_name, username)]\n            print(f\"작업 '{task_name}'가 {username}에 의해 제거되었습니다.\")\n        else:\n            print(f\"사용자 {username}에 대한 작업 '{task_name}'을 찾을 수 없습니다.\")\n\n    def get_task(self, task_name, username):\n        return self.tasks.get((task_name, username), None)\n\nclass UserController:\n    def __init__(self):\n        self.users = {}\n        self.logged_in_user = None\n\n    def register_user(self, username, password):\n        if username in self.users:\n            print(f\"'{username}' 사용자가 이미 존재합니다.\")\n        else:\n            self.users[username] = User(username, password)\n            print(f\"'{username}' 사용자가 등록되었습니다.\")\n\n    def login_user(self, username, password):\n        user = self.users.get(username)\n        if user and user.check_password(password):\n            self.logged_in_user = user\n            user.login()\n        else:\n            print(\"유효하지 않은 사용자 이름 또는 비밀번호입니다.\")\n\n    def logout_user(self):\n        if self.logged_in_user:\n            self.logged_in_user.logout()\n            self.logged_in_user = None\n        else:\n            print(\"로그인된 사용자가 없습니다.\")\n\n    def get_logged_in_user(self):\n        return self.logged_in_user\n\nclass TaskScheduler:\n    def schedule_task(self, task_name, time, username):\n        print(f\"'{task_name}' 작업이 {username}에 의해 {time}에 예약되었습니다.\")\n\nclass TaskController:\n    def __init__(self, user_controller, task_manager, task_scheduler):\n        self.user_controller = user_controller\n        self.task_manager = task_manager\n        self.task_scheduler = task_scheduler\n\n    def handle_add_task(self, task_name):\n        user = self.user_controller.get_logged_in_user()\n        if user:\n            task = Task(task_name)\n            self.task_manager.add_task(task, user.username)\n        else:\n            print(\"로그인된 사용자가 없습니다.\")\n\n    def handle_remove_task(self, task_name):\n        user = self.user_controller.get_logged_in_user()\n        if user:\n            self.task_manager.remove_task(task_name, user.username)\n        else:\n            print(\"로그인된 사용자가 없습니다.\")\n\n    def handle_perform_task(self, task_name):\n        user = self.user_controller.get_logged_in_user()\n        if user:\n            task = self.task_manager.get_task(task_name, user.username)\n            if task:\n                task.perform()\n                self.task_manager.remove_task(task_name, user.username)\n            else:\n                print(f\"사용자 {user.username}에 대해 작업 '{task_name}'을 찾을 수 없습니다.\")\n        else:\n            print(\"로그인된 사용자가 없습니다.\")\n\n    def handle_schedule_task(self, task_name, time):\n        user = self.user_controller.get_logged_in_user()\n        if user:\n            self.task_scheduler.schedule_task(task_name, time, user.username)\n        else:\n            print(\"로그인된 사용자가 없습니다.\")\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n각 클래스는 하나의 명확한 책임을 갖습니다.\n\n## 다형성\n\n다형성은 OOP의 기본 개념으로, 다른 클래스의 객체를 공통 상위 클래스의 객체로 처리할 수 있게 해줍니다.\n\n## 순수 가공\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n가끔은 우리의 문제 도메인에 직접적으로 대응되지 않지만 코드를 더 잘 관리하기 위해 만든 클래스가 필요할 수 있습니다. 이러한 클래스들은 우리의 주요 클래스를 복잡하게 만들지 않고 원활하게 작동하도록 도와주는 편리한 도구들과 같습니다.\n\n```js\nclass Resource:\n    def __init__(self):\n        print(\"리소스를 로딩 중입니다...\")\n        # 리소스 집약 작업을 시뮬레이션합니다\n        import time\n        time.sleep(2)\n        print(\"리소스가 로딩되었습니다.\")\n\n    def use(self):\n        print(\"리소스를 사용 중입니다.\")\n```\n\n이 예시에서 Resource 클래스는 리소스를 로딩하기 위해 과도한 시간이 소요될 수 있습니다. Resource 객체를 생성할 때마다 리소스 집약적인 작업을 즉시 수행하며, 실제로 사용하지 않아도 됩니다.\n\n이제 Resource 객체가 필요한 경우에만 생성되도록 액세스를 제어하는 ResourceProxy 클래스를 소개해보겠습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nclass Resource:\n    def __init__(self):\n        print(\"리소스를 불러오는 중...\")\n        # 리소스 집약적인 작업을 시뮬레이션합니다\n        import time\n        time.sleep(2)\n        print(\"리소스가 불러졌습니다.\")\n\n    def use(self):\n        print(\"리소스를 사용 중입니다.\")\n\nclass ResourceProxy:\n    def __init__(self):\n        self._resource = None\n\n    def use(self):\n        if self._resource is None:\n            self._resource = Resource()  # 게으른 초기화\n        self._resource.use()\n```\n\n`ResourceProxy`는 `Resource` 객체에 대한 프록시 역할을 하며, 액세스를 제어하고 필요할 때만 생성되도록 보장합니다(게으른 초기화).\n\n원본 클래스를 복잡하게 만들지 않으면서도 가치를 더하는 도우미 클래스를 소개했습니다.\n\n`순수 가상화`는 문제 도메인 내에서 실제 세계 개념을 나타내지 않는 인공 클래스를 생성하는 디자인 원칙입니다. 이 클래스는 고유한 디자인 목표인 높은 응집력, 낮은 결합도, 재사용성을 달성하기 위해 도입됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기본적으로 \"상상의 산물\"이며, 이는 깔끔하고 효율적인 설계를 유지하는 데 도움이 되는 발명된 구조라는 뜻입니다. 이 상상한 클래스에 할당된 책임은 다른 클래스와 높은 응집성을 유지하고 최소한으로 결합되도록 보장하여 모듈식이고 유지보수가 쉬운 코드베이스를 유지하는 데 도움이 되어야 합니다.\n\n목표는 각 클래스가 집중된 목적을 가지고 있으며 최소한의 의존성을 갖도록하여 전체적으로 깔끔한 아키텍처를 유발하는 시스템을 설계하는 것입니다. 순수한 가공은 때로 디자이너가 시스템의 복잡성을 효과적으로 관리해야 할 때 창의적인 솔루션으로 사용됩니다.\n\n```js\n# 나쁜 예\n\nclass Customer:\n    def __init__(self, name, email):\n        self.name = name\n        self.email = email\n\n    def save_to_database(self):\n        # 데이터베이스에 저장하는 것을 모의로 시뮬레이션\n        print(f\"{self.name} 고객을 데이터베이스에 저장합니다.\")\n\n# 좋은 예\nclass Customer:\n    def __init__(self, name, email):\n        self.name = name\n        self.email = email\n\nclass CustomerRepository:\n    def save(self, customer):\n        # 데이터베이스에 저장하는 것을 모의로 시뮬레이션\n        print(f\"{customer.name} 고객을 데이터베이스에 저장합니다.\")\n```\n\n## 간접성\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n간접 역참조의 원칙은 다른 구성 요소 사이에 중간 클래스를 생성하는 것을 포함합니다. 이 중간 클래스는 클래스들을 분리하여 시스템에서 유연성과 재사용성을 촉진하는 데 도움이 됩니다.\n\n```js\nclass Database:\n    def save_user(self, username):\n        print(f\"사용자 {username}을(를) 데이터베이스에 저장했습니다.\")\n\nclass UserRepository:\n    def __init__(self, database):\n        self.database = database\n\n    def save(self, username):\n        self.database.save_user(username)\n\nclass User:\n    def __init__(self, username, user_repository):\n        self.username = username\n        self.user_repository = user_repository\n\n    def save(self):\n        self.user_repository.save(self.username)\n```\n\nUserRepository는 User와 Database 클래스 간의 상호 작용을 추상화하는 중개자 역할을 합니다. 이 리포지토리는 통신을 중재하고 데이터 작업을 관리합니다.\n\nUser 클래스는 Database 클래스와 직접 상호 작용하지 않으므로 종속성이 줄어듭니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 보호된 변이\n\nProtected Variations은 시스템의 요소들을 안정적인 인터페이스 뒤에 변경 또는 다른 요소의 변화로부터 보호하는 것을 목표로 합니다.\n\n본질적으로, 이는 우리 시스템에서 변경될 가능성이 높거나 불안정할 수 있는 부분을 식별하고, 이러한 부분 주변에 안정적인 인터페이스를 생성하여 이러한 변경으로부터 시스템의 나머지 부분을 보호하는 것입니다.\n\n이 원칙을 구현하기 위해 우리는 먼저 시스템 내에서 변경이 가장 가능성이 높은 지점을 식별합니다. 이를 \"변이 지점\"이라고 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그럼, 우리는 이러한 가변 부분과 상호 작용하는 안정적이고 일관된 방법을 제공하는 인터페이스나 추상 클래스를 생성합니다.\n\n이를 통해 시스템을 통해 전파되는 잠재적인 변경사항이나 불안정성을 방지하여 버그를 도입하는 위험을 최소화하고 광범위한 리팩터링이 필요한 필요성을 줄입니다.\n\n간단한 예제를 통해 **보호된 변형** 원칙을 보여줍시다. 여기서는 다양한 결제 방법을 지원해야 할 수 있는 결제 시스템을 가정합니다.\n\n```python\nclass CreditCardPayment:\n    def process_payment(self, amount):\n        print(f\"금액 ${amount}의 신용카드 결제 처리중\")\n\nclass PayPalPayment:\n    def process_payment(self, amount):\n        print(f\"금액 ${amount}의 PayPal 결제 처리중\")\n\nclass Order:\n    def __init__(self, amount):\n        self.amount = amount\n\n    def process_payment(self, payment_method):\n        if payment_method == \"credit_card\":\n            payment = CreditCardPayment()\n            payment.process_payment(self.amount)\n        elif payment_method == \"paypal\":\n            payment = PayPalPayment()\n            payment.process_payment(self.amount)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nOrder 클래스는 특정 결제 방법 구현과 직접 상호 작용합니다.\n\n이제 결제 방법의 변화를 캡슐화하기 위한 안정적인 인터페이스를 소개합시다.\n\n```python\nfrom abc import ABC, abstractmethod\n\nclass PaymentMethod(ABC):\n    @abstractmethod\n    def process_payment(self, amount):\n        pass\n\nclass CreditCardPayment(PaymentMethod):\n    def process_payment(self, amount):\n        print(f\"카드로 ${amount} 결제 진행 중\")\n\nclass PayPalPayment(PaymentMethod):\n    def process_payment(self, amount):\n        print(f\"PayPal로 ${amount} 결제 진행 중\")\n\nclass Order:\n    def __init__(self, amount, payment_method):\n        self.amount = amount\n        self.payment_method = payment_method\n\n    def process_payment(self):\n        self.payment_method.process_payment(self.amount)\n```\n\n결제 처리 로직은 특정 결제 방법 클래스 내에 캡슐화되어 있습니다. 새로운 결제 방법이 도입되면 Order 클래스를 수정하지 않고 PaymentMethod 인터페이스를 구현하는 새 클래스를 생성하여 추가할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 더 읽어보기\n\n## 출처\n\nApplying UML and Patterns, Craig Larman\n\nhttps://www.geeksforgeeks.org/grasp-design-principles-in-ooad/\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위키백과 링크의 표를 마크다운 형식으로 변경하세요.\n","ogImage":{"url":"/assets/img/2024-07-09-GRASPPrinciplesTheFoundationofRobustandMaintainableCode_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-GRASPPrinciplesTheFoundationofRobustandMaintainableCode_0.png","tag":["Tech"],"readingTime":28},{"title":"2024년, 수학자가 대세가 된 이유","description":"","date":"2024-07-09 14:54","slug":"2024-07-09-TheEraoftheMathematicianHasArrived","content":"\r\n![라는 링크된 이미지](/TIL/assets/img/2024-07-09-TheEraoftheMathematicianHasArrived_0.png)\r\n\r\n저는 순수수학자로 훈련받았어요. 사실 알게 치는 사람이죠. 박사 학위를 받을 쯤에는 너무나 특이한 전문분야로 깊숙이 들어가 있어, 심사위원을 찾기도 어려울 정도였어요. 학자가 되고 싶었다는 생각 때문에 이 토끼굴 속으로 빠져들게 된 거예요. 그런데 가만 생각하니 결론은 변했어요.\r\n\r\n나에게는 학계가 너무 외롭고 냉대적으로 느껴졌고, 그래서 다른 길을 찾아야겠다고 결정했어요. 그런데 오직 수학식 작성에만 익숙했던 나는 어디로 가야 할까요? 이전의 전문 지식을 떨쳐버리고 새롭게 시작해야 한다는 사실을 받아들였는데, 앞으로 나에게 깊은 대수학이 무용지물일 것임을 깨달았죠.\r\n\r\n며칠이 지난 뒤에 놀랍게도 그 가정이 전혀 틀렸다는 것을 알게 되었어요. 오늘, 새로 일어나는 모든 일을 이해하기 위해선 수학보다 더 적합한 분야가 없다고 말할 수 있어요. 저만 믿지 마시고 직업 시장도 그렇게 느끼고 있거든요. 미국 노동 통계국이 최근 발표한 보고서에 따르면, 수학자와 통계학자의 취업 시장이 다음 10년 동안 33%나 성장할 것으로 예측돼 있고...\r\n","ogImage":{"url":"/assets/img/2024-07-09-TheEraoftheMathematicianHasArrived_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-TheEraoftheMathematicianHasArrived_0.png","tag":["Tech"],"readingTime":1},{"title":"환상적인 네트워크 그래프를 위한 최고의 15가지 Python 도구","description":"","date":"2024-07-09 14:53","slug":"2024-07-09-Top15PythonToolsforStunningNetworkGraphs","content":"\n## 파이썬 시각화\n\n네트워크 그래프는 간단한 모양과 선을 사용하여 복잡한 시스템을 보여줍니다. 이것들은 데이터 내의 연결을 이해하는 데 도움이 됩니다. 여기 네트워크 그림을 만들기 위한 좋은 파이썬 도구 15가지가 있습니다. 이 모든 도구들은 무료로 이용할 수 있습니다.\n\n- NetworkX\n\nNetworkX는 네트워크 처리에 도움이 되는 파이썬 도구입니다. 여러분이:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n1. 네트워크 생성\n\n2. 네트워크 변경\n\n3. 네트워크 연구\n\n파이썬에서 그래프 데이터를 다룰 때 많은 사람들이 NetworkX를 사용합니다. 또한 많은 그래프 인공지능 도구의 기반으로 사용됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![그래프 도구](/TIL/assets/img/2024-07-09-Top15PythonToolsforStunningNetworkGraphs_0.png)\n\n- GitHub: https://github.com/networkx/networkx\n- Documentation: https://networkx.org\n\n# Graph-tool\n\nGraph-tool은 네트워크 작업을 위한 Python 패키지입니다. 다음과 같은 작업을 수행할 수 있습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n1. 네트워크 데이터 다루기\n\n2. 네트워크에서 수학 문제 풀기\n","ogImage":{"url":"/assets/img/2024-07-09-Top15PythonToolsforStunningNetworkGraphs_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-Top15PythonToolsforStunningNetworkGraphs_0.png","tag":["Tech"],"readingTime":2}],"page":"22","totalPageCount":34,"totalPageGroupCount":2,"lastPageGroup":14,"currentPageGroup":1},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"22"},"buildId":"jKAIrnIuHBv4ZHjiQbX6i","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>