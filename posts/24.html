<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>TIL</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//posts/24" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="TIL" data-gatsby-head="true"/><meta property="og:title" content="TIL" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//posts/24" data-gatsby-head="true"/><meta name="twitter:title" content="TIL" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/7978fe7362f7d4c9.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/7978fe7362f7d4c9.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/873-eb138c3217d71553.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/posts/%5Bpage%5D-de1dc5579188f9be.js" defer=""></script><script src="/TIL/_next/static/Pi4433xRlbDszsHxI9gPN/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/Pi4433xRlbDszsHxI9gPN/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="파이썬에서 SOLID 원칙 적용하는 방법" href="/TIL/post/2024-07-09-SOLIDprinciplesinPython"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="파이썬에서 SOLID 원칙 적용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-09-SOLIDprinciplesinPython_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="파이썬에서 SOLID 원칙 적용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">파이썬에서 SOLID 원칙 적용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 9, 2024</span><span class="PostList_reading_time__6CBMQ">15<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="파이썬 함수 사용법을 일찍 배웠어야 했던 7가지 팁" href="/TIL/post/2024-07-09-7ThingsIShouldveLearntMuchEarlierForPythonFunctions"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="파이썬 함수 사용법을 일찍 배웠어야 했던 7가지 팁" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-09-7ThingsIShouldveLearntMuchEarlierForPythonFunctions_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="파이썬 함수 사용법을 일찍 배웠어야 했던 7가지 팁" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">파이썬 함수 사용법을 일찍 배웠어야 했던 7가지 팁</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 9, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Python을 사용한 PDF를 Word로 변환하는 5가지 방법 비교 가이드" href="/TIL/post/2024-07-09-5WaystoConvertPDFtoWordinPythonAComparisonGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Python을 사용한 PDF를 Word로 변환하는 5가지 방법 비교 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-09-5WaystoConvertPDFtoWordinPythonAComparisonGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Python을 사용한 PDF를 Word로 변환하는 5가지 방법 비교 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Python을 사용한 PDF를 Word로 변환하는 5가지 방법 비교 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 9, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Plotly Dash로 아름답고 상호작용하는 대시보드 레이아웃 만드는 방법 Python" href="/TIL/post/2024-07-09-HowtocreateabeautifulinteractivedashboardlayoutinPythonwithPlotlyDash"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Plotly Dash로 아름답고 상호작용하는 대시보드 레이아웃 만드는 방법 Python" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-09-HowtocreateabeautifulinteractivedashboardlayoutinPythonwithPlotlyDash_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Plotly Dash로 아름답고 상호작용하는 대시보드 레이아웃 만드는 방법 Python" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Plotly Dash로 아름답고 상호작용하는 대시보드 레이아웃 만드는 방법 Python</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 9, 2024</span><span class="PostList_reading_time__6CBMQ">36<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Python을 사용해 PDF에서 이미지 및 이미지 정보 추출하는 방법" href="/TIL/post/2024-07-09-ExtractImagesandImageInformationfromPDFwithPython"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Python을 사용해 PDF에서 이미지 및 이미지 정보 추출하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-09-ExtractImagesandImageInformationfromPDFwithPython_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Python을 사용해 PDF에서 이미지 및 이미지 정보 추출하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Python을 사용해 PDF에서 이미지 및 이미지 정보 추출하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 9, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="컴퓨터 비전으로 파이썬을 사용해 녹색 배경을 다른 이미지로 교체하는 방법" href="/TIL/post/2024-07-09-UsingPythontoconvertGreenbackgroundwithanotherImageComputerVision"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="컴퓨터 비전으로 파이썬을 사용해 녹색 배경을 다른 이미지로 교체하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-09-UsingPythontoconvertGreenbackgroundwithanotherImageComputerVision_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="컴퓨터 비전으로 파이썬을 사용해 녹색 배경을 다른 이미지로 교체하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">컴퓨터 비전으로 파이썬을 사용해 녹색 배경을 다른 이미지로 교체하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 9, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Python으로 머신러닝에서 불균형 데이터 다루는 방법" href="/TIL/post/2024-07-09-HowtoHandleImbalancedDataforMachineLearninginPython"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Python으로 머신러닝에서 불균형 데이터 다루는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-09-HowtoHandleImbalancedDataforMachineLearninginPython_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Python으로 머신러닝에서 불균형 데이터 다루는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Python으로 머신러닝에서 불균형 데이터 다루는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 9, 2024</span><span class="PostList_reading_time__6CBMQ">33<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="취미로 만든 파이썬 버전 관리 시스템 I Coded Pit 소개 " href="/TIL/post/2024-07-09-ICodedPitAVersionControlSysteminPythonforFun"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="취미로 만든 파이썬 버전 관리 시스템 I Coded Pit 소개 " loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-09-ICodedPitAVersionControlSysteminPythonforFun_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="취미로 만든 파이썬 버전 관리 시스템 I Coded Pit 소개 " loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">취미로 만든 파이썬 버전 관리 시스템 I Coded Pit 소개 </strong><div class="PostList_meta__VCFLX"><span class="date">Jul 9, 2024</span><span class="PostList_reading_time__6CBMQ">17<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="TensorFlow Transform 프로덕션에서 매끄러운 데이터 준비를 위한 필수 가이드" href="/TIL/post/2024-07-09-TensorFlowTransformEnsuringSeamlessDataPreparationinProduction"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="TensorFlow Transform 프로덕션에서 매끄러운 데이터 준비를 위한 필수 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-09-TensorFlowTransformEnsuringSeamlessDataPreparationinProduction_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="TensorFlow Transform 프로덕션에서 매끄러운 데이터 준비를 위한 필수 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">TensorFlow Transform 프로덕션에서 매끄러운 데이터 준비를 위한 필수 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 9, 2024</span><span class="PostList_reading_time__6CBMQ">18<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="모델 성능 시각화 Python 코드로 혼동 행렬 그리는 방법 가이드" href="/TIL/post/2024-07-09-VisualizingModelPerformanceAGuidetoPlottingConfusionMatricesinPythonCode"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="모델 성능 시각화 Python 코드로 혼동 행렬 그리는 방법 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-09-VisualizingModelPerformanceAGuidetoPlottingConfusionMatricesinPythonCode_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="모델 성능 시각화 Python 코드로 혼동 행렬 그리는 방법 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">모델 성능 시각화 Python 코드로 혼동 행렬 그리는 방법 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 9, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/TIL/posts/21">21</a><a class="link" href="/TIL/posts/22">22</a><a class="link" href="/TIL/posts/23">23</a><a class="link" href="/TIL/posts/24">24</a><a class="link" href="/TIL/posts/25">25</a><a class="link" href="/TIL/posts/26">26</a><a class="link" href="/TIL/posts/27">27</a><a class="link" href="/TIL/posts/28">28</a><a class="link" href="/TIL/posts/29">29</a><a class="link" href="/TIL/posts/30">30</a><a class="link" href="/TIL/posts/31">31</a><a class="link" href="/TIL/posts/32">32</a><a class="link" href="/TIL/posts/33">33</a><a class="link" href="/TIL/posts/34">34</a></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"파이썬에서 SOLID 원칙 적용하는 방법","description":"","date":"2024-07-09 14:45","slug":"2024-07-09-SOLIDprinciplesinPython","content":"\n![SOLID principles in Python](/TIL/assets/img/2024-07-09-SOLIDprinciplesinPython_0.png)\n\n# SOLID이란 무엇인가요?\n\n객체 지향 프로그래밍은 모든 프로그래머의 도구 상자에서 매우 유용한 도구입니다. 그러나 사용할 때 대부분의 사람들이 빠지는 흔한 함정이 있습니다.\n\nSOLID 원칙은 이러한 함정을 피하고 깔끔하고 유지보수 가능한 코드를 작성하는 데 도움이 되는 일련의 지침입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\"SOLID\"은 다음을 나타내는 머리글자입니다:\n\n- 단일 책임 원칙 (SRP)\n- 개방/폐쇠 원칙 (OCP)\n- 리스코프 치환 원칙 (LSP)\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 인터페이스 분리 원칙\n\n- 의존성 역전 원칙\n\n## 1. 단일 책임 원칙 (SRP)\n\n로버트 C. 마틴 (a.k.a 아저씨 밥)이 \"OOD의 원칙\"이라는 기사에서 만들어진 단일 책임 원칙은 다음과 같습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n한 클래스는 한 가지 책임만 가져야 합니다. 한 클래스가 여러 가지 일을 한다면, 여러 클래스로 분리해야 합니다.\n\n간단한 예를 통해 이를 설명해보겠습니다. 우리가 Google 드라이브 또는 Dropbox에서 객체를 읽고 쓰는 클래스가 있다고 가정해 봅시다.\n\n```js\nclass StorageClient:\n    _instance = None\n    _google_client = None\n    _dropbox_client = None\n\n    def __init__(self, google_credentials, dropbox_credentials) -\u003e None:\n        self._google_client = \"Google 클라이언트\"\n        self._dropbox_client = \"Dropbox 클라이언트\"\n\n    @classmethod\n    def get_or_create_instance(cls, google_credentials, dropbox_credentials) -\u003e \"StorageClient\":\n        if not cls._instance:\n            cls._instance = StorageClient(google_credentials, dropbox_credentials)\n\n        return cls._instance\n\n    def read_from_google(self, key):\n        ...\n\n    def upload_to_google(self, key, value):\n        ...\n\n    def read_from_dropbox(self, key):\n        ...\n\n    def upload_to_dropbox(self, key, value):\n        ...\n```\n\n이 클래스의 문제는 두 가지 책임을 가지고 있다는 점입니다. Google 드라이브 및 Dropbox에서 객체를 읽고 쓰는 데에 대한 별도의 로직을 구현해야 합니다. SRP를 준수하기 위해 이 클래스를 GoogleStorageClient와 DropboxStorageClient로 분리할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nclass GoogleStorageClient:\n    _instance = None\n    _google_client = None\n\n    def __init__(self, google_credentials) -\u003e None:\n        self._google_client = \"Google client\"\n\n    @classmethod\n    def get_or_create_instance(cls, google_credentials) -\u003e \"GoogleStorageClient\":\n        if not cls._instance:\n            cls._instance = GoogleStorageClient(google_credentials)\n\n        return cls._instance\n\n    def read(self, key):\n        ...\n\n    def upload(self, key, value):\n        ...\n\n\nclass DropboxStorageClient:\n    _instance = None\n    _dropbox_client = None\n\n    def __init__(self, dropbox_credentials) -\u003e None:\n        self._dropbox_client = \"Dropbox client\"\n\n    @classmethod\n    def get_or_create_instance(cls, dropbox_credentials) -\u003e \"DropboxStorageClient\":\n        if not cls._instance:\n            cls._instance = DropboxStorageClient(dropbox_credentials)\n\n        return cls._instance\n\n    def read(self, key):\n        ...\n\n    def upload(self, key, value):\n        ...\n```\n\n조금 더 상세하게 작성하더라도, 두 클라이언트를 개별적으로 개발하고 코드를 더 유지보수하기 쉽게 만듭니다. 예를 들어 Google 클라이언트를 작업하는 사람은 Dropbox 클라이언트의 작동 방식을 알 필요가 없으며 그 반대도 마찬가지입니다.\n\n## 2. 개방/폐쇄 원칙 (OCP)\n\n버트랜드 메이어는 1988년 저술한 \"객체지향 소프트웨어 구성\"에서 개방-폐쇄 원칙을 처음 제안한 것으로 일반적으로 알려져 있습니다. 그러나 1990년대에 이 원칙은 언클 밥이 1996년에 발표한 \"개방-폐쇄 원칙\"으로 현재의 형태로 재정의되었습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n개방/폐쇄 원칙은 다음을 의미합니다:\n\n클래스에 새 기능을 추가할 수 있어야 하며 기존 코드를 변경하지 않아도 됩니다.\n\n예를 들어, 다음 클래스는 개방/폐쇄 원칙을 위반합니다:\n\n```js\nclass Vehicle:\n    def __init__(self, vehicle_type, **kwargs) -\u003e None:\n        self.vehicle = vehicle_type\n        if self.vehicle_type == \"car\":\n            self.tires = kwargs[\"tires\"]\n            self.mode = kwargs[\"mode\"]\n        elif self.vehicle_type == \"boat\":\n            self.motors = kwargs[\"motors\"]\n            self.mode = kwargs[\"mode\"]\n\n    def get_specifications(self) -\u003e str:\n        if self.vehicle_type == \"car\":\n            return f\"This {self.vehicle_type} has {self.tires} tires and can drive on {self.mode}.\"\n        elif self.vehicle_type == \"boat\":\n            return f\"This {self.vehicle_type} has {self.motors} motors and can float on {self.mode}.\"\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 클래스의 문제점은 새로운 차량, 예를 들어 비행기를 추가하려면 기존 클래스를 수정해야 한다는 것입니다.\n\n기존 코드를 수정하는 것은 위험할 수 있으며 버그를 도입할 수도 있고 유닛 테스트를 실패할 수도 있습니다.\n\n대신 추상 기본 클래스를 정의하고 상속을 사용하여 클래스가 개방/폐쇄 원칙을 따르도록 할 수 있습니다.\n\n```js\nfrom abc import ABC, abstractmethod\n\nclass Vehicle(ABC):\n    def __init__(self, mode) -\u003e None:\n        self.mode = mode\n\n    @abstractmethod\n    def get_specifications(self) -\u003e str:\n        ...\n\nclass Car(Vehicle):\n    def __init__(self, tires) -\u003e None:\n        super().__init__(\"lane\")\n        self.tires = tires\n\n    def get_specifications(self) -\u003e str:\n        return f\"This car has {self.tires} tires and can drive on {self.mode}.\"\n\nclass Boat(Vehicle):\n    def __init__(self, motors) -\u003e None:\n        super().__init__(\"water\")\n        self.motors = motors\n\n    def get_specifications(self) -\u003e str:\n        return f\"This boat has {self.motors} motors and can float on {self.mode}.\"\n\nclass Plane(Vehicle):\n    def __init__(self, engines) -\u003e None:\n        super().__init__(\"air\")\n        self.engines = engines\n\n    def get_specifications(self) -\u003e str:\n        return f\"This plane has {self.engines} engines and can fly through the {self.mode}.\"\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 새 차량을 추가하고 싶다면, 단순히 Vehicle 클래스를 상속하고 get_specifications 메서드를 구현하는 새 클래스를 생성하면 됩니다.\n\n## 3. 리스코프 치환 원칙 (LSP)\n\n리스코프 치환 원칙은 1987년 OOPSLA 컨퍼런스에서 Barbara Liskov에 의해 소개되었습니다. 이 원칙은 다음과 같습니다:\n\n다시 말해, 만약 `S`가 `T`의 서브 클래스라면, `T` 타입의 객체를 `S` 타입의 객체로 대체할 수 있어야 하며, 프로그램의 기능을 변경하지 않아야 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예를 들어, 다음과 같은 클래스를 고려해보세요:\n\n```python\nclass Person:\n    def __init__(self, name, age) -\u003e None:\n        self.name = name\n        self.age = age\n\n    def get_name(self) -\u003e str:\n        return self.name\n\n    def vote(self, give_vote) -\u003e int:\n        if give_vote:\n            return 1\n        return 0\n\nclass Child(Person):\n    def __init__(self, name, age) -\u003e None:\n        super().__init__(name, age)\n\n    def vote(self) -\u003e None:\n        raise NotImplementedError(\"어린이는 투표할 수 없습니다.\")\n```\n\n이 코드의 문제는 Child 클래스가 리스코프 치환 원칙을 위반한다는 것입니다. Person 타입의 객체를 Child 타입의 객체로 대체하려고 하면, 예를 들어 vote 메서드를 사용하려고 할 때 프로그램이 예상대로 동작하지 않을 것입니다.\n\n이 문제를 해결하기 위해서는 Person을 추상 기본 클래스로 변환하고, 그것을 상속하는 Child와 Adult 두 클래스를 만들면 됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nfrom abc import ABC, abstractmethod\n\nclass Person(ABC):\ndef **init**(self, name, age) -\u003e None:\nself.name = name\nself.age = age\n\n    def get_name(self) -\u003e str:\n        return self.name\n\nclass Child(Person):\ndef **init**(self, name, age) -\u003e None:\nsuper().**init**(name, age)\n\n    def go_to_school(self) -\u003e None:\n        print(f\"{self.name} is going to school.\")\n\nclass Adult(Person):\ndef **init**(self, name, age) -\u003e None:\nsuper().**init**(name, age)\n\n    def vote(self) -\u003e int:\n        return 1\n\n이제 프로그램의 정확성에 영향을 주지 않고 Person 유형의 객체를 Child 또는 Adult 유형의 객체로 대체할 수 있습니다.\n\n## 4. Interface Segregation Principle (ISP)\n\n인터페이스 분리 원칙(Interface Segregation Principle, ISP)은 Uncle Bob이 만들었습니다. 이 원칙은 다음과 같이 설명합니다:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n큰 인터페이스를 피해야 합니다. 이는 모든 클라이언트가 구현하는 인터페이스 메서드를 사용하지 않는 대규모 인터페이스를 의미합니다.\n\n예를 들어, 다음과 같은 인터페이스를 고려해 보세요:\n\n```python\nfrom abc import ABC, abstractmethod\n\nclass Printer(ABC):\n    def scan(self) -\u003e None: ...\n\n    def fax(self) -\u003e None: ...\n\n    def print(self) -\u003e None: ...\n\n\nclass SimplePrinter(Printer):\n    def scan(self) -\u003e None:\n        raise NotImplementedError(\"This printer cannot scan.\")\n\n    def fax(self) -\u003e None:\n        raise NotImplementedError(\"This printer cannot fax.\")\n\n    def print(self) -\u003e None:\n        print(\"Printing...\")\n\n\nclass AdvancedPrinter(Printer):\n    def scan(self) -\u003e None:\n        print(\"Scanning...\")\n\n    def fax(self) -\u003e None:\n        print(\"Faxing...\")\n\n    def print(self) -\u003e None:\n        print(\"Printing...\")\n```\n\n이 경우, SimplePrinter 클래스는 scan 및 fax 메서드가 필요하지 않지만, Printer 인터페이스를 구현하므로 이들을 구현해야 합니다. 이는 인터페이스 격리 원칙을 위반하는 것입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그 대신, Printer 인터페이스를 Scanner, Fax 및 Printer 세 개의 별도의 인터페이스로 분리할 수 있습니다.\n\n```js\nfrom abc import ABC, abstractmethod\n\n\nclass Scanner(ABC):\n    @abstractmethod\n    def scan(self) -\u003e None:\n        ...\n\n\nclass Fax(ABC):\n    @abstractmethod\n    def fax(self) -\u003e None:\n        ...\n\n\nclass Printer(ABC):\n    @abstractmethod\n    def print(self) -\u003e None:\n        ...\n\n\nclass SimplePrinter(Printer):\n    def print(self) -\u003e None:\n        print(\"Printing...\")\n\n\nclass AdvancedPrinter(Scanner, Fax, Printer):\n    def scan(self) -\u003e None:\n        print(\"Scanning...\")\n\n    def fax(self) -\u003e None:\n        print(\"Faxing...\")\n\n    def print(self) -\u003e None:\n        print(\"Printing...\")\n```\n\n이제 SimplePrinter 클래스는 Printer 인터페이스만 구현하면 되고, AdvancedPrinter 클래스는 세 인터페이스를 모두 구현할 수 있습니다.\n\n이 방식을 통해 코드를 이해하기 쉽게 만들고 SimplePrinter 클래스에 불필요한 메서드가 필요 없어졌습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 5. 의존성 역전 원칙\n\n언클 밥이 만든 의존성 역전 원칙은 다음과 같습니다:\n\n이 원칙은 고수준 모듈과 저수준 모듈을 결합을 느슨하게 하기 위해 그들 사이에 추상화 계층을 도입하는 것에 관한 것입니다. 이를 통해 결합이 적고 유연한 시스템을 만들 수 있습니다.\n\n다음은 의존성 역전 원칙을 위반하는 예시입니다. 고수준 모듈인 PaymentService가 저수준 모듈인 PaypalProcessor에 직접 의존하는 것입니다:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nclass PaypalProcessor:\n    def process_payment(self, amount):\n        print(f\"Processing payment of ${amount} via PayPal\")\n\n\nclass PaymentService:\n    def __init__(self) -\u003e None:\n        self.payment_processor = PaypalProcessor()\n\n    def perform_payment(self, amount):\n        self.payment_processor.process_payment(amount)\n\n\npayment_service = PaymentService()\npayment_service.perform_payment(100)\n```\n\n만약 다른 결제 게이트웨이로 전환하고 싶다면, PaymentService 클래스를 수정해야 하는데 이는 개방-폐쇄 원칙을 위배합니다.\n\n대신, 우리가 결제를 처리하는 PaymentService 고수준 모듈과 PayPal, Stripe와 같은 다른 결제 게이트웨이와 상호 작용할 수 있는 추상 인터페이스인 PaymentProcessor가 있는 것으로 가정해 봅시다.\n\n```python\nfrom abc import ABC, abstractmethod\n\n\nclass PaymentProcessor(ABC):\n    @abstractmethod\n    def process_payment(self, amount):\n        pass\n\n\nclass PayPalPaymentProcessor(PaymentProcessor):\n    def process_payment(self, amount):\n        print(f\"Processing payment of ${amount} via PayPal\")\n\n\nclass StripePaymentProcessor(PaymentProcessor):\n    def process_payment(self, amount):\n        print(f\"Processing payment of ${amount} via Stripe\")\n\n\nclass PaymentService:\n    def __init__(self, payment_processor):\n        self.payment_processor = payment_processor\n\n    def perform_payment(self, amount):\n        self.payment_processor.process_payment(amount)\n\n\npaypal_processor = PayPalPaymentProcessor()\npayment_service = PaymentService(paypal_processor)\npayment_service.perform_payment(100)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이렇게하면 PaymentService 클래스는 특정 결제 프로세서 구현에 의존하지 않습니다. 대신 PaymentProcessor 인터페이스에 의존하고 있어서 PaymentService 클래스를 수정하지 않고도 다양한 결제 프로세서 간에 전환할 수 있습니다.\n\n# 결론\n\nSOLID 원칙은 깨끗하고 유지보수 가능하며 유연한 코드를 작성하는 데 도움이 되는 일련의 지침입니다. 이러한 원칙을 따르면 이해하기 쉬우며 테스트하고 유지하기 쉬운 코드를 만들 수 있습니다. 이러한 원칙에 적응하는 데는 시간이 걸릴 수 있지만, 확실히 더 나은 프로그래머가 되고 더 나은 소프트웨어를 만들 수 있도록 도와줄 것입니다. 이들은 가이드라인이며 절대적인 규칙이 아니므로 현명하게 사용하고 특정 요구사항에 맞게 적용하십시오.\n","ogImage":{"url":"/assets/img/2024-07-09-SOLIDprinciplesinPython_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-SOLIDprinciplesinPython_0.png","tag":["Tech"],"readingTime":15},{"title":"파이썬 함수 사용법을 일찍 배웠어야 했던 7가지 팁","description":"","date":"2024-07-09 14:44","slug":"2024-07-09-7ThingsIShouldveLearntMuchEarlierForPythonFunctions","content":"\n![이미지](/TIL/assets/img/2024-07-09-7ThingsIShouldveLearntMuchEarlierForPythonFunctions_0.png)\n\n파이썬에 대한 내 이해력이 더 좋았을 텐데, 이런 것들을 내 여정에서 이른 시일 내에 어떻게든 배웠더라면 훨씬 더 좋았을 텐데요. 하지만 인생은 인생대로이고, 늦게 배우는 것은 결코 늦기보다는 낫습니다.\n\n# 1) 타입 힌팅\n\n```python\ndef magic(a, b):\n  return a + b\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파이썬은 동적으로 타입이 지정되기 때문에 변수 데이터 유형이 실행 중에 결정되어서 저렇게 함수를 작성할 수 있습니다.\n\n```js\ndef magic(a:int, b:int) -\u003e int:\n  return a + b\n```\n\n^ 위와 똑같은 함수를 작성하지만, 타입 힌트를 추가했습니다.\n\n- a는 정수여야 합니다.\n- b는 정수여야 합니다.\n- 함수의 반환 값도 정수여야 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n코드베이스가 커질수록 타입 힌팅은 우리 코드를 가능한 한 사람이 읽기 쉽게 만드는 데 매우 중요해집니다. 1만 개의 함수가 있다고 상상해보세요. 이때 이 함수들이 어떤 데이터 유형을 취하는지와 반환하는 유형을 추론해야 한다면 정말 즐겁지 않을 것입니다.\n\n```js\ndef test1(ls: list[int], x:float) -\u003e list[float]:\n  # 작업들\n```\n\n^ ls는 float의 리스트여야 하고, x는 float이어야 하며, 이 함수는 float의 리스트를 반환해야 합니다\n","ogImage":{"url":"/assets/img/2024-07-09-7ThingsIShouldveLearntMuchEarlierForPythonFunctions_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-7ThingsIShouldveLearntMuchEarlierForPythonFunctions_0.png","tag":["Tech"],"readingTime":2},{"title":"Python을 사용한 PDF를 Word로 변환하는 5가지 방법 비교 가이드","description":"","date":"2024-07-09 14:43","slug":"2024-07-09-5WaystoConvertPDFtoWordinPythonAComparisonGuide","content":"\n![image](/TIL/assets/img/2024-07-09-5WaystoConvertPDFtoWordinPythonAComparisonGuide_0.png)\n\nPDF 문서를 편집 가능한 Microsoft Word 파일로 변환하면 변경 사항을 가할 수 있고 주석을 추가하며 PDF 콘텐츠에 대해 더 효율적으로 협업할 수 있습니다.\n\n이 블로그 포스트에서는 무료 오픈 소스 라이브러리 또는 상용 라이브러리를 사용하여 Python에서 PDF를 Word로 변환하는 5가지 솔루션을 모아서 각 솔루션의 장단점을 강조했습니다.\n\n- PyPDF2 및 python-docx를 사용하여 PDF를 Word로 변환\n- pdfplumber 및 python-docx를 사용하여 PDF를 Word로 변환\n- pdf2docx를 사용하여 PDF를 Word로 변환\n- Spire.PDF for Python을 사용하여 PDF를 Word로 변환\n- .NET을 통해 Aspose.Words for Python을 사용하여 PDF를 Word로 변환\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## PyPDF2와 python-docx를 사용하여 PDF를 Word로 변환하기\n\nPyPDF2는 Python에서 PDF 파일을 다루는 데 사용하는 무료 오픈 소스 라이브러리로, PDF 문서를 읽고 조작하며 처리하는 다양한 기능을 제공합니다.\n\npython-docx는 Microsoft Word (.docx) 파일을 생성하고 업데이트하는 데 사용하는 무료 오픈 소스 라이브러리입니다.\n\nPyPI를 통해 이들을 설치하려면 다음과 같은 pip 명령을 사용하십시오.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\npip install PyPDF2\npip install python-docx\n```\n\n코드 예시:\n\n```js\nfrom PyPDF2 import PdfReader\nfrom PyPDF2 import PdfWriter\nfrom docx import Document\nfrom docx.shared import Inches\n\n# 새 Word 문서 생성\ndocument = Document()\n\n# PDF 파일 열기\nwith open(\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\Input.pdf\", \"rb\") as file:\n\n    # PdfReader 객체 생성\n    pdf_reader = PdfReader(file)\n\n    # 쓰기용으로 Word 문서 열기\n    with open(\"output.docx\", \"wb\") as output_file:\n\n        # 각 페이지를 순환하며\n        for page_num in range(len(pdf_reader.pages)):\n\n            # 현재 페이지 가져오기\n            page = pdf_reader.pages[page_num]\n\n            # 페이지에서 텍스트 추출\n            text = page.extract_text()\n\n            # 텍스트를 담는 단락을 Word에 추가\n            document.add_paragraph(text)\n\n# Word 문서 저장\ndocument.save(\"output.docx\")\n```\n\n장점:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 무료입니다.\n\n단점:\n\n- 텍스트만 추출되어 워드 문서에 삽입됩니다.\n- 원본 PDF 파일의 모든 서식과 레이아웃이 손실됩니다.\n\n## pdfplumber와 python-docx를 이용해 PDF를 워드로 변환하기\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\npython-docx은 Microsoft Word (.docx) 파일을 만들고 업데이트하기 위한 무료 오픈소스 라이브러리입니다.\n\npdfplumber는 PDF 파일로부터 텍스트와 테이블을 추출하기 위한 무료 오픈소스 Python 라이브러리입니다.\n\n아래 명령어를 통해 PyPI를 통해 이를 설치할 수 있습니다.\n\n```js\npip install pdfplumber\npip install python-docx\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 코드 예시입니다:\n\n```js\nimport pdfplumber\nfrom docx import Document\nfrom docx.shared import Inches\n\n# PDF 파일 열기\nwith pdfplumber.open(\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\Input.pdf\") as pdf:\n\n    # PDF에서 텍스트 추출\n    text = \"\"\n    for page in pdf.pages:\n        text += page.extract_text()\n\n# 새 Word 문서 생성\ndocument = Document()\n\n# 문서에 텍스트가 들어갈 단락 추가\ndocument.add_paragraph(text)\n\n# Word 문서 저장\ndocument.save(\"output.docx\")\n```\n\n장점:\n\n- 무료입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n**단점:**\n\n- 텍스트만 추출되어 워드 문서에 들어가게 됩니다.\n- 원본 PDF 파일의 모든 서식과 레이아웃이 사라집니다.\n\n## pdf2docx를 사용하여 PDF를 워드로 변환하기\n\npdf2docx는 PDF 파일을 Microsoft Word (.docx) 문서로 간단하고 효율적으로 변환하는 방법을 제공하는 Python 라이브러리입니다. 이는 문서 변환, 데이터 추출 및 텍스트 처리와 같은 여러 목적으로 사용할 수 있는 무료 오픈 소스 라이브러리입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음 pip 명령을 사용하여 PyPI에서 설치할 수 있습니다.\n\n```js\npip install pdf2docx\n```\n\n코드 예시:\n\n```js\nfrom pdf2docx import Converter\n\ndef convert_pdf_to_docx(pdf_file, docx_file):\n\n    # Converter 객체 생성\n    cv = Converter(pdf_file)\n\n    # 지정된 PDF 페이지를 docx로 변환\n    cv.convert(docx_file, start=0, end=None)\n    cv.close()\n\n# PDF를 Docx 파일로 변환\nconvert_pdf_to_docx(\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\Input.pdf\", \"Output.docx\")\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n장점:\n\n- 무료입니다.\n- 텍스트 및 그래픽 요소가 모두 변환됩니다.\n- 형식 및 레이아웃이 유지됩니다.\n\n단점:\n\n- 상업용 라이브러리를 사용하는 것보다 복잡한 PDF 문서를 변환하는 데 시간이 조금 더 소요됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Spire.PDF를 사용하여 PDF를 Word로 변환하기\n\nSpire.PDF for Python은 Python에서 PDF 문서를 처리하는 기능이 풍부한 라이브러리입니다. PDF 파일을 프로그래밍적으로 만들거나 수정하거나 조작하기 위한 다양한 도구를 제공합니다.\n\nPyPI에서 다음 pip 명령어를 사용하여 설치할 수 있습니다.\n\n```js\npip install Spire.PDF\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n코드 예시:\n\n```python\nfrom spire.pdf.common import *\nfrom spire.pdf import *\n\n# PdfDocument 객체 생성\ndoc = PdfDocument()\n\n# PDF 문서 불러오기\ndoc.LoadFromFile(\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\Input.pdf\")\n\n# 스트리밍 레이아웃으로 PDF를 Word로 변환\n# doc.ConvertOptions.SetPdfToDocOptions(True, True)\n\n# docx 파일로 변환\ndoc.SaveToFile(\"Output.docx\", FileFormat.DOCX)\n\n# 리소스 해제\ndoc.Close()\n```\n\n장점:\n\n- 텍스트와 그래픽 요소가 모두 변환됩니다.\n- 서식과 레이아웃이 보존됩니다(고정 페이지 레이아웃 모드에서).\n- 변환 속도가 빠릅니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n단점:\n\n- 최저 수준의 라이선스 비용은 $999입니다.\n\n## Aspose.Words for Python을 사용하여 PDF를 Word로 변환하기\n\nAspose.Words for Python via .NET은 Python을 통해 Microsoft Word 문서(.docx, .doc)를 조작하고 변환하는 상용 라이브러리입니다. 또한 PDF 및 HTML과 같은 다른 형식을 Word 형식으로 변환하는 기능도 지원합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테이블 태그를 Markdown 형식으로 변경해보세요.\n\n| Header One | Header Two |\n| ---------- | ---------- |\n| Data 1     | Data 2     |\n| Data 3     | Data 4     |\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n장점:\n\n- 텍스트 및 그래픽 요소가 모두 변환됩니다.\n- 형식과 레이아웃이 보존됩니다.\n- 변환 속도가 빠릅니다.\n\n단점:\n\n- 가장 낮은 수준의 라이선스 비용은 $1199입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 결론\n\n무료이자 오픈 소스인 라이브러리를 사용하면 Python을 활용해 PDF 및 Word 문서를 처리할 수 있어 편리하며, 라이선스나 비용에 대한 걱정 없이 사용할 수 있습니다. 상업용 솔루션은 일반적으로 무료이자 오픈 소스인 라이브러리보다 더 고급 기능을 제공하며 더 나은 성능을 보장합니다. 이러한 옵션 중 어떤 것을 선택할지는 당신의 특정 요구 사항, 예산 및 필요한 기능 수준에 따라 다를 것입니다.\n\n## 관련 자료\n\nPython에서 PDF에 주석 달기의 8가지 방법\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파이썬에서 PDF 파일을 나누고 병합하기\n\n파이썬에서 PDF의 텍스트 추출하기\n\n파이썬에서 PDF에서 이미지 추출하기\n","ogImage":{"url":"/assets/img/2024-07-09-5WaystoConvertPDFtoWordinPythonAComparisonGuide_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-5WaystoConvertPDFtoWordinPythonAComparisonGuide_0.png","tag":["Tech"],"readingTime":9},{"title":"Plotly Dash로 아름답고 상호작용하는 대시보드 레이아웃 만드는 방법 Python","description":"","date":"2024-07-09 14:39","slug":"2024-07-09-HowtocreateabeautifulinteractivedashboardlayoutinPythonwithPlotlyDash","content":"\n파이썬으로 만들어진 대시보드는 인상적인 디자인, 독특한 상호작용 및 최고의 처리 속도를 가질 수 있습니다. 그건 멋지게 들리지만, 주의할 점이 있어요: 생성 과정은 그다지 간단하지 않고 많은 함정이 숨어 있습니다. 이 기사는 대시보드 생성의 첫 번째 단계인 레이아웃 디자인에 주로 초점을 맞춥니다. 대시보드 그리드를 개발하고, 컨테이너, 텍스트 블록, 버튼, 드롭다운, 이미지 및 출력 양식과 같은 모든 기본 레이아웃 요소를 생성하고 스타일을 적용하는 방법을 살펴볼 것입니다.\n\n우리가 점진적으로 만들어 나갈 대시보드 프로토타입은 최근 Dash Example App Gallery에 포함된 내 Global Precious Metals and Stones Export Research 대시보드에서 영감을 받았습니다. 입구 페이지의 모든 주요 요소가 어떻게 생성되었는지에 대해 자세히 알아볼 것입니다.\n\n우리가 최종으로 얻게 될 모습은 이렇습니다:\n\n![How to create a beautiful interactive dashboard layout in Python with Plotly Dash](/TIL/assets/img/2024-07-09-HowtocreateabeautifulinteractivedashboardlayoutinPythonwithPlotlyDash_0.png)\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n대시보드를 이미지 그대로 재현하려면 Poppins 글꼴이 설치되어 있어야 합니다. 일부 컴퓨터는 기본적으로 이 글꼴을 가지고 있을 수 있지만, 만약 설치가 필요하다면 여기서 다운로드할 수 있습니다.\n\n그러면 레이아웃 생성을 시작해 보겠습니다!\n\nGitHub 리포지토리를 사용하여 함께 따라오실 수 있습니다.\n\n## 패키지 설치하기\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n일반적으로, Dash에서는 대시보드를 만드는 것이 아니라 대시보드처럼 보이는 완전한 웹 애플리케이션을 만드는 것입니다. 따라서 생성 프로세스는 웹 페이지의 생성과 매우 유사합니다.\n\n레이아웃을 만들기 위해 다음과 같은 여러 요소 세트를 사용할 것입니다:\n\n- 대시보드 구조를 개발하는 데 사용되는 HTML 요소;\n- 외관을 정의하는 CSS;\n- 사전 설계된 Dash 및 Bootstrap 구성 요소로 생성 프로세스를 용이하게 하는 데 사용되는 것입니다.\n\n그래프를 그리려면 Numpy, Random 및 Plotly 라이브러리가 필요합니다. Plotly는 Dash와 함께 설치되고 Random은 Python과 함께 설치되므로 Numpy가 이미 설치되어 있지 않은 경우에만 설치하면 됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\npip install dash\npip install dash-bootstrap-components\npip install numpy\n```\n\n여기서 모든 작업은 Jupyter Notebook에서 이루어질 거에요.\n\n```js\nfrom dash import Dash, html, dcc\nimport dash_bootstrap_components as dbc\n```\n\n레이아웃을 만들기 위해 필요한 모든 패키지를 방금 설치했어요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Dash를 사용하여 우리 애플리케이션을 출시할 거에요.\n- Dash에서의 HTML 컴포넌트는 HTML 태그와 유사해요. 예를 들어, Dash 명령어인 html.Div(), html.P(), 또는 html.Img()는 각각 `div`, `p`, 또는 `img`를 나타내요. 여기서 모든 컴포넌트 목록이 있어요.\n- Dash 코어 컴포넌트 (DCC)는 준비된 상호작용 요소인 그래프, 드롭다운, 버튼 또는 임시 저장소를 저장해요. 즉, dcc.Dropdown()이나 dcc.Graph() 명령어를 적용하여 각각 드롭다운을 생성하거나 Plotly 그래프를 호출할 수 있어요. 가능한 모든 컴포넌트가 여기 나와 있어요.\n- Dash Bootstrap 컴포넌트 (DBC)는 많은 경우 HTML 및 DCC 요소, 심지어 전체 CSS 파일을 효과적으로 대체할 수 있어요. 우리는 DBC 명령어를 사용하여 대시보드 본문, 모든 버튼, 그리고 전반적인 페이지 스타일링을 설정할 거에요. Dash Bootstrap 요소에 대해 더 많이 읽어볼 수 있는 곳이 있어요.\n\n## 중첩 대시보드 구조\n\n본질적으로, Dash 애플리케이션은 중첩된 직사각형 DIV 컨테이너 구조에요. 이러한 컨테이너에는 그래프, 텍스트, 이미지 및 탐색 요소들을 배치해요. 배경을 고려하면, 우리 페이지는 여러 레이어로 구성되어 있어요:\n\n![대화형 대시보드 레이아웃을 만드는 방법](/TIL/assets/img/2024-07-09-HowtocreateabeautifulinteractivedashboardlayoutinPythonwithPlotlyDash_1.png)\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 애플리케이션 시작하기\n\n대시보드를 만드는 것부터 시작해봅시다. 우선, 대시 애플리케이션을 실행해 봅시다:\n\n```js\napp = Dash(__name__);\n```\n\n그 다음으로 레이아웃을 만들어봅니다; 현재는 빈 DIV 컨테이너입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\napp.layout = html.Div();\n```\n\n이제 개발 서버를 디버그 모드로 실행할 수 있습니다:\n\n```js\nif __name__ == \"__main__\":\n    app.run_server(debug=True, port=8050)\n```\n\n결과 코드를 실행해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\napp = Dash(__name__)\napp.layout = html.Div()\nif __name__ == \"__main__\":\n    app.run_server(debug=True, port=8050)\n```\n\n저희 애플리케이션이 생성되었습니다! 지금은 빈 페이지일 뿐입니다. 주피터 노트북을 사용하신다면 바로 출력 창에서 확인하실 수 있고, 개발 서버인 http://127.0.0.1:8050/에서 전체 화면으로 확장할 수도 있습니다.\n\n서버 링크의 마지막 네 자리는 포트 번호입니다; 기본값은 8050입니다. 앱이 개발 중일 때 업데이트가 중지된 경우, 애플리케이션 코드와 링크에 다른 포트 번호를 넣어주시면 됩니다 — 예를 들어, 8051입니다.\n\n## 대시보드 본문 만들기\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n대시보드 본문을 만들기 위해 Bootstrap 컨테이너를 사용할 것입니다. 이는 대시보드 그리드의 최상위 요소로서, 너비를 설정하고 모든 하위 요소를 \"포함\"합니다. 우리의 임시 html.Div()를 dbc.Container()으로 교체하세요. 대시보드가 브라우저 창의 너비를 100% 차지하도록 하려면 fluid=True로 설정하여 fluid 해야합니다.\n\n```js\napp.layout = dbc.Container((fluid = True));\n```\n\n화면에 컨테이너가 나타나려면 무언가를 포함해야하므로 일시적으로 일부 텍스트를 넣어봅시다. 먼저 텍스트를 html.P() 요소로 감싸주세요. HTML `p` 태그와 유사한 요소이며, 그런 다음 컨테이너 내에 배치하세요.\n\n```js\napp.layout = dbc.Container(html.P(\"내 멋진 대시보드가 여기에 나타납니다.\"), (fluid = True));\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n앱을 업데이트하고 와우! 우리의 컨테이너 내용을 볼 수 있어요. 아직까지는 꽤 평범해 보이니 대시보드를 스타일링하는 것부터 시작해 볼까요?\n\n## 대시보드가 어떻게 스타일링되는지\n\n우리 앱의 각 부분인 컨테이너, 네비게이션 요소 또는 텍스트는 길이와 너비, 색상, 폰트, 들여쓰기 등 특정한 스타일을 가질 수 있어요. 전체 앱에 대한 일반적인 스타일링 규칙은 특별한 사용자 정의 CSS 파일에 설정되고, 개별 요소의 스타일은 사용자 정의 CSS 및 앱 코드에 자세히 기재할 수 있어요.\n\n먼저 사용자 정의 CSS를 만들어 보겠어요. 주피터 노트북(또는 코드)이 실행되는 동일한 폴더에 \"assets\" 폴더를 생성한 다음 그 안에 빈 텍스트 파일을 만들어 \"style.css\"로 저장하세요. 이 파일에서 대시보드 요소들의 모습을 자세히 설명할 거예요. 파일을 열어보겠어요.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n대시보드 요소와 해당 CSS 스타일을 연결하려면 클래스 또는 ID를 제공합니다:\n\n- 클래스는 요소나 여러 요소 그룹에 지정하여 스타일을 적용합니다.\n- ID는 고유한 대시보드 요소에 할당되어 해당 요소의 스타일을 설정하거나 상호작용을 구성합니다.\n\n요소에는 클래스와 ID를 둘 다 할당할 수 있으며, 후자가 \"강력\"합니다. 즉, 컨테이너의 클래스 \"red\"가 빨간색을 지정하고 ID \"blue\"가 파란색을 지정한다면 컨테이너는 빨간색이 아니라 파란색이 됩니다.\n\n특정 HTML 태그의 모든 요소에 스타일을 지정할 수도 있습니다. 예를 들어 모든 텍스트 (`p`)나 전체 페이지 (`body`)에 대해 클래스나 ID를 지정하지 않고 스타일을 할당할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n대시보드의 본문을 스타일링하려면 클래스를 제공합니다. 클래스는 대시보드의 컨테이너 내에 설정되며, 다른 내용과 쉼표로 구분됩니다:\n\n```js\napp.layout = dbc.Container(\n  html.P(\"내 멋진 대시보드가 여기에 있을 거예요.\"),\n  (fluid = True),\n  (className = \"대시보드-컨테이너\")\n);\n```\n\n코드를 저장한 후 CSS 파일로 넘어가 보겠습니다. 클래스에 스타일을 설정하려면 그 이름 앞에 점(.)을 붙입니다: .대시보드-컨테이너. 여기서 대시보드의 너비와 높이 (1400x800), 정렬, 들여쓰기, 색상 (배경색), 테두리 (border), 모서리를 둥근 모양으로 만드는 속성을 설정했습니다. 이 모두는 잘 알려진 CSS 스타일링 요소이며, 오픈 소스 문서에서 많은 정보를 찾을 수 있습니다. 지금은 이 스타일링 조각을 style.css 파일에 넣고 저장한 다음 어플리케이션이 어떻게 변하는지 확인해보세요.\n\n```js\n.대시보드-컨테이너 {\n    width: 1400px;\n    height: 800px;\n    margin-left: auto;\n    margin-right: auto;\n    margin-top: 50px;\n    margin-bottom: 50px;\n    background-color: #010103;\n    border: 1px solid #cccccc;\n    border-radius: 10px;\n}\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n대시보드 본문의 스타일은 설정되었지만, 배경과 플레이스홀더 텍스트는 어떻게 되나요?\n\n우리의 배경은 웹 페이지 자체입니다. 스타일은 대시 컴포넌트가 아닌 표준 HTML `body` 태그에 의해 결정되고 클래스를 도입할 필요가 없습니다. SlateGray 색상으로 지정해봅시다.\n\n```js\nbody {\n    background-color: #708090;\n}\n```\n\n기억하세요, 우리는 placeholder 텍스트를 html.P() 태그로 감쌌습니다. 이를 스타일링하기 위해 모든 `p` 요소(즉, 텍스트)를 한꺼번에 스타일링할 수 있습니다. 클래스를 도입할 필요가 없으며, 서로 다른 스타일로 여러 html.P() 텍스트를 만들려면 각각 클래스를 생성해야 합니다. 우리의 텍스트를 흰색 Poppins 글꼴로 그리고 여백을 설정해봅시다. 모든 여백은 부모 컨테이너부터 측정됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\np {\n    font-family: 'Poppins';\n    color: #ffffff;\n    margin-left: 30px;\n    margin-top: 30px;\n}\n```\n\n우리의 CSS 파일은 이제 다음과 같아야 합니다:\n\n```js\nbody {\n    background-color: #708090;\n}\n\n.dashboard-container {\n    width: 1400px;\n    height: 800px;\n    margin-left: auto;\n    margin-right: auto;\n    margin-top: 50px;\n    margin-bottom: 50px;\n    background-color: #010103;\n    border: 1px solid #cccccc;\n    border-radius: 10px;\n}\n\np {\n    font-family: 'Poppins';\n    color: #ffffff;\n    margin-left: 30px;\n    margin-top: 30px;\n}\n```\n\n저장하고 앱으로 돌아가세요. 스타일이 자동으로 업데이트 되지 않으면 페이지를 새로 고침하세요. 우리 대시보드의 본문과 배경이 준비되었어요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/TIL/assets/img/2024-07-09-HowtocreateabeautifulinteractivedashboardlayoutinPythonwithPlotlyDash_2.png)\n\n## 기본 스타일을 사용하는 방법 및 왜 설정해야 하는가?\n\n부트스트랩에는 응용 프로그램이 시작될 때 설치할 수 있는 미리 디자인된 스타일이 있습니다. 모든 가능한 옵션에 대한 링크는이 페이지의 마지막 섹션에 나열되어 있습니다. 각 스타일 페이지는 적용 후 응용 프로그램의 모든 요소가 어떻게 보일지 보여줍니다.\n\n기본 스타일을 설정하려면, 응용 프로그램을 시작할 때 대괄호 안에 명시합니다. 여기에서 Flatly 스타일로 지정한 것처럼요:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\napp = Dash(__name__, (external_stylesheets = [dbc.themes.FLATLY]));\n```\n\n기본 스타일을 설정하면 나만의 것을 만들 때 많은 시간을 절약할 수 있어요. 이는 사실 Bootstrap에서 생성된 미리 만들어진 사용자 정의 CSS 파일입니다. 응용 프로그램을 시작할 때 이를 설정하면 응용 프로그램의 요소들이 이 CSS 파일에 지정된 스타일과 연결됩니다.\n\n그러나 응용 프로그램에는 여러 개의 CSS 파일이 있을 수 있어요! 기본 스타일을 설정하고 나서 자신만의 사용자 정의 CSS 파일을 자산 폴더에 추가하면 응용 프로그램은 계층 구조에 따라 두 가지 CSS 파일을 따라갑니다: 먼저 우리의 사용자 정의 파일에서 요소의 스타일을 찾은 다음 Bootstrap 파일에서 찾아요.\n\n어떻게 작동하는지 보고 싶나요? 잠시 style.css를 style.txt로 저장해서, Dash가 그것을 \"보지\" 못하도록 해보세요. 어떻게 앱이 변하는지 확인해보세요. 이제 페이지가 \"Flatly\" 스타일로 디자인되었어요.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nCSS 계층 구조를 알면 어떤 장점이 있을까요? 이를 알면 우리에게 가장 적합한 기본 스타일을 설정하고, 그 다음에는 완전히 새로운 스타일을 처음부터 만드는 대신 우리 자신의 CSS 파일에서 일부 요소를 맞춤 설정할 수 있습니다.\n\n## 개별 대시보드 요소 스타일링\n\n또한 앱에서 직접 각 개별 요소를 스타일링할 수 있습니다. 이 스타일은 사용자 정의 CSS와 Bootstrap CSS보다 우선순위가 높습니다. 예를 들어 대시보드의 색상을 흰색으로, 테두리 색상을 검정색으로, 텍스트 색상을 검정색으로 변경해 볼 수 있습니다. 이를 위해 새로운 색상을 포함하는 스타일 딕셔너리를 dbc.Container() 및 html.P() 안에 넣어주면 됩니다.\n\n```js\napp.layout = dbc.Container(\n  html.P(\"내 멋진 대시보드가 여기에 있을 거예요.\", (style = { color: \"#010103\" })),\n  (fluid = True),\n  (className = \"dashboard-container\"),\n  (style = {\n    \"background-color\": \"#ffffff\",\n    \"border-color\": \"#010103\",\n  })\n);\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 대시보드 구성하기\n\n그래서, 우리는 대시보드의 본문을 갖게 되었습니다. 이제 DIV 컨테이너를 겹쳐 놓기 시작합시다.\n\n첫 번째 DIV 컨테이너의 층은 대시보드를 네비게이션 바와 콘텐츠(우리의 경우에는 그래프 및 출력)로 나눕니다.\n\n![대시보드 구성](/TIL/assets/img/2024-07-09-HowtocreateabeautifulinteractivedashboardlayoutinPythonwithPlotlyDash_3.png)\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위 코드에서 placeholder 텍스트를 제거하고 대신 두 개의 DIV 컨테이너 목록을 넣어봅시다.\n\n```js\napp.layout = dbc.Container([html.Div(), html.Div()], (fluid = True), (className = \"dashboard-container\"));\n```\n\n이제 컨테이너의 매개변수를 명확히해 봅시다:\n\n너비와 높이. 우리는 대시보드를 수평으로 나누었고, 기본적으로 자식 컨테이너의 높이는 부모의 100%가 됩니다. 각 컨테이너의 너비는 스타일 사전에서 픽셀로(“140px” 또는 단순히 140) 또는 부모 컨테이너의 너비의 백분율로(“10%”) 지정합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n들여쓰기입니다. 여백 크기도 픽셀로 지정하거나 컨테이너 크기의 백분율로 지정할 수 있습니다. 모든 변에 여백을 설정할 수 있습니다(margin: 25) 또는 특정 변에만 설정할 수 있습니다(margin-left: 25). 자식 컨테이너와 여백의 총 너비가 부모 컨테이너의 너비를 초과하지 않도록 주의하세요.\n\n정렬입니다. 자식 컨테이너를 정렬하려면 부모 컨테이너의 스타일 사전에서 'display' 옵션을 사용합니다. 수평으로 정렬하려면 \"flex\"로 지정하고, 수직으로 정렬하려면 \"block\"으로 지정하세요.\n\n```js\napp.layout = dbc.Container(\n  [\n    html.Div(\n      (style = {\n        width: 340,\n        \"margin-left\": 35,\n        \"margin-top\": 35,\n        \"margin-bottom\": 35,\n      })\n    ),\n    html.Div(\n      (style = {\n        width: 990,\n        \"margin-top\": 35,\n        \"margin-right\": 35,\n        \"margin-bottom\": 35,\n      })\n    ),\n  ],\n  (fluid = True),\n  (style = { display: \"flex\" }),\n  (className = \"dashboard-container\")\n);\n```\n\n첫 번째 층의 자식 컨테이너가 생성되었습니다. 두 번째로 넘어가봅시다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/TIL/assets/img/2024-07-09-HowtocreateabeautifulinteractivedashboardlayoutinPythonwithPlotlyDash_4.png)\n\n왼쪽 \"네비게이션\" 컨테이너는 네 개의 부분으로 나뉩니다: 대시보드 제목 및 설명, 버튼 막대, 드롭다운 메뉴 막대 및 이미지입니다. 그래서 네 개의 빈 DIV 컨테이너 목록을 넣어봅시다.\n\n대시보드의 오른쪽 부분은 그래프와 해당 출력으로 구성되어 있어서 두 개의 DIV 목록을 넣을 것입니다. 그래프와 출력 패널의 너비는 대략 80 대 20의 비율이 되어야 합니다. 부모 DIV의 display 매개변수를 \"flex\"로 설정하여 이를 가로로 정렬합니다.\n\n```js\napp.layout = dbc.Container(\n  [\n    html.Div(\n      [html.Div(), html.Div(), html.Div(), html.Div()],\n      (style = {\n        width: 340,\n        \"margin-left\": 35,\n        \"margin-top\": 35,\n        \"margin-bottom\": 35,\n      })\n    ),\n    html.Div(\n      [html.Div((style = { width: 790 })), html.Div((style = { width: 200 }))],\n      (style = {\n        width: 990,\n        \"margin-top\": 35,\n        \"margin-right\": 35,\n        \"margin-bottom\": 35,\n        display: \"flex\",\n      })\n    ),\n  ],\n  (fluid = True),\n  (style = { display: \"flex\" }),\n  (className = \"dashboard-container\")\n);\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 텍스트 형식 지정\n\n이 수준에서는 이미 대시보드에 콘텐츠를 채워 넣을 수 있습니다. 네비게이션 패널의 상단 컨테이너에는 대시보드 제목과 소개 텍스트가 있습니다. 대시보드에서 헤딩은 일반적으로 html.H1(), html.H2(), ... html.H6() 명령을 사용하여 지정되며, 이는 HTML의 `h1`, `h2`, ... `h6` 태그와 유사합니다.\n\n대시보드에는 헤더와 하나의 종류의 서브헤더만 있는데, 공통 태그를 사용하고 클래스나 ID를 도입하지 않아도 됩니다.\n\n헤더와 소개 텍스트를 상단 DIV 컨테이너에 html.H1() 및 html.P() 요소의 목록으로 넣으세요:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nhtml.Div([\n  html.H1(\"Welcome to my beautiful dashboard!\"),\n  html.P(\"This dashboard prototype shows how to create an effective layout.\"),\n]);\n```\n\n이제 CSS로 이동하여 주요 헤더인 h1에 스타일을 만들고, p에 대한 하나를 다음과 같이 수정하세요:\n\n```js\nh1 {\n    font-family: \"Poppins\";\n    color: #ffffff;\n    font-size: 35px;\n    margin: 15px;\n}\n\np {\n    font-family: \"Poppins\";\n    color: #ffffff;\n    font-size: 16px;\n    margin: 15px;\n    text-align: justify;\n}\n```\n\nCSS를 저장한 후에도 제목이 어떻게 보이는지 개선하고 싶어졌고, 이제 앱 코드에서 직접 수정하겠습니다. 먼저, 텍스트 컨테이너 요소를 상단에 맞추기 위해 '수직 정렬' 매개변수를 설정합니다. 둘째, 대시보드 높이의 3분의 1 정도로 컨테이너의 높이를 수정하여 텍스트를 네비게이션에서 명확하게 분리합니다. 마지막으로 html.Span()과 html.Br()을 사용하여 \"Welcome\"을 새 줄에 두어 텍스트를 분리하겠습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nhtml.Div([\nhtml.H1([\nhtml.Span(\"환영합니다\"),\nhtml.Br(),\nhtml.Span(\"내 멋진 대시보드로!\")\n]),\nhtml.P(\"이 대시보드 프로토타입은 효과적인 레이아웃을 어떻게 만드는지 보여줍니다.\")\n],\nstyle={\n\"vertical-alignment\": \"top\",\n\"height\": 260\n})\n\n저장하고 업데이트하세요. 이제 우리 대시보드는 이렇습니다:\n\n\u003cimg src=\"/TIL/assets/img/2024-07-09-HowtocreateabeautifulinteractivedashboardlayoutinPythonwithPlotlyDash_5.png\" /\u003e\n\n## 버튼 스타일링\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저희 네비게이션 바의 두 번째 컨테이너에는 버튼이 포함되어 있습니다. 처음 두 개는 그룹 버튼이고 세 번째는 독립적인 버튼입니다. 이 컨테이너는 마지막 DIV 레이어에 속해 있어요.\n\n![image](/TIL/assets/img/2024-07-09-HowtocreateabeautifulinteractivedashboardlayoutinPythonwithPlotlyDash_6.png)\n\n따라서 이 컨테이너를 2:1의 비율로 나누되, CSS 파일에서 제목과 텍스트에 15px의 여백을 주었던 것을 기억하면, 버튼 패널에도 같은 여백을 유지하는 것이 좋아요. 그리고 \"display\"를 \"flex\"로 설정하여 두 자식 컨테이너를 일렬로 유지해 주세요.\n\n```js\nhtml.Div(\n  [html.Div((style = { width: 206 })), html.Div((style = { width: 104 }))],\n  (style = { \"margin-left\": 15, \"margin-right\": 15, display: \"flex\" })\n);\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n두 개의 버튼 그룹은 RadioItems 요소입니다. 즉, 버튼처럼 스타일이 적용된 체크박스입니다. 이 요소에 대해 더 자세히 알아보려면 \"RadioItems as ButtonGroup\" 섹션을 확인해주세요.\n\n우리는 미래 버튼을 dbc.RadioItems() 태그 아래의 왼쪽 컨테이너에 배치합니다. 내부에는 각 버튼의 라벨과 실제 값이 정의된 사전 목록인 options를 배치합니다. 또한 options 외에도 선택된 기본 옵션인 value를 배치합니다.\n\n```js\nhtml.Div(\n  [\n    html.Div(\n      dbc.RadioItems(\n        (options = [\n          { label: \"그래프\", value: 1 },\n          { label: \"테이블\", value: 2 },\n        ]),\n        (value = 1)\n      ),\n      (style = { width: 206 })\n    ),\n    html.Div((style = { width: 104 })),\n  ],\n  (style = {\n    \"margin-left\": 15,\n    \"margin-right\": 15,\n    display: \"flex\",\n  })\n);\n```\n\n지금 앱을 업데이트하면 \"그래프\"와 \"테이블\"이라는 두 개의 전환 가능한 체크박스가 표시됩니다. 이것들을 버튼으로 바꿔야 합니다. 여기서 우리의 기본 스타일이 도움이 될 것입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nFlatly 스타일 페이지를 확인해보세요. 버튼 섹션에서는 활성화된(active), 비활성화(disabled), 아웃라인(outline) 버튼을 볼 수 있어요. 'primary', 'secondary', 'danger'와 같은 이름들은 특정 색상을 나타냅니다. 저희 대시보드에서 'light' 버튼을 사용할 거에요: 버튼을 누르면 활성화된 'light' 버튼처럼 보이고, 그렇지 않을 때는 아웃라인 'light' 버튼처럼 보이게 할 거에요. 활성화된 버튼 행 위로 마우스 커서를 올리고 팝업 버튼을 클릭해보세요; 그러면 이 모든 버튼의 코드와 클래스를 포함한 창이 나타날 거에요. 우리 버튼은 \"btn btn-light\" 클래스를 가지고 있어요. 아웃라인 버튼 행에서는, 우리가 관심을 갖는 버튼 클래스가 \"btn btn-outline-light\"입니다. 우리는 지금 이 두 클래스를 사용할 거에요.\n\n이제 코드로 돌아가서 체크박스를 이 버튼들로 변환해보겠어요. 이를 위해 dbc.RadioItems() 내부에 여러 클래스를 지정해야 해요:\n\n- className \"btn-group\"은 우리 버튼 그룹을 가로로 정렬할 거에요.\n- inputClassName \"btn-check\"은 체크박스를 \"숨길\" 거에요.\n- labelClassName \"btn btn-outline-light\"는 선택되지 않은 체크박스의 텍스트를 Flatly 아웃라인 버튼으로 보이게 할 거에요.\n- labelCheckedClassName \"btn btn-light\"는 선택된 체크박스의 텍스트를 Flatly 활성화된 버튼으로 보이게 할 거에요.\n\n```js\nhtml.Div(\n  [\n    html.Div(\n      dbc.RadioItems(\n        (className = \"btn-group\"),\n        (inputClassName = \"btn-check\"),\n        (labelClassName = \"btn btn-outline-light\"),\n        (labelCheckedClassName = \"btn btn-light\"),\n        (options = [\n          { label: \"Graph\", value: 1 },\n          { label: \"Table\", value: 2 },\n        ]),\n        (value = 1)\n      ),\n      (style = { width: 206 })\n    ),\n    html.Div((style = { width: 104 })),\n  ],\n  (style = {\n    \"margin-left\": 15,\n    \"margin-right\": 15,\n    display: \"flex\",\n  })\n);\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n모든 이 클래스들의 외관은 이미 우리의 부트스트랩 CSS 파일에 설정되어 있습니다. 앱을 업데이트하고 체크박스가 버튼으로 변환되었는지 확인하세요. 원하는 대로 이미 가까이 왔습니다; 조금 수정이 필요합니다. 특히, 버튼이 부모 컨테이너의 전체 영역을 차지하도록 만들고, 선택되지 않은 버튼에서 외곽선을 제거하며, 버튼에 마우스를 올렸을 때 버튼이 가벼워지게 만들고, Poppins 글꼴로 바꾸려고 합니다.\n\n우리는 우리의 사용자 정의 CSS 파일을 사용하여 부트스트랩 Flatly 버튼 매개변수를 다시 작성하여 이 모든 것을 수행할 것입니다. CSS 스타일링의 자세한 분석은 이 튜토리얼의 범위를 벗어나므로 이 코드 조각을 CSS 파일에 넣고 저장하세요:\n\n```js\n/* 라디오 버튼 */\n\n.form-check {\n    width: 100%;\n    height: 38px;\n    margin: 1px;\n    padding-left: 0;\n}\n\n.btn.btn-outline-light,\n.btn.btn-light {\n    width: 100%;\n    height: 100%;\n    padding: 6px;\n    font-family: \"Poppins\";\n    border-radius: 3px;\n}\n\n.btn.btn-outline-light {\n    border: 1px solid transparent;\n}\n\n.btn.btn-outline-light:hover {\n    color: #010103;\n    background-color: color-mix(in srgb, var(--bs-light), #010103 7%);\n}\n```\n\n이제 세 번째 버튼으로 넘어가 봅시다. 여기서는 보이지 않는 체크박스가 아니기 때문에 매우 간단합니다. 두 번째 컨테이너에 `dbc.Button()` 태그를 넣고, 버튼 라벨(\"About\"), 클릭 수 및 클래스 이름을 지정하세요. 세 번째 버튼은 다른 두 버튼과 색상이 다르게 표시되기를 원합니다. 그래서 그 버튼의 클래스를 \"btn btn-info\"로 설정하여 Flatly 활성 '정보' 버튼처럼 보이도록 만들겠습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nhtml.Div(\n  [\n    html.Div(\n      dbc.RadioItems(\n        (className = \"btn-group\"),\n        (inputClassName = \"btn-check\"),\n        (labelClassName = \"btn btn-outline-light\"),\n        (labelCheckedClassName = \"btn btn-light\"),\n        (options = [\n          { label: \"Graph\", value: 1 },\n          { label: \"Table\", value: 2 },\n        ]),\n        (value = 1)\n      ),\n      (style = { width: 206 })\n    ),\n    html.Div(dbc.Button(\"About\", (className = \"btn btn-info\"), (n_clicks = 0)), (style = { width: 104 })),\n  ],\n  (style = {\n    \"margin-left\": 15,\n    \"margin-right\": 15,\n    display: \"flex\",\n  })\n);\n```\n\n이제 이 추가적인 버튼 스타일을 사용자 정의 CSS 스타일로 변경하고 앱을 업데이트하세요:\n\n```js\n/* Single button */\n\n.btn.btn-info {\n    width: 100%;\n    height: 38px;\n    margin: 1px;\n    padding: 6px;\n    font-family: \"Poppins\";\n    border-radius: 3px;\n    background-color: transparent;\n    border: 1px solid transparent;\n}\n\n.btn.btn-info:active,\n.btn.btn-info:focus {\n    background-color: var(--bs-info);\n}\n\n.btn.btn-info:hover {\n    background-color: color-mix(in srgb, var(--bs-info), #010103 7%);\n}\n```\n\n우리의 버튼 패널이 준비되었습니다!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Image](/TIL/assets/img/2024-07-09-HowtocreateabeautifulinteractivedashboardlayoutinPythonwithPlotlyDash_7.png)\n\n## 드롭다운 스타일링\n\n다음 컨테이너는 세 개의 드롭다운이 아래로 배치된 그룹입니다. 그래서 그 안에 세 개의 빈 DIV 컨테이너 목록을 넣어 보겠습니다. 또한 부모 컨테이너의 왼쪽과 오른쪽 여백을 다시 15px로 설정하고 위쪽으로는 버튼들과 구분하기 위해 30px 여백을 두겠습니다.\n\n```js\nhtml.Div(\n  [html.Div(), html.Div(), html.Div()],\n  (style = {\n    \"margin-left\": 15,\n    \"margin-right\": 15,\n    \"margin-top\": 30,\n  })\n);\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n부트스트랩 컴포넌트를 사용하여 버튼이나 드롭다운을 만들 수 있지만, 많은 옵션을 선택해야 하거나 기본 옵션을 표시해야 하는 경우에는 (우리의 경우처럼) Dash Core Components (DCC)를 사용하는 것이 더 편리합니다. dcc dropdown에 대해 더 자세히 알아보세요.\n\n우리의 경우 각 드롭다운 DIV 컨테이너에는 서브헤더와 드롭다운이 포함되어 있습니다. 서브헤더는 html.H2() 태그로 감싸고 그 뒤에 dcc.Dropdown()을 배치하세요:\n\n```js\nhtml.Div(\n  [\n    html.Div([html.H2(\"선택 불가 드롭다운:\"), dcc.Dropdown()]),\n    html.Div([html.H2(\"선택 불가 드롭다운:\"), dcc.Dropdown()]),\n    html.Div([html.H2(\"선택 가능 드롭다운:\"), dcc.Dropdown()]),\n  ],\n  (style = {\n    \"margin-left\": 15,\n    \"margin-right\": 15,\n    \"margin-top\": 30,\n  })\n);\n```\n\n먼저 서브헤더를 스타일링해 보겠습니다. CSS 파일에 다음 스타일을 h2 태그에 적용하세요:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nh2 {\n    margin-bottom: 0px;\n    margin-top: 10px;\n    font-family: \"Poppins\";\n    font-size: 14px !important;\n    color: #ffffff;\n}\n```\n\n이제 드롭다운을 채워보겠습니다. 라디오 버튼과 유사하게, 드롭다운에는 옵션 사전과 기본 선택값이 있습니다. 또한 드롭다운을 clearable 또는 non-clearable(그럼 우리에게 예를 들어 \"선택...\"과 같은 플레이스홀더를 보여주며 기본값이 필요 없게 됩니다.)로 설정하여 clearable 매개변수를 각각 False 또는 True로 설정하여 만들 수 있습니다. 또 다른 유용한 매개변수는 optionHeight로, 드롭다운 메뉴 옵션의 높이를 설정합니다.\n\n```js\nhtml.Div(\n  [\n    html.Div([\n      html.H2(\"선택 불가능한 드롭다운:\"),\n      dcc.Dropdown(\n        (options = [\n          { label: \"옵션 A\", value: 1 },\n          { label: \"옵션 B\", value: 2 },\n          { label: \"옵션 C\", value: 3 },\n        ]),\n        (value = 1),\n        (clearable = False),\n        (optionHeight = 40)\n      ),\n    ]),\n    html.Div([\n      html.H2(\"선택 불가능한 드롭다운:\"),\n      dcc.Dropdown(\n        (options = [\n          { label: \"옵션 A\", value: 1 },\n          { label: \"옵션 B\", value: 2 },\n          { label: \"옵션 C\", value: 3 },\n        ]),\n        (value = 2),\n        (clearable = False),\n        (optionHeight = 40)\n      ),\n    ]),\n    html.Div([\n      html.H2(\"선택 가능한 드롭다운:\"),\n      dcc.Dropdown(\n        (options = [\n          { label: \"옵션 A\", value: 1 },\n          { label: \"옵션 B\", value: 2 },\n          { label: \"옵션 C\", value: 3 },\n        ]),\n        (clearable = True),\n        (optionHeight = 40)\n      ),\n    ]),\n  ],\n  (style = {\n    \"margin-left\": 15,\n    \"margin-right\": 15,\n    \"margin-top\": 30,\n  })\n);\n```\n\n이제 앱을 업데이트하세요. 이미 매우 멋져 보이지만, 아직도 드롭다운을 다크 모드로 디자인하고 싶습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그래서, 각 dcc.Dropdown()에 className=\"customDropdown\"을 추가하고 CSS 파일로 이동합시다. DCC 요소를 스타일링하는 것은 Bootstrap 요소를 스타일링하는 것보다 복잡합니다. 왜냐하면 우리에게 고정된 요소 스타일이 없기 때문에 모든 것은 사용자 정의 CSS에서 지정되어야 합니다. 그래서 이 코드를 CSS 파일에 추가하고 저장하세요.\n\n```js\n/* Dropdowns */\n\n.customDropdown {\n    font-size: 16px;\n    font-family: \"Poppins\";\n    padding-left: 1px;\n}\n\n.customDropdown .Select-control {\n    width: 100%;\n    height: 38px;\n    background-color: transparent;\n    border: 1px solid #676768;\n    border-radius: 3px;\n    color: var(--bs-info) !important;\n}\n\n.customDropdown .Select-value-label,\n.customDropdown .Select-placeholder {\n    color: var(--bs-info) !important;\n}\n\n.customDropdown .Select-arrow {\n    border-color: #cccccc transparent transparent;\n}\n\n.customDropdown.is-open .Select-arrow {\n    border-color: transparent transparent #cccccc;\n}\n\n.customDropdown .Select-clear {\n    color: var(--bs-info);\n    font-size: 22px;\n}\n\n.customDropdown.is-focused:not(.is-open) \u003e .Select-control {\n    border: 2px solid color-mix(in srgb, var(--bs-info), #010103 50%) !important;\n}\n\n.customDropdown.is-focused:not(.is-open) .Select-arrow {\n    border-color: var(--bs-info) transparent transparent;\n}\n\n.customDropdown .Select-menu-outer {\n    margin-top: 5px;\n    border-radius: 3px;\n    background-color: #010103;\n    border: 1px solid #676768;\n    color: var(--bs-light);\n}\n\n.customDropdown .VirtualizedSelectFocusedOption {\n    background-color: color-mix(in srgb, var(--bs-light), #010103 7%);\n    border-radius: 3px;\n    color: #010103;\n}\n```\n\n저장하고 결과를 확인해봅시다. 이제 애플리케이션이 다음과 같이 보여져야 합니다:\n\n\u003cimg src=\"/TIL/assets/img/2024-07-09-HowtocreateabeautifulinteractivedashboardlayoutinPythonwithPlotlyDash_8.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 이미지 추가하기\n\n이 부분은 매우 간단합니다: Dash에서 이미지를 추가하는 것은 다른 HTML 요소처럼 html.Img() 명령을 사용하면 됩니다. 이 명령은 해당 `img` 태그를 복제합니다. 안에는 이미지 링크와 이미지의 너비, 높이, 여백을 정의할 수 있는 스타일 딕셔너리가 들어갑니다.\n\n```js\nhtml.Div(\n  html.Img(\n    (src = \"assets/image.svg\"),\n    (style = {\n      \"margin-left\": 15,\n      \"margin-right\": 15,\n      \"margin-top\": 30,\n      width: 310,\n    })\n  )\n);\n```\n\n저는 미리 assets 폴더에 두었던 이미지를 사용했습니다. 이 명령줄에서 명령 바 아래에 이미지가 나타났습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/TIL/assets/img/2024-07-09-HowtocreateabeautifulinteractivedashboardlayoutinPythonwithPlotlyDash_9.png)\n\n## 그래프 추가\n\n대시보드의 주요 공간은 그래프로 채워지므로 한 개를 만들어 봅시다. 먼저 우리의 import 목록에 아래 패키지들을 추가해주세요:\n\n```python\nimport plotly.graph_objects as go\nimport numpy as np\nimport random\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자, 이제 표준 분포에서 무작위 샘플을 사용하여 산점도를 만들어 봅시다:\n\n```js\nfig = go.Figure(\n  go.Scattergl(\n    (x = np.random.randn(1000)),\n    (y = np.random.randn(1000)),\n    (mode = \"markers\"),\n    (marker = dict((color = random.sample([\"#ecf0f1\"] * 500 + [\"#3498db\"] * 500, 1000)), (line_width = 1)))\n  )\n);\n\nfig.update_layout(\n  (plot_bgcolor = \"#010103\"),\n  (width = 790),\n  (height = 730),\n  (xaxis_visible = False),\n  (yaxis_visible = False),\n  (showlegend = False),\n  (margin = dict((l = 0), (r = 0), (t = 0), (b = 0)))\n);\n```\n\n여기서 중요한 점은 레이아웃 바깥에서 그래프를 생성해야 합니다. 레이아웃에서는 완성된 시각화만을 호출합니다. 따라서 차트 코드를 레이아웃 코드 앞에 배치합니다.\n\n레이아웃에서는 그래프를 dсс.Graph() 명령으로 호출합니다. 그래프 데이터를 figure 변수에 전달합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nhtml.Div(dcc.Graph((figure = fig)), (style = { width: 790 }));\n```\n\n차트의 팝업 내비게이션 바가 싫어요. 아래 CSS 파일을 사용하여 제거할 수 있어요:\n\n```js\n.modebar { display: none !important; }\n```\n\n우리 대시보드 레이아웃이 거의 준비되었어요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/TIL/assets/img/2024-07-09-HowtocreateabeautifulinteractivedashboardlayoutinPythonwithPlotlyDash_10.png)\n\n## 그래프 출력 섹션 추가\n\n대시보드의 마지막 부분은 차트의 출력 섹션입니다. 기본적으로 이러한 출력 섹션은 사용자 동작에 따라 변하는 `p` 요소를 포함한 동일한 DIV 컨테이너들입니다. 그래프 오른쪽에 이러한 출력 컨테이너들을 두 개 생성해 봅시다.\n\n두 개의 출력 필드를 생성하려면 간단히 마지막 빈 DIV 컨테이너에 두 가지 텍스트 요소와 두 개의 DIV를 배치하면 됩니다. 이미 subheading에 스타일이 적용되어 있으므로 해당 요소들을 html.H2() 명령어로 감싸기만 하면 됩니다. 또한 출력 필드 중 하나에는 값을 채우고 나머지는 비워 둡시다. 여전히 무료인 `h3` 텍스트 태그를 사용하여 출력을 스타일링하겠습니다. 두 번째 컨테이너 내부에 html.H3(“Selected Value”) 요소를 배치합니다. 출력 DIV 필드 자체에 스타일을 적용하려면 클래스를 도입해야 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nhtml.Div(\n  [\n    html.H2(\"Output 1:\"),\n    html.Div((className = \"Output\")),\n    html.H2(\"Output 2:\"),\n    html.Div(html.H3(\"Selected Value\"), (className = \"Output\")),\n  ],\n  (style = { width: 200 })\n);\n```\n\n이제 CSS 파일에서 .Output 클래스와 h3 태그에 스타일을 할당하겠습니다:\n\n```js\n.Output {\n    width: 150px;\n    height: 38px;\n    background-color: rgba(204,204,204,0.1);\n    border: 1px solid rgba(204,204,204,0.1);\n    border-radius: 3px;\n}\n\n.Output:empty::before {\n  content:\"\";\n  display:inline-block;\n}\n\nh3 {\n    font-size: 16px;\n    line-height: 34px;\n    padding-left: 7px;\n    font-family: \"Poppins\";\n    color: var(--bs-info);\n}\n```\n\n자, 모두 끝났어요! 대시보드를 위한 모든 레이아웃 요소들이 개발되었습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/TIL/assets/img/2024-07-09-HowtocreateabeautifulinteractivedashboardlayoutinPythonwithPlotlyDash_11.png)\n\n우리는 그래프와 모든 탐색 요소가 포함된 레이아웃을 완성했으므로 Plotly Dash에서 대시보드를 만드는 첫 번째 단계를 완료했습니다. 다음 단계는 상호 작용이 가능하게 만드는 것인데, 이 단계에서 이전에 생성한 모든 탐색 요소들을 \"작동\"시킬 것입니다. 세 번째는 일반 사용자가 이용할 수 있는 실시간 웹 애플리케이션을 배포하는 것입니다.\n\nDash 앱 개발의 첫 번째 단계에서 도움이 될 수 있는 것은 무엇인가요?\n\n- Dribble의 웹 디자인 섹션에는 영감을 얻을 수 있는 많은 아름답고 기능적인 레이아웃이 있습니다.\n- 준비된 CSS 솔루션을 공부하는 것. CodePen을 확인할 수 있지만, 대부분의 \"어떻게 할 수 있는가\"라는 질문에 대한 대답은 Stackoverflow나 Google에서 간단한 검색으로 찾을 수 있습니다.\n- Dash 문서를 주의 깊게 읽고 사이트를 검색하는 것. 각 Dash 요소의 설명은 항상 코드 예제와 변경할 수 있는 속성 목록이 함께 제공됩니다.\n- Plotly 커뮤니티 포럼. 커뮤니티 회원들은 이미 발생한 대부분의 문제를 해결하려고 노력했습니다. 그들은 자주 코드 조각을 게시하고 토론하며, 이러한 토론 중에서 종종 준비된 솔루션을 찾을 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n즐거운 앱 개발 되세요!\n","ogImage":{"url":"/assets/img/2024-07-09-HowtocreateabeautifulinteractivedashboardlayoutinPythonwithPlotlyDash_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-HowtocreateabeautifulinteractivedashboardlayoutinPythonwithPlotlyDash_0.png","tag":["Tech"],"readingTime":36},{"title":"Python을 사용해 PDF에서 이미지 및 이미지 정보 추출하는 방법","description":"","date":"2024-07-09 14:38","slug":"2024-07-09-ExtractImagesandImageInformationfromPDFwithPython","content":"\nPDF (Portable Document Format) 파일은 다양한 형식과 일관된 포맷팅을 가지고 있어 문서 공유와 보존에 널리 사용됩니다. 텍스트 콘텐츠 외에도 PDF 파일에는 종종 가치 있는 이미지가 포함되어 있습니다. 이러한 이미지를 추출하고 위치 (x와 y 좌표), 너비, 높이와 같은 관련 정보를 검색함으로써 이미지 분석, 조작, 그리고 다양한 프로젝트에 통합하는 많은 가능성을 발견할 수 있습니다. 이 블로그 포스트에서는 Python을 사용하여 PDF 파일에서 이미지와 이미지 정보를 추출하는 방법을 알아보겠습니다.\n\n- Python으로 PDF에서 이미지 추출하기\n- Python으로 PDF에서 이미지 정보 추출하기\n\n# Python을 사용하여 PDF로부터 이미지 및 이미지 정보 추출하는 라이브러리\n\nPython에서 PDF 파일로부터 이미지와 이미지 정보를 추출하기 위해 Spire.PDF for Python을 사용할 것입니다. 이 라이브러리는 Python 애플리케이션 내에서 PDF 파일을 생성, 읽기, 편집, 변환할 수 있도록 설계된 기능이 풍부하고 사용자 친화적인 라이브러리입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음 pip 명령어를 사용하여 PyPI에서 Spire.PDF for Python을 설치할 수 있어요:\n\n```js\npip install Spire.Pdf\n```\n\n이미 Spire.PDF for Python을 설치 했고 최신 버전으로 업그레이드 하고 싶다면, 다음 pip 명령어를 사용해 주세요:\n\n```js\npip install --upgrade Spire.Pdf\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n더 자세한 정보를 원하시면, 이 공식 설명서를 확인하실 수 있어요: VS Code에서 Python용 Spire.PDF 설치 방법.\n\n# Python에서 PDF 이미지 추출하기\n\nSpire.PDF for Python의 PdfImageHelper 클래스를 사용하면 PDF 파일 내 이미지를 쉽게 다룰 수 있어요.\n\nPDF 파일에서 이미지를 가져오려면 PdfImageHelper.GetImagesInfo(page: PdfPageBase) 함수를 사용할 수 있어요. 이 함수는 PDF 페이지의 이미지를 나타내는 PdfImageInfo 객체 목록을 반환할 거예요. PdfImageInfo 객체를 얻으면 PdfImageInfo.Image.Save() 함수를 사용하여 각 이미지를 파일로 저장할 수 있어요.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 코드는 Python 및 Spire.PDF for Python을 사용하여 PDF 파일에서 이미지를 추출하는 방법을 보여줍니다:\n\n```python\nfrom spire.pdf.common import *\nfrom spire.pdf import *\n\ndef extract_images_from_pdf(pdf_path, output_dir):\n    \"\"\"\n    PDF 파일에서 모든 이미지를 추출하여 지정된 출력 디렉토리에 저장합니다.\n\n    Args:\n        pdf_path (str): PDF 파일 경로\n        output_dir (str): 추출된 이미지가 저장될 디렉토리\n    \"\"\"\n    # PdfDocument 객체 생성 및 PDF 파일 로드\n    doc = PdfDocument()\n    doc.LoadFromFile(pdf_path)\n\n    # PdfImageHelper 객체 생성\n    image_helper = PdfImageHelper()\n\n    image_count = 1\n    # PDF의 모든 페이지에 대해 반복\n    for page_index in range(doc.Pages.Count):\n        # 현재 페이지의 이미지 정보 가져오기\n        image_infos = image_helper.GetImagesInfo(doc.Pages[page_index])\n\n        # 이미지 추출 및 저장\n        for image_index in range(len(image_infos)):\n            # 이미지 가져오기\n            image = image_infos[image_index].Image\n            # 출력 파일 이름 지정\n            output_file = os.path.join(output_dir, f\"Image-{image_count}.png\")\n            # 이미지 저장\n            image.Save(output_file)\n            image_count += 1\n\n    # PdfDocument 객체 닫기\n    doc.Close()\n\n# 사용 예시\nextract_images_from_pdf(\"Sample.pdf\", \"C:/Users/Administrator/Desktop/Images\")\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-09-ExtractImagesandImageInformationfromPDFwithPython_0.png\" /\u003e\n\n# Python을 사용하여 PDF에서 이미지 정보 추출하기\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nPDF에서 이미지의 정보를 추출하기 위해서는 PdfImageInfo.Bounds.X, PdfImageInfo.Bounds.Y, PdfImageInfo.Bounds.Width 및 PdfImageInfo.Bounds.Height 속성을 사용할 수 있습니다.\n\n아래 코드는 Python과 Spire.PDF for Python을 사용하여 PDF 파일에서 이미지의 위치 (x 및 y 좌표), 너비 및 높이와 같은 이미지 정보를 추출하는 방법을 보여줍니다:\n\n```python\nfrom spire.pdf.common import *\nfrom spire.pdf import *\n\ndef print_pdf_image_info(pdf_path):\n    \"\"\"\n    PDF 파일에서 이미지에 대한 정보를 출력합니다.\n\n    Args:\n        pdf_path (str): PDF 파일의 경로.\n    \"\"\"\n    # PdfDocument 객체를 만들고 PDF 파일을 로드합니다\n    doc = PdfDocument()\n    doc.LoadFromFile(pdf_path)\n\n    # PdfImageHelper 객체를 만듭니다\n    image_helper = PdfImageHelper()\n\n    # PDF의 모든 페이지를 반복합니다\n    for page_index in range(doc.Pages.Count):\n        page = doc.Pages[page_index]\n\n        # 현재 페이지에 대한 이미지 정보를 가져옵니다\n        image_infos = image_helper.GetImagesInfo(page)\n\n        # 이미지 정보를 출력합니다\n        for image_index, image_info in enumerate(image_infos):\n            print(f\"페이지 {page_index + 1}, 이미지 {image_index + 1}:\")\n            print(f\"  이미지 위치: ({image_info.Bounds.X}, {image_info.Bounds.Y})\")\n            print(f\"  이미지 크기: {image_info.Bounds.Width} x {image_info.Bounds.Height}\")\n\n    # PdfDocument 객체를 닫습니다\n    doc.Close()\n\n# 사용 예\nprint_pdf_image_info(\"Sample.pdf\")\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론\n\n이 블로그 포스트에서는 Python을 사용하여 PDF 파일에서 이미지를 추출하는 방법을 보여주었습니다. 또한 Python을 사용하여 PDF 파일에서 이미지의 위치 (x 및 y 좌표), 너비 및 높이와 같은 이미지와 관련된 세부 정보를 추출하는 방법도 설명되었습니다.\n\n# 관련 주제\n\n- Python을 사용하여 PDF에서 텍스트 읽거나 추출하기 — 포괄적인 안내서\n- Python을 사용하여 PDF 테이블을 텍스트, Excel 및 CSV로 추출하기\n- Python을 사용하여 PDF 양식 데이터 추출하기\n- Python을 사용하여 PDF를 압축하거나 파일 크기 줄이는 5가지 방법\n- Python을 사용하여 PDF 파일 자르기 방법\n","ogImage":{"url":"/assets/img/2024-07-09-ExtractImagesandImageInformationfromPDFwithPython_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-ExtractImagesandImageInformationfromPDFwithPython_0.png","tag":["Tech"],"readingTime":6},{"title":"컴퓨터 비전으로 파이썬을 사용해 녹색 배경을 다른 이미지로 교체하는 방법","description":"","date":"2024-07-09 14:37","slug":"2024-07-09-UsingPythontoconvertGreenbackgroundwithanotherImageComputerVision","content":"\n디지털 이미지 처리 및 비디오 편집에서 특정 색상(일반적으로 녹색 또는 파랑)을 다른 이미지 또는 비디오 시퀀스로 대체하는 기술은 염색 키 또는 그린 스크린이라고 일반적으로 알려져 있습니다. 이 기술은 영화 제작, 텔레비전 제작 및 소셜 미디어 플랫폼에 매력적인 콘텐츠를 만드는 데 널리 사용됩니다. 이 기술은 파이썬을 사용하여 구현할 수 있습니다.\n\n이제 파이썬 코드의 각 단계를 분해하여 녹색 배경을 이미지에서 제거하고 다른 이미지로 대체하는 방법을 이해해 보겠습니다:\n\n```python\n# 필요한 라이브러리 가져오기\n\n코드는 필요한 라이브러리를 가져오는 것으로 시작합니다. OpenCV 함수를 위해 cv2를, 숫자 연산을 위해 numpy를 가져옵니다.\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport cv2\nimport numpy as np\n```\n\n# 이미지 읽기 및 크기 조정\n\n두 개의 이미지, greenscreen01.jpg(녹색 배경을 가진 주 이미지)와 scenic04.jpg(대체 이미지)를 읽습니다. 두 이미지 모두 균일한 크기로 조정됩니다(이 경우 500x500 픽셀) 이후의 처리를 위해 호환성을 보장합니다.\n\n```js\n# 주 이미지(녹색 배경)와 대체 이미지를 읽기\nmain_image = cv2.imread('greenscreen01.jpg')\nreplacement_image = cv2.imread('scenic04.jpg')\n\nmain_image = cv2.resize(main_image, (500, 500))\nreplacement_image = cv2.resize(replacement_image, (500, 500))\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Image](/TIL/assets/img/2024-07-09-UsingPythontoconvertGreenbackgroundwithanotherImageComputerVision_0.png)\n\n## HSV로 변환\n\n주 이미지 (main_image)는 BGR (기본 OpenCV 색상 형식)에서 HSV (색조, 채도, 값) 색 공간으로 변환됩니다. HSV는 색상 기반 세분화에 유용합니다.\n\n```js\n# 주 이미지를 HSV 색 공간으로 변환\nhsv_main = cv2.cvtColor(main_image, cv2.COLOR_BGR2HSV)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 색상 범위 정의\n\nHSV 공간에서 녹색 색상의 범위는 하한 및 상한 임계값 (lower_green 및 upper_green)을 사용하여 정의됩니다. 이러한 값은 주 이미지에 나타난 녹색 음영의 범위를 커버하도록 경험적으로 조정됩니다.\n\n```js\n# HSV 색 공간에서 녹색 색상 범위 정의\nlower_green = np.array([35, 50, 50])\nupper_green = np.array([85, 255, 255])\n```\n\n# 마스크 생성 및 녹색 픽셀 대체\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이진 마스크(mask)는 cv2.inRange()을 사용하여 생성됩니다. 이는 메인 이미지 내에서 지정된 녹색 색상 범위 내에 속하는 픽셀을 식별합니다. 마스크(mask) 내에서 0이 아닌 값에 해당하는 메인 이미지의 픽셀(즉, 녹색 픽셀)은 대체 이미지의 픽셀로 대체됩니다.\n\n```python\n# 정의된 범위 내의 녹색 픽셀에 대한 마스크 생성\nmask = cv2.inRange(hsv_main, lower_green, upper_green)\n\n# 대체 이미지에서 해당 픽셀로 녹색 픽셀 교체\nmodified_main_image = main_image.copy()\nmodified_main_image[mask \u003e 0] = replacement_image[mask \u003e 0]\n```\n\n# 결과 표시\n\n수정된 이미지(modified_main_image)는 cv2.imshow()를 사용하여 표시되며, 초록 배경 제거 효과를 시각적으로 확인할 수 있습니다. cv2.waitKey(0)는 이미지 창을 닫기 위해 키 입력을 기다리며, cv2.destroyAllWindows()는 모든 OpenCV 창을 정상적으로 닫습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 수정된 메인 이미지 표시\ncv2.imshow('수정된 메인 이미지', modified_main_image)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n```\n\n![2024-07-09-UsingPythontoconvertGreenbackgroundwithanotherImageComputerVision_1](/TIL/assets/img/2024-07-09-UsingPythontoconvertGreenbackgroundwithanotherImageComputerVision_1.png)\n\n# 결론\n\n이러한 몇 가지 단계를 사용하면 Python과 OpenCV를 활용하여 이미지에서 녹색 배경을 효과적으로 제거할 수 있습니다. 이미지를 HSV 색 공간으로 변환하고, 녹색 색상 범위를 정의하고, 마스크를 생성하고, 픽셀을 대체함으로써, 이 코드는 녹색 배경을 다른 이미지로 대체하는 원하는 효과를 제공합니다. 이 기술은 비디오 시퀀스를 처리하고 비디오 편집 및 특수 효과 제작에서 만날 수 있는 더 복잡한 시나리오를 처리하기 위해 더 확장될 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 참고 자료\n\nhttps://opencv.org/\n","ogImage":{"url":"/assets/img/2024-07-09-UsingPythontoconvertGreenbackgroundwithanotherImageComputerVision_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-UsingPythontoconvertGreenbackgroundwithanotherImageComputerVision_0.png","tag":["Tech"],"readingTime":5},{"title":"Python으로 머신러닝에서 불균형 데이터 다루는 방법","description":"","date":"2024-07-09 14:33","slug":"2024-07-09-HowtoHandleImbalancedDataforMachineLearninginPython","content":"\n기계 학습의 분류 문제를 다룰 때 고려해야 할 중요한 요소 중 하나는 레이블을 정의하는 클래스의 균형입니다.\n\n세 개의 클래스로 이루어진 상황을 상상해보세요. 초기 분석을 수행하여 정확도를 계산하면 93%를 얻을 수 있습니다. 그런 다음 더 깊게 들여다보는데, 데이터의 80%가 한 클래스에 속한다는 것을 알 수 있습니다. 이것이 좋은 징후인가요?\n\n음, 그렇지 않습니다. 이 문서에서는 그 이유를 설명하고 있습니다.\n\n# 초보자를 위한 Jupyter 노트북 설정하기\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기계 학습 초보자라면, ML 문제를 해결하기 위해 두 가지 소프트웨어를 사용할 수 있다는 것을 모를 수 있습니다:\n\n- Anaconda\n- Google Colaboratory\n\nAnaconda는 데이터 분석 및 기계 학습으로 예측을 하는 데 필요한 모든 라이브러리를 제공하는 데이터 과학 플랫폼입니다. 또한 데이터 과학자들이 데이터를 분석하는 데 사용하는 Jupyter Notebooks를 제공합니다. 따라서 Anaconda를 설치하면 필요한 모든 것을 갖추게 됩니다.\n\n반면에 Google Colaboratory는 설정이 필요 없는 호스팅된 Jupyter Notebook 서비스로, 무료로 컴퓨팅 리소스 및 필요한 모든 라이브러리에 대한 액세스를 제공합니다. 따라서 PC에 아무것도 설치하지 않고 데이터를 분석하려면 이 솔루션을 선택할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마침내, 이 글에서 찾을 수 있는 모든 코드를 포함하는 공개 저장소를 만들었습니다. 이 저장소는 하나의 Jupyter Notebook에 있어 데이터 과학자들이 데이터를 분석하는 방식을 확인하고자 할 때 참고할 수 있습니다.\n\n# 머신 러닝에서 불균형 데이터 소개\n\n이 섹션은 머신 러닝에서 클래스 불균형 문제를 소개하고, 불균형 클래스가 흔한 시나리오를 다룹니다. 그러나 계속하기 전에, \"불균형\" 또는 \"균형이 맞지 않는\" 용어를 무시하고 사용할 수 있다는 점을 얘기합시다.\n\n# 불균형 데이터 정의 및 모델 성능에 미치는 영향\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n상상해봐요. 당신이 100명의 학생들을 가르치는 수학 선생님인 상황을 상상해보세요. 이 학생들 중 90명은 수학을 잘하는 학생(Group A), 그리고 10명은 어려워하는 학생들(Group B)이라고 부를 수 있겠네요. 이 수업 구성은 기계 학습 세상에서 \"불균형 데이터\"로 알려져 있어요.\n\n기계 학습에서 데이터는 컴퓨터에 예측이나 결정을 내리도록 가르치는 데 사용되는 교과서와 같아요. 불균형 데이터가 있다는 것은 컴퓨터가 배워야 하는 것들에 대한 예제 수에 큰 차이가 있다는 것을 의미해요. 우리의 수업 비유에 따르면, 과반이 되는 A 그룹보다 소수인 B 그룹의 학생 수가 적어요.\n\n이제 우리의 기계 학습 모델의 성능은 불균형 데이터에 영향을 받아요. 예를 들어, 여기에는 몇 가지 영향들이 있어요:\n\n- 편향된 학습. 대부분의 학생들이 수학을 잘하는 이 불균형한 수업에서 컴퓨터를 가르치면, 약간 편향될 수 있어요. 마치 컴퓨터가 수학 천재들에게 둘러싸인 듯하니, 모두가 수학 천재인 것으로 생각할 수 있어요. 기계 학습 용어로는 모델이 과반수 클래스 쪽으로 편향될 수 있어요. 그것은 일반적인 것(Group A)을 예측하는 데 능숙해지지만 드문 것(Group B)을 이해하는 데 어려움을 겪을 수 있어요. 당신이 학생들의 투표를 사용하여 수학 가르치기에 얼마나 능숙한지를 평가한다면, 90%의 학생이 수학을 잘하는 것이기 때문에 편향된 결과를 받을 수 있어요. 그런데 이 90% 중 대부분이 사설 수업을 듣고 있다면 당신은 알 수 없어요.\n- 잘못된 정확도. 컴퓨터의 성능을 평가하려면 컴퓨터가 수학을 잘하는 학생이나 어려워하는 학생을 올바르게 식별한 횟수를 확인하여야 해요. A 그룹이 많기 때문에 컴퓨터는 대부분의 학생을 올바르게 맞출 수 있을 거예요. 그래서 정확도가 높아 보인다면 컴퓨터가 훌륭한 일을 하는 것처럼 보일 수 있어요. 그러나 B 그룹이 적기 때문에 실제로는 B 그룹에는 엉망진창일 수 있어요. 기계 학습에서 이 높은 정확도는 컴퓨터가 소수 클래스에서 얼마나 잘 수행되고 있는지 알려주지 않아서 잘못된 정보일 수 있어요.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n간단히 말해서, 불균형 데이터는 컴퓨터에 학습시키려는 서로 다른 사례들에 대해 불균형한 예제 수가 있다는 것을 의미하며, 특히 드물게 발생하는 경우를 처리할 때 머신러닝 모델의 성능에 심각한 영향을 미칠 수 있습니다.\n\n어쨌든, 데이터가 불균형할 것으로 예상되는 경우도 있습니다.\n\n이것들에 대해 설명하기 전에 먼저 어떤 경우에 불균형 데이터가 일반적인지 살펴보겠습니다.\n\n# 불균형 데이터가 흔한 시나리오\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n현실적인 시나리오에서는 데이터가 불균형적인 경우가 많이 발생합니다. 만약 그렇지 않다면, 오류가 있는 것을 의미합니다.\n\n예를 들어 의학 분야를 생각해보겠습니다. 대규모 인구 중에서 희귀 질병을 찾으려고 할 때, 데이터는 불균형해야 합니다. 그렇지 않으면 우리가 찾고 있는 질병이 희귀하지 않다는 것을 의미합니다.\n\n사기 탐지의 경우도 마찬가지입니다. 금융 기관의 데이터 과학자로서 신용 카드에서 사기 거래를 분석하고 있을 때, 불균형한 데이터를 발견해야 합니다. 그렇지 않으면 사기 거래가 비-사기 거래만큼 자주 발생한다는 것을 의미합니다.\n\n# 불균형 문제 이해하기\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 Python 코드와 함께 실제 상황에 대해 알아볼까요? 이를 통해 다음을 보여줄 수 있습니다:\n\n- 그래픽을 기반으로 한 주요 및 소수 클래스 간의 차이.\n- 불균형한 데이터에 영향을 받는 평가 지표들.\n- 불균형한 데이터에 영향을 받지 않는 평가 지표들.\n\n# 주요 및 소수 클래스 간의 차이\n\n수학 선생님인 당신이라고 가정해보겠습니다. 이번에는 1000명의 학생으로 이루어진 대규모 강의를 하고 있습니다. 머신러닝을 사용하여 어떠한 분류를 수행하기 전에, 데이터가 불균형인지 확인하기로 결정했습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하나의 방법은 분포를 시각화하는 것입니다. 예를 들어, 다음과 같이:\n\n```js\nimport numpy as np\nimport matplotlib.pyplot as plt\n```\n\n```js\n# 재현 가능성을 위해 랜덤 시드 설정\nnp.random.seed(42)\n# 다수 클래스 (Class 0)를 위한 데이터 생성\nmajority_class = np.random.normal(0, 1, 900)\n# 소수 클래스 (Class 1)를 위한 데이터 생성\nminority_class = np.random.normal(3, 1, 100)\n# 다수 클래스와 소수 클래스 데이터 결합\ndata = np.concatenate((majority_class, minority_class))\n# 클래스 레이블 생성\nlabels = np.concatenate((np.zeros(900), np.ones(100)))\n# 클래스 분포 플로팅\nplt.figure(figsize=(8, 6))\nplt.hist(data[labels == 0], bins=20, color='blue', alpha=0.6, label='다수 클래스 (Class 0)')\nplt.hist(data[labels == 1], bins=20, color='red', alpha=0.6, label='소수 클래스 (Class 1)')\nplt.xlabel('특성 값')\nplt.ylabel('빈도수')\nplt.title('불균형 데이터셋의 클래스 분포')\nplt.legend()\nplt.show()\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-09-HowtoHandleImbalancedDataforMachineLearninginPython_0.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 Python 예제에서는 두 개의 클래스를 만들었습니다:\n\n- 주요 클래스 (클래스 0). 이 클래스는 데이터 포인트의 대다수를 나타냅니다. 평균이 0이고 표준 편차가 1인 정규 분포에서 900개의 데이터 포인트를 생성했습니다. 실제 시나리오에서는 매우 흔하거나 전형적인 것을 나타낼 수 있습니다.\n- 소수 클래스 (클래스 1). 이 클래스는 데이터 포인트의 소수를 나타냅니다. 평균이 3이고 표준 편차가 1인 정규 분포에서 100개의 데이터 포인트를 생성했습니다. 이 클래스는 의도적으로 흔하지 않게 만들어져 불균형 데이터셋을 시뮬레이션합니다. 실제로는 드문 사건이나 이상을 나타낼 수 있습니다.\n\n다음으로, 이 두 클래스를 해당 레이블 (주요 클래스에 대한 0 및 소수 클래스에 대한 1)과 함께 단일 데이터셋으로 결합합니다. 마지막으로, 히스토그램을 사용하여 클래스 분포를 시각화합니다. 히스토그램에서:\n\n- 파란 막대는 주요 클래스 (클래스 0)를 나타내며, 좌측에 더 크고 더 빈번한 막대입니다.\n- 빨간 막대는 소수 클래스 (클래스 1)를 나타내며, 우측에 더 작고 덜 빈번한 막대입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 시각화는 불균형 데이터셋에서 주요 및 소수 클래스 간의 차이를 명확하게 보여줍니다. 주요 클래스는 소수 클래스보다 훨씬 많은 데이터 포인트를 가지고 있으며, 이는 불균형 데이터의 일반적인 특성입니다.\n\n클래스 불균형을 다루는 또 다른 방법은 분포를 통해 직접적으로 빈도를 살펴보는 것입니다. 예를 들어, 다음과 같이 할 수 있습니다:\n\n```js\nimport numpy as np\nimport matplotlib.pyplot as plt\n```\n\n```js\n# 재현성을 위해 임의의 시드 설정\nnp.random.seed(42)\n# 주요 클래스 (클래스 0)에 대한 데이터 생성\nmajority_class = np.random.normal(0, 1, 900)\n# 소수 클래스 (클래스 1)에 대한 데이터 생성\nminority_class = np.random.normal(3, 1, 100)\n# 주요 및 소수 클래스 데이터 결합\ndata = np.concatenate((majority_class, minority_class))\n# 클래스에 대한 레이블 생성\nlabels = np.concatenate((np.zeros(900), np.ones(100))\n# 각 클래스의 빈도 카운트\nclass_counts = [len(labels[labels == 0]), len(labels[labels == 1])]\n# 막대 그래프를 사용하여 클래스 빈도 플로팅\nplt.figure(figsize=(8, 6))\nplt.bar(['주요 클래스 (클래스 0)', '소수 클래스 (클래스 1)'], class_counts, color=['blue', 'red'])\nplt.xlabel('클래스')\nplt.ylabel('빈도')\nplt.title('불균형 데이터셋의 클래스 빈도')\nplt.show()\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래와 같이 테이블 태그를 마크다운 형식으로 변경해주세요.\n\n![image](/TIL/assets/img/2024-07-09-HowtoHandleImbalancedDataforMachineLearninginPython_1.png)\n\n그러니까, 이 경우에는 클래스에 속하는 데이터의 모든 발생을 계산하는 내장 메소드 len()을 사용할 수 있습니다.\n\n# 이상 데이터로 영향을 받는 일반 평가 지표\n\n이상 데이터에 영향을 받는 모든 평가 지표를 설명하려면 먼저 다음을 정의해야 합니다:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- True positive (TP). 분류기가 조건이나 특성의 존재를 올바르게 예측한 값\n- True negative (TN). 분류기가 조건이나 특성의 부재를 올바르게 예측한 값\n- False positive (FP). 분류기가 특정 조건이나 속성이 존재하는 것으로 잘못 예측한 값\n- False negative (FN). 분류기가 특정 조건이나 속성이 존재하지 않는 것으로 잘못 예측한 값\n\n다음은 불균형 데이터가 영향을 미치는 일반적인 평가 지표입니다:\n\n- 정확도. 데이터 세트에서 올바르게 예측된 인스턴스의 비율을 측정합니다.\n\n![이미지](/TIL/assets/img/2024-07-09-HowtoHandleImbalancedDataforMachineLearninginPython_2.png)\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파이썬에서 정확도 지표를 계산하는 방법에 대한 예제를 만들어보겠습니다:\n\n```python\nfrom sklearn.metrics import accuracy_score\n```\n\n```python\n# 실제 레이블\ntrue_labels = [0, 0, 0, 0, 0, 1, 1, 1, 1, 1]\n# 모델이 예측한 레이블\npredicted_labels = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\naccuracy = accuracy_score(true_labels, predicted_labels)\nprint(\"정확도:\", accuracy)\n```\n\n결과는:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n정확도: 0.5;\n```\n\n정확도는 불균형한 데이터를 다룰 때 혼란을 줄 수 있습니다.\n\n실제로 95%가 A 클래스에 속하고 5%만 B 클래스에 속하는 데이터 세트가 있다고 가정해 봅시다. 모델이 모든 인스턴스를 A 클래스로 예측한다면 95%의 정확도를 달성할 것입니다. 하지만 이는 반드시 모델이 좋다는 것을 의미하지는 않습니다. 이는 단지 클래스 불균형을 악용한 것뿐입니다. 다시 말해, 이 메트릭은 소수 클래스 (B 클래스)를 얼마나 잘 식별하는지를 고려하지 않습니다.\n\n- 정밀도. 이것은 모든 예측된 긍정 인스턴스 중 올바르게 예측된 긍정 인스턴스의 비율을 측정합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![How to Handle Imbalanced Data for Machine Learning in Python](/TIL/assets/img/2024-07-09-HowtoHandleImbalancedDataforMachineLearninginPython_3.png)\n\n한 예제를 통해 Python에서 정밀도 지표를 계산하는 방법을 살펴보겠습니다:\n\n```python\nfrom sklearn.metrics import precision_score\n```\n\n```python\n# True labels\ntrue_labels = [0, 0, 0, 0, 0, 1, 1, 1, 1, 1]\n# Predicted labels by a model\npredicted_labels = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\nprecision = precision_score(true_labels, predicted_labels)\nprint(\"Precision:\", precision)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n결과는 다음과 같습니다:\n\n```js\n정밀도: 0.5;\n```\n\n불균형 데이터 세트에서는 정밀도가 매우 오해를 일으킬 수 있습니다.\n\n실제로, 모델이 하나의 인스턴스만을 긍정적(클래스 B)으로 분류하고 그게 맞는 경우, 정밀도는 100%가 될 것입니다. 그러나 이는 모델이 소수 클래스에서의 성능을 나타내는 것이 아닐 수 있습니다. 왜냐하면 많은 긍정적 인스턴스를 놓칠 수 있기 때문입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 재현율 (또는 민감도). 재현율은 또한 민감도 또는 진양성율로 알려져 있으며, 올바르게 예측된 긍정적 인스턴스의 비율을 측정합니다:\n\n![Example](/TIL/assets/img/2024-07-09-HowtoHandleImbalancedDataforMachineLearninginPython_4.png)\n\n파이썬을 사용하여 재현율 지표를 계산하는 예제를 만들어 보겠습니다:\n\n```js\nfrom sklearn.metrics import recall_score\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 실제 레이블\ntrue_labels = [0, 0, 0, 0, 0, 1, 1, 1, 1, 1]\n# 모델이 예측한 레이블\npredicted_labels = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\nrecall = recall_score(true_labels, predicted_labels)\nprint(\"재현율:\", recall)\n```\n\n결과는:\n\n```js\n재현율: 1.0;\n```\n\n재현율은 불균형한 데이터셋에서도 잘못된 정보를 줄 수 있습니다. 특히 모든 긍정적인 인스턴스를 포착하는 것이 중요할 때에는요.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 모델이 더 많은 양의 양성 인스턴스가 있는 상황에서 한 인스턴스만을 양성(Class B)으로 예측할 경우, 재현율이 매우 낮을 수 있습니다. 이는 모델이 소수 클래스의 중요한 부분을 놓치고 있음을 나타낼 수 있습니다. 이는 이 메트릭이 false positives를 고려하지 않기 때문에 발생합니다.\n\n- F1 스코어. F1 스코어는 정밀도와 재현율의 조화평균입니다. 정밀도와 재현율 사이의 균형을 제공합니다:\n\n![image](/TIL/assets/img/2024-07-09-HowtoHandleImbalancedDataforMachineLearninginPython_5.png)\n\n파이썬을 사용하여 F1 스코어 메트릭을 계산하는 예제를 만들어봅시다:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nfrom sklearn.metrics import f1_score\n```\n\n```js\n# True labels\ntrue_labels = [0, 0, 0, 0, 0, 1, 1, 1, 1, 1]\n# Predicted labels by a model\npredicted_labels = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n# Calculate and print F1-score\nf1 = f1_score(true_labels, predicted_labels)\nprint(\"F1-Score:\", f1)\n```\n\n결과는:\n\n```js\nF1-Score: 0.6666666666666666\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 메트릭은 정밀도와 재현율을 사용하여 생성되었기 때문에 데이터 불균형에 영향을 받을 수 있습니다.\n\n하나의 클래스가 지배적이고 (다수 클래스인 경우), 그 모델이 해당 클래스를 편향으로 처리하는 경우, F1 점수는 소수 클래스의 낮은 재현율에도 높은 정밀도 때문에 상대적으로 높을 수 있습니다. 이는 모델의 전체 효과를 잘못 나타낼 수 있습니다.\n\n# 데이터 불균형에 영향을 받지 않는 가장 많이 사용되는 평가 지표\n\n이제 클래스 불균형에 영향을 받지 않는 평가 지표 중 가장 많이 사용되는 두 가지를 설명하겠습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 혼동 행렬. 혼동 행렬은 분류 알고리즘의 성능을 요약하는 표입니다. 이는 True Positives (TP), True Negatives (TN), False Positives (FP) 및 False Negatives (FN)의 자세한 분석을 제공합니다. 특히, 주 대각선(왼쪽 위에서 오른쪽 아래)은 TP와 TN을 보여주며, 보조 대각선(왼쪽 아래에서 오른쪽 위)은 FP와 FN을 나타냅니다. 따라서, 머신 러닝 모델이 데이터를 올바르게 분류할 경우, 혼동 행렬의 주 대각선은 가장 높은 값을, 보조 대각선은 가장 낮은 값을 보고해야 합니다.\n\n파이썬에서 예제를 보여드리겠습니다:\n\n```python\nfrom sklearn.metrics import confusion_matrix\n```\n\n```python\n# True and predicted labels\ntrue_labels = [0, 0, 0, 0, 0, 1, 1, 1, 1, 1]\npredicted_labels = [0, 0, 0, 0, 0, 1, 1, 1, 0, 1]\n# Create confusion matrix\ncm = confusion_matrix(true_labels, predicted_labels)\n# Print confusion matrix\nprint(\"Confusion Matrix:\")\nprint(cm)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그리고 저희가 얻은 것은:\n\n```js\n혼동 행렬:\n[[5 0]\n [1 4]]\n```\n\n이 혼동 행렬은 주 대각선에 결과가 가장 많기 때문에(10개 중 9개) 좋은 분류기를 나타냅니다. 이는 분류기가 5개의 TP와 4개의 TN을 예측했다는 것을 의미합니다.\n\n그에 비해, 보조 대각선은 낮은 결과를 보여줍니다(10개 중 1개). 이는 분류기가 1개의 FP와 0개의 FN을 예측했음을 의미합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러므로 이것은 좋은 분류기로 이어집니다.\n\n따라서 혼동 행렬은 모델 성능의 자세한 분석을 제공하여 각 클래스에 대해 올바르게 또는 잘못 분류된 인스턴스의 수를 몇 초 안에 알 수 있도록합니다.\n\n- AUC/ROC 커브. ROC는 \"Receiver Operating Characteristic\"의 약자로, 참 긍정률 (TPR)을 다른 임계값에서 거짓 긍정률 (FPR)에 대비하여 그래픽 방식으로 그리는 분류기를 평가하는 방법입니다.\n\n우리는 다음과 같이 정의합니다:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- TPR을 민감도로(우리가 말했듯이 recall로도 불릴 수 있음).\n- FPR을 1-특이도로 정의합니다.\n\n특이도는 분류기가 모든 부정적인 샘플을 찾는 능력을 의미합니다:\n\n![이미지](/TIL/assets/img/2024-07-09-HowtoHandleImbalancedDataforMachineLearninginPython_6.png)\n\nAUC는 ROC 곡선 아래 영역을 나타내며 \"곡선 아래 영역\"을 의미합니다. 이는 0에서 1사이의 전체적인 성능 지표로, 1은 분류기가 레이블의 100%를 실제 값으로 예측한다는 것을 의미하며, 서로 다른 분류기들을 비교할 때 더 적합합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 이진 분류 문제를 공부한다고 가정해봅시다. 파이썬에서 AUC 곡선을 그리는 방법은 다음과 같습니다:\n\n```python\nimport numpy as np\nfrom sklearn.datasets import make_classification\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.metrics import roc_curve, roc_auc_score\nimport matplotlib.pyplot as plt\n```\n\n```python\n# 무작위로 이진 분류 데이터세트 생성\nX, y = make_classification(n_samples=1000, n_features=10, n_classes=2, random_state=42)\n# 데이터세트를 학습 및 테스트 세트로 분할\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n# 학습 데이터에서 로지스틱 회귀 모델 학습\nmodel = LogisticRegression()\nmodel.fit(X_train, y_train)\n# 테스트 데이터에 대해 확률 예측\nprobs = model.predict_proba(X_test)\n# ROC 곡선 및 AUC 점수 계산\nfpr, tpr, thresholds = roc_curve(y_test, probs[:, 1])\nauc_score = roc_auc_score(y_test, probs[:, 1])\n# ROC 곡선 그리기\nplt.plot(fpr, tpr, label='AUC = {:.2f}'.format(auc_score))\nplt.plot([0, 1], [0, 1], 'k--')\nplt.xlabel('False Positive Rate')\nplt.ylabel('True Positive Rate')\nplt.title('ROC Curve')\nplt.legend(loc='lower right')\nplt.show()\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-09-HowtoHandleImbalancedDataforMachineLearninginPython_7.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그 코드로는 다음을 할 수 있어요:\n\n- make_classification 메서드로 분류 데이터셋을 생성했어요.\n- 데이터셋을 훈련 세트와 테스트 세트로 나눴어요.\n- Logistic Regression 분류기로 훈련 세트를 fit했어요.\n- predict_proba() 메서드로 테스트 데이터에 대한 예측을 만들었어요.\n- ROC 곡선과 AUC 점수를 계산했어요.\n- AUC 곡선을 그렸어요.\n\n# 불균형 데이터 다루는 기술\n\n이 섹션에서는 불균형 데이터를 다루는 몇 가지 기술을 다루겠어요.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다시 말해, 우리는 불균형 데이터를 다루는 방법에 대해 이야기할 것입니다.\n\n## 리샘플링\n\n불균형 데이터셋을 처리하는 데 널리 사용되는 방법론은 리샘플링입니다. 이 방법론은 두 가지 다른 프로세스로 나눌 수 있습니다:\n\n- 오버샘플링. 소수 클래스에 더 많은 예제를 추가하는 것을 의미합니다.\n- 언더샘플링. 다수 클래스에서 샘플을 제거하는 것을 의미합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n두 가지 방법에 대해 설명해 보겠습니다.\n\n## Oversampling\n\nOversampling은 소수 클래스의 인스턴스 수를 늘려 클래스 분포를 균형있게 만드는 재표본화 기술입니다. 주로 기존 인스턴스를 복제하거나 소수 클래스와 유사한 합성 데이터 포인트를 생성함으로써 수행됩니다. 목표는 모델이 훈련 중에 두 클래스의 더 균형 잡힌 표현을 볼 수 있도록 하는 것입니다.\n\n장점:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 모델 성능 향상. Oversampling은 소수 클래스의 특성을 더 잘 학습할 수 있도록 도와주어 전체적인 분류 성능을 향상시킬 수 있습니다, 특히 소수 클래스에 대해서 더욱 효과적입니다.\n- 정보 보존. 언더샘플링과는 달리, 오버샘플링은 과반 클래스의 모든 인스턴스를 보존하여 정보의 손실이 없도록 합니다.\n\n단점:\n\n- 과적합의 위험. 중복되거나 합성된 인스턴스는 적절하게 제어되지 않으면, 특히 합성 데이터가 기존 데이터와 너무 유사한 경우에는 과적합을 유발할 수 있습니다.\n- 훈련 시간 증가. 오버샘플링으로 인한 더 큰 데이터셋은 머신러닝 알고리즘의 학습 시간이 더 오래 걸릴 수 있습니다.\n\nPython에서 불균형한 데이터셋에 대한 오버샘플링 기술을 어떻게 활용할 수 있는지 알아보겠습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn.datasets import make_classification\nfrom imblearn.over_sampling import RandomOverSampler\nfrom collections import Counter\n```\n\n```js\n# 3개 클래스를 가지는 불균형 데이터셋 생성\nX, y = make_classification(\n    n_samples=1000,\n    n_features=20,\n    n_classes=3,\n    n_clusters_per_class=1,\n    weights=[0.1, 0.3, 0.6],  # 클래스 불균형\n    random_state=42\n)\n# 초기 클래스들의 히스토그램 출력\nplt.figure(figsize=(10, 6))\nplt.hist(y, bins=range(4), align='left', rwidth=0.8, color='blue', alpha=0.7)\nplt.title(\"초기 클래스들의 히스토그램\")\nplt.xlabel(\"클래스\")\nplt.ylabel(\"인스턴스 개수\")\nplt.xticks(range(3), ['클래스 0', '클래스 1', '클래스 2'])\nplt.show()\n# RandomOverSampler를 사용하여 오버샘플링 적용\noversampler = RandomOverSampler(sampling_strategy='auto', random_state=42)\nX_resampled, y_resampled = oversampler.fit_resample(X, y)\n# 재샘플링된 클래스들의 히스토그램 출력\nplt.figure(figsize=(10, 6))\nplt.hist(y_resampled, bins=range(4), align='left', rwidth=0.8, color='orange', alpha=0.7)\nplt.title(\"재샘플링된 클래스들의 히스토그램 (오버샘플링)\")\nplt.xlabel(\"클래스\")\nplt.ylabel(\"인스턴스 개수\")\nplt.xticks(range(3), ['클래스 0', '클래스 1', '클래스 2'])\nplt.show()\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-09-HowtoHandleImbalancedDataforMachineLearninginPython_8.png\" /\u003e\n\n## 언더샘플링\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n언더샘플링은 머신 러닝에서 사용되는 샘플링 기술 중 하나로, 주요 클래스의 인스턴스 수를 줄여 클래스 분포를 균형있게 만드는 것에 초점을 맞춥니다. 주로 주요 클래스에서 인스턴스를 무작위로 제거해 두 클래스가 보다 균형 잡힌 표현이 되도록 하는 방식입니다. 여기에는 언더샘플링의 장단점이 있습니다.\n\n장점:\n\n- 과적합 위험이 감소합니다. 언더샘플링은 오버샘플링과 비교하여 과적합 위험을 줄입니다. 주요 클래스의 인스턴스 수를 줄이면 모델이 학습 데이터를 외워버리는 경향이 줄어들고 새로운, 보이지 않는 데이터에 대해 더 잘 일반화할 수 있습니다.\n- 빠른 학습 시간입니다. 언더샘플링을 거친 후 데이터셋에는 더 이상 적은 인스턴스가 있기 때문에 머신 러닝 알고리즘의 학습 시간을 줄일 수 있습니다. 보통 데이터가 적을수록 학습 시간이 더 빨라집니다.\n\n단점:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 정보 손실. 언더샘플링은 주요 클래스에서 인스턴스를 버림으로써 귀중한 정보 손실을 야기할 수 있습니다. 만일 버려진 인스턴스에 주요 클래스의 전반적인 이해에 기여하는 중요한 특성이 있다면 문제가 될 수 있습니다.\n- 편향된 모델의 위험. 주요 클래스에서 인스턴스를 제거하면 편향된 모델을 유발할 수 있으며, 이는 실제 주요 클래스의 분포를 정확하게 포착하지 못할 수 있습니다. 이러한 편향은 모델이 실제 세계 상황에 일반화하는 능력에 영향을 줄 수 있습니다.\n- 주요 클래스에서의 성능 저하 가능성. 언더샘플링은 주요 클래스에서 성능이 나쁜 모델을 유발할 수 있습니다. 왜냐하면 학습할 정보가 적기 때문입니다. 이는 주요 클래스의 인스턴스를 잘못 분류할 수 있게 됩니다.\n- 샘플링 비율에 민감함. 언더샘플링 정도는 모델의 성능에 중대한 영향을 미칠 수 있습니다. 샘플링 비율이 과도하면 주요 클래스의 중요한 정보가 손실될 수 있고, 너무 보수적이면 클래스 불균형 문제가 계속 남을 수 있습니다.\n\n아래는 파이썬에서 불균형 데이터셋에 대해 언더샘플링 기술을 활용하는 방법입니다:\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn.datasets import make_classification\nfrom imblearn.under_sampling import RandomUnderSampler\nfrom collections import Counter\n```\n\n```python\n# 3개 클래스를 갖는 불균형 데이터셋 생성\nX, y = make_classification(\n    n_samples=1000,\n    n_features=20,\n    n_classes=3,\n    n_clusters_per_class=1,\n    weights=[0.1, 0.3, 0.6],  # 클래스 불균형\n    random_state=42\n)\n# 초기 클래스 히스토그램 출력\nplt.figure(figsize=(10, 6))\nplt.hist(y, bins=range(4), align='left', rwidth=0.8, color='blue', alpha=0.7)\nplt.title(\"Initial Classes의 히스토그램\")\nplt.xlabel(\"클래스\")\nplt.ylabel(\"인스턴스 수\")\nplt.xticks(range(3), ['클래스 0', '클래스 1', '클래스 2'])\nplt.show()\n# RandomUnderSampler를 사용하여 언더샘플링 적용\nundersampler = RandomUnderSampler(sampling_strategy='auto', random_state=42)\nX_resampled, y_resampled = undersampler.fit_resample(X, y)\n# 재샘플링 클래스의 히스토그램 출력\nplt.figure(figsize=(10, 6))\nplt.hist(y_resampled, bins=range(4), align='left', rwidth=0.8, color='orange', alpha=0.7)\nplt.title(\"Resampled Classes (언더샘플링)의 히스토그램\")\nplt.xlabel(\"클래스\")\nplt.ylabel(\"인스턴스 수\")\nplt.xticks(range(3), ['클래스 0', '클래스 1', '클래스 2'])\nplt.show()\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 Markdown 형식으로 표를 변경한 것입니다.\n\n![image](/TIL/assets/img/2024-07-09-HowtoHandleImbalancedDataforMachineLearninginPython_9.png)\n\n## 성능 비교\n\n다음은 Python 예제를 만들어보겠습니다.\n\n- 균형이 맞지 않은 데이터 세트를 만듭니다.\n- 언더샘플링 및 오버샘플링을 진행합니다.\n- 언더샘플링 및 오버샘플링된 데이터 세트에 대해 훈련 및 검증 세트를 만들고, KNN 분류기로 학습합니다.\n- 언더샘플링 및 오버샘플링된 데이터 세트의 정확도를 비교합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport numpy as np\nfrom sklearn.datasets import make_classification\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom imblearn.over_sampling import RandomOverSampler\nfrom imblearn.under_sampling import RandomUnderSampler\nfrom sklearn.metrics import accuracy_score\n```\n\n```js\n# 3개의 클래스를 가진 불균형 데이터셋 생성\nX, y = make_classification(\n    n_samples=1000,\n    n_features=20,\n    n_classes=3,\n    n_clusters_per_class=1,\n    weights=[0.1, 0.3, 0.6],  # 클래스 불균형\n    random_state=42\n)\n# 원본 데이터셋을 학습 및 테스트 세트로 분할\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n# RandomOverSampler를 사용하여 오버샘플링 적용\noversampler = RandomOverSampler(sampling_strategy='auto', random_state=42)\nX_train_oversampled, y_train_oversampled = oversampler.fit_resample(X_train, y_train)\n# RandomUnderSampler를 사용하여 언더샘플링 적용\nundersampler = RandomUnderSampler(sampling_strategy='auto', random_state=42)\nX_train_undersampled, y_train_undersampled = undersampler.fit_resample(X_train, y_train)\n# 원본 학습 세트에 KNN 분류기 피팅\nknn_original = KNeighborsClassifier(n_neighbors=5)\nknn_original.fit(X_train, y_train)\n# 오버샘플링된 학습 세트에 KNN 분류기 피팅\nknn_oversampled = KNeighborsClassifier(n_neighbors=5)\nknn_oversampled.fit(X_train_oversampled, y_train_oversampled)\n# 언더샘플링된 학습 세트에 KNN 분류기 피팅\nknn_undersampled = KNeighborsClassifier(n_neighbors=5)\nknn_undersampled.fit(X_train_undersampled, y_train_undersampled)\n# 학습 세트에 대한 예측 수행\ny_train_pred_original = knn_original.predict(X_train)\ny_train_pred_oversampled = knn_oversampled.predict(X_train_oversampled)\ny_train_pred_undersampled = knn_undersampled.predict(X_train_undersampled)\n# 테스트 세트에 대한 예측 수행\ny_test_pred_original = knn_original.predict(X_test)\ny_test_pred_oversampled = knn_oversampled.predict(X_test)\ny_test_pred_undersampled = knn_undersampled.predict(X_test)\n# 학습 세트의 정확도 계산 및 출력\nprint(\"원본 학습 세트 정확도:\", accuracy_score(y_train, y_train_pred_original))\nprint(\"오버샘플링된 학습 세트 정확도:\", accuracy_score(y_train_oversampled, y_train_pred_oversampled))\nprint(\"언더샘플링된 학습 세트 정확도:\", accuracy_score(y_train_undersampled, y_train_pred_undersampled))\n# 테스트 세트의 정확도 계산 및 출력\nprint(\"\\n원본 테스트 세트 정확도:\", accuracy_score(y_test, y_test_pred_original))\nprint(\"오버샘플링된 테스트 세트 정확도:\", accuracy_score(y_test, y_test_pred_oversampled))\nprint(\"언더샘플링된 테스트 세트 정확도:\", accuracy_score(y_test, y_test_pred_undersampled))\n```\n\n결과:\n\n```js\n원본 학습 세트 정확도: 0.9125\n오버샘플링된 학습 세트 정확도: 0.9514767932489452\n언더샘플링된 학습 세트 정확도: 0.85\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n원본 테스트 세트 정확도: 0.885\n오버샘플링된 테스트 세트 정확도: 0.79\n언더샘플링된 테스트 세트 정확도: 0.805\n```\n\n정확도 지표 비교를 통해 이러한 방법론의 특징을 확인할 수 있습니다:\n\n- 오버샘플링 기술은 KNN 모델이 오버피팅되고 있는 것을 시사하며, 이는 오버샘플링 그 자체 때문입니다.\n- 언더샘플링 기술은 KNN 모델이 편향될 수 있음을 시사하며, 이는 언더샘플링 그 자체 때문입니다.\n- 리샘플링 없이 모델을 학습시킨 것은 데이터의 불균형으로 정확도가 잘못 이끌 수 있음을 보여줍니다.\n\n따라서 이 경우, 가능한 해결책은 오버샘플링을 사용하고 KNN의 하이퍼파라미터를 조정하여 오버피팅을 피할 수 있는지 확인해 보는 것입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 앙상블\n\n불균형 데이터를 다루는 또 다른 방법은 앙상블 학습을 사용하는 것입니다. 특히, 랜덤 포레스트(Random Forest, RF)는 여러 의사 결정 트리 모델의 앙상블인데, 주 클래스에 편향되지 않는 내재적 능력으로 널리 사용되는 머신 러닝 모델입니다.\n\n그 이유는 다음과 같습니다:\n\n- Bootstrap 샘플링. RF 모델은 무작위 샘플링을 사용하여 작동합니다. 즉, 다양한 의사 결정 트리 모델을 훈련하는 동안, 선택된 데이터는 전체 데이터 세트의 무작위 하위 집합을 사용하고, 데이터는 대체됩니다. 이는 평균적으로 각 의사 결정 트리가 원래 데이터의 약 2/3에 대해 훈련됩니다. 결과적으로 소수 클래스의 일부 인스턴스가 의사 결정 트리를 작성하는 데 사용된 하위 집합에 포함될 가능성이 높습니다. 샘플 선택의 이 랜덤성은 주요 및 소수 클래스의 영향을 균형있게 조정하는 데 도움이 됩니다.\n- 무작위 특성 선택. 데이터를 무작위화하는 것 외에도, 랜덤 포레스트는 각 트리의 각 노드에 대해 무작위로 특성을 선택합니다. 즉, 분할할 때 고려할 특성의 무작위 하위 집합을 선택합니다. 이 특성의 무작위성은 대부분 주 클래스를 대표하는 특성에 대한 잠재적인 편향을 줄입니다.\n- 오류 수정 메커니즘. 랜덤 포레스트는 그 자체의 앙상블 성격을 통해 오류 수정 메커니즘을 사용합니다. 앙상블에서 한 의사 결정 트리가 소수 클래스 인스턴스에서 오류를 발생시키면, 앙상블의 다른 트리들은 해당 인스턴스에 대해 정확한 예측을 함으로써 보상할 수 있습니다. 앙상블 기반의 오류 수정은 주요 클래스의 우세함을 완화하는 데 도움이 됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이전에 만든 데이터세트를 고려해 봅시다. 랜덤 포레스트 분류기를 사용하여 적합한 결과를 살펴봅시다:\n\n```js\nimport numpy as np\nfrom sklearn.datasets import make_classification\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.metrics import accuracy_score\n```\n\n```js\n# 3개의 클래스로 불균형 데이터세트 생성\nX, y = make_classification(\n    n_samples=1000,\n    n_features=20,\n    n_classes=3,\n    n_clusters_per_class=1,\n    weights=[0.1, 0.3, 0.6],  # 클래스 불균형\n    random_state=42\n)\n# 데이터세트를 훈련 세트와 테스트 세트로 분할\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n# 훈련 세트에 랜덤 포레스트 분류기를 적합\nrf_classifier = RandomForestClassifier(random_state=42)\nrf_classifier.fit(X_train, y_train)\n# 훈련 세트와 테스트 세트에 대한 예측 생성\ny_train_pred = rf_classifier.predict(X_train)\ny_test_pred = rf_classifier.predict(X_test)\n# 훈련 세트의 정확도 계산 및 출력\ntrain_accuracy = accuracy_score(y_train, y_train_pred)\nprint(\"훈련 세트 정확도:\", train_accuracy)\n# 테스트 세트의 정확도 계산 및 출력\ntest_accuracy = accuracy_score(y_test, y_test_pred)\nprint(\"테스트 세트 정확도:\", test_accuracy)\n```\n\n그리고 우리는 다음과 같은 결과를 얻습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n학습 세트 정확도: 1.0\n테스트 세트 정확도: 0.97\n```\n\n이 경우에는 랜덤 포레스트를 사용했기 때문에 데이터 세트를 다시 샘플링할 필요가 없었습니다. 그래도 결과는 모델이 과적합될 가능성을 시사합니다. 이는 랜덤 포레스트 특성 때문일 수 있으므로 하이퍼파라미터 튜닝을 위해 추가적인 조사가 필요할 것입니다.\n\n어쨌든, 이 경우에는 하이퍼파라미터 튜닝 후 RF 모델을 사용하는 것이 KNN을 사용하고 데이터 세트를 언더샘플링하거나 오버샘플링하는 것보다 좋은 선택일 수 있습니다.\n\n# 결론\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 기사에서는 기계 학습(Machine Learning)에서 불균형 데이터를 다루는 방법에 대해 논의했습니다.\n\n특히, 희귀한 사건을 연구하기 때문에 데이터가 불균형할 것으로 예상되는 상황이 있습니다.\n\n반면에 데이터가 불균형해서는 안 되는 경우, 리샘플링(resampling)과 앙상블링(ensembling)과 같은 ML 모델을 다루는 방법에 대한 몇 가지 방법론을 소개했습니다.\n\n원문은 2024년 3월 7일 https://semaphoreci.com 에서 게시되었습니다.\n","ogImage":{"url":"/assets/img/2024-07-09-HowtoHandleImbalancedDataforMachineLearninginPython_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-HowtoHandleImbalancedDataforMachineLearninginPython_0.png","tag":["Tech"],"readingTime":33},{"title":"취미로 만든 파이썬 버전 관리 시스템 I Coded Pit 소개 ","description":"","date":"2024-07-09 14:31","slug":"2024-07-09-ICodedPitAVersionControlSysteminPythonforFun","content":"\n\u003cimg src=\"/TIL/assets/img/2024-07-09-ICodedPitAVersionControlSysteminPythonforFun_0.png\" /\u003e\n\n안녕하세요! Git이라는 신비한 도구를 모든 개발자가 지켜왔다는데, 그 실제 동작 원리가 궁금한 적이 있으신가요? 저도 그랬어요. Sanket Singh의 \"I coded Git in 1.5 hours | Make your own Version Control System 😎\"라는 YouTube 비디오에서 영감을 받아, 조금씩 코딩하는 모험을 떠났어요. 파이썬으로 제가 직접 버전 관리 시스템을 만들어보는 건 어떨까요?\n\n여기 ⛏️Pit이 나왔습니다! 귀엽고 놀랍도록 기능적인 버전 관리 시스템(VCS)이에요. 코딩을 즐기고 도전해보고 싶다는 이유로 만들었죠. 'Pit'이라는 이름은 깊고 어두운 구멍 연상시킬 수 있겠지만, 이 프로젝트는 사실 VCS의 매력적인 세계를 탐험하는 데 집중한 거예요. 게다가, 리포지토리를 초기화할 때 \"난 Pit을 파고 있어\"라고 말하는 건 정말 재미있는 일이에요.\n\nPit을 알아보기 전에 Git을 먼저 살펴볼까요? 2005년 Linus Torvalds가 만든 Git은 소스 코드의 변경 사항을 추적하는 분산 버전 관리 시스템으로, 여러 개발자가 협업할 수 있도록 하고 작업을 덮어쓰지 않게 합니다. 강력하고 유연하며 진지한 코딩 활동을 위해 필수적이에요.\n이론은 넘어가고 Pit이 완성된 후 어떻게 작동하는지 확인해보겠습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![2024-07-09-ICodedPitAVersionControlSysteminPythonforFun_1](/TIL/assets/img/2024-07-09-ICodedPitAVersionControlSysteminPythonforFun_1.png)\n\n안녕하세요! 이 두 부분으로 구성된 기사에서 Pit이 어떻게 작동하는지 알아보겠습니다. 환경을 설정하고 VCS의 핵심 구성 요소를 만드는 것부터 시작해서 변경 내용을 커밋하고 로그를 확인하는 고급 기능까지 살펴볼 거에요. 그러니 당신의 삽(아니, 키보드!)을 쥐고 함께 파는 것을 시작해봐요!\n\n# Pit을 파다 — 버전 컨트롤 시스템 설정하기\n\nPit은 명령줄 인터페이스를 통해 기본적인 버전 관리 기능을 제공하도록 설계되었습니다. 사용자는 새 저장소를 초기화하고 파일을 스테이징 영역에 추가하며 변경 사항을 커밋하고 커밋 로그를 확인하거나 저장소의 상태를 확인할 수 있어요.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 프로젝트 구조\n\n구현 세부 정보에 대해 파헤치기 전에 Pit 프로젝트의 구조를 살펴보겠습니다:\n\n```js\nproject/\n├── .pit/                 # 메인 저장소 디렉토리 (자동 생성됨)\n│   ├── objects/          # 객체(파일) 스냅샷을 저장하는 디렉토리\n│   ├── HEAD              # 현재 커밋을 참조하는 파일\n│   ├── index             # 스테이징 영역(스테이징된 파일의 목록)을 저장하는 파일\n├── pit.py                # Pit의 메인 Python 스크립트\n├── pit.cmd               # 명령 처리기\n├── 기타 파일들           # 프로젝트에 있는 기타 파일들\n```\n\nPit의 핵심은 Pit 클래스로, 핵심 기능을 캡슐화하고 Python의 pathlib 라이브러리를 통해 파일 시스템과 상호 작용합니다. 이 구조를 통해 Pit은 초기화된 디렉토리(초기화 명령)부터 커밋 스냅샷을 저장하는 일 등 저장소 데이터를 효과적으로 관리할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport os\nimport sys\nfrom pathlib import Path\nimport hashlib\nfrom datetime import datetime\nimport json\nfrom pprint import pp\n\nclass Pit:\n    def __init__(self, repo_path=\".\") -\u003e None:\n        self.repo_path = Path(repo_path, \".pit\")\n        self.objects_path = self.repo_path / \"objects\"\n        self.head_path = self.repo_path / \"HEAD\"\n        self.index_path = self.repo_path / \"index\"\n```\n\n# Implementing init Command\n\npit init\n\n## Project Initialization with Pit\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nPit을 사용하기 위해서는 새 저장소를 초기화해야 합니다. 이 과정은 프로젝트 내에서 버전 관리를 관리하기 위한 필요한 디렉터리 구조와 파일을 설정합니다.\n\n## 저장소 구조 설정\n\n파이썬의 Pit 클래스는 start 메서드를 통해 이 초기화를 처리합니다. 다음은 포함된 단계를 살펴봅시다:\n\n저장소 존재 여부 확인: start 메서드는 먼저 지정된 또는 현재 디렉토리(repo_path)에 .pit 디렉터리가 이미 존재하는지 확인합니다. 이미 존재한다면 저장소가 이미 존재한다는 메시지를 인쇄하고 프로그램을 종료합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\ndef start(self):\n    if self.repo_path.exists():\n        print(\"⛏️  이미 작업공간이 존재합니다!\")\n        sys.exit(1)\n```\n\n저장소 디렉토리 생성: 저장소가 존재하지 않는 경우, Pit은 경로를 이용하여 주요 .pit 디렉토리 및 하위 디렉토리 (objects, HEAD, index)를 생성합니다. 여기서 objects 디렉토리는 파일 내용의 스냅샷을 보관하고, HEAD 파일은 현재 커밋을 추적하며, index 파일은 변경 사항을 위한 스테이징 영역 역할을 합니다.\n\n```python\ndef start(self):\n    # ...\n    self.repo_path.mkdir(exist_ok=True)\n    self.objects_path.mkdir(exist_ok=True)\n    self.head_path.touch(exist_ok=True)\n    if not self.index_path.exists():\n        with self.index_path.open(\"w\") as index_file:\n            index_file.write(\"[]\")\n    print(\"⛏️  할일들을 처리중...\")\n```\n\ninit 명령어를 구현함으로써, Pit은 프로젝트 이력과 변경 사항을 관리하기 위한 기초를 마련합니다. 이 체계적인 접근은 업무 분리를 명확히 하고, 파일 추가 (add), 변경 내용 커밋 (commit), 커밋 로그 보기 (log)와 같은 후속 작업을 위해 저장소를 준비합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# add 명령어 구현\n\npit add `파일명`\n\n## Pit을 사용하여 스테이징 변경하기\n\n리포지토리를 초기화한 후에 Pit을 사용하는 다음 단계는 변경 사항을 스테이징하는 것입니다. 특히, 파일을 스테이징 영역에 추가하는 것입니다. 이를 통해 사용자는 프로젝트 파일의 버전을 제어하고 조직적으로 관리하기 위해 수정 사항을 다음 커밋을 위해 준비할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 스테이징 영역에 파일 추가하기\n\nPit 클래스의 add 메서드는 이 과정을 용이하게 도와줍니다. 이러한 과정을 살펴보겠습니다:\n\n파일 데이터 읽기: add 메서드는 read_file 도우미 메서드를 사용하여 file_path로 지정된 파일의 내용을 읽어옵니다.\n\n```js\ndef add(self, file_path):\n    file_data = self.read_file(file_path)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파일 내용 해싱: 다음으로, Pit은 파일 내용의 SHA-1 해시를 계산하여 파일을 고유하게 식별합니다. 이 해시는 체크섬으로 작용하여 무결성을 보장하고 파일 버전을 빠르게 찾을 수 있도록 합니다.\n\n```js\ndef add(self, file_path):\n    # ...\n    file_hash = self.hash_object(file_data)\n```\n\n오류 처리: 지정된 파일이 존재하지 않을 경우 (FileNotFoundError), Pit은 오류 메시지를 인쇄하고 정상적으로 종료합니다.\n\n```js\ndef add(self, file_path):\n    # ...\n    if not file_data:\n        print(f\"⛏️  Error: {file_path}를 찾을 수 없습니다!\")\n        sys.exit(1)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기존 파일 확인: Pit은 객체 디렉토리에 동일한 해시를 가진 파일이 이미 있는지 확인합니다. 이미 존재한다면 해당 파일이 이미 저장소에 추가되었음을 나타냅니다.\n\n```python\ndef add(self, file_path):\n    # ...\n    if self.check_hash_exists(file_hash):\n        print(f\"⛏️  오류: {file_path}이(가) 이미 존재합니다!\")\n        sys.exit(1)\n```\n\n파일 스테이징: 새 파일이며 검사를 통과하면 Pit은 파일 내용을 해시된 이름으로 객체 디렉토리에 저장합니다. 인덱스 파일을 업데이트하여 다음 커밋을 위해 파일 경로와 해시를 포함시킵니다.\n\n```python\ndef add(self, file_path):\n    # ...\n    object_path = self.objects_path / file_hash\n    self.write_file(object_path, file_data)\n    self.update_staging_area(file_path, file_hash)\n    print(f\"⛏️  {file_path}를 스테이징 영역에 추가했습니다\")\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# commit 명령어 구현하기\n\npit commit \"메시지\"\n\n## Pit를 사용하여 프로젝트 스냅샷 캡처하기\n\nadd 명령어로 변경 사항을 스테이징한 후, Pit을 사용하여 버전 관리하는 다음 단계는 이러한 변경 사항을 커밋하는 것입니다. 커밋은 프로젝트의 현재 상태에 대한 스냅샷을 생성하고, 저장소의 히스토리에 기록합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 변경 내용 커밋하기\n\nPit 클래스의 commit 메서드는 이 프로세스를 용이하게 합니다. 이에 관련된 단계를 살펴봅시다:\n\nStaged 파일 읽기: commit 메서드는 as_list 도우미 메서드를 사용하여 인덱스 파일에서 Staged 파일의 목록을 검색하는 작업으로 시작합니다.\n\n```js\ndef commit(self, message):\n    index = self.as_list(self.read_file(self.index_path))\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n현재 HEAD 가져오기: 그런 다음 get_current_head 메서드를 사용하여 HEAD 파일에서 현재 커밋 (HEAD)의 해시를 검색합니다.\n\n```js\ndef commit(self, message):\n    # ...\n    parent_commit = self.get_current_head()\n```\n\n커밋 데이터 생성: Pit은 부모 커밋 해시 (있는 경우), 커밋 메시지, 타임스탬프 및 스테이징된 파일 목록을 포함한 커밋 데이터를 구성합니다. 이 데이터는 JSON 형식으로 직렬화됩니다.\n\n```js\ndef commit(self, message):\n    # ...\n    commit_data = json.dumps({\n        \"parent\": parent_commit,\n        \"message\": message,\n        \"date\": datetime.now().isoformat(),\n        \"files\": index\n    })\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n커밋 데이터 해싱: 직렬화된 커밋 데이터에 대해 SHA-1 해시가 계산되어 저장소 내에서 커밋을 고유하게 식별합니다.\n\n```python\ndef commit(self, message):\n    # ...\n    commit_hash = self.hash_object(str(commit_data))\n```\n\n커밋 객체 저장: Pit은 커밋 데이터를 해시 된 이름으로 objects 디렉토리에 기록하여 프로젝트 상태를 영구적으로 기록합니다.\n\n```python\ndef commit(self, message):\n    # ...\n    commit_path = self.objects_path / commit_hash\n    self.write_file(commit_path, str(commit_data))\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nHEAD 및 인덱스 업데이트: HEAD 파일이 새로운 커밋 해시를 가리키도록 업데이트되어 저장소의 최신 상태를 나타냅니다. 인덱스 파일이 지워져, 향후 변경을 위한 스테이징 영역이 재설정됩니다.\n\n```python\ndef commit(self, message):\n    # ...\n    self.write_file(self.head_path, commit_hash)\n    self.write_file(self.index_path, \"[]\")\n```\n\n작업 완료 메시지: 마지막으로, Pit은 성공적으로 커밋되었음을 나타내는 확인 메시지를 출력하고 참조용으로 커밋 해시를 표시합니다.\n\n```python\ndef commit(self, message):\n    # ...\n    print(f\"⛏️  {commit_hash}로 커밋되었습니다.\")\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 로그 명령어 구현\n\npit log\n\n## Pit로 프로젝트 이력 탐색하기\n\n커밋 명령어로 변경 사항을 커밋한 후, Pit은 로그 명령어를 통해 사용자가 저장소의 이력을 탐색할 수 있습니다. 이 명령어는 커밋들의 연대순 목록을 표시하여 프로젝트의 진화와 시간이 지남에 따른 변경 사항 순서를 제공합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 커밋 로그 보기\n\nPit 클래스의 log 메서드는 이 프로세스를 용이하게합니다. 함께 차례대로 진행해 보겠습니다:\n\n현재 HEAD 가져오기: log 메서드는 get_current_head 메서드를 사용하여 HEAD 파일에서 현재 커밋의 해시를 검색하여 시작됩니다.\n\n```js\ndef log(self):\n    current_commit_hash = self.get_current_head()\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n커밋 반복: Pit은 루프를 사용하여 현재 HEAD부터 시작하여 커밋 기록을 반복합니다. 초기 커밋 (부모가 없는 곳)에 도달할 때까지 커밋 데이터를 가져와 표시합니다.\n\n```python\ndef log(self):\n    # ...\n    while current_commit_hash:\n        commit_data = self.read_file(self.objects_path / current_commit_hash)\n        commit_data = json.loads(commit_data)\n```\n\n커밋 정보 표시: 각 커밋에 대해 Pit은 커밋 해시, 커밋 메시지 및 기타 세부 정보 (예: 타임스탬프, 부모 커밋 등)와 같은 관련 정보를 출력합니다.\n\n```python\ndef log(self):\n    # ...\n        # ...\n        print(f\"⛏️  Commit: {current_commit_hash}\")\n        pp(commit_data)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 커밋 기록 탐색: `Pit`은 `current_commit_hash`를 부모 커밋의 해시로 업데이트하여 초기 커밋부터 최신 커밋까지 저장소의 기록을 탐색할 수 있습니다.\n\n```python\ndef log(self):\n    # ...\n        # ...\n        current_commit_hash = commit_data.get('parent')\n```\n\n### 커밋이 없는 경우 처리: 만약 커밋이 없다면 (HEAD가 없는 경우), `Pit`은 아직 커밋이 없다는 메시지를 출력합니다.\n\n```python\ndef log(self):\n    # ...\n    if not current_commit_hash:\n        print(\"⛏️  아직 커밋이 없습니다!\")\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음은 클래스에서 중요한 메소드였습니다. 사용자를 안내해주는 도우미 메소드인 show_usage()도 있습니다.\n\nPit의 show_usage 함수는 사용자가 유효한 명령을 지정하지 않거나 잘못된 인수를 제공하여 도구를 호출했을 때 사용법 지침과 명령 옵션을 표시하는 유틸리티로 작용합니다. 이 함수를 통해 사용자는 명령 줄 인터페이스(CLI)를 통해 Pit와 효과적으로 상호 작용하는 방법을 이해할 수 있습니다.\n\n```js\ndef show_usage():\n    print(\"⛏️  Pit - 간단한 버전 관리 시스템\")\n    print(\"사용법: pit \u003ccommand\u003e [\u003cargs\u003e]\")\n    print(\"명령어:\")\n    print(\"  init        빈 pit 저장소 생성\")\n    print(\"  add         파일을 스테이징 영역에 추가\")\n    print(\"  commit      변경 사항을 저장소에 기록\")\n    print(\"  log         커밋 로그보기\")\n```\n\n# 명령 줄 인터페이스(CLI) 작업 관리\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n피트(Pit)의 주요 기능인 main 함수는 명령줄 인터페이스(CLI)를 통해 버전 관리 작업을 실행하는 진입점으로 기능합니다. 이 함수는 사용자, 다양한 피트(init, add, commit, log) 명령어, 그리고 피트 클래스의 기본 기능 간의 상호 작용을 조정합니다. 이 함수는 클래스 외부에 있어야 합니다.\n\nmain 함수는 사용자가 전달한 명령줄 인자를 처리하고, 이에 해당하는 동작을 피트 클래스 내에서 정의된 메소드에 위임합니다. 코드를 살펴봅시다:\n\n```js\nif __name__ == \"__main__\"\n    def main():\n        pit = Pit()\n        if len(sys.argv) \u003c 2:\n            show_usage()\n            sys.exit(1)\n        command = sys.argv[1]\n        if command == \"init\":\n            pit.start()\n        elif command == \"add\":\n            if len(sys.argv) \u003c 3:\n                print(\"Usage: pit add \u003cfile_path\u003e\")\n                sys.exit(1)\n            file_path = sys.argv[2]\n            if file_path == \"*\":\n                for file in Path(\".\").rglob(\"*\"):\n                    if file.is_file():\n                        pit.add(file)\n            else:\n                pit.add(file_path)\n         elif command == \"commit\":\n            if len(sys.argv) \u003c 3:\n                print(\"Usage: pit commit \u003cmessage\u003e\")\n                sys.exit(1)\n            message = sys.argv[2]\n            pit.commit(message)\n        elif command == \"log\":\n            pit.log()\n        else:\n            show_usage()\n            sys.exit(1)\n```\n\n## 배치 스크립트\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 배치 스크립트 (pit.cmd)는 Python 모듈(pit)과 상호 작용하는 간단한 방법을 제공합니다. 이 모듈은 버전 관리 기능을 구현하며, Python의 직접적인 모듈 실행 능력(-m 플래그)을 활용하여 명령줄 인수를 원활하게 전달함으로써 윈도우 명령 프롬프트에서 pit 모듈을 유연하고 직관적으로 사용할 수 있습니다.\n\n```js\n@echo OFF\npython -m pit %*\n```\n\n# 결론\n\n이 pit과의 여정 첫 부분에서 우리는 Python 기반 버전 관리 시스템의 기본 설정 및 초기 작업을 탐색했습니다. 우리는 pit init을 사용하여 새 저장소를 초기화하여 프로젝트 히스토리를 관리하는 데 필요한 디렉토리 구조를 설정했습니다. 이후에는 pit add로 스테이징 영역에 파일을 추가하고, pit commit으로 변경 사항을 커밋하며, pit log를 통해 커밋 히스토리를 살펴보았습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위 기초적인 명령어들을 통해, 우리는 변경 사항을 추적하고 버전을 관리하며 협업과 프로젝트 관리에 체계적인 방법을 제공하는 피트를 위한 기반을 마련했습니다. 첫 번째 파트에서는 Python 프로젝트 내에서 피트를 효과적으로 활용하기 위한 필수 도구들을 갖추었습니다.\n\n곧 공개될 Part 2를 기대해 주세요. 거기에서는 피트를 이해하고 적용하는 능력을 향상시켜 우리의 개발 워크플로우를 더욱 강화할 것입니다.\n","ogImage":{"url":"/assets/img/2024-07-09-ICodedPitAVersionControlSysteminPythonforFun_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-ICodedPitAVersionControlSysteminPythonforFun_0.png","tag":["Tech"],"readingTime":17},{"title":"TensorFlow Transform 프로덕션에서 매끄러운 데이터 준비를 위한 필수 가이드","description":"","date":"2024-07-09 14:29","slug":"2024-07-09-TensorFlowTransformEnsuringSeamlessDataPreparationinProduction","content":"\n## 제품 환경을 위한 데이터 파이프라인 확장을 위한 TensorFlow Transform 활용\n\n![이미지](/TIL/assets/img/2024-07-09-TensorFlowTransformEnsuringSeamlessDataPreparationinProduction_0.png)\n\n데이터 전처리는 머신 러닝 파이프라인에서 중요한 단계 중 하나입니다. TensorFlow Transform은 거대한 데이터셋 위에서 분산 환경에서 이를 달성하는 데 도움이 됩니다.\n\n데이터 변환에 대해 더 알아보기 전에, 제품 파이프라인 프로세스의 첫 번째 단계인 데이터 유효성 검사에 대해 다룬 제 글 \"TFX 방식으로 제품 파이프라인에서 데이터 유효성 검사하기\"가 있습니다. 더 나은 이해를 위해 이 글을 확인해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 데모에서는 환경을 구성하는 것이 훨씬 쉽고 빠르기 때문에 이를 위해 Colab을 사용했습니다. 탐색 단계에 있다면 중요한 부분에 집중할 수 있도록 도와줄 Colab을 추천드립니다.\n\nML 파이프라인 작업은 데이터 수집 및 검증으로 시작하여 변환을 거칩니다. 변환된 데이터는 학습 및 배포됩니다. 이전 글에서 검증 부분을 다루었고, 이제는 변환 부분을 다룰 예정입니다. Tensorflow에서 파이프라인에 대한 더 나은 이해를 위해 아래 글을 확인해보세요.\n\n이전에 말한 대로 Colab을 사용할 것입니다. 그래서 tfx 라이브러리를 설치하면 됩니다.\n\n```js\n! pip install tfx\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2024-07-09-TensorFlowTransformEnsuringSeamlessDataPreparationinProduction_1.png\" /\u003e\n\n그 다음은 imports가 옵니다.\n\n```js\n# 라이브러리 가져오기\n\nimport tensorflow as tf\n\nfrom tfx.components import CsvExampleGen\nfrom tfx.components import ExampleValidator\nfrom tfx.components import SchemaGen\nfrom tfx.v1.components import ImportSchemaGen\nfrom tfx.components import StatisticsGen\nfrom tfx.components import Transform\n\nfrom tfx.orchestration.experimental.interactive.interactive_context import InteractiveContext\nfrom google.protobuf.json_format import MessageToDict\n\nimport os\n```\n\n저희는 데이터 유효성 검사 기사에서와 같이 Kaggle에서 제공하는 타이타닉 우주선 데이터셋을 사용할 것입니다. 이 데이터셋은 상업적 및 비상업적 용도로 무료로 사용할 수 있습니다. 여기에서 데이터셋에 접근할 수 있습니다. 데이터셋에 대한 설명이 아래 그림에 표시되어 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2024-07-09-TensorFlowTransformEnsuringSeamlessDataPreparationinProduction_2.png\" /\u003e\n\n데이터 변환 부분을 시작하기 위해서는 파이프라인 구성 요소를 배치할 폴더를 생성하는 것이 좋습니다(그렇지 않으면 기본 디렉터리에 배치됩니다). 저는 파이프라인 구성 요소를 위한 하나와 훈련 데이터를 위한 다른 하나의 폴더를 만들었습니다.\n\n```js\n# 파이프라인 폴더 경로\n# 생성된 모든 구성 요소는 여기에 저장됩니다\n_pipeline_root = '/content/tfx/pipeline/'\n\n# 훈련 데이터 경로\n# 여러 훈련 데이터 파일을 포함할 수도 있습니다\n_data_root = '/content/tfx/data/'\n```\n\n그 다음으로, InteractiveContext를 만들고 파이프라인 디렉터리 경로를 전달합니다. 이 과정은 또한 파이프라인 프로세스의 메타데이터를 저장하기 위한 sqlite 데이터베이스를 생성합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nInteractiveContext은 각 단계를 탐색하는 데 사용됩니다. 각 단계에서 생성된 아티팩트를 확인할 수 있습니다. 프로덕션 환경에서는 Apache Beam과 같은 파이프라인 생성 프레임워크를 사용하면 이 전체 프로세스가 개입없이 자동으로 실행될 것입니다.\n\n```js\n# InteractiveContext 초기화\n# 이는 메타데이터를 저장하기 위해 sqlite db를 생성합니다\n\ncontext = InteractiveContext(pipeline_root=_pipeline_root)\n```\n\n다음으로 데이터 수집부터 시작합니다. 데이터가 csv 파일로 저장되어 있다면 CsvExampleGen을 사용하여 데이터 파일이 저장된 디렉터리 경로를 전달할 수 있습니다.\n\n```js\n# 입력 CSV 파일\nexample_gen = CsvExampleGen(input_base=_data_root)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nTFX는 현재 csv, tf.Record, BigQuery 및 일부 사용자 정의 실행기를 지원합니다. 자세한 내용은 아래 링크에서 확인할 수 있어요.\n\n`ExampleGen` 구성 요소를 실행하려면 `context.run`을 사용하세요.\n\n```js\n# 구성 요소 실행하기\n\ncontext.run(example_gen)\n```\n\n구성 요소를 실행한 후, 아래와 같은 출력이 생성됩니다. 실행 ID, 구성 요소 세부 정보 및 구성 요소의 출력이 저장된 위치가 표시됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2024-07-09-TensorFlowTransformEnsuringSeamlessDataPreparationinProduction_3.png\" /\u003e\n\n확장하면 이 상세 정보를 볼 수 있어야 합니다.\n\n\u003cimg src=\"/TIL/assets/img/2024-07-09-TensorFlowTransformEnsuringSeamlessDataPreparationinProduction_4.png\" /\u003e\n\n디렉토리 구조는 아래 이미지와 같습니다. 이 모든 아티팩트들은 TFX에 의해 자동으로 생성되었습니다. 또한 자동으로 버전이 지정되며 세부 정보는 metadata.sqlite에 저장됩니다. 해당 sqlite 파일은 데이터 출처 또는 데이터 계보를 유지하는 데 도움이 됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래와 같이 코드를 사용하여 이러한 자료를 프로그램적으로 탐색해 보세요.\n\n```js\n# 생성된 자료 확인\nartifact = example_gen.outputs['examples'].get()[0]\n\n# 분할 이름과 URI 표시\nprint(f'split names: {artifact.split_names}')\nprint(f'artifact uri: {artifact.uri}')\n```\n\n출력은 파일 이름과 URI가 될 것입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Image](/TIL/assets/img/2024-07-09-TensorFlowTransformEnsuringSeamlessDataPreparationinProduction_6.png)\n\n이제 train uri를 복사하여 파일 내부의 세부 정보를 살펴보겠습니다. 파일은 zip 파일로 저장되어 있으며 TFRecordDataset 형식으로 저장되어 있습니다.\n\n```js\n# 훈련 예제를 나타내는 출력 아티팩트의 URI를 가져옵니다\ntrain_uri = os.path.join(artifact.uri, 'Split-train')\n\n# 이 디렉토리에 있는 파일 목록(모든 압축된 TFRecord 파일)을 가져옵니다\ntfrecord_filenames = [os.path.join(train_uri, name)\n                      for name in os.listdir(train_uri)]\n\n# 이 파일들을 읽을 `TFRecordDataset`을 생성합니다\ndataset = tf.data.TFRecordDataset(tfrecord_filenames, compression_type=\"GZIP\")\n```\n\n아래 코드는 Tensorflow에서 가져온 것이며, TFRecordDataset에서 레코드를 가져와 결과를 반환하여 검사할 수 있는 표준 코드입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 도우미 함수로 개별 예제 가져오기\n\ndef get_records(dataset, num_records):\n'''주어진 데이터 세트에서 레코드를 추출합니다.\n매개변수:\ndataset (TFRecordDataset): ExampleGen에 의해 저장된 데이터 세트\nnum_records (int): 미리보기할 레코드 수\n'''\n\n    # 빈 리스트를 초기화합니다.\n    records = []\n\n    # 가져올 레코드 수를 지정하는 `take()` 메서드 사용\n    for tfrecord in dataset.take(num_records):\n\n        # 텐서의 넘파이 속성을 가져옵니다.\n        serialized_example = tfrecord.numpy()\n\n        # 직렬화된 데이터를 읽기 위해 `tf.train.Example()`을 초기화합니다.\n        example = tf.train.Example()\n\n        # 예제 데이터를 읽습니다 (결과는 프로토콜 버퍼 메시지입니다).\n        example.ParseFromString(serialized_example)\n\n        # 프로토콜 버퍼 메시지를 Python 사전으로 변환합니다.\n        example_dict = (MessageToDict(example))\n\n        # 레코드 목록에 추가합니다.\n        records.append(example_dict)\n\n    return records\n\n# 데이터 세트에서 3개의 레코드 가져오기\n\nsample_records = get_records(dataset, 3)\n\n# 결과 출력\n\npp.pprint(sample_records)\n\n3개의 레코드를 요청했고, 출력은 다음과 같습니다. 각 레코드와 해당 메타데이터가 사전 형식으로 저장됩니다.\n\n\u003cimg src=\"/TIL/assets/img/2024-07-09-TensorFlowTransformEnsuringSeamlessDataPreparationinProduction_7.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음으로, 다음 단계로 진행하여 StatisticsGen을 사용하여 데이터의 통계를 생성하는 과정으로 이동합니다. example_gen 객체에서 출력을 인수로 전달합니다.\n\nstatistics.run을 사용하여 구성 요소를 실행합니다. 이때 statistics_gen을 인수로 전달합니다.\n\n```js\n# example_gen 객체를 사용하여 StatisticsGen으로 데이터 집합 통계 생성\n\nstatistics_gen = StatisticsGen(\n    examples=example_gen.outputs['examples'])\n\n# 구성 요소 실행\ncontext.run(statistics_gen)\n```\n\n결과를 확인하려면 context.show를 사용할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 출력 통계 보기\n\ncontext.show(statistics_gen.outputs['statistics'])\n```\n\nTFDV (TensorFlow Data Validation) 기사에서 설명한 통계 생성과 매우 유사하다는 것을 알 수 있습니다. 그 이유는 TFX가 이러한 작업을 수행하기 위해 내부적으로 TFDV를 사용하기 때문입니다. TFDV에 익숙해지면 이러한 프로세스를 더 잘 이해하는 데 도움이 될 것입니다.\n\n\u003cimg src=\"/TIL/assets/img/2024-07-09-TensorFlowTransformEnsuringSeamlessDataPreparationinProduction_8.png\" /\u003e\n\n다음 단계는 스키마를 생성하는 것입니다. 이 작업은 statistics_gen 객체를 전달하여 SchemaGen을 사용하여 수행됩니다. 구성 요소를 실행하고 context.show를 사용하여 시각화하세요.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 통계_gen 객체를 사용하여 SchemaGen을 사용하여 스키마 생성\n\nschema_gen = SchemaGen(\n    statistics=statistics_gen.outputs['statistics'],\n    )\n\n# 컴포넌트 실행\ncontext.run(schema_gen)\n\n# 스키마 시각화\n\ncontext.show(schema_gen.outputs['schema'])\n```\n\n출력 결과에는 데이터의 기본 스키마에 관한 세부 정보가 표시됩니다. TFDV와 마찬가지로입니다.\n\n\u003cimg src=\"/TIL/assets/img/2024-07-09-TensorFlowTransformEnsuringSeamlessDataPreparationinProduction_9.png\" /\u003e\n\n여기에 제시된 스키마를 수정해야 하는 경우 tfdv를 사용하여 수정하고 스키마 파일을 생성할 수 있습니다. ImportSchemaGen을 사용하여 새 파일을 tfx에 사용하도록 요청할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 스키마 파일을 수동으로 추가\nschema_gen = ImportSchemaGen(schema_file=\"path_to_schema_file/schema.pbtxt\")\n```\n\n다음으로, ExampleValidator를 사용하여 예제를 유효성 검사합니다. statistics_gen 및 schema_gen을 인수로 전달합니다.\n\n```js\n# ExampleValidator를 사용하여 예제 유효성을 검사\n# statistics_gen 및 schema_gen 객체를 전달합니다\n\nexample_validator = ExampleValidator(\n    statistics=statistics_gen.outputs['statistics'],\n    schema=schema_gen.outputs['schema'])\n\n# 구성 요소를 실행합니다.\ncontext.run(example_validator)\n```\n\n모든 것이 잘되었음을 나타내는 이상적인 출력입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![TensorFlowTransformEnsuringSeamlessDataPreparationinProduction_10](/TIL/assets/img/2024-07-09-TensorFlowTransformEnsuringSeamlessDataPreparationinProduction_10.png)\n\nAt this point, our directory structure looks like the image above. We can see that for every step in the process, the corresponding artifacts are created.\n\n![TensorFlowTransformEnsuringSeamlessDataPreparationinProduction_11](/TIL/assets/img/2024-07-09-TensorFlowTransformEnsuringSeamlessDataPreparationinProduction_11.png)\n\nLet us move on to the actual transformation part. We will now create the `constants.py` file to add all the constants required for the process.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 이 프로젝트에 사용할 모든 상수를 포함하는 파일 생성\n\n\\_constants_module_file = 'constants.py'\n\n모든 상수를 생성하고 constants.py 파일에 쓸 것입니다. “%%writefile '\\_constants_module_file'”을 참조하세요. 이 몤령어는 코드를 실행시키지 않고 대신 주어진 셀의 모든 코드를 지정된 파일로 작성합니다.\n\n%%writefile {\\_constants_module_file}\n\n# 문자열 데이터 유형을 인덱스로 변환할 기능\n\nCATEGORICAL_FEATURE_KEYS = ['CryoSleep', 'Destination', 'HomePlanet', 'VIP']\n\n# 지속적인 것으로 표시된 숫자 기능\n\nNUMERIC_FEATURE_KEYS = ['Age', 'FoodCourt', 'RoomService', 'ShoppingMall', 'Spa', 'VRDeck']\n\n# 버킷에 그룹화할 수 있는 기능\n\nBUCKET_FEATURE_KEYS = ['Age']\n\n# 각 버킷 기능을 인코딩하는 데 사용하는 버킷 수\n\nFEATURE_BUCKET_COUNT = {'Age': 4}\n\n# 모델이 예측할 기능\n\nLABEL_KEY = 'Transported'\n\n# 기능 이름을 바꾸기 위한 유틸리티 함수\n\ndef transformed_name(key):\nreturn key + '\\_xf'\n\n실제 데이터를 변환하는 코드를 포함하는 transform.py 파일을 생성합시다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 프로젝트를 위한 전처리 코드가 포함된 파일을 생성합니다.\n\n_transform_module_file = 'transform.py'\n```\n\n여기서는 tensorflow_transform 라이브러리를 사용할 것입니다. 변환 과정에 대한 코드는 preprocessing_fn 함수 안에 작성될 것입니다. 변환 과정에서 tfx가 내부적으로 이를 찾을 수 있도록 동일한 이름을 사용해야 합니다.\n\n```js\n%%writefile {_transform_module_file}\n\nimport tensorflow as tf\nimport tensorflow_transform as tft\n\nimport constants\n\n# 상수 모듈의 내용을 언패킹합니다.\n_NUMERIC_FEATURE_KEYS = constants.NUMERIC_FEATURE_KEYS\n_CATEGORICAL_FEATURE_KEYS = constants.CATEGORICAL_FEATURE_KEYS\n_BUCKET_FEATURE_KEYS = constants.BUCKET_FEATURE_KEYS\n_FEATURE_BUCKET_COUNT = constants.FEATURE_BUCKET_COUNT\n_LABEL_KEY = constants.LABEL_KEY\n_transformed_name = constants.transformed_name\n\n\n# 변환을 정의합니다.\ndef preprocessing_fn(inputs):\n\n    outputs = {}\n\n    # 이러한 기능들을 [0,1] 범위로 스케일링합니다.\n    for key in _NUMERIC_FEATURE_KEYS:\n        outputs[_transformed_name(key)] = tft.scale_to_0_1(\n            inputs[key])\n\n    # 이러한 기능들을 버킷으로 나눕니다.\n    for key in _BUCKET_FEATURE_KEYS:\n        outputs[_transformed_name(key)] = tft.bucketize(\n            inputs[key], _FEATURE_BUCKET_COUNT[key])\n\n    # 문자열을 어휘 사전의 인덱스로 변환합니다.\n    for key in _CATEGORICAL_FEATURE_KEYS:\n        outputs[_transformed_name(key)] = tft.compute_and_apply_vocabulary(inputs[key])\n\n    # 라벨 문자열을 인덱스로 변환합니다.\n    outputs[_transformed_name(_LABEL_KEY)] = tft.compute_and_apply_vocabulary(inputs[_LABEL_KEY])\n\n    return outputs\n```\n\n이 데모에서는 몇 가지 표준 스케일링 및 인코딩 함수를 사용했습니다. transform 라이브러리에는 실제로 다양한 함수가 포함되어 있습니다. 여기에서 살펴보세요.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 변환 과정을 보겠습니다. Transform 객체를 생성하고 example_gen 및 schema_gen 객체와 함께 우리가 만든 transform.py 파일의 경로를 전달합니다.\n\n```js\n# TF 경고 메시지 무시\ntf.get_logger().setLevel('ERROR')\n\n# example_gen 및 schema_gen 객체로 Transform 구성 요소 인스턴스화\n# transform 파일의 경로를 전달\n\ntransform = Transform(\n    examples=example_gen.outputs['examples'],\n    schema=schema_gen.outputs['schema'],\n    module_file=os.path.abspath(_transform_module_file))\n\n# 구성 요소 실행\ncontext.run(transform)\n```\n\n실행하고 변환 부분이 완료되었습니다!\n\n아래 이미지에 나타난 변환된 데이터를 살펴보세요.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![TensorFlow Transform](/TIL/assets/img/2024-07-09-TensorFlowTransformEnsuringSeamlessDataPreparationinProduction_12.png)\n\n# 그냥 scikit-learn 라이브러리나 pandas를 사용하는 것은 왜 아닌가요?\n\n지금 이게 여러분의 질문인가요?\n\n이 프로세스는 데이터 전처리를 원하는 개인을 위한 것이 아닙니다. 모델 훈련을 시작하고 싶은 사람들을 위한 것이 아닙니다. 이것은 대규모 데이터 (분산 처리를 요구하는 데이터)와 끊어질 여지가 없는 자동화된 프로덕션 파이프라인에 적용되어야 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n변환을 적용한 후에 폴더 구조가 다음과 같이 보입니다\n\n![folder structure](/TIL/assets/img/2024-07-09-TensorFlowTransformEnsuringSeamlessDataPreparationinProduction_13.png)\n\n여기에는 변환 전후의 세부 내용이 포함되어 있습니다. 또한 변환 그래프도 만들어졌습니다.\n\n우리는 tft.scale_to_0_1을 사용하여 숫자 특성을 스케일링했습니다. 이러한 함수는 전체 데이터를 분석해야 하는 세부 정보를 계산해야 합니다(예: 특성 내 평균, 최소값 및 최대값). 여러 기계에 분산된 데이터를 분석하여 이러한 세부 정보를 얻는 것은 성능이 많이 필요합니다(특히 여러 번 수행해야 하는 경우). 이러한 세부 사항은 한 번 계산되고 변환 그래프에 유지됩니다. 함수가 이러한 세부 정보를 필요로 할 때마다, 그것은 바로 변환 그래프에서 검색됩니다. 또한 학습 단계에서 생성된 변환을 직접 서빙 데이터에 적용하여 전처리 단계에서 일관성을 보장하는 데 도움이 됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nTensorflow Transform 라이브러리를 사용하는 또 다른 주요 장점은 모든 단계가 아티팩트로 기록되어 데이터 계보가 유지된다는 것입니다. 또한 데이터가 변경될 때 자동으로 데이터 버전 관리가 수행됩니다. 이로 인해 제품 환경에서의 실험, 배포 및 롤백이 쉬워집니다.\n\n여기까지 입니다. 궁금한 점이 있으시면 댓글 섹션에 남겨주세요.\n\n본문에 사용된 노트북 및 데이터 파일은 이 링크를 통해 내 GitHub 저장소에서 다운로드할 수 있습니다.\n\n# 다음은 무엇일까요?\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파이프라인 구성 요소를 더 잘 이해하기 위해 아래 글을 읽어보세요.\n\n제 글을 읽어주셔서 감사합니다. 마음에 드셨다면 몇 개의 박수로 격려해 주시고, 만약 다른 쪽에 계신다면 의견란에 개선할 점을 알려주세요. 안녕히 가세요.\n\n특별히 언급하지 않는 한, 모든 이미지는 저자가 찍은 것입니다.\n","ogImage":{"url":"/assets/img/2024-07-09-TensorFlowTransformEnsuringSeamlessDataPreparationinProduction_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-TensorFlowTransformEnsuringSeamlessDataPreparationinProduction_0.png","tag":["Tech"],"readingTime":18},{"title":"모델 성능 시각화 Python 코드로 혼동 행렬 그리는 방법 가이드","description":"","date":"2024-07-09 14:27","slug":"2024-07-09-VisualizingModelPerformanceAGuidetoPlottingConfusionMatricesinPythonCode","content":"\n\u003cimg src=\"/TIL/assets/img/2024-07-09-VisualizingModelPerformanceAGuidetoPlottingConfusionMatricesinPythonCode_0.png\" /\u003e\n\n안녕하세요! 이 기사에서는 머신러닝 모델을 평가하는데 있어서 혼동 행렬의 중요성에 대해 살펴보겠습니다. 혼동 행렬이 무엇이며, 어떻게 작동하는지, 그리고 분류 모델의 성능을 평가하는 데 왜 중요한지에 대한 자세한 설명을 제공할 것입니다. 게다가, 우리는 혼동 행렬을 그리는 Python 함수를 살펴보고, 결과를 효과적으로 해석하는 방법에 대한 통찰을 제공할 것입니다.\n\n## 혼동 행렬 소개\n\n혼동 행렬은 분류 알고리즘의 성능을 평가하는 데 사용되는 표입니다. 예측된 레이블을 실제 레이블과 비교하여 모델이 얼마나 잘 수행되고 있는지 명확하게 보여줍니다. 이 행렬은 모델이 어떤 종류의 오류를 범하고 있는지 이해하는 데 특히 유용하며, 개선할 부분을 식별하는 데 도움이 됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 혼동 행렬의 구조\n\n이진 분류 문제의 혼동 행렬은 일반적으로 다음과 같은 모습을 갖습니다:\n\n![Confusion Matrix](/TIL/assets/img/2024-07-09-VisualizingModelPerformanceAGuidetoPlottingConfusionMatricesinPythonCode_1.png)\n\n다중 클래스 분류 문제의 경우, 행렬은 더 많은 클래스를 수용하도록 확장됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 정확도: 정확도 점수 이상의 자세한 정확도 정보를 제공합니다.\n- 오류 분석: 오류 유형(거짓 양성 및 거짓 음성)을 식별하는 데 도움이 됩니다.\n- 모델 개선: 오분류를 이해함으로써 모델을 개선하는 데 유용한 통찰을 제공합니다.\n\n## Python으로 혼동 행렬 플로팅\n\n```js\nimport itertools\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndef plot_confusion_matrix(cm, class_labels=None, normalize=False, figsize=(10, 10)):\n    \"\"\"\n    레이블 및 백분율로 혼동 행렬을 플로팅합니다.\n\n    Args:\n        cm (numpy.ndarray): 혼동 행렬.\n        class_labels (list, optional): 클래스에 대한 사용자 정의 레이블. 기본값은 None입니다.\n        normalize (bool, optional): 백분율을 위해 혼동 행렬을 정규화할지 여부. 기본값은 False입니다.\n        figsize (tuple, optional): 도표의 크기. 기본값은 (10, 10)입니다.\n\n    Returns:\n        None\n    \"\"\"\n    n_classes = cm.shape[0]\n\n    # 플로팅을 위한 도표 및 축 생성\n    fig, ax = plt.subplots(figsize=figsize)\n\n    # 혼동 행렬 시각화를 위한 컬러맵 생성\n    cax = ax.matshow(cm, cmap=plt.cm.Blues)  # 다른 컬러맵을 사용할 수 있습니다\n\n    # 플롯에 컬러바 추가\n    fig.colorbar(cax)\n\n    # 축 레이블 (선택사항)\n    if class_labels is not None:\n        labels = class_labels\n    else:\n        labels = np.arange(cm.shape[0])\n\n    # 축 레이블 및 제목 설정\n    ax.set(\n        title=\"혼동 행렬\",\n        xlabel=\"예측된 레이블\",\n        ylabel=\"실제 레이블\",\n        xticks=np.arange(n_classes),\n        yticks=np.arange(n_classes),\n        xticklabels=labels,\n        yticklabels=labels,\n    )\n\n    # 가독성을 높이기 위해 x축 레이블 회전\n    ax.xaxis.set_label_position(\"bottom\")\n    ax.xaxis.tick_bottom()\n\n    # 레이블 크기 조정\n    plt.setp(ax.xaxis.get_majorticklabels(), size=20)\n    plt.setp(ax.yaxis.get_majorticklabels(), size=20)\n    ax.title.set_size(20)\n\n    # 텍스트 색상 임계값 계산\n    threshold = (cm.max() + cm.min()) / 2.\n\n    # 필요한 경우 혼동 행렬 정규화\n    if normalize:\n        cm = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis]\n\n    # 혼동 행렬의 각 요소를 순회하고 텍스트 주석 추가\n    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):\n        # 값 및 백분율 표시 (선택사항)\n        text = f\"{cm[i, j]:.2f}\" if normalize else f\"{cm[i, j]}\"\n\n        # 임계값에 기반한 텍스트 색상 설정\n        color = \"white\" if cm[i, j] \u003e threshold else \"black\"\n\n        # 중앙 정렬 및 적절한 크기로 텍스트 주석 추가\n        ax.text(\n            j,\n            i,\n            text,\n            ha=\"center\",\n            va=\"center\",\n            color=color,\n            fontsize=15,\n        )\n\n    # 혼동 행렬 플롯 표시\n    plt.show()\n```\n\nPlot Confusion Matrix 함수 사용 방법\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 혼동 행렬 생성: 플로팅하기 전에 모델의 예측과 실제 레이블을 이용해 혼동 행렬을 생성해야 합니다. 이를 위해 sklearn.metrics.confusion_matrix를 사용할 수 있습니다.\n\n```js\nfrom sklearn.metrics import confusion_matrix\n\ny_pred = model.predict(X_test)\ncm = confusion_matrix(y_test, y_pred)\n```\n\n2. 혼동 행렬 플로팅: 생성된 행렬로 plot_confusion_matrix 함수를 호출하세요.\n\n```js\nplot_confusion_matrix(cm, (class_labels = [\"Class 0\", \"Class 1\"]), (normalize = True));\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n혼동 행렬은 분류 모델의 성능을 평가하는 강력한 도구입니다. 이들은 모델이 얼마나 잘 수행되고 있는지에 대한 포괄적인 관점을 제공하며 개선이 필요한 부분을 강조합니다. 혼동 행렬을 시각화함으로써, 모델의 동작에 대한 더 깊은 통찰력을 얻고 미래 개선을 위한 정보를 파악할 수 있습니다.\n\n본 문서에서는 혼동 행렬을 플로팅하는 Python 함수를 제공하고 사용 방법을 설명했습니다. 이 함수를 워크플로에 통합함으로써, 모델의 예측을 효과적으로 분석하고 해석할 수 있어 더 나은 정확도의 머신 러닝 모델에 이르게 될 것입니다.\n","ogImage":{"url":"/assets/img/2024-07-09-VisualizingModelPerformanceAGuidetoPlottingConfusionMatricesinPythonCode_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-VisualizingModelPerformanceAGuidetoPlottingConfusionMatricesinPythonCode_0.png","tag":["Tech"],"readingTime":5}],"page":"24","totalPageCount":34,"totalPageGroupCount":2,"lastPageGroup":14,"currentPageGroup":1},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"24"},"buildId":"Pi4433xRlbDszsHxI9gPN","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>