<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>TIL</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//posts/12" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="TIL" data-gatsby-head="true"/><meta property="og:title" content="TIL" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//posts/12" data-gatsby-head="true"/><meta name="twitter:title" content="TIL" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/a76947e4a2088726.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/a76947e4a2088726.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/873-eb138c3217d71553.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/posts/%5Bpage%5D-de1dc5579188f9be.js" defer=""></script><script src="/TIL/_next/static/KUC9M_yIlA1Ugo01xmkHL/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/KUC9M_yIlA1Ugo01xmkHL/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Next.js 15에서 instrumentation-client.js 로 웹사이트 분석 도구 사용하기₩" href="/TIL/post/2025-04-22-instrumentation-clientjs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15에서 instrumentation-client.js 로 웹사이트 분석 도구 사용하기₩" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15에서 instrumentation-client.js 로 웹사이트 분석 도구 사용하기₩" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15에서 instrumentation-client.js 로 웹사이트 분석 도구 사용하기₩</strong><div class="PostList_meta__VCFLX"><span class="date">18 hours ago</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="instrumentation.js로 웹사이트 성능 측정 도구 만들기" href="/TIL/post/2025-04-22-instrumentationjs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="instrumentation.js로 웹사이트 성능 측정 도구 만들기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="instrumentation.js로 웹사이트 성능 측정 도구 만들기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">instrumentation.js로 웹사이트 성능 측정 도구 만들기</strong><div class="PostList_meta__VCFLX"><span class="date">18 hours ago</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="nextjs 15 접근 금지 페이지 forbidden.js로 쉽게 만드는 방법" href="/TIL/post/2025-04-22-forbiddenjs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="nextjs 15 접근 금지 페이지 forbidden.js로 쉽게 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="nextjs 15 접근 금지 페이지 forbidden.js로 쉽게 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">nextjs 15 접근 금지 페이지 forbidden.js로 쉽게 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">18 hours ago</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js 15에서 error.js 파일로 에러 처리하는 방법 정리" href="/TIL/post/2025-04-22-errorjs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15에서 error.js 파일로 에러 처리하는 방법 정리" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15에서 error.js 파일로 에러 처리하는 방법 정리" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15에서 error.js 파일로 에러 처리하는 방법 정리</strong><div class="PostList_meta__VCFLX"><span class="date">18 hours ago</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js 15 Parallel Routes default.js 활용법 정리" href="/TIL/post/2025-04-22-defaultjs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15 Parallel Routes default.js 활용법 정리" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15 Parallel Routes default.js 활용법 정리" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15 Parallel Routes default.js 활용법 정리</strong><div class="PostList_meta__VCFLX"><span class="date">18 hours ago</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nextjs 15 Script 태그 사용 방법" href="/TIL/post/2025-04-22-Script"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nextjs 15 Script 태그 사용 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nextjs 15 Script 태그 사용 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Nextjs 15 Script 태그 사용 방법</strong><div class="PostList_meta__VCFLX"><span class="date">19 hours ago</span><span class="PostList_reading_time__6CBMQ">25<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js 15에서 Link 컴포넌트로 라우팅하는 방법" href="/TIL/post/2025-04-22-Link"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15에서 Link 컴포넌트로 라우팅하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15에서 Link 컴포넌트로 라우팅하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15에서 Link 컴포넌트로 라우팅하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">19 hours ago</span><span class="PostList_reading_time__6CBMQ">37<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js 15에서 이미지 최적화하는 5가지 방법" href="/TIL/post/2025-04-22-Image"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15에서 이미지 최적화하는 5가지 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15에서 이미지 최적화하는 5가지 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15에서 이미지 최적화하는 5가지 방법</strong><div class="PostList_meta__VCFLX"><span class="date">19 hours ago</span><span class="PostList_reading_time__6CBMQ">99<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js 15에서 폼(Form) 쉽게 만드는 방법" href="/TIL/post/2025-04-22-Form"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15에서 폼(Form) 쉽게 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15에서 폼(Form) 쉽게 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15에서 폼(Form) 쉽게 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">19 hours ago</span><span class="PostList_reading_time__6CBMQ">17<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nextjs 15에서 Font Module 사용하는 방법 가이드" href="/TIL/post/2025-04-22-FontModule"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nextjs 15에서 Font Module 사용하는 방법 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nextjs 15에서 Font Module 사용하는 방법 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Nextjs 15에서 Font Module 사용하는 방법 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">19 hours ago</span><span class="PostList_reading_time__6CBMQ">34<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/TIL/posts/1">1</a><a class="link" href="/TIL/posts/2">2</a><a class="link" href="/TIL/posts/3">3</a><a class="link" href="/TIL/posts/4">4</a><a class="link" href="/TIL/posts/5">5</a><a class="link" href="/TIL/posts/6">6</a><a class="link" href="/TIL/posts/7">7</a><a class="link" href="/TIL/posts/8">8</a><a class="link" href="/TIL/posts/9">9</a><a class="link" href="/TIL/posts/10">10</a><a class="link" href="/TIL/posts/11">11</a><a class="link posts_-active__YVJEi" href="/TIL/posts/12">12</a><a class="link" href="/TIL/posts/13">13</a><a class="link" href="/TIL/posts/14">14</a><a class="link" href="/TIL/posts/15">15</a><a class="link" href="/TIL/posts/16">16</a><a class="link" href="/TIL/posts/17">17</a><a class="link" href="/TIL/posts/18">18</a><a class="link" href="/TIL/posts/19">19</a><a class="link" href="/TIL/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Next.js 15에서 instrumentation-client.js 로 웹사이트 분석 도구 사용하기₩","description":"","date":"2025-04-22 02:38","slug":"2025-04-22-instrumentation-clientjs","content":"\n\n# instrumentation-client.js\n\ninstrumentation-client.js|ts 파일은 여러분의 애플리케이션 프런트엔드 코드가 실행되기 전에 모니터링이나 분석 코드를 추가할 수 있게 해줍니다. 이를 통해 성능 추적, 오류 감지 같은 클라이언트 측 관찰성 도구들을 쉽고 빠르게 셋업할 수 있죠.\n\n사용 방법도 아주 간단해요! 파일을 애플리케이션 루트 폴더나 `src` 폴더 안에 넣기만 하면 준비 완료입니다.\n\n## 사용법\n\n(여기서부터 구체적인 사용법을 이어서 작성하면 됩니다.)  \n\n이렇게 미리 모니터링 코드를 두면, 현장에서 발생하는 문제를 더 빨리 발견할 수 있고, 서비스 품질을 높이는데 큰 도움이 되니 꼭 활용해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n서버 사이드 계측(instrumentation)과 달리, 클라이언트 쪽에서는 특정 함수를 따로 export할 필요가 없어요. 그냥 원하는 파일 안에 모니터링 코드를 바로 작성해주시면 됩니다.\n\n```js\n// 퍼포먼스 모니터링 시작 시점 찍기\nperformance.mark('app-init')\n \n// 애널리틱스 초기화\nconsole.log('Analytics initialized')\n \n// 에러 추적 세팅\nwindow.addEventListener('error', (event) =\u003e {\n  // 에러 추적 서비스로 에러 데이터 전송\n  reportError(event.error)\n})\n```\n\n이렇게 간단히 작성할 수 있죠. \n\n참고로 `performance.mark()`는 브라우저의 성능 측정 API로, 특정 시점에 표시를 찍어서 나중에 성능 분석 자료로 활용할 수 있어요. 그리고 `window.addEventListener('error', ...)`를 사용하면 페이지 내에서 발생하는 자바스크립트 에러를 잡아내서 별도의 추적 시스템에 전송할 수 있어서 디버깅에 매우 유용합니다.\n\n---\n\n## 버전 히스토리\n\n| Version | Changes                         |\n|---------|--------------------------------|\n| v15.3   | `instrumentation-client` 도입  |\n\n`instrumentation-client`를 도입하면서 클라이언트 쪽에서도 더 쉽게 모니터링 코드 작성이 가능해졌어요. 이 부분 활용하면 애플리케이션 상태를 실시간으로 추적하거나 성능 병목을 빠르게 찾는 데 큰 도움이 됩니다.","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":2},{"title":"instrumentation.js로 웹사이트 성능 측정 도구 만들기","description":"","date":"2025-04-22 02:38","slug":"2025-04-22-instrumentationjs","content":"\n\n# instrumentation.js\n\ninstrumentation.js|ts 파일은 애플리케이션에 관찰 가능성(Observability) 도구를 통합하는 용도로 사용돼요. 이를 통해 애플리케이션의 성능과 동작을 추적할 수 있고, 실제 서비스 중에 발생하는 문제를 더 효과적으로 디버깅할 수 있답니다.\n\n사용법도 간단해요! 프로젝트 루트 디렉토리에 파일을 두거나, 만약 src 폴더를 사용한다면 그 안에 넣으면 되죠.\n\n## 파일에서 제공하는 주요 기능 (Exports)\n\n(여기에 실제로 어떤 내용이 export 되는지 명시되어야 하는데요, 이어서 있으면 같이 정리해보겠습니다.)\n\n---\n\n### 조금 더 알아두면 좋은 점!\n\n- 관찰 가능성 도구에는 여러 가지가 있는데, 예를 들어 로그 수집, 메트릭 수집, 트레이싱 등이 있어요. instrumentation.js를 통해 이런 도구들을 한 곳에 모아 효율적으로 관리할 수 있어요.\n- 실제 운영 환경에서 문제가 발생했을 때, 미리 설정한 instrumentation 덕분에 원인을 빠르게 파악할 수 있으니 개발, 운영 모두에 큰 도움이 된답니다.\n- TypeScript를 사용한다면 .ts 확장자를 사용해 타입 안정성을 더할 수도 있어요.\n\n다음에는 instrumentation.js 안에 어떤 코드가 들어가는지, 구체적인 예시를 하나씩 살펴보도록 할게요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### register (선택 사항)\n\nNext.js 서버가 새로 시작될 때 한 번 호출되는 `register` 함수를 파일에서 export할 수 있어요. 이 함수는 async 함수여도 되고, 주로 초기 설정이나 라이브러리 등록 같은 작업에 사용되죠.\n\n예를 들어, 아래처럼 OpenTelemetry를 연동하는 작업을 할 수 있어요:\n\n```js\nimport { registerOTel } from '@vercel/otel'\n \nexport function register() {\n  registerOTel('next-app')\n}\n```\n\n위 코드에서 `registerOTel` 함수는 'next-app'이라는 이름으로 OpenTelemetry를 설정해주는 역할을 해요. 이 부분은 프로젝트에서 필요한 모니터링이나 트레이싱을 할 때 유용하답니다.\n\n### onRequestError (선택 사항)\n\n`onRequestError` 함수도 선택 사항인데요, 이 함수는 HTTP 요청 중 에러가 발생했을 때 실행되도록 만들어져 있어요. 만약 API 라우트나 서버 함수에서 에러 로그를 따로 남기거나 오류를 처리하고 싶을 때 이 함수를 정의해서 사용할 수 있답니다.\n\n---\n\n참고로, `register` 함수 같은 초기화 함수는 앱이 구동될 때 한 번만 실행되기 때문에 무거운 초기 작업이나 설정을 이곳에 모아두면 깔끔하게 관리할 수 있어요. Next.js를 활용할 때, 이런 선택적 함수들로 서버 사이드의 세밀한 로직을 다루는 팁을 꼭 알아두시면 좋아요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 onRequestError라는 함수를 선택적으로 내보내서 서버 에러를 커스텀한 관측(Observability) 도구로 추적할 수 있어요.\n\n- 만약 onRequestError 안에서 비동기 작업을 한다면 꼭 `await` 해줘야 해요. 이 함수는 Next.js 서버가 에러를 포착할 때 실행되거든요.\n- 여기서 주의할 점! 에러 인스턴스가 실제로 던져진 원본 에러가 아닐 수도 있어요. 특히 Server Components 렌더링 도중 React가 처리한 에러라면 그럴 수 있는데, 이럴 때는 에러 객체의 `digest` 속성을 이용해서 실제 에러 타입을 확인할 수 있답니다.\n\n아래 코드를 보면 실제로 onRequestError에서 에러 정보를 외부 서버로 POST 요청을 보내서 보고하는 간단한 예시를 보여주고 있어요:\n\n```js\nimport { type Instrumentation } from 'next'\n \nexport const onRequestError: Instrumentation.onRequestError = async (\n  err,\n  request,\n  context\n) =\u003e {\n  await fetch('https://.../report-error', {\n    method: 'POST',\n    body: JSON.stringify({\n      message: err.message,\n      request,\n      context,\n    }),\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  })\n}\n```\n\n### onRequestError 함수 파라미터\n\n| 파라미터명  | 설명                                                   |\n|-------------|--------------------------------------------------------|\n| `err`       | 발생한 에러 객체입니다. React가 가공할 수도 있어요.            |\n| `request`   | 현재 요청 정보가 담긴 객체입니다.                             |\n| `context`   | 요청에 관련된 추가 컨텍스트 정보가 들어있습니다.                   |\n\n이걸 활용하면 서버 에러를 커스텀 로그 서버나 Sentry, Datadog 같은 외부 모니터링 서비스에 손쉽게 연결할 수 있어요. 특히 여러 비동기 작업을 할 때 `await`를 빠뜨리지 않도록 주의해주세요! 안 그러면 에러 추적이 중간에 끊길 수 있거든요.\n\n그리고 `digest` 프로퍼티를 써서 에러 타입을 확인하는 팁! React에서 처리된 에러는 내부적으론 변형될 수 있기 때문에, 원래 에러를 정확히 파악하려면 이걸 참고하면 좋아요.\n\n이 기능을 잘 쓰면 서버 안정성 모니터링에 훨씬 도움 돼서, 문제 발생 시 빠르게 대응 가능하니 꼭 한번 적용해보시길 추천드립니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번에는 `onRequestError` 함수에 대해 알아볼게요. 이 함수는 에러가 발생했을 때 호출되며, 세 가지 매개변수를 받아요: `error`, `request`, 그리고 `context`입니다.\n\n```ts\nexport function onRequestError(\n  error: { digest: string } \u0026 Error,\n  request: {\n    path: string; // 리소스 경로, 예: /blog?name=foo\n    method: string; // 요청 메서드, 예: GET, POST 등\n    headers: { [key: string]: string };\n  },\n  context: {\n    routerKind: 'Pages Router' | 'App Router'; // 사용하는 라우터 종류\n    routePath: string; // 라우트 파일 경로, 예: /app/blog/[dynamic]\n    routeType: 'render' | 'route' | 'action' | 'middleware'; // 에러 발생 컨텍스트\n    renderSource:\n      | 'react-server-components'\n      | 'react-server-components-payload'\n      | 'server-rendering'; // 렌더링 소스\n    revalidateReason: 'on-demand' | 'stale' | undefined; // 재검증 사유, undefined 는 일반 요청 의미\n    renderType: 'dynamic' | 'dynamic-resume'; // 'dynamic-resume'은 PPR 사용 시\n  }\n): void | Promise\u003cvoid\u003e;\n```\n\n| 파라미터 | 설명                        |\n|----------|-----------------------------|\n| `error`  | 발생한 실제 에러, 고유 ID인 `digest` 포함 |\n| `request`| 에러와 관련된 요청 정보      |\n| `context`| 에러가 발생한 환경 정보를 담고 있음 |\n\n### 파라미터 자세히 살펴보기\n\n- `error`: 항상 Error 타입이며, 여기에 `digest`라는 고유 ID가 있어 에러를 추적하기 좋습니다. 예를 들어, 같은 에러가 여러 번 발생할 경우 이 ID로 쉽게 분류할 수 있죠.\n- `request`: 실제 요청 정보입니다. 어떤 경로(`path`)로, 어떤 메서드(`method`)가 쓰였고, 헤더에는 어떤 정보가 담겨있는지 확인할 수 있어요.\n- `context`: 어느 라우터에서 발생했는지(`routerKind`), 어떤 라우트 파일에서 발생했는지(`routePath`), 그리고 에러가 일어난 시점(`routeType`)을 알려줍니다. 렌더링 소스(`renderSource`)나 재검증 사유(`revalidateReason`)도 담겨있어, 상황별 대응에 유용해요.\n\n### 추가 팁: 왜 이렇게 복잡한 정보가 필요할까?\n\n에러 핸들링은 단순히 에러 메시지를 로그에 남기는 걸 넘어서, 상황에 맞게 대처하거나 사용자에게 정확한 안내를 해주는 데 중요해요. 예를 들어 `revalidateReason`이 `'stale'`이면 캐시된 데이터를 다시 불러오는 중 문제가 생긴 거고, 이를 활용하면 재시도 로직이나 사용자 안내 메시지를 다르게 할 수 있겠죠.\n\n최근 Next.js 같은 프레임워크가 여러 라우터 시스템과 다양한 렌더링 방식을 지원하면서, 이런 세분화된 정보가 꼭 필요해졌답니다.\n\n---\n\n다음에 이어서 `### Specifying the runtime` 부분도 한 번 살펴볼게요! 혹시 여기까지 궁금한 점 있으면 댓글로 물어봐 주세요 :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\ninstrumentation.js 파일은 Node.js와 Edge 런타임 둘 다에서 동작하는데요, 만약 특정 런타임을 대상으로 하고 싶다면 process.env.NEXT_RUNTIME 값을 활용하면 됩니다.\n\n```js\nexport function register() {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    return require('./register.edge')\n  } else {\n    return require('./register.node')\n  }\n}\n\nexport function onRequestError() {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    return require('./on-request-error.edge')\n  } else {\n    return require('./on-request-error.node')\n  }\n}\n```\n\n여기서 중요한 점은 process.env.NEXT_RUNTIME이 'edge'인지 아닌지에 따라서 각각 다른 모듈을 require해서 사용하는 방식이에요. 이렇게 하면 동일한 코드베이스에서 런타임 환경에 맞게 동작 방식을 유연하게 바꿀 수 있어서 정말 편리합니다.\n\n---\n\n## 버전 히스토리\n\n| Version   | Changes                                    |\n|-----------|--------------------------------------------|\n| v15.0.0   | `onRequestError` 추가, `instrumentation` 안정화 |\n| v14.0.4   | `instrumentation`에 Turbopack 지원 추가        |\n| v13.2.0   | `instrumentation` 실험적 기능으로 처음 소개      |\n\n버전 히스토리를 보면 알 수 있듯, instrumentation 기능이 처음에는 실험적으로 도입됐다가 이후 안정화 되고, Turbopack 같은 최신 툴도 지원이 추가되면서 점점 완성도 있게 발전해온 걸 확인할 수 있어요.\n\n---\n\n개발할 때 runtime 환경 구분이 필요한 경우에는 이렇게 환경변수를 통해 동적으로 모듈을 분기하는 패턴을 자주 쓰게 되는데, Next.js 같은 프레임워크에서 공식적으로 지원하니까 훨씬 편하게 적용할 수 있는 것 같더라고요. 혹시 특정 런타임에서만 동작하는 코드를 작성하려고 하면 참고해보시면 좋을 것 같아요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":8},{"title":"nextjs 15 접근 금지 페이지 forbidden.js로 쉽게 만드는 방법","description":"","date":"2025-04-22 02:37","slug":"2025-04-22-forbiddenjs","content":"\n\n# forbidden.js 파일 설명\n\nNext.js에서 인증 과정 중 forbidden 함수가 호출될 때 표시되는 UI를 커스터마이징할 수 있는 파일이 바로 forbidden.js예요. 이 파일을 통해 사용자가 권한이 없을 때 어떤 화면을 보여줄지 자유롭게 디자인할 수 있답니다. 그리고 중요한 점은, 이 컴포넌트를 렌더링하면 Next.js가 자동으로 HTTP 상태 코드 403(Forbidden)을 반환한다는 거예요.\n\n예를 들어, 기본적인 forbidden.js는 아래처럼 작성할 수 있어요:\n\n```js\nimport Link from 'next/link'\n\nexport default function Forbidden() {\n  return (\n    \u003cdiv\u003e\n      \u003ch2\u003eForbidden\u003c/h2\u003e\n      \u003cp\u003eYou are not authorized to access this resource.\u003c/p\u003e\n      \u003cLink href=\"/\"\u003eReturn Home\u003c/Link\u003e\n    \u003c/div\u003e\n  )\n}\n```\n\n조금 더 친근하게 메시지를 바꾸거나, 추가적인 안내 문구를 넣어 사용자 경험을 개선할 수도 있겠죠? 예를 들어, 로그인이 필요한 경우라면 로그인 페이지로 바로 가는 버튼을 추가하는 것도 좋은 방법이에요.\n\n```js\nimport Link from 'next/link'\n\nexport default function Forbidden() {\n  return (\n    \u003cdiv style={{ textAlign: 'center', margin: '2rem' }}\u003e\n      \u003ch2\u003e접근 금지\u003c/h2\u003e\n      \u003cp\u003e이 페이지에 접근할 권한이 없어요.\u003c/p\u003e\n      \u003cp\u003e계속하려면 로그인이 필요합니다.\u003c/p\u003e\n      \u003cLink href=\"/login\"\u003e\n        \u003ca style={{ color: 'blue', textDecoration: 'underline' }}\u003e로그인 하러 가기\u003c/a\u003e\n      \u003c/Link\u003e\n      \u003cbr /\u003e\n      \u003cLink href=\"/\"\u003e\n        \u003ca style={{ color: 'gray', marginTop: '1rem', display: 'inline-block' }}\u003e홈으로 돌아가기\u003c/a\u003e\n      \u003c/Link\u003e\n    \u003c/div\u003e\n  )\n}\n```\n\n\u003e 참고로, 이런 방식으로 UI를 커스텀하면 사용자에게 명확한 안내를 제공할 수 있고, 더 나은 사용자 경험(UX)을 만들 수 있다는 점 기억하세요!\n\n## 참고자료\n- Next.js 공식 문서: [Error Handling](https://nextjs.org/docs/advanced-features/custom-error-page)\n- HTTP 상태 코드 403: [MDN - 403 Forbidden](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/403)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### Props\n\nforbidden.js 컴포넌트는 어떤 props도 받지 않습니다.\n\n## 버전 히스토리\n\n| 버전       | 변경사항                   |\n|------------|---------------------------|\n| `v15.1.0`  | forbidden.js가 새로 추가됨 |\n\n버전 히스토리를 보면 forbidden.js는 v15.1.0에서 처음 등장했네요. 새로운 컴포넌트를 도입할 때는 이렇게 변경사항을 꼼꼼히 챙겨두면 나중에 관리할 때 정말 도움이 됩니다. 개발하면서 버전 관리는 꼭 습관처럼 하시길 추천드려요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":3},{"title":"Next.js 15에서 error.js 파일로 에러 처리하는 방법 정리","description":"","date":"2025-04-22 02:36","slug":"2025-04-22-errorjs","content":"\n\n# error.js 파일 이해하기: 예기치 않은 에러 처리하기\n\n프로그래밍 하다 보면 갑자기 예상하지 못한 에러가 발생할 때가 있어요. 이럴 때 사용자에게 깔끔한 ‘에러 메시지’를 보여주고, 앱이 갑자기 죽지 않도록 안전하게 처리하는 게 중요하죠. 이번에 소개할 `error.js` 파일은 그런 에러를 잡아내고 사용자에게 알림 UI(화면)를 보여주는 역할을 해요.\n\n---\n\n## 핵심 코드 정리\n\n```js\n'use client' // Error boundaries는 Client 측 컴포넌트여야 해요\n\nimport { useEffect } from 'react'\n\nexport default function Error({\n  error,\n  reset,\n}: {\n  error: Error \u0026 { digest?: string }\n  reset: () =\u003e void\n}) {\n  useEffect(() =\u003e {\n    // 에러가 발생하면 콘솔과 같은 에러 리포팅 서비스에 기록하세요\n    console.error(error)\n  }, [error])\n\n  return (\n    \u003cdiv\u003e\n      \u003ch2\u003eSomething went wrong!\u003c/h2\u003e\n      \u003cbutton onClick={() =\u003e reset()}\u003e\n        Try again\n      \u003c/button\u003e\n    \u003c/div\u003e\n  )\n}\n```\n\n---\n\n## 주요 포인트\n\n| 항목 | 설명 |\n|---|---|\n| `'use client'` | 에러 경계(Error Boundary)는 **클라이언트 컴포넌트**여야 한다는 점! 서버 컴포넌트에서는 에러 경계를 사용할 수 없어요. |\n| `useEffect` | 에러가 발생하면 로깅(log)하는 부분이에요. 보통 여기에 Sentry, LogRocket 같은 에러 수집 서비스 코드를 넣기도 하죠. |\n| `reset` 함수 | 사용자가 “Try again” 버튼을 누르면 이 `reset` 함수가 실행되면서, 문제가 발생한 부분을 다시 렌더링하는 시도를 합니다. |\n\n---\n\n## 제가 더 알려드리고 싶은 점!\n\n- **에러 경계란?**  \n  리액트에서는 ‘에러 경계’라는 개념이 있는데, 컴포넌트 트리 어느 한 부분에서 에러가 나더라도, 해당 부분만 격리해서 에러 UI를 보여주고 전체 앱이 멈추지 않도록 도와줍니다.\n\n- **에러 처리할 때 어디에 쓰면 좋을까?**  \n  보통 사용자가 조작하는 주요 화면 컴포넌트 주변에 적용하면 좋아요. 예를 들어, 특정 API 호출이 실패하거나, 컴포넌트 내부 상태가 꼬였을 때 앱이 멈추는 걸 방지하죠.\n\n- **추가 아이디어**  \n  에러 메시지를 조금 더 사용자 친화적으로 바꾸거나, 에러 상세 내용을 개발자용 로그에만 남기고 사용자는 간단하게 안내하는 것도 좋은 UX 방식입니다.\n\n- **실무 꿀팁!**  \n  에러 발생 시 단순히 console.error만 하기보단, 별도의 에러 모니터링 툴(Sentry, Bugsnag 등)과 연동해두면 실시간으로 문제를 감지하고 빠르게 대응할 수 있어서 정말 좋아요.\n\n---\n\n요약하면, `error.js` 파일은 “앱이 갑자기 멈추지 않고 사용자에게 안내 메시지를 띄우면서, 다시 시도할 수 있도록 도와주는 작은 안전망” 같은 역할을 하는 컴포넌트입니다. 다음 프로젝트에 적용해보면 에러 대응이 한결 수월해질 거예요! 😊\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nerror.js는 라우트 세그먼트와 그 안에 중첩된 자식들을 React의 에러 경계(Error Boundary)로 감싸주는 역할을 해요. 만약 이 경계 내에서 에러가 발생하면, 에러 컴포넌트가 대체 UI(fallback UI)로 보여지게 되죠.\n\n![Error Boundary 예시]( /assets/img/2025-04-22-errorjs_1.png )\n\n\u003e 알아두면 좋은 팁!\n\u003e React DevTools에서는 에러 경계를 토글해가며 실제 에러 상태를 테스트할 수 있어요.\n\u003e 만약 하위 에러 경계에서 발생한 에러가 부모 에러 경계까지 전달되길 원한다면, 에러 컴포넌트 렌더링 시점에 에러를 다시 던지(throw)면 됩니다.\n\n에러 경계(Error Boundary)는 React에서 UI가 예기치 않게 깨지는 상황을 방지하고 사용자에게도 친절한 메시지를 보여줄 수 있는 좋은 방법인데요, React 16 버전부터 도입된 기능이랍니다. 에러 경계 안에서만 렌더링되는 컴포넌트가 문제가 생기면 그 부분만 대체 UI로 교체되고, 전체 앱이 다운되는 걸 막아줘요.\n\n만약 이 기능을 제대로 활용하고싶다면, 한번 직접 React DevTools에서 에러 경계 토글 기능을 사용해 보면서 에러 상태 테스트를 해보는 걸 추천드려요. 실제 서비스에서 에러 상황을 어떻게 커버할지 고민할 때 큰 도움이 될 거예요!\n\n필요하면 이걸로 사용자에게 에러 메시지를 커스텀하거나, 에러 로그를 서버로 보내는 등의 작업도 할 수 있으니 참고하시고요.\n\n## 참고 자료  \n- [React 공식 문서 - Error Boundaries](https://reactjs.org/docs/error-boundaries.html)  \n- [React DevTools](https://reactjs.org/blog/2019/08/15/new-react-devtools.html)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### Props\n\n#### error\n\n`error`는 `error.js` 클라이언트 컴포넌트로 전달되는 Error 객체의 인스턴스입니다.\n\n\u003e 알아두면 좋은 점: 개발 환경에서는 클라이언트로 전달되는 Error 객체가 직렬화되어 원래 에러 메시지를 포함해 디버깅이 더 쉽도록 도와줍니다. 하지만 프로덕션 환경에서는 잠재적으로 민감한 정보가 클라이언트로 유출되는 것을 막기 위해 이 동작이 달라진다는 점 참고하세요.\n\n추가로, 이런 에러 핸들링 방식을 통해 개발할 때에는 에러 메시지를 좀 더 자유롭게 확인할 수 있지만, 실제 운영 환경에서는 안전을 최우선으로 생각하기 때문에 에러 내용이 제한적으로 전달된다는 점 기억해두시면 좋아요. 에러 관련 코드를 작성할 때는 이 점을 고려해 로깅이나 모니터링도 함께 신경 써주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n#### error.message\n\n- 클라이언트 컴포넌트에서 전달된 에러는 원래의 에러 메시지를 그대로 보여줘요.\n- 반면, 서버 컴포넌트에서 온 에러는 예민한 정보를 노출하지 않기 위해 일반적인 메시지와 식별자(identifier)를 보여준답니다.  \n  이 식별자, 즉 `errors.digest` 값을 사용하면 서버 로그에서 해당 에러를 쉽게 찾아낼 수 있어요.\n\n#### error.digest\n\n이건 자동으로 생성된 에러 해시 값이에요.  \n서버 쪽 로그와 에러를 매칭할 때 아주 유용하죠.  \n즉, 사용자에게는 세세한 정보 대신 이 해시값만 보여주고, 개발자는 이 해시값을 통해 문제를 추적할 수 있는 거예요.\n\n---\n\n### 조금 더 알아볼까요?\n\n서버 컴포넌트에서 에러 메시지에 상세한 내용을 숨기는 이유는 보안 때문이에요.  \n만약 민감한 코드 구조나 데이터가 클라이언트에 노출되면 해커들이 공격에 악용할 수 있거든요.  \n그래서 '어떤 문제가 발생했는지'는 알려주되, '어떤 코드에서, 왜'에 관한 자세한 건 서버 쪽에만 기록해서 관리하는 거죠.\n\n이런 구조 덕분에 사용자 경험은 방해받지 않으면서, 개발자는 충분한 디버깅 정보를 확보할 수 있답니다.  \n\n혹시 서버 로그에서 에러를 찾으려면 `error.digest` 값을 복사해서 검색해보세요!  \n이게 생각보다 꽤 쏙쏙 잘 맞아 떨어진답니다. 🙂\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n#### 리셋 (reset)\n\n가끔 에러가 일시적인 경우가 있어요. 이런 경우에는 다시 시도하면 문제를 해결할 수 있죠.\n\n에러 컴포넌트에서는 `reset()` 함수를 사용해서 사용자에게 에러에서 복구할 기회를 줄 수 있어요. 이 함수가 호출되면, 에러 경계(error boundary)에 감싸져 있는 컴포넌트를 다시 렌더링하려고 시도합니다. 만약 다시 렌더링에 성공하면 기존의 에러 화면(fallback)이 정상 화면으로 바뀌게 되죠.\n\n사용법은 아주 간단해요. 예를 들어:\n\n```js\n'use client' // 에러 경계는 반드시 클라이언트 컴포넌트여야 합니다\n\nexport default function Error({\n  error,\n  reset,\n}: {\n  error: Error \u0026 { digest?: string }\n  reset: () =\u003e void\n}) {\n  return (\n    \u003cdiv\u003e\n      \u003ch2\u003e문제가 발생했습니다!\u003c/h2\u003e\n      \u003cbutton onClick={() =\u003e reset()}\u003e다시 시도하기\u003c/button\u003e\n    \u003c/div\u003e\n  )\n}\n```\n\n위 예제에서 `reset()` 함수가 버튼 클릭 시 호출되고, 이로 인해 오류 상태가 초기화되어 정상 화면을 다시 시도하게 되는 거죠.\n\n---\n\n**추가 팁!**\n\n- `reset()`은 React의 에러 경계 기능과 연동되어 동작하기 때문에, Next.js 13의 `app` 디렉토리 기반에서 클라이언트 컴포넌트로 작성해야 합니다.\n- `reset()`을 사용할 땐 오류 발생 시 사용자에게 친절하게 안내하는 UI를 보여주는 게 좋아요. 예를 들어, 에러 내용과 함께 재시도 버튼을 제공하면 사용자 경험이 훨씬 좋아집니다.\n- 일시적인 네트워크 문제나 API 호출 실패 같은 상황에서 특히 유용하니, 네트워크 상태 변화 이벤트와도 같이 활용하면 효과적이에요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 예시\n\n### 전역 에러 처리(Global Error)\n\n전역 에러 처리는 조금 덜 흔하지만, 루트 앱 디렉토리에 `global-error.js` 파일을 만들어서 루트 레이아웃(root layout)이나 템플릿(root template)에서 발생하는 에러를 잡을 수 있어요. 특히 다국어 지원(i18n)을 사용할 때도 문제없이 동작합니다. 여기서 중요한 점! 전역 에러 UI는 반드시 `html`과 `body` 태그를 직접 정의해야 해요. 이 파일이 활성화되면 해당 루트 레이아웃이나 템플릿을 대체하게 된답니다.\n\n```jsx\n'use client' // 에러 바운더리는 클라이언트 컴포넌트여야 해요\n\nexport default function GlobalError({\n  error,\n  reset,\n}: {\n  error: Error \u0026 { digest?: string }\n  reset: () =\u003e void\n}) {\n  return (\n    \u003chtml\u003e\n      \u003cbody\u003e\n        \u003ch2\u003e문제가 발생했어요!\u003c/h2\u003e\n        \u003cbutton onClick={() =\u003e reset()}\u003e다시 시도하기\u003c/button\u003e\n      \u003c/body\u003e\n    \u003c/html\u003e\n  )\n}\n```\n\n### 추가 팁!\n\n- `reset` 함수는 에러 상태를 초기화해서 컴포넌트를 리프레시하는 역할을 해요. 사용자 경험을 위해 꼭 넣어주세요.\n- 전역 에러 컴포넌트가 활성화되면 기존의 레이아웃이나 템플릿이 완전히 대체되니, 디자인 요소나 공통 레이아웃을 포함시키고 싶으면 직접 만들어야 한다는 점 기억하세요.\n- **에러 경계(Error Boundaries)**는 클라이언트에서만 동작하기 때문에 꼭 `'use client'`를 선언해야 하는 점도 꼭 체크!  \n\n이렇게 전역에서 에러를 처리하면 예상치 못한 문제가 발생해도 깔끔하게 사용자에게 안내할 수 있어서 앱 안정성에 큰 도움이 됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 버전 히스토리\n\n| 버전         | 변경 사항                         |\n|--------------|----------------------------------|\n| `v15.2.0`    | 개발 환경에서 `global-error`도 표시되도록 변경됨. |\n| `v13.1.0`    | `global-error` 기능 추가됨.             |\n| `v13.0.0`    | `error` 기능 추가됨.                    |\n\n---\n\n여기서 잠깐!  \n\n- `global-error`는 전역적으로 발생하는 에러를 한눈에 확인할 수 있게 해주는 기능이에요. 특히 개발할 때 어디서 문제가 생겼는지 빠르게 파악할 수 있어서 무척 유용하죠.\n- 버전 히스토리를 잘 확인해두면 새로 추가된 기능이나 변경된 점을 놓치지 않을 수 있으니 개발하면서 꼭 참고하시길 추천해요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":8},{"title":"Next.js 15 Parallel Routes default.js 활용법 정리","description":"","date":"2025-04-22 02:35","slug":"2025-04-22-defaultjs","content":"\n# default.js 파일에 대해 알아보자\n\n안녕하세요! 오늘은 Next.js에서 Parallel Routes를 사용할 때 나오는 `default.js` 파일에 대해 이야기해볼게요. Next.js를 쓰다 보면 우리가 원하는 화면(서브페이지)을 보여주다가도, 가끔 새로고침(하드 네비게이션)을 하면 그 상태를 잃어버리고 다시 렌더링해야 할 때가 있잖아요? 이 문제를 해결해주는 게 바로 `default.js` 파일이에요.\n\n---\n\n## default.js 파일, 왜 필요할까?\n\nNext.js는 **소프트 네비게이션**(페이지를 새로고침하지 않고 이동할 때)에서는 각 슬롯(slot)의 액티브 상태를 잘 기억하고 있답니다. 그래서 사용자가 어디에 있었는지 그대로 보여줄 수 있죠.\n\n그런데, 만약 **하드 네비게이션**(진짜 페이지를 새로 고침하거나 처음 방문하는 경우)이 발생하면 액티브 상태를 기억하지 못해요. 그래서 이때, 현재 URL과 맞지 않는 서브페이지가 있을 때 렌더링할 기본 화면을 제공해주기 위해 `default.js`가 필요하답니다.\n\n---\n\n## 예시 폴더 구조 살펴보기\n\n아래처럼 폴더 구조를 보면, `@team` 슬롯에는 `settings` 페이지가 있는 반면, `@analytics`는 없어요.\n\napp\n├── layout.js\n├── page.js\n├── @team\n│ ├── page.js\n│ └── settings\n│ └── page.js\n└── @analytics\n└── page.js\n\n위처럼 되어있다면, `@analytics` 슬롯에 `settings` 페이지 같은 게 없어 하드 네비게이션 시 상태 복구가 힘들기 때문에, 이때 `default.js`가 빈 슬롯 내용이나 기본 안내 메시지를 보여주는 역할을 하게 되는 거죠.\n\n---\n\n## 조금 더 알아두면 좋은 점!\n\n- `default.js`는 슬롯 내부의 서브페이지가 현재 URL과 맞지 않을 때 보여주는 **fallback UI**입니다.\n- 이를 활용하면 페이지가 완전히 새로고침되어도, 깨지지 않고 친절한 기본 메시지를 띄울 수 있죠.\n- 이 기능을 통해 탭이나 메뉴처럼 여러 슬롯을 가진 복잡한 UI를 만들 때 유저 경험이 훨씬 좋아져요.\n\n---\n\n궁금한 점 있으면 댓글로 남겨주세요! 다음에도 재미있고 유용한 Next.js 팁 가지고 올게요~ :)\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위 내용을 쉽게 풀어서 설명해드릴게요.\n\n---\n\nNext.js에서 /settings 경로로 이동하면, `@team` 슬롯에는 설정 페이지가 보여지고, `@analytics` 슬롯은 현재 활성화된 페이지를 계속 유지해요.\n\n**여기서 슬롯(@team, @analytics)이란?**  \n페이지를 여러 영역으로 나누고, 각 영역에 다른 컴포넌트를 꽂아 넣을 수 있는 공간 같은 개념이에요. 그래서 한 페이지 안에서도 독립적으로 여러 컴포넌트가 관리됩니다.\n\n---\n\n그런데, 새로고침을 하게 되면 Next.js는 `@analytics` 슬롯에 대해 `default.js` 파일을 찾으려고 해요. 만약 `default.js`가 없다면 404 (페이지 없음) 오류를 띄웁니다.\n\n또 하나 중요한 점!  \n`children` 슬롯은 암묵적으로 존재하는 기본 슬롯인데요, 이 `children` 슬롯도 `default.js` 파일을 만들어 줘야 해요. 그래야 Next.js가 부모 페이지의 활성 상태를 복구하지 못할 때 대체할 컴포넌트를 보여줄 수 있어요.\n\n---\n\n### 요약하자면\n\n| 상황                        | 해야할 일                           | 이유                                                              |\n| --------------------------- | ----------------------------------- | ----------------------------------------------------------------- |\n| /settings 접근 시           | @team 슬롯에 설정 페이지 렌더링     | 해당 슬롯에 지정한 컴포넌트만 바꾸고 다른 슬롯은 유지하기 위해    |\n| 새로고침할 때               | `@analytics/default.js` 만들어 두기 | 새로고침 시 기본으로 보여줄 컴포넌트가 필요, 없으면 404 오류 발생 |\n| 암묵적 기본 슬롯 `children` | `children/default.js`도 만들어 주기 | 부모 페이지 상태 복구 실패 시 대체 컴포넌트를 보여주기 위해       |\n\n---\n\n### 추가 팁!\n\n- 이렇게 슬롯별로 `default.js`를 준비해두면 사용자 경험이 한층 좋아져요. 새로고침 후에도 오류 대신 기본 페이지가 적절히 렌더링 되거든요.\n- 만약 `default.js`가 없으면, 사용자가 새로고침할 때 꽤 당황스러운 404를 보게 되니 꼭 챙겨주세요!\n\n---\n\n이 정도만 알고 있어도 Next.js의 복잡한 경로 관리와 슬롯 구조를 조금 더 편하게 다룰 수 있을 거예요. 다음에도 이런 실용적인 Next.js 팁 있으면 공유해 드릴게요! :)\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 참고 자료\n\n### params (선택 사항)\n\n`params`는 루트 경로부터 슬롯 내부의 하위 페이지까지의 동적 라우트 매개변수를 담고 있는 객체를 반환하는 **Promise**입니다. 쉽게 말해, 서버나 페이지가 렌더링될 때 URL 경로에서 변하는 부분들을 비동기적으로 받아오는데 사용돼요.\n\n예를 들어 아래 코드를 보면:\n\n```js\nexport default async function Default({ params }: { params: Promise\u003c{ artist: string }\u003e }) {\n  const { artist } = await params;\n}\n```\n\n`params`는 `{ artist: string }` 타입을 가진 Promise를 받는데, 여기서 `artist`는 URL 경로의 동적 부분입니다 (`/artist/:artist` 같은 라우트).\n\n---\n\n### 좀 더 쉽게 풀어볼까요?\n\n- 동적 라우팅(dynamic routing)은 URL 경로가 고정된 게 아니라, 변수처럼 변하는 부분을 말해요. 예를 들면, 프로필 페이지 URL이 `/profile/john`과 `/profile/jane`처럼 각각 다를 때, `john`이나 `jane`이 동적 매개변수가 되는 거죠.\n- Next.js 13의 App 디렉토리에서는 이런 동적 매개변수를 `params` Promise로 받아 사용할 수 있게 해줍니다.\n- 그리고 `params`는 Promise 타입이기 때문에, async/await을 써서 값을 받아와야 하는 점 꼭 기억하세요!\n\n---\n\n### 팁\n\n- 서버 컴포넌트는 기본적으로 async 함수로 만들 수 있으니, 동적으로 데이터를 불러와야 할 때는 이 `params`를 활용하면 아주 편리해요.\n- 만약 여러 개의 동적 파라미터가 있다면, `params` 객체에 여러 키가 포함돼서 옵니다. 예를 들어, `/artist/:artist/album/:albumId` 라우트의 경우 `{ artist: string; albumId: string }` 형태로 받겠죠.\n- 이 `params`를 잘 활용하면 클라이언트에서 URL을 참고해 요청을 전달하거나 데이터를 동적으로 렌더링하기 훨씬 수월해집니다.\n\n이렇게 `params` Promise를 통해 쉽고 똑똑하게 동적 라우팅 데이터를 다룰 수 있다는 점 기억해두세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음은 Next.js에서 동적 라우팅 시 `params`가 어떻게 전달되는지 예제를 통해 정리한 내용이에요.\n\n| Example                                    | URL          | `params`                                     |\n| ------------------------------------------ | ------------ | -------------------------------------------- |\n| `app/[artist]/@sidebar/default.js`         | `/zack`      | `Promise\u003c{ artist: 'zack' }\u003e`                |\n| `app/[artist]/[album]/@sidebar/default.js` | `/zack/next` | `Promise\u003c{ artist: 'zack', album: 'next' }\u003e` |\n\n여기서 중요한 점은, `params`가 Promise 형태라는 거죠. 그래서 `params` 값을 실제로 사용하기 위해서는 `async/await` 또는 React의 `use` 함수를 써야 해요. 예를 들어, 이렇게 쓸 수 있죠:\n\n```jsx\nconst params = await props.params; // 또는 React 18의 use 함수 사용\n```\n\n버전 14 이하에서는 `params`가 동기적으로 바로 사용 가능했는데, Next.js 15부터는 비동기로 변경되면서 사용법도 달라졌답니다. 다만, 지금 당장은 이전 방식도 호환을 위해 지원하긴 하지만 곧 deprecated될 예정이에요. 그러니까 코드를 새로 쓸 때는 이 부분 꼭 염두에 두는 게 좋아요.\n\n추가로, `params`가 Promise라는 점은 뭔가 데이터가 비동기적으로 준비된다는 걸 의미하기도 해요. 따라서 페이지의 서버사이드 렌더링이나 데이터 페칭 로직과 잘 맞물려서 설계해야 부드러운 UX를 만들 수 있습니다.\n\n이 부분 혼동되기 쉬운데, 꼼꼼히 체크해서 다음 프로젝트에 제대로 적용해보세요!\n","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":6},{"title":"Nextjs 15 Script 태그 사용 방법","description":"","date":"2025-04-22 02:33","slug":"2025-04-22-Script","content":"\n\n# Script 컴포넌트 사용법\n\n이번 글에서는 Next.js에서 제공하는 `Script` 컴포넌트에 대해 알아볼게요. `Script` 컴포넌트는 외부 스크립트를 페이지에 쉽게 로드하고, 로딩 시점이나 우선순위 등을 조절할 수 있어서 성능 최적화에 정말 유용합니다. 더 자세한 기능과 사용법은 Next.js 공식 문서의 [Optimizing Scripts 페이지](https://nextjs.org/docs/basic-features/script)를 참고해보세요.\n\n```js\nimport Script from 'next/script'\n \nexport default function Dashboard() {\n  return (\n    \u003c\u003e\n      \u003cScript src=\"https://example.com/script.js\" /\u003e\n    \u003c/\u003e\n  )\n}\n```\n\n위 예시는 가장 기본적인 사용법으로, 외부 스크립트 URL을 `src` 속성으로 전달해 페이지에 적용하는 모습입니다.\n\n---\n\n## Script 컴포넌트 주요 Props\n\n아래 표에선 Script 컴포넌트에서 자주 사용하는 props를 정리해봤어요. 각 속성은 스크립트 로딩 시점, 실행 방식 등을 제어하는 데 도움을 줍니다.\n\n| Prop        | 타입               | 설명                                                                                                 | 기본값      |\n|-------------|--------------------|----------------------------------------------------------------------------------------------------|-------------|\n| `src`       | `string`           | 로드할 외부 스크립트의 URL                                                                          | (필수)      |\n| `strategy`  | `'beforeInteractive'` \\| `'afterInteractive'` \\| `'lazyOnload'` | 스크립트 로딩 전략. `beforeInteractive`는 HTML 파싱 전에, `afterInteractive`는 페이지가 상호작용 가능해진 후, `lazyOnload`는 브라우저가 유휴 상태일 때 로드합니다. | `'afterInteractive'` |\n| `onLoad`    | `function`         | 스크립트가 정상적으로 로드됐을 때 호출되는 콜백                                                     | -           |\n| `onError`   | `function`         | 스크립트 로딩에 실패했을 때 호출되는 콜백                                                           | -           |\n| `id`        | `string`           | 스크립트 엘리먼트의 고유 식별자                                                                      | -           |\n| `dangerouslySetInnerHTML` | `{ __html: string }` | 스크립트 내부에 직접 코드를 삽입할 때 사용                                                           | -           |\n\n---\n\n### 전략(strategy)에 대해 조금 더 설명하자면\n\n- **beforeInteractive**  \n  페이지가 사용자와 상호작용하기 전에 스크립트를 미리 로드해야 할 때 사용합니다. 예를 들어, 핵심 기능을 담당하는 라이브러리라면 이 전략이 적합할 수 있어요.\n\n- **afterInteractive**  \n  메인 콘텐츠가 준비된 후에 스크립트를 로드합니다. 보통 기본값으로 사용되며, 사용자 경험에 큰 영향을 주지 않으면서 추가 스크립트를 로드하고 싶을 때 좋아요.\n\n- **lazyOnload**  \n  페이지가 완전히 로딩된 뒤, 브라우저가 한가할 때 스크립트를 로드하는 아주 느긋한 방법입니다. 성능 최적화에 매우 유용하지만, 즉시 필요한 스크립트에는 사용하지 않는 게 좋습니다.\n\n---\n\n### 직접 내부 코드를 넣고 싶을 때\n\n```js\n\u003cScript\n  id=\"show-banner\"\n  dangerouslySetInnerHTML={{\n    __html: `\n      alert('Welcome to our site!');\n    `,\n  }}\n/\u003e\n```\n\n이렇게 하면 별도로 스크립트 파일을 만들지 않고도 페이지에 간단한 자바스크립트 코드를 삽입할 수 있죠. 단, XSS 공격 방지를 위해 내용에 주의를 기울여야 합니다.\n\n---\n\n`Script` 컴포넌트는 외부 스크립트 로딩을 제어하면서도 Next.js의 서버 사이드 렌더링(SSR) 환경에 잘 맞게 설계됐다 보니, 꼭 알아두면 프로젝트 성능 관리에 큰 도움이 될 거예요. 다음에는 더 다양한 예제와 활용 방법도 공유할게요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nScript 컴포넌트에서 사용할 수 있는 props를 간단히 정리해봤어요.\n\n| Prop     | Example                        | Type     | Required                        |\n|----------|-------------------------------|----------|--------------------------------|\n| `src`    | `src=\"http://example.com/script\"` | String   | inline 스크립트를 사용하지 않는 한 필수입니다. |\n| `strategy` | `strategy=\"lazyOnload\"`         | String   | 선택사항입니다.                    |\n| `onLoad` | `onLoad={onLoadFunc}`           | Function | 선택사항입니다.                    |\n| `onReady`| `onReady={onReadyFunc}`         | Function | 선택사항입니다.                    |\n| `onError`| `onError={onErrorFunc}`         | Function | 선택사항입니다.                    |\n\n---\n\n### 필수로 꼭 필요한 Prop\n\n`Script` 컴포넌트를 사용할 때 기본적으로 꼭 지정해줘야 하는 prop은 `src`입니다. 물론 인라인 스크립트를 사용하는 경우라면 `src` 없이도 가능해요. \n\n- `src`는 외부에서 불러올 스크립트 파일의 URL을 지정하는 곳이에요.  \n- `strategy`는 스크립트 로딩 시점을 제어하는 옵션인데, 성능 최적화를 원할 땐 `lazyOnload` 같은 값을 주면 페이지 로딩 후에 느긋하게 불러옵니다.  \n- `onLoad`, `onReady`, `onError` 같은 콜백 함수들은 스크립트 로딩 상태를 감지해서 필요한 작업을 연결할 때 유용합니다. 예를 들어 서드파티 스크립트 로딩이 끝난 후에 어떤 함수를 실행하고 싶을 때 써보세요.\n\n간단하지만 스크립트 로딩 관리에서 꽤 유용하게 쓰일 수 있으니, 적절히 활용해보면 좋아요! 궁금한 점 있으면 또 알려줄게요 :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### src\n\n`src`는 외부 스크립트의 URL 경로를 지정하는 문자열이에요. 이 경로는 절대 URL(예: https://example.com/script.js)일 수도 있고, 내부 경로나 상대 경로일 수도 있죠. 중요한 점은, 인라인(inline) 스크립트를 사용하지 않는 한 `src` 속성은 반드시 지정해줘야 한다는 거예요.\n\n내가 한 가지 더 알려주자면, 외부 스크립트를 사용할 때는 CORS 정책이나 네트워크 지연 문제도 고려해야 해요. 만약 스크립트 로딩이 지연되면 페이지 렌더링에도 영향을 줄 수 있으니까, `async`나 `defer` 같은 속성을 잘 활용해서 비동기 로딩을 하는 것도 추천합니다.\n\n## Optional Props\n\n`Script /` 컴포넌트는 필수 속성 외에도 사용자가 편리하게 쓸 수 있도록 여러 추가 속성을 지원해요. 이 옵션들을 잘 활용하면 스크립트 로딩이나 실행 타이밍을 세밀하게 조절할 수 있어서 더욱 효율적이죠.\n\n아래는 주요 옵션들입니다:\n\n| 속성 이름           | 설명                                                   |\n|-------------------|------------------------------------------------------|\n| `async`           | 스크립트를 비동기로 로드합니다. 페이지 렌더링을 차단하지 않아요.          |\n| `defer`           | DOM 파싱이 끝난 후 스크립트를 실행합니다.                       |\n| `onLoad`          | 스크립트가 로드된 후 호출되는 콜백 함수입니다.                      |\n| `onError`         | 로딩 에러가 발생했을 때 호출되는 콜백 함수입니다.                   |\n| `strategy`        | 스크립트 로딩 전략을 지정합니다. (예: `beforeInteractive`, `afterInteractive`, `lazyOnload`) |\n\n여기서 `strategy` 속성은 Next.js 같은 프레임워크에서 제공하는 스크립트 최적화 옵션인데, 상황에 맞게 잘 선택하면 페이지 속도 최적화에 큰 도움이 됩니다.\n\n필요하면 각각의 옵션에 대해서 더 자세히 알아보고, 상황에 맞게 조합해보세요. 스크립트 로딩이 잘 되어야 사용자 경험도 쾌적해진답니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### strategy (스크립트 로딩 전략)\n\n스크립트를 언제 어떻게 로딩할지 정하는 방법이에요. 총 4가지 방법이 있는데, 각각의 특징이 조금씩 달라요.\n\n| 전략명             | 설명                                           |\n|-----------------|----------------------------------------------|\n| beforeInteractive | Next.js 코드 실행 전에, 그리고 페이지가 활성화되기 전에 미리 로딩해요. |\n| afterInteractive  | (기본값) 페이지가 어느 정도 활성화된 후에 로딩하지만, 그래도 빠른 편이에요. |\n| lazyOnload        | 브라우저가 한가할 때, 나중에 천천히 로딩해요. |\n| worker            | (실험적) 웹 워커 안에서 로딩해요. 메인 스레드 부담을 줄여줍니다. |\n\n---\n\n### beforeInteractive\n\n`beforeInteractive` 전략은 말 그대로 페이지가 완전히 활성화되기 전에, Next.js의 어떤 코드보다도 먼저 스크립트를 로딩해요. 이걸 쓰는 이유는 페이지가 초기화되기 전에 꼭 필요한 스크립트가 있을 때인데요.\n\n예를 들어, 페이지가 렌더링되는 순간 바로 동작해야 할 자바스크립트가 있거나, 어떤 중요 라이브러리(예: 전역 상태관리 라이브러리)가 빨리 준비돼야 할 경우에 좋습니다.\n\n하지만 무조건 빨리 로딩한다고 좋은 건 아니에요! 이 전략을 남용하면 페이지 초기 로딩 속도가 느려질 수 있으니 꼭 필요한 경우에만 사용하는 게 좋아요.\n\n---\n\n#### Tip!\n\n- `afterInteractive`가 기본값이라, 특별한 이유가 없다면 이걸 쓰는 게 무난합니다.\n- 만약 무거운 스크립트라면 `lazyOnload` 전략을 사용해서 사용자가 페이지를 충분히 볼 수 있을 때 로딩하는 게 좋습니다.\n- 웹 워커(`worker` 전략)는 아직 실험 단계지만, 스크립트가 백그라운드에서 처리되어 메인 UI 렌더링 성능이 좋아질 수 있으니 관심 있으면 조금씩 써보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 `beforeInteractive` 로드 전략을 사용하는 스크립트에 대해 이야기해볼게요.\n\n### beforeInteractive 로드 전략이란?\n\n`beforeInteractive` 전략을 사용하면, 해당 스크립트가 서버에서 초기 HTML에 바로 주입돼요. 그러니까 브라우저가 Next.js의 어떤 모듈도 다운받기 전에, 이 스크립트부터 먼저 다운로드하고 실행하게 됩니다. 이게 무슨 의미일까요? 중요한 스크립트를 아주 빨리 불러오고 싶을 때 쓸 수 있다는 거죠.\n\n하지만 여기서 중요한 점! 실행은 페이지 수화(page hydration)를 막지 않아요. 즉, 이 스크립트를 실행한다고 해서 React가 클라이언트에서 페이지를 활성화하는 과정을 지연시키지 않습니다.\n\n### 어디에 위치해야 할까?\n\n`beforeInteractive` 스크립트는 루트 레이아웃(`app/layout.tsx`) 안에 넣어야 합니다. 왜냐하면, 이 전략은 애플리케이션 어떤 페이지가 로드되더라도 반드시 필요한 공통 스크립트(예: 폰트 로더, 전역 추적 코드 등)를 로드하게 설계되어 있기 때문입니다.\n\n### 사용하면 좋은 경우\n\n이 전략은 진짜 필수적인 스크립트에만 쓰는 게 좋아요. 예를 들어,\n\n- 전체 사이트에 적용되는 폰트 로딩 스크립트\n- 필수적인 애널리틱스 코드\n- 크리티컬 CSS나 자바스크립트 초기화 스크립트\n\n이런 것들이에요. 너무 많아지면 페이지 로딩 초기 비용이 커질 수 있으니 주의!\n\n---\n\n### 간단 정리 (Markdown 표)\n\n| 특징                      | 설명                                                        |\n|-------------------------|-----------------------------------------------------------|\n| 주입 위치                  | 서버에서 초기 HTML에 직접 삽입                             |\n| 다운로드 시점              | Next.js 모듈보다 먼저 다운로드                             |\n| 실행 순서                  | 삽입된 순서대로 실행                                        |\n| 페이지 수화 차단 여부       | 실행해도 페이지 수화 과정(block)에는 영향 없음               |\n| 배치 위치                  | `app/layout.tsx` (루트 레이아웃)                           |\n| 주 용도                   | 전체 사이트에 필요한 필수 스크립트 즉시 로드                  |\n\n---\n\n### 덧붙여서\n\n실제로 프로젝트에서 이걸 설정하려면, `\u003cScript\u003e` 컴포넌트를 이렇게 쓰면 됩니다.\n\n```tsx\nimport Script from 'next/script';\n\nexport default function RootLayout({ children }) {\n  return (\n    \u003chtml\u003e\n      \u003chead\u003e\n        \u003cScript src=\"/critical-script.js\" strategy=\"beforeInteractive\" /\u003e\n      \u003c/head\u003e\n      \u003cbody\u003e{children}\u003c/body\u003e\n    \u003c/html\u003e\n  );\n}\n```\n\n이렇게 하면 `/critical-script.js`가 Next.js 모듈보다 먼저 다운로드되고 실행돼서, 사이트 구동에 꼭 필요한 스크립트를 미리 준비할 수 있어요.\n\n---\n\n요약하자면, `beforeInteractive`는 **“진짜 꼭 필요한 아주 중요한 스크립트를 최대한 빨리, 페이지 수화 지연 없이 불러올 때”** 사용하는 로드 전략입니다.\n\n필요에 따라 맞춤형으로 활용해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 `\u003cScript\u003e` 컴포넌트를 사용할 때 `strategy=\"beforeInteractive\"` 옵션을 자주 보게 되는데요, 이 옵션이 어떤 역할을 하는지 간단히 알려드릴게요!\n\n위 코드를 보면, `\u003cScript\u003e` 태그가 `\u003cbody\u003e` 안에 있지만 사실상 `beforeInteractive`로 설정된 스크립트는 항상 HTML 문서의 `\u003chead\u003e` 안에 주입됩니다. 즉, 컴포넌트 내부 어디에 두든지 페이지가 렌더링 되기 전에 스크립트가 로드된다는 뜻이에요.\n\n왜 이게 중요하냐면, 페이지가 사용자와 상호작용하기 전에 꼭 필요한 스크립트들이 미리 로드되어 있어야 하기 때문입니다. 예를 들어:\n\n| 예시 스크립트 종류        | 설명                                       |\n|------------------------|------------------------------------------|\n| 봇 탐지(bot detectors)    | 크롤러나 봇을 빠르게 식별하려면 초기 단계에서 실행 필요  |\n| 쿠키 동의 관리(cookie consent managers) | 개인정보 동의 팝업이나 관리 스크립트는 인터랙션 전에 준비되어야 함 |\n\n이런 스크립트들은 사용자의 상호작용이 일어나기 전부터 로드되어서 빠르게 동작해야 하므로 `beforeInteractive` 전략을 써서 우선순위를 높여주는 게 좋은 방법입니다.\n\n### 추가로 알아두면 좋은 점!\n\n- `beforeInteractive` 외에도 `lazyOnload`, `afterInteractive` 같은 전략이 있는데, 각각 로드 시점과 우선순위가 다르니 상황에 맞게 선택해야 합니다.\n- 그리고 Next.js는 스크립트 최적화에 신경을 많이 썼기 때문에, 직접 `\u003cscript\u003e` 태그를 쓰기보다는 `\u003cScript\u003e` 컴포넌트를 활용하는 걸 추천해요. 그래야 스크립트 로딩 타이밍과 위치를 자동으로 제어해줘서 성능과 SEO에 도움됩니다.\n\n간단하게 정리하자면, 꼭 페이지가 사용자와 상호작용하기 전에 필요한 스크립트가 있다면 **`strategy=\"beforeInteractive\"`** 로 설정해주면 좋다!고 이해하시면 됩니다.\n\n필요한 경우 저도 자주 쓰는 옵션이라, 다음에 스크립트 로딩 전략에 대해 더 자세히 공유해볼게요. :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### afterInteractive 전략이란?\n\nNext.js에서 `Script` 컴포넌트를 사용할 때 `strategy=\"afterInteractive\"` 옵션을 자주 보게 되실 텐데요. 이건 스크립트를 클라이언트 쪽에 삽입하고, 페이지가 **렌더링된 후에** 실행하도록 하는 방식이에요. 쉽게 말해, Next.js가 페이지를 초기화하고, 클라이언트에서 인터랙티브 상태가 된 다음에 스크립트를 로딩하는 거죠.\n\n보통 이 전략은 기본값이기도 하고, **첫 번째로 실행해야 하는 Next.js 내부 코드가 끝난 다음 바로 실행돼야 하는 스크립트**에 사용돼요. 예를 들어, 외부 광고 스크립트나 사용자 행동 추적 스크립트 같은 게 이에 해당됩니다.\n\n#### 특징\n- 원하는 페이지나 레이아웃 어디에든 넣을 수 있어요.\n- 해당 페이지가 클라이언트에서 접근될 때만 로드되고 실행됩니다.\n- 페이지 로딩 속도를 어느 정도 지키면서 외부 스크립트를 넣고 싶을 때 적합합니다.\n\n아래는 실제 사용 예제인데, `strategy=\"afterInteractive\"`를 명시하지 않아도 기본값이라서 생략 가능해요.\n\n```jsx\nimport Script from 'next/script'\n\nexport default function Page() {\n  return (\n    \u003c\u003e\n      \u003cScript src=\"https://example.com/script.js\" strategy=\"afterInteractive\" /\u003e\n    \u003c/\u003e\n  )\n}\n```\n\n---\n\n#### 추가로 알아두면 좋은 점!\n\n- `afterInteractive` 말고도 Next.js는 `beforeInteractive`, `lazyOnload` 같은 다양한 로딩 전략이 있어요. 각각 특성이 달라서 상황에 맞게 골라서 사용하면 됩니다.\n- 만약 **빠른 우선 실행**이 필요한 스크립트면 `beforeInteractive`를, **페이지가 완전히 로드된 후** 실행하면 충분한 스크립트는 `lazyOnload`를 쓰는 식이죠.\n- 이 전략을 잘 활용하면, 사용자 경험을 해치지 않으면서도 사이트에 꼭 필요한 외부 스크립트들을 최적화할 수 있습니다.\n\nNext.js에서 스크립트 로딩 전략을 이해하고 사용하면 성능과 UX 모두 챙길 수 있으니, 꼭 한 번 실습해 보시길 추천드려요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nafterInteractive에 적합한 스크립트 예시로는 다음과 같은 것들이 있어요!\n\n- 태그 매니저 (Tag managers)\n- 애널리틱스 (Analytics)\n\n---\n\n### lazyOnload\n\nlazyOnload 전략을 사용하는 스크립트는 브라우저가 한가한 시간(Idle time)에 클라이언트 쪽 HTML에 주입돼요. 페이지의 모든 리소스가 다 로드된 후에 실행되기 때문에, 초반에 빠르게 로드할 필요가 없는 백그라운드 작업이나 우선 순위가 낮은 스크립트에 딱 맞아요.\n\n즉, 예를 들어 사용자 경험에 큰 영향을 미치지 않는 광고 트래킹 코드나 추가적인 위젯 스크립트 등은 lazyOnload로 관리하면 초기 페이지 로딩 속도를 잡아주는 데 도움이 된답니다.\n\n---\n\n이렇게 스크립트의 로딩 전략을 상황에 맞게 골라주면 페이지 퍼포먼스 최적화에 큰 도움이 되니 꼭 참고해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nnext.js에서 제공하는 `\u003cScript\u003e` 컴포넌트의 `lazyOnload` 전략에 대해 이야기해볼게요.\n\n이 `lazyOnload` 옵션은 스크립트를 페이지나 레이아웃 어디에든 넣을 수 있는데, 실제로 그 페이지(또는 해당 그룹의 페이지)가 브라우저에서 열릴 때 스크립트가 로드되고 실행돼요. 즉, 페이지가 처음 렌더링될 때 바로 로드할 필요가 없는 스크립트를 뒤로 미루는 셈이죠.\n\n```jsx\nimport Script from 'next/script'\n\nexport default function Page() {\n  return (\n    \u003c\u003e\n      \u003cScript src=\"https://example.com/script.js\" strategy=\"lazyOnload\" /\u003e\n    \u003c/\u003e\n  )\n}\n```\n\n예를 들어, 아래와 같은 경우 `lazyOnload`로 스크립트를 불러오면 좋아요:\n\n- 채팅 지원 플러그인 (Chat support plugins)\n- SNS 위젯 (Social media widgets)\n\n왜냐하면 이런 스크립트들은 페이지가 뜨자마자 바로 작동할 필요는 없고, 사용자 경험에 큰 영향을 주지 않으면서도 필요할 때 로딩되면 충분하기 때문이에요.\n\n---\n\n**추가 팁!**\n\n`lazyOnload`는 기본 `afterInteractive` 전략보다도 늦게 실행되기 때문에 초기 페이지 렌더링에 거의 영향을 주지 않아요. 하지만 꼭 필요한 스크립트여서 사용자 즉각 반응에 영향을 미친다면, 오히려 `afterInteractive`를 사용하는 것이 좋답니다.\n\n그리고 혹시 페이지가 복잡해서 스크립트가 많아지면, 지연 로드 전략을 잘 활용하는 게 사용자 퍼포먼스 측면에서 완전 도움이 되니 꼭 기억해둬요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### worker 전략 사용하기\n\n\u003e 경고: worker 전략은 아직 안정화 단계가 아니며 App Router와는 아직 호환되지 않습니다. 사용 시 주의가 필요해요.\n\nworker 전략은 스크립트를 웹 워커(Web Worker)로 분리해서 메인 스레드가 여유로워지도록 도와줍니다. 이렇게 하면 주요한 첫 번째 파티 리소스들만 메인 스레드에서 처리되고, 나머지 스크립트는 워커에서 실행되기 때문에 성능에 긍정적인 영향을 줄 수 있죠.\n\n하지만 이 전략은 아직 조금 고급 사용법에 속하고, 모든 타사 스크립트를 지원하지 않을 수 있다는 걸 기억하세요. 적절한 테스트가 필요해요.\n\n만약 worker 전략을 사용하고 싶다면, next.config.js 파일 안에 `nextScriptWorkers` 플래그를 활성화해야 합니다:\n\n```js\n// next.config.js\nmodule.exports = {\n  experimental: {\n    nextScriptWorkers: true,\n  },\n};\n```\n\n이렇게 설정하면 스크립트가 워커 쪽에서 실행될 수 있도록 준비됩니다.\n\n---\n\n참고로, 웹 워커를 사용하면 복잡한 연산이나 무거운 스크립트가 메인 스레드를 막는 현상을 줄여줄 수 있어서 사용자 경험(UX) 향상에 큰 도움이 돼요. 하지만 모든 코드가 워커 환경에 맞는 것은 아니고, DOM에 직접 접근하는 코드는 워커에서 불가능하니 워커로 옮길 때는 이 점도 신경 써야 해요.\n\n추가적으로, 워커를 제대로 활용하면 페이지 응답 속도 개선은 물론이고, UI가 멈추는 현상(jank)도 크게 줄일 수 있어서 성능 최적화에 관심 있다면 충분히 고려해볼 만한 전략입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번에는 Next.js에서 제공하는 `nextScriptWorkers` 실험 기능과 `worker` 전략을 사용하는 방법에 대해 알아볼게요. 이 기능을 활용하면 스크립트를 워커(worker)로 실행해서 메인 스레드의 부담을 줄일 수 있어요. 하지만 아직은 실험 단계라서, 사용법에 몇 가지 제약이 있답니다.\n\n---\n\n### 1. 설정 방법\n\n먼저 `next.config.js`에 다음과 같이 설정을 추가해 주세요.\n\n```js\nmodule.exports = {\n  experimental: {\n    nextScriptWorkers: true,\n  },\n}\n```\n\n이렇게 하면 Next.js가 스크립트를 웹 워커로 실행하는 걸 지원하게 됩니다.\n\n---\n\n### 2. 스크립트 사용 위치 제한\n\n**중요!** 워커 스크립트는 현재 페이지 컴포넌트가 위치한 `pages/` 디렉터리 안에서만 사용할 수 있어요. 그래서 `App`이나 `Document`같은 전역 컴포넌트에서는 워커 전략을 사용할 수 없습니다.\n\n---\n\n### 3. 사용 예시\n\n`pages/index.js` 같은 페이지에서 아래처럼 `next/script`의 `Script` 컴포넌트를 쓰면서 `strategy=\"worker\"`를 넣으면 스크립트가 워커로 로드돼요.\n\n```jsx\nimport Script from 'next/script'\n\nexport default function Home() {\n  return (\n    \u003c\u003e\n      \u003cScript src=\"https://example.com/script.js\" strategy=\"worker\" /\u003e\n    \u003c/\u003e\n  )\n}\n```\n\n---\n\n### 4. onLoad 이벤트\n\n`Script` 컴포넌트는 `onLoad` 프로퍼티를 지원해서 스크립트가 성공적으로 로드됐을 때 콜백을 실행할 수 있어요.\n\n```jsx\n\u003cScript\n  src=\"https://example.com/script.js\"\n  strategy=\"worker\"\n  onLoad={() =\u003e {\n    console.log('Worker script loaded!');\n  }}\n/\u003e\n```\n\n워커 안에서 실행되는 스크립트는 메인 스레드와는 별개라 직접적인 DOM조작이나 전역 변수 사용이 제한돼요. 그러니까 워커 쪽 스크립트는 주로 데이터 처리나 계산 같은 무거운 작업에 활용하는 게 좋아요.\n\n---\n\n### 5. 추가 팁\n\n- 워커 스크립트에서 메인 스레드와 통신할 때는 `postMessage` API를 사용하셔야 해요.\n- 아직 실험 기능이라서 Next.js 공식 문서나 GitHub 이슈 페이지에서 최신 상태를 참고하는 게 좋아요.\n- 자주 변경될 수 있으니 프로덕션 환경에서는 신중히 사용하세요!\n\n---\n\n웹 워커를 활용하면 UI가 막히지 않고 부드럽게 동작하게 만들어주는 훌륭한 방법입니다. Next.js에서 실험적으로 지원하는 이 기능을 한번 사용해보고 퍼포먼스 향상에 도움이 되는지 직접 체험해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여러분, Next.js에서 `\u003cScript\u003e` 컴포넌트를 쓸 때 알아둬야 할 중요한 점이 있어요.\n\n\u003e **경고!** `onLoad` 이벤트 핸들러는 아직 서버 컴포넌트(Server Components)에서는 작동하지 않고 클라이언트 컴포넌트(Client Components)에서만 쓸 수 있어요. 또, `beforeInteractive` 로딩 전략과는 함께 못 쓰니까 `onReady`를 대신 사용하는 게 좋아요.\n\n왜 이런 얘기를 하냐면, 가끔 우리가 외부 서드파티 스크립트를 로드할 때 스크립트가 다 로딩된 후에 특정 함수를 실행해야 할 때가 있잖아요. 그런 경우에 `afterInteractive` 나 `lazyOnload` 같은 로딩 전략으로 스크립트를 불러온 다음, `onLoad` 프로퍼티를 활용하면 원하는 작업을 안전하게 실행할 수 있답니다.\n\n간단한 예를 들어볼게요. lodash라는 유명한 유틸 라이브러리를 외부 CDN에서 불러오고, 로딩이 완료되면 lodash의 `sample` 메서드를 써서 배열에서 랜덤 값을 뽑아 콘솔에 찍는 코드예요.\n\n```jsx\n'use client'\n\nimport Script from 'next/script'\n\nexport default function Page() {\n  return (\n    \u003c\u003e\n      \u003cScript\n        src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.20/lodash.min.js\"\n        onLoad={() =\u003e {\n          console.log(_.sample([1, 2, 3, 4]))\n        }}\n        strategy=\"afterInteractive\" // 로딩 시점 지정도 잊지 말기\n      /\u003e\n    \u003c/\u003e\n  )\n}\n```\n\n### 여기서 중요 포인트 정리!\n\n| 내용                             | 설명                                            |\n|--------------------------------|-------------------------------------------------|\n| `onLoad`                      | 스크립트가 완전히 로드된 후 실행되는 함수        |\n| 사용 가능 위치                 | 클라이언트 컴포넌트 내에서만 사용 가능           |\n| 로딩 전략                      | `beforeInteractive`와 함께 사용 불가, 대신 `afterInteractive` 추천 |\n| 대안                         | `beforeInteractive` 쓸 때는 `onReady` 속성 사용 |\n\n이 방식을 이용하면 외부 스크립트가 준비된 이후에 바로 원하는 JS 코드를 실행할 수 있어서 효과적이에요.\n\n---\n\n만약 Next.js에서 서버 사이드 렌더링(SSR) 모드로 작업 중이라면, 클라이언트 컴포넌트에 `'use client'`를 꼭 붙여줘야 `onLoad` 같은 클라이언트 전용 기능이 작동한다는 점도 꼭 기억하세요!\n\n필요하다면 스크립트의 로딩 시점을 바꾸는 `strategy` 속성을 다양하게 조합해서 페이지 성능 최적화에 신경쓰면 더 좋겠죠? `afterInteractive`는 페이지가 인터랙티브한 상태가 된 후, `lazyOnload`는 브라우저가 한가해질 때 로드하는 등 상황에 맞춰 선택할 수 있어요.\n\n이렇게 외부 스크립트와 우리 코드가 잘 협업하는 방법, 다음 프로젝트 때 유용하게 활용해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### onReady\n\n\u003e 경고: onReady는 아직 Server Components에서는 작동하지 않고, Client Components에서만 사용할 수 있어요.\n\n어떤 서드파티 스크립트들은 스크립트가 완전히 로드된 후, 그리고 컴포넌트가 마운트될 때마다 자바스크립트 코드를 실행해야 할 때가 있어요. 예를 들면, 페이지 경로가 바뀌어서 컴포넌트가 다시 렌더링될 때마다 말이죠.\n\n이럴 때 `onReady` 속성을 활용하면, 스크립트가 처음 로드될 때뿐 아니라 매번 컴포넌트가 다시 마운트될 때마다 코드를 실행할 수 있어요.\n\n예를 들어, 구글 맵을 컴포넌트가 마운트될 때마다 다시 불러와야 할 때 아래처럼 쓸 수 있답니다. \n\n```jsx\n\u003cScript\n  src=\"https://maps.googleapis.com/maps/api/js?key=YOUR_API_KEY\"\n  onReady={() =\u003e {\n    // 컴포넌트가 마운트될 때마다 구글 맵 재초기화\n    const map = new window.google.maps.Map(document.getElementById(\"map\"), {\n      center: { lat: -34.397, lng: 150.644 },\n      zoom: 8,\n    });\n  }}\n/\u003e\n```\n\n\u003e 팁!  \n\u003e onReady는 스크립트가 완전히 로드된 시점과 컴포넌트가 재마운트되는 시점을 포괄해서 처리하기 때문에, 복잡한 외부 라이브러리 초기화 작업에 특히 유용해요.  \n\u003e 다만, Server Components에서는 아직 지원하지 않으니, 클라이언트 전용 컴포넌트에서만 사용해야 한다는 거 꼭 기억하세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여러분, 리액트와 Next.js에서 구글 맵스(google maps) API를 불러오고 싶을 때 어떻게 하는지 아시나요? 위에 간단한 예제가 있는데요, `next/script` 컴포넌트를 이용해서 외부 스크립트를 쉽게 불러올 수 있습니다.\n\n```jsx\n'use client'\n \nimport { useRef } from 'react'\nimport Script from 'next/script'\n \nexport default function Page() {\n  const mapRef = useRef()\n \n  return (\n    \u003c\u003e\n      \u003cdiv ref={mapRef}\u003e\u003c/div\u003e\n      \u003cScript\n        id=\"google-maps\"\n        src=\"https://maps.googleapis.com/maps/api/js\"\n        onReady={() =\u003e {\n          new google.maps.Map(mapRef.current, {\n            center: { lat: -34.397, lng: 150.644 },\n            zoom: 8,\n          })\n        }}\n      /\u003e\n    \u003c/\u003e\n  )\n}\n```\n\n여기서 `mapRef`로 div 요소를 잡아두고, 구글 맵이 스크립트가 로드된 후에 `new google.maps.Map`을 실행해서 지도를 띄우는 식입니다. 중요한 점은 `'use client'`를 꼭 붙여서 이 컴포넌트가 클라이언트 사이드에서만 동작하도록 만들어야 한다는 거예요. 구글 맵 API는 브라우저 환경에서 동작하기 때문에 서버 사이드에선 의미가 없거든요.\n\n---\n\n### onError 옵션으로 에러 잡기\n\n그리고 `next/script`에는 `onReady` 뿐만 아니라 `onError`라는 옵션도 있어요. 스크립트가 정상적으로 로드되지 않았을 때 에러를 잡아서 대처하기 편리하죠.\n\n예를 들어,\n\n```jsx\n\u003cScript\n  id=\"google-maps\"\n  src=\"https://maps.googleapis.com/maps/api/js\"\n  onReady={() =\u003e {\n    // 정상 로드 시 초기화 코드\n  }}\n  onError={(e) =\u003e {\n    console.error('구글 맵 스크립트 로드 실패!', e)\n  }}\n/\u003e\n```\n\n하지만 한 가지 주의할 점! `onError`는 아직 서버 컴포넌트에서는 동작하지 않고, `beforeInteractive` 같은 특정 로딩 전략과도 호환되지 않아요. 따라서 클라이언트 컴포넌트에서만 잘 활용할 수 있다는 점을 기억하세요.\n\n---\n\n### 추가 팁: 구글 맵 API 키\n\n실제 프로젝트에서는 구글 맵 API를 불러올 때 API 키를 함께 줘야 제대로 작동해요. URL에 `key=YOUR_API_KEY` 파라미터를 넣어줘야 합니다.\n\n```jsx\nsrc=\"https://maps.googleapis.com/maps/api/js?key=YOUR_API_KEY\"\n```\n\nAPI 키 없이 그냥 불러오면 제한되거나 작동하지 않을 수 있으니 꼭 발급받고 넣어주세요. 혹시 모르시는 분들을 위해 구글 클라우드 플랫폼에서 API 키 발급받는 법도 다음에 따로 다뤄볼게요!\n\n---\n\n요약하자면:\n\n| 개념           | 설명                                                        |\n| -------------- | ----------------------------------------------------------- |\n| next/script    | Next.js에서 외부 스크립트를 쉽고 안전하게 불러올 수 있는 컴포넌트 |\n| onReady        | 스크립트 로드 완료 후 실행할 콜백 함수                        |\n| onError        | 스크립트 로드 실패 시 에러 처리 가능 (클라이언트 컴포넌트 전용) |\n| useRef         | 리액트에서 DOM 요소를 직접 참조하기 위한 훅                       |\n| API 키         | 구글 맵 API 사용 시 필수, URL 파라미터로 넣어야 제대로 동작        |\n\n이 정도면 구글 맵 API를 Next.js에서 어떻게 붙이는지 쉽게 감이 오지 않나요? 앞으로 다양한 외부 스크립트와 API도 이렇게 표현할 수 있으니 자주 써보면서 익혀보세요! 궁금한 점 있으면 댓글로 남겨주세요 :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안녕하세요! 이번에는 Next.js에서 제공하는 `\u003cScript\u003e` 컴포넌트를 사용하는 방법에 대해서 살펴볼게요. \n\n---\n\n### Next.js의 `\u003cScript\u003e` 컴포넌트\n\nNext.js에서 외부 스크립트를 쉽게 불러오고 관리할 수 있게 도와주는 컴포넌트가 바로 `next/script`의 `\u003cScript\u003e`입니다. 기본적으로 HTML의 `\u003cscript\u003e` 태그를 대체하면서, 스크립트 로딩 전략을 제어하거나 로딩 실패 시 에러 처리도 할 수 있는 편리한 기능들을 가지고 있죠.\n\n```jsx\n'use client'\n\nimport Script from 'next/script'\n\nexport default function Page() {\n  return (\n    \u003c\u003e\n      \u003cScript\n        src=\"https://example.com/script.js\"\n        onError={(e: Error) =\u003e {\n          console.error('Script failed to load', e)\n        }}\n      /\u003e\n    \u003c/\u003e\n  )\n}\n```\n\n위 코드를 보면, `src` 속성에 외부 스크립트 URL을 넣고, `onError` prop을 통해 로드 실패 시 콘솔에 에러를 출력하도록 구현했습니다. \n\n\u003e 💡 참고: `'use client'`는 이 컴포넌트가 클라이언트 컴포넌트라는 걸 알려줘서, 브라우저에서만 스크립트가 실행되도록 해줍니다.\n\n---\n\n## `next/script` 버전별 변경사항 히스토리\n\n`\u003cScript\u003e` 컴포넌트도 Next.js 버전 업데이트에 따라 점점 기능이 좋아지고 안정적으로 변해왔는데요, 주요 버전 변경사항을 한눈에 정리해봤어요:\n\n| Version   | Changes                                                         |\n| --------- | --------------------------------------------------------------- |\n| v13.0.0   | `beforeInteractive`와 `afterInteractive`가 `app` 디렉터리 지원을 위해 수정됨 |\n| v12.2.4   | `onReady` prop 추가                                             |\n| v12.2.2   | `beforeInteractive` 옵션을 가진 `\u003cScript\u003e`를 `_document`에 배치 가능하게 변경        |\n| v11.0.0   | `next/script` 컴포넌트 도입                                     |\n\n---\n\n### 추가로 알아두면 좋은 팁!\n\n- **로드 전략 제어**: `\u003cScript\u003e`는 `strategy`라는 속성을 통해 스크립트가 언제 로드되고 실행될지 정할 수 있어요. 주요 값으로는 `beforeInteractive`(HTML 파싱 전에 로드), `afterInteractive`(페이지 인터랙티브 후 로드), `lazyOnload`(브라우저 유휴 상태에서 로드) 등이 있답니다.\n\n- **중복 로드 방지**: `\u003cScript\u003e`는 같은 `src`를 가진 스크립트가 여러 곳에 있어도 중복으로 로드하지 않으니, 여러 컴포넌트에서 스크립트를 사용할 때도 걱정 없어요.\n\n- **직접적인 DOM 접근이 필요할 때**: 가끔 외부 스크립트가 페이지 렌더링에 영향을 미치거나, DOM 요소를 직접 조작해야 할 때가 있어요. 이럴 때는 `\u003cScript\u003e` 컴포넌트를 적절히 사용해서 로딩 순서를 관리하면 좋은 성능을 기대할 수 있답니다.\n\n---\n\n요약하자면, Next.js 11버전부터 등장한 `\u003cScript\u003e` 컴포넌트 덕분에 외부 스크립트를 더 안전하고 효율적으로 관리할 수 있게 되었어요. 앞으로 외부 자바스크립트를 넣을 때는 직접 `\u003cscript\u003e` 태그 쓰기보다 이걸 적극 활용해 보세요!\n\n궁금한 점 있으면 언제든 댓글로 물어봐 주세요! 😊","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":25},{"title":"Next.js 15에서 Link 컴포넌트로 라우팅하는 방법","description":"","date":"2025-04-22 02:29","slug":"2025-04-22-Link","content":"\n\n# Link 컴포넌트\n\n`Link`는 React의 `a` 태그를 확장한 Next.js 컴포넌트로, 페이지 간 이동 시 클라이언트 사이드 네비게이션과 사전 로딩(prefetching)을 지원해요. 덕분에 사용자는 더 빠르고 부드러운 페이지 전환을 경험할 수 있답니다. Next.js에서 라우트 간 이동하는 가장 기본적이고 권장되는 방법이에요.\n\n기본 사용법은 이렇게 간단해요:\n\n```js\nimport Link from 'next/link'\n\nexport default function Page() {\n  return \u003cLink href=\"/dashboard\"\u003eDashboard\u003c/Link\u003e\n}\n```\n\n위 코드에서 `href` 속성에 이동할 경로를 넣으면 되고, 내부 텍스트나 컴포넌트가 링크로 표시됩니다.\n\n---\n\n### 좀 더 알아두면 좋은 팁!\n\n- `Link` 내부에 `\u003ca\u003e` 태그를 써서 스타일을 직접 주거나 추가 속성을 넣을 수도 있어요:\n\n```jsx\n\u003cLink href=\"/about\"\u003e\n  \u003ca style={{ color: 'red' }}\u003eAbout Us\u003c/a\u003e\n\u003c/Link\u003e\n```\n\n- 최신 Next.js 버전에서는 내부에 `\u003ca\u003e` 태그를 생략하고 바로 텍스트나 컴포넌트를 넣어도 자동으로 처리해줘서 더 편해졌습니다.\n  \n- `prefetch` 속성으로 미리 데이터를 불러오게 할 수 있는데, 기본값은 `true`예요. 페이지가 백그라운드에서 빠르게 로드되도록 도와줍니다.\n\n- `Link`를 사용할 때는 외부 링크에는 적합하지 않아요. 외부 주소를 연결할 땐 일반 `a` 태그나 `next/head` 내의 `meta` 태그를 쓰는 게 맞습니다.\n\n이렇게 `Link` 컴포넌트를 활용하면 Next.js 앱에서 라우팅이 훨씬 깔끔하고 빠르게 진행돼, 사용자 경험도 크게 향상되니 꼭 기억해두세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 참고자료\n\n`Link` 컴포넌트에 전달할 수 있는 주요 props를 정리해봤어요. 이걸 알면 링크를 어떻게 제어할 수 있는지 감이 딱 옵니다!\n\n| Prop        | 예시                         | 타입                | 필수 여부 |\n|-------------|-----------------------------|---------------------|-----------|\n| [href](#href-required)          | `href=\"/dashboard\"`           | String 또는 Object   | 필수      |\n| [replace](#replace)            | `replace={false}`             | Boolean             | 선택      |\n| [scroll](#scroll)              | `scroll={false}`              | Boolean             | 선택      |\n| [prefetch](#prefetch)          | `prefetch={false}`            | Boolean 또는 null    | 선택      |\n| [onNavigate](#onnavigate)      | `onNavigate={(e) =\u003e {}}`      | Function            | 선택      |\n\n\u003e 팁!  \n`Link`에 `className`이나 `target=\"_blank\"` 같은 `a` 태그 속성도 props로 넣으면 내부 `a` 태그에 똑같이 전달돼요.  \n예를 들어 새 탭에서 열고 싶으면 다음처럼 쓰면 됩니다:  \n```jsx\n\u003cLink href=\"/page\" target=\"_blank\" className=\"my-link\"\u003eGo to Page\u003c/Link\u003e\n```\n\n---\n\n### href\n\n`href`는 어디로 연결할지 경로나 URL을 지정하는 데 꼭 필요해요. 문자형 문자열이나 URL을 나타내는 객체 둘 다 써도 됩니다.\n\n---\n\n### replace\n\n`replace`가 `true`면 링크를 이동할 때 브라우저 히스토리를 새로 만들지 않고 현재 기록을 덮어쓰게 돼요. SPA에서 뒤로 가기 버튼을 눌렀을 때 이전 페이지로 돌아가지 않게 할 때 유용하죠.\n\n---\n\n### scroll\n\n기본적으로 `Link`를 클릭하면 페이지가 최상단으로 스크롤 돼요. `scroll={false}`를 주면 그 동작을 막을 수 있어요. 스크롤 위치를 유지하고 싶을 때 기억해두면 좋아요.\n\n---\n\n### prefetch\n\n`prefetch` 속성은 해당 링크의 페이지 데이터를 미리 불러올지 결정합니다. 네트워크 비용을 약간 부담하더라도 미리 로딩해두면 사용자 경험이 훨씬 부드러워져서 개인적으로 자주 사용해요.  \n`false`를 주면 미리 로딩하지 않습니다.\n\n---\n\n### onNavigate\n\n링크 이동 시 실행할 커스텀 함수도 넣을 수 있어요. 예를 들어, 링크 클릭 전 알림 창을 띄우거나, 이동을 조건부로 막을 때 활용할 수 있죠.\n\n---\n\n저도 이 링크 컴포넌트 쓸 때, 어떻게 하면 사용자 경험이 더 좋아질까 하면서 이 props들을 잘 활용하는 편입니다. 애플리케이션 특성에 맞게 적절히 조합해서 써보세요! 혹시 생소한 props 있으면 댓글이나 질문 주세요 :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### href (필수)\n\n`href`는 이동하고자 하는 경로나 URL을 지정하는 속성이에요.\n\n```js\nimport Link from 'next/link'\n\n// /about?name=test 경로로 이동하는 예제\nexport default function Page() {\n  return (\n    \u003cLink\n      href={{\n        pathname: '/about',\n        query: { name: 'test' },\n      }}\n    \u003e\n      About\n    \u003c/Link\u003e\n  )\n}\n```\n\n위 코드처럼 `href`에는 문자열 경로뿐만 아니라 `pathname`과 `query` 객체 형태로도 전달할 수 있어요. 이렇게 하면 URL 쿼리 스트링을 깔끔하게 관리할 수 있죠.\n\n---\n\n### replace\n\n`replace`는 링크를 클릭했을 때 현재 페이지를 대체해서 히스토리에 쌓이지 않도록 하는 옵션이에요.\n\n예를 들어:\n\n```js\nimport Link from 'next/link'\n\nexport default function Page() {\n  return (\n    \u003cLink href=\"/about\" replace\u003e\n      About (Replace)\n    \u003c/Link\u003e\n  )\n}\n```\n\n이렇게 하면 사용자가 링크를 누르면 `/about`으로 이동하지만, 브라우저 뒤로 가기 버튼을 눌러도 이전 페이지로 돌아가지 않아요. 기존의 기록(history)을 새로운 페이지로 덮어쓰는 방식이라고 생각하면 이해가 쉬워요.\n\n---\n\n### 추가로 알려드리는 팁!\n\n- **prefetch**: Next.js의 `Link` 컴포넌트에는 자동으로 링크된 페이지를 미리 불러오는 `prefetch` 기능이 기본으로 켜져 있어요. 이는 페이지 전환 속도를 크게 올려주지만, 네트워크 비용이 부담될 수 있는 점 참고하세요.\n\n- **passHref**: `Link`가 자식 컴포넌트로 감싸고 있는 태그가 `\u003ca\u003e`가 아닌 다른 컴포넌트일 때, `passHref` 속성을 사용하면 `href`가 자식 컴포넌트에게 제대로 전달돼요.\n\n이렇게 Next.js의 `Link` 컴포넌트를 활용하면 SPA(싱글 페이지 어플리케이션)처럼 빠르고 부드러운 화면 전환을 손쉽게 만들 수 있으니 꼭 익혀두시면 좋아요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js의 `next/link`에서 자주 쓰이는 `replace`와 `scroll` 속성에 대해 쉽게 설명해볼게요.\n\n### replace 속성\n\n기본값은 `false`입니다.  \n`replace`를 `true`로 설정하면, 새로운 URL을 브라우저의 히스토리에 추가하는 대신 현재 히스토리 상태를 **대체**해버려요. 쉽게 말해, 뒤로 가기 버튼을 눌렀을 때 이전 페이지가 아니라 그 전 페이지로 바로 가도록 하는 거죠.\n\n예시 코드를 보면,\n\n```jsx\nimport Link from 'next/link'\n\nexport default function Page() {\n  return (\n    \u003cLink href=\"/dashboard\" replace\u003e\n      Dashboard\n    \u003c/Link\u003e\n  )\n}\n```\n\n'Dashboard' 링크를 클릭했을 때 새로운 히스토리를 쌓는 게 아니라 기존 상태를 바꾸기에, 브라우저 히스토리가 깔끔해져요. 이 기능은 로그인 리디렉션 같은 상황에서 유용하게 쓰입니다.\n\n---\n\n### scroll 속성\n\n기본값은 `true`예요.  \nLink로 페이지를 이동할 때 스크롤 위치를 어떻게 처리할지 결정해주는데요,\n\n- `scroll={true}`면, 백/포워드 내비게이션처럼 브라우저가 스크롤 위치를 유지해줘요.\n- 물론, 새로운 페이지가 보기에 없거나 새롭게 랜더링되면 자동으로 페이지 맨 위로 스크롤이 이동합니다.\n\n만약 페이지 전환할 때마다 항상 맨 위로 스크롤시키고 싶다면(특별한 경우), `scroll`을 `true`로 둬야 하고, 특정 스크롤 위치 유지를 원한다면 `false`로 설정하세요.\n\n---\n\n### 추가 팁!\n\n- 히스토리 관리가 복잡한 싱글 페이지 앱(SPA)에서 `replace` 옵션을 적절히 활용하면 사용자 경험이 더 자연스러워집니다.\n- 스크롤 조작은 모바일에서 특히 UX에 큰 영향을 줄 수 있으니 필요에 따라 세밀하게 조절하는 걸 추천해요.\n\n간단하지만 꼭 알아둬야 하는 Next.js의 핵심 속성들이니까, 실제 프로젝트에서 한번씩 설정해보면서 감을 잡아보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 `scroll = false`로 설정하면, 첫 번째 페이지 요소로 자동 스크롤을 시도하지 않는다는 점 기억해두면 좋아요.\n\n\u003e 팁: Next.js는 네비게이션 시 `scroll: false`인지 먼저 확인하고 스크롤 동작을 제어하는데요. 만약 스크롤이 활성화되어 있다면, DOM에서 관련 요소를 찾아내어 최상위 요소들을 하나씩 체크합니다. 여기서 스크롤이 불가능하거나 HTML이 렌더링되지 않은 요소들(예를 들어 sticky나 fixed 위치 요소, getBoundingClientRect로 계산된 화면에 보이지 않는 요소)은 건너뛰고요. 그런 다음 형제 요소들을 계속 탐색하면서 화면(viewport)에 보이는 스크롤 가능한 요소를 찾아 스크롤을 수행합니다.\n\n아래 코드는 `Link` 컴포넌트 사용 예시입니다. `scroll={false}` 속성을 줘서 해당 링크 클릭 시 스크롤 이동이 일어나지 않도록 설정하고 있어요:\n\n```jsx\nimport Link from 'next/link'\n \nexport default function Page() {\n  return (\n    \u003cLink href=\"/dashboard\" scroll={false}\u003e\n      Dashboard\n    \u003c/Link\u003e\n  )\n}\n```\n\n### prefetch 속성에 대해 잠깐\n\nNext.js의 `Link` 컴포넌트엔 `prefetch`라는 속성도 있는데요, 이게 켜져 있으면 해당 링크에 마우스를 올리거나 화면에 보일 때 미리 페이지 리소스를 다운로드해서 빠르게 이동할 수 있게 해줍니다. 기본값은 보통 `true`이지만, 특정 상황에서는 성능 최적화를 위한 선택적 비활성화가 가능해요.\n\n예를 들어, 사용자가 자주 클릭하지 않는 링크에 대해서는 `prefetch={false}`를 줘서 불필요한 데이터 로드를 막을 수 있습니다.  \n```jsx\n\u003cLink href=\"/some-page\" prefetch={false}\u003e\n  Some Page\n\u003c/Link\u003e\n```\n\n이렇게 Next.js에서 스크롤과 프리페치 설정을 적절히 활용하면 사용자 경험을 더 풍부하고 빠르게 만들어줄 수 있습니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js의 `Link` 컴포넌트에서 **프리페칭(prefetching)** 기능은 사용자가 링크를 화면에서 보게 될 때(초기 로드 시 혹은 스크롤로 인해) 자동으로 해당 경로와 데이터를 미리 불러오는 기능이에요. 이렇게 하면 사용자가 실제로 링크를 클릭했을 때 훨씬 빠르게 페이지가 열려서, 좀 더 부드럽고 빠른 사용자 경험을 제공할 수 있죠.\n\n### 프리페칭 작동 방식\n- 사용자가 링크 컴포넌트를 화면에 보게 되면 Next.js가 백그라운드에서 해당 경로와 데이터를 미리 요청해요.\n- 만약 미리 받아온 데이터가 시간이 지나 만료되었다면, 사용자가 링크에 마우스를 올릴 때 다시 한 번 프리페칭을 시도합니다.\n- 중요한 점! 이 기능은 **프로덕션 환경에서만** 활성화돼요. 개발 모드에서는 자동으로 프리페칭하지 않습니다.\n\n### prefetch 속성에 들어갈 수 있는 값과 의미\n\n| prop 값 | 설명 |\n|---------|------|\n| `null` (기본값) | 라우트가 정적(static)인 경우 전체 경로와 데이터를 미리 가져와요. 동적(dynamic)인 경우 가장 가까운 `loading.js` 경계(segment)까지만 부분적으로 프리페치합니다. |\n| `true` | 정적, 동적 상관없이 전체 경로와 데이터를 전부 미리 불러와요. |\n| `false` | 뷰포트 진입 시나 마우스 오버 시에도 프리페칭이 **절대** 일어나지 않아요. |\n\n### 실제 예시 코드\n```js\nimport Link from 'next/link'\n\nexport default function Page() {\n  return (\n    \u003cLink href=\"/dashboard\" prefetch={false}\u003e\n      Dashboard\n    \u003c/Link\u003e\n  )\n}\n```\n\n위 예에서는 `/dashboard` 경로의 프리페칭을 끈 상태예요. 이렇게 하면 페이지가 무거운 경우, 불필요한 데이터 요청을 방지할 수 있죠.\n\n---\n\n### 추가 팁!\n- 프리페칭을 적절히 활용하면 사용자가 링크를 클릭했을 때 대기 시간을 크게 줄일 수 있어요. 하지만 너무 많은 페이지를 미리 불러오면 네트워크 비용과 메모리 사용량이 증가할 수 있으니 꼭 필요한 페이지에만 사용하는 걸 추천합니다.\n- 만약 여러분이 동적 라우팅을 많이 쓴다면, `loading.js` 같은 경계점을 잘 활용해서 불필요한 데이터가 미리 불러와지는 걸 막을 수 있어요.\n- 그리고 React의 `Suspense`와 잘 활용하면 더욱 유연한 로딩 경험을 제공할 수 있으니 관심이 있다면 같이 공부해보면 좋아요!\n\n프리페칭을 이해하고 적절하게 적용하면 더 빠르고 쾌적한 Next.js 앱을 만들 수 있으니, 꼭 활용해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### onNavigate 이벤트 핸들러\n\nNext.js에서 client-side navigation, 즉 페이지가 새로고침 없이 이동할 때 실행되는 이벤트 핸들러가 있는데요, 바로 `onNavigate`입니다. 이 핸들러는 이벤트 객체를 받고, 이 객체 안에는 `preventDefault()` 메서드도 있어서 필요하다면 이동을 취소할 수도 있어요.\n\n```jsx\nimport Link from 'next/link'\n\nexport default function Page() {\n  return (\n    \u003cLink\n      href=\"/dashboard\"\n      onNavigate={(e) =\u003e {\n        // SPA 내비게이션 중에만 실행돼요.\n        console.log('Navigating...')\n  \n        // 필요하면 이걸 호출해서 내비게이션을 막을 수 있어요.\n        // e.preventDefault()\n      }}\n    \u003e\n      Dashboard\n    \u003c/Link\u003e\n  )\n}\n```\n\n\u003e 알아두면 좋은 점: `onClick`과 `onNavigate`는 비슷해 보일 수 있지만, 용도가 좀 달라요.  \n\u003e - `onClick`은 모든 클릭 이벤트에 대해 실행돼요.  \n\u003e - `onNavigate`는 오직 SPA 내비게이션(클라이언트 사이드 라우팅) 때만 실행됩니다.  \n\u003e  \n\u003e 몇 가지 차이점 정리해 보면:  \n\u003e - Ctrl/Cmd + 클릭(새 탭 열기) 시에는 `onClick`은 실행되지만, `onNavigate`는 실행되지 않아요. (Next.js가 기본적으로 새 탭에서 내비게이션을 막거든요)  \n\u003e - 외부 URL로 이동할 때는 `onNavigate`가 작동하지 않아요. (클라이언트 사이드, 동일 출처 내비게이션 전용이라서요)  \n\u003e - `download` 속성이 있는 링크는 `onClick` 이벤트는 발생하지만, 브라우저가 직접 파일 다운로드를 처리해서 `onNavigate`는 실행되지 않아요.\n\n---\n\n추가로 알려드릴 게 있어요!  \n`onNavigate`는 `next/link` 컴포넌트를 통해 내부 페이지 전환을 좀 더 세밀하게 제어하거나 로깅할 때 아주 유용합니다. 예를 들어, 사용자에게 경고 알림을 띄우거나, 아직 저장하지 않은 작업이 있을 때 확인 메시지를 띄워서 실수로 페이지를 벗어나지 않게 할 수도 있죠. 이럴 때 `e.preventDefault()`가 아주 중요한 역할을 합니다.\n\n반면에, 외부 링크나 새 탭 열기 등에는 작동하지 않기 때문에, 전체 클릭 이벤트를 감지하려면 `onClick`도 함께 활용하는 게 좋습니다. 두 이벤트를 적절히 구분해서 쓰면 사용자 경험을 한층 더 세심하게 만들 수 있답니다.\n\n그 밖에 SPA 내비게이션이 제대로 감지되는지 꼭 테스트도 해보세요! Next.js는 자주 업데이트되니 공식 문서나 최신 릴리즈 노트도 틈틈이 체크하는 걸 추천해요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 예제들\n\n아래 예제들은 `Link` 컴포넌트를 다양한 상황에서 어떻게 사용하는지 보여줘요.\n\n### 동적 세그먼트에 링크 걸기\n\n동적 세그먼트에 링크를 걸 때는 템플릿 리터럴과 변수 삽입을 활용해서 링크 목록을 쉽게 만들 수 있어요. 예를 들어, 블로그 게시물 목록을 만들 때 이렇게 할 수 있죠:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 포스트 리스트를 보여주는 코드와, 현재 경로에 따라 링크에 'active' 클래스를 추가하는 방법에 대해 살펴볼게요.\n\n---\n\n### 포스트 리스트 컴포넌트\n\n```tsx\nimport Link from 'next/link'\n\ninterface Post {\n  id: number\n  title: string\n  slug: string\n}\n\nexport default function PostList({ posts }: { posts: Post[] }) {\n  return (\n    \u003cul\u003e\n      {posts.map((post) =\u003e (\n        \u003cli key={post.id}\u003e\n          \u003cLink href={`/blog/${post.slug}`}\u003e{post.title}\u003c/Link\u003e\n        \u003c/li\u003e\n      ))}\n    \u003c/ul\u003e\n  )\n}\n```\n\n이 코드는 간단하게 `posts` 배열을 받아서, 각 포스트에 맞는 링크를 생성해줍니다. `slug`를 이용해 동적인 URL(`/blog/${post.slug}`)을 만들고 있죠.\n\n---\n\n### 활성화된(Active) 링크 확인하기\n\n사용자가 어느 페이지에 있는지 알 수 있게 하려면, 해당 링크에 'active' 클래스를 추가하는 게 일반적이에요. Next.js 13 버전부터는 `usePathname()` 훅을 이용해 현재 경로 정보를 쉽게 가져올 수 있습니다.\n\n```tsx\n'use client'\n\nimport { usePathname } from 'next/navigation'\nimport Link from 'next/link'\n\nexport function Links() {\n  const pathname = usePathname()\n\n  return (\n    \u003cnav\u003e\n      \u003cLink className={`link ${pathname === '/' ? 'active' : ''}`} href=\"/\"\u003e\n        Home\n      \u003c/Link\u003e\n\n      \u003cLink\n        className={`link ${pathname === '/about' ? 'active' : ''}`}\n        href=\"/about\"\n      \u003e\n        About\n      \u003c/Link\u003e\n    \u003c/nav\u003e\n  )\n}\n```\n\n- `pathname`이 현재 URL 경로를 반환해요.\n- 이걸 비교해서 조건부로 클래스 이름에 'active'를 붙여줍니다.\n- 이렇게 하면 CSS에서 `.active`에 특별한 스타일을 줘서 현재 위치를 한눈에 알 수 있어요.\n\n---\n\n### 내가 추가로 알려주고 싶은 팁!\n\n1. **부분 일치도 활용하기:**  \n   예를 들어 `/blog/abc` 같은 세부 포스트 경로에 있을 때 `/blog` 메뉴를 활성화하고 싶다면 엄격히 `pathname === '/blog'`로 비교하는 대신 `pathname.startsWith('/blog')`로 체크하면 좋아요.\n\n2. **스타일링은 어떻게?**  \n   예를 들어 CSS 모듈을 쓰고 있다면, 클래스들 연결을 `clsx` 라이브러리를 활용해 조금 더 깔끔하게 관리할 수도 있어요.\n\n3. **Link 컴포넌트 감싸기**  \n   가끔 액티브 상태에 따라 아이콘을 바꾸거나 조작할 때 `\u003cLink\u003e`를 별도의 커스텀 컴포넌트로 만들어 사용하는 방법도 있어요.\n\n---\n\n### 정리하자면\n\n| 내용              | 설명                                      |\n|-------------------|-------------------------------------------|\n| `usePathname()`    | 현재 경로 문자열을 가져오는 훅               |\n| `Link` 컴포넌트    | 페이지 이동용 Next.js 기본 링크 컴포넌트     |\n| active 클래스 추가 | 현재 경로와 링크 경로를 비교해 클래스명 추가 |\n\n---\n\n이렇게 하면 내비게이션 메뉴에서 사용자가 어느 페이지에 있는지 쉽게 시각적으로 알려줄 수 있죠! Next.js로 개발할 때 유용하게 활용해보세요. 😊\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 특정 id로 스크롤하기\n\n웹사이트에서 네비게이션할 때 특정 id로 바로 스크롤하고 싶다면, URL 뒤에 `#` 해시 링크를 붙이거나 `href` 속성에 해시 링크를 전달하면 돼요. Next.js의 `Link` 컴포넌트가 결국 `\u003ca\u003e` 태그로 변환되기 때문에 이 방법이 가능합니다.\n\n```jsx\n\u003cLink href=\"/dashboard#settings\"\u003eSettings\u003c/Link\u003e\n\n// 실제 렌더링 결과\n\u003ca href=\"/dashboard#settings\"\u003eSettings\u003c/a\u003e\n```\n\n\u003e 알아두면 좋은 점:\nNext.js에서는 네비게이션 후에 해당 페이지가 화면에 보이지 않으면 자동으로 그 영역으로 스크롤해줘요. 그래서 별도의 스크립트 없이도 원하는 id로 깔끔하게 이동할 수 있답니다.\n\n참고로, 만약 페이지 내에서 부드러운 스크롤 효과를 원한다면 CSS `scroll-behavior: smooth;`를 `html`이나 `body` 태그에 적용해주는 것도 좋은 방법이에요. 그러면 사용자 경험이 더 좋아져요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 동적 라우트 세그먼트에 링크 걸기\n\n동적 라우트 세그먼트를 사용할 때는 템플릿 리터럴(template literals)을 활용해서 링크 경로를 만들면 정말 편리해요!\n\n예를 들어, Next.js에서 `app/blog/[slug]/page.js`와 같은 동적 라우트가 있을 때, 여러 게시물(post) 목록을 받아 각 게시물별로 동적 경로에 맞춰 링크를 쉽게 만들 수 있답니다. 아래 예제를 보시면 감이 딱 올 거에요:\n\n```js\nimport Link from 'next/link'\n \nexport default function Page({ posts }) {\n  return (\n    \u003cul\u003e\n      {posts.map((post) =\u003e (\n        \u003cli key={post.id}\u003e\n          \u003cLink href={`/blog/${post.slug}`}\u003e{post.title}\u003c/Link\u003e\n        \u003c/li\u003e\n      ))}\n    \u003c/ul\u003e\n  )\n}\n```\n\n- `posts` 배열 안에는 게시물 데이터가 들어있고, 각 게시물마다 고유한 `slug`가 있죠.\n- 이 `slug`를 템플릿 리터럴을 이용해 URL에 넣어줘서 동적인 링크를 만들어 주는 거예요.\n\nTip!  \nNext.js 13부터는 `app` 디렉토리가 도입되면서 라우팅 방식이 약간 바뀌었는데, 이 점 참고하시고 항상 최신 공식 문서를 확인하는 습관을 들이면 좋아요. 또한, `Link` 컴포넌트가 내부적으로 클라이언트 사이드 네비게이션을 해주기 때문에 페이지 이동이 더 부드럽고 빠르답니다!\n\n간단하지만 실무에 꼭 필요한 꿀팁이니 꼭 활용해 보세요~!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### Link의 자식이 `a` 태그를 감싸는 커스텀 컴포넌트라면?\n\nNext.js에서 `Link` 컴포넌트의 자식이 그냥 `a` 태그가 아니라, `a` 태그를 감싸고 있는 커스텀 컴포넌트라면 반드시 `passHref` 속성을 `Link`에 추가해줘야 해요. 특히 styled-components 같은 라이브러리를 사용할 때 이게 꼭 필요해요.\n\n왜냐하면 `passHref`를 안 넣으면 실제 렌더링 되는 `a` 태그에 `href` 속성이 빠져버리거든요. 그럼 접근성(Accessibility)이 떨어지고, 검색 엔진 최적화(SEO)에도 부정적인 영향이 생길 수 있어요. \n\n만약 ESLint를 사용한다면 `next/link-passhref`라는 규칙이 있어서 `passHref`를 제대로 썼는지 체크해주니 참고하세요.\n\n```js\nimport Link from 'next/link'\nimport styled from 'styled-components'\n\n// 이렇게 a 태그를 스타일링한 커스텀 컴포넌트를 만들었어요\nconst RedLink = styled.a`\n  color: red;\n`\n\nfunction NavLink({ href, name }) {\n  return (\n    \u003cLink href={href} passHref legacyBehavior\u003e\n      \u003cRedLink\u003e{name}\u003c/RedLink\u003e\n    \u003c/Link\u003e\n  )\n}\n\nexport default NavLink\n```\n\n- 만약 emotion 라이브러리의 JSX 프래그마(`@jsx jsx`) 기능을 쓴다면, 직접 `a` 태그를 사용해도 무조건 `passHref`를 넣어줘야 해요.\n- 그리고 커스텀 컴포넌트는 `onClick` 프로퍼티를 지원해야 링크 내비게이션이 제대로 작동합니다. 가령 클릭 이벤트를 잘 전달하는지 꼭 확인하세요.\n\n---\n\n추가로 말하자면, `passHref`는 Next.js 12 이전 버전에서는 필수였는데, 최신 버전에서는 보통 자동으로 전달해주기도 해요. 그러나 여전히 커스텀 컴포넌트나 CSS-in-JS 라이브러리와 함께 쓸 때는 명시적으로 `passHref`를 넣는 게 안전합니다. 실수로 빠뜨리면 디버깅할 때 엄청 헷갈릴 수 있으니 기억해두세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 함수형 컴포넌트 안에 중첩된 Link 사용하기\n\nNext.js에서 `\u003cLink\u003e` 컴포넌트의 자식이 함수형 컴포넌트일 때는, 단순히 `passHref`와 `legacyBehavior`를 사용하는 걸로 끝나지 않습니다. 이럴 경우에는 `React.forwardRef`로 해당 컴포넌트를 감싸줘야 제대로 동작해요.\n\n아래 예시 코드를 보면, `MyButton`이라는 함수형 컴포넌트를 만들고, `React.forwardRef`를 이용해서 ref를 전달하는 방법을 보여주고 있답니다:\n\n```jsx\nimport Link from 'next/link'\nimport React from 'react'\n \n// MyButton의 props 타입 정의\ninterface MyButtonProps {\n  onClick?: React.MouseEventHandler\u003cHTMLAnchorElement\u003e\n  href?: string\n}\n \n// React.ForwardRefRenderFunction 타입을 사용해 ref 처리\nconst MyButton: React.ForwardRefRenderFunction\u003c\n  HTMLAnchorElement,\n  MyButtonProps\n\u003e = ({ onClick, href }, ref) =\u003e {\n  return (\n    \u003ca href={href} onClick={onClick} ref={ref}\u003e\n      Click Me\n    \u003c/a\u003e\n  )\n}\n \n// forwardRef로 컴포넌트 감싸기\nconst ForwardedMyButton = React.forwardRef(MyButton)\n \nexport default function Page() {\n  return (\n    \u003cLink href=\"/about\" passHref legacyBehavior\u003e\n      \u003cForwardedMyButton /\u003e\n    \u003c/Link\u003e\n  )\n}\n```\n\n여기서 중요한 점은 `Link`에 `passHref`를 넣어줘야 자식 컴포넌트에 `href`가 올바르게 전달되고, `legacyBehavior`는 Next.js 13에서 `\u003cLink\u003e`의 내부 동작 방식을 이전 버전과 호환하게 해줍니다. 그리고 ref를 전달하려면 반드시 `React.forwardRef`로 감싸줘야 해요.\n\n---\n\n### URL 변경 시, push 대신 replace 사용하기\n\nNext.js의 라우터에서 페이지 이동할 때 기본적으로 `router.push()`를 씁니다. 그런데 때에 따라 이동 기록을 남기고 싶지 않을 때도 있죠? 예를 들어 로그인 후 리다이렉트할 때 뒤로가기를 못 하게 만들고 싶을 때요.\n\n그럴 땐 `router.replace()`를 사용하세요! `replace()`는 현재 기록을 새 URL로 대체하기 때문에, 사용자가 브라우저 뒤로가기로 이전 페이지에 접근할 수 없게 됩니다.\n\n```js\nimport { useRouter } from 'next/router'\n\nfunction SomeComponent() {\n  const router = useRouter()\n\n  const handleRedirect = () =\u003e {\n    router.replace('/dashboard')\n  }\n\n  return \u003cbutton onClick={handleRedirect}\u003eGo to Dashboard\u003c/button\u003e\n}\n```\n\n실제로 많이 사용되는 편리한 기능이라 참고해두시면 웹 앱 내비게이션 관리할 때 훨씬 깔끔해질 거예요.\n\n---\n\n궁금한 점 있으면 언제든 물어봐주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 Link 컴포넌트를 사용할 때 기본 동작은 새로운 URL을 히스토리 스택에 쌓는(push) 거예요. 하지만 이게 항상 원하는 결과는 아닐 수 있죠. 예를 들어, 페이지 이동할 때 새 기록을 남기고 싶지 않다면 replace라는 속성을 사용해줘야 해요. 이렇게요:\n\n```js\nimport Link from 'next/link'\n\nexport default function Page() {\n  return (\n    \u003cLink href=\"/about\" replace\u003e\n      About us\n    \u003c/Link\u003e\n  )\n}\n```\n\nreplace를 넣으면 히스토리에 새 항목이 추가되는 대신, 현재 기록이 대체되기 때문에 뒤로 가기 했을 때 이전 페이지가 바로 나타나는 효과를 낼 수 있어요.\n\n---\n\n### 페이지 이동 시 스크롤 위치 유지하기\n\nNext.js Link의 기본 스크롤 동작은 '페이지 상단으로 자동 스크롤' 하는 게 아니라, 브라우저에서 뒤로 가기나 앞으로 가기 할 때처럼 현재 스크롤 위치를 그대로 유지하는 거예요. 즉, 새 페이지로 이동해도 사용자가 보던 위치가 그대로 유지된다는 뜻이죠.\n\n이게 의외로 유용한 이유는 긴 페이지를 보고 있던 상황에서 페이지 전환 후에도 스크롤 위치가 유지되면 사용자는 자연스럽게 이어서 볼 수 있기 때문이에요. 물론 상단으로 강제로 스크롤하고 싶으면 별도의 조치를 취해야 한다는 점 참고하세요.\n\n---\n\n### 추가 팁!\n\n만약 페이지가 바뀔 때마다 무조건 상단으로 스크롤 하고 싶다면, Next.js의 `useRouter` 훅을 사용해 `router.events`의 `routeChangeComplete` 이벤트에 리스너를 걸어서 수동으로 스크롤을 조작할 수 있어요.\n\n```js\nimport { useEffect } from 'react'\nimport { useRouter } from 'next/router'\n\nexport default function MyApp({ Component, pageProps }) {\n  const router = useRouter()\n\n  useEffect(() =\u003e {\n    const handleRouteChange = () =\u003e {\n      window.scrollTo(0, 0)\n    }\n    router.events.on('routeChangeComplete', handleRouteChange)\n    return () =\u003e {\n      router.events.off('routeChangeComplete', handleRouteChange)\n    }\n  }, [router.events])\n\n  return \u003cComponent {...pageProps} /\u003e\n}\n```\n\n이렇게 하면 페이지가 바뀔 때마다 스크롤이 맨 위로 이동해서 깔끔한 사용자 경험을 만들 수 있어요.\n\n---\n\n요약하자면,\n\n| 기능                         | 기본 동작                         | 변경 방법                  |\n|------------------------------|--------------------------------|---------------------------|\n| 히스토리에 새 URL 추가 여부  | 새 URL을 히스토리에 푸시(push) | `replace` prop 사용        |\n| 페이지 전환 시 스크롤 위치   | 현재 위치 유지                   | 직접 스크롤 위치 조작 필요  |\n\nNext.js의 Link는 이렇게 유연하게 동작하니 상황에 따라 적절히 활용해 보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 링크를 클릭할 때 페이지가 화면에 보이지 않으면 자동으로 첫 번째 페이지 요소의 맨 위로 스크롤이 이동하는 기본 동작이 있어요. 근데 이 스크롤 이동이 불편하거나 필요 없을 때가 있죠? 그럴 때는 `Link` 컴포넌트에 `scroll={false}`를 넣거나, `router.push()` 또는 `router.replace()`를 사용할 때 옵션으로 `{ scroll: false }`를 넘겨주면 이 자동 스크롤을 막을 수 있어요.\n\n예를 들어, 아래는 `Link` 컴포넌트에서 스크롤 이동을 막는 방법입니다:\n\n```jsx\nimport Link from 'next/link'\n \nexport default function Page() {\n  return (\n    \u003cLink href=\"/#hashid\" scroll={false}\u003e\n      Disables scrolling to the top\n    \u003c/Link\u003e\n  )\n}\n```\n\n`router.push()`나 `router.replace()`를 사용할 때는 이렇게 하면 됩니다:\n\n```jsx\n// useRouter\nimport { useRouter } from 'next/navigation'\n \nconst router = useRouter()\n \nrouter.push('/dashboard', { scroll: false })\n```\n\n여기서 한 가지 팁을 더 드리자면, `scroll={false}` 옵션을 사용하면 URL 이동은 되지만 페이지가 바뀌면서 자동으로 스크롤이 되지 않기 때문에 해시 링크(`#hashid`)나 특정 위치로 부드럽게 스크롤하려면 직접 스크롤을 제어하는 로직을 추가해줘야 해요. 예를 들어, `useEffect`와 `window.scrollTo`를 이용해서 원하는 위치로 스크롤을 움직이는 방식이죠.\n\n또한, 이런 스크롤 제어 옵션은 SPA 내에서 페이지 이동 시 유저 경험을 다양하게 조절할 수 있어서 상황에 맞게 쓰면 훨씬 깔끔한 UX를 만들 수 있으니 기억해두세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### Middleware에서 링크 프리페칭(Prefetching) 하기\n\nMiddleware를 쓸 때, 보통 인증 처리나 특정 조건에 따라 사용자를 다른 페이지로 리다이렉트하는 작업을 많이 하죠. 그런데 Next.js에서 `Link` 컴포넌트를 사용할 때 Middleware에 의해 경로가 리라이트(rewrite) 되는 경우, 그냥 `href`만 넣으면 프리페칭이 제대로 되지 않을 수 있어요.\n\n그래서 Next.js한테 \"이 링크는 사용자에게는 `/` 경로로 보여주지만, 실제 프리페칭을 할 땐 `/auth/dashboard`나 `/public/dashboard`로 미리 자료를 가져와\" 라고 알려줘야 합니다. 이러면 Middleware에서 불필요하게 fetch를 여러 번 해서 정체를 파악하는 일을 줄일 수 있어요. (사실 미리 경로까지 알려주는 꼼수랄까요?)\n\n예를 들어, 인증된 사용자와 비인증 방문자를 각각 다르게 보여주는 `/dashboard` 라우트를 셋업했다고 하면, Middleware를 이렇게 작성합니다:\n\n```js\nimport { NextResponse } from 'next/server'\n\nexport function middleware(request: Request) {\n  const nextUrl = request.nextUrl\n  if (nextUrl.pathname === '/dashboard') {\n    if (request.cookies.authToken) {\n      // 인증된 사용자라면 /auth/dashboard로 리라이트\n      return NextResponse.rewrite(new URL('/auth/dashboard', request.url))\n    } else {\n      // 비인증 방문자는 /public/dashboard로 리라이트\n      return NextResponse.rewrite(new URL('/public/dashboard', request.url))\n    }\n  }\n}\n```\n\n---\n\n### 좀 더 알면 좋은 팁!\n\n- **`NextResponse.rewrite()`** 는 사용자가 요청한 URL을 실제 서버측 처리 경로로 바꿔줘요. 즉, 사용자는 `/dashboard`를 보지만 내부적으로는 `/auth/dashboard` 또는 `/public/dashboard`를 보여주게 되는 거죠.\n\n- 이렇게 하면 SEO에도 도움이 됩니다. 클라이언트 측에서 보는 URL은 깔끔하면서도, 내부에서는 사용자 권한에 맞는 콘텐츠를 노출할 수 있어요.\n\n- 프리페칭을 제대로 하려면 Next.js `Link` 컴포넌트에서 `href`와 `as`(또는 `prefetch` 관련 옵션)를 적절히 써야 하는데, Next.js 13 이상에서 미들웨어 기반 리라이트가 지원되는 환경이라면 이 방법이 특히 효과적입니다.\n\n- 만약 레거시 라우팅 시스템을 쓰고 있거나, 미들웨어가 복잡한 경우라면 프리페치가 꼬일 수 있으니 이 점도 참고하세요.\n\n---\n\n### 마무리\n\nMiddleware는 아주 강력한 도구지만, 링크 프리페칭 같은 세밀한 부분까지 챙겨야 빠르고 깔끔한 사용자 경험을 제공할 수 있습니다. 사용자가 화면 전환 시 빠른 로딩을 느끼도록, 미들웨어 리라이트를 제대로 이해하고 Next.js에 알려주는 게 중요해요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번에 `Link` 컴포넌트에서 경로를 조건에 따라 다르게 연결하고 싶을 때, 다음과 같이 작성해주면 됩니다:\n\n```js\n'use client'\n\nimport Link from 'next/link'\nimport useIsAuthed from './hooks/useIsAuthed' // 인증 상태를 확인하는 커스텀 훅\n\nexport default function Page() {\n  const isAuthed = useIsAuthed()\n  // 인증 상태에 따라서 이동할 경로를 바꿔줘요\n  const path = isAuthed ? '/auth/dashboard' : '/public/dashboard'\n  return (\n    \u003cLink as=\"/dashboard\" href={path}\u003e\n      Dashboard\n    \u003c/Link\u003e\n  )\n}\n```\n\n여기서 `useIsAuthed`는 내가 직접 만든 인증 관련 커스텀 훅이고, 로그인 상태인지 아닌지에 따라 `/auth/dashboard` 혹은 `/public/dashboard`로 연결해주고 있어요. 그리고 `as` 속성은 실제 URL에 표시될 경로를 정해주는 역할을 하니, `/dashboard`로 깔끔하게 보이도록 한 거죠.\n\n---\n\n### 네비게이션 차단하기 (Blocking navigation)\n\n사용자가 폼을 작성 중인데 저장하지 않고 페이지를 벗어나려고 할 때, 네비게이션을 막아서 \"변경사항이 사라질 수 있어요!\"라고 경고하고 싶을 때가 있죠? 이런 경우엔 `onNavigate`라는 prop을 활용하면 돼요. 조건에 따라서 이동을 차단할 수 있도록 구현할 수 있습니다.\n\n근데 앱 규모가 커지면 이런 차단 로직을 여러 컴포넌트에서 일관되게 관리해야 하잖아요? 그럴 때 React Context를 사용하면 앱 전체에 차단 상태를 공유하고 관리하기가 편해집니다.\n\n먼저, 네비게이션 차단 상태를 관리할 Context를 만들어볼게요:\n\n```js\nimport { createContext, useState, useContext } from 'react'\n\nconst NavigationBlockContext = createContext({\n  isBlocked: false,\n  setIsBlocked: () =\u003e {},\n})\n\n// 차단 상태를 전역에서 관리할 Provider 컴포넌트\nexport function NavigationBlockProvider({ children }) {\n  const [isBlocked, setIsBlocked] = useState(false)\n  \n  return (\n    \u003cNavigationBlockContext.Provider value={{ isBlocked, setIsBlocked }}\u003e\n      {children}\n    \u003c/NavigationBlockContext.Provider\u003e\n  )\n}\n\n// Context를 쉽게 사용하는 커스텀 훅\nexport function useNavigationBlock() {\n  return useContext(NavigationBlockContext)\n}\n```\n\n이렇게 만들어두면, 폼이나 링크 컴포넌트 어디서든 `useNavigationBlock`을 불러와서 네비게이션 차단 여부를 읽거나 설정할 수 있어요.\n\n예를 들어, 폼에서는 사용자가 작성 중일 때 `setIsBlocked(true)`로 네비게이션을 막고, 저장하거나 취소하면 `setIsBlocked(false)`로 해제해주면 됩니다.\n\n---\n\n### 추가 팁!\n\n- 네이티브 `beforeunload` 이벤트와 연동해서 사용자가 탭을 닫거나 새로고침하려고 할 때도 경고를 띄우는 걸 같이 구현할 수 있어요.\n- `onNavigate` 콜백에서 사용자가 정말로 이동할지 확인하는 모달을 만들어 보여주면 UX가 훨씬 좋아집니다.\n- Next.js 13 기준이라면, `Link` 컴포넌트가 기본적으로 클라이언트 컴포넌트이므로 `use client` 선언을 잊지 마세요!\n\n필요하다면 네비게이션 차단과 관련된 샘플 코드도 더 공유할게요. 도움이 되었길 바랍니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n작성해주신 코드는 React context를 활용해서 페이지 이동(네비게이션)을 막을 수 있는 간단한 구조를 만들려는 시도입니다. 폼에서 데이터가 변경되면 `isBlocked` 상태를 true로 바꿔서 이동을 막고, 저장하면 false로 다시 풀어주는 형태입니다.\n\n근데 조금 수정이 필요한 부분이 있어서, 전체적으로 사용법과 함께 설명을 드리고, 마지막에 네비게이션을 막는 커스텀 Link 컴포넌트까지 만들어볼게요!\n\n---\n\n## 1. NavigationBlockerContext 고쳐보기\n\n```tsx\n'use client'\n\nimport { createContext, useState, useContext, ReactNode } from 'react'\n\ninterface NavigationBlockerContextType {\n  isBlocked: boolean\n  setIsBlocked: (isBlocked: boolean) =\u003e void\n}\n\nexport const NavigationBlockerContext = createContext\u003cNavigationBlockerContextType\u003e({\n  isBlocked: false,\n  setIsBlocked: () =\u003e {},\n})\n\nexport function NavigationBlockerProvider({ children }: { children: ReactNode }) {\n  const [isBlocked, setIsBlocked] = useState(false)\n\n  return (\n    \u003cNavigationBlockerContext.Provider value={{ isBlocked, setIsBlocked }}\u003e\n      {children}\n    \u003c/NavigationBlockerContext.Provider\u003e\n  )\n}\n\nexport function useNavigationBlocker() {\n  return useContext(NavigationBlockerContext)\n}\n```\n\n### 여기서 수정한 점\n\n- `value={ isBlocked, setIsBlocked }` → 이건 객체 형태여야 해서 `{ isBlocked, setIsBlocked }`로 바꿔줘야 해요.\n- `children` 타입에 ReactNode를 붙여줬어요.\n\n---\n\n## 2. Form 컴포넌트에서 이동 방지 상태 변경하기\n\n```tsx\n'use client'\n\nimport { useNavigationBlocker } from '../contexts/navigation-blocker'\n\nexport default function Form() {\n  const { setIsBlocked } = useNavigationBlocker()\n\n  return (\n    \u003cform\n      onSubmit={(e) =\u003e {\n        e.preventDefault()\n        setIsBlocked(false) // 저장하면 이동 가능\n      }}\n      onChange={() =\u003e setIsBlocked(true)} // 변경되면 이동 막음\n    \u003e\n      \u003cinput type=\"text\" name=\"name\" /\u003e\n      \u003cbutton type=\"submit\"\u003eSave\u003c/button\u003e\n    \u003c/form\u003e\n  )\n}\n```\n\n여기서도 `onSubmit` 이벤트 함수 닫는 괄호가 빠졌네요. 수정해주었습니다.\n\n---\n\n## 3. 네비게이션을 막는 커스텀 Link 컴포넌트 만들기\n\n일단 React에서 페이지 이동을 제어할 때 보통 `react-router`나 `next/router`를 씁니다.  \n이 예시에서는 Next.js 13 또는 React Router 같은 걸 생각하면서 기본적인 커스텀 Link를 만들어볼게요.\n\n```tsx\n'use client'\n\nimport Link, { LinkProps } from 'next/link' // next/link 쓰는 경우\nimport { useNavigationBlocker } from '../contexts/navigation-blocker'\nimport { useRouter } from 'next/navigation'\nimport { MouseEvent } from 'react'\n\ninterface NavigationBlockerLinkProps extends LinkProps {\n  children: React.ReactNode\n}\n\nexport default function NavigationBlockerLink({ children, href, ...props }: NavigationBlockerLinkProps) {\n  const { isBlocked } = useNavigationBlocker()\n  const router = useRouter()\n\n  const handleClick = (e: MouseEvent\u003cHTMLAnchorElement\u003e) =\u003e {\n    if (isBlocked) {\n      e.preventDefault()\n      if (confirm('변경사항이 저장되지 않았습니다. 페이지를 이동하시겠습니까?')) {\n        router.push(href.toString())\n      }\n    }\n  }\n\n  return (\n    \u003cLink href={href} {...props} onClick={handleClick}\u003e\n      {children}\n    \u003c/Link\u003e\n  )\n}\n```\n\n### 주요 포인트\n\n- `isBlocked` 상태가 true면 이동 전에 confirm 창을 띄워 확인받아요.\n- 확인하면 `router.push`로 직접 이동 처리를 해줍니다.\n- `next/link`의 경우는 `onClick` 이벤트를 지원하므로 이렇게 커스텀이 가능합니다.\n\n---\n\n## 4. 마무리: 페이지 이동 제한 기능 이해하기\n\n- 이 패턴은 보통 사용자가 입력 중인 폼에서 확인 없이 떠나는 걸 막고자 할 때 유용해요.\n- 브라우저 기본 경고성 팝업(예: `beforeunload` 이벤트)을 쓰는 방법도 있지만 UX 제어에 한계가 있어요.\n- 이렇게 컨텍스트와 커스텀 Link로 제어하면 리액트단에서 한결 편하고 깔끔하게 구현됩니다.\n- 참고로 브라우저 새로고침, 닫기 등의 동작까지 막으려면 `window.addEventListener('beforeunload', ...)`를 추가하는 것도 고려해보세요!\n\n---\n\n## 참고용 전체 코드\n\n| 파일명 | 주요 내용 |\n| --- | --- |\n| contexts/navigation-blocker.tsx | NavigationBlockerContext와 Provider 정의 |\n| components/Form.tsx | 변경 시 이동 막고, 저장 시 이동 허용하는 폼 |\n| components/NavigationBlockerLink.tsx | 이동 전에 확인창 띄우는 커스텀 Link |\n\n---\n\n필요하면 제가 `beforeunload` 이벤트 활용법도 추가 작성해드릴게요. 언제든 질문 주세요!  \n이제 이 패턴으로 더 깔끔하게 사용자 이동 제한 기능을 구현해보세요~!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자, 이번에는 Next.js 프로젝트에서 \"저장하지 않은 변경사항이 있을 때 페이지 이동을 막는\" 커스텀 링크 컴포넌트를 만들어보는 방법을 다뤄볼게요. 사용자 경험을 고려할 때, 이런 기능은 정말 유용하답니다!\n\n---\n\n### 1. `CustomLink` 컴포넌트 만들기\n\n```tsx\n'use client'\n\nimport Link from 'next/link'\nimport { useNavigationBlocker } from '../contexts/navigation-blocker'\n\ninterface CustomLinkProps extends React.ComponentProps\u003ctypeof Link\u003e {\n  children: React.ReactNode\n}\n\nexport function CustomLink({ children, ...props }: CustomLinkProps) {\n  const { isBlocked } = useNavigationBlocker()\n\n  return (\n    \u003cLink\n      onNavigate={(e) =\u003e {\n        if (\n          isBlocked \u0026\u0026\n          !window.confirm('You have unsaved changes. Leave anyway?')\n        ) {\n          e.preventDefault()\n        }\n      }}\n      {...props}\n    \u003e\n      {children}\n    \u003c/Link\u003e\n  )\n}\n```\n\n\u003e 여기서 `useNavigationBlocker`는 사용자 정의 훅으로, 저장되지 않은 변경사항이 있는지를 상태로 관리해주는 역할을 해요. 상태가 `true`라면 이동 직전에 확인창을 띄워서 사용자가 실수로 페이지를 벗어나지 않도록 막아줍니다.\n\n---\n\n### 2. `Nav` 컴포넌트 구현하기\n\n```tsx\n'use client'\n\nimport { CustomLink as Link } from './custom-link'\n\nexport default function Nav() {\n  return (\n    \u003cnav\u003e\n      \u003cLink href=\"/\"\u003eHome\u003c/Link\u003e\n      \u003cLink href=\"/about\"\u003eAbout\u003c/Link\u003e\n    \u003c/nav\u003e\n  )\n}\n```\n\n\u003e `Nav` 컴포넌트는 위에서 만든 `CustomLink`를 이용해서 메뉴를 구성한 예시입니다.\n\n---\n\n### 3. 루트 레이아웃에 `NavigationBlockerProvider` 사용하기\n\n아직 `NavigationBlockerProvider` 코드는 주어지지 않았지만, 대략 아래와 같은 형태로 감싸주면 됩니다:\n\n```tsx\n'use client'\n\nimport { NavigationBlockerProvider } from '../contexts/navigation-blocker'\n\nexport default function RootLayout({ children }: { children: React.ReactNode }) {\n  return (\n    \u003cNavigationBlockerProvider\u003e\n      {children}\n    \u003c/NavigationBlockerProvider\u003e\n  )\n}\n```\n\n이렇게 하면 앱 전체에 저장되지 않은 변경사항 감지 상태가 공유되고, `CustomLink`가 이를 활용해 네비게이션 차단기능을 수행할 수 있게 됩니다.\n\n---\n\n### 간단히 정리\n\n| 구성 요소 | 역할 |\n|---|---|\n| `NavigationBlockerProvider` | 저장되지 않은 변경사항 감지 상태를 Context API로 제공 |\n| `useNavigationBlocker` | Context에서 `isBlocked` 값과 상태 제어 함수 훅으로 가져오기 |\n| `CustomLink` | Link 컴포넌트를 확장하여 네비게이션 전에 확인창 표시 |\n| `Nav` | `CustomLink`를 이용한 네비게이션 UI |\n\n---\n\n### 추가 팁\n\n- 사용자 경험 관점에서, 페이지 떠나기 전 확인창은 너무 잦으면 귀찮아질 수 있어요. 변경사항을 꼼꼼히 체크하는 로직과 적절한 상태 초기화가 중요합니다.\n- React의 `beforeunload` 이벤트와 연동하여 브라우저 탭 닫기나 새로고침도 막아줄 수 있어요. 필요하다면 추가 구현해보세요.\n- Next.js의 `Link` 컴포넌트가 아직 네비게이션 인터셉트 기능을 완전 지원하지 않는 경우, `router.events` 활용하는 방법도 고려해볼 수 있습니다.\n\n---\n\n이제 여러분도 저장하지 않은 내용 때문에 당황하지 않는 친절한 웹 앱을 만들어 보세요! 필요하면 `useNavigationBlocker`와 `NavigationBlockerProvider` 구현 방법도 알려드릴게요~\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번에는 Next.js 같은 React 프로젝트에서 사용자 경험을 업그레이드하는 ‘네비게이션 차단’ 기능을 만들어보는 얘기를 해볼게요.\n\n먼저, `NavigationBlockerProvider`라는 컨텍스트 프로바이더를 `RootLayout`에 감싸서 앱 전체에서 네비게이션을 관리할 수 있게 했어요. 이렇게 하면 어느 페이지나 컴포넌트에서 ‘아직 저장 안 한 변경사항이 있는데 정말 나가도 되냐’는 확인창을 띄울 수 있죠.\n\n```tsx\nimport { NavigationBlockerProvider } from './contexts/navigation-blocker';\n \nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    \u003chtml lang=\"en\"\u003e\n      \u003cbody\u003e\n        \u003cNavigationBlockerProvider\u003e{children}\u003c/NavigationBlockerProvider\u003e\n      \u003c/body\u003e\n    \u003c/html\u003e\n  );\n}\n```\n\n그리고 실제 페이지에서는 `Nav` 컴포넌트(아마 내비게이션 바)와 `Form` 컴포넌트를 함께 사용했네요.\n\n```tsx\nimport Nav from './components/nav';\nimport Form from './components/form';\n \nexport default function Page() {\n  return (\n    \u003cdiv\u003e\n      \u003cNav /\u003e\n      \u003cmain\u003e\n        \u003ch1\u003eWelcome to the Dashboard\u003c/h1\u003e\n        \u003cForm /\u003e\n      \u003c/main\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n이 상태에서 만약 폼에 수정 사항이 있는데 `CustomLink` 같은 커스텀 내비게이션 링크를 통해 페이지를 옮기려고 하면, ‘정말 페이지를 떠나도 되나요?’ 하는 확인창이 뜰 거예요. 덕분에 사용자는 실수로 작업하던 내용을 날리는 일이 줄어들겠죠?\n\n---\n\n### 조금 더 이야기해볼게요\n\n- 사실 이 기능을 구현하려면 `NavigationBlockerProvider` 내부에 [React Router의 Prompt](https://reactrouter.com/en/main/routers/history-router#prompt) 개념이나, Next.js 13의 `useRouter` 등 네비게이션 훅을 잘 활용해야 해요.\n- 브라우저 탭 닫기나 새로고침 시 경고를 띄우는 `beforeunload` 이벤트 리스너도 함께 등록하면 실수 방지에 더 효과적이에요.\n- 또한, `CustomLink` 컴포넌트는 기본 `\u003cLink\u003e` 대신 네비게이션 차단 로직을 포함해야 하므로, 클릭 시 `e.preventDefault()`로 네비게이션을 잠깐 막은 뒤 사용자 확인을 체크하는 구조로 만드는 게 보통이에요.\n\n이런 부분들은 추후에 한번 더 깊게 다뤄볼게요. 혹시 관심 있다면 직접 만들어보고 궁금한 점 질문해주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 버전 히스토리\n\n| 버전        | 변경 사항                                                                                                             |\n|-------------|----------------------------------------------------------------------------------------------------------------------|\n| `v15.3.0`   | `onNavigate` API 추가                                                                                                 |\n| `v13.0.0`   | 더 이상 자식 `\u003ca\u003e` 태그가 필요하지 않습니다. 코드베이스를 자동으로 업데이트 해주는 \u003ca href=\"/docs/app/guides/upgrading/codemods#remove-a-tags-from-link-components\"\u003ecodemod\u003c/a\u003e 도 제공됩니다. |\n| `v10.0.0`   | 동적 라우트를 가리키는 `href` 속성이 자동으로 처리되어 `as` 속성이 더 이상 필요하지 않습니다.                                    |\n| `v8.0.0`    | 사전 페치(prefetch) 성능 향상                                                                                          |\n| `v1.0.0`    | `next/link` 컴포넌트 도입                                                                                            |\n\n---\n\n이 버전 히스토리를 보면서 Next.js의 `next/link` 컴포넌트가 얼마나 발전해왔는지 한눈에 알 수 있는데요, 특히 v13 버전부터는 `\u003ca\u003e` 태그를 직접 감싸지 않아도 된다는 점이 굉장히 편리해졌어요. 덕분에 JSX가 훨씬 깔끔해지고, 링크 관리가 좀 더 쉬워졌답니다.\n\n또한, v10에서 동적 라우팅이 더 자연스러워진 것도 주목할 만한 변화예요. 예전에는 동적 경로를 사용할 때 `as` 같은 뭔가 추가적인 속성을 계속 신경 써야 했는데, 이제는 `href`만 잘 넘기면 알아서 처리해주니 개발자의 실수를 줄여주죠.\n\n마지막으로 `onNavigate` API 같은 새로운 기능도 추가되고 있으니, 다음 프로젝트에 적용해보시면 한층 더 향상된 사용자 경험을 제공할 수 있을 거예요! 😊\n\n다음에도 업데이트나 새로운 팁 있으면 또 공유할게요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":37},{"title":"Next.js 15에서 이미지 최적화하는 5가지 방법","description":"","date":"2025-04-22 02:20","slug":"2025-04-22-Image","content":"\n\n# Image 컴포넌트 사용법\n\n이번에는 Next.js에서 제공하는 `Image` 컴포넌트에 대해서 알아볼게요. 이미지 최적화에 신경 써야 할 때 직접 `\u003cimg\u003e` 태그를 쓰기보다는 이 컴포넌트를 활용하면 자동으로 다양한 최적화가 진행되어 성능 향상에 도움이 된답니다.\n\n아래는 `Image` 컴포넌트를 사용하는 기본적인 예시입니다.\n\n```js\nimport Image from 'next/image'\n\nexport default function Page() {\n  return (\n    \u003cImage\n      src=\"/profile.png\"       // 이미지 경로\n      width={500}              // 이미지 너비(px)\n      height={500}             // 이미지 높이(px)\n      alt=\"Picture of the author\" // 대체 텍스트 (접근성에 필수!)\n    /\u003e\n  )\n}\n```\n\n`Image` 컴포넌트의 기본적인 사용법은 이렇게 `src`, `width`, `height`, `alt` 속성을 넘겨주는 거에요. 이 외에도 여러 유용한 props들이 있는데, 이어서 자세히 살펴볼게요.\n\n## Image 컴포넌트 주요 Props\n\n| Prop        | 타입          | 설명                                               |\n|-------------|---------------|--------------------------------------------------|\n| src         | string        | 불러올 이미지 경로 또는 URL                        |\n| width       | number/string | 이미지 너비                                       |\n| height      | number/string | 이미지 높이                                       |\n| alt         | string        | 이미지 설명 텍스트 (웹 접근성 측면에서 매우 중요)  |\n| layout      | string        | 이미지 레이아웃 (`fixed`, `intrinsic`, `responsive`, `fill`) 설정 |\n| priority    | boolean       | true일 경우 우선 로딩, 주로 초기 페이지에 사용      |\n| placeholder | string        | 이미지 로딩 전 보여줄 플레이스홀더 (`blur` 가능)  |\n| quality     | number        | 이미지 품질 설정 (1~100)                          |\n| loader      | function      | 커스텀 이미지 로더 함수 설정                      |\n\n### layout 옵션 간단 설명\n\n- `fixed`: 지정한 크기에서 고정\n- `intrinsic`: 원본 비율 유지하며 최대 크기까지 늘어남\n- `responsive`: 부모 컨테이너의 크기에 맞게 반응형 조절\n- `fill`: 부모 컨테이너를 가득 채움 (position: absolute 필요)\n\n### Tip\n`priority` 속성을 설정하면 페이지 로딩 시 해당 이미지가 우선적으로 로드되어 사용자 경험이 개선됩니다. 예를 들어, 프로필 사진이나 메인 배너 이미지에 사용하는 게 좋아요.\n\n또한 `placeholder=\"blur\"`와 함께 `blurDataURL` 속성을 사용하면 이미지를 불러오는 동안 흐릿한 미리보기 이미지를 보여줄 수 있어 깔끔한 로딩 효과를 줄 수 있답니다.\n\n---\n\n추가로 궁금한 점이나 더 자세한 사용법이 필요하면 언제든지 알려주세요! Next.js는 이미지 핸들링을 꽤 잘 처리해주니까 꼭 활용해보시길 추천해요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nImage 컴포넌트에 사용할 수 있는 주요 props를 정리해봤어요. 이 내용을 참고하면 이미지 컴포넌트를 사용할 때 어떤 옵션들을 넣을 수 있는지 한눈에 확인할 수 있을 거예요.\n\n| Prop             | Example                          | Type               | Status     |\n|------------------|---------------------------------|--------------------|------------|\n| `src`            | `src=\"/profile.png\"`             | String             | Required   |\n| `width`          | `width={500}`                   | Integer (px)       | Required   |\n| `height`         | `height={500}`                  | Integer (px)       | Required   |\n| `alt`            | `alt=\"Picture of the author\"`  | String             | Required   |\n| `loader`         | `loader={imageLoader}`          | Function           | -          |\n| `fill`           | `fill={true}`                   | Boolean            | -          |\n| `sizes`          | `sizes=\"(max-width: 768px) 100vw, 33vw\"` | String   | -          |\n| `quality`        | `quality={80}`                  | Integer (1-100)    | -          |\n| `priority`       | `priority={true}`               | Boolean            | -          |\n| `placeholder`    | `placeholder=\"blur\"`            | String             | -          |\n| `style`          | `style={{objectFit: \"contain\"}}`| Object             | -          |\n| `onLoadingComplete` | `onLoadingComplete={img =\u003e done()}` | Function       | Deprecated |\n| `onLoad`         | `onLoad={event =\u003e done()}`      | Function           | -          |\n| `onError`        | `onError={event =\u003e fail()}`     | Function           | -          |\n| `loading`        | `loading=\"lazy\"`                | String             | -          |\n| `blurDataURL`    | `blurDataURL=\"data:image/jpeg...\"` | String         | -          |\n| `overrideSrc`    | `overrideSrc=\"/seo.png\"`         | String             | -          |\n\n---\n\n### 필수로 꼭 들어가야 하는 props\nImage 컴포넌트를 쓸 때는 최소한 다음 네 가지는 꼭 지정해줘야 해요.\n\n- `src`: 이미지 경로 (예: `/profile.png`)  \n- `alt`: 이미지가 로드되지 않을 때 대체 텍스트 역할을 하는 설명  \n- `width`: 이미지 너비 (픽셀 단위)  \n- `height`: 이미지 높이 (픽셀 단위)  \n\n`width`와 `height` 대신에 `fill={true}` 옵션을 사용하는 방법도 있는데, 이 경우 이미지가 부모 요소의 크기에 맞춰서 자동으로 채워지게 돼요.\n\n---\n\n### 그 외에 알아두면 좋은 점들\n- `loader`: 커스텀 이미지 로더를 만들 때 유용해요. 기본 로더 대신 내가 원하는 로딩 방식을 정의할 수 있어요.  \n- `priority`: 중요한 이미지는 이 옵션을 true로 설정해서 퍼포먼스를 개선할 수 있어요. React 내장 lazy loading과 다르게 우선 로드되게 할 수 있답니다.  \n- `placeholder`와 `blurDataURL`: 이미지를 불러오기 전에 흐릿한 이미지(blur 효과)를 보여 주는 용도로 자주 쓰여요. 사용자 경험을 한층 부드럽게 만들어주죠.  \n- `sizes`: 반응형 이미지에서 매우 유용해요. 화면 크기에 따라 적절한 이미지 크기를 제공할 수 있게 도와줍니다.  \n- `onLoad`와 `onError`: 이미지가 로드되었을 때나 에러가 났을 때 적절한 콜백 처리를 하고 싶으면 이 props들을 활용하세요.  \n\n`onLoadingComplete`는 요즘은 사용을 권장하지 않는 Deprecated 상태니까, 가능하면 `onLoad`를 사용하시는 걸 추천해요.\n\n---\n\n실제 프로젝트에서 이미지를 최적화하고 싶을 때 이 컴포넌트의 다양한 옵션들을 잘 활용하면 훨씬 효율적이고 깔끔한 구현이 가능해집니다. 저는 개인적으로 `priority`, `placeholder`, 그리고 `sizes` 옵션을 자주 사용해서 사용자 경험이 좋아지는 걸 체감했어요.\n\n필요한 부분만 잘 골라서 쓰면 되니 너무 걱정 말고 하나씩 시도해보면서 익혀보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안녕하세요! 오늘은 Next.js에서 `Image` 컴포넌트를 사용할 때 `src` 속성에 대해 알아볼게요.\n\n```js\nimport Image from 'next/image'\n \nexport default function Page() {\n  return (\n    \u003cdiv\u003e\n      \u003cImage\n        src=\"/profile.png\"\n        width={500}\n        height={500}\n        alt=\"Picture of the author\"\n      /\u003e\n    \u003c/div\u003e\n  )\n}\n```\n\n위 예제에서 `src`는 이미지 경로를 나타내는데요, Next.js에서는 `src`에 사용할 수 있는 값이 제한되어 있습니다. 그 조건을 한번 살펴볼게요.\n\n| src 값 유형         | 설명                                                                                         |\n|--------------------|--------------------------------------------------------------------------------------------|\n| 정적으로 import된 이미지 파일 | 예를 들어, `import profilePic from '../public/profile.png'` 처럼 미리 불러온 이미지 파일을 사용할 수 있어요.          |\n| 경로 문자열              | URL 형태의 문자열로, 다음 두 경우로 나뉘어요: \u003cbr\u003e - 외부 URL: `https://example.com/image.png` \u003cbr\u003e - 내부 경로: `/profile.png` 等 |\n\n여기서 중요한 점! 내부 경로를 쓸 때는 `loader` 속성에 따라서 다음과 같이 처리되는데요,\n\n- 기본 `loader`를 사용할 때는 `/public` 폴더 내의 자원을 지정할 때는 경로가 `/` 로 시작해야 해요.즉, `/profile.png`는 `public/profile.png`에 위치한 파일을 가리킵니다.\n- 외부 이미지 URL을 쓸 땐 반드시 도메인을 `next.config.js`의 `images.domains` 배열에 추가해줘야 정상적으로 최적화가 이루어져요.\n\n또한, Next.js의 `Image` 컴포넌트는 이미지 최적화나 lazy loading 등 다양한 이점을 주는데요, 그래서 `width`와 `height`를 꼭 명시해주는 게 좋아요. 그래야 이미지가 로드되기 전에도 레이아웃이 안정적으로 잡히고, 화면이 덜 흔들리게 되거든요.\n\n추가 팁으로, 만약 이미지를 자바스크립트에서 직접 import 한다면 이렇게 쓸 수 있습니다:\n\n```js\nimport profilePic from '../public/profile.png'\n\n\u003cImage\n  src={profilePic}\n  alt=\"Profile\"\n  width={500}\n  height={500}\n/\u003e\n```\n\n이렇게 하면 Next.js가 빌드 타임에 이미지 사이즈를 정확히 파악해서 최적화에 도움을 줄 거예요.\n\n요약하면, `src`에 들어가는 값은 크게 두 가지! **정적 import한 이미지** 또는 **경로 문자열**이에요. 외부 이미지를 쓸 때는 꼭 `next.config.js`에 도메인 등록 잊지 마시고, 내부 경로는 `public` 폴더를 기준으로 적절하게 작성하면 된답니다.\n\nNext.js에서 이미지 다루기를 조금 더 편하고 효율적으로 하려면 이 부분을 잘 이해하시면 큰 도움이 될 거예요! 😊\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기본 로더(default loader)를 사용할 때는 다음 사항도 꼭 참고하세요:\n\n- src가 외부 URL일 경우에는 `remotePatterns` 설정도 함께 해줘야 합니다.\n- src가 애니메이션 이미지거나 JPEG, PNG, WebP, AVIF, GIF, TIFF 같은 알려진 포맷이 아닐 때는, 이미지는 있는 그대로(served as-is) 서빙됩니다.\n- src가 SVG 형식이면 기본적으로 차단됩니다. SVG를 사용하려면 `unoptimized` 또는 `dangerouslyAllowSVG` 옵션을 활성화해야 해요.\n\n---\n\n### width 속성\n\n`width` 속성은 이미지의 실제 픽셀 너비를 나타내는 값이에요. 이 값은 이미지가 로드될 때 레이아웃이 흔들리는 걸 막기 위해 적절한 종횡비(aspect ratio)를 계산하는 데 쓰입니다. 하지만 이게 곧 화면에 표시되는 크기를 결정하는 건 아니에요! 화면에 보이는 크기는 CSS로 조절하게 돼요. 쉽게 말해, HTML의 `img` 태그에서 `width` 속성과 비슷한 역할을 한다고 생각하시면 됩니다.\n\n요즘 반응형 이미지 대응이나 레이아웃 안정성을 위해 width, height 같은 실제 이미지 크기 정보를 명확히 지정해주는 게 권장되고 있으니 꼭 기억해 주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n필수 항목입니다. 단, 정적으로 임포트된 이미지나 fill 속성이 적용된 이미지의 경우는 예외입니다.\n\n### height (높이)\n\nheight 속성은 이미지의 본래 높이를 픽셀 단위로 나타냅니다. 이 값은 이미지의 올바른 가로세로 비율을 추론하는 데 사용되며, 로딩 중에 레이아웃이 흔들리는 현상(layout shift)을 방지하는 효과가 있어요. 다만, 실제 화면에 렌더링되는 이미지 크기를 결정하는 속성은 아니에요. 렌더링 크기는 CSS에서 제어하며, HTML `img` 태그의 height 속성과 비슷한 역할을 한다고 생각하시면 됩니다.\n\n이 부분에서 중요한 점은, height 속성을 명시해두면 브라우저가 이미지 로딩 시점에 공간을 미리 확보하기 때문에 “레이아웃 점프” 현상을 줄여 사용자 경험을 개선할 수 있다는 것입니다. 특히 페이지 내 이미지가 많거나 이미지가 느리게 로드되는 환경에서 이 점이 큰 도움이 됩니다.\n\n추가로, 만약 정적으로 임포트된 이미지라면 빌드 시점에 이미지 크기 정보가 이미 포함되어 있어 직접 height를 명시하지 않아도 되고, fill 속성(부모 요소의 크기에 맞춰 이미지를 꽉 채우는 스타일)을 사용하는 경우에도 마찬가지로 height를 직접 지정할 필요가 없습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003e 알아두면 좋은 점:\nwidth와 height 속성은 이미지의 가로세로 비율(종횡비)을 결정하는 데 함께 사용돼요. 브라우저는 이 정보를 바탕으로 이미지가 로딩되기 전에 미리 공간을 확보하죠.  \n하지만 intrinsic size(내재적 크기)가 항상 브라우저에 렌더링되는 크기와 같지는 않아요. 부모 컨테이너 크기에 따라 이미지가 그 안에 맞게 조절되거든요. 예를 들어, 부모 컨테이너가 이미지 intrinsic size보다 작으면, 이미지는 자동으로 축소되어 컨테이너에 맞춰지는 거죠.  \n만약 width와 height가 애초에 알려지지 않았다면, `fill` 속성을 활용할 수도 있어요.\n\n### alt 속성\n\n이미지의 alt 속성은 화면 읽기 기기(screen reader)와 검색 엔진을 위한 설명 역할을 해요. 이미지가 비활성화되어 있거나 로딩 오류가 발생했을 때는 대체 텍스트로 나타나죠.\n\nalt 텍스트는 페이지의 의미를 바꾸지 않고 이미지를 대신할 수 있는 내용을 담아야 합니다.  \n즉, 이미지를 보완하는 용도가 아니라, 이미지 캡션이나 주변 텍스트에서 이미 설명한 내용을 반복하면 안 돼요.  \n\n요즘은 웹 접근성의 중요성이 부각되면서, 올바른 alt 속성 작성이 필수로 권장되고 있어요. 특히 시각장애인들이 사용하는 스크린 리더에서는 이미지가 제공하는 정보를 alt가 대신 전달하기 때문에, 간결하면서도 핵심을 담는 것이 좋답니다.\n\n| 속성              | 설명                                                         |\n|-------------------|--------------------------------------------------------------|\n| width, height     | 이미지의 가로세로 비율 결정, 브라우저가 공간 미리 확보       |\n| intrinsic size    | 실제 이미지 파일의 원본 크기, 부모 컨테이너에 따라 조정됨    |\n| fill              | width, height 미지정 시 공간에 꽉 채우기 위한 옵션           |\n| alt               | 이미지 설명, 스크린 리더와 검색 엔진에 활용되며 대체 텍스트 역할 |\n\n이미지 태그를 작성할 때는 위 내용을 참고해서, 디자인 뿐 아니라 접근성과 SEO까지 한 번에 챙겨보시면 좋아요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이미지가 단순히 장식용이거나\n사용자에게 중요한 정보 전달 목적이 아니라면,\nalt 속성은 빈 문자열로 설정하는 게 좋아요 (alt=\"\").\n\n더 알아보기\n\n## 선택적 속성(Optional Props)\n\n`Image /` 컴포넌트는 필수 속성 외에도 다양한 추가 속성을 지원해요.  \n이번 섹션에서는 가장 자주 쓰이는 속성들을 소개할게요.  \n좀 더 특별하거나 덜 자주 쓰이는 속성들은 '고급 속성(Advanced Props)' 섹션에서 확인할 수 있어요.\n\n---\n\n참고로, alt 속성은 이미지가 로드되지 않을 때 대체 텍스트로 보여주기도 하고, 시각장애인들이 스크린 리더를 사용할 때 이미지 내용을 설명해줘서 접근성 측면에서 매우 중요하답니다.  \n하지만 장식용인 경우에는 오히려 의미 없는 텍스트가 읽히면서 사용자에게 혼란을 줄 수 있으니, 빈 문자열로 두는 게 맞아요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### loader\n\n이미지 URL을 처리할 때 사용하는 커스텀 함수예요.\n\nloader 함수는 이미지에 필요한 URL을 직접 만들어내는데, 함수에 넘겨지는 주요 인자는 다음과 같아요:\n\n- `src`: 이미지 경로 또는 파일명\n- `width`: 이미지 너비 (픽셀 단위)\n- `quality`: 이미지 품질 (보통 압축률이나 화질 조절에 사용)\n\n이걸 기억하면, 원하는 대로 이미지 URL을 동적으로 생성할 수 있답니다! 예를 들어, CDN에서 이미지를 받아올 때 너비나 품질에 맞게 URL을 조합해서 요청할 수 있죠.\n\n추가로, 로더를 직접 만들면 기본 이미지 최적화 방식을 바꾸거나, 외부 이미지 서비스(예: Cloudinary, Imgix 등)를 쓸 때 유용해요. 그런 경우 URL 생성 규칙이 다르니까 loader 함수에서 그에 맞게 처리하면 되죠.\n\n---\n\n만약 간단한 예시가 궁금하다면 이렇게 써볼 수 있어요:\n\n```js\nfunction myLoader({ src, width, quality }) {\n  return `https://mycdn.com/${src}?w=${width}\u0026q=${quality || 75}`;\n}\n```\n\n위처럼 `src`, `width`, `quality`를 받아서 URL을 조합하고, 이 URL을 이미지 컴포넌트에 넘겨주면 돼요.  \n그럼 필요한 크기와 품질에 맞춰서 이미지를 호출하니 네트워크 비용도 아끼고 페이지 속도도 좋아져요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기 커스텀 로더(custom loader)를 사용하는 예제가 있어요:\n\n```js\n'use client'\n\nimport Image from 'next/image'\n\nconst imageLoader = ({ src, width, quality }) =\u003e {\n  return `https://example.com/${src}?w=${width}\u0026q=${quality || 75}`\n}\n\nexport default function Page() {\n  return (\n    \u003cImage\n      loader={imageLoader}\n      src=\"me.png\"\n      alt=\"Picture of the author\"\n      width={500}\n      height={500}\n    /\u003e\n  )\n}\n```\n\n### 핵심 포인트\n- `loader`라는 프로퍼티에 함수 형태로 로더를 넣을 때는 **클라이언트 컴포넌트(Client Components)** 안에서 사용해야 해요. 이유는 Next.js가 이 함수를 직렬화(serialization)해야 하기 때문입니다.\n- 즉, `'use client'` 지시어를 꼭 컴포넌트 상단에 추가해줘야 오류가 안 납니다.\n\n---\n\n### 참고!  \n만약 앱 전역에 걸쳐서 모든 `next/image` 컴포넌트에 대해 같은 커스텀 로더를 쓰고 싶다면, `next.config.js`의 `loaderFile` 옵션을 설정하는 방법도 있어요. 그러면 매번 개별 컴포넌트에서 `loader` prop을 넘겨주지 않아도 되죠. \n\n```js\n// next.config.js\nmodule.exports = {\n  experimental: {\n    images: {\n      loaderFile: './my-custom-loader.js',\n    },\n  },\n}\n```\n\n`my-custom-loader.js`에 로더 함수를 작성해두면 Next.js가 자동으로 이걸 참조합니다.\n\n---\n\n### 커스텀 로더 쓸 때 알아두면 좋은 점\n\n| 내용                        | 설명                                                           |\n|-----------------------------|----------------------------------------------------------------|\n| 로더에서 다루는 인자          | `src`, `width`, `quality` 등 이미지 최적화에 중요한 값들         |\n| 기본 품질 값                 | `quality`가 없으면 75로 기본 세팅되는 경우가 많음                  |\n| 'use client' 필요            | 로더 함수를 컴포넌트 안에서 직접 넘길 땐 클라이언트 컴포넌트여야 함  |\n| 전역 설정 가능               | `loaderFile` 옵션으로 앱 전체에 일괄 적용 가능                    |\n\n---\n\n커스텀 로더는 외부 CDN이나 이미지 서버에서 동적으로 크기 조절, 품질 조절이 가능할 때 특히 유용해요. 이렇게 하면 필요한 사이즈로 딱 맞는 이미지를 받아와서 페이지 로딩 속도를 개선할 수 있답니다. \n\n혹시 이미지 최적화 관련해서 더 궁금한 점 있으면 언제든 질문 주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### fill\n\n```js\nfill={true} // {true} | {false}\n```\n\n`fill`은 이미지가 부모 요소를 꽉 채우도록 하는 불리언 값이에요. 특히, 이미지의 너비와 높이를 미리 지정하기 어려울 때 유용하죠.\n\n단, 이 기능을 제대로 사용하려면 부모 요소에 `position: \"relative\"`, `position: \"fixed\"`, 또는 `position: \"absolute\"` 스타일을 꼭 지정해줘야 해요. 그래야 이미지가 부모 요소 안에서 정확하게 위치하고 크기가 맞춰지니까요.\n\n예를 들어 이렇게 쓸 수 있겠죠:\n\n```jsx\n\u003cdiv style={{ position: 'relative', width: '100%', height: '300px' }}\u003e\n  \u003cImage src=\"/example.jpg\" alt=\"Example\" fill={true} /\u003e\n\u003c/div\u003e\n```\n\n여기서 `div`에 `position: 'relative'`를 줌으로써 이미지가 그 영역을 꽉 채우게 만들 수 있어요.\n\n이 점 꼭 기억하고 활용하면, 반응형 이미지 배치 때 꽤 편리하답니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기본적으로 img 태그에는 position: \"absolute\" 스타일이 자동으로 적용돼요.\n\n만약 이미지에 별도의 스타일이 지정되지 않았다면, 이미지는 컨테이너 크기에 맞춰 늘어나게 돼요. 그런데 이럴 때 이미지가 찌그러지거나 비율이 이상해질 수 있죠. 그래서 보통은 object-fit: \"contain\" 스타일을 주는 게 좋아요. 이걸 주면 이미지가 컨테이너 안에 딱 맞게 맞춰지고, 빈 공간이 있을 때는 레터박스(검은 여백)가 생기면서 원본 비율을 유지해 줍니다.\n\n반대로 object-fit: \"cover\"를 사용하면 이미지가 컨테이너를 꽉 채우도록 잘리면서 보여줘요. 원본 비율은 지키지만, 이미지 일부가 잘릴 수 있다는 점 명심하세요.\n\n이렇게 object-fit을 적절히 활용하면 웹에서 이미지가 깨지거나 비율이 이상해지는 걸 방지할 수 있어요. 특히 반응형 웹이나 다양한 크기의 컨테이너에 이미지를 넣을 때 꼭 알아두면 좋은 CSS 속성이죠.\n\n| 속성        | 설명                                         |\n|-------------|----------------------------------------------|\n| position    | 이미지 위치 지정, 기본값은 \"absolute\"        |\n| object-fit  | 이미지의 컨테이너 내 맞춤 방식 지정          |\n| contain     | 이미지 비율 유지하며 컨테이너 안에 모두 보여줌 |\n| cover       | 비율 유지하며 컨테이너를 완전히 덮되 일부 잘림 |\n\n더 자세한 내용은 CSS의 object-fit 관련 문서를 참고하면 도움이 될 거예요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n오늘은 웹 개발할 때 이미지 다룰 때 꼭 알아두면 좋은 CSS 속성 몇 가지와 함께, 특히 `sizes` 속성에 대해 이야기해볼게요. 이미지 로딩 성능과 반응형 디자인에 큰 영향을 주기 때문에 이해하면 꽤 유용하답니다.\n\n---\n\n### position, object-fit, object-position 간단 정리\n\n- **position**  \n  이미지나 요소의 위치를 설정할 때 쓰이는 CSS 속성이죠. 예를 들어, `relative`, `absolute` 같은 값을 줘요. 이미지가 컨테이너 내에서 어떻게 배치될지 결정할 때 많이 씁니다.\n\n- **object-fit**  \n  이미지를 컨테이너 크기에 맞게 어떻게 맞출지 정하는 속성이에요. 대표값으로는 `cover` (이미지 꽉 채우기, 잘릴 수 있음), `contain` (이미지 전체 보이도록 축소/확대), `fill` (비율 무시하고 꽉 채움), `none` (원본 크기 유지) 등이 있어요.\n\n- **object-position**  \n  `object-fit`이 `cover`나 `contain`일 때, 이미지가 컨테이너 안에서 어디에 위치할지 정하는 속성이에요. 기본값은 `center center`죠. 간단히 `top left`, `bottom right` 등으로 조절할 수 있어요.\n\n이 세 가지 조합하면, 이미지가 반응형일 때 원하는 방식으로 나타나게 할 수 있어요!\n\n---\n\n### sizes 속성 이해하기 (이미지 로딩 최적화에 핵심!)\n\n`\u003cimg\u003e` 태그에서 특히 `\u003csource\u003e`와 함께 쓰면서 '지금 이 화면 사이즈에서 이미지가 실제로 얼마나 크게 보여질지' 브라우저에 알려주는 역할을 해요. 사실, 브라우저가 이미지 크기를 미리 알고 있으면, 가장 적합한 크기의 이미지를 요청할 수 있어 성능이 팍 좋아집니다.\n\n#### sizes 정의 방식\n\n- 문자열 형태로 쓰고, CSS 미디어 쿼리랑 비슷해요.\n- 화면 너비 기준으로 '어떤 상황에 이미지가 몇 픽셀 너비만큼 보여질지'를 지정해줘요.\n- 여러 조건을 콤마(,)로 구분해 순서대로 해석합니다.\n\n예를 들어,\n\n```css\nsizes=\"(max-width: 600px) 480px, 800px\"\n```\n\n이렇게 하면, 화면 너비가 600px 이하일 땐 이미지가 480px 크기로 보여지고, 그 이상일 땐 800px 크기로 보여질 거란 걸 알려주는 거죠.\n\n#### sizes가 중요한 이유\n\n- `fill` 또는 반응형 크기를 가진 이미지를 사용할 때 특히 효과적입니다.\n- 화면 크기에 맞춘 적절한 이미지 해상도를 요청해 불필요한 데이터 낭비를 줄여줍니다.\n- 결국, 로딩 속도 개선과 데이터 절약으로 이어지니 모바일 환경에선 필수!\n\n---\n\n### 간단 요약 테이블\n\n| 속성           | 설명                                       | 대표값 및 의미                          |\n|----------------|------------------------------------------|---------------------------------------|\n| position       | 요소의 위치 설정                         | relative, absolute 등                 |\n| object-fit     | 이미지가 컨테이너 내에서 크기 조절 방법 | cover, contain, fill, none            |\n| object-position| 이미지 내부에서 위치 지정                | center center (기본), top left 등     |\n| sizes          | 여러 화면 크기에 맞춘 이미지 출력 크기 안내 | (media query) 크기, 최종 이미지 너비 |\n\n---\n\n### 마무리 팁\n\n- **`sizes`가 없으면?**  \n  브라우저는 디폴트로 전체 이미지 크기를 사용하거나 해상도에 맞춘 이미지를 선택 못해, 큰 이미지 불필요하게 다운받을 수 있어요.\n\n- **`srcset`과 함께 쓰기!**  \n  `sizes`는 주로 `srcset`과 같이 써서 여러 해상도 이미지를 상황에 맞게 불러오도록 해요.\n\n- **반응형 이미지 사용시 필수!**  \n  화면 크기별로 이미지를 다르게 하고 싶으면, `sizes`에 익숙해지는 게 좋습니다.\n\n---\n\n이미지를 효율적으로 다루는 건 작은 것 같지만 웹 페이지 속도와 사용자 경험에 큰 차이를 만듭니다. `position`, `object-fit`, `object-position`으로 디자인을 잡고, `sizes`로 똑똑하게 이미지 로딩 관리해보세요! 앞으로도 계속 실용적인 웹 테크닉 알려드릴게요. 궁금한 점 있으면 댓글 남겨주세요~ 😊\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nnext/image의 sizes 속성, 제대로 이해하고 있나요?  \n이미지를 좀 더 똑똑하게 불러오고 싶다면 sizes 속성만큼 중요한 것도 없어요. 이번 글에서는 sizes가 왜 필요한지, 그리고 어떻게 활용하면 좋은지 쉽게 풀어볼게요.\n\n---\n\n### 1. sizes는 \"얼마나 크게 이미지를 보여줄 건지\" 알려주는 역할이에요.\n브라우저는 `\u003cImage\u003e` 컴포넌트에 자동으로 만들어지는 srcset(다양한 크기의 이미지 묶음)을 보고 어떤 이미지를 다운받을지 결정하는데요. 이때 sizes 속성 값이 중요한 역할을 해요.\n\n- sizes가 없다면?  \n  기본값인 `100vw`(화면 가로 너비 100%)로 인식해서, **화면 크기만큼 큰 이미지를 다운받아요**.  \n  즉, 모바일 화면이라도 큰 데스크톱용 이미지를 받을 수도 있다는 뜻이죠. 낭비 그 자체...!\n\n- sizes가 있으면?  \n  화면 크기나 레이아웃에 맞는 이미지를 미리 알려서, 그에 적합한 크기의 이미지를 똑똑하게 골라 다운받을 수 있어요.\n\n---\n\n### 2. sizes는 srcset을 어떻게 만들어내느냐에도 영향을 줘요.\n자동 생성되는 srcset이 크게 두 가지로 나뉘는데요.\n\n- sizes가 없을 때는, 고정 크기 이미지용으로 작은 srcset이 만들어져요 (예: 1x, 2x...)  \n- sizes가 있으면, 반응형 이미지를 위한 큰 srcset이 생성돼요(예: 640w, 750w 같은 픽셀 너비 단위)\n\n특히 sizes에 `50vw`처럼 뷰포트의 % 단위가 들어가면, 불필요하게 작은 이미지 옵션들이 걸러져서 srcset이 간결해지고, 진짜 필요한 이미지들만 주로 다운받게 되죠.\n\n---\n\n### 실제 사례로 살펴볼게요!\n\n```js\nimport Image from 'next/image'\n\nexport default function Page() {\n  return (\n    \u003cdiv className=\"grid-element\"\u003e\n      \u003cImage\n        fill\n        src=\"/example.png\"\n        sizes=\"(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw\"\n      /\u003e\n    \u003c/div\u003e\n  )\n}\n```\n\n- 화면이 최대 768px이면? 이미지가 화면 최대 너비(`100vw`)로 보여져요 - 주로 모바일용  \n- 768px 초과, 1200px 이하 화면이면? 이미지가 화면 너비의 절반(`50vw`)  \n- 1200px 초과면? 이미지가 화면 너비의 33%(`33vw`)만 차지한다는 의미\n\n---\n\n### sizes의 위력: 성능에 미치는 영향\n\n만약 `sizes`를 위 예시처럼 적절히 지정하지 않으면, 특히 데스크톱에서 **실제로 1/3 크기만 필요한 이미지를 3배 크기(가로 기준) 이미지로 다운받게 되겠죠**?  \n이미지 파일 크기는 가로 * 세로이기 때문에, 파일 크기는 대략 가로 크기의 제곱에 비례해요.  \n즉, 3배 큰 이미지를 받으면, 용량은 9배가 될 수 있다는 말입니다!\n\n---\n\n### 정리!\n\n| 포인트 | 설명 |\n|--------|-------|\n| sizes의 역할 | 이미지가 실제로 렌더링될 크기를 브라우저에 알려서 적합한 이미지 선택 유도 |\n| sizes 없을 때 | 기본 `100vw`로 간주, 무조건 화면 가로폭만큼 큰 이미지 다운 |\n| sizes가 있으면 | 반응형 srcset 선택 가능, 불필요한 큰 이미지 다운로드 억제 |\n| 권장 활용 | 뷰포트 크기별 예상 이미지 크기를 sizes에 정의해두기 |\n\n---\n\n### 추가 팁!\n\n- `fill` 속성을 사용할 때는 특히 sizes 설정 꼭 해주세요.  \n  그 이유는 fill일 때 이미지가 부모 요소에 맞춰 꽉 채워지는데, sizes가 없으면 무조건 화면 가로 크기로 판단하기 때문이에요.\n\n- 복잡한 레이아웃 환경이라면, media query 같은 복수 조건으로 sizes를 꼭 세분화해서 지정하는 습관을!\n\n---\n\n이처럼 sizes가 제한적으로 보이지만, 성능 최적화에 있어선 꽤나 강력한 역할을 해요.  \n앞으로 next/image 쓸 때는 **sizes 설정 잊지 말고 성능도 챙기는 스마트한 개발자**가 되어봅시다!  \n궁금한 점 있으면 댓글로 알려주세요~\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nsrcset과 sizes 속성에 대해 조금 더 재미있게 파헤쳐보도록 할게요!\n\n---\n\n## srcset과 sizes: 이미지 최적화를 위한 든든한 친구들\n\n웹에서 이미지가 너무 크거나 작게 나오면 사용자 경험이 떨어지잖아요? 그래서 요즘은 반응형 이미지를 쉽게 구현할 수 있도록 srcset과 sizes라는 속성을 많이 사용해요.\n\n### srcset이란?\n\n이미지를 다양한 크기로 준비해두고, 브라우저가 화면 크기나 해상도에 맞게 적절한 이미지를 골라서 보여주도록 해주는 역할이에요.\n\n예를 들어:\n\n```html\n\u003cimg \n  src=\"small.jpg\" \n  srcset=\"small.jpg 500w, medium.jpg 1000w, large.jpg 1500w\" \n  alt=\"예쁜 고양이\" \n/\u003e\n```\n\n위에서 500w, 1000w, 1500w는 각각 이미지의 가로 너비(pixel) 크기를 의미해요. 브라우저가 화면에 맞게 적절한 이미지를 골라서 내려받겠죠.\n\n### sizes란?\n\nsizes는 브라우저에게 \"내 이미지는 이렇게 크기로 보여질 거야\"라고 미리 알려주는 역할을 해요. 예를 들어, 내가 이미지가 보통 뷰포트의 50% 정도 차지한다면 그에 맞게 알려주면 크기를 더 정확하게 고를 수 있습니다.\n\n```html\n\u003cimg\n  src=\"small.jpg\"\n  srcset=\"small.jpg 500w, medium.jpg 1000w, large.jpg 1500w\"\n  sizes=\"(max-width: 600px) 100vw, 50vw\"\n  alt=\"예쁜 강아지\"\n/\u003e\n```\n\n- `(max-width: 600px) 100vw`: 뷰포트가 600px 이하일 때는 이미지가 화면 너비 전체(100vw)를 차지한다는 뜻이에요.\n- `50vw`: 그 외에는 화면 너비의 50%만 쓰인다는 뜻이에요.\n\n### quality 속성도 알아두자!\n\n위에서 언급된 quality는 이미지 처리 라이브러리(예: Next.js 이미지 컴포넌트)에서 이미지를 압축할 때 몇 퍼센트 품질로 줄일 건지를 나타내요. 1~100까지 숫자를 받는데, 너무 낮으면 이미지가 뭉개지고, 너무 높으면 용량도 커져서 로딩이 느려져요. 보통 70~80 수준에서 적절히 타협하는 편입니다.\n\n```js\nquality={75} // 적당한 화질과 용량의 밸런스를 잡을 수 있어요\n```\n\n---\n\n### 참고하면 좋은 사이트\n\n- [web.dev의 srcset 설명](https://web.dev/learn/design/responsive-images/)\n- [MDN 이미지 반응형 가이드](https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images)\n\n---\n\n이제부터 이미지 태그 예쁘게 짜서 웹사이트 속도도 챙기고 사용자 경험도 쏙쏙 높여보아요!  \n궁금한 점 있으면 언제든 댓글로 물어봐 주세요~\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이미지 최적화에서 quality(품질) 값은 1부터 100 사이의 정수로 설정할 수 있는데요, 100이 가장 높은 품질이자 가장 큰 파일 크기를 의미합니다. 기본값은 75로 설정되어 있어요.\n\n만약 next.config.js 파일에서 qualities 설정을 따로 정의해뒀다면, quality 속성 값은 그 중 하나와 꼭 일치해야 한다는 점 기억하세요.\n\n\u003e 참고할 내용: 원본 이미지가 이미 저품질이라면, quality 값을 너무 높게 설정할 경우 최적화된 이미지가 오히려 원본 파일보다 용량이 더 커질 수 있으니 주의가 필요합니다.\n\n---\n\n### priority (우선순위)\n\n여기서 priority는 Next.js에서 이미지 로딩 시, 어느 이미지를 더 빨리 불러올지 우선순위를 정하는 속성입니다. 예를 들어, 페이지 상단에 보이는 히어로 이미지 같은 경우 priority를 true로 설정하면, 브라우저가 페이지 렌더링 시 해당 이미지를 더 빨리 불러오게 됩니다.\n\n속성을 간단히 정리하면:\n\n| 속성명   | 설명                                    |\n|---------|----------------------------------------|\n| priority | true로 설정하면 해당 이미지에 우선순위를 줘 빠르게 로드 |\n\n적절하게 priority를 설정하면 사용자 경험이 한층 더 좋아질 수 있으니, 중요한 이미지는 꼭 체크해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\npriority={false} // {false} | {true}\n```\n\n이 옵션이 `true`일 때, Next.js는 해당 이미지를 미리(preload) 불러옵니다. 즉, 이미지가 더 빨리 로드되도록 하는 기능이죠. **중요한 점은, priority가 true일 경우 lazy loading(지연 로딩)이 자동으로 비활성화된다는 것**입니다. 만약 `loading` 속성을 사용하면서 `lazy`로 설정하면 `priority`와 함께 쓸 수 없어요. 그래서 priority가 필요한 이미지에서는 `loading` 속성을 제거하는 게 좋습니다.\n\n이 속성은 **Largest Contentful Paint(LCP)** 요소로 감지되는 이미지에 주로 사용해야 합니다. LCP란 페이지 로드 시 사용자에게 가장 크게 보이는 콘텐츠를 의미하는데, 이미지가 이 역할을 한다면 빠르게 불러오는 것이 UX 개선에 도움이 되거든요.\n\n뷰포트 크기에 따라 LCP 요소가 달라질 수 있어서, 여러 개의 이미지를 priority로 설정하는 것도 괜찮습니다. 다만, 이 속성은 화면 상단(above the fold)에 보이는 이미지에만 사용하는 게 효과적입니다. 기본값은 `false`로 설정돼 있어요.\n\n---\n\n### 추가 팁!\n\n- **priority 이미지가 너무 많으면 어떻게 될까요?**  \n  너무 많은 이미지를 미리 불러오면 네트워크에 부담이 갈 수 있으니, 정말 필요한 이미지만 우선순위를 주는 게 좋아요.\n\n- **Next.js의 `Image` 컴포넌트와 함께 사용**  \n  Next.js의 `\u003cImage /\u003e` 컴포넌트에서 이 옵션을 쓰면 자동으로 적절한 최적화도 같이 해줘서, 별도로 신경 쓰지 않아도 됩니다.\n\n- **LCP 개선은 SEO에도 좋아요!**  \n  페이지 로딩 속도와 사용자 경험 개선은 검색 엔진 최적화(SEO)에도 긍정적인 영향을 주니, 중요한 이미지에는 꼭 priority를 고려해보세요.\n\n---\n\n우리 웹 페이지가 빠르게 렌더링되고, 사용자들이 이미지 때문에 답답해하지 않게 하는 작은 팁 하나였어요! 다음 번에도 더 유용한 개발 꿀팁 가지고 올게요 :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### placeholder\n\n```js\nplaceholder = 'empty' // \"empty\" | \"blur\" | \"data:image/...\"\n```\n\n이미지가 로딩되는 동안 보여줄 자리 표시자(플레이스홀더)를 설정하는 속성입니다. 사용할 수 있는 값은 `'empty'`, `'blur'`, 또는 `'data:image/...'` 형태입니다. 기본값은 `'empty'`입니다.\n\n- `'empty'`: 아무 것도 표시하지 않고 그냥 빈 공간으로 둡니다.\n- `'blur'`: 이미지가 로딩되는 동안 블러 처리된 저해상도 이미지를 보여줍니다. 이때 `blurDataURL` 속성에 지정된 데이터 URL이 플레이스홀더로 사용돼요.\n- `'data:image/...'`: 직접 데이터 URL 형태의 이미지를 넣어서 커스텀 플레이스홀더를 설정할 수도 있습니다.\n\n특히, `blur` 옵션은 정적 임포트(static import)로 불러온 `.jpg`, `.png`, `.webp`, `.avif` 같은 이미지 포맷의 경우 자동으로 `blurDataURL`이 채워지는데, 만약 애니메이션 이미지라면 이 기능이 적용되지 않습니다.\n\n이 기능 덕분에 이미지가 화면에 깜빡이거나 완전히 로드될 때까지 기다리지 않고, 자연스러운 흐릿한 미리보기를 보여줘서 UX가 훨씬 부드러워진답니다. 요즘 웹사이트에서 흔히 볼 수 있는 '더 좋은 사용자 경험'을 위한 작은 팁이죠!\n\n추가로, **blurDataURL**은 보통 아주 작은 크기의 저해상도 이미지 정보를 base64로 인코딩한 문자열을 의미해요. 직접 생성하기 번거롭다면 자동 생성 도구나 라이브러리를 활용하는 것도 방법입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n동적 이미지(dynamic images)를 사용할 때는 반드시 `blurDataURL` 속성을 제공해줘야 해요. 이 속성은 이미지가 로딩되는 동안 보여줄 흐릿한(blurred) 이미지 데이터를 뜻하는데요, 이걸 넣어주면 사용자가 이미지가 완전히 로딩될 때까지 깜빡임 없이 부드러운 경험을 할 수 있답니다.\n\n그런데 이 `blurDataURL` 값을 직접 만들기 번거로울 수 있죠? 그래서 Plaiceholder 같은 솔루션이 인기를 끌고 있어요. Plaiceholder는 이미지를 자동으로 Base64 포맷으로 변환해서 흐릿한 이미지로 만들어주니까, 요긴하게 쓸 수 있어요.\n\n그리고 만약 이미지 URL이 `data:image/...` 형식이라면, 이 데이터 URL이 그대로 로딩 중인 플레이스홀더(placeholder)로 사용돼요. 반면에 `blurDataURL`을 비워두면 로딩 중에 아무 것도 보이지 않고 빈 공간만 남게 되니 주의해야 해요.\n\n쉽게 말해 이런 느낌이에요:\n\n| `blurDataURL` 상태           | 결과                          |\n|-----------------------------|-------------------------------|\n| 값이 세팅된 경우             | 로딩 중 흐릿한 이미지 표시    |\n| `data:image/...` 포맷       | 해당 데이터가 로딩 플레이스홀더로 사용됨 |\n| 비워둔 경우(빈값)           | 로딩 중 빈 공간               |\n\n직접 써보면서 확인해보세요. 이미지의 로딩 경험이 훨씬 부드러워질 거예요! 혹시 더 자세한 설정 방법이나 Plaiceholder 사용법이 궁금하면 알려주세요~\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 블러(blur) 플레이스홀더 데모  \n- 데이터 URL을 이용한 플레이스홀더 프로퍼티로 쉐이머(shimmer) 효과 데모  \n- blurDataURL 프로퍼티를 활용한 컬러 효과 데모  \n\n## 고급 속성 사용법\n\n때로는 더 복잡한 사용이 필요할 때가 있죠. `Image /` 컴포넌트는 선택적으로 아래와 같은 고급 속성들을 받을 수 있습니다.\n\n### style (스타일)\n\n여기서 스타일을 지정해서 이미지에 다양한 시각적 효과를 줄 수 있어요. 예를 들어, 이미지 모서리를 둥글게 하거나, 그림자를 넣는 등 CSS를 직접 적용할 수 있답니다.\n\n이런 고급 props들을 잘 활용하면 더 세련되고 사용자 친화적인 이미지 로딩 경험을 만들 수 있어요!  \n\n필요하면 다음에 `blurDataURL`이나 쉐이머 효과 만들 때 사용하는 데이터 URL 생성 방법도 같이 소개할게요.  \n편하게 알려드릴 테니 기대해 주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이미지에 CSS 스타일을 직접 전달할 수 있어요.\n\n```js\nconst imageStyle = {\n  borderRadius: '50%',\n  border: '1px solid #fff',\n}\n \nexport default function ProfileImage() {\n  return \u003cImage src=\"...\" style={imageStyle} /\u003e\n}\n```\n\n여기서 중요한 점! 이미지의 `width`와 `height` 속성은 스타일링에 영향을 줄 수 있어요. 만약 CSS 스타일로 이미지의 너비를 조절한다면, 높이는 `auto`로 설정해줘야 원래 비율을 유지할 수 있습니다. 안 그러면 이미지가 찌그러져 보일 수 있거든요.\n\n예를 들면 이렇게 하면 좋아요:\n\n```js\nconst imageStyle = {\n  width: '100px',\n  height: 'auto',\n  borderRadius: '50%',\n  border: '1px solid #fff',\n}\n```\n\n이렇게 하면 너비는 100px로 고정하고, 높이는 자동으로 조절되어 이미지 비율이 깨지지 않죠.\n\n---\n\n### onLoadingComplete\n\n`onLoadingComplete`는 이미지가 모두 로드된 후에 실행되는 콜백 함수입니다. 이미지 처리나 로딩 상태 관리를 할 때 유용해요.\n\n예를 들어, 이미지가 로드 완료되면 어떤 작업을 하고 싶을 때 이렇게 쓸 수 있어요:\n\n```js\nexport default function ProfileImage() {\n  const handleLoadingComplete = () =\u003e {\n    console.log('이미지가 성공적으로 로드되었습니다!');\n    // 여기서 로딩 스피너 숨기기 등 다른 작업을 할 수 있겠죠\n  }\n\n  return \u003cImage src=\"...\" onLoadingComplete={handleLoadingComplete} /\u003e\n}\n```\n\n이 콜백 함수를 활용해서 사용자 경험을 좀 더 부드럽게 만들 수 있어요. 예를 들어 이미지가 로드 중일 때 스피너를 표시하고, 완료되면 스피너를 숨기는 식으로요.\n\n이 부분도 꼭 기억해두세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안녕하세요, 여러분! 오늘은 Next.js 14에서 Image 컴포넌트의 새로운 변화에 대해 짧게 이야기해보려고 해요.\n\n기존에 아래처럼 `onLoadingComplete`를 썼던 분들 많으시죠?\n\n```js\n'use client'\n\n\u003cImage onLoadingComplete={(img) =\u003e console.log(img.naturalWidth)} /\u003e\n```\n\n그런데 Next.js 14부터는 이 `onLoadingComplete`가 deprecated(더 이상 권장되지 않음) 되었어요. 대신 `onLoad`라는 새로운 콜백 함수가 도입됐답니다.\n\n### 그럼 뭐가 달라졌을까요?\n\n- **`onLoad`** 콜백은 이미지가 완전히 로드되고, 플레이스홀더(placeholder)가 제거된 후에 호출돼요.\n- 이 함수는 실제 `\u003cimg\u003e` 요소를 인자로 받아요. 그래서 이미지의 크기 정보나 기타 속성을 쉽게 가져올 수 있죠.\n\n### 바뀐 사용법은 이렇게!\n\n```js\n'use client'\n\nimport Image from 'next/image';\n\n\u003cImage\n  src=\"/example.jpg\"\n  width={500}\n  height={300}\n  onLoad={(img) =\u003e console.log('Image width:', img.naturalWidth)}\n/\u003e\n```\n\n### 참고!\n- `onLoad` 안에서 받는 인자는 실제 HTML의 `\u003cimg\u003e` 엘리먼트이므로, `naturalWidth`, `naturalHeight`, `currentSrc` 같은 DOM 속성에 접근 가능해요.\n- 이전과 달리 `onLoadingComplete`는 더 이상 공식 문서에서 지원하지 않으니, 꼭 `onLoad`로 바꾸시는 걸 추천드려요.\n\n---\n\n사실 이런 변화는 Next.js가 내부에서 이미지 로딩 과정을 더 효율적이고 통제하기 쉽게 만들기 위한 거라 생각하면 좋아요. 새로운 버전 나오면 공식 문서 체크와 함께 이렇게 바뀐 부분도 챙겨주면 프로젝트 유지보수가 훨씬 편하답니다.\n\n혹시 이미지 로딩과 관련해서 더 궁금한 점 있으면 댓글로 알려주세요! 그럼 즐거운 개발 되세요~ 😊\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003e 참고할 점: onLoadingComplete 같은 함수 형태의 props를 사용할 때는, 전달한 함수를 직렬화하기 위해 클라이언트 컴포넌트를 사용해야 한다는 점을 기억하세요.\n\n### onLoad\n\n```js\n\u003cImage onLoad={(e) =\u003e console.log(e.target.naturalWidth)} /\u003e\n```\n\n이미지가 완전히 로드되고 플레이스홀더가 사라진 후에 실행되는 콜백 함수입니다.\n\n---\n\n여기에 덧붙여서, onLoad 이벤트는 이미지가 화면에 렌더링 되는 순간을 알 수 있어서, 예를 들어 이미지 크기에 따라 레이아웃을 조절하거나 로딩 상태를 업데이트 하는 데 쓸 수 있어요. 또한, 네트워크 상황이 느릴 때 사용자에게 로딩 완료 시점을 알려주는 용도로도 활용할 수 있답니다.\n\n하지만 Next.js의 Image 컴포넌트를 사용할 때는 내장된 최적화 특징 때문에, \"onLoadingComplete\"라는 비슷한 이벤트도 함께 제공되니 필요에 따라 적절히 선택해서 사용하세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n콜백 함수는 이벤트 객체 하나를 인자로 받게 되는데, 여기서 이벤트의 `target`은 실제로 렌더된 `img` 요소를 가리키게 돼요.\n\n\u003e 참고할 점: onLoad처럼 함수 형태의 prop을 사용할 때는, 이 함수를 직렬화하기 위해 클라이언트 컴포넌트(Client Components)를 사용해야 해요.\n\n### onError\n\n```jsx\n\u003cImage onError={(e) =\u003e console.error(e.target.id)} /\u003e\n```\n\n`onError`는 이미지 로드에 문제가 생겼을 때 호출되는 콜백 함수예요. 예를 들면, 이미지 URL이 잘못됐거나 서버에서 이미지를 불러올 수 없을 때 이 함수가 실행되죠. 위 코드에서는 에러가 발생한 이미지 엘리먼트의 id 값을 콘솔에 출력하고 있네요.\n\n참고로, 이런 이벤트 핸들러를 사용할 땐 해당 컴포넌트가 클라이언트에서 동작하도록 설정돼 있어야 한다는 점 기억하세요. 특히 Next.js 같은 프레임워크에서는 서버 컴포넌트와 클라이언트 컴포넌트가 구분되어 있어서, 함수가 전달되는 이벤트 핸들러는 클라이언트 컴포넌트에서만 제대로 동작합니다.  \n\n혹시 이미지 로드 실패 시 사용자에게 다른 이미지를 보여주거나, 오류 메시지를 띄우고 싶다면 `onError` 안에서 상태를 변경하거나 별도의 로직을 구현하면 돼요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이미지 로딩에 실패했을 때 호출되는 콜백 함수에 대해 이야기해볼게요.\n\n---\n\n### onError\n\n이미지 로딩 중 문제가 발생하면 실행되는 함수예요. 예를 들어, 이미지 URL이 잘못되었거나, 서버에 이미지가 없을 때 호출할 수 있죠.\n\n\u003e 참고로 알아두면 좋은 점!  \n\u003e `onError` 같은 콜백 함수를 프로퍼티로 넘기려면, 이 함수를 직렬화(serialization)할 수 있는 **클라이언트 컴포넌트(Client Components)** 안에서 사용해야 해요. 즉, 서버 컴포넌트에서 바로 함수 형태로 넘기면 동작하지 않을 수 있다는 뜻입니다.\n\n---\n\n### loading 속성\n\n```js\nloading = 'lazy' // 'lazy' 또는 'eager' 중 선택 가능\n```\n\n- `lazy` (지연 로딩): 이미지를 사용자가 실제로 볼 때까지 미뤄서 로딩해요. 페이지 초기 로딩 속도 향상에 도움을 줍니다.\n- `eager` (즉시 로딩): 페이지가 로드될 때 이미지를 바로 불러와요. 빠른 렌더링이 필요할 때 쓰면 좋아요.\n\n---\n\n요즘 웹에서는 지연 로딩이 기본 트렌드인데요, 특히 이미지를 많이 쓰는 페이지는 `loading='lazy'`를 적용하는 게 퍼포먼스 향상에 크게 이바지한답니다.\n\n간단한 예제도 같이 볼까요?\n\n```jsx\nimport { useState } from 'react';\n\nfunction ImageWithFallback({ src, alt }) {\n  const [error, setError] = useState(false);\n\n  return (\n    \u003c\u003e\n      {!error ? (\n        \u003cimg\n          src={src}\n          alt={alt}\n          loading=\"lazy\"\n          onError={() =\u003e setError(true)}\n        /\u003e\n      ) : (\n        \u003cdiv\u003e이미지를 불러올 수 없습니다.\u003c/div\u003e\n      )}\n    \u003c/\u003e\n  );\n}\n```\n\n이렇게 하면 이미지가 실패할 때 텍스트로 대체 표시도 할 수 있죠.\n\n---\n\n필요에 따라서 `onError`를 활용해 이미지 교체, 오류 기록, 사용자 알림 등 다양한 작업을 할 수 있으니 기억해두세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이미지 로딩 동작에 대해 이야기해볼게요. 기본값은 `lazy`인데요, 쉽게 말해 이미지는 화면에 보이기 직전에야 로드되도록 지연시켜서 페이지 로딩 속도를 높여주는 거예요.\n\n- `lazy`: 이미지가 화면에 가까워질 때까지 로딩을 미뤄요. 예를 들어, 사용자가 스크롤을 내려서 이미지가 보일 타이밍에 이미지를 불러오는 방식이죠. 데이터 소모도 줄이고 페이지가 훨씬 빨리 뜹니다.\n- `eager`: 이미지가 페이지가 로드될 때 바로 불러와요. 중요한 이미지나 빠르게 보여줘야 할 때 유용하답니다.\n\n이 `loading` 속성 덕분에 개발자들이 웹사이트 성능을 최적화하기가 한결 쉬워졌어요. 자세한 내용을 더 보고 싶다면 [loading attribute에 대해 알아보기](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#loading)에서 확인할 수 있어요.\n\n참고로, `lazy` 로딩은 모든 브라우저가 지원하는 건 아니라서 필요에 따라 자바스크립트로 폴리필을 적용하는 경우도 있어요. 또한, 이미지가 중요한 정보라면 `eager`를 선택하는 게 사용자 경험에 더 좋을 수 있으니 상황에 맞게 잘 활용해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### blurDataURL\n\nblurDataURL은 이미지가 로드되기 전에 임시로 보여줄 작은 이미지를 Base64 형태로 지정할 때 사용해요. 쉽게 말해서, 실제 이미지가 로딩되기 전 잠깐 나타나는 ‘흐릿한 미리보기’ 같은 역할이죠. \n\n주의할 점은 이 값이 반영되려면 꼭 placeholder=\"blur\"와 함께 써야 한다는 거예요! \n\n또, blurDataURL에 넣는 이미지는 아주 작고 간단한 게 좋아요. 보통 10px 이하 크기의 이미지가 적당한데요, 그 이유는 이 이미지가 화면에 확대되고 흐려지면서 보여지기 때문이에요. 너무 큰 이미지를 넣으면 앱 성능에 안 좋을 수 있거든요.\n\n예를 들어 마크다운으로 표현하면 이렇게 써볼 수 있어요:\n\n| 속성명        | 설명                                                             |\n|---------------|----------------------------------------------------------------|\n| blurDataURL   | 로드 전에 쓰이는 미리보기 이미지의 Base64 인코딩 데이터            |\n| placeholder   | `'blur'`으로 설정해서 blurDataURL과 함께 사용해야 효과를 볼 수 있음 |\n\n이걸 활용하면 사용자 경험이 조금 더 매끄러워져서, 이미지가 늦게 뜰 때도 갑자기 빈 화면이 나오는 걸 방지할 수 있어요. 웹이나 앱에서 이미지가 무거워 딜레이가 있을 때 정말 유용하답니다.\n\n직접 써보는 것도 추천해요! 예를 들어, Next.js의 Image 컴포넌트에서 자주 쓰이는 기능이라, 관심 있으면 찾아보시면 도움이 많이 될 겁니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 기본 blurDataURL prop 사용법 데모  \n- blurDataURL prop를 이용한 색상 효과 데모\n\n이미지와 어울리는 단색 색상 Data URL도 생성할 수 있어요.\n\n### unoptimized 옵션\n\n```js\nunoptimized = {false} // false 또는 true 값 사용 가능\n```\n\n---\n\n조금 더 설명을 덧붙이자면, `blurDataURL`은 이미지가 로딩되기 전까지 잠깐 보여줄 작은 저해상도 이미지의 URL이에요. 흔히 ‘로딩 플레이스홀더’로 활용하죠. 특히 네트워크 속도가 느릴 때 사용자에게 부드러운 경험을 선사할 수 있어요.\n\n`unoptimized` 옵션은 Next.js에서 이미지 최적화를 끌지 말지를 결정하는 건데요. 기본값은 `false`로 최적화 기능을 켜둔 상태고, `true`로 설정하면 최적화를 끄고 원본 이미지를 그대로 사용하게 돼요. 개발 과정에서 최적화 문제를 피하거나 특정 상황에서 이미지를 그대로 사용하고 싶을 때 유용합니다.\n\n그리고 색상 효과를 내는 blurDataURL도 많이 활용되는데요, 실제 이미지와 비슷한 톤의 단색을 blurDataURL로 만들어 놓으면 로딩 시 배경색처럼 자연스럽게 보일 수 있어요. 이 방법은 이미지가 로딩되는 동안 사용자 시각 경험을 더 좋게 만들어주니까 개발할 때 한 번쯤 적용해 보는 걸 추천드려요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n원본 이미지를 `src`에서 그대로 내보내고 싶을 때, 즉 퀄리티나 크기, 포맷을 변경하지 않을 때는 `unoptimized` 속성을 `true`로 설정하면 됩니다. 기본값은 `false`입니다.\n\n이렇게 하는 게 특히 좋은 경우는 최적화를 해도 큰 이점이 없는 이미지들이에요. 예를 들어, 아주 작은 이미지(1KB 이하), 벡터 이미지(SVG), 또는 움직이는 이미지(GIF) 등이 그 예입니다.\n\n아래는 간단한 사용 예시입니다:\n\n```js\nimport Image from 'next/image'\n\nconst UnoptimizedImage = (props) =\u003e {\n  return \u003cImage {...props} unoptimized /\u003e\n}\n```\n\n그리고 Next.js 12.3.0부터는 모든 이미지에 대해 `unoptimized` 옵션을 기본으로 적용하려면 `next.config.js` 파일에 다음과 같은 설정을 추가하면 됩니다:\n\n```js\n// next.config.js\nmodule.exports = {\n  images: {\n    unoptimized: true,\n  },\n}\n```\n\n이렇게 설정하면 개별 이미지마다 `unoptimized` 속성을 일일이 지정하지 않아도 되니 관리가 훨씬 편해져요.\n\n추가로, 최적화를 비활성화하면 이미지가 CDN이나 외부 최적화 서비스 없이 그대로 제공되므로, 속도나 용량 활용 측면에서 체크가 필요합니다. 그래서 보통은 작은 이미지나 이미 최적화된 SVG, GIF에만 적용하는 것을 추천드려요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여러분, Next.js에서 이미지 최적화 관련 설정해보셨나요? 오늘은 간단하게 `next.config.js`에서 이미지 최적화를 비활성화하는 법과, `Image` 컴포넌트에 `src`를 넘겨줄 때 어떤 일이 일어나는지 살펴보겠습니다.\n\n---\n\n### 이미지 최적화 끄기\n\nNext.js는 기본적으로 이미지 최적화를 자동으로 해주는데요, 가끔은 직접 최적화하지 않고 원본 이미지를 그대로 쓰고 싶을 때가 있죠. 그럴 때 `next.config.js` 파일에 이렇게 설정하면 됩니다:\n\n```js\nmodule.exports = {\n  images: {\n    unoptimized: true,\n  },\n}\n```\n\n이렇게 하면 Next.js가 이미지 최적화를 건너뛰고, 여러분이 지정한 이미지가 그대로 사용돼요.\n\n---\n\n### `Image` 컴포넌트의 `src` 프로퍼티\n\n그리고 `Image` 컴포넌트에 `src` 값을 넘기면, 내부적으로 `srcset` 과 `src` 속성이 자동으로 생성돼서 결국 HTML의 `\u003cimg\u003e` 태그로 변환됩니다.\n\n예를 들어:\n\n```js\n\u003cImage src=\"/me.jpg\" /\u003e\n```\n\n이렇게 쓰면 Next.js가 자동으로 화면 크기에 맞는 여러 해상도의 이미지 URL을 만들어서 `srcset`에 넣어주고, 동시에 기본 `src` 도 넣어줘서 브라우저가 가장 적합한 이미지를 골라서 보여주게 하는 거죠.\n\n이 부분이 왜 좋냐면, 반응형 이미지 처리가 훨씬 편하고, 성능도 좋아진다는 점입니다!\n\n---\n\n### 팁! 이미지 최적화 관련 기억할 점\n\n- `unoptimized: true`를 쓰면 캐싱이나 최적화가 없기 때문에, 프로덕션에서 할 때는 성능 저하가 있을 수 있으니 주의하세요.\n- `next/image` 컴포넌트를 쓸 때는 반드시 `width`와 `height`를 지정하는 게 좋습니다. 그래야 레이아웃이 안정적으로 잡히고 CLS(Cumulative Layout Shift)를 줄일 수 있어요.\n- 외부 도메인의 이미지를 쓸 때는 `next.config.js`에 도메인 허용 설정을 해줘야 합니다.\n\n\u003e 그리고 혹시 더 깊게 이미지 최적화를 알아보고 싶으면, `next/image` 공식 문서도 한번 들여다보시면 정말 많은 팁들이 숨어있답니다!\n\n오늘은 여기까지! 필요할 때마다 참고하시고, 이미지 최적화도 똑똑하게 활용해 보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안녕하세요! 오늘은 Next.js 이미지 컴포넌트(Image) 사용 시, `src` 속성 자동 생성 문제와 이를 우회하는 방법에 대해 알아볼게요.\n\n보통 `\u003cimg\u003e` 태그를 사용하면 이렇게 srcset과 src를 직접 지정하잖아요?\n\n```html\n\u003cimg\n  srcset=\"\n    /_next/image?url=%2Fme.jpg\u0026w=640\u0026q=75 1x,\n    /_next/image?url=%2Fme.jpg\u0026w=828\u0026q=75 2x\n  \"\n  src=\"/_next/image?url=%2Fme.jpg\u0026w=828\u0026q=75\"\n/\u003e\n```\n\n근데 Next.js의 `\u003cImage\u003e` 컴포넌트를 쓰면 내부적으로 `src`와 `srcset`을 자동으로 생성해줘요. 다 좋은데, 가끔은 이 자동 생성된 `src`를 우리가 직접 지정하고 싶을 때가 있죠. 예를 들어, 기존 웹사이트를 `img`에서 `Image` 컴포넌트로 바꿀 때, SEO 최적화를 위해 이미지 URL을 그대로 유지하고 싶을 수도 있어요. (검색엔진 최적화, 이미지 랭킹 유지 및 재크롤 방지 목적 등)\n\n그럴 때 사용하는 게 바로 `overrideSrc` prop 입니다.\n\n```jsx\n\u003cImage src=\"/me.jpg\" overrideSrc=\"/override.jpg\" /\u003e\n```\n\n이렇게 하면 내부적으로는 `/me.jpg`로 이미지 최적화 및 로딩 처리를 하면서도, 실제 `src` 속성은 `/override.jpg`로 지정할 수 있어요.\n\n🎯 핵심 정리!\n\n| 상황                                | 해결법                        |\n|---------------------------------|-----------------------------|\n| 기본적으로 자동 생성된 src 쓰기 원함       | 그냥 `\u003cImage src=\"...\" /\u003e` 사용      |\n| SEO 등 이미지 URL을 유지해야 할 때            | `\u003cImage src=\"...\" overrideSrc=\"...\" /\u003e` 사용 |\n\n---\n\n추가 팁!\n\n- 이미지 최적화는 Next.js가 자동으로 해주지만, SEO를 위해 실제 보여지는 HTML 속성 값을 직접 관리해야 할 때가 있어서 이렇게 `overrideSrc`가 유용해요.\n- 오버라이드 한 URL이 실제 이미지가 맞는지, 접근 가능 여부는 미리 확인하는 게 좋습니다.\n- `overrideSrc`는 Next.js 공식 문서에 나오는 기능은 아닌 경우가 많아서, 직접 구현하거나 커스텀 이미지 컴포넌트를 만들어 사용하는 방법도 있어요!\n\nNext.js 이미지 컴포넌트를 다룰 때 이런 작은 팁들이 개발 생산성도 올려주고, SEO 챙기는데도 크게 도움 된답니다. 다음에도 유용한 정보로 찾아올게요! 😄\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 코드는 `\u003cimg\u003e` 태그에서 `srcset`과 `src` 속성을 활용하는 예시입니다.\n\n```js\n\u003cimg\n  srcset=\"\n    /_next/image?url=%2Fme.jpg\u0026w=640\u0026q=75 1x,\n    /_next/image?url=%2Fme.jpg\u0026w=828\u0026q=75 2x\n  \"\n  src=\"/override.jpg\"\n/\u003e\n```\n\n### 간단 정리\n\n- `srcset`은 브라우저가 디바이스 해상도에 맞는 이미지를 선택해서 로드할 수 있도록 도와줘요.\n- 위 예시에서는 1배(640px)와 2배(828px) 해상도의 이미지를 준비해뒀죠.\n- `src`는 기본 이미지 URL로, `srcset`을 지원하지 않는 구형 브라우저에서 사용돼요.\n\n---\n\n### decoding 속성에 대해서\n\n브라우저에 이미지의 디코딩(화면에 보여주기 위해 이미지 데이터를 해석하는 과정)을 어떻게 처리할지 힌트를 주는 속성이에요. 기본값은 `async`로, 비동기적으로 디코딩해서 페이지 렌더링 속도에 도움을 줘요.\n\n| 속성값 | 설명                              |\n|--------|---------------------------------|\n| sync   | 이미지 디코딩이 끝날 때까지 렌더링을 중단해요. 주요 이미지에 적합. |\n| async  | 디코딩을 비동기 처리해요. 기본값이며, 렌더링에 지장 없어요. |\n| auto   | 브라우저가 최적의 전략으로 디코딩 방식을 결정해요. |\n\n### 왜 `decoding`을 신경 써야 할까?\n\n이미지가 많은 페이지에서 디코딩 방식을 잘 설정하면, 페이지 렌더링이 훨씬 부드러워지고 사용자 경험이 좋아집니다. 특히 중요한 이미지나 첫 화면에 노출되는 이미지가 있다면 `sync`로 설정해서 바로 보이게 하는 것도 방법이에요.\n\n---\n\n### 한 가지 팁!\n\n`loading=\"lazy\"` 속성과 함께 쓰면, 이미지가 화면 근처에 올 때만 로드하고, 디코딩도 적절히 조절할 수 있어서 성능 최적화에 더 도움이 됩니다.\n\n```html\n\u003cimg src=\"image.jpg\" decoding=\"async\" loading=\"lazy\" alt=\"example\" /\u003e\n```\n\n---\n\n이렇게 이미지 관련 속성들을 적절히 이해하고 사용하면, 웹 페이지의 성능과 사용자 경험을 크게 개선할 수 있어요. 다음에도 좋은 팁으로 또 만나요! 😊\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- async: 이미지를 비동기적으로 디코딩해서, 이미지 로딩이 완료되기 전에도 다른 콘텐츠가 먼저 렌더링될 수 있게 해줘요.\n- sync: 이미지를 동기적으로 디코딩해서, 다른 콘텐츠와 함께 완전하게 한 번에 보여주고 싶을 때 사용해요.\n- auto: 디코딩 모드에 대한 특별한 선호 없이 브라우저가 가장 적절하다고 판단하는 방식을 선택하게 합니다.\n\n디코딩 속성(decoding attribute)에 대해 더 궁금하다면, 자세한 정보를 찾아보는 것도 좋아요. 이미지 로딩 방식에 따라 페이지 렌더링 속도나 사용자 경험이 달라질 수 있으니까요.\n\n### 다른 속성들 (Other Props)\n\n`Image` 컴포넌트에 넣는 다른 모든 속성들은, 특별히 제한된 몇 가지를 제외한 채로 실제 `\u003cimg\u003e` 태그에 그대로 전달됩니다.  \n즉, 일반적인 `alt`, `width`, `height` 같은 속성들은 걱정 없이 사용할 수 있죠.\n\n---\n\n추가로 알려드리자면, 이미지 디코딩 방식은 특히 페이지가 많이 복잡하거나 이미지가 많은 경우 성능에 꽤 큰 영향을 줄 수 있어요. 예를 들어, `async`로 둬서 텍스트 같은 중요한 콘텐츠가 먼저 보이게 하면 사용자 경험이 더 좋아질 수 있답니다. 반면, UI가 깔끔하게 한꺼번에 보여지는 게 중요한 경우엔 `sync`를 선택하는 게 좋고요.\n\n꼭 상황에 맞게 선택해 주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- srcSet 대신 Device Sizes를 사용하세요.\n\n## 설정 옵션\n\n다음은 props 외에 next.config.js 파일에서 Image 컴포넌트를 설정할 수 있는 옵션들입니다. 이 옵션들을 통해 이미지 최적화 동작을 세밀하게 조절할 수 있어요.\n\n### localPatterns\n\n(localPatterns 옵션에 대한 설명이 더 있으면 여기에 추가하면 좋겠지만, 지금은 제목만 주셨네요. 만약 이미지 경로나 패턴을 로컬 이미지 관리에 사용한다면, 이 옵션이 어떤 역할을 하는지 간단히 정리해볼게요.)\n\nlocalPatterns는 로컬 이미지 파일 경로나 패턴들을 지정하는 옵션입니다. 예를 들어, 특정 폴더 내 이미지 파일만 이미지 최적화 대상에 포함하거나 특정 형식의 파일만 처리하도록 할 때 유용하답니다. 이렇게 하면 불필요한 파일까지 빌드 과정에 포함되는 걸 막아 최적화를 더욱 깔끔하게 할 수 있어요.\n\n---\n\n추가로 srcSet과 Device Sizes에 대해 조금 더 알려드릴게요.\n\n### srcSet 대신 Device Sizes 사용하기\n\n예전에는 이미지 태그에 srcSet 속성을 직접 지정해서 여러 해상도 대응 이미지를 넘겨주곤 했는데요, Next.js Image 컴포넌트에서는 deviceSizes 배열을 통해 대응할 화면 너비별 이미지 사이즈를 미리 지정합니다. 그러면 Next.js가 자동으로 가장 적합한 이미지 크기를 골라 srcSet을 만들어서 넣어줘 개발자가 직접 일일이 srcSet을 관리할 필요가 사라지죠.\n\n```js\n// next.config.js 예시\nmodule.exports = {\n  images: {\n    deviceSizes: [320, 420, 768, 1024, 1200],\n  },\n};\n```\n\n이런 식으로 설정하면 각 기기별 스크린 크기에 맞는 이미지가 제공되어 더욱 빠르고 효율적인 이미지 로딩이 가능해져요.\n\n어려운 설정 같아 보여도, Next.js가 알아서 다 해주니까 걱정하지 마세요. 대신 나만의 이미지 정책에 맞게 deviceSizes 같은 옵션을 적절히 조정해주면 됩니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 이미지 최적화를 할 때, 특정 경로만 최적화 대상으로 지정하고 싶다면 `next.config.js` 파일에서 `localPatterns` 옵션을 활용할 수 있어요. 이 옵션을 사용하면 내가 원하는 경로만 이미지를 최적화하고, 그 외의 경로에 대해서는 요청을 차단할 수 있답니다.\n\n예를 들어, 아래처럼 설정하면 `/assets/images/`로 시작하는 로컬 이미지 경로만 최적화가 허용되고, 쿼리 스트링이 붙은 경로는 허용되지 않아요.\n\n```js\nmodule.exports = {\n  images: {\n    localPatterns: [\n      {\n        pathname: '/assets/images/**',\n        search: '',\n      },\n    ],\n  },\n}\n```\n\n\u003e 참고로, 위 설정을 적용하면 `next/image` 컴포넌트의 `src` 속성이 `/assets/images/`로 시작하지 않거나 쿼리 스트링이 포함된 경우, 요청이 400 Bad Request로 처리됩니다. 따라서 불필요한 경로나 잘못된 요청을 막는 데 유용해요.\n\n또한, `localPatterns` 외에도 `remotePatterns`라는 옵션도 있는데, 이것은 외부 도메인의 이미지를 최적화 대상으로 설정할 때 사용됩니다. 다음에 이어서 `remotePatterns`에 대해서도 알아볼게요. \n\n이렇게 경로를 명확하게 지정해주면 보안 측면에서도 도움이 되고, 최적화 대상이 한정되니 관리도 편해지니 꼭 활용해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 외부 이미지를 사용할 때, 보안을 위해 외부 이미지에 대한 설정이 필요해요. 이렇게 해야 악의적인 사용자가 다른 도메인의 이미지를 마음대로 불러오는 걸 막을 수 있답니다. \n\nNext.js는 외부 이미지를 Next.js Image Optimization API를 통해 제공하는데, 이때 `remotePatterns` 설정을 통해 내 계정에서 사용할 수 있는 외부 이미지 URL 패턴을 지정할 수 있어요. 이렇게 지정하면 지정된 도메인과 경로에 해당하는 이미지들만 안전하게 불러올 수 있습니다.\n\n### Next.js 15.3.0 이상 버전\n\n아래처럼 `next.config.js` 파일에 `remotePatterns`에 `new URL` 객체로 패턴을 지정해주면 돼요.\n\n```js\nmodule.exports = {\n  images: {\n    remotePatterns: [new URL('https://example.com/account123/**')],\n  },\n}\n```\n\n### Next.js 15.3.0 미만 버전\n\n이전 버전에서는 `remotePatterns`를 객체 형태로 설정해줘야 하는데, 조금 더 자세하게 프로토콜, 호스트명, 포트, 경로 등을 나눠서 작성해줍니다.\n\n```js\nmodule.exports = {\n  images: {\n    remotePatterns: [\n      {\n        protocol: 'https',\n        hostname: 'example.com',\n        port: '',\n        pathname: '/account123/**',\n        search: '',\n      },\n    ],\n  },\n}\n```\n\n---\n\n### 추가 팁\n\n- `pathname`에서 `/**`는 와일드카드로, 해당 경로 이하의 모든 이미지 경로를 허용한다는 뜻이에요. 필요에 따라 경로를 더 구체적으로 설정해주세요.\n- 만약 여러 도메인에서 이미지를 불러와야 한다면, `remotePatterns` 안에 여러 패턴을 배열 형태로 추가하면 됩니다.\n- 보안을 위해 믿을 수 있는 도메인만 허용하는 게 가장 좋아요! 나중에 이미지 도메인이 바뀐다면 꼭 이 설정도 함께 업데이트해줘야 합니다.\n\n앱에서 이미지를 최적화하면서도 보안도 챙기려면 이런 설정, 꼭 잊지 말고 해주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nnext/image 컴포넌트를 사용할 때 외부 이미지 도메인을 어떻게 안전하게 설정할 수 있는지 아시나요? 이번에 알려드릴 내용은 Next.js의 `next.config.js` 파일에 `remotePatterns` 옵션을 활용하는 방법입니다.\n\n---\n\n먼저, 이렇게 설정하면 이미지 URL이 꼭 `https://example.com/account123/`로 시작해야 하고, 쿼리 스트링은 없어야 해요. 다른 프로토콜(예: http), 호스트 이름, 포트 번호, 혹은 경로가 일치하지 않으면 400 Bad Request 에러가 발생합니다.\n\n```js\nmodule.exports = {\n  images: {\n    remotePatterns: [\n      {\n        protocol: 'https',\n        hostname: 'example.com',\n        port: '',\n        pathname: '/account123/**',\n        search: '',\n      },\n    ],\n  },\n}\n```\n\n이렇게 해두면 고정된 경로 패턴을 안전하게 지정할 수 있어요. 근데 만약 여러 서브도메인이 있는 경우라면 어떻게 할까요?\n\n---\n\n그럴 때는 와일드카드 패턴을 활용할 수 있어요! 예를 들어, 아래 설정은 https 프로토콜에, `img1.example.com` 또는 `me.avatar.example.com` 같은 여러 서브도메인을 모두 허용합니다. 하지만 포트는 없고 쿼리 스트링도 없어야 하죠.\n\n```js\nmodule.exports = {\n  images: {\n    remotePatterns: [\n      {\n        protocol: 'https',\n        hostname: '**.example.com',\n        port: '',\n        search: '',\n      },\n    ],\n  },\n}\n```\n\n---\n\n| 속성      | 의미                                 | 예시 값                   |\n|-----------|------------------------------------|---------------------------|\n| protocol  | 허용할 프로토콜 (http, https 등)    | 'https'                   |\n| hostname  | 호스트 이름, 와일드카드 가능(**)      | '**.example.com'           |\n| port      | 포트 번호 (빈 문자열은 포트 없음)      | ''                        |\n| pathname  | 경로 (글로벌 와일드카드 /** 가능)  | '/account123/**'           |\n| search    | 쿼리 스트링 (빈 문자열은 쿼리 없음)    | ''                        |\n\n---\n\n\u003e 참고로, `remotePatterns` 안에 경로를 지정하려면 `pathname` 속성을 꼭 써야 해요. 위 첫번째 예제에서 `/account123/**`처럼 사용하구요!\n\n이 기능 덕분에 보안도 챙기면서 다양한 도메인에서 이미지를 마음껏 불러올 수 있답니다. 특히 외부 이미지가 많은 프로젝트에서는 꼭 살펴봐야 할 설정이에요.\n\n---\n\n요약하자면,\n\n- `remotePatterns`를 쓰면 이미지 허용 도메인을 세밀하게 설정할 수 있어요.\n- 와일드카드를 활용해 여러 서브도메인도 한방에 통제 가능합니다.\n- 프로토콜, 포트, 쿼리스트링까지 꼼꼼히 설정 가능해 오류를 줄이고 보안도 강화할 수 있죠.\n\n이렇게 하시면 Next.js 프로젝트에서 안전하게 외부 이미지를 관리할 수 있어서, 성능과 안정성을 함께 챙길 수 있답니다! 혹시 더 궁금한 점 있으면 언제든지 댓글로 물어봐 주세요~\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n와일드카드 패턴은 경로 이름(pathname)과 호스트 이름(hostname) 모두에 사용할 수 있는데, 다음과 같은 문법을 가지고 있어요:\n\n- `*` : 한 개의 경로 세그먼트(path segment) 또는 서브도메인(subdomain)에 대응해요.\n- `**` : 경로 세그먼트가 끝부분에 여러 개 있을 때, 또는 서브도메인이 시작 부분에 여러 개 있을 때 모두 매칭해요.\n\n단, `**` 문법은 패턴 중간에는 사용할 수 없다는 점 참고하세요!\n\n\u003e **알아두면 좋은 점**: 프로토콜, 포트, 경로(pathname), 검색(search) 정보를 생략하면 자동으로 와일드카드 `**`가 포함된 것으로 간주돼요. 하지만 이 방법은 권장하지 않아요. 왜냐하면 의도치 않은 URL까지 매칭되어 악의적인 사용자의 공격에 노출될 수 있기 때문이에요.\n\n---\n\n조금 더 부연하자면, 와일드카드를 사용할 때는 어떤 부분에 얼마만큼 유연함을 줄지 꼭 신중히 결정해야 해요. 특히, `**`는 매우 강력한 매칭이 되기 때문에 보안상 위험할 수 있으니, 가능한 최소한으로 사용하는 걸 추천합니다.\n\n예를 들어, 호스트네임에 `*.example.com`은 `abc.example.com`에는 매칭되지만, `xyz.abc.example.com`까지는 포함하지 않아요. 반면 `**.example.com`이라면 여러 개의 서브도메인을 복수로 포함하는 경우에 사용하죠.\n\n이런 와일드카드 패턴 활용법을 잘 이해하면, URL 필터링이나 라우팅 기능을 구현할 때 훨씬 편리하게 조건을 작성할 수 있어요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nnext.config.js에서 remotePatterns 속성에 search 옵션을 사용하는 예시를 보여드릴게요:\n\n```js\nmodule.exports = {\n  images: {\n    remotePatterns: [\n      {\n        protocol: 'https',\n        hostname: 'assets.example.com',\n        search: '?v=1727111025337',\n      },\n    ],\n  },\n}\n```\n\n\u003e 참고할 점: 위 예시는 next/image 컴포넌트의 src 값이 `https://assets.example.com`으로 시작해야 하고, 쿼리 스트링이 정확히 `?v=1727111025337` 로 일치해야만 이미지를 불러올 수 있다는 뜻이에요. 만약 프로토콜이나 쿼리 스트링이 다르면 400 Bad Request 오류가 발생할 수 있습니다.\n\n이렇게 remotePatterns에 search 값을 명시하면, URL 매칭 조건을 엄격하게 설정할 수 있어서 보안이나 캐시 관리를 조금 더 세밀하게 할 수 있어요.\n\n### domains와의 차이점\n\n`domains` 속성은 단순히 hostname 기반으로 이미지를 허용하는 반면, `remotePatterns`는 프로토콜, 호스트명, 경로, 포트, 검색(쿼리)까지 좀 더 자세히 지정할 수 있다는 점에서 훨씬 유연해요. 만약 특정 쿼리를 포함한 URL만 받고 싶다면 `remotePatterns`를 사용하세요.\n\n예를 들어, 다음은 domains와 remotePatterns의 비교입니다:\n\n| 속성명        | 설명                                  | 유연성                |\n|-------------|-------------------------------------|--------------------|\n| domains     | 도메인 이름만 지정, 간단히 허용 목록 작성 가능    | 낮음                  |\n| remotePatterns | 프로토콜, 호스트, 경로, 검색 등 세부적으로 지정 가능 | 매우 높음             |\n\n개발할 때 이렇게 쿼리 스트링까지 조건에 넣으면, 이미지 요청에서 인증 토큰이나 버전 관리 같은 정보를 활용할 때도 편리해요.\n\n필요에 따라 여러분 프로젝트에 맞는 방식을 선택해서 사용해 보면 좋겠네요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js 14부터는 remotePatterns라는 엄격한 설정 방식을 권장하면서, 기존의 domains 설정이 점점 Deprecated(사용 중단)되고 있다는 경고가 나오는 경우가 많아요. \n\n왜 그러냐면, domains 설정은 외부 이미지 도메인을 허용하는 데는 편리하지만, 와일드카드 패턴 매칭이 안 되고, 프로토콜(https, http), 포트, 경로나 쿼리 스트링 같은 세밀한 조건을 제한할 수가 없거든요. 즉, 보안 측면에서 좀 허술할 수 있어요. 특히 도메인의 모든 콘텐츠를 소유하지 않은 경우에는 위험할 수도 있어요.\n\n대신 remotePatterns는 이런 부분을 세밀하게 지정할 수 있어서, 악성 사용자가 이미지 요청을 조작해 공격하는 걸 막아줄 수 있답니다.\n\n---\n\n### domains 설정 예시 (next.config.js)\n\n```js\nmodule.exports = {\n  images: {\n    domains: ['example.com', 'cdn.example.com'],\n  },\n};\n```\n\n위처럼 도메인을 배열로 넣어주면, 해당 도메인에 있는 외부 이미지들을 Next.js 이미지 최적화 기능과 함께 쓸 수 있어요. 하지만 프로토콜이나 경로는 제한하지 못하고, 와일드카드(*)도 안 돼서 살짝 아쉽죠.\n\n---\n\n### 추가로, remotePatterns 설정법은?\n\n만약 `remotePatterns`를 써보고 싶다면, 이렇게 쓸 수 있어요:\n\n```js\nmodule.exports = {\n  images: {\n    remotePatterns: [\n      {\n        protocol: 'https',\n        hostname: 'example.com',\n        port: '',\n        pathname: '/images/**',\n      },\n    ],\n  },\n};\n```\n\n이렇게 하면 `https://example.com/images/` 하위 경로만 허용하는 식으로 훨씬 정밀한 제어가 가능해요. 물론, Next.js 14 이상이어야 지원됩니다.\n\n---\n\n### 정리하자면\n\n- domains는 간단하지만 제한적이고 보안 취약점이 있을 수 있으니 조심!\n- remotePatterns는 더 엄격하고 안전한 설정 방법\n- 여러분이 도메인 소유주가 아니면 remotePatterns 추천!\n\n개발하면서 이미지 도메인 설정할 때 참고하시고, 가능하면 최신 방식인 remotePatterns로 업데이트해보세요! 안전한 앱 만드는 데 큰 도움이 될 거예요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여러분, Next.js에서 이미지 최적화를 할 때 기본 API 대신 클라우드 제공업체를 이용하고 싶을 때가 있죠? 그럴 땐 next.config.js 파일에서 loaderFile 옵션을 활용해서 커스텀 로더를 설정할 수 있어요.\n\n먼저 기본적으로 도메인을 설정해주는 예제를 볼게요:\n\n```js\nmodule.exports = {\n  images: {\n    domains: ['assets.acme.com'], // 여기서 외부 이미지 도메인을 지정해줘요.\n  },\n}\n```\n\n이렇게 하면 Next.js가 `assets.acme.com`에서 가져오는 이미지를 허용하고 최적화할 수 있게 됩니다.\n\n그런데 만약 클라우드 제공업체(예: Cloudinary, Imgix 등)를 직접 써서 이미지 최적화를 맡기고 싶으면 어떻게 할까요? 이때는 `loaderFile` 옵션을 사용해서 커스텀 이미지 로더를 지정하면 돼요. 예시는 아래와 같습니다:\n\n```js\nmodule.exports = {\n  images: {\n    loader: 'custom',               // 커스텀 로더 사용 선언\n    loaderFile: './my/image/loader.js', // 직접 만든 로더 파일 경로\n  },\n}\n```\n\n### 여기서 중요한 점\n- `loader`는 `'default'`, `'imgix'`, `'cloudinary'`, `'akamai'` 등 미리 준비된 옵션도 있지만, `custom`을 쓰면 직접 로더 코드를 만들어 제어할 수 있습니다.\n- `loaderFile`에 적힌 파일에서는 함수가 export되어 있어야 하며, 이미지 URL과 원하는 크기 등을 인자로 받아 최종 이미지 URL을 반환해야 해요.\n\n예를 들어, `./my/image/loader.js` 파일은 대략 이런 모양일 수 있어요:\n\n```js\nmodule.exports = ({ src, width, quality }) =\u003e {\n  return `https://your-cloud-provider.com/${src}?w=${width}\u0026q=${quality || 75}`\n}\n```\n\n이렇게 하면 Next.js가 이미지 최적화를 요청할 때 이 커스텀 로더를 거쳐 이미지 URL을 생성하고, 클라우드에서 최적화된 이미지를 받아 올 수 있습니다.\n\n---\n\n요약하자면, Next.js의 이미지 컴포넌트는 기본 제공 API로도 훌륭하지만, 자신만의 클라우드 서비스나 특별한 최적화 방식을 쓰고 싶을 땐 `loader`를 `'custom'`으로 설정하고, `loaderFile`에서 직접 URL 생성 방식을 관리하면 완전 내 맘대로 컨트롤할 수 있어 편리하답니다! \n\n더 궁금하면 언제든 질문 주세요~\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 이미지 로더를 설정할 때, `loader` 파일은 반드시 Next.js 애플리케이션 루트 기준으로 상대 경로를 가리켜야 합니다. 이 파일에서는 기본(default)로 문자열을 반환하는 함수 하나를 export해야 하는데요, 예를 들어 아래처럼 작성할 수 있습니다:\n\n```js\n'use client'\n\nexport default function myImageLoader({ src, width, quality }) {\n  return `https://example.com/${src}?w=${width}\u0026q=${quality || 75}`\n}\n```\n\n여기서 `src`는 이미지 경로, `width`는 요청할 이미지의 너비, `quality`는 이미지 품질(기본 75)인데요, 함수가 최종적으로 반환하는 문자열은 이미지 URL이 됩니다. 이 방식을 쓰면 이미지 요청을 커스터마이징할 수 있어서 CDN이나 외부 이미지 서버와 연동할 때 아주 유용하답니다.\n\n---\n\n그리고 꼭 파일 하나에 넣어야 한다고 생각하지 마세요! Next.js `next/image` 컴포넌트의 `loader` 프롭에도 직접 함수를 넘겨줄 수 있어요. 이렇게 하면 각 이미지마다 다른 로더를 쓸 수도 있어서 더욱 유연한 관리가 가능합니다.\n\n아래는 두 가지 예시입니다:\n\n| 구분 | 설명 | 코드 |\n|-------|-------------|-------------|\n| 1. loader 파일 사용 | 루트에 파일 만들어서 재사용 | js 'use client' export default function myImageLoader({ src, width, quality }) { return `https://example.com/${src}?w=${width}\u0026q=${quality || 75}` }  |\n| 2. loader prop 사용 | 이미지 컴포넌트마다 다르게 설정 | jsx import Image from 'next/image'; const myImageLoader = ({ src, width, quality }) =\u003e { return `https://example.com/${src}?w=${width}\u0026q=${quality || 75}`; } \u003cImage loader={myImageLoader} src=\"me.png\" width={500} height={500} alt=\"me\" /\u003e  |\n\n---\n\nTip!  \n- `loader` 함수가 반환하는 URL은 클라이언트가 실제로 접근 가능한 주소여야 해요. 내부 경로나 상대 경로를 그대로 쓰면 안 됩니다.  \n- 품질(`quality`) 옵션을 넣는 이유는 이미지 크기와 품질간 밸런스를 맞추기 위해서인데, 기본값은 75이지만 필요에 따라 조절하세요.  \n- 공식 Next.js 문서(https://nextjs.org/docs/api-reference/next/image#loader)에서도 다양한 예제를 참고할 수 있어요.\n\n이미지 요청 경로 다루는 게 어렵게 느껴질 수 있는데, 이런 사용자 정의 로더를 잘 활용하면 서버 부담도 줄이고, 이미지 로딩 속도도 개선할 수 있답니다! 궁금하면 꼭 한 번 시도해 보세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 커스텀 이미지 로더 설정\n\n\u003e 참고할 점: 이미지 로더 파일을 커스터마이징할 때 함수(function)를 넘겨줘야 하는데, 이 함수는 Client Components에서 직렬화(serialization) 과정을 거쳐야 제대로 작동해요.\n\n## 고급 설정\n\n아래 설정들은 주로 고급 사용자들을 위한 내용이에요. 보통은 건드릴 필요가 없고, 만약 이 설정들을 직접 바꾸면 향후 Next.js 업데이트 시 기본 설정이 변경돼도 자동 반영되지 않으니 주의가 필요해요.\n\n---\n\n사실 이미지 로더를 직접 커스터마이징하는 경우는 주로 이미지 처리 방식을 세밀하게 조정하고 싶을 때입니다. 예를 들면, 이미지 CDN을 직접 지정하거나, 특정 포맷 변환, 압축 옵션을 다루고 싶을 때 쓰이죠. 하지만 대부분 프로젝트에서는 Next.js가 제공하는 기본 이미지 로더로 충분한 성능과 편리함을 느낄 수 있으니, 특별한 이유가 없다면 기본 설정을 유지하는 게 안정적입니다.\n\n필요하다면 Client Component에서 커스텀 함수를 어떻게 직렬화하는지 추가 예제도 나중에 소개할게요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### deviceSizes\n\n만약 여러분이 타겟하려는 사용자들이 주로 사용하는 디바이스의 화면 너비를 알고 있다면, `next.config.js` 파일에서 `deviceSizes`라는 속성에 해당 너비들을 지정할 수 있어요. 이렇게 지정해주면, `next/image` 컴포넌트가 `sizes` 속성을 사용할 때 사용자의 디바이스에 가장 적합한 이미지 크기를 골라서 제공할 수 있게 됩니다.\n\n만약 별도로 설정하지 않으면, Next.js는 기본값으로 아래와 같은 디바이스 크기들을 사용해요.\n\n```js\nmodule.exports = {\n  images: {\n    deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],\n  },\n}\n```\n\n| 기본 deviceSizes 값 |\n| ------------------- |\n| 640                 |\n| 750                 |\n| 828                 |\n| 1080                |\n| 1200                |\n| 1920                |\n| 2048                |\n| 3840                |\n\n---\n\n이걸 설정하는 가장 큰 장점은 이미지 최적화에서 효율성! 예를 들어, 모바일 사용자에게 굳이 큰 해상도의 이미지를 내려주면 데이터 낭비가 심하잖아요. 그런데 이걸 활용하면 크고 작은 여러 버전의 이미지가 준비되어서, 각각의 디바이스에 최적화된 이미지를 업로드 없이 자동으로 빠르게 제공해주니까요.\n\n추가로, `deviceSizes`와 비슷하게 `imageSizes`라는 옵션도 있는데요, 이건 고정된 이미지 크기(아이콘 같은 작은 이미지)들을 지정할 때 유용해요. 보통 `deviceSizes`는 반응형 이미지에, `imageSizes`는 고정 사이즈 이미지에 활용한다고 이해하시면 좋아요. \n\n실제로 프로젝트에 맞춰 이 값들을 잘 조절하면 성능이 확연히 개선되는 걸 체감할 수 있으니 한 번 프로젝트에 적용해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### imageSizes란?\n\nNext.js에서 `next.config.js` 파일 안에 `images.imageSizes`라는 속성을 통해 **이미지 너비 리스트를 직접 지정**할 수 있어요. 이 리스트는 `deviceSizes`라는 또 다른 배열과 합쳐져서, 이미지의 `srcset`을 생성할 때 사용되는 전체 크기 배열을 만든답니다.\n\n그런데 왜 두 개의 리스트가 따로 있냐고요? 그 이유는, `imageSizes`는 **이미지에 `sizes` 속성이 제공될 때만 사용**돼요. 즉, `sizes` prop이 있으면 이 이미지는 화면 전체 너비를 쓰는 게 아니라, 화면보다 작은 크기로 보여준다는 의미거든요. 그래서 `imageSizes`에 들어가는 값들은 항상 `deviceSizes`의 가장 작은 크기보다 작아야 해요. 이것은 이미지가 너무 커서 불필요한 리소스를 쓰는 걸 방지해줍니다.\n\n만약 여러분이 따로 설정을 안 해주면 Next.js가 기본값을 사용하게 돼요.\n\n---\n\n#### 추가로 알아두면 좋은 점!\n\n- `deviceSizes`는 주로 일반적인 기기 화면 크기를 기준으로 하며, Next.js가 자동으로 기본값을 제공하지만, 상황에 맞게 조정할 수도 있어요.\n- 예를 들어, 모바일 최적화가 매우 중요하거나, 특정 컴포넌트가 작은 이미지 크기를 주로 쓴다면, `imageSizes`를 알맞게 지정해주면 네트워크 대역폭 절약과 빠른 로딩에 도움이 됩니다.\n- 또한, Image 컴포넌트에서 `sizes` prop을 사용하면, 당신이 지정한 `imageSizes` 배열에 맞게 다양한 이미지를 브라우저가 선택하게 됩니다.\n\n---\n\n아래는 각 속성별 기본값이 어떻게 설정되어 있는지 참고해보세요.\n\n| 속성 이름       | 기본값                                 | 설명                                            |\n|----------------|---------------------------------------|-------------------------------------------------|\n| deviceSizes    | [640, 750, 828, 1080, 1200, 1920, 2048, 3840] | 대표적인 기기 너비 배열                             |\n| imageSizes     | [16, 32, 48, 64, 96]                  | `sizes` prop이 있는 이미지에 사용되는 작고 세밀한 너비 배열 |\n\n요렇게 이해하면 Next.js 이미지 최적화가 좀 더 명확해지실 거예요! 혹시 이미지 로딩 최적화 팁에 관심 있으면 또 알려드릴게요~\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n오늘은 Next.js에서 이미지 최적화 설정하는 방법에 대해 쉽고 간단하게 알아볼게요. 이미지 크기와 퀄리티(quality)를 직접 설정해서 웹사이트 로딩 속도와 사용자 경험을 개선할 수 있답니다.\n\n---\n\n### 이미지 크기 (`imageSizes`) 설정하기\n\nNext.js의 기본 이미지 최적화 API는 여러 크기의 이미지를 자동으로 만드는데요. 만약 이 크기를 내가 원하는 크기로 지정하고 싶다면 `next.config.js` 파일에 `imageSizes`를 설정하면 돼요.\n\n```js\nmodule.exports = {\n  images: {\n    imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],\n  },\n}\n```\n\n위 코드에서 이미지 사이즈 배열에 들어간 숫자들은 픽셀 단위의 너비를 의미해요. 예를 들어 16은 16px 너비의 이미지를 생성한단 뜻이죠. 이 설정을 참고해서 사이트에 필요한 크기만 지정하면 불필요한 이미지 생성과 트래픽을 줄일 수 있어요.\n\n---\n\n### 이미지 퀄리티 (`qualities`) 제한하기\n\n기본적으로 Next.js는 이미지 퀄리티를 1부터 100까지 모두 허용해요. 근데 세부적으로 퀄리티를 제한하고 싶을 때는 이렇게 해볼 수 있습니다.\n\n```js\nmodule.exports = {\n  images: {\n    qualities: [25, 50, 75],\n  },\n}\n```\n\n이렇게 하면 오직 25%, 50%, 75% 퀄리티만 이미지 최적화 API에서 허용하게 돼요. 덕분에 최대한 이미지 품질과 용량을 조절할 수 있죠. 예를 들어, 퀄리티를 너무 낮게 하면 화질이 떨어져 사용자 경험이 나빠질 수 있으니, 적당한 균형을 찾는 게 중요해요!\n\n---\n\n### 참고로 더 알아두면 좋은 팁\n\n- `imageSizes`는 기본적으로 `[16, 32, 48, 64, 96, 128, 256, 384]` 크기들이 포함돼 있지만, 커스텀 사이즈 추가 가능해요.\n- `imageSizes`는 사이즈 지정에 사용하고, 실제 사용할 수 있는 이미지 최대 크기는 `deviceSizes`에서 설정할 수 있어요.\n- 퀄리티 제한을 할 때는 일반적으로 75~80 정도가 적당히 고화질과 적당한 용량의 밸런스로 추천됩니다.\n- 더 나아가 `formats` 설정을 이용해서 WebP, AVIF 등 최신 이미지 포맷으로 변환하는 것도 가능하니까 같이 고려해보세요!\n\n---\n\n### 마무리\n\nNext.js 이미지 최적화 세팅은 웹 속도를 개선하고 사용자 경험을 올리는 데 적절한 이미지 크기와 퀄리티를 직접 정할 수 있어 정말 편리해요. 사이트 규모와 용도에 맞춰서 적절하게 설정해 보시길 추천드려요!\n\n앞으로도 이런 실용적인 팁들 많이 공유할게요. 언제든 질문 주세요~!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위 예시에서는 허용되는 품질 값이 25, 50, 75 세 가지로 정해져 있어요. quality prop에 이 배열에 없는 값이 들어가면, 이미지 요청이 실패하면서 400 Bad Request 에러가 발생합니다. 그러니까 품질 설정할 때는 꼭 허용된 값 중에서 선택해야 한다는 점 꼭 기억하세요!\n\n### formats\n\n기본적으로 Image Optimization API는 요청에 포함된 브라우저의 Accept 헤더를 통해 어떤 이미지 포맷을 지원하는지 자동으로 감지합니다. 이 정보를 바탕으로 가장 최적화된 출력 포맷을 선택해주는 거죠.\n\n여기서 중요한 점은 만약 Accept 헤더에 여러 개의 지원 포맷이 포함되어 있다면, 미리 설정된 formats 배열에서 가장 먼저 일치하는 포맷을 사용한다는 것입니다. 즉, 배열의 순서가 정말 중요해요! 만약 일치하는 포맷이 없거나, 원본 이미지가 애니메이션 GIF 같은 특수한 경우라면, API는 원본 이미지 포맷을 그대로 반환합니다.\n\n이 부분을 이해하면, 이미지 최적화를 하면서도 호환성을 최대한 보장할 수 있고, 불필요한 에러도 막을 수 있으니 꼭 참고하세요!\n\n아래는 요점 정리한 표예요:\n\n| 키워드       | 설명                                                                |\n|--------------|-------------------------------------------------------------------|\n| quality      | 허용값은 25, 50, 75. 배열 외 값 입력 시 400 Bad Request 발생           |\n| Accept 헤더  | 브라우저가 지원하는 이미지 포맷 정보를 포함하는 HTTP 헤더               |\n| formats 배열 | Accept 헤더와 비교해 출력 포맷을 결정. 배열 내 순서가 최종 포맷 선택에 중요 |\n| Fallback     | 일치하는 포맷 없거나 애니메이션 이미지일 경우 원본 포맷 사용             |\n\n이렇게 정리해두면 이미지 최적화 설정할 때 훨씬 이해가 쉬워질 거예요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n설정을 따로 해주지 않으면 기본값으로 아래와 같은 설정이 적용돼요.\n\n```js\nmodule.exports = {\n  images: {\n    formats: ['image/webp'],\n  },\n}\n```\n\n여기서 `formats`는 이미지 최적화를 위해 어떤 포맷을 사용할지 지정하는 옵션인데요, 기본값은 `webp` 포맷이에요. `webp`는 구글에서 만든 이미지 포맷으로, JPG나 PNG보다 용량을 줄이면서도 화질 손실이 적어 많이 쓰이죠.\n\n그리고 만약 AVIF 포맷을 사용해보고 싶다면, 이렇게 바꿔주면 돼요.\n\n```js\nmodule.exports = {\n  images: {\n    formats: ['image/avif'],\n  },\n}\n```\n\nAVIF는 최근에 각광받는 이미지 포맷으로, `webp`보다 압축률이 더 좋고 화질도 뛰어나지만 아직 모든 브라우저에서 완벽하게 지원하는 건 아니에요. 그래서 위 설정처럼 넣으면, 브라우저가 AVIF를 지원하지 않을 땐 원본 이미지 포맷을 대신 보여줘서 큰 문제가 없답니다.\n\n참고로, `formats` 배열에 여러 포맷을 넣어서 동시에 지원하게 할 수도 있어요. 예를 들어 내비게이션이 상황에 맞게 최적화된 포맷을 골라주도록 하려면 이렇게 할 수 있죠.\n\n```js\nmodule.exports = {\n  images: {\n    formats: ['image/avif', 'image/webp'],\n  },\n}\n```\n\n이렇게 하면 AVIF를 우선 시도하고, 지원하지 않으면 webp, 또 그마저 지원하지 않으면 원본 이미지로 자동으로 fallback 해준답니다.\n\n요즘은 이미지 최적화를 하는 게 페이지 로딩 속도 개선에 큰 도움이 되니까, 이런 포맷 지정은 꼭 활용해보길 추천해요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003e 참고할 점:\n대부분의 경우에는 여전히 WebP 형식을 사용하는 것을 추천해요.\nAVIF는 인코딩하는 데 WebP보다 약 50% 더 시간이 걸리지만, 압축률은 약 20% 더 좋아서 파일 크기가 더 작아진답니다. 그래서 이미지를 처음 요청할 때는 속도가 조금 느릴 수 있지만, 캐시된 이후에는 훨씬 빠르게 로드돼요.\n만약 Next.js 앞에 Proxy나 CDN을 직접 운영한다면, 반드시 Proxy가 `Accept` 헤더를 전달하도록 설정해줘야 해요. 이 부분을 놓치면 최적화된 이미지가 제대로 제공되지 않을 수 있거든요.\n\n## 캐싱 동작 방식\n\n기본 이미지 로더의 캐싱 알고리즘은 다음과 같아요. 다른 로더를 사용한다면 클라우드 제공업체의 문서를 참고하는 게 좋아요.\n\n이미지는 요청 시 동적으로 최적화되고, 프로젝트의 `distDir/cache/images` 디렉터리에 저장돼요. 이렇게 최적화된 이미지는 만료 시간이 도달할 때까지 이후 요청에 동일하게 제공됩니다. 만약 요청한 이미지가 캐시돼있지만 만료되었다면, 서버는 만료된(오래된) 이미지를 바로 보여주고, 백그라운드에서는 이미지를 다시 최적화(재검증)해서 새 캐시와 만료 시간으로 업데이트합니다.\n\n---\n\n이렇게 하면 처음 사용자에게도 최소한의 지연만 주면서 최신 이미지를 유지하는 효율적인 캐싱 전략이 구현되는 거죠. 실제로 운영할 때는 압축률과 인코딩 속도, 그리고 캐시 만료 정책을 적절히 조절하는 게 중요해요. CDN이나 프록시를 쓴다면, `Accept` 헤더가 제대로 전달되는지 꼭 확인해서 원하는 포맷으로 이미지를 제공받도록 하는 것도 핵심입니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이미지 캐시 상태를 확인할 때는 `x-nextjs-cache`라는 응답 헤더 값을 보면 됩니다. 이 헤더가 가리키는 값은 보통 다음 세 가지 중 하나예요:\n\n| 캐시 상태 | 설명 |\n|------------|---------|\n| MISS | 경로가 캐시에 없다는 뜻이에요. 보통 이건 처음 한번, 첫 방문할 때 발생해요. |\n| STALE | 경로가 캐시에 있긴 한데, 재검증(revalidate) 시간이 초과돼서 백그라운드에서 업데이트가 진행 중인 경우입니다. |\n| HIT | 경로가 캐시에 있고, 재검증 시간이 지나지 않았을 때를 의미해요. |\n\n캐시 만료 시간(정확히 말하면 Max Age)은 `minimumCacheTTL` 설정값과 업스트림 이미지의 `Cache-Control` 헤더 중 더 큰 값으로 정해집니다. 여기서 `Cache-Control` 헤더의 `max-age` 값을 기준으로 하는데, 만약 `s-maxage`와 `max-age` 둘 다 있으면 `s-maxage`가 우선입니다. 그리고 이 `max-age` 값은 CDN이나 브라우저 같은 하위 클라이언트에게도 그대로 전달돼요.\n\n그리고 몇 가지 팁을 드리면:\n\n- `minimumCacheTTL`을 설정하면, 업스트림 이미지에서 Cache-Control 헤더가 없거나 너무 낮을 때 캐시 지속 시간을 인위적으로 늘릴 수 있어요.\n- `deviceSizes`와 `imageSizes`를 잘 설정해서 생성되는 이미지 종류(사이즈)를 줄이면 서버의 부하도 줄이고 캐시 효율도 높일 수 있어요.\n- `formats` 설정으로 여러 이미지 포맷 생성을 끄고, 한 가지 포맷만 사용하도록 할 수도 있어요. 이건 클라이언트의 호환성이나 트래픽 관리에 도움됩니다.\n\n이렇게 캐시 설정을 적절히 조절하면, 이미지 로딩 속도 향상과 서버 비용 절감 두 마리 토끼를 잡을 수 있으니, 꼭 한 번 살펴보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### minimumCacheTTL\n\n이미지 최적화 캐시의 TTL(Time to Live), 즉 이미지가 캐시에서 살아있는 시간을 초 단위로 설정할 수 있어요. \n\n사실 대부분의 경우에는 **Static Image Import** 방식을 쓰는 게 더 좋아요. 이 방법은 파일 내용을 자동으로 해시(hash)해서 캐시를 사실상 영구적으로 유지하는 효과가 있고, `Cache-Control` 헤더에 `immutable`이 설정돼서 브라우저가 굳이 자주 새로 다운로드하지 않게 해주거든요.\n\n만약 따로 설정하지 않으면 기본값으로 아래 설정이 사용됩니다.\n\n```js\nmodule.exports = {\n  images: {\n    minimumCacheTTL: 60, // 1분 간 캐시 유지\n  },\n}\n```\n\n### 추가 팁!\n\n- TTL을 너무 짧게 하면 캐시를 자주 새로 받아서 서버 부하가 늘어나고, 반대로 너무 길게 설정하면 오래된 이미지가 사용될 수도 있어요.\n- 그래서 가능하면 정적 이미지(import 방식)를 활용하는 게 좋고, 동적으로 변경될 가능성이 있는 이미지만 TTL을 적절히 조절하는 방식을 추천드립니다.\n- 만약 이미지가 자주 변경되는 편이라면 TTL을 짧게, 그렇지 않으면 길게 잡는 게 무난해요.\n\n이렇게 적절한 캐시 설정으로 웹사이트 속도와 사용자 경험을 더 좋게 만들어 보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이미지 최적화할 때 TTL(Time To Live)을 늘려서 재검증(revalidation) 횟수를 줄이고, 그 결과 비용 절감 효과를 기대할 수 있어요. 예를 들어, Next.js 내 설정 파일에서 이렇게 써주면 돼요:\n\n```js\nmodule.exports = {\n  images: {\n    minimumCacheTTL: 2678400, // 31일 (초 단위)\n  },\n};\n```\n\n여기서 `minimumCacheTTL`은 이미지가 캐시에 머무르는 최소 시간을 의미해요. 최적화된 이미지의 만료 시간(또는 Max Age)은 이 값과 원본 이미지 서버가 보내는 `Cache-Control` 헤더 중 더 긴 쪽을 따르게 됩니다.\n\n만약 이미지마다 캐싱 정책을 다르게 하고 싶다면, 최적화 요청이 가는 `/_next/image` 경로가 아니라 원본 이미지 경로(예: `/some-asset.jpg`)에 직접 `Cache-Control` 헤더를 설정해야 합니다. 그렇지 않으면 모든 이미지가 같은 캐시 정책을 따르게 돼요.\n\n참고로, TTL을 너무 길게 잡으면 업데이트된 이미지가 바로 반영되지 않을 수 있으니, 상황에 맞게 적절한 기간을 선택하는 게 좋아요. 개발 중에는 짧게, 배포 환경에선 길게 설정하는 방식도 괜찮겠죠? 그리고 이미지 캐싱 전략은 비용뿐만 아니라 사용자 경험에도 큰 영향을 주니 신중하게 고민해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지금은 캐시를 무효화할 수 있는 별도의 방법이 없기 때문에, minimumCacheTTL 값을 낮게 설정하는 게 좋아요. 그렇지 않으면 src 속성을 직접 변경하거나, `distDir`/cache/images 폴더를 수동으로 삭제해야 할 수도 있어요.\n\n### disableStaticImages\n\n기본 설정으로는 `import icon from './icon.png'`처럼 정적 파일을 임포트해서 src 속성에 바로 전달할 수 있어요.\n\n하지만 어떤 경우에는, 다른 플러그인과 충돌이 일어나서 임포트가 다르게 동작해야 할 때가 있어요. 그럴 때 이 기능을 끄는 옵션이 바로 `disableStaticImages`입니다.\n\n---\n\n한 가지 팁을 더 드리자면, 이미지 캐시를 적절히 관리하지 않으면 개발 중에 변경 사항이 바로 반영되지 않아 꽤 답답할 수 있어요. 그래서 개발 모드에서는 캐시 TTL을 낮게 설정하거나, 필요할 땐 수동으로 캐시를 삭제하는 습관을 들이면 좋습니다. 또한, 플러그인 간 충돌을 미리 파악해서 `disableStaticImages` 옵션을 활용하면 예상치 못한 문제도 피할 수 있답니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 static 이미지 임포트를 비활성화하고 싶다면, `next.config.js` 파일에 아래와 같이 설정할 수 있어요:\n\n```js\nmodule.exports = {\n  images: {\n    disableStaticImages: true,\n  },\n}\n```\n\n이 설정을 하면 정적 이미지 임포트를 끄게 되어, 이미지 파일들을 직접 import 하는 방식 대신 다른 방법으로 이미지를 다루게 돼요. 예를 들어, public 폴더에 이미지를 두고 경로로만 접근하는 방식이죠.\n\n---\n\n### dangerouslyAllowSVG 옵션에 대해\n\nNext.js 기본 이미지 로더는 SVG 최적화를 지원하지 않는데, 그 이유는 두 가지가 있어요.\n\n1. **SVG는 벡터 이미지라서 크기를 조절해도 화질 손실이 없어요.** 그렇기 때문에 변형 과정이 딱히 필요 없죠.\n2. **SVG 파일은 HTML/CSS와 비슷한 특성을 갖고 있어서, 제대로 된 Content Security Policy(CSP) 헤더 없이는 보안 취약점이 생길 수 있어요.**\n\n그래서 `dangerouslyAllowSVG` 옵션이 있긴 하지만, 이걸 사용할 땐 보안에 특히 신경 써야 해요. SVG를 사용하면서 보안 문제가 걱정된다면, SVG를 컴포넌트 형태로 다루거나 외부에서 안전하게 처리한 뒤 사용하는 걸 추천합니다.\n\n---\n\n### 추가 팁!\n\n- 만약 SVG를 React 컴포넌트처럼 사용하고 싶다면, `@svgr/webpack`을 쓰는 방법도 있어요. 이걸 쓰면 SVG를 import 해서 SVG 컴포넌트로 만들 수 있죠.\n- 그리고 이미지 최적화는 Next.js 이미지 컴포넌트의 핵심 기능 중 하나니까, 가능하면 static 이미지 임포트 기능을 끄기보다는 제대로 활용하는 걸 추천해요.\n\n이런 설정 하나하나 이해하고 적용하다 보면 Next.js에서 이미지 다루는 법에 자신감이 생길 거예요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그래서 src 속성이 SVG임이 확실할 때는 unoptimized 속성을 사용하는 걸 추천해요. 실제로 src가 \".svg\"로 끝날 때는 이 부분이 자동으로 적용됩니다.\n\n하지만 만약 기본 이미지 최적화 API를 사용해서 SVG 이미지를 제공해야 한다면, next.config.js 파일 안에 dangerouslyAllowSVG 옵션을 설정할 수 있어요:\n\n```js\nmodule.exports = {\n  images: {\n    dangerouslyAllowSVG: true,\n    contentDispositionType: 'attachment',\n    contentSecurityPolicy: \"default-src 'self'; script-src 'none'; sandbox;\",\n  },\n}\n```\n\n여기서 주의할 점은, SVG 이미지가 종종 악성 스크립트를 포함할 수 있어서 보안 면에서 취약할 수 있다는 거예요. 그래서 contentDispositionType을 'attachment'로 설정해서 브라우저가 이미지를 그냥 보여주는 게 아니라 다운로드하도록 강제하는 걸 추천하고, contentSecurityPolicy를 지정해서 이미지 안에 숨어있는 스크립트가 실행되지 못하도록 막는 것이 매우 중요하답니다.\n\n참고로, SVG는 벡터 이미지라서 해상도에 상관없이 선명한 장점이 있지만, 안전하지 않은 SVG를 그대로 사용하면 XSS 공격에 노출될 수 있으니, 가능하면 신뢰할 수 있는 SVG만 쓰거나 이런 보안 설정을 꼭 해주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### contentDispositionType\n\n기본적으로 이미지 로더(loader)는 `Content-Disposition` 헤더를 `attachment`로 설정합니다. 이 설정이 중요한 이유는 API가 원격 이미지를 임의로 불러올 수 있기 때문에 보안을 강화하기 위해서예요.\n\n| 설정값     | 설명                                      |\n|------------|-------------------------------------------|\n| attachment | 브라우저가 이미지를 직접 방문하면 다운로드하도록 강제함 (기본값) |\n| inline     | 브라우저가 이미지를 직접 방문했을 때 바로 렌더링해서 보여줌     |\n\n특히, `dangerouslyAllowSVG` 옵션이 켜져 있을 경우 `attachment`로 설정하는 것이 더 안전합니다. SVG 파일은 악성코드로 악용될 수 있기 때문에, 무조건 다운받게 만들어서 브라우저가 바로 실행하지 못하게 하는 거죠.\n\n하지만 경우에 따라서는 직접 이미지를 방문했을 때 다운로드 받는 게 아니라 바로 화면에 표시되길 원할 수도 있어요. 이런 때는 `contentDispositionType`을 `inline`으로 설정하면 됩니다. 그러면 URL을 브라우저에 직접 입력했을 때도 이미지가 바로 보이게 되죠.\n\n---\n\n### 추가 팁!\n\n- 만약 내 서비스에서 외부에서 임의로 이미지를 불러오는걸 허용한다면, 보안에 신경 써서 꼭 `attachment`로 두세요.\n- SVG는 특히 조심해야 하니, 내장 SVG가 아닌 외부 SVG를 불러올 때는 `inline`보다는 `attachment`를 추천해요.\n- 하지만 사용자 경험(UX)을 고려해 이미지 바로 보기가 자주 필요한 서비스라면 `inline` 설정을 고려해볼 수 있습니다. 이럴 땐 SVG 보안 이슈도 신경 써주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자, 이번에는 Next.js에서 이미지 최적화와 애니메이션 이미지 다루는 방법에 대해 살펴볼게요.\n\n```js\nmodule.exports = {\n  images: {\n    contentDispositionType: 'inline',\n  },\n}\n```\n\n위 설정 코드는 이미지 응답 시 `Content-Disposition` 헤더를 'inline'으로 설정해주는 거예요. 이렇게 하면 브라우저가 이미지를 다운로드하지 않고, 바로 화면에 표시하도록 하는 역할을 해요. 이미지를 웹페이지 내에서 자연스럽게 보여주고 싶을 때 유용하죠.\n\n---\n\n## 애니메이션 이미지 처리\n\nNext.js의 기본 이미지 로더는 애니메이션이 들어간 이미지(예: GIF, APNG, WebP)가 들어오면 자동으로 이미지 최적화를 건너뛰고 원본 그대로 이미지를 서빙해줍니다. 왜냐면 애니메이션 이미지 최적화는 조금 까다롭고, 최적화 과정에서 애니메이션이 깨질 위험이 있거든요.\n\n자동으로 애니메이션인지 판단하는 기능은 완벽하진 않지만, 대부분의 경우 GIF, APNG, WebP 파일 포맷을 기준으로 잘 감지해 줍니다.\n\n만약 특정 애니메이션 이미지에 대해서 확실하게 최적화를 건너뛰고 싶다면, Next.js의 `Image` 컴포넌트에 `unoptimized` 속성을 추가해주면 돼요.\n\n```jsx\nimport Image from 'next/image'\n\nexport default function MyComponent() {\n  return (\n    \u003cImage\n      src=\"/animated-image.gif\"\n      alt=\"애니메이션 이미지\"\n      width={500}\n      height={300}\n      unoptimized // 이 속성 덕분에 해당 이미지는 최적화 없이 바로 서빙됩니다.\n    /\u003e\n  )\n}\n```\n\n### 추가 팁!\n\n- GIF 대신 WebP 포맷으로 애니메이션 이미지를 사용하는 것도 좋은 방법이에요. WebP는 파일 크기는 훨씬 작으면서도 화질을 잘 유지하거든요.\n- Next.js에서 자동 최적화를 사용하면 성능이 좋아지지만, 애니메이션 이미지 때문에 어쩔 수 없이 건너뛰는 경우가 있으니, 애니메이션 이미지가 많다면 CDN 또는 별도의 외부 이미지 서버를 사용하는 것도 고려해보세요.\n\n---\n\n요약하면, Next.js는 애니메이션 이미지에 대해 친절한 자동 최적화를 제공하지만, 100% 완벽하진 않아서 직접 `unoptimized` 플래그를 활용하는 게 좋고, `contentDispositionType: 'inline'` 설정으로 이미지를 웹 내에서 부드럽게 다룰 수 있다는 이야기였습니다!\n\n필요하면 언제든지 더 구체적인 사용법도 알려드릴게요 :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 반응형 이미지 만들기\n\n웹 개발하다 보면 다양한 기기별 해상도를 지원하기 위해 이미지도 그에 맞게 잘 보여줘야 할 때가 많죠. 기본적으로 srcset 속성에는 1x, 2x 해상도 이미지가 들어가서 화면의 픽셀 밀도에 맞춰 이미지를 바꿔주는데요. 하지만, 뷰포트 크기에 따라 이미지 크기도 유동적으로 바꾸고 싶다면, srcset 뿐만 아니라 sizes 속성도 함께 설정해줘야 합니다. 그리고 스타일이나 className으로 이미지 크기를 조정하는 것도 중요하죠.\n\n아래는 반응형 이미지를 만드는 몇 가지 방법 중 하나인 '정적 import 사용하기' 예시입니다.\n\n---\n\n### 정적 임포트로 반응형 이미지 만들기\n\nReact나 Next.js 같은 환경에서 자주 쓰이는 방식인데요, 이미지를 프로젝트 안에서 import 해서 쓸 때 유용합니다.\n\n```jsx\nimport responsiveImg from '../public/images/responsive-image.jpg';\n\nexport default function MyComponent() {\n  return (\n    \u003cimg\n      src={responsiveImg.src}\n      srcSet={`${responsiveImg.src} 1x, ${responsiveImg.src.replace('.jpg', '@2x.jpg')} 2x`}\n      sizes=\"(max-width: 600px) 100vw, 50vw\"\n      style={{ width: '100%', height: 'auto' }}\n      alt=\"Responsive example\"\n    /\u003e\n  );\n}\n```\n\n---\n\n여기서 sizes 속성은 뷰포트 너비가 600px 이하일 때 이미지가 화면 너비(100vw)의 100%를 차지하고, 그 이상일 땐 50%를 차지하도록 지정하는 거예요. 이렇게 하면 작은 화면에선 이미지가 꽉 차 보이고, 큰 화면에선 절반 크기로 나란히 배치하기 좋아요.\n\n그리고 style이나 className으로 `width: 100%`를 주면 이미지가 부모 컨테이너의 크기에 맞게 늘어나거나 줄어듭니다. height는 auto로 하면 비율이 유지돼서 이미지가 찌그러지지 않죠.\n\n---\n\n**팁!**  \n- 이미지를 더 다양하게 반응형으로 다루고 싶으면 picture 태그와 함께 여러 해상도, 형식(webp, jpeg 등)을 srcSet에 넣어주는 것도 좋은 방법이에요.  \n- Next.js를 쓰는 분들이라면 내장된 Image 컴포넌트를 활용하면 알아서 최적화 해주니 더 쉽게 반응형 이미지를 만들 수 있습니다.\n\n이제 images 태그만 써도 다양한 기기에서 딱 예쁘게 보여줄 수 있으니 꼭 sizes값과 css 조합도 함께 고려해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 이미지가 정적(변하지 않는) 소스라면, 이렇게 statically import해서 반응형 이미지(Responsive Image)를 쉽게 만들 수 있어요:\n\n```js\nimport Image from 'next/image'\nimport me from '../photos/me.jpg'\n\nexport default function Author() {\n  return (\n    \u003cImage\n      src={me}\n      alt=\"Picture of the author\"\n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }}\n    /\u003e\n  )\n}\n```\n\n이 코드에서 중요한 점은 `sizes=\"100vw\"`예요. 이 설정 덕분에 이미지가 뷰포트(Viewport) 너비 100%에 맞춰서 크기가 조절돼요. 그리고 `style`로 `width: '100%'` 그리고 `height: 'auto'`를 줘서 이미지 비율을 유지하며 폭에 맞게 크기가 변하게 됩니다.\n\n---\n\n### 왜 이렇게 하는 걸까?\n\n- **정적 import**는 번들링할 때 이미지 정보를 미리 알아서, 최적화된 사이즈를 자동으로 만들어줘서 페이지 로딩 속도가 빨라져요.\n- `next/image` 컴포넌트 자체가 여러 크기의 이미지를 제공해주고, 뷰포트에 따라 적절한 사이즈의 이미지를 불러오기 때문에 데이터 사용량도 줄일 수 있답니다.\n- `sizes` 속성은 반응형 이미지에서 어떤 폭에서 이미지를 얼마나 크게 보여줄 지 브라우저에 알려주는 역할을 해요. \n\n---\n\n### 한번 해보세요!\n\n위 코드를 페이지에 넣고 브라우저 창 크기를 조절해서 이미지가 폭에 맞춰 잘 변하는지 확인해 보면 정말 반응형 이미지임을 체감할 수 있을 거예요.\n\n---\n\n만약 이미지를 동적으로 불러야 한다면, 다음 시간에 그 방법도 알려드릴게요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 반응형 이미지에 비율 맞추기\n\n웹에서 이미지를 쓸 때 특히 원본 이미지가 동적이거나 외부 URL일 경우, 반응형으로 잘 보여주려면 이미지의 가로(width)와 세로(height)를 꼭 지정해줘야 해요. 그래야 이미지가 비율을 유지하면서 화면 크기에 맞게 조절되거든요.\n\nNext.js의 `next/image` 컴포넌트를 예로 들어볼게요.\n\n```js\nimport Image from 'next/image'\n\nexport default function Page({ photoUrl }) {\n  return (\n    \u003cImage\n      src={photoUrl}            // 동적 혹은 외부 주소로 이미지 호출\n      alt=\"Picture of the author\"\n      sizes=\"100vw\"             // 화면 전체 폭에 맞춰서 크기를 조절\n      style={{\n        width: '100%',          // 가로는 부모 컨테이너에 딱 맞게\n        height: 'auto',         // 세로는 비율에 맞게 자동 조절\n      }}\n      width={500}               // 이미지의 원본 가로 크기\n      height={300}              // 이미지의 원본 세로 크기\n    /\u003e\n  )\n}\n```\n\n여기서 `width={500}`과 `height={300}`은 원본 이미지의 가로, 세로 크기를 나타내고, `style`에서 `width: 100%`로 설정해주면 화면 크기에 딱 맞춰서 이미지 크기가 바뀌면서도 가로세로 비율이 깨지지 않아요.\n\n\u003e 실제로 `next/image`는 `width`, `height` 정보가 있어야 이미지 사이즈 계산과 레이아웃 잡는 데 도움을 줘서 CLS(Cumulative Layout Shift) 같은 레이아웃 깨짐 문제도 예방할 수 있답니다.\n\n---\n\n추가로, 반응형 이미지를 만들 때 기억하면 좋은 점!\n\n| 팁 | 설명 |\n| --- | --- |\n| `sizes` 속성 | 뷰포트(viewport) 크기에 따라 어떤 크기의 이미지를 로딩할지 브라우저에 알려줍니다. `100vw`는 화면 전체 너비를 뜻해요. |\n| `style` | CSS로 가로 세로 비율을 조절하지만 원본 비율과 다르면 이미지가 찌그러질 수 있어 비율 맞추는 게 중요해요. |\n| 원본 크기 지정 | `width`와 `height`를 지정해야 브라우저가 최적의 이미지를 불러오고 레이아웃이 안정적이에요! |\n\n필요하다면, CSS로 부모 요소에 `max-width`를 정해서 너무 커지지 않도록 제한하는 것도 좋아요.\n\n오늘은 이렇게 동적 이미지로 반응형 이미지를 깔끔하게 다루는 방법을 알아봤어요. 실무에서 꽤 자주 쓰이니 한번 써보시면서 감 잡아보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 뷰포트에 반응하는 이미지 데모\n\n#### 이미지의 가로세로 비율(aspect ratio)을 모를 때 - `fill` 속성 활용법\n\n이미지를 반응형으로 만들고 싶은데, 이미지의 정확한 가로세로 비율을 모를 경우가 있죠? 그럴 땐 부모 요소에 `position: relative`를 주고, Next.js의 `Image` 컴포넌트에 `fill` 속성을 사용하면 꽉 차게 이미지가 들어가요. 이때 `object-fit` 스타일로 이미지가 어떻게 맞춰질지 정할 수 있는데, `'contain'`으로 하면 이미지가 찌그러지거나 잘리지 않고 꽉 차도록 조절해 줍니다.\n\n아래 예시 코드를 보시면 이해가 빠르실 거에요:\n\n```jsx\nimport Image from 'next/image'\n\nexport default function Page({ photoUrl }) {\n  return (\n    \u003cdiv style={{ position: 'relative', width: '300px', height: '500px' }}\u003e\n      \u003cImage\n        src={photoUrl}\n        alt=\"Picture of the author\"\n        sizes=\"300px\"\n        fill\n        style={{\n          objectFit: 'contain',\n        }}\n      /\u003e\n    \u003c/div\u003e\n  )\n}\n```\n\n- `div`에 `position: relative`를 줘야 `fill`로 설정된 이미지가 부모 영역을 기준으로 꽉 채울 수 있어요.\n- `width`와 `height`를 고정 또는 반응형 단위로 지정해주면 이미지 크기가 결정되고, 그 안에서 `fill`이 동작하는 거죠.\n- `objectFit`을 `'contain'`으로 하면 이미지가 영역 내에 꽉 차면서 비율이 유지되고, `'cover'`로 설정하면 영역을 가득 채우되 일부 잘릴 수도 있습니다.\n\n\u003e 추가 팁!  \n\u003e 만약 이미지가 부모 크기에 맞춰 유연하게 크기가 변하길 원한다면, 부모 요소를 미디어 쿼리나 CSS 그리드/플렉스를 활용해 동적으로 크기를 조절하는 방법도 있어요. 그러면 `fill`과 함께 더 자연스러운 반응형 이미지를 구현할 수 있습니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n한번 해볼까요?\n\n- fill prop을 활용하는 데모\n\n## 테마 감지 CSS\n\n웹사이트를 만들 때, 라이트 모드와 다크 모드에 따라 다른 이미지를 보여주고 싶을 때가 있죠? 이럴 때는 두 개의 `Image` 컴포넌트를 감싸는 새로운 컴포넌트를 만들어서 CSS 미디어 쿼리를 활용해 적절한 이미지만 보여주도록 할 수 있어요.\n\n예를 들어, CSS의 `prefers-color-scheme` 미디어 쿼리를 사용하면 사용자가 설정한 테마(라이트 or 다크)에 따라 다른 스타일이나 이미지를 적용할 수 있답니다. 이를 이용하면 자바스크립트로 복잡한 조건문을 작성하지 않아도, 아주 깔끔하게 테마별 이미지를 처리할 수 있어요.\n\n아래는 이 개념을 활용한 간단한 예시입니다.\n\n```jsx\nimport Image from 'next/image';\n\nconst ThemeImage = () =\u003e {\n  return (\n    \u003c\u003e\n      \u003cImage\n        src=\"/images/light-mode.png\"\n        alt=\"라이트 모드 이미지\"\n        className=\"light-image\"\n        width={200}\n        height={200}\n      /\u003e\n      \u003cImage\n        src=\"/images/dark-mode.png\"\n        alt=\"다크 모드 이미지\"\n        className=\"dark-image\"\n        width={200}\n        height={200}\n      /\u003e\n      \u003cstyle jsx\u003e{`\n        .light-image {\n          display: block;\n        }\n        .dark-image {\n          display: none;\n        }\n        @media (prefers-color-scheme: dark) {\n          .light-image {\n            display: none;\n          }\n          .dark-image {\n            display: block;\n          }\n        }\n      `}\u003c/style\u003e\n    \u003c/\u003e\n  );\n};\n\nexport default ThemeImage;\n```\n\n위 코드에서는 기본적으로 라이트 모드 이미지를 보여주고, 다크 모드가 감지되면 다크 모드 이미지만 보이도록 CSS로 조절해줍니다.\n\n----\n\n추가로 팁 하나!\n\n만약 이미지가 너무 많아서 이렇게 일일이 컴포넌트를 만들기 번거롭다면, [picture 태그](https://developer.mozilla.org/ko/docs/Web/HTML/Element/picture)와 `source` 태그를 활용하는 방법도 있어요. `source`의 `media` 속성에 `prefers-color-scheme` 조건을 넣으면 브라우저가 자동으로 맞는 이미지를 골라줍니다.\n\n```jsx\n\u003cpicture\u003e\n  \u003csource srcSet=\"/images/dark-mode.png\" media=\"(prefers-color-scheme: dark)\" /\u003e\n  \u003cimg src=\"/images/light-mode.png\" alt=\"테마별 이미지\" width={200} height={200} /\u003e\n\u003c/picture\u003e\n```\n\n이렇게 하면 자바스크립트나 추가 CSS 없이도 손쉽게 테마별 이미지를 관리할 수 있어서 더 깔끔하니 참고해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번 시간에는 다크모드 지원을 할 때 이미지도 알아서 라이트모드용, 다크모드용 이미지를 잘 보여주게 하는 간단한 방법을 소개해 드릴게요. CSS와 Next.js를 함께 활용한 스타일링과 컴포넌트 설계법을 보면서, 실제로 어떻게 이미지 로딩이 최적화되는지도 짚어보려 합니다.\n\n---\n\n### 1. CSS로 다크모드에 따라 보이기/숨기기 설정하기\n\n```css\n.imgDark {\n  display: none;\n}\n\n@media (prefers-color-scheme: dark) {\n  .imgLight {\n    display: none;\n  }\n  .imgDark {\n    display: unset;\n  }\n}\n```\n\n- `.imgDark` 이미지는 기본적으로 숨겨져 있어요.\n- 사용자의 OS나 브라우저가 다크모드를 감지하면(`prefers-color-scheme: dark`), `.imgLight` 이미지는 숨기고 `.imgDark` 이미지는 보여주게 됩니다.\n\n이렇게만 해줘도 다크모드 감지 시 자동으로 이미지를 바꿔서 보여줄 수 있죠.\n\n---\n\n### 2. Next.js 컴포넌트로 깔끔하게 관리하기\n\n```tsx\nimport styles from './theme-image.module.css'\nimport Image, { ImageProps } from 'next/image'\n\ntype Props = Omit\u003cImageProps, 'src' | 'priority' | 'loading'\u003e \u0026 {\n  srcLight: string\n  srcDark: string\n}\n\nconst ThemeImage = (props: Props) =\u003e {\n  const { srcLight, srcDark, ...rest } = props\n\n  return (\n    \u003c\u003e\n      \u003cImage {...rest} src={srcLight} className={styles.imgLight} /\u003e\n      \u003cImage {...rest} src={srcDark} className={styles.imgDark} /\u003e\n    \u003c/\u003e\n  )\n}\n```\n\n- Next.js의 `Image` 컴포넌트를 한 번에 두 개 넣고, CSS로 어느 이미지를 보여줄지 제어하는 방식입니다.\n- `Priority`나 `loading=\"eager\"`를 쓰면 이미지가 모두 로드되어 버려서 비효율적이므로 **기본 `loading=\"lazy\"` 속성을 이용**하거나 **`fetchPriority=\"high\"`**를 활용하세요.\n\n---\n\n### 3. 핵심 포인트: 이미지 로딩 최적화\n\n| 고려사항                 | 설명                                                         |\n|------------------------|------------------------------------------------------------|\n| 기본 로딩 방식            | `loading=\"lazy\"`는 스크롤 등 사용자 행동에 맞게 이미지를 불러옵니다. 이 덕분에 안 보이는 이미지는 바로 로드되지 않아요.  |\n| `priority` 속성 사용 제한 | 라이트/다크용 이미지가 동시에 로드되기 때문에 `priority`를 쓰면 번거로워질 수 있습니다.                     |\n| `fetchPriority` 활용      | Next.js 13부터 새로 도입된 `fetchPriority=\"high\"`를 이용하면 우선순위 지정이 가능하지만, 옮겨서 써야 하는 상황이라는 점 참고! |\n\n---\n\n### 간단 요약\n\n- CSS 미디어 쿼리로 라이트/다크 이미지를 제어하자.\n- `next/image`를 두 개 겹쳐서 쓰되, 실제 보여줄 이미지만 노출되도록 CSS로 관리하자.\n- 불필요한 이미지 로딩을 막기 위해 기본 `loading=\"lazy\"`를 사용하자. 필요할 땐 `fetchPriority=\"high\"`도 써보자.\n\n---\n\n### 덧붙여서 알려드리는 팁!\n\n- 만약 이미지가 너무 많거나 용량이 크다면, 라이트/다크 모드 전환 시 자바스크립트로 이미지를 동적으로 교체하는 방법도 고려할 수 있습니다.\n- 또 CSS `image-set` 같은 기능도 사용해볼 수 있지만, 브라우저 지원이 조금씩 다르니 꼭 테스트하세요!\n\n---\n\n다크모드 시대에 잘 맞춰 사용자 경험을 선물해주는 테마별 이미지 처리, 어렵지 않지요? 직접 코드를 돌려보면서 이미지 교체가 매끄럽게 되는 걸 느껴보시면 이해가 훨씬 쉬워집니다.\n\n그럼 즐거운 개발 하세요! 🚀\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 데모: 라이트/다크 모드 테마 감지\n\n## getImageProps 함수\n\n조금 더 고급 활용법을 원할 때는 getImageProps() 함수를 호출해서, 실제 `img` 태그에 들어갈 props들을 받아올 수 있어요. 그리고 이 props들을 다른 컴포넌트나 스타일, 혹은 캔버스 등에 넘겨서 자유롭게 사용할 수 있죠.\n\n이 방법의 좋은 점은 React의 useState()를 사용하지 않기 때문에 퍼포먼스가 좀 더 좋아질 수 있다는 거예요. (useState를 쓰면 상태 변경으로 리렌더링이 발생할 수 있거든요.) 하지만 여기서 주의할 점은 placeholder prop과 함께 사용할 수 없다는 겁니다! 왜냐하면 placeholder가 한 번 설정되면 절대 사라지지 않거든요.\n\n즉, 이미지 로딩 상태를 직접 관리하거나, 커스텀한 방식으로 이미지를 표시하고 싶을 때 이 함수를 쓰면 꽤 유용하겠죠? 다만, 나중에 placeholder 효과를 구현하고 싶다면 다른 방법을 고민해야 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 테마 감지용 이미지 바꾸기\n\n웹사이트를 만들 때, 라이트 모드와 다크 모드에 따라 다른 이미지를 보여주고 싶을 때가 있죠? 이럴 때 유용한 방법이 바로 `picture` 태그를 활용하는 거예요. 사용자 브라우저가 선호하는 색상 모드(라이트/다크)를 감지해서 그에 맞는 이미지를 자동으로 보여줄 수 있답니다.\n\n아래는 Next.js에서 `next/image`의 `getImageProps`를 활용해, 라이트/다크 모드별로 서로 다른 이미지를 설정하는 예시 코드입니다.\n\n```jsx\nimport { getImageProps } from 'next/image'\n\nexport default function Page() {\n  const common = { alt: 'Theme Example', width: 800, height: 400 }\n\n  const {\n    props: { srcSet: dark },\n  } = getImageProps({ ...common, src: '/dark.png' })\n\n  const {\n    props: { srcSet: light, ...rest },\n  } = getImageProps({ ...common, src: '/light.png' })\n\n  return (\n    \u003cpicture\u003e\n      \u003csource media=\"(prefers-color-scheme: dark)\" srcSet={dark} /\u003e\n      \u003csource media=\"(prefers-color-scheme: light)\" srcSet={light} /\u003e\n      \u003cimg {...rest} /\u003e\n    \u003c/picture\u003e\n  )\n}\n```\n\n---\n\n### 여기서 알아두면 좋은 점!\n\n- **`picture` 태그**: 여러 이미지를 상황에 맞게 골라 보여주기 위해 쓰여요. `\u003csource\u003e`에 조건(미디어쿼리)을 걸고, 마지막 `\u003cimg\u003e` 태그가 기본 이미지 역할을 해주죠.\n- **`prefers-color-scheme` 미디어 쿼리**: 사용자 기기의 모드 설정을 감지해 `dark`나 `light` 여부를 판단해요.\n- **Next.js의 `getImageProps`**: 이미지를 최적화하고 메타 정보를 제공해서, 별도의 수동 작업 없이도 쉽게 이미지 관련 속성을 얻을 수 있어요.\n\n---\n\n### 추가 팁!\n\n1. 이미지 파일을 많이 만드는 게 번거롭다면, CSS 필터(예: `filter: invert(1)`)를 활용해 이미지 색상을 조절하는 방법도 있어요. 단, 복잡한 이미지엔 적용하기 어려울 수 있답니다.\n\n2. 다크 모드 이미지를 SVG로 만들면 색상 변경도 더 자유롭고, 용량도 줄일 수 있으니 참고하세요.\n\n3. `picture` 태그가 구형 브라우저에서는 지원되지 않을 수 있으니, 꼭 호환성 체크도 해보시면서 사용하시길 추천드립니다.\n\n---\n\n다음에는 ‘아트 디렉션’(Art Direction)을 위해서 어떻게 이미지 크기나 구성을 바꾸는지에 대해 다뤄볼게요! 디자인 변화에 따라 이미지를 컨트롤하는 재미난 방법들이 많이 있답니다. 기대해주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n데스크탑과 모바일에서 각각 다른 이미지를 보여주고 싶을 때, 흔히 'Art Direction(아트 디렉션)'이라고 불러요.  \n이럴 때는 `getImageProps()` 함수에 각 기기별로 다른 `src`, `width`, `height`, `quality` 값을 넘겨줘서 손쉽게 처리할 수 있답니다.\n\n아래 예제를 보면 조금 더 이해하기 쉬울 거예요:\n\n```jsx\nimport { getImageProps } from 'next/image'\n\nexport default function Home() {\n  const common = { alt: 'Art Direction Example', sizes: '100vw' }\n\n  // 데스크탑용 이미지 속성 가져오기\n  const {\n    props: { srcSet: desktop },\n  } = getImageProps({\n    ...common,\n    width: 1440,\n    height: 875,\n    quality: 80,\n    src: '/desktop.jpg',\n  })\n\n  // 모바일용 이미지 속성 가져오기\n  const {\n    props: { srcSet: mobile, ...rest },\n  } = getImageProps({\n    ...common,\n    width: 750,\n    height: 1334,\n    quality: 70,\n    src: '/mobile.jpg',\n  })\n\n  return (\n    \u003cpicture\u003e\n      \u003csource media=\"(min-width: 1000px)\" srcSet={desktop} /\u003e\n      \u003csource media=\"(min-width: 500px)\" srcSet={mobile} /\u003e\n      \u003cimg {...rest} style={{ width: '100%', height: 'auto' }} /\u003e\n    \u003c/picture\u003e\n  )\n}\n```\n\n`\u003cpicture\u003e` 태그와 `\u003csource\u003e`를 사용해서 화면 크기에 맞는 이미지를 선택하도록 해주는데요, 브라우저가 조건에 맞는 첫 번째 `\u003csource\u003e`를 찾아 이미지를 보여주고, 맞는 게 없으면 `\u003cimg\u003e` 태그에 있는 이미지가 기본으로 나옵니다.\n\n그리고 여기서 `getImageProps()`로 반환받은 `srcSet`은 여러 해상도 이미지를 브라우저가 자동으로 선택하게 도와줘서, 고해상도 기기에서도 선명한 이미지를 볼 수 있습니다.\n\n---\n\n### CSS 배경 이미지에 활용하기\n\n사실 이미지를 태그로만 쓰는 게 아니라, CSS `background-image`로도 활용할 수 있어요.  \n이때 `srcSet` 문자열을 CSS의 `image-set()` 함수로 변환해서 반응형 배경 이미지를 만들 수 있답니다.\n\n예를 들어, 이렇게 쓸 수 있어요:\n\n```css\nbackground-image: image-set(\n  url('/image-1x.png') 1x,\n  url('/image-2x.png') 2x\n);\n```\n\n`image-set()` 함수는 해상도에 따라 다른 이미지를 로드하도록 도와주는데, 그렇게 하면 모바일과 데스크탑의 배경 이미지를 각각 최적화할 수 있어요.\n\n---\n\n### 이렇게 활용해보세요!\n\n- 이미지 용량과 해상도를 따로 조절해서 모바일에서는 가볍고, 데스크탑에서는 선명한 이미지를 제공할 수 있어요.\n- `\u003cpicture\u003e` 태그를 활용하면 SEO와 접근성에도 좋아요. `\u003cimg\u003e`의 `alt` 속성을 꼭 챙기는 것도 잊지 말고요!\n- CSS `image-set()`으로 배경 이미지에 반응형을 적용해보면 디자인 퀄리티가 더 좋아질 수 있답니다.\n\n이미지 아트 디렉션, 처음에는 조금 복잡해 보여도 차근차근 손에 익으면서 효과를 톡톡히 볼 수 있을 거예요.  \n필요하면 제가 배경 이미지용 `image-set()` 변환법도 예제로 한번 더 알려드릴게요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nJS와 Next.js의 next/image 컴포넌트를 활용해서 배경 이미지를 다루는 예제와, 관련한 브라우저 호환 이슈를 알아볼게요.\n\n---\n\n## 배경 이미지로 next/image srcSet 활용하기\n\n```js\nimport { getImageProps } from 'next/image';\n \nfunction getBackgroundImage(srcSet = '') {\n  const imageSet = srcSet\n    .split(', ')\n    .map((str) =\u003e {\n      const [url, dpi] = str.split(' ');\n      return `url(\"${url}\") ${dpi}`;\n    })\n    .join(', ');\n  return `image-set(${imageSet})`;\n}\n \nexport default function Home() {\n  const {\n    props: { srcSet },\n  } = getImageProps({ alt: '', width: 128, height: 128, src: '/img.png' });\n  \n  const backgroundImage = getBackgroundImage(srcSet);\n  \n  const style = { height: '100vh', width: '100vw', backgroundImage };\n \n  return (\n    \u003cmain style={style}\u003e\n      \u003ch1\u003eHello World\u003c/h1\u003e\n    \u003c/main\u003e\n  );\n}\n```\n\n### 설명을 덧붙이자면\n\n- `getImageProps`는 next/image가 이미지 로딩에 최적화된 속성들(`srcSet`, `src`, `sizes` 등)을 생성해주는 함수입니다.\n- 여기서는 `srcSet` 문자열을 받아서 CSS `image-set()` 구문에 맞게 변환해줍니다.\n- `image-set`은 여러 해상도에 맞는 이미지들을 선언해서 브라우저가 상황에 맞게 선택적으로 로딩할 수 있게 합니다.\n- 이걸 스타일 객체에 바로 `backgroundImage`로 넣어서 배경으로 활용하는 거죠.\n\n### 작은 팁!\n\n- CSS `image-set()` 지원은 아직 일부 브라우저에서 제한적이라 실제로 쓸 땐 호환성 체크 꼭 하세요.\n- 여기선 inline style로 썼지만, css-in-js나 external css로 작성하면 유지보수가 더 좋을 수 있어요.\n- next/image 기본 컴포넌트는 `\u003cimg\u003e` 태그에 최적화되어 있기 때문에 배경 이미지로 쓰긴 다소 변칙적이라, 상황에 따라 직접 이미지 태그를 쓰는 것도 고민해보세요.\n\n---\n\n## 알려진 브라우저 버그 및 주의점\n\n| 브라우저             | 이슈 내용                                               | 해결법 / 참고                                |\n|----------------------|--------------------------------------------------------|---------------------------------------------|\n| Safari 15 ~ 16.3     | 이미지 로딩 시 회색 테두리 표시                        | - CSS @supports로 특정 스타일 적용\u003cbr\u003e- `priority` 속성으로 위쪽 영역 이미지 우선 로딩 |\n| Safari \u003c 15.4         | native lazy loading 미지원 (eager fallback)            | 최신 버전으로 업데이트 권장                 |\n| Safari \u003c 12           | blur-up placeholder 빈 상태 fallback                   | blur-up 효과 대신 다른 placeholder 사용 고려|\n| Safari \u003c 15           | width/height auto 스타일 사용 시 레이아웃 시프트 발생 가능 | 고정 크기 사용 추천                          |\n| Firefox 67+           | 로딩 중 흰색 배경 표시                                  | - AVIF 포맷 활성화\u003cbr\u003e- placeholder 사용   |\n\n### 알아두면 좋은 점\n\n- Next.js의 next/image는 기본적으로 lazy loading을 지원하지만, 브라우저마다 native 지원 범위가 다릅니다.\n- 특히 구형 브라우저에서는 eager로 강제 변경되거나 placeholder가 제대로 보이지 않는 등 UX가 달라질 수 있어요.\n- blur-up placeholder 효과가 안되는 구형 사파리는 사용자 눈에 빈 화면이 되는 단점이 있습니다.\n- Firefox에서 흰색 배경 문제는 AVIF 사용 및 placeholder 설정으로 완화할 수 있으니 가능하면 이미지를 AVIF 포맷으로 변환하는 게 좋아요.\n- Layout Shift (레이아웃 변화)를 막으려면 기본적으로 이미지 영역의 크기를 미리 지정해주는 게 중요합니다.\n\n---\n\n### 마무리\n\nnext/image는 편리한 이미지 최적화 도구지만, 브라우저 별로 미묘한 차이가 있어서 꼼꼼한 테스트가 필요해요.  \n특히 배경 이미지로 변형하거나 레거시 브라우저를 지원한다면, 위 이슈들을 참고해서 적절히 대응하세요!\n\n더 궁금한 점 있으면 언제든 질문해 주세요~  \n개발할 때 자주 쓰는 팁도 하나씩 알려 드릴게요 :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 버전 히스토리\n\n| 버전        | 변경사항                                                                                                                         |\n|-------------|----------------------------------------------------------------------------------------------------------------------------------|\n| `v15.3.0`   | `remotePatterns`에서 `URL` 객체 배열을 지원하도록 추가됨.                                                                       |\n| `v15.0.0`   | `contentDispositionType` 설정 기본값이 `attachment`으로 변경됨.                                                                  |\n| `v14.2.23`  | `qualities` 설정이 추가됨.                                                                                                      |\n| `v14.2.15`  | `decoding` prop과 `localPatterns` 설정이 추가됨.                                                                                |\n| `v14.2.14`  | `remotePatterns.search` prop이 추가됨.                                                                                         |\n| `v14.2.0`   | `overrideSrc` prop이 추가됨.                                                                                                   |\n| `v14.1.0`   | `getImageProps()`가 안정화됨.                                                                                                  |\n| `v14.0.0`   | `onLoadingComplete` prop과 `domains` 설정이 deprecated됨.                                                                       |\n| `v13.4.14`  | `placeholder` prop이 `data:/image...` URI를 지원하도록 추가됨.                                                                    |\n| `v13.2.0`   | `contentDispositionType` 설정이 추가됨.                                                                                         |\n| `v13.0.6`   | `ref` prop이 추가됨.                                                                                                            |\n| `v13.0.0`   | - `next/image` 임포트가 `next/legacy/image`로 이름 변경됨.\u003cbr\u003e- `next/future/image` 임포트가 `next/image`로 이름 변경됨.\u003cbr\u003e- \u003ca href=\"/docs/app/guides/upgrading/codemods#next-image-to-legacy-image\"\u003e안전하고 자동으로 임포트를 변경해주는 codemod 제공\u003c/a\u003e.\u003cbr\u003e- `\u003cspan\u003e` 래퍼 제거.\u003cbr\u003e- `layout`, `objectFit`, `objectPosition`, `lazyBoundary`, `lazyRoot` prop 삭제.\u003cbr\u003e- `alt` prop 필수화.\u003cbr\u003e- `onLoadingComplete`이 `img` 엘리먼트 레퍼런스를 받음.\u003cbr\u003e- 기본 내장 로더 설정 제거됨. |\n| `v12.3.0`   | `remotePatterns` 및 `unoptimized` 설정이 안정화됨.                                                                              |\n| `v12.2.0`   | 실험적 `remotePatterns`와 `unoptimized` 설정 추가.\u003cbr\u003e`layout=\"raw\"` 삭제됨.                                                   |\n| `v12.1.1`   | `style` prop 추가.\u003cbr\u003e실험적 `layout=\"raw\"` 지원 추가.                                                                           |\n| `v12.1.0`   | `dangerouslyAllowSVG`와 `contentSecurityPolicy` 설정 추가됨.                                                                     |\n| `v12.0.9`   | `lazyRoot` prop 추가됨.                                                                                                         |\n| `v12.0.0`   | - `formats` 설정 추가.\u003cbr\u003e- AVIF 이미지 포맷 지원 추가.\u003cbr\u003e- 래퍼 엘리먼트가 `\u003cdiv\u003e`에서 `\u003cspan\u003e`으로 변경됨.                  |\n| `v11.1.0`   | `onLoadingComplete`과 `lazyBoundary` prop 추가됨.                                                                               |\n| `v11.0.0`   | - `src` prop이 정적 임포트를 지원.\u003cbr\u003e- `placeholder` prop 추가.\u003cbr\u003e- `blurDataURL` prop 추가.                                  |\n| `v10.0.5`   | `loader` prop 추가됨.                                                                                                           |\n| `v10.0.1`   | `layout` prop 추가됨.                                                                                                           |\n| `v10.0.0`   | `next/image` 컴포넌트 도입됨.                                                                                                  |\n\n---\n\n이렇게 버전별로 주요 업데이트가 정리되어 있으니, 특히 `v13`에서 큰 변화가 있었던 점 잊지 마세요! `alt`가 필수로 변경된 점이라든지 `next/image`의 경로가 달라진 부분은 프로젝트 마이그레이션 시 꼭 체크하세요. 그리고 최신 버전에서는 AVIF 포맷 지원 등 이미지 최적화 기능도 점점 좋아지고 있어서, 가능하면 최신 버전을 쓰는 게 좋습니다.\n\n필요하면 각 버전에 있는 새로운 prop이나 설정을 활용해 성능과 사용자 경험을 개선해보시길 추천합니다!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":99},{"title":"Next.js 15에서 폼(Form) 쉽게 만드는 방법","description":"","date":"2025-04-22 02:18","slug":"2025-04-22-Form","content":"\n\n# Form 컴포넌트 소개\n\n`Form` 컴포넌트는 HTML의 기본 `form` 요소를 확장한 거예요. 이걸 사용하면 로딩 UI 미리 불러오기(prefetch), 제출 시 클라이언트 사이드에서 페이지 이동, 그리고 점진적 향상(progressive enhancement) 같은 기능을 쉽게 구현할 수 있답니다.\n\n특히, URL 검색 파라미터(search params)를 업데이트하는 폼에서 유용해요. 기존에 이런 작업 하면서 번거롭게 작성하던 코드량을 훨씬 줄여주거든요.\n\n간단한 기본 사용법은 다음과 같아요:  \n\n```jsx\n\u003cForm method=\"get\" action=\"/search\"\u003e\n  \u003cinput name=\"query\" /\u003e\n  \u003cbutton type=\"submit\"\u003eSearch\u003c/button\u003e\n\u003c/Form\u003e\n```\n\n---\n\n### 덧붙일 내용 - 왜 점진적 향상인가?\n\n점진적 향상(Progressive Enhancement)이란 말 그대로 웹 기능을 기본 HTML에서도 사용 가능하면서, 자바스크립트를 지원하는 환경에서는 더 나은 경험을 제공하는 걸 의미해요.  \n`Form` 컴포넌트를 쓰면 이렇게 기본 HTML 폼 기능을 유지하면서도, JavaScript가 활성화된 환경에서는 더 빠르고 매끄러운 네비게이션이 가능하죠.\n\n또한, 네트워크 상태가 좋지 않은 경우에도 기본 폼 기능 덕분에 최소한의 작동은 보장되니, 사용자 경험을 꽤나 챙길 수 있어요.  \n\n`Form`과 비슷한 개념으로는 React의 `react-router` 라이브러리나 Next.js의 `next/link` 같은 것들이 있는데, 이 컴포넌트는 좀 더 폼 제출에 특화되어 있다고 보면 됩니다!  \n\n필요한 상황에 맞게 잘 활용해 보세요. 폼 제출 시 사용자 경험을 한층 개선해 줄 거예요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번 글에서는 Next.js의 `Form` 컴포넌트 사용법에 대해 다뤄볼게요. 예제를 보면서 설명할게요.\n\n```jsx\nimport Form from 'next/form'\n \nexport default function Page() {\n  return (\n    \u003cForm action=\"/search\"\u003e\n      {/* 제출 시, 입력값이 URL에 쿼리 파라미터로 붙어요. 예: /search?query=abc */}\n      \u003cinput name=\"query\" /\u003e\n      \u003cbutton type=\"submit\"\u003eSubmit\u003c/button\u003e\n    \u003c/Form\u003e\n  )\n}\n```\n\n### 이 코드가 하는 일?\n\n`Form` 컴포넌트에 `action=\"/search\"` 처럼 문자열 형태로 `action`을 넘기면, 기본적으로 HTML 폼이 GET 방식으로 데이터를 보내는 방식과 유사해요. 사용자가 입력한 값(여기선 `query` input 값)이 URL 쿼리 스트링으로 추가되고, `/search?query=입력값` 형태로 이동하죠.\n\n---\n\n### 근데 여기서 Next.js가 특별한 점은?\n\n| 특징 | 설명 |\n| --- | --- |\n| 미리 불러오기(Prefetch) | 폼이 화면에 나타나면 지정한 경로(`/search`)를 미리 불러와서 페이지 전환이 훨씬 빨라져요. 이때 레이아웃이나 로딩 컴포넌트 같은 공유 UI도 함께 미리 준비돼요. |\n| 클라이언트 사이드 내비게이션 | 폼을 제출했을 때, 페이지가 전체 새로고침 되지 않고 SPA처럼 클라이언트 사이드에서 경로가 바뀌어요. 덕분에 공유 UI가 유지되고, 유저 인터페이스가 더 부드럽게 느껴집니다. |\n\n---\n\n### 참고! `action`에 함수 넣으면?\n\n`Form`의 `action` 프로퍼티에 서버 액션(Server Action) 함수를 전달하면, 제출 시 해당 함수가 실행돼요. 완전히 React 방식으로 동작하는 거죠. 서버에서 데이터를 처리하거나 검증하는 등의 작업을 손쉽게 구현할 수 있습니다.\n\n---\n\n### 추가 팁!\n\n- 기존 HTML `\u003cform\u003e`과 거의 비슷하게 동작하니까, 폼을 처음 접하는 사람도 금방 적응할 수 있어요.\n- Next.js는 `Form`과 라우팅 시스템을 잘 조합해서 SPA와 SSR의 장점을 살렸답니다!\n- 만약 POST 방식으로 데이터를 보내고 싶다면, `action`에 서버 함수를 사용하는 게 좋고, 더 복잡한 API 호출도 쉽게 처리 가능해요.\n\n---\n\n요약하자면, Next.js의 `Form` 컴포넌트를 이용하면 편하게 폼을 작성하면서도, 빠른 페이지 전환과 클라이언트 상태 유지를 누릴 수 있어요. 상황에 따라 `action`에 문자열 URL을 주거나 서버 함수로 처리하는 전략을 골라 쓰시면 됩니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### action (문자열) Props\n\n`Form` 컴포넌트에서 `action`이 문자열일 때 지원하는 props를 살펴볼게요.\n\n| Prop      | 예시                      | 타입                         | 필수 여부  |\n|-----------|---------------------------|------------------------------|------------|\n| `action`  | `action=\"/search\"`         | `string` (URL 또는 상대 경로) | 필수       |\n| `replace` | `replace={false}`          | `boolean`                    | 선택       |\n| `scroll`  | `scroll={true}`            | `boolean`                    | 선택       |\n| `prefetch`| `prefetch={true}`          | `boolean`                    | 선택       |\n\n- **action**: 폼이 제출됐을 때 이동할 URL 혹은 경로를 지정해줘요.  \n  만약 빈 문자열 `\"\"`로 설정하면, 현재 경로에서 검색 파라미터만 업데이트해서 이동해요.  \n  예를 들어, 검색 기능이 있는 페이지에서 검색어만 바뀔 때 유용하겠죠?\n  \n- **replace**: 기본값은 `false`예요.  \n  브라우저의 기록(history) 스택에 새 항목을 추가할지 말지 결정하는데요,  \n  만약 `true`라면 기존 기록을 새 기록으로 *교체*합니다.  \n  뒤로 가기 버튼을 눌렀을 때 이전 페이지로 돌아가지 않게 하려면 이걸 켜면 돼요.\n  \n- **scroll**: 기본값은 `true`이고, 탐색 시 스크롤 동작을 조절해요.  \n  `true`면 새 페이지로 이동할 때 스크롤을 맨 위로 올리고, 뒤로/앞으로 가기 시에는 스크롤 위치를 유지해 줘요.  \n  만약 원하는 스크롤 위치가 있다면 `false`로 설정하고 직접 관리할 수도 있답니다.\n  \n- **prefetch**: 기본값은 `true`로,  \n  폼이 화면에 보이면 해당 경로를 미리 불러와서(pre-fetch) 빠르게 전환할 수 있게 도와줘요.  \n  네트워크 트래픽이나 자원 절약을 원한다면 이 옵션을 꺼도 됩니다.\n\n---\n\n이렇게 각 prop을 잘 활용하면, 단순한 폼 제출 이상의 사용자 경험을 만들 수 있어요.  \n특히 SPA(싱글 페이지 애플리케이션) 개발 시, 이 props들은 라우팅과 렌더링 방식에 큰 영향을 줍니다.\n\n추가 팁으로, `action=\"\"`을 쓰면 URL 파라미터만 바꾸기 때문에  \n검색 페이지나 필터링 기능 구현 시 유용하니 꼭 기억해 두세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### action (함수) Props\n\n`action`이 함수일 때, `Form` 컴포넌트는 다음과 같은 prop을 지원합니다:\n\n| Prop    | 예시                  | 타입                          | 필수 여부 |\n|---------|-----------------------|-------------------------------|----------|\n| action  | `action={myAction}`   | `function` (서버 액션 함수)   | 필수      |\n\n- **action**: 사용자가 폼을 제출할 때 호출되는 서버 액션 함수입니다. React 문서를 참고하면 더 자세한 정보를 얻을 수 있어요.\n\n---\n\n여기서 잠깐! `action`이 서버 액션 함수라는 점에서 조금 독특한데요. 보통 폼 제출은 클라이언트 사이드에서 처리하거나, API 호출을 통해 이루어지곤 하죠. 그런데 React Server Components 환경에서는 서버에서 직접 실행되는 함수 형태로 액션을 정의할 수도 있답니다. 덕분에 클라이언트와 서버 간 데이터 처리 로직 구분이 깔끔해지고, 성능 최적화에도 도움이 돼요.\n\n혹시 익숙하지 않은분은 \"서버 액션\"이 뭔지 한 번 찾아보고, React 공식 문서에서 관련 예제를 보면 이해가 금방 될 거예요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n좋은 정보 한 가지! action이 함수일 때는 replace와 scroll 속성들이 무시된다는 점 기억하세요.\n\n### 주의할 점들\n\n| 항목 | 설명 |\n|---|---|\n| **formAction** | `button`이나 `input type=\"submit\"`에서 action 속성을 덮어쓸 수 있어요. Next.js는 클라이언트 사이드 네비게이션을 수행하지만, 이 방법은 prefetch(선불러오기)를 지원하지 않는다는 점 참고하세요. 그리고 basePath를 사용한다면 반드시 formAction 경로에 basePath를 포함시켜야 합니다. 예) `formAction=\"/base-path/search\"` |\n| **key** | 문자열 형태의 action에 key prop을 넘기는 건 지원되지 않습니다. 만약 리렌더링이나 뮤테이션을 트리거하고 싶으면 함수형 action을 사용하세요. |\n| **onSubmit** | 폼 제출 로직을 처리할 때 사용 가능하지만, 만약 `event.preventDefault()`를 호출하면 Next.js `Form`의 기본 동작(즉 URL로 네비게이션)이 무시됩니다. |\n| **method, encType, target** | 이 속성들은 `Form`의 기본 동작을 오버라이드하기 때문에 지원되지 않아요. 대신에 `formMethod`, `formEncType`, `formTarget` 속성을 써서 각각 method, encType, target을 덮어쓸 수 있긴 하지만 이 경우엔 네이티브 브라우저 동작으로 fallback됩니다. 이들 기능을 꼭 사용해야 한다면 Next.js `Form` 대신 HTML `form` 태그를 사용하는 게 좋아요. |\n| **input type=\"file\"** | action이 문자열일 때 이 타입의 input은 브라우저 동작과 동일하게 파일 객체 대신 파일명만 제출됩니다. |\n\n---\n\n사실 Next.js의 `Form` 컴포넌트를 사용할 때 이런 제약사항들을 미리 알고 있으면 개발할 때 헷갈리는 부분이 줄어요. 특히 prefetch가 안 되거나, 리렌더링 이슈가 생겼을 때는 \"혹시 action을 문자열로 쓰고 key를 넘긴 건 아닌가?\" 하고 한번 점검해보세요.\n\n더불어 파일 업로드 처리는 Next.js 내장 `Form` 컴포넌트로 하기엔 제약이 있으니, 이럴 땐 기존 HTML `form` 태그와 서버 API를 직접 연결하는 방식이 안전합니다.\n\n이런 점들을 잘 기억해두시면 Next.js의 폼 처리 방식을 더욱 능숙하게 사용할 수 있을 거예요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 예제\n\n### 검색 결과 페이지로 이동하는 검색 폼 만들기\n\n검색 결과 페이지로 이동하는 폼을 만들고 싶다면, `action` 속성에 결과 페이지 경로를 넣어주면 됩니다. 예를 들어, `/search` 경로로 이동하도록 설정하면 사용자가 폼을 제출할 때 검색어가 쿼리 파라미터로 붙어서 해당 페이지로 넘어가죠.\n\n```js\nimport Form from 'next/form'\n\nexport default function Page() {\n  return (\n    \u003cForm action=\"/search\"\u003e\n      \u003cinput name=\"query\" /\u003e\n      \u003cbutton type=\"submit\"\u003eSubmit\u003c/button\u003e\n    \u003c/Form\u003e\n  )\n}\n```\n\n여기서 중요한 점은 `input`에 반드시 `name` 속성을 주어야 폼 데이터를 제대로 전달할 수 있다는 거예요. `name=\"query\"`로 지정한 검색어가 `/search?query=검색어` 형태로 넘어가게 됩니다.\n\n그리고, `Form` 컴포넌트는 Next.js의 새로운 폼 처리 방식을 따르는 컴포넌트인데요, 내부적으로 기본 HTML `\u003cform\u003e` 태그와 유사하게 동작하지만 Next.js 특성에 맞게 최적화되어 있어요. 만약 Next.js 버전에 따라 `Form` 컴포넌트가 제공되지 않는 경우에는 기본 `\u003cform\u003e` 태그를 사용하셔도 무방해요.\n\n마지막으로 조금 더 사용자 친화적으로 만들고 싶다면, 입력 필드에 `placeholder`를 넣어주거나, 버튼에 좀 더 직관적인 텍스트를 넣는 것도 추천드려요!\n\n```js\n\u003cForm action=\"/search\"\u003e\n  \u003cinput name=\"query\" placeholder=\"검색어를 입력하세요\" /\u003e\n  \u003cbutton type=\"submit\"\u003e검색\u003c/button\u003e\n\u003c/Form\u003e\n```\n\n이렇게 하면 검색 폼이 더 완성도 있게 보이겠죠? 간단하지만 기본적인 검색 기능을 구현할 때 유용한 방법입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n사용자가 검색어 입력 필드에 값을 넣고 폼을 제출하면, 폼 데이터가 URL의 쿼리 파라미터로 인코딩돼서 `/search?query=abc` 같은 형식으로 이동하게 돼요.\n\n\u003e 참고로, action 속성에 빈 문자열 `\"\"`을 넣으면, 같은 경로로 이동하면서 쿼리 파라미터만 업데이트할 수 있다는 점도 알아두면 좋아요.\n\n검색 결과 페이지에서는 `searchParams`라는 `page.js`의 prop을 통해 쿼리 값을 받아올 수 있고, 이를 이용해 외부 API에서 데이터를 불러오는 식으로 활용할 수 있답니다.\n\n아래 예제를 살펴볼게요.\n\n```js\nimport { getSearchResults } from '@/lib/search'\n\nexport default async function SearchPage({\n  searchParams,\n}: {\n  searchParams: Promise\u003c{ [key: string]: string | string[] | undefined }\u003e\n}) {\n  // searchParams는 Promise 형태라 await을 해줘야 쿼리 값을 받을 수 있어요\n  const results = await getSearchResults((await searchParams).query)\n\n  return \u003cdiv\u003e...\u003c/div\u003e\n}\n```\n\n\u003e 여기서 한 가지 팁을 드리자면, `searchParams`가 Promise라는 점 때문에 async/await을 꼭 처리해줘야 해요. 깜빡하면 값이 제대로 안 들어와서 당황할 수 있답니다.\n\n정리하자면, 이 방법은 서버사이드 렌더링 환경에서 검색어에 따라 동적인 데이터를 불러오기 아주 편리한 방식이에요. React 컴포넌트에서 직접 URL 쿼리 파라미터를 읽어서 비동기 데이터 요청을 쉽게 처리할 수 있거든요.\n\n만약 사용자가 계속 검색어를 바꾸면서 결과를 보고 싶다면, 이 패턴을 잘 응용하면 굉장히 깔끔한 페이지 구성이 가능하니 꼭 기억해두세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n`Form`이 사용자의 화면에 보이기 시작하면, `/search` 페이지에 있는 공통 UI(예를 들어 layout.js나 loading.js) 리소스가 미리 불러와집니다(prefetch). 그리고 폼이 제출되면 바로 새로운 경로로 이동하면서, 결과가 로딩되는 동안에는 로딩 UI가 보여집니다. 이렇게 로딩 UI를 설계하려면 loading.js를 사용하면 되는데, 간단한 예시는 다음과 같아요:\n\n```js\nexport default function Loading() {\n  return \u003cdiv\u003eLoading...\u003c/div\u003e\n}\n```\n\n그런데 여기서 한 가지 더 신경 써야 할 점은, 혹시 공통 UI가 아직 완전히 로드되지 않은 상태에서는 사용자가 답답함을 느낄 수 있다는 거예요. 이런 경우를 대비해서 `useFormStatus` 훅을 활용해서 즉각적인 피드백을 줄 수 있습니다.\n\n자, 그러면 제출이 진행 중일 때 로딩 상태를 보여주는 컴포넌트를 하나 만들어볼게요. 이 컴포넌트는 사용자가 폼을 제출해서 결과를 기다릴 때 뭔가 진행 중임을 보여줘서 사용자 경험을 더 매끄럽게 만들어줍니다.\n\n```js\n'use client'\n\nimport { useFormStatus } from 'react-dom'\n\nexport default function FormProgress() {\n  const { pending } = useFormStatus()\n\n  return (\n    \u003cdiv\u003e\n      {pending ? '폼 제출 중...' : null}\n    \u003c/div\u003e\n  )\n}\n```\n\n여기서 `useFormStatus`는 React Server Components 환경에서 폼 제출 상태(예: 대기중인지 여부)를 추적할 수 있게 도와주는 훅이에요. `pending`이 `true`일 때는 폼이 제출 중임을 의미하죠.\n\n---\n\n### 추가 팁 - 이런 경우에 쓰면 좋아요!\n\n- 사용자가 버튼을 여러 번 반복해서 누르는 걸 방지하고 싶을 때\n- 네트워크가 느려서 서버 응답 시간이 긴 경우 진행 상태를 명확히 보여주고 싶을 때\n- 전체 페이지가 아닌 일부 컴포넌트에만 로딩 표시를 제한하고 싶을 때\n\n---\n\n### 요약\n- `Form`이 화면에 보이면 `/search` 페이지의 공통 UI 리소스를 미리 받아서 빠르게 렌더링 가능\n- 폼 제출 시 로딩 UI(loading.js)로 사용자 피드백 제공\n- `useFormStatus` 훅을 이용해 폼 제출이 진행 중인 상태를 감지하고 즉각적으로 사용자에게 알려줄 수 있음\n\n이렇게 하면 사용자 경험이 훨씬 부드러워지고, 로딩중임을 확실히 인지시켜줘서 UX가 좋아지겠죠? 다음에도 이런 React Server Components 관련 내용 자주 알려드릴게요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번에는 React(특히 Next.js)에서 서버 액션(Server Actions)을 활용한 폼과 버튼 구현 예제를 함께 살펴볼게요.\n\n---\n\n먼저, `SearchButton` 컴포넌트를 보시면, `useFormStatus` 훅을 활용해서 폼이 제출 중인지 아닌지 상태를 확인하고 있죠.\n\n```jsx\n'use client'\nimport { useFormStatus } from 'react-dom'\n \nexport default function SearchButton() {\n  const status = useFormStatus()\n  return (\n    \u003cbutton type=\"submit\"\u003e{status.pending ? 'Searching...' : 'Search'}\u003c/button\u003e\n  )\n}\n```\n\n- `useFormStatus`는 폼 제출 상태를 받아와서, 제출이 진행 중일 때는 버튼 텍스트를 'Searching...'으로, 그렇지 않을 때는 'Search'로 바꾸어 줘요.\n- 그리고 `use client` 지시자는 이 컴포넌트가 클라이언트 컴포넌트임을 Next.js에 알려줍니다. 서버 컴포넌트와 클라이언트 컴포넌트를 적절히 분리해서 사용하는 것이 Next.js 13에서 중요한 포인트입니다.\n\n---\n\n그 다음, 실제 검색 폼 페이지 코드를 보면 이렇게 돼있어요.\n\n```jsx\nimport Form from 'next/form'\nimport { SearchButton } from '@/ui/search-button'\n \nexport default function Page() {\n  return (\n    \u003cForm action=\"/search\"\u003e\n      \u003cinput name=\"query\" /\u003e\n      \u003cSearchButton /\u003e\n    \u003c/Form\u003e\n  )\n}\n```\n\n- 여기서는 `next/form` 라이브러리에서 가져온 `Form` 컴포넌트를 사용하고 있네요.\n- `Form` 컴포넌트에 `action`으로 `/search`를 넘겨서, 제출하면 해당 서버 액션이 실행될 거예요.\n- 그리고 `SearchButton`을 넣어서 폼 제출 시 상태가 표시되도록 했죠.\n\n---\n\n### Server Actions란?\n\nNext.js 13부터 도입된 서버 액션 기능은 클라이언트에서 서버 함수를 직접 호출하듯 코드를 작성할 수 있게 해 줍니다. 기존에는 API 라우트로 POST 요청 보내고 응답 받는 과정이 필요했다면, 서버 액션을 사용하면 그 과정을 훨씬 간편하게 만들 수 있죠.\n\n이번 예제의 핵심은:\n\n- 클라이언트에서 폼 제출 시 `Form` 컴포넌트가 서버 액션을 호출한다.\n- 서버 액션 실행 중일 때 버튼 상태(`Searching...`)를 통해 사용자가 인지할 수 있다.\n\n---\n\n### 더 알아두면 좋은 팁들!\n\n| 내용 | 설명 |\n| --- | --- |\n| `useFormStatus` | 폼 제출 상태를 알 수 있어 UI에 반영하기 좋아요. |\n| 클라이언트 컴포넌트 | 상태를 관리할 버튼 등 인터랙티브한 부분은 클라이언트 컴포넌트로 작성해야 해요. |\n| `Form` 컴포넌트 | 기존 폼 태그를 대체하면서 서버 액션과 자연스럽게 연동됩니다. |\n| 서버 액션 개발 | 서버에서 실행되는 함수이므로 보안이 중요한 로직을 담기 좋아요. |\n\n---\n\n### 마치며\n\n이번에 소개한 `useFormStatus`와 `Form` 컴포넌트를 활용하면 서버 액션과 클라이언트 상태를 아주 깔끔하게 관리할 수 있어요. Next.js 13의 서버 액션 기능은 단순한 API 통신보다 훨씬 직관적이고 강력한 도구니 꼭 한번 적용해 보고, 더 넓은 가능성을 찾아보길 추천해요!\n\n필요하면 서버 액션 만드는 방법과 연동하는 예제도 함께 공유할 테니, 관심 있으면 알려 주세요 :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번에 Next.js에서 `Form` 태그를 활용하는 방법을 살펴봤어요. 그냥 `\u003cform\u003e` 태그 대신 `Form` 컴포넌트를 쓰면, mutation(데이터 변경 작업)을 할 때 간편하게 액션 함수를 넘겨줄 수 있답니다.\n\n```jsx\nimport Form from 'next/form'\nimport { createPost } from '@/posts/actions'\n\nexport default function Page() {\n  return (\n    \u003cForm action={createPost}\u003e\n      \u003cinput name=\"title\" /\u003e\n      {/* ... */}\n      \u003cbutton type=\"submit\"\u003eCreate Post\u003c/button\u003e\n    \u003c/Form\u003e\n  )\n}\n```\n\n여기서 `createPost`는 서버 사이드에서 실행되는 함수로, 폼에 제출된 데이터를 받아 글을 생성하는 역할을 하죠. 이렇게 함수 형태로 액션을 넘기면, 폼 제출 시 자동으로 해당 함수가 호출됩니다.\n\n그리고 글이 만들어지고 나서 보통 새 글 페이지로 리다이렉트 하고 싶은 경우가 많잖아요? 이럴 땐 Next.js의 `next/navigation` 모듈에 있는 `redirect` 함수를 사용하면 돼요.\n\n```js\nimport { redirect } from 'next/navigation';\n\nexport async function createPost(formData) {\n  const post = await createPostInDB(formData);\n  redirect(`/posts/${post.id}`);\n}\n```\n\n여기서 주의할 점은요, 폼이 제출된 후에 액션 함수가 실행되기 때문에, 이 때까지 어디로 리다이렉트할지 모릅니다. 그래서 `Form` 컴포넌트는 자동으로 어떤 UI를 미리 불러오거나(prefetch) 준비하는 기능이 없어요. 즉, 네비게이션이 동적인 상황이라 미리 준비하지 않는다는 뜻입니다.\n\n---\n\n### 참고로 알아두면 좋은 점\n\n- `Form` 컴포넌트를 사용하면 서버 액션을 쉽고 깔끔하게 연결할 수 있어요.\n- 꼭 `redirect`를 사용해서 리다이렉션을 처리해야 하고, 클라이언트에서 직접 네비게이션을 하지 않는 게 좋습니다.\n- 서버 사이드 액션 함수 안에서는 보통 데이터베이스 작업이나 외부 API 호출 같은 일을 처리합니다.\n- 사용자가 제출한 데이터는 `formData` 형태로 받게 되며, 이걸 활용해 원하는 작업을 하면 됩니다.\n\nNext.js 13 초기 버전과 비교하면 정말 좋아진 점 중 하나가 이런 서버 액션과 클라이언트가 자연스럽게 연동된다는 거예요. 개발할 때 훨씬 깔끔하고 안정적으로 만들어서 추천해요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n요즘 Next.js에서 서버 액션(Server Actions)을 활용하는 방법을 공부하고 있는데, 간단하게 정리해볼게요. 서버 액션을 쓰면 서버에서 데이터를 처리하고 그 결과에 따라 바로 리다이렉트도 쉽게 할 수 있어서 편리하답니다.\n\n우선, 새 글을 만드는 `createPost` 서버 액션 함수부터 볼게요:\n\n```js\n'use server'\nimport { redirect } from 'next/navigation'\n \nexport async function createPost(formData: FormData) {\n  // 새로운 글 생성 로직이 여기 들어가겠죠?\n  // 예를 들어 DB에 저장하거나 API를 호출하고...\n \n  // 새 글의 ID를 받아왔다고 가정\n  redirect(`/posts/${data.id}`)  // 생성 완료 후 새 글 페이지로 이동\n}\n```\n\n여기서 'use server' 지시어는 이 함수가 서버에서만 실행된다는 뜻이고, `redirect` 함수로 새로운 글 페이지로 이동할 수 있어요. 클라이언트에서 별도의 처리 없이 서버에서 바로 리다이렉트되는 점이 신기하죠?\n\n그리고 새 글 페이지 컴포넌트에서는 `params`를 받아서 해당 글 데이터를 불러옵니다:\n\n```js\nimport { getPost } from '@/posts/data'\n \nexport default async function PostPage({\n  params,\n}: {\n  params: Promise\u003c{ id: string }\u003e\n}) {\n  const { id } = await params\n  const data = await getPost(id) // 서버에서 글 데이터 가져오기\n \n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003e{data.title}\u003c/h1\u003e\n      {/* 글 내용이나 댓글 등 추가 정보 표시 가능 */}\n    \u003c/div\u003e\n  )\n}\n```\n\n여기서 `params`가 프로미스로 되어있는 게 좀 특이한데, 이게 Next.js의 새로운 동적 라우팅 방식 때문이에요. 비동기로 params를 받아서 바로 데이터를 fetch할 수 있답니다.\n\n덧붙여서, Server Actions은 Next.js 13에서 소개된 기능이고, 기존에 API 라우트를 따로 만들지 않아도 서버 코드를 컴포넌트 안에서 선언해서 사용할 수 있어 개발 생산성을 높여줘요.\n\n더 다양한 예제와 활용 팁은 [서버 액션 공식 문서](https://nextjs.org/docs/app/building-your-application/routing/server-actions)에서 확인해보세요! 한번 익숙해지면 클라이언트-서버 데이터 흐름이 훨씬 깔끔해져서 추천합니다 :)","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":17},{"title":"Nextjs 15에서 Font Module 사용하는 방법 가이드","description":"","date":"2025-04-22 02:14","slug":"2025-04-22-FontModule","content":"\n\n# 폰트 모듈\n\n이번 글에서는 next/font/google과 next/font/local을 어떻게 활용할 수 있는지 알려드릴게요. 폰트를 효율적으로 불러오고 최적화하는 방법을 배우고 싶다면, next.js의 *Optimizing Fonts* 페이지도 함께 참고하시면 좋아요.\n\n### Font 함수 인자들\n\n폰트를 쓸 때 어떻게 인자를 넘기는지 궁금하시죠? 구글 폰트용 설정과 로컬 폰트용 설정을 각각 따로 살펴보면 이해가 쏙쏙 될 거예요.\n\n---\n\n### 구글 폰트 (Google Fonts) 사용법\n\n구글 폰트를 쉽게 불러오려면 `next/font/google`의 함수를 씁니다. 이 함수는 폰트 이름을 넘겨주면 자동으로 최적화된 CSS와 폰트 파일을 로드해줘요.\n\n- `weight`: 폰트 굵기 설정 (예: '400', '700')\n- `style`: 이탤릭체 같은 스타일 지정 가능 ('normal', 'italic')\n- `subsets`: 지원할 문자집합 선택 (한국어는 'latin', 'latin-ext', 'korean' 등)\n- `variable`: CSS 변수로 쓰기 위한 옵션\n\n### 로컬 폰트 (Local Fonts) 사용법\n\n내 PC나 프로젝트에 직접 폰트 파일을 넣고 싶다면 `next/font/local`을 써보세요. 경로나 파일명을 지정해서 필요한 굵기, 스타일을 함께 넘길 수 있어요.\n\n---\n\n필요에 따라 구글 폰트랑 로컬 폰트를 함께 조합해서 쓰는 것도 가능합니다. 프로젝트에 따라 딱 맞는 방법을 골라 쓰시면 성능과 디자인 모두 잡을 수 있어요! 궁금한 점 있으면 언제든 질문해 주세요~\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 `next/font`에서 사용되는 주요 옵션들에 대한 정리입니다. 구글 폰트(`font/google`)와 로컬 폰트(`font/local`)에서 각각 어떤 옵션이 필수인지, 타입은 무엇인지 등을 알 수 있어요.\n\n| Key                 | font/google 지원 여부 | font/local 지원 여부 | Type                          | Required          |\n|---------------------|-----------------------|---------------------|-------------------------------|-------------------|\n| [`src`](#src)           | ❌ 음영 (해당 없음)      | ✅                   | String 또는 객체 배열 (경로 포함) | 필수              |\n| [`weight`](#weight)     | ✅                   | ✅                   | String 또는 배열             | 필수/선택 (경우에 따라) |\n| [`style`](#style)       | ✅                   | ✅                   | String 또는 배열             | 선택               |\n| [`subsets`](#subsets)   | ✅                   | ❌ 음영                | 문자열 배열                 | 선택               |\n| [`axes`](#axes)         | ✅                   | ❌ 음영                | 문자열 배열                 | 선택               |\n| [`display`](#display)   | ✅                   | ✅                   | String                      | 선택               |\n| [`preload`](#preload)   | ✅                   | ✅                   | Boolean                     | 선택               |\n| [`fallback`](#fallback) | ✅                   | ✅                   | 문자열 배열                 | 선택               |\n| [`adjustFontFallback`](#adjustfontfallback) | ✅         | ✅                   | Boolean 또는 String          | 선택               |\n| [`variable`](#variable) | ✅                   | ✅                   | String                      | 선택               |\n| [`declarations`](#declarations) | ❌ 음영            | ✅                   | 객체 배열                   | 선택               |\n\n---\n\n### src\n\n- **설명**  \n  로컬 폰트 경로를 지정할 때 사용해요. 문자열 하나 또는 객체 배열 형태로 폰트 파일 경로를 넣을 수 있습니다.  \n  예를 들어, 객체는 `{ path: 'path/to/font.woff2', weight: '400', style: 'normal' }` 이런 식으로 사용할 수 있어요.  \n\n- **사용처**  \n  오직 로컬 폰트를 로딩할 때(`next/font/local`)만 의미가 있습니다.  \n\n---\n\n### 추가 팁!\n\n- 구글 폰트는 `src` 옵션이 없어요. 대신 `weight`나 `style`, `subsets`같은 옵션들을 사용해서 폰트를 다양하게 커스터마이즈 할 수 있습니다.\n- `preload`가 `true`로 설정되면, 폰트가 미리 로딩되어 초기 렌더링시 폰트가 깜빡이지 않는 효과가 있어 사용자 경험이 더 좋아집니다.\n- `fallback`으로 여러 글꼴을 지정해 두면, 만약 로딩에 실패해도 다른 글꼴로 대체되어 디자인이 깨지지 않아요.\n- `variable` 옵션은 CSS 변수로 폰트 패밀리를 정의해 보다 유연하게 스타일을 적용할 때 유용합니다.\n\n---\n\n폰트 설정을 제대로 하면 웹사이트의 성능과 사용 체감이 확 좋아지니, 꼭 이 옵션들을 꼼꼼히 살펴보시길 바랍니다! 특히 Next.js 같은 프레임워크에서는 기본적으로 최적화해주니까, 이걸 잘 활용하는 게 핵심입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n웹 개발하면서 폰트를 쓸 때, `src` 속성에 폰트 파일 경로를 지정하는 게 필수인 거 다들 아시죠? 폰트가 어디에 있냐에 따라서 경로를 어떻게 써야 하는지 예를 들어서 설명해볼게요.\n\n예를 들어,\n\n- `src: './fonts/my-font.woff2'` 라고 적었다면, `my-font.woff2` 파일이 `app` 폴더 안에 있는 `fonts`라는 폴더 안에 있어야 해요.\n- `src`에 배열처럼 여러 경로를 주는 경우도 있어요. 예를 들어,\n\n```ts\nsrc: [\n  'path: `./inter/Inter-Thin.ttf`, weight: `100`',\n  'path: `./inter/Inter-Regular.ttf`, weight: `400`',\n  'path: `./inter/Inter-Bold-Italic.ttf`, weight: `700`, style: `italic`',\n]\n```\n\n이렇게 여러 스타일과 두께(weight)를 각각 지정할 수도 있어요.\n\n또한 만약에 `app/page.tsx`에서 `src: '../styles/fonts/my-font.ttf'`라고 폰트를 불러온다면, 실제로 프로젝트 루트에 있는 `styles/fonts` 폴더 안에 `my-font.ttf`가 위치해야 해요. 즉, 경로는 호출하는 위치 기준으로 상대 경로를 잘 맞춰주는 게 중요합니다.\n\n---\n\n### weight\n\n이건 폰트 굵기를 지정하는 속성인데, 숫자가 커질수록 더 두꺼운 글자가 돼요. 보통 100부터 900까지 설정 가능합니다.\n\n- 100: 얇은 글씨 (Thin)\n- 400: 일반 글씨 (Regular)\n- 700: 두꺼운 글씨 (Bold)\n\n여기서 한 가지 팁! 만약 폰트 파일마다 굵기가 다 다르다면, 각각 다른 파일을 넣어주고 `weight`를 명시해줘야 나중에 CSS에서 굵기 조절할 때 자연스럽게 적용돼요.\n\n---\n\n### 추가 팁!\n\n- 폰트 파일 경로 설정할 때, 상대 경로가 헷갈릴 수 있는데 `app` 폴더를 루트처럼 생각하는 경우가 많으니, 프로젝트 구조를 한 번 확실히 파악하고 써보세요.\n- 그리고 폰트 포맷 종류도 중요해요. 보통 최신 웹에서는 `woff2`를 권장하는데, 크기도 작고 브라우저 호환성도 좋아서요.\n- 여러 스타일과 굵기를 쓰고 싶으면 위에 예제처럼 배열 안에 객체 형태로 주는 방법이 가장 깔끔해요.\n\n꼭 한 번 폰트 파일 위치와 경로, weight 옵션 등 기본 세팅을 확실히 잡고 시작하면 나중에 폰트 적용이 훨씬 편해질 거예요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n폰트 굵기(font weight)에 대해 이야기해볼게요!\n\n폰트 굵기 설정은 다음과 같은 형식으로 사용할 수 있어요:\n\n- **문자열(String)**: 해당 폰트에서 지원하는 굵기 값을 나열하거나, 만약 가변(variable) 폰트라면 범위 값을 줄 수 있어요.\n- **배열(Array)**: 만약 구글 폰트(Google Font) 중에 가변 폰트가 아니라면, 사용할 굵기 값들을 배열 형태로 넣어줘야 해요.\n\n이 설정은 React의 Next.js 라이브러리 중 `next/font/google`과 `next/font/local`에서 주로 적용됩니다.\n\n특히 중요!\n\n| 상황                         | 굵기 설정 필수 여부          |\n|-----------------------------|-----------------------------|\n| 가변 폰트(variable font)를 사용 | 선택적 (범위를 줄 수 있음)    |\n| 가변 폰트가 아닌 구글 폰트 사용 | 반드시 필요 (배열 형태로 줘야 함) |\n| 로컬 폰트(`next/font/local`) 사용  | 상황에 따라 필요할 수 있음      |\n\n즉, 가변 폰트를 쓰면 좀 더 자유롭게 굵기 범위를 조절할 수 있는 반면, 일반적인 구글 폰트들은 원하는 굵기 값들을 명시해줘야 정상적으로 적용된다는 뜻이에요.\n\n혹시 굵기 설정을 안 해주면 어떻게 될까? 대부분 기본 굵기(보통 400)로 적용되고, 원하는 다양한 굵기를 활용 못 할 수도 있으니 폰트 스타일을 다양하게 보여주고 싶다면 꼭 설정해주는 것이 좋아요.\n\n예를 들어,\n\n```js\nimport { Roboto } from 'next/font/google';\n\nconst roboto = Roboto({\n  weight: ['400', '700'], // 400과 700 두 가지 굵기만 사용\n});\n```\n\n이렇게 중복된 굵기를 배열로 지정해줌으로써 페이지 내에서 굵기 변화를 주기 쉽답니다.\n\n요약하면, 폰트 굵기 설정은 사용자 경험 측면에서 폰트를 세밀하게 조정하는 중요한 옵션이므로, 사용하는 폰트 종류와 상황에 맞게 잘 활용해 보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예시:\n\n- weight: `400`  \n  단일 weight 값을 나타내는 문자열입니다. 예를 들어 폰트 Inter의 경우 가능한 값은 `100`, `200`, `300`, `400`, `500`, `600`, `700`, `800`, `900` 또는 기본값인 `variable`입니다.\n- weight: `100 900`  \n  변수 폰트(variable font)에서 100부터 900 사이의 범위를 나타내는 문자열입니다.\n- weight: [`100`, `400`, `900`]  \n  변수 폰트가 아닌 경우에 가능한 3가지 값으로 이루어진 배열입니다.\n\n### style\n\n폰트 스타일을 지정하며, 다음과 같은 옵션들이 있습니다:  \n\n(여기서 스타일 옵션 목록이 이어질텐데, 추가 정보가 있는 경우 알려주시면 함께 도움 드릴게요!)\n\n---\n\n폰트 weight 같은 경우는 특히 웹에서 폰트를 효율적으로 사용할 때 중요한데요,  \n변수 폰트를 쓰면 여러 굵기를 한 파일로 관리할 수 있고, 필요한 굵기만 지정해서 쓰니까 로딩 속도도 최적화할 수 있어요.  \n반면에 일반 폰트는 굵기마다 별도의 파일이 있어서 용량이 커지고 로딩이 느려질 수 있답니다.  \n\n개발할 때 이 점 참고해서 상황에 맞게 weight를 잘 지정해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 문자열 값으로 기본값은 `normal`이에요.\n- 만약 폰트가 가변 구글 폰트가 아니라면 스타일이 여러 개일 수 있는데, 이럴 땐 스타일 값들이 배열 형태로 들어갑니다. 이건 `next/font/google`에서만 적용돼요.\n\n이 설정은 `next/font/google`과 `next/font/local`에서 사용할 수 있습니다.\n\n- 선택적(필수는 아님)\n\n### 예시\n\n| 속성               | 설명                         |\n|------------------|----------------------------|\n| `\"normal\"`       | 기본 스타일 (보통 굵기, 기울임 없음) |\n| `[\"normal\", \"italic\"]` | 보통과 이탤릭 스타일 같이 사용할 때 |\n\n\n참고로, 구글 폰트를 다룰 때 스타일을 배열로 넘기면 여러 폰트 스타일을 한 번에 불러와서 상황에 따라 쉽게 사용할 수 있어서 편해요.  \n가변 폰트는 `wght` 같은 굵기(weight) 변수 값을 직접 조절할 수 있지만, 비가변 폰트는 이런 식으로 여러 스타일을 배열에 담아 관리하면 되니 기억해두면 좋아요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nFont 스타일과 subsets 옵션에 대해 좀 더 쉽게 설명해볼게요.\n\n---\n\n## 스타일(style)에 대해 알아볼까요?\n\n- **`italic`**: 문자열 형태에요. 예를 들어, `italic` 또는 `normal` 값을 줄 수 있는데, 주로 **next/font/google**에서 사용돼요. 즉, 글씨를 기울이거나(normal) 기본 상태로 설정할 때 쓰는 거죠.\n  \n- **`oblique`**: 이건 또 다른 문자열 스타일인데, 사실 **next/font/local** 쪽에서 사용해요. 어떤 값이든 넣을 수는 있지만, 보통 표준 폰트 스타일에서 많이 쓰는 값들을 넣는 경우가 많아요.\n  \n- **`['italic', 'normal']`**: 흥미롭게도, next/font/google에서는 이렇게 배열로 두 가지 값을 받을 때도 있어요. 첫 값과 두 번째 값이 각각 normal, italic 중 하나가 들어가는 식이죠.\n\n즉, 같은 스타일 프로퍼티인데도 사용하는 환경(google 폰트인지, local 폰트인지)에 따라 받을 수 있는 값이 다르니 참고하세요.\n\n---\n\n## subsets 옵션은 뭐하는 거야?\n\n**subsets**는 폰트의 문자 집합을 의미해요. 예를 들어, 한글 폰트라면 기본 라틴 문자뿐 아니라 한글도 포함되어야겠죠? 이걸 배열로 써서 어떤 문자 집합을 미리 불러올지 설정해요.\n\n예를 들면:\n\n```js\nsubsets: ['latin', 'cyrillic', 'korean']\n```\n\n이렇게 쓰면 '라틴', '키릴 문자', '한글'을 미리 로딩해줍니다.\n\n중요한 점은, subsets 옵션을 이용하면 폰트에 대해 관련 링크 preload 태그가 `\u003chead\u003e`에 자동 삽입돼서 페이지 로딩 성능이 좋아져요. 그리고 preload 옵션이 true일 때 자동 반영되는 게 기본이니 따로 신경 쓸 필요 없답니다.\n\n---\n\n## 정리해볼까요?\n\n| 옵션 이름 | 타입 | 사용처 | 설명 |\n|-----------|-------|--------|------------------------------------------------------------------|\n| style | string 또는 string 배열 | next/font/google, next/font/local | 폰트 스타일 지정 (italic, normal, oblique 등). 환경에 따라 받는 값이 다름 |\n| subsets | string 배열 | next/font/google | 미리 불러올 폰트 문자 집합 배열. 성능 최적화에 도움 |\n\n---\n\n\u003e 참고로, 구글 폰트에서 제공하는 subsets는 각 언어별로 최적화된 문자만 포함하도록 설계되어 있어서, 전체 폰트를 다 불러오는 것보다 훨씬 가볍고 빠릅니다. 한국어 앱이라면 꼭 한글 subsets를 지정하는 게 좋아요!\n\n---\n\n이제 스타일과 subsets 옵션을 좀 더 편하게 이해할 수 있겠죠? 다음에 폰트 설정할 때 이 점만 잘 신경 써도 성능과 사용자 경험이 좋아질 거예요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Optional\n\n예시:\n\n| 옵션명  | 설명                         |\n|---------|------------------------------|\n| subsets | [`latin`]: latin 서브셋을 포함한 배열 |\n\n서브셋(subsets)은 폰트에서 사용하는 문자 집합의 일부분을 의미해요. 예를 들어, `latin`은 영어를 비롯한 라틴 문자들을 포함하는 서브셋이죠.\n\n더 많은 서브셋 리스트는 Google Fonts에서 원하는 폰트 페이지를 확인하면 상세히 볼 수 있어요. 다양한 언어와 문자 지원 여부를 확인할 때 유용하답니다!\n\n참고로, 서브셋을 적절히 선택하면 페이지 로딩 속도를 개선할 수 있으니, 필요한 문자 집합만 골라서 사용하는 게 좋아요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### axes\n\n일부 variable font(가변 글꼴)에는 추가 축(axes)이 포함되어 있을 수 있어요. 기본적으로는 파일 크기를 최소화하기 위해 **글꼴 두께(font weight)** 축만 포함되어 있답니다.  \n그래서 만약 더 다양한 스타일(예: 기울기, 폭 등)을 활용하고 싶다면, 해당 폰트가 지원하는 축들이 무엇인지 확인하고 추가로 포함시켜야 해요.\n\n예를 들어, 구글 폰트에서 제공하는 variable font 중 일부는 `wght`(글꼴 두께) 외에 `wdth`(글자 폭)나 `ital`(이탤릭) 같은 축들을 지원할 수 있죠.  \n하지만 모든 폰트가 모든 축을 지원하는 건 아니니까, 사용하려는 폰트의 상세 설명을 참고하는 게 좋아요.\n\n\u003e **참고:** Next.js에서 `next/font/google`을 사용할 때, 이 옵션은 선택 사항이에요. 필요할 때만 추가해 주면 된답니다.\n\n| 축 이름 (Axis Tag) | 설명                  | 예시                  |\n|-----------------|---------------------|---------------------|\n| wght            | 글꼴 두께 (Weight)      | 100 ~ 900           |\n| wdth            | 글자 폭 (Width)         | 50% ~ 200%          |\n| ital            | 이탤릭 (Italic)          | 0(기본), 1(이탤릭)    |\n\n만약 여러분이 스타일 변화를 워낙 많이 주고 싶으면, 여러 축을 활용해보세요!  \n그 덕분에 폰트 파일이 커질 수 있으니, 용도에 맞게 적절히 조절하는 게 중요합니다.  \n\n궁금하면 직접 variable font를 지원하는 툴이나 브라우저에서 축 값을 조절해 보는 것도 재미있는 경험이 될 거예요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예시를 들어 설명해볼게요:\n\n- axes: [`slnt`]: 이건 Inter라는 가변 폰트에서 `slnt`라는 추가 axes(축)를 나타내는 배열이에요. 이 폰트는 기울기(slant)를 조절할 수 있거든요. 여러분이 사용하는 폰트가 어떤 axes를 지원하는지는 구글 가변 폰트 페이지에서 필터를 활용해 `wght`(굵기) 이외에 다른 축들을 찾아보면 쉽게 확인할 수 있어요.\n\n---\n\n### display 속성\n\n`display` 속성은 폰트가 브라우저에 어떻게 보여질지 결정하는 값이에요. 가능한 문자열 값들은 다음과 같아요:\n\n| 값      | 설명                                                                       |\n|---------|----------------------------------------------------------------------------|\n| `auto`  | 기본 동작으로, 브라우저가 최적이라고 판단하는 방식을 따릅니다.             |\n| `block` | 폰트가 로드될 때까지 텍스트를 숨깁니다. (Flash of Invisible Text - FOIT)    |\n| `swap`  | 폰트가 로드되기 전까지 시스템 기본 폰트로 대체하여 보여줍니다. (Flash of Unstyled Text - FOUT), 기본값이에요. |\n| `fallback` | 짧은 시간 동안 기본 폰트로 보여주고, 폰트가 로드되면 변경됩니다.            |\n| `optional` | 네트워크 상황이 좋지 않거나 폰트가 늦게 로드될 경우 기본 폰트를 계속 사용합니다.|\n\n이 display 속성을 잘 활용하면 웹 폰트 로딩 시 발생할 수 있는 깜빡임이나 보이지 않는 텍스트 문제를 어느 정도 해결할 수 있어요. 기본적으로는 `swap`이 많이 쓰이는데, 이는 사용자 경험을 위해 빠르게 텍스트를 보여주고 나중에 폰트를 바꾸기 때문이에요. 만약 사용자에게 깜빡임이 전혀 보이지 않게 하려면 `block`을 선택할 수도 있지만, 이 경우 폰트가 늦게 로드될 때 텍스트가 아예 보이지 않는 문제가 생길 수 있어요.\n\n웹 폰트 성능 최적화를 고려할 때 `display` 옵션을 꼭 체크해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js 14부터 도입된 `next/font/google`와 `next/font/local`에서 `display` 옵션을 사용할 수 있어요. 이 옵션은 폰트 로딩 방식을 조절하는데, 특히 사용자 경험에 영향을 많이 끼치죠.\n\n### display 옵션이란?\n\n- **`optional`**: 브라우저가 폰트를 빨리 로드하지 못할 경우, 시스템 기본 폰트로 빠르게 폴백(fallback)하도록 하는 값이에요. 폰트가 늦게 로딩되면 폰트 플래시 현상(FOIT, Flash of Invisible Text)을 줄일 수 있어서 사용자 입장에서 깔끔한 경험을 할 수 있죠.\n\n다른 display 값들도 있지만, `optional`은 특히 모바일 환경이나 네트워크 속도가 느릴 때 효과적이에요.\n\n---\n\n### 간단 사용 예시\n\n```js\nimport localFont from 'next/font/local';\n\nconst myFont = localFont({\n  src: './my-font.woff2',\n  display: 'optional',  // 이 부분이 display 옵션 설정\n});\n```\n\n또는 Google Fonts 사용 시:\n\n```js\nimport { Roboto } from 'next/font/google';\n\nconst roboto = Roboto({\n  weight: '400',\n  display: 'optional',\n});\n```\n\n---\n\n### display 옵션 종류 정리표\n\n| 값         | 설명                                             |\n|------------|--------------------------------------------------|\n| `auto`     | 기본값, 브라우저가 적절히 판단해서 렌더링함      |\n| `block`    | 폰트가 로드될 때까지 텍스트가 보이지 않음(FOIT)  |\n| `swap`     | 기본 폰트로 먼저 렌더링 후, 폰트가 로드되면 교체  |\n| `fallback` | `block`처럼 잠깐 숨겼다가, 기본 폰트로 바꿈       |\n| `optional` | 네트워크 상태에 따라 빠른 폰트 교체 또는 기본 폰트 사용 |\n\n---\n\n### 참고사항\n\n- `optional`로 설정하면 네트워크가 나쁠 때 폰트 플래시 문제를 줄일 수 있지만, 폰트가 늦게 로드되거나 아예 로드되지 않는 경우에도 텍스트가 잘 보여서 사용자 경험이 개선돼요.\n- 반대로 `block`은 폰트가 로딩될 때까지 텍스트가 아예 안 보이기 때문에 SEO나 접근성 측면에서 고려가 필요해요.\n- 폰트 최적화를 위해선 프로젝트 상황에 맞게 `display` 옵션을 조절하는 것이 중요합니다.\n\n---\n\n궁금한 점 있으면 댓글로 남겨주세요! 폰트 로딩을 잘 설정하면 웹사이트 퍼포먼스와 사용자 경험이 확 달라진답니다.😉\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### preload\n\n`preload`는 폰트를 미리 불러올지 말지를 정하는 불리언(boolean) 값이에요. 기본값은 `true`로 설정되어 있죠.\n\n이 옵션은 Next.js에서 `next/font/google`이나 `next/font/local`처럼 폰트를 불러올 때 자주 사용되는데요, 폰트를 미리 불러오면 페이지가 렌더링될 때 폰트가 더 빨리 적용되어 사용자 경험이 좋아지는 장점이 있어요.\n\n하지만 꼭 미리 로딩이 필요한 게 아닐 때는 `preload: false`로 설정해서 네트워크 리소스를 아낄 수도 있답니다. 예를 들어, 특정 폰트를 나중에(사용자가 어떤 특정 모드를 선택했을 때) 써야 한다면 미리 로딩하지 않는 게 효율적일 수 있겠죠.\n\n---\n\n#### 정리하자면\n\n| 옵션명 | 타입    | 기본값 | 설명                                    |\n|-------|--------|-------|---------------------------------------|\n| preload | boolean | true  | 폰트를 미리 로드할지 여부를 지정해요. |\n\n---\n\n참고로, 폰트 프리로드는 크롬 같은 주요 브라우저에서 더 빠른 렌더링을 도와주는 기술이에요. 다만 너무 많은 폰트를 한꺼번에 프리로드하면 오히려 초기 로딩 시간을 늘릴 수 있으니 적절히 사용하는 게 좋아요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예시:\n\n- preload: false\n\n### fallback\n\n폰트가 로드되지 않을 때 사용할 대체 폰트입니다. 기본 폰트 없이 대체할 폰트들을 문자열 배열 형태로 지정하는 거예요.\n\n---\n\n추가로 설명하자면, 웹에서 커스텀 폰트를 쓸 때 가끔 폰트가 늦게 로딩되거나 실패할 수 있잖아요? 이럴 때 미리 지정한 fallback 폰트들이 대신 적용돼서 사용자 경험이 깨지지 않도록 도와줘요. 예를 들어 'Roboto' 폰트가 로드되지 않으면 'Arial'이나 'sans-serif' 같은 기본 폰트로 바꿔주는 거죠.\n\n\nfallback: ['Arial', 'Helvetica', 'sans-serif']\n\n\n이런 식으로 배열로 적어주면 되고, 순서대로 브라우저에게 적용 가능한 폰트를 찾아 사용하게 해요. 이렇게만 잘 활용해도 웹사이트 텍스트가 깔끔하게 보여서 좋답니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Optional\n\nnext/font/google과 next/font/local에서 사용돼요.\n\n예를 들어:\n\n- fallback: [`system-ui`, `arial`]: 폰트가 제대로 로드되지 않을 때 대신 사용할 폰트들을 배열로 설정하는 거예요. 여기서는 `system-ui`나 `arial` 같은 시스템 기본 폰트들이 fallback으로 들어가 있죠.\n\n폰트 로딩에 있어 fallback 설정은 사용자 경험에서 꽤 중요해요. 왜냐하면 웹폰트가 느리게 로딩되거나 실패할 때, 아무 글씨도 안 보이거나 이상한 글꼴로 보이면 사용자가 불편하거든요. 그래서 `fallback`에 신뢰할 수 있는 기본 폰트를 적절히 지정해 두면, 렌더링이 순조롭게 이뤄져요.\n\n혹시 여러분 프로젝트에서도 Google 폰트나 로컬 폰트를 쓸 때 이 `fallback` 옵션 꼭 활용해 보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### adjustFontFallback\n\n- **next/font/google**에서 사용하는 옵션으로, 자동으로 폰트 대체(fallback) 폰트를 적용할지 여부를 설정하는 불리언 값입니다. 이 기능을 켜면 Cumulative Layout Shift(CLS, 누적 레이아웃 이동)를 줄여서 사용자 경험을 더 좋게 만들어 줍니다. 기본값은 `true`입니다.\n- **next/font/local**에서는 문자열 또는 불리언 false 값을 받으며, 마찬가지로 자동 폰트 대체를 설정합니다. 여기서는 `\"Arial\"`, `\"Times New Roman\"` 중 하나 또는 `false`를 사용할 수 있는데, 기본값은 `\"Arial\"`입니다.  \n\n| 속성                  | next/font/google                | next/font/local                   | 기본값          | 설명                                      |\n|---------------------|-----------------------------|------------------------------|---------------|-----------------------------------------|\n| **adjustFontFallback** | boolean (true/false)           | string (\"Arial\", \"Times New Roman\") or false | true (google), \"Arial\" (local) | 자동 fallback 폰트 적용 여부 (CLS 감소 목적) |\n\n\u003e 참고로, CLS는 웹 페이지가 로딩될 때 글자가 갑자기 바뀌거나 레이아웃이 흔들리는 현상으로 사용자에게 불편을 주는데, 이 옵션을 적절히 사용하면 그런 현상을 줄일 수 있어서 페이지가 훨씬 안정적으로 느껴집니다. 로컬 폰트 쓸 때는 원하는 fallback 폰트를 직접 지정할 수 있는 점도 편리하니 참고하세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예시:\n\n- `adjustFontFallback: false`: `next/font/google`에 사용할 때\n- `adjustFontFallback: 'Times New Roman'`: `next/font/local`에 사용할 때\n\n### variable\n\n스타일을 CSS 변수 방식으로 적용할 때 사용할 CSS 변수 이름을 지정하는 문자열 값이에요.\n\n---\n\n조금 더 설명하자면, `adjustFontFallback` 옵션은 폰트가 로드되지 않았을 때 대체 폰트를 어떻게 처리할지 결정하는 설정입니다. 예를 들어, Google 폰트를 쓸 때는 기본값으로 그냥 false를 주면서 별도의 fallback 폰트 조정 없이 사용할 수 있지만, 로컬 폰트를 쓸 땐 직접 fallback 폰트를 지정할 수 있어요.\n\n그리고 `variable` 속성은 CSS 변수를 활용할 때 변수 이름을 정하는 부분인데, 이걸 잘 활용하면 다크모드나 테마 변경 같은 동적 스타일 변경에 훨씬 유용합니다. 예를 들어, `\"--my-font-variable\"` 같은 이름으로 지정하면 CSS 내에서 `var(--my-font-variable)`로 폰트를 쉽게 관리할 수 있어요.\n\n이런 식으로 적절한 옵션 조합을 통해 폰트 로딩과 스타일 적용을 더 세밀하게 제어할 수 있으니 참고하세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nnext/font/google과 next/font/local에서 사용하는 옵션 중 하나를 소개할게요.\n\n### 선택적(옵션) 속성 예시\n\n#### variable: `--my-font`\n여기서 `variable`은 CSS 변수 이름을 지정할 때 쓰는 옵션이에요. 예를 들어 `--my-font`라고 하면, 이 폰트를 가리키는 CSS 변수가 `--my-font`로 선언된다는 뜻이죠.\n\n```jsx\nimport localFont from 'next/font/local';\n\nconst myFont = localFont({\n  src: './my-font.woff2',\n  variable: '--my-font',\n});\n```\n\n위처럼 설정하면, CSS에서 `var(--my-font)`로 이 폰트를 참조할 수 있어요.\n\n왜 이게 유용하냐면, 프로젝트에서 여러 군데서 일관된 폰트를 쓰고 싶을 때, CSS 변수를 사용하면 한 번에 관리하기 편하거든요. 폰트를 바꾼다거나 할 때도 변수만 바꾸면 전체에 바로 반영되니까요.\n\n마치 CSS 커스텀 프로퍼티를 사용하는 것과 같은 개념이에요. Next.js의 `next/font`는 이렇게 편리한 방식으로 폰트를 다룰 수 있게 도와주니까, 폰트 관리에 투자하는 시간이 훨씬 줄어들 거예요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### declarations\n\n여기서 말하는 declarations는 폰트를 정의할 때 사용하는 여러 속성들을 모아놓은 배열이에요. 쉽게 말해, `@font-face`를 좀 더 자세히 설정할 수 있도록 도와주는 key-value 쌍들의 집합이죠.\n\n이건 주로 `next/font/local`에서 쓰이는데, 꼭 필요한 건 아니고 선택사항이에요. 그러니까 필요한 경우에만 폰트 스타일, 무게, 범위 같은 추가 정보를 덧붙이고 싶을 때 사용하면 좋아요.\n\n예를 들면, `font-weight`나 `unicode-range` 같은 세부 설정을 통해 폰트가 더욱 정확하게 로드되도록 제어할 수 있어요. 이런 걸 잘 활용하면 웹사이트를 더 깔끔하고 빠르게 만들 수 있으니 참고해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예시:\n\n- 선언: [' prop: `ascent-override`, value: `90%` ']\n\n## 스타일 적용하기\n\n폰트 스타일을 적용하는 방법은 크게 세 가지가 있어요:\n\n- 인라인 스타일(inline style)로 직접 선언하기\n- CSS 클래스에 스타일 지정하기\n- JavaScript 등 스크립트로 동적으로 스타일 추가하기\n\n이 중에서 어떤 방법을 쓸지는 프로젝트 상황에 따라 달라지는데, 간단한 테스트나 빠른 적용에는 인라인 스타일이 편하고, 유지보수가 중요한 경우 CSS 클래스로 관리하는 게 좋아요. 혹은 복잡한 사용자 인터랙션이 필요하면 JavaScript를 활용해서 동적으로 바꾸는 방법도 쓸 수 있답니다.\n\n궁금하면 더 자세히 설명해줄게요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n좋아요, 이번에는 웹 개발할 때 자주 쓰이는 세 가지 CSS 관련 속성에 대해 이야기해볼게요: `className`, `style`, 그리고 CSS Variables에 대해서요.\n\n---\n\n### className\n\n`className`은 리액트(React)에서 HTML 요소에 CSS 클래스를 지정할 때 쓰는 속성이에요. 보통 HTML에서는 `class`라고 적지만, 리액트에서는 `class`가 자바스크립트 예약어라서 `className`으로 표기해요.\n\n예를 들어, 어떤 폰트를 불러왔다고 할 때, 그 폰트와 연결된 CSS 클래스를 다음처럼 사용할 수 있어요.\n\n```jsx\n\u003cp className={inter.className}\u003eHello, Next.js!\u003c/p\u003e\n```\n\n여기서 `inter.className`은 불러온 'Inter' 폰트와 연결된 고유한 클래스명이에요. 이렇게 하면 해당 폰트 스타일이 `p` 태그에 적용돼서 글자가 예쁘게 잘 보이게 되죠.\n\n---\n\n### style\n\n`style`은 HTML 요소에 인라인 CSS를 직접 넣을 때 사용하는 속성이에요. 리액트에서는 스타일을 객체 형태로 넘겨줘야 해요.\n\n```jsx\n\u003cp style={{ color: 'blue', fontSize: '16px' }}\u003eStyled text\u003c/p\u003e\n```\n\n이렇게 하면 글자 색이 파란색이고 글씨 크기가 16px인 텍스트를 만들 수 있죠. 간단해서 편하긴 한데, 코드가 길어지면 가독성이 떨어질 수 있으니 너무 남발하는 건 피하는 게 좋아요.\n\n---\n\n### CSS Variables (커스텀 프로퍼티)\n\nCSS Variables, 즉 커스텀 프로퍼티는 CSS 안에서 변수를 선언하고 재사용할 수 있게 도와줘요. 예를 들어, 자주 쓰는 색상을 변수에 담아두면 유지보수할 때 아주 편하죠.\n\n```css\n:root {\n  --main-color: #4CAF50;\n  --padding: 10px;\n}\n\n.button {\n  background-color: var(--main-color);\n  padding: var(--padding);\n}\n```\n\n리액트나 Next.js에서도 CSS 변수를 사용할 수 있는데, 특히 다크모드 같은 테마를 구현할 때 유용해요. 예를 들어, 자바스크립트로 CSS 변수를 조작해서 실시간으로 스타일이 바뀌게 만들 수도 있답니다.\n\n---\n\n### 추가 팁!\n\n- **className**과 **style**은 상황에 따라 적절히 섞어 쓰는 게 좋아요. 복잡하거나 여러 요소에 적용하는 스타일은 CSS 클래스(`className`)로 관리하고, 간단히 몇 가지 스타일만 바꾸고 싶을 땐 `style`을 쓰는 게 효율적이죠.\n\n- 프로젝트가 커질수록 CSS-in-JS 라이브러리(예: styled-components, emotion)를 활용해서 `className`과 `style`을 관리하면 훨씬 편리해져요.\n\n---\n\n요약하자면,  \n- `className`: CSS 클래스를 붙일 때  \n- `style`: 인라인 스타일 직접 쓸 때  \n- CSS Variables: 반복되는 스타일 값들을 변수처럼 처리할 때\n\n이걸 잘 활용하면 깔끔하고 유지보수가 쉬운 스타일 관리를 할 수 있으니 꼭 기억해 주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### style\n\n이 스타일은 로드된 폰트에 대해 읽기 전용 CSS 스타일 객체를 반환해주는데요, 이 스타일 객체는 HTML 요소에 바로 적용할 수 있어요. 여기에는 `style.fontFamily` 속성이 포함되어 있어서, 폰트 패밀리 이름과 함께 대체 폰트들도 쉽게 접근할 수 있습니다.\n\n예를 들어, 아래처럼 사용할 수 있죠:\n\n```jsx\n\u003cp style={inter.style}\u003eHello World\u003c/p\u003e\n```\n\n위 코드를 보면, `inter.style`이 바로 `fontFamily` 정보를 포함한 CSS 스타일 객체를 반환해서, 텍스트에 원하는 폰트가 바로 적용되는 모습을 볼 수 있어요.\n\n\u003e 참고로, 이렇게 스타일 객체를 활용하면 별도로 CSS 파일을 수정하지 않아도 되고, 컴포넌트 단위로 쉽게 폰트를 적용할 수 있어서 유용합니다.\n\n### CSS Variables\n\n물론, CSS 변수 방식으로도 폰트를 제어할 수 있는데요, 이 방법은 스타일이 적용되는 범위를 더 세밀하게 조절할 수 있고, 전역 스타일과도 잘 어울립니다. 필요하다면 다음번에 CSS 변수 사용법에 대해서도 알려드릴게요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n외부 스타일 시트에 스타일을 설정하고 추가 옵션들을 지정하고 싶다면, CSS 변수 방법을 활용하는 게 좋아요.\n\n폰트를 불러오는 것뿐만 아니라, CSS 변수가 정의된 CSS 파일도 함께 import한 다음, 폰트 로더 객체의 variable 옵션에 변수를 이렇게 설정하면 됩니다:\n\n```js\nimport { Inter } from 'next/font/google'\nimport styles from '../styles/component.module.css'\n \nconst inter = Inter({\n  variable: '--font-inter',\n})\n```\n\n그리고 폰트를 적용하고 싶은 텍스트의 부모 컨테이너에는 이 폰트 로더의 변수 값을 className으로 넣어주고, 텍스트에는 외부 CSS 파일에서 가져온 styles의 클래스를 넣어주면 돼요.\n\n간단하게 요약하면 이렇게 사용할 수 있죠:\n\n| 역할           | 할당하는 className 값             |\n| -------------- | ------------------------------- |\n| 텍스트 부모 컨테이너 | `inter.variable` (예: `\"--font-inter\"`에 해당하는 클래스) |\n| 텍스트 요소       | `styles`에서 임포트한 CSS 클래스 (예: `styles.textClass`) |\n\n이 방법의 장점은 폰트 설정을 CSS 변수로 관리하다 보니, 폰트를 바꾸거나 조정할 때 외부 CSS만 수정하면 되서 유지보수가 훨씬 편해진다는 점이에요. 그리고 스타일과 폰트 로딩 코드를 깔끔하게 분리할 수 있어서 프로젝트 구조가 한결 명료해집니다.\n\n참고로, CSS 변수는 전역적으로도 사용할 수 있으니, 이렇게 지정해 놓으면 여러 컴포넌트에서 동일한 폰트를 쉽게 재사용할 수 있는 점도 기억해두세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자, 위에 코드를 보면 React 컴포넌트 안에서 클래스를 이용해 글자 스타일을 지정하고 있어요. 간단히 설명하자면, `Hello World` 텍스트에 `Inter` 폰트를 적용하고, 폰트 두께는 200(얇음), 스타일은 이탤릭으로 주는 거죠.\n\n먼저, 컴포넌트 내 JSX는 이렇게 생겼고요:\n\n```jsx\n\u003cmain className={inter.variable}\u003e\n  \u003cp className={styles.text}\u003eHello World\u003c/p\u003e\n\u003c/main\u003e\n```\n\n그리고 `component.module.css` 파일 안에 `.text` 클래스가 아래처럼 정의되어 있답니다:\n\n```css\n.text {\n  font-family: var(--font-inter);\n  font-weight: 200;\n  font-style: italic;\n}\n```\n\n여기서 중요한 점은 `var(--font-inter)` 부분이에요. CSS 변수로 지정된 폰트 이름인데, 아마 글로벌 CSS나 루트에서 `--font-inter`가 Inter 폰트를 가리키는 값으로 설정돼 있을 거예요. 이렇게 하면 폰트를 프로젝트 어느 곳에서나 일관되게 사용할 수 있고, 만약 폰트를 바꾸고 싶으면 변수값만 수정하면 돼서 관리도 편하답니다.\n\n또, `font-weight: 200`은 폰트가 얇게 나오도록 해주고, `font-style: italic`으로 기울임꼴(이탤릭) 효과를 줍니다. 폰트는 사용자를 위한 시각적 느낌을 많이 좌우하니까, 이렇게 세심한 조정을 해주는 게 중요해요.\n\n추가 팁을 하나 드리면, Inter 같은 웹폰트를 사용할 때는 로딩 속도를 위해서 구글 폰트 라이브러리를 사용하거나, 로컬에 폰트를 두고 `@font-face`로 불러오는 방법도 좋아요. 그리고 여러 웹폰트 옵션들(font-weight, font-style 등)을 미리 로드해두면, 사용자 경험이 더 매끄러워집니다!\n\n정리해보면 간단하게:\n\n| 부분          | 역할                               |\n| ------------- | --------------------------------- |\n| `className={styles.text}` | CSS 모듈에서 정의한 텍스트 스타일 적용 |\n| `font-family: var(--font-inter)` | Inter 폰트 사용 설정(변수로 관리)       |\n| `font-weight: 200`         | 얇은 글씨 두께 지정                   |\n| `font-style: italic`       | 이탤릭체 스타일 적용                  |\n\n이렇게 해놓고 필요하면 더 세밀하게 스타일도 추가하고, 폰트도 다양하게 적용해보세요. 폰트 하나 바꾸는 것만으로도 사이트 분위기가 확 달라질 수 있답니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 폰트 정의 파일(font definitions file) 활용하기\n\n로컬 폰트나 구글 폰트를 사용할 때마다 해당 폰트가 애플리케이션에 하나의 인스턴스로 호스팅됩니다. 그래서 여러 군데에서 같은 폰트를 쓴다면, 매번 호출하는 것보다 한 곳에서 폰트를 불러오고 필요한 곳에서 그 폰트 객체를 가져다 쓰는 게 훨씬 효율적이에요. 이걸 위해 폰트 정의 파일을 만드는 방법을 추천합니다.\n\n예를 들어, 프로젝트 루트에 `styles` 폴더를 만들고 그 안에 `fonts.ts` 파일을 만듭니다.\n\n그리고 이렇게 폰트 정의를 작성해보세요:\n\n```ts\n// styles/fonts.ts\nimport { localFont } from '@next/font/local';\n\nexport const myLocalFont = localFont({\n  src: './path/to/your/font.woff2',\n  weight: '400',\n  style: 'normal',\n  variable: '--my-local-font',\n});\n\nimport { GoogleFont } from '@next/font/google';\n\nexport const myGoogleFont = GoogleFont({\n  family: 'Roboto',\n  weights: ['400', '700'],\n  subsets: ['latin'],\n  variable: '--my-google-font',\n});\n```\n\n이제 이 `fonts.ts` 파일에서 내보낸 `myLocalFont`, `myGoogleFont` 같은 폰트 객체를 각각 필요한 컴포넌트나 페이지에서 불러와 사용하면 돼요.\n\n---\n\n### 추가 TIP!\n\n- 이렇게 폰트를 한 곳에서 관리하면, 향후 폰트 이름이나 스타일, 굵기를 변경할 때 훨씬 간편해져요.\n- `variable` 옵션을 지정해두면 CSS 변수로도 폰트를 사용할 수 있어서 스타일링 할 때 유연성이 증가한답니다.\n- 특히 구글 폰트는 여러 폰트 원격 호출을 줄일 수 있어서 퍼포먼스에도 도움이 돼요.\n\n한 번 깔끔하게 정리해두면 프로젝트 유지보수할 때 정말 큰 도움이 되니, 꼭 시도해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 구글 폰트와 로컬 폰트를 쉽게 불러와서 사용하는 방법 소개해볼게요. \n\n먼저, `next/font/google`과 `next/font/local`을 활용해서 폰트를 정의해봅시다.\n\n```js\nimport { Inter, Lora, Source_Sans_3 } from 'next/font/google'\nimport localFont from 'next/font/local'\n\n// 변수 폰트를 간단히 정의\nconst inter = Inter()\nconst lora = Lora()\n\n// 일반(non-variable) 폰트의 두 가지 굵기 정의\nconst sourceCodePro400 = Source_Sans_3({ weight: '400' })\nconst sourceCodePro700 = Source_Sans_3({ weight: '700' })\n\n// 로컬 폰트 정의 (styles 폴더에 GreatVibes-Regular.ttf가 있다고 가정)\nconst greatVibes = localFont({ src: './GreatVibes-Regular.ttf' })\n\nexport { inter, lora, sourceCodePro400, sourceCodePro700, greatVibes }\n```\n\n이렇게 하면 어느 컴포넌트에서든 폰트 클래스를 쉽게 불러와서 쓸 수 있어요.\n\n```js\nimport { inter, lora, sourceCodePro700, greatVibes } from '../styles/fonts'\n\nexport default function Page() {\n  return (\n    \u003cdiv\u003e\n      \u003cp className={inter.className}\u003eInter 폰트로 인사하기\u003c/p\u003e\n      \u003cp style={lora.style}\u003eLora 폰트로 인사하기\u003c/p\u003e\n      \u003cp className={sourceCodePro700.className}\u003e\n        700 굵기의 Source_Sans_3 폰트로 인사하기\n      \u003c/p\u003e\n      \u003cp className={greatVibes.className}\u003eGreat Vibes 폰트로 멋진 제목\u003c/p\u003e\n    \u003c/div\u003e\n  )\n}\n```\n\n타입스크립트 혹은 자바스크립트 환경에서 폰트 경로를 더 간편하게 관리하려면, `tsconfig.json` 또는 `jsconfig.json`에 alias를 등록하는 것도 좋아요.\n\n```json\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"@fonts/*\": [\"styles/*\"]\n    }\n  }\n}\n```\n\n이 설정을 하면, 폰트 임포트할 때 이렇게 사용할 수 있죠:\n\n```js\nimport { inter, lora } from '@fonts/fonts'\n```\n\n---\n\n### 추가 팁!\n\n- `next/font`는 SSR(서버사이드 렌더링) 환경에서도 최적화된 폰트를 자동으로 처리해주기 때문에, 따로 폰트 파일을 직접 관리하는 번거로움이 줄어들어요.\n- 로컬 폰트는 상대경로가 정확해야 합니다. 폰트 위치가 바뀌면 해당 경로를 꼭 확인하세요.\n- 폰트 로딩 전략이나 폰트 디스플레이 옵션도 `next/font`에서 조절할 수 있는데, 퍼포먼스 최적화에 관심이 있는 분들은 공식 문서를 한번 봐보면 좋습니다.\n- `className` 과 `style` 옵션을 동시에 제공하는 경우가 있는데, 보통 변수 폰트는 `className`을, 비변수 폰트나 로컬 폰트는 `style` 혹은 `className` 모두 사용할 수 있으니 상황에 맞게 쓰시면 됩니다.\n\n이렇게 세팅해두면 폰트를 다양하게 적용하기 편해서 UI 작업할 때 훨씬 수월해져요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여러분, 오늘은 TypeScript나 JavaScript 프로젝트에서 경로 별칭(Path Alias)을 설정하는 법을 간단히 소개하려고 해요. 특히 폰트처럼 자주 쓰는 리소스를 깔끔하게 import하고 싶을 때 매우 유용하답니다!\n\n먼저, `tsconfig.json` 혹은 `jsconfig.json` 파일에 다음과 같은 설정을 추가해 주세요:\n\n```json\n{\n  \"compilerOptions\": {\n    \"paths\": {\n      \"@/fonts\": [\"./styles/fonts\"]\n    }\n  }\n}\n```\n\n여기서 `\"@/fonts\"`란 별칭(alias)이 `./styles/fonts` 디렉터리를 가리키도록 해주는 거예요. 이제부터는 해당 폴더의 내용을 편하게 이렇게 불러올 수 있습니다:\n\n```js\nimport { greatVibes, sourceCodePro400 } from '@/fonts'\n```\n\n이 방식의 장점은?  \n- 복잡한 상대 경로(`../../../styles/fonts`) 대신 깔끔한 별칭 사용  \n- 프로젝트 구조가 바뀌어도 alias만 수정하면 되니 유지보수 편리  \n- 가독성 UP\n\n---\n\n### 버전별 차이 정리\n\n| TypeScript 버전 | 경로 별칭 지원 상황                                             |\n|-----------------|---------------------------------------------------------------|\n| 2.0 이상        | `paths` 옵션으로 기본 지원 (단, `baseUrl`과 같이 설정 필요)     |\n| 4.x 이상        | 점점 향상된 타입 추론과 함께 별칭 관련 IDE 지원 강화          |\n| Next.js 등 프레임워크 | 프레임워크별 `jsconfig.json` 혹은 `tsconfig.json`에서 지원 및 별도 설정 필요 |\n\n참고로, Next.js 프로젝트라면 `jsconfig.json` 파일에 위와 같은 `paths` 설정을 넣어주고 재시작해 주시면 바로 적용돼요!\n\n---\n\n### 추가 팁\n\n- `baseUrl` 설정도 같이 해주면 편리합니다. 보통 이렇게 쓰죠:\n\n```json\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"@/fonts\": [\"./styles/fonts\"]\n    }\n  }\n}\n```\n\n- VSCode 같은 IDE도 `jsconfig.json` 혹은 `tsconfig.json` 변경 사항을 바로 인식해서 자동완성 지원이 팍팍 될 거예요!\n\n이렇게 하면 프로젝트를 좀 더 깔끔하게 관리할 수 있답니다. 다음에도 개발 팁으로 또 만나요! 😊\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n| Version    | Changes                                          |\n|------------|--------------------------------------------------|\n| `v13.2.0`  | `@next/font`가 `next/font`로 이름이 변경되었습니다. 이제 별도의 설치가 필요 없어요. |\n| `v13.0.0`  | `@next/font`가 처음 도입되었습니다.              |\n\n---\n\n이번에 살펴볼 내용은 Next.js의 폰트 관련 변경사항이에요. 이전에는 `@next/font`라는 패키지를 별도로 설치해서 사용했는데, 13.2.0 버전부터는 이 패키지 이름이 `next/font`로 바뀌면서 따로 설치를 할 필요가 없어졌답니다.  \n\n즉, Next.js 프로젝트에 기본 내장된 기능으로 제공되니 바로 import해서 쓸 수 있어요. 이렇게 하면 번들 크기를 줄이고, 설정도 훨씬 간편해져서 개발 편의성이 좋아졌죠.\n\n추가로, `@next/font`가 도입된 13.0.0부터 이 기능을 사용할 수 있었으니, 만약 예전 프로젝트라면 최신 버전으로 업그레이드하는 걸 추천드려요. 최신 Next.js는 폰트를 다루기 편하게 만들어서 페이지 속도와 사용자 경험 모두 살릴 수 있답니다.","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":34}],"page":"12","totalPageCount":50,"totalPageGroupCount":3,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"12"},"buildId":"KUC9M_yIlA1Ugo01xmkHL","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>