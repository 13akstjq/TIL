<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>TIL</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//posts/6" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="TIL" data-gatsby-head="true"/><meta property="og:title" content="TIL" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//posts/6" data-gatsby-head="true"/><meta name="twitter:title" content="TIL" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/7978fe7362f7d4c9.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/7978fe7362f7d4c9.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/TIL/_next/static/chunks/463-925361deb4cec4b1.js" defer=""></script><script src="/TIL/_next/static/chunks/873-2eda6d845ad1e69e.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/posts/%5Bpage%5D-350e448526ad5efa.js" defer=""></script><script src="/TIL/_next/static/OY-qm1-_Mz9jLZ5863EbF/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/OY-qm1-_Mz9jLZ5863EbF/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="웹 서비스 개발을 위한 언어 선택 가이드" href="/TIL/post/2024-07-09-Decidingonalanguageforyourwebservice"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="웹 서비스 개발을 위한 언어 선택 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-09-Decidingonalanguageforyourwebservice_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="웹 서비스 개발을 위한 언어 선택 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">웹 서비스 개발을 위한 언어 선택 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">6 hours ago</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="파이썬 코딩 시작하기 5 딕셔너리 2부" href="/TIL/post/2024-07-09-StartCodingwithPython5DictionariespartII"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="파이썬 코딩 시작하기 5 딕셔너리 2부" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/no-image.jpg"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="파이썬 코딩 시작하기 5 딕셔너리 2부" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">파이썬 코딩 시작하기 5 딕셔너리 2부</strong><div class="PostList_meta__VCFLX"><span class="date">6 hours ago</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="초보 때 알았더라면 좋았을 Python 코딩 꿀팁 10가지" href="/TIL/post/2024-07-09-PythonCodingTipsLessonsIWishIKnewWhenIStartedCoding"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="초보 때 알았더라면 좋았을 Python 코딩 꿀팁 10가지" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-09-PythonCodingTipsLessonsIWishIKnewWhenIStartedCoding_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="초보 때 알았더라면 좋았을 Python 코딩 꿀팁 10가지" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">초보 때 알았더라면 좋았을 Python 코딩 꿀팁 10가지</strong><div class="PostList_meta__VCFLX"><span class="date">6 hours ago</span><span class="PostList_reading_time__6CBMQ">25<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="3일차, 4일차  진도가 부족한 이유" href="/TIL/post/2024-07-09-Day3Day4NotEnoughProgress"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="3일차, 4일차  진도가 부족한 이유" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-09-Day3Day4NotEnoughProgress_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="3일차, 4일차  진도가 부족한 이유" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">3일차, 4일차  진도가 부족한 이유</strong><div class="PostList_meta__VCFLX"><span class="date">6 hours ago</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="빠른 푸리에 변환을 이용한 주식 시장 신호 분석 방법" href="/TIL/post/2024-07-09-StockMarketSignalAnalysisUsingFastFourierTransform"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="빠른 푸리에 변환을 이용한 주식 시장 신호 분석 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-09-StockMarketSignalAnalysisUsingFastFourierTransform_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="빠른 푸리에 변환을 이용한 주식 시장 신호 분석 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">빠른 푸리에 변환을 이용한 주식 시장 신호 분석 방법</strong><div class="PostList_meta__VCFLX"><span class="date">6 hours ago</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="NanoLlava 가장 작은 시각적 언어란" href="/TIL/post/2024-07-09-NanoLlavaisthesmallestVisualLanguage"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="NanoLlava 가장 작은 시각적 언어란" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-09-NanoLlavaisthesmallestVisualLanguage_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="NanoLlava 가장 작은 시각적 언어란" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">NanoLlava 가장 작은 시각적 언어란</strong><div class="PostList_meta__VCFLX"><span class="date">6 hours ago</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="뉴럴 네트워크 손실 함수 이해 및 구현 방법 기초부터" href="/TIL/post/2024-07-09-UnderstandingImplementingDifferentLossFunctionsofNeuralNetworksfromScratch"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="뉴럴 네트워크 손실 함수 이해 및 구현 방법 기초부터" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-09-UnderstandingImplementingDifferentLossFunctionsofNeuralNetworksfromScratch_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="뉴럴 네트워크 손실 함수 이해 및 구현 방법 기초부터" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">뉴럴 네트워크 손실 함수 이해 및 구현 방법 기초부터</strong><div class="PostList_meta__VCFLX"><span class="date">6 hours ago</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Mojo, Python보다 90,000배 빠르다 드디어 오픈소스 공개 출시 즉시 17,000 스타 돌파" href="/TIL/post/2024-07-09-Mojo90000TimesFasterThanPythonFinallyOpenSourcedJustLaunchedAlreadySurpassing17000Stars"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Mojo, Python보다 90,000배 빠르다 드디어 오픈소스 공개 출시 즉시 17,000 스타 돌파" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-09-Mojo90000TimesFasterThanPythonFinallyOpenSourcedJustLaunchedAlreadySurpassing17000Stars_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Mojo, Python보다 90,000배 빠르다 드디어 오픈소스 공개 출시 즉시 17,000 스타 돌파" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Mojo, Python보다 90,000배 빠르다 드디어 오픈소스 공개 출시 즉시 17,000 스타 돌파</strong><div class="PostList_meta__VCFLX"><span class="date">6 hours ago</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="PyFilesystem2 OpenCV로 캡처한 프레임을 메모리 파일 시스템에 저장하는 방법" href="/TIL/post/2024-07-09-PyFilesystem2StoringFramesCapturedbyOpenCVinanIn-MemoryFilesystem"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="PyFilesystem2 OpenCV로 캡처한 프레임을 메모리 파일 시스템에 저장하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-09-PyFilesystem2StoringFramesCapturedbyOpenCVinanIn-MemoryFilesystem_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="PyFilesystem2 OpenCV로 캡처한 프레임을 메모리 파일 시스템에 저장하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">PyFilesystem2 OpenCV로 캡처한 프레임을 메모리 파일 시스템에 저장하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">6 hours ago</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="주식 거래에서 가장 인기 있는 10가지 금융 지표" href="/TIL/post/2024-07-09-TheMostPopularFinancialMetricsinStockTrading"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="주식 거래에서 가장 인기 있는 10가지 금융 지표" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/no-image.jpg"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="주식 거래에서 가장 인기 있는 10가지 금융 지표" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">주식 거래에서 가장 인기 있는 10가지 금융 지표</strong><div class="PostList_meta__VCFLX"><span class="date">6 hours ago</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/TIL/posts/1">1</a><a class="link" href="/TIL/posts/2">2</a><a class="link" href="/TIL/posts/3">3</a><a class="link" href="/TIL/posts/4">4</a><a class="link" href="/TIL/posts/5">5</a><a class="link posts_-active__YVJEi" href="/TIL/posts/6">6</a><a class="link" href="/TIL/posts/7">7</a><a class="link" href="/TIL/posts/8">8</a><a class="link" href="/TIL/posts/9">9</a><a class="link" href="/TIL/posts/10">10</a><a class="link" href="/TIL/posts/11">11</a><a class="link" href="/TIL/posts/12">12</a><a class="link" href="/TIL/posts/13">13</a><a class="link" href="/TIL/posts/14">14</a><a class="link" href="/TIL/posts/15">15</a><a class="link" href="/TIL/posts/16">16</a><a class="link" href="/TIL/posts/17">17</a><a class="link" href="/TIL/posts/18">18</a><a class="link" href="/TIL/posts/19">19</a></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"웹 서비스 개발을 위한 언어 선택 가이드","description":"","date":"2024-07-09 15:08","slug":"2024-07-09-Decidingonalanguageforyourwebservice","content":"\n\nSingularity에서는 주로 웹 서비스에 Python을 사용합니다. 프론트 엔드에서는 Typescript를 사용합니다. 또한 실시간 푸시 서버에는 Elixir를 사용합니다. 최근에 매우 높은 I/O 처리량이 필요한 프로젝트를 시작했는데, Python이 그 사용 사례에서 최선의 도구가 아닐 수도 있다는 걱정이 들었습니다. 그래서 우리는 다음과 같은 질문을 하였습니다:\n\n## 높은 처리량 웹 서비스에 어떤 언어를 사용해야 할까요?\n\n팀 내부의 경험을 기반으로, 우리는 성능을 벤치마킹하고 싶은 몇 가지 후보 언어를 가지고 있었습니다. 팀으로서 우리는 다음을 시험해보기로 결정했습니다:\n\n- NodeJS\n- Java\n- Rust\n- C++\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리는 커뮤니티 지원이 많고 철저한 문서화가 있는 프레임워크와 함께 각 언어를 만들기로 약 2시간을 할애하기로 결정했습니다. 웹 서버들은 PostgreSQL 데이터베이스와 상호 작용하는 도커 컴포즈 네트워크에서 작동할 것입니다. 이 웹 서버들은 ID로 항목을 가져오는 두 가지 Endpoints를 가지게 될 것이며, 페이지/오프셋 매개변수로 항목 목록을 페이징 처리합니다.\n\n## 테스트\n\n실제로 테스트한 언어 및 프레임워크는 다음과 같습니다:\n\n- Python (Flask/SQLAlchemy/psycopg2)\n- NodeJS (express/TypeORM)\n- Rust (Actix Web/tokio_postgres)\n- Async Python (FastAPI/SQLAlchemy/asyncpg)\n- Elixir (Phoenix/Ecto)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리는 C++와 Java도 시도하기로 합의했지만, 심플한 케이스에서도 설정에 어려움을 겪었습니다. 관련 조사를 하는 데 너무 많은 시간이 걸리고, 제가 찾을 수 있는 (공개된) 자료와 커뮤니티 지원이 부족했으며, JSON API → PostgreSQL db 서비스를 짧은 시간에 작동시키지 못했습니다. 나중에 다시 시도해보겠지만, 그 접근의 어려움으로 이번 테스트 세트에 대해 그만두기로 결정했습니다.\n\n나열된 모든 프레임워크와 언어에 대해, 제가 제작한 프로덕션 레디 도커 이미지를 생성하는 데 공식 문서에서 권장하는 방법을 따랐습니다. 그런 다음 나는 이들 이미지를 내 랩탑에서 도커 네트워크에서 컨테이너로 실행했는데, 내 랩탑에는 PostgreSQL 16 도커 컨테이너가 실행 중이어서 모두 같은 데이터베이스에 접근했습니다. 저는 Locust를 사용하여 로컬 환경에서 테스트를 실행했습니다.\n\n이 기사는 각 결과 집합의 이유에 대해서 파헤치지 않을 것입니다. 그렇게 하면 연구와 기사가 훨씬 더 길어질 것입니다. 게다가, 이 연속은 서버의 최고의 IO 처리량을 빨리 배울 수 있는 것이 목적입니다.\n\n각 결과 집합마다, 우리는 동시 사용자 수와 각 프레임워크가 그들을 어떻게 다뤄갔는지 살펴볼 것입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 1,000명 미만의 사용자\n\n각각 1, 10, 100명의 동시 사용자를 대상으로 최대 초당 2개의 요청을 보내는 테스트 세트입니다.\n\nPython\n\n![이미지](/assets/img/2024-07-09-Decidingonalanguageforyourwebservice_0.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNodeJS\n\n![NodeJS](/assets/img/2024-07-09-Decidingonalanguageforyourwebservice_1.png)\n\nElixir\n\n![Elixir](/assets/img/2024-07-09-Decidingonalanguageforyourwebservice_2.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\nRust\n\n![Rust](/assets/img/2024-07-09-Decidingonalanguageforyourwebservice_3.png)\n\nAsync Python\n\n![Async Python](/assets/img/2024-07-09-Decidingonalanguageforyourwebservice_4.png)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 세트의 테스트에서 예상한 대로 동작하는 것을 볼 수 있었습니다. 거의 모든 설정이 약 200개의 동시 요청을 그대로 처리하고 제공합니다. 유일한 예외는 async/await 구문을 사용하는 Python입니다. 불행히도, 약 50%의 오류율이 있었습니다. 로그에 기록된 오류를 살펴보면 다음과 같습니다:\n\nsorry, too many clients already\n\n이 오류는 asyncpg 드라이버에서 전파되었습니다. 이 오류를 찾아보니 PostgreSQL db에서 직접 발생한 오류로, 응용 프로그램 코드의 오류가 아니었습니다. 이 설정을 잘 작동하게 하기 위해 몇 가지 조정과 구성 변경을 할 수 있겠지만, 그렇게 하면 연습의 목적을 상실하게 될 것 같습니다.\n\n이후의 모든 테스트에서는 Async Python 설정을 제외하겠습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 1,000 사용자\n\n파이썬\n\n![이미지](/assets/img/2024-07-09-Decidingonalanguageforyourwebservice_5.png)\n\nNodeJS\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![Elixir](/assets/img/2024-07-09-Decidingonalanguageforyourwebservice_6.png)\n\n![Rust](/assets/img/2024-07-09-Decidingonalanguageforyourwebservice_7.png)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-07-09-Decidingonalanguageforyourwebservice_8.png)\n\n여기서는 초당 약 2,000개의 요청에 대한 설정을 유지하도록 요청하고 있습니다. 모든 프레임워크가 이를 처리하는 데 예쁘게 처리하지만 Python은 그렇지 않습니다. Python은 왜 따라잡지 못할까요? 왜 약 200개의 요청/초까지 제한될까요? 제 정확한 설정은 무엇인가요?\n\n모두 좋은 질문이고, 저도 궁금하지만, 이 문제의 요점은 아닙니다. 그러나 오류가 발생하지 않았기 때문에, 제가 마지막 테스트 세트에 Python을 포함시키겠습니다.\n\n## 2,000 사용자\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\nPython\n\n![Python image](/assets/img/2024-07-09-Decidingonalanguageforyourwebservice_9.png)\n\nNodeJS\n\n![NodeJS image](/assets/img/2024-07-09-Decidingonalanguageforyourwebservice_10.png)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Elixir\n\n![Elixir](/assets/img/2024-07-09-Decidingonalanguageforyourwebservice_11.png)\n\n# Rust\n\n![Rust](/assets/img/2024-07-09-Decidingonalanguageforyourwebservice_12.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기서는 초당 약 4,000개의 요청을 처리할 수 있도록 세팅할 것을 요청하고 있습니다. 이 수준에 도달하려는 모든 프레임워크들이 제대로 따라가기 어려운 것으로 보입니다. 그러나 (Python을 제외한) 모든 세팅이 매우 유사한 동작을 보이는 것으로 보아, 테스트를 실행하는 데 사용하는 노트북에 병목 현상이 있을 수도 있고, 실제 세팅 자체에 병목 현상이 있는 것일 수도 있습니다. 이것이 사실인지 아닌지는 확실하지 않습니다.\n\n# 결론\n\n입출력(IO)이 병목 현상인 고처리량 워크로드에 대해서는, 이러한 세팅 중 어느 것을 선택하고 학습해도 문제가 없어 보입니다. 단, Python을 제외한 모든 것들에 대한 선택을 권합니다.\n\nPython을 사용하길 꺼리지는 않겠습니다. 몇 년간 사용해온 것이며, 설정의 용이성과 문법을 즐기고 있으며, 데이터 분석 및 조작 워크로드에 특히 유용하기 때문에 계속해서 사용할 것입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러나 이 테스트를 실시한 이유는 곧 이전 제품과는 다른 작업량을 갖는 새 제품을 출시할 예정이기 때문입니다. 새 제품을 보다 잘 지원하기 위해 스택을 변경해야 할 지 알아보고 싶었어요.\n\n새 제품이 무엇인지 궁금하신가요? 우리의 스택에 관심이 있으신가요? 결과에 동의하지 않으시나요?\n\n소프트웨어 엔지니어를 채용 중입니다! 메일을 보내서 여러분의 생각을 알려주세요. 의견을 기다리고 있습니다 🌱","ogImage":{"url":"/assets/img/2024-07-09-Decidingonalanguageforyourwebservice_0.png"},"coverImage":"/assets/img/2024-07-09-Decidingonalanguageforyourwebservice_0.png","tag":["Tech"],"readingTime":8},{"title":"파이썬 코딩 시작하기 5 딕셔너리 2부","description":"","date":"2024-07-09 15:07","slug":"2024-07-09-StartCodingwithPython5DictionariespartII","content":"\n\n딕셔너리를 반복하는 방법을 배울 거에요. 딕셔너리는 다양한 방식으로 정보를 저장할 수 있기 때문에, 이를 반복하는 여러 가지 방법이 있어요. 주어진 딕셔너리의 키, 값 또는 모든 키-값 쌍을 반복할 수 있어요.\n\n## 키-값 쌍을 반복하기\n\n세 개의 키-값 쌍을 포함하는 scientist_0 딕셔너리를 고려해봅시다.\n\n```js\n# 파일 이름: scientist.py\n\nscientist_0 = {\n    'username': 'rfeynman',\n    'first name': 'richard',\n    'last name': 'feynman',\n    }\n\nfor key, value in scientist_0.items():\n    print(f\"\\nKey: {key}\")\n    print(f\"Value: {value}\")\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테이블 태그를 Markdown 형식으로 변경해주세요.","ogImage":{"url":"/TIL/assets/no-image.jpg"},"coverImage":"/TIL/assets/no-image.jpg","tag":["Tech"],"readingTime":1},{"title":"초보 때 알았더라면 좋았을 Python 코딩 꿀팁 10가지","description":"","date":"2024-07-09 15:05","slug":"2024-07-09-PythonCodingTipsLessonsIWishIKnewWhenIStartedCoding","content":"\n\n![Python Coding Tips](/assets/img/2024-07-09-PythonCodingTipsLessonsIWishIKnewWhenIStartedCoding_0.png)\n\n코딩 여정을 시작할 때 파이썬 세계에 뛰어 들어가면서 약간의 어려움을 겪었어요. 코딩의 기본은 이해했지만, 내 코드를 효율적으로 만드는 방법을 알아내는 것은 퍼즐을 푸는 것처럼 어려웠죠. 예전에는 종종 파이썬의 신이 이끌어 준다는 말을 기억해요 — 정말 좋은 조언이긴 하지만, 내 생각에는 너무 추상적이었어요. 더 구체적인 예시가 필요했고, 그래서 이 가이드를 만들게 되었답니다.\n\n재미있게도, ChatGPT 시대 이후에 코딩을 배우기 시작한 사람들이 어떻게 코딩을 접근하는지에 변화를 주목했어요. ChatGPT 시대에 배운 사람들은 오류 수정과 디버깅에 뛰어나는 것 같아요. 그 반면, GPT 이전에 코딩한 사람들은 답을 분석하고 Stack Overflow나 문서와 같은 자료를 활용하는 데 능숙해요 — 아마도 조금의 복사-붙여넣기 기술도 있겠죠! ;)\n\n![Python Coding Tips](/assets/img/2024-07-09-PythonCodingTipsLessonsIWishIKnewWhenIStartedCoding_1.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n사진: Kelly Sikkema 님의 Unsplash\n\n저는 Python으로 코딩을 하는 7년 간에 중요한 차이를 만들어 준 몇 가지 개념을 경험해 왔습니다. 이 글에서는 제 경험을 바탕으로 27가지 직관적인 코딩 팁을 공유하고 싶습니다. 이러한 팁들은 제 코딩 속도를 높이는 데 도움이 되었을 뿐만 아니라, 제 코드를 더 깔끔하고 이해하기 쉽게 만들었습니다. 이러한 소중한 팁을 나누는 동안 함께해 주세요. 혹시 당신의 코딩 여정과 맞닿는 팁을 발견할 수도 있을 것입니다!\n\n# 1. F-Strings: 동적 문자열 포맷팅\n\n장점:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 간결하고 읽기 쉬운 구문.\n- 문자열 내부에 쉽게 표현식을 넣을 수 있습니다.\n\n단점:\n- Python 3.6 이상에서만 사용 가능합니다.\n- 보안 취약점에 주의해야 합니다; SQL Injection\n\n예시:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nname = \"John\"\nage = 25\nmessage = f\"My name is {name}, and I am {age} years old.\"\n```\n\n## 2. 데코레이터: 기능 동적으로 개선하기\n\n장점:\n\n- 함수의 동작을 확장하는 깔끔한 방법을 제공합니다.\n- 코드 재사용성을 향상시킵니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nCons:\n\n- 데코레이터를 과도하게 사용하면 코드를 이해하기 어렵게 만들 수 있습니다.\n\n예시:\n\n```python\nimport time\ndef timer_decorator(func):\n    def wrapper(*args, **kwargs):\n        start_time = time.time()\n        result = func(*args, **kwargs)\n        end_time = time.time()\n        print(f\"{func.__name__} executed in {end_time - start_time} seconds\")\n        return result\n    return wrapper\n@timer_decorator\ndef example_function():\n    # 함수 로직이 여기에 있습니다\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 3. Python 숙련도 향상을 위한 help() 함수 활용\n\n장점:\n\n- 즉각적인 문서화: 코드 내에서 Python 객체, 모듈 또는 함수에 대한 문서를 빠르게 참조할 수 있습니다.\n- 대화식 학습: Python 인터프리터나 스크립트에서 직접 생소한 모듈이나 함수를 탐색하고 학습하기에 이상적입니다.\n\n단점:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 제한된 정보: help()를 통해 제공되는 정보는 때로 간결할 수 있으며, 복잡한 주제에 대해서는 보다 자세한 문서가 필요할 수 있습니다. help()의 효과는 코드 내 docstrings의 존재와 품질에 따라 달라집니다.\n\n예시:\n\n```js\n# 예시: help() 함수 사용하기\ndef calculate_square(number):\n    \"\"\"\n    주어진 숫자의 제곱을 계산합니다.매개변수:\n    - number (int): 입력 숫자.\n    반환:\n    - int: 입력 숫자의 제곱 값.\n    \"\"\"\n    return number ** 2\n# calculate_square 함수에 대한 도움말 얻기\nhelp(calculate_square)\n```\n\n# 4. List Comprehensions: 간결한 리스트 생성\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n장점:\n\n- 목록 생성 로직을 간결하게 만들어 가독성을 향상시킵니다.\n- 기존 루프와 비교하여 성능을 향상시키는 경우가 많습니다.\n\n단점:\n\n- 특히 복잡한 로직에서는 가독성을 높이기 위해 중첩된 리스트 컴프리헨션을 피해야 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예시:\n\n```js\n# 범위 내에서 짝수의 제곱값 찾기\nsquares = [x**2 for x in range(10) if x % 2 == 0]\n```\n\n# 5. 루프에서의 else 절\n\n장점:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 루프가 break 문이 없이 자연스럽게 완료될 때 코드를 실행할 수 있습니다.\n- 특정 동작이 성공적인 루프를 따라야 하는 시나리오에 이상적입니다.\n\n단점:\n\n- 종종 간과되거나 오해되어 잠재적인 논리 오류로 이어질 수 있습니다.\n\n예시:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# else 절을 사용하여 소수 찾기\nfor n in range(2, 10):\n    for x in range(2, n):\n        if n % x == 0:\n            break\n    else:\n        print(n, \"은(는) 소수입니다.\")\n```\n\n# 6. 람다 함수: 빠르고 익명의 함수\n\n장점:\n\n- 간단한 함수를 간결하게 한 줄에 작성할 수 있습니다.\n- 형식적인 함수 정의가 필요하지 않습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n단점:\n\n- 단일 표현식에 한정되어 복잡한 논리에 적합하지 않음.\n- 과다 사용 시 코드 가독성을 떨어뜨릴 수 있음.\n\n예시:\n\n```js\n# 람다 함수를 사용하여 두 숫자 더하기\nadd_numbers = lambda x, y: x + y\nresult = add_numbers(3, 5)\n```  \n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 7. enumerate 및 zip을 활용한 파이썬적인 Iteration\n\n팁: enumerate()와 zip() 함수를 활용하여 시퀀스를 더 파이썬스럽게 반복하세요.\n\n장점:\n\n- enumerate(): 인덱스와 값 모두를 사용하여 반복을 간단하게 만듭니다.\n- zip(): 여러 리스트에 대해 병렬 반복을 용이하게 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nCons:\n\n- 중요한 단점은 없음; 코드 가독성과 간결함을 향상시킴.\n\n예시:\n\n```python\n# enumerate와 zip을 사용한 Pythonic한 반복\nnames = [\"Alice\", \"Bob\", \"Charlie\"]\nages = [25, 30, 22]\n# 인덱스와 값을 함께 사용하는 Enumerate\nfor index, name in enumerate(names):\n    print(f\"사람 {index + 1}: {name}\")\n# 병렬 반복을 위한 Zip\nfor name, age in zip(names, ages):\n    print(f\"{name}은(는) {age}살입니다.\")\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 8. *args 와 **kwargs: 유연한 함수 인수\n\n장점:\n\n- 가변 개수의 인수를 처리하는 데 이상적입니다.\n- 다양한 함수와 래퍼를 생성할 수 있습니다.\n\n단점:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 기능 시그니처가 모든 가능한 인수를 나타내지 않을 수 있으므로 주의 깊은 문서화가 필요합니다.\n\n예시:\n\n```js\n# 주어진 모든 인수를 곱하는 함수\ndef multiply(*args):\n    result = 1\n    for num in args:\n        result *= num\n    return result\n```\n\n# 9. try 및 except를 사용한 안정적인 오류 처리\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n장점:\n\n- 오류 내구성: 예기치 못한 오류로 인해 프로그램이 충돌하는 것을 방지합니다.\n- 향상된 디버깅: 무엇이 잘못되었는지에 대한 통찰을 제공하여 효과적인 디버깅을 돕습니다.\n- 사용자 친화적: 사용자에게 구체적인 오류 메시지를 전달하여 더 나은 경험을 제공합니다.\n\n단점:\n\n- 오버헤드: try와 except를 사용할 경우 일부 경우에 약간의 성능 오버헤드가 발생할 수 있습니다.\n- 잠재적인 실수: 오류를 잘못 잡거나 억제하는 경우 근본적인 문제를 숨길 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예시:\n\n```js\n# 예시: graceful try와 except를 활용한 오류 처리\ndef divide_numbers(a, b):\n    try:\n        result = a / b\n        print(f\"{a}를 {b}로 나눈 결과는: {result}\")\n    except ZeroDivisionError:\n        print(\"0으로 나눌 수 없습니다! 0이 아닌 값으로 나누어 주세요.\")\n    except Exception as e:\n        print(f\"예상치 못한 오류가 발생했습니다: {e}\")\n    else:\n        print(\"나눗셈 성공!\")\n# 함수 테스트\ndivide_numbers(10, 2)  # 일반적인 나눗셈\ndivide_numbers(5, 0)   # 0으로 나누기\ndivide_numbers(\"a\", 2) # 예상치 못한 오류 (TypeError)\n```\n\n# 10. 리스트 슬라이싱: 강력하면서 표현력이 있는 사용법\n\n장점:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 하위 목록 추출, 뒤집기, 요소 건너뛰기 등의 작업을 쉽게 수행할 수 있습니다.\n- 코드 가독성을 향상시키고 명시적인 반복문이 필요 없도록 합니다.\n\n단점:\n\n- 복잡한 슬라이싱을 과도하게 사용하면 코드 가독성에 영향을 줄 수 있습니다.\n\n예시:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 인덱스 2부터 5까지의 서브리스트 추출\noriginal_list = [1, 2, 3, 4, 5, 6, 7]\nsublist = original_list[2:6]\n```\n\n# 11. 제너레이터: 메모리 효율적인 반복\n\n장점:\n\n- 대규모 데이터 세트를 효율적으로 처리합니다.\n- 아이템을 실시간으로 생성하여 메모리를 절약합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n단점:\n\n- 생성기는 일회용 반복자입니다. 한 번 소비되면 재사용할 수 없습니다.\n\n예:\n\n```js\n# 피보나치 수열 생성기\ndef fibonacci(n):\n    a, b = 0, 1\n    for _ in range(n):\n        yield a\n        a, b = b, a + b\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 12. 단언문: 자신감을 가지고 디버깅하기\n\n장점:\n\n- 잠재적 문제를 미리 잡아내어 코드 신뢰성을 향상시킵니다.\n- 코드에 대한 가정을 확인하는 방법을 제공합니다.\n\n단점:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 제품 코드에서 오버 사용하면 성능에 영향을 줄 수 있습니다.\n\n예시:\n\n```js\n# 변수가 양수인지 확인하는 어설션\nnum = -5\nassert num \u003e 0, \"숫자는 양수여야 합니다.\"\n```\n\n# 13. 깊은 복사 vs 얕은 복사: 현명하게 복제하기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n장점:\n\n- 얕은 복사: 동일한 객체에 대한 참조를 가진 새로운 컬렉션을 생성합니다.\n- 깊은 복사: 원본 객체 및 모든 내용의 독립적인 복제본을 생성합니다.\n\n단점:\n\n- deepcopy가 필요한데 얕은 복사를 사용하면 원본 데이터의 의도치 않은 수정이 발생할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예시:\n\n```js\n# 중첩된 목록을 얕은 복사와 깊은 복사로 복제하는 방법\nimport copy\noriginal = [[1, 2, 3], [4, 5, 6]]\nshallow = copy.copy(original)\ndeep = copy.deepcopy(original)\n```\n\n# 14. 랜덤 모듈: 예측할 수 없는 것을 환영하세요\n\n장점:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 시뮬레이션, 게임 또는 예측할 수 없는 상황에 유용합니다.\n- 다양한 무작위화 기능을 제공합니다.\n\n단점:\n\n- 결과는 실제로 무작위적이지 않고 의사난수입니다.\n\n예시:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport random\n# 1과 10 사이의 난수 생성\nrandom_number = random.randint(1, 10)\n```\n\n### 15. Defaultdict: 사전 조작 간소화하기\n\n장점:\n\n- 존재하지 않는 키에 대한 기본값을 제공하여 코드를 간소화합니다.\n- 명시적인 키 존재 여부 검사를 없애줍니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nCons:\n\n- collections 모듈을 가져와야 함.\n\n예시:\n\n```python\nfrom collections import defaultdict\nword = \"pythonic\"\nletter_count = defaultdict(int)\nfor letter in word:\n    letter_count[letter] += 1\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 16. 해저 쇠사자 연산자(:=): 효율적인 인라인 할당\n\n장점:\n\n- 효율적으로 값을 할당하고 동일한 표현식 내에서 사용합니다.\n- 특정 조건에서 중복을 줄여줍니다.\n\n단점:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 이를 과도하게 사용하면 연산자에 익숙하지 않은 사람들에게 코드를 읽는 데 어렵게 만들 수 있습니다.\n\n예시:\n\n```js\n# 파일에서 빈 줄을 찾을 때까지 줄을 읽는 방법\nwith open('file.txt', 'r') as f:\n    while (line := f.readline().strip()):\n        print(line)\n```\n\n# 17. 타입 힌팅: 코드 가독성 향상하기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n장점:\n\n- 코드 가독성과 유지 관리성을 향상시킵니다.\n- 더 나은 IDE 지원 및 정적 유형 검사를 가능하게 합니다.\n\n단점:\n\n- Python은 여전히 동적으로 유형이 할당되는 언어이며, 유형 힌트는 옵션이며 강제되지 않습니다 — 인간 눈을 위한 것이죠 ;) .\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예시:\n\n```js\n# 타입 힌트가 있는 함수\ndef greet(name: str) -\u003e str:\n    return f\"Hello, {name}!\"\n```\n\n# 18. Namedtuples: 스스로 설명하는 데이터 구조\n\n장점:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 가볍고 변경할 수 없는 데이터 구조를 제공합니다.\n- 각 필드에 이름을 지정하여 코드 가독성을 향상시킵니다.\n\n단점:\n\n- 변경할 수 없으며, 생성 후 수정할 수 없습니다.\n- 가변 구조를 위해서는 데이터 클래스를 사용하는 것을 고려해보세요 (Python 3.7+).\n\n예시:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\n# 사람을 위한 namedtuple 만들기 \nfrom collections import namedtuple\nPerson = namedtuple('Person', ['name', 'age'])\nalice = Person(name=\"Alice\", age=30)\n```\n\n# 19. 리스트를 병합하고 해제하는 방법: 순차열 결합 및 해제\n\n장점:\n\n- 동시에 여러 리스트를 반복하는 것을 간단하게 만듭니다.\n- 서로 다른 리스트에서 항목을 함께 처리해야 하는 작업에 편리합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n단점:\n\n- zip()은 입력 리스트 중 가장 짧은 곳에서 멈춥니다. 크기가 다른 iterable을 사용할 경우 itertools.zip_longest()을 고려해보세요.\n\n예시:\n\n```js\n# 퀴즈에서 사용자 입력과 해당 답변을 매칭하는 예시\nnames = [\"Alice\", \"Bob\"]\nscores = [85, 92]\nfor name, score in zip(names, scores):\n    print(f\"{name}: {score}\")\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 20. Dictionaries — get()과 setdefault(): 우아한 키 처리\n\n장점:\n\n- get(): 키의 값을 검색하여, 해당 키가 존재하지 않을 경우 기본값을 제공합니다.\n- setdefault(): 키가 존재하지 않을 경우 기본값을 설정하여, 중복된 키 확인을 방지합니다.\n\n단점:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 이러한 방법을 간과하면 중복 코드를 확인하는 데 유용합니다.\n\n예시:\n\n```js\ndata = {\"name\": \"Alice\"}\nage = data.get(\"age\", 30)\ndata.setdefault(\"country\", \"USA\")\n```\n\n# 21. __main__ 가드: 스크립트 실행을 제어하기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n장점:\n\n- 특정 코드가 스크립트가 직접 실행될 때만 실행되고 가져올 때는 실행되지 않도록 보장합니다.\n- 기능으로 가져와서 함수를 사용하거나 작업을 위해 직접 실행할 수 있는 유틸리티 스크립트에 유용합니다.\n\n단점:\n\n- 이 가드를 사용하는 것을 잊으면 모듈이 가져올 때 예기치 않은 동작을 초래할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예시:\n\n```js\nif __name__ == \"__main__\":\n    print(\"이 스크립트는 직접 실행 중입니다!\")\n```\n\n# 22. 가상 환경: 프로젝트별 개발을 위한 종속성 격리\n\n장점:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 각 프로젝트를 위한 깨끗하고 격리된 환경을 보장합니다.\n- 의존성 관리를 용이하게 하고 충돌을 피할 수 있습니다.\n\nCons:\n\n- 가상 환경을 활성화하는 것을 잊으면 전역 Python 환경에 의도하지 않은 패키지 설치로 이어질 수 있습니다.\n\nExample:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```bash\n# 가상 환경 생성 및 활성화\npython -m venv my_project_env\nsource my_project_env/bin/activate\n```\n\n# 23. 별표 (*) 연산자: 다재다능하고 강력함\n\n장점:\n\n- 컬렉션을 각각의 요소로 효율적으로 언패킹한다.\n- 함수 내에서 동적인 인수 처리를 용이하게 한다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n단점:\n\n- 여러번의 언패킹을 연속적으로 사용하는 경우에는 코드 가독성이 감소할 수 있습니다.\n\n예시:\n\n```js\n# 함수에 별도의 인수를 기대하는 동적 목록 값 전달\ndef func(a, b, c):\n    return a + b + c\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nvalues = [1, 2, 3]\nprint(func(*values))\n```\n\n# 24. 컨텍스트 매니저(with 문): 리소스 관리의 간편함\n\n장점:\n\n- 리소스의 적절한 설정 및 해제를 보장합니다.\n- 코드 가독성을 향상시키고 리소스 누수 가능성을 줄입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n단점:\n\n- 유익할 때 with 문을 사용하지 않는 것은 리소스 관련 문제로 이어질 수 있습니다.\n\n예시:\n\n```js\n# 컨텍스트 매니저를 사용하여 파일 열고 읽기\nwith open('file.txt', 'r') as f:\n    content = f.read()\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 25. 파이썬의 언더스코어(_) 사용법: 명명과 루프에서의 다재다능함\n\n장점:\n\n- 명명 규칙에서 \"보호된\" 변수를 나타냄.\n- REPL 환경에서 마지막 결과를 재사용함.\n- 루프에서 루프 변수가 필요하지 않을 때 일회용 변수로 작용함.\n\n단점:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 다양한 용도로 사용되면 특히 새로운 코더들에게 혼란스러울 수 있어요.\n\n예시:\n\n```js\n# 루프 카운터가 필요 없는 특정 횟수만큼 반복하기\nfor _ in range(5):\n    print(\"Hello, World!\")\n```\n\n# 26. 맵, 필터 및 리듀스: 파이썬에서의 함수형 프로그래밍\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n장점:\n\n- map(): 컬렉션의 각 항목에 함수를 적용합니다.\n- filter(): 조건에 따라 항목을 선택합니다.\n- reduce(): 함수를 누적적으로 적용하여 시퀀스를 단일 값으로 축소합니다.\n\n단점:\n\n- Python 3.x에서 map()과 filter()는 반복자를 반환하므로 필요하다면 리스트로 변환하세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예시:\n\n```js\n# map()을 사용하여 문자열을 대문자로 변환하기\nnames = [\"alice\", \"bob\", \"charlie\"]\nupper_names = list(map(str.upper, names))\n```\n\n# 27. 딕셔너리 병합: 딕셔너리 작업을 간단하게 만들기\n\n장점:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 여러 사전의 내용을 결합하는 것을 간편하게 해줍니다.\n- 병합 방법을 선택하는 데 유연성을 제공합니다.\n\n단점:\n\n- 이 접근을 과도하게 사용하면 중첩된 사전을 처리할 때 예상치 못한 결과로 이어질 수 있습니다.\n\n예시:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n# 딕셔너리를 update() 메서드를 사용하여 병합하기\ndict1 = {'a': 1, 'b': 2}\ndict2 = {'b': 3, 'c': 4}\ndict1.update(dict2)\r\n\n\n# 축하해요! 마침내 완료했어요!\n\n이 파이썬 코딩 팁을 마무리하며, 여러분은 여러분의 코딩 도구 상자에 유용한 속임수들을 배운 것을 기대합니다. 코딩 전문가이든 초보자이든, 새로운 팁으로 색다르게 유지하는 것은 언제나 좋은 선택입니다. 이것들을 적용해보고, 여러분에게 도움이 되는 것을 확인하고, 여러분의 파이썬 코딩 실력을 조금씩 향상시키는 여정을 즐기세요. 즐거운 코딩 되세요!","ogImage":{"url":"/assets/img/2024-07-09-PythonCodingTipsLessonsIWishIKnewWhenIStartedCoding_0.png"},"coverImage":"/assets/img/2024-07-09-PythonCodingTipsLessonsIWishIKnewWhenIStartedCoding_0.png","tag":["Tech"],"readingTime":25},{"title":"3일차, 4일차  진도가 부족한 이유","description":"","date":"2024-07-09 15:04","slug":"2024-07-09-Day3Day4NotEnoughProgress","content":"\n\n## 30일 코딩 챌린지\n\n![이미지](/assets/img/2024-07-09-Day3Day4NotEnoughProgress_0.png)\n\n저의 지역에서 전원 문제가 지속되고 있습니다. 어제인 'Day 3'에 한 일은 이전 날(데이 2의 업데이트를 읽으려면 아래로 스크롤하세요👇)의 온도 변환기를 다듬은 것 뿐입니다.\n\n제게 궁금증을 자아냅니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n어쨌든, 그걸 생각하느라 시간을 낭비하지 말아요. 여기 오늘(4일차)의 내 보고서가 있어요:\n\n이전 날들과는 달리, 오늘은 조직된 계획이 없었어요.\n\nTkinter를 통해 내 온도 변환기의 두 번째 버전을 위한 창을 만들어보려고 했어요.\n\n하지만, 아마도 내 코드에 집중하지 못하고 거의 전혀 진전이 없었어요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이유는요? 다른 급한 일이 더 많아서 그래요.\n\n그래서, 음, 오늘은 지금까지 최악의 날이었어요.\n\n그리고 그 이유는 프로젝트를 진행하기 위한 수단과 의지가 있었는데도 집중할 수 없었기 때문이에요. 충분한 양을 처리하지 못하는 것 같아요.\n\n어쨌든, IDE를 열고 어제보다 더 많은 시간을 프로젝트에 쏟은 사실을 고려하면 오늘을 \"완료\"로 표시할 수 있어요.","ogImage":{"url":"/assets/img/2024-07-09-Day3Day4NotEnoughProgress_0.png"},"coverImage":"/assets/img/2024-07-09-Day3Day4NotEnoughProgress_0.png","tag":["Tech"],"readingTime":2},{"title":"빠른 푸리에 변환을 이용한 주식 시장 신호 분석 방법","description":"","date":"2024-07-09 15:03","slug":"2024-07-09-StockMarketSignalAnalysisUsingFastFourierTransform","content":"\n\n# 소개\n\n금융 시장은 본질적으로 소음이 많고 예측할 수 없어서, 수익성 있는 기회를 식별하고 활용하려는 트레이더와 투자자에게 상당한 어려움을 줍니다.\n\n이 복잡성을 해결하기 위해 현대 트레이더들은 수학적 및 통계적 기술을 활용하여 소음을 걸러내고 데이터의 기저 주기/트렌드를 더 명확히 이해하기 위한 다양한 기법을 사용합니다. FFT(Fast Fourier Transform) 알고리즘은 이러한 강력한 도구 중 하나로, 어떤 신호/파형을 주파수가 변하는 사인 성분들의 합으로 표현하는 데 사용되는 알고리즘입니다. 따라서 시간 영역에서 주파수 영역으로 신호를 변환합니다.\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*e-_z80BnbHWyFTfRLblJ_w.gif)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 기사에서 논의하는 FFT 알고리즘은 신호 처리를 사용하여 가장 중요한 주파수를 감지하고 데이터에서 잡음을 제거합니다.\n\n# FFT를 사용하는 이유?\n\n## 주기와 패턴 감지\n\n주식 가격이나 거래량과 같은 금융 시계열은 다양한 경제 주기, 계절성 또는 투자자 행동으로 인해 주기적인 패턴을 나타내는 경우가 많습니다. 푸리에 변환은 이러한 주기와 해당 주파수를 식별하는 데 도움이 됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 소음 필터링\n\n금융 데이터는 종종 무작위 변동으로 인해 소음이 발생합니다. 데이터를 주파수 영역으로 변환하여 분석가들은 고주파 소음을 제거하여 중요한 저주파수 트렌드에 집중할 수 있습니다.\n\n## 예측 모델링\n\n주파수를 식별함으로써, 분석가들은 역사적인 패턴을 기반으로 미래 가격 변동이나 트렌드에 대한 예측을 할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 기계 학습을 위한 기능 추출\n\nFourier 변환에서 얻은 주파수 구성 요소는 머신 러닝 모델에서 특징으로 사용되어 예측의 정확도를 향상시킬 수 있습니다.\n\n# 코드 및 단계별 분석\n\n## 노트북 설정 및 주식 데이터 수집\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n필요한 기본 주식 데이터 수집 및 데이터 프레임 조작을 위한 라이브러리 가져오기가 첫 번째 단계입니다.\n\n또한, 분석 기간을 1년으로 설정하고 분석할 주식은 Tata Consultancy Services (TCS)입니다. 필요한 주식의 OLHCAV 데이터는 'df'라는 데이터 프레임에 저장되어 있습니다.\n\n```js\n#라이브러리 가져오기\nimport pandas as pd\nfrom pandas_datareader import data as pdr\nimport numpy as np\nimport math\nimport datetime\nimport scipy.stats as stats\nimport matplotlib.pyplot as plt\nimport yfinance as yfin\nyfin.pdr_override()\n\n# 분석 기간 설정\nend_date = datetime.datetime.now()\nstart_date = end_date - datetime.timedelta(365)\nticker = 'TCS'\n\ndf = pdr.get_data_yahoo(ticker + '.NS', start = start_date, end = end_date)\n```\n\n## FFT의 적용\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nnp.fft.fft()을 사용하여 푸리에 변환을 수행할 것이며, np.fft.fftfreq()를 사용하여 주파수를 얻을 것입니다. 가장 중요한 주파수가 나타나는 때를 나타내기 위해 진폭 대 주기를 그래프로 그려볼 수 있습니다.\n\n```js\nfft_result = np.fft.fft(df['Close'])\nfrequencies = np.fft.fftfreq(len(fft_result), d=1)  # assuming daily data, d=1\nmagnitude = np.abs(fft_result)\nperiods = 1 / frequencies\n```\n\n## 가격 및 주파수 영역 표현 시각화\n\n아래의 주파수 플롯은 시계열 내에서 우세한 주파수를 강조합니다. 이러한 주파수는 역 FFT를 수행하거나 원래 시계열을 다시 만들거나 잡음을 줄인 버전을 생성하는 데 사용될 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 가격의 간단한 시각화\nplt.figure(figsize=(10, 8))\nplt.subplot(2, 1, 1)\nplt.plot(df.index, df['Close'])\nplt.title('TCS 시계열')\nplt.xlabel('날짜')\nplt.ylabel('가격')\n\n# 주파수 도메인 표현\nplt.subplot(2, 1, 2)\nplt.plot(periods, magnitude)\nplt.title('TCS의 FFT')\nplt.xlabel('기간 (일)')\nplt.ylabel('크기')\nplt.xlim(0, max(periods[1:]))  # 중요한 주기를 보기 위한 x-축 제한 (큰 주기 무시)\nplt.ylim(0, max(magnitude[1:]) * 1.1)  # 제로 주파수 구성요소 무시\n\nplt.tight_layout()\nplt.show()\n```\n\n\u003cimg src=\"/assets/img/2024-07-09-StockMarketSignalAnalysisUsingFastFourierTransform_0.png\" /\u003e\n\n하지만, 이러한 우세 주파수의 중요성은 단순히 시계열을 재구성하는 데서 그치지 않습니다. 이들은 시계열 구조에 영향을 미치는 주요 경제 보고서나 거시경제 사건과 관련될 수 있습니다.\n\n## 원래 주식 시장 데이터 복구하기\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nnp.fft.ifft() 함수를 사용하여 원래의 시계열을 복원할 수 있습니다. 이 함수는 fft_results를 역변환합니다. 아래 그래프에서 볼 수 있듯이 완벽하게 재구성되었습니다.\n\n```js\nrecovered = np.fft.ifft(fft_result)\nplt.figure(figsize=(14, 6))\nplt.plot(df.index, df['Close'], label='Original')\nplt.plot(df.index, recovered, label='Recovered')\nplt.title('TCS 시계열: FFT 역변환')\nplt.xlabel('날짜')\nplt.ylabel('가격')\nplt.legend()\nplt.show()\n```\n\n\u003cimg src=\"/assets/img/2024-07-09-StockMarketSignalAnalysisUsingFastFourierTransform_1.png\" /\u003e\n\n## 주요 주파수를 갖는 파형의 재구성\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이것은 상위 25개 FFT 주파수만 사용하여 재구성된 신호를 생성합니다. 이것은 데이터의 노이즈 제거를 의미합니다.\n\n```js\ndominant_periods = pd.Series(periods, index = magnitude).nlargest(25)\ndominant_periods.to_frame('주기 (일)')\ntop_periods = dominant_periods.index\ntop_fft_result = fft_result.copy()\ntop_fft_result[np.abs(frequencies) \u003e 1 / top_periods.min()] = 0\ntop_recovered = np.fft.ifft(top_fft_result)\n\n\nplt.figure(figsize = (14, 6))\nplt.plot(df.index, df['Close'], label = '원본')\nplt.plot(df.index, top_recovered, label = '복원된')\nplt.title('TCS 시계열: FFT 역변환')\nplt.xlabel('날짜')\nplt.ylabel('가격')\nplt.legend()\nplt.show()\n```\n\n\u003cimg src=\"/assets/img/2024-07-09-StockMarketSignalAnalysisUsingFastFourierTransform_2.png\" /\u003e\n\n# 결론\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 문서에서 설명한 알고리즘은 산업 전문가들이 사용하는 분석을 지나치게 단순화한 것입니다. 성능을 개선하기 위해 일반적으로 매일 모델을 조정합니다.\n\n도움이 되었기를 바라며, 여기에 GitHub 파일을 찾을 수 있습니다: [https://github.com/karantha-kur/Signal-Analysis-Using-FFT/tree/main](https://github.com/karantha-kur/Signal-Analysis-Using-FFT/tree/main)","ogImage":{"url":"/assets/img/2024-07-09-StockMarketSignalAnalysisUsingFastFourierTransform_0.png"},"coverImage":"/assets/img/2024-07-09-StockMarketSignalAnalysisUsingFastFourierTransform_0.png","tag":["Tech"],"readingTime":7},{"title":"NanoLlava 가장 작은 시각적 언어란","description":"","date":"2024-07-09 15:02","slug":"2024-07-09-NanoLlavaisthesmallestVisualLanguage","content":"\n\n![이미지](/assets/img/2024-07-09-NanoLlavaisthesmallestVisualLanguage_0.png)\n\n요즘 뉴스에는 시각 언어 모델이 많이 등장하고 있어요. 지난 몇 일간의 발표 속에 믿기 어려운 소식이 많았는데, 이미지를 통해 대화를 하려면 돈을 내야 할까요?\n\nGPT-4o, Gemini-flash, PaliGemma, Copilot+PC… 이 모든 것이 1주일 안에 나왔어요!\n\n아무도 알지 못했지만 Abetlen이 GGUF 버전의 가장 작은 언어 모델인 TINIEST을 출시했다는 사실이죠.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n전체 모델은 NanoLlava를 만나실 수 있는 컴퓨터의 2GB 하드 디스크 공간에 저장됩니다.\n\n이 기사에서는 모델을 양자화하여 어떤 컴퓨터에서도 실행하는 방법을 배우게 될 것입니다. 전용 GPU 없이도 작업을 완료할 수 있습니다.\n\n```js\n# 목차\n---\n작고 강력한 모델\n모델을 시각적으로 만드는 것은 무엇인가요?\nPC에서 NanoLlava\n - 환경 설정\nInference call - textual\nStreamlit Application\n``` \n\n# 작고 강력한\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n나노라바는 Sub 1B 비전-언어 모델입니다. 네, 정확히 들으셨어요! GPT-4o 수행능력을 기대하지 마세요 (그렇게 할 수는 있지만, ...혹은 소유중인 경우에만 가능합니다.)","ogImage":{"url":"/assets/img/2024-07-09-NanoLlavaisthesmallestVisualLanguage_0.png"},"coverImage":"/assets/img/2024-07-09-NanoLlavaisthesmallestVisualLanguage_0.png","tag":["Tech"],"readingTime":2},{"title":"뉴럴 네트워크 손실 함수 이해 및 구현 방법 기초부터","description":"","date":"2024-07-09 15:01","slug":"2024-07-09-UnderstandingImplementingDifferentLossFunctionsofNeuralNetworksfromScratch","content":"\n\n\u003cimg src=\"/assets/img/2024-07-09-UnderstandingImplementingDifferentLossFunctionsofNeuralNetworksfromScratch_0.png\" /\u003e\n\n신경망의 매혹적인 세계에서 손실 함수는 훈련 과정을 정확한 예측으로 이끄는 안내 나침반 같은 역할을 합니다. 이러한 함수들을 숙달하는 것은 딥러닝에 진지하게 임하는 사람들에게 중요합니다. 왜냐하면 손실 함수를 선택하는 것은 모델의 성능에 상당한 영향을 미칠 수 있기 때문입니다. 신진 데이터 과학자든 경험 많은 기계 학습 엔지니어든, 이 블로그는 다양한 손실 함수를 해독하고 그 목적을 설명하며, 처음부터 구현하는 방법을 보여줍니다.\n\n자, 이러한 수학적 도구가 어떻게 신경망 훈련을 변화시킬 수 있는지 알아봅시다!\n\n그래서, 우리 마음에 떠오르는 첫 번째 질문은 '손실 함수란 무엇인가요?'입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](/assets/img/2024-07-09-UnderstandingImplementingDifferentLossFunctionsofNeuralNetworksfromScratch_1.png)\n\n핵심적으로, 손실 함수(J로 표시됨)는 두 개의 매개변수를 입력으로 받는 수학 함수입니다:\n\n- 예측된 출력\n- 실제 출력\n\n이 함수는 모델의 예측 값과 모델이 생성해야 하는 실제 값과 비교하여 모델이 얼마나 잘 작동하는지를 평가하기 위해 사용됩니다. 예측 값이 실제 값과 크게 다를 경우 손실 값은 크게 나타납니다. 반면, 낮은 손실 값은 두 값이 거의 유사할 때 발생합니다. 따라서 효율적인 손실 함수를 사용하여 모델을 올바르게 훈련시키는 것이 중요합니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n높은 손실 값은 모델의 예측이 부정확하다는 것을 시사하며, 네트워크를 크게 재조정해야 한다는 것을 의미합니다. 반면에 낮은 손실 값은 모델이 효과적으로 작동하고 있으며, 가중치를 매우 약간만 조정해야 한다는 것을 나타냅니다.\n\n이러한 시나리오는 새로운 요리법을 만드는 것과 유사합니다. 요리물이 실패하면 \"손실\"이 높아지고, 요리사는 다음에 요리물을 개선하기 위해 재료나 조리 방법에 상당한 변화를 해야 합니다. 그러나 요리물이 잘 나오면 이미 효과적인 레시피와 기술이기 때문에 필요한 경우에는 작은 조정만 필요합니다. 이 조정은 향후 블로그에서 논의할 하이퍼파라미터를 조정함으로써 수행할 수 있습니다. 이제 손실 함수가 무엇인지 이해했으므로, 다음으로 궁금한 것은 어떤 종류의 손실 함수가 있고 이를 어떻게 구현하는지에 대한 것입니다.\n\n신경망에서의 손실 함수 유형\n\n회귀 손실 함수\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 평균 제곱 오차 (MSE)\n\nMSE는 회귀 문제에 사용되는 가장 인기 있는 손실 함수 중 하나입니다. 이는 예측 값과 실제 값 사이의 오차의 제곱의 평균을 측정합니다. MSE는 이상치에 민감합니다.\n\n사용 사례: MSE는 주택 가격이나 온도와 같은 연속적인 값을 예측하는 회귀 문제에서 흔히 사용됩니다.\n\n수학적 공식:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 Markdown 형식으로 표시된 내용입니다.\n\n\n![이미지](/assets/img/2024-07-09-UnderstandingImplementingDifferentLossFunctionsofNeuralNetworksfromScratch_2.png)\n\nwhere,\n\n![이미지](/assets/img/2024-07-09-UnderstandingImplementingDifferentLossFunctionsofNeuralNetworksfromScratch_3.png)\n\n\n코드 구현:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\ndef mean_squared_error(y_true, y_predicted):\n    total_error = 0\n    for yt, yp in zip(y_true, y_predicted):\n        total_error += (yt-yp)**2\n    mse = total_error/len(y_true)\n    return mse\n```\n\n2. Mean Absolute Error (MAE)\n\nMAE는 예측 값과 실제 값 사이의 절대 오차의 평균을 측정합니다. MSE보다 이상치에 민감하지 않습니다.\n\n사용 사례: MAE는 중앙값 주택 가격을 예측하는 경우와 같이, 이상치에 민감하지 않은 손실 함수를 원할 때 사용됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n수학 공식:\n\n![수식](/assets/img/2024-07-09-UnderstandingImplementingDifferentLossFunctionsofNeuralNetworksfromScratch_4.png)\n\n코드 구현:\n\n```python\ndef mean_abs_error(y_predicted, y_true):\n    total_error = 0\n    for yp, yt in zip(y_predicted, y_true):\n        total_error += abs(yp - yt)\n    mae = total_error/len(y_predicted)\n    return mae\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n3. 휴버 손실\n\n휴버 손실은 MSE와 MAE의 우수한 특성을 결합하여, MSE보다 이상치에 민감하지 않고 MAE보다 원점 주변에서 부드럽습니다.\n\n사용 사례: 휴버 손실은 이상치의 영향을 줄이고 손실 함수를 미분 가능하게 유지하고자 하는 견고한 회귀 문제에서 자주 사용됩니다.\n\n수학적 공식:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![Image](/assets/img/2024-07-09-UnderstandingImplementingDifferentLossFunctionsofNeuralNetworksfromScratch_5.png)\n\n코드 구현:\n\n```python\ndef huber_loss(y_true, y_pred, delta=1.0):\n    n = len(y_true)\n    loss = 0\n    for i in range(n):\n        diff = y_true[i] - y_pred[i]\n        if abs(diff) \u003c= delta:\n            loss += 0.5 * diff ** 2\n        else:\n            loss += delta * (abs(diff) - 0.5 * delta)\n    return loss / n\n```\n\n분류 손실 함수\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n1. Binary Cross-Entropy 손실\n\nBinary Cross-Entropy 손실은 이진 분류 작업에 사용됩니다. 출력이 0과 1 사이의 확률 값인 분류 모델의 성능을 측정합니다.\n\n사용 사례: 스팸 감지나 사기 탐지와 같은 이진 분류 문제에 이 손실 함수가 이상적입니다.\n\n수학적 공식:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이미지 태그를 Markdown 형식으로 변경하세요.\n\n\n![UnderstandingImplementingDifferentLossFunctionsofNeuralNetworksfromScratch](/assets/img/2024-07-09-UnderstandingImplementingDifferentLossFunctionsofNeuralNetworksfromScratch_6.png)\n\n\n코드 구현:\n\n```python\nimport math\n\ndef binary_crossentropy(y_true, y_pred):\n    n = len(y_true)\n    loss = 0\n    for i in range(n):\n        loss += y_true[i] * math.log(y_pred[i]) + (1 - y_true[i]) * math.log(1 - y_pred[i])\n    return -loss / n\n```\n\n2. 범주형 Cross-Entropy Loss\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n범주형 크로스 엔트로피 손실은 다중 클래스 분류 작업에 사용됩니다. 이는 여러 클래스에 대한 확률 분포인 분류 모델의 성능을 측정합니다.\n\n활용 사례: 이 손실 함수는 숫자 인식(MNIST)이나 물체 검출과 같은 다중 클래스 분류 문제에 적합합니다.\n\n수학적 공식:\n\n![수식](/assets/img/2024-07-09-UnderstandingImplementingDifferentLossFunctionsofNeuralNetworksfromScratch_7.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n구현된 코드:\n\n```js\nimport math\n\ndef categorical_crossentropy(y_true, y_pred):\n    n = len(y_true)\n    c = len(y_true[0])\n    loss = 0\n    for i in range(n):\n        for j in range(c):\n            if y_true[i][j] == 1:\n                loss += y_true[i][j] * math.log(y_pred[i][j])\n    return -loss / n\n```\n\n3. Sparse Categorical Cross-Entropy Loss\n\nSparse Categorical Cross-Entropy는 목표 레이블이 원-핫 인코딩된 벡터가 아닌 정수일 때 사용됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n사용 사례: 이 손실 함수는 타겟 레이블이 one-hot 벡터가 아닌 정수 레이블 형태인 다중 클래스 분류 문제에서 사용됩니다.\n\n수학적 공식:\n\n![이미지](/assets/img/2024-07-09-UnderstandingImplementingDifferentLossFunctionsofNeuralNetworksfromScratch_8.png)\n\n코드 구현:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ndef sparse_categorical_cross_entropy(y_true, y_pred):\n    n = len(y_true)\n    loss = 0\n    for i in range(n):\n        loss += y_true[i] * math.log(y_pred[i]))\n    return -loss / n\n```\n\n거기에는 몇 가지 더 특별한 손실 함수가 있어요:\n\n- Kullback-Leibler Divergence\n- Cosine Similarity Loss\n- Dice Loss\n- Quantile Loss\n- Hinge Loss\n\n이제 손실 함수에 대해 간결하고 명확하게 이해하셨기를 바랍니다. 다가오는 블로그에서는 특별한 손실 함수, 사용 사례 및 구현에 대해 논의할 예정이에요. 컴퓨터 비전과 딥 러닝에 관한 더 많은 기사를 위해 블로그를 팔로우해 주세요. 궁금한 사항이 있거나 특정 부분에 대한 추가 정보가 필요하면 언제든지 의견을 남겨주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마크다운 형식으로 표 태그를 변경하세요: Linkedin","ogImage":{"url":"/assets/img/2024-07-09-UnderstandingImplementingDifferentLossFunctionsofNeuralNetworksfromScratch_0.png"},"coverImage":"/assets/img/2024-07-09-UnderstandingImplementingDifferentLossFunctionsofNeuralNetworksfromScratch_0.png","tag":["Tech"],"readingTime":10},{"title":"Mojo, Python보다 90,000배 빠르다 드디어 오픈소스 공개 출시 즉시 17,000 스타 돌파","description":"","date":"2024-07-09 15:00","slug":"2024-07-09-Mojo90000TimesFasterThanPythonFinallyOpenSourcedJustLaunchedAlreadySurpassing17000Stars","content":"\n\n2024년 3월 29일, Modular Inc.은 Mojo의 핵심 구성 요소를 오픈 소스화한다고 발표했습니다.\n\nMojo는 작년 8월에 공식적으로 출시된 인공 지능 소프트웨어를 작성하기 위해 특별히 설계된 프로그래밍 언어입니다. 그 이후로 17만 5천 명 이상의 개발자와 5천 개 이상의 기관이 모아졌습니다.\n\n인공 지능 모델은 종종 여러 프로그래밍 언어로 작성됩니다. 개발자는 일반적으로 가장 간단한 신경망의 일부를 구현하기 위해 Python을 사용합니다. Python은 배우기 쉽지만 비교적 느린 속도 때문에 사용됩니다. 남은 코드는 보통 C++로 작성되며, C++은 더 빠르지만 학습하기에 복잡합니다.\n\nModular은 Mojo를 더 편리한 대안으로 위치시킵니다. Python과 유사한 쉬운 구문을 제공하지만 수천 배 더 빠른 실행 속도를 갖도록 하며, 이를 통해 개발자들은 C++과 같은 복잡한 언어를 배우지 않고도 빠른 AI 모델을 작성할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-07-09-Mojo90000TimesFasterThanPythonFinallyOpenSourcedJustLaunchedAlreadySurpassing17000Stars_0.png\" /\u003e\n\n지난해 Mojo가 소개됐을 때, 일부 개발자들은 그 등장에 들뜬 기대를 표현했습니다. 그러나 Chris Lattner은 디스코드에서 오픈 소스 날짜에 대해 물어볼 때 \"알았다면 말했을 거야.\" 라고 말했습니다. 약 1년 동안 많은 개발자들이 관찰하며 의심의 태도를 보였습니다:","ogImage":{"url":"/assets/img/2024-07-09-Mojo90000TimesFasterThanPythonFinallyOpenSourcedJustLaunchedAlreadySurpassing17000Stars_0.png"},"coverImage":"/assets/img/2024-07-09-Mojo90000TimesFasterThanPythonFinallyOpenSourcedJustLaunchedAlreadySurpassing17000Stars_0.png","tag":["Tech"],"readingTime":2},{"title":"PyFilesystem2 OpenCV로 캡처한 프레임을 메모리 파일 시스템에 저장하는 방법","description":"","date":"2024-07-09 14:59","slug":"2024-07-09-PyFilesystem2StoringFramesCapturedbyOpenCVinanIn-MemoryFilesystem","content":"\n\n\u003cimg src=\"/assets/img/2024-07-09-PyFilesystem2StoringFramesCapturedbyOpenCVinanIn-MemoryFilesystem_0.png\" /\u003e\n\n소개\nPyFilesystem2은 Python에서 파일 시스템을 다루는 강력하고 유연한 라이브러리로, 개발자들이 파일과 디렉토리를 쉽게 관리할 수 있습니다. PyFilesystem2의 매력적인 기능 중 하나는 인메모리 파일 시스템을 지원한다는 점인데, 이는 테스트, 데이터 캐싱, 빠른 처리 등 다양한 목적에 유용할 수 있습니다. 본 문서에서는 OpenCV로 캡처된 비디오 프레임을 인메모리 파일 시스템에 저장하는 방법을 알아보겠습니다.\n\n필수 조건\n시작하려면 PyFilesystem2 및 OpenCV 두 라이브러리를 설치해야 합니다. 다음 명령어로 pip를 사용하여 이 라이브러리들을 설치할 수 있습니다:\n\n인메모리 파일 시스템 생성\n먼저 인메모리 파일 시스템을 생성해야 합니다. 이 작업은 PyFilesystem2 라이브러리의 `MemoryFS` 클래스를 사용하여 수행할 수 있습니다. 아래는 인메모리 파일 시스템을 생성하고 그 안에 간단한 파일을 저장하는 예제입니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nOpenCV을 사용하여 비디오 프레임 캡처하기\n비디오 프레임을 캡처하기 위해 OpenCV 라이브러리를 사용할 것입니다. OpenCV는 이미지 및 비디오 처리에 사용되는 오픈 소스 라이브러리입니다. 카메라 또는 비디오 파일에서 비디오 프레임을 캡처하는 방법은 다음과 같습니다:\n\n인메모리 파일 시스템에 프레임 저장하기\n이제 비디오 프레임을 캡처할 수 있으므로, 이러한 프레임을 인메모리 파일 시스템에 저장해야 합니다. 이를 위해 먼저 프레임을 이미지 형식 (예: PNG)으로 변환한 다음 파일 시스템에 저장합니다.\n\n결론\n본 문서에서는 PyFilesystem2를 사용하여 OpenCV로 캡처한 비디오 프레임을 인메모리 파일 시스템에 저장하는 방법을 살펴보았습니다. 이 접근 방식을 사용하면 실시간 및 임시 처리 작업에 매우 유용한 비디오 프레임을 빠르게 임시로 저장할 수 있습니다. PyFilesystem2는 다양한 유형의 파일 시스템을 쉽게 관리하고 프로젝트에서 활용할 수 있는 강력한 도구입니다.","ogImage":{"url":"/assets/img/2024-07-09-PyFilesystem2StoringFramesCapturedbyOpenCVinanIn-MemoryFilesystem_0.png"},"coverImage":"/assets/img/2024-07-09-PyFilesystem2StoringFramesCapturedbyOpenCVinanIn-MemoryFilesystem_0.png","tag":["Tech"],"readingTime":2},{"title":"주식 거래에서 가장 인기 있는 10가지 금융 지표","description":"","date":"2024-07-09 14:59","slug":"2024-07-09-TheMostPopularFinancialMetricsinStockTrading","content":"\n\n주식 거래에서 사용되는 금융 지표는 많지만, 가장 인기 있는 일부는 다음과 같습니다:\n\n- 주당 순이익 (EPS): 주당 순이익은 기업의 이익 중 주당 주식에 배정된 부분입니다. 기업의 수익성과 성장 잠재력을 평가하는 데 사용되는 주요 지표입니다.\n- 주가 이익 비율 (P/E 비율): 주가 이익 비율은 주식 가격을 주당 이익과 비교하는 가격 평가 비율입니다. 기업의 현재 주가를 이익과 비교하며, 다른 기업의 가치를 비교하는 데 사용됩니다.\n- 배당 수익률: 배당 수익률은 기업의 연간 배당 지급액을 현재 주가로 나눈 값입니다. 주식 투자의 수익 잠재력을 평가하는 데 사용됩니다.\n- 시가 총액: 시가 총액은 기업의 유통 중인 주식의 총 가치입니다. 기업의 규모를 평가하고 다른 기업의 상대적 규모를 비교하는 데 사용됩니다.\n- 자기 자본 수익률 (ROE): 자기 자본 수익률은 기업이 주주 자본 양에 비례하여 얼마나 많은 이익을 창출하는지를 측정하는 수익성 비율입니다. 기업의 수익성과 효율성을 평가하는 데 사용됩니다.\n- 부채 자본 비율: 부채 자본 비율은 기업의 총 부채를 총 자본에 비교하는 금융 비율입니다. 부채 비율을 평가하는 것에 사용됩니다.","ogImage":{"url":"/TIL/assets/no-image.jpg"},"coverImage":"/TIL/assets/no-image.jpg","tag":["Tech"],"readingTime":1}],"page":"6","totalPageCount":19,"totalPageGroupCount":1,"lastPageGroup":19,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"6"},"buildId":"OY-qm1-_Mz9jLZ5863EbF","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>