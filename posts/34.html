<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>TIL</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//posts/34" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="TIL" data-gatsby-head="true"/><meta property="og:title" content="TIL" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//posts/34" data-gatsby-head="true"/><meta name="twitter:title" content="TIL" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/873-eb138c3217d71553.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-de1dc5579188f9be.js" defer=""></script><script src="/_next/static/xx51Gh_JNHDTBdDwrgykD/_buildManifest.js" defer=""></script><script src="/_next/static/xx51Gh_JNHDTBdDwrgykD/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="2025년까지 파이썬이 IT 산업을 지배할 7가지 이유" href="/post/2024-07-06-TheReasonsPythonWillDominatetheITIndustryby2025"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="2025년까지 파이썬이 IT 산업을 지배할 7가지 이유" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-06-TheReasonsPythonWillDominatetheITIndustryby2025_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="2025년까지 파이썬이 IT 산업을 지배할 7가지 이유" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">2025년까지 파이썬이 IT 산업을 지배할 7가지 이유</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 6, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="TS Types와 Interfaces를 사용하는 방법 및 시기" href="/post/2024-07-02-TSWhentouseTypesandwhentouseInterfaces"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="TS Types와 Interfaces를 사용하는 방법 및 시기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-02-TSWhentouseTypesandwhentouseInterfaces_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="TS Types와 Interfaces를 사용하는 방법 및 시기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">TS Types와 Interfaces를 사용하는 방법 및 시기</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 2, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nextjs 사용이 점점 더 어려워지는 이유" href="/post/2024-07-02-ItsnotjustyouNextjsisgettinghardertouse"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nextjs 사용이 점점 더 어려워지는 이유" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-02-ItsnotjustyouNextjsisgettinghardertouse_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nextjs 사용이 점점 더 어려워지는 이유" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Nextjs 사용이 점점 더 어려워지는 이유</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 2, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="TypeScript와 함께 작업할 때 정직이 최선의 정책인 이유  거짓말의 대가" href="/post/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="TypeScript와 함께 작업할 때 정직이 최선의 정책인 이유  거짓말의 대가" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="TypeScript와 함께 작업할 때 정직이 최선의 정책인 이유  거짓말의 대가" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">TypeScript와 함께 작업할 때 정직이 최선의 정책인 이유  거짓말의 대가</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 2, 2024</span><span class="PostList_reading_time__6CBMQ">19<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nextjs에서 Tailwind와 Swiper로 썸네일 슬라이더 만드는 방법" href="/post/2024-07-02-CreatingaThumbnailSliderinNextjswithTailwindandSwiper"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nextjs에서 Tailwind와 Swiper로 썸네일 슬라이더 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-02-CreatingaThumbnailSliderinNextjswithTailwindandSwiper_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nextjs에서 Tailwind와 Swiper로 썸네일 슬라이더 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Nextjs에서 Tailwind와 Swiper로 썸네일 슬라이더 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 2, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="코믹 힙에서 요소 추가 및 제거 과정 이해하기" href="/post/2024-07-02-ComicHowAddingRemovingStuffFromHeapsWork"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="코믹 힙에서 요소 추가 및 제거 과정 이해하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-02-ComicHowAddingRemovingStuffFromHeapsWork_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="코믹 힙에서 요소 추가 및 제거 과정 이해하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">코믹 힙에서 요소 추가 및 제거 과정 이해하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 2, 2024</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Jupyter Lab IDE에서 Typescript, LangChainjs, Ollama를 사용하여 AI 프로토타입 환경 빠르게 구축하는 방법" href="/post/2024-07-02-CreateanAIprototypingenvironmentusingJupyterLabIDEwithTypescriptLangChainjsandOllamaforrapidAIprototyping"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Jupyter Lab IDE에서 Typescript, LangChainjs, Ollama를 사용하여 AI 프로토타입 환경 빠르게 구축하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-02-CreateanAIprototypingenvironmentusingJupyterLabIDEwithTypescriptLangChainjsandOllamaforrapidAIprototyping_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Jupyter Lab IDE에서 Typescript, LangChainjs, Ollama를 사용하여 AI 프로토타입 환경 빠르게 구축하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Jupyter Lab IDE에서 Typescript, LangChainjs, Ollama를 사용하여 AI 프로토타입 환경 빠르게 구축하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 2, 2024</span><span class="PostList_reading_time__6CBMQ">16<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="AI와 함께하는 프로그래밍  Vision LLMs 사용법" href="/post/2024-07-02-ProgrammingwithAIVisionLLMs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="AI와 함께하는 프로그래밍  Vision LLMs 사용법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-02-ProgrammingwithAIVisionLLMs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="AI와 함께하는 프로그래밍  Vision LLMs 사용법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">AI와 함께하는 프로그래밍  Vision LLMs 사용법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 2, 2024</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Python으로 삼체 문제를 시각적으로 시뮬레이션하는 방법" href="/post/2024-07-02-VisuallySimulatingtheThree-BodyProblemonPython"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Python으로 삼체 문제를 시각적으로 시뮬레이션하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-02-VisuallySimulatingtheThree-BodyProblemonPython_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Python으로 삼체 문제를 시각적으로 시뮬레이션하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Python으로 삼체 문제를 시각적으로 시뮬레이션하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 2, 2024</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Pydantic Settings로 Python 설정 완벽하게 하기 위한 방법" href="/post/2024-07-02-GetYourPythonConfigurationsRightEveryTimewithPydanticSettings"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Pydantic Settings로 Python 설정 완벽하게 하기 위한 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-02-GetYourPythonConfigurationsRightEveryTimewithPydanticSettings_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Pydantic Settings로 Python 설정 완벽하게 하기 위한 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Pydantic Settings로 Python 설정 완벽하게 하기 위한 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 2, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/21">21</a><a class="link" href="/posts/22">22</a><a class="link" href="/posts/23">23</a><a class="link" href="/posts/24">24</a><a class="link" href="/posts/25">25</a><a class="link" href="/posts/26">26</a><a class="link" href="/posts/27">27</a><a class="link" href="/posts/28">28</a><a class="link" href="/posts/29">29</a><a class="link" href="/posts/30">30</a><a class="link" href="/posts/31">31</a><a class="link" href="/posts/32">32</a><a class="link" href="/posts/33">33</a><a class="link" href="/posts/34">34</a></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"2025년까지 파이썬이 IT 산업을 지배할 7가지 이유","description":"","date":"2024-07-06 02:21","slug":"2024-07-06-TheReasonsPythonWillDominatetheITIndustryby2025","content":"\n/assets/img/2024-07-06-TheReasonsPythonWillDominatetheITIndustryby2025_0.png\n\n전화로 피자 주문을 하는 과거를 떠올려보세요. 그리고 배달원이 당신의 주소를 제대로 기억했는지 손가락 교차하며 기다리던 시절을 생각해보세요. 오늘날, 자율 주행 자동차가 당신에게 뜨거운 피자를 가져다 줄 수 있고, 당신은 잡지보다 작은 화면에서 최신 시리즈를 시청할 수 있습니다. 이 놀라운 기술 대부분이 파이썬에서 유래했다는 것을 알고 계셨나요?\n\n파이썬은 학계와 컴퓨터 애호가들을 넘어서 확장되어 왔습니다. 최신 동향을 따라가지 않은 사람들에게 놀랄만한 소식일지도 모릅니다. 지능적인 기계와 자율 주행 자동차 개발부터 웹사이트 제작과 데이터 분석까지 파이썬은 모든 다른 언어를 빠르게 대체하고 있습니다. 내 확고한 확신은 파이썬이 2025년에 기술 세계에서 최고로 거론될 것이라는 것입니다.\n\n## 파이썬의 묻힌 영웅: 사용 편의성, 커뮤니티, 다양성\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파이썬의 엄청난 유연성은 그 중요한 특징 중 하나입니다. 프로그래머들을 위한 범용 도구 세트와 같이 매우 다재다능합니다. 웹사이트를 만들고 싶으신가요? Django와 Flask는 여러분의 요구를 충족시킬 수 있는 많은 파이썬 프레임워크 중의 두 가지에 불과합니다. 데이터 과학을 깊게 탐험하고 싶으신가요? NumPy, pandas, 그리고 matplotlib과 같은 라이브러리들이 귀중한 동반자가 될 것을 알게 되실 것입니다...\n","ogImage":{"url":"/assets/img/2024-07-06-TheReasonsPythonWillDominatetheITIndustryby2025_0.png"},"coverImage":"/TIL/assets/img/2024-07-06-TheReasonsPythonWillDominatetheITIndustryby2025_0.png","tag":["Tech"],"readingTime":2},{"title":"TS Types와 Interfaces를 사용하는 방법 및 시기","description":"","date":"2024-07-02 21:53","slug":"2024-07-02-TSWhentouseTypesandwhentouseInterfaces","content":"\nTypeScript를 처음 접했을 때 인터페이스와 타입이 서로 교환 가능해 보일 수 있습니다, 특히 객체 모양을 설명할 때입니다. 실제로 TPerson 및 IPerson을 모두 가져오는 코드를 볼 수 있는데, 이는 둘 다 클래스 또는 객체 구조를 정의할 수 있다는 것을 시사합니다. 이 명백한 유사성은 각각을 사용해야 할 때에 대한 혼란을 야기할 수 있습니다.\n\n그러나 중요한 차이가 존재합니다: 인터페이스는 객체 및 클래스를 설명하는 데 사용되지만, 타입은 어떤 유형의 데이터 구조든 표현할 수 있습니다. 이 기본적인 대조는 TypeScript 프로젝트에서 각각을 언제 사용해야 할지에 대한 기준을 마련합니다.\n\n# 명백한 유사성\n\n다음과 같이 보이는 동등한 정의를 고려해보세요:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ninterface IPerson {\n  name: string;\n  age: number;\n}\n\ntype TPerson = {\n  name: string,\n  age: number,\n};\n\nconst person1: IPerson = { name: \"Alice\", age: 30 };\nconst person2: TPerson = { name: \"Bob\", age: 25 };\n```\n\nIPerson과 TPerson은 둘 다 이름과 나이 속성을 가진 객체를 설명할 수 있지만, 그 기능은 여기서부터 다릅니다.\n\n# 인터페이스: 클래스 제한을 위한 전문가\n\nTypeScript의 인터페이스는 특정 목적에 맞게 설계되었습니다: 객체와 클래스의 형태를 설명하는 데 사용됩니다. 원시 값의 별칭을 만들거나, 결합 유형 또는 교차 유형을 생성하는 데 사용할 수 없습니다. 이 특화된 기능은 인터페이스를 객체지향 프로그래밍 시나리오에서 특히 강력하게 만듭니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nTypeScript을 공부할 때 인터페이스와 타입의 차이를 이해하는 것이 중요합니다. 기억해야 할 주요 차이는 인터페이스는 객체와 클래스를 설명하는 데만 사용되지만, 타입은 어떤 종류의 데이터 구조든 나타낼 수 있다는 점입니다. 이 기본적인 대조는 TypeScript 프로젝트에서 각각을 언제 어떻게 사용해야 하는지를 결정합니다.\n\n인터페이스의 주요 장점은 다음과 같습니다:\n\n- 객체 모양 정의: 인터페이스는 객체가 특정 구조를 준수하는지 확실하게 보장하는 방법을 제공합니다.\n- 확장성: 인터페이스를 확장할 수 있어 복잡한 객체 유형을 시간이 지남에 따라 발전시키는 데 이상적입니다.\n- 클래스 구현: implements 키워드를 이용하여 클래스를 제한하고 인터페이스 계약을 준수하도록 함으로써 코드의 견고성을 향상시킵니다.\n\n간단한 예시를 살펴보겠습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ninterface IAnimal {\n  name: string;\n  age: number;\n  speak(): void;\n}\n\nclass Dog implements IAnimal {\n  name: string;\n  age: number;\n\n  constructor(name: string, age: number) {\n    this.name = name;\n    this.age = age;\n  }\n\n  speak() {\n    console.log(\"Woof!\");\n  }\n}\n```\n\n그리고 여기에 `extends` 키워드를 잘 활용한 예제가 있어요.\n\n```js\ninterface IAnimal {\n  name: string;\n  speak(): void;\n}\n\ninterface IDog extends IAnimal {\n  breed: string;\n  wagTail(): void;\n}\n\nclass Dog implements IDog {\n  name: string;\n  breed: string;\n\n  constructor(name: string, breed: string) {\n    this.name = name;\n    this.breed = breed;\n  }\n\n  speak() {\n    console.log(\"Woof!\");\n  }\n\n  wagTail() {\n    console.log(`${this.name}가 꼬리를 흔들고 있어요.`);\n  }\n}\n\nconst myDog = new Dog(\"Buddy\", \"Labrador\");\nmyDog.speak();\nmyDog.wagTail();\n```\n\n주의하셔야 할 점은 아래의 문법이 객체를 제한하는 경우에서는 클래스가 아닌 객체를 제한하는 경우에만 맞는 구문이에요:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```typescript\n인터페이스 IPerson {\n  이름: 문자열;\n  나이: 숫자;\n}\n\n상수 person1: IPerson = { 이름: \"Alice\", 나이: 30 };\n```\n\n# 타입: 다재다능한 파워하우스\n\n인터페이스는 객체 모양에만 제한되지만, 타입은 더 다양한 가능성을 제공합니다:\n\n- 다재다능성: 타입은 객체뿐만 아니라 기본 유형, 유니온, 교차, 튜플 등을 대표할 수 있습니다.\n- 복잡한 타입 작성: 유니언(|) 및 교차(\u0026) 연산자로 타입을 정교하게 정의할 수 있습니다.\n- 별칭: 타입 별칭은 복잡한 타입에서 코드 가독성을 높일 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음은 예제 입니다:\n\n```js\ntype TName = string;\ntype TAge = number;\n\ntype TPerson = {\n  name: TName,\n  age: TAge,\n};\n\ntype TAnimal = {\n  name: string,\n  age: number,\n  speak(): void,\n};\n\ntype TDog = TAnimal \u0026 { breed: string };\n\nconst myDog: TDog = {\n  name: \"Buddy\",\n  age: 5,\n  breed: \"Golden Retriever\",\n  speak() {\n    console.log(\"Woof!\");\n  },\n};\n```\n\n# 인터페이스와 유형 사이 선택하기\n\n각각의 한계와 강점을 이해하고, 다음 권장 사항을 고려해보세요:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Interfaces를 사용하는 경우:\n\n  - 오브젝트나 클래스와 작업할 때\n  - 오브젝트가 지켜야 하는 계약을 정의할 때\n  - 오브젝트 정의를 확장하거나 병합해야 할 때\n\n- Types를 사용하는 경우:\n  - 오브젝트를 포함한 모든 종류의 타입 정의를 생성할 때\n  - 유니언, 교차 또는 기본형과 작업할 때\n  - 타입 생성에서 최대 유연성이 필요할 때\n\n# 결론\n\nTypeScript에서의 인터페이스와 타입의 차이는 분명합니다: 인터페이스는 오브젝트 형태를 설명하는 데 특화되어 있고, 타입은 모든 종류의 타입 정의에 대해 더 큰 유연성을 제공합니다. 이 기본적인 차이를 이해하면 TypeScript 프로젝트에서 보다 정보를 얻고 더 나은 결정을 내릴 수 있습니다.\n\n인터페이스는 클래스 기반 시나리오에서 뛰어나며, 오브젝트 구조의 일관성을 보장해야 하는 경우에 유용합니다. 타입은 그들의 다양성으로 인해 복잡한 정의와 다양한 데이터 구조에 대한 가독성 향상에 필요한 도구입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마지막으로, 클래스와 타입을 제한하는 데 인터페이스를 사용하고 그 외에는 거의 모든 것에 인터페이스를 사용해야 합니다. 이렇게 하면 더 표현력이 뛰어나고 유지보수하기 쉽고 견고한 TypeScript 코드를 작성할 수 있습니다. 기억하세요, 이 도구들을 사용하여 시간이 지나도 유지할 수 있는 명확하고 자기 설명적인 코드를 작성하는 것이 목표입니다.\n","ogImage":{"url":"/TIL/assets/img/2024-07-02-TSWhentouseTypesandwhentouseInterfaces_0.png"},"coverImage":"/TIL/assets/img/2024-07-02-TSWhentouseTypesandwhentouseInterfaces_0.png","tag":["Tech"],"readingTime":6},{"title":"Nextjs 사용이 점점 더 어려워지는 이유","description":"","date":"2024-07-02 21:52","slug":"2024-07-02-ItsnotjustyouNextjsisgettinghardertouse","content":"\n![image 1](/TIL/assets/img/2024-07-02-ItsnotjustyouNextjsisgettinghardertouse_0.png)\n\n이전에 언급한 것처럼, Next.js 미들웨어를 사용하면 서버 컴포넌트가 부과한 일부 제한을 해결하는 데 유용할 수 있다는 블로그 글을 썼어요. 이에 대한 토론으로 인해 Next.js 개발 경험이 좋지 않다는 의견이 나왔어요.\n\n![image 2](/TIL/assets/img/2024-07-02-ItsnotjustyouNextjsisgettinghardertouse_1.png)\n\n저의 관점에서, Next.js 의 앱 라우터에는 채택하기 어렵게 만드는 두 가지 주요 문제가 있어요:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 보통 기초적인 작업을 하려면 내부 동작에 대해 많은 것을 이해해야 합니다.\n- 옵트인(opt-in)이 아닌 옵트아웃(opt-out)인 방식으로 발을 쏘기 쉬운 많은 방법이 있습니다.\n\n더 잘 이해하려면, 이전 버전인 Pages Router를 살펴보겠습니다.\n\n# Pages Router 간단히 살펴보기\n\nNext.js에 대해 처음 알게 되었을 때, 주요 \"경쟁자\"는 Create React App (CRA)였습니다. 나는 모든 프로젝트에 CRA를 사용했지만 두 가지 이유로 Next.js로 전환했습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 파일 기반 라우팅이 마음에 들었어요. 왜냐하면 보일러플레이트 코드를 적게 작성할 수 있어서요.\n- 개발 서버를 실행할 때마다 CRA는 빠르게 짜증나는 http://localhost:3000을 열었는데, Next.js는 그렇지 않았어요.\n\n두 번째 이유는 조금 어리석게 들릴 수 있지만, 나에게는 Next.js가 였어요:\n\n더 나은 기본 설정이 있는 React.\n\n그리고 그게 내가 정말 원했던 것이었어요. 후에 Next.js가 갖고 있는 다른 기능을 발견했을 때에는 꽤 놀랐어요. API 라우트는 추가 인프라를 설정할 필요 없이 서버리스 함수를 제공해주어서 \"Contact Us\" 양식 같은 것을 만드는 것에 아주 유용했어요. getServerSideProps를 사용하면 페이지가 로드되기 전에 서버에서 기본 함수를 실행할 수 있었어요.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그 개념들은 강력하지만 동시에 간단하기도 했어요.\n\nAPI route는 다른 라우트 핸들러와 매우 비슷하게 보였고 동작했어요. Express나 Cloudflare Workers를 사용해봤다면 라우트 핸들러를 자세히 보면 이미 알고 있던 개념들이 그대로 적용돼 있는 걸 느낄 수 있어요. getServerSideProps는 약간 다르긴 했지만, 한번 요청을 받는 방법과 응답 형식을 이해하면 꽤 간단한 거라는 걸 알게 되었어요.\n\n# 앱 라우터 릴리스\n\nNext 13 릴리스에서는 앱 라우터를 도입했고 많은 새로운 기능들이 추가됐어요. 서버 컴포넌트를 사용하면 React 컴포넌트를 서버에서 렌더링하고 클라이언트에 전달해야하는 데이터 양을 줄일 수 있어요.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n레이아웃은 여러 경로에서 공유되는 UI의 측면을 정의할 수 있어서 매번 탐색할 때마다 다시 렌더링할 필요가 없었습니다.\n\n캐싱 기능이... 더욱 정교해졌습니다.\n\n이러한 기능들이 흥미로웠지만, 가장 큰 손실은 간단함이었습니다.\n\n# 프레임워크가 생각했던대로 동작하지 않을 때\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n개발자로서 머리를 벽에 쿵쿵 치며 \"왜 이게 작동하지 않지?\" 하고 외치는 것은 상당히 보편적인 경험입니다.\n\n모두가 다 그런 적이 있고, 항상 짜증이 납니다. 제 경우, 코드에 버그가 아니라 어떻게 작동해야 하는지 잘 몰랐을 때가 더 고통스러웠습니다.\n\n이제 더 이상 \"왜 이게 작동하지 않지?\" 라고 말하지 않고, \"왜 이게 저렇게 작동하지?\" 라고 이제 말할 것입니다.\n\n앱 라우터는 안타깝게도 이러한 섬세한 점들로 가득합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n내 원래 문제를 다시 살펴보겠어요: 서버 컴포넌트에서 URL을 얻고 싶었어요. 주제에 대한 인기 있는 Github 이슈에 대한 답변을 준비했는데, 그 중 일부를 여기에 올려볼게요:\n\n이 응답은 정말 대단하다고 생각해요. 잘 쓰여졌고, 많은 기본적인 문제들을 이해하는데 도움이 되며, 저는 전혀 고려하지 못한 다양한 접근 방식과 관련된 절충안에 대한 통찰력을 얻게 되었어요.\n\n하지만 말해야 할 한 가지는, 개발자이고 서버 컴포넌트에서 URL을 얻으려는 것이라면, 아마도 이것을 읽은 후에 아마도 코드를 다시 구조화해야 한다는 것을 깨달을 때까지 5가지 더 찾아보고 있을 것이라는 것이죠.\n\n이 글은 나의 느낌을 요약한 것 같아요:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/TIL/assets/img/2024-07-02-ItsnotjustyouNextjsisgettinghardertouse_2.png)\n\n그것이 반드시 잘못된 것은 아니라는 점을 유의하십시오.\n\n원문에는 몇 가지 미묘한 점도 언급되어 있습니다. 하나의 보편적인 함정은 쿠키 처리 방식에 있습니다. 어디에서든 cookies().set(\"key\", \"value\")를 호출할 수 있고 이것은 타입 체크가 가능하지만, 일부 경우에는 런타임에서 실패할 수 있습니다.\n\n서버에서 거의 모든 것을 할 수 있었던 \"옛\" 방식과 비교하면, 복잡성이 증가했다고 말할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n제가 말씀드리고 싶은 것은 \"기본으로 켜진 캐싱\"은 다소 거친 경험이라는 점입니다. 많은 사람들이 캐싱에 동의하기를 기대하는 것이 오히려 캐싱 비활성화 방법을 찾기 위해 많은 문서를 살펴야 한다고 생각합니다.\n\n다른 회사들도 우리와 유사한 문제를 겪었을 거라고 확신합니다. PropelAuth에서 종종 버그 신고를 받는데, 그것들은 실제로 버그가 아니라 \"API 호출을 한 줄로 생각했지만 실제로는 호출하지 않았고, 캐시된 결과만 읽고 있는 것\"이라고 할 수 있습니다.\n\n그리고 이 모든 것은 다시 한 번 질문을 던집니다. 이러한 기능과 최적화는 과연 누구를 위한 것인가요?\n\n# 모두에게 맞는 제품을 만드는 것은 매우 어려운 일입니다\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n너가 너무 복잡하다고 느끼는 기능들은 실제로 몇몇 사람에겐 중요할 수 있어요. 예를 들어 전자상거래 플랫폼을 개발 중이라면, 이 기능들이 정말 유용할 거예요.\n\n작은 양의 데이터를 클라이언트에 전달하기 때문에 페이지가 빨리 로드됩니다. 모든 것이 강력하게 캐시되어 있어 페이지가 빨리 로드됩니다. 사용자가 새로운 페이지로 이동할 때 페이지의 일부만 다시 렌더링해야 하기 때문에 페이지가 더 빨리 로드됩니다. 전자상거래 세계에서 페이지가 빠르게 로드될수록 더 많은 수익이 발생하니, 이런 기능들을 위해 좀 더 복잡한 프레임워크를 사용하겠죠.\n\n하지만 SaaS 애플리케이션용 대시보드를 개발 중이라면… 이런 부분에 별로 신경 쓰지 않을 거예요. 기능을 빠르게 출시하는 속도를 더 중요하게 생각하고, 복잡성은 개발 팀에 부담이 될 거예요.\n\n제 개인적인 경험과 App Router에 대한 답답함은 다른 사람의 것과 다를 수 있어요. 제품, 사용 사례, 그리고 리소스가 모두 다르기 때문이에요. B2B SaaS 애플리케이션을 많이 작성하고 다른 사람들이 그것을 작성할 때 도와주는 사람으로서 말씀드리면, App Router DX는 Pages Router보다 한 단계 아래 수준이에요.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 프레임워크가 성장함에 따라 불가피한가요?\n\n제품/프레임워크가 성장하면 복잡해지는 경향이 있습니다. 고객들이 더 많은 것을 요청합니다. 대규모 고객들은 더 구체적인 것을 요청합니다. 대규모 고객들이 더 많은 금액을 지불하기 때문에 특정 기능을 우선적으로 개발합니다.\n\n이전에 모든 것의 간단함을 좋아했던 고객들은 일부 복잡한 점을 다루어야 한다고 느끼기 시작하고... 오, 보세요, 더 간단한 새로운 프레임워크가 나타났네요. 우리는 그것으로 모두 변경해야 합니다!\n\n이러한 상황을 피하는 것은 어려울 수 있지만, 일부 사람들이 필요로 하는 복잡성을 모두의 문제로 만들지 않는 방법 중 하나입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 그저 뭔가가 추천된다고 해서, 그게 당신에게 맞는 것은 아니라는 뜻은 아니에요\n\n앱 라우터를 사용함에 있어서 제가 겪은 가장 큰 문제 중 하나는 딱 이거였어요:\n\n![이미지](/TIL/assets/img/2024-07-02-ItsnotjustyouNextjsisgettinghardertouse_3.png)\n\nNext.js는 제품으로 충분히 준비되기 전부터 공식적으로 앱 라우터를 사용할 것을 권장해 왔어요. Next.js는 TypeScript, ESLint, Tailwind가 프로젝트에 적합한지 여부에 대한 권장사항을 갖고 있지 않아요 (TS/ESLint에는 기본 값으로 Yes, Tailwind에는 No를 제공하지만, Tailwind 팬들에게는 죄송합니다). 그러나, Next.js는 분명히 당신이 앱 라우터를 사용해야 한다고 믿고 있어요.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n공식 React 문서는 같은 의견을 공유하지 않습니다. 현재 그들은 페이지 라우터를 권장하고 앱 라우터를 \"최신형 React 프레임워크\"로 설명하고 있습니다.\n\n그 렌즈를 통해 앱 라우터를 바라볼 때, 더 많은 의미를 부여할 수 있습니다. React에 대한 권장 기본값으로 생각하는 대신, 베타 릴리스로 생각할 수 있습니다. 사용 경험이 더 복잡해지며, 몇 가지 쉬웠던 것들이 지금은 어려워지거나 불가능해졌습니다. 하지만 \"최신형\"인 것으로부터 무엇을 기대하겠습니까?\n\n따라서 다음 프로젝트를 위해 프레임워크를 선택할 때, 앱 라우터에는 여전히 많은 가공되지 않은 점이 있음을 인식하는 것이 중요합니다. 당신의 사용 사례에 더 적합한 다른 도구를 찾는 것이 더 나은 결과를 가져올 수도 있습니다.\n","ogImage":{"url":"/TIL/assets/img/2024-07-02-ItsnotjustyouNextjsisgettinghardertouse_0.png"},"coverImage":"/TIL/assets/img/2024-07-02-ItsnotjustyouNextjsisgettinghardertouse_0.png","tag":["Tech"],"readingTime":9},{"title":"TypeScript와 함께 작업할 때 정직이 최선의 정책인 이유  거짓말의 대가","description":"","date":"2024-07-02 21:49","slug":"2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript","content":"\n![이미지](/TIL/assets/img/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript_0.png)\n\n# 서문\n\n코드베이스로 새로운 풀 리퀘스트 '라이브러리 A 마이너 업데이트'를 받았다고 상상해보세요. 변경 사항을 검토하고 모든 것이 좋아 보입니다: 유닛 테스트를 통과했고, 통합 테스트가 성공했으며, 수동 테스트에서는 문제가 발견되지 않았습니다. 자신감을 갖고 PR을 프로덕션에 병합합니다. 성공적인 배포 후, 한 잠깐 쉬어도 좋을 것 같은 시간에 복어 잇님 모님 캆시 닦고 동료들과 이야기를 나눕니다. 정말 좋은 하루가 되고 있습니다.\n\n그러나 당신이 책상에 돌아가 앉은 순간, 예상치 못한 광경이 당신을 반격합니다: 슬랙 인박스에 99개의 읽지 않은 메시지가 있는 것입니다. 무엇이 잘못되었을까요?\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/TIL/assets/img/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript_1.png)\n\n코드 세계에서 거짓말은 현실 세계에서와 마찬가지로 치명적일 수 있습니다. TypeScript 컴파일러를 속이면 전체 응용 프로그램의 무결성이 위험에 빠집니다. 모든 X와 같이 알 수 없는 것은 시간이 지남에 따라 증가할 수 있는 가격이 따릅니다.\n\n이 기사는 다음 측면을 밝히는 데 목표를 두고 있습니다:\n\n- 코드베이스로 속임수를 도입하는 메커니즘\n- 이러한 실천으로 이어지는 근본적인 이유들\n- 기만의 사이클에서 벗어나 보다 투명한 코딩 접근 방식을 채택하는 전략\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Chapter 1: 속임수의 기술\n\n우선, \"거짓말\"의 정의부터 시작해 봅시다:\n\n하지만 거짓말은 프로그래밍과 무슨 공통점이 있는 걸까요 🤔? 실은 상당히 많은 부분이 비슷합니다.\n\n![이미지](/TIL/assets/img/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript_2.png)\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 거짓의 정의를 이해했으니, 우리에게 한 가지 질문을 해 보겠습니다:\n\n그럼, 한 가지 더 물어볼게요: 코드로 무언가를 수행하려고 하는 상황에서 TypeScript가 너무 엄격하거나 필요한 유연성을 제공하지 않는 상황에 처했던 적이 있나요? 혹시 '유형 단언'이나 명시적 형 변환을 시도해 보았는데, 컴파일러를 속이는 방법으로 기술적으로 올바르지만 예상과 맞지 않는 코드를 수용하도록 했던 적이 있나요?\n\nTypeScript는 우리 코드의 유형을 추론하는 데 탁월한 성과를 거두고 있습니다. 예를 들어, 이 스니펫에서 애완동물의 유형을 완벽하게 포착해냅니다:\n\n```js\nlet pets = [new Dog(), new Cat(), new Bird()];\nlet pets: (Dog | Cat | Bird)[];\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n실제 코딩은 종종 예상과는 다르게 복잡할 때가 많아요!\n\n개발자 생활에서 아래와 같은 경우를 만날 수도 있습니다:\n\n## 사례 1.\n\n```javascript\nconst params = new URL(document.location).searchParams;\nconst name = params.get(\"name\");\n\nconst hello = `Welcome ${name!}`;\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Case 2.\n\n```js\nimport { ColorsEnum } from 'happy-lib/colors';\nimport { LocalColorsEnum } from '../enums/color';\n...\n\nconst handleColorChange = async (colorToUpdate: LocalColorsEnum) =\u003e {\n    await callImaginaryApi('/colors', {\n        color: colorToUpdate as unknown as ColorsEnum\n    })\n}\n```\n\n## Case 3.\n\n```js\ntype UserType = 'admin' | 'superadmin' | 'user'\ntype SpecialUsers = Extract\u003cUserType, 'admin' | 'superadmin'\u003e\n\nconst allowList = ['admin', 'superadmin'] as const satisfies SpecialUsers[];\n\nconst doAdminStuff = (userType: SpecialUsers) =\u003e {\n  // magic\n}\n\nconst checkIfAllowed = (userType: UserType) =\u003e {\n  if (allowList.includes(userType)) {\n    doAdminStuff(userType as SpecialUsers)\n  }\n}\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 한 발자국 물러나서 이 경우들을 다시 살펴보고 \"거짓말\"을 찾아보세요.\n\n![이미지](/TIL/assets/img/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript_3.png)\n\n찾았나요? 네, 아니오? (혹시라도? 모르겠어요). 네라면, 축하해요 🎉 찾지 못했다면 걱정마시고 계속해서 읽어보세요.\n\n우리 함께 모든 경우를 해결해 낼 거에요 💪.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 케이스 1\n\n```js\nconst params = new URL(document.location).searchParams;\nconst name = params.get(\"name\");\n\nconst hello = `환영합니다, ${name}님!`;\n```\n\n여기에는 URL에서 검색 매개변수를 구문 분석하는 클래식 프론트엔드 사례가 있습니다. 이름 매개변수를 검색하고 환영 메시지를 반환하려고 합니다. 안타깝게도, 이 코드는 거짓말을 하고 있습니다.\n\n```js\nconst hello = `환영합니다, ${name}님!`;\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n당신이 왜 이것을 문제로 생각하는지 궁금할 수도 있습니다. URL에 이름 매개변수가 없는 경우, \"이름이 정의되지 않은 상태에서 '안녕하세요'가 표시됩니다. 코드에는 TypeScript에게 모든 것이 괜찮다고 확신하는! - non-null assertion operator가 포함되어 있습니다. (여기서는 사실이 아닙니다 😠). 우리에게 다행히, 해결책은 간단합니다:\n\n```js\nconst params = new URL(document.location).searchParams;\nconst name = params.get(\"name\");\n\nif (!name) {\n  // 오류 케이스를 좀 더 세련되게 처리\n}\n\nconst hello = `환영합니다 ${name}`;\n```\n\nTypeScript를 사용하여 narrowing을 하고, 오래된 if 문의 도움으로 이제 if 블록 바깥에서 name을 사용할 때 항상 값이 있다고 확신할 수 있습니다. 잠재적인 오류를 숨겨도 오류가 사라질 것이라는 보장은 없다는 것을 기억하는 것이 매우 중요합니다.\n\n## 케이스 2\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport { ColorsEnum } from 'happy-lib/colors';\nimport { LocalColorsEnum } from '../enums/color';\n...\n\nconst handleColorChange = async (colorToUpdate: LocalColorsEnum) =\u003e {\n    await callImaginaryApi('/colors', {\n        color: colorToUpdate as unknown as ColorsEnum\n    })\n}\n```\n\n여기서 볼 수 있는 것은 상상 속의 API를 사용하여 색상을 업데이트하는 간단한 경우입니다. 현재 코드가 어떻게 보이는지에 따라 모든 것이 괜찮아 보입니다. 수동으로 작동을 테스트하고 유닛 테스트를 추가했습니다. 네, colorToUpdate을 다른 열거형으로 수용하지만, 값이 동일하고 변경되지 않을 것을 알고 있습니다.\n\n불행하게도, 위의 줄은 거짓말이 들어 있으며 찾기 어려운 것입니다.\n\n아래 줄에 집중해보겠습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n...\ncolor: colorToUpdate as unknown as ColorsEnum\n...\n```\n\n이 코드는 TypeScript에게 다음을 알려줍니다:\n\nhappy-lib/colors 패키지가 주요 패치를 받을 경우를 가정해 봅시다. 알 수없는 이유로 ColorsEnum이 변경되어 열거형의 키 케이싱이 바뀝니다. 이러한 열거형은 더 이상 동일한 값을 보유하지 않습니다. TypeScript 컴파일러는 이러한 사항에 대해 경고하지 않고 단위 테스트에서는 문제를 포착하지 못할 것입니다. 이 문제를 포착하는 것은 수동 또는 엔드투엔드 테스트에 달려 있습니다. 그러나 이럴 필요는 없습니다.\n\n우리는 진실을 이야기하기 위해 이 코드를 다시 작성해보겠습니다. 이 연습의 목적을 위해 colorToUpdate 유형을 변경할 수 없으며, 이 작업을 함수 내부에서 처리해야 합니다. TypeScript(또는 JavaScript)에서 열거형을 비교하는 것은 어렵습니다. 우리가 할 수 있는 것은 번역기를 작성하거나(또는 사전을 사용하는 것)하는 것입니다:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nfunction transformColorEnum(localColor: LocalColorsEnum): ColorsEnum | null {\n  switch (localColor.toString()) {\n    case LocalColorsEnum.Red:\n      return ColorsEnum.Red;\n    case LocalColorsEnum.Green:\n      return ColorsEnum.Green;\n    case LocalColorsEnum.Blue:\n      return ColorsEnum.Blue;\n    default:\n      return null;\n  }\n}\n\nconst handleColorChange = async (colorToUpdate: LocalColorsEnum) =\u003e {\n  const translatedColor = transformColorEnum(colorToUpdate);\n\n  if (!translatedColor) {\n    // 에러 케이스를 처리하세요\n  }\n\n  await callImaginaryApi(\"/colors\", {\n    color: colorToUpdate,\n  });\n};\n```\n\n여기서 우리는 무엇을 달성했을까요? 이제 API 변경으로 인해 잘못된 값이 전송되는 경우를 방지할 수 있게 되었습니다.\n\n맞아요. 이 코드를 개선할 다양한 방법이 있습니다(어떤 라이브러리도 사용하지 않고도), 하지만 이번에는 Zod 라이브러리를 사용하여 이를 처리하는 방법을 보여드리고 싶었어요:\n\n```js\nimport z from \"zod\";\n\nconst handleColorChange = async (colorToUpdate: LocalColorsEnum) =\u003e {\n  const translatedColor = z.nativeEnum(ColorsEnum).safeParse(colorToUpdate);\n\n  if (!translatedColor.success) {\n    // 에러 케이스를 처리하세요\n  }\n\n  await callImaginaryApi(\"/colors\", {\n    color: colorToUpdate,\n  });\n};\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 케이스 3\n\n```js\ntype UserType = 'admin' | 'superadmin' | 'user'\ntype SpecialUsers = Extract\u003cUserType, 'admin' | 'superadmin'\u003e\n\nconst allowList = ['admin', 'superadmin'] as const satisfies SpecialUsers[];\n\nconst doAdminStuff = (userType: SpecialUsers) =\u003e {\n  // magic\n}\n\nconst checkIfAllowed = (userType: UserType) =\u003e {\n  if (allowList.includes(userType)) {\n    doAdminStuff(userType as SpecialUsers)\n  }\n}\n```\n\n이미 1과 2번 케이스를 해결했다면, 여기서 형 변환을 하고 있다는 것을 빠르게 지적할 수 있을 것입니다. 그리고 당신은 맞을 것입니다! 다행히 이번에는 상황이 심각하지는 않습니다. 사용자가 권한 배열에 포함되어 있는지 확인하기 때문에 안전합니다. 그러나 우리는 가져야 할 정보 유형을 잃어버렸습니다. 거의 동일한 로직을 유지하면서 정보 유형을 복구해 봅시다.\n\n```js\ntype UserType = 'admin' | 'superadmin' | 'user';\ntype SpecialUsers = Extract\u003cUserType, 'admin' | 'superadmin'\u003e;\n\nconst allowList = ['admin', 'superadmin'] as const satisfies SpecialUsers[];\n\nconst doAdminStuff = (userType: SpecialUsers) =\u003e {\n  // magic\n};\n\nconst isSpecialUser = (userType: UserType): userType is SpecialUsers =\u003e {\n  return allowList.includes(userType as SpecialUsers);\n};\n\nconst checkIfAllowed = (userType: UserType) =\u003e {\n  if (isSpecialUser(userType)) {\n    doAdminStuff(userType);\n  }\n};\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 형변환(casting)이 안전한 이유는 `isSpecialUser` 유형 가드 함수 내부에서 사용하기 때문입니다. TypeScript는 includes 확인이 통과되면 `userType`이 `SpecialUsers` 유형이어야 한다는 것을 이해합니다. 따라서 형변환은 안전하며 유형 안전성을 위반하지 않습니다. 이렇게 하면 `userType` 변수는 if 블록의 범위 내에서 `SpecialUsers` 유형을 유지합니다.\n\n![이미지](/TIL/assets/img/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript_4.png)\n\n3/3 사건 마무리 수사관 - 훌륭한 일했어요.\n\n# 2장: 거짓말의 해부학.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저희 코드에서 문제점을 파악했습니다. 이제는 그 문제들이 처음에 발생한 이유를 이해해야 합니다.\n\n코딩 세계에서는 종종 특정 목표를 이루기 위해 의도적으로 유형이나 데이터 구조를 조작하는 상황에 처합니다. 실생활에서 무언가에 대해 확신이 없거나 단축키를 사용하길 원할 때 사람들이 진실을 왜곡하는 것과 비슷한 상황이죠.\n\n## 알 수 없는 데이터\n\n가장 일반적으로 '거짓말'을 하는 경우는 데이터가 불확실한 출처에서 올 때입니다. 예를 들어, 이 코드 조각을 살펴보죠:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n// API에서 사용자 데이터를 가져옵니다\nconst response = await getUsers();\nconst users = await response.json();\n```\n\n사용자가 특정 유형임을 정확히 알 수 있을까요? 대부분, 다음과 같은 것을 볼 수 있습니다:\n\n```js\nconst users: Users = await response.json() as Users;\n```\n\n대부분의 경우에는 잘 작동합니다. 그러나 이 코드는 실제로 안전하지 않습니다. 우리가 호출하는 엔드포인트가 지정된 형식의 데이터를 반환하는지 알 방법이 없습니다. 유형 단언(as Users)을 사용하여 사실상 코드에 거짓말을 하고 원하는 것이 맞다고 코드에 알려주는 것입니다. 하지만 이러한 \"소백한 거짓말\"은 종종 미래 문제의 근본 원인이 되며 오류 케이스를 무시합니다. getUsers가 반환하는 유형이 변경되면 어떻게 될까요? TypeScript에 모든 것이 괜찮고 특정 유형(e.g., Users)이 반환될 것이 확실하다고 확신할 수 있지만, 실제로는 코드가 예기치 않은 유형을 처리할 준비가 되어 있지 않습니다. 이는 프로덕션 코드를 망가뜨릴 수 있는 런타임 오류로 이어질 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript_5.png\" /\u003e\n\n## 게으름 (좋은겁니다 😎)\n\n가끔은 사소해 보이지만 디버깅하기 어려울 수 있는 거짓말도 있어요.\n\n예를 들어 단위 테스트에서 대량의 모의 객체가 있는 경우를 생각해봅시다. 특정 속성만 신경 쓰지만 자동완성과 타입 안전성의 이점을 원한다면, 이런 식의 코드가 될 수 있습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nconst veryBigObjectMock: BigObjectType = {\n    ...{} as BigObjectType,\n    keyIWantToMock: 'myMock'\n};\n```\n\n컴파일러가 만족하고 테스트가 의도대로 실행됩니다...지금까지는요. 그러나 어느 날 테스트가 실패하면서 데이터 구조가 변경되었다는 것을 알고 있음에도 TypeScript의 타입 체커(tsc)가 문제를 보고하지 않는 것을 발견할 수 있습니다. 아마도 당신이 로직을 잘못 이해한 것인지 생각해 볼지도 모르겠죠.\n\n무엇이 잘못되었는지 알아내려고 몇 시간을 낭비한 후, 오래된 키 이름을 가진 잊혀진 목 객체를 기억낼 수 있습니다. 시간을 낭비한 셈이죠.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 준비되지 않은 데이터 사용\n\n준비되지 않은 데이터를 사용하는 것은 일반적인 함정일 수 있습니다. 우리는 밑바닥 데이터를 안전하게 사용할 수 있는지 확인하지 않고 속성이나 메서드에 액세스하려는 유혹을 느낄 수 있습니다.\n\n예를 살펴봅시다. 비동기적으로 가져온 할 일 항목을 표시하는 TodoList 컴포넌트가 있다고 가정해 봅시다. 이 할 일 항목은 리덕스의 useSelector 훅을 통해 반환됩니다 (물론 다른 상태 관리 라이브러리일 수도 있습니다):\n\n```js\nimport * as React from \"react\";\nimport { useSelector } from \"react-redux\";\n\ntype Todo = { id: string, name: string };\n\nconst TodoList = () =\u003e {\n  const todos: Todo[] | null = useSelector((state) =\u003e state.todos);\n\n  return (\n    \u003cul\u003e\n      {todos?.map((todo) =\u003e (\n        \u003cli key={todo.id}\u003e{todo.name}\u003c/li\u003e\n      ))}\n    \u003c/ul\u003e\n  );\n};\nexport default TodoList;\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 컴포넌트를 사용할 때는 잘 렌더링됩니다. 그러나 주의 깊게 관찰하거나 인터넷 연결이 느린 경우에는 1초 미만의 깜빡임이 발생할 수도 있습니다. 하지만 받는 데 시간이 걸리는 경우나 애플리케이션에서 할 일 항목에 대한 실시간 업데이트를 보여주려는 경우에는 어떨까요? 이 순진한 방법을 사용하면 사용자 경험이 좋지 않을 수 있습니다. TypeScript는 할 일 항목이 비어 있을 수 있다고 알려줬는데도 우리는 그 경고를 무시하기로 결정했습니다.\n\n# 제 3장: 진실의 힘.\n\n![이미지](/TIL/assets/img/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript_6.png)\n\n지금까지 코드에서 거짓이 어떻게 보이는지와 그 코드베이스에 나타난 이유에 중점을 두었습니다. 그러나 우리는 진실을 말할 수 있는 방법이 무엇이며 어떻게 거짓을 멈출 수 있을까요?\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다행히도, 쉬운 일은 아니지만 우리 삶을 많이 개선해 줄 것입니다.\n\n**Typescript을 믿으세요.**\n\nTypescript는 당신을 위해 최선을 다해줍니다. 당신에게 경고를 주고 실수를 예방해줍니다. 코드에서 보이는 오류와 경고에는 그 이유가 있습니다.\n\n**엄격한 eslint 및 tsconfig 규칙을 추가하세요.**\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자동화할 수 있는 것은 자동화하고 엄격한 @typescript-eslint 구성을 사용하세요. 이는 오류를 보여주는 것뿐만 아니라 미래 실수를 방지하는 데 도움이 될 수 있습니다. 최상의 관행과 권장 사항을 사용하여 tsconfig를 설정하세요 (예: https://www.totaltypescript.com/tsconfig-cheat-sheet). 이렇게 하면 올바른 방향으로 유지될 수 있습니다. 수동으로 확인할 필요가 줄수록 더 좋습니다.\n\n## TypeScript에게 일을 시키세요.\n\nif-else 조건문 및 switch 문과 같은 흐름 제어문을 사용하면 TypeScript가 변수 유형에 대한 이해를 더욱 정확하게 할 수 있습니다. 다음과 같이 할 수 있습니다:\n\n```js\nconst optionalValue: string | null = getOptionalValue();\n\nif (!optionalValue) {\n  return;\n} else {\n  // 코드의 나머지 부분\n}\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\noptionalValue에 값이 항상 있으므로 else 본문에서 수동 타입 체크가 필요하지 않습니다.\n\n## 확실히 움직이세요.\n\n값이 undefined 또는 null일 가능성이 있는 경우, 그러한 경우가 발생할 가능성이 높으므로 이에 대비하고 정상적으로 처리하세요. 입력 유효성 검사, 방어적 프로그래밍 및 타입 체크를 통해 가능성을 좁힙니다. 기본값 제공, 오류 처리 구현, 그리고 작업 전에 이러한 경우를 확인하고 처리하는 방어적 코드 작성과 같은 전략을 활용하세요.\n\n## 런타임에서 유효성 검사하세요.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예방 조치인 입력 유효성 검사와 유형 검사와 같은 것들은 중요하지만, 알려지지 않거나 신뢰할 수 없는 객체를 다룰 때는 런타임에 데이터를 유효성 검사하는 것이 매우 중요합니다. 이를 달성하는 강력한 도구 중 하나는 zod입니다. TypeScript를 기반으로 한 스키마 유효성 검사 라이브러리로 데이터의 예상 형태와 유형을 정의하는 엄격한 스키마를 설정할 수 있습니다. 데이터 구조물의 청사진과 같은 개념입니다! Zod를 사용하면 런타임에서 잘못된 또는 예기치 않은 데이터에 대해 경고를 내어주는 강력한 스키마를 만들 수 있습니다. 예를 들어, 외부 API나 사용자 입력에서 데이터를 받는 경우, 해당 데이터의 예상 구조를 나타내는 Zod 스키마를 정의하고 해당 스키마를 사용하여 들어오는 데이터를 유효성 검사할 수 있습니다. 이를 통해 지정된 유형, 형태 및 제약 조건을 준수하는지 확인할 수 있습니다. 데이터가 이러한 기대에 미치지 않는 경우, Zod는 유용한 오류를 발생시켜 이 문제를 세련되게 처리할 수 있게 도와줍니다. 또한, 유형 가드나 어서션 함수와 같은 기술을 구현하는 자체 파서를 작성할 수도 있습니다.\n\n# Chapter 4: 마무리.\n\nTypeScript의 타입 어설션을 사용하면 값의 유형에 대해 컴파일러에게 거짓 정보를 전달할 수 있습니다. 유효한 사용 사례가 제한적이지만 자주 남용되며, 정적 유형 확인 목적을 해치는 잔인한 유형 오류를 초래할 수 있습니다.\n\n완벽한 세상에서는 사용하는 라이브러리에서 모든 타이핑을 처리할 수 있고 가능한 한 순수 JavaScript에 가까운 코드만 작성할 수 있을 것입니다. 불행하게도, 이것은 현실적으로 어렵고, 타입을 어떻게 구조화할지에 대해 신중해야 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nTypeScript는 개발자가 오류를 잡고 코드 품질을 향상시키는 데 도움을 주도록 설계되었지만, 마법같은 해결책은 아닙니다. 여전히 그 아래에는 옛날의 JavaScript가 있다는 것을 기억해야 합니다. TypeScript는 정적 유형 검사를 위한 강력한 도구를 제공하지만 모든 잠재적인 런타임 오류를 제거할 수는 없습니다.\n\n이 글을 처음부터 끝까지 함께 읽어주셔서 감사합니다. 그리고 기억하세요:\n\n거짓말 하지 마세요.\n\n![이미지](/TIL/assets/img/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript_7.png)\n","ogImage":{"url":"/TIL/assets/img/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript_0.png"},"coverImage":"/TIL/assets/img/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript_0.png","tag":["Tech"],"readingTime":19},{"title":"Nextjs에서 Tailwind와 Swiper로 썸네일 슬라이더 만드는 방법","description":"","date":"2024-07-02 21:47","slug":"2024-07-02-CreatingaThumbnailSliderinNextjswithTailwindandSwiper","content":"\n## Next.js, Tailwind CSS, 및 Swiper를 사용하여 썸네일 슬라이더 만들기 단계별 가이드\n\n썸네일은 더 큰 이미지의 작은 이미지 표현입니다.\n\n썸네일 슬라이더는 클릭할 수 있는 주요 이미지와 그 아래 일련의 썸네일을 포함하는 슬라이더입니다.\n\n위 내용을 기반으로, Next.js, Tailwind CSS, 및 Swiper를 사용하여 자체 썸네일 슬라이더를 만드는 것을 시작해보겠습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 프로젝트 설정\n\n우선, 새로운 Next.js 프로젝트를 설정해보세요. 터미널을 열고 다음 명령어를 실행하세요:\n\n```js\nnpx create-next-app@latest\n```\n\n그런 다음에 뒤이어 나오는 프롬프트에 답변하세요. 내 개인적인 답변은 각 줄의 괄호 안에 있습니다. \"Tailwind CSS\"에 대해 \"Yes\"로 선택하는 것을 잊지 마세요.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n프로젝트의 이름은 무엇인가요? my-app (thumbnail-slider)\n\nTypeScript를 사용하시겠습니까? 아니요 / 예 (예)\n\nESLint를 사용하시겠습니까? 아니요 / 예 (예)\n\nTailwind CSS를 사용하시겠습니까? 아니요 / 예 (예)\n\n`src/` 디렉토리를 사용하시겠습니까? 아니요 / 예 (아니요)\n\nApp Router를 사용하시겠습니까? (권장) 아니요 / 예 (예)\n\n기본 import 별칭 (@/*)을 사용자 정의하시겠습니까? 아니요 / 예 (아니요)\n```\n\n다음으로, 프로젝트 디렉토리에 들어간 후에 Swiper를 설치하세요.\n\n```js\nnpm install swiper\n```\n\n# 썸네일 슬라이더 구축하기\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 Thumbnail Slider를 구축하기 위한 필수 구성 요소를 생성해 봅시다.\n\n- 프로젝트 디렉토리에 components라는 새 디렉토리를 만듭니다.\n- components 디렉토리 내부에 ThumbnailSlider.tsx 또는 .jsx라는 새 파일을 만듭니다(typescript를 사용하지 않는 경우).\n\n## 필수 구성 요소 가져오기\n\nswiper에 필요한 가져오기를 추가하는 것부터 시작해 봅시다. 아래 코드를 그대로 복사하세요:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n\"use client\";\n\nimport React, { useState } from \"react\";\nimport Image from \"next/image\";\n\n// Swiper React 컴포넌트 가져오기\nimport { Swiper, SwiperSlide } from \"swiper/react\";\n\n// Swiper 유형 가져오기\nimport { Swiper as SwiperType } from \"swiper\";\n\n// Swiper 스타일 가져오기\nimport \"swiper/css\";\nimport \"swiper/css/navigation\";\nimport \"swiper/css/thumbs\";\n\n// 필요한 모듈 가져오기\nimport { Thumbs } from \"swiper/modules\";\n```\n\n설명:\n\n- 컴포넌트 가져오기: Swiper 및 SwiperSlide는 Swiper 라이브러리의 React 모듈에서 가져옵니다. 이러한 컴포넌트는 캐러셀/슬라이더와 개별 슬라이드를 만들고 관리하는 데 사용됩니다.\n- 유형 가져오기: Swiper as SwiperType은 TypeScript 유형 안전성을 위해 가져옵니다. 이를 통해 적절한 코드 지원과 오류 확인이 가능합니다.\n- 스타일 가져오기: Swiper CSS 파일을 가져와서 캐러셀에 필요한 중요한 스타일을 적용합니다. 이는 네비게이션 버튼 및 썸네일 네비게이션을 포함합니다.\n- Thumbs 모듈: Thumbs는 \"swiper/modules\"에서 가져온 것입니다. 이 모듈은 Swiper 슬라이더의 썸네일 네비게이션 기능을 제공합니다.\n\n## 개별 컴포넌트 생성하기\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 썸네일 슬라이더 컴포넌트를 만들어볼 차례에요. 슬라이더 컴포넌트와 썸네일 컴포넌트와 함께 만들 것인데요, 이들은 한 컴포넌트에 모은 코드양을 줄이기 위해 분리되어 있어요.\n\n```js\nconst ThumbnailSlider = ({ images }: { images: string[] }) =\u003e {\n  return (\n    // 메인 슬라이더와 썸네일 슬라이더를 담는 컨테이너\n    \u003cdiv className=\"w-4/5 h-4/5 flex flex-col gap-4\"\u003e\n      \u003cSlider images={images} /\u003e {/* 메인 이미지 슬라이더 */}\n      \u003cThumbnail images={images} /\u003e {/* 썸네일 내비게이션 슬라이더 */}\n    \u003c/div\u003e\n  );\n};\n\nconst Slider = ({ images }: { images: string[] }) =\u003e {\n  return (\n    // 메인 이미지 슬라이더 컴포넌트\n    \u003cdiv className=\"w-full h-full flex-1 overflow-hidden\"\u003e\n      \u003cSwiper className=\"h-full\" grabCursor loop\u003e\n        {/* 각 이미지 슬라이드를 만들기 위해 이미지를 반복합니다. */}\n        {images.map((image, index) =\u003e (\n          \u003cSwiperSlide key={index}\u003e\n            \u003cdiv className=\"relative w-full h-full\"\u003e\n              {/* 각 슬라이드의 이미지 컴포넌트 */}\n              \u003cImage\n                src={image}\n                alt=\"slide\"\n                fill\n                className=\"object-cover\"\n                sizes=\"70vw\"\n                priority={index === 0 \u0026\u0026 true} // 첫 번째 이미지가 우선적으로 로드되도록 합니다.\n              /\u003e\n            \u003c/div\u003e\n          \u003c/SwiperSlide\u003e\n        ))}\n      \u003c/Swiper\u003e\n    \u003c/div\u003e\n  );\n};\n\nconst Thumbnail = ({ images }: { images: string[] }) =\u003e {\n  return (\n    // 썸네일 내비게이션 슬라이더 컴포넌트\n    \u003cdiv className=\"relative flex gap-2 justify-center h-14\"\u003e\n      \u003cSwiper className=\"w-2/4 h-full\" loop slidesPerView={4} spaceBetween={8}\u003e\n        {/* 각 썸네일을 만들기 위해 이미지를 반복합니다. */}\n        {images.map((image, index) =\u003e (\n          \u003cSwiperSlide\n            key={index}\n            className=\"rounded-md cursor-pointer border-[3px] border-solid border-transparent overflow-hidden\"\n          \u003e\n            \u003cdiv className=\"relative w-full h-full\"\u003e\n              {/* 썸네일 이미지 컴포넌트 */}\n              \u003cImage src={image} alt=\"thumbnail\" fill className=\"object-cover\" sizes=\"100px\" /\u003e\n            \u003c/div\u003e\n          \u003c/SwiperSlide\u003e\n        ))}\n      \u003c/Swiper\u003e\n    \u003c/div\u003e\n  );\n};\n\nexport default ThumbnailSlider;\n```\n\n## 슬라이더와 썸네일 컴포넌트 연결하기\n\n여기까지 오면 썸네일 슬라이더는 거의 완성되었어요. 유일한 문제는 현재 각각 따로 움직인다는 것이죠. 하지만 우리가 원하는 것은 이들이 연결된 것처럼 함께 움직이도록 하는 것입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이를 달성하기 위해 ThumbnailSlider 컴포넌트에 다음을 추가할 것입니다:\n\n```js\nconst [thumbsSwiper, setThumbsSwiper] = (useState \u003c SwiperType) | (null \u003e null);\n```\n\n그런 다음 이를 Slider 및 Thumbnail 컴포넌트로 props로 전달하세요.\n\n```js\n\u003cSlider images={images} thumbs={ thumbsSwiper, setThumbsSwiper } /\u003e\n\u003cThumbnail images={images} thumbs={ thumbsSwiper, setThumbsSwiper } /\u003e\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n물론, Slider 및 Thumbnail 컴포넌트에 새로운 속성(props)을 전달하고 있기 때문에 해당 코드를 업데이트해야 합니다.\n\nTypescript를 사용 중이라면, 다음과 같이 타입 안전성을 위한 인터페이스를 붙여넣으세요:\n\n```js\ninterface SliderProps {\n  images: string[];\n  thumbs: {\n    thumbsSwiper: SwiperType | null,\n    setThumbsSwiper: React.Dispatch\u003cReact.SetStateAction\u003cSwiperType | null\u003e\u003e,\n  };\n}\n```\n\n이제 정의한 상태를 사용하도록 Slider 및 Thumbnail 컴포넌트를 편집해 보겠습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n슬라이더 컴포넌트에서 다음 작업을 수행하십시오:\n\n```js\nconst Slider = ({ images, thumbs }: SliderProps) =\u003e {\n  const { thumbsSwiper } = thumbs;\n\n  return (\n    \u003cdiv className=\"w-full h-full flex-1 overflow-hidden\"\u003e\n      {/* 이미지 슬라이더용 주 스와이퍼 컴포넌트 */}\n      \u003cSwiper\n        className=\"h-full\"\n        grabCursor\n        loop\n\n        thumbs={{ swiper: thumbsSwiper }} // 메인 슬라이더를 썸네일 싱크를 위해 썸네일 스와이퍼에 연결\n        modules={[Thumbs]} // 썸네일 탐색을 위해 Thumbs 모듈을 활성화\n      \u003e\n       // 이전 코드를 여기에 추가하세요...\n      \u003c/Swiper\u003e\n    \u003c/div\u003e\n```\n\n썸네일 컴포넌트에서 다음 작업을 수행하십시오:\n\n```js\nconst Thumbnail = ({ images, thumbs }: SliderProps) =\u003e {\n  const { setThumbsSwiper } = thumbs;\n\n  return (\n    \u003cdiv className=\"relative flex gap-2 justify-center h-14\"\u003e\n      {/* 썸네일 탐색용 스와이퍼 컴포넌트 */}\n      \u003cSwiper\n        className=\"w-2/4 h-full\"\n        loop\n        slidesPerView={4} // 한 뷰 당 썸네일 수\n        spaceBetween={8} // 썸네일 간 간격\n        onSwiper={setThumbsSwiper} // 컴포넌트가 마운트될 때 썸네일 스와이퍼 설정\n        freeMode // 스냅 포인트 없이 자유롭게 슬라이딩 허용\n        watchSlidesProgress // 썸네일의 슬라이드 진행 상황을 감시\n      \u003e\n        // 이전 코드를 여기에 추가하세요...\n      \u003c/Swiper\u003e\n    \u003c/div\u003e\n  );\n};\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 활성 썸네일 요소 스타일링\n\n지금은 섬네일 슬라이더가 제대로 작동해야 하지만, 현재 활성화된 썸네일을 강조하고 싶다면 globals.css 파일을 /app 디렉토리에서 열어서 다음 CSS 코드를 추가할 수 있어요:\n\n```js\n.swiper-slide-thumb-active {\n    border-color: black;\n}\n```\n\n## 썸네일 슬라이더 컴포넌트 사용하기\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n최종적으로 코드에서 썸네일 슬라이더를 사용하려면 간단히 가져와서 다음과 같이 호출하면 됩니다:\n\n```js\nimport ThumbnailSlider from \"@/components/ThumbnailSlider\";\n\nexport default function Home() {\n  return (\n    \u003cmain className=\"w-full h-screen flex items-center justify-center\"\u003e\n      \u003cThumbnailSlider images={images} /\u003e\n    \u003c/main\u003e\n  );\n}\n```\n\n썸네일 슬라이더가 작동하려면 이미지 URL을 나타내는 문자열 배열을 제공해야 합니다. 아래는 그 예시입니다:\n\n```js\n// 별칭을 사용하여 components 디렉토리에서 ThumbnailSlider 컴포넌트 가져오기\nimport ThumbnailSlider from \"@/components/ThumbnailSlider\";\n\n// 홈 페이지를 위한 기본 함수 컴포넌트\nexport default function Home() {\n  // 동적으로 생성된 이미지 URL 배열\n  const images = Array(4)\n    .fill(null)\n    .map((_, index) =\u003e `/random/image (${index + 1}).png`);\n\n  // 주요 콘텐츠 영역 렌더링\n  return (\n    \u003cmain className=\"w-full h-screen flex items-center justify-center\"\u003e\n      {/* 동적으로 생성된 이미지를 사용하여 ThumbnailSlider 컴포넌트 렌더링 */}\n      \u003cThumbnailSlider images={images} /\u003e\n    \u003c/main\u003e\n  );\n}\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위 글을 읽어주셔서 정말 감사합니다! 😊\n만약 이 글이 도움이 되었다면 반드시 박수를 치고 팔로우해주세요! 👏\n","ogImage":{"url":"/TIL/assets/img/2024-07-02-CreatingaThumbnailSliderinNextjswithTailwindandSwiper_0.png"},"coverImage":"/TIL/assets/img/2024-07-02-CreatingaThumbnailSliderinNextjswithTailwindandSwiper_0.png","tag":["Tech"],"readingTime":11},{"title":"코믹 힙에서 요소 추가 및 제거 과정 이해하기","description":"","date":"2024-07-02 21:45","slug":"2024-07-02-ComicHowAddingRemovingStuffFromHeapsWork","content":"\n![image](/TIL/assets/img/2024-07-02-ComicHowAddingRemovingStuffFromHeapsWork_0.png)\n\n# 간단한 소개\n\n힙(heap)은 우선순위 큐(priority queue)의 구현 방식입니다. 힙에서는 우선 순위가 가장 높은 요소가 먼저 나갑니다. 우선 순위는 다음과 같이 정의될 수 있습니다:\n\n- 최대 힙(max heap)의 경우 가장 큰 숫자가 먼저 나갑니다.\n- 최소 힙(min heap)의 경우 가장 작은 숫자가 먼저 나갑니다.\n","ogImage":{"url":"/TIL/assets/img/2024-07-02-ComicHowAddingRemovingStuffFromHeapsWork_0.png"},"coverImage":"/TIL/assets/img/2024-07-02-ComicHowAddingRemovingStuffFromHeapsWork_0.png","tag":["Tech"],"readingTime":1},{"title":"Jupyter Lab IDE에서 Typescript, LangChainjs, Ollama를 사용하여 AI 프로토타입 환경 빠르게 구축하는 방법","description":"","date":"2024-07-02 21:45","slug":"2024-07-02-CreateanAIprototypingenvironmentusingJupyterLabIDEwithTypescriptLangChainjsandOllamaforrapidAIprototyping","content":"\n## TypeScript 개발자를 위한 단계별 안내서\n\n![Image](/TIL/assets/img/2024-07-02-CreateanAIprototypingenvironmentusingJupyterLabIDEwithTypescriptLangChainjsandOllamaforrapidAIprototyping_0.png)\n\n# 소개\n\n이 글은 AI 지원 개발에 대한 나의 여정을 설명한 글 시리즈의 두 번째 부분입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 시리즈의 소개 부분에서는 최근 변경 사항을 요약하여 Typescript로 AI 앱을 프로토 타입 및 개발할 수 있도록 하는 내용을 설명했습니다.\n\n첫 번째 부분을 읽지 않으셨나요? 이 프로젝트에 대해 간략히 설명하겠습니다. 앞으로 몇 달 동안 그리고 아마도 몇 년 동안 새로운 AI 모델 및 도구들을 실험하고 배우는 모든 것을 여러분께 보여드리겠습니다. 여러분이 게시물을 통해 제 작업의 중요한 단계를 보고, 이 지식을 여러분의 실무에 적용할 수 있게 될 것입니다.\n\n이 문서에서는 Jupyter Lab IDE를 설치하고 빠른 프로토타이핑 환경을 위한 모든 필수 도구를 설치하는 방법을 안내합니다. 한 번만 설정하면 되며, 모든 단계를 차근차근 설명해드리겠습니다. 이 설정을 마치면 제 미래 실험을 모두 따라할 수 있게 됩니다. (그래서 노력할 가치가 있습니다 :) ).\n\n예를 들어, 이 시리즈의 다음 부분에서는 \"텍스트 리뷰어 앱\"을 만드는 과정을 자세히 설명할 예정입니다:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/TIL/assets/img/2024-07-02-CreateanAIprototypingenvironmentusingJupyterLabIDEwithTypescriptLangChainjsandOllamaforrapidAIprototyping_1.png)\n\n# 내 작업 흐름과 도구\n\nAI 도구 개발을 위해 다음과 같은 작업 흐름을 사용합니다:\n\n- 빠르게 AI 도구를 프로토타입하는 데 사용되는 Typescript 및 Jupyter Lab 기반의 AI 도구 프로토타이핑 환경\n- 프로토타입의 코드를 확장하고 이를 기반으로 스토어를 생성합니다. React 앱에서는 Zustand React 스토어를 사용하고, Angular에서는 NgRx의 SignalStore를 사용하며, Jupyter Lab에서는 Zustand Vanilla 스토어를 사용합니다. 이러한 스토어 솔루션들은 많은 공통점을 가지고 있어서 동일한 선택자, 이펙트 및 업데이터 코드를 재사용할 수 있습니다.\n- Angular 또는 React 앱 또는 Nx 모노레포에서 스토어를 사용하는 스마트 컴포넌트를 구축합니다. React 앱에서는 Shadcn UI를 사용하고, Angular 앱에서는 Shadcn 기반의 spartan/ui를 사용하여 Angular 및 React 모두에서 거의 동일한 앱 아키텍처를 사용할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n제 Typescript 기반 AI 도구 프로토타이핑 환경에서 가장 중요한 도구들은 다음과 같아요:\n\n- Jupyter Lab: 웹 기반 대화형 개발 환경\n- Deno Typescript/Javascript 커널: Jupyter 노트북에서 Typescript로 Jupyter 노트북을 생성할 수 있게 해줘요\n- Ollama: 로컬로 LLMs 실행할 수 있는 도구\n- Langchain: 언어 모델을 활용한 응용 프로그램을 개발할 수 있는 프레임워크\n\n아래의 패키지 관리자를 설치하고 가장 중요한 명령어를 설명할거에요:\n\n- Chocolatey: Windows 소프트웨어 관리 솔루션, Python과 Deno를 설치하는 데 사용됩니다\n- Python 패키지 설치 관리자 (pip): Python 기반 패키지를 설치하는 데 사용되며, Jupyter Lab과 같은 Python 기반 도구 및 Chroma DB 벡터 데이터베이스와 같은 다른 Python 기반 도구를 설치하는 데 사용할 거에요\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 글의 단계를 따르면 로컬 Jupyter Lab IDE(다운로드 가능한 Jupyter 노트북)에서 \"텍스트 리뷰어 앱\" 프로토 타입을 실행하고 나의 예시를 기반으로 자신의 앱 프로토 타입을 만들 수 있게 될 거예요:\n\n![이미지](/TIL/assets/img/2024-07-02-CreateanAIprototypingenvironmentusingJupyterLabIDEwithTypescriptLangChainjsandOllamaforrapidAIprototyping_2.png)\n\n# 부가정보: 타입스크립트를 통한 Jupyter 노트북 사용의 장점은 무엇인가요?\n\n처음 실험을 시작했을 때, 간단한 Angular 앱을 만들고 실험용 AI 코드를 주 컴포넌트의 생성자에 작성하고 콘솔에 출력했습니다. 단순한 실험에는 이 방식이 잘 작동했지만, 어떤 것을 구축할 방법에 대한 명확한 계획이 있고 여러 가지 모델, 프롬프트 또는 에이전트 네트워크를 실험하고 싶지 않을 때입니다. 그러나 더 복잡한 실험의 경우, 이 간단한 방법에는 제약이 있어요:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 전체 실험 코드는 한꺼번에 모두 실행됩니다. 만약 여러 부분으로 나누어 실행하고 싶다면, UI 컨트롤이 필요하거나 코드 일부를 주석 처리/해제해야 합니다. Jupyter에서는 코드를 여러 셀로 나누고, 모든 셀 또는 일부 셀을 별도로 실행할 수 있습니다.\n- 패키지 관리: Deno에서는 이 과정이 자동으로 이루어집니다. import 문을 작성하면 Deno가 NPM 또는 Deno 패키지를 백그라운드에서 자동으로 다운로드하고 저장합니다. package.json이나 node_modules 디렉토리가 필요하지 않습니다. Deno에서 특정 버전의 패키지를 다운로드하면 모든 Jupyter 노트북에서 해당 패키지를 사용할 수 있습니다.\n- Jupyter에서는 노트북을 간단히 복사할 수 있습니다. 새로운 AI 도구를 실험할 때는 노트북을 복제하고 예를 들어 프롬프트나 모델을 변경하면 됩니다. 그러면 노트북을 병렬로 실행하고 결과를 나란히 비교할 수 있습니다.\n- Jupyter에서는 RAG(검색 보강 생성)을 사용하는 사용자 정의 에이전트가 필요한 경우 해당 추가 지식이 포함된 로컬 파일에 직접 액세스할 수 있습니다. Angular/React 앱에서도 이 작업이 가능하지만, 로컬 파일에 액세스하기 위해 서버와 같은 것이 필요하여 조금 더 어려울 수 있습니다.\n- Jupyter/Deno로 생성하는 TypeScript 코드는 휴대성이 좋습니다. 프론트엔드 프로젝트에서 사용할 수 있을 뿐만 아니라 백엔드에서도 코드를 사용할 수 있습니다. 실험 목적으로는 Jupyter와 Deno가 완벽한 반면, 프로토타입 단계에서는 Angular 또는 React 앱을 생성해야 합니다. 이러한 프로토타입은 단일 사용자 또는 작은 팀의 작업을 효과적으로 지원할 수 있습니다. 그러나 프로토타입을 실제 서비스로 전환하려면 리소스와 비용을 관리하기 위해 코드 일부를 백엔드로 이동해야 합니다(API 액세스와 요금 등).\n- 마지막으로, 내가 생각하기에 Jupyter 노트북을 사용하는 가장 큰 장점은 상호 작용적인 기사를 가지고 있는 것입니다. 코드 자체, 코드의 출력 및 설명(Markdown으로)이 한 곳에 모여 있어 ML/AI 개념을 다른 개발자들에게 전달하기에 완벽합니다.\n\n이제 우리의 빠른 프로토타이핑 환경 구축을 시작해봅시다! 기억하세요, 이 설정은 한 번만 해주시면 됩니다 :)\n\n# 설정: Chocolatey\n\n# Chocolatey CLI 설치 (Windows)\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n앞서 말씀드린대로 Chocolatey는 Windows용 소프트웨어 관리 솔루션으로, Python 및 Deno를 설치하는 데 사용됩니다. Jupyter Lab IDE를 설치하고 실행하기 위해 Python이 필요하며, Deno는 Jupyter Lab를 위한 Typescript 언어 지원을 제공합니다.\n\n만약 리눅스를 사용 중이라면 이러한 단계를 건너뛰고 Python 및 Deno를 설치하는 \"리눅스에서\" 섹션으로 이동하십시오.\n\nChocolatey를 설치하려면 다음 명령을 관리자 권한으로 실행하십시오(출처):\n\n```js\n@\"%SystemRoot%\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\" -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command \"[System.Net.ServicePointManager]::SecurityProtocol = 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))\" \u0026\u0026 SET \"PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin\"\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 명령은 원격 설치1.ps 스크립트를 다운로드하여 컴퓨터에서 실행하므로 실행하기 전에 안전을 확인하려면 내용을 확인해야합니다.\n\n관련 기사: Chocolatey 문서: Chocolatey CLI 설치\n\n# 가장 중요한 Chocolatey CLI 명령어\n\n- choco list -localonly: 로컬로 설치된 패키지를 나열합니다.\n- choco install PackageName: 패키지를 설치합니다 (Community Package Repository에서 사용 가능한 패키지를 검색할 수 있습니다).\n- choco upgrade PackageName: 패키지를 업그레이드합니다.\n- choco uninstall PackageName: 패키지를 제거합니다.\n- choco outdated: 새로운 버전이 있는 로컬로 설치된 패키지를 나열합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 설정: Python 및 Deno 설치\n\n# Windows\n\n관리자 권한으로 실행된 명령 프롬프트에서 Python을 설치하려면 choco install python를 실행하세요. 그런 다음 refreshenv 명령을 실행하여 PATH 및 기타 환경 변수를 새로 고쳐주세요. 이제 python --version을 실행하면 Python의 버전이 표시됩니다.\n\nPython 패키지 관리자(pip) 버전을 업그레이드하려면 python -m pip install -U pip을 실행하세요.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음으로 Deno Typescript Kernel을 설치하세요:\n\n```js\nchoco install deno\n```\n\n# 리눅스에서\n\n리눅스에서는 배포판의 패키지 관리자를 사용하여 Python을 설치할 수 있습니다. 그런 다음 python -m pip install -U pip 명령을 사용하여 Python 패키지 관리자(pip)를 업그레이드할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그럼 Deno Typescript Kernel과 Pnpm 패키지 관리자를 설치하세요:\n\n```js\ncurl -fsSL https://deno.land/install.sh | sh\n```\n\n이 원격 스크립트 파일의 내용을 실행하기 전에 안전을 확인해야 합니다.\n\n관련 기사:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Deno 설치\n\n# Python 가상 환경(venv) 생성\n\n이후부터는 Windows와 Linux에서 설치 단계가 매우 유사합니다. 홈 디렉토리로 C:\\Users\\YourUser\\ 대신 /home/YourUser/를 사용해주세요.\n\n가상 환경은 설치된 패키지 집합을 포함합니다. 컴퓨터의 각 Python 기반 프로젝트를 위해 별도의 가상 환경을 만드는 것을 권장합니다. 따라서 JupyterLab과 Deno를 위한 새 가상 환경을 만듭니다. 나중에 추가적인 가상 환경을 생성할 수도 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n명령 프롬프트(관리자 권한 없는 상태에서)를 열고 가상 환경을 위한 새 디렉토리를 만들어주세요: mkdir C:\\Users\\YourUser\\venv. 그리고 다음 명령어로 새 가상 환경을 생성해주세요: python -m venv C:\\Users\\YourUser\\venv\\jupyter-deno\n\n가상 환경을 활성화한 후 C:\\Users\\YourUser\\venv\\jupyter-deno\\Scripts\\activate 명령어로 패키지를 설치하기 전에 활성화해야 합니다. 이 스크립트를 실행한 후 프롬프트가 (jupyter-deno) C:\\로 변경됩니다.\n\n관련 문서: Python 문서: 가상 환경 만들기\n\n# 가장 중요한 Python 패키지 관리자 (pip) 명령어\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- pip list: 현재 설치된 패키지 목록을 확인합니다.\n- pip install PackageName: 패키지를 설치합니다 (Python Package Index에서 사용 가능한 패키지를 확인할 수 있습니다).\n- pip install --upgrade PackageName: 패키지를 업그레이드합니다.\n- pip uninstall PackageName: 패키지를 제거합니다.\n- pip list --outdated: 최신 버전이 있는 현재 설치된 패키지 목록을 확인합니다.\n\n# 설정: Deno 커널을 사용한 JupyterLab 설치\n\n활성화된 환경 안에서 Jupyter Lab를 설치합니다: pip install jupyterlab. 그 후, deno jupyter --unstable --install 명령을 사용하여 Jupyter에 Deno 커널을 추가합니다.\n\nJupyter Lab에서는 기본적으로 숨김 파일을 표시하지 않습니다. 예를 들어, Jupyter Lab에서 .env 파일을 볼 수 없습니다. OpenAI의 API 키와 같은 정보를 .env 파일에 저장할 수 있습니다. 이러한 파일을 Jupyter Lab의 파일 관리자에서 표시하려면 다음 명령으로 새 Jupyter 구성 파일을 생성해야 합니다:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nmkdir C:\\Users\\YourUser\\.jupyter\ncd C:\\Users\\YourUser\\.jupyter\njupyter server --generate-config\n```\n\n마지막 명령어는 C:\\Users\\YourUser\\.jupyter\\jupyter_server_config.py 파일을 생성합니다. 이 파일을 열어 ContentsManager.allow_hidden = True로 설정해주세요. Jupyter Lab을 다시 시작하면 이제 뷰 메뉴의 Show Hidden Files 항목을 사용하여 Jupyter Lab에서 숨겨진 파일을 표시하거나 숨길 수 있습니다.\n\n설치 프로세스의 마지막 단계로, Jupyter 노트북을 위한 디렉토리를 만들고 Jupyter Lab을 시작해주세요:\n\n```js\nmkdir C:\\Users\\YourUser\\jupyter\ncd C:\\Users\\YourUser\\jupyter\njupyter lab\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n관련 기사:\n\n- Jupyter Notebook에 현대 JavaScript 가져오기\n- JupyterLab 문서: 숨겨진 파일 표시\n\n# 설정: Ollama 설치 및 사용\n\n# Ollama 및 모델 설치\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이전에 언급했듯이, 로컬 LLM 모델을 실행할 때 Ollama를 사용합니다.\n\nWindows용 Ollama를 여기서 다운로드하고 모델 라이브러리는 여기에서 찾을 수 있습니다. Ollama를 설치한 후에는 테스트 목적으로 좋은 codellama:7b-code 모델을 다운로드하는 것을 제안합니다: ollama pull codellama:7b-code. 이는 약 4GB의 RAM을 필요로 하는 소형 모델입니다. 저는 이 모델을 RAM이 16GB이고 듀얼 코어 CPU를 가진 오래된 노트북에서 사용하며, 수용 가능한 속도로 응답을 제공합니다. 또한 \"텍스트 리뷰어 앱\" 프로토타입에서도 이 로컬 모델을 사용합니다.\n\n# 가장 중요한 Ollama 명령어:\n\n- ollama list: 다운로드된 모델을 나열합니다.\n- ollama pull ModelName:version: LLM 모델을 다운로드합니다.\n- ollama serve: 백그라운드에서 Ollama 서버를 실행합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 로컬 모델로 첫 번째 AI 프로토 타입을 시도해보세요\n\n만약 아직 주피터 랩을 시작하지 않았다면, 가상 환경을 활성화하고 해당 가상 환경 내에서 주피터 랩을 시작하는 `jupyter lab` 명령어를 실행하세요. 브라우저에서 UI를 열 수 있습니다: http://localhost:8888/. Ollama를 실행하려면 `ollama serve`를 사용하세요.\n\n앱 프로토 타입이 포함된 노트북을 C:\\Users\\YourUser\\jupyter 디렉토리로 다운로드하세요. JupyterLab 파일 브라우저(화면의 왼쪽 패널)에서 다운로드 된 노트북을 선택한 후 \"Edit\" 메뉴에서 \"Clear Outputs of All Cells\"를 선택하여 셀에 저장된 모든 출력을 제거하고, \"Run\" 메뉴에서 \"Run all cells\" 메뉴 항목을 클릭하세요. 일부 처리 후, 비교 결과가 마지막 셀 위에 표시될 것입니다:\n\n![AI 프로토타입 환경 설정 이미지](/TIL/assets/img/2024-07-02-CreateanAIprototypingenvironmentusingJupyterLabIDEwithTypescriptLangChainjsandOllamaforrapidAIprototyping_3.png)\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 다음 단계\n\n내 기사 시리즈의 다음 부분에서는 다음을 보여 드릴 것입니다:\n\n- Jupyter Lab IDE 및 Deno Javascript/Typescript 런타임을 사용하는 방법 (노트북에서 Typescript 코드를 실행하는 방법)\n- \"Text reviewer app\" 프로토타입 (위의 스크린샷)의 작동 방법\n- LLMs 및 LangChain.js의 기본 개념 (LangChain은 다양한 LLM 모델 및 제공자 API 사이를 쉽게 전환할 수 있도록 지원하며, OpenAI 플랫폼 API 또는 로컬 Ollama API와 같은 API를 사용할 수 있게 합니다.)\n- 프로토타입을 기반으로 한 \"Text reviewer app\"의 상태 및 저장소 생성 방법, 그리고 코드 생성을 위해 AI 사용하는 방법\n- 위에서 언급한 저장소를 사용하는 React 및 Angular 앱을 만드는 방법\n\n# 요약\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 작은 튜토리얼을 완료한 것을 축하해요! 알겠지만, 지금까지 따라온 것 중에 가장 흥미로운 과정은 아니었을 거야. 하지만 신뢰해줘, 이제 AI 도구를 구축해보며 실험할 수 있는 강력한 프로토타이핑 환경을 갖게 됐어. 거기에 이는 대단한 식사를 위한 모든 재료를 얻는 것과 같아 (동시에 주방도 짓는 느낌이지 :D). 다음 글에서 요리를 시작할 텐데, 즐거운 파트를 기대해!\n\n다음 두 글에서, JupyterLab IDE와 Deno Javascript / Typescript 런타임을 사용하는 방법을 설명하고, \"텍스트 리뷰어 앱\" 프로토타입이 어떻게 작동하는지 자세히 보여줄 거야.\n\n# 👨‍💻저자 소개\n\n내 이름은 Gergely Szerovay이고, 많은 해 동안 데이터 과학자와 풀스택 개발자로 일했어. 최근에는 Angular 기반 프론트엔드 개발에 중점을 둔 프론트엔드 테크 리드로 일하고 있어. 나의 역할의 일환으로, Angular 및 프론트엔드 개발 분야가 어떻게 진화하고 있는지를 지속적으로 추적하고 있어.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지난 몇 년 동안 Angular은 매우 빠르게 발전해 왔고, 작년에는 AI 활용이 늘어나면서 소프트웨어 개발 워크플로우도 빠르게 진화했습니다. AI 지원 소프트웨어 개발의 진화를 밀접히 따라가기 위해, 저는 공개적으로 AI 도구를 개발하기로 결심했고, 진행 상황을 AIBoosted.dev에서 공개할 것입니다. 여기 구독하기 🚀\n\nAngular 및 AI, Typescript, React, Angular와 함께 AI 앱을 구축하는 방법에 대해 더 알아보려면 Substack (Angular Addicts), Substack (AIBoosted.dev), Medium, Dev.to, X 또는 LinkedIn에서 제 팔로우 해주세요!\n","ogImage":{"url":"/TIL/assets/img/2024-07-02-CreateanAIprototypingenvironmentusingJupyterLabIDEwithTypescriptLangChainjsandOllamaforrapidAIprototyping_0.png"},"coverImage":"/TIL/assets/img/2024-07-02-CreateanAIprototypingenvironmentusingJupyterLabIDEwithTypescriptLangChainjsandOllamaforrapidAIprototyping_0.png","tag":["Tech"],"readingTime":16},{"title":"AI와 함께하는 프로그래밍  Vision LLMs 사용법","description":"","date":"2024-07-02 21:44","slug":"2024-07-02-ProgrammingwithAIVisionLLMs","content":"\r\n이건 저의 AI 수업을 위해 준비한 자료의 마지막 부분 (4/4)입니다. 처음 3부분은 아래에 있어요.\r\n","ogImage":{"url":"/TIL/assets/img/2024-07-02-ProgrammingwithAIVisionLLMs_0.png"},"coverImage":"/TIL/assets/img/2024-07-02-ProgrammingwithAIVisionLLMs_0.png","tag":["Tech"],"readingTime":1},{"title":"Python으로 삼체 문제를 시각적으로 시뮬레이션하는 방법","description":"","date":"2024-07-02 21:44","slug":"2024-07-02-VisuallySimulatingtheThree-BodyProblemonPython","content":"\r\n물리학에서, 세 개체 문제는 서로에게 인력을 끼치는 영향 아래 세 질량의 움직임을 예측하는 고전 역학의 유명한 문제입니다.\r\n\r\n세 개체 문제를 악명 높게 만드는 것은 그 혼돈스러운 성격 때문에 해결하기 어렵다는 점입니다. 함께 말씀드리고 싶은 게 있습니다...\r\n","ogImage":{"url":"/TIL/assets/img/2024-07-02-VisuallySimulatingtheThree-BodyProblemonPython_0.png"},"coverImage":"/TIL/assets/img/2024-07-02-VisuallySimulatingtheThree-BodyProblemonPython_0.png","tag":["Tech"],"readingTime":1},{"title":"Pydantic Settings로 Python 설정 완벽하게 하기 위한 방법","description":"","date":"2024-07-02 21:43","slug":"2024-07-02-GetYourPythonConfigurationsRightEveryTimewithPydanticSettings","content":"\n# 소개\n\n진지한 Python 애플리케이션을 개발할 때는 종종 애플리케이션이 실행되는 위치에 따라 변경될 수 있는 구성 매개변수가 필요합니다. 환경 변수는 애플리케이션 코드를 변경하지 않고 설정을 조정할 수 있는 훌륭한 방법입니다. 환경 변수를 조정하기만 하면 되기 때문에 다시 빌드할 필요가 없습니다.\n\n그러나 환경 변수를 사용하는 것은 자체적인 일련의 도전 과제를 수반합니다. 이러한 변수가 유효하고 일관성 있게 유지되도록 보장해야 하며 그렇지 않으면 실행 중에 애플리케이션 실행에 실패할 위험이 있습니다. 일반적으로 이 값들을 유효성 검사하기 위해 사용자 정의 코드를 작성해야 하는데, 이는 지루하고 실수를 유발할 수 있습니다. 가끔은 개발자들이 유효성 검사를 건너뛰고 최선을 다하길 희망하기도 하는데, 이는 재앙을 불러올 수 있는 결과입니다.\n\nPydantic Settings를 소개합니다 — Python 애플리케이션에서 구성 관리를 간편화하는 훌륭한 도구입니다. Pydantic Settings를 사용하면 Pydantic의 데이터 유효성 확인 기능을 활용하여 환경 변수를 읽고 검증할 수 있습니다. 이를 통해 애플리케이션이 항상 올바른 구성을 얻게 되어 실행 중 오류의 위험을 줄이고 개발자로서의 생활을 훨씬 쉽게 만들어 줍니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 문제 설명\n\n구성 관리는 소프트웨어 개발의 중요한 측면입니다. 애플리케이션은 종종 데이터베이스 연결, API 키 및 기타 환경별 변수에 대한 설정이 필요합니다. 이러한 설정은 특히 다른 환경(개발, 테스트, 프로덕션)에 애플리케이션을 배포할 때 안전하고 효율적으로 관리되어야 합니다.\n\n응용 프로그램 내에서 이러한 설정을 하드코딩하는 것은 안전 취약점을 유발할 수 있고 다중 환경에서 설정을 관리하기 어렵게 만들 수 있기 때문에 이상적이지 않습니다. 여기서 Pydantic Settings이 등장하여 구성을 처리할 구조화된 안전한 방법을 제공합니다.\n\n## 예시 — .env와 함께\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nPydantic Settings은 환경 변수 또는 .env 파일에서 구성을 로드하는 과정을 쉽게 만들어줍니다. 이 작업이 어떻게 이루어지는지 예시를 살펴보도록 하겠습니다.\n\n먼저 Pydantic을 설치해야 합니다:\n\n```js\npip install pydantic_settings\n```\n\n다음으로 프로젝트 디렉토리에 다음 내용을 가진 .env 파일을 만들어주세요:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nDATABASE_URL=postgresql://user:password@localhost:5432/mydatabase\nAPI_KEY=your_api_key_here\nDEBUG=True\n```\n\n이제 Pydantic을 사용하여 설정 모델을 정의하는 settings.py 파일을 생성해봅시다:\n\n```js\nfrom pydantic_settings import BaseSettings\n\nclass Settings(BaseSettings):\n    database_url: str\n    api_key: str\n    debug: bool\n\n    class Config:\n        env_file = \".env\"\n\nsettings = Settings()\n```\n\nSettings 클래스를 통해 database_url, api_key, debug와 같은 예상 구성 변수를 정의합니다. Settings 내부에 중첩된 Config 클래스는 이러한 변수가 .env 파일에서 로드되어야 함을 지정합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\n환경 설정에서 settings 모듈을 불러와주세요.\n\n다음은 settings 모듈 값을 출력한 것입니다:\n- 데이터베이스 URL: postgresql://user:password@localhost:5432/mydatabase\n- API 키: your_api_key_here\n- 디버그 모드: True\n\n만약 .env 파일에서 디버그 값을 불리언(Boolean)이 아닌 다른 값으로 설정하면, 위 코드는 유효성 오류를 발생시킬 것입니다.\n\n예를 들어, .env 파일에서 DEBUG 값을 xyz로 변경한 후 프로그램을 다시 실행하면 다음과 같습니다:\n\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러면 이와 같은 오류가 발생합니다:\n\n```js\npydantic_core._pydantic_core.ValidationError: Settings에 대한 1개의 유효성 검사 오류\ndebug\n  입력은 유효한 부울(boolean)이어야 하며, 입력값 [type=bool_parsing, input_value='xyz', input_type=str]을 해석할 수 없습니다.\n    자세한 정보는 https://errors.pydantic.dev/2.7/v/bool_parsing 를 참조해주세요.\n```\n\n그리하여 데이터 유효성 검사를 무료로 받을 수 있습니다. 이를 통해 pydantic BaseModel로 수행할 수 있는 모든 검사를 수행할 수 있습니다.\n\n중첩된 예제\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n설정을 중첩 모델로 관리할 수도 있습니다. 예를 살펴보세요. .env 파일을 정의하는 방법과 Settings 모델이 최종 구성을 생성하기 위해 다른 모델들을 사용하는 것을 주목해주세요. 멋지죠!\n\n```js\n# 당신의 .env 파일\nV0=0\nSUB_MODEL='{\"v1\": \"json-1\", \"v2\": \"json-2\"}'\nSUB_MODEL__V2=nested-2\nSUB_MODEL__V3=3\nSUB_MODEL__DEEP__V4=v4\n```\n\n```js\nfrom pydantic import BaseModel\n\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass DeepSubModel(BaseModel):\n    v4: str\n\n\nclass SubModel(BaseModel):\n    v1: str\n    v2: bytes\n    v3: int\n    deep: DeepSubModel # .env will have __DEEP__ to pass configs to DeepSubModel\n\n\nclass Settings(BaseSettings):\n    v0: str\n    sub_model: SubModel\n\n    class Config(SettingsConfigDict):\n        env_nested_delimiter = \"__\"\n\n\nprint(Settings().model_dump())\n\"\"\"\n{\n    'v0': '0',\n    'sub_model': {'v1': 'json-1', 'v2': b'nested-2', 'v3': 3, 'deep': {'v4': 'v4'},\n}\n\"\"\"\n```\n\n중첩 접근 방식을 사용하면 애플리케이션 구성 및 유효성 검사 논리를 보다 쉽게 분리할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론\n\n중첩 구성을 사용하여 Pydantic 설정을 활용하면 애플리케이션 설정을 더 효과적으로 구성할 수 있습니다. 이 구조는 애플리케이션이 성장함에 따라 설정을 관리하고 유지하는 것이 더 쉬워집니다. Pydantic의 강력함을 활용하면 타입 안전성과 기본 유효성 검사를 제공받아 구성 오류의 위험을 줄일 수 있습니다.\n\n파이썬 애플리케이션을 간소화하고 싶나요? 저희에게 https://kubeops.consulting/에서 연락해보세요. 저희 팀은 파이썬 애플리케이션을 작성하고 확장하는 데 특화되어 있습니다.\n","ogImage":{"url":"/TIL/assets/img/2024-07-02-GetYourPythonConfigurationsRightEveryTimewithPydanticSettings_0.png"},"coverImage":"/TIL/assets/img/2024-07-02-GetYourPythonConfigurationsRightEveryTimewithPydanticSettings_0.png","tag":["Tech"],"readingTime":6}],"page":"34","totalPageCount":34,"totalPageGroupCount":2,"lastPageGroup":14,"currentPageGroup":1},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"34"},"buildId":"xx51Gh_JNHDTBdDwrgykD","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>