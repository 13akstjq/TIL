<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>TIL</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//posts/7" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="TIL" data-gatsby-head="true"/><meta property="og:title" content="TIL" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//posts/7" data-gatsby-head="true"/><meta name="twitter:title" content="TIL" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/7978fe7362f7d4c9.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/7978fe7362f7d4c9.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/TIL/_next/static/chunks/463-925361deb4cec4b1.js" defer=""></script><script src="/TIL/_next/static/chunks/873-2eda6d845ad1e69e.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/posts/%5Bpage%5D-350e448526ad5efa.js" defer=""></script><script src="/TIL/_next/static/QAkYP0lvl03W-5CKD69kb/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/QAkYP0lvl03W-5CKD69kb/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Pytorch에서 텐서 고급 선택 방법" href="/TIL/post/2024-07-12-AdvancedSelectionfromTensorsinPytorch"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Pytorch에서 텐서 고급 선택 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-12-AdvancedSelectionfromTensorsinPytorch_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Pytorch에서 텐서 고급 선택 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Pytorch에서 텐서 고급 선택 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 12, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="2024년에 AI 엔지니어링을 시작한다면 이렇게 하세요" href="/TIL/post/2024-07-12-IfIstartedlearningAIEngineeringin2024hereswhatIwoulddo"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="2024년에 AI 엔지니어링을 시작한다면 이렇게 하세요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-12-IfIstartedlearningAIEngineeringin2024hereswhatIwoulddo_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="2024년에 AI 엔지니어링을 시작한다면 이렇게 하세요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">2024년에 AI 엔지니어링을 시작한다면 이렇게 하세요</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 12, 2024</span><span class="PostList_reading_time__6CBMQ">16<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="대수학자처럼 사고하는 법" href="/TIL/post/2024-07-12-HowToThinkLikeAnAlgebraist"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="대수학자처럼 사고하는 법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-12-HowToThinkLikeAnAlgebraist_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="대수학자처럼 사고하는 법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">대수학자처럼 사고하는 법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 12, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Python으로 웹사이트에서 데이터를 쉽게 추출하는 방법" href="/TIL/post/2024-07-12-HowToEasilyExtractDataFromAWebsiteWithPython"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Python으로 웹사이트에서 데이터를 쉽게 추출하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-12-HowToEasilyExtractDataFromAWebsiteWithPython_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Python으로 웹사이트에서 데이터를 쉽게 추출하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Python으로 웹사이트에서 데이터를 쉽게 추출하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 12, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Apache Iceberg PySpark로 데이터 웨어하우스를 만드는 4가지 방법" href="/TIL/post/2024-07-12-ApacheIceberg4MethodsToCreateAWarehouseWithPySpark"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Apache Iceberg PySpark로 데이터 웨어하우스를 만드는 4가지 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-12-ApacheIceberg4MethodsToCreateAWarehouseWithPySpark_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Apache Iceberg PySpark로 데이터 웨어하우스를 만드는 4가지 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Apache Iceberg PySpark로 데이터 웨어하우스를 만드는 4가지 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 12, 2024</span><span class="PostList_reading_time__6CBMQ">26<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Python 동시성 프로그래밍 Futures 사용법" href="/TIL/post/2024-07-12-PythonConcurrencyProgrammingFutures"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Python 동시성 프로그래밍 Futures 사용법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-12-PythonConcurrencyProgrammingFutures_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Python 동시성 프로그래밍 Futures 사용법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Python 동시성 프로그래밍 Futures 사용법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 12, 2024</span><span class="PostList_reading_time__6CBMQ">17<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="스태킹 앙상블 기법 이해하고 활용하는 방법" href="/TIL/post/2024-07-12-TheStackingEnsembleMethod"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="스태킹 앙상블 기법 이해하고 활용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-12-TheStackingEnsembleMethod_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="스태킹 앙상블 기법 이해하고 활용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">스태킹 앙상블 기법 이해하고 활용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 12, 2024</span><span class="PostList_reading_time__6CBMQ">19<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="PyTorch 입문  커스텀 데이터 사용 방법" href="/TIL/post/2024-07-12-PyTorchIntroductionUsingCustomData"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="PyTorch 입문  커스텀 데이터 사용 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="PyTorch 입문  커스텀 데이터 사용 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">PyTorch 입문  커스텀 데이터 사용 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 12, 2024</span><span class="PostList_reading_time__6CBMQ">19<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="완전 무료 강좌 Python과 데이터 엔지니어링 완벽 가이드" href="/TIL/post/2024-07-12-CompleteFreeCourseonPythonandDataEngineering"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="완전 무료 강좌 Python과 데이터 엔지니어링 완벽 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-12-CompleteFreeCourseonPythonandDataEngineering_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="완전 무료 강좌 Python과 데이터 엔지니어링 완벽 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">완전 무료 강좌 Python과 데이터 엔지니어링 완벽 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 12, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Python으로 WhatsApp에서 AI를 사용하여 자신 복제하는 방법" href="/TIL/post/2024-07-12-CloningYourselfonWhatsAppwithAIinPython"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Python으로 WhatsApp에서 AI를 사용하여 자신 복제하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-12-CloningYourselfonWhatsAppwithAIinPython_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Python으로 WhatsApp에서 AI를 사용하여 자신 복제하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Python으로 WhatsApp에서 AI를 사용하여 자신 복제하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 12, 2024</span><span class="PostList_reading_time__6CBMQ">30<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/TIL/posts/1">1</a><a class="link" href="/TIL/posts/2">2</a><a class="link" href="/TIL/posts/3">3</a><a class="link" href="/TIL/posts/4">4</a><a class="link" href="/TIL/posts/5">5</a><a class="link" href="/TIL/posts/6">6</a><a class="link posts_-active__YVJEi" href="/TIL/posts/7">7</a><a class="link" href="/TIL/posts/8">8</a><a class="link" href="/TIL/posts/9">9</a><a class="link" href="/TIL/posts/10">10</a><a class="link" href="/TIL/posts/11">11</a><a class="link" href="/TIL/posts/12">12</a><a class="link" href="/TIL/posts/13">13</a><a class="link" href="/TIL/posts/14">14</a><a class="link" href="/TIL/posts/15">15</a><a class="link" href="/TIL/posts/16">16</a><a class="link" href="/TIL/posts/17">17</a><a class="link" href="/TIL/posts/18">18</a><a class="link" href="/TIL/posts/19">19</a><a class="link" href="/TIL/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Pytorch에서 텐서 고급 선택 방법","description":"","date":"2024-07-12 20:32","slug":"2024-07-12-AdvancedSelectionfromTensorsinPytorch","content":"\n\n가끔은 파이토치(Pytorch)로 고급 색인 및 선택을 해야 할 때가 있습니다. 예를 들어 \"텐서 A에서 텐서 B에 지정된 색인을 따라 요소를 선택하는 방법\"과 같은 질문에 답변할 수 있습니다.\n\n이 게시물에서는 이러한 작업을 수행하는 가장 일반적인 세 가지 방법인 torch.index_select, torch.gather 및 torch.take를 소개합니다. 우리는 이러한 방법을 자세히 설명하고 서로 비교합니다.\n\n![이미지](/TIL/assets/img/2024-07-12-AdvancedSelectionfromTensorsinPytorch_0.png)\n\n솔직히 말해서, 이 게시물의 동기 중 하나는 어떤 기능을 언제 사용해야 하는지를 잊어버려 구글링하거나 스택 오버플로우를 찾아보거나, 내 의견으로는 비교적 간단하고 그리 도움이 되지 않는 공식 설명서를 보는 것 때문입니다. 그래서 여기에서는 언급한 바와 같이 이러한 기능에 대해 심층적으로 알아보겠습니다: 언제 어떻게 사용해야 하는지 동기부여를 해주고, 2D 및 3D에서 예제를 제공하며, 결과적으로 선택된 요소를 그래픽으로 표시할 것입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 게시물이 해당 기능에 대한 명확성을 가져다 주고 추가 탐구가 필요 없도록 도와줄 것을 희망합니다 — 읽어 주셔서 감사합니다!\n\n그리고 이제, 더 이상 어색함 없이 함수를 하나하나 살펴보겠습니다. 먼저, 모든 것을 2D 예제로 시작하여 결과 선택을 시각화한 후, 3D에서 조금 더 복잡한 예제로 넘어갑니다. 그 이후에는 간단한 파이썬에서 실행된 작업을 재구현합니다 — 이를 통해 이러한 함수가 무엇을 하는지에 대한 다른 정보원인 유사한 의사코드를 참고할 수 있게 됩니다. 마지막으로, 함수들과 해당 차이점들을 표로 요약합니다.\n\n# torch.index_select\n\ntorch.index_select는 한 차원을 따라 요소를 선택하는 동시에 다른 차원을 유지합니다. 다시 말해, 다른 모든 차원의 모든 요소를 유지한 채 목표 차원에서 인덱스 텐서를 따라 요소를 선택합니다. 우리는 2D 예제로 이를 보여줍니다. 여기서는 1차원을 따라 선택하겠습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nnum_picks = 2\n\nvalues = torch.rand((len_dim_0, len_dim_1))\nindices = torch.randint(0, len_dim_1, size=(num_picks,))\n# [len_dim_0, num_picks]\npicked = torch.index_select(values, 1, indices)\n```\n\n그 결과 텐서는 형태 [len_dim_0, num_picks]를 가집니다: 차원 0을 따라 각 요소에 대해 차원 1에서 동일한 요소를 선택했습니다. 이를 시각화해 봅시다:\n\n![image](/TIL/assets/img/2024-07-12-AdvancedSelectionfromTensorsinPytorch_1.png)\n\n이제 세 가지 차원으로 이동합니다. 이것은 기계 학습 / 데이터 과학의 세계에 더 가까워지며, 형상이 [batch_size, num_elements, num_features]인 텐서를 상상해 보겠습니다. num_elements 요소가 있고 num_feature 특징이 있으며 모든 것이 배치 처리됩니다. torch.index_select를 사용하여 모든 배치 / 특징 조합에 대해 동일한 요소를 선택할 수 있습니다:\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport torch\n\nbatch_size = 16\nnum_elements = 64\nnum_features = 1024\nnum_picks = 2\n\nvalues = torch.rand((batch_size, num_elements, num_features))\nindices = torch.randint(0, num_elements, size=(num_picks,))\n# [batch_size, num_picks, num_features]\npicked = torch.index_select(values, 1, indices)\n```\n\n어떤 사람들은 index_select가 하는 일을 코드 형태로 이해하는 것을 선호할 수 있습니다. 따라서, 간단한 for 루프를 사용하여 이 함수를 다시 구현할 수 있는 방법을 설명해 드리겠습니다:\n\n```js\npicked_manual = torch.zeros_like(picked)\nfor i in range(batch_size):\n    for j in range(num_picks):\n        for k in range(num_features):\n            picked_manual[i, j, k] = values[i, indices[j], k]\n\nassert torch.all(torch.eq(picked, picked_manual))\n```\n\n# torch.gather\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음으로 torch.gather로 이동해 보겠습니다. gather는 index_select와 유사하게 작동하지만 이제 원하는 차원에서 요소 선택이 다른 차원에 따라 종속적입니다. 다시 말해 우리의 머신러닝 예제를 재사용하는 것입니다: 매 batch 인덱스마다, 그리고 매 feature마다, \"element\" 차원에서 다른 요소를 선택할 수 있습니다. 하나의 텐서에서 다른 텐서의 인덱스를 따르면서 요소를 선택합니다.\n\nML 프로젝트를 진행하면서 이런 사용 사례를 자주 만나게 되었는데, 하나의 구체적인 예시는 어떤 조건에 따라 트리에서 노드를 선택하고, 각 노드가 일부 feature로 지정된다고 할 때, 배치 차원에 선택할 요소를 넣는 인덱스 선택 행렬을 생성하고 해당 값을 feature 차원을 따라 반복하는 것입니다. 즉, 각 batch 인덱스마다 조건에 따라 다른 요소를 선택할 수 있으며, 우리의 예시에서 이 조건은 배치 인덱스에만 의존하지만 feature 인덱스에도 의존할 수 있습니다.\n\n하지만 먼저, 2D 예제로 다시 시작해 보겠습니다:\n\n```js\nnum_picks = 2\n\nvalues = torch.rand((len_dim_0, len_dim_1))\nindices = torch.randint(0, len_dim_1, size=(len_dim_0, num_picks))\n# [len_dim_0, num_picks]\npicked = torch.gather(values, 1, indices)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이를 시각화할 때, 우리는 이제 선택이 직선으로 특징지어지지 않고, 차원 0의 각 인덱스마다 차원 1의 다른 요소가 선택된다는 것을 관찰할 수 있습니다:\n\n![image](/TIL/assets/img/2024-07-12-AdvancedSelectionfromTensorsinPytorch_2.png)\n\n이를 바탕으로 세 가지 차원으로 이동하고, 또한 Python 코드를 통해 이 선택을 다시 구현해보겠습니다:\n\n```python\nimport torch\n\nbatch_size = 16\nnum_elements = 64\nnum_features = 1024\nnum_picks = 5\nvalues = torch.rand((batch_size, num_elements, num_features))\nindices = torch.randint(0, num_elements, size=(batch_size, num_picks, num_features))\npicked = torch.gather(values, 1, indices)\n\npicked_manual = torch.zeros_like(picked)\nfor i in range(batch_size):\n    for j in range(num_picks):\n        for k in range(num_features):\n            picked_manual[i, j, k] = values[i, indices[i, j, k], k]\n\nassert torch.all(torch.eq(picked, picked_manual))\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## torch.take\n\ntorch.take는 소개된 세 가지 기능 중 가장 이해하기 쉬운 것일 수 있습니다. 이 함수는 입력 텐서를 평평하게 취급하고 이 목록에서 요소를 선택합니다. 예를 들어, 입력 텐서의 모양이 [4, 5]이고 인덱스 6과 19를 선택할 때, 우리는 평평한 텐서의 6번째와 19번째 요소를 얻습니다. 즉, 제 2행의 2번째 요소와 맨 마지막 요소를 의미합니다.\n\n2D 예시:\n\n```js\nnum_picks = 2\n\nvalues = torch.rand((len_dim_0, len_dim_1))\nindices = torch.randint(0, len_dim_0 * len_dim_1, size=(num_picks,))\n# [num_picks]\npicked = torch.take(values, indices)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래에서 볼 수 있듯이, 우리는 이제 두 개의 요소만 얻게 되었습니다:\n\n![image](/TIL/assets/img/2024-07-12-AdvancedSelectionfromTensorsinPytorch_3.png)\n\n다음은 3D 선택 후 재구현입니다. 인덱스 텐서는 이제 임의의 모양을 가질 수 있으며, 결과 선택은 이 모양으로 제공됩니다:\n\n```python\nimport torch\n\nbatch_size = 16\nnum_elements = 64\nnum_features = 1024\nnum_picks = (2, 5, 3)\n\nvalues = torch.rand((batch_size, num_elements, num_features))\nindices = torch.randint(0, batch_size * num_elements * num_features, size=num_picks)\n# [2, 5, 3]\npicked = torch.take(values, indices)\n\npicked_manual = torch.zeros(num_picks)\nfor i in range(num_picks[0]):\n    for j in range(num_picks[1]):\n        for k in range(num_picks[2]):\n            picked_manual[i, j, k] = values.flatten()[indices[i, j, k]]\n\nassert torch.all(torch.eq(picked, picked_manual))\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론\n\n이 게시물에서는 Pytorch에서 세 가지 일반적인 선택 방법인 torch.index_select, torch.gather 및 torch.take을 살펴보았습니다. 이러한 방법을 사용하면 조건에 따라 텐서에서 요소를 선택하거나 색인 할 수 있습니다. 모든 경우에 우리는 간단한 2D 예제로 시작하여 결과 선택을 시각적으로 표현했습니다. 그런 다음, 어느 정도 더 복잡하고 현실적인 3D 시나리오로 이동했습니다. 이 시나리오에서는 [batch_size, num_elements, num_features] 모양의 텐서에서 선택해야 하는 경우가 있습니다. 이는 모든 ML 프로젝트에서 일반적으로 발생할 수 있는 사용 사례입니다.\n\n이 게시물을 마무리하면 이러한 함수들 간의 차이점을 테이블로 요약하고 싶습니다. 이 테이블은 간단한 설명 및 샘플 모양을 포함하며, 샘플 모양은 이전에 언급한 3D ML 예제에 맞게 조정되어 있습니다. 색인 텐서의 필요한 모양과 결과적으로 출력될 모양을 나열할 것입니다:\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-AdvancedSelectionfromTensorsinPytorch_4.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n읽어 주셔서 감사합니다!","ogImage":{"url":"/TIL/assets/img/2024-07-12-AdvancedSelectionfromTensorsinPytorch_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-AdvancedSelectionfromTensorsinPytorch_0.png","tag":["Tech"],"readingTime":9},{"title":"2024년에 AI 엔지니어링을 시작한다면 이렇게 하세요","description":"","date":"2024-07-12 20:30","slug":"2024-07-12-IfIstartedlearningAIEngineeringin2024hereswhatIwoulddo","content":"\n\n여러분, 안녕하세요!\n\n위의 표를 다음과 같이 Markdown 형식으로 변경해 보겠습니다.\n\n\n| 파일이름                                                     |                                                                            |\n| ------------------------------------------------------------ | -------------------------------------------------------------------------- |\n| 2024-07-12-IfIstartedlearningAIEngineeringin2024hereswhatIwoulddo_0.png |                                                                            |\n\n2023년 5월, 나는 결심했어요. AI를 배우기 위해 시간을 투자하기로 결정했죠.\n\n저는 6개월 동안(아버지의 휴가)을 내어 AI 엔지니어링 주제에 대해 배우는 데 시간을 할애했습니다.\n\n그리고 12개월이 흘렀을 때, 프리랜서 AI 엔지니어로 일하면서 첫 유료 프로젝트를 수행했어요.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAI 엔지니어를 꿈꾸는 여러분을 위해 글을 쓰고 있어요. 제가 경험한 레슨, 실수, 경험을 공유할 거예요. 왜냐하면...\n\n여러분이 오늘 제가 있는 곳에 빠르게 도달하기를 원하기 때문이에요.\n\n이 글을 마치고 나면 여러분은 다음을 알게 될 거예요:\n\n- 무엇을 배워야 하는지\n- 왜 그것을 배워야 하는지\n- 어떻게 빠르게 배울지\n- 학습의 혜택을 최대화하는 방법\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저작권 표시. 12개월 전에는 처음부터 시작하지 않았어요. 2019년에 기계 학습과 자연어 처리를 탐험하기 시작했어요. 또한 소프트웨어 엔지니어이기도 해요. 그래서 AI로 전환하기로 결정했을 때 꽤 유리한 시작점을 가지고 있었어요.\n\n# 첫 번째 AI 엔지니어링 직업 취득을 위한 7 단계\n\n제가 처음부터 AI 엔지니어링을 배우기 시작할 경우 따를 정확한 단계를 공유할게요.\n\n# 단계 1: 기본 파이썬 배우기.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAI 엔지니어들은 코딩하는 방법을 알아야 합니다.\n\n하지만 시작할 때는 몇 가지 기초적인 것만 알아도 됩니다. 예를 들면:\n✔ 반복문\n✔ 변수\n✔ 함수\n✔ 데이터 유형\n✔ 기본 구문\n✔ 기본 작업\n✔ 조건문\n✔ API 및 라이브러리 사용법\n✔ 데이터 구조:\n↳ 리스트\n↳ 튜플\n↳ 딕셔너리\n\n많은 것을 배워야 하는 것처럼 들릴 수도 있지만, 사실 그렇게 어렵지 않아요.\n\n물론, Python을 능숙하게 다룰수록 더 좋습니다.\n하지만, 처음으로 AI 프로젝트를 만드는 기초를 배우는 것이 가장 중요합니다 (프로젝트에 대해 더 자세히 알아보기는 4단계에서).\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다행히도, 제가 위에 제공한 목록만으로도 충분히 시작할 수 있어요.\n\n이 멋진 Python 자료들을 추천해 드려요:\n\n- Real Python.\n- Corey Schafer의 YT 채널.\n- Programming for Everybody (Getting Started with Python)\n\n# 단계 2️: 대형 언어 모델(LLMs) 배우기.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nLLM은 AI 프로젝트의 \"두뇌\"입니다.\nAI 엔지니어들은 LLM을 많이 사용해요! 그래서 그들이 어떻게 작동하는지 이해하는 것이 중요해요.\n\nLLM을 사용하기 시작하려면 심층적으로 파고들 필요는 없어요.\n오늘날 GPT-4, Claude 3, 그리고 Gemini이(가) 가장 강력한 LLMs입니다. 그리고 비기술자들조차도 큰 성공을 거둘 수 있어요. 그것은 그들이 프롬프트 엔지니어링을 배웠기 때문이에요(3단계에서 자세히 알아봐요).\n\n한 번 더 말하지만, 프로젝트에서 LLM을 적용하기 시작하려면 정확히 그들이 어떻게 작동하는지 알 필요가 없어요.\n\n다음 용어들을 이해해주세요:\n- 토큰\n- 문맥 창\n- 주의 메커니즘\n- 온도 (LLM에서)\n- 트랜스포머 아키텍처\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n처음으로 AI 프로젝트를 구축하는 데 필요한 기초를 제공해줄 거에요. 매 프로젝트마다 기초를 확장해나갈 거에요.\n\nLLM에 대해 배울 좋은 자료:\n\n- Andrej Karpathy의 YouTube 채널.\n- Sentdex의 YouTube 채널.\n- OpenAI Playground (실험용).\n\n# 3. 프롬프트 엔지니어링의 원리를 배우세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAI 엔지니어들은 LLM과 잘 소통하는 방법을 알고 있어요.\n\n그래서 프롬프트 엔지니어링은 그들의 일부분이에요.\n\n그렇다면, 프롬프트를 배우는 데 너무 많은 시간을 쓰지 마세요. 너무 심화되지 않도록 해요.\n\n그냥:\n- 목표를 명확히 하는 법을 배워보세요\n- 맥락을 제공하는 법을 배워보세요\n- 구체적으로 표현하는 법을 배워보세요\n- 계속해서 프롬프트를 개선해 나가세요\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저는 미래의 기술로서 '프롬프트 엔지니어링'에 대해 의심합니다. 그 이유는 간단합니다: 프롬프트는 평범한 텍스트일 뿐이기 때문입니다. 이미 LLM 및 DSPy와 같은 프레임워크로 우수한 프롬프트 작성이 자동화되고 있습니다.\n\n그래서 여기서 너무 많은 시간을 투자하지 말 것을 권합니다. 하지만 기본기는 중요합니다.\n\n필요할 때만 고급 프롬프팅을 공부하세요 (자료는 풍부합니다).\n\n여기서 프롬프트 엔지니어링을 배울 수 있습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 학습 유도 웹사이트.\n- OpenAI의 Prompt Engineering.\n- Lil’Log의 Prompt Engineering.\n\n## 4. AI 프로젝트 구축.\n\n“지식은 실행을 통해 가장 잘 활용됩니다.” Tiago Forte\nAI 프로젝트를 구축하는 것이 AI 엔지니어로 채용되는 유일한 요구 사항입니다.\n\n이론만으로는 충분하지 않습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n당신이 AI 엔지니어라고 자처하려면 AI와 코드를 사용하여 실제로 무언가를 만들 수 있다는 것을 보여주어야 해요.\n\n다행히도,  여러분은 이미 이 기사의 첫 3단계를 완료한 후 첫 번째 AI 프로젝트를 만들 준비가 되어 있어요.\n\n만약 여러분의 스타일이라면, 첫 3단계를 거치지 않고 바로 첫 번째 프로젝트에 도전해도 괜찮아요. 프로젝트를 만들며 3단계를 배울 거예요.\n\n첫 프로젝트는 간단하면서 좋아요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기서는 \"only\" 2가지 목표가 있습니다:\n\n- 처음 3단계를 결합하는 것.\n- 이론뿐만 아니라 실전에서도 배우는 것.\n\n첫 프로젝트에서는 Python, LLMs 및 프롬프트를 사용할 것입니다. 이는 처음 3단계 모든 것을 결합한다는 뜻입니다. OpenAI API나 LangChain 또는 LlamaIndex와 같은 프레임워크 덕분에 간단합니다.\n\n실습을 통해 배우는 것에 대해 이야기해 봅시다...\n“지식이 실행을 앞서가지 않도록 항상 해라.” - Dan Koe\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n착하게 번역\n\n정말로 배우는 것은 응용해야만 합니다.\n\n정말로 강조할 수가 없어요.\n\n제가 수백 시간 (수천 시간일 수도 있음)을 이론만 배우는 데 낭비했어요. 오늘날 그 중 95%를 기억하고 있지 않아요.\n\n3년 전 (34세 때)부터는 아무것도 만들지 않고는 배우지 않기로 결심했어요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n결과는?\n✔ 빠르게 배우게 됩니다.\n✔ 학습을 문서화합니다.\n✔ 거의 모든 것을 기억합니다.\n✔ 훨씬 더 깊은 이해를 얻게 됩니다.\n✔ 완료된 프로젝트 포트폴리오를 구축합니다.\n\n참고: 모든 결과를 향상시키는 추가적인 일을 하나 더합니다 (5단계에서 더 자세히 설명).\n\n그러니 제 실수를 반복하지 말아주세요.\n\n이론보다 실행에 우선순위를 두세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n프로젝트로 돌아가려고 합니다. 첫 번째로 권장하는 것은 ChatGPT \"복제본\"을 만드는 것입니다.\n\n복제본을 만들기 위해 필요한 것:\n✔ Python\n✔ OpenAI API\n✔ Streamlit(GUI용)\n✔ 약 40줄의 코드\n\n가능해 보이나요?\n\n이 프로젝트는 놀라운 것이 아닐 것입니다. 하지만 아래와 같은 이점이 있을 거예요:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- \"Creator mode\"으로 전환하겠습니다.\n- 단계 1, 2 및 3에서 얻은 지식을 확고히 할 수 있도록 도와 드리겠습니다.\n- LLM 매개변수 및 프롬프트를 실험해 볼 수 있도록 해 드릴게요.\n\n프로젝트에 도움이 필요하면 제 글을 참고해 주세요:\n\n# 5. 공개 학습하기.\n\nAustin Kleon의 \"Show Your Work\"은 2시간 정도의 읽을 거리입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n책 덕분에 지금 이 글을 쓰고 있어요.\n\n이 책 덕분에 모두가 소중한 가치를 공유할 수 있다는 것을 이해했어요. 완전히 초보일지라도, 여러분은 대부분의 사람들보다 앞서 있는 거예요.\n\n증거가 필요하다고요?\n\n제가 AI 공부를 시작한 지 약 6주만에 쓴 글 링크를 공유했어요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n무엇을 공유할까요?\n\n✔ 코드\n✔ 수업\n✔ 실수\n✔ 생각\n✔ 즐겨찾는 자료\n\n배운 모든 것을 공유하세요.\n\n많은 사람들에게 공개하는 것이 어려움을 알고 있어요 (제게도 무서웠어요).\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하지만 그것은 당신이 할 수 있는 최고의 장기 투자 중 하나가 될 것입니다. 크리에이터 경제가 번창하고 있습니다. 콘텐츠를 만드는 것은 시간 투자를 제외하고는 거의 단점이 없어요.\n\n다음을 얻게 될 거에요:\n✔ 신뢰 구축\n✔ 다른 사람들에게 영감 주기\n️✔ 신뢰성 확보\n✔ 진본성 확보\n✔ 성장 추적\n✔ 지식 고착화\n✔ 네트워크 확장\n✔ 가르치면서 더 깊이 배우기\n✔ 개인 브랜드 구축\n\n그리고 이 목록은 심지어 완전하지 않아요!\n\n저는 이것을 해봤고, 혜택을 확인해요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n요렇게 생각하고 있어요:\n\n🌟 배운 것을 나누세요!\n\n# 6. 단계 4와 5를 반복하세요.\n\n계속해서 해나가요. 함께 공유해요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음 프로젝트를 선택하는 방법?\n\n이건 당신이 다음 프로젝트에 뛰어들기 전에 꼭 물어봐야할 중요한 질문이에요.\n\n나는 프로젝트를 하나 끝마치는 데 몇 일밖에 없어서 엄청 큰 실수를 했어요. 매주 영상을 게시했기 때문에, 아래 과정을 거쳤죠:\n\n- 프로젝트 아이디어 찾기.\n- 사용할 기술 선택하기.\n- 프로젝트 만들기 (코드 작성).\n- 프로젝트에 대해 이야기하는 녹화.\n- 내 녹음물 편집하기 (너무 싫었어요).\n- 설명 준비하기.\n- 영상 업로드하기.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그럼, 저는 매체(Medium)를 위한 기사를 썼어요.\n\n모두 7일 안에.\n\n저는 실제 프로젝트를 만드는 대신 탐험하고 공유하는 데 시간을 보냈어요. 탐험 자체가 좋은 일이에요. 하지만 이 \"충격적인 진실\"을 빨리 알았다면 더 좋았을텐데요:\n\n탐험적 AI 프로젝트로는 취업이 어려워요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\"Benefits, not features\"는 판매에서의 주요 원칙 중 하나입니다.\n\n왜 AI 엔지니어링에 관한 기사에서 판매 원칙을 언급하는 걸까요? 많은 사람들이 AI가 과대포장되었다고 믿습니다.\n\nAI 뉴스는 멋진 AI 특징을 언급합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하지만 기업은 결과에만 관심이 있어요.\n안타깝게도, 기능은 대부분의 경우 기업에 실질적인 혜택을 제공하지 못해요.\n\n만약 여러분의 프로젝트가 두드러지게 하고 싶다면 혜택에 집중하세요.\n\n다음은 3가지 주요 혜택 카테고리에요:\n\n- 시간 절약\n- 비용 절감\n- 수익 증대\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n(힌트: AI는 시간을 절약하는 데 좋은 도구입니다.)\n\n프로젝트가 가치를 더하는지 확인하세요 (현실 세계에서 혜택을 제공).\n\n- 편안한 영역을 벗어나기\n- 새로운 것을 배울 것을 보장하기\n- 기존 기술 향상시키기\n- 실제 문제 해결하기\n\n각 프로젝트는 도전적이어야 하고 새로운 것을 배우도록 강제해야 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n친구야, 여기 몇 가지 실용적인 주제가 있어:\n- RAG\n- LangChain\n- HuggingFace\n- Vector Databases\n- Vector Embedding\n- 오픈소스 LLMs\n- 이미지 생성기 (DALL-e 3)\n- 음성 모델 (Whisper와 TTS)\n\n나는 최근 AI 엔지니어링 직무에 지원해서 10회 이상의 면접을 봤어.\n\n내 경험상 회사들은 항상 RAG에 대해 물어봐. 그래서 나는 2번이나 3번째 프로젝트에서 RAG를 사용할 거야.\n\n조기에 시작할수록 좋아.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n표 태그를 Markdown 형식으로 변경하면서 더 나은 결과를 얻을 수 있습니다. \n\n**단계 1, 2, 3에서 기술을 향상**하여 프로젝트에서 더 많은 이점을 얻을 수 있습니다. \n\n- 코딩 기술 확장하기\n- LLMs 자세히 배우기\n- 프롬프트 탐색하기\n\n실제 문제를 해결하는 프로젝트를 개발하세요.\n\n# 7️. 멘토를 찾아보세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n멘토가 없다는 것이 내 진전을 엄청나게 늦춘 것 같아.\n\n내 여정에서는 글의 처음 6 단계를 모두 (어느 정도는) 수행했어.\n\n하지만 나는 멘토를 찾지 못한 채...\n\n내게는 이런 일을 할 수 있는 사람이 한 명도 없었어:\n- 어려운 시기를 함께 극복할 수 있는\n- 어떤 기술을 키워야 하는지 알려 줄 수 있는\n- 내 진로를 돕는\n- 자신의 네트워크에 소개해 주는\n- 성공을 함께 축하해 주는\n- 나에게 경력에 관한 조언을 해 주는\n- 피드백을 주는\n- 격려해 주는\n- 비판해 주는\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저의 실수를 하지 마세요!\n\n멘토를 찾아보세요.\n\n멘토가 여러분을 몇 달 동안 구해줄 거예요!\n\n참고: AI 엔지니어링 여정에서 멘토를 찾고 있다면 도와드릴게요. 매체(Medium) 출처라고 말씀하시고 LinkedIn에서 DM 보내주세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론\n\n아직 AI 엔지니어가 되기에는 매우 일찍입니다.\n\n이 역할은 아직 정의되지 않았지만 수요는 빠르게 증가하고 있습니다.\n\n이 기사를 읽은 후에는 AI 엔지니어가 되기 위한 제 경로를 엄청난 속도로 배웠습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n질문이 있으면 댓글에 적어주세요! ✍️\n\n🔔 제 이름은 Kris예요. 저는 기술 분야의 사람들이 AI 엔지니어가 되도록 도와드려요. \nMedium에서는 저의 경험과 새로운 AI 엔지니어가 되고 싶어하는 분들에게 가치 있는 교훈을 공유하고 있어요. 꼭 팔로우해주세요. 🔔","ogImage":{"url":"/TIL/assets/img/2024-07-12-IfIstartedlearningAIEngineeringin2024hereswhatIwoulddo_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-IfIstartedlearningAIEngineeringin2024hereswhatIwoulddo_0.png","tag":["Tech"],"readingTime":16},{"title":"대수학자처럼 사고하는 법","description":"","date":"2024-07-12 20:29","slug":"2024-07-12-HowToThinkLikeAnAlgebraist","content":"\n\n![HowToThinkLikeAnAlgebraist](/TIL/assets/img/2024-07-12-HowToThinkLikeAnAlgebraist_0.png)\n\n30년이나 40년 전에 열정적이고 재능 있는 고등학교 수학 학생이었다면, 당신이 교과과정의 일환으로 기초 그룹 이론을 공부했을 확률은 거의 확실했습니다. 안타깝게도 이제는 이러한 경우가 많지 않습니다. 많은 고등학교 교육과정에서 그룹 이론이 제외되었으며, 오늘날 많은 사람들은 수학 관련 학과를 전공할 때 처음으로 마주치게 됩니다.\n\n이 점이 안타깝습니다. 그룹 이론은 대수학자처럼 생각하는 방법에 대한 훌륭한 입문입니다. 이러한 사고 방식을 통해 조직적이고 체계적이게 이산적이고 추상적인 객체를 처리할 수 있으며, 이는 고급 수학을 공부하는 데 필수적인 기술이자 삶 전반에서 극도로 유용한 기술입니다. 이러한 방식으로 생각하는 데는 익숙해지기에 시간이 필요하며, 학교에서 조금이라도 경험이 있는 사람들은 학위 수준에서 수학을 공부할 때 더 빨리 적응할 것입니다.\n\n저는 1988년 케임브리지 대학 입학 시험지에서 이 문제를 발견했으며, 이 문제가 내 주장을 훌륭하게 설명해 주는 사례라고 생각합니다. 만약 이 문제에 대해 적절한 순서와 논리적으로 생각할 수 있다면, 해결책은 깔끔하고 매우 우아할 것입니다. 그러나 대수학자처럼 생각하는 방법에 대한 훈련이 없다면, 이 문제에 대처하는 데 어려움을 겪을 것입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n문제를 제시하기 전에 옛날에 고등학생들이 배우던 작은 양의 군 이론을 소개해드릴게요 😊\n\n## 그룹이란 무엇인가요?\n\n그룹은 수학에서 보는 일부 공통 구조를 추상화하고 일반화하는 방법입니다. 간단한 예로, 정수 집합을 살펴봅시다. 이 집합에서 덧셈 연산을 살펴보겠습니다. 정수와 이 연산에 대한 몇 가지 특성이 있습니다. 이러한 특성들은 당연하게 여기지만, 그들이 작동하고 유용성과 관련이 있습니다. 여기 몇 가지 특성이 있습니다:\n\n- 정수는 덧셈에 대해 닫혀 있습니다. 즉, 모든 두 정수를 더하면 다른 정수가 나옵니다.\n- 정수는 덧셈에 대해 결합적입니다. 즉, 세 개의 정수 a, b 및 c가 있을 때 a + (b + c) = (a + b) + c 가 성립합니다.\n- 항등원인 0(영)이 존재합니다. 이 정수는 다른 어떤 정수에 더해져도 같은 정수를 반환합니다. 따라서 모든 정수 a에 대해 a + 0 = 0 + a = a 가 성립합니다.\n- 임의의 정수 a에 대해 역원 -a가 존재합니다. 이는 정수와 그 역원을 아무 순서로 더하면 항등원 0이 나온다는 것을 의미합니다. 즉, 모든 정수 a에 대해 a + (-a) = (-a) + a = 0 가 성립합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이러한 속성들을 일반 대수 구조를 정의하는 추상화된 개념으로 정의할 수 있습니다.\n\n그룹은 다음과 같은 조건을 만족하는 객체 G로 이루어진 집합과 해당 객체들에 대한 연산인 *을 함께 하는 것으로 정의됩니다:\n\n- g, h가 G에 속한다면 g*h도 G에 속합니다.\n- 임의의 g, h, k가 G에 속할 때, g*(h*k) = (g*h)*k가 성립합니다.\n- G에는 항등원인 e가 존재하며, 모든 g ∈ G에 대해 g*e = e*g = g가 성립합니다.\n- 모든 g ∈ G에 대해 역원 g^(-1)이 존재하며, g * g^(-1) = g^(-1) * g = e가 성립합니다.\n\n그룹이라는 개념은 우리가 일상 생활에서 유용하게 활용하는 수학적 구조를 추상화하는 방법으로 개발되었지만, 이 정의가 소개된 이후 몇 세기 동안, 수학자들은 이러한 속성을 따르며 거대하고 완전히 믿기 어려운 방식으로 유한 그룹을 형성하는 놀라운 구조들을 발견해왔습니다. 예를 들어, 몬스터 그룹은 1970년대에 발견되었으며 808,017,424,794,512,875,886,459,904,961,710,757,005,754,368,000,000,000개의 원소로 구성되어 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 문제\n\n여기는 1988년 케임브리지 대학 입시시험의 한 문제입니다. 만약 원하신다면, 제가 풀이를 보여주기 전에 먼저 도전해보세요. 그룹에는 하나의 연산만 정의되어 있기 때문에 그룹에서 대수를 다룰 때 연산 표기를 생략하는 것이 일반적이며 편리합니다. 그렇기 때문에 g*h는 단순히 gh로 쓰이고 g*g는 g²로 쓰입니다.\n\n![Image](/TIL/assets/img/2024-07-12-HowToThinkLikeAnAlgebraist_1.png)\n\n## 나의 풀이 — 파트 (i)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리는 o(g) = n이라고 말을 들었습니다, 따라서 g^k = e인 더 작은 양수 정수 k ` n은 없습니다. 따라서 g^N = e이면 N ≥ n이어야 합니다.\n\n우리는 숫자 N을 N = kn + j로 쓸 수 있습니다. 여기서 k ≥ 1이고 0 ≤ j ` n입니다. 그러면 다음을 말할 수 있습니다.\n\n\n| g^j      | g^(n+j)     | g^(2n+j)    | ... | g^((k-1)n+j) |\n|----------|-------------|--------------|-----|---------------|\n| g^0      | g^n         | g^(2n)       | ... | g^((k-1)n)   |\n\n\n그러나 우리는\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-HowToThinkLikeAnAlgebraist_3.png\" /\u003e\n\n그리고 0 ≤ j ≤ n이기 때문에 j = 0이어야 합니다. 왜냐하면 o(g) = n이기 때문이죠. 따라서 N = kn이고, 따라서 n은 N으로 나누어집니다.\n\n## 내 해답 — Part (ii)\n\n이 부분이 더욱 명확해지도록 우리의 연산 표기법을 사용해봅시다. 다음과 같이 말할 수 있습니다:\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![How to think like an algebraist](/TIL/assets/img/2024-07-12-HowToThinkLikeAnAlgebraist_4.png)\n\nWith the h element repeated m times. Now note that:\n\n![How to think like an algebraist](/TIL/assets/img/2024-07-12-HowToThinkLikeAnAlgebraist_5.png)\n\nSo this means we can make the following replacement:\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\\\u003cimg src=\"/TIL/assets/img/2024-07-12-HowToThinkLikeAnAlgebraist_6.png\" /\u003e\n\nh가 처음과 끝을 포함해 m번 나타납니다. 이제 우리가 이것을 원래 식에 넣으면\n\n\\\u003cimg src=\"/TIL/assets/img/2024-07-12-HowToThinkLikeAnAlgebraist_7.png\" /\u003e\n\n오른쪽에 m번 반복되어 있습니다. 따라서 필요한 결과를 얻을 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 나의 해결책 — Part (iii)\n\n주어진 정보를 사용하면:\n\n![이미지](/TIL/assets/img/2024-07-12-HowToThinkLikeAnAlgebraist_8.png)\n\n이제 우리가 이전 부분에서 얻은 결과를 사용해봅시다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래와 같이 변경해주셨으면 좋겠습니다.\n\n\n![HowToThinkLikeAnAlgebraist_9](/TIL/assets/img/2024-07-12-HowToThinkLikeAnAlgebraist_9.png)\n\n아래의 내용대로 수정해 주십시오.\n\nTo find o(h), we can use the given fact that g⁵ = e. Consider the following logic:\n\n![HowToThinkLikeAnAlgebraist_10](/TIL/assets/img/2024-07-12-HowToThinkLikeAnAlgebraist_10.png)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래와 같이 결과를 사용하여 이를 반복할 수 있습니다. \n\n\n![Part(ii)](/TIL/assets/img/2024-07-12-HowToThinkLikeAnAlgebraist_11.png)\n\n\n유사한 논리를 사용하여 계속하여 이 패턴을 유지하면 다음과 같은 결론을 내릴 수 있습니다: \n\n\n![Pattern Logic](/TIL/assets/img/2024-07-12-HowToThinkLikeAnAlgebraist_12.png)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하지만 우리는 g⁵ = e임을 알고 있으므로, 다음과 같이도 말할 수 있습니다:\n\n![image](/TIL/assets/img/2024-07-12-HowToThinkLikeAnAlgebraist_13.png)\n\n따라서:\n\n![image](/TIL/assets/img/2024-07-12-HowToThinkLikeAnAlgebraist_14.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그래서:\n\n![Image](/TIL/assets/img/2024-07-12-HowToThinkLikeAnAlgebraist_15.png)\n\n이제, Part (i)를 사용하면 h의 순서는 31로 나누어져야 합니다. 그런데 31은 소수입니다. 따라서 o(h) = 31입니다.\n\n그룹 이론에 대한 소개 어땠나요? 자유롭게 의견을 남겨주세요!","ogImage":{"url":"/TIL/assets/img/2024-07-12-HowToThinkLikeAnAlgebraist_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-HowToThinkLikeAnAlgebraist_0.png","tag":["Tech"],"readingTime":8},{"title":"Python으로 웹사이트에서 데이터를 쉽게 추출하는 방법","description":"","date":"2024-07-12 20:27","slug":"2024-07-12-HowToEasilyExtractDataFromAWebsiteWithPython","content":"\n\n\u003ctable\u003e\n\u003ctr\u003e\n  \u003cth\u003eLibrary\u003c/th\u003e\n  \u003cth\u003ePurpose\u003c/th\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n  \u003ctd\u003eRequests\u003c/td\u003e\n  \u003ctd\u003eFor sending HTTP requests\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n  \u003ctd\u003eBeautifulSoup\u003c/td\u003e\n  \u003ctd\u003eFor parsing HTML and XML\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n  \u003ctd\u003eTkinter\u003c/td\u003e\n  \u003ctd\u003eFor building the GUI\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/table\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- **Pandas**: 추출된 데이터를 위한 데이터베이스를 생성하는 데 사용됩니다.\n- **Requests**: 웹사이트에 접근 권한을 요청하는 데 사용됩니다.\n- **BeautifulSoup**: 웹상에서 데이터를 찾는 데 사용됩니다.\n\n# 작업: 이메일 목록 추출 및 CSV로 변환하기\n\n여러 주제에서 많은 이메일을 가져와야 했습니다.\n\n\"수동으로는 절대 할 수 없어\" 라고 생각했습니다. 그렇게 하면 시간이 많이 걸리고 지루할 것이라고 생. 따라서 나는 파이썬 기술을 사용하기로 결정했습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n웹 사이트에는 다음과 같은 데이터가 있습니다:\n\n![Data Table](/TIL/assets/img/2024-07-12-HowToEasilyExtractDataFromAWebsiteWithPython_1.png)\n\n네, 과목 이름과 이메일이 포함된 표가 있습니다.\n\n이 프로젝트의 목표는 이 데이터를 사용하여 CSV 파일을 생성하는 것입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 단계 1. 모듈 가져오기\n\n먼저 사용할 Python 라이브러리를 가져와 봅시다:\n\n- pandas.\n- requests.\n- BeautifulSoup.\n\n```js\nimport pandas as pd\nimport requests\nfrom bs4 import BeautifulSoup\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 단계 2. 데이터 찾기\n\n## 2.1. 웹 스크래핑은 어떻게 작동되나요?\n\n웹에서 데이터를 추출하는 것이 가능한 이유는 무엇인가요?\n\n답은 HTML(HyperText Markup Language)에 달려 있습니다. HTML은 웹 브라우저에서 표시할 문서의 표준 마크업 언어입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n웹사이트 어디에서든 마우스 오른쪽 버튼을 클릭하고 Inspect를 선택하면 웹의 코드가 오른쪽에 표시됩니다:\n\n![image](/TIL/assets/img/2024-07-12-HowToEasilyExtractDataFromAWebsiteWithPython_2.png)\n\n파이썬은 (일부 라이브러리와 함께) 이 HTML 코드를 \"읽고\" 원하는 데이터를 찾는 것입니다.\n\n더 자세한 내용은 향후 기사에서 확인해보세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 2.2. HTML 가져오기 함수\n\n우선, 웹 사이트에서 HTML 코드를 가져와야 합니다.\n\nURL을 매개변수로 하는 get_html 함수를 생성하는 방법은 다음과 같습니다:\n\n```js\nimport pandas as pd\nimport requests\nfrom bs4 import BeautifulSoup\n\ndef get_html(url):\n\n    try:\n        response = requests.get(url) # 웹 사이트에서 HTML을 요청합니다\n        return response.text\n\n    except Exception as e: # 가능한 오류를 처리하기 위한 예외 처리\n        print(f\"웹 페이지를 가져오는 데 실패했습니다: {e}\")\n        return \"\"emails = set() # 중복을 피하기 위한 코드입니다\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 단계 3. 데이터 추출\n\n다음 단계는 우리가 원하는 데이터를 추출하는 것입니다.\n\n우리는 이전 함수에서 HTML 코드를 가져오는 extract_data 함수를 만들 수 있습니다. 이는 다음 단계를 포함합니다:\n\n- BeautifulSoup 클래스 초기화.\n- 테이블을 찾는 변수 설정.\n- 데이터를 수집할 빈 리스트.\n- 데이터를 검색하는 for 루프.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport pandas as pd\nimport requests\nfrom bs4 import BeautifulSoup\n\ndef get_html(url):\n\n    try:\n        response = requests.get(url) # 웹사이트로부터 HTML을 요청합니다.\n        return response.text\n\n    except Exception as e: # 가능한 오류를 처리하기 위한 부분\n        print(f\"웹 페이지를 가져오는 데 실패했습니다: {e}\")\n        return \"\" # 중복을 피하기 위해 이메일 집합으로 설정\n\ndef extract_data(html):\n\n    soup = BeautifulSoup(html, 'html.parser') # BeautifulSoup 클래스를 초기화\n    table = soup.find('table') # 테이블을 찾습니다.\n    data = [] # 데이터를 수집할 빈 리스트\n    \n    if table:\n\n        rows = table.find_all('tr') # 모든 테이블을 찾습니다.\n\n        for row in rows[1:]:  # 헤더 행을 건너 뜁니다.\n            cols = row.find_all('td') # 테이블에서 셀을 찾습니다.\n\n            if len(cols) == 4:  # 항상 4개의 열이 있다고 가정\n                catedra_name = cols[0].text.strip() # 과목 이름\n                email = cols[1].text.strip() # 이메일\n                data.append({'catedra': catedra_name, 'email': email}) # 데이터 리스트에 추가\n    \n    return data\n```\n\n# 단계 4. 함수 호출 및 데이터 CSV로 저장\n\n이제 모든 준비가 되었으므로 함수를 호출해야 합니다.\n\n```js\nimport pandas as pd\nimport requests\nfrom bs4 import BeautifulSoup\n\ndef get_html(url):\n\n    try:\n        response = requests.get(url) # 웹사이트에서 HTML 가져오기\n        return response.text\n\n    except Exception as e: # 가능한 오류 처리\n        print(f\"웹 페이지를 가져오는 데 실패했습니다: {e}\")\n        return \"\" # 중복을 피하기 위해 이메일 집합\n\ndef extract_data(html):\n\n    soup = BeautifulSoup(html, 'html.parser') # BeautifulSoup 클래스를 초기화\n    table = soup.find('table') # 테이블 찾기\n    data = [] # 데이터 수집을 위한 빈 리스트\n    \n    if table:\n\n        rows = table.find_all('tr') # 모든 테이블 찾기\n\n        for row in rows[1:]:  # 헤더 행 건너 띄기\n            cols = row.find_all('td')\n\n            if len(cols) == 4:  # 항상 4개의 열\n                catedra_name = cols[0].text.strip() # 과목 이름\n                email = cols[1].text.strip() # 이메일\n                data.append({'catedra': catedra_name, 'email': email})\n    \n    return data\n\nurl = \"https://edipsicouba.net.ar/uncategorized/listado-mails-materias-electivas/\"  # 여러분의 링크 설정\n\nhtml = get_html(url) # get_html() 함수 호출하여 내용을 변수에 저장\ndata = extract_data(html) # extract_data() 함수 호출하여 결과를 변수에 저장\n\ndf = pd.DataFrame(data) # 데이터를 데이터프레임으로 변환\ndf.to_csv('mail_info.csv', index=False) # 데이터프레임을 CSV 파일로 저장\n\nprint(\"데이터가 성공적으로 추출되어 mail_info.csv로 저장되었습니다\")\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그게 다에요!\n\n이렇게 하면 웹사이트의 테이블 안에서 데이터를 수집할 수 있어요.\n\n또한, 이렇게 하면 Python을 사용하여 지루한 작업을 자동화할 수 있어요 😉\n\n다음 글에서는 데이터 분석 프로젝트를 위해 슈퍼마켓에서 데이터를 수집하는 방법을 보여드릴게요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 도와드릴 수 있는 방법:\n\n- 새로운 무료 뉴스레터 'The Super Learning Lab'를 구독하세요.\n- 곧 무료 학습 이북과 이메일 코스가 출시될 예정입니다!\n\n![HowToEasilyExtractDataFromAWebsiteWithPython_3](/TIL/assets/img/2024-07-12-HowToEasilyExtractDataFromAWebsiteWithPython_3.png)\n\n## 내 최고의 학습 기사들:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안녕하세요!\n\n가져와주셔서 감사합니다! 아래는 이번 주 발간물 내용입니다:\n\n- Ultralearning으로 무엇이든 배우기\n- 초안 속 9가지 Ultra-learning 원칙\n- Ultralearning을 활용하여 2개월 만에 무료로 독일어 배우기\n- 학습을 슈퍼파워로 만들기\n- 이것을 하지 않고 책을 읽는 것을 그만두세요\n\n만날 날을 기대하며,\n\nAxel\n\n# 간단하고 쉬운 용어로 🚀\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nIn Plain English 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가에게 박수를 보내고 팔로우해주세요 👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문하기: CoFeed | Differ\n- PlainEnglish.io에서 더 많은 콘텐츠 확인하기","ogImage":{"url":"/TIL/assets/img/2024-07-12-HowToEasilyExtractDataFromAWebsiteWithPython_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-HowToEasilyExtractDataFromAWebsiteWithPython_0.png","tag":["Tech"],"readingTime":9},{"title":"Apache Iceberg PySpark로 데이터 웨어하우스를 만드는 4가지 방법","description":"","date":"2024-07-12 20:24","slug":"2024-07-12-ApacheIceberg4MethodsToCreateAWarehouseWithPySpark","content":"\n\n![image](/TIL/assets/img/2024-07-12-ApacheIceberg4MethodsToCreateAWarehouseWithPySpark_0.png)\n\n## 온디맨드 강좌| 추천\n\n몇몇 독자들이 데이터 엔지니어가 되는 데 도움이 되는 온디맨드 강좌를 요청했습니다. 이 중에서 제가 추천하는 3가지 좋은 자료들은 다음과 같습니다:\n\n- 데이터 엔지니어링 나노디그리 (UDACITY)\n- 아파치 카프카 및 아파치 스파크를 이용한 데이터 스트리밍 나노디그리 (UDACITY)\n- PySpark를 이용한 스파크 및 파이썬을 활용한 빅데이터 (UDEMY)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아직 Medium 회원이 아니신가요? 매달 $5로 Medium의 모든 콘텐츠에 액세스할 수 있는 제 추천 링크로 가입해보세요!\n\n# 소개\n\nApache Iceberg은 데이터 레이크 내에서 매우 큰 데이터 세트를 효율적으로 저장하는 데 산업의 기준이 되어가고 있습니다.\n\n이 오픈 테이블 형식은 Parquet 또는 ORC 파일로 저장된 데이터 세트에 대해 작동할 수 있도록 해주며, 관계형 데이터베이스의 테이블과 정확히 같은 방식으로 작동합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아이스버그 데이터 웨어하우스를 올바르게 생성하는 것은 해당 형식의 모든 데이터를 저장하고 조회할 수 있는 기본적인 첫 번째 단계입니다. 그러나 아이스버그 문서는 종종 기술적인 내용이 부족하거나 관련 사용 사례를 다루지 않는 경우가 있습니다.\n\n현재 Spark가 아이스버그 테이블과 작업하기 위해 가장 잘 지원되는 컴퓨팅 엔진 중 하나이므로 이번 튜토리얼에서는 다음 질문에 대답할 것입니다:\n\n대규모 데이터 보관 솔루션을 개발하면서 얻은 실무 경험을 바탕으로, 본 튜토리얼은 데이터 엔지니어들에게 아이스버그 API를 PySpark에서 활용하기 위한 기본 단계를 보여주며, 연구하는 데 소요되는 시간(및 시행착오)을 감소시키는 등 지식 간극을 메우고자 합니다.\n\n# 방법론\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아이스버그 아키텍처는 세 개의 주요 레이어로 구성되어 있습니다:\n\n- 아이스버그 카탈로그 레이어: 각 테이블의 현재 메타데이터 파일의 정확한 위치를 저장합니다. 이 포인터는 Spark, Trino, Flink 등의 쿼리 엔진이 데이터를 읽거나 쓸 위치를 정확히 지정합니다.\n- 메타데이터 레이어: 아이스버그 테이블과 관련된 메타데이터를 저장합니다. 테이블 스키마, 파티셔닝 스키마 및 특정 시점의 테이블 스냅샷과 같은 정보를 포함합니다.\n- 데이터 레이어: 행 데이터를 컬럼 형식으로 저장하며, 파티션화된 디렉토리에 구성합니다.\n\n환경 및 특정 요구에 따라, 이러한 레이어는 동일한 저장소 내에 있거나 다른 기술을 활용할 수 있습니다.\n\n본 튜토리얼에서는 데이터 엔지니어가 로컬 환경에서 개발하는 동안 아이스버그 데이터 웨어하우스를 설정하는 세 가지 간단한 방법을 소개할 것입니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 방법 #1: 로컬에서 실행되는 Spark 세션으로, 메타데이터와 데이터 레이어는 MinIO 버킷에, 카탈로그 레이어는 PostGres DB에 저장되어 있습니다.\n- 방법 #2: 로컬에서 실행되는 Spark 세션으로, 모든 세 가지 레이어가 스테이징 AWS S3 버킷에 저장되어 있습니다(하둡 카탈로그 사용).\n- 방법 #3: EMR 클러스터에서 실행되는 Spark 세션으로, 수동 CLI 배포를 통해, 모든 세 가지 레이어가 스테이징 AWS S3 버킷에 저장되어 있습니다(하둡 카탈로그 사용).\n\n또한 상용 환경에서 동일한 결과를 얻는 데 일반적으로 사용되는 추가적인 방법을 설명할 것입니다:\n\n- 방법 #4: EMR 클러스터에서 실행되는 Spark 세션으로, 자동화된 Apache Airflow 배포를 통해, 모든 세 가지 레이어가 프로덕션 AWS S3 버킷에 저장되어 있습니다(하둡 카탈로그 사용).\n\n아래에 위에서 설명한 방법들의 시각적 표현을 찾을 수 있습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](/TIL/assets/img/2024-07-12-ApacheIceberg4MethodsToCreateAWarehouseWithPySpark_1.png)\n\n# 환경 설정하기\n\n이 자습서에서 사용하는 자료는 GitHub에서 이용할 수 있습니다.\n\n따라서 따라하기 위해 단순히 원격 프로젝트 저장소를 로컬로 클론하고 spark_icb_warehouse 디렉터리로 이동한 후 docker compose up -d를 실행하면 됩니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 명령은 다음 서비스를 실행합니다:\n\n```js\nspark_icb_warehouse % docker compose up -d\n[+] Running 6/6\n ⠿ Network spark_icb_warehouse_shared-network 생성됨                                                                                                         0.0초\n ⠿ Container postgres-db                       시작함                                                                                                         1.0초\n ⠿ Container minio                             시작함                                                                                                         1.0초\n ⠿ Container mc                                시작함                                                                                                         1.8초\n ⠿ Container airflow_webserver                 시작함                                                                                                         1.9초\n ⠿ Container airflow_scheduler                 시작함\n```\n\n- Postgres DB = 메소드 #1의 일환으로 사용되며 Iceberg 카탈로그를 저장하고, 메소드 #4의 일환으로 Airflow 메타데이터를 저장하기 위해 사용됩니다. 동일한 Postgres 서비스가 두 개의 데이터베이스를 호스트하는 효율적인 전략입니다. 즉, docker-compose.yml이 실행되면 생성된 airflow_metadata_db와 postgres-init 폴더의 init_dbs.sh 스크립트를 실행하여 생성된 iceberg_warehouse_pg 데이터베이스가 사용됩니다.\n- MinIO = 메소드 #1의 일환으로 Iceberg 데이터와 메타데이터 레이어를 저장하기 위해 사용됩니다. Docker를 통해 실행될 때 MinIO는 크라우드 스토리지 (예: S3 Bucket)의 기능을 무료로 제공하고 주요 설치나 유지 관리가 필요하지 않습니다. 따라서 PySpark 어플리케이션을 로컬로 테스트하는 동안 훌륭한 선택지입니다.\n- Apache Airflow (WebServer + Scheduler) = 메소드 #4의 일환으로 PySpark 어플리케이션을 EMR에 자동으로 배포하고, 프로덕션 환경에서의 일반적인 전략을 시뮬레이션하기 위해 사용됩니다. 이 튜토리얼에서는 Airflow 버전 2.5.2를 사용하고 UI를 8085 포트에서 사용할 수 있도록 설정했습니다.\n\n이 세 가지 서비스 외에도 동일한 지역(예: eu-central-1) 내에서 생성된 S3 Bucket과 기본 EMR 클러스터를 기다리는 상태로 설정한 AWS 계정이 있다고 가정합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하지만 PySpark은 어떻게 될까요? Iceberg 퀵스타트 가이드는 인기 있는 tabulario/spark-iceberg 이미지를 가져와 Docker에서 독립적으로 Spark를 실행하는 것을 권장합니다 – 온라인 가이드의 대부분과 마찬가지로 – 그러나 이 튜토리얼의 목표 중 하나는 실제로 이것이 필요하지 않다는 것을 보여주는 것입니다:\n\n- 메소드 #1 및 #2의 경우, 우리는 단순히 로컬로 pyspark (버전 3.3.1)을 설치할 수 있으며, 가상 환경의 일부로 코드를 Jupyter 노트북을 통해 컴파일할 수 있습니다.\n- 메소드 #3 및 #4의 경우, EMR 클러스터를 설정하는 동안 pyspark=3.3.1이 사전 설치되어 있으며 추가 단계가 필요하지 않습니다.\n\n# Iceberg Warehouse 생성하기\n\n이 섹션의 코드 조각은 GitHub 레포지토리의 Spark_Iceberg_WH Jupyter 노트북의 일부로 제공됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아이스버그 프레임워크가 Pyspark 위에서 작동하도록 하려면 스파크 세션을 생성할 때 구성값의 일부로 전달될 다음 패키지를 명시해야 합니다.\n\n```js\n# 종속성 정의 (Maven에서 다운로드할 패키지)\n# 1. Spark가 Iceberg 웨어하우스와 상호 작용하기 위해 필요\nDEPENDENCIES = \"org.apache.iceberg:iceberg-spark-runtime-3.3_2.12:1.3.1\"\nDEPENDENCIES += \",software.amazon.awssdk:bundle:2.20.18\"\nDEPENDENCIES += \",com.amazonaws:aws-java-sdk-bundle:1.11.901\"\nDEPENDENCIES += \",org.apache.hadoop:hadoop-aws:3.3.4\"\n\n# 2. 카탈로그가 포스트그레스 DB에 저장된 경우에만 필요\nDEPENDENCIES += \",org.postgresql:postgresql:42.6.0\"\n```\n\n다음 사항을 유의해야 합니다:\n\n- 우리는 iceberg-spark 패키지 버전 1.3.1을 사용할 것입니다. 이 버전을 사용할 때 구성 오류를 피하기 위해 꼭 필요한 패키지는 awssdk-bundle, aws-sdk-bundle, hadoop-aws 세 개 뿐입니다.\n- Python에서 문자열을 연결하는 더 좋은 방법이 있지만, 위의 코드는 더 필요하지 않을 때 패키지에 주석을 달기 쉽게 만들어줍니다 (예를 들어 postgresql은 메소드 #1에만 필요합니다).\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 방법 #1 = `로컬 스파크 세션 + MinIO에 메타데이터/데이터 레이어 + 포스트그레스 DB에 카탈로그 레이어`\n\n파이스파크를 사용하여 아이스버그 데이터 웨어하우스를 만드는 첫 번째 방법은, 로컬 SparkSession을 실행하고 JDBC 카탈로그(포스트그레스 DB)를 사용하도록 구성하고 메타데이터 및 데이터 레이어를 MinIO 버킷에 저장하는 것입니다.\n\n이를 수행하는 코드는 아래에 제시되어 있습니다:\n\n```js\nfrom pyspark import SparkConf\nfrom pyspark.sql import SparkSession\n\ndef spark_local_to_minio(icb_catalog_name,\n                         iceberg_warehouse,\n                         storage_type,\n                         pg_user,\n                         pg_password,\n                         minio_bucket,\n                         minio_access_key,\n                         minio_secret_key,\n                         minio_end_point):\n\n    conf = (\n            SparkConf()\n            .setAppName('spark_local_to_minio')\n            #Dependencies\n            .set('spark.jars.packages', DEPENDENCIES)\n            #SQL Extensions\n            .set('spark.sql.extensions', 'org.apache.iceberg.spark.extensions.IcebergSparkSessionExtensions')\n            #Catalog Configuration\n            .set(f'spark.sql.catalog.{icb_catalog_name}', 'org.apache.iceberg.spark.SparkCatalog')\n            .set(f'spark.sql.catalog.{icb_catalog_name}.catalog-impl', 'org.apache.iceberg.jdbc.JdbcCatalog')\n            .set(f'spark.sql.catalog.{icb_catalog_name}.uri', f'jdbc:postgresql://localhost:5439/{pg_db}')\n            .set(f'spark.sql.catalog.{icb_catalog_name}.jdbc.user', pg_user)\n            .set(f'spark.sql.catalog.{icb_catalog_name}.jdbc.password', pg_password)\n            .set(f'spark.sql.catalog.{icb_catalog_name}.jdbc.verifyServerCertificate', 'true')\n            .set(f'spark.sql.catalog.{icb_catalog_name}.jdbc.useSSL', 'true')\n            .set(f'spark.sql.defaultCatalog', icb_catalog_name)\n            .set(f'spark.sql.catalog.{icb_catalog_name}.warehouse', f's3a://{minio_bucket}/{iceberg_warehouse}/{storage_type}/')\n            # MinIO Configuration\n            .set('spark.hadoop.fs.s3a.access.key', minio_access_key)\n            .set('spark.hadoop.fs.s3a.secret.key', minio_secret_key)\n            .set(\"spark.hadoop.fs.s3a.endpoint\", minio_end_point)\n    )\n    \n    ## Start Spark Session\n    spark = SparkSession.builder.config(conf=conf).getOrCreate()\n\n    print(\"Spark Session Running\")\n    \n    return spark\n\n############################################\nicb_catalog_name = 'pg_catalog'\niceberg_warehouse = 'iceberg-warehouse-pg'\nstorage_type = 'data-archives'\n\npg_db = 'iceberg_warehouse_pg'\npg_user = 'postgres'\npg_password = 'postgres'\n\nminio_bucket = 'iceberg-bucket'\nminio_access_key = 'admin'\nminio_secret_key = 'password'\nminio_end_point = 'http://127.0.0.1:9000'\n\nspark = spark_local_to_minio(icb_catalog_name,\n                             iceberg_warehouse,\n                             storage_type,\n                             pg_user,\n                             pg_password,\n                             minio_bucket,\n                             minio_access_key,\n                             minio_secret_key,\n                             minio_end_point)\r\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n`spark_local_to_minio()` 함수를 실행하면 SparkSession이 생성되어 iceberg_warehouse_pg(로컬에서 포트 5439로 사용 가능)와 MinIO의 iceberg-bucket을 가리키게 됩니다(docker-compose.yml을 실행하면서 생성됨, 로컬에서 127.0.0.1:9000으로 사용 가능).\n\n그러나 iceberg 웨어하우스는 SQL 명령을 실행하지 않으면 MinIO에 실질적으로 표시되지 않습니다(테스트 테이블처럼 객체를 생성하는 명령). 예를 들어:\n\n```js\n# iceberg-warehouse-pg 웨어하우스에 테스트 테이블(Within MinIO) 생성\n# *참고*: 이 작업을 실행하기 전에 UI에서 ICB WH를 볼 수 없습니다.\nspark.sql(f\"\"\"CREATE OR REPLACE TABLE {icb_catalog_name}.TEST_SCHEMA.TEST_TABLE_MINIO_PG (\n             FIELD_1 BIGINT,\n             FIELD_2 varchar(50),\n             FIELD_3 DATE,\n             FIELD_4 DOUBLE,\n             FIELD_5 TIMESTAMP\n             )\n             USING iceberg\n             \"\"\")\n\n# PG 카탈로그에 생성된 테이블 표시(TEST_SCHEMA)\nspark.sql(f'SHOW TABLES IN {icb_catalog_name}.TEST_SCHEMA').show(truncate=False)pyt\n```\n\n위와 같은 결과가 나타납니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n|namespace  |tableName          |isTemporary|\n|-----------|-------------------|-----------|\n|TEST_SCHEMA|TEST_TABLE_MINIO_PG|false      |\n\n\n위의 표는 TEST_SCHEMA.TEST_TABLE_MINIO_PG가 카탈로그에 등록되었음을 의미합니다. 이 카탈로그는 iceberg_warehouse_pg 데이터베이스 위에 구축되었으며 MinIO 버킷에 메타데이터 파일이 저장되었습니다.\n\n위에 설명한 것이 실제로 발생했는지 확인하기 위해 두 가지 확인을 수행할 수 있습니다:\n\n- MinIO UI에 액세스하여(사용자: admin, 비밀번호: password) 메타데이터 파일로 이동합니다:\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n[Markdown 형식으로 변경한 텍스트]\n![이미지1](/TIL/assets/img/2024-07-12-ApacheIceberg4MethodsToCreateAWarehouseWithPySpark_2.png)\n\n![이미지2](/TIL/assets/img/2024-07-12-ApacheIceberg4MethodsToCreateAWarehouseWithPySpark_3.png)\n\n- 선호하는 DBMS를 통해 Postgres DB에 연결하고 iceberg_tables를 쿼리하세요:\n\n![이미지3](/TIL/assets/img/2024-07-12-ApacheIceberg4MethodsToCreateAWarehouseWithPySpark_4.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Method #2 - 로컬 Spark 세션 + S3 버킷의 모든 레이어\n\n일명 #Method 1과 마찬가지로, 데이터 엔지니어들은 로컬 개발 및 테스트를 지원하도록 정확히 설정된 스테이징 S3 버킷(프로덕션 버킷을 반영)에 액세스할 수 있습니다.\n\n만약 그렇다면, SparkSession은 로컬에서 실행되지만, 이번에는 모든 레이어가 S3 버킷 내에 저장될 수 있습니다. 특히, S3 저장소는 하둡 카탈로그(반면에 MinIO에는 누락된)를 내장하고 있어, Iceberg 데이터 웨어하우스를 생성하면서 설정할 수 있는 아마도 가장 쉬운 [외부] 카탈로그입니다.\n\n위에서 설명한 내용을 달성하는 코드는 다음과 같습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport os\nfrom pyspark import SparkConf\nfrom pyspark.sql import SparkSession\n\ndef spark_local_to_s3(icb_catalog_name,\n                      iceberg_warehouse,\n                      storage_type,\n                      s3_bucket,\n                      s3_access_key,\n                      s3_secret_key):\n    \n    \n    os.environ.update({'AWS_ACCESS_KEY_ID': s3_access_key,\n                       'AWS_SECRET_ACCESS_KEY': s3_secret_key\n                       #'AWS_SESSION_TOKEN': s3_session_token\n                      })\n    \n    conf = (\n            SparkConf()\n            .setAppName('spark_local_to_s3')\n            #packages\n            .set('spark.jars.packages', DEPENDENCIES)\n            #SQL Extensions\n            .set('spark.sql.extensions', 'org.apache.iceberg.spark.extensions.IcebergSparkSessionExtensions')\n            #Configuring Catalog\n            .set(f'spark.sql.catalog.{icb_catalog_name}', 'org.apache.iceberg.spark.SparkCatalog')\n            .set(f'spark.sql.catalog.{icb_catalog_name}.type', 'hadoop')\n            .set(f'spark.sql.catalog.{icb_catalog_name}.warehouse', f's3a://{s3_bucket}/{iceberg_warehouse}/{storage_type}/')\n            .set(f'spark.sql.catalog.{icb_catalog_name}.io-impl', 'org.apache.iceberg.aws.s3.S3FileIO')\n    )\n\n    # Start Spark Session\n    spark = SparkSession.builder.config(conf=conf).getOrCreate()\n    \n    print(\"Spark 세션 실행 중\")\n    \n    return spark\n\nicb_catalog_name = 'hadoop_catalog'\niceberg_warehouse = 'iceberg-warehouse-dev-hdp'\nstorage_type = 'data-archives'\n\ns3_bucket = 'iceberg-bucket-9004'\ns3_access_key='XXXXX'\ns3_secret_key='XXXXX'\n\nspark = spark_local_to_s3(icb_catalog_name,\n                          iceberg_warehouse,\n                          storage_type,\n                          s3_bucket,\n                          s3_access_key,\n                          s3_secret_key)\r\n```\n\n한눈에 보기에 이 메서드는 #method 1보다 설정이 상당히 적게 필요함을 알 수 있습니다:\n\n- JDBC Catalog 구현이 `spark.sql.catalog.'icb_catalog_name'.type`, `hadoop`로 대체되었습니다.\n- MinIO 구성이 `spark.sql.catalog.'icb_catalog_name'.io-impl`, `org.apache.iceberg.aws.s3.S3FileIO`로 대체되었습니다.\n- 또한 S3 버킷의 access_key와 secret_key (가끔은 session_token이 필요할 수도 있음)이 환경 변수로 사용 가능하도록 만들었습니다. 환경 변수 사용으로 연결 오류가 발생하는 경우, 대안적으로 비밀을 default 프로필 아래 ~/.aws/credentials에 저장하는 방법이 있습니다.\n\n이번에는 spark_local_to_s3() 함수를 실행할 때, SparkSession을 생성하여 iceberg-bucket-9004를 가리키고 백그라운드에서 hadoop 카탈로그가 구성되었습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아마도 iceberg-warehouse-dev-hdp가 S3 계정 UI에 표시되지 않을 것입니다. 올바른 iceberg object를 생성하는 pyspark.sql 명령을 실행하지 않는 이상:\n\n```js\n# 메소드 1과 같이, 이 명령을 실행하지 않으면 ICB WH가 S3 Bucket 내부에 표시되지 않음\nspark.sql(f\"\"\"CREATE OR REPLACE TABLE {icb_catalog_name}.TEST_SCHEMA.TEST_TABLE_S3_HDP (\n             FIELD_1 BIGINT,\n             FIELD_2 varchar(50),\n             FIELD_3 DATE,\n             FIELD_4 DOUBLE,\n             FIELD_5 TIMESTAMP\n             )\n             USING iceberg\n             \"\"\")\n```\n\n실제로, 위의 명령은 데이터 웨어하우스와 TEST_TABLE_S3_HDP 테이블을 위한 전용 폴더를 생성합니다:\n\n![이미지](/TIL/assets/img/2024-07-12-ApacheIceberg4MethodsToCreateAWarehouseWithPySpark_5.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-ApacheIceberg4MethodsToCreateAWarehouseWithPySpark_6.png\" /\u003e\n\n## Method #3 - Spark Session On EMR (via CLI) + All Layers On S3 Bucket\n\nIf AWS EMR is your go-to production framework for deploying PySpark applications, you probably have a staging cluster for development paired with a staging S3 bucket (similar to #method 2).\n\nIn this scenario, data engineers can submit PySpark applications to the EMR cluster through AWS CLI.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nEMR 단계를 추가하는 명령어를 작성할 때는 클러스터 드라이버에서 SparkSession이 자동으로 실행될 것이므로 올바른 종속성, 구성 및 PySpark 스크립트를 제출하는 데 주의해야 합니다.\n\n이 방법을 사용하면 종속성이 Maven에서 자동으로 다운로드되는 대신 별도의 jars/ 폴더 내의 jar 파일로 S3에 사용 가능하게 만들어졌으며 PySpark 애플리케이션 자체도 scripts/ 폴더에 저장되었습니다.\n\n아래는 EMR에 create_iceberg_wh_app.py 애플리케이션을 제출하는 명령어의 예시입니다. 이 명령어는 실제로 해둡 카탈로그에 iceberg 웨어하우스를 설정하는 필요한 구성을 가지고 있습니다:\n\n```js\n# CLI를 통해 AWS EMR 클러스터에 단계 추가\n# 실제 클러스터 ID로 j-xxxxxxxxxxx를 대체하세요\naws emr add-steps --profile aws_personal --cluster-id j-xxxxxxxxxxx \\ \n--steps '[{\n  \"Args\":[\"spark-submit\",\n    \"--deploy-mode\",\"client\",\n    \"--jars\",\"s3://iceberg-bucket-9004/jars/hadoop-aws-3.3.4.jar,s3://iceberg-bucket-9004/jars/bundle-2.20.18.jar,s3://iceberg-bucket-9004/jars/aws-java-sdk-bundle-1.11.901.jar,s3://iceberg-bucket-9004/jars/iceberg-spark-runtime-3.3_2.12-1.3.1.jar\",\n    \"--conf\",\"spark.sql.catalog.hadoop_catalog=org.apache.iceberg.spark.SparkCatalog\",\n    \"--conf\",\"spark.sql.extensions=org.apache.iceberg.spark.extensions.IcebergSparkSessionExtensions\",\n    \"--conf\",\"spark.sql.catalog.hadoop_catalog.type=hadoop\",\n    \"--conf\",\"spark.sql.catalog.hadoop_catalog.warehouse=s3://iceberg-bucket-9004/iceberg-warehouse-emr/data-archives/\",\n    \"--conf\",\"spark.sql.catalog.hadoop_catalog.io-impl=org.apache.iceberg.aws.s3.S3FileIO\",\n    \"s3://iceberg-bucket-9004/scripts/create_iceberg_wh_app.py\"],\n  \"Type\":\"CUSTOM_JAR\",\n  \"ActionOnFailure\":\"CONTINUE\",\n  \"Jar\":\"command-runner.jar\",\n  \"Properties\":\"\",\n  \"Name\":\"create_iceberg_wh_via_emr_cli\"\n}]'\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 명령이 성공적으로 실행되면, stepID가 반환됩니다:\n\n![StepID](/TIL/assets/img/2024-07-12-ApacheIceberg4MethodsToCreateAWarehouseWithPySpark_7.png)\n\nEMR 클러스터 UI에서도 동일한 stepID가 나타나며, 이는 PySpark 스크립트가 실행 준비가 된 것을 나타냅니다:\n\n![StepID](/TIL/assets/img/2024-07-12-ApacheIceberg4MethodsToCreateAWarehouseWithPySpark_8.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n작업이 완료되면 클러스터에서 로그가 생성됩니다. 이 경우, 로그에서 TEST_TABLE_EMR_S3_HDP가 카탈로그에 실제로 생성되었음을 확인했습니다:\n\n```js\nINFO:root:Creating SPARK SESSION...\n\nINFO:root:SPARK SESSION created!\n\n+-----------+---------------------+-----------+\n|namespace  |tableName            |isTemporary|\n+-----------+---------------------+-----------+\n|TEST_SCHEMA|TEST_TABLE_EMR_S3_HDP|false      |\n+-----------+---------------------+-----------+\n\nINFO:root:Main APPLICATION was executed!\n```\n\n결과적으로, iceberg-bucket-9004 S3 버킷 내에서 add-steps 명령어의 일부로 지정된 이름인 iceberg-warehouse-emr가 생성되었습니다:\n\n![이미지](/TIL/assets/img/2024-07-12-ApacheIceberg4MethodsToCreateAWarehouseWithPySpark_9.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Method #4: Spark Session On EMR (Via Airflow) + All Layers On S3 Bucket\n\n일반적으로, 실제 환경에서는 Apache Airflow를 사용하여 작업을 조율하며 PySpark 응용 프로그램을 배포하기 위해 EMR에 단계를 자동으로 추가합니다.\n\nAWS EMR에서 Airflow를 사용하여 PySpark 파이프라인을 자동화하는 방법에 대해 자세히 알고 싶다면 이 문서를 참조하십시오.\n\n요약하면, 이 방법은 다음 네 가지 작업을 수행하는 전용 DAG(spark_create_iceberg_wh_dag.py)를 설정하는 것을 포함합니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- create_iceberg_wh_app.py 파일을 iceberg-bucket-9004의 scripts/ 폴더에 업로드합니다 (EMR이 배포할 수 있도록 함).\n- dag_params.json 파일에서 필요한 Spark 작업 구성을 구문 분석하고 EMR에 제출할 명령을 자동으로 빌드하는 데 사용합니다:\n\n```js\n{\n    \"local_conf\":{\n       \"local_sub_folder\":\"/assets/\",\n       \"files_to_upload\":[\"create_iceberg_wh_app.py\"]\n    },\n    \"s3_conf\":{\n       \"bucket_name\":\"iceberg-bucket-9004\",\n       \"s3_scripts_path\":\"scripts/\"\n    },\n    \"spark_submit_cmd\":{\n       \"cmd\":\"[\\\"spark-submit\\\", \\\"--deploy-mode\\\", \\\"client\\\"]\",\n       \"pyspark_exec\":\"scripts/create_iceberg_wh_app.py\"\n    },\n    \"spark_conf\":{\n         \"spark.sql.catalog.hadoop_catalog\": \"org.apache.iceberg.spark.SparkCatalog\",\n         \"spark.sql.extensions\": \"org.apache.iceberg.spark.extensions.IcebergSparkSessionExtensions\",\n         \"spark.sql.catalog.hadoop_catalog.type\": \"hadoop\",\n         \"spark.sql.catalog.hadoop_catalog.warehouse\": \"s3a://iceberg-bucket-9004/iceberg-warehouse-prod-hdp/data-archives/\",\n         \"spark.sql.catalog.hadoop_catalog.io-impl\": \"org.apache.iceberg.aws.s3.S3FileIO\"\n    },\n    \"spark_jars_conf\":{\n       \"bucket_prefix\":\"s3://iceberg-bucket-9004/\",\n       \"bucket_subfolder\":\"jars/\"\n    },\n    \"spark_jars_conf_value\":[\n         \"hadoop-aws-3.3.4.jar\",\n         \"bundle-2.20.18.jar\",\n         \"aws-java-sdk-bundle-1.11.901.jar\",\n         \"iceberg-spark-runtime-3.3_2.12-1.3.1.jar\"\n    ]\n }\n```\n\n- EmrAddStepsOperator를 통해 PySpark 스크립트를 배포하고 실행할 단계를 EMR에 추가하도록 지시합니다.\n- EMRStepSensor를 통해 EMR 단계 상태를 지속적으로 모니터링합니다.\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-ApacheIceberg4MethodsToCreateAWarehouseWithPySpark_10.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n#method3에 대해 이야기해보겠습니다. DAG가 트리거된 직후에 PySpark 스크립트를 실행하는 단계가 EMR UI의 Steps 섹션 아래에 나타납니다.\n\n![Step](/TIL/assets/img/2024-07-12-ApacheIceberg4MethodsToCreateAWarehouseWithPySpark_11.png)\n\n해당 단계가 완료 상태가 되면 S3 버킷 내에 새 Iceberg 웨어하우스인 \"iceberg-warehouse-prod-hdp\"가 생성된 것을 확인할 수 있습니다.\n\n![Iceberg Warehouse](/TIL/assets/img/2024-07-12-ApacheIceberg4MethodsToCreateAWarehouseWithPySpark_12.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론\n\n이 튜토리얼에서는 PySpark를 사용하여 Apache Iceberg 데이터 웨어하우스를 로컬 또는 프로덕션 환경에서 생성하는 네 가지 방법을 소개했습니다.\n\n각 방법은 특정 사용 사례를 다루며 다른 기술 (Docker, MinIo, S3, EMR, Airflow) 및 다른 전략 (로컬에서 실행되는 SparkSession 대 EMR 클러스터에서 실행되는 SparkSession, 데이터베이스에 저장된 카탈로그 레이어 대 S3 버킷 등)을 사용합니다.\n\n현재 문서에 다양한 조합을 제시함으로써 데이터 엔지니어가 Iceberg 오픈 테이블 형식을 기반으로하는 PySpark 애플리케이션을 구축하면서 테스트하는 데 소요되는 시간을 절약하도록 돕는 것이 목표입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 출처\n\n- Apache Iceberg 소개\n- Spark 및 Iceberg 빠른 시작\n- MinIO를 사용한 Apache Iceberg 개발자를 위한 소개\n- Iceberg 및 MinIO를 사용한 Lakehouse 아키텍처 완벽 가이드\n- Apache Iceberg 학습 — 카탈로그를 Postgres에 저장하기\n- Iceberg 항해: Pyspark로 iceberg 테이블 단위 테스트하기","ogImage":{"url":"/TIL/assets/img/2024-07-12-ApacheIceberg4MethodsToCreateAWarehouseWithPySpark_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-ApacheIceberg4MethodsToCreateAWarehouseWithPySpark_0.png","tag":["Tech"],"readingTime":26},{"title":"Python 동시성 프로그래밍 Futures 사용법","description":"","date":"2024-07-12 20:22","slug":"2024-07-12-PythonConcurrencyProgrammingFutures","content":"\n\n\n![Image](/TIL/assets/img/2024-07-12-PythonConcurrencyProgrammingFutures_0.png)\n\n협업 프로그래밍을 올바르고 합리적으로 사용하면 우리 프로그램에 상당한 성능 향상을 가져다 줄 것입니다. 오늘의 글에서는 파이썬에서 동시성 프로그래밍 및 Future를 중점으로 하는 동시성 프로그래밍을 이해하고 적용하는 방법을 안내하겠습니다.\n\n# 동시성과 병렬성: 차이 이해하기\n\n동시성 프로그래밍에 대해 학습할 때 동시성과 병렬성이라는 용어를 함께 사용하는 경우가 많습니다. 이로 인해 많은 사람들이 두 용어가 동일한 것으로 생각되는 오해를 하게 됩니다. 그러나 이는 오인입니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n먼저 일반적으로 오해되는 것을 명확하게 해 봅시다: 파이썬에서 동시성은 여러 작업(스레드 또는 태스크)이 동시에 동시에 발생한다는 것을 의미하지 않습니다. 대신, 한 번에 하나의 작업만 진행되도록 허용하고, 스레드 또는 태스크가 완료될 때까지 서로 전환됩니다. 아래 다이어그램을 살펴보겠습니다:\n\n![Concurrency Diagram](/TIL/assets/img/2024-07-12-PythonConcurrencyProgrammingFutures_1.png)\n\n이 다이어그램은 태스크 전환을 관리하는 두 가지 다른 방법을 보여줍니다. 이는 파이썬에서 동시성의 두 형태에 대응됩니다: 스레딩과 asyncio입니다.\n\n스레딩의 경우, 운영 체제는 각 스레드의 모든 세부 정보를 알고 있기 때문에 필요에 따라 스레드 전환을 처리합니다. 여기서의 장점은 프로그래머가 전환 프로세스를 관리할 필요가 없기 때문에 코드를 작성하기가 더 쉽다는 것입니다. 그러나 이는 레이스 컨디션과 같은 문제로 이어질 수 있습니다. 이는 스레드가 단일 명령문 실행 도중에 서로 간섭할 수 있는 상황을 말합니다(e.g., x += 1).\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러나 asyncio를 사용할 경우, 주 프로그램이 작업을 전환할 수 있다는 것을 명시적으로 알려주어야 합니다. 이러한 설계는 asyncio 이벤트 루프에 의해 제어되는 방식으로 전환되므로 실행 중에 작업이 충돌하지 않도록 보장하여 경쟁 조건을 피할 수 있도록 도와줍니다.\n\n병렬성에 대해 이야기하면, 동시에 동시에 실행되는 작업을 가리킵니다. Python에서 이는 멀티 프로세싱을 통해 달성됩니다. 예를 들어, 컴퓨터가 6코어 프로세서를 사용한다면, 실행 속도를 높이기 위해 6개의 프로세스를 동시에 실행할 수 있습니다. 멀티 프로세싱의 기본 아이디어는 다음과 같이 나타낼 수 있습니다:\n\n![멀티 프로세싱](/TIL/assets/img/2024-07-12-PythonConcurrencyProgrammingFutures_2.png)\n\n두 가지를 비교해보면:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n동시성은 빈번한 I/O 작업이 발생하는 시나리오에서 자주 사용됩니다. 예를 들어, 웹 사이트에서 여러 파일을 다운로드할 때, I/O 작업에 소요되는 시간이 CPU 처리에 소요되는 시간보다 크게 늘어날 수 있습니다.\n\n반면에 병렬성은 CPU 집중적인 시나리오에 더 적합합니다. 예를 들어, MapReduce 병렬 계산에서 여러 대의 기계와 프로세서를 사용하여 작업을 여러 코어 또는 시스템에 분산시켜 실행 속도를 높이는 데 활용됩니다.\n\n# 동시성 프로그래밍의 Futures\n\n## 단일 스레드 및 다중 스레드 접근 방식의 성능 비교\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음으로, 코드 관점에서 Futures를 이해하고 단일 스레드 방식과 성능을 비교하기 위한 구체적인 예제를 사용해보겠습니다.\n\n여러 웹사이트에서 콘텐츠를 다운로드하고 결과를 출력하는 작업이 있다고 가정해봅시다. 단일 스레드 방식을 사용한다면, 코드 구현은 다음과 같이 보일 것입니다 (단순함을 위해 예외 처리는 간단히 생략했습니다):\n\n```js\nimport requests\nimport time\n \ndef download_one(url):\n    resp = requests.get(url)\n    print('{}에서 {}를 읽었습니다.'.format(url, len(resp.content)))\n    \ndef download_all(sites):\n    for site in sites:\n        download_one(site)\n \ndef main():\n    sites = [\n        'https://en.wikipedia.org/wiki/Portal:Arts',\n        'https://en.wikipedia.org/wiki/Portal:History',\n        'https://en.wikipedia.org/wiki/Portal:Society',\n        'https://en.wikipedia.org/wiki/Portal:Biography',\n        'https://en.wikipedia.org/wiki/Portal:Mathematics',\n        'https://en.wikipedia.org/wiki/Portal:Technology',\n        'https://en.wikipedia.org/wiki/Portal:Geography',\n        'https://en.wikipedia.org/wiki/Portal:Science',\n        'https://en.wikipedia.org/wiki/Computer_science',\n        'https://en.wikipedia.org/wiki/Python_(programming_language)',\n        'https://en.wikipedia.org/wiki/Java_(programming_language)',\n        'https://en.wikipedia.org/wiki/PHP',\n        'https://en.wikipedia.org/wiki/Node.js',\n        'https://en.wikipedia.org/wiki/The_C_Programming_Language',\n        'https://en.wikipedia.org/wiki/Go_(programming_language)'\n    ]\n    start_time = time.perf_counter()\n    download_all(sites)\n    end_time = time.perf_counter()\n    print('{}개 사이트를 {}초에 다운로드했습니다.'.format(len(sites), end_time - start_time))\n    \nif __name__ == '__main__':\n    main()\n```\n\n이 방식은 직접적이고 간단한 접근 방식입니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n먼저 웹사이트 목록을 순회합니다. 그 후, 현재 웹사이트에 대한 다운로드 작업을 수행합니다. 현재 작업이 완료될 때까지 기다렸다가 다음 웹사이트로 넘어가며, 모든 작업이 완료될 때까지 이 과정을 계속합니다.\n\n총 소요 시간은 약 2.4초인 것을 확인할 수 있습니다. 단일 스레드 방식의 장점은 간단함에 있지만, 대부분의 시간이 I/O 작업을 기다리며 보내므로 효율적이지 않습니다. 프로그램은 각 웹사이트의 다운로드가 끝날 때까지 기다려야 다음 작업을 시작할 수 있습니다. 웹사이트 다운로드해야 하는 수가 수천 개에 달하는 현실적인 프로덕션 환경에서는 이 방식이 실행하기에 적합하지 않습니다.\n\n그 다음, 코드의 멀티 스레드 버전을 살펴봅시다:\n\n```js\nimport concurrent.futures\nimport requests\nimport threading\nimport time\n \ndef download_one(url):\n    resp = requests.get(url)\n    print('Read {} from {}'.format(len(resp.content), url))\n \ndef download_all(sites):\n    with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:\n        executor.map(download_one, sites)\n \ndef main():\n    sites = [\n        'https://en.wikipedia.org/wiki/Portal:Arts',\n        'https://en.wikipedia.org/wiki/Portal:History',\n        'https://en.wikipedia.org/wiki/Portal:Society',\n        'https://en.wikipedia.org/wiki/Portal:Biography',\n        'https://en.wikipedia.org/wiki/Portal:Mathematics',\n        'https://en.wikipedia.org/wiki/Portal:Technology',\n        'https://en.wikipedia.org/wiki/Portal:Geography',\n        'https://en.wikipedia.org/wiki/Portal:Science',\n        'https://en.wikipedia.org/wiki/Computer_science',\n        'https://en.wikipedia.org/wiki/Python_(programming_language)',\n        'https://en.wikipedia.org/wiki/Java_(programming_language)',\n        'https://en.wikipedia.org/wiki/PHP',\n        'https://en.wikipedia.org/wiki/Node.js',\n        'https://en.wikipedia.org/wiki/The_C_Programming_Language',\n        'https://en.wikipedia.org/wiki/Go_(programming_language)'\n    ]\n    start_time = time.perf_counter()\n    download_all(sites)\n    end_time = time.perf_counter()\n    print('Download {} sites in {} seconds'.format(len(sites), end_time - start_time))\n\nif __name__ == '__main__':\n    main()\n\n## Output\nRead 151021 from https://en.wikipedia.org/wiki/Portal:Mathematics\nRead 129886 from https://en.wikipedia.org/wiki/Portal:Arts\nRead 107637 from https://en.wikipedia.org/wiki/Portal:Biography\nRead 224118 from https://en.wikipedia.org/wiki/Portal:Society\nRead 184343 from https://en.wikipedia.org/wiki/Portal:History\nRead 167923 from https://en.wikipedia.org/wiki/Portal:Geography\nRead 157811 from https://en.wikipedia.org/wiki/Portal:Technology\nRead 91533 from https://en.wikipedia.org/wiki/Portal:Science\nRead 321352 from https://en.wikipedia.org/wiki/Computer_science\nRead 391905 from https://en.wikipedia.org/wiki/Python_(programming_language)\nRead 180298 from https://en.wikipedia.org/wiki/Node.js\nRead 56765 from https://en.wikipedia.org/wiki/The_C_Programming_Language\nRead 468461 from https://en.wikipedia.org/wiki/PHP\nRead 321417 from https://en.wikipedia.org/wiki/Java_(programming_language)\nRead 324039 from https://en.wikipedia.org/wiki/Go_(programming_language)\nDownload 15 sites in 0.19936635800002023 seconds\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n총 시간이 약 0.2초로 나타나는 것은 효율성이 10배 이상 향상되었다는 사실을 알 수 있어요.\n\n다중 스레드 버전과 단일 스레드 버전 사이의 주요 차이점을 살펴보겠어요:\n\n```js\nwith concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:\n        executor.map(download_one, sites)\n```\n\n여기서는 5개의 스레드를 사용할 수 있는 스레드 풀을 생성했어요. executor.map()은 파이썬 내장 map() 함수와 유사하며, 각각의 urls 요소에 download_one() 함수를 동시에 적용해요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여담이지만, download_one() 함수에서 사용하는 requests.get() 메서드는 스레드 안전(thread-safe)하므로 경합 상태를 일으키지 않고 여러 스레드 환경에서 안전하게 사용할 수 있습니다.\n\n또한, 스레드의 개수는 사용자가 정의할 수 있지만, 더 많은 스레드가 항상 좋은 것은 아닙니다. 그 이유는 스레드를 생성, 유지 및 소멸하는 데 일정한 오버헤드가 발생하기 때문입니다. 스레드의 개수를 지나치게 높게 설정하면 오히려 성능이 떨어질 수 있습니다. 종종 실제 요구 사항에 기반하여 최적의 스레드 개수를 찾기 위해 몇 가지 테스트를 수행해야 합니다.\n\n물론 프로그램 효율성을 향상시키기 위해 병렬성(parallelism)을 사용할 수도 있습니다. 이를 위해 download_all() 함수에서 다음과 같이 변경할 수 있습니다:\n\n```js\nwith futures.ThreadPoolExecutor(workers) as executor\n=\u003e\nwith futures.ProcessPoolExecutor() as executor:\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n코드를 변경해야 하는 부분에서는 ProcessPoolExecutor() 함수를 사용하여 병렬로 작업을 실행할 수 있는 프로세스 풀을 생성합니다. 그러나 여기서 worker 매개변수를 종종 생략하는데, 시스템이 사용 가능한 CPU 코어 수를 자동으로 프로세스로 활용할 수 있기 때문입니다.\n\n이전에 언급한 대로, 병렬성은 일반적으로 CPU 바운드 시나리오에서 사용됩니다. I/O 바운드 작업의 경우 대부분의 시간이 대기 상태에 소요되며, 여러 프로세스를 사용하는 것은 멀티 스레딩과 비교하여 효율성을 향상시키지 않습니다. 실제로 CPU 코어의 제한으로 인해 멀티 프로세싱의 성능이 종종 멀티 스레딩보다 나쁠 수 있습니다.\n\n# Futures란 정확히 무엇인가요?\n\n파이썬에서 Futures 모듈은 concurrent.futures와 asyncio에 위치하며, 둘 다 지연된 작업을 나타냅니다. Futures는 대기 상태에 있는 작업을 래핑하여 큐에 배치합니다. 이러한 작업의 상태는 언제든지 쿼리할 수 있으며, 작업이 완료된 후 결과 또는 예외를 검색할 수도 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n일반적으로 사용자들은 미래(Futures)를 생성하는 방법에 대해 걱정할 필요가 없습니다. 내부 메커니즘이 대신 처리해 주기 때문이죠. 실제로 해야 할 일은 이러한 Futures를 실행할 수 있도록 예약하는 것입니다.\n\n예를 들어, Futures 모듈에서 Executor 클래스를 사용하면 executor.submit(func) 메서드를 사용하여 작업을 제출할 수 있습니다. 이 메서드는 func() 함수를 실행할 수 있도록 예약하고 작업을 나타내는 Future 객체를 반환합니다. 그런 다음 이 Future 객체를 사용하여 작업의 상태를 조회하거나 결과를 검색할 수 있습니다.\n\nFutures 모듈에서 자주 사용되는 몇 가지 메서드는 다음과 같습니다:\n\n- done(): 해당 작업이 완료되었는지 확인하는 메서드입니다. True는 작업이 완료되었음을 나타내고, False는 아직 진행 중이라는 뜻입니다. done()은 비차단 방식으로 동작하며 결과를 즉시 반환합니다.\n- add_done_callback(fn): 이 메서드는 Future가 완료되면 실행될 콜백 함수 fn을 등록합니다. 콜백 함수 fn은 Future가 작업을 완료한 후에 알림을 받고 호출됩니다.\n- result(): 이 메서드는 Future의 결과 또는 예외를 반환합니다. Future가 완료되었을 때 호출합니다. Future가 예외를 만났다면 result()는 해당 예외를 발생시킵니다.\n- as_completed(fs): 이 함수는 Futures fs의 반복자를 가져와 완료될 때마다 Futures를 생성하는 반복자를 반환합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그래서, 앞서 언급한 예제는 다음과 같은 형식으로도 작성할 수 있습니다:\n\n```js\nimport concurrent.futures\nimport requests\nimport time\n\ndef download_one(url):\n    resp = requests.get(url)\n    print('Read {} from {}'.format(len(resp.content), url))\n\ndef download_all(sites):\n    with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:\n        to_do = []\n        for site in sites:\n            future = executor.submit(download_one, site)\n            to_do.append(future)\n\n        for future in concurrent.futures.as_completed(to_do):\n            future.result()\n\ndef main():\n    sites = [\n        'https://en.wikipedia.org/wiki/Portal:Arts',\n        'https://en.wikipedia.org/wiki/Portal:History',\n        'https://en.wikipedia.org/wiki/Portal:Society',\n        'https://en.wikipedia.org/wiki/Portal:Biography',\n        'https://en.wikipedia.org/wiki/Portal:Mathematics',\n        'https://en.wikipedia.org/wiki/Portal:Technology',\n        'https://en.wikipedia.org/wiki/Portal:Geography',\n        'https://en.wikipedia.org/wiki/Portal:Science',\n        'https://en.wikipedia.org/wiki/Computer_science',\n        'https://en.wikipedia.org/wiki/Python_(programming_language)',\n        'https://en.wikipedia.org/wiki/Java_(programming_language)',\n        'https://en.wikipedia.org/wiki/PHP',\n        'https://en.wikipedia.org/wiki/Node.js',\n        'https://en.wikipedia.org/wiki/The_C_Programming_Language',\n        'https://en.wikipedia.org/wiki/Go_(programming_language)'\n    ]\n    start_time = time.perf_counter()\n    download_all(sites)\n    end_time = time.perf_counter()\n    print('Download {} sites in {} seconds'.format(len(sites), end_time - start_time))\n\nif __name__ == '__main__':\n    main()\n\n## 결과\nhttps://en.wikipedia.org/wiki/Portal:Arts에서 129,886을 읽음\nhttps://en.wikipedia.org/wiki/Portal:Biography에서 107,634을 읽음\nhttps://en.wikipedia.org/wiki/Portal:Society에서 224,118을 읽음\nhttps://en.wikipedia.org/wiki/Portal:Mathematics에서 158,984을 읽음\nhttps://en.wikipedia.org/wiki/Portal:History에서 184,343을 읽음\nhttps://en.wikipedia.org/wiki/Portal:Technology에서 157,949을 읽음\nhttps://en.wikipedia.org/wiki/Portal:Geography에서 167,923을 읽음\nhttps://en.wikipedia.org/wiki/Portal:Science에서 94,228을 읽음\nhttps://en.wikipedia.org/wiki/Python_(programming_language)에서 391,905을 읽음\nhttps://en.wikipedia.org/wiki/Computer_science에서 321,352을 읽음\nhttps://en.wikipedia.org/wiki/Node.js에서 180,298을 읽음\nhttps://en.wikipedia.org/wiki/Java_(programming_language)에서 321,417을 읽음\nhttps://en.wikipedia.org/wiki/PHP에서 468,421을 읽음\nhttps://en.wikipedia.org/wiki/The_C_Programming_Language에서 56,765을 읽음\nhttps://en.wikipedia.org/wiki/Go_(programming_language)에서 324,039을 읽음\n15개 사이트를 0.21698231499976828초에 다운로드함\n```\n\n여기서, 우리는 먼저 executor.submit()를 호출하여 각 웹사이트에서 내용을 다운로드하는 작업을 to_do라는 미래 큐에 넣고 실행을 대기시킵니다. 그런 다음 as_completed() 함수를 사용하여 각 미래가 완료될 때마다 결과를 출력합니다.\n\n그러나 미래가 완료되는 순서가 목록의 순서와 일치하는 것은 아님을 유의해야 합니다. 완료 순서는 시스템 스케줄링 및 각 미래의 실행 시간에 따라 달라집니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 왜 멀티스레딩에서 한 번에 하나의 스레드만 실행될 수 있을까요?\n\n이전에 파이썬에서 메인 프로그램에서 한 번에 하나의 스레드만 실행될 수 있다고 언급했습니다. 이게 왜 그런 걸까요?\n\n나중에 더 자세히 배울 Global Interpreter Lock (GIL) 개념을 간단히 소개해 드리겠습니다.\n\n사실 파이썬 인터프리터는 스레드로부터 안전하지 않습니다. 동시 스레드로 인한 레이스 컨디션과 같은 문제를 해결하기 위해 파이썬은 Global Interpreter Lock (GIL)를 도입했습니다. 이 잠금은 한 번에 한 스레드만 파이썬 바이트코드를 실행할 수 있도록 보장합니다. 그러나 스레드가 I/O 작업으로 인해 차단될 때 GIL이 해제되어 다른 스레드가 계속해서 실행될 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론\n\n이 글에서는 파이썬에서 동시성과 병렬성의 개념과 차이점을 먼저 살펴보았습니다.\n\n동시성은 스레드와 작업 간에 전환을 통해 달성되지만, 어떤 순간에는 한 스레드 또는 작업만 실행될 수 있습니다. 반면에 병렬성은 여러 프로세스가 동시에 실행되는 것을 의미합니다.\n\n동시성은 일반적으로 빈번한 I/O 작업이 있는 시나리오에서 사용되고, 병렬성은 CPU 집약적인 작업에 더 적합합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리는 웹 사이트 콘텐츠를 다운로드하는 예제를 통해 단일 스레드 방식과 Futures를 사용한 멀티 스레딩 버전 사이의 성능 차이를 비교했습니다. 잘 구현된 멀티 스레딩 접근 방식이 프로그램의 효율성을 크게 향상시킬 수 있다는 것이 명백합니다.\n\n또한 Futures의 구체적인 원리를 탐구했습니다. done(), result(), as_completed()과 같은 일반적인 함수들을 다루며, 예제를 통해 그 사용법을 설명했습니다.\n\n기억해야 할 중요한 점은 Python이 글로벌 인터프리터 락(GIL) 때문에 한 번에 하나의 스레드만 실행되도록 한다는 것입니다. 그러나 I/O 작업에 대해서는 스레드가 차단될 때 GIL이 해제되어 다른 스레드가 계속 실행될 수 있습니다.\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-PythonConcurrencyProgrammingFutures_3.png\" /\u003e","ogImage":{"url":"/TIL/assets/img/2024-07-12-PythonConcurrencyProgrammingFutures_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-PythonConcurrencyProgrammingFutures_0.png","tag":["Tech"],"readingTime":17},{"title":"스태킹 앙상블 기법 이해하고 활용하는 방법","description":"","date":"2024-07-12 20:20","slug":"2024-07-12-TheStackingEnsembleMethod","content":"\n\n기계 학습에서 쌓기의 힘을 발견해보세요. 이 기술은 여러 모델을 하나로 결합하여 강력한 예측기로 만드는 기법입니다. 이 기사에서는 쌓기의 기초부터 고급 기술까지 살펴보고, 다양한 모델의 장점을 결합하여 정확성을 향상시키는 방법을 소개합니다. 쌓기에 익숙하지 않은 분들이나 최적화 전략을 찾고 계신 분들을 위해, scikit-learn을 활용하여 예측 모델링을 높이는 실용적인 통찰과 팁을 제공합니다.\n\n이 기사는 scikit-learn을 바탕으로 작성되었지만, scikit-learn의 쌓기 모델을 구현하고 모방하는 순수한 Python 클래스를 제공합니다. 이 순수한 Python 구현을 검토하는 것은 여러분의 이해도를 확인하고 테스트하는 데 훌륭한 방법입니다.\n\n이 게시물에서는 다음을 확인하게 됩니다:\n\n- 쌓기가 머신러닝의 앙상블 기법 중 일부인지\n- 쌓기가 예측을 제공하기 위해 내부적으로 어떻게 작동하는지\n- 쌓기가 어떻게 fitting되는지\n- “리스택”이 무엇인지\n- 다층 쌓기를 어떻게 생성할 수 있는지\n- 왜 기본 모델의 성능을 검사해야 하는지\n- 스택 모델의 사용을 조정하고 최적화하는 방법\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\"테이블\" 태그를 마크다운 형식으로 변경해주세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\"’베이스 모델’이라 함은 만날 수 있는 모든 전통적인 모델을 의미합니다 - scikit-learn에서 직접 가져와 학습하고 예측할 수 있는 모델입니다. 이러한 베이스 모델은 예를 들어 다음과 같습니다:\n\n- 선형 회귀나 로지스틱 회귀 (및 이들의 변형인 LASSO 또는 리지)\n- 서포트 벡터 회귀 또는 분류기\n- 의사결정 트리 회귀 또는 분류기\n- K-최근접 이웃 회귀 또는 분류기\n\n각각의 이 모델들은 장단점이 있고, 하이퍼파라미터들이 있으며, ‘편안한’ 영역이 있습니다. 따라서, 이 모델들은 여러분의 머신러닝 문제에서 서로 다르게 수행할 수 있습니다: 데이터셋 전체에서 다른 점수를 가질 뿐만 아니라, 데이터셋의 일부 샘플/영역에서는 더 나은 성능을 발휘할 수도 있고, 다른 곳에서는 더 나쁠 수도 있습니다.\n\n앙상블 방법의 일반적인 아이디어는 여러 이러한 베이스 모델을 하나의 더 나은 모델로 결합하는 것입니다. 스태킹 기술에서는 이러한 모델들을 건물의 벽돌로 사용하고 예측을 결합하는 수단으로 사용할 것입니다.\"\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n일반적인 앙상블 모델 기술 중 몇 가지를 빠르게 살펴봅시다:\n\n- 투표: 투표 앙상블은 일련의 기본 모델에서 생성되며, 최종 예측은 기본 모델의 예측을 평균 (회귀의 경우)하거나 가장 예측 클래스 (분류의 경우)로 간단히 계산하여 얻습니다. 이것은 가장 간단한 앙상블 기술 중 하나이며 이해하고 설명하기 가장 쉽습니다.\n- 부스팅: 일련의 약한 학습자들의 (거의 더미 모델) 예측이 순환적으로 가중치를 사용하여 조정됩니다. 이 기술은 Adaboost 알고리즘과 GradientBoosting으로 이어지며 성능이 우수한 모델 중 하나입니다.\n- 배깅: 부트스트랩 집계라고도 하는 병렬 앙상블 기술로, 여러 개별 모델이 전체 데이터 세트의 다른 하위 집합에 적합됩니다. 이러한 모델의 예측은 그런 다음 (투표/평균 사용) 결합됩니다. 개별 모델이 결정 트리인 경우, 이 기술은 랜덤 포레스트 알고리즘으로 이어집니다.\n- 스태킹: 이 게시물이 설명하는 앙상블 기술입니다. 계속 읽어 보세요!\n\n그래서 스태킹은 앙상블 기술 중 하나일 뿐입니다. 스태킹은 위의 앙상블 기술들과 많은 면에서 다릅니다:\n\n- 기본 모델을 순차적으로 결합하지 않습니다.\n- 모델의 가중치를 순환적으로 업데이트하지 않습니다.\n- 기본 모델의 예측을 단순히 평균화하지 않습니다.\n- 다양한 종류의 모델 (LinReg, KNN, SVM 등) 모음과 함께 작동합니다. 반면에 배깅과 부스팅은 일반적으로 동일한 기본 모델 (보통 결정 트리)의 모음을 사용합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 스태킹 작동 방식\n\n스태킹 방법의 가장 큰 차이점과 특징 중 하나는 기본 모델의 구조와 최종 예측을 계산하는 방식입니다. 스태킹 앙상블의 구조는 다음과 같습니다:\n\n- 일련의 기본 모델이 앙상블을 이룸: 이들은 독립적으로 훈련되고 예측합니다. 이러한 모델은 \"기본 레이어\" 또는 스택 구조의 \"0층\"이라고도 불립니다. 이러한 기본 모델은 부스팅/배깅 컨텍스트에서와 같이 \"약 학습기(weak learners)\"로 불릴 수도 있지만, 엄격히 말하면 약 학습기는 아닙니다.\n- 또 다른 단일 모델이 기본 모델의 예측을 감싸 최종 예측을 계산합니다. 이 모델은 \"최종 레이어\" 또는 \"1층\"이라고도 불립니다.\n\n다음과 같이 도식화됩니다 (우리는 지금 예측 과정에 초점을 맞춥니다):\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![Image](/TIL/assets/img/2024-07-12-TheStackingEnsembleMethod_1.png)\n\n스태킹의 특징 중요한 것은 다음과 같습니다: 내부적으로 스택의 최종 모델은 일반적인 입력 데이터 집합 X와 함께 작동하지 않고, 대신에 베이스 모델의 예측값에서 학습/예측합니다. 아이디어는 모델을 사용하여 기초 모델이 출력 y를 예측하는 방법을 학습하고, 이러한 예측을 실제 참값 y_true와 비교하는 것입니다.\n\n모델이 적합화된 후, 예측 프로세스는 간단히 다음과 같이 이루어집니다: 새로운 X 데이터 집합(또는 단일 샘플 x)에 대해\n\n- 모든 베이스 모델 예측이 독립적으로 계산됩니다: 모델로 기초 모델에 대해 y_pred=model.predict(X)를 수행합니다.\n- 이러한 y_pred 벡터들은 가로로 연결(concatenated)되어 새로운 2D 데이터 집합을 만들게 되는데, 이 과정에 각 열은 특정 기초 모델에 대한 예측을 나타내고 이 행렬을 X_final이라고 부릅니다. 이것은 최종 추정기의 2D 입력 데이터 집합을 나타냅니다.\n- 이 X_final 2D 데이터 집합은 최종 추정기에 의해 실제 최종 예측을 예측하는 데 사용됩니다: final.predict(X_final)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-TheStackingEnsembleMethod_2.png\" /\u003e\n\n다시 말해, 스태킹은 기본 모델의 y-예측으로 구성된 내부 2D 데이터셋 행렬이 생성되고, 이 행렬이 최종 모델의 입력으로 사용된다는 것을 의미합니다. 따라서 최종 모델은 y-공간 값의 2D 행렬을 입력으로 받아 실제 1D 예측인 y-공간 값의 출력을 생성합니다.\n\n스태킹을 보는 다른 방법은 간단히 투표 모델로 볼 수 있지만, 평균값/가장 많이 투표된 예측을 가져오는 것이 아니라 이러한 예측값을 다른 모델에 공급하는 것입니다. 다시 말해, 스태킹을 사용하여 투표를 흉내 내기 위해 최종 모델로 평균화/argmax 모델을 사용할 수 있습니다.\n\n일반적으로 회귀 문제의 경우 최종 모델로는 간단한 LinearRegression을, 분류 문제의 경우 LogisticRegression을 사용하며, 이러한 모델은 scikit-learn의 StackingClassifier 및 StackingRegressor의 기본값입니다. 최종 추정기에 의해 기본 모델의 예측을 결합하는 단계는 종종 \"블렌딩\"이라고 불리며, 모든 모델의 예측이 단일 예측으로 혼합됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 스택 모델을 적절하게 적합시키는 방법\n\n스택 모델이 작동하는 구체적인 방식 때문에 특정한 적합 절차를 사용해야 합니다.\n\nscikit-learn에서는 어떤 추정기든 자동으로 이 작업이 처리됩니다. 따라서 스택 모델을 사용하기 위해 이 적합 절차를 이해할 필요는 절대적으로 없습니다. 한편, 모델이 어떻게 작동하는지 이해하는 것은 항상 좋은 일이죠. 또한 새로운 것을 배우는 것은 굉장히 재밌고 만족스러운 경험입니다!\n\n스택을 적합시키는 알고리즘은 2단계로 나눌 수 있습니다. 첫 번째는 매우 간단한데, 두 번째는 조금 더 설명이 필요합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 단계 1: 모든 기본 모델(레이어 0에서 온 모델)은 완전히 독립적으로 피팅되며 전체 X/y 데이터셋을 사용합니다. 다시 말해, 첫 번째 단계는 아래와 같습니다: base_models의 각 모델에 대해 model.fit(X, y)를 실행하는 것과 동일합니다.\n- 단계 2: 최종 추정기는 피팅되지 않은 기본 모델을 사용하여 교차 검증 체계를 활용하여 피팅됩니다.\n\n첫 번째 단계는 상당히 명확합니다: 스택 모델인 stack.fit(X, y)에 대해 fit 메서드가 호출되면, X와 y가 각기의 기본 모델로 전달되어 서로 독립적으로 피팅이 진행됩니다. 이 단계는 base_models의 각 모델에 대해 model.fit(X, y)를 실행하는 것과 동일합니다. 이러한 피팅된 추정기는 stack 모델의 stack.estimators_ 속성에 저장됩니다.\n\n그런 다음 최종 추정기를 훈련시키기 위해 다른 방법이 사용됩니다. 이미 해당 피팅을 위한 대상 출력 y가 있지만, 여전히 기본 모델들의 예측으로 생성된 중간 X_final 데이터셋을 생성해야 합니다. 이미 피팅된 추정기들에 .predict 메서드를 사용하는 것은 입력 X가 이미 기본 추정기에 의해 보고되고 훈련되었기 때문에 어떤 종류의 오버피팅을 초래할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-TheStackingEnsembleMethod_4.png\" /\u003e\n\n다시 말해 이미 학습된 기본 추정기를 사용하여 입력 데이터 세트를 최종 추정기에 맞출 수 없습니다. 대신, 각 추정기는 동일한 교차 검증 폴드로 cross_val_predict 함수에 공급되어 모든 기본 추정기에 대한 y_pred를 생성합니다. 이러한 기본 예측값은 X_final 훈련 데이터 세트에 수평으로 연결되어 최종 추정기가 X_final, y로 적합하게 됩니다.\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-TheStackingEnsembleMethod_5.png\" /\u003e\n\n이제 문제를 아래와 같이 분해하는 방법을 알게 되었습니다: \"최종 추정기가 대상 y에 적합하도록 사용하는 X 데이터 세트는 모든 추정기에 의해 제공된 예측 값들을 연결하여 생성됩니다. (모든 추정기에 대해 동일한 cv 전략을 사용하여, 모든 기본 추정기가 항상 동일한 입력/출력을 보는 사실을 고려하기 위함). 이는 첫 번째 단계에서 적합된 기본 모델들(전체 X 데이터 세트로 적합된 모델들)이 최종 추정기를 적합하기 위해 사용되지 않는다는 것을 의미합니다. 대신, 각 폴드에 대해 적합되지 않은 기본 모델의 사본이 사용되며, 각 폴드에 대한 예측값이 연결되어 X_final을 생성합니다. (각 모델에 대해 수직으로, 그리고 수평으로 X_final을 만들기 위해)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](/TIL/assets/img/2024-07-12-TheStackingEnsembleMethod_6.png)\n\n이 방법을 통해 최종 추정기는 베이스 모델의 예측값이 이미 확인되지 않은 샘플에 적합됩니다.\n\n이 적합 절차를 보는 또 다른 방법은 교차 검증 데이터 폴드 분해에서 중간 2D 데이터 세트 X_final을 표현하는 것입니다: X 데이터 세트는 N 개의 폴드(X_train, X_test, y_train, y_test)로 분할됩니다. 폴드는 각 개별 샘플이 테스트 세트로 한 번만 사용되는 \"분할\" 기준을 준수해야 합니다. 이 분할의 각각에 대해 미적합 기본 모델의 복사본이 .fit(X_train, y_train)을 사용하여 적합되고, 해당 예측값이 .predict(X_test)을 사용하여 계산됩니다. 이렇게 하면 모든 베이스 모델에 대한 모든 분할에 대해 y_pred를 얻을 수 있습니다. 최종 X_train은 모든 분할의 예측값을 수직으로 연결한 것입니다.\n\n# 리스태킹\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n스태킹 아키텍처는 모델의 추가적인 사용자 정의를 가능하게 합니다. 이는 모델이 작동하는 방식을 조정할 수 있는 하이퍼파라미터로 생각할 수 있습니다. 아이디어는 정말 간단합니다: 베이스 모델의 수평으로 쌓인 예측뿐만 아니라 원본 입력 X 데이터 집합도 마지막 추정기의 입력에 추가됩니다. 이렇게 하면 최종 추정기가 베이스 모델의 예측과 원본 데이터를 모두 포함하여 데이터에서 더 많은 정보를 찾을 수 있습니다. 다시 말해, 스태킹 모델의 복잡성은 마지막 모델의 입력 특성의 수를 늘림으로써 증가됩니다.\n\n사이킷런에서는 이를 스택 모델의 passthrough=True 매개변수를 통해 수행합니다.\n\n![Stacking Ensemble Method](/TIL/assets/img/2024-07-12-TheStackingEnsembleMethod_7.png)\n\n물론 X 행렬은 학습 시간과 예측 시간 모두 X_final에 추가됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 다층\n\n스태킹 모델의 디자인 방식을 통해 추가적인 스택을 간단히 만들 수 있어 더 복잡한 모델을 만들 수 있습니다. 이는 새로운 스택을 중첩하여 수행될 수 있는데, 새로운 스택은 이전 스택의 최종 에스티메이터로 설정됩니다. 이 작업은 모델의 복잡성을 높이지만, 학습/예측 시간과 과적합 가능성이 증가할 수 있다는 점을 유의해야 합니다.\n\n![이미지](/TIL/assets/img/2024-07-12-TheStackingEnsembleMethod_8.png)\n\n# 스택 모델 튜닝\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이미 언급한 대로, 스태킹은 각 베이스 모델의 최상의 부분을 유지하려는 목적으로, 서로의 약점을 보완할 수 있도록 하는 것을 목표로 합니다. 즉, 모든 모델이 동일한 샘플에서 동일한 성능을 발휘한다면, 스택 모델은 어떤 개선도 이루어지지 않을 것입니다. 따라서 다양한 데이터셋의 위상 영역에서 이상적으로 성능을 발휘하는 서로 다르게 작용하는 베이스 모델을 사용하여 스택 모델을 최적화할 수 있습니다.\n\n따라서 베이스 모델이 어떻게 성능을 발휘하고, 그들의 예측 오류가 서로 상관 관계가 있는지 여부를 검토하는 것이 좋은 아이디어일 수 있습니다. 두 모델이 거의 동일한 오류를 공유한다면, 한 모델은 아마 버릴 수 있을 것입니다 - 전반적인 성능을 유지하면서 연산 복잡성을 줄일 수 있습니다.\n\n스택은 모든 베이스 모델과 최종 모델을 포함하므로, 모든 하이퍼파라미터를 상속합니다. 스택의 성능에 관심을 가지기 때문에 베이스 모델의 성능에 엄격하게 초점을 맞추는 것이 아니라, 그들의 하이퍼파라미터는 스택에서 튜닝되어야 합니다. 다시 말해, 베이스 모델은 하이퍼파라미터 A로 혼자서 더 나은 성능을 발휘할 수 있지만, 스택의 성능은 하이퍼파라미터 B로 더 나을 수 있습니다.\n\n마지막으로, passthrough=True 또는 False를 사용하여 스택 모델을 조정하는 또 다른 방법이 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n일반적으로, 스택이 있는지 기본 모델과 동일한 성능을 발휘하는지 항상 확인해야 합니다. 그렇다면, 스택을 버리거나 조정해야 합니다. 높은 계산 복잡성은 상당한 성능 향상과 함께 제공된다는 것을 명심해야 합니다.\n\n스태킹은 앙상블 모델의 한 형태이므로, 개별 모델이 완벽하지 않다고 해서 항상 안 좋은 것은 아닙니다. 목표는 모델의 성능이 서로 보완될 수 있도록 하는 것입니다 — 마치 약한 학습자들이 결합되어 더 나은 모델이 만들어지는 것처럼요.\n\n실제로, 스택 예측기는 기본 계층의 최고 예측기만큼 잘 예측하며 때로는 이러한 예측기의 서로 다른 강점을 결합함으로써 이를 앞지르기도 합니다. 그러나 스택 예측기로 훈련과 예측을 하는 것은 계산적으로 비용이 많이 드는 일입니다.\n\n# scikit-learn을 사용한 스태킹\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 우리는 스태킹에 대해 모두 알았으니, scikit-learn과 함께 어떻게 사용하는지 살펴봅시다. 기억해야 할 유일한 것은 scikit-learn에서 스태킹이 모델/메타-모델로 구현된다는 것입니다:\n\n- .fit 및 .predict 메서드를 가진 모델이다.\n- 다른 모델을 입력으로 받는 메타-모델이다.\n\nScikit-learn은 앙상블 모듈에서 분류 및 회귀용 스태킹 모델을 제공합니다. 회귀용 매우 간단한 예제를 살펴보겠습니다:\n\n```python\n%matplotlib qt\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn.datasets import load_iris, make_moons, make_circles\nfrom sklearn.model_selection import StratifiedKFold, train_test_split, cross_validate\nfrom sklearn.svm import SVC, LinearSVC\nfrom sklearn.naive_bayes import GaussianNB\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.linear_model import LogisticRegressionCV, LogisticRegression\nfrom sklearn.ensemble import StackingClassifier\n\nX, y = make_circles(n_samples=500, noise=0.3, factor=0.5, random_state=1, shuffle=True)\n\n# 3개의 기본 모델을 사용합니다.\nbase_models = [\n    ('knn', KNeighborsClassifier(n_neighbors=3)),\n    ('logreg', LogisticRegression(max_iter=1000)),\n    ('svc', SVC(C=0.05)),\n]\n\n# 기본 모델을 사용하여 스택을 만들고 최종 예측기로 LogisticRegression을 사용합니다.\nstack = StackingClassifier(\n    estimators=base_models,\n    final_estimator=LogisticRegressionCV(max_iter=1000)\n)\n\nrestack = StackingClassifier(\n    estimators=base_models,\n    final_estimator=LogisticRegressionCV(max_iter=1000),\n    passthrough=True,\n)\n\n# 그런 다음 모든 모델을 비교할 수 있는 멋진 목록을 만듭니다.\nmodels = base_models + [('stack', stack), ('restack', restack)]\n\nX_train, X_test, y_train, y_test = train_test_split(X, y, stratify=y)\n\nfor name, model in models:\n    model.fit(X_train, y_train)\n\n\n# stacking classifier의 결정 경계\nx_min, x_max = X[:, 0].min() - 1, X[:, 0].max() + 1\ny_min, y_max = X[:, 1].min() - 1, X[:, 1].max() + 1\nxx, yy = np.meshgrid(np.arange(x_min, x_max, 0.2),\n                     np.arange(y_min, y_max, 0.2))\n\nfig, axes = plt.subplots(1, len(models), sharex=True, sharey=True)\nfor ax, (name, model) in zip(axes, models):\n    Z = model.predict(np.c_[xx.ravel(), yy.ravel()])\n    Z = Z.reshape(xx.shape)\n    ax.contourf(xx, yy, Z, alpha=0.8)\n    ax.scatter(X_test[:, 0], X_test[:, 1], c=y_test, edgecolors='k')\n    ax.set_title(f\"{name} 점수={model.score(X_test, y_test):.2f}\")\n    ax.set_xlabel(\"특성 1\")\n    ax.set_ylabel(\"특성 2\")\nfig.tight_layout()\r\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n완벽을 위해 stack의 다시 쌓은 버전을 추가했습니다. 플롯을 보면 기본 모델을 결합하면 stack의 성능이 기본 모델 중 가장 좋은 성능을 조금 능가한다는 것을 알 수 있습니다. 다시 쌓기를 사용하면 성능이 더 조금 향상됩니다.\n\n위에서 설명한 것은 모델 스택을 만드는 방법을 보여줄 뿐, 실제 성능 추정을 위해서는 튜닝과 교차 검증이 필요합니다.\n\n## \"처음부터\" 스택 구성하기\n\n이제 scikit-learn API를 사용하여 스태킹의 간단한 구현을 살펴보겠습니다. 이것은 스태킹이 그렇게 복잡하지 않다는 것을 보여주는 장난감 예제에 불과합니다. 학습/설명 목적 이외에는 scikit-learn의 구현을 사용해야 합니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nimport numpy as np\nfrom sklearn.datasets import load_diabetes\nfrom sklearn.ensemble import RandomForestRegressor\nfrom sklearn.linear_model import Ridge\nfrom sklearn.model_selection import cross_validate\nfrom sklearn.base import BaseEstimator, RegressorMixin, TransformerMixin, clone\nfrom sklearn.model_selection import cross_val_predict\n\nclass HomeMadeStackingRegressor(BaseEstimator, RegressorMixin, TransformerMixin):\n    def __init__(self, base_estimators, meta_estimator):\n        self.base_estimators = base_estimators\n        self.meta_estimator = meta_estimator\n\n    def fit(self, X, y):\n        self.base_estimators_ = [clone(est) for est in self.base_estimators]\n        self.meta_estimator_ = clone(self.meta_estimator)\n\n        # Fit base estimators independently\n        for est in self.base_estimators_:\n            est.fit(X, y)\n\n        # Generate X_final feature dataset for the final estimator\n        # as the concatenation of the cross_val_predict results of the base estimators\n        X_final = np.array([cross_val_predict(est, X, y, cv=5) for est in self.base_estimators_]).T\n\n        # Fit final estimator\n        self.meta_estimator_.fit(X_final, y)\n        return self\n\n    def predict(self, X):\n        meta_features = np.array([est.predict(X) for est in self.base_estimators_]).T\n        return self.meta_estimator_.predict(meta_features)\n\n\nboston = load_diabetes()\nX, y = boston.data, boston.target\n\nbase_estimators = [RandomForestRegressor(n_estimators=20, max_depth=3, random_state=1), Ridge()]\nmeta_estimator = Ridge()\nstack = HomeMadeStackingRegressor(base_estimators, meta_estimator)\n\nmodels = list(zip(['rf', 'ridge'], base_estimators)) + [('stack', stack)]\n\nresults = []\nfor name, basemodel in models:\n    cv_results = cross_validate(basemodel, X, y, return_estimator=True, return_train_score=True)\n    df = pd.DataFrame.from_dict(cv_results)\n    df.reset_index(names=\"run\", inplace=True)\n    df[\"model\"] = name\n    results.append(df)\n\ncv_results = pd.concat(results).reset_index(drop=True)\ncv_results_melt = cv_results.melt(id_vars=[\"model\", \"run\"], value_vars=[\"test_score\", \"train_score\", \"fit_time\", \"score_time\"], var_name=\"metric\", value_name='value')\nsns.catplot(cv_results_melt, y=\"model\", x=\"value\", kind=\"bar\", hue=\"model\", col=\"metric\", sharex=False)\n```\n\n스태킹의 테스트 점수가 기본 모델보다 우수함을 확인할 수 있습니다. 그러나 더 높은 학습 시간을 필요로 합니다.\n\n# 요약\n\n스태킹에 대해 기억해야 할 것들입니다:\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 앙상블 기법이며, 최종 모델을 사용하여 기본 모델의 예측을 결합합니다.\n- 최종 모델은 기본 모델의 예측을 수평 스택으로 사용합니다.\n- 기본 모델이 서로 다르고 서로의 약점을 보완할 때 가장 잘 작동합니다. 최소한 기본 모델 중 가장 우수한 것보다는 성능이 우수해야 합니다.\n- 기본 및 최종 모델의 하이퍼파라미터와 통과 매개변수를 사용하여 조정할 수 있습니다. 다시 쌓을 수 있도록 하거나 아니면 그렇지 않도록 설정할 수 있습니다.\n- 적합화 과정에는 기본 추정기와 동일하게 독립적으로 적합된 최종 추정기를 적합화하기 위해 교차 검증 체계를 사용합니다.\n\n이 글이 마음에 드셨다면 다른 글도 읽어보세요:","ogImage":{"url":"/TIL/assets/img/2024-07-12-TheStackingEnsembleMethod_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-TheStackingEnsembleMethod_0.png","tag":["Tech"],"readingTime":19},{"title":"PyTorch 입문  커스텀 데이터 사용 방법","description":"","date":"2024-07-12 20:17","slug":"2024-07-12-PyTorchIntroductionUsingCustomData","content":"\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_0.png\" /\u003e\n\n파이토치는 현재 딥 러닝 분야에서 가장 핫한 라이브러리 중 하나입니다. ChatGPT가 출시된 이후 데이터 과학가와 머신 러닝 엔지니어들 사이에서 딥 러닝 라이브러리가 아마도 가장 많은 관심을 받고 있다고 볼 수 있습니다. 특히 이러한 라이브러리는 매우 빠르게 복잡한 다차원 계산을 수행하는 능력이 뛰어나며, 이러한 라이브러리는 우리가 신경망 모델을 훈련하는 방식을 바꾸었습니다. 특히 이러한 모델이 저장하고 최적화하는 많은 수의 가중치를 관리하는 데 매우 도움이 됩니다. TensorFlow(구글의 프레임워크)와 경쟁하며, PyTorch는 Meta의 오픈 소스 프레임워크로, 아주 멋지고 실용적인 문법을 사용하여 딥 러닝 모델을 훈련할 수 있는 기회를 제공합니다.\n\n지금까지 이 PyTorch 시리즈에서 이 라이브러리를 사용하는 기본 개념을 배워왔습니다. 예를 들어:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 텐서에 대한 기본 사항을 배우기\n- PyTorch를 사용하여 처음 선형 모델(회귀)을 만드는 방법 이해하기\n- 비선형 활성화 함수 및 비선형 문제 해결하는 방법 배우기\n\n저희는 예제와 이전 블로그 게시물에서 몇 가지 사용자 정의 데이터셋을 사용했습니다. 이 시리즈에서 딥 러닝 모델을 교육하는 방향으로 진행하면서, PyTorch의 맥락에서 다양한 데이터셋을 통합하는 방법을 이해하는 데 매우 도움이 됩니다. 이 블로그 게시물에서는 라이브러리에서 사용자 정의 데이터셋을 다루는 방법을 배우고, 특히 세 가지 다른 유형의 데이터를 통합하는 방법을 다룰 것입니다:\n\n- CSV 파일\n- 이미지 데이터\n- 텍스트 데이터\n\n또한 데이터 배치의 개념에 대해 살펴보고, 이를 위해 PyTorch 사용자 정의 DataLoader를 사용하는 방법도 알아볼 것입니다. 이 블로그 게시물의 일부 영감은 Zero to Mastery Pytorch 무료 강좌에서 온 것입니다 — 많은 흥미로운 학습 예제가 있는 이 멋진 자료를 확인해보세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n시작해 봅시다!\n\n# 랜덤 데이터셋 생성\n\n먼저, Pytorch에서 랜덤 데이터셋을 생성하여 DataLoader를 어떻게 사용할 수 있는지 이해해 봅시다:\n\n```python\nimport torch\nfrom torch.utils.data import Dataset, DataLoader\n\nclass RandomIntDataset(Dataset):\n    def __init__(self, start, stop, x, y):\n        self.data = torch.randint(start, stop, (x,y))\n        self.labels = torch.randint(0, 10, (x,))\n\n    def __len__(self):\n        return len(self.labels)\n\n    def __str__(self):\n        return str(torch.cat((self.data, self.labels.unsqueeze(1)), 1))\n\n    def __getitem__(self, i):\n        return self.data[i], self.labels[i]\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저희 RandomIntDataset은 랜덤한 torch 객체와 레이블을 생성합니다. 클래스에 던더 메서드를 도입하고 torch.utils.data.Dataset을 상속했음을 주목해주세요. (특히 데이터셋을 DataLoader와 결합할 때 유용하게 사용될 것입니다).\n\n이전 클래스를 기반으로 첫 번째 데이터셋 객체를 생성해봅시다!\n\n```js\ndataset = RandomIntDataset(100, 1000, 500, 10)\n```\n\n다시 말씀드리지만, Pytorch의 기본 클래스를 상속받았기 때문에 DataLoader를 사용하여 좋은 이터러블을 생성할 수 있습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\r\ndataset_loader = DataLoader(dataset, batch_size=10, shuffle=True)\r\n```\r\n\r\n신경망 내에서 데이터를 배치로 전달하는 것은 매우 흔한 일이며 DataLoader 생성자가 깔끔한 batch_size 인자를 통해 이를 처리합니다! dataset_loader는 반복 가능하므로 순차적인 데이터 배치를 얻기 위해 next 및 iter를 사용할 수 있습니다.\r\n\r\n```js\r\ndata, labels = next(iter(dataset_loader))\r\ndata\r\n```\r\n\r\n\u003cimg src=\"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_1.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n새로운 iteration을 실행하고 data_loader의 다음 배치가 어떻게 이동하는지 확인해보세요! 이를 통해 데이터 및 레이블 객체 내부의 다른 데이터가 표시됩니다.\n\n물론, 이 무작위 데이터 세트는 실제로 \"사용자 지정 데이터 세트\"로 간주하기 어렵습니다. 무작위 생성된 데이터와 작업하려고 할 가능성은 매우 낮습니다. 그러나 배치 처리에 익숙해지는 데 도움이 되는 이 소개 후에 첫 번째 CSV 파일을 PyTorch 파이프라인에 포함하여 계속 진행할 준비가 되었습니다!\n\n# DataLoader와 사용자 지정 데이터 세트 결합\n\n우리가 보았듯이, 무작위 데이터 세트 사용은 단순한 연습일 뿐입니다. 그러나 이제 DataLoader와 데이터 배치가 어떻게 작동하는지 알기 때문에 이 지식을 사용하여 새로운 클래스를 만들어 PyTorch 데이터 세트를 사용할 수 있습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nimport pandas as pd\n\nclass TaxiSample(Dataset):\n    def __init__(self):\n        super().__init__()\n        df = pd.read_csv('data/taxi_data_sample.csv')\n        \n        features = ['passenger_count',\n                    'pickup_longitude',\n                    'pickup_latitude',\n                    'dropoff_longitude',\n                    'dropoff_latitude']\n        \n        target = 'trip_duration'\n        \n        self.features = torch.tensor(df[features].values, \n                                     dtype=torch.float32)\n\n        self.labels = torch.tensor(df[target].values, \n                                   dtype=torch.float32)\n\n    def __len__(self):\n        return len(self.labels)\n\n    def __getitem__(self, idx):\n        return self.features[idx], self.labels[idx]\n```\n\n참고: 라이브러리를 게시물에서 지날 때까지 가져오고 있지만 모든 라이브러리는 스크립트의 처음에 가져와야 합니다!\n\n우리가 사용하는 데이터셋은 Kaggle의 택시 여행 소요 시간 경쟁의 샘플 버전입니다. 여기서 csv를 init에 전달하고 있습니다 (이 기능을 더 다룰 수 있도록 인수로도 전달할 수 있습니다). DataLoader와 잘 어울리는지 확인해봅시다:\n\n```python\ndata_taxi = TaxiSample()\ndataset_loader = DataLoader(data_taxi, batch_size=20, shuffle=True)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리의 배치 크기가 20인 경우, 이 데이터셋에서 이터레이터를 만들 수 있습니다:\n\n```js\ndata_iterator = iter(dataset_loader)\ndata, labels = next(data_iterator)\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_2.png\" /\u003e\n\n멋져요! 이것들은 데이터셋에서 무작위로 선택한 처음 20개의 예시입니다. 위 이미지에서는 피처와 해당 레이블을 확인할 수 있어요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n있는 이미지 데이터를 사용 해보세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 블로그 게시물의 이 섹션에서는 이미지 데이터 처리 능력을 보여주기 위해 Microsoft Research Cats. vs Dogs. 데이터셋과 함께 Pytorch를 사용할 것입니다. 먼저 pathlib를 사용하여 경로를 정의해 보겠습니다:\n\n```python\nfrom pathlib import Path\ndata_path = Path(“data/dogs_cats”)\n```\n\n폴더 안에는 강아지 이미지와 고양이 이미지가 있는 두 개의 폴더가 있습니다. 각 폴더에서 이미지 경로를 추출해 봅시다:\n\n![이미지](/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_3.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 섹션에서는 일반적인 컴퓨터 비전 변환 및 아키텍처를 제공하는 pytorch의 멋진 확장인 torchvision이 필요합니다.\n\n```js\nfrom torchvision import datasets, transforms\n```\n\n다음으로 jpg 파일 이름을 읽어보겠습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimage_dogs_list = list((data_path/'dogs').glob(\"*.jpg\"))\nimage_cats_list = list((data_path/'cats').glob(\"*.jpg\"))\n```\n\n.. and combining our lists into a single object:\n\n```js\nimage_paths = image_cats_list + image_dogs_list\n```\n\nLet’s see if everything is working fine by extracting a random image from our list:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nimport random\nfrom PIL import Image\n\nrandom.seed(20)\n\nrandom_image_path = random.choice(image_paths)\nimage_class = random_image_path.parent.stem\n\nimg = Image.open(random_image_path)\n\nprint(f\"Random image path: {random_image_path}\")\nprint(f\"Image class: {image_class}\")\nprint(f\"Image height: {img.height}\") \nprint(f\"Image width: {img.width}\")\nimg\n```\n\n![Cute little doggo!](/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_5.png)\n\n귀여운 강아지!\n\n이미지를 텐서로 변환할 때 일반적인 단계 중 하나는 이미지를 일반적인 포맷으로 조정하는 것입니다. transforms 라이브러리를 사용하여 이미지 크기를 조정하고 첫 번째 비전 파이프라인을 설정할 수 있습니다!\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\ndata_transform = transforms.Compose([\n # 이미지 크기를 조정합니다\n transforms.Resize(size=(64, 64)),\n # 이미지를 수평으로 무작위로 뒤집습니다 — 이는 데이터 증가를 위한 단계입니다\n transforms.RandomHorizontalFlip(p=0.5),\n transforms.ToTensor()])\n```\n\n위 transforms 파이프라인에서 우리는 다음을 수행합니다:\n\n- 이미지를 64x64 픽셀 크기로 크기 조정합니다.\n- 무작위로 수평으로 이미지를 뒤집습니다 — 이는 데이터 증가를 위한 일반적인 단계입니다.\n- 이미지를 텐서로 변환합니다.\n\n한 이미지와 해당 변환된 버전을 나란히 그래플로 표시합니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport matplotlib.pyplot as plt\n\ndef plot_transformed_images(image_paths: list, \n                            transform: transforms.Compose, \n                            n=3, \n                            seed=100):\n    random.seed(seed)\n    random_image_paths = random.sample(image_paths, k=n)\n    for image_path in random_image_paths:\n        with Image.open(image_path) as f:\n            fig, ax = plt.subplots(1, 2)\n            ax[0].imshow(f) \n            ax[0].set_title(f\"Original Image \\nSize: {f.size}\")\n            ax[0].axis(\"off\") \n            transformed_image = transform(f).permute(1, 2, 0) \n            ax[1].imshow(transformed_image) \n            ax[1].set_title(f\"Transformed Image \\nSize: {transformed_image.shape}\")\n            ax[1].axis(\"off\")\n            fig.suptitle(f\"Class: {image_path.parent.stem}\", fontsize=16)\n```\n\n```js\nplot_transformed_images(image_paths, \n transform=data_transform, \n n=1)\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_6.png\" /\u003e\n\n저런! 변환을 통해 기본 텐서에 액세스하는 방법을 살펴보겠습니다. 예를 들어, 첫 번째 이미지의 경우:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimage_path = image_paths[0]\ndata_transform(Image.open(image_path))\n```\n\n![image](/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_7.png)\n\n데이터 변환은 RGB 채널이 3개이고 64x64 텐서를 생성했습니다!\n\n우리가 넘어가기 전에 더해야 할 마지막 단계 하나가 있습니다. 빠르게 텐서와 레이블을 생성하는 대안이 있습니다. 우리는 ImageFolder를 사용하여 편리하게 훈련 데이터를 생성할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ntrain_data = datasets.ImageFolder(root=data_path, transform=data_transform, target_transform=None)\n```\n\n`datasets.ImageFolder`을 사용해요\n\n```js\nclass_names = train_data.classes\nclass_names\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_8.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nclass_names에는 현재 태그(폴더 이름에서 읽음)가 컴퓨터 비전 모델에 포함되어 있습니다. train_data에는 컴퓨터 비전 프로세스에 대한 중요한 메타데이터가 포함되어 있습니다:\n\n![이미지](/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_9.png)\n\n그리고 이제 데이터 세트 ImageFolders를 DataLoaders로 변환하는 것은 매우 간단합니다:\n\n```js\ntrain_dataloader = DataLoader(dataset=train_data, \n batch_size=5,\n num_workers=1, \n shuffle=True)\n\ntrain_dataloader\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n보면 이터러블이 있네요:\n\n```python\nimg, label = next(iter(train_dataloader))\nprint(f\"이미지 형태: {img.shape} -\u003e [배치 크기, 색상 채널, 높이, 너비]\")\nprint(f\"레이블 형태: {label.shape}\")\n```\n\n![image](/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_10.png)\n\n멋져요! 이 배치 크기가 5인 경우, 3채널(RGB)의 64x64 픽셀 이미지를 나타내는 3x64x64 텐서를 얻을 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 이 데이터 배치를 사용하여 강아지와 고양이 이미지를 인식하는 머신러닝 모델을 훈련할 수 있어요! (사실, 이 시리즈의 다음 블로그 게시물에서 이를 진행할 예정이에요!)\n\n# 텍스트 데이터 사용\n\n이 글의 마지막 부분에서는 sklearn.datasets의 fetch_20newsgroups를 사용하여 문자열과 정수 간 매핑을 생성할 거에요:\n\n```js\nfrom sklearn.datasets import fetch_20newsgroups\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음의 내용을 newsgroups에서 로드해 보겠습니다:\n\n```python\nfrom sklearn.datasets import fetch_20newsgroups\n\ncategories = [\n    'comp.os.ms-windows.misc',\n    'rec.sport.baseball',\n    'rec.sport.hockey',\n]\n\ndataset = fetch_20newsgroups(subset='train', categories=categories, shuffle=True, remove=('headers', 'footers', 'quotes'))\ncorpus = [item for item in dataset['data']]\n```\n\n다음 함수는 텍스트를 전처리할 것입니다:\n\n```python\nimport nltk\nimport re\n\ndef preprocess_text(text: str) -\u003e str:\n    '''\n    입력 데이터에서 텍스트를 전처리하여 특수 문자와 숫자를 제거합니다.\n    \n    토큰 목록을 반환합니다.\n    '''\n    # 특수 문자 및 숫자 제거\n    text = re.sub(\"[^A-Za-z]+\", \" \", text)\n    tokens = nltk.word_tokenize(text.lower())\n    return tokens\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 우리 어휘를 생성하는 함수입니다:\n\n```js\ndef get_vocab(training_corpus):\n  # 특수 문자 추가\n  # 패딩, 라인 끝, 알 수 없는 용어\n  vocab = {'__PAD__': 0, '__\u003c/e\u003e__': 1, '__UNK__': 2}\n  for item in training_corpus: \n    processed_text = preprocess_text(item)\n    processed_text.sort()\n    for word in processed_text:\n      if word not in vocab:\n        vocab[word] = len(vocab) \n  return vocab  \n```\n\n전체 어휘 사이즈는 얼마인가요?\n\n```js\nvocab = get_vocab(corpus)\nlen(vocab)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이미지 파일:\n\n![이미지 파일](/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_11.png)\n\n단어장은 2만 6천 개가 조금 넘는 단어를 포함하고 있으며, 각 단어는 정수로 매핑되어 있습니다:\n\n이미지 파일:\n\n![이미지 파일](/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_12.png)\n\n이렇게 설정을 했으면, 문자를 정수로 변환하여 텐서로 변환하는 함수를 사용할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\ndef text_to_tensor(text: str, vocab_dict: dict) -\u003e torch.tensor:\n    '''\n    텍스트를 전처리하고 텐서 형식의 정수 매핑을 생성합니다.\n    '''   \n    word_l = preprocess_text(text)\n        \n    # 빈 텐서 초기화\n    tensor_l = [] \n    \n    # 단어 목록에서 __UNK__ 값을 가져옴\n    unk_ID = vocab_dict['__UNK__']\n            \n    # 각 단어에 대해:\n    for word in word_l:\n        # 인덱스 가져옴\n        # 단어가 vocab_dict에 없으면 UNK로 할당\n        word_ID = vocab_dict.get(word, unk_ID)\n        # 텐서 목록에 추가\n        tensor_l.append(word_ID)\n\n    return torch.tensor(tensor_l)\n```\n\n이 함수가 텍스트를 텐서로 어떻게 변환하는지에 대한 예시는 아래와 같습니다. 첫 번째 텍스트의 처음 200 단어를 사용하여 검사합니다:\n\n```python\nsnippet = corpus[0][0:200]\nprint('텍스트 \"{}\"는 다음과 같이 텐서로 표현됩니다: {}'.format(snippet, text_to_tensor(snippet, vocab)))\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_13.png\" /\u003e\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테이블 태그를 마크다운 형식으로 변경해주세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 PyTorch 시리즈의 더 많은 포스트를 알아보려면 다음 링크를 확인해보세요:\n\n- Tensor 소개;\n- 선형 모델 만들기;\n- 활성화 함수 및 비선형 문제;\n\n이 게시물의 자료:\n\n- 택시 여행 기간 — https://www.nyc.gov/site/tlc/about/tlc-trip-record-data.page\n- 고양이와 개 이미지 인용: @Inproceedings (컨퍼런스)'asirra-a-captcha-that-exploits-interest-aligned-manual-image-categorization,\n저자 = 'Elson, Jeremy 및 Douceur, John (JD) 및 Howell, Jon 및 Saul, Jared',\n제목 = 'Asirra: A CAPTCHA that Exploits Interest-Aligned Manual Image Categorization',\n책 제목 = 'Proceedings of 14th ACM Conference on Computer and Communications Security (CCS)',\n연도 = '2007',\n월 = '10월',\n발행사 = 'Association for Computing Machinery, Inc.',\nurl = 'https://www.microsoft.com/en-us/research/publication/asirra-a-captcha-that-exploits-interest-aligned-manual-image-categorization/',\n판본 = 'Proceedings of 14th ACM Conference on Computer and Communications Security (CCS)',\n'","ogImage":{"url":"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_0.png","tag":["Tech"],"readingTime":19},{"title":"완전 무료 강좌 Python과 데이터 엔지니어링 완벽 가이드","description":"","date":"2024-07-12 20:16","slug":"2024-07-12-CompleteFreeCourseonPythonandDataEngineering","content":"\n\n파이썬에는 네 가지 복잡한 유형이 있습니다: 리스트, 튜플, 세트 및 사전이 있습니다. 각각에 대해 별도로 이야기하고 실제 예제를 제공하겠습니다.\n\n무료로 읽으려면 다음 링크를 확인하십시오:\n\n## 리스트:\n\n- 리스트는 변경 가능한 요소입니다.\n- 문자열, 문자, 정수 및 부동 소수점 숫자와 같은 서로 다른 유형의 항목을 포함 할 수 있습니다.\n- 인덱스는 0부터 시작합니다.\n- 순서가 있고 중복된 요소가 있습니다. append, remove 및 수정과 같은 연산이 가능합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 코드는 실제 예시입니다:\n\n\n![image](/TIL/assets/img/2024-07-12-CompleteFreeCourseonPythonandDataEngineering_0.png)\n\n\n# 튜플:\n\n- 변경할 수 없는 데이터입니다.\n- 변경할 수 없는 리스트로 사용될 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\ntuple = (1, 2, 3, 4, 5, \"b\", \"c\", \"d\")\n```\n\n3. 필드의 컬렉션으로 사용될 수 있으며, 요소의 수가 고정되어 있고 순서가 중요합니다.\n\n```python\ncity, year, pop, chg, area = ('Tokyo', 2003, 32_450, 0.66, 8014)\n```\n\n아래 코드는 실제 예시입니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![Course Image](/TIL/assets/img/2024-07-12-CompleteFreeCourseonPythonandDataEngineering_1.png)\n\n# Sets:\n\n- Mutable data.\n- Elements are not ordered, nor duplicated.\n- Sets are hashable so it’s highly optimized.\n- Sets use a hashtable as its underlying data structure. This explains the O(1) membership checking, since looking up an item in a hashtable is an O(1) operation, on average.\n- Operations between sets can be union, intersection, difference, or symmetric difference.\n\nThe code below is a practical example:\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![이미지](/TIL/assets/img/2024-07-12-CompleteFreeCourseonPythonandDataEngineering_2.png)\n\n# 딕셔너리:\n\n- 키-값 쌍이다.\n- 키: 어떤 불변 유형이며 유일하다.\n- 값: 불변 또는 가변 유형이 될 수 있다.\n- 데이터를 효율적으로 조회한다.\n- 키로 접근한다.\n- 파이썬에서 딕셔너리는 해시 테이블로 구현된다.\n- 키는 해시 가능한 객체여야 한다. 적절한 __hash__ 및 __eq__ 메서드를 구현해야 한다.\n- 키에 의한 항목 접근은 매우 빠르다. 딕셔너리에 수백만 개의 키가 있을 수 있지만, 파이썬은 키의 해시 코드를 계산하고 해시 테이블에 대한 색인 오프셋을 파생하여 키를 직접 찾을 수 있으며 일치하는 항목을 찾기 위해 소수의 시도를 하게 된다.\n- Python 3.7부터 dict 내장의 새로운 개선 사항은 다음과 같다: 사전 객체의 삽입 순서 보존 속성은 파이썬 언어 사양의 공식 부분으로 선언되었다. 이는 더 이상 OrderedDict가 필요하지 않다는 것을 의미한다. 거의 똑같다.\n\n![이미지](/TIL/assets/img/2024-07-12-CompleteFreeCourseonPythonandDataEngineering_3.png)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# NumPy Arrays:\n\n- 동일한 유형의 객체로 구성된 다차원 배열이다.\n- NumPy 배열은 List보다 우수하다:\n- List보다 효율적으로 저장된다.\n- 수학 연산을 벡터화할 수 있어, Python에서 List를 순회하는 것보다 성능이 높다.\n- 연산:\n- 숫자 연산: sin, cos, max, mean, variance, standard deviation, dot product.\n- 비숫자 연산: 색인, 슬라이싱, 쌓기, 분할, 논리 연산.\n\n# 참고 자료:\n\n세트는 어떻게 구현되었나요?\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nDict 대 OrderedDict\n\nDict은 파이썬의 해시 테이블입니다.\n\n파이썬 공부 교재\n\n# 감사 노트:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n각자의 시간을 내어 저의 글을 읽어 주셔서 감사의 말씀 전하고 싶습니다. 여러분의 지지와 참여는 저에게 너무나 소중하며, 이 멋진 청중과 제 생각과 통찰을 나눌 수 있는 기회에 진심으로 감사드립니다. 여러분의 팔로우는 저에게 가치 있는 내용을 만들기 위해 더 나은 자아를 추구하도록 영감을 줍니다. 오랜 구독자이든 새로 오신 독자이든, 여러분의 존재가 중요하며, 지지에 깊은 감사를 표합니다. 여러분과 공감되고 영감을 주는 고품질 글을 제공하기 위해 헌신할 것입니다. 여러분의 피드백과 댓글은 글쓰기에 대한 열정을 불어 넣어주고, 지속적인 성장을 동기부여합니다. 이 청중의 일원으로 함께해 주셔서 감사합니다. 여러분이 제 커뮤니티의 일원으로 있어 기쁘게 생각하며, 미래에도 여러분과 여러 새로운 아이디어를 공유하기를 기대합니다.\n\n코드가 필요하시다면 구독하고 메시지 보내주세요.\n\n감사합니다.","ogImage":{"url":"/TIL/assets/img/2024-07-12-CompleteFreeCourseonPythonandDataEngineering_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-CompleteFreeCourseonPythonandDataEngineering_0.png","tag":["Tech"],"readingTime":5},{"title":"Python으로 WhatsApp에서 AI를 사용하여 자신 복제하는 방법","description":"","date":"2024-07-12 20:13","slug":"2024-07-12-CloningYourselfonWhatsAppwithAIinPython","content":"\n\n\n![Cloning Yourself on WhatsApp with AI in Python](/TIL/assets/img/2024-07-12-CloningYourselfonWhatsAppwithAIinPython_0.png)\n\n친구들, 가족, 동료들로부터 온 WhatsApp 메시지를 계속해서 따라갈 수 있는 자신을 복제할 수 있다면 얼마나 좋을까요? 이 글에서는 정확히 그렇게 해볼 것입니다.\n\n우리는 여러분을 대신해 대화를 처리할 수 있는 챗봇을 만드는 방법을 보여드리겠습니다. OpenAI의 GPT 모델과 Twilio의 WhatsApp API를 사용하여 여러분의 채팅 스타일을 모방하고 이미지를 이해하여 여러분을 위해 대화할 수 있는 디지털 친구를 만들어볼 것입니다.\n\n이 글의 구성은 다음과 같습니다:\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 1. 환경 설정\n\n## 단계 1. Twilio에 가입하기\n\n- Twilio 웹 사이트로 이동합니다.\n- 무료 체험 계정을 등록합니다. $15의 무료 크레딧이 제공됩니다.\n- 가입 프로세스 중에 이메일과 전화번호를 인증합니다.\n\n## 단계 2. Twilio WhatsApp 샌드박스 설정\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Twilio 콘솔에 로그인합니다.\n- ‘All Products \u0026 Services’ -\u003e ‘Programmable Messaging’ -\u003e ‘Try it Out’ -\u003e ‘Try WhatsApp’로 이동합니다.\n- WhatsApp 샌드박스를 설정하는 지침에 따릅니다. WhatsApp을 통해 Twilio 번호로 코드를 보내어 샌드박스에 참여합니다.\n- 가입하고 나면 샌드박스 번호를 메모해 둡니다.\n\n## 단계 3. Ngrok 설정\n\nNgrok은 로컬 개발 환경으로 안전한 터널을 생성하여 로컬 서버를 인터넷에 노출시킬 수 있는 도구입니다.\n\n이는 Twilio와 같은 서비스와의 웹훅 통합을 테스트하는 데 특히 유용합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n1. ngrok을 ngrok.com/download에서 다운로드하세요.\n\n2. 다운로드한 파일 압축 해제: 다운로드 후 ngrok 파일을 압축 해제하세요.\n\n3. Ngrok 인증: ngrok을 사용하기 전에 ngrok 인증 토큰을 사용하여 인증해야 합니다. ngrok 대시보드에서 인증 토큰을 찾을 수 있습니다. 터미널이나 명령 프롬프트를 열고 다음 명령을 실행하여 ngrok 인증 토큰을 실제 ngrok 인증 토큰으로 바꿔치기하세요: \n\n[2024-07-12-CloningYourselfonWhatsAppwithAIinPython_1.png](/TIL/assets/img/2024-07-12-CloningYourselfonWhatsAppwithAIinPython_1.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n4. 포트 5000을 터널링하기 위해 Ngrok 실행: Flask 애플리케이션은 일반적으로 기본적으로 포트 5000에서 실행됩니다. 따라서 이 포트를 터널링할 필요가 있습니다. 터미널이나 명령 프롬프트에서 ngrok이 위치한 디렉토리로 이동한 후 다음 명령을 실행하세요:\n\n```js\nngrok http 5000\n```\n\n만약 이 명령이 작동하지 않는다면, 대신 다음 명령을 시도해보세요:\n\n```js\n./ngrok http 5000\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![이미지](/TIL/assets/img/2024-07-12-CloningYourselfonWhatsAppwithAIinPython_2.png)\n\n5. 전달 URL 주의: ngrok가 실행되면 https://12345.ngrok.io와 같은 전달 URL을 제공합니다. 이 URL은 WhatsApp에서 수신된 메시지를 받기 위해 Twilio 구성에서 웹훅 URL로 사용됩니다.\n\n중요 사항:\n\n- 애플리케이션을 테스트하는 동안 ngrok를 계속 실행하십시오. ngrok를 중지하면 전달 URL이 작동하지 않게 되며 새로운 전달 URL로 Twilio의 웹훅 URL을 업데이트해야 합니다.\n- 무료 버전의 ngrok는 임시 URL을 제공하며, ngrok를 다시 시작할 때마다 변경됩니다. 장기간 테스트 또는 개발에 안정적인 URL이 필요한 경우 유료 ngrok 플랜으로 업그레이드를 고려해보세요.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 단계 4. Twilio 샌드박스 설정하기\n\n- Twilio 콘솔의 WhatsApp 샌드박스로 돌아갑니다.\n- ngrok URL 다음에 /whatsapp 엔드포인트가 이어지도록 '메시지 수신 시' 웹훅을 구성합니다. https://12345.ngrok.io/whatsapp와 같은 형식이어야 합니다. 아래 이미지를 참고하세요.\n- 변경 사항을 저장하세요.\n\n![이미지](/TIL/assets/img/2024-07-12-CloningYourselfonWhatsAppwithAIinPython_3.png)\n\n## 단계 5. Twilio 자격 증명 얻기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nTwilio 대시보드에서 \"설정\"으로 이동하여 \"계정 SID\" 및 \"인증 토큰\"을 메모해주세요. 이 정보는 Python에서 API 요청을 인증하는 데 사용됩니다.\n\n![이미지](/TIL/assets/img/2024-07-12-CloningYourselfonWhatsAppwithAIinPython_4.png)\n\n## 단계 6. OpenAI API 자격 증명 획득\n\nOpenAI의 모델과 상호 작용하려면 API 자격 증명을 획득해야 합니다. 이를 통해 요청이 인증됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-CloningYourselfonWhatsAppwithAIinPython_5.png\" /\u003e\n\n# 2. Python Automation Script\n\n## 2.1. Install Python Libraries\n\n코딩을 시작하기 전에 몇 가지 라이브러리를 설치해야 합니다. 터미널이나 명령 프롬프트를 열고 다음 명령을 입력하세요:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n```js\npip install flask twilio openai\n```\n\n## 2.2. Python에서 자격 증명 설정\n\n이제 코드 편집기에서 자격 증명을 설정할 차례입니다. 단순함을 위해 VS Code 안의 Jupyter Notebook을 사용하고 있습니다.\n\n플레이스홀더를 실제 Twilio 및 OpenAI 자격 증명으로 교체해주세요.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nfrom flask import Flask, request\nfrom twilio.rest import Client\nimport openai\nimport requests\nfrom requests.auth import HTTPBasicAuth\nimport base64\nimport os\n\n# Twilio credentials\naccount_sid = ''\nauth_token = ''\ntwilio_number = 'whatsapp:+14155238886'\ntwilio_client = Client(account_sid, auth_token)\n# OpenAI API Key\nopenai_api_key = ''\n```\n\n## 2.3. 플라스크 어플리케이션 설정\n\n우리는 Flask를 사용하여 웹 서버를 생성하여 새로운 WhatsApp 메시지가 도착할 때 Twilio가 호출할 수 있는 URL 엔드포인트(라우트)를 정의하는데 사용합니다. \n\n파이썬 파일의 자격 증명들 아래에서 Flask 어플리케이션을 초기화하고 업로드를위한 디렉토리를 설정합니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\napp = Flask(__name__)\n\nuploads_dir = 'uploads'\nos.makedirs(uploads_dir, exist_ok=True)\n```\n\n이 코드 라인은 Flask 클래스의 인스턴스를 생성합니다. __name__은 Python의 특별한 변수로, 모듈로 import되었을 때는 모듈의 이름을 가리키지만, 스크립트가 직접 실행될 때는 `__main__`으로 설정됩니다.\n\nFlask 및 첫 Flask 애플리케이션을 설정하는 방법에 대해 더 많이 알아 보려면 공식 Flask 문서를 참조하십시오.\n\n## 2.4. 트위리오(Twilio)와 WhatsApp 통합하기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nTwilio는 WhatsApp과 프로그래밍적으로 상호 작용하는 간편한 방법을 제공합니다. Twilio의 WhatsApp 샌드박스를 사용하면 WhatsApp 비즈니스 API를 직접 설정해야 하는 복잡성 없이 메시지를 보내고 받을 수 있습니다.\n\nWhatsApp 번호에서 메시지를 받을 때마다 Twilio는 Flask 앱에서 지정한 라우트로 HTTP POST 요청을 보냅니다. 그런 다음 Flask 앱은 이 메시지를 처리합니다.\n\nWhatsApp을 Twilio와 통합하려면 SMS, 음성, 비디오, 이메일 및 WhatsApp과 같은 메시징 앱을 통해 통신을 관리하는 일련의 도구를 제공하는 Twilio API를 사용합니다.\n\n여기 작동 방식의 간소화된 개요입니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 플라스크 애플리케이션은 서버에서 실행되며 특정 경로에서 수신되는 HTTP POST 요청을 수신합니다.\n- Twilio는 WhatsApp 번호가 메시지를 수신할 때마다 해당 경로로 HTTP POST 요청을 보냅니다.\n- 서버는 요청을 처리하고 (메시지에 회신하는 등) Twilio에 다시 응답합니다.\n\nTwilio와 WhatsApp을 통합하려면 WhatsApp용 Twilio API 문서를 참조하십시오.\n\n이미지와 같은 미디어 메시지를 처리하려면 Twilio가 요청할 때 보내는 MediaUrl 매개변수를 처리해야 합니다.\n\n이러한 URL은 서버에서 가져와 처리할 수 있는 미디어 콘텐츠를 가리킵니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nTwilio를 사용하여 미디어 메시지를 수신하는 방법에 대한 자세한 내용은 Twilio를 사용하여 미디어 메시지를받는 섹션을 참조하십시오.\n\n```js\n@app.route(\"/whatsapp\", methods=['POST'])\ndef reply_whatsapp():\n    # 여기서 수신된 메시지를 처리합니다\n    pass\n```\n\n## 2.5. 수신된 메시지 처리하기\n\nreply_whatsapp 함수 내에서 수신된 메시지를 처리하고 그것들을 저장할 위치를 설정하기 시작하세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n플라스크에서 수신 메시지를 처리하려면 다음을 수행해야 합니다:\n\n- 새 메시지가 도착했을 때 Twilio가 호출할 수 있는 라우트를 정의합니다.\n- 요청에서 메시지 내용 및 발신자 정보를 추출합니다.\n- 메시지 내용에 따라 어떻게 응답하거나 작동할지 결정합니다.\n\n저희 경우, 자동 챗봇을 구축 중이므로 수신 메시지에서 텍스트나 미디어 URL을 가져와 응답을 생성할 예정입니다.\n\n이러한 수신 메시지를 처리하는 방법에 대한 자세한 내용은 Twilio의 메시지 수신 및 답장 가이드를 확인해주세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nconversation_histories = {}\n\n@app.route(\"/whatsapp\", methods=['POST'])\ndef reply_whatsapp():\n    incoming_msg = request.values.get('Body', '').lower()\n    from_number = request.values.get('From')\n    user_history = conversation_histories.get(from_number, [])\n    # We will continue to build on this function\n    return 'OK', 200\n```\n\n## 2.6. OpenAI의 GPT 모델 통합\n\n다음과 같은 두 가지 목적으로 OpenAI의 두 모델을 사용할 것입니다:\n\n- 텍스트용 GPT-4: 이러한 모델은 입력에 기반하여 인간과 같은 텍스트를 이해하고 생성할 수 있습니다. WhatsApp 봇의 맥락에서는 텍스트 메시지에 대한 답변을 생성하는 데 사용할 수 있습니다.\n- 이미지용 GPT-4 비전: 이미지와 같은 미디어를 처리할 때 모델의 비전 기능을 사용하여 이미지의 내용을 이해하고 설명을 제공할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n대화를 관리하기 위해 각 채팅의 컨텍스트를 저장하기 위해 conversation_histories 사전을 사용합니다.\n\n이렇게 하면 사용자로부터 메시지를 받을 때 사용자의 대화 기록을 새 메시지와 함께 OpenAI에 전송하여 모델이 일관된 응답을 생성할 수 있게 됩니다.\n\n## 2.7. 대화 기록 구축하기\n\n대화 기록을 유지하는 것은 우리의 AI가 상호 작용 과정에서 더 일관되고 관련성 있는 응답을 생성할 수 있도록 컨텍스트를 유지하는 데 도움이 됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n어떻게 만들까요:\n\n- 각 대화를 송신자의 번호를 키로 사용하여 사전(dictionary)에 저장합니다.\n- 새로운 메시지를 대화 기록에 추가한 후 OpenAI의 API로 전송합니다.\n- API 요청마다 대화 기록이 함께 전달되도록 합니다.\n\n## 2.8. 완성된 코드\n\n이제 모든 것을 완성된 코드로 조합해 봅시다. 다음은 전체 스크립트가 어떻게 보일지에 대한 자세한 설명이 포함된 것입니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nfrom flask import Flask, request\nfrom twilio.rest import Client\nimport openai\nimport requests\nfrom requests.auth import HTTPBasicAuth\nimport base64\nimport os\n\napp = Flask(__name__)\n\n# Twilio credentials\naccount_sid = ''\nauth_token = ''\ntwilio_number = ''\ntwilio_client = Client(account_sid, auth_token)\n\n# OpenAI API Key\nopenai_api_key = ''\n\n# Ensure the 'uploads' directory exists\nuploads_dir = 'uploads'\nos.makedirs(uploads_dir, exist_ok=True)\n\nconversation_histories = {}\n\n@app.route(\"/whatsapp\", methods=['POST'])\ndef reply_whatsapp():\n    incoming_msg = request.form.get('Body', '').lower()\n    media_url = request.form.get('MediaUrl0')\n    from_number = request.form.get('From')\n    message_sid = request.form.get('MessageSid')\n\n    # Prepare the headers for OpenAI API\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"Authorization\": f\"Bearer {openai_api_key}\"\n    }\n\n    # Get the user's conversation history, if it exists\n    user_history = conversation_histories.get(from_number, [])\n\n    if media_url:\n        # Process as an image\n        print('Image URL detected, attempting to retrieve the image...')\n        response = requests.get(media_url, auth=HTTPBasicAuth(account_sid, auth_token))\n        if response.status_code == 200:\n            # Save the image to a file in the 'uploads' directory\n            image_path = os.path.join(uploads_dir, f'{message_sid}.png')\n            with open(image_path, \"wb\") as image_file:\n                image_file.write(response.content)\n\n            # Encode the image in base64\n            base64_image = encode_image(image_path)\n\n            # Prepare the payload for the OpenAI API\n            payload = {\n                \"model\": \"gpt-4-vision-preview\",  # Use the correct model name for images\n                \"messages\": user_history + [\n                    {\n                        \"role\": \"user\",\n                        \"content\": [\n                            {\n                                \"type\": \"image_url\",\n                                \"image_url\": {\n                                    \"url\": f\"data:image/png;base64,{base64_image}\"\n                                }\n                            }\n                        ]\n                    }\n                ],\n                \"max_tokens\": 300\n            }\n\n            # Send the request to the OpenAI API\n            openai_response = requests.post(\"https://api.openai.com/v1/chat/completions\", headers=headers, json=payload)\n            description = openai_response.json().get('choices')[0].get('message').get('content') if openai_response.ok else \"Failed to get a description from OpenAI.\"\n            \n            # Update the user's conversation history with the image description\n            user_history.append({\"role\": \"assistant\", \"content\": description})\n            conversation_histories[from_number] = user_history\n\n            # Respond back on WhatsApp with the description\n            twilio_client.messages.create(\n                body=description,\n                from_=twilio_number,\n                to=from_number\n            )\n        else:\n            print('Failed to retrieve the image.')\n    else:\n        # Process as text\n        print('No image URL found, processing text...')\n        payload = {\n            \"model\": \"gpt-4\",  # Use the appropriate model for text\n            \"messages\": user_history + [\n                {\n                    \"role\": \"user\",\n                    \"content\": incoming_msg\n                }\n            ],\n            \"max_tokens\": 300\n        }\n        # Send the request to OpenAI API for text messages\n        openai_response = requests.post(\"https://api.openai.com/v1/chat/completions\", headers=headers, json=payload)\n        response_text = openai_response.json().get('choices')[0].get('message').get('content') if openai_response.ok else \"Failed to get a response.\"\n\n        # Update the user's conversation history\n        user_history.append({\"role\": \"assistant\", \"content\": response_text})\n        conversation_histories[from_number] = user_history\n\n        # Respond back on WhatsApp with the text response\n        twilio_client.messages.create(\n            body=response_text,\n            from_=twilio_number,\n            to=from_number\n        )\n\n    return 'OK', 200\n\ndef encode_image(image_path):\n    with open(image_path, \"rb\") as image_file:\n        return base64.b64encode(image_file.read()).decode('utf-8')\n\nif __name__ == '__main__':\n    app.run(debug=True, use_reloader=False)\n``` \n\n# 3. OpenAI 어시스턴트로 자동화하기\n\n이 섹션에서는 개인 대화 스타일을 모방하고 Twilio와 통합하며 텍스트 및 이미지 메시지를 처리하는 OpenAI 어시스턴트를 생성하는 방법에 대해 알아보겠습니다.\n\nOpenAI 어시스턴트 사용의 장점은 더 정확하게 파일을 첨부하고 동작을 수정하여 개인 커뮤니케이션 스타일을 가장 유사하게 모방할 수 있다는 데 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 3.1 대화 기록 정리하기\n\n대화 스타일을 모방할 수 있는 OpenAI 어시스턴트를 만들기 위해 WhatsApp 대화 기록을 정리해야 합니다.\n\n이것이 중요한 이유는 어시스턴트가 개인의 의사 소통 스타일과 일관된 방식으로 응답하는 방법을 배우기 위해 이 기록을 사용하기 때문입니다.\n\n고려해야 할 주요 사항:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 3.2 특정 사람의 대화 스타일을 복제할 수 있는 Open AI 어시스턴트 생성\n\n특정 사람의 대화 스타일을 과거 채팅 데이터를 기반으로 재현할 수 있는 AI 어시스턴트를 만드는 방법:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- WhatsApp 대화 기록을 구문 분석하고 OpenAI가 훈련에 사용할 수 있는 형식으로 변환합니다.\n- openai.File.create() 메서드를 사용하여 이 대화 기록을 OpenAI에 업로드하고 이를 사용하여 사용자 정의 어시스턴트를 훈련시킵니다.\n- openai.Assistant.create()를 사용하여 업로드한 파일을 어시스턴트의 훈련 참조로 제공하여 어시스턴트를 생성합니다.\n\n고려 사항:\n\n- 어시스턴트는 AI 성격을 드러내지 않아야 하며, 인간과 유사한 상호 작용의 환영을 유지해야 합니다.\n- 이미지 설명을 포함한 다양한 입력을 처리하여 대화를 원활하게 이어가야 합니다.\n\n```js\nimport openai\nfrom openai import OpenAI\n\ndef parse_whatsapp_history(file_path):\n    # WhatsApp 채팅 기록을 구문 분석하는 함수\n\n# OpenAI API 키 설정\nopenai.api_key = ''\n\n# OpenAI 클라이언트 초기화\nclient = OpenAI(api_key=openai.api_key)\n\n# WhatsApp 대화 기록 구문 분석\nwhatsapp_messages = parse_whatsapp_history(r\"WhatsApp Conversation between Alex.txt\")\n\n# WhatsApp 메시지를 파일로 업로드\nfile = client.files.create(\n    file=open(r\"WhatsApp Conversation between Alex.txt\", 'rb'),\n    purpose='assistants'\n)\n\ninstructions = (\n    \"당신은 Alex입니다. WhatsApp 기록을 기반으로 Alex의 대화 스타일을 모방합니다.\"\n    \"반드시 AI임을 밝히지 마십시오.\"\n    \"가끔 이미지 설명을 받을 수 있습니다.\"\n    \"대화에 자연스럽게 이 설명을 통합하고 어떠한 파일의 존재에 대해 언급하지 않습니다.\"\n    \"이미지를 직접 본 것처럼 행동합니다.\"\n    \"대화의 흐름을 유지합니다.\"\n)\n\n# 검색 도구가 활성화된 사용자 정의 어시스턴트 생성\nassistant = client.beta.assistants.create(\n    name=\"나의 WhatsApp 클론\",\n    instructions=instructions,\n    # 모델\n    # 파일\n    # 도구\n)\r\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nOpenAI 어시스턴트를 사용하여 WhatsApp 대화를 자동화하는 방법을 자세히 살펴보고 싶은 분들을 위해 www.entreprenerdly.com에서 상세한 안내가 제공되고 있어요:\n\n![이미지](/TIL/assets/img/2024-07-12-CloningYourselfonWhatsAppwithAIinPython_6.png)\n\n## 3.3 Twilio와 어시스턴트 통합\n\n훈련된 OpenAI 어시스턴트를 Twilio API와 통합하여 WhatsApp 메시지에 응답하도록 설정하는 것에 대해 알아봐요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n통합하는 방법:\n\n- Flask를 사용하여 Twilio가 새 메시지를 수신할 때 HTTP POST 요청을 보낼 수 있는 웹 서버를 생성합니다.\n- Flask 라우트 핸들러를 사용하여 수신된 메시지 및 미디어를 처리합니다.\n- openai.Completion.create()를 사용하여 텍스트 응답 또는 openai.Image.create()를 사용하여 이미지 처리를 위해 OpenAI 어시스턴트와 상호 작용합니다.\n- Twilio의 메시징 API를 통해 어시스턴트의 응답을 사용자에게 보냅니다.\n\n주요 통합 단계:\n\n- Flask 앱에 Twilio에서의 POST 요청을 처리할 수 있는 라우트를 설정합니다 (/whatsapp으로 코드에서).\n- requests 라이브러리를 사용하여 Twilio 번호로 보낸 이미지를 검색하고 OpenAI API와 상호 작용합니다.\n- 어시스턴트로부터 응답을 사용자에게 보내기 위해 대화 기록을 유지합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nfrom flask import Flask, request\nfrom twilio.rest import Client\nimport openai\nimport requests\nfrom requests.auth import HTTPBasicAuth\nimport base64\nimport os\nimport time\n\napp = Flask(__name__)\n\n# Twilio credentials\naccount_sid = ''\nauth_token = ''\ntwilio_number = 'whatsapp:+14155238886'\ntwilio_client = Client(account_sid, auth_token)\n\n# OpenAI API Key\nopenai_api_key = ''\n\n# Ensure the 'uploads' directory exists\nuploads_dir = 'uploads'\nos.makedirs(uploads_dir, exist_ok=True)\n\nconversation_histories = {}\n\n# Initialize the OpenAI client\nclient = openai.OpenAI(api_key=openai_api_key)\n\n# Create the custom assistant (replace 'assistant_id' with your actual assistant ID)\nassistant_id = assistant.id #'asst_g5yiS6TewzdO75JSrBuNBwEV'\n\n@app.route(\"/whatsapp\", methods=['POST'])\ndef reply_whatsapp():\n    # Function to handle incoming WhatsApp messages\n\ndef interact_with_assistant(assistant_id, message_content, image_path=None):\n    # Function to interact with assistant using text and images\n\ndef encode_image(image_path):\n    with open(image_path, \"rb\") as image_file:\n        return base64.b64encode(image_file.read()).decode('utf-8')\n\nif __name__ == '__main__':\n    app.run(debug=True, use_reloader=False)\n```\n\n## 4. Further Practical Applications\n\n알아봤던 OpenAI와 Twilio를 사용하여 WhatsApp 대화를 자동화하는 기술은 개인 메시지 이상의 폭넓은 실용적인 응용 프로그램을 갖고 있습니다. 이 기술이 어떻게 적응되고 다른 시나리오에서 적용될 수 있는지 살펴보겠습니다:\n\n### 4.1 고객 지원 자동화\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자주 묻는 질문과 흔한 문제에 대한 대답을 자동화하여 고객 지원의 응답 시간과 효율성을 높일 수 있습니다.\n\n구현 방안:\n\n- 지난 고객 서비스 상호작용에 대한 AI 모델을 세밀하게 조정하여 일반적인 쿼리를 처리합니다.\n- CRM 시스템과 통합하여 고객 이력을 기반으로 개인화된 응답을 제공합니다.\n- 복잡한 문제가 발생할 때에는 인적 에이전트들에게 일을 넘깁니다.\n\n자원:\n이미 개발된 솔루션을 사용하려면 Salesforce의 AI 기반 고객 관계 관리 솔루션인 Einstein AI를 확인해보세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 4.2 전자 상거래 챗봇\n\n제품 추천, 재고 업데이트 및 주문 추적을 제공할 수 있는 인공 지능 챗봇을 활용하여 온라인 쇼핑 경험을 향상시킵니다.\n\n구현:\n\n- 실시간 정보를 제공하기 위해 전자 상거래 플랫폼의 데이터베이스와 상호 작용하는 챗봇을 개발합니다.\n- 대화형 인공 지능을 사용하여 고객이 구매 프로세스를 안내하거나 상품을 업셀링/크로스셀링 할 수 있습니다.\n- 채팅 인터페이스를 통해 사용자가 주문을 직접 할 수 있도록 거래 기능을 구현합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n리소스:\n이미 개발된 솔루션을 위해 Magento와 Shopify은 AI를 전자 상거래 플랫폼에 통합하기 위한 API 및 개발자 리소스를 제공합니다.\n\n## 4.3 정신 건강 지원\n\n자동화된 공감 표현 응답을 통해 예비 정신 건강 지원 및 위기 대응을 제공합니다.\n\n구현:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- AI를 프로그램하여 정신 건강에 대한 언어를 인식하고 지원 자원을 제공하도록 합니다.\n- 기밀을 보장하고 전문적인 도움 링크를 제공합니다.\n- 상황의 긴급성을 판단하기 위해 감정 분석을 사용하고 필요시 인간 상담자에게 경고할 수 있습니다.\n\n자원:\n이미 개발된 솔루션에 대해 Woebot 등의 AI 기반 정신 건강 플랫폼을 참고하여 학습하십시오.\n\n## 4.4 교육 튜터 및 언어 학습\n\n컨셉을 설명하고 질문에 답변하며 언어 학습을 돕는 대화형 AI로 교육 자료를 보강하세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n구현:\n\n- 교육 콘텐츠에 특화된 도우미를 만들어 숙제와 시험 준비를 돕습니다.\n- 사용자와 대화하여 실수를 바로 잡고 개선점을 제안하는 언어 학습 봇을 구축합니다.\n\n자원:\n이미 개발된 솔루션을 찾으려면 Duolingo의 언어 연습용 챗봇을 살펴보세요.\n\n## 4.5 이벤트 계획과 알림\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n친절한 톤으로 번역해보겠습니다.\n\n캘린더를 관리하는 데 도움을 주어 이벤트 계획을 자동화하고 리마인더를 보내며 약속을 재스케줄링할 수 있습니다.\n\n구현:\n\n- 캘린더 API와 동기화하여 사용자가 WhatsApp을 통해 이벤트를 추가하고 쿼리할 수 있도록 합니다.\n- 대화에서 날짜와 시간 참조를 이해하기 위해 자연어 처리를 사용합니다.\n\n자원:\n이미 개발된 솔루션의 경우 Google Calendar API는 이벤트를 프로그래밍 방식으로 관리하는 기능을 제공합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 5. 도전과 한계\n\n오픈 에이 아이(OpenAI)와 트윌리오(Twilio)를 사용하여 WhatsApp 대화를 자동화하는 것은 여러 이점을 제공하지만, 발생할 수 있는 도전과 한계를 인식하는 것이 중요합니다.\n\n## 5.1 프라이버시와 보안에 대한 고려 사항\n\n도전: 민감한 개인 데이터를 처리하는 것은 개인정보 보호 법 및 보안 조치를 엄격히 준수하여 데이터 침해를 방지해야 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n고려 사항:\n\n- GDPR 및 HIPAA와 같은 규정 준수 보장\n- 데이터 전송 및 저장을 위해 end-to-end 암호화 구현\n- 새로운 위협에 대비하기 위해 보안 프로토콜을 정기적으로 감사 및 업데이트\n\n## 5.2 대화 맥락과 일관성\n\n도전 과제: AI 모델이 긴 또는 복잡한 대화에서 맥락과 일관성을 유지하는 것은 도전적일 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n고려 사항:\n\n- 고급 자연 언어 처리 기술을 활용하여 맥락을 이해합니다.\n- 계속해서 새로운 데이터로 모델을 훈련하여 일관성을 유지하는 능력을 향상시킵니다.\n- AI가 일관된 응답을 제공할 수 없는 상황을 우아하게 처리하기 위한 후행 메커니즘을 구현합니다.\n\n## 5.3 모호함과 오해 다루기\n\n도전: 자연어는 종종 모호하며, AI 모델은 사용자 의도나 감정을 오해할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n고려해야 할 사항:\n\n- 메시지의 감정적 톤을 더 잘 이해하기 위해 감성 분석을 사용하세요.\n- 모호성을 해소하고 정확한 응답을 보장하기 위해 명확한 질문을 사용하세요.\n- 반복되는 문제를 식별하고 수정하기 위해 AI 응답을 정기적으로 모니터링하고 검토하세요.\n\n## 5.4 확장성 및 성능\n\n도전 과제: 사용자 수가 증가함에 따라 성능과 확장성을 유지하는 것이 어려워질 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n고려해야 할 사항:\n\n- 고효율로 대량의 요청을 처리하기 위해 백엔드 인프라를 최적화합니다.\n- 수요 변동을 관리하기 위해 로드 밸런싱과 자동 확장을 구현합니다.\n- 시스템 성능을 정기적으로 모니터링하고 필요에 따라 조정합니다.\n\n## 5.5 윤리적 및 사회적 영향\n\n과제: AI의 개인 커뮤니케이션에서 윤리적 문제가 발생할 수 있습니다. 예를 들어 사람을 흉내내거나 인간 상호작용의 침해가 될 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n고려사항:\n\n- 사용자에게 AI 사용 사실을 명확히 알리고 동의를 받습니다.\n- 사용자의 복지와 개인정보 보호를 우선시하는 책임 있는 AI 사용을 위한 지침을 개발합니다.\n- 윤리적 우려를 다루고 사회 기대에 적응하기 위해 이해 관계자와 지속적인 대화에 참여합니다.\n\n## 5.6 기술적 제약사항\n\n과제: 현재 AI 모델은 복잡한 언어 뉘앙스, 관용구 및 문화적 언급을 이해하는 데 제약이 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n고려 사항:\n\n- 언어 능력을 향상시키기 위해 AI 모델을 지속적으로 업데이트하고 개선합니다.\n- 다양한 교육 데이터를 통합하여 모델이 다양한 언어와 문화를 이해하도록 합니다.\n- AI의 능력과 한계에 대해 사용자들에게 현실적인 기대를 설정합니다.\n\n# 마무리\n\n자신을 복제하는 개념은 의사 소통을 관리하는 것을 넘어, 자동으로 작동할 수 있는 대체 디지털 존재를 만드는 것입니다. 언젠가 그 대체 존재가 우리 대신에 일과 개인 생활의 측면을 처리할 수도 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기술, 철학적 및 규제적 도전 과제로 가득한 여정은 신중하게 탐색되어야 합니다. 인상적인 기술이기는 하지만 결함이 없는 것은 아니며, 배치되는 과정은 주의 깊게 그리고 전망을 내다보는 마음가짐으로 다뤄져야 합니다.\n\n읽어 주셔서 감사합니다. 만약 이 기사가 유익하다고 생각되시면 👏를 눌러서 향후 콘텐츠를 지원해 주시기 바랍니다.\n\nEntrepren erdly.com에서는 행동 가능한 지식으로 권한을 부여하는 튜토리얼, 코드 및 전략 전체 스위트를 제공합니다.\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-CloningYourselfonWhatsAppwithAIinPython_7.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 관련 기사:","ogImage":{"url":"/TIL/assets/img/2024-07-12-CloningYourselfonWhatsAppwithAIinPython_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-CloningYourselfonWhatsAppwithAIinPython_0.png","tag":["Tech"],"readingTime":30}],"page":"7","totalPageCount":28,"totalPageGroupCount":2,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"7"},"buildId":"QAkYP0lvl03W-5CKD69kb","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>