<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>TIL</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//posts/7" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="TIL" data-gatsby-head="true"/><meta property="og:title" content="TIL" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//posts/7" data-gatsby-head="true"/><meta name="twitter:title" content="TIL" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/873-eb138c3217d71553.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-de1dc5579188f9be.js" defer=""></script><script src="/_next/static/GnJ8pEcO5t2Vzpus740Q5/_buildManifest.js" defer=""></script><script src="/_next/static/GnJ8pEcO5t2Vzpus740Q5/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="튜토리얼 그만 이렇게 프로그래밍을 배워보세요" href="/post/2024-07-14-StopDoingTutorialsLearnProgrammingLikeThis"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="튜토리얼 그만 이렇게 프로그래밍을 배워보세요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-StopDoingTutorialsLearnProgrammingLikeThis_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="튜토리얼 그만 이렇게 프로그래밍을 배워보세요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">튜토리얼 그만 이렇게 프로그래밍을 배워보세요</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="TypeScript 네트워크 서버 구축법 Nodejs 멀티스레드 함수 작성하기" href="/post/2024-07-13-HowToWriteATypescriptNodeJSMulti-ThreadedFunction"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="TypeScript 네트워크 서버 구축법 Nodejs 멀티스레드 함수 작성하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-13-HowToWriteATypescriptNodeJSMulti-ThreadedFunction_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="TypeScript 네트워크 서버 구축법 Nodejs 멀티스레드 함수 작성하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">TypeScript 네트워크 서버 구축법 Nodejs 멀티스레드 함수 작성하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 13, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="튜토리얼 Typescript로 배우는 함수형 프로그래밍 실전 적용법" href="/post/2024-07-13-TutorialFunctionalProgramminginActionwithTypescript"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="튜토리얼 Typescript로 배우는 함수형 프로그래밍 실전 적용법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-13-TutorialFunctionalProgramminginActionwithTypescript_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="튜토리얼 Typescript로 배우는 함수형 프로그래밍 실전 적용법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">튜토리얼 Typescript로 배우는 함수형 프로그래밍 실전 적용법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 13, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="TypeScript의 Record 타입 완벽 마스터하기" href="/post/2024-07-13-MasteringTypeScriptsRecordType"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="TypeScript의 Record 타입 완벽 마스터하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-13-MasteringTypeScriptsRecordType_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="TypeScript의 Record 타입 완벽 마스터하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">TypeScript의 Record 타입 완벽 마스터하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 13, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Airflow 변수 완전 정복하는 방법" href="/post/2024-07-13-MasteringAirflowVariables"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Airflow 변수 완전 정복하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-13-MasteringAirflowVariables_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Airflow 변수 완전 정복하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Airflow 변수 완전 정복하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 13, 2024</span><span class="PostList_reading_time__6CBMQ">17<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Matplotlib를 사용한 데이터 시각화 방법" href="/post/2024-07-13-DataVisualizationwithMatplotlib"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Matplotlib를 사용한 데이터 시각화 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-13-DataVisualizationwithMatplotlib_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Matplotlib를 사용한 데이터 시각화 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Matplotlib를 사용한 데이터 시각화 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 13, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="지구과학자를 위한 파이썬 시작 가이드 코드를 개선하는 5가지 방법" href="/post/2024-07-13-GettingStartedWithPythonasaGeoscientistHereAre5WaysYouCanImproveYourCode"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="지구과학자를 위한 파이썬 시작 가이드 코드를 개선하는 5가지 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-13-GettingStartedWithPythonasaGeoscientistHereAre5WaysYouCanImproveYourCode_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="지구과학자를 위한 파이썬 시작 가이드 코드를 개선하는 5가지 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">지구과학자를 위한 파이썬 시작 가이드 코드를 개선하는 5가지 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 13, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Quantstats, TA, PyPortfolioOpt, FinanceToolkit을 이용한 미국 빅테크 주식 통합 퀀트 트레이딩 분석" href="/post/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Quantstats, TA, PyPortfolioOpt, FinanceToolkit을 이용한 미국 빅테크 주식 통합 퀀트 트레이딩 분석" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Quantstats, TA, PyPortfolioOpt, FinanceToolkit을 이용한 미국 빅테크 주식 통합 퀀트 트레이딩 분석" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Quantstats, TA, PyPortfolioOpt, FinanceToolkit을 이용한 미국 빅테크 주식 통합 퀀트 트레이딩 분석</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 13, 2024</span><span class="PostList_reading_time__6CBMQ">76<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Python의 가장 강력한 데코레이터" href="/post/2024-07-13-PythonsMostPowerfulDecorator"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Python의 가장 강력한 데코레이터" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-13-PythonsMostPowerfulDecorator_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Python의 가장 강력한 데코레이터" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Python의 가장 강력한 데코레이터</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 13, 2024</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="파이썬으로 랜덤 포레스트 직접 구현하는 방법" href="/post/2024-07-13-BuildingaRandomForestbyHandinPython"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="파이썬으로 랜덤 포레스트 직접 구현하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-13-BuildingaRandomForestbyHandinPython_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="파이썬으로 랜덤 포레스트 직접 구현하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">파이썬으로 랜덤 포레스트 직접 구현하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 13, 2024</span><span class="PostList_reading_time__6CBMQ">26<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link posts_-active__YVJEi" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"튜토리얼 그만 이렇게 프로그래밍을 배워보세요","description":"","date":"2024-07-14 19:40","slug":"2024-07-14-StopDoingTutorialsLearnProgrammingLikeThis","content":"\n\n마크다운 형식으로 테이블 태그를 변경해주세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그럭저럭요. 처음 프로그래밍 시험을 볼 때, 제가 코딩하는 방법을 모른다는 것을 깨달았어요. 컴퓨터를 바라보며 처음 몇 줄을 어떻게 작성할지 고민했죠.\n\n이게 요즘의 학습 과정을 현실적으로 알렸다는 거야.\n\n그래서 제 경험처럼 하지 마세요. 대신 이렇게 해보세요.\n\n# 코딩을 효과적으로 배우는 방법?\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n효과적으로 학습한다는 것이 무엇을 의미하는지부터 시작해 봅시다.\n\n학습은 단기 기억에서 장기 기억으로 정보를 연결하는 것입니다. 예를 들어 다시 읽거나 다시 시청하는 것은 공부하는 개념에 대한 어느 정도의 숙련도를 제공하지만, 해당 정보를 단기 기억(작동 중인 기억)에 \"보관\"합니다.\n\n이것이 당신이 아직 배우지 않은 것을 배운 것으로 생각하는 이유입니다.\n\n이것은 무언가를 배우는 비효과적인 방법입니다. 반면, 예를 들어 코딩을 효과적으로 배우기 위해서는 공부하는 정보를 회상해야 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다시 말해, 스스로를 시험하고 배운 것을 적용해야 합니다.\n\n- 악기를 배우고 싶다면 악기를 연습하십시오.\n- 축구를 배우고 싶다면 축구를 연습하세요.\n- 차를 운전하는 법을 배우고 싶다면 차를 운전해 보세요.\n- 프로그래밍을 배우고 싶다면 코딩하세요.\n\n# 운전을 배우는 것은 코딩을 배우는 것과 같다\n\n몇 주 전, 처음으로 차를 운전하는 법을 익혔습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n첫 수업 전에는 몇 개의 비디오를 보고 자동차가 어떻게 작동하는지 및 운전하는 방법에 대한 기본을 읽었어요. 물론, 실제 차와 연습하지 않으면 아무 소용이 없었죠.\n\n악기를 배울 때도 동일한 원리가 적용돼요.\n\n기타를 치는 법, 음계, 음표 등 기술적인 내용을 배울 수 있어요. 기본을 습득한 후 쉬운 즐겨듣는 노래 몇 곡을 배워봐요. 그 순간, 당신은 기억에 접목하는 중이에요.\n\n이것이 효과적인 학습이에요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 예시들은 까부러운 것 같지만, 이렇게 학습하는 많은 학생을 만난 적이 있어요. 그들은 앉아서 강의를 보며, 다시 보며, 어떻게든지 프로그래밍을 배워나가죠.\n\n여기서 배울 점은 코딩 없이는 프로그래밍을 배울 수 없다는 것이에요.\n\n## 초보자를 위한 몇 가지 프로젝트\n\n- 퀴즈 코드 작성하기.\n- 뱀 게임 코드 작성하기.\n- 데스크탑 정리 프로그램.\n- Streamlit을 이용한 데이터 분석 앱.\n- 호텔 데이터 웹 스크래핑 (고급).\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n주말에 보호하 실력을 동기화할 수 있는 5가지 파이썬 프로젝트를 확인해보세요 :)\n\n마지막으로, 정보 회수 실력을 연습하는 몇 가지 팁을 공유하겠습니다. 당신이 공부하는 어떤 주제에든지 이 팁을 적용해보세요 :)\n\n## 팁 1: 자유 회상\n\n- 책을 닫거나 창을 변경하세요.\n- 지금까지 배운 내용을 회상하세요(책을 보지 않고).\n- 옳은 답변에 대한 피드백을 받으세요.\n- 자신이 알고 있는 것과 모르는 것을 확인하세요.\n- 반복하세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 팁 2: 플래시카드\n\n- 당신의 자료로부터 플래시카드를 만드세요.\n- 정답을 보지 않고 질문에 솔직하게 대답하세요.\n- 스스로를 테스트하고 피드백을 받으세요.\n- 알고 있는 것과 모르는 것을 확인하세요.\n- 반복하세요.\n\n프로젝트가 학습에 중요하긴 하지만, 알고리즘이나 논리적 사고와 같은 기술적인 것을 소홀히하지 마세요.\n\n그것이 또 다른 내 실수였어요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n학습 여정에서 행운을 빕니다!\n\n# 도와드릴 수 있는 방법:\n\n- 내 새로운 무료 뉴스레터 'The Super Learning Lab'을 구독하세요.\n- 곧 나올 무료 학습 전자책과 이메일 코스를 기대해 주세요!\n\n![image](/TIL/assets/img/2024-07-14-StopDoingTutorialsLearnProgrammingLikeThis_1.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 내 최고의 학습 기사:\n\n- Ultralearning으로 모든 것 배우기\n- 초간단 정리: 9가지 울트라러닝 원칙\n- 울트라러닝으로 무료로 2개월만에 독일어 배우는 법\n- 학습을 당신의 슈퍼파워로 만드세요\n- 이렇게 하지 않고 책을 읽는 것을 그만하세요\n\n안녕,\n\nAxel","ogImage":{"url":"/TIL/assets/img/2024-07-14-StopDoingTutorialsLearnProgrammingLikeThis_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-StopDoingTutorialsLearnProgrammingLikeThis_0.png","tag":["Tech"],"readingTime":5},{"title":"TypeScript 네트워크 서버 구축법 Nodejs 멀티스레드 함수 작성하기","description":"","date":"2024-07-13 20:38","slug":"2024-07-13-HowToWriteATypescriptNodeJSMulti-ThreadedFunction","content":"\n\n\n![링크](/TIL/assets/img/2024-07-13-HowToWriteATypescriptNodeJSMulti-ThreadedFunction_0.png)\n\nTypeScript과 Node.js는 단일 스레드 및 이벤트 기반 모드에서 작동합니다. 그러나 Node.js에는 특정 시나리오를 위해 멀티 스레딩을 가능하게 하는 Worker Threads 모듈이 제공됩니다. Worker Threads 모듈을 사용하면 TypeScript 코드를 병렬로 실행하여 필요할 때 여러 스레드를 활용할 수 있습니다.\n\n# Node.js에서 멀티 스레딩\n\n단일 스레드 형식 — 기본적으로 Node.js는 TypeScript 코드를 실행하는 데 단일 스레드를 사용합니다. 이 설계는 여러 스레드를 관리하는 복잡성을 피하므로 비동기 작업을 간단하게 처리할 수 있습니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n워커 스레드 모듈 - 워커 스레드 모듈은 Node.js의 기능으로, 개발자가 메인 스레드와 별도로 추가 스레드를 생성할 수 있게 합니다. 이러한 워커 스레드는 TypeScript 코드를 독립적으로 실행하여 작업을 병렬로 처리할 수 있는 방법을 제공합니다.\n\n멀티 스레딩의 사용 사례 - 멀티 스레딩은 CPU 집중형 계산이나 병렬 비동기 작업과 같이 특정 작업을 분할하고 동시에 실행할 수 있는 시나리오에서 유용합니다. 이를 통해 여러 스레드의 처리 능력을 활용하여 응용 프로그램의 전반적인 성능을 향상시킬 수 있습니다.\n\n예제로 넘어가기 전에.... \n\n# 멀티 스레딩에 대한 추가 고려 사항\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n많은 이유로 멀티스레딩을 피하고 Node.js의 싱글 스레드 특성을 활용하는 것이 좋습니다. 전진하기 전에 고려해야 할 몇 가지 중요한 부분이 있습니다.\n\n스레드 관리 오버헤드: 멀티스레딩은 특정 시나리오에서 성능을 향상시킬 수 있지만, 스레드 관리와 관련된 오버헤드도 동반됩니다. 개발자들은 해당 상황에서 멀티스레딩의 이점이 해당 사용 사례에서의 오버헤드를 상회하는지 신중히 검토해야 합니다.\n\n동시성과 동기화: 여러 스레드로 작업할 때, 개발자들은 동시성과 동기화와 관련된 문제들을 다뤄야 합니다. 이는 공유 리소스를 관리하고 경쟁 조건을 방지하며 스레드 간 데이터 일관성을 보장하는 것을 포함합니다.\n\n확장성: 멀티스레딩은 멀티 코어 프로세서에서 사용 가능한 리소스를 효율적으로 활용할 수 있도록 해 확장성을 향상시킬 수 있습니다. 그러나 멀티스레드 애플리케이션을 확장하기 위해서는 부하 분산 및 리소스 경합과 같은 요소들을 신중히 고려하여 최적의 성능을 달성해야 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n디버깅 복잡성: 멀티스레드 응용 프로그램을 디버깅하는 것은 단일 스레드 응용 프로그램보다 얽힌 스레드 상호작용과 잠재적 동시성 문제로 인해 더 도전적일 수 있습니다. 개발자는 쓰레딩 관련 문제를 효과적으로 진단하고 해결하기 위해 전문적인 디버깅 도구와 기술을 사용해야 할 수도 있습니다.\n\n자원 관리: 멀티스레드 응용 프로그램은 단일 스레드 응용 프로그램보다 더 많은 시스템 자원(예: 메모리 및 CPU)을 소비할 수 있습니다. 개발자는 성능 저하와 잠재적 병목 현상을 피하기 위해 자원 사용을 주의 깊게 관리해야 합니다.\n\n잠재적 함정: 멀티스레드로 인해 성능 이점을 얻을 수 있지만, 데드락, 라이브락 및 스레드 기아와 같은 잠재적 함정이 소개될 수도 있습니다. 개발자는 이러한 개념을 이해하고 응용 프로그램 신뢰도와 성능에 미치는 영향을 완화하기 위해 최선의 방법을 사용해야 합니다.\n\n다음은 Worker Threads를 사용한 TypeScript 예시를 제공하겠습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```typescript\nimport { Worker, isMainThread, parentPort } from 'worker_threads';\n\nfunction runWorkerThread() {\n  if (isMainThread) {\n    // 이것은 메인 스레드입니다\n\n    // 새로운 워커 스레드를 생성합니다\n    const worker = new Worker(__filename);\n\n    // 워커 스레드로부터 메시지를 수신합니다\n    worker.on('message', (result: any) =\u003e {\n      console.log('워커로부터 결과:', result);\n    });\n\n    // 워커 스레드로 데이터를 보냅니다\n    worker.postMessage({ data: '메인 스레드로부터 안녕하세요!' });\n  } else {\n    // 이것은 워커 스레드입니다\n\n    // 메인 스레드로부터 메시지를 수신합니다\n    parentPort?.on('message', (message: any) =\u003e {\n      console.log('메인 스레드로부터 메시지:', message);\n\n      // 일부 무거운 계산을 수행합니다\n      const result = performHeavyComputation();\n\n      // 결과를 다시 메인 스레드로 보냅니다\n      parentPort?.postMessage(result);\n\n      // 워커 스레드를 종료합니다\n      parentPort?.close();\n    });\n\n    function performHeavyComputation() {\n      // 무거운 계산을 시뮬레이션합니다\n      let result = 0;\n      for (let i = 0; i \u003c 1e9; i++) {\n        result += i;\n      }\n      return result;\n    }\n  }\n}\n\n// 워커 스레드 실행을 위해 함수를 호출합니다\nrunWorkerThread();\r\n```\n\n이 예시는 메인 스레드와 워커 스레드로 구성된 멀티 스레드 설정을 보여줍니다. 무거운 계산은 워커 스레드에서 수행되고, 그 결과가 메인 스레드로 보내집니다.\n\n워커 스레드를 생성하고 관리하는 로직은 runWorkerThread 함수 내에 캡슐화되어 있습니다. 워커 스레드를 시작하려면 이 함수를 필요할 때 호출할 수 있습니다.\n\n본 내용을 즐기셨고 이러한 노력을 지원하고 싶으시다면 다음 링크를 방문해주세요: [https://ko-fi.com/jacobmacinnis](https://ko-fi.com/jacobmacinnis)\n","ogImage":{"url":"/TIL/assets/img/2024-07-13-HowToWriteATypescriptNodeJSMulti-ThreadedFunction_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-HowToWriteATypescriptNodeJSMulti-ThreadedFunction_0.png","tag":["Tech"],"readingTime":5},{"title":"튜토리얼 Typescript로 배우는 함수형 프로그래밍 실전 적용법","description":"","date":"2024-07-13 20:37","slug":"2024-07-13-TutorialFunctionalProgramminginActionwithTypescript","content":"\n\n\n![Tutorial Image](/TIL/assets/img/2024-07-13-TutorialFunctionalProgramminginActionwithTypescript_0.png)\n\n# 소개\n\n내 커리어 초반에 가르쳐진 한 가지는 JavaScript가 객체지향 언어가 아니라는 것이었습니다. 상속보다는 합성을 사용하고 함수(클래스가 아닌)를 일등 시민으로 다루는 것이 더 나은 접근이라는 것이죠. 전체 스택 역할을 하는 Scala가 백엔드 서비스로 사용되는 회사에 들어가니 정말 놀랍더군요. 프로그래밍에 대한 내가 알고 있던 것을 다시 생각해야 했고 Martin Odersky의 목소리를 듣는 데 많은 시간을 보내야 했습니다. 하지만 익숙해지고 나면 한 번도 되돌아보지 않았습니다. 그 이후로 프론트엔드를 위한 몇 가지 FP 트릭을 발견했는데 이를 공유하고 싶습니다.\n\n이 자습서에서는 RxJS, fp-ts 및 io-ts라는 3가지 라이브러리와 그들과 관련된 함수형 프로그래밍 패러다임을 다룰 것입니다. io-ts의 피어 종속성인 fp-ts를 알아야 합니다. \n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# FP 리프레셔\n\n함수형 프로그래밍은 대학 대수 수업에서 순수 함수에 대한 강의를 떠올리게 합니다. 출력이 제공된 입력에만 의존하는 것이 이를 의미합니다. 이는 데이터의 변이를 피하고 \"부작용\"이 없도록 하는 것으로 더 예측 가능한 코드를 작성할 수 있습니다. 이것은 불변 변수의 값이 한 번 설정되면 나중에 변경할 수 없다는 점 때문에 때로는 귀찮음이 될 수도 있습니다.\n\nmap과 같은 고차 함수는 한 개 이상의 함수를 인수로 받아 새로운 함수를 반환하는데 함수형 프로그래밍에서 기본적인 역할을 합니다. 재사용성과 모듈성을 통해 기반 함수를 설정하고 확장해 나가는 데 더 빠르게 이동할 수 있습니다. 객체 지향 프로그래밍 (OOP)은 데이터 변환 프로세스를 다룰 때 복잡해지는 반면, 싱글톤, 정적 함수 또는 정적 변수를 사용해야 하는지 여부에 대한 문제가 발생할 수 있는 반면, 함수형 프로그래밍은 평이한 함수의 사용을 옹호함으로써 이러한 시나리오를 단순화합니다. 말 그대로 모든 것이 함수입니다\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-TutorialFunctionalProgramminginActionwithTypescript_1.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# RxJS\n\n이 라이브러리는 특히 클래스 간에 상태 \"반응성\"을 제공할 수 있는 반응형 프로그래밍 라이브러리로서 인기가 있습니다. 이 라이브러리는 JS의 어떤 값의 변경에 반응하기 위해 채울 수 있는 컨테이너 또는 구조물로 생각할 수 있습니다. 아마도 예상하신 대로, React와 아주 잘 작동하며 훅을 위한 일등 지원을 제공합니다. RxJS의 주요 개념들 중 일부는 공식 문서에서 쉽게 찾을 수 있지만, 여러분의 편의를 위해 여기에 간단히 기재하였습니다:\n\n- Observables: RxJS는 시간이 지남에 따라 값 스트림을 방출하는 함수인 Observables 개념을 중심으로 구축되었습니다. Observables는 함수형 반응형 프로그래밍의 핵심 개념이며, 비동기 작업을 합성 및 선언적인 방식으로 표현할 수 있습니다.\n- Operators: RxJS는 Observables을 변환, 필터링, 결합 및 조작하는 데 사용할 수 있는 다양한 방식의 연산자를 제공합니다. Operators는 하나 이상의 observables을 입력으로 사용하고 새로운 observable을 출력으로 반환하는 순수 함수입니다.\n- 함수형 프로그래밍의 원칙들: RxJS는 불변성(한 번 생성되면 변경할 수 없음), 조합성(큰 애플리케이션을 위한 작은 구성 요소), 참조 투명성(동일한 입력은 몇 번 호출되었든 동일한 출력을 생성함)과 같은 많은 함수형 프로그래밍 원칙을 따릅니다. Observables 및 연산자는 부작용이 없는 순수 함수이며, 복합하여 복잡한 비동기 작업을 만들 수 있는 선언적인 방식으로 결합될 수 있습니다.\n\n# fp-ts\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 라이브러리는 RxJS만큼 인기가 없고 조금 더 복잡합니다. 이 라이브러리는 사용자가 숫자뿐만 아니라 어떤 데이터 유형이든 연결할 수 있는 미리 작성된 함수를 제공합니다.\n\n특징\n\n- 대수적 데이터 유형: fp-ts는 Option, Either, Task 등의 대수적 데이터 유형을 제공하여 복잡한 데이터 구조를 안전하고 조립 가능한 방식으로 표현할 수 있습니다. 대수적 데이터 유형은 함수형 프로그래밍의 핵심 개념으로, null/undefined 오류 및 기타 일반적인 런타임 오류를 피하는 데 도움이 됩니다.\n- 타입 클래스: fp-ts는 Functor, Applicative, Monad 등의 타입 클래스를 제공하여 필요한 인터페이스를 구현한 모든 데이터 유형과 작동하는 일반 함수를 정의할 수 있습니다. 타입 클래스는 추상화와 재사용을 위한 강력한 도구이며, 보다 일반적이고 조립 가능한 코드를 작성하는 데 도움이 됩니다.\n- 함수형 프로그래밍 원칙: fp-ts는 불변성, 조합성, 참조 투명성 등 많은 함수형 프로그래밍 원칙을 따릅니다. 대수적 데이터 유형과 타입 클래스는 부작용이 없는 순수 함수로, 안전하고 조립 가능한 방식으로 결합하여 복잡한 프로그램을 만들 수 있습니다.\n\n# io-ts\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 라이브러리는 3개 중 가장 작은 라이브러리이며 TypeScript 코드에 입력 및 출력 도우미를 제공합니다. 일반적인 사용 사례는 API 호출을 보내고 받는 것이지만 오디오 및 비디오와 같은 것들에도 유용합니다.\n\n특징\n\n- 런타임 유형 유효성 검사: io-ts는 데이터 구조에 대한 런타임 유형을 정의하는 방법을 제공하며 정의된 유형과 일치하는 데이터를 자동으로 유효성 검사하고 디코딩할 수 있습니다. 런타임 유형 유효성 검사는 런타임 오류를 방지하고 데이터 일관성을 보장하는 강력한 도구입니다.\n- 유형 추론: io-ts는 런타임 유형 정의에서 TypeScript 유형을 추론할 수 있어 IDE에서 중복되는 유형 주석을 작성하지 않고도 유형 안전성 및 자동완성을 얻을 수 있습니다.\n- 함수형 프로그래밍 원칙: io-ts는 불변성, 합성성, 참조 투명성과 같은 많은 함수형 프로그래밍 원칙을 따릅니다. 런타임 유형 정의는 부작용이 없는 순수 함수이며 선언적 방식으로 조합하고 재사용할 수 있습니다.\n\n# 리액트로 데모하기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n모든 세 가지 라이브러리를 사용하는 일반적인 사례는 API 호출을 필요 이상으로 복잡하게 만드는 것입니다. 우리가 일반적인 React.js 컴포넌트에서 어떻게 작동하는지 살펴봅시다.\n\n```js\nimport React, { useState, useEffect } from 'react';\nimport { Observable } from 'rxjs';\nimport { pipe } from 'fp-ts/lib/pipeable';\nimport { map, fold } from 'fp-ts/lib/Either';\nimport * as t from 'io-ts';\n\nconst ResponseType = t.type({\n  data: t.string,\n});\n\nconst fetchData = (): Observable\u003ct.TypeOf\u003ctypeof ResponseType\u003e\u003e =\u003e {\n  return Observable.create(({ error, next, complete }) =\u003e {\n    fetch('https://example.com/api/data')\n      .then((response) =\u003e response.json())\n      .then((data) =\u003e {\n        const result = ResponseType.decode(data);\n        pipe(\n          result,\n          fold(\n            error,\n            next,\n          ),\n        );\n        complete();\n      })\n      .catch(error);\n  });\n};\n\nconst MyComponent = () =\u003e {\n  const [data, setData] = useState({});\n\n  useEffect(() =\u003e {\n    const subscription = fetchData().subscribe(({ data }) =\u003e setData(data));\n    return () =\u003e {\n      subscription.unsubscribe();\n    };\n  }, []);\n\n  return \u003cdiv\u003e{data}\u003c/div\u003e;\n};\n```\n\n이 예제에서는 io-ts를 사용하여 예상되는 API 응답의 형태를 나타내는 런타임 타입 ResponseType를 정의합니다. 그런 다음 API 호출을 수행하고 응답의 Observable을 반환하는 fetchData 함수를 정의합니다.\n\nReact 컴포넌트에서 useState 훅을 사용하여 검색한 데이터를 추적합니다. 그런 다음 useEffect 훅을 사용하여 fetchData에 의해 반환된 Observable을 구독합니다. 컴포넌트가 마운트될 때 Observable을 구독하고 데이터가 도착하면 검색된 데이터로 상태를 업데이트합니다. 또한 컴포넌트가 마운트 해제될 때 Observable을 구독 취소하여 메모리 누수를 방지합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nfp-ts의 pipe 함수를 사용하여 API 응답의 디코딩과 결과를 Either로 폴딩하는 작업을 조합합니다. 이를 통해 디코딩 오류와 API 오류를 기능적이고 조합 가능한 방식으로 처리할 수 있습니다.\n\n이제 더 고급 사용 사례를 살펴보고 GraphQL API와 함께 웹 데이터 테이블을 표시하는 방법을 살펴봅시다:\n\n```js\nimport React, { useState, useEffect } from 'react';\nimport { pipe } from 'fp-ts/lib/pipeable';\nimport { map, fold } from 'fp-ts/lib/Either';\nimport * as t from 'io-ts';\nimport { ApolloClient, InMemoryCache, gql } from '@apollo/client';\nimport { Observable } from 'rxjs';\n\nconst ResponseType = t.type({\n  data: t.type({\n    users: t.array(\n      t.type({\n        id: t.string,\n        name: t.string,\n        email: t.string,\n        phone: t.string,\n      }),\n    ),\n  }),\n});\n\nconst fetchData = (): Observable\u003ct.TypeOf\u003ctypeof ResponseType\u003e\u003e =\u003e {\n  const client = new ApolloClient({\n    uri: 'https://mygraphqlapi.com/graphql',\n    cache: new InMemoryCache(),\n  });\n\n  const query = gql`\n    query {\n      users {\n        id\n        name\n        email\n        phone\n      }\n    }\n  `;\n\n  return Observable.create(({ error, next, complete }) =\u003e {\n    client\n      .query({ query })\n      .then(({ data }) =\u003e {\n        const result = ResponseType.decode(data);\n        pipe(\n          result,\n          fold(\n            error,\n            next,\n          ),\n        );\n        complete();\n      })\n      .catch(error);\n  });\n};\n\nconst UserTable = () =\u003e {\n  const [users, setUsers] = useState([]);\n\n  useEffect(() =\u003e {\n    const subscription = fetchData().subscribe(({ data: { users } }) =\u003e setUsers(users));\n    return () =\u003e {\n      subscription.unsubscribe();\n    };\n  }, []);\n\n  return (\n    | 표\n    | 머리글\n    | 승객\n    | 별명\n    | 전자 메일\n    | 전화번호\n    | ------\n    | ----------\n    | -------- \n    | {users.map(({ id, name, email, phone }) =\u003e (\n      \u003ctr key={id}\u003e\n        \u003ctd\u003e{id}\u003c/td\u003e\n        \u003ctd\u003e{name}\u003c/td\u003e\n        \u003ctd\u003e{email}\u003c/td\u003e\n        \u003ctd\u003e{phone}\u003c/td\u003e\n      \u003c/tr\u003e\n    ))}\n    | \n  );\n};\n```\n\n이 예제에서는 우리의 GraphQL 응답의 예상 모양을 나타내는 io-ts를 사용하여 런타임 유형인 ResponseType을 정의합니다. ApolloClient를 사용하여 GraphQL API에서 데이터를 가져오고 응답의 Observable을 반환하는 fetchData 함수를 정의합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리의 React 컴포넌트에서는 useState 훅을 사용하여 가져온 데이터를 추적합니다. 그런 다음 useEffect 훅을 사용하여 fetchData에 의해 반환된 Observable을 구독합니다. 컴포넌트가 마운트될 때 Observable을 구독하고 데이터가 도착하면 상태를 업데이트합니다. 또한 컴포넌트가 마운트 해제될 때 Observable을 구독해제하여 메모리 누수를 방지합니다.\n\n마지막으로, 가져온 데이터를 사용하여 웹 데이터 테이블을 렌더링합니다. 사용자 배열을 매핑하고 각 사용자에 대한 행을 렌더링하여 ID, 이름, 이메일 및 전화번호를 표시합니다.\n\n# 결론\n\n제 전문 경력의 대부분에서 프로젝트의 핵심 라이브러리와 기술 스택은 일반적으로 제 입성 전에 구현되었습니다. 새로 합류한 팀에게 다른 방향으로 이주할 것을 설득하는 것은 거의 불가능할 수 있습니다. 이미 있는 것에 헌신하고 나아가야 합니다. 그러나 운이 좋으면 JS 코드베이스에 함수형 프로그래밍 패턴과 라이브러리를 소개할 수있는 경우가 있습니다. 그렇게 하면 훨씬 더 행복할 수 있습니다! 프로그래밍 실수로 인해 버그가 발생할 가능성이 적어진다고 (제 의견으로는) 확신합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안녕하세요! 궁금한 점, 의견, 뜨거운 이야기가 있으면 아래에 남겨주세요!","ogImage":{"url":"/TIL/assets/img/2024-07-13-TutorialFunctionalProgramminginActionwithTypescript_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-TutorialFunctionalProgramminginActionwithTypescript_0.png","tag":["Tech"],"readingTime":10},{"title":"TypeScript의 Record 타입 완벽 마스터하기","description":"","date":"2024-07-13 20:36","slug":"2024-07-13-MasteringTypeScriptsRecordType","content":"\n\n\n![Record Type](/TIL/assets/img/2024-07-13-MasteringTypeScriptsRecordType_0.png)\n\nTypeScript의 Record 타입은 우리가 key-value 쌍 타입을 정의하는 데 도움이 되는 매우 유용한 도구입니다. 이 기사에서는 Record 타입의 다양한 응용 시나리오를 탐구하고, 코드 품질과 유지 관리성을 향상시킬 수 있는 방법에 대해 알아보겠습니다.\n\n# 1. Record Type이란 무엇인가요?\n\nRecord 타입은 TypeScript에서 내장된 일반적인 제네릭 타입으로, 키와 값이 지정된 타입인 객체 타입을 구성하는 데 사용됩니다. 다음과 같이 정의됩니다:\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n유형 레코드`K, T`는 그 키가 유형 K이고 값이 유형 T인 개체를 나타냅니다. 간단한 예제를 살펴봅시다:\n\n유형 사용자 = {\n  이름: 문자열;\n  나이: 숫자;\n};\n\n유형 사용자레코드 = 레코드 \u003c문자열, 사용자\u003e;\n\n상수 사용자: 사용자레코드 = {\n  사용자1 : { 이름: \"앨리스\", 나이: 25 },\n  사용자2 : { 이름: \"밥\", 나이: 30 },\n};\n\n이 예제에서 UserRecord는 키가 문자열 형식이고 값이 사용자 형식인 개체를 나타냅니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 2. 레코드와 튜플의 차이\n\n레코드와 튜플은 TypeScript에서 객체 구조를 정의하는 데 사용되는 도구입니다. 그러나 사용 용도와 특성이 다릅니다.\n\n- 레코드: 키-값 쌍을 정의하는 데 사용되며, 키와 값의 타입이 임의적일 수 있습니다.\n- 튜플: 고정된 길이와 타입의 배열을 정의하는 데 사용됩니다.\n\n## 코드 예제:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\ntype UserTuple = [string, number]; // 튜플 타입\n\nconst userTuple: UserTuple = [\"Alice\", 25]; // 유효함\n// const invalidUserTuple: UserTuple = [25, \"Alice\"]; // 오류: 타입 불일치\n\ntype UserRecord = Record\u003cstring, number\u003e;\n\nconst userRecord: UserRecord = {\n  Alice: 25,\n  Bob: 30,\n};\n\n# 3. Record과 Map의 차이점\n\nRecord와 Map은 모두 키-값 쌍을 저장하는 데 사용될 수 있지만, 중요한 차이점이 있습니다:\n\n- Record: 컴파일 시간에 타입 체크를 위해 사용되는 타입 정의 도구.\n- Map: ES6에서 소개된 데이터 구조로, 런타임에서 키-값 쌍을 저장하는 데 사용됨.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 코드 예시:\n\n// Record를 사용\ntype UserAges = Record\u003cstring, number\u003e;\n\nconst userAges: UserAges = {\n  Alice: 25,\n  Bob: 30,\n};\n\n// Map 사용\nconst userAgeMap = new Map\u003cstring, number\u003e();\nuserAgeMap.set(\"Alice\", 25);\nuserAgeMap.set(\"Bob\", 30);\n\nconsole.log(userAgeMap.get(\"Alice\")); // 결과: 25\n\n# 4. 모든 경우 다루기\n\nRecord 타입을 사용할 때, 모든 가능한 경우를 다루도록 하여 모든 경우에 대해 처리하도록 할 수 있습니다. 특히 유니언 타입을 다룰 때 유용합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 코드 예시:\n\ntype Status = \"success\" | \"error\" | \"loading\";\n\nconst statusMessages: Record\u003cStatus, string\u003e = {\n  success: \"작업이 성공적으로 완료되었습니다\",\n  error: \"오류가 발생했습니다\",\n  loading: \"로딩 중...\",\n};\n\n// getStatusMessage 함수를 사용할 때 모든 경우의 수를 처리하도록 보장\nfunction getStatusMessage(status: Status): string {\n  return statusMessages[status];\n}\n\n이 예제에서 Record`Status, string`은 statusMessages 객체에서 모든 가능한 Status 값이 처리되도록 보장하며, getStatusMessage 함수에서 각 상태 메시지에 안전하게 접근할 수 있게 합니다.\n\n# 5. 제네릭 애플리케이션에서 타입 체킹 강제화\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nRecord 유형은 일반 프로그래밍에서 매우 유용하며 키와 값 사이의 일관성을 보장하고 유형 검사를 강제할 수 있게 해줍니다.\n\n## 코드 예시:\n\nfunction createRecord\u003cK extends string, T\u003e(keys: K[], value: T): Record\u003cK, T\u003e {\n  const record: Partial\u003cRecord\u003cK, T\u003e\u003e = {};\n  keys.forEach(key =\u003e {\n    record[key] = value;\n  });\n  return record as Record\u003cK, T\u003e;\n}\n\nconst record = createRecord([\"Alice\", \"Bob\"], 25);\nconsole.log(record); // 결과: { Alice: 25, Bob: 25 }\n\n이 예시에서 createRecord 함수는 키 배열과 값을 가져와 Record 유형을 사용하여 생성된 객체의 키와 값이 일관되도록 보장합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 6. 선택적 타입 매핑을 위해 Pick 타입과 Record 사용하기\n\n특정 속성만 포함된 객체 타입을 만들기 위해 Pick과 Record 타입을 결합할 수 있습니다.\n\n## 코드 예시:\n\ninterface User {\n  id: number;\n  name: string;\n  age: number;\n  email: string;\n}\n\ntype UserInfo = Pick\u003cUser, \"id\" | \"name\"\u003e;\n\ntype UserInfoRecord = Record\u003cstring, UserInfo\u003e;\n\nconst userInfo: UserInfoRecord = {\n  user1: { id: 1, name: \"Alice\" },\n  user2: { id: 2, name: \"Bob\" },\n};\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 예시에서는 사용자 인터페이스에서 id와 name 속성을 선택하기 위해 Pick 타입을 사용하고, Record 타입을 사용하여 이러한 속성을 포함하는 객체 타입을 생성합니다.\n\n# 7. Record를 사용한 동적 Key-Value 사전 구현\n\nRecord 타입은 동적 키-값 사전을 구현하기에 적합하며, 특히 동적 키와 값이 필요할 때 유용합니다.\n\n## 코드 예시:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\ntype Dictionary\u003cT\u003e = Record\u003cstring, T\u003e;\n\nconst stringDictionary: Dictionary\u003cstring\u003e = {\n  key1: \"value1\",\n  key2: \"value2\",\n};\n\nconst numberDictionary: Dictionary\u003cnumber\u003e = {\n  key1: 1,\n  key2: 2,\n};\n\n이 예시에서 Dictionary 타입은 어떤 타입의 key-value 쌍을 저장하는 데 사용할 수 있어 코드를 더 유연하고 일반적으로 만들어줍니다.\n\n# 8. Record와 함께 ReadOnly 사용하기\n\nReadOnly와 Record 타입을 함께 사용하여 수정할 수 없는 key-value 쌍 객체를 만들 수 있습니다. 이를 통해 객체의 프로퍼티가 수정될 수 없도록 보장합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 코드 예시:\n\ntype ReadOnlyUserRecord = Readonly\u003cRecord\u003cstring, User\u003e\u003e;\n\nconst readOnlyUsers: ReadOnlyUserRecord = {\n  user1: { name: \"Alice\", age: 25 },\n  user2: { name: \"Bob\", age: 30 },\n};\n\n// readOnlyUsers.user1 = { name: \"Charlie\", age: 35 }; // 오류: 'user1'에 할당할 수 없습니다. 읽기 전용 속성이기 때문에\n\n이 예시에서는 Readonly와 Record 타입을 결합하여 수정할 수 없는 사용자 레코드 객체를 만들어 객체의 속성을 수정할 수 없도록 보장합니다.\n\n# 9. Record와 Partial 함께 사용하기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n부분 및 레코드 유형을 결합하여 모든 속성이 선택적인 객체를 만들 수 있어요.\n\n## 코드 예시:\n\ntype PartialUserRecord = Partial\u003cRecord\u003cstring, User\u003e\u003e;\n\nconst partialUsers: PartialUserRecord = {\n  user1: { name: \"Alice\", age: 25 },\n  user2: undefined, // 속성이 선택적이므로 유효합니다\n};\n\n이 예시에서 Partial 및 Record의 결합을 통해 속성이 선택적인 객체를 정의할 수 있어서 부분적인 데이터를 처리하는 데 매우 유용합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 10. Record를 사용하여 모든 속성을 필수로 강제하는 방법\n\n어떤 경우에는 객체의 모든 속성이 필수임을 보장해야 할 수도 있습니다. Required와 Record 타입을 결합하여 이를 달성할 수 있습니다.\n\n## 코드 예시:\n\ninterface Config {\n  host?: string;\n  port?: number;\n}\n\ntype RequiredConfig = Required\u003cConfig\u003e;\n\ntype ConfigRecord = Record\u003cstring, RequiredConfig\u003e;\n\nconst configs: ConfigRecord = {\n  dev: { host: \"localhost\", port: 8080 },\n  prod: { host: \"example.com\", port: 80 },\n};\n\n// 'port'가 필수이기 때문에 에러가 발생합니다\n// const invalidConfigs: ConfigRecord = {\n//   dev: { host: \"localhost\" }\n// };\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 예시에서는 Config 객체의 모든 속성이 필수로 입력되도록 Required 및 Record 유형을 사용하여 구성 객체의 완성도를 보장합니다.\n\n이 글을 통해 TypeScript의 Record 유형의 다양한 응용 프로그램 시나리오를 자세히 살펴보았습니다. Record 유형의 기본 정의, Tuple 및 Map과의 차이점, 그리고 실제 응용프로그램에서 코드 가독성과 유지 관리성을 향상시키기 위해 Record 유형을 사용하는 방법에 대해 배웠습니다. 이러한 예시들이 Record 유형을 더 잘 이해하고 적용할 수 있도록 도와드리고 TypeScript 코드를 더 효율적이고 신뢰할 수 있게 만들기를 바랍니다.","ogImage":{"url":"/TIL/assets/img/2024-07-13-MasteringTypeScriptsRecordType_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-MasteringTypeScriptsRecordType_0.png","tag":["Tech"],"readingTime":9},{"title":"Airflow 변수 완전 정복하는 방법","description":"","date":"2024-07-13 20:34","slug":"2024-07-13-MasteringAirflowVariables","content":"\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-MasteringAirflowVariables_0.png\" /\u003e\n\n만약 여러 데이터 파이프라인이 동일한 API 엔드포인트와 상호 작용해야 하는 상황이 있다면, 정말 모든 파이프라인에서 이 엔드포인트를 선언해야 할까요? 이 엔드포인트가 나중에 변경된다면, 모든 파일에서 해당 값을 업데이트해야 합니다.\n\nAirflow 변수는 간단하면서도 가치 있는 구조로, 여러 DAG에서 중복 선언을 방지하는 데 사용됩니다. 이들은 단순히 키와 JSON 직렬화 가능한 값으로 구성된 객체로, Airflow의 메타데이터베이스에 저장됩니다.\n\n그리고 코드가 토큰이나 기타 유형의 비밀을 사용한다면 어떻게 해야 할까요? 평문으로 하드코딩하는 것은 안전한 접근 방식으로 보이지 않습니다. 반복을 줄이는 데 beyond하는 Airflow 변수는 민감한 정보를 관리하는 데도 도움이 됩니다. Airflow에서 변수를 정의하는 여섯 가지 다양한 방법 중에서 적합한 방법을 선택하는 것은 보안과 이식성을 보장하기 위해 중요합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자주 간과되는 측면 중 하나는 변수 검색이 Airflow 성능에 미치는 영향입니다. 스케줄러가 DAG 파일을 파싱할 때마다 메타데이터베이스에 요청하는 것은 성능에 부담이 될 수 있습니다(기본값은 삼십 초입니다).\n\n이 함정에 빠지기는 꽤 쉽습니다. DAG를 구문 분석하는 방법과 데이터베이스에서 변수를 검색하는 방법을 이해하지 않는 한요하는 베스트 프렉티스를 적용하는 것이 중요합니다.\n\n# Airflow 변수 정의\n\nDAG 파일을 파싱하는 방법과 DAGs를 최적화하기 위해 적용해야 하는 베스트 프렉티스에 대해 논의하기 전에, 기초를 제대로 이해하는 것이 중요합니다. 여기서는 어떻게 Airflow에서 변수를 선언하는지에만 초점을 맞춰 보겠습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이미 언급한 바와 같이, Airflow에서 변수를 선언하는 여러 가지 방법이 있습니다. 그 중 일부는 다른 것보다 더 안전하고 이식성이 뛰어난 것으로 나타나므로, 이들의 장단점을 살펴보고 이해해 봅시다.\n\n## 1. 사용자 인터페이스에서 변수 생성\n\n첫 번째 방법으로, 사용자 인터페이스를 통해 변수를 생성하는 방법을 살펴보겠습니다. 상위 메뉴에서 Admin → Variables → + 를 선택합니다.\n\n키와 값을 입력한 후, 만들기를 클릭하여 생성합니다. 변수는 이제 변수 목록에서 확인할 수 있어야 합니다. 기본적으로 UI에서 생성된 변수는 자동으로 메타데이터 데이터베이스에 저장됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n변수 값이 평문으로 표시된다는 것을 알 수 있어요. Airflow 변수 중 민감한 정보를 저장하려면 UI 방식이 가장 적합하지 않을 수 있어요.\n\n또한, 이 방법은 이식성이 떨어집니다. 환경을 재생성하려면 먼저 현재 환경에서 수동으로 내보내고, 마지막으로 새로 만든 환경으로 다시 가져와야 해요.\n\n## 2. 환경 변수를 내보내어 변수 생성하기\n\n두 번째 옵션은 AIRFLOW_VAR_`변수_이름` 표기법을 사용하여 환경 변수를 내보내는 것이에요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음 명령어를 사용하여 두 변수인 foo와 bar를 생성할 수 있습니다.\n\n```js\nexport AIRFLOW_VAR_FOO=my_value\nexport AIRFLOW_VAR_BAR='{\"newsletter\":\"Data Pipeline\"}'\n```\n\n이 방법의 장점 중 하나는 환경 변수를 통해 생성된 변수가 UI에 표시되지 않는다는 것입니다(물론 코드에서 참조할 수는 있습니다). 즉, 민감한 정보가 노출되지 않습니다.\n\nUI를 통해 생성된 변수와는 달리, 이 방법은 메타데이터베이스에 지속적으로 저장하지 않습니다. 따라서 환경 변수를 사용하면 데이터베이스 연결을 설정할 필요가 없어 빠르게 검색할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하지만 여전히 환경 변수를 관리하는 것도 어려울 수 있습니다. 환경 변수가 Airflow 배포를 담당하는 자동화 스크립트에서 사용되는 파일에 저장된 경우 값들을 어떻게 안전하게 보호할 수 있을까요?\n\n## 3. Airflow CLI를 통한 변수 생성\n\nAirflow CLI를 사용하여 변수를 생성할 수도 있습니다. 먼저 Airflow 스케줄러 워커에 연결해야 합니다. 예를 들어 Docker를 통해 Airflow를 실행 중이라면, 먼저 스케줄러의 컨테이너 ID를 찾은 다음 다음 명령을 실행하세요.\n\n```js\ndocker exec -it \u003cairflow-scheduler-container-id\u003e /bin/bash\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAirflow 변수를 만들려면 다음의 명령어를 사용할 수 있어요:\n\n```js\nairflow variables set \\\n    my_cli_var \\\n    my_value \\\n    --description '이 변수는 CLI를 통해 생성되었어요'\n```\n\n만약 특정 변수에 여러 값을 할당하려면 JSON 형식을 사용하는 것이 좋아요:\n\n```js\nairflow variables set \\\n    my_cli_json_var \\\n    '{\"key\": \"value\", \"another_key\": \"another_value\"}' \\\n    --description '이 변수는 CLI를 통해 생성되었어요'\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nJSON 변수를 직렬화하는 옵션도 있습니다. 이를 위해 -j 또는 --json 플래그를 제공하여 수행할 수 있습니다.\n\n```js\nairflow variables set \\\n    --json \\\n    my_cli_serialised_json_var \\\n    '{\"key\": \"value\", \"another_key\": \"another_value\"}' \\\n    --description 'CLI를 통해 생성된 이 변수'\n```\n\n이제 UI의 변수 목록으로 돌아가보면, 이전 단계에서 만든 세 가지 변수가 모두 표시됩니다.\n\nCLI를 통해 생성된 변수는 UI에서 확인할 수 있어 민감한 정보도 노출되고 메타데이터베이스에 저장될 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n내 의견으로는, 이 방법은 개발 환경에서 유용합니다. 특정 변수를 빠르게 생성하고 테스트하거나 해당 변수를 참조하는 기능을 테스트하고 싶을 때 유용합니다. 프로덕션 배포의 경우, 변수를 생성(또는 업데이트)하기 위한 자동화 스크립트를 작성해야 하며, 이 정보는 파일에 저장되어야 합니다. 그렇기 때문에 몇 가지 변수에는 민감한 정보가 포함될 수 있어 처리하기 어려울 수 있습니다.\n\n## 4. REST API를 사용하여 변수 생성\n\n이 네 번째 방법은 REST API를 호출하여 몇 가지 변수를 생성하는 것을 포함합니다. 이는 Airflow CLI 방식과 유사하며 동일한 장단점을 제공합니다.\n\n```js\ncurl -X POST ${AIRFLOW_URL}/api/v1/variables \\\n        -H \"Content-Type: application/json\" \\\n        --user \"${AIRFLOW_USERNAME}:${AIRFLOW_PASSWORD}\" \\\n        -d '{\"key\": \"json_var\", \"value\": \"{\\\"key1\\\":\\\"val1\\\"}\"}'\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 5. 변수를 프로그래밍적으로 생성하기\n\n프로그래밍적으로 변수를 생성하는 것도 실행 가능하고 간단합니다.\n\n```js\ndef create_vars():\n    from airflow.models import Variable\n\n    Variable.set(key='my_var', value='my_val')\n    Variable.set(\n        key='my_json_var', \n        value={'my_key': 23, 'another_key': 'another_val'}, \n        serialize_json=True,\n    )\n\n...\n\nPythonOperator(\n    task_id='create_variables',\n    python_callable=create_vars,\n)\n```\n\n물론 이것은 나쁜 관행이며 프로덕션 배포에서 피해야 합니다. 변수 - 특히 민감한 정보를 포함하는 변수 - 는 DAG 파일에서 선언되어서는 안 되며 코드는 버전 관리되고 UI의 코드 탭에서도 볼 수 있기 때문입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 6. 시크릿 스토어/백엔드에서 변수 만들기 ❤\n\n환경 변수나 메타스토어 데이터베이스에서 변수를 검색하는 것 외에도 Airflow 변수를 검색하기 위해 대체 시크릿 백엔드를 활성화할 수 있습니다.\n\n현재 Apache Airflow 커뮤니티에서 제공하는 시크릿 백엔드 구현에는 다음이 포함됩니다:\n\n- Amazon (Secrets Manager 및 Systems Manager Parameter Store)\n- Google (Cloud Secret Manager)\n- Microsoft (Azure Key Vault)\n- HashiCorp (Vault)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n사실, Airflow에서 변수를 정의하는 가장 좋고 안전하며 휴대성이 뛰어난 방법입니다.\n\n# 민감한 변수 값 숨기기\n\n이전 섹션에서 설명한 몇 가지 방법 중 일부에서 민감한 정보가 실제로 사용자 인터페이스에 표시될 수 있다고 언급했습니다. 사실, 변수가 올바르게 이름 지어진 경우에는 민감한 값을 숨길 수 있습니다.\n\n변수 이름에 특정 키워드가 포함되어 민감한 정보를 나타낼 수 있다고 생각되면 해당 값이 자동으로 숨겨집니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음은 민감한 정보를 값으로 저장하게끔 변수를 자격 부여할 키워드 목록입니다:\n\n```js\naccess_token\napi_key\napikey\nauthorization\npassphrase\npasswd\npassword\nprivate_key\nsecret\ntoken\nkeyfile_dict\nservice_account\n```\n\n만약 변수 이름에 이 키워드 중 하나가 포함되어 있다면, Airflow는 해당 값을 적절히 처리할 것입니다. 이 기능이 예상대로 작동하는지 확인하기 위해 예제를 시도해 보겠습니다.\n\n먼저, 위에 언급된 키워드 중 하나를 추가하지 않고 새 변수를 만들어 보겠습니다. 우리는 변수의 값이 사용자 인터페이스에서 보이는 것을 확인할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음 화면에서는 새로운 변수인 my_api_key를 생성하려고 시도합니다. 이전에 토론한 대로 변수 이름에 api_key 키워드가 포함되어 있기 때문에 Airflow는 민감한 정보를 보호하는 방식으로 해당 값을 처리해야 합니다.\n\n실제로 지금 UI의 변수 목록으로 돌아가보면 새로 생성된 변수의 값을 숨겨진 것을 볼 수 있습니다.\n\n기존 키워드 목록에 만족스럽지 않다면, 추가적인 키워드를 지정하여 변수 값 숨김 시 고려해야 하는 키워드 목록을 확장할 수도 있습니다. 이는 airflow.cfg( [core] 섹션 내)의 sensitive_var_conn_names를 통해 구성하거나 AIRFLOW__CORE__SENSITIVE_VAR_CONN_NAMES 환경 변수를 내보내는 것으로 설정할 수 있습니다.\n\n# 효율적인 변수 검색\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기본 설정으로 Airflow DAG는 30초마다 구문 분석됩니다. 스케줄러는 DAG 폴더를 스캔하여 DAG 파일에 대한 변경 사항을 식별합니다. 변수를 올바르게 가져오지 않으면 DAG 구문 분석 프로세스가 곧 병목 현상이 될 수 있습니다.\n\n변수를 선언하는 방법에 따라 Airflow는 DAG 파일에서 선언된 각 변수에 대해 메타스토어 데이터베이스에 연결을 초기화해야 할 수 있습니다.\n\n# 요청으로 메타스토어 과부하 피하기\n\nDAG에서 변수를 검색하기 위해 두 가지 접근 방식을 취할 수 있습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Variable.get() 함수 사용\n- var 템플릿 변수 사용\n\n만약 첫 번째 옵션을 선택하신 경우, Variable.get()은 지정된 변수의 값을 추론하기 위해 메타스토어 데이터베이스와의 새로운 연결을 생성할 것입니다. 이제 DAG 파일에서 이 함수를 호출하는 위치는 성능에 큰 영향을 미칠 수 있습니다.\n\n## 잘못된 예시\n\n만약 이 함수가 태스크 외부에서 호출되거나 DAG Context Manager 내에서 호출된다면, 메타스토어와의 -의미 없는- 새로운 연결이 DAG가 파싱될 때마다 생성될 것입니다(즉, 30초마다).\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nfrom datetime import datetime\n\nfrom airflow import DAG\nfrom airflow.models import Variable\nfrom airflow.operators.python import PythonOperator\n\nmy_var = Variable.get('my_var')\n\nwith DAG('my_dag', start_date=datetime(2024, 1, 1)) as dag:\n    print_var = PythonOperator(\n        task_id='print_var',\n        python_callable=lambda: print(my_var),\n    )\n```\n\n만약 동일한 패턴이 많은 다른 DAG에서 사용된다면, 언젠가는 메타스토어 데이터베이스에 문제가 발생할 수 있습니다.\n\n실제로 이 패턴을 피할 수 없는 몇 가지 예외적인 상황이 있습니다. 예를 들어 변수의 값에 따라 동적으로 작업을 생성하고 싶다고 가정해보겠습니다. 그 경우 해당 함수를 작업 외부에서 호출하거나 Context Manager 내에서 호출해야 할 수도 있습니다. 하지만 가능하면 이 접근 방식을 피하는 것이 중요합니다.\n\n또한, 연산자의 인수에서 Variable.get() 함수를 호출하더라도 동일한 문제가 발생할 것임을 언급하는 것이 중요합니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nfrom datetime import datetime\n\nfrom airflow import DAG\nfrom airflow.models import Variable\nfrom airflow.operators.python import PythonOperator\n\ndef _print_var(my_var):\n    print(my_var)\nwith DAG('my_dag', start_date=datetime(2024, 1, 1)) as dag:\n    print_var = PythonOperator(\n        task_id='print_var',\n        python_callable=_print_var,\n        op_args=[Variable.get('my_var')],\n    )\n```\n\n사실 템플릿 엔진을 사용하면 이런 문제를 쉽게 피할 수 있어요.\n\n## Best Practices\n\n기본적으로 Variable.get()를 호출하는 대신에 템플릿 참조를 사용할 수 있어요. 이 기술을 사용하면 변수의 값은 런타임에만 가져와지게 돼요.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래의 코드 스니펫은 JSON 또는 JSON이 아닌 값에 대한 변수의 템플릿 참조를 사용하는 방법을 보여줍니다.\n\n```js\nfrom datetime import datetime\n\nfrom airflow import DAG\nfrom airflow.models import Variable\nfrom airflow.operators.python import PythonOperator\n\ndef _print_var(val1, val2, val3, val4):\n    print(val1)\n    print(val2)\n    print(val3)\n    print(val4)\n\nwith DAG('my_dag', start_date=datetime(2024, 1, 1)) as dag:\n    print_var = PythonOperator(\n        task_id='print_var',\n        python_callable=_print_var,\n        op_args=[\n            '{ var.value.my_var }',\n            '{ var.json.my_vars.key1 }',\n            '{ var.json.my_vars.key2 }',\n            '{ var.json.my_vars.key3 }',\n        ],\n    )\n```\n\n그러나 템플릿 엔진 접근 방식은 템플릿 참조를 제공할 인수에 대해 오퍼레이터가 템플릿화된 필드를 지원하는 경우에만 적용됩니다.\n\n템플릿 참조가 작동하지 않는 경우에는 여전히 Variable.get()이 작업 내에서 호출되도록하여 매번 DAG가 구문 분석될 때 메타스토어 데이터베이스로의 연결이 초기화되지 않도록 할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nfrom datetime import datetime\n\nfrom airflow import DAG\nfrom airflow.models import Variable\nfrom airflow.operators.python import PythonOperator\n\ndef _print_var():\n    my_var = Variable.get('my_var')\n    print(my_var)\n\nwith DAG('my_dag', start_date=datetime(2024, 1, 1)) as dag:\n    print_var = PythonOperator(\n        task_id='print_var',\n        python_callable=_print_var,\n    )\n```\n\n# 단일 변수에 여러 값을 저장하기\n\n이제 특정 DAG가 세 가지 다른 값을 검색해야 한다고 가정해 봅시다. 이전 섹션에서 소개된 최선의 방법을 따르더라도 메타스토어 데이터베이스에 대해 세 개의 개별 연결을 시작해야 합니다.\n\n```python\nfrom datetime import datetime\n\nfrom airflow import DAG\nfrom airflow.models import Variable\nfrom airflow.operators.python import PythonOperator\n\ndef _print_vars():\n    my_var = Variable.get('my_var')\n    another_var = Variable.get('another_var')\n    one_more_var = Variable.get('one_more_var')\n    print(my_var)\n    print(another_var)\n    print(one_more_var)\n\nwith DAG('my_dag', start_date=datetime(2024, 1, 1)) as dag:\n    print_var = PythonOperator(\n        task_id='print_vars',\n        python_callable=_print_vars,\n    )\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n대신, 세 개의 키-값 쌍으로 구성된 단일 JSON 변수를 생성할 수 있습니다. 당연히 이 작업은 세 값을 한 변수로 압축하는 데 논리적으로 의미가 있는 한 수행해야 합니다.\n\n이제 메타스토어 데이터베이스로의 연결을 한 번만 수행하여 변수에서 지정된 모든 키의 값을 검색할 수 있습니다.\n\n```js\nfrom datetime import datetime\n\nfrom airflow import DAG\nfrom airflow.models import Variable\nfrom airflow.operators.python import PythonOperator\n\ndef _print_vars():\n    my_vars = Variable.get('my_vars', deserialize_json=True)\n    print(my_vars['key1'])\n    print(my_vars['key2'])\n    print(my_vars['key3'])\n\nwith DAG('my_dag', start_date=datetime(2024, 1, 1)) as dag:\n    print_var = PythonOperator(\n        task_id='print_vars',\n        python_callable=_print_vars,\n    )\n```\n\n# 최종 생각..\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n에어플로우 변수 선언은 간단하지만, 가장 좋은 방법을 적용하지 않으면 메타스토어 데이터베이스에서 가져오는 과정이 악몽이 될 수 있습니다.\n\n이 튜토리얼에서는 여섯 가지 다른 방법으로 에어플로우 변수를 생성하는 방법을 보여드렸습니다. 각 접근 방식에는 장단점이 있으며, 그에 맞춰 사용해야 합니다. 프로덕션 배포에서의 최상의 관례는 보안과 이식성을 제공하는 백엔드 시크릿을 사용하는 것입니다.\n\n더 중요한 건, 에어플로우 데이터베이스를 과부하시키지 않기 위해 피해야 할 기술들과 변수 구조 활용의 최적화 방법에 대해 논의했습니다. 이제 변수는 템플릿 참조를 통해 유추하거나 작업 함수 정의 내에서 정의되어야 한다는 점이 분명해졌기를 바랍니다.","ogImage":{"url":"/TIL/assets/img/2024-07-13-MasteringAirflowVariables_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-MasteringAirflowVariables_0.png","tag":["Tech"],"readingTime":17},{"title":"Matplotlib를 사용한 데이터 시각화 방법","description":"","date":"2024-07-13 20:32","slug":"2024-07-13-DataVisualizationwithMatplotlib","content":"\n\n![이미지](/TIL/assets/img/2024-07-13-DataVisualizationwithMatplotlib_0.png)\n\n데이터 시각화는 데이터 작업을 하는 사람들에게 매우 중요한 기술입니다. 이를 통해 복잡한 데이터 세트를 이해하고 결과를 효과적으로 전달할 수 있습니다. Python에서 데이터 시각화에 가장 인기 있는 라이브러리 중 하나인 Matplotlib을 살펴보겠습니다. 동물원 프로젝트와 관련된 코드 예제들은 이러한 개념을 더 잘 이해할 수 있도록 도와줍니다.\n\n# Matplotlib 개요\n\nMatplotlib은 Python 프로그래밍 언어를 위한 플로팅 라이브러리입니다. 일반 GUI 툴킷인 Tkinter, wxPython, Qt 또는 GTK를 사용하여 응용 프로그램에 플롯을 임베딩하기 위한 객체 지향 API를 제공합니다. Matplotlib은 또한 Python에서 정적, 애니메이션 및 대화형 시각화를 만드는 데 인기 있는 라이브러리입니다. 차트나 그래프를 만드는 것이 얼마나 쉬운지 알아보기 위해 몇 가지 코드 예제를 살펴봅시다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport matplotlib.pyplot as plt\nimport numpy as np\n# 간단한 그래프 예제\nx = np.linspace(0, 10, 100)\ny = np.sin(x)\nplt.plot(x, y)\nplt.show()\n```\n\n출력\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-DataVisualizationwithMatplotlib_1.png\" /\u003e\n\n이 간단한 예제는 Matplotlib을 사용하여 기본 선 그래프를 만드는 방법을 보여줍니다. 그러나 Matplotlib의 강점은 그 유연성과 복잡한 그래프를 만들 수 있는 능력에서 나옵니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 그림과 축\n\nMatplotlib에서 그림은 플롯을 구성하는 모든 요소를 포함하는 컨테이너로 생각할 수 있습니다. 축은 '플롯'으로 일반적으로 생각되는 요소로, 데이터 공간을 나타냅니다.\n\n그림\n\nMatplotlib에서 그림은 모든 것이 그려지는 전체 창 또는 페이지입니다. 이 그림에는 서브 축, 제목, 범례 및 레이블이 포함됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n```js\nfig = plt.figure()  # 아무 축이 없는 빈 그림\nfig, ax = plt.subplots()  # 하나의 축이 있는 그림\nfig, axs = plt.subplots(2, 2)  # 2x2 격자 형태의 축이 있는 그림\n```\n\n축\n\n이것은 우리가 '플롯'이라고 생각하는 것으로, 데이터 공간이 있는 이미지의 영역입니다. 하나의 그림에는 여러 축이 포함될 수 있지만, 특정 축 객체는 하나의 그림에만 있을 수 있습니다.\n\n```js\nfig = plt.figure()\nax1 = fig.add_subplot(211)  # 2행 1열로 구성된 그림에 서브플롯 추가 및 첫 번째 플롯 참조\nax2 = fig.add_subplot(212)  # 2행 1열로 구성된 그림에 서브플롯 추가 및 두 번째 플롯 참조\n``` \n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 동물원 프로젝트를 고려해보겠습니다. 다양한 동물과 그 특성에 관한 데이터가 있습니다. 우리는 Matplotlib을 사용하여 이 데이터를 시각화하고 싶습니다.\n\n```js\nimport pandas as pd\n# 동물원 프로젝트용 DataFrame 'df'가 있다고 가정\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\ndf = pd.DataFrame({\n    'animal': ['lion', 'tiger', 'bear', 'zebra', 'giraffe'],\n    'count': [5, 4, 6, 8, 2],\n    'average_weight': [190, 220, 300, 250, 800]\n})\nfig, ax = plt.subplots()\n# 동물 수에 대한 막대 그래프\nax.bar(df['animal'], df['count'], color='blue', alpha=0.7, label='Count')\n# 평균 무게에 대한 선 그래프, 보조 y-축 사용\nax2 = ax.twinx()\nax2.plot(df['animal'], df['average_weight'], color='red', label='Average Weight')\n# 라벨 및 제목\nax.set_xlabel('동물')\nax.set_ylabel('수')\nax2.set_ylabel('평균 무게 (kg)')\nplt.title('동물원 동물 통계')\n# 범례 표시\nfig.legend(loc=\"upper left\", bbox_to_anchor=(0,1), bbox_transform=ax.transAxes)\nplt.show()\n```\n\n출력\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-DataVisualizationwithMatplotlib_2.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 예제에서는 각 동물의 수를 나타내는 막대 플롯과 각 동물의 평균 체중을 나타내는 라인 플롯을 만들었습니다. 두 가지 다른 양을 나타내기 위해 두 개의 y-축을 사용했습니다.\n\n## 서브플롯 이해하기\n\n서브플롯(subplots)은 동일한 그림 안에 여러 플롯을 만드는 방법입니다. 이것은 그리드 시스템과 같이 생각해볼 수 있습니다. 각 셀에는 플롯이 들어갈 수 있는 격자가 있습니다. 같은 그림 내에서 다수의 플롯을 구조적으로 표시하고 싶을 때 매우 유용합니다. Matplotlib에서는 plt.subplots() 함수를 사용하여 서브플롯을 만듭니다. 전달한 두 인수는 우리의 그리드의 행과 열의 수입니다. 예를 들어, plt.subplots(2, 3)은 2개의 행과 3개의 열을 가진 그리드를 만들어 총 6개의 서브플롯을 얻게 됩니다.\n\n```js\nfig, axs = plt.subplots(2, 3)  # 2행 3열의 그리드를 생성합니다\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 axs는 우리가 조작할 수있는 축 (개별 플롯)를 보유하고있는 2D 배열입니다. 예를 들어, axs[0, 1]은 첫 번째 행과 두 번째 열의 서브플롯에 액세스할 수 있습니다.\n\n## 여러 축\n\n가끔은 서로 다른 스케일이나 단위를 가진 서로 다른 데이터 세트를 동일한 플롯에 그리고 싶을 수 있습니다. 그럴 때 다중 축이 유용합니다.\n\nMatplotlib에서는 twinx() 또는 twiny() 메서드를 사용하여 플롯에 두 번째 축을 추가할 수 있습니다. twinx()는 두 번째 y 축을, twiny()는 두 번째 x 축을 생성합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nfig, ax1 = plt.subplots()\n# 첫 번째 y축에 그리기\nax1.plot(x, y1, color='blue')\nax1.set_ylabel('Y1', color='blue')\n# 두 번째 y축 생성 및 그리기\nax2 = ax1.twinx()\nax2.plot(x, y2, color='red')\nax2.set_ylabel('Y2', color='red')\n```\n\n결과\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-DataVisualizationwithMatplotlib_3.png\" /\u003e\n\n이 예시에서는 y1과 y2가 동일한 그래프에 표시되지만 각자의 y축을 가지고 있어 서로 다른 척도로 측정할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 파이플롯 인터페이스\n\n맷플롯립의 파이플롯 인터페이스는 많은 사람들에게 플로팅의 세계로 들어가는 게이트웨이입니다. MATLAB의 플로팅 기능에서 영감을 받아 직관적이고 사용하기 쉽도록 설계되었습니다. 파이플롯을 사용하면 요소에 대한 정교한 제어가 중요하지 않은 빠르고 간단한 플로팅에 적합한 방식으로 도형과 축을 암시적으로 생성할 수 있습니다.\n\n```python\nimport matplotlib.pyplot as plt\n# 간단한 파이플롯 예시\nplt.figure()\nplt.plot([1, 2, 3, 4], [10, 20, 25, 30])\nplt.title('간단한 플롯')\nplt.show()\n```\n\n이 코드 조각은 최소한의 번거로움으로 기본 선 플롯을 생성합니다. 그러나 플로팅 요구 사항이 더 복잡해지면 파이플롯 인터페이스의 제약을 느낄 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 객체 지향 접근 방식\n\n객체 지향(OO) 접근 방식을 소개합니다. 이 방법론은 우리에게 자유를 주며, 플롯의 세부적인 사용자 정의가 가능합니다. Pyplot의 상태 지향에 의존하는 대신, figure 및 axes 객체와 직접 작업합니다. 이는 여러 개의 플롯을 다루거나 플롯 요소를 정확하게 제어해야 할 때 특히 유리합니다.\n\n```js\nimport matplotlib.pyplot as plt\n# 객체 지향 예시\nfig, ax = plt.subplots()\nax.plot([1, 2, 3, 4], [10, 20, 25, 30])\nax.set_title('OO 접근 방식 플롯')\nplt.show()\n```\n\n이 코드 조각에서 우리는 명시적으로 figure와 axes 객체를 생성하여 플롯의 모든 측면을 조정할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 왜 Pyplot보다 객체 지향을 선택해야 하는가?\n\nOO 접근 방식은 프로젝트가 더 높은 수준의 정교함을 요구할 때 빛을 발합니다. 예를 들어, 서로 다른 동물들의 식이 요구사항을 시각화해야 하는 동물원 프로젝트에서는 OO 접근 방식을 통해 하위그림을 생성하고 범례를 사용자 정의하며 주석을 쉽게 추가할 수 있습니다.\n\n또한 OO 접근 방식은 확장 가능합니다. 프로젝트가 성장함에 따라 시각화를 유지하고 업데이트하는 것이 더 관리하기 쉬워집니다. 우리는 플롯을 포함한 함수를 만들 수 있고, GUI 애플리케이션에 플롯을 삽입할 수 있으며 등등 많은 기능들을 추가할 수 있습니다.\n\n## Matplotlib의 API: 중추부분\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nMatplotlib의 API는 시각화를 만들기 위한 유연한 접근 방식을 제공하는 클래스의 집합입니다. 객체 지향적이기 때문에 플롯을 마치 작업실의 물리적 객체처럼 거의 그대로 조작할 수 있습니다. 우리는 조정하고 세밀하게 다듬을 수 있어서, 정보를 전달하는 데 그치지 않고 매력적인 시각화를 만들 수 있습니다.\n\nAPI는 방대하지만, 핵심은 Figure와 Axes 클래스입니다.\n\n가상의 동물원 프로젝트에서 Matplotlib의 API를 적용해 보겠습니다. 다양한 동물들의 일주일 동안의 급식 일정을 시각화해야 한다고 상상해 보세요. 이 작업은 다수의 데이터 시리즈를 처리하고 한눈에 통찰을 제공할 수 있는 세심한 접근이 필요합니다.\n\nMatplotlib의 API로 무대를 설정해 봅시다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리는 우선적으로 필요한 모듈을 가져와서 데이터를 설정합니다. 동물들의 목록과 일주일 동안의 식량 소비량을 나타내는 배열이 있을 것입니다.\n\n```js\nimport matplotlib.pyplot as plt\nimport numpy as np\nanimals = ['사자', '코끼리', '기린', '원숭이']\nconsumption = np.array([\n    [30, 35, 28, 40, 42, 37, 35],  # 사자\n    [50, 55, 52, 58, 56, 60, 59],  # 코끼리\n    [20, 22, 25, 23, 26, 24, 22],  # 기린\n    [10, 15, 12, 17, 16, 14, 13]   # 원숭이\n])\n```\n\n시각화 만들기\n\n데이터가 준비되었으면, subplots 함수를 사용하여 Figure 및 여러 Axes를 만듭니다. 각 Axes는 일주일의 하루를 나타내며, 각 동물의 식량 소비량을 플롯합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\nfig, axs = plt.subplots(1, 7, figsize=(20, 5), sharey=True)\ndays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']\ncolors = ['red', 'green', 'blue', 'orange']\nfor i, ax in enumerate(axs):\n    for j, animal in enumerate(animals):\n        ax.bar(animal, consumption[j][i], color=colors[j])\n    ax.set_title(days[i])\nfig.suptitle('Zoo Animal Feeding Schedule')\nplt.show()\n\n\n위 코드 블록에서는 매일의 동물별 소비량을 보여주는 막대 차트를 작성했습니다. 공유 y축을 통해 플롯 간 일관성을 유지하고 색상을 사용하여 동물을 구분합니다.\n\n마무리\n\n시각화를 눈에 띄게 만들기 위해 레이블, 범례, 그리고 디자인을 미세조정합니다. Matplotlib의 API를 사용하여 이 작업을 수행할 수 있습니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# y 축 레이블 추가\nfig.text(0.04, 0.5, '음식 소비량 (kg)', va='center', rotation='vertical')\n# 범례 추가\nfig.legend(animals, loc='upper right')\n# 가독성을 위한 레이아웃 조정\nplt.tight_layout(rect=[0.03, 0.03, 1, 0.95])\n# 최종 플롯 표시\nplt.show()\n```\n\n출력\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-DataVisualizationwithMatplotlib_4.png\" /\u003e\n\n더 많은 기사: Seaborn으로 데이터 시각화","ogImage":{"url":"/TIL/assets/img/2024-07-13-DataVisualizationwithMatplotlib_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-DataVisualizationwithMatplotlib_0.png","tag":["Tech"],"readingTime":11},{"title":"지구과학자를 위한 파이썬 시작 가이드 코드를 개선하는 5가지 방법","description":"","date":"2024-07-13 20:31","slug":"2024-07-13-GettingStartedWithPythonasaGeoscientistHereAre5WaysYouCanImproveYourCode","content":"\n\n![Getting Started With Python as a Geoscientist](/TIL/assets/img/2024-07-13-GettingStartedWithPythonasaGeoscientistHereAre5WaysYouCanImproveYourCode_0.png)\n\n여러 해 동안 지질 과학 및 암페트로물리컬 분야에서 다양한 Python 스크립트를 보고 작업해왔습니다. 그동안 다양한 코딩 스타일을 보았고(또는 작성한 적도 있습니다), 잘 구성된 코드에서 문서화가 잘 되어 있는 것부터 모든 내용이 하나의 Python 파일에 있고 거의 구조화되지 않은 것까지 다양합니다. 후자의 경우, 코드를 몇 달 후에 다시 살펴보면 유지, 디버그 및 이해가 어려울 수 있습니다. 적용된 스타일을 결정하는 요구 사항이 종종 코드 작성 목적을 결정합니다.\n\n한 번 또는 두 번 사용될 수 있는 스크립트를 생성하거나 엄격한 시간 제약과 압박 하에 작업할 때는 원하는 만큼 아름답고 조직적으로 작성할 수 없을 수도 있습니다. 그러나 여러 차례 사용하거나 다른 사용자에게 배포하는 코드를 작성하거나 시간이 허락된다면 나중에 확장할 수 있는 방식으로 코드나 앱을 구조화하고 싶을 것입니다. 이렇게 하면 코드를 다시 확인할 때 시간과 머리 아픈 일을 절약할 수 있을 뿐만 아니라 코드가 무엇을 하는지 혹은 무엇을 하려고 했는지 잊는 딜레마를 피할 수도 있습니다.\n\n지질 과학자로서 코딩이 자연스럽지 않을 수 있습니다. 그러나 동료나 친구들이 만들었거나 얘기하는 앱을 보고 시도해보기를 원하는 영향을 받았을 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 글에서는 몇 년 동안 배운 다섯 가지의 조언을 공유하려고 합니다. 이 조언들은 제 지구과학 Python 애플리케이션을 개선하는 데 도움이 되었고, 처음으로 Python과 머신러닝의 세계로 진입하는 사람들에게도 도움이 될 것입니다.\n\n이 조언은 지구과학자가 아닌 누구에게나 동일하게 적용될 수 있으며, Python을 처음 배우기 시작하는 사람들에게 유용할 것입니다.\n\n# 애플리케이션 폴더 구조 설정\n\nPython 앱을 처음 만들 때 코드를 하나의 폴더에 모두 보관하는 것이 편리하고 쉬울 수 있습니다. 그러나 프로젝트가 성장하고 복잡해지면 코드 베이스를 유지하고 탐색하기가 어려워질 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 작업을 손쉽게 정리하는 방법은 효과적인 폴더 구조를 만드는 것입니다. 프로젝트가 작은 경우라도 데이터 파일과 출력 또는 임시 파일을 각각의 폴더로 분리하는 것이 유용합니다.\n\n예를 들어, 다음 구조는 데이터 처리, 시각화 및 분석을 위한 특정 기능이 분리된 폴더 집합을 유지합니다. 이를 통해 특정 기능을 자체 파일 내에 저장할 수 있습니다. 이러한 기능들은 main.py 파일에서 필요할 때마다 호출할 수 있습니다.\n\n또한, 데이터 파일은 데이터 하위 디렉토리에 배치할 수 있습니다.\n\n\n# 간단한 프로젝트 구조 예시\nyour_project/\n├── data_processing/\n│   └── data_cleaner.py\n├── visualisation/\n│   └── plotter.py\n├── analysis/\n│   └── statistical_model.py\n├── data/\n│   └── raw_data.csv\n└── main.py\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 라이브러리나 플랫폼 전용 어플리케이션(예: Dash)을 개발 중이라면 Cookiecutter와 같은 프레임워크를 살펴볼 가치가 있습니다. 이를 사용하면 여러 미리 정의된 템플릿을 통해 프로젝트 구조를 매우 빠르게 설정할 수 있습니다.\n\n마지막으로, 여러 어플리케이션에서 코드를 재사용할 계획이라면 해당 기능 및 클래스를 저장할 파이썬 라이브러리를 작성하는 것도 고려해보세요.\n\n# 함수와 클래스를 사용하여 재사용 가능한 코드 만들기\n\nPython(또는 다른 어떤 프로그래밍 언어에서도) 작업할 때, 깔끔하고 효율적인 코드를 만드는 관행을 따르는 것은 좋은 습관입니다. 특히 어플리케이션이 점점 커지는 경우에는 더욱 중요합니다. 이를 통해 코드를 쉽게 재사용하고 유지보수하기 쉽게하며 가독성을 높이고 (그 외 여러 가지 이점도 포함하여) 향상시킬 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n함수와 클래스를 통해 코드를 구성하고 기능을 분리하여 반복되는 코드를 줄일 수 있습니다.\n\n## 모듈화된 코드를 위한 함수\n\n함수를 사용하면 호출될 때 실행할 수 있는 코드를 캡슐화할 수 있습니다. 함수에 매개변수를 전달할 수 있으며, 결과를 반환할 수 있습니다.\n\nPython에서 함수를 만들려면 def 키워드를 사용하고, 함수의 이름을 작성한 후, 마지막으로 사용할 매개변수/인수를 지정하면 됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예를 들어, 아래 함수는 대용량 밀도 층의 측정값을 바탕으로 밀도 퇴적률을 계산합니다. 이 함수는 세 개의 매개변수( rho_matrix, rho_bulk 및 rho_fluid )를 입력으로 받아 계산을 수행하고 퇴적률 값을 반환합니다.\n\n```js\ndef calculate_density_porosity(rho_matrix, rho_bulk, rho_fluid):\n\n    return (rho_matrix - rho_bulk) / (rho_matrix - rho_fluid)\n```\n\n## 복잡한 데이터 구조를 다루는 클래스\n\n애플리케이션이 커지거나 복잡한 데이터 구조를 처리해야 하는 경우에는 클래스를 고려할 만한 유용한 도구가 될 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파이썬에서 클래스는 객체(블루프린트와 유사한 것)를 생성하고 객체의 동작 방식을 정의하는 데 사용됩니다. 이는 상태(멤버 변수)의 초기 값과 동작(멤버 함수 또는 메소드의 구현)을 제공함으로써 이루어집니다.\n\n## 재사용 가능한 코드를 위한 최상의 관행\n\n여러분의 애플리케이션에서 재사용 가능한 코드를 만들 때 몇 가지 최상의 관행을 소개합니다.\n\n- 단일 책임 원칙: 각 함수 또는 클래스는 단일 책임 또는 목적을 가져야 합니다. 이렇게 하면 코드가 테스트와 유지보수가 더 쉬워집니다.\n- 명확한 명명: 함수나 클래스를 생성할 때 명확한 이름을 가져야 합니다. 이 이름은 그들이 무엇을 하는지 또는 무엇을 나타내는지 명확히 보여주어야 합니다. 명명 규칙에 대한 pep-8 가이드라인을 참고하세요.\n- 문서화: 함수와 클래스의 목적과 사용법을 문서화하기 위해 독스트링을 사용하고 최소한의 계산 또는 방법론 출처에 대한 참조를 포함하세요. 이것은 특히 지구과학 분야에서 함수가 복잡한 계산을 수행하는 데 사용될 때 특히 중요합니다. 문서화는 블록 주석, 인라인 주석 및 문서화 문자열을 포함할 수 있습니다. 자세한 내용은 pep- 지침을 확인하세요.\n- 모듈화된 디자인: 각 부분(함수 또는 클래스)이 개별적으로 테스트 및 사용될 수 있도록 코드를 설계해야 합니다. 이로 인해 한 두 줄짜리 함수가 나올 수도 있지만 이는 더 큰 코드 조각에 감춰진 코드를 가지는 것보다 낫습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 코드에 문서 추가하기\n\n![Python 개발자로 시작하는 방법: 지질학자로 시작하기](/TIL/assets/img/2024-07-13-GettingStartedWithPythonasaGeoscientistHereAre5WaysYouCanImproveYourCode_1.png)\n\n스크립트, 함수 또는 클래스를 작성할 때 문서화가 중요합니다. 코드 내에 주석과 문서화 문자열(docstrings)을 작성하면 몇 달 후에 애플리케이션을 다시 방문했을 때 머리 아픔을 예방하는 데 큰 도움이 될 수 있습니다. 또한, 다른 사람들이 코드를 살펴보는 경우에도 코드를 이해하는 데 도움이 될 수 있습니다.\n\n문서화를 통해 코드의 가독성을 개선하는 세 가지 간단한 방법이 있습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n주석은 코드 섹션 뒤에 있는 아이디어를 설명하거나 복잡한 논리를 분해하거나 코드에 대한 컨텍스트를 제공하는 데 사용됩니다. 주석을 추가하는 아이디어는 코드가 어떻게 작동하는지 설명하는 것이 아니라 코드와 논리 뒤에 있는 '왜'를 설명하는 것입니다.\n\n도움말 문자열은 함수나 클래스가 무엇을 하는지와 함수나 클래스가 요구하는 매개변수가 무엇인지 설명하는 데 사용됩니다. 이는 코드를 사용하는 사람에게 매우 유용합니다.\n\n타입 힌팅은 사용자가 코드를 더 잘 이해할 수 있게 합니다. 이는 주어진 함수나 클래스의 각 매개변수에 대한 데이터 유형이 무엇인지 사용자에게 알려줌으로써 그렇게 합니다.\n\n이전에 본 예제에서는 도움말 문자열을 추가하여 문서를 확장했습니다. 이로써 함수가 무엇을 하는지, 예상되는 각 매개변수가 무엇인지, 예상하는 데이터 유형이 무엇인지 설명합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ndef calculate_density_porosity(rho_matrix: float, rho_bulk: float, rho_fluid: float) -\u003e float:\n    \"\"\"\n    Calculates porosity based on bulk density measurements.\n\n    Parameters:\n      rho_matrix (float): The rock matrix density.\n      rho_bulk (float): The bulk density value.\n      rho_fluid (float): The fluid density.\n    \n    Returns:\n      float: The calculated density porosity.\n    \"\"\"\n    return (rho_matrix - rho_bulk) / (rho_matrix - rho_fluid)\n```\n\nPython 코드에서 문서화를 개선하는 방법에 대해 더 알아보려면 아래 동영상을 확인해보세요. 코드 문서화에 대해 더 자세히 다루었습니다:\n\n또는 다음 매체 기사를 확인할 수도 있습니다.\n\n# 버전 관리\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지구과학자로서 학업 과정에서 여러 버전의 에세이 및 논문을 저장하고 dissertation_version1.docx, dissertation_final.docx 또는 dissertation_final_final.docx와 같은 파일 이름을 만드는 데 익숙할 것으로 확신합니다. 이렇게 하면 매우 혼란스러워지고 나중에 파일을 다시 확인할 때 어떤 것이 진정 최종 버전인지 제대로 추적할 수 없게 됩니다.\n\nGit 또는 GitHub와 같은 온라인 시스템과 같은 시스템을 도입하면 미친 듯한 이름의 여러 파일을 만들지 않고도 다른 버전을 추적할 수 있습니다.\n\n또한 프로젝트 작업 중에 만든 변경 사항을 추적하고 싶을 수 있습니다. 이렇게 하면 이전에 작동했던 함수인데도 변경으로 인해 작동이 멈춘 경우 이전에 작동했던 코드로 롤백할 수 있는 가능성이 있습니다.\n\n버전 관리를 도입하면 다음과 같은 작업을 수행할 수 있습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 시간이 지남에 따라 변경 사항을 추적할 수 있습니다.\n- 다른 사람과 효과적으로 협력할 수 있습니다.\n- 기존 코드를 망가뜨리지 않고 실험할 수 있습니다.\n- 그리고 더 많은 기능들\n\n버전 관리의 개념을 이해하고 탐구하기 위한 좋은 안내서를 확인해보세요:\n\n# 작업하는 동안 테스트 생성하기\n\n코드나 애플리케이션을 개발할 때 함수를 수정하는 경우 특히 예상대로 작동하는지 확인해야 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n함수를 변경하거나 이에 의존하는 기타 함수들에 대한 어떠한 변경이든 안정성을 확인하는 한 가지 방법은 해당 코드 주변에 테스트를 작성하는 것입니다.\n\nPyTest나 unittest와 같은 여러 Python 테스팅 프레임워크를 사용하면 쉽게 사용할 수 있으며 연속적인 통합 워크플로의 일부로서 자동화할 수도 있습니다.\n\n예를 들어, 아래 코드는 unittest를 사용하고 이전에 본 포로시티 방정식을 감싸는 예시입니다.\n\n```python\nimport unittest\nfrom your_project.geoscience_calculations import calculate_density_porosity\n\nclass TestDensityPorosityCalculation(unittest.TestCase):\n    def test_calculate_density_porosity(self):\n        self.assertAlmostEqual(calculate_density_porosity(2.65, 2.0, 1.0), 0.39)\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 테스트는 calculate_density_porosity 함수가 rho_matrix, rho_bulk, rho_fluid에 대한 특정 값이 주어졌을 때 밀도 산소포도를 올바르게 계산하는지 확인합니다.\n\n그런 다음 assertAlmostEqual 메서드를 사용하여 예상 값이 반환된 값과 근사하게 일치하는지 확인합니다. 부동 소수점 숫자의 특성 때문에 정확한 동일성을 항상 보장할 수 없을 수 있기 때문입니다.\n\n테스팅에 대해 더 알아보려면 다음 기사를 확인해보세요:\n\n# Summary\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지구과학자로서, Python에 익숙하지 않을 수도 있고, 경력이나 학업 중에 가볍게 다뤄본 적이 있을 수도 있습니다. 하지만 애플리케이션을 개발하는 데 더 능숙해지고 싶어하는 경우에 이 다섯 가지 팁이 도움이 될 것입니다.\n\n파이썬 코딩을 배우는 초기 단계에 있을 때나 현재 기술과 지식을 확장할 때에는 코드가 적절히 문서화되어 있고, 주변에는 테스트가 작성되어 있으며, 조직화된 구조 내에 포함되어 있는지 확인하는 것이 중요합니다. 코드의 규모와 복잡성이 증가할 때, 이후에 발생할 수 있는 시간 손실과 머리 아픔을 줄일 수 있습니다. 버전 관리를 사용하여 모든 변경 사항을 추적하고 친구나 동료들과 쉽게 협업할 수 있도록 할 수 있습니다.\n\n읽어 주셔서 감사합니다. 이 글을 마치시기 전에 꼭 저의 콘텐츠를 구독하고 제 글을 이메일로 받아보세요. 이 곳에서 확인하실 수 있습니다! 또한, 이 콘텐츠를 즐기셨다면 감사의 표시로 몇 번 클랩을 눌러주시면 감사하겠습니다.","ogImage":{"url":"/TIL/assets/img/2024-07-13-GettingStartedWithPythonasaGeoscientistHereAre5WaysYouCanImproveYourCode_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-GettingStartedWithPythonasaGeoscientistHereAre5WaysYouCanImproveYourCode_0.png","tag":["Tech"],"readingTime":11},{"title":"Quantstats, TA, PyPortfolioOpt, FinanceToolkit을 이용한 미국 빅테크 주식 통합 퀀트 트레이딩 분석","description":"","date":"2024-07-13 20:25","slug":"2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit","content":"\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit_0.png\" /\u003e\n\n- 이 게시물에서는 기술적, 근본적 분석 도구 및 현대 포트폴리오 최적화(PO) 알고리즘을 통합하여 파이썬에서 미국 대형 기술 기업들의 양적 거래 분석에 초점을 맞추고 있습니다.\n\n## 미국의 대형 기술 기업이란?\n\n- 빅 포 (알파벳, 아마존, 애플, 메타)\n- 빅 파이브 (알파벳, 아마존, 애플, 메타, 마이크로소프트)\n- 멋진 일곱 (알파벳, 아마존, 애플, 메타, 마이크로소프트, 엔비디아, 테슬라)\n- 기타: 보고서에 따르면 AMD는 2023년 이후 브랜드 성장을 상당히 경험했으며, 전년대비 53% 증가했습니다. 또한 AMD의 브랜드 가치가 비즈니스 기술 및 서비스 플랫폼 부문에서 5186만 달러에 달했습니다. 그 강한 성장이 어디서 비롯된 것인지 쉽게 추측할 수 있습니다. AMD는 최근 몇 년 동안 경쟁사 인텔과 엔비디아가 해 온 것처럼 AI에 주력하고 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 비즈니스 케이스\n\n- 최근 몇 년간 미국 주식 시장은 빅테크가 주도한 놀라운 성장 기회를 제공해 왔습니다. 하지만, 상승장이 계속될 수 있을까요?\n- 빅테크 기업들은 역사상 가장 큰 반독점 입법 파동에 직면하고 있습니다.\n- 세계적인 세금 전쟁이 임박했습니다. 이는 빅테크에 큰 타격을 줄 수 있습니다.\n- 결론: 이러한 인상적인 성과에도 불구하고, 현재의 고 인플레이션과 이자율 경제환경에서 특히 높은 가치평가를 받는 기술 주식에 베팅하는 것에 대해 투자자들은 조심해야 합니다. Nvidia 칩과 Meta의 대형 언어 모델과 같은 AI 응용 프로그램은 약속을 보이지만, 이들의 시장가치는 실제 소비자 혜택과 실현된 생산성 향상에 궁극적으로 의존할 것입니다.\n\n## 프로젝트 목표\n\n- 우리의 궁극적인 목표는 기술적 분석 (TA) 지표, 주식 기초 내용 및 위험과 수익을 동시에 고려하는 포트폴리오 최적화를 통합하는 것입니다.\n- Markowitz (1952) [1]는 투자 포트폴리오의 다양성을 옹호하며, 이 과정이 투자의 분산을 줄인다는 것을 입증했습니다.\n- 이 다양성 개념들은 Modern Portfolio Theory (MPT)을 불러일으켰는데, 이는 위험과 수익이라는 두 가지 상충하는 목표 사이에서 선택하는 아이디어를 가져왔습니다.\n- TA 지표는 자산 가격과 거래량의 추세를 식별하기 위해 시장 참가자들에 의해 널리 사용됩니다. 최근 연구에 따르면 [2], 우리는 MPT와 TA 간의 격차를 줄이기 위해 TA 신호의 최적 가중치를 직접 다중 TA 신호의 함수로 매개변수화된 PO 전략을 개발했습니다.\n- 일부 거래자들은 FA 대신 TA를 선호하지만, 가장 성공적인 전략은 종종 두 가지를 조화롭게 적용한 것에서 나옵니다. 이는 거래자들이 즉각적인 가격 변동과 장기적인 경제 예측에서 모두 이익을 취할 수 있도록 하며 [3], 이 통합된 PO 접근 방식은 시장 역학을 이해하는 것을 강화할 뿐만 아니라 거래자들이 견고한 투자 결정을 내리기 위한 포괄적인 도구 상자를 제공합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 기술 분석 (TA)\n\n- TA는 시장을 분석하는 프레임워크를 트레이더에 제공하여 트렌드, 지지/저항 수준 및 진입/퇴출 지점을 식별하는 데 도움을 줍니다 [5].\n- TA의 두 가지 주요 가정은 다음과 같습니다 [5]: (1) 보안 가격은 기본적인 요소를 포함한 모든 중요한 정보를 반영한다; (2) 가격 변동은 상승, 하락 또는 측면 추세를 따른다.\n\n## 근본 분석 (FA)\n\n- TA는 단기적인 패턴만 식별하는 반면, FA는 주식 가격이 실제 가치를 저평가(또는 고평가)하는 자산을 강조할 것입니다 [5, 7].\n- 간단히 말해, 스마트한 투자 결정을 내리는 것이 FA의 주요 이점입니다. 이는 회사가 얼마나 벌고 지출하는지, 얼마나 많은 제품을 판매하는지 및 외부 요소에 어떻게 영향을 받는지를 이해하는 것을 포함합니다 [7].\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## TA vs FA\n\n- FA(기업 재무 분석)는 자산의 품질에 초점을 맞추고, TA(기술적 분석)는 시장 동향을 가치의 지표로 삼습니다. 두 방법 모두 주식 가격의 미래 동향을 예측하는 데 사용됩니다.\n\n## 포트폴리오 최적화\n\n- PO(포트폴리오 최적화)는 투자자가 자산을 선택하여 재무 위험을 최소화하고 ROI를 극대화하는 프로세스입니다.\n- 투자 수익률(ROI)은 모든 산업에서 익숙한 지표입니다.\n- 재정적으로 위험은 투자 수익이 기대와 다를 가능성을 의미합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 도구들:\n\n- Quantstats는 포트폴리오 분석을 위한 광범위한 기능을 제공합니다. 양적 분석가, 트레이더 및 포트폴리오 매니저를 대상으로 하며, 투자 전략에 대한 보다 깊은 통찰력을 얻고자 하는 사용자를 위해 설계되었습니다.\n- TA는 금융 시계열 데이터 세트에 대한 TA 라이브러리입니다. 금융 시계열 데이터 세트(오픈, 클로즈, 하이, 로우, 볼륨)에서 피쳐 엔지니어링을 수행하는 데 유용합니다. Pandas와 Numpy에 기반을 두고 있습니다.\n- PyPortfolioOpt는 전통적인 MPT 및 Black-Litterman 할당뿐만 아니라 Shrinkage, Hierarchical Risk Parity와 같은 분야의 최근 개발사항들을 구현하는 라이브러리입니다. 또한, 지수 가중 공분산 행렬과 같은 혁신적인 실험적 기능도 포함하고 있습니다.\n- FinanceToolkit은 가장 단순한 방식으로 150가지 이상의 재무 비율, 지표 및 성과 측정 항목이 포함된 오픈 소스 툴킷입니다. 이 툴킷은 주식에만 국한되지 않고, 옵션, 화폐, 암호화폐, ETF, 상장펀드, 지수, 머니 마켓, 상품, 주요 경제 지표 등에 대한 역사적 데이터 및 샤프 비율, VaR과 같은 중요한 성과 및 위험 측정 수단을 얻기 위해 사용할 수 있습니다.\n\n## 자료\n\n- 금융 시장을 위한 데이터 과학\n- FinanceToolkit 예제\n- 주식 시장 트렌드 및 Value at Risk\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 프로젝트 마일스톤\n\n- 빅 포 매칭 2020-2024 (BF)의 기초적인 리스크-수익 분석\n- 등가치 가중 BF 포트폴리오의 성과 분석\n- Sharpe Ratio 최대화를 위한 BF 최적화 (효율적 투자선) vs S\u0026P 500\n- (NVDA, AMD) vs 벤치마크 누적 수익률 및 VaR\n- (NVDA, AMD) 수익성 분석 및 그리스 감도\n- NVDA 및 AMD의 Fama-French 요인과의 상관 관계\n- (AAPL, AMZN, META, MSFT, GOOG) 재무 분석 및 주가 시뮬레이션\n- TA 이치모쿠 클라우드 차트: NVDA vs AMD\n- META 주식 TA, RSI vs EMA 전략 백테스팅\n\n위의 프로젝트 마일스톤에 대해 깊이 있게 탐구하는 포괄적인 안내서입니다. 해당 프로젝트는 가상 안콘다 환경을 생성한 후 주피터 노트북에서 구현되었습니다.\n\n## 기본 임포트 및 설치\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 필요한 Python 라이브러리 설치 및 불러오기\n\n```js\n!pip install quantstats, ta, pypfopt, plotly, yfinance, sklearn, seaborn, scipy\n```\n\n```js\n# 라이브러리 불러오기\n\n# 데이터 처리 및 통계 분석 \nimport pandas as pd\n#from pandas_datareader import data\nimport numpy as np\nfrom scipy import stats\n\n# 데이터 시각화 \nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\n\n# 최적화 및 자산 할당\nfrom pypfopt.efficient_frontier import EfficientFrontier\nfrom pypfopt import risk_models\nfrom pypfopt import expected_returns\nfrom pypfopt import black_litterman, BlackLittermanModel\n\n# 금융 데이터 \nimport quantstats as qs\nimport ta\nimport yfinance as yf\n\n# 선형 회귀 모델\nfrom sklearn.linear_model import LinearRegression\n\n# Plotly 오프라인 모드 활성화\nfrom plotly.offline import init_notebook_mode\ninit_notebook_mode(connected=True)\n\n\n# 포트폴리오 최적화를 위한 라이브러리 불러오기\nfrom pypfopt.efficient_frontier import EfficientFrontier\nfrom pypfopt import risk_models\nfrom pypfopt import expected_returns\n\n# 날짜 및 경고 숨기기 \nimport datetime as dt\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n```\n\n# 2020–2024 빅 포 팝 4 (BF) 기본 수익-변동성 분석\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 입력된 BF 주식 데이터 2020-2024년을 읽는 중\n\n```js\n#Big Four\ntickers = [\"AAPL\", \"GOOG\",\"AMZN\",\"META\"] \naapl = qs.utils.download_returns(tickers)\naapl = aapl.loc['2020-01-01':'2024-07-10']\n```\n\n- BF 주식의 일일 수익률 그래픽 표시\n\n```js\n# 각 주식의 일일 수익률 그래픽 표시\nprint('\\n')\nprint('\\n주식 일일 수익률 그래픽:\\n')\nqs.plots.daily_returns(aapl,benchmark='SPY')\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](/TIL/assets/img/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit_1.png)\n\n- 주식의 성과를 평가하는 가장 좋은 방법 중 하나는 일일 수익률을 계산하는 것입니다.\n- 위에 있는 플롯은 기본적으로 주식 가치가 하루 동안 얼마나 변화했는지 보여줍니다. 이 기본 정보를 사용하여 회사에 더 많이 투자하거나 다른 곳에 투자를 시도할지 결정할 수 있습니다.\n- BF 주식 누적 수익 그래플 작성\n\n```js\n# 각 주식에 대한 누적 수익 그래프 작성\nprint('\\n')\nprint('\\nStock Cumulative Returns Plot\\n')\nqs.plots.returns(aapl)\n```\n\n![image](/TIL/assets/img/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit_2.png)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 누적 수익 대비는 일정 기간 동안 투자 가격의 총 변화를 의미합니다.\n- 이것은 물가 상승 및 기타 외부 요인의 영향을 고려하지 않는 총 명목 수익입니다.\n- 양의 수익은 이익을 나타내고, 음의 수익은 손실을 나타냅니다.\n- 세금은 대부분의 투자에 대한 누적 수익을 상당히 줄일 수 있습니다.\n\n## BF의 첨도\n\n- BF 일일 수익의 첨도를 계산하고 그래프로 나타내기\n\n```js\n# 첨도를 측정하기 위해 quantstats 사용\nprint('\\n')\nprint(\"BF의 첨도: \", qs.stats.kurtosis(aapl).round(2))\n\nAAPL     5.03\nAMZN     4.00\nGOOG     3.63\nMETA    17.71\ndtype: float64\n\nqs.stats.kurtosis(aapl).round(2).plot.bar(label='첨도')\nplt.legend()\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/TIL/assets/img/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit_3.png)\n\n- 첨도(Kurtosis)는 분포의 꼬리 모양을 측정합니다.\n- 금융 분석에서 첨도는 투자의 가격 변동성 리스크를 측정하는 데 사용됩니다. 첨도는 투자의 가격이 정기적으로 경험하는 변동성을 측정합니다. 수익 분포의 높은 첨도는 투자가 가끔 극단적인 수익을 내줄 것을 시사합니다. 높은 첨도는 큰 양의 양수 수익 또는 극단적인 음수 수익을 나타낼 수 있다는 것을 염두에 두세요.\n- 우리는 BF의 일일 수익을 첨두관련 분포(첨도 ` 3.0)로 간주할 수 있습니다. 이 분포는 긴 꼬리(이상치)를 가진 곡선으로 나타납니다.\n- 추론: kur(META) `` kur(AAPL) ` kur(AMZN) ~ kur(GOOG)\n\n## BF의 왜도(Skewness)\n\n- BF의 일일 수익의 왜도(Skewness)를 계산하고 그래프에 표시하기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# Quantstats를 사용하여 왜도 측정\nprint('\\n')\nprint(\"주식 왜도: \", qs.stats.skew(aapl).round(2))\n\n주식 왜도:  Ticker\nAAPL    0.12\nAMZN    0.12\nGOOG   -0.06\nMETA   -0.29\ndtype: float64\n\nqs.stats.skew(aapl).round(2).plot.bar(label='Skewness')\nplt.legend()\n```\n\n![분산 도표](/TIL/assets/img/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit_4.png)\n\n- 왜도는 데이터가 대칭적 벨 곡선에서 벗어나는 방향과 정도를 나타냅니다.\n- 왜도가 0인 분포는 완전히 대칭적이며 분포의 왼쪽과 오른쪽이 거울 이미지인 것을 의미합니다. 양수 왜도는 오른쪽 꼬리가 왼쪽보다 길거나 더 두껍다는 것을 의미하며, 데이터가 높은 값을 가질 가능성이 높음을 시사합니다. 음수 왜도는 왼쪽 꼬리가 오른쪽보다 길거나 더 두꺼워 낮은 값을 가질 가능성을 시사합니다.\n- 일반적으로 -0.5 ~ 0.5 사이의 값은 약간의 왜도 수준을 나타냅니다.\n- 추론: skew(META)=-0.29\n- 실현 왜도와 미래 가격 간에 부정적인 교차 섹션이 관찰됩니다. — 음수 왜도를 가진 주식은 높은 변동성에 대해 미래 수익이 높게 보상됩니다.\n- GOOG의 부정적인 왜도는 투자자가 빈번한 소규모 이익과 소수의 큰 손실을 기대할 수 있다는 것을 의미합니다. 실제로, 많은 거래 전략이 부정적으로 왜도된 분포에 기초합니다.\n- AAPL 및 AMZN의 0에서 적정한 양수의 왜도와 결합되면, 이러한 분포는 안정적인 수익과 낮은 리스크를 시사할 것입니다.\n\n## BF의 표준 편차\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- BF 일별 수익률의 표준 편차(STD)를 계산하고 그래프로 플로팅합니다.\n\n```js\n# 표준 편차 계산하기\nprint('\\n')\nprint(\"주식 표준 편차: \", aapl.std().round(3))\n\n주식 표준 편차:  Ticker\nAAPL    0.021\nAMZN    0.023\nGOOG    0.021\nMETA    0.029\ndtype: float64\n\naapl.std().round(3).plot.bar(label='STD')\nplt.legend()\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit_5.png\" /\u003e\n\n- 표준 편차는 투자를 비교하는 기본적인 방법으로, 데이터의 변동이나 분산을 측정합니다. 더 높은 표준 편차는 더 높은 위험을 의미합니다.\n- 데이터 포인트가 평균에서 더 멀리 떨어져 있는 경우 데이터 세트 내에서 더 높은 편차가 있습니다. 표준 편차는 분산의 제곱근으로 계산됩니다.\n- 변동성이 큰 주식은 표준 편차가 높고, 안정적인 블루 칩 주가 주식의 편차는 보통 낮습니다.\n- 결론: std(AAPL, AMZN, GOOG) 약 0.02, std(META) 약 0.03입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## BF 상관 분석\n\n- 페어 플롯(pairplot)과 상관 행렬은 자산 간의 상관 관계를 시각화하는 데 유용한 도구입니다.\n- BF 일일 수익의 페어 플롯을 생성합니다.\n\n```js\n# 페어 플롯\nsns.pairplot(aapl, kind='reg')\nplt.show()\n```\n\n![이미지](/TIL/assets/img/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit_6.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 위의 플롯은 구글과 메타 주식 간의 흥미로운 선형 관계를 보여줍니다.\n- BF 일일 수익의 상관 행렬을 플로팅한 결과입니다.\n\n```js\n# 상관 행렬\ncorr = aapl.corr()\nmask = np.zeros_like(corr, dtype=bool)\nmask[np.triu_indices_from(mask)] = True\nsns.heatmap(corr, annot=True, mask=mask)\nplt.show()\n```\n\n![이미지](/TIL/assets/img/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit_7.png)\n\n- GOOG와 AAPL, AMZN, META의 3개 주식 간에는 0.64~0.66 정도의 강한 양의 상관 관계가 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## BF의 베타 계수\n\n- 주식의 베타 계수는 시장 기준으로 시간이 지남에 따른 변동성을 측정하는 지표입니다. 1의 베타는 주식의 변동성이 시장과 정확히 일치한다는 것을 의미합니다. 더 높은 베타는 큰 변동성을 나타내고, 낮은 베타는 덜한 변동성을 나타냅니다.\n- BF의 벤치마크 SPY에 대한 베타 계수를 계산하기 위해 선형 회귀 분석을 사용합니다.\n\n```js\nbench = [\"SPY\"] \nspy = qs.utils.download_returns(bench)\nspy = spy.loc['2020-01-01':'2024-07-10']\n\n# 인덱스 제거\nspy_no_index = spy.reset_index(drop = True)\naapl_no_index = aapl.reset_index(drop = True)\n\n# 애플의 수익률과 벤치마크 사이의 선형 관계 설정\n\n자산='AAPL'\nX = spy_no_index.values.reshape(-1,1)\ny = aapl_no_index[asset].values.reshape(-1,1)\n\nlinreg = LinearRegression().fit(X, y)\n\n베타 = linreg.coef_[0]\n알파 = linreg.intercept_\nprint('\\n')\nprint('AAPL 베타: ', beta.round(3))\nprint('\\nAAPL 알파: ', alpha.round(3))\n\n\n자산_베타 = []\n자산_베타.append(베타.round(3)[0])\n\nAAPL 베타:  [1.203]\n\nAAPL 알파:  [0.001]\n\n자산='AMZN'\nX = spy_no_index.values.reshape(-1,1)\ny = aapl_no_index[asset].values.reshape(-1,1)\n\nlinreg = LinearRegression().fit(X, y)\n\n베타 = linreg.coef_[0]\n알파 = linreg.intercept_\nprint('\\n')\nprint('AMZN 베타: ', beta.round(3))\nprint('\\nAMZN 알파: ', alpha.round(3))\n\n자산_베타.append(베타.round(3)[0])\n\nAMZN 베타:  [1.075]\n\nAMZN 알파:  [0.]\n\n자산='META'\nX = spy_no_index.values.reshape(-1,1)\ny = aapl_no_index[asset].values.reshape(-1,1)\n\nlinreg = LinearRegression().fit(X, y)\n\n베타 = linreg.coef_[0]\n알파 = linreg.intercept_\nprint('\\n')\nprint('META 베타: ', beta.round(3))\nprint('\\nMETA 알파: ', alpha.round(3))\n\n자산_베타.append(베타.round(3)[0])\n\nMETA 베타:  [1.324]\n\nMETA 알파:  [0.001]\n\n자산='GOOG'\nX = spy_no_index.values.reshape(-1,1)\ny = aapl_no_index[asset].values.reshape(-1,1)\n\nlinreg = LinearRegression().fit(X, y)\n\n베타 = linreg.coef_[0]\n알파 = linreg.intercept_\nprint('\\n')\nprint('GOOG 베타: ', beta.round(3))\nprint('\\nGOOG 알파: ', alpha.round(3))\n\n자산_베타.append(베타.round(3)[0])\n\nGOOG 베타:  [1.139]\n\nGOOG 알파:  [0.]\n\nprint(자산_베타)\n[1.203, 1.075, 1.324, 1.139]\r\n```\n\n- BF의 베타 계수를 플로팅하기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nfig, ax = plt.subplots(figsize=(6, 6))\n\nx = asset_beta\ntickers1=['AAPL', 'AMZN', 'META', 'GOOG']\n\nax.pie(x, labels=tickers1, autopct='%.1f%%',\n       wedgeprops={'linewidth': 3.0, 'edgecolor': 'white'},\n       textprops={'size': 'x-large'})\nax.set_title('Asset Beta', fontsize=18)\nplt.tight_layout()\n```\n\n![Pie Chart](/TIL/assets/img/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit_8.png)\n\n```python\n#import numpy as np\n#import matplotlib.pyplot as plt\n \ncourses = tickers\nvalues = x\n \nfig = plt.figure(figsize=(10, 5))\n\n# creating the bar plot\nplt.bar(courses, values, color='maroon', width=0.4)\n\nplt.xlabel(\"Assets\")\nplt.ylabel(\"Beta Value\")\nplt.title(\"Asset Beta Values\")\nplt.show()\n```\n\n![Bar Chart](/TIL/assets/img/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit_9.png)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 정의상 S\u0026P 500 지수와 같은 시장은 베타가 1.0이며, 개별 주식은 시장과 얼마나 벗어나는지에 따라 순위가 매겨집니다.\n- 추론: BF 주식은 베타가 1.0보다 높기 때문에 시간이 지남에 따라 시장보다 더 많이 흔듭니다.\n\n## BF의 샤프 비율\n\n- 샤프 비율은 투자의 위험 조정 수익률을 측정하는 지표입니다.\n- BF의 샤프 비율을 계산하고 시각화합니다.\n\n```js\n# 샤프 비율 계산\nprint('\\n')\nprint(\"주식의 샤프 비율: \", qs.stats.sharpe(aapl).round(2))\n주식의 샤프 비율: Ticker\nAAPL 0.93\nAMZN 0.65\nGOOG 0.87\nMETA 0.69\ndtype: float64\n\nqs.stats.sharpe(aapl).round(2).plot.bar(label='샤프 비율')\nplt.legend()\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/TIL/assets/img/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit_10.png)\n\n- Sharpe ratio가 높을수록 투자가 다른 Sharpe ratio가 낮은 투자에 비해 주어진 위험 수준에서 더 높은 수익을 제공함을 나타냅니다.\n- 결론: AAPL은 다른 3개 주식 (AMZN, GOOG, META)에 비해 주어진 위험 수준에서 더 높은 수익을 제공할 수 있습니다. AAPL의 Sharpe ratio가 거의 1에 가깝다는 것은 투자의 평균 수익이 리스크-프리 이자율과 거의 같다는 것을 의미합니다.\n\n# 등중 BF 포트폴리오의 성과 분석\n\n- 등중 BF 포트폴리오의 성과를 살펴봅시다.\n- 각 보안의 가중치 = 포트폴리오 내 보안 수로 1을 나눈 값\n- 4개 주식으로 이루어진 BF 포트폴리오에서 각 주식은 25%의 가중치를 가집니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nweights = [0.25, 0.25, 0.25, 0.25] # 각 주식의 가중치 정의\nap=aapl['AAPL']\nam=aapl['AMZN']\nme=aapl['META']\nms=aapl['GOOG']\nportfolio = ap*weights[0] + am*weights[1] + me*weights[2] + ms*weights[3] # 각 주식을 해당 가중치로 곱하여 포트폴리오 생성\nportfolio # 포트폴리오의 일일 수익률 표시\n\nDate\n2020-01-02    0.023684\n2020-01-03   -0.008015\n2020-01-06    0.016586\n2020-01-07   -0.000268\n2020-01-08    0.006574\n                ...   \n2024-07-02    0.012870\n2024-07-03   -0.000289\n2024-07-05    0.029234\n2024-07-08   -0.006084\n2024-07-09    0.001275\nLength: 1136, dtype: float64\n```\n\n- 포트폴리오의 일일 수익률, 히스토그램, 누적 수익률 플로팅\n\n```js\nportfolio.plot()\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit_11.png\" /\u003e\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nportfolio.hist()\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit_12.png\" /\u003e\n\n```js\nqs.plots.returns(portfolio)\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit_13.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Equal-Weighted BF 포트폴리오 성과 보고서 및 전략 시각화 vs SPY 기준 생성 중입니다!\n\n```js\nqs.reports.full(portfolio, benchmark = spy)\n```\n\n```js\n성과 지표\n                           기준          전략\n-------------------------  -----------  ----------\n시작 기간                 2020-01-02   2020-01-02\n종료 기간                 2024-07-09   2024-07-09\n무위험 이자율             0.0%         0.0%\n시장 참여 시간            100.0%       100.0%\n\n누적 수익률               72.69%       191.47%\nCAGR﹪                    8.7%         17.75%\n\n샤프 지수                 0.67         0.91\n확률적 샤프 비율          91.92%       97.3%\n스마트 샤프                0.6          0.82\n소르티노 지수              0.93         1.31\n스마트 소르티노             0.84         1.18\n소르티노/√2                0.66         0.93\n스마트 소르티노/√2         0.59         0.83\n오메가                     1.18         1.18\n\n최대 하락폭               -34.1%       -49.12%\n최장기 하락일             745          690\n변동성 (연간)             21.66%       31.42%\nR^2                      0.67         0.67\n정보 비율                 0.05         0.05\n칼마르 비율               0.26         0.36\n비대칭도                   -0.54        -0.14\n첨도                     11.14        4.01\n\n예상 일일 %              0.05%        0.09%\n예상 월별 %              1.0%         1.96%\n예상 연간 %              11.55%       23.86%\n켈리 기준                4.81%        5.39%\n파산 위험                 0.0%         0.0%\n일일 VaR                 -2.19%       -3.14%\n예상 손실 (cVaR)         -2.19%       -3.14%\n\n최대 연속 승리           10           8\n최대 연속 패배           7            6\n이익/통곽 비율          0.14         0.18\n이익/통곽 (1M)          0.7          1.12\n\n상환 비율                0.92         0.96\n이익 요소               1.14         1.18\n상식적 비율              1.08         1.14\nCPC 지수                0.57         0.61\n테일 비율               0.95         0.97\n이상치 승률             4.9          3.06\n이상치 손실률           4.78         3.19\n\nMTD                     2.13%        5.18%\n3M                      7.15%        16.73%\n6M                      17.11%       36.32%\nYTD                     16.94%       34.8%\n1Y                      26.74%       54.69%\n3Y (연간)              5.54%        9.97%\n5Y (연간)              8.7%         17.75%\n10Y (연간)             8.7%         17.75%\n전체 기간 (연간)       8.7%         17.75%\n\n최고 효과 일             9.06%        10.41%\n최악의 날               -10.94%      -10.9%\n최고 월                  12.7%        20.41%\n최악의 월               -13.0%       -15.13%\n최고 연도               27.04%       91.38%\n최악의 연도             -19.48%      -44.71%\n\n평균 하락                  -2.12%       -3.55%\n평균 하락 일             21           23\n회복 계수                1.91         2.63\n울서 지수                0.1          0.18\n평정 지수                0.44         0.42\n\n월별 상승 평균           4.73%        7.66%\n월별 하락 평균           -5.82%       -7.11%\n이익 일 %                 54.41%       53.7%\n이익 월 %                63.64%       65.45%\n이익 분기 %              73.68%       68.42%\n이익 연도 %              80.0%        80.0%\n\n베타                       -            1.19\n알파                      -            0.12\n상관관계               -            81.71%\nTreynor Ratio           -            161.56%\n없음\n\n\n최악 5 번 하락\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit_14.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 전략 시각화 대 SPY 벤치마크\n\n![이미지1](/TIL/assets/img/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit_15.png)\n\n![이미지2](/TIL/assets/img/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit_16.png)\n\n![이미지3](/TIL/assets/img/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit_17.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image 1](/TIL/assets/img/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit_18.png)\n\n![image 2](/TIL/assets/img/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit_19.png)\n\n![image 3](/TIL/assets/img/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit_20.png)\n\n- 결과:\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 전략 누적 수익률은 약 200%에 비해 벤치마크는 약 75%입니다.\n- 전략 누적 수익률(변동성 매칭)은 약 125%입니다.\n- 연말 전략 수익률은 약 30%에 비해 벤치마크는 약 15%입니다.\n- 월간 수익률 분포: 전략은 약 5%에 비해 벤치마크는 약 3%입니다.\n- 롤링 베타는 약 1.5입니다.\n- 롤링 변동성은 약 0.2에 비해 벤치마크는 약 0.1입니다.\n- 롤링 샤프 비율은 약 2.5입니다.\n- 롤링 소르티노 비율은 약 5.0입니다.\n- 최악의 손실액은 2021년 12월 28일에 -47%입니다.\n- 월간 최소 활동 수익률은 2022년 10월에 -15%입니다.\n- 전략 수익률 분위: 분기별으로 약 10% 및 연간으로 약 45%입니다.\n\n- 전략의 누적 수익률 및 샤프 비율이 벤치마크보다 높아, 같은 위험 수준에 더 나은 수익을 창출한다는 것을 보여줍니다.\n- 일반적으로 샤프 비율이 1.0보다 크면 투자자들에게 만족스럽거나 양호한 것으로 간주됩니다. 2.0보다 높은 비율은 매우 우수하다고 평가됩니다. 전략의 샤프 비율은 약 2.5입니다.\n- 소르티노 비율은 2 이상이면 이상적인 것으로 간주됩니다. 우리의 전략은 약 5.0의 소르티노 비율을 얻습니다.\n- 베타가 1보다 큰 경우: 베타가 1.0보다 크면 해당 자산의 가격이 이론적으로 시장보다 더 변동적임을 나타냅니다. 주식의 베타가 1.2면 시장보다 20% 더 변동적이라고 가정됩니다 (롤링 변동성 vs 벤치마크 비교). 테크놀로지 주식은 주요 벤치마크보다 더 높은 베타 값을 갖는 경향이 있습니다.\n- 전반적으로 제안된 Equal-Weighted BF Portfolio는 합리적인 투자 수익률을 창출했지만 SPY에 비해 더 높은 변동성을 동반합니다.\n\n# BF의 최대 샤프 비율을 위한 효율적 투자 가장자리\n\n- PyPortfolioOpt 라이브러리는 EfficientFrontier 클래스를 제공하며, 이 클래스는 공분산 행렬과 예상 수익을 입력으로 사용합니다. weights 변수는 최대 샤프 비율을 갖는 목표에 따라 각 자산에 대한 최적화된 가중치를 저장합니다.\n- 효율적인 투자 가장자리(Point of Origin)를 위한 라이브러리 가져오기 및 주식 데이터 읽기.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 포트폴리오 최적화를 위한 라이브러리 가져오기\nfrom pypfopt.efficient_frontier import EfficientFrontier\nfrom pypfopt import risk_models\nfrom pypfopt import expected_returns\n\ndf=yf.download(tickers, start = '2020-01-01')['Adj Close']\ndf.tail()\n\nTicker     AAPL       AMZN       GOOG       META\nDate    \n2024-07-02 220.270004 200.000000 186.610001 509.500000\n2024-07-03 221.550003 197.589996 187.389999 509.959991\n2024-07-05 226.339996 200.000000 191.960007 539.909973\n2024-07-08 227.820007 199.289993 190.479996 529.320007\n2024-07-09 228.679993 199.339996 190.440002 530.000000\n```\n\n- 연간화된 기대수익률 및 연간 샘플 공분산 행렬을 계산하고 플로팅합니다.\n\n```js\n# 연간화된 기대수익률 및 연간 샘플 공분산 행렬 계산\nmu = expected_returns.mean_historical_return(df) # 기대 수익률\nS = risk_models.sample_cov(df) # 공분산 행렬\n\n# 연간화된 기대수익률 시각화\nmu\n\nTicker\nAAPL    0.288713\nAMZN    0.179139\nGOOG    0.255711\nMETA    0.229041\ndtype: float64\n\nmu.plot.bar(label='연간화된 기대수익률')\nplt.legend()\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit_21.png\" /\u003e\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 공분산 행렬 시각화\n\n```js\n# 공분산 행렬 시각화\nS\n\n|        | AAPL    | AMZN    | GOOG    | META    |\n|--------|---------|---------|---------|---------|\n| AAPL   | 0.106707| 0.071803| 0.070835| 0.086041|\n| AMZN   | 0.071803| 0.132787| 0.078590| 0.103355|\n| GOOG   | 0.070835| 0.078590| 0.107778| 0.098501|\n| META   | 0.086041| 0.103355| 0.098501| 0.213837|\n\nS.style.background_gradient(cmap='coolwarm')\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit_22.png\" /\u003e\n\n- MSR에 대한 포트폴리오 최적화\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 최대 샤프 비율을 위한 최적화\nef = EfficientFrontier(mu, S) # 기대수익과 공분산 행렬을 입력으로 제공\nweights = ef.max_sharpe() # 샤프 비율 최적화를 위한 가중치 최적화\n\nclean_weights = ef.clean_weights() # clean_weights는 가중치를 반올림하고 거의 0에 가까운 값을 잘라냄\n\n# 최적화된 가중치와 포트폴리오의 예상 수익을 출력\nclean_weights\n\nOrderedDict([('AAPL', 0.66721),\n             ('AMZN', 0.0),\n             ('GOOG', 0.33279),\n             ('META', 0.0)])\n```\n\n- MSR 최적화 포트폴리오 생성\n\n```js\n# 최적화된 가중치를 사용하여 새로운 포트폴리오 생성\nnew_weights = [0.66721, 0.33279]\noptimized_portfolio = df['AAPL']*new_weights[0] + df['GOOG']*new_weights[1]\noptimized_portfolio # 일일 수익 시각화\n\nDate\n2020-01-02     71.406448\n2020-01-03     70.821647\n2020-01-06     71.763386\n2020-01-07     71.520408\n2020-01-08     72.480875\n                 ...    \n2024-07-02    209.068292\n2024-07-03    210.181895\n2024-07-05    214.898680\n2024-07-08    215.393625\n2024-07-09    215.954106\nLength: 1136, dtype: float64\n```\n\n- MSR 누적 수익 시각화 \n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\noptimized_portfolio.plot(label='최적화된 포트폴리오')\nplt.legend()\n```\n\n![이미지](/TIL/assets/img/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit_23.png)\n\n- MSR PO는 BF 대신 AAPL과 GOOG (총 2개 자산)만 고려하여 220%의 수익을 제공합니다. 이는 B2로 불리며 페어 트레이딩의 잠재적 후보입니다.\n- MSR B2 포트폴리오 성과 보고서 및 전략 시각화를 SPY 벤치마크 대비 생성\n\n```python\n# 첫 번째 포트폴리오와 최적화된 포트폴리오를 비교하는 새로운 보고서 표시\nqs.reports.full(optimized_portfolio, benchmark=portfolio)\n\n성과 지표\n                           벤치마크    전략\n-------------------------  -----------  ----------\n시작 기간               2020-01-03   2020-01-03\n종료 기간                 2024-07-09   2024-07-09\n무위험 이자율             0.0%         0.0%\n시장 참여 시간           100.0%       100.0%\n\n누적 수익            184.73%      202.43%\nCAGR﹪           17.34%       18.43%\n\n샤프                     0.9          0.96\n확률적인 샤프 비율         97.08%       97.9%\n스마트 샤프               0.79         0.84\n소르티노                    1.29         1.4\n스마트 소르티노              1.13         1.23\n소르티노/√2                 0.91         0.99\n스마트 소르티노/√2           0.8          0.87\n오메가                      1.19         1.19\n\n최대 손실                 -49.12%      -33.58%\n최장 연속 손실 일수            690          542\n변동성 (연간)          31.42%       30.32%\nR^2                        0.8          0.8\n정보 비율                  0.0          0.0\n칼마르                     0.35         0.55\n외도                       -0.14        -0.07\n첨도                      4.02         4.66\n\n기대되는 일일 %           0.09%        0.1%\n기대되는 월간 %         1.92%        2.03%\n기대되는 연간 %          23.28%       24.77%\n켈리 기준                   5.11%        8.13%\n파산 위험                0.0%         0.0%\n일일 가치위험            -3.14%       -3.03%\n기대되는 실패(조건부 VaR)   -3.14%       -3.03%\n\n연속 최대 성공 수          8            11\n연속 최대 손실 수          6            6\n이익/손실 비율           0.17         0.19\n이익/손실 (1M)            1.1          1.14\n\n상환 비율                 0.95         0.98\n이익 요소               1.17         1.19\n상식적인 비율           1.14         1.16\nCPC 지수                0.6          0.63\n꼬리 비율                0.97         0.98\n이상치 이기는 비율        3.8          3.97\n이상치 손실 비율         3.55         3.62\n\n월말 이익                  5.18%        7.14%\n3개월간                   16.73%       31.57%\n6개월간                   36.32%       26.89%\nYTD                      34.8%        23.43%\n1년                    54.69%       29.71%\n3년 (연간)             9.97%        10.51%\n5년 (연간)             17.34%       18.43%\n10년 (연간)            17.34%       18.43%\n최고치 (연간)           17.34%       18.43%\n\n최고 수익 날짜         10.41%       11.17%\n최악의 날              -10.9%       -12.32%\n최고의 월              20.41%       18.65%\n최악의 월             -15.13%      -12.31%\n최고의 연도           91.38%       62.29%\n최악의 연도          -44.71%      -29.98%\n\n평균 하락                 -3.59%       -4.0%\n평균 하락 일수            23           26\n회복 요인                  2.58         3.91\n울서 지수                  0.18         0.12\n평온 지수                   0.42         0.94\n\n평균 상승 월              7.75%        8.26%\n평균 하락 월           -6.91%       -6.96%\n이익 일 %                 53.66%       54.54%\n이익 월 %                65.45%       58.18%\n이익 분기 %             68.42%       57.89%\n이익 연도 %              80.0%        80.0%\n\n베타                       -            0.86\n알파                      -            0.05\n상관 관계                -            89.32%\n트레이너 비율              -            234.87%\n없음\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 최악의 5번의 Drawdown\n\n![Worst Drawdowns](/TIL/assets/img/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit_24.png)\n\n- MSR PO 전략 시각화\n\n![MSR PO Strategy Visualization](/TIL/assets/img/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit_25.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![Image 1](/TIL/assets/img/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit_26.png)\n\n![Image 2](/TIL/assets/img/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit_27.png)\n\n![Image 3](/TIL/assets/img/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit_28.png)\n\n![Image 4](/TIL/assets/img/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit_29.png)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 결론:\n\n- 전략 누적 수익률 약 220%.\n- 전략 누적 수익률 (변동성 일치) 약 210%.\n- 월별 수익 분포: 전략 약 7% 대 벤치마크 약 3%.\n- 롤링 베타 약 0.6\n- 롤링 변동성 약 0.2\n- 롤링 샤프 비율 약 2.5\n- 롤링 소티노 비율 약 5.0\n- 최대 손실 약 -31% (2021년 01월 04일)\n- 최소 월간 순활 수익 약 -10% (2022년 10월)\n- 전략 수익 분위 수: 분기별로 약 10%, 연간으로 약 50%.\n\n- 전략의 누적 수익률과 샤프 비율이 벤치마크보다 높음을 보여줍니다. 이는 더 많은 수익을 가져오지만, 같은 수준의 위험을 감수하고 있음을 의미합니다.\n- 베타 값이 1보다 낮다는 것은 MSR B2가 전체 시장보다 덜 변동성이 있다는 것을 의미합니다.\n- 전반적으로 최적화된 MSR B2 포트폴리오는 위험-수익 교환 관계 측면에서 50% BF-to-B2 포트폴리오 비용 절감까지 고려하여 평등가중 BF 포트폴리오보다 우수한 성과를 거뒀습니다.\n\n# (NVDA, AMD) 대 S\u0026P 500 수익성 분석\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- FinanceToolkit [9]를 사용하여 (NVDA, AMD) 대 S\u0026P 500 수익 분석의 세부 정보를 살펴보겠습니다.\n- 입력한 과거 데이터, 손익 계산서, 수익성 비율, FA 및 TA 지표 가져오기 [9]\n\n```js\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as mtick\nimport pandas as pd\nimport seaborn as sns\nfrom matplotlib import patheffects\n\nfrom financetoolkit import Toolkit\n\nAPI_KEY = \"YOUR API KEY\"\n\ncompanies = Toolkit([\"NVDA\", \"AMD\"], api_key=API_KEY, start_date=\"2017-12-31\")\n\n# 손익 계산서\nhistorical_data = companies.get_historical_data()\n\n# 재무 제표 예시\nincome_statement = companies.get_income_statement()\n\n# 수익성 비율\nprofitability_ratios = companies.ratios.collect_profitability_ratios()\n\n# 그리스 금융 지표\nall_greeks = companies.options.collect_all_greeks(expiration_time_range=180)\n\n\n# 요소 자산 상관 관계\nfactor_asset_correlations = companies.performance.get_factor_asset_correlations(\n    period=\"quarterly\"\n)\n\n# VaR\nvalue_at_risk = companies.risk.get_value_at_risk(period=\"weekly\")\n\n# TA 지표\nichimoku_cloud = companies.technicals.get_ichimoku_cloud()\n```\n\n## 누적 수익률\n\n- NVDA, AMD 및 S\u0026P 500의 누적 수익률을 시각화합니다. [9]\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ndisplay(역사적_데이터)\n\n# 클립 보드에 복사 (이건 README에 데이터를 붙여 넣기 위함입니다)\npd.io.clipboards.to_clipboard(\n    역사적_데이터.xs(\"NVDA\", axis=1, level=1).iloc[:-1].head().to_markdown(),\n    excel=False,\n)\n\n# 누적 수익을 위한 라인 차트 생성\nax = 역사적_데이터[\"누적 수익\"].plot(\n    figsize=(15, 5),\n    lw=2,\n)\n\n# 색상 및 라인 스타일 사용자 정의\nax.set_prop_cycle(color=[\"#007ACC\", \"#FF6F61\", \"#4CAF50\"])\nax.set_xlabel(\"년도\")\nax.set_ylabel(\"누적 수익\")\nax.set_title(\n    \"NVDA 및 AMD의 누적 수익과 S\u0026P 500을 벤치마크로 함께한 수익\"\n)\n\n# 범례 추가\nax.legend([\"NVDA\", \"AMD\", \"S\u0026P 500\"], loc=\"upper left\")\n\n# 가시성을 위해 그리드 라인 추가\nax.grid(True, linestyle=\"--\", alpha=0.7)\n\nplt.show()\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit_30.png\" /\u003e\n\n## 변동성\n\n- NVDA 및 AMD 대 S\u0026P 500의 변동성 그래픽화\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nprint(historical_data['Volatility'].iloc[-1])\nNVDA        0.0324\nAMD         0.0345\nBenchmark   0.0125\nName: 2024-07-09, dtype: float64\n\nhistorical_data['Volatility'].iloc[-1].plot.bar(title='Volatility')\n```\n\n![Image](/TIL/assets/img/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit_31.png)\n\n- 저희 두 자산의 변동성이 벤치마크의 3배 정도 더 높다는 것을 알 수 있습니다.\n\n## 손익계산서\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 2019년부터 2024년까지의 NVDA 및 AMD 손익 계산서를 비교해보세요 [9]\n\n```js\nincome_statement를 출력하세요\n\n# 클립보드에 복사하세요 (README에 데이터를 붙여넣기 위한 용도입니다)\npd.io.clipboards.to_clipboard(\n    income_statement.loc[\"NVDA\"].head().to_markdown(), excel=False\n)\n\n# 막대 그래프 생성\nebitda_data = income_statement.loc[:, \"EBITDA\", :].T\ncolors = [\"#007ACC\", \"#FF6F61\"]\nax = ebitda_data.plot.bar(figsize=(15, 5), color=colors)\n\n# 막대 위에 데이터 라벨 추가 (백만으로 나누어 사용자 정의 포맷팅 (백만과 천 단위 구분))\nfor p in ax.patches:\n    ebitda_millions = p.get_height() / 1_000_000_000\n    label = f\"{ebitda_millions:,.2f} M\"\n    x = p.get_x() + p.get_width() / 2.0\n    y = p.get_height()\n\n    # 라벨이 차트 상단과 너무 가까운지 확인\n    if y \u003c 0.2 * ax.get_ylim()[1]:\n        va = \"bottom\"\n        xytext = (0, 5)\n    else:\n        va = \"top\"\n        xytext = (0, -5)\n\n    # 텍스트에 대한 스트로크 효과 생성\n    text = ax.annotate(\n        label,\n        (x, y),\n        ha=\"center\",\n        va=va,\n        fontsize=10,\n        color=\"black\",\n        xytext=xytext,\n        textcoords=\"offset points\",\n    )\n    text.set_path_effects([patheffects.withStroke(linewidth=3, foreground=\"white\")])\n\n# 축 라벨 사용자 정의\nplt.xlabel(\"\", fontsize=10)\nplt.ylabel(\"\", fontsize=10)\n\n# x tick의 각도 조정\nplt.xticks(rotation=0)\n\n# 제목 설정\nplt.title(\n    \"Earnings Before Interest, Taxes, Depreciation and Amortization (EBITDA) of NVDA \u0026 AMD\",\n    fontsize=12,\n)\n\n# 명확성을 위해 수평 grid 추가\nplt.grid(axis=\"y\", linestyle=\"--\", alpha=0.7)\n\n# y축에 천 단위 구분 추가\nax.yaxis.set_major_formatter(\n    mtick.FuncFormatter(lambda x, _: f\"{x / 1_000_000_000:,.0f} M\")\n)\n\n# 그래프 출력\nplt.show()\n```\n\n![차트1](/TIL/assets/img/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit_32.png)\n\n![차트2](/TIL/assets/img/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit_33.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![Profitability Ratios](/TIL/assets/img/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit_34.png)\n\n## 수익성 비율\n\n- NVDA 및 AMD 수익성 비율 2019–2024 시각화 [9]\n\n```js\ndisplay(profitability_ratios)\n\n# 클립 보드로 복사 (이것은 README에 데이터를 붙여넣기하기 위한 것입니다)\npd.io.clipboards.to_clipboard(\n    profitability_ratios.loc[\"NVDA\"].head().to_markdown(), excel=False\n)\n\nratios_to_plot = [\n    \"Return on Assets\",\n    \"Return on Equity\",\n    \"Return on Invested Capital\",\n    \"Return on Tangible Assets\",\n]\n\n# 그림 생성\nax = (\n    (profitability_ratios.dropna(axis=1) * 100)\n    .loc[\"NVDA\", ratios_to_plot, :]\n    .T.plot(figsize=(15, 5), title=\"NVDA의 수익성 비율\", lw=2)\n)\n\n# 라인 스타일과 색상 커스터마이징\nline_styles = [\"-\", \"--\", \"-.\", \":\"]\nline_colors = [\"blue\", \"red\", \"green\", \"purple\"]\nfor i, line in enumerate(ax.get_lines()):\n    line.set_linestyle(line_styles[i])\n    line.set_color(line_colors[i])\n\n# 범례 커스터마이징\nax.legend(ratios_to_plot)\n\n# 라벨 및 그리드 추가\nplt.xlabel(\"Year\", fontsize=12)\nplt.ylabel(\"Percentage (%)\", fontsize=12)\nplt.grid(True, linestyle=\"--\", alpha=0.7)\n\n# 제목 커스터마이징\nplt.title(\"NVDA의 수익성 비율\")\n\n# 그림 표시\nplt.show()\n```\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n-md\n\n![image](/TIL/assets/img/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit_35.png)\n\n![image](/TIL/assets/img/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit_36.png)\n\n- AMD 수익성 비율 그래픽 그리기\n\n```js\n# 클립 보드로 복사 (README에 데이터를 붙여넣을 때 사용)\npd.io.clipboards.to_clipboard(\n    profitability_ratios.loc[\"AMD\"].head().to_markdown(), excel=False\n)\n\nratios_to_plot = [\n    \"Return on Assets\",\n    \"Return on Equity\",\n    \"Return on Invested Capital\",\n    \"Return on Tangible Assets\",\n]\n\n# 그림 생성\nax = (\n    (profitability_ratios.dropna(axis=1) * 100)\n    .loc[\"AMD\", ratios_to_plot, :]\n    .T.plot(figsize=(15, 5), title=\"AMD의 수익성 비율\", lw=2)\n)\n\n# 라인 스타일과 색상 사용자 정의\nline_styles = [\"-\", \"--\", \"-.\", \":\"]\nline_colors = [\"blue\", \"red\", \"green\", \"purple\"]\nfor i, line in enumerate(ax.get_lines()):\n    line.set_linestyle(line_styles[i])\n    line.set_color(line_colors[i])\n\n# 범례 사용자 정의\nax.legend(ratios_to_plot)\n\n# 레이블과 그리드 추가\nplt.xlabel(\"년도\", fontsize=12)\nplt.ylabel(\"백분율 (%)\", fontsize=12)\nplt.grid(True, linestyle=\"--\", alpha=0.7)\n\n# 제목 사용자 정의\nplt.title(\"AMD의 수익성 비율\")\n\n# 그림 표시\nplt.show()\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![Image](/TIL/assets/img/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit_37.png)\n\n- 2023년 NVDA 대 AMD 수익성 비율 검토\n\n```js\nprint(profitability_ratios['2023'])\n\nAMD   매출 이익율                                     0.4612\n      영업 이익율                                   0.0177\n      순이익율                                      0.0377\n      이자 상환 여유성 비율                           37.283\n      세전 순이익 마진                              0.0217\n      유효 세율                                   -0.7033\n      자산 수익률                                   0.0126\n      자본 수익률                                   0.0154\n      투자 자본 이익률                             0.0146\n      자본 운용 이익률                               0.01\n      유형 자산 수익률                             0.0083\n      소득 품질 비율                               1.952\n      EBT당 순이익                                1.6811\n      영업현금흐름 대 영업 현금흐름 비율           0.6725\n      EBT 대 EBIT 비율                           0.8274\n      EBIT 대 매출                               0.0271\nNVDA  매출 이익율                                    0.5693\n      영업 이익율                                   0.1566\n      순이익율                                      0.1619\n      이자 상환 여유성 비율                        22.0153\n      세전 순이익 마진                             0.155\n      유효 세율                                  -0.0447\n      자산 수익률                                   0.1023\n      자본 수익률                                   0.1793\n      투자 자본 이익률                            0.1319\n      자본 운용 이익률                            0.1283\n      유형 자산 수익률                            0.0693\n      소득 품질 비율                              1.2914\n      EBT당 순이익                               1.0447\n      영업현금흐름 대 영업 현금흐름 비율           0.6751\n      EBT 대 EBIT 비율                           0.941\n      EBIT 대 매출                               0.1647\nName: 2023, dtype: float64\n\nplt.figure(figsize=(14, 8))\nprof=profitability_ratios['2023']\ncols = ['NVDA', 'AMD']\nprof[cols].plot(kind='bar')\n```\n\n![Image](/TIL/assets/img/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit_38.png)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 2023년 NVDA 대 AMD 수익성 비율 확대\n\n```js\nplt.figure(figsize=(14, 8))\nprof = profitability_ratios['2023']\ncols = ['NVDA', 'AMD']\nprof[cols].plot(kind='bar')\nplt.ylim(-1, 2.5)\n```\n\n![Profitability Ratios](/TIL/assets/img/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit_39.png)\n\n## AMD 대 NVDA 그리스 민감도\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- AMD에 대한 그리스 감수치 분석 중 [9]\n\n```js\nimport matplotlib.pyplot as plt\nfrom matplotlib import cm\n\nfig, ax = plt.subplots(figsize=(15, 10), ncols=2, nrows=2)\n\ndelta_over_time_df = pd.DataFrame()\ndates = all_greeks.columns.get_level_values(0)\n\n# 1, 2개월 ... 처리\nfor i, time in enumerate(range(30, 210, 30)):\n\n    try:\n        period_column = dates[time]\n    except IndexError:\n        period_column = dates[-1]\n\n    color = cm.viridis(i / 5)  # 색상 변화에 viridis colormap 사용\n\n    # Delta plot\n    ax[0, 0].plot(all_greeks.loc[\"AMD\", (period_column, \"Delta\")], color=color)\n\n    # Gamma plot\n    ax[0, 1].plot(all_greeks.loc[\"AMD\", (period_column, \"Gamma\")], color=color)\n\n    # Theta plot\n    ax[1, 0].plot(all_greeks.loc[\"AMD\", (period_column, \"Theta\")], color=color)\n\n    # Vega plot\n    ax[1, 1].plot(all_greeks.loc[\"AMD\", (period_column, \"Vega\")], color=color)\n\n    delta_over_time_df = pd.concat(\n        [delta_over_time_df, all_greeks.loc[\"AMD\", (period_column, \"Delta\")]], axis=1\n    )\n\ndate_labels = [\n    \"1 달\",\n    \"2 달\",\n    \"3 달\",\n    \"4 달\",\n    \"5 달\",\n    \"6 달\",\n]\n\ndelta_over_time_df.columns = date_labels\n\n# DataFrame 표시\ndisplay(delta_over_time_df.iloc[7:12])\n\n# 클립보드로 복사 (README에 데이터를 붙여넣으려면)\npd.io.clipboards.to_clipboard(delta_over_time_df.iloc[7:12].to_markdown(), excel=False)\n\n# 타이틀 및 레이블\nfor number1, number2 in [(0, 0), (1, 0), (0, 1), (1, 1)]:\n    ax[number1, number2].set_xlim(\n        [all_greeks.loc[\"AMD\"].index.min(), all_greeks.loc[\"AMD\"].index.max()]\n    )\n    ax[number1, number2].grid(True, linestyle=\"--\", alpha=0.7)\n    ax[number1, number2].set_xlabel(\"행사가\")\n    ax[number1, number2].set_facecolor(\"#F5F5F5\")\n\nax[0, 0].set_title(\"Delta\")\nax[0, 1].set_title(\"Gamma\")\nax[1, 0].set_title(\"Theta\")\nax[1, 1].set_title(\"Vega\")\n\n# 레이아웃 조정\nfig.legend(\n    date_labels,\n    loc=\"upper center\",\n    ncol=6,\n    bbox_to_anchor=(0.5, 0),\n    frameon=False,\n)\nfig.suptitle(\n    \"AMD에 대한 그리스 감수치 분석\", fontsize=30, x=0.5, y=0.98, fontfamily=\"cursive\"\n)\n\nfig.tight_layout()\n\n# 플롯 표시\nplt.show()\n\n    1 달 2 달 3 달 4 달 5 달 6 달\n165 0.872 0.8067 0.7692 0.7398 0.7236 0.7113\n170 0.7487 0.698 0.6728 0.6544 0.6449 0.638\n175 0.5863 0.5721 0.5664 0.5631 0.562 0.5615\n180 0.4124 0.442 0.458 0.471 0.4786 0.4848\n185 0.2582 0.3212 0.3555 0.3828 0.3985 0.4108\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit_40.png\" /\u003e\n\n- NVDA에 대한 그리스 감수치 분석 중 [9]\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n```js\nimport matplotlib.pyplot as plt\nfrom matplotlib import cm\n\nfig, ax = plt.subplots(figsize=(15, 10), ncols=2, nrows=2)\n\ndelta_over_time_df = pd.DataFrame()\ndates = all_greeks.columns.get_level_values(0)\n\n# Loop through different times\nfor i, time in enumerate(range(30, 210, 30)):\n\n    try:\n        period_column = dates[time]\n    except IndexError:\n        period_column = dates[-1]\n\n    color = cm.viridis(i / 5)  # Using viridis colormap for color variation\n\n    # Delta plot\n    ax[0, 0].plot(all_greeks.loc[\"NVDA\", (period_column, \"Delta\")], color=color)\n\n    # Gamma plot\n    ax[0, 1].plot(all_greeks.loc[\"NVDA\", (period_column, \"Gamma\")], color=color)\n\n    # Theta plot\n    ax[1, 0].plot(all_greeks.loc[\"NVDA\", (period_column, \"Theta\")], color=color)\n\n    # Vega plot\n    ax[1, 1].plot(all_greeks.loc[\"NVDA\", (period_column, \"Vega\")], color=color)\n\n    delta_over_time_df = pd.concat(\n        [delta_over_time_df, all_greeks.loc[\"NVDA\", (period_column, \"Delta\")]], axis=1\n    )\n\ndate_labels = [\n    \"1 Month\",\n    \"2 Months\",\n    \"3 Months\",\n    \"4 Months\",\n    \"5 Months\",\n    \"6 Months\",\n]\n\ndelta_over_time_df.columns = date_labels\n\n# Show the DataFrame\ndisplay(delta_over_time_df.iloc[7:12])\n\n# Copy to clipboard (this is just to paste the data in the README)\npd.io.clipboards.to_clipboard(delta_over_time_df.iloc[7:12].to_markdown(), excel=False)\n\n# Titles and labels\nfor number1, number2 in [(0, 0), (1, 0), (0, 1), (1, 1)]:\n    ax[number1, number2].set_xlim(\n        [all_greeks.loc[\"NVDA\"].index.min(), all_greeks.loc[\"NVDA\"].index.max()]\n    )\n    ax[number1, number2].grid(True, linestyle=\"--\", alpha=0.7)\n    ax[number1, number2].set_xlabel(\"Strike Price\")\n    ax[number1, number2].set_facecolor(\"#F5F5F5\")\n\nax[0, 0].set_title(\"Delta\")\nax[0, 1].set_title(\"Gamma\")\nax[1, 0].set_title(\"Theta\")\nax[1, 1].set_title(\"Vega\")\n\n# Adjust layout\nfig.legend(\n    date_labels,\n    loc=\"upper center\",\n    ncol=6,\n    bbox_to_anchor=(0.5, 0),\n    frameon=False,\n)\nfig.suptitle(\n    \"Greek Sensitivities for NVDA\", fontsize=30, x=0.5, y=0.98, fontfamily=\"cursive\"\n)\n\nfig.tight_layout()\n\n# Show the plot\nplt.show()\n\n    1 Month 2 Months 3 Months 4 Months 5 Months 6 Months\n135 0.3367 0.3835 0.4084 0.4282 0.4395 0.4484\n140 0.1525 0.2277 0.2722 0.3087 0.3298 0.3466\n145 0.0539 0.1188 0.1666 0.2099 0.2363 0.2578\n150 0.0149 0.0547 0.0939 0.1349 0.1619 0.1848\n155 0.0033 0.0224 0.049 0.0822 0.1063 0.128\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit_41.png\" /\u003e\n\n해석: 옵션 그리스는 옵션 가격이 변동성이나 기초 자산의 가격과 같은 기본 결정 요소에 대한 민감성을 나타내는 재정적 측정치입니다. 그리스는 옵션 포트폴리오를 분석하고 옵션 또는 옵션 포트폴리오의 민감성 분석에 활용됩니다. 이러한 측정치는 많은 투자자에 의해 옵션 거래에 대한 정보를 얻기 위한 필수적인 요소로 간주됩니다.\n\nDelta: 기초 자산의 가격이 $1 증가하면 옵션의 가격이 Delta 금액만큼 변동합니다.\n\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n감마는 델타의 변화가 기초 자산 가격 변동과 어떻게 관련되는지를 측정하는 지표입니다. 기초 자산 가격이 $1 증가하면, 옵션의 델타는 감마만큼 변화합니다.\n\n베가는 옵션의 가격이 기초 자산의 변동성에 얼마나 민감한지를 나타내는 옵션 그리스 중 하나입니다. 기초 자산의 변동성이 1% 증가하면, 옵션 가격은 베가만큼 변화합니다.\n\n세타는 옵션 가격이 옵션의 만기까지 남은 시간에 대해 얼마나 민감한지를 나타내는 지표입니다. 옵션의 만기까지 남은 기간이 하루 줄어들면, 옵션 가격은 세타만큼 변화합니다. 세타 옵션 그리스는 시간 가치 손실이라고도 불립니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- ATM(At the money)은 옵션의 행사 가격이 기초 자산의 현재 시장 가격과 동일한 상황을 말합니다. ATM 콜 옵션은 델타가 0.50입니다.\n- NVDA/AMD의 ATM 행사 가격 USD는 130/175입니다.\n- 세타는 일반적으로 롱 포지션에 대해 음수로 표현되며, 옵션 가치의 얼마나 많은 부분이 손실되고 있는지를 나타냅니다.\n- 저희의 그래프는 NVDA/AMD의 ATM 세타가 약 -0.3/-0.45임을 보여줍니다.\n- 델타가 . 40-. 60 범위에 있거나 일반적으로 옵션이 ATM일 때 감마가 가장 높습니다. 따라서 만약 옵션의 델타가 +40이고 감마가 10이라면 기초 자산 가격이 1달러 오르면 그 옵션의 델타가 +50이 됩니다.\n- 저희 예시에서 NVDA/AMD의 ATM 감마는 0.05/0.035입니다.\n- 옵션 베가는 기본 주가 변동성에 대한 옵션의 민감도를 보고하는 것입니다. 더 높은 베가 값은 옵션 가격이 변동성 변화에 민감하다는 것을 나타내고, 더 낮은 베가는 옵션 가격이 변동성 변화에 민감하지 않다는 것을 나타냅니다.\n- 우리의 다이어그램은 NVDA/AMD의 ATM 베가가 0.14/0.18임을 나타냅니다.\n\n## NVDA \u0026 AMD VaR vs Benchmark\n\n- NVDA \u0026 AMD Value-at-Risk (VaR) vs Benchmark을 플로팅합니다. [9]\n\n\n|                 | NVDA    | AMD     | Benchmark |\n|-----------------|---------|---------|-----------|\n| 2017-01-02/2017-01-08 | -0.0198 | -0.0141    | -0.0007  |\n| 2017-01-09/2017-01-15 | -0.0146 | -0.0356    | -0.0031  |\n| 2017-01-16/2017-01-22 | -0.0217 | -0.0627    | -0.0037  |\n| 2017-01-23/2017-01-29 | NaN     | -0.004     | -0.0024  |\n| 2017-01-30/2017-02-05 | -0.0131 | -0.0192    | -0.005   |\n| ...             | ...     | ...     | ...       |\n| 2024-06-03/2024-06-09 | -0.0096 | -0.0215    | -0.001   |\n| 2024-06-10/2024-06-16 | -0.0042 | -0.0376    | NaN      |\n| 2024-06-17/2024-06-23 | -0.0349 | -0.0214    | -0.0025  |\n| 2024-06-24/2024-06-30 | -0.0573 | -0.0147    | -0.0038  |\n| 2024-07-01/2024-07-07 | -0.0079 | -0.0255    | NaN      |\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/TIL/assets/img/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit_42.png)\n\n2024-07 추론: NVDA, AMD 및 S\u0026P 500의 VaR은 각각 약 5%, 3% 및 1%입니다.\n\n## NVDA 및 AMD의 Fama-French 요인과의 상관 관계\n\n- 투자자들은 위험을 양적화하고 자본에 대한 예상 수익을 추정하는 데 사용되는 금융 모델을 찾고 있습니다. Fama French 5요인 모델은 가장 고전적인 모델 중 하나입니다(Fama 및 French, 2015).\n- NVDA와 AMD의 Fama-French 요인과의 상관 관계 탐색\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n화면에 요소 대상 상호 상관 관계를 표시합니다.\n\n# 클립 보드에 복사하기 (README에 데이터를 붙여넣기하려는 목적)\npd.io.clipboards.to_clipboard(\n    factor_asset_correlations.xs(\"NVDA\", axis=1, level=0)\n    .iloc[:-1]\n    .tail()\n    .to_markdown(),\n    excel=False,\n)\n\n# factor_asset_correlations DataFrame을 정의하세요 (YourDataFrame을 대체하세요)\ncorrelations_aapl = factor_asset_correlations.xs(\"NVDA\", axis=1, level=0)\ncorrelations_msft = factor_asset_correlations.xs(\"AMD\", axis=1, level=0)\n\n# x축을 공유하며 서브플롯을 만들고 스타일을 사용자 정의하세요\nfig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 8), sharex=True)\n\n# 선에 대한 색상 팔렛트 설정\ncolors = [\"#007ACC\", \"#FF6F61\", \"#4CAF50\", \"#FFD700\", \"#FF6347\", \"#6A5ACD\", \"#FF8C00\"]\n\n# AAPL의 상호 상관 관계 그래프\ncorrelations_aapl.plot(\n    ax=ax1, title=\"NVDA의 Fama-French Factors와의 상관 관계\", color=colors\n)\nax1.set_ylabel(\"상관 관계\")\nax1.legend(loc=\"upper right\", frameon=False)\n\n# MSFT의 상호 상관 관계 그래프\ncorrelations_msft.plot(\n    ax=ax2, title=\"AMD의 Fama-French Factors와의 상관 관계\", color=colors\n)\nax2.set_xlabel(\"날짜\")\nax2.set_ylabel(\"상관 관계\")\nax2.legend(loc=\"upper right\", frameon=False)\n\n# 명확한 그리드 선을 추가하세요\nax1.grid(True, linestyle=\"--\", alpha=0.5)\nax2.grid(True, linestyle=\"--\", alpha=0.5)\n\n# 범례 및 레이블을 사용자 정의하세요\nax1.legend(loc=\"upper right\", frameon=False)\nax2.legend(loc=\"upper right\", frameon=False)\n\n# 서브플롯의 배경색을 설정하세요\nax1.set_facecolor(\"#F9F9F9\")\nax2.set_facecolor(\"#F9F9F9\")\n\n# 서브플롯의 위쪽과 오른쪽 테두리를 제거하세요\nax1.spines[[\"top\", \"right\"]].set_visible(False)\nax2.spines[[\"top\", \"right\"]].set_visible(False)\n\n# 간격을 최적화하기 위해 tight 레이아웃 설정\nplt.tight_layout()\n\n# 그래프 보기\nplt.show()\r\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- MKT은 시장의 초과수익입니다. 이것은 가치가 가중치가 부여된 시장 포트폴리오의 수익률입니다.\n- SMB는 소형 주식의 다양한 포트폴리오의 수익률에서 대형 주식의 다양한 포트폴리오의 수익률을 뺀 값입니다.\n- HML은 고 Book-to-Market 비율을 가진 주식의 다양한 포트폴리오와 저 Book-to-Market 비율을 가진 주식의 다양한 포트폴리오 간의 차이입니다.\n- RMW는 강한(높고 안정적인) 수익성을 가진 주식의 다양한 포트폴리오와 약한(낮은) 수익성을 가진 주식의 다양한 포트폴리오 간의 차이입니다.\n- CMA는 저 및 고 투자 기업의 다양한 포트폴리오 간의 차이로 정의됩니다. 여기서 저/고 투자는 재투자 비율이 낮음/높음을 의미합니다.\n\n## 추론 2024:\n- HML(NVDA)`HML(AMD)\n- 만약 가치 주식이 성장 주식을 능가할 것이라고 믿는다면, 포트폴리오를 HML 요인이 높은 자산 쪽으로 기울이는 것이 좋습니다.\n- 우리의 예에서는 저 Book-to-Market 비율을 가진 대형기업의 경우, \"큰 규모\" 및 \"낮은 가치\" 범주로 분류됩니다. Fama-French 모델에 따르면, 이 기업은 장기적으로 낮은 수익률을 제공할 것으로 예상되며, SMB 및 HML 요인이 모두 음수일 것으로 예상됩니다.\n- HML 요인과 유사하게 정의된 수익성 요인(RMW)은 운영 수익성이 강한(높음) 기업과 약한(낮은) 기업의 수익률 간의 차이입니다. 우리는 알 수 있습니다.\n- RMW(NVDA) 약 0.25이며 RMW(AMD) 약 0.1입니다.\n\n## TA 이치모쿠 클라우드: NVDA 대 AMD\n\n- TA 이치모쿠 클라우드는 시장 심리와 가격 모멘텀을 한눈에 볼 수 있게 하여 트레이더가 추세를 식별하는 데 도움을 줄 수 있습니다.\n- NVDA \u0026 AMD에 대한 이치모쿠 클라우드 비교\n\n```js\ndisplay(ichimoku_cloud)\n\n# 이치모쿠 클라우드 데이터 데이터프레임 정의\nichimoku_data_aapl = ichimoku_cloud.xs(\"NVDA\", level=1, axis=1)\nichimoku_data_msft = ichimoku_cloud.xs(\"AMD\", level=1, axis=1)\n\n# 클립보드에 복사 (이것은 README에 데이터를 붙여넣기하기 위한 것입니다)\npd.io.clipboards.to_clipboard(ichimoku_data_aapl.tail().to_markdown(), excel=False)\n\n# 마지막 500행 가져오기\nichimoku_data_aapl = ichimoku_data_aapl.iloc[-500:]\nichimoku_data_msft = ichimoku_data_msft.iloc[-500:]\n\n# 수평 서브플롯을 위한 그림 및 두 개의 축 생성\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))\n\n# PeriodIndex를 DatetimeIndex로 변환\nichimoku_data_aapl.index = ichimoku_data_aapl.index.to_timestamp()\nichimoku_data_msft.index = ichimoku_data_msft.index.to_timestamp()\n\n# NVDA용 이치모쿠 클라우드 플롯\nax1.plot(\n    ichimoku_data_aapl.index,\n    ichimoku_data_aapl[\"Conversion Line\"],\n    color=\"blue\",\n    label=\"Conversion Line (텐칸센)\",\n    linewidth=2,\n)\nax1.plot(\n    ichimoku_data_aapl.index,\n    ichimoku_data_aapl[\"Base Line\"],\n    color=\"red\",\n    label=\"Base Line (기준선)\",\n    linewidth=2,\n)\nax1.fill_between(\n    ichimoku_data_aapl.index,\n    ichimoku_data_aapl[\"Leading Span A\"],\n    ichimoku_data_aapl[\"Leading Span B\"],\n    where=ichimoku_data_aapl[\"Leading Span A\"] \u003e= ichimoku_data_aapl[\"Leading Span B\"],\n    facecolor=\"green\",\n    alpha=0.2,\n    label=\"상승 클라우드\",\n)\nax1.fill_between(\n    ichimoku_data_aapl.index,\n    ichimoku_data_aapl[\"Leading Span A\"],\n    ichimoku_data_aapl[\"Leading Span B\"],\n    where=ichimoku_data_aapl[\"Leading Span A\"] \u003c ichimoku_data_aapl[\"Leading Span B\"],\n    facecolor=\"red\",\n    alpha=0.2,\n    label=\"하락 클라우드\",\n)\n\n# NVDA에 대한 범례 및 레이블 사용자 정의\nax1.legend(loc=\"upper left\")\nax1.set_xlabel(\"날짜\", fontsize=14)\nax1.set_ylabel(\"가격\", fontsize=14)\nax1.set_title(\"이치모쿠 클라우드 차트 (NVDA)\", fontsize=16)\nax1.grid(True, linestyle=\"--\", alpha=0.5)\nax1.set_facecolor(\"#f7f7f7\")\nax1.tick_params(axis=\"both\", which=\"major\", labelsize=12)\n\n# MSFT용 이치모쿠 클라우드 플롯\nax2.plot(\n    ichimoku_data_msft.index,\n    ichimoku_data_msft[\"Conversion Line\"],\n    color=\"blue\",\n    label=\"Conversion Line (텐칸센)\",\n    linewidth=2,\n)\nax2.plot(\n    ichimoku_data_msft.index,\n    ichimoku_data_msft[\"Base Line\"],\n    color=\"red\",\n    label=\"Base Line (기준선)\",\n    linewidth=2,\n)\nax2.fill_between(\n    ichimoku_data_msft.index,\n    ichimoku_data_msft[\"Leading Span A\"],\n    ichimoku_data_msft[\"Leading Span B\"],\n    where=ichimoku_data_msft[\"Leading Span A\"] \u003e= ichimoku_data_msft[\"Leading Span B\"],\n    facecolor=\"green\",\n    alpha=0.2,\n    label=\"상승 클라우드\",\n)\nax2.fill_between(\n    ichimoku_data_msft.index,\n    ichimoku_data_msft[\"Leading Span A\"],\n    ichimoku_data_msft[\"Leading Span B\"],\n    where=ichimoku_data_msft[\"Leading Span A\"] \u003c ichimoku_data_msft[\"Leading Span B\"],\n    facecolor=\"red\",\n    alpha=0.2,\n    label=\"하락 클라우드\",\n)\n\n# AMD에 대한 범례 및 레이블 사용자 정의\nax2.legend(loc=\"upper left\")\nax2.set_xlabel(\"날짜\", fontsize=14)\nax2.set_ylabel(\"가격\", fontsize=14)\nax2.set_title(\"이치모쿠 클라우드 차트 (AMD)\", fontsize=16)\nax2.grid(True, linestyle=\"--\", alpha=0.5)\nax2.set_facecolor(\"#f7f7f7\")\nax2.tick_params(axis=\"both\", which=\"major\", labelsize=12)\n\n# 서브플롯 간의 간격 조정\nplt.tight_layout()\n\n# 플롯 보기\nplt.show()\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![이미지](/TIL/assets/img/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit_45.png)\n\n- 이 그래프는 NVDA 및 AMD가 각각 상승 및 하락하는 단기 추세를 따르는 것을 보여줍니다. AMD 플롯을 보면 2024년 7월에 Tenkan Sen(파란색 선)과 Kijun Sen(빨간색 선)이 명확히 교차하는 것을 볼 수 있습니다.\n\n## 1년 빅테크 주가 예측\n\n- FinanceToolkit이 1년 빅테크 주식을 예측할 수 있나요?\n- 회사 티커로 Toolkit을 초기화하고 1년 주식 가격 시뮬레이션을 플로팅하기 [9]\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 회사 티커로 Toolkit을 초기화합니다\n회사 = Toolkit(\n    [\"AAPL\", \"MSFT\", \"GOOGL\", \"AMZN\"], api_key=API_KEY, start_date=\"2005-01-01\"\n)\n\n주가모의실험 = 회사.options.get_stock_price_simulation(timesteps=10)\n\nfig, ax = plt.subplots(2, 2, figsize=(15, 10))\n\n주가모의실험_전치 = 주가모의실험.T\n주가모의실험_전치.index = (\n    주가모의실험_전치.index.astype(\"datetime64[ns]\")\n)\n\nfor i, 티커 in enumerate(회사._tickers):\n    ax[i // 2, i % 2].plot(주가모의실험_전치[티커])\n    ax[i // 2, i % 2].set_title(티커)\n    ax[i // 2, i % 2].xaxis.set_tick_params(rotation=20)\n    ax[i // 2, i % 2].yaxis.set_tick_params(labelsize=8)\n    ax[i // 2, i % 2].grid(linestyle=\"--\", alpha=0.5)\n\nfig.suptitle(\"주가 모의실험\", fontweight=\"bold\")\nfig.tight_layout()\nplt.show()\r\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit_46.png\" /\u003e\n\n- 이러한 예측은 시간이 흐름에 따른 자본 가격의 이항 리턴 분포에 기반합니다. 이 모델에서는 각 반복마다 두 가지 가능한 결과가 있습니다 — 상승하거나 하락하며, 이는 이항 트리를 따릅니다.\n- 시간에 따라 이 두 값을 그리는 것은 이항 트리를 만드는 것으로 알려져 있습니다. 이항 모델에 대한 자세한 내용은 Equity Derivatives의 가격 결정 및 분석(금융 Toolbox)을 참조하십시오.\n- 이 모델은 직관적이며 잘 알려진 Black-Scholes 모델보다 실무에서 더 자주 사용됩니다.\n\n## META 캔들스틱 \u0026 기술 분석 지표\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 마침내, 지난 729일 동안의 META TA 전략들을 탐색해 보겠습니다.\n- 주식 데이터 읽기\n\n```js\nticker=\"META\"\ndfme = yf.download(ticker, start = '2020-01-01')\n```\n\n- META 캔들스틱 차트 2020–2024 및 TA 지표 표시\n\n```js\n# 이동평균 추가\ndfme['EMA9'] = dfme['Adj Close'].ewm(span = 9, adjust = False).mean() # 지수 이동평균 9기간\ndfme['SMA20'] = dfme['Adj Close'].rolling(window=20).mean() # 단순 이동평균 20기간\ndfme['SMA50'] = dfme['Adj Close'].rolling(window=50).mean() # 단순 이동평균 50기간\ndfme['SMA100'] = dfme['Adj Close'].rolling(window=100).mean() # 단순 이동평균 100기간\ndfme['SMA200'] = dfme['Adj Close'].rolling(window=200).mean() # 단순 이동평균 200기간\n\n# 14기간 RSI 추가\ndelta = dfme['Adj Close'].diff() # 델타 계산\ngain = delta.where(delta \u003e 0,0) # 상승값 획득\nloss = -delta.where(delta \u003c 0,0) # 하락값 획득\navg_gain = gain.rolling(window=14).mean() # 14기간 평균 상승값 측정\navg_loss = loss.rolling(window=14).mean() # 14기간 평균 하락값 측정\nrs = avg_gain/avg_loss # RS 계산\ndfme['RSI'] = 100 - (100 / (1 + rs)) # 데이터 프레임에 RSI 열 생성\n\n# 20기간 볼린저 밴드 추가\ndfme['BB_UPPER'] = dfme['SMA20'] + 2*dfme['Adj Close'].rolling(window=20).std() # 상단 밴드\ndfme['BB_LOWER'] = dfme['SMA20'] - 2*dfme['Adj Close'].rolling(window=20).std() # 하단 밴드\n\n# 14기간 ATR 추가\ndfme['TR'] = pd.DataFrame(np.maximum(np.maximum(dfme['High'] - dfme['Low'], abs(dfme['High'] - dfme['Adj Close'].shift())), abs(dfme['Low'] - dfme['Adj Close'].shift())), index = dfme.index)\ndfme['ATR'] = dfme['TR'].rolling(window = 14).mean() # 데이터 프레임에 ATR 열 생성\n\n# 지표와 함께 캔들스틱 차트 표시\nfig = make_subplots(rows=4, cols=1, shared_xaxes=True, vertical_spacing=0.05,row_heights=[0.6, 0.10, 0.10, 0.20])\n\n# 캔들스틱\nfig.add_trace(go.Candlestick(x=dfme.index,\n                             open=dfme['Open'],\n                             high=dfme['High'],\n                             low=dfme['Low'],\n                             close=dfme['Adj Close'],\n                             name='META'),\n              row=1, col=1)\n\n# 이동평균\nfig.add_trace(go.Scatter(x=dfme.index,\n                         y=dfme['EMA9'],\n                         mode='lines',\n                         line=dict(color='#90EE90'),\n                         name='EMA9'),\n              row=1, col=1)\n\n# 이하 생략\n...\n\nfig.show()\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit_47.png\" /\u003e\n\n## META RSI 대 MA 백테스팅\n\n- 기술적 분석 백테스팅: 지난 729일 동안의 일별 META 데이터에서 RSI 및 MA 전략의 기대 수익 비교\n\n```python\nend_date = dt.datetime.now() # 3월 21일 날짜를 정의\nstart_date = end_date - dt.timedelta(days=729) # 지난 729일 동안의 시간별 데이터 로딩\n\nhourly_eur_usd = yf.download('META', start=start_date, end=end_date, interval='1d')\nhourly_eur_usd \n\n           Open       High       Low        Close      Adj Close   Volume\nDate      \n2022-07-12 164.800003 165.910004 162.100006 163.270004 162.935181 16639700\n2022-07-13 160.160004 164.979996 159.610001 163.490005 163.154739 16555100\n2022-07-14 161.220001 162.589996 157.279999 158.050003 157.725891 23765200\n2022-07-15 160.539993 164.979996 159.820007 164.699997 164.362244 23342800\n2022-07-18 166.750000 171.690002 165.639999 167.229996 166.887054 23574300\n... ... ... ... ... ... ...\n2024-07-02 500.760010 510.500000 499.450012 509.500000 509.500000 7739500\n2024-07-03 506.369995 511.279999 506.019989 509.959991 509.959991 6005600\n2024-07-05 511.600006 540.869995 511.600006 539.909973 539.909973 21354100\n2024-07-08 542.349976 542.809998 526.650024 529.320007 529.320007 14917500\n2024-07-09 533.750000 537.479980 528.190002 530.000000 530.000000 8753200\n501 rows × 6 columns\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- RSI 백테스팅 전략 구현하기\n\n```js\n# TA 라이브러리를 사용하여 RSI 계산하기\nhourly_eur_usd['rsi'] = ta.momentum.RSIIndicator(hourly_eur_usd['Adj Close'], window=14).rsi()\n\n# RSI 전략의 매개변수 정의\nrsi_period = 14\noverbought = 80\noversold = 40\n\n# 신호를 저장할 새 열 생성\nhourly_eur_usd['signal'] = 0 # 포지션을 가지지 않을 때 'signal' = 0\n\n# 진입점 생성\nfor i in range(rsi_period, len(hourly_eur_usd)):\n    if hourly_eur_usd['rsi'][i] \u003e overbought and hourly_eur_usd['rsi'][i - 1] \u003c= overbought:\n        hourly_eur_usd['signal'][i] = -1 # 'signal' = -1 일 때 판매\n    elif hourly_eur_usd['rsi'][i] \u003c oversold and hourly_eur_usd['rsi'][i - 1] \u003e= oversold:\n        hourly_eur_usd['signal'][i] = 1 # 'signal' = 1 일 때 구매\n        \n# 통화쌍의 일일 수익률 계산\nhourly_eur_usd['returns'] = hourly_eur_usd['Adj Close'].pct_change()\nhourly_eur_usd['cumulative_returns'] = (1 + hourly_eur_usd['returns']).cumprod() - 1 # 기간의 총 수익률\n\n# 신호를 수익에 적용\nhourly_eur_usd['strategy_returns'] = hourly_eur_usd['signal'].shift(1) * hourly_eur_usd['returns']\n\n# 전략의 누적 수익 계산\nhourly_eur_usd['cumulative_strategy_returns'] = (1 + hourly_eur_usd['strategy_returns']).cumprod() - 1\n\n# 초기 자본을 $100으로 설정\ninitial_capital = 100\n\n# 전체 포트폴리오 가치 계산\nhourly_eur_usd['portfolio_value'] = (1 + hourly_eur_usd['strategy_returns']).cumprod() * initial_capital\n\n# 거래 수, 초기 자본, 최종 자본 출력\nnum_trades = hourly_eur_usd['signal'].abs().sum()\nfinal_capital = hourly_eur_usd['portfolio_value'].iloc[-1]\ntotal_return = (final_capital - initial_capital) / initial_capital * 100\n\nprint('\\n')\nprint(f\"거래 수: {num_trades}\")\nprint(f\"초기 자본: ${initial_capital}\")\nprint(f\"최종 자본: ${final_capital:.2f}\")\nprint(f\"총 수익률: {total_return:.2f}%\")\nprint('\\n')\n\n# 포트폴리오 총 가치 플로팅\nfig = go.Figure()\n\nfig.add_trace(go.Scatter(x=hourly_eur_usd.index,\n                         y=hourly_eur_usd['portfolio_value'].round(2),\n                         mode='lines',\n                         line=dict(color='#00BFFF'),\n                         name='포트폴리오 가치'))\n\nfig.update_layout(title='예상 수익 RSI 전략 META 데이터',\n                  xaxis_title='날짜',\n                  yaxis_title='가치 ($)',\n                  template='plotly_dark',\n                  height=600)\n\nfig.show()\n\n거래 수: 11\n초기 자본: $100\n최종 자본: $107.97\n총 수익률: 7.97%\r\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit_48.png\" /\u003e\n\n- MA 백테스팅 전략 구현하기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# TA 라이브러리를 사용하여 EMA 생성\nws = 5\nwl = 10\nhourly_eur_usd['ema9'] = ta.trend.ema_indicator(hourly_eur_usd['Adj Close'], window=ws)\n\n# TA 라이브러리를 사용하여 SMA 생성\nhourly_eur_usd['sma20'] = ta.trend.sma_indicator(hourly_eur_usd['Adj Close'], window=wl)\n\n# 이동평균 교차 전략 매개변수 정의\nshort_ma = 'ema9'\nlong_ma = 'sma20'\n\n# 신호를 저장할 새 열 생성\nhourly_eur_usd['signal'] = 0\n\n# 진입 신호 생성\nfor i in range(1, len(hourly_eur_usd)):\n    if hourly_eur_usd[short_ma][i] \u003e hourly_eur_usd[long_ma][i] and hourly_eur_usd[short_ma][i - 1] \u003c= hourly_eur_usd[long_ma][i - 1]:\n        hourly_eur_usd['signal'][i] = 1  # 매수 신호\n    elif hourly_eur_usd[short_ma][i] \u003c hourly_eur_usd[long_ma][i] and hourly_eur_usd[short_ma][i - 1] \u003e= hourly_eur_usd[long_ma][i - 1]:\n        hourly_eur_usd['signal'][i] = -1  # 매도 신호\n\n# 총 수익률 계산\nhourly_eur_usd['returns'] = hourly_eur_usd['Adj Close'].pct_change()\nhourly_eur_usd['cumulative_returns'] = (1 + hourly_eur_usd['returns']).cumprod() - 1\n\n# 수익률에 신호 적용\nhourly_eur_usd['strategy_returns'] = hourly_eur_usd['signal'].shift(1) * hourly_eur_usd['returns']\n\n# 누적 수익률 계산\nhourly_eur_usd['cumulative_strategy_returns'] = (1 + hourly_eur_usd['strategy_returns']).cumprod() - 1\n\n# 초기 자본 설정\ninitial_capital = 100\n\n# 포트폴리오 가치 총액 계산\nhourly_eur_usd['portfolio_value'] = (1 + hourly_eur_usd['strategy_returns']).cumprod() * initial_capital\n\n# 거래 횟수, 초기 자본, 최종 자본 출력\nnum_trades = hourly_eur_usd['signal'].abs().sum()\nfinal_capital = hourly_eur_usd['portfolio_value'].iloc[-1]\ntotal_return = (final_capital - initial_capital) / initial_capital * 100\n\nprint('\\n')\nprint(f\"거래 횟수: {num_trades}\")\nprint(f\"초기 자본: ${initial_capital}\")\nprint(f\"최종 자본: ${final_capital:.2f}\")\nprint(f\"총 수익률: {total_return:.2f}%\")\nprint('\\n')\n\n# 전략 가치 그래픽화\nfig = go.Figure()\n\nfig.add_trace(go.Scatter(x=hourly_eur_usd.index,\n                         y=hourly_eur_usd['portfolio_value'].round(2),\n                         mode='lines',\n                         line=dict(color='#00BFFF'),\n                         name='포트폴리오 가치'))\n\nfig.update_layout(title='META 데이터에 기대되는 결과 이동평균 교차 전략',\n                  xaxis_title='날짜',\n                  yaxis_title='가치 ($)',\n                  template='plotly_dark',\n                  height=600)\n\nfig.show()\n\n거래 횟수: 50\n초기 자본: $100\n최종 자본: $108.00\n총 수익률: 8.00%\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit_49.png\" /\u003e\n\n- RSI 및 MA 전략은 모두 2022년부터 2024년까지 META 데이터에서 약 8%의 예상 수익을 산출함을 확인할 수 있습니다. 그러나 거래 횟수 측면에서 RSI 전략이 더 우수함을 알 수 있습니다. 즉, 11 (RSI) vs 50 (MA).\n\n# 결론\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 저희 사회의 디지털화가 급속히 증가함에 따라 미국 대형 기술 기업(Big Tech)들이 디지털 인프라와 플랫폼 소유를 통해 엄청난 부를 축적하고 영향력을 행사하게 되었습니다.\n- 본 게시물에서는 기술적, 기본적 분석 도구와 최신 포트폴리오 최적화(PO) 알고리즘을 Python을 활용해 통합한 미국 Big Tech들의 양적 거래 분석을 제시했습니다.\n- 우리는 기술적 분석 지표, 주식 기초 및 리스크 및 수익을 동시에 고려한 PO를 통합했습니다.\n- 우리는 이번 연구 동안 Quantstats, TA, PyPortfolioOpt, Plotly, FinanceToolkit 라이브러리를 사용했습니다.\n- 누적 수익, 첨도, 비대칭도, 상관 관계, 표준편차, 베타, 샤프 비율 등의 금융 지표를 분석했습니다.\n- 2020년부터 2024년까지의 금융 성과인 등가 가중 포트폴리오와 최대 샤프 비율 포트폴리오와 S\u0026P 전략을 비교했습니다(Sortino, Sharpe, Calmar, Treynor 비율, 켈리 기준, MTD, 최대 하락 폭, 베타, 알파, 연평균 복리 증가율 등).\n- 2019년부터 2024년까지 NVDA 대 AMD 손익 계산서와 수익성 비율을 분석했습니다. 그리스 감능성, Value-at-Risk(VaR) 대 대조군, Fama-French 5 요인과의 상관 관계를 시각화했습니다.\n- 주식 가격 예측에 대한 1년치 Big Tech 주가 예측을 시간별로 이루어진 자산 가격의 이항 분포를 따르는 움직임 상승 또는 하락 두 가지 결과를 지닌 이진 트리를 따라 반복하여 모델을 사용했습니다.\n- 기술 시장의 감성 및 가격 모멘텀을 파악하기 위해 TA Ichimoku 클라우드를 활용했습니다.\n- 마지막 729일의 META TA 전략을 탐색하면서 RSI 대 MA 크로스오버 거래 신호(백테스팅)의 예상 수익을 비교했습니다.\n- TA 지표와 함께 2020년부터 2024년까지의 META 캔들스틱 차트는 주식 데이터 시각화에서 Plotly의 강력함을 보여 주었습니다.\n\n# 참고 문헌\n\n- Markowitz, H., 1952, PORTFOLIO SELECTION. The Journal of Finance.\n- Markowitz meets technical analysis: Building optimal portfolios by exploiting information in trend-following signals\n- Mastering Market Movements: Integrating Technical and Fundamental Analysis in Trading\n- Fundamental vs. Technical Analysis: An Overview\n- The Advantages and Disadvantages of Technical Analysis\n- The pros and cons of fundamental analysis\n- Fundamental Analysis: Advantages And Disadvantages\n- Portfolio Optimization: How to Find Your Investment Balance\n- Financial Analysis with the Finance Toolkit in Python\n\n# 더 알아보기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 주식 포트폴리오 위험/수익률 최적화\n- 비트코인, 금, 원유 가격의 종합 분석\n- Max(수익률/위험) 거래를 향하여\n- 75가지 간단한 FinTA 지표를 사용한 NVDA 기술 분석\n\n## 연락처\n\n- 웹사이트\n- GitHub\n- X/Twitter\n- Pinterest\n- Mastodon\n- Tumblr\n\n## 면책사항\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 다음의 면책 조항은이 기사에 제공 된 정보가 교육 용도로만 사용되며 재정 건전성 또는 투자 자문으로 간주되어서는 안 된다는 것을 명확히합니다.\n- 제공된 정보는 귀하의 개별 재정 상황, 목표 또는 리스크 허용도를 고려하지 않습니다.\n- 귀하가 하는 어떠한 투자 결정이나 조치도 귀하의 전적인 책임입니다.\n- 귀하의 재정 목표, 리스크 허용도 및 투자 시간표에 근거하여 어떤 투자의 적합성을 독립적으로 평가해야합니다.\n- 귀하는 귀하의 특정 요구에 맞게 맞춤 지도를 제공할 수있는 인증 된 재무 전문가의 조언을 구하는 것이 좋습니다.\n- 제공되는 도구, 데이터, 콘텐츠 및 정보는 개인의 투자 요구를 충족시키기 위해 맞춤화되지 않았습니다. 따라서 도구, 데이터, 콘텐츠 및 정보는 정보 및 교육 목적으로만 제공됩니다.","ogImage":{"url":"/TIL/assets/img/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-AnIntegratedQuantTradingAnalysisofUSBigTechsusingQuantstatsTAPyPortfolioOptandFinanceToolkit_0.png","tag":["Tech"],"readingTime":76},{"title":"Python의 가장 강력한 데코레이터","description":"","date":"2024-07-13 20:21","slug":"2024-07-13-PythonsMostPowerfulDecorator","content":"\n\n![파이썬의 강력한 데코레이터](/TIL/assets/img/2024-07-13-PythonsMostPowerfulDecorator_0.png)\n\n@property는 파이썬에서 제일 좋아하는 데코레이터입니다. 여러 해 동안 파이썬을 사용해왔는데, 매년마다 언어에 대한 전문 지식과 편안함이 조금씩 쌓여왔어요. 이렇게 오랜 기간 동안 배운 기술과 트릭 가운데, property 데코레이터는 두드러지는 효과를 발휘했습니다. 이 데코레이터는 복잡한 문제 해결을 도와주고 깔끔하고 효율적이며 우아한 코드를 작성하는 데 지속적으로 도움을 주고 있어요.\n\n@property 데코레이터는 클래스 속성과 상호작용하는 방식을 향상시키는 엄청난 기능입니다. 속성을 연결하고 의존성을 만드는 강력한 방법이 될 수 있어요. 이 초보자 친화적인 안내서에서 속성의 기본 개념을 탐구하고 클래스를 강화하기 위해 5가지 다른 방법에 대해 알아볼 거에요. 또한 데이터 과학과 기계 학습 분야의 실용적인 예제를 통해 이해를 더욱 견고하게 할 거예요.\n\n팁: 파이썬 애호가에게 처음으로 속성을 소개할 때 그들 눈 속에서 반짝임을 볼 때 너무 흥분돼요. 처음 알게 될 때도 그대로 반짝이길 바래요! 이미 경험 많은 개발자이고 개념에 익숙하다면, 이 포스트에서 새로운 것을 발견했으면 좋겠어요. 어찌되었든, 설명이 더 잘 될 수 있는 부분이 있거나 놓칠법한 중요한 사용 사례가 있다면 댓글에서 알려주시면 감사하겠습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 속성 간단 안내서\n\n한 마디로 말하자면, 파이썬에서 속성(property)은 객체의 특정 측면에 대한 제어된 액세스를 허용하는 특수한 속성입니다. 다음과 같이 이름과 클래스라는 두 가지 간단한 속성을 정의하는 학생(Student) 클래스를 고려해보십시오. 우리는 인스턴스화하고 다음과 같이 이름 속성에 액세스할 수 있습니다:\n\n학생의 이름을 요청하고 이름 속성에 액세스하여 출력할 수 있습니다. 모두 좋습니다! 이제 학생들에게 이름을 요청할 때마다 일어서도록 강제하고 싶다고 상상해보십시오. 다음과 같이 속성 데코레이터를 사용하여 코드를 다시 포매팅함으로써 쉽게 이를 달성할 수 있습니다:\n\n여기서 @property를 사용하여 이름 속성에 액세스하기 전에 추가 작업을 할 수 있었습니다! 이름 속성의 기술용어는 getter입니다: 속성을 \"가져오기\"하기 전에 작업을 수행할 수 있는 방법이라고 생각해보세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기본적으로 속성은 Python에서 getter 메서드를 생성할 수 있게 해주는 바로가기로 생각할 수 있어요. 객체에 대한 정보를 안전하게 접근할 수 있는 방법을 제공해줍니다. @property를 통해 구현된 getter 메서드를 통해 비공개 또는 보호된 속성에 안전하게 접근할 수 있게 됩니다. 위 예시에서 볼 수 있듯이, \"비공개\" 속성 _name을 정의하고 getter 메서드인 name 속성을 통해 접근하고 있어요.\n\n속성의 가장 중요한 기능은 속성을 읽기 전용으로 만들어 값을 덮어쓰기하는 것을 막는다는 점이에요. 아래 예시를 살펴보세요:\n\nname이 속성으로 설정되어 있기 때문에 보통의 속성처럼 어떤 값을 간단히 덮어쓸 수 없어요. 이렇게 함으로써 속성의 무결성과 기능성이 애플리케이션 전반에 걸쳐 유지되도록 보장할 수 있어요.\n\n요약하자면, 속성은 속성을 읽기 전용으로 만들어주고 실제 속성에 접근하기 전에 다른 작업을 수행할 수 있도록 해줍니다. 실제 예시를 통해 자세히 살펴보겠지만, 지금은 속성 데코레이터가 어떻게 작동하는지에 대한 대략적인 개념을 이해하셨으면 좋겠어요. 계속 진행하기 전에 한 가지 알아보고 넘어가기 위해 속성이 어떻게 작동하는지와 속성이 작동하는 기본 개념인 디스크립터에 대해 간단히 살펴보겠습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 뒷면에서: 속성과 디스크립터\n\n속성은 속성이 어떻게 접근, 수정 또는 삭제되는지를 결정하는 객체인 디스크립터 개념과 밀접한 관련이 있습니다. 여기서는 \"접근\" 부분에만 초점을 맞춥니다. 디스크립터는 클래스 내의 속성에 대한 특정 규칙과 조건을 정의할 수 있습니다. 일반적으로 이를 통해 코드와 객체/클래스의 동작을 더 잘 제어하고 유연하게 조작할 수 있습니다. 속성은 내부적으로 디스크립터를 활용하여 클래스에 이를 녹여내어 객체/클래스의 기능을 향상시킬 수 있습니다.\n\n메소드에 @property 데코레이터를 사용하면 getter 디스크립터가 생성됩니다. 속성에 접근할 때 디스크립터의 __get__ 메소드가 호출되어 속성 값을 반환하기 전에 추가 동작을 수행할 수 있습니다. 실제로 @property 데코레이터는 getter 디스크립터를 만드는 간편한 방법입니다.\n\n디스크립터의 작동 방식에 대한 자세한 내용은 이 글의 범위를 벗어나지만, 파이썬 참조 문서와 Real Python의 훌륭한 기사를 참조하여 더 자세히 알아볼 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 데이터 처리 및 기계 학습의 맥락에서 속성을 사용하는 5가지 다른 방법을 살펴보겠습니다.\n\n# 1. 데이터 또는 모델 속성이 덮어쓰기되는 것으로부터 보호하기\n\n![이미지](/TIL/assets/img/2024-07-13-PythonsMostPowerfulDecorator_1.png)\n\n우리가 토론한 대로, 속성은 직접 할당을 제한하여 클래스 속성이 덮어쓰기되는 것을 방지하는 강력한 메커니즘을 제공합니다. 이 기능은 데이터 과학 및 기계 학습 응용 프로그램에서 데이터 및 모델의 무결성이 중요한 경우에 특히 가치가 있습니다. @property 데코레이터를 활용하여 읽기 전용 속성을 생성할 수 있으며, 이를 통해 속성에 액세스할 수 있지만 수정할 수는 없습니다. 이는 우연한 오류 발생 가능성이 적은 견고한 데이터 및 모델 객체를 생성하는 데 매우 유용할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n클래스 속성이 데이터셋을 나타낼 때는 덮어쓰기를 방지하는 것이 매우 중요합니다. 이렇게 함으로써 데이터의 일관성과 신뢰성을 보장할 수 있습니다. 데이터 과학과 기계 학습 워크플로우에서 데이터셋은 종종 외부 소스에서 로드되거나 복잡한 계산을 통해 생성됩니다. 한 번 데이터가 로드되거나 계산된 후에는 그 무결성을 유지하는 것이 중요합니다. 이를 통해 후속 분석이나 모델에서 오류나 불일치를 방지할 수 있습니다.\n\n예를 들어, 간단한 데이터 로더 클래스를 고려해 보겠습니다. 이 클래스는 경로를 입력으로 받아들이고 해당 경로에 포함된 데이터를 로드합니다(간소화된 예시로 Parquet 파일을 가정합니다).\n\n여기서 주된 문제는 예시에서 보여준 것처럼 데이터셋 속성을 덮어쓸 수 있다는 것입니다. 데이터를 실수로 수정하여 원본 경로에 더 이상 해당하지 않음을 깨닫지 못한 채로 파이프라인에 문제가 발생할 수 있습니다. 게다가 클래스에서 다른 속성(카운트 또는 평균 및 통계와 같은 일반 통계치)을 계산하고 있고 데이터가 실수로 덮어써진 경우, 여전히 통계치가 데이터에 해당한다고 잘못 가정할 수 있습니다.\n\n이 문제를 개선하기 위해 dataset을 호출할 때 경로를 로드하는 메서드로 변환하는 방법이 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n혹시 load_dataset() 메서드를 호출하기 위해 seemingly redundant 한 dataset() 메서드를 정의하는지 혼란스러워 하신다면, 곧 알게 될 거예요.\n\n여기서 전체 아이디어는 이제 file_path 속성 대신 데이터가 항상 dataset() 메서드를 통해 가져와진다는 것입니다. 이것은 완벽한 해결책은 아니지만, dataset() 메서드가 속성이 아닌 메서드이기 때문에 (1) 그렇게 완벽하지는 않고, (2) 여전히 실수로 덮어쓸 수 있습니다. @property 데코레이터를 사용하면 이 두 문제를 동시에 해결할 수 있어요.\n\n매직! 이전 코드 스니펫과 거의 동일하지만 데코레이터 하나를 추가함으로써 두 문제를 해결했어요. dataset은 이제 사실상 읽기 전용 속성이 됐어요.\n\n지금까지 좋아요, 하지만 또 다른 문제가 생겼어요. 이 특정 구현은 데이터셋 속성을 호출할 때마다 데이터를 불러오기 위해 pd.read_parquet() 함수를 호출합니다. 이것은 매우 비효율적일 수 있으며, 중대한 크기의 데이터셋에도 적합하지 않을 수 있어요. 데이터셋 메서드에 캐싱을 구현해야 합니다. 이것이 다음 세그먼트의 주제입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n작업을 계속하기 전에, 이 세그먼트를 요약해보겠습니다. 클래스 속성이 덮어쓰여지는 것을 방지하는 속성을 사용함으로써, 데이터 과학과 머신 러닝 애플리케이션에서 데이터의 일관성과 신뢰성을 보장할 수 있습니다. 이는 모델의 무결성을 유지하고 오류를 방지하며 정확한 분석과 예측을 촉진하는 데 도움이 됩니다.\n\n이제 @property를 사용하여 클래스를 강화할 수 있는 몇 가지 다른 방법을 살펴보겠습니다.\n\n# 2. 비싼 속성의 캐싱 및 최적화\n\n![이미지](/TIL/assets/img/2024-07-13-PythonsMostPowerfulDecorator_2.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n속성은 성능을 최적화하고 런타임을 줄이는 캐싱 메커니즘으로 사용할 수 있습니다. 이는 특히 속성의 계산이 자원을 많이 사용하고 결과가 자주 변하지 않는 시나리오에서 이점을 제공합니다.\n\n이전 세그먼트에서는 데이터셋 속성을 호출할 때마다 클래스가 디스크에서 데이터프레임을 로드하는 문제가 발생했습니다. 그러나 최초로 로드된 후 데이터셋을 캐시하기 위해 프라이빗 속성 _dataset을 추가함으로써 이를 완화할 수 있습니다.\n\n이 업데이트로 데이터셋이 처음 호출될 때 데이터는 한 번 파일에서 내부 _dataset 속성으로 로드됩니다. 데이터셋을 이후에 사용할 때는 간단히 메모리에서 데이터를 로드합니다.\n\n더 안전하게 하기 위해 file_path도 속성으로 변경할 수 있지만, 실제 사용 사례에 따라 달라집니다. 각 로더 인스턴스가 특정 파일 경로 또는 데이터셋에만 해당하도록 하려면 file_path를 읽기 전용으로 만들어야 합니다. 그렇지 않으면 파일 경로가 동적으로 변경될 수 있는 더 유연한 범용 데이터 로딩 클래스가 필요한 경우, 그대로 두면 됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n완전성을 위해 머신 러닝과 관련된 예제도 고려해 봅시다. 하이퍼파라미터를 갖지 않고 피쳐와 타겟 데이터셋을 입력으로 받아 모델을 훈련하는 간단한 머신 러닝 모델을 구축해 봅시다. 아래 구현은 두 가지 속성을 갖고 있습니다: trained는 모델이 훈련되었는지 여부를 나타내며 model_parameters는 훈련 후에 모델 파라미터를 \"캐싱\"하여 덮어쓰기 방지 기능을 제공합니다.\n\n여기서는 trained 상태와 모델 파라미터를 읽기 전용 속성으로 변환하기 위해 속성을 사용하고 있습니다. 이 접근 방식을 통해 모델의 훈련 여부를 쉽게 확인하고, 훈련된 파라미터를 검색할 수 있습니다.\n\n요약하자면: 자원 집약적인 계산 결과를 캐싱함으로써, 속성은 불필요한 계산을 피하고 코드 실행 효율성을 향상시켜줍니다. 특히 속성의 결과가 자주 변경되지 않을 때 특히 유용합니다. 예시로는 대규모 데이터셋부터 ML 모델 파라미터까지 다양한 경우가 있습니다.\n\n# 3. 자주 사용되는 속성의 동적 계산\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![그림](/TIL/assets/img/2024-07-13-PythonsMostPowerfulDecorator_3.png)\n\n속성은 동적 계산에 사용될 수 있으며, 속성 값의 계산을 실시간으로 가능하게 합니다. 특히 속성 값이 다른 속성이나 외부 요인에 의존하는 경우에 유용합니다. 다음과 같은 간단하고 흔한 예제를 고려해보세요:\n\n면적(area) 및 둘레(circumference) 속성은 현재 반지름 속성의 값에 기초하여 면적 및 둘레를 동적으로 계산합니다. 이는 속성이 계산을 속성 내부에 캡슐화할 수 있도록 하여, 추가적인 메서드를 정의하고 실행한 다음 출력을 변수에 할당하지 않아도 되게 합니다.\n\n데이터 처리 문맥에서 더 실용적인 예제는 다음과 같이 설명됩니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 예에서 DataProcessor 클래스는 팬더스 DataFrame을 입력으로 받아 \"계산\"에 대한 속성을 제공합니다. 동적 계산을 위해 속성을 사용하면 데이터에 대한 정보를 수동으로 매번 계산할 필요 없이 쉽게 가져올 수 있습니다. 이는 특히 대규모 데이터셋을 처리하거나 반복적인 계산을 수행할 때 시간과 노력을 절약하는 데 도움이 됩니다.\n\n계산이 비용이 많이 드는 경우 해당 계산을 변수에 캐싱하여 속성에 대한 긴 액세스 시간을 방지하는 것이 좋습니다. 반면에 계산 결과가 많고 많은 메모리를 차지할 경우, 해당 결과를 속성에 보유하면 불필요한 메모리 오버로드를 유발할 수 있으므로 캐싱할 내용에 대해 주의해야 합니다.\n\n요약하면: 속성을 사용하여 계산을 속성 내에 캡슐화하면 다른 속성이나 외부 요인을 기반으로 값의 동적 계산이 가능해지며 별도의 메서드를 연쇄적으로 실행하고 결과를 변수에 할당할 필요가 없어집니다.\n\n# 4. Setter와 결합하여 새 값 할당의 유효성 검사하기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](/TIL/assets/img/2024-07-13-PythonsMostPowerfulDecorator_4.png)\n\n속성 데코레이터를 추가하여 속성을 읽기 전용으로 만드는 이유는 변수에 getter 메서드를 도입하고 setter 메서드를 도입하지 않기 때문입니다. 따라서 해당 속성은 새 값으로 \"설정\"될 수 없습니다. 그러나 단순히 @`속성`.setter를 추가함으로써 변수에 setter 메서드를 도입할 수 있으며, 이를 통해 속성에 새 값 할당 전에 추가 코드(예: 정상성 검사 또는 다른 수동 개입)를 실행할 수 있습니다.\n\n@property와 @`속성`.setter의 조합은 Python에서 속성의 값 설정 시 사용자 지정 유효성 검사를 가능하게 하는 강력한 기능을 제공합니다. 이 조합을 활용하면 속성에 할당되는 데이터가 유효하고 적절한 데이터만 할당되도록 한 클래스의 견고성과 신뢰성을 향상시킬 수 있습니다. 이렇게하면 코드베이스의 전반적인 무결성이 향상되며 잠재적인 버그나 잘못된 데이터가 속성에 할당되는 것을 방지할 수 있습니다. 다음 예제를 확인해보세요:\n\nscaling_factor 속성은 이제 setter 메서드가 정의되어 있기 때문에 더 이상 읽기 전용이 아닙니다. 그러나 긍정적인 측면은 이제 속성에 할당하기 전에 체크를 수행하여 새 값을 유효한지 확인할 수 있다는 것입니다. 예를 들어, 여기서 스케일 요인에 할당된 값을 항상 양수인지 확인하는 것을 보여드리겠습니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위 예제에서 확인할 수 있듯이, 유효하지 않은 (0 또는 음수) 값을 할당하려고 하면 ValueError가 발생합니다. 이는 클래스 속성에 문제가 있는 값을 실수로 할당하여 발생하는 오류를 찾는 데 매우 유용할 수 있습니다.\n\n요약하자면: 게터와 세터를 최대한 활용하면 클래스를 더 견고하고 임의의 값이 아닌 에러에 덜 민감하게 만드는 데 매우 강력할 수 있습니다. 또한 이를 사용하여 값뿐만 아니라 데이터 유형인지도 확인할 수 있습니다.\n\n# 5. 무거운 속성들의 지연로딩 및 메모리 최적화\n\n![image](/TIL/assets/img/2024-07-13-PythonsMostPowerfulDecorator_5.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n속성은 클래스 내에서 메모리 집중형 에셋 및 속성을 게으르게 로드할 수 있는 방법을 제공하여, 필요한 시점까지 미루는 것을 가능하게 합니다. 이 기능은 방대한 데이터 세트나 자원 집약적인 작업을 다룰 때 특히 유용합니다. 이러한 자원들을 실제로 필요한 시점까지 로드를 미룸으로써, 시스템의 전반적인 성능과 효율성을 크게 향상시킬 수 있습니다. 게으르게 로딩을 통해 오직 필요한 자원만 필요한 시점에 메모리에 로드되므로, 불필요한 오버헤드를 줄일 수 있어 메모리를 절약하고 자원 할당을 최적화할 수 있습니다.\n\n저희는 이미 이를 섹션 2의 예제에서 수동으로 구현했습니다. 데이터는 DataLoader 클래스에 초기화 시 로딩되는 것이 아니라 데이터셋 속성에 처음 접근할 때 로드됩니다. 캐싱을 위해 우리는 비공개 속성 _dataset을 정의하고 None으로 인스턴스화하고, 처음으로 접근할 때 이 데이터를로드하도록했습니다. 너무 많은 단계처럼 들립니다. functools 라이브러리는 @property 대신 @cached_property 데코레이터를 사용하여 모든 보일러플레이트 코드를 간단히 없애는 편리한 방법을 제공합니다. 예시를 보겠습니다:\n\n훨씬 깔끔하죠! 누구나 보일러플레이트 코드를 좋아하지 않아요.\n\n게으르게 로드되는 속성들은 데이터 클래스를 보다 메모리 효율적으로 만들 수 있습니다. Python에서 메모리 효율적인 클래스를 작성하는 다른 방법에 대해 자세히 알아보려면 이 글을 확인해보세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n요약하자면: 속성의 게으른 로딩 활용은 성능 향상, 리소스 사용 최적화 및 코드의 전반적 효율성 향상 이점을 제공합니다. @cached_property 데코레이터를 사용하여 이를 쉽게 달성할 수 있습니다.\n\n오늘은 속성에 대해 많은 것을 배웠습니다 (또는 저처럼 느린 독자라면 여러 날 동안). 파이썬의 속성은 설명자의 기본 개념을 기반으로 한 clean하고 유연한 방식으로 클래스에서 속성 액세스를 관리합니다. 속성은 코드 가독성을 향상시키며 변수 보호, 동적 계산, 유효성 검사, 캐싱 및 게으른 로딩을 위한 다양한 기능을 제공합니다. 데이터 과학 및 머신 러닝에서 파이썬 개발을 계속하면 속성 습득이 확실히 프로그래밍 도구 상 중요한 기술이 될 것입니다.\n\n자 이제 멋진 것을 만들어 보고 그것에 대해 여기나 LinkedIn에서 저에게 알려주세요!","ogImage":{"url":"/TIL/assets/img/2024-07-13-PythonsMostPowerfulDecorator_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-PythonsMostPowerfulDecorator_0.png","tag":["Tech"],"readingTime":13},{"title":"파이썬으로 랜덤 포레스트 직접 구현하는 방법","description":"","date":"2024-07-13 20:17","slug":"2024-07-13-BuildingaRandomForestbyHandinPython","content":"\n\n![Building a Random Forest by Hand in Python](/TIL/assets/img/2024-07-13-BuildingaRandomForestbyHandinPython_0.png)\n\n약물 발견에서 종 분류, 신용 점수 매기기, 사이버 보안 등 랜덤 포레스트는 복잡한 세상을 모델링하는 인기 있고 강력한 알고리즘입니다. 그 다양성과 예측 능력은 첨단 복잡성을 필요로 할 것 같지만, 랜덤 포레스트가 실제로 무엇인지 파헤쳐보면 놀랍게 간단한 일련의 반복 단계들로 이뤄져 있습니다.\n\n저는 무엇인가를 배우는 가장 좋은 방법은 그것과 놀아보는 것이라고 생각합니다. 그러므로 랜덤 포레스트가 어떻게 작동하는지 직관을 얻기 위해 Python으로 직접 포레스트를 만들어 봅시다. 의사 결정 트리에서 시작하여 완전한 포레스트로 확장해보겠습니다. 우리는 분류와 회귀 모두에 대해 이 알고리즘이 얼마나 유연하고 해석 가능한지 직접 확인할 것입니다. 이 프로젝트가 복잡해 들리더라도 실제로 우리가 배워야 할 핵심 개념은 1) 데이터를 순차적으로 분할하는 방법, 2) 데이터가 얼마나 잘 분할되었는지를 어떻게 정량화 하는가 입니다.\n\n# 배경\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 의사 결정 트리 추론\n\n의사 결정 트리는 피처를 레이블과 매핑하는 이진 규칙 집합을 식별하는 지도 학습 알고리즘입니다. 로지스틱 회귀와 같은 알고리즘과 달리 출력이 방정식인 것이 아니라 의사 결정 트리 알고리즘은 비모수적이므로 피처와 레이블 간의 관계에 강한 가정을 하지 않습니다. 이는 의사 결정 트리가 훈련 데이터를 최적으로 분할하는 방식으로 자유롭게 성장할 수 있기 때문에 결과적인 구조가 데이터 집합에 따라 다양하다는 것을 의미합니다.\n\n의사 결정 트리의 주요 장점 중 하나는 해석 가능성입니다. 분류를 위해 카테고리를 예측하는 트리가나 회귀를 위해 연속 값을 예측하는 각 단계는 트리 노드에서 확인할 수 있습니다. 예를 들어, 온라인에서 본 제품을 구매할지 예측하는 모델은 다음과 같이 보일 수 있습니다.\n\n![의사 결정 트리](/TIL/assets/img/2024-07-13-BuildingaRandomForestbyHandinPython_1.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n루트부터 시작하여, 트리의 각 노드는 이진 질문을 하며 (예: \"세션 길이가 5분보다 길었습니까?\"), 답변에 따라 피처 벡터를 두 개의 자식 노드 중 하나로 전달합니다. 자식 노드가 없는 경우 - 즉, 리프 노드에 도달한 경우 - 트리는 응답을 반환합니다.\n\n![image](/TIL/assets/img/2024-07-13-BuildingaRandomForestbyHandinPython_2.png)\n\n(이 블로그 포스트에서는 분류에 초점을 맞추겠지만, 의사 결정 트리 회귀기는 순차적 값이 아닌 클래스 레이블이 아닌 연속 값을 반환하게 됩니다.)\n\n## 의사 결정 트리 학습\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n유추 또는 이 예측 프로세스는 꽤 간단합니다. 그러나 이 트리를 구축하는 것은 훨씬 명백하지 않습니다. 각 노드의 이진 규칙은 어떻게 결정되는 걸까요? 트리에 사용되는 특성들은 무엇이며, 어떤 순서로 사용되는 걸까요? 0.5 또는 1과 같은 임계값은 어떻게 결정되는 걸까요?\n\n의사 결정 트리가 어떻게 구축되는지 이해하기 위해, 우리가 모양(사각형과 삼각형)의 대형 데이터 세트를 특징에 기반하여 사각형만 또는 삼각형만 포함하는 작은 데이터 세트로 분할하려고 한다고 상상해 봅시다. 이상적인 경우에는 모양을 완벽하게 분리하는 몇몇 범주형 특성이 있습니다.\n\n하지만 항상 그렇게 간단하지는 않습니다. 행운이 따르면, 대신 모양을 완벽하게 분리하는 어떤 임계값을 가진 연속적인 특성이 있을 수도 있습니다. 정확한 임계값을 찾기 위해 몇 번의 시도가 필요하지만, 그런 다음 완벽한 분할이 이루어집니다. (휴!)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![이미지](/TIL/assets/img/2024-07-13-BuildingaRandomForestbyHandinPython_4.png)\n\n그렇게 간단하지는 않죠. 이 장난감 예제에서는 모든 삼각형과 사각형이 동일하기 때문에 그들의 특성 벡터를 분리하는 것이 쉬워요. (하나의 삼각형에 대해 작동하는 규칙이 모든 삼각형에 적용됩니다!)\n\n하지만 실제 세상에서는 특성이 레이블로 깔끔하게 매핑되지 않습니다. 전자 상거래 예제로 돌아가서, 세션에서 사이트에 보낸 시간과 같은 특성은 어떤 임계값에서도 클래스를 완벽하게 분할하지 못할 수도 있어요.\n\n![이미지](/TIL/assets/img/2024-07-13-BuildingaRandomForestbyHandinPython_5.png)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 어떤 임계값에서도 데이터를 완벽하게 분리할 수 있는 특성이 없다면 어떻게 해야 할까요? 이 경우, 레이블 집합이 얼마나 \"혼합된\"지를 측정하는 방법이 필요합니다. 일반적으로 사용하는 지표 중 하나가 지니 불순도인데, 다음 식으로 계산됩니다:\n\n\nGini = 1 - Σ(pk)^2\n\n\n여기서 pk는 우리의 m개 클래스 중 하나에 속할 확률입니다. 제곱과 1의 합이 1이 되어야 하므로, 두 가지 클래스인 사각형과 삼각형의 경우, 이 식을 pk로 정의할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 p✓, 집합에서 양성 레이블을 무작위로 선택할 확률에 따른 지니 불순도의 시각적 표현입니다. [1] (우리는 pk를 p✓로 대체하여 확인 표지가 양성 클래스임을 나타냈습니다.) 집합의 요소가 모두 확인 표지가 아닌 경우(즉, x인 경우) 또는 모두 확인 표지인 경우에 지니 불순도가 가장 낮습니다. 지니 불순도는 x와 확인 표지가 같은 수 일 때 최대치에 도달합니다.\n\n![image](/TIL/assets/img/2024-07-13-BuildingaRandomForestbyHandinPython_8.png)\n\n그렇기 때문에 클래스를 분할하기 위해 규칙을 식별할 때, 우리는 단순히 각 하위 집합의 가중치를 고려해 지니 불순도를 최소화하는 분할을 선택할 수 있습니다. (각 하위 집합은 고유의 불순도를 가지고 있으므로 각 하위 집합의 샘플 수로 가중 평균을 취합니다.) 주어진 특성에 대해, 해당 특성의 모든 가능한 값으로 데이터를 분할하고, 하위 집합의 가중치가 적용된 지니 불순도를 기록한 다음, 가장 낮은 불순도를 초래한 특성 값을 선택할 수 있습니다.\n\n아래에서, 계정 연령 특성을 35일을 기준으로 분할하면, 제품을 구매하는 사용자와 구매하지 않는 사용자를 가장 잘 분리할 수 있습니다 (상상의 데이터셋에서).\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/TIL/assets/img/2024-07-13-BuildingaRandomForestbyHandinPython_9.png)\n\n우리는 모든 특성에 대해 이 과정을 반복하고, 최적 분할 결과 지니 불순도가 가장 낮은 특성을 선택할 수 있습니다. 아래에서 세션 길이의 최적 분할이 계정 연령과 빈번한 쇼핑객에 대한 최적 분할보다 낮은 지니 불순도를 보여줍니다. 빈번한 쇼핑객은 이진 특성이므로 분할할 값이 하나뿐입니다.\n\n![이미지](/TIL/assets/img/2024-07-13-BuildingaRandomForestbyHandinPython_10.png)\n\n세션 길이에 대한 분할 ` 5분`이 우리 결정 트리에서 첫 번째 분기가 됩니다. 그런 다음 특성 및 값 반복 프로세스를 반복하고 각 부분집합, 그들의 하위 부분집합 등에 대해 데이터를 최적으로 분할하는 최상의 특성을 선택합니다. 이렇게 완벽하게 분할된 데이터가 필요하거나 트리가 허용된 최대 깊이에 도달할 때까지 진행합니다. (다음 섹션에서 자세히 설명하겠습니다.)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기에 앞서 본 트리가 나타난 것이지만 각 노드에 훈련 데이터가 표시되어 있습니다. 트리를 아래로 이동할수록 양성 및 음성 클래스가 점점 분리되는 것을 주목하세요. 트리의 맨 아래에 도달하면 잎 노드는 데이터 하위 집합에서의 과반 클래스를 출력합니다. (우리의 경우에는 유일한 클래스입니다.)\n\n![image](/TIL/assets/img/2024-07-13-BuildingaRandomForestbyHandinPython_11.png)\n\n## 랜덤 포레스트\n\n위의 결정 트리는 데이터를 하나의 클래스 레이블만 포함하도록 분할합니다 (즉, Gini 불순도 = 0). 이렇게 함으로써 모델이 훈련 데이터를 설명하는 능력을 최대화하지만, 모델을 데이터에 과적합할 위험이 있습니다. 모델이 모든 특징-레이블 조합을 외우는 것이 아니라 근본적인 패턴을 학습하는 대신에 기억하는 것처럼 생각해보세요. 과적합된 모델은 일반화하기 어렵고, 일반적으로 모델링의 목표인 새로운 데이터에 대한 일반화가 어려워집니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n과적합을 방지하는 몇 가지 방법이 있습니다. 한 가지 방법은 트리의 깊이를 제한하는 것입니다. 예를 들어 위의 트리를 두 레벨로 제한하면 왼쪽 가지를 자주 쇼핑 고객 분할에서 끝낼 수 있습니다.\n\n![image](/TIL/assets/img/2024-07-13-BuildingaRandomForestbyHandinPython_12.png)\n\n이제 왼쪽 가지의 잎 노드에는 자신들의 하위 집합에서 혼합된 레이블이 있습니다. 이 \"불순도\"를 허용하는 것은 비최적적으로 보일 수 있지만, 이는 잡음이 있는 피쳐에 대한 강력한 방어 수단입니다. 예를 들어, 훈련 데이터에서 Time idle과 Age of account가 우연히 예측력이 있었다면, 해당 피쳐를 제외한 모델이 새 데이터에 대해 일반화하는 데 더 좋을 것입니다.\n\n트리 깊이 제한은 효과적입니다. 하지만 더 강력한 전략과 함께 사용할 수 있습니다: 앙상블 학습. 머신러닝에서 - 그리고 동물 집단에서도 - 일련의 예측을 집계하면 종종 개별 예측보다 더 높은 정확도를 달성할 수 있습니다. 개별 모델의 오류가 상쇄되어 모델링되는 데이터의 기본 패턴을 더 명확하게 볼 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![Image](/TIL/assets/img/2024-07-13-BuildingaRandomForestbyHandinPython_13.png)\n\n이거 굉장히 좋은데, 전체 모델 예측에 변동이 있어야 앙상블이 유용해집니다. 지난 섹션에서 설명한 알고리즘 - 모든 피처의 모든 값에 대해 Gini 불순도가 가장 낮은 지점에서 분할 - 은 결정론적입니다. 주어진 데이터 세트에 대해 저희 알고리즘은 항상 동일한 의사결정 나무 [2]를 출력하므로, 앙상블로 10개 또는 100개의 트리를 학습시켜도 실제로 아무것도 이루지 못할 것입니다. 그렇다면 왜 숲이 단일 트리보다 나은가요?\n\n여기서 랜덤성이 등장합니다. 랜덤 포레스트 내의 트리들 사이에는 데이터 분할 방식 및 데이터 자체의 변화가 있어서 모델 예측에 변동이 생기고, 오버피팅에 대한 더 큰 방어 기능을 제공합니다.\n\n우선 데이터로 시작해보죠. 부스트랩을 사용하여 데이터를 샘플링하거나 대체로써 모델에 영향을 미치는 아웃라이어들이 무의미한 상관 관계를 가로채는 것을 방지할 수 있습니다. 아이디어는 아웃라이어가 희박하기 때문에 실제 피처와 레이블 간의 진짜 관계를 반영하는 샘플보다 덜 무작위로 선택될 가능성이 높다는 것입니다. 부스트랩을 사용하면 숲 내의 각 의사결정 트리에 약간 다른 데이터 세트를 제공할 수 있어서 여전히 동일한 일반적인 경향을 포함할 것입니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-BuildingaRandomForestbyHandinPython_14.png\" /\u003e\n\n두 번째 방법은 랜덤 포레스트가 데이터를 분할할 때 일부 기능의 임계값을 찾을 때 무작위로 기능의 서브셋만 선택한다는 것입니다. 예를 들어, scikit-learn의 RandomForestClassifier는 지니 불순도를 최소화하는 임계값을 찾을 때 기능 수의 제곱근만 고려합니다.\n\n이 방법들은 이상하게 보일 수 있습니다. 왜 우리가 모든 기능을 사용하지 않는 걸까요? 그리고 왜 의도적으로 데이터에서 행을 중복하거나 삭제할까요? 실제로, 이 방식으로 생성하는 각 개별 트리는 종종 보통의 결정 트리보다 예측 능력이 상당히 떨어집니다. 그러나 수십 개의 이러한 Swiss-cheese 트리를 집계하면 놀라운 결과가 나타납니다: 원래의 결정 트리보다 더 정확한 랜덤 포레스트가 형성됩니다.\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-BuildingaRandomForestbyHandinPython_15.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 구현\n\n이제 직접 Python에서 랜덤 포레스트를 구현해 봅시다. 트리의 노드부터 시작해서 의사 결정 트리, 마지막으로 랜덤 포레스트까지 구현해 보겠습니다.\n\n## 노드\n\n먼저, 의사 결정 트리에서 노드 역할을 하는 클래스를 만들어 봅시다. 이 클래스는 훈련에 사용되는 다음과 같은 속성을 가지고 있을 것입니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 데이터의 하위 집합(또는 루트 노드의 전체 데이터 세트)\n- 이 하위 집합의 양성 레이블 비율과 Gini 불순도\n- 왼쪽과 오른쪽 자식 노드를 가리키는 포인터(노드가 잎인 경우 None으로 설정)\n\n이 클래스는 새 데이터를 분류하는 데 사용되는 다음 속성도 갖추고 있습니다:\n\n- 입력을 왼쪽이나 오른쪽 자식 노드로 이동시키는 데 사용되는 특징 이름과 임계값(노드가 잎이 아닌 경우)\n- (노드가 잎일 경우) 반환할 레이블\n\n이러한 기준을 충족하는 Node 클래스를 아래 코드로 만들 수 있습니다. GitHub의 소스 코드에는 더 철저한 독스트링과 입력 유효성 검사가 포함되어 있지만, 가독성을 위해 여기서 간소화된 버전을 공유하겠습니다. 참고로 이 파일을 node.py로 명명하고 이후 파일에서 참조할 것입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\r\nimport numpy as np\nimport pandas as pd\nfrom typing_extensions import Self\n\nclass Node:\n    \"\"\"\n    의사 결정 트리의 노드입니다.\n    \"\"\"\n    def __init__(\n        self,\n        df: pd.DataFrame,\n        target_col: str\n    ) -\u003e None:\n        # 훈련용\n        self.df = df\n        self.target_col = target_col\n        self.pk = self._set_pk()\n        self.gini = self._set_gini()\n\n        # 훈련/추론용\n        self.left = None\n        self.right = None\n\n        # 추론용\n        self.feature = None\n        self.threshold = None\n\n    def _set_pk(self) -\u003e float:\n        \"\"\"\n        pk를 설정합니다. 양성 클래스인 샘플의 비율입니다.\n        샘플은 양성 클래스가 1이고 음성 클래스가 0인 int 배열로 가정합니다.\n        \"\"\"\n        return np.mean(self.df[self.target_col].values)\n\n    def _set_gini(self) -\u003e float:\n        \"\"\"\n        지니 불순도를 설정합니다.\n        \"\"\"\n        return 1 - self.pk**2 - (1 - self.pk)**2\r\n```\n\n현재까지 코드는 가벼운 내용입니다. 데이터프레임(df)과 레이블을 포함하는 열(target_col)을 지정하여 노드를 인스턴스화합니다. 좌측과 우측 자식 노드(self.left, self.right) 및 추론에 사용되는 feature 및 threshold 값을 가진 빈 속성을 생성합니다. 마지막으로, pk(타겟 열에서 1의 비율)와 _set_pk 및 _set_gini 메서드를 사용하여 Gini 불순도를 계산합니다.\n\n이제 기능을 추가하여 특정 feature의 값들을 반복하고 자식 노드에서 최소 지니 불순도를 최소화하는 임계값을 식별하는 논리를 추가해봅시다. split_on_feature 함수는 각 feature의 고유한 값에 대해 _process_split 도우미 함수를 실행합니다. 값 중에 null을 제거한 후 남은 값들이 있으면(잎 노드의 경우 목록이 비어있을 수 있음), 가장 낮은 불순도를 갖는 분할에 대한 Gini 불순도, feature 임계값, 좌우 자식 노드를 반환합니다.\n\n```js\r\nclass Node:\n    ...\n    def split_on_feature(\n        self,\n        feature: str\n    ) -\u003e tuple[float, int|float, Self, Self]:\n        \"\"\"\n        특정 feature의 값을 반복하고 자식 노드에서 가중 Gini 불순도를 최소화하는 분할을 식별합니다.\n        가중 Gini 불순도, feature 임계값, 좌우 자식 노드의 튜플을 반환합니다.\n        \"\"\"\n        values = []\n\n        for thresh in self.df[feature].unique():\n            values.append(self._process_split(feature, thresh))\n\n        values = [v for v in values if v[1] is not None]\n        if values:\n            return min(values, key=lambda x: x[0])\n        return None, None, None, None\r\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이것이 실제 작업을 수행하는 _process_split입니다. 우리는 self.df를 feature 임계값에 따라 분할하고, 어느 하위 데이터 세트가 비어 있는 경우 일찍 종료하며, 하위 데이터로 자식 노드를 생성하고, 마지막으로 가중 Gini 불순도를 계산합니다.\n\n```python\nclass Node:\n    ...\n    def _process_split(\n        self,\n        feature: str,\n        threshold: int|float\n    ) -\u003e tuple[float, int|float, Self|None, Self|None]:\n        \"\"\"\n        feature 임계값에 따라 데이터 프레임을 분할합니다. 가중 Gini 불순도를 반환하고, 입력된 임계값 및 자식 노드를 반환합니다.\n        분할 결과가 빈 하위 집합으로 이어지면 Gini 불순도와 None을 반환합니다.\n        \"\"\"\n        df_lower = self.df[self.df[feature] \u003c= threshold]\n        df_upper = self.df[self.df[feature] \u003e threshold]\n\n        # 임계값이 데이터를 전혀 분할하지 않을 경우 일찍 종료\n        if len(df_lower) == 0 or len(df_upper) == 0:\n            return self.gini, None, None, None\n\n        node_lower = Node(df_lower, self.target_col)\n        node_upper = Node(df_upper, self.target_col)\n\n        prop_lower = len(df_lower) / len(self.df)\n        prop_upper = len(df_upper) / len(self.df)\n\n        weighted_gini = node_lower.gini * prop_lower \\\n          + node_upper.gini * prop_upper\n\n        return weighted_gini, threshold, node_lower, node_upper\n```\n\n빠르게 테스트해 봅시다. 아래에서 노드를 인스턴스화하고 데이터에 대해 최적의 분할을 찾도록 합니다. split_on_feature는 자식 노드에서 0.0의 가중 Gini 불순도를 반환합니다. 왜냐하면 레이블을 완벽하게 값 2에서 분할할 수 있기 때문입니다. 세 번째 및 네 번째 값은 분할로 생성된 왼쪽 및 오른쪽 자식 노드입니다.\n\n```python\nimport pandas as pd\n\ndf = pd.DataFrame({'feature': [1, 2, 3], 'label': [0, 0, 1]})\nnode = Node(df, 'label')\n\nprint(f\"pk: {round(node.pk, 2)}, gini: {round(node.gini, 2)}\")\n# pk: 0.33, gini: 0.44\n\nprint(node.split_on_feature('feature'))\n# (0.0, 2,\n# \u003c__main__.Node object at 0x137c279d0\u003e,\n# \u003c__main__.Node object at 0x137c24160\u003e)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 의사 결정 트리\n\n다음 단계는 트레이닝 데이터를 가장 잘 분할하고 새로운 데이터를 가장 정확하게 분류하기 위해 노드를 트리에 배열하는 것입니다. 먼저 기본 구조부터 시작하여 분류기를 학습하고(즉, 트리를 구축하고) 예측을 생성할 수 있는 능력을 살펴봅시다. 우리는 decision_tree.py 파일을 node.py와 동일한 디렉토리에 저장하고 파일에서 Node를 가져옵니다.\n\n우리의 DecisionTree 클래스는 루트 노드로 시작하는데, 이는 df와 target_col로 인스턴스화하는 Node입니다. feature_select은 랜덤 포레스트의 트리를 트레이닝할 때 사용할 feature의 비율을 제어합니다. 기본 의사 결정 트리 클래스에서는 특성의 100%를 기본값으로 사용할 것입니다. max_depth는 트리가 성장할 수 있는 최대 깊이를 지정하는데, 이는 과적합을 방지하는 데 도움이 됩니다.\n\n```js\r\nimport numpy as np\nimport pandas as pd\n\nfrom .node import Node\n\nclass DecisionTree:\n    \"\"\"\n    의사 결정 트리 분류기, Node로 구성됨\n    \"\"\"\n    def __init__(\n        self,\n        df: pd.DataFrame,\n        target_col: str,\n        feature_select: float = 1.0,\n        max_depth: int = 4\n    ) -\u003e None:\n        self.root = Node(df, target_col)\n        self.features = list(df)\n        self.features.remove(target_col)\n        self.feature_select = feature_select\n        self.max_depth = max_depth\r\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 트리를 구축하는 논리를 작성해 봅시다. 코딩 면접뿐만 아니라 Leetcode에서 공부한 모든 것이 유용하다는 것을 증명하기 위해 스택을 사용하여 깊이 우선 탐색을 수행하고, 각 노드에서 _process_node를 반복적으로 호출하고 해당 노드의 자식을 스택에 추가합니다. 또한 현재 깊이를 확인하여 self.max_depth를 초과하지 않도록 확인합니다. 모든 노드를 처리한 후에는 DecisionTree 인스턴스를 반환합니다.\n\n```js\nclass DecisionTree:\n    ...\n    def build_tree(self) -\u003e None:\n        \"\"\"\n        깊이 우선 탐색을 사용하여 트리를 구축합니다.\n        \"\"\"\n        stack = [(self.root, 0)]\n        \n        while stack:\n            current_node, depth = stack.pop()\n            \n            if depth \u003c= self.max_depth:\n                left, right = self._process_node(current_node)\n                \n                if left and right:\n                    current_node.left = left\n                    current_node.right = right\n                    stack.append((right, depth+1))\n                    stack.append((left, depth+1))\n        \n        return self\n```\n\n_process_node에서 실제로 무엇이 발생할까요? 우리는 먼저 특징의 하위 집합을 무작위로 선택한 다음 (또는 self.feature_select가 1.0이면 모든 특징을 선택합니다), 해당 특징을 반복하여 노드의 split_on_feature 메소드를 호출하여 그 특징의 최적 분할을 찾습니다. 그런 다음 자식 노드에서 지니 불순도가 가장 낮아지는 특징을 찾아 현재 노드의 불순도와 비교합니다. 최적의 분할이 더 낮은 불순도를 유발한다면 자식 노드를 반환하고, 그렇지 않으면 순회를 중지해야 함을 나타내기 위해 None을 반환합니다.\n\n```js\nclass DecisionTree:\n    ...\n    def _process_node(\n        self,\n        node: Node\n    ) -\u003e tuple[Node|None, Node|None]:\n        \"\"\"\n        특징을 반복하여 자식 노드에서 지니 불순도를 최소화하는 분할을 식별하고\n        지니 불순도를 가장 많이 줄이는 특징을 식별한 후 해당 특징에 대해\n        분할된 자식 노드를 반환합니다.\n        \"\"\"\n        # 무작위로 특징을 선택합니다. self.feature_select = 1.0이면\n        # 무작위로 선택되지 않습니다 (기본값).\n        features = list(\n            np.random.choice(\n                self.features,\n                int(self.feature_select*len(self.features)),\n                replace=False\n            )\n        )\n\n        # 각 열에 대한 최상의 분할을 위한 지니 불순도 가져오기\n        d = {}\n        for col in features:\n            feature_info = node.split_on_feature(col)\n            if feature_info[0] is not None\n                d[col] = feature_info\n\n        # 분할할 최적의 열 선택하기\n        min_gini = np.inf\n        best_feature = None\n        for col, tup in d.items():\n            if tup[0] \u003c min_gini:\n                min_gini = tup[0]\n                best_feature = col\n\n        # 최상의 분할이 불순도를 줄이는 경우에만 업데이트\n        if min_gini \u003c node.gini:\n            # 노드 업데이트\n            node.feature = best_feature\n            node.threshold = d[col][1]\n            return d[col][2:]\n\n        return None, None\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 코드는 트리를 구축하는 데 사용됩니다. 이제 예측을 생성하는 코드를 작성해 봅시다. classify 함수는 _classify 도우미 함수를 감싸는 래퍼일 뿐이며 한 번에 하나씩이 아닌 피처 벡터의 데이터프레임에 대해 예측을 생성할 수 있도록 합니다. 실제 작업은 _classify에서 수행되는데, 이 함수는 피처 벡터가 노드의 임계값과 비교에 따라 왼쪽이나 오른쪽 자식 노드로 재귀적으로 이동합니다. 잎 노드는 피처와 임계값 속성이 모두 None이므로, 노드의 pk가 0.5보다 크면 1을 반환하고 그렇지 않으면 0을 반환합니다.\n\n```python\nclass DecisionTree:\n    ...\n    def classify(self, feature_df: pd.DataFrame) -\u003e list[int]:\n        \"\"\"\n        각 행이 피처 벡터인 데이터프레임이 주어졌을 때, 트리를 탐색하여 예측 레이블을 생성합니다.\n        \"\"\"\n        return [\n          self._classify(self.root, f) for i, f in feature_df.iterrows()\n        ]\n\n    def _classify(self, node: Node, features: pd.Series) -\u003e int:\n        \"\"\"\n        피처 벡터가 주어졌을 때, 노드의 자식을 탐색하여 잎에 도달할 때까지 이동한 후, 노드에서 가장 빈번한 클래스를 반환합니다.\n        긍정적인 레이블과 부정적인 레이블이 동일한 수일 경우, 부정 클래스를 예측합니다.\n        \"\"\"\n        # 자식 노드\n        if node.feature is None or node.threshold is None:\n            return int(node.pk \u003e 0.5)\n\n        if features[node.feature] \u003c node.threshold:\n            return self._classify(node.left, features)\n        return self._classify(node.right, features)\n```\n\n## Random Forest\n\n이제 결정 트리 분류기에 필요한 모든 것을 갖추었습니다! 가장 어려운 작업은 이미 모두 끝났습니다. 분류기를 랜덤 포레스트로 확장하는 것은 이미 _process_node에서 최소화된 피처 선택을 구현했기 때문에 부트스트랩된 데이터에 여러 개의 트리를 생성하는 것만 필요합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n랜덤 포레스트를 구현한 random_forest.py 파일을 만들어봅시다. 이 파일에는 RandomForest 클래스가 포함되어 있습니다. 항상처럼, 우리는 클래스를 데이터프레임(df)과 타깃 열로 초기화하고 DecisionTree 클래스와 마찬가지로 feature_select 및 max_depth 매개변수를 가지고 있습니다. 이제 추가로 n_trees 매개변수도 전달합니다.\n\nMarkdown 형식으로 테이블 태그를 변경하세요.\n\n```python\nimport pandas as pd\n\nfrom .decision_tree import DecisionTree\n\nclass RandomForest:\n    \"\"\"\n    다수의 의사 결정 트리로 구성된 포레스트.\n    \"\"\"\n    def __init__(\n        self,\n        df: pd.DataFrame,\n        target_col: str,\n        n_trees: int = 100,\n        feature_select: float = 0.5,\n        max_depth: int = 4\n    ) -\u003e None:\n        self.df = df\n        self.target_col = target_col\n        self.n_trees = n_trees\n        self.feature_select = feature_select\n        self.max_depth = max_depth\n        self.forest = []\n```\n\n학습은 간단합니다. 우리는 n_trees 개의 부트스트랩 데이터프레임을 생성하고, 각각에 대해 DecisionTree를 인스턴스화한 다음 각 의사 결정 트리를 훈련시키기 위해 .build_tree를 호출합니다.\n\n```python\nclass RandomForest:\n    ...\n    def train(self) -\u003e None:\n        \"\"\"\n        self.df에 대해 포레스트를 학습합니다.\n        \"\"\"\n        bootstrap_dfs = [self._bootstrap() for _ in range(self.n_trees)]\n        self.forest = [\n            DecisionTree(\n              bdf,\n              self.target_col,\n              self.feature_select,\n              self.max_depth\n            )\n            for bdf in bootstrap_dfs\n        ]\n        self.forest = [tree.build_tree() for tree in self.forest]\n        return None\n\n    def _bootstrap(self) -\u003e pd.DataFrame:\n        \"\"\"\n        self.df에서 복원 추출을 통해 행을 샘플링합니다.\n        \"\"\"\n        return self.df.sample(len(self.df), replace=True)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n분류 또한 간단합니다: 우리는 숲 속의 각 트리가 입력된 feature_df를 분류하고, 각 행에 대해 가장 일반적인 예측 레이블을 반환하도록 합니다. 이 작업을 하는 가장 쉬운 방법은 예측을 데이터프레임으로 변환한 다음, 최빈값을 취하는 것이었습니다.\n\n```python\nclass RandomForest\n    ...\n    def classify(self, feature_df: pd.DataFrame) -\u003e int:\n        \"\"\"\n        입력된 feature 벡터를 분류합니다. 숲 속의 각 트리는 예측 레이블을 생성하고,\n        각 feature 벡터에 대해 가장 일반적인 레이블이 반환됩니다.\n        \"\"\"\n        preds = pd.DataFrame(\n          [tree.classify(feature_df) for tree in self.forest]\n        )\n        # 가장 일반적인 예측 레이블 반환\n        return list(preds.mode().iloc[0])\n```\n\n그리고... 이게 전부입니다! run.py 스크립트를 실행하면 DecisionTree 분류기, RandomForest의 평균 트리, 전체 RandomForest, 그리고 scikit-learn의 RandomForestClassifier의 정확도를 비교할 수 있습니다. 결과는 데이터셋, 숲당 트리 수 등에 따라 다를 수 있지만, 우리가 한 결정 트리가 숲의 평균 트리보다 더 높은 정확도를 가지고 있고, 전체 랜덤 포레스트가 개별 트리보다 훨씬 강하다는 것을 볼 수 있습니다. 역시 scikit-learn이 가장 높은 정확도를 보여주죠... 하지만 우리도 나쁘지 않았습니다!\n\n```python\n정확도\n * 단일 의사결정 트리:   0.61\n * 평균 랜덤 포레스트 트리: 0.595\n * 전체 랜덤 포레스트:     0.81\n * scikit-learn 랜덤 포레스트:    0.89\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![img](/TIL/assets/img/2024-07-13-BuildingaRandomForestbyHandinPython_16.png)\n\n# 결론\n\n이 게시물에서는 랜덤 포레스트(Random Forest)라는 가장 인기 있고 강력한 머신 러닝 알고리즘 중 하나를 다루었습니다. 이론부터 시작하여 결정 트리가 데이터 세트를 분할하는 데 가장 적합한 기능 값을 식별하기 위해 Gini 불순도와 같은 지표를 사용하는 방법을 설명했습니다. 그리고 Gini 불순도를 가장 많이 감소시키는 최적 분할 기능을 반복적으로 식별하여 트리를 구축하는 방법을 보여주었습니다. 또한 무작위 특성 선택 및 부트스트랩 데이터 세트를 사용하여 수십 개의 결정 트리로 구성된 랜덤 포레스트를 구축하는 방법을 설명했습니다. 마지막으로 몇 가지 코드를 작성하여 해당 이론을 테스트했습니다.\n\n더 알고 싶다면 미니 프로젝트가 많이 있습니다. 동일한 기능이 대상 변수와 매우 비선형적인 관계를 가질 경우 트리에서 여러 번 사용될 수 있는 방법을 시각화해 볼 수 있습니다. 이 게시물에서 회귀에 대해 다루지 않았지만, 연속적인 대상을 처리할 수 있도록 코드를 수정하는 것은 그리 어렵지 않을 것입니다. 데이터 양과 열의 수에 따른 일반 DecisionTree, 평균 랜덤 포레스트 트리 및 전체 포레스트의 예측력이 어떻게 달라지는지 확인하는 것도 흥미로울 것입니다. 마지막으로, RandomForest가 어떻게 트리를 학습하는지를 병렬화하고 싶은 사람이 있다면 PR을 제출해 주시기 바랍니다. 😜\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n친절하게 읽어 주셔서 감사합니다!\nMatt\n\n# 1. 의사 결정 트리 훈련\n\n이 그림은 정말 마음을 쏙 들인 작품이었습니다. 곡선과 원들이 한 색에서 다른 색으로 전환되는 방법을 알아내는 것이 어려웠는데, 놀랍게도 가장 어려웠던 부분은 x와 체크 마크를 원 안에 깔끔하게 유지하면서 너무 많이 뭉쳐지지 않게 하는 것이었습니다. 이 그림의 아이콘과 색상을 너무 많이 바꿔서 결국 스크립트를 작성해서 생성하는 것으로 끝이 났죠.\n\n여기에는 장난감 예제(분할 모양)와 포스트의 주요 예제(전자 상거래)와 더 명확한 시각적 구분이 필요하다고 생각하기 전까지 일부 버전의 그림이 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-BuildingaRandomForestbyHandinPython_17.png\" /\u003e\n\n## 2. 랜덤 포레스트\n\n아래 코드를 사용하여 동일한 데이터 세트에 대해 sklearn이 동일한 결정 트리를 출력하는지 직접 확인할 수 있습니다. 랜덤 상태를 동일하게 지정해야한다는 점을 주의하세요.\n\n```js\nimport numpy as np\nimport pandas as pd\nfrom sklearn.tree import DecisionTreeClassifier\n\n# 매개변수\nrandom_state = 42\n\n# 데이터 생성\ndf = pd.DataFrame(\n    {\n        'feature_1': np.random.normal(0, 1, 100),\n        'feature_2': np.random.normal(1, 1, 100),\n        'label': np.random.choice([0, 1], 100)\n    }\n)\n\nmod1 = DecisionTreeClassifier(random_state=random_state)\nmod1.fit(df[['feature_1', 'feature_2']], df['label'])\n\nmod2 = DecisionTreeClassifier(random_state=42)\nmod2.fit(df[['feature_1', 'feature_2']], df['label'])\n\ncomparison = (mod1.tree_.value == mod2.tree_.value)\nprint(comparison.all())\n# True\n```","ogImage":{"url":"/TIL/assets/img/2024-07-13-BuildingaRandomForestbyHandinPython_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-BuildingaRandomForestbyHandinPython_0.png","tag":["Tech"],"readingTime":26}],"page":"7","totalPageCount":34,"totalPageGroupCount":2,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"7"},"buildId":"GnJ8pEcO5t2Vzpus740Q5","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>