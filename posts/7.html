<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>TIL</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//posts/7" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="TIL" data-gatsby-head="true"/><meta property="og:title" content="TIL" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//posts/7" data-gatsby-head="true"/><meta name="twitter:title" content="TIL" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/7978fe7362f7d4c9.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/7978fe7362f7d4c9.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/873-eb138c3217d71553.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/posts/%5Bpage%5D-de1dc5579188f9be.js" defer=""></script><script src="/TIL/_next/static/o6AmBAY_j9v9JmbaRA39X/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/o6AmBAY_j9v9JmbaRA39X/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Next.js 15에서 데이터 fetch하는 방법" href="/TIL/post/2025-04-22-Howtofetchdataandstream"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15에서 데이터 fetch하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15에서 데이터 fetch하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15에서 데이터 fetch하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">11 hours ago</span><span class="PostList_reading_time__6CBMQ">17<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="2025년 ReactJS와 Next.js에서 CSS를 가장 쉽게 사용하는 방법" href="/TIL/post/2025-04-22-HowtouseCSSinyourapplication"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="2025년 ReactJS와 Next.js에서 CSS를 가장 쉽게 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="2025년 ReactJS와 Next.js에서 CSS를 가장 쉽게 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">2025년 ReactJS와 Next.js에서 CSS를 가장 쉽게 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">11 hours ago</span><span class="PostList_reading_time__6CBMQ">25<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nextjs 15에서 이미지와 폰트 최적화하는 방법" href="/TIL/post/2025-04-22-Howtooptimizeimagesandfonts"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nextjs 15에서 이미지와 폰트 최적화하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nextjs 15에서 이미지와 폰트 최적화하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Nextjs 15에서 이미지와 폰트 최적화하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">11 hours ago</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js 15에서 레이아웃과 페이지 쉽게 만드는 방법" href="/TIL/post/2025-04-22-Howtocreatelayoutsandpages"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15에서 레이아웃과 페이지 쉽게 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15에서 레이아웃과 페이지 쉽게 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15에서 레이아웃과 페이지 쉽게 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">11 hours ago</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js 15 프로젝트 폴더 설계 방법" href="/TIL/post/2025-04-22-Projectstructureandorganization"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15 프로젝트 폴더 설계 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15 프로젝트 폴더 설계 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15 프로젝트 폴더 설계 방법</strong><div class="PostList_meta__VCFLX"><span class="date">11 hours ago</span><span class="PostList_reading_time__6CBMQ">20<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js 14 2025년 최신 프로젝트 세팅 방법 완벽 가이드" href="/TIL/post/2025-04-22-HowtosetupanewNextjsproject"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 14 2025년 최신 프로젝트 세팅 방법 완벽 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 14 2025년 최신 프로젝트 세팅 방법 완벽 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 14 2025년 최신 프로젝트 세팅 방법 완벽 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">11 hours ago</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="linear-gradient를 활용한 border 애니메이션 5가지 만들기" href="/TIL/post/2025-04-22-border-animation"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="linear-gradient를 활용한 border 애니메이션 5가지 만들기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="https://source.unsplash.com/random/?programming"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="linear-gradient를 활용한 border 애니메이션 5가지 만들기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">linear-gradient를 활용한 border 애니메이션 5가지 만들기</strong><div class="PostList_meta__VCFLX"><span class="date">12 hours ago</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="미디어 쿼리 vs. 컨테이너 쿼리 차이점 비교" href="/TIL/post/2025-04-20-containerquery-mediaquery"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="미디어 쿼리 vs. 컨테이너 쿼리 차이점 비교" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2025-04-20-containerquery-mediaquery.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="미디어 쿼리 vs. 컨테이너 쿼리 차이점 비교" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">미디어 쿼리 vs. 컨테이너 쿼리 차이점 비교</strong><div class="PostList_meta__VCFLX"><span class="date">Apr 20, 2025</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="CSS :has() 선택자 사용 방법 정리" href="/TIL/post/2025-04-20-css-has-selector"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="CSS :has() 선택자 사용 방법 정리" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2025-04-20-css-has-selector.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="CSS :has() 선택자 사용 방법 정리" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">CSS :has() 선택자 사용 방법 정리</strong><div class="PostList_meta__VCFLX"><span class="date">Apr 20, 2025</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Vite에서 SVG 사용하는 두 가지 방법 (React + TypeScript 기준)" href="/TIL/post/2025-04-18-vite-svg"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Vite에서 SVG 사용하는 두 가지 방법 (React + TypeScript 기준)" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-15-TechStackForProduction-ReadyLLMApplicationsIn2024_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Vite에서 SVG 사용하는 두 가지 방법 (React + TypeScript 기준)" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Vite에서 SVG 사용하는 두 가지 방법 (React + TypeScript 기준)</strong><div class="PostList_meta__VCFLX"><span class="date">Apr 18, 2025</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/TIL/posts/1">1</a><a class="link" href="/TIL/posts/2">2</a><a class="link" href="/TIL/posts/3">3</a><a class="link" href="/TIL/posts/4">4</a><a class="link" href="/TIL/posts/5">5</a><a class="link" href="/TIL/posts/6">6</a><a class="link posts_-active__YVJEi" href="/TIL/posts/7">7</a><a class="link" href="/TIL/posts/8">8</a><a class="link" href="/TIL/posts/9">9</a><a class="link" href="/TIL/posts/10">10</a><a class="link" href="/TIL/posts/11">11</a><a class="link" href="/TIL/posts/12">12</a><a class="link" href="/TIL/posts/13">13</a><a class="link" href="/TIL/posts/14">14</a><a class="link" href="/TIL/posts/15">15</a><a class="link" href="/TIL/posts/16">16</a><a class="link" href="/TIL/posts/17">17</a><a class="link" href="/TIL/posts/18">18</a><a class="link" href="/TIL/posts/19">19</a><a class="link" href="/TIL/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Next.js 15에서 데이터 fetch하는 방법","description":"","date":"2025-04-22 01:13","slug":"2025-04-22-Howtofetchdataandstream","content":"\n# 데이터 가져오기와 스트리밍하는 방법\n\n이번 글에서는 Next.js 같은 환경에서 서버 컴포넌트와 클라이언트 컴포넌트에서 데이터를 가져오는 방법을 알려드릴게요. 그리고 데이터를 기반으로 콘텐츠를 스트리밍하는 방법도 같이 살펴볼 거예요.\n\n## 데이터 가져오기\n\n### 서버 컴포넌트에서 데이터 가져오기\n\n서버 컴포넌트(Server Components)는 서버에서 실행되기 때문에 데이터를 바로 fetch해서 렌더링할 수 있어요. 클라이언트에게는 이미 준비된 결과만 내려주기 때문에 성능도 좋고 보안상 이점도 있죠.\n\n예를 들어, 이렇게 사용할 수 있어요:\n\n```jsx\n// ServerComponent.jsx\nasync function ServerComponent() {\n  const res = await fetch(\"https://api.example.com/data\");\n  const data = await res.json();\n\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003e서버에서 가져온 데이터\u003c/h1\u003e\n      \u003cp\u003e{data.message}\u003c/p\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default ServerComponent;\n```\n\n서버 컴포넌트는 기본적으로 비동기 함수(async function)로 만들 수 있어서, 데이터를 기다렸다가 렌더링하는 것에 전혀 무리가 없답니다.\n\n---\n\n추가 팁!\n\n- fetch를 쓸 때는 캐싱과 관련된 옵션을 꼭 확인하세요. 예를 들어 Next.js에서는 `fetch('url', { next: { revalidate: 60 }})` 처럼 60초마다 다시 가져오게 설정할 수 있어요.\n- 만약 API 호출이 오래 걸리는 경우, React 18 스트리밍 기능과 함께 쓰면 사용자에게 더 빠른 피드백을 줄 수 있어요. 이 부분도 곧 설명할게요!\n\n다음으로, 클라이언트 컴포넌트에서 데이터 가져오는 법과 스트리밍하는 예시를 이어서 다뤄볼게요.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n서버 컴포넌트(Server Components)에서 데이터를 가져올 때는 주로 이렇게 두 가지 방법을 사용해요:\n\n- fetch API 활용하기\n- ORM이나 데이터베이스 직접 호출하기\n\n#### fetch API 사용법\n\nfetch API를 쓰려면 컴포넌트를 비동기 함수(async function)로 만들고, fetch 호출 앞에 await를 붙여서 데이터를 받아오면 돼요. 예시를 살펴볼게요:\n\n```jsx\n// 비동기 함수로 만든 서버 컴포넌트 예시\nexport default async function UserProfile() {\n  const res = await fetch(\"https://api.example.com/user\");\n\n  // 서버 컴포넌트에서 fetch할 때는 기본적으로 캐싱이 되는데,\n  // 필요에 따라 cache 옵션을 조절할 수 있어요.\n  // 예: await fetch(url, { cache: 'no-store' }) // 매번 새로 불러오기\n\n  if (!res.ok) {\n    // 에러 처리도 서버 컴포넌트 내에서 할 수 있답니다.\n    throw new Error(\"사용자 정보를 가져오는데 실패했습니다.\");\n  }\n\n  const user = await res.json();\n\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003e{user.name}님 안녕하세요!\u003c/h1\u003e\n      \u003cp\u003e이메일: {user.email}\u003c/p\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n\u003e 여기서 중요한 팁! Server Components는 클라이언트와 달리 fetch API를 사용할 때 네트워크 요청이 서버에서 처리되기 때문에 API 키 같은 민감한 정보도 안전하게 다룰 수 있어요.\n\n다음 번에는 ORM이나 데이터베이스 직접 호출 방법도 같이 정리해볼게요! 컴포넌트에서 데이터 가져오는 게 이제 좀 감 잡히셨죠?\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번에는 React의 Server Component에서 데이터 가져오는 방법에 대해 살펴보려고 해요. 특히 fetch API를 사용하거나 ORM을 통해 데이터베이스에서 직접 데이터를 불러오는 예제를 함께 보여드릴게요.\n\n먼저, `fetch`를 사용해서 외부 API에서 블로그 글 목록을 가져오는 아주 기본적인 예제입니다.\n\n```jsx\nexport default async function Page() {\n  const data = await fetch(\"https://api.vercel.app/blog\");\n  const posts = await data.json();\n\n  return (\n    \u003cul\u003e\n      {posts.map((post) =\u003e (\n        \u003cli key={post.id}\u003e{post.title}\u003c/li\u003e\n      ))}\n    \u003c/ul\u003e\n  );\n}\n```\n\n서버 컴포넌트는 서버에서 렌더링되기 때문에 async 함수로 만들고 `await`로 데이터를 받아올 수 있는 게 큰 장점이에요. 이렇게 하면 클라이언트에서 별도로 데이터를 가져오는 로직을 짤 필요가 없고, 초기 렌더링 시점에 바로 데이터를 사용할 수 있죠.\n\n---\n\n그리고 조금 더 고급 예제로, ORM이나 직접 데이터베이스 클라이언트를 사용해서 데이터베이스 쿼리를 하는 방법도 있는데요. 예를 들어, Prisma나 Drizzle ORM 같이 JavaScript/TypeScript에서 많이 사용하는 ORM을 쓸 때도 동일한 패턴입니다.\n\n```jsx\nimport { db, posts } from \"@/lib/db\";\n\nexport default async function Page() {\n  const allPosts = await db.select().from(posts);\n\n  return (\n    \u003cul\u003e\n      {allPosts.map((post) =\u003e (\n        \u003cli key={post.id}\u003e{post.title}\u003c/li\u003e\n      ))}\n    \u003c/ul\u003e\n  );\n}\n```\n\n이 경우 `db.select().from(posts)` 같은 쿼리문을 `await` 해서 서버에서 바로 데이터베이스를 조회하고, 그 결과를 UI로 바로 뿌려줄 수 있어요.\n\n---\n\n### 여기서 몇 가지 더 알려드릴 팁!\n\n- **서버 컴포넌트와 클라이언트 컴포넌트의 역할 분리!**  \n  서버 컴포넌트는 데이터를 불러오고, 클라이언트 컴포넌트는 사용자 상호작용(UI 이벤트 등)을 담당하는 식으로 분리하면 앱 구조가 더 깔끔해져요.\n\n- **fetch 캐싱 전략**  \n  `fetch` 호출할 때 `cache: 'no-store'` 옵션을 넣으면 항상 최신 데이터를 받아올 수 있고, 반대로 캐싱 옵션을 활용하면 퍼포먼스를 높일 수도 있어요.\n\n- **환경변수 사용하기**  \n  데이터베이스 연결이나 API 호출 시 민감한 정보(API 키 등)는 .env 파일에 숨기는 게 안전해요.\n\n---\n\n이번 글에서는 React 서버 컴포넌트 내에서 외부 API, ORM으로 데이터 가져오는 기본적인 방법을 정리해보았는데요. 실제 프로젝트에서 서버 사이드 렌더링을 하거나 Next.js와 같은 프레임워크를 사용할 때 꼭 알아두면 유용한 패턴이에요. 편하게 데이터를 다루고 싶을 때 async/await와 서버 컴포넌트를 적극 활용해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 클라이언트 컴포넌트에서 데이터 가져오기\n\n클라이언트 컴포넌트에서 데이터를 가져오는 방법은 크게 두 가지가 있어요.\n\n- React의 `use` 훅 사용하기\n- SWR, React Query 같은 커뮤니티 라이브러리 활용하기\n\n#### 1. React `use` 훅 사용하기\n\nReact 18부터 도입된 `use` 훅을 사용하면 데이터 패칭을 조금 더 간결하게 할 수 있어요. 이 훅은 비동기 함수에서 데이터를 받아와서 컴포넌트가 렌더링되기 전에 데이터 로딩을 처리해주죠.\n\n예를 들면 이렇게 사용할 수 있어요:\n\n```jsx\n\"use client\";\n\nimport { use } from \"react\";\n\nasync function fetchUser() {\n  const res = await fetch(\"/api/user\");\n  if (!res.ok) throw new Error(\"Failed to fetch user\");\n  return res.json();\n}\n\nexport default function UserComponent() {\n  const user = use(fetchUser());\n\n  return \u003cdiv\u003eHello, {user.name}!\u003c/div\u003e;\n}\n```\n\n`use` 훅은 서버 컴포넌트에서는 바로 사용할 수 없고 클라이언트 컴포넌트에서만 지원되니 참고하세요!\n\n#### 2. SWR, React Query 같은 라이브러리 이용하기\n\n`use` 훅이 꽤 편리하지만, 상태 관리, 캐싱, 리페치 같은 점에서 기능이 부족할 때는 SWR이나 React Query가 많이 쓰여요.\n\n이들 라이브러리는 다음과 같은 이점이 있어요:\n\n| 장점                  | 설명                                                         |\n| --------------------- | ------------------------------------------------------------ |\n| 자동 캐싱             | 이전에 가져온 데이터를 캐시해서 빠르게 보여줘요.             |\n| 배경 리페치           | 데이터를 최신 상태로 유지하기 위해 자동으로 재요청해요.      |\n| 로딩과 에러 상태 처리 | 로딩 중인 상태나 에러를 쉽게 관리할 수 있어요.               |\n| 폴링과 리프레시       | 정기적으로 데이터를 갱신하거나 수동으로 새로고침이 가능해요. |\n\n예를 들어 SWR을 쓰면 이렇게 간단하게 데이터를 가져올 수 있죠:\n\n```jsx\n\"use client\";\n\nimport useSWR from \"swr\";\n\nconst fetcher = (url) =\u003e fetch(url).then((res) =\u003e res.json());\n\nexport default function UserComponent() {\n  const { data, error } = useSWR(\"/api/user\", fetcher);\n\n  if (error) return \u003cdiv\u003e에러 발생!\u003c/div\u003e;\n  if (!data) return \u003cdiv\u003e로딩 중...\u003c/div\u003e;\n\n  return \u003cdiv\u003eHello, {data.name}!\u003c/div\u003e;\n}\n```\n\nReact Query 역시 비슷한 방식으로 동작하고, 복잡한 데이터 동기화 문제를 쉽게 해결할 수 있어서 대규모 프로젝트에 많이 사용돼요.\n\n---\n\n데이터를 어떻게 패칭할지는 프로젝트 규모와 요구사항에 따라 선택하면 좋아요. 간단한 경우에는 React `use` 훅만으로도 충분하지만, 상태 관리가 복잡하거나 다양한 기능을 원한다면 SWR이나 React Query를 한 번 써보시길 추천해요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nReact의 새로운 use hook을 활용해서 서버에서 클라이언트로 데이터를 스트리밍하는 방법을 소개할게요. 이걸 쓰면 데이터를 미리 기다리지 않고도 렌더링을 시작할 수 있어서 사용자 경험이 더 좋아져요.\n\n먼저, 서버 컴포넌트에서 데이터를 가져오고, 그 Promise를 클라이언트 컴포넌트에 props로 넘겨줍니다:\n\n```jsx\nimport Posts from \"@/app/ui/posts\";\nimport { Suspense } from \"react\";\n\nexport default function Page() {\n  // 데이터 fetching 함수 호출, 여기서 await는 하지 않아요\n  const posts = getPosts();\n\n  return (\n    \u003cSuspense fallback={\u003cdiv\u003eLoading...\u003c/div\u003e}\u003e\n      \u003cPosts posts={posts} /\u003e\n    \u003c/Suspense\u003e\n  );\n}\n```\n\n여기서 중요한 점! getPosts() 의 Promise를 바로 넘겨주는 거예요. 아직 데이터가 준비되지 않았어도, Suspense로 감싸고 있기 때문에 로딩 UI가 보였다가 데이터가 준비되면 실제 내용이 렌더링됩니다.\n\n그 다음, 클라이언트 컴포넌트에선 `use` hook을 이용해서 Promise를 읽을 수 있어요:\n\n```jsx\n\"use client\";\nimport { use } from \"react\";\n\nexport default function Posts({ posts }: { posts: Promise\u003c{ id: string, title: string }[]\u003e }) {\n  // Promise가 끝날 때까지 기다렸다가 결과를 가져옵니다\n  const allPosts = use(posts);\n\n  return (\n    \u003cul\u003e\n      {allPosts.map((post) =\u003e (\n        \u003cli key={post.id}\u003e{post.title}\u003c/li\u003e\n      ))}\n    \u003c/ul\u003e\n  );\n}\n```\n\n이 방법의 장점은 서버 컴포넌트에서 데이터를 바로 넘겨주기 때문에 클라이언트에서 fetch 코드를 따로 작성할 필요가 없고, Suspense와 함께 쓰면 자연스럽게 로딩 상태도 처리할 수 있다는 점이에요.\n\n\u003e 참고로 `use` hook은 React 18에서 도입된 기능이고 Next.js 13 같은 최신 프레임워크와 아주 잘 맞아요. 만약 여러분이 Next.js 같은 환경에서 작업한다면 적극 활용해보세요!\n\n요약하자면:\n\n| 단계                   | 설명                                            |\n| ---------------------- | ----------------------------------------------- |\n| 1. 서버 컴포넌트       | 데이터를 fetching하고 Promise를 props로 넘기기  |\n| 2. 클라이언트 컴포넌트 | `use` hook으로 Promise 처리해서 데이터 사용하기 |\n| 3. Suspense 적용       | 로딩 UI 관리해서 UX 향상                        |\n\n이렇게 하면 fetch로 데이터를 직접 기다리지 않고도 부드러운 렌더링과 데이터 스트리밍 효과를 낼 수 있답니다. 한번 써보면 React의 새로운 가능성에 감탄하게 될 거예요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위 예제에서 `Posts /` 컴포넌트를 `Suspense` 경계로 감싸줘야 합니다. 이렇게 하면 데이터 로딩 중일 때 fallback UI가 보여지면서 Promise가 해결될 때까지 기다릴 수 있어요. 스트리밍에 대해 더 알고 싶다면 실제 React 공식 문서나 관련 자료를 참고해보세요.\n\n---\n\n### 커뮤니티 라이브러리 활용하기\n\nReact에서 클라이언트 컴포넌트 내 데이터를 가져올 때는 SWR이나 React Query 같은 커뮤니티 라이브러리를 많이 사용합니다. 이 라이브러리들은 캐싱, 스트리밍, 갱신 정책 등 다양한 기능을 제공해서 데이터 패칭을 훨씬 편리하게 만들어줘요.\n\n예를 들어 SWR을 사용한 코드는 다음과 같습니다:\n\n```js\n\"use client\";\nimport useSWR from \"swr\";\n\nconst fetcher = (url) =\u003e fetch(url).then((r) =\u003e r.json());\n\nexport default function BlogPage() {\n  const { data, error, isLoading } = useSWR(\"https://api.vercel.app/blog\", fetcher);\n\n  if (isLoading) return \u003cdiv\u003eLoading...\u003c/div\u003e;\n  if (error) return \u003cdiv\u003eError: {error.message}\u003c/div\u003e;\n\n  return (\n    \u003cul\u003e\n      {data.map((post: { id: string, title: string }) =\u003e (\n        \u003cli key={post.id}\u003e{post.title}\u003c/li\u003e\n      ))}\n    \u003c/ul\u003e\n  );\n}\n```\n\n- 여기서 `useSWR`은 데이터를 쉽게 가져오고 자동으로 캐싱해주며, 필요하면 재요청도 해줍니다.\n- `isLoading`, `error` 상태도 관리해줘서 로딩중이나 에러가 났을 때 사용자에게 알기 쉽게 UI를 보여줄 수 있어요.\n- `Suspense`를 직접 쓰는 대신 SWR이 내부적으로 비슷한 원리(loading 상태 관리)를 처리해준다고 생각하면 편합니다.\n\n---\n\n이 밖에도 React Query는 더 많은 기능과 옵션을 제공하니, 프로젝트 성격에 맞게 골라 써보시면 좋겠죠? 데이터를 클라이언트에서 관리할 때 편리한 도구들이 많으니 적극 활용해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 스트리밍 (Streaming)\n\n\u003e 주의: 아래 내용은 Next.js 15 카나리 버전에서 도입된 dynamicIO 설정 옵션이 활성화되어 있다고 가정한 설명입니다.\n\n서버 컴포넌트(Server Components)에서 async/await를 사용할 때, Next.js는 자동으로 동적 렌더링(dynamic rendering)을 선택하게 돼요. 즉, 매번 사용자 요청이 들어올 때마다 서버에서 데이터를 가져오고 렌더링을 한다는 뜻이죠. 여기서 문제가 되는 점은, 만약 데이터 요청이 느리다면 그 경로 전체가 렌더링 되지 않고 기다리게 된다는 거예요.\n\n이런 상황에서 사용자 경험과 초기 로딩 속도를 개선하기 위해 스트리밍(Streaming)을 사용할 수 있습니다. 스트리밍은 페이지의 HTML 내용을 작고 여러 개의 청크(chunk)로 나누고, 그 청크들을 서버에서 클라이언트로 점진적으로 보내는 방식을 말합니다. 이렇게 하면 사용자에게는 빠르게 일부 콘텐츠가 먼저 보이고, 나머지도 순차적으로 로딩되어 부드러운 경험을 제공할 수 있죠.\n\n---\n\n### 추가 팁: 스트리밍 적용 시 주의할 점\n\n- **콘텐츠 순서 보장**  \n  스트리밍은 HTML을 나누어 보내지만, 클라이언트는 리소스를 받는 순서대로 렌더링해요. 그래서 서버에서 청크를 보내는 순서를 적절히 관리하는 게 중요합니다.\n\n- **상태(state) 관리**  \n  서버에서 각 청크가 독립적으로 렌더링되므로, 상태 관리에 신경 써야 해요. React의 서버 컴포넌트 특성상 상태를 클라이언트와 분리해서 다뤄야 할 때도 있습니다.\n\n- **SEO 영향 고려**  \n  스트리밍은 SEO에도 긍정적입니다. 초기 콘텐츠를 빠르게 보여주기 때문에 검색엔진 크롤러가 콘텐츠를 더 잘 인식할 수 있어요.\n\n---\n\n스트리밍 덕분에 사용자들은 느린 데이터 로딩으로 인한 기다림이 줄어들고, 동시에 서버 자원을 효율적으로 사용할 수 있게 됩니다. Next.js의 스트리밍 기능, 꼭 활용해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2025-04-22-Howtofetchdataandstream_0.png\" /\u003e\n\n애플리케이션에서 스트리밍(streaming)을 구현하는 방법은 크게 두 가지가 있어요:\n\n- `loading.js` 파일을 활용하는 방법\n- React의 `Suspense` 컴포넌트를 사용하는 방법\n\n### loading.js를 활용한 방법\n\nloading.js 파일을 이용하면 컴포넌트가 로딩 중일 때 보여줄 UI를 간단히 처리할 수 있는데요, 이것만 잘 활용해도 로딩 상태 관리가 훨씬 깔끔해집니다. React 18 이후로 서버 컴포넌트를 지원하면서 이 방식이 점점 많이 쓰이고 있죠.\n\n다음에 React `Suspense` 컴포넌트를 활용하는 방법도 한번 살펴볼게요.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여러분, Next.js에서 페이지 데이터를 가져올 때 로딩 상태를 어떻게 더 잘 보여줄 수 있을까요? 바로 `loading.js` 파일을 활용하는 방법입니다!\n\n예를 들어, `app/blog/page.js` 파일과 같은 폴더(`app/blog`)에 `loading.js` 파일을 만들어주면, 페이지 데이터를 가져오는 동안 사용자가 기다리는 모습을 좀 더 깔끔하게 보여줄 수 있어요.\n\n```js\nexport default function Loading() {\n  // 여기서 로딩 화면 UI를 정의해주면 됩니다\n  return \u003cdiv\u003eLoading...\u003c/div\u003e;\n}\n```\n\n이렇게 하면 사용자가 페이지로 이동할 때, 화면은 즉시 레이아웃과 이 로딩 UI를 보여주고, 데이터가 모두 준비되면 자동으로 실제 콘텐츠로 바뀌어요.\n\n참고로, 이런 방식이 좋은 이유는 “빈 화면”이나 갑작스러운 깜빡임 없이 자연스럽게 사용자 경험이 이어진다는 점이에요. 실제로 프로젝트에 적용할 때는 단순 텍스트 대신 스피너 애니메이션이나 뼈대 UI(Skeleton UI)를 넣어주면 더 효과적이랍니다.\n\n아래는 예시 이미지인데, 이런 식으로 로딩 중인 상태를 좀 더 친절하게 보여줄 수 있어요.\n\n| ![로딩 화면 예시](https://yourdomain.com/assets/img/2025-04-22-Howtofetchdataandstream_1.png) |\n| --------------------------------------------------------------------------------------------- |\n\n나중에 `loading.js`에서 다양한 로딩 상태 구현을 고민해보면서, 사용자 경험을 한층 업그레이드 해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2025-04-22-Howtofetchdataandstream_2.png\" /\u003e\n\n뒤에서 보면, `loading.js`는 `layout.js` 내부에 중첩되어 자동으로 `page.js` 파일과 그 아래 자식들을 `Suspense` 경계로 감싸게 돼요.\n\n\u003cimg src=\"/TIL/assets/img/2025-04-22-Howtofetchdataandstream_3.png\" /\u003e\n\n이 방식은 라우트 세그먼트(레이아웃과 페이지)에 잘 맞지만, 더 세밀한 스트리밍이 필요하다면 직접 `Suspense`를 활용하는 게 좋아요.\n\n---\n\n여기서 잠깐! `Suspense`를 사용하면 리액트에서 비동기 데이터를 로딩하는 동안 그 자리를 대체하는 로딩 UI를 보여줄 수 있다는 점이 정말 편해요. 특히 Next.js 13처럼 서버 컴포넌트가 도입된 환경에서는 `loading.js` 같은 파일로 페이지 단위 로딩 처리를 자동으로 해주니까 개발이 훨씬 수월해지죠.\n\n하지만, 한 단계 더 들어가서 페이지 일부만 따로 로딩하고 싶을 때(예를 들어, 큰 리스트 아이템 중 일부만 먼저 보여주고, 나머지는 천천히 로딩하고 싶을 때) `Suspense`를 직접 사용하는 것이 필요해집니다.\n\n즉,\n\n- `loading.js` + `layout.js` = 페이지 단위 자동 로딩 UI 처리\n- `Suspense` = 하위 컴포넌트 단위 세밀한 로딩 UI 제어\n\n이 두 가지를 적절하게 조합해 사용하는 게 개발 생산성을 높이는 좋은 팁이에요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### `Suspense`를 활용한 부분적 스트리밍\n\n`Suspense`는 페이지의 특정 부분만 스트리밍할 수 있게 해줘서, 사용자 경험을 더 부드럽고 빠르게 만들어주는데요. 예를 들어, 전체 페이지 중에서 `Suspense` 경계 밖에 있는 내용은 바로 보여주고, 경계 안에 있는 블로그 목록 같은 무거운 컴포넌트만 나중에 스트리밍해서 로드할 수 있어요.\n\n아래 예제를 보면, 제목과 인사말은 즉시 렌더링되고, 블로그 목록은 `Suspense` 안에서 비동기로 불러와집니다. 로딩 중일 때는 `BlogListSkeleton` 컴포넌트가 대신 보여지겠죠?\n\n```jsx\nimport { Suspense } from \"react\";\nimport BlogList from \"@/components/BlogList\";\nimport BlogListSkeleton from \"@/components/BlogListSkeleton\";\n\nexport default function BlogPage() {\n  return (\n    \u003cdiv\u003e\n      {/* 이 부분은 즉시 클라이언트에게 전송됩니다 */}\n      \u003cheader\u003e\n        \u003ch1\u003eWelcome to the Blog\u003c/h1\u003e\n        \u003cp\u003eRead the latest posts below.\u003c/p\u003e\n      \u003c/header\u003e\n      \u003cmain\u003e\n        {/* Suspense 경계 안의 컴포넌트는 스트리밍 되어 로드됩니다 */}\n        \u003cSuspense fallback={\u003cBlogListSkeleton /\u003e}\u003e\n          \u003cBlogList /\u003e\n        \u003c/Suspense\u003e\n      \u003c/main\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n### 의미 있는 로딩 상태 만들기\n\n`Suspense`를 사용하면 단순히 \"로딩 중\" 텍스트만 보여주는 대신, 실제 콘텐츠 형태를 모방한 스켈레톤 UI를 보여줄 수 있는데요. 이는 사용자에게 페이지가 정말로 반응하고 있다는 느낌을 잘 줍니다. 예를 들어 블로그 목록이라면 개별 목록 아이템이 빈 카드처럼 보이는 스켈레톤 화면을 만드는 거죠.\n\n이런 UX 테크닉을 적용하면, 페이지가 로딩될 때 사용자가 느끼는 대기시간이 훨씬 짧고 부드러워 보여 실제 체감 성능이 높아집니다.\n\n더불어, `Suspense`를 적절히 활용하면 데이터가 준비되는 순서에 따라 UI를 부분별로 제어할 수 있어서, 복잡한 페이지도 단계적으로 로드할 수 있다는 점!\n\n요약하자면,\n\n- 초기 콘텐츠는 지체 없이 보여주기\n- 데이터를 불러오는 부분은 `Suspense`와 fallback UI로 감싸기\n- 스켈레톤 UI 등 의미 있는 로딩 화면 제공하기\n\n이렇게만 해도 사용자 경험은 대폭 개선될 거예요! 😊\n\n필요하다면 Suspense의 fallback 컴포넌트를 직접 커스터마이징해서 브랜드 느낌이나 스타일을 살리는 것도 추천드려요.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n즉시 로딩 상태란, 사용자가 페이지를 이동한 직후 바로 보여주는 대체 UI를 의미해요. 이게 왜 중요하냐면, 사용자가 앱이 반응하고 있다는 걸 바로 알 수 있게 해줘서 불안감을 줄이고 더 나은 사용자 경험을 제공할 수 있기 때문이죠.\n\n가장 좋은 방법은 단순히 로딩 중이라는 표시만 보여주는 게 아니라, 의미 있는 로딩 상태를 디자인하는 거예요. 예를 들어, 뼈대 화면(skeleton)을 보여준다거나, 돌아가는 스피너(spinner)를 사용하는 게 대표적이고요. 좀 더 나아가서는 다음에 보여질 화면의 핵심 요소, 예를 들어 커버 사진이나 제목 같은 작은 부분을 먼저 보여주면 훨씬 자연스러운 느낌을 줄 수 있습니다.\n\n개발 중에는 React Devtools를 활용하면 컴포넌트의 로딩 상태를 미리 보고, 어떻게 동작하는지 자세하게 확인할 수 있어요. 덕분에 사용자에게 완성도 높은 로딩 UI를 더 쉽게 만들 수 있답니다.\n\n간단히 정리해볼게요.\n\n| 팁                    | 설명                                                        |\n| --------------------- | ----------------------------------------------------------- |\n| 즉시 로딩 상태        | 네비게이션 후 바로 보여지는 대체 UI                         |\n| 의미 있는 로딩 디자인 | 스켈레톤, 스피너, 다음 화면 일부 요소(제목, 이미지 등) 활용 |\n| 개발 시 활용 도구     | React Devtools로 로딩 상태 미리보기 및 검사                 |\n\n이런 방식으로 사용자에게 앱이 멈추지 않고 잘 작동 중임을 자연스럽게 알릴 수 있어요. 여러분도 한 번 적용해보세요!\n","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":17},{"title":"2025년 ReactJS와 Next.js에서 CSS를 가장 쉽게 사용하는 방법","description":"","date":"2025-04-22 01:08","slug":"2025-04-22-HowtouseCSSinyourapplication","content":"\n\n# 애플리케이션에서 CSS 사용법 알아보기\n\nNext.js에서는 CSS를 사용하는 여러 가지 방법을 제공하는데요, 대표적으로 다음과 같은 방식들이 있어요:\n\n- CSS 모듈(CSS Modules)\n- 글로벌 CSS(Global CSS)\n- Tailwind CSS\n- Sass\n- CSS-in-JS\n- 외부 스타일시트(External Stylesheets)\n\n이 글에서는 각각의 방법을 어떻게 사용하는지 차근차근 알려드릴게요. 앞으로 여러분 프로젝트에 어떤 방식이 가장 잘 맞을지 선택하는 데 도움이 되길 바랍니다!  \n\n다양한 스타일링 옵션을 활용하면 코드 관리도 쉽고, 유지보수도 편해지니까 꼭 익혀두세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## CSS Modules\n\nCSS Modules는 CSS 클래스 이름을 고유하게 만들어서, 같은 이름의 클래스를 여러 파일에서 마음껏 사용할 수 있게 도와주는 방법이에요. 덕분에 클래스 이름 충돌 걱정 없이 스타일을 관리할 수 있죠.\n\n사용 방법도 간단해요! 스타일 파일을 `.module.css` 확장자로 만들고, 이걸 필요한 컴포넌트에서 import하기만 하면 돼요. 예를 들어:\n\n```css\n/* blog.module.css */\n.blog {\n  padding: 24px;\n}\n```\n\n그리고 컴포넌트에서는 이렇게 불러와서 사용하면 돼요:\n\n```jsx\nimport styles from './blog.module.css';\n\nfunction Blog() {\n  return \u003cdiv className={styles.blog}\u003e안녕하세요, 블로그입니다!\u003c/div\u003e;\n}\n```\n\n여기서 중요한 점! 일반 CSS 파일과는 달리, CSS Modules에서는 클래스를 사용할 때 항상 import한 `styles` 객체를 통해 접근해 주어야 해요. 이렇게 하면 자동으로 클래스 이름이 고유한 문자열로 변환돼서, 다른 컴포넌트의 같은 클래스 이름과 충돌하지 않도록 막아줍니다.\n\n그리고 혹시 CSS Modules가 조금 낯설게 느껴질 수도 있지만, 최근에는 React를 비롯한 여러 프론트엔드 프레임워크에서 기본 지원하거나 쉽게 설정할 수 있어서 많이 쓰이는 추세에요. 특히 프로젝트가 커질수록 스타일 관리가 훨씬 편해지니, 개인 프로젝트나 회사 프로젝트 모두에서 강력 추천합니다!\n\n덧붙여서, CSS Modules는 전역 네임스페이스 오염 없이 컴포넌트 단위 스타일링이 가능해서, 스타일을 쓰면서 발생하는 버그도 줄여준답니다. 다른 방법으로는 styled-components 같은 CSS-in-JS도 있으니, 용도와 선호도에 따라 선택하면 좋아요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport styles from './styles.module.css'\n\nexport default function Page({ children }: { children: React.ReactNode }) {\n  return \u003cmain className={styles.blog}\u003e{children}\u003c/main\u003e\n}\n```\n\n## 글로벌 CSS(Global CSS)\n\n애플리케이션 전체에 스타일을 적용하고 싶을 때는 글로벌 CSS를 사용하면 편리해요.\n\n예를 들어, `app/global.css` 파일을 만들어서 스타일을 작성하고, 이 파일을 루트 레이아웃(root layout) 파일에 import 하면 애플리케이션의 모든 경로(route)에 글로벌 스타일이 적용돼요.\n\n```css\n/* app/global.css 예시 */\nbody {\n  margin: 0;\n  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n  background-color: #f9f9f9;\n  color: #333;\n}\n```\n\n그리고 루트 레이아웃 파일에서는 이렇게 import 해주세요.\n\n```js\nimport './global.css';\n\nexport default function RootLayout({ children }) {\n  return (\n    \u003chtml\u003e\n      \u003cbody\u003e{children}\u003c/body\u003e\n    \u003c/html\u003e\n  );\n}\n```\n\n\u003e 참고로, 글로벌 CSS는 보통 전체적인 기본 스타일(Reset, 폰트, 배경 등)을 적용할 때 사용하고, 각 컴포넌트별 스타일은 CSS 모듈이나 styled-components 같은 방식을 병행해 쓰는 게 유지보수에 좋아요.\n\n추가로 Next.js에서는 글로벌 CSS가 한 번만 import 되어야 하니, 루트 레이아웃이나 앱 컴포넌트에 넣는 걸 추천합니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번에는 Next.js에서 글로벌 스타일과 Tailwind CSS에 대해 간단히 살펴볼게요.\n\n우선, CSS에서 `body` 태그에 아래와 같은 스타일을 적용한 예시가 있어요:\n\n```css\nbody {\n  padding: 20px 20px 60px;\n  max-width: 680px;\n  margin: 0 auto;\n}\n```\n\n이 스타일은 `body`에 패딩을 줘서 콘텐츠 주변에 공간을 만들고, 최대 너비를 680px로 제한해주고, 좌우 여백은 자동으로 가운데 정렬하는 역할을 하죠.\n\n그리고 Next.js 앱에서는 이렇게 글로벌 CSS를 가져와서 모든 페이지에 적용할 수 있어요:\n\n```tsx\n// 이 파일은 루트 레이아웃 컴포넌트입니다.\n// 전체 앱에 글로벌 스타일이 적용되도록 설정해요.\nimport './global.css'\n \nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    \u003chtml lang=\"en\"\u003e\n      \u003cbody\u003e{children}\u003c/body\u003e\n    \u003c/html\u003e\n  )\n}\n```\n\n여기서 `import './global.css'` 부분이 바로 앱 전체에 영향을 주는 글로벌 스타일을 불러오는 부분입니다.\n\n### 알아두면 좋은 점\nNext.js는 React의 스타일 시트 지원 기능과 Suspense를 활용해서 스타일 관리를 하는데요, 문제가 되는 부분은 \"라우트 간 이동 시 스타일 시트가 자동으로 제거되지 않아 충돌(conflicts)이 날 수 있다\"는 거예요.\n\n그래서 권장하는 방법은,\n\n- 정말 앱 전체에 적용되어야 하는 스타일만 글로벌 CSS로 작성하세요.\n- 페이지별, 컴포넌트별로 독립된 스타일이 필요하다면 CSS 모듈(CSS Modules)을 사용하세요.\n\n이렇게 하면 스타일 충돌을 막을 수 있고 관리도 더 쉬워집니다.\n\n---\n\n## Tailwind CSS 이야기\n\n그럼 Tailwind CSS는 어떻게 Next.js와 쓰일까요? Tailwind CSS는 유틸리티 클래스 기반 CSS 프레임워크로, 복잡한 CSS를 손쉽게 작성할 수 있게 도와줘요.\n\n예를 들어, 위에서 했던 `body` 스타일을 Tailwind로 표현하고 싶다면, 다음과 같이 할 수 있죠:\n\n```tsx\n\u003cbody className=\"p-5 pb-15 max-w-xl mx-auto\"\u003e\n  {children}\n\u003c/body\u003e\n```\n\n- `p-5`는 padding 20px (Tailwind 기본 spacing scale에서 대략 1.25rem) 정도를 줍니다.\n- `pb-15`은 padding-bottom 60px 정도를 줘요.\n- `max-w-xl` 은 최대 너비 약 680px에 해당합니다.\n- `mx-auto`는 좌우 마진 자동으로 가운데 정렬을 의미합니다.\n\nTailwind를 활용하면 CSS 파일을 따로 관리하지 않아도 되고, 클래스만 잘 조합해서 손쉽게 반응형 및 스타일 변화를 줄 수 있죠.\n\n---\n\n### 참고\nTailwind CSS도 Next.js에서 쉽게 통합할 수 있으니 관심 있으면 더 자세히 알려드릴게요!  \n그리고 CSS Modules와 같이 쓰면 좀 더 컴포넌트 단위로 깔끔한 스타일링도 가능합니다.\n\n---\n\n요약하자면,\n\n| 내용                      | 설명                                        |\n|-------------------------|-------------------------------------------|\n| 글로벌 CSS              | 앱 전체에 적용되는 기본 스타일, 충돌 주의 필요          |\n| CSS Modules             | 컴포넌트별 국소 스타일링, 충돌 적음                   |\n| Tailwind CSS            | 유틸리티 클래스 기반, 빠른 스타일링 가능               |\n\n필요에 따라 적절한 방법을 골라서 쓰면 되겠습니다!\n\n다음에는 Tailwind CSS 설정법과 활용 팁을 공유할게요. 질문 있으면 부담 없이 알려주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nTailwind CSS는 Next.js와 찰떡같이 잘 어울리는 유틸리티 퍼스트(Utility-First) CSS 프레임워크에요. 쉽게 말해, 미리 만들어진 클래스를 조합해서 빠르고 효율적으로 스타일을 입힐 수 있죠.\n\n### Tailwind 설치하기\n\nTailwind를 바로 써보고 싶다면, 아래 명령어로 필요한 패키지들을 설치하세요:\n\n```bash\nnpm install tailwindcss @tailwindcss/postcss postcss\n```\n\n여기서 `tailwindcss`는 본체이고, `@tailwindcss/postcss`랑 `postcss`는 Tailwind 스타일을 빌드할 때 필요한 도구들이에요. Next.js 프로젝트에서 스타일링할 때 필수라고 생각하면 됩니다.\n\n참고로, 요즘 Next.js 최신 버전에서는 위 패키지 설치 후에 `npx tailwindcss init`으로 설정 파일을 생성해서 Tailwind 설정을 좀 더 커스터마이징할 수 있어요. 스타일을 내가 원하는 대로 바꾸고 싶다면 꼭 해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### Tailwind 설정하기\n\n프로젝트 루트에 `postcss.config.mjs` 파일을 만들어서 PostCSS 설정에 `@tailwindcss/postcss` 플러그인을 추가해보세요! 간단한 설정 하나로 Tailwind CSS의 모든 유틸리티 클래스를 마음껏 사용할 수 있게 됩니다.\n\n예를 들면, `postcss.config.mjs` 파일에 아래처럼 설정을 추가할 수 있어요:\n\n```js\n/** @type {import('tailwindcss').Config} */\nexport default {\n  plugins: {\n    '@tailwindcss/postcss': {},\n  },\n}\n```\n\n\u003e 참고로 Tailwind 설정 파일은 `tailwind.config.js` 혹은 `tailwind.config.mjs`로 따로 만들어져 있어야 합니다. 만약 아직 없다면 기본 설정부터 만들어 놓는 걸 추천드려요. 잘 설정해두면 테마, 색상, 폰트 등 자유롭게 커스터마이징하기도 훨씬 수월합니다.\n\n### Tailwind 사용하기\n\nTailwind를 프로젝트에 제대로 설정했다면, HTML이나 JSX 파일에서 바로 클래스명을 쓰기만 하면 돼요!\n\n```html\n\u003cbutton class=\"bg-blue-500 text-white font-bold py-2 px-4 rounded\"\u003e\n  클릭해봐요!\n\u003c/button\u003e\n```\n\n이렇게 쓰면 버튼에 파란 배경, 하얀 글자, 굵은 글꼴, 약간의 패딩과 둥근 모서리가 한 번에 적용됩니다. 기존 CSS 작성하느라 헷갈릴 필요 없이, 클래스 이름으로 직관적인 스타일링 가능!\n\n\u003e 팁 하나 더! 개발 중에 변경사항이 잘 반영되지 않으면, PostCSS 빌드 프로세스를 재시작하거나 캐시를 지우는 것도 한번 시도해보세요. Tailwind는 JIT(Just-In-Time) 컴파일 기능 덕분에 빠르게 스타일을 적용할 수 있지만 간혹 환경마다 캐시 문제로 반영이 늦을 수 있거든요.\n\n필요한 만큼 쉽고 빠르게 스타일을 적용할 수 있으니 꼭 한번 써보세요! Tailwind는 커뮤니티도 활발해서 다양한 플러그인과 자료들이 많답니다. 앞으로도 더 재미있는 Tailwind 팁들 공유할게요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nTailwind CSS를 Next.js 프로젝트에 적용하려면, 먼저 글로벌 스타일시트에 Tailwind 지시어를 추가해야 해요. 이렇게 하면 Tailwind의 기본 스타일과 유틸리티 클래스들이 전역에서 적용됩니다.\n\n```css\n@import 'tailwindcss';\n```\n\n위 코드를 `globals.css` 같은 전역 스타일 파일에 넣어주세요.\n\n그리고 Next.js 프로젝트의 최상위 레이아웃 파일에서 이 스타일시트를 불러와야 해요. 보통 `app/layout.tsx`나 `app/layout.js`에 아래처럼 `globals.css`를 임포트합니다:\n\n```tsx\nimport type { Metadata } from 'next';\n// 이 스타일들은 애플리케이션의 모든 라우트에 적용됩니다.\nimport './globals.css';\n\nexport const metadata: Metadata = {\n  title: 'Create Next App',\n  description: 'Generated by create next app',\n};\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    \u003chtml lang=\"en\"\u003e\n      \u003cbody\u003e{children}\u003c/body\u003e\n    \u003c/html\u003e\n  );\n}\n```\n\n---\n\n### 조금 더 알아보기\n- 이 `@import 'tailwindcss';`는 Tailwind가 필요한 기본 스타일과 유틸리티 클래스를 불러오는 역할을 해요.\n- 만약 더 세부적으로 `@tailwind base;`, `@tailwind components;`, `@tailwind utilities;` 같은 지시어를 커스텀 스타일시트에 넣는 경우도 있는데, 기본적으로 `@import 'tailwindcss';` 하나로 필요한 부분을 다 가져와요.\n- 그리고 글로벌 스타일을 한 번 적용하면, 각 페이지 컴포넌트에서는 따로 스타일을 임포트할 필요가 없어서 편리하답니다.\n- Tailwind를 제대로 적용했는지 확인하려면, 애플리케이션을 실행 후 개발자 도구에서 클래스들이 잘 붙는지 보고, Tailwind 유틸리티 클래스를 적용해 스타일이 변하는지 테스트해보세요!\n\n이제 Tailwind 스타일이 Next.js 프로젝트 전체에 적용됐으니, 마음껏 유틸리티 클래스를 활용해서 빠르게 스타일링해 보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그럼 이제부터 여러분이 개발하는 애플리케이션에 Tailwind의 유틸리티 클래스를 본격적으로 적용할 수 있어요.\n\n```js\nexport default function Page() {\n  return \u003ch1 className=\"text-3xl font-bold underline\"\u003eHello, Next.js!\u003c/h1\u003e\n}\n```\n\n위 예제처럼 클래스 이름만 쭉 써주면 스타일이 깔끔하게 적용되니 정말 편리하답니다.\n\n---\n\n## Sass 사용하기\n\nNext.js는 Sass와 아주 잘 통합돼 있어서 `.scss`, `.sass` 확장자 둘 다 자유롭게 사용할 수 있어요. \n\nSass는 CSS를 더 효율적이고 구조적으로 관리할 수 있게 해주는 CSS 전처리기인데요, 변수, 중첩, 믹스인 같은 강력한 기능 덕분에 코드 작성이 훨씬 편해진답니다.\n\nNext.js 프로젝트에서 Sass를 사용하려면 일단 `sass` 패키지를 설치해주고 (`npm install sass`), 그다음에 `.scss`나 `.sass` 파일을 임포트해서 바로 스타일을 적용할 수 있어요.\n\n예를 들어,\n\n```scss\n// styles.module.scss\n$primary-color: #4f46e5;\n\n.title {\n  color: $primary-color;\n  font-weight: bold;\n}\n```\n\n```js\nimport styles from './styles.module.scss';\n\nexport default function Page() {\n  return \u003ch1 className={styles.title}\u003eHello, Next.js with Sass!\u003c/h1\u003e;\n}\n```\n\n이렇게 작성하면 Sass가 제공하는 변수 기능도 자연스럽게 쓸 수 있답니다.\n\n---\n\n\u003e 참고로, Sass를 사용하면 CSS 유지보수가 더 쉬워지고, 규모가 큰 프로젝트에서는 특히 효과적이에요. 만약 Tailwind와 Sass 둘 다 같이 쓴다면, Tailwind로 기본 스타일을 빠르게 구성하고, Sass로 좀 더 복잡한 커스텀 스타일을 관리하는 식으로 활용할 수도 있겠죠!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nSass를 컴포넌트 단위로도 사용할 수 있어요. CSS Modules와 함께 `.module.scss`나 `.module.sass` 확장자를 사용하면 되죠. 덕분에 스타일의 범위를 컴포넌트 내부로 한정할 수 있어서, 다른 부분에 영향 주지 않고 스타일을 관리하기 정말 편해집니다.\n\n### Sass 설치 방법\n\nSass를 프로젝트에서 바로 사용하려면 `sass` 패키지를 설치해줘야 해요. 터미널에 아래 명령어만 입력하면 끝!\n\n```bash\nnpm install --save-dev sass\n```\n\n이렇게 하면 `node-sass` 대신 더 빠르고 최신 버전인 `sass`가 설치됩니다. 요즘은 대부분 이 패키지를 추천하고 있으니 꼭 참고하세요!\n\n그리고 Sass를 쓰다 보면 `.scss`와 `.sass` 확장자의 차이가 궁금할 수도 있는데, 간단히 말하면 `.scss`는 CSS 문법과 거의 비슷해서 배우기 쉽고, `.sass`는 들여쓰기를 기반으로 한 문법이에요. 보통 `.scss`를 더 많이 사용한답니다.\n\n만약 Create React App 같은 환경에선 위 설치만 해도 바로 Sass를 쓸 준비가 된 거예요! 컴포넌트별 Sass를 적용하려면 스타일 파일 이름을 `ComponentName.module.scss`처럼 지으면 되고, 이렇게 하면 CSS가 자동으로 모듈화돼서 충돌 없이 안정적입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### Sass 옵션 커스터마이징하기\n\nNext.js에서 Sass 옵션을 설정하고 싶을 때는 `next.config.js` 파일 내에 `sassOptions`를 사용하면 돼요. 예를 들어, 모든 Sass 파일에 공통으로 사용할 변수를 선언하고 싶다면 `additionalData` 옵션을 활용할 수 있어요.\n\n```js\nimport type { NextConfig } from 'next'\n\nconst nextConfig: NextConfig = {\n  sassOptions: {\n    additionalData: `$var: red;`,\n  },\n}\n\nexport default nextConfig\n```\n\n위 예제에서는 Sass 변수 `$var`에 빨간색(`red`) 값을 기본으로 넣어두었어요. 이렇게 설정하면 모든 Sass 파일에서 별도의 선언 없이 `$var` 변수를 바로 사용할 수 있답니다. 덕분에 공통 변수나 믹스인 등을 간편하게 적용할 수 있어요.\n\n\u003e 팁!  \n\u003e `additionalData`는 파일마다 자동으로 추가되는 코드라서, 여러 변수나 스타일 믹스인들을 등록하면 훨씬 효율적으로 Sass를 관리할 수 있어요.  \n\u003e 예를 들어, 공통 색상 팔레트나 폰트 스타일을 미리 정의해두는 식이죠.\n\n---\n\n## CSS-in-JS\n\n(여기서부터 CSS-in-JS에 대해 다룰 예정인데, 추가로 궁금한 부분이 있으면 말씀해 주세요!)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nReact Server Components(RSC)를 사용하다 보면 한 가지 주의할 점이 있어요. 바로 **런타임 시 자바스크립트가 필요한 CSS-in-JS 라이브러리들은 현재 React Server Components에서 지원되지 않는다**는 거죠.\n\n### 왜 이런 제한이 생길까?\nReact Server Components는 서버에서 미리 렌더링하고 클라이언트에서는 최소한의 자바스크립트만 실행하는 방식을 취하기 때문에,\n런타임에 자바스크립트가 꼭 필요한 스타일링 라이브러리들은 당장 호환되기 힘든 상황이에요.\n\n### 그렇다면 어떤 CSS-in-JS 라이브러리는 지금 앱 디렉토리의 Client Components에서 쓸 수 있을까?\n아래는 현재 지원되는 라이브러리 목록입니다. (알파벳순)\n\n| 지원 라이브러리              |\n|-----------------------|\n| ant-design            |\n| chakra-ui             |\n| @fluentui/react-components |\n| kuma-ui               |\n| @mui/material         |\n| @mui/joy              |\n| pandacss              |\n| styled-jsx            |\n| styled-components     |\n| stylex                |\n| tamagui               |\n| tss-react             |\n| vanilla-extract       |\n\n### 지원 관련 고민 중인 라이브러리도 있다!\n현재 React 최신 버전에 맞춰 Server Components와 Streaming 지원을 준비 중인 라이브러리들도 있으니, 앞으로 더 확대될 가능성이 높습니다.\n\n### 추가 팁\n- 만약 CSS-in-JS를 꼭 써야 한다면, Server Component가 아닌 Client Component에서만 해당 라이브러리를 사용하도록 분리하는 방법을 추천해요.\n- 스타일링을 아예 CSS 모듈 또는 vanilla CSS로 관리하거나, `styled-jsx`같이 별도 런타임이 필요 없는 라이트한 스타일러를 고려하는 것도 좋아요.\n\n---\n\nReact 개발하면서 최신 기능들을 써보고 싶은데 스타일링 라이브러리 때문에 고민이라면,\n이 리스트와 팁을 참고해서 내 프로젝트에 맞게 잘 조합해보시길 바라요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- emotion\n\n서버 컴포넌트(Server Components)에 스타일을 입히고 싶다면, CSS 파일을 생성하는 CSS Modules나 Tailwind CSS 같은 솔루션을 사용하는 것을 추천해요. 이 방법들이 서버 컴포넌트와 잘 맞고, 성능 측면에서도 유리하답니다.\n\n### CSS-in-JS 설정하기\n\n만약 CSS-in-JS를 사용하고 싶다면, 다음과 같은 설정이 필요해요: \n\n(여기서는 emotion 같은 CSS-in-JS 라이브러리를 예로 들 수 있겠죠.)\n\n추가로, CSS-in-JS를 사용할 때는 클라이언트 컴포넌트 내에서 스타일 적용이 이뤄지는 경우가 많아서, 서버 컴포넌트에서는 권장되지 않는다는 점을 기억하세요. 상황에 따라 적절한 방식을 선택하는 게 중요해요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nstyle-jsx를 Next.js 같은 React 환경에서 사용할 때 스타일을 깔끔하게 적용하고 수집하는 방법에 대해 알려드릴게요. 보통 SSR(서버 사이드 렌더링)을 하게 되면 스타일이 제대로 적용되는 시점이 중요하거든요. 그래서 스타일을 한 군데 모아 관리하고, 렌더 전에 HTML에 스타일을 주입하는 코드를 작성합니다.\n\n아래는 주요 포인트와 예시 코드입니다.\n\n---\n\n### 스타일 레지스트리 만들기\n\n- `createStyleRegistry()`를 이용해 스타일을 모으는 레지스트리를 만듭니다.\n- 컴포넌트가 처음 렌더될 때 한 번만 생성되도록 `useState`의 lazy initializer 패턴을 씁니다.\n\n### 스타일을 HTML에 주입하기\n\n- `useServerInsertedHTML` 훅을 사용해서 서버에서 렌더링 직전에 스타일 태그를 HTML에 넣어줍니다.\n- 이러면 나중에 페이지가 로드될 때 스타일이 깜빡이거나 지연 없이 바로 적용돼요.\n\n### 클라이언트 컴포넌트에서 래핑하기\n\n- 앱의 최상위 컴포넌트를 스타일 레지스트리로 감싸서 SSR 초기 렌더링할 때 스타일 관리를 집중시킵니다.\n\n---\n\n### Styled-jsx 적용 예시\n\n```jsx\n'use client'\n\nimport React, { useState } from 'react'\nimport { useServerInsertedHTML } from 'next/navigation'\nimport { StyleRegistry, createStyleRegistry } from 'styled-jsx'\n\nexport default function StyledJsxRegistry({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  // 스타일시트를 한 번만 생성 (lazy init)\n  const [jsxStyleRegistry] = useState(() =\u003e createStyleRegistry())\n\n  // 서버 렌더링 시 스타일 태그를 먼저 삽입\n  useServerInsertedHTML(() =\u003e {\n    const styles = jsxStyleRegistry.styles()\n    jsxStyleRegistry.flush()\n    return \u003c\u003e{styles}\u003c/\u003e\n  })\n\n  // 스타일 등록기를 통해 자식 요소들 감싸기\n  return \u003cStyleRegistry registry={jsxStyleRegistry}\u003e{children}\u003c/StyleRegistry\u003e\n}\n```\n\n---\n\n### 부가 팁!\n\n- `StyleRegistry`는 스타일을 수집하고 렌더링하는 역할을 해주기 때문에, 이 컴포넌트로 앱 전체를 감싼다면 스타일 충돌도 관리할 수 있어요.\n- `flush()` 메서드는 수집한 스타일을 비워서 중복 삽입을 막아줍니다.\n- 만약 styled-jsx 외에 Emotion, Styled-components 등 다른 CSS-in-JS 라이브러리를 쓴다면 각각의 서버 스타일 주입 방법이 있으니 참고하세요.\n\n이렇게 하면 서버에서 스타일이 빠르게 적용되어 사용자 경험이 훨씬 좋아집니다! 한 번 적용해 보시면 렌더링 과정에서 스타일이 정확하고 깔끔하게 적용되는 걸 눈으로 확인하실 수 있을 거예요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자, 이제 root layout을 registry로 감싸는 방법을 알려드릴게요.\n\n```js\nimport StyledJsxRegistry from './registry'\n \nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    \u003chtml\u003e\n      \u003cbody\u003e\n        \u003cStyledJsxRegistry\u003e{children}\u003c/StyledJsxRegistry\u003e\n      \u003c/body\u003e\n    \u003c/html\u003e\n  )\n}\n```\n\n이렇게 하면 스타일 관련 문제를 좀 더 깔끔하게 관리할 수 있어요. 특히 여러 컴포넌트에서 스타일이 꼬일 때 유용하죠.\n\n---\n\n### styled-components 사용법\n\n만약 Next.js 프로젝트에서 **styled-components**를 사용하려면, `next.config.js` 파일에서 별도로 활성화해야 해요. 다음과 같이 설정해 주세요:\n\n```js\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  // 기타 설정들...\n\n  compiler: {\n    styledComponents: true,\n  },\n}\n\nmodule.exports = nextConfig\n```\n\n이 설정을 하면 styled-components가 Next.js 컴파일러와 잘 연동되어 SSR (서버사이드 렌더링) 시 스타일이 깨지지 않도록 도와줘요.\n\n---\n\n#### 참고 팁!\n\n- `styled-components` 쓸 때는 Babel 설정도 필요할 수 있는데, Next.js 12 이상이면 위 `compiler` 옵션만으로 대부분 해결돼요.\n- `StyledJsxRegistry` 같은 커스텀 레지스트리를 사용하는 이유는 스타일 충돌을 방지하고, 렌더링 최적화를 위해서입니다.\n- 스타일 관리는 React+Next.js에서 꽤 복잡할 수 있지만, 이런 설정들을 적용하면 훨씬 안정적인 UI를 만들 수 있으니 꼭 적용해 보세요!\n\n궁금한 점 있으면 언제든 물어보세요~\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 `styled-components`를 잘 사용하려면, 기본 설정과 함께 서버 사이드에서 스타일을 제대로 수집하고 HTML `\u003chead\u003e`에 주입하는 작업이 필요해요. 간단히 말해서, SSR 환경에서 스타일이 누락되지 않도록 조치를 취하는 거죠.\n\n### 1. `next.config.js` 설정\n\n일단 Next.js 설정 파일에서 `styledComponents` 플래그를 `true`로 켜줘야 해요. 그렇지 않으면 컴파일러가 스타일드 컴포넌트 문법을 제대로 처리하지 못해요.\n\n```js\nimport type { NextConfig } from 'next';\n\nconst nextConfig: NextConfig = {\n  compiler: {\n    styledComponents: true,\n  },\n};\n\nexport default nextConfig;\n```\n\n이 작업은 CSS 클래스 이름 충돌을 방지하고, 개발 편의성을 높여줘요!\n\n---\n\n### 2. 서버에서 스타일 수집하기: `StyledComponentsRegistry` 컴포넌트\n\n서버 측 렌더링(SSR) 시 모든 스타일 규칙을 모아서 나중에 `\u003chead\u003e` 태그에 삽입해야 해요. 이걸 위해 `ServerStyleSheet`를 사용해서 스타일을 수집하고, `useServerInsertedHTML` 훅으로 클라이언트에 주입합니다.\n\n```js\n'use client';\n\nimport React, { useState } from 'react';\nimport { useServerInsertedHTML } from 'next/navigation';\nimport { ServerStyleSheet, StyleSheetManager } from 'styled-components';\n\nexport default function StyledComponentsRegistry({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  // 스타일시트는 한 번만 생성하도록 lazy 초기화 사용\n  const [styledComponentsStyleSheet] = useState(() =\u003e new ServerStyleSheet());\n\n  useServerInsertedHTML(() =\u003e {\n    const styles = styledComponentsStyleSheet.getStyleElement();\n    styledComponentsStyleSheet.instance.clearTag(); // 기존 태그 초기화\n    return \u003c\u003e{styles}\u003c/\u003e;\n  });\n\n  // 클라이언트에서는 그냥 children만 리턴\n  if (typeof window !== 'undefined') return \u003c\u003e{children}\u003c/\u003e;\n\n  // 서버에서는 StyleSheetManager로 감싸서 스타일 수집\n  return (\n    \u003cStyleSheetManager sheet={styledComponentsStyleSheet.instance}\u003e\n      {children}\n    \u003c/StyleSheetManager\u003e\n  );\n}\n```\n\n#### 핵심 포인트\n\n- `ServerStyleSheet`로 렌더링된 스타일을 묶어서 관리해요.\n- `useServerInsertedHTML` 훅은 서버 호출 시 스타일 태그를 `\u003chead\u003e` 안에 넣어 줍니다.\n- 클라이언트에서는 스타일 수집할 필요가 없으니 그냥 children을 렌더링하죠.\n- 서버에서는 `StyleSheetManager`로 감싸서 스타일링을 추적합니다.\n\n이 구조 덕분에 FOUC(Flash of Unstyled Content, 스타일링 없는 깜빡임)를 없앨 수 있고, SEO와 UX 품질도 깔끔해져요!\n\n---\n\n### 3. 루트 레이아웃에 적용하기\n\n마지막으로 `app/layout.tsx` 같은 루트 레이아웃 파일에서, 기존 children을 `StyledComponentsRegistry`로 감싸주세요.\n\n```tsx\nimport StyledComponentsRegistry from './StyledComponentsRegistry';\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    \u003chtml lang=\"ko\"\u003e\n      \u003chead\u003e{/* 여기에 다른 head 요소들 */}\u003c/head\u003e\n      \u003cbody\u003e\n        \u003cStyledComponentsRegistry\u003e\n          {children}\n        \u003c/StyledComponentsRegistry\u003e\n      \u003c/body\u003e\n    \u003c/html\u003e\n  );\n}\n```\n\n---\n\n## 정리\n\n| 단계                   | 설명                                                                                |\n|------------------------|-----------------------------------------------------------------------------------|\n| 1. next.config.js 설정  | `compiler.styledComponents: true`를 켜서 styled-components 컴파일러를 활성화            |\n| 2. StyledComponentsRegistry 작성 | 서버 스타일 수집용 컴포넌트 작성. `ServerStyleSheet`, `useServerInsertedHTML` 활용  |\n| 3. 루트 레이아웃 감싸기  | 레이아웃에서 모든 children을 위 컴포넌트로 감싸서 SSR 시 스타일 누락 방지                |\n\n---\n\n### 참고 팁\n\n- `styled-components` 이전 버전에서는 `_document.js`에서 SSR 설정을 하곤 했는데, Next.js 13의 App Router에서는 `useServerInsertedHTML` 훅으로 훨씬 더 간편하게 적용할 수 있어요.\n- `ServerStyleSheet` 인스턴스는 꼭 한 번만 생성하고 재사용해야 렌더링 시 메모리 누수를 방지합니다.\n- 개발 중에 styles가 이상하게 보이면 캐시를 삭제하고 다시 빌드해 보는 것도 좋아요.\n\n---\n\n이 방법으로 프로젝트에서 `styled-components`를 깔끔하게 SSR 환경에 맞게 쓸 수 있답니다! 혹시 더 궁금한 점 있으면 언제든 물어봐 주세요~ 🚀\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번 글에서는 React 컴포넌트에서 외부 스타일시트를 다루는 방법과 styled-components를 사용하는 루트 레이아웃 구성을 소개할게요.\n\n먼저, styled-components를 활용한 RootLayout 컴포넌트 모습부터 살펴봅시다.\n\n```jsx\nimport StyledComponentsRegistry from './lib/registry'\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    \u003chtml\u003e\n      \u003cbody\u003e\n        \u003cStyledComponentsRegistry\u003e{children}\u003c/StyledComponentsRegistry\u003e\n      \u003c/body\u003e\n    \u003c/html\u003e\n  )\n}\n```\n\n여기서 StyledComponentsRegistry는 styled-components를 SSR(서버 사이드 렌더링)에서 제대로 작동하게 하도록 도와주는 역할을 해요. 만약 여러분이 Next.js 같은 프레임워크를 사용한다면, SSR 시 스타일 섞임 현상이나 스타일 누락 문제를 줄이는데 아주 유용하죠.\n\n그 다음, 외부 패키지에서 제공하는 CSS 파일을 불러오는 방법입니다. 예시로 Bootstrap CSS를 활용해 볼게요.\n\n```jsx\nimport 'bootstrap/dist/css/bootstrap.css'\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    \u003chtml lang=\"en\"\u003e\n      \u003cbody className=\"container\"\u003e{children}\u003c/body\u003e\n    \u003c/html\u003e\n  )\n}\n```\n\n이렇게 레이아웃 최상위 루트에 Bootstrap을 임포트해서 전체 앱에 적용할 수 있어요. 이렇게 하면 별도로 각 컴포넌트마다 스타일을 임포트하지 않아도 되니 편리합니다.\n\n추가 팁을 드리자면:\n\n- 외부 CSS는 글로벌하게 적용되기 때문에 기본값 덮어쓰기나 클래스 충돌을 염두에 두고 사용하세요.\n- styled-components 같이 CSS-in-JS 방식을 쓰면서 외부 스타일시트를 혼합하는 경우, 스타일 우선순위나 특정성 specificity를 고려해야 합니다.\n- 종종 styled-components로 스타일을 작성하면서 Bootstrap처럼 미리 만들어진 UI 라이브러리 CSS를 함께 쓰면, 코드 재사용성과 개발 생산성을 높일 수 있으니 두 방식을 적절히 섞는 걸 추천합니다!\n\n요약하자면, styled-components SSR 설정을 통해 안정적인 스타일 렌더링을 확보하고, 외부 CSS는 전역에 한번만 불러오는 방식을 취하면 여러분 프로젝트의 스타일 관리가 훨씬 깔끔해질 거예요. 필요한 부분에서는 컴포넌트 단위로 스타일을 나누고, 글로벌 스타일이나 라이브러리는 루트 레이아웃에서 한꺼번에 관리하는 게 좋아요.\n\n이제 여러분도 Next.js 프로젝트나 React 앱에서 스타일시트 관리가 좀 더 수월해지길 바랍니다! 궁금한 점 있으면 언제든 댓글로 알려주세요. :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n외부 스타일시트는 꼭 npm 패키지에서 직접 가져오거나, 파일을 다운받아서 내 프로젝트 코드와 함께 두어야 해요. 그러니까 `\u003clink rel=\"stylesheet\" /\u003e` 태그처럼 외부 URL을 그냥 연결해서 쓰는 방식은 사용할 수 없다는 뜻이죠.\n\n왜 그런 규칙이 있냐면, 보통 이렇게 하면 스타일이 내 프로젝트 안에 완전히 포함되기 때문에 빌드하거나 배포할 때 의존성이 깔끔해지고, 네트워크 지연 없이 더 빠르게 스타일을 적용할 수 있으니까요.\n\n실제로 CSS 가져오는 방법은 크게 두 가지예요:\n\n1. **npm 패키지에서 직접 import**  \n   예를 들어, `import 'package-name/dist/style.css';` 이렇게 사용하면 스타일시트가 내 프로젝트 안에서 관리되니까 편리해요.\n\n2. **파일 다운로드 후 프로젝트에 포함**  \n   필요한 CSS 파일을 직접 다운받아서 `/styles` 같은 디렉터리에 넣고,  \n   `import './styles/custom.css';` 이런식으로 불러옵니다.\n\n이때 주의할 점은, 외부에서 그냥 `\u003clink\u003e` 태그로 불러오면 리액트 같은 프레임워크 환경에서 스타일 관리가 까다로워지고, 로드 타이밍 문제도 생길 수 있으니 가급적 권장하지 않는다는 거예요.\n\n개발할 때 이런 점 참고해서, 스타일 관리도 깔끔하게 하는 습관 들이면 좋아요! 필요하면 이후에 CSS-in-JS 같은 방법도 한번 알아보시는 걸 추천드립니다. 스타일시트와 자바스크립트를 한 곳에서 관리하니까 훨씬 효율적이거든요.","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":25},{"title":"Nextjs 15에서 이미지와 폰트 최적화하는 방법","description":"","date":"2025-04-22 01:05","slug":"2025-04-22-Howtooptimizeimagesandfonts","content":"\n# 이미지와 폰트 최적화하는 방법\n\nNext.js는 이미지와 폰트 최적화를 자동으로 지원해줘요. 이 글에서는 어떻게 이 기능들을 활용할 수 있는지 쉽게 알려드릴게요.\n\n## 이미지 최적화하기\n\nNext.js의 `Image` 컴포넌트는 기본 HTML의 `img` 태그를 확장한 건데요, 여기에는 여러 가지 좋은 점이 있어요:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이미지 최적화는 웹 성능 향상에 정말 중요한 부분인데요! Next.js의 `next/image` 컴포넌트를 사용하면 여러 가지 유용한 기능들을 쉽게 활용할 수 있습니다.\n\n- **크기 최적화 (Size optimization)**: 각 디바이스에 맞게 자동으로 적절한 크기의 이미지를 제공해주고, WebP 같은 최신 이미지 포맷도 지원해서 용량을 줄여줘요.\n- **시각적 안정성 (Visual stability)**: 이미지가 로딩되는 동안 레이아웃이 흔들리거나 이동하지 않도록 자동으로 잡아줍니다.\n- **빠른 페이지 로드 (Faster page loads)**: 뷰포트에 들어올 때까지 이미지를 로드하지 않는 '네이티브 지연 로딩(lazy loading)'을 사용하며, 옵션으로 흐릿한 블러(blur-up) 플레이스홀더도 추가할 수 있어요.\n- **유연한 자산 관리 (Asset flexibility)**: 로컬 이미지뿐만 아니라 원격 서버에 있는 이미지도 필요에 따라 크기를 조절하며 불러올 수 있습니다.\n\n시작하려면 `next/image`에서 `Image`를 import하고, 컴포넌트 안에서 이렇게 사용해보세요.\n\n```js\nimport Image from \"next/image\";\n\nexport default function Page() {\n  return \u003cImage src=\"\" alt=\"\" /\u003e;\n}\n```\n\n- `src` 속성에는 로컬 이미지 경로나 외부 URL 모두 들어갈 수 있어요.\n- `alt` 속성은 이미지 설명으로 SEO와 접근성에 매우 중요하니 꼭 넣어주세요!\n\n---\n\n### 추가 팁!\n\n- `width`와 `height`를 명시해주면 레이아웃이 더 안정적이라 로딩 시 레이아웃 이동(Cumulative Layout Shift)을 방지할 수 있어요.\n- 원격 이미지 URL을 써야 하면 `next.config.js`에 `domains` 설정을 해줘야 로딩이 허용됩니다.\n\n```js\n// next.config.js\nmodule.exports = {\n  images: {\n    domains: [\"example.com\"], // 허용할 원격 이미지 도메인\n  },\n};\n```\n\n- `placeholder=\"blur\"` 옵션을 주면 흐릿한 이미지가 먼저 보이면서 자연스러운 로딩 경험을 줄 수도 있고, 특히 느린 네트워크에서 효과적입니다.\n\n이렇게만 활용해도 페이지 퍼포먼스와 사용자 경험이 꽤 개선될 거예요! 앞으로 프로젝트에 멋지게 적용해 보세요 :)\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 로컬 이미지 사용하기\n\nNext.js에서는 이미지나 폰트 같은 정적 파일을 프로젝트 루트 디렉터리에 `public`이라는 폴더를 만들어서 관리할 수 있어요. 이렇게 `public` 폴더 안에 저장한 파일들은 코드에서 기본 URL(`/`)부터 시작해서 쉽게 불러올 수 있답니다.\n\n예를 들어, `public/assets/img/2025-04-22-Howtooptimizeimagesandfonts_0.png`라는 이미지가 있다면 HTML에서는 이렇게 사용할 수 있어요:\n\n```html\n\u003cimg src=\"/TIL/assets/img/2025-04-22-Howtooptimizeimagesandfonts_0.png\" /\u003e\n```\n\n---\n\n더 나아가 Next.js에서 권장하는 방법인 `next/image` 컴포넌트를 써보면 이렇게 됩니다:\n\n```jsx\nimport Image from \"next/image\";\nimport profilePic from \"./me.png\";\n\nexport default function Page() {\n  return (\n    \u003cImage\n      src={profilePic}\n      alt=\"Picture of the author\"\n      // width={500} 자동으로 제공됨\n      // height={500} 자동으로 제공됨\n      // blurDataURL=\"data:...\" 자동 제공 (로딩 시 블러 효과)\n      // placeholder=\"blur\" // 로딩 중에 흐릿하게 미리보기 하는 옵션 (선택 사항)\n    /\u003e\n  );\n}\n```\n\n`next/image`를 쓰면 이미지 크기 최적화, 자동 레이지 로딩(lazy loading), 웹 최적화 포맷 변환 등 다양한 이점을 누릴 수 있어서 성능 개선에 특히 좋아요.\n\n\u003e TIP: `next/image`는 이미지를 직접 `import`로 불러와야 제대로 작동하니, 프로젝트 내 이미지 파일 경로를 정확히 지정해 주세요!  \n\u003e 그리고 `public` 폴더 내 이미지 파일을 사용할 땐 `src`에 문자열 경로(`/assets/img/example.png`)를 직접 넣으면 되고, import해서 사용하는 경우는 외부나 프로젝트 내부 파일을 가리킬 때 주로 쓰입니다.\n\n이렇게 하면 로컬 이미지 자원을 깔끔하게 관리하면서 Next.js의 최적화 기능도 빵빵하게 사용할 수 있으니 꼭 활용해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js는 이미지 파일을 가져올 때, 이미지의 고유 너비와 높이를 자동으로 판단해줘요. 이 값을 이용해서 이미지 비율을 정하고, 이미지가 로딩되는 동안 발생할 수 있는 레이아웃 흔들림(Cumulative Layout Shift)을 막아줍니다. 덕분에 사용자 경험이 훨씬 좋아지죠.\n\n### 원격 이미지 사용하기\n\n로컬 이미지뿐만 아니라, 원격 서버에 있는 이미지도 사용할 수 있어요. 이때는 `src` 속성에 이미지 URL을 바로 넣어주면 됩니다.\n\n```js\nimport Image from \"next/image\";\n\nexport default function Page() {\n  return (\n    \u003cImage src=\"https://s3.amazonaws.com/my-bucket/profile.png\" alt=\"Picture of the author\" width={500} height={500} /\u003e\n  );\n}\n```\n\n\u003e 참고로, 원격 이미지 URL을 사용할 때도 `width`와 `height`를 꼭 명시해주셔야 합니다. 이렇게 하면 Next.js가 이미지 공간을 미리 확보해서 페이지가 흔들리지 않도록 해주거든요.\n\n혹시 원격 이미지 도메인이 반복적으로 쓰인다면, `next.config.js` 파일에서 도메인을 허용해주는 설정도 해주시면 좋아요. 예를 들어:\n\n```js\n// next.config.js\nmodule.exports = {\n  images: {\n    domains: [\"s3.amazonaws.com\"],\n  },\n};\n```\n\n이 설정을 해줘야 Next.js가 해당 도메인의 이미지를 최적화하고 사용할 수 있으니 꼭 기억하세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js를 사용할 때, 빌드 과정에서 원격(remote) 이미지 파일에 직접 접근할 수 없기 때문에, 이미지 컴포넌트에 width, height 그리고 선택적으로 blurDataURL 같은 속성들을 직접 지정해줘야 해요. 이 width와 height 정보는 이미지가 로딩되면서 화면이 깜빡이거나 레이아웃이 순간적으로 바뀌는 현상(layout shift)을 막아주고, 올바른 비율(aspect ratio)을 유지하는 데 도움이 되죠.\n\n그리고 원격 서버에서 이미지를 안전하게 불러오려면, next.config.js 파일에서 허용할 원격 이미지 URL 패턴을 정확하게 명시해줘야 해요. 이렇게 구체적으로 지정하는 이유는 보안상 악의적인 URL이 들어오는 걸 막기 위함입니다. 예를 들어 아래와 같이 특정 AWS S3 버킷에서만 이미지를 불러오도록 설정할 수 있어요:\n\n```js\nimport { NextConfig } from \"next\";\n\nconst config: NextConfig = {\n  images: {\n    remotePatterns: [\n      {\n        protocol: \"https\",\n        hostname: \"s3.amazonaws.com\",\n        port: \"\",\n        pathname: \"/my-bucket/**\",\n        search: \"\",\n      },\n    ],\n  },\n};\n\nexport default config;\n```\n\n위처럼 설정하면 s3.amazonaws.com 도메인의 /my-bucket 경로 밑에 있는 이미지들만 Next.js 이미지 최적화 기능을 통해 불러올 수 있게 돼요.\n\n---\n\n### 추가로 알려드리는 팁!\n\n- 원격 이미지의 크기를 정확히 알기 어렵다면, 개발자 도구나 디자인 툴에서 미리 가로, 세로 크기를 측정해 넣는 걸 추천합니다.\n- `blurDataURL` 속성은 낮은 해상도의 이미지 베이스64 데이터를 넣어 이미지가 로딩될 때 부드럽게 보여주는 효과를 줍니다. 사용자 경험을 개선하는 데 특히 유용해요.\n- 때로는 이미지를 캐싱하기 위해 CDN을 사용합니다. 이럴 때도 해당 CDN 도메인에 맞게 remotePatterns 설정을 해줘야 하니 참고하세요.\n\n---\n\n## 폰트 최적화하기 (Optimizing Fonts)\n\nNext.js는 기본적으로 디폴트 폰트를 빠르게 로딩하기 위한 몇 가지 기능을 제공하는데요, 웹폰트를 최적화하면 페이지 로딩 속도를 개선하고, 불필요한 폰트 파일 다운로드를 줄일 수 있습니다. 이 주제에 대해서도 곧 상세하게 다뤄볼게요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nnext/font 모듈은 폰트를 자동으로 최적화해주고, 외부 네트워크 요청을 없애서 개인정보 보호와 성능을 동시에 잡아줍니다.\n\n이 모듈은 폰트 파일을 자체 호스팅하는 기능도 내장하고 있어요. 덕분에 웹 폰트를 불러올 때 레이아웃이 흔들리는 현상(레이아웃 시프트) 없이 깔끔하게 로딩할 수 있답니다.\n\n사용법도 간단해요! next/font에서 제공하는 `local` 혹은 `google` 폰트 모듈을 불러오고, 필요한 옵션을 주면서 함수를 호출해서 폰트를 적용할 엘리먼트의 `className`에 할당하면 됩니다.\n\n아래는 구체적인 예시 코드인데요, 제가 좀 더 완성된 형태로 정리해봤어요.\n\n```js\n// 예를 들어 구글 폰트를 불러올 땐 이렇게!\nimport { Roboto } from \"next/font/google\";\n\nconst roboto = Roboto({\n  subsets: [\"latin\"],\n  weight: [\"400\", \"700\"],\n  style: [\"normal\", \"italic\"],\n});\n\nexport default function Layout({ children }: { children: React.ReactNode }) {\n  return (\n    \u003chtml lang=\"ko\"\u003e\n      \u003cbody className={roboto.className}\u003e{children}\u003c/body\u003e\n    \u003c/html\u003e\n  );\n}\n```\n\n여기서 `Roboto`는 구글에서 제공하는 대표적인 구글 폰트 중 하나입니다. 옵션으로는 `subsets` (영문 등 문자 범위), `weight` (폰트 굵기), `style` (normal, italic 등)를 지정할 수 있어요.\n\n- **장점!**\n  - 폰트가 페이지에서 필요한 부분에만 로딩되어 초기 로딩 속도가 빨라집니다.\n  - 폰트를 외부 서버에서 가져오는 대신 자체 서버에서 제공해 개인정보도 안심!\n  - CSS에서 자주 발생하는 폰트 관련 CLS (Layout Shift) 문제를 예방할 수 있어요.\n\n간단하게 `next/font`를 사용하는 방법 알려드렸는데, 실제 프로젝트에 도입해 보면 성능 개선이 꽤 느껴진답니다. 혹시 직접 폰트 파일을 프로젝트에 추가해서 쓰고 싶다면 `next/font/local` 모듈을 참고해보세요. `next/font/google`처럼 쓰되, 폰트 파일 경로를 지정해서 불러올 수 있습니다.\n\n새 프로젝트에 폰트 적용 고민 중이라면, 이 방법 꼭 한 번 써보시길 추천드려요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 구글 폰트 자동 호스팅하기\n\n웹사이트에 예쁜 글꼴을 적용할 때 구글 폰트를 많이 사용하시죠? 근데 여러분, 구글 폰트를 그냥 링크 걸어서 쓰면 사용자의 브라우저가 구글 서버에 직접 요청을 보내서 폰트를 가져오거든요. 이러면 약간 속도가 느려질 수도 있고, 개인정보 측면에서 꺼려질 수도 있죠.\n\n그런데 Next.js에서는 구글 폰트를 배포할 때 자동으로 내 서버에서 직접 호스팅해서 폰트를 제공할 수 있어요. 이렇게 하면 사용자가 우리 사이트에 접속할 때 구글 서버로 요청이 나가지 않고, 우리 도메인에서 바로 폰트를 받으니 더 빠르고 깔끔해집니다.\n\n아래처럼 간단하게 `next/font/google`에서 원하는 폰트를 import하고 설정해주면 끝!\n\n```js\nimport { Geist } from \"next/font/google\";\n\nconst geist = Geist({\n  subsets: [\"latin\"],\n});\n\nexport default function RootLayout({ children }) {\n  return (\n    \u003chtml lang=\"en\" className={geist.className}\u003e\n      \u003cbody\u003e{children}\u003c/body\u003e\n    \u003c/html\u003e\n  );\n}\n```\n\n- `subsets` 옵션은 폰트에서 사용할 문자의 범위를 설정해요. 예를 들어 `latin`은 영어권 문자에 해당하고, 한국어는 `korean` 서브셋을 따로 지원하는 폰트가 많으니 필요하면 추가해주면 됩니다.\n- 이렇게 하면 폰트 파일들이 빌드 때 내 사이트에 포함되고, 별도 요청 없이 바로 렌더링되어 속도도 좋아져요.\n\n참고로, 커스텀 폰트를 쓰거나 구글 폰트 말고 다른 외부 폰트를 사용할 때도 비슷하게 직접 호스팅하는 걸 추천합니다. 사이트 속도도 개선하고, 외부 서버 의존도를 낮출 수 있으니까요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n변수 폰트(variable fonts)를 사용하는 걸 추천해요! 성능도 좋고 유연하게 폰트를 조절할 수 있어서요. 만약 변수 폰트를 쓸 수 없는 상황이라면, 폰트의 굵기(weight)를 꼭 지정해줘야 해요.\n\n예를 들어, Google 폰트인 Roboto를 Next.js에서 사용할 때는 이렇게 작성해요:\n\n```js\nimport { Roboto } from \"next/font/google\";\n\nconst roboto = Roboto({\n  subsets: [\"latin\"],\n});\n\nexport default function RootLayout({ children }: { children: React.ReactNode }) {\n  return (\n    \u003chtml lang=\"en\" className={roboto.className}\u003e\n      \u003cbody\u003e{children}\u003c/body\u003e\n    \u003c/html\u003e\n  );\n}\n```\n\n위 코드에서 `Roboto`는 변수 폰트로 불러와서, 원하는 굵기나 스타일을 쉽게 조절할 수 있답니다.\n\n---\n\n### 로컬 폰트 사용하는 방법\n\n로컬에 저장된 폰트를 사용하고 싶을 땐 `next/font/local`에서 폰트를 임포트하면 돼요. 그리고 폰트 파일(src)의 경로를 꼭 지정해줘야 해요.\n\n```js\nimport localFont from \"next/font/local\";\n\nconst myFont = localFont({\n  src: \"./fonts/MyFont.woff2\",\n  weight: \"400\",\n  style: \"normal\",\n});\n\nexport default function RootLayout({ children }) {\n  return (\n    \u003chtml lang=\"en\" className={myFont.className}\u003e\n      \u003cbody\u003e{children}\u003c/body\u003e\n    \u003c/html\u003e\n  );\n}\n```\n\n여기서 주의할 점은, 로컬 폰트를 쓸 땐 폰트 파일의 형식(woff, woff2, ttf 등)에 따라 브라우저 호환성이 달라질 수 있으니 여러 형식을 같이 넣어주는 것도 좋은 방법이에요.\n\n---\n\n추가로, 변수 폰트를 쓰면 파일 사이즈도 줄일 수 있는데, 왜냐하면 한 파일 내에서 여러 굵기와 스타일을 다룰 수 있기 때문이죠. 기존엔 굵기별로 따로 폰트 파일을 불러와야 했거든요. 그래서 성능 최적화에도 큰 도움이 돼요!\n\n궁금한 점 있으면 댓글로 남겨주세요~\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 `localFont`를 사용해서 로컬 폰트를 불러오는 방법에 대해 이야기해볼게요. 폰트를 프로젝트 안에 직접 넣고 사용할 때 정말 유용한 기능인데요, 예를 들어 아래처럼 간단히 사용할 수 있어요.\n\n```js\nimport localFont from \"next/font/local\";\n\nconst myFont = localFont({\n  src: \"./my-font.woff2\",\n});\n\nexport default function RootLayout({ children }: { children: React.ReactNode }) {\n  return (\n    \u003chtml lang=\"en\" className={myFont.className}\u003e\n      \u003cbody\u003e{children}\u003c/body\u003e\n    \u003c/html\u003e\n  );\n}\n```\n\n이 코드의 핵심은 `localFont`가 폰트 파일 경로를 받아서 내부적으로 `@font-face`를 생성해주고, 관련 CSS 클래스를 제공합니다. `myFont.className`을 html 태그에 넣으면 페이지 전체에 해당 폰트가 적용돼요.\n\n그리고 보통 하나의 폰트 패밀리에는 다양한 스타일과 두께가 있기 마련이죠? 예를 들면 일반체, 이탤릭, 굵은 글씨 등등. 이런 경우에는 `src`를 배열 형태로 넘겨서 각각의 스타일과 무게를 지정할 수 있습니다.\n\n```js\nconst roboto = localFont({\n  src: [\n    {\n      path: \"./Roboto-Regular.woff2\",\n      weight: \"400\",\n      style: \"normal\",\n    },\n    {\n      path: \"./Roboto-Italic.woff2\",\n      weight: \"400\",\n      style: \"italic\",\n    },\n    {\n      path: \"./Roboto-Bold.woff2\",\n      weight: \"700\",\n      style: \"normal\",\n    },\n    {\n      path: \"./Roboto-BoldItalic.woff2\",\n      weight: \"700\",\n      style: \"italic\",\n    },\n  ],\n});\n```\n\n이렇게 하면 폰트를 사용할 때 보통 CSS에서 하는 `font-weight`, `font-style` 같은 속성들도 그대로 적용되니 굉장히 편리해요. 페이지에서 `\u003cp style={{ fontWeight: '700', fontStyle: 'italic' }}\u003e` 이런 식으로 쓰면 `Roboto-BoldItalic.woff2`가 적용되는 거죠.\n\n추가 팁으로, 이 방법은 폰트 파일을 직접 관리하기 때문에 구글 폰트 CDN과 달리 네트워크 지연이나 외부 서비스 의존이 없어서 성능 면에서도 좋고, 개인정보 보호에도 유리하답니다!\n\n### 요약\n\n| 특징                                 | 설명                                              |\n| ------------------------------------ | ------------------------------------------------- |\n| `localFont` 사용법                   | 폰트를 로컬에서 직접 불러옴                       |\n| 단일 파일 폰트 지정                  | `src`에 한 개의 폰트 파일 경로 지정               |\n| 여러 스타일/두께 폰트 지정           | `src`를 배열로 주고 각각의 `weight`, `style` 지정 |\n| 자동으로 클래스 및 `@font-face` 생성 | 폰트를 클래스 이름으로 쉽게 적용 가능             |\n| 성능 및 개인정보 보호                | 외부 호출 없이 빠르고 안전함                      |\n\nNext.js 프로젝트에서 폰트를 더 세밀하게 컨트롤하고 싶다면, 이렇게 `localFont` 사용을 적극 추천해요!\n","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":13},{"title":"Next.js 15에서 레이아웃과 페이지 쉽게 만드는 방법","description":"","date":"2025-04-22 01:01","slug":"2025-04-22-Howtocreatelayoutsandpages","content":"\n# 레이아웃과 페이지 만드는 방법\n\nNext.js는 파일 시스템 기반 라우팅을 사용해요. 즉, 폴더와 파일 구조를 활용해서 라우트를 정의할 수 있다는 거죠. 이번 글에서는 레이아웃과 페이지를 어떻게 만들고 서로 링크하는지 쉽게 알려드릴게요.\n\n## 페이지 만들기\n\n페이지란 특정 경로에서 렌더링되는 UI를 뜻해요. 페이지를 만들려면 `app` 디렉토리 안에 파일을 추가하고, 그 파일에서 React 컴포넌트를 기본 내보내기(default export) 하면 됩니다. 예를 들어, 인덱스 페이지(`/`)를 만들고 싶으면 아래처럼 하면 돼요:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 이미지는 Next.js에서 페이지를 간단하게 만드는 예시 코드와 관련된 내용입니다.\n\n```js\nexport default function Page() {\n  return \u003ch1\u003eHello Next.js!\u003c/h1\u003e;\n}\n```\n\n위 예시처럼 기본적으로 Next.js에서는 함수를 작성해서 간단한 페이지를 만들 수 있어요.\n\n---\n\n## 레이아웃 만들기 (Creating a layout)\n\n레이아웃(layout)이란 여러 페이지에서 공통으로 쓰이는 UI를 의미해요. 예를 들어 네비게이션 바, 사이드 메뉴, 푸터 같은 부분들이 여기에 해당하겠죠.\n\nNext.js의 장점 중 하나는 네비게이션을 할 때 레이아웃이 다시 렌더링되지 않고, 상태를 유지하며 대화형을 계속 유지한다는 점이에요. 덕분에 페이지가 바뀌어도 빠르고 자연스러운 사용자 경험을 제공할 수 있어요.\n\n\u003e **추가 팁!**  \n\u003e 레이아웃을 만들 땐 `app/layout.js` 파일을 활용하면 좋아요. 이 파일에 공통 UI를 정의하면, 그 하위에 있는 모든 페이지에서 레이아웃이 자동으로 적용됩니다. 그래서 중복 코드를 줄이고, 전체 애플리케이션의 구조를 깔끔하게 관리할 수 있답니다.\n\n---\n\n여기까지 Next.js에서 어떻게 간단한 페이지를 만들고, 공통 UI를 위해 레이아웃을 활용하는지 살펴봤어요. 다음에는 레이아웃을 실제로 구현하는 방법에 대해 더 깊게 다뤄볼게요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n리액트에서 레이아웃(Layout)을 정의하는 방법에 대해 이야기해볼게요. 기본적으로 레이아웃 파일에서 React 컴포넌트를 default export 하면 레이아웃으로 사용할 수 있어요. 이 컴포넌트는 꼭 `children` prop을 받아야 하는데요, 이 `children`이 바로 각각의 페이지나 다른 레이아웃이 될 수 있답니다.\n\n예를 들어, `app` 디렉토리 안에 레이아웃 파일을 만들어서, 그 안에 index 페이지를 자식으로 받는 레이아웃을 만들어보는 거죠.\n\n아래 코드를 보면 어떻게 구성되는지 감이 잡히실 거예요.\n\n```jsx\nexport default function DashboardLayout({ children }: { children: React.ReactNode }) {\n  return (\n    \u003chtml lang=\"en\"\u003e\n      \u003cbody\u003e\n        {/* 레이아웃 UI 영역 */}\n        {/* 여기에 children을 넣어서 페이지나 중첩된 레이아웃을 렌더링 */}\n        \u003cmain\u003e{children}\u003c/main\u003e\n      \u003c/body\u003e\n    \u003c/html\u003e\n  );\n}\n```\n\n이렇게 레이아웃 컴포넌트를 만들면, `DashboardLayout`이 감싸는 모든 페이지는 이 레이아웃 UI 안에 렌더링됩니다. 즉, 공통적으로 적용하고 싶은 UI(헤더, 사이드바, 푸터 등)를 레이아웃 컴포넌트 안에 넣으면 유지보수가 훨씬 편해지죠.\n\n더불어, Next.js 13 이상에서는 `app` 폴더 기반 라우팅 시스템에서 이런 레이아웃 정의가 기본으로 사용되니 꼭 익혀두면 좋아요!\n\n참고로, `children`에 들어가는 값이 또 다른 레이아웃일 수도 있어서, 레이아웃을 중첩해서 사용할 수 있다는 점도 기억해두세요.\n\n필요하다면, 레이아웃에 헤더, 네비게이션 바 등을 넣어 사용자 경험이 일관되게 만들어주는 용도로 아주 유용하답니다!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위에 나오는 레이아웃을 '루트 레이아웃(root layout)'이라고 부르는데요, 그 이유는 앱 디렉토리의 최상단(루트)에 정의되기 때문이에요. 루트 레이아웃은 앱에 꼭 필요하고, html 태그와 body 태그를 반드시 포함해야 한다는 점도 기억하세요.\n\n## 중첩 네스트드 라우트(Nested Route) 만들기\n\n네스트드 라우트는 여러 URL 세그먼트로 구성된 경로를 의미해요. 쉽게 말해, URL이 여러 부분으로 나뉘어 있는 구조죠. 예를 들어서, `/blog/[slug]` 라우트는 세 개의 세그먼트로 이루어져 있어요:\n\n| 세그먼트 종류 | 설명                                | 예시     |\n| ------------- | ----------------------------------- | -------- |\n| 루트 세그먼트 | 최상위 경로                         | `/`      |\n| 중간 세그먼트 | 중간 디렉토리경로                   | `blog`   |\n| 리프 세그먼트 | 마지막 세그먼트(동적 세그먼트 포함) | `[slug]` |\n\n여기서 `[slug]`는 동적 세그먼트를 의미하는데, 예를 들어 특정 블로그 글의 고유 주소 부분을 표현할 때 사용돼요.\n\n추가로, 중첩 라우팅을 활용하면 UI를 더 효율적으로 구성할 수 있어요. 예를 들어 공통 레이아웃을 중간 세그먼트인 `blog` 아래에 두고, 각 글은 그 레이아웃 안에서 화면에 표시하는 식이죠. Next.js나 React 기반 프레임워크에서 이런 네스트드 라우팅을 지원해주니까 활용해보시면 좋아요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 라우트를 어떻게 만들고 관리하는지 간단하게 알려줄게요!\n\n---\n\n### Next.js 라우팅 기본 개념\n\n- **폴더**: URL 경로(segment)를 정의하는 역할을 해요.\n- **파일**: 예를 들어 `page.tsx`나 `layout.tsx` 같은 파일은 해당 경로(segment)에 보여질 UI를 담당해요.\n\n---\n\n### 중첩 라우트 만드는 법\n\n중첩 라우트를 만들고 싶으면 폴더 안에 폴더를 계속 넣으면 돼요.\n\n예를 들어, `/blog` 라는 경로를 만들고 싶다고 하면,  \n`app` 폴더 안에 `blog`라는 폴더를 만들면 됩니다.\n\n그리고 `/blog` 경로에서 보여줄 페이지를 만들려면, `blog` 폴더 안에 `page.tsx` 파일을 만들어야 해요.  \n이 `page.tsx`가 실제로 `/blog` 경로에서 렌더링될 UI를 담당하죠.\n\n---\n\n### 구조 예시\n\n| 경로                | 설명                                  |\n| ------------------- | ------------------------------------- |\n| `app/blog/`         | `/blog` 경로(라우트)의 폴더           |\n| `app/blog/page.tsx` | `/blog` 경로에 보여질 페이지 컴포넌트 |\n\n---\n\n### 추가 꿀팁!\n\n- Next.js 13부터는 `app` 디렉토리 기반의 라우팅이 기본이에요. 이전의 `pages` 폴더 스타일보다 훨씬 직관적이고, 레이아웃 관리도 편해졌어요.\n- `layout.tsx` 파일을 같은 위치 혹은 상위 폴더에 두면, 그 경로에 공통으로 적용되는 레이아웃을 만들 수 있답니다.\n- 예를 들어, `app/blog/layout.tsx`를 만들면 `/blog` 아래 모든 페이지가 공통 레이아웃을 가지게 되죠.\n\n---\n\n이미지로 보면 이런 느낌이에요!\n\n![폴더 구조와 page.tsx](/TIL/assets/img/2025-04-22-Howtocreatelayoutsandpages_2.png)  \n(※ 실제 이미지 주소가 다르다면 알맞게 수정해 주세요.)\n\n---\n\nNext.js로 라우팅 구조 짤 때는 folder = URL segment, 그리고 그 segment에 보여줄 UI는 파일로 관리한다!  \n이 공식만 기억하면 중첩 라우팅도 쉽게 할 수 있으니까 꼭 익혀두세요! 😊\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n계속해서 중첩 폴더를 만들어 경로를 중첩해서 관리할 수 있어요. 예를 들어, 블로그 개별 포스트 페이지를 만들고 싶다면 `blog` 폴더 안에 `[slug]`라는 이름의 폴더를 새로 만들고, 그 안에 `page.js` 파일을 추가하면 됩니다.\n\n아래처럼 기본적으로 `generateStaticParams` 함수를 만들어서 어떤 슬러그들이 있을지 미리 정의해줄 수도 있어요.\n\n```js\nfunction generateStaticParams() {\n  // 예: 블로그 글 슬러그들을 담아 리턴\n  return [{ slug: \"my-first-post\" }, { slug: \"hello-world\" }];\n}\n\nexport default function Page() {\n  return \u003ch1\u003eHello, Blog Post Page!\u003c/h1\u003e;\n}\n```\n\n이런 식으로 슬러그를 동적으로 받아서 각각의 블로그 포스트 페이지를 만들 수 있답니다.\n\n---\n\n📌 여기서 잠깐!  \n`[slug]` 폴더명에서 대괄호(`[]`)는 동적 라우트를 의미해요. 즉, URL 경로에 따라 달라지는 부분을 변수처럼 처리한다는 거죠. 예를 들어 `/blog/my-first-post`나 `/blog/hello-world` 같은 주소가 들어오면 각각에 맞는 슬러그 값을 받아 페이지를 렌더링하는 식이에요.\n\n정리하면, 폴더 구조가 URL 구조와 일치하므로 직관적으로 관리하고, 동적 라우팅 덕분에 다양한 경로를 손쉽게 처리할 수 있어요.\n\n이걸 응용하면 포트폴리오, 쇼핑몰 상품 페이지, 유저 프로필 등 여러 상황에 딱 맞는 동적 페이지를 편하게 만들 수 있겠죠? 😄\n\n---\n\n### 추가 팁: `generateStaticParams` 활용하기\n\n- 이 함수는 빌드 시점에 호출되어, 미리 생성할 정적 경로를 알려줍니다.\n- 블로그 글처럼 내용이 자주 바뀌지 않는 경우 미리 정적으로 빌드해두면 성능이 엄청 좋아져요.\n- 반대로 동적으로 내용을 자주 바꾸는 경우엔 서버 사이드 렌더링이나 ISR(Incremental Static Regeneration) 등의 기법도 고려해보세요!\n\n이상으로 Next.js 앱 라우팅에서 중첩 폴더와 동적 라우트 설정하는 법을 간단히 알아봤어요. 궁금한 점 있으면 언제든 질문 주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n폴더 이름을 대괄호([])로 감싸면 예를 들어 [slug]처럼, 이 부분이 동적 라우트 세그먼트(dynamic route segment)가 돼서 데이터 기반으로 여러 페이지를 쉽게 만들어줄 수 있어요. 블로그 포스트나 상품 페이지처럼 같은 구조지만 내용이 다른 여러 페이지를 만들 때 정말 유용하답니다.\n\n## 레이아웃 중첩(Nesting layouts)\n\n기본적으로 폴더 구조에 따라 레이아웃도 중첩돼요. 즉, 부모 레이아웃이 자식 레이아웃을 children 프로퍼티로 감싸는 형태라는 뜻이죠. 이걸 활용해서 특정 라우트(폴더)마다 레이아웃을 따로 지정할 수 있어요.\n\n예를 들어, `/blog` 경로를 위한 레이아웃을 만들고 싶다면 blog 폴더 안에 layout 파일을 추가하면 됩니다. 이렇게 하면 `/blog`와 그 하위 페이지에만 적용되는 레이아웃을 별도로 관리할 수 있어서 더 체계적이고 유지보수도 쉬워져요.\n\n더 덧붙이자면, 이 방식은 여러 페이지의 공통 UI(예: 네비게이션 바, 푸터 등)를 재사용할 때 아주 효과적이에요. 레이아웃을 잘 설계해 놓으면 페이지 개발 속도가 확실히 빨라지고, UI 일관성도 자연스럽게 유지할 수 있답니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n앱을 만들 때 레이아웃을 중첩해서 사용하는 경우가 많아요. 위 코드에서는 `BlogLayout`이라는 컴포넌트를 정의했는데요, 이 컴포넌트가 `children`을 받아서 `\u003csection\u003e` 태그로 감싸고 있죠. 이건 블로그 관련 페이지만 따로 꾸밀 때 유용해요.\n\n예를 들어, 루트 레이아웃인 `app/layout.js`가 전체 앱을 감싸고, 그 안에 `app/blog/layout.js`(즉, 위에서 정의한 `BlogLayout`)가 블로그 관련 페이지를 감싸는 구조라고 생각하면 됩니다. 그리고 실제 블로그 메인 페이지(`app/blog/page.js`)와 개별 포스트 페이지(`app/blog/[slug]/page.js`)가 그 안에 들어가는 식이죠.\n\n이렇게 하면 기본 레이아웃은 유지하면서도, 특정 섹션(여기서는 블로그)만 별도로 스타일이나 구성을 다르게 할 수 있어서 훨씬 관리하기 편해집니다.\n\n---\n\n## 페이지 간 링크 연결하기\n\n페이지들을 만들었으면 이제 서로 연결해줘야겠죠? Next.js에서는 `\u003cLink\u003e` 컴포넌트를 사용해서 페이지 간 이동을 쉽게 할 수 있어요. 예를 들어 블로그 리스트에서 각각의 포스트 페이지로 이동하고 싶을 때 이렇게 할 수 있습니다:\n\n```jsx\nimport Link from \"next/link\";\n\nexport default function BlogList({ posts }) {\n  return (\n    \u003cul\u003e\n      {posts.map((post) =\u003e (\n        \u003cli key={post.slug}\u003e\n          \u003cLink href={`/blog/${post.slug}`}\u003e{post.title}\u003c/Link\u003e\n        \u003c/li\u003e\n      ))}\n    \u003c/ul\u003e\n  );\n}\n```\n\n위 예제는 간단한 블로그 리스트 컴포넌트인데요, `posts` 배열을 받아서 각 포스트 제목에 맞게 링크를 걸어줍니다. 이렇게 하면 Next.js가 자동으로 사전 렌더링과 클라이언트 측 네비게이션을 최적화해줘서 사용자 경험이 훨씬 좋아져요.\n\n---\n\n### 팁!\n\n- 중첩 레이아웃을 쓸 때는 각 레이아웃 파일 이름과 위치가 중요해요. 예를 들어 `app/blog/layout.js`는 `/blog` 경로 하위 모든 페이지에 자동으로 적용됩니다.\n- 레이아웃 안에 헤더나 푸터를 넣어서 반복되는 UI를 한 번만 작성해도 효율적입니다.\n- 링크를 걸 때는 가능한 `next/link`를 써주세요. `\u003ca\u003e` 태그만 쓰면 페이지 전환 시 전체가 새로고침돼서 느릴 수 있어요.\n\n이제 여러분도 레이아웃을 중첩해서 더 구조화된 Next.js 앱을 쉽게 만들 수 있어요! 혹시 더 궁금한 점 있으면 언제든 질문해 주세요~\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 페이지 간 이동을 할 때는 `Link` 컴포넌트를 사용하면 아주 편리해요. `Link`는 HTML의 기본 `a` 태그를 확장한 컴포넌트로, 미리 페이지를 불러오는(prefetching) 기능과 클라이언트 사이드 네비게이션을 지원해줘서 사용자 경험을 훨씬 부드럽게 만들어줍니다.\n\n예를 들어, 블로그 글 목록을 만들고 싶다면, `next/link`에서 `Link`를 임포트(import)한 다음, 각 글의 경로를 `href` 속성에 넘겨주면 돼요.\n\n```js\nimport Link from \"next/link\";\n\nexport default async function PostList() {\n  const posts = await getPosts();\n\n  return (\n    \u003cul\u003e\n      {posts.map((post) =\u003e (\n        \u003cli key={post.slug}\u003e\n          \u003cLink href={`/posts/${post.slug}`}\u003e{post.title}\u003c/Link\u003e\n        \u003c/li\u003e\n      ))}\n    \u003c/ul\u003e\n  );\n}\n```\n\n여기서 주목할 점은, `Link` 컴포넌트는 내부적으로 HTML의 `\u003ca\u003e` 태그를 사용하지만, Next.js가 최적화해주는 사전 로딩과 클라이언트 사이드 라우팅 기능을 추가로 제공한다는 것이에요.\n\n\u003e 참고로, Next.js의 공식 문서에서는 페이지 이동 시 `Link`를 쓰는 것을 권장합니다. 하지만 더 세밀한 라우팅 제어가 필요할 때는 `useRouter` 훅을 사용해 프로그래밍 방식으로 라우팅할 수도 있어요.\n\n더불어 `Link` 내부에 `\u003ca\u003e` 태그를 직접 감싸는 예전 방식도 있었는데, Next.js 13버전부터는 `href`를 바로 `Link`에 넘겨주고 텍스트나 요소를 자식으로 넣는 방식이 표준이에요. 혹시 이전 문서를 참고한다면 이 부분 조금 헷갈릴 수 있으니 주의하세요!\n\n간단하게 정리하면:\n\n| 특징                         | 설명                                                   |\n| ---------------------------- | ------------------------------------------------------ |\n| Link 컴포넌트                | HTML `\u003ca\u003e` 태그에 라우팅 기능이 추가된 컴포넌트        |\n| prefetching                  | 화면에 보이기 전에 미리 페이지를 불러와 빠른 이동 지원 |\n| 클라이언트 사이드 네비게이션 | 전체 페이지 새로고침 없이 부드럽게 라우팅              |\n| useRouter 훅 사용            | 프로그래밍 방식으로 라우팅을 제어할 때 활용 가능       |\n\n이처럼 Next.js에서는 기본적으로 `Link`를 활용해 사용자에게 자연스러운 페이지 전환 경험을 제공하는 게 가장 깔끔한 방법입니다!\n","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":11},{"title":"Next.js 15 프로젝트 폴더 설계 방법","description":"","date":"2025-04-22 00:55","slug":"2025-04-22-Projectstructureandorganization","content":"\n# 프로젝트 구조와 조직 방법\n\n이번 글에서는 Next.js에서 사용하는 폴더와 파일 규칙에 대해 한눈에 정리해 드리고, 프로젝트를 어떻게 잘 구성할지에 대한 팁도 함께 알려드릴게요.\n\n## 폴더와 파일 규칙\n\n### 최상위 폴더\n\n최상위 폴더는 애플리케이션 코드와 정적 자산(이미지, 폰트 등)을 구분해서 관리할 때 사용해요.\n\n![프로젝트 구조 이미지](/TIL/assets/img/2025-04-22-Projectstructureandorganization_0.png)\n\n| 폴더 이름                                                                                  | 설명                                                 |\n| ------------------------------------------------------------------------------------------ | ---------------------------------------------------- |\n| [`app`](https://nextjs.org/docs/app/building-your-application/routing)                     | App Router (Next.js의 새로운 라우팅 방식)            |\n| [`pages`](https://nextjs.org/docs/pages/building-your-application/routing)                 | Pages Router (기존 라우팅 방식)                      |\n| [`public`](https://nextjs.org/docs/app/building-your-application/optimizing/static-assets) | 외부에 서비스할 정적 자산 모음                       |\n| [`src`](https://nextjs.org/docs/app/building-your-application/configuring/src-directory)   | 옵션! 소스코드를 별도 관리하고 싶을 때 사용하는 폴더 |\n\n### 최상위 파일\n\n(여기서부터 다음 내용이 이어집니다.)\n\n---\n\n폴더 구조를 깔끔하게 정리하면 프로젝트 유지보수가 훨씬 수월해져요. 너무 복잡하게 만들지 말고, 자신의 프로젝트에 맞게 심플하게 가져가는 게 가장 좋아요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 최상위(Top-level) 파일들은 여러분의 애플리케이션을 설정하고, 의존성을 관리하며, 미들웨어를 실행하고, 모니터링 도구를 통합하고, 환경 변수를 정의하는 데 사용돼요. 그러니까 프로젝트의 중요한 설정들이 여기서 모여있다고 보면 됩니다.\n\n다음은 각 파일들이 어떤 역할을 하는지 간단히 정리한 표에요:\n\n| 파일명                                                                                                        | 설명                            |\n| ------------------------------------------------------------------------------------------------------------- | ------------------------------- |\n| [`next.config.js`](https://nextjs.org/docs/app/api-reference/config/next-config-js)                           | Next.js 설정 파일               |\n| [`package.json`](https://nextjs.org/docs/app/getting-started/installation#manual-installation)                | 프로젝트 의존성과 스크립트 관리 |\n| [`instrumentation.ts`](https://nextjs.org/docs/app/building-your-application/optimizing/instrumentation)      | OpenTelemetry 및 계측 관련 파일 |\n| [`middleware.ts`](https://nextjs.org/docs/app/building-your-application/routing/middleware)                   | Next.js 요청 미들웨어 파일      |\n| [`.env`](https://nextjs.org/docs/app/building-your-application/configuring/environment-variables)             | 환경 변수 설정 파일             |\n| [`.env.local`](https://nextjs.org/docs/app/building-your-application/configuring/environment-variables)       | 로컬 환경 변수 설정             |\n| [`.env.production`](https://nextjs.org/docs/app/building-your-application/configuring/environment-variables)  | 프로덕션 환경 변수 설정         |\n| [`.env.development`](https://nextjs.org/docs/app/building-your-application/configuring/environment-variables) | 개발 환경 변수 설정             |\n| [`.eslintrc.json`](https://nextjs.org/docs/app/api-reference/config/eslint)                                   | ESLint 설정 파일                |\n| `.gitignore`                                                                                                  | Git에서 무시할 파일/폴더 목록   |\n| `next-env.d.ts`                                                                                               | Next.js용 TypeScript 선언 파일  |\n| `tsconfig.json`                                                                                               | TypeScript 설정 파일            |\n| `jsconfig.json`                                                                                               | JavaScript 설정 파일            |\n\n---\n\n### 라우팅 관련 파일\n\nNext.js에서 앱 라우팅을 구성하는 데 사용되는 파일들을 모아봤어요:\n\n| 파일명                                                                                          | 확장자            | 설명                          |\n| ----------------------------------------------------------------------------------------------- | ----------------- | ----------------------------- |\n| [`layout`](https://nextjs.org/docs/app/api-reference/file-conventions/layout)                   | .js / .jsx / .tsx | 레이아웃 컴포넌트             |\n| [`page`](https://nextjs.org/docs/app/api-reference/file-conventions/page)                       | .js / .jsx / .tsx | 페이지 컴포넌트               |\n| [`loading`](https://nextjs.org/docs/app/api-reference/file-conventions/loading)                 | .js / .jsx / .tsx | 로딩중 UI 컴포넌트            |\n| [`not-found`](https://nextjs.org/docs/app/api-reference/file-conventions/not-found)             | .js / .jsx / .tsx | 404 페이지 UI                 |\n| [`error`](https://nextjs.org/docs/app/api-reference/file-conventions/error)                     | .js / .jsx / .tsx | 에러 UI                       |\n| [`global-error`](https://nextjs.org/docs/app/api-reference/file-conventions/error#global-error) | .js / .jsx / .tsx | 글로벌 에러 UI                |\n| [`route`](https://nextjs.org/docs/app/api-reference/file-conventions/route)                     | .js / .ts         | API 엔드포인트                |\n| [`template`](https://nextjs.org/docs/app/api-reference/file-conventions/template)               | .js / .jsx / .tsx | 다시 렌더링되는 레이아웃      |\n| [`default`](https://nextjs.org/docs/app/api-reference/file-conventions/default)                 | .js / .jsx / .tsx | 병렬 라우트용 fallback 페이지 |\n\n---\n\n### 중첩 라우트 (Nested routes)\n\nNext.js에서는 폴더 구조를 통해 중첩된 라우트를 쉽게 표현할 수 있어요.\n\n| 폴더 구조       | 설명                   |\n| --------------- | ---------------------- |\n| `folder`        | 하나의 라우트 세그먼트 |\n| `folder/folder` | 중첩된 라우트 세그먼트 |\n\n---\n\n### 동적 라우트 (Dynamic routes)\n\n동적 라우팅은 경로에 가변 요소가 포함될 때 사용돼요.\n\n| 경로 표현법                                                                                                                 | 설명                                         |\n| --------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------- |\n| [`[folder]`](https://nextjs.org/docs/app/building-your-application/routing/dynamic-routes#convention)                       | 동적 라우트 세그먼트                         |\n| [`[...folder]`](https://nextjs.org/docs/app/building-your-application/routing/dynamic-routes#catch-all-segments)            | 모든 하위 경로를 잡아내는 catch-all 세그먼트 |\n| [`[[...folder]]`](https://nextjs.org/docs/app/building-your-application/routing/dynamic-routes#optional-catch-all-segments) | 선택적인 catch-all 세그먼트                  |\n\n---\n\n블로그를 보시는 여러분도 Next.js를 쓸 때 이 파일들과 폴더 구조들을 잘 알고 나면, 프로젝트를 더 효율적이고 이해하기 쉽게 관리할 수 있습니다! 필요할 때마다 이 표를 참고하세요~\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### Route Groups와 private 폴더\n\n| 구분       | 설명                                             |\n| ---------- | ------------------------------------------------ |\n| `(folder)` | 라우팅에 영향을 주지 않고 라우트를 그룹화        |\n| `_folder`  | 해당 폴더와 모든 하위 세그먼트를 라우팅에서 제외 |\n\n### 병렬(Parallel) 및 인터셉트(Intercepted) 라우트\n\n| 구분             | 설명                            |\n| ---------------- | ------------------------------- |\n| `@folder`        | 네임드 슬롯(named slot)         |\n| `(.)folder`      | 같은 레벨을 인터셉트(intercept) |\n| `(..)folder`     | 한 단계 위 레벨을 인터셉트      |\n| `(..)(..)folder` | 두 단계 위 레벨을 인터셉트      |\n| `(...)folder`    | 루트에서부터 인터셉트           |\n\n### 메타데이터 파일 규칙\n\n#### 앱 아이콘(App icons)\n\n| 이름         | 확장자                                  | 설명                         |\n| ------------ | --------------------------------------- | ---------------------------- |\n| `favicon`    | `.ico`                                  | 파비콘(favicon) 파일         |\n| `icon`       | `.ico`, `.jpg`, `.jpeg`, `.png`, `.svg` | 앱 아이콘 파일               |\n| `icon`       | `.js`, `.ts`, `.tsx`                    | 코드로 생성된 앱 아이콘      |\n| `apple-icon` | `.jpg`, `.jpeg`, `.png`                 | 애플 앱 아이콘 파일          |\n| `apple-icon` | `.js`, `.ts`, `.tsx`                    | 코드로 생성된 애플 앱 아이콘 |\n\n---\n\n조금 어렵게 느껴질 수 있는 routing 영역에서 폴더명을 활용하는 여러 가지 문법과 파일명 규칙을 정리해봤어요.  \n특히 (folder) 같이 라우팅에는 영향을 주지 않으면서 내부 조직화용으로 많이 쓰이고요, `_folder`는 아예 routing 대상에서 제외하는 용도로 쓴답니다.  \nParallel과 Intercept 라우트는 고급 기능인데, 슬래시 하나, 두 개 등에 따라 라우팅 경로를 제어할 수 있어서 원하는 맞춤 페이지 구성에 도움을 줘요.  \n마지막으로 메타데이터 쪽은 favicon이나 app icon 관련 파일명과 확장자를 정해놓은 내용이니 프로젝트 셋업할 때 참고하면 좋습니다!\n\n필요하시면 더 자세한 설명도 알려드릴게요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 Open Graph 이미지, Twitter 이미지, 그리고 SEO 관련 파일 종류와 확장자, 그리고 용도에 대한 표입니다. Markdown 형식으로 정리해 봤어요!\n\n### Open Graph \u0026 Twitter 이미지 파일\n\n| 이름                                                                                                                                        | 확장자                          | 설명                              |\n| ------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------- | --------------------------------- |\n| [opengraph-image](https://nextjs.org/docs/app/api-reference/file-conventions/metadata/opengraph-image#opengraph-image)                      | `.jpg`, `.jpeg`, `.png`, `.gif` | Open Graph 이미지 파일            |\n| [opengraph-image](https://nextjs.org/docs/app/api-reference/file-conventions/metadata/opengraph-image#generate-images-using-code-js-ts-tsx) | `.js`, `.ts`, `.tsx`            | 코드로 생성하는 Open Graph 이미지 |\n| [twitter-image](https://nextjs.org/docs/app/api-reference/file-conventions/metadata/opengraph-image#twitter-image)                          | `.jpg`, `.jpeg`, `.png`, `.gif` | Twitter에 보여줄 이미지 파일      |\n| [twitter-image](https://nextjs.org/docs/app/api-reference/file-conventions/metadata/opengraph-image#generate-images-using-code-js-ts-tsx)   | `.js`, `.ts`, `.tsx`            | 코드로 생성하는 Twitter 이미지    |\n\n### SEO 관련 파일\n\n| 이름                                                                                                                         | 확장자       | 설명                        |\n| ---------------------------------------------------------------------------------------------------------------------------- | ------------ | --------------------------- |\n| [sitemap](https://nextjs.org/docs/app/api-reference/file-conventions/metadata/sitemap#sitemap-files-xml)                     | `.xml`       | 사이트맵 파일               |\n| [sitemap](https://nextjs.org/docs/app/api-reference/file-conventions/metadata/sitemap#generating-a-sitemap-using-code-js-ts) | `.js`, `.ts` | 코드로 생성하는 사이트맵    |\n| [robots](https://nextjs.org/docs/app/api-reference/file-conventions/metadata/robots#static-robotstxt)                        | `.txt`       | robots.txt 파일             |\n| [robots](https://nextjs.org/docs/app/api-reference/file-conventions/metadata/robots#generate-a-robots-file)                  | `.js`, `.ts` | 코드로 생성하는 robots 파일 |\n\n---\n\n## 프로젝트 구성하기\n\nNext.js에서는 프로젝트 파일을 어떻게 배치할지는 자유롭게 선택할 수 있어요. 딱 정해진 규칙이 있는 건 아니지만, 다음과 같은 기능들이 있어서 편리하게 구성할 수 있답니다.\n\n### 컴포넌트 계층 구조\n\nNext.js 내에서 특별한 이름의 파일들은 아래와 같은 계층 구조를 따라 렌더링됩니다:\n\n- `layout.js` — 페이지 레이아웃 정의\n- `template.js` — 페이지 템플릿\n- `error.js` — React 오류 경계(Error Boundary) 처리\n- `loading.js` — React Suspense 경계로 로딩 UI\n- `not-found.js` — 404 페이지용 에러 경계\n- `page.js` 혹은 nested `layout.js` — 실제 페이지 컴포넌트\n\n이 계층 덕분에 페이지 단위 컴포넌트가 어떻게 조합되고 재사용되는지 명확하게 구조화할 수 있어요. 이를 활용해서 여러분만의 깔끔한 프로젝트 구조를 만들어 보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여러분, 오늘은 Next.js 앱 디렉토리 구조와 라우트 구성에 대해 알아볼게요. 복잡해 보일 수 있지만, 하나씩 차근차근 이해하면 실제로 프로젝트를 더 효율적으로 관리할 수 있답니다.\n\n---\n\n### 라우트 컴포넌트는 계층적으로 렌더링된다\n\n우리가 만든 컴포넌트들은 중첩된 라우트(nested routes)에서 재귀적으로 렌더링돼요. 쉽게 말해, 특정 라우트의 컴포넌트는 그 부모 라우트 컴포넌트 안에 중첩되는 구조입니다.\n\n예를 들어, `/dashboard/settings` 같은 경로가 있다면 `dashboard` 컴포넌트가 먼저 렌더링되고, 그 안에 `settings` 컴포넌트가 들어가는 식이에요.\n\n---\n\n### 라우트는 폴더 구조로 정의한다 — 콜로케이션(colocation)\n\nNext.js 앱 디렉토리 안에서, **중첩된 폴더가 라우트 구조를 뜻해요**. 폴더 하나가 하나의 라우트 세그먼트(route segment)를 나타내고, 이 세그먼트가 URL 경로의 일부로 매핑됩니다.\n\n하지만 중요한 점! 폴더만 있다고 해서 그 경로가 바로 “공개적으로” 접근 가능한 페이지가 되진 않아요. 그 폴더 안에 `page.js` 혹은 `route.js` 파일이 있어야 비로소 해당 라우트가 활성화되고, 방문할 수 있답니다.\n\n---\n\n### 실제 클라이언트에 전송되는 것은?\n\n라우트가 공개되어 있어도, 클라이언트에 보내지는 건 그 라우트의 `page.js`나 `route.js`에서 반환하는 콘텐츠뿐이에요. 부모 라우트 컴포넌트가 중첩되어 렌더링되더라도, 클라이언트에게는 각 세그먼트의 `page.js` 결과물만 전달되니까 참고하세요!\n\n---\n\n정리하면,\n\n- 라우트 구조는 폴더 중첩으로 표현한다.\n- 해당 폴더에 `page.js`나 `route.js` 파일이 있어야 라우트가 활성화된다.\n- 중첩된 라우트는 부모-자식 구조로 렌더링된다.\n- 클라이언트에는 각 세그먼트 라우트 파일에서 반환한 콘텐츠만 전달된다.\n\n이런 구조 덕분에 프로젝트 내 파일과 라우트가 자연스럽게 연관되니, 관리도 쉽고 개발 속도도 빨라진답니다. 여러분도 프로젝트에 적용해 보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n앱 디렉터리 내에서 라우트 구간(route segments) 안에 프로젝트 파일들을 안전하게 함께 둘 수 있다는 뜻이에요. 이렇게 하면 파일들이 실수로 라우트로 잡히는 일을 방지할 수 있답니다.\n\n---\n\n\u003e 참고할 점: 프로젝트 파일들을 꼭 app 폴더 안에 넣어야 하는 건 아니에요. 원한다면 app 디렉터리 밖에 보관해도 무방합니다.\n\n---\n\n### Private 폴더 만들기\n\n폴더 이름 앞에 언더스코어(\\_)를 붙여서 private 폴더를 만들 수 있어요. 예를 들면 `_folderName` 같은 식이죠.\n\n이렇게 하면 라우팅시스템이 이 폴더와 그 하위 폴더들을 무시하니까, 라우트로 작동하지 않는 구현 세부 사항용 폴더로 쓸 수 있어요.\n\n---\n\n관련 그림 첨부해 뒀으니 한 번 참고해 보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n앱 디렉터리 내 파일은 기본적으로 안전하게 한 곳에 모아둘 수 있어서 private 폴더가 꼭 필요한 건 아니에요. 하지만 private 폴더가 있으면 다음과 같은 점에서 도움이 됩니다:\n\n- UI 로직과 라우팅 로직을 분리할 수 있어요.\n- 프로젝트 내 파일 구성과 Next.js 생태계 전반에서 내부 파일을 일관성 있게 정리할 수 있죠.\n- 코드 에디터에서 파일을 분류하고 그룹화하기 쉬워요.\n- 앞으로 나올 Next.js 파일 네이밍 규칙과 겹칠 수 있는 이름 충돌을 방지할 수 있습니다.\n\n\u003e 참고!\n\u003e 비록 Next.js 공식 프레임워크 규칙은 아니지만, private 폴더 외부에 있는 파일들도 언더스코어(\\_) 패턴을 사용해서 \"private\" 임을 표시하는 방식을 고민해볼 수 있어요.  \n\u003e URL 세그먼트가 언더스코어로 시작해야 한다면 URL 인코딩된 형태인 `%5F`를 앞에 붙이면 됩니다. 예를 들어 `%5FfolderName`처럼요.  \n\u003e 만약 private 폴더를 사용하지 않는다면, 예상치 못한 이름 충돌을 막기 위해 Next.js의 특별한 파일 네이밍 규칙을 잘 숙지하는 게 좋겠죠.\n\n### 라우트 그룹(Route groups)\n\n라우트 그룹은 폴더 이름을 괄호로 감싸서 만듭니다: `(folderName)`\n\n이렇게 하면 이 폴더는 단순히 파일 정리를 위한 용도이고, 실제 라우트 URL 경로에는 포함되지 않아요.\n\n![라우트 그룹 예시 이미지](/TIL/assets/img/2025-04-22-Projectstructureandorganization_7.png)\n\n라우트 그룹이 유용한 점은 다음과 같습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 사이트 섹션, 의도, 혹은 팀 단위로 라우트를 정리하기 (예: 마케팅 페이지, 관리자 페이지 등)\n- 같은 라우트 세그먼트 레벨에서 중첩 레이아웃 활성화하기:\n\n  - 같은 세그먼트 내에 여러 개의 중첩 레이아웃 만들기 (여러 개의 루트 레이아웃 포함)\n  - 공통 세그먼트 내 일부 라우트에만 레이아웃 추가하기\n\n- 같은 세그먼트 내에 여러 개의 중첩 레이아웃 만들기 (여러 개의 루트 레이아웃 포함)\n- 공통 세그먼트 내 일부 라우트에만 레이아웃 추가하기\n\n---\n\n### src 디렉토리\n\nNext.js는 app을 포함한 애플리케이션 코드를 선택적으로 `src` 디렉토리 안에 저장하는 것을 지원합니다. 이렇게 하면 프로젝트 루트에 주로 위치하는 설정 파일과 애플리케이션 코드를 깔끔하게 분리할 수 있습니다.\n\n![Project Structure](/TIL/assets/img/2025-04-22-Projectstructureandorganization_8.png)\n\n---\n\n### 예제\n\n아래 섹션은 흔히 사용하는 전략들을 아주 간략히 정리한 내용입니다. 가장 중요한 점은 여러분과 팀에게 맞는 방식을 선택하고, 프로젝트 전반에 걸쳐 일관성 있게 유지하는 것입니다.\n\n\u003e 참고: 아래 예시에서는 `components`와 `lib` 폴더를 일반적인 예시 폴더명으로 사용했으며, 이들의 이름은 프레임워크에서 특별한 의미를 가진 것은 아닙니다. 프로젝트에 따라 `ui`, `utils`, `hooks`, `styles` 등 다양한 이름을 사용해도 무방합니다.\n\n---\n\n#### app 폴더 밖에 프로젝트 파일 저장하기\n\n| 전략 구분               | 설명                                                               |\n| ----------------------- | ------------------------------------------------------------------ |\n| app 폴더 분리           | app 폴더와는 별개로 components, lib 같은 폴더를 루트 혹은 src에 둠 |\n| 역할별 폴더 구성        | 컴포넌트, 유틸리티, 훅 등을 역할에 맞춰 분리함                     |\n| 팀/기능별으로 폴더 분리 | 팀 혹은 기능 단위로 폴더를 나눠 관리함                             |\n\n---\n\n위와 같은 방법으로 프로젝트를 체계적으로 구성하면 협업 효율이 올라가고 유지보수가 쉬워집니다. 꼭 정답은 없으니 팀 상황에 맞게 유연하게 적용해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 전략은 애플리케이션 코드를 프로젝트 루트의 공유 폴더에 모두 저장하고, app 디렉터리는 오로지 라우팅 용도로만 사용하는 방식이에요.\n\n![프로젝트 구조 1](/TIL/assets/img/2025-04-22-Projectstructureandorganization_9.png)\n\n#### app 내부의 최상위 폴더에 프로젝트 파일 저장하기\n\n이 전략은 애플리케이션 코드를 app 디렉터리 루트에 공유 폴더 형태로 모두 저장하는 방식이에요.\n\n![프로젝트 구조 2](/TIL/assets/img/2025-04-22-Projectstructureandorganization_10.png)\n\n#### 기능이나 라우트별로 프로젝트 파일 분리하기\n\n이 전략은 전역에서 공유되는 애플리케이션 코드는 app 디렉터리 루트에 두고, 좀 더 특정한 애플리케이션 코드는 해당 라우트 세그먼트(경로 단위) 안에 나눠서 저장하는 방식이에요.\n\n![프로젝트 구조 3](/TIL/assets/img/2025-04-22-Projectstructureandorganization_11.png)\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### URL 경로에 영향 없이 라우트 정리하기\n\nURL 경로를 변경하지 않고 라우트를 깔끔하게 정리하고 싶다면, 관련된 라우트들을 그룹으로 묶으면 좋아요. 이때, 괄호로 묶은 폴더 이름(예: `(marketing)`, `(shop)`)은 URL에서 제외됩니다.\n\n예를 들어, 아래 구조에서 `(marketing)`과 `(shop)`은 URL에 나타나지 않고, 폴더 내의 라우트들이 그대로 URL에 반영돼요.\n\n![route 그룹 예시](/TIL/assets/img/2025-04-22-Projectstructureandorganization_12.png)\n\n또한 `(marketing)`과 `(shop)` 폴더 안에 `layout.js` 파일을 추가하면, 각각의 그룹마다 개별 레이아웃을 적용할 수 있습니다. 즉, URL 경로는 같아도 레이아웃은 다르게 설정 가능하다는 거죠.\n\n![개별 레이아웃 적용 예시](/TIL/assets/img/2025-04-22-Projectstructureandorganization_13.png)\n\n### 특정 세그먼트만 레이아웃에 포함시키기\n\n특정 라우트만 하나의 레이아웃으로 묶고 싶다면, 해당 라우트들만 새로운 그룹(예: `(shop)`)으로 묶으면 됩니다. 그룹에 포함된 라우트들은 그룹 레이아웃을 공유하고, 밖에 있는 라우트는 영향을 받지 않아요.\n\n예를 들어, `account`와 `cart`는 `(shop)` 그룹에 넣어 레이아웃을 공유하고, `checkout`은 그룹 밖에 둬서 별도의 레이아웃을 유지할 수 있습니다.\n\n![특정 그룹에만 레이아웃 적용 예시](/TIL/assets/img/2025-04-22-Projectstructureandorganization_14.png)\n\n이런 방법을 사용하면 프로젝트 구조를 깔끔하게 유지하면서도 URL 디자인에는 전혀 영향 주지 않을 수 있어서 정말 유용합니다!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 특정 경로에 로딩 스켈레톤 적용하기\n\n특정 라우트에만 로딩 스켈레톤을 적용하고 싶다면, 새로운 라우트 그룹 (예: /(overview))을 만들고 그 안에 loading.tsx 파일을 넣으면 됩니다.\n\n\u003cimg src=\"/TIL/assets/img/2025-04-22-Projectstructureandorganization_15.png\" /\u003e\n\n이렇게 하면 loading.tsx 파일은 대시보드 내의 overview 페이지에만 적용되고, 다른 대시보드 페이지에는 영향을 주지 않으면서 URL 경로 구조도 유지할 수 있어요.\n\n---\n\n### 여러 개의 루트 레이아웃 만들기\n\n여러 루트 레이아웃을 만들고 싶으면 최상위에 있던 layout.js 파일을 제거한 다음, 각 라우트 그룹 내부에 layout.js 파일을 각각 만들어 주면 됩니다. 이렇게 하면 완전히 다른 UI나 경험이 필요한 섹션을 애플리케이션 내에 구분하기 매우 편리해요. 이때 각 루트 레이아웃에는 `html`과 `body` 태그가 반드시 포함되어야 합니다.\n\n\u003cimg src=\"/TIL/assets/img/2025-04-22-Projectstructureandorganization_16.png\" /\u003e\n\n위 예시처럼, (marketing)과 (shop)은 각각 자신만의 루트 레이아웃을 가지고 있게 됩니다.\n","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":20},{"title":"Next.js 14 2025년 최신 프로젝트 세팅 방법 완벽 가이드","description":"","date":"2025-04-22 00:32","slug":"2025-04-22-HowtosetupanewNextjsproject","content":"\n# 새로운 Next.js 프로젝트 설정 방법\n\n## 시스템 요구 사항\n\n시작하기 전에, 시스템이 다음 요구 사항을 충족하는지 확인하세요:\n\n| 요구 사항 | 설명                                 |\n| --------- | ------------------------------------ |\n| Node.js   | 18.18 버전 이상                      |\n| 운영 체제 | macOS, Windows(WSL 포함), 또는 Linux |\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 자동 설치\n\n새로운 Next.js 앱을 가장 빠르게 만드는 방법은 create-next-app을 사용하는 것입니다. 이 도구가 모든 설정을 자동으로 해줍니다. 프로젝트를 생성하려면 다음 명령어를 실행하세요:\n\n```js\nnpx create-next-app@latest\n```\n\n설치 중에 다음과 같은 프롬프트가 나타납니다:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n| 질문                                                             | 선택지   |\n| ---------------------------------------------------------------- | -------- |\n| What is your project named?                                      | my-app   |\n| Would you like to use TypeScript?                                | No / Yes |\n| Would you like to use ESLint?                                    | No / Yes |\n| Would you like to use Tailwind CSS?                              | No / Yes |\n| Would you like your code inside a `src/` directory?              | No / Yes |\n| Would you like to use App Router? (recommended)                  | No / Yes |\n| Would you like to use Turbopack for `next dev`?                  | No / Yes |\n| Would you like to customize the import alias (`@/*` by default)? | No / Yes |\n| What import alias would you like configured?                     | @/\\*     |\n\n프로젝트 생성 후, create-next-app이 프로젝트 이름으로 된 폴더를 만들고 필요한 의존성들을 설치해 줍니다.\n\n## 수동 설치\n\nNext.js 앱을 수동으로 새로 만들고 싶다면, 필요한 패키지를 설치하세요:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n| 스크립트명 | 설명                                      |\n| ---------- | ----------------------------------------- |\n| dev        | 개발 서버를 실행합니다.                   |\n| build      | 프로덕션용으로 애플리케이션을 빌드합니다. |\n| start      | 빌드된 애플리케이션을 실행합니다.         |\n| lint       | 코드 린팅을 실행합니다.                   |\n\n위 명령어들은 애플리케이션 개발의 각 단계를 위한 스크립트들이에요. `npm install`로 최신 버전의 Next.js와 React를 설치한 뒤, `package.json`에 이 스크립트들을 추가하면 다양한 개발 작업을 쉽게 실행할 수 있답니다!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- next dev: 개발 서버를 시작합니다.\n- next build: 애플리케이션을 프로덕션용으로 빌드합니다.\n- next start: 프로덕션 서버를 시작합니다.\n- next lint: ESLint를 실행합니다.\n\n### 앱 디렉토리 만들기\n\nNext.js는 파일 시스템 라우팅을 사용해, 애플리케이션의 라우트가 파일 구조에 따라 결정됩니다.\n\n`app` 폴더를 만드세요. 그리고 `app` 폴더 안에 `layout.tsx` 파일을 만드세요. 이 파일이 루트 레이아웃이고 꼭 필요하며, `html`과 `body` 태그를 포함해야 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nexport default function RootLayout({ children }: { children: React.ReactNode }) {\n  return (\n    \u003chtml lang=\"en\"\u003e\n      \u003cbody\u003e{children}\u003c/body\u003e\n    \u003c/html\u003e\n  );\n}\n```\n\n홈 페이지 app/page.tsx를 다음과 같이 초기 콘텐츠와 함께 만들어 주세요:\n\n```js\nexport default function Page() {\n  return \u003ch1\u003eHello, Next.js!\u003c/h1\u003e;\n}\n```\n\n사용자가 애플리케이션의 루트 경로 (/)를 방문하면 layout.tsx와 page.tsx 두 파일이 모두 렌더링됩니다.\n\n| 파일명     | 역할                                       |\n| ---------- | ------------------------------------------ |\n| layout.tsx | HTML 구조와 공통 레이아웃 정의             |\n| page.tsx   | 루트 경로에 표시할 초기 페이지 콘텐츠 제공 |\n\n친절하게 궁금한 점 있으면 언제든지 물어보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2025-04-22-HowtosetupanewNextjsproject_0.png\" /\u003e\n\n\u003e 알아두면 좋은 점:\n\u003e 루트 레이아웃(root layout) 파일을 만들지 않아도, next dev 명령어로 개발 서버를 실행할 때 Next.js가 자동으로 이 파일을 생성해 줍니다.  \n\u003e 프로젝트 루트에 src 디렉터리를 만들어 애플리케이션 코드를 구성 파일과 분리해서 관리할 수도 있습니다.\n\n### public 폴더 생성하기 (선택 사항)\n\n프로젝트 루트에 public 폴더를 만들어 이미지, 폰트 등 정적 자산을 저장해 보세요.  \npublic 폴더 안에 있는 파일들은 기본 URL(/)부터 참조할 수 있습니다.\n\n| 폴더명 | 설명                                       |\n| ------ | ------------------------------------------ |\n| public | 정적 자산(이미지, 폰트 등)을 저장하는 폴더 |\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자산은 루트 경로(/)를 사용해 참조할 수 있습니다. 예를 들어, public/profile.png 파일은 /profile.png로 참조할 수 있습니다:\n\n```js\nimport Image from \"next/image\";\n\nexport default function Page() {\n  // 여기에 컴포넌트 내용을 작성하세요\n}\n```\n\n## 개발 서버 실행하기\n\n- npm run dev 명령어로 개발 서버를 시작하세요.\n- http://localhost:3000 에 접속해 애플리케이션을 확인하세요.\n- app/page.tsx 파일을 수정하고 저장하면 브라우저에서 변경된 결과를 즉시 볼 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## TypeScript 설정하기\n\n\u003e 최소 TypeScript 버전: v4.5.2\n\nNext.js는 TypeScript를 기본적으로 지원합니다. 프로젝트에 TypeScript를 추가하려면 파일 이름을 `.ts` 또는 `.tsx`로 변경하고 `next dev`를 실행하세요. 그러면 Next.js가 필요한 종속성을 자동으로 설치하고, 권장 설정이 포함된 `tsconfig.json` 파일을 추가합니다.\n\n### IDE 플러그인\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js는 VSCode와 다른 코드 편집기에서 고급 타입 검사와 자동 완성을 사용할 수 있도록 맞춤형 TypeScript 플러그인과 타입 체크 기능을 포함하고 있어요.\n\nVS Code에서 플러그인을 활성화하려면 다음 단계를 따라 주세요:\n\n- 명령 팔레트 열기 (Ctrl/⌘ + Shift + P)\n- \"TypeScript: Select TypeScript Version\" 검색하기\n- \"Use Workspace Version\" 선택하기\n\n| 단계 | 설명                                         |\n| ---- | -------------------------------------------- |\n| 1    | 명령 팔레트 열기 (Ctrl/⌘ + Shift + P)        |\n| 2    | \"TypeScript: Select TypeScript Version\" 검색 |\n| 3    | \"Use Workspace Version\" 선택                 |\n\n\u003cimg src=\"/TIL/assets/img/2025-04-22-HowtosetupanewNextjsproject_1.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nTypeScript 참고 페이지에서 더 많은 정보를 확인할 수 있어요.\n\n## ESLint 설정하기\n\nNext.js는 내장 ESLint를 제공합니다. create-next-app으로 새 프로젝트를 만들면 필요한 패키지를 자동으로 설치하고 적절한 설정을 구성해 줘요.\n\n기존 프로젝트에 ESLint를 수동으로 추가하려면 package.json에 다음과 같이 next lint 스크립트를 추가하면 됩니다:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n{\n  \"scripts\": {\n    \"lint\": \"next lint\"\n  }\n}\n```\n\n그런 다음, `npm run lint` 명령어를 실행하면 설치 및 설정 과정을 안내받을 수 있습니다.\n\n```js\nnpm run lint\n```\n\n다음과 같은 프롬프트가 나타날 거예요:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003e ? ESLint를 어떻게 설정하시겠어요?\n\u003e ❯ 엄격 모드 (권장)\n\u003e 기본 모드\n\u003e 취소\n\n| 옵션      | 설명                                                                                                                                  |\n| --------- | ------------------------------------------------------------------------------------------------------------------------------------- |\n| 엄격 모드 | Next.js의 기본 ESLint 설정에 더 엄격한 Core Web Vitals 규칙 세트가 포함됩니다. ESLint를 처음 설정하는 개발자에게 권장되는 설정입니다. |\n| 기본 모드 | Next.js의 기본 ESLint 설정이 포함됩니다.                                                                                              |\n| 취소      | 설정을 건너뜁니다. 직접 커스텀 ESLint 설정을 할 계획이라면 이 옵션을 선택하세요.                                                      |\n\n엄격 모드나 기본 모드를 선택하면, Next.js가 자동으로 eslint와 eslint-config-next를 애플리케이션의 종속성으로 설치하고, 프로젝트 루트에 선택한 설정이 포함된 `.eslintrc.json` 파일을 생성합니다.\n\n이제 `next lint` 명령어를 실행하여 ESLint로 오류를 점검할 수 있습니다. ESLint 설정이 완료되면, 빌드할 때마다 (`next build`) 자동으로 ESLint가 실행됩니다. 오류가 있을 경우 빌드가 실패하며, 경고는 빌드에 영향을 주지 않습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nESLint 플러그인 페이지에서 더 많은 정보를 확인할 수 있어요.\n\n## 절대 경로 및 모듈 경로 별칭 설정하기\n\nNext.js는 tsconfig.json과 jsconfig.json 파일의 \"paths\"와 \"baseUrl\" 옵션을 기본적으로 지원해요.\n\n이 옵션들을 통해 프로젝트 디렉터리를 절대 경로로 별칭(alias) 설정할 수 있어서, 모듈을 더 쉽고 깔끔하게 임포트할 수 있답니다. 예를 들어:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n| Before                                                    | After                                              |\n| --------------------------------------------------------- | -------------------------------------------------- |\n| js\u003cbr\u003eimport { Button } from '../../../components/button' | js\u003cbr\u003eimport { Button } from '@/components/button' |\n\n절대 경로(import)를 설정하려면 tsconfig.json 또는 jsconfig.json 파일에 baseUrl 설정 옵션을 추가하세요. 예를 들어:\n\n```js\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \"src/\"\n  }\n}\n```\n\nbaseUrl 경로를 설정하는 것 외에도 \"paths\" 옵션을 사용해 모듈 경로에 별칭(alias)을 지정할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예를 들어, 다음 설정은 @/components/*를 components/*에 매핑합니다:\n\n```js\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \"src/\",\n    \"paths\": {\n      \"@/styles/*\": [\"styles/*\"],\n      \"@/components/*\": [\"components/*\"]\n    }\n  }\n}\n```\n\n\"paths\"에 있는 경로들은 모두 baseUrl 위치를 기준으로 한 상대 경로입니다.\n","ogImage":{"url":"/assets/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":12},{"title":"linear-gradient를 활용한 border 애니메이션 5가지 만들기","description":"linear-gradient, conic-gradient 등을 활용해 border 애니메이션을 만드는 방법에 대해서 공유합니다","date":"2025-04-22 00:01","slug":"2025-04-22-border-animation","content":"\n# linear-gradient를 활용한 여러가지 border 애니메이션 5가지\n\n`linear-gradient`, `conic-gradient`,`hue-rotate` 등을 활용해 아래 5가지 border 애니메이션을 만드는 방법에 대해서 공유합니다.\n단순 코드 공유가 아닌 결과물을 보고 애니메이션을 만들어가는 과정을 담아보려고 합니다.\n\n**1. 길이가 변하는 border 애니메이션**\n![2](/TIL/assets/img/2025_04_22-double_border.gif)\n**2. 움직이는 점선 border 애니메이션**\n![1](/TIL/assets/img/2025_04_22-dotted_box.gif)\n**3. 무지개 border 애니메이션**\n![3](/TIL/assets/img/2025_04_22-rotated_rainbow_box.gif)\n**4. 빛나는 border 애니메이션**\n![4](/TIL/assets/img/2025_04_22-rotated_conic_box.gif)\n**5. 색깔이 변하는 border 애니메이션**\n![5](/TIL/assets/img/2025_04_22-hue_box.gif)\n\n\u003c!-- seedividend - 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1898504329\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n     (adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n---\n\n## 1. 길이가 변하는 border 애니메이션\n\n![2](/TIL/assets/img/2025_04_22-double_border.gif)\n첫 번째로 만들어볼 것은 마우스 오버 시 border 길이가 변하는 박스인데요.\n좌측 상단과 우측 하단의 선의 길이가 변하는 것처럼 보이지만\n아래 박스처럼 좌측 상단과 우측 하단의 사각형이 커졌다 작아졌다 하는 구조로 만들 수 있습니다.\n![6](/TIL/assets/img/2025_04_22-double_box_real.gif)\n\n여기서 적절한 위치의 border만 사용하면 원하는 결과를 얻을 수 있을 것 같습니다.\n그리고 좌상단, 우하단 두 개의 사각형만 추가로 필요하므로 `::after`, `::before` 가상 요소만 사용하여 깔끔하게 작업할 수 있을 것 같습니다.\n\n```css\n.double_box {\n  position: relative;\n  border: 1px solid #0f0;\n  width: 200px;\n  height: 100px;\n  cursor: pointer;\n\n  \u0026::before,\n  \u0026::after {\n    content: \"\";\n    position: absolute;\n    width: 20px;\n    height: 20px;\n    transition: 0.2s ease-in-out;\n  }\n\n  \u0026::before {\n    top: -5px;\n    left: -5px;\n    border-top: 1px solid #0f0;\n    border-left: 1px solid #0f0;\n  }\n\n  \u0026::after {\n    right: -5px;\n    bottom: -5px;\n    border-bottom: 1px solid #0f0;\n    border-right: 1px solid #0f0;\n  }\n\n  \u0026:hover::before,\n  \u0026:hover::after {\n    width: calc(100% + 9px);\n    height: calc(100% + 9px);\n  }\n}\n```\n\n\u003c!-- seedividend - 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1898504329\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n     (adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 결과\n\n`::before`, `::after` 가상 요소의 border와 사이즈를 변경해서 아래와 같은 길이가 변하는 border 애니메이션을 구현할 수 있습니다.\n\n\u003ciframe height=\"307.078125\" style=\"width: 100%;\" scrolling=\"no\" title=\"Untitled\" src=\"https://codepen.io/13akstjq/embed/yLEgPNe?default-tab=css%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\"\u003e\n  See the Pen \u003ca href=\"https://codepen.io/13akstjq/pen/yLEgPNe\"\u003e\n  Untitled\u003c/a\u003e by 13akstjq (\u003ca href=\"https://codepen.io/13akstjq\"\u003e@13akstjq\u003c/a\u003e)\n  on \u003ca href=\"https://codepen.io\"\u003eCodePen\u003c/a\u003e.\n\u003c/iframe\u003e\n\n## 2. 움직이는 점선 애니메이션\n\n![1](/TIL/assets/img/2025_04_22-dotted_box.gif)\n\n두 번째로 만들어볼 것은 움직이는 점선 애니메이션인데요.\n우선 점선 박스를 만들기 위해 border 속성 값인 dotted를 사용해 보겠습니다.\n\n```css\nborder: 1px dotted #333;\n```\n\n![1](/TIL/assets/img/2025_04_22-dotted-box.png)\n\n하지만 border는 따로 animation을 제공하지 않기 때문에 움직이는 점선 애니메이션을 만들 수 없습니다.\n그렇기 때문에 다른 방법으로 점선을 구현해야 합니다. 점선은 `linear-gradient` 로 아래와 같이 구현할 수 있습니다.\n\n\u003c!-- seedividend - 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1898504329\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n     (adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```css\n.dotted_box {\n  background: linear-gradient(90deg, #333 50%, transparent 50%) 0 0 / 4px 1px repeat-x, /* 상 */ linear-gradient(\n        90deg,\n        #333 50%,\n        transparent 50%\n      ) 0 100% / 4px 1px repeat-x, /* 하 */ linear-gradient(0, #333 50%, transparent 50%) 0 0 / 1px 4px repeat-y, /* 좌 */\n      linear-gradient(0, #333 50%, transparent 50%) 100% 0 / 1px 4px repeat-y; /* 우 */\n}\n```\n\n![1](/TIL/assets/img/2025_04_22-dotted-box.png)\n\n점선 박스를 만들었으면 점선을 이동시켜서 움직이는 것처럼 애니메이션을 작성해야 합니다.\n시계방향으로 회전하는 애니메이션을 만들고 싶다면 아래 애니메이션 \\처럼 `background-position`을 각각 이동시켜주면 됩니다.\n\n**시계 방향**\n\n```css\n@keyframes linearGradientMove {\n  100% {\n    /* 상  ,    하    ,   좌   ,  우    */\n    background-position: 4px 0, -4px 100%, 0 -4px, 100% 4px;\n  }\n}\n```\n\n**반시계 방향**\n반시계 방향이라면 아래와 같이 작성하면 됩니다.\n복잡해보이지만 직접 작성해보면 어떻게 동작하는지 이해가 쉽게 됩니다.\n\n```css\n@keyframes linearGradientMove {\n  100% {\n    /* 상  ,    하    ,   좌   ,  우    */\n    background-position: -4px 0, 4px 100%, 0 4px, 100% -4px;\n  }\n}\n```\n\n\u003c!-- seedividend - 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1898504329\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n     (adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 결과\n\nborder 속성으로는 지원하지 않지만 `linear-gradient`로 아래와 같이 움직이는 점선 애니메이션을 구현할 수 있습니다.\n\n\u003ciframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"Untitled\" src=\"https://codepen.io/13akstjq/embed/zYaNPMR?default-tab=css%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\"\u003e\n  See the Pen \u003ca href=\"https://codepen.io/13akstjq/pen/zYaNPMR\"\u003e\n  Untitled\u003c/a\u003e by 13akstjq (\u003ca href=\"https://codepen.io/13akstjq\"\u003e@13akstjq\u003c/a\u003e)\n  on \u003ca href=\"https://codepen.io\"\u003eCodePen\u003c/a\u003e.\n\u003c/iframe\u003e\n\n## 3. 무지개 border 애니메이션\n\n![3](/TIL/assets/img/2025_04_22-rotated_rainbow_box.gif)\n\n세 번째로는 무지개 border 애니메이션을 구현해 보겠습니다.\n가장 먼저 기본적인 css 속성으로 해결할 수 있는지 판단해 볼 텐데요.\n위와 같은 스펙을 지원하는 css 속성은 없으니 다른 방법으로 만들어야겠다는 생각이 듭니다.\n이번에도 테두리만 보이지만 사각형을 활용해 볼 수 있을 것 같습니다.\n\n\u003c!-- seedividend - 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1898504329\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n     (adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```css\n.rotated_box {\n  \u0026::before {\n    content: \"\";\n    position: absolute;\n    left: 0%;\n    top: 0%;\n    width: 100%;\n    height: 100%;\n    background-repeat: no-repeat;\n    background-size: 50% 50%;\n    background-position: 0 0, 100% 0, 100% 100%, 0 100%;\n    background-image: linear-gradient(#399953, #399953), linear-gradient(#fbb300, #fbb300), linear-gradient(\n        #d53e33,\n        #d53e33\n      ), linear-gradient(#377af5, #377af5);\n    animation: rotate 3s linear infinite;\n  }\n}\n```\n\n\u003c!-- seedividend - 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1898504329\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n     (adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![3](/TIL/assets/img/2025_04_22-rainbow_box.png)\n\n`linear-gradient` 활용해 `::before` 요소에 위와 같이 4개의 사각형을 만들어줍니다.\n그리고 회전을 시켜주면 테두리가 비슷한 모습이 나올 것 같습니다.\n\n![3](/TIL/assets/img/2025_04_22-rainbow_box2.gif)\n\n회전을 시켜보니 위 영상처럼 빈 공간이 노출되는데요.\n이 부분은 `::before`의 사이즈를 키워서 해결할 수 있습니다.\n\n```css\n.rotated_box {\n  \u0026::before {\n    content: \"\";\n    position: absolute;\n    left: -50%;\n    top: -50%;\n    width: 200%; /* 2배 */\n    height: 200%; /* 2배 */\n    background-repeat: no-repeat;\n    background-size: 50% 50%;\n    background-position: 0 0, 100% 0, 100% 100%, 0 100%;\n    background-image: linear-gradient(#399953, #399953), linear-gradient(#fbb300, #fbb300), linear-gradient(\n        #d53e33,\n        #d53e33\n      ), linear-gradient(#377af5, #377af5);\n    animation: rotate 3s linear infinite;\n  }\n}\n```\n\n![3](/TIL/assets/img/2025_04_22-rainbow_box3.gif)\n\n이런 형태까지 만들었으니 이제 `::after` 요소를 이용해서 내부 영역을 흰색으로 채워주면 됩니다.\n\n### 결과\n\n예시에서는 4개만 사용했지만 더 다양한 색깔로 나누어서도 구현이 가능할 것 같습니다.\n\n\u003ciframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"Untitled\" src=\"https://codepen.io/13akstjq/embed/KKeaZay?default-tab=css%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\"\u003e\n  See the Pen \u003ca href=\"https://codepen.io/13akstjq/pen/KKeaZay\"\u003e\n  Untitled\u003c/a\u003e by 13akstjq (\u003ca href=\"https://codepen.io/13akstjq\"\u003e@13akstjq\u003c/a\u003e)\n  on \u003ca href=\"https://codepen.io\"\u003eCodePen\u003c/a\u003e.\n\u003c/iframe\u003e\n\n\u003c!-- seedividend - 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1898504329\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n     (adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 4. 빛나는 border 애니메이션\n\n![4](/TIL/assets/img/2025_04_22-rotated_conic_box.gif)\n\n다음으로 만들어 볼 것은 테두리가 빛나는 애니메이션입니다.\n이 애니메이션 또한 기본 css 속성이 존재하지 않기 때문에 다른 방법으로 구현해야 하는데요.\n\n이번엔 `linear-gradient`가 아니라 `conic-gradient`를 이용해서 구현해 보겠습니다.\n\n`linear-gradient`가 직선 형태의 그라데이션이라면 `conic-gradient`는 중심점을 기준으로 원형으로 그라데이션을 그리는 속성입니다.\n\n```css\n.rotated_one_conic_box {\n  \u0026::before {\n    content: \"\";\n    position: absolute;\n    left: -50%;\n    top: -50%;\n    width: 200%;\n    height: 200%;\n    background: conic-gradient(transparent, rgba(168, 239, 255, 1), transparent 30%);\n  }\n}\n```\n\n![4](/TIL/assets/img/2025_04_22-conic_box1.png)\n\n이제 이 `::before` 가상 요소를 무지개 애니메이션 때와 같이 회전시켜주고 `::after` 요소를 이용해 내부 컨텐츠를 채워주면 됩니다.\n\n\u003c!-- seedividend - 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1898504329\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n     (adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 결과\n\n\u003ciframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"conic-box\" src=\"https://codepen.io/13akstjq/embed/GRGrVZg?default-tab=css%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\"\u003e\n  See the Pen \u003ca href=\"https://codepen.io/13akstjq/pen/GRGrVZg\"\u003e\n  conic-box\u003c/a\u003e by 13akstjq (\u003ca href=\"https://codepen.io/13akstjq\"\u003e@13akstjq\u003c/a\u003e)\n  on \u003ca href=\"https://codepen.io\"\u003eCodePen\u003c/a\u003e.\n\u003c/iframe\u003e\n\n## 5. 색깔이 변하는 border 애니메이션\n\n![5](/TIL/assets/img/2025_04_22-hue_box.gif)\n\n색깔이 변하는 border 애니메이션은 그라데이션 border만 만들 수 있다면 쉽게 적용할 수 있습니다.\n\n```css\n.rotated_gradient_box {\n  width: 200px;\n  height: 100px;\n  margin: 7px auto 0;\n  border-radius: 21px;\n  border: 10px solid transparent;\n  background-image: linear-gradient(#444, #444), linear-gradient(to left, #37a9fa, #5951f3);\n  background-clip: content-box, border-box;\n  background-origin: border-box;\n}\n```\n\n![5](/TIL/assets/img/2025_04_22-gradient-box1.png)\n\n이렇게 그라디언트 border를 적용 했으면 `hue-rotate` 속성과 애니메이션으로 색상을 변경해 주면 됩니다.\n`hue-rotate`는 각도 값을 넣어주면 되며, 아래 사진과 같은 색상환에 따라서 색상이 노출됩니다.\n\n\u003c!-- seedividend - 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1898504329\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n     (adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```css\nhue-ratote(angle)\n```\n\n![5](/TIL/assets/img/2025_04_22-hue-rotate.png)\n\n### 결과\n\n\u003ciframe height=\"300\" style=\"width: 100%;\" scrolling=\"no\" title=\"Untitled\" src=\"https://codepen.io/13akstjq/embed/MWXJNXX?default-tab=css%2Cresult\" frameborder=\"no\" loading=\"lazy\" allowtransparency=\"true\" allowfullscreen=\"true\"\u003e\n  See the Pen \u003ca href=\"https://codepen.io/13akstjq/pen/MWXJNXX\"\u003e\n  Untitled\u003c/a\u003e by 13akstjq (\u003ca href=\"https://codepen.io/13akstjq\"\u003e@13akstjq\u003c/a\u003e)\n  on \u003ca href=\"https://codepen.io\"\u003eCodePen\u003c/a\u003e.\n\u003c/iframe\u003e\n\n## 마치며\n\n점점 인터렉티브한 웹사이트가 많아지면서 기존 속성들로 해결하기 어려운 경우들이 많이 있는데요.\n그럴 때는 전혀 다른 용도로 사용되는 속성을 이용하거나, 도형, 마스크 등등 다양한 방법으로 구현해야 합니다. 스펙을 조정하는 방법도 있겠지만 다양한 아이디어로 스펙을 구현해 보는 것도 좋을 것 같습니다.\n","ogImage":{"url":null},"coverImage":"","tag":["Tech"],"readingTime":12},{"title":"미디어 쿼리 vs. 컨테이너 쿼리 차이점 비교","description":"","date":"2025-04-20 00:06","slug":"2025-04-20-containerquery-mediaquery","content":"\n안녕하세요! 오늘은 **컨테이너 쿼리(Container Query)** 를 본격적으로 사용하기 전에 꼭 알고 있어야 할 개념인, **미디어 쿼리(Media Query)** 와의 차이점에 대해 이야기해볼게요. 🤔\n\n둘 다 반응형 디자인에 사용하는 CSS 문법이지만, **어디에 적용되는지, 언제 쓰는 게 더 좋은지**에 따라 차이가 꽤 있습니다!\n\n---\n\n## ✅ 미디어 쿼리란?\n\n미디어 쿼리는 우리가 이미 많이 써온 방식이에요.  \n**브라우저 뷰포트(viewport)의 크기**에 따라 스타일을 다르게 적용하죠.\n\n```css\n@media (min-width: 768px) {\n  .box {\n    background-color: lightblue;\n  }\n}\n```\n\n- 위 예제는 화면의 너비가 **768px 이상**일 때 `.box`의 배경색을 파란색으로 바꿉니다.\n- 주로 전체적인 **페이지 레이아웃**을 바꿀 때 많이 써요.\n\n---\n\n## ✅ 컨테이너 쿼리란?\n\n컨테이너 쿼리는 조금 달라요!  \n**뷰포트가 아니라, 특정 요소(부모 컨테이너)의 크기**를 기준으로 스타일을 바꿔줍니다. 🎯\n\n```css\n.container {\n  container-type: inline-size;\n}\n\n@container (min-width: 400px) {\n  .box {\n    background-color: lightgreen;\n  }\n}\n```\n\n- `.container` 요소의 **가로 너비가 400px 이상**일 때, 내부 `.box` 요소에 스타일을 적용합니다.\n- 그래서 페이지 크기와 상관없이, **컴포넌트의 위치나 구조에 따라 자동 반응**하게 만들 수 있어요!\n\n---\n\n## 📊 둘의 차이를 표로 한눈에 정리\n\n| 비교 항목     | 미디어 쿼리 (Media Query)   | 컨테이너 쿼리 (Container Query)                                     |\n| ------------- | --------------------------- | ------------------------------------------------------------------- |\n| 기준          | **브라우저 뷰포트 크기**    | **부모 컨테이너 크기**                                              |\n| 주 사용처     | 전체 페이지 레이아웃        | 개별 컴포넌트/요소 스타일링                                         |\n| 유연성        | 한정적 (전체 페이지 기준)   | 매우 유연함 (컴포넌트 기반)                                         |\n| 예시          | `@media (min-width: 768px)` | `@container (min-width: 400px)`                                     |\n| 브라우저 지원 | 널리 지원                   | [최신 브라우저부터 지원](https://caniuse.com/css-container-queries) |\n\n---\n\n## 💡 간단한 비교 예제\n\n### 💻 HTML\n\n```html\n\u003cdiv class=\"container\"\u003e\n  \u003cdiv class=\"box\"\u003e나는 박스야\u003c/div\u003e\n\u003c/div\u003e\n```\n\n### 🎨 CSS – 미디어 쿼리 버전\n\n```css\n.box {\n  background-color: pink;\n}\n\n@media (min-width: 600px) {\n  .box {\n    background-color: skyblue;\n  }\n}\n```\n\n📸 **결과:** 화면 너비가 600px 이상이 되면 박스가 파란색으로 바뀜\n\n---\n\n### 🎨 CSS – 컨테이너 쿼리 버전\n\n```css\n.container {\n  container-type: inline-size;\n}\n\n.box {\n  background-color: pink;\n}\n\n@container (min-width: 400px) {\n  .box {\n    background-color: lightgreen;\n  }\n}\n```\n\n📸 **결과:** `.container`의 너비가 400px 이상일 때 박스가 연두색으로 바뀜  \n👉 화면 크기가 아닌, **부모 요소 너비에 따라** 바뀌기 때문에 **레이아웃 내부에서 반응형 처리가 가능**해요!\n\n---\n\n## 🧠 언제 뭘 써야 할까?\n\n- **미디어 쿼리**는 페이지 전체 레이아웃 변경에 여전히 좋습니다.\n- **컨테이너 쿼리**는 컴포넌트 단위로 스타일을 바꿔야 할 때 아주 강력합니다!\n\n🎯 특히 **디자인 시스템, 컴포넌트 기반 UI (예: React, Vue 등)** 을 쓸 때는 컨테이너 쿼리가 훨씬 유리해요.\n\n---\n\n## ⚠️ 사용 전 주의할 점\n\n- **브라우저 지원**: 최신 버전의 크롬, 엣지, 파이어폭스에서는 지원하지만 Safari는 16.0 이상에서만 지원돼요.\n- **`container-type` 설정 필수**: 부모 요소에 `container-type` 속성을 주지 않으면 동작하지 않아요!\n- **성능 고려**: 너무 많은 요소에 컨테이너 쿼리를 쓰면 렌더링 비용이 올라갈 수 있어요.\n\n---\n\n## 📌 마무리\n\n미디어 쿼리와 컨테이너 쿼리는 서로 경쟁하는 게 아니라 **상호 보완적**이에요.  \n페이지 전체는 미디어 쿼리로, 세부 컴포넌트는 컨테이너 쿼리로 나눠서 쓰면 **더 유연하고 깔끔한 반응형 UI**를 만들 수 있어요. 🎉\n\n---\n\n\u003e 다음 글에서는 컨테이너 쿼리 문법을 좀 더 자세히 다루고, 다양한 실전 예제도 소개할게요! 🙌\n","ogImage":{"url":"/TIL/assets/img/2024-07-15-TechStackForProduction-ReadyLLMApplicationsIn2024_0.png"},"coverImage":"/TIL/assets/img/2025-04-20-containerquery-mediaquery.png","tag":["Tech"],"readingTime":3},{"title":"CSS :has() 선택자 사용 방법 정리","description":"","date":"2025-04-20 00:06","slug":"2025-04-20-css-has-selector","content":"\n안녕하세요! 오늘은 CSS에서 최근에 도입된 강력한 기능인 `:has()` 선택자에 대해 알아보겠습니다. 이 선택자는 부모 요소가 특정 자식 요소를 포함하고 있는지 여부에 따라 스타일을 적용할 수 있게 해줍니다. 자바스크립트 없이도 동적인 스타일링이 가능해졌다는 점에서 매우 유용합니다.\n\n## `:has()` 선택자란?\n\n`:has()`는 CSS의 관계형 의사 클래스(relational pseudo-class)로, 특정 자식 요소를 포함하는 부모 요소를 선택할 수 있게 해줍니다. 예를 들어, `\u003cdiv\u003e` 요소 중에서 `\u003cp\u003e` 요소를 포함하는 것만 선택하고 싶다면 다음과 같이 작성할 수 있습니다:\n\n```css\ndiv:has(p) {\n  background-color: #f0f0f0;\n}\n```\n\n이렇게 하면 `\u003cp\u003e` 요소를 포함한 `\u003cdiv\u003e`에만 배경색이 적용됩니다.\n\n## 실전 예제들\n\n### 1. 이미지가 있는 아티클 강조하기\n\n```html\n\u003carticle\u003e\n  \u003ch2\u003e첫 번째 아티클\u003c/h2\u003e\n  \u003cp\u003e내용이 여기에 있습니다.\u003c/p\u003e\n\u003c/article\u003e\n\n\u003carticle\u003e\n  \u003ch2\u003e두 번째 아티클\u003c/h2\u003e\n  \u003cimg src=\"image.jpg\" alt=\"이미지 설명\" /\u003e\n  \u003cp\u003e이미지가 포함된 아티클입니다.\u003c/p\u003e\n\u003c/article\u003e\n```\n\n```css\narticle:has(img) {\n  border: 2px solid #007acc;\n  padding: 10px;\n}\n```\n\n**설명**: 이미지가 포함된 아티클에만 테두리와 패딩을 적용하여 시각적으로 강조합니다.\n\n### 2. 서브메뉴가 있는 네비게이션 항목 표시하기\n\n```html\n\u003cul class=\"main-menu\"\u003e\n  \u003cli\u003e홈\u003c/li\u003e\n  \u003cli\u003e\n    서비스\n    \u003cul class=\"sub-menu\"\u003e\n      \u003cli\u003e웹 개발\u003c/li\u003e\n      \u003cli\u003e모바일 앱\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e문의하기\u003c/li\u003e\n\u003c/ul\u003e\n```\n\n```css\n.main-menu \u003e li:has(.sub-menu)::after {\n  content: \" ▼\";\n  font-size: 0.8em;\n  color: #555;\n}\n```\n\n**설명**: 서브메뉴가 있는 항목에만 화살표 기호를 추가하여 사용자가 하위 메뉴가 있음을 알 수 있도록 합니다.\n\n### 3. 입력 필드가 비어 있을 때 버튼 비활성화하기\n\n```html\n\u003cform\u003e\n  \u003cinput type=\"text\" id=\"username\" placeholder=\"사용자 이름\" /\u003e\n  \u003cbutton type=\"submit\"\u003e제출\u003c/button\u003e\n\u003c/form\u003e\n```\n\n```css\nform:has(input:placeholder-shown) button {\n  background-color: #ccc;\n  cursor: not-allowed;\n}\n```\n\n**설명**: 입력 필드가 비어 있을 때 버튼의 배경색을 변경하고 커서를 비활성화 상태로 표시하여 제출을 방지합니다.\n\n## 주의할 점 및 참고 사항\n\n- **브라우저 지원**: `:has()` 선택자는 최신 브라우저에서 지원됩니다. [Can I use](https://caniuse.com/css-has)에 따르면, 대부분의 최신 브라우저에서 사용할 수 있지만, 일부 구형 브라우저에서는 지원되지 않을 수 있습니다.\n\n- **성능 고려**: 복잡한 선택자나 많은 요소에 `:has()`를 사용할 경우 성능에 영향을 줄 수 있으므로 주의해야 합니다.\n\n- **중첩 사용 제한**: `:has()` 선택자 안에 또 다른 `:has()`를 중첩해서 사용하는 것은 현재 지원되지 않습니다.\n\n## 마무리\n\n`:has()` 선택자는 CSS에서 부모 요소를 자식 요소의 상태에 따라 스타일링할 수 있게 해주는 강력한 도구입니다. 자바스크립트 없이도 동적인 스타일링이 가능해져 코드의 간결성과 유지보수성이 향상됩니다. 실무에서도 다양한 상황에 활용할 수 있으니, 적극적으로 사용해보시기 바랍니다!\n","ogImage":{"url":"/TIL/assets/img/2024-07-15-TechStackForProduction-ReadyLLMApplicationsIn2024_0.png"},"coverImage":"/TIL/assets/img/2025-04-20-css-has-selector.png","tag":["Tech"],"readingTime":2},{"title":"Vite에서 SVG 사용하는 두 가지 방법 (React + TypeScript 기준)","description":"","date":"2025-04-18 00:06","slug":"2025-04-18-vite-svg","content":"\n## ✅ 1. React 컴포넌트로 사용하는 방법 (`?react` 쿼리)\n\nSVG를 직접 React 컴포넌트로 import 하여 사용하려면 **vite-plugin-svgr** 플러그인이 필요합니다.\n\n---\n\n### 📦 1-1. 설치\n\n```bash\nnpm install vite-plugin-svgr --save-dev\n# 또는\nyarn add vite-plugin-svgr --dev\n```\n\n---\n\n### ⚙️ 1-2. vite.config.ts 설정\n\n```ts\n// vite.config.ts\nimport { defineConfig } from \"vite\";\nimport react from \"@vitejs/plugin-react\";\nimport svgr from \"vite-plugin-svgr\";\nimport path from \"path\";\n\nexport default defineConfig({\n  plugins: [react(), svgr()],\n  resolve: {\n    alias: {\n      \"@\": path.resolve(__dirname, \"src\"),\n    },\n  },\n});\n```\n\n---\n\n### 🧩 1-3. TypeScript 선언 추가 (`svg.d.ts`)\n\n```ts\n// src/svg.d.ts\ndeclare module \"*.svg?react\" {\n  import * as React from \"react\";\n  export const ReactComponent: React.FC\u003cReact.SVGProps\u003cSVGSVGElement\u003e\u003e;\n  export default ReactComponent;\n}\n```\n\n---\n\n### 🧪 1-4. 사용 예시\n\n```tsx\n// 예: src/components/Icon.tsx\nimport { ReactComponent as HeartIcon } from \"@/assets/icons/heart.svg?react\";\n\nconst Icon = () =\u003e {\n  return \u003cHeartIcon width={32} height={32} fill=\"red\" /\u003e;\n};\n\nexport default Icon;\n```\n\n---\n\n## 📁 2. 이미지 파일처럼 사용하는 방법 (`img` 태그)\n\n`vite-plugin-svgr` 없이도 기본적으로 SVG 파일은 **URL로 import**해서 이미지처럼 사용할 수 있습니다.\n\n---\n\n### 📂 2-1. import 방식\n\n```tsx\n// 예: src/components/ImageIcon.tsx\nimport heartUrl from \"@/assets/icons/heart.svg\";\n\nconst ImageIcon = () =\u003e {\n  return \u003cimg src={heartUrl} alt=\"Heart\" width={32} /\u003e;\n};\n\nexport default ImageIcon;\n```\n\n---\n\n### 🧩 2-2. TypeScript 선언 추가 (`svg.d.ts`)\n\n```ts\n// src/svg.d.ts\ndeclare module \"*.svg\" {\n  const src: string;\n  export default src;\n}\n```\n\n\u003e ⚠️ `*.svg?react`과 `*.svg` 둘 다 선언해주면 두 방식 모두 사용할 수 있습니다.\n\n---\n\n## 🔁 3. 마무리 - 개발 서버 재시작\n\n```bash\nnpm run dev\n# 또는\nyarn dev\n```\n\n---\n","ogImage":{"url":"/TIL/assets/img/2024-07-15-TechStackForProduction-ReadyLLMApplicationsIn2024_0.png"},"coverImage":"/TIL/assets/img/2024-07-15-TechStackForProduction-ReadyLLMApplicationsIn2024_0.png","tag":["Tech"],"readingTime":2}],"page":"7","totalPageCount":41,"totalPageGroupCount":3,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"7"},"buildId":"o6AmBAY_j9v9JmbaRA39X","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>