<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>TIL</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//posts/20" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="TIL" data-gatsby-head="true"/><meta property="og:title" content="TIL" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//posts/20" data-gatsby-head="true"/><meta name="twitter:title" content="TIL" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/7978fe7362f7d4c9.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/7978fe7362f7d4c9.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/873-eb138c3217d71553.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/posts/%5Bpage%5D-de1dc5579188f9be.js" defer=""></script><script src="/TIL/_next/static/X4OrKfmLtU3-3BijwfHe6/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/X4OrKfmLtU3-3BijwfHe6/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="초고속 언어 Mojo 간단 소개  Python의 슈퍼셋" href="/TIL/post/2024-07-14-AQuickIntroductiontoMojoaSupersetofPythonThatIsSuperFast"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="초고속 언어 Mojo 간단 소개  Python의 슈퍼셋" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-AQuickIntroductiontoMojoaSupersetofPythonThatIsSuperFast_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="초고속 언어 Mojo 간단 소개  Python의 슈퍼셋" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">초고속 언어 Mojo 간단 소개  Python의 슈퍼셋</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="PySpark 윈도우 연산을 마스터하기 위한 5가지 예제" href="/TIL/post/2024-07-14-5ExamplestoMasterPySparkWindowOperations"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="PySpark 윈도우 연산을 마스터하기 위한 5가지 예제" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-5ExamplestoMasterPySparkWindowOperations_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="PySpark 윈도우 연산을 마스터하기 위한 5가지 예제" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">PySpark 윈도우 연산을 마스터하기 위한 5가지 예제</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">16<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="지구가 비어있다면 어떤 일이 벌어질까 그리고 그렇지 않다는 사실은 어떻게 알 수 있을까" href="/TIL/post/2024-07-14-WhatWouldHappenIftheEarthWasHollowandHowDoWeKnowItsNot"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="지구가 비어있다면 어떤 일이 벌어질까 그리고 그렇지 않다는 사실은 어떻게 알 수 있을까" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-WhatWouldHappenIftheEarthWasHollowandHowDoWeKnowItsNot_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="지구가 비어있다면 어떤 일이 벌어질까 그리고 그렇지 않다는 사실은 어떻게 알 수 있을까" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">지구가 비어있다면 어떤 일이 벌어질까 그리고 그렇지 않다는 사실은 어떻게 알 수 있을까</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="강화 학습을 이용한 동적 가격 책정 최적화 방법" href="/TIL/post/2024-07-14-OptimizingDynamicPricingwithReinforcementLearning"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="강화 학습을 이용한 동적 가격 책정 최적화 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-OptimizingDynamicPricingwithReinforcementLearning_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="강화 학습을 이용한 동적 가격 책정 최적화 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">강화 학습을 이용한 동적 가격 책정 최적화 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">16<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="네트워크 과학으로 예측한 다음에 죽을 왕좌의 게임 캐릭터는 누구" href="/TIL/post/2024-07-14-NetworkSciencePredictsWhoDiesNextinGameofThrones"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="네트워크 과학으로 예측한 다음에 죽을 왕좌의 게임 캐릭터는 누구" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-NetworkSciencePredictsWhoDiesNextinGameofThrones_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="네트워크 과학으로 예측한 다음에 죽을 왕좌의 게임 캐릭터는 누구" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">네트워크 과학으로 예측한 다음에 죽을 왕좌의 게임 캐릭터는 누구</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="벨만-포드 알고리즘으로 최단 경로 찾는 방법" href="/TIL/post/2024-07-14-FindShortestPathsWithBellman-Ford"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="벨만-포드 알고리즘으로 최단 경로 찾는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-FindShortestPathsWithBellman-Ford_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="벨만-포드 알고리즘으로 최단 경로 찾는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">벨만-포드 알고리즘으로 최단 경로 찾는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Python에서 BERT를 사용한 토픽 모델링 방법" href="/TIL/post/2024-07-14-TopicModellingwithBERTtopicinPython"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Python에서 BERT를 사용한 토픽 모델링 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-TopicModellingwithBERTtopicinPython_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Python에서 BERT를 사용한 토픽 모델링 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Python에서 BERT를 사용한 토픽 모델링 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="데이터 과학에서 자주 오해받는 5가지 단어" href="/TIL/post/2024-07-14-FiveMassivelyMisusedWordsinDataScience"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="데이터 과학에서 자주 오해받는 5가지 단어" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-FiveMassivelyMisusedWordsinDataScience_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="데이터 과학에서 자주 오해받는 5가지 단어" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">데이터 과학에서 자주 오해받는 5가지 단어</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="코드 없는 GenAI 에이전트 워크플로우 오케스트레이션 로컬 Mistral AI 모델과 함께하는 AutoGen Studio 사용법" href="/TIL/post/2024-07-14-NoCodeGenAIAgentsWorkflowOrchestrationAutoGenStudiowithLocalMistralAImodel"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="코드 없는 GenAI 에이전트 워크플로우 오케스트레이션 로컬 Mistral AI 모델과 함께하는 AutoGen Studio 사용법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-NoCodeGenAIAgentsWorkflowOrchestrationAutoGenStudiowithLocalMistralAImodel_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="코드 없는 GenAI 에이전트 워크플로우 오케스트레이션 로컬 Mistral AI 모델과 함께하는 AutoGen Studio 사용법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">코드 없는 GenAI 에이전트 워크플로우 오케스트레이션 로컬 Mistral AI 모델과 함께하는 AutoGen Studio 사용법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="선형 회귀 쉽게 이해하기  실생활 예시와 함께하는 초보자 가이드" href="/TIL/post/2024-07-14-SimplifyingLinearRegressionABeginnersGuidewithareal-worldPracticalExample"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="선형 회귀 쉽게 이해하기  실생활 예시와 함께하는 초보자 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-SimplifyingLinearRegressionABeginnersGuidewithareal-worldPracticalExample_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="선형 회귀 쉽게 이해하기  실생활 예시와 함께하는 초보자 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">선형 회귀 쉽게 이해하기  실생활 예시와 함께하는 초보자 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/TIL/posts/21">21</a><a class="link" href="/TIL/posts/22">22</a><a class="link" href="/TIL/posts/23">23</a><a class="link" href="/TIL/posts/24">24</a><a class="link" href="/TIL/posts/25">25</a><a class="link" href="/TIL/posts/26">26</a><a class="link" href="/TIL/posts/27">27</a><a class="link" href="/TIL/posts/28">28</a><a class="link" href="/TIL/posts/29">29</a><a class="link" href="/TIL/posts/30">30</a><a class="link" href="/TIL/posts/31">31</a><a class="link" href="/TIL/posts/32">32</a><a class="link" href="/TIL/posts/33">33</a><a class="link" href="/TIL/posts/34">34</a><a class="link" href="/TIL/posts/35">35</a><a class="link" href="/TIL/posts/36">36</a><a class="link" href="/TIL/posts/37">37</a><a class="link" href="/TIL/posts/38">38</a><a class="link" href="/TIL/posts/39">39</a><a class="link posts_-active__YVJEi" href="/TIL/posts/40">40</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"초고속 언어 Mojo 간단 소개  Python의 슈퍼셋","description":"","date":"2024-07-14 20:18","slug":"2024-07-14-AQuickIntroductiontoMojoaSupersetofPythonThatIsSuperFast","content":"\n\n\n![Mojo Language](/TIL/assets/img/2024-07-14-AQuickIntroductiontoMojoaSupersetofPythonThatIsSuperFast_0.png)\n\n2023년에 등장한 Mojo라는 새로운 언어가 눈에 띄게 화제가 되었습니다. Swift 프로그래밍 언어의 원조 아키텍트 인 크리스 라트너에 의해 만들어졌습니다. Mojo는 Python의 상위 집합으로 설계되었습니다. 구문은 Python과 매우 유사하여 Python 개발자들에게 매우 친숙합니다.\n\nMojo는 컴파일 언어이며 Python보다 훨씬 빠릅니다. 특히 ML/AI 관련 계산을 위해 최적화되어 있어 일반 Python 개발자들에게 흥미롭고 도움이 될 수 있습니다.\n\n이 게시물에서는 Mojo의 매우 기본 개념을 소개하고 Python과 비교합니다. Python과 비교했을 때 Mojo의 구문과 효율성에 놀라실 것입니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 왜 모조?\n\nMojo는 현재 AI 회사 모듈러(Modular)에서 개발한 프로프리어터리(소유권이 있는) 프로그래밍 언어로, 복잡성을 제거하고 AI 개발에 유연성과 속도를 더하는 확장 가능하고 통합된 AI 플랫폼을 구축하는 것을 목표로 합니다. 그리고 이 플랫폼을 위해 개발된 새로운 언어인 Mojo는 AI 인프라 확장 및 가속화 문제를 해결하기 위해 개발되었습니다. 이 언어는 현대 CPU 및 GPU를 포함한 이종 하드웨어에 이상적인 컴파일러 인프라인 MLIR로 구축된 첫 번째 프로그래밍 언어입니다. 요약하자면, Mojo는 AI를 위한 새로운 언어입니다.\n\n## Mojo와 Python\n\nMojo는 Python의 슈퍼셋(또는 고급 버전)으로 디자인되었으며, TypeScript가 JavaScript의 슈퍼셋인 것과 유사합니다. 이것은 JavaScript를 크게 향상시키는 것처럼 Python 개발자들이 Mojo를 시작하는 것이 매우 쉽다는 것을 의미합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파이썬은 머신 러닝/인공지능 및 기타 많은 분야에서 주목받는 언어입니다. 특히 데이터 관련 분야에서는 파이썬이 많이 사용됩니다. 그러나 파이썬은 저수준 성능과 동시성을 위한 글로벌 인터프리터 잠금(GIL) 등의 문제가 있습니다. 이러한 문제들은 오랫동안 파이썬 개발자들에게 머리아픈 문제였으며, 사람들이 파이썬이 느리고 동시성이 떨어진다고 말하는 부끄러운 이유입니다. 이는 또한 파이썬 개발을 제한시키는 중요한 사실이며, 이로 인해 파이썬이 모든 핵심 기능이 C와 같은 더 효율적인 컴파일된 언어로 개발된 '접착제 언어'로 끝나게 되었습니다.\n\nMojo는 파이썬의 인기와 간편함과 C 및 Rust와 같은 컴파일된 언어의 효율성 사이의 간극을 메우기 위해 디자인되었습니다. Mojo는 활발하게 파이썬 커뮤니티를 수용하고, 컴파일 및 메모리 관리와 같은 모든 복잡성을 숨겨 효율적인 코드 실행을 위해 배경에서 발생하는 작업을 쉽고 쉽게 만들려고 노력합니다.\n\n이 게시물에서는 Mojo의 기본 사항을 직접 Python과 비교하여 안내합니다. 변수, 함수 및 구조체와 같은 언어 기본 사항을 소개할 것입니다. 마지막으로, 동일한 코드 조각에 대한 Mojo와 Python의 효율성을 비교하고 Python 코드를 Mojo에서 직접 실행하는 방법을 알려드릴 것입니다. 그러면 이 새로운 언어에 대해 더 나은 이해를 얻을 수 있고, 귀하의 특정 영역에서의 사용 가능성을 확인할 수 있을 것입니다.\n\n## Mojo 설치\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 명령어를 사용하여 Linux 컴퓨터에 Mojo를 설치할 수 있어요:\n\n```js\ncurl https://get.modular.com | sh - \u0026\u0026 \\\nmodular auth mut_73b76eabd7a04555be4daa751d3e7088\n\nmodular install mojo\n```\n\n다른 플랫폼에 대한 지침은 여기서 찾을 수 있어요.\n\n설치가 완료되면 콘솔에서 Mojo를 설정하는 지침이 표시될 거예요:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![Mojo Introduction 1](/TIL/assets/img/2024-07-14-AQuickIntroductiontoMojoaSupersetofPythonThatIsSuperFast_1.png)\n\nCopy and run the corresponding commands for your shell so you can start using Mojo:\n\n![Mojo Introduction 2](/TIL/assets/img/2024-07-14-AQuickIntroductiontoMojoaSupersetofPythonThatIsSuperFast_2.png)\n\nThe `print` command works the same as in Python, and we've just written our first \"Hello World\" code in Mojo!\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n모조 REPL을 종료하려면 Python의 quit()이나 iPython의 exit과 달리 콜론(:)을 누르고 quit를 입력해야 합니다.\n\n## 변수\n\nPython과 비슷하게, Mojo에서도 이름과 값을 가진 변수를 만들 수 있습니다:\n\n```js\n  1\u003e x = 1 \n  2.  \n(Int) x = 1\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음과 같이 선언된 변수는 변할 수 있으므로, mutable합니다:\n\n```js\n  2\u003e x = 2 \n  3. print(x) \n  4.  \n2\n```\n\n그러나 Mojo는 엄격한 유형을 가지고 있기 때문에 변수의 유형을 변경할 수 없습니다:\n\n```js\n  4\u003e x = \"a\" \n  5.  \n[사용자] 오류: 표현식 [2]:1:5: 대입 중에 'StringLiteral' 값을 'Int'으로 암시적으로 변환할 수 없습니다\nx = \"a\"\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테이블 태그를 마크다운 형식으로 변경하십시오.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n  1\u003e let x = 1 \n  2. x = 2 \n  3. print(x) \n  4.  \n[User] error: Expression [0]:2:1: expression must be mutable in assignment\nx = 2\n```\n\nMojo는 현재 Python의 \"상위집합\"으로 설계되었지만 아직 완전히 그렇지는 않습니다. 따라서 Python처럼 보이지만 때로는 문법이 다를 수 있습니다. 예를 들어, 유형 주석을 위한 키워드가 다릅니다:\n\n```js\n  1\u003e var x: Int = 1 \n  2. var y: String = \"a\" \n  3. var z: Bool = True\n```\n\n## 함수들\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nMojo 함수는 fn 또는 def 키워드로 선언할 수 있습니다.\n\n함수를 선언할 때 def를 사용하면 인수 유형과 반환 유형을 지정할 필요가 없고 이름과 값만으로 변수를 생성할 수 있습니다. 이것은 파이썬에서 할 수 있는 것과 정확히 동일합니다:\n\n```js\ndef sum_up(n):\n    sum = 0\n    for i in range(1, n+1):\n        sum += i\n\n    return sum\n```\n\nfn 키워드를 사용하여 정의된 동일한 함수는:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nfn sum_up(n: Int) -\u003e Int:\n    var sum: Int = 0\n    for i in range(1, n+1):\n        sum += i\n    \n    return sum\n```\n\nfn으로 정의된 함수는 엄격한 타입을 갖고 있으며 컴파일 시간에 함수가 올바른 타입을 입력 받고 반환하는지 확인합니다. def 키워드를 지원하는 것은 Python 사용자들이 Mojo의 구문을 이해하고 시작하기 쉽게 만들기 위한 것일 뿐입니다. Mojo 코드를 작성할 때 좋은 습관으로 간주되지는 않습니다. Mojo 코드를 더 읽어보면 대부분의 함수가 fn 키워드로 정의되어 있는 것을 보실 수 있습니다.\n\n## Mojo 구조체\n\nMojo의 구조체는 Python의 클래스와 유사합니다. 둘 다 프로퍼티, 메서드, 데코레이터 등을 지원합니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파이썬에서 간단한 클래스를 정의해 봅시다:\n\n```python\nclass Dog:\n    def __init__(self, name):\n        self.name = name\n\n    def run(self):\n        print(f\"{self.name} is running.\")\n\ndog = Dog('Teddy')\ndog.run()\n```\n\nMojo에서 해당하는 구조체는 다음과 같습니다:\n\n```python\nstruct Dog:\n    var name: String\n\n    fn __init__(inout self, name: String):\n        self.name = name\n\n    fn run(self):\n        print(self.name, \" is running.\")\n\nlet dog = Dog('Teddy')\ndog.run()\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기 몇 가지 주요 차이점이 있어요:\n\n- 속성을 먼저 정의하고 생성자(__init__())에서 값을 할당해야 해요.\n- __init__()의 첫 번째 인자는 관례상 self로 불리며, Python에서는 inout 키워드로 정의되어 있어요. 이는 self가 가변 참조임을 의미해요. 이것은 복잡한 개념이지만, 이 글에서는 그 정도까지 깊게 파고들 필요는 없어요.\n- 아직 Mojo에서 f-string은 지원되지 않으므로 일반적인 프린팅을 사용해야 해요.\n\n변수와 함수의 기본을 알면, 두 요소의 조합인 구조체의 구문을 배우는 것은 쉬워요. 그러나 Mojo의 구조체는 복잡한 개념이며, 더 깊이 파고들고 싶다면 Mojo의 모든 것을 다루고 있어요. 심지어 Int, String, Bool과 같은 기본 유형도 내부적으로는 구조체이며, 이것이 클래스/구조체와 같은 대문자로 시작하는 이유에요.\n\n## Python과 Mojo 코드의 효율성 비교\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n알겠어요, 이제 Mojo의 매우 기본적인 구문을 알았으니, Python과 Mojo 코드의 효율성을 비교하고 최근 왜 많은 관심을 받고 있는지 살펴봅시다.\n\n다음 코드를 sum_up.py라는 Python 파일에 넣어봅시다:\n\n```python\ndef sum_up(n):\n    sum = 0\n    for i in range(1, n+1):\n        sum += i\n    \n    return sum\n\ndef main():\n    print(sum_up(1000_000_000))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n그리고 이 코드를 sum_up.mojo라는 Mojo 파일에 넣어봅시다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nfn sum_up(n: Int) -\u003e Int:\n    var sum: Int = 0\n    for i in range(1, n+1):\n        sum += i\n    \n    return sum\n\nfn main():\n    print(sum_up(1000_000_000))\n```\n\nMojo 파일의 경우, 진입 지점으로 main() 함수를 정의해야 하지만 호출할 필요는 없습니다.\n\nLinux에서는 time 명령어를 사용하여 명령어의 실행 시간을 측정할 수 있습니다. 먼저 Mojo 파일을 실행해봅시다. 그렇지 않으면 Python 파일을 먼저 실행하면 인내심을 잃을 수 있습니다 😅:\n\n```js\n$ time mojo sum_up.mojo \n500000000500000000\n\nreal    0m0,134s\nuser    0m0,161s\nsys     0m0,004s\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테이블 태그를 Markdown 형식으로 변경하였습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nMojo는 컴파일된 언어이고 Python은 해석된 언어이기 때문에 이유가 달라요. 컴파일된 언어에서 동일한 코드는 Python에서보다 100배 빠를 수 있다는 것은 놀라운 일이 아닙니다. 그러나 Python과 구문이 매우 유사하고 Python 사용자에게 친숙하기 때문에 꽤 놀라운 것입니다. 만약 우리 모든 데이터 처리 및 ML/AI 코드가 코드를 최소한으로 변경하면서 100배 빠르다면 환상적일 것입니다.\n\n## Mojo에서 Python 코드 직접 실행\n\n장기적으로, Mojo가 성숙해지고 Python의 실제 상위 집합이되면 바로 Mojo를 사용하고 Python 코드를 Mojo에서 직접 실행할 수 있어야 합니다. 마치 TypeScript에서 유효한 JavaScript 코드를 작성할 수 있는 것처럼요.\n\n그러나 현재는 Mojo에서 Python 모듈을 가져와서 Mojo 코드에서 Python 함수를 호출하고 Python 객체와 상호 작용할 수 있습니다. 위의 sum_up.py 모듈을 생성하고 Mojo에서 바로 실행하는 call_python_in_mojo.mojo라는 새 파일을 만들어 보죠.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n```js\nPython 모듈이 Mojo에서 찾을 수 있도록 경로를 추가해야합니다. 다음 명령어로 이 코드를 실행할 수 있습니다:\n\ntime mojo call_python_in_mojo.mojo\n\nPython을 직접 실행하는 것과 속도가 같다는 것을 알 수 있습니다. 조금 실망스러운 일이죠. 하지만 Mojo가 아직 초기 개발 중이고 많은 기능이 아직 구현되지 않았다는 것을 감안해야 합니다. 시간이 흐를수록 Python과의 사용성 및 통합이 훨씬 개선될 것으로 기대됩니다.\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 게시물에서는 Mojo라는 새로운 프로그래밍 언어의 매우 기초적인 부분을 소개했습니다. Mojo는 Python의 상위 집합으로 설계되어 Python과 매우 유사한 구문을 가지고 있습니다. 우리는 Mojo 코드의 간단한 구문과 놀라운 속도를 경험했는데, 이는 데이터 처리와 기계 학습에 매우 매력적일 수 있습니다.\n\n그러나 Mojo는 아직 매우 새로운 언어이며 아직 완전히 성숙해지지 않았습니다. 보편적인 개발자들이 일할 준비가 되기까지 어느 정도 시간이 필요합니다. 그럼에도 불구하고, 이 언어를 계속 주시하고 AI의 새 시대를 놓치지 않기 위해 시간을 할애하는 가치가 있습니다. 그리고 준비가 되면 우리는 효율성을 향상시키기 위해 빠르게 전환할 수 있으며, 이는 게임 체인저 이벤트가 될 수도 있습니다.\n\n## 관련 게시물:\n\n- Python typing and validation with mypy and pedantic\n- Python에서 쉘 명령어를 올바르게 실행하는 방법","ogImage":{"url":"/TIL/assets/img/2024-07-14-AQuickIntroductiontoMojoaSupersetofPythonThatIsSuperFast_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-AQuickIntroductiontoMojoaSupersetofPythonThatIsSuperFast_0.png","tag":["Tech"],"readingTime":13},{"title":"PySpark 윈도우 연산을 마스터하기 위한 5가지 예제","description":"","date":"2024-07-14 20:16","slug":"2024-07-14-5ExamplestoMasterPySparkWindowOperations","content":"\n\n\n![Window Operations](/TIL/assets/img/2024-07-14-5ExamplestoMasterPySparkWindowOperations_0.png)\n\n내가 사용해 본 모든 데이터 분석 및 조작 도구에는 윈도우 연산이 있습니다. 일부는 다른 것보다 유연하고 능력이 높지만, 윈도우에서 계산을 할 수 있는 것이 필수적입니다.\n\n데이터 분석에서 윈도우란 무엇인가요?\n\n윈도우는 어떤 방식으로 관련된 행들의 집합입니다. 이 관련은 동일한 그룹에 속하거나 연속적인 n일에 존재하는 것일 수 있습니다. 필요한 제약 조건으로 윈도우를 생성한 후, 해당 윈도우에서 계산이나 집계를 수행할 수 있습니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 기사에서는 PySpark를 사용하여 창 작업에 대해 포괄적으로 이해할 수 있는 5가지 구체적인 예제를 살펴보겠습니다. 우리는 파티션과 함께 윈도우를 생성하는 방법, 이러한 윈도우를 사용자 정의하는 방법, 그리고 이를 통해 계산을 수행하는 방법을 배울 것입니다.\n\nPySpark는 대규모 데이터 처리에 사용되는 분석 엔진인 Spark의 Python API입니다.\n\n# 데이터\n\n이 기사를 위해 모의 데이터로 샘플 데이터셋을 준비했고, 해당 데이터셋은 제 저장소에서 다운로드할 수 있습니다. 이 기사에서 사용할 데이터셋은 \"sample_sales_pyspark.csv\"라고 부릅니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자, spark 세션을 시작하고 이 데이터셋으로부터 DataFrame을 생성해 봅시다.\n\n```js\nfrom pyspark.sql import SparkSession\nfrom pyspark.sql import Window, functions as F\n\nspark = SparkSession.builder.getOrCreate()\n\ndata = spark.read.csv(\"sample_sales_pyspark.csv\", header=True)\n\ndata.show(15)\n\n# output\n+----------+------------+----------+---------+---------+-----+\n|store_code|product_code|sales_date|sales_qty|sales_rev|price|\n+----------+------------+----------+---------+---------+-----+\n|        B1|       89912|2021-05-01|       14|    17654| 1261|\n|        B1|       89912|2021-05-02|       19|    24282| 1278|\n|        B1|       89912|2021-05-03|       15|    19305| 1287|\n|        B1|       89912|2021-05-04|       21|    28287| 1347|\n|        B1|       89912|2021-05-05|        4|     5404| 1351|\n|        B1|       89912|2021-05-06|        5|     6775| 1355|\n|        B1|       89912|2021-05-07|       10|    12420| 1242|\n|        B1|       89912|2021-05-08|       18|    22500| 1250|\n|        B1|       89912|2021-05-09|        5|     6555| 1311|\n|        B1|       89912|2021-05-10|        2|     2638| 1319|\n|        B1|       89912|2021-05-11|       15|    19575| 1305|\n|        B1|       89912|2021-05-12|       21|    28182| 1342|\n|        B1|       89912|2021-05-13|        7|     9268| 1324|\n|        B1|       89912|2021-05-14|       17|    22576| 1328|\n|        B1|       89912|2021-05-15|       16|    20320| 1270|\n+----------+------------+----------+---------+---------+-----+\n```\n\n## 예제 1\n\n우선, 파티션과 정렬 열을 기준으로 윈도우를 생성합니다. DataFrame에서는 각 제품의 누적 판매량을 각 상점별로 계산하려면 윈도우를 다음과 같이 정의합니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nwindow = Window.partitionBy(\"store_code\", \"product_code\").orderBy(\"sales_date\")\n```\n\n누적 판매량을 계산하려면 이 윈도우 위에 sum 함수를 적용하기만 하면 됩니다:\n\n```js\ndata = data.withColumn(\"total_sales\", F.sum(\"sales_qty\").over(window))\n```\n\n이 코드는 \"total_sales\"라는 새 열을 만들며, 이전에 정의한 윈도우 상에서 계산된 판매 수량의 누적 합계를 포함합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\" B1\" 스토어의 첫 30개 행을 확인해봐서 누적값이 올바르게 계산되었는지 확인해보세요:\n\n```js\ndata \\\n.filter((F.col(\"store_code\")==\"B1\")) \\\n.select(\"store_code\", \"product_code\", \"sales_date\", \"sales_qty\", \"total_sales\") \\\n.show(30)\n\n# output\n+----------+------------+----------+---------+-----------+\n|store_code|product_code|sales_date|sales_qty|total_sales|\n+----------+------------+----------+---------+-----------+\n|        B1|       89912|2021-05-01|       14|       14.0|\n|        B1|       89912|2021-05-02|       19|       33.0|\n|        B1|       89912|2021-05-03|       15|       48.0|\n|        B1|       89912|2021-05-04|       21|       69.0|\n|        B1|       89912|2021-05-05|        4|       73.0|\n|        B1|       89912|2021-05-06|        5|       78.0|\n|        B1|       89912|2021-05-07|       10|       88.0|\n|        B1|       89912|2021-05-08|       18|      106.0|\n|        B1|       89912|2021-05-09|        5|      111.0|\n|        B1|       89912|2021-05-10|        2|      113.0|\n|        B1|       89912|2021-05-11|       15|      128.0|\n|        B1|       89912|2021-05-12|       21|      149.0|\n|        B1|       89912|2021-05-13|        7|      156.0|\n|        B1|       89912|2021-05-14|       17|      173.0|\n|        B1|       89912|2021-05-15|       16|      189.0|\n|        B1|       89915|2021-05-01|       20|       20.0|\n|        B1|       89915|2021-05-02|        0|       20.0|\n|        B1|       89915|2021-05-03|       10|       30.0|\n|        B1|       89915|2021-05-04|       13|       43.0|\n|        B1|       89915|2021-05-05|       21|       64.0|\n|        B1|       89915|2021-05-06|        4|       68.0|\n|        B1|       89915|2021-05-07|       20|       88.0|\n|        B1|       89915|2021-05-08|       16|      104.0|\n|        B1|       89915|2021-05-09|       21|      125.0|\n|        B1|       89915|2021-05-10|        2|      127.0|\n|        B1|       89915|2021-05-11|       15|      142.0|\n|        B1|       89915|2021-05-12|       15|      157.0|\n|        B1|       89915|2021-05-13|       14|      171.0|\n|        B1|       89915|2021-05-14|        3|      174.0|\n|        B1|       89915|2021-05-15|        1|      175.0|\n+----------+------------+----------+---------+-----------+\n```\n\n첫 15개 행은 제품 89912에 속하므로 총 판매액 열은 판매 수량 열의 값들의 누적 합을 보여줍니다. 16번째 행에서 제품 코드가 변경되어 누적 합이 초기화됩니다. 이는 우리가 스토어 코드와 제품 코드로 분할된 윈도우를 생성했기 때문입니다.\n\n## 예시 2\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n창을 생성한 후에는 다양한 집계를 계산할 수 있어요. 예를 들어, 앞에서 정의한 창에 대해 max 함수를 적용하면, 결과는 주어진 상점의 제품의 누적 최대 가격이 될 거예요.\n\n창을 생성하는 코드를 작성할 테니까, 위를 계속 찾지 않아도 돼요.\n\n```js\n# 창 정의\nwindow = Window.partitionBy(\"store_code\", \"product_code\").orderBy(\"sales_date\")\n\n# 누적 최대 가격\ndata = data.withColumn(\"max_price\", F.max(\"price\").over(window))\n\n# 결과 확인\ndata \\\n.filter((F.col(\"store_code\")==\"B1\")) \\\n.select(\"store_code\", \"product_code\", \"sales_date\", \"price\", \"max_price\") \\\n.show(15)\n\n# 결과\n+----------+------------+----------+-----+---------+\n|store_code|product_code|sales_date|price|max_price|\n+----------+------------+----------+-----+---------+\n|        B1|       89912|2021-05-01| 1261|     1261|\n|        B1|       89912|2021-05-02| 1278|     1278|\n|        B1|       89912|2021-05-03| 1287|     1287|\n|        B1|       89912|2021-05-04| 1347|     1347|\n|        B1|       89912|2021-05-05| 1351|     1351|\n|        B1|       89912|2021-05-06| 1355|     1355|\n|        B1|       89912|2021-05-07| 1242|     1355|\n|        B1|       89912|2021-05-08| 1250|     1355|\n|        B1|       89912|2021-05-09| 1311|     1355|\n|        B1|       89912|2021-05-10| 1319|     1355|\n|        B1|       89912|2021-05-11| 1305|     1355|\n|        B1|       89912|2021-05-12| 1342|     1355|\n|        B1|       89912|2021-05-13| 1324|     1355|\n|        B1|       89912|2021-05-14| 1328|     1355|\n|        B1|       89912|2021-05-15| 1270|     1355|\n+----------+------------+----------+-----+---------+\n```\n\n\"max_price\" 열의 값은 증가하거나 동일하게 유지돼요. 7번째 행에서는 가격이 실제로 낮아지지만, 누적 최대 값이 표시돼서 최대 가격 값은 그대로 유지돌아요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 예제 3\n\nlag 및 lead는 일반적으로 사용되는 윈도우 함수 중 일부입니다. 시계열 데이터를 분석할 때 자주 사용합니다. 현재 행의 앞이나 뒤에 오프셋된 값을 반환합니다.\n\n- lag(\"sales_qty\", 1) : 1행 전\n- lag(\"sales_qty\", 2) : 2행 전\n- lead(\"sales_qty\", 1) : 1행 후\n- lead(\"sales_qty\", 2) : 2행 후\n\nlag의 음수 값을 사용하여 오프셋을 지정할 수 있으므로 lag(\"sales_qty\", 1)은 lead(\"sales_qty\", -1)과 동일합니다. 둘 다 이전 행의 값을 제공합니다. 테스트해 봅시다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 창을 정의합니다\nwindow = Window.partitionBy(\"store_code\", \"product_code\").orderBy(\"sales_date\")\n\n# 전일 판매 수량\ndata = data.withColumn(\"prev_day_sales_lag\", F.lag(\"sales_qty\", 1).over(window))\ndata = data.withColumn(\"prev_day_sales_lead\", F.lead(\"sales_qty\", -1).over(window))\n\n# 다른 제품-매장 쌍에 대한 출력 확인\ndata \\\n.filter((F.col(\"store_code\")==\"A1\") \u0026 (F.col(\"product_code\")==\"95955\")) \\\n.select(\"sales_date\", \"sales_qty\", \"prev_day_sales_lag\", \"prev_day_sales_lead\") \\\n.show(15)\n\n# 출력 결과\n+----------+---------+------------------+-------------------+\n|sales_date|sales_qty|prev_day_sales_lag|prev_day_sales_lead|\n+----------+---------+------------------+-------------------+\n|2021-05-01|       13|              NULL|               NULL|\n|2021-05-02|        3|                13|                 13|\n|2021-05-03|       22|                 3|                  3|\n|2021-05-04|       17|                22|                 22|\n|2021-05-05|       20|                17|                 17|\n|2021-05-06|       14|                20|                 20|\n|2021-05-07|       10|                14|                 14|\n|2021-05-08|       10|                10|                 10|\n|2021-05-09|       15|                10|                 10|\n|2021-05-10|       15|                15|                 15|\n|2021-05-11|        8|                15|                 15|\n|2021-05-12|        9|                 8|                  8|\n|2021-05-13|       13|                 9|                  9|\n|2021-05-14|        6|                13|                 13|\n|2021-05-15|       21|                 6|                  6|\n+----------+---------+------------------+-------------------+\n```\n\n첫 번째 행의 전일 값은 NULL입니다. 이는 해당 행이 이전 날짜를 가지고 있지 않기 때문에 발생합니다.\n\n## 예시 4\n\n행을 기반으로 한 창을 정의한 후, rowsBetween 메소드를 사용하여 범위를 좁힐 수 있습니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n요즘 세 가지 이유로 판매량의 평균을 계산하려면 이 창을 다음과 같이 정의할 수 있습니다:\n\n```js\nwindow = Window \\\n.partitionBy(\"store_code\", \"product_code\") \\\n.orderBy(\"sales_date\") \\\n.rowsBetween(-3, -1)\n```\n\n첫 번째 매개변수가 시작이고 두 번째 매개변수가 끝입니다. 각 행에 대한 마지막 세 행을 포함하는 창을 사용자 정의했습니다. \"-1\"은 현재 행의 이전 행을 가리키고 \"-3\"은 현재 행의 세 번째 이전 행을 나타냅니다.\n\n![이미지](/TIL/assets/img/2024-07-14-5ExamplestoMasterPySparkWindowOperations_1.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지난 세 날 동안의 평균 판매 수량을 계산하려면 이 윈도우에 mean 함수를 적용하기만 하면 됩니다.\n\n```js\n# 윈도우 정의\nwindow = Window \\\n.partitionBy(\"store_code\", \"product_code\") \\\n.orderBy(\"sales_date\") \\\n.rowsBetween(-3, -1)\n\n# 평균 계산\ndata = data.withColumn(\"last_3_day_avg\", F.mean(\"sales_qty\").over(window))\n\n# 데이터 표시\ndata \\\n.filter((F.col(\"store_code\")==\"A1\") \u0026 (F.col(\"product_code\")==\"95955\")) \\\n.select(\"sales_date\", \"sales_qty\", \"last_3_day_avg\") \\\n.show()\n\n# 결과\n+----------+---------+------------------+\n|sales_date|sales_qty|    last_3_day_avg|\n+----------+---------+------------------+\n|2021-05-01|       13|              NULL|\n|2021-05-02|        3|              13.0|\n|2021-05-03|       22|               8.0|\n|2021-05-04|       17|12.666666666666666|\n|2021-05-05|       20|              14.0|\n|2021-05-06|       14|19.666666666666668|\n|2021-05-07|       10|              17.0|\n|2021-05-08|       10|14.666666666666666|\n|2021-05-09|       15|11.333333333333334|\n|2021-05-10|       15|11.666666666666666|\n|2021-05-11|        8|13.333333333333334|\n|2021-05-12|        9|12.666666666666666|\n|2021-05-13|       13|10.666666666666666|\n|2021-05-14|        6|              10.0|\n|2021-05-15|       21| 9.333333333333334|\n+----------+---------+------------------+\n```\n\n예를 들어, 네 번째 행인 \"2021-05-04\"의 경우, 지난 세 행(13, 3, 22)의 값의 평균인 13.75입니다.\n\n## 예시 5\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n입력 데이터의 각 행에서 정의된 창 내의 열의 누적 평균 값을 계산해야 하는 경우를 생각해보세요. 각 행에 대해 계산은 창의 첫 번째 행과 현재 행 사이의 행을 포함해야 합니다.\n\n이를 위해 unboundedPreceding으로 시작점을 정의할 수 있습니다. 마찬가지로, 창의 끝까지 가려면 unboundedFollowing을 사용할 수 있습니다.\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-5ExamplestoMasterPySparkWindowOperations_2.png\" /\u003e\n\n창을 정의한 후 나머지는 동일합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 윈도우 정의\nwindow = Window \\\n.partitionBy(\"store_code\", \"product_code\") \\\n.orderBy(\"sales_date\") \\\n.rowsBetween(Window.unboundedPreceding, -1)\n\n# 평균 계산\ndata = data.withColumn(\"누적평균\", F.mean(\"sales_qty\").over(window))\n\n# 데이터 출력\ndata \\\n.filter((F.col(\"store_code\")==\"A1\") \u0026 (F.col(\"product_code\")==\"95955\")) \\\n.select(\"sales_date\", \"sales_qty\", \"누적평균\") \\\n.show()\n\n# 결과\n+----------+---------+------------------+\n|sales_date|sales_qty|   누적평균       |\n+----------+---------+------------------+\n|2021-05-01|       13|              NULL|\n|2021-05-02|        3|              13.0|\n|2021-05-03|       22|               8.0|\n|2021-05-04|       17|12.666666666666666|\n|2021-05-05|       20|             13.75|\n|2021-05-06|       14|              15.0|\n|2021-05-07|       10|14.833333333333334|\n|2021-05-08|       10|14.142857142857142|\n|2021-05-09|       15|            13.625|\n|2021-05-10|       15|13.777777777777779|\n|2021-05-11|        8|              13.9|\n|2021-05-12|        9|13.363636363636363|\n|2021-05-13|       13|              13.0|\n|2021-05-14|        6|              13.0|\n|2021-05-15|       21|              12.5|\n+----------+---------+------------------+\n```\n\n누적평균 열에는 현재 행까지의 모든 행의 평균 판매량이 포함됩니다 (현재 행은 제외됨). 현재 행을 누적 평균 계산에 포함하려면 다음과 같이 윈도우를 정의할 수 있습니다:\n\n```js\nwindow = Window \\\n.partitionBy(\"store_code\", \"product_code\") \\\n.orderBy(\"sales_date\") \\\n.rowsBetween(Window.unboundedPreceding, Window.currentRow)\n```\n\n# 마지막으로\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n윈도우 작업은 데이터 분석에 있어 근본적인 작업입니다. 특히 시계열 데이터를 다루거나 시계열 데이터에 대한 예측 분석을 위해 머신러닝 모델을 만들 때 다양한 피처를 생성하기 위해 윈도우 작업을 사용합니다.\n\n대부분의 데이터 분석 및 조작 도구는 윈도우 작업을 수행하는 데 도움이 되는 기능을 제공합니다. 이 글에서는 PySpark를 사용하여 이러한 작업을 수행하는 방법을 배웠습니다.\n\n읽어 주셔서 감사합니다. 피드백이 있으시면 언제든지 알려주세요.","ogImage":{"url":"/TIL/assets/img/2024-07-14-5ExamplestoMasterPySparkWindowOperations_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-5ExamplestoMasterPySparkWindowOperations_0.png","tag":["Tech"],"readingTime":16},{"title":"지구가 비어있다면 어떤 일이 벌어질까 그리고 그렇지 않다는 사실은 어떻게 알 수 있을까","description":"","date":"2024-07-14 20:15","slug":"2024-07-14-WhatWouldHappenIftheEarthWasHollowandHowDoWeKnowItsNot","content":"\n\n![이미지](/TIL/assets/img/2024-07-14-WhatWouldHappenIftheEarthWasHollowandHowDoWeKnowItsNot_0.png)\n\n레딧에서 재미있는 질문이 있었습니다(삭제되었어요). 이 질문은 텅 빈 지구의 물리학에 대해 물었습니다. 질문이 완전히 명확하지는 않았고 중요한 부분이 빠져 있었지만, 저는 답변할 거예요. 사실, 이 질문의 다른 버전을 만들어서 답변할 거에요.\n\n# 중력과 고체 지구.\n\n좋아요, 텅 빈 지구에 대해 생각해보겠지만 한 가지 중요한 것에 대해 이야기해야 해요. 중력에 대해 이야기할 거예요. 중력을 질량을 가진 물체 사이의 가 attract한 힘으로 모델링하겠어요(시간-공간 곡률로 모델링하지 않을 거예요). 이를 통해 우리는 다른 작은 물체에 의한 단위 질량 당 중력을 계산할 수 있어요. 이것을 중력장이라 하며(Newtons per kilogram 단위를 갖습니다) 벡터 g입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 작은 작은 물체로 인한 중력장은 물체의 값(m)과 그 물체로부터의 거리(r) 양쪽에 따라 달라집니다. 이것은 그 물체를 향하는 벡터이며 우리는 이를 다음과 같은 식으로 쓸 수 있습니다.\n\n![image](/TIL/assets/img/2024-07-14-WhatWouldHappenIftheEarthWasHollowandHowDoWeKnowItsNot_1.png)\n\n여기서 G는 값이 6.67 x 10^-11 N*m²/kg²인 범용 중력 상수입니다. 또한, r-hat가 포함되어 있음을 주목해 주세요. 만약 r이 물체에서 중력장을 찾으려는 지점까지의 벡터라면, r-hat는 전체 표현을 벡터로 만드는 단위 벡터입니다. 네, 중요합니다.\n\n만약 점 물체가 아닌 물체가 있다면 어떻게 이 경우의 중력장 값을 찾을 수 있을까요? 마침내, 중력은 중첩 원리를 따른다는 사실이 있습니다. 이것은 하나 이상의 작은 점 물체로 인한 중력장은 각 물체의 중력장의 벡터 합이라는 것을 의미합니다. 따라서, 모든 이상한 모양의 물체에 대해 나는 그 물체를 여러 작은 물체들로 나누어 중력장을 계산할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n실제 지구의 중력장을 모델링하는 데 이 아이디어를 사용해봅시다. 재밌는 건, 지구를 구성하는 1000개의 미세한 물체가 전체 지구를 1/1000만큼의 질량을 가진 것처럼 가정할 수 있다는 것이에요. 물론, 이것은 실제로는 사실이 아니에요. 지구의 밀도는 표면보다 중심에 더 높기 때문에요. 하지만, 괜찮아요 (나를 믿어봐).\n\n우리의 지구를 나타내기 위해 5000개의 물체를 여기에 준비했어요. (네, 이건 Web VPython으로 만들었어요).\n\n![Earth Model](/TIL/assets/img/2024-07-14-WhatWouldHappenIftheEarthWasHollowandHowDoWeKnowItsNot_2.png)\n\n지구 표면( x축 상)에서 중력장을 찾기 위해 중첩 원리를 사용하면, g = `-10.0, 0.33, -0.73` N/kg를 얻게 돼요. 9.8 N/kg의 예상치와 완전히 일치하지는 않지만, 5000개의 물체만 사용했을 때는 충분히 가까운 값이에요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 지구 전체를 엄청나게 작지만 매우 질량이 많은 하나의 지점으로 대체한다면 어떨까요? 만약 이 작은 지점의 질량이 지구와 같다면, 이는 지구와 동일한 중력장 값을 만들 것입니다. 사실, 구 형태의 균일한 분포 외부의 중력장은 점 질량으로 인한 중력장과 정확히 같습니다. 이는 꽤 유용한 아이디어입니다.\n\n이제 우리는 몇 가지 질문에 준비되었습니다.\n\n# 만약 지구의 외부 10퍼센트만 남았다면 어떻게 될까요?\n\n심지어 이것도 완벽한 질문은 아니지만 너무 길게 만들고 싶지 않았어요. 그래서, 지구 내부 일부가 마법같이 사라진다고 상상해보세요. 그 후에, 우리는 지름의 10퍼센트인 지구 바깥 부분만 남게 됩니다. 지구의 반지름이 6.37 x 10^6 미터이기 때문에 표면의 두께는 637 킬로미터가 될 것입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 지구를 5000개의 작은 질량으로 나누는 방법은 위와 같습니다. 그러나 이러한 질량들은 지구의 외부 부분에만 있을 것입니다. 또한 이러한 모든 질량의 합은 전체 지구의 질량이 아니라 더 적은 값을 가질 것입니다.\n\n표면 근처 물질의 밀도는 대략 3500 킬로그램/미터³입니다. 이 밀도와 남아있는 지구의 부피(남은 부분)를 이용하여 1.03 x 10²⁴ 킬로그램의 질량을 구할 수 있습니다. 네, 이는 전체 지구의 질량보다 약 20% 낮습니다.\n\n이제 5000개의 점 질량을 만들어 봅시다. 확인해보세요.\n\n![이미지](https://miro.medium.com/v2/resize:fit:904/1*hKcOCkFW0e1bC5I-Sq4YCg.gif)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지구 표면에서 중력장 계산을 다시 실행하니, 값이 딱 1.4 N/kg이 나왔어요. 일반적인 지구의 중력보다 훨씬 낮은 값이 나온 이유는 질량이 줄어들었기 때문이에요.\n\n그런데 기다려봐요! 또 다른 흥미로운 상황이 생겼어요. 만약 지구 안으로 들어간다면 어떻게 될까요? 우리가 계산한 내부의 특정 위치(중심에는 아니고 중심절반 정도로)의 중력장 값은 `8.88e-3, -1.46e-3, -0.22` N/kg이에요. 5000개의 질량만 사용했기 때문에 정확히는 아니지만 0에 가까울 거예요.\n\n네, 지구 안에 들어가면 중력장이 0이 돼요. 슈퍼히어로나 붕떨어진 풍선처럼 자유롭게 움직일 수 있을 거에요(단, 공기가 있다는 전제 하에).\n\n# 만약 내부를 제거하는 대신 그냥 눌러넣는다면요?\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다른 방법으로는 지구를 구멍난 형태로 만들 수 있어요. 중심에 있는 물질을 모두 바깥부분으로 쫙 누르면 돼요. 이 방법의 차이점은 총 질량이 변하지 않는다는 거에요. 이 말은 지구 표면에서 중력장이 여전히 9.8 N/kg일 것이라는 거예요. 사실 대부분의 부분에서 구멍난 지구와 단단한 지구의 차이를 구별하기 어려울 거에요.\n\n# 그럼, 지구가 구멍난 게 아닌 걸 어떻게 알죠?\n\n그거 좋은 질문이에요. 지구에 대해 알아낸 거나 이게 단단한지 아니면 구멍난 것인지를 알아내는 게 참 신기해요. 표면 주변에 서서는 진짜로 알 수가 없죠. 구멍이 있는지 아니면 단단한지 알려면 속을 들여다봐야 할 텐데요 — 하지만 1킬로미터만 파봐도 멀리 못 갈 거예요. 그래서, 지구가 단단하다는 것을 시사하는 흥미로운 실험을 하나 보여드릴게요.\n\n지구를 보기 전에 이해해야 할 중요한 개념이 몇 가지 있어요. 첫 번째로는 만유인력의 개념입니다 (이것을 방금 위에서 사용했죠). 1666년에 이삭 뉴튼은 행성이 원형으로 움직이게 하는 힘이 지구에서 물체들을 떨어뜨리는 힘과 같다고 제안했어요. 그래서 질량을 가진 두 물체는 서로 인력을 발생시켜요. 이 힘은 거리와 두 물체의 값을에 따라 달라져요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n두 번째 아이디어는 지구가 구형이라는 것입니다(그리고 평평하지 않다는 것을 바보가 아닌 사람들은 모두 알고 있었죠). 지구는 구형이며, 지구의 반지름은 에라토스테네스에 의해 결정되었습니다. 그래서 모든 사람들이 지구의 크기를 알고 있었어요.\n\n이제 멋진 실험에 대해 이야기해 보겠습니다. 실험은 줄에 매달린 물체와 큰 산이 관련되어 있습니다. 아이디어는 마름모는 위아래로 매달리지 않고, 오히려 순수 중력장의 방향으로 매달리는 것입니다. 이 마름모를 큰 산 근처에 두면, 산으로부터 오는 중력이 측면으로 당기고 마름모에 편향을 줄 것입니다.\n\n물체에 작용하는 세 가지 힘이 있습니다(저는 두 개만 보여줍니다). 지구로 인한 중력 힘(아래), 산으로 인한 중력 힘(측면)과 줄이 있어요. 만약 마름모의 각도를 알고 있다면, 그것이 지구로부터 오는 힘과의 상대적 중력 힘의 크기를 찾는 것은 어렵지 않습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 실험은 쉬운 것이 아닌 것 같네요. 아마도 처음으로 마주한 문제는 뭘까요 - 우리가 수직 방향을 결정하는 데 수줄기를 사용하는데, 그것의 반류를 어떻게 찾을까요. 어이쿠. 잘 찾기 힘들죠. 재밌는 점은, 별의 위치를 사용하여 수직 방향을 결정하는 것입니다.\n\n그 다음 큰 문제는 뭘까요 - 산의 질량을 어떻게 찾을까요? 산의 밀도와 부피를 알고 있다면 질량을 찾는 것은 그리 어렵지 않습니다. 하지만 부피를 찾는 것은 정말 어렵죠. 모양이 잘 정돈된 산을 찾고 주변에 다른 산들이 그렇게 가깝지 않은 산을 찾는 것이 좋습니다 (다른 산들이 중력을 발생시킬 수 있어요).\n\n1774년에 스코틀랜드의 산인 셸할리온 산이 선택되었습니다. 신중한 측정 덕분에, 수질기의 반류가 일상보다 작은 것을 발견했습니다. 그들은 산의 밀도가 2500 킬로그램/미터³이라는 가정으로, 지구의 밀도를 4500 kg/ m³로 계산했습니다. 참고로, 지구의 실제 밀도는 더 높습니다 - 5500 kg/m³의 값을 가지고 있어요.\n\n하지만 이 계산을 가지고 지구의 내부에 빈 공간이 없다고 가정하는 것은 매우 어렵습니다. 지하에 있는 물질이 엄청나게 밀도가 높다는 것을 시사합니다. 훨씬 쉬운 설명은 지구가 단단한 것뿐만 아니라 지구 표면의 일반적인 바위가 아니라는 것이죠.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n캐벤디시가 중력 상수(G)를 측정한 후 지구의 질량(밀도)에 대한 더 나은 값이 얻어졌지만, 이건 나중 이야기입니다. 이것이 어떻게 달성되었는지에 대한 엿보기가 여기 있습니다.","ogImage":{"url":"/TIL/assets/img/2024-07-14-WhatWouldHappenIftheEarthWasHollowandHowDoWeKnowItsNot_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-WhatWouldHappenIftheEarthWasHollowandHowDoWeKnowItsNot_0.png","tag":["Tech"],"readingTime":8},{"title":"강화 학습을 이용한 동적 가격 책정 최적화 방법","description":"","date":"2024-07-14 20:13","slug":"2024-07-14-OptimizingDynamicPricingwithReinforcementLearning","content":"\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-OptimizingDynamicPricingwithReinforcementLearning_0.png\" /\u003e\n\n# 1. 소개\n\n소매 가격 전략은 매출과 이익을 최적화하는 데 중요합니다. 효과적인 가격 책정은 수요, 시장 상황 및 경쟁을 고려하여 소비자 행동을 영향을 주고 매출을 극대화합니다. 예를 들어 소매업체는 가격을 전략적으로 조정하고 할인을 적용하여 매출을 촉진하고 수익을 증가시킬 수 있습니다.\n\n본 논문은 Deep Deterministic Policy Gradient (DDPG) 알고리즘을 사용한 강화 학습 접근 방식을 통해 가격 전략을 최적화하는 것을 탐구합니다. 가격과 할인을 동적으로 조정함으로써 가격 결정을 개선할 수 있습니다. 또한 SHAP (Shapley Additive Explanations) 값은 모델의 결정에 미치는 가격, 할인 및 매출의 영향에 대한 통찰을 제공합니다. 이러한 복합 접근 방식은 실시간 분석 및 설명 가능한 인공지능 기술을 통합하여 전통적인 가격 모델을 향상시킵니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 2. 소매 업계의 가격 정책 모델링\n\n소매 업계의 가격 정책은 수익과 이윤을 최적화하기 위해 수학적으로 모델링될 수 있습니다. 매출 기능은 다음과 같이 작성할 수 있습니다:\n\n![매출 기능](/TIL/assets/img/2024-07-14-OptimizingDynamicPricingwithReinforcementLearning_1.png)\n\n이는 매출이 주로 가격과 할인과 같은 여러 요소에 의존한다는 것을 의미합니다. 일반적으로 가격이 증가하면 매출이 감소하고 그 반대도 마찬가지입니다. 최적의 가격을 찾아 매출이나 이윤을 극대화하는 것이 목표입니다. 예를 들어, 매출 기능이 이차 함수를 따른다면:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![optimization](/TIL/assets/img/2024-07-14-OptimizingDynamicPricingwithReinforcementLearning_2.png)\n\n상수 a와 b가 있는 경우, 최적화 기법으로는 이차 또는 선형 프로그래밍을 사용하여 최적 가격을 찾을 수 있습니다.\n\n하지만 전통적인 최적화 방법에는 한계가 있습니다. 실시간 적응성이 부족해 즉각적인 시장 변화에 기초한 효율적인 가격 조정이 어려울 수 있습니다. 또한 판매에 영향을 미치는 요소에 대한 사전지식이 필요한데, 동적인 시장에서는 항상 실행 가능하지 않을 수 있습니다.\n\n실시간 데이터 및 강화 학습과 같은 고급 머신러닝 모델은 이러한 도전에 대한 해결책을 제공합니다. 이러한 모델은 가격 전략을 동적으로 조정하고 다양한 요소의 영향을 분석하여 소매 환경에서 더 효과적이고 반응력있는 가격 결정을 지원할 수 있습니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 3. Pricing Strategies를 위한 강화 학습\n\n강화 학습 (RL)은 환경과 상호 작용하여 누적 보상을 극대화하기 위해 최적의 조치를 학습하는 기계 학습 기술입니다. 우리의 가격 전략에서는:\n\n- 환경: 소매 시장\n- 에이전트: 가격 모델\n- 목표: 가격과 할인을 동적으로 조정하여 매출과 이윤을 최적화\n\n우리는 실시간 의사 결정에 이상적인 정책 기반 및 가치 기반 학습을 결합한 Deep Deterministic Policy Gradient (DDPG) 알고리즘을 활용합니다. DDPG의 작동 방식은 다음과 같습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n정책 기반 학습: 강화 학습의 정책 함수인 액터-네트워크를 사용합니다:\n\n![Policy-Based Learning](/TIL/assets/img/2024-07-14-OptimizingDynamicPricingwithReinforcementLearning_3.png)\n\n상태 s가 주어진 경우 동작 a를 선택합니다. θ^π는 정책 네트워크의 매개변수입니다.\n\n가치 기반 학습: 비평가 네트워크(Q 함수)를 사용합니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](/TIL/assets/img/2024-07-14-OptimizingDynamicPricingwithReinforcementLearning_4.png)\n\n행동-가치 함수를 평가하기 위해.\n\n학습 과정:\n\n- Actor-Critic 아키텍처: Actor는 기대값 반환의 그래디언트를 따라 정책을 업데이트하며, Critic은 벨만 방정식을 사용하여 가치 추정을 업데이트합니다.\n- Experience Replay: 과거 경험 (s,a,r,s′)을 재생 버퍼에 저장하여 상관 관계를 끊고 학습을 안정화합니다.\n- Target Networks: 학습을 안정화하도록 학습된 네트워크를 천천히 추적하기 위해 목표 네트워크 세트 θ^π′ 및 θ^Q′를 유지합니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nDDPG의 장점은 다음과 같습니다:\n\n- 적응성: DDPG는 최신 시장 데이터를 기반으로 실시간으로 조정을 제공합니다.\n- 세밀한 결정: 연속적인 액션 공간은 정확한 가격 조정을 가능하게 합니다.\n- 데이터 기반 통찰력: 다양한 요소(가격, 할인 등)가 매출에 미치는 영향을 이해하는 데 도움이 되어 보다 효과적인 가격 전략을 도와줍니다.\n\n# 4. 코딩 및 데이터 실험\n\n이제 강화 학습(RL) 프레임워크 내에서 딥 디터미니스틱 정책 그라디언트(DDPG) 알고리즘을 구현하여 소매 가격 전략을 최적화해봅니다. 이 접근 방식은 매출과 이익을 극대화하기 위해 가격과 할인을 동적으로 조정합니다. 게다가, SHAP(Shapley Additive Explanations) 분석을 사용하여 모델 결정에 각 기능이 미치는 영향을 이해하여 RL 기반 가격 모델의 해석 가능성을 향상시킵니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n강화학습 환경 설정:\n\n- 환경 초기화: 우리는 맞춤 gym 환경인 SalesPredictionEnv를 정의합니다. 이 환경은 소매 시장을 시뮬레이션합니다. 환경은 초기 가격과 할인을 입력으로 받고 진짜 판매 기능을 사용하여 판매를 시뮬레이션합니다. 액션 공간은 가격과 할인을 연속적으로 조정할 수 있으며 관찰 공간에는 현재 가격, 할인 및 예측된 판매가 포함됩니다.\n\n```python\nclass SalesPredictionEnv(gym.Env):\n    def __init__(self, initial_price, initial_discount, true_sales_function):\n        super(SalesPredictionEnv, self).__init__()\n        self.initial_price = initial_price\n        self.initial_discount = initial_discount\n        self.true_sales_function = true_sales_function\n\n        self.action_space = spaces.Box(low=-0.1, high=0.1, shape=(2,), dtype=np.float32)\n        self.observation_space = spaces.Box(low=0, high=np.inf, shape=(3,), dtype=np.float32)\n\n        self.price = self.initial_price\n        self.discount = self.initial_discount\n        self.sales = self.true_sales_function(self.price, self.discount)\n        self.done = False\n\n    def reset(self, seed=None, options=None):\n        super().reset(seed=seed)\n        self.price = self.initial_price\n        self.discount = self.initial_discount\n        self.sales = self.true_sales_function(self.price, self.discount)\n        return np.array([self.price, self.discount, self.sales], dtype=np.float32), {}\n\n    def step(self, action):\n        self.price += action[0]\n        self.discount += action[1]\n        new_sales = self.true_sales_function(self.price, self.discount)\n\n        reward = -abs(self.sales - new_sales)\n        self.sales = new_sales\n        self.done = False\n\n        return np.array([self.price, self.discount, self.sales], dtype=np.float32), reward, False, False, {}\n\n    def render(self, mode='human'):\n        print(f'Price: {self.price}, Discount: {self.discount}, Sales: {self.sales}')\n```\n\n진짜 판매 함수: 그런 다음 가격, 할인 및 판매 간의 관계를 모델링하는 판매 함수를 정의합니다. 이 함수는 강화학습(RL) 구현에서 소매 환경을 시뮬레이션할 수 있습니다. RL 에이전트가 다양한 가격과 할인 수준이 판매에 어떤 영향을 미치는지 이해할 수 있도록 합니다. 이 함수는 다음과 같이 공식화됩니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ndef true_sales_function(가격, 할인):\n    return -0.5 * 가격 ** 2 + 가격 + 11 + 2 * 할인\n```\n\n실제 세계의 강화학습 구현에서는 이러한 함수들이 종종 과거 판매 데이터, 경험적 연구 또는 도메인 전문 지식을 기반으로 실제 시장 행위를 모방하는 데 사용됩니다. 이 이차 함수 형태는 중간 가격 상승이 판매를 촉진할 수 있지만, 과도한 가격이나 할인은 전반적인 판매에 부정적인 영향을 미칠 수 있다.\n\n환경 및 모델 설정: check_env를 사용하여 환경을 초기화합니다. 그런 다음 환경에 DDPG 에이전트를 설정합니다.\n\n```js\nenv = SalesPredictionEnv(initial_price=5.0, initial_discount=1.0, true_sales_function=true_sales_function)\ncheck_env(env)\nmodel = DDPG('MlpPolicy', env, verbose=1)\nmodel.learn(total_timesteps=10000)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nSHAP 분석:\n\nSHAP (Shapley Additive Explanations)은 각 특징이 예측에 미치는 영향을 양적으로 설명하여 모델을 해석 가능하게 합니다. RL 설정에서 SHAP를 구현하는 과정은 다음과 같습니다:\n\n- SHAP를 위한 데이터 수집: 환경을 재설정하고 SHAP 분석을 위해 상태와 행동을 수집합니다.\n\n```js\nobs, _ = env.reset()\nstates = []\nactions = []\nfor _ in range(10):\n    action, _states = model.predict(obs)\n    obs, rewards, terminated, truncated, _ = env.step(action)\n    env.render()\n    states.append(obs)\n    actions.append(action)\n\nstates = np.array(states)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nSHAP 예측 래퍼: SHAP의 올바른 출력 형식을 보장하기 위해 래퍼 함수를 정의합니다.\n\n```js\ndef predict_wrapper(observations):\n    predictions = []\n    for obs in observations:\n        action, _states = model.predict(obs)\n        predictions.append(action.flatten())\n    return np.array(predictions)\n```\n\n예측 DataFrame: 예측을 저장할 DataFrame을 생성하고 추가 분석을 위해 Excel 파일에 저장합니다.\n\n```js\npredictions = {\n    'ID': list(range(len(states))),\n    'price': states[:, 0],\n    'discount': states[:, 1],\n    'sales': states[:, 2],\n    'predicted_action_0': [None] * len(states),\n    'predicted_action_1': [None] * len(states)\n}\n\nfor idx, state in enumerate(states):\n    action, _states = model.predict(state)\n    predictions['predicted_action_0'][idx] = action[0]\n    predictions['predicted_action_1'][idx] = action[1]\n\npredictions_df = pd.DataFrame(predictions)\npredictions_df.to_excel(\"reinforcement_learning_predictions.xlsx\", index=False)\nprint(predictions_df.head(10))\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nSHAP Explainer 및 Visualization: 우리는 SHAP를 사용하여 모델의 의사결정에 미치는 다른 feature들의 영향을 분석하고 결과를 시각화합니다.\n\n```js\nexplainer = shap.Explainer(predict_wrapper, states)\nshap_values = explainer(states)\n\nshap_values_price = shap_values[..., 0]\n\nshap.plots.beeswarm(shap_values_price)\nshap.plots.bar(shap_values_price[0])\n```\n\n상위 영향력 있는 feature들: 각 state의 상위 영향력 있는 feature들을 추출하여 DataFrame에 저장하여 쉬운 분석을 할 수 있습니다.\n\n```js\ndata = {\n    'ID': list(range(len(states))),\n    'price': states[:, 0],\n    'discount': states[:, 1],\n    'sales': states[:, 2],\n    'top_feature1': [None] * len(states),\n    'top_feature2': [None] * len(states),\n    'importance1': [None] * len(states),\n    'importance2': [None] * len(states)\n}\n\nfeatures = ['price', 'discount', 'sales']\nfor i in range(len(states)):\n    sorted_indices = np.argsort(-np.abs(shap_values.values[i][:, 0]))\n    data['top_feature1'][i] = features[sorted_indices[0]]\n    data['importance1'][i] = shap_values.values[i][sorted_indices[0], 0]\n\n    if len(sorted_indices) \u003e 1:\n        data['top_feature2'][i] = features[sorted_indices[1]]\n        data['importance2'][i] = shap_values.values[i][sorted_indices[1], 0]\n\nreason_df = pd.DataFrame(data)\nprint(reason_df.head(10))\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 5. 분석과 인사이트\n\n다음의 SHAP 막대 그래프는 Price(가격), Discount(할인) 및 Sales(판매)가 특정 인스턴스에 대한 모델의 가격 결정에 미치는 영향을 보여줍니다:\n\n- SHAP 막대 그래프는 Price(가격), Discount(할인) 및 Sales(판매)가 특정 인스턴스에 대한 모델의 가격 결정에 미치는 영향을 보여줍니다:\n- Sales(판매): 가장 높은 긍정적 영향을 나타내며, 높은 판매량이 모델이 가격과 할인을 유지하거나 높이는 데 강력한 영향을 미친다는 것을 시사합니다.\n- Discount(할인): 높은 할인은 결과에 부정적인 영향을 미치며, 과도한 할인을 피하기 위해 할인액을 줄이는 것을 권장하는 모델의 결론으로 이어집니다.\n- Price(가격): 약간의 긍정적 영향을 나타내며, 결과를 향상시키기 위해 가격을 약간 올리는 것을 선호하는 모델이고 판매량에 큰 영향을 미치지 않는다는 것을 나타냅니다.\n\n![이미지](/TIL/assets/img/2024-07-14-OptimizingDynamicPricingwithReinforcementLearning_5.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n모델은 가격 책정 전략을 안내하기 위해 판매를 우선시하며, 수익을 극대화하기 위해 신중한 할인 관리와 약간의 가격 인상을 권장합니다. 막대 도표는 모델의 특정 사례에 대한 가격 결정에 영향을 미치는 Sales, Price 및 Discount가 어떻게 변하는지를 강조합니다.\n\n다음은 SHAP beeswarm 도표로, 여러 사례에 걸쳐 Price, Discount 및 Sales가 모델의 가격 결정에 미치는 영향을 보여줍니다:\n\n- Sales (Feature 2): 높은 값(빨강)은 모델의 출력을 증가시키고, 낮은 값(파랑)은 감소시킵니다.\n- Price (Feature 0): 낮은 값(파랑)은 부정적인 영향을 미치며, 더 높은 값(빨강)은 긍정적인 영향을 미칩니다.\n- Discount (Feature 1): 높은 값(빨강)은 모델의 출력을 감소시키고, 낮은 값(파랑)은 긍정적인 영향을 미칩니다.\n\n![도표 이미지](/TIL/assets/img/2024-07-14-OptimizingDynamicPricingwithReinforcementLearning_6.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n벌집 그림은 매출, 가격 및 할인이 모델의 결정에 미치는 영향이 여러 인스턴스에 걸쳐 어떻게 변하는지를 제공하여 그들이 모델의 결정에 미치는 중요성과 일관성을 강조합니다.\n\n예측된 작업 테이블은 다른 기능에 대한 모델의 예측을 제시합니다:\n\n![Predicted Actions Table](/TIL/assets/img/2024-07-14-OptimizingDynamicPricingwithReinforcementLearning_7.png)\n\n- 가격 조정: 가격에 대한 예측된 작업은 약간 부정적이며(예측 작업 0), 가격이 감소함에 따라 약간의 인하를 시사합니다.\n- 할인 조정: 할인에 대한 예측된 작업(예측 작업 1)도 약간 부정적이며, 소폭의 감소를 나타냅니다. 모델은 수익성을 유지하기 위해 신중한 할인을 권장하는 일관된 경향을 보입니다.\n- 매출 영향: 가격과 할인이 감소함에 따라 매출이 증가하며, 전형적인 시장 행동을 반영합니다. 모델이 가격과 할인을 약간 감소시킨 것은 수익성을 유지하면서 매출을 최적화할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nFeature Importance Table은 각 인스턴스에 대해 모델 결정에 영향을 줄인 최상위 두 가지 기능과 그 중요도 값을 식별합니다:\n\n- 판매량: 모든 인스턴스에서 가장 중요한 기능(top_feature1)으로 일관되게 나타납니다.\n- 가격 및 할인: 교체 가능 기능(top_feature2)은 다양한 중요도 값을 가지며, 판매량에 높은 중요도 값이 해당 기능이 모델 예측에 미치는 강력한 영향을 나타냅니다.\n\n![image](/TIL/assets/img/2024-07-14-OptimizingDynamicPricingwithReinforcementLearning_8.png)\n\n요약하면, 판매가격은 모델의 가격 결정에서 우세한 요소이며, 가격 및 할인은 보조이지만 중요한 역할을 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 6. 결론\n\n본 연구는 소매 가격 전략을 최적화하기 위해 Deep Deterministic Policy Gradient (DDPG) 알고리즘을 활용합니다. 강화 학습 (RL)과 SHAP (Shapley Additive Explanations)을 결합하여 가격 및 할인을 조정하여 매출과 이익을 극대화할 수 있습니다.\n\n장점:\n\n- 적응성: 전통적인 가격 모델과 달리 RL은 실시간 데이터로부터 계속 학습하여 시장 변화에 즉각 대응할 수 있습니다.\n- 정밀성: DDPG의 연속적인 행동 공간은 섬세한 가격 결정을 가능하게 합니다.\n- 통찰력: SHAP 값은 다양한 요인의 영향에 대한 설명 가능한 통찰력을 제공하여 의사 결정 투명성을 향상시킵니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n단점:\n\n- 복잡성: 강화 학습 모델을 구현하는 데는 상당한 컴퓨팅 자원과 전문 지식이 필요합니다.\n- 데이터 의존성: 강화 학습의 효과는 사용 가능한 데이터의 품질과 양에 매우 의존합니다.\n- 안정성: 동적 환경에서 안정적인 학습을 보장하는 것은 어려울 수 있으며 하이퍼파라미터를 세심히 조정해야 합니다.\n\n개선 제안:\n\n- 혼합 모델: 강화 학습과 전통적 최적화 방법을 결합함으로써 안전성과 성능을 향상시킬 수 있습니다.\n- 향상된 데이터 통합: 고객 피드백 및 경쟁사 가격과 같은 다양한 데이터 원본을 통합하여 모델의 정확성을 향상시킬 수 있습니다.\n- 확장성: 확장 가능한 강화 학습 프레임워크를 개발하여 소매 세그먼트와 시장 전반에 이러한 방법을 도움이 될 수 있습니다.\n- 지속적인 모니터링: 비즈니스 목표 및 시장 조건과 일치하는 모델의 결정을 보장하기 위해 모니터링 및 검증 프로세스를 구현합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nGitHub의 내 저장소에 있는 Python 스크립트는 다음과 같습니다: [datalev001/Reinforcement_price](https://github.com/datalev001/Reinforcement_price)","ogImage":{"url":"/TIL/assets/img/2024-07-14-OptimizingDynamicPricingwithReinforcementLearning_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-OptimizingDynamicPricingwithReinforcementLearning_0.png","tag":["Tech"],"readingTime":16},{"title":"네트워크 과학으로 예측한 다음에 죽을 왕좌의 게임 캐릭터는 누구","description":"","date":"2024-07-14 20:11","slug":"2024-07-14-NetworkSciencePredictsWhoDiesNextinGameofThrones","content":"\n\n\n![Network Science Predicts Who Dies Next in Game of Thrones](/TIL/assets/img/2024-07-14-NetworkSciencePredictsWhoDiesNextinGameofThrones_0.png)\n\n# 소셜 네트워크 분석과 머신 러닝은 최근 몇 년간 수많은 응용 분야에서 사용되고 있습니다. 예를 들어, 2017년에 이루어진 이 짧은 프로젝트는 몇 가지 미디어 관심을 끌었는데, 주된 목표는 네트워크 과학과 예측 모델링을 결합하여 인기 있는 TV 및 도서 시리즈인 'Game of Thrones'의 주요 캐릭터들 중 어떤 이들이 그들의 최후를 맞이할 가능성이 높은지 예측하는 것이었습니다.\n\n# 1. 소개\n\n이 글은 2017년에 발표된 두 개의 블로그 포스트 [1, 2]를 요약한 것으로, 이들은 네트워크 과학, 예측 모델링, TV 프로그램 (및 책 시리즈적 적응) 'Game of Thrones'을 결합하여 시리즈의 그 당시 에피소드에서 주요 인물들이 그들의 최후를 맞이할 가능성이 높은 캐릭터를 식별하기 위해 노력했습니다. 다양한 미디어에서 받은 높은 관심으로 인해 [4–10], 저자는 이 프로젝트를 요약하였습니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 프로젝트에서는 TV 시리즈의 라벨이 붙은 자막을 기반으로 작업했어요. 여기에는 발화된 텍스트 뿐만 아니라 발화자의 이름도 포함되어 있었죠. 게다가 사용된 데이터셋 [11]은 서로 다른 장면 사이의 구분 요소에 대한 정보를 가지고 있었어요. 이 두 가지 정보를 결합하여 모든 장면에 나타나는 캐릭터 목록을 추출했어요. 총 600명 정도였죠. 그런 다음 이러한 장면을 쇼의 사회 시스템의 기본 구성 요소로 가정하고 웨스테로스의 사회 지도를 작성하는 데 사용했어요. 이 네트워크에서 각 주요 캐릭터는 네트워크 노드로 표시되며, 같은 장면에서 함께 출연한 경우에는 두 플레이어 사이에 연결이 있어요. 게다가, 그들이 함께 출연하는 빈도가 더 높을수록 연결이 더 강해져요. 그런 다음 이러한 캐릭터(네트워크 노드)의 다양한 네트워크 중심성 측정 값을 계산하여 예측 기능으로 사용했고, 이들 캐릭터가 6시즌 동안 살았는지 여부를 라벨링했어요. 마지막으로, 아직 살아있는 캐릭터 중 어떤 캐릭터가 죽을 가능성이 높은지 예측하기 위해 널리 사용되는 선형 모델인 서포트 벡터 머신을 적용했어요.\n\n두 번째 섹션에서는 처음 6시즌의 자막을 기반으로 한 원래 예측에 대한 자세한 내용이 소개되었습니다. 세 번째 섹션에서는 7시즌 이후의 예측이 업데이트되었어요. 나중에 추가된 요약은 최종 결과에 대한 간단한 평가를 제공해요.\n\n# 2. 왕좌의 게임 예측\n\n왕좌의 게임의 새 시즌이 곧 다가오며 팬들은 무엇을 기대할지 흥분하고 있어요. 제가 즐겼던 캐릭터 중 어떤 캐릭터가 죽을 것인지, 누가 다음 시즌에 살아남을지 궁금해서 혼자만은 아니에요. 그래서 캐릭터들을 순위 매기기로 결정했어요. 왕좌의 게임은 사회적 위치와 진정한 친구들이 꽤 중요한 복잡한 세계이기 때문에 각 캐릭터의 사회 상호 작용 패턴을 네트워크 과학 도구를 사용하여 양적으로 표현했어요. 그런 다음 기계 학습 방법을 사용하여 그들의 운명을 예측했죠.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2.1. 웨스테로스의 네트워크 만들기\n\n데이터 원본으로는 팬 웹사이트 [11]에서 대화 형식으로 수집된 쇼 자막을 사용했습니다. 불행하게도 2, 3 시즌 대부분의 에피소드가 누락되어 있지만, 나머지 네 시즌에는 거의 600개의 장면이 포함된 일관된 형식으로 제공됩니다.\n\n먼저 왕국 사회 체계의 집계된 네트워크를 구축했습니다. 이 네트워크에서 각 노드는 이야기의 캐릭터를 나타내고 각 쌍의 캐릭터 사이의 연결 가중치는 그들의 사회적 상호 작용의 강도를 상징합니다. 사회 상호 작용의 기본 단위로 장면을 고려했습니다 (평균 에피소드에는 약 스무 개의 장면이 포함됩니다). 이는 한 장면에서 한 번 (두 번) 나온 모든 사람들이 강도가 하나 (둘)인 관계를 가지며, 장면 내에서는 모든 사람이 서로 연결되어 있다는 것을 의미합니다. 다시 말하면, 장면은 모든 사람들 간의 관계를 한 단계씩 높여 모두가 서로 강하게 연결된 완전 그래프 또는 클리크입니다. 이러한 장면 수준의 완전 네트워크를 계산한 다음 이를 집계하여 우리는 웨스테로스의 글로벌 사회 네트워크 (도식 1)에 도달하게 되며, 거의 400개의 노드와 3000개 이상의 엣지를 갖습니다.\n\n네트워크 시각화에서 (도식 1) 위대한 가문의 모든 구성원은 서로 다른 색상으로 표시됩니다 (예: 파랑 - 스타크, 빨강 - 란니스터, 노랑 - 마텔). 다른 사람들은 회색으로 표시됩니다. 노드 크기는 각 사람이 가진 연락처 수에 비례하며 가장 인기 있는 캐릭터 이름이 레이블로 추가됩니다. 연결 중심성이 매우 낮은 흥미로운 없는 노드는 걸러집니다. 월 주변 야인들 주변에 분리된 공동체가 보이며, 요한 스노우 주변의 사람들은 왕국의 나머지와의 연락이 거의 없다는 것을 보여줍니다. 티리온은 별도의 역할을 맡고 있습니다: 그는 다이네리스 타거리엔를 네트워크의 중앙에 있는 왕의 땅을 포함하여 연결하고 있습니다. 이곳에서 두 개의 큰 공동체를 볼 수 있습니다. 이들은 스타크와 란니스터 그리고 스타크와 탈리 가문 간의 결속 및 란니스터와 마텔 간의 갈등과 같은 영향영역 및 상호작용을 형성하여 이야기의 핵심부에서 밀집된 웹을 형성하고 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n수학으로 넘어가 봅시다. 우리는 노드의 중요성을 측정할 수 있는 다양한 지표를 계산할 수 있어요. 우리는 이러한 측정값을 캐릭터에 연결하여 이 사회 생태계에서의 중요성을 설명할 거예요. 이러한 측정값 중 일부는 i) 노드 차수 — 사람이 가지는 연락 수; ii) 가중치된 차수 — 특정 노드의 엣지 가중치 총합; iii) 클러스터링 — 노드의 연락처 쌍이 자주 연락하는 정도; 그리고 iv) 중심성, 그 노드가 얼마나 정보 흐름에서 다리 역할을 하는지를 나타내는 중요도, 다른 노드 쌍 사이의 최단 경로 상에 얼마나 자주 위치하는지를 측정합니다 (Table 2). 중요한 사람과 중요하지 않은 사람을 더 잘 파악할 뿐만 아니라, 어떤 캐릭터가 최초 6시즌에서 사망했는지 데이터로부터 알아낼 수도 있어요. 그래서 우리의 목표는 네트워크 위치와 생존을 연결하는 것입니다: 한 가지를 다른 가지와 연결시키는 것은 가능할까요? 다시 말해, 캐릭터가 사망했는지 여부를 예측하는 데 어떤 네트워크 측정값이 도움이 될지 알아내기 위해 알고리즘을 훈련하고 싶어요.\n\n**2.2. 예측**\n\n우리에게는 관심 있는 94명의 캐릭터 집합이 있어요. 모든 캐릭터는 사회적인 중요성의 다양한 측면을 나타내는 일곱 가지 다른 네트워크 기반 특성으로 설명됩니다. 또한 우리는 그 중 61명이 이미 사망한 캐릭터를 알고 있어요. 이 지식을 바탕으로 우리는 누가 곧 죽을지 굉장히 예측할 수 있어요: 아직 살아 있는 사람 중에서 이미 사망한 사람과 비슷한 특성을 가진 사람은 누구일까요? 이 문제는 데이터 과학에서 널리 연구된 이탈 문제와 비슷합니다. 다양한 분류 기반 알고리즘으로 이 문제를 해결할 수 있어요. 이 분석에서는 가장 정확한 Support Vector Machine (SVM)을 사용했어요. 이 알고리즘은 Python에서 쉽게 사용할 수 있어요. 이 기능을 집에서 시도해보고 싶다면 사용해보세요.\n\n기계 학습 알고리즘은 모든 특성을 고려하고 대상 변수의 가능한 값을 예측합니다. 이를 위해 샘플 데이터를 무작위로 테스트 세트와 훈련 세트로 분할하고 여러 번 반복해 예측을 수행한 후 최종 결과를 평가합니다. 이 교차 검증 전략을 통해 SVM 분류기는 경우의 72.3%에서 올바른 클래스(사망 또는 생존)를 예측했어요. 데이터의 규모와 성격을 고려하면 이는 만족스러운 결과입니다. 정확성을 설명하기 위해 모델은 8명의 캐릭터가 사망해서는 안 되지만 이야기 속에서는 그런 캐릭터들이 사망했음을 말해요 — 여왕의 죽음은 왕보다 덜 가능성이 있다는 것인데, 그리고 강력한 친구들이 그를 구할 수 없었던 진노스 슬린트도 그렇습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Network Science Predicts Who Dies Next in Game of Thrones](/TIL/assets/img/2024-07-14-NetworkSciencePredictsWhoDiesNextinGameofThrones_1.png)\n\n다른 유형의 특징(예: 성별, 귀족 가문의 일원 여부, 연설의 감정 분석)을 포함하거나 보다 완전한 데이터셋을 사용하거나 TV 프로그램을 책과 비교하는 등의 작업은 예측의 정확성을 높일 수 있습니다. 또한, 이 모델은 Jon Snow가 죽었다가 부활하거나 Benjen Stark가 중간 어딘가에 있는 등의 불일치를 무시합니다.\n\n2.3. 결과 — 스포일러 주의\n\nSVM 모델을 사용하여 각 살아있는 잘 알려진 캐릭터가 죽을 확률을 얻을 수 있습니다. 네트워크 측정값들은 종종 매우 상관관계가 있기 때문에 단독으로 높은 예측력을 가진 하나 또는 둘을 선택할 수 없지만, 보이는 바와 같이 betweenness가 높고 clustering이 낮으며 차수가 높은 캐릭터들은 죽을 가능성이 더 낮습니다. 어쨌든 기계 학습 접근 방식의 강점은 많은 특징들 중에서 숨겨진 관계를 발견하는 것입니다. 예측 중에 5-fold 교차 검증을 사용하였고, 이를 100번 반복하여 각 확률의 통계적 값 및 오차에 대한 추정을 얻었습니다. 마지막으로, 최종 예측 모델에 따라 생존 순으로 순위 매겨진 캐릭터 목록이 여기에 있습니다 (테이블 2).\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Network Science Predicts Who Dies Next in Game of Thrones](/TIL/assets/img/2024-07-14-NetworkSciencePredictsWhoDiesNextinGameofThrones_2.png)\n\n이 목록은 많은 흥미로운 것을 알려줍니다. 첫째, 다네리스는 상당히 죽을 가능성이 높아 보이며, 많은 추측과 겹칩니다. 반면 티리온과 존 스노우는 비교적 안전해 보입니다. 둘째, 항상 인기 있는 아리아 스타크와 덜 친절한 하운드는 이미 죽을 위기를 여러 차례 겪었는데도 위험한 위치에 있습니다. 놀랍게도 현재 철 왕좌에 앉아있는 세르세이와 그곳에 오르려는 베일리시는 훨씬 좋은 위치에 있는 것으로 보입니다. 조라 몰몬트는 화파병에 대한 치료법을 찾을 것으로 보이며, 그가 겪어온 모든 것에도 불구하고 테온 그레이조이는 아마도 살아남을 것입니다. 안타깝게도, 에린 가족에 대해서는 그렇지 못할 것으로 보입니다.\n\n# 3. 게임 오브 스론 예측 2.0\n\n뜻밖의 소식을 가져오고 끊임없는 논쟁을 일으킨 게임 오브 스론 7시즌이 끝났고 중요한 캐릭터들을 자연스럽게 죽였습니다. 그래서 이제 이전 예측을 검증할 수 있는 기회가 왔습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n3.1. 지금까지 무슨 일이 있었나요?\n\n이전 블로그 게시물에서 TV 프로그램의 에피소드를 사용하여 웨스테로스 왕국의 소셜 네트워크를 만들고 죽은 캐릭터와 살아있는 캐릭터의 다양한 중심성 매개변수를 결정하고, 각 살아있는 캐릭터가 죽을 가능성을 예측하기 위해 서포트 벡터 머신 모델을 사용했습니다. 결과는 살아있는 캐릭터들이 시리즈 종료 전에 죽을 가능성에 따라 순위가 매겨진 캐릭터 목록 형태로 나왔습니다. 제 예측은 시간을 고려하지 않습니다: 캐릭터가 첫 번째 에피소드에서 즉시 죽을지 또는 막바지에야 죽을지는 예측하지 않습니다. 그래서 최종 시즌은 아직 남아 있지만, 모델의 예비 결과에 대해 이야기하고 싶습니다. 이전 예측은 34명의 잘 알려진 캐릭터의 운명을 다루었으며, 그 중 대부분은 최신 시즌에 나타났습니다. 그러나 그중에는 지금까지 4명이 죽었는데, 만약 죽음이 무작위로 발생했다면 모든 캐릭터가 죽을 확률은 대략 11%를 의미합니다. 모델의 한계와 단순함에도 불구하고, 상당히 잘 수행했습니다(Table 3): 목록의 처음에 있는 타인, 그리고 올레나 타이렐과 페티르 베일리쉬의 사망을 예측했지만, 타인의 자매 사망은 예측하지 못했습니다. 반면, 조라는 (죽을 것으로 생각되는) 치명적인 질병에 대한 치료법을 발견하고 생존할 것으로 예측한 것이 맞았습니다. 마찬가지로, 테온은 모든 고통을 겪었음에도 계속해서 살아갈 것이라는 것에 대한 정확한 예측이었습니다.\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-NetworkSciencePredictsWhoDiesNextinGameofThrones_3.png\" /\u003e\n\n3.2. 예측 2.0\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이전에 소개된 방법론을 사용하여 캐릭터들의 사망 확률에 기반한 현재 순위도 계산해보았어요. 이 정보는 약간의 스포일러가 포함되어 있으니 이 게시물의 끝에서 확인할 수 있어요.\n\n가장 중요한 이벤트는 의심할 여지 없이 다네리스와 존, 그리고 세르세이와의 만남입니다. 이것이 바로 이 네트워크의 (도식 2) 이전에 연결되지 않았던 도메인들이 마침내 연결되었다는 의미에요 (도식 3). 이를 통해 많은 새로운 연결이 생성되고 원래의 소셜 네트워크가 변형되며, 이는 또한 캐릭터들의 예측된 미래를 바꾸게 된다고 해요. 제1-6 시즌을 기반으로 한 중심 캐릭터들의 필터링된 네트워크는 도식 2에서 확인할 수 있고, 1-7 시즌을 기반으로 한 네트워크는 도식 3에 나와 있어요. 노드는 연결 강도의 총량에 비례하는 크기로 캐릭터들을 나타내고, 색상은 7 시즌에 등장하는 대가문을 나타내는 색으로 설정되어 있어요 (파란색 - 스타크, 빨간색 - 란니스터, 마젠타색 - 타르가르엔, 초록색 - 타이렐, 노란색 - 그레이조이).\n\n![Figure 2](/TIL/assets/img/2024-07-14-NetworkSciencePredictsWhoDiesNextinGameofThrones_4.png)\n\n![Figure 3](/TIL/assets/img/2024-07-14-NetworkSciencePredictsWhoDiesNextinGameofThrones_5)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n리스트와 네트워크를 통해 몇 가지 사실을 추론할 수 있습니다:\n\n- 거의 모든 네트워크 측정을 기반으로 중요한 캐릭터인 Jon;\n- Bran은 결국 행동에 가까워졌는데, 그는 불길한 미래를 암시하는 것으로 보입니다;\n- Daenerys는 영향력 있는 친구들을 충분히 얻었는데, 그러나 그녀 주변의 사람들이 그녀의 임무를 위해 희생될 수도 있습니다;\n- Cersei 주변의 사람들이 사라지는 것을 보면 (그림 3에서 란니스터 가문과 유사한 작은 빨간 지역을 보십시오), 그녀와 가까이 있는 사람들에게 영향을 미치는 것 같습니다;\n- Theon과 Jorah는 생존할 가능성이 높아 보이며 (아마 이전 경험에 기반할지도 모릅니다);\n- 많은 사람들에게 친애받는 와일링 Tormund는 폐쇄되는 성벽에서 탈출뿐만 아니라 전쟁 전체에서도 생존할 것으로 보입니다.\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-NetworkSciencePredictsWhoDiesNextinGameofThrones_6.png\" /\u003e\n\n# 4. 결론\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nFigure 4에서 예측된 확률이 87% 미만에서 명확한 신호와 일치하지 않았지만 무작위 기준선(동전 던지기로 예측을 구축했다면 얻을 확률) 주변에 매우 겹치고 변동했습니다. 그러나 예측된 적중이 실제 적중과 매우 겹치는 87% 이상의 임계값을 넘어서 빠르고 명확한 증가를 보았습니다. 이 결론은 네트워크 특징이 '왕좌의 게임'에서 가장 명백한 죽음을 포착할 수 있었다는 것을 시사합니다. 그러나 불확실한 상황에서는 잘 작동하지 않았을 수 있습니다.\n\n![Image](/TIL/assets/img/2024-07-14-NetworkSciencePredictsWhoDiesNextinGameofThrones_7.png)\n\n부정확성과 한계는 여러 가지 차원이 있습니다. 먼저, 데이터의 청결함과 양을 개선할 수 있었을 것입니다. 둘째, 데이터 형식과 특징을 확장할 수 있었고, 예를 들어, 인물에 대한 메타 정보(예: 나이, 성별)를 이용하여 네트워크 특징을 보강하고 TV 시리즈 및 원작 책에서 정보를 결합할 수 있습니다. 마지막으로 가장 흥미로운 사항은 예측된 기간인 시즌 7과 8이 책을 기반으로 하지 않았다는 점입니다. 한편 다른 훈련 데이터는 그랬습니다. 이 차원은 성이 구축된 방식에 대한 논리가 어떻게 구성되었는지에 대한 관점에서 매우 중요하지만, 양적 방법으로 연구하기가 매우 어렵고 분명한 미래 연구 대상이 될 것입니다.\n\n# 5. 데이터 접근성\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 연구와 관련된 지원 파일은 https://github.com/milanjanosov/GameOfThron에서 찾을 수 있습니다.\n\n## 6. 면책 조항\n\n블로그 게시물은 원본 형태 그대로 섹션 두와 세에 게시되었지만, 일부 오타 및 문법 문제가 수정되었습니다. 이는 텍스트 의미에 영향을 미치지 않았습니다.\n\n## 7. 감사의 글\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저자는 중앙 유럽 대학교 학술 글쓰기 센터의 Ágnes Diós-Tóth, Thomas Rooney 및 Robin Bellers에게 이 논문과 원본 블로그 포스트의 여러 부분을 검토해 준 것에 대해 감사의 말씀을 전합니다.","ogImage":{"url":"/TIL/assets/img/2024-07-14-NetworkSciencePredictsWhoDiesNextinGameofThrones_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-NetworkSciencePredictsWhoDiesNextinGameofThrones_0.png","tag":["Tech"],"readingTime":12},{"title":"벨만-포드 알고리즘으로 최단 경로 찾는 방법","description":"","date":"2024-07-14 20:09","slug":"2024-07-14-FindShortestPathsWithBellman-Ford","content":"\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-FindShortestPathsWithBellman-Ford_0.png\" /\u003e\n\n최단 경로 찾기는 컴퓨터 과학에서 기본적인 문제로, 네트워크 라우팅 프로토콜부터 그래프 분석까지 다양한 알고리즘과 응용프로그램의 기초를 형성합니다. 현실에서는 물류 및 통신 네트워크에서 효율적인 경로를 찾고 여행 시간을 최소화하는 데 핵심적인 문제입니다.\n\n이 문제가 이렇게 중요하기 때문에 많은 사람들이 이를 해결하는 방법에 대해 고민했습니다. 이는 다양한 가정과 실행 시간을 가진 다양한 알고리즘의 동물원으로 이어졌습니다. 이 글에서는 벨만-포드 알고리즘의 작동 방식과 Python 및 Rust에서의 구현 방법을 보여 드리고자 합니다.\n\n# (Shimbel-)벨만-포드(-무어) 알고리즘\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n알고리즘의 이름부터 헷갈릴 수 있어요. 문헌에서는 벨만-포드 알고리즘으로 알려져 있지만 많은 사람들이 관여했습니다. Alexander Schrijver의 논문 \"조합 최적화의 역사에 대하여\"에 따르면, Alfonso Shimbel은 1955년에 동등한 알고리즘을 개발했고, Richard Bellman과 Lester Ford Jr.은 각각 1958년과 1956년에 이 알고리즘을 설명했습니다. 이후 Edward F. Moore가 1959년에 알고리즘의 변형을 발표했어요. 하지만 걱정하지 마세요, 이 알고리즘 자체는 그 역사보다 이해하기 쉬워요.\n\n이들의 알고리즘은 여러분이 주어진 그래프의 고정된 노드에서 시작하여 다른 각 노드까지의 최단 경로 문제를 해결해요. 다음과 같은 그래프를 예시로 삼아볼게요:\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-FindShortestPathsWithBellman-Ford_1.png\" /\u003e\n\n총 6개의 방향성이 있는 에지로 연결된 네 개의 노드를 볼 수 있어요. 각 에지는 가중치가 있습니다. 예를 들어, 3에서 0으로 가는 에지의 가중치는 1이에요. 노드 0에서 노드 2로의 최단 경로는 직접적인 0-2가 아닌 총 비용이 (-1)+1+0 = 0인 0-1-3-2일 수 있어요. 이제 이러한 경로를 알고리즘적으로 찾는 고수준 아이디어에 대해 이야기해볼게요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 아이디어\n\n알고리즘은 시작 노드로부터 i개 이하의 엣지를 사용하여 다른 모든 노드까지의 최단 경로의 길이를 배열 형태로 유지하는 간단한 아이디어를 중심으로 돌아갑니다.\n\n이 배열을 i = 0, 1, ...부터 순차적으로 계산합니다. 각 반복에서 i에 대한 정보는 이전 반복 i-1의 배열과 그래프의 엣지를 사용합니다.\n\n## 예시\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자 그럼 이제 작은 예제를 사용해보자. 노드 0에서 다른 모든 노드로 가는 최단 경로 길이를 찾고 싶다고 가정해보자. 나중 단계에서 실제 경로도 재구성할 것이지만, 일단은 일 노드 간의 경로 길이에만 관심을 갖자.\n\n거리 배열을 [0, ∞, ∞, ∞]로 시작한다. 즉, 우리는 최대 edge 0을 사용하여 0 노드에서 0 노드로 총 길이 0만큼 도달할 수 있다는 것이다. 이것은 우리가 정한 정의다. 두 번째 항목은 0 노드에서 1 노드로 최대 edge 0을 사용하여 ∞ 길이로 도달할 수 있음을 의미하는데, 즉 해당 노드에 도달할 수 없다는 것이다. 동일한 이유로 0 노드에서 2와 3으로 가는 것도 동일하다.\n\n거리를 해당 노드 옆에 써보자:\n\n![이미지](/TIL/assets/img/2024-07-14-FindShortestPathsWithBellman-Ford_2.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음 반복에서는 최소경로 길이를 포함하는 다른 배열 [a, b, c, d]를 채우려고 합니다. 이 배열은 노드 0에서 최대 한 개의 엣지를 사용하여 다른 모든 노드까지의 최단 경로 길이를 포함합니다. 이전 배열을 사용하여 이를 어떻게 계산하는지 살펴봅시다. 예를 들어, 노드 0에서 1까지의 최단 경로 길이를 알고 싶다면 두 가지 가능성이 있습니다:\n\n- 0에서 1까지 엣지를 사용하지 않고 이동하거나\n\n- 0에서 1까지 추가 엣지를 사용하여 이동합니다.\n\n옵션 1은 이전 배열 [0, ∞, ∞, ∞]에서 볼 수 있듯이 길이가 ∞입니다. 두 번째 옵션의 길이는 -1이며 그래프를 통해 노드 0에서 노드 1로 -1의 비용으로 이동할 수 있습니다. 분명히 이전에 보았던 ∞보다 -1이 더 작으므로 배열에 이를 넣어 보겠습니다. 다른 노드에 대해 동일한 작업을 수행하면 업데이트된 배열 [0, -1, 1, ∞]이 됩니다. 이제 이 반복이 완료되었습니다.\n\n그래픽적으로表시하면:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/TIL/assets/img/2024-07-14-FindShortestPathsWithBellman-Ford_3.png)\n\n다음 이터레이션에서는 같은 게임을 다시 합니다. 노드 0에서 다른 모든 노드로 가는 최단 경로 길이가 최대 두 개의 변을 사용하여 [a, b, c, d]를 채우고 싶습니다. 예를 들어, 노드 0에서 노드 3까지의 최단 경로 길이를 계산해 봅시다. 노드 0에서 노드 3으로 가는 여러 옵션이 있습니다:\n\n- 단일 변을 사용하여 0에서 3으로 이동: 길이는 이전 이터레이션의 배열에서 볼 수있는대로 ∞입니다.\n- 먼저 노드 1로 이동한 다음 1에서 3으로 가는 변을 사용할 수 있습니다. 하나의 변만 사용하여 노드 1로 가는 데 드는 비용은 배열에서 확인할 수 있는대로 -1입니다. 노드 1에서 노드 3으로 한 단계 더 가는 데 드는 비용은 그래프에서 확인할 수 있는대로 1입니다. 따라서 이미 이전 옵션보다 작은 비용인 0으로 노드 0에서 노드 3에 도달할 수 있습니다.\n- 먼저 노드 2로 이동한 다음 2에서 3으로 가는 변을 사용할 수 있습니다. 따라서 노드 0에서 노드 3으로 2 단계로 도달하여 비용은 1 + 2 = 3입니다.\n\n다른 옵션이 없으므로 두 번째 옵션에서 최단 경로 길이는 0입니다. 다른 노드에 대해도 수행하면 배열 [0, -1, 1, 0]을 얻을 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![이미지](/TIL/assets/img/2024-07-14-FindShortestPathsWithBellman-Ford_4.png)\n\n이전 배열 [0, -1, 1, 0]에서 시작하는 한 번 더의 반복 작업을 합니다. 이번 반복에서는 노드 0에서 노드 2로의 최단 경로 길이가 변하는 것 외에는 큰 변화가 없습니다. 이전 배열에서 볼 수 있듯이, 최대 두 개의 엣지를 사용하여 길이가 1인 것을 알 수 있습니다. 그러나 처음에 우리는 실제로 길이가 (-1) + 1 + 0 = 0인 0–1–3–2의 최단 경로를 보았습니다. 우리는 현재 반복에서 이 경로 길이를 찾을 것이며, 그러면 알고리즘이 종료됩니다. 이것은 네 개의 노드를 가지면 최단 경로가 최대 세 개의 엣지만을 포함해야 하거나 일반적으로 N 노드를 가지면 N— 1개의 엣지를 포함해야 하기 때문입니다.\n\n![이미지](/TIL/assets/img/2024-07-14-FindShortestPathsWithBellman-Ford_5.png)\n\n## 음수 순환이란\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마지막 문장에서 조금 거짓말을 한 것 같아요. 음의 순환이 존재할 수 있다는 건데요, 예를 들어 노드 u에서 자신으로 돌아와 경로의 총 길이가 0보다 작은 것입니다. 이 경우 순환을 돌 때마다 경로의 길이를 줄일 수 있기 때문에 최단한 경로가 없는 것이죠. 음의 순환을 찾으려면 N개의 노드가 있을 때 N번째 반복을 실행해야 합니다. 음의 순환하지 않는다면 이 반복에서 우리 배열이 변하지 않아야 합니다. 이것이 여전히 변경된다면, 어딘가에 음의 순환이 있다는 것을 알 수 있습니다. 이를 복원할 수도 있지만, 여기서는 그렇게 하지 않겠습니다.\n\n# 구현\n\n작은 코드량에 대한 많은 글입니다. 두 가지 다른 프로그래밍 언어인 Python과 Rust로 어떻게 하는지 살펴봅시다.\n\n## Python\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기 있습니다. 제가 경로 길이 뿐만 아니라 가장 짧은 경로를 재구성할 수 있는 다른 배열 prev도 계산합니다.\n\n```js\nN = 4\ngraph = {0: {1: -1, 2: 1}, 1: {3: 1}, 2: {3: 2}, 3: {0: 1, 2: 0}}\nstart = 0\n\ndists = [float(\"inf\") for i in range(N)]\nprev = [None for i in range(N)]\n\ndists[start] = 0\nprev[start] = start\n\nfor _i in range(N):\n    for node, edges in graph.items():            # 모두에 대해 반복\n        for next_node, weight in edges.items():  # `node`에서 시작하는 모든 간선에 대해 반복\n            candidate_length = dists[node] + weight\n            if candidate_length \u003c dists[next_node]:\n                dists[next_node] = candidate_length\n                prev[next_node] = node # `node`에서 `next_node`로 이동하는 것이 이전 경로보다 나은 것\n\nfor node, edges in graph.items():\n    for next_node, weight in edges.items():\n        if dists[node] + weight \u003c dists[next_node]:\n            print(\"음의 사이클이 감지되었습니다!\")\n\nprint(dists)\nprint(prev)\n```\n\n출력은 다음과 같습니다.\n\n```js\n[0, -1, 0, 0]\n[0, 0, 3, 1]\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n첫 번째 배열은 노드 0부터 노드 0, 1, 2 및 3으로 가는 가장 짧은 경로가 각각 0, -1, 0 및 0임을 나타냅니다.\n\n노드 0에서 노드 2로 길이가 0인 경로를 어떻게 얻을 수 있을까요? 두 번째 배열 prev를 살펴봅시다. 거기서 prev[2] == 3 이므로 노드 3에서 노드 2로 이동합니다. 따라서 경로는 3–2로 끝납니다. 또한 노드 3에서 노드 1로 이동한다는 것을 알 수 있습니다. 따라서 경로는 1–3–2로 끝납니다. 그리고 노드 1에서 노드 0으로 이동한다는 것을 알 수 있습니다. 따라서 전체 경로는 0–1–3–2 입니다.\n\n좋아요, Rust에서 같은 작업을 해봅시다!\n\n## Rust\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n한 줄 씩 번역해 보았습니다. Rust에 관심이 있는 분들에게 도움이 될 수도 있을 것 같아요.\n\n```rust\nuse std::collections::HashMap;\n\nfn main() {\n    const N: usize = 4;\n    let graph: HashMap\u003cusize, HashMap\u003cusize, f32\u003e\u003e = HashMap::from([\n        (0, HashMap::from([(1, -1.), (2, 1.)])),\n        (1, HashMap::from([(3, 1.)])),\n        (2, HashMap::from([(3, 2.)])),\n        (3, HashMap::from([(0, 1.), (2, 0.)])),\n    ]);\n    let start: usize = 0;\n\n    let mut dists = [f32::INFINITY; N];\n    let mut prev = [None::\u003cusize\u003e; N];\n\n    dists[start] = 0.0;\n    prev[start] = Some(start);\n\n    for _i in 0..N - 1 {\n        for (node, edges) in graph.iter() {\n            for (next_node, weight) in edges.iter() {\n                let candidate_length = dists[*node] + *weight;\n                if candidate_length \u003c dists[*next_node] {\n                    dists[*next_node] = candidate_length;\n                    prev[*next_node] = Some(*node);\n                }\n            }\n        }\n    }\n\n    for (node, edges) in graph.iter() {\n        for (next_node, weight) in edges.iter() {\n            if dists[*node] + *weight \u003c dists[*next_node] {\n                println!(\"Negative cycle detected!\");\n            }\n        }\n    }\n\n    println!(\"{:?}\", dists);\n    println!(\"{:?}\", prev);\n}\n```\n\n## 실행 시간과 메모리\n\n이 알고리즘은 그래프의 노드 수를 의미하는 N과 그래프의 간선 수를 의미하는 E에 대해 O(N · E) 시간에 실행된다는 것을 확인할 수 있어요. 이는 모든 N 노드를 순회하는 루프와 모든 E 간선을 순회하는 내부 루프가 중첩되어 있기 때문에 나타나는 직접적인 결과입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n메모리 사용량 측면에서는 추가로 크기가 N인 두 개의 배열과 몇 개의 상수만 저장하면 되므로 추가 메모리 복잡도는 O(N)이 됩니다.\n\n프로그래밍 언어의 성능 측정가들을 위해: 내 Python 버전은 평균적으로 노드당 10개의 이웃을 갖는 랜덤 1000개 노드 그래프에서 3초가 걸렸지만, Rust 버전은 동일한 그래프에서 0.5초가 걸렸습니다.\n\n# 결론\n\n이 글에서는 한 노드로부터 모든 노드까지의 최단 경로 길이와 최단 경로를 찾는 방법을 배웠습니다. 이를 위해 우리는 벨만-포드 알고리즘을 선택했습니다. 이 알고리즘은 빠르고 간단하며 효율적으로 구현할 수 있으며 추가 메모리를 많이 사용하지 않는 편리한 알고리즘입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n더 빠른 알고리즘인 다익스트라 알고리즘을 사용할 수는 없지만, 우리 예시에는 사용할 수 없습니다. 다익스트라 알고리즘은 양의 간선 가중치를 전제로 하기 때문이죠. 그래서 약간의 음의 간선 가중치를 더해 다른 알고리즘을 사용해야 했어요. 😉\n\n그래서 최단 경로 알고리즘을 구현하거나 이를 대신 처리해주는 라이브러리를 사용해야 할 때, 그 알고리즘이 어떻게 작동하는지 이해하게 되었으면 합니다.\n\n오늘 새롭고 흥미로운 가치있는 것을 배우셨기를 바랍니다. 읽어주셔서 감사합니다!","ogImage":{"url":"/TIL/assets/img/2024-07-14-FindShortestPathsWithBellman-Ford_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-FindShortestPathsWithBellman-Ford_0.png","tag":["Tech"],"readingTime":11},{"title":"Python에서 BERT를 사용한 토픽 모델링 방법","description":"","date":"2024-07-14 20:08","slug":"2024-07-14-TopicModellingwithBERTtopicinPython","content":"\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-TopicModellingwithBERTtopicinPython_0.png\" /\u003e\n\n토픽 모델링(즉, 텍스트 데이터 코퍼스에서의 토픽 식별)은 라텐트 디리클레 할당(LDA) 모델이 발표된 이후 빠르게 발전해왔습니다. 그러나 이 클래식한 토픽 모델은 단어들 간의 관계를 잘 포착하지 못합니다. 왜냐하면 단어 가방이라는 통계적 개념에 기반하기 때문입니다. 최근에는 임베딩 기반의 Top2Vec와 BERTopic 모델이 사전 훈련된 언어 모델을 활용하여 토픽을 생성함으로써 이러한 단점을 극복하고 있습니다.\n\n이 기사에서는 Maarten Grootendorst의 (2022) BERTopic을 사용하여 정치 연설 원고에서 토픽을 대표하는 용어를 식별할 것입니다. 이 모델은 다양한 코퍼스에서의 토픽 모델링 지표에서 전통적이고 현대적인 대부분의 토픽 모델을 능가하며, 기업, 학계(Chagnon, 2024) 및 공공부문에서 활용되어왔습니다. 우리는 다음을 파이썬 코드를 통해 살펴볼 것입니다:\n\n- 데이터를 효과적으로 전처리하는 방법\n- Bigram 토픽 모델을 생성하는 방법\n- 시간이 지남에 따라 가장 빈번한 용어를 탐색하는 방법.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 1. 예제 데이터\n\n예제 데이터 세트로는 Efat et al. (2023) 논문의 일환으로 공개된 Empoliticon: Political Speeches-Context \u0026 Emotion 데이터 세트를 사용합니다. 해당 데이터 세트는 국제 저작권 4.0 라이센스에 따라 출시되었으며 미국, 영국, 중국 및 러시아 대통령/총리의 정치 연설 2010개의 대본을 포함하고 있습니다. 주제 모델을 더 집중시키기 위해 하위 집합에는 러시아 리더들의 556개 연설만 포함되어 있습니다:\n\n![image](/TIL/assets/img/2024-07-14-TopicModellingwithBERTtopicinPython_1.png)\n\n# 2. 데이터 전처리\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n텍스트 데이터셋 작업은 복잡합니다. 단순한 정리만으로도 데이터셋에서 모든 불필요한 정보를 체계적으로 제거해야 하는 여러 단계가 필요합니다. 이 프로젝트의 모든 요구 사항을 확인해 주세요.\n\n### 2.1. 못 읽는 문자(mojibake) 오류 수정\n\n못 읽는 문자(mojibake)는 문자 인코딩 오류로 인해 나타나는 혼란스러운 텍스트를 의미하는 일본어 단어입니다. 다음은 예시입니다:\n\n![example](/TIL/assets/img/2024-07-14-TopicModellingwithBERTtopicinPython_2.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n클리닝을 시작하기 전에 이 단계를 포함하는 것이 유용합니다. 인코딩 관련 오류를 수정하는 것은 간단합니다:\n\n2.2. 특수 문자, 구두점 및 숫자 정리\n\n이 단계는 인코딩 오류를 수정한 후에 바로 이어져야 합니다. 가장 간단한 방법은 cleantext 라이브러리를 사용하는 것입니다. 또한 소문자화를 고려하세요. 데이터 집합에서 \"노동\"과 \"Labor\"가 같은 의미인가요? 그렇다면 lowercase 매개변수를 추가하고 클리닝 함수를 적용하십시오:\n\n2.3. 불용어 제거 전략 정의\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n일반적으로 불용어 목록을 제거하는 것은 필수적입니다. 프로젝트의 초점에 따라, 가치를 더하지 않는 추가적인 불용어 목록에서 데이터를 정리하는 것도 유용할 수 있습니다. BERTopic의 문서에 작성된 것처럼:\n\n대신, 주제 모델 생성 중 임베딩을 생성한 후 문서를 전처리하는 데 CountVectorizer를 사용합니다.\n\n# 3. 주제 생성\n\n보다 깔끔한 데이터셋으로, 영어 불용어와 추가 불용어 목록을 제거하고, 주제 바이그램 모델을 생성한 후 데이터에 적용할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nnr_topics parameter은 7로 설정되어 있으며, 6개의 토픽을 생성합니다. 나머지 토픽은 이상치를 유지하는 데 사용됩니다.\n\n# 4. 토픽 시각화\n\n다음 단계에서는 결과를 더 잘 표현하기 위해 히트맵으로 데이터를 시각화해보겠습니다. 결과는 다음과 같습니다:\n\n![Topic Modelling with BERT topic in Python](/TIL/assets/img/2024-07-14-TopicModellingwithBERTtopicinPython_3.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래와 같이 하겠습니다. 토픽 모델에서 바이그램과 그 확률을 추출하여 6개 주제에 대한 데이터 프레임을 작성할 것입니다:\n\n다음으로, 이 코드는 Figure 1에 히트맵을 생성합니다.\n\n## 5. 시간별 토큰 빈도\n\n이제, 시간에 따른 바이그램의 발전에 대한 관점을 추가할 것입니다. 러시아 지도자의 연설에서 어떤 연도에 바이그램이 가장 자주 사용되었는지 살펴볼 것입니다. Figure 2의 히트맵은 각 연도별로 5개 가장 빈도가 높은 바이그램의 빈도를 표시합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](/TIL/assets/img/2024-07-14-TopicModellingwithBERTtopicinPython_4.png)\n\nThe arabica library, which is now forthcoming in the Journal of Open Source Software (Koráb \u0026 Poměnková, 2024), was developed for this purpose. Here is the code generating the heatmap in Figure 2:\n\n![image](/TIL/assets/img/2024-07-14-TopicModellingwithBERTtopicinPython_5.png)\n\n# Conclusions\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 기사는 BERTopic을 사용한 토픽 모델링에 대해 간단히 소개했습니다. 이 모델의 프레임워크는 다양한 확장, 세밀 조정 및 시각화 방법을 제공합니다(문서 참조). 주요 결과를 요약해보겠습니다:\n\n- 토픽 모델은 방어 정책(토픽 1), 경제 발전(토픽 2), 제2차 세계대전(토픽 3), 내부 정책(토픽 4), 건강 및 인구통계(토픽 5), 교육(토픽 6)에 대해 6가지 명확한 토픽을 보여줍니다.\n- Arabica와 BERTopic을 결합하면 외교 및 방위 정책 토픽(“군사”, “러시아 연방”, “법 집행”)이 2012년 이전에 더 자주 논의되었음을 볼 수 있습니다. 반면 교육 및 건강관련 주제가 특히 2010년 이후에는 적게 논의되었습니다.\n- Arabica가 절대 빈도를 반환하기 때문에 데이터셋에는 제2차 세계대전, 외교 및 방위 정책 용어가 더 많이 포함되어 있습니다. 그러나 지역적 맥락을 알지 못하면 결과를 잘 해석하기 어렵습니다.\n\n이전 기사에서 간단한 LDA를 사용한 토픽 모델링 접근 방식에 대해 설명한 바 있습니다. 이 튜토리얼의 완전한 코드는 내 GitHub에 있습니다.\n\n제 작품을 즐기신다면 커피를 사주시고 글쓰기를 지원할 수 있습니다. 또한 새 기사 발행 알림을 받기 위해 이메일 목록을 구독할 수도 있습니다. 감사합니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 참고 자료\n\n[1] Blei, Ng, Jordan (2003). Latent Dirichlet Allocation. Journal Of Machine Learning Research 3, pp. 993–1022.\n\n[2] Chagnon, Pandolfi, Donatelli, Ushizima (2024). Benchmarking topic models on scientific articles using BERTeley. Natural Language Processing Journal 6.\n\n[3] Efat, Atiq, Abeed, Momin, Alam (2023). Empoliticon: NLP 및 MLBased Approach를 사용한 정치 연설에서 컨텍스트 및 감정 분류. IEEE Access, vol. 11.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n[4] Grootendorst (2022). Bertopic: Neural Topic Modeling With A Class-Based TF-IDF Procedure. Computer Science.\n\n[5] Koráb, Poměnková (2024). Arabica: A Python package for exploratory analysis of text data. In The Journal of Open Source Software. Journal of Open Source Software. https://doi.org/10.5281/zenodo.10866697.","ogImage":{"url":"/TIL/assets/img/2024-07-14-TopicModellingwithBERTtopicinPython_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-TopicModellingwithBERTtopicinPython_0.png","tag":["Tech"],"readingTime":7},{"title":"데이터 과학에서 자주 오해받는 5가지 단어","description":"","date":"2024-07-14 20:06","slug":"2024-07-14-FiveMassivelyMisusedWordsinDataScience","content":"\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-FiveMassivelyMisusedWordsinDataScience_0.png\" /\u003e\n\n우리 모두가 아는 대로, 데이터 과학은 우리의 세계에 매우 새로운 학문입니다. 이로 인해 이는 일할 때 매우 흥미로운 분야가 됩니다. 그러나 이로 인해 문제가 발생하기도 합니다. 오늘은 그 중 하나인 문제에 대해 이야기하고 싶습니다: 데이터 과학 결과나 개념을 설명할 때 잘못된 용어를 사용하는 문제입니다.\n\n제가 항상 다뤄야 하는 다섯 가지 자주 오용되는 단어와 전형적인 오용에 대한 설명이 있습니다. 이를 통해 데이터 과학 결과의 전달 및 구현에서의 함정에 대해 더 많이 인식하게 된다면 좋겠습니다.\n\n## 1. 예측적인\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n와우, 사람들은 세상을 예측하는 걸 정말 좋아하네요, 그렇죠? 2010년쯤 유행하기 시작한 이후로, p-단어처럼 흔히 들어본 말은 없는 것 같아요. 계수가 통계적으로 유의미한 변수인 x는 선형 모델에서 중요하다고 하더라도, 그 변수가 예측력이 있는 것은 아닙니다. 그건 상당히 무리인 주장이죠.\n\n훈련된 통계 모델에서 유의미한 영향을 끼치는 변수들도, 그 효과가 미미해서 사실상 중요하지 않을 수도 있어요. 따라서, 그 변수들을 '예측적으로' 설명한다는 것은 현실을 잘못 표현할 수도 있어요. 새로운 데이터에 대한 테스트 과정이 필요한데, 이를 통해 모델이나 변수들을 실제로 '예측적인지' 설명할 수 있어요. 며칠 전에 로지스틱 회귀 모델 결과를 사람이 '예측적이다'라고 설명했을 때, 저는 훈련 및 테스트 데이터를 나누지 않았고, 예측을 시도하고 있지도 않았는데요. 규칙적으로, 왼쪽에 빼놓은 테스트 샘플을 사용하여 예측 효과를 확인하지 않으면 변수나 모델을 '예측적으로' 설명하지 마세요.\n\n## 2. R-squared\n\nR-squared는 대체로 선형, 가법적 모델의 모델 품질 측정으로만 적용됩니다. 그런데 제가 종종 확률 모델이나 분류기에 '높은 R-squared'를 갖고 있다고 하는 사람들을 듣곤 해요. 그게 무슨 뜻일까요? 심플한 일반화된 선형 모델조차도 전체적인 모델 품질을 정의하는 여러 방법이 있어요. 이러한 모델들에는 적어도 5가지 다른 유사 R-squared 메트릭스가 있고, 그 결과는 크게 다를 수 있으며 해석하기 어려울 수 있어요. 예측 정확도 메트릭스인 ROC AUC, F1-score와 같은 지표까지 더해져서 혼란스러울 수 있죠.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n사람들이 한 접근 방식의 용어를 다른 접근 방식에서 무언가를 설명할 때 사용하지 못하도록 허락하지 마세요. 이것은 좋지 않은 실천이며 지적으로 정직하지 못할 수도 있습니다. 미리 적합한 품질 측정 항목을 합의하고 사람들이 그것을 준수하도록 유도하세요.\n\n### 3. 확률\n\n확률 모델링을 하다보면 odds(승산) 용어를 자주 만날 것입니다. 이 모델의 계수를 해석할 때 odds가 자연스럽게 발생합니다. 그러나 odds는 확률을 의미하지 않습니다. 이 오해는 odds 비율을 사람들에게 설명할 때 정말 나쁠 수 있습니다. 모델에서 변수가 300%의 odds 비율을 가진다면, 사람들은 종종 해당 변수의 단위 증가가 결과의 확률을 세 배로 만든다고 생각합니다. 정말 멋지게 들리죠! 그것은 틀렸습니다. 결과에 미치는 확률의 영향은 사전 확률이 무엇이었느냐에 달려 있습니다. 이미 매우 높은 경우, 300%의 odds 비율은 거의 영향을 주지 않을 것입니다. 매우 낮은 경우, 실제로 300%의 영향을 줄 것이지만, 작은 것의 300%는 아마도 여전히 작을 것입니다. 더 읽고 싶다면 이 주제에 대한 제 기사를 확인하세요.\n\n### 4. 증명\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n통계 검정에서 잘못 사용되는 또 다른 p 단어는 입증(Prove)이다. 가설을 입증하거나 반박하지 않습니다. 귀무 가설(null hypothesis)을 기각하거나 기각하지 못합니다. 많은 사람들이 제대로 이해하지 않는 철학이며, 이는 분명히 의미론적인 것이 아닙니다.\n\n예를 들어, 12세에서 16세 사이의 소년과 소녀가 친구의 평균 수가 동일한지 테스트하고 싶다고 가정해봅시다. 해당 연령대의 충분한 샘플을 조사하여 모든 소년과 소녀 사이의 평균 친구 수에 차이가 없다는 귀무가설을 세우고, 우리가 가진 표본의 통계적 특성을 고려하여 그 귀무가설이 얼마나 진실일지 확인합니다. 무작위로 설정된 확률 막대(알파)를 사용하여(`보통 5% 정도) 귀무가설을 기각할 수 있다고 선언할 수도 있습니다.\n\n소년과 소년이 서로 다른 평균 친구 수를 가진다는 것을 증명했다고 말할 수 없습니다. 두 그룹이 같은 친구 수를 가질 가능성은 낮다고 말할 수 있거나 '통계적 검정이 알파 0.05에서 귀무가설을 기각했다'라고 말할 수 있습니다. 입증은 100% 확신을 의미하며, 표본을 다룰 때는 그 정도에 도달할 수 없습니다.\n\n## 5. 파워\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n통계적 파워라는 또 다른 p로 시작하는 용어는 종종 사람들이 그 의미를 이해하지 못하는 사람들 사이에서 사용되는 것입니다. 많은 사람들이 무언가가 높거나 낮은 통계적 파워를 갖고 있다고 말하지만, 실제로 의미하는 것은 낮거나 높은 p-값 또는 높거나 낮은 표본 크기입니다. 통계적 파워가 무엇인지 정의할 수 있는지 스스로에게 묻는 것이 중요합니다.\n\n통계적 파워는 사실 대안 가설이 참일 때 널 가설을 기각할 확률을 나타냅니다. 이것은 기본적으로 널 가설의 기각이 얼마나 신뢰할 수 있는지 나타내는 측정 지표입니다. 이는 p-값 이상으로 많은 요소에 의해 결정되며, 샘플 크기, 알파, 효과 크기를 사용하여 계산됩니다. 실제로 더 높은 알파나 낮은 샘플 크기를 갖는 결과가 더 높은 통계적 파워를 가질 수 있는 것은 완전히 가능합니다.\n\n데이터 과학이나 통계학에서 자주 오용되는 용어가 있나요? 그러한 경우가 있다면 언제든지 댓글을 남겨주세요.","ogImage":{"url":"/TIL/assets/img/2024-07-14-FiveMassivelyMisusedWordsinDataScience_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-FiveMassivelyMisusedWordsinDataScience_0.png","tag":["Tech"],"readingTime":4},{"title":"코드 없는 GenAI 에이전트 워크플로우 오케스트레이션 로컬 Mistral AI 모델과 함께하는 AutoGen Studio 사용법","description":"","date":"2024-07-14 20:04","slug":"2024-07-14-NoCodeGenAIAgentsWorkflowOrchestrationAutoGenStudiowithLocalMistralAImodel","content":"\n\n자유 링크 — 이 LinkedIn 게시물을 좋아해 주세요\n\nAutoGen은 Microsoft에서 개발한 프레임워크로, 특히 LLM 에이전트를 조정하는 다중 에이전트 애플리케이션 개발을 간소화하기 위해 설계되었습니다.\n\n다중 에이전트 애플리케이션은 여러 LLM 또는 다중 모달 에이전트 또는 엔티티가 전체 워크플로에서 상호 작용하여 특정 목표나 작업을 달성하는 시스템을 의미합니다. 이러한 에이전트는 LLM 에이전트, 검색에이전트 또는 독립적인 결정을 내리거나 기능 호출 또는 조치를 취할 수 있는 다른 에이전트일 수 있습니다.\n\nAutoGen에 대해 더 알고 싶다면 이전 기사를 참조해주세요: AutoGen In-depth yet Simple.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n미스트랄 AI는 2023년 4월에 메타와 구글 연구원 출신인 프랑스의 AI 회사입니다. 이 회사는 오픈 대형 언어 모델 (LLM)을 제작하는 데 중점을 두며 오픈 소스 AI 모델의 중요성을 강조합니다.\n\n이 기사에서는 AutoGen Studio의 직관적인 노코드 플랫폼과 지역 통합 미스트랄 AI 모델의 혁명적인 융합에 초점을 맞출 것입니다. 이 조합은 AI를 응용프로그램에 쉽게 통합하는 데만 그치는 것이 아니라, 다양한 생성적 AI 에이전트를 어떻게 상호 작용, 배포하며 현실적인 업계 업무 흐름에서 혜택을 누르는 데에 도움을 주는 데 있습니다.\n\n# AutoGen Studio의 인터페이스 탐색:\n\n## AutoGen Studio 설치\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAutoGen Studio는 오픈 소스 코드로 여기에서 사용할 수 있으며 pip를 통해 설치할 수 있습니다.\n\n```js\npip install autogenstudio\n```\n\n## Autogen Studio 실행\n\n설치가 완료되면 터미널에 다음을 입력하여 웹 UI를 실행할 수 있습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\nautogenstudio ui --port 8082\n\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-NoCodeGenAIAgentsWorkflowOrchestrationAutoGenStudiowithLocalMistralAImodel_0.png\" /\u003e\n\nAutoGen Studio는 다중 에이전트 AI 응용 프로그램의 생성 및 관리를 용이하게 하는 간소화되고 사용자 친화적인 인터페이스를 제공합니다. 이 인터페이스는 Skills, Models, Agents 및 Workflows와 같은 몇 가지 섹션으로 분할되어 있으며, 각각이 응용 프로그램 개발에 필수적인 역할을 합니다.\n\n## Skills\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기술 섹션에서는 에이전트가 작업을 해결하는 데 사용할 Python 함수를 개발하고 저장할 수 있습니다. 여기는 응용 프로그램의 기능이 정의되고 개발되는 프로그래밍 환경입니다.\n\n## 모델\n\n모델 섹션은 GPT-4 및 기타 로컬 또는 사용자 정의 모델을 구성하고 관리할 수 있는 사용자 모델입니다.\n\n사용자는 Mistral AI와 같은 모델을 설정할 수 있으며, 스튜디오가 로컬 AI 모델 통합 및 관리를 지원한다는 것을 나타냅니다. 이러한 유연성을 통해 OpenAI의 GPT-4 같은 강력한 모델 및 특정 작업에 맞게 개발된 자사의 또는 전문화된 모델을 함께 사용할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 에이전트\n\n'에이전트' 섹션은 재사용 가능한 에이전트를 구성하는 데 사용됩니다. 사용자는 로컬 어시스턴트, 주 에이전트, 사용자 프록시 등 다양한 에이전트의 역할을 생성하고 정의할 수 있으며, 이들이 앱의 워크플로우 내에서 상호 작용하는 방식을 조율할 수 있습니다.\n\n# 워크플로우\n\n'워크플로우' 섹션은 마법이 일어나는 곳입니다. 사용자는 시스템이 작업을 처리하는 방식을 정의하는 복잡한 워크플로우를 설계할 수 있습니다. 이곳에서 모든 구성 요소가 하나로 결합됩니다: 'Skills'는 논리를 제공하고, 'Models'는 AI의 지능을 제공하며, '에이전트'는 작업을 수행하며, '워크플로우'는 모든 것을 일관된 시스템으로 연결합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n플랫폼의 인터페이스는 직관적이며 각 섹션이 명확히 표시되어 있고 시각적 레이아웃을 통해 네비게이션을 간단하게 유도합니다. 새로운 에이전트, 모델 또는 기술을 추가하는 경우, 일반적으로 몇 번의 클릭만으로 간단한 프로세스로 진행됩니다. 생생한 색상과 현대적인 디자인 요소의 사용으로 사용자 경험을 쾌적하고 사용하기 쉽게 만듭니다.\n\n## 지역 미스트랄 AI 모델 통합\n\n지역 미스트랄 AI 모델을 AutoGen Studio의 생태계에 통합하는 것은 매우 쉽고 직관적입니다. 사용자는 자신의 지역 모델을 스튜디오에 추가하고 앱 내의 다른 구성 요소와 상호작용하는 방법을 정의할 수 있습니다. GPT-4 비전, GPT 3.5, GPT 4 turbo와 같은 다중 모달 모델의 파워와 미스트랄 AI와 같은 지역 모델을 결합해야 하는 사용자들에게 특히 유용합니다.\n\n요약하자면, AutoGen Studio는 다중 에이전트 AI 기반 응용 프로그램을 구축하기 위한 포괄적이고 접근하기 쉬운 도구로, 다양한 AI 모델 및 사용자 정의 기술을 수용하여 개발자와 비즈니스에게 다재다능한 선택지를 제공합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 로컬 Mistral AI 모델 설정하기:\n\n로컬 Mistral AI 모델 설정은 여러 단계로 이루어져 있으며, 각 단계마다 시스템이 Ollama사의 Mistral 모델과 같은 대규모 언어 모델을 로컬에서 실행할 수 있는 환경으로 준비됩니다. 각 단계와 그 필요성에 대한 설명은 다음과 같습니다:\n\n- Ollama 설치: Ollama는 대규모 언어 모델에 액세스할 수 있는 플랫폼입니다. Ollama를 설치하는 것은 첫 번째 단계이며, Mistral 모델이 실행될 환경입니다. 이를 통해 사용자는 Llama 2, Code Llama, Mistral과 같은 기존 모델을 실행하거나 사용자 정의 및 배포할 수 있습니다. Ollama는 다음 링크에서 다운로드할 수 있습니다: https://ollama.ai/\n\n![이미지](/TIL/assets/img/2024-07-14-NoCodeGenAIAgentsWorkflowOrchestrationAutoGenStudiowithLocalMistralAImodel_1.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2. Ollama Mistral 실행: Ollama 플랫폼에서 아래 명령을 실행하여 Mistral 모델을 시작합니다. 이 명령은 모델을 설정하고 필요한 데이터를 로드하며 쿼리 처리를 담당하는 서비스를 시작합니다.\n\n```js\nollama run mistral\n```\n\n2. LiteLLM 설치: LiteLLM 라이브러리는 http 엔드포인트에서 언어 모델을 실행하는 데 도움을 주는 도구입니다. LiteLLM을 설치하거나 업그레이드하면 라이브러리의 최신 버전을 사용할 수 있어서 호환성과 기능의 관점에서 중요합니다.\n\n```js\npip install litellm --upgrade\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n3. Gunicorn 설치: Gunicorn은 UNIX 시스템용 Python WSGI HTTP 서버로, Python 웹 애플리케이션을 실행하는 데 사용됩니다. LiteLLM 프록시를 실행하는 데 필요하며 이를 통해 귀하의 언어 모델에 로컬 HTTP 요청을 보낼 수 있습니다.\n\n```js\npip install gunicorn\n```\n\n4. Ollama/Mistral 모델을 사용하여 LiteLLM 실행: 이 단계는 모델을 초기화하고 실행할 준비를 하는 과정입니다. 이 명령은 LiteLLM이 Ollama가 제공하는 Mistral 모델을 사용하도록 지시합니다. 상호작용을 위해 모델을 준비하여 쿼리를 시작하고 응답을 받을 수 있게 합니다.\n\n이 프로세스가 끝나면 로컬의 Mistral 모델이 0.0.0.0:8000에서 1개의 워커와 함께 시작됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이러한 각 단계는 로컬에서 AI 모델과 상호 작용할 수 있는 완전한 작업 환경을 설정하는 데 필요합니다. 이 로컬 설정을 통해 개발자는 클라우드 서비스와 지속적으로 통신할 필요 없이 AI 모델을 테스트하고 통합할 수 있습니다. 이는 개발 속도, 오프라인 기능, API 호출 비용 절감 등에 도움이 될 수 있습니다.\n\n![image](/TIL/assets/img/2024-07-14-NoCodeGenAIAgentsWorkflowOrchestrationAutoGenStudiowithLocalMistralAImodel_2.png)\n\n# AutoGen 및 Mistral AI와의 Workflow Orchestration:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파이썬 스크립트를 작성하여 사인 파형을 그래프로 그리고 'sine_wave.png' 파일로 저장하는 상황에서 AutoGen과 Mistral AI를 함께 사용하여 원활한 워크플로우를 만들 수 있습니다. AutoGen Studio는 멀티 에이전트 애플리케이션을 구축하고 관리하기 위한 인터페이스로 작용하며, Mistral AI는 로컬 모델을 통해 처리 능력을 제공합니다.\n\n다음은 두 플랫폼의 기능을 활용하여 오케스트레이션하는 방법입니다:\n\n## 1. 워크플로우 생성:\n\n- AutoGen Studio에서 사인 파형 이미지를 생성하는 특정 작업을 위한 새로운 워크플로우를 시작합니다.\n- 우리는 워크플로우에 \"Local mistral Agent Workflow\"와 같은 이름을 구성합니다.\n- 워크플로우 사양에는 송신자 및 수신자 에이전트가 포함되어 있으며, 'userproxy'가 요청을 시작하는 송신자로, 'primary_assistant'가 요청을 처리하고 출력을 제공하는 수신자로 지정될 수 있습니다.\n- 사용자 프록시의 역할은 사용자와 상호 작용하고 primary_assistant가 생성한 코드를 실행하는 것입니다. 코드에 오류가 발생하면 해당 오류를 primary_assistant 에이전트에 보냅니다.\n- primary_assistant 에이전트는 로컬 Mistral AI 모델을 활용하여 우리 시나리오에서 코드를 생성합니다. 코드에 오류가 있으면 사용자 프록시 에이전트가 보낸 실행 오류에 따라 코드를 조정합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 2. 모델 구성:\n\n- '미스트랄 로컬 모델'이라는 모델이 AutoGen Studio 내에 설정되어 Mistral AI와 상호 작용하도록 구성됩니다.\n- 모델의 API 엔드포인트는 Mistral AI가 실행 중인 로컬 서버 주소로 구성됩니다 (예: http://0.0.0.0:8000).\n- 이 설정을 통해 AutoGen Studio가 데이터를 Mistral AI 모델로 보내고 처리된 결과를 받을 수 있습니다.\n\n## 3. 세션 실행:\n\n- AutoGen Studio의 'Playground' 인터페이스에서 사용자는 '로컬 미스트랄 에이전트 워크플로'를 선택하여 새 세션을 시작합니다.\n- 사용자는 삼각파 플롯을 생성하기 위한 명령 또는 요청을 입력합니다.\n- 요청은 사용자 프록시 에이전트가 주요 어시스턴트 에이전트로 전송되어 Mistral AI 모델을 활용합니다. 이렇게 하여 Python 스크립트가 생성되고 사용자 프록시 에이전트가 코드를 실행합니다. 오류가 발생하면 이를 주요 어시스턴트 에이전트로 되돌려보냅니다. 주요 어시스턴트 에이전트가 코드를 재조정하여 사용자 프록시 에이전트로 다시 전송하고 코드가 작동되어 삼각파 플롯 이미지를 생성합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 4. 결과 및 검토:\n\n- Mistral AI에서 스크립트를 실행하면 'sine_wave.png' 파일이 생성되어 디스크에 저장됩니다.\n- AutoGen Studio 인터페이스에서는 세션 진행 상황 및 결과가 표시되며, 'sine_wave.png' 파일과 'sine_wave'를 플로팅하는 파이썬 코드가 생성됩니다.\n- 사용자는 결과를 검토하고, 널리 사용할 수 있도록 워크플로를 게시하거나, 처음부터 다시 시작하려면 모델을 삭제하거나, 스크립트를 개선하고 워크플로 매개변수를 더 세밀하게 조정하기 위해 추가적으로 반복할 수 있습니다.\n\n# 결론:\n\nAutoGen Studio와 로컬 Mistral AI 모델은 GenAI 에이전트의 워크플로를 조정하는 데 주요한 진전을 보여줍니다. 이 아키텍처는 AutoGen Studio의 직관적인 디자인과 Mistral AI의 우수한 성능을 결합하여, 다중 에이전트가 기여할 수 있는 환경을 구축합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAutoGen Studio와 로컬 Mistral AI 모델의 장점:\n\n- 쉬운 통합: 로컬 Mistral AI 모델이 AutoGen Studio에 쉽게 통합되어 다양한 LLM 모델을 한 배포로 효율적으로 활용하는 과정을 간소화합니다.\n- 맞춤 및 유연성: 개발자들은 AI 모델을 특정 요구 사항에 맞게 맞춤화하여 하나의 프로젝트의 다양한 필요에 완벽히 맞는 맞춤형 솔루션을 제공할 수 있습니다.\n- 향상된 성능: AutoGen과 함께 로컬에서 AI 모델을 실행하면 지연 시간이 줄어들고 응답 시간이 향상되어 실시간 애플리케이션 및 민감한 작업에 중요합니다.\n- 데이터 개인 정보 보호 및 보안: AI 모델의 로컬 실행은 데이터에 대한 완전한 통제를 제공하며 외부 환경에 노출되어서는 안 되는 민감하거나 전문성이 있는 정보에 대해 핵심적인 역할을 합니다.\n- 비용 효율성: 클라우드 기반 AI 서비스에 대한 의존을 최소화하여 데이터 전송 및 LLM API 사용과 관련된 비용을 크게 절감할 수 있습니다.\n- 오프라인 기능: 로컬 Mistral AI 모델을 사용하면 인터넷 연결이 없어도 시스템이 작동되는 것을 보장하여 AI 기반 솔루션의 오프라인 기능을 허용합니다.\n- UI로 복잡한 AI 워크플로우 작성: 사용자는 AutoGen Studio의 노코드 인터페이스를 활용하여 AI 기반 워크플로우를 직관적으로 설계하고 관리할 수 있습니다.\n\n이 기사에서는 AutoGen Studio와 로컬 Mistral AI 모델의 통합이 GenAI 워크플로우의 세계에서 혁명적인 발전을 가져왔습니다. 성장하는 고급 AI 애플리케이션 수요를 충족시키는 사용자 친화적이고 유연하며 비용 효율적인 솔루션을 제공하여 AI 애플리케이션을 만들기가 언제보다 쉬워졌습니다.\n\n# 떠나기 전에! 🦸🏻‍♀️\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 만약 이 글이 유익하다고 느끼신다면, 이 LinkedIn 글을 ‘좋아요’해 주세요. 또한 무료 친구 링크를 LinkedIn 글에서 찾을 수 있습니다. 여러분의 참여는 이 글을 더 홍보하는 데 도움이 될 것이며, 여러분의 지지는 저에게 큰 원동력이 됩니다. ✍🏻🦾❤️\n- 이 글을 50번 클랩해 주시면, 정말로 저를 도와주시고 다른 사람들에게 이 글을 알릴 수 있습니다. 👏\n- 제 최신 글을 보려면 Medium, LinkedIn에서 팔로우하고 구독해주세요. 🫶\n\n# 흥미 있는 주제라면, 더 많은 글을 읽어보실 수 있습니다.","ogImage":{"url":"/TIL/assets/img/2024-07-14-NoCodeGenAIAgentsWorkflowOrchestrationAutoGenStudiowithLocalMistralAImodel_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-NoCodeGenAIAgentsWorkflowOrchestrationAutoGenStudiowithLocalMistralAImodel_0.png","tag":["Tech"],"readingTime":12},{"title":"선형 회귀 쉽게 이해하기  실생활 예시와 함께하는 초보자 가이드","description":"","date":"2024-07-14 20:03","slug":"2024-07-14-SimplifyingLinearRegressionABeginnersGuidewithareal-worldPracticalExample","content":"\n\n선형 회귀는 머신 러닝 세계에서 가장 기본적인 알고리즘 중 하나이며, 분석의 ABC와 같습니다.\n\n하늘의 별무리를 통해 가장 적합한 선을 만든다고 생각해보세요. 여기서 각 별은 데이터 점을 나타냅니다.\n\n오늘은 선형 의존성의 클래식 예시 중 하나인 키와 몸무게를 활용해 실제 세계 머신 러닝에 대해 알아보겠습니다 👇🏻\n\n# 기본 원리 이해하기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n간단한 선형 회귀는 가장 기본적인 머신러닝 알고리즘입니다. 데이터 모델링에 대한 여정을 시작하는 대부분의 경우입니다.\n\n신장과 몸무게를 그래프로 그려보면, 신장이 증가함에 따라 몸무게도 증가하는 선이 대략적으로 나타날 것입니다.\n\n그것이 선형 회귀의 핵심입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러니까 이 작업을 어떻게 수행할 수 있는지 살펴보겠습니다...\n\n## #1. 데이터 탐색 - 뛰기 전에 훔쳐보기\n\n분석에 들어가기 전에 데이터와 친해지는 것부터 시작해봐요.\n\n세 개의 열이 있는 테이블을 상상해보세요: 성별, 키, 몸무게.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](/TIL/assets/img/2024-07-14-SimplifyingLinearRegressionABeginnersGuidewithareal-worldPracticalExample_1.png)\n\n파이썬의 df.info()로 간단히 살펴보면 수천 개의 항목이 있고 중요한 것은 결측값이 없다는 것입니다.\n\n그리고 데이터의 분포는 어떤가요?\n\n키에 대한 종모양 곡선 하나와 몸무게에 대한 종모양 곡선 하나를 생각해보세요. 두 곡선 모두 나비 날개만큼 대칭적인데요 — 바로 여기가 우리의 정규 분포입니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-SimplifyingLinearRegressionABeginnersGuidewithareal-worldPracticalExample_2.png\" /\u003e\n\n# #2. 최적 선을 찾는 방법\n\n우리의 최적 선을 얻기 위해서는 여러 가지 방법이 있습니다. 오늘날 대다수의 사람들은 scikit-learn을 활용하여 미리 빌드된 선형 회귀 알고리즘을 적용할 것입니다.\n\n그러나 이번에는 최초로 세 가지 다른 방법을 시도해 봅시다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 2 DIY — 모두 스스로 알고리즘 생성.\n- 1 최종 방법은 scikit-learn 활용하는 것.\n\n## 접근 방법 #1: 최소 제곱법 (OLS)\n\n최소 제곱법(OLS)의 목적은 예측 오차의 제곱을 최소화하여 최적의 계수 A와 B를 결정하는 것입니다 — 이것이 바로 선형 회귀의 비용 함수인 MSE입니다.\n\n미적분을 활용하여 비용 함수의 최소값을 찾기 위해 편미분의 성질을 이용합니다. 그리고 이러한 편미분이 0이 되는 지점이 최소값에 해당합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위 수학 문제를 해결하여 A와 B에 대한 정확한 닫힌 수학 공식을 얻게 되면, 가장 정확한 선형 모델로 향하는 직접적인 경로를 얻을 수 있습니다.\n\n![링크](/TIL/assets/img/2024-07-14-SimplifyingLinearRegressionABeginnersGuidewithareal-worldPracticalExample_3.png)\n\n이것은 이러한 수학적인 닫힌 해결책을 찾기 위해 몇 줄의 코드를 정의하는 것으로 번역됩니다. 그래서 매우 직관적입니다.\n\n## 방법 #2: 경사하강법 — 산에서의 하이킹\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n경사 하강은 비용 함수를 최소화하는 데 사용되는 중요한 최적화 알고리즘으로, 예측 모델의 가장 정확한 가중치 값을 찾는 데 도움을 줍니다.\n\n언덕 꼭대기에 서 있는 것으로 상상해보세요. 여러분의 목표는 아래의 계곡에 있습니다. 이것은 비용 함수의 최솟값을 나타냅니다.\n\n이를 달성하기 위해 가중치 A와 B에 대한 초기 추정치로 시작하여 이 추정치를 반복적으로 개선합니다.\n\n이 과정은 언덕을 내려가는 것과 유사합니다. 각각의 단계에서 우리는 주변 환경을 평가하고, 각각의 다음 단계가 계곡 바닥에 더 가까워지도록 우리의 궤적을 조정합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이러한 단계는 학습 속도에 의해 안내됩니다 — 방정식에서 lr로 상징되는 중요한 하이퍼파라미터입니다. 이 학습 속도는 매개변수 A와 B에 대한 조정이나 단계의 크기를 제어하여 최소값을 초과하지 않도록 합니다.\n\n![image](/TIL/assets/img/2024-07-14-SimplifyingLinearRegressionABeginnersGuidewithareal-worldPracticalExample_4.png)\n\n각 단계에서 비용 함수의 A 및 B에 대한 편도함수인 dA와 dB를 계산합니다. 이 도함수는 우리에게 비용 함수가 가장 빨리 감소하는 방향을 가리키는데, 이것은 비유적인 언덕에서 가장 가파른 하강 경로를 찾는 것과 유사합니다.\n\n각 반복에서 A와 B에 대한 업데이트된 방정식은 다음과 같습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지침대로 테이블 태그를 마크다운 형식으로 변경하겠습니다.\n\n\nThis meticulous process is repeated until we reach a point where the cost function’s decrease is negligible, suggesting we’ve arrived at or near the global minimum — our destination where the predictive error is minimized, and our model’s accuracy is maximized.\n\n![Image](/TIL/assets/img/2024-07-14-SimplifyingLinearRegressionABeginnersGuidewithareal-worldPracticalExample_5.png)\n\nThis translates into defining two main functions:\n\n- The function to compute MSE\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- A 및 B를 업데이트하는 기능\n\n우리는 코드를 다음과 같이 초기화합니다:\n\n- A = 0\n- B = 0\n- 학습률 0.0001(학습률은 알고리즘이 더 빠르게 또는 더 느리게 학습할 수 있도록 합니다).\n- 최대 반복 횟수\n\n그래서 최종 코드는 다음과 같습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 접근 방법 #3: Sci-Kit Learn — 파이썬의 강력한 무브\n\n파이썬을 좋아하는 사람들을 위해, Sci-Kit Learn은 머신 러닝을 위한 스위스 아미 나이프입니다. 회귀, 분류, 클러스터링 등을 위한 다양한 도구로 가득합니다.\n\n우리가 해야 할 일은 LinearRegression 라이브러리를 가져와서 객체를 만들고, 데이터로 훈련시키는 것뿐입니다.\n\n몇 줄의 코드로 이를 구현할 수 있습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n왔어요!\n\n우리의 모델이 준비되었습니다.\n\n# 3. 최종 결과\n\n우리의 기술을 적용한 후, 공식이 생성되었습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](/TIL/assets/img/2024-07-14-SimplifyingLinearRegressionABeginnersGuidewithareal-worldPracticalExample_6.png)\n\nWith the data we crunched, A turned out to be around 7.17, and B was approximately -350.73.\n\nWhat does this mean?\n\nFor every inch of height, the weight increases by about 7.17 units, minus our intercept value.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 가정 게임\n\n어떤 모델도 완벽하지 않으며, 선형 회귀는 특정 가정에 의존합니다:\n\n- 선형성: 우리의 데이터는 선이 되어야 합니다. 기억해주세요. 이미 간단한 산점도로 이 선형 패턴을 첫 번째 분석에서 확인했습니다.\n- 독립성: 입력 변수는 서로 독립적이어야 합니다.\n- 잔차의 정규 분포: 관측값과 예측값의 차이는 종 모양의 곡선을 형성해야 합니다.\n\n![이미지](/TIL/assets/img/2024-07-14-SimplifyingLinearRegressionABeginnersGuidewithareal-worldPracticalExample_7.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 잔차의 등분산성: 오차의 퍼짐은 독립 변수의 모든 값에서 일관되어야 합니다.\n\n![image](/TIL/assets/img/2024-07-14-SimplifyingLinearRegressionABeginnersGuidewithareal-worldPracticalExample_8.png)\n\n# 마무리의 생각\n\n선형 회귀는 간단한 것처럼 보일 수 있지만, 데이터 과학 무기함에 속한 강력한 도구입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n데이터 분석의 매력은 그 간단함에 있습니다.\n\n복잡한 모델을 사용하는 것이 중요한 게 아니라, 올바른 모델을 올바른 상황에 사용하는 것이 중요한 거죠.\n\n이 개념을 소화하면, 당신은 데이터 속에 숨겨진 이야기를 발견하는 길에 여러분이 잘 나아가고 있습니다.\n\n호기심을 가져라, 데이터 우주를 계속 탐험해 보세요! 🤓\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음의 GitHub 저장소에서 코드를 확인할 수 있어요.\n\nForCode’Sake를 팔로우하면 이와 유사한 기사를 더 많이 볼 수 있어요! ✨\n\nMLBasics 이슈가 마음에 드셨나요? 그렇다면 DataBites 뉴스레터에 가입하여 최신 내용을 이메일로 받아보세요!\n\n유니크한 콘텐츠를 약속합니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 Markdown 형식의 표를 확인하세요.\n\n![이미지](/TIL/assets/img/2024-07-14-SimplifyingLinearRegressionABeginnersGuidewithareal-worldPracticalExample_9.png)\n\n데이터 과학자 또는 데이터 엔지니어가 되기 위한 훌륭한 데이터 과학 로드맵을 확인해보세요! 🤓\n\n또한 ML, SQL, Python 및 DataViz에 관한 매일 게시하는 치트 시트를 확인할 수 있는 X, Threads 및 LinkedIn에서 저를 만날 수도 있습니다.","ogImage":{"url":"/TIL/assets/img/2024-07-14-SimplifyingLinearRegressionABeginnersGuidewithareal-worldPracticalExample_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-SimplifyingLinearRegressionABeginnersGuidewithareal-worldPracticalExample_0.png","tag":["Tech"],"readingTime":10}],"page":"20","totalPageCount":50,"totalPageGroupCount":3,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"20"},"buildId":"X4OrKfmLtU3-3BijwfHe6","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>