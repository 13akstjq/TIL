<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>TIL</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//posts/21" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="TIL" data-gatsby-head="true"/><meta property="og:title" content="TIL" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//posts/21" data-gatsby-head="true"/><meta name="twitter:title" content="TIL" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/7d7290728862aada.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/7d7290728862aada.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/873-eb138c3217d71553.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/posts/%5Bpage%5D-de1dc5579188f9be.js" defer=""></script><script src="/TIL/_next/static/olPs1cVezSGTqD7OaewDI/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/olPs1cVezSGTqD7OaewDI/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Django로 튼튼한 웹 애플리케이션을 만드는 15가지 팁" href="/TIL/post/2024-07-14-15TipsforBuildingRobustWebApplicationswithDjango"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Django로 튼튼한 웹 애플리케이션을 만드는 15가지 팁" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-15TipsforBuildingRobustWebApplicationswithDjango_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Django로 튼튼한 웹 애플리케이션을 만드는 15가지 팁" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Django로 튼튼한 웹 애플리케이션을 만드는 15가지 팁</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="PySpark의 Repartition 진실 놀랄 준비 하세요" href="/TIL/post/2024-07-14-TheTruthAboutPySparksRepartitionPreparetoBeSurprised"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="PySpark의 Repartition 진실 놀랄 준비 하세요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-TheTruthAboutPySparksRepartitionPreparetoBeSurprised_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="PySpark의 Repartition 진실 놀랄 준비 하세요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">PySpark의 Repartition 진실 놀랄 준비 하세요</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="데이터 사이언스 마스터를 위한 11가지 필수 Python Matplotlib 시각화" href="/TIL/post/2024-07-14-11EssentialPythonMatplotlibVisualizationsforDataScienceMastery"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="데이터 사이언스 마스터를 위한 11가지 필수 Python Matplotlib 시각화" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-11EssentialPythonMatplotlibVisualizationsforDataScienceMastery_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="데이터 사이언스 마스터를 위한 11가지 필수 Python Matplotlib 시각화" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">데이터 사이언스 마스터를 위한 11가지 필수 Python Matplotlib 시각화</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">16<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Django 개발자들이 자주 저지르는 10가지 실수와 해결 방법" href="/TIL/post/2024-07-14-Top10DjangoMistakestoAvoidandHowtoFixThem"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Django 개발자들이 자주 저지르는 10가지 실수와 해결 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-Top10DjangoMistakestoAvoidandHowtoFixThem_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Django 개발자들이 자주 저지르는 10가지 실수와 해결 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Django 개발자들이 자주 저지르는 10가지 실수와 해결 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">24<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="이미지 분할의 혁명 U-Net 아키텍처 탐구" href="/TIL/post/2024-07-14-TheRevolutionofImageSegmentationExploringU-NetArchitecture"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="이미지 분할의 혁명 U-Net 아키텍처 탐구" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-TheRevolutionofImageSegmentationExploringU-NetArchitecture_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="이미지 분할의 혁명 U-Net 아키텍처 탐구" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">이미지 분할의 혁명 U-Net 아키텍처 탐구</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="__init__py 파일 제대로 이해하고 사용하기" href="/TIL/post/2024-07-14-CanYouEven__init__py"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="__init__py 파일 제대로 이해하고 사용하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-CanYouEven__init__py_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="__init__py 파일 제대로 이해하고 사용하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">__init__py 파일 제대로 이해하고 사용하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="삼체 문제의 트리플 별 직렬 현상 물리학 실제로 사람이 행성에서 끌려갈 수 있을까" href="/TIL/post/2024-07-14-PhysicsoftheTri-SolarSyzygyfromThe3BodyProblemCouldPeopleReallyBePulledOffaPlanet"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="삼체 문제의 트리플 별 직렬 현상 물리학 실제로 사람이 행성에서 끌려갈 수 있을까" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-PhysicsoftheTri-SolarSyzygyfromThe3BodyProblemCouldPeopleReallyBePulledOffaPlanet_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="삼체 문제의 트리플 별 직렬 현상 물리학 실제로 사람이 행성에서 끌려갈 수 있을까" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">삼체 문제의 트리플 별 직렬 현상 물리학 실제로 사람이 행성에서 끌려갈 수 있을까</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자동 ARIMA 모델 사용 방법" href="/TIL/post/2024-07-14-AutomaticARIMA"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자동 ARIMA 모델 사용 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-AutomaticARIMA_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자동 ARIMA 모델 사용 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">자동 ARIMA 모델 사용 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">25<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="시니어 개발자들이 프로그래밍 도전을 해결하는 방법 비밀 코드 정복기" href="/TIL/post/2024-07-14-CrackingtheCodeHowSeniorDevsTackleProgrammingChallenges"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="시니어 개발자들이 프로그래밍 도전을 해결하는 방법 비밀 코드 정복기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-CrackingtheCodeHowSeniorDevsTackleProgrammingChallenges_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="시니어 개발자들이 프로그래밍 도전을 해결하는 방법 비밀 코드 정복기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">시니어 개발자들이 프로그래밍 도전을 해결하는 방법 비밀 코드 정복기</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="소비자용 그래픽 카드 하나로 LLMs 미세 조정하는 방법" href="/TIL/post/2024-07-14-FineTuningLLMsonaSingleConsumerGraphicCard"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="소비자용 그래픽 카드 하나로 LLMs 미세 조정하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-FineTuningLLMsonaSingleConsumerGraphicCard_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="소비자용 그래픽 카드 하나로 LLMs 미세 조정하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">소비자용 그래픽 카드 하나로 LLMs 미세 조정하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">15<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/TIL/posts/21">21</a><a class="link" href="/TIL/posts/22">22</a><a class="link" href="/TIL/posts/23">23</a><a class="link" href="/TIL/posts/24">24</a><a class="link" href="/TIL/posts/25">25</a><a class="link" href="/TIL/posts/26">26</a><a class="link" href="/TIL/posts/27">27</a><a class="link" href="/TIL/posts/28">28</a><a class="link" href="/TIL/posts/29">29</a><a class="link" href="/TIL/posts/30">30</a><a class="link" href="/TIL/posts/31">31</a><a class="link" href="/TIL/posts/32">32</a><a class="link" href="/TIL/posts/33">33</a><a class="link" href="/TIL/posts/34">34</a><a class="link" href="/TIL/posts/35">35</a><a class="link" href="/TIL/posts/36">36</a><a class="link" href="/TIL/posts/37">37</a><a class="link" href="/TIL/posts/38">38</a><a class="link" href="/TIL/posts/39">39</a><a class="link" href="/TIL/posts/40">40</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Django로 튼튼한 웹 애플리케이션을 만드는 15가지 팁","description":"","date":"2024-07-14 20:01","slug":"2024-07-14-15TipsforBuildingRobustWebApplicationswithDjango","content":"\n\n\n![image](/TIL/assets/img/2024-07-14-15TipsforBuildingRobustWebApplicationswithDjango_0.png)\n\n장고는 강력하고 다재다능한 웹 프레임워크로 개발자들이 빠르고 효율적으로 견고한 웹 애플리케이션을 구축할 수 있습니다. 그러나 진정으로 견고한 애플리케이션을 구축하려면 모범 사례와 고급 기술에 주의를 기울여야 합니다. 이곳에는 Django로 견고한 웹 애플리케이션을 구축하는 데 도움이 되는 15가지 팁이 있습니다.\n\n## 1. 가상 환경 사용\n\n가상 환경은 의존성을 관리하고 프로젝트별 라이브러리를 격리하는 데 필수적입니다. 이를 통해 패키지 간 충돌을 방지하고 일관된 개발 환경을 유지할 수 있습니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 가상 환경 생성하기\npython -m venv env\n\n# 가상 환경 활성화하기\n# Windows에서는\nenv\\Scripts\\activate\n# Unix나 MacOS에서는\nsource env/bin/activate\n```\n\n# 2. 장고 프로젝트 구조 따르기\n\n장고에서 권장하는 프로젝트 구조를 준수하여 애플리케이션을 구조화하고 유지보수 가능하게 유지하세요. 이는 앱, 템플릿, 정적 파일 및 설정을 분리하는 것을 포함합니다.\n\n```js\nmyproject/\n    manage.py\n    myproject/\n        __init__.py\n        settings.py\n        urls.py\n        wsgi.py\n    myapp/\n        __init__.py\n        admin.py\n        apps.py\n        models.py\n        tests.py\n        views.py\n        migrations/\n        templates/\n        static/\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 3. Django Admin을 활용하여 신속한 프로토타이핑\n\nDjango의 내장 관리자 인터페이스는 관리 인터페이스를 빠르게 생성하는 강력한 도구입니다. 필요에 맞게 사용자 정의하고 신속한 프로토타이핑 및 애플리케이션 데이터 관리에 활용하세요.\n\n```js\n# admin.py에서 모델 등록\nfrom django.contrib import admin\nfrom .models import MyModel\n\nadmin.site.register(MyModel)\n```\n\n# 4. 클래스 기반 뷰 사용\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n클래스 기반 뷰(CBVs)는 함수 기반 뷰(FBVs)에 비해 더 유연하고 재사용 가능한 접근 방식을 제공합니다. 이를 통해 코드 재사용과 더 나은 구성을 촉진합니다.\n\n```js\nfrom django.views import View\nfrom django.http import HttpResponse\n\nclass MyView(View):\n    def get(self, request):\n        return HttpResponse('Hello, World!')\n```\n\n# 5. 커스텀 사용자 모델 구현\n\n장고의 기본 사용자 모델은 모든 요구 사항을 충족하지 못할 수 있습니다. 프로젝트 초기에 사용자 모델을 사용자 정의하여 나중에 복잡성을 피하도록 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nfrom django.contrib.auth.models import AbstractUser\n\nclass CustomUser(AbstractUser):\n    # 여기에 사용자 정의 필드를 추가하세요\n    pass\n\n# settings.py 업데이트\nAUTH_USER_MODEL = 'myapp.CustomUser'\n```\n\n# 6. 로직 분리를 위해 시그널 사용하기\n\nDjango 시그널을 사용하면 응용 프로그램의 구성 요소를 분리하여 통지를 보내고 받을 수 있습니다. 모델 변경이나 사용자 작업과 같은 이벤트를 처리하기 위해 시그널을 사용하세요.\n\n```python\nfrom django.db.models.signals import post_save\nfrom django.dispatch import receiver\nfrom .models import MyModel\n\n@receiver(post_save, sender=MyModel)\ndef my_model_post_save(sender, instance, created, **kwargs):\n    if created:\n        # 어떤 동작 수행\n        pass\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 7. 데이터베이스 쿼리 최적화\n\n효율적인 데이터베이스 쿼리는 성능에 중요합니다. Django의 ORM 기능인 select_related와 prefetch_related를 사용하여 쿼리의 수를 최소화하세요.\n\n```js\n# select_related 사용\nqueryset = MyModel.objects.select_related('related_model').all()\n\n# prefetch_related 사용\nqueryset = MyModel.objects.prefetch_related('related_set').all()\n```\n\n# 8. 캐싱 구현\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n캐싱은 자주 액세스하는 데이터를 저장하여 성능을 향상시킵니다. Django는 Memcached와 Redis와 같은 다양한 캐싱 백엔드를 지원합니다.\n\n```js\n# settings.py 업데이트\nCACHES = {\n    'default': {\n        'BACKEND': 'django.core.cache.backends.memcached.MemcachedCache',\n        'LOCATION': '127.0.0.1:11211',\n    }\n}\n\n# 뷰에서 캐싱 사용\nfrom django.views.decorators.cache import cache_page\n\n@cache_page(60 * 15)\ndef my_view(request):\n    # 뷰 로직 여기에 작성\n    pass\n```\n\n# 9. 미들웨어 현명하게 사용하기\n\n미들웨어를 사용하면 요청과 응답을 전역적으로 처리할 수 있습니다. 미들웨어를 신중하게 사용하여 기능을 향상시키고 불필요한 복잡성을 추가하지 않도록 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 사용자 정의 미들웨어\nclass MyMiddleware:\n    def __init__(self, get_response):\n        self.get_response = get_response\n\n    def __call__(self, request):\n        # 뷰가 호출되기 전 각 요청에 대해 실행되는 코드\n        response = self.get_response(request)\n        # 뷰가 호출된 후 각 응답에 대해 실행되는 코드\n        return response\n\n# settings.py 업데이트\nMIDDLEWARE = [\n    'myproject.middleware.MyMiddleware',\n    # 다른 미들웨어\n]\r\n```\n\n# 10. 양식 유효성 검사 구현\n\n견고한 양식 유효성 검사는 데이터 무결성을 보장하고 사용자 경험을 향상시킵니다. Django의 양식 클래스를 사용하여 유효성 검사와 오류 처리를 처리하세요.\n\n```js\nfrom django import forms\n\nclass MyForm(forms.Form):\n    name = forms.CharField(max_length=100)\n    email = forms.EmailField()\n\n    def clean_email(self):\n        email = self.cleaned_data.get('email')\n        if not email.endswith('@example.com'):\n            raise forms.ValidationError('잘못된 이메일 도메인')\n        return email\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 11. 애플리케이션 보안 강화하기\n\n웹 애플리케이션에서 보안은 매우 중요합니다. Django의 기본 보안 기능인 CSRF 보호, XSS 보호 및 안전한 비밀번호 해싱 기능을 사용하세요.\n\n```js\n# CSRF 미들웨어가 활성화되어 있는지 확인\nMIDDLEWARE = [\n    'django.middleware.csrf.CsrfViewMiddleware',\n    # 다른 미들웨어\n]\n\n# Django의 기본 비밀번호 해시 함수 사용하기\nfrom django.contrib.auth.hashers import make_password\n\npassword = make_password('my_secure_password')\n```\n\n# 12. 비동기 작업에 Celery 사용하기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n셀러리는 장고와 잘 통합되는 비동기 작업 큐/작업 큐입니다. 이를 사용하여 시간이 오래 걸리는 작업을 백그라운드에서 처리할 수 있어요.\n\n```js\n# Celery 설치하기\npip install celery\n\n# Celery 인스턴스 생성하기\nfrom celery import Celery\n\napp = Celery('myproject', broker='redis://localhost:6379/0')\n\n# settings.py에서 Celery 구성하기\nCELERY_BROKER_URL = 'redis://localhost:6379/0'\n\n# 작업 정의하기\n@app.task\ndef my_task():\n    # 작업 로직 작성\n    pass\n\n# 작업 호출하기\nmy_task.delay()\n```\n\n# 13. 테스트 작성하기\n\n테스트를 작성하면 애플리케이션의 신뢰성과 안정성을 보장할 수 있어요. 장고의 내장 테스트 프레임워크를 사용하여 단위 테스트, 통합 테스트, 기능 테스트를 작성해보세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\nfrom django.test import TestCase\r\nfrom .models import MyModel\r\n\r\nclass MyModelTest(TestCase):\r\n    def test_str(self):\r\n        my_model = MyModel(name='Test')\r\n        self.assertEqual(str(my_model), 'Test')\r\n\n\r\n## 14. Logging 사용\r\n\r\nLogging을 사용하면 애플리케이션의 모니터링과 디버깅에 도움이 됩니다. 중요 이벤트와 오류를 캡처하기 위해 Django의 로깅 프레임워크를 구성하세요.\r\n\r\n```python\r\n# settings.py 업데이트\r\nLOGGING = {\r\n    'version': 1,\r\n    'disable_existing_loggers': False,\r\n    'handlers': {\r\n        'file': {\r\n            'level': 'DEBUG',\r\n            'class': 'logging.FileHandler',\r\n            'filename': 'debug.log',\r\n        },\r\n    },\r\n    'loggers': {\r\n        'django': {\r\n            'handlers': ['file'],\r\n            'level': 'DEBUG',\r\n            'propagate': True,\r\n        },\r\n    },\r\n}\r\n\r\n# view에서 logging 사용\r\nimport logging\r\n\r\nlogger = logging.getLogger(__name__)\r\n\r\ndef my_view(request):\r\n    logger.debug('디버그 메시지입니다')\r\n    # 뷰 로직은 여기에\r\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 15. 최선의 실천 방법으로 배포하기\n\nDjango 애플리케이션을 배포하는 것은 제품 환경에서 원할하게 실행되도록 하는 여러 단계를 거칩니다. 견고한 배포 설정을 위해 Gunicorn, Nginx, Docker와 같은 도구들을 사용하세요.\n\n```js\n# 예시 Gunicorn 명령어\ngunicorn myproject.wsgi:application --bind 0.0.0.0:8000\n\n# 예시 Dockerfile\nFROM python:3.9\nENV PYTHONUNBUFFERED 1\nWORKDIR /app\nCOPY requirements.txt /app/\nRUN pip install -r requirements.txt\nCOPY . /app/\nCMD [\"gunicorn\", \"myproject.wsgi:application\", \"--bind\", \"0.0.0.0:8000\"]\n```\n\n이 15가지 팁을 따르면 Django로 견고하고 안전하며 효율적인 웹 애플리케이션을 만들 수 있습니다. 소규모 프로젝트나 대규모 애플리케이션을 개발하더라도 최선의 실천 방법을 준수하고 Django의 강력한 기능을 활용하면 애플리케이션이 유지보수 가능하고 성능이 우수하며 확장 가능하도록 보장할 수 있습니다. 즐거운 코딩 되세요!","ogImage":{"url":"/TIL/assets/img/2024-07-14-15TipsforBuildingRobustWebApplicationswithDjango_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-15TipsforBuildingRobustWebApplicationswithDjango_0.png","tag":["Tech"],"readingTime":10},{"title":"PySpark의 Repartition 진실 놀랄 준비 하세요","description":"","date":"2024-07-14 20:00","slug":"2024-07-14-TheTruthAboutPySparksRepartitionPreparetoBeSurprised","content":"\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-TheTruthAboutPySparksRepartitionPreparetoBeSurprised_0.png\" /\u003e\n\n데이터 엔지니어로서, 데이터 파이프라인을 다루고 성능을 최적화하는 데 수많은 시간을 보냈습니다. PySpark에 대해 꽤 잘 알고 있을 줄 알았지만, 몇 가지 부분에 대해 틀렸던 것을 깨달았습니다 — 특히 repartition() 함수에 관한 부분이 그렇습니다.\n\n많은 분들처럼, 저도 repartition() 함수가 어떻게 작동하는지에 대해 많은 가정을 했습니다. 그러나 몇몇 가정이 사실은 크게 틀렸던 것으로 판명이 났습니다. 이 블로그 게시물에서는 PySpark에서 분할에 대한 일반적인 오해 몇 가지를 해소해보겠습니다. repartition() 함수에 집중하고, 실제로 데이터가 파티션으로 어떻게 분산되는지 살펴보겠습니다.\n\n그러나 스크롤 다운하기 전에 — df.repartition(columnName)이 columnName의 값을 기반으로 데이터를 분배한다고 알고 계셨나요? 아래 이미지와 같은 방식으로 말이죠? 이것은 흔히 퍼지는 미신입니다! 사실은 대부분의 사람들이 생각하는 방식으로 작동하지 않습니다. 흥미를 느껴지나요? 이어서 진실을 밝혀보고 파티션 전략을 최적화하는 방법을 배워보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](/TIL/assets/img/2024-07-14-TheTruthAboutPySparksRepartitionPreparetoBeSurprised_1.png)\n\n파이스파크에서는 두 가지 주로 사용되는 파티션 전략을 알고 있습니다. 첫 번째는 df.repartition()이고 두 번째는 df.repartitionByRange()입니다. 이 두 함수는 데이터프레임 내에서 데이터를 파티션 간에 재분배하기 위해 일정한 로직을 사용합니다. 오늘은 repartition() 함수에 중점을 둘 것입니다.\n\n# 신화\n\n일반적으로 SQL 언어에서는 데이터를 파티션 키(예: 국가)로 파티션하면 해당 데이터가 국가 별로 여러 청크로 분할될 것이라는 개념을 자주 접하게 됩니다. 예를 들어, 이것은 일반적으로 사용되는 T-SQL 코드입니다:\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n```js\nSELECT\n    Country,\n    COUNT(Name) OVER (PARTITION BY Country) AS CountPerCountry\nFROM sample_data;\n```\n\nDatabricks의 Delta Tables을 사용하더라도 간단한 Spark SQL 절로 테이블을 파티션할 수 있어요:\n\n```js\nCREATE TABLE partitioned_country_table\nUSING DELTA\nPARTITIONED BY (Country)\nAS SELECT * FROM sample_data;\n```\n\nPySpark DataFrames를 사용할 때 파티션을 어떻게 볼지를 다시 고려하는 것이 중요해요. 확장 가능한 병렬 컴퓨팅을 위해 설계된 Spark에서는 파티션을 주로 데이터를 효율적으로 worker 노드에 분산시키는 데 사용하며 집계를 수행하는 데 사용되지는 않아요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n.repartition(columnName)을 사용하면 데이터가 columnName의 고유 값에 따라 자동으로 그룹화된다는 흔한 오해가 있습니다. 이 오해는 사람들이 \"repartition\"이란 용어가 데이터를 해당 열 값에 따라 별도의 그룹으로 재구성한다고 직감적으로 생각하기 때문에 발생합니다. 하지만 Spark에서는 .repartition(columnName)이 데이터를 재분배하여 병렬성을 달성하고 성능을 향상시키지만 모든 columnName 값을 가진 행이 반드시 동일한 파티션에 포함되는 것을 보장하지는 않습니다.\n\n가짜 데이터로 이를 증명해 봅시다.\n\n```python\nfrom faker import Faker\nimport random\nfrom pyspark.sql import SparkSession\nfrom pyspark.sql.types import *\nfrom pyspark.sql.functions import spark_partition_id, countDistinct\n\nspark_session = (\n    SparkSession.builder.master(\"local\")\n    .appName(\"Spark Repartitioning\")\n    .config(\"spark.sql.adaptive.enabled\", \"false\")\n    .getOrCreate()\n)\n\n# Faker 초기화\nfake = Faker()\n\n# 샘플 데이터 생성\ndef generate_data(num_records):\n    data = []\n    for _ in range(num_records):\n        name = fake.name()\n        country = fake.country()\n        data.append((name, country))\n    return data\n\ndata = generate_data(1000)  # 1000개 레코드 생성\ndata = spark_session.sparkContext.parallelize(data)\n\n# 데이터의 스키마 정의\nschema = StructType(\n    [\n        StructField(\"Name\", StringType(), True),\n        StructField(\"Country\", StringType(), True),\n    ]\n)\n\n# 데이터와 스키마를 사용하여 DataFrame 생성\ndf: DataFrame = spark_session.createDataFrame(data, schema)\ndf = df.repartition(\"Country\").withColumn(\"partitionId\", spark_partition_id())\n\n(\n    df.groupBy(\"partitionId\")\n    .agg(countDistinct(\"Country\").alias(\"DistinctCount\"))\n    .filter(\"DistinctCount \u003e 1\")\n    .show()\n)\n\n```\n\n```python\n+-----------+-------------+\n|partitionId|DistinctCount|\n+-----------+-------------+\n|         31|            2|\n|         85|            2|\n|         65|            3|\n|        155|            3|\n|         26|            4|\n|        103|            2|\n|         91|            2|\n|         22|            2|\n|        157|            2|\n|        177|            2|\n|         52|            2|\n|         13|            3|\n|         86|            2|\n|        178|            2|\n|         20|            2|\n|         40|            3|\n|         57|            2|\n|        120|            2|\n|         96|            2|\n|         48|            2|\n+-----------+-------------+\n상위 20개 행만 표시됨\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n보시다시피, 일부 DataFrame 파티션에는 파티션당 하나 이상의 나라가 포함되어 있어서, 처음에 기대했던 것과는 다릅니다. 그런데 왜 이런 일이 발생하는 걸까요?\n\n이 진실은 PySpark의 배경에 숨어 있습니다. repartition() 함수는 내부적으로 HashPartitioner를 호출하여 (이 멋진 Stack Overflow 댓글에서 설명된대로) 데이터를 파티션으로 분산합니다. 이 파티셔너는 데이터를 파티션에 따라 분배하기 위해 다음과 같이 정의된 공식을 사용합니다: hash(partitionKey) % numPartitions\n\n아래 다이어그램에 따라 데이터를 파티션에 분배합니다.\n\n![다이어그램](/TIL/assets/img/2024-07-14-TheTruthAboutPySparksRepartitionPreparetoBeSurprised_2.png)\n\n한 열을 계산하기 위해 스파크의 해시 파티셔너 동작을 모방하는데, 실제로는 해시 코드 및 파티션 수에 대한 음수가 아닌 모듈화가 발생한다는 점에 유의하십시오 (소스 코드에 따르면).\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](/TIL/assets/img/2024-07-14-TheTruthAboutPySparksRepartitionPreparetoBeSurprised_3.png)\n\n위의 다이어그램을 복제하는 PySpark 코드입니다.\n\n```python\nfrom pyspark.sql.functions import hash, col, lit, spark_partition_id, udf\n\ndata = [(\"Marshall Islands\",), (\"Tuvalu\",), (\"Somalia\",), (\"USA\",)]\n\nschema = StructType([StructField(\"Country\", StringType(), True)])\n\n# 파티션 수\nnum_partitions = 2\n\n# 해시 및 파티션 계산\ndf2 = df.withColumn(\"hash\", hash(col(\"Country\")))\ndf2 = df2.withColumn(\"num_partitions\", lit(num_partitions))\ndf2 = df2.withColumn(\n    \"hash(Country) % numPartitions\",\n    (col(\"hash\") % col(\"num_partitions\") + col(\"num_partitions\"))\n    % col(\"num_partitions\"),\n)\ndf2 = df2.repartition(num_partitions, col(\"Country\"))\ndf2 = df2.withColumn(\"spark_partition_id\", spark_partition_id())\ndf2.show()\n```\n\n![image](/TIL/assets/img/2024-07-14-TheTruthAboutPySparksRepartitionPreparetoBeSurprised_4.png)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n보시다시피, 레코드가 어느 파티션에 끝날지 예측할 수 있으므로 .repartition() 함수가 더 이해하기 쉬워집니다.\n\n# 이게 왜 중요한가요?\n\n저는 직접 참여한 프로젝트에서의 실제 사용 사례로 생각해보겠습니다. 저희는 Databricks와 PySpark를 사용하여 수백 테라바이트의 매우 큰 데이터 세트를 이관했습니다. 데이터가 처리된 후에는 Spark MSSQL Connector를 사용하여 Azure SQL Server에 저장되었습니다. 테이블을 파티션별로 데이터를 저장할 때 높은 동시성을 보장하기 위해 경쟁과 대기 시간을 줄이기 위해 노력했습니다. 초기 접근 방식은 쓰기 프로세스 이전에 .repartition()을 사용하는 것이었는데, 이로 인해 일부 속도 이점을 얻었습니다. 그러나 여전히 락과 경합이 발생했습니다. 최종적으로 우리는 repartitionByRange()로 전환했고, 이 방법이 더 결정론적이며 우리의 SQL Server 테이블 파티셔닝 전략과 더 잘 부합한다는 것을 알게 되었습니다.\n\n이것은 한 가지 사용 사례에 불과하지만, 이 개념을 이해하는 것은 잠재적인 병목 현상을 식별하는 데 도움이 됩니다. repartitionByRange() 대 repartition()과 그들의 성능 영향에 대한 장단점에 대한 구체적인 기사를 쓰기로 계획하고 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론\n\nPySpark에서의 Repartitioning은 파이프라인 성능에 중요한 측면입니다. PySpark 파티션 내 데이터의 분포는 병렬성 뿐만 아니라 리소스 활용에도 영향을 미칩니다. 리소스를 더 효율적으로 사용하기 위해서는 적절한 파티셔닝이 필요합니다.\n\nrepartition() 메서드가 모든 문제를 해결해 주지는 않지만, 그 동작을 이해하는 것이 중요합니다. 이 메서드는 데이터를 분할하는 데 있어 파티션 키를 기준으로 결정적으로 분할하는 것이 아니라, 작업 노드에 데이터를 골고루 분배하여 성능과 병렬화를 향상시키는 데 사용됩니다.\n\n# 연락 유지하기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 이 글을 즐겼다면, 다른 파티션 함수에 대해 더 알고 싶다면 망설이지 말고 나를 팔로우해주세요. 그래야 최신 글들이 더 빨리 당신에게 전달될 거에요.\n\n- 더 이상 이야기들을 원하신다면 Medium에서 제게 팔로우해주세요.\n- LinkedIn에서 연락해주세요.\n\n참고해 주셔서 감사합니다 :)\n\n# 간단히 말해 🚀\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 클랩하고 팔로우해주세요 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io에서 더 많은 콘텐츠 만나보세요","ogImage":{"url":"/TIL/assets/img/2024-07-14-TheTruthAboutPySparksRepartitionPreparetoBeSurprised_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-TheTruthAboutPySparksRepartitionPreparetoBeSurprised_0.png","tag":["Tech"],"readingTime":10},{"title":"데이터 사이언스 마스터를 위한 11가지 필수 Python Matplotlib 시각화","description":"","date":"2024-07-14 19:59","slug":"2024-07-14-11EssentialPythonMatplotlibVisualizationsforDataScienceMastery","content":"\n\n## 파이썬 맷플롯립 시각화\n\n맷플롯립을 사용하면 파이썬으로 멋진 그림을 그릴 수 있어요. 데이터를 다양한 방식으로 표시할 수 있습니다. 많은 양의 코드가 필요하지 않아요. 선 그래프, 막대 차트 및 여러 종류의 차트를 만들 수 있어요.\n\n# 간단한 선 그래프\n\n- figures 와 axes: 맷플롯립에서 figure 는 상자 같아요. 플롯의 모든 부분을 보유해요. axes 는 figure 내부의 더 작은 상자처럼 생겼어요. 주변에 선들과 플롯의 의미를 알려주는 단어들이 있어요.\n- 변수 명명: Figure 객체는 일반적으로 `fig`로 이름을 짓고, axes 객체는 `ax`로 이름을 지어요.\n- 데이터 플로팅: `ax.plot` 메서드를 사용하여 axes에 데이터를 플로팅하세요.\n- Pylab 인터페이스: MATLAB과 유사한 인터페이스를 제공하여 자동으로 figure와 axes를 만들어줘요.\n- 여러 선: 동일한 figure에 여러 선을 그리려면 `plot` 함수를 여러 번 호출하세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport numpy as np\nimport matplotlib.pyplot as plt\nplt.style.use('seaborn-v0_8-whitegrid')\nfig = plt.figure()\nax = plt.axes()\nx = np.linspace(0, 10, 1000)\nplt.plot(x, np.sin(x))\nplt.plot(x, np.cos(x))\nplt.show()\n```\n\n![image](/TIL/assets/img/2024-07-14-11EssentialPythonMatplotlibVisualizationsforDataScienceMastery_0.png)\n\n# 간단한 산점도\n\n- 무엇인가: 산점도는 순서가 없는 점들을 가지고 있습니다. 선 그래프는 점들이 연결되어 있습니다.\n- 만드는 방법: 산점도를 그리려면 `plt.plot` 또는 `ax.plot`을 사용할 수 있습니다.\n- 점 스타일: 특별한 코드로 점의 모양을 변경할 수 있습니다. 문서에 어떤 코드를 사용해야 하는지 설명되어 있습니다.\n- `plt.scatter`의 재미있는 점: 각 점을 특별하게 만들 수 있습니다. 크기와 색상이 다를 수 있습니다. 이를 위해 데이터 세트를 사용합니다.\n- 투명한 점: 점을 서로 겹치게 만들 때 `alpha` 설정으로 점을 투명하게 만들 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport numpy as np\nimport matplotlib.pyplot as plt\nplt.style.use('seaborn-v0_8-whitegrid')\nrng = np.random.RandomState(0)\nx = rng.randn(100)\ny = rng.randn(100)\ncolors = rng.rand(100)\nsizes = 1000 * rng.rand(100)\nplt.scatter(x, y, c=colors, s=sizes, alpha=0.3,\n            cmap='viridis')\nplt.colorbar();\nplt.show()\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-11EssentialPythonMatplotlibVisualizationsforDataScienceMastery_1.png\" /\u003e\n\n# 오류 시각화\n\n- 왜 중요한가: 과학에서는 오류를 올바르게 이해하는 것이 측정 자체보다 중요하다.\n- 예를 들어: 허블 상수를 추측할 때 오류에 대해 고려해야 합니다. 이를 통해 서로 다른 측정 결과가 일치하는지 알 수 있습니다.\n- 불확실함 표현: 측정 값을 보고할 때 얼마나 확신이 없는지도 함께 말해야 합니다 (예: 71±2.5 (km/s)/Mpc). 이렇게 하면 데이터를 더 잘 비교할 수 있습니다.\n- 오류 표시: 차트에 오류를 넣으면 더 다양하고 정확한 정보를 얻을 수 있습니다.\n- `fmt` 설정: 차트에서 선과 점이 어떻게 보이는지를 제어합니다. `plt.plot` 코드와 비슷한 역할을 합니다.\n- `errorbar` 함수: 오차 막대 기호의 모양을 변경할 수 있게 해줍니다. 예를 들어, 가로로 만들어 진해지게 만들 수 있습니다.\n- 자신만의 스타일: 측면 오차 막대, 단측 오차 막대 등에 대한 더 많은 `errorbar` 설정을 활용하여 차트를 원하는 대로 꾸밉니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nplt.style.use('seaborn-v0_8-whitegrid')\nx = np.linspace(0, 10, 50)\ndy = 0.8\ny = np.sin(x) + dy * np.random.randn(50)\nplt.errorbar(x, y, yerr=dy, fmt='o', color='black',\n             ecolor='lightgray', elinewidth=3, capsize=0)\nplt.show()\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-11EssentialPythonMatplotlibVisualizationsforDataScienceMastery_2.png\" /\u003e\n\n# 밀도 및 등고도 플롯\n\n- 3D 데이터 시각화: 3D 데이터를 2D 차트로 표현하는 등고선 플롯이나 히트맵과 같은 차트 사용.\n- 함수 사용: 등고선 플로팅에는 `plt.contour`, 채워진 등고선 플로팅에는 `plt.contourf`, 이미지 형태로 플로팅에는 `plt.imshow` 사용.\n- 데이터 전처리: 1차원 배열로부터 2차원 그리드 생성하는 데 `np.meshgrid` 활용.\n- 등고선 플로팅하기: `plt.contour`는 그리드와 높이 값을 나타내는 `x`, `y`, `z`가 필요.\n- 선 스타일: 흑백 등고선 플롯에서 점선은 음수를, 실선은 양수를 의미.\n- 컬러 맵: `cmap`을 활용하여 등고선 색상 지정. 예를 들어, `RdGy`는 군집 데이터에 적합.\n- 컬러 바: 색상표를 만들기 위해 `plt.colorbar` 사용. 컬러 값의 범위를 보여줌.\n- 채워진 등고선 플로팅: `plt.contourf`를 사용하여 등고선 플로팅을 채움. 간격이 적고 보기 좋음.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n```js\nimport numpy as np\nimport matplotlib.pyplot as plt\nplt.style.use('seaborn-v0_8-whitegrid')\ndef f(x, y):\n    return np.sin(x) ** 10 + np.cos(10 + y * x) * np.cos(x)\nx = np.linspace(0, 5, 50)\ny = np.linspace(0, 5, 40)\nX, Y = np.meshgrid(x, y)\nZ = f(X, Y)\nplt.contourf(X, Y, Z, 20, cmap='RdGy')\nplt.colorbar();\nplt.show()\n```\n\n![Image](/TIL/assets/img/2024-07-14-11EssentialPythonMatplotlibVisualizationsforDataScienceMastery_3.png)\n\n# 히스토그램, Binning 및 Density\n\n- 기본 히스토그램: Matplotlib의 `hist()` 함수를 사용하여 빠르게 기본 히스토그램을 생성합니다.\n- 매개변수 조정: `hist()`는 히스토그램 계산 및 표시를 조정하기 위한 매개변수를 제공합니다.\n- 설정 변경: 더 이상 `normed`를 사용하지 마세요. 대신 정규화하기 위해 `density`를 사용하세요.\n- 자신만의 스타일: `histtype='stepfilled'` 및 `alpha`를 사용하여 투명한 막대를 만들어서 서로 다른 데이터를 일치시키는 데 유용합니다.\n- 자세히 알아보기: `plt.hist` 문서를 확인하여 변경할 수 있는 방법에 대해 더 배우세요.\n- 숫자만 필요한 경우: 플롯 없이 히스토그램 숫자만 얻으려면 `np.histogram()`을 사용하세요.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport numpy as np\nimport matplotlib.pyplot as plt\nplt.style.use('seaborn-v0_8-whitegrid')\nx1 = np.random.normal(0, 0.8, 1000)\nx2 = np.random.normal(-2, 1, 1000)\nx3 = np.random.normal(3, 2, 1000)\nkwargs = dict(histtype='stepfilled', alpha=0.3, density=True, bins=40)\nplt.hist(x1, **kwargs)\nplt.hist(x2, **kwargs)\nplt.hist(x3, **kwargs);\nplt.show()\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-11EssentialPythonMatplotlibVisualizationsforDataScienceMastery_4.png\" /\u003e\n\n# 사용자 정의 범례\n\n- 중요성: 범례는 시각화에 의미를 부여하여 다양한 차트 요소를 명확하게 해줍니다.\n- 키 만들기: 이름으로 차트 부분에 키를 만들려면 `plt.legend()`를 사용합니다.\n- 다양한 설정: 키가 위치하게 할 곳을 선택하세요. 상자를 제거하세요. 여러 행을 사용하세요. 둥근 모서리 또는 그림자를 사용하세요. 투명도와 단어 간 간격을 조절하세요.\n- 표시할 항목 선택: 키에 들어갈 부분과 이름을 지정하세요. 이를 수행하려면 'plot'이 제공하는 것을 설정하세요.\n- 다수의 선: `plt.plot`은 여러 개의 선을 제공할 수 있습니다. 원하는대로 키를 만들려면 `plt.legend()`에 제공할 선을 선택하세요.\n- 부분에 이름 지정: 차트 부분에 직접 이름을 지정하세요. 그런 다음 키에 그 이름을 넣어서 쉽게 식별할 수 있도록 하세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nplt.style.use('seaborn-v0_8-whitegrid')\nx = np.linspace(0, 10, 1000)\ny = np.sin(x[:, np.newaxis] + np.pi * np.arange(0, 2, 0.5))\n\nplt.plot(x, y[:, 0], label='first')\nplt.plot(x, y[:, 1], label='second')\nplt.plot(x, y[:, 2:])\nplt.legend(framealpha=1, frameon=True)\nplt.show()\n```\n\n![Custom Colorbars](/TIL/assets/img/2024-07-14-11EssentialPythonMatplotlibVisualizationsforDataScienceMastery_5.png)\n\n# 사용자 정의 컬러바\n\n범례 vs. 컬러바: 범례는 이산적인 레이블을 나타내는 반면, 컬러바는 연속값-색상 관계를 나타냅니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n색상 막대 만들기: `plt.colorbar()`을 사용하여 색상 막대를 만듭니다.\n\n칼라맵: `cmap` 매개변수를 사용하여 칼라맵을 지정합니다.\n\n칼라맵 자원: 모든 사용 가능한 칼라맵은 `plt.cm` 모듈에서 찾을 수 있습니다. 칼라맵을 나열하려면 IPython의 탭 자동완성을 사용하세요.\n\n칼라맵 유형:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- a. 연속 색상지도: `binary` 또는 `viridis`와 같은 단일 연속 색상 시리즈입니다.\n- b. 발산 색상지도: `RdBu` 또는 `PuOr`와 같은 두 가지 대조되는 색상 시리즈입니다.\n- c. 질적 색상지도: `rainbow` 또는 `jet`과 같이 연속적이지 않은 색상 조합입니다.\n\n```js\nimport numpy as np\nimport matplotlib.pyplot as plt\nplt.style.use('classic')\nx = np.linspace(0, 10, 1000)\nI = np.sin(x) * np.cos(x[:, np.newaxis])\nplt.imshow(I, aspect='auto', cmap='viridis')\nplt.colorbar()\nplt.show()\n```\n\n![Visualization](/TIL/assets/img/2024-07-14-11EssentialPythonMatplotlibVisualizationsforDataScienceMastery_6.png)\n\n# 다중 서브플롯\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 컨셉: Matplotlib은 데이터를 옆으로 나란히 표시하기 위해 단일 그림에서 여러 서브플롯을 허용합니다.\n- 서브플롯 생성: `plt.axes()`를 사용하여 서브플롯을 생성하고, 위치와 크기를 `[왼쪽, 아래, 너비, 높이]`의 리스트 매개변수로 지정합니다.\n- 기본 동작: `plt.axes()`는 보통 전체 그림 영역을 채우는 축 객체를 만듭니다.\n- 정렬: `plt.subplot()`을 사용하여 그리드 안에 서브플롯을 생성하고, 행, 열 및 서브플롯 인덱스에 대한 매개변수를 사용합니다.\n- 다중 행/열: `plt.GridSpec()`를 사용하여 여러 행 또는 열에 걸쳐있는 서브플롯을 만들고, 그리드 레이아웃을 정의합니다.\n- GridSpec 사용법: `plt.GridSpec()`은 그리드 레이아웃을 정의하고, 서브플롯 생성 시 `plt.subplot()`에 전달할 수 있습니다.\n- GridSpec 특징: 직접 차트를 만들지는 않지만 서브플롯 그리드 레이아웃을 정의합니다.\n\n```js\nimport numpy as np\nimport matplotlib.pyplot as plt\nplt.style.use('seaborn-v0_8-whitegrid')\nmean = [0, 0]\ncov = [[1, 1], [1, 2]]\nx, y = np.random.multivariate_normal(mean, cov, 3000).T\n# GridSpec를 사용하여 그리드를 생성하고 서브플롯을 추가합니다\nfig = plt.figure(figsize=(6, 6))\ngrid = plt.GridSpec(4, 4, hspace=0.2, wspace=0.2)\nmain_ax = fig.add_subplot(grid[:-1, 1:])\ny_hist = fig.add_subplot(grid[:-1, 0], xticklabels=[], sharey=main_ax)\nx_hist = fig.add_subplot(grid[-1, 1:], yticklabels=[], sharex=main_ax)\n# 주요 서브플롯에 산점도를 플롯합니다\nmain_ax.plot(x, y, 'ok', markersize=3, alpha=0.2)\n# x와 y 방향으로 히스토그램을 플롯합니다\nx_hist.hist(x, 40, histtype='stepfilled',\n            orientation='vertical', color='gray')\nx_hist.invert_yaxis() # x축 히스토그램의 y축 방향을 반전합니다 (우측 하단에 위치)\ny_hist.hist(y, 40, histtype='stepfilled',\n            orientation='horizontal', color='gray')\ny_hist.invert_xaxis() # y축 히스토그램의 x축 방향을 반전합니다 (상단 좌측에 위치)\nplt.show()\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-11EssentialPythonMatplotlibVisualizationsforDataScienceMastery_7.png\" /\u003e\n\n# 텍스트 및 주석\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 목적: 시각화는 데이터 뒤에 숨겨진 이야기를 독자에게 전달하기 위해 노력합니다.\n- 표현: 일부 차트는 그 자체로 이야기를 전달하지만, 다른 차트는 텍스트 지원이 필요합니다.\n- 주석: 차트에 텍스트 주석을 추가하여 독자의 주의를 끌고 이해를 돕습니다.\n- 텍스트 배치: 차트의 특정 위치(`x`, `y`)에 텍스트를 추가하려면 `plt.text` 또는 `ax.text`를 사용하세요.\n- 가이드: 정보 전달을 향상시키기 위해 텍스트 주석을 통해 독자를 주요 차트 기능으로 안내하세요.\n\n```js\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport matplotlib.dates as mdates\nplt.style.use('seaborn-v0_8-whitegrid')\n# 샘플 데이터셋 생성\ndates = pd.date_range(start='1969-01-01', end='1988-12-31', freq='D')\ndata = np.random.randint(3000, 5000, size=len(dates))\nbirths = pd.DataFrame(data, columns=['births'], index=dates)\nfig, ax = plt.subplots(figsize=(12, 4))\nbirths_by_date = births.pivot_table('births', [births.index.month, births.index.day])\nbirths_by_date.index = [pd.Timestamp(year=2012, month=month, day=day) for month, day in births_by_date.index]\nbirths_by_date.plot(ax=ax)\n# 선 플롯의 특정 위치에 주석 추가\nstyle = dict(size=10, color='gray')\nax.text(pd.Timestamp('2012-1-1'), 3950, \"New Year's Day\", **style)\nax.text(pd.Timestamp('2012-7-4'), 4250, \"Independence Day\", ha='center', **style)\nax.text(pd.Timestamp('2012-9-4'), 4850, \"Labor Day\", ha='center', **style)\nax.text(pd.Timestamp('2012-10-31'), 4600, \"Halloween\", ha='right', **style)\nax.text(pd.Timestamp('2012-11-25'), 4450, \"Thanksgiving\", ha='center', **style)\nax.text(pd.Timestamp('2012-12-25'), 3850, \"Christmas\", ha='right', **style)\n# 제목과 y축 레이블 설정\nax.set(title='USA births by day of year (1969-1988)',\n       ylabel='average daily births')\n# x축에 월 레이블을 중앙에 정렬\nax.xaxis.set_major_locator(mdates.MonthLocator())\nax.xaxis.set_minor_locator(mdates.MonthLocator(bymonthday=15))\nax.xaxis.set_major_formatter(plt.NullFormatter())\nax.xaxis.set_minor_formatter(mdates.DateFormatter('%b'))\nplt.show()\n```\n\n# 커스텀 눈금\n\n- 눈금 변경: Matplotlib의 보통 눈금은 대부분의 차트에 적합합니다. 그러나 일부를 위해 변경해야 할 수도 있습니다.\n- 물건 속의 물건: Matplotlib의 모든 차트 부분은 물건입니다. 도표에는 축이 있습니다. 축에는 차트 요소가 있습니다.\n- 축 요소: 축에는 `xaxis`와 `yaxis`가 있습니다. 이들은 선, 눈금, 이름 등을 가지고 있습니다.\n- 새 버전: Matplotlib 2.0 이후로 긴 축에 작은 눈금이 숨겨지게 되었습니다. 이것은 `xlim`과 `ylim`으로 변경할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\n\r\nplt.style.use('seaborn-v0_8-whitegrid')\r\nfig, ax = plt.subplots()\r\nx = np.linspace(0, 3 * np.pi, 1000)\r\nax.plot(x, np.sin(x), lw=3, label='Sine')\r\nax.plot(x, np.cos(x), lw=3, label='Cosine')\r\nax.grid(True)\r\nax.legend(frameon=False)\r\nax.axis('equal')\r\nax.set_xlim(0, 3 * np.pi)\r\nplt.show()\r\n```\r\n\r\n\u003cimg src=\"/TIL/assets/img/2024-07-14-11EssentialPythonMatplotlibVisualizationsforDataScienceMastery_8.png\" /\u003e\r\n\r\n# Matplotlib에서 3D 플롯 만들기\r\n\r\n- 2D에서 3D로: Matplotlib은 처음에는 2D 플롯만 지원했지만, 3D 플롯 도구는 버전 1.0에서 소개되었습니다.\r\n- 3D 도구 모음: 3D 플로팅은 Matplotlib과 함께 제공되는 `mplot3d` 도구 모음을 로드하여 수행됩니다.\r\n- 3D 플롯 유형: 3D 축을 활성화한 후 3D 라인 및 산점도와 같은 다양한 3D 플롯을 그릴 수 있습니다.\r\n- 3D 플로팅 함수: 3D 라인 플롯 및 산점도 플롯에는 각각 `ax.plot3D` 및 `ax.scatter3D`를 사용합니다.\r\n- 투명도와 깊이: 깊이를 나타내기 위해 산점도 플롯에는 다양한 투명도가 적용됩니다.\r\n- 대화식 뷰: 대화식 뷰를 통해 더 나은 3D 시각 경험을 제공합니다.\r\n- 3D 버프 맵: `mplot3d` 도구 모음에는 3D 버프 맵을 만드는 도구가 있습니다. 이것들은 2D `ax.contour`와 유사합니다.\r\n- 3D 표면 차트: 표면 차트는 색의 변화로 3D 표면을 보여줍니다. 와이어 차트보다 더 나은 시각적 효과를 제공합니다.\r\n- 그리드 데이터 이미지: 그리드 데이터에서 생성된 3D 이미지에는 와이어 차트와 표면 차트가 있습니다. 데이터를 3D 모양에 표시하여 더 명확하고 설득력있게 만듭니다.\r\n- 틱 스타일 변경: 일반 틱 스타일은 대부분의 작업에 적합하지만, 사인 및 코사인 차트와 같은 특정 차트에 대해 변경해야 할 수 있습니다.\r\n- 사용자 정의 예제: 틱이 위치하고 어떻게 보이는지 변경하면 차트가 무엇을 의미하는지 더 잘 보여줄 수 있습니다. 데이터에 딱 맞게 맞출 수 있습니다.\r\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfig = plt.figure()\nax = plt.axes(projection='3d')\ndef f(x, y):\n    return np.sin(np.sqrt(x ** 2 + y ** 2))\nx = np.linspace(-6, 6, 30)\ny = np.linspace(-6, 6, 30)\nX, Y = np.meshgrid(x, y)\nZ = f(X, Y)\nax.set_xlabel('x')\nax.set_ylabel('y')\nax.set_zlabel('z')\n# Flatten the X, Y, Z arrays for plot_trisurf\nax.plot_trisurf(X.flatten(), Y.flatten(), Z.flatten(),\n                cmap='viridis', edgecolor='none')\nplt.show()\n\n\n![Image](/TIL/assets/img/2024-07-14-11EssentialPythonMatplotlibVisualizationsforDataScienceMastery_9.png)\n\n저는 \"Medium에서 팔로워를 빠르게 얻는 법\"에 대한 전자책을 쓰고 있어요. 왜냐하면 제가 최고의 증거이기 때문이죠 – 딱 한 달 만에 5,000명 이상의 팔로워를 얻었어요. 기대해 주세요!\n\nSubstack에서 \"GPT 소개\" 시리즈를 쓰고 있어요. 관심 있으시면 팔로우 해주세요!\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n총 10개의 글 중 일곱 번째가 이미 완료되었어요!\n\n독서📖, 형광펜 강조🖍️, 박수👏, 댓글💬, 공유🗣️해 주셔서 감사합니다. \"Medium 친구\"로서, 매일 작가 친구들에게 호의를 돌려드릴 수 있도록 최선을 다하고 있어요.\n\n또한, 뉴스레터📰를 구독하여 이와 같은 멋진 콘텐츠가 올라올 때마다 알림을 받을 수 있어요. 고맙구나, 친애하는 챔프!🤓\n\n최신 파이썬 이야기를 계속해서 받아보려면 Substack에서 저희와 연결해주세요. 함께 파이썬의 미래를 함께 만들어요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 즐겨보세요","ogImage":{"url":"/TIL/assets/img/2024-07-14-11EssentialPythonMatplotlibVisualizationsforDataScienceMastery_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-11EssentialPythonMatplotlibVisualizationsforDataScienceMastery_0.png","tag":["Tech"],"readingTime":16},{"title":"Django 개발자들이 자주 저지르는 10가지 실수와 해결 방법","description":"","date":"2024-07-14 19:56","slug":"2024-07-14-Top10DjangoMistakestoAvoidandHowtoFixThem","content":"\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-Top10DjangoMistakestoAvoidandHowtoFixThem_0.png\" /\u003e\n\n안녕하세요, 친구들! 오늘은 Django에 대해 이야기해봐요. 그 인기있는 도구는 코딩 세계에서 많이 사용되죠. 코드를 배우면서 실수하는 것은 당연한 일이에요. 조금씩 성장하는데 도움이 되는 작은 수업이라고 생각해보세요. 그래서 많은 사람들이 겪어본 일반적인 Django 실수를 몇 가지 공유하고 그 해결책에 대해 이야기해보기로 했어요.\n\n자리를 잡고 바로 시작해볼까요? Django를 시작하는 사람이나 기술을 향상시키려는 사람에게 이 글은 도움이 될 거예요. 작은 실수들로부터 배우고 더 나은 결과물을 만들어내는 기회를 잡아봐요. 준비됐나요?\n\n# 오류 #1: Django의 내장 기능을 무시하기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nDjango로 무언가를 제작하다가 나중에 Django가 이미 제공하고 있는 것을 발견했던 적이 있나요? 저도 비슷한 경험이 있어요. 수제 빵을 만드는 것과 비슷하죠. 이미 빵 만드는 기계를 소유하고 있었는데도 모른 채 손수 만들어낸 것 같아요. Django는 우리 작업을 단순화하기 위해 설계된 다양한 기능으로 가득하답니다.\n\n잘못한 순간: 바퀴를 다시 발명하려고 하는 것. 인증 시스템, 폼 또는 관리자 인터페이스와 관련된 모든 것을 코딩하는 데 몇 시간을 낭비하는 경우를 많이 보았습니다. Django가 이미 제공하는 것을 재구현하려는 시도를 했었죠.\n\n수정 방법: Django의 도구 상자를 활용해봐요. 예를 들어, 사용자 인증이 필요한 경우는 Django가 모두 대신 처리해줍니다. 다음 코드를 확인해보세요:\n\n```python\nfrom django.contrib.auth.forms import UserCreationForm\nfrom django.urls import reverse_lazy\nfrom django.views import generic\n\nclass SignUp(generic.CreateView):\n    form_class = UserCreationForm\n    success_url = reverse_lazy('login')\n    template_name = 'signup.html'\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n본문을 확인하세요! 간단한 가입 양식이 있어요. 그리고 양식? Django 양식은 사용자 입력을 다루는 마법봉 같아요:\n\n```js\nfrom django import forms\n\nclass ContactForm(forms.Form):\n    name = forms.CharField()\n    message = forms.CharField(widget=forms.Textarea)\n```\n\nDjango의 기능들은 숨겨진 보물들과 같아요. 이를 파헤치면 시간을 절약할 뿐만 아니라 앱을 훨씬 능률적으로 만들 수 있어요. 그러니 코딩하기 전에, 이렇게 물어보세요: \"이걸 할 수 있는 Django 방법이 있을까요?\"\n\n# 실수 #2: 부족한 데이터베이스 관리\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n메모 \n예전에 옷장이 엉망이 되면 내가 좋아하는 셔츠를 찾기 힘들어져서 당황하는 거 알지? Django에서 비효율적인 데이터베이스 관리는 그랬다치면 그런 느낌이란다. 데이터베이스를 깔끔하고 효율적으로 유지하는 게 아주 중요하단다. 안 그러면 느린 쿼리와 성능 문제에 직면할 지경이야.\n\n실수 순간: 이게 바로 우리가 자주 걸릴 함정이야 — 데이터베이스 인덱싱을 무시하거나 비효율적인 쿼리를 작성하는 것. 바로 찾고 싶은 특정 셔츠 대신 옷장에 있는 모든 셔츠를 일일이 뒤져보는 것과 비슷하다고 할까.\n\n수리법: 쿼리 정리해 볼까? 먼저, 인덱싱. 데이터베이스 검색 속도를 높이는 생명 구조자나요. 자주 사용자 이름으로 검색한다고 가정해보자:\n\n```js\nclass User(models.Model):\n    username = models.CharField(max_length=245, db_index=True)\n    # 다른 필드...\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\ndb_index=True를 추가하는 것은 마치 옷장에 즐겨 입는 셔츠로 바로 통로를 만드는 것과 같아요.\n\n다음으로, 쿼리를 최적화해 보겠습니다. Django의 ORM은 훌륭하지만 조심해야 해요. N+1 쿼리 문제를 피하기 위해:\n\n```js\n# 이렇게 하는 대신\nfor book in Book.objects.all():\n    print(book.author.name)\n\n# 이렇게 해주세요\nfor book in Book.objects.select_related('author').all():\n    print(book.author.name)\n```\n\n이렇게 하면 각 책에 대한 별도의 쿼리 대신 같은 쿼리에서 작가 데이터를 가져올 수 있어요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그리고 대규모 데이터셋을 필터링하기 위해 prefetch_related를 사용하세요:\n\n```js\n# 다대다 관계를 다룰 때\nfor room in Room.objects.prefetch_related('guests').all():\n    guests = \", \".join(str(guest) for guest in room.guests.all())\n    print(f\"Room: {room.name}, Guests: {guests}\")\n```\n\n이렇게 하면 관련된 객체에 액세스할 때 발생하는 쿼리 수를 줄일 수 있어요.\n\n기억하세요, Django에서 데이터베이스를 효율적으로 관리하는 것은 스마트한 계획과 이런 작은 꿀팁들을 알아내는 데 달려 있어요. 데이터베이스 쿼리를 능숙하고 효율적으로 관리하면 Django 앱이 좋아할 거예요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 실수 #3: 보안 관행을 무시하다\n\n앞문을 열어 놓고 나가기를 한 적이 있나요? 디지털 세계에서는 우리의 Django 앱에서 보안을 간과할 때 발생하는 일종의 상황입니다. Django는 일부 견고한 보안 기능을 제공하지만 이를 사용하지 않는 것은 고민을 초대하는 것과 같습니다.\n\n실수 순간: 민감한 데이터를 노출하거나 CSRF 토큰을 잘못 처리하는 것은 큰 실수입니다. 이는 큰 표지판에 집 주소를 실수로 공개하는 것과 마찬가지로 현명하지 않습니다.\n\n수정 방법: 보안을 강화해 봅시다. 우선, 민감한 데이터에 대한 Django의 내장 보호 기능을 항상 사용하세요. 이렇게 하지 않는 예시를 보여드릴게요:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 평문으로 민감한 데이터를 저장하지 마세요\nuser.secret = \"나의매우비밀번호\"\nuser.save()\r\n```\n\n대신 Django에게 처리를 맡기세요:\n\n```js\nfrom django.contrib.auth.hashers import make_password\n\n# 올바른 방법\nuser.password = make_password(\"나의매우비밀번호\")\nuser.save()\r\n```\n\n이제 CSRF 토큰에 대해 이야기해 보겠습니다. 이들은 웹사이트의 비밀 악수처럼 작동합니다. 이를 빠뜨리는 것은 특히 AJAX 호출에서 흔한 실수입니다. 이를 올바르게 포함하는 방법은 다음과 같습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n// AJAX 호출을 위한 JavaScript 코드\nfunction csrfSafeMethod(method) {\n    // 이 HTTP 메소드는 CSRF 보호가 필요하지 않습니다\n    return (/^(GET|HEAD|OPTIONS|TRACE)$/.test(method));\n}\n\n$.ajaxSetup({\n    beforeSend: function(xhr, settings) {\n        if (!csrfSafeMethod(settings.type) \u0026\u0026 !this.crossDomain) {\n            xhr.setRequestHeader(\"X-CSRFToken\", getCookie('csrftoken'));\n        }\n    }\n});\n```\n\n또한, Django 폼에서는 'csrf_token' 템플릿 태그가 있는지 확인해주세요:\n\n```html\n\u003cform method=\"post\"\u003e\n    {% csrf_token %}\n    \u003c!-- 여기에 폼 필드를 추가하세요 --\u003e\n\u003c/form\u003e\n```\n\n위 가이드라인을 준수하면 당신의 Django 앱을 견고하고 튼튼한 요새로 만들 수 있어요. 그러니 웹 개발의 영역에서는 조심하는 것이 후회하는 것보다 언제나 현명합니다!\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 실수 #4: 테스트를 과소평가하기\n\n이런 상황을 상상해보세요. 당신은 Django 앱에서 최고의 기능을 완성했습니다. 멋있게 보이고 자신의 컴퓨터에서 잘 작동하며 라이브로 푸시합니다. 그런데, 우왕! 뭔가가 깨졌습니다. 익숙한 상황인가요? 테스트를 무시할 때 종종 발생합니다. 그것은 먼저 입어보지 않고 수트를 사는 것과 비슷합니다. 나중에 발생할 수 있는 문제를 예상할 수 없습니다.\n\nOops 순간: 많은 사람들이 테스트를 건너뛰는 습관에 빠져 시간을 절약한다고 생각하지만, 그것은 안전 조치 없이 줄타기를 하는 것과 유사합니다.\n\n수정 방법: Django의 테스트 프레임워크를 선택하고 테스트 주도 개발 (TDD) 방법을 채택해보세요. 여기 간단한 Django 테스트 예제가 있습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nDjango의 테스트 케이스와 모델에서 테스트하는 방법은 이렇습니다. 이 테스트는 모델의 문자열 표현이 우리가 예상한 대로인지 확인합니다. 간단하지만 강력한 방법이죠.\n\n그리고 데이터를 깨끗하게 유지하는 것을 좋아하는 분들을 위해, Django의 Client 클래스로 테스트하는 방법을 소개합니다.\n\nfrom django.test import TestCase\nfrom .models import YourModel\n\nclass YourModelTest(TestCase):\n    def test_str_representation(self):\n        entry = YourModel(name=\"My Test Entry\")\n        self.assertEqual(str(entry), entry.name)\n\nfrom django.test import Client\n\nclass ViewTest(TestCase):\n    def setUp(self):\n        self.client = Client()\n\n    def test_homepage(self):\n        response = self.client.get('/')\n        self.assertEqual(response.status_code, 200)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이렇게 하면 홈페이지가 원활하게 작동됨이 보장됩니다.\n\nTDD를 채택하는 것은 기능 코드를 작성하기 전에 이러한 테스트를 먼저 작성한다는 것을 의미합니다. 집을 지을 때 청사진을 그리는 것과 비슷합니다. 개발을 안내하고 오류를 초기에 잡아냅니다.\n\nDjango 세계에서 테스트는 그저 일의 부담이 아니라 견고하고 신뢰할 수 있는 코드를 위한 비밀 무기입니다. 그러므로 우리는 이를 과소평가하지 말아야 하며, 코딩 루틴의 일부로 만들어 봅시다!\n\n# 실수 #5: 정적 파일과 미디어 파일 관리하기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n작은 것 같지만 큰 귀찮음이 될 수 있는 주제에 대해 이야기해 봐요 — Django에서 정적 파일과 미디어 파일을 처리하는 것입니다. 이것은 책장을 정리하는 것과 비슷해요. 모든 것이 제 자리에 있을 때 효과적으로 보이고 작동합니다. 그러나 그렇지 않으면 필요한 책을 찾는 것이 괴로운 일이 될 거예요.\n\n실수 순간: 흔한 실수 중 하나는 정적 자산을 잘못 구성하는 것이에요. 이것은 책을 순서 없이 책장에 올려놓는 것과 같아요 — 특히 개발 환경에서 운영 환경으로 이동할 때 더럽혀집니다.\n\n수정 방법: 핵심은 각 환경에 맞게 정적 파일과 미디어 파일을 올바르게 설정하는 것이에요. 개발 환경 설정에서는 아래와 같이 설정할 수 있어요:\n\n# settings.py in development\nSTATIC_URL = '/static/'\nMEDIA_URL = '/media/'\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n로컬 머신에서는 잘 작동합니다. 그러나 프로덕션 환경으로 이동하면 변경됩니다. 이 파일들을 Amazon S3와 같은 서비스를 통해 다르게 제공해야 합니다. 다음은 설정하는 방법입니다:\n\n# settings.py in production\nSTATIC_URL = 'https://yourbucketname.s3.amazonaws.com/static/'\nMEDIA_URL = 'https://yourbucketname.s3.amazonaws.com/media/'\n\n# Using django-storages for S3 integration\nSTATICFILES_STORAGE = 'storages.backends.s3boto3.S3Boto3Storage'\nDEFAULT_FILE_STORAGE = 'storages.backends.s3boto3.S3Boto3Storage'\n\n이 설정은 정적 및 미디어 파일이 프로덕션 환경에서 올바르게 처리되도록합니다.\n\n반드시 collectstatic도 잊지 마세요! 배포 전에 모든 정적 파일을 한 곳에 수집해야 합니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\npython manage.py collectstatic\n\n이 명령어는 STATIC_ROOT 디렉토리로 모든 정적 파일을 수집하여 배포 준비를 합니다.\n\n이러한 파일을 올바르게 관리하면 Django 앱이 잘 작동할 뿐만 아니라 배포된 위치에 상관없이 더 빨리 로드되고 의도한 대로 보입니다. 그러니 디지털 책꽂이를 정리해 봅시다!\n\n# 실수 #6: Django 템플릿의 효율적인 사용 방법\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n식탁 위에 각종 가전제품이 모두 쌓여 있는 주방에 들어간 적이 있나요? 요리사들의 꿈 같지만 실제로는 정리되지 않은 혼돈 그 자체예요. Django 템플릿도 마찬가지죠. 강력하지만 너무 많은 로직을 밀어 넣으면 요리할 만큼의 정돈되지 못한 주방과 같습니다.\n\n실수 순간: 복잡한 로직으로 템플릿을 엄청 채워 넣는 것은 흔한 일이에요. 한 개의 버너로 7코스 요리를 준비하려는 것 같아서 처리하기 힘들어지죠.\n\n수정안: 간단히 유지하세요. Django의 템플릿 태그와 필터를 사용하여 템플릿을 깔끔하고 읽기 쉽게 유지하세요. 템플릿에 로직을 밀어 넣는 대신 템플릿 태그를 사용하세요:\n\n# 당신의_템플릿.html\n{ for item in items }\n    { if item.is_available }\n        \u003cp\u003e{ item.name } 이/가 이용 가능합니다!\u003c/p\u003e\n    { endif }\n{ endfor }\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이렇게 하면 깔끔하고 깔끔해요. 그런데 논리가 좀 더 복잡해지면 어떨까요? 사용자 상태를 표시하는 필요가 자주 있는 경우 사용자 지정 템플릿 태그를 작성해보세요:\n\n# 사용자 정의 템플릿 태그에서\nfrom django import template\n\nregister = template.Library()\n\n@register.simple_tag\ndef user_status(user):\n    return \"활성화됨\" if user.is_active else \"비활성화됨\"\n\n그리고 템플릿에서 사용하세요:\n\n{ 사용자 정의 태그 불러오기 }\n\u003cp\u003e사용자 상태: { user_status user }\u003c/p\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n필터는 또 다른 훌륭한 도구입니다. 데이터를 형식화하는 데 완벽합니다. 특정 형식으로 날짜를 표시하려면 다음과 같이 작성하세요:\n\n# 템플릿에서\n{ your_date|date:\"D d M Y\" }\n\n이 방법은 템플릿 자체에서 형식을 지정하는 것보다 훨씬 깔끔합니다.\n\n템플릿을 간소화하고 Django의 템플릿 태그와 필터를 사용함으로써 효율적이고 관리하기 쉬운 코드를 유지할 수 있습니다. 정돈된 부엌을 유지하는 것과 같습니다: 필요한 모든 것이 준비되어 있지만 필요할 때만 사용됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 실수 #7: 부족한 애플리케이션 구조\n\n도서관에서 모든 책이 한 곳에 쌓여 있는 라이브러리에서 책을 찾아보았던 적이 있나요? 바로 그것이 구조가 잘못된 Django 프로젝트를 다루는 느낌입니다. 청결하고 확장 가능한 구조를 갖는 것이 중요합니다. 이를 잘 정리된 도서관처럼 생각해보세요. 각 책이 자리를 가지고 있는 곳이 있는 곳입니다.\n\n실수 순간: Monolithic 앱을 만들거나 Django의 앱 구조를 효과적으로 활용하지 않는 것이 흔한 실수입니다. 서로 다른 향신료, 냄비, 프라이팬을 하나의 큰 서랍에 넣는 것과 같은 혼란스러운 상황을 초래할 수 있습니다.\n\n문제 해결: 프로젝트를 더 작고 효율적으로 관리할 수 있는 앱으로 나누어보세요. 각 앱은 명확한 목적을 가져야 합니다. 예를 들어, 하나의 거대한 앱 대신에, - 한 개의 목적을 가진 작은 앱을 사용하세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nmanage.py\nyour_project/\n    __init__.py\n    settings.py\n    urls.py\n    wsgi.py\n    asgi.py\nblog/\n    models.py\n    views.py\n    templates/\n    urls.py\nstore/\n    models.py\n    views.py\n    templates/\n    urls.py\n\n이 구조에서 blog와 store는 프로젝트 내의 별도의 앱입니다. 각각 자체 모델, 뷰, 템플릿 및 URL을 가지고 있어 프로젝트를 모듈화하고 더 쉽게 유지할 수 있습니다.\n\n또한 Django의 프로젝트 수준과 앱 수준의 템플릿 디렉토리를 사용하세요. 이렇게 하면 템플릿이 정리되어 관리됩니다:\n\n# settings.py에 추가\nTEMPLATES = [\n    {\n        # ...\n        'DIRS': [os.path.join(BASE_DIR, 'templates')],\n        # ...\n    },\n]\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n각 앱 안에서 템플릿을 해당 폴더에 구성하세요:\n\nyour_project/\n    templates/\n        base.html\nblog/\n    templates/\n        blog/\n            blog_index.html\n            blog_detail.html\nstore/\n    templates/\n        store/\n            store_index.html\n            store_detail.html\n\n이렇게 Django 프로젝트를 구성하면 성공을 이룰 수 있을 거에요. 이 방법을 사용하면 프로젝트를 확장하고 관리할 수 있으며, 작업하기 훨씬 만족스러울 거예요!\n\n# 실수 #8: 성능 최적화 무시하기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파스트푸드 가게에서 주문한 음식이 너무 오래 걸려서 배달되는 상황을 상상해보세요. 짜증나죠? 그런 느낌이 바로 웹 앱이 느릴 때 느껴지는 감정입니다. Django 세계에서 성능 최적화를 간과하는 것은 파스트푸드 산업에서 천천히 움직이는 식당을 운영하는 것과 같습니다. 그렇게 어울리지 않죠.\n\n실수 순간: 주요 문제는 뭘까요? 캐싱 사용하지 않기나 비효율적인 코드 작성 등입니다. 각 주문마다 새로운 프렌치 프라이를 만드는 것과 같습니다. 준비된 프렌치 프라이가 준비되어 있지 않은 것입니다.\n\n수정 방법: Django의 캐싱 프레임워크는 사이트 일부를 저장하여 각 방문마다 다시 구축할 필요가 없도록하는 데 탁월합니다. 한 뷰 전체를 15분의 1/4 동안 캐시하는 방법은 다음과 같습니다:\n\nfrom django.views.decorators.cache import cache_page\n\n@cache_page(60 * 15)\ndef my_view(request):\n    # 뷰 로직 작성\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그리고 템플릿 캐싱을 위해 조각만 캐시할 수도 있어요:\n\n{ load cache }\n{ cache 500 sidebar }\n    \u003c!-- Heavy lifting sidebar stuff --\u003e\n{ endcache }\n\n이제 코드와 쿼리를 최적화해 봐요. Django의 ORM은 효과적이지만, 분별력 없이 사용하면 비효율적인 쿼리가 발생할 수 있어요. 도서관에 있는 모든 책과 저자를 함께 보여주려고 한다면 이렇게 하지 말고요:\n\nbooks = Book.objects.all()\nfor book in books:\n    print(book.author.name)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이렇게 해보세요:\n\nbooks = Book.objects.select_related('author').all()\nfor book in books:\n    print(book.author.name)\n\n이렇게 하면 쿼리의 수가 줄어들어 페이지 로딩 속도가 빨라집니다.\n\nDjango 앱을 원할하게 유지하는 것은 바쁜 음식점에서 주문을 처리하는 것과 같아요. 캐싱과 쿼리 최적화에 약간의 선견지명을 발휘하면 성능에 큰 차이를 만들 수 있어요. 앱을 빠르고 잘 동작하도록 유지합시다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 실수 #9: 버전 관리를 잊은 경우\n\n상상해보세요: 거대한 직소 퍼즐을 해결하고 있는데 매번 멀어지는 동안 누군가가 조각들을 재배열하는 상황입니다. 짜증나죠? 버전 관리 없이 코딩하는 것은 이런 느낌입니다. 개발 세계에서 버전 관리는 마법 같은 실행 취소 버튼이나 각 퍼즐 변경 사항을 추적할 수 있는 방법과 같습니다.\n\n실수 순간: 많은 사람들이 버전 관리를 설정하지 않고 프로젝트에 뛰어들곤 합니다. 이는 지도 없이 여행하는 것과 같습니다. 어딘가에는 도착할 수 있겠지만 어디죠?\n\n수정 방법: Git은 코딩 여정에서 우리의 지도입니다. 모든 변경 사항을 추적하고 협업을 용이하게 만들어줍니다. Git을 설정하는 것은 간단합니다. 먼저 프로젝트에서 Git 저장소를 초기화하세요:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그럼 파일을 추가하고 커밋하세요:\n\ngit add .\ngit commit -m \"첫 번째 커밋\"\n\n코드를 커밋하는 것뿐만이 아닙니다. 좋은 습관을 가지세요. 변경한 내용을 설명하는 의미 있는 커밋 메시지를 작성하세요:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\ngit commit -m \"사용자 인증 기능 추가\"\n\n그리고 새로운 기능이나 버그 수정에 브랜치를 사용하세요. 실험을 할 때 주요 코드를 안전하게 보관할 수 있어요:\n\ngit checkout -b new-feature\n\n완료되면, 메인 브랜치로 병합해주세요:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마지막으로, .gitignore 파일을 잊지 마세요. 이 파일들은 추적기에 \"이 파일들은 무시해\" 라고 말하는 것과 같다고 생각하시면 되요. 특히 환경 설정과 같은 파일들을 위해 꼭 필요합니다:\n\n# .gitignore\n.env\n__pycache__/\ndb.sqlite3\n\n개발 프로세스에 버전 관리를 짜맞춰 넣으면, 단순히 변경 사항을 추적하는 것 뿐만 아니라, 프로젝트의 여정을 기록하는 연대기를 만들게 됩니다. 이것은 어떤 개발자도 소홀히 할 수 없는 안전망입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 실수 #10: 커뮤니티와 리소스를 무시하는 것\n\n가정에서 무언가를 고치려다가 막연한 상상으로만 할 때가 있지 않나요? 가끔은 남는 부품이 생기기도 하죠? 그것은 마치 Django를 활용할 때 활기찬 커뮤니티와 풍부한 리소스를 활용하지 않는 것과 비슷합니다. 사용 가능한 도구상자를 전혀 이용하지 않는 것과 같죠.\n\n실수한 순간: 종종, 우리는 혼자서 문제를 해결하려고 하며 남들의 도움이 필요하지 않다고 생각할 때가 있습니다. 하지만 도움을 주고 안내해 줄 수 있는 사람들이 많을 때 왜 바퀴를 다시 발명해야 할까요?\n\n수정 방법: 우선, Django 문서는 코딩 세계에서 가장 친한 친구와 같습니다. 그것은 포괄적이고 잘 구조화되어 있습니다. 막힐 때마다 답이 문서 안에 있을 확률이 높습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nhttps://docs.djangoproject.com/\n\n하지만 문서만으로는 충분하지 않을 때는 어떻게 할까요? 이때 커뮤니티 포럼과 질문 응답 사이트인 스택 오버플로와 같은 곳이 도움이 됩니다. 이상한 오류나 복잡한 문제가 발생했을 때 다른 사람이 이미 해결한 경우가 있습니다:\n\nhttps://stackoverflow.com/questions/tagged/django\n\n그리고 Django의 공식 포럼을 잊지 말아야 합니다. 조언을 구하거나 지식을 공유하고 다른 사람의 경험을 배울 수 있는 보물창고입니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nhttps://forum.djangoproject.com/\n\n또한, Django 관련 블로그를 팔로우하거나 뉴스레터를 구독하는 것도 고려해보세요. 이들은 최선의 방법, 새로운 기능 및 유용한 팁에 대한 통찰을 제공할 수 있습니다:\n\nDjango News (https://django-news.com/)\nSimple is Better Than Complex (https://simpleisbetterthancomplex.com/)\n\n게다가 DjangoCon에 참석해보는 것은 어떨까요? 이는 단순히 강연에 관한 것이 아니라 만나는 사람들과 나누는 경험들에 대한 것입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n장고 커뮤니티를 받아들여 그 풍부한 자원을 이용하면, 코딩 퍼즐을 해결하는 것뿐만 아니라 활기찬 지지 망의 일원이 되는 것입니다. 기억하세요, 배울 것은 항상 더 있고, 그것을 하는 가장 좋은 방법은 함께하는 것입니다.\n\n# 결론\n\n그리고 여기에서 이것이 있습니다 — Django 개발 세계의 흔한 함정을 헤쳐나가는 여정이었습니다. 이것은 하이킹 여행과 약간 비슷합니다: 분명히 몇 번 걸려 넘어질 수 있지만, 각 실수는 새로운 것을 가르쳐 줍니다. 이 실수를 피하는 것은 당신의 코드를 더 나아지게 만드는 것뿐만 아니라 개발자로서成長하는 것입니다.\n\n장고의 전체 잠재력을 활용하지 않는 것부터 커뮤니티의 지혜를 놓치는 것까지, 저희가 다룬 각 지점은 더 견고하고 효율적이며 즐거운 Django 경험을 향한 한 걸음입니다. 이 팁을 당신의 코딩 나침반으로 생각하고 혼란의 희미한 물에서 빠져 명확하고 더 효과적인 개발을 향해 이끌어주는 것으로 생각해보세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하지만 여기서 학습이 끝나는 것은 아닙니다. 장고는 다른 프레임워크와 마찬가지로 계속해서 학습 곡선이 이어지는 것이죠. 항상 새로운 도전과 놀라움을 안겨주는 모험이기 때문입니다. 그것이 장고의 아름다움이라고 생각되지 않나요? 항상 배울 것이 있고, 해결해야 할 새로운 퍼즐이 있는 것이죠.\n\n이제 여러분의 이야기를 듣고 싶어요. 여러분이 자주 활용하는 장고 트릭이 뭔가요? 코딩 실수에서 얻은 학습 기회로 이어지는 이야기가 있나요? 여러분의 경험과 팁을 댓글로 공유해주세요. 이 대화를 이어가고, 서로서로에서 계속해서 학습해 나가요. 결국, 이것이 장고 커뮤니티를 멋지게 만드는 것이죠 - 우리 모두 함께하는 것입니다.\n\n👏 만약 장고 보안 영역을 빠른 여행하면서 즐겼다면, 대화를 계속해요! 여러분의 박수와 공유는 제 글을 쓰는 열정을 불어넣어주는 것 뿐만 아니라 다른 사람들이 장고 보안에 대한 중요한 통찰을 발견할 수 있도록 도와줍니다.\n\n🖋️ Medium에서 팔로우해요: 더 많은 기술 통찰, 팁, 이야기를 원하시나요? 웹 개발 세계에서 제 최신 사상과 유용한 안내서를 정기적으로 공유하는 Medium에서 저를 팔로우해주세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n🎮 디스코드 커뮤니티에 가입해주세요: 더 심도있는 토론에 참여하고, 질문을 하며, 다른 장고 애호가 및 웹 개발자들과 연결하세요. 제 디스코드 커뮤니티에 가입하여 지식과 호기심이 만나며 함께 성장할 수 있는 공간입니다.\n\n🎥 제 YouTube 채널 구독하기\n\n그리고 제가 Patreon도 만들었어요. 여러분의 지원으로 글 쓰기를 계속할 수 있고 동영상 제작을 시작할 수 있습니다.\n\n여러분의 지원, 참여, 그리고 호기심이 이 커뮤니티를 특별하게 만듭니다. 정말 감사드려요! ❤️\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n🤖 트래비스와 함께 무료로 파이썬을 배워보세요. 📚 15만 개의 무료 학습 자료 | 🔀 대화형 로드맵 | 🤖 인공지능 지도학습.\n\n# 쉬운 영어로 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 박수로 격려하고 팔로우해주세요 ️👏️️ \n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture\n- PlainEnglish.io에서 더 많은 콘텐츠 확인하기","ogImage":{"url":"/TIL/assets/img/2024-07-14-Top10DjangoMistakestoAvoidandHowtoFixThem_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-Top10DjangoMistakestoAvoidandHowtoFixThem_0.png","tag":["Tech"],"readingTime":24},{"title":"이미지 분할의 혁명 U-Net 아키텍처 탐구","description":"","date":"2024-07-14 19:55","slug":"2024-07-14-TheRevolutionofImageSegmentationExploringU-NetArchitecture","content":"\n\n# 요약\n\n배경: 이미지 세그멘테이션은 특히 생체 의료 이미징 분야에서 정확성과 효율성을 요구하여 정밀한 분석이 필요합니다. Olaf Ronneberger 등에 의해 소개된 U-Net 아키텍처는 이러한 작업에 대한 중요한 해결책으로 부상하였습니다.\n\n문제: 기존 이미지 세그멘테이션 기술은 고해상도 공간 세부 정보와 맥락적 이해 사이의 균형을 맞추는 데 도움이 필요하여 세그멘테이션 성능이 최적화되지 않을 수 있습니다.\n\n접근 방식: 본 글에서는 합성 데이터셋을 활용한 U-Net 아키텍처의 구현을 탐구합니다. 특성 엔지니어링, 하이퍼파라미터 튜닝, 교차 검증을 포함한 포괄적인 프로세스를 통해 모델을 교육 및 평가합니다. U-Net 모델의 성능은 표준 메트릭과 시각화를 사용하여 평가됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n결과: U-Net 모델은 합성 데이터셋에서 높은 정확도(99.03%), 정밀도(99.07%), 재현율(98.99%), 그리고 F1 점수(99.03%)를 달성했습니다. 손실 및 정확도 플롯은 효과적인 학습과 과적합이 적음을 시사하며, 실제 및 예측된 마스크의 시각적 비교는 모델의 분할 능력을 보여줍니다.\n\n결론: U-Net 아키텍처는 이미지 분할 작업에 매우 효과적이며, 우수한 성능 지표와 시각적 결과를 달성합니다. 고해상도 공간 세부 정보를 맥락적 이해와 결합할 수 있는 능력은 특히 생체 의료 이미지 분석과 같이 정밀한 이미지 분석이 필요한 분야에서 가치가 있습니다.\n\n키워드: U-Net 아키텍처; 이미지 분할; 생체 의료 이미징; 딥 러닝; 신경망.\n\n# 소개\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n의료 영상 이미지를 정밀하게 분석하여 이상을 식별하는 방사선 전문의로 상상해 보세요. 이 작업에는 예민한 시각과 몇 시간에 걸친 집중력이 필요합니다. 만약 이 프로세스를 자동화하여 작업량을 줄이고 정확성을 높일 방법이 있다면 어떨까요? U-Net [1]이 그 해결책으로 등장합니다. 이 건물주택은 의료 영상 분할에서 혁명을 일으킨 아키텍처의 놀라운 예다.\n\n![이미지](/TIL/assets/img/2024-07-14-TheRevolutionofImageSegmentationExploringU-NetArchitecture_0.png)\n\n# U-Net의 탄생\n\nU-Net은 2015년에 Olaf Ronneberger와 그 동료들에 의해 소개되었으며 주로 생체 의료 이미지 분할을 위해 설계되었습니다. U자 모양을 띤 이 아키텍처는 맥락을 포착하는 수축 경로와 정확한 지역화를 가능케 하는 대칭확장 경로로 구성되어 있습니다. 이 이중 경로 접근법은 특히 정확성이 중요한 분야에서 U-Net을 게임 체인저로 만들었습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 아키텍처 분석\n\n## 1. 인코더: 맥락 캡처\n\n인코더 또는 저차원화 경로는 3x3 콘볼루셔널 계층 두 개(패딩이 없는 콘볼루션)을 반복적으로 적용한 후 각각 ReLU 및 2x2 맥스 풀링 연산을 적용하여 다운샘플링하는 과정으로 구성됩니다. 이 경로는 이미지의 주요 특징을 캡처하면서 공간적인 차원을 줄여 입력 데이터의 맥락을 이해할 수 있도록 합니다.\n\n## 2. 병목 계층: 다리\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n네트워크의 핵심에서 병목 계층은 인코더와 디코더 사이의 다리 역할을 합니다. 이 계층은 데이터를 더 처리하며 분할에 중요한 가장 추상적인 특징을 포착하는 합성곱 계층으로 구성되어 있습니다.\n\n## 3. 디코더: 정확한 위치 지정\n\n디코더 또는 확장 경로는 특성 맵의 업샘플링을 수행한 후 2x2 컨볼루션(\"업-컨볼루션\")이 이어지는 반으로 특성 채널의 수를 절반으로 줄이는 작업을 수행합니다. 이 경로는 인코더에 의해 포착된 맥락을 수축 경로의 해당 계층에서의 고해상도 특징과 skip 연결을 통해 결합합니다. 이러한 skip 연결은 네트워크가 다운샘플링 중에 상실된 공간 정보를 보존하도록 도와주기 때문에 정확한 위치 지정을 보장합니다.\n\n## 4. 출력 계층: 분할 맵\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n최종 레이어는 각 피처 벡터를 원하는 클래스 수에 매핑하는 1x1 컨볼루션입니다. 일반적으로 이어서 소프트맥스 활성화 함수가 사용됩니다. 그 결과는 입력 이미지의 관심 영역을 강조하는 분할된 출력입니다.\n\n# 건너뛰기 연결의 힘\n\nU-Net의 가장 혁신적인 기능 중 하나는 건너뛰기 연결의 사용입니다. 이러한 연결은 인코더와 디코더 경로의 해당 레이어를 연결하여 네트워크가 일반적으로 대략적이고 추상적인 피처를 세밀하고 상세한 정보와 결합하도록 하는 데 기여합니다. 이 설계 선택은 U-Net이 상대적으로 작은 데이터셋에서 훈련되었을 때라도 높은 정확도를 달성하도록 허용하여 분할 작업에서 뛰어난 성능을 발휘하게 만듭니다.\n\n# 실제 응용 사례\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nU-Net이 처음에는 의료 이미지 분할을 위해 개발되었지만, 그 응용 분야는 훨씬 넓어집니다. 농업 분야에서는 위성 이미지를 분할하여 작물 건강을 모니터링하는 데 사용됩니다. 자율 주행에서는 U-Net이 도로 장면을 분할하여 차선, 차량 및 보행자를 식별하는 데 도움이 됩니다. U-Net의 다양성은 이미지 분할이 중요한 여러 영역에서 가치있는 도구로 만들어줍니다.\n\n# 실제 예시\n\n아래에는 합성 데이터셋에서 U-Net 아키텍처를 시연하는 완전한 코드 예시가 있습니다. 이 예시에는 특성 특성화, 특성 공학, 하이퍼파라미터 튜닝, 교차 검증, 예측, 평가 메트릭 및 결과 시각화가 포함되어 있습니다.\n\n```js\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn.model_selection import train_test_split, KFold\nfrom sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score\nimport tensorflow as tf\nfrom tensorflow.keras import layers, models as keras_models\nfrom tensorflow.keras.optimizers import Adam\n\n# 합성 데이터셋 생성\ndef create_synthetic_data(num_samples=1000, img_size=128):\n    X = np.random.rand(num_samples, img_size, img_size, 1)\n    Y = (X \u003e 0.5).astype(np.float32)\n    return X, Y\n\nX, Y = create_synthetic_data()\n\n# 데이터 분할\nX_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2, random_state=42)\n\n# U-Net 모델\ndef unet_model(input_size=(128, 128, 1)):\n    inputs = layers.Input(input_size)\n\n    # 중략\n\n# 모델 컴파일 및 훈련\ndef compile_and_train_model(X_train, Y_train, X_val, Y_val, epochs=50, batch_size=32, learning_rate=1e-4):\n\n    # 중략\n\n# 하이퍼파라미터 튜닝 및 교차 검증\nkf = KFold(n_splits=5)\nhistories = []\ntrained_models = []\n\n# 중략\n\n# 테스트 세트에서 최종 모델 평가\nbest_model = trained_models[0]\n\n# 중략\n\n# 평가 메트릭\naccuracy = accuracy_score(Y_test.flatten(), test_predictions_binary.flatten())\nprecision = precision_score(Y_test.flatten(), test_predictions_binary.flatten())\nrecall = recall_score(Y_test.flatten(), test_predictions_binary.flatten())\nf1 = f1_score(Y_test.flatten(), test_predictions_binary.flatten())\n\nprint(f\"정확도: {accuracy:.4f}\")\nprint(f\"정밀도: {precision:.4f}\")\nprint(f\"재현율: {recall:.4f}\")\nprint(f\"F1 점수: {f1:.4f}\")\n\n# 훈련 이력 시각화\nplt.figure(figsize=(12, 4))\n\n# 중략\n\n# 예측 시각화\ndef visualize_predictions(X_test, Y_test, predictions, num_samples=5):\n    plt.figure(figsize=(15, 5))\n\n    # 중략\n\nvisualize_predictions(X_test, Y_test, test_predictions_binary)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 코드 설명\n\n- 가상 데이터셋 생성: 무작위 이미지와 이에 대응하는 이진 마스크로 가상 데이터셋을 생성합니다.\n- 데이터 분할: 데이터셋을 학습 및 테스트 세트로 나눕니다.\n- U-Net 모델 정의: U-Net 아키텍처를 인코더, 병목, 디코더 블록으로 정의합니다.\n- 모델 컴파일 및 학습: 모델을 Adam 옵티마이저와 이진 크로스 엔트로피 손실 함수로 컴파일합니다. 학습 및 검증 데이터로 모델을 학습시킵니다.\n- 하이퍼파라미터 튜닝 및 교차 검증: K-Fold 교차 검증을 사용하여 여러 모델을 학습하고 학습 히스토리를 기록합니다. \n- 평가: 최적 모델을 정확도, 정밀도, 재현율 및 F1 점수를 사용하여 테스트 세트에서 평가합니다.\n- 학습 히스토리 그래프: 모델의 성능을 시각화하기 위해 학습과 검증 손실 및 정확도를 플롯합니다.\n- 예측 시각화: 테스트 세트에서 몇 가지 샘플을 시각화하여 입력 이미지, 실제 마스크 및 예측된 마스크를 비교합니다.\n\n이 코드는 가상 데이터셋을 사용하여 U-Net 모델을 구현하고 평가하는 포괄적인 예제를 제공하며, 모델 학습부터 성능 평가 및 시각화까지 모든 중요한 측면을 다룹니다.\n\n![이미지](/TIL/assets/img/2024-07-14-TheRevolutionofImageSegmentationExploringU-NetArchitecture_1.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nU-Net 모델이 합성 데이터 세트에서의 성능이 시각적 및 양적으로 평가되었습니다. 결과를 자세히 해석해 봅시다.\n\n## 손실 및 정확도 그래프\n\n손실 그래프\n\n- 훈련 손실 및 검증 손실: 둘 다 초기에 빠르게 감소한 후 낮은 값 주변에 안정화되며, 끝에 약간의 상승이 나타납니다. 훈련 및 검증 손실이 유사한 추세를 따르므로, 모델이 과적합이 없이 효과적으로 학습하고 있음을 나타냅니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n정확도 그래프\n\n- 훈련 정확도 및 검증 정확도: 두 정확도 지표 모두 빠르게 증가하고 약 0.99 정도에서 안정화됩니다. 훈련 및 검증 정확도 곡선의 밀접한 일치는 잘 일반화된 모델을 나타냅니다.\n\n## 성능 메트릭\n\n- 정확도: 0.9903: 모델이 픽셀 중 약 99.03%를 올바르게 식별합니다.\n- 정밀도: 0.9907: 마스크 일부로 예측된 픽셀 중 약 99.07%가 올바릅니다. 이 높은 정밀도는 모델이 거의 잘못된 양성 오류를 만들지 않음을 나타냅니다.\n- 재현율: 0.9899: 모델이 실제 마스크 픽셀 중 약 98.99%를 올바르게 식별합니다. 이 높은 재현율은 모델이 거의 잘못된 해로운 오류를 만들지 않음을 시사합니다.\n- F1 점수: 0.9903: 정밀도와 재현율의 조화 평균으로, 두 지표 사이의 견고한 균형을 나타냅니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 Markdown 형식으로 변환된 내용입니다.\n\n![예측 시각화](/TIL/assets/img/2024-07-14-TheRevolutionofImageSegmentationExploringU-NetArchitecture_2.png)\n\n## 예측 시각화\n\n- 입력 이미지, 실제 마스크, 예측된 마스크: 이 시각화는 입력 이미지와 이에 해당하는 실제 및 예측된 마스크를 보여줍니다. 예측된 마스크는 실제 마스크와 매우 유사하여, 합성 데이터셋을 분할하는 모델의 효과를 보여줍니다.\n\n## 해석\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nU-Net 모델은 합성 데이터셋에서 뛰어난 성능을 보여주었습니다. 높은 정확도, 정밀도, 재현율 및 F1 점수를 기록했죠. 훈련 및 검증 지표 간의 밀접한 일치는 모델이 잘 일반화되었고 균형있게 설정되었음을 시사합니다. 시각화 결과도 모델이 이미지를 정확하게 분할하고 실제 마스크와 근접하게 일치하는 것을 확인합니다.\n\n이 예시는 이미지 세그멘테이션 작업에 U-Net의 힘을 잘 보여줍니다. 높은 성능 지표와 정확한 분할을 시각적으로 확인함으로써, 심지어 합성 데이터셋에서도 U-Net의 효과를 명확히 확인할 수 있습니다. 이는 정밀한 세그멘테이션이 필요한 생체 의료 영상과 같은 분야에서 U-Net의 응용에 대한 신뢰감을 제공합니다.\n\n# 결론\n\nU-Net은 이미지 세그멘테이션 분야에서 새로운 표준을 세웠습니다. 복잡한 세부사항을 포착하고 정확한 지역화를 제공하는 능력은 다양한 산업에서 필수품이 되었습니다. 기술이 발전함에 따라 U-Net의 원칙은 더욱 정교한 아키텍처를 영감으로 삼아 이미지 분석의 가능성을 확장시킬 것으로 기대됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n정밀도가 모든 차이를 만들 수 있는 세상에서 혁신적인 신경망 설계의 힘을 증명하는 U-Net은 복잡한 분할 도전 과제에 접근하고 해결하는 방법을 변화시키고 있습니다.\n\nU-Net 아키텍처 탐험을 통해 유익한 정보를 얻으셨기를 바랍니다. U-Net 모델이 이미지 분할의 미래에 어떻게 영향을 미칠 것으로 보십니까? 아래 댓글란에 여러분의 생각과 경험을 공유해주세요! 만약 이 글이 마음에 들었다면 꼭 여러분의 네트워크와 공유하지 않으시기 바랍니다.\n\n# 참고문헌","ogImage":{"url":"/TIL/assets/img/2024-07-14-TheRevolutionofImageSegmentationExploringU-NetArchitecture_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-TheRevolutionofImageSegmentationExploringU-NetArchitecture_0.png","tag":["Tech"],"readingTime":11},{"title":"__init__py 파일 제대로 이해하고 사용하기","description":"","date":"2024-07-14 19:53","slug":"2024-07-14-CanYouEven__init__py","content":"\n\n다른 폴더에서 코드를 가져올 때 항상 빈 __init__.py 파일을 넣습니다. 이것은 대부분의 파이썬 개발자들에게 거의 반복적인 습관이 되었습니다 - 초보자든 마법사든. 그러나 우리는 __init__.py에 대해 정말로 알고 있을까요?\n\n이 블로그 포스트에서는 __init__.py가 어떻게 작동하는지와 비어있지 않은 __init__.py가 우리 파이썬 개발자로서 어떻게 도움이 되는지 세 가지 방법을 살펴보겠습니다.\n\n## __init__.py란 무엇인가요?\n\n__init__.py는 폴더를 패키지로 취급해야 한다는 것을 파이썬 해석기에 알려주는 파이썬 파일입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n컴파일된 언어인 C 및 C++과 달리, Python의 인터프리터는 필요한 종속성을 실시간으로 가져옵니다. Python에게 코드를 다른 곳에서 사용할 것이라고 신호를 보내려면 폴더에 __init__.py를 넣으면 됩니다.\n\n그래서 __init__.py를 게이트키퍼로 생각해보세요. 이 파일은 폴더를 가져올 수 있는 Python 패키지로 변환시켜줍니다.\n\n![이미지](/TIL/assets/img/2024-07-14-CanYouEven__init__py_0.png)\n\n하지만 __init__.py는 그 이상입니다. Python에서 클래스를 만들 때 종종 __init__ 함수를 생성해야합니다. 이 함수는 객체가 어떻게 구성되어야 하는지를 정의하며 클래스의 객체가 생성될 때 가장 먼저 실행됩니다. 같은 방식으로, __init__.py는 Python 패키지의 생성자입니다. 패키지가 가져올 때마다 먼저 실행됩니다. 빈 __init__.py는 Python 패키지의 빈 __init__ 생성자 메서드를 의미합니다. 괜찮지만 더 많은 일을 할 수 없다는 뜻은 아닙니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## __init__.py 주의해서 사용하기\n\n__init__.py는 파이썬 패키지의 생성자이므로, __init__.py를 어디에 두는지에 대해 신중해야 합니다.\n\n날짜 형식을 처리하는 몇 가지 사용자 정의 유틸리티 함수가 있는 datetime이라는 폴더가 있다고 가정해봅시다:\n\n```python\n# ./datetime/utils.py\n\ndef increment_date(date: int, increment: int) -\u003e int:\n    \"\"\"밀리초 단위로 타임스탬프 증가\"\"\"\n    return date + increment\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리는 그런 다음 __init__.py를 추가해서 main.py에서 코드를 가져올 수 있도록합니다:\n\n```js\nmyfolder\n│\n├── datetime\n│   ├── __init__.py\n│   └── utils.py\n└── main.py\n```\n\n```js\n# main.py\n\nfrom datetime.utils import increment_date\nfrom datetime import datetime\n\ndef main():\n    timestamp = datetime.timestamp(datetime(2024, 2, 27))\n    print(increment_date(timestamp, increment=10))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n만약 main.py를 실행하면 무엇이 일어날까요?\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nImportError: `datetime` 모듈에서 `datetime`을 가져올 수 없습니다.\n\n보통, Python 인터프리터는 패키지 발견 과정을 (1) 로컬 디렉토리, (2) 표준 라이브러리, 그리고 (3) 설치된 Python 모듈의 순서로 우선시합니다.\n\ndatetime이라는 이름의 폴더에 __init__.py를 넣음으로써, 우리는 datetime이라는 파이썬 표준 라이브러리를 재정의했기 때문에 datetime.datetime을 가져오는 명령문이 실패했습니다.\n\n이 문제를 피하려면 매우 간단한 수정이 필요합니다: 다른 Python 표준 라이브러리나 설치된 Python 모듈과 동일한 이름을 가진 폴더 아래에 __init__.py를 넣지 않도록 항상 주의하십시오.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n__init__.py가 어떻게 작동하는지 이해하면, 이것을 활용하여 할 수 있는 좀 더 멋진 것들을 살펴보겠습니다!\n\n## 1. 패키지 레벨 설정 정의하기\n\n만약 코드 내 모든 Python 파일이 유사한 설정을 공유한다면 어떨까요? 로깅 레벨, 상수, 환경 변수 등. 당신의 패키지 내 모든 Python 파일 상단에 설정을 지정하는 대신, 이를 모두 __init__.py에 포함시킬 수 있습니다.\n\n```python\n# myfolder/__init__.py\n\nimport os\nimport logging\n\n# 패키지 전체의 환경 변수를 로드합니다.\nOPENAI_API_KEY = os.getenv(\"OPENAI_API_KEY\", None)\n\n# 패키지 레벨 상수를 설정합니다.\nMODEL = \"gpt-4\"\n\n# 로깅 구성을 설정할 수도 있습니다.\nlogging.basicConfig(level=logging.INFO)\n\n# 패키지 내에서 편리하게 재사용할 수 있는 사용자 지정 데코레이터를 추가하세요.\ndef foo(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        logging.info(f\"함수 호출 중: {func.__name__}\")\n        result = func(*args, **kwargs)\n        logging.info(f\"함수 {func.__name__} 실행 완료\")\n        return result\n    return wrapper\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n당신의 코드베이스에서는 다음과 같이 할 수 있습니다:\n\n```js\n# myfolder/bar.py\n\n# 패키지 __init__.py에서 상대적인 임포트\nfrom . import OPENAI_API_KEY, MODEL, foo\n\nfrom openai import OpenAI\nfrom typing import Optional\n\nclient = OpenAI()\n\n@foo\ndef chat_with_openai(prompt: str, llm: Optional[str] = None) -\u003e Any:\n    \"\"\"Prompt를 LLM에 보내고 응답을 반환합니다\"\"\"\n    llm = llm or MODEL\n    \n    return client.chat.completions.create(\n              model=llm,\n              messages=[\n                {\"role\": \"system\", \"content\": \"You are a helpful assistant.\"},\n                {\"role\": \"user\", \"content\": prompt}\n              ]\n            )\n```\n\n위 내용에 추가하여 다음과 같은 작업도 가능합니다:\n\n- 기능 플래깅\n- 고급 로거 구성 (예: 모든 로그를 폴더에 저장)\n- 기본 매개변수 설정 (예: 출력 디렉토리가 제공되지 않은 경우 X에 저장)\n- 사용 모니터링 (예: 모든 함수 호출을 클라우드 인스턴스로 보내는 사용자 지정 데코레이터)\n- 테마 사용자 정의/정의 (예: 언어 로캘, 라이트/다크 테마)\n- 사용자 정의 데코레이터로 오류 처리 중앙화\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 2. 패키지 가져오기 단순화\n\n코드베이스가 복잡해지면 더 많은 클래스와 함수를 추가하게 될 것입니다. 코드를 응집된 단위로 분리하는 원칙에 따라, 아래와 같은 구조가 생길 수 있습니다:\n\n```js\nfoo\n│\n├── llm_email_responder\n│   ├── __init__.py\n│   ├── base_email_responder.py\n│   ├── mail_chimp_responder.py\n│   ├── zoho_mail_responder.py\n│   └── send_grid_responder.py\n└── __init__.py\n```\n\nMailChimp에 대한 LLM 이메일 응답기를 사용하려면 다음이 필요합니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nfrom foo.llm_email_responder.mail_chimp_responder import MailChimpResponder\n```\n\n곧 여러 줄의 비슷한 import 문이 생겨나게 되어 코드베이스의 내부 구조를 기억하기 어렵게 만들 수 있습니다. \n\n__init__.py는 import를 정리하고 코드베이스의 더 낮은 수준의 부분을 보호하면서 개발 경험을 단순화하는 데 사용할 수 있습니다.\n\n```js\n# ./foo/llm_email_responder/__init__.py\n\n# 사용자가 더 높은 수준의 구현만큼 자주 사용하지 않을 것으로 예상되므로\n# 가장 낮은 수준의 이메일 응답기는 건너뜁니다.\nfrom .mail_chimp_responder import MailChimpResponder\nfrom .zoho_mail_responder import ZohoResponder\nfrom .send_grid_responder import SendGridResponder\n\n__all__ = [\n    \"MailChimpResponder\",\n    \"ZohoResponder\",\n    \"SendGridResponder\",\n]\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 __init__.py와 함께, 이제 다음과 같이 응답기에 액세스할 수 있습니다:\n\n```js\nfrom foo.llm_email_responder import MailChimpResponder\n```\n\n이것은 개발자 친화적 인터페이스에서 하위 수준의 코드를 노출하는 편리한 방법이지만, 하위 수준 코드베이스에 대한 변경은 반드시 __init__.py의 변경과 일치해야 함으로 유지 보수 노력이 증가할 것입니다. 또한 하위 수준의 코드 베이스를 노출하는 것이 일관된 아키텍처를 형성하는지 여부를 평가해야 합니다.\n\n## 싱글톤 패턴\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n싱글톤 디자인 패턴을 적용하려면 __init__.py를 사용할 수도 있어요. 이렇게 하면 패키지 전체가 __init__.py에서 인스턴스화한 동일한 인스턴스를 사용하도록 강제됩니다.\n\n만약 패키지가 원격 서비스에 연결을 설정하거나 대규모 데이터셋을로드하거나, 무거운 작업을 요구하는 어떤 전제조건이 필요하다면, 이 방법이 아주 편리할 거예요.\n\n예를 들어 금융 보고서를 조작하는 LLM 필요를 처리하기 위해 Gemini Pro에 연결해야 한다고 해보죠.\n\n```js\nfoo\n│\n├── report_analyser\n│   ├── __init__.py\n│   ├── outline_extraction.py\n│   └── entity_extraction.py\n└── __init__.py\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n# .foo/report_analyser/outline_extraction\nfrom langchain_google_vertexai import VertexAI\n\ndef extract_outline(page: str, **kwargs) -\u003e str:\n    llm = VertexAI(\n        model_name=\"gemini-pro\", location=\"europe-west2\", **kwargs\n    )\n    prompt_template = \"\"\"...\u003cYour prompt template here\u003e...\"\"\"\n    prompt = prompt_template.format_prompt(page=page)\n    return llm.invoke(prompt)\n\n\n\n# .foo/report_analyser/entity_extraction\nfrom langchain_google_vertexai import VertexAI\n\ndef extract_entities(page: str, **kwargs) -\u003e str:\n    llm = VertexAI(\n        model_name=\"gemini-pro\", location=\"europe-west2\", **kwargs\n    )\n    prompt_template = \"\"\"...\u003cYour prompt template here\u003e...\"\"\"\n    prompt = prompt_template.format_prompt(page=page)\n    return llm.invoke(prompt)\n\n\n\n# .foo/report_analyser/entity_extraction\nfrom foo.report_analyser.outline_extraction import extract_outline\nfrom foo.report_analyser.entity_extraction import extract_entities\n\ndef main():\n    page = \"Long page of document here\"\n\n    # A connection to VertexAI will be created for\n    # extracting outline\n    outline = extract_outline(page, temperature=0.2)\n\n    # Another connection to VertexAI will be created\n    # for extracting entities\n    entities = extract_entities(page, temperature=0.2)\n\n\n각 작업을 실행할 때마다 코드베이스가 VertexAI와 새로운 연결을 생성하여 불필요한 네트워크 오버헤드가 발생합니다. 만약 Gemini Pro에 대해 동일한 구성을 사용할 계획이라면, 대신 다음을 수행할 수 있습니다:\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# .foo/report_analyser/__init__.py\nfrom langchain_google_vertexai import VertexAI\n\nDEFAULT_LLM = VertexAI(\n    model_name=\"gemini-pro\",\n    location=\"europe-west2\",\n    temperature=0.2,\n)\n```\n\n```js\n# .foo/report_analyser/outline_extraction\nfrom . import DEFAULT_LLM\n\nfrom typing import Dict\n\ndef extract_outline(\n    page: str,\n    custom_llm_parameters: Optional[Dict] = None\n) -\u003e str:\n    \n    if custom_llm_parameters is None:\n        llm = DEFAULT_LLM\n    else:\n        llm = VertexAI(\n            model_name=\"gemini-pro\",\n            location=\"europe-west2\",\n            **custom_llm_parameters\n        )\n    prompt_template = \"\"\"...\u003cYour prompt template here\u003e...\"\"\"\n    prompt = prompt_template.format_prompt(page=page)\n    return llm.invoke(prompt)\n```\n\n코드를 개선하려면, __init__.py에서 LLM 연결을 생성하는 부분을 분리하여 별도의 파일로 만들어 LLM 연결 관리자를 만들 수 있습니다. @lru_cache와 결합하면 사용자 정의 구성을 더 효율적으로 처리하고 있는 것을 알 수 있을 것입니다.\n\n__init__.py에 대해 무엇인지 배우고 더 잘 활용하는 방법에 대한 아이디어를 얻었기를 바랍니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파이썬에 대해 더 알고 싶다면, 파이썬에 관한 다른 블로그를 확인해보세요!\n\n다음에 또 만나요, Louis입니다.","ogImage":{"url":"/TIL/assets/img/2024-07-14-CanYouEven__init__py_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-CanYouEven__init__py_0.png","tag":["Tech"],"readingTime":12},{"title":"삼체 문제의 트리플 별 직렬 현상 물리학 실제로 사람이 행성에서 끌려갈 수 있을까","description":"","date":"2024-07-14 19:52","slug":"2024-07-14-PhysicsoftheTri-SolarSyzygyfromThe3BodyProblemCouldPeopleReallyBePulledOffaPlanet","content":"\n\n\n![Tri-Solar Syzygy](/TIL/assets/img/2024-07-14-PhysicsoftheTri-SolarSyzygyfromThe3BodyProblemCouldPeopleReallyBePulledOffaPlanet_0.png)\n\n영화 예고편에 있는 내용이라면 스포일러가 아닙니다. 제가 말하고 싶은 것은 Trisolaris 행성 주민들이 표면에서 끌려 내려가는 장면을 언급한 것입니다.\n\n여기 중요한 사항들만 알려 드릴게요. Trisolaris라는 행성이 세 개의 태양이 있는 천체계에 있다는 점입니다 (그래서 3-체 문제라고 불립니다). 어느 순간, 사람들 (실제로는 사람이 아니죠)이 행성 표면에서 끌려올라가는 장면이 있는데요. 책에서 이렇게 이야기하고 있어요.\n\n이 부분이 플롯의 현실적인 면에서 옳은지 여부는 사실 중요하지 않아요 — 이겈 이야기이고, 때로는 이야기가 물리 법칙을 따르지 않기도 해요. 그래서 더 재미있는 거죠. 하지만 여전히 이 Tri-Solar Syzygy의 물리학을 살펴볼 거에요 (실은 '시지지'가 무엇인지는 잘 모르겠어요. 이제 물어보기도 부끄러워집니다).\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 3체 문제\n\n만약에 중력 상호작용이 일어나는 두 물체가 있다면 (이렇게 해서 이진 별계에 있는 두 별이 될 수 있어요), 해석적으로 운동 방정식을 풀어낼 수 있어요. 초기 조건을 알고 있다면 두 물체의 미래 위치와 속도를 찾을 수 있는 식을 얻을 수 있어요. 놀랍게도, 이를 2체 문제라고 부를 수 있어요. 만일 더 자세한 유도를 원한다면, 제가 도와드릴 수 있어요.\n\n하지만 만약 서로 상호작용하는 세 물체를 갖고 있다면 어떨까요? 예를 들어, 세 개의 별이 있다고 해 봅시다: 별 1, 별 2, 별 3. 이 경우에는 별 1과 2 사이의 상호작용, 2와 3 사이의 상호작용, 그리고 1과 3 사이의 상호작용이 존재할 거에요. 이는 2체 문제의 좀 더 복잡한 버전일 것 같지만, 이 시스템을 위한 해석적인 해결책은 없어요. (적어도 우리가 아는 바로는) 이를 방정식 형태로 풀 수 있는 방법은 불가능해요.\n\n3체 문제 같은 문제를 해결할 수 있는 한 가지 방법이 있어요 - 수치적인 해법입니다. 아이디어는 운동을 짧은 시간 간격으로 나누는 것이에요. 이 간격 각각에 우리는 모든 중력 힘을 계산하고, 그 짧은 시간 동안에는 이들이 일정하다고 가정할 수 있어요. 일정한 힘을 가질 때, 세 개의 별의 운동량과 위치가 어떻게 변하는지 알 수 있어요. 그 후에는 그냥 다음 시간 간격에 대해 이 프로세스를 반복하기만 하면 돼요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n각 시간 간격 동안의 계산은 비교적 간단합니다 — 하지만 그만큼 많은 계산을 해야 합니다. 누구나 그 모든 계산을 하고 싶어하진 않으니까, 컴퓨터에게 맡기는 게 편합니다 (그나저나 컴퓨터는 크게 불평하지 않아요 — 적어도 지금까진요).\n\n여기 저의 매우 상세한 3체 문제의 수치해법입니다.\n\n# 안정적인 3체 해법\n\n일반적으로, 세 개체의 움직임을 결정하기 위해서는 수치 계산이 필요합니다. 그러나 세 별의 해법을 얻을 수 있는 특별한 상황도 있습니다. 몇 가지 중요한 물리 개념이 있으니, 그 부분부터 알아봅시다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n두 질량 간의 중력 상호작용을 다음 방정식으로 모델링할 수 있습니다:\n\n![equation1](/TIL/assets/img/2024-07-14-PhysicsoftheTri-SolarSyzygyfromThe3BodyProblemCouldPeopleReallyBePulledOffaPlanet_1.png)\n\n여기서 M1과 m2는 벡터 r로 구분된 두 질량입니다. G는 만유인력상수이고 r-hat은 힘이 벡터가 되도록 하는 단위 벡터입니다. 그렇다면 두 개 이상의 질량이 있다면 어떻게 될까요? 그 경우, 총 힘은 각 질량에서 오는 힘의 벡터 합일 뿐입니다.\n\n![equation2](/TIL/assets/img/2024-07-14-PhysicsoftheTri-SolarSyzygyfromThe3BodyProblemCouldPeopleReallyBePulledOffaPlanet_2.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 우리는 원운동에 대해 생각해야 합니다. 삼성계의 가장 간단한 움직임은 원을 그리는 것이겠죠. 물체가 원 안에서 움직이고 있다면, 원의 중심을 향하는 가속도가 발생하며 그 크기는 다음과 같습니다:\n\n![원운동 가속도](/TIL/assets/img/2024-07-14-PhysicsoftheTri-SolarSyzygyfromThe3BodyProblemCouldPeopleReallyBePulledOffaPlanet_3.png)\n\n원운동의 반지름은 r이고 속도는 v입니다. 각속도(ω)의 운동가속도를 계산하는 것도 가능합니다.\n\n자, 이제 우리는 안정된 움직임을 준비했습니다. 세 개의 별이 같은 질량을 가지고 있으며 한 별이 고정되어 있고 다른 두 별이 그 고정된 별 주위를 공전하는 것으로 가정합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image1](/TIL/assets/img/2024-07-14-PhysicsoftheTri-SolarSyzygyfromThe3BodyProblemCouldPeopleReallyBePulledOffaPlanet_4.png)\n\n중간에 있는 별 1에는 두 개의 중력이 작용함을 알 수 있습니다. 그러나 대칭이라면, 별 2와 별 3이 반대 방향으로 같은 힘으로 작용하여 별 1이 정지 상태에 있을 수 있도록 하지요.\n\n별 2를 보면, 왼쪽으로 두 개의 중력이 작용합니다 - 별 1과 별 3에서. 이 순방향 힘은 별 2가 왼쪽으로 가속화되도록 합니다. 이 순방향 힘이 별 2가 원운동 할 수 있도록 만드는 속도(v)를 계산할 수 있게 됩니다. 별 1은 별 2에서 거리 r 떨어져 있지만, 별 3는 2r의 거리에 있습니다.\n\n![image2](/TIL/assets/img/2024-07-14-PhysicsoftheTri-SolarSyzygyfromThe3BodyProblemCouldPeopleReallyBePulledOffaPlanet_5.png)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n태양의 크기 (r)를 알고 있다고 가정해 봅시다. 그러면 별 2의 속도를 구할 수 있습니다 (이는 별 3의 속도가 될 것입니다).\n\n![image](/TIL/assets/img/2024-07-14-PhysicsoftheTri-SolarSyzygyfromThe3BodyProblemCouldPeopleReallyBePulledOffaPlanet_6.png)\n\n이게 실제로 작동할까요? 한 번 시도해 볼 수 있습니다. 세 개의 같은 질량을 가진 태양으로 수치 계산을 해보겠습니다. 중간에 있는 별은 정지 상태에서 시작하고, 나머지 두 개의 별은 계산된 속도로 시작합니다. 그런 다음, 별의 움직임을 모델링하기 위해 수치 계산 방법을 사용할 수 있습니다. 전체 Web VPython 코드는 여기에서 확인할 수 있습니다. 애니메이션은 다음과 같이 보입니다:\n\n![animation](https://miro.medium.com/v2/resize:fit:960/1*RA24sRZkOic5eOCj7FBVzg.gif)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n물론, 중요한 점은 삼합성 시스템이 안정한 궤도에 있지 않다는 것입니다 — 이것이 바로 삼합성의 거주자들이 마주한 문제 중 하나입니다. 그러나 이 책에서는 별들이 어떻게 이러한 배열에 도달하는지 알 수 있습니다.\n\n# 삼합성 행성의 궤도\n\n이제 행성을 추가해보죠. 이로 인해 \"네 체 문제\"가 되지는 않을 것입니다. 행성의 질량은 별들에 비해 매우 작다고 가정할 수 있기 때문입니다. 이는 행성이 별 세 개에게 발생시키는 중력 힘이 그들의 움직임에 별다른 영향을 미치지 않을 것을 뜻합니다. 물론, 4개의 서로 작용하는 물체의 움직임을 쉽게 모델링할 수 있겠지만, 이 가정은 설정을 더 쉽게 만들 것입니다.\n\n행성의 관점에서 볼 때, 세 별은 일직선으로 유지되어야 합니다. 이것은 삼합성이 두 별과 같은 각속도를 가지고 있을 때(가운데 별이 고정일 때) 발생합니다. 다음은 다이어그램입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](/TIL/assets/img/2024-07-14-PhysicsoftheTri-SolarSyzygyfromThe3BodyProblemCouldPeopleReallyBePulledOffaPlanet_7.png)\n\n당연히 이것은 실제 크기로 표현된 것이 아닙니다 (작은 행성은 볼 수 없겠죠). 이 행성에는 세 개의 중력 작용이 있습니다 (세 개의 별로 인한 것입니다). 그에 따라 행성의 가속은 각속도(ω)와 궤도 거리(r_p)에 따라 달라집니다.\n\n이 위치에서 모든 중력은 가속과 같은 방향에 있으므로, 뉴턴의 제2 법칙에 대한 다음 방정식을 작성할 수 있습니다 (참고: 각 별의 질량은 M이고 행성의 질량은 m입니다).\n\n![image](/TIL/assets/img/2024-07-14-PhysicsoftheTri-SolarSyzygyfromThe3BodyProblemCouldPeopleReallyBePulledOffaPlanet_8.png)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n행성의 각 운동 속도는 외부 별 중 하나의 각 운동 속도에서 구할 수 있습니다.\n\n![image](/TIL/assets/img/2024-07-14-PhysicsoftheTri-SolarSyzygyfromThe3BodyProblemCouldPeopleReallyBePulledOffaPlanet_9.png)\n\n이제 행성 트리솔라리스의 공전 거리 (r_p)를 구하는 것은 여전히 어려운 방정식으로 보입니다. 괜찮아요. 실제로 이 방정식을 풀 필요는 없어요. 숫자적 해법을 찾을 수 있으며, r_p의 다른 값에 대해 방정식의 좌변과 우변의 값을 구하여 해의 값을 찾을 수 있어요. 이 두 변을 그래프로 그리면 교차하는 지점이 해를 주는 r_p의 숫자 값이 될 거에요. 한 번 확인해보세요.\n\n![image](/TIL/assets/img/2024-07-14-PhysicsoftheTri-SolarSyzygyfromThe3BodyProblemCouldPeopleReallyBePulledOffaPlanet_10.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n스케일 조정을 해 보면서, 행성 공전 거리를 0.21065 AU로 결정했어요. 그럼, 그걸로 테스트해 볼게요. 여기 4번째 객체를 넣은 3체 문제 계산 결과입니다.\n\n![image](https://miro.medium.com/v2/resize:fit:1000/1*EHiES60H5-45wmU7IZpYDQ.gif)\n\n별의 회전 운동과 대부분 일치하면서 행성이 이동하는 모습을 보실 수 있어요. 애니메이션 끝 쪽에 조금씩 벗어나는데요 — 근데 괜찮아요. 이 삼중태양 허물기는 어차피 영원히 지속되지 않거든요.\n\n# 삼중태양 허물기 모델링\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n사람들이 행성 표면에서 당겨지는 이유가 무엇일까요? 첫 번째 아이디어는 세 개의 별로부터의 중력 힘의 합이 사람들을 당겨내는 중력 힘보다 크다는 것입니다. 이미지를 보세요!\n\n![image](/TIL/assets/img/2024-07-14-PhysicsoftheTri-SolarSyzygyfromThe3BodyProblemCouldPeopleReallyBePulledOffaPlanet_11.png)\n\n좋아요. 우리는 이러한 힘들을 계산할 수 있어요 (일부 가정을 가지고). 지구와 똑같은 행성이라고 가정해 봅시다 (왜냐하면요). 이것은 즉, 사람을 행성으로 당기는 중력 힘이 1킬로그램당 9.8 뉴턴이 될 것이라는 것을 의미해요. 세 개의 별로 인한 순박한 힘으로 인한 순박한 힘의 경우, 1.5 N/kg 정도일 것입니다 - 9.8 N/kg 보다 작아요. 네, 이것이 삼합운 돌아가는 내 특정 값에 대한 값이에요.\n\n그런데 기다려 주세요! 중력 힘의 이 차이로 실제로는 당신이 트리솔라리스의 표면에서 더 가벼워진다는 느낌을 받지 못할 거예요. 왜냐하면요? 그것은 행성이 정지해 있지 않기 때문에 그렇습니다 - 사실 행성은 이미 원형 운동으로 움직이고 있기 때문에 별들 쪽으로 가속하고 있어요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n걱정하지 마세요, 선이 3개인 라인의 누적 효과를 계산할 수 있어요. 하지만 약간의 잡수작을 필요로 할 거예요. 3개의 별과 중력 상호작용은 행성에 힘을 가해 가속시키는데, 이는 행성의 중심에서의 가속임을 명심해야 해요. 표면에 있는 비인간은 행성 중심에서의 가속도 값을 가질 것인데, 별들에 더 가까운 지점에서의 중력 힘을 받게 될 거예요. 네, 조금 복잡한 일이죠.\n\n트리솔라리스 표면의 겉으로 보이는 중력 힘은 행성의 중심에서의 중력장과 표면에서의 차이로 나타날 거예요. 행성의 반지름이 6.3 x 10⁶ 미터인 것으로 가정해봅시다 (지구와 같다 가정). 그 경우, 별들에서 오는 유효한 힘은 1kg 당 0.00074 뉴턴을 향해 당겨주게 될 거예요.\n\n그러니까, 질량이 70kg인 생명체는 보통 686 뉴턴의 무게를 느낄 수 있을 텐데요 — 그러나 세 개의 별이 일렬로 위치할 때 그들은 685.99 뉴턴만 느낄 거예요. 만약 숫자에 좀 미숙하다면, 그것은 무게 차이가 크지 않다는 거죠.\n\n이제 맞추세요! 만약 한 사람 (실제 사람이 아닌)이 행성의 반대편에 있다면, 그들도 역시 겉으로 보이는 무게가 더 낮게 느껴질 거예요. 이 경우에 별들로부터의 중력 힘은 조금 더 낮아지겠지만, 행성의 중심의 가속도는 그들에게 지속적으로 멀어지는 것처럼 보일 거예요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이야기 한 번 더 들려줄게요. 정확히 여러분이 지구에 두 개의 조수가 있는 이유입니다. 그 이유는 달로부터 오는 중력에 의한 가속이 지구의 중심에서 발생하기 때문입니다. 지구의 중심에서의 가속은 지구 표면에서의 달로부터 오는 중력과는 다릅니다. 이러한 차이로 인해 물이 두 군데에서 풍겨져 두 개의 물 축적이 발생하는 것이죠. 여기 지구의 표면 가속과 실제 중력장 사이의 차이를 시각화한 그림이 있어요.\n\n![Earth Visualization](/TIL/assets/img/2024-07-14-PhysicsoftheTri-SolarSyzygyfromThe3BodyProblemCouldPeopleReallyBePulledOffaPlanet_12.png)\n\n만약 이 이미지를 생성하는 과정의 자세한 내용을 보고 싶다면, 전부 제공해 드리겠습니다.\n\n그러면, 여기 주의! \"3체 문제\"는 넷플릭스 쇼로 제작된 책일 뿐이에요. 실제로는 존재하지 않습니다. 물리학이 완벽하진 않아도 괜찮아요. 물론, 행성의 크기나 궤도를 변경하면 효과적인 힘을 더 크게 얻을 수도 있겠지만, 제가 설정한 값들이 합리적으로 보인다고 생각해요.","ogImage":{"url":"/TIL/assets/img/2024-07-14-PhysicsoftheTri-SolarSyzygyfromThe3BodyProblemCouldPeopleReallyBePulledOffaPlanet_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-PhysicsoftheTri-SolarSyzygyfromThe3BodyProblemCouldPeopleReallyBePulledOffaPlanet_0.png","tag":["Tech"],"readingTime":11},{"title":"자동 ARIMA 모델 사용 방법","description":"","date":"2024-07-14 19:49","slug":"2024-07-14-AutomaticARIMA","content":"\n\n자동 모델 선택 및 다단계 예측\n\n![이미지](/TIL/assets/img/2024-07-14-AutomaticARIMA_0.png)\n\nARIMA (AutoRegressive Integrated Moving Average)은 시계열 예측 및 분석에 사용되는 통계 모델입니다. ARIMA의 기원은 1900년대 초반으로 거슬러 올라가며 자기회귀(AR) 모델과 이동평균 (MA) 모델이 별도로 발전됐습니다. 두 모델 모두 현실 시계열 데이터의 복잡한 역학을 포착하기에는 충분하지 않은 것으로 나타납니다. 1960년대에 세 통계학자인 조지 E. P. 박스, 그윌림 M. 젠킨스, 그리고 그레고리 C. 레인절이 \"시계열 분석: 예측과 제어\"라는 책에서 AR과 MA 모델을 공식적으로 통합하여 ARIMA를 만들었습니다.\n\nARIMA는 아마도 가장 잘 알려진 패러다임이지만, 왜 이 \"현대적인\" 시계열 서적에 포함시키는 걸까요? 주된 이유는 AR과 MA가 현대적인 시계열 기술에서 많은 흔적을 남겨주었기 때문입니다. ARIMA에 대한 기본 이해는 다른 복잡한 모델에 걸쳐 활용할 수 있게 해줍니다. 예를 들어, NeuralProphet의 4장에서 AR 모듈을 보았고, 12장과 13장에서는 AR 항목을 감독 학습 모델에서 특징으로 볼 것입니다. 이 책에 ARIMA를 포함한 두 번째 이유는 최근의 코드 개발로 자동 모델 선택과 다단계 예측이 가능해졌기 때문입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 챕터 4: \"튜토리얼 II: 트렌드 + 계절성 + 휴일 및 이벤트 + 자기 회귀(AR) + 지연 회귀자 + 미래 회귀자.\"\n- 챕터 12: \"트리 기반 시계열 예측에 대한 튜토리얼\"\n- 챕터 13: \"다단계 시계열 예측에 대한 튜토리얼.\"\n\n오늘날의 코드 라이브러리를 사용하면 최적의 ARIMA 모델을 선택할 수 있습니다. 표준 ARIMA 학파에서 교육을 받은 경우, 최적의 AR 및 MA 순서를 선택하기위한 규정화된 지침을 외우고 있는 사람도 있을 것입니다. 모델 사양을 결정하기 위해 자동 상관 함수(ACF) 및 부분 자동 상관 함수(PACF)를 사용해야 합니다. 그러나 나는 그런 규정화된 지침을 잊어버리고 그냥 여러 순서의 후보 모델을 만들어 최적의 모델을 선택합니다. 왜 최상의 모델을 선택하기 위해 많은 모델을 생성하지 않을까요? 이러한 이유로, Python의 \"pmdarima\"와 같은 편리한 라이브러리가 있어 최적 사양을 자동화하는 데 도움이 됩니다. 이 장을 \"자동 ARIMA\"라고 제목 지어 이 이점을 강조하고자 합니다. 그래도 이 챕터에서는 차이, ACF 및 PACF의 개념을 다룰 것입니다.\n\n\"statsmodels\"와 \"pmdarima\"와 같은 현대의 코드 라이브러리는 단기 예측이 아닌 다단계 예측을 가능하게 합니다. 이를 수행하기 위해 모델을 재귀적으로 적용하여 예측을 생성하는 방법에 대해 배우게 될 것입니다. 일반적으로 다단계 예측을 생성하는 두 가지 기본 전략이 있습니다: 재귀적 방법과 직접 방법. 우리는 챕터 13 \"다단계 시계열 예측에 대한 튜토리얼\"에서 이를 배울 것입니다. 두 전략은 ARIMA와 lightGBM 또는 XGB와 같은 트리 기반 모델에 채택되어 다단계 예측을 생성합니다.\n\n마지막으로, 많은 사용 사례에서 우리는 점 추정치에 만족하지 않고 예측 구간을 필요로 합니다. 잠재적 불확실성을 평가하기 위해 가능한 값의 범위가 필요합니다. \"pmdarima\"와 \"statsmodels\"는 신뢰 구간을 반환합니다. 반면에, Part II \"확률적 예측을 얻기\"의 5부터 8 챕터에서 예측 구간을 위한 더 많은 기술을 배웠습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 제 5장: 시계열 확률 예측을 위한 몬테카를로 시뮬레이션\n- 제 6장: 시계열 확률 예측을 위한 분위 회귀\n- 제 7장: 시계열 확률 예측을 위한 형식 예측\n- 제 8장: 시계열 확률 예측을 위한 형식화된 분위 회귀\n\n이 글에서는 이론과 실무를 포괄적으로 설명하겠습니다. 실제 데이터를 사용하여 모델 구축과 예측을 안내할 예정이에요. 이미 알고 계신 부분은 건너뛰셔도 괜찮아요. Python 노트북은 여기서 다운로드할 수 있어요. 다룰 주제들은 다음과 같아요:\n\n- ARIMA 모델\n- 차분\n- ACF 사용하여 MA의 차수 제안\n- PACF 사용하여 AR의 차수 제안\n- pmdarima 라이브러리 사용하여 최적 모델 자동 탐색\n- 다단계 예측\n- statsmodels 사용하여 모델을 반복적으로 업데이트\n- SARIMA 모델\n\n먼저 데이터를 불러오겠습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n데이터 전처리\n\n카글의 아보카도 판매 데이터를 사용할 것입니다.\n\n```js\n%matplotlib inline\nfrom matplotlib import pyplot as plt\nimport pandas as pd\nimport numpy as np\n\nfrom google.colab import drive\ndrive.mount('/content/gdrive')\n\npath = '/content/gdrive/My Drive/data/time_series'\ndata = pd.read_csv(path + '/avocado_monthly.csv', index_col='Date')\ndata.sort_values(by='Total Volume', ascending=False)\n```\n\n(A) 그림은 이 데이터셋의 일부를 보여줍니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![그림](/TIL/assets/img/2024-07-14-AutomaticARIMA_1.png)\n\n이 데이터 세트에서는 하나의 일변량 시계열만 사용할 것입니다.\n\n```js\n# '유기농' 및 'TotalUS' 지역인 하나의 시계열만 사용합니다.\ndf = data[(data['type']=='organic') \u0026 (data['region']=='TotalUS')].copy()\ndf = df['Total Volume']\ndf.columns = ['y']\ndf = df[pd.to_datetime(df.index)\u003c=pd.to_datetime('2018-02-01')]\n\n# 일변량 시계열 그래프 그리기\nplt.figure(figsize=(10,4))\nplt.plot(df)\nplt.xlabel(\"날짜\")\nplt.ylabel(\"볼륨\")\nplt.show()\n```\n\n그림 (B)는 일변량 시계열 그래프를 보여줍니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![그림](/TIL/assets/img/2024-07-14-AutomaticARIMA_2.png)\n\n이후에는 80%를 인-타임 훈련 데이터로 사용하고 나머지 20%는 아웃-오브-타임 테스트 데이터로 사용합니다.\n\n```js\n# Train-test-split\ntrain_len = int(df.shape[0] * 0.8)\ntest_len = df.shape[0] - train_len\ntrain, test = df[:train_len], df[train_len:]\nprint(f\"{train_len}개의 훈련 샘플\")\nprint(f\"{df.shape[0] - train_len}개의 테스트 샘플\")\n```\n\n좋아요. 이제 우리는 정의부터 시작합시다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nARIMA 모델들\n\nARIMA는 단변량 시계열 데이터를 사용하여 미래 값을 예측하는 모델 클래스입니다. 이 모델들은 시계열 데이터의 과거 또는 이전 값, 즉 자기 회귀(AR) 항목과 이동 평균(MA) 항목인 이동 예측 오차의 지연된 값들을 사용하여 미래 값을 예측합니다. ARIMA이란 \"자기 회귀-통합-이동 평균\"의 약자로, \"AR\", \"I\", \"MA\"로 구성됩니다. 여기서 ARIMA의 \"I\"는 \"통합(integrated)\"을 의미하며, 이는 시계열 데이터가 안정성을 달성하기 위해 차분된 것을 나타냅니다. 안정적인 시계열 데이터는 시간이 지나도 평균, 분산 및 자기 상관이 일정하므로 모델링하기 쉽습니다. ARIMA(p,d,q) 모델로 수학적으로 표현하면 다음과 같습니다:\n\nMarkdown 형식으로 테이블 태그를 변경하십시오.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![AutomaticARIMA_3](/TIL/assets/img/2024-07-14-AutomaticARIMA_3.png)\n\nARIMA 표기법에 친숙해지기 위해 위 식을 적용해 봅시다.\n\n![AutomaticARIMA_4](/TIL/assets/img/2024-07-14-AutomaticARIMA_4.png)\n\n일반적으로 AR만 또는 MA만, 또는 p와 q가 모두 4 미만이기 때문에 우변에 많은 항이 없습니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n차이화\n\n차이화의 목표는 시계열을 안정적으로 만드는 것입니다. 시계열에서 안정성이란 값의 평균이 시간에 따라 일정하다는 것을 의미합니다. 다시 말해, 안정적인 시계열은 일정한 평균을 갖습니다. 이전 코드는 원래 시계열, 1차 차이화(한 번 차이화), 그리고 2차 차이화(두 번 차이화)를 플롯합니다.\n\n```js\nimport numpy as np, pandas as pd\nfrom statsmodels.graphics.tsaplots import plot_acf, plot_pacf\nfrom statsmodels.tsa.stattools import adfuller\nimport matplotlib.pyplot as plt\nplt.rcParams.update({'figure.figsize':(10,6), 'figure.dpi':100})\nlag_len = 15\nfig, axes = plt.subplots(3, 1, sharex=True)\n\n# Original Series\naxes[0].plot(train.values); axes[0].set_title('Original Series')\n\n# 1st Differencing\naxes[1].plot(train.diff()); axes[1].set_title('1st Order Differencing')\n\n\n# 2nd Differencing\naxes[2].plot(train.diff().diff()); axes[2].set_title('2nd Order Differencing')\n\naxes[0].xaxis.set_major_locator(MultipleLocator(30))\n\nplt.show()\n```\n\n도 (C)는 학습 데이터의 원래 시계열, 1차 차이화, 그리고 2차 차이화에 대한 플롯을 보여줍니다. 1차 및 2차 차이화된 시계열은 안정적입니다. 즉, 모델은 최소한 한 번은 차이화되어야 합니다. 일반적으로 1차 차이화만으로 충분합니다. 안정적인 시계열에 대한 차이화는 여전히 안정적일 것입니다. 1차 차이화가 이미 안정적이라면 2차 차이화를 얻기 위해 과도하게 차이화할 필요가 없습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-AutomaticARIMA_5.png\" /\u003e\n\n이제 ACF를 사용하여 MA(order)를 얻는 방법에 대해 이해해 봅시다.\n\nACF를 사용하여 MA(order)를 제안합니다.\n\n이미 두 변수 간의 상관 계수에 익숙하실 것입니다. 이는 그들의 관계를 측정합니다. -1과 1 사이의 값을 갖습니다. 양의/음의 상관 계수는 두 변수 간에 양의/음의 관계가 있음을 의미합니다. 상관 계수가 1일 경우 완벽한 양의 선형 관계를, 0.0일 경우 변수 간의 선형 관계가 없음을 나타냅니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nACF는 자기상관함수(Autocorrelation Function)의 약자입니다. 이것은 시계열과 그 지연된 버전 간의 상관관계를 측정합니다. ACF는 시계열의 시간 t와 시간 t-k에서의 값들 간의 상관관계로 계산됩니다. 여기서 k는 래그(지연) 번호를 나타냅니다. ACF(k)는 래그 k에서의 자기상관을 나타냅니다. 자기상관을 시각화해봅시다.\n\n```python\nfrom statsmodels.graphics.tsaplots import plot_acf\nplt.rcParams.update({'figure.figsize':(10,6), 'figure.dpi':100})\nlag_len = 15\nfig, axes = plt.subplots(3, 1, sharex=True)\n\n# 원 데이터\nplot_acf(train.values[0:lag_len], ax=axes[0], title = 'ACF - 원 데이터')\n\n# 1차 차분\nplot_acf(train.diff().dropna()[0:lag_len], ax=axes[1], title = 'ACF - 1차 차분')\n\n# 2차 차분\nplot_acf(train.diff().diff().dropna()[0:lag_len], ax=axes[2], title = 'ACF - 2차 차분')\n\nplt.show()\n```\n\n(D) 그림은 자기상관을 보여줍니다. 첫 번째 막대의 상관 계수는 1.0인데, 이는 y_t와 그 자신의 상관관계를 나타냅니다. 파란 영역은 유의수준을 의미합니다. 유의수준을 넘는 막대는 통계적으로 유의미하다는 것을 의미합니다. 보시다시피, 1차 차분 라인에서의 래그 1은 유의미합니다. 이는 모델이 래그 1 항을 포함하고 있으며 1차 차분이 있다는 것을 의미합니다.\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-AutomaticARIMA_6.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 PACF를 배워 봅시다.\n\nPACF를 사용하여 AR의 순서를 제안하세요.\n\nACF는 시계열과 그 이전 시간 단계의 관련성을 측정합니다. 현재 시계열 값이 과거 값들과 얼마나 연관이 있는지를 알려줍니다. 반면 PACF는 시계열과 그 이전 시간 단계의 부분 상관 관계를 측정하며, 해당 시간 단계 이전의 모든 이전 시간 단계 값을 고려한 후의 영향을 고려합니다. 이는 현재 시계열 값과 특정 시간 지연 값 사이의 직접적인 관계가 있는지 여부를 결정하는 데 도움이 됩니다. 특히 (E) 그림에서 PACF 지연 1이 중요하다고 합니다. 이는 유의 수준을 넘어섰기 때문입니다. 지연 2도 중요하다고 판명되었는데, 약간의 노력으로 유의 선을 넘었습니다(파란색 영역).\n\n```python\nfrom statsmodels.graphics.tsaplots import plot_pacf\nplt.rcParams.update({'figure.figsize':(10,6), 'figure.dpi':100})\nlag_len = 15\nfig, axes = plt.subplots(3, 1, sharex=True)\n\n# Original Series\nplot_pacf(train.values[0:lag_len], ax=axes[0], title = 'PACF - Original series')\n\n# 1st Differencing\nplot_pacf(train.diff().dropna()[0:lag_len], ax=axes[1], title = 'PACF - 1st differencing')\n\n# 2nd Differencing\nplot_pacf(train.diff().diff().dropna()[0:lag_len], ax=axes[2], title = 'PACF - 2nd differencing')\n\nplt.show()\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n(E) 그림은 PACF 플롯을 보여줍니다.\n\n![PACF 그림](/TIL/assets/img/2024-07-14-AutomaticARIMA_7.png)\n\n그림 (C), (D), (E)의 차이, ACF 및 PACF는 ARIMA(1, 1, 1)을 제안합니다. 만약 이 진단을 알지 못한다고 가정하더라도, 여전히 auto_ARIMA()를 사용하여 모델 사양의 범위를 찾을 수 있습니다.\n\nauto_ARIMA() 사용하여 최적 모델을 자동으로 탐색하는 방법\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nimport pmdarima as pm\nmodel = pm.auto_arima(train,\n                      d=None,\n                      seasonal=False,\n                      stepwise=True,\n                      suppress_warnings=True,\n                      error_action=\"ignore\",\n                      max_p=None,\n                      max_order=None,\n                      trace=True)\n```\n\n![Automatic ARIMA](/TIL/assets/img/2024-07-14-AutomaticARIMA_8.png)\n\n아카이케 정보 기준(Akaike Information Criterion, AIC) 값은 모델 성능 지표입니다. 이 값은 2 * 모델 파라미터 수 - 2 * 최대 우도(L)입니다. 값이 작을수록 모델이 더 잘 맞는 것을 나타냅니다.\n\n![Automatic ARIMA](/TIL/assets/img/2024-07-14-AutomaticARIMA_9.png)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nFigure(F)에서 가장 낮은 AIC 값은 3,301.526입니다. ARIMA(1, 1, 1)(0, 0, 0)입니다. 계절성 구성요소는 (0, 0, 0)입니다. 계절 차분이 없기 때문에 \"seasonal=False\"로 하이퍼파라미터를 끔 처리했습니다. 나중에 ARIMA에서 다시 활성화할 것입니다.\n\n다중 기간 예측\n\n\"pmdarima\"의 \"predict\" 함수를 사용하면 미래 시점의 기간 수를 지정할 수 있습니다. 미래 시점을 테스트 데이터의 길이로 설정합니다. 그리고 \"return_conf_int = True\"와 \"alpha = 0.05\"로 설정하여 95% 신뢰 수준의 신뢰 구간을 반환합니다.\n\n```js\n# test_len의 길이에 대한 다중 기간 예측 생성\nfcast = model.predict(n_periods=test_len, return_conf_int=True, alpha=0.05)\nforecasts = fcast[0]\nconfidence_intervals = fcast[1]\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n모델의 성능을 평가해 봅시다.\n\n```python\nfrom sklearn.metrics import mean_squared_error, mean_absolute_percentage_error\nprint(f\"MAPE: {mean_absolute_percentage_error(test, forecasts)}\")\n```\n\n평균 절대 백분율 오차는 0.1490595592393948 또는 14.9% 입니다. 다음으로 실제 값과 예측값을 그래프로 그려보겠습니다.\n\n```python\ndef plot_it():\n    fig, ax = plt.subplots(figsize=(12,4))\n\n    # 실제 vs. 예측\n    ax.plot(train, color='blue', label='Training data')\n    ax.plot(test.index, forecasts, color='red', marker='o',\n                label='Predicted')\n    ax.plot(test.index, test, color='green', label='Test data')\n    ax.set_title('아보카도 판매량')\n    ax.set_xlabel('날짜')\n    ax.set_ylabel('양')\n    conf_int = np.asarray(confidence_intervals)\n\n    # 신뢰 구간\n    ax.fill_between(test.index,\n                        conf_int[:, 0], conf_int[:, 1],\n                        alpha=0.9, color='orange',\n                        label=\"신뢰 구간\")\n    # 주요 눈금이 20의 배수인 플롯 생성\n    ax.legend()\n    ax.xaxis.set_major_locator(MultipleLocator(20))\n    plt.show()\n\nplot_it()\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n표 (G)는 학습, 테스트 데이터, 예측값 및 신뢰 구간의 시계열을 제공합니다.\n\n![Figure G](/TIL/assets/img/2024-07-14-AutomaticARIMA_10.png)\n\n표 (G)의 예측 값은 일정 기간 이후에 고정값에 수렴하며 예측 가능성이 있습니다. 인상적으로 보이지 않습니다. 각 반복에서 모델을 업데이트하여 개선할 수 있습니다.\n\n각 반복에서 모델을 업데이트해보세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n각 예측은 예측 시계열에 새로운 관측치를 추가합니다. 모델이 정적인 경우, 예측된 시계열은 최종적으로 직선이 되어 그래프(G)에 표시됩니다. 각 반복에서 추가된 관측치로 모델을 업데이트할 수 있습니다.\n\n우리는 시간 외 시험 기간의 각 반복에서 한 기간을 예측한 후, 새로운 예측을 모델을 업데이트하는 데 사용할 것입니다. \"return_conf_int = True\" 및 \"alpha= 5%\"를 지정하여 95% 신뢰 수준의 예측 구간을 추가할 수 있습니다.\n\n```js\n# https://alkaline-ml.com/pmdarima/modules/generated/pmdarima.arima.ARIMA.html#pmdarima.arima.ARIMA.update\ndef one_period_forecast():\n    fcast = model.predict(n_periods=1, return_conf_int=True, alpha=0.05)\n    # fcast는 두 개의 리스트로 구성됩니다.\n    # 첫 번째 리스트는 예측입니다.\n    forecasts = fcast[0].tolist()\n    # 두 번째 리스트는 신뢰 구간입니다.\n    confidence_intervals = fcast[1]\n    return ( forecasts, \n             np.asarray(confidence_intervals).tolist()[0])\n\nforecasts = []\nconfidence_intervals = []\n\nfor add_obs in test:\n    fc, conf = one_period_forecast()\n    forecasts.append(fc)\n    confidence_intervals.append(conf)\n    # 기존 모델 업데이트\n    model.update(add_obs)\n\nplot_it()\n```\n\n그림 (H)은 예측값이 테스트 값과 더 잘 일치함을 보여줍니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-AutomaticARIMA_11.png\" /\u003e\n\n모델 성능은 어떤가요?\n\n```js\nprint(f\"MAPE: {mean_absolute_percentage_error(test, forecasts)}\")\n```\n\nMAPE는 0.11766234388644323으로, 약 11.7%보다 약간 향상되었습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리 연구를 위한 데이터는 여러 해에 걸친 시계열 데이터이기 때문에 강력한 계절성을 갖고 있다고 의심됩니다. 우리는 Seasonal ARIMA를 사용하여 모델을 완화할 것입니다.\n\nSARIMA 모델\n\nSARIMA 모델은 계절적 시계열 데이터를 다루는 데 특히 설계되었습니다. ARIMA 모델의 비계절적 구성요소 (AR, I 및 MA)에 추가로 SARIMA 모델에는 데이터의 계절적 패턴을 포착하는 계절적 구성요소 (SAR, SI 및 SMA)가 포함되어 있습니다. SARIMA 모델의 SAR 구성요소는 ARIMA 모델의 AR 구성요소와 유사하지만 시계열의 계절적 지연된 값에 작용합니다. SI 구성요소는 ARIMA 모델의 I 구성요소와 유사하지만 시계열의 계절적 차이에 적용됩니다. 마지막으로, SMA 구성요소는 ARIMA 모델의 MA 구성요소와 유사하지만 시계열의 계절적 지연된 오차에 작용합니다.\n\n요약하자면, SARIMA는 단순히 계절 급변을 적용합니다. 계절적 급변은 일반적인 급변과 유사합니다. 연이은 용어를 빼는 대신, 계절적 급변은 이전 계절의 값에서 값을 뺍니다. SARIMA 모델은 일반적으로 SARIMA(p,d,q)(P,D,Q)[S]로 표기됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- p은 계절적 자기회귀항의 차수를 나타냅니다.\n- q는 계절적 이동평균항의 차수를 나타냅니다.\n- Q는 계절적 차분의 차수를 나타냅니다.\n- S는 12개월과 같은 계절 사이클을 나타냅니다.\n\n계절 ARIMA 모델은 데이터의 계절 패턴을 포착하기 위해 추가 매개변수를 통합합니다. 다음 구성 요소를 추가합니다:\n\n- 계절적 AR 항: 이러한 항목은 현재 관측치와 계절 간격의 특정 차이 관측치 사이의 관계를 나타냅니다. 데이터의 계절적 패턴을 캡처합니다.\n- 계절적 MA 항: 이러한 항목은 현재 관측치와 계절 간격의 특정 기간의 선행 예측 오류 사이의 관계를 나타냅니다. 데이터의 계절적 변동성을 캡처합니다.\n\nSARIMA 모델링은 매우 쉽습니다. 해야 할 일은 하이퍼파라미터 \"seasonal\"을 \"True\"로 변경하는 것뿐입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nimport pmdarima as pm\nmodel = pm.auto_arima(train,\n                      # You just need to turn the seasonal to \"True\"\n                      seasonal=True,\n                      start_P=1,\n                      start_q=1,\n                      max_p=None,\n                      max_q=None,\n                      m=12,\n                      d=1,\n                      D=1,\n                      trace=True,\n                      error_action='ignore',\n                      suppress_warnings=True,\n                      stepwise=True)\nmodel.summary()\r\n```\n\n한 가지 모델을 만들었어요. 그림 (I)은 최적의 모델이 ARIMA(0,1,1)(0,1,1)[12]임을 보여줍니다.\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-AutomaticARIMA_12.png\" /\u003e\n\n결과를 그래픽으로 표시하고 각 반복마다 모델 업데이트를 활성화해봅시다. 그림 (J)에 플롯이 표시됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nforecasts = []\nconfidence_intervals = []\n\nfor add_obs in test:\n    fc, conf = one_period_forecast()\n    forecasts.append(fc)\n    confidence_intervals.append(conf)\n    # Updates the existing model\n    model.update(add_obs)\n\n# Plot the results\nplot_it()\n\n# Calculate MAPE\nprint(f\"MAPE: {mean_absolute_percentage_error(test, forecasts)}\")\n```\n\nMAPE는 0.11918293096560012 또는 11.9%입니다. 이것은 위의 ARIMA 모델에 비해 뚜렷한 개선이 없어 보입니다. 모델의 간결성 원칙에 따라, 우리는 SARIMA 대신 ARIMA 모델을 사용할 것입니다.\n\n![이미지](/TIL/assets/img/2024-07-14-AutomaticARIMA_13.png)\n\n결론\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 게시물에서는 고전적인 ARIMA 및 SARIMA 모델 사양을 검토했습니다. 최적 모델을 자동으로 검색하기 위해 pmdarima 라이브러리의 사용법을 배웠습니다. 또한 ARIMA 및 SARIMA에 대한 다기간 예측 생성 방법을 배웠습니다.\n\n우리는 복잡성이 증가하는 시계열 데이터를 모델링할 것입니다. 여러 Python 라이브러리가 복잡한 데이터 구조에 대한 해결책을 제공합니다. 우리는 이러한 데이터 솔루션을 10장에서 배울 것입니다: 시계열 데이터 형식 변환의 비밀.\n\n참고문헌\n\n- [1] Box, G. E. P., Jenkins, G. M., and Reinsel, G. C. (2015). 시계열 분석: 예측 및 제어 (5판). John Wiley \u0026 Sons.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n샘플 eBook 챕터(무료): [여기](https://github.com/dataman-git/modern-time-series/blob/main/20240522beauty_TOC.pdf)\n\n- 아름다운 형식으로 책을 재현하고 즐거운 독서 경험을 제공하기 위해 The Innovation Press, LLC 직원 여러분께 감사드립니다. 우리는 Teachable 플랫폼을 선택하여 전 세계 독자들에게 번거로운 과부하 없이 eBook을 유통합니다. 신용 카드 거래는 Teachable.com이 안전하고 기밀리에 처리합니다.\n\nTeachable.com의 eBook: $22.50\n[여기](https://drdataman.teachable.com/p/home)\n\nAmazon.com에서 인쇄판: $65 [링크](https://a.co/d/25FVsMx)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 프린트 버전은 윤광 처리 커버, 컬러 인쇄, 아름다운 스프링어 글꼴 및 레이아웃을 채택하여 즐거운 독서 경험을 제공합니다. 7.5 x 9.25인치의 품격 높은 크기는 서재에 있는 대부분의 책과 어울립니다.\n- \"이 책은 Kuo의 시계열 분석에 대한 깊은 이해와 예측 분석 및 이상 탐지에 대한 응용을 증명하는 것입니다. 이 책은 독자들이 실제 세계의 문제에 대처하기 위한 필수적인 기술을 제공합니다. 데이터 과학 분야로의 직업 전환을 고려하는 사람들에게 특히 가치 있는 자료입니다. Kuo는 전통적인 기술 뿐만 아니라 최신 기술에 대해 자세히 탐구합니다. Kuo는 신경망 및 다른 고급 알고리즘에 대한 논의를 통합하여, 분야의 최신 동향과 발전을 반영합니다. 이는 독자가 확립된 방법뿐만 아니라 데이터 과학 분야에서 가장 현재이고 혁신적인 기술을 다루는 데 대비할 수 있도록 보장합니다. Kuo의 생생한 글쓰기 스타일로 책의 명료함과 접근성은 높아졌습니다. 그는 복잡한 수학 및 통계 개념을 신비롭지 않게 만들면서도 엄격성을 희생하지 않았습니다.\"\n\n# 현대적인 시계열 예측: 예측 분석 및 이상 탐지를 위한\n\n제로 장: 서문\n\n1장: 소개\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 장 2: 비즈니스 예측을 위한 선지자\n\n# 장 3: 튜토리얼 I: 트렌드 + 계절성 + 휴일 및 이벤트\n\n# 장 4: 튜토리얼 II: 트렌드 + 계절성 + 휴일 및 이벤트 + 자기회귀(AR) + 지연 회귀자 + 미래 회귀자\n\n# 장 5: 시계열 데이터의 변화점 탐지\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nChapter 6: 시계열 확률 예측을 위한 몬테카를로 시뮬레이션\n\nChapter 7: 시계열 확률 예측을 위한 분위 회귀\n\nChapter 8: 시계열 확률 예측을 위한 일치 예측\n\nChapter 9: 시계열 확률 예측을 위한 일치화된 분위 회귀\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 제 10장: 자동 ARIMA!\n\n# 제 11장: 시계열 데이터 형식 쉽게 만들기\n\n# 제 12장: 다기간 확률 예측을 위한 선형 회귀\n\n# 제 13장: 트리 기반 시계열 모델을 위한 피처 엔지니어링\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 14장: 다기간 시계열 예측을 위한 두 가지 기본 전략\n\n# 15장: 다기간 시계열 확률적 예측을 위한 Tree 기반 XGB, LightGBM 및 CatBoost 모델\n\n# 16장: 시계열 모델링 기술의 진화\n\n# 17장: 시계열 확률적 예측을 위한 Deep Learning 기반 DeepAR\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nChapter 18: 주가에 대한 확률적 예측을 위한 응용\n\nChapter 19: RNN부터 Transformer 기반 시계열 모델까지\n\nChapter 20: 해석 가능한 시계열 예측을 위한 Temporal Fusion Transformer\n\nChapter 21: 시계열 예측을 위한 오픈소스 Lag-Llama 튜토리얼","ogImage":{"url":"/TIL/assets/img/2024-07-14-AutomaticARIMA_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-AutomaticARIMA_0.png","tag":["Tech"],"readingTime":25},{"title":"시니어 개발자들이 프로그래밍 도전을 해결하는 방법 비밀 코드 정복기","description":"","date":"2024-07-14 19:47","slug":"2024-07-14-CrackingtheCodeHowSeniorDevsTackleProgrammingChallenges","content":"\n\n\n![Image](/TIL/assets/img/2024-07-14-CrackingtheCodeHowSeniorDevsTackleProgrammingChallenges_0.png)\n\n프로그래밍은 대단히 어려운 작업이며, 특정 사람들에게는 당연한 것처럼 보일 수 있습니다. 의심하는 사람들이 \"아니, 프로그래밍이 어렵다고? 다음은 뭔가, 하늘은 파란색이라고?\"\n\n이 비꼼은 경험 많은 개발자에게 프로그래밍의 어려움이 자명함을 강조합니다. 그러나 초보자들은 종종 프로그래밍이 쉽다고 생각합니다.\n\n# 프로그래밍의 현실\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n놀랍게도, 코딩을 하는 것이 프로그래밍 중에서 가장 어려운 부분은 아닙니다. 표면적으로 보면 프로그래밍은 간단해 보일 수 있지만, 컴퓨터가 이해할 수 있는 코드를 작성하는 것이랍니다.\n\n하지만, 현실은 훨씬 더 복잡해요. 프로그래밍은 논리적 사고, 문제 해결 능력, 그리고 다루고 있는 문제와 도구에 대한 심층적인 이해를 필요로 합니다.\n\n# 프로그래밍 마인드셋의 중요성\n\n많은 초보자들은 프로그래밍의 핵심 부분을 배워야 합니다: 마인드셋입니다. 개발자처럼 생각하는 것이, 특히 초보자들에겐 프로그래밍을 어렵게 만드는 이유입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n코드를 작성하는 것 뿐만 아니라 문제해결 방식에 대해서도 중요해요. 일주일만에 JavaScript를 배운다는 것은 가능해 보일 수 있지만, 내부에 숨어있는 사회불안증(imposter syndrome), 늦은 밤 코딩 세션, 포기하고 싶은 순간들은 언급되지 않죠.\n\n이러한 경험들은 튜토리얼이나 책에서 소개되는 것이 아니라, 실제로 체험해봐야 합니다.\n\n# 프로그래밍에서의 개발자 마인드셋\n\n# 요리 비유\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n개발자의 마인드셋을 이해하려면, 레시피를 암기해서 요리를 배우는 것을 상상해보세요. 케이크를 만들려면 밀가루, 설탕, 계란, 버터가 필요하다는 것을 알 수 있을 거예요.\n\n레시피를 따라하면 꽤 괜찮은 케이크를 굽을 수 있어요. 그런데 만약 재료가 부족하다면 어떻게 할까요? 또는 다른 무언가를 굽도록 요청받았을 때 어떡할까요? 왜냐하면 상대방이 케이크를 싫어한다고 하면 말이에요.\n\n레시피만 암기한 상태라면 해매일지도 모릅니다. 마찬가지로, Python이나 JavaScript와 같은 프로그래밍 언어를 알아간다는 것도 레시피를 암기하는 것과 비슷합니다.\n\n모든 문법을 알아도, 더 중요한 질문은: 어떻게 효과적으로 활용할 수 있는지 아는지인 거죠?\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 예시: 프로그래밍에서 평균 계산하기\n\n다음 예시를 살펴보세요: 변수, 반복문, 그리고 리스트가 어떻게 동작하는지 배웠습니다. 숫자들의 리스트를 생성하고 for 루프를 사용하여 각 숫자를 출력할 수 있습니다.\n\n이제 이 숫자들의 평균을 찾아야하지만 sum 함수를 사용하지 않습니다. 이를 위해서는 sum 함수가 하는 일을 이해해야 합니다: 모든 요소를 모두 더합니다.\n\n튜토리얼에서 얻는 기본 지식을 활용하여 for 루프를 사용하여 리스트를 순회하고 필요한 산술 연산을 수행할 수 있습니다. 이 예시는 튜토리얼이 기본을 가르쳐주지만 문제를 해결하기 위해 창의적으로 적용해야 함을 보여줍니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 프로그래밍의 진정한 도전\n\n# 프로그래밍에서의 문제 해결과 논리적 사고\n\n프로그래밍의 진정한 도전은 문제 해결과 논리적 사고에 있습니다. 코딩하는 법을 알기만 하는 것이 아니라 무엇을 코딩할지도 아는 것입니다.\n\n새로운 기능을 개발하거나 버그를 수정하려면 그것을 더 작고 관리하기 쉬운 조각들로 나누어 각 부분을 체계적으로 해결해야 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 기술은 실제로 가르쳐 주기 어려울 뿐만 아니라 자신으로 찾아내야 합니다.\n\n# 프로그래밍의 고통\n\n![이미지](/TIL/assets/img/2024-07-14-CrackingtheCodeHowSeniorDevsTackleProgrammingChallenges_1.png)\n\n많은 사람들이 '튜토리얼 지옥'에 갇혀 계속해서 튜토리얼을 보고 수많은 예시를 따라하지만 새롭고 독특한 문제를 해결하지 못하는 상황에 빠지곤 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n프로그래밍의 학습 곡선은 가파릅니다. 튜토리얼과 실무 경험을 균형있게 조합해야하기 때문이죠. 튜토리얼은 자전거 지지 바와 같아요. 결국 필요 없어질 거예요.\n\n진정한 학습은 배운 것을 다양한 상황에 적용하기 시작할 때 시작됩니다.\n\n# 프로그래머의 마인드셋을 갖추는 팁\n\n# 1. 프로그래밍 문제 분해하기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n프로그래밍 문제를 작은 관리 가능한 작업으로 나누어 시작해보세요. 이 방법을 사용하면 가장 어려운 문제조차 접근 가능해 보이고 명확한 시작점을 제공받게 될 거예요.\n\n예를 들어, 리스트에서 가장 많이 나타나는 상위 세 개의 단어를 추적하고 표시하는 프로그램을 작성해야 한다면 다음과 같이 나눠보세요:\n\n- 먼저, 리스트를 살펴보세요.\n- 그 다음, 각 단어의 빈도수를 세어보세요.\n- 마지막으로, 상위 세 개의 가장 많이 나타나는 단어를 결정하세요.\n\n# 2. 프로젝트 기반 학습에서의 프로그래밍\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n프로그래밍의 프로젝트 기반 학습(PBL)은 기술 향상과 문제 해결 능력 향상에 중요합니다.\n\n실전 프로젝트를 통해 이론적 지식을 실제 응용에 적용하여 심층적인 이해와 실무 전문성을 키울 수 있습니다. 이 반복적인 과정은 프로그래밍 능력을 향상시키는 것뿐만 아니라 개발자에게 필수적인 비판적 사고와 창의성을 육성하는 데 도움이 됩니다.\n\n각 완료된 프로젝트는 포트폴리오에 기여하여 여러분의 역량을 과시하고 잠재적인 고용주들에게 매력을 늘려줍니다.\n\n이 접근 방식은 여러분의 기술을 향상시키는 것뿐만 아니라 취업 기회를 열어줍니다. 왜냐하면 고용주들은 실무 경험을 입증한 후보자와 성공적인 프로젝트 완료 이력이 있는 지원자를 가치 있게 여기기 때문입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 3. 프로그래밍을 위한 파인만 기법\n\n이 기법은 당신이 개념을 정말로 이해했다고 할 수 있는 것은 그것을 간단한 용어로 설명할 수 있는 경우에만 가능하다는 아이디어에 기반을 두고 있습니다.\n\n이 기법은 복잡한 프로그래밍 개념을 기초적인 부분으로 나누어야 한다는 것을 강요하여 당신이 이해한 것과 더 많은 공부가 필요한 부분을 드러내게 합니다.\n\n어떤 사람에게 개념을 가르치거나 설명하거나, 혹은 혼자 소리 내어 스스로에게 설명하는 것은 당신의 이해를 확고하게 하고 보다 더 기억력을 향상시킵니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 4. 프로그래밍에서 실패를 수용하세요\n\n프로그래밍에서는 실패를 학습 과정의 일부로 받아들이는 것이 중요합니다. 만난 모든 오류와 버그는 소중한 교훈을 제공하며 문제 해결 능력을 향상시키고 이해를 깊이 있게 합니다.\n\n이러한 저하를 수용함으로써 탄력성을 육성하고 개선에 대한 적극적인 접근 방식을 취할 수 있습니다.\n\n실패를 분석함으로써 개발자들은 코딩 관행을 개선하고 향후 동일한 문제가 발생하는 것을 방지하는 통찰을 얻을 수 있습니다. 이러한 마음가짐 변화는 프로그래밍 노력에서 지속적인 성장과 혁신을 촉진합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 5. 프로그래밍을 꾸준히 연습하세요\n\n연습을 꾸준히 이어나가세요. 한 번에 1시간 이상 같은 주제나 프로젝트에 집중하는 것이 좋습니다. 짧은 연습 시간은 작은 문제에 유용할 수 있지만, 보다 깊은 이해를 위해서는 더 오래 집중해야 합니다.\n\n# 6. 다른 사람과 자신을 비교하지 마세요\n\n자신을 비교해야 하는 유일한 상대는 바로 여러분 자신입니다. 작은 성과라도 축하하세요. 한 가지 자습서를 완료했거나 버그를 해결했다면 축하해야 합니다. 각자가 자신의 속도로 진전하기 때문에, 특히 여러 해의 경험을 가진 사람들과 비교하는 것은 역효과적입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 팁을 따라가고 계속 도전함으로써, 당신은 성공한 프로그래머가 되기 위해 필요한 마인드를 개발할 수 있을 것입니다. 앞으로 나아가며 계속 배우고, 필요할 때 프로그래밍 커뮤니티에서 도움을 요청하는 것을 주저하지 마세요. 즐거운 코딩하세요!\n\n이 글이 마음에 들었다면 👏 를 클릭해주세요! 제 계정을 팔로우해주시면 감사하겠습니다! 즐겨 보는 부분을 강조하셔도 됩니다. 여러분의 참여가 제 영감입니다!","ogImage":{"url":"/TIL/assets/img/2024-07-14-CrackingtheCodeHowSeniorDevsTackleProgrammingChallenges_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-CrackingtheCodeHowSeniorDevsTackleProgrammingChallenges_0.png","tag":["Tech"],"readingTime":8},{"title":"소비자용 그래픽 카드 하나로 LLMs 미세 조정하는 방법","description":"","date":"2024-07-14 19:45","slug":"2024-07-14-FineTuningLLMsonaSingleConsumerGraphicCard","content":"\n\n## 생성적 AI\n\n![이미지](/TIL/assets/img/2024-07-14-FineTuningLLMsonaSingleConsumerGraphicCard_0.png)\n\n# 배경\n\n대형 언어 모델 또는 다른 생성 모델을 생각할 때, 먼저 떠오르는 하드웨어는 GPU입니다. GPU 없이는 생성적 AI, 기계 학습, 심층 학습, 데이터 과학 등의 많은 발전이 불가능했을 것입니다. 15년 전, 게이머들이 최신 GPU 기술에 열광했다면, 오늘날 데이터 과학자와 기계 학습 엔지니어들도 이 분야의 소식을 따라가며 함께 관심을 가지고 있습니다. 보통 게이머들과 기계 학습 사용자는 서로 다른 종류의 GPU와 그래픽 카드를 사용한다고 볼 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n게임 사용자들은 일반적으로 소비자용 그래픽 카드(예: NVIDIA GeForce RTX 시리즈 GPU)를 사용하고, ML 및 AI 개발자들은 주로 데이터 센터 및 클라우드 컴퓨팅 GPU(예: V100, A100 또는 H100)에 대한 뉴스를 따릅니다. 게임 그래픽 카드는 일반적으로 GPU 메모리가 훨씬 적습니다(2024년 1월 기준 최대 24GB). 반면 데이터 센터 GPU는 일반적으로 40GB에서 80GB 정도의 범위에 있습니다. 또한 가격도 다른 중요한 차이점입니다. 대부분의 소비자용 그래픽 카드의 가격이 최대 3000달러가 될 수 있는 반면, 대부분의 데이터 센터 그래픽 카드는 그 가격부터 시작하여 수십만 달러까지 쉽게 올라갈 수 있습니다.\n\n저를 포함한 많은 사람들이 그래픽 카드를 게임이나 일상적인 용도로 사용할 수 있기 때문에, 같은 그래픽 카드를 사용하여 LLM 모델의 학습, 미세 조정 또는 추론에 사용할 수 있는지 궁금할 수 있습니다. 2020년에 저는 소비자용 그래픽 카드를 데이터 과학 프로젝트에 사용할 수 있는지에 대해 포괄적인 기사를 썼습니다. 당시에는 대부분 작은 ML이나 딥 러닝 모델이었고, 6GB 메모리를 가진 그래픽 카드라도 많은 학습 프로젝트를 처리할 수 있었습니다. 그러나 본 기사에서는 수십억 개의 매개변수를 가진 대형 언어 모델에 이러한 그래픽 카드를 사용할 것입니다.\n\n본 기사에서는 24GB GPU 메모리를 가진 GeForce 3090 RTX 카드를 사용했습니다. 참고로, A100 및 H100과 같은 데이터 센터 그래픽 카드는 각각 40GB 및 80GB의 메모리를 가지고 있습니다. 또한 전형적인 AWS EC2 p4d.24xlarge 인스턴스는 총 320GB의 GPU 메모리를 가진 8개의 GPU(V100)를 가지고 있습니다. 간단한 소비자용 GPU와 전형적인 클라우드 ML 인스턴스 간의 차이가 상당히 크다는 것을 보실 수 있습니다. 그러나 질문은, 우리가 단일 소비자용 그래픽 카드에서 대형 모델을 학습할 수 있는지 여부인데요? 가능하다면, 팁과 교훈은 무엇인가요? 이 기사의 나머지 부분을 읽어보세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아무런 LLM 모델이나 교육 데이터 집합을로드하기 전에 그러한 프로세스에 필요한 하드웨어 및 소프트웨어를 찾아야합니다.\n\n언급한 바와 같이, 나는 소비자 GPU 중에서도 가장 높은 메모리(24GB) 중 하나를 갖고 있는 NVIDIA GeForce RTX 3090 GPU를 사용했습니다(참고로, 4090 모델도 동일한 메모리 크기를 가지고 있습니다). 이 GPU는 유명한 A100 GPU에 있는 것과 동일한 Ampere 아키텍처를 기반으로 하고 있습니다. GeForce RTX 3090 GPU 사양에 대해 더 자세히 알아볼 수 있습니다.\n\n모든 테스트를 거친 후, 24GB가 10억 개의 매개변수를 갖는 LLM과 작업을 수행하는 데 필요한 최소한의 GPU 메모리라고 생각합니다.\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-FineTuningLLMsonaSingleConsumerGraphicCard_1.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그래픽 카드 외에도 PC의 좋은 환기 시스템이 필요합니다. 세밀한 조정 중에 GPU의 온도가 쉽게 올라가고 팬으로는 충분히 식힐 수 없는 경우가 있습니다. 높은 GPU 온도는 GPU 성능을 낮출 수 있고, 처리 시간이 더 오래 걸릴 수 있습니다.\n\n하드웨어 외에도 여기서 언급해야 할 몇 가지 소프트웨어 고려 사항이 있습니다. 먼저, Windows 사용자라면 안타깝게도 나쁜 소식이 있어요. 일부 라이브러리와 도구는 Linux에서만 작동합니다. 특히, 모델 양자화에 자주 사용되는 bitsandbytes는 Windows 친화적이지 않습니다. 어떤 사람들은 Windows용 래퍼를 만들었지만 (예를 들어 여기), 그들은 장단점이 있어요. 그래서 제 추천은 WSL에 Linux를 설치하거나 저와 같이 듀얼 부팅 시스템을 사용하여 LLM 작업 중에 완전히 Linux로 전환하는 것입니다.\n\n또한, PyTorch와 호환되는 CUDA 버전을 설치해야 합니다. 제 추천은 CUDA 12.3을 설치하는 것입니다 (링크). 그런 다음 이 페이지로 이동하여 시스템, CUDA 버전 및 패키지 관리자 시스템에 따라 올바른 PyTorch를 다운로드하고 설치해야 합니다 (https://pytorch.org/).\n\n```js\nexport BNB_CUDA_VERSION=123\nexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/\u003cYOUR-USER-DIR\u003e/local/cuda-12.3\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마지막으로 시스템에 다음 패키지를 설치해야 합니다. 충돌을 피하기 위해 시스템에 이미 설치된 다른 패키지와 충돌을 피하기 위해 새 가상 환경(venv)을 만드는 것을 권장합니다. 또한, 아래는 제가 성공적으로 사용한 패키지 버전들입니다:\n\n```js\ntorch==2.1.2\ntransformers==4.36.2\ndatasests==2.16.1\nbitsandbytes==0.42.0\npeft==0.7.1\n```\n\n# 기술적 배경\n\n이제 시스템에서 LLMs를 사용하기 위해 모든 하드웨어와 소프트웨어를 준비했으니, 다음 섹션에서 마주할 기술적 개념에 대해 매우 간단히 검토하는 것이 좋습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n대형 언어 모델은 수백만 또는 수십억 개의 매개변수로 구성됩니다. 일반적으로 수십억 또는 때로는 수조의 토큰으로 훈련된 사전 훈련된 모델을 사용하는데 굉장히 긴 훈련 과정과 수백만 달러가 들었습니다. 이러한 모델 매개변수 각각은 32비트(4바이트)의 메모리를 차지하고 로드하기 위해 필요합니다. 일반적으로 10억 개의 매개변수당 약 4GB의 메모리가 필요하다고 생각할 수 있습니다. 로드(및 이후 추론 또는 후속 모델 훈련)를 위해 메모리 사용량을 줄이는 한 가지 기술은 \"양자화\"입니다. 이 기술에서는 모델 가중치의 정밀도를 32비트의 완전 정밀도에서 16비트(fp16 또는 bfloat16), 8비트(int8) 또는 그 이하로 줄입니다.\n\n모델 가중치의 정밀도를 줄이면 제한적인 메모리에 더 큰 모델을 로드할 수 있지만 모델 성능을 희생해야 합니다. 그러나 일부 연구에서는 fp32와 bfloat16 간의 모델 성능 차이가 중요하지 않다고 제안하며, 많은 유명한 모델(Llama2 포함)이 bfloat16로 사전 훈련되었습니다.\n\n양자화는 단일 GPU에서 메모리가 24GB인 대형 언어 모델을 세밀하게 조정하거나 추론할 때 반드시 사용해야 하는 기술입니다. 나중에 볼 것처럼 bitsandbytes 라이브러리를 사용하여 모델 양자화를 구현할 수 있습니다.\n\n가장 엄격한 양자화 기술을 사용하더라도 수십억 개의 매개변수를 가진 작은 크기의 LLM 모델을 사전 훈련할 수 없습니다. 크리스 프레글리 등은 최근 발표된 'AWS에서의 생성적 AI' 도서에서 모델 훈련에 필요한 메모리에 대한 좋은 규칙을 설명했습니다. 그들은 모델의 10억 개의 매개변수당 16비트 반 정밀도에서 6GB의 메모리가 필요하다고 설명했죠.\n\n기억해야 할 것은 메모리 크기가 훈련 이야기의 일부일 뿐이라는 점입니다. 사전 훈련을 완료하는 데 필요한 시간도 또 하나의 중요한 측면입니다. 예를 들어 가장 작은 Llama2 모델인 Llama2 7B는 70억 개의 매개변수를 가지고 훈련을 완료하는 데 184320 GPU 시간이 걸렸습니다.\n\n그래서 대부분의 사람들(상당한 하드웨어 자원과 예산을 갖춘 사람들도)는 특정 사용 사례에 맞게 사전 훈련된 모델을 사용하고 세밀하게 조정하려는 경향이 있습니다. 그러나 한정된 자원(예: 단일 GPU)으로 완전한 세밀 조정을 수행하는 것은 다소 어려울 수 있습니다. 이에 따라 모델 매개변수의 한정된 부분만 업데이트하는 \"효율적인 매개 조정\" (PEFT) 이 보다 현실적으로 보입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다양한 PEFT 기술 중에서, LoRA (Low Ranking Adaption)는 그 계산 효율성으로 매우 인기가 높습니다. 이 기술에서는 원래 모델의 가중치를 모두 고정시키고 대신 Transformer 아키텍처의 특정 레이어에 추가할 수 있는 저랭크 행렬을 학습합니다. LLM을 세세히 조정할 때 LoRA를 사용하는 경우, 모델 가중치의 0.5%를 업데이트합니다.\n\nQLoRA는 저랭크 행렬 LoRA에 우리가 설명한 양자화 개념을 결합한 변형입니다. 특히, QLoRA 구현에서는 모델을 세세히 조정하기 위해 nf4 또는 Normal Float 4를 사용할 것입니다. QLoRA는 단일 소비자 GPU로 대규모 모델을 세세히 조정하는 경우 연구 사례에서 매우 유용합니다.\n\n# 코딩 타임\n\n마지막으로, 이제 코딩할 시간입니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n내 GitHub 리포지토리에서 작동하는 주피터 노트북을 찾을 수 있어요. 이 코드의 많은 부분은 Mathieu Busquet의 깔끔한 글에서 영감을 받아 따랐어요.\n\n코드를 한 줄씩 설명하지는 않겠지만, 단일 GPU에서 대규모 모델을 세밀하게 조정하는 데 중요한 부분을 강조할 거에요.\n\n## 트랜스포머 모델\n\n우선, 이 테스트에 Mistral 7B 모델(mistralai/Mistral-7B-v0.1)을 선택했어요. Mistral AI가 개발한 Mistral 7B 모델은 2023년 9월에 공개된 오픈 소스 LLM이에요 (논문 링크). 많은 측면에서 이 모델은 Llama2와 같은 유명한 모델들을 능가해요 (다음 차트를 참고하세요).\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-FineTuningLLMsonaSingleConsumerGraphicCard_2.png\" /\u003e\n\n## 데이터셋\n\n또한, 저는 fine-tuning을 위해 Databricks databricks-dolly-15k dataset를 사용했어요 (CC BY-SA 3.0 라이선스하에 제공됨). fine-tuning 시간을 줄이기 위해 이 데이터의 작은 부분(1000행)을 사용했고 컨셉을 증명했어요.\n\n## 구성 요소\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n모델 로딩 시, GPU 메모리 제한을 극복하기 위해 다음과 같은 양자화 구성을 사용했어요.\n\n```js\nquantization_config = BitsAndBytesConfig(\n    load_in_4bit=True,\n    bnb_4bit_use_double_quant=True,\n    bnb_4bit_quant_type=\"nf4\",\n    bnb_4bit_compute_dtype=torch.bfloat16,\n)\n```\n\n이 양자화 구성은 bfloat16 계산 데이터 유형과 nf4(4비트 Normal Float)인 저정밀 스토리지 데이터 유형을 가지고 있기 때문에 단일 GPU에서 모델 세밀 조정에 매우 중요해요. 실제로는 QLORA 가중치 텐서가 사용될 때, 텐서를 bfloat16로 비양자화하고 16비트에서 행렬 곱셈을 수행하게 됩니다(자세한 내용은 원본 논문 참조).\n\n또한 이전에 언급한 대로, 양자화와 함께 LoRA를 사용하여 메모리 제한을 극복하기 위한 QLoRA를 사용 중이에요. 여기 LoRA를 위한 제 설정입니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nlora_config = LoraConfig(\n    r=16,\n    lora_alpha=64,\n    target_modules=[\"q_proj\", \"k_proj\", \"v_proj\", \"o_proj\", \"gate_proj\"],\n    bias=\"none\",\n    lora_dropout=0.05,\n    task_type=\"CAUSAL_LM\",\n)\n```\n\n제 LoRA 구성에는 랭크로 16을 사용했어요. 4부터 16 사이의 랭크로 설정하는 것이 학습 가능한 매개변수의 수를 줄이고 모델 성능 사이의 적절한 균형을 얻기 위해 권장됩니다. 마지막으로, Mistral 7B 트랜스포머 모델의 일부 선형 계층에 LoRA를 적용했습니다.\n\n# 학습 및 모니터링\n\n제 개인적인 그래픽 카드를 사용하여 4 에포크 (1000 단계)의 학습을 완료할 수 있었어요. 지역 GPU에서 LLM을 학습하는 이러한 테스트 중 하나의 목적은 어떠한 제한 없이 하드웨어 리소스를 모니터링하는 것이에요. 학습 중 GPU를 모니터링하는 가장 간단한 도구 중 하나는 Nvidia 시스템 관리 인터페이스 (SMI)입니다. 단순히 터미널을 열고 명령줄에 다음을 입력하세요:\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nnvidia-smi\n```\n\n또는 지속적인 모니터링과 업데이트를 위해 다음을 사용하세요 (1초마다 새로고침):\n\n```js\nnvidia-smi -l 1\n```\n\n이렇게 하면 GPU에서 각 프로세스의 메모리 사용량을 확인할 수 있습니다. 다음 SMI 보기에서 저는 모델을 불러왔고 약 5GB의 메모리를 사용했습니다 (양자화 덕분에). 또한 Anaconda3 Python (Jupyter 노트북) 프로세스로 모델이 불러와진 것을 확인할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n+---------------------------------------------------------------------------------------+\n| NVIDIA-SMI 545.23.08              Driver Version: 545.23.08    CUDA Version: 12.3     |\n|-----------------------------------------+----------------------+----------------------+\n| GPU  Name                 Persistence-M | Bus-Id        Disp.A | Volatile Uncorr. ECC |\n| Fan  Temp   Perf          Pwr:Usage/Cap |         Memory-Usage | GPU-Util  Compute M. |\n|                                         |                      |               MIG M. |\n|=========================================+======================+======================|\n|   0  NVIDIA GeForce RTX 3090        On  | 00000000:29:00.0  On |                  N/A |\n| 30%   37C    P8              33W / 350W |   5346MiB / 24576MiB |      5%      Default |\n|                                         |                      |                  N/A |\n+-----------------------------------------+----------------------+----------------------+\n                                                                                         \n+---------------------------------------------------------------------------------------+\n| Processes:                                                                            |\n|  GPU   GI   CI        PID   Type   Process name                            GPU Memory |\n|        ID   ID                                                             Usage      |\n|=======================================================================================|\n|    0   N/A  N/A      1610      G   /usr/lib/xorg/Xorg                          179MiB |\n|    0   N/A  N/A      1820      G   /usr/bin/gnome-shell                         41MiB |\n|    0   N/A  N/A    108004      G   ...2023.3.3/host-linux-x64/nsys-ui.bin        8MiB |\n|    0   N/A  N/A    168032      G   ...seed-version=20240110-180219.406000      117MiB |\n|    0   N/A  N/A    327503      C   /home/***/anaconda3/bin/python             4880MiB |\n+---------------------------------------------------------------------------------------+\n```\n\n그리고 이곳은 훈련 과정 중 약 30단계 이후의 메모리 상태입니다. 보시다시피, 사용 중인 GPU 메모리는 현재 약 15GB입니다.\n\n```js\n+---------------------------------------------------------------------------------------+\n| NVIDIA-SMI 545.23.08              Driver Version: 545.23.08    CUDA Version: 12.3     |\n|-----------------------------------------+----------------------+----------------------+\n| GPU  Name                 Persistence-M | Bus-Id        Disp.A | Volatile Uncorr. ECC |\n| Fan  Temp   Perf          Pwr:Usage/Cap |         Memory-Usage | GPU-Util  Compute M. |\n|                                         |                      |               MIG M. |\n|=========================================+======================+======================|\n|   0  NVIDIA GeForce RTX 3090        On  | 00000000:29:00.0  On |                  N/A |\n| 30%   57C    P2             341W / 350W |  15054MiB / 24576MiB |    100%      Default |\n|                                         |                      |                  N/A |\n+-----------------------------------------+----------------------+----------------------+\n                                                                                         \n+---------------------------------------------------------------------------------------+\n| Processes:                                                                            |\n|  GPU   GI   CI        PID   Type   Process name                            GPU Memory |\n|        ID   ID                                                             Usage      |\n|=======================================================================================|\n|    0   N/A  N/A      1610      G   /usr/lib/xorg/Xorg                          179MiB |\n|    0   N/A  N/A      1820      G   /usr/bin/gnome-shell                         40MiB |\n|    0   N/A  N/A    108004      G   ...2023.3.3/host-linux-x64/nsys-ui.bin        8MiB |\n|    0   N/A  N/A    168032      G   ...seed-version=20240110-180219.406000      182MiB |\n|    0   N/A  N/A    327503      C   /home/***/anaconda3/bin/python            14524MiB |\n+---------------------------------------------------------------------------------------+\n```\n\nSMI는 GPU 메모리 사용량을 모니터링하는 간단한 도구이지만, 더 자세한 정보를 제공하는 고급 모니터링 도구들도 몇 가지 있습니다. 그 중 하나가 PyTorch Memory Snapshot인데, 이에 관해 더 읽어볼 수 있는 흥미로운 기사가 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 개요\n\n본 문서에서는 Mistral 7B와 같은 대규모 언어 모델을 단일 24GB GPU(예: NVIDIA GeForce RTX 3090 GPU)에서 세밀하게 조정할 수 있는 것을 보여드렸습니다. 그러나 자세히 설명한 대로 QLoRA와 같은 특별한 PEFT 기술이 필요합니다. 또한 모델의 배치 크기가 중요하며, 한정된 자원 때문에 보다 오랜 시간의 훈련이 필요할 수 있습니다.","ogImage":{"url":"/TIL/assets/img/2024-07-14-FineTuningLLMsonaSingleConsumerGraphicCard_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-FineTuningLLMsonaSingleConsumerGraphicCard_0.png","tag":["Tech"],"readingTime":15}],"page":"21","totalPageCount":50,"totalPageGroupCount":3,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"21"},"buildId":"olPs1cVezSGTqD7OaewDI","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>