<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>TIL</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//posts/11" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="TIL" data-gatsby-head="true"/><meta property="og:title" content="TIL" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//posts/11" data-gatsby-head="true"/><meta name="twitter:title" content="TIL" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/a76947e4a2088726.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/a76947e4a2088726.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/873-eb138c3217d71553.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/posts/%5Bpage%5D-de1dc5579188f9be.js" defer=""></script><script src="/TIL/_next/static/KUC9M_yIlA1Ugo01xmkHL/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/KUC9M_yIlA1Ugo01xmkHL/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="nextjs 15에서 template.js 사용하는 방법" href="/TIL/post/2025-04-22-templatejs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="nextjs 15에서 template.js 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="nextjs 15에서 template.js 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">nextjs 15에서 template.js 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">18 hours ago</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js 15에서 Unauthorized.js로 권한 없는 접근 처리하는 방법" href="/TIL/post/2025-04-22-unauthorizedjs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15에서 Unauthorized.js로 권한 없는 접근 처리하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15에서 Unauthorized.js로 권한 없는 접근 처리하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15에서 Unauthorized.js로 권한 없는 접근 처리하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">18 hours ago</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js 15 라우트 세그먼트 설정 방법과 활용팁" href="/TIL/post/2025-04-22-RouteSegmentConfig"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15 라우트 세그먼트 설정 방법과 활용팁" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15 라우트 세그먼트 설정 방법과 활용팁" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15 라우트 세그먼트 설정 방법과 활용팁</strong><div class="PostList_meta__VCFLX"><span class="date">18 hours ago</span><span class="PostList_reading_time__6CBMQ">18<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js 15에서 route.js 파일 설정하는 방법" href="/TIL/post/2025-04-22-routejs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15에서 route.js 파일 설정하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15에서 route.js 파일 설정하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15에서 route.js 파일 설정하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">18 hours ago</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js 15에서 not-found.js로 404 페이지 쉽게 만드는 방법" href="/TIL/post/2025-04-22-not-foundjs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15에서 not-found.js로 404 페이지 쉽게 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15에서 not-found.js로 404 페이지 쉽게 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15에서 not-found.js로 404 페이지 쉽게 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">18 hours ago</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js 15 page.js로 페이지 구성하는 방법" href="/TIL/post/2025-04-22-pagejs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15 page.js로 페이지 구성하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15 page.js로 페이지 구성하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15 page.js로 페이지 구성하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">18 hours ago</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js 15 로딩 컴포넌트 만들기 (loading.js)" href="/TIL/post/2025-04-22-loadingjs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15 로딩 컴포넌트 만들기 (loading.js)" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15 로딩 컴포넌트 만들기 (loading.js)" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15 로딩 컴포넌트 만들기 (loading.js)</strong><div class="PostList_meta__VCFLX"><span class="date">18 hours ago</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js 15에서 mdx-components.js로 커스텀 MDX 컴포넌트 만드는 방법" href="/TIL/post/2025-04-22-mdx-componentsjs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15에서 mdx-components.js로 커스텀 MDX 컴포넌트 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15에서 mdx-components.js로 커스텀 MDX 컴포넌트 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15에서 mdx-components.js로 커스텀 MDX 컴포넌트 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">18 hours ago</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js 15에서 Middleware.js로 서버 데이터 처리하는 방법" href="/TIL/post/2025-04-22-middlewarejs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15에서 Middleware.js로 서버 데이터 처리하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15에서 Middleware.js로 서버 데이터 처리하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15에서 Middleware.js로 서버 데이터 처리하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">18 hours ago</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nextjs 15 에서 레이아웃 잡는 방법 (layout.js)" href="/TIL/post/2025-04-22-layoutjs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nextjs 15 에서 레이아웃 잡는 방법 (layout.js)" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nextjs 15 에서 레이아웃 잡는 방법 (layout.js)" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Nextjs 15 에서 레이아웃 잡는 방법 (layout.js)</strong><div class="PostList_meta__VCFLX"><span class="date">18 hours ago</span><span class="PostList_reading_time__6CBMQ">18<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/TIL/posts/1">1</a><a class="link" href="/TIL/posts/2">2</a><a class="link" href="/TIL/posts/3">3</a><a class="link" href="/TIL/posts/4">4</a><a class="link" href="/TIL/posts/5">5</a><a class="link" href="/TIL/posts/6">6</a><a class="link" href="/TIL/posts/7">7</a><a class="link" href="/TIL/posts/8">8</a><a class="link" href="/TIL/posts/9">9</a><a class="link" href="/TIL/posts/10">10</a><a class="link posts_-active__YVJEi" href="/TIL/posts/11">11</a><a class="link" href="/TIL/posts/12">12</a><a class="link" href="/TIL/posts/13">13</a><a class="link" href="/TIL/posts/14">14</a><a class="link" href="/TIL/posts/15">15</a><a class="link" href="/TIL/posts/16">16</a><a class="link" href="/TIL/posts/17">17</a><a class="link" href="/TIL/posts/18">18</a><a class="link" href="/TIL/posts/19">19</a><a class="link" href="/TIL/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"nextjs 15에서 template.js 사용하는 방법","description":"","date":"2025-04-22 02:47","slug":"2025-04-22-templatejs","content":"\n# template.js 파일 이해하기\n\n이번에는 `template.js` 파일에 대해 이야기해볼게요. 템플릿 파일은 레이아웃(layout)과 비슷한 역할을 하지만, 조금 다릅니다.\n\n레이아웃은 여러 라우트(route)에서 유지되면서 상태(state)를 유지하는 반면, 템플릿은 고유한 키(unique key)를 가지고 있어서 자식 클라이언트 컴포넌트(Client Components)의 상태가 페이지가 이동할 때마다 초기화(reset)된다는 차이가 있어요.\n\n예를 들어, 다음과 같은 템플릿 컴포넌트가 있다고 가정해볼게요.\n\n```js\nexport default function Template({ children }: { children: React.ReactNode }) {\n  return \u003cdiv\u003e{children}\u003c/div\u003e;\n}\n```\n\n이 코드에서는 `children`을 받아서 `\u003cdiv\u003e`로 감싸기만 했죠. 이 템플릿을 사용하면, 페이지를 이동할 때마다 자식 컴포넌트들의 상태가 초기화됩니다.\n\n---\n\n### 상태 유지 vs 초기화: 왜 중요할까?\n\n- **레이아웃**은 여러 페이지 사이를 오가더라도 상태가 유지돼요. 예를 들어, 사이드바가 열려있는 상태를 유지하고 싶다면 레이아웃이 맞아요.\n- **템플릿**은 페이지 또는 특정 라우트마다 상태를 초기화해야 할 때 씁니다. 예를 들어, 폼 입력값을 페이지별로 완전히 새로 시작하고 싶을 때요.\n\n---\n\n### 꿀팁: 템플릿과 레이아웃, 언제 써야 할까?\n\n- 상태 유지가 필요하면 → 레이아웃을 사용하세요.\n- 상태 초기화가 필요하면 → 템플릿을 사용하세요.\n\ni이해를 돕기 위해 이미지도 참고하면 좋아요!\nt\n![template 개념 이미지](/TIL/assets/img/2025-04-22-templatejs_0.png)\n\n---\n\n요약하자면, `template.js`는 레이아웃과 비슷하지만, 페이지가 바뀔 때마다 자식 컴포넌트 상태가 초기화 된다는 점에서 다릅니다. 프로젝트에서 상태 관리가 필요한 부분을 명확히 구분해서 템플릿과 레이아웃을 적절히 활용해 보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n가끔은 레이아웃(Layout) 대신에 템플릿(Template)을 선택하는 게 더 나은 경우도 있어요. 예를 들면:\n\n- useEffect (예: 페이지 뷰 로깅)나 useState (예: 각 페이지별 피드백 폼) 같은 훅을 활용하는 기능이 필요할 때.\n- 기본 프레임워크 동작 방식을 바꾸고 싶을 때. 예를 들어, 레이아웃 내의 Suspense 경계는 레이아웃이 처음 로드될 때만 fallback UI를 보여주고 페이지 전환 시에는 보여주지 않지만, 템플릿에서는 페이지가 바뀔 때마다 fallback UI가 매번 표시됩니다.\n\n## Props\n\n### children (필수)\n\nchildren은 템플릿 내부에 렌더링될 자식 요소들을 의미합니다. 이걸 사용해서 부모 컴포넌트에서 자식 컴포넌트를 감싸거나 그 안에 배치할 수 있어요. React에서 자식 요소를 다룰 때 거의 항상 사용하니까 꼭 기억해두세요!\n\n---\n\n추가로, 레이아웃과 템플릿 선택 기준에 대해 조금 더 설명하자면, 레이아웃은 기본적으로 페이지 전환 시 지속되는 공통 UI나 구조를 만드는 데 쓰이고, 템플릿은 각 페이지가 로드될 때마다 새로 렌더링되어야 하는 동적인 UI나 상태 관리가 필요할 때 적합해요. 개발하는 서비스의 특성과 UX 목표에 따라 적절히 선택하면 됩니다!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nTemplate 컴포넌트는 children prop을 받아 사용할 수 있어요. 예를 들어 이렇게 작성할 수 있죠:\n\n```jsx\n\u003cLayout\u003e\n  {/* 템플릿에는 자동으로 고유한 key가 주어진다는 점 참고하세요. */}\n  \u003cTemplate key={routeParam}\u003e{children}\u003c/Template\u003e\n\u003c/Layout\u003e\n```\n\n\u003e 알아두면 좋은 점:\n\u003e 기본적으로 템플릿은 서버 컴포넌트(Server Component)로 동작하지만, \"use client\" 지시어를 붙이면 클라이언트 컴포넌트(Client Component)로도 사용할 수 있습니다.\n\u003e 사용자가 템플릿을 공유하는 여러 라우트 사이를 이동할 때는 컴포넌트가 새로 마운트되고, DOM 요소들도 재생성돼요. 그래서 클라이언트 컴포넌트의 상태는 유지되지 않고, effect도 다시 실행됩니다.\n\n즉, 템플릿을 클라이언트 측에서 사용한다면 상태 관리 혹은 사이드 이펙트 처리에 유의해야 한다는 점 기억하세요!\n\n## Version History\n\n(이후 버전 히스토리 내용이 이어지는 부분이라면 여기에 추가 정보를 넣을 수 있어요.)\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 표를 마크다운 형식으로 변환한 내용이에요.\n\n| Version   | Changes                |\n| --------- | ---------------------- |\n| `v13.0.0` | `template` introduced. |\n\n여기서 'template'이 새로 도입되었다고 하네요. 보통 이런 변경 사항은 라이브러리나 프레임워크의 중요한 기능 추가나 개선일 가능성이 높아요. 만약 여러분이 사용 중인 버전이 13.0.0이라면 이 'template' 기능을 꼭 한번 살펴보는 걸 추천해요. 새로운 기능이 어떤 식으로 코드를 더 깔끔하게 해주거나, 생산성을 높여줄지 직접 써보면서 경험해보는 게 가장 좋아요!\n","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":4},{"title":"Next.js 15에서 Unauthorized.js로 권한 없는 접근 처리하는 방법","description":"","date":"2025-04-22 02:47","slug":"2025-04-22-unauthorizedjs","content":"\n\n# unauthorized.js\n\n`unauthorized.js` 파일은 인증 과정에서 `unauthorized` 함수가 호출될 때 보여줄 UI를 렌더링하는 역할을 해요. 이 파일을 통해 UI를 원하는 대로 꾸밀 수 있을 뿐만 아니라, Next.js가 자동으로 401 상태 코드를 반환해 준답니다.\n\n```js\nimport Login from '@/app/components/Login'\n\nexport default function Unauthorized() {\n  return (\n    \u003cmain\u003e\n      \u003ch1\u003e401 - Unauthorized\u003c/h1\u003e\n      \u003cp\u003ePlease log in to access this page.\u003c/p\u003e\n      \u003cLogin /\u003e\n    \u003c/main\u003e\n  )\n}\n```\n\n위 코드를 보면, 기본적으로 \"401 - Unauthorized\"라는 제목과 함께 로그인을 요청하는 문구가 보이고, `Login` 컴포넌트를 렌더링해 실제 로그인 화면도 함께 표시하고 있어요.\n\n### 조금 더 알아보기\n\n- **401 상태 코드란?**  \n  401은 '인증이 필요함'을 나타내는 HTTP 상태 코드로, 사용자가 인증되지 않은 상태에서 접근 권한이 필요한 페이지에 접근할 때 서버가 보내요.\n\n- **Next.js에서의 활용 팁**  \n  이 파일을 커스터마이징하면 에러 페이지를 여러분의 서비스 스타일에 맞게 꾸밀 수 있답니다. 예를 들어, 로그인 버튼 대신 소셜 로그인이나 회원가입으로 유도하는 링크도 넣어볼 수 있겠죠?\n\n- **추가로 하면 좋은 것**  \n  사용자가 왜 인증이 필요한지 좀 더 자세한 안내나, 인증 절차에 도움이 될 만한 FAQ 링크를 같이 넣으면 UX가 더 좋아질 수 있어요.\n\n필요하면 한 번 직접 만들어보고, 여러분만의 인증 오류 페이지도 멋지게 만들어 보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### Props\n\n`unauthorized.js` 컴포넌트는 어떤 props도 받지 않습니다.\n\n## 예시\n\n### 로그인하지 않은 사용자에게 로그인 UI 보여주기\n\n로그인하지 않은 사용자를 대상으로 로그인 화면을 보여주고 싶을 때, `unauthorized.js` 컴포넌트를 사용할 수 있어요. 참고로 이 컴포넌트는 추가 설정을 위해 props를 받지 않으니, 간단하게 기본 UI를 렌더링하는 용도로 쓴다는 점 기억하세요.\n\n만약 내 서비스에서 로그인 여부에 따라 다른 화면을 보여줘야 한다면, 조건문으로 이 컴포넌트를 넣어주면 됩니다. 예를 들어:\n\n```jsx\n{ !userIsLoggedIn \u0026\u0026 \u003cUnauthorized /\u003e }\n```\n\n이렇게 하면 인증되지 않은 사용자에게만 로그인 페이지가 표시되고, 이미 로그인한 사용자에겐 다른 화면이 보여지겠죠?\n\n추가로, `unauthorized.js` 컴포넌트 내부를 수정해 나만의 로그인 UI로 커스터마이징해도 좋습니다. 그럴 땐 props 대신 내부 상태나 리덕스 등 상태관리 라이브러리를 이용해서 유연하게 UX를 조절해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여러분 안녕하세요! 오늘은 Next.js 앱에서 인증이 필요한 페이지에 대해 'unauthorized' 함수를 이용해 인증되지 않은 사용자에게 로그인 UI를 보여주는 방법을 쉽게 설명해드릴게요.\n\n먼저, `DashboardPage` 컴포넌트를 살펴봅시다. 여기서는 `verifySession()` 함수를 통해 사용자의 세션 정보를 확인하는데요, 이 함수는 비동기 함수라 `await`를 붙여 호출해주고 있어요.\n\n```jsx\nimport { verifySession } from '@/app/lib/dal'\nimport { unauthorized } from 'next/navigation'\n \nexport default async function DashboardPage() {\n  const session = await verifySession()\n \n  if (!session) {\n    unauthorized()\n  }\n \n  return \u003cdiv\u003eDashboard\u003c/div\u003e\n}\n```\n\n- `verifySession()` 함수가 null 또는 undefined를 반환한다면 세션이 없는 것으로 간주하고, `unauthorized()` 함수를 호출해버립니다.\n- 이 `unauthorized()` 함수는 내부적으로 Next.js에 내장된 기능으로, 렌더링을 멈추고 `unauthorized.js` 파일을 호출해서 401 페이지를 보여주게 해줍니다.\n\n그럼 그 `unauthorized.js` 파일에 어떤 컴포넌트가 있냐면,\n\n```jsx\nimport Login from '@/app/components/Login'\n \nexport default function UnauthorizedPage() {\n  return (\n    \u003cmain\u003e\n      \u003ch1\u003e401 - Unauthorized\u003c/h1\u003e\n      \u003cp\u003ePlease log in to access this page.\u003c/p\u003e\n      \u003cLogin /\u003e\n    \u003c/main\u003e\n  )\n}\n```\n\n이렇게 간단하게 로그인 UI를 포함한 페이지를 만들고 있어요. 화면에 “401 - Unauthorized” 메시지와 로그인 폼이 나타나게 되는 거죠.\n\n---\n\n### 한 번에 쉽게 인증 처리하기\n\n사실 여기서 중요한 점은, 이런 패턴을 쓰면 페이지 보호 로직이 깔끔해진다는 거예요. 개발자 입장에서 보면, 사용자가 로그인을 하지 않은 상태면 바로 401 페이지로 분기시키고, 그 화면에서 자연스럽게 로그인하도록 유도할 수 있죠.\n\n- 기존의 리다이렉트 방식이나, 클라이언트 사이드에서 상태를 확인하는 것보다 서버에서 바로 인증 상태를 확인하는 게 보안상 더 안전합니다.\n- 물론 세션 검증 함수(`verifySession`)는 직접 구현해야 해요. 예를 들어 쿠키에 포함된 토큰을 해석하거나, 데이터베이스를 조회해서 유효성을 검사하게 됩니다.\n\n---\n\n### 이해를 돕는 간단 다이어그램\n\n| 동작 단계             | 설명                                    |\n|-------------------|---------------------------------------|\n| 1. 세션 확인          | `verifySession` 호출해서 로그인 여부 확인          |\n| 2. 미인증 사용자 감지     | 세션이 없으면 `unauthorized()` 호출해서 401 페이지 렌더링   |\n| 3. 401 페이지 렌더링      | `unauthorized.js`에 정의된 로그인 화면을 보여줌            |\n| 4. 로그인 후 세션 생성     | 로그인 컴포넌트에서 정상 로그인이 되면 세션이 생성됨         |\n| 5. 접근 허용           | 이후 대시보드 페이지 접속 가능                           |\n\n---\n\n### 마치며\n\nNext.js 앱에서 인증이 필요한 페이지를 다룰 때, ‘unauthorized’ 함수를 잘 활용하면 간단하고 체계적인 접근 제어를 구현할 수 있습니다. 보안도 높이고 UX도 좋으니 여러분께서도 꼭 한 번 써보시길 추천드려요.\n\n추가로, 로그인 컴포넌트나 세션 검증 로직에 대해 궁금하신 점 있으면 댓글로 알려주세요. 다음에는 그 부분도 자세히 다뤄보겠습니다!\n\n오늘도 즐거운 개발 되시길! 🚀\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n| Version   | Changes                 |\n|-----------|-------------------------|\n| `v15.1.0` | `unauthorized.js` 도입됨 |\n\n이번에 `v15.1.0` 버전에서 `unauthorized.js`라는 파일이 새롭게 추가됐어요. 보통 이런 파일 이름은 '허가되지 않은 접근'과 관련된 기능을 처리할 때 쓰이는데요, 예를 들어 로그인이 필요한 페이지에 비로그인 사용자가 접근하려 할 때 보여주는 에러 처리나 리다이렉트 등을 담당할 수도 있답니다.\n\n이렇게 특정 상황에 맞는 자바스크립트 파일을 분리해서 관리하면 코드 유지보수도 편해지고, 필요한 경우에만 로드해서 성능 최적화도 할 수 있어요. 나중에 관련 기능을 더 자세히 살펴볼 기회가 있으면, `unauthorized.js`가 실제로 어떤 역할을 하는지 한번 분석해보는 것도 재밌겠네요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":5},{"title":"Next.js 15 라우트 세그먼트 설정 방법과 활용팁","description":"","date":"2025-04-22 02:45","slug":"2025-04-22-RouteSegmentConfig","content":"\n\n# Route Segment Config\n\n\u003e 이 페이지에 소개된 옵션들은 `dynamicIO` 플래그가 켜져 있으면 비활성화되고, 앞으로는 없어질 예정이에요.\n\nRoute Segment 옵션은 Page, Layout, 또는 Route Handler의 동작 방식을 직접 제어하고 싶을 때 유용해요. 이 옵션들은 아래 변수들을 export 해서 설정할 수 있습니다.\n\n| 옵션             | 타입                                                                                  | 기본값           |\n|-----------------|-------------------------------------------------------------------------------------|-----------------|\n| [experimental_ppr](#experimental_ppr) | `boolean`                                                                             |                 |\n| [dynamic](#dynamic)                   | `'auto'` \\| `'force-dynamic'` \\| `'error'` \\| `'force-static'`                        | `'auto'`        |\n| [dynamicParams](#dynamicparams)      | `boolean`                                                                             | `true`          |\n| [revalidate](#revalidate)             | `false` \\| `0` \\| `number`                                                            | `false`         |\n| [fetchCache](#fetchcache)             | `'auto'` \\| `'default-cache'` \\| `'only-cache'` \\| `'force-cache'` \\| `'force-no-store'` \\| `'default-no-store'` \\| `'only-no-store'` | `'auto'`        |\n| [runtime](#runtime)                   | `'nodejs'` \\| `'edge'`                                                                | `'nodejs'`      |\n| [preferredRegion](#preferredregion)  | `'auto'` \\| `'global'` \\| `'home'` \\| `string` \\| `string[]`                          | `'auto'`        |\n| [maxDuration](#maxduration)           | `number`                                                                             | 배포 플랫폼에 따라 설정 |\n\n---\n\n### 한눈에 보기\n\n- **experimental_ppr**: 실험적인 부분들에 대한 설정인데, 자세한 내용은 공식 문서를 참고해야 해요.\n- **dynamic**: 페이지를 동적으로 처리할지, 정적으로 처리할지 결정할 수 있어요. 기본값은 `'auto'`라 알아서 최적의 방식을 선택합니다.\n- **dynamicParams**: 동적 경로 파라미터 사용 여부를 설정해요. 기본적으로 `true`라 동적 파라미터를 허용합니다.\n- **revalidate**: ISR(Incremental Static Regeneration)을 사용할 때 재빌드 주기를 설정합니다. `false`는 재빌드를 하지 않는다는 의미고, 숫자를 지정하면 해당 초마다 재빌드 돼요.\n- **fetchCache**: 서버 측 데이터 fetching 시 어떤 캐싱 전략을 사용할지 정하는 옵션입니다.\n- **runtime**: `nodejs` 또는 `edge` 중 실행 환경을 선택할 수 있어요. 기본은 `nodejs`.\n- **preferredRegion**: 배포 리전을 지정할 수 있는 옵션입니다. 글로벌 서비스를 위한 `'global'`이나 특정 리전 이름, 혹은 배열로 여러 리전을 설정할 수 있죠.\n- **maxDuration**: 함수 실행 최장 시간을 의미하는데, 보통 배포 환경에 따라 제한됩니다.\n\n---\n\n### 그리고 살짝 덧붙이자면...\n\n이런 Route Segment 설정을 통해서 Next.js 같은 프레임워크에서 페이지나 API 경로의 동작 방식을 세밀하게 조정할 수 있어요. 예를 들어, `dynamic: 'force-dynamic'`으로 지정하면 요청마다 항상 새롭게 렌더링해서 가장 최신 데이터를 보여주고, `revalidate` 시간을 설정해두면 효율적인 캐싱을 하면서도 일정 주기로 콘텐츠가 갱신되게 할 수 있죠.\n\n또한, `runtime`을 `edge`로 설정하면 전 세계 엣지 서버에서 빠르게 처리가 가능해서 속도 향상과 지연 감소에 도움 될 수 있습니다. 다만 엣지 런타임 환경 제약 조건이 있으니, 사용 시 주의하세요.\n\n이렇게 구성해두면 사용자 경험을 더 좋게 만들어주고, 서버 리소스를 효과적으로 사용할 수 있다는 장점이 있습니다. 다음에는 각 옵션별 좀 더 구체적인 활용법도 소개해볼게요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 옵션\n\n### experimental_ppr\n\nPartial Prerendering, 줄여서 PPR을 레이아웃이나 페이지에 적용할 수 있는 옵션이에요. 이걸 활성화하면 페이지나 특정 레이아웃이 부분적으로 미리 렌더링 되어서, 사용자가 페이지를 더 빨리 볼 수 있도록 도와줘요.\n\n```js\nexport const experimental_ppr = true\n// true | false\n```\n\n참고로, 이 옵션은 아직 실험적인 기능이라 가끔 예상치 못한 동작이 있을 수도 있어요. 그래서 프로젝트에 바로 적용하기보다는 테스트 환경에서 먼저 써보고, 잘 맞는지 확인하는 걸 추천드려요!\n\n추가로 Partial Prerendering은 페이지의 일부만 미리 만들어두고 나머지는 필요할 때 로드하는 방식이기 때문에, 데이터가 자주 변하는 부분이나 사용자 맞춤형 콘텐츠에서 유용할 수 있어요. 만약에 페이지가 크고 렌더링 시간이 길다면, PPR을 활용해서 초기 로딩 속도를 확실히 개선할 수 있답니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### dynamic\n\n레이아웃이나 페이지의 동작 방식을 완전 정적(static) 또는 완전 동적(dynamic)으로 바꿀 수 있는 옵션이에요.\n\n```js\nexport const dynamic = 'auto'\n// 사용할 수 있는 값: 'auto' | 'force-dynamic' | 'error' | 'force-static'\n```\n\n여기서 각 값의 의미는 다음과 같아요:\n\n- `'auto'`: 기본값이에요. 상황에 따라 동적 또는 정적으로 처리해요.\n- `'force-dynamic'`: 무조건 동적으로 렌더링해요.\n- `'force-static'`: 무조건 정적으로 렌더링해요.\n- `'error'`: 동적 동작이 필요할 때 에러를 발생시켜요.\n\n\u003e 참고로 알면 좋은 점: Next.js의 최신 app 디렉토리 구조에서는 페이지 단위에서 모두 다 동적이거나 모두 다 정적인 getServerSideProps, getStaticProps 대신, fetch 요청 단위에서 좀 더 세밀하게 캐싱을 조절하는 방식을 선호해요. 즉, 이전의 방식보다 더 유연해졌죠. 그런데 기존의 페이지 단위 동작 모델로 쉽게 돌아가고 싶은 경우, 이 `dynamic` 옵션을 활용하면 간편하게 이전 모델을 유지할 수 있어서 마이그레이션할 때도 편리해요.\n\n---\n\n추가로 덧붙이자면, 실제로는 fetch 함수에서 `cache` 옵션을 주는 쪽이 더 권장됩니다. 예를 들어:\n\n```js\nconst res = await fetch('/api/data', { cache: 'no-store' }) // 항상 최신 데이터를 받아오도록 강제\n```\n\n이런 식으로 개별 fetch 요청마다 캐싱 동작을 세부 조절할 수 있어요. `dynamic` 옵션은 주로 전체 페이지 단위의 기본 동작을 결정할 때 사용한다고 생각하면 됩니다. \n\n즉, Next.js의 최신 앱 구조는 “모든 것을 다 세부적으로 제어하는 시대”라고 이해하면 좋겠네요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n`dynamic` 옵션에는 총 네 가지가 있어요. 각 옵션이 어떤 차이를 만드는지 쉽게 정리해볼게요!\n\n| 옵션           | 설명                                                                                                  | 추가 팁                                                                                          |\n|---------------|-----------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------|\n| `auto` (기본값) | 가능한 한 많이 캐시하지만, 동적으로 동작하고 싶은 컴포넌트는 이를 선택할 수 있도록 허용합니다.                                    | 기본값 그대로 쓰면 딱히 설정하지 않아도 자동으로 적절히 작동해요.                                      |\n| `force-dynamic` | 무조건 동적 렌더링을 합니다. 즉, 각 요청마다 매번 페이지가 새로 렌더링됨.                                       | 내부적으로 모든 fetch() 요청은 `'cache: no-store', next: { revalidate: 0 }` 설정이 되고, `fetchCache = force-no-store` 로 강제되죠. |\n| `error`        | 정적 렌더링만 강제하고, 만약 Dynamic API나 캐시되지 않는 데이터를 쓰면 에러 발생!                                    | pages 디렉토리의 `getStaticProps()`와 비슷해요. fetch()는 `'cache: force-cache'`를 사용하고, `fetchCache = only-cache`, `dynamicParams = false`로 설정됩니다. 동적 파라미터가 필요하면 수동으로 `dynamicParams = true`로 바꿔야 해요.        |\n| `force-static` | 정적 렌더링 강제 + cookies, headers(), useSearchParams() 호출 시 빈값만 반환하게 만듭니다.                          | 정말 정적으로만 작동해야 하는 상황에 쓸 수 있어요.                                                    |\n\n---\n\n### 참고! \n`getServerSideProps`, `getStaticProps`에서 `dynamic: 'force-dynamic'`이나 `dynamic: 'error'`로 마이그레이션하는 방법은 [업그레이드 가이드](https://nextjs.org/docs/pages/building-your-application/data-fetching/upgrading)에서 자세히 설명하고 있으니 참고하세요.\n\n---\n\n### dynamicParams란?\n이건 `generateStaticParams`로 미리 생성하지 않은 동적 경로(`/posts/[id]` 같은)가 방문됐을 때 어떻게 처리할지 결정할 수 있는 옵션이에요. 예를 들면 동적 경로가 너무 많을 때 미리 다 생성할 수 없으니, 방문 시점에 동적으로 처리할지, 아니면 에러를 표시할지 선택할 수 있습니다.\n\n---\n\n이렇게 보면 `dynamic` 옵션을 상황과 필요에 맞게 조절하는 게 핵심이라는 걸 알 수 있죠. 예를 들어, 자주 바뀌는 데이터를 보여주는 페이지라면 `force-dynamic`이 유리하고, 가능하면 빌드 타임에 다 끝내고 싶으면 `error` 혹은 `force-static`을 쓰는 식이에요.\n\n실제로 프로젝트에 적용할 때는 데이터 특성과 사용자 경험을 잘 고려해서 가장 적합한 설정을 찾아 보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nexport const dynamicParams = true // true | false,\n```\n\n- true (기본값): `generateStaticParams`에 포함되지 않은 동적 세그먼트는 요청 시점에 생성돼요.\n- false: `generateStaticParams`에 없는 동적 세그먼트에 접근하면 404 페이지가 반환됩니다.\n\n\u003e 알아두면 좋은 점:  \n이 옵션은 pages 디렉터리에서 사용하던 `getStaticPaths`의 `fallback: true | false | blocking` 옵션을 대체해요.  \n만약 모든 경로를 처음부터 정적으로 렌더링하고 싶다면, `generateStaticParams`에서 빈 배열을 반환하거나 `export const dynamic = 'force-static'`을 사용해야 합니다.  \n`dynamicParams = true`인 경우, 해당 세그먼트는 스트리밍 서버 렌더링(Streaming Server Rendering)을 사용해요.  \n그리고 `dynamic = 'error'`나 `dynamic = 'force-static'`을 쓰면 `dynamicParams`의 기본값이 false로 바뀝니다.\n\n---\n\n### revalidate  \n\n*여기서 부터는 `revalidate` 옵션에 대해 살펴볼게요.*  \n\nNext.js의 `revalidate` 옵션은 ISR(Incremental Static Regeneration) 기능을 제어하는 데 사용돼요.  \n간단히 말해서, 특정 페이지를 정적으로 렌더링한 뒤, 일정 시간이 지나면 백그라운드에서 다시 빌드해서 최신 데이터를 반영할 수 있게 해줍니다.\n\n```js\nexport const revalidate = 10; // 10초마다 페이지 재생성\n```\n\n- 숫자 (초 단위): 페이지가 이 값만큼의 시간이 지나면 재생성됩니다.  \n- `false` 또는 `0`: ISR 비활성화, 빌드 시 한 번만 생성됨.\n\n재생성 시점에 방문한 사용자는 기존 페이지를 보고, 백그라운드에서 새 페이지가 만들어지니까 사용자 경험에 끊김이 적어요.\n\n---\n\n### 간단 요약\n\n| 옵션               | 설명                                                |\n|--------------------|---------------------------------------------------|\n| `dynamicParams`     | 동적 세그먼트가 동적으로 생성되는지 여부 설정          |\n| `revalidate`        | ISR 주기 설정, 몇 초마다 페이지를 다시 생성할지 결정     |\n\n---\n\n### 추가 팁!\n\n- **`dynamicParams = true`와 ISR 함께 쓰기**  \n   동적 경로가 많거나 데이터가 자주 바뀌는 경우에 유용해요. 첫 요청 때만 페이지를 생성하고, 나중에 ISR로 업데이트할 수 있거든요.\n\n- **빈 배열 반환시 모든 경로 미리 생성**  \n   미리 생성할 경로를 다 알 수 있으면 `generateStaticParams`에서 배열을 반환해 정적으로 빠른 페이지를 만들 수 있어요.  \n\n- **`dynamic = 'force-static'` 사용**  \n   앱 전체를 정적으로 만들고 싶을 땐 이 값을 써서 SSR이나 동적 params 없이 순수 정적 빌드만 하게 설정해보세요.\n\n여러분 프로젝트에 맞게 이런 설정들을 적절히 활용하면, 효율적인 빌드와 빠른 퍼포먼스를 동시에 잡을 수 있답니다!  \n추가로 Next.js 공식 문서도 자주 확인하면서 최신 기능을 놓치지 않는 게 중요해요~\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n레이아웃이나 페이지에 기본 revalidation(재검증) 시간을 설정할 수 있어요. 여기서 중요한 점은 이 설정이 개별 fetch 요청에서 설정한 revalidate 값을 덮어쓰지 않는다는 거예요.\n\n```js\nexport const revalidate = false\n// false | 0 | number\n```\n\n| 값 | 의미 |\n|---|---|\n| false (기본값) | 기본적으로 `force-cache` 옵션이 붙은 fetch 요청이나 Dynamic API 사용 이전에 발견된 요청들은 캐싱합니다. 사실상 재검증 기간이 무한대(`revalidate: Infinity`)인 것과 같아서, 리소스를 무한정 캐시하겠다는 의미예요. 그래도 개별 fetch 요청에서 `cache: no-store` 나 `revalidate: 0`을 써서 캐시를 회피하거나, 경로의 기본값보다 짧은 재검증 시간을 가진 양수로 설정해 재검증 빈도를 높이는 건 가능합니다. |\n| 0 | 이 옵션을 설정하면 Dynamic API를 사용하지 않더라도 레이아웃이나 페이지가 항상 동적으로 렌더링됩니다. 이 경우 캐시 옵션을 명시하지 않은 fetch 요청은 기본적으로 `no-store`로 동작하지만, `force-cache` 옵션을 준 요청이나 양의 재검증 시간을 가진 요청은 그대로 유지됩니다. |\n| number (초 단위) | 레이아웃이나 페이지의 기본 재검증 주기를 초 단위 숫자로 설정합니다. 예를 들어 `revalidate = 600`이면 10분마다 재검증합니다. |\n\n---\n\n### 참고할 점\n- `revalidate` 값은 정적으로 분석 가능해야 해요. 예를 들어 `revalidate = 600`은 유효하지만, `revalidate = 60 * 10` 같이 계산식은 안 됩니다. 즉, 값을 변수나 계산식이 아닌 숫자 리터럴로 직접 입력해야 하는 점을 기억하세요.\n- `runtime = 'edge'`를 사용할 때는 `revalidate` 값이 적용되지 않습니다.\n- 개발 모드(Development)에서는 모든 페이지가 항상 on-demand로 렌더링되며 캐싱되지 않아요. 덕분에 코드를 바로바로 수정 확인할 수 있고, 재검증 시간을 기다릴 필요가 없답니다.\n\n---\n\n### 추가로 알아두면 좋은 팁!\n`revalidate`를 적절히 사용하면 페이지의 최신성을 유지하면서도 캐싱을 통해 빠른 응답 속도를 얻을 수 있어요. 예를 들어 자주 변경되지 않는 블로그 글 같은 경우에는 긴 재검증 시간(`false` 또는 큰 숫자)을 줘서 트래픽 부담을 줄이고, 자주 갱신이 필요한 데이터엔 짧은 재검증 시간을 설정하는 식이죠.\n\n기본 설정을 잘 활용하면 서버 부하를 줄이면서 사용자에게 더 빠른 웹 경험을 제공할 수 있으니, 상황에 맞는 값을 고민해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n#### 재검증 주기 (Revalidation Frequency)\n\n- 하나의 경로(route)에 속한 레이아웃(layout)과 페이지(page)들 각각이 재검증(revalidate) 시간을 갖는데, 이 중 가장 짧은 재검증 주기가 그 경로 전체의 재검증 주기가 됩니다. 즉, 자식 페이지들도 부모 레이아웃만큼 자주 재검증되도록 보장하는 거죠.\n- 개별 fetch 요청(fetch requests)에서는 경로의 기본 재검증 주기보다 더 짧은 재검증 주기를 설정할 수 있어요. 이를 통해 특정 경로나 상황에 맞게 동적으로 재검증 빈도를 높일 수 있습니다.\n\n예를 들어, 뉴스 기사 페이지는 자주 업데이트돼야 할 수도 있으니까 이 경우엔 재검증 주기를 더 짧게 설정할 수 있겠죠.\n\n---\n\n### fetchCache\n\n`fetchCache`는 클라이언트에서 데이터를 호출할 때 결과를 캐시하는 방식을 다루는 설정이에요. 원격 API를 호출할 때마다 서버에 부담주지 않으면서도, 최신 데이터를 적절히 유지하기 위한 중요한 포인트랍니다. cache-control 헤더 같이 HTTP 표준 캐싱 정책과도 연동되니까, 이 부분을 적절히 활용하면 효율적인 데이터 요청과 성능 향상에 큰 도움이 됩니다.\n\n---\n\n### runtime\n\n`runtime`은 코드를 실행하는 환경을 의미해요. Next.js 같은 프레임워크에서 `runtime`은 서버 사이드에서 동작하는지, 클라이언트 사이드에서 동작하는지에 따라 달라집니다. 서버에선 Node.js 환경에서 구동되고, 클라이언트에선 브라우저 환경이죠.\n\n실제로 `runtime`이 중요해지는 이유는, 일부 기능들은 서버에서만, 또는 클라이언트에서만 동작해야 하기 때문입니다. 예를 들어, 민감한 API 키로 데이터를 불러오는 작업은 서버에서만 실행하도록 하고, 사용자 상호작용에 따른 UI 업데이트는 클라이언트에서 처리하는 식이죠.\n\n---\n\n이렇게 `revalidation frequency`부터 `fetchCache`, `runtime`까지 조합해서 쓰면, 데이터 신선도 유지와 성능 최적화를 모두 잡을 수 있어요. Next.js 같은 최신 프레임워크를 사용할 때 이 부분들을 잘 이해하고 활용하는 게 개발 생산성 향상에 큰 도움이 되니 참고하시길 바랍니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n애플리케이션 렌더링에는 Node.js 런타임을 사용하는 걸 추천드리고, 미들웨어(Middleware)에는 Edge 런타임만 지원되니 이 점 참고해 주세요.\n\n```js\nexport const runtime = 'nodejs'\n// 'nodejs' | 'edge'\n```\n\n| 런타임 종류 | 설명                   |\n| --------- | -------------------- |\n| nodejs    | 기본값, 앱 렌더링용        |\n| edge      | 미들웨어 전용, 빠른 응답에 적합 |\n\nNode.js 런타임은 널리 사용되는 서버 환경으로, 풍부한 라이브러리와 안정성 덕분에 앱 렌더링에 최적입니다. 반면, Edge 런타임은 전세계적으로 분산된 서버에서 실행돼 지연시간을 최소화하기 때문에 미들웨어 같은 경량 작업에 딱이죠.\n\n더 자세한 런타임 차이점과 사용법은 공식 문서를 참고하시면 도움이 될 거예요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### preferredRegion\n\n```js\nexport const preferredRegion = 'auto'\n// 'auto' | 'global' | 'home' | ['iad1', 'sfo1']\n```\n\n`preferredRegion` 옵션은 배포하는 플랫폼에 따라 지원 여부와 사용 가능한 지역이 달라진다는 점, 꼭 기억하세요!\n\n\u003e 참고할 점  \n만약 `preferredRegion`을 따로 지정하지 않으면, 가장 가까운 상위 레이아웃(parent layout)의 설정을 상속받습니다.  \n그리고 최상위 레이아웃(root layout)은 기본값으로 모든 지역(all regions)을 대상으로 합니다.\n\n---\n\n이 기능은 여러 서버 지역(Region) 중 어디서 코드를 실행할지 선택할 때 아주 유용해요. 예를 들어, 사용자가 미국 동부에 많다면 'iad1' 같은 특정 리전을 지정해 그쪽에서 서비스하도록 설정할 수 있죠. 'auto'로 설정하면 Next.js가 가장 적합한 지역을 자동으로 선택해주니 편리합니다.\n\n여기서 'global'은 전 세계 여러 지역에 걸쳐 배포하는 경우이고, 'home'은 특정 홈 지역을 지칭할 때 사용됩니다. 또한 배열 형태로 여러 리전을 직접 지정해 여러 곳에서 동시에 실행되도록 할 수도 있답니다.\n\n이처럼 `preferredRegion`을 잘 활용하면 사용자 경험을 크게 향상시킬 수 있으니, 필요에 맞게 설정하는 걸 추천드립니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### maxDuration\n\nNext.js에서는 기본적으로 서버 사이드 로직(페이지 렌더링이나 API 처리 등)의 실행 시간을 제한하지 않아요. 그런데 배포 플랫폼에서 Next.js 빌드 결과에 포함된 `maxDuration` 값을 활용해 실행 시간 제한을 걸 수 있답니다. 예를 들어, Vercel 같은 곳에서는 이 값을 참고해서 서버 로직이 너무 오래 걸리지 않도록 관리할 수 있죠.\n\n\u003e **참고**: `maxDuration` 설정은 Next.js 13.4.10 이상 버전에서만 사용할 수 있어요.\n\n```js\nexport const maxDuration = 5\n```\n\n위처럼 `maxDuration`을 5로 설정하면, 해당 서버 로직이 5초 이상 실행되지 않도록 제한할 것을 제안하게 되는 거예요.\n\n---\n\n### 보너스 팁!\n\n- **왜 실행 시간 제한이 중요할까?**  \n  서버 쪽 로직이 무한루프에 빠지거나 너무 오래 걸리면, 서버 자원을 낭비하고 사용자 경험도 악화돼요. 특히 서버리스 환경에서는 실행 시간이 길어질수록 비용이 더 발생할 수 있어서, 이런 제한을 두는 게 효율적이랍니다.\n\n- **`maxDuration`은 어디에 적용될까?**  \n  서버 컴포넌트의 렌더링 로직이나 API Route 핸들러 등, 서버에서 실행되는 모든 로직에 적용할 수 있어요.\n\n- **Next.js 버전 확인법**  \n  프로젝트에서 현재 사용하는 Next.js 버전을 확인하려면 `package.json` 파일에서 `next` 항목을 보면 되니 참고하세요!\n\n---\n\n혹시 여러분의 프로젝트에서 실행 시간이 너무 긴 서버 코드를 발견했다면, `maxDuration` 설정과 함께 코드를 최적화하는 걸 추천드려요. 작은 설정과 최적화가 서버 환경 전반의 효율성을 크게 올려준답니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003e 알아두면 좋은 점:  \n만약 Server Actions를 사용할 경우, 페이지 단위에서 maxDuration을 설정해서 해당 페이지 내 모든 Server Actions의 기본 타임아웃 시간을 변경할 수 있어요.\n\n### generateStaticParams\n\ngenerateStaticParams 함수는 동적 라우트 세그먼트와 함께 사용할 수 있는데요, 이 함수를 이용하면 빌드 시점에 정적으로 생성할 라우트 세그먼트 파라미터 리스트를 정의할 수 있어요.  \n즉, 요청할 때마다(dynamic하게) 생성하는 것이 아니라, 미리(static하게) 만들어 두는 거죠.\n\n이렇게 하면 빌드 시 미리 생성된 페이지 덕분에 사용자 경험이 더 빨라지고 서버 부하도 줄일 수 있어요.\n\n조금 더 자세한 내용은 공식 API 문서를 참고해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 버전 히스토리\n\n| Version         | 설명                                                                                                         |\n|-----------------|------------------------------------------------------------------------------------------------------------|\n| `v15.0.0-RC`    | `export const runtime = \"experimental-edge\"`가 deprecated 되었습니다. 이에 따른 코드 변경을 쉽게 해주는 [codemod](https://nextjs.org/docs/app/guides/upgrading/codemods#transform-app-router-route-segment-config-runtime-value-from-experimental-edge-to-edge)가 제공됩니다. |\n\n여기서 codemod란, 코드 변환을 자동으로 해주는 도구를 의미해요. 기존에 `experimental-edge`로 설정해둔 부분을 새로운 방식인 `edge`로 한 번에 바꿔주니까, 직접 손으로 일일이 수정할 필요가 없어서 편하답니다. 혹시 Next.js로 프로젝트를 진행 중이라면 이 부분 꼭 참고하세요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":18},{"title":"Next.js 15에서 route.js 파일 설정하는 방법","description":"","date":"2025-04-22 02:44","slug":"2025-04-22-routejs","content":"\n\n# route.js\n\nRoute Handlers는 특정 경로(route)에 대해 커스텀 요청 처리기를 만들 수 있게 해주는 기능이에요. 즉, 내가 원하는 경로에 맞춰서 요청(Request)과 응답(Response)을 직접 다룰 수 있게 해주죠. 이때 Web Request와 Response API를 활용해요.\n\n예를 들어, 아래처럼 GET 요청을 받았을 때 JSON 형태로 간단한 메시지를 응답하는 코드를 작성할 수 있어요:\n\n```js\nexport async function GET() {\n  return Response.json({ message: 'Hello World' });\n}\n```\n\n이 코드는 \"/route\" 같은 경로로 GET 요청이 들어오면 `{ message: 'Hello World' }`라는 JSON 데이터를 클라이언트에게 보내주는 역할을 해요. \n\n추가로 알아두면 좋은 점 몇 가지 알려드릴게요!\n\n- **Method별 함수 지원**: GET뿐 아니라 POST, PUT, DELETE 등 HTTP 메서드에 맞춰서 함수들을 만들 수 있어요.  \n- **내장 Response 객체 활용**: 위 예시처럼 `Response.json()` 메서드는 JSON 응답을 쉽게 만들어 주기 때문에 정말 편리해요.\n- **비동기 처리 가능**: 데이터베이스 조회나 외부 API 호출처럼 비동기가 필요한 작업도 `async/await` 패턴으로 자연스럽게 처리할 수 있어요.\n- **라우팅과 별개로 작동**: Next.js 같은 프레임워크에서는 보통 페이지 라우팅과 별개로 API 응답을 여기서 따로 관리할 수 있답니다!\n\n만약 좀 더 복잡한 요청 처리(예: 요청 본문 읽기, 헤더 조작 등)를 하고 싶다면, Request 객체를 받아 쓰면 됩니다. 예를 들어:\n\n```js\nexport async function POST(request) {\n  const body = await request.json();\n  return Response.json({ youSent: body });\n}\n```\n\n이렇게 하면 클라이언트가 보낸 데이터를 받아서 다시 돌려주는 간단한 POST 처리도 가능해요.\n\n---\n\n## 참고 자료\n\n- 공식 MDN 문서 - [Web Request and Response APIs](https://developer.mozilla.org/en-US/docs/Web/API/Request)\n- Next.js API Routes 공식 문서 (비슷한 개념으로 활용 가능)  \n- Response 객체 관련 문서: JSON 응답 생성 등 다양한 메서드 지원\n\n---\n\n간단하지만 강력한 route.js의 Route Handlers, 여러분의 서버 로직 구현에 꼭 활용해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### HTTP 메서드\n\n라우트 파일에서는 특정 경로(route)에 대해 커스텀 요청 핸들러를 만들 수 있어요. 즉, 클라이언트가 어떤 요청을 했는지에 따라 다르게 동작하도록 코드를 작성할 수 있다는 뜻이죠. 여기서 지원하는 HTTP 메서드는 GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS 이렇게 총 7가지에요.\n\n```js\nexport async function GET(request: Request) {}\n \nexport async function HEAD(request: Request) {}\n \nexport async function POST(request: Request) {}\n \nexport async function PUT(request: Request) {}\n \nexport async function DELETE(request: Request) {}\n \nexport async function PATCH(request: Request) {}\n \n// 만약 `OPTIONS` 메서드를 직접 정의하지 않으면,\n// Next.js가 자동으로 `OPTIONS` 메서드를 구현해주고,\n// Route Handler에 정의된 다른 메서드들을 기준으로 `Allow` 헤더를 설정해줍니다.\nexport async function OPTIONS(request: Request) {}\n```\n\n각 함수는 `Request` 객체를 받아서 비동기적으로 처리할 수 있는 함수예요. `Request` 객체를 통해 요청과 관련된 다양한 정보를 얻을 수 있답니다.\n\n#### 간단히 정리한 HTTP 메서드 역할\n\n| 메서드 | 설명 |\n|---|---|\n| GET | 서버에서 데이터를 읽어올 때 사용해요. 가장 기본적인 요청이죠. |\n| POST | 서버에 데이터를 새로 생성할 때 쓰여요. 예를 들어 회원가입 같은 요청이죠. |\n| PUT | 데이터를 통째로 수정할 때 사용해요. 기존 데이터를 전부 교체할 때 유용합니다. |\n| PATCH | 데이터의 일부만 수정할 때 사용해요. 수정할 부분만 보내면 되어서 효율적이죠. |\n| DELETE | 서버에서 데이터를 삭제할 때 쓰여요. |\n| HEAD | GET 요청과 비슷하지만 응답 본문(body)은 안 내려줘서 응답 헤더만 받고 싶을 때 유용해요. |\n| OPTIONS | 클라이언트가 해당 경로에서 어떤 메서드를 사용할 수 있는지 미리 물어볼 때 사용합니다. |\n\n\u003e **팁!** 실제 API 설계할 때는 각 메서드가 어떤 동작을 하는지 명확하게 구분해서 사용하는 게 좋아요. 그래야 클라이언트가 어떤 요청을 보내야 할지 헷갈리지 않고, 유지보수도 훨씬 쉬워집니다.\n\n다음에는 `Parameters`(매개변수) 부분에 대해 자세히 알아볼게요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### Next.js에서 NextRequest 활용하기 (feat. request 객체 이해하기)\n\nNext.js에서 API 라우트나 미들웨어를 만들 때, `request` 객체를 자주 다루게 되죠. 그런데 그냥 기본 Web Request API와는 조금 다른, Next.js만의 확장판인 `NextRequest`라는 객체가 있다고 해요.\n\n#### NextRequest란?\n\n`NextRequest`는 기본 Web Request 객체를 상속해서, 더 쉽고 편하게 쓸 수 있게 만든 Next.js 전용 객체입니다. 예를 들어, 쿠키를 꺼내거나, URL 정보를 다룰 때 훨씬 직관적이고 편리해요. `nextUrl`이라는 확장된 URL 객체가 포함되어 있어서, 이걸 활용하면 URL 조작도 손쉽답니다.\n\n#### 간단한 예제\n\n```ts\nimport type { NextRequest } from 'next/server'\n\nexport async function GET(request: NextRequest) {\n  // nextUrl을 통해 URL을 쉽게 접근 가능\n  const url = request.nextUrl\n\n  // 예: 쿼리 파라미터 출력해보기\n  console.log(url.searchParams.get('id'))\n\n  return new Response('Hello World')\n}\n```\n\n위 코드에서 `request.nextUrl`을 이용하면 URL 전체를 분석할 수 있고, `searchParams`로 쿼리도 쉽게 읽을 수 있어요. 만약 그냥 `request.url`을 쓰면 문자열 형태라, 직접 파싱을 해야 하니까 귀찮죠.\n\n#### NextRequest만의 꿀팁!\n\n- **쿠키 꺼내기**: `request.cookies.get('cookieName')`으로 바로 쿠키 값 꺼낼 수 있어요.\n- **헤더 접근**: `request.headers.get('headerName')` 작성법은 동일하지만, 실제로 다루기 더 깔끔해요.\n- **POST Body 읽기**: 비동기로 `request.json()` 같은 메서드를 사용해 JSON 본문을 바로 파싱할 수 있습니다.\n\n#### 마무리\n\nNext.js 13부터 등장한 이 `NextRequest` 객체는 서버 컴포넌트나 API 라우트, 미들웨어를 작성할 때 훨씬 편리하고 강력한 도구입니다. 기존의 Web Request 객체보다 기능이 많고, 특히 URL이나 쿠키 처리에 도움을 주니 꼭 활용해 보세요!\n\n궁금하면 Next.js 공식 문서에서 [`NextRequest`](https://nextjs.org/docs/api-reference/edge-runtime#nextrequest)도 참고해보시면 좋습니다.\n\n---\n\n필요하다면 다음에는 `NextResponse` 활용법도 소개할게요. 이걸로 응답을 쉽게 제어할 수 있답니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 Next.js의 동적 라우트에서 `params`가 어떻게 사용되는지 보여주는 코드 예제입니다. 이 때 `params`는 현재 라우트의 동적 경로 파라미터들을 담은 객체를 비동기적으로 반환하는 Promise입니다.\n\n```js\nexport async function GET(\n  request: Request,\n  { params }: { params: Promise\u003c{ team: string }\u003e }\n) {\n  const { team } = await params\n  // 이제 team 변수에 URL에서 전달된 동적 경로 파라미터가 들어있어요.\n}\n```\n\n예를 들어, 다음과 같은 라우트 구조와 URL 요청이 있을 때 `params`는 이렇게 들어옵니다:\n\n| Example                        | URL           | params                             |\n|-------------------------------|---------------|----------------------------------|\n| `app/dashboard/[team]/route.js` | `/dashboard/1` | `Promise\u003c{ team: '1' }\u003e`          |\n| `app/shop/[tag]/[item]/route.js` | `/shop/1/2`   | `Promise\u003c{ tag: '1', item: '2' }\u003e` |\n| `app/blog/[...slug]/route.js`    | `/blog/1/2`   | `Promise\u003c{ slug: ['1', '2'] }\u003e`    |\n\n여기서 `[team]`, `[tag]`, `[item]` 같은 부분이 동적 경로 파라미터를 나타내고, `[...,slug]`는 여러 경로 세그먼트를 배열 형태로 받을 때 사용합니다.\n\n### 덧붙여서\n\n- `params`가 Promise인 이유는 Next.js가 라우트의 데이터 패칭 시점에 비동기 처리를 하기 때문이에요. 그래서 항상 `await`을 사용해 값을 꺼내주어야 해요.\n- 동적 라우트를 사용할 땐, `params`에서 기대하는 속성명이 URL 안 동적 경로 이름과 정확히 일치하는지 꼭 확인해야 합니다.\n- 여러 개의 동적 파라미터가 있다면, 그 만큼 프로퍼티를 비동기로 받아서 처리할 수 있어요.  \n- 다중 세그먼트 캡쳐(`[...slug]`)는 블로그 포스트나 검색 결과처럼 URL 계층이 다양하게 바뀌는 경우에 유용합니다.\n\n이런 기본 개념만 잘 이해하면 Next.js의 동적 라우트는 크게 어렵지 않으니, 직접 여러가지 라우트를 만들어보면서 경험을 쌓아보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 쿠키 다루기\n\n```js\nimport { cookies } from 'next/headers'\n\nexport async function GET(request: NextRequest) {\n  const cookieStore = await cookies()\n\n  const a = cookieStore.get('a')       // 쿠키 'a' 값을 가져오기\n  const b = cookieStore.set('b', '1')  // 쿠키 'b'를 '1'로 설정하기\n  const c = cookieStore.delete('c')    // 쿠키 'c' 삭제하기\n}\n```\n\nNext.js의 `cookies()` 함수로 쉽게 쿠키를 가져오고 설정하고 삭제할 수 있어요. 여기서 중요한 건 `cookies()`가 비동기 함수라는 점인데, 그래서 `await`를 붙여줘야 제대로 값을 받을 수 있답니다.\n\n`cookieStore.get()`은 해당 이름의 쿠키 정보를 객체 형태로 줘요. 없으면 `undefined`를 반환하고요. `cookieStore.set()`은 새로운 쿠키를 추가하거나 기존 쿠키를 덮어씁니다. `cookieStore.delete()`는 지정한 쿠키를 삭제할 때 씁니다.\n\n클라이언트와 서버 모두 쿠키를 다루지만, Next.js API Route 혹은 Route Handler에서는 이렇게 `next/headers`에서 제공하는 함수를 활용하면 훨씬 간단해져서 좋아요!\n\n---\n\n## 버전 히스토리\n\n| Version         | Changes                                                                  |\n|-----------------|--------------------------------------------------------------------------|\n| `v15.0.0-RC`    | `context.params`가 이제 프로미스 형태로 바뀌었어요. [codemod](https://nextjs.org/docs/app/guides/upgrading/codemods#150) 도 제공됩니다. |\n| `v15.0.0-RC`    | `GET` 핸들러의 기본 캐싱 정책이 static에서 dynamic으로 변경됐습니다.          |\n| `v13.2.0`       | Route Handlers가 처음 소개되었습니다.                                     |\n\nNext.js는 계속 발전 중이라 버전마다 큰 변화가 있는데, 특히 Route Handler와 쿠키, 캐시 다루는 방식도 바뀌니 공식 문서를 챙겨보시는 걸 추천해요! 혹시 기존 코드를 15버전 이상으로 올리려면 codemod를 꼭 활용해보세요. 작업할 때 시간 많이 절약됩니다.","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":8},{"title":"Next.js 15에서 not-found.js로 404 페이지 쉽게 만드는 방법","description":"","date":"2025-04-22 02:43","slug":"2025-04-22-not-foundjs","content":"\n\n# not-found.js 파일 사용법 - Next.js에서 404 페이지 만들기\n\n안녕하세요! 오늘은 Next.js에서 사용자 정의 404 페이지를 만드는 방법을 소개할게요. `not-found.js` 파일을 사용하면, 특정 라우트(segment)에서 `notFound` 함수가 호출되었을 때 보여질 UI를 쉽게 꾸밀 수 있답니다.\n\n## 기본 개념\n\n- `not-found.js`는 라우트 내에서 `notFound()` 함수가 호출되는 경우, 그에 대한 UI를 렌더링해줍니다.\n- 스트리밍 응답(response)인 경우에는 HTTP 상태 코드가 200으로 반환되지만, 스트리밍이 아닌 일반 응답은 404 상태 코드를 반환합니다.\n- 즉, 사용자에게 맞춤형 404 페이지를 쉽게 제공하면서 백엔드의 응답 코드는 상황에 맞게 처리해줍니다.\n\n## 예제 코드\n\n아래는 아주 기본적인 `not-found.js` 파일 예제입니다.\n\n```jsx\nimport Link from 'next/link'\n \nexport default function NotFound() {\n  return (\n    \u003cdiv\u003e\n      \u003ch2\u003eNot Found\u003c/h2\u003e\n      \u003cp\u003eCould not find requested resource\u003c/p\u003e\n      \u003cLink href=\"/\"\u003eReturn Home\u003c/Link\u003e\n    \u003c/div\u003e\n  )\n}\n```\n\n- `\u003ch2\u003e` 태그로 큰 제목을, `\u003cp\u003e`로 간단한 안내 문구를 넣었고요.\n- `next/link`의 `Link` 컴포넌트를 사용해서 홈으로 돌아갈 수 있는 링크도 만들었어요.\n\n요렇게 하면, 사용자 경험을 높이는 맞춤형 404 페이지를 아주 쉽게 만들 수 있죠!\n\n## 추가 팁!\n\n- `not-found.js`는 라우트 폴더 바로 아래에 위치해야 작동해요. 예: `app/products/not-found.js`\n- 더 멋진 UI를 위해 스타일링 라이브러리(Tailwind CSS 등)를 활용해도 좋습니다.\n- 404 페이지에서 로그를 남기고 싶다면 컴포넌트 내에서 간단한 클라이언트 또는 서버 사이드 코드 작성도 가능해요.\n- Next.js 13 버전 이상의 앱 라우터(App Router) 환경에서만 동작하니 참고하세요!\n\n---\n\n다음에 더 재미있고 유용한 Next.js 팁으로 찾아올게요! 필요하면 댓글로 질문 남겨주세요~ 🙌\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### Props\n\nnot-found.js 컴포넌트는 아무런 props도 받지 않습니다.\n\n\u003e 알아두면 좋은 점: 예상되는 notFound() 오류를 잡아내는 것 외에도, 루트에 위치한 app/not-found.js 파일은 여러분 앱 전체에서 처리되지 않는 URL들도 다룹니다. 즉, 사용자가 여러분 앱 내에서 처리하지 않는 URL에 접속할 경우, app/not-found.js 파일에서 내보내는 UI가 보여지게 된다는 뜻이에요.\n\n## 예시\n\n(여기에는 실제 사용 예시나 코드가 들어가면 더 이해하기 좋겠죠? 만약 준비된 예시가 있다면 추가해보세요!) \n\n---\n\n이 부분을 보면 Next.js 13의 새로운 파일 기반 라우팅에서 404 페이지를 처리하는 방식을 알 수 있어요. 예전에는 별도의 error handling 코드를 많이 짰는데, 이제는 이처럼 not-found.js 파일 하나로 깔끔하게 처리할 수 있습니다. 그리고 루트 디렉토리의 app/not-found.js는 전체 앱에서 처리하지 못하는 URL에 대해서도 자동으로 404 페이지 역할을 하니까, 개발하면서 404 페이지를 따로 신경 쓰지 않아도 된다는 점이 정말 편리해요.\n\n더불어, 만약 특정 경로에서만 커스텀 404 페이지가 필요하다면 하위 폴더에 별도로 not-found.js를 만들어 적용할 수도 있다는 점, 알고 계시면 좋습니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 데이터 가져오기 (Data Fetching)\n\n기본적으로 `not-found` 컴포넌트는 서버 컴포넌트(Server Component)이에요. 하지만 이 컴포넌트를 `async`로 만들어 데이터를 받아오고 화면에 보여줄 수도 있답니다.\n\n아래 예시를 보면, `headers()`를 통해 요청 헤더에서 도메인 정보를 가져오고, 그 도메인에 맞는 데이터를 비동기로 받아와서 화면에 출력하는 모습이에요.\n\n```js\nimport Link from 'next/link'\nimport { headers } from 'next/headers'\n\nexport default async function NotFound() {\n  const headersList = await headers()\n  const domain = headersList.get('host')\n  const data = await getSiteData(domain)\n  return (\n    \u003cdiv\u003e\n      \u003ch2\u003eNot Found: {data.name}\u003c/h2\u003e\n      \u003cp\u003eCould not find requested resource\u003c/p\u003e\n      \u003cp\u003e\n        View \u003cLink href=\"/blog\"\u003eall posts\u003c/Link\u003e\n      \u003c/p\u003e\n    \u003c/div\u003e\n  )\n}\n```\n\n### 여기서 좀 더 알아두면 좋은 점!\n\n- `headers()` 함수는 서버에서 실행될 때만 사용할 수 있어요. 클라이언트에서 실행하면 동작하지 않으니 주의하세요.\n- 위 예시는 서버 컴포넌트에서 데이터를 가져오는 기본적인 패턴인데, 만약 `usePathname` 같은 클라이언트 훅을 써서 URL 경로에 따라 화면을 다르게 그리고 싶다면, 데이터를 클라이언트에서 가져와야 해요. 그러니까 클라이언트 컴포넌트로 만들어서 `useEffect` 같은 훅을 이용하는 거죠.\n- 서버 컴포넌트와 클라이언트 컴포넌트를 혼용할 때는 데이터를 어디서, 어떻게 가져올지 상황에 맞게 설계하는 게 중요합니다.\n\n즉, **비동기 데이터 페칭이 필요하다면 서버 컴포넌트에서 async 함수로 간단하게 처리할 수 있지만, 클라이언트 훅을 사용하고 싶다면 클라이언트 컴포넌트에서 처리하는 걸 기억하세요!**\n\n이해하기 어려운 부분이나 직접 써보고 싶은 팁 있으면 언제든 물어보세요 :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 버전 히스토리\n\n| 버전        | 변경 사항                                   |\n|-------------|--------------------------------------------|\n| `v13.3.0`   | 루트 `app/not-found`가 전역에서 매칭되지 않는 URL들을 처리하도록 변경됨. |\n| `v13.0.0`   | `not-found` 기능이 도입됨.                   |\n\n---\n\n여기서 `not-found`는 사용자 경험을 위해 웹사이트에서 404 페이지 같은 '찾을 수 없음' 페이지를 쉽게 구현할 수 있게 도와주는 기능이에요. 특히 `v13.3.0`에서는 앱의 루트 경로에서 전역적으로 매칭되지 않는 URL을 처리하도록 확장돼서, 여러분이 앱 내에서 예상치 못한 경로로 접근할 때도 깔끔하게 안내 페이지를 띄울 수 있답니다.\n\n웹 개발하면서 이런 '404페이지' 처리 중요하죠? 사용자가 잘못된 URL로 들어왔을 때 그냥 에러 메시지 띄우는 것보다 친절한 안내 페이지를 보여주는 게 훨씬 UX 측면에서 좋아요. Next.js 최신 버전들을 사용한다면 이런 기능들을 잘 활용해보세요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":5},{"title":"Next.js 15 page.js로 페이지 구성하는 방법","description":"","date":"2025-04-22 02:43","slug":"2025-04-22-pagejs","content":"\n\n# page.js 파일 이해하기\n\n이번에는 Next.js에서 route(경로)마다 고유한 UI를 정의할 수 있는 `page.js` 파일에 대해 이야기해볼게요. 간단히 말해서, 특정 경로에 연결되는 페이지 컴포넌트를 만들고 싶으면, 해당 경로 폴더 안에 `page.js` 파일을 만들고 기본 내보내기(default export)로 컴포넌트를 작성하면 됩니다.\n\n예를 들어, 이렇게 작성할 수 있어요:\n\n```js\nexport default function Page({\n  params,\n  searchParams,\n}: {\n  params: Promise\u003c{ slug: string }\u003e\n  searchParams: Promise\u003c{ [key: string]: string | string[] | undefined }\u003e\n}) {\n  return \u003ch1\u003eMy Page\u003c/h1\u003e\n}\n```\n\n- **params**: URL 경로의 동적 세그먼트(예: `/post/[slug]`에서 `slug` 값)를 받을 때 사용돼요.\n- **searchParams**: 쿼리 스트링에 포함된 키-값 쌍을 객체 형태로 받을 수 있어요.\n\n하지만 위 예제에서는 params와 searchParams 타입을 `Promise`로 감싸고 있는데, 이는 Next.js 13+에서 서버 컴포넌트가 비동기 작업을 할 수 있어서 그런 경우가 많아요.\n\n---\n\n## 여기서 알아두면 좋은 점들\n\n| 내용                     | 설명                                                                                      |\n|--------------------------|-------------------------------------------------------------------------------------------|\n| 기본 내보내기 필수        | `page.js`에 기본으로 export된 React 컴포넌트가 있어야 Next.js가 해당 페이지를 인식해요.       |\n| 서버 컴포넌트 기본 적용    | Next.js 13부터는 기본적으로 `page.js`는 서버 컴포넌트라서, 클라이언트 상태 관리가 필요하면 별도 설정 필요해요.(예: `'use client'` 선언) |\n| 동적 라우팅 지원          | `params`를 통해 동적 경로 세그먼트를 쉽게 받아올 수 있어 동적인 페이지 구현이 편리해졌어요.       |\n| 쿼리 파라미터 사용법      | `searchParams`로 URL에 전달된 쿼리 파라미터를 받을 수 있어, 필터링이나 검색 기능 구현 가능해요.   |\n\n---\n\n### 추가 팁! \n\n- **`'use client'` 선언**  \n  만약 해당 `page.js` 안에서 `useState`, `useEffect` 같은 클라이언트 전용 API를 사용한다면, 파일 최상단에 `'use client'`를 꼭 작성해 줘야 해요. 그래야 Next.js가 클라이언트 컴포넌트로 취급합니다.\n\n- **비동기 컴포넌트**  \n  위 코드처럼 파라미터가 `Promise`로 되어 있다면, 컴포넌트를 `async` 함수로 만들어서 데이터를 서버에서 직접 fetch하거나 처리할 수도 있어요.\n\n- **파일 위치에 따른 라우팅**  \n  `app` 디렉터리 구조에 따라서 자동으로 URL 경로가 결정되니까, 폴더 이름과 파일 이름이 곧 URL이 된다고 생각하면 편합니다.\n\n---\n\n`page.js`를 활용하면 각 경로별로 독립적인 UI 및 데이터 처리가 매우 편리해져서, Next.js의 강력한 기능을 실제 프로젝트에 잘 녹여내는 데 큰 도움이 됩니다!\n\n한번 직접 만들어 보면서 익혀보시길 추천드려요 :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번 글에서는 Next.js에서 페이지 파일과 라우팅에 대해 간단하게 정리해볼게요. 주로 `.js`, `.jsx`, `.tsx` 확장자를 가진 파일들이 페이지로서 사용되는데, 이 부분부터 시작해봅시다.\n\n---\n\n### Next.js 페이지 파일 정리\n\n- **페이지 확장자**  \n  `.js`, `.jsx`, `.tsx` 확장자가 페이지 파일로 사용됩니다.  \n  즉, 이 파일들을 `pages` 디렉토리나 앱 디렉토리(route segment) 안에 넣으면 해당 파일이 하나의 페이지로 처리돼요.\n\n- **페이지가 항상 라우트 트리의 '리프(leaf)'이다**  \n  이 말은, 페이지가 최종적으로 도착하는 경로의 끝부분(리프 노드)이란 뜻입니다.  \n  중간 경로(segment)는 레이아웃이나 다른 로직을 담당하고, 실제 화면에 그려지는 페이지는 트리의 가장 끝에 있어요.\n\n- **라우트 세그먼트를 공개하려면 페이지 파일이 필수!**  \n  어떤 경로(segment)를 외부에서 접근 가능하게 만들려면 해당 위치에 페이지 파일이 꼭 필요합니다.  \n  페이지 파일이 없다면 그 경로는 사용자에게 보여지지 않아요.\n\n- **페이지는 기본적으로 서버 컴포넌트(Server Components)**  \n  Next.js 13부터는 페이지가 서버 컴포넌트로 기본 설정되어 있어 서버에서 렌더링됩니다.  \n  하지만 필요에 따라 클라이언트 컴포넌트(Client Component)로 설정할 수도 있어, 인터랙티브한 UI가 필요할 때는 클라이언트 컴포넌트로 바꿔주면 됩니다.\n\n---\n\n### 참고: Props 중 params\n\n페이지 컴포넌트에 전달되는 `params`는 선택 사항이며, 동적 라우팅에 많이 사용됩니다.  \nURL 경로에서 동적 세그먼트를 추출해 매개변수로 전달해주기 때문에, 예를 들어 블로그 글 ID 같은 값을 받아 처리할 때 유용하죠.\n\n---\n\n### 추가로 알아두면 좋은 점들\n\n- **서버 컴포넌트 vs 클라이언트 컴포넌트**  \n  - 서버 컴포넌트는 초기 렌더링 속도가 빠르고 SEO에 유리하며, 서버에서만 실행됩니다.  \n  - 클라이언트 컴포넌트는 사용자 인터랙션, 상태 관리, 이벤트 핸들러에 필요하지만, 번들 크기가 커질 수 있으니 꼭 필요한 곳에만 사용하세요.\n\n- **_app.js, _document.js 같은 특수 파일은 pages 디렉토리에서만 사용 가능하다?**  \n  Next.js의 앱 라우팅 시스템과 기존 pages 시스템은 약간 다르기 때문에 혼동될 수 있습니다. 만약 최신 앱 디렉토리를 사용하고 있다면, 그에 맞게 구조를 잡아야 해요.\n\n---\n\n다음에도 Next.js 라우팅이나 페이지 관련 정보를 더 쉽게 풀어서 알려드릴게요! 필요하면 댓글로 궁금한 점 주세요! 😊\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n루트 세그먼트부터 해당 페이지까지 전달되는 동적 라우트 파라미터들을 담고 있는 객체를 반환하는 Promise에 대해 살펴볼게요.\n\n```js\nexport default async function Page({\n  params,\n}: {\n  params: Promise\u003c{ slug: string }\u003e\n}) {\n  const { slug } = await params\n}\n```\n\n여기서 `params`는 Promise 형태로 넘어오기 때문에, 값을 얻어내려면 꼭 `async/await`을 써야 합니다. 혹은 React의 use 함수와 같은 방법을 써도 좋아요.\n\n아래는 동적 라우팅에 따른 `params` 값 예시입니다.\n\n| Example Route                      | URL        | params                          |\n|----------------------------------|------------|--------------------------------|\n| `app/shop/[slug]/page.js`         | `/shop/1`  | `Promise\u003c{ slug: '1' }\u003e`        |\n| `app/shop/[category]/[item]/page.js` | `/shop/1/2` | `Promise\u003c{ category: '1', item: '2' }\u003e` |\n| `app/shop/[...slug]/page.js`      | `/shop/1/2` | `Promise\u003c{ slug: ['1', '2'] }\u003e` |\n\n---\n\n참고로, Next.js 14버전까지는 `params`가 동기 프로퍼티였어요. 그래서 바로 접근 가능했죠. 근데 Next.js 15부터는 이게 Promise 형태가 됐습니다. 아직 15버전에서는 예전처럼 동기적으로 접근해도 동작하지만, 앞으로는 deprecated(사용 중단 예정)이 될 거니까 미리 `async/await` 패턴으로 바꾸는 게 좋아요.\n\n추가 팁을 드리자면, 동적 라우팅에서 여러 개의 파라미터가 있을 때는 `params` 객체에 그 이름대로 키가 잡히고, catch-all 라우트(`[...slug]`)처럼 경로의 여러 값을 배열로 받을 때도 있으니 구조 분해할 때 조심하세요.\n\n요약하자면,\n\n- Next.js 15부터 `params`는 Promise다.\n- `async/await`나 React의 use 함수로 값을 받아야 한다.\n- 기존 동기 접근은 당분간 유지되지만, 곧 없어질 예정이다.\n\n이 점만 기억하면 동적 라우팅을 다룰 때 좀 더 깔끔하고 미래에도 문제없는 코드를 작성할 수 있을 거예요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n#### searchParams (선택 사항)\n\n`searchParams`는 현재 URL의 쿼리 파라미터를 담고 있는 객체로, Promise 형태로 전달됩니다. 예를 들어, 이렇게 받아올 수 있죠:\n\n```js\nexport default async function Page({\n  searchParams,\n}: {\n  searchParams: Promise\u003c{ [key: string]: string | string[] | undefined }\u003e\n}) {\n  const filters = (await searchParams).filters;\n}\n```\n\n예를 들어 URL이 `/shop?a=1`이라면 `searchParams`는 `{ a: '1' }`라는 객체를 Promise로 감싸 전달합니다.\n\n| 예시 URL           | searchParams 타입              |\n|------------------|------------------------------|\n| `/shop?a=1`       | `Promise\u003c{ a: '1' }\u003e`         |\n| `/shop?a=1\u0026b=2`   | `Promise\u003c{ a: '1', b: '2' }\u003e` |\n| `/shop?a=1\u0026a=2`   | `Promise\u003c{ a: ['1', '2'] }\u003e`  |\n\n여기서 중요한 점은, 같은 키에 여러 값이 있을 때는 배열 형태로 받아온다는 거예요. (예: `?a=1\u0026a=2`)\n\n---\n\n추가 팁을 하나 드리자면, 이 `searchParams`를 활용해 필터링 기능이나 페이징 같은 걸 페이지에서 직접 다룰 수 있어서, 서버에서 별도 처리를 하지 않고도 쿼리 기반 UI를 손쉽게 만들 수 있습니다. Next.js 13 이상 같은 최신 프레임워크에서 특히 유용한 패턴이니, 꼭 기억해두세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 내용은 Next.js의 `searchParams` prop 사용법에 관한 업데이트를 다루고 있는데요, 쉽게 말해서 `searchParams`가 이제는 Promise 형태라는 점을 기억해 두셔야 합니다. 예전(버전 14 이하)에는 동기적으로 바로 접근할 수 있었지만, 버전 15부터는 비동기적으로 값을 받아야 하므로 `async/await`이나 React의 비동기 훅을 꼭 써야 한다는 뜻이죠.\n\n---\n\n### 주요 포인트 정리\n\n| 내용 | 설명 |\n|-------|---------|\n| `searchParams`가 Promise 형태 | `searchParams`가 비동기 값이 되었어요. 따라서 값을 사용할 때 꼭 `await`를 사용하거나 비동기 훅을 사용하세요. |\n| 이전 버전과의 호환성 | Next.js 15에서는 이전처럼 동기적으로 접근 가능하지만, 앞으로는 지원이 끊깁니다. 지금부터는 비동기로 처리하는게 안전해요. |\n| 동적 API | `searchParams`는 동적인 API라서 해당 값을 미리 알 수 없고, 이를 쓰면 서버가 요청 시점에 페이지를 렌더링 합니다. 따라서 빌드 타임에 완전히 고정된 페이지는 아니게 돼요. |\n| 객체 형태 | `searchParams`는 `URLSearchParams` 인스턴스가 아니라 일반 자바스크립트 객체입니다. 즉, 메서드 같은 건 없고 단순 키-값 쌍이에요. |\n\n---\n\n### 좀 더 쉽게 이해할 수 있는 예시\n\n만약 URL에 `?category=books`라는 쿼리파라미터가 붙었다고 해볼게요. 기존에는 이렇게 바로 썼겠죠?\n\n```js\nfunction Page({ searchParams }) {\n  console.log(searchParams.category);\n  return \u003cdiv\u003e{searchParams.category}\u003c/div\u003e;\n}\n```\n\n하지만 이제는 이렇게 바꿔야 합니다.\n\n```js\nasync function Page({ searchParams }) {\n  const params = await searchParams;\n  console.log(params.category);\n  return \u003cdiv\u003e{params.category}\u003c/div\u003e;\n}\n```\n\n또는 React의 `useEffect`를 쓰는 컴포넌트 안이라면:\n\n```js\nfunction PageWrapper() {\n  const [category, setCategory] = React.useState(null);\n\n  React.useEffect(() =\u003e {\n    async function getParams() {\n      const params = await searchParams;\n      setCategory(params.category);\n    }\n    getParams();\n  }, []);\n\n  return \u003cdiv\u003e{category ? category : '로딩중...'}\u003c/div\u003e;\n}\n```\n\n---\n\n### 정리하며\n\n- Next.js 15부터는 `searchParams`가 비동기로 바뀌었으니, `await` 안 쓰면 제대로 된 값 못 받아요.  \n- 이번 업데이트로 인해 약간의 코드 수정이 필요하지만, 동적 쿼리에 더 유연하게 대응할 수 있어져서 좋은 점도 많아요.  \n- 참고로, `searchParams`는 그냥 키-값 객체라서 `get()` 이런 메서드는 없습니다.\n\n---\n\n앞으로 쿼리파라미터를 다룰 때 이 점 꼭 기억하시고 미리 준비해두세요! 개발할 때 예상치 못한 비동기 문제에 걸려서 당황하는 일이 크게 줄어들 거예요. 혹시 동적 라우팅이나 쿼리 데이터 처리에 대해 더 궁금한 점 있으면 언제든지 알려주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js의 새로운 app 폴더 구조에서는 페이지 컴포넌트에 `params`와 `searchParams`를 props로 전달할 수 있어요. 이걸 활용하면 동적 경로나 쿼리스트링을 쉽게 처리할 수 있답니다.\n\n먼저, `params`를 이용한 예제부터 볼게요. 아래 코드에서 `params`는 URL의 동적 세그먼트(예: `/blog/[slug]`의 slug)를 의미해요.\n\n```js\nexport default async function Page({\n  params,\n}: {\n  params: Promise\u003c{ slug: string }\u003e\n}) {\n  const { slug } = await params\n  return \u003ch1\u003eBlog Post: {slug}\u003c/h1\u003e\n}\n```\n\n여기서 주목할 부분은 `params`가 Promise 형태라는 것! 그래서 `await`으로 먼저 값을 꺼내줘야해요. 이렇게 하면 URL에 따라 각기 다른 블로그 포스트를 보여줄 수 있죠.\n\n---\n\n다음은 `searchParams`를 이용해서 URL 쿼리스트링을 가져오는 방법이에요. 예를 들어, `?page=2\u0026sort=desc\u0026query=apple` 같은 쿼리가 있을 때 유용하죠.\n\n```js\nexport default async function Page({\n  searchParams,\n}: {\n  searchParams: Promise\u003c{ [key: string]: string | string[] | undefined }\u003e\n}) {\n  const { page = '1', sort = 'asc', query = '' } = await searchParams\n \n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003eProduct Listing\u003c/h1\u003e\n      \u003cp\u003eSearch query: {query}\u003c/p\u003e\n      \u003cp\u003eCurrent page: {page}\u003c/p\u003e\n      \u003cp\u003eSort order: {sort}\u003c/p\u003e\n    \u003c/div\u003e\n  )\n}\n```\n\n`searchParams` 역시 Promise 형태라서 `await` 해준 뒤 각 파라미터를 디폴트값과 함께 받는 게 좋아요. 이렇게 하면 필터링, 페이지네이션, 정렬 같은 작업을 쉽게 처리할 수 있어요.\n\n---\n\n### 추가 팁\n\n- `params`는 동적 라우팅에서만 전달되고, `searchParams`는 URL의 쿼리스트링이 있을 때만 의미가 있습니다.\n\n- 쿼리파라미터가 배열 형태일 수도 있으니, 타입을 `{ [key: string]: string | string[] | undefined }` 같이 지정해주는 게 좋아요.\n\n- `await`을 꼭 사용해야 하는데, async 함수인 점을 잊지 마세요!\n\n- 실제로는 데이터를 서버에서 가져오는 코드와 결합해서 화면에 뿌리는 경우가 많아요. 이 부분만 분리해서 써도 Next.js의 라우팅과 데이터 패칭이 간단해집니다.\n\n이제 Next.js의 새 라우팅 방식으로 더 편리한 동적 페이지와 쿼리 처리 구현해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 클라이언트 컴포넌트에서 searchParams와 params 읽기\n\nNext.js 13의 앱 라우팅에서는 클라이언트 컴포넌트(Client Component)에서는 `async` 함수를 사용할 수 없기 때문에, `searchParams`와 `params`처럼 비동기 데이터를 직접 받아서 처리하는 데 약간의 꼼수가 필요합니다.\n\n바로 React 18에서 도입된 `use` 훅을 활용하면, 비동기 `Promise` 형태로 전달되는 `params`와 `searchParams`를 간단히 읽을 수 있어요.\n\n```jsx\n'use client'\n\nimport { use } from 'react'\n\nexport default function Page({\n  params,\n  searchParams,\n}: {\n  params: Promise\u003c{ slug: string }\u003e\n  searchParams: Promise\u003c{ [key: string]: string | string[] | undefined }\u003e\n}) {\n  const { slug } = use(params)\n  const { query } = use(searchParams)\n\n  // 이 시점에서는 slug와 query가 실제 데이터로 변환되어 사용 가능\n}\n```\n\n여기서 중요한 점은 `params`와 `searchParams`가 `Promise`로 전달된다는 것입니다. 그래서 이걸 바로 읽기 위해 `use(params)`, `use(searchParams)`를 사용하는 거죠. 이렇게 하면 동기적으로 사용할 수 있어서, 클라이언트 컴포넌트에서도 자연스럽게 데이터를 사용할 수 있습니다.\n\n\u003e 참고로, `use` 훅은 아직 실험적인 기능이라서 프로젝트 환경이나 React 버전에 따라 다소 차이가 있을 수 있으니, 최신 공식 문서나 Next.js 업데이트를 꼭 확인하는 게 좋아요.\n\n---\n\n## 버전 히스토리\n\n| 버전  | 내용                                         |\n|-------|----------------------------------------------|\n| 13.4  | 클라이언트 컴포넌트에서 `use` 훅을 활용해 `params`와 `searchParams`를 쉽게 읽을 수 있는 기능 추가 |\n| -     | `use` 훅은 React 18의 실험적 기능으로서, 점차 안정화 중                  |\n\n---\n\n개발하면서 이런 작은 변화들이 실제 코드 작성 방식을 많이 바꾸는데요, 특히 Next.js처럼 SSR과 클라이언트 렌더링이 섞여 있는 환경에서는 비동기 데이터 처리 방법이 중요해집니다. 앞으로도 새로운 React 기능이나 Next.js 업데이트 소식 공유할게요! 도움이 되셨다면 댓글로 남겨주세요 :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n| Version      | Changes                                                                                   |\n|--------------|-------------------------------------------------------------------------------------------|\n| `v15.0.0-RC` | `params`와 `searchParams`가 이제 Promise로 바뀌었어요. 관련해서 [codemod](https://nextjs.org/docs/app/guides/upgrading/codemods#150) 도 준비되어 있으니 참고하세요! |\n| `v13.0.0`    | `page`가 도입되었습니다.                                                                  |\n\n요즘 Next.js 업데이트 소식 전해드릴게요! 특히 `v15.0.0-RC`부터는 `params`와 `searchParams`가 비동기 처리 방식으로 바뀌어서, 기존 코드에선 약간의 수정이 필요해요. 다행히 공식에서 자동으로 코드를 바꿔주는 codemod 도구를 제공하고 있어서, 크게 어렵지 않게 적용할 수 있답니다.\n\n또, 좀 더 기본적인 부분으로 돌아가 보면 `v13.0.0`에서는 이제 `page`가 도입되었는데요, Next.js 사용하시면서 페이지 단위로 구조를 잡을 때 참고하시면 좋아요. 버전 바뀔 때마다 새로운 기능이 추가되니, 자주 공식 문서 한번씩 훑어보는 걸 추천드려요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":13},{"title":"Next.js 15 로딩 컴포넌트 만들기 (loading.js)","description":"","date":"2025-04-22 02:41","slug":"2025-04-22-loadingjs","content":"\n\n# loading.js 소개\n\n이번에는 React에서 사용할 수 있는 `loading.js` 파일에 대해 이야기해볼게요. 이 파일은 Suspense를 활용해서 **즉각적인 로딩 상태**를 만들어 주는 역할을 해요.\n\n기본적으로는 서버 컴포넌트(Server Component)로 작동하지만, 필요에 따라 `\"use client\"` 지시어를 붙여서 클라이언트 컴포넌트(Client Component)로도 쓸 수 있답니다.\n\n---\n\n## 예시 코드\n\n```js\nexport default function Loading() {\n  // 또는 내가 만든 커스텀 로딩 스켈레톤 컴포넌트를 넣어줄 수도 있어요\n  return \u003cp\u003eLoading...\u003c/p\u003e;\n}\n```\n\n### 좀 더 쉽게 설명하자면?\n\n이 파일을 만들어 놓으면 페이지 혹은 컴포넌트가 로딩될 때, 사용자에게 “로딩 중입니다” 같은 상태를 바로 보여줄 수 있어 UX가 훨씬 좋아지죠. Suspense가 컴포넌트를 렌더링하는 동안 이 `Loading` 컴포넌트를 잠시 보여주는 식이에요.\n\n### 꿀팁: 커스텀 로딩 UI 만들기\n\n간단한 텍스트 대신에 애니메이션이 들어간 스켈레톤 UI나 뼈대 화면을 만들어서 넣으면 더 자연스럽고 프로답게 보일 수 있어요. React의 `react-loading-skeleton` 라이브러리를 사용해도 좋고, CSS 애니메이션으로 직접 꾸며줄 수도 있답니다.\n\n---\n\n그럼 다음에는 Suspense랑 함께 이 `loading.js`를 어떻게 더 멋지게 활용하는지도 같이 알아볼게요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n로딩 UI 컴포넌트는 어떤 파라미터도 받지 않는다는 점, 알아두면 좋아요.\n\n\u003e 참고 팁:\n로딩 UI를 설계할 때 React Developer Tools를 이용하면 Suspense 경계(boundary)를 수동으로 토글해보면서 동작을 확인하는 데 큰 도움이 됩니다.\n\n## 버전 히스토리\n\n| 버전       | 변경 사항              |\n|------------|-----------------------|\n| `v13.0.0`  | `loading` 컴포넌트 도입 | \n\n추가로, 로딩 UI는 사용자 경험에서 정말 중요한 부분이에요. 너무 짧게 보여주면 깜빡이는 느낌이 들 수 있고, 너무 길면 지루한 느낌을 줄 수 있거든요. 그래서 React Suspense와 함께 사용할 때는 로딩 컴포넌트를 잘 활용해서 자연스러운 화면 전환 효과를 만드는 게 중요해요. React Developer Tools로 직접 토글해보면서 그런 느낌을 체험해 보세요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":2},{"title":"Next.js 15에서 mdx-components.js로 커스텀 MDX 컴포넌트 만드는 방법","description":"","date":"2025-04-22 02:41","slug":"2025-04-22-mdx-componentsjs","content":"\n\n# mdx-components.js (또는 .tsx) 파일 소개\n\nNext.js에서 `@next/mdx`와 App Router를 함께 사용할 때, `mdx-components.js` (또는 `mdx-components.tsx`) 파일은 꼭 필요한 친구예요. 이 파일이 없으면 MDX를 제대로 쓸 수 없거든요. 게다가 이 파일을 활용하면 MDX 내에서 사용하는 컴포넌트들의 스타일이나 동작을 커스터마이징할 수도 있답니다!\n\n---\n\n## 위치는 어디에?\n\n- 프로젝트 루트 바로 아래에 둬요.  \n- 예를 들어, `pages` 또는 `app` 폴더와 같은 레벨에 (또는 `src` 폴더 안에) 두면 좋아요.\n\n---\n\n## 기본적인 작성법\n\n```tsx\nimport type { MDXComponents } from 'mdx/types'\n\nexport function useMDXComponents(components: MDXComponents): MDXComponents {\n  return {\n    ...components,\n  }\n}\n```\n\n이 코드는 기본 설정으로 컴포넌트들을 그대로 반환하는 역할을 해요. 여기서 `components`에 우리가 직접 만든 커스텀 컴포넌트들을 덮어씌워서 스타일이나 기능을 내가 원하는 대로 바꿀 수 있죠.\n\n---\n\n## 실제로 커스텀 해보기\n\n예를 들어, MDX 안에서 `\u003ch1\u003e` 태그의 스타일을 바꾸고 싶다면 이렇게 작성할 수 있어요:\n\n```tsx\nimport type { MDXComponents } from 'mdx/types'\n\nconst MyH1 = (props) =\u003e \u003ch1 style={{ color: 'tomato', fontSize: '2.5rem' }} {...props} /\u003e\n\nexport function useMDXComponents(components: MDXComponents): MDXComponents {\n  return {\n    h1: MyH1,\n    ...components,\n  }\n}\n```\n\n이렇게 하면 MDX 파일 내 `\u003ch1\u003e` 태그가 모두 토마토색 큰 글씨로 바뀌죠.\n\n---\n\n## 참고! 왜 이걸 쓰는 걸까?\n\nMDX 안에는 기본 HTML 태그뿐만 아니라, React 컴포넌트도 자유롭게 넣을 수 있어요. 예를 들어 버튼, 카드, 또는 특별한 레이아웃 컴포넌트 등이죠. 이걸 한 번에 관리하고 싶다면 이 `mdx-components` 파일을 활용해서 확장하거나 수정하는 게 가장 깔끔하답니다.\n\n---\n\n**정리하자면**, `mdx-components.js`(또는 `.tsx`)는 Next.js + MDX 환경에서 커스텀 컴포넌트를 선언하고 스타일을 조절하는 중요한 허브 역할을 하니 꼭 기억하세요! 프로젝트에서 MDX를 쓴다면 이 친구는 필수랍니다 :)\n\n---\n\n필요하면 나중에 커스텀 컴포넌트를 더 만드는 법도 알려드릴게요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Exports\n\n### useMDXComponents 함수\n\n이 파일은 하나의 함수만 내보내야 해요. 기본 내보내기(default export)로 하거나 `useMDXComponents`라는 이름으로 내보낼 수 있죠.\n\n```js\nimport type { MDXComponents } from 'mdx/types'\n\nexport function useMDXComponents(components: MDXComponents): MDXComponents {\n  return {\n    ...components,\n  }\n}\n```\n\n\u003e 여기서 `useMDXComponents` 함수는 MDX 컴포넌트를 커스터마이징할 때 유용해요. 예를 들어, 기본 제공되는 MDX 컴포넌트를 당신만의 스타일이나 새로운 컴포넌트로 대체하고 싶을 때 이 함수를 사용하죠.  \n\u003e 그리고 `components` 객체를 받아 그대로 돌려주고 있는데, 필요하면 여기에 새로운 컴포넌트를 추가하거나 기존 컴포넌트를 덮어씌우는 작업도 할 수 있어요.  \n\u003e\n\u003e 간단한 예를 들어볼게요:  \n\u003e js\n\u003e export function useMDXComponents(components) {\n\u003e   return {\n\u003e     h1: (props) =\u003e \u003ch1 style={{ color: 'tomato' }} {...props} /\u003e,\n\u003e     ...components,\n\u003e   }\n\u003e }\n\u003e \n\u003e 이렇게 하면 MDX 내의 모든 `h1` 태그는 토마토색 글씨로 표시되겠죠!   \n\u003e  \n\u003e MDX로 콘텐츠 작업할 때 아주 많이 쓰이는 패턴입니다.  \n\u003e 필요에 따라 잘 커스터마이징해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Params\n\n### components\n\nMDX 컴포넌트를 정의할 때, export 함수는 단일 파라미터인 `components`를 받습니다. 이 `components`는 `MDXComponents` 타입의 인스턴스인데요.\n\n- **키(key)**는 대체하고자 하는 HTML 태그 이름을 의미합니다.  \n- **값(value)**은 해당 HTML 태그 대신 렌더링할 컴포넌트를 지정하는 거죠.\n\n즉, 기본 HTML 요소를 내 마음대로 바꾸고 싶을 때 유용하게 쓸 수 있습니다. 예를 들어, `\u003ch1\u003e` 태그를 나만의 스타일이 입혀진 헤딩 컴포넌트로 교체할 수도 있고, `\u003ca\u003e` 태그를 커스텀 링크 컴포넌트로 바꿔서 새 창 열기 같은 기능을 쉽게 추가할 수도 있답니다.\n\n이걸 활용하면 MDX 문서 내에서 일관된 UI를 손쉽게 유지할 수 있고, 스타일이나 동작도 프로젝트에 맞게 맞춤 설정할 수 있어요! 많이 써먹어보세요~\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003e 참고할 점: 오버라이드가 없는 다른 컴포넌트들도 모두 전달해주는 것(즉, ...components)을 잊지 마세요.\n\n## 버전 히스토리\n\n| Version     | Changes           |\n|-------------|-------------------|\n| `v13.1.2`   | MDX 컴포넌트 추가 | \n\n여기서 MDX 컴포넌트란, Markdown과 React 컴포넌트를 함께 쓸 수 있게 해주는 기능이에요. 프로젝트에서 문서나 블로그 작성할 때 훨씬 유용하게 쓰이니까 꼭 한 번 써보시길 추천합니다!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":4},{"title":"Next.js 15에서 Middleware.js로 서버 데이터 처리하는 방법","description":"","date":"2025-04-22 02:41","slug":"2025-04-22-middlewarejs","content":"\n\n# middleware.js란?\n\nmiddleware.js(또는 middleware.ts)는 서버에서 요청이 완료되기 전에 중간에 끼어들어 특정 코드를 실행할 수 있도록 도와주는 파일이에요. 즉, 클라이언트가 서버에 요청을 보내면, 해당 요청을 처리하기 전에 이 미들웨어가 먼저 동작하게 되죠.\n\n이걸 쓰면 어떻게 좋냐고요? 예를 들어, 들어오는 요청에 따라 응답을 바꾸거나 리다이렉트 시키거나, 요청이나 응답 헤더를 수정하는 일이 가능해요. 심지어는 바로 응답을 보내버릴 수도 있답니다!\n\n미들웨어는 라우트가 렌더링되기 전에 작동하기 때문에, 인증(auth) 처리, 로깅(logging), 그리고 복잡한 리다이렉트 같은 서버 사이드 로직을 구현할 때 아주 유용하게 쓰여요.\n\n보통 프로젝트 루트에 `middleware.ts` 또는 `middleware.js` 파일을 만들어서 정의합니다. 이 위치는 `app`이나 `pages` 폴더와 같은 수준이거나, `src` 폴더 안일 수도 있어요.\n\n---\n\n### 참고로!\n\n- 미들웨어에서는 **응답을 직접 반환**하면 그 뒤에 라우트 렌더링은 안 되고, 그냥 그 응답이 바로 전송돼요.\n- 요청을 **리라이트(rewrite)** 하면 내부 경로 변경이, **리다이렉트(redirect)** 하면 클라이언트에게 다른 주소로 이동하라고 지시하는 의미예요.\n- 요청이나 응답 헤더를 자유롭게 조작할 수 있으니, 예를 들어 사용자 에이전트(user-agent)를 검사하거나 쿠키 작업도 가능합니다.\n\n이러면 서버가 좀 더 똑똑해지고, 클라이언트에 맞춤형 응답을 줄 수 있어요!\n\n---\n\n필요하시다면 다음 글에서는 실제 코드 예제와 함께 미들웨어의 구체적인 사용법도 다뤄볼게요~!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 middleware 작성할 때 기본적으로 export하는 함수는 단 하나여야 한다는 점, 알고 계셨나요? 오늘은 그 부분을 중심으로 간단하게 설명해 보려고 해요.\n\n```js\nimport { NextResponse, NextRequest } from 'next/server'\n \n// 이 함수는 요청을 가로채서 /about 경로 하위에 있는 모든 경로 요청을 /home 으로 리다이렉트 해줘요.\nexport function middleware(request: NextRequest) {\n  return NextResponse.redirect(new URL('/home', request.url))\n}\n \nexport const config = {\n  matcher: '/about/:path*',\n}\n```\n\n위 코드에서 핵심은 `middleware` 함수 하나만 export 하고 있다는 거예요. Next.js는 한 파일에서 여러 미들웨어 함수를 내보내는 것을 지원하지 않아요. 따라서 두 개 이상의 미들웨어가 필요한 경우엔 각각 따로 파일을 만들어야 하죠.\n\n그리고, `config` 객체의 `matcher` 속성은 어떤 경로에 이 미들웨어를 적용할지 정해주는 역할을 해요. 여기서는 `/about/` 경로 이하 모든 경로를 지정했죠. 참고로 `:path*` 부분은 와일드카드 같은 역할을 해서 하위 경로 전체를 포괄할 수 있어요.\n\n### 정리하면\n\n| 항목                 | 설명                                                  |\n|--------------------|-----------------------------------------------------|\n| 미들웨어 함수          | 꼭 하나만 export 해야 한다                               |\n| `matcher` 설정        | 어떤 URL 패턴에 대해 미들웨어를 실행할지 지정               |\n| 리다이렉션 처리         | `NextResponse.redirect` 로 요청을 원하는 경로로 보낼 수 있다  |\n\n이런 룰들은 Next.js 내부에서 미들웨어 처리 방식을 단순화하고, 성능 최적화를 위한 부분이에요. 프로젝트 설계 시 이 점 꼭 기억해 두시면 쓸데없는 에러를 예방할 수 있답니다.\n\n또한, 만약 복잡한 미들웨어 로직이 필요하다면 여러 파일로 분리하거나, 환경변수에 따라 미들웨어를 다르게 실행하도록 코드를 짜는 것도 좋은 전략이에요. \n\n다음에는 미들웨어에서 자주 쓰이는 다른 기능들도 한번 같이 살펴봐요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n// 기본 export 예제\nexport default function middleware(request) {\n  // 미들웨어 로직 작성\n}\n```\n\n### config 객체 (선택 사항)\n\n미들웨어 함수와 함께 config 객체를 export할 수도 있어요. 이 객체 안에는 `matcher`가 들어가는데, 이 matcher를 통해 미들웨어가 적용될 경로를 지정할 수 있습니다.\n\n#### matcher\n\nmatcher는 미들웨어가 실행될 URL 경로나 패턴을 지정하는 역할을 해요. 예를 들어, 특정 경로나 API 엔드포인트에만 미들웨어가 동작하도록 설정할 수 있죠.\n\n```js\nexport const config = {\n  matcher: ['/about/:path*', '/dashboard/:path*'],\n};\n```\n\n위 예시는 `/about`과 `/dashboard`로 시작하는 모든 하위 경로에 미들웨어가 적용된다는 뜻이에요.\n\n참고로, matcher에 지정할 수 있는 패턴은 Next.js의 라우팅 규칙과 비슷해서 익숙하시다면 편하게 쓸 수 있을 거예요.\n\n만약 더 세밀한 조건이 필요하다면, 직접 미들웨어 안에서 request 객체를 검사하는 방법도 있어요. 예를 들어, 쿠키나 헤더에 따라 동작을 조절할 수도 있죠.\n\n미들웨어 설정 시 알아두면 좋은 팁!\n- `matcher`를 구체적으로 지정하면 불필요한 미들웨어 실행을 줄여서 퍼포먼스를 개선할 수 있어요.\n- 여러 경로를 배열로 전달할 수 있으니 한꺼번에 관리하기 편합니다.\n- 잘못된 matcher 패턴은 미들웨어가 의도치 않게 작동하지 않을 수 있으니, 꼭 테스트해보세요!\n\n다음에는 미들웨어 내부에서 실제 request 요청을 다루는 법과 응답 처리 방법에 대해 이야기해볼게요. 그럼 같이 공부해봐요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n`matcher` 옵션은 Middleware가 특정 경로에서만 실행되도록 설정할 때 사용해요. 쉽게 말해, 이 옵션을 통해 ‘어떤 경로에 Middleware를 적용할지’를 정할 수 있다는 뜻이죠.\n\n그 방법은 크게 세 가지예요:\n\n- **단일 경로 지정:**  \n  그냥 문자열로 경로를 적으면 돼요. 예를 들어, `/about`이면 `/about` 경로에서만 Middleware가 실행됩니다.\n\n- **여러 경로 지정:**  \n  배열을 사용해서 여러 경로를 한 번에 지정할 수 있어요.  \n  예시) `matcher: ['/about', '/contact']` 이렇게 하면 `/about`과 `/contact` 두 경로 모두 적용됩니다.\n\n- **정규 표현식(Regex) 사용:**  \n  더 정교한 경로 필터링이 필요할 땐 정규식도 사용할 수 있어요.  \n  예를 들면,  \n  js\n  matcher: ['/((?!api|_next/static|_next/image|.*\\\\.png$).*)']\n  \n  이렇게 하면 `api`, `_next/static`, `_next/image` 폴더나 `.png` 파일 경로는 제외하고 나머지 경로에만 Middleware를 적용해요.  \n  정규 표현식의 부정형 전방탐색(negative lookahead)을 활용해 특정 경로나 파일 형식을 꼼꼼히 걸러낼 수 있답니다.\n\n그리고 `matcher` 옵션에는 배열 안에 객체 형식으로 경로를 더 세분화해서 지정할 수도 있는데, 이 객체에는 다음과 같은 키들이 있어요:\n\n| 키 이름      | 설명                                               |\n|--------------|----------------------------------------------------|\n| `src`        | 적용할 경로를 정의 (문자열 또는 정규식)             |\n| `methods`    | 적용할 HTTP 메소드 배열 (예: `['GET', 'POST']`)     |\n| `has`        | 요청에 특정 헤더, 쿠키, 쿼리 파라미터가 있는지 조건 지정 |\n| `missing`    | 요청에 특정 헤더, 쿠키, 쿼리 파라미터가 없는지 조건 지정 |\n\n이런 식으로 복잡한 조건을 걸 수 있어서, 예를 들어 `POST` 요청이고 특정 쿠키가 있을 때만 Middleware를 적용하는 것도 가능하답니다.\n\n---\n\n### 추가 팁  \nRouter 미들웨어를 효과적으로 사용하려면, 불필요하게 모든 경로에 Middleware가 실행되지 않도록 `matcher`를 잘 설정하는 게 좋아요. 안 그러면 성능에 영향이 있을 수 있거든요! 또한, Next.js에서 자주 쓰는 `_next/static` 같은 내부 리소스 경로들은 보통 Middleware 대상에서 제외하는 게 일반적이에요.\n\n이 정도만 잘 활용해도 경로별로 딱 맞는 Middleware 적용이 훨씬 수월해질 거예요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n요즘 웹 개발할 때, 특정 요청 경로에 맞춰서 로직을 처리하거나 미들웨어를 적용하는 경우가 많죠? 이번에 소개할 내용은 이런 요청 경로 매칭을 세밀하게 조정할 수 있는 설정 방법이에요.\n\n---\n\n### 주요 옵션 설명\n\n| 옵션명     | 설명                                                                                           |\n|------------|------------------------------------------------------------------------------------------------|\n| source     | 요청 경로를 매칭하는 경로 또는 패턴이에요. 문자열로 직접 지정하거나 복잡한 패턴을 지정할 수 있어요.             |\n| regexp     | 정규표현식으로 source를 세밀하게 조절할 수 있어요. 포함하거나 제외할 경로를 더욱 정확하게 조절할 때 쓸 수 있죠. |\n| locale     | 불리언 값인데, false로 하면 로케일(언어 설정 등)을 매칭에서 무시해요. 기본값은 true로 다루는 경우가 많습니다.  |\n| has        | 요청 헤더, 쿼리 파라미터, 쿠키 등의 특정 요소가 있을 때 조건을 걸고 싶을 때 사용해요.                            |\n| missing    | 반대로, 헤더나 쿠키 같은 특정 요소가 없을 때만 동작하도록 조건을 걸고 싶을 때 쓰면 좋아요.                         |\n\n---\n\n### 실제 예제\n\n```js\nexport const config = {\n  matcher: [\n    {\n      source: '/api/*',\n      regexp: '^/api/(.*)',\n      locale: false,\n      has: [\n        { type: 'header', key: 'Authorization', value: 'Bearer Token' },\n        { type: 'query', key: 'userId', value: '123' },\n      ],\n      missing: [{ type: 'cookie', key: 'session', value: 'active' }],\n    },\n  ],\n}\n```\n\n- `/api/*` 경로에 대해 매칭합니다.\n- `regexp`로 좀 더 정교하게 `/api/` 뒤에 어떤 값이 오든 매칭하도록 했어요.\n- 로케일 기반 매칭은 무시(`locale: false`)하고요.\n- 요청 헤더에 `Authorization`이 `'Bearer Token'` 이고, 쿼리 파라미터에 `userId=123` 이 있어야 합니다.\n- 그리고 `session` 쿠키가 없을 때만 이 설정이 적용되는 거죠.\n\n---\n\n### 참고로!\n\n- `has`와 `missing` 조건은 다중으로 걸 수 있으니, 복합 조건 처리도 편리하게 구성할 수 있습니다.\n- `regexp` 쓰면 경로를 한 층 더 정교하게 제어할 수 있어서, 간단한 경로나 특수 문자 포함 경로도 문제없이 처리 가능해요.\n- `locale` 설정은 멀티랭귀지 사이트 만들 때 유용하고, 단일 언어 사이트는 보통 false로 두고 쓰기도 합니다.\n\n이렇게 매칭 설정을 잘 사용하면, Next.js나 비슷한 프레임워크에서 요청 경로 조건에 맞는 미들웨어나 특정 API 처리 로직을 깔끔하게 관리할 수 있답니다.\n\n---\n\n다음 글에서는 이 설정을 실제 미들웨어에 어떻게 적용할 수 있는지, 그리고 성능 최적화 팁도 함께 다뤄볼게요! 궁금한 점 있으면 댓글로 남겨주세요~\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nMiddleware를 정의할 때 기본 내보내기 함수는 하나의 매개변수인 request를 받습니다. 이 request는 NextRequest의 인스턴스로, 들어온 HTTP 요청을 나타내죠.\n\n```js\nimport type { NextRequest } from 'next/server'\n\nexport function middleware(request: NextRequest) {\n  // 여기에 Middleware 로직을 작성하세요\n}\n```\n\n\u003e 알아두면 좋은 점:\nNextRequest는 Next.js Middleware에서 들어오는 HTTP 요청을 나타내는 타입이에요. 반면에 NextResponse는 HTTP 응답을 조작하고 돌려보낼 때 사용하는 클래스로 구분되어 있습니다.\n\n## NextResponse\n\nNextResponse는 Middleware 안에서 주로 클라이언트에게 반환할 응답을 조작할 때 사용합니다. 예를 들어, 요청을 리다이렉트하거나 쿠키를 설정하는 등의 작업을 할 수 있죠.\n\n간단한 예시를 보면:\n\n```js\nimport { NextResponse } from 'next/server'\n\nexport function middleware(request) {\n  // 특정 경로로 리다이렉트하기\n  if (request.nextUrl.pathname === '/old-path') {\n    return NextResponse.redirect(new URL('/new-path', request.url))\n  }\n  return NextResponse.next()\n}\n```\n\n이렇게 요청된 경로가 `/old-path`라면 `/new-path`로 리다이렉트 시키고, 그렇지 않으면 다음 미들웨어나 라우터로 요청을 넘기게 됩니다.\n\n또한 NextResponse를 이용해 쿠키를 설정할 수도 있어요. 예를 들어:\n\n```js\nimport { NextResponse } from 'next/server'\n\nexport function middleware(request) {\n  const response = NextResponse.next()\n  response.cookies.set('my-cookie', 'my-value', { path: '/', maxAge: 60 * 60 * 24 }) // 1일간 유지되는 쿠키\n  return response\n}\n```\n\n위 예시에서는 응답에 'my-cookie'라는 이름의 쿠키를 추가하는 거죠.\n\nMiddleware에서 NextRequest와 NextResponse의 역할을 잘 구분해두면 효과적인 요청 처리 및 응답 제어가 가능하니 꼭 기억해두세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n미들웨어(Middleware)는 NextResponse 객체를 사용할 수 있는데, 이 객체는 Web Response API를 확장한 거예요. NextResponse 객체를 반환하면 쿠키를 직접 조작하거나, 헤더를 설정하고, 리다이렉트를 구현하거나, 경로를 다시 쓸 수 있어서 정말 유용하답니다.\n\n\u003e 참고로 리다이렉트를 구현할 땐 NextResponse.redirect 대신 Response.redirect를 써도 된다는 점! 상황에 맞게 골라 쓰시면 돼요.\n\n## 실행 환경(Runtime)\n\n미들웨어는 Edge 런타임에서만 동작해요. 그래서 Node.js 런타임에서는 사용할 수 없다는 점, 꼭 기억해주세요.\n\n---\n\n### 미들웨어에서 NextResponse를 쓰면 좋은 점\n\n- 쿠키 설정/삭제가 편리해요.\n- 헤더를 자유자재로 조작할 수 있어서 보안이나 캐싱 정책 등을 설정할 때 유리하죠.\n- 경로 재작성(Rewrite) 기능으로 SEO 최적화나 사용자 맞춤 라우팅이 쉬워져요.\n\nEdge 런타임이라는 건, 쉽게 말해 요청이 사용자와 가까운 서버(Edge)에서 빠르게 처리된다는 뜻인데요. 그래서 미들웨어가 빠른 응답 속도에 도움을 줘서 좋은 사용자 경험을 만들 수 있답니다.\n\n필요할 때 미들웨어와 NextResponse를 적절히 활용해보세요! 개발할 때 꽤 큰 힘이 되어줄 거예요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 버전 히스토리 (Version History)\n\n| 버전       | 변경 사항                                                                                         |\n|------------|--------------------------------------------------------------------------------------------------|\n| `v13.1.0`  | 고급 미들웨어 플래그(Advanced Middleware flags) 추가                                           |\n| `v13.0.0`  | 미들웨어가 요청 헤더, 응답 헤더를 수정할 수 있고, 응답도 직접 보낼 수 있게 개선                  |\n| `v12.2.0`  | 미들웨어가 안정화됨. 자세한 업그레이드 가이드는 [여기](https://nextjs.org/docs/messages/middleware-upgrade-guide) 참고 |\n| `v12.0.9`  | Edge Runtime에서 절대 URL 강제 적용 ([관련 PR](https://github.com/vercel/next.js/pull/33410))                  |\n| `v12.0.0`  | 미들웨어(Beta) 기능 추가                                                                         |\n\n---\n\n*잠깐!*\n\n여기서 말하는 '미들웨어'는 Next.js에서 API 요청과 응답 사이에 원하는 로직을 끼워 넣을 수 있는 기능이에요. 예를 들어 로그인 검증, A/B 테스트, 사용자 맞춤 리디렉션 등을 처리할 때 아주 유용하답니다.\n\n그리고 `v13.0.0`부터는 요청과 응답 헤더를 수정하거나 직접 응답을 보내는 등 훨씬 더 강력한 제어가 가능해져서, 미들웨어를 활용하는 범위가 정말 넓어졌어요.\n\n버전이 올라가면서 미들웨어가 안정화되고 기능도 점점 확장되고 있으니, 현재 개발 중인 프로젝트에 맞춰 적절히 선택해서 쓰시면 좋겠네요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":12},{"title":"Nextjs 15 에서 레이아웃 잡는 방법 (layout.js)","description":"","date":"2025-04-22 02:39","slug":"2025-04-22-layoutjs","content":"\n\n# layout.js 이해하기\n\nNext.js에서 `layout.js` 파일은 애플리케이션의 **레이아웃(화면 구성 틀)**을 정의하는 데 사용돼요. 쉽게 말해, 여러 페이지에서 공통적으로 사용되는 UI 구조를 한 곳에 모아서 관리할 수 있게 해주죠.\n\n예를 들어, 아래 코드를 살펴볼게요:\n\n```js\nexport default function DashboardLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return \u003csection\u003e{children}\u003c/section\u003e\n}\n```\n\n여기서 `DashboardLayout` 컴포넌트는 내부에 들어올 콘텐츠(여기서는 `children`)를 `\u003csection\u003e` 태그 안에 감싸서 렌더링해요. 이 의미는, `DashboardLayout` 위에 두고 싶거나 반복적으로 쓰이는 헤더, 사이드바 같은 요소를 여기에 추가하면 더 편하게 관리할 수 있다는 점이죠.\n\n---\n\n## 루트 레이아웃 (Root Layout)이란?\n\nNext.js 13버전부터는 앱 폴더 안에 `layout.js` 파일을 두는 게 많아졌는데, 그 중에서도 **루트 레이아웃**은 가장 최상단에 위치하는 레이아웃입니다. 이 루트 레이아웃은 앱 전체에 공통으로 적용할 `html`, `body` 태그를 정의하고 전역 스타일, 폰트, 메타데이터, 그리고 공통 UI(예: 네비게이션 바)를 배치할 때 사용돼요.\n\n예를 들어, 이렇게 작성할 수 있죠:\n\n```js\nexport default function RootLayout({ children }) {\n  return (\n    \u003chtml lang=\"ko\"\u003e\n      \u003cbody\u003e\n        {/* 공통 헤더 */}\n        \u003cheader\u003e\n          \u003cnav\u003e내 네비게이션 바\u003c/nav\u003e\n        \u003c/header\u003e\n        \n        {/* 페이지 컨텐츠 */}\n        \u003cmain\u003e{children}\u003c/main\u003e\n        \n        {/* 공통 푸터 */}\n        \u003cfooter\u003e© 2024 내사이트\u003c/footer\u003e\n      \u003c/body\u003e\n    \u003c/html\u003e\n  )\n}\n```\n\n이렇게 하면, 모든 페이지가 이 루트 레이아웃 안에서 렌더링되고, 중복되는 UI 코드를 매번 작성하지 않아도 돼서 유지보수가 훨씬 쉬워집니다.\n\n---\n\n## 추가로 알아두면 좋은 팁\n\n- **중첩 레이아웃(Nested Layout):** Next.js는 여러 개의 `layout.js` 파일을 각 폴더마다 만들 수 있어요. 예를 들어, `app/dashboard/layout.js`는 대시보드 구역에만 적용되는 레이아웃으로 설정할 수 있답니다.\n- **서버 컴포넌트:** 기본적으로 `layout.js`는 서버 컴포넌트로 동작해요. 그래서 클라이언트 전용 기능(이벤트 핸들러 등)은 `use client` 지시자를 따로 써서 클라이언트 컴포넌트로 만들어야 해요.\n- **스타일링:** 루트 레이아웃에 글로벌 CSS를 불러오거나, 구글 폰트 같은 외부 폰트를 적용하기 좋은 위치입니다.\n\n---\n\nNext.js의 레이아웃 시스템을 잘 활용하면 코드가 깔끔해지고, 프로젝트가 커져도 구조를 쉽게 관리할 수 있어요. 한 번 직접 만들어보고 중첩 레이아웃도 시험해보길 추천합니다! 😊\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자, 이번에는 React 컴포넌트에서 자주 사용되는 RootLayout 예제를 살펴볼게요. 위 코드는 Next.js 13부터 도입된 새로운 app 디렉토리 구조에서 루트 레이아웃을 정의하는 기본적인 방법입니다.\n\n```tsx\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    \u003chtml lang=\"en\"\u003e\n      \u003cbody\u003e{children}\u003c/body\u003e\n    \u003c/html\u003e\n  )\n}\n```\n\n이 컴포넌트는 부모 컴포넌트로부터 `children`이라는 prop을 받아서, 그 안에 어떤 하위 컴포넌트가 들어와도 감싸주는 역할을 합니다.\n\n## 주요 내용 정리\n\n| Props     | 타입                 | 설명                                   |\n| --------- | -------------------- | ------------------------------------ |\n| children  | React.ReactNode (필수) | 하위 컴포넌트나 JSX를 포함하는 prop   |\n\n### 추가로 알아두면 좋은 점!\n\n- `\u003chtml lang=\"en\"\u003e` 태그는 페이지 전체 언어 설정을 나타내서 SEO와 접근성 측면에서 매우 중요해요. 상황에 맞게 `lang` 속성을 적절히 바꿔주세요.\n- `RootLayout`은 모든 페이지에 공통적으로 적용되는 레이아웃이 들어가는 곳이에요. 예를 들어 네비게이션 바, 푸터, 글로벌 스타일 등을 넣을 수 있죠.\n- React에서 props 타입을 지정할 땐 보통 TypeScript를 사용해 이런 형태로 명시해 줍니다. 이를 통해 컴포넌트 사용 시 타입 안정성을 확보할 수 있어요.\n\n이 간단한 구조를 기반으로, 여러분만의 멋진 레이아웃을 만들어 보세요! 😊\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n레이아웃 컴포넌트는 children 프로퍼티를 받아야 하고, 이를 사용해서 렌더링해야 해요. 렌더링 시점에 children에는 현재 레이아웃이 감싸고 있는 라우트의 하위 세그먼트들이 들어오게 되죠. 주로 자식 레이아웃 컴포넌트(있다면)나 페이지 컴포넌트가 될 거예요. 그리고 상황에 따라 로딩(Loading)이나 에러(Error) 같은 특별한 파일들도 포함될 수 있답니다.\n\n---\n\n### params (선택사항)\n\nparams는 비동기적으로 동적 라우트 파라미터를 얻을 때 사용해요. 루트 세그먼트부터 현재 레이아웃까지의 경로에 해당하는 모든 동적 파라미터들을 객체 형태로 받아올 수 있죠.\n\n예를 들자면, 아래처럼 사용할 수 있어요:\n\n```js\nexport default async function Layout({\n  params,\n}: {\n  params: Promise\u003c{ team: string }\u003e\n}) {\n  const { team } = await params;\n  // 이제 team 변수를 사용해서 팀별 UI를 구성할 수 있어요\n}\n```\n\n---\n\n#### 여기서 알아두면 좋은 점!\n\n- Layout 컴포넌트가 children을 받아 렌더링하는 구조 덕분에 중첩된 레이아웃을 쉽게 다룰 수 있어요.\n- 비동기 params를 통해 페이지마다 필요한 데이터를 라우팅 단계에서 미리 받아와서, UI를 더 빠르게 그리고 사용자 맞춤형으로 보여줄 수 있답니다.\n- 이 방식을 사용하면 레이아웃별로 공통 요소(헤더, 사이드바 등)를 한 번만 선언하고, 그 안에 컨텐츠를 중첩해서 관리할 수 있어 유지보수가 훨씬 용이해져요.\n\n이런 구조를 이해하면, Next.js 같은 최신 프레임워크의 라우팅과 레이아웃 시스템을 훨씬 더 능숙하게 다룰 수 있게 됩니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 Next.js의 동적 라우팅 예시입니다. 각 경로에 해당하는 URL과 넘겨받는 params 값을 보여주고 있어요.\n\n| Example Route                    | URL             | params                       |\n| ------------------------------ | --------------- | ---------------------------- |\n| `app/dashboard/[team]/layout.js` | `/dashboard/1`  | `Promise\u003c{ team: '1' }\u003e`     |\n| `app/shop/[tag]/[item]/layout.js` | `/shop/1/2`    | `Promise\u003c{ tag: '1', item: '2' }\u003e` |\n| `app/blog/[...slug]/layout.js`   | `/blog/1/2`    | `Promise\u003c{ slug: ['1', '2'] }\u003e`    |\n\n여기서 중요한 점! `params`는 Promise 형태로 전달되기 때문에 async/await를 사용하거나 React의 `use` 함수 같은 비동기 핸들링이 필요합니다.  \nNext.js 버전 14 및 이전에서는 `params`가 동기적 prop이었는데, 버전 15부터는 비동기 형태로 바뀌었어요. 다만 아직 하위 호환성을 위해 동기식 접근도 가능하지만, 앞으로는 deprecated 될 예정이라 미리 비동기로 바꿔서 사용하는 게 좋습니다.\n\n---\n\n### 루트 레이아웃 (Root Layout)\n\nNext.js의 앱 디렉터리 구조에서는 반드시 최상위에 `app/layout.js` 파일이 있어야 합니다. 이 파일이 애플리케이션의 공통 레이아웃을 담당하며, 페이지 전반에 걸쳐 공통적으로 적용할 UI(헤더, 푸터, 네비게이션 등)를 넣는 곳이죠.\n\n---\n\n추가 팁!  \n라우터 파라미터를 Promise로 받는다는 점이 처음엔 헷갈릴 수 있지만, 이 덕분에 서버 사이드 렌더링 환경에서 비동기로 데이터를 받아와 처리하는데 유연성을 얻게 됩니다. `layout.js`뿐 아니라, 각 컴포넌트에서 비동기 작업을 자연스럽게 하도록 돕는 구조라는 걸 기억하세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 Root Layout을 설정할 때 몇 가지 꼭 알아둬야 할 핵심 포인트들이 있어요. 제가 직접 코드를 보면서 정리해봤는데요, 실제로 개발할 때 참고하면 딱 좋을 것 같아서 공유합니다!\n\n```tsx\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    \u003chtml\u003e\n      \u003cbody\u003e{children}\u003c/body\u003e\n    \u003c/html\u003e\n  )\n}\n```\n\n### 1. `html`과 `body` 태그는 Root Layout에서 꼭 정의해야 해요\nRoot Layout은 애플리케이션 전체의 뼈대가 되기 때문에, `\u003chtml\u003e`, `\u003cbody\u003e` 태그를 직접 작성해줘야 합니다.  \n그런데 이 밖에 `head` 태그나 그 안에 들어가는 `title`, `meta` 같은 요소들은 직접 넣으면 안 된다는 점!  \n이걸 next.js에서 **Metadata API**라는 걸로 관리해줘서, 머리 정보들을 자동으로 스트리밍 처리하고 중복 제거까지 해준답니다. 이게 꽤 편하니까 꼭 활용해 보세요.\n\n### 2. `head` 태그는 **Metadata API** 사용하기\n직접 `head` 태그에 `title`, `meta` 이런 거 넣으면 안 되고, next.js가 제공하는 Metadata API를 써서 데이터 설정해야 해요.  \n예를 들어, layout이나 page에서 `export const metadata = { title: '홈페이지' }` 이렇게 지정할 수 있습니다.  \n이 방식 덕분에 로딩 속도는 빨라지고 SEO도 좋아지죠!\n\n### 3. 여러 Root Layout 만들기! (Route Groups)\nRoutes를 그룹으로 묶어서 각 그룹마다 Root Layout을 다르게 만들 수 있어요.  \n예를 들어, 쇼핑몰 영역과 블로그 영역이 각각 `app/(shop)/layout.js`와 `app/(marketing)/layout.js`를 쓴다고 하면,  \n이 두 구역 사이를 이동할 때는 완전한 페이지 리로드가 발생해요. (즉, 클라이언트 사이드 네비게이션이 아니라 서버에서 다시 불러오는 방식)  \n이 점은 여러 개의 Root Layout을 사용할 때 발생하는 특성입니다.\n\n---\n\n## 궁금증 해결 : Layout에서 Request 객체에 접근할 수 있나요?\n\nRoot Layout이나 Layout 컴포넌트에서 직접 HTTP Request 객체에 접근하는 건 불가능합니다.  \nNext.js 앱 디렉토리(app router)는 서버 컴포넌트 기반이고, 서버 컴포넌트에서는 요청 정보를 직접 다루는 게 제한돼 있거든요.\n\n만약 요청에 포함된 데이터(query, headers, cookies 등)를 사용하고 싶다면, `fetch` 함수나 서버 컴포넌트에서 사용할 수 있는 다양한 Next.js API를 활용해서 데이터를 미리 받아오는 패턴을 주로 사용합니다.\n\n예를 들어:\n\n```tsx\nexport default async function RootLayout({ children }) {\n  const res = await fetch('https://api.example.com/data');\n  const data = await res.json();\n\n  return (\n    \u003chtml\u003e\n      \u003cbody\u003e\n        {/* 여기서 data를 활용할 수 있어요 */}\n        {children}\n      \u003c/body\u003e\n    \u003c/html\u003e\n  );\n}\n```\n\n또한, 특정 요청 헤더나 쿠키 등이 필요하면 Next.js가 제공하는 `cookies()`나 `headers()` 함수를 사용할 수도 있으니 참고하세요.  \n\n---\n\nNext.js 13의 앱 라우터 구조가 처음엔 조금 낯설지만, 이런 Root Layout 기본 규칙을 이해하고 나면 훨씬 유연하게 프로젝트를 구성할 수 있답니다!  \n궁금한 점 있으면 언제든 말씀해 주세요. 개발 힘내시고 좋은 하루 보내세요~ 😊\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 레이아웃(layout)은 원시 요청 객체(raw request object)에 직접 접근할 수 없도록 의도적으로 제한되어 있습니다. 대신, 서버 전용 함수(server-only functions)를 통해 헤더(headers)와 쿠키(cookies) 정보는 가져올 수 있어요.\n\n이유는 간단해요. 레이아웃은 페이지 간 이동 시 불필요한 연산을 줄이기 위해 한 번 렌더링된 뒤 재사용될 수 있도록 설계되어 있어요. 만약 레이아웃에서 매 요청마다 원시 요청 객체에 접근해 무거운 작업을 수행하게 된다면, 그만큼 성능에 악영향이 가기 때문이죠.\n\n또한, 이런 제한 덕분에 레이아웃이 여러 페이지에서 일관적이고 예측 가능한 방식으로 동작하도록 보장합니다. 개발자 입장에선 디버깅도 훨씬 간편해지는 장점이 있어요.\n\n### 참고로, 레이아웃은 searchParams(검색 파라미터)도 직접 받지 않습니다.\n\n이 부분 꼭 알아두시면 좋아요. 만약 query string 정보를 레이아웃에서 활용하고 싶다면, 서버 함수에서 받아서 헤더나 쿠키에 저장하거나, 페이지 컴포넌트 쪽에서 처리하는 방식을 생각해 볼 수 있습니다.\n\n---\n\n### 간단 정리 테이블\n\n| 제한 사항                    | 이유 및 설명                                                  |\n|-----------------------------|-----------------------------------------------------------|\n| 원시 요청 객체 접근 불가      | 렌더링 성능 최적화와 일관성 있는 레이아웃 동작 보장               |\n| 헤더와 쿠키는 서버 함수 통해 접근 가능 | 필요한 요청 정보만 안전하게 접근할 수 있도록                       |\n| 레이아웃은 검색 파라미터 수신 불가 | 검색 파라미터는 페이지에서 처리하거나 서버 함수로 받아야 함            |\n\n이런 구조를 이해하면 Next.js 레이아웃을 설계할 때 어디서 어떤 정보를 받아서 처리해야 하는지 명확해져서 개발이 훨씬 수월해집니다. 필요할 땐 서버 함수 잘 활용해서 헤더, 쿠키 같은 정보만 쏙쏙 뽑아 쓰세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nPages와 달리 Layout 컴포넌트는 searchParams props를 받지 않아요. 그 이유는, 공통 레이아웃(shared layout)은 페이지가 이동해도 재렌더링되지 않기 때문에, 만약 searchParams를 받는다면 이전 네비게이션의 값이 그대로 남아있어서 최신 상태가 아니게 될 수 있기 때문이죠.\n\nNext.js에서 클라이언트 사이드 네비게이션을 할 때, 공통 레이아웃 아래의 페이지 일부만 자동으로 렌더링해줘서, 예를 들어 아래와 같은 디렉터리 구조가 있다고 할 때:\n\n\ndashboard/\n  ├── layout.tsx\n  ├── settings.tsx\n  └── analytics.tsx\n\n\n`dashboard/layout.tsx`는 `/dashboard/settings`와 `/dashboard/analytics` 두 경로 모두에 걸친 공통 레이아웃으로 작동합니다. 이 말은, 사용자가 `/dashboard/settings`에서 `/dashboard/analytics`로 이동해도 `dashboard/layout.tsx`는 다시 렌더링되지 않는다는 거죠.\n\n즉, 공통 레이아웃은 한 번 렌더링한 뒤 유지되어서 불필요한 렌더링 부담이 줄어들고, 페이지 전환이 더 빠르게 느껴지게 돼요.\n\n---\n\n그리고 참고로, 만약 공통 레이아웃에서 현재 URL의 query(=searchParams)를 꼭 사용해야 한다면, 레이아웃 내부가 아니라 개별 페이지 컴포넌트 내에서 `useSearchParams()` 같은 React 훅을 활용하는 게 좋아요. 그쪽이 항상 최신 URL 상태를 반영할 수 있답니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\"/dashboard/settings\"에서 \"/dashboard/analytics\"로 이동할 때, \"/dashboard/analytics/page.tsx\"는 서버에서 다시 렌더링이 되지만, \"dashboard/layout.tsx\"는 두 경로에서 공통으로 사용하는 레이아웃 컴포넌트라서 다시 렌더링되지 않습니다.\n\n이런 최적화 덕분에, 공통 레이아웃을 공유하는 페이지 간 이동 시에는 전체 경로를 다시 그릴 필요 없이, 페이지 단위의 데이터 페칭과 렌더링만 수행되기 때문에 훨씬 빠른 네비게이션이 가능합니다. 즉, 레이아웃까지 포함한 전체 경로가 다시 렌더링되면 시간이 더 걸리지만, 공통 레이아웃이 그대로 유지되니 성능이 더 좋아지는 거죠.\n\n하지만 여기서 주의할 점! layout.tsx가 다시 렌더링되지 않으니, 이 레이아웃 컴포넌트에 있는 searchParams prop은 navigation 후에 구버전(stale)이 될 수 있습니다.\n\n그래서 검색 파라미터가 필요할 땐, 레이아웃에서 바로 쓰지 말고 아래 두 가지 방법 중 하나를 이용하는 걸 추천해요.\n\n1. Page 컴포넌트에서 전달받는 최신 searchParams prop을 사용하기\n2. 레이아웃 내 클라이언트 컴포넌트에서 useSearchParams 훅을 사용해서 최신값을 받아오기\n\n이렇게 하면 클라이언트에서 렌더링될 때 최신 searchParams를 쓸 수 있어 데이터가 꼬이는 문제를 예방할 수 있답니다.\n\n---\n\n**tip!**\n\n- 클라이언트 컴포넌트에서 `useSearchParams`를 쓸 때는 `\"use client\"` 지시어를 꼭 선언해야 해요.\n- 만약 레이아웃이 공통 상태나 데이터를 많이 관리한다면, 이런 최적화가 큰 차이를 만들어낼 수 있어요.\n- Next.js 앱 디렉토리 구조에서는 이런 레이아웃 재사용과 부분 렌더링 최적화가 핵심이니 꼭 이해해두시면 좋아요!\n\n더 궁금한 점 있으면 편하게 물어봐 주세요~\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 레이아웃(Layouts)에서 pathname에 접근할 수 없는 이유\n\nNext.js에서 레이아웃은 기본적으로 **서버 컴포넌트(Server Components)**로 동작하는데요, 이게 왜 문제가 되냐면 클라이언트 사이드 네비게이션(페이지 간 이동) 시에 레이아웃이 다시 렌더링되지 않아요.  \n즉, `pathname` 같은 네비게이션 상태가 바뀌더라도 레이아웃은 리렌더링하지 않기 때문에, `pathname` 정보가 실제와 다르게 **stale(오래된 정보)**가 될 수 있습니다.\n\n그렇다고 레이아웃을 매번 새로 서버에서 받아오면 캐싱의 이점도 날아가고, RSC(Server Components) 페이로드 크기도 커져서 비효율적이겠죠.\n\n---\n\n### 그럼 어떻게 해야 하나요?\n\n이럴 때는 `pathname`을 필요로 하는 부분의 로직을 **클라이언트 컴포넌트(Client Component)**로 분리하는 방법이 좋아요. 클라이언트 컴포넌트는 페이지가 네비게이션할 때마다 리렌더링 되지만, 서버에서 다시 받아오진 않기 때문에 최신의 `pathname` 값을 바로바로 사용할 수 있어요.\n\nNext.js는 `usePathname` 같은 훅도 제공해서 현재 경로를 쉽게 알 수 있게 해줍니다.\n\n---\n\n### 예제 코드\n\n```jsx\nimport { ClientComponent } from '@/app/ui/ClientComponent'\n\nexport default function Layout({ children }: { children: React.ReactNode }) {\n  return (\n    \u003c\u003e\n      \u003cClientComponent /\u003e\n      {/* 여기에 레이아웃의 다른 UI들 */}\n      \u003cmain\u003e{children}\u003c/main\u003e\n    \u003c/\u003e\n  )\n}\n```\n\n`ClientComponent` 안에서는 이렇게 쓸 수 있겠죠:\n\n```jsx\n\"use client\"\nimport { usePathname } from 'next/navigation'\n\nexport function ClientComponent() {\n  const pathname = usePathname()\n\n  return \u003cdiv\u003e현재 경로: {pathname}\u003c/div\u003e\n}\n```\n\n---\n\n### 정리하며 드리는 팁!\n\n- **레이아웃에서 서버 컴포넌트와 클라이언트 컴포넌트를 적절히 나누자**  \n  너무 많은 상태나 UI를 클라이언트 컴포넌트로 두면 서버 컴포넌트의 장점이 줄지만, 라우팅 상태처럼 자주 변하는 데이터는 클라이언트 컴포넌트가 적절해요.\n  \n- **`usePathname` 외에도 `useSearchParams`**, `useRouter` 같은 훅도 비슷한 이유로 클라이언트 컴포넌트에서 써야 해요.\n\n- **최신 Next.js는 서버 컴포넌트와 클라이언트 컴포넌트를 잘 섞어 쓰는 패턴을 권장**하니 이를 염두에 두고 컴포넌트를 설계하면 더 편하고 최적화된 앱을 만들 수 있습니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n경로 패턴을 다룰 때, 흔히 사용하는 방법 중 하나가 바로 params(props)를 활용하는 거예요.\n\n좀 더 구체적인 내용과 예시는 아래 'Examples' 섹션을 참고하면 도움이 될 거예요.\n\n## 예시\n\n### params를 이용해 콘텐츠를 보여주기\n\n이렇게 params를 활용하면 URL에서 특정 값을 파라미터로 받아서 동적으로 콘텐츠를 바꾸는 게 가능해져요. 예를 들어 사용자가 특정 아이템의 상세 페이지를 보게 할 때, URL에 ID를 넣고 그 ID에 맞는 정보를 렌더링할 수 있죠.\n\n기본적으로 params는 라우트에서 토큰화된 URL 조각들을 받아서 컴포넌트에 전달해주는 역할을 합니다. react-router 같은 라이브러리를 쓴다면 자연스럽게 사용할 수 있죠.\n\n다음 예시를 참고해볼게요:\n\n| URL | params | 설명 |\n|---|---|---|\n| /user/123 | { id: '123' } | 유저 아이디가 123인 페이지 보여주기 |\n| /product/456 | { productId: '456' } | 상품 상세 페이지를 productId에 맞게 보여주기 |\n\n이처럼 params를 잘 활용하면, 같은 컴포넌트가 다양한 경로 데이터를 받아 콘텐츠를 유동적으로 바꿔줄 수 있어서 프로젝트 관리하기 훨씬 편해진답니다. 필요하면 제가 더 실무 예제도 공유해드릴게요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n동적 라우트 세그먼트를 활용하면 params 프로퍼티를 통해 특정 콘텐츠를 보여주거나 가져올 수 있어요.\n\n```jsx\nexport default async function DashboardLayout({\n  children,\n  params,\n}: {\n  children: React.ReactNode\n  params: Promise\u003c{ team: string }\u003e\n}) {\n  const { team } = await params\n \n  return (\n    \u003csection\u003e\n      \u003cheader\u003e\n        \u003ch1\u003eWelcome to {team}'s Dashboard\u003c/h1\u003e\n      \u003c/header\u003e\n      \u003cmain\u003e{children}\u003c/main\u003e\n    \u003c/section\u003e\n  )\n}\n```\n\n위 예제는 Next.js에서 동적 세그먼트를 받고, 그 파라미터를 비동기(await)로 풀어서 사용하는 모습이에요. 여기서 `params`는 `{ team: string }` 형태라고 타입이 지정돼 있죠.\n\n---\n\n### 클라이언트 컴포넌트에서 params 읽기\n\n서버 컴포넌트에서는 async/await로 params를 다룰 수 있어요. 하지만 클라이언트 컴포넌트는 async 함수를 지원하지 않아서 직접 params를 await할 수 없죠. 이때는 React의 `use` 훅을 사용해서 Promise를 처리할 수 있는데, 다음과 같이 활용해요:\n\n```jsx\n'use client'\n\nimport { use } from 'react';\n\nexport default function Dashboard({ paramsPromise }: { paramsPromise: Promise\u003c{ team: string }\u003e }) {\n  const { team } = use(paramsPromise);\n\n  return \u003ch1\u003eWelcome to {team}'s Dashboard\u003c/h1\u003e;\n}\n```\n\n여기서 `use` 훅은 React 18부터 실험적으로 지원하는 훅인데, Promise를 직접 커버할 수 있어서 비동기 데이터를 자연스럽게 렌더링할 수 있게 도와줍니다.\n\n---\n\n**추가 팁!**\n\n- Next.js 13의 `app` 디렉터리를 쓸 때는 동적 라우트를 만들면 자동으로 params가 들어오고, 그걸 서버 컴포넌트에서 바로 사용할 수 있어서 편리해요.\n- 클라이언트 컴포넌트에서 async 로직을 처리할 때는 보통 `useEffect`와 상태관리를 쓰지만, `use` 훅을 쓰면 좀 더 깔끔한 코드가 될 수 있어요.\n- 다만 `use` 훅은 아직 실험적 기능이라 프로젝트에 맞게 신중히 사용해야 합니다.\n\n이런 방식으로 동적 라우트를 활용해서 사용자 맞춤 대시보드나 상세 페이지를 쉽게 구현할 수 있답니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n'use client'\n\nimport { use } from 'react'\n\nexport default function Page({\n  params,\n}: {\n  params: Promise\u003c{ slug: string }\u003e\n}) {\n  const { slug } = use(params)\n}\n```\n\n## 버전 히스토리\n\n| 버전           | 변경 사항                                                                                  |\n| -------------- | ----------------------------------------------------------------------------------------- |\n| `v15.0.0-RC`   | `params`가 이제 Promise로 변경되었습니다. [codemod](https://nextjs.org/docs/app/guides/upgrading/codemods#150) 도 제공됩니다. |\n| `v13.0.0`      | `layout`이 새로 도입되었습니다.                                                            |\n\n---\n\n위 코드를 보면 `params`가 Promise 형태로 전달되고, React 18에서 도입된 `use` 훅을 사용해서 그 Promise를 직접 해결(resolve)하는 방식을 사용하고 있네요. \n\n이 방식은 서버 컴포넌트에서 비동기 데이터를 쉽게 처리할 수 있게 해줘서, 데이터 로딩 코드를 더 깔끔하게 작성할 수 있다는 장점이 있어요.\n\n참고로 `use` 훅은 아직 React 공식 API가 아니기 때문에, Next.js 같은 프레임워크에서 실험적으로 지원하는 기능이에요. 그러니 프로젝트에 적용할 때는 호환성을 꼭 확인하는 게 좋아요!\n\n그리고 `params`가 Promise로 바뀐 이유는 서버 컴포넌트가 비동기적으로 라우팅 파라미터를 처리할 수 있도록 하기 위해서인데요, 이를 통해 더 유연한 데이터 페칭과 페이지 렌더링이 가능해졌답니다. \n\n더 자세한 내용은 Next.js 공식 문서나 업그레이드 가이드를 참고해보세요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":18}],"page":"11","totalPageCount":50,"totalPageGroupCount":3,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"11"},"buildId":"KUC9M_yIlA1Ugo01xmkHL","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>