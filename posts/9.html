<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>TIL</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//posts/9" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="TIL" data-gatsby-head="true"/><meta property="og:title" content="TIL" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//posts/9" data-gatsby-head="true"/><meta name="twitter:title" content="TIL" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/7d7290728862aada.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/7d7290728862aada.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/873-eb138c3217d71553.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/posts/%5Bpage%5D-de1dc5579188f9be.js" defer=""></script><script src="/TIL/_next/static/M7pU9hOcx8u_ZIFMf95sd/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/M7pU9hOcx8u_ZIFMf95sd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Next.js 15에서 HTTP 요청 헤더 쉽게 작성하기 (headers) " href="/TIL/post/2025-04-22-headers"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15에서 HTTP 요청 헤더 쉽게 작성하기 (headers) " loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15에서 HTTP 요청 헤더 쉽게 작성하기 (headers) " loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15에서 HTTP 요청 헤더 쉽게 작성하기 (headers) </strong><div class="PostList_meta__VCFLX"><span class="date">8 hours ago</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js 15에서 generateViewport 함수로 반응형 페이지 만드는 방법" href="/TIL/post/2025-04-22-generateViewport"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15에서 generateViewport 함수로 반응형 페이지 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15에서 generateViewport 함수로 반응형 페이지 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15에서 generateViewport 함수로 반응형 페이지 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">8 hours ago</span><span class="PostList_reading_time__6CBMQ">17<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js 13에서 generateStaticParams 사용법 정리" href="/TIL/post/2025-04-22-generateStaticParams"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 13에서 generateStaticParams 사용법 정리" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 13에서 generateStaticParams 사용법 정리" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 13에서 generateStaticParams 사용법 정리</strong><div class="PostList_meta__VCFLX"><span class="date">9 hours ago</span><span class="PostList_reading_time__6CBMQ">20<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js 15에서 generateSitemaps 기능 쉽게 구현하는 2025년 최신 가이드" href="/TIL/post/2025-04-22-generateSitemaps"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15에서 generateSitemaps 기능 쉽게 구현하는 2025년 최신 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15에서 generateSitemaps 기능 쉽게 구현하는 2025년 최신 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15에서 generateSitemaps 기능 쉽게 구현하는 2025년 최신 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">9 hours ago</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js 15에서 generateMetadata 함수로 SEO 메타데이터 자동 생성하는 방법" href="/TIL/post/2025-04-22-generateMetadata"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15에서 generateMetadata 함수로 SEO 메타데이터 자동 생성하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15에서 generateMetadata 함수로 SEO 메타데이터 자동 생성하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15에서 generateMetadata 함수로 SEO 메타데이터 자동 생성하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">18 hours ago</span><span class="PostList_reading_time__6CBMQ">84<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js 15에서 generateImageMetadata 함수 사용하는 방법" href="/TIL/post/2025-04-22-generateImageMetadata"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15에서 generateImageMetadata 함수 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15에서 generateImageMetadata 함수 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15에서 generateImageMetadata 함수 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">18 hours ago</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js 15에서 Forbidden 에러 해결하는 방법" href="/TIL/post/2025-04-22-forbidden"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15에서 Forbidden 에러 해결하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15에서 Forbidden 에러 해결하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15에서 Forbidden 에러 해결하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">18 hours ago</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nextjs 15에서 draftMode 기능 사용하는 방법" href="/TIL/post/2025-04-22-draftMode"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nextjs 15에서 draftMode 기능 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nextjs 15에서 draftMode 기능 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Nextjs 15에서 draftMode 기능 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">18 hours ago</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js 15에서 fetch API 활용하는 최신 방법" href="/TIL/post/2025-04-22-fetch"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15에서 fetch API 활용하는 최신 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15에서 fetch API 활용하는 최신 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15에서 fetch API 활용하는 최신 방법</strong><div class="PostList_meta__VCFLX"><span class="date">18 hours ago</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js 15에서 쿠키 쉽게 다루는 방법" href="/TIL/post/2025-04-22-cookies"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15에서 쿠키 쉽게 다루는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15에서 쿠키 쉽게 다루는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15에서 쿠키 쉽게 다루는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">18 hours ago</span><span class="PostList_reading_time__6CBMQ">20<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/TIL/posts/1">1</a><a class="link" href="/TIL/posts/2">2</a><a class="link" href="/TIL/posts/3">3</a><a class="link" href="/TIL/posts/4">4</a><a class="link" href="/TIL/posts/5">5</a><a class="link" href="/TIL/posts/6">6</a><a class="link" href="/TIL/posts/7">7</a><a class="link" href="/TIL/posts/8">8</a><a class="link posts_-active__YVJEi" href="/TIL/posts/9">9</a><a class="link" href="/TIL/posts/10">10</a><a class="link" href="/TIL/posts/11">11</a><a class="link" href="/TIL/posts/12">12</a><a class="link" href="/TIL/posts/13">13</a><a class="link" href="/TIL/posts/14">14</a><a class="link" href="/TIL/posts/15">15</a><a class="link" href="/TIL/posts/16">16</a><a class="link" href="/TIL/posts/17">17</a><a class="link" href="/TIL/posts/18">18</a><a class="link" href="/TIL/posts/19">19</a><a class="link" href="/TIL/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Next.js 15에서 HTTP 요청 헤더 쉽게 작성하기 (headers) ","description":"","date":"2025-04-22 12:41","slug":"2025-04-22-headers","content":"\n\n# headers 함수 알아보기\n\n`headers` 함수는 Server Component 내에서 HTTP 요청 헤더를 비동기로 읽을 수 있게 도와주는 유틸리티입니다. 간단히 말해, 클라이언트가 서버에 보낸 요청의 헤더 정보를 서버 컴포넌트 안에서 쉽게 확인할 수 있다는 거죠.\n\n아래 예제를 보고 한번 살펴볼게요!\n\n```js\nimport { headers } from 'next/headers'\n\nexport default async function Page() {\n  const headersList = await headers()\n  const userAgent = headersList.get('user-agent')\n\n  return (\n    \u003cdiv\u003e\n      \u003cp\u003e당신의 User-Agent: {userAgent}\u003c/p\u003e\n    \u003c/div\u003e\n  )\n}\n```\n\n- 여기서 `headers()`를 호출하면 요청에 포함된 모든 헤더 정보를 담은 객체를 비동기로 가져옵니다.\n- `headersList.get('user-agent')`로 특정 헤더(`user-agent`) 값을 얻을 수 있어요.\n- 이렇게 얻은 헤더 정보로 클라이언트 환경에 따라 다른 내용을 렌더링하거나, API 요청 시 헤더를 조작할 수도 있습니다.\n\n\u003e 참고로, `headers()` 함수는 Server Component에서만 사용 가능하기 때문에 클라이언트 컴포넌트에서는 사용할 수 없다는 점 기억하세요!\n\n---\n\n### 헤더 정보 활용 팁\n\n- **사용자 환경 감지:** User-Agent 헤더를 통해 브라우저 종류나 버전을 확인할 수 있어, 맞춤형 UI를 제공할 때 유용해요.\n- **보안 검사:** 특정 헤더 값을 검사해서 요청이 정상적인지 체크할 수도 있고, 토큰이나 인증 정보를 확인하는 데도 쓰입니다.\n- **로깅 및 분석:** 클라이언트 IP, 언어 설정, 쿠키 등 다양한 헤더 정보를 기록해서 서비스 개선에 활용하세요.\n\n---\n\n필요할 때마다 `headers`를 활용하면 서버 사이드에서 더 스마트하게 사용자 요청을 다룰 수 있으니 꼭 기억해두세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 파라미터\n\nheaders는 별도의 파라미터를 받지 않습니다.\n\n### 반환값\n\nheaders는 읽기 전용(Web Headers) 객체를 반환합니다.\n\n---\n\n여기서 Web Headers 객체란, 웹 요청과 응답에 포함되는 헤더 정보를 나타내는 객체예요. 쉽게 말해서, 서버나 클라이언트가 주고받는 부가 정보를 가지고 있는 거죠. 주로 콘텐츠 타입(Content-Type), 인증 정보(Authorization), 캐시 제어(Cache-Control) 등 다양한 정보를 담고 있답니다.\n\n이 객체가 읽기 전용이라서, 값들을 마음대로 바꾸지는 못하지만, 필요한 경우 새로운 헤더를 만들어서 요청에 추가할 수 있어요. 혹시 헤더를 조작하거나 확인하는 작업이 필요하다면, 이 점 참고하면 좋을 것 같아요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nHeaders 객체 메서드 정리해봤어요! 웹 개발할 때 Headers 다룰 일 많으니 참고해 보세요.\n\n| 메서드              | 설명                                                                                           |\n|---------------------|------------------------------------------------------------------------------------------------|\n| Headers.entries()   | Headers 객체에 들어있는 모든 키/값 쌍을 돌면서 이터레이터(iterator)를 반환해요.                      |\n| Headers.forEach()   | Headers 내 각 키/값 쌍에 대해 한 번씩 제공한 함수를 실행해요.                                    |\n| Headers.get()       | 특정 이름을 가진 헤더의 모든 값을 문자열(String)로 반환해요.                                    |\n| Headers.has()       | 해당 헤더가 존재하는지 여부를 boolean으로 알려줘요.                                              |\n| Headers.keys()      | 모든 키를 순회할 수 있는 이터레이터를 반환해요.                                                 |\n| Headers.values()    | 모든 값을 순회할 수 있는 이터레이터를 반환해요.                                                 |\n\n---\n\n## 알아두면 좋은 점\n\n- `headers` 함수는 비동기(async) 함수라 Promise를 반환해요. 그래서 `async/await` 문법이나 React에서 제공하는 hook들을 사용해야 합니다.\n\n- Next.js 14버전 이전까진 `headers`가 동기 함수였는데, Next.js 15버전에서도 아직 동기 방식으로 접근은 가능하지만 점점 사라질 예정이에요. 호환성 때문에 아직 남겨두고 있긴 합니다.\n\n- `headers`는 읽기 전용(Read-only)입니다. 그래서 요청 헤더를 새로 설정하거나 삭제하는 건 불가능해요.\n\n- `headers`가 동적으로 API 값을 반환하기 때문에, 해당 라우트(페이지)는 자동으로 ‘동적 렌더링’ 모드로 들어갑니다. 정적 생성(Static Generation)이 필요한 상황에서는 주의하세요.\n\n---\n\n혹시 `Headers` 객체를 사용할 때 어떻게 데이터를 순회하는지 궁금하다면, 다음처럼 간단한 예제도 있어요!\n\n```js\nconst headers = new Headers();\nheaders.append('Content-Type', 'application/json');\nheaders.append('X-Custom-Header', 'Value123');\n\nfor (const [key, value] of headers.entries()) {\n  console.log(`${key}: ${value}`);\n}\n\nheaders.forEach((value, key) =\u003e {\n  console.log(`${key} = ${value}`);\n});\n```\n\n이런 식으로 `entries()`로 반복문 사용하거나 `forEach`를 바로 쓸 수 있어요.\n\n개발하시면서 Headers 객체를 다룰 일이 많다면, 이런 기본 메서드들을 익혀두면 훨씬 편리합니다. 꼭 기억해두세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### Authorization 헤더 사용하기\n\n```js\nimport { headers } from 'next/headers'\n \nexport default async function Page() {\n  const authorization = (await headers()).get('authorization')\n  const res = await fetch('...', {\n    headers: { authorization }, // Authorization 헤더 전달하기\n  })\n  const user = await res.json()\n \n  return \u003ch1\u003e{user.name}\u003c/h1\u003e\n}\n```\n\n여기서 중요한 점은, Next.js 13부터 `headers()` 함수가 비동기 함수가 되었다는 거예요. 그래서 `await headers()`로 호출해야 하고, 그 결과에서 `authorization` 헤더 값을 가져올 수 있습니다. 그리고 이 값을 fetch 요청의 헤더로 그대로 넘겨줘서, 서버 간 인증 정보를 전달할 수 있죠.\n\n이 방법은 특히 API 라우트나 서버 컴포넌트에서 클라이언트가 보낸 헤더를 그대로 백엔드 API에 넘길 때 유용해요. 예를 들어, JWT 토큰을 포함한 Authorization 헤더를 안전하게 전달할 수 있다는 뜻이죠.\n\n다만, Authorization 헤더에는 민감한 정보가 많이 담기므로, 꼭 신뢰할 수 있는 환경에서만 이렇게 포워딩하고, 노출되지 않도록 주의해야 합니다.\n\n---\n\n## 버전 히스토리\n\n| Version         | Changes                                                                                      |\n|-----------------|----------------------------------------------------------------------------------------------|\n| `v15.0.0-RC`    | `headers`가 이제 비동기 함수가 되었습니다. 관련 코드 변경을 도와주는 \u003ca href=\"/docs/app/guides/upgrading/codemods#150\"\u003ecodemod\u003c/a\u003e가 제공됩니다. |\n| `v13.0.0`       | `headers` 함수가 도입되었습니다.                                                              |\n\n---\n\n참고로, 예전 Next.js 버전에서는 `headers`가 동기 함수였는데, 비동기 함수로 변경되면서 더 유연한 비동기 작업이 가능해졌어요. 업그레이드할 때는 이 점 꼭 체크하세요! 그리고 `authorization` 외에도 필요한 다른 헤더들도 동일한 방식으로 가져와서 활용할 수 있답니다.","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":6},{"title":"Next.js 15에서 generateViewport 함수로 반응형 페이지 만드는 방법","description":"","date":"2025-04-22 12:39","slug":"2025-04-22-generateViewport","content":"\n\n# generateViewport\n\n웹페이지의 초기 뷰포트(viewport)를 설정할 때, 정적인 `viewport` 객체나 동적인 `generateViewport` 함수를 사용할 수 있어요.\n\n\u003e 알아두면 좋은 점:\n\u003e - `viewport` 객체와 `generateViewport` 함수는 서버 컴포넌트(Server Components)에서만 지원돼요.\n\u003e - 하나의 라우트 세그먼트(route segment)에서 `viewport` 객체와 `generateViewport` 함수를 동시에 내보낼(export) 수 없답니다.\n\u003e - 만약 메타데이터(metadata) 내보내기(export) 방식을 이전 버전에서 마이그레이션하는 중이라면, `metadata-to-viewport-export` 코드를 자동 변환해주는 codemod를 활용하면 편리해요.\n\n## viewport 객체\n\n(여기서부터는 viewport 객체에 대한 설명이 이어질 텐데, 필요하면 추가로 알려드리겠습니다!)\n\n---\n\n### 조금 더 부연 설명\n\n`generateViewport`는 화면 크기나 사용자 환경에 맞춰 화면 표시를 동적으로 조정하고 싶을 때 유용해요. 예를 들어, 데스크탑과 모바일을 구분해서 뷰포트 설정을 다르게 하고 싶을 때 사용할 수 있죠.\n\n반대로, `viewport` 객체는 애초에 고정된 초기값을 정할 때 적합합니다. 보통 한 가지 뷰포트 설정으로 충분한 경우라면 이걸 사용하면 돼요.\n\n서버 컴포넌트에서만 지원된다는 점도 기억해야 해요. 클라이언트 컴포넌트에서는 이 기능을 사용할 수 없으니, 뷰포트를 조절하려면 서버 사이드 렌더링 또는 서버 컴포넌트를 활용해야 한답니다.\n\n다음에는 예제 코드와 함께 자세히 보여드릴게요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n뷰포트(viewport) 설정을 정의하려면, `layout.jsx` 또는 `page.jsx` 파일에서 뷰포트 객체를 export 하면 돼요.\n\n```js\nimport type { Viewport } from 'next'\n\nexport const viewport: Viewport = {\n  themeColor: 'black',\n}\n\nexport default function Page() {}\n```\n\n여기서 `viewport` 객체에 여러 옵션들을 넣을 수 있는데, 예를 들어 `themeColor`를 지정해서 브라우저 테마 색상을 바꿀 수 있어요. 이렇게 하면 사용자의 환경에 맞게 더 맞춤화된 UI를 제공할 수 있답니다.\n\n---\n\n### generateViewport 함수\n\n`generateViewport` 함수는 하나 이상의 뷰포트 필드를 포함하는 `Viewport` 객체를 반환해야 해요. 즉, 동적으로 뷰포트 옵션을 생성하고 싶을 때 이 함수를 사용하면 유용하죠.\n\n예를 들어, 사용자의 설정이나 페이지 상태에 따라 뷰포트 메타 정보를 바꿔야 할 때 `generateViewport`를 작성할 수 있습니다.\n\n```js\nimport type { Viewport } from 'next'\n\nexport function generateViewport(): Viewport {\n  return {\n    themeColor: 'blue',\n    initialScale: 1,\n    width: 'device-width',\n  }\n}\n```\n\n이렇게 하면서 `themeColor`, `initialScale`, `width` 같은 다양한 뷰포트 관련 설정을 추가할 수 있어요. \n\n---\n\n### 뷰포트 옵션에 대해 조금 더!\n\n뷰포트 설정에 들어가는 일반적인 필드를 몇 가지 소개할게요.\n\n| 필드명         | 설명                                                      |\n| -------------- | --------------------------------------------------------- |\n| `width`        | 뷰포트의 너비를 지정해요. 예: 'device-width' 사용 가능.   |\n| `initialScale` | 페이지 로드 시 초기 확대/축소 비율을 설정해요.             |\n| `minimumScale` | 사용자가 최소 확대/축소할 수 있는 비율.                    |\n| `maximumScale` | 사용자가 최대 확대/축소할 수 있는 비율.                    |\n| `userScalable` | 사용자가 확대/축소 가능 여부 설정 ('yes' 또는 'no').       |\n| `themeColor`   | 브라우저의 주소창 색상 등에서 사용할 테마 색상을 지정해요. |\n\n이 필드들을 적절히 조합해서 모바일에서 최적의 UX를 제공할 수 있습니다!\n\n---\n\n요약하자면, Next.js에서 뷰포트를 설정할 땐 `export const viewport` 나 `generateViewport` 함수를 활용하는데, 동적 설정이 필요하다면 후자를, 고정 값만 필요하다면 전자를 쓰시면 돼요. 쉽죠? 필요한 옵션들을 잘 심어서 모바일 사용자에게 더 좋은 화면 경험을 선사해봅시다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 코드는 Next.js 같은 프레임워크에서 뷰포트(Viewport)를 동적으로 생성하는 함수예요.\n\n```js\nexport function generateViewport({ params }) {\n  return {\n    themeColor: '...',\n  }\n}\n```\n\n여기서 `generateViewport` 함수는 뷰포트 설정을 runtime(실행 시점)에 맞춰서 동적으로 리턴해주는데요, 중요한 점은 다음과 같습니다.\n\n\u003e 참고!  \n\u003e 만약 뷰포트가 실행 시점과 상관없이 항상 똑같다면, 이 함수를 쓰지 말고 정적인(static) viewport 객체를 만들어서 쓰는 게 더 좋아요. 이렇게 하면 빌드 타임에 최적화가 가능하거든요.\n\n---\n\n## 뷰포트(Viewport) 필드 정리\n\n### themeColor\n\n- `themeColor`는 모바일 브라우저에서 사용자가 보는 브라우저 UI, 상태 바(status bar) 등의 색상을 정하는 필드입니다.\n- 예를 들어, iOS Safari에서는 이 색상이 상단 상태 바 색상으로 적용되고, Android에서는 툴바 색상 등에 활용돼요.\n- 색상을 지정하면 웹사이트의 아이덴티티를 좀 더 강하게 보여줄 수 있어서 사용자 경험(UX)을 향상시키는 데 도움 됩니다.\n\n---\n\n### 추가로 알려드리고 싶은 팁!\n\n많은 개발자가 메타 태그(meta tag)를 통해 `theme-color`를 직접 넣어 관리하는데, Next.js 같은 최신 프레임워크에서는 이처럼 뷰포트 설정을 함수 또는 객체로 관리함으로써 좀 더 깔끔하고 일관된 방법으로 처리할 수 있어요.\n\n또한, 다이나믹하게 `themeColor`를 바꿔야 한다면, URL 파라미터(`params`) 같은 runtime 데이터에 따라 조건을 걸어 다양한 색상을 반환하는 것도 가능하니 참고하세요!\n\n---\n\n필요하다면 나중에 `generateViewport` 이외의 다른 뷰포트 속성이나 관련 메타 태그 설정도 함께 정리해볼게요. 지금은 `themeColor`에 집중해서 말씀드렸고, 다음에는 `viewport`의 다른 필드들(예: width, initial-scale 등)도 다뤄보겠습니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\ntheme-color에 대해 좀 더 쉽게 설명해볼게요.\n\n---\n\n## theme-color란?\n\n웹사이트를 모바일 기기에서 열었을 때, 브라우저 상단 바(상태 표시줄)의 배경색을 설정할 수 있게 해주는 메타 태그예요. 즉, 사용자가 사이트를 더 깔끔하고 통일감 있게 느낄 수 있도록 도와주죠.\n\n---\n\n## 간단한 theme-color 사용법\n\n1. Next.js 같은 프레임워크를 쓴다면, viewport 설정에 `themeColor`를 지정할 수 있어요.\n\n```js\nimport type { Viewport } from 'next'\n\nexport const viewport: Viewport = {\n  themeColor: 'black',\n}\n```\n\n2. 혹은 HTML 문서에 메타 태그로 직접 넣어줄 수도 있습니다.\n\n```html\n\u003cmeta name=\"theme-color\" content=\"black\" /\u003e\n```\n\n---\n\n## 알아두면 좋은 점\n\n- 색상은 기본 CSS 색상 값이나 헥스 컬러코드(`#000000`) 모두 가능해요.\n- 안드로이드 크롬에서 특히 잘 작동하며, iOS 사파리는 아직 완전 지원하지는 않습니다.\n- `theme-color` 덕분에 사용자가 사이트를 북마크하거나 홈 화면에 추가했을 때도 바탕색이 설정된 느낌을 줄 수 있어요.\n\n---\n\n## 조금 더 활용해보기\n\n브라우저나 다크 모드에 따라 다르게 색을 지정하고 싶다면, 미디어 쿼리를 사용해서 조건부로 `theme-color`를 설정할 수 있답니다.\n\n예를 들어:\n\n```html\n\u003cmeta name=\"theme-color\" content=\"#ffffff\" media=\"(prefers-color-scheme: light)\" /\u003e\n\u003cmeta name=\"theme-color\" content=\"#000000\" media=\"(prefers-color-scheme: dark)\" /\u003e\n```\n\n이렇게 하면 사용자의 다크 모드 여부에 따라 자동으로 테마 컬러가 변경돼서 훨씬 세련된 UX를 만들 수 있어요.\n\n---\n\n간단하지만 뜻밖에 사이트 인상에 큰 영향을 주는 `theme-color`! 놓치지 말고 꼭 활용해보세요 :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번에 살펴볼 내용은 Next.js에서 제공하는 `Viewport` 타입 예시인데요, 특히 테마 색상(theme-color)을 미디어 쿼리(media attribute)를 활용해서 조건부로 적용하는 방법이에요.\n\n```js\nimport type { Viewport } from 'next'\n\nexport const viewport: Viewport = {\n  themeColor: [\n    { media: '(prefers-color-scheme: light)', color: 'cyan' },\n    { media: '(prefers-color-scheme: dark)', color: 'black' },\n  ],\n}\n```\n\n이렇게 하면, 사용자가 밝은 모드(light mode)를 사용하면 테마 색상이 cyan, 어두운 모드(dark mode)를 사용하면 black으로 자동 설정됩니다.\n\n실제 HTML에서는 이런 meta 태그로 변환돼요:\n\n```html\n\u003cmeta name=\"theme-color\" media=\"(prefers-color-scheme: light)\" content=\"cyan\" /\u003e\n\u003cmeta name=\"theme-color\" media=\"(prefers-color-scheme: dark)\" content=\"black\" /\u003e\n```\n\n이 meta 태그의 `media` 속성은 브라우저의 미디어 쿼리 조건을 활용해서, 특정 조건일 때만 해당 테마 색상을 적용하게 해줍니다. 덕분에 사용자 환경에 따라 자동으로 색상이 바뀌어 UX가 좋아지죠.\n\n---\n\n### width, initialScale, maximumScale, userScalable\n\n이번엔 뷰포트 설정에서 자주 쓰는 속성들에 대해 간단히 정리해볼게요.\n\n| 속성명           | 설명                                                         |\n|------------------|--------------------------------------------------------------|\n| `width`          | 뷰포트의 너비를 설정합니다. 보통 `device-width`를 많이 씁니다.       |\n| `initialScale`   | 초기 배율을 정합니다. 예: 1.0은 100% 크기라는 뜻이에요.           |\n| `maximumScale`   | 사용자가 확대할 수 있는 최대 배율을 지정합니다.                   |\n| `userScalable`   | 사용자가 확대/축소 가능 여부를 설정합니다. `yes` 또는 `no` 값 사용. |\n\n예를 들면, 이렇게 쓸 수 있어요:\n\n```html\n\u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\" /\u003e\n```\n\n- `width=device-width`: 뷰포트 너비를 디바이스 화면 너비에 맞춤\n- `initial-scale=1.0`: 페이지 처음 로딩 시 확대/축소 안됨\n- `maximum-scale=1.0`: 사용자가 확대할 수 있는 최대 크기를 1배로 제한\n- `user-scalable=no`: 사용자가 화면 확대/축소를 못 하게 제한\n\n요즘은 접근성 측면에서 `user-scalable=no`는 주의해서 써야 합니다. 모바일 사용자가 글자가 작다면 확대할 수 있는 게 좋거든요. 따라서 특별한 이유가 없다면 확대 제한을 두지 않는 걸 추천합니다.\n\n---\n\n이렇게 meta 태그에서 다양한 뷰포트 설정과 미디어 조건을 활용하면, 사용자 환경에 딱 맞는 페이지를 만드는 데 큰 도움이 돼요. Next.js 같은 modern 프레임워크에서도 타입으로 안전하게 관리할 수 있으니, 한번 적용해보시면 좋겠습니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n알아두면 좋은 점: Next.js에서는 뷰포트(viewport) meta 태그가 자동으로 설정돼서 보통은 따로 만질 필요가 없어요. 기본 설정이 대부분의 경우에 딱 맞기 때문이죠. 그래도 완전한 정보를 위해 어떻게 설정할 수 있는지 예시를 알려드릴게요.\n\n```js\nimport type { Viewport } from 'next'\n\nexport const viewport: Viewport = {\n  width: 'device-width',\n  initialScale: 1,\n  maximumScale: 1,\n  userScalable: false,\n  // 좀 덜 자주 쓰이긴 하는데 아래 옵션도 지원돼요\n  // interactiveWidget: 'resizes-visual',\n}\n```\n\n그리고 HTML에서 직접 메타 태그로 작성하면 이렇게 생겼어요:\n\n```html\n\u003cmeta\n  name=\"viewport\"\n  content=\"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no\"\n/\u003e\n```\n\n여기서 한 가지 팁을 더 드리자면, `user-scalable=no` 옵션은 사용자가 페이지를 핀치 줌(pinch zoom)으로 확대하는 것을 막아요. 이게 디자인을 고정하고 싶을 때는 좋은데, 접근성 측면에서는 주의가 필요해요. 사용자들이 글자 크기를 키워서 보는 걸 방해할 수 있으니까요.\n\n---\n\n### colorScheme\n\n다음으로는 `colorScheme`에 대해 간단히 설명해볼게요. 웹사이트나 앱에서 다크 모드, 라이트 모드 같은 색상 테마를 지원할 때 사용하는 설정이에요. 예를 들어, 사용자의 OS 설정에 따라 자동으로 다크 모드가 적용되게 하거나, 특정 테마를 강제할 수 있죠.\n\nNext.js나 React를 사용할 때는 보통 CSS 미디어쿼리 `prefers-color-scheme`을 활용하거나, 상태 관리로 테마를 바꾸는 방식으로 구현해요.\n\n```css\n@media (prefers-color-scheme: dark) {\n  body {\n    background-color: #121212;\n    color: #ffffff;\n  }\n}\n\n@media (prefers-color-scheme: light) {\n  body {\n    background-color: #ffffff;\n    color: #000000;\n  }\n}\n```\n\n또한, Next.js 13부터는 내장된 `colorScheme` 타입이나 설정을 활용해 더 간편하게 테마를 관리하는 방법도 있답니다. 궁금하시면 더 알려드릴게요!\n\n---\n\n뷰포트 설정과 색상 테마, 요 두 가지는 요즘 프론트엔드 개발에서 사용자 경험을 좌우하는 중요한 부분이니 꼭 기억해두세요. 다른 궁금한 점 있으면 언제든 질문해 주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\ncolor-scheme에 대해 더 알아보기\n\n웹 개발하다 보면 사용자 기기의 테마(라이트 모드, 다크 모드)에 맞춰 UI를 자동으로 조정하고 싶을 때가 있죠? 이럴 때 유용한 게 바로 `color-scheme`입니다.\n\n`color-scheme`는 브라우저나 OS가 현재 페이지의 색상 모드(라이트, 다크, 혹은 둘 다)를 알려주는 역할을 해요. 쉽게 말해, 당신의 사이트가 어떤 테마를 지원하는지 브라우저에게 알려주는 설정이라 볼 수 있어요.\n\n예를 들어 Next.js 같은 프레임워크에서 `viewport` 타입 설정할 때 이렇게 사용할 수 있어요:\n\n```js\nimport type { Viewport } from 'next'\n\nexport const viewport: Viewport = {\n  colorScheme: 'dark',\n}\n```\n\n그리고 HTML 메타태그로도 지정해줄 수 있답니다.\n\n```html\n\u003cmeta name=\"color-scheme\" content=\"dark\" /\u003e\n```\n\n이 메타 태그를 넣으면 브라우저가 다크 모드 환경에 맞춰 스크롤바나 기본 UI 요소의 색상을 조정해줍니다. 물론, 이건 사이트 내부 스타일에 영향을 주는 게 아니라 브라우저 레벨에서 UI를 맞춰주는 거라서 직접 CSS에서 따로 색상 조정을 해주는 것과는 차이가 있어요.\n\n## color-scheme의 타입 종류\n\n| 타입명      | 설명                                    |\n|-------------|---------------------------------------|\n| `normal`    | 기본적인 라이트 모드 (기본값)           |\n| `dark`      | 다크 모드 지원                         |\n| `light`     | 라이트 모드 지원                       |\n| `only`      | 특정 모드만 사용 (예: 다크 모드만 허용) |\n\n한 가지 팁! 다크 모드를 완벽히 지원하려면 `color-scheme` 설정뿐 아니라 `prefers-color-scheme` 미디어 쿼리도 같이 사용해서 사용자 테마에 따라 스타일을 다르게 적용해줘야 해요.\n\n```css\n@media (prefers-color-scheme: dark) {\n  body {\n    background-color: #121212;\n    color: #ffffff;\n  }\n}\n```\n\n이렇게 하면 사용자의 OS 설정과 심리스하게 연동되는 사이트를 만들 수 있답니다. `color-scheme` 메타 태그는 주로 브라우저 기본 UI의 색상 조절을 돕는 역할이라고 생각하면 돼요!\n\n그럼 오늘은 여기까지! 다음에 또 흥미로운 웹 개발 팁으로 찾아올게요 :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번 포스트에서는 Next.js에서 뷰포트(Viewport) 객체에 타입 안전성을 추가하는 방법에 대해 이야기해보려고 해요. 자바스크립트로 작성하면 타입에 대해 신경 쓰지 않아도 되지만, 타입스크립트를 쓴다면 명확하게 타입을 지정해주는 게 훨씬 안정적이고 실수도 줄일 수 있답니다.\n\n### viewport 객체에 타입 지정하기\n\nNext.js에서 뷰포트 객체를 만들 때 `Viewport` 타입을 사용하면, 해당 객체가 어떤 속성을 가져야 하는지 IDE가 바로 알려주기 때문에 실수를 미리 방지할 수 있어요. TypeScript를 지원하는 IDE를 쓴다면 타입을 명시하지 않아도 자동으로 감지해주지만, 명시적으로 적어두면 다른 개발자들이 코드를 이해할 때 더 쉽고 명확하답니다.\n\n```ts\nimport type { Viewport } from 'next';\n\nexport const viewport: Viewport = {\n  themeColor: 'black',\n};\n```\n\n위 코드에서 `viewport` 객체는 `Viewport` 타입을 명시적으로 지정해줬어요. 이렇게 하면 `themeColor` 외에도 `Viewport` 타입에 정의되어 있는 다른 속성들을 자동 완성으로 안내받을 수 있답니다.\n\n또한, 이렇게 타입을 선언하면 잘못된 타입을 넣었을 때 컴파일 타임에 바로 오류를 잡아줘서 버그를 줄이는 데 큰 도움이 돼요.\n\n### 추가 팁: generateViewport 함수에 타입 적용하기\n\n`Viewport` 타입은 뷰포트 정보를 다루는 함수, 예를 들어 `generateViewport` 같이 뷰포트 데이터를 생성하는 함수에도 적용할 수 있어요. 이렇게 하면 함수가 리턴하는 데이터가 항상 타입에 맞는지 보장할 수 있죠.\n\n다음 포스트에서는 `generateViewport` 함수에서 어떻게 타입을 활용하는지 실제 예시를 들면서 말씀드릴게요~!\n\n---\n\n이처럼 Next.js와 TypeScript를 함께 쓰면, 뷰포트뿐만 아니라 다양한 객체에 타입을 명확하게 지정하여 안전한 코드를 작성할 수 있답니다. 앞으로도 더 많은 타입스크립트 활용법을 공유할 테니 기대해 주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안녕하세요! 오늘은 `generateViewport`라는 함수를 살펴보면서, Next.js에서 Viewport를 어떻게 다루는지 간단히 알아볼게요. 코드도 같이 보면서 쉽게 이해해볼까요?\n\n---\n\n### 일반 함수 형식\n\n먼저 가장 기본적인 형태부터 볼게요.\n\n```js\nimport type { Viewport } from 'next'\n \nexport function generateViewport(): Viewport {\n  return {\n    themeColor: 'black',\n  }\n}\n```\n\n여기선 `generateViewport`라는 함수를 정의했고, Next.js에서 타입을 가져와 `Viewport` 타입으로 리턴을 명확히 해줬어요. 실제로 리턴되는 값은 `themeColor: 'black'` 하나뿐인데요, 이처럼 간단하게 뷰포트 관련 설정을 만들 수 있습니다.\n\n---\n\n### 세그먼트 Props를 받는 경우\n\n이번엔 Next.js의 동적 라우팅에서 자주 보는 segment props를 매개변수로 사용하는 버전이에요.\n\n```ts\nimport type { Viewport } from 'next'\n \ntype Props = {\n  params: Promise\u003c{ id: string }\u003e\n  searchParams: Promise\u003c{ [key: string]: string | string[] | undefined }\u003e\n}\n \nexport function generateViewport({ params, searchParams }: Props): Viewport {\n  return {\n    themeColor: 'black',\n  }\n}\n \nexport default function Page({ params, searchParams }: Props) {}\n```\n\n| 내용 | 설명 |\n|-------|------------|\n| `params` | URL 경로에 포함된 변수예요. 예를 들어 `/posts/123`에서 `id`가 `123`이 됩니다. |\n| `searchParams` | URL의 쿼리스트링, 예를 들어 `?sort=asc`와 같은 부분을 의미해요. |\n\n여기서 조금 신기한 점은 `params`와 `searchParams`가 `Promise` 타입이라는 거예요. 보통은 동기적으로 바로 값을 받는데, 비동기적으로 처리할 수도 있게 설계한 거죠. 미래에 API 호출이나 파일 읽기 같은 비동기 작업과 연동하기에 유용해요.\n\n---\n\n### 추가 팁!\n\n- `generateViewport` 함수는 페이지 렌더링 시 뷰포트 설정을 동적으로 제어할 수 있게 해줘서, 다양한 테마를 적용하거나 사용자에 맞춘 UI 조절에 쓰기 좋아요.\n- 만약 `searchParams`가 배열 형태일 수도 있기 때문에 타입에 그런 부분도 반영해두었는데, 실제 활용하면서 쿼리 파라미터에 따라 조건화를 할 때 유용합니다.\n- Next.js 13버전 이상의 앱 디렉터리 구조를 사용한다면, 이런 타입과 함수 구조가 점점 더 중요해지고 있으니 익혀두면 좋아요.\n\n이처럼 기본부터 비동기 props까지, `generateViewport` 함수가 어떻게 활용될 수 있는지 감이 잡히셨나요? 다음에 더 재밌는 주제로 또 찾아올게요! 🙌\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n#### JavaScript 프로젝트에서 JSDoc으로 타입 안정성 높이기\n\nJavaScript로 프로젝트를 하다 보면, 타입 안정성이 아쉬울 때가 많죠. 이럴 때 TypeScript로 전환하는 것도 방법이지만, 규모가 크지 않거나 빠르게 작업할 때는 조금 부담스러울 수 있어요. 그래서 추천하는 것이 바로 **JSDoc**을 활용하는 방법입니다.\n\n예를 들어, Next.js 프로젝트에서 특정 객체에 타입을 지정하고 싶은 경우, 이렇게 작성할 수 있어요:\n\n```js\n/** @type {import(\"next\").Viewport} */\nexport const viewport = {\n  themeColor: 'black',\n}\n```\n\n여기서 `@type` 태그를 사용하여 `next` 패키지에서 제공하는 `Viewport` 타입을 참조한 거죠. 이걸 하면 에디터에서 자동완성도 되고, 타입에 맞지 않는 값을 넣으면 경고가 뜨기 때문에 실수 확률을 줄일 수 있어요.\n\n### 이 방법의 장점과 팁\n\n- **TypeScript 전환 없이도 타입 안정성 얻기**: 기존 자바스크립트 코드를 크게 바꾸지 않고도 타입 체크 기능을 누릴 수 있어요.\n- **에디터 지원**: VSCode 같은 에디터에서 JSDoc 주석을 분석해 자동완성, 리팩토링 도움 기능을 제공합니다.\n- **공식 타입 활용 가능**: 외부 라이브러리나 프레임워크의 타입 정의를 그대로 참고할 수 있어서, 타입 정의를 새로 만들 필요가 없어요.\n\n만약 좀 더 큰 프로젝트라면, JSDoc과 함께 **TypeScript로 점진적 전환**을 고려해 보는 것도 좋아요. 처음엔 JSDoc으로 조금씩 타입을 적용하고, 필요에 따라 `.ts` 혹은 `.tsx` 파일을 만들어 나가는 전략입니다.\n\n---\n\n## 버전 히스토리 (Version History)\n\n이 부분은 주로 프로젝트의 변경 이력을 기록하는 공간인데요, 아래와 같은 형식으로 정리해 두면 좋아요.\n\n| 날짜         | 버전   | 변경 내용                             |\n|--------------|--------|-------------------------------------|\n| 2024-06-01   | 1.0.0  | 프로젝트 초기 버전 배포              |\n| 2024-06-15   | 1.1.0  | JSDoc 타입 주석 추가 및 코드 정리   |\n\n시간이 지나면서 어떤 기능이 추가됐고, 어떤 버전을 사용해야 하는지 명확해져서 협업에도 도움이 됩니다. 프로젝트 초반에 간단히라도 버전 히스토리 관리하는 습관, 꼭 추천드려요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n| Version   | Changes                                  |\n|-----------|------------------------------------------|\n| `v14.0.0` | `viewport`와 `generateViewport`가 추가됨 |\n\n여기서 `viewport`와 `generateViewport`는 웹 개발할 때 화면 크기나 뷰포트 관련 작업을 할 때 엄청 유용한 기능이에요. 특히 반응형 디자인을 구현할 때 이 두가지를 잘 활용하면 더 깔끔하고 효율적으로 화면 크기를 조절할 수 있답니다. 다음번에 이 기능들에 대해 더 자세히 파헤쳐볼게요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":17},{"title":"Next.js 13에서 generateStaticParams 사용법 정리","description":"","date":"2025-04-22 12:37","slug":"2025-04-22-generateStaticParams","content":"\n\n# generateStaticParams 함수 알아보기\n\nNext.js에서 동적 라우트(dynamic route)를 사용할 때, `generateStaticParams` 함수를 활용하면 **빌드 시점에 미리 정적 페이지들을 생성**할 수 있어요. 덕분에 사용자가 페이지를 요청할 때마다 서버에서 동적으로 처리하는 게 아니라, 빠르게 미리 만들어 둔 페이지를 보여줄 수 있답니다.\n\n---\n\n## 어떻게 동작하나요?\n\n```js\n// [slug] 같은 동적 경로에 들어갈 param들을 미리 만들어 반환하는 함수예요!\nexport async function generateStaticParams() {\n  const posts = await fetch('https://.../posts').then((res) =\u003e res.json())\n \n  return posts.map((post) =\u003e ({\n    slug: post.slug,\n  }))\n}\n \n// 미리 뽑아낸 param들로 여러 버전의 페이지가 생성돼요\nexport default async function Page({\n  params,\n}: {\n  params: Promise\u003c{ slug: string }\u003e\n}) {\n  const { slug } = await params\n  // 해당 slug를 이용해 데이터를 가져오거나 렌더링을 진행해요\n}\n```\n\n이렇게 하면 `posts` 데이터에서 각 `slug`를 뽑아내서, 각 슬러그 별로 페이지가 **스태틱하게 생성**되죠.\n\n---\n\n## 알아두면 좋은 점\n\n| 포인트 | 설명 |\n|---|---|\n| `dynamicParams` 옵션 | `generateStaticParams`로 생성되지 않은 동적 구간에 방문했을 때 어떻게 동작할지 설정 가능해요. |\n| ISR(Incremental Static Regeneration) 설정 | 만약 런타임에 경로의 재검증이 필요하다면, 빈 배열을 반환하거나 `export const dynamic = 'force-static'`를 사용해야 해요. |\n| 실행 시점 | - 개발 모드(`next dev`)에서는 라우트를 방문할 때마다 `generateStaticParams`가 호출돼요.\u003cbr\u003e- 빌드 시점(`next build`)에는 관련 레이아웃이나 페이지가 생성되기 전에 한 번 호출돼요.\u003cbr\u003e- ISR에서는 다시 호출되지 않아요. |\n| 기존 함수와 비교 | 기존 Pages Router의 `getStaticPaths` 함수 대신 사용된답니다. |\n\n---\n\n## TIP! 더 편리하게 사용하려면?\n\n1. **빨리 빌드하는 방법**: 너무 많은 페이지를 한 번에 만드는 경우 빌드 시간이 길어져서 시간이 한참 걸릴 수 있어요. 필요한 핵심 데이터만 뽑거나, 자주 바뀌지 않는 부분만 `generateStaticParams`로 처리하는 게 좋아요.\n\n2. **ISR과 함께 쓰기**: `generateStaticParams`로 만드는 정적 페이지가 오래되어 조금씩 바뀌는 데이터라면, ISR 설정으로 일정 시간마다 다시 빌드 없이 업데이트되게 하는 것도 좋아요.\n\n3. **`dynamicParams` 활용법**: 만약 generateStaticParams에 없는 슬러그가 들어오는 상황을 대비해, `dynamicParams: true` 옵션을 설정해 동적 경로를 SSR으로 처리할 수도 있어요.\n\n---\n\nNext.js 13의 `app` 디렉토리를 사용한다면 이 기능은 꼭 익혀 두세요! 덕분에 사용자에게 훨씬 빠른 페이지 로딩 속도와 좋은 경험을 제공할 수 있답니다.😉\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 파라미터(Parameters)\n\n`options.params` (선택 사항)\n\n만약 라우트(route)에 여러 개의 동적 세그먼트(dynamic segment)가 있고, 각각 `generateStaticParams`를 사용한다면, 자식의 `generateStaticParams` 함수는 부모가 생성한 파라미터 집합(params)마다 한 번씩 실행됩니다.\n\n여기서 중요한 점은, 자식 세그먼트에서 사용하는 `params` 객체는 부모의 `generateStaticParams`에서 만들어진 파라미터들을 포함하고 있다는 거예요. 즉, 부모가 생성한 파라미터를 활용해서 자식 세그먼트의 파라미터를 만들 수 있다는 뜻이죠.\n\n---\n\n예를 들어, 부모 라우트에서 카테고리를 생성하고, 자식 라우트에서 해당 카테고리 내의 상품 ID를 생성하는 경우를 생각해 볼 수 있습니다. 이렇게 하면 부모-자식 관계를 유지하면서도 각각의 동적 경로를 효율적으로 생성할 수 있겠죠.\n\n이 구조는 Next.js 같은 프레임워크에서 정적 사이트 생성(Static Site Generation) 시 매우 유용하니, 동적 라우팅을 할 때 꼭 기억해두시면 좋습니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Returns (반환값)\n\n`generateStaticParams` 함수는 배열을 반환해야 하는데, 이 배열 안에는 각 경로(dynamic route)의 동적 세그먼트(dynamic segment)가 담긴 객체들이 들어 있습니다.\n\n- 배열 안의 각 객체는 해당 경로의 동적 세그먼트 이름과, 그 세그먼트에 채워질 값을 프로퍼티로 가지고 있어요.\n- 여기서 프로퍼티의 이름은 세그먼트 이름과 똑같고, 값은 해당 세그먼트에 들어가야 할 실제 값이 됩니다.\n\n아래 표를 보시면 이해가 더 쉽습니다.\n\n| 예시 경로                         | `generateStaticParams`가 반환하는 타입         |\n|----------------------------------|---------------------------------------------|\n| `/product/[id]`                  | `{ id: string }[]`                           |\n| `/products/[category]/[product]` | `{ category: string, product: string }[]`   |\n| `/products/[...slug]`             | `{ slug: string[] }[]`                        |\n\n---\n\n### 조금 더 풀어보자면...\n\n- `[id]`처럼 하나의 세그먼트가 들어가는 경로는, 객체 안에 그 세그먼트 이름(`id`)을 키로 두고 문자열 값을 넣으면 됩니다.\n- `[category]`와 `[product]` 같이 여러 동적 세그먼트가 있을 땐, 각각 키로 넣고 값도 각각 넣으면 돼요.\n- 그리고 `[...slug]`처럼 'catch-all' 세그먼트는 배열 형태의 문자열로 값을 넣어줘야 합니다!\n\n이걸 잘 활용하면 Next.js에서 빌드 타임에 모든 필요한 페이지를 미리 생성할 수 있어서, 성능 최적화에 큰 도움이 됩니다. 꼭 만들어 보시면서 이해해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js 13에서 동적 라우팅을 할 때, 미리 정적인 페이지를 생성하고 싶다면 `generateStaticParams`라는 함수를 활용할 수 있어요. 이 함수에서 반환하는 파라미터들을 기반으로 정적 페이지를 미리 만들어주는 거죠. 어떻게 쓰는지 한 번 살펴볼게요!\n\n---\n\n## 단일 동적 세그먼트 (Single Dynamic Segment)\n\n예를 들어, 상품(id)에 따라 페이지를 미리 생성한다고 하면 이렇게 작성할 수 있어요:\n\n```js\nexport function generateStaticParams() {\n  return [{ id: '1' }, { id: '2' }, { id: '3' }]\n}\n\n// 이렇게 하면 총 세 개의 페이지가 빌드 타임에 생성됩니다:\n// - /product/1\n// - /product/2\n// - /product/3\nexport default async function Page({\n  params,\n}: {\n  params: Promise\u003c{ id: string }\u003e\n}) {\n  const { id } = await params\n  // id를 활용해서 데이터 페칭 또는 렌더링 작업을 수행\n}\n```\n\n여기서 주목할 점은 `params`가 `Promise`라는 점! Next.js 13에서는 비동기 params를 지원하니까, 필요한 데이터를 미리 가져오는 작업을 할 때 유용합니다.\n\n---\n\n## 다중 동적 세그먼트 (Multiple Dynamic Segments)\n\n이번엔 URL에 동적 세그먼트가 2개 이상인 경우예요. 예를 들어 카테고리와 상품 ID가 함께 있을 때:\n\n```js\nexport function generateStaticParams() {\n  return [\n    { category: 'a', product: '1' },\n    { category: 'b', product: '2' },\n    { category: 'c', product: '3' },\n  ]\n}\n\n// 이렇게 하면 총 세 개의 페이지가 생성됩니다:\n// - /products/a/1\n// - /products/b/2\n// - /products/c/3\nexport default async function Page({\n  params,\n}: {\n  params: Promise\u003c{ category: string; product: string }\u003e\n}) {\n  const { category, product } = await params\n  // category와 product 값을 바탕으로 페이지 렌더링\n}\n```\n\n이처럼 여러 개의 동적 세그먼트가 있을 때도 `generateStaticParams`에서 각각의 조합을 배열로 반환해주면 빌드 시에 모두 커버되는 페이지를 만들어줍니다.\n\n---\n\n## 개인적인 팁\n\n- `generateStaticParams`는 꼭 필요한 페이지를 미리 생성하는 용도로 써야 해요. 너무 많은 조합을 만들면 빌드 시간이 엄청 길어질 수 있으니까 주의!\n- 만약 데이터가 너무 많거나 자주 변동된다면, SSR(Server Side Rendering)이나 ISR(Incremental Static Regeneration)을 함께 활용하는 것도 좋은 방법입니다.\n- 타입스크립트를 쓴다면 `params` 타입을 명확히 지정해두면 코드 자동완성이나 안정성 측면에서 더 좋아요.\n\n다음 프로젝트에 이 기능 써보면 SEO와 성능에 좋은 긍정적인 효과를 직접 느낄 수 있을 거예요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Catch-all Dynamic Segment 알아보기\n\n위 예제를 보면, Next.js 같은 프레임워크에서 동적 경로를 한꺼번에 처리하는 방식을 보여주고 있어요. `slug`라는 배열을 이용해 여러 레벨의 URL 세그먼트를 잡아낼 수 있죠.\n\n```js\nexport function generateStaticParams() {\n  return [{ slug: ['a', '1'] }, { slug: ['b', '2'] }, { slug: ['c', '3'] }]\n}\n\n// 이렇게 반환된 params로 세 가지 페이지가 정적 생성돼요:\n// - /product/a/1\n// - /product/b/2\n// - /product/c/3\n\nexport default async function Page({\n  params,\n}: {\n  params: Promise\u003c{ slug: string[] }\u003e\n}) {\n  const { slug } = await params\n  // 실제 페이지 내용 처리\n}\n```\n\n이처럼 `generateStaticParams` 함수가 여러 경로에 대한 파라미터를 배열로 반환하면, 빌드 시점에 이 경로들이 미리 렌더링됩니다. 그래서 방문자가 해당 URL에 접속하면 서버에서 빠른 응답을 받을 수 있죠.\n\n### 여기서 잠깐!\n\n- **`slug`가 배열인 이유**: 2단계 이상의 동적 경로를 한 번에 잡기 위해서예요. 예를 들어 `/product/a/1`처럼 두 개의 세그먼트가 있으면 `slug`는 `['a', '1']`이 됩니다.\n- **Static Generation \u0026 Dynamic Routing**: 이 패턴은 빌드 시점에 생성 가능한 경로만 미리 만들고, 그렇지 않은 경로는 런타임에서 처리할 수도 있어요. 필요에 따라 혼합해서 쓰면 좋아요.\n\n## 예시\n\n### Static Rendering\n\n아래는 위 코드를 활용해서 실제 페이지를 정적으로 렌더링하는 간단한 예시를 생각해볼 수 있습니다.\n\n| 경로          | 설명                    |\n| ------------- | ----------------------- |\n| /product/a/1  | slug: ['a', '1']        |\n| /product/b/2  | slug: ['b', '2']        |\n| /product/c/3  | slug: ['c', '3']        |\n\n이런 식으로 동적 세그먼트를 유연하게 다룰 수 있는 구조가 되겠죠?\n\n---\n\n동적 라우팅과 정적 생성은 페이지 성능 최적화에 큰 도움이 돼서 꼭 익혀두면 좋아요. 다음 글에서는 이걸 이용해서 더 복잡한 예제도 한번 다뤄볼게요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n#### 빌드 시 모든 경로 미리 생성하기\n\nNext.js에서 페이지를 미리 정적으로 생성하려면, `generateStaticParams` 함수에 생성할 경로(path) 전체 목록을 넘겨줘야 해요. 이렇게 해두면 빌드 타임에 모든 페이지가 미리 렌더링 되어서 빠른 로딩 속도를 기대할 수 있답니다.\n\n예를 들어, 외부 API에서 게시물 목록을 받아와 각 게시물의 슬러그를 기반으로 페이지를 생성하는 코드는 아래와 같아요:\n\n```js\nexport async function generateStaticParams() {\n  const posts = await fetch('https://.../posts').then((res) =\u003e res.json())\n \n  return posts.map((post) =\u003e ({\n    slug: post.slug,\n  }))\n}\n```\n\n이렇게 하면 `posts` 배열 안에 있는 모든 게시물의 `slug`가 각각 정적으로 생성되어, 빌드 시점에 모든 페이지가 만들어져요.\n\n---\n\n#### 참고: 일부 경로만 빌드 시 생성하기\n\n몇 만 개, 몇 십 만 개의 경로가 있을 때는 모든 경로를 빌드 시 생성하는 게 현실적이지 않을 수 있어요. 이럴 땐 일부 경로만 빌드 타임에 미리 생성하고, 나머지는 런타임에 동적으로 처리하는 방법도 있어요.\n\n예를 들어, 인기 게시물만 미리 생성하고 나머지는 필요할 때 렌더링하거나, fallback 옵션을 사용하는 방법이 있죠.\n\n이 부분은 상황에 따라 유연하게 고민해서 적용하면 되니, 다음에 더 자세히 다뤄볼게요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n빌드 시점에 일부 경로만 정적으로 미리 만들어 두고, 나머지 경로는 첫 방문 시에 서버에서 렌더링하고 싶다면, `generateStaticParams` 함수에서 일부 경로만 반환하면 됩니다.\n\n```js\nexport async function generateStaticParams() {\n  const posts = await fetch('https://.../posts').then((res) =\u003e res.json())\n\n  // 첫 10개의 포스트만 빌드 타임에 미리 렌더링\n  return posts.slice(0, 10).map((post) =\u003e ({\n    slug: post.slug,\n  }))\n}\n```\n\n이렇게 하면 상위 10개의 포스트 페이지는 미리 만들어지고, 나머지 페이지는 아직 만들어지지 않은 상태가 됩니다.\n\n그런데 이렇게 되면 아직 정적으로 생성되지 않은 다른 동적 경로에 방문했을 때 어떻게 할지 정해야 하죠. 여기서 `dynamicParams` 옵션을 사용하면 동적 경로가 미리 생성되어 있지 않은 경우의 동작을 제어할 수 있습니다.\n\n```js\n// 상위 10개를 제외한 나머지는 404 페이지를 보여줌\nexport const dynamicParams = false\n\nexport async function generateStaticParams() {\n  const posts = await fetch('https://.../posts').then((res) =\u003e res.json())\n  const topPosts = posts.slice(0, 10)\n\n  return topPosts.map((post) =\u003e ({\n    slug: post.slug,\n  }))\n}\n```\n\n- `dynamicParams = false`로 설정하면, 미리 생성되지 않은 동적 경로에 접근할 경우 404 에러를 띄워줍니다.\n- 반대로 `dynamicParams = true` 혹은 기본값으로 설정하면, 해당 경로를 처음 방문할 때 서버가 동적으로 렌더링해주고 이후에는 캐싱될 수 있습니다.\n\n이 기능 덕분에 빌드 시간을 줄이면서도 원하는 일부 페이지만 미리 렌더링하는 하이브리드 방식을 유연하게 사용할 수 있어요.\n\n---\n\n### 추가 팁!\n\n- 만약 여러분의 데이터가 자주 변하거나 무한히 많다면, 모든 페이지를 빌드 시점에 미리 생성하는 건 비효율적일 수 있어요.\n- 이런 경우 `dynamicParams: true`를 활용해서 사용자가 방문할 때마다 필요한 페이지만 서버에서 렌더링 하거나, ISR(Incremental Static Regeneration) 같은 기술과 조합해 보면 좋습니다.\n- `generateStaticParams`에서 반환하는 경로의 객체 모양은 라우팅에 따라 달라지니, 꼭 라우트 파라미터 이름과 일치하도록 작성해야 해요.\n\n이렇게 Next.js(혹은 비슷한 프레임워크)에서는 정적 생성과 동적 렌더링을 조합해 효율적인 페이지 전략을 짤 수 있으니 프로젝트 상황에 맞게 잘 활용해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n#### 모든 경로를 런타임 시 처리하기\n\n처음 방문할 때 모든 경로를 정적으로 렌더링하려면, `generateStaticParams` 함수에서 빈 배열을 반환하면 됩니다. 이렇게 하면 빌드 시점에는 렌더링할 경로가 없고, 방문하는 순간에 경로가 렌더링되죠. 또는 `export const dynamic = 'force-static'`을 사용해서 강제로 정적 렌더링을 지정할 수도 있어요.\n\n```js\nexport async function generateStaticParams() {\n  return []\n}\n```\n\n\u003e 알아두면 좋은 점: `generateStaticParams` 함수는 항상 배열을 반환해야 합니다. 비어있는 배열이어도 괜찮아요. 만약 배열이 아닌 다른 값을 반환하면 Next.js가 그 경로를 동적 렌더링하게 됩니다.\n\n추가로, 이 점이 중요한 이유는 빌드 타임에 모든 경로를 미리 처리하지 않고, 필요할 때만 렌더링하도록 하여 빌드 시간을 단축하고 서버 리소스를 효율적으로 사용할 수 있기 때문입니다. 특히 사용자마다 동적으로 생성되는 페이지가 많을 때 유용하죠.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nexport const dynamic = 'force-static'\n```\n\n### 지정되지 않은 경로에 대해 렌더링 비활성화하기\n\n런타임에 지정되지 않은 경로가 정적으로 렌더링되는 것을 막으려면, 라우트 세그먼트에 `export const dynamicParams = false` 옵션을 추가하면 됩니다. 이 설정을 사용하면 `generateStaticParams`에서 제공한 경로만 서비스되고, 지정하지 않은 경로는 404 에러가 나거나(캐치올 라우트의 경우 해당 경로와 매칭됨) 처리됩니다.\n\n이 설정은 특히 미리 정해진 경로만 정적으로 생성하고 싶을 때 유용해요. 예를 들어, 블로그 게시글 경로가 미리 모두 정해져 있고, 없는 글에 대한 요청은 404를 보여주고 싶을 때 쓸 수 있죠.\n\n### 여러 개의 동적 세그먼트 다루기\n\nNext.js의 라우팅 시스템은 여러 개의 동적 세그먼트를 한 경로에 넣는 것도 지원해요. 예를 들어, `[category]/[postId]` 같은 식으로요. 이 경우 각 동적 세그먼트에 대응하는 파라미터를 `generateStaticParams` 함수에서 모두 반환해 줘야 정적 생성이 정상적으로 이뤄집니다.\n\n```js\nexport async function generateStaticParams() {\n  return [\n    { category: 'tech', postId: 'nextjs-guide' },\n    { category: 'life', postId: 'morning-routine' },\n  ];\n}\n```\n\n이렇게 하면 `tech/nextjs-guide`, `life/morning-routine` 두 경로가 미리 정적으로 생성되죠.\n\n동적 세그먼트를 여러 개 쓸 때는 각 세그먼트에 대응하는 파라미터를 적절히 관리하는 게 중요해요. 그리고 `dynamicParams = false`와 조합하면, 정해진 경로 외에는 모두 404 처리되게 설정할 수 있답니다.\n\n---\n\n추가로, Next.js의 동적 라우팅과 정적 생성은 SEO에도 굉장히 유리해서, 미리 생성된 페이지가 빠르게 로드되고 검색엔진 최적화에도 도움을 줘요. 그래서 동적 경로라도 미리 경로를 정의해 정적으로 생성하는 방식을 권장합니다. 다만 모든 경로를 미리 알 수 없거나 너무 많다면, SSR과 ISR의 적절한 사용도 고려해 보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n동적 세그먼트에 대해 params를 생성할 때, 현재 레이아웃이나 페이지 위쪽에서만 가능하고, 아래쪽에서는 불가능하다는 점 알아두면 유용해요. 예를 들어, `app/products/[category]/[product]` 경로를 생각해보죠:\n\n- `app/products/[category]/[product]/page.js`에서는 `[category]`와 `[product]` 두 동적 세그먼트 모두에 대한 params를 생성할 수 있어요.\n- 반면에 `app/products/[category]/layout.js`에서는 오직 `[category]`에 대한 params만 생성 가능하답니다.\n\n여기서 중요한 부분은, 동적 세그먼트가 여러 개인 경로라면 params를 생성하는 방법이 두 가지로 나뉜다는 거예요.\n\n### 동적 세그먼트 params 생성 방법 1: 아래에서 위로 (Bottom Up)\n\n아래쪽(페이지 혹은 더 깊은 레벨)부터 params를 만들어서 상위 레이아웃으로 전달하는 식이죠. 이 방식은 여러 동적 세그먼트가 있을 때 가장 직관적이에요. 예를 들면, `[product]/page.js`에서 `[product]` params를 만들고, 그 위쪽 `[category]/layout.js`에서 `[category]` params를 생성하는 식입니다.\n\n사실 이런 구조는 실무에서도 자주 쓰이는데요, 이유는 개별 페이지에서 가장 상세한 params를 만들고, 레이아웃은 좀 더 상위 레벨에서 필요한 범위의 params만 관리하기 때문이에요.\n\n---\n\n추가로, Next.js 13 앱 디렉토리 구조에서 동적 세그먼트와 params 생성이 왜 이렇게 제한되는지 궁금해하시는 분들도 많아요. 이건 경로 매칭과 렌더링 흐름이 위에서 아래로 진행되기 때문인데요. 상위 레이아웃에서 params를 정하지 않고서 하위 경로에서 마음대로 바꾸면 전체 UI가 예상치 못한 상태가 될 수 있거든요. 그래서 안정적이고 예측 가능한 렌더링을 위해 이런 규칙이 만들어졌다고 보면 돼요.\n\n아참, 만약 여러 동적 세그먼트가 복잡하게 얽힌 상황이라면, 서버 컴포넌트에서 데이터를 패칭하면서 params를 조합하는 방식도 고려해보세요. 데이터를 불러오는 동시에 필요한 여러 params를 만들어내니까 코드도 더 깔끔해지고 관리도 쉬워질 거예요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n리액트 라우팅할 때, 특히 Next.js 같은 프레임워크에서 동적 라우트 여러 개를 한꺼번에 생성하는 경우가 많죠? 예를 들어 `[category]` 와 그 하위 경로인 `[product]`를 함께 동적으로 만들 때 어떻게 하면 좋을지 알아볼게요.\n\n```js\n// [category]/[product] 경로를 위한 정적 파라미터 생성 함수\nexport async function generateStaticParams() {\n  const products = await fetch('https://.../products').then(res =\u003e res.json());\n\n  return products.map(product =\u003e ({\n    category: product.category.slug,  // 카테고리 슬러그\n    product: product.id,               // 제품 아이디\n  }));\n}\n\nexport default function Page({\n  params,\n}: {\n  params: Promise\u003c{ category: string; product: string }\u003e\n}) {\n  // params.category와 params.product를 이용해 페이지 내용 구성 가능\n}\n```\n\n### 여기서 중요한 포인트!\n\n- `generateStaticParams`를 통해 `category`, `product` 두 개의 파라미터를 한꺼번에 뽑아서 반환하죠.\n- 반환 형식은 배열 안에 객체 형태로 `{ category, product }`를 넣어줘야 함!\n- 이렇게 하면 Next.js가 빌드 시점에 모든 동적 경로를 정적으로 생성해줍니다.\n\n---\n\n### 상위 경로부터 하위 경로를 순차적으로 생성하는 법\n\n아래는 **상위 segment(`[category]`)를 먼저 생성하고**, 그 결과를 기반으로 하위 segment(`[product]`)를 생성하는 방법이에요.\n\n```js\n// 먼저 카테고리 목록을 가져옵니다.\nasync function getCategories() {\n  const categories = await fetch('https://.../categories').then(res =\u003e res.json());\n  return categories;\n}\n\n// 이후 카테고리 별 제품 목록을 가져옵니다.\nasync function getProductsByCategory(categorySlug) {\n  const products = await fetch(`https://.../categories/${categorySlug}/products`).then(res =\u003e res.json());\n  return products;\n}\n\nexport async function generateStaticParams() {\n  const categories = await getCategories();\n  \n  const params = [];\n  for (const category of categories) {\n    const products = await getProductsByCategory(category.slug);\n    for (const product of products) {\n      params.push({\n        category: category.slug,\n        product: product.id,\n      });\n    }\n  }\n  return params;\n}\n```\n\n이렇게 하면 카테고리부터 쭉 받아서, 각 카테고리마다 제품 리스트를 가져와 해당 조합을 모두 만들어 낼 수 있죠!\n\n---\n\n### 보너스 꿀팁 ⭐\n\n- 여러 비동기 호출이 있을 땐 `Promise.all`을 활용하면 병렬처리가 가능해서 더 빠르게 데이터를 받아올 수 있어요.\n- `generateStaticParams`가 너무 무거워지면 빌드 시간이 길어질 수 있으니, 필요한 데이터만 꼭 선별해 불러오는 게 중요해요.\n- Next.js 13부터 `generateStaticParams`가 점점 더 강력해지고 있는데, 최신 문서 참고하는 것도 추천드립니다!\n\n---\n\n자, 이렇게 동적 라우트 여러개 한꺼번에, 그리고 부모-자식 관계로 연동해서 파라미터 생성하는 방법을 알아봤습니다. 필요에 따라 딱 맞게 조합해서 사용해보세요! 궁금한 점 있으면 언제든 질문해 주세요~\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여러분, Next.js에서 동적 라우트와 관련해서 `generateStaticParams`를 어떻게 활용하는지 궁금하신 적 있나요? 오늘은 부모-자식 동적 라우팅에서 `generateStaticParams` 함수가 어떻게 작동하는지 쉽게 풀어드릴게요!\n\n---\n\n우선, 부모 라우트가 있다면, 이 부모가 있는 카테고리(`category`)를 기준으로 다음과 같이 `generateStaticParams`를 만들어줍니다.\n\n```js\n// [category]에 해당하는 세그먼트 생성 → 예: /category/샌드위치\nexport async function generateStaticParams() {\n  const products = await fetch('https://.../products').then((res) =\u003e res.json())\n \n  return products.map((product) =\u003e ({\n    category: product.category.slug,\n  }))\n}\n \nexport default function Layout({\n  params,\n}: {\n  params: { category: string }\n}) {\n  // ...\n}\n```\n\n이 코드는 외부 API에서 상품 정보를 받아 카테고리별로 경로를 정적으로 생성합니다. 예를 들어, \"샌드위치\", \"음료\" 같은 카테고리를 미리 만들어서 각 경로에 대응시켜주는 거죠.\n\n---\n\n이제 자식 라우트 `[product]`가 있다고 해볼게요. 여기서 중요한 점!\n\n부모의 `generateStaticParams` 함수가 만들어낸 각 `category` 세그먼트별로, 자식 라우트의 `generateStaticParams` 함수가 **각각 한 번씩 실행**됩니다. 즉, 부모 카테고리에 맞게 자식 데이터도 동적으로 생성할 수 있어요.\n\n```js\n// 부모 카테고리 params를 받아서 그 하위의 상품들로 [product] 세그먼트 생성\nexport async function generateStaticParams({\n  params: { category },\n}: {\n  params: { category: string }\n}) {\n  const products = await fetch(\n    `https://.../products?category=${category}`\n  ).then((res) =\u003e res.json())\n \n  return products.map((product) =\u003e ({\n    product: product.id,\n  }))\n}\n \nexport default function Page({\n  params,\n}: {\n  params: { category: string; product: string }\n}) {\n  // ...\n}\n```\n\n예를 들어, `category`가 \"샌드위치\"라면, 그 안에 속한 제품 아이디들을 가져와서 `/샌드위치/제품ID` 형태의 경로를 만들어 주는 거죠.\n\n---\n\n### 팁!\n\n1. `params` 타입 지정할 때, Promise가 아니라 바로 `{ category: string }` 형태로 명확히 적어주는 것이 편해요. 타입스크립트에서 헷갈릴 수 있거든요.\n2. 부모-자식 관계에서 데이터 흐름을 잘 생각해서 API 요청을 최소화하면 성능에 도움이 됩니다.\n3. `generateStaticParams`는 빌드 타임에 한 번만 실행되니, 자주 바뀌는 데이터는 `getStaticPaths`(Next.js 12 이전)나 SSR로 고민해보세요.\n\n---\n\n요약하자면, Next.js의 동적 라우팅에서 부모 세그먼트 `generateStaticParams`가 만들어낸 경로마다 자식 세그먼트의 `generateStaticParams`가 각각 호출되어, 계층적으로 경로를 생성합니다. 덕분에 복잡한 URL 구조를 쉽게 다룰 수 있답니다!\n\n여러분도 이 구조를 잘 활용해서 멋진 다이나믹 웹사이트 만들어 보세요~! 😄\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003e 참고할 점: fetch 요청은 generate-로 시작하는 함수들, Layout, Page, Server Component 전반에 걸쳐 같은 데이터를 요청하면 자동으로 메모이제이션(memoization)이 됩니다. fetch를 사용할 수 없는 경우에는 React cache를 활용할 수 있어요.\n\n## 버전 히스토리\n\n| 버전       | 변경사항                   |\n|------------|---------------------------|\n| `v13.0.0`  | `generateStaticParams` 도입 | \n\n이 내용은 Next.js 같은 최신 프레임워크에서 중요한데요, fetch 요청이 중복되지 않고 효율적으로 관리돼서 성능이 꽤 좋아진답니다. 그리고 `generateStaticParams`는 정적 생성 시 파라미터를 미리 지정할 수 있게 해주는 함수로, 미리 페이지를 만들어 빠르게 제공할 수 있게 해줘요. 이렇게 바뀌면서 서버와 클라이언트 간의 데이터 전달이 좀 더 깔끔해졌다고 보면 됩니다!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":20},{"title":"Next.js 15에서 generateSitemaps 기능 쉽게 구현하는 2025년 최신 가이드","description":"","date":"2025-04-22 12:36","slug":"2025-04-22-generateSitemaps","content":"\n\n# generateSitemaps 함수 소개\n\n웹사이트를 운영하다 보면, 검색엔진 최적화(SEO)를 위해 여러 개의 사이트맵(sitemap)을 만들어야 할 때가 있는데요. 이때 `generateSitemaps` 함수를 사용하면 여러 개의 사이트맵을 손쉽게 생성할 수 있어요.\n\n## 반환값(Returns)\n\n`generateSitemaps` 함수는 사이트맵을 여러 개 만들고, 각 사이트맵에 대해 `id`라는 프로퍼티를 가진 객체들의 배열을 반환합니다. 쉽게 말해, 생성된 사이트맵들의 고유 식별자 리스트를 받아볼 수 있다는 뜻이죠.\n\n| 반환 유형   | 설명                                |\n| --------- | --------------------------------- |\n| 배열(Array) | 각각의 사이트맵을 나타내는 객체들로 구성됨 |\n| 객체(Object) | 각 객체는 `id` 프로퍼티를 포함          |\n\n---\n\n### 추가 팁!\n\n- 사이트맵을 여러 개로 나누는 것은 대규모 웹사이트에서 자주 쓰이는 전략입니다. 구글 같은 검색엔진은 한 사이트맵 파일에 너무 많은 URL이 들어가면 효율적으로 크롤링하지 못하거든요.\n- `id` 값을 활용해서 나중에 각 사이트맵을 동적으로 불러오거나 관리할 때 용이합니다.\n- 만약 사이트맵을 자동 생성할 수 있는 라이브러리나 툴을 사용 중이라면, 이 같은 함수는 내부적으로 페이지 URL들을 분배하고 각 파일을 생성하는 역할을 담당합니다.\n\n웹사이트 규모가 커질수록 사이트맵 관리가 쉽지 않은데, 이런 함수를 잘 활용하면 관리도 편하고 SEO에도 훨씬 도움이 되니 꼭 참고하세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## URL 경로\n\n생성된 사이트맵은 `/.../sitemap/[id].xml` 경로에서 확인할 수 있어요. 예를 들어, `/product/sitemap/1.xml` 같은 식이죠.\n\n## 예시\n\n사이트맵을 나누고 싶다면 `generateSitemaps` 함수에서 사이트맵 ID를 포함한 객체 배열을 반환하면 돼요. 그리고 이 ID를 활용해서 각각 고유한 사이트맵을 생성할 수 있답니다.\n\n아래 표를 보면 좀 더 이해하기 편할 거예요.\n\n| Sitemap ID | 생성되는 사이트맵 파일 경로    |\n|------------|------------------------------|\n| 1          | /product/sitemap/1.xml        |\n| 2          | /product/sitemap/2.xml        |\n| 3          | /product/sitemap/3.xml        |\n\n이렇게 ID를 기준으로 사이트맵을 나누면, 대형 웹사이트에서도 효율적으로 검색 엔진에 페이지를 노출시킬 수 있어요. 대략 한 사이트맵에 50,000개 정도의 URL까지만 포함하는 게 권장되니까요.\n\n만약 사이트맵이 너무 커서 관리가 힘들다면, 이렇게 ID를 쪼개서 여러 개로 만드는 방법을 꼭 활용해 보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 코드는 Next.js에서 동적 사이트맵을 생성하는 간단한 예제예요. 사이트맵은 검색 엔진이 내 사이트를 효율적으로 크롤링할 수 있도록 도와주는 중요한 역할을 하죠. 여기선 제품 목록(product)을 50,000개씩 나눠서 각각의 사이트맵을 만들어주는 구조예요.\n\n```js\nimport { BASE_URL } from '@/app/lib/constants'\n \nexport async function generateSitemaps() {\n  // 전체 상품 수를 불러와서 사이트맵 페이지 개수를 계산하는 대신, 임시로 4개의 사이트맵 페이지를 반환\n  return [{ id: 0 }, { id: 1 }, { id: 2 }, { id: 3 }]\n}\n \nexport default async function sitemap({\n  id,\n}: {\n  id: number\n}): Promise\u003cMetadataRoute.Sitemap\u003e {\n  // 구글은 사이트맵에 최대 50,000개의 URL만 허용하니 이걸 기준으로 상품을 나눠서 가져옴\n  const start = id * 50000\n  const end = start + 50000\n  const products = await getProducts(\n    `SELECT id, date FROM products WHERE id BETWEEN ${start} AND ${end}`\n  )\n  return products.map((product) =\u003e ({\n    url: `${BASE_URL}/product/${product.id}`,\n    lastModified: product.date,\n  }))\n}\n```\n\n### 중요한 포인트\n- 사이트맵을 너무 크게 만들면 구글에서 인식하기 어려우니 50,000개씩 분할하는 게 기본입니다.\n- `generateSitemaps` 함수는 사이트맵의 페이지 목록을 반환하는 역할을 하고, 실제 각 페이지에 어떤 URL이 들어갈지 `sitemap` 함수에서 처리하죠.\n- 실제 환경에서는 상품 총 개수를 DB에서 조회해 그에 맞게 페이지 수를 동적으로 만들어줘야 해요.\n\n---\n\n## 버전 히스토리\n\n| 버전 | 변경사항 |\n|-------|---------|\n| `v15.0.0` | `generateSitemaps` 함수가 개발 환경과 프로덕션 환경에서 일관된 URL을 생성하도록 개선됨 |\n| `v13.3.2` | `generateSitemaps` 함수 도입. 개발 시 `/.../sitemap.xml/[id]` URL을 통해 동적으로 생성된 사이트맵 확인 가능 (예: `/product/sitemap.xml/1`) |\n\n---\n\n### 추가 팁\n- 사이트맵 URL을 서비스 루트에 쉽게 추가하고 싶다면, Next.js 내의 API Route를 사용하거나 서버리스 함수(Serverless Function)를 활용할 수도 있어요.\n- 사이트맵 생성 시 추천하는 방법 중 하나는 정기적으로 크론 잡으로 상품 리스트 업데이트에 맞춰 사이트맵을 재생성하는 거예요.\n- 큰 사이트라면 사이트맵 인덱스 파일을 만들어서 여러 개의 사이트맵 파일을 참조하는 전략도 있어요.\n\n사이트맵은 SEO 최적화에도 굉장히 중요하니, 꼭 내 사이트 규모에 맞게 적절한 구조로 관리해 보세요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":4},{"title":"Next.js 15에서 generateMetadata 함수로 SEO 메타데이터 자동 생성하는 방법","description":"","date":"2025-04-22 03:05","slug":"2025-04-22-generateMetadata","content":"\n\n# generateMetadata\n\n이번 글에서는 Next.js에서 메타데이터를 설정하는 방법 중 Config 기반 메타데이터 옵션인 `generateMetadata`와 정적인 `metadata` 객체에 대해 알아볼게요.\n\n```js\nimport type { Metadata } from 'next'\n\n// 정적 메타데이터 예시\nexport const metadata: Metadata = {\n  title: '홈페이지 제목',\n}\n\n// 동적 메타데이터 예시\nexport async function generateMetadata({ params }) {\n  return {\n    title: '동적 페이지 제목',\n  }\n}\n```\n\n\u003e 알아두면 좋은 점:\n\u003e - `metadata` 객체와 `generateMetadata` 함수는 **서버 컴포넌트**에서만 지원돼요.\n\u003e - 한 라우트 세그먼트에서 `metadata` 객체와 `generateMetadata` 함수를 동시에 내보낼 수는 없습니다.\n\n---\n\n### 좀 더 자세히 설명해볼게요!\n\nNext.js 13부터는 페이지별 메타데이터를 쉽게 설정하는 방법으로 `metadata` 객체 또는 `generateMetadata` 함수를 제공해요.\n\n- **`metadata` 객체**: 빌드 시점에 정적으로 설정되는 메타데이터로, 변하지 않는 값을 넣을 때 사용해요.\n- **`generateMetadata` 함수**: 요청에 따라 동적으로 값을 만들거나, API 데이터 등을 기반으로 메타데이터를 생성해야 할 때 사용해요.\n\n예를 들면 블로그 게시글 같은 경우, 글 ID를 URL 파라미터로 받아서 `generateMetadata`에서 제목과 설명을 동적으로 세팅할 수 있죠.\n\n```js\nexport async function generateMetadata({ params }) {\n  const post = await getPost(params.id);\n  return {\n    title: post.title,\n    description: post.summary,\n  }\n}\n```\n\n---\n\n### 참고사항\n\n- 이 기능들은 **서버 컴포넌트(Server Components)**에서만 동작해요. 클라이언트 컴포넌트에서는 지원되지 않으니 주의하세요.\n- 한 경로에서 `metadata`와 `generateMetadata`를 동시에 export하면 충돌이 나므로, 하나만 골라서 사용해야 합니다.\n\n메타데이터는 SEO에 매우 중요한 역할을 하니, 빌드시점에 고정 값으로 넣을지, 동적으로 데이터를 가져와서 세팅할지 상황에 맞게 잘 선택해 사용하면 좋겠죠?\n\n다음 글에서는 실제 프로젝트에서 어떻게 활용하는지 더 구체적인 예제도 소개해볼게요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 메타데이터 객체\n\nNext.js에서 정적인 메타데이터를 정의할 때는 `layout.js`나 `page.js` 파일에서 `Metadata` 객체를 export 하면 됩니다.\n\n```js\nimport type { Metadata } from 'next'\n\nexport const metadata: Metadata = {\n  title: '내 멋진 페이지 제목',\n  description: '페이지에 대한 간단한 설명을 적어주세요',\n}\n\nexport default function Page() {}\n```\n\n이렇게 하면 해당 페이지에 맞는 SEO-friendly한 메타데이터가 자동으로 적용돼서, 검색 엔진 최적화(SEO)에 도움이 되고, 소셜 미디어에 공유될 때도 깔끔하게 노출돼요.\n\n### 참고로\n`.metadata` 객체에는 더 많은 필드들이 있어요. 예를 들어 `keywords`, `author`, `openGraph`, `twitter` 같은 다양한 메타데이터 옵션을 넣을 수 있는데요, 이것들은 페이지를 더 풍부하게 만들어주고 SNS 공유 시 미리보기 정보를 더 세밀하게 제어할 수 있어요.\n\n아래는 자주 사용하는 메타데이터 필드를 간단히 정리한 표예요:\n\n| 필드명        | 설명                                  |\n| ------------- | ------------------------------------- |\n| `title`       | 페이지 제목                           |\n| `description` | 페이지 설명                           |\n| `keywords`    | SEO를 위한 키워드 배열                |\n| `author`      | 페이지 제작자 정보                    |\n| `openGraph`   | 오픈 그래프 프로토콜에 따른 메타데이터 |\n| `twitter`     | 트위터 카드용 메타데이터              |\n\n더 자세한 내용은 공식 문서의 [Metadata Fields](https://nextjs.org/docs/app/api-reference/functions/generate-metadata#fields) 항목을 참고하면 좋아요.\n\n---\n\n정리하자면, Next.js에서 페이지별 메타데이터를 간단하게 관리하려면 `metadata` 객체를 export하는 것만으로 충분합니다. 이렇게 하면 최신 SEO 기술도 쉽게 적용할 수 있어서, 별도의 헤드 태그를 직접 조작하는 번거로움을 줄일 수 있어요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## generateMetadata 함수란?\n\nNext.js에서 동적인 메타데이터를 설정할 때, 현재 라우트의 파라미터나 외부 데이터, 부모 컴포넌트의 메타데이터 정보를 기반으로 설정할 수 있어요. 이를 위해 `generateMetadata`라는 함수를 export해서 메타데이터 객체를 반환하면 됩니다.\n\n예를 들어, 상품 페이지에서 URL 파라미터로 받은 상품 ID를 활용해 서버에서 상품 데이터를 가져와서 타이틀이나 Open Graph 이미지 정보를 동적으로 세팅할 수 있죠.\n\n```js\nimport type { Metadata, ResolvingMetadata } from 'next'\n\n// Props 타입 정의 - params와 검색 파라미터가 Promise로 들어오는 걸 확인하세요\ntype Props = {\n  params: Promise\u003c{ id: string }\u003e\n  searchParams: Promise\u003c{ [key: string]: string | string[] | undefined }\u003e\n}\n\nexport async function generateMetadata(\n  { params, searchParams }: Props,\n  parent: ResolvingMetadata\n): Promise\u003cMetadata\u003e {\n  // 라우트 파라미터 읽기\n  const { id } = await params\n\n  // 외부 API에서 상품 정보 가져오기\n  const product = await fetch(`https://.../${id}`).then((res) =\u003e res.json())\n\n  // 부모 메타데이터의 Open Graph 이미지 배열 불러오기 (없으면 빈 배열)\n  const previousImages = (await parent).openGraph?.images || []\n\n  // 동적으로 메타데이터 설정 (기존 이미지는 유지하면서 새 이미지 추가)\n  return {\n    title: product.title,\n    openGraph: {\n      images: ['/some-specific-page-image.jpg', ...previousImages],\n    },\n  }\n}\n\n// Page 컴포넌트 예시 - params, searchParams 받아올 수 있음\nexport default function Page({ params, searchParams }: Props) {}\n```\n\n### 주요 파라미터 설명\n\n| 파라미터 | 설명 |\n| -------- | ---- |\n| `params` | URL 라우트 파라미터(예: `/product/[id]`에서 `id`). Promise로 감싸져서 옵니다. |\n| `searchParams` | URL 쿼리스트링 파라미터 (`?category=shoes` 등). Promise 타입입니다. |\n| `parent` | 부모 레이아웃 혹은 상위 컴포넌트에 설정된 메타데이터를 받아올 수 있어요. 기존 메타데이터를 활용해 확장할 때 유용합니다. |\n\n---\n\n\u003e **꿀팁!**  \n\u003e `generateMetadata` 함수 내부에서 필요할 때 외부 API를 호출해 정보를 받아올 수 있기 때문에, 페이지마다 SEO 최적화된 메타 태그를 동적으로 설정할 수 있어요.  \n\u003e  \n\u003e 다만, 이 함수는 서버에서만 실행되므로, 클라이언트 전용 상태나 이벤트는 사용할 수 없고, 비동기 작업도 서버에서 처리됩니다.  \n\u003e  \n\u003e 그리고 `params`와 `searchParams`가 Promise 형태라는 점도 헷갈리지 말아요! `await`를 꼭 붙여서 값을 받아야 합니다.\n\n---\n\n이제 `generateMetadata`를 잘 활용해서, 검색 엔진 최적화와 SNS 공유에 딱 맞는 메타데이터를 페이지 단위로 동적 생성할 수 있겠죠? 계산된 데이터를 기반으로 메타데이터를 만드는 저만의 SEO 전략을 코딩에 적용해 보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\ngenerateMetadata 함수에 대해 알아볼게요! 이 함수는 Next.js 같은 프레임워크에서 페이지별로 메타데이터를 동적으로 생성할 때 많이 사용됩니다. 조금 더 쉽게 설명하고, 함수가 받는 파라미터와 반환값에 대해 정리해볼게요.\n\n---\n\n## generateMetadata 함수 파라미터 설명\n\n이 함수는 다음과 같은 파라미터를 받습니다. 보통 하나의 `props` 객체로 전달되는데, 그 안에 여러 속성이 들어 있어요.\n\n| 파라미터명    | 설명                                                                                                              | 예시                                                                                 |\n|---------------|-------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------|\n| `params`      | 현재 라우트에서 동적 세그먼트(즉, URL 경로에서 동적으로 변하는 부분)들의 값을 모아놓은 객체.                       | `/shop/1` → `{ slug: '1' }` \u003cbr\u003e `/shop/1/2` → `{ tag: '1', item: '2' }` \u003cbr\u003e `/shop/1/2` (catch-all) → `{ slug: ['1', '2'] }` |\n| `searchParams`| URL 쿼리스트링(검색 파라미터)의 값들을 담은 객체입니다. 여러 개일 경우 배열로 들어올 수도 있어요.                  | `/shop?a=1` → `{ a: '1' }` \u003cbr\u003e `/shop?a=1\u0026b=2` → `{ a: '1', b: '2' }` \u003cbr\u003e `/shop?a=1\u0026a=2` → `{ a: ['1', '2'] }`              |\n| `parent`      | 상위 라우트(segment)에서 이미 계산된 메타데이터를 Promise 형태로 받습니다. 상위의 메타데이터를 기반으로 추가 가공할 때 유용해요. | —                                                                                    |\n\n---\n\n## 참고 및 중요 포인트\n\n- `params` 객체는 URL 경로의 동적 부분을 잡아주기 때문에, 예를 들어 `[slug]` 같은 동적 경로 세그먼트에 해당하는 값이 들어옵니다.\n- `[...slug]` 같은 catch-all 세그먼트의 경우 배열로 넘어옵니다.\n- `searchParams`는 쿼리스트링에서 하나뿐 아니라 여러 값도 받을 수 있어서 배열로 표현될 수도 있어요.\n- `parent`는 재귀적 메타데이터 생성이 필요한 경우에 상위 메타데이터를 가져오는데, `await`을 사용해서 비동기 처리합니다.\n- 반환값은 `Metadata` 객체로, 보통 `title`, `description`, `openGraph` 같은 SEO 관련 메타데이터를 포함시킵니다.\n\n---\n\n## `generateMetadata` 반환값 예시\n\n다음은 `generateMetadata`가 반환할 수 있는 간단한 메타데이터 객체의 예시입니다.\n\n```ts\n{\n  title: 'Shop - ' + params.slug,\n  description: `This is the shop page for item ${params.slug}`,\n  openGraph: {\n    title: 'Shop OG Title',\n    description: 'Open graph description',\n    url: `https://example.com/shop/${params.slug}`,\n  },\n}\n```\n\n---\n\n이 함수로 동적 라우팅에 맞춰 SEO 최적화나 페이지별 메타데이터 세팅이 가능해서 Next.js의 중요한 기능 중 하나예요! 만약 상위 메타데이터와 합칠 필요가 있다면 `parent`를 `await`해서 가져와서 병합해주면 되고요.\n\n궁금한 점 있으면 언제든 질문해 주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003e 알아두면 좋은 점:\n- 메타데이터가 런타임 정보에 의존하지 않는다면, generateMetadata 대신 static metadata 객체를 사용하는 게 좋아요.\n- fetch 요청은 generateMetadata, generateStaticParams, Layout, Page, Server Component 등에서 같은 데이터를 요청할 땐 자동으로 메모이제이션(캐싱)됩니다. 만약 fetch를 쓸 수 없는 상황이라면 React cache를 활용할 수 있어요.\n- searchParams는 오직 page.js 세그먼트에서만 사용 가능합니다.\n- Next.js의 redirect()와 notFound() 메서드는 generateMetadata 안에서도 사용할 수 있어요.\n\n## 메타데이터 필드\n\n### title\n\ntitle 속성은 문서의 제목을 설정하는 데 사용됩니다. 단순 문자열로 지정할 수도 있고, 선택적으로 템플릿 객체 형태로 정의할 수도 있어요.\n\n---\n\n여기서 조금 더 팁을 드리자면, Next.js에서 페이지 타이틀을 동적으로 관리할 때 템플릿 객체를 활용하면 일관된 제목 포맷을 유지하는 데 아주 유용합니다. 예를 들어, 모든 페이지 제목 뒤에 ‘ | 내사이트명’을 붙이고 싶다면 템플릿을 써보세요. 각 페이지에서 제목만 넘겨주면 되니까 관리가 훨씬 편해진답니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n#### 문자열 (String)\n\nNext.js나 React를 사용할 때, 주로 문자열을 다루는 방법에 대해 간단히 정리해볼게요!\n\n예를 들어, 아래처럼 `metadata`라는 객체 안에 `title`이라는 문자열을 설정하는 코드가 있어요.\n\n```js\nexport const metadata = {\n  title: 'Next.js',\n}\n```\n\n이 코드는 주로 페이지의 메타데이터를 설정할 때 씁니다. 예를 들면, 브라우저 탭에 표시되는 제목 같은 내용을 여기서 정의하죠.\n\n그리고 HTML에서는 이렇게 `\u003ctitle\u003e` 태그 안에 직접 문자열을 넣어서 페이지 제목을 설정합니다.\n\n```js\n\u003ctitle\u003eNext.js\u003c/title\u003e\n```\n\n이 두 가지 방식이 결국 같은 목적, 즉 ‘페이지 제목’을 설정하는 거라 이해하면 쉬워요.\n\n---\n\n### 조금 더 알아볼까요?\n\n- **`metadata` 객체**: Next.js에서는 페이지별 메타데이터를 객체 형태로 내보내는 게 일반적이에요. 이렇게 하면 SEO 최적화나 소셜 미디어 공유 시에 필요한 정보를 손쉽게 관리할 수 있어요.\n- **템플릿 객체 (Template object)**: 보통 ‘템플릿 객체’란 UI 요소나 설정값 등을 미리 정해놓은 객체 형태로 관리하는 것을 말해요. 예를 들면, 페이지마다 `metadata`를 객체로 만들어서 사용하는 게 좋은 예죠.\n\n---\n\n### 간단 정리\n\n| 개념               | 설명                                                    |\n|------------------|-------------------------------------------------------|\n| 문자열 (String)     | 코드나 HTML 안에서 텍스트 데이터를 나타내는 기본 단위                    |\n| `metadata` 객체     | 페이지 정보(제목, 설명 등)를 담는 JSON 형식의 설정 객체                       |\n| `\u003ctitle\u003e` 태그       | HTML 문서의 제목을 브라우저 탭에 표시해주는 태그                         |\n| 템플릿 객체 (Template object) | 미리 정의된 설정이나 데이터를 객체 형태로 만들어서 재사용하는 패턴        |\n\n---\n\n그러니까, 개발할 때는 문자열을 단순히 “글자”로 생각하지 말고, 객체나 태그와 같이 어디에 어떻게 쓸지, 또 왜 필요한지 항상 생각하면서 다루면 훨씬 효율적인 코드를 만들 수 있어요! 필요하면 문자열 조작 함수나 템플릿 리터럴로 동적 텍스트를 만들 수도 있고요.\n\n궁금한 점 있으면 언제든 질문해주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 `metadata` 객체를 이용해 페이지의 메타 정보를 설정할 때, `title` 속성은 여러 가지 형태로 설정할 수 있어요. 그중에서 `title.default`는 자식 라우트 세그먼트가 별도로 제목(title)을 정의하지 않았을 때 사용할 ‘기본 제목(fallback title)’ 역할을 해요.\n\n예를 들어, 이런 코드가 있다고 가정해볼게요:\n\n```js\nimport type { Metadata } from 'next'\n\nexport const metadata: Metadata = {\n  title: {\n    default: 'Acme',\n  },\n}\n```\n\n위와 같이 `default` 값을 지정하면, 자식 페이지에서 `title`을 따로 정의하지 않아도 `\u003ctitle\u003eAcme\u003c/title\u003e`로 기본 타이틀이 세팅됩니다.\n\n---\n\n### 정리해볼게요!\n\n| 옵션       | 설명                                                      | 예시                         |\n|------------|-----------------------------------------------------------|------------------------------|\n| `title.default` | 자식 라우트에서 제목을 지정하지 않을 때 보여지는 기본 타이틀 | `'Acme'`                     |\n| `title.template`| 페이지 제목을 포맷팅할 때 쓰는 템플릿                      | `'%s | My Site'`              |\n| `title.absolute`| 절대 제목으로 설정, 템플릿과 관계없이 고정된 제목 사용       | `'Welcome to Acme'`          |\n\n예를 들어, `title.template`을 활용하면 동적인 제목을 예쁘게 꾸밀 수 있죠.\n\n```js\nexport const metadata: Metadata = {\n  title: {\n    template: '%s | Acme',\n    default: 'Acme',\n  },\n};\n```\n\n- `/about` 페이지에서 `title`을 `About Us`로 지정하면, `\u003ctitle\u003eAbout Us | Acme\u003c/title\u003e`가 되고,\n- `/contact` 같은 다른 자식 라우트가 타이틀을 따로 지정하지 않으면 `\u003ctitle\u003eAcme\u003c/title\u003e`가 됩니다.\n\n### 좀 더 팁!\n\n1. `title.absolute`는 특정 페이지에서 무조건 고정된 타이틀을 써야할 때 쓸 수 있어요. 템플릿 무시하고 딱 하나의 제목만 보여줘야 할 때 유용합니다.\n2. `title.default`는 여러 자식 라우트에 일괄적인 기본 타이틀을 넣고 싶을 때 딱이죠.\n3. SEO 관점에서 각 페이지에 맞는 고유한 타이틀을 갖는 것이 좋지만, 없을 때 기본 타이틀을 두는 것도 좋은 습관입니다.\n\n이렇게 `metadata`의 `title` 옵션을 잘 활용하면, 중복되는 코드 없이 깔끔하게 제목을 관리할 수 있어서 프로젝트가 더 효율적으로 운영돼요. 다음 번 Next.js 프로젝트에 꼭 적용해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 title.template을 활용하면 자식 라우트 세그먼트에 정의된 타이틀에 접두사나 접미사를 쉽게 붙일 수 있어요. 예를 들어, 자식 페이지의 타이틀에 ' | Acme'라는 접미사를 자동으로 붙이는 방식이죠.\n\n```js\nimport type { Metadata } from 'next'\n\nexport const metadata: Metadata = {\n  title: {\n    template: '%s | Acme',\n    default: 'Acme', // template을 쓸 때는 default 타이틀이 꼭 필요해요.\n  },\n}\n```\n\n그리고 자식 라우트에서는 이렇게 타이틀을 선언하면 아래처럼 렌더링 됩니다:\n\n```js\nimport type { Metadata } from 'next'\n\nexport const metadata: Metadata = {\n  title: 'About',\n}\n\n// 결과 : \u003ctitle\u003eAbout | Acme\u003c/title\u003e\n```\n\n### 이 점 꼭 기억하세요!\n- `title.template`은 자기 자신이 속한 라우트 세그먼트가 아니라 *자식* 라우트 세그먼트에만 적용돼요.\n- 그래서 template을 사용할 때는 `title.default`를 반드시 설정해야 합니다.\n- `layout.js` 안에서 `title.template`을 정의해도, 같은 라우트 세그먼트에 있는 `page.js`의 타이틀에는 적용되지 않아요.\n- `page.js`에서 `title.template`을 정의해봤자 무의미해요, 페이지는 항상 마지막 세그먼트이기 때문이죠. 즉, 자식 라우트가 없으니 template이 적용될 곳이 없다는 이야기입니다.\n- 타이틀이나 기본 타이틀(`title` 또는 `title.default`)을 아예 정의하지 않은 라우트에는 template이 먹히지 않아요.\n\n---\n\n### 추가 팁!\n`title.template`을 잘 활용하면 사이트 전체의 타이틀 포맷을 통일하기 쉽고, SEO 관리에도 유리합니다. 예를 들어, 블로그 포스트마다 글 제목 뒤에 ' | 내 블로그명'을 붙이고 싶을 때 유용하죠. 게다가 유지보수하기도 정말 편해져요. 타이틀 형식을 하나만 바꾸면 모든 자식 페이지에 바로 반영되니까요.\n\n혹시 라우트 구조가 복잡해서 타이틀 설정이 어려운 경우, `layout.js`와 `page.js`의 역할을 다시 한 번 점검해보면서 어느 위치에 타이틀 관련 코드를 넣어야 할지 고민해보는 걸 추천드려요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n`title.absolute`는 부모 세그먼트에 설정된 `title.template`을 무시하고, 절대적인 제목을 지정할 때 사용할 수 있어요. 쉽게 말해, 부모에서 정의한 제목 형식을 적용하지 않고 내가 원하는 제목을 딱 하나만 보여줄 수 있다는 뜻이죠.\n\n예를 들어, 아래처럼 `metadata`에 `template`을 설정해 두면…\n\n```js\nimport type { Metadata } from 'next'\n\nexport const metadata: Metadata = {\n  title: {\n    template: '%s | Acme',\n  },\n}\n```\n\n아래처럼 `absolute`를 쓰면, 부모가 세팅한 `%s | Acme` 형식을 무시하고 그냥 'About'이라는 제목만 보여줍니다.\n\n```js\nimport type { Metadata } from 'next'\n\nexport const metadata: Metadata = {\n  title: {\n    absolute: 'About',\n  },\n}\n\n// 출력 결과: \u003ctitle\u003eAbout\u003c/title\u003e\n```\n\n---\n\n### 알아두면 좋은 점 정리\n\n| 위치       | 속성              | 설명                                                                                                                                                         |\n|------------|-------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **layout.js** | `title` (string), `title.default` | 자식 세그먼트 중 제목을 따로 정하지 않은 곳에 기본 제목을 제공합니다. 부모의 `title.template`이 있으면 그 형식을 덧붙여서 보여줘요.                              |\n|            | `title.absolute`  | 자식 세그먼트에 기본 제목을 설정하지만, 부모의 `title.template`을 무시합니다. 즉, 깔끔하게 절대 제목만 보여줘요.                                                  |\n|            | `title.template`  | 자식 세그먼트용 새로운 제목 템플릿을 정의합니다.                                                                                                               |\n| **page.js**  | `title` (string)  | 페이지(라우트)의 제목을 정의합니다. 부모의 `title.template`이 있으면 같이 적용돼요.                                                                           |\n|            | `title.absolute`  | 페이지 제목을 절대적으로 지정하며, 부모의 `title.template`을 무시합니다.                                                                                       |\n|            | `title.template`  | 적용되지 않습니다. 페이지는 항상 라우트의 마지막 세그먼트여서 템플릿을 사용할 수 없어요.                                                                        |\n\n---\n\n### 좀 더 살펴보기!\n\n- `title.template`은 `%s` 자리에 해당 제목이 들어가도록 포맷을 만들어 줄 때 씁니다. 예를 들어, `'%s | 내 사이트'` 같은 형태죠. 그래서 자식 세그먼트에서 제목만 정의하면 자동으로 `| 내 사이트`가 붙어요.\n- 반면 `title.absolute`는 그냥 깨끗하게 제목을 바꿔야 할 때 편리합니다. 예를 들어, \"특별한 이벤트 페이지\" 같이 이름만 딱 보여줘야 할 때 `title.template`을 쓰면 `특별한 이벤트 페이지 | 내 사이트`처럼 길어질 수 있는데 그걸 막아줍니다.\n- layout 단위에서 잘 설계하면, 사이트 전체 제목 구조를 관리하기가 훨씬 수월해져요. 기본 템플릿은 내비두고, 특수 페이지에서만 `absolute`로 자유롭게 제목을 정하는 게 흔한 패턴입니다.\n\n다시 요약하자면, `title.absolute`는 부모 제목 템플릿을 무시하고 딱 하나의 제목을 화면에 보여주고 싶을 때 사용하는 옵션이에요. next.js 앱에서 제목 관리할 때 요긴하게 쓰이니 기억해 두시면 좋아요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### description 설명\n\n```js\nexport const metadata = {\n  description: 'The React Framework for the Web',\n}\n```\n\n위 코드는 자바스크립트에서 `metadata`라는 객체에 웹 페이지나 앱의 설명(description)을 정의한 예시입니다. React나 Next.js 같은 프레임워크에서 메타데이터를 설정할 때 흔히 볼 수 있죠.\n\n```html\n\u003cmeta name=\"description\" content=\"The React Framework for the Web\" /\u003e\n```\n\n위 태그는 HTML `\u003chead\u003e` 영역에 들어가는 메타 태그로, 브라우저나 검색엔진이 페이지를 이해할 때 참고하는 설명을 담고 있어요. SEO(Search Engine Optimization)에도 꼭 필요한 부분이죠.\n\n---\n\n### 왜 description이 중요할까?\n\n- **검색 결과 노출**: 구글이나 네이버 같은 검색엔진에서 내 페이지가 어떤 내용을 담고 있는지 설명해주기 때문에 검색 결과에 노출될 때 보이는 요약문으로 활용돼요.\n- **사용자 클릭 유도**: 매력적인 설명은 검색 사용자들이 내 페이지를 클릭하도록 유도할 수 있어요.\n- **공유 시 정보 제공**: SNS나 메신저에 링크를 공유할 때도 이 description이 설명으로 사용됩니다.\n\n---\n\n### Basic Fields\n\n웹 메타데이터에는 description 외에도 여러 기본 필드들이 있어요. 대표적인 기본 필드를 표로 정리해볼게요.\n\n| 필드명          | 설명                             | 예시                                |\n|----------------|--------------------------------|-----------------------------------|\n| title          | 페이지의 제목                   | \"React로 만드는 웹 어플리케이션\"   |\n| description    | 페이지 설명                    | \"The React Framework for the Web\" |\n| keywords       | 검색 키워드 (요즘엔 덜 쓰임)  | \"React, JavaScript, Web Framework\"|\n| author         | 작성자 이름                   | \"홍길동\"                           |\n| viewport       | 화면 크기의 기본 설정          | \"width=device-width, initial-scale=1\" |\n\n---\n\n### 팁: 메타데이터 잘 활용하는 법\n\n1. **각 페이지마다 고유한 description 작성하기**  \n   똑같은 설명을 여러 페이지에 쓰면 SEO에 좋지 않아요. 페이지마다 내용을 잘 반영해서 개성있게 써보세요.\n\n2. **길이 조절**  \n   너무 길면 검색 결과에서 잘리니까 150~160자 정도로 간결하게 작성하세요.\n\n3. **중요 키워드 포함하기**  \n   설명 안에 주요 키워드를 자연스럽게 넣으면 검색엔진에서 더 잘 인식합니다.\n\n---\n\n이렇게 메타테이터의 `description` 필드는 쉽지만 굉장히 중요한 부분이에요. 제대로 설정해두면 검색엔진에서의 인지도도 쑥쑥 올라가니 꼭 신경 써주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안녕하세요! 오늘은 Next.js에서 메타데이터를 관리하는 방법에 대해서 이야기해볼게요. 특히 metadata 객체를 통해 SEO에 중요한 여러 정보를 한 번에 설정하는 방법과, 이 정보가 실제로 HTML 메타 태그로 어떻게 변환되는지 살펴보겠습니다.\n\n먼저, Next.js에서 사용하는 metadata 객체를 보면 다음과 같아요:\n\n```js\nexport const metadata = {\n  generator: 'Next.js',\n  applicationName: 'Next.js',\n  referrer: 'origin-when-cross-origin',\n  keywords: ['Next.js', 'React', 'JavaScript'],\n  authors: [{ name: 'Seb' }, { name: 'Josh', url: 'https://nextjs.org' }],\n  creator: 'Jiachi Liu',\n  publisher: 'Sebastian Markbåge',\n  formatDetection: {\n    email: false,\n    address: false,\n    telephone: false,\n  },\n}\n```\n\n이렇게 설정해 주면 Next.js가 내부적으로 아래와 같은 메타 태그로 변환해주게 되죠:\n\n| 태그 종류               | 내용                                                             |\n|----------------------|----------------------------------------------------------------|\n| `\u003cmeta name=\"application-name\" content=\"Next.js\" /\u003e` | 애플리케이션 이름을 지정해요.                                      |\n| `\u003cmeta name=\"author\" content=\"Seb\" /\u003e`               | 저자 이름 (Seb)                                                  |\n| `\u003clink rel=\"author\" href=\"https://nextjs.org\" /\u003e`    | 저자 관련 URL (Josh의 프로필 링크)                               |\n| `\u003cmeta name=\"author\" content=\"Josh\" /\u003e`               | 저자 이름 (Josh)                                                 |\n| `\u003cmeta name=\"generator\" content=\"Next.js\" /\u003e`        | 생성 도구 (Next.js)                                              |\n| `\u003cmeta name=\"keywords\" content=\"Next.js,React,JavaScript\" /\u003e` | 주요 키워드                                                    |\n| `\u003cmeta name=\"referrer\" content=\"origin-when-cross-origin\" /\u003e` | 리퍼러 정책 설정                                               |\n| `\u003cmeta name=\"color-scheme\" content=\"dark\" /\u003e`        | 컬러 스킴 (다크 모드)                                            |\n| `\u003cmeta name=\"creator\" content=\"Jiachi Liu\" /\u003e`        | 콘텐츠 제작자                                                     |\n| `\u003cmeta name=\"publisher\" content=\"Sebastian Markbåge\" /\u003e` | 콘텐츠 배급자                                                  |\n| `\u003cmeta name=\"format-detection\" content=\"telephone=no, address=no, email=no\" /\u003e` | 자동 전화번호, 주소, 이메일 인식 비활성화 |\n\n### 여기서 중요한 점!\n\n- `authors` 배열 안에 객체를 넣으면 저자 정보뿐 아니라, URL 같은 추가 속성도 넣을 수 있다는 점!\n- `formatDetection` 설정은 요즘 모바일에서 전화번호, 주소, 이메일 자동 링크 걸리는 걸 방지할 때 많이 쓰여요. 예를 들어, 아이폰은 자동으로 전화번호 인식을 하는데, 이걸 끄고 싶으면 metadata에 이렇게 설정하면 돼요.\n- `referrer`는 보안을 위해서 추천하는 정책 중 하나예요.\n\n---\n\n### metadataBase란?\n\n마지막으로 metadataBase라는 옵션에 대해 간단히 짚고 넘어갈게요.\n\nmetadataBase는 메타데이터에 사용하는 URL들이 절대 경로(완전한 URL)를 요구할 때, 기본 URL을 한 번에 지정해주는 편리한 옵션이에요.\n\n예를 들어, 메타 태그에 이미지 URL을 넣거나 OG(Open Graph) 태그에 링크를 넣을 때 다음처럼 활용할 수 있죠:\n\n```js\nexport const metadataBase = new URL('https://example.com')\n```\n\n이렇게 설정하면 상대 경로인 `/image.png`가 자동으로 `https://example.com/image.png`로 변환되어서 출력됩니다. 굉장히 편하죠?\n\n---\n\n### 맺으며\n\nNext.js의 메타데이터 설정은 기본적인 SEO는 물론이고, 사용자 경험 개선에도 큰 도움이 됩니다. 이런 메타 정보를 꼼꼼하게 관리하는 습관이 좋은 웹사이트를 만드는 첫걸음이니 꼭 활용해보세요!\n\n필요하다면 Open Graph, Twitter Card 같은 SNS용 메타 태그도 같이 설정할 수 있으니, 다음 글에서는 그런 부분도 다뤄볼게요~!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nmetadataBase 옵션에 대해 한 번 쉽게 정리해볼게요!\n\n---\n\n### metadataBase가 뭘까?\n\n`metadataBase`는 URL 기반 메타데이터를 만들 때, **절대 URL 대신 상대 경로를 쓸 수 있게 해주는 옵션**이에요.  \n예를 들어 `images: '/og-image.png'`라고 하면, 이 상대 경로가 `metadataBase`에 써둔 기본 URL과 합쳐져서 완전한 URL(`https://acme.com/og-image.png`)을 만들어줍니다.\n\n---\n\n### 사용 예시\n\n```js\nexport const metadata = {\n  metadataBase: new URL('https://acme.com'),\n  alternates: {\n    canonical: '/',\n    languages: {\n      'en-US': '/en-US',\n      'de-DE': '/de-DE',\n    },\n  },\n  openGraph: {\n    images: '/og-image.png',\n  },\n}\n```\n\n위처럼 쓰면 Next.js가 최종 HTML에 다음과 같이 출력해줘요:\n\n```html\n\u003clink rel=\"canonical\" href=\"https://acme.com\" /\u003e\n\u003clink rel=\"alternate\" hreflang=\"en-US\" href=\"https://acme.com/en-US\" /\u003e\n\u003clink rel=\"alternate\" hreflang=\"de-DE\" href=\"https://acme.com/de-DE\" /\u003e\n\u003cmeta property=\"og:image\" content=\"https://acme.com/og-image.png\" /\u003e\n```\n\n---\n\n### 알아두면 좋은 팁!\n\n| 내용 | 설명 |\n|---|---|\n| 일반적으로 어디에 설정하나요? | `metadataBase`는 보통 `root app/layout.js`에 설정해서 모든 라우트에 적용합니다. |\n| 어떤 필드에 적용되나요? | 절대 URL이 필요한 URL 기반 메타데이터들에 적용돼요. (Open Graph 이미지, canonical 링크, hreflang 등) |\n| 복잡한 URL도 가능해요 | 서브도메인 포함(`https://app.acme.com`)이나, 베이스 경로 포함도 가능(`https://acme.com/start/from/here`)해요. |\n| 절대 URL 쓰면? | 해당 필드는 `metadataBase`를 무시하고 절대 URL을 그대로 씁니다. |\n| `metadataBase` 없으면 어떻게 되나요? | 상대 경로를 쓸 때 에러가 납니다. 빌드 오류가 나니까 꼭 설정해줘야 해요! |\n| 슬래시 중복 처리 | `metadataBase`가 끝에 슬래시(`/`) 있어도, 상대경로가 앞에 슬래시 있어도 자동으로 정리해서 `//`가 생기지 않아요! |\n\n---\n\n### 마무리\n\n`metadataBase`는 앱 전체 메타데이터를 관리할 때 정말 편리한 옵션이에요.  \n특히 도메인이 바뀌거나 서브도메인이 추가될 때 한 곳만 바꾸면 되니까 유지보수도 쉬워집니다!\n\n---\n\n도움이 됐다면 좋겠네요~ 다음에 더 재미있는 개발 이야기로 찾아올게요! 😄\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n#### 기본값(Default value)\n\n`metadataBase`를 따로 설정하지 않으면 기본값이 자동으로 지정돼요.\n\n\u003e **Vercel 환경 기준:**\n\u003e - 프로덕션 배포에서는 `VERCEL_PROJECT_PRODUCTION_URL` 값을 사용해요.\n\u003e - 프리뷰 배포에서는 `VERCEL_BRANCH_URL`이 우선시 되고, 이 값이 없으면 `VERCEL_URL`을 사용합니다.\n\u003e \n\u003e 만약 위 환경 변수들이 없다면 기본값은 `http://localhost:${process.env.PORT || 3000}`이 됩니다. 이 덕분에 Open Graph 이미지가 로컬 환경에서 테스트할 때부터 Vercel 프리뷰, 프로덕션 환경 모두에서 잘 작동해요.\n\u003e\n\u003e 기본값을 덮어쓰고 싶다면, 환경 변수를 이용해 URL을 컴퓨팅하는 걸 추천해요. 이렇게 하면 개발(local), 스테이징, 프로덕션 환경에 맞춰 유동적으로 URL을 관리할 수 있어서 훨씬 편리하답니다.\n\u003e \n\u003e 참고로, Vercel 관련 환경 변수는 [System Environment Variables](https://vercel.com/docs/concepts/projects/environment-variables#system-environment-variables) 문서에서 자세히 확인할 수 있어요.\n\n#### URL 구성(URL Composition)  \n(여기에서는 URL을 어떻게 조합하는지에 관한 내용이 나올 것 같네요. 필요하면 추가 설명해 드릴게요!)\n\n---\n\n추가 팁:  \n`metadataBase`를 잘 활용하면 SEO, 소셜 미디어 공유 등에 쓰이는 Open Graph, Twitter Card 메타데이터 설정이 훨씬 편리해집니다. 특히, 여러 환경에 맞게 URL이 자동으로 바뀌니까 관리 부담도 줄어들죠!  \n환경 변수 설정을 깜빡하지 말고, `.env` 파일 같은 곳에서 꼼꼼히 관리해 주세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nURL 구성을 할 때, 개발자가 의도한 경로를 우선시하는 특징이 있습니다. 여기서 기본 디렉토리 탐색 방식과는 다르게 작동한다고 보면 돼요.\n\n- `metadataBase`와 `metadata` 필드 사이에 있는 **슬래시(/)**는 자동으로 정리(정규화)돼요. 그래서 경로가 어색하게 겹치거나 빠지는 일이 없죠.\n- 그리고 일반적으로 URL 전체 경로를 대체하는 절대 경로(`/`로 시작하는 경로)가 들어와도, 이걸 \"상대 경로\"로 해석해서 `metadataBase`의 끝부분부터 시작하는 경로로 간주해요.\n\n### 예를 들어, 아래처럼 `metadataBase`를 설정했다고 가정해보죠:\n\n```js\nimport type { Metadata } from 'next'\n\nexport const metadata: Metadata = {\n  metadataBase: new URL('https://acme.com'),\n}\n```\n\n이 경우, 만약 `metadata` 안에서 절대 경로처럼 보이는 `/about`이나 `/team` 같은 경로를 넣더라도, 실제로는 `https://acme.com/about`, `https://acme.com/team` 이런 식으로 `metadataBase`를 바탕으로 경로가 완성됩니다. \n\n이는 URL 조합 시 헷갈릴 수 있는 슬래시 중복 문제나, 경로가 엉뚱하게 바뀌는 문제를 방지해줘서 개발자가 의도한 URL을 정확하게 만들 수 있도록 도와줍니다.\n\n---\n\n추가로, Next.js에서 `metadataBase`를 사용하는 이유는 **SEO 최적화와 메타데이터 관리**를 좀 더 깔끔하고 명확하게 하기 위해서예요. 이걸 잘 활용하면 외부 링크나 공유할 때도 주소가 예상대로 동작해서 유용하니, 프로젝트에 맞게 꼭 써보길 추천합니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위에서 설명한 `metadataBase`를 상속받아 개별 메타데이터 필드가 자신의 값을 설정할 때, URL은 다음과 같이 해석돼요:\n\n| `metadata` 필드      | 해석된 URL                       |\n|---------------------|---------------------------------|\n| `/`                 | `https://acme.com`               |\n| `./`                | `https://acme.com`               |\n| `payments`          | `https://acme.com/payments`      |\n| `/payments`         | `https://acme.com/payments`      |\n| `./payments`        | `https://acme.com/payments`      |\n| `../payments`       | `https://acme.com/payments`      |\n| `https://beta.acme.com/payments` | `https://beta.acme.com/payments` |\n\n즉, 상대 경로를 적더라도 `metadataBase`가 `https://acme.com`이라면, 결국 그 기준에서 최종 URL이 해석된다는 뜻이에요. 완전한 절대 URL을 제공하면 그대로 사용되고, 상대 경로라면 기본 베이스를 기준으로 합쳐지게 되죠.\n\n---\n\n### openGraph 메타데이터 예시\n\n```js\nexport const metadata = {\n  openGraph: {\n    title: 'Next.js',\n    description: 'The React Framework for the Web',\n    url: 'https://nextjs.org',\n    siteName: 'Next.js',\n    images: [\n      {\n        url: 'https://nextjs.org/og.png', // 반드시 절대 URL이어야 해요.\n        width: 800,\n        height: 600,\n      },\n      {\n        url: 'https://nextjs.org/og-alt.png',\n        width: 1800,\n        height: 1600,\n        alt: 'My custom alt', // 이미지가 로드 안 될 때 대체 텍스트용\n      },\n    ],\n    videos: [\n      {\n        url: 'https://nextjs.org/video.mp4', // 절대 URL 필수\n        width: 800,\n        height: 600,\n      },\n    ],\n    audio: [\n      {\n        url: 'https://nextjs.org/audio.mp3', // 절대 URL이어야 함\n      },\n    ],\n    locale: 'en_US',\n    type: 'website',\n  },\n}\n```\n\nOpen Graph 메타데이터는 페이스북, 트위터 같은 소셜 미디어에서 공유할 때 정보가 풍부하게 나타나도록 도와줘요. 예를 들어, 사이트 제목, 설명, 메인 URL 뿐만 아니라 이미지, 동영상, 오디오까지 확장해서 넣을 수 있죠. 특히 이미지의 경우, 절대경로 URL을 사용하는 게 중요하고, 크기 정보와 대체 텍스트도 넣어주는 게 좋아요. 그래야 소셜 미디어가 올바르게 콘텐츠를 표시하거든요.\n\n또, `locale` 속성은 콘텐츠 언어나 지역을 지정하는데, 이를 통해 다른 국가나 언어권에서 맞춤형으로 보이게 할 수 있어요. `type`은 공유하는 콘텐츠의 유형을 지정하는데, 예를 들어 `website`, `article`, `video.movie` 등이 있어요.\n\n이렇게 메타데이터를 꼼꼼히 설정하면, 검색엔진 최적화(SEO)와 소셜 미디어에서의 콘텐츠 노출이 훨씬 좋아지니 꼭 활용해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n오늘은 웹 페이스북, 트위터 등 소셜 미디어에서 내 사이트가 어떻게 보일지 정하는 데 핵심 역할을 하는 'Open Graph(OG) 메타태그'에 대해 얘기해보려고 해요. 그리고 Next.js에서 이걸 어떻게 손쉽게 다룰 수 있을지도 소개합니다.\n\n---\n\n## 1. 기본적인 Open Graph 메타태그 구조\n\n웹 문서 `\u003chead\u003e` 안에 아래처럼 메타 태그를 넣으면, SNS에서 내 페이지가 공유될 때 제목, 설명, 이미지, 사이트 이름 등 다양한 정보를 잘 보여줄 수 있어요.\n\n```html\n\u003cmeta property=\"og:title\" content=\"Next.js\" /\u003e\n\u003cmeta property=\"og:description\" content=\"The React Framework for the Web\" /\u003e\n\u003cmeta property=\"og:url\" content=\"https://nextjs.org/\" /\u003e\n\u003cmeta property=\"og:site_name\" content=\"Next.js\" /\u003e\n\u003cmeta property=\"og:locale\" content=\"en_US\" /\u003e\n\u003cmeta property=\"og:image\" content=\"https://nextjs.org/og.png\" /\u003e\n\u003cmeta property=\"og:image:width\" content=\"800\" /\u003e\n\u003cmeta property=\"og:image:height\" content=\"600\" /\u003e\n\u003cmeta property=\"og:image\" content=\"https://nextjs.org/og-alt.png\" /\u003e\n\u003cmeta property=\"og:image:width\" content=\"1800\" /\u003e\n\u003cmeta property=\"og:image:height\" content=\"1600\" /\u003e\n\u003cmeta property=\"og:image:alt\" content=\"My custom alt\" /\u003e\n\u003cmeta property=\"og:video\" content=\"https://nextjs.org/video.mp4\" /\u003e\n\u003cmeta property=\"og:video:width\" content=\"800\" /\u003e\n\u003cmeta property=\"og:video:height\" content=\"600\" /\u003e\n\u003cmeta property=\"og:audio\" content=\"https://nextjs.org/audio.mp3\" /\u003e\n\u003cmeta property=\"og:type\" content=\"website\" /\u003e\n```\n\n\u003e 여기서 중요한 점은 여러 개의 og:image 태그를 넣을 수 있다는 거예요! 이렇게 하면 SNS에서 선택적으로 보여줄 이미지가 다양해져서 좀 더 풍성한 미리보기를 만들 수 있죠.\n\n---\n\n## 2. 포스트 형식 메타태그 예시\n\n블로그 글이나 뉴스 같은 ‘article’ 타입엔 아래처럼 좀 더 구체적인 메타 정보(작성일, 작성자 등)를 추가할 수 있어요.\n\n```html\n\u003cmeta property=\"og:title\" content=\"Next.js\" /\u003e\n\u003cmeta property=\"og:description\" content=\"The React Framework for the Web\" /\u003e\n\u003cmeta property=\"og:type\" content=\"article\" /\u003e\n\u003cmeta property=\"article:published_time\" content=\"2023-01-01T00:00:00.000Z\" /\u003e\n\u003cmeta property=\"article:author\" content=\"Seb\" /\u003e\n\u003cmeta property=\"article:author\" content=\"Josh\" /\u003e\n```\n\n여기서도 작성자가 여러 명일 경우, author 태그를 여러 개 넣으면 됩니다.\n\n---\n\n## 3. Next.js 메타데이터 API로 간단하게 쓰기\n\nNext.js 13부터 파일 기반 메타데이터 API 덕분에 이런 메타 태그를 자바스크립트 오브젝트 형태로 쉽게 선언 가능해요:\n\n```js\nexport const metadata = {\n  openGraph: {\n    title: 'Next.js',\n    description: 'The React Framework for the Web',\n    type: 'article',\n    publishedTime: '2023-01-01T00:00:00.000Z',\n    authors: ['Seb', 'Josh'],\n  },\n}\n```\n\n이렇게만 하면 Next.js가 알아서 위의 `\u003cmeta\u003e` 태그들을 자동으로 만들어 줍니다. 훨씬 편하죠?\n\n---\n\n## 4. 꿀팁: 이미지 메타데이터는 파일 기반 API 활용하기\n\nOpen Graph 이미지 메타정보를 직접 관리하는 건 정말 귀찮거든요. 예를 들어 이미지 파일이 바뀌거나 경로가 바뀌면 메타데이터도 수동으로 바꿔줘야 해서 실수가 잦아요.\n\nNext.js 파일 기반 메타데이터 API를 사용하면:\n\n- 실제 파일 시스템에서 이미지를 가져와서 맞는 크기, 타입 등을 자동으로 계산해줘요.\n- 중복되거나 엉뚱한 메타 태그 생성을 방지해줘서 안정적입니다.\n\n공식 문서를 참고해서 이미지 파일을 같이 관리하는 패턴으로 바꾸면 개발 생산성이 올라가니 꼭 써보세요!\n\n---\n\n## 마무리\n\n- OG 태그는 SNS 공유 시 내 사이트가 멋지게 보이도록 만드는 필수 요소예요.\n- 기본 태그부터 기사형 태그까지 상황에 맞게 넣으면 좋아요.\n- Next.js 13 이상의 메타데이터 API를 활용하면 작업이 훨씬 수월해집니다.\n- 이미지 메타 정보는 파일 기반 API를 이용해 관리하세요.\n\n웹사이트를 좀 더 프로페셔널하게 보이게 만드는 작은 팁! 여러분의 프로젝트에도 꼭 적용해 보시길 바랍니다. 다음에도 좋은 웹 개발 이야기로 찾아올게요! 😄\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### robots 메타 태그 설정하기\n\nNext.js에서 SEO를 신경 쓸 때, `metadata` 객체의 `robots` 속성을 잘 활용하면 구글봇 같은 검색 엔진 크롤러들에게 페이지 인덱싱 방법을 알려줄 수 있어요. 예를 들어 아래처럼 설정할 수 있죠:\n\n```js\nimport type { Metadata } from 'next'\n \nexport const metadata: Metadata = {\n  robots: {\n    index: true, // 페이지를 인덱싱 하라고 명시\n    follow: true, // 페이지 내 링크들도 크롤링 하도록 허용\n    nocache: false, // 캐싱 하지 말라는 지시어(false면 캐시 가능)\n    googleBot: { // 구글봇에 대한 세부 설정\n      index: true,\n      follow: true,\n      noimageindex: false, // 이미지 인덱싱 허용\n      'max-video-preview': -1, // 비디오 미리보기 무제한\n      'max-image-preview': 'large', // 큰 이미지 미리보기 허용\n      'max-snippet': -1, // 스니펫 길이 제한 없음\n    },\n  },\n}\n```\n\n이걸 HTML meta 태그로 나타내면 아래와 같아요:\n\n```html\n\u003cmeta name=\"robots\" content=\"index, follow\" /\u003e\n\u003cmeta\n  name=\"googlebot\"\n  content=\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"\n/\u003e\n```\n\n\u003e **팁!**  \n\u003e robots 메타 태그는 SEO에 아주 중요한 역할을 해요.  \n\u003e - `index, follow`는 기본적으로 페이지와 링크들을 모두 크롤링해서 인덱싱하라는 뜻이고,  \n\u003e - `noindex`를 쓰면 검색결과에서 제외되기도 하니 주의가 필요해요.  \n\u003e  \n\u003e 구글봇에 따로 설정을 줄 수 있다는 점도 기억해두면 좋습니다.  \n\u003e 맞춤형 SEO가 필요할 때 활용하기 딱 좋거든요.\n\n다음은 아이콘 관련 설정으로 넘어가 볼게요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n좋은 소식! 아이콘 설정할 때 되도록이면 파일 기반의 Metadata API를 사용하는 걸 추천해요. 설정 파일과 실제 아이콘 파일을 일일이 맞출 필요 없이, 이 API가 알아서 올바른 메타데이터를 생성해주거든요. 덕분에 실수도 줄고 관리도 편해져요.\n\n예를 들어, 아래처럼 간단하게 아이콘 경로만 지정해주면:\n\n```js\nexport const metadata = {\n  icons: {\n    icon: '/icon.png',\n    shortcut: '/shortcut-icon.png',\n    apple: '/apple-icon.png',\n    other: {\n      rel: 'apple-touch-icon-precomposed',\n      url: '/apple-touch-icon-precomposed.png',\n    },\n  },\n}\n```\n\n이렇게 실제 HTML 메타 태그가 자동으로 생성되죠:\n\n```html\n\u003clink rel=\"shortcut icon\" href=\"/shortcut-icon.png\" /\u003e\n\u003clink rel=\"icon\" href=\"/icon.png\" /\u003e\n\u003clink rel=\"apple-touch-icon\" href=\"/apple-icon.png\" /\u003e\n\u003clink rel=\"apple-touch-icon-precomposed\" href=\"/apple-touch-icon-precomposed.png\" /\u003e\n```\n\n여기서 아이콘을 더 다양한 상황에 맞게 세분화해서 지정할 수도 있어요. 예를 들면 다크모드용 아이콘이나 여러 크기의 아이콘 등도 말이죠:\n\n```js\nexport const metadata = {\n  icons: {\n    icon: [\n      { url: '/icon.png' },\n      new URL('/icon.png', 'https://example.com'), // 절대 URL도 가능해요\n      { url: '/icon-dark.png', media: '(prefers-color-scheme: dark)' }, // 다크모드 전용 아이콘\n    ],\n    shortcut: ['/shortcut-icon.png'], // 배열 형태로도 지원하고\n    apple: [\n      { url: '/apple-icon.png' },\n      { url: '/apple-icon-x3.png', sizes: '180x180', type: 'image/png' }, // 크기와 타입 지정\n    ],\n    other: [\n      {\n        rel: 'apple-touch-icon-precomposed',\n        url: '/apple-touch-icon-precomposed.png',\n      },\n    ],\n  },\n}\n```\n\n잘 보시면, 각 아이콘에 크기, 미디어 쿼리, 타입 등 상황에 맞는 세부 옵션을 넣을 수 있어서 훨씬 유연하게 아이콘을 관리할 수 있어요. 특히 요즘 다크모드 지원이 필수인 만큼 `(prefers-color-scheme: dark)` 같은 미디어 쿼리를 활용하는 게 중요합니다.\n\n아이콘 설정은 웹사이트의 첫인상에도 영향을 주니 꼼꼼하게 세팅해두면 좋아요! 나중에 favicon이 제대로 안 보인다고 당황하지 말고, 이런 메타데이터 API를 활용해보세요. 관리가 훨씬 쉬워질 거랍니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위 코드는 웹사이트에서 자주 사용하는 아이콘과 메타 태그 설정 부분인데요, HTML `\u003clink\u003e` 태그를 이용해 파비콘(favicon), 애플 터치 아이콘을 등록하는 예시입니다.\n\n간단히 설명드리자면,\n\n- `\u003clink rel=\"shortcut icon\" href=\"/shortcut-icon.png\" /\u003e`: 가장 일반적인 파비콘 설정.\n- `\u003clink rel=\"icon\" href=\"/icon.png\" /\u003e`: 파비콘 설정 (기본).\n- `\u003clink rel=\"icon\" href=\"https://example.com/icon.png\" /\u003e`: 외부 URL에 있는 아이콘 설정 가능.\n- `\u003clink rel=\"icon\" href=\"/icon-dark.png\" media=\"(prefers-color-scheme: dark)\" /\u003e`: 다크 모드일 때 사용할 파비콘.\n- `\u003clink rel=\"apple-touch-icon\" href=\"/apple-icon.png\" /\u003e` 및 관련 태그들: 아이폰, 아이패드 등 iOS 기기 홈 화면에 추가할 때 쓰이는 아이콘.\n\n이 부분에서 알아두면 좋은 점 몇 가지!\n\n| 항목 | 설명 |\n| --- | --- |\n| msapplication-* 메타 태그 | MS Edge(Chromium 기반)에서는 더 이상 지원하지 않으니 추가할 필요 없음 |\n| themeColor 옵션 | Next.js 14부터는 `themeColor`가 deprecated 되었고, 대신 `viewport` 설정을 권장 |\n\n📌 특히 다크 모드용으로 별도 파비콘을 설정한다든지, 애플 터치 아이콘에 사이즈를 명시해서 다양한 기기 대응을 하는 점이 요즘 트렌드고, 사용자 경험을 더 좋게 만듭니다.\n\n---\n\n\u003e **추가 팁!**  \n\u003e 아이콘은 해상도가 높은 걸 준비하는 게 유리해요. 예를 들어 180x180 사이즈 정도면 모바일 기기에서 깨끗하게 보이고, 더 큰 아이콘을 준비하면 고화질 디스플레이에서 유용하죠.  \n\u003e 또, `manifest.json` 파일과 연동해 PWA(Progressive Web App)를 만들 때에도 아이콘 설정이 중요합니다.\n\n이렇게 설정을 해두면, 다양한 브라우저와 디바이스에서 잘 작동하는 멋진 사이트 아이콘을 가질 수 있습니다! 필요하다면 상황에 맞게 `rel`이나 `sizes` 같은 속성도 조절해 보세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### colorScheme\n\n\u003e 더 이상 권장되지 않아요: Next.js 14부터는 metadata에서 `colorScheme` 옵션이 deprecated 되었어요. 대신에 **viewport 설정**을 사용하라고 하네요.\n\n사실 `colorScheme`은 라이트 모드, 다크 모드 같은 테마를 간단하게 지정할 때 쓰였는데, 이제는 Next.js가 좀 더 유연하게 뷰포트 기반으로 처리하기 때문에 바뀐 거예요. 만약 이전에 `colorScheme` 쓰고 있었다면, 이제는 `viewport` 설정을 어떻게 주는지 살펴보는 걸 추천해요!\n\n---\n\n### manifest\n\n웹 애플리케이션 매니페스트(manifest)는 웹 앱이 네이티브 앱처럼 동작할 수 있도록 도와주는 **설정 파일**이에요.  \n말 그대로, 앱 이름, 아이콘, 시작 URL, 화면 회전 방식 등 사용자 경험에 관련된 여러 정보를 JSON 형태로 정의해두는 거죠.\n\n이 매니페스트는 [Web Application Manifest 사양](https://developer.mozilla.org/en-US/docs/Web/Manifest)을 따르는데, 이를 통해 브라우저가 앱 설치 시 어떤 모습으로 표시할지, 시작할 때 어떤 화면크기로 열지 같은 걸 알 수 있어요.\n\n---\n\n추가로, Next.js에서 이 매니페스트를 다룰 때는 `public` 폴더에 `manifest.json` 파일을 넣고, 이걸 기본 HTML에 링크해주면 끝!  \n```html\n\u003clink rel=\"manifest\" href=\"/manifest.json\" /\u003e\n```\n\n이렇게 하면 PWA(Progressive Web App)로서 한 단계 더 발전시킬 수 있으니, 관심 있으면 한번 도전해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안녕하세요 여러분! 이번에는 웹앱이나 사이트에서 자주 사용되는 `manifest` 관련 설정과 트위터 메타데이터에 대해 살펴볼게요.\n\n---\n\n먼저, Next.js 같은 프레임워크에서 `manifest`를 설정하는 방법입니다. 아래 코드는 `metadata` 객체 안에 `manifest` 속성을 넣는 예시인데요,\n\n```js\nexport const metadata = {\n  manifest: 'https://nextjs.org/manifest.json',\n}\n```\n\n이렇게 하면 Next.js가 이 `manifest.json` 파일을 웹 앱의 매니페스트로 인식해줍니다.\n\n---\n\n기존 HTML에서는 아래처럼 `\u003clink\u003e` 태그로 `manifest`를 연결했죠.\n\n```js\n\u003clink rel=\"manifest\" href=\"https://nextjs.org/manifest.json\" /\u003e\n```\n\n즉, `manifest`는 PWA(Progressive Web App)를 만들 때 필수적인 구성 요소로, 앱의 아이콘, 이름, 시작 URL, 색상 같은 정보를 담고 있어요. 그래서 브라우저가 앱을 어떻게 실행할지, 어떤 버튼을 보여줄지 등의 정보를 확인할 수 있답니다.\n\n---\n\n### Twitter 메타데이터 (트위터 카드)\n\n흥미로운 점은, 트위터의 메타데이터 스펙이 실제로는 X(예전 트위터)뿐만 아니라 여러 플랫폼에서 활용된다는 거예요.\n\n예를 들어, `twitter:card`, `twitter:title`, `twitter:description` 같은 태그를 넣으면 트윗이 공유될 때 예쁘게 카드 형태로 보이고, 검색 엔진에도 긍정적인 영향을 미칩니다.\n\n추가 팁으로는 아래처럼 Next.js의 `metadata` 객체에 `twitter` 속성을 활용할 수도 있어요:\n\n```js\nexport const metadata = {\n  twitter: {\n    card: 'summary_large_image',\n    site: '@your_twitter_handle',\n    title: '이 페이지의 제목',\n    description: '페이지 설명을 적어주세요',\n    images: ['https://example.com/image.png'],\n  },\n}\n```\n\n이렇게 하면 별도의 `\u003cmeta\u003e` 태그를 일일이 작성하지 않아도 되니 훨씬 편리합니다.\n\n---\n\n### 요약\n\n아래 표에 간략히 정리해봤어요!\n\n| 설정 방법          | 설명                                     |\n|-------------------|----------------------------------------|\n| `metadata.manifest` | Next.js에서 PWA 매니페스트 JSON 파일 경로 설정  |\n| `\u003clink rel=\"manifest\" ... /\u003e` | 전통적인 HTML에서 매니페스트 연결 태그          |\n| `metadata.twitter` | 트위터(X) 카드 메타데이터 자동 생성 및 관리      |\n\n---\n\n오늘은 여기까지! PWA나 소셜 공유 시 내 사이트를 더 멋지게 보이게 만들고 싶다면 `manifest` 설정과 트위터 카드 메타데이터를 꼭 활용해보세요. 질문 있으면 댓글로 남겨주세요~ :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n트위터 카드를 활용해서 여러분의 웹페이지가 트위터에서 더 멋지게 보이도록 할 수 있어요. 특히 링크가 공유될 때 이미지, 제목, 설명 등이 깔끔하게 표시되어서 클릭률도 올라가겠죠?\n\n이번에 소개할 건 Next.js 공식 문서 기준으로 작성한 Twitter Card 메타 태그예요. Next.js에서 `metadata` 객체 안에 트위터 정보를 넣는 방식인데, 이걸 페이지에 적용하면 트위터가 이 정보를 보고 카드 형태로 링크를 꾸며줍니다.\n\n---\n\n### 1. `summary_large_image` 카드 타입  \n트윗에 큰 이미지와 함께 짧은 제목, 설명을 노출하는 카드 타입이에요.\n\n```jsx\nexport const metadata = {\n  twitter: {\n    card: 'summary_large_image',            // 카드 타입 지정\n    title: 'Next.js',                        // 카드 제목\n    description: 'The React Framework for the Web', // 카드 설명\n    siteId: '1467726470533754880',          // 사이트 트위터 ID (숫자)\n    creator: '@nextjs',                      // 작성자 트위터 계정\n    creatorId: '1467726470533754880',       // 작성자 트위터 ID (숫자)\n    images: ['https://nextjs.org/og.png'],  // 반드시 절대 URL로 이미지 지정\n  },\n}\n```\n\n위처럼 설정하면 내부적으로는 아래처럼 메타 태그가 생성됩니다:\n\n```html\n\u003cmeta name=\"twitter:card\" content=\"summary_large_image\" /\u003e\n\u003cmeta name=\"twitter:site:id\" content=\"1467726470533754880\" /\u003e\n\u003cmeta name=\"twitter:creator\" content=\"@nextjs\" /\u003e\n\u003cmeta name=\"twitter:creator:id\" content=\"1467726470533754880\" /\u003e\n\u003cmeta name=\"twitter:title\" content=\"Next.js\" /\u003e\n\u003cmeta name=\"twitter:description\" content=\"The React Framework for the Web\" /\u003e\n\u003cmeta name=\"twitter:image\" content=\"https://nextjs.org/og.png\" /\u003e\n```\n\n\u003e **팁:** `images`는 배열로 받지만, URL은 반드시 절대 경로(https://~~)여야 하므로 로컬 경로나 상대 경로는 사용하면 안 됩니다.\n\n---\n\n### 2. `app` 카드 타입  \n앱 카드 타입은 모바일 앱 링크를 추가해 앱 설치를 유도할 때 유용해요. 예를 들어 iPhone, iPad, 구글플레이 각각에 맞는 앱 스토어 URL을 넣을 수 있죠.\n\n```jsx\nexport const metadata = {\n  twitter: {\n    card: 'app',\n    title: 'Next.js',\n    description: 'The React Framework for the Web',\n    siteId: '1467726470533754880',\n    creator: '@nextjs',\n    creatorId: '1467726470533754880',\n    images: {\n      url: 'https://nextjs.org/og.png',\n      alt: 'Next.js Logo',                  // 이미지 대체 텍스트도 넣으면 좋아요\n    },\n    app: {\n      name: 'twitter_app',\n      id: {\n        iphone: 'twitter_app://iphone',    // 앱 아이디 스킴\n        ipad: 'twitter_app://ipad',\n        googleplay: 'twitter_app://googleplay',\n      },\n      url: {\n        iphone: 'https://iphone_url',      // iOS 앱스토어 URL\n        ipad: 'https://ipad_url',          // iPad용 URL\n      },\n    },\n  },\n}\n```\n\n요런 식으로 하면 트위터 카드에 앱 다운로드 링크도 함께 추가되어 사용자가 트윗에서 바로 앱 설치 페이지로 이동할 수 있답니다.  \n\n---\n\n## 한눈에 보는 트위터 카드 옵션 정리\n\n| 속성           | 설명                                        | 비고                         |\n| -------------- | ------------------------------------------- | ---------------------------- |\n| `card`         | 카드 유형 지정 (`summary_large_image`, `app` 등) | 타입에 따라 보이는 형태 변동 |\n| `title`        | 카드 제목                                    | 70자 이내 권장               |\n| `description`  | 카드에 보이는 간단 설명                       | 200자 이내 권장              |\n| `siteId`       | 사이트 소유 트위터 ID                         | 숫자만 입력                  |\n| `creator`      | 작성자 트위터 핸들 (예: `@nextjs`)          | 선택사항                    |\n| `creatorId`    | 작성자 트위터 ID                              | 숫자만 입력                  |\n| `images`       | 대표 이미지 URL (또는 객체로 `url`, `alt` 포함)| 반드시 절대 URL              |\n| `app`          | 모바일 앱 정보 (앱 이름, ID, URL 등)          | 앱 카드 타입에서 사용         |\n\n---\n\n### 마무리\n\n트위터 카드는 단순한 텍스트 링크보다 훨씬 풍성한 정보를 제공합니다. 블로그, 뉴스, 제품 소개 페이지 등 모든 공유 콘텐츠에 기본으로 적용하면 좋고, 특히 모바일 앱을 홍보할 때는 `app` 카드가 효과적이에요.\n\n참고로, 메타 태그가 제대로 작동하는지 꼭 [Twitter Card Validator](https://cards-dev.twitter.com/validator)에서 테스트해보세요! URL을 입력하면 트위터에서 어떻게 보일지 미리 확인할 수 있으니까요.\n\n자, 이제 여러분 웹사이트에 멋진 트위터 카드를 달아서 SNS 유입도 올리고, 사용자 경험도 업그레이드 해보세요! 필요하면 Next.js 공식 문서도 같이 참고하시길 추천합니다. 🚀\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번에 살펴볼 내용은 Next.js 프로젝트 안에서 Twitter 카드 메타 태그 설정과 관련된 부분이에요. 그리고 Next.js 14에서 바뀐 `viewport` 설정에 대한 알림도 함께 다뤄볼게요.\n\n우선, 코드에서 메타 태그를 보면 주로 Twitter 카드용으로 쓰이는 정보들이 담겨 있어요. 트위터 카드란, 트위터에 URL을 공유할 때 보이는 미리보기 박스 같은 거죠. 여기서 중요한 속성들을 한 번 정리해볼게요.\n\n| 메타 태그 속성명                 | 설명                                    |\n|--------------------------------|---------------------------------------|\n| `twitter:site:id`               | 트위터 사이트(계정) 고유 ID             |\n| `twitter:creator`               | 컨텐츠를 만든 사람의 트위터 핸들         |\n| `twitter:title`                 | 공유할 때 보여질 제목                     |\n| `twitter:description`           | 공유할 때 보여질 설명                     |\n| `twitter:card`                  | 카드 타입 (예: summary, app 등)          |\n| `twitter:image`                 | 미리보기 이미지 URL                      |\n| `twitter:image:alt`             | 이미지 대체 텍스트                       |\n| `twitter:app:name:iphone`       | 아이폰 앱 이름                           |\n| `twitter:app:id:iphone`         | 아이폰 앱 고유 ID/URI                    |\n| `twitter:app:url:iphone`        | 아이폰 앱 연결 URL                       |\n| (ipad, googleplay 관련 항목도 동일한 역할을 함)                |\n\n이렇게 여러 플랫폼(iPhone, iPad, Android/GooglePlay) 별로 앱 이름과 URL을 명시해 주는 게 특징이에요. 만약 여러분 앱이 여러 플랫폼에서 동작한다면, 이런 메타 태그를 꼭 넣어주는 게 좋아요. 그럼 트위터가 공유 시 앱을 바로 연결해주니까요.\n\n---\n\n### Next.js 14부터 달라진 viewport 설정\n\n그리고 예고처럼, Next.js 14부터는 `metadata` 안에서 `viewport` 옵션을 직접 쓰는 게 deprecated(사용 중단) 되었어요. 대신, Next.js는 이제 `next.config.js` 또는 `app/layout.tsx` 등에서 별도의 viewport 설정을 권장합니다.\n\n예를 들어, 기존엔 이렇게 썼다면:\n\n```js\nexport const metadata = {\n  viewport: 'width=device-width, initial-scale=1',\n};\n```\n\n이제는 HTML `\u003chead\u003e` 안에 직접 `\u003cmeta name=\"viewport\" content=\"...\"\u003e` 를 넣거나, Next.js가 제공하는 새로운 방식대로 설정하라는 거죠.\n\n이 부분은 반응형 웹 개발 시 매우 중요한 설정이라 꼭 알아두세요!\n\n---\n\n### 추가 팁! Twitter Card Validator\n\n트위터에서 내가 설정한 카드가 제대로 나오는지 확인하고 싶다면 [Twitter Card Validator](https://cards-dev.twitter.com/validator) 를 사용해보세요. URL 입력하면 실제 카드가 어떻게 나오는지 미리 보여줍니다.\n\n---\n\n그럼 오늘은 여기까지! 메타 태그 잘 활용해서 SNS 공유 효과도 쑥쑥 올려보세요~\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n요즘 웹사이트 최적화할 때 꼭 챙겨야 하는 메타 태그들, 여러분도 많이 들어보셨죠? 구글, 야ндекс, 야후 같은 검색엔진 인증부터, 애플 웹 앱 설정까지 다양한 메타 정보를 자바스크립트 객체 형태로 관리할 수 있는데요. 제가 한 번 직접 정리해보고, 어떤 식으로 활용하는지 쉽게 설명해 드릴게요!\n\n---\n\n## 1. 검색엔진 인증 메타 태그 관리하기\n\n웹사이트를 운영하면 구글, 야ндекс, 야후 등 다양한 검색엔진에 ‘내 사이트 인증’ 절차를 거쳐야 하죠. 이렇게 해야 검색 결과에 잘 노출되고, 통계도 정확하게 받아볼 수 있어요.\n\n```js\nexport const metadata = {\n  verification: {\n    google: 'google',           // 구글 사이트 인증 코드\n    yandex: 'yandex',           // 야ндекс 사이트 인증 코드\n    yahoo: 'yahoo',             // 야후 사이트 인증 코드\n    other: {\n      me: ['my-email', 'my-link'], // 기타 인증용 메타 정보\n    },\n  },\n}\n```\n\n위처럼 `verification` 객체 안에 각 인증 키를 넣으면, 실제 HTML 메타 태그로 이렇게 변환됩니다:\n\n```html\n\u003cmeta name=\"google-site-verification\" content=\"google\" /\u003e\n\u003cmeta name=\"y_key\" content=\"yahoo\" /\u003e\n\u003cmeta name=\"yandex-verification\" content=\"yandex\" /\u003e\n\u003cmeta name=\"me\" content=\"my-email\" /\u003e\n\u003cmeta name=\"me\" content=\"my-link\" /\u003e\n```\n\n\u003e **TIP:** `me` 메타 태그는 주로 이메일이나 개인 프로필 URL을 나타낼 때 사용해요. 검색엔진 최적화(SEO)를 넘어서 사이트 신뢰도에 도움 됩니다.\n\n---\n\n## 2. Apple Web App 을 위한 메타 태그 구성하기\n\n아이폰, 아이패드 사용자 대상으로 웹 앱 모양을 좀 더 자연스럽게 만들고 싶다면 ‘appleWebApp’ 메타 정보가 매우 중요해요. 홈 화면에 웹 앱을 추가했을 때, 앱처럼 보여지는 설정들을 여기에 담을 수 있어요.\n\n```js\nexport const metadata = {\n  itunes: {\n    appId: 'myAppStoreID',          // 앱스토어 ID\n    appArgument: 'myAppArgument',   // 앱 열 때 전달하는 인자 (URL 스킴 등)\n  },\n  appleWebApp: {\n    title: 'Apple Web App',         // 웹 앱 이름\n    statusBarStyle: 'black-translucent', // 상태바 스타일(투명하거나 색상 지정)\n    startupImage: [                 // 시작화면 이미지\n      '/assets/startup/apple-touch-startup-image-768x1004.png',\n      {\n        url: '/assets/startup/apple-touch-startup-image-1536x2008.png',\n        media: '(device-width: 768px) and (device-height: 1024px)',\n      },\n    ],\n  },\n}\n```\n\n위 설정을 넣으면, 애플 기기에서 다음과 같은 경험을 쉽게 만들 수 있어요:\n\n- 홈 화면에 아이콘 추가했을 때 앱 이름과 상태바 모양 조정\n- 앱 시작 시 딜레이 없이 로딩 화면(스플래시 이미지) 띄우기\n- 앱스토어 연동해서 사용자 유입 매끄럽게\n\n---\n\n### 정리: 메타 태그는 ‘웹사이트를 검색엔진과 스마트 기기 환경에 맞게 최적화하는 히든 챔피언’\n\n하나하나 보면 어렵거나 귀찮을 수 있지만, `metadata` 객체로 잘 구조화하면 관리도 편하고 재사용도 쉬워집니다. 특히 최신 프레임워크(Next.js 같은)에서는 이런 식으로 메타 정보를 코드로 정의하는 걸 권장하죠.\n\n혹시 여러분도 사이트 SEO, 혹은 PWA/Apple Web App 최적화를 생각 중이라면, 위처럼 메타 태그 전략부터 차근차근 시작해 보시길 추천합니다!\n\n---\n\n참고로 다음 시간에는 이 `metadata` 객체를 실제로 어떻게 HTML `\u003chead\u003e`에 심고, 렌더링하는지 예제를 상세히 보여드릴게요. 기대 많이 해 주세요~\n\n---\n\n필요하다면 제가 직접 만든 메타 태그 템플릿도 공유해 드릴 수 있으니, 언제든 편하게 물어봐 주세요! 😊\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n메타 태그와 링크 태그를 통해 앱 관련 정보와 웹 앱 설정, 그리고 SEO에 중요한 alternates(대체 링크)를 어떻게 다루는지 예시를 보여드릴게요.\n\n---\n\n## 1. iOS/앱 관련 메타 태그 예시\n\n```html\n\u003cmeta\n  name=\"apple-itunes-app\"\n  content=\"app-id=myAppStoreID, app-argument=myAppArgument\"\n/\u003e\n\u003cmeta name=\"mobile-web-app-capable\" content=\"yes\" /\u003e\n\u003cmeta name=\"apple-mobile-web-app-title\" content=\"Apple Web App\" /\u003e\n\u003clink\n  href=\"/assets/startup/apple-touch-startup-image-768x1004.png\"\n  rel=\"apple-touch-startup-image\"\n/\u003e\n\u003clink\n  href=\"/assets/startup/apple-touch-startup-image-1536x2008.png\"\n  media=\"(device-width: 768px) and (device-height: 1024px)\"\n  rel=\"apple-touch-startup-image\"\n/\u003e\n\u003cmeta\n  name=\"apple-mobile-web-app-status-bar-style\"\n  content=\"black-translucent\"\n/\u003e\n```\n\n### 설명!\n\n- `apple-itunes-app`: 스토어 앱 아이디와 호출할 매개변수를 넣어, iOS에서 앱으로 바로 연결할 수 있게 해줍니다.\n- `mobile-web-app-capable`: 웹앱을 홈화면에 추가하면 네이티브 앱처럼 풀스크린으로 보여주도록 설정.\n- `apple-mobile-web-app-title`: 홈화면 아이콘 밑에 표시될 이름.\n- `apple-touch-startup-image`: 앱 실행 시 보여줄 스플래시 이미지를 기기별 해상도와 맞춰서 지정해줄 수 있어요.\n- `apple-mobile-web-app-status-bar-style`: 상태바 스타일을 지정하는데 `black-translucent`는 반투명 검정색을 의미.\n\n---\n\n## 2. SEO에 도움되는 alternates 설정\n\nNext.js 등에서 `metadata` 객체를 활용하면 좀 더 깔끔하게 메타 태그를 관리할 수 있습니다.\n\n### metadata 예시 (자바스크립트)\n\n```js\nexport const metadata = {\n  alternates: {\n    canonical: 'https://nextjs.org',\n    languages: {\n      'en-US': 'https://nextjs.org/en-US',\n      'de-DE': 'https://nextjs.org/de-DE',\n    },\n    media: {\n      'only screen and (max-width: 600px)': 'https://nextjs.org/mobile',\n    },\n    types: {\n      'application/rss+xml': 'https://nextjs.org/rss',\n    },\n  },\n}\n```\n\n### 실제 HTML로 변환 시\n\n```html\n\u003clink rel=\"canonical\" href=\"https://nextjs.org\" /\u003e\n\u003clink rel=\"alternate\" hreflang=\"en-US\" href=\"https://nextjs.org/en-US\" /\u003e\n\u003clink rel=\"alternate\" hreflang=\"de-DE\" href=\"https://nextjs.org/de-DE\" /\u003e\n\u003clink\n  rel=\"alternate\"\n  media=\"only screen and (max-width: 600px)\"\n  href=\"https://nextjs.org/mobile\"\n/\u003e\n\u003clink\n  rel=\"alternate\"\n  type=\"application/rss+xml\"\n  href=\"https://nextjs.org/rss\"\n/\u003e\n```\n\n### 설명!\n\n- `canonical`: 중복되는 콘텐츠가 있을 때 대표 주소를 검색 엔진에 알려줘 SEO에 유리!\n- `hreflang`: 언어별 페이지가 있을 때, 사용자 언어에 맞는 페이지로 안내해줍니다.\n- `media`: 특정 미디어쿼리 조건에 맞는 별도의 페이지를 지정할 수 있어 반응형 페이지를 분리할 때 유용.\n- `type`: RSS 피드 같은 타입별 대체 리소스 링크도 연결할 수 있습니다.\n\n---\n\n## 추가 팁!\n\n- iOS 홈 화면 아이콘(`apple-touch-icon`)이나 안드로이드 웹앱 설정도 같이 해주면 모바일 환경에서 훨씬 앱 같은 느낌을 낼 수 있어요.\n- SEO에서 `alternates`는 다국어 사이트, 반응형 사이트 운영 시 꼭 챙겨야 할 부분입니다.\n- Next.js나 React 같은 프레임워크에선 `head` 혹은 `metadata` 설정을 통해 위 태그를 동적으로 관리하면 편리해요.\n\n---\n\n필요한 메타 태그나 링크 설정 어떻게 쓰는지 궁금하다면 언제든 물어봐주세요! 제가 직접 해보고 쓰는 만큼 친근하게 알려드릴게요 :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### appLinks: 메타데이터에서 앱 링크 설정하기\n\n안녕하세요 여러분! 오늘은 메타데이터(metadata) 안에 `appLinks`를 설정하는 방법에 대해서 쉽게 알려드릴게요. 여러분이 Next.js 같은 최신 프레임워크에서 앱과 웹을 연결할 때 꽤 유용한 부분이랍니다.\n\n먼저, 아래 `appLinks` 객체를 보시면 iOS, Android, 그리고 Web을 위한 링크 설정을 각각 해 놓은 걸 볼 수 있어요.\n\n```js\nexport const metadata = {\n  appLinks: {\n    ios: {\n      url: 'https://nextjs.org/ios',\n      app_store_id: 'app_store_id',\n    },\n    android: {\n      package: 'com.example.android/package',\n      app_name: 'app_name_android',\n    },\n    web: {\n      url: 'https://nextjs.org/web',\n      should_fallback: true,\n    },\n  },\n}\n```\n\n- `ios`: 여기서는 iOS 앱 스토어 링크와 앱 ID가 들어가 있어요. 사용자가 iOS 디바이스에서 해당 링크를 열면 앱이 연결되거나 앱스토어로 이동하게 되죠.\n- `android`: 패키지 이름과 앱 이름이 들어가 있습니다. 마찬가지로 안드로이드 사용자를 위한 정보예요.\n- `web`: 웹 URL과 `should_fallback`이라는 옵션이 있어요. 이거는 모바일 앱이 설치 안 돼 있을 때 웹 사이트로 자동으로 넘어가게 하는 역할을 합니다.\n\n그리고 이렇게 설정한 내용은 결국 아래처럼 HTML `\u003cmeta\u003e` 태그로 변환이 됩니다. 이 메타 태그들은 Open Graph 프로토콜에 기반한 앱 링크 정보를 담고 있어서 SNS나 브라우저가 앱과 웹을 적절히 연결하게 해줍니다.\n\n| 태그 속성                    | 내용                          |\n|----------------------------|-----------------------------|\n| `\u003cmeta property=\"al:ios:url\" content=\"https://nextjs.org/ios\" /\u003e`         | iOS 앱으로 연결되는 URL          |\n| `\u003cmeta property=\"al:ios:app_store_id\" content=\"app_store_id\" /\u003e`          | iOS 앱스토어 ID                  |\n| `\u003cmeta property=\"al:android:package\" content=\"com.example.android/package\" /\u003e` | 안드로이드 앱 패키지 이름          |\n| `\u003cmeta property=\"al:android:app_name\" content=\"app_name_android\" /\u003e`      | 안드로이드 앱 이름                |\n| `\u003cmeta property=\"al:web:url\" content=\"https://nextjs.org/web\" /\u003e`         | 웹 URL                         |\n| `\u003cmeta property=\"al:web:should_fallback\" content=\"true\" /\u003e`               | 웹 fallback 허용 여부             |\n\n---\n\n### 추가 팁!\n\n- **앱 링크 설정의 중요성:** 요즘은 SNS나 모바일 브라우저에서 링크를 누르면 바로 앱이 뜨길 원하시잖아요? 이런 `appLinks` 덕분에 사용자 경험이 확실히 좋아집니다.\n- **앱이 없을 때 웹 fallback:** `should_fallback`을 `true`로 두면 사용자의 기기에 앱이 없어도 자연스럽게 웹으로 넘어가서 끊김없는 경험을 제공합니다.\n- **아이콘이나 스플래시 스크린 같은 추가 설정도 가능**하니, 앱을 홍보할 때 같이 챙기시면 좋겠죠?\n\n앱과 웹을 유기적으로 연결하고 싶을 때, 위처럼 `appLinks` 설정하는 것 잊지 마세요! 도움이 되셨다면 좋아요와 구독 부탁드려요~ 다음에 또 유용한 개발 정보로 찾아뵙겠습니다. :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\"archives\"라는 건 역사적인 가치가 있는 기록, 문서, 혹은 기타 자료들을 모아놓은 컬렉션을 의미해요. 예를 들어, 오래된 사진, 편지, 공식 문서 같은 것들이 여기에 속하죠.\n\n위에 있는 코드를 보면 두 가지 형태로 \"archives\"를 지정하는 방법이 나와 있어요.\n\n첫 번째는 자바스크립트 객체 형태로, `metadata`라는 변수 안에 `archives`라는 배열 속성으로 URL을 넣고 있고요.\n\n```js\nexport const metadata = {\n  archives: ['https://nextjs.org/13'],\n}\n```\n\n두 번째는 HTML의 `\u003clink\u003e` 태그를 써서 `\"archives\"`라는 관계를 명시하는 방법이에요.\n\n```js\n\u003clink rel=\"archives\" href=\"https://nextjs.org/13\" /\u003e\n```\n\n이런 방식으로 사이트나 문서가 참조하는 중요한 역사적 자료 링크를 연결할 수 있죠.\n\n### assets(에셋)\n\n여기서 `archives`와 비슷하게 많이 쓰이는 `assets`라는 용어도 알아두면 좋아요. `assets`는 이미지, 스타일시트, 스크립트 등 웹사이트에서 사용하는 모든 '자산'들을 의미해요. 즉, 웹사이트를 구성하는 데 필요한 리소스 파일들이죠.\n\n아래는 `assets`를 나타낼 때 사용하는 간단한 메타데이터 예시예요.\n\n```js\nexport const metadata = {\n  assets: ['https://example.com/assets/logo.png'],\n}\n```\n\n---\n\n추가로, 보통 역사적 기록이나 자료들을 다룰 때는 메타데이터를 잘 작성해두면 나중에 자료들을 검색하거나 관리하는 데 큰 도움이 돼요. 그래서 링크 태그나 자바스크립트 객체를 활용해 이런 정보를 명확하게 표시하는 게 중요합니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 `metadata`를 사용해서 페이지에 다양한 메타 정보를 추가할 수 있어요. 근데 `assets`와 `bookmarks`를 어떻게 쓰는지는 조금 헷갈릴 수 있죠. 여기서 간단하게 설명하고 예제도 보여드릴게요.\n\n---\n\n### 1. `assets` 설정하기\n\n```js\nexport const metadata = {\n  assets: ['https://nextjs.org/assets'],\n}\n```\n\n`assets`는 페이지에서 사용할 외부 리소스(이미지, 폰트, 아이콘 등)를 미리 선언하는 역할을 해요. 이게 있으면, 브라우저가 미리 해당 리소스를 캐싱하거나 최적화된 방식으로 로딩할 수 있게 도와줍니다.\n\n브라우저에 직접 `\u003clink rel=\"assets\" ... /\u003e` 태그를 추가하는 코드도 있는데, 보통 Next.js에서는 `metadata`를 통해 쉽게 설정할 수 있어요.\n\n이걸 HTML로 보면 이렇게 생겼죠:\n\n```html\n\u003clink rel=\"assets\" href=\"https://nextjs.org/assets\" /\u003e\n```\n\n---\n\n### 2. `bookmarks` 설정하기\n\n```js\nexport const metadata = {\n  bookmarks: ['https://nextjs.org/13'],\n}\n```\n\n`bookmarks`는 웹 브라우저에서 사용하는 북마크 리소스를 지정하는 메타데이터인데, 사실 웹 표준이나 브라우저 지원 면에서는 아직 널리 쓰이지 않는 편이에요. 그래서 굳이 사용할 필요는 없고, 특수한 경우가 아니라면 안 써도 무방합니다.\n\n---\n\n### 간단 정리\n\n| 키워드    | 용도                                      | 브라우저 지원 및 유용성                  |\n|----------|-----------------------------------------|----------------------------------------|\n| `assets` | 외부 리소스를 사전에 선언해 최적화 지원            | Next.js에서 공식 지원, 실사용에서 유용함   |\n| `bookmarks` | 북마크 관련 리소스 지정 (특정 브라우저에서 사용 가능) | 아직 표준 널리 쓰이지 않음, 보통 안 써도 됨 |\n\n---\n\n### 참고로\n\n- Next.js에서 `metadata`는 SEO나 사용자 경험 개선에 중요한 역할을 해요.\n- 공식 문서에서 지원하는 키만 사용하는 게 안전하고, `assets`는 그중 하나입니다.\n- HTML `\u003clink\u003e` 태그를 직접 다룰 필요 없이, Next.js가 알아서 `metadata`를 바탕으로 최적의 구조로 만들어줍니다.\n\n---\n\n이렇게 `metadata`를 잘 활용하면 페이지가 더 빠르게 로드되거나, 검색 엔진 최적화에도 도움 될 수 있어요. 혹시 더 궁금한 점 있으면 알려주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안녕하세요! 오늘은 HTML과 Next.js 메타데이터에 대해서 간단히 살펴볼게요. 코드 예시들을 보면서 자연스럽게 이해할 수 있도록 설명해 드릴게요.\n\n먼저, `\u003clink\u003e` 태그로 북마크(bookmarks) 같은 걸 지정하는 부분인데요:\n\n```html\n\u003clink rel=\"bookmarks\" href=\"https://nextjs.org/13\" /\u003e\n```\n\n여기서 `rel=\"bookmarks\"`는 링크가 북마크 관련 링크임을 알려주는 역할이에요. 하지만 보통 웹 개발에서 이 속성은 잘 사용하지 않는 편이라, 만약 북마크를 위한 링크를 넣고 싶다면 보통 사용자 브라우저나 북마크 기능을 활용하는 게 좋겠죠.\n\n---\n\n다음은 Next.js에서 메타데이터(metadata)를 설정하는 부분입니다.\n\n```js\nexport const metadata = {\n  category: 'technology',\n}\n```\n\n이 코드처럼 `metadata` 객체로 카테고리 같은 정보를 지정할 수 있어요. Next.js 13 버전부터 이런 식으로 페이지나 컴포넌트 단위 메타데이터 설정이 가능해져서 SEO(검색엔진최적화)에 아주 유용합니다.\n\n---\n\n그리고 보통 HTML 문서에는 다음처럼 `\u003cmeta\u003e` 태그를 써서 카테고리를 명시하기도 하죠:\n\n```html\n\u003cmeta name=\"category\" content=\"technology\" /\u003e\n```\n\n이 메타 태그는 검색엔진이나 소셜 미디어가 내용을 이해하는 데 도움을 줄 수 있어요.\n\n---\n\n### 쉽게 정리한 내용\n\n| 태그/코드                   | 역할 및 설명                                   |\n|-----------------------------|----------------------------------------------|\n| `\u003clink rel=\"bookmarks\" ...\u003e` | 북마크 관련 링크를 지정 (실제로는 잘 쓰이지 않음) |\n| `export const metadata = {...}` | Next.js에서 페이지 메타데이터 설정 (추천)          |\n| `\u003cmeta name=\"category\" ...\u003e` | HTML 문서에서 카테고리 같은 메타 정보 명시          |\n\n---\n\n참고로, HTML 메타태그는 SEO를 위해 꼭 필요한 요소입니다. 특히 `description`, `keywords`, `author` 같은 태그들도 추가해주면 더 좋죠. Next.js 13부터는 이런 메타데이터를 코드 안에서 직접 관리할 수 있어 개발 생산성이 훨씬 올라가니 꼭 한 번 써보세요!\n\n그럼 오늘 내용은 여기까지~ 즐거운 개발 되세요! 😊\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 페이스북 연동하기\n\n웹페이지에 페이스북 앱이나 페이스북 계정을 연결해서 페이스북 소셜 플러그인(Facebook Social Plugins)을 활용할 수 있어요. 공식 페이스북 문서에서 더 자세한 내용을 확인할 수 있답니다.\n\n\u003e 참고할 점: `appId`와 `admins` 옵션은 둘 다 쓸 수 없고, 한 가지만 선택해서 써야 해요.\n\n간단한 예시 코드를 보면 이렇게 구성할 수 있어요:\n\n```js\nexport const metadata = {\n  facebook: {\n    appId: '12345678',  // 본인의 페이스북 앱 ID를 여기에 입력하세요\n  },\n}\n```\n\n---\n\n#### 추가 팁!\n\n- **appId**는 페이스북 개발자 페이지에서 앱을 생성하면 얻을 수 있어요. 이 ID를 넣으면 페이스북 로그인, 공유 버튼 등 다양한 플러그인을 웹에 쉽게 적용할 수 있답니다.\n- 만약 개인 또는 조직의 페이스북 계정이 관리자로서 관련 페이지를 관리한다면 `admins` 옵션을 사용할 수도 있어요. 하지만 `appId`와 `admins`는 동시에 넣을 수 없으니 주의하세요.\n- 페이스북 소셜 플러그인을 적용할 때는 도메인 설정도 잘 맞춰줘야 오류 없이 작동해요.\n\n웹에 페이스북 기능을 심플하게 넣고 싶다면 이 설정부터 시작해 보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여러분, 페이스북과 연동할 때 사용하는 메타 태그에 대해 이야기해볼게요.\n\n---\n\n먼저, 페이스북 앱 ID를 지정하는 태그는 이렇게 생겼어요:\n\n```html\n\u003cmeta property=\"fb:app_id\" content=\"12345678\" /\u003e\n```\n\n이건 페이스북 앱과 내 사이트를 연결할 때 자주 사용되는 태그입니다. 특히, 페이스북에서 제공하는 소셜 플러그인이나 오픈그래프(Open Graph) 기능을 쓸 때 꼭 필요해요.\n\n---\n\n그리고 또 하나, 페이스북 관리자 권한을 명시할 때는 이렇게 할 수 있어요:\n\n```js\nexport const metadata = {\n  facebook: {\n    admins: '12345678',\n  },\n}\n```\n\n혹은 HTML에서는 다음처럼 쓸 수 있죠:\n\n```html\n\u003cmeta property=\"fb:admins\" content=\"12345678\" /\u003e\n```\n\n여기서 '12345678'은 페이스북 사용자 ID입니다. 이렇게 적어놓으면, 내가 해당 페이지에 대한 페이스북 통계나 관리를 더 쉽게 할 수 있어요.\n\n---\n\n추가로, 만약 여러 명의 fb:admins를 설정하고 싶다면, 배열을 사용하면 됩니다. 예를 들어 이렇게요:\n\n```js\nexport const metadata = {\n  facebook: {\n    admins: ['12345678', '87654321', '11223344'],\n  },\n}\n```\n\n이 경우, 페이스북에서 여러 사람에게 관리자 권한을 줄 수 있어 협업 시에 아주 유용하죠.\n\n---\n\n정리하자면,\n\n| 태그 종류          | 역할                        | 예시                                        |\n|-------------------|----------------------------|-------------------------------------------|\n| fb:app_id         | 앱 ID 등록, 페이스북 연동 필수    | `\u003cmeta property=\"fb:app_id\" content=\"12345678\" /\u003e` |\n| fb:admins         | 페이지 관리자 지정               | `\u003cmeta property=\"fb:admins\" content=\"12345678\" /\u003e`   |\n| fb:admins (배열)  | 여러 명의 관리자 지정            | admins: ['12345678', '87654321']             |\n\n---\n\n마지막으로 팁! 메타 태그는 HTML 헤드(head) 태그 안에 넣어야 제대로 작동하니, 꼭 위치를 신경 써주세요. 더불어 페이스북 디버거 툴 (Facebook Sharing Debugger)을 사용하면 제대로 설정됐는지 검증 가능하니 활용해 보시길 추천해요!\n\n필요한 부분 있으면 댓글로 물어봐 주세요~ :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안녕하세요! 이번에는 페이스북과 핀터레스트 같은 SNS 메타 태그를 다루는 방법을 간단히 살펴볼게요. 웹 개발할 때 메타데이터를 어떻게 설정하는지는 SEO나 소셜 미디어에서 내 콘텐츠가 어떻게 보일지에 큰 영향을 줍니다.\n\n## Facebook 메타 태그 설정하기\n\n먼저 `metadata` 객체를 사용해 페이스북의 `fb:admins`를 등록하는 예시입니다. 이 코드는 여러분이 페이스북 페이지의 관리자임을 인증하는 데 도움을 줘요.\n\n```js\nexport const metadata = {\n  facebook: {\n    admins: ['12345678', '87654321'],\n  },\n}\n```\n\n이걸 HTML 메타 태그로 변환하면 이렇게 됩니다:\n\n```html\n\u003cmeta property=\"fb:admins\" content=\"12345678\" /\u003e\n\u003cmeta property=\"fb:admins\" content=\"87654321\" /\u003e\n```\n\n페이스북에서 여러 명의 관리자를 등록할 때는 `\u003cmeta\u003e` 태그를 각각 추가하는 형식이죠. 이 값들은 페이스북 개발자 페이지에서 본인 계정을 식별할 때 필요해요. 특히 오픈 그래프(Open Graph) 태그와 함께 쓴다면 내 페이지가 페이스북에 공유될 때 멋지게 표시할 수 있습니다.\n\nTip!  \n`fb:admins` 외에도 `fb:app_id`(앱 ID)를 추가해주면 더 강력한 통계와 함께 페이스북 기능을 사용할 수 있어요.\n\n## Pinterest Rich Pins 활성화하기\n\n다음으로, 핀터레스트에서는 \"Rich Pins\"(리치 핀)이라는 기능이 있는데요, 이걸 통해 내가 만든 웹사이트 콘텐츠가 핀터레스트에서 더 풍부한 정보를 담아 보여질 수 있어요.\n\n\u003e 리치 핀은 예를 들면 상품, 레시피, 기사 등의 추가 정보가 포함되어서 사용자에게 더 많은 가치를 제공합니다.\n\n웹페이지에서 리치 핀을 사용할지 말지를 설정할 수 있는데, 간단히 메타 태그를 추가하거나 핀터레스트 개발자 도구를 통해 활성화할 수 있어요.\n\n예시로는 이런 식으로 메타 태그를 넣게 되죠:\n\n```html\n\u003cmeta property=\"og:type\" content=\"product\" /\u003e\n\u003cmeta property=\"og:title\" content=\"Awesome Product\" /\u003e\n\u003cmeta property=\"og:description\" content=\"This product is really awesome because...\" /\u003e\n\u003cmeta property=\"og:image\" content=\"https://example.com/product-image.jpg\" /\u003e\n\u003clink rel=\"canonical\" href=\"https://example.com/product-page\" /\u003e\n```\n\n이런 오픈 그래프 태그들이 핀터레스트가 내 콘텐츠를 정확히 이해하고 풍성하게 보이도록 도와줍니다.\n\n---\n\n### 요약 정리\n\n| 소셜 서비스 | 설정 방법                          | 주요 역할                                  |\n|-------------|----------------------------------|-------------------------------------------|\n| Facebook    | `\u003cmeta property=\"fb:admins\" /\u003e` | 관리자 인증 및 공유 시 페이지 신뢰성 향상  |\n| Pinterest   | 오픈 그래프 태그 추가           | 리치 핀 활성화로 콘텐츠 정보 풍성하게 표시 |\n\n---\n\n메타 태그를 잘 활용하면 내 사이트가 SNS에서 더 멋지게 보이고, 방문자에게 신뢰감을 줄 수 있어요. 블로그나 쇼핑몰을 운영하신다면 꼭 챙겨야 할 부분이니 한번 적용해보시길 추천드릴게요! 필요하면 오픈 그래프 태그, 트위터 카드 태그 같은 다른 메타 데이터도 같이 공부해보면 좋습니다 :)\n\n궁금한 점 있으면 언제든 물어보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자바스크립트 코드에서 메타데이터를 설정하는 방법과 HTML 메타 태그를 직접 작성하는 방법을 비교해볼게요.\n\n```js\nexport const metadata = {\n  pinterest: {\n    richPin: true,\n  },\n}\n```\n\n위 코드는 프로젝트 안에서 메타데이터를 설정하는 대표적인 예입니다. 여기서는 Pinterest의 Rich Pin 기능을 활성화 한다는 걸 나타내죠.\n\n반면에 HTML에서는 이렇게 작성할 수 있겠죠:\n\n```html\n\u003cmeta name=\"pinterest-rich-pin\" content=\"true\" /\u003e\n```\n\n이렇게 하면 브라우저나 크롤러가 해당 페이지에서 Rich Pin 기능을 인식할 수 있어요.\n\n---\n\n그리고 여기서 중요한 점! \n\n\u003e **other** 옵션을 활용하면 프로젝트에서 기본적으로 지원하지 않는 커스텀 메타 태그들도 추가할 수 있어요.\n\n즉, 공식적으로 제공되는 메타데이터 옵션 외에 브랜드에서 특별하게 필요한 메타 태그가 있거나, 아직 최신 메타 태그가 공식 지원되기 전에 먼저 써야 하는 상황에도 유용하답니다.\n\n---\n\n참고로 메타데이터는 검색 엔진 최적화(SEO), SNS 공유, 웹사이트의 기능 확장 등 다양한 용도로 활용되기 때문에, 어떤 메타 태그를 쓸지 꼼꼼하게 고민해보는 게 좋아요. 특히 Pinterest 같은 SNS 메타 태그는 이미지 노출과 관련된 중요한 역할을 하니까, 꼭 신경 써서 세팅해보시길 바랍니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 내용은 React나 Next.js 같은 프레임워크에서 메타 태그(metadata)를 설정하는 방법에 관한 거예요. 메타 태그는 웹페이지의 정보를 검색 엔진이나 브라우저에 알려주는 중요한 역할을 하죠.\n\n우선, `metadata` 객체에서 `other`라는 키로 커스텀 메타 태그를 정의할 수 있어요.\n\n```js\nexport const metadata = {\n  other: {\n    custom: 'meta',\n  },\n}\n```\n\n위 코드는 결국 HTML로 변환될 때 아래처럼 된다고 볼 수 있어요.\n\n```html\n\u003cmeta name=\"custom\" content=\"meta\" /\u003e\n```\n\n만약 같은 이름의 메타 태그를 여러 개 만들어야 한다면, 값에 배열을 넣으면 됩니다.\n\n```js\nexport const metadata = {\n  other: {\n    custom: ['meta1', 'meta2'],\n  },\n}\n```\n\n이렇게 하면 HTML에서는 다음과 같이 두 개의 메타 태그가 만들어져요:\n\n```html\n\u003cmeta name=\"custom\" content=\"meta1\" /\u003e\n\u003cmeta name=\"custom\" content=\"meta2\" /\u003e\n```\n\n---\n\n### 추가 팁!\n\n1. **메타 태그에 다양한 정보 넣기**  \n   `name`과 `content` 외에도 `http-equiv`나 `charset` 등의 속성도 있는데, 프레임워크 문서에서 지원하는 범위 내에서 활용해보세요.\n\n2. **여러 메타 태그 관리하기**  \n   SEO 최적화와 SNS 공유를 위한 `og:title`, `og:description`, `twitter:card` 같은 메타 태그도 함께 작성해야 한다면, `metadata` 객체 안에 따로 정의해놓고 관리하면 편리해요.\n\n3. **동적 메타 태그**  \n   만약 페이지마다 동적으로 메타 태그를 바꿔야 할 때는, 정적인 `export const metadata`뿐 아니라 React의 상태(state)나 훅을 사용해서 동적으로 설정하는 방법도 공부해보세요.\n\n메타 태그를 잘 활용하면 사용자 경험과 검색엔진에서의 가시성 모두 향상시킬 수 있으니, 꼭 챙겨서 활용해보시길 바랍니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n\u003cmeta name=\"custom\" content=\"meta1\" /\u003e \u003cmeta name=\"custom\" content=\"meta2\" /\u003e\n```\n\n## 지원하지 않는 메타데이터 유형\n\n아래 메타데이터 타입들은 현재 Next.js에서 내장 지원을 하지 않아요. 하지만 그렇다고 아예 사용할 수 없는 건 아니에요. 이런 메타 태그들은 레이아웃(layout)이나 개별 페이지 내부에서 직접 렌더링할 수 있습니다.\n\n| 메타데이터                    | 권장 방법                                                                                       |\n|------------------------------|------------------------------------------------------------------------------------------------|\n| `\u003cmeta http-equiv=\"...\"\u003e`     | `\u003cmeta http-equiv\u003e`는 HTTP 헤더 역할을 하는데, 여기서는 직접 태그 사용보다는 \u003ca href=\"/docs/app/api-reference/functions/redirect\"\u003e\u003ccode\u003eredirect()\u003c/code\u003e\u003c/a\u003e, \u003ca href=\"/docs/app/building-your-application/routing/middleware#nextresponse\"\u003e미들웨어\u003c/a\u003e, \u003ca href=\"/docs/app/api-reference/config/next-config-js/headers\"\u003e보안 헤더 설정\u003c/a\u003e 같은 방법으로 대응하는 걸 권장해요. |\n| `\u003cbase\u003e`                     | `\u003cbase\u003e` 태그는 레이아웃이나 페이지 컴포넌트 안에서 직접 렌더링하세요.                                |\n| `\u003cnoscript\u003e`                 | `\u003cnoscript\u003e` 태그 역시 레이아웃이나 페이지 내에서 렌더링하는 게 좋아요.                              |\n| `\u003cstyle\u003e`                   | Next.js에서 스타일을 적용하는 방법에 대해선 \u003ca href=\"/docs/app/building-your-application/styling/css\"\u003e여기\u003c/a\u003e서 확인해보세요.                         |\n| `\u003cscript\u003e`                  | 스크립트 사용에 관한 자세한 내용은 \u003ca href=\"/docs/app/building-your-application/optimizing/scripts\"\u003e이 문서\u003c/a\u003e에서 다룹니다.                          |\n| `\u003clink rel=\"stylesheet\" /\u003e`  | 스타일시트는 레이아웃 또는 페이지에서 직접 `import` 하여 적용하는 것을 권장합니다.                    |\n| `\u003clink rel=\"preload\" /\u003e`     | React에서 preload를 사용하려면 \u003ca href=\"#link-relpreload\"\u003eReactDOM preload 메서드\u003c/a\u003e를 활용하세요.           |\n| `\u003clink rel=\"preconnect\" /\u003e`  | 비슷하게 preconnect가 필요하면 \u003ca href=\"#link-relpreconnect\"\u003eReactDOM preconnect 메서드\u003c/a\u003e를 사용하세요.      |\n| `\u003clink rel=\"dns-prefetch\" /\u003e`| DNS 미리 조회가 필요할 때는 \u003ca href=\"#link-reldns-prefetch\"\u003eReactDOM prefetchDNS 메서드\u003c/a\u003e를 참고하면 됩니다.     |\n\n---\n\n### 조금 더 쉽게 이해하기\n\nNext.js가 내부적으로 지원하지 않는 태그들은 꼭 페이지나 레이아웃 컴포넌트에서 직접 넣어야 한다고 기억해 주세요. 그리고 `\u003cmeta http-equiv\u003e` 같은 헤더 관련 태그들은 서버 설정이나 Next.js의 자체 헤더 설정 기능으로 대체하는 편이 훨씬 안정적이고 최적화된 방법입니다.\n\n또한 CSS나 스크립트 같은 리소스들은 `import`나 Next.js에서 권장하는 관리 방식을 따르는 게 가장 좋은데요, 이렇게 하면 빌드 과정에서 최적화가 자연스럽게 따라와서 성능에 큰 도움이 된답니다.\n\n저도 처음에는 `\u003cstyle\u003e`이나 `\u003cscript\u003e`, `\u003cmeta\u003e` 태그 작성하는 게 익숙치 않았는데, 공식 문서들을 보면서 Next.js 스타일에 맞게 사용하는 방법을 익히니 프로젝트 관리가 훨씬 편해졌어요. 여러분도 Next.js와 함께라면 점점 더 깔끔하고 빠른 웹 앱을 만들 수 있을 거예요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 리소스 힌트(Resource hints)란?\n\n웹 페이지를 빠르게 불러오기 위해 브라우저에 외부 리소스가 곧 필요할 거라는 신호를 줄 수 있어요. 이때 사용하는 게 바로 `\u003clink\u003e` 태그의 `rel` 속성 키워드들이에요. 예를 들어, `preload`, `preconnect`, `dns-prefetch` 같은 것들이 있죠. 브라우저는 이 힌트를 받으면 미리 리소스를 준비해서 페이지 로딩 속도를 확 끌어올려준답니다.\n\n그런데 보통 이런 힌트는 메타데이터 API에 직접 포함하기 어려워요. 하지만 React에서 새롭게 제공하는 ReactDOM 메서드를 통해 문서의 `\u003chead\u003e`에 안전하게 이 힌트를 삽입할 수 있어요. 아래처럼 사용하면 되죠!\n\n```jsx\n'use client'\n\nimport ReactDOM from 'react-dom'\n\nexport function PreloadResources() {\n  ReactDOM.preload('https://example.com/script.js', { as: 'script' })        // 스크립트 미리 로드\n  ReactDOM.preconnect('https://fonts.googleapis.com', { crossOrigin: 'anonymous' }) // 사전에 서버 연결\n  ReactDOM.prefetchDNS('https://cdn.example.com')                          // DNS 조회 미리하기\n\n  return null\n}\n```\n\n#### 각 메서드가 하는 일 정리\n\n| 메서드             | 역할 설명                           | 자주 쓰는 용도                         |\n|------------------|---------------------------------|---------------------------------|\n| `ReactDOM.preload`    | 해당 리소스를 미리 다운로드해서 준비 | 스크립트, 스타일시트, 폰트 선로딩           |\n| `ReactDOM.preconnect` | 리소스를 제공하는 서버와 미리 연결       | 외부 폰트, API 서버 등 네트워크 연결 앞당기기    |\n| `ReactDOM.prefetchDNS`| 도메인 이름 해석(DNS 조회)을 미리해서 속도 향상 | 외부 CDN, API 서버 DNS 조회 시간 단축         |\n\n---\n\n### 추가 팁!\n\n- **preload**는 실제 리소스를 미리 다운받기 때문에, 정말 필요한 리소스에만 적용하는 게 좋아요. 너무 많이 사용하면 오히려 네트워크에 부담이 될 수 있거든요.\n- **preconnect**와 **prefetchDNS**는 리소스 요청 자체보다는 연결을 준비하는 단계라서 비용이 적은 편이에요. 많이 사용해도 크게 문제없지만 무조건 남발하는 건 피하는 게 좋아요.\n- React 18부터 ReactDOM에 이런 메서드가 생기면서, 서버 컴포넌트나 클라이언트 컴포넌트에서 동적으로 리소스 선로딩을 관리하기 훨씬 편해졌답니다.\n\n리소스 최적화가 생각보다 쉽지 않은데, 이런 기능으로 페이지 속도를 한층 끌어올려 보세요! 😊\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n웹 페이지를 렌더링하는 동안 리소스를 미리 불러오는 방법에 대해 알아볼게요. 조금 더 빠르게 페이지를 띄우고 싶을 때 유용한 팁입니다!\n\n---\n\n### React에서 리소스 미리 불러오기\n\nReact에서 `ReactDOM.preload` 함수를 사용하면, 특정 자원을 미리 로드할 수 있어요.\n\n```js\nReactDOM.preload(href: string, options: { as: string })\n```\n\n- `href`: 미리 불러올 리소스 URL\n- `options.as`: 리소스 타입(ex. `script`, `style`, `image` 등)\n\n이렇게 하면 해당 리소스가 실제로 필요할 때보다 훨씬 일찍 다운로드가 시작돼서, 렌더링 속도가 빨라져요.\n\n---\n\n### HTML `\u003clink rel=\"preload\"\u003e` 태그\n\n브라우저 표준으로 미리 불러오기 할 때는 `\u003clink\u003e` 태그를 사용해요.\n\n```html\n\u003clink rel=\"preload\" href=\"...\" as=\"...\" /\u003e\n```\n\n- `href`: 리소스 주소\n- `as`: 불러올 리소스 종류(ex. `script`, `style`, `image`, `font` 등)\n\n이 방법도 리소스를 빠르게 준비시키는 데 효과적입니다.\n\n---\n\n### 추가 팁: preconnect\n\n리소스를 미리 불러오기 전에, 네트워크 연결부터 미리 열어두는 방법도 있어요. `preconnect`를 사용하면 DNS 조회나 TLS 핸드쉐이크 같은 초기 연결 과정을 미리 수행해서 연결 시간을 줄일 수 있답니다.\n\n```html\n\u003clink rel=\"preconnect\" href=\"https://example.com\" /\u003e\n```\n\n이렇게 하면 브라우저가 해당 도메인과의 초기 연결을 미리 처리해줘서, 리소스를 실제로 요청할 때 더 빠르게 받을 수 있어요.\n\n---\n\n### 마무리\n\n- **preload**: 리소스 자체를 미리 다운로드 시작\n- **preconnect**: 해당 도메인과의 네트워크 연결을 미리 시작\n\n둘 다 적절히 활용하면, 페이지 로딩 시간 단축에 큰 도움이 돼요. 특히, 외부 CDN에서 스크립트나 폰트, 이미지 같은 무거운 리소스를 불러올 때 효과가 좋으니 참고하세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여러분, 웹 페이지를 좀 더 빠르게 로딩하고 싶을 때 사용할 수 있는 기술 중에 '프리커넥트(preconnect)'와 '프리페치(prefetch)'가 있어요. 이번 글에서는 React에서 해당 기능을 어떻게 활용할 수 있는지 간단하게 정리해볼게요.\n\n---\n\n### 1. Preconnect (도메인 미리 연결하기)\n\n웹 브라우저가 리소스를 요청하기 전에 DNS 조회, TCP 핸드셰이크, TLS 협상 등을 미리 처리하도록 하는 기능입니다. 쉽게 말해서 \"아, 곧 여기서 리소스를 받아올 거니까 미리 연결 준비 해둘게!\"라는 거죠.\n\nHTML에서는 보통 이렇게 사용해요:\n\n```html\n\u003clink rel=\"preconnect\" href=\"https://example.com\" crossorigin /\u003e\n```\n\nReact에서는 다음과 같이 사용할 수 있습니다:\n\n```js\nReactDOM.preconnect('https://example.com', { crossOrigin: 'anonymous' });\n```\n\n`crossOrigin` 옵션은 리소스가 CORS 정책에 따라 로드돼야 할 때 설정해주면 되고, 보통 `anonymous`나 `use-credentials` 중 하나를 골라 사용합니다.\n\n---\n\n### 2. Prefetch DNS (도메인 이름 해석 미리 하기)\n\n이건 조금 더 가볍게 DNS 조회만 미리 해두는 기능이에요. 브라우저가 도메인 주소를 미리 해석해서 나중에 리소스를 요청할 때 시간을 절약할 수 있죠.\n\nReact에서 이렇게 사용 가능해요:\n\n```js\nReactDOM.prefetchDNS('https://example.com');\n```\n\n---\n\n### 👉 왜 이런 기능들을 써야 할까?\n\n- **로딩 속도 개선**: 외부 리소스(이미지, 폰트, 스크립트 등)를 불러올 때 필요한 연결 과정을 미리 끝내서 사용자 체감 속도를 높일 수 있어요.\n- **경쟁 상태 완화**: 여러 리소스를 동시에 요청하는 상황에서 연결 비용을 줄여서 네트워크 경합을 줄여줍니다.\n\n---\n\n### 참고로 알아두면 좋은 점!\n\n- `preconnect`는 HTTPS, 크로스오리진 리소스에서 특히 효과적이에요.\n- 너무 많이 쓰면 오히려 오버헤드가 발생할 수 있으니 꼭 필요한 도메인에만 적용하세요.\n- `prefetchDNS`는 프리커넥트보다는 가벼운 작업입니다. 가능하면 `preconnect`를 먼저 고려하세요.\n\n---\n\n요즘은 React 자체에서 이런 네트워크 최적화 기능을 간편하게 지원해 준다는 점이 참 편리하고, 서버 사이드 렌더링(SSR) 환경이나 Next.js 같은 프레임워크에서도 적절히 활용하면 더욱 좋습니다.\n\n다음에는 실제 프로젝트에 적용하면서 생길 수 있는 팁이나 주의사항도 공유할게요! 궁금한 점 있으면 댓글로 남겨주세요~ 😊\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n\u003clink rel=\"dns-prefetch\" href=\"...\" /\u003e\n```\n\n\u003e 알아두면 좋은 점:  \n이 메서드들은 현재 클라이언트 컴포넌트에서만 지원됩니다. 하지만 초기 페이지 로드는 여전히 서버 사이드 렌더링으로 이루어집니다.  \nNext.js에 내장된 기능들(예: next/font, next/image, next/script)은 관련 리소스 힌트를 자동으로 처리해주니 참고하세요.\n\n## 타입 종류\n\n메타데이터에 타입 안정성을 추가하고 싶다면 `Metadata` 타입을 사용할 수 있습니다.  \nIDE에서 내장된 TypeScript 플러그인을 사용 중이라면 타입을 따로 명시할 필요는 없지만, 명시적으로 추가하고 싶다면 그렇게 해도 괜찮습니다.\n\n---\n\n### 추가 팁!  \n`dns-prefetch`는 브라우저가 DNS 조회를 미리 해두게 해서 첫 요청 시간을 줄여주는 역할이에요.  \n외부 리소스를 많이 사용하는 페이지에서는 이걸 적절히 활용하면 로딩 속도 체감에 큰 도움이 됩니다!  \n그리고 Next.js가 자동으로 대부분 처리해주긴 하지만, 커스텀 도메인이나 특수한 경우에는 직접 넣어줘야 할 수도 있어요.  \n\n---\n\n필요하면 저도 다음 글에서 `preconnect`, `prefetch`, `preload` 같은 리소스 힌트 비교와 함께 실제 사용법도 자세히 다뤄볼게요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### metadata 객체\n\n```js\nimport type { Metadata } from 'next'\n\nexport const metadata: Metadata = {\n  title: 'Next.js',\n}\n```\n\nNext.js에서 페이지에 메타데이터를 설정할 때 `metadata` 객체를 이렇게 정의할 수 있어요. 예를 들어, `title`을 지정해서 브라우저 탭에 표시되는 제목을 쉽게 바꿀 수 있죠. 정적으로 고정된 메타데이터가 필요할 때 주로 활용합니다.\n\n### generateMetadata 함수\n\n#### 일반 함수(Regular function)\n\ngenerateMetadata 함수는 동적으로 메타데이터를 생성할 때 사용하는데, 페이지가 렌더링되기 전에 호출돼서 필요한 정보를 가져오거나 계산해서 메타데이터를 만들 수 있답니다. 예를 들어, API에서 데이터를 불러와서 제목이나 설명을 동적으로 넣을 때 유용하죠.\n\n```js\nimport type { Metadata } from 'next'\nimport type { Params } from 'next/navigation'\n\nexport async function generateMetadata({ params }: Params): Promise\u003cMetadata\u003e {\n  const data = await fetch(`https://api.example.com/posts/${params.id}`)\n  const post = await data.json()\n\n  return {\n    title: post.title,\n    description: post.summary,\n  }\n}\n```\n\n\u003e 이렇게 하면 각 게시글마다 고유한 제목과 설명을 메타데이터에 넣을 수 있어 SEO에도 좋아요!\n\n\u003e 참고로, `generateMetadata`는 페이지가 서버에서 렌더링될 때만 동작하기 때문에, 클라이언트 사이드에서 동적으로 변경하는 메타데이터와는 목적이 조금 다르다는 점 기억해 주세요.\n\n요약하자면:  \n- **metadata 객체**는 정적인 메타데이터용  \n- **generateMetadata 함수**는 동적으로 메타데이터를 생성할 때 사용  \n\n다음에는 `generateMetadata`의 화살표 함수 버전이나 비동기 처리에 대해 또 얘기해볼게요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 `generateMetadata` 함수는 페이지 메타데이터(예: 제목, 설명 등)를 정의할 때 사용돼요. 이 함수는 동기 혹은 비동기 형태로 작성할 수 있는데, 어떤 차이가 있는지 한 번 살펴볼게요.\n\n---\n\n## 기본 동기 함수\n\n```js\nimport type { Metadata } from 'next'\n \nexport function generateMetadata(): Metadata {\n  return {\n    title: 'Next.js',\n  }\n}\n```\n\n여기서는 `generateMetadata`를 동기 함수로 정의했어요. 단순히 객체를 반환하니까, 렌더링 과정에서 바로 메타 데이터를 사용할 수 있죠. 페이지 제목만 간단히 설정할 때 유용해요.\n\n---\n\n## 비동기 함수 (Async)\n\n```js\nimport type { Metadata } from 'next'\n \nexport async function generateMetadata(): Promise\u003cMetadata\u003e {\n  return {\n    title: 'Next.js',\n  }\n}\n```\n\n메타데이터 생성에 API 호출이나 DB 조회 같은 비동기 작업이 필요할 땐, async 함수로 정의할 수 있어요. Promise를 반환하면 Next.js가 알아서 기다려 준답니다.\n\n---\n\n## 세그먼트 Props와 함께 사용하기\n\nNext.js에서는 라우트 세그먼트(예: `[slug]` 같은 동적 경로)의 정보를 `generateMetadata`에 넘겨줄 수 있어요. 이를 통해 각 페이지마다 맞춤 메타데이터 생성이 가능하죠.\n\n```ts\nimport type { Metadata } from 'next'\n\ntype Params = {\n  params: {\n    slug: string\n  }\n}\n\nexport function generateMetadata({ params }: Params): Metadata {\n  return {\n    title: `Post - ${params.slug}`,\n  }\n}\n```\n\n이렇게 하면 URL 경로에 따라 적절한 제목을 동적으로 설정할 수 있어 편리합니다.\n\n---\n\n### 요약 📌\n\n| 형태            | 특징                          | 사용 상황                       |\n|-----------------|-----------------------------|------------------------------|\n| 동기 함수       | 즉시 메타데이터 반환           | 간단한 메타데이터 설정           |\n| 비동기 함수     | Promise 반환, await 가능       | API 호출 등 비동기 로직 필요 시  |\n| 세그먼트 포함    | 라우트 파라미터 활용 가능       | 동적 경로에 따라 메타데이터 달리할 때 |\n\n---\n\nNext.js에서 메타데이터를 유연하게 다루는 방법, 어렵지 않죠? 페이지마다 맞춤형 SEO 설정을 할 때 이 기능을 꼭 활용해 보세요! 필요하면 next.js 공식 문서도 참고하면 도움이 많이 될 거예요. 😊\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n요즘 Next.js에서 메타데이터를 다루는 방법이 많이 바뀌었죠? 이번 글에서는 Next.js에서 메타데이터를 생성하고 사용하는 기본적인 방법과, 부모 메타데이터를 활용하는 방법까지 간단하게 살펴볼게요.\n\n---\n\n## 기본 메타데이터 생성하기\n\n아래 코드를 보시면 `generateMetadata`라는 함수를 정의해서 메타데이터를 리턴하고 있어요.\n\n```js\nimport type { Metadata } from 'next'\n \ntype Props = {\n  params: Promise\u003c{ id: string }\u003e\n  searchParams: Promise\u003c{ [key: string]: string | string[] | undefined }\u003e\n}\n \nexport function generateMetadata({ params, searchParams }: Props): Metadata {\n  return {\n    title: 'Next.js',\n  }\n}\n \nexport default function Page({ params, searchParams }: Props) {}\n```\n\n여기서 중요한 점은:\n\n- `generateMetadata` 함수가 `Metadata` 타입 객체를 반환한다는 것\n- 이 메타데이터는 페이지 렌더링 시 Next.js가 자동으로 HTML `\u003chead\u003e`에 넣어준다는 것\n\n`params`나 `searchParams`를 사용해 동적으로 메타데이터를 바꿀 수도 있어요.\n\n---\n\n## 부모 메타데이터와 합치기\n\nNext.js는 중첩된 레이아웃이나 페이지 구조를 지원하기 때문에, 상위 레이아웃에서 정의한 메타데이터와 병합해서 사용하는 경우가 많죠. 이런 경우엔 `generateMetadata` 함수에서 `parent`라는 인자를 받아서 처리할 수 있어요.\n\n```js\nimport type { Metadata, ResolvingMetadata } from 'next'\n \nexport async function generateMetadata(\n  { params, searchParams }: Props,\n  parent: ResolvingMetadata\n): Promise\u003cMetadata\u003e {\n  return {\n    title: 'Next.js',\n  }\n}\n```\n\n- `parent`는 상위 레이아웃이 전달하는 메타데이터를 포함한 객체라서, 이 데이터를 참고하거나 확장해서 메타데이터를 만들 수 있어요.\n- 보통 `async` 함수로 작성하는데, `parent` 메타데이터를 비동기로 받아오기 때문이에요.\n\n---\n\n## 자바스크립트 프로젝트에서 활용하기\n\n타입스크립트를 사용하지 않는 자바스크립트 프로젝트에서도 거의 같은 방식으로 사용할 수 있어요. 타입 선언 부분을 제외하면 되고, `generateMetadata` 함수만 잘 활용하면 되죠.\n\n```js\nexport async function generateMetadata({ params, searchParams }, parent) {\n  return {\n    title: 'Next.js',\n  }\n}\n```\n\n---\n\n### 추가 팁!\n\n- 메타데이터는 `title` 뿐만 아니라 `description`, `openGraph`, `icons` 등 다양한 속성을 설정할 수 있어요.\n- Next.js 13 이상부터 공식 지원하는 메타데이터 API라서, SEO나 SNS 공유 시 훨씬 효율적이에요.\n- 페이지나 레이아웃 단위로 메타데이터를 구분해서 작성하면 유지보수가 편해지니 꼭 활용해 보세요.\n\n---\n\n| 구분            | 설명                                                      |\n| --------------- | --------------------------------------------------------- |\n| `generateMetadata` | 페이지나 레이아웃에서 메타데이터를 생성하는 함수               |\n| `params`        | URL 파라미터 정보를 담고 있음                               |\n| `searchParams`  | URL 쿼리스트링 정보를 담고 있음                             |\n| `parent`        | 상위 레이아웃의 메타데이터 정보를 포함하는 객체 (비동기 가능) |\n\n---\n\n다음번에는 메타데이터 속성별 구체적 예시와 SEO에 어떻게 활용할 수 있는지 알려드릴게요. 필요하면 궁금한 점 편하게 질문해주세요! 😄\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nJavaScript 프로젝트에서 타입 안정성을 높이고 싶을 때, JSDoc을 활용할 수 있어요.\n\n```js\n/** @type {import(\"next\").Metadata} */\nexport const metadata = {\n  title: 'Next.js',\n}\n```\n\n위 예시는 Next.js 프로젝트에서 메타데이터 객체에 타입을 지정하는 방법이에요. 이렇게 하면 에디터에서 자동 완성도 지원되고, 실수로 메타데이터 키를 잘못 작성하는 실수를 줄일 수 있답니다.\n\n---\n\n## 스트리밍 메타데이터(Streaming metadata)\n\nNext.js에서 `generateMetadata` 함수가 반환하는 메타데이터는 클라이언트에게 스트리밍 방식으로 전송돼요. 즉, 메타데이터가 준비되는 즉시 HTML에 주입되기 때문에 페이지 로딩 속도나 SEO 측면에서 유리하답니다.\n\n이 방식 덕분에 페이지가 완전히 렌더링되기 전에 메타데이터가 미리 전달되면서 브라우저와 검색엔진이 올바른 정보를 빠르게 인식할 수 있어요.\n\n추가로, 스트리밍 방식 덕분에 대규모 프로젝트에서 메타데이터 처리도 효율적으로 수행되니, Next.js를 사용할 때 꼭 기억해두면 좋은 팁입니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n페이지 메타데이터는 주로 봇이나 크롤러를 대상으로 하기 때문에, Next.js는 JavaScript를 실행하고 전체 페이지 DOM을 검사할 수 있는 봇(예: Googlebot)에 대해 메타데이터를 스트리밍 방식으로 제공합니다. 하지만 메타데이터가 없으면 안 되는 HTML 제한 봇(예: Twitterbot)에게는 여전히 페이지 렌더링을 막는 블로킹 방식으로 메타데이터를 제공하게 됩니다. 이런 봇들은 크롤링할 때 JavaScript를 실행할 수 없기 때문이죠.\n\nNext.js는 자동으로 들어오는 요청의 유저 에이전트(User Agent)를 감지해서 스트리밍 메타데이터를 줄지, 아니면 블로킹 메타데이터를 줄지 판단합니다.\n\n그런데, 혹시 Next.js가 기본으로 인식하는 봇 리스트 외에 내가 원하는 봇을 따로 지정하고 싶다면, next.config.js 파일 안에 `htmlLimitedBots` 옵션을 써서 직접 정할 수 있어요. 이 옵션에 정규표현식 패턴으로 유저 에이전트를 지정하면, 일치하는 봇들은 페이지를 요청할 때 무조건 블로킹 메타데이터를 받게 됩니다.\n\n예를 들어, `MySpecialBot`, `MyAnotherSpecialBot`, `SimpleCrawler`라는 봇을 직접 지정하려면 이렇게 작성하면 됩니다:\n\n```js\nimport type { NextConfig } from 'next'\n\nconst config: NextConfig = {\n  htmlLimitedBots: 'MySpecialBot|MyAnotherSpecialBot|SimpleCrawler',\n}\n\nexport default config\n```\n\n### 추가로 알아두면 좋은 점!\n- 이 기능 덕분에 트위터 같은 JavaScript를 실행하지 못하는 봇들이 페이지 메타데이터를 제대로 받아갈 수 있어, 공유 시에 미리보기 정보가 깨지지 않아요.\n- `htmlLimitedBots` 옵션에 너무 많은 봇을 넣으면 서버 리소스가 더 소모될 수 있으니 꼭 필요한 봇만 추가하는 게 좋습니다.\n- Next.js 13 이상의 App Router에서 적용되는 중요한 설정이며, 메타데이터 처리 최적화를 통해 SEO와 소셜 공유 품질을 높이고 싶을 때 활용해보세요!\n\n필요한 봇 패턴을 유연하게 커스터마이징해서, 내 웹사이트가 다양한 봇 환경에서도 깔끔하게 잘 작동하도록 만드는 팁이었습니다 :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nhtmlLimitedBots 설정을 지정하면 Next.js의 기본 유저 에이전트(user agent) 리스트를 덮어쓰게 되어, 어떤 봇이 이 동작을 선택할지 완전히 제어할 수 있습니다. 이 기능은 다소 고급스러운 설정이므로, 대부분의 경우 기본값으로도 충분합니다.\n\n아래는 버전별 주요 변경사항입니다:\n\n| 버전       | 변경사항                                                                                                                   |\n|------------|----------------------------------------------------------------------------------------------------------------------------|\n| v15.2.0    | `generateMetadata`에 스트리밍 지원이 도입되었습니다.                                                                          |\n| v13.2.0    | `viewport`, `themeColor`, `colorScheme` 설정이 더 이상 권장되지 않고, 대신 [viewport 구성](https://nextjs.org/docs/app/api-reference/functions/generate-viewport) 방식으로 대체되었습니다.  |\n| v13.2.0    | `metadata`와 `generateMetadata` 기능이 새롭게 도입되었습니다.                                                                 |\n\n덧붙여서, Next.js에서 메타데이터 관련 기능들이 점점 세분화되고 발전하면서, 메타데이터를 동적으로 생성하거나 스트리밍하는 기능들도 지원하고 있어 SEO 최적화나 성능 향상에 도움을 줄 수 있답니다. 앞으로 최신 Next.js 기능을 다룰 때는 이런 변화들을 잘 활용해보시는 걸 추천드려요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":84},{"title":"Next.js 15에서 generateImageMetadata 함수 사용하는 방법","description":"","date":"2025-04-22 03:04","slug":"2025-04-22-generateImageMetadata","content":"\n\n# generateImageMetadata 함수 소개\n\n여러분, 이미지 메타데이터를 다룰 때 직접 하나하나 값을 하드코딩하기 귀찮거나, 여러 버전의 이미지를 한꺼번에 처리하고 싶었던 적 있으신가요? 바로 그럴 때 `generateImageMetadata` 함수를 활용하면 정말 편리해요!\n\n이 함수는 하나의 이미지를 다양한 버전으로 만들어내거나, 한 라우트 세그먼트에 여러 이미지를 반환할 수 있도록 도와줘요. 특히 아이콘 같이 자주 쓰이면서도 크기나 형식이 달라지는 이미지 작업에 아주 유용하답니다.\n\n## 파라미터 (Parameters)\n\n`generateImageMetadata` 함수에 넘겨줄 수 있는 주요 파라미터들은 아래와 같아요:\n\n| 파라미터 이름 | 설명 |\n| --- | --- |\n| `src` | 기본 이미지 경로 또는 URL (필수) |\n| `sizes` | 생성할 이미지 크기 배열 (예: `[16, 32, 64]`) |\n| `formats` | 생성할 이미지 형식 배열 (예: `['png', 'webp']`) |\n| `outputDir` | 변환 이미지가 저장될 디렉터리 경로 |\n| `quality` | 이미지 압축 품질 (0~100) |\n| `background` | 배경색 설정 (특히 투명하지 않은 이미지에 유용) |\n\n위 내용은 가장 기본적이고 자주 사용하는 옵션들을 포함하고 있어요. 이외에도 상황에 따라 추가 설정이 가능하니 공식 문서를 참고하면 더 깊이 이해할 수 있습니다.\n\n---\n\n### 실무에서 이렇게 활용해보세요!\n\n1. **아이콘 다양화**  \n   앱이나 웹사이트 내에서 동일한 아이콘을 크기별, 포맷별로 자동 생성해서 사용하면 코드가 더 깔끔해지고, 다양한 기기 대응이 쉬워져요.\n\n2. **SEO와 성능 최적화**  \n   다양한 해상도와 포맷(WebP 등)을 지원하면 사용자의 네트워크 환경이나 브라우저에 맞춰 최적화된 이미지를 제공할 수 있어, 페이지 로딩 속도와 SEO에 도움이 됩니다.\n\n다음번에는 이 함수를 실제 코드 예제와 함께 '어떻게 사용하는지' 자세히 다뤄볼게요! 질문이나 궁금한 점 있으면 언제든 댓글 남겨주세요 :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n#### params (선택 사항)\n\n`params`는 동적 라우트 매개변수를 포함하는 객체인데요, 이 객체는 루트 세그먼트에서부터 `generateImageMetadata` 함수가 호출된 세그먼트까지의 매개변수를 담고 있어요.\n\n예를 들어, 아래처럼 `generateImageMetadata` 함수에 `params`를 전달받을 수 있습니다.\n\n```js\nexport function generateImageMetadata({\n  params,\n}: {\n  params: { slug: string }\n}) {\n  // ...\n}\n```\n\n이때, 라우트와 URL, 그리고 `params`의 예시는 다음 표처럼 이해하시면 편해요.\n\n| Route                       | URL        | params              |\n|-----------------------------|------------|---------------------|\n| `app/shop/icon.js`           | `/shop`    | `undefined`         |\n| `app/shop/[slug]/icon.js`    | `/shop/1`  | `{ slug: '1' }`     |\n| `app/shop/[tag]/[item]/icon.js` | `/shop/1/2` | `{ tag: '1', item: '2' }` |\n\n즉, URL 경로에 따라 `params` 객체 안에 전달되는 키와 값이 달라지는 거죠.\n\n참고로, Next.js 같은 프레임워크에서는 이 `params`를 통해 동적으로 페이지를 구성할 때 유용하게 쓰여요. 특히 여러 단계의 동적 세그먼트가 있을 경우, 이 객체를 활용해 필요한 데이터를 가져오거나 메타데이터를 생성할 수 있답니다.\n\n또 한 가지 팁을 드리자면, `params`가 `undefined`인 경우도 있으니 함수 내에서 안전하게 처리해주는 게 좋아요! 예를 들면 다음과 같이요:\n\n```js\nexport function generateImageMetadata({ params }) {\n  const slug = params?.slug ?? 'default';\n  // slug를 안전하게 사용\n}\n```\n\n이렇게 하면 예상치 못한 에러를 방지할 수 있답니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 리턴값 설명\n\n`generateImageMetadata` 함수는 이미지 메타데이터를 담은 객체들의 배열을 반환해야 합니다. 여기서 각 객체는 이미지의 대체 텍스트(`alt`), 크기(`size`) 같은 정보를 포함하고 있어요. 그리고 꼭 포함해야 할 값 중 하나가 `id`인데, 이 값은 이미지 생성 컴포넌트에서 props로 전달받게 됩니다.\n\n아래는 반환하는 객체 구조를 간단히 정리한 표예요:\n\n| Image Metadata Object | Type                      |\n|----------------------|---------------------------|\n| `id`                 | `string` (필수)            |\n| `alt`                | `string`                   |\n| `size`               | `{ width: number; height: number }` |\n| `contentType`        | `string`                   |\n\n### 예제 코드\n\n```js\nimport { ImageResponse } from 'next/og'\n \nexport function generateImageMetadata() {\n  return [\n    {\n      contentType: 'image/png',\n      size: { width: 48, height: 48 },\n      id: 'small',\n    },\n    {\n      contentType: 'image/png',\n      size: { width: 72, height: 72 },\n      id: 'medium',\n    },\n  ]\n}\n \nexport default function Icon({ id }: { id: string }) {\n  return new ImageResponse(\n    (\n      \u003cdiv\n        style={{\n          width: '100%',\n          height: '100%',\n          display: 'flex',\n          alignItems: 'center',\n          justifyContent: 'center',\n          fontSize: 88,\n          background: '#000',\n          color: '#fafafa',\n        }}\n      \u003e\n        Icon {id}\n      \u003c/div\u003e\n    )\n  )\n}\n```\n\n---\n\n### 조금 더 설명을 덧붙이자면\n\n- `generateImageMetadata` 함수는 이미지가 다양할 때 각각에 맞는 메타정보를 한꺼번에 관리할 수 있어 편리합니다.\n- 각 이미지별 `id`는 컴포넌트에서 어떤 이미지를 렌더할지 구분하는 역할을 해요. 이 `id`를 이용해 동적으로 이미지 내용을 바꾸거나 다르게 스타일링할 수 있습니다.\n- `contentType`은 보통 이미지 포맷을 지정하는데, 예를 들어 `image/png`나 `image/jpeg` 등을 쓸 수 있어요.\n- `alt` 값은 UI 접근성을 높이기 위해 넣으면 좋습니다. 이미지 로딩 실패 시나 스크린 리더 사용자의 이해를 도와주니까요.\n\n그리고 스타일링 부분에서, 인라인 스타일에 중괄호 `{}`를 빼먹을 수 있는데 꼭 유의하세요! 예제 코드처럼 객체형태로 잘 감싸야 합니다.\n\n필요에 따라 더 다양한 메타데이터를 포함시켜 유연하게 확장하는 것도 추천드려요~!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 예제\n\n#### 외부 데이터를 활용한 이미지 생성\n\n이번 예제에서는 `params` 객체와 외부 데이터를 사용해 라우트 세그먼트에 대해 여러 개의 Open Graph 이미지를 생성하는 방법을 보여드릴게요.\n\n```js\nimport { ImageResponse } from 'next/og'\nimport { getCaptionForImage, getOGImages } from '@/app/utils/images'\n\nexport async function generateImageMetadata({\n  params,\n}: {\n  params: { id: string }\n}) {\n  const images = await getOGImages(params.id)\n\n  return images.map((image, idx) =\u003e ({\n    id: idx,\n    size: { width: 1200, height: 600 },\n    alt: image.text,\n    contentType: 'image/png',\n  }))\n}\n\nexport default async function Image({\n  params,\n  id,\n}: {\n  params: { id: string }\n  id: number\n}) {\n  const productId = (await params).id\n  const imageId = id\n  const text = await getCaptionForImage(productId, imageId)\n\n  return new ImageResponse(\n    (\n      \u003cdiv\n        style={\n          {\n            // ...\n          }\n        }\n      \u003e\n        {text}\n      \u003c/div\u003e\n    )\n  )\n}\n```\n\n---\n\n위 예제는 `params.id`를 기반으로 여러 Open Graph 이미지를 생성해주는 방식이에요. 먼저 `generateImageMetadata` 함수에서 외부 유틸 함수 `getOGImages`를 호출해 이미지 메타데이터들을 불러옵니다. 그리고 각각의 이미지를 원하는 크기와 alt 텍스트, 콘텐츠 타입과 함께 반환하죠.\n\n또한, 이미지 생성 함수 `Image`에서는 각각의 이미지 ID와 제품 ID를 받아서 해당 이미지에 들어갈 텍스트 캡션을 외부에서 가져와 렌더링합니다.\n\n\u003e 참고로 이런 방식을 사용하면 한 가지 라우트에 여러 OG 이미지를 동적으로 생성할 수 있어서, SNS에서 링크를 공유할 때 다양한 시각적 표현이 가능해집니다.  \n\u003e  \n\u003e 그리고 `ImageResponse`는 Next.js의 `next/og` 모듈에서 제공하는 기능으로, JSX를 기반으로 이미지를 그릴 수 있게 해줘요. 평소 HTML이나 React를 다루는 것처럼 편하게 이미지 레이아웃도 조절 가능하니 참 편리합니다.\n\n여기에 좀 더 스타일을 입히거나, 이미지 안에 다른 컴포넌트나 아이콘, 배경색 등을 넣어서 더욱 멋진 OG 이미지를 만들 수도 있겠네요. 이렇게 동적으로 메타데이터와 이미지를 생성하는 것은 SEO뿐만 아니라, 사용자 경험 향상에도 크게 도움을 줄 수 있습니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 버전 히스토리\n\n| 버전      | 변경 사항                       |\n|-----------|-------------------------------|\n| v13.3.0   | `generateImageMetadata` 기능 추가 |\n\n여기서 `generateImageMetadata`라는 기능이 새롭게 도입된 걸 확인할 수 있어요. 혹시 이미지 처리나 메타데이터 자동 생성과 관련된 작업을 한다면, 이 기능이 꽤 유용할 거예요. 나중에 직접 사용해보고 어떤 점이 좋은지, 어떻게 활용할 수 있는지도 다뤄볼게요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":8},{"title":"Next.js 15에서 Forbidden 에러 해결하는 방법","description":"","date":"2025-04-22 03:03","slug":"2025-04-22-forbidden","content":"\n\n# forbidden 함수 사용법과 설정 가이드\n\n안녕하세요! 오늘은 Next.js에서 권한 오류를 처리할 때 아주 유용한 `forbidden` 함수에 대해 알아볼게요. 이 함수는 권한이 없을 때 403 에러 페이지를 띄워주는데, 기본 제공 UI를 `forbidden.js` 파일로 직접 커스터마이징할 수도 있어서 유용하답니다.\n\n## forbidden 함수란?\n\n`forbidden` 함수는 사용자가 접근 권한이 없을 때 호출하면, Next.js가 자동으로 403 에러 페이지를 렌더링해 줍니다. 보통 로그인 상태나 권한 상태를 체크할 때 유용하게 쓸 수 있어요.\n\n## 설정 방법\n\n`forbidden` 함수를 쓰려면 먼저 `next.config.js`에서 실험적 기능인 `authInterrupts` 옵션을 활성화해야 합니다. 아래처럼 설정해 주세요:\n\n```js\nimport type { NextConfig } from 'next'\n\nconst nextConfig: NextConfig = {\n  experimental: {\n    authInterrupts: true,\n  },\n}\n\nexport default nextConfig\n```\n\n이 설정을 하면 `forbidden` 함수를 호출했을 때 Next.js가 자동으로 권한 부족 화면을 보여주게 됩니다.\n\n## forbidden.js로 UI 커스터마이징하기\n\n기본 403 화면 대신 회사나 프로젝트에 맞는 디자인으로 꾸미고 싶다면, 앱 루트에 `forbidden.js` 파일을 만들어서 커스텀 UI를 구현할 수 있어요.\n\n예를 들어:\n\n```jsx\nexport default function Forbidden() {\n  return (\n    \u003cdiv style={{ textAlign: 'center', padding: '2rem' }}\u003e\n      \u003ch1\u003e403 - 접근 금지\u003c/h1\u003e\n      \u003cp\u003e죄송합니다만, 이 페이지에 접근할 권한이 없습니다.\u003c/p\u003e\n      \u003cbutton onClick={() =\u003e window.location.href = '/login'}\u003e\n        로그인 페이지로 가기\n      \u003c/button\u003e\n    \u003c/div\u003e\n  )\n}\n```\n\n이런 식으로 친근한 UI를 만들어 놓으면 사용자 경험이 더 좋아질 거예요.\n\n## 팁: 권한 체크 로직과 연동하기\n\n실제로는 서버나 클라이언트에서 인증 정보를 확인한 후, 권한이 없으면 `forbidden()`을 호출하는 식으로 동작합니다. 예를 들어:\n\n```js\nimport { forbidden } from 'next/dist/server/api-utils'\n\nexport async function getServerSideProps(context) {\n  const user = await getUserFromSession(context.req)\n\n  if (!user || !user.hasAccess) {\n    throw forbidden()\n  }\n\n  return { props: { user } }\n}\n```\n\n이렇게 하면 권한이 없는 사용자에겐 자동으로 403 페이지가 렌더링됩니다.\n\n---\n\nNext.js에서 권한 관련 에러 처리를 깔끔히 하고 싶다면 `forbidden` 함수와 `authInterrupts` 설정을 적극 활용해 보세요. 기본 UI는 귀찮으면 그대로 써도 좋고, 필요하면 `forbidden.js`로 멋지게 꾸며 보시고요!\n\n필요한 내용 있으면 언제든 질문 남겨 주세요~ :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nnext.js에서 `forbidden` 함수는 Server Components, Server Actions, 그리고 Route Handlers 안에서만 호출할 수 있어요. 이 함수는 권한이 없는 사용자가 특정 페이지에 접근하려 할 때 간단하게 403 상태 코드를 반환하도록 도와주는데요, 예를 들어 관리자 페이지 같은 경우에 유용하게 사용할 수 있죠.\n\n아래 예시를 한번 보세요:\n\n```jsx\nimport { verifySession } from '@/app/lib/dal'\nimport { forbidden } from 'next/navigation'\n \nexport default async function AdminPage() {\n  const session = await verifySession()\n \n  // 사용자가 'admin' 역할인지 확인\n  if (session.role !== 'admin') {\n    forbidden() // 권한 없으면 403 에러를 발생시켜요.\n  }\n \n  // 권한이 있으면 관리자 페이지 렌더링\n  return \u003c\u003e\u003c/\u003e\n}\n```\n\n여기서 `verifySession()`은 사용자 세션을 확인하고, 세션에 포함된 `role` 정보를 바탕으로 권한 검사를 하게 됩니다. 만약 역할이 'admin'이 아니라면 `forbidden()` 함수를 호출해서 접근을 차단하는 거죠.\n\n### 알고 있으면 좋은 점\n- `forbidden` 함수는 루트 레이아웃(root layout)에서는 호출할 수 없어요. 루트 레이아웃에서 호출하면 에러가 발생하니 주의하세요.\n- `forbidden()` 이 호출되면 HTTP 상태 코드 403이 자동으로 반환되고, 페이지는 더 이상 렌더링되지 않습니다.\n- 이 방법은 클라이언트 사이드가 아닌 서버 사이드에서 권한 체크가 진행되기 때문에 보안적으로 훨씬 안전합니다.\n\n요약하면, Next.js에서 권한 제어를 할 때 서버 컴포넌트나 서버 액션, 라우트 핸들러에서 `forbidden()`을 이용해 간편하고 안전하게 접근을 제한할 수 있다는 점 기억하세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 예제\n\n### 역할(role) 기반 라우트 보호\n\n`forbidden` 함수를 사용하면 유저의 역할에 따라 특정 페이지 접근을 제한할 수 있어요. 인증은 되었지만 권한이 없는 사용자가 중요한 페이지에 들어오는 걸 막는 데 아주 유용하답니다.\n\n```js\nimport { verifySession } from '@/app/lib/dal'\nimport { forbidden } from 'next/navigation'\n\nexport default async function AdminPage() {\n  const session = await verifySession()\n\n  // 유저의 역할이 'admin'인지 확인하기\n  if (session.role !== 'admin') {\n    forbidden()  // 권한 없으면 접근 금지 처리\n  }\n\n  // 권한이 확인된 사용자에게 관리자 페이지 렌더링\n  return (\n    \u003cmain\u003e\n      \u003ch1\u003eAdmin Dashboard\u003c/h1\u003e\n      \u003cp\u003eWelcome, {session.user.name}!\u003c/p\u003e\n    \u003c/main\u003e\n  )\n}\n```\n\n---\n\n### 조금 더 설명을 덧붙이자면\n\n- `verifySession()` 같은 함수는 보통 로그인 상태와 사용자 정보를 서버에서 확인하는 역할을 해요.\n- `forbidden()`이 호출되면 Next.js가 자동으로 403 상태 코드를 반환하면서 페이지 렌더링을 막아요.\n- 이 구조를 응용하면 관리자뿐만 아니라 일반 회원, VIP 등 다양한 권한 기반 페이지 구성이 깔끔하게 가능하답니다.\n- 클라이언트 쪽이 아니라 서버 사이드에서 권한 검사를 하기에 보안도 한층 강해지죠.\n\n이런 식으로 `forbidden()`을 적절히 써서 중요한 페이지에 사용자 권한을 확실히 적용할 수 있답니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### Server Actions에서의 Mutation 사용하기\n\n서버 액션(Server Actions)으로 뮤테이션(mutation)을 구현할 때, 민감한 데이터를 업데이트하는 작업은 꼭 특정 권한이 있는 사용자만 할 수 있도록 제한하는 게 중요해요. 예를 들어, 관리자(admin)만 역할(role)을 변경할 수 있게 막는 방법을 살펴볼게요.\n\n```js\n'use server'\n\nimport { verifySession } from '@/app/lib/dal'\nimport { forbidden } from 'next/navigation'\nimport db from '@/app/lib/db'\n\nexport async function updateRole(formData: FormData) {\n  const session = await verifySession()\n\n  // 관리자만 역할 변경 권한을 부여\n  if (session.role !== 'admin') {\n    forbidden()\n  }\n\n  // 권한 확인 후 역할 업데이트 로직 수행\n  // ...\n}\n```\n\n여기서 중요한 건 `verifySession()` 함수를 통해 현재 사용자의 세션 정보를 받아와서, 역할(role)이 'admin'인지 확인하는 부분이에요. 만약 관리자가 아니라면, `forbidden()` 함수를 호출해서 접근을 막아요. 이 함수는 Next.js의 내비게이션에서 권한을 제한할 때 쓰이는 함수로, 권한이 없으면 클라이언트에 적절한 에러 페이지를 보여줍니다.\n\n---\n\n### 덧붙여서!\n\n- **세션 검증은 꼭 서버에서!**  \n  세션이나 권한 체크 등 보안과 관련된 로직은 클라이언트가 아니라 서버에서 처리해야 안전합니다.\n\n- **forbidden() 외 에러 처리**  \n  상황에 따라서는 `forbidden()` 대신 직접 403 응답을 커스텀할 수도 있지만, Next.js 내장 함수 사용이 더 간편하고 안전하죠.\n\n- **코드 구조 고민하기**  \n  `updateRole` 같은 함수는 재사용성, 테스트 용이성 측면에서 최대한 작게, 명확하게 작성하는 게 좋아요.\n\n- **db 연동**  \n  주석 처리된 부분에는 실제 데이터베이스 업데이트 로직을 넣으면 되는데, 예를 들어 Prisma 같은 ORM을 사용한다면, `db.user.update()` 같은 함수를 호출해서 처리할 수 있어요.\n\n서버 액션에서 뮤테이션을 처리할 때 권한 체크를 깔끔하게 하는 방법, 참고가 되었으면 좋겠습니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 위의 HTML table 태그를 Markdown 형식으로 바꾼 내용입니다.\n\n| Version   | Changes                   |\n|-----------|---------------------------|\n| `v15.1.0` | `forbidden` introduced.   |\n\n여기서 `forbidden`이라는 새 기능이 v15.1.0 버전에 추가됐다고 하는데요, 보통 이런 변화는 특정 상황에서 접근을 제한하거나 권한을 관리할 때 활용되곤 합니다. 만약 여러분이 API나 설정에서 권한 관련 처리를 한다면, `forbidden` 옵션이 어떤 역할을 하는지 한번 체크해보는 것도 좋겠네요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":7},{"title":"Nextjs 15에서 draftMode 기능 사용하는 방법","description":"","date":"2025-04-22 03:02","slug":"2025-04-22-draftMode","content":"\n\n# draftMode\n\n이번에 소개할 기능은 Next.js에서 제공하는 `draftMode`라는 async 함수입니다. 이 함수는 서버 컴포넌트(Server Component) 내에서 Draft Mode를 켜고 끌 수 있게 해주고, 현재 Draft Mode가 활성화되어 있는지도 확인할 수 있어요.\n\n```js\nimport { draftMode } from 'next/headers'\n\nexport default async function Page() {\n  const { isEnabled } = await draftMode()\n  // isEnabled가 true면 Draft Mode가 활성화된 상태,\n  // false면 비활성화 상태입니다.\n}\n```\n\n## Draft Mode란?\n\nNext.js에서 Draft Mode는 관리자나 콘텐츠 작성자가 실제 공개된 페이지와는 별개로 콘텐츠를 미리보기하거나 테스트할 때 유용합니다. 보통 CMS(Content Management System)와 연동해서, 아직 퍼블리시되지 않은 글이나 변경사항을 미리 볼 때 많이 활용되죠.\n\n## draftMode 함수 주요 기능\n\n- **활성화**: Draft Mode 켜기\n- **비활성화**: Draft Mode 끄기\n- **상태확인**: 현재 Draft Mode가 켜져 있는지 확인\n\n### 예를 들어 Draft Mode를 켜고 끄는 방법\n\n아래처럼 `enable()`과 `disable()` 메서드를 쓸 수 있어요.\n\n```js\nimport { draftMode } from 'next/headers'\n\nexport default async function Page() {\n  const draft = await draftMode()\n\n  // Draft Mode 활성화\n  draft.enable()\n\n  // Draft Mode 비활성화 (필요시)\n  // draft.disable()\n\n  const { isEnabled } = await draftMode()\n  console.log('Draft Mode 활성화 여부:', isEnabled)\n}\n```\n\n## 참고할 점\n\n- `draftMode()`는 서버 컴포넌트에서만 쓸 수 있습니다. 클라이언트 컴포넌트에서는 동작하지 않아요.\n- 주로 CMS와 함께 사용해, 콘텐츠 미리보기를 간단하게 구현할 때 유용합니다.\n- Draft Mode가 켜져 있으면, 예를 들어 API 요청 시 비공개 상태인 콘텐츠도 가져오도록 설정할 수 있죠.\n\n요즘 Next.js가 점점 서버 기능과 콘텐츠 관리 기능을 강화하는데, Draft Mode는 그 중에서도 굉장히 실용적인 기능이니 꼭 한번 써보시길 추천합니다!  \n\n---\n\n## Reference\n\n- [Next.js Documentation - draftMode](https://nextjs.org/docs/app/building-your-application/configuration/draft-mode) (공식 문서 링크)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음은 Draft Mode에서 사용할 수 있는 메서드와 프로퍼티들입니다:\n\n| 메서드         | 설명                                                         |\n| -------------- | ------------------------------------------------------------ |\n| `isEnabled`    | Draft Mode가 활성화되어 있는지 여부를 나타내는 boolean 값입니다. |\n| `enable()`     | Route Handler에서 Draft Mode를 활성화하며, 이때 `__prerender_bypass` 쿠키를 설정합니다. |\n| `disable()`    | Route Handler에서 Draft Mode를 비활성화하며, 쿠키를 삭제합니다. |\n\n---\n\n## 알아두면 좋은 팁\n\n- `draftMode` 함수는 비동기 함수로, Promise를 반환합니다. 따라서 `async/await`를 사용하거나 React의 `use` 함수를 사용해야 해요.  \n  예전(Next.js 14버전 이하)에는 `draftMode`가 동기 함수였는데, 15버전에서는 하위 호환성을 위해 동기 접근도 가능하지만 곧 Deprecated될 예정입니다.\n\n- `next build`를 할 때마다 새로운 우회 쿠키 값이 생성되기 때문에, 이 쿠키 값을 예측하기 어렵습니다. 보안 측면에서 좋은 변화죠!\n\n- 로컬에서 Draft Mode를 HTTP로 테스트할 때는 브라우저 설정에서 **서드파티 쿠키 허용** 및 **로컬 스토리지 접근 허용**이 필요하니 참고하세요.\n\n---\n\n### 좀 더 자세한 설명!\n\n`Draft Mode`는 쉽게 말해 \"임시 저장\" 모드 같은 개념인데요, 보통은 빌드된 정적 페이지를 보여주지만, 이 모드를 켜면 실시간으로 수정 중인 데이터를 확인할 수 있어 개발할 때 정말 유용합니다. 예를 들어, CMS에서 콘텐츠를 수정하며 바로바로 결과를 확인하고 싶을 때 많이 쓰이죠.\n\n`enable()`을 호출하면 내부적으로 `__prerender_bypass`라는 쿠키가 설정되고, Next.js 서버는 이 쿠키를 보고 캐시된 정적 파일 대신 최신 서버 데이터를 반환합니다. 그리고 개발이 끝났으면 `disable()`을 호출해서 쿠키를 삭제해 다시 캐싱된 페이지를 보여주도록 해요.\n\n마지막으로, 비동기 함수라는 점을 꼭 주의하세요. Next.js가 점점 비동기 패턴을 밀고 있기 때문에, 예전처럼 동기적으로 호출하면 버그가 날 수 있으니 async/await 사용을 권장합니다.\n\n이 글이 Draft Mode를 이해하는 데 도움이 됐길 바라요! 개발하면서 궁금한 점 있으면 언제든 물어보세요~\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 예제\n\n### Draft Mode 활성화하기\n\nDraft Mode를 사용하려면 새로운 Route Handler를 만들고 `enable()` 메서드를 호출하면 돼요. 이렇게 하면 임시로 수정 중인 내용을 확인할 수 있답니다.\n\n```js\nimport { draftMode } from 'next/headers'\n\nexport async function GET(request: Request) {\n  const draft = await draftMode()\n  draft.enable()\n  return new Response('Draft mode is enabled')\n}\n```\n\n---\n\n### 조금 더 설명하자면?\n\n`draftMode()` 함수는 현재 요청에서 Draft Mode의 상태를 제어할 수 있는 객체를 반환해줘요. 그 객체의 `enable()` 메서드를 호출하면 그 사용자의 세션에 Draft Mode가 활성화돼서, 보통은 비공개로 관리되는 수정 중인 콘텐츠들을 볼 수 있게 되죠.\n\n예를 들어, 컨텐츠 수정 중인 페이지를 실시간으로 확인하고 싶을 때 엄청 편리해요. 반대로 `disable()` 메서드를 호출하면 Draft Mode가 해제됩니다.\n\nNext.js를 사용 중이라면 이 기능을 활용해서 콘텐츠 검수나 개발 중인 기능 확인도 쉽게 할 수 있으니, 꼭 한 번 써보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### Draft Mode 끄기\n\n기본적으로 Draft Mode는 브라우저를 닫으면 세션이 종료돼요.\n\n하지만 직접 Draft Mode를 끄고 싶다면, Route Handler 안에서 `disable()` 메서드를 사용하면 돼요. 예를 들어:\n\n```js\nimport { draftMode } from 'next/headers'\n\nexport async function GET(request: Request) {\n  const draft = await draftMode()\n  draft.disable()\n  return new Response('Draft mode is disabled')\n}\n```\n\n이렇게 하면 현재 세션에서 Draft Mode가 비활성화돼서, 더 이상 임시 콘텐츠나 수정된 내용을 확인할 수 없게 돼요.\n\n여기서 한 가지 팁! 보통 Draft Mode는 테스트나 미리보기용으로 많이 쓰이니, 실제 서비스에선 잘 꺼두는 게 좋아요. Draft Mode가 켜진 상태에서는 캐싱이나 일부 기능이 동작하지 않을 수 있으니까요.\n\n참고로, Next.js의 `draftMode()`는 클라이언트-서버 환경 모두에서 사용 가능해, 서버에서 조건에 따라 쉽게 Draft Mode를 켜고 끌 수 있다는 점도 기억해두세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여러분, Next.js에서 Route Handler를 호출할 때 주의할 점이 있어요! 만약 `Link` 컴포넌트를 이용해서 라우트를 호출한다면, `prefetch='false'`를 꼭 넘겨줘야 해요. 이걸 안 하면 prefetch 과정에서 쿠키가 의도치않게 삭제될 수 있거든요. \n\n---\n\n### Draft Mode가 켜져 있는지 확인하는 방법\n\n서버 컴포넌트(Server Component)에서 Draft Mode가 활성화되어 있는지 확인하고 싶을 때는, `next/headers` 모듈의 `draftMode` 함수를 사용하면 돼요. 이 함수는 `isEnabled`라는 프로퍼티를 반환하는데, 이걸 통해 현재 Draft Mode 상태를 알 수 있죠.\n\n아래 코드를 한 번 보세요:\n\n```js\nimport { draftMode } from 'next/headers'\n\nexport default async function Page() {\n  const { isEnabled } = await draftMode()\n  return (\n    \u003cmain\u003e\n      \u003ch1\u003eMy Blog Post\u003c/h1\u003e\n      \u003cp\u003eDraft Mode is currently {isEnabled ? 'Enabled' : 'Disabled'}\u003c/p\u003e\n    \u003c/main\u003e\n  )\n}\n```\n\n이렇게 하면 페이지를 렌더링할 때 Draft Mode가 켜져 있는지 바로 확인할 수 있어요. \n\n\u003e 팁 하나 더! Draft Mode는 예를 들어 컨텐츠를 작성하거나 수정할 때 유용해요. 실제로 배포된 최종 버전에 반영되기 전에 미리 볼 수 있게 해주는 기능이라, 가끔 이 상태가 켜져 있는지 확인해 보는 것이 중요하답니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 버전 히스토리\n\n| 버전           | 변경사항                                                                                 |\n| -------------- | ---------------------------------------------------------------------------------------- |\n| `v15.0.0-RC`   | `draftMode`가 이제 비동기 함수(async function)로 변경되었습니다. 관련 [코드모드(codemod)](/docs/app/guides/upgrading/codemods#150)도 제공 중이에요. |\n| `v13.4.0`      | `draftMode` 기능이 처음 도입되었습니다.                                                  |\n\n---\n\n여기서 잠깐! `draftMode`라는 기능이 뭔지 궁금하신 분들도 계실텐데요, 쉽게 말해서 Next.js에서 \"초안 모드\"처럼 작동해서 페이지가 캐시되지 않고 항상 최신 상태를 유지하도록 도와주는 기능이에요. 특히 서버사이드 렌더링하거나 ISR(Incremental Static Regeneration)을 사용할 때 실시간 업데이트가 필요할 때 유용하답니다.\n\n그리고 `v15.0.0-RC`부터는 이 `draftMode` 함수가 async로 바뀌면서, 내부에서 비동기 작업이 가능해졌어요. 만약 이전 버전에서 사용 중이라면 코드 모드를 통해 자동으로 변환할 수 있으니 큰 걱정 하지 않아도 됩니다! \n\nNext.js 같은 프레임워크가 계속 발전하면서 이런 세세한 변경사항도 꼭 챙겨 두시는 게 좋아요. 개발할 때 버전별 차이로 헷갈리는 일이 줄어들 거예요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":8},{"title":"Next.js 15에서 fetch API 활용하는 최신 방법","description":"","date":"2025-04-22 03:02","slug":"2025-04-22-fetch","content":"\n\n# fetch\n\nNext.js에서는 기본 웹 fetch() API를 확장해서, 서버에서 각 요청마다 고유한 지속 캐싱(persistent caching)과 재검증(revalidation) 규칙을 설정할 수 있도록 했어요.\n\n브라우저에서는 fetch 요청 시 cache 옵션이 브라우저 HTTP 캐시와 어떻게 상호작용할지를 지정하잖아요? 그런데 Next.js의 확장된 fetch에서는 서버 사이드에서 할 때 이 cache 옵션이 프레임워크가 관리하는 지속 데이터 캐시(persistent Data Cache)와 어떻게 상호작용할지를 결정해줘요.\n\n즉, 서버 컴포넌트 안에서 async/await와 함께 그냥 fetch를 호출해도, 이 캐시 전략들이 작동하면서 성능 향상 및 데이터 최신성을 관리해준다는 뜻이에요.\n\n---\n\n### 추가 설명\n\n- **지속 데이터 캐시란?**  \n  서버에서 한 번 가져온 데이터를 일정 시간 동안 저장해서, 같은 데이터를 재요청할 때 네트워크 호출을 줄여주는 역할을 해요. 그래서 유저 입장에선 페이지가 더 빨리 로드되고, 서버 부담도 줄어들죠.\n\n- **재검증(revalidation)이 뭐예요?**  \n  캐시된 데이터가 오래되었는지 주기적으로 체크해서, 최신 데이터가 필요하면 다시 fetch를 하는 거예요.\n\n- **서버 컴포넌트에서 fetch를 쓴다?**  \n  Next.js 13부터 도입된 서버 컴포넌트 덕분에, 서버에서 비동기적으로 데이터를 패칭하고 바로 렌더링할 수 있어요. 클라이언트에서 데이터 로딩 처리하는 걸 줄일 수 있죠.\n\n---\n\n### 예시 코드\n\n```jsx\n// 서버 컴포넌트 내에서 fetch 사용\nexport default async function Page() {\n  const res = await fetch('https://api.example.com/data', {\n    cache: 'force-cache'  // 고정된 캐시 전략 적용\n  });\n  const data = await res.json();\n\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003e서버에서 가져온 데이터\u003c/h1\u003e\n      \u003cpre\u003e{JSON.stringify(data, null, 2)}\u003c/pre\u003e\n    \u003c/div\u003e\n  )\n}\n```\n\nNext.js의 fetch API 확장 덕분에 서버 쪽 데이터 요청을 더 똑똑하게 관리할 수 있으니, 다음 프로젝트에 꼭 활용해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여러분, Next.js에서 데이터를 불러오는 방법에 대해 이야기해볼게요. 위에 있는 코드를 보시면, `fetch` 함수로 외부 API에서 데이터를 받아와서 화면에 포스트 리스트를 렌더링하는 아주 기본적인 예제입니다.\n\n```jsx\nexport default async function Page() {\n  let data = await fetch('https://api.vercel.app/blog')\n  let posts = await data.json()\n  return (\n    \u003cul\u003e\n      {posts.map((post) =\u003e (\n        \u003cli key={post.id}\u003e{post.title}\u003c/li\u003e\n      ))}\n    \u003c/ul\u003e\n  )\n}\n```\n\n### Next.js의 fetch() API 활용\n\nNext.js는 기본적으로 웹의 `fetch()` API를 확장해서 제공하는데요, 그래서 우리가 익숙한 `fetch` 옵션들을 그대로 사용할 수 있다는 점이 편리해요. 이번에 살펴볼 옵션 중 하나가 `cache` 옵션입니다.\n\n### `options.cache`\n\n`cache` 옵션은 데이터를 어떻게 캐싱할지를 결정하는 역할을 해요. 예를 들어, 기본적으로는 서버 컴포넌트에서 데이터를 패칭할 때 `cache`가 적용되어, 다음에 같은 요청이 오면 캐시된 데이터를 바로 사용할 수 있도록 돼 있죠. 이걸 조절하면, 실시간 데이터가 중요하거나, 너무 자주 데이터를 갱신할 필요가 있을 때 유용해요.\n\n- `\"default\"`: 기본 캐싱 정책을 따릅니다.\n- `\"no-cache\"`: 매번 네트워크에서 새 데이터를 받아옵니다.\n- `\"force-cache\"`: 캐시된 데이터만 사용하고 네트워크 요청은 안 합니다.\n- `\"only-if-cached\"`: 캐시된 데이터가 없으면 실패합니다.\n\n예를 들어, 이렇게 쓸 수 있어요:\n\n```js\nlet data = await fetch('https://api.vercel.app/blog', { cache: 'no-cache' })\n```\n\n이렇게 하면 무조건 최신 데이터를 받아오기 때문에, 실시간 뉴스나 가격 정보처럼 자주 업데이트되는 데이터에 적합합니다.\n\n---\n\n### 한 가지 꿀팁!\n\nNext.js 13부터는 `fetch`에 `next` 옵션도 함께 쓸 수 있는데요, 굉장히 강력합니다. 예를 들어 `next: { revalidate: 10 }` 옵션을 넣으면, 데이터를 받아와서 10초마다 캐시를 리프레시하도록 할 수 있어요. 이렇게 하면 서버 부하도 줄이고, 사용자는 어느 정도 최신 데이터를 볼 수 있죠.\n\n```js\nlet data = await fetch('https://api.vercel.app/blog', {\n  next: { revalidate: 10 }\n})\n```\n\n한마디로, 여러분 프로젝트 상황에 맞게 캐시 전략을 유연하게 조절해 보세요. 그럼 데이터 패칭도 똑똑하게 할 수 있답니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 요청이 데이터 캐시와 어떻게 상호작용할지 설정하는 방법에 대해 설명해드릴게요.\n\n```js\nfetch(`https://...`, { cache: 'force-cache' | 'no-store' })\n```\n\n여기서 cache 옵션은 세 가지 주요 상태가 있어요:\n\n| 옵션          | 동작 설명                                                                                           |\n|---------------|---------------------------------------------------------------------------------------------------|\n| auto (기본값) | 개발 환경에서는 매 요청마다 원격 서버에서 데이터를 가져와요. 하지만 빌드 시점에 페이지가 정적으로 사전 렌더링되면 그때 한 번만 가져와요. 그리고 동적 API가 감지되면 매 요청마다 데이터를 가져오죠. |\n| no-store      | 동적 API 여부와 상관없이 항상 매 요청마다 원격 서버에서 데이터를 가져와요. 캐시를 사용하지 않는 느낌이에요.                    |\n| force-cache   | Next.js의 데이터 캐시에서 일치하는 요청이 있는지 찾아요. ‘신선한’ 캐시가 있으면 캐시에서 바로 반환하고, 없거나 오래된 캐시라면 원격 서버에서 새로 데이터를 받아와 캐시를 업데이트해요.  |\n\n### 추가 꿀팁!\n\n- 캐시가 ‘신선한(fresh)’하다는 말은 캐시된 데이터가 아직 유효하다는 뜻이에요. 이를 판단하는 기준은 Next.js 내부 정책이나 `revalidate` 옵션에 따라 달라집니다.\n- `force-cache`를 사용하면 빌드 시점의 데이터를 최대한 활용하면서도, 변경사항이 있을 때만 서버에서 최신 데이터를 받을 수 있어서 효율적이에요.\n- 개발 중에는 기본 `auto` 모드가 편리하지만, 프로덕션 환경에서는 상황에 맞게 `no-store` (실시간 업데이트 필요 시)나 `force-cache` (최소한의 요청으로 성능 최적화 시)를 선택하는 게 좋아요.\n\n### options.next.revalidate\n\n이 옵션은 캐시를 갱신하는 주기를 설정할 때 쓰입니다. 예를 들어, \n\n```js\nfetch('https://...', { next: { revalidate: 60 } })\n```\n\n이렇게 설정하면, 캐시된 데이터가 60초가 지나면 다음 요청 때 새로 갱신해요. 다시 말해, 1분마다 데이터를 새로고침하는 것과 같죠.\n\n이걸 적절히 활용하면 새로 고침의 빈도와 SEO 최적화를 균형 있게 맞출 수 있습니다.\n\n---\n\nNext.js의 데이터 캐시는 페이지 성능과 사용자 경험에 큰 영향을 주니, 개발 환경과 서비스 특성에 맞게 잘 설정해 보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nfetch 함수에 `next: { revalidate: ... }` 옵션을 주면 리소스의 캐시 수명을 초 단위로 설정할 수 있어요. 쉽게 말해, 캐시가 얼마 동안 유지될지 정하는 거죠. 이 옵션에 따라 캐싱 동작이 달라집니다.\n\n| revalidate 값 | 의미                                                         |\n|---------------|--------------------------------------------------------------|\n| false         | 리소스를 무한정 캐시해요. (사실상 revalidate: Infinity와 같아요.) HTTP 캐시는 오랫동안 쓰다가 오래된 캐시를 지울 순 있지만, 기본적으로 무제한으로 저장합니다. |\n| 0             | 캐시를 절대 하지 않아요. 항상 리소스를 새롭게 받아옵니다.       |\n| number        | 숫자(초)만큼 캐시 생명주기를 정해요. 예를 들어 60이면 60초간 캐시 유지. |\n\n### 좀 더 알아두면 좋은 점\n\n- 특정 fetch 요청에서 설정한 `revalidate` 값이 라우트(route) 기본 값보다 작으면, 라우트 전체의 리밸리데이트 간격도 그만큼 줄어듭니다.\n- 같은 URL을 가진 두 개의 fetch 요청이 각각 다른 `revalidate` 값을 가지고 있다면, 더 짧은 시간(낮은 값)이 적용됩니다.\n- `revalidate`를 숫자로 주면 따로 `cache` 옵션을 설정하지 않아도 돼요.\n- `revalidate`와 `cache` 옵션이 모순되는 설정(예: `revalidate: 3600`인데 `cache: 'no-store'`)을 하면 에러가 발생해요.\n\n### 참고로,\n이 옵션은 Next.js에서 제공하는 기능으로, 서버 측 데이터 패칭 시 자동으로 ISR(Incremental Static Regeneration)을 조절하는데 유용합니다. 개발할 때 캐시 정책을 유연하게 조절하면, 페이지 성능과 최신성 사이에서 좋은 균형을 맞출 수 있어요.\n\n혹시 어떻게 쓰는지 구체적인 예시가 궁금하다면 알려주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### options.next.tags\n\n```js\nfetch(`https://...`, { next: { tags: ['collection'] } })\n```\n\n`options.next.tags`는 요청에 캐시 태그(cache tags)를 설정하는 옵션이에요. 캐시 태그를 지정해두면, 나중에 `revalidateTag` API를 사용해서 해당 태그가 붙은 데이터만 선택적으로 갱신할 수 있답니다. 이렇게 하면 불필요하게 전체 데이터를 다시 받아오지 않아도 되니까 성능 최적화에 큰 도움이 되죠.\n\n- **태그 길이 제한**: 각 태그는 최대 256자까지만 작성할 수 있어요.\n- **태그 개수 제한**: 한 요청당 최대 128개의 태그를 설정할 수 있어요.\n\n---\n\n### 추가 팁!\n\n`revalidateTag`를 사용하면 페이지나 일부 컴포넌트에서 특정 태그를 기반으로 데이터를 갱신할 수 있어서 리얼타임 데이터 반영이나, 변경이 잦은 부분만 업데이트할 때 매우 유용해요.\n\n예를 들어, 쇼핑몰에서 ‘상품 컬렉션(collection)’ 태그를 붙인 데이터만 따로 갱신하고 싶을 때 편리하겠죠? 커스텀 태그를 잘 활용해서 앱 성능과 사용자 경험을 한층 개선해 보세요! \n\n---\n\n## 문제 해결 (Troubleshooting)\n\n| 문제 상황                        | 해결 방법                                 |\n|-------------------------------|----------------------------------------|\n| 태그가 너무 길 때               | 태그 길이를 256자 이내로 줄이세요.        |\n| 태그 개수가 128개를 초과할 때   | 필요 없는 태그를 제거하거나 그룹화하세요. |\n| 데이터가 갱신되지 않을 때       | `revalidateTag`가 올바르게 호출되었는지 확인하세요. |\n| 캐시가 정상 동작하지 않을 때   | fetch 옵션과 캐시 정책을 다시 점검해보세요.   |\n\n혹시 캐시 관련해서 더 궁금한 점이나, 특정 상황에서 어떻게 활용하면 좋은지 알고 싶다면 언제든 질문해 주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### Fetch 기본 자동 no-store와 캐시: `no-store`가 개발 환경에서 최신 데이터를 보여주지 않는 이유\n\nNext.js에서 개발할 때, 특히 **Server Components**를 사용할 때 조금 특이한 캐싱 동작이 있어요. 바로 HMR(Hot Module Replacement) 과정에서 fetch 응답을 캐시에 저장한다는 점입니다. 이 덕분에 빠른 응답 속도와 함께, API 호출 비용도 아낄 수 있죠.\n\n그런데 여기서 중요한 점! HMR 캐시는 기본적으로 모든 fetch 요청에 적용되는데, 심지어 `cache: 'no-store'` 옵션을 넣어도 마찬가지라는 거예요. 즉, 기본값인 `no-cache`나 `cache: 'no-store'`를 사용해도 HMR 중에는 캐시가 유지되어서 **최신 데이터가 바로바로 안 보일 수 있습니다**. \n\n하지만 실제로 페이지를 새로고침하거나 다른 경로로 이동할 때는 캐시가 깨져서 다시 최신 데이터를 가져오게 돼요.\n\n이게 개발할 때 가끔 데이터를 바로바로 바꿔서 테스트하는 과정에서 헷갈리게 할 수 있으니 주의해야 합니다.\n\n추가로 궁금하다면 [serverComponentsHmrCache 문서](https://nextjs.org/docs/advanced-features/react-18/server-components#hot-module-replacement-cache)도 확인해보세요!\n\n---\n\n### 참고로 알아두면 좋은 점\n\n- `cache: 'no-store'` 옵션은 **프로덕션 환경에선 실제로 캐시를 안 해서 무조건 최신 데이터를 가져오지만**,\n- 개발 모드에서만 HMR 캐시가 이를 덮어씌웁니다.\n- 이 때문에 개발 중에는 **fetch 요청이 예상과 다르게 동작할 수 있으니 주의**해야 해요.\n- 만약 진짜 최신 데이터를 계속 보고 싶다면, [페이지를 새로고침하거나 다른 경로로 이동하는 방법](https://nextjs.org/docs/basic-features/data-fetching#refreshing-data-on-client-navigation)을 쓰는 게 좋습니다.\n\n이런 Next.js 내부 동작 방식을 살펴보는 건 개발 생산성을 높이고, 예상치 못한 버그를 막는 데 큰 도움이 됩니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 버전 히스토리\n\n| 버전       | 변경 사항           |\n|------------|---------------------|\n| `v13.0.0`  | `fetch` 기능 추가됨 |\n\n여기서 `fetch`는 데이터를 서버에서 가져올 때 자주 사용하는 기능인데, 이 버전부터 공식적으로 도입됐다는 뜻이에요. 개발할 때 API 호출이 필요하면 이 기능을 활용해보세요. 예전에는 XMLHttpRequest나 다른 라이브러리를 많이 썼는데, `fetch`는 Promise 기반이라 비동기 처리가 훨씬 깔끔해져서 요즘은 표준처럼 쓰이고 있답니다.","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":10},{"title":"Next.js 15에서 쿠키 쉽게 다루는 방법","description":"","date":"2025-04-22 03:00","slug":"2025-04-22-cookies","content":"\n# Cookies (쿠키)\n\n`cookies`는 Server Components에서 들어오는 HTTP 요청의 쿠키를 읽고, Server Actions나 Route Handlers에서는 나가는 요청의 쿠키를 읽거나 쓸 수 있게 해주는 비동기 함수입니다.\n\n간단히 말해서, 서버 측에서 쿠키를 다루고 싶을 때 아주 유용한 도구에요. 예를 들어, 사용자가 설정한 테마값을 쿠키로 저장하고, 페이지를 렌더링할 때 이 값을 가져와서 다르게 보여주고 싶을 때 사용할 수 있죠.\n\n```js\nimport { cookies } from \"next/headers\";\n\nexport default async function Page() {\n  const cookieStore = await cookies(); // 쿠키 저장소를 비동기적으로 가져옵니다.\n  const theme = cookieStore.get(\"theme\"); // 'theme'이라는 이름의 쿠키를 읽어옵니다.\n  return \"...\";\n}\n```\n\n위 예제에서 `cookieStore`는 실제 쿠키 데이터를 다룰 수 있는 객체를 반환해줘요. `get` 메서드를 통해 특정 쿠키 값을 읽을 수 있죠.\n\n---\n\n## 추가 팁 - 쿠키 다루기\n\n- **읽기 \u0026 쓰기**: Server Actions나 Route Handlers에서는 `cookieStore.set('name', 'value', options)`를 사용해 쿠키를 설정할 수 있어요. 예를 들어, 사용자 로그인 후 세션 정보를 쿠키로 저장하는 경우처럼요.\n- **옵션 설정**: 쿠키 설정 시 `path`, `httpOnly`, `secure`, `maxAge` 등 다양한 옵션을 줄 수 있습니다. 이를 통해 보안이나 쿠키 유효 기간 등을 조절할 수 있죠.\n\n- **실제 활용 예시**:\n\n```js\nimport { cookies } from \"next/headers\";\n\nexport async function POST() {\n  const cookieStore = cookies();\n  cookieStore.set(\"token\", \"abc123\", { httpOnly: true, maxAge: 60 * 60 * 24 }); // 1일 동안 유효한 쿠키\n  return new Response(\"쿠키가 설정되었습니다.\");\n}\n```\n\n---\n\n`cookies` 함수는 Next.js 최신 버전에서 Server Components, Server Actions, Route Handlers 같은 서버 환경에서 쿠키를 안전하고 편리하게 다룰 수 있게 설계된 기능입니다. 클라이언트에서 document.cookie를 직접 만지는 것보다 훨씬 안전하고 깔끔하니, 서버에서 쿠키 작업이 필요할 때 적극 활용해 보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 메서드 소개\n\n아래는 사용할 수 있는 메서드들입니다:\n\n| 메서드                      | 반환 타입 | 설명                                                             |\n| --------------------------- | --------- | ---------------------------------------------------------------- |\n| `get('name')`               | Object    | 쿠키 이름을 받아서 그 이름과 값이 담긴 객체를 반환해요.          |\n| `getAll()`                  | 객체 배열 | 이름이 일치하는 모든 쿠키를 배열로 반환해줍니다.                 |\n| `has('name')`               | Boolean   | 쿠키 이름을 받아서 해당 쿠키가 존재하는지 true/false로 알려줘요. |\n| `set(name, value, options)` | -         | 쿠키 이름, 값, 옵션을 받아서 요청하는 쿠키를 설정합니다.         |\n| `delete(name)`              | -         | 쿠키 이름을 받아서 해당 쿠키를 삭제해줘요.                       |\n| `clear()`                   | -         | 모든 쿠키를 한 번에 삭제합니다.                                  |\n| `toString()`                | String    | 현재 쿠키들을 문자열 포맷으로 반환해줘요.                        |\n\n---\n\n직접 개발하다 보면 쿠키를 다루는 일이 꽤 잦을텐데, 이런 메서드들이 있으면 정말 편리하겠죠? 예를 들어, `has('name')` 메서드로 쿠키가 있는지 딱 체크해서 조건문을 쓰기도 쉽고, `getAll()` 메서드로 같은 이름을 가진 여러 쿠키를 모두 가져올 수도 있으니까 상황에 맞게 유용하게 쓸 수 있답니다.\n\n쿠키를 설정할 때는 `set()` 메서드에 옵션을 함께 넘겨주면, 유효 기간, 경로, 도메인 같은 세부 설정도 가능해서 제어가 한층 더 세밀해져요.\n\n이렇게 메서드들을 잘 활용하면 쿠키 관리를 훨씬 깔끔하게 할 수 있으니 참고하세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n쿠키(cookie)를 설정할 때 옵션 객체에서 사용할 수 있는 속성들은 아래와 같아요:\n\n| 옵션              | 타입                                   | 설명                                                                                    |\n| ----------------- | -------------------------------------- | --------------------------------------------------------------------------------------- |\n| `name`            | String                                 | 쿠키의 이름을 지정합니다.                                                               |\n| `value`           | String                                 | 쿠키에 저장할 값을 지정합니다.                                                          |\n| `expires`         | Date                                   | 쿠키 만료일을 정확하게 설정합니다.                                                      |\n| `maxAge`          | Number                                 | 쿠키의 수명(초 단위)을 설정합니다.                                                      |\n| `domain`          | String                                 | 쿠키가 유효한 도메인을 지정합니다.                                                      |\n| `path`            | String, 기본값: `'/'`                  | 쿠키의 유효 경로를 지정해 특정 경로 내에서만 쿠키가 사용되도록 제한할 수 있습니다.      |\n| `secure`          | Boolean                                | HTTPS 연결에서만 쿠키가 전송되도록 하여 보안을 강화합니다.                              |\n| `httpOnly`        | Boolean                                | 클라이언트 자바스크립트에서 쿠키 접근을 차단해 HTTP 요청에만 쿠키 사용을 제한합니다.    |\n| `sameSite`        | Boolean, `'lax'`, `'strict'`, `'none'` | 크로스 사이트 요청에 대한 쿠키 동작 방식을 제어합니다.                                  |\n| `priority`        | String (`\"low\"`, `\"medium\"`, `\"high\"`) | 쿠키의 우선순위를 지정합니다.                                                           |\n| `encode('value')` | Function                               | 쿠키 값을 인코딩하는 데 사용할 함수를 지정할 수 있습니다.                               |\n| `partitioned`     | Boolean                                | 쿠키가 [Partitioned Cookies](https://github.com/privacycg/CHIPS)인지 여부를 나타냅니다. |\n\n\u003e 여기서 `path` 옵션은 기본값이 `'/'`로 설정되어 있으니, 특정 경로에서만 쿠키가 유효하게 하려면 다른 값을 명시해줘야 해요.\n\n---\n\n### 좀 더 알려드릴 게 있어요!\n\n- **`secure` 옵션을 꼭 써야 하는 이유**  \n  쿠키가 HTTPS를 통해서만 전송될 수 있게 하는 `secure` 옵션은 민감한 정보 전송 시 보안을 크게 높여줍니다. 꼭 HTTPS 환경에서만 쿠키를 사용해야 할 경우 꼭 활성화해 주세요.\n\n- **`httpOnly`가 왜 중요한가?**  \n  `httpOnly` 속성을 활성화하면, 클라이언트 측 자바스크립트가 쿠키에 접근하지 못해서 XSS 공격에 의한 쿠키 탈취 위험을 줄일 수 있어요.\n\n- **`sameSite` 옵션으로 CSRF 방어하기**  \n  요즘은 크로스 사이트 요청 위조(CSRF) 공격 문제가 많기 때문에, `sameSite` 옵션을 `'lax'` 또는 `'strict'`로 설정하는 것이 보안에 도움이 됩니다.\n\n- **Partitioned Cookies**  \n  아직 상대적으로 최신 기술인 partitioned cookies는 브라우저별로 쿠키 저장소를 분리해서 사용자 간 추적을 어렵게 만드는 방향으로 연구되고 있습니다. 관심 있다면 GitHub 링크를 참고해 보세요!\n\n---\n\n쿠키 설정에 대해 더 자세한 내용은 [MDN 웹 문서](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies)에서 확인하실 수 있어요. 여기에 다양한 사례와 권장하는 보안 설정 방법도 소개되어 있으니 참고하면 큰 도움이 됩니다!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 알아두면 좋은 팁들\n\n- `cookies` 함수는 비동기 함수이며, Promise를 반환해요. 그래서 `async/await`를 사용하거나 React의 `use` 함수를 활용해서 값을 받아와야 합니다.  \n  참고로 Next.js 14 버전 이전까지는 동기 함수였는데, Next.js 15 버전에서도 이전 버전 호환을 위해 동기 방식으로 사용하는 게 가능하지만, 앞으로 이 방식은 사라질 예정입니다.\n\n- `cookies` 함수는 동적 API에 속해 있어요. 반환값을 미리 알 수 없기 때문에, 레이아웃(layout)이나 페이지에서 사용하게 되면 해당 라우트(route)가 동적 렌더링(dynamic rendering)으로 변환됩니다.\n\n- `.delete` 메서드는 아래 조건에서만 사용할 수 있습니다:\n\n  1. 서버 액션(Server Action)이나 라우트 핸들러(Route Handler) 안에서 호출해야 합니다.\n  2. `.set`을 호출한 같은 도메인이어야 합니다. 만약 와일드카드 도메인(wildcard domain)을 사용한다면, 세부 서브도메인이 정확히 일치해야 하며, 같은 프로토콜(HTTP 또는 HTTPS)에서 실행되어야 합니다.\n\n- HTTP 프로토콜 특성상 스트리밍(streaming) 시작 이후에는 쿠키 설정이 불가능하므로, 쿠키를 설정할 때는 서버 액션이나 라우트 핸들러 내에서 `.set` 메서드를 호출해야 해요.\n\n---\n\n## 서버 컴포넌트에서 쿠키 동작 이해하기\n\n서버 컴포넌트(Server Components)에서 쿠키를 다룰 때 기억해야 할 점은, 쿠키가 기본적으로 **클라이언트 쪽 저장소**라는 사실입니다. 즉, 쿠키는 브라우저에 저장되어서 HTTP 요청과 함께 서버에 전달되는 데이터인데, 서버 컴포넌트는 서버에서 렌더링되기 때문에 쿠키 정보를 정확히 반영하기 위해선 쿠키를 비동기적으로 불러와야 해요.\n\n### 여기서 조금 더!\n\n서버 컴포넌트에서는 쿠키 데이터에 접근할 때마다 클라이언트(브라우저)에서 전송된 쿠키를 읽는 느낌이라고 생각하면 편합니다. 그래서 쿠키가 바뀌면 서버 컴포넌트도 동적으로 다시 렌더링할 수밖에 없어요. 이 과정이 바로 Next.js가 동적 API로 취급하는 이유죠.\n\n또한, 서버 컴포넌트 내에서 `cookies().get()` 같은 API를 편리하게 호출할 수 있게 됐지만, 이 과정이 비동기적 처리임을 잊지 마세요. 그래서 `async` 함수 안에서 쿠키를 다뤄야 하며, 그렇게 해서 받아온 값으로 컴포넌트를 렌더링해야 합니다.\n\n---\n\n이런 점들을 잘 이해하고 사용하면, Next.js에서 쿠키 기반 인증이나 세션 관리 같은 기능을 더 안정적이고 자연스럽게 구현할 수 있습니다! 궁금한 점 있으면 언제든 물어보세요! 😊\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 서버 컴포넌트(Server Components)에서 쿠키를 읽을 수 있는 이유는 클라이언트(브라우저)가 HTTP 요청 헤더에 쿠키 데이터를 함께 보내기 때문이에요. 즉, 서버 쪽에서 요청이 올 때 쿠키 정보를 받을 수 있는 거죠.\n- 하지만 서버 컴포넌트에서 쿠키를 직접 설정(set)하는 건 불가능해요. 심지어 라우트 핸들러(Route Handler)나 서버 액션(Server Action)을 써도 마찬가지예요. 왜냐하면 쿠키는 실제로 서버가 아니라 클라이언트, 즉 브라우저가 저장하기 때문입니다.\n\n서버는 클라이언트(브라우저)에게 `Set-Cookie`라는 응답 헤더를 통해 \"이 쿠키를 저장해 달라\"는 명령만 보낼 수 있어요. 쿠키 저장 자체는 브라우저가 처리하죠. 그래서 쿠키 상태를 변경하는 작업(예: `.set`, `.delete`, `.clear`)은 반드시 라우트 핸들러나 서버 액션 내에서 해야 해요. 그래야 응답 헤더를 통해 적절한 쿠키 저장 명령을 포함시킬 수 있기 때문입니다.\n\n---\n\n## 예제들\n\n### 쿠키 가져오기 (Getting a cookie)\n\n```tsx\nimport { cookies } from \"next/headers\";\n\nexport default function ServerComponent() {\n  const cookieStore = cookies();\n  const token = cookieStore.get(\"token\")?.value;\n\n  return \u003cdiv\u003e{token ? `토큰 값: ${token}` : \"토큰이 없습니다.\"}\u003c/div\u003e;\n}\n```\n\n위 예시는 서버 컴포넌트에서 쿠키를 읽는 간단한 방법을 보여줘요. 요청 헤더에서 쿠키 데이터를 받아서 `token`이라는 이름의 쿠키가 있으면 값을 보여주고, 없으면 '토큰이 없습니다'라는 메시지를 띄우는 식이죠.\n\n---\n\n### 쿠키 설정하기 (Setting a cookie) - 라우트 핸들러 예시\n\n```tsx\nimport { NextResponse } from \"next/server\";\n\nexport async function POST() {\n  const response = NextResponse.json({ message: \"쿠키가 설정되었습니다!\" });\n  response.cookies.set(\"token\", \"abc123\", { httpOnly: true, maxAge: 60 * 60 * 24 });\n\n  return response;\n}\n```\n\n쿠키를 설정하고 싶을 땐 서버 컴포넌트가 아니라 이런 라우트 핸들러에서 응답 헤더에 `Set-Cookie`를 포함시켜서 브라우저에게 전달해야 해요. `httpOnly` 옵션을 쓰면 자바스크립트에서 쿠키가 조작되는걸 막아 보안성을 높일 수도 있어요.\n\n---\n\n### 팁: 쿠키 사용 시 주의사항\n\n- 쿠키는 용량 제한(보통 4KB)이 있어 너무 많은 데이터를 넣으면 안 돼요.\n- 인증용 토큰 같은 민감한 정보는 `httpOnly`와 `secure` 옵션을 설정해 보안을 강화하세요.\n- 클라이언트에서 `document.cookie`로 접근 가능한 쿠키와 서버에서 읽는 쿠키가 다를 수 있으니 목적에 맞는 쿠키 설정이 필요합니다.\n\n---\n\n쿠키는 웹에서 사용자 상태와 인증 정보를 관리하는 데 정말 중요해요. 서버와 클라이언트가 함께 작동해야 하니까 이 점 꼭 기억하면서 코딩해 보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 쿠키를 다룰 때 `await cookies()` 메서드를 사용하면 편리하게 쿠키 값을 가져올 수 있어요.\n\n예를 들어, 특정 이름을 가진 쿠키 하나만 가져오고 싶다면 아래처럼 하면 됩니다:\n\n```js\nimport { cookies } from \"next/headers\";\n\nexport default async function Page() {\n  const cookieStore = await cookies();\n  const theme = cookieStore.get(\"theme\"); // 'theme'이라는 이름의 쿠키 가져오기\n  return \"...\";\n}\n```\n\n`cookieStore.get('name')`은 해당 이름을 가진 첫 번째 쿠키를 반환하고, 만약 쿠키가 없으면 `undefined`를 돌려주니 존재 여부를 꼭 체크해주는 게 좋아요.\n\n---\n\n### 여러 개 혹은 모든 쿠키 가져오기\n\n만약 특정 이름에 해당하는 쿠키가 여러 개 있거나, 아예 전부 다 가져오고 싶다면 `getAll()` 메서드를 사용하면 됩니다. 아래처럼 쓰면 되죠:\n\n```js\nconst allThemeCookies = cookieStore.getAll(\"theme\"); // 'theme'이라는 이름의 모든 쿠키 가져오기\nconst allCookies = cookieStore.getAll(); // 이름 지정 없이 모든 쿠키 가져오기\n```\n\n`getAll()`은 배열을 반환해주기 때문에, 여러 개의 같은 이름 쿠키를 한 번에 다루거나 쿠키를 일괄 처리할 때 유용해요.\n\n---\n\n### 참고 팁!\n\n- 서버 컴포넌트에서만 `next/headers` 모듈의 `cookies()`를 쓸 수 있습니다.\n- 클라이언트 사이드에서 쿠키를 읽으려면 일반적인 JavaScript `document.cookie`를 써야 한다는 점도 기억하세요.\n- 보안상 쿠키를 다룰 땐 HttpOnly, Secure 옵션들도 잘 설정하는 습관이 필요합니다.\n\n필요한 쿠키를 깔끔하게 가져와서 편리한 상태 관리나 유저 테마 설정 등에 활용해 보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자, Next.js 13에서 Cookies API를 사용하는 방법에 대해 이야기해볼게요. Server Component나 서버 관련 코드에서 쿠키를 쉽게 조회하고, 설정할 수 있는 예제인데요.\n\n먼저, 쿠키를 읽어오는 코드입니다:\n\n```jsx\nimport { cookies } from \"next/headers\";\n\nexport default async function Page() {\n  // 쿠키 스토어를 불러오고\n  const cookieStore = await cookies();\n\n  // 모든 쿠키를 가져와서 JSX로 렌더링합니다\n  return cookieStore.getAll().map((cookie) =\u003e (\n    \u003cdiv key={cookie.name}\u003e\n      \u003cp\u003eName: {cookie.name}\u003c/p\u003e\n      \u003cp\u003eValue: {cookie.value}\u003c/p\u003e\n    \u003c/div\u003e\n  ));\n}\n```\n\n여기서 `cookies()` 함수는 서버에서 현재 요청에 포함된 쿠키들을 읽어오는 API예요. `getAll()`을 호출하면 모든 쿠키가 배열로 반환되고, 각 쿠키는 이름과 값뿐만 아니라 추가 옵션들도 포함할 수 있어요. 이걸 React 컴포넌트에서 렌더링하는 거죠.\n\n---\n\n### 쿠키 설정하기\n\n이제 쿠키를 새로 설정하는 방법입니다. Next.js에서는 서버 액션이나 Route Handler 내부에서 `cookies().set()` 메서드를 사용해서 쿠키를 만들 수 있어요.\n\n```js\n\"use server\";\n\nimport { cookies } from \"next/headers\";\n\nexport async function create(data) {\n  const cookieStore = await cookies();\n\n  // 기본적으로 name이라는 이름과 'lee'라는 값으로 쿠키 설정\n  cookieStore.set(\"name\", \"lee\");\n\n  // secure 옵션(HTTPS에서만 전송)\n  cookieStore.set(\"name\", \"lee\", { secure: true });\n\n  // 좀 더 상세 옵션 지정 가능 (httpOnly, path 등)\n  cookieStore.set({\n    name: \"name\",\n    value: \"lee\",\n    httpOnly: true,\n    path: \"/\",\n  });\n}\n```\n\n여기서 `httpOnly` 옵션은 클라이언트 JavaScript에서 쿠키에 접근하는 걸 막아서 보안에 도움이 되고, `secure` 옵션은 HTTPS 연결에서만 쿠키가 전송되도록 하는 거예요. 또, `path` 옵션을 지정하면 쿠키가 특정 경로에서만 유효하도록 할 수 있답니다.\n\n---\n\n### 알아두면 좋은 팁\n\n- 이 API는 서버 측에서만 동작하기 때문에, 클라이언트 측에서 쿠키를 다루려면 `document.cookie`를 사용해야 해요.\n- 쿠키는 보통 사용자 인증, 세션 관리, UI 상태 유지 등에 쓰이는데, 민감한 정보는 꼭 `httpOnly`나 `secure` 옵션을 함께 설정해서 노출되거나 탈취되지 않도록 주의하세요.\n- Next.js 13부터 도입된 이 `cookies` API는 사용하기 훨씬 편리해졌는데, 기존의 `set-cookie` 헤더 직접 조작보다 안정적이고 직관적이랍니다.\n\n---\n\n쿠키 다루기가 어려울 수 있는데, 이렇게 서버 컴포넌트 안에서 직관적으로 쓰니까 훨씬 편리해졌죠? 필요에 따라 쿠키를 갖고 놀아보세요! 혹시 더 궁금한 거 있으면 알려주세요.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 쿠키가 존재하는지 확인하기\n\nNext.js에서 쿠키가 있는지 확인하고 싶을 때는 `await cookies()` 메서드와 `has(name)` 메서드를 조합해서 사용하면 됩니다.\n\n```js\nimport { cookies } from \"next/headers\";\n\nexport default async function Page() {\n  const cookieStore = await cookies();\n  const hasCookie = cookieStore.has(\"theme\"); // 'theme' 쿠키가 있는지 확인\n  return hasCookie ? \"쿠키가 존재해요!\" : \"쿠키가 없어요!\";\n}\n```\n\n위 코드처럼 간단하게 특정 이름의 쿠키가 있는지 true/false로 확인할 수 있어요. 서버 컴포넌트에서 쿠키를 읽거나 분기 처리를 해야 할 때 유용하죠.\n\n---\n\n### 쿠키 삭제하기\n\n쿠키를 삭제하려면 기본적으로는 만료일자를 과거로 설정해줘야 해요. 서버 측에서 쿠키를 삭제하는 방법을 살펴볼게요.\n\n```js\nimport { cookies } from \"next/headers\";\n\nexport async function DELETE() {\n  const cookieStore = cookies();\n  cookieStore.delete(\"theme\", { path: \"/\" }); // 'theme' 쿠키 삭제\n  return new Response(\"쿠키 삭제됨\", { status: 200 });\n}\n```\n\n- `cookieStore.delete()` 메서드로 삭제할 쿠키 이름과 경로를 지정해주면 됩니다.\n- 쿠키가 특정 경로나 도메인에 묶여 있다면, 삭제할 때도 그 경로나 도메인을 맞춰줘야 완전히 삭제가 돼요.\n- 만약 클라이언트 쪽에서 쿠키를 삭제하고 싶다면, 자바스크립트의 `document.cookie = \"name=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;\"` 같은 방법을 쓰면 됩니다.\n\n---\n\n### 조금 더 알아두면 좋은 점\n\n- Next.js의 `cookies()`는 서버 컴포넌트나 API 라우트 등 서버 측에서만 사용할 수 있어요.\n- 쿠키는 보안상 중요한 정보를 담기보다는 세션식별자나 사용자 선호 설정 정도로 사용하는 게 좋아요.\n- `Secure`, `HttpOnly`, `SameSite` 같은 옵션도 꼭 설정해서 보안을 강화하는 습관을 들이면 좋답니다!\n\n다음에 쿠키 관련해서 직접 실습하면서 또 도움이 될 만한 팁을 공유할게요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n쿠키를 삭제하는 방법에는 크게 세 가지가 있어요. 여기서는 그 중 두 가지를 소개해드릴게요.\n\n### 1. `delete()` 메서드 사용하기\n\nNext.js에서 제공하는 `cookies` 객체에 있는 `delete()` 메서드를 사용해서 간단하게 쿠키를 지울 수 있어요.\n\n```js\n\"use server\";\n\nimport { cookies } from \"next/headers\";\n\nexport async function deleteCookie() {\n  (await cookies()).delete(\"name\"); // 'name'이라는 이름의 쿠키를 삭제해요.\n}\n```\n\n- `await cookies()`를 호출해서 현재 쿠키 객체를 받아오고, 그 안에서 `delete('name')`을 호출해서 특정 쿠키를 삭제합니다.\n- 서버 컴포넌트 또는 서버 함수 안에서만 쓸 수 있다는 점 참고하세요.\n\n### 2. 같은 이름으로 빈 값 설정하기\n\n사실, 쿠키를 삭제하는 또 다른 방법은 같은 이름으로 빈 값을 설정하고 만료 시간을 과거로 설정하는 거예요. 이렇게 하면 브라우저가 해당 쿠키를 지우게 됩니다.\n\n```js\nimport { cookies } from \"next/headers\";\n\nexport async function deleteCookieBySetting() {\n  (await cookies()).set({\n    name: \"name\",\n    value: \"\", // 빈 값으로 설정\n    expires: new Date(0), // 만료 시간을 과거로 설정해서 즉시 만료\n    path: \"/\",\n  });\n}\n```\n\n- `set()` 메서드를 이용해 만료 시점을 과거로 지정하면 쿠키가 삭제된 것과 같은 효과를 냅니다.\n- 직접 쿠키 값을 칼같이 삭제하지 않아도 되니, 간단한 상황에 유용하죠.\n\n---\n\n### 참고: 쿠키 삭제 시 주의할 점\n\n- 쿠키는 도메인, 경로(path), 보안 설정(secure, httpOnly)에 따라 영향을 받습니다.\n- 쿠키를 삭제할 때도 같은 도메인과 경로를 명시해줘야 확실히 삭제할 수 있어요.\n- 만약 삭제가 제대로 안 된다면, 해당 쿠키의 `path`나 `domain` 설정을 다시 한 번 확인해 보세요.\n\n---\n\n쿠키를 다룰 때는 이렇게 여러 방법이 있으니, 상황에 맞게 골라 쓰시면 됩니다. 서버에서 직접 쿠키를 관리하는 경우라면 `delete()`를, 클라이언트 쪽에서는 빈 값과 만료 시간을 조정하는 방법이 인기가 많아요.\n\n필요하면 다음에 세 번째 방법도 알려드릴게요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n`Next.js`의 서버 컴포넌트에서 쿠키를 삭제하는 방법에 대해 알아볼게요. 보통 쿠키를 \"삭제\"하려면, 해당 쿠키의 만료 시간을 즉시 만료시키거나, 빈 값으로 덮어쓰는 두 가지 방법을 사용해요.\n\n---\n\n### 1. 쿠키를 빈 값으로 덮어쓰기\n\n아래 코드는 `cookies().set()` 메서드를 사용해서 쿠키 이름을 빈 문자열로 설정하는 예시입니다.\n이렇게 하면 쿠키 값이 빈 문자열로 바뀌지만, 실제로 쿠키는 브라우저에 그대로 남아 있을 수 있어요.\n\n```js\n'use server'\n\nimport { cookies } from 'next/headers'\n\nexport async function delete(data) {\n  (await cookies()).set('name', '')\n}\n```\n\n---\n\n### 2. maxAge를 0으로 설정해 바로 만료시키기\n\n쿠키를 완전히 삭제하려면 `maxAge` 옵션을 0으로 설정해서 쿠키 만료 시간을 즉시 지난 값으로 설정하는 방법이 더 확실해요.\n\n```js\n'use server'\n\nimport { cookies } from 'next/headers'\n\nexport async function delete(data) {\n  (await cookies()).set('name', 'value', { maxAge: 0 })\n}\n```\n\n`maxAge`는 초 단위로 시간을 받기 때문에 `0`을 주면 곧바로 만료 처리되는 거죠.\n\n---\n\n## 흔히 묻는 질문\n\n| 질문                                    | 답변                                                                                          |\n| --------------------------------------- | --------------------------------------------------------------------------------------------- |\n| `maxAge` 대신 `expires`를 써도 되나요?  | 네, 가능합니다. `expires`는 날짜 객체를 받아서 쿠키 만료 시간을 설정하는 방법이에요.          |\n| 빈 문자열로 설정하면 쿠키가 삭제되나요? | 사실상 값만 비워질 뿐 구버전 브라우저나 일부 환경에서는 쿠키가 살아 있을 수 있어요.           |\n| `maxAge: 0` 와 `maxAge: -1` 차이는?     | 둘 다 쿠키를 즉시 만료시키지만, 보통 `0`을 사용해요. 음수는 브라우저에 따라 달라질 수 있어요. |\n\n---\n\n### 마무리\n\n`Next.js` 13 서버 컴포넌트 기능에서 새로 제공하는 `cookies` API는 훨씬 간편하게 쿠키를 다룰 수 있도록 도와주지만, 조금만 주의하면 쿠키 삭제도 깔끔하게 할 수 있어요!\n\n쿠키를 삭제할 땐 꼭 제대로 만료 시간을 설정해서, 원하지 않는 쿠키가 백그라운드에 남지 않도록 관리해주세요. 쿠키 조작에 대해 더 궁금한 점 있으면 언제든 물어봐주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 `cookies` 관련 변경 사항을 정리한 표예요.\n\n| Version      | Changes                                                                                                                                                     |\n| ------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `v15.0.0-RC` | `cookies`가 이제 비동기(async) 함수로 변경되었어요. 업그레이드할 때 도움이 되는 \u003ca href=\"/docs/app/guides/upgrading/codemods#150\"\u003ecodemod\u003c/a\u003e도 제공됩니다. |\n| `v13.0.0`    | `cookies` 기능이 처음 도입되었어요.                                                                                                                         |\n\n참고로, `cookies`가 비동기 함수가 된 이유는 서버에서 쿠키를 처리할 때 비동기 작업이 필요한 경우가 많기 때문이에요. 예를 들어, 데이터베이스 조회나 외부 API 호출을 하면서 쿠키 값을 확인하거나 수정할 때 자연스럽게 비동기로 처리하는 게 더 효율적이죠.\n\n이런 변경사항을 반영하지 않으면 기존에 동기 함수처럼 호출하던 코드에서 문제가 발생할 수 있으니, 꼭 공식 codemod를 활용해서 코드를 자동 변환해 보는 걸 추천드려요!\n","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":20}],"page":"9","totalPageCount":50,"totalPageGroupCount":3,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"9"},"buildId":"M7pU9hOcx8u_ZIFMf95sd","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>