<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>TIL</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//posts/2" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="TIL" data-gatsby-head="true"/><meta property="og:title" content="TIL" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//posts/2" data-gatsby-head="true"/><meta name="twitter:title" content="TIL" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/7978fe7362f7d4c9.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/7978fe7362f7d4c9.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/873-eb138c3217d71553.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/posts/%5Bpage%5D-de1dc5579188f9be.js" defer=""></script><script src="/TIL/_next/static/o6AmBAY_j9v9JmbaRA39X/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/o6AmBAY_j9v9JmbaRA39X/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Next.js 15에서 sitemap.xml 자동으로 생성하는 방법" href="/TIL/post/2025-04-22-sitemapxml"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15에서 sitemap.xml 자동으로 생성하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15에서 sitemap.xml 자동으로 생성하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15에서 sitemap.xml 자동으로 생성하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">9 hours ago</span><span class="PostList_reading_time__6CBMQ">18<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="웹 SEO를 위한 robots.txt 작성과 활용법" href="/TIL/post/2025-04-22-robotstxt"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="웹 SEO를 위한 robots.txt 작성과 활용법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="웹 SEO를 위한 robots.txt 작성과 활용법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">웹 SEO를 위한 robots.txt 작성과 활용법</strong><div class="PostList_meta__VCFLX"><span class="date">9 hours ago</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js 15에서 OpenGraph-Image와 Twitter-Image 설정하는 방법 " href="/TIL/post/2025-04-22-opengraph-imageandtwitter-image"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15에서 OpenGraph-Image와 Twitter-Image 설정하는 방법 " loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15에서 OpenGraph-Image와 Twitter-Image 설정하는 방법 " loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15에서 OpenGraph-Image와 Twitter-Image 설정하는 방법 </strong><div class="PostList_meta__VCFLX"><span class="date">9 hours ago</span><span class="PostList_reading_time__6CBMQ">25<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nextjs15에서 manifest.json 설정하는 방법" href="/TIL/post/2025-04-22-manifestjson"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nextjs15에서 manifest.json 설정하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nextjs15에서 manifest.json 설정하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Nextjs15에서 manifest.json 설정하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">9 hours ago</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="nextjs 15에서 meta data 사용하는 방법" href="/TIL/post/2025-04-22-MetadataFilesAPIReference"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="nextjs 15에서 meta data 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="nextjs 15에서 meta data 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">nextjs 15에서 meta data 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">9 hours ago</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="2025년 Next.js 15에서 favicon, icon, apple-icon 쉽게 설정하는 방법" href="/TIL/post/2025-04-22-faviconiconandapple-icon"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="2025년 Next.js 15에서 favicon, icon, apple-icon 쉽게 설정하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="2025년 Next.js 15에서 favicon, icon, apple-icon 쉽게 설정하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">2025년 Next.js 15에서 favicon, icon, apple-icon 쉽게 설정하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">9 hours ago</span><span class="PostList_reading_time__6CBMQ">21<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="nextjs 15에서 template.js 사용하는 방법" href="/TIL/post/2025-04-22-templatejs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="nextjs 15에서 template.js 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="nextjs 15에서 template.js 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">nextjs 15에서 template.js 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">9 hours ago</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js 15에서 Unauthorized.js로 권한 없는 접근 처리하는 방법" href="/TIL/post/2025-04-22-unauthorizedjs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15에서 Unauthorized.js로 권한 없는 접근 처리하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15에서 Unauthorized.js로 권한 없는 접근 처리하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15에서 Unauthorized.js로 권한 없는 접근 처리하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">9 hours ago</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js 15 라우트 세그먼트 설정 방법과 활용팁" href="/TIL/post/2025-04-22-RouteSegmentConfig"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15 라우트 세그먼트 설정 방법과 활용팁" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15 라우트 세그먼트 설정 방법과 활용팁" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15 라우트 세그먼트 설정 방법과 활용팁</strong><div class="PostList_meta__VCFLX"><span class="date">9 hours ago</span><span class="PostList_reading_time__6CBMQ">18<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js 15에서 route.js 파일 설정하는 방법" href="/TIL/post/2025-04-22-routejs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15에서 route.js 파일 설정하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15에서 route.js 파일 설정하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15에서 route.js 파일 설정하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">9 hours ago</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/TIL/posts/1">1</a><a class="link posts_-active__YVJEi" href="/TIL/posts/2">2</a><a class="link" href="/TIL/posts/3">3</a><a class="link" href="/TIL/posts/4">4</a><a class="link" href="/TIL/posts/5">5</a><a class="link" href="/TIL/posts/6">6</a><a class="link" href="/TIL/posts/7">7</a><a class="link" href="/TIL/posts/8">8</a><a class="link" href="/TIL/posts/9">9</a><a class="link" href="/TIL/posts/10">10</a><a class="link" href="/TIL/posts/11">11</a><a class="link" href="/TIL/posts/12">12</a><a class="link" href="/TIL/posts/13">13</a><a class="link" href="/TIL/posts/14">14</a><a class="link" href="/TIL/posts/15">15</a><a class="link" href="/TIL/posts/16">16</a><a class="link" href="/TIL/posts/17">17</a><a class="link" href="/TIL/posts/18">18</a><a class="link" href="/TIL/posts/19">19</a><a class="link" href="/TIL/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Next.js 15에서 sitemap.xml 자동으로 생성하는 방법","description":"","date":"2025-04-22 02:54","slug":"2025-04-22-sitemapxml","content":"\n\n# sitemap.xml\n\nsitemap.(xml|js|ts)은 검색 엔진 크롤러가 사이트를 더 효율적으로 색인할 수 있도록 도와주는, Sitemaps XML 형식을 따르는 특별한 파일이에요.\n\n### Sitemap 파일(.xml)\n\n작은 규모의 앱이라면, 루트 디렉토리에 sitemap.xml 파일을 만들어 두는 게 가장 간단한 방법이에요. 이렇게 하면 크롤러가 바로 이 파일을 찾아서 사이트 구조를 쉽게 파악할 수 있답니다.\n\n---\n\n### 참고로 알아두면 좋은 점!\n\n- sitemap.xml에 사이트 내 주요 URL들을 담으면, 구글 같은 검색 엔진이 어떤 페이지를 우선적으로 크롤링할지 효율적으로 판단해요.\n- 페이지가 너무 많으면 하나의 sitemap.xml에 다 담기 어려운데, 이럴 땐 sitemap index 파일을 사용하거나 여러 개의 sitemap 파일을 나누어 관리할 수도 있어요.\n- 웹사이트가 자주 바뀌는 경우엔 sitemap.xml에 `lastmod` 태그를 넣어서 마지막 변경 시점을 알리는 것도 좋아요. 그러면 크롤러가 변경된 부분을 빠르게 반영할 수 있어요.\n\n마지막으로, sitemap.xml을 만드는 데 너무 복잡하게 생각하지 마세요. 간단하게 시작하고, 사이트가 커지면 점차 확장하는 방향으로 가면 충분합니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nsitemap.xml 파일을 직접 작성하는 것도 방법이지만, 프로젝트 규모가 커지면서 수동으로 관리하기엔 점점 힘들어집니다. 그래서 요즘엔 코드로 sitemap을 자동 생성하는 방식을 많이 사용해요.\n\n```js\n\u003curlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\"\u003e\n  \u003curl\u003e\n    \u003cloc\u003ehttps://acme.com\u003c/loc\u003e\n    \u003clastmod\u003e2023-04-06T15:02:24.021Z\u003c/lastmod\u003e\n    \u003cchangefreq\u003eyearly\u003c/changefreq\u003e\n    \u003cpriority\u003e1\u003c/priority\u003e\n  \u003c/url\u003e\n  \u003curl\u003e\n    \u003cloc\u003ehttps://acme.com/about\u003c/loc\u003e\n    \u003clastmod\u003e2023-04-06T15:02:24.021Z\u003c/lastmod\u003e\n    \u003cchangefreq\u003emonthly\u003c/changefreq\u003e\n    \u003cpriority\u003e0.8\u003c/priority\u003e\n  \u003c/url\u003e\n  \u003curl\u003e\n    \u003cloc\u003ehttps://acme.com/blog\u003c/loc\u003e\n    \u003clastmod\u003e2023-04-06T15:02:24.021Z\u003c/lastmod\u003e\n    \u003cchangefreq\u003eweekly\u003c/changefreq\u003e\n    \u003cpriority\u003e0.5\u003c/priority\u003e\n  \u003c/url\u003e\n\u003c/urlset\u003e\n```\n\n위처럼 정적인 sitemap도 좋지만, JavaScript나 TypeScript를 활용하면 더 유연하게 sitemap을 관리할 수 있죠.\n\n---\n\n## 코드로 sitemap 만들기 (.js, .ts)\n\n예를 들어, `sitemap.js` 또는 `sitemap.ts` 같은 파일을 만들어서 거기서 URL 배열을 내보내는 함수를 작성할 수 있어요. TypeScript를 사용하면 `Sitemap` 타입도 제공되니까 타입 안정성도 챙길 수 있고요.\n\n```ts\nimport { Sitemap } from 'some-sitemap-package'; // 예시, 실제로는 사용중인 라이브러리 따라 다름\n\nconst sitemap: Sitemap = [\n  {\n    loc: 'https://acme.com',\n    lastmod: new Date().toISOString(),\n    changefreq: 'yearly',\n    priority: 1.0\n  },\n  {\n    loc: 'https://acme.com/about',\n    lastmod: new Date().toISOString(),\n    changefreq: 'monthly',\n    priority: 0.8\n  },\n  {\n    loc: 'https://acme.com/blog',\n    lastmod: new Date().toISOString(),\n    changefreq: 'weekly',\n    priority: 0.5\n  }\n];\n\nexport default function getSitemap() {\n  return sitemap;\n}\n```\n\n\u003e **참고!** `sitemap.js` 파일은 특별한 Route Handler의 역할을 하며, 기본적으로 캐싱이 되기 때문에 사이트 성능에도 도움이 됩니다. 다만, 동적 API를 사용하거나 dynamic config 옵션이 있으면 캐싱이 적용되지 않을 수 있답니다.\n\n---\n\n### 추가 팁\n\n- **자동 갱신:** 블로그처럼 새 글이 자주 올라오는 사이트는 게시글이 추가될 때마다 sitemap을 자동으로 업데이트하는 게 좋아요.\n- **우선순위(priority):** 검색 엔진에게 어떤 페이지가 더 중요한지 알려주는 역할을 해요. 1.0이 가장 높은 값이고 0.0에 가까울수록 낮아요.\n- **변경 빈도(changefreq):** 페이지가 얼마나 자주 변경되는지 알려주면 검색 엔진이 크롤링 빈도를 조절하는 데 도움이 돼요.\n\n이렇게 코드로 sitemap을 관리하면, 추가하거나 수정할 때 훨씬 편하고 실수를 줄일 수 있어요. 꼭 한번 활용해 보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js의 `MetadataRoute.Sitemap` 타입으로 작성한 자바스크립트 객체를 실제 XML 사이트맵 형식으로 어떻게 변환하는지 보여주는 예제인데요.\n\n코드를 보면 사이트맵에 들어갈 URL 리스트와 각 URL에 대한 메타정보(마지막 수정일, 변경 빈도, 우선순위)를 객체 배열로 반환하고 있어요. 그걸 XML `\u003curlset\u003e` 태그 내부에 `\u003curl\u003e`단위로 나눠서 넣으면, 검색엔진이 이해할 수 있는 표준 사이트맵 파일이 완성됩니다.\n\n---\n\n### 자바스크립트 객체 ⇨ XML 사이트맵 대응표\n\n| 자바스크립트 속성명 | XML 사이트맵 태그명  | 설명                         |\n|---------------------|---------------------|------------------------------|\n| url                 | `\u003cloc\u003e`             | URL 위치                     |\n| lastModified        | `\u003clastmod\u003e`         | 마지막 수정일 (ISO 8601 표기)|\n| changeFrequency     | `\u003cchangefreq\u003e`      | URL 변경 빈도 ('yearly', 'monthly', 'weekly' 등) |\n| priority            | `\u003cpriority\u003e`        | 우선순위 (0.0 ~ 1.0 사이 숫자) |\n\n---\n\n### 추가 팁: Image Sitemap 만들기\n\n사이트맵에 이미지가 포함된 페이지를 별도로 표현할 때는 **Image Sitemap**이라고 불러요. 이미지를 효과적으로 검색엔진에 알릴 수 있어서 SEO에 도움이 되는 중요한 기능이죠.\n\n예를 들어, 이미지 정보를 담는 XML 구조는 다음과 같아요.\n\n```js\n\u003curl\u003e\n  \u003cloc\u003ehttps://example.com/page-with-image\u003c/loc\u003e\n  \u003cimage:image\u003e\n    \u003cimage:loc\u003ehttps://example.com/images/image1.jpg\u003c/image:loc\u003e\n    \u003cimage:caption\u003eImage Caption Here\u003c/image:caption\u003e\n    \u003cimage:title\u003eImage Title Here\u003c/image:title\u003e\n  \u003c/image:image\u003e\n\u003c/url\u003e\n```\n\n이미지 정보를 추가할 때는 각 `\u003curl\u003e` 안에 `\u003cimage:image\u003e` 태그를 중첩시키고, 내부에 이미지 URL, 캡션, 타이틀 등을 넣어 줍니다.\n\n---\n\nNode.js나 Next.js 환경에서 이런 XML을 프로그래밍적으로 생성할 때는 보통 라이브러리를 쓰거나, 직접 문자열 템플릿을 만들어서 변환하죠. 여러분도 이 자료를 참고해서 자동으로 사이트맵을 만들면 워낙 편하니 꼭 도전해보길 추천할게요! 검색엔진 최적화(SEO)에 매우 큰 도움이 됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이미지 사이트맵을 만들 때는 `images` 속성을 활용할 수 있어요. 이미지가 포함된 사이트맵은 구글 검색에서 이미지 색인에 도움을 주니까, 이미지가 많은 사이트를 운영한다면 꼭 활용해보길 추천해요. 자세한 내용은 구글 개발자 문서(Developer Docs)에서 확인할 수 있습니다.\n\n아래는 Next.js에서 `MetadataRoute.Sitemap` 타입을 사용해 이미지 사이트맵을 만드는 예제 코드예요:\n\n```js\nimport type { MetadataRoute } from 'next'\n\nexport default function sitemap(): MetadataRoute.Sitemap {\n  return [\n    {\n      url: 'https://example.com',\n      lastModified: '2021-01-01',\n      changeFrequency: 'weekly',\n      priority: 0.5,\n      images: ['https://example.com/image.jpg'],\n    },\n  ]\n}\n```\n\n이 코드를 통해 생성되는 사이트맵 XML은 다음과 같이 생겼답니다:\n\n```js\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\n\u003curlset\n  xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\"\n  xmlns:image=\"http://www.google.com/schemas/sitemap-image/1.1\"\n\u003e\n  \u003curl\u003e\n    \u003cloc\u003ehttps://example.com\u003c/loc\u003e\n    \u003cimage:image\u003e\n      \u003cimage:loc\u003ehttps://example.com/image.jpg\u003c/image:loc\u003e\n    \u003c/image:image\u003e\n    \u003clastmod\u003e2021-01-01\u003c/lastmod\u003e\n    \u003cchangefreq\u003eweekly\u003c/changefreq\u003e\n    \u003cpriority\u003e0.5\u003c/priority\u003e\n  \u003c/url\u003e\n\u003c/urlset\u003e\n```\n\n### 이미지 사이트맵, 이래서 좋아요!\n\n| 장점 | 설명 |\n|---|---|\n| 더 나은 색인 | 구글이 이미지도 정확히 인식해서 검색 결과에 노출 가능성이 높아져요. |\n| 트래픽 증가 | 이미지 검색을 통한 방문자 유입이 늘어나서 사이트 트래픽 증대에 도움이 됩니다. |\n| SEO 강화 | 콘텐츠의 시각적 요소가 잘 반영되니, 전체 SEO 점수에도 긍정적 영향을 줍니다. |\n\n\u003e **Tip!**  \n\u003e 이미지 URL은 절대 경로로 명확하게 지정해 주세요. 이미지 파일이 자주 업데이트되는 경우에는 `lastModified` 값도 신경 써서 맞춰 주면 더 좋아요.\n\n이왕 이미지 많은 사이트를 운영 중이라면, 이렇게 이미지 사이트맵까지 챙겨서 검색 노출, 방문자 수 두 마리 토끼 잡아보시길 바랍니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 비디오 사이트맵 (Video Sitemaps)\n\n웹사이트에 비디오 콘텐츠가 많다면, 비디오 전용 사이트맵을 만들어 검색 엔진이 영상을 더 잘 인식하고 노출할 수 있게 할 수 있어요. Next.js 같은 현대적인 프레임워크에서는 `videos` 프로퍼티를 활용해서 비디오 사이트맵을 쉽게 생성할 수 있는데요. 구글 공식 개발자 문서에서 자세한 내용을 참고할 수 있으니 꼭 한 번 확인해보세요!\n\n아래 코드는 Next.js에서 비디오 사이트맵을 만드는 예시입니다:\n\n```js\nimport type { MetadataRoute } from 'next'\n \nexport default function sitemap(): MetadataRoute.Sitemap {\n  return [\n    {\n      url: 'https://example.com',                  // 페이지 URL\n      lastModified: '2021-01-01',                  // 마지막 수정일\n      changeFrequency: 'weekly',                    // 변경 빈도\n      priority: 0.5,                               // 우선순위\n      videos: [                                    // 비디오 정보 배열\n        {\n          title: 'example',                        // 영상 제목\n          thumbnail_loc: 'https://example.com/image.jpg', // 썸네일 이미지 URL\n          description: 'this is the description', // 영상 설명\n        },\n      ],\n    },\n  ]\n}\n```\n\n### 비디오 사이트맵을 만들 때 알아두면 좋은 점\n\n- `lastModified`와 `changeFrequency`는 검색 엔진에 갱신 주기를 알려주는 역할을 합니다. 자주 업데이트되는 콘텐츠면 보다 최신 정보를 반영하도록 설계하는 게 좋아요.\n- `priority` 값은 0에서 1 사이로, 같은 사이트 내에서 해당 URL의 상대적 중요도를 나타내는데, 영상이 중요한 페이지라면 0.7 이상을 주는 것도 괜찮아요.\n- `videos` 배열 안에는 여러 개의 비디오 정보를 넣을 수 있으므로, 한 페이지에 여러 영상이 있다면 모두 추가할 수 있어요.\n- `thumbnail_loc` (썸네일 위치)은 영상 내용과 잘 맞는 정사각형 또는 16:9 비율의 고화질 이미지를 사용하는 게 노출 효과 면에서 유리합니다.\n\n---\n\n### 참고로, 비디오 사이트맵을 만들면 어떤 점이 좋나요?\n\n- 구글이 사이트 내 비디오를 더 잘 파악해서 검색 결과에 리치 스니펫(동영상 미리보기)을 보여 줄 확률이 증가합니다.\n- 유튜브 같은 외부 서비스 대신 자체 호스팅 영상이 있을 때 특히 검색 노출에 도움이 됩니다.\n- 영상의 메타 정보를 명확하게 전달함으로써 사용자 경험 향상에도 기여할 수 있어요.\n\n비디오를 많이 다루는 개발자나 콘텐츠 제작자라면 꼭 도입해보길 추천드립니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안녕하세요! 오늘은 **로컬라이즈된 사이트맵(Localized Sitemap)**을 만드는 방법에 대해 알려드릴게요.\n\n---\n\n### 1. 기본 비디오 사이트맵 예시\n\n먼저, XML 형태로 작성된 비디오 사이트맵 예시를 보실게요.\n\n```js\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\n\u003curlset\n  xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\"\n  xmlns:video=\"http://www.google.com/schemas/sitemap-video/1.1\"\n\u003e\n  \u003curl\u003e\n    \u003cloc\u003ehttps://example.com\u003c/loc\u003e\n    \u003cvideo:video\u003e\n      \u003cvideo:title\u003eexample\u003c/video:title\u003e\n      \u003cvideo:thumbnail_loc\u003ehttps://example.com/image.jpg\u003c/video:thumbnail_loc\u003e\n      \u003cvideo:description\u003ethis is the description\u003c/video:description\u003e\n    \u003c/video:video\u003e\n    \u003clastmod\u003e2021-01-01\u003c/lastmod\u003e\n    \u003cchangefreq\u003eweekly\u003c/changefreq\u003e\n    \u003cpriority\u003e0.5\u003c/priority\u003e\n  \u003c/url\u003e\n\u003c/urlset\u003e\n```\n\n- 여기선 `\u003cloc\u003e` 태그에 URL이 들어가고,\n- `\u003cvideo:video\u003e` 안에 비디오 타이틀, 썸네일, 설명이 포함되어 있죠.\n- `\u003clastmod\u003e`, `\u003cchangefreq\u003e`, `\u003cpriority\u003e` 같은 검색엔진 최적화 태그들도 추가됐어요.\n\n---\n\n### 2. Next.js에서 로컬라이즈된 사이트맵 생성하기\n\n이제 Next.js 기반 프로젝트에서, 여러 언어별 사이트맵을 자동으로 생성하는 방법을 알려드릴게요.\n\n```ts\nimport type { MetadataRoute } from 'next'\n\nexport default function sitemap(): MetadataRoute.Sitemap {\n  return [\n    {\n      url: 'https://acme.com',\n      lastModified: new Date(),\n      alternates: {\n        languages: {\n          es: 'https://acme.com/es',\n          de: 'https://acme.com/de',\n        },\n      },\n    },\n    {\n      url: 'https://acme.com/about',\n      lastModified: new Date(),\n      alternates: {\n        languages: {\n          es: 'https://acme.com/es/about',\n          de: 'https://acme.com/de/about',\n        },\n      },\n    },\n    {\n      url: 'https://acme.com/blog',\n      lastModified: new Date(),\n      alternates: {\n        languages: {\n          es: 'https://acme.com/es/blog',\n          de: 'https://acme.com/de/blog',\n        },\n      },\n    },\n  ]\n}\n```\n\n- `lastModified`엔 최신 업데이트 시간을 넣고,\n- `alternates.languages` 속성으로 각 언어별 페이지 URL을 명시해주는게 포인트입니다.\n- 이렇게 하면 구글 같은 검색엔진이 다국어 페이지를 인식해 SEO에 도움이 돼요!\n\n---\n\n### 사이트맵에 대해 더 알아두면 좋은 점\n\n| 제목              | 설명                                                         |\n|-----------------|------------------------------------------------------------|\n| 사이트맵 역할       | 검색엔진 크롤러에게 내 사이트 페이지 구조를 알려줘요                 |\n| 로컬라이즈 사이트맵 | 다국어 사이트에서 각 언어별 URL을 명확히 표시해서 SEO를 극대화해요    |\n| Next.js 지원      | 최신 Next.js는 `app` 디렉터리에 `sitemap.ts`를 추가해 쉽게 구현 가능 |\n| lastModified 쓰임  | 페이지가 언제 업데이트됐는지 알려줘 크롤러가 효율적으로 크롤링하게 도움 |\n\n---\n\n### 마무리\n\n만약 여러분의 사이트가 여러 언어로 운영된다면, 이렇게 로컬라이즈된 사이트맵은 필수라고 할 수 있어요.  \n특히 Next.js 같이 최신 프레임워크에선 손 쉽게 관리할 수 있으니 꼭 활용해보세요!\n\n궁금한 점이나 어려운 점 있으면 편하게 댓글 남겨주시고, 즐거운 개발 하시길 바랄게요 :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n\u003curlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\" xmlns:xhtml=\"http://www.w3.org/1999/xhtml\"\u003e\n  \u003curl\u003e\n    \u003cloc\u003ehttps://acme.com\u003c/loc\u003e\n    \u003cxhtml:link\n      rel=\"alternate\"\n      hreflang=\"es\"\n      href=\"https://acme.com/es\"/\u003e\n    \u003cxhtml:link\n      rel=\"alternate\"\n      hreflang=\"de\"\n      href=\"https://acme.com/de\"/\u003e\n    \u003clastmod\u003e2023-04-06T15:02:24.021Z\u003c/lastmod\u003e\n  \u003c/url\u003e\n  \u003curl\u003e\n    \u003cloc\u003ehttps://acme.com/about\u003c/loc\u003e\n    \u003cxhtml:link\n      rel=\"alternate\"\n      hreflang=\"es\"\n      href=\"https://acme.com/es/about\"/\u003e\n    \u003cxhtml:link\n      rel=\"alternate\"\n      hreflang=\"de\"\n      href=\"https://acme.com/de/about\"/\u003e\n    \u003clastmod\u003e2023-04-06T15:02:24.021Z\u003c/lastmod\u003e\n  \u003c/url\u003e\n  \u003curl\u003e\n    \u003cloc\u003ehttps://acme.com/blog\u003c/loc\u003e\n    \u003cxhtml:link\n      rel=\"alternate\"\n      hreflang=\"es\"\n      href=\"https://acme.com/es/blog\"/\u003e\n    \u003cxhtml:link\n      rel=\"alternate\"\n      hreflang=\"de\"\n      href=\"https://acme.com/de/blog\"/\u003e\n    \u003clastmod\u003e2023-04-06T15:02:24.021Z\u003c/lastmod\u003e\n  \u003c/url\u003e\n\u003c/urlset\u003e\n```\n\n### 다중 사이트맵 생성하기\n\n대부분의 웹사이트는 하나의 사이트맵만으로 충분하지만, 큰 규모의 웹 애플리케이션에서는 사이트맵을 여러 개로 나눠야 할 때가 있어요. 검색 엔진이 너무 큰 파일을 처리하기 어려워할 수 있고, 사이트맵 크기 제한(50,000 URL 또는 50MB uncompressed)을 초과할 우려도 있거든요.\n\n그래서 사이트맵을 나누는 방법은 크게 두 가지가 있습니다:\n\n| 방법           | 설명                                                                                   |\n| -------------- | -------------------------------------------------------------------------------------- |\n| 여러 개의 사이트맵 파일 생성 | 사이트를 여러 개의 사이트맵 파일로 나누어 각각 관리하는 방법. 예를 들어, /sitemap1.xml, /sitemap2.xml처럼 분리 가능해요. |\n| 사이트맵 인덱스 파일 활용   | 여러 개의 사이트맵 파일을 묶어주는 ‘사이트맵 인덱스 파일’을 만들어 검색 엔진에 알려주는 방법입니다. 인덱스 파일은 각 사이트맵 파일의 위치를 포함합니다.  |\n\n\u003e 참고로, 사이트맵 인덱스 파일은 아래처럼 `\u003csitemapindex\u003e` 태그를 사용해 작성합니다.\n\n```js\n\u003csitemapindex xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\"\u003e\n  \u003csitemap\u003e\n    \u003cloc\u003ehttps://acme.com/sitemap1.xml\u003c/loc\u003e\n    \u003clastmod\u003e2023-04-01\u003c/lastmod\u003e\n  \u003c/sitemap\u003e\n  \u003csitemap\u003e\n    \u003cloc\u003ehttps://acme.com/sitemap2.xml\u003c/loc\u003e\n    \u003clastmod\u003e2023-04-05\u003c/lastmod\u003e\n  \u003c/sitemap\u003e\n\u003c/sitemapindex\u003e\n```\n\n이렇게 하면 검색 엔진은 인덱스 파일만 방문해 여러 사이트맵을 효과적으로 크롤링할 수 있어요. \n\n---\n\n사이트맵 나누기 방법을 이해하면, 큰 웹사이트 SEO 관리에 훨씬 유리해집니다. 필요에 따라 적절히 활용해 보세요! 혹시 궁금한 점 있으면 언제든 물어봐 주세요~\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n사이트맵을 여러 개로 나누는 방법에 대해 이야기해볼게요. Next.js에서 사이트맵은 기본적으로 app 디렉토리에 sitemap.xml 또는 sitemap.js(ts) 같은 파일을 생성해서 만들 수 있는데, 여기서 더 나아가 여러 경로 세그먼트에 걸쳐 여러 개의 사이트맵을 나누어 관리할 수 있어요. 예를 들어, app/sitemap.xml, app/products/sitemap.xml처럼 각각 독립적으로 관리하는 방식이죠.\n\n또 다른 방법으로는 `generateSitemaps` 함수를 사용하는 건데요, 이 함수는 여러 개의 사이트맵을 동적으로 생성할 때 유용합니다. 간단히 말하면, `generateSitemaps`에서 사이트맵 ID 배열을 반환하고, 거기에 맞춰 각 ID마다 별도의 사이트맵을 만드는 겁니다.\n\n아래 예제를 볼까요?\n\n```js\nimport type { MetadataRoute } from 'next'\nimport { BASE_URL } from '@/app/lib/constants'\n \nexport async function generateSitemaps() {\n  // 전체 상품 수를 가져와서 사이트맵 개수를 산정할 수 있겠지만 여기선 예시로 4개의 ID를 만들었어요.\n  return [{ id: 0 }, { id: 1 }, { id: 2 }, { id: 3 }]\n}\n \nexport default async function sitemap({\n  id,\n}: {\n  id: number\n}): Promise\u003cMetadataRoute.Sitemap\u003e {\n  // 구글은 한 사이트맵에 최대 50,000 URL을 허용해요.\n  const start = id * 50000\n  const end = start + 50000\n  // 데이터베이스 쿼리를 통해 특정 범위의 상품을 받아옵니다.\n  const products = await getProducts(\n    `SELECT id, date FROM products WHERE id BETWEEN ${start} AND ${end}`\n  )\n  // 상품마다 URL과 마지막 수정일을 반환하세요.\n  return products.map((product) =\u003e ({\n    url: `${BASE_URL}/product/${product.id}`,\n    lastModified: product.date,\n  }))\n}\n```\n\n위 방식대로 하면 실제 생성되는 사이트맵 파일은 `/product/sitemap/0.xml`부터 `/product/sitemap/3.xml`까지 각 ID별로 존재하게 됩니다.\n\n### 참고 팁!\n- 사이트맵을 여러 개로 나누면 검색엔진 크롤러가 한꺼번에 너무 많은 URL을 받지 않아서 효율적이에요.\n- `generateSitemaps`와 `sitemap` 함수를 함께 써서 동적으로 필요한 만큼 파일을 만들 수 있으니, 상품이나 게시글이 엄청 많을 때 특히 유용합니다.\n- `/robots.txt` 파일에 이런 사이트맵 URL들을 모두 등록하거나, 사이트맵 인덱스를 만들어서 크롤러에게 알려주는 것도 잊지 마세요!\n\n이제 대규모 프로젝트에서 사이트맵 관리가 훨씬 수월해지겠죠? 궁금한 점 있으면 언제든 물어봐요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\ngenerateSitemaps API에 대한 더 자세한 정보는 공식 문서를 참고하시면 좋아요.\n\n## 반환값\n\n`sitemap.xml`, `sitemap.ts`, 또는 `sitemap.js`에서 기본으로 내보내는 함수는 아래처럼 특정 속성을 가진 객체들의 배열을 반환해야 해요:\n\n```ts\ntype Sitemap = Array\u003c{\n  url: string\n  lastModified?: string | Date\n  changeFrequency?:\n    | 'always'\n    | 'hourly'\n    | 'daily'\n    | 'weekly'\n    | 'monthly'\n    | 'yearly'\n    | 'never'\n  priority?: number\n  alternates?: {\n    languages?: {\n      [languageCode: string]: string\n    }\n  }\n}\u003e\n```\n\n### 속성 설명\n- `url`: 필수! 사이트맵에 등록할 URL입니다.\n- `lastModified`: 해당 페이지가 마지막으로 수정된 날짜를 나타내요. 문자열(ISO 포맷)이나 Date 객체 모두 가능해요.\n- `changeFrequency`: 검색 엔진에게 페이지가 얼마나 자주 변경되는지 알릴 때 쓰입니다. 기본값은 없으므로 필요할 때만 넣으시면 돼요.\n- `priority`: URL 우선순위를 0.0에서 1.0 사이의 숫자로 지정합니다. 기본값은 0.5이고, 높을수록 중요하다고 간주해요.\n- `alternates.languages`: 다국어 페이지가 있을 때, 각 언어별 URL을 명시할 수 있어요. 예를 들면 `{ en: \"/en/page\", ko: \"/ko/page\" }` 이런 식입니다.\n\n---\n\n### 팁 + @\n사이트맵을 잘 작성해두면 검색 엔진 최적화(SEO)에 큰 도움이 된답니다. 특히 `lastModified`나 `changeFrequency`를 적절히 지정해 두면 크롤러가 페이지 업데이트를 빠르게 인지해서 노출이 더 좋아질 수 있어요.  \n또한 다국어 사이트라면 `alternates.languages`를 꼭 활용해 보세요. 구글 등에서 올바르게 다국어 페이지를 인식하는 데 도움이 됩니다.\n\n혹시 사이트맵 자동 생성 도구를 사용 중이라면, 이런 반환 객체 형식을 참고해서 커스터마이징 해보는 것도 좋겠죠?ㅎㅎ\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 버전 히스토리\n\n| 버전       | 변경사항                                       |\n|------------|--------------------------------------------|\n| `v14.2.0`  | 다국어 지원 기능 추가                          |\n| `v13.4.14` | 사이트맵에 `changeFrequency`와 `priority` 속성 추가 |\n| `v13.3.0`  | 사이트맵 기능 도입                             |\n\n---\n\n간단하게 버전별 주요 변경사항을 정리해봤어요. 특히 사이트맵 관련 기능이 점점 강화되고 있다는 걸 볼 수 있는데요, 웹사이트 SEO 최적화에 관심이 있다면 `changeFrequency`(변경 빈도)와 `priority`(우선순위) 속성이 어떤 의미인지 꼭 알아두시는 걸 추천드려요. 이 속성들을 잘 활용하면 검색 엔진이 내 사이트를 더 잘 이해하고, 중요한 페이지를 더 빠르게 크롤링하도록 도와준답니다!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":18},{"title":"웹 SEO를 위한 robots.txt 작성과 활용법","description":"","date":"2025-04-22 02:53","slug":"2025-04-22-robotstxt","content":"\n\n# robots.txt 파일 쉽게 만들기\n\n웹사이트를 운영하다 보면, 검색 엔진 봇들이 우리 사이트를 어떻게 크롤링할지 정하는 게 중요한데요. 그럴 때 쓰는 게 바로 **robots.txt** 파일이에요. 이 파일을 웹사이트의 루트 디렉터리에 넣으면, 검색 엔진 크롤러에게 “여기까지는 들어와도 돼”, “여기는 접근하지마”라고 알려줄 수 있죠.\n\n---\n\n## 기본적인 robots.txt 예시\n\n```js\nUser-Agent: *\nAllow: /\nDisallow: /private/\n\nSitemap: https://acme.com/sitemap.xml\n```\n\n- `User-Agent: *` : 모든 크롤러에 적용한다는 뜻!  \n- `Allow: /` : 사이트 전체를 접근허용해요.  \n- `Disallow: /private/` : `/private/` 경로 아래는 크롤링 금지!  \n- `Sitemap` : 사이트맵 URL을 알려주면 봇들이 페이지 구조를 더 잘 알 수 있답니다.\n\n---\n\n## 알아두면 좋은 점!\n\n- robots.txt 파일은 “규칙”이지만, 강제성이 없다 보니 악의적인 봇은 무시할 수도 있어요.  \n- CSS, JS 같은 리소스가 차단되지 않게 하시는 게 좋아요. 구글 등 주요 검색 엔진은 이런 파일을 분석해서 페이지를 제대로 이해하거든요.  \n- 꼭 사이트 루트에 위치해야 하며, 경로를 잘못 넣으면 크롤러가 못 찾을 수 있어요.  \n- 사이트맵 URL 적는 것도 함께 하면 SEO에 도움 됩니다!\n\nrobots.txt는 단순하면서도 웹사이트 검색 노출을 관리하는 데 중요한 파일이니, 위 내용을 참고해서 꼭 한 번만 세팅해 보세요! 그럼 여러분 사이트에 맞는 최적의 SEO 환경을 만들 수 있을 거예요. 😄\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Robots 파일 생성하기\n\n웹사이트를 검색엔진이 어떻게 크롤링해야 하는지 알려주는 `robots.txt` 파일을 Next.js에서 쉽게 만들 수 있어요. 이때 `robots.js` 혹은 `robots.ts` 파일을 만들어서 `Robots` 객체를 반환하면 됩니다.\n\n```js\nimport type { MetadataRoute } from 'next'\n\nexport default function robots(): MetadataRoute.Robots {\n  return {\n    rules: {\n      userAgent: '*',       // 모든 봇에 대해 적용\n      allow: '/',           // 루트 디렉토리는 크롤링 허용\n      disallow: '/private/', // '/private/' 경로는 크롤링 금지\n    },\n    sitemap: 'https://acme.com/sitemap.xml', // 사이트맵 위치 지정\n  }\n}\n```\n\n### 알아두면 좋은 점 🌟\n- `robots.js`는 Next.js의 **특별한 Route Handler**인데, 기본적으로 캐싱이 되어 있어요.  \n- 다만 동적 API(dynamic API)나 동적 구성(dynamic config)을 사용할 경우에는 캐싱되지 않습니다.  \n- 이 방식이 더 관리하기 편하고, 직접 `public/robots.txt` 파일을 만들지 않아도 되니 개발 속도가 빨라져요.\n\n### 개인적으로 팁!\n- 사이트에 아주 민감한 정보가 있다면, `.env` 파일이나 서버 설정으로 크롤링 금지 경로를 관리하는 것도 좋아요.  \n- 그리고 구글 서치 콘솔 같은 도구에 사이트맵 URL을 등록해두면 검색엔진 최적화에도 도움이 됩니다.\n\n이렇게 설정만 하면 여러분 사이트에 맞는 `robots.txt`를 편리하게 관리할 수 있어요! 🕷️🚫\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n출력 예시:\n\n```js\nUser-Agent: *\nAllow: /\nDisallow: /private/\n\nSitemap: https://acme.com/sitemap.xml\n```\n\n### 특정 사용자 에이전트 맞춤 설정하기\n\n검색 엔진 봇마다 사이트 크롤링 방식을 다르게 설정하고 싶을 때가 있죠? 이런 경우에는 `rules` 속성에 사용자 에이전트(User-Agent) 배열을 전달해서 각각을 개별적으로 지정할 수 있어요. 예를 들어, 이렇게 활용할 수 있습니다:\n\n```js\nrules: [\n  {\n    userAgent: ['Googlebot', 'Bingbot'],\n    allow: ['/public'],\n    disallow: ['/private']\n  },\n  {\n    userAgent: ['*'],\n    disallow: ['/admin']\n  }\n]\n```\n\n위처럼 하면 `Googlebot`과 `Bingbot`은 `/public` 경로를 허용하고 `/private`는 차단하지만, 모든 다른 봇들은 `/admin` 경로만 차단하도록 설정할 수 있죠.\n\n추가 팁으로, 잘 구성된 `robots.txt`는 검색엔진 최적화(SEO)에도 도움을 주니 꼭 꼼꼼히 작성해 보세요! 그리고 필요하다면 사이트맵 위치도 명확히 표시해주면 크롤러가 사이트 구조를 더 잘 파악할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번에는 Next.js에서 `MetadataRoute.Robots` 타입을 이용해 robots.txt를 설정하는 방법에 대해 살펴볼게요.\n\n위 예제 코드를 보면 `robots()` 함수가 `MetadataRoute.Robots` 타입 객체를 반환하고 있습니다. 이 객체는 검색 엔진 크롤러들이 어떤 경로를 탐색할 수 있는지 세밀하게 조절할 수 있어요.\n\n```js\nexport default function robots(): MetadataRoute.Robots {\n  return {\n    rules: [\n      {\n        userAgent: 'Googlebot',\n        allow: ['/'],\n        disallow: '/private/',\n      },\n      {\n        userAgent: ['Applebot', 'Bingbot'],\n        disallow: ['/'],\n      },\n    ],\n    sitemap: 'https://acme.com/sitemap.xml',\n  }\n}\n```\n\n이 설정은 다음과 같은 의미를 갖는데요:\n\n| User-Agent  | Allow | Disallow   |\n|-------------|-------|------------|\n| Googlebot   | /     | /private/  |\n| Applebot    |       | /          |\n| Bingbot     |       | /          |\n\n- Googlebot에게는 전체 경로를 허용하지만 `/private/`는 막습니다.\n- Applebot과 Bingbot은 사이트 전체 접근 금지입니다.\n- Sitemap 위치도 명시되어 있어 크롤러가 쉽게 사이트맵을 찾을 수 있어요.\n\n이렇게 하면 robots.txt는 다음과 같이 생성됩니다:\n\n\nUser-Agent: Googlebot\nAllow: /\nDisallow: /private/\n\nUser-Agent: Applebot\nDisallow: /\n\nUser-Agent: Bingbot\nDisallow: /\n\nSitemap: https://acme.com/sitemap.xml\n\n\n### 여기서 알아두면 좋은 점\n- `allow`와 `disallow`를 배열로 줄 수도 있어서 여러 경로를 지정할 수 있어요.\n- `userAgent`도 문자열 하나나 배열로 여러 봇을 지정 가능해서 편리하죠.\n- 사이트맵 URL 꼭 포함하는 걸 추천합니다. 크롤러가 사이트 구조를 더 빠르게 파악하거든요.\n\n이 기능은 Next.js 13부터 정식 지원하면서 서버 컴포넌트 안에서 손쉽게 robots.txt 처리를 할 수 있어요. 예전엔 따로 파일을 만들어야 해서 좀 번거로웠는데, 이제 훨씬 깔끔하게 관리할 수 있답니다.\n\n필요하면 robots.txt뿐만 아니라 `MetadataRoute` 타입으로 `favicon`이나 `manifest`도 관리할 수 있으니까 Next.js 공식 문서도 한번 살펴봐 보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```ts\ntype Robots = {\n  rules:\n    | {\n        userAgent?: string | string[]\n        allow?: string | string[]\n        disallow?: string | string[]\n        crawlDelay?: number\n      }\n    | Array\u003c{\n        userAgent: string | string[]\n        allow?: string | string[]\n        disallow?: string | string[]\n        crawlDelay?: number\n      }\u003e\n  sitemap?: string | string[]\n  host?: string\n}\n```\n\n## 버전 히스토리\n\n| Version   | Changes               |\n|-----------|-----------------------|\n| `v13.3.0` | `robots`가 도입되었습니다. |\n\n---\n\n### robots 타입 살짝 풀어보기!\n\n위 타입은 주로 웹사이트의 `robots.txt` 설정을 타입스크립트로 표현한 거예요. 웹 크롤러가 어떤 페이지는 크롤링해도 되고, 어떤 페이지는 금지해야 할 때 `robots.txt`를 사용하는데요, 이런 설정을 코드로 관리할 때 유용하죠.\n\n- `rules`는 크롤러 별로 어떤 경로를 허용(`allow`)하거나 차단(`disallow`)할지 설정해요.\n- `userAgent`는 어떤 크롤러에 대한 규칙인지 지정하는 부분이라, Googlebot, Bingbot 등 특정 크롤러 이름을 넣을 수 있어요. 배열로 여러 크롤러를 지정할 수도 있고요.\n- `crawlDelay`는 크롤러가 요청 사이에 얼마나 기다려야 하는지 초 단위로 설정합니다.\n- `sitemap`은 사이트맵 URL을 명시해 크롤러가 더 효율적으로 페이지를 찾게 돕고,\n- `host`는 사이트의 대표 도메인을 지정하는 값이에요.\n\n이 타입으로 `robots.txt`를 프로그램matically(프로그램적으로) 생성하거나, 동적으로 관리하는 툴을 만들 때 큰 도움이 될 거예요!\n\n필요하면 제가 간단한 예제도 함께 만들어볼게요. 관심 있으면 알려주세요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":7},{"title":"Next.js 15에서 OpenGraph-Image와 Twitter-Image 설정하는 방법 ","description":"","date":"2025-04-22 02:51","slug":"2025-04-22-opengraph-imageandtwitter-image","content":"\n\n# opengraph-image와 twitter-image 파일 컨벤션\n\n웹 개발할 때, 내가 만든 페이지를 누군가 SNS나 메신저에서 공유할 때 보여지는 썸네일 이미지, 한 번쯤 신경 써봤죠? 이때 중요한 게 바로 Open Graph 이미지와 Twitter 카드 이미지입니다. 이걸 제대로 설정해주면 공유할 때 내 콘텐츠가 더 눈에 띄고 프로페셔널해 보여요.\n\n여기서 소개할 opengraph-image와 twitter-image 파일 컨벤션은, 특정 라우트(경로)별로 이런 이미지를 쉽게 설정하는 방법이에요. 즉, 페이지별로 다르게 썸네일을 지정할 수 있다는 뜻이죠.\n\n---\n\n## Open Graph와 Twitter 이미지 설정 방법\n\n개발자나 블로거들이 흔히 쓰는 방법은 두 가지예요:\n\n(아래에서 자세하게 설명할게요!)\n\n---\n\n\u003e 참고: Open Graph(Open Graph Protocol)는 페이스북, 카카오톡 같은 소셜 미디어가 공유 링크를 표시할 때 사용하는 메타 데이터 규격이에요.  \n\u003e Twitter 카드도 이름 그대로 트위터에서 공유 링크 시 보이는 카드형 이미지나 요약 정보를 위한 메타 태그입니다.\n\n다음 메시지에서 두 가지 방법에 대해서 더 자세히 정리해드릴게요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n개발자 분들, 안녕하세요! 오늘은 Next.js에서 이미지를 다루는 방법에 대해 이야기해볼게요. 특히, 라우트 세그먼트(route segment)를 위한 오픈그래프(Open Graph) 이미지 설정하는 방법에 집중해보겠습니다.\n\n---\n\n## 이미지 파일로 이미지 설정하기 (.jpg, .png, .gif)\n\nNext.js에서는 라우트 세그먼트에 공유할 이미지를 쉽게 설정할 수 있어요. 방법은 간단히 세그먼트 폴더 안에 `opengraph-image` 또는 `twitter-image`라는 이름의 이미지 파일을 넣어주면 됩니다.\n\n예를 들어, `/about` 페이지에 대한 오픈그래프 이미지를 설정하고 싶다면 `/about/opengraph-image.jpg` 파일을 넣으면 돼요.\n\n그럼 Next.js가 해당 이미지를 자동으로 인식해서, 여러분의 앱 `head` 태그 안에 적절한 메타 태그를 삽입해 줍니다. 즉, `\u003cmeta property=\"og:image\" content=\"...\"\u003e` 같은 태그들이 자동으로 생성되는 거죠!\n\n이 방식의 장점은 별도의 코드 작업 없이 이미지만 해당 위치에 두면 알아서 처리해준다는 거예요. 덕분에 SEO나 공유하기 좋은 이미지 설정을 간편하게 할 수 있죠.\n\n---\n\n### 참고로, 이미지 파일명과 경로가 정말 중요해요!\n\n- 파일명은 **반드시 정확**하게 `opengraph-image` 또는 `twitter-image` 여야 합니다.\n- 지원되는 확장자는 `.jpg`, `.png`, `.gif` 등 표준 이미지 포맷들입니다.\n- 여러 이미지 포맷 중에 최적화된 포맷을 선택하는 것도 중요해요. 예를 들어, 투명 배경이 필요하면 PNG, 사진이라면 JPG가 적합합니다.\n\n---\n\n다음에는 이미지 파일을 직접 업로드하지 않고, 자바스크립트 코드로 이미지를 생성하는 방법도 소개해 드릴게요! (예: .js, .ts, .tsx 파일 사용)\n\n그럼 여기까지 알아두시면 라우트별 공유 이미지 설정은 문제없겠네요. 즐코딩! 🚀\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 파일 네이밍 규칙과 지원하는 파일 형식을 정리한 표입니다. 참고로 파일 크기 제한도 있으니 꼭 확인해주세요!\n\n| File convention            | Supported file types               |\n|---------------------------|----------------------------------|\n| [opengraph-image](#opengraph-image)       | `.jpg`, `.jpeg`, `.png`, `.gif`         |\n| [twitter-image](#twitter-image)           | `.jpg`, `.jpeg`, `.png`, `.gif`         |\n| [opengraph-image.alt](#opengraph-imagealttxt) | `.txt`                              |\n| [twitter-image.alt](#twitter-imagealttxt)      | `.txt`                              |\n\n\u003e 알아두면 좋은 점:\n\u003e - `twitter-image` 파일 크기는 5MB를 넘으면 안 됩니다.\n\u003e - `opengraph-image` 파일 크기는 8MB를 넘지 않아야 합니다.\n\u003e - 만약 이 크기 제한을 넘으면 빌드가 실패하니 주의하세요!\n\n---\n\n### opengraph-image\n\n`opengraph-image.(jpg|jpeg|png|gif)` 형식의 이미지를 원하는 라우트 세그먼트에 추가할 수 있습니다.\n\n---\n\n추가로, opengraph 이미지와 트위터 이미지 모두 소셜 미디어에서 링크를 공유할 때 미리보기 이미지로 쓰이니, 가능한 한 눈에 띄고 관련성이 높은 이미지로 준비하는 게 좋아요. 그리고 alt 텍스트 파일(`.txt`)을 함께 제공하면 이미지가 잘 로드되지 않을 때 대체 텍스트로 활용할 수 있어서 접근성 측면에서도 도움이 됩니다. \n\n파일 크기가 크면 로딩 시간이 길어질 수 있으니 이미지 최적화도 꼭 챙기시길 바래요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 코드는 웹 페이지의 메타 태그를 설정하는 예시로, 특히 SNS 공유 시에 어떤 이미지가 어떻게 표시될지 지정하는 부분이에요. 조금 더 쉽게 설명드릴게요!\n\n### og:image (Open Graph 이미지)\n\n```html\n\u003cmeta property=\"og:image\" content=\"\u003cgenerated\u003e\" /\u003e\n\u003cmeta property=\"og:image:type\" content=\"\u003cgenerated\u003e\" /\u003e\n\u003cmeta property=\"og:image:width\" content=\"\u003cgenerated\u003e\" /\u003e\n\u003cmeta property=\"og:image:height\" content=\"\u003cgenerated\u003e\" /\u003e\n```\n\n- `og:image`: 페이스북, 카카오톡 같은 SNS에서 공유될 때 썸네일로 사용할 이미지 URL이에요.\n- `og:image:type`: 이미지의 타입(jpeg, png 등)을 알려주는 태그에요.\n- `og:image:width`, `og:image:height`: 이미지의 가로, 세로 크기를 픽셀 단위로 알려줘요.\n\n이걸 잘 설정하면 공유할 때 이미지가 깨지거나 엉뚱한 이미지가 나오는 걸 막을 수 있어요.\n\n---\n\n### twitter-image (트위터 전용 이미지)\n\n```html\n\u003cmeta name=\"twitter:image\" content=\"\u003cgenerated\u003e\" /\u003e\n\u003cmeta name=\"twitter:image:type\" content=\"\u003cgenerated\u003e\" /\u003e\n\u003cmeta name=\"twitter:image:width\" content=\"\u003cgenerated\u003e\" /\u003e\n\u003cmeta name=\"twitter:image:height\" content=\"\u003cgenerated\u003e\" /\u003e\n```\n\n- `twitter:image`: 트위터에서 공유 시 사용할 이미지 URL입니다.\n- `twitter:image:type`, `twitter:image:width`, `twitter:image:height`: Open Graph와 비슷하게 이미지 타입과 크기를 알려줘요.\n\n트위터는 트위터 카드라는 시스템이 있는데, 이 태그를 넣어줘야 멋진 카드 형태로 공유할 수 있어요.\n\n---\n\n### 추가 TIP!\n\n- 보통 og 이미지와 twitter 이미지 주소를 동일하게 쓸 때가 많지만, 필요에 따라 다른 이미지를 지정해도 돼요.\n- 이미지 권장 크기는 SNS마다 조금씩 다르긴 하지만, 최소한 1200x630(px) 정도를 권장해요. 그래야 고해상도 화면에서도 잘 보여요.\n- 이미지 URL은 절대경로(https://... )로 넣어야 하므로 주의하세요!\n\n### 요약\n\n| 태그 종류         | 목적                         | 속성 예시                          |\n|-----------------|----------------------------|---------------------------------|\n| og:image        | 페이스북, 카카오톡 공유 이미지 | content, type, width, height    |\n| twitter:image   | 트위터 공유 이미지           | content, type, width, height    |\n\n이렇게 설정해주면 공유할 때 더 깔끔하고 전문적인 모습으로 보여질 수 있어요! 나중에 내 블로그나 서비스에 SNS 공유 기능 붙일 때 꼭 참고하세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### opengraph-image.alt.txt 파일 활용법\n\n웹사이트를 운영하다 보면 **Open Graph 이미지**(SNS에 공유할 때 미리보기 이미지)와 함께 그 이미지의 대체 텍스트(alt text)를 정의해야 할 때가 있어요. 대체 텍스트는 이미지가 로드되지 않을 때 보여지거나, 스크린 리더 사용자에게 이미지 내용을 설명해주는 중요한 역할을 하죠.\n\n이때 **opengraph-image.alt.txt** 파일을 사용하는 방법이 있어요. Open Graph 이미지 파일(jpg, jpeg, png, gif)이 있는 폴더 혹은 경로와 같은 위치에 이 텍스트 파일을 넣어서 이미지의 alt 텍스트를 지정할 수 있습니다.\n\n예시를 들어볼게요.\n\n```js\nAbout Acme\n```\n\n이렇게 텍스트 파일에 이미지에 대한 설명을 적어두면, HTML 헤더 안에 다음과 같은 메타 태그가 자동으로 생성될 수 있어요.\n\n```html\n\u003cmeta property=\"og:image:alt\" content=\"About Acme\" /\u003e\n```\n\n이 메타 태그는 검색 엔진 최적화(SEO)에도 도움이 되고, 접근성(Accessibility) 측면에서도 매우 유용합니다.  \n물론, 직접 `\u003cmeta\u003e` 태그를 HTML에 넣어줘도 되지만, 파일로 관리하면 여러 이미지의 alt 텍스트를 일괄 관리하기 더 편리해요.\n\n---\n\n**추가 팁!**  \n- alt 텍스트는 이미지의 내용을 간결하고 명확하게 설명하는 문장이 좋아요.  \n- 너무 길거나 장황하면 오히려 독이 될 수 있으니 적당히 짧고 핵심을 담는 게 중요합니다.  \n- Open Graph 태그를 잘 관리하면 페이스북, 트위터, 카카오톡 등 다양한 SNS에서 링크 공유 시 예쁘고 의미 있는 미리보기를 보여줄 수 있습니다.\n\n따라서, `opengraph-image.alt.txt` 파일을 잘 활용해서 더 완성도 높고 친절한 웹 콘텐츠를 만들어보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n트위터 이미지를 사용할 때 이미지 설명(alt text)을 꼭 챙기는 게 좋아요. 왜냐하면 이미지가 제대로 로딩 안 될 때 사용자에게 대체 텍스트로 보여줄 수 있고, 접근성 측면에서도 도움이 되거든요.\n\n여기서 `twitter-image.alt.txt`라는 파일은 여러분이 올린 트위터 이미지 파일(jpg, png, gif 등)과 같은 폴더(경로)에 두면 돼요. 이 파일 안에는 이미지에 대한 간단한 설명을 담아두는 거죠.\n\n예를 들어, 이미지가 \"About Acme\"이라는 내용을 담았다면,  \n`twitter-image.alt.txt` 안에는 이렇게 적어요:\n\n\nAbout Acme\n\n\n그리고 만약 HTML 메타 태그로 직접 추가할 경우라면 이렇게 쓸 수 있답니다:\n\n```html\n\u003cmeta property=\"twitter:image:alt\" content=\"About Acme\" /\u003e\n```\n\n사실 이 작업이 왜 중요하냐면, 트위터 같은 소셜 미디어 플랫폼에서 이미지를 공유할 때 설명이 있으면 더 접근성 높고, 사용자 경험도 좋아져요. 또한 이미지가 어떤 내용인지 검색 엔진 최적화(SEO)에도 조금 도움될 수 있답니다.\n\n간단하지만 놓치기 쉬운 부분, 꼭 챙겨주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 코드로 이미지 생성하기 (.js, .ts, .tsx)\n\n보통 이미지는 이미지 파일을 그대로 사용하는 경우가 많지만, 코드로 이미지를 직접 생성하는 것도 가능합니다.\n\n예를 들어, 특정 라우트 세그먼트에 공유 이미지(opengraph-image나 twitter-image)를 만들고 싶다면, `opengraph-image`나 `twitter-image`라는 이름의 라우트를 만들고 거기서 기본(default)으로 내보내는 함수를 작성하면 돼요.\n\n그리고 아래 표처럼 파일명 컨벤션과 지원하는 파일 타입도 정해져 있습니다:\n\n| 파일명 컨벤션         | 지원하는 파일 타입       |\n|--------------------|-------------------|\n| `opengraph-image`  | `.js`, `.ts`, `.tsx` |\n| `twitter-image`    | `.js`, `.ts`, `.tsx` |\n\n---\n\n### 조금 더 알아두면 좋은 팁!\n\n- 이렇게 코드로 이미지를 생성하면, 동적으로 텍스트, 배경색, 아이콘 등을 상황에 맞게 커스터마이징할 수 있어요.\n- 예를 들어 블로그 글마다 다른 오픈그래프 이미지를 자동으로 생성하고 싶을 때 굉장히 유용하죠.\n- React 컴포넌트 형식으로 이미지를 만들면서, SVG나 Canvas API를 활용하거나, headless 브라우저에서 캡처하는 방법도 있어요.\n  \n직접 만들어 보면 생각보다 재미있고 신기하니 한 번 도전해 보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n좋은 정보!\n\nNext.js에서 이미지를 생성할 때 기본적으로 정적으로 최적화(빌드 시 생성 및 캐시)된다는 점을 알고 있으면 좋아요. 단, Dynamic API나 캐시되지 않는 데이터를 사용하면 동적으로 처리됩니다. 그리고 한 파일 내에서 여러 이미지를 만들고 싶다면 `generateImageMetadata`를 활용할 수 있고요.\n\n특히 `opengraph-image.js`와 `twitter-image.js` 같은 라우트 핸들러(Route Handlers)는 기본적으로 캐시 처리되지만, Dynamic API 또는 다이나믹 설정을 사용하면 예외입니다.\n\n### 가장 간단한 이미지 생성법: ImageResponse API\n\n`next/og` 패키지의 `ImageResponse`를 사용하면 아주 쉽게 이미지 생성이 가능해요. 아래 예제를 한 번 볼게요.\n\n```js\nimport { ImageResponse } from 'next/og'\nimport { readFile } from 'node:fs/promises'\nimport { join } from 'node:path'\n\n// 이미지 메타 데이터\nexport const alt = 'About Acme'\nexport const size = {\n  width: 1200,\n  height: 630,\n}\n\nexport const contentType = 'image/png'\n\n// 이미지 생성 함수\nexport default async function Image() {\n  // 폰트 불러오기 (process.cwd()는 Next.js 프로젝트 루트 디렉터리)\n  const interSemiBold = await readFile(join(process.cwd(), 'assets/Inter-SemiBold.ttf'))\n\n  return new ImageResponse(\n    (\n      \u003cdiv\n        style={{\n          fontSize: 128,\n          background: 'white',\n          width: '100%',\n          height: '100%',\n          display: 'flex',\n          alignItems: 'center',\n          justifyContent: 'center',\n        }}\n      \u003e\n        About Acme\n      \u003c/div\u003e\n    ),\n    {\n      ...size,\n      fonts: [\n        {\n          name: 'Inter',\n          data: interSemiBold,\n          style: 'normal',\n          weight: 400,\n        },\n      ],\n    }\n  )\n}\n```\n\n여기서 중요한 점은 직접 폰트를 로드해서 이미지 안에 텍스트를 쓸 때 폰트가 제대로 렌더되도록 하는 거예요. 그리고 스타일을 인라인으로 줘서 기본적인 레이아웃도 잡을 수 있죠.\n\n만들어진 이미지는 Open Graph 혹은 트위터 카드 메타 태그에서 사용할 수 있는데요:\n\n```html\n\u003cmeta property=\"og:image\" content=\"\u003cgenerated\u003e\" /\u003e\n\u003cmeta property=\"og:image:alt\" content=\"About Acme\" /\u003e\n\u003cmeta property=\"og:image:type\" content=\"image/png\" /\u003e\n\u003cmeta property=\"og:image:width\" content=\"1200\" /\u003e\n\u003cmeta property=\"og:image:height\" content=\"630\" /\u003e\n```\n\n이렇게 넣어주면 SNS에 공유될 때 예쁜 미리보기 이미지가 나타납니다.\n\n---\n\n### 추가 팁!\n\n- 이미지 크기(`width`, `height`)는 SNS 공유용으로 권장되는 크기를 따라야 해요. 보통 1200x630이 표준입니다.\n- `ImageResponse`의 JSX 내부에서는 스타일이나 레이아웃도 마음껏 커스터마이징할 수 있으니, 브랜드 컬러나 로고 넣기도 어렵지 않아요.\n- 폰트 파일은 프로젝트에 포함시키거나 CDN에서 로드해도 되고, 성능을 위해 필요한 폰트만 정확히 불러오는 게 좋아요.\n- 서버 컴포넌트에서만 사용 가능하다는 것도 기억하세요!\n\n이렇게 Next.js의 이미지 생성 기능을 활용하면, SEO와 SNS 공유에서 경쟁력을 크게 높일 수 있습니다. 개발하면서 꼭 한번 써보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### Props\n\n기본으로 내보내는 함수가 받는 props는 다음과 같아요:\n\n#### params (선택 사항)\n\n이건 동적 라우트 파라미터들을 담고 있는 객체예요. 루트 세그먼트부터 opengraph-image나 twitter-image 세그먼트까지의 경로에 있는 모든 동적 파라미터들이 들어있답니다.\n\n---\n\n추가로 설명하자면, Next.js 같은 프레임워크에서 동적 라우트(dynamic route)는 URL 일부가 변할 수 있을 때 사용되는데, 예를 들어 `/posts/[id]`처럼 `id`가 동적으로 변하죠. 이런 경우 이 params 객체를 통해 해당 URL에서 어떤 값이 왔는지 쉽게 받아서 처리할 수 있답니다.\n\nMarkdown 표로 정리하면:\n\n| Prop   | 설명                                                                    | 선택 여부  |\n|--------|-------------------------------------------------------------------------|------------|\n| params | 동적 라우트 파라미터들. 루트부터 현재 세그먼트까지의 경로 파라미터들이 포함돼 있음. | 선택 사항   |\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js 13의 App 디렉토리에서 Open Graph 이미지를 동적으로 생성할 때, `params`를 받아서 경로에 맞는 데이터를 처리하는 방식을 알아볼게요.\n\n```js\nexport default function Image({ params }: { params: { slug: string } }) {\n  // ...\n}\n```\n\n위 예시는 `params` 안에 `slug`라는 문자열이 들어오는 컴포넌트의 기본 형태예요. 이 `params`는 URL 경로를 기반으로 자동으로 전달되죠.\n\n아래는 라우트별 `params` 값과 매칭되는 예시입니다.\n\n| Route                                 | URL           | `params`                  |\n|-------------------------------------|---------------|---------------------------|\n| `app/shop/opengraph-image.js`          | `/shop`       | `undefined`               |\n| `app/shop/[slug]/opengraph-image.js`   | `/shop/1`     | `{ slug: '1' }`           |\n| `app/shop/[tag]/[item]/opengraph-image.js` | `/shop/1/2` | `{ tag: '1', item: '2' }` |\n\n즉, 동적 라우트(`[slug]` 등)를 사용하면 해당 경로 변수들이 `params` 객체로 들어와서 사용할 수 있어요.\n\n그리고 중요한 점! 이 Open Graph 이미지를 만드는 컴포넌트는 기본적으로 다음 중 하나를 반환해야 해요.\n\n- `Blob`\n- `ArrayBuffer`\n- `TypedArray`\n- `DataView`\n- `ReadableStream`\n- `Response`\n\n이 중 하나를 반환하면 Next.js가 이미지로 자동 변환해주는 거죠.\n\n---\n\n### 좀 더 쉽게 설명하자면\n\n라우팅에 따라 Open Graph용 이미지 생성 로직을 분리할 수 있는데, URL에 포함된 변수들을 `params`로 받아서 이미지 내용에 반영할 수 있어요. 예를 들어 `/shop/1`이라면 `slug`가 `'1'`이 들어와서 해당 제품 정보를 사용해 이미지를 그리는 식입니다.\n\n또한 반환 타입에 제약이 있는데, 이 반환값을 Next.js가 받아서 최종 이미지 파일을 만들어 주기 때문에 꼭 위 타입 중 하나로 반환해야 하고, 보통은 `Response` 객체를 많이 써요. \n\n이미지 생성에 대해 익숙하지 않다면, `@vercel/og` 같은 유틸리티를 사용해서 React 컴포넌트처럼 그려주고 그걸 바로 이미지로 변환시켜 주는 라이브러리도 추천드립니다.\n\n\n---\n\n### 정리\n\n- `params`에는 URL 동적 세그먼트 값들이 담긴다.\n- 경로에 따라 `params`가 자동으로 전달된다.\n- Open Graph 이미지 함수는 Blob, Response 등 이미지를 표현할 수 있는 타입을 반환해야 한다.\n- 동적 라우트에 맞게 이미지를 동적으로 생성하는 데 딱 맞는 구조다.\n\n이제 이렇게 받은 `params`로 원하는 이미지 내용을 자유롭게 변경해 보세요! Next.js의 App 디렉토리 덕분에 라우트별 이미지 생성이 훨씬 간편해졌습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003e 참고로, ImageResponse는 이 반환 타입을 만족합니다.\n\n### Config exports\n\nopengraph-image 또는 twitter-image 경로에서 alt, size, contentType 변수를 export해서 이미지 메타데이터를 선택적으로 설정할 수 있어요.\n\n| Option      | Type                                                                                                        |\n|-------------|-------------------------------------------------------------------------------------------------------------|\n| [alt](#alt) | `string`                                                                                                    |\n| [size](#size) | `{ width: number; height: number }`                                                                        |\n| [contentType](#contenttype) | `string` - [이미지 MIME 타입 (참고 문서)](https://developer.mozilla.org/docs/Web/HTTP/Basics_of_HTTP/MIME_types#image_types) |\n\n---\n\n조금 덧붙여서 설명하자면, alt는 이미지가 로드되지 않거나 스크린 리더를 사용할 때 중요한 역할을 하는 텍스트라서 SEO나 접근성을 위해 꼭 설정하는 걸 권장합니다. size는 이미지의 가로, 세로 크기를 명시해서 클라이언트가 적절한 공간을 미리 잡을 수 있게 도와주고요. contentType은 이미지의 MIME 타입으로, 예를 들어 `image/png`, `image/jpeg` 등이 있는데, 이걸 정확히 지정해주면 브라우저에서 이미지 처리할 때 더 효율적으로 작동합니다.\n\nMIME 타입에 대해 잘 모르겠으면 위 MDN 링크 한 번 확인해보세요. 이미지뿐만 아니라 다양한 파일 타입에 대해 표준화된 정보를 얻을 수 있어서 개발할 때 많이 도움이 됩니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### alt 속성에 대해 알아볼까요?\n\n웹에서 이미지를 사용할 때 `alt` 속성은 정말 중요해요. 간단히 말해, `alt`는 이미지가 표시되지 않을 때 대신 보여주는 텍스트인데요, 시각장애가 있는 분들이 스크린리더를 통해 이미지를 이해할 수 있도록 도와주는 역할도 해줘요.\n\n예를 들어, 리액트 컴포넌트에서 `alt` 텍스트를 변수로 지정하는 방법은 이렇게 할 수 있어요:\n\n```js\nexport const alt = 'My images alt text'\n\nexport default function Image() {\n  return \u003cimg src=\"/path/to/image.jpg\" alt={alt} /\u003e\n}\n```\n\n또한, 소셜 미디어에서 공유할 때 사용하는 Open Graph 태그에도 `alt` 속성을 넣어줘서 이미지에 대한 추가 정보를 제공할 수 있답니다.\n\n```html\n\u003cmeta property=\"og:image:alt\" content=\"My images alt text\" /\u003e\n```\n\n이렇게 하면, 페이스북이나 트위터 같은 곳에서 이미지를 불러올 때 이 설명을 활용할 수 있어요.\n\n\u003e 참고로! `alt` 텍스트는 이미지 내용을 간결하면서도 충분히 설명할 수 있게 작성하는 게 좋아요. 그냥 '사진' 보다는 ‘서울의 남산타워 야경’처럼 구체적으로 적으면 효과적이에요.\n\n---\n\n### size 속성도 짚어볼게요\n\n이미지의 크기를 다룰 때도 중요하게 생각해야 할 게 바로 `size`에요. 보통 HTML에서는 `\u003cimg\u003e` 태그의 `width`, `height`로 크기를 조절하지만, 요즘은 반응형 디자인 때문에 CSS나 스타일 속성으로 크기를 정하는 경우가 많죠.\n\n```html\n\u003cimg src=\"/path/to/image.jpg\" alt=\"sample image\" width=\"200\" height=\"150\" /\u003e\n```\n\n하지만 이렇게 하게 되면 이미지 본연의 비율이 유지되지 않을 수 있으니, CSS에서 `max-width: 100%; height: auto;` 같은 설정으로 너비에 맞게 자동 조절하도록 하는 게 더 유연해요.\n\n```css\nimg {\n  max-width: 100%;\n  height: auto;\n}\n```\n\n또, 만약 리액트에서 사이즈 관련 값을 변수로 관리한다면 이렇게 활용할 수 있어요.\n\n```js\nexport const size = {\n  width: 200,\n  height: 150\n};\n\nexport default function Image() {\n  return \u003cimg src=\"/path/to/image.jpg\" alt=\"sample image\" width={size.width} height={size.height} /\u003e;\n}\n```\n\n\u003e 작은 팁 하나! 이미지 크기를 지정할 때는 실제 이미지 파일의 크기와 맞추거나, 리사이징해서 용량 낭비를 막는 게 페이지 로딩 속도에 도움이 돼요.\n\n---\n\n요약하자면, ‘alt’는 접근성과 SEO를 위해 꼭 필요한 속성이고, ‘size’는 디자인과 퍼포먼스에 직결된 중요한 부분이랍니다. 이미지 작업할 때 이 두 가지 꼭 챙기세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안녕하세요! 오늘은 웹 개발에서 자주 사용하는 이미지 메타(tag) 관련 내용을 조금 더 친근한 느낌으로 정리해볼게요.\n\n---\n\n### 이미지 크기 정보 — size 객체\n\n```js\nexport const size = { width: 1200, height: 630 }\n \nexport default function Image() {}\n```\n\n위 코드는 보통 이미지의 크기를 미리 정의할 때 사용해요. 특히 소셜 미디어나 SEO(Open Graph) 최적화할 때 이미지 크기를 명시하는 게 좋은데요. 여기서 `width`가 1200, `height`가 630인 픽셀 단위 크기를 지정했네요. 이 크기는 많은 SNS나 페이스북, 트위터에서 권장하는 OG 이미지 크기와도 잘 맞아서, 공유했을 때 이미지가 잘 보이도록 도와줍니다.\n\n---\n\n### 메타 태그로 이미지 크기 설정하기 (Open Graph)\n\n```html\n\u003cmeta property=\"og:image:width\" content=\"1200\" /\u003e\n\u003cmeta property=\"og:image:height\" content=\"630\" /\u003e\n```\n\n위 메타 태그들은 HTML 문서 안에 넣어서 페이스북 같은 소셜 미디어가 이미지를 정확한 크기로 인식하게 도와줍니다. \n\n\u003e 만약 이 부분을 안 넣으면, 요즘 SNS 플랫폼들이 자동으로 이미지 크기를 추정할 수는 있지만, 정확한 크기를 명시해주면 훨씬 깔끔하게 미리보기가 나와요!\n\n---\n\n### 이미지 타입 명시 — contentType\n\n```js\nexport const contentType = 'image/png'\n \nexport default function Image() {}\n```\n\n`contentType`은 이미지 파일 형식을 알려주는 변수입니다. 보통 png, jpg, jpeg, gif 등이 있어요. 클라이언트나 서버가 이미지를 처리할 때 타입을 알아야해서 명시해두면 좋아요.\n\n---\n\n## 한 눈에 보는 정리 테이블\n\n| 속성             | 값           | 설명                                   |\n|------------------|--------------|--------------------------------------|\n| size.width       | 1200         | 이미지 가로 픽셀                      |\n| size.height      | 630          | 이미지 세로 픽셀                      |\n| og:image:width   | 1200         | Open Graph 메타 태그 내 이미지 가로 크기 |\n| og:image:height  | 630          | Open Graph 메타 태그 내 이미지 세로 크기 |\n| contentType      | 'image/png'  | 이미지 파일 포맷 (PNG/JPEG 등)       |\n\n---\n\n### 추가 팁!\n\n- **이미지 크기**: OG 이미지 권장 크기는 보통 `1200x630` 픽셀이 가장 흔한데, 비율이 약 1.91:1 이거든요. 이 비율을 맞추면 SNS 공유 시 이미지가 잘려서 보이는 일 없이 깔끔하게 노출됩니다.\n\n- **Content-Type 중요성**: 서버에서 이미지 응답을 보낼 때도 이 MIME type을 정확하게 설정해주면, 클라이언트가 이미지를 올바르게 해석할 수 있습니다.\n\n- **Next.js 유저라면**: image 컴포넌트 내에 `width`, `height`를 고정해주면 레이아웃 shift 없이 좋은 퍼포먼스를 낼 수 있어요.\n\n---\n\n그럼 오늘 정리한 내용을 바탕으로 여러분이 만든 페이지가 소셜미디어에서 더 예쁘고 명확하게 보이길 바랄게요! 궁금한 점 있으면 댓글로 남겨주세요 :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n\u003cmeta property=\"og:image:type\" content=\"image/png\" /\u003e\n```\n\n#### Route Segment Config (라우트 세그먼트 설정)\n\nopengraph-image와 twitter-image는 특별한 Route Handlers인데요, 이것들은 Pages나 Layouts에서 사용하는 것과 똑같은 라우트 세그먼트 설정 옵션들을 사용할 수 있어요.\n\n### 예시들\n\n---\n\n여기서 잠깐! \"Route Segment Config\"는 Next.js나 비슷한 프레임워크에서 사용할 때, 각 URL 경로나 페이지 구간(segment)에 설정을 적용하는 방법이에요. 그래서 og:image나 twitter-image 같은 메타정보를 동적으로 설정하고 싶을 때 활용하면 굉장히 유용하답니다.\n\n예를 들면, 특정 페이지에 맞춰서 og:image를 다르게 지정하고 싶을 때, 바로 이 설정을 이용해서 쉽게 처리할 수 있어요.\n\nMarkdown 형식으로 표기하면 아래와 같은 식으로 말이죠:\n\n| 설정 이름               | 설명                              | 예시 값         |\n|-----------------------|---------------------------------|---------------|\n| `content`             | 실제 메타 태그에 들어갈 값         | `image/png`    |\n| `property=\"og:image:type\"` | Open Graph 프로토콜에서 이미지 타입 정의 | `image/png`    |\n\n필요하면 직접 이미지 타입 외에 사이즈 정보나 용량 같은 추가 데이터도 넣을 수 있으니 참고하세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n#### 외부 데이터 사용하기\n\n이번 예제에서는 `params` 객체와 외부 데이터를 활용해서 이미지를 생성하는 방법을 보여드릴게요.\n\n\u003e 알아두면 좋은 점: 기본적으로 이 방식으로 생성된 이미지는 정적으로 최적화돼요. 필요에 따라 fetch 옵션이나 라우트 세그먼트 옵션을 조정해서 이 동작을 바꿀 수 있습니다.\n\n```js\nimport { ImageResponse } from 'next/og'\n \nexport const alt = 'About Acme'\nexport const size = {\n  width: 1200,\n  height: 630,\n}\nexport const contentType = 'image/png'\n \nexport default async function Image({ params }: { params: { slug: string } }) {\n  // params.slug 값에 따라 외부 API에서 포스트 데이터를 가져옵니다.\n  const post = await fetch(`https://.../posts/${params.slug}`).then((res) =\u003e\n    res.json()\n  )\n \n  return new ImageResponse(\n    (\n      \u003cdiv\n        style={{\n          fontSize: 48,\n          background: 'white',\n          width: '100%',\n          height: '100%',\n          display: 'flex',\n          alignItems: 'center',\n          justifyContent: 'center',\n        }}\n      \u003e\n        {post.title}\n      \u003c/div\u003e\n    ),\n    {\n      ...size,\n    }\n  )\n}\n```\n\n---\n\n조금 더 풀어서 설명하면, 이 코드는 URL에서 전달받은 `slug` 값을 이용해 외부 API에서 해당 글(post) 정보를 불러와요. 그리고 그 글의 제목을 이미지 안에 크게 띄우는 거죠.\n\n여기서 `ImageResponse`는 Next.js의 Open Graph 이미지 생성 도구인데, 기본적으로 서버 사이드에서 실행되고 HTML 같은 JSX를 이미지로 렌더링해 줍니다. 그래서 동적으로 변하는 글 제목을 이미지에 넣을 수 있답니다.\n\n참고로 `fontSize`, `background` 같은 인라인 스타일을 `style` 객체 안에 제대로 넣어줘야 하고, `width`, `height` 등 여러 스타일을 조합해 원하는 레이아웃으로 만들 수 있어요.\n\n---\n\n추가 팁: 외부 데이터를 불러올 때 에러 핸들링을 꼭 해주는 게 좋아요. 예를 들어 API가 응답하지 않거나 데이터가 없을 경우를 대비해 기본값을 넣거나, 사용자에게 알림을 줄 수 있죠. 그래야 이미지 생성이 실패하지 않고 원활히 처리됩니다 :)\n\n그리고 만약 이미지가 너무 복잡해지면, CSS 스타일을 따로 작성하거나 React 컴포넌트로 분리해서 관리하는 것도 좋은 방법이에요. 이렇게 하면 가독성도 좋아지고 유지보수도 쉬워진답니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n#### Node.js 런타임에서 로컬 자산 사용하기\n\n이번 예제에서는 Node.js 런타임을 이용해 로컬 파일 시스템에서 이미지를 읽어오고, 그 이미지를 `img` 태그의 `src` 속성에 `ArrayBuffer` 형태로 전달하는 방법을 보여드릴게요. 여기서 중요한 점은, 로컬 자산(이미지 파일 등)은 프로젝트 최상위 경로(root)를 기준으로 두어야 한다는 거예요. 예제 소스 파일이 어디에 있든 상관없답니다.\n\n아래 코드를 보면 `readFile`로 이미지를 불러오고, `Uint8Array.from`을 이용해 `ArrayBuffer`로 변환하는 과정이 보이죠? 이렇게 하면 Next.js의 `ImageResponse`에 이미지를 전달할 수 있어요.\n\n```js\nimport { ImageResponse } from 'next/og'\nimport { join } from 'node:path'\nimport { readFile } from 'node:fs/promises'\n \nexport default async function Image() {\n  const logoData = await readFile(join(process.cwd(), 'logo.png'))\n  const logoSrc = Uint8Array.from(logoData).buffer\n \n  return new ImageResponse(\n    (\n      \u003cdiv\n        style={{\n          display: 'flex',\n          alignItems: 'center',\n          justifyContent: 'center',\n        }}\n      \u003e\n        \u003cimg src={logoSrc} height=\"100\" /\u003e\n      \u003c/div\u003e\n    )\n  )\n}\n```\n\n---\n\n### 여기서 조금 더 팁!\n\n- `process.cwd()`는 현재 Node.js 실행 경로(보통 프로젝트 루트)를 반환해요. 때문에 로컬 자산은 항상 프로젝트 루트 기준으로 경로를 잡는 게 좋아요.\n\n- `ArrayBuffer` 형태로 변환하는 이유는, 로컬 이미지 데이터를 바이너리 형태로 직접 다루면서 Next.js가 이미지를 처리할 수 있게 하기 위함입니다.\n\n- 만약 이미지를 직접 HTML의 `img` 태그에서 사용하고 싶으면, `data URL`로 변환하는 방법도 있지만 이번 경우처럼 바이너리 데이터를 직접 사용하는 게 효율적일 수 있어요.\n\n- 스타일링할 때 `style` 객체를 작성할 때는 반드시 중괄호(`{}`) 두 번 써서 JSX 객체 형태로 넣어야 하는 거, 잊지 마세요!\n\n이렇게 하면 Next.js와 Node.js 런타임을 활용해 로컬 이미지를 자유롭게 서버사이드에서 렌더링해볼 수 있답니다. 앞으로 이미지 처리 함께 파헤쳐봐요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n| Version  | Changes                                  |\n|----------|------------------------------------------|\n| `v13.3.0` | `opengraph-image`와 `twitter-image` 기능 추가됨 |\n\n이번에 `v13.3.0` 버전에서는 Open Graph 이미지와 트위터 이미지 기능이 새롭게 도입되었어요. 이 기능들은 주로 소셜 미디어에서 공유할 때 미리보기 이미지로 사용되는데, 덕분에 내 웹페이지가 좀 더 멋지고 눈에 띄게 보이도록 해줘요. 개인 블로그나 프로젝트 소개 페이지를 운영 중이라면 꼭 활용해보는 걸 추천합니다! 혹시 더 자세한 설정 방법이나 활용 팁이 궁금하면 댓글로 남겨주세요. 함께 공부해봐요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":25},{"title":"Nextjs15에서 manifest.json 설정하는 방법","description":"","date":"2025-04-22 02:50","slug":"2025-04-22-manifestjson","content":"\n\n# manifest.json이란?\n\n웹 앱을 만들 때 'manifest.json' 또는 'manifest.webmanifest' 파일을 루트 디렉토리에 넣어주는 게 좋아요. 이 파일은 웹 앱이 어떻게 동작하는지, 어떤 이름을 가졌는지, 아이콘은 무엇인지 등 브라우저가 알아야 할 정보를 담고 있답니다. 쉽게 말해, 내 웹 앱의 소개서를 만들어서 브라우저에게 알려주는 역할이에요.\n\n## 고정된(static) manifest 파일 예시\n\n아래는 간단한 manifest.json 예시입니다. 주로 이런 형식으로 만들어서 프로젝트 루트에 넣어주면 되죠.\n\n```json\n{\n  \"name\": \"My Next.js Application\",\n  \"short_name\": \"Next.js App\",\n  \"description\": \"An application built with Next.js\",\n  \"start_url\": \"/\"\n  // 기타 설정들...\n}\n```\n\n여기서 주요 속성들을 짚어볼게요.\n\n| 속성명       | 설명                                             |\n|--------------|--------------------------------------------------|\n| name         | 웹 앱의 전체 이름, 기기나 설치 시 표시됨         |\n| short_name   | 이름 대신 사용할 짧은 이름, 아이콘 밑 등에서 표시 |\n| description  | 앱에 대한 간단한 설명                             |\n| start_url    | 앱을 실행할 때 열릴 기본 URL                      |\n\n---\n\n### manifest.json을 왜 넣어야 할까?\n\n* **PWA 지원**: Progressive Web App을 지원하려면 필수! 홈 화면에 아이콘을 추가하거나 오프라인 모드 같은 기능을 쓸 때 manifest가 필요해요.\n\n* **탭 이름 및 아이콘 설정**: 브라우저 탭이나 북마크에 나타나는 이름과 아이콘을 설정할 수 있어요.\n\n* **앱처럼 보이게 하기**: 풀스크린 모드, 방향 고정 등 다양한 옵션도 manifest에서 설정 가능하니 더 앱다운 느낌을 줄 수 있죠.\n\n---\n\n### 참고! manifest.json에 자주 쓰이는 주요 옵션들\n\n| 속성명          | 설명                                                          |\n|-----------------|---------------------------------------------------------------|\n| icons           | 앱 아이콘 목록, 크기별 이미지를 배열로 넣음                     |\n| display         | 앱이 실행될 때 UI 모드 (예: standalone, fullscreen, minimal-ui) |\n| background_color| 앱 시작화면 배경색                                           |\n| theme_color     | 브라우저 툴바 색상 등, 테마 컬러                               |\n| scope           | 앱의 유효 범위 URL, 이 범위 내에서만 앱으로 인식됨             |\n\n---\n\nmanifest.json 설정만 잘해줘도 사용자 경험이 크게 향상되니, Next.js 같은 프레임워크에서 PWA를 고민한다면 꼭 챙겨보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 매니페스트 파일 생성하기\n\n이번에는 `manifest.js` 또는 `manifest.ts` 파일을 만들어서 `Manifest` 객체를 반환하는 방법을 알려드릴게요.\n\n\u003e 참고로 `manifest.js`는 Next.js의 특별한 Route Handler 중 하나예요. 기본적으로 캐시가 되지만, 만약 동적 API나 동적 설정 옵션을 사용하면 캐시되지 않아요.\n\n```js\nimport type { MetadataRoute } from 'next'\n \nexport default function manifest(): MetadataRoute.Manifest {\n  return {\n    name: 'Next.js App',\n    short_name: 'Next.js App',\n    description: 'Next.js App',\n    start_url: '/',\n    display: 'standalone',\n    background_color: '#fff',\n    theme_color: '#fff',\n    icons: [\n      {\n        src: '/favicon.ico',\n        sizes: 'any',\n        type: 'image/x-icon',\n      },\n    ],\n  }\n}\n```\n\n### 더 알아두면 좋은 팁!\n- `start_url`은 사용자가 앱을 실행했을 때 기본으로 열리는 경로를 설정하는 거예요. 보통 루트(`/`)로 지정하지만 필요에 따라 다르게 할 수 있어요.\n- `display` 옵션에는 `'standalone'` 외에도 `'fullscreen'`, `'minimal-ui'`, `'browser'` 등이 있어요. 각 옵션마다 앱을 어떻게 보여줄지 달라지니 원하는 사용자 경험에 맞게 선택하세요.\n- `icons` 배열에는 여러 크기의 아이콘을 넣어두는 게 좋아요. 그래야 다양한 기기와 해상도에서 깔끔하게 앱 아이콘이 보여지거든요.\n\n덤으로 매니페스트 파일은 PWA(Progressive Web App)를 만들 때 꼭 필요한 파일이니, 만약 여러분이 웹 앱을 좀 더 앱처럼 보이고 싶다면 꼭 만들어 보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### Manifest Object\n\nManifest Object는 웹 표준이 새로워짐에 따라 업데이트될 수 있는 다양한 옵션들을 담고 있는 객체예요. 최신 옵션들에 대해 자세히 알고 싶다면, TypeScript를 사용 중이라면 코드 에디터 안에서 `MetadataRoute.Manifest` 타입을 참고하는 게 가장 확실하고요. 그렇지 않으면 [MDN 문서](https://developer.mozilla.org/en-US/docs/Web/Manifest)를 보는 것도 좋은 방법이에요.\n\n참고로, Manifest Object는 주로 웹 앱이 어떻게 보이고 동작할지를 정의하는데 쓰여서, 푸시 알림, 아이콘, 시작 URL, 테마 컬러 같은 설정들을 포함하죠. 요즘에는 PWA(Progressive Web App)를 만들 때 꼭 필요한 요소 중 하나랍니다. 그래서 웹앱 개발자라면 한 번쯤 꼼꼼히 살펴볼 만한 부분이에요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":4},{"title":"nextjs 15에서 meta data 사용하는 방법","description":"","date":"2025-04-22 02:48","slug":"2025-04-22-MetadataFilesAPIReference","content":"\n\n# 메타데이터 파일 API 가이드\n\n이번 글에서는 메타데이터 파일에 관한 규칙과 사용법에 대해 다뤄볼게요. Next.js에선 \"파일 기반 메타데이터\"를 사용해서 각 경로(route)별로 메타 정보를 관리할 수 있어요.\n\n기본 아이디어는 특별한 메타데이터 파일들을 경로 폴더 안에 넣는 건데요, 크게 두 가지 방식으로 만들 수 있어요.\n\n- 정적 파일: 예를 들어 `opengraph-image.jpg` 같은 이미지 파일을 그대로 넣는 경우\n- 동적 파일: 예를 들어 `opengraph-image.js` 같이 코드를 실행해서 파일을 생성하는 경우\n\n파일을 이렇게 정의하면 Next.js가 알아서 이 파일들을 서빙해주고, 프로덕션 환경에선 캐싱을 위해 파일명에 해시 값을 붙여 관리해줘요. 그리고 페이지의 `\u003chead\u003e` 태그에 이 메타데이터에 맞게 URL, 파일 타입, 이미지 크기 같은 정보들을 자동으로 업데이트해줍니다.\n\n---\n\n이걸 이용하면 여러분이 직접 `\u003cmeta\u003e` 태그나 `\u003clink\u003e` 태그를 일일이 관리하는 수고를 줄일 수 있어요. 특히 SEO 최적화나 소셜 미디어 같은 외부 서비스에 정확한 정보를 보여줘야 할 때 매우 유용하답니다. \n\n그리고 동적 파일이 지원된다는 건, 상황에 따라 이미지나 메타 정보를 프로그래밍적으로 생성할 수 있다는 뜻이에요. 예를 들어 사용자 맞춤형 오픈그래프 이미지 만들기 같은 작업도 할 수 있겠죠.\n\n다음에는 실제 예시를 통해 어떻게 파일을 만들고 구성하는지 구체적으로 살펴볼게요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003e 알아두면 좋은 팁:\n특별한 라우트 핸들러들 — 예를 들어 sitemap.ts, opengraph-image.tsx, icon.tsx 같은 메타데이터 파일들은 기본적으로 캐싱이 됩니다.  \nmiddleware.ts와 함께 사용할 때는, 메타데이터 파일들이 캐싱 문제로 꼬이지 않도록 matcher 설정에서 이 파일들을 제외해 주는 게 좋아요.\n\n사실 이런 메타데이터 파일들은 자주 변경되지 않기 때문에 캐싱하는 게 성능 측면에서 유리하지만, 만약 미들웨어에서 특정 로직으로 캐싱을 우회해야 한다면 꼭 matcher를 잘 설정해 주세요. 그러면 불필요한 리퀘스트 차단이나 잘못된 데이터 제공 문제를 예방할 수 있거든요.\n\n혹시 middleware.ts를 처음 사용하신다면, matcher 옵션에 대해 간단히 설명하자면, 이 옵션을 통해 미들웨어가 적용될 URL 패턴을 정할 수 있는데, 여기서 제외 패턴을 설정하면 특정 파일이나 경로는 미들웨어의 적용 대상에서 빠집니다. 아주 유용하니 꼭 기억해두세요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":2},{"title":"2025년 Next.js 15에서 favicon, icon, apple-icon 쉽게 설정하는 방법","description":"","date":"2025-04-22 02:48","slug":"2025-04-22-faviconiconandapple-icon","content":"\n\n# favicon, icon, 그리고 apple-icon\n\n웹 애플리케이션이나 웹사이트를 만들 때, 한 번쯤 들어봤을 'favicon', 'icon', 'apple-icon'에 대해 이야기해볼게요. 이 파일들은 우리 앱이나 사이트에 아이콘을 설정할 수 있게 해주는데요. \n\n이 아이콘들은 웹 브라우저 탭, 스마트폰 홈 화면, 그리고 검색 엔진 결과에 표시되어 웹사이트의 정체성을 보여주고, 사용자 경험을 조금 더 풍부하게 만들어줘요.\n\n아이콘을 설정하는 방법에는 크게 두 가지가 있어요: \n\n(아래에서 각각의 방법과 구체적인 설정법도 함께 소개할게요.)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Next.js에서 앱 아이콘 설정하기: 이미지 파일과 코드 이용법\n\n안녕하세요! 오늘은 Next.js 프로젝트에서 앱 아이콘을 어떻게 설정하는지, 특히 이미지 파일이나 코드를 사용하는 방법에 대해 다뤄볼게요. 아이콘은 웹사이트나 앱을 한눈에 알아볼 수 있게 해주니까 정말 중요하죠. 자, 그럼 시작해볼까요?\n\n---\n\n## 1. 이미지 파일 사용하기 (.ico, .jpg, .png)\n\n### 기본 개념\nNext.js에서는 favicon, icon, 또는 apple-icon 이미지 파일을 `/app` 디렉터리 안에 넣어서 앱 아이콘을 설정할 수 있어요. 여기서 중요한 점은 favicon 이미지 파일은 `/app` 폴더의 최상위에 위치해야 한다는 점이에요.\n\n예를 들어, 이런 형식으로 위치시키면 돼요:\n\n\n/app/favicon.ico\n/app/apple-icon.png\n\n\n### 어떻게 작동하나요?\nNext.js가 빌드하거나 실행할 때, 이 파일들을 자동으로 감지해서 `\u003chead\u003e` 태그 안에 적절한 `\u003clink\u003e` 태그를 넣어줘요. 덕분에 우리가 하나하나 수동으로 태그를 추가하지 않아도 돼서 정말 편하답니다.\n\n### 주의할 점\n- favicon은 보통 `.ico` 형식을 많이 쓰지만, 요즘은 크기가 크고 투명한 PNG 파일도 흔하게 사용됩니다.\n- iOS 기기용 애플 아이콘(apple-touch-icon)도 추가해주면 좋죠.\n- `/app` 최상위에 위치하지 않으면 자동 인식이 안 되니 꼭 위치를 확인하세요!\n\n---\n\n## 2. 코드로 아이콘 생성하기 (.js, .ts, .tsx)\n\n### 이미지 대신 코드로 아이콘을 만들고 싶다면?\n\nNext.js나 React에서는 SVG를 컴포넌트로 만들어서 아이콘을 직접 렌더링할 수도 있어요. 예를 들면, `.tsx` 파일 안에 SVG 코드를 넣고, 필요할 때마다 해당 아이콘 컴포넌트를 호출하는 방식이죠.\n\n이 방법의 장점은:\n\n- 아이콘 크기, 색상, 애니메이션 등 커스터마이즈가 자유롭다\n- 별도의 이미지 파일 추가 없이 관리가 간편하다\n- 타입스크립트와도 잘 호환된다\n\n### 간단한 예시\n\n```tsx\nimport React from 'react';\n\nconst MyIcon = () =\u003e (\n  \u003csvg width=\"32\" height=\"32\" viewBox=\"0 0 32 32\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\n    \u003ccircle cx=\"16\" cy=\"16\" r=\"16\" fill=\"#4CAF50\" /\u003e\n    \u003cpath d=\"M16 8L24 24H8L16 8Z\" fill=\"white\" /\u003e\n  \u003c/svg\u003e\n);\n\nexport default MyIcon;\n```\n\n이렇게 만든 아이콘을 페이지나 컴포넌트에서 불러와서 쓸 수 있어요.\n\n---\n\n## 요약 비교 테이블\n\n| 방법               | 장점                                    | 단점                               | 사용 추천 상황                      |\n|--------------------|-----------------------------------------|----------------------------------|----------------------------------|\n| 이미지 파일 (.ico, .png) | 자동으로 `\u003chead\u003e`에 태그 추가, 간편              | 위치 제약 있음, 커스터마이징 불가     | 기본적인 favicon 설정 시           |\n| 코드 생성 (.js, .tsx)     | 커스터마이징 자유, 타입 안정성, 애니메이션 가능 | `\u003chead\u003e`에 자동 추가 안됨, 직접 추가 필요 | 커스텀 아이콘 UI 컴포넌트 만들 때  |\n\n---\n\n## 팁 한마디!\n\nfavicon은 단지 웹사이트 탭에 표시되는 것 뿐 아니라, 모바일 홈 화면 바로가기 아이콘, 웹 애플리케이션 아이콘 등 다양하게 사용돼요. 그러니 퀄리티 좋은 여러 크기 아이콘들을 준비해서 사용하는 게 좋아요. 추가로, [favicon.io](https://favicon.io/) 같은 온라인 툴을 통해 손쉽게 favicon을 생성하고 변환할 수도 있답니다.\n\n---\n\nNext.js 프로젝트에 맞는 아이콘 설정 방법, 이해하는 데 도움이 되었길 바라요! 궁금한 점 있으면 언제든지 댓글로 물어봐 주세요 :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 favicon, icon, apple-icon 파일 관련 규칙을 정리한 표입니다. 공식 문서나 개발하면서 참고하기 딱 좋아요!\n\n| 파일 명명 규칙       | 지원하는 파일 타입                              | 유효한 위치          |\n|--------------------|-------------------------------------------|-------------------|\n| [favicon](#favicon)      | `.ico`                                    | `app/`            |\n| [icon](#icon)            | `.ico`, `.jpg`, `.jpeg`, `.png`, `.svg`  | `app/**/*`        |\n| [apple-icon](#apple-icon) | `.jpg`, `.jpeg`, `.png`                    | `app/**/*`        |\n\n### favicon\n\nfavicon은 웹 브라우저 탭에 표시되는 아주 작은 아이콘을 의미하죠. 여기서는 `favicon.ico` 파일을 루트 경로인 `/app` 폴더에 넣으면 됩니다.\n\n```js\n\u003clink rel=\"icon\" href=\"/favicon.ico\" sizes=\"any\" /\u003e\n```\n\n이렇게 하면 기본적으로 모든 크기에서 아이콘이 잘 보이게 돼요.\n\n---\n\n추가로 알려드리자면, 아이콘 파일들을 `app` 내부 어디에 넣어도 되는데(`app/**/*`), favicon은 꼭 루트(`app/`)에 놓아야 한다는 점 기억하세요. 그리고 애플 기기(iPhone, iPad 등)에서 홈 화면에 추가할 때 사용하는 `apple-icon`은 PNG, JPG 같은 이미지 포맷을 활용합니다.\n\n개발하면서 아이콘을 여러 가지 사이즈로 준비하면 다양한 환경에서 사용자 경험이 더 좋으니, 가능하면 다양한 크기로 아이콘을 만들어 두는 걸 추천해요. 예를 들어, 16x16, 32x32, 180x180 같은 크기를 만들어 놓으면 좋죠!\n\n필요한 경우 SVG 사용도 고려할 수 있는데, SVG는 벡터 기반이라 해상도에 상관없이 선명하게 표시된답니다. 하지만 모든 브라우저나 플랫폼에서 100% 지원하는 건 아니니까 favicon용으로는 `ico`가 여전히 표준이에요.\n\n참고로 React, Next.js 같은 프레임워크에서는 이 폴더 구조에 맞춰 아이콘 파일을 배치하고, 필요한 메타 태그나 링크를 `\u003chead\u003e`에 추가해주면 쉽게 적용할 수 있어요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 아이콘 설정하기\n\n웹사이트에 아이콘을 추가하는 방법, 생각보다 간단해요! 보통 파비콘(favicon)이라고 부르는 아이콘은 `.ico`, `.jpg`, `.jpeg`, `.png`, `.svg` 같은 이미지 파일을 사용해요.\n\n기본적인 아이콘 추가 태그는 이렇게 생겼답니다:\n\n```js\n\u003clink\n  rel=\"icon\"\n  href=\"/icon?\u003cgenerated\u003e\"\n  type=\"image/\u003cgenerated\u003e\"\n  sizes=\"\u003cgenerated\u003e\"\n/\u003e\n```\n\n- `rel=\"icon\"`: 이 링크가 아이콘이라는 뜻이에요.\n- `href`: 실제 아이콘 파일 경로를 넣으면 되죠. `\u003cgenerated\u003e`는 파일명이나 쿼리 스트링으로 바꿔주세요.\n- `type`: 이미지 형식을 명시해줘요. 예를 들면, `image/png`, `image/svg+xml` 처럼요.\n- `sizes`: 아이콘 크기(px)를 말해주는데, 여러 크기를 지원하는게 좋습니다. 보통 `16x16`, `32x32` 등으로 설정해요.\n\n예를 들어, 사이트 루트에 `favicon.png`라는 파일을 쓴다면 이렇게 쓸 수 있어요:\n\n```html\n\u003clink rel=\"icon\" href=\"/favicon.png\" type=\"image/png\" sizes=\"32x32\" /\u003e\n```\n\n---\n\n### 애플 터치 아이콘 (apple-icon)\n\n아이폰이나 아이패드에서 홈 화면에 웹사이트를 추가할 때 뜨는 아이콘은 별도로 설정하는 게 좋아요. 이걸 \"애플 터치 아이콘\"이라고 불러요.\n\n```html\n\u003clink rel=\"apple-touch-icon\" href=\"/apple-icon.png\" sizes=\"180x180\" /\u003e\n```\n\n- `rel`: `apple-touch-icon`으로 설정하세요.\n- `href`: 아이콘 파일 경로.\n- `sizes`: 보통 `180x180` 크기를 많이 사용해요.\n\n애플 터치 아이콘을 설정해두면 iOS 기기에서 홈 화면에 북마크를 추가할 때 선명하고 예쁜 아이콘이 나타나서 사용자 경험이 훨씬 좋아진답니다!\n\n---\n\n### 추가 팁!\n\n1. **여러 사이즈 지원하기**  \n모든 기기에서 최적의 아이콘 품질을 위해 16x16, 32x32, 48x48, 180x180 크기의 아이콘을 준비해두면 좋아요.\n\n2. **SVG 아이콘 사용하기**  \n요즘 브라우저들은 SVG도 잘 지원하니, 벡터 형식인 SVG를 사용할 경우 화면 해상도에 관계없이 선명한 아이콘을 보여줄 수 있어요.\n\n3. **manifest.json과 함께 쓰기**  \nPWA(Progressive Web App)를 고려한다면, `manifest.json` 파일에도 아이콘 정보를 넣으면 앱 설치 시 아이콘이 제대로 보입니다.\n\n---\n\n아이콘 설정은 기본 중 기본이지만, 사용자가 웹사이트를 더 오래 기억하고 편리하게 하도록 만드는 데 큰 역할을 하니 꼭 신경 써보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n애플 터치 아이콘(apple-touch-icon) 설정하는 법에 대해 쉽게 알려드릴게요. iOS 기기에서 홈 화면에 웹사이트를 추가할 때 이 아이콘이 보여지는데요, 생각보다 간단해요!\n\n아래 예시처럼 `\u003clink\u003e` 태그를 쓰시면 되는데, 이미지 파일은 보통 jpg, jpeg, png 형식 중 한 가지로 준비하시면 돼요.\n\n```html\n\u003clink\n  rel=\"apple-touch-icon\"\n  href=\"/apple-icon-180x180.png\"\n  type=\"image/png\"\n  sizes=\"180x180\"\n/\u003e\n```\n\n여기서 각각의 의미를 한번 살펴볼게요.\n\n| 속성(rel)             | 역할                                |\n|-------------------|-----------------------------------|\n| `rel=\"apple-touch-icon\"` | 이 링크가 애플 터치 아이콘임을 명시            |\n| `href`               | 아이콘 이미지 경로 (보통 루트 디렉터리에 위치)         |\n| `type`               | 이미지 타입 (jpg, png 등)               |\n| `sizes`              | 아이콘 크기(px 단위, 가로x세로)               |\n\n### 여러 개 아이콘 등록하기\n\n화면 크기에 따라 다르게 적용되도록 여러 크기의 아이콘을 등록할 수도 있어요. 이럴 때는 파일 이름에 숫자를 붙여 차례로 관리하시면 됩니다.\n\n예를 들어,\n\n- apple-icon-120x120.png  \n- apple-icon-152x152.png  \n- apple-icon-180x180.png  \n\n처럼요.\n\n브라우저가 필요한 아이콘 크기를 판단해 알맞은 파일을 자동으로 선택합니다.\n\n### 추가 팁!\n\n- 아이콘 파일은 프로젝트의 루트(/) 혹은 앱의 root segment에 있어야 적용돼요.  \n- 간혹 favicon과 apple-touch-icon을 혼동하는 경우 있는데, 둘은 기술적 목적과 사용하는 위치가 다릅니다. favicon은 브라우저 탭, apple-touch-icon은 iOS 홈 화면이죠.  \n- 요즘은 `.svg` 아이콘을 쓰기도 하는데요, 이 경우 `sizes=\"any\"`를 지정해서 아이콘 크기를 제한하지 않는 식으로 만들어 줍니다.  \n- 아이콘 이미지는 정사각형(가로, 세로가 같은)으로 만드는 게 좋아요. 그래야 크기가 바뀌어도 깨지거나 왜곡되지 않습니다.\n\n### 자동으로 아이콘 생성하는 방법 (.js, .ts, .tsx)\n\n아이콘 이미지 관리를 직접 하기 귀찮으면, 아래처럼 코드로 아이콘을 생성하고 설정 파일에서 자동으로 등록하는 방법도 있어요.\n\n```js\nimport { generateAppleTouchIcons } from 'your-icon-generator-library';\n\ngenerateAppleTouchIcons({\n  src: 'logo.png',\n  outputDir: '/public/icons',\n  sizes: [120, 152, 180], // 생성할 아이콘 크기들\n});\n```\n\n이런 방식은 프로젝트 빌드 과정에 포함시키면 최신 로고를 기준으로 자동으로 아이콘 이미지를 만들어줘서 관리하기 훨씬 편합니다!\n\n---\n\n이제 여러분도 iOS 홈 화면에 예쁜 아이콘을 쉽게 추가할 수 있겠죠? 😊 아이콘용 이미지는 180x180px 정도로 준비하면 가장 무난하니 참고하세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이미지 파일을 직접 사용하는 것 외에도, 코드를 통해 아이콘을 프로그래밍 방식으로 생성할 수 있어요.\n\n예를 들어, `icon`이나 `apple-icon`이라는 라우트를 만들어서 기본 내보내기(default export)로 함수를 작성하면 앱 아이콘을 동적으로 만들 수 있답니다.\n\n| 파일명 컨벤션 | 지원 파일 타입               |\n|--------------|---------------------------|\n| `icon`       | `.js`, `.ts`, `.tsx`      |\n| `apple-icon` | `.js`, `.ts`, `.tsx`      |\n\n가장 간단한 아이콘 생성 방법은 Next.js의 `next/og` 패키지에서 제공하는 `ImageResponse` API를 활용하는 거예요. 이 API를 사용하면 서버 사이드에서 이미지(아이콘)를 동적으로 그려서 반환할 수 있죠.\n\n예를 들어, 다음과 같은 식으로 작성할 수 있어요:\n\n```ts\nimport { ImageResponse } from 'next/og';\n\nexport const runtime = 'edge';\n\nexport default function Icon() {\n  return new ImageResponse(\n    (\n      \u003cdiv\n        style={{\n          background: 'white',\n          width: '100%',\n          height: '100%',\n          display: 'flex',\n          alignItems: 'center',\n          justifyContent: 'center',\n          fontSize: 128,\n          fontWeight: 'bold',\n          color: '#0070f3',\n        }}\n      \u003e\n        🚀\n      \u003c/div\u003e\n    ),\n    {\n      width: 512,\n      height: 512,\n    }\n  );\n}\n```\n\n위 예시는 \"🚀\" 이모지를 활용해 512x512 크기의 아이콘 이미지를 만들어요. 이렇게 하면 별도의 이미지 파일 없이도 코드를 통해 나만의 아이콘을 동적으로 생성할 수 있답니다.\n\n추가로, `icon`과 `apple-icon` 라우트는 각각 일반 앱 아이콘과 iOS용 애플 아이콘을 생성할 때 활용해요. 필요에 따라 서로 다른 스타일이나 해상도로 아이콘을 만들어 줄 수도 있답니다.\n\n이렇게 아이콘을 코드로 생성하는 방법은 커스터마이징이 쉽고, 빌드할 때마다 최신 상태의 아이콘을 자동으로 만들어주기 때문에 꽤 유용해요! 한번 시도해보시길 추천드려요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 Open Graph(og) 이미지나 아이콘을 생성하는 방법을 소개할게요! 이번에 살펴볼 코드는 32x32 크기의 PNG 아이콘을 동적으로 생성하는 예제입니다. 코드를 보면서 직접 어떤 짓을 하는지, 그리고 알아두면 좋은 팁도 같이 정리해볼게요.\n\n---\n\n## 동적 아이콘 생성 코드\n\n```jsx\nimport { ImageResponse } from 'next/og';\n\n// 이미지 메타데이터 (크기, 타입)\nexport const size = {\n  width: 32,\n  height: 32,\n};\nexport const contentType = 'image/png';\n\n// 이미지 생성 함수\nexport default function Icon() {\n  return new ImageResponse(\n    (\n      \u003cdiv\n        style={{\n          fontSize: 24,\n          background: 'black',\n          width: '100%',\n          height: '100%',\n          display: 'flex',\n          alignItems: 'center',\n          justifyContent: 'center',\n          color: 'white',\n        }}\n      \u003e\n        A\n      \u003c/div\u003e\n    ),\n    {\n      ...size, // 위에서 정의한 32x32 크기를 그대로 사용\n    }\n  );\n}\n```\n\n여기서 중요한 점은 `ImageResponse`라는 Next.js의 API를 이용해서 JSX 형태로 이미지를 만들어낸다는 거예요. 즉, 평소 웹에서 HTML/CSS를 쓰듯 그걸 그대로 이미지로 변환하는 느낌이죠!\n\n### key 포인트!\n\n- `fontSize`, `background`, `color` 등을 사용해서 화면 중앙에 대문자 'A'가 흰색으로 나타나도록 디자인했어요.\n- `size` 객체를 재사용해서 이미지 크기를 일관성 있게 지정했어요.\n- 이렇게 만든 이미지는 `image/png` 타입이기 때문에 아이콘이나 썸네일 등으로 활용 가능하죠.\n\n---\n\n## HTML에서 생성한 아이콘 사용하기\n\n```html\n\u003clink rel=\"icon\" href=\"/icon?\u003cgenerated\u003e\" type=\"image/png\" sizes=\"32x32\" /\u003e\n```\n\n위 태그는 만들어진 아이콘을 `favicon` 등으로 사용할 때 쓰는 근본적인 형태입니다. `?\u003cgenerated\u003e` 부분은 동적으로 생성된 이미지를 캐시 방지용 쿼리 스트링일 수도 있고, 실제 운영환경에 맞춰 적절하게 수정해 써야 합니다.\n\n---\n\n## 알아두면 좋은 점들\n\n| 구분           | 설명                                                                                   |\n| -------------- | -------------------------------------------------------------------------------------- |\n| 생성 시점       | 기본적으로 아이콘은 빌드 시점에 한번 정적으로 생성되고 캐시됩니다.                      |\n| 동적 데이터 사용 | 동적 API나 uncached 데이터를 이용하면 런타임에 매번 새로 생성할 수 있어요.             |\n| 여러 아이콘 생성 | 한 파일에서 `generateImageMetadata`라는 함수를 쓰면 여러 아이콘을 한번에 만들 수 있어요. |\n| favicon 제한    | `ImageResponse`로 favicon(대표 아이콘)은 직접 생성 불가. 대신 기본 favicon.ico 파일 사용하세요. |\n| 앱 아이콘 특성  | 앱 아이콘은 특수한 라우트 핸들러로 동적으로 생성되지만, 캐시는 기본값으로 적용됩니다.    |\n\n즉, 아이콘을 다루면서 ‘정적 생성’과 ‘동적 생성’ 방식 차이를 이해하는 게 중요해요. 그래야 빌드 속도와 최종 사용자 경험 사이 균형을 맞출 수 있답니다.\n\n---\n\n이번 포스트는 Next.js의 Open Graph 이미지 생성 기능을 통해 동적으로 아이콘을 만드는 방법을 소개했어요. Open Graph 이미지는 주로 SNS 공유 시 미리보기에 뜨는 이미지로 많이 쓰이지만, 이렇게 아이콘이나 프로필 이미지 생성에도 응용 가능하답니다.\n\n혹시 『더 멋진 아이콘 디자인』을 원한다면 SVG, Canvas API, 또는 외부 그래픽 파일을 활용하는 방법도 한번 시도해보세요. Next.js가 제공하는 이런 이미지 생성 기능은 입맛에 맞게 스타일링과 로직을 마음껏 변경할 수 있다는 점이 정말 매력적입니다.\n\n앞으로도 이런 실용적인 기능을 쉽고 재밌게 알려드릴게요. 즐겁게 개발하세요! 🚀\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기본 내보내기 함수는 다음과 같은 props를 받습니다:\n\n#### params (옵션)\n\n루트 세그먼트부터 해당 아이콘 (`icon` 또는 `apple-icon`)이 위치한 세그먼트까지의 동적 라우트 파라미터들을 담고 있는 객체입니다.\n\n```js\nexport default function Icon({ params }: { params: { slug: string } }) {\n  // ...\n}\n```\n\n여기서 `params.slug`는 URL 경로에서 동적으로 변하는 부분을 나타내는데요, 예를 들어 `/posts/hello-world` 라는 경로가 있다면, slug는 `\"hello-world\"`가 됩니다. 이런 동적 파라미터를 이용하면 여러 페이지를 하나의 컴포넌트로 유연하게 처리할 수 있어서 편리해요.\n\n\u003e 참고로, Next.js 같은 프레임워크에서는 이런 동적 라우팅을 지원해서 SEO 최적화에도 용이하니 꼭 활용해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 React 또는 Next.js 같은 환경에서 동적인 라우팅과 관련된 파일과 URL 경로, 그리고 params가 어떻게 매핑되는지를 정리한 표입니다.\n\n| Route                       | URL        | `params`                  |\n|-----------------------------|------------|---------------------------|\n| `app/shop/icon.js`           | `/shop`    | `undefined`               |\n| `app/shop/[slug]/icon.js`    | `/shop/1`  | `{ slug: '1' }`           |\n| `app/shop/[tag]/[item]/icon.js` | `/shop/1/2` | `{ tag: '1', item: '2' }` |\n\n### Returns\n\n기본으로 export되는 함수는 다음과 같은 타입 중 하나를 반환해야 합니다:\n\n- Blob\n- ArrayBuffer\n- TypedArray\n- DataView\n- ReadableStream\n- Response\n\n\u003e 참고로, `ImageResponse`가 이 반환 타입 요건을 만족합니다.\n\n---\n\n### 조금 더 쉽게 설명해볼게요!\n\n위 표는 Next.js나 비슷한 프레임워크에서 동적 라우팅을 구성할 때 파일 이름과 실제 URL 매칭, 그리고 params가 어떻게 넘어오는지를 보여주는 예시예요. 예를 들어 `app/shop/[slug]/icon.js` 파일은 `/shop/1` URL로 접속했을 때, `{ slug: '1' }`라는 파라미터를 받아서 그에 맞는 동작을 하게 됩니다.\n\n그리고 함수가 반환해야 하는 타입은 이미지나 스트림, 혹은 응답 객체 등 다양한 형태가 될 수 있어요. 특히 `ImageResponse`라는 타입이 있는데, 이건 Next.js에서 이미지를 동적으로 생성할 때 자주 사용하는 반환 타입입니다.\n\n만약 서버 사이드에서 이미지를 생성해서 클라이언트로 보내야 하는 상황이라면, `ImageResponse`를 반환하면 자동으로 올바른 이미지 응답이 만들어져서 편리하답니다!\n\n---\n\n### 참고로, 이런 동적 라우팅을 활용하면\n\n- URL 하나하나마다 다른 데이터를 보여주고 싶을 때\n- API 경로를 간편하게 관리하고 싶을 때\n- 여러 단계의 파라미터를 받아 처리해야 할 때\n\n굉장히 유용합니다. Next.js의 파일 기반 라우팅이 정말 강력한 이유 중 하나죠!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### Config exports\n\n아이콘의 메타데이터를 설정하고 싶을 때, 아이콘이나 애플 아이콘 경로에서 `size`와 `contentType` 변수를 내보내(export)서 설정할 수 있어요.\n\n| Option       | Type                                                                                             |\n|--------------|--------------------------------------------------------------------------------------------------|\n| `size`       | `{ width: number; height: number }` - 아이콘의 가로, 세로 크기를 직접 지정할 수 있어요.                        |\n| `contentType`| `string` - 이미지 MIME 타입을 지정합니다. 예를 들어 `image/png`, `image/svg+xml` 등이 있죠. [더 알아보기](https://developer.mozilla.org/docs/Web/HTTP/Basics_of_HTTP/MIME_types#image_types) |\n\n#### size\n\n`size`는 아이콘의 너비(width)와 높이(height)를 숫자로 지정할 수 있는 속성입니다. 예를 들면:\n\n```js\nexport const size = { width: 64, height: 64 };\n```\n\n이렇게 지정해주면, 아이콘이 실제로 64x64 픽셀 크기로 인식돼서, 제대로 크기가 맞게 처리되죠.\n\n---\n\n추가로, `contentType`을 제대로 지정하는 것도 중요한데요. 아이콘 파일 형식이 무엇인지 정확히 알려줘야 웹 브라우저가 올바르게 이미지를 해석해요. 예를 들어 PNG 이미지는 `image/png`, SVG는 `image/svg+xml`과 같이 설정해 줍니다.\n\n이 자잘한 설정 덕분에 아이콘을 사용할 때 크기나 형식 문제로 발생하는 오류들을 방지할 수 있답니다. 만약 커스텀 아이콘을 직접 만들어서 쓰거나, 아이콘 라이브러리에서 가져온 파일을 사용할 때 꼭 확인해 보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안녕하세요, 여러분! 오늘은 웹 아이콘을 다룰 때 자주 사용하는 몇 가지 코드 조각과 관련된 내용을 살펴보려고 해요. 특히, 리액트 컴포넌트에서 아이콘을 정의할 때와 HTML에서 파비콘(favicon)을 설정할 때 알아두면 좋은 부분들을 정리해볼게요.\n\n## 1. 아이콘 크기 설정\n\n먼저, 주어진 코드에서 `size`라는 객체를 보면 다음과 같아요:\n\n```js\nexport const size = { width: 32, height: 32 }\n```\n\n이렇게 크기를 명시해두면, 아이콘 컴포넌트 내부에서 이 사이즈 값을 활용해서 적절한 크기로 아이콘을 렌더링할 수 있습니다. 예를 들어, SVG 아이콘을 만들 때 `width`와 `height`를 이 값으로 넣어주면 유용하죠.\n\n```js\nexport default function Icon() {\n  return (\n    \u003csvg width={size.width} height={size.height} /* ... */\u003e\n      {/* SVG 내용 */}\n    \u003c/svg\u003e\n  )\n}\n```\n\n## 2. HTML에서 아이콘 링크 태그 설정\n\n아래 코드는 HTML 문서의 `\u003chead\u003e` 부분에 아이콘을 연결할 때 쓰는 링크 태그입니다.\n\n```js\n\u003clink rel=\"icon\" sizes=\"32x32\" /\u003e\n```\n\n여기서 `rel=\"icon\"`은 브라우저가 이 리소스를 사이트의 대표 아이콘으로 사용하도록 하는 역할을 해요. `sizes=\"32x32\"`는 아이콘의 크기를 명시하는 속성인데요, 실제로는 이미지 파일 경로(`href`)도 꼭 넣어줘야 아이콘이 제대로 인식될 수 있습니다.\n\n예를 들면 다음과 같이 작성하는 게 일반적입니다.\n\n```html\n\u003clink rel=\"icon\" type=\"image/png\" sizes=\"32x32\" href=\"/favicon-32x32.png\" /\u003e\n```\n\n이렇게 하면 브라우저는 32x32 픽셀 크기의 PNG 형식 아이콘 파일을 파비콘으로 사용할 수 있게 되죠.\n\n## 3. 아이콘 MIME 타입 정의\n\n```js\nexport const contentType = 'image/png'\n\nexport default function Icon() {}\n```\n\n`contentType`은 이미지나 파일의 형식을 나타내는 MIME 타입인데, 아이콘 파일이 PNG 형식이라면 `'image/png'`로 설정하는 게 맞아요. 서버나 API에서 아이콘 데이터를 전송할 때, 또는 `\u003clink\u003e` 태그에 `type=\"image/png\"` 속성을 지정할 때 이 값이 필요합니다.\n\n---\n\n### 한 줄 정리\n\n| 항목          | 설명                                    | 예시                              |\n| ------------- | -------------------------------------- | -------------------------------- |\n| `size` 객체   | 아이콘 크기를 지정 (너비, 높이)         | `{ width: 32, height: 32 }`       |\n| `\u003clink rel\u003e`  | 파비콘 연결 태그, `href`와 함께 사용     | `\u003clink rel=\"icon\" type=\"image/png\" sizes=\"32x32\" href=\"/favicon.png\" /\u003e` |\n| `contentType` | 아이콘 파일의 MIME 타입 지정             | `'image/png'`                    |\n\n---\n\n### 추가 팁!\n\n- 파비콘은 다양한 크기로 준비하는 게 좋아요. 모바일이나 고해상도 화면에서는 16x16, 32x32, 48x48, 96x96 등 여러 사이즈 중 적합한 걸 골라 사용하거든요.\n- SVG 아이콘을 사용할 경우 `type=\"image/svg+xml\"`로 지정하면 더 선명하고 유연한 아이콘 활용이 가능해요.\n- React에서 아이콘 컴포넌트를 만들 때는 크기, 색상 등을 props로 받아 커스터마이징할 수 있게 만드는 것도 좋은 방법입니다.\n\n아이콘 설정, 이제 막막하지 않죠? 앞으로도 유용한 웹 개발 팁들로 찾아올게요~! 😊\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n```js\n\u003clink rel=\"icon\" type=\"image/png\" /\u003e\n```\n\n#### Route Segment Config\n\nicon과 apple-icon은 특별한 Route Handlers로, Pages와 Layouts에서 사용하는 것과 동일한 라우트 세그먼트 구성 옵션을 사용할 수 있어요.\n\n## 버전 히스토리 (Version History)\n\n\n---\n\n위 내용은 HTML에서 파비콘(favicon)을 설정할 때 사용하는 `\u003clink\u003e` 태그의 예시입니다. 여기서 `rel=\"icon\"`은 브라우저 탭에 보이는 아이콘을 지정하죠. `type=\"image/png\"`는 아이콘 파일 타입이 PNG임을 알려주는 부분이에요.\n\n그리고 Next.js나 유사한 프레임워크에서 사용하는 라우트 세그먼트 설정에 관한 내용도 나와 있는데요. `icon`과 `apple-icon`은 일반적인 페이지나 레이아웃과 마찬가지로 설정 옵션을 쓸 수 있어서, 아이콘 관련 라우팅 처리를 쉽게 할 수 있다는 뜻입니다.\n\n---\n\n추가로, 웹사이트 파비콘을 설정할 때 단순히 `favicon.ico` 파일만 사용하는 시대는 점점 줄고 있어요. 요즘은 다양한 해상도와 기기별로 최적화된 여러 아이콘 파일들을 `\u003clink rel=\"icon\" /\u003e`, `\u003clink rel=\"apple-touch-icon\" /\u003e` 등으로 세밀하게 관리하는 추세예요. 이렇게 하면 모바일 기기나 다양한 플랫폼에서 더 예쁘고 선명한 아이콘을 보여줄 수 있습니다.\n\n만약 Next.js 13 이상 버전을 사용하고 있다면, 라우트 세그먼트를 이용해 아이콘이나 애플 아이콘 같은 리소스들을 별도로 관리하는 것도 좋습니다. 그러면 유지보수가 편하고, 특정 페이지별로 아이콘을 다르게 설정하는 것도 가능해져요.\n\n---\n\n참고로, 파비콘 설정과 관련해서 지원하는 이미지 포맷은 다음과 같은데요:\n\n| 이미지 포맷 | 설명                           |\n|-------------|------------------------------|\n| `.ico`      | 가장 전통적인 파비콘 포맷        |\n| `.png`      | 투명도 지원하는 현대적인 포맷    |\n| `.svg`      | 벡터 이미지로, 크기 조절 가능     |\n| `.gif`      | 움직이는 아이콘으로도 가능         |\n\n프로젝트 성격에 맞게 잘 선택해서 사용하세요. 위 표처럼 여러 포맷을 함께 제공하면, 다양한 디바이스와 브라우저에서 더 안정적으로 작동합니다.\n\n필요하면 다음 글에서 실제 프로젝트에 적용하는 예시도 공유할게요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 해당 내용을 Markdown 형식으로 바꾼 표입니다. \n\n| Version   | Changes                                    |\n|-----------|--------------------------------------------|\n| `v13.3.0` | `favicon` icon과 `apple-icon`이 새롭게 추가됨 |\n\n이 부분은 웹 개발할 때 자주 쓰이는 favicon과 apple-icon 관련 업데이트 소식인데요, favicon은 브라우저 탭에 보이는 작은 아이콘을 말하고, apple-icon은 아이폰이나 아이패드 등의 홈 화면에 웹앱을 추가했을 때 보여지는 아이콘이에요. 이렇게 지원을 추가하면 사용자가 더 깔끔하고 프로페셔널한 느낌을 받을 수 있답니다! 혹시 웹사이트에 이런 아이콘들을 넣고 싶다면, 각 플랫폼별 기본 사이즈와 포맷을 맞춰주는 것도 잊지 마세요~","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":21},{"title":"nextjs 15에서 template.js 사용하는 방법","description":"","date":"2025-04-22 02:47","slug":"2025-04-22-templatejs","content":"\n# template.js 파일 이해하기\n\n이번에는 `template.js` 파일에 대해 이야기해볼게요. 템플릿 파일은 레이아웃(layout)과 비슷한 역할을 하지만, 조금 다릅니다.\n\n레이아웃은 여러 라우트(route)에서 유지되면서 상태(state)를 유지하는 반면, 템플릿은 고유한 키(unique key)를 가지고 있어서 자식 클라이언트 컴포넌트(Client Components)의 상태가 페이지가 이동할 때마다 초기화(reset)된다는 차이가 있어요.\n\n예를 들어, 다음과 같은 템플릿 컴포넌트가 있다고 가정해볼게요.\n\n```js\nexport default function Template({ children }: { children: React.ReactNode }) {\n  return \u003cdiv\u003e{children}\u003c/div\u003e;\n}\n```\n\n이 코드에서는 `children`을 받아서 `\u003cdiv\u003e`로 감싸기만 했죠. 이 템플릿을 사용하면, 페이지를 이동할 때마다 자식 컴포넌트들의 상태가 초기화됩니다.\n\n---\n\n### 상태 유지 vs 초기화: 왜 중요할까?\n\n- **레이아웃**은 여러 페이지 사이를 오가더라도 상태가 유지돼요. 예를 들어, 사이드바가 열려있는 상태를 유지하고 싶다면 레이아웃이 맞아요.\n- **템플릿**은 페이지 또는 특정 라우트마다 상태를 초기화해야 할 때 씁니다. 예를 들어, 폼 입력값을 페이지별로 완전히 새로 시작하고 싶을 때요.\n\n---\n\n### 꿀팁: 템플릿과 레이아웃, 언제 써야 할까?\n\n- 상태 유지가 필요하면 → 레이아웃을 사용하세요.\n- 상태 초기화가 필요하면 → 템플릿을 사용하세요.\n\ni이해를 돕기 위해 이미지도 참고하면 좋아요!\nt\n![template 개념 이미지](/TIL/assets/img/2025-04-22-templatejs_0.png)\n\n---\n\n요약하자면, `template.js`는 레이아웃과 비슷하지만, 페이지가 바뀔 때마다 자식 컴포넌트 상태가 초기화 된다는 점에서 다릅니다. 프로젝트에서 상태 관리가 필요한 부분을 명확히 구분해서 템플릿과 레이아웃을 적절히 활용해 보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n가끔은 레이아웃(Layout) 대신에 템플릿(Template)을 선택하는 게 더 나은 경우도 있어요. 예를 들면:\n\n- useEffect (예: 페이지 뷰 로깅)나 useState (예: 각 페이지별 피드백 폼) 같은 훅을 활용하는 기능이 필요할 때.\n- 기본 프레임워크 동작 방식을 바꾸고 싶을 때. 예를 들어, 레이아웃 내의 Suspense 경계는 레이아웃이 처음 로드될 때만 fallback UI를 보여주고 페이지 전환 시에는 보여주지 않지만, 템플릿에서는 페이지가 바뀔 때마다 fallback UI가 매번 표시됩니다.\n\n## Props\n\n### children (필수)\n\nchildren은 템플릿 내부에 렌더링될 자식 요소들을 의미합니다. 이걸 사용해서 부모 컴포넌트에서 자식 컴포넌트를 감싸거나 그 안에 배치할 수 있어요. React에서 자식 요소를 다룰 때 거의 항상 사용하니까 꼭 기억해두세요!\n\n---\n\n추가로, 레이아웃과 템플릿 선택 기준에 대해 조금 더 설명하자면, 레이아웃은 기본적으로 페이지 전환 시 지속되는 공통 UI나 구조를 만드는 데 쓰이고, 템플릿은 각 페이지가 로드될 때마다 새로 렌더링되어야 하는 동적인 UI나 상태 관리가 필요할 때 적합해요. 개발하는 서비스의 특성과 UX 목표에 따라 적절히 선택하면 됩니다!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nTemplate 컴포넌트는 children prop을 받아 사용할 수 있어요. 예를 들어 이렇게 작성할 수 있죠:\n\n```jsx\n\u003cLayout\u003e\n  {/* 템플릿에는 자동으로 고유한 key가 주어진다는 점 참고하세요. */}\n  \u003cTemplate key={routeParam}\u003e{children}\u003c/Template\u003e\n\u003c/Layout\u003e\n```\n\n\u003e 알아두면 좋은 점:\n\u003e 기본적으로 템플릿은 서버 컴포넌트(Server Component)로 동작하지만, \"use client\" 지시어를 붙이면 클라이언트 컴포넌트(Client Component)로도 사용할 수 있습니다.\n\u003e 사용자가 템플릿을 공유하는 여러 라우트 사이를 이동할 때는 컴포넌트가 새로 마운트되고, DOM 요소들도 재생성돼요. 그래서 클라이언트 컴포넌트의 상태는 유지되지 않고, effect도 다시 실행됩니다.\n\n즉, 템플릿을 클라이언트 측에서 사용한다면 상태 관리 혹은 사이드 이펙트 처리에 유의해야 한다는 점 기억하세요!\n\n## Version History\n\n(이후 버전 히스토리 내용이 이어지는 부분이라면 여기에 추가 정보를 넣을 수 있어요.)\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 표를 마크다운 형식으로 변환한 내용이에요.\n\n| Version   | Changes                |\n| --------- | ---------------------- |\n| `v13.0.0` | `template` introduced. |\n\n여기서 'template'이 새로 도입되었다고 하네요. 보통 이런 변경 사항은 라이브러리나 프레임워크의 중요한 기능 추가나 개선일 가능성이 높아요. 만약 여러분이 사용 중인 버전이 13.0.0이라면 이 'template' 기능을 꼭 한번 살펴보는 걸 추천해요. 새로운 기능이 어떤 식으로 코드를 더 깔끔하게 해주거나, 생산성을 높여줄지 직접 써보면서 경험해보는 게 가장 좋아요!\n","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":4},{"title":"Next.js 15에서 Unauthorized.js로 권한 없는 접근 처리하는 방법","description":"","date":"2025-04-22 02:47","slug":"2025-04-22-unauthorizedjs","content":"\n\n# unauthorized.js\n\n`unauthorized.js` 파일은 인증 과정에서 `unauthorized` 함수가 호출될 때 보여줄 UI를 렌더링하는 역할을 해요. 이 파일을 통해 UI를 원하는 대로 꾸밀 수 있을 뿐만 아니라, Next.js가 자동으로 401 상태 코드를 반환해 준답니다.\n\n```js\nimport Login from '@/app/components/Login'\n\nexport default function Unauthorized() {\n  return (\n    \u003cmain\u003e\n      \u003ch1\u003e401 - Unauthorized\u003c/h1\u003e\n      \u003cp\u003ePlease log in to access this page.\u003c/p\u003e\n      \u003cLogin /\u003e\n    \u003c/main\u003e\n  )\n}\n```\n\n위 코드를 보면, 기본적으로 \"401 - Unauthorized\"라는 제목과 함께 로그인을 요청하는 문구가 보이고, `Login` 컴포넌트를 렌더링해 실제 로그인 화면도 함께 표시하고 있어요.\n\n### 조금 더 알아보기\n\n- **401 상태 코드란?**  \n  401은 '인증이 필요함'을 나타내는 HTTP 상태 코드로, 사용자가 인증되지 않은 상태에서 접근 권한이 필요한 페이지에 접근할 때 서버가 보내요.\n\n- **Next.js에서의 활용 팁**  \n  이 파일을 커스터마이징하면 에러 페이지를 여러분의 서비스 스타일에 맞게 꾸밀 수 있답니다. 예를 들어, 로그인 버튼 대신 소셜 로그인이나 회원가입으로 유도하는 링크도 넣어볼 수 있겠죠?\n\n- **추가로 하면 좋은 것**  \n  사용자가 왜 인증이 필요한지 좀 더 자세한 안내나, 인증 절차에 도움이 될 만한 FAQ 링크를 같이 넣으면 UX가 더 좋아질 수 있어요.\n\n필요하면 한 번 직접 만들어보고, 여러분만의 인증 오류 페이지도 멋지게 만들어 보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### Props\n\n`unauthorized.js` 컴포넌트는 어떤 props도 받지 않습니다.\n\n## 예시\n\n### 로그인하지 않은 사용자에게 로그인 UI 보여주기\n\n로그인하지 않은 사용자를 대상으로 로그인 화면을 보여주고 싶을 때, `unauthorized.js` 컴포넌트를 사용할 수 있어요. 참고로 이 컴포넌트는 추가 설정을 위해 props를 받지 않으니, 간단하게 기본 UI를 렌더링하는 용도로 쓴다는 점 기억하세요.\n\n만약 내 서비스에서 로그인 여부에 따라 다른 화면을 보여줘야 한다면, 조건문으로 이 컴포넌트를 넣어주면 됩니다. 예를 들어:\n\n```jsx\n{ !userIsLoggedIn \u0026\u0026 \u003cUnauthorized /\u003e }\n```\n\n이렇게 하면 인증되지 않은 사용자에게만 로그인 페이지가 표시되고, 이미 로그인한 사용자에겐 다른 화면이 보여지겠죠?\n\n추가로, `unauthorized.js` 컴포넌트 내부를 수정해 나만의 로그인 UI로 커스터마이징해도 좋습니다. 그럴 땐 props 대신 내부 상태나 리덕스 등 상태관리 라이브러리를 이용해서 유연하게 UX를 조절해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여러분 안녕하세요! 오늘은 Next.js 앱에서 인증이 필요한 페이지에 대해 'unauthorized' 함수를 이용해 인증되지 않은 사용자에게 로그인 UI를 보여주는 방법을 쉽게 설명해드릴게요.\n\n먼저, `DashboardPage` 컴포넌트를 살펴봅시다. 여기서는 `verifySession()` 함수를 통해 사용자의 세션 정보를 확인하는데요, 이 함수는 비동기 함수라 `await`를 붙여 호출해주고 있어요.\n\n```jsx\nimport { verifySession } from '@/app/lib/dal'\nimport { unauthorized } from 'next/navigation'\n \nexport default async function DashboardPage() {\n  const session = await verifySession()\n \n  if (!session) {\n    unauthorized()\n  }\n \n  return \u003cdiv\u003eDashboard\u003c/div\u003e\n}\n```\n\n- `verifySession()` 함수가 null 또는 undefined를 반환한다면 세션이 없는 것으로 간주하고, `unauthorized()` 함수를 호출해버립니다.\n- 이 `unauthorized()` 함수는 내부적으로 Next.js에 내장된 기능으로, 렌더링을 멈추고 `unauthorized.js` 파일을 호출해서 401 페이지를 보여주게 해줍니다.\n\n그럼 그 `unauthorized.js` 파일에 어떤 컴포넌트가 있냐면,\n\n```jsx\nimport Login from '@/app/components/Login'\n \nexport default function UnauthorizedPage() {\n  return (\n    \u003cmain\u003e\n      \u003ch1\u003e401 - Unauthorized\u003c/h1\u003e\n      \u003cp\u003ePlease log in to access this page.\u003c/p\u003e\n      \u003cLogin /\u003e\n    \u003c/main\u003e\n  )\n}\n```\n\n이렇게 간단하게 로그인 UI를 포함한 페이지를 만들고 있어요. 화면에 “401 - Unauthorized” 메시지와 로그인 폼이 나타나게 되는 거죠.\n\n---\n\n### 한 번에 쉽게 인증 처리하기\n\n사실 여기서 중요한 점은, 이런 패턴을 쓰면 페이지 보호 로직이 깔끔해진다는 거예요. 개발자 입장에서 보면, 사용자가 로그인을 하지 않은 상태면 바로 401 페이지로 분기시키고, 그 화면에서 자연스럽게 로그인하도록 유도할 수 있죠.\n\n- 기존의 리다이렉트 방식이나, 클라이언트 사이드에서 상태를 확인하는 것보다 서버에서 바로 인증 상태를 확인하는 게 보안상 더 안전합니다.\n- 물론 세션 검증 함수(`verifySession`)는 직접 구현해야 해요. 예를 들어 쿠키에 포함된 토큰을 해석하거나, 데이터베이스를 조회해서 유효성을 검사하게 됩니다.\n\n---\n\n### 이해를 돕는 간단 다이어그램\n\n| 동작 단계             | 설명                                    |\n|-------------------|---------------------------------------|\n| 1. 세션 확인          | `verifySession` 호출해서 로그인 여부 확인          |\n| 2. 미인증 사용자 감지     | 세션이 없으면 `unauthorized()` 호출해서 401 페이지 렌더링   |\n| 3. 401 페이지 렌더링      | `unauthorized.js`에 정의된 로그인 화면을 보여줌            |\n| 4. 로그인 후 세션 생성     | 로그인 컴포넌트에서 정상 로그인이 되면 세션이 생성됨         |\n| 5. 접근 허용           | 이후 대시보드 페이지 접속 가능                           |\n\n---\n\n### 마치며\n\nNext.js 앱에서 인증이 필요한 페이지를 다룰 때, ‘unauthorized’ 함수를 잘 활용하면 간단하고 체계적인 접근 제어를 구현할 수 있습니다. 보안도 높이고 UX도 좋으니 여러분께서도 꼭 한 번 써보시길 추천드려요.\n\n추가로, 로그인 컴포넌트나 세션 검증 로직에 대해 궁금하신 점 있으면 댓글로 알려주세요. 다음에는 그 부분도 자세히 다뤄보겠습니다!\n\n오늘도 즐거운 개발 되시길! 🚀\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n| Version   | Changes                 |\n|-----------|-------------------------|\n| `v15.1.0` | `unauthorized.js` 도입됨 |\n\n이번에 `v15.1.0` 버전에서 `unauthorized.js`라는 파일이 새롭게 추가됐어요. 보통 이런 파일 이름은 '허가되지 않은 접근'과 관련된 기능을 처리할 때 쓰이는데요, 예를 들어 로그인이 필요한 페이지에 비로그인 사용자가 접근하려 할 때 보여주는 에러 처리나 리다이렉트 등을 담당할 수도 있답니다.\n\n이렇게 특정 상황에 맞는 자바스크립트 파일을 분리해서 관리하면 코드 유지보수도 편해지고, 필요한 경우에만 로드해서 성능 최적화도 할 수 있어요. 나중에 관련 기능을 더 자세히 살펴볼 기회가 있으면, `unauthorized.js`가 실제로 어떤 역할을 하는지 한번 분석해보는 것도 재밌겠네요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":5},{"title":"Next.js 15 라우트 세그먼트 설정 방법과 활용팁","description":"","date":"2025-04-22 02:45","slug":"2025-04-22-RouteSegmentConfig","content":"\n\n# Route Segment Config\n\n\u003e 이 페이지에 소개된 옵션들은 `dynamicIO` 플래그가 켜져 있으면 비활성화되고, 앞으로는 없어질 예정이에요.\n\nRoute Segment 옵션은 Page, Layout, 또는 Route Handler의 동작 방식을 직접 제어하고 싶을 때 유용해요. 이 옵션들은 아래 변수들을 export 해서 설정할 수 있습니다.\n\n| 옵션             | 타입                                                                                  | 기본값           |\n|-----------------|-------------------------------------------------------------------------------------|-----------------|\n| [experimental_ppr](#experimental_ppr) | `boolean`                                                                             |                 |\n| [dynamic](#dynamic)                   | `'auto'` \\| `'force-dynamic'` \\| `'error'` \\| `'force-static'`                        | `'auto'`        |\n| [dynamicParams](#dynamicparams)      | `boolean`                                                                             | `true`          |\n| [revalidate](#revalidate)             | `false` \\| `0` \\| `number`                                                            | `false`         |\n| [fetchCache](#fetchcache)             | `'auto'` \\| `'default-cache'` \\| `'only-cache'` \\| `'force-cache'` \\| `'force-no-store'` \\| `'default-no-store'` \\| `'only-no-store'` | `'auto'`        |\n| [runtime](#runtime)                   | `'nodejs'` \\| `'edge'`                                                                | `'nodejs'`      |\n| [preferredRegion](#preferredregion)  | `'auto'` \\| `'global'` \\| `'home'` \\| `string` \\| `string[]`                          | `'auto'`        |\n| [maxDuration](#maxduration)           | `number`                                                                             | 배포 플랫폼에 따라 설정 |\n\n---\n\n### 한눈에 보기\n\n- **experimental_ppr**: 실험적인 부분들에 대한 설정인데, 자세한 내용은 공식 문서를 참고해야 해요.\n- **dynamic**: 페이지를 동적으로 처리할지, 정적으로 처리할지 결정할 수 있어요. 기본값은 `'auto'`라 알아서 최적의 방식을 선택합니다.\n- **dynamicParams**: 동적 경로 파라미터 사용 여부를 설정해요. 기본적으로 `true`라 동적 파라미터를 허용합니다.\n- **revalidate**: ISR(Incremental Static Regeneration)을 사용할 때 재빌드 주기를 설정합니다. `false`는 재빌드를 하지 않는다는 의미고, 숫자를 지정하면 해당 초마다 재빌드 돼요.\n- **fetchCache**: 서버 측 데이터 fetching 시 어떤 캐싱 전략을 사용할지 정하는 옵션입니다.\n- **runtime**: `nodejs` 또는 `edge` 중 실행 환경을 선택할 수 있어요. 기본은 `nodejs`.\n- **preferredRegion**: 배포 리전을 지정할 수 있는 옵션입니다. 글로벌 서비스를 위한 `'global'`이나 특정 리전 이름, 혹은 배열로 여러 리전을 설정할 수 있죠.\n- **maxDuration**: 함수 실행 최장 시간을 의미하는데, 보통 배포 환경에 따라 제한됩니다.\n\n---\n\n### 그리고 살짝 덧붙이자면...\n\n이런 Route Segment 설정을 통해서 Next.js 같은 프레임워크에서 페이지나 API 경로의 동작 방식을 세밀하게 조정할 수 있어요. 예를 들어, `dynamic: 'force-dynamic'`으로 지정하면 요청마다 항상 새롭게 렌더링해서 가장 최신 데이터를 보여주고, `revalidate` 시간을 설정해두면 효율적인 캐싱을 하면서도 일정 주기로 콘텐츠가 갱신되게 할 수 있죠.\n\n또한, `runtime`을 `edge`로 설정하면 전 세계 엣지 서버에서 빠르게 처리가 가능해서 속도 향상과 지연 감소에 도움 될 수 있습니다. 다만 엣지 런타임 환경 제약 조건이 있으니, 사용 시 주의하세요.\n\n이렇게 구성해두면 사용자 경험을 더 좋게 만들어주고, 서버 리소스를 효과적으로 사용할 수 있다는 장점이 있습니다. 다음에는 각 옵션별 좀 더 구체적인 활용법도 소개해볼게요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 옵션\n\n### experimental_ppr\n\nPartial Prerendering, 줄여서 PPR을 레이아웃이나 페이지에 적용할 수 있는 옵션이에요. 이걸 활성화하면 페이지나 특정 레이아웃이 부분적으로 미리 렌더링 되어서, 사용자가 페이지를 더 빨리 볼 수 있도록 도와줘요.\n\n```js\nexport const experimental_ppr = true\n// true | false\n```\n\n참고로, 이 옵션은 아직 실험적인 기능이라 가끔 예상치 못한 동작이 있을 수도 있어요. 그래서 프로젝트에 바로 적용하기보다는 테스트 환경에서 먼저 써보고, 잘 맞는지 확인하는 걸 추천드려요!\n\n추가로 Partial Prerendering은 페이지의 일부만 미리 만들어두고 나머지는 필요할 때 로드하는 방식이기 때문에, 데이터가 자주 변하는 부분이나 사용자 맞춤형 콘텐츠에서 유용할 수 있어요. 만약에 페이지가 크고 렌더링 시간이 길다면, PPR을 활용해서 초기 로딩 속도를 확실히 개선할 수 있답니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### dynamic\n\n레이아웃이나 페이지의 동작 방식을 완전 정적(static) 또는 완전 동적(dynamic)으로 바꿀 수 있는 옵션이에요.\n\n```js\nexport const dynamic = 'auto'\n// 사용할 수 있는 값: 'auto' | 'force-dynamic' | 'error' | 'force-static'\n```\n\n여기서 각 값의 의미는 다음과 같아요:\n\n- `'auto'`: 기본값이에요. 상황에 따라 동적 또는 정적으로 처리해요.\n- `'force-dynamic'`: 무조건 동적으로 렌더링해요.\n- `'force-static'`: 무조건 정적으로 렌더링해요.\n- `'error'`: 동적 동작이 필요할 때 에러를 발생시켜요.\n\n\u003e 참고로 알면 좋은 점: Next.js의 최신 app 디렉토리 구조에서는 페이지 단위에서 모두 다 동적이거나 모두 다 정적인 getServerSideProps, getStaticProps 대신, fetch 요청 단위에서 좀 더 세밀하게 캐싱을 조절하는 방식을 선호해요. 즉, 이전의 방식보다 더 유연해졌죠. 그런데 기존의 페이지 단위 동작 모델로 쉽게 돌아가고 싶은 경우, 이 `dynamic` 옵션을 활용하면 간편하게 이전 모델을 유지할 수 있어서 마이그레이션할 때도 편리해요.\n\n---\n\n추가로 덧붙이자면, 실제로는 fetch 함수에서 `cache` 옵션을 주는 쪽이 더 권장됩니다. 예를 들어:\n\n```js\nconst res = await fetch('/api/data', { cache: 'no-store' }) // 항상 최신 데이터를 받아오도록 강제\n```\n\n이런 식으로 개별 fetch 요청마다 캐싱 동작을 세부 조절할 수 있어요. `dynamic` 옵션은 주로 전체 페이지 단위의 기본 동작을 결정할 때 사용한다고 생각하면 됩니다. \n\n즉, Next.js의 최신 앱 구조는 “모든 것을 다 세부적으로 제어하는 시대”라고 이해하면 좋겠네요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n`dynamic` 옵션에는 총 네 가지가 있어요. 각 옵션이 어떤 차이를 만드는지 쉽게 정리해볼게요!\n\n| 옵션           | 설명                                                                                                  | 추가 팁                                                                                          |\n|---------------|-----------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------|\n| `auto` (기본값) | 가능한 한 많이 캐시하지만, 동적으로 동작하고 싶은 컴포넌트는 이를 선택할 수 있도록 허용합니다.                                    | 기본값 그대로 쓰면 딱히 설정하지 않아도 자동으로 적절히 작동해요.                                      |\n| `force-dynamic` | 무조건 동적 렌더링을 합니다. 즉, 각 요청마다 매번 페이지가 새로 렌더링됨.                                       | 내부적으로 모든 fetch() 요청은 `'cache: no-store', next: { revalidate: 0 }` 설정이 되고, `fetchCache = force-no-store` 로 강제되죠. |\n| `error`        | 정적 렌더링만 강제하고, 만약 Dynamic API나 캐시되지 않는 데이터를 쓰면 에러 발생!                                    | pages 디렉토리의 `getStaticProps()`와 비슷해요. fetch()는 `'cache: force-cache'`를 사용하고, `fetchCache = only-cache`, `dynamicParams = false`로 설정됩니다. 동적 파라미터가 필요하면 수동으로 `dynamicParams = true`로 바꿔야 해요.        |\n| `force-static` | 정적 렌더링 강제 + cookies, headers(), useSearchParams() 호출 시 빈값만 반환하게 만듭니다.                          | 정말 정적으로만 작동해야 하는 상황에 쓸 수 있어요.                                                    |\n\n---\n\n### 참고! \n`getServerSideProps`, `getStaticProps`에서 `dynamic: 'force-dynamic'`이나 `dynamic: 'error'`로 마이그레이션하는 방법은 [업그레이드 가이드](https://nextjs.org/docs/pages/building-your-application/data-fetching/upgrading)에서 자세히 설명하고 있으니 참고하세요.\n\n---\n\n### dynamicParams란?\n이건 `generateStaticParams`로 미리 생성하지 않은 동적 경로(`/posts/[id]` 같은)가 방문됐을 때 어떻게 처리할지 결정할 수 있는 옵션이에요. 예를 들면 동적 경로가 너무 많을 때 미리 다 생성할 수 없으니, 방문 시점에 동적으로 처리할지, 아니면 에러를 표시할지 선택할 수 있습니다.\n\n---\n\n이렇게 보면 `dynamic` 옵션을 상황과 필요에 맞게 조절하는 게 핵심이라는 걸 알 수 있죠. 예를 들어, 자주 바뀌는 데이터를 보여주는 페이지라면 `force-dynamic`이 유리하고, 가능하면 빌드 타임에 다 끝내고 싶으면 `error` 혹은 `force-static`을 쓰는 식이에요.\n\n실제로 프로젝트에 적용할 때는 데이터 특성과 사용자 경험을 잘 고려해서 가장 적합한 설정을 찾아 보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nexport const dynamicParams = true // true | false,\n```\n\n- true (기본값): `generateStaticParams`에 포함되지 않은 동적 세그먼트는 요청 시점에 생성돼요.\n- false: `generateStaticParams`에 없는 동적 세그먼트에 접근하면 404 페이지가 반환됩니다.\n\n\u003e 알아두면 좋은 점:  \n이 옵션은 pages 디렉터리에서 사용하던 `getStaticPaths`의 `fallback: true | false | blocking` 옵션을 대체해요.  \n만약 모든 경로를 처음부터 정적으로 렌더링하고 싶다면, `generateStaticParams`에서 빈 배열을 반환하거나 `export const dynamic = 'force-static'`을 사용해야 합니다.  \n`dynamicParams = true`인 경우, 해당 세그먼트는 스트리밍 서버 렌더링(Streaming Server Rendering)을 사용해요.  \n그리고 `dynamic = 'error'`나 `dynamic = 'force-static'`을 쓰면 `dynamicParams`의 기본값이 false로 바뀝니다.\n\n---\n\n### revalidate  \n\n*여기서 부터는 `revalidate` 옵션에 대해 살펴볼게요.*  \n\nNext.js의 `revalidate` 옵션은 ISR(Incremental Static Regeneration) 기능을 제어하는 데 사용돼요.  \n간단히 말해서, 특정 페이지를 정적으로 렌더링한 뒤, 일정 시간이 지나면 백그라운드에서 다시 빌드해서 최신 데이터를 반영할 수 있게 해줍니다.\n\n```js\nexport const revalidate = 10; // 10초마다 페이지 재생성\n```\n\n- 숫자 (초 단위): 페이지가 이 값만큼의 시간이 지나면 재생성됩니다.  \n- `false` 또는 `0`: ISR 비활성화, 빌드 시 한 번만 생성됨.\n\n재생성 시점에 방문한 사용자는 기존 페이지를 보고, 백그라운드에서 새 페이지가 만들어지니까 사용자 경험에 끊김이 적어요.\n\n---\n\n### 간단 요약\n\n| 옵션               | 설명                                                |\n|--------------------|---------------------------------------------------|\n| `dynamicParams`     | 동적 세그먼트가 동적으로 생성되는지 여부 설정          |\n| `revalidate`        | ISR 주기 설정, 몇 초마다 페이지를 다시 생성할지 결정     |\n\n---\n\n### 추가 팁!\n\n- **`dynamicParams = true`와 ISR 함께 쓰기**  \n   동적 경로가 많거나 데이터가 자주 바뀌는 경우에 유용해요. 첫 요청 때만 페이지를 생성하고, 나중에 ISR로 업데이트할 수 있거든요.\n\n- **빈 배열 반환시 모든 경로 미리 생성**  \n   미리 생성할 경로를 다 알 수 있으면 `generateStaticParams`에서 배열을 반환해 정적으로 빠른 페이지를 만들 수 있어요.  \n\n- **`dynamic = 'force-static'` 사용**  \n   앱 전체를 정적으로 만들고 싶을 땐 이 값을 써서 SSR이나 동적 params 없이 순수 정적 빌드만 하게 설정해보세요.\n\n여러분 프로젝트에 맞게 이런 설정들을 적절히 활용하면, 효율적인 빌드와 빠른 퍼포먼스를 동시에 잡을 수 있답니다!  \n추가로 Next.js 공식 문서도 자주 확인하면서 최신 기능을 놓치지 않는 게 중요해요~\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n레이아웃이나 페이지에 기본 revalidation(재검증) 시간을 설정할 수 있어요. 여기서 중요한 점은 이 설정이 개별 fetch 요청에서 설정한 revalidate 값을 덮어쓰지 않는다는 거예요.\n\n```js\nexport const revalidate = false\n// false | 0 | number\n```\n\n| 값 | 의미 |\n|---|---|\n| false (기본값) | 기본적으로 `force-cache` 옵션이 붙은 fetch 요청이나 Dynamic API 사용 이전에 발견된 요청들은 캐싱합니다. 사실상 재검증 기간이 무한대(`revalidate: Infinity`)인 것과 같아서, 리소스를 무한정 캐시하겠다는 의미예요. 그래도 개별 fetch 요청에서 `cache: no-store` 나 `revalidate: 0`을 써서 캐시를 회피하거나, 경로의 기본값보다 짧은 재검증 시간을 가진 양수로 설정해 재검증 빈도를 높이는 건 가능합니다. |\n| 0 | 이 옵션을 설정하면 Dynamic API를 사용하지 않더라도 레이아웃이나 페이지가 항상 동적으로 렌더링됩니다. 이 경우 캐시 옵션을 명시하지 않은 fetch 요청은 기본적으로 `no-store`로 동작하지만, `force-cache` 옵션을 준 요청이나 양의 재검증 시간을 가진 요청은 그대로 유지됩니다. |\n| number (초 단위) | 레이아웃이나 페이지의 기본 재검증 주기를 초 단위 숫자로 설정합니다. 예를 들어 `revalidate = 600`이면 10분마다 재검증합니다. |\n\n---\n\n### 참고할 점\n- `revalidate` 값은 정적으로 분석 가능해야 해요. 예를 들어 `revalidate = 600`은 유효하지만, `revalidate = 60 * 10` 같이 계산식은 안 됩니다. 즉, 값을 변수나 계산식이 아닌 숫자 리터럴로 직접 입력해야 하는 점을 기억하세요.\n- `runtime = 'edge'`를 사용할 때는 `revalidate` 값이 적용되지 않습니다.\n- 개발 모드(Development)에서는 모든 페이지가 항상 on-demand로 렌더링되며 캐싱되지 않아요. 덕분에 코드를 바로바로 수정 확인할 수 있고, 재검증 시간을 기다릴 필요가 없답니다.\n\n---\n\n### 추가로 알아두면 좋은 팁!\n`revalidate`를 적절히 사용하면 페이지의 최신성을 유지하면서도 캐싱을 통해 빠른 응답 속도를 얻을 수 있어요. 예를 들어 자주 변경되지 않는 블로그 글 같은 경우에는 긴 재검증 시간(`false` 또는 큰 숫자)을 줘서 트래픽 부담을 줄이고, 자주 갱신이 필요한 데이터엔 짧은 재검증 시간을 설정하는 식이죠.\n\n기본 설정을 잘 활용하면 서버 부하를 줄이면서 사용자에게 더 빠른 웹 경험을 제공할 수 있으니, 상황에 맞는 값을 고민해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n#### 재검증 주기 (Revalidation Frequency)\n\n- 하나의 경로(route)에 속한 레이아웃(layout)과 페이지(page)들 각각이 재검증(revalidate) 시간을 갖는데, 이 중 가장 짧은 재검증 주기가 그 경로 전체의 재검증 주기가 됩니다. 즉, 자식 페이지들도 부모 레이아웃만큼 자주 재검증되도록 보장하는 거죠.\n- 개별 fetch 요청(fetch requests)에서는 경로의 기본 재검증 주기보다 더 짧은 재검증 주기를 설정할 수 있어요. 이를 통해 특정 경로나 상황에 맞게 동적으로 재검증 빈도를 높일 수 있습니다.\n\n예를 들어, 뉴스 기사 페이지는 자주 업데이트돼야 할 수도 있으니까 이 경우엔 재검증 주기를 더 짧게 설정할 수 있겠죠.\n\n---\n\n### fetchCache\n\n`fetchCache`는 클라이언트에서 데이터를 호출할 때 결과를 캐시하는 방식을 다루는 설정이에요. 원격 API를 호출할 때마다 서버에 부담주지 않으면서도, 최신 데이터를 적절히 유지하기 위한 중요한 포인트랍니다. cache-control 헤더 같이 HTTP 표준 캐싱 정책과도 연동되니까, 이 부분을 적절히 활용하면 효율적인 데이터 요청과 성능 향상에 큰 도움이 됩니다.\n\n---\n\n### runtime\n\n`runtime`은 코드를 실행하는 환경을 의미해요. Next.js 같은 프레임워크에서 `runtime`은 서버 사이드에서 동작하는지, 클라이언트 사이드에서 동작하는지에 따라 달라집니다. 서버에선 Node.js 환경에서 구동되고, 클라이언트에선 브라우저 환경이죠.\n\n실제로 `runtime`이 중요해지는 이유는, 일부 기능들은 서버에서만, 또는 클라이언트에서만 동작해야 하기 때문입니다. 예를 들어, 민감한 API 키로 데이터를 불러오는 작업은 서버에서만 실행하도록 하고, 사용자 상호작용에 따른 UI 업데이트는 클라이언트에서 처리하는 식이죠.\n\n---\n\n이렇게 `revalidation frequency`부터 `fetchCache`, `runtime`까지 조합해서 쓰면, 데이터 신선도 유지와 성능 최적화를 모두 잡을 수 있어요. Next.js 같은 최신 프레임워크를 사용할 때 이 부분들을 잘 이해하고 활용하는 게 개발 생산성 향상에 큰 도움이 되니 참고하시길 바랍니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n애플리케이션 렌더링에는 Node.js 런타임을 사용하는 걸 추천드리고, 미들웨어(Middleware)에는 Edge 런타임만 지원되니 이 점 참고해 주세요.\n\n```js\nexport const runtime = 'nodejs'\n// 'nodejs' | 'edge'\n```\n\n| 런타임 종류 | 설명                   |\n| --------- | -------------------- |\n| nodejs    | 기본값, 앱 렌더링용        |\n| edge      | 미들웨어 전용, 빠른 응답에 적합 |\n\nNode.js 런타임은 널리 사용되는 서버 환경으로, 풍부한 라이브러리와 안정성 덕분에 앱 렌더링에 최적입니다. 반면, Edge 런타임은 전세계적으로 분산된 서버에서 실행돼 지연시간을 최소화하기 때문에 미들웨어 같은 경량 작업에 딱이죠.\n\n더 자세한 런타임 차이점과 사용법은 공식 문서를 참고하시면 도움이 될 거예요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### preferredRegion\n\n```js\nexport const preferredRegion = 'auto'\n// 'auto' | 'global' | 'home' | ['iad1', 'sfo1']\n```\n\n`preferredRegion` 옵션은 배포하는 플랫폼에 따라 지원 여부와 사용 가능한 지역이 달라진다는 점, 꼭 기억하세요!\n\n\u003e 참고할 점  \n만약 `preferredRegion`을 따로 지정하지 않으면, 가장 가까운 상위 레이아웃(parent layout)의 설정을 상속받습니다.  \n그리고 최상위 레이아웃(root layout)은 기본값으로 모든 지역(all regions)을 대상으로 합니다.\n\n---\n\n이 기능은 여러 서버 지역(Region) 중 어디서 코드를 실행할지 선택할 때 아주 유용해요. 예를 들어, 사용자가 미국 동부에 많다면 'iad1' 같은 특정 리전을 지정해 그쪽에서 서비스하도록 설정할 수 있죠. 'auto'로 설정하면 Next.js가 가장 적합한 지역을 자동으로 선택해주니 편리합니다.\n\n여기서 'global'은 전 세계 여러 지역에 걸쳐 배포하는 경우이고, 'home'은 특정 홈 지역을 지칭할 때 사용됩니다. 또한 배열 형태로 여러 리전을 직접 지정해 여러 곳에서 동시에 실행되도록 할 수도 있답니다.\n\n이처럼 `preferredRegion`을 잘 활용하면 사용자 경험을 크게 향상시킬 수 있으니, 필요에 맞게 설정하는 걸 추천드립니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### maxDuration\n\nNext.js에서는 기본적으로 서버 사이드 로직(페이지 렌더링이나 API 처리 등)의 실행 시간을 제한하지 않아요. 그런데 배포 플랫폼에서 Next.js 빌드 결과에 포함된 `maxDuration` 값을 활용해 실행 시간 제한을 걸 수 있답니다. 예를 들어, Vercel 같은 곳에서는 이 값을 참고해서 서버 로직이 너무 오래 걸리지 않도록 관리할 수 있죠.\n\n\u003e **참고**: `maxDuration` 설정은 Next.js 13.4.10 이상 버전에서만 사용할 수 있어요.\n\n```js\nexport const maxDuration = 5\n```\n\n위처럼 `maxDuration`을 5로 설정하면, 해당 서버 로직이 5초 이상 실행되지 않도록 제한할 것을 제안하게 되는 거예요.\n\n---\n\n### 보너스 팁!\n\n- **왜 실행 시간 제한이 중요할까?**  \n  서버 쪽 로직이 무한루프에 빠지거나 너무 오래 걸리면, 서버 자원을 낭비하고 사용자 경험도 악화돼요. 특히 서버리스 환경에서는 실행 시간이 길어질수록 비용이 더 발생할 수 있어서, 이런 제한을 두는 게 효율적이랍니다.\n\n- **`maxDuration`은 어디에 적용될까?**  \n  서버 컴포넌트의 렌더링 로직이나 API Route 핸들러 등, 서버에서 실행되는 모든 로직에 적용할 수 있어요.\n\n- **Next.js 버전 확인법**  \n  프로젝트에서 현재 사용하는 Next.js 버전을 확인하려면 `package.json` 파일에서 `next` 항목을 보면 되니 참고하세요!\n\n---\n\n혹시 여러분의 프로젝트에서 실행 시간이 너무 긴 서버 코드를 발견했다면, `maxDuration` 설정과 함께 코드를 최적화하는 걸 추천드려요. 작은 설정과 최적화가 서버 환경 전반의 효율성을 크게 올려준답니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003e 알아두면 좋은 점:  \n만약 Server Actions를 사용할 경우, 페이지 단위에서 maxDuration을 설정해서 해당 페이지 내 모든 Server Actions의 기본 타임아웃 시간을 변경할 수 있어요.\n\n### generateStaticParams\n\ngenerateStaticParams 함수는 동적 라우트 세그먼트와 함께 사용할 수 있는데요, 이 함수를 이용하면 빌드 시점에 정적으로 생성할 라우트 세그먼트 파라미터 리스트를 정의할 수 있어요.  \n즉, 요청할 때마다(dynamic하게) 생성하는 것이 아니라, 미리(static하게) 만들어 두는 거죠.\n\n이렇게 하면 빌드 시 미리 생성된 페이지 덕분에 사용자 경험이 더 빨라지고 서버 부하도 줄일 수 있어요.\n\n조금 더 자세한 내용은 공식 API 문서를 참고해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 버전 히스토리\n\n| Version         | 설명                                                                                                         |\n|-----------------|------------------------------------------------------------------------------------------------------------|\n| `v15.0.0-RC`    | `export const runtime = \"experimental-edge\"`가 deprecated 되었습니다. 이에 따른 코드 변경을 쉽게 해주는 [codemod](https://nextjs.org/docs/app/guides/upgrading/codemods#transform-app-router-route-segment-config-runtime-value-from-experimental-edge-to-edge)가 제공됩니다. |\n\n여기서 codemod란, 코드 변환을 자동으로 해주는 도구를 의미해요. 기존에 `experimental-edge`로 설정해둔 부분을 새로운 방식인 `edge`로 한 번에 바꿔주니까, 직접 손으로 일일이 수정할 필요가 없어서 편하답니다. 혹시 Next.js로 프로젝트를 진행 중이라면 이 부분 꼭 참고하세요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":18},{"title":"Next.js 15에서 route.js 파일 설정하는 방법","description":"","date":"2025-04-22 02:44","slug":"2025-04-22-routejs","content":"\n\n# route.js\n\nRoute Handlers는 특정 경로(route)에 대해 커스텀 요청 처리기를 만들 수 있게 해주는 기능이에요. 즉, 내가 원하는 경로에 맞춰서 요청(Request)과 응답(Response)을 직접 다룰 수 있게 해주죠. 이때 Web Request와 Response API를 활용해요.\n\n예를 들어, 아래처럼 GET 요청을 받았을 때 JSON 형태로 간단한 메시지를 응답하는 코드를 작성할 수 있어요:\n\n```js\nexport async function GET() {\n  return Response.json({ message: 'Hello World' });\n}\n```\n\n이 코드는 \"/route\" 같은 경로로 GET 요청이 들어오면 `{ message: 'Hello World' }`라는 JSON 데이터를 클라이언트에게 보내주는 역할을 해요. \n\n추가로 알아두면 좋은 점 몇 가지 알려드릴게요!\n\n- **Method별 함수 지원**: GET뿐 아니라 POST, PUT, DELETE 등 HTTP 메서드에 맞춰서 함수들을 만들 수 있어요.  \n- **내장 Response 객체 활용**: 위 예시처럼 `Response.json()` 메서드는 JSON 응답을 쉽게 만들어 주기 때문에 정말 편리해요.\n- **비동기 처리 가능**: 데이터베이스 조회나 외부 API 호출처럼 비동기가 필요한 작업도 `async/await` 패턴으로 자연스럽게 처리할 수 있어요.\n- **라우팅과 별개로 작동**: Next.js 같은 프레임워크에서는 보통 페이지 라우팅과 별개로 API 응답을 여기서 따로 관리할 수 있답니다!\n\n만약 좀 더 복잡한 요청 처리(예: 요청 본문 읽기, 헤더 조작 등)를 하고 싶다면, Request 객체를 받아 쓰면 됩니다. 예를 들어:\n\n```js\nexport async function POST(request) {\n  const body = await request.json();\n  return Response.json({ youSent: body });\n}\n```\n\n이렇게 하면 클라이언트가 보낸 데이터를 받아서 다시 돌려주는 간단한 POST 처리도 가능해요.\n\n---\n\n## 참고 자료\n\n- 공식 MDN 문서 - [Web Request and Response APIs](https://developer.mozilla.org/en-US/docs/Web/API/Request)\n- Next.js API Routes 공식 문서 (비슷한 개념으로 활용 가능)  \n- Response 객체 관련 문서: JSON 응답 생성 등 다양한 메서드 지원\n\n---\n\n간단하지만 강력한 route.js의 Route Handlers, 여러분의 서버 로직 구현에 꼭 활용해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### HTTP 메서드\n\n라우트 파일에서는 특정 경로(route)에 대해 커스텀 요청 핸들러를 만들 수 있어요. 즉, 클라이언트가 어떤 요청을 했는지에 따라 다르게 동작하도록 코드를 작성할 수 있다는 뜻이죠. 여기서 지원하는 HTTP 메서드는 GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS 이렇게 총 7가지에요.\n\n```js\nexport async function GET(request: Request) {}\n \nexport async function HEAD(request: Request) {}\n \nexport async function POST(request: Request) {}\n \nexport async function PUT(request: Request) {}\n \nexport async function DELETE(request: Request) {}\n \nexport async function PATCH(request: Request) {}\n \n// 만약 `OPTIONS` 메서드를 직접 정의하지 않으면,\n// Next.js가 자동으로 `OPTIONS` 메서드를 구현해주고,\n// Route Handler에 정의된 다른 메서드들을 기준으로 `Allow` 헤더를 설정해줍니다.\nexport async function OPTIONS(request: Request) {}\n```\n\n각 함수는 `Request` 객체를 받아서 비동기적으로 처리할 수 있는 함수예요. `Request` 객체를 통해 요청과 관련된 다양한 정보를 얻을 수 있답니다.\n\n#### 간단히 정리한 HTTP 메서드 역할\n\n| 메서드 | 설명 |\n|---|---|\n| GET | 서버에서 데이터를 읽어올 때 사용해요. 가장 기본적인 요청이죠. |\n| POST | 서버에 데이터를 새로 생성할 때 쓰여요. 예를 들어 회원가입 같은 요청이죠. |\n| PUT | 데이터를 통째로 수정할 때 사용해요. 기존 데이터를 전부 교체할 때 유용합니다. |\n| PATCH | 데이터의 일부만 수정할 때 사용해요. 수정할 부분만 보내면 되어서 효율적이죠. |\n| DELETE | 서버에서 데이터를 삭제할 때 쓰여요. |\n| HEAD | GET 요청과 비슷하지만 응답 본문(body)은 안 내려줘서 응답 헤더만 받고 싶을 때 유용해요. |\n| OPTIONS | 클라이언트가 해당 경로에서 어떤 메서드를 사용할 수 있는지 미리 물어볼 때 사용합니다. |\n\n\u003e **팁!** 실제 API 설계할 때는 각 메서드가 어떤 동작을 하는지 명확하게 구분해서 사용하는 게 좋아요. 그래야 클라이언트가 어떤 요청을 보내야 할지 헷갈리지 않고, 유지보수도 훨씬 쉬워집니다.\n\n다음에는 `Parameters`(매개변수) 부분에 대해 자세히 알아볼게요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### Next.js에서 NextRequest 활용하기 (feat. request 객체 이해하기)\n\nNext.js에서 API 라우트나 미들웨어를 만들 때, `request` 객체를 자주 다루게 되죠. 그런데 그냥 기본 Web Request API와는 조금 다른, Next.js만의 확장판인 `NextRequest`라는 객체가 있다고 해요.\n\n#### NextRequest란?\n\n`NextRequest`는 기본 Web Request 객체를 상속해서, 더 쉽고 편하게 쓸 수 있게 만든 Next.js 전용 객체입니다. 예를 들어, 쿠키를 꺼내거나, URL 정보를 다룰 때 훨씬 직관적이고 편리해요. `nextUrl`이라는 확장된 URL 객체가 포함되어 있어서, 이걸 활용하면 URL 조작도 손쉽답니다.\n\n#### 간단한 예제\n\n```ts\nimport type { NextRequest } from 'next/server'\n\nexport async function GET(request: NextRequest) {\n  // nextUrl을 통해 URL을 쉽게 접근 가능\n  const url = request.nextUrl\n\n  // 예: 쿼리 파라미터 출력해보기\n  console.log(url.searchParams.get('id'))\n\n  return new Response('Hello World')\n}\n```\n\n위 코드에서 `request.nextUrl`을 이용하면 URL 전체를 분석할 수 있고, `searchParams`로 쿼리도 쉽게 읽을 수 있어요. 만약 그냥 `request.url`을 쓰면 문자열 형태라, 직접 파싱을 해야 하니까 귀찮죠.\n\n#### NextRequest만의 꿀팁!\n\n- **쿠키 꺼내기**: `request.cookies.get('cookieName')`으로 바로 쿠키 값 꺼낼 수 있어요.\n- **헤더 접근**: `request.headers.get('headerName')` 작성법은 동일하지만, 실제로 다루기 더 깔끔해요.\n- **POST Body 읽기**: 비동기로 `request.json()` 같은 메서드를 사용해 JSON 본문을 바로 파싱할 수 있습니다.\n\n#### 마무리\n\nNext.js 13부터 등장한 이 `NextRequest` 객체는 서버 컴포넌트나 API 라우트, 미들웨어를 작성할 때 훨씬 편리하고 강력한 도구입니다. 기존의 Web Request 객체보다 기능이 많고, 특히 URL이나 쿠키 처리에 도움을 주니 꼭 활용해 보세요!\n\n궁금하면 Next.js 공식 문서에서 [`NextRequest`](https://nextjs.org/docs/api-reference/edge-runtime#nextrequest)도 참고해보시면 좋습니다.\n\n---\n\n필요하다면 다음에는 `NextResponse` 활용법도 소개할게요. 이걸로 응답을 쉽게 제어할 수 있답니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 Next.js의 동적 라우트에서 `params`가 어떻게 사용되는지 보여주는 코드 예제입니다. 이 때 `params`는 현재 라우트의 동적 경로 파라미터들을 담은 객체를 비동기적으로 반환하는 Promise입니다.\n\n```js\nexport async function GET(\n  request: Request,\n  { params }: { params: Promise\u003c{ team: string }\u003e }\n) {\n  const { team } = await params\n  // 이제 team 변수에 URL에서 전달된 동적 경로 파라미터가 들어있어요.\n}\n```\n\n예를 들어, 다음과 같은 라우트 구조와 URL 요청이 있을 때 `params`는 이렇게 들어옵니다:\n\n| Example                        | URL           | params                             |\n|-------------------------------|---------------|----------------------------------|\n| `app/dashboard/[team]/route.js` | `/dashboard/1` | `Promise\u003c{ team: '1' }\u003e`          |\n| `app/shop/[tag]/[item]/route.js` | `/shop/1/2`   | `Promise\u003c{ tag: '1', item: '2' }\u003e` |\n| `app/blog/[...slug]/route.js`    | `/blog/1/2`   | `Promise\u003c{ slug: ['1', '2'] }\u003e`    |\n\n여기서 `[team]`, `[tag]`, `[item]` 같은 부분이 동적 경로 파라미터를 나타내고, `[...,slug]`는 여러 경로 세그먼트를 배열 형태로 받을 때 사용합니다.\n\n### 덧붙여서\n\n- `params`가 Promise인 이유는 Next.js가 라우트의 데이터 패칭 시점에 비동기 처리를 하기 때문이에요. 그래서 항상 `await`을 사용해 값을 꺼내주어야 해요.\n- 동적 라우트를 사용할 땐, `params`에서 기대하는 속성명이 URL 안 동적 경로 이름과 정확히 일치하는지 꼭 확인해야 합니다.\n- 여러 개의 동적 파라미터가 있다면, 그 만큼 프로퍼티를 비동기로 받아서 처리할 수 있어요.  \n- 다중 세그먼트 캡쳐(`[...slug]`)는 블로그 포스트나 검색 결과처럼 URL 계층이 다양하게 바뀌는 경우에 유용합니다.\n\n이런 기본 개념만 잘 이해하면 Next.js의 동적 라우트는 크게 어렵지 않으니, 직접 여러가지 라우트를 만들어보면서 경험을 쌓아보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 쿠키 다루기\n\n```js\nimport { cookies } from 'next/headers'\n\nexport async function GET(request: NextRequest) {\n  const cookieStore = await cookies()\n\n  const a = cookieStore.get('a')       // 쿠키 'a' 값을 가져오기\n  const b = cookieStore.set('b', '1')  // 쿠키 'b'를 '1'로 설정하기\n  const c = cookieStore.delete('c')    // 쿠키 'c' 삭제하기\n}\n```\n\nNext.js의 `cookies()` 함수로 쉽게 쿠키를 가져오고 설정하고 삭제할 수 있어요. 여기서 중요한 건 `cookies()`가 비동기 함수라는 점인데, 그래서 `await`를 붙여줘야 제대로 값을 받을 수 있답니다.\n\n`cookieStore.get()`은 해당 이름의 쿠키 정보를 객체 형태로 줘요. 없으면 `undefined`를 반환하고요. `cookieStore.set()`은 새로운 쿠키를 추가하거나 기존 쿠키를 덮어씁니다. `cookieStore.delete()`는 지정한 쿠키를 삭제할 때 씁니다.\n\n클라이언트와 서버 모두 쿠키를 다루지만, Next.js API Route 혹은 Route Handler에서는 이렇게 `next/headers`에서 제공하는 함수를 활용하면 훨씬 간단해져서 좋아요!\n\n---\n\n## 버전 히스토리\n\n| Version         | Changes                                                                  |\n|-----------------|--------------------------------------------------------------------------|\n| `v15.0.0-RC`    | `context.params`가 이제 프로미스 형태로 바뀌었어요. [codemod](https://nextjs.org/docs/app/guides/upgrading/codemods#150) 도 제공됩니다. |\n| `v15.0.0-RC`    | `GET` 핸들러의 기본 캐싱 정책이 static에서 dynamic으로 변경됐습니다.          |\n| `v13.2.0`       | Route Handlers가 처음 소개되었습니다.                                     |\n\nNext.js는 계속 발전 중이라 버전마다 큰 변화가 있는데, 특히 Route Handler와 쿠키, 캐시 다루는 방식도 바뀌니 공식 문서를 챙겨보시는 걸 추천해요! 혹시 기존 코드를 15버전 이상으로 올리려면 codemod를 꼭 활용해보세요. 작업할 때 시간 많이 절약됩니다.","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":8}],"page":"2","totalPageCount":41,"totalPageGroupCount":3,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"2"},"buildId":"o6AmBAY_j9v9JmbaRA39X","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>