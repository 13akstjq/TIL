<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>TIL</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//posts/4" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="TIL" data-gatsby-head="true"/><meta property="og:title" content="TIL" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//posts/4" data-gatsby-head="true"/><meta name="twitter:title" content="TIL" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/7d7290728862aada.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/7d7290728862aada.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/873-eb138c3217d71553.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/posts/%5Bpage%5D-de1dc5579188f9be.js" defer=""></script><script src="/TIL/_next/static/olPs1cVezSGTqD7OaewDI/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/olPs1cVezSGTqD7OaewDI/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Next.js 15에서 poweredByHeader 비활성화하는 방법" href="/TIL/post/2025-04-22-poweredByHeader"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15에서 poweredByHeader 비활성화하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15에서 poweredByHeader 비활성화하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15에서 poweredByHeader 비활성화하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">8 hours ago</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js 15 onDemandEntries 사용 방법" href="/TIL/post/2025-04-22-onDemandEntries"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15 onDemandEntries 사용 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15 onDemandEntries 사용 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15 onDemandEntries 사용 방법</strong><div class="PostList_meta__VCFLX"><span class="date">8 hours ago</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js 15에서 optimizePackageImports로 불필요한 패키지 자동 최적화하는 방법" href="/TIL/post/2025-04-22-optimizePackageImports"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15에서 optimizePackageImports로 불필요한 패키지 자동 최적화하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15에서 optimizePackageImports로 불필요한 패키지 자동 최적화하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15에서 optimizePackageImports로 불필요한 패키지 자동 최적화하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">8 hours ago</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js 15 output 파일이란" href="/TIL/post/2025-04-22-output"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15 output 파일이란" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15 output 파일이란" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15 output 파일이란</strong><div class="PostList_meta__VCFLX"><span class="date">8 hours ago</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nextjs15에서 로깅(logging) 설정하는 방법" href="/TIL/post/2025-04-22-logging"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nextjs15에서 로깅(logging) 설정하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nextjs15에서 로깅(logging) 설정하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Nextjs15에서 로깅(logging) 설정하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">8 hours ago</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nextjs에서 mdxRs 사용하는 방법" href="/TIL/post/2025-04-22-mdxRs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nextjs에서 mdxRs 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nextjs에서 mdxRs 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Nextjs에서 mdxRs 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">8 hours ago</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js 15 커스텀 캐시 핸들러 구현 방법" href="/TIL/post/2025-04-22-CustomNextjsCacheHandler"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15 커스텀 캐시 핸들러 구현 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15 커스텀 캐시 핸들러 구현 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15 커스텀 캐시 핸들러 구현 방법</strong><div class="PostList_meta__VCFLX"><span class="date">8 hours ago</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js 15에서 Inline CSS 작성하는 방법" href="/TIL/post/2025-04-22-inlineCss"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15에서 Inline CSS 작성하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15에서 Inline CSS 작성하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15에서 Inline CSS 작성하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">8 hours ago</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Node.js httpAgentOptions 완벽 가이드" href="/TIL/post/2025-04-22-httpAgentOptions"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Node.js httpAgentOptions 완벽 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Node.js httpAgentOptions 완벽 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Node.js httpAgentOptions 완벽 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">8 hours ago</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="2025년 최신 이미지 최적화 기술과 활용법 총정리" href="/TIL/post/2025-04-22-images"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="2025년 최신 이미지 최적화 기술과 활용법 총정리" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="2025년 최신 이미지 최적화 기술과 활용법 총정리" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">2025년 최신 이미지 최적화 기술과 활용법 총정리</strong><div class="PostList_meta__VCFLX"><span class="date">8 hours ago</span><span class="PostList_reading_time__6CBMQ">24<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/TIL/posts/1">1</a><a class="link" href="/TIL/posts/2">2</a><a class="link" href="/TIL/posts/3">3</a><a class="link posts_-active__YVJEi" href="/TIL/posts/4">4</a><a class="link" href="/TIL/posts/5">5</a><a class="link" href="/TIL/posts/6">6</a><a class="link" href="/TIL/posts/7">7</a><a class="link" href="/TIL/posts/8">8</a><a class="link" href="/TIL/posts/9">9</a><a class="link" href="/TIL/posts/10">10</a><a class="link" href="/TIL/posts/11">11</a><a class="link" href="/TIL/posts/12">12</a><a class="link" href="/TIL/posts/13">13</a><a class="link" href="/TIL/posts/14">14</a><a class="link" href="/TIL/posts/15">15</a><a class="link" href="/TIL/posts/16">16</a><a class="link" href="/TIL/posts/17">17</a><a class="link" href="/TIL/posts/18">18</a><a class="link" href="/TIL/posts/19">19</a><a class="link" href="/TIL/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Next.js 15에서 poweredByHeader 비활성화하는 방법","description":"","date":"2025-04-22 13:17","slug":"2025-04-22-poweredByHeader","content":"\n\n# poweredByHeader 설정\n\nNext.js를 사용하다 보면, 기본적으로 모든 응답 헤더에 `x-powered-by`라는 헤더가 붙어요. 이 헤더는 \"이 사이트가 Next.js로 만들어졌다\"는 걸 알려주는데, 보안상 노출을 줄이거나 단순히 이 헤더를 빼고 싶을 때가 있죠.\n\n이럴 때는 `next.config.js` 파일을 열어서 `poweredByHeader` 설정을 꺼주면 돼요.\n\n```js\nmodule.exports = {\n  poweredByHeader: false,\n}\n```\n\n이렇게 하면 서버가 응답할 때 `x-powered-by` 헤더가 더 이상 붙지 않아요.\n\n---\n\n### 추가로 알아두면 좋은 점\n\n- **보안성 강화**  \n  노출되는 정보는 최소화하는 게 좋은 보안 습관이에요. `x-powered-by` 헤더를 빼면 해커가 사용하는 도구가 사이트의 기술 스택을 파악하는 걸 조금이나마 어렵게 만들 수 있습니다.\n\n- **SEO나 서비스 성능에는 영향 없음**  \n  이 설정은 단지 헤더 노출 여부만 바꾸는 거라 웹사이트 성능이나 검색엔진 최적화(SEO)에 영향은 없어요.\n\n- **Next.js 기본 설정**  \n  Next.js는 편의를 위해 기본으로 켜져있지만, 필요에 따라 언제든 끌 수 있으니 맞춤 설정 해주세요.\n\n혹시 더 궁금한 내용이나 Next.js 설정에 대해 알고 싶다면 언제든 질문해주세요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":1},{"title":"Next.js 15 onDemandEntries 사용 방법","description":"","date":"2025-04-22 13:16","slug":"2025-04-22-onDemandEntries","content":"\n\n# onDemandEntries 설정으로 Next.js 개발 서버 메모리 관리하기\n\nNext.js에서 개발할 때 서버가 빌드된 페이지들을 메모리에 얼마나 오래, 몇 개까지 유지할지 제어할 수 있는 옵션이 있다는 걸 아셨나요? 이 옵션이 바로 **onDemandEntries**입니다.\n\n기본값도 있지만, 직접 설정을 바꿔주면 개발환경에서 페이지 리로딩 속도나 메모리 사용량을 조절하는 데 도움이 될 수 있어요.\n\n예를 들어, `next.config.js` 파일에 다음처럼 추가하면 됩니다:\n\n```js\nmodule.exports = {\n  onDemandEntries: {\n    // 페이지를 메모리에 유지하는 최대 시간 (밀리초 단위)\n    maxInactiveAge: 25 * 1000,  // 25초 동안 비활성 페이지 유지\n    // 동시에 메모리에 유지할 페이지 수\n    pagesBufferLength: 2,\n  },\n}\n```\n\n- **maxInactiveAge**: 개발 서버가 사용하지 않는 페이지를 메모리에 남겨두는 시간이에요. 기본값은 25초 정도입니다. 너무 짧게 하면 자주 페이지를 다시 빌드해서 느릴 수 있고, 너무 길면 메모리 낭비가 발생할 수 있죠.\n- **pagesBufferLength**: 서버가 한 번에 메모리에 유지할 페이지 수입니다. 이 숫자를 늘리면 여러 페이지를 빠르게 전환할 때 빌드 시간을 줄일 수 있지만, 메모리도 더 많이 사용해요.\n\n### 참고! onDemandEntries가 어떻게 도움이 될까?\n\n앱 개발 중에 페이지를 자주 수정하거나 이동할 때, 이 옵션을 조절하면 번거로운 리로딩이나 대기 시간을 줄일 수 있어요. 특히 큰 프로젝트에서는 이걸 적절히 설정하면 개발 속도가 확실히 빨라집니다.\n\n### 추가 팁\n\n- 너무 짧거나 너무 길게 설정하지 말고, 본인 프로젝트 상황에 맞게 한번씩 조절해보세요.\n- `pagesBufferLength`는 너무 크게 설정하면 메모리 사용량이 커지므로, 적절히 테스트해서 맞추는 게 좋습니다.\n- 프로덕션 환경에는 영향을 미치지 않는 설정이니 걱정 없이 개발할 때만 조절하세요!\n\n그럼 오늘도 Next.js 개발 즐겁게 하시길 바랍니다! 😊","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":2},{"title":"Next.js 15에서 optimizePackageImports로 불필요한 패키지 자동 최적화하는 방법","description":"","date":"2025-04-22 13:16","slug":"2025-04-22-optimizePackageImports","content":"\n\n# optimizePackageImports\n\n개발하다 보면 어떤 패키지들은 수백 개, 많게는 수천 개의 모듈을 내보내기도 하죠. 이런 경우, 필요하지 않은 모듈들까지 다 불러오면 개발 속도가 느려지고, 최종 빌드 결과물도 커져서 성능에 악영향을 줄 수 있어요.\n\n그래서 Next.js에서는 `experimental.optimizePackageImports`라는 실험적인 기능을 제공하는데요. 여기에 패키지 이름을 등록해두면, 실제로 사용하는 모듈들만 딱 로드해줘서 부담을 확 줄일 수 있어요. 그렇지만, 평소처럼 여러 named export를 한꺼번에 import하는 작성 방식은 그대로 유지할 수 있어서 편리하답니다.\n\n사용법은 아주 간단해요. `next.config.js`에 아래처럼 추가하면 됩니다:\n\n```js\nmodule.exports = {\n  experimental: {\n    optimizePackageImports: ['package-name'],\n  },\n}\n```\n\n이렇게 하면 `package-name` 내에서 내가 쓰는 부분만 덜 불러오니까, 개발 속도도 더 빠르고 빌드 사이즈도 더 작아질 수 있어요.\n\n---\n\n### 조금 더 추가로!\n\n- 아직 실험적인 기능이라서, 모든 패키지에서 완벽하게 동작하지 않을 수 있으니 주의하세요.\n- 보통 대용량 UI 라이브러리(e.g., lodash, moment, antd 등)에서 특히 효과가 좋습니다.\n- 추후 정식 기능으로 자리잡으면 더 안정적으로 지원될 가능성이 높으니 깃허브나 공식 문서에서 업데이트를 계속 체크하는 게 좋아요.\n\n복잡한 임포트 덕분에 빌드 시간이 느려지거나, 최종 번들 파일이 너무 커지는 분들에게는 꽤 유용한 옵션이니 꼭 기억해두면 좋아요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안녕하세요 여러분! 오늘은 웹 개발할 때 자주 쓰는 라이브러리들 중에서 **기본적으로 최적화가 적용되는 라이브러리들**을 소개해드릴게요. 최적화가 미리 되어있는 라이브러리를 사용하면 번들 사이즈가 줄어들고, 성능도 더 좋아져서 프로젝트에 큰 도움이 된답니다.\n\n아래는 기본적으로 최적화가 되어 있는 라이브러리 목록이에요:\n\n| 라이브러리명                     | 설명 및 특징                                      |\n|---------------------------------|------------------------------------------------|\n| lucide-react                    | 가벼운 SVG 아이콘 라이브러리                     |\n| date-fns                       | 날짜/시간 다루기 편한 함수 모음                   |\n| lodash-es                      | 함수형 프로그래밍 기반 유틸리티 라이브러리         |\n| ramda                         | 함수형 프로그래밍 도구, 불변성 유지에 도움         |\n| antd                          | 기업용 UI 컴포넌트 라이브러리                        |\n| react-bootstrap               | Bootstrap을 React 전용으로 재구현한 컴포넌트 모음    |\n| ahooks                        | React 훅(Hooks) 유틸리티                            |\n| @ant-design/icons             | Ant Design 아이콘 모음                              |\n| @headlessui/react            | UI 로직만 제공하고 스타일링은 자유롭게 할 수 있는 컴포넌트 |\n| @headlessui-float/react      | Headless UI 기능 중 'float' 관련 컴포넌트            |\n| @heroicons/react/20/solid    | 깔끔한 20px 사이즈의 Heroicons 솔리드 버전          |\n| @heroicons/react/24/solid    | 깔끔한 24px 사이즈의 Heroicons 솔리드 버전          |\n| @heroicons/react/24/outline  | 깔끔한 24px 사이즈의 Heroicons 아웃라인 버전        |\n| @visx/visx                   | 데이터 시각화용 React 컴포넌트                        |\n| @tremor/react                | 대시보드 UI 컴포넌트 라이브러리                      |\n| rxjs                         | 반응형 프로그래밍 라이브러리                          |\n| @mui/material                | 머티리얼 UI 핵심 컴포넌트                             |\n| @mui/icons-material          | 머티리얼 UI 아이콘 모음                               |\n| recharts                     | 그래프 시각화용 React 컴포넌트                         |\n| react-use                    | 유용한 React 훅들 모음                               |\n| @material-ui/core            | 구버전 머티리얼 UI의 핵심 컴포넌트                     |\n| @material-ui/icons           | 구버전 머티리얼 UI 아이콘 모음                         |\n| @tabler/icons-react          | SVG 아이콘 라이브러리                                  |\n| mui-core                     | MUI의 코어 컴포넌트 패키지                            |\n| react-icons/*                | 다양한 아이콘을 쉽게 불러올 수 있는 아이콘 라이브러리     |\n\n---\n\n### 왜 최적화된 라이브러리를 써야 할까?\n\n웹 앱 성능이 점점 중요해지면서, **번들 사이즈 줄이기**와 **필요한 코드만 가져오기(tree-shaking)**가 필수가 되었어요. 만약 최적화가 안 되어있는 라이브러리를 쓰면, 불필요한 코드까지 함께 번들에 포함돼서 로딩 속도가 느려질 수 있어요.\n\n그래서 React 프로젝트에서는 위와 같은 미리 최적화가 잘 된 라이브러리를 많이 추천하죠. 특히 아이콘이나 UI 컴포넌트 같이 많이 쓰이는 라이브러리라면 이런 점이 더 중요해요.\n\n---\n\n### 팁!\n\n- 라이브러리 import할 때 **ES 모듈 방식을 사용하면** 트리쉐이킹에 더 유리해요.\n- 같은 종류의 아이콘이라도 `react-icons` 같은 라이브러리는 필요한 아이콘만 골라서 import 할 수 있어서 번들 사이즈 절감에 좋죠.\n- MUI 같은 경우도 최신 버전에서는 tree-shaking에 꽤 신경을 많이 쓰고 있으니 최신 버전을 사용하는 걸 추천해요.\n\n---\n\n### 마무리\n\n어떤 라이브러리를 쓰느냐에 따라서 프로젝트 성능이 달라질 수 있으니, 꼭 위 라이브러리들을 참고해서 최적화를 신경써보세요. 😊  \n앞으로도 유용한 정보와 꿀팁들 많이 공유할게요!\n\n궁금한 점 있으면 댓글로 남겨주세요~!  \n좋은 하루 보내세요!🚀","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":5},{"title":"Next.js 15 output 파일이란","description":"","date":"2025-04-22 13:16","slug":"2025-04-22-output","content":"\n\n# Output\n\nNext.js는 빌드 과정에서 각 페이지와 그 의존성들을 자동으로 추적해서, 프로덕션 버전을 배포하는 데 필요한 파일들만 골라내요.\n\n이 기능 덕분에 배포 크기를 확 줄일 수 있어요. 예전에는 Docker로 배포할 때 `next start`를 실행하려면 패키지 의존성에 포함된 모든 파일을 다 설치해야 했죠. 그런데 Next.js 12부터는 `.next/` 디렉터리 안의 Output File Tracing을 활용해서 꼭 필요한 파일만 포함할 수 있게 되었답니다.\n\n게다가 이 방법은 이제 더 이상 사용하지 않는 `serverless` 타깃을 쓸 필요도 없게 만드는데요, 이 `serverless` 모드는 여러 가지 문제를 일으키기도 하고 불필요한 파일 복제를 만들어내기도 했었거든요.\n\n---\n\n추가로, Output File Tracing이 잘 작동하려면, 여러분이 직접 추가한 네이티브 모듈(native modules)이나 외부 파일들이 제대로 인식되는지 꼭 확인해보세요. 때때로 수동으로 설정을 조금 조정해줘야 할 수도 있거든요. 전체 빌드와 배포 최적화를 목표로 한다면 이 부분도 신경 쓰는 게 좋아요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 어떻게 작동할까?\n\nNext.js가 빌드될 때, 내부적으로 **@vercel/nft**라는 도구를 사용해서 코드를 정적으로 분석해요. 여기서 import, require, 그리고 fs(파일 시스템)를 어떻게 쓰는지 살펴보면서, 특정 페이지가 로딩할 수 있는 모든 파일을 미리 파악하죠.\n\n또한, Next.js의 프로덕션 서버도 필요한 파일들을 추적해서 `.next/next-server.js.nft.json`이라는 결과물을 만들어줘요. 이 파일은 실제 운영 환경에서 어떤 파일들이 필요한지 알려주는 중요한 파일이에요.\n\n이렇게 생성된 `.nft.json` 파일들을 활용하려면, 이 JSON 안에 적힌 파일 목록을 읽고, 실제 파일 경로를 기준으로 필요한 파일들을 복사해서 배포할 위치에 넣으면 된답니다.\n\n---\n\n### 추가로 알아두면 좋은 점!\n\n- **@vercel/nft**는 Node.js 프로젝트에서 필요한 파일들을 추적하는 데 정말 유용한 도구에요. Next.js 외에도 서버리스 환경에서 최적화된 배포를 할 때도 활용하곤 하죠.\n- 이 방식을 이용하면, 불필요한 파일들을 빼고 정말 필요한 파일만 배포할 수 있어서 용량도 줄이고, 보안 측면에서도 이점이 있어요.\n- 만약 환경변수에 따라 동적으로 파일을 로딩하는 코드를 쓰면, 그 부분은 정적 분석에서 누락될 수 있으니 주의해야 해요. 그러니 동적 import를 많이 쓴다면 직접 확인해주는 게 좋아요.\n\n간단히 말해서, Next.js는 앱에 필요한 모든 파일들을 꼼꼼히 체크해서 배포 시 효율적으로 관리할 수 있게 도와주는 거죠!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 자동으로 추적된 파일 복사하기\n\nNext.js에서는 배포할 때 필요한 파일들만 쏙쏙 골라서 복사해주는 'standalone' 폴더를 자동으로 만들어줍니다. 여기에는 프로젝트 파일뿐만 아니라, 꼭 필요한 node_modules 내의 파일들도 포함돼요. 덕분에 용량도 줄고, 배포 속도도 빨라지니 아주 편리하답니다!\n\n이 기능을 사용하려면 `next.config.js` 파일에 아래처럼 설정만 추가해주면 끝!\n\n```js\nmodule.exports = {\n  output: 'standalone',\n}\n```\n\n이렇게 설정하면 Next.js가 빌드할 때 필요한 파일들만 골라서 따로 모아준답니다. 특히 서버리스 함수나 도커 환경처럼 가볍고 독립적인 배포가 필요할 때 정말 유용해요.\n\n**추가 팁!**  \n- 만약 직접 추가로 복사해야 할 파일이나 폴더가 있다면, `next.config.js`에서 `webpack` 설정을 활용해 커스터마이징할 수도 있어요.  \n- standalone 모드는 기본적으로 빌드된 output을 따로 분리하다 보니, 기존의 `next start` 명령어로도 다루기 쉬워진답니다.\n\n필요한 파일만 추려서 배포하고 싶다면 꼭 한 번 적용해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 내용을 쉽게 풀어서 설명해볼게요!\n\n---\n\nNext.js를 빌드하면 `.next/standalone`이라는 폴더가 생기는데, 이 폴더는 따로 `node_modules`를 설치하지 않고도 바로 배포할 수 있어요. 즉, 배포 환경을 좀 더 간소화할 수 있는 장점이 있죠.\n\n그리고 `server.js`라는 작은 서버 파일도 함께 만들어지는데, 이 파일은 기존에 `next start`로 서버를 띄우는 대신 사용할 수 있어요. 여기서 중요한 점은, 이 작은 서버는 기본적으로 `public` 폴더나 `.next/static` 폴더를 복사하지 않아요. 보통 정적 파일은 CDN에서 처리하는 게 효율적이기 때문이에요.\n\n하지만 만약 CDN을 사용하지 않고 직접 서버에서 이 정적 파일들도 서비스하고 싶다면, 빌드 후에 아래 명령어로 직접 폴더를 복사해주면 돼요:\n\n```bash\ncp -r public .next/standalone/ \u0026\u0026 cp -r .next/static .next/standalone/.next/\n```\n\n복사가 끝나면, `server.js`가 이 경로에 있는 정적 파일들을 자동으로 서빙하게 됩니다.\n\n---\n\n조금 더 덧붙이자면, 단독 배포(standalone deployment)는 서버리스 환경이나 컨테이너 배포 등에서 아주 유용해요. 보통 `node_modules` 폴더 크기가 꽤 되는데, 이걸 제외하고 필요한 코드만 딱 가져가니까 훨씬 가볍고 빠르게 배포할 수 있어요.\n\n또한, CDN을 활용하면 정적 파일 로딩 속도가 더 빨라져서 사용자 경험도 좋아지니까, 가능하면 CDN을 쓰는 방향을 추천해요. 그래도 간단하게 로컬 서버에서 정적 파일도 서비스해보고 싶다면, 위 복사 명령어 기억해두면 되겠죠?\n\n---\n\n필요할 때마다 이렇게 `standalone` 빌드 사용하시고, 배포 환경에 맞게 정적 파일 처리 방법도 유연하게 선택해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n로컬에서 최소한의 server.js 파일을 실행하고 싶다면, 아래 커맨드를 사용하면 돼요:\n\n```bash\nnode .next/standalone/server.js\n```\n\n\u003e 참고할 점:  \n만약 여러분의 프로젝트가 특정 포트나 호스트네임에서 서버를 띄워야 한다면, 실행 전에 환경변수로 PORT나 HOSTNAME을 설정할 수 있어요.  \n예를 들어,  \n```bash\nPORT=8080 HOSTNAME=0.0.0.0 node server.js\n```\n이렇게 하면 http://0.0.0.0:8080 에서 서버가 실행됩니다.\n\n---\n\n## 주의할 점 (Caveats)\n\n이어서, server.js를 사용할 때 알아두면 좋은 주의사항들도 있으니 같이 살펴봐요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nmonorepo 환경에서 Next.js의 트레이싱 기능을 사용할 때, 기본적으로 프로젝트 디렉토리가 트레이싱의 기준이 돼요. 예를 들어 `packages/web-app`이라는 패키지를 빌드할 때, `packages/web-app` 폴더만 트레이싱 루트로 잡히고, 그 밖의 파일들은 포함되지 않아요. 만약 이 외부 파일들도 포함시키고 싶다면 `next.config.js`에서 `outputFileTracingRoot`를 설정해주면 됩니다.\n\n```js\nmodule.exports = {\n  // monorepo 루트가 현재 디렉토리에서 두 단계 위에 있는 경우\n  outputFileTracingRoot: path.join(__dirname, '../../'),\n}\n```\n\n이렇게 하면 monorepo의 최상위 폴더부터 파일을 추적하기 때문에, 여러 패키지에서 필요한 공통 파일도 문제없이 포함될 수 있어요.\n\n---\n\n근데 가끔 Next.js가 필요한 파일을 빼먹거나, 반대로 필요 없는 파일을 잘못 포함시키는 경우가 있어요. 이럴 때 `outputFileTracingExcludes`와 `outputFileTracingIncludes` 옵션을 활용할 수 있습니다. \n\n- `outputFileTracingExcludes`: 특정 페이지나 API 라우트에 대해 추가적으로 제외하고 싶은 파일이나 폴더를 지정\n- `outputFileTracingIncludes`: 특정 페이지나 API 라우트에 대해 추가로 포함해야 하는 파일이나 폴더를 지정\n\n두 옵션 모두 minimatch glob 형식의 패턴을 받아서 더 세밀하게 조절할 수 있답니다.\n\n```js\nmodule.exports = {\n  outputFileTracingExcludes: {\n    '/api/hello': ['./un-necessary-folder/**/*'], // '/api/hello' 라우트에 un-necessary-folder 아래 모든 파일 제외\n  },\n  outputFileTracingIncludes: {\n    '/api/another': ['./necessary-folder/**/*'], // '/api/another' 라우트에 necessary-folder 포함\n    '/api/login/\\\\[\\\\[\\\\.\\\\.\\\\.slug\\\\]\\\\]': [\n      './node_modules/aws-crt/dist/bin/**/*', // 동적 라우트 '[...slug]'에 node_modules aws-crt 라이브러리 포함\n    ],\n  },\n}\n```\n\n---\n\n팁을 하나 더 드리자면, monorepo에서 이렇게 설정을 잘 해두면 빌드할 때 누락된 파일 문제를 방지하고, 불필요한 파일까지 묶이는 걸 막을 수 있어서 배포 용량 최적화에도 큰 도움이 돼요. 꼭 필요하다면 로깅 기능이나 자체 스크립트를 활용해서 다음 빌드에 포함되는 파일들을 점검해보는 것도 좋아요!  \n\nNext.js가 파일 트레이싱을 완전히 자동으로 잘 해주긴 하지만, 가끔 민감한 상황에서는 이 설정들로 미세 조정할 수 있다는 점 꼭 기억해두세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n참고: outputFileTracingIncludes/outputFileTracingExcludes의 키는 glob 패턴이라서, 특수 문자는 꼭 이스케이프 처리를 해줘야 해요.\n\n- 현재 Next.js는 생성된 `.nft.json` 파일들을 따로 처리하지 않아요. 이 파일들은 배포 플랫폼(예: Vercel)에서 읽어서, 최소한의 용량으로 배포하기 위해 사용됩니다. 앞으로 출시될 버전에서는 이 `.nft.json` 파일들을 활용하는 새로운 명령어도 계획 중이라고 하네요.\n\n## 실험적인 turbotrace 기능\n\n의존성 추적(tracing)은 복잡한 계산과 분석을 필요로 해서 속도가 느릴 수밖에 없어요. 그래서 저희는 Rust로 turbotrace라는 도구를 만들었는데요, 기존 자바스크립트 구현체보다 훨씬 빠르고 똑똑한 대안이랍니다.\n\n---\n\n여기서 잠깐! glob 패턴을 쓸 때는 `*`, `?`, `[` 같은 특수 문자를 적절히 이스케이프해야 예상치 못한 결과를 막을 수 있어요. 예를 들어, `\\*`처럼 백슬래시를 붙여주면 안전합니다.\n\n그리고 turbotrace가 나중에 공식 next.js에 통합되면, 배포 속도도 많이 가뿐해질테니 기대해봐도 좋겠네요! Rust 기반이라 메모리 관리가 더 효율적인 점도 큰 장점입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 turbotrace 기능을 활성화하려면, `next.config.js` 파일에 아래와 같은 설정을 추가해주면 됩니다:\n\n```js\nmodule.exports = {\n  experimental: {\n    turbotrace: {\n      // turbotrace 로그 레벨을 제어합니다. 기본값은 'error'입니다.\n      logLevel:\n        | 'bug'\n        | 'fatal'\n        | 'error'\n        | 'warning'\n        | 'hint'\n        | 'note'\n        | 'suggestions'\n        | 'info',\n      \n      // 분석의 상세 내용을 로그에 포함할지 여부 (기본값: false)\n      logDetail: false,\n      \n      // 모든 로그 메시지를 제한 없이 보여줍니다.\n      // 기본적으로 turbotrace는 각 카테고리별로 1개의 로그 메시지만 표시합니다.\n      logAll: false,\n      \n      // turbotrace의 컨텍스트 디렉터리를 지정합니다.\n      // 컨텍스트 디렉터리 외부의 파일은 추적 대상에서 제외됩니다.\n      // `outputFileTracingRoot` 설정과 유사한 역할을 합니다.\n      // 만약 `outputFileTracingRoot`와 `contextDirectory`가 모두 설정되어 있으면, `contextDirectory`가 우선됩니다.\n      contextDirectory: '',\n      \n      // 코드 내 `process.cwd()` 표현이 있다면 이것을 turbotrace에 알리기 위한 설정입니다.\n      // 예를 들어 `require(process.cwd() + '/package.json')` 같은 경우 올바르게 추적됩니다.\n      processCwd: '',\n      \n      // turbotrace의 최대 메모리 사용량(MB 단위)을 설정합니다. 기본값은 6000MB입니다.\n      memoryLimit: 6000,\n    },\n  },\n}\n```\n\n---\n\n### turbotrace 기능이 뭐죠?\n\nturbotrace는 Next.js에서 사용되는 파일 의존성 추적 도구에요. 앱 번들링이나 서버리스 배포할 때 어떤 파일들이 실제로 필요한지 스스로 추적해서 정확한 파일만 포함할 수 있게 도와줍니다. 이 덕분에 배포 크기 최적화나 빌드 시간 단축에 효과적이죠.\n\n---\n\n### 몇 가지 팁!\n\n- `logLevel`을 `'info'`나 `'suggestions'`로 높여두면 turbotrace가 어떻게 동작하는지 더 자세한 정보들을 확인할 수 있으니 디버깅할 때 유용해요.\n- `contextDirectory`를 프로젝트 루트로 지정하면 외부 라이브러리나 임시 파일 같은 엉뚱한 파일 추적을 줄일 수 있어요.\n- 메모리 제한(`memoryLimit`)은 상황에 맞게 조절해보세요. 큰 프로젝트라면 기본 6000MB보다 더 늘려야 문제가 생기지 않을 수 있어요.\n\n---\n\nNext.js를 사용할 때 이런 실험적인 기능들을 직접 써보면서 프로젝트에 맞게 튜닝해보는 것도 재미있는 경험이 될 거예요! 언제든 최신 문서나 커뮤니티 의견도 참고하면서 최적화해보세요 :)","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":10},{"title":"Nextjs15에서 로깅(logging) 설정하는 방법","description":"","date":"2025-04-22 13:15","slug":"2025-04-22-logging","content":"\n\n# 로깅(logging) 설정하기\n\n## 옵션(Options)\n\n### 정보 가져오기(Fetching)\n\nNext.js를 개발 모드에서 실행할 때, 콘솔에 찍히는 로그의 수준(logging level)과 전체 URL이 출력될지 여부를 설정할 수 있어요.\n\n이 기능을 잘 활용하면 디버깅할 때 필요한 정보만 골라서 볼 수 있어서 개발 생산성이 쑥쑥 올라가죠!\n\n---\n\n추가로 알아두면 좋은 점!\n\n- 로깅 레벨을 너무 자세하게 설정하면 로그가 너무 많아서 오히려 원하는 정보를 찾기 어려울 수 있어요.\n- 반대로 너무 적게 설정하면 중요한 디버깅 정보가 누락될 수 있으니 상황에 맞게 조절하는 게 좋아요.\n- 전체 URL 출력은 인증 토큰 같은 민감한 정보가 포함될 수 있으니, 실제 서비스 환경에서는 주의를 기울이는 게 좋습니다.\n\nNext.js에서는 보통 `next.config.js` 파일이나 환경변수를 통해 이런 로깅 설정을 편리하게 조절할 수 있습니다. 다음에 설정 방법도 한 번 정리해볼게요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n현재 로깅(logging) 기능은 fetch API를 사용한 데이터 가져오기(fetching)에만 적용되고 있어요. 즉, Next.js 내부에서 발생하는 다른 로그들은 아직 이 설정에 포함되지 않습니다.\n\n```js\nmodule.exports = {\n  logging: {\n    fetches: {\n      fullUrl: true,\n    },\n  },\n}\n```\n위 설정을 추가하면 fetch 요청 시 전체 URL이 로그에 출력돼서, 어느 경로로 데이터를 요청했는지 더 명확하게 알 수 있어요.\n\n그리고 Next.js의 Server Components 기능에서 **HMR(Hot Module Replacement)** 캐시에서 복원된 fetch 요청들은 기본적으로는 로그에 찍히지 않습니다. 만약 이 부분도 로그로 보고 싶다면, 아래처럼 `hmrRefreshes` 옵션을 true로 설정하면 돼요.\n\n```js\nmodule.exports = {\n  logging: {\n    fetches: {\n      hmrRefreshes: true,\n    },\n  },\n}\n```\n\n이렇게 하면 코드 변경 시 HMR로 인해 캐시된 fetch 요청들도 모두 로그로 확인할 수 있어서, 개발 중 네트워크 요청의 흐름을 더 잘 파악할 수 있답니다.\n\n---\n\n💡 **추가 팁!**  \n- 로그 레벨 관리나 커스텀 로깅을 추가하고 싶으면, Next.js 자체 로깅이 아닌 별도의 로깅 라이브러리(winston, pino, loglevel 등)를 도입하는 것도 좋은 방법이에요.  \n- 특히 서버 환경과 클라이언트 환경에서 각각 로그를 구분하는 게 필요할 때 유용하니 참고하세요!  \n- 그리고 로그가 너무 많이 찍히면 개발 속도가 느려질 수 있으니, 필요한 부분만 선별적으로 켜는 게 좋아요.\n\n필요한 설정을 통해 fetch 요청에 대해 잘 관찰하면서, Next.js 프로젝트를 더 효율적으로 개발해봐요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 들어오는 요청( Incoming Requests ) 로그 관리하기\n\n개발할 때 보통 콘솔 창에서 들어오는 요청들이 쭉 찍히는 걸 보신 적 있죠? 기본 설정은 그렇게 모든 요청을 다 로그로 남기도록 되어 있는데요, 이게 너무 많아서 중요한 로그가 묻히거나 콘솔이 지저분해질 때가 있어요.\n\n그래서 `incomingRequests` 옵션을 활용해서 어떤 요청은 로그에서 아예 빼버릴 수 있습니다. 참고로 이 옵션은 개발 환경에서만 작동하고, 실제 배포된 프로덕션 환경에는 영향이 없으니 걱정 말고 사용하시면 돼요!\n\n간단하게 예를 들어보면:\n\n```js\nmodule.exports = {\n  logging: {\n    incomingRequests: {\n      ignore: [/\\api\\/v1\\/health/],\n    },\n  },\n}\n```\n\n위 설정은 API 내 건강 체크용 엔드포인트 `/api/v1/health`에 대한 요청만 콘솔 로그에서 무시하는 거예요. 보통 이런 헬스 체크는 너무 자주 호출되기 때문에 로그에 계속 찍히면 방해가 될 때가 많죠.\n\n그리고 만약 **아예 모든 들어오는 요청 로그를 끄고 싶을 때**는 이렇게 할 수 있어요:\n\n```js\nmodule.exports = {\n  logging: {\n    incomingRequests: false,\n  },\n}\n```\n\n이렇게 하면 개발 중일 때도 요청 로그가 완전히 안 찍히니, 정말 필요 없을 때 과감히 꺼버리는 것도 방법이에요.\n\n---\n\n\u003e TIP!  \n\u003e 로그 정리는 개발 생산성을 크게 높여요. 너무 많은 불필요한 로그로 중요한 오류 메시지를 놓치지 않도록 필요한 것만 남겨두는 습관을 들여보세요~\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nJS 설정 파일에서 로그(logging)를 제어하는 방법에 대해 간단하게 정리해볼게요.\n\n---\n\n## 로그 끄기 설정하기\n\n기본적으로 `logging` 옵션을 객체 형태로 설정해서 `incomingRequests` 같은 세부 로그 항목을 조절할 수 있어요. 예를 들어, 들어오는 요청에 대한 로그를 끄고 싶으면 이렇게 설정하죠:\n\n```js\nmodule.exports = {\n  logging: {\n    incomingRequests: false,\n  },\n}\n```\n\n그런데 만약 개발 환경에서 아예 로그를 전부 끄고 싶다면, `logging`을 `false`로 바꾸면 돼요:\n\n```js\nmodule.exports = {\n  logging: false,\n}\n```\n\n이렇게 하면 불필요한 로그가 쏟아지는 걸 막아서 콘솔이 깔끔해지고, 개발할 때 필요한 정보만 집중할 수 있답니다.\n\n---\n\n### 좀 더 알려드리자면\n\n- 로그를 완전히 끄는 것보다 필요한 로그만 필터링해서 사용하는 게 보통 좋아요. 예를 들어 오류 로그만 켜두고, 디버그용 로그는 끄는 식으로요.\n- 로그는 개발할 때만 끄고, 배포 환경에서는 문제가 발생할 때 빠르게 원인을 찾을 수 있도록 적절히 켜두는 게 중요합니다.\n- 만약 로그가 너무 많아지면, 나중에 로그 분석 도구나 미들웨어를 써서 편리하게 관리해보는 것도 추천해요.\n\n---\n\n아래는 정리한 로그 설정 예시입니다.\n\n| 설정 | 설명                      |\n|-------|---------------------------|\n| `{ logging: false }` | 모든 로그 끄기            |\n| `{ logging: { incomingRequests: false } }` | 들어오는 요청 로그만 끄기 |\n\n이렇게 간단하게 로그를 껐다 켰다 하면서 개발 편의성을 높여보세요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":5},{"title":"Nextjs에서 mdxRs 사용하는 방법","description":"","date":"2025-04-22 13:15","slug":"2025-04-22-mdxRs","content":"\n\n# mdxRs\n\n이번 글에서는 Next.js에서 MDX 파일을 컴파일 할 때 사용하는 새로운 러스트(Rust) 기반 컴파일러인 `mdxRs`에 대해 이야기해볼게요.\n\n---\n\nMDX란, 마크다운(Markdown)과 JSX가 합쳐진 형태로, 리액트 컴포넌트를 마크다운 문서에 자연스럽게 섞어서 사용할 수 있게 해줘서 개발자들에게 아주 인기 있는 포맷이에요.\n\n기존 `@next/mdx` 플러그인은 자바스크립트로 작성된 컴파일러를 사용했는데요, 이번에 실험적으로 러스트로 작성된 훨씬 빠른 컴파일러를 지원하는 게 바로 `mdxRs`입니다. 러스트 컴파일러 덕분에 속도가 빨라지고 메모리 사용량도 줄일 수 있어 성능 효율이 좋아졌다는 장점이 있어요.\n\n---\n\n다음은 `mdxRs`를 Next.js 프로젝트에 적용하는 기본 설정입니다:\n\n```js\nconst withMDX = require('@next/mdx')()\n\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  pageExtensions: ['ts', 'tsx', 'mdx'], // mdx 파일도 페이지로 인식하게 합니다.\n  experimental: {\n    mdxRs: true, // 러스트 기반 MDX 컴파일러 활성화\n  },\n}\n\nmodule.exports = withMDX(nextConfig)\n```\n\n- `pageExtensions`: 여기서 MDX 확장자를 추가해서 `.mdx` 파일을 라우트 페이지로 사용할 수 있게 해주고요.\n- `experimental.mdxRs`: 실험 기능인 러스트 MDX 컴파일러를 활성화합니다. (오늘 기준으로는 실험 단계라 API가 바뀔 가능성도 있으니 참고하세요!)\n\n---\n\n### 참고로, 더 알아두면 좋은 점들\n\n- `mdxRs` 기능은 Next.js의 실험적인 기능에 해당하기 때문에, 버전을 업그레이드 할 때 호환성 문제나 기능 변경이 있을 수 있어요.\n- Rust 기반 컴파일러라서 최적화가 잘 되어 있어 특히 대용량 MDX 파일이나 빌드 시간이 긴 프로젝트에서 효과를 더 느낄 수 있습니다.\n- 이미 `@next/mdx` 플러그인에 익숙하다면, 특별한 변경 없이 옵션만 켜주면 되니까 도입도 쉽다는 장점이 있습니다.\n- 만약 MDX 내부에 복잡한 커스텀 컴포넌트가 많거나, 특별한 Babel/ESLint 설정이 필요하면 `withMDX` 함수 인자로 옵션들을 함께 전달해 더 세밀한 설정이 가능합니다.\n\n---\n\n마지막으로 실험적으로 만나볼 수 있는 이 기능, 직접 적용해보고 빌드 속도나 번들 결과물 차이가 어떤지 체감해 보는 것도 개발자로서 재미있는 경험이 될 거예요!\n\n더 많은 Next.js, MDX 관련 이야기는 앞으로도 공유할게요. 궁금한 점 있으면 댓글로 알려주세요 :)","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":2},{"title":"Next.js 15 커스텀 캐시 핸들러 구현 방법","description":"","date":"2025-04-22 13:14","slug":"2025-04-22-CustomNextjsCacheHandler","content":"\n\n# 커스텀 Next.js 캐시 핸들러\n\nNext.js에서 페이지 캐싱과 재검증(Incremental Static Regeneration, ISR)은 같은 캐시를 공유해요. Vercel 같은 플랫폼에 배포하면 이 ISR 캐시는 자동으로 내구성 있는 저장소에 저장되기 때문에 걱정할 필요가 없죠.\n\n그런데 만약 직접 서버를 운영한다면? 이 경우 ISR 캐시는 Next.js 서버의 파일 시스템(디스크)에 저장됩니다. Pages Router와 App Router 모두에서 이 방식이 기본적으로 잘 작동해요.\n\n하지만 만약 캐시를 좀 더 오래 보존하고 싶거나, 여러 컨테이너나 서버 인스턴스 간에 같은 캐시를 공유하고 싶다면? Next.js 캐시 저장 위치를 직접 설정할 수 있습니다. 이렇게 하면 내구성 있는 저장소(예: 네트워크 파일 시스템, 클라우드 스토리지 등)에 캐시를 저장하거나, 여러 서버가 같은 캐시를 함께 사용할 수 있죠.\n\n---\n\n\u003e **TIP!**  \n\u003e 직접 캐시 위치를 바꾸는 건 고급 설정이긴 하지만, 대규모 서비스에서는 상당히 유용해요. 예를 들어, 여러 서버가 동시에 캐시를 공유하면 캐시 미스(cache miss)를 줄이고, 전체 앱의 응답 속도를 개선할 수 있거든요.  \n\u003e  \n\u003e 참고로, 캐시 파일을 저장하는 경로는 Next.js 설정에서 `experimental` 옵션 아래 `cacheHandlerPath`를 지정해 관리할 수 있어요. (`next.config.js`에서 설정 가능)  \n\u003e  \n\u003e 나중에 여러 서버를 운영하거나 클러스터를 구성할 일이 있다면, 이 부분을 꼭 알아두시면 도움이 됩니다!\n\n---\n\n궁금하면 직접 `next.config.js`에 적용해보면서 전체 작동 흐름을 살펴보는 것도 좋아요. 아래에 간단한 예시를 덧붙일게요!\n\n```js\n// next.config.js\nmodule.exports = {\n  experimental: {\n    cacheHandlerPath: './custom-cache-handler.js',\n  },\n}\n```\n\n이렇게 하면 캐시 저장과 재검증 로직을 직접 커스텀한 파일에서 처리할 수 있어요. 물론, 고급 내용이라 추가 구현이 필요함을 기억하세요!\n\n---\n\nNext.js ISR 캐시 동작에 대해 한 번쯤 정리하면, 배포 환경이나 서버 정책에 따라 적절한 캐시 전략을 세울 때 큰 도움이 될 거예요.  \n앞으로 나올 Next.js 업데이트에서도 관련 기능이 계속 개선될 예정이라, 꾸준히 살펴보는 것도 추천합니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nmodule.exports = {\n  cacheHandler: require.resolve('./cache-handler.js'),\n  cacheMaxMemorySize: 0, // 기본 메모리 캐싱 비활성화\n}\n```\n\n위 코드는 커스텀 캐시 핸들러를 적용하는 간단한 예시입니다. 기본적으로 제공되는 메모리 캐시를 끄고, 직접 만든 캐시 핸들러 파일을 사용하도록 설정하죠.\n\n---\n\n## 커스텀 캐시 핸들러란?\n\n보통 캐시는 데이터나 결과를 서버 메모리에 저장해 재사용 속도를 높여주는 역할을 해요. 그런데 기본 캐시 방식이 내 프로젝트에 꼭 맞지 않거나, Redis 같은 외부 캐시 서버를 쓰고 싶을 때가 있죠. 그럴 경우 직접 캐시 저장/조회 로직을 짤 수 있는 커스텀 캐시 핸들러를 만들어서 적용할 수 있어요.\n\n---\n\n## API 참고: 캐시 핸들러에서 구현할 수 있는 메서드들\n\n| 메서드명       | 설명                                                            |\n|---------------|-----------------------------------------------------------------|\n| get           | 캐시에 저장된 데이터를 불러올 때 호출됩니다.                    |\n| set           | 새로운 데이터를 캐시에 저장할 때 사용합니다.                    |\n| revalidateTag | 특정 태그와 관련된 캐시를 무효화하거나 갱신할 때 사용됩니다.    |\n\n---\n\n### 조금 더 쉽게 풀어 설명하면...\n\n- `get`은 \"어? 내가 저장해 둔 자료 있나?\" 하고 찾아보는 함수에요.\n- `set`은 \"내가 새로 알게 된 정보를 저장해두자!\" 하고 기록하는 함수고요.\n- `revalidateTag`는 \"이 태그가 붙은 모든 캐시, 이제 좀 다시 확인해볼래요?\" 라고 해서 부분적인 캐시 무효화를 담당합니다.\n\n---\n\n### 참고\n\n- `cacheMaxMemorySize : 0` 으로 설정하면 Next.js나 다른 프레임워크가 제공하는 기본 메모리 캐시는 비활성화되어서, 완전히 내가 만든 캐시 핸들러만 동작합니다.\n- 캐시 핸들러는 비동기 함수일 수 있으니, async/await 문법을 활용해서 외부 저장소(예: Redis, Memcached)와 통신하는 게 일반적이에요.\n- 캐시 전략을 잘 짜야 성능과 일관성 모두 잡을 수 있으니, 상황에 맞게 TTL(Time To Live)이나 무효화 전략을 적절히 설정하세요.\n\n---\n\n궁금한 점이나 적용하면서 어려움 있으면 언제든지 댓글로 물어보세요. 직접 써보고 공부하는 것이 가장 빠른 길이니까요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### get()\n\n| Parameter | Type   | Description                |\n| --------- | ------ | --------------------------|\n| `key`     | string | 캐시에 저장된 값의 키입니다. |\n\n이 메서드는 캐시된 값을 반환해줍니다. 만약 해당 키에 맞는 값이 없으면 `null`을 돌려줘요.  \n개발할 때 자주 사용하는 캐시 기능인데, 예를 들어 어떤 API 결과를 캐시에 저장해 놓으면 나중에 똑같은 데이터를 다시 받아올 필요 없이 빠르게 꺼내 쓸 수 있죠.\n\n### set()\n\n(다음에 `set()` 메서드에 대해서도 이어서 설명해 드릴게요!)  \n\n---  \n참고로 캐시 캐이터를 활용할 때는 저장된 데이터의 라이프사이클, 만료시간 등을 잘 관리하는 게 성능 최적화에 큰 도움이 됩니다. 필요 없는 오래된 데이터가 계속 쌓이면 오히려 성능 저하를 초래할 수 있으니 주의하세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 캐시 관련 함수들의 파라미터와 설명을 정리한 내용이에요. 개발하면서 캐시를 효율적으로 관리하려면 이런 정보들을 잘 이해하는 게 중요하죠!\n\n### setCacheData()\n\n| Parameter | Type | Description |\n| --------- | ---- | ----------- |\n| `key` | `string` | 데이터를 저장할 때 사용할 키입니다. |\n| `data` | 데이터 타입 혹은 `null` | 캐시에 저장할 데이터입니다. |\n| `ctx` | `{ tags: [] }` | 캐시 태그들을 지정해주는 영역이에요. 관리 목적이나, 특정 태그를 기준으로 캐시를 무효화할 때 유용합니다. |\n\n이 함수는 데이터를 캐시에 저장하며, `Promise\u003cvoid\u003e`를 반환해서 비동기 작업임을 알려줍니다.\n\n---\n\n### revalidateTag()\n\n| Parameter | Type | Description |\n| --------- | ---- | ----------- |\n| `tag` | `string` 또는 `string[]` | 재검증할 캐시 태그들이에요. 배열로 여러 태그를 한 번에 지정할 수도 있고, 단일 문자열로 한 태그를 지정할 수도 있답니다. |\n\n이 함수는 특정 태그에 해당하는 캐시들을 재검증(재갱신)하는 역할을 해요. 캐시 무효화 전략에 있어서 태그 기반 관리는 꽤 강력한 수단이라서 알아두면 좋아요.\n\n---\n\n#### 개인적으로 덧붙이자면…\n\n- 캐시를 태그로 관리하면, 데이터의 특정 변경 사항에 맞춰 관련 데이터만 효율적으로 업데이트할 수 있어요.\n- 예를 들어, 블로그 포스트 리스트 페이지와 단일 포스트 페이지가 각각 다른 태그를 갖고 있으면, 특정 포스트가 수정될 때 해당 포스트 태그만 재검증해서 불필요한 전체 캐시 갱신을 줄일 수 있답니다.\n- `ctx` 같은 컨텍스트 객체를 활용해 다양한 태그를 잘 관리하는 것도 중요하니, 실제 프로젝트에서 캐시 전략을 짤 때 참고하세요!\n\n필요하면 이 내용을 기반으로 캐시 전략이나 코드를 더 자세히 다뤄볼게요. 언제든 궁금한 점 댓글로 남겨주세요! 😄\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n`Promise\u003cvoid\u003e`를 반환하는 함수에 대해 알아볼게요. 여기서는 주로 데이터 재검증(revalidation)이나 `revalidateTag()` 함수와 관련된 내용이에요.\n\n### 핵심 포인트\n\n- `revalidatePath`는 캐시 태그(cache tags)를 활용하기 위한 편의 함수예요.  \n- 이걸 호출하면 내부적으로 `revalidateTag` 함수가 실행되는데, 개발자가 원하는 대로 경로(path)를 기준으로 캐시 키를 태그할 수 있게끔 설계되어 있죠.\n\n즉, `revalidatePath`를 쓰면 경로나 특정 조건에 따라 캐시를 좀 더 세밀하게 관리할 수 있어서, 데이터가 바뀌었을 때 꼭 필요한 부분만 다시 새로고침할 수 있어요.\n\n---\n\n조금 더 쉽게 말하자면, 예전에는 전체 페이지 새로고침이나 데이터 재호출이 번거롭고 비용도 컸는데, 이 기능을 통해 '이 경로에 해당하는 데이터만' 선택적으로 빠르게 다시 불러올 수 있어서 효율성이 훨씬 높아졌다는 얘기죠.\n\n---\n\n## 버전 히스토리(Version History)\n\n아래 표에는 이 기능이 언제 어떤 부분이 업데이트되었는지 간단히 정리해봤어요.\n\n| 버전 | 변경 내용                         |\n|------|---------------------------------|\n| v1.0 | `revalidatePath` 기능 첫 도입    |\n| v1.1 | `revalidateTag` 호출 방식 개선  |\n| v1.2 | 캐시 태그 관리 최적화            |\n\n---\n\n혹시 이 부분과 관련해서 더 궁금한 게 있으면 언제든 질문해 주세요! 개발하면서 캐시나 데이터 최신화가 고민인 분들께 정말 좋은 팁이 될 거예요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 버전별 주요 변경사항을 정리한 표입니다. 이 표는 개발자들이 버전 업그레이드 시 참고할 수 있도록 쉽게 정리했어요.\n\n| Version   | Changes                                                  |\n|-----------|----------------------------------------------------------|\n| `v14.1.0` | `cacheHandler`로 이름 변경 및 안정화                       |\n| `v13.4.0` | `incrementalCacheHandlerPath`가 `revalidateTag` 지원      |\n| `v13.4.0` | `incrementalCacheHandlerPath`가 standalone output 지원    |\n| `v12.2.0` | 실험적 기능으로 `incrementalCacheHandlerPath` 추가          |\n\n여기서 `incrementalCacheHandlerPath`는 점진적 캐시 핸들링 기능인데, 최근 버전들에서 점점 더 안정화되고 범용적으로 지원되는 추세입니다. '재검증 태그(revalidateTag)'도 캐시 관리에 큰 도움이 되니, 최신 프로젝트에서는 이 기능들을 적극 활용해 보는 걸 추천해요!\n\n또한, `cacheHandler`가 안정화된 건 중요한 포인트인데요, 이름 변경과 함께 API가 더 견고해졌다는 뜻이니, 사용하는 라이브러리나 프레임워크에서 이 부분을 꼭 최신 상태로 유지하는 게 좋겠죠?","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":8},{"title":"Next.js 15에서 Inline CSS 작성하는 방법","description":"","date":"2025-04-22 13:14","slug":"2025-04-22-inlineCss","content":"\n\n# inlineCss\n\n## 사용 방법\n\n`inlineCss`는 Next.js에서 CSS를 외부 링크(`link` 태그) 대신에 내부 스타일(`style` 태그)로 인라인 처리해주는 실험적 기능이에요. 이걸 켜면, 보통 CSS 파일을 불러올 때 사용하는 `link` 태그 대신 `head` 태그 내에 직접 `style` 태그를 생성해서 CSS를 넣어줍니다.\n\n### 왜 이 기능을 쓸까?\n\n- **초기 렌더링 속도 개선**: 외부에서 CSS 파일을 불러오지 않고 바로 HTML 문서 안에 CSS가 들어가 있어서, 스타일 로딩에 걸리는 시간이 줄어들 수 있어요.\n- **더 나은 퍼포먼스**: 네트워크 요청 수가 줄어드니 실제 렌더링 속도가 더 빨라질 가능성이 큽니다.\n- **적용법도 간단**해요! next.config.js에 아래처럼 설정만 해주면 끝~\n\n```js\nimport type { NextConfig } from 'next'\n\nconst nextConfig: NextConfig = {\n  experimental: {\n    inlineCss: true,\n  },\n}\n\nexport default nextConfig\n```\n\n### 주의할 점!\n\n- 아직 **실험적인 기능**이라서, 프로젝트에 바로 적용하기 전에 꼼꼼히 테스트해보는 걸 추천해요.\n- 스타일 규모가 아주 크거나 CSS 파일이 많이 분할된 경우, HTML 문서 크기가 커질 수 있어서 오히려 성능에 악영향을 줄 수도 있어요.\n- 자바스크립트 번들 사이즈와 별개로, CSS가 HTML에 포함되므로 SEO 측면에서는 스타일이 빨리 적용되어 긍정적일 수 있습니다.\n\nNext.js에서 이런 기능들이 점점 늘어나면서, 우리는 더 편하게 최적화된 웹사이트를 만들 수 있죠! 혹시 CSS 인라인 처리에 관심 있으면 꼭 한 번 테스트해보세요. 도움이 필요하면 언제든 물어봐 주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 장단점 비교: 언제 인라인 CSS를 사용할까?\n\n인라인 CSS를 사용하면 좋은 경우가 몇 가지 있어요. 간단히 정리해볼게요!\n\n| 상황 | 설명 |\n|---|---|\n| **첫 방문자** | CSS 파일은 렌더링을 차단하는 리소스라서, 외부 CSS를 불러올 때 처음 방문자는 로딩 지연을 겪어요. 이때 CSS를 인라인으로 넣으면 처음부터 스타일이 바로 적용돼서 페이지 로드 속도가 확 좋아집니다. |\n| **성능 지표 개선** | 네트워크 요청 횟수를 줄이면 FCP(First Contentful Paint)나 LCP(Largest Contentful Paint)같은 중요한 웹 성능 지표가 대폭 상승하죠. 인라인 CSS가 이 부분에서 효과적입니다. |\n| **느린 네트워크 환경** | 와이파이가 약하거나 모바일 데이터 연결이 느릴 때, 네트워크 라운드 트립(왕복시간)이 꽤 크게 느껴져요. 인라인 CSS는 이런 환경에서 성능 향상이 두드러집니다. |\n| **아토믹 CSS 번들 (예: Tailwind CSS)** | Tailwind처럼 유틸리티 중심의 CSS 프레임워크는 페이지에 필요한 스타일 양이 디자인 복잡도와 크게 무관해요. 즉, 스타일의 전체 크기가 작고 일정하다는 말인데요, 그래서 인라인으로 넣으면 네트워크 요청도 줄이고 페이로드도 가볍게 유지할 수 있어요! |\n\n---\n\n### 추가로 알아두면 좋은 팁!\n\n- 인라인 CSS는 초반 로딩에 장점이 있지만, 너무 많은 스타일을 인라인으로 넣으면 HTML 파일 크기가 커져서 오히려 로드가 느려질 수 있어요. 적당한 선에서 재사용성이 낮거나 꼭 필요한 스타일만 넣는 게 좋아요.\n- 그리고 자주 바뀌는 스타일에는 별도의 CSS 파일을 사용하는 게 캐싱 측면에서 유리합니다. 인라인 스타일은 캐시가 어려워서 매번 새로 받아야 하거든요.\n- 결국 사용자 경험과 유지보수 편의성, 성능 지표 사이의 '적절한 균형'을 찾아야 하는 게 관건입니다.\n\n이런 점들 참고해서 프로젝트 상황에 맞게 인라인 CSS를 써보세요! 배운 만큼 웹 페이지가 확실히 빨라지고 사용자 만족도도 올라갈 거예요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 언제 인라인 CSS를 피해야 할까?\n\n인라인 CSS는 성능 향상에 꽤 도움이 되지만, 상황에 따라선 꼭 좋은 선택이 아닐 수 있어요. 어떤 경우인지 한번 살펴볼게요.\n\n| 상황 | 이유 및 설명 |\n|-------|-------------|\n| **큰 CSS 번들** | CSS 파일이 너무 크면, 인라인으로 모두 넣을 경우 HTML 파일 크기가 크게 늘어나요. 그러면 초기 응답 시간(Time to First Byte, TTFB)이 느려지고, 인터넷 속도가 느린 사용자에겐 오히려 성능 저하로 이어질 수 있어요. |\n| **동적 혹은 페이지별 CSS** | 페이지마다 스타일이 많이 달라지고, CSS가 동적으로 변하는 경우 인라인 CSS가 중복되고 과도하게 커질 수 있어요. 이렇게 되면 관리도 어렵고, 전반적인 로딩 효율도 떨어져요. |\n| **브라우저 캐싱 활용 시** | 다시 방문하는 사용자가 많을 땐 외부 CSS 파일이 유리해요. 브라우저가 파일을 캐시해서 재접속 때 파일을 다시 다운로드하지 않아도 되니까 데이터 절약도 되고 빠르죠. 인라인은 이 캐싱 이점을 포기하는 셈이에요. |\n\n---\n\n내 개인적인 팁을 하나 덧붙이면, 단순히 인라인 CSS냐 아니냐로만 고민하기보단, 중요한 부분(Critical CSS)만 인라인 하고 나머지는 외부 stylesheet로 분리하는 ‘하이브리드’ 전략을 쓰면 좋아요. 이렇게 하면 첫 화면 렌더링 속도를 잡으면서도 캐싱의 장점도 누릴 수 있거든요.\n\n여러분이 만드는 사이트나 앱의 특성에 맞게, 이런 장단점을 꼼꼼히 따져보시면서 유연하게 적용해 보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003e 참고할 점:\n이 기능은 현재 실험 단계이며 몇 가지 알려진 제한 사항이 있어요:\n- CSS 인라인 처리는 전역적으로 적용되며, 개별 페이지별 설정은 불가능해요.\n- 초기 페이지 로드 시 스타일이 두 번 중복돼요. 한 번은 SSR용 `style` 태그 안에, 또 한 번은 RSC 페이로드 안에 포함돼요.\n- 정적으로 렌더링된 페이지로 이동할 때는 중복을 피하기 위해 인라인 CSS 대신 `link` 태그를 사용해요.\n- 이 기능은 개발 모드에서는 사용할 수 없고, 프로덕션 빌드에서만 작동해요.\n\n---\n\n조금 더 풀어서 설명해볼게요. 이 기능은 웹사이트의 성능 최적화를 위해 CSS를 HTML 내부에 직접 넣는 방식(인라인 CSS)을 사용해요. 인라인 CSS는 초기 로딩 속도를 높여주고, 스타일이 빠르게 적용되는 장점이 있죠. 다만 아직 실험적인 기능이라서, 스타일 중복 문제나 상황에 따라 인라인 대신 외부 링크를 사용하는 식으로 처리하는 등 몇 가지 제한이 있어요.\n\n개발할 때는 이 기능을 동작시키기 힘드니, 실제 프로덕션 환경에서만 효과를 확인하는 게 좋아요. 앞으로 개선되면서 더 유연한 설정이 가능해지길 기대해봅니다.","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":5},{"title":"Node.js httpAgentOptions 완벽 가이드","description":"","date":"2025-04-22 13:12","slug":"2025-04-22-httpAgentOptions","content":"\n\n# httpAgentOptions 설정하기\n\n안녕하세요! 오늘은 Next.js에서 `httpAgentOptions` 옵션을 활용해 서버 사이드에서 `fetch()` 호출 시 HTTP Keep-Alive를 제어하는 방법에 대해 이야기해볼게요.\n\n## 왜 이 설정이 필요할까?\n\nNode.js 18 버전 이전에서는 Next.js가 내부적으로 `fetch()` 함수를 사용할 때 `undici` 라이브러리를 통해 자동으로 polyfill(대체)해주는데요, 이 과정에서 기본적으로 HTTP Keep-Alive 설정이 켜져 있습니다. Keep-Alive는 같은 서버로 여러 요청을 보낼 때 TCP 연결을 유지해서 성능을 높여주지만, 특정 상황에서는 연결을 계속 유지하는 게 오히려 문제가 될 수도 있어요.\n\n예를 들어, 짧게 끊는 요청이 많거나 프록시 서버를 사용 중이라면 Keep-Alive를 꺼서 연결이 오래 유지되는 걸 방지하는 게 유리할 수 있어요.\n\n## Next.js에서 HTTP Keep-Alive 끄는 방법\n\n`next.config.js` 파일에 간단히 다음과 같은 옵션을 추가하면, 서버 쪽에서 호출하는 모든 `fetch()`에 대해 Keep-Alive를 끌 수 있습니다:\n\n```js\nmodule.exports = {\n  httpAgentOptions: {\n    keepAlive: false,\n  },\n}\n```\n\n이걸 넣으면 Next.js가 내부에서 사용하는 HTTP 에이전트에 `keepAlive: false`가 적용돼서, 연결이 요청마다 끊기게 돼요.\n\n## 참고로 알아두면 좋은 점!\n\n- 이 설정은 서버사이드에서만 적용되는 점, 클라이언트 사이드 `fetch()`에는 영향을 미치지 않는 점 기억하세요.\n- Node.js 18 이상에서는 기본적으로 글로벌 `fetch`가 내장되어 있고, Next.js에서도 undici보다 내장 fetch를 사용할 수 있기 때문에 이 설정이 영향을 미치지 않을 수 있습니다.\n- 개발 환경이나 서버 환경에 따라 Keep-Alive 연결 유지 여부에 따라 성능이나 네트워크 자원 활용도가 달라지기 때문에, 꼭 상황에 맞게 설정해주시면 좋아요!\n\n이렇게 간단히 `httpAgentOptions`를 활용해서 서버 fetch의 동작을 제어할 수 있으니, 참고해보시고 꼭 필요한 경우에 맞춰 설정해보세요. 오늘도 좋은 개발 하세요! 🚀","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":2},{"title":"2025년 최신 이미지 최적화 기술과 활용법 총정리","description":"","date":"2025-04-22 13:12","slug":"2025-04-22-images","content":"\n\n# 이미지 최적화, Next.js 내장 API 대신 클라우드 연동하기\n\n안녕하세요! 오늘은 Next.js에서 기본 제공하는 이미지 최적화 API 대신, 클라우드 제공업체의 이미지를 활용하는 방법에 대해 알아볼게요. \n\nNext.js 자체적으로 이미지 최적화 기능이 굉장히 편리하지만, 경우에 따라 AWS, Cloudinary, Imgix 같은 클라우드 서비스를 사용해야 할 때도 있죠. 그럴 땐 `next.config.js`에 약간의 설정만 추가하면 쉽게 커스터마이징 할 수 있어요.\n\n```js\nmodule.exports = {\n  images: {\n    loader: 'custom',         // 커스텀 로더를 사용하겠다는 뜻이에요\n    loaderFile: './my/image/loader.js', // 이미지 URL을 변환하는 함수가 담긴 파일 경로\n  },\n}\n```\n\n위 설정에서 `loaderFile`은 Next.js 프로젝트 루트 기준 상대 경로로 지정해야 해요. 그리고 이 파일은 기본(default)으로 함수를 내보내야 하죠. 이 함수는 이미지 URL을 문자열로 반환하게 만들면 됩니다. \n\n예를 들면, 내 클라우드 이미지 서비스 URL을 붙이는 방식으로 직접 조절할 수 있게 만드는 거죠! \n\n### 예시: loader.js 파일\n\n```js\nexport default function loader({ src, width, quality }) {\n  return `https://your-cloud-service.com/${src}?w=${width}\u0026q=${quality || 75}`;\n}\n```\n\n- `src`: 최종적으로 최적화할 이미지 경로\n- `width`: 요청하는 이미지의 너비 (Next.js가 필요에 따라 조절)\n- `quality`: 이미지 품질 (옵션, 없으면 기본값 75 사용)\n\n이런 방식으로 자체 클라우드 이미지 URL 생성 로직을 자유롭게 구현할 수 있답니다.\n\n---\n\n### 추가 팁!\n\n- 클라우드를 활용하면, 이미지 변환뿐 아니라 CDN을 통한 빠른 로딩까지 누릴 수 있어요.\n- AWS S3 + CloudFront, Cloudinary, Imgix 등이 대표적입니다.\n- `next/image` 컴포넌트와의 호환성을 유지하면서도 유연하게 커스터마이징 가능해요.\n- `loaderFile`을 지정하지 않고 `loader: 'imgix'`나 `loader: 'cloudinary'` 같은 기본 제공 로더를 쓸 수도 있어요.\n\n이미지 최적화 전략을 고민 중이라면, 내 프로젝트에 가장 잘 맞는 방식을 찾아보고 적용하는 게 중요합니다. Next.js의 확장성 덕분에, 다양한 클라우드 서비스와 쉽게 연동할 수 있으니 걱정하지 마세요!\n\n필요하면 다음 번에 각 클라우드 제공업체별 최적화 설정법도 소개할게요. 편하게 댓글로 요청해주세요~\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안녕하세요 여러분! 오늘은 Next.js에서 이미지 최적화를 할 때 자주 사용되는 커스텀 이미지 로더 함수에 대해 이야기해볼게요.\n\n위 코드를 보면 `myImageLoader`라는 함수가 있어요. 요 함수는 다음과 같이 생겼죠:\n\n```js\n'use client'\n \nexport default function myImageLoader({ src, width, quality }) {\n  return `https://example.com/${src}?w=${width}\u0026q=${quality || 75}`\n}\n```\n\n### 이 함수가 하는 일?\n이 함수는 이미지 URL을 받아서 다음과 같이 변형해줘요.\n\n- `src`: 원본 이미지 경로\n- `width`: 요청하는 이미지 너비 (이미지 최적화를 위해)\n- `quality`: 이미지 품질. 만약 입력 안 하면 기본값 75로 설정됨\n\n즉, `https://example.com/이미지경로?w=이미지너비\u0026q=품질` 형태로 URL을 만들어서 커스텀 이미지 서버나 CDN에 최적화된 이미지를 요청하게 만드는 거예요.\n\n---\n\n### 어떻게 쓰나요?\n\n`next/image` 컴포넌트를 사용할 때 `loader` prop에 이 함수를 넘겨주면 돼요.\n\n```jsx\nimport Image from 'next/image'\nimport myImageLoader from './myImageLoader'\n\nexport default function MyComponent() {\n  return (\n    \u003cImage\n      loader={myImageLoader}\n      src=\"path/to/image.jpg\"\n      alt=\"My Image\"\n      width={800}\n      height={600}\n    /\u003e\n  )\n}\n```\n\n---\n\n### 여기서 알면 좋은 팁!\n\n- 이 loader 함수를 커스텀하고 싶으면 `use client` 지시어를 꼭 붙여서 클라이언트 컴포넌트로 만들어야 해요. 그래야 함수가 직렬화되어 클라이언트에서 잘 작동하거든요.\n- Next.js 내장 이미지 최적화 API가 어떻게 동작하는지도 잘 이해해두면 좋아요. 공식 문서에서 [Image Configuration Options](https://nextjs.org/docs/api-reference/next/image#configuration) 참고하시면 유용해요.\n\n---\n\n### 추가로 알아두면 좋은 점\n\n- 커스텀 로더를 사용하면, Next.js가 제공하는 기본 최적화 기능을 일부 포기하는 경우가 있어요. 그렇기 때문에 중간 CDN 혹은 별도 이미지 서버가 있을 때 최적화 문제를 직접 해결하고 싶을 때 사용하면 좋습니다.\n- 만약 여러 종류의 이미지를 각각 다른 서버에서 받는 경우, 로더 함수를 조금 더 복잡하게 만들어서 서버별 분기처리도 가능해요.\n\n그러니까 상황에 맞게 잘 활용하면 공식 next/image 기능을 더 유연하고 강력하게 쓸 수 있다는 뜻이죠!\n\n---\n\n요약한 표도 준비했어요.\n\n| 항목         | 설명                                                                                   |\n|--------------|----------------------------------------------------------------------------------------|\n| `src`        | 원본 이미지 경로                                                                        |\n| `width`      | 요청 이미지 너비, 최적화를 위해 사용                                                    |\n| `quality`    | 이미지 품질, 기본값은 75                                                                |\n| `loader` prop | next/image 컴포넌트에 커스텀 로더 함수를 전달하여 이미지 URL 생성 제어 가능              |\n| `use client` | 커스텀 로더가 클라이언트 컴포넌트가 되도록 지시어를 붙여야 함 (함수 직렬화 필요)        |\n\n---\n\n이런 커스텀 로더 활용법으로 Next.js 이미지를 나만의 방식으로 최적화해보세요! 다음에도 개발 꿀팁 가지고 올게요 :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 예제 로더 구성\n\n이미지 최적화 서비스를 만들 때, 각각의 CDN이나 이미지 서비스들이 요구하는 방식에 맞춰 URL을 만드는 게 중요해요. 여기서는 대표적인 서비스들의 로더 예시를 보여드릴게요.\n\n| 서비스명           | 설명                          |\n|-------------------|-----------------------------|\n| Akamai            | Akamai CDN 이미지 로더       |\n| AWS CloudFront    | AWS의 CDN 서비스             |\n| Cloudinary        | 이미지와 비디오 관리 플랫폼  |\n| Cloudflare        | 웹 최적화 및 CDN 서비스      |\n| Contentful        | 컨텐츠 관리 시스템           |\n| Fastly            | 고성능 CDN                   |\n| Gumlet            | 이미지 최적화 및 변환 서비스 |\n| ImageEngine       | 이미지 최적화 솔루션          |\n| Imgix             | 실시간 이미지 처리 서비스     |\n| PixelBin          | 이미지 최적화 플랫폼          |\n| Sanity            | 구조화된 컨텐츠 관리 시스템   |\n| Sirv              | 이미지 호스팅과 CDN           |\n| Supabase          | 오픈 소스 백엔드 플랫폼       |\n| Thumbor           | 오픈 소스 이미지 처리 서버    |\n| Imagekit          | 실시간 이미지 최적화 서비스   |\n| Nitrogen AIO      | AI 기반 이미지 최적화 도구    |\n\n---\n\n### Akamai 예시 코드\n\n```js\n// 공식 문서: https://techdocs.akamai.com/ivm/reference/test-images-on-demand\nexport default function akamaiLoader({ src, width, quality }) {\n  return `https://example.com/${src}?imwidth=${width}`\n}\n```\n\nAkamai는 URL에 `imwidth` 파라미터로 원하는 이미지 너비를 지정하는 식으로 이미지를 요청할 수 있어요. 이처럼 각 서비스마다 URL 포맷이 다르니, 서비스를 사용할 때는 꼭 공식 문서를 확인해 주세요!\n\n---\n\n### 조금 더 유용한 팁!\n\n- `quality` 파라미터를 지원하는 경우, 이미지 품질 조절도 가능한데요. 품질을 조절하면 파일 크기를 줄이면서도 적당한 화면 퀄리티를 유지할 수 있어요.\n- width, height를 명확히 지정하면 브라우저가 레이아웃을 미리 잡는데 도움이 돼서 LCP(최대 콘텐츠 표시 시간) 개선에 유리합니다.\n- 이미지를 다루는 서비스마다 URL 규칙이 다르기 때문에, 공통 인터페이스로 로더 함수를 만들어두면 코드 관리가 편해집니다.\n\n이미지 최적화는 웹 성능에 엄청 큰 영향을 미치니까, 여러분만의 로더를 만들어서 꼭 활용해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### AWS CloudFront 이미지 최적화 로더\n\nAWS CloudFront는 CDN 서비스로 유명하지만, 이미지 최적화 기능도 정말 강력해요. 위 코드 예제는 CloudFront의 이미지 최적화 API와 연동하는 간단한 로더 함수입니다.\n\n```js\nexport default function cloudfrontLoader({ src, width, quality }) {\n  const url = new URL(`https://example.com${src}`)\n  url.searchParams.set('format', 'auto') // 이미지 포맷을 자동으로 변환 (WebP, AVIF 등 지원)\n  url.searchParams.set('width', width.toString()) // 원하는 이미지 너비 지정\n  url.searchParams.set('quality', (quality || 75).toString()) // 퀄리티 조절 (기본 75)\n  return url.href\n}\n```\n\n- **format=auto**: 브라우저가 지원하는 최적의 이미지 포맷(WebP, AVIF 등)을 자동으로 선택해줍니다. 이걸 사용하면 무조건 파일 사이즈가 줄어들어 빠른 로딩이 가능해지죠.\n- **width**와 **quality** 설정으로 원하는 사이즈와 품질을 자유롭게 조절할 수 있어요.\n\n**팁!** AWS는 CloudFront 외에도 [AWS Image Handler](https://aws.amazon.com/solutions/implementations/image-handler/) 솔루션을 제공합니다. 요구사항에 따라 서버리스 방식으로 이미지 리사이징, 최적화를 구현할 수도 있어요.\n\n---\n\n### Cloudinary 이미지 최적화 로더\n\nCloudinary는 이미지 및 비디오 관리에서 거의 표준처럼 쓰이는 서비스인데요, 여기서도 자동 변환과 최적화 기능을 활용할 수 있습니다.\n\n```js\nexport default function cloudinaryLoader({ src, width, quality }) {\n  const params = ['f_auto', 'c_limit', `w_${width}`, `q_${quality || 'auto'}`]\n  return `https://example.com/${params.join(',')}${src}`\n}\n```\n\n- **f_auto**: 자동 이미지 포맷 변환\n- **c_limit**: 컨텐츠 제한 모드로 이미지가 지정한 width보다 크면 축소\n- **w_300**: 이미지 너비 300픽셀 설정 예시\n- **q_auto**: 이미지 퀄리티를 자동으로 최적화\n\nCloudinary는 다양한 트랜스포메이션 옵션을 제공하니, 공식 문서나 데모 페이지([링크](https://res.cloudinary.com/demo/image/upload/w_300,c_limit,q_auto/turtles.jpg))를 참고해서 꼭 활용해보세요!\n\n---\n\n### 한 줄 요약\n\n| 서비스       | 이미지 최적화 키워드                  | 특징 및 참고사항                                   |\n|--------------|-----------------------------------|--------------------------------------------------|\n| AWS CloudFront | `format=auto`, `width`, `quality` | AWS 인프라 연동, 서버리스 이미지 최적화 가능        |\n| Cloudinary     | `f_auto`, `c_limit`, `w_`, `q_`    | 다양한 이미지 변환/최적화 기능 제공, 쉽게 적용 가능 |\n\n---\n\n저도 예전에 이미지 최적화 때문에 엄청 고민했는데, 이런 CDN 서비스의 자동 최적화 기능을 이용하니 정말 편하더라고요. 직접 써보면서 서비스마다 조금씩 다른 파라미터와 특성을 비교해 보는 것도 좋은 공부가 될 거예요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### Cloudflare 이미지 로더 함수\n\n```js\n// Docs: https://developers.cloudflare.com/images/transform-images\nexport default function cloudflareLoader({ src, width, quality }) {\n  const params = [`width=${width}`, `quality=${quality || 75}`, 'format=auto']\n  return `https://example.com/cdn-cgi/image/${params.join(',')}/${src}`\n}\n```\n\n여기서는 Cloudflare의 이미지 변환 API를 이용해서 이미지를 자동 포맷(webp, avif 등)으로 변경하고, 지정한 너비(width)와 품질(quality)를 적용해주고 있어요. quality는 지정하지 않으면 기본값 75로 처리하니 참고하세요.\n\n포인트는 URL에 쿼리스트링 대신 path 부분에 파라미터를 쉼표로 구분해서 넣는다는 거예요. Cloudflare 방식만 좀 특별하니 헷갈리지 말기!\n\n---\n\n### Contentful 이미지 로더 함수\n\n```js\n// Docs: https://www.contentful.com/developers/docs/references/images-api/\nexport default function contentfulLoader({ src, width, quality }) {\n  const url = new URL(`https://example.com${src}`)\n  url.searchParams.set('fm', 'webp')\n  url.searchParams.set('w', width.toString())\n  url.searchParams.set('q', (quality || 75).toString())\n  return url.href\n}\n```\n\nContentful 이미지 API를 쓸 때는 URLSearchParams를 이용해서 쿼리스트링을 붙여줘요. 여기서 `fm=webp`는 이미지 포맷을 webp로 강제 변환하는 옵션이고, `w`는 너비, `q`는 품질이에요.\n\nContentful은 URL에 쿼리파라미터를 붙이는 형식이라 Cloudflare와 달리 경로가 복잡하지 않아서 편리해요.\n\n---\n\n### 추가 팁\n\n- 이미지 최적화할 때는 가능한 한 `format=auto`나 `fm=webp` 같은 포맷 자동 변환 기능을 꼭 쓰는 게 좋아요. 요즘 브라우저 대부분이 webp, avif 등 고효율 포맷을 지원해서 페이지 로딩 속도가 훨씬 빨라진답니다.\n- 이미지 너비(width)를 꼭 지정해서 너무 큰 원본 이미지를 불필요하게 불러오지 않도록 하세요.\n- 품질(quality)을 75 정도로 설정하면 품질과 파일 크기의 균형이 잘 맞는 편이에요. 필요하다면 조절해보세요.\n\n이렇게 내가 쓰는 CDN이나 이미지 제공 서비스에 맞게 최적화 로더 함수를 만들어서 쓰면 Next.js 같은 프레임워크에서 자동으로 최적화된 이미지를 잘 뽑아줄 수 있어요. 한번 직접 만들어서 써보면 생각보다 간단하고 효과가 확실하니 도전해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### Fastly와 Gumlet 이미지 로더 비교\n\n이미지 최적화와 관련해서 Fastly와 Gumlet 두 가지 서비스를 많이 사용하죠. 여기서 각각의 간단한 커스텀 이미지 로더 함수 예제를 소개할게요. 이 함수들은 주로 Next.js 같은 프레임워크에서 이미지 URL을 동적으로 생성할 때 유용하게 쓰입니다.\n\n```js\n// Fastly 로더 예제\nexport default function fastlyLoader({ src, width, quality }) {\n  const url = new URL(`https://example.com${src}`)\n  url.searchParams.set('auto', 'webp') // 자동으로 WebP 포맷 변환\n  url.searchParams.set('width', width.toString()) // 이미지 너비 설정\n  url.searchParams.set('quality', (quality || 75).toString()) // 이미지 품질 설정 (기본 75)\n  return url.href\n}\n```\n\n```js\n// Gumlet 로더 예제\nexport default function gumletLoader({ src, width, quality }) {\n  const url = new URL(`https://example.com${src}`)\n  url.searchParams.set('format', 'auto') // 자동 포맷 변환\n  url.searchParams.set('w', width.toString()) // 이미지 너비 설정\n  url.searchParams.set('q', (quality || 75).toString()) // 이미지 품질 설정 (기본 75)\n  return url.href\n}\n```\n\n| 항목         | Fastly                              | Gumlet                              |\n|--------------|-----------------------------------|-----------------------------------|\n| 포맷 자동변환 | `auto=webp`                       | `format=auto`                     |\n| 이미지 너비   | `width`                           | `w`                               |\n| 품질 설정    | `quality` (기본값 75)             | `q` (기본값 75)                   |\n| 공식 문서    | [Fastly IO Docs](https://developer.fastly.com/reference/io/) | [Gumlet Docs](https://docs.gumlet.com/reference/image-transform-size) |\n\n---\n\n### 빠르게 정리하는 팁!\n\n- 두 서비스 모두 이미지 포맷을 자동변환해서 WebP 같은 최신 포맷으로 최적화할 수 있어요.\n- 파라미터 명칭이 조금 다르니 사용할 때 코드를 잘 확인해야 합니다.\n- `quality` 기본값을 75로 맞추는 건 적당한 품질 유지와 용량 절약 균형을 위해 많이 쓰입니다.\n- URL 생성시 `new URL`을 쓰면 쿼리 파라미터 세팅이 편해서 추천해요.\n\n이렇게 커스텀 로더를 쓰면 내 서비스에 맞춰 최적의 이미지 URL을 자동으로 만들어주니까 퍼포먼스에 큰 도움이 됩니다. 나중에 더 심화된 옵션들도 활용해보면 좋아요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### ImageEngine\n\n```js\n// 공식 문서: https://support.imageengine.io/hc/en-us/articles/360058880672-Directives\nexport default function imageengineLoader({ src, width, quality }) {\n  const compression = 100 - (quality || 50)  // quality가 없으면 기본 50으로 지정 후 압축률 계산\n  const params = [`w_${width}`, `cmpr_${compression}`]\n  return `https://example.com${src}?imgeng=/${params.join('/')}`\n}\n```\n\nImageEngine은 이미지의 크기 조절과 압축률을 URL 파라미터로 조절해서 최적화해주는 서비스입니다. 위 코드에서는 너비(width)와 품질(quality)를 받아서 적절한 압축 비율로 변환하고, 이 매개변수를 URL에 붙여서 반환해줍니다.\n\n- `w_{width}` : 이미지 너비 지정\n- `cmpr_{value}` : 압축률 지정 (100에서 quality 값을 뺀 값)\n\n\u003e 참고로, quality 값을 0~100까지 넘겨주면 압축률을 구할 수 있어서 좀 더 세밀하게 이미지 품질과 용량을 조절할 수 있답니다.\n\n---\n\n### Imgix\n\n```js\n// 예제 이미지: https://static.imgix.net/daisy.png?format=auto\u0026fit=max\u0026w=300\nexport default function imgixLoader({ src, width, quality }) {\n  const url = new URL(`https://example.com${src}`)\n  const params = url.searchParams\n  params.set('auto', params.getAll('auto').join(',') || 'format')  // 자동 포맷 설정\n  params.set('fit', params.get('fit') || 'max')                    // 이미지 fitting 방식 지정\n  params.set('w', params.get('w') || width.toString())             // 너비 지정\n  params.set('q', (quality || 50).toString())                      // 품질 지정\n  return url.href\n}\n```\n\nImgix는 매우 인기있는 이미지 최적화 및 제공 서비스입니다. 위 예시 코드는 URL 객체를 활용해 기존 쿼리 파라미터를 유지하면서 자동 포맷, 맞춤 크기, 품질을 지정해서 반환하고 있어요.\n\n- `auto=format` : 브라우저에 최적화된 형식으로 자동 변환 (webp, jpeg 등)\n- `fit=max` : 이미지 fitting 방법으로 최대 크기까지 맞춤 (crop이나 clip도 가능해요)\n- `w` : 너비(width) 지정\n- `q` : 품질(quality) 지정 (기본값 50)\n\n\u003e URL 객체를 쓰는 이유? 쿼리 파라미터를 쉽게 조작하면서 중복 제거하고 올바른 URL을 만들기 위해서에요.\n\n### 한 번에 비교해보는 주요 파라미터\n\n| 서비스    | 주요 파라미터        | 설명                                   |\n|-----------|---------------------|--------------------------------------|\n| ImageEngine | `w_{width}`         | 이미지 너비 지정                      |\n|           | `cmpr_{compression}` | 압축률 지정 (100 - quality)           |\n| Imgix     | `w`                  | 이미지 너비 지정                      |\n|           | `q`                  | 품질(quality) 지정                    |\n|           | `auto=format`        | 자동 포맷 변환                        |\n|           | `fit`                | 이미지 fitting 방식                   |\n\n---\n\n### 참고 팁\n- 이미지 최적화할 때는 무조건 품질을 최고로 올리는 것보다, 용량과 품질의 적절한 균형점을 찾는 게 중요해요.\n- 'quality' 값을 너무 낮게 하면 이미지가 뭉개지고, 너무 높이면 로딩 속도가 느려지니까요. 보통 50~70 사이 조절이 많이 쓰입니다.\n- 또한, `auto=format` 같은 기능을 지원하는 서비스는 유용해요. 브라우저에 맞는 최적 포맷으로 변환해주거든요.\n\n기본적인 사용법과 개념부터 잡고, 필요에 따라 각 서비스 공식 문서를 참고해서 더 세밀하게 조정해보길 추천드립니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### PixelBin 이미지 로더 함수\n\n```js\n// Doc (Resize): https://www.pixelbin.io/docs/transformations/basic/resize/#width-w\n// Doc (Optimise): https://www.pixelbin.io/docs/optimizations/quality/#image-quality-when-delivering\n// Doc (Auto Format Delivery): https://www.pixelbin.io/docs/optimizations/format/#automatic-format-selection-with-f_auto-url-parameter\nexport default function pixelBinLoader({ src, width, quality }) {\n  const name = '\u003cyour-cloud-name\u003e'\n  const opt = `t.resize(w:${width})~t.compress(q:${quality || 75})`\n  return `https://cdn.pixelbin.io/v2/${name}/${opt}/${src}?f_auto=true`\n}\n```\n\nPixelBin은 이미지 크기 조절, 압축, 포맷 자동 변환 등을 손쉽게 적용할 수 있게 해주는 이미지 CDN 서비스예요. 위 코드에서 `width`와 `quality`를 받아서 이미지를 최적화된 형태로 반환합니다.\n\n- `t.resize(w:${width})`: 원하는 가로 폭으로 이미지 크기를 조절\n- `t.compress(q:${quality || 75})`: 이미지 품질을 0~100으로 지정하며 기본값은 75\n- `?f_auto=true`: 브라우저에 맞춰 최적의 이미지 포맷(WebP, AVIF 등)을 자동 선택해줍니다.\n\n직접 클라우드 이름(`\u003cyour-cloud-name\u003e`)을 넣어서 사용하세요. PixelBin 덕분에 이미지 최적화가 훨씬 간편해져서 페이지 속도 개선에 아주 좋아요!\n\n---\n\n### Sanity 이미지 로더 함수\n\n```js\n// Docs: https://www.sanity.io/docs/image-urls\nexport default function sanityLoader({ src, width, quality }) {\n  const prj = 'zp7mbokg'\n  const dataset = 'production'\n  const url = new URL(`https://cdn.sanity.io/images/${prj}/${dataset}${src}`)\n  url.searchParams.set('auto', 'format')\n  url.searchParams.set('fit', 'max')\n  url.searchParams.set('w', width.toString())\n  if (quality) {\n    url.searchParams.set('q', quality.toString())\n  }\n  return url.href\n}\n```\n\nSanity는 헤드리스 CMS답게 이미지를 효과적으로 다룰 수 있는 내장 이미지 CDN을 제공합니다. 위 코드는 프로젝트 ID와 데이터셋만 맞춰주면 원하는 크기와 품질로 이미지를 요청할 수 있어요.\n\n- `auto=format`: 자동으로 최적의 이미지 포맷을 선택\n- `fit=max`: 지정한 크기 내에서 이미지 크기를 최대한 맞춤\n- `w`: 가로 폭 지정\n- `q`: 이미지 품질 지정 (optional)\n\nSanity를 쓰면서 매번 직접 URL 다루기 귀찮다면 이렇게 로더 함수로 한 번 만들어 두면 훨씬 편하겠죠?\n\n---\n\n### 추가 팁!\n\n요즘은 다양한 디바이스가 많으니까 이미지 사이즈와 포맷 최적화는 필수가 됐어요. 위 두 예시 모두 **자동 포맷 변환**을 지원하는데, 이런 기능을 활용하면 꼭 WebP, AVIF 같은 최신 포맷을 개별 지원하지 않아도 되니 개발이 한결 수월해진답니다.\n\n또한, `quality` 값을 너무 높게 잡으면 페이지 로딩 속도가 늦어지고, 너무 낮게 하면 화질이 떨어질 수 있으니 적절한 타협이 중요해요. 보통 70~80 정도가 밸런스가 잘 맞는 편입니다. 실제 서비스에 적용 전에는 꼭 여러 디바이스에서 테스트해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### Sirv 이미지 로더\n\nSirv는 이미지 최적화와 다이나믹 이미징을 지원하는 서비스에요. 위 코드를 보면, 이미지 URL에 필요한 파라미터를 추가해서 최적화된 이미지를 불러올 수 있게 만들어두었죠.\n\n- `format` 파라미터는 이미지 형식을 지정하는데, 기본값은 `'optimal'`로 설정해서 브라우저에 맞는 포맷을 자동으로 선택합니다.\n- `w`는 이미지의 너비를 의미하고, 값을 넣어주지 않았다면 `width` 매개변수에서 받아 활용해요.\n- `q`는 이미지 품질(quality) 숫자로, 기본값 85를 사용하지만 필요에 따라 조절 가능해요.\n\n```js\nexport default function sirvLoader({ src, width, quality }) {\n  const url = new URL(`https://example.com${src}`)\n  const params = url.searchParams\n  params.set('format', params.getAll('format').join(',') || 'optimal')\n  params.set('w', params.get('w') || width.toString())\n  params.set('q', (quality || 85).toString())\n  return url.href\n}\n```\n\n### Supabase 이미지 로더\n\nSupabase의 스토리지를 이용해 이미지 변환 기능을 쓸 때는 URL 파라미터로 `width`와 `quality`을 넣으면 돼요.\n\n- `width` 파라미터로 원하는 이미지 너비를 지정하고,\n- `quality`를 통해 이미지 압축 정도를 조절할 수 있어요. 기본 75로 설정되어 있습니다.\n\n```js\nexport default function supabaseLoader({ src, width, quality }) {\n  const url = new URL(`https://example.com${src}`)\n  url.searchParams.set('width', width.toString())\n  url.searchParams.set('quality', (quality || 75).toString())\n  return url.href\n}\n```\n\n---\n\n### 추가 팁  — Next.js와 함께 쓸 때\n\n이 두 로더는 Next.js의 `next/image` 컴포넌트에서 `loader` 옵션으로 지정해서 쓸 수 있어요. 이렇게 하면 이미지 최적화가 훨씬 간편해지죠.\n\n```js\nimport Image from 'next/image'\nimport sirvLoader from './sirvLoader'\n\nexport default function MyComponent() {\n  return (\n    \u003cImage\n      loader={sirvLoader}\n      src=\"/my-image.png\"\n      width={800}\n      height={600}\n      alt=\"Example image\"\n    /\u003e\n  )\n}\n```\n\nSupabase도 마찬가지구요.\n\n만약 여러분이 이미지 최적화나 변환 기능을 직접 구현하거나 타 서비스와 연동할 계획이라면, 이런 커스텀 로더 패턴을 잘 기억해 두는 게 좋아요. 서비스마다 요구하는 쿼리 파라미터가 다르니 꼭 공식 문서를 참고하세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### Thumbor와 ImageKit.io 이미지 로더 함수 비교\n\n안녕하세요! 오늘은 이미지 최적화 서비스인 Thumbor와 ImageKit.io를 사용할 때 자주 쓰이는 이미지 URL 생성 함수 예제를 소개할게요. 여러분이 Next.js 같은 프레임워크에서 커스텀 이미지 로더를 만들 때 참고하면 좋아요.\n\n---\n\n#### Thumbor\n\n```js\n// 공식 문서: https://thumbor.readthedocs.io/en/latest/\nexport default function thumborLoader({ src, width, quality }) {\n  const params = [`${width}x0`, `filters:quality(${quality || 75})`]\n  return `https://example.com${params.join('/')}${src}`\n}\n```\n\n- 사용법: \n  - `width`만 지정하고 높이(height)는 0으로 고정해서 비율을 유지합니다.\n  - `quality`는 필터로 적용하며 기본값은 75입니다.\n- Thumbor는 URL 구조가 `/widthxheight/filters:.../image_path` 형식이에요.\n- 실제 사용할 때 `https://example.com` 대신 본인 서버 주소로 바꾸시면 됩니다.\n\n---\n\n#### ImageKit.io\n\n```js\n// 공식 문서: https://imagekit.io/docs/image-transformation\nexport default function imageKitLoader({ src, width, quality }) {\n  const params = [`w-${width}`, `q-${quality || 80}`]\n  return `https://ik.imagekit.io/your_imagekit_id/${src}?tr=${params.join(',')}`\n}\n```\n\n- 사용법:\n  - URL 쿼리 스트링 `?tr=` 뒤에 변환 옵션을 쉼표로 구분해서 넣는 방식이에요.\n  - `w-`는 너비 지정, `q-`는 품질 설정이며 기본값은 80입니다.\n- `your_imagekit_id`를 본인 계정에 맞게 바꿔 주세요.\n\n---\n\n### 비교 및 팁\n\n| 특징            | Thumbor                                | ImageKit.io                         |\n|-----------------|--------------------------------------|-----------------------------------|\n| URL 형식        | `/widthxheight/filters:value/image`  | `?tr=options` 쿼리 스트링           |\n| 품질 기본값      | 75                                   | 80                                |\n| 비율 유지 방식   | 높이 0으로 설정해서 자동 맞춤         | 너비만 지정, 자동 비율 유지           |\n| 공식 문서 링크    | [Thumbor Docs](https://thumbor.readthedocs.io/en/latest/) | [ImageKit Docs](https://imagekit.io/docs/image-transformation) |\n\n---\n\n### 한마디\n\n이미지 최적화는 페이지 로딩 속도에 직접적인 영향을 미치기 때문에 꼭 신경 써야 하는 부분이에요. Thumbor와 ImageKit.io 모두 강력한 기능을 제공하니 프로젝트 상황에 맞게 선택하세요. 특히 ImageKit은 CDN 연동이 원활하고, Thumbor는 직접 서버에서 동작하므로 관리 편의성이 달라요.\n\n궁금한 점 있으면 댓글로 물어봐 주세요! 다음에도 더 유용한 개발 정보로 찾아올게요~\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### Nitrogen AIO\n\n안녕하세요! 오늘은 Nitrogen AIO의 `aioLoader` 함수를 한번 같이 살펴볼게요. 이 코드는 이미지 URL을 받아서, 파라미터를 조작해 최적화된 이미지 URL을 자동으로 만들어주는 역할을 합니다.\n\n```js\n// Docs: https://docs.n7.io/aio/intergrations/\nexport default function aioLoader({ src, width, quality }) {\n  const url = new URL(src, window.location.href) // 주어진 src를 기반으로 URL 객체 생성\n  const params = url.searchParams             // URL의 쿼리 파라미터 접근\n  const aioParams = params.getAll('aio')      // 'aio' 키에 해당하는 모든 값 가져오기\n  aioParams.push(`w-${width}`)                 // 너비 정보 추가 (예: w-800)\n  if (quality) {\n    aioParams.push(`q-${quality.toString()}`) // 품질 정보 추가 (예: q-75)\n  }\n  params.set('aio', aioParams.join(';'))       // 'aio' 파라미터를 새롭게 세팅. 여러 값은 ';'로 구분\n  return url.href                              // 최종 변환된 URL 반환\n}\n```\n\n---\n\n### 코드 설명\n\n- `new URL(src, window.location.href)`: 상대경로나 절대경로로 전달된 `src`를 URL 객체로 변환합니다. 이렇게 하면 쉽게 쿼리 파라미터를 조작할 수 있죠.\n- `params.getAll('aio')`: 하나의 쿼리 파라미터 키에 여러 값이 있을 때, 모두 배열로 가져올 수 있습니다. 예를 들어 `?aio=foo\u0026aio=bar`면 `['foo','bar']`가 나오죠.\n- `aioParams.push(...)`: 이미지의 너비와 품질 정보를 `'aio'` 파라미터 값 안에 추가해줍니다. 이렇게 하여 이미지 최적화 옵션을 전달하죠.\n- 마지막으로 `params.set('aio', aioParams.join(';'))`: 여러 옵션을 세미콜론(;)으로 연결하여 하나의 `'aio'` 쿼리 파라미터로 변환합니다.\n\n---\n\n### 추가 팁 🧐\n\n- **왜 'aio' 파라미터를 여러 개 합쳐서 넣을까?**\n\n  여러 옵션을 하나의 키(`aio`) 밑에 세미콜론으로 이어붙이면 URL이 깔끔해지고 쿼리 파라미터 키가 너무 많아지는 걸 방지할 수 있어요.\n\n- **quality 값이 없으면 어떻게 될까요?**\n\n  만약 `quality`가 주어지지 않으면 기본 품질 설정을 유지하거나 서버 쪽에서 기본값이 사용됩니다.\n\n- **더 다양한 옵션 추가하기**\n\n  필요하다면 `aioParams.push(...)` 부분을 확장해서 다른 이미지 최적화 옵션(예: 포맷 변환, 크롭 등)도 추가할 수 있어요.\n\n---\n\n이렇게 간단한 함수 하나로 이미지 URL을 동적으로 최적화할 수 있다는 게 Nitrogen AIO의 매력 중 하나랍니다! 만약 실제 프로젝트에 적용한다면, 이미지 로드시 항상 원하는 크기와 품질로 이미지를 불러오게 되어 사용자 경험이 한층 좋아질 거예요.\n\n더 궁금한 점 있으면 언제든 물어보세요! 😊","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":24}],"page":"4","totalPageCount":50,"totalPageGroupCount":3,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"4"},"buildId":"olPs1cVezSGTqD7OaewDI","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>