<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>TIL</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//posts/4" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="TIL" data-gatsby-head="true"/><meta property="og:title" content="TIL" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//posts/4" data-gatsby-head="true"/><meta name="twitter:title" content="TIL" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/7978fe7362f7d4c9.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/7978fe7362f7d4c9.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/TIL/_next/static/chunks/463-925361deb4cec4b1.js" defer=""></script><script src="/TIL/_next/static/chunks/873-2eda6d845ad1e69e.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/posts/%5Bpage%5D-350e448526ad5efa.js" defer=""></script><script src="/TIL/_next/static/OY-qm1-_Mz9jLZ5863EbF/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/OY-qm1-_Mz9jLZ5863EbF/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="당신의 Python 코드를 쉽게 개선할 수 있는 7가지 방법" href="/TIL/post/2024-07-09-7SimpleWaysToDrasticallyImproveYourPythonCode"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="당신의 Python 코드를 쉽게 개선할 수 있는 7가지 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-09-7SimpleWaysToDrasticallyImproveYourPythonCode_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="당신의 Python 코드를 쉽게 개선할 수 있는 7가지 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">당신의 Python 코드를 쉽게 개선할 수 있는 7가지 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 9, 2024</span><span class="PostList_reading_time__6CBMQ">15<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Kafka, Redis, Postgres, Kubernetes를 활용한 실시간 파이프라인 마이크로서비스 프로젝트 방법" href="/TIL/post/2024-07-09-Real-TimePipelineMicroservicesProjectwithKafkaRedisPostgresandKubernetes"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Kafka, Redis, Postgres, Kubernetes를 활용한 실시간 파이프라인 마이크로서비스 프로젝트 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-09-Real-TimePipelineMicroservicesProjectwithKafkaRedisPostgresandKubernetes_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Kafka, Redis, Postgres, Kubernetes를 활용한 실시간 파이프라인 마이크로서비스 프로젝트 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Kafka, Redis, Postgres, Kubernetes를 활용한 실시간 파이프라인 마이크로서비스 프로젝트 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 9, 2024</span><span class="PostList_reading_time__6CBMQ">34<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="시계열 확률 예측을 위한 분위 회귀 방법 " href="/TIL/post/2024-07-09-QuantileRegressionforTimeSeriesProbabilisticForecasting"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="시계열 확률 예측을 위한 분위 회귀 방법 " loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-09-QuantileRegressionforTimeSeriesProbabilisticForecasting_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="시계열 확률 예측을 위한 분위 회귀 방법 " loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">시계열 확률 예측을 위한 분위 회귀 방법 </strong><div class="PostList_meta__VCFLX"><span class="date">Jul 9, 2024</span><span class="PostList_reading_time__6CBMQ">14<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="파이썬과 트랜스포머로 생성형 AI 챗봇 만들기 방법" href="/TIL/post/2024-07-09-CreatingaGenerativeAIChatbotwithPythonandTransformers"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="파이썬과 트랜스포머로 생성형 AI 챗봇 만들기 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-09-CreatingaGenerativeAIChatbotwithPythonandTransformers_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="파이썬과 트랜스포머로 생성형 AI 챗봇 만들기 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">파이썬과 트랜스포머로 생성형 AI 챗봇 만들기 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 9, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="진정한 인공지능의 벽에 부딪힌 AGI의 발전 현황" href="/TIL/post/2024-07-09-ProgresstowardstrueArtificialGeneralIntelligenceAGIhashitawall"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="진정한 인공지능의 벽에 부딪힌 AGI의 발전 현황" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-09-ProgresstowardstrueArtificialGeneralIntelligenceAGIhashitawall_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="진정한 인공지능의 벽에 부딪힌 AGI의 발전 현황" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">진정한 인공지능의 벽에 부딪힌 AGI의 발전 현황</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 9, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="여러 기간의 시계열 확률 예측을 위한 XGB, LightGBM, CatBoost 모델 비교 분석" href="/TIL/post/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="여러 기간의 시계열 확률 예측을 위한 XGB, LightGBM, CatBoost 모델 비교 분석" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="여러 기간의 시계열 확률 예측을 위한 XGB, LightGBM, CatBoost 모델 비교 분석" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">여러 기간의 시계열 확률 예측을 위한 XGB, LightGBM, CatBoost 모델 비교 분석</strong><div class="PostList_meta__VCFLX"><span class="date">2 hours ago</span><span class="PostList_reading_time__6CBMQ">26<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="알아두었으면 좋았을 Python 리스트 방법 12가지" href="/TIL/post/2024-07-09-12PythonListThingsIRegretNotKnowingEarlier"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="알아두었으면 좋았을 Python 리스트 방법 12가지" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-09-12PythonListThingsIRegretNotKnowingEarlier_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="알아두었으면 좋았을 Python 리스트 방법 12가지" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">알아두었으면 좋았을 Python 리스트 방법 12가지</strong><div class="PostList_meta__VCFLX"><span class="date">2 hours ago</span><span class="PostList_reading_time__6CBMQ">15<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="다중 기간 확률 예측을 위한 선형 모델 이해하기" href="/TIL/post/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="다중 기간 확률 예측을 위한 선형 모델 이해하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="다중 기간 확률 예측을 위한 선형 모델 이해하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">다중 기간 확률 예측을 위한 선형 모델 이해하기</strong><div class="PostList_meta__VCFLX"><span class="date">2 hours ago</span><span class="PostList_reading_time__6CBMQ">21<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="파이썬 고급 문자열 조작 기법들" href="/TIL/post/2024-07-09-AdvancedStringManipulationsinPython"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="파이썬 고급 문자열 조작 기법들" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-09-AdvancedStringManipulationsinPython_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="파이썬 고급 문자열 조작 기법들" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">파이썬 고급 문자열 조작 기법들</strong><div class="PostList_meta__VCFLX"><span class="date">2 hours ago</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Python 리스트 내포 List Comprehension 문법의 진정한 강점 단순한 문법 설탕이 아님" href="/TIL/post/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Python 리스트 내포 List Comprehension 문법의 진정한 강점 단순한 문법 설탕이 아님" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Python 리스트 내포 List Comprehension 문법의 진정한 강점 단순한 문법 설탕이 아님" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Python 리스트 내포 List Comprehension 문법의 진정한 강점 단순한 문법 설탕이 아님</strong><div class="PostList_meta__VCFLX"><span class="date">2 hours ago</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/TIL/posts/1">1</a><a class="link" href="/TIL/posts/2">2</a><a class="link" href="/TIL/posts/3">3</a><a class="link posts_-active__YVJEi" href="/TIL/posts/4">4</a><a class="link" href="/TIL/posts/5">5</a><a class="link" href="/TIL/posts/6">6</a><a class="link" href="/TIL/posts/7">7</a><a class="link" href="/TIL/posts/8">8</a><a class="link" href="/TIL/posts/9">9</a><a class="link" href="/TIL/posts/10">10</a><a class="link" href="/TIL/posts/11">11</a><a class="link" href="/TIL/posts/12">12</a><a class="link" href="/TIL/posts/13">13</a><a class="link" href="/TIL/posts/14">14</a><a class="link" href="/TIL/posts/15">15</a><a class="link" href="/TIL/posts/16">16</a><a class="link" href="/TIL/posts/17">17</a><a class="link" href="/TIL/posts/18">18</a><a class="link" href="/TIL/posts/19">19</a></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"당신의 Python 코드를 쉽게 개선할 수 있는 7가지 방법","description":"","date":"2024-07-09 19:45","slug":"2024-07-09-7SimpleWaysToDrasticallyImproveYourPythonCode","content":"\n\n\u003cimg src=\"/assets/img/2024-07-09-7SimpleWaysToDrasticallyImproveYourPythonCode_0.png\" /\u003e\n\n## 소개\n\n파이썬은 데이터 과학과 함께 올라와 프로그래밍 세계에서 인기를 얻었는데, 이에는 아주 좋은 이유가 있습니다. 이 언어에는 C와 밀접한 연계성과 다양한 문제를 원활하게 해결하기 위한 적절한 타입 및 함수 시스템을 포함한 여러 이점이 있습니다. 이러한 이점 중 하나는 파이썬이 작성, 학습 및 해독이 굉장히 쉬운 언어임에 틀림없습니다. 이로 인해 파이썬은 대부분의 기본 계산 작업에 대한 고수준 스크립팅 언어로 변모했습니다.\n\n파이썬의 사용 편의성은 특히 데이터에 보다 집중하고 싶은 과학자들이나 구문에 덜 관심을 갖고 싶은 초보 프로그래머들을 위한 매력적인 선택지가 됩니다. 그러나 사용 편의성과 접근성과 함께 성능에 주목할 필요가 있습니다. 또한 파이썬 같은 스크립팅 언어는 일반적으로 방법을 잘못 사용하더라도 파악하지 못하거나 직면할 필요가 없는 공간을 훨씬 더 많이 제공하는 경향이 있습니다. 다행히도 새로운 파이썬 사용자들을 위해서 파이썬은 광범위한 기능을 도입하여 사용하기 쉽고 동적으로 타입이 지정된 스크립팅 언어의 단점을 완화할 수 있었습니다. 좋은 프로그래밍 관행과 함께 파이썬의 타입 시스템과 생태계를 효과적으로 활용함으로써 파이썬의 다양한 단점을 완화하고 해당 언어에서 훨씬 더 나은 코드를 작성할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 추상화\n\n어떤 객체 지향 프로그래밍 언어에서 가장 먼저 이야기해야 하는 것은 추상화입니다. 추상화는 상속을 사용하여 훨씬 더 많은 기능을 더 적은 코드로 만들 수 있는 일반적인 프로그래밍 개념입니다. 상속은 추상화를 용이하게 하는 방법으로, 하위 클래스를 통해 기능을 전파하는 클래스 유형이 있는 방식입니다. 이것이 추상화 개념의 원래 출발점이자 객체 지향 프로그래밍 개념의 기반이 됩니다. 여기서 \"메서드\"는 해당 유형에 적합하게 설계된 클래스의 내부 함수를 의미합니다.\n\n추상화는 많은 다른 유형과 함께 사용할 수 있는 일반적인 함수를 만들 수 있게 해줍니다. 이게 바로 계층적 하위 클래스를 사용하여 어떤 유형인지 결정할 수 있는 것입니다. 이것은 다형성이라고도 하며, 하나의 서브루틴으로 여러 유형의 데이터 구조를 '변형'할 수 있는 능력을 의미합니다. Python에서는 메서드와 속성이 클래스를 구성합니다. 그런 다음 이 클래스의 하위 클래스가 될 수 있으며, 속성과 메서드를 상속받을 수 있습니다. 이것이 상속이라고 하며, Simula 시뮬레이션 언어에서 공개된 추상화 개념의 원조입니다.\n\n프로그래머로서 들을 수 있는 일반적인 조언 중 하나는 \"일반적인 함수를 작성하라\"는 것입니다. 이 조언은 의미가 있습니다. 함수가 보다 일반적일수록 프로젝트에 최종적으로 들어가는 코드가 적어집니다. 이는 또한 사물이 파괴될 기회가 적어지고, 파괴된 경우에는 해결책을 형성하기 위해 한 곳만 살펴보면 되는 것을 의미합니다. 그러나 이 조언에서 종종 빠지는 중요한 부분은 일반적인 함수를 계층적 추상화 수준으로 설계해야 한다는 것입니다. 다시 말해, 우리는 모든 차량을 위해 함수를 작성하고, 필요한 경우에만 트럭을 위한 함수를 작성해야 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이렇게 보면, 파이썬이 제공하는 기능과 메서드 기능도 자연스럽게 패턴이 있는 것 같아요. 함수는 매우 일반적인 호출에 사용하고, 메서드는 특정 유형의 호출에 더 적합하며 특히 상속을 원하는 경우 더 좋아요. Python에서 추상화 기법을 사용하려면, 우선 클래스를 만들어야 해요:\n\n```python\nclass Car:\n    def __init__(self, name, color: str):\n        self.name = name\n        self.color = color\n    def honk(self):\n        print(self.name + \" has just honked at us in their \" + self.color + \" car\")\n```\n\n이 간단한 클래스에는 name 및 color 속성과 honk 메서드가 있습니다. 자동차를 만들고 honk 메서드를 호출하면 작은 메시지가 출력됩니다.\n\n```python\nmycar = Car(\"the mystery machine\", \"green, flower-covered\")\nmycar.honk()\n\nthe mystery machine has just honked at us in their green, flower-covered car\n선택이 삭제됨\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이것은 좋아요. 하지만 저는 트럭도 가지고 있어요. 제가 시골 소녀니까요. 그래서 우리는 트럭을 만들어야 할 거예요. 괄호 안에 Car 클래스를 Truck 클래스에 제공해주면 Car의 모든 속성과 메소드를 상속받을 수 있어요. 데이터인 이름과 색깔은 같이 저장하지만, 우리의 honk 메소드는 Car의 버전이 차량이 Car임을 언급하기 때문에 변경되어야 해요. 따라서 이를 고려하여, 우리는 서브 클래스에 새로운 메소드를 작성함으로써 상속된 메소드를 오버로드할 수 있어요.\n\n```js\nclass Truck(Car):\n    def honk(self):\n        print(self.name + \" has just honked at us in their \" + self.color + \" truck\")\n```\n\n추상화하지 않은 경우 이 코드는 다음과 같아요:\n\n```js\nclass Truck(Car):\n    def __init__(self, name, color : str):\n        self.name = name\n        self.color = color\n    def honk(self):\n        print(self.name + \" has just honked at us in their \" + self.color + \" truck\")\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nmytruck = Truck(\"my large truck\", \"red\")\nmytruck.honk()\n\nmy large truck가 빨간 트럭으로 우리에게 경적을 울렸어요\n```\n\n우리는 완전히 새로운 Car를 생성할 수도 있습니다. 여기서 중요한 점은 pass 키워드를 사용하여 Python의 들여쓰기 문법을 활용해 생성자를 이름만 정의하는 것입니다.\n\n```python\nclass Sedan(Car):\n    pass\n```\n\n훨씬 큰 사용 사례에서 추상화가 Python에서 훌륭한 코드를 작성하는 데 절대적으로 필요한 이유를 이해하기 쉽습니다. 다행히 이 기술은 사용하기 매우 쉽습니다, 그리고 제가 논의하고 싶은 다음 기술도 마찬가지입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 표현식들\n\n파이썬과 유사한 많은 다양한 스크립팅 언어를 사용한 후에 얘기하지만, 표현식들이 이런 언어에서 작업할 때 가장 귀중한 자산 중 하나라는 걸 자신 있게 말씀드릴 수 있어요. 표현식들은 제너레이터, 리스트 및 기타 유형을 아주 간결하고 효과적으로 생성하는 방법입니다. 일반적으로 기존의 for 루프를 통해 작성되는 것과 같은 형태로 구성될 수 있는 요소들을 생성하는 방법입니다. 예를 들어, 1부터 30까지의 제곱을 생성하는 다음 예제를 고려해보세요:\n\n```js\nvalues = []\nfor x in range(1, 30):\n    values.append(x ** 2)\n```\n\n이것은 for 루프 방식으로, 이는 파이썬에서 반복 가능한 요소와 함께 작업하는 핵심적인 방법입니다. 이 접근 방식의 for 루프 버전은 리스트를 초기화하고 각 반복에서 해당 리스트에 새 요소를 추가하는 것을 요구합니다. 이 방식은 효율적이지만, 요소를 생성하는 데 제너레이터를 사용하는 것만큼 효과적이지는 않습니다. 후자는 더 간결할 뿐만 아니라 성능도 더 나아집니다. 위 예제의 코드는 간단한 리스트 표현식으로 한 줄로 변환됩니다. 제너레이터를 생성하려면 사실상 역방향 for 루프를 작성하고 리스트 구분 기호로 둘러싸면 됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nvalues = [x ** 2 for x in range(1, 30)]\n```\n\n위에 대한 설명은 지능 표현식 또는 생성기가 다음 반복 단계의 실행에 매핑된 반환을 만들기위한 함수를 만들어 냄을 의미합니다. 좀 더 간단한 용어로 설명하면, 생성기는 함수에서 반복자를 통해 반환을 만들기 위해 특별히 만들어지는 반면 for 루프는 더 개방적이며 단순히 반복자를 만듭니다. 이로 인해 Python에서 작업을 크게 빠르게 만들며 코드를 훨씬 더 간결하게 만듭니다. 그러나 각 요소에 대해 반환을 기대하지 않는 경우에는 다른 방법을 사용하는 것이 더 나을 수 있습니다.\n\n## 람다 및 맵\n\nPython 코드를 극적으로 개선하는 다음 간단한 기술은 iterable의 요소들을 횡단하여 함수를 호출하는 조합인 람다와 맵을 사용하는 것입니다. 현재 Python의 가장 일반적인 응용 분야가 과학 컴퓨팅이라는 점을 고려하면, 람다와 맵은 놀라울 만큼 많이 사용되는 Python 기능입니다. 둘의 다양성은 많은 다른 도메인에서 함께 기능을 통해 뛰어나기 때문에, 이 기술은 확실히 알아두어야 할 가치가 있습니다. 특히 데이터 과학을 위해 Python 언어를 사용하는 사람들뿐만 아니라요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nLambda는 호출 가능한 함수 유형으로 신속하게 표현식을 작성하는 데 사용됩니다. 이를 통해 간단한 클로저 함수를 생성할 수 있습니다. 이 함수들은 인수로 제공되어 다양한 가능성을 제공할 수 있습니다. Python에서 람다를 사용하는 것은 비교적 간단합니다. 람다 키워드에 인수를 제공한 다음 콜론과 함수의 논리를 추가합니다.\n\n```js\nf = lambda x: x + 5\nf(5)\n\n10\n```\n\n이 개념은 함수를 생성하는 능력 때문에 상당히 강력합니다. 그러나 이 기술이 빛나는 한 가지 맥락은 이러한 함수들을 반복 가능한 객체에 매핑하는 것입니다. 이를 통해 생성기와 연관된 생성 측면 없이 배열을 변경할 수 있습니다. 이 경우 함수는 몇 가지 차이점이 있는 생성기와 유사한 기능을 만들기 위해 요소를 직접 제공받습니다.\n\n```js\nf = lambda x: x ** 2\n\nm = map(f, values)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리가 맵을 사용하여 함수를 값에 매핑하면 맵을 단순히 리스트로 캐스팅하여 제곱된 배열을 얻을 수 있습니다:\n\n```js\nsquared = list(m)\n[6,\n 9,\n 14,\n 21,\n 30,\n 41,\n 54,\n 69,\n 86,\n 105,\n....\r\n```\n\n이 두 가지를 결합함으로써 코드를 압축하는 방법이 얼마나 쉬운지 알 수 있습니다!\n\n## 추출\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음 소프트웨어를 개선하는 방법은 일반적으로 우수한 프로그래밍 조언입니다. 추출 기술은 대규모 하위 루틴에서 코드를 추출하여 작은 하위 루틴의 시리즈로 압축하는 실천 방법입니다. 전체 작업을 처리하는 하나의 함수를 작성하는 대신 해당 작업의 각 단계는 프로젝트 내의 다른 함수로 전달됩니다. 이 기술에 대해 중요성과 중요성을 노래한 몇 가지 기사를 작성했습니다. 위대한 소프트웨어 공학 프로젝트를 만들 때 매우 중요합니다.\n\n```python\ndef quiz_user():\n    correct = []\n    print(\"이름은 뭐에요?\")\n    x = input()\n    print(\"2 + 2는 뭐에요?\")\n    answer = input()\n    \n    if answer == \"4\":\n        print(\"정답\")\n        correct.append(True)\n    else:\n        print(\"틀렸어요.\")\n        correct.append(False)\n    \n    print(\"하늘의 색깔은 뭐에요?\")\n    answer = input()\n    \n    if answer == \"파란색\":\n        print(\"정답\")\n        correct.append(True)\n    else:\n        print(\"틀렸어요.\")\n        correct.append(False)\n    \n    return correct\n```\n\n이 함수에는 여러 단계가 포함되어 있고 최종적으로 이름이 시행하는 것 이상을 수행합니다. 이는 이상적이지 않습니다. 각 함수가 직접적으로 작업을 수행하도록 원합니다. 그리고 목적 외 작은 작업은 함수 바깥에 두는 것이 좋습니다. 추출 프로세스는 몇 가지 핵심 단계로 수행됩니다. 첫 번째 단계에서 함수의 다른 부분과 입력 및 출력을 고려합니다. 함수를 그룹화한 후에는 함수를 함수 밖으로 추출하고 함수를 호출합니다. 이 특정 상황에서는 더 다재다능한 질문 요청 함수를 만드는 것이 더 적합할 수 있지만, 이 경우에는 각각의 출력이 알고리즘 과정의 새로운 단계인 것처럼 가정하여 함수의 반환을 생성합니다.\n\n```python\ndef ask_name():\n    print(\"이름은 뭐에요?\")\n    x = input()\n    print(\"안녕 \" + x)\n    return x\n\ndef question1():\n    print(\"2 + 2는 뭐에요?\")\n    answer = input()\n    \n    if answer == \"4\":\n        print(\"정답\")\n        return True\n    else:\n        print(\"틀렸어요.\")\n        return False\n        \ndef question2():\n    print(\"하늘의 색깔은 뭐에요?\")\n    answer = input()\n    \n    if answer == \"파란색\":\n        print(\"정답\")\n        return True\n    else:\n        print(\"틀렸어요.\")\n        return False\n\ndef quiz_user():\n    correct = []\n    ask_name()\n    correct = [f() for f in (question1, question2)]\n    return correct\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n추출 기술을 사용하면 코드를 다양한 방법으로 개선할 수 있어요. 먼저, 함수를 작성할 때 코드를 함수 내에서 재사용할 수 있어요. 특정 알고리즘을 더 큰 함수 내에 그대로 두면, 전혀 다른 목적을 가진 코드 일부에 액세스하지 못할 수도 있어요. 추출 사용의 또 다른 이점은 프로젝트가 훨씬 더 조직적으로 됩니다. 함수는 짧고 중첩을 최소화하는 것이 좋아요. 이 모든 것은 논리적인 코드를 고유한 범위로 가져오는 것이 종종 매우 좋은 선택이 될 수 있다는 것을 말해요.\n\n## del\n\n다음으로 논의하고 싶은 파이썬 기능은 'del' 입니다. 이 키워드는 파이썬 객체를 메모리에서 제거하는 데 사용됩니다. 첫눈에는 그다지 중요하지 않아 보이지만, 파이썬이 사용하기 쉬운 스크립트 언어이기 때문에 가능한 한 자주 사용하고 싶은 파이썬 기능 중 하나에요. 'del'은 종종 간과되지만, 이 기능은 메모리를 보존하는 데 매우 도움이 될 수 있어요.\n\n```js\ndel squared\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파이썬과 같은 스크립트 언어에서는 메모리 및 성능 관리 방법이 더 제한적이기 때문에 계산 시간을 단축하고 메모리를 해제하는 데 도움이 되는 모든 것을 활용하고 싶을 것입니다. 파이썬은 사실 유사한 스크립트 언어들 중에서 적어도 힙에서 빠르게 무언가를 제거하고 가비지 수집하는 키워드 del 이 하나는 있어서 어느 정도 독특합니다. 그런 관점에서 이 기능을 확실히 활용하고 싶습니다.\n\n## break 와 continue\n\n당신의 도구 상자에 꼭 있어야 할 또 다른 중요한 기술은 break 와 continue 키워드입니다. 이 두 키워드는 모두 반복적 루프 문맥에서 특히 사용되며, 반복적 루프를 더 최적화하기 위해 break 를 사용하여 반복을 중단하거나 continue 를 사용하여 다음 요소로 건너뛸 수 있습니다.\n\n```js\nmydata = [None, None, 55, 22, 33, 44, None, 2, None, 73, 22, None, None, None, 36, \"stop here please\", 23]\nnewvalues = []\nfor x in mydata:\n    if x == None:\n        continue\n    elif x == \"stop here please\":\n        break\n    newvalues.append(x)\n\nnewvalues\n[55, 22, 33, 44, 2, 73, 22, 36]\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n당연히, break와 continue는 각각 자신의 사용 사례를 가지고 있습니다. 예를 들어 조건부로 특정 요소에 대해 작업하고 싶을 때를 생각해보세요. 이러한 키워드에는 끝이 없는 사용 방법이 있으며, 여러분의 도구 상자에 이러한 간단한 도구들을 유지하는 것이 좋은 아이디어입니다.\n\n## else는 최대한 사용을 줄입니다\n\n코드 개선에 관한 참고 사항으로 다룰 마지막 주제는 else를 최대한 줄이는 방법입니다. 저는 큰 else 문과 중첩된 조건문 같은 것은 가능한 한 피해야 한다고 생각합니다. else 자체가 서브루틴이라는 것을 이해해야 합니다. 이것은 우리 함수 아래에서 정의된 완전히 독립적인 스코프의 또 다른 레이어입니다. else 키워드를 사용하는 많은 경우가 있지만, 우리 코드를 더 읽기 쉽고 기능적으로 더 효율적으로 만들기 위해 사용하지 않아야 할 때도 있습니다.\n\n```js\nclass Pump:\n    def __init__(self):\n        self.pumping = False\n\ndef activate_lights():\n    print(\"the lights are on\")\n\nmainvalve = Pump()\n\ndef turn_on_pump():\n    mainvalve.pumping = True\n\ndef turn_switch(has_power: bool):\n    if not has_power:\n        print(\"there is no power\")\n    else:\n        activate_lights()\n        turn_on_pump()\n        if mainvalve.pumping == False:\n            print(\"error turning on the pump\")\n        else:\n            print(\"the pump is on!\")\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 경우에는 기본적으로 else 아래에서 함수를 계속 진행합니다. 이 접근 방식에는 여러 가지 단점이 있습니다. 먼저, 똑같은 것을 두 번 프로그래밍할 가능성이 훨씬 커집니다. 이것은 이 글의 방법론 중 하나인데, 우리는 그렇게 하고 싶지 않습니다.\n\n```js\ndef turn_switch(has_power: bool):\n    if not has_power:\n        print(\"전원이 없습니다\")\n    else:\n        activate_lights()\n        turn_on_pump()\n        if mainvalve.pumping == False:\n            print(\"펌프 작동 오류\")\n        else:\n            print(\"펌프가 작동 중입니다!\")\n```\n\n```js\ndef turn_switch(has_power: bool):\n    if not has_power:\n        print(\"전원이 없습니다\")\n        return\n    activate_lights()\n    turn_on_pump()\n    if mainvalve.pumping == False:\n        print(\"펌프 작동 오류\")\n        return\n        print(\"펌프가 작동 중입니다!\")\n```\n\n또한 위의 경우에는 언젠가는 조건부 내부에서 사용되는 변수를 할당해야 할 것입니다. 이 값은 조건부 외부에서 사용할 계획이 있다면 함수의 비공개 범위에 유지하는 것이 훨씬 더 합리적입니다. 조건부 내부에서 변수를 새로 할당할 수 없으며, 조건부는 루프와 마찬가지로 다른 렉시컬 범위를 추가합니다. 이러한 점을 고려하면 이러한 범위를 설정하고 데이터를 전달하는 데 시간이 걸립니다. 몇몇 부적절한 조건부는 큰 문제를 일으키지 않을 수 있지만, 추가적인 중첩 및 더 많은 호출은 항상 성능을 저하시킵니다. 최적의 성능은 Python과 같은 언어에서 더욱 중요합니다. 우리는 Python의 속도 신뢰성이 C와 같은 것에 비하면 그리 높지 않기 때문에 실제 작성한 대부분의 Python 코드가 가능한 최적화되도록 하려고 할 것입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다른 경우마다 else를 사용해서는 안 된다는 이유에도 불구하고, else에는 사용할 때의 이유가 있습니다. 특히 모든 조건문 뒤에 기본적으로 else를 사용하는 것은 일반적인 코딩 방식이기 때문에, 그 사용 사례가 else를 사용해야 하는 경우에 대해 명확하게 표현해야 합니다. 전자를 사용하는 것이 더 나은 점이 있다고 생각해요.\n\n## 결론\n\n파이썬의 성공은 확실히 사용 편의성과 접근성에 기인합니다. 다른 언어들처럼 단점이 없는 것은 아니지만, 파이썬이 인기를 얻은 이유를 쉽게 이해할 수 있습니다. 특히 파이썬을 주로 사용하는 분야를 고려하면 더 그렇습니다. 파이썬의 접근성 중 하나인 단점은, 사용자가 놓치기 쉬운 기능들이 있어서 입니다. 예를 들어, 누군가는 오랜 시간 동안 파이썬을 사용했지만 pipenv를 어떻게 사용해야 하는지 모르는 경우가 있을 수 있습니다.\n\n다행히도 시간이 흘러가며 프로그래밍 실력은 향상되고 지식이 쌓입니다. 파이썬은 쉽게 시작할 수 있는 언어이지만, 정말 멋진 기능들을 발견하려면 조금의 연구가 필요합니다. 지속적인 발전을 위해 더 나은 코딩 습관을 습득하는 것은 좋은 생각입니다. 우리는 프로그래머로써 항상成長해야 하며, 우리는 삶을 살아가며 배우고 가르치고 원하는 것을 만드는 시간이 제한되어 있습니다. 우리가 원하는 것이 무엇이든 상관없이 배울 시간을 갖도록 하자는 것이 중요합니다. 우수한 프로그래머가 되는 가장 놀라운 점은 극적인 표현력으로 주변 모두에게 이익이 되는 것입니다. 마치 관객들이 모두 팬인 거리 공연자와 같이요. 오늘날 파이썬을 잘 배운 것은 극히 중요하기 때문에, 적어도 나의 프로그래밍에 대한 분명하고 구체적인 조언을 나눌 수 있어서 기쁩니다!","ogImage":{"url":"/assets/img/2024-07-09-7SimpleWaysToDrasticallyImproveYourPythonCode_0.png"},"coverImage":"/assets/img/2024-07-09-7SimpleWaysToDrasticallyImproveYourPythonCode_0.png","tag":["Tech"],"readingTime":15},{"title":"Kafka, Redis, Postgres, Kubernetes를 활용한 실시간 파이프라인 마이크로서비스 프로젝트 방법","description":"","date":"2024-07-09 19:43","slug":"2024-07-09-Real-TimePipelineMicroservicesProjectwithKafkaRedisPostgresandKubernetes","content":"\n\n# 소개\n\n이 문서는 데이터를 처리하여 분석을 위해 데이터베이스를 채우는 데 사용되는 실시간 마이크로서비스 프로젝트에 대한 안내서입니다.\n\n![이미지](/assets/img/2024-07-09-Real-TimePipelineMicroservicesProjectwithKafkaRedisPostgresandKubernetes_0.png)\n\n# STG-Service\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Redis 클라이언트\n\nRedis와 상호 작용하기 위한 간단한 클라이언트입니다. 특정 키로 객체를 가져오거나 새 키-값 쌍을 설정할 수 있습니다:\n\n```js\nimport json\nfrom typing import Dict\nimport redis\n\nclass RedisClient:\n    def __init__(self, host: str, port: int, password: str, cert_path: str) -\u003e None:\n        self._client = redis.StrictRedis(\n            host=host,\n            port=port,\n            password=password,\n            ssl=True,\n            ssl_ca_certs=cert_path)\n    def set(self, k, v):\n        self._client.set(k, json.dumps(v))\n    def get(self, k) -\u003e Dict:\n        obj: str = self._client.get(k)\n        return json.loads(obj)\n```\n\n# Postgres 클라이언트\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n데이터베이스에 연결하는 것 외에도, 클라이언트는 하나의 컨텍스트 매니저의 일부로 여러 쿼리를 실행할 수 있는 기능을 제공하여 한 트랜잭션의 실행 명령을 커밋할 필요가 없어요 (나중에 사용 예제를 보게 될 거에요):\n\n```js\nfrom contextlib import contextmanager\nfrom typing import Generator\nimport psycopg2\n\nclass PgConnect:\n    def __init__(self, host: str, port: int, db_name: str, user: str, pw: str, sslmode: str = \"require\") -\u003e None:\n        self.host = host\n        self.port = port\n        self.db_name = db_name\n        self.user = user\n        self.pw = pw\n        self.sslmode = sslmode\n    def url(self) -\u003e str:\n        return \"\"\"\n            host={host}\n            port={port}\n            dbname={db_name}\n            user={user}\n            password={pw}\n            target_session_attrs=read-write\n            sslmode={sslmode}\n        \"\"\".format(\n            host=self.host,\n            port=self.port,\n            db_name=self.db_name,\n            user=self.user,\n            pw=self.pw,\n            sslmode=self.sslmode)\n    @contextmanager\n    def connection(self) -\u003e Generator:\n        keepalive_kwargs = {\n            \"keepalives\": 1,\n            \"keepalives_idle\": 30,\n            \"keepalives_interval\": 5,\n            \"keepalives_count\": 5,\n        }\n        conn = psycopg2.connect(self.url(), **keepalive_kwargs)\n        try:\n            yield conn\n            conn.commit()\n        except Exception as e:\n            conn.rollback()\n            raise e\n        finally:\n            conn.close()\r\n```\n\n카프카에서 메시지를 생성하고 사용하는 두 개의 별도 및 간단한 클라이언트:\n\n```js\nimport json\nfrom typing import Dict, Optional\nfrom confluent_kafka import Consumer, Producer\n\ndef error_callback(err):\n    print('Something went wrong: {}'.format(err))\n\nclass KafkaProducer:\n    def __init__(self, host: str, port: int, user: str, password: str, topic: str, cert_path: str) -\u003e None:\n        params = {\n            'bootstrap.servers': f'{host}:{port}',\n            'security.protocol': 'SASL_SSL',\n            'ssl.ca.location': cert_path,\n            'sasl.mechanism': 'SCRAM-SHA-512',\n            'sasl.username': user,\n            'sasl.password': password,\n            'error_cb': error_callback,\n        }\n        self.topic = topic\n        self.p = Producer(params)\n    def produce(self, payload: Dict) -\u003e None:\n        self.p.produce(self.topic, json.dumps(payload))\n        self.p.flush(10)\n\nclass KafkaConsumer:\n    def __init__(self,\n                 host: str,\n                 port: int,\n                 user: str,\n                 password: str,\n                 topic: str,\n                 group: str,\n                 cert_path: str\n                 ) -\u003e None:\n        params = {\n            'bootstrap.servers': f'{host}:{port}',\n            'security.protocol': 'SASL_SSL',\n            'ssl.ca.location': cert_path,\n            'sasl.mechanism': 'SCRAM-SHA-512',\n            'sasl.username': user,\n            'sasl.password': password,\n            'group.id': group,  # '',\n            'auto.offset.reset': 'earliest',\n            'enable.auto.commit': False,\n            'error_cb': error_callback,\n            'debug': 'all',\n            'client.id': 'someclientkey'\n        }\n        self.topic = topic\n        self.c = Consumer(params)\n        self.c.subscribe([topic])\n    def consume(self, timeout: float = 3.0) -\u003e Optional[Dict]:\n        msg = self.c.poll(timeout=timeout)\n        if not msg:\n            return None\n        if msg.error():\n            raise Exception(msg.error())\n        val = msg.value().decode()\n        return json.loads(val)\r\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# STG Schema\n\n포스트그레스의 스테이징 레이어로, Kafka에서 나온 로우 메시지를 저장할 한 개의 테이블이 있을 것입니다. 이는 아래와 같이 정의되어 있습니다.\n\n```js\nCREATE SCHEMA IF NOT EXISTS stg;\n\nCREATE TABLE IF NOT EXISTS stg.order_events (\n    id SERIAL   PRIMARY KEY,\n    object_id   INTEGER NOT NULL UNIQUE,\n    object_type VARCHAR(20) NOT NULL,\n    sent_dttm   TIMESTAMP NOT NULL,\n    payload     JSON NOT NULL\n);\n```\n\n그리고 이를 실행할 파이썬 함수는:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nfrom lib.pg.pg_connect import PgConnect\n\ndef make_stg_migrations(db: PgConnect) -\u003e None:\n    with db.connection() as conn:\n        with conn.cursor() as cur:\n            # STG 스키마의 SQL 정의 경로는 다를 수 있습니다.\n            cur.execute(open(\"stg_schema.sql\", \"r\").read())\r\n```\n\n프로그램이 `db.connection()`으로 정의된 컨텍스트 매니저를 벗어나면 명시적으로 실행할 필요 없이 자동으로 커밋됩니다.\n\n# 메시지 처리\n\n먼저 소비된 카프카 메시지를 STG 포스트그레스 테이블(StgRepository)에 삽입한 다음, 레디스에서 레스토랑 데이터를 풍부하게하여 다른 카프카 클러스터(StgMessageProcessor)를 위한 출력 메시지를 구성해야 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nfrom datetime import datetime\n\nfrom lib.pg.pg_connect import PgConnect\n\nclass StgRepository:\n    def __init__(self, db: PgConnect) -\u003e None:\n        self._db = db\n    \n    def order_events_insert(self,\n                            object_id: int,\n                            object_type: str,\n                            sent_dttm: datetime,\n                            payload: str\n                            ) -\u003e None:\n        with self._db.connection() as conn:\n            with conn.cursor() as cur:\n                cur.execute(\n                    \"\"\"\n                        INSERT INTO stg.order_events (object_id, object_type, sent_dttm, payload) VALUES (%(object_id)s, %(object_type)s, %(sent_dttm)s, %(payload)s)\n                        ON CONFLICT (object_id)\n                        DO UPDATE \n                        SET object_type = EXCLUDED.object_type,\n                            sent_dttm = EXCLUDED.sent_dttm,\n                            payload = EXCLUDED.payload;\n                    \"\"\",\n                    {\n                        'object_id': object_id,\n                        'object_type': object_type,\n                        'sent_dttm': sent_dttm,\n                        'payload': payload\n                    }\n                )\r\n```\r\n\r\n```python\nimport json\nfrom datetime import datetime\nfrom logging import Logger\nfrom lib.kafka_connect.kafka_connectors import KafkaConsumer, KafkaProducer\nfrom lib.redis.redis_client import RedisClient\nfrom stg_loader.repository.stg_repository import StgRepository\n\nclass StgMessageProcessor:\n    def __init__(self,\n                 consumer: KafkaConsumer,\n                 producer: KafkaProducer,\n                 redis: RedisClient,\n                 stg_repository: StgRepository,\n                 logger: Logger) -\u003e None:\n        self._logger = logger\n        self._consumer = consumer\n        self._producer = producer\n        self._redis = redis\n        self._stg_repository = stg_repository\n        self._batch_size = 100\n    \n    def run(self) -\u003e None:\n        self._logger.info(f\"{datetime.utcnow()}: START\")\n        for i in range(self._batch_size):\n            msg = self._consumer.consume()\n            if not msg:\n                continue\n            self._stg_repository.order_events_insert(object_id=msg[\"object_id\"],\n                                                     object_type=msg[\"object_type\"],\n                                                     sent_dttm=msg[\"sent_dttm\"],\n                                                     payload=json.dumps(msg[\"payload\"]))\n            dst_msg = self._construct_output_message(msg)\n            self._producer.produce(dst_msg)\n        self._logger.info(f\"{datetime.utcnow()}: FINISH\")\n    \n    def _construct_output_message(self, original_message: dict) -\u003e dict:\n        restaurant_id = original_message[\"payload\"][\"restaurant\"][\"id\"]\n        restaurant_data = self._redis.get(restaurant_id)\n        restaurant_name = restaurant_data[\"name\"]\n        user_id = original_message[\"payload\"][\"user\"][\"id\"]\n        user_data = self._redis.get(user_id)\n        user_name = user_data[\"name\"]\n        user_login = user_data[\"login\"]\n        order = original_message[\"payload\"]\n        restaurant_menu = {p[\"_id\"]: p for p in restaurant_data[\"menu\"]}\n        products = {p[\"id\"]: {**p, \"category\": restaurant_menu[p[\"id\"]][\"category\"]} for p in order[\"order_items\"]}\n        return {\n                \"object_id\": original_message[\"object_id\"],\n                \"object_type\": original_message[\"object_type\"],\n                \"payload\": {\n                    \"id\": original_message[\"object_id\"],\n                    \"date\": order[\"date\"],\n                    \"cost\": order[\"cost\"],\n                    \"payment\": order[\"payment\"],\n                    \"status\": order[\"final_status\"],\n                    \"restaurant\": {\n                        \"restaurant_id\": restaurant_id,\n                        \"restaurant_name\": restaurant_name\n                    },\n                    \"user\": {\n                        \"user_id\": user_id,\n                        \"user_name\": user_name,\n                        \"user_login\": user_login\n                    },\n                    \"products\": products\n                }\n            }\r\n```\r\n\r\n# 서비스 구성\r\n\r\n소스/싱크 카프카, Redis 및 포스트그레스와 연결해야 합니다. 이것은 확실히 많은 구성이 필요하며 환경 변수를 사용해야 하므로 이를 별도의 클래스에서 수용할 것입니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nimport os\n\nfrom lib.kafka_connect.kafka_connectors import KafkaConsumer, KafkaProducer\nfrom lib.redis.redis_client import RedisClient\nfrom lib.pg.pg_connect import PgConnect\nfrom stg_loader.repository.stg_repository import StgRepository\n\nclass AppConfig:\n    CERTIFICATE_PATH = '/crt/YandexInternalRootCA.crt'\n    DEFAULT_JOB_INTERVAL = 25\n    def __init__(self) -\u003e None:\n        self.kafka_host = str(os.getenv('KAFKA_HOST') or \"\")\n        self.kafka_port = int(str(os.getenv('KAFKA_PORT')) or 0)\n        self.kafka_consumer_username = str(os.getenv('KAFKA_CONSUMER_USERNAME') or \"\")\n        self.kafka_consumer_password = str(os.getenv('KAFKA_CONSUMER_PASSWORD') or \"\")\n        self.kafka_consumer_group = str(os.getenv('KAFKA_CONSUMER_GROUP') or \"\")\n        self.kafka_consumer_topic = str(os.getenv('KAFKA_SOURCE_TOPIC') or \"\")\n        self.kafka_producer_username = str(os.getenv('KAFKA_PRODUCER_USERNAME') or \"\")\n        self.kafka_producer_password = str(os.getenv('KAFKA_PRODUCER_PASSWORD') or \"\")\n        self.kafka_producer_topic = str(os.getenv('KAFKA_DESTINATION_TOPIC') or \"\")\n        self.redis_host = str(os.getenv('REDIS_HOST') or \"\")\n        self.redis_port = int(str(os.getenv('REDIS_PORT')) or 0)\n        self.redis_password = str(os.getenv('REDIS_PASSWORD') or \"\")\n        self.pg_host = str(os.getenv('PG_HOST') or \"\")\n        self.pg_port = int(str(os.getenv('PG_PORT')) or 6432)\n        self.pg_db_name = str(os.getenv(\"PG_DB_NAME\"))\n        self.pg_user = str(os.getenv('PG_USER') or \"\")\n        self.pg_password = str(os.getenv('PG_PASSWORD') or \"\")\n    def kafka_producer(self):\n        return KafkaProducer(\n            self.kafka_host,\n            self.kafka_port,\n            self.kafka_producer_username,\n            self.kafka_producer_password,\n            self.kafka_producer_topic,\n            self.CERTIFICATE_PATH\n        )\n    def kafka_consumer(self):\n        return KafkaConsumer(\n            self.kafka_host,\n            self.kafka_port,\n            self.kafka_consumer_username,\n            self.kafka_consumer_password,\n            self.kafka_consumer_topic,\n            self.kafka_consumer_group,\n            self.CERTIFICATE_PATH\n        )\n    def redis_client(self) -\u003e RedisClient:\n        return RedisClient(\n            self.redis_host,\n            self.redis_port,\n            self.redis_password,\n            self.CERTIFICATE_PATH\n        )\n    def stg_loader(self) -\u003e StgRepository:\n        db: PgConnect = PgConnect(\n            self.pg_host,\n            self.pg_port,\n            self.pg_db_name,\n            self.pg_user,\n            self.pg_password\n        )\n        return StgRepository(db)\n    def pg_client(self) -\u003e PgConnect:\n        return PgConnect(\n            self.pg_host,\n            self.pg_port,\n            self.pg_db_name,\n            self.pg_user,\n            self.pg_password\n        )\r\n```\n\n# STG Service 실행\n\nStgMessageProcessor를 백그라운드 프로세스로 실행해야 합니다 (apscheduler 파이썬 모듈의 BackgroundScheduler를 사용할 것입니다) 그리고 건강 상태를 확인하는 간단한 API를 추가할 것입니다.\n\n```python\nimport os\nimport logging\n\nfrom apscheduler.schedulers.background import BackgroundScheduler\nfrom flask import Flask\nfrom stg_loader.stg_message_processor_job import StgMessageProcessor\nfrom app_config import AppConfig\nfrom stg_migrations import make_stg_migrations\n\napp = Flask(__name__)\n\n# 서비스가 정상인지 확인할 수 있는 엔드포인트 생성\n@app.get('/health')\ndef health():\n    return 'healthy'\n\nif __name__ == '__main__':\n    app.logger.setLevel(logging.DEBUG)\n    config = AppConfig()\n    make_stg_migrations(config.pg_client())\n    proc = StgMessageProcessor(logger=app.logger,\n                               consumer=config.kafka_consumer(),\n                               producer=config.kafka_producer(),\n                               redis=config.redis_client(),\n                               stg_repository=config.stg_loader())\n    scheduler = BackgroundScheduler()\n    scheduler.add_job(func=proc.run, trigger=\"interval\", seconds=config.DEFAULT_JOB_INTERVAL)\n    scheduler.start()\n    app.run(debug=True, host='0.0.0.0', use_reloader=False)\r\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Dockerfile\n\n스테이징 서비스는 코어크레이트 기반의 쿠버네티스 클러스터에서 실행될 예정이므로, 서비스를 도커 이미지로 만들어주어야 합니다.\n\n```js\nFROM python:3.10\n\nRUN apt-get update -y\n# 컨테이너 내에서 confluent_kafka 파이썬 모듈이 작동되도록 필요합니다\nRUN git clone https://github.com/edenhill/librdkafka \u0026\u0026 cd librdkafka \u0026\u0026 ./configure \u0026\u0026 make \u0026\u0026 make install \u0026\u0026 ldconfig\nCOPY . .\nRUN pip install -r requirements.txt\n# Kafka 클러스터에 안전한 연결을 위한 인증서 다운로드\nRUN mkdir -p /crt\nRUN wget \"https://storage.yandexcloud.net/cloud-certs/CA.pem\" --output-document /crt/YandexInternalRootCA.crt\nRUN chmod 0600 /crt/YandexInternalRootCA.crt\nWORKDIR /src\n# 파이썬 임포트가 작동되도록 설정\nENV PYTHONPATH \"${PYTHONPATH}:/src\"\nENTRYPOINT [\"python\"]\nCMD [\"app.py\"]\n```\n\n로컬 테스트를 위해 Docker Compose를 사용하여 스테이징 서비스를 실행할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```yaml\nversion: \"3.9\"\n\nservices:\n  stg_service:\n    build:\n      context: .\n      network: host\n    image: stg_img:local\n    container_name: stg_container\n    environment:\n      FLASK_APP: ${STG_SERVICE_APP_NAME:-stg_service}\n      DEBUG: ${STG_SERVICE_DEBUG:-True}\n      KAFKA_HOST: ${KAFKA_HOST}\n      KAFKA_PORT: ${KAFKA_PORT}\n      KAFKA_CONSUMER_USERNAME: ${KAFKA_CONSUMER_USERNAME}\n      KAFKA_CONSUMER_PASSWORD: ${KAFKA_CONSUMER_PASSWORD}\n      KAFKA_CONSUMER_GROUP: ${KAFKA_CONSUMER_GROUP}\n      KAFKA_SOURCE_TOPIC: ${KAFKA_SOURCE_TOPIC}\n      KAFKA_DESTINATION_TOPIC: ${KAFKA_DESTINATION_TOPIC}\n      KAFKA_PRODUCER_USERNAME: ${KAFKA_PRODUCER_USERNAME}\n      KAFKA_PRODUCER_PASSWORD: ${KAFKA_PRODUCER_PASSWORD}\n      REDIS_HOST: ${REDIS_HOST}\n      REDIS_PORT: ${REDIS_PORT}\n      REDIS_PASSWORD: ${REDIS_PASSWORD}\n      PG_HOST: ${PG_HOST}\n      PG_PORT: ${PG_PORT}\n      PG_DB_NAME: ${PG_DB_NAME}\n      PG_USER: ${PG_USER}\n      PG_PASSWORD: ${PG_PASSWORD}\n    network_mode: \"bridge\"\n    ports:\n      - \"5101:5000\"\n    restart: unless-stopped\n```\n\n.env 파일:\n\n```yaml\nKAFKA_HOST=******.mdb.yandexcloud.net\nKAFKA_PORT=9091\nKAFKA_CONSUMER_USERNAME=producer_consumer\nKAFKA_CONSUMER_PASSWORD=******\nKAFKA_CONSUMER_GROUP=test-consumer1\nKAFKA_SOURCE_TOPIC=dds_input_topic\nKAFKA_PRODUCER_USERNAME=producer_consumer\nKAFKA_PRODUCER_PASSWORD=*******\nKAFKA_DESTINATION_TOPIC=cdm_input_topic\n\nREDIS_HOST=******.mdb.yandexcloud.net\nREDIS_PORT=6380\nREDIS_PASSWORD=******\nPG_HOST=********.mdb.yandexcloud.net\nPG_PORT=6432\nPG_DB_NAME=sprint9dwh\nPG_USER=yandex_pg\nPG_PASSWORD=**********\n```\n\n# HELM 차트\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nChart.yaml 파일:\n\n```yaml\napiVersion: v2\nname: first-service\ndescription: 쿠버네티스용 헬름 차트\n\n# 차트는 'application' 또는 'library' 차트 중 하나일 수 있습니다.\n#\n# Application 차트는 템플릿 모음이며 버전이 지정된 아카이브로 패키지화하여 배포될 수 있습니다.\n#\n# Library 차트는 차트 개발자를 위한 유용한 유틸리티 또는 함수를 제공합니다. Application 차트의 종속성으로 포함되어\n# 렌더링 파이프라인에 이러한 유틸리티와 함수를 삽입합니다. Library 차트는 템플릿을 정의하지 않으며 따라서 배포될 수 없습니다.\ntype: application\n# 이것은 차트 버전입니다. 이 번호는 차트 및 해당 템플릿에 변경이 있을 때마다 증가해야 합니다.\n# 버전은 Semantic Versioning (https://semver.org/)을 따르는 것으로 예상됩니다.\nversion: 0.1.0\n# 이것은 배포되는 애플리케이션의 버전 번호입니다. 이 버전 번호는 애플리케이션에 변경이 있는 경우마다 증가해야 합니다.\n# 버전은 Semantic Versioning을 따르지 않습니다. 애플리케이션이 사용 중인 버전을 반영해야 합니다.\n# 따옴표와 함께 사용하는 것이 권장됩니다.\nappVersion: \"1.16.0\"\n```\n\nvalues.yaml 파일:\n\n```yaml\n# 앱의 기본 값.\n# 이것은 YAML 형식의 파일입니다.\n# 템플릿에 전달할 변수를 선언합니다.\n\nreplicaCount: 3\nimage:\n  # 컨테이너 레지스트리에 대한 링크. 야н덱스 클라우드에서 실행할 것입니다.\n  repository: cr.yandex/crpr6naar69761ehm0bp/stg_service\n  pullPolicy: IfNotPresent\n  # 기본적으로 차트 appVersion인 이미지 태그를 덮어씁니다.\n  tag: \"v2022-12-13-r1\"\ncontainerPort: 5000\nconfig:\n  KAFKA_HOST: rc1a-hins1kp5qsfnsob3.mdb.yandexcloud.net\n  KAFKA_PORT: '9091'\n  KAFKA_CONSUMER_USERNAME: producer_consumer\n  KAFKA_CONSUMER_PASSWORD: '*****'\n  KAFKA_CONSUMER_GROUP: test-consumer1\n  KAFKA_SOURCE_TOPIC: order-service_orders\n  KAFKA_PRODUCER_USERNAME: producer_consumer\n  KAFKA_PRODUCER_PASSWORD: '*****'\n  KAFKA_DESTINATION_TOPIC: dds_topic_name\n  REDIS_HOST: c-c9qeltiiu2rkcr6v9net.rw.mdb.yandexcloud.net\n  REDIS_PORT: '6380'\n  REDIS_PASSWORD: '*****'\n  PG_HOST: rc1b-4olk4uzgdrdte114.mdb.yandexcloud.net\n  PG_PORT: '6432'\n  PG_DB_NAME: sprint9dwh\n  PG_USER: yandex_pg\n  PG_PASSWORD: '*****'\nimagePullSecrets: []\nnameOverride: \"\"\nfullnameOverride: \"\"\npodAnnotations: {}\nresources:\n  # 일반적으로 기본 리소스를 지정하지 않고 사용자의 명시적인 선택으로 유지하는 것을 권장합니다.\n  # 이것은 Minikube와 같은 리소스가 적은 환경에서 차트 실행 기회를 높이기도 합니다.\n  # 리소스를 지정하려면 아래 줄 주석 처리를 해제하고 필요에 맞게 조정한 다음 'resources:' 뒤의 중괄호를 제거하세요.\n  limits:\n    cpu: 100m\n    memory: 128Mi\n  requests:\n    cpu: 100m\n    memory: 128Mi\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```yaml\ntemplates/configmap.yaml은 우리 서비스의 구성을 저장하는 k8s 엔터티입니다. values.yaml 파일의 config 블록에서 모든 키-값 쌍을 가져올 것입니다:\n\n---\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: {{ include \"app.fullname\" . }}-config\n  labels:\n    {{- include \"app.labels\" . | nindent 4 }}\n{{- with .Values.config }}\ndata:\n  {{- toYaml . | nindent 2 }}\n{{- end }}\n\ntemplates/deployment.yaml 파일\n\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: {{ include \"app.fullname\" . }}\n  labels:\n    {{- include \"app.labels\" . | nindent 4 }}\nspec:\n  replicas: {{ .Values.replicaCount }}\n  selector:\n    matchLabels:\n      {{- include \"app.selectorLabels\" . | nindent 6 }}\n  template:\n    metadata:\n      {{- with .Values.podAnnotations }}\n      annotations:\n        {{- toYaml . | nindent 8 }}\n      {{- end }}\n      labels:\n        {{- include \"app.selectorLabels\" . | nindent 8 }}\n    spec:\n      {{- with .Values.imagePullSecrets }}\n      imagePullSecrets:\n        {{- toYaml . | nindent 8 }}\n      {{- end }}\n      containers:\n        - name: {{ .Chart.Name }}\n          securityContext:\n            {{- toYaml .Values.securityContext | nindent 12 }}\n          image: \"{{ .Values.image.repository }}:{{ .Values.image.tag | default .Chart.AppVersion }}\"\n          imagePullPolicy: {{ .Values.image.pullPolicy }}\n          envFrom:\n            - configMapRef:\n                name: {{ include \"app.fullname\" . }}-config\n          ports:\n            - name: http\n              containerPort: {{ .Values.containerPort }}\n              protocol: TCP\n          resources:\n            {{- toYaml .Values.resources | nindent 12 }}\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nSTG-Service의 소스 코드는 여기에서 찾을 수 있어요.\n\n# DDS-Service\n\nSTG-Service 이후의 모든 것은 실제로 매우 쉬워집니다. 다른 서비스들도 거의 동일한 구조를 사용하기 때문이죠. DDS-Service의 경우, 모든 클라이언트 정의가 동일합니다. Dockerfile, Docker Compose 및 HELM Chart는 거의 동일합니다. 여기에서 소스 코드를 확인할 수 있어요.\n\n가장 큰 차이점은 데이터 모델링 방식에 있습니다 (Data Vault 2.0을 사용합니다):\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nCREATE SCHEMA IF NOT EXISTS dds;\n\n-- 데이터 보트 --\n-- 허브 --\nCREATE TABLE IF NOT EXISTS dds.h_user (\n    h_user_pk UUID PRIMARY KEY,\n    user_id   VARCHAR NOT NULL UNIQUE,\n    load_dt   TIMESTAMP NOT NULL,\n    load_src  VARCHAR NOT NULL\n);\nCREATE TABLE IF NOT EXISTS dds.h_product (\n    h_product_pk UUID PRIMARY KEY,\n    product_id   VARCHAR NOT NULL UNIQUE,\n    load_dt      TIMESTAMP NOT NULL,\n    load_src     VARCHAR NOT NULL\n);\nCREATE TABLE IF NOT EXISTS dds.h_category (\n    h_category_pk UUID PRIMARY KEY,\n    category_name VARCHAR NOT NULL UNIQUE,\n    load_dt       TIMESTAMP NOT NULL,\n    load_src      VARCHAR NOT NULL\n);\nCREATE TABLE IF NOT EXISTS dds.h_restaurant (\n    h_restaurant_pk UUID PRIMARY KEY,\n    restaurant_id   VARCHAR NOT NULL UNIQUE,\n    load_dt         TIMESTAMP NOT NULL,\n    load_src        VARCHAR NOT NULL\n);\nCREATE TABLE IF NOT EXISTS dds.h_order (\n    h_order_pk UUID PRIMARY KEY,\n    order_id   INTEGER NOT NULL UNIQUE,\n    order_dt   TIMESTAMP NOT NULL,\n    load_dt    TIMESTAMP NOT NULL,\n    load_src   VARCHAR NOT NULL\n);\n-- 훗들 --\nCREATE TABLE IF NOT EXISTS dds.s_user_names (\n    hk_user_names_pk UUID PRIMARY KEY,\n    h_user_pk        UUID NOT NULL UNIQUE REFERENCES dds.h_user (h_user_pk),\n    username         VARCHAR NOT NULL,\n    userlogin        VARCHAR NOT NULL,\n    load_src         VARCHAR NOT NULL,\n    load_dt          TIMESTAMP NOT NULL\n);\nCREATE TABLE IF NOT EXISTS dds.s_product_names (\n    hk_product_names_pk UUID PRIMARY KEY,\n    h_product_pk        UUID NOT NULL UNIQUE REFERENCES dds.h_product (h_product_pk),\n    name                VARCHAR NOT NULL,\n    load_src            VARCHAR NOT NULL,\n    load_dt             TIMESTAMP NOT NULL\n);\nCREATE TABLE IF NOT EXISTS dds.s_restaurant_names (\n    hk_restaurant_names_pk UUID PRIMARY KEY,\n    h_restaurant_pk        UUID NOT NULL UNIQUE REFERENCES dds.h_restaurant (h_restaurant_pk),\n    name                   VARCHAR NOT NULL,\n    load_src               VARCHAR NOT NULL,\n    load_dt                TIMESTAMP NOT NULL\n);\nCREATE TABLE IF NOT EXISTS dds.s_order_cost (\n    hk_order_cost_pk UUID PRIMARY KEY,\n    h_order_pk       UUID NOT NULL UNIQUE REFERENCES dds.h_order (h_order_pk),\n    cost             DECIMAL(19, 5) NOT NULL,\n    payment          DECIMAL(19, 5) NOT NULL,\n    load_src         VARCHAR NOT NULL,\n    load_dt          TIMESTAMP NOT NULL\n);\nCREATE TABLE IF NOT EXISTS dds.s_order_status (\n    hk_order_status_pk UUID PRIMARY KEY,\n    h_order_pk         UUID NOT NULL UNIQUE REFERENCES dds.h_order (h_order_pk),\n    status             VARCHAR NOT NULL,\n    load_src           VARCHAR NOT NULL,\n    load_dt            TIMESTAMP NOT NULL\n);\n-- 링크 --\nCREATE TABLE IF NOT EXISTS dds.l_order_product (\n    hk_order_product_pk UUID PRIMARY KEY,\n    h_order_pk          UUID NOT NULL REFERENCES dds.h_order (h_order_pk),\n    h_product_pk        UUID NOT NULL REFERENCES dds.h_product (h_product_pk),\n    load_src            VARCHAR NOT NULL,\n    load_dt             TIMESTAMP NOT NULL\n);\nCREATE TABLE IF NOT EXISTS dds.l_product_restaurant (\n    hk_product_restaurant_pk UUID PRIMARY KEY,\n    h_restaurant_pk          UUID NOT NULL REFERENCES dds.h_restaurant (h_restaurant_pk),\n    h_product_pk             UUID NOT NULL REFERENCES dds.h_product (h_product_pk),\n    load_src                 VARCHAR NOT NULL,\n    load_dt                  TIMESTAMP NOT NULL\n);\nCREATE TABLE IF NOT EXISTS dds.l_product_category (\n    hk_product_category_pk UUID PRIMARY KEY,\n    h_category_pk          UUID NOT NULL REFERENCES dds.h_category (h_category_pk),\n    h_product_pk           UUID NOT NULL REFERENCES dds.h_product (h_product_pk),\n    load_src               VARCHAR NOT NULL,\n    load_dt                TIMESTAMP NOT NULL\n);\nCREATE TABLE IF NOT EXISTS dds.l_order_user (\n    hk_order_user_pk UUID PRIMARY KEY,\n    h_order_pk       UUID NOT NULL REFERENCES dds.h_order (h_order_pk),\n    h_user_pk        UUID NOT NULL REFERENCES dds.h_user (h_user_pk),\n    load_src         VARCHAR NOT NULL,\n    load_dt          TIMESTAMP NOT NULL\n);\r\n\n우리 DDS-Service의 소스 Kafka 메시지는 STG-Service의 출력 메시지입니다. 또 다른 차이점은 Postgres에 이러한 메시지를 저장하는 방식에 있습니다. 데이터 보트 모델을 사용하므로 약간 복잡해집니다:\n\nimport os\nimport uuid\nfrom datetime import datetime\n\nfrom lib.pg.pg_connect import PgConnect\nfrom psycopg2.extras import execute_batch\n\nclass DdsRepository:\n    def __init__(self, db: PgConnect) -\u003e None:\n        self._db = db\n        self._batch_size = 20\n    def h_user_insert(self, user_id: str) -\u003e None:\n        with self._db.connection() as conn:\n            with conn.cursor() as cur:\n                cur.execute(\"\"\"\n                    INSERT INTO dds.h_user (h_user_pk, user_id, load_dt, load_src) VALUES (%(h_user_pk)s, %(user_id)s, %(load_dt)s, %(load_src)s)\n                    ON CONFLICT (user_id)\n                    DO NOTHING;\n                \"\"\",\n                {\n                    \"h_user_pk\": str(uuid.uuid4()),\n                    \"user_id\": user_id,\n                    \"load_dt\": datetime.now(),\n                    \"load_src\": str(os.getenv('KAFKA_SOURCE_TOPIC') or \"\")\n                })\n    def s_user_names_insert(self, user_id: str, username: str, userlogin: str) -\u003e None:\n        with self._db.connection() as conn:\n            with conn.cursor() as cur:\n                cur.execute(f\"SELECT h_user_pk FROM dds.h_user WHERE user_id = '{user_id}'\")\n                h_user_pk = cur.fetchone()[0]\n                cur.execute(\"\"\"\n                    INSERT INTO dds.s_user_names (hk_user_names_pk, h_user_pk, username, userlogin, load_dt, load_src) VALUES (%(hk_user_names_pk)s, %(h_user_pk)s, %(username)s, %(userlogin)s, %(load_dt)s, %(load_src)s)\n                    ON CONFLICT (h_user_pk)\n                    DO NOTHING;\n                \"\"\",\n                {\n                    \"hk_user_names_pk\": str(uuid.uuid4()),\n                    \"h_user_pk\": h_user_pk,\n                    \"username\": username,\n                    \"userlogin\": userlogin,\n                    \"load_dt\": datetime.now(),\n                    \"load_src\": str(os.getenv('KAFKA_SOURCE_TOPIC') or \"\")\n                })\n    def h_order_insert(self, order_id: str, order_dt: datetime) -\u003e None:\n        with self._db.connection() as conn:\n            with conn.cursor() as cur:\n                cur.execute(\"\"\"\n                    INSERT INTO dds.h_order (h_order_pk, order_id, order_dt, load_dt, load_src) VALUES (%(h_order_pk)s, %(order_id)s, %(order_dt)s, %(load_dt)s, %(load_src)s)\n                    ON CONFLICT (order_id)\n                    DO NOTHING;\n                \"\"\",\n                {\n                    \"h_order_pk\": str(uuid.uuid4()),\n                    \"order_id\": order_id,\n                    \"order_dt\": order_dt,\n                    \"load_dt\": datetime.now(),\n                    \"load_src\": str(os.getenv('KAFKA_SOURCE_TOPIC') or \"\")\n                })\n    def s_order_cost_insert(self, order_id: str, cost: float, payment: float) -\u003e None:\n        with self._db.connection() as conn:\n            with conn.cursor() as cur:\n                cur.execute(f\"SELECT h_order_pk FROM dds.h_order WHERE order_id = '{order_id}'\")\n                h_order_pk = cur.fetchone()[0]\n                cur.execute(\"\"\"\n                    INSERT INTO dds.s_order_cost (hk_order_cost_pk, h_order_pk, cost, payment, load_dt, load_src) VALUES (%(hk_order_cost_pk)s, %(h_order_pk)s, %(cost)s, %(payment)s, %(load_dt)s, %(load_src)s)\n                    ON CONFLICT (h_order_pk)\n                    DO UPDATE SET cost = EXCLUDED.cost,\n                                  payment = EXCLUDED.payment;\n                \"\"\",\n                {\n                    \"hk_order_cost_pk\": str(uuid.uuid4()),\n                    \"h_order_pk\": h_order_pk,\n                    \"cost\": cost,\n                    \"payment\": payment,\n                    \"load_dt\": datetime.now(),\n                    \"load_src\": str(os.getenv('KAFKA_SOURCE_TOPIC') or \"\")\n                })\n    def s_order_status_insert(self, order_id: str, status: str) -\u003e None:\n        with self._db.connection() as conn:\n            with conn.cursor() as cur:\n                cur.execute(f\"SELECT h_order_pk FROM dds.h_order WHERE order_id = '{order_id}'\")\n                h_order_pk = cur.fetchone()[0]\n                cur.execute(\"\"\"\n                    INSERT INTO dds.s_order_status (hk_order_status_pk, h_order_pk, status, load_dt, load_src) VALUES (%(hk_order_status_pk)s, %(h_order_pk)s, %(status)s, %(load_dt)s, %(load_src)s)\n                    ON CONFLICT (h_order_pk)\n                    DO UPDATE SET status=EXCLUDED.status;\n                \"\"\",\n                {\n                    \"hk_order_status_pk\": str(uuid.uuid4()),\n                    \"h_order_pk\": h_order_pk,\n                    \"status\": status,\n                    \"load_dt\": datetime.now(),\n                    \"load_src\": str(os.getenv('KAFKA_SOURCE_TOPIC') or \"\")\n                })\n    def l_order_user_insert(self, user_id: str, order_id:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리는 수신 메시지를 HUB, SATELLITE 및 LINK로 분할합니다 - 이는 우리 데이터 모델의 주요 개체입니다. 또한, 마지막 단계로, 메시지를 출력 Kafka 클러스터로 준비하여 다음 다운스트림 서비스에 전달합니다.\n\napp.py 파일은 기본적으로 동일합니다: 서비스를 백그라운드 작업으로 실행하고 서비스의 상태를 확인하기 위한 간단한 API를 생성합니다.\n\n# CDM-Service\n\n다른 서비스들과 유사하게 작동하며 여기에서 확인할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 스택아데믹 🎓\n\n끝까지 읽어주셔서 감사합니다. 떠나시기 전에:\n\n- 작가를 클랩하고 팔로우해주시면 감사하겠습니다! 👏\n- 저희를 팔로우해주세요: X | LinkedIn | YouTube | Discord\n- 저희 다른 플랫폼도 방문해주세요: In Plain English | CoFeed | Differ\n- 스택아데믹닷컴에서 더 많은 콘텐츠를 만나보세요","ogImage":{"url":"/assets/img/2024-07-09-Real-TimePipelineMicroservicesProjectwithKafkaRedisPostgresandKubernetes_0.png"},"coverImage":"/assets/img/2024-07-09-Real-TimePipelineMicroservicesProjectwithKafkaRedisPostgresandKubernetes_0.png","tag":["Tech"],"readingTime":34},{"title":"시계열 확률 예측을 위한 분위 회귀 방법 ","description":"","date":"2024-07-09 19:41","slug":"2024-07-09-QuantileRegressionforTimeSeriesProbabilisticForecasting","content":"\n\n\n![Quantile Regression for Time Series Probabilistic Forecasting](/assets/img/2024-07-09-QuantileRegressionforTimeSeriesProbabilisticForecasting_0.png)\n\n가끔 우리는 유일한 확실한 것은 불확실함이라는 것을 듣습니다. 우리는 불확실성을 좋아하지 않습니다. \"내일 날씨는 50% 폭염, 50% 허리케인일 것이다\"라는 말을 듣고 싶지 않습니다. 그러나 반대로 불확실성을 양적으로 나타내기 위해 가능한 예측 범위를 요청하기도 합니다. 불확실성 속에서도 확실성을 원하는 건데요. 미래를 위해 계획을 세우는 데 도움을 주기 위해서입니다. 조직의 재정 계획을 수행 중이라고 상상해 봅시다. 두 가지 중 어느 것이 더 나을까요:\n\n- 예상 평균 재정 손실은 4000만 달러이거나\n- 재정 손실이 약 1000만 달러부터 7000만 달러 사이일 것으로 95% 확신하며, 약 4000만 달러 정도일 것입니다. 더불어, 재정 손실이 약 3000만 달러부터 5000만 달러 사이일 것으로 68% 확신합니다.\n\n분위 회귀(Quantile regression)는 이 요구를 충족시킵니다. 분위 회귀는 예측 구간을 제공하며 표시된 것처럼 가능성을 양적으로 나타냅니다. 분위 회귀는 예측 변수와 반응 변수 간의 관계를 모델링하기 위해 사용되는 통계 기법으로, 반응 변수의 조건부 분포가 관심 대상인 경우에 특히 유용합니다. 예측 변수가 주어졌을 때 반응 변수의 조건부 평균을 추정하는 전통적인 회귀 방법(예: 최소 제곱 회귀)과 달리 분위 회귀는 반응 변수의 조건부 분위수를 추정합니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![Quantile Regression for Time Series Probabilistic Forecasting](/assets/img/2024-07-09-QuantileRegressionforTimeSeriesProbabilisticForecasting_1.png)\n\n\"Monte Carlo Simulation for Time Series Probabilistic Forecasts\"에서 몬테카를로 시뮬레이션 기술을 배웠습니다. 양분위 회귀(Quantile regression)가 몬테카를로 시뮬레이션보다 어떤 장점을 가지고 있는지 알아보았습니다. 첫째로, 양분위 회귀는 예측 변수가 주어졌을 때 종속 변수의 조건부 양분위를 직접 추정합니다. 이는 몬테카를로 시뮬레이션에서와 같이 많은 가능한 결과를 생성하는 대신에 양분위 회귀는 종속 변수의 분포의 특정 양분위를 추정해줍니다. 이는 중앙값, 사분위 또는 극단적 양분위에서 예측 불확실성을 이해하는 데 특히 유용할 수 있습니다. 둘째로, 양분위 회귀는 예측 불확실성을 추정하기 위한 모델 기반 접근 방식을 제공합니다. 이는 관찰 데이터를 이용하여 변수 간의 관계를 추정하고, 이 관계를 기반으로 예측을 수행합니다. 반면에 몬테카를로 시뮬레이션은 입력 변수에 대한 확률 분포를 지정하고 무작위 샘플링을 통해 결과를 생성하는 데 의존합니다.\n\nNeuralProphet를 사용하여 시계열 모델을 구축하는 방법을 다음 장(chapter)에서 배웠습니다:\n\n- Chapter 3: Tutorial I: Trend + seasonality + holidays \u0026 events\n- Chapter 4: Tutorial II: Trend + seasonality + holidays \u0026 events + auto-regressive (AR) + lagged regressors + future regressors\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNeural Prophet은 두 가지 통계 기법을 제공합니다: (1) 분위수 회귀 및 (2) 일치 분위수 예측입니다. 일치 분위수 예측 기법은 회귀를 측정하기 위한 보정 프로세스를 추가합니다. 이 장에서는 Neural Prophet의 분위수 회귀 모듈을 실행할 것입니다. 다음 장에서 일치 분위수 예측을 배울 예정입니다. Python 노트북은 이 Github 링크를 통해 다운로드할 수 있습니다.\n\n소프트웨어 요구 사항\n\nNeuralProphet를 설치하기 위해 표준 설치 방법인 pip install NeuralProphet를 따를 것입니다.\n\n```js\n!pip install neuralprophet\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 Google Colab을 사용하는 경우, NeuralProphet은 numpy 1.23.5를 사용하지 않으면 작동하지 않는다는 점 유의해 주세요. numpy를 제거하고 numpy 1.23.5를 설치해야 합니다.\n\n```js\n# neuralprophet은 numpy1.23.5를 사용하지 않으면 Colab에서 작동하지 않습니다: https://github.com/googlecolab/colabtools/issues/3752\n!pip uninstall numpy\n!pip install git+https://github.com/ourownstory/neural_prophet.git numpy==1.23.5\n```\n\n데이터를 로드하고, 몇 가지 도구를 가져와 보겠습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n%matplotlib inline\nfrom matplotlib import pyplot as plt\nimport pandas as pd\nimport numpy as np\nimport logging\nimport warnings\nlogging.getLogger('prophet').setLevel(logging.ERROR)\nwarnings.filterwarnings(\"ignore\")\n```\n\n이전 장에서 소개한 NeuralProphet을 계속 사용할 것입니다. Kaggle의 Bike Share Daily 데이터를 사용할 건데요 (여기나 여기서 다운로드 가능합니다). 이 데이터셋은 매일의 대여 수요와 온도, 풍속 등 다른 기상 정보가 있는 다중 변수 데이터셋입니다.\n\n```js\nfrom google.colab import drive\ndrive.mount('/content/gdrive')\npath = '/content/gdrive/My Drive/data/time_series'\ndata = pd.read_csv(path + '/bike_sharing_daily.csv')\ndata.tail()\n```\n\n\u003cimg src=\"/assets/img/2024-07-09-QuantileRegressionforTimeSeriesProbabilisticForecasting_2.png\" /\u003e\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자전거 대여량을 그래프로 플롯해 봅시다. 두 번째 해에 수요가 증가하고 계절적 패턴이 있는 것을 관찰할 수 있어요.\n\n```js\n# 문자열을 datetime64로 변환하기\ndata[\"ds\"] = pd.to_datetime(data[\"dteday\"])\n\n# 대여량 데이터의 선 그래프 만들기\nplt.plot(data['ds'], data[\"cnt\"])\nplt.xlabel(\"날짜\")\nplt.ylabel(\"수량\")\nplt.show()\n```\n\n![그림](/assets/img/2024-07-09-QuantileRegressionforTimeSeriesProbabilisticForecasting_3.png)\n\n모델링을 위해 매우 기본적인 데이터 준비를 할 거에요. NeuralProphet에서는 칼럼 이름을 “ds”와 “y”로 지정해야 해요. Prophet과 동일하죠.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\ndf = data[['ds','cnt']]\ndf.columns = ['ds','y']\n```\n\n지금부터 NeuralProphet에서 분위 회귀를 구축하러 바로 가봅시다. 5번, 10번, 50번, 90번, 95번 분위의 값을 얻고 싶다고 가정해봅시다. quantile_list = [0.05, 0.1, 0.5, 0.9, 0.95]로 지정하고, quantile_list를 켜려면 \"parameter quantiles = quantile_list\"를 사용합니다. 나머지 매개변수는 Chapter 3: Tutorial I: Trend + seasonality + holidays \u0026 events에서와 동일합니다.\n\n```python\nfrom neuralprophet import NeuralProphet, set_log_level\n\nquantile_list=[0.05,0.1,0.5,0.9,0.95]\n# Model and prediction\nm = NeuralProphet(\n    quantiles=quantile_list,\n    yearly_seasonality=True,\n    weekly_seasonality=True,\n    daily_seasonality=False\n)\nm = m.add_country_holidays(\"US\")\nm.set_plotting_backend(\"matplotlib\")  # Use matplotlib\n\ndf_train, df_test = m.split_df(df, valid_p=0.2)\nmetrics = m.fit(df_train, validation_df=df_test, progress=\"bar\")\nmetrics.tail()\n```\n\n작업이 완료되면 prophet에서 상속받은 .make_future_dataframe()을 사용하여 예측을 위한 새 데이터 프레임을 만들 것입니다. n_historic_predictions 매개변수는 지난 100개 데이터 포인트만 포함하도록 설정됩니다. \"True\"로 설정하면 전체 기록이 포함됩니다. \"periods=50\"를 설정하여 다음 50개 데이터 포인트를 예측합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\n미래 = m.make_future_dataframe(df, periods=50, n_historic_predictions=100) #, n_historic_predictions=1)\n\n# 훈련된 모델로 예측 수행\n예측 = m.predict(df=미래)\n예측.tail(60)\n```\n\n예측값은 \"forecast\" 데이터 프레임에 저장됩니다.\n\n![이미지](/assets/img/2024-07-09-QuantileRegressionforTimeSeriesProbabilisticForecasting_4.png)\n\n위 데이터 프레임은 플로팅을 위한 모든 데이터 요소를 갖고 있습니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nm.plot(\n    forecast, \n    plotting_backend=\"plotly-static\"\n    #plotting_backend = \"matplotlib\"\n)\n```\n\n아래와 같이 플롯이 표시됩니다. 예측 구간은 분위값으로 제공됩니다!\n\n\u003cimg src=\"/assets/img/2024-07-09-QuantileRegressionforTimeSeriesProbabilisticForecasting_5.png\" /\u003e\n\n분위 회귀에 의한 예측 구간과 OLS에 의한 신뢰 구간은 다릅니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예측 구간이 인기를 얻으면, 분위수 회귀와 최소 자승법(OLS)에서의 신뢰 구간의 차이를 구별하는 것이 도움이 될 것입니다. 그림 (F)에서 좌측에는 선형 회귀를 그리고 우측에는 분위수 회귀를 표시했습니다.\n\n![그림](/assets/img/2024-07-09-QuantileRegressionforTimeSeriesProbabilisticForecasting_6.png)\n\n우선, 이들의 목표는 다릅니다:\n\n- 선형 회귀: 주요 목표는 종속 변수의 조건부 평균과 가능한 한 가까운 예측 값을 찾는 것입니다.\n- 분위수 회귀: 목표는 특정 신뢰 수준에서 예상되는 미래 관측값이 위치할 범위를 제공하는 것입니다. 종속 변수 Y의 조건부 분포의 다양한 분위수에서 독립 변수(T) 사이의 관련성을 추정합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음으로, 그들의 계산방법이 다릅니다:\n\n- 선형 회귀에서 신뢰구간은 독립변수의 계수에 대한 구간 추정입니다. 예를 들어 b ± 1.96 * b의 표준 오차(Figure F)와 같이 표시됩니다. 이는 주로 최소 총 거리를 찾기 위해 최소제곱법(OLS)을 사용하여 데이터 포인트와 선 간의 거리를 최소화합니다. 계수가 변할 수 있기 때문에 예측된 조건부 평균값도 변할 수 있습니다. Figure F의 왼쪽 그래프에서, 계수 b가 변하기 때문에 예측된 평균값이 약간씩 다를 수 있습니다.\n- 분위 회귀에서는 종속 변수의 25번째, 50번째 또는 75번째 분위와 같은 분위수 수준을 선택하여 회귀 계수를 추정합니다. 분위 회귀는 일반적으로 절대 편차의 가중 합을 최소화하지만 OLS를 사용하지는 않습니다.\n\n세 번째로, 그들의 응용이 다릅니다:\n\n- 선형 회귀에서는 \"예측된 조건부 평균은 95% 신뢰구간 내에 있다\"라고 말합니다. 신뢰구간은 전체 범위가 아닌 조건부 평균이기 때문에 예측 구간보다 좁습니다.\n- 분위 회귀에서는 \"예측값이 예측 구간의 범위 내에 들어갈 가능성이 95%입니다.\"라고 말합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n결론\n\n이 장에서는 예측 구간을 위한 분위수 회귀의 개념을 배웠습니다. NeuralProphet을 사용하여 예측 구간을 생성하는 방법을 보여주었습니다. 또한 비즈니스 응용 프로그램에서 흔히 혼동되는 예측 구간과 신뢰 구간의 차이를 구별했습니다. 다음 장에서는 예측 불확실성에 대한 다른 중요한 기술인 준수 역분위 회귀(CQR)를 계속 공부할 것입니다.\n\n샘플 eBook 장(무료): [링크](https://github.com/dataman-git/modern-time-series/blob/main/20240522beauty_TOC.pdf)\n\n- 아름다운 형식으로 책을 재현하여 즐거운 독서 경험을 제공해준 The Innovation Press, LLC 직원들에게 감사드립니다. eBook을 분배하기 위해 Teachable 플랫폼을 선택했습니다. 이를 통해 부담스럽지 않은 경비와 전 세계 독자들에게 배포할 수 있었습니다. 신용카드 거래는 Teachable.com에서 기밀이지키며 안전하게 처리됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\neBook on Teachable.com: $22.50\n[링크](https://drdataman.teachable.com/p/home)\n\nThe print edition on Amazon.com: $65 [링크](https://a.co/d/25FVsMx)\n\n- 프린트 판은 광택 처리된 표지, 컬러 출력물, 아름다운 Springer 글꼴 및 레이아웃을 채택하여 즐거운 독서 경험을 제공합니다. 7.5 x 9.25 인치의 크기는 서재에 있는 대부분의 책들과 어울립니다.\n- “이 책은 부오파이의 시계열 분석에 대한 깊은 이해와 예측 분석 및 이상 감지 분야에서의 응용을 검증하는 것입니다. 이 책은 독자들이 실제 세상의 도전 과제에 대처할 수 있는 필수적인 기술을 제공합니다. 데이터 과학으로의 전환을 원하는 사람들에게 특히 가치 있는 자료입니다. 부오파이는 전통적인 기술과 최신 기술 모두에 대해 상세하게 탐구합니다. 부오파이는 신경망 및 기타 고급 알고리즘에 대한 토론을 통합하여 최신 트렌드와 발전 상황을 반영합니다. 이는 독자가 확립된 방법뿐만 아니라 데이터 과학 분야의 가장 최신 및 혁신적인 기술과도 상호작용할 준비가 되어 있는지를 보장합니다. 부오파이의 생생하고 접근 가능한 글쓰기 스타일 때문에 이 책의 명료함과 접근성은 높아졌습니다. 그는 복잡한 수학 및 통계 개념을 풀어내어 엄밀성을 희생하지 않으면서도 접근 가능하게 만들어냅니다.”\n\n# 모던 시계열 예측: 예측 분석 및 이상 감지를 위한\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nChapter 0: 서문\n\nChapter 1: 소개\n\nChapter 2: 비즈니스 예측을 위한 선지자\n\nChapter 3: 튜토리얼 I: 트렌드 + 계절성 + 휴일 및 이벤트\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음은 Markdown 형식으로 변경된 내용입니다:\n\n- Chapter 4: Tutorial II: Trend + seasonality + holidays \u0026 events + auto-regressive (AR) + lagged regressors + future regressors\n\n- Chapter 5: Change Point Detection in Time Series\n\n- Chapter 6: Monte Carlo Simulation for Time Series Probabilistic Forecasting\n\n- Chapter 7: Quantile Regression for Time Series Probabilistic Forecasting\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Chapter 8: 시계열 확률 예측을 위한 조화형 예측\n# Chapter 9: 시계열 확률 예측을 위한 조화화된 분위 회귀\n# Chapter 10: 자동 ARIMA!\n# Chapter 11: 시계열 데이터 형식 만들기 쉽게\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Chapter 12: 다기간 확률 예측을 위한 선형 회귀\n\n## Chapter 13: Tree-based 시계열 모델을 위한 피처 엔지니어링\n\n### Chapter 14: 다기간 시계열 예측을 위한 두 가지 기본 전략\n\n#### Chapter 15: 다기간 시계열 확률 예측을 위한 Tree-based XGB, LightGBM, 및 CatBoost 모델\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 16 장: 시계열 모델링 기법의 진보\n\n# 17 장: 시계열 확률 예측을 위한 딥러닝 기반 DeepAR\n\n# 18 장: 주가에 대한 확률 예측 응용\n\n# 19 장: RNN에서 Transformer 기반 시계열 모델로\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 20장: 해석 가능한 시계열 예측을 위한 시간 퓨전 트랜스포머\n\n# 21장: 시계열 예측을 위한 오픈 소스 Lag-Llama 튜토리얼","ogImage":{"url":"/assets/img/2024-07-09-QuantileRegressionforTimeSeriesProbabilisticForecasting_0.png"},"coverImage":"/assets/img/2024-07-09-QuantileRegressionforTimeSeriesProbabilisticForecasting_0.png","tag":["Tech"],"readingTime":14},{"title":"파이썬과 트랜스포머로 생성형 AI 챗봇 만들기 방법","description":"","date":"2024-07-09 19:40","slug":"2024-07-09-CreatingaGenerativeAIChatbotwithPythonandTransformers","content":"\n\n요즘의 디지털 시대에, 챗봇은 간단한 자동응답 도구에서 복잡하고 맥락을 이해하는 대화를 수행할 수 있는 가상 보조로 진화했습니다. 이 글에서는 파이썬과 허깅페이스의 트랜스포머 라이브러리를 사용하여 생성 모델인 GPT-2와 같은 고급 모델을 활용해 AI 챗봇을 구축하는 방법을 살펴보겠습니다.\n\n# 생성식 AI 챗봇 소개\n\n생성식 AI 챗봇은 인공 지능의 중요한 발전을 나타내며, 기업이 고객 지원을 자동화하고 사용자-시스템 상호작용을 향상시키는 데 기여합니다. 미리 정의된 응답에 제한된 규칙 기반 챗봇과는 달리, 생성식 챗봇은 자연어를 이해하고 생성하는 더 현실적인 대화를 할 수 있습니다.\n\n# 사용된 도구 및 라이브러리\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 프로젝트에서는 다음 도구 및 라이브러리를 활용할 예정입니다:\n\n- Python: 다재다능하고 배우기 쉬운 프로그래밍 언어.\n- Transformers: 사전 학습된 언어 모델 구현을 제공하는 허깅페이스 라이브러리.\n- Flask: Python으로 웹 응용 프로그램을 구축하기 위한 가볍고 효율적인 웹 프레임워크.\n- PyTorch: 인공지능 모델을 훈련하고 평가하는 데 사용되는 머신러닝 라이브러리.\n\n# 단계 1: 환경 설정\n\n시작하기 전에 시스템에 Python과 pip이 설치되어 있는지 확인하세요. 그런 다음 터미널에서 다음 명령을 실행하여 필요한 라이브러리를 설치하세요:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![2024-07-09-CreatingaGenerativeAIChatbotwithPythonandTransformers_0.png](/assets/img/2024-07-09-CreatingaGenerativeAIChatbotwithPythonandTransformers_0.png)\n\n# Step 2: Loading GPT-2 Model and Tokenizer\n\nTo begin, import the required libraries and load the pretrained GPT-2 model and its corresponding tokenizer:\n\n![2024-07-09-CreatingaGenerativeAIChatbotwithPythonandTransformers_1.png](/assets/img/2024-07-09-CreatingaGenerativeAIChatbotwithPythonandTransformers_1.png)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 단계 3: 응답 함수 생성\n\n사용자 입력을 가져와 인코딩하고 GPT-2 모델을 사용하여 응답을 생성하는 함수를 정의하세요:\n\n![image](/assets/img/2024-07-09-CreatingaGenerativeAIChatbotwithPythonandTransformers_2.png)\n\n# 단계 4: Flask 어플리케이션 설정\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음으로 웹 요청을 처리하고 챗봇을 위한 직관적 인터페이스를 제공하기 위해 Flask 애플리케이션을 설정하세요:\n\n![image1](/assets/img/2024-07-09-CreatingaGenerativeAIChatbotwithPythonandTransformers_3.png)\n\n![image2](/assets/img/2024-07-09-CreatingaGenerativeAIChatbotwithPythonandTransformers_4.png)\n\n![image3](/assets/img/2024-07-09-CreatingaGenerativeAIChatbotwithPythonandTransformers_5.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![사진](/assets/img/2024-07-09-CreatingaGenerativeAIChatbotwithPythonandTransformers_6.png)\n\n# 단계 5: Flask 앱 실행 및 상호 작용\n\n챗봇 애플리케이션을 실행하려면:\n\n- 위의 Python 코드를 파일에 저장하세요. 예를 들어, chatbot_app.py로 저장합니다.\n- 터미널이나 명령 프롬프트를 엽니다.\n- chatbot_app.py 파일이 위치한 디렉토리로 이동합니다.\n- Flask 애플리케이션을 시작하려면 다음 명령을 실행하세요:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![Image](/assets/img/2024-07-09-CreatingaGenerativeAIChatbotwithPythonandTransformers_7.png)\n\n- 어플리케이션이 시작되면 웹 브라우저를 열고 챗봇과 상호 작용하기 위해 http://127.0.0.1:5000/ 로 이동하세요.\n\n![Image](/assets/img/2024-07-09-CreatingaGenerativeAIChatbotwithPythonandTransformers_8.png)\n\n![Image](/assets/img/2024-07-09-CreatingaGenerativeAIChatbotwithPythonandTransformers_9.png)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론\n\n생성형 AI 챗봇은 기업과 사용자가 상호 작용하는 방식을 혁신하고 있습니다. Hugging Face의 Transformers와 같은 고급 도구를 활용하면 자연스럽고 맥락 있는 대화를 이어나갈 수 있는 챗봇을 만들 수 있으며, 이는 사용자 경험을 크게 향상시킵니다.","ogImage":{"url":"/assets/img/2024-07-09-CreatingaGenerativeAIChatbotwithPythonandTransformers_0.png"},"coverImage":"/assets/img/2024-07-09-CreatingaGenerativeAIChatbotwithPythonandTransformers_0.png","tag":["Tech"],"readingTime":5},{"title":"진정한 인공지능의 벽에 부딪힌 AGI의 발전 현황","description":"","date":"2024-07-09 19:38","slug":"2024-07-09-ProgresstowardstrueArtificialGeneralIntelligenceAGIhashitawall","content":"\n\n\n![image](/assets/img/2024-07-09-ProgresstowardstrueArtificialGeneralIntelligenceAGIhashitawall_0.png)\n\n인공 일반 지능(AGI)을 향한 탐구는 몇십 년 동안 연구 커뮤니티의 관심을 사로 잡아 왔습니다.\n\nAGI는 인간이 하는 것과 비슷하게 프로그래밍되지 않은 상태에서도 다양한 작업을 수행할 수 있는 AI 시스템의 능력을 나타냅니다. 이는 우리가 학습, 추론 및 새로운 상황에 적응할 수 있는 능력을 갖춘 시스템을 찾고 있다는 것을 의미합니다.\n\n그러나 분야에서 중요한 발전이 있었음에도 불구하고, 대부분의 AI 시스템은 아직도 좁은 작업과 영역에 제한되어 있어 AGI는 여전히 애매한 목표로 남아 있습니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n`\u003ctable\u003e`태그를 Markdown 형식으로 변경해 주세요.\n\n그 이유가 무엇인가요?\n\n# 인공지능이 잘하지 못하는 것\n\nAGI에 대한 주요 장애물 중 하나는 현대 인공지능 시스템이 추론보다는 기억에 의존하고 있다는 것입니다. 우리가 모두 아는 이 시스템들인 Language Large Models (LLMs)는 학습 데이터의 패턴을 암기하고 인접한 맥락에서 적용하는 데 능숙합니다.\n\n하지만 새로운 경우를 바탕으로한 새로운 추론을 생성하는 능력이 부족합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nLLM은 독창적이거나 혁신적인 상황에 기반한 새로운 추론을 생성할 수 없으며 기억에 의존한다는 제한이 있습니다.\n\n또 다른 문제는 AI 시스템이 학습 데이터를 넘어서 일반화할 수 없는 점입니다. 예를 들어, 체스를 하는 방법을 학습한 AI 시스템은 사람들보다 더 잘 체스를 둘 수 있지만, 체커 또는 바둑과 같은 다른 보드 게임에 해당 지식을 전이시키는 것은 불가능합니다.\n\n이러한 일반화 실패는 AGI를 달성하는 데 중요한 장애물이며, 시스템이 새로운 상황에 지식을 적용하는 능력을 제한합니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*_LbxAoOCs7Ed8ThxzsC_eQ.gif)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 새로운 패러다임과 새로운 기준\n\n2019년, Keras의 창시자 인 프랑수아 쇌레(François Chollet)는 2.5백만 명 이상의 개발자가 채택한 오픈 소스 딥 러닝 라이브러리인 Keras의 창시자이자 Google의 소프트웨어 엔지니어 및 AI 연구원으로서, 영향력 있는 논문 \"지능의 측정에 관하여\"을 발표했습니다. 이 논문에서 그는 알려지지 않은 작업에 대한 AI 기술 습득의 효율을 측정하기 위한 기준인 추상화 및 추론 코퍼스(ARC-AGI)를 소개했습니다.\n\n마침내, 모든 좋은 과학이 해야 할 것처럼, 우리는 정의로부터 시작해야 합니다. AGI에 대한 일반적인 합의는 \"경제적 가치가 있는 작업의 대부분을 자동화할 수 있는 시스템\"으로 정의된다는 것입니다. 이것이 유용한 목표로 간주될 수 있지만... 이것은 지능의 부정확한 측정입니다.\n\n보다 지능적이고 인간과 유사한 시스템을 위한 고의적인 진보를 이루기 위해, 우리는 적절한 피드백 신호를 따라야 합니다: 우리는 지능을 정의하고 평가해야 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 기술, 암기 및 지능\n\n기술은 이전 지식과 경험에 크게 영향을 받습니다. 무제한의 사전 지식이나 무제한의 교육 데이터는 개발자들에게 시스템의 기술 수준을 \"구매\"할 수 있는 기회를 제공합니다. 이것은 시스템 자체의 일반화 능력을 가리게 합니다.\n\n현대 인공지능 (LLM)은 뛰어난 암기 엔진으로 입증되었습니다. 그들은 훈련 데이터에서 고차원의 패턴을 기억하고 해당 패턴을 인접한 문맥에 적용할 수 있습니다.\n\n이것은 그들의 겉보기 추론 능력이 작동하는 방식입니다. LLM은 실제로 추론하지 않습니다. 대신, 그들은 추론 패턴을 암기하고 해당 추론 패턴을 인접한 문맥에 적용합니다. 그러나 그들은 새로운 상황에 기반한 새로운 추론을 만들어 내지 못합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지능은 넓거나 일반적인 능력에 있습니다; 훈련 데이터 외에도 새로운 기술을 효율적으로 습득할 수 있는 시스템으로 AGI를 정의하는 방식을 조정해야 합니다. 아니, 더 나아가...\n\n![이미지](/assets/img/2024-07-09-ProgresstowardstrueArtificialGeneralIntelligenceAGIhashitawall_1.png)\n\n# 이러한 종류의 지능을 어떻게 측정할 수 있을까요?\n\n대부분의 AI 벤치마크는 기술을 측정합니다. 하지만 기술은 지능이 아니라는 것을 방금 보았죠?\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2019년 같은 연구에서 탄생한 **인공 일반 지능(AGI)**을 위한 추상화 및 추론 말뭉치 (ARC-AGI)는 AGI의 유일한 공식 벤치마크로 여겨집니다.\n\n**추상화 및 추론 말뭉치(ARC)**는 AI 시스템의 작업 범위에 걸쳐 습득 능률을 테스트하도록 특별히 설계된 벤치마크입니다.\n\n![이미지](/assets/img/2024-07-09-ProgresstowardstrueArtificialGeneralIntelligenceAGIhashitawall_2.png)\n\n이는 추론과 추상화가 필요한 이미지 작업들을 포함한 과제 모음처럼 보입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기에는 명확한 의도가 있습니다. 즉, AI 시스템이 예시로부터 학습하고 그 지식을 새로운, 보지 못한 문제를 해결하는 데 적용할 수 있는 능력을 검증하는 것입니다. 이는 인간과 유사한 지능의 중요한 측면으로, 종종 \"유동적 지능\"이라고 합니다.\n\nARC 벤치마크는 중요한 이유가 있습니다.\n\n- 이는 이러한 추상적 추론을 필요로 하는 작업에 어려움을 겪는 현재의 기계 학습 방법에 도전합니다.\n- 이것은 연구자들이 인간 수준의 지능을 달성하기에 더 가까운 AI 시스템을 개발하는 데 도움이 됩니다.\n\n![이미지](/assets/img/2024-07-09-ProgresstowardstrueArtificialGeneralIntelligenceAGIhashitawall_3.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 다분야 접근\n\n인공 일반 지능(AGI)으로 나아가는 진전이 멈춰있습니다. 엄청나게 방대한 양의 데이터로 훈련된 LLM은 그럼에도 불구하고, 훈련받지 않은 간단한 문제에 적응하거나 새로운 발명을 할 수 없는 상황입니다.\n\nChollet이 만든 2019년 Abstraction and Reasoning Corpus for Artificial General Intelligence (ARC-AGI)는 AGI의 유일한 공식적인 벤치마크입니다.\n\n최근 NYU 교수이자 Meta의 최고 AI 과학자인 야얀 르쿤은 AGI 분야에서 진전하려면 LLM에 집중해서는 안된다고 공개적으로 언급했습니다...\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/assets/img/2024-07-09-ProgresstowardstrueArtificialGeneralIntelligenceAGIhashitawall_4.png)\n\n저는 이 도발을 좋아하고, 모든 AI 연구자가 이 도전에 대해 잘 알고 있다고 믿습니다. 대학 연구자들이 이 분야에서 몇 발자국 앞서 나가야 한다고 생각합니다. 학계는 보통 문제에 대해 다학제적 접근에 숙달되어 있지만, 그들은 자금과 컴퓨팅 파워 등 자원이 부족합니다.\n\n그러나 현재 AI 연구의 추세는 소스코드를 공개하지 않는 연구 방향으로 이동하고 있어서 아이디어와 지식의 공유를 제한하고 있습니다. 이 추세는 \"스케일만 있으면 충분하다\"는 믿음과 경쟁 우위를 보호하려는 욕심에서 나온 것이죠. 이 방식은 혁신을 억불하며 AGI로의 진전속도를 제한합니다.\n\n언제나 예외는 있습니다...\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n오픈 소스 연구는 협력과 지식 공유를 촉진하여 AGI로의 진전 속도를 가속화합니다. 연구를 공개로 접근 가능하게 함으로써 전 세계의 연구자들이 더 지능적인 AI 시스템의 개발에 기여할 수 있으며, 다양한 시각에서 새로운 아이디어와 혁신이 탄생할 수 있습니다.\n\nAI 연구에서의 투명성 부족과 협력은 AGI가 임박했다는 오도된 인식에 기여하고 있으며, 이는 AI 규제 환경에 영향을 미치고 있습니다. 규제 당국은 AGI가 임박했다는 잘못된 가정 하에 길잡이 AI 연구에 대한 장애물을 고려하고 있습니다.\n\n오픈 소스 연구는 더 지능적인 AI 시스템의 개발을 이끌어주고 일반 지능의 더 정확한 측정 지표를 제공할 수 있습니다.\n\nARC Challenge는 대규모 경쟁을 진행하는 역사가 있으며, 2020년 Kaggle에서 시작된 첫 번째 ARC-AGI 대회를 시작으로 2022년과 2023년에는 ARCathon이 열렸으며, 가장 최근에는 상금 총액이 1.1백만달러가 넘는 ARC Prize 2024가 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![2024-07-09-ProgresstowardstrueArtificialGeneralIntelligenceAGIhashitawall_5.png](/assets/img/2024-07-09-ProgresstowardstrueArtificialGeneralIntelligenceAGIhashitawall_5.png)\n\n# 결론…\n\nAGI를 위한 탐험은 복잡하고 도전적인 목표이지만 불가능한 것은 아닙니다.\n\n현대 AI의 제한을 극복하고 AGI를 준비하기 위해, 우리는 오픈소스 연구의 적극적 지지자가 되어야 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하지만 그보다 중요한 것은 우리가 어떤 지적인 것이란 것에 대한 오픈 토론의 일부가 되어야 한다는 것입니다. 다양한 분야의 시각에서 바라봤을 때 어떤 지능인지에 대한 토론을 펼쳐야 합니다.\n\n그렇게 함으로써 누구라도 프로그래밍 전문가가 아니더라도 더 지적인 AI 시스템의 개발에 기여할 수 있게 되어 AGI로의 발전속도를 높일 수 있습니다.\n\n만약 이 이야기가 가치있었다면 조금이라도 지원을 보여주고 싶다면 다음과 같은 방법을 사용할 수 있습니다:\n\n- 이 이야기에 대해 많이 박수를 치기\n- 기억하기에 더 중요한 부분을 강조하기 (나중에 그것들을 찾는 데 더 편리하고 나에게는 더 나은 기사를 쓸 수 있습니다)\n- '자체 AI 구축하기' 시작하는 방법 배우기, 무료 eBook 다운로드하기\n- 저를 Medium에서 팔로우하기\n- 내 최신 기사 읽기 https://medium.com/@fabio.matricardi\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자료 및 참고 자료:\n\n![Generative AI](/assets/img/2024-07-09-ProgresstowardstrueArtificialGeneralIntelligenceAGIhashitawall_6.png)\n\n이 이야기는 Generative AI에서 게시되었습니다. LinkedIn에서 저희와 연락을 유지하고 최신 AI 이야기에 대해 최신 정보를 얻으려면 Zeniteq를 팔로우하세요.\n\n저희의 뉴스레터를 구독하여 generative AI의 최신 뉴스와 업데이트를 받아보세요. 함께 AI의 미래를 함께 만들어가요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![Image](/assets/img/2024-07-09-ProgresstowardstrueArtificialGeneralIntelligenceAGIhashitawall_7.png)\n","ogImage":{"url":"/assets/img/2024-07-09-ProgresstowardstrueArtificialGeneralIntelligenceAGIhashitawall_0.png"},"coverImage":"/assets/img/2024-07-09-ProgresstowardstrueArtificialGeneralIntelligenceAGIhashitawall_0.png","tag":["Tech"],"readingTime":10},{"title":"여러 기간의 시계열 확률 예측을 위한 XGB, LightGBM, CatBoost 모델 비교 분석","description":"","date":"2024-07-09 19:34","slug":"2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting","content":"\n\n\n![Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting](/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_0.png)\n\nSample eBook chapters (free): [https://github.com/dataman-git/modern-time-series/blob/main/20240522beauty_TOC.pdf](https://github.com/dataman-git/modern-time-series/blob/main/20240522beauty_TOC.pdf)\n\neBook on Teachable.com: $22.50 [https://drdataman.teachable.com/p/home](https://drdataman.teachable.com/p/home)\n\nThe print edition on Amazon.com: $65 [https://a.co/d/25FVsMx](https://a.co/d/25FVsMx)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 텍스트를 친근하게 번역하면 아래와 같습니다.\n\n챕터 제목은 \"확률 예측\", \"다기간\", \"트리 기반\" 세 가지 중요한 개념을 다룹니다. 첫 번째로 \"확률 예측\"이 있습니다. 많은 실세계 응용 프로그램에서는 자원 계획이나 이상 징후 감지를 위해 예측 구간을 요청하며, 이는 1장에서 언급한 것과 같습니다. 이 책의 Part 2에서 언급한 네 가지 해결책 중 하나는 분위수 회귀입니다. 분위 예측은 예측 값을 매우 가능성이 높은 50 번째 백분위 값이거나 상위 90 번째 백분위 값과 같이 매우 낮은 가능성을 보여줍니다 (A) 그림에서 확인할 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_1.png\" /\u003e\n\n제목에서 두 번째 개념은 다기간 예측입니다. 우리는 일일 예측이 아닌 여러 기간을 위한 예측이 필요한 경우가 많습니다. 한 주간 휴가를 계획할 때, 한 날이 아닌 5일간의 날씨 예보가 필요합니다. 그러나 선형 회귀 또는 트리 기반 알고리즘은 일반적으로 점 추정만 제공합니다. 이러한 경우 어떻게 예측 프로세스를 설계하여 다기간을 제공할 수 있을까요? 직관적으로, 다음 기간을 예측하면 동일한 모델의 입력으로 사용하여 다다음 기간을 예측할 수도 있지 않을까요? 이 해결책은 인기가 있으며 (B) 그림에서 보이는 것과 같이 재귀적 예측 전략이라고 합니다. 재귀적 예측 전략은 모델의 예측을 후속 예측의 입력으로 사용합니다. 전략은 모델이 1 단계 앞으로 예측하기 위해 yt에서 yt-k까지의 과거 값을 사용합니다. 그런 다음 yt+1을 통합하고 다른 입력을 업데이트하여 yt+2를 예측합니다. 이 프로세스를 반복하여 모든 후속 시간 단계를 예측합니다. Darts 라이브러리에서도 이 전략을 할당할 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_2.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n새로운 시각으로 생각해보는 건 어때요? n 기간을 예측하는 것이 목표인 경우, 왜 n 개의 모델을 따로 구축하지 않을까요? 각 모델은 각각의 다음 n 기간을 예측할 것입니다. 이는 직접 예측 전략이라고 불립니다. Darts 라이브러리의 기본 전략이며, 라이브러리에 포함된 모든 모델에 대해 적용됩니다.\n\n![이미지](/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_3.png)\n\n마지막으로, 장 제목에 있는 \"tree-based\"에 대해 논의해보겠습니다. Tree-based 알고리즘들은 지도 학습 알고리즘입니다. 샘플을 행으로, 피처를 열로 갖는 데이터 프레임이 필요합니다. 단변량 시계열 데이터를 데이터 프레임으로 어떻게 변환할까요? 기본 아이디어는 단변량 시계열 데이터에서 샘플을 생성하는 것입니다. 이렇게 함으로써, 모델링을 위해 단변량 시계열 데이터를 데이터 프레임으로 재구성하고, 원하는 경우 단변량 시계열 데이터에서 피처를 생성할 수도 있습니다.\n\n이번 장에서는 세 가지 tree-based 모델인 XGBoost (2016), LightGBM (2017), CatBoost (2018)에 대해 세 부분으로 소개하고, 각 알고리즘에 대해 간단히 설명할 것입니다. 세 모델 간의 차이점에 대해 궁금하다면, Figure (C)에 각 세 그래디언트 부스팅 기반 알고리즘의 특징을 강조한 표를 만들었습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_4.png)\n\n이번 장에서는 Darts 라이브러리를 사용할 것입니다. 시계열 모델링은 많은 기능과 데이터를 저장해야 하므로 Darts 라이브러리는 자체 데이터 형식을 갖추고 있습니다. 시간 순서에 풍부한 정보를 담을 수 있는 다양한 데이터 형식의 장점을 설명하기 위해 본 책은 '10장: 시계열 데이터 형식 쉽게 만들기'를 별도로 마련했습니다. 마지막으로, 이 장은 '11장: 다기간 확률 예측을 위한 자기회귀 선형 회귀'와 함께 읽을 수 있습니다. 두 장은 프로젝트에 적합한 모델을 선택하기 위해 선형 회귀 및 트리 기반 모델을 구축하는 데 도움이 됩니다.\n\n이 장의 구조는 다음과 같습니다:\n\n- 필요한 소프트웨어 요구 사항\n- 판다스 데이터를 Darts 데이터 형식으로 변환하는 방법\n- XGB\n- LightGBM\n- CatBoost\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파이썬 노트북은 이 Github 링크를 통해 다운로드할 수 있어요.\n\n소프트웨어 요구 사항\n\n기본 Darts 패키지는 Prophet, CatBoost, 그리고 LightGBM 종속성을 설치하지 않습니다. 0.25.0 버전을 기준으로 해서요. 직접 Prophet, CatBoost, 그리고 LightGBM 패키지를 설치해야 해요.\n\n- CatBoostModel: CatBoost 설치 가이드를 사용하여 catboost 패키지(버전 1.0.6 이상)를 설치합니다.\n- LightGBMModel: LightGBM 설치 가이드를 사용하여 lightgbm 패키지(버전 3.2.0 이상)를 설치합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n!pip install pandas numpy matplotlib darts lightgbm catboost\n```\n\n다음으로, 동일한 Walmart 매장 판매 데이터를 로드할 것입니다.\n\n데이터\n\n저는 Kaggle.com에 있는 Walmart 데이터셋을 사용할 것입니다. 이 데이터셋은 2010년 2월 5일부터 2012년 11월 1일까지의 주간 매장 매출 정보를 포함하고 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Date - 판매 주차\n- Store - 상점 번호\n- 주간 매출 - 상점의 매출\n- 휴일 플래그 - 주가 특별 휴일 주인지 여부 1 - 휴일 주 0 - 비 휴일 주\n- 온도 - 판매일 온도\n- 연료 가격 - 지역의 연료 비용\n\n소매 판매에 영향을 미칠 수있는 두 가지 거시경제 지표 : 소비자 물가지수와 실업률. 데이터 세트는 Pandas 데이터 프레임으로로드됩니다.\n\n```js\n%matplotlib inline\nimport pandas as pd\nimport numpy as np\nfrom matplotlib import pyplot as plt\n\n# Google Colab\nfrom google.colab import drive\ndrive.mount('/content/gdrive')\npath = '/content/gdrive/My Drive/data/time_series'\n# https://www.kaggle.com/datasets/yasserh/walmart-dataset\n\n# 데이터 로드\ndata = pd.read_csv(path + '/walmart.csv', delimiter=\",\")\ndata['ds'] = pd.to_datetime(data['Date'], format='%d-%m-%Y')\ndata.index = data['ds']\ndata = data.drop('Date', axis=1)\ndata.head()\n```\n\n\u003cimg src=\"/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_5.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n제 10 장에서 쉽게 만들어진 Darts의 시계열 데이터 형식에 대해 배웠어요. Darts의 주요 데이터 클래스는 \"TimeSeries\" 클래스입니다. Darts는 값들을 다음과 같은 배열 모양으로 저장해요 (시간, 차원, 샘플):\n\n- 시간: 위 예시에서처럼 143 주와 같은 시간 인덱스\n- 차원: 다변량 시계열의 \"열\"\n- 샘플: 기간에 대한 값들. 10 번째, 50 번째 백분위수와 90 번째 백분위수에 대한 그림 (A)에서처럼 확률론적 예측이라면 3개의 샘플이 있을 거예요.\n\n저희는 월마트 매장 판매량을 불러오기 위해 .from_group_dataframe() 함수를 사용할 거예요. 그룹 ID는 \"Store\"예요. 따라서 group_cols 매개변수는 \"Store\"가 될 거예요. 시간 인덱스는 \"ds\" 열이에요.\n\n```js\nfrom darts import TimeSeries\ndarts_group_df = TimeSeries.from_group_dataframe(data, group_cols='Store', time_col='ds')\nprint(\"그룹/매장의 수는:\", len(darts_group_df))\nprint(\"시간 기간의 수는: \", len(darts_group_df[0]))\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 그룹/상점 수: 45\n- 기간 수: 143\n\n다음과 같이 컬럼을 나열할 수 있습니다. components 함수를 사용해봅시다:\n\n```js\ndarts_group_df[0].components\n```\n\nIndex(['Weekly_Sales', 'Holiday_Flag', 'Temperature', 'Fuel_Price', 'CPI', 'Unemployment'], dtype='object', name='component')\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nStore 1 매출 모델을 구축하기 위해 Store 1 데이터만 사용할 겁니다. \"darts_group_df[0]\"에 해당합니다. 이를 훈련 데이터와 테스트 데이터로 나눌 겁니다.\n\n```js\nstore1 = darts_group_df[0]\ntrain = store1[:130]\ntest = store1[130:]\nlen(train), len(test) # (130, 13)\n```\n\n우리의 목표 시리즈는 \"Weekly_Sales\"입니다. 다른 공선변수를 포함할 수도 있습니다. 시계열에서는 과거 공선변수와 미래 공선변수 두 종류가 있습니다. Darts 라이브러리는 동일한 용어를 사용합니다. 과거 공선변수는 연구 현재 시간까지의 변수입니다. 미래 공선변수는 미래에 관측 가능한 변수입니다. 미래 값을 어떻게 알 수 있는지 궁금할 수도 있습니다. 첫 번째 이유는 미래 휴일과 같이 결정론적 값이기 때문입니다. 두 번째 이유는 날씨 예측과 같은 다른 소스에서 예측된 값이기 때문입니다. 우리의 경우 \"Fuel_price\"와 \"CPI\"를 과거 공선변수로, \"Holiday_flag\"를 미래 공선변수로 포함할 것입니다. 훈련 데이터에서의 목표와 과거 공선변수는 130개의 데이터 포인트가 있습니다. 하지만 미래 공선변수는 실제로 미래까지 확장되어 143개의 데이터 포인트를 갖습니다.\n\n```js\ntarget = train['Weekly_Sales']\npast_cov = train[['Fuel_Price','CPI']]\nfuture_cov = store1['Holiday_Flag'][:143]\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우니바리에이트 데이터부터 시작해보겠습니다.\n\nXGB\n\nXGBoost (Extreme Gradient Boosting)은 분류 및 회귀와 같은 지도 학습 작업에 널리 사용되며 효율성, 확장성 및 정확도로 알려져 있습니다. 가장 주목할 만한 기능은 오버피팅을 방지하기 위해 L1 및 L2 규제 기술이 포함되어 있다는 점입니다. 규제 패널티는 트리의 가중치, 리프 노드 값, 특성 중요도 점수에 적용되어 일반화 성능을 향상시키는 데 도움을 줍니다. 또 다른 기능으로는 병렬 및 분산 컴퓨팅을 지원하며 멀티코어 CPU 및 Apache Spark 및 Dask와 같은 분산 컴퓨팅 프레임워크에서 효율적인 학습이 가능합니다. 이 확장성은 대규모 데이터 처리에 적합하게 만듭니다. 그 외에도 이전 모델이 실수한 오류를 수정하기 위해 각 트리가 순차적으로 훈련되는 경사 부스팅 프레임워크를 계승했습니다. 전체적인 목표는 특정 손실 함수를 최소화하는 것입니다.\n\n다음 코드는 Darts의 표준 모델링 구문입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nfrom darts.models import XGBModel\nn = 12\nchunk_length = n\nmodel = XGBModel(\n    lags=12,\n    lags_past_covariates=12,\n    lags_future_covariates=[0,1,2,3,4,5],\n    output_chunk_length=12,\n    Multi_models = True # optional\n    verbose=-1\n)\nmodel.fit(target, past_covariates=past_cov, future_covariates=future_cov)\npred = model.predict(n)\npred\n```\n\nfit() 함수의 \"target\"은 모델링을 위한 대상 시리즈입니다. 모델은 yt, yt-1, yt-2, ..., yt-12까지의 지연된 값들에 대한 \"lags\"를 필요로 합니다. 또한 다른 공변량을 지정할 수도 있습니다. 시계열 모델링에서 과거 공변량과 미래 공변량이라는 두 가지 넓은 유형의 공변량이 있습니다. Darts는 이 규칙을 따릅니다. lags_past_covariates는 xt, xt-1, ..., xt-12와 같이 지연된 과거 공변량을 나타냅니다. 약간 혼동스러운 lags_future_covariates 이름은 미래 공변량을 의미합니다. \"미래 공변량\"은 미래 시간 단계에서의 이러한 공변량의 값들을 의미하며, \"지연된\" 값들은 이전 시간 단계에서의 미래 공변량을 의미합니다. 이는 미래 t + n 단계에 대해 모델이 t부터 t + (n-1)까지의 공변량의 값을 고려한다는 것을 의미합니다.\n\nmulti_models 매개변수가 True로 설정된 것에 주목해주세요. 이는 모델에게 다중 기간 예측을 위한 직접 예측 전략 또는 재귀적 예측 전략을 사용할지 알려줍니다. 기본값은 True이며, 이는 직접 예측 전략을 사용한다는 것을 의미합니다.\n\n입력 청크 길이와 출력 청크 길이에 관한 한 가지 추가적인 매개변수가 있습니다. 이는 단변량 시리즈에서 샘플을 생성하는 것과 관련이 있습니다. 그림 (F)는 y0에서 y15까지의 시리즈에서 생성된 샘플을 보여줍니다. 각 샘플에는 입력 청크와 출력 청크가 포함되어 있습니다. 입력 청크 길이가 5이고 출력 청크 길이가 2인 것을 가정해보세요. 첫 번째 샘플은 입력 청크로 y0 - y4를, 출력 청크로 y5, y6를 가지고 있습니다. 창이 시리즈를 따라 이동하여 샘플을 만들며, 이를 시리즈의 끝까지 반복합니다. 출력 청크 길이는 예측할 수 있는 가장 긴 길이를 정의합니다. 이를 12로 지정했습니다. 12 이상을 예측하려고 하면 오류 메시지가 출력됩니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![Dart data array](/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_6.png)\n\nThe outputs are stored in the Dart data array:\n\n![Dart data array](/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_7.png)\n\nWe will plot the actual and the predicted values. We make this in a function for repeating use.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\ndef plotit():\n  import matplotlib.pyplot as plt\n  target.plot(label='train')\n  pred.plot(label='prediction')\n  test['Weekly_Sales'][:n].plot(label='actual')\n\n  from darts.metrics.metrics import mae, mape\n  print(\"Mean Absolute Error:\", mae(test['Weekly_Sales'][:n], pred))\n  print(\"Mean Absolute Percentage Error\", mape(test['Weekly_Sales'][:n], pred))\n\nplotit()\n```\n\nMAPE 값은 10.55% 입니다.\n\n![이미지](/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_8.png)\n\n이제 분위수 예측을 추가해보겠습니다. 모델에게 5개의 분위수를 생성해 달라고 요청하겠습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nfrom darts.models import XGBModel\nn = 12\nchunk_length = n\nmodel = XGBModel(\n    lags=12,\n    lags_past_covariates=12,\n    lags_future_covariates=[0,1,2,3,4,5,6,7,8,9,10,11,12],\n    output_chunk_length=chunk_length,\n    likelihood = 'quantile', # 'quantile' 또는 'poisson'으로 설정 가능합니다.\n    # 'quantile'로 설정하면 sklearn.linear_model.QuantileRegressor가 사용됩니다.\n    # 'poisson'으로 설정하면 sklearn.linear_model.PoissonRegressor가 사용됩니다.\n    quantiles=[0.01, 0.05, 0.50, 0.95, 0.99]\n)\nmodel.fit(target, past_covariates=past_cov, future_covariates=future_cov)\npred = model.predict(n, num_samples=5)\npred\n```\n\n각 예측에는 5개의 샘플이 있습니다. 이는 5개의 분위 수치 값을 생성했기 때문입니다.\n\n![](/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_9.png)\n\n실제 값과 분위 예측을 시각화할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ndef plotQuantile():\n    import matplotlib.pyplot as plt\n    target.plot(label = 'train')\n    pred.plot(label = 'prediction')\n    test['Weekly_Sales'][:n].plot(label = 'actual')\n\nplotQuantile()\n```\n\n양자 예측은 다음과 같습니다:\n\n![그림](/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_10.png)\n\n모델을 구축하고 예측을 제공하는 것이 매우 쉽다는 것을 발견할 수 있을 것 입니다. 계속해서 LightGBM 모델을 구축해 봅시다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nLightGBM\n\n\"제 12장: Tree-based Time Series Models의 Feature Engineering\"에서 lightGBM 모델을 구축한 적이 있지 않았나요? 정말이죠! 다른 점은 여기서는 Darts 라이브러리를 사용하여 lightGBM 모델을 구축할 것이라는 점입니다. 이전 장에서의 데이터 형식은 Pandas 데이터 프레임이었지만, 여기서는 Darts 데이터 object입니다. 그럼에도 불구하고 LightGBM이 무엇인지 설명해보겠습니다.\n\nLightGBM (Light Gradient Boosting Machine)은 gradient-boosting 결정 트리 모델의 효율적이고 확장 가능한 학습을 위해 설계되었습니다. LightGBM은 빠른 속도, 메모리 효율성, 정확성으로 인해 인기를 얻었습니다. 그 중요한 특징은 다른 gradient-boosting 구현에서 사용되는 전통적인 수준별 전략이 아니라 잎별 성장 전략을 채택한다는 것입니다. 이 전략은 손실을 가장 효과적으로 최소화할 잎 노드를 선택하여 더 빠른 학습 시간을 제공합니다. 그 외에도 그래디언트 부스팅 알고리즘을 여전히 구현합니다.\n\n```js\nfrom darts.models import LightGBMModel\nn = 12\nmodel = LightGBMModel(\n    lags=12,\n    lags_past_covariates=12,\n    lags_future_covariates=[0,1,2,3,4,5],\n    output_chunk_length=12,\n    verbose=-1\n)\nmodel.fit(target, past_covariates=past_cov, future_covariates=future_cov)\npred = model.predict(n)\npred.values()\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 코드는 XGB와 유사하여 더 이상 강조하지 않겠습니다. 그래프를 그려 성능 메트릭을 살펴봅시다:\n\n```js\nplotit()\n```\n\nMAPE는 5.09%입니다.\n\n![이미지](/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_11.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 분위 예측을 포함해 봅시다.\n\n```js\nn = 12\nchunk_length = n\nmodel = LightGBMModel(\n    lags=12,\n    lags_past_covariates=12,\n    lags_future_covariates=[0,1,2,3,4,5,6,7,8,9,10,11,12],\n    output_chunk_length=chunk_length,\n    likelihood = 'quantile', # quantile 또는 poisson 으로 설정할 수 있습니다.\n    # quantile로 설정하면 sklearn.linear_model.QuantileRegressor가 사용됩니다.\n    # poisson으로 설정하면 sklearn.linear_model.PoissonRegressor가 사용됩니다.\n    quantiles=[0.01, 0.05, 0.50, 0.95, 0.99]\n)\nmodel.fit(target, past_covariates=past_cov, future_covariates=future_cov)\npred = model.predict(n, num_samples=5)\npred\n```\n\n분위 예측을 그래프로 확인해볼 수 있습니다.\n\n```js\nplotQuantile()\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n양자수치 예측값은:\n\n![image](/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_12.png)\n\n좋아요. 이미 두 개의 모델이 구축되었습니다. 이제 CatBoost 모델을 구축해봅시다.\n\nCatBoost\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nCatBoost은 \"Category Boosting\"의 약자입니다. 범주형 기능을 효율적으로 처리할 수 있도록 특별히 설계되었으므로 다양한 분류 및 회귀 작업에 적합합니다. 이는 원-핫 인코딩과 같은 전처리가 필요 없이 범주형 기능을 직접 처리할 수 있습니다. CatBoost는 카테고리별 통계 속성에 기초하여 최적 분할점을 찾아 효율적으로 범주형 변수를 처리하는 Ordered Boosting이라는 새로운 알고리즘을 사용합니다. 이외에도 결정 트리 앙상블을 구축하기 위해 그래디언트 부스팅의 구현을 상속받습니다. 각 트리는 이전 모델의 오류를 최소화하도록 학습됩니다. 최적 매개변수를 찾기 위해 그래디언트 강하 최적화 알고리즘을 사용합니다.\n\n```js\nfrom darts.models import CatBoostModel\nn = 12\nchunk_length = n\nmodel = CatBoostModel(\n    lags=12,\n    lags_past_covariates=12,\n    lags_future_covariates=[0,1,2,3,4,5],\n    output_chunk_length=12,\n    verbose=-1\n)\nmodel.fit(target, past_covariates=past_cov, future_covariates=future_cov)\npred = model.predict(n)\npred\n```\n\n위 코드에 CatBoostModel을 삽입하여 내용을 그대로 유지하시면 됩니다.\n\n결과를 그래프로 출력해보겠습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nplotit()\n```\n\nMAPE는 5.96% 입니다.\n\n![이미지](/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_13.png)\n\n모델에 분위 예측을 포함해 봅시다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\r\nn = 12\nchunk_length = n\nmodel = CatBoostModel(\r\n    lags=12,\r\n    lags_past_covariates=12,\r\n    lags_future_covariates=[0,1,2,3,4,5,6,7,8,9,10,11,12],\r\n    output_chunk_length=chunk_length,\r\n    likelihood = 'quantile', # 'quantile' 또는 'poisson'으로 설정할 수 있습니다.\r\n    # 'quantile'로 설정하면 sklearn.linear_model.QuantileRegressor가 사용됩니다.\r\n    # 'poisson'으로 설정하면 sklearn.linear_model.PoissonRegressor가 사용됩니다.\r\n    quantiles=[0.01, 0.05, 0.50, 0.95,0.99]\r\n)\nmodel.fit(target, past_covariates=past_cov, future_covariates=future_cov)\r\npred = model.predict(n, num_samples=5)\r\npred\r\n```\r\n\r\n양자화 예측값을 그릴 수 있습니다.\r\n\r\n```js\r\nplotQuantile()\r\n```\r\n\r\n이 차트는 다음과 같습니다.\r\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Tree-based Models](/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_14.png)\n\n결론\n\n이 장에서는 Darts 라이브러리를 사용하여 세 가지 인기있는 트리 기반 시계열 모델을 구축했습니다. 우리는 다기간 예측 및 예측 불확실성의 사용 사례에 중점을 두었습니다. 다음에 시계열 모델을 구축하여 다기간 예측 및 예측 불확실성을 제공해야 할 때, 세 가지 트리 기반 모델과 다기간 확률적 예측을 위한 자동 회귀 선형 회귀 모델을 함께 생성하는 것을 권장합니다. 우승 모델을 찾기 위해 11 장에서 선형 회귀 모델과 결합하여 사용할 수 있습니다.\n\n이 장은 트리 기반 시계열 모델에 대한 현대적 기법 시리즈를 마무리합니다. 다음 장에서는 딥러닝 기반 시계열 모델에 대한 시리즈를 시작할 것입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 시계열 모델링 기법의 진화\n- RNN/LSTM용 DeepAR\n- 응용 - 주식 가격에 대한 확률 예측\n\n참고문헌\n\n- (XGB) Chen, T., \u0026 Guestrin, C. (2016). XGBoost: A Scalable Tree Boosting System. In Proceedings of the 22nd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining (pp. 785–794). ACM. [링크](https://dl.acm.org/doi/10.1145/2939672.2939785)\n- (LightGBM) Ke, G., Meng, Q., Finley, T., Wang, T., Chen, W., Ma, W., … \u0026 Li, Q. (2017). LightGBM: A Highly Efficient Gradient Boosting Decision Tree. In Advances in Neural Information Processing Systems (pp. 3146–3154). [링크](https://proceedings.neurips.cc/paper/2017/file/6449f44a102fde848669bdd9eb6b76fa-Paper.pdf)\n- (CatBoost) Prokhorenkova, L., Gusev, G., Vorobev, A., Dorogush, A. V., \u0026 Gulin, A. (2018). CatBoost: unbiased boosting with categorical features. In Advances in Neural Information Processing Systems (pp. 6638–6648). [링크](https://proceedings.neurips.cc/paper/2018/file/0d4724e4525b451dae9f6cb39983e6cd-Paper.pdf)\n\n샘플 eBook 챕터 (무료): [링크](https://github.com/dataman-git/modern-time-series/blob/main/20240522beauty_TOC.pdf)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- The Innovation Press, LLC의 직원들께서 아름다운 형식으로 책을 재구성해 주어 즐거운 독서 경험을 선사했습니다. 전 세계 독자들에게 복잡한 유지보수비 없이 eBook을 배포하기 위해 Teachable 플랫폼을 선택했습니다. 신용카드 거래는 Teachable.com에 의해 기밀리에 안전하게 관리됩니다.\n\nTeachable.com에서의 eBook: $22.50\nhttps://drdataman.teachable.com/p/home\n\nAmazon.com에서의 인쇄판: $65 https://a.co/d/25FVsMx\n\n- 인쇄판은 윤광 표지, 컬러 인쇄, 아름다운 Springer 글꼴과 레이아웃을 사용하여 즐거운 독서를 위해 디자인되었습니다. 7.5 x 9.25 인치의 크기는 책장의 대부분 책들과 잘 어울립니다.\n- “이 책은 과거 시계열 분석 및 예측 분석, 이상 징후 탐지 등의 응용에 대한 깊은 이해력을 갖춘 쿠오의 증명서입니다. 이 책은 독자들에게 실세계의 도전 과제에 대처하는 데 필요한 기술을 제공합니다. 데이터 과학으로의 전직을 고려하는 분들에게 특히 가치 있습니다. 쿠오는 전통적이고 최첨단 기술 모두에 대해 상세히 탐구합니다. 쿠오는 신경망 및 다른 고급 알고리즘에 대한 토론을 통합하여 최신 동향과 발전을 반영합니다. 이는 독자들이 확립된 방법뿐만 아니라 데이터 과학 분야의 가장 최신이며 혁신적인 기술과 상호작용할 수 있도록 준비되어 있다는 것을 보장합니다. 쿠오의 생동감 넘치는 글쓰기 스타일로 이 책의 명확함과 접근성이 향상되었습니다. 그는 복잡한 수학적 및 통계적 개념을 실용적으로 만들어내며 엄격함을 희생하지 않고 다가갈 수 있게 만듭니다.”\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 현대 시계열 예측: 예측 분석과 이상 감지\n\n제로 장: 서문\n\n1장: 소개\n\n2장: 비즈니스 예측을 위한 예언자\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### Chapter 3: 튜토리얼 1 - 추세 + 계절성 + 휴일 및 이벤트\n\n### Chapter 4: 튜토리얼 2 - 추세 + 계절성 + 휴일 및 이벤트 + 자기회귀(AR) + 지연 회귀 변수 + 미래 회귀 변수\n\n### Chapter 5: 시계열의 변화점 탐지\n\n### Chapter 6: 시계열 확률 예측을 위한 몬테카를로 시뮬레이션\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n제목 7: 시계열 확률 예측을 위한 분위 회귀\n\n제목 8: 시계열 확률 예측을 위한 적응형 예측\n\n제목 9: 시계열 확률 예측을 위한 적응형 분위 회귀\n\n제목 10: 자동 ARIMA!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\"Chapter 11: 시계열 데이터 형식을 쉽게 만들어보기\n\nChapter 12: 다기간 확률 예측을 위한 선형 회귀\n\nChapter 13: 트리 기반 시계열 모델을 위한 피처 엔지니어링\n\nChapter 14: 다기간 시계열 예측을 위한 두 가지 주요 전략\"\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 15장: Tree 기반 XGB, LightGBM 및 CatBoost 모델을 활용한 다기간 시계열 확률 예측\n\n# 16장: 시계열 모델링 기법의 진화\n\n# 17장: Deep Learning 기반 DeepAR을 활용한 시계열 확률 예측\n\n# 18장: 응용 - 주식 가격에 대한 확률적 예측\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 19장: RNN에서 Transformer 기반 시계열 모델로\n\n# 20장: 해석 가능한 시계열 예측을 위한 Temporal Fusion Transformer\n\n# 21장: 시계열 예측을 위한 오픈소스 Lag-Llama 튜토리얼","ogImage":{"url":"/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_0.png"},"coverImage":"/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_0.png","tag":["Tech"],"readingTime":26},{"title":"알아두었으면 좋았을 Python 리스트 방법 12가지","description":"","date":"2024-07-09 19:32","slug":"2024-07-09-12PythonListThingsIRegretNotKnowingEarlier","content":"\n\n\n![이미지](/assets/img/2024-07-09-12PythonListThingsIRegretNotKnowingEarlier_0.png)\n\n파이썬 여행을 하면서 몇 가지를 좀 늦게 알게 되었는데, 아마 당신이 이것들을 더 빨리 배울 수 있을 거에요.\n\n### 1) 리스트를 결합하기 위해 * 사용하기\n\n리스트 앞에 *을 추가하면 언팩합니다:\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\na = [1, 2]\nb = [3, 4]\n\nc = [*a, *b, 5]\n\nprint(c) # [1, 2, 3, 4, 5]\n```\n\n- 첫 번째 *는 a의 요소를 c에 풀어 헤친다\n- 두 번째 *는 b의 요소를 c에 풀어 헤친다\n- 이것이 왜 1, 2, 3, 4, 5가 동일한 목록 c에 들어 있는지 이유입니다\n\n```js\na = [1, 2]\nb = [3, 4]\nc = [5, 6]\nd = [7, 8]\n\nx = [*a, b, *c, d]\n\nprint(x) # [1, 2, [3,4], 5, 6, [7, 8]]\n```\n\n^ *이 붙은 리스트(a와 c)만 풀어 헤쳐진다는 것을 주목해 주세요. b와 d는 일반 요소처럼 처리됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 2) *를 사용하여 리스트 언패킹하기\n\n리스트를 언패킹할 때, 우리는 *를 변수 앞에 사용하여 즉시 사용하지 않을 초과 요소를 받을 수 있습니다.\n\n```js\nmylist = ['apple', 'orange', 'pear', 'pineapple', 'durian']\n\na, b, *others = mylist\n\nprint(a)       # apple\nprint(b)       # orange\nprint(others)  # ['pear', 'pineapple', 'durian']\n```\n\n- a는 mylist의 첫 번째 요소에 할당됩니다.\n- b는 mylist의 두 번째 요소에 할당됩니다.\n- others는 mylist의 모든 다른 요소를 받는 리스트에 할당됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n노트 - a와 b가 반드시 가장 앞에 있을 필요는 없습니다.\n\n```js\nmylist = ['apple', 'orange', 'pear', 'pineapple', 'durian']\n\na, *others, b = mylist\n\nprint(a)       # apple\nprint(b)       # durian\nprint(others)  # ['orange', 'pear', 'pineapple']\n```\n\n- a는 mylist의 첫 번째 요소에 할당됩니다.\n- b는 mylist의 마지막 요소에 할당됩니다.\n- others는 mylist 사이에 모든 다른 요소를 캐치하는 리스트에 할당됩니다.\n\n# 3) 리스트를 함수 인수로 언패킹하는 방법\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n함수 이름, 나이, 성별을 받는 test 함수가 있다고 가정해보죠. 이 함수를 사용하려면 test(이름, 나이, 성별)와 같이 전달해주어야 합니다. \n\n```js\ndef test(name, age, gender):\n    print(name, age, gender)\n\ntest('rocky', 5, 'male') # rocky 5 male\n```\n\n만약 올바른 함수 인수를 포함하는 리스트 x = ['rocky', 5, 'male']가 있다면, *를 사용하여 해당 인수를 함수에 전달할 수 있습니다.\n\n```js\nx = ['rocky', 5, 'male']\n\ntest(*x) # rocky 5 male\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위 내용은 다음과 같습니다:\n\n```js\ntest('rocky', 5, 'male')\n```\n\n# 4) 리스트 컴프리헨션\n\n어떤 이유로 인해 나는 리스트 컴프리헨션에 대해 상대적으로 늦게 배웠다 (자료 구조와 알고리즘에 대해서 배운 후에야).\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 우리가 [1, 2, 3, 4, 5]라는 리스트가 있고, 각 요소를 10씩 곱해서 [10, 20, 30, 40, 50] 리스트를 만들고 싶다면, 리스트 컴프리헨션 없이는 어떻게 할 수 있을까요:\n\n```js\nnumbers = [1, 2, 3, 4, 5]\n\nnewlist = []\nfor number in numbers:\n    newlist.append(number * 10)\n\nprint(newlist)  # [10, 20, 30, 40, 50]\n```\n\n리스트 컴프리헨션을 사용하여 훨씬 더 우아하게 할 수 있는 방법은 다음과 같습니다:\n\n```js\nnumbers = [1, 2, 3, 4, 5]\n\nnewlist = [n * 10 for n in numbers]\n\nprint(newlist)  # [10, 20, 30, 40, 50]\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 5) 중첩된 리스트에 대한 리스트 컴프리헨션\n\n하지만 중첩된 for 루프는 어떻게 할까요? 걱정하지 마세요. 리스트 컴프리헨션은 이를 쉽게 처리할 수 있습니다. 리스트 컴프리헨션을 사용하지 않은 예시를 통해 살펴보겠습니다:\n\n```js\nnewlist = []\n\nfor i in [1, 2]:\n    for j in [3, 4]:\n        t = (i, j)\n        newlist.append(t)\n        \nprint(newlist) # [(1, 3), (1, 4), (2, 3), (2, 4)]\n```\n\n리스트 컴프리헨션을 사용하여 정확히 동일한 작업을 수행할 수 있습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nnewlist = [(i,j) for i in [1,2] for j in [3,4]]\n\nprint(newlist) # [(1, 3), (1, 4), (2, 3), (2, 4)]\n```\n\n^ 중첩된 for 루프를 리스트 내포로 변환할 때는 외부 for 루프가 먼저 오고, 그 다음에 내부 for 루프가 옵니다.\n\n# 6) 튜플 대 리스트\n\n비기너였을 때 저는 꽤 오랫동안 튜플을 무시했습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n튜플은 그냥 변경할 수 없는 목록입니다. 변경할 수 없다는 것은 튜플을 만든 후에는 변경할 수 없다는 것을 의미합니다.\n\n```js\n# 리스트는 변경할 수 있습니다. .append를 사용하여 만든 후에도 요소를 추가할 수 있습니다.\n\nmylist = [1, 2, 3]\n\nmylist.append(4)\nprint(mylist)      # [1, 2, 3, 4]\n```\n\n```js\n# 튜플은 변경할 수 없습니다. 만든 후에는 아무것도 추가할 수 없습니다\n\nmytuple = (1, 2, 3)\n\nmytuple.append(4) # ERROR\n```\n\n그래서 튜플은 목록의 안 좋은 버전으로 보입니다. 왜 튜플을 사용해야 할까요?\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n튜플의 불변성의 가장 큰 장점은 해시 가능하다는 것입니다.\n\n- 리스트는 사전 키가 될 수 없지만 튜플은 될 수 있습니다\n- 리스트는 집합에 추가할 수 없지만 튜플은 추가할 수 있습니다\n\n```js\n# 리스트는 1) 사전 키로 사용할 수 없으며 2) 집합에 추가할 수 없음\n\nd = {\n    [1, 2, 3]: 4,\n    [5, 6, 7]: 8\n}\n\n# ERROR\n```\n\n```js\n# 하지만 튜플은 가능합니다\n\nd = {\n    (1, 2, 3): 4,\n    (5, 6, 7): 8\n}\n\n# OK\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 7) .insert()을 사용하여 특정 인덱스에 새 요소를 삽입합니다.\n\n.append()은 리스트의 뒷부분에만 새 요소를 추가할 수 있습니다.\n\n하지만 .insert()을 사용하면 새 요소를 어떤 인덱스에든 추가할 수 있습니다.\n\n```js\nmylist = [1, 2, 3]\n\n# 새 값 100을 인덱스 0에 추가\nmylist.insert(0, 100)\n\nprint(mylist) # [100, 1, 2, 3]\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n^ 기존 요소가 모두 오른쪽으로 이동해야 하므로 이 작업은 O(n) 시간이 걸립니다.\n\n```js\nmylist = [1, 2, 3]\n\n# 인덱스 2에 새로운 요소 150 추가\nmylist.insert(2, 150)\n\nprint(mylist) # [1, 2, 150, 3]\n```\n\n^ 1과 2는 그대로 있지만, 3은 오른쪽으로 이동해야 합니다.\n\n# 8) .pop()을 사용하여 요소 제거\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n.pop() 메소드를 사용하면 2가지 작업을 동시에 할 수 있습니다:\n\n- 리스트의 마지막 요소를 삭제합니다.\n- 삭제된 이 요소를 반환합니다.\n\n```js\nmylist = [1, 2, 3]\n\n# 마지막 요소 제거하고 x에 할당\nx = mylist.pop()\n\nprint(x)      # 3\nprint(mylist) # [1, 2]\n```\n\n.pop()에 인덱스를 전달하면 해당 인덱스의 요소를 제거할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n내목록 = [1, 2, 3]\n\n# 인덱스 0의 요소를 제거하고 x에 할당\nx = 내목록.pop(0)\n\nprint(x)       # 1\nprint(내목록)  # [2, 3]\n```\n\n.pop(n)은 모두 n 이후에 위치한 인데스의 요소를 좌측으로 이동해야 하므로 O(n) 시간이 걸린다는 것을 알아두세요. 이것은 우리 목록이 매우 큰 경우 비효율적일 수 있다는 것을 의미합니다.\n\n# 9) .extend()를 사용하여 목록 결합\n\n.extend()는 한 목록의 모든 요소를 다른 목록에 추가할 수 있게 해줍니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\r\na = [1, 2, 3]\r\nb = [4, 5, 6]\r\n\r\n# b의 모든 요소를 a에 추가합니다.\r\na.extend(b)\r\n\r\nprint(a)  # [1, 2, 3, 4, 5, 6]\r\nprint(b)  # [4, 5, 6]\r\n```\r\n\r\n^ b가 변경되지 않았음에 유의해주세요\r\n\r\n# 10) sort() vs sorted()\r\n\r\n- `.sort()`은 리스트 자체를 정렬합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nmylist = [1, 3, 2]\n\nmylist.sort()\n\nprint(mylist) # [1, 2, 3]\n```\n\nsorted() 함수는 리스트를 정렬한 복사본을 생성합니다. 원본 리스트는 그대로 유지됩니다. 원본 리스트의 순서를 보존하고 싶을 때 이것을 사용합니다.\n\n```js\nmylist = [1, 3, 2]\n\nnewlist = sorted(mylist)\n\nprint(newlist)  # [1, 2, 3]\nprint(mylist)   # [1, 3, 2]\n```\n\n# 11) 사용자 정의 조건으로 .sort()하기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n**참고— 이것은 .sort()와 sorted()에 대해 동일하게 작동합니다.**\n\n기본 .sort()는 문자열을 알파벳 순서대로 정렬합니다:\n\n```js\nfruits = ['orange', 'apple', 'pear']\n\nfruits.sort()\n\nprint(fruits) # ['apple', 'orange', 'pear']\n```\n\n우리는 .sort()에서 key 인자에 함수를 전달하여 사용자 정의 정렬 조건을 정의할 수 있습니다. 예: list.sort(key=your_function)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 함수는 전체 요소를 가져와서\n- 우리가 정렬하려는 값을 반환합니다.\n\n문자열 내의 p의 개수로 정렬하고 싶다고 가정해 봅시다.\n\n- 따라서 사용자 정의 함수는 여전히 전체 요소를 가져와서\n- p 문자의 개수를 반환합니다.\n\n```js\ndef your_condition(element: str) -\u003e int:\n    return element.count('p')\n\nfruits = ['orange', 'apple', 'pear']\n\nfruits.sort(key=your_condition)\n\nprint(fruits) # ['orange', 'pear', 'apple']\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테이블 태그를 Markdown 형식으로 변경하세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n노트 - 이 코드는 .sort()와 sorted() 모두에 작동합니다.\n\n학생을 나타내는 각각의 사전이 포함된 목록이 있다고 가정해 봅시다.\n\n```js\nstudents = [\n    {'name': 'A', 'math':100, 'science':81},\n    {'name': 'B', 'math':100, 'science':71},\n    {'name': 'C', 'math':100, 'science':91},\n    {'name': 'D', 'math':80, 'science':91},\n    {'name': 'E', 'math':80, 'science':93},\n    {'name': 'F', 'math':80, 'science':92}\n]\n```\n\n그리고 그들의 수학 점수에 따라 정렬한다고 가정합시다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nstudents.sort(key=lambda x:x['math'])\n\nprint(students)\n\n'''\n[\n  {'name': 'D', 'math': 80, 'science': 91}, \n  {'name': 'E', 'math': 80, 'science': 93}, \n  {'name': 'F', 'math': 80, 'science': 92}, \n  {'name': 'A', 'math': 100, 'science': 81}, \n  {'name': 'B', 'math': 100, 'science': 71}, \n  {'name': 'C', 'math': 100, 'science': 91}\n]\n'''\n\n^ math=80 at the front, math=100 at the back. But notice that their science score is not sorted.\n\nAnd what if we want to sort by math first, then science?\n\n- first sort by math score\n- for students with the same math score, sort by science score\n``` \n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이를 수행하기 위해서는 우리의 주요 함수는 단순히 튜플 (첫 번째 조건, 두 번째 조건)을 반환하면 됩니다. 이 경우에는 (수학 점수, 과학 점수)가 될 것입니다.\n\n```js\nstudents.sort(key=lambda x:(x['math'], x['science']) )\n\nprint(students)\n\n'''\n[\n  {'name': 'D', 'math': 80, 'science': 91}, \n  {'name': 'F', 'math': 80, 'science': 92}, \n  {'name': 'E', 'math': 80, 'science': 93}, \n  {'name': 'B', 'math': 100, 'science': 71}, \n  {'name': 'A', 'math': 100, 'science': 81}, \n  {'name': 'C', 'math': 100, 'science': 91}\n]\n'''\n```\n\n그리고 여기서, 수학 점수가 동일한 학생들은 과학 점수에 의해 정렬됨을 주목해 보세요.\n\n참고 — 3가지 조건에 따라 정렬하려면, 단순히 (첫 번째 조건, 두 번째 조건, 세 번째 조건)의 튜플을 반환하면 됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론\n\n이 내용이 명확하고 이해하기 쉬웠으면 좋겠어요!\n\n# 친구들을 위한 Python 농담\n\n# 만약에 제작자로서 저를 지원하고 싶다면\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 제 책을 구입해 주세요! — 101 Things I Never Knew About Python\n- 확인할 수 있는 곳: [여기](https://payhip.com/b/vywcf)\n- 이 이야기를 위해 50번 클랩을 해주세요\n- 댓글로 당신의 생각을 남겨주세요\n- 이야기 중 가장 좋아하는 부분을 강조해주세요\n\n감사합니다! 이런 작은 행동이 큰 도움이 되고, 정말 감사드립니다!\n\nYouTube: [여기](https://www.youtube.com/@zlliu246)\n\nLinkedIn: [여기](https://www.linkedin.com/in/zlliu/)","ogImage":{"url":"/assets/img/2024-07-09-12PythonListThingsIRegretNotKnowingEarlier_0.png"},"coverImage":"/assets/img/2024-07-09-12PythonListThingsIRegretNotKnowingEarlier_0.png","tag":["Tech"],"readingTime":15},{"title":"다중 기간 확률 예측을 위한 선형 모델 이해하기","description":"","date":"2024-07-09 19:30","slug":"2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting","content":"\n\n\u003cimg src=\"/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_0.png\" /\u003e\n\n샘플 eBook 장(chapters) (무료): [여기](https://github.com/dataman-git/modern-time-series/blob/main/20240522beauty_TOC.pdf)\n\nTeachable.com에서 eBook: $22.50 [여기](https://drdataman.teachable.com/p/home)\n\nAmazon.com에서 인쇄본: $65 [여기](https://a.co/d/25FVsMx)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n선형 회귀 모델은 시계열에 대한 점 추정을 당연히 할 수 있습니다. 선형 회귀 모델은 빠르고 해석하기 쉽며 쉽게 배포할 수 있는 장점이 있습니다. 많은 기관에서 여전히 좋은 선택입니다. 선형 회귀의 일반적인 유형은 자기회귀 모델로, 9장인 \"자동 ARIMA\"에서 나와 있습니다. 그러나 많은 실제 사용 사례에서는 다음 두 가지를 제공해야 합니다: (1) 확률적 예측(또는 예측 구간 또는 예측 불확실성이라고도 함)과 (2) 다기간 예측. 선형 회귀를 어떻게 확장하여 이 두 결과를 수행할 수 있을까요?\n\n(1)에 대한 해결책은 분위 회귀를 사용하여 예측 불확실성을 제공하는 것입니다. (A) 그림은 분위 예측을 보여줍니다. 미래의 시간 t에 대해 10번째, 50번째 및 90번째 백분위수를 기반으로 예측 샘플을 반환합니다. 필요하다면 더 많은 분위 샘플을 생성할 수 있습니다. 이에 대해서는 \"6장: 예측 불확실성을 위한 분위 회귀\"를 참조해주세요.\n\n![quantile forecasts](/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_1.png)\n\n(2)는 어떻게 해결할까요? 선형 회귀는 점 예측을 생성하지만, 다기간 예측을 어떻게 만들까요? 한 가지 방법은 동일한 모델을 재귀적으로 사용하는 것일 수 있습니다. 한 기간 예측을 모델로부터 얻어 다음 기간을 예측하는 데 입력으로 사용합니다. 그런 다음 두 번째 기간을 예측하기 위해 두 번째 기간의 예측을 입력으로 사용합니다. 이전 기간의 예측을 사용하여 모든 기간을 반복할 수 있습니다. 이것이 재귀 예측 또는 반복적 예측 전략이 하는 일입니다. (B) 그림은 모델이 먼저 yt+1을 생성하고, 그런 다음 같은 모델이 yt+1을 사용하여 yt+2를 생성하는 것을 보여줍니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 마크다운 형식의 테이블입니다.\n\n또 다른 전략은 n개의 별도 모델을 구축하는 것입니다. 각 모델은 n개의 기간에 대한 예측을 생성합니다. 10개 기간을 예측하려면 10개의 모델을 교육하고 각 모델을 특정 단계를 예측하도록 설정합니다. 이를 직접 예측 전략이라고 합니다. 이 전략은 그림 (C)에 나와 있습니다. 두 가지 전략을 학습하려면 13장인 \"다중 기간 시계열 예측을 위한 두 가지 주요 전략\"으로 이동하세요.\n\n선형 회귀를 단변량 시계열로 제한할 이유는 명백히 없습니다. 다른 변수인 공변량이라고 불리는 변수도 추가할 수 있습니다. 그림 (D)에는 다른 공변량 xt와 과거 p개 항목이 포함되어 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![그림](/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_4.png)\n\n선형 모델은 Figure (A)에 표시된 분위수 예측 및 Figure (D)에 표시된 직접 예측을 수행해야 할 때 복잡해 보입니다. 다행히 Python 시계열 라이브러리인 Darts에서 이러한 프로세스가 구현되었습니다. Darts 라이브러리는 \"scikit-learn\" 함수를 많이 포함하고 있어 \"scikit-learn\"의 기능을 활용할 수 있습니다. 이 중에는 sklearn의 분위수 회귀기능도 포함되어 있습니다. 따라서 우리는 Darts 라이브러리에 초점을 맞출 수 있습니다.\n\n우리는 다음 단계로 진행할 것입니다:\n\n- 단변량 데이터로 시작하기\n- 다른 공변럇값 포함하기, 그리고\n- 분위수 예측 포함하기.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nDarts 라이브러리는 시계열 데이터를 위한 특별한 데이터 형식을 가지고 있어요. 10장: 시계열 데이터 형식을 쉽게 다루는 내용은 Darts의 데이터 구조에 대해 소개하고 있어요. 이 장의 파이썬 노트북은 이 Github 링크를 통해 확인할 수 있어요.\n\n우선 데이터를 불러와 볼까요?\n\n데이터 불러오기\n\n이번에는 Kaggle.com의 Walmart 데이터셋을 사용해 보겠어요. 이 데이터셋은 2010년 2월 5일부터 2012년 11월 1일까지의 매장 주간 매출 데이터를 포함하고 있어요:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 날짜 — 판매 주의 주\n- 상점 — 상점 번호\n- 주간 판매 — 상점의 매출\n- 공휴일 플래그 — 특별 공휴일 주 인지 여부 1 — 공휴일 주 0 — 비공휴일 주\n- 온도 — 판매일의 온도\n- 연료 가격 — 지역의 연료 비용\n\n또한 소매 매출에 영향을 미칠 수 있는 두 가지 거시 경제 지표가 있습니다: 소비자물가지수 및 실업률. 데이터 집합은 먼저 Pandas 데이터 프레임으로로드됩니다.\n\n```js\n%matplotlib inline\nimport pandas as pd\nimport numpy as np\nfrom matplotlib import pyplot as plt\n\nfrom google.colab import drive\ndrive.mount('/content/gdrive')\npath = '/content/gdrive/My Drive/data/time_series'\ndata = pd.read_csv(path + '/walmart.csv', delimiter=\",\")\ndata['ds'] = pd.to_datetime(data['Date'], format='%d-%m-%Y')\ndata.index = data['ds']\ndata = data.drop('Date', axis=1)\ndata.head()\n```\n\n\u003cimg src=\"/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_5.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n데이터 준비를 위한 Darts의 주요 Python 클래스는 TimeSeries 클래스입니다. Darts는 값들을 다차원 배열로 저장하는데, 이 배열들은 다음과 같은 형태를 가지고 있어요 (시간, 차원, 샘플):\n\n- 시간: 예를 들어 위 예시에서처럼 143주와 같은 시간 색인을 말해요.\n- 차원: 다변량 시리즈의 \"열\"들을 나타냅니다.\n- 샘플: 기간에 대한 값들을 의미합니다. 만약 10번째, 50번째, 90번째 백분위수에 대한 세 개의 샘플과 같이 확률론적 예측이라면, 세 개의 샘플이 존재하게 됩니다.\n\nWalmart 상점 매출을 불러오기 위해 .from_group_dataframe() 함수를 사용할 거에요. 그룹 ID는 \"Store\"이며, 따라서 group_cols 매개변수는 \"Store\"여야 해요. 시간 색인은 \"ds\" 열이에요.\n\n```js\nfrom darts import TimeSeries\ndarts_group_df = TimeSeries.from_group_dataframe(data, group_cols='Store', time_col='ds')\nprint(\"상점/그룹 수는:\", len(darts_group_df))\nprint(\"시간 기간의 수는: \", len(darts_group_df[0]))\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그룹/스토어의 수는 45개입니다.\n기간의 수는 143개입니다.\n\n.columns 함수를 사용하여 열을 나열할 수 있습니다:\n\n```js\ndarts_group_df[0].components\n```\n\n열 이름은:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n인덱스(['주간_매출', '휴일_플래그', '온도', '유종_가격', '소비자_물가_지수', '실업률'], dtype='object', name='구성요소')\n\n로컬 모델 구축하기\n\n시계열 예측에서는 두 가지 주요 유형의 모델이 있습니다: 로컬 모델과 글로벌 모델이 있습니다. 로컬 모델은 단일 시계열 또는 단변량 시계열에 사용되며 해당 시리즈에서 고유한 패턴과 트렌드를 포착하도록 설계되었습니다. 반면 글로벌 모델은 여러 시계열을 사용하여 개발되며 매개변수가 모든 시계열 전체에서 공유됩니다. 이를 통해 모델은 시계열 간에 일반적인 패턴과 관계를 포착하여 보다 정확한 예측을 할 수 있습니다.\n\n각 가게에 대해 로컬 모델을 구축할 것입니다. 가게 1 판매를 위한 모델을 구축하기 위해 가게 1의 데이터인 \"darts_group_df[0]\"를 사용할 것입니다. 이를 훈련 및 테스트 데이터로 분할할 것입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nstore1 = darts_group_df[0]\ntrain = store1[:130]\ntest = store1[130:]\nlen(train), len(test) # (130, 13)\n```\n\n타겟 변수와 공변량을 정의해 봅시다.\n\n타겟 및 과거, 미래 공변량\n\n저희의 타겟 시리즈는 \"Weekly_Sales\"입니다. 다른 공변량도 포함할 수 있습니다. 시계열에서는 과거 공변량과 미래 공변량 두 가지 유형의 공변량이 있습니다. 과거 공변량은 현재 연구 시점까지의 변수입니다. 그리고 미래 공변량은 미래에서 관찰 가능한 변수입니다. 미래 값을 어떻게 알 수 있는지 궁금할 수도 있습니다. 우리는 미래 값을 알 수 있는 이유가 두 가지 있습니다. 첫 번째 이유는 그들이 달력 일수, 공휴일 또는 정기 프로모션과 같은 결정론적 값이기 때문입니다. 두 번째 이유는 날씨 예보와 같은 외부 소스의 예측 값입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리 경우에는 \"Fuel_price\"와 \"CPI\"를 과거 공선변수로 포함하고 \"Holiday_flag\"를 미래 공선변수로 포함할 것입니다. 훈련 데이터에서 목표 및 과거 공선변수는 130개의 데이터 포인트를 가지고 있습니다. 그러나 미래 공선변수는 미래로 확장되어야 하며, 테스트 데이터의 기간을 커버하기 위해 추가 13개의 데이터 포인트를 가지고 있어야 합니다.\n\n```js\ntarget = train['Weekly_Sales']  #130 주\npast_cov = train[['Fuel_Price', 'CPI']]  # 130 주\nfuture_cov = store1['Holiday_Flag'][:143]  #143 주\n```\n\n기본 구문을 보여주기 위해 공선변수 없이 시작해봅시다.\n\n(1) 유변량 데이터만, 공선변수 없음\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 코드는 Darts의 LinearRegressionMode 클래스의 공식입니다.\n\n```js\nfrom darts.models import LinearRegressionModel\nn = 11\nmodel = LinearRegressionModel(\n    lags=12,\n    multi_models = True  # 기본값\n)\n```\n\n주요 입력 매개변수는 다음과 같습니다:\n\n- lags: 지연된 항목의 수\n- multi_models: 이 하이퍼 매개변수는 다기간 예측 전략을 식별합니다. \"True\"이면 직접 예측 전략을 적용하고, 그렇지 않으면 재귀적 예측 전략을 적용합니다. 기본값은 \"True\"입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\"우리는 단변량 시리즈 'target'을 사용하여 모델을 훈련하고 다음 n 기간을 예측할 것입니다.\n\n```js\nmodel.fit(target)\npred = model.predict(n)\npred.values()\"\n```\n결과는 다음 n 기간을 예측한 것입니다. 위의 코드가 이미 직접 예측 전략을 실행했음을 주목하세요.\n\n![image](/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_6.png)\"\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n훈련 데이터, 예측 값 및 실제 값들을 함께 시각화해 보겠습니다:\n\n```js\nimport matplotlib.pyplot as plt\ntarget.plot(label='훈련 데이터')\npred.plot(label='예측값')\ntest['Weekly_Sales'][:n].plot(label='실제값')\n```\n\n그림 (G)은 위의 플롯을 보여줍니다.\n\n\u003cimg src=\"/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_7.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n모델의 성능은 어떤가요? 평균 절대 오차 또는 평균 절대 백분율 오차를 사용해보는 것이 좋을 것 같아요.\n\n```js\nfrom darts.metrics.metrics import mae, mape\nprint(\"평균 절대 오차:\", mae(test['Weekly_Sales'][:n], pred))\nprint(\"평균 절대 백분율 오차:\", mape(test['Weekly_Sales'][:n], pred))\n```\n\nMAPE는 4.07% 입니다:\n\n- 평균 절대 오차: 63404.82928050449\n- 평균 절대 백분율 오차: 4.070126403190025\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 다른 공석요인을 추가해 봅시다.\n\n과거 및 미래 공석요인 추가하기\n\n공석요인은 추가 입력 변수입니다. Darts는 모델링을 위해 두 가지 유형의 공석요인을 취합니다. 하나는 과거 공석요인(lags_past_covariates)으로 된 지연된(lagged) 과거 공석요인이며, 다른 하나는 다소 혼란스러운 이름을 가진 미래 공석요인(lags_future_covariates)입니다. \"미래 공석요인\"은 이러한 공석요인의 미래 시간 단계에서의 값을 가리킵니다. 그리고 \"지연된\" 값은 이전 시간 단계의 미래 공석요인을 나타냅니다. 따라서 미래에서 t + n 단계에 해당하는 시간에 모델은 t부터 t + (n-1) 기능의 공석요인 값을 고려합니다.\n\n```js\nfrom darts.models import LinearRegressionModel\nn = 12\nmodel = LinearRegressionModel(\n    lags=12,\n    lags_past_covariates=12,\n    lags_future_covariates=[0,1,2,3,4,5,6,7,8,9,10,11,12],\n    output_chunk_length=12,\n)\nmodel.fit(target, past_covariates=past_cov, future_covariates=future_cov)\npred = model.predict(n)\npred.values()\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n상기된 매개변수 output_chunk_length에 대해 자세한 설명이 필요합니다. 이는 단변량 시리즈에서 샘플을 생성하는 데 관한 것입니다. Figure (H)에서는 y0부터 y15까지의 시리즈에서 생성된 샘플을 보여줍니다. 각 샘플은 입력 청크와 출력 청크를 포함합니다. 입력 청크의 길이가 5이고 출력 청크의 길이가 2인 것으로 가정해 봅시다. 첫 번째 샘플은 입력 청크로 y0부터 y4를, 출력 청크로 y5, y6을 가집니다. 창이 시리즈를 따라 이동하여 시리즈의 끝까지 샘플을 만듭니다.\n\n![이미지](/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_8.png)\n\n출력 청크의 길이는 예측 가능한 최대 길이를 정의합니다. 이를 12로 지정했습니다. 12보다 더 많이 예측하고자 한다면 에러 메시지를 받게 될 것입니다.\n\n다음으로 하이퍼파라미터 multi_models=True는 다중 기간에 대한 확률적 예측을 위한 직접적인 전략을 정의합니다. 이는 각 미래 n 기간을 위해 별도의 n개 모델을 구축하는 전략을 의미합니다. 이는 기본 값이기 때문에 별도로 명시할 필요가 없습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_9.png)\n\n모델링과 예측을 한 뒤에는 실제 값과 예측값을 플롯에 함께 표시해보겠습니다.\n\n```js\nimport matplotlib.pyplot as plt\ntarget.plot(label='훈련 데이터')\npred.plot(label='예측값')\ntest['Weekly_Sales'][:n].plot(label='실제값')\n```\n\n(J) 그림은 결과를 플롯한 것입니다:\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![Image](/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_10.png)\n\n성능을 측정해 봅시다.\n\n```js\nprint(\"평균 절대 오차:\", mae(test['Weekly_Sales'][:n], pred))\nprint(\"평균 절대 백분율 오차:\", mape(test['Weekly_Sales'][:n], pred))\n```\n\n- 평균 절대 오차: 119866.3976798996\n- 평균 절대 백분율 오차: 7.738643655822244\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nMAPE는 7.73%로 이전 모델보다 낮습니다. 이전 모델을 선택할 수도 있었을 텐데요. 그 다음으로는 분위 예측을 생성하는 방법을 배워보겠습니다.\n\n(3) 분위 예측\n\n앞서 언급한대로 quantiles=[0.01,0.05,0.50,0.95,0.99]을 추가합니다. 샘플이 5개 있기 때문에 .predict()에서 num_samples=5를 지정할 것입니다.\n\n```js\nfrom darts.models import LinearRegressionModel\nn = 12\nchunk_length = n\nmodel = LinearRegressionModel(\n    lags=12,\n    lags_past_covariates=12,\n    lags_future_covariates=[0,1,2,3,4,5,6,7,8,9,10,11,12],\n    output_chunk_length=chunk_length,\n    likelihood = 'quantile', # 'quantile' 또는 'poisson'으로 설정할 수 있습니다.\n    # 'quantile'로 설정할 경우, sklearn.linear_model.QuantileRegressor가 사용됩니다.\n    # 'poisson'으로 설정할 경우, sklearn.linear_model.PoissonRegressor가 사용됩니다.\n    quantiles=[0.01, 0.05, 0.50, 0.95,0.99]\n)\nmodel.fit(target, past_covariates=past_cov, future_covariates=future_cov)\npred = model.predict(n, num_samples=5)\npred\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n각 기간에 대한 예측은 한 샘플 대신 5개의 샘플이 될 것입니다. (그래서 Darts의 데이터 형식을 \"샘플\"이라고 부릅니다.)\n\n![이미지](/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_11.png)\n\n실제 값과 확률 예측을 그래플에 플로팅할 것입니다.\n\n```js\nimport matplotlib.pyplot as plt\ntarget.plot(label='train')\npred.plot(label='prediction')\ntest['Weekly_Sales'][:n].plot(label='actual')\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![위 예측은 확률적 예측을 위한 연한 파란색 영역을 포함합니다.](/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_12.png)\n\n결론\n\n이 장에서는 Darts 라이브러리를 사용하여 선형 회귀 모델 클래스를 배웠습니다. 이를 통해 여러 기간의 확률적 예측을 위한 선형 모델을 구축할 수 있습니다. 과거 및 미래 공변량을 포함한 구문 및 다기간 앞쪽 예측을 위한 직접 또는 재귀적 예측 전략의 옵션을 배웠습니다. 또한 모델을 분위수 확률적 예측을 위해 설정하는 방법도 배웠습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 장에서는 최신 회귀 기반 시계열 기법을 마무리합니다:\n\n- 자동 ARIMA!\n- 쉬운 시계열 데이터 형식\n- 다기간 확률 예측을 위한 선형 회귀\n\n다음 단원에서는 트리 기반 모델링 기법을 공부할 예정입니다:\n\n- 트리 기반 시계열 예측에 대한 튜토리얼\n- 다기간 시계열 예측에 대한 튜토리얼\n- 다기간 시계열 확률 예측을 위한 트리 기반 XGB, LightGBM 및 CatBoost 모델\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n샘플 eBook 챕터(무료): [여기](https://github.com/dataman-git/modern-time-series/blob/main/20240522beauty_TOC.pdf)\n\n- The Innovation Press, LLC의 스태프 여러분께 감사드립니다. 아름다운 형식으로 책을 재현하여 즐거운 독서 경험을 선사해 주셨습니다. 저희는 Teachable 플랫폼을 선택하여 eBook을 전 세계 독자에게 분배하며 무거운 오버헤드 없이 알찬 서비스를 제공합니다. 결제 거래는 Teachable.com에서 신뢰성 있고 안전하게 처리됩니다.\n\nTeachable.com에서의 eBook: $22.50\n[여기에서 확인하세요](https://drdataman.teachable.com/p/home)\n\nAmazon.com에서의 인쇄판: $65 [여기서 확인하세요](https://a.co/d/25FVsMx)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 인쇄판은 광택이 도는 표지, 컬러 프린트, 아름다운 Springer 폰트와 레이아웃이 매력적인 읽기를 위해 채택되었습니다. 7.5 x 9.25인치의 포털 크기로 대부분의 책장에 적합합니다.\n- \"이 책은 Kuo의 시계열 분석에 대한 심층적인 이해와 예측 분석 및 이상 탐지에 대한 응용을 입증하는 것입니다. 이 책은 독자들이 현실 세계의 도전 과제에 대처하는 데 필요한 기술을 제공합니다. 데이터 과학으로의 직업 전환을 추구하는 사람들에게 특히 가치 있는 자료입니다. Kuo는 전통적인 기법과 최신 기법을 자세히 탐구했습니다. Kuo는 신경망 및 다른 고급 알고리즘에 대한 논의를 통합함으로써, 분야의 최신 동향과 발전을 반영했습니다. 이것은 독자가 확립된 방법뿐만 아니라 데이터 과학 분야의 가장 최신이며 혁신적인 기법과 상호 작용할 준비가 되어 있는 것을 보장합니다. Kuo의 유쾌한 글쓰기 스타일로 책의 알기 쉽고 접근성이 향상되었습니다. 그는 복잡한 수학적 및 통계적 개념을 낯설지 않게 만들어 손실되지 않도록 했습니다.\"\n\n# 모던 시계열 예측: 예측 분석과 이상 탐지를 위한\n\nChapter 0: 서문\n\nChapter 1: 소개\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 장 2: 비즈니스 예측용 선지자\n\n## 장 3: 튜토리얼 I: 추세 + 계절성 + 휴일 및 이벤트\n\n## 장 4: 튜토리얼 II: 추세 + 계절성 + 휴일 및 이벤트 + 자기회귀(AR) + 지연 회귀자 + 미래 회귀자\n\n## 장 5: 시계열에서의 변화점 탐지\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n6장: 시계열 확률 예측을 위한 몬테카를로 시뮬레이션\n\n7장: 시계열 확률 예측을 위한 분위수 회귀\n\n8장: 시계열 확률 예측을 위한 일치 예측\n\n9장: 시계열 확률 예측을 위한 일치화된 분위수 회귀\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 제 10 장: 자동 ARIMA!\n\n### 제 11 장: 시계열 데이터 형식 쉽게 만들기\n\n### 제 12 장: 다기간 확률 예측을 위한 선형 회귀\n\n### 제 13 장: 트리 기반 시계열 모델용 피처 엔지니어링\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nChapter 14: 다기간 시계열 예측을 위한 두 가지 주요 전략\n\nChapter 15: Tree 기반 XGB, LightGBM 및 CatBoost 모델에 대한 다기간 시계열 확률적 예측\n\nChapter 16: 시계열 모델링 기술의 진화\n\nChapter 17: 시계열 확률적 예측을 위한 Deep Learning 기반 DeepAR\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Chapter 18: 주식 가격을 위한 확률론적 예측 애플리케이션\n\n# Chapter 19: RNN에서 Transformer 기반 시계열 모델로\n\n# Chapter 20: 해석 가능한 시계열 예측을 위한 Temporal Fusion Transformer\n\n# Chapter 21: 시계열 예측을 위한 오픈 소스 Lag-Llama 튜토리얼","ogImage":{"url":"/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_0.png"},"coverImage":"/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_0.png","tag":["Tech"],"readingTime":21},{"title":"파이썬 고급 문자열 조작 기법들","description":"","date":"2024-07-09 19:28","slug":"2024-07-09-AdvancedStringManipulationsinPython","content":"\n\n\n![Advanced String Manipulations in Python](/assets/img/2024-07-09-AdvancedStringManipulationsinPython_0.png)\n\n파이썬에서 문자열은 기본적이며 거의 모든 파이썬 애플리케이션에서 널리 사용됩니다. 연결 및 슬라이싱과 같은 기본적인 문자열 작업은 간단하지만, 파이썬은 코드를 보다 효율적이고 가독성 있게 만들어주는 다양한 고급 문자열 조작 기술을 제공합니다. 이 기사는 파이썬에서의 고급 문자열 조작에 대해 자세히 설명하고 있으며, 중급 개발자들이 문자열 처리 능력을 향상할 수 있도록 예제와 함께 제공합니다.\n\n# 문자열 포매팅\n\n## format() 사용하기\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n`format()` 메서드는 더 다양한 문자열 포맷팅을 가능하게 합니다.\n\n```js\nname = \"Alice\"\nage = 30\nformatted_string = \"Name: {}, Age: {}\".format(name, age)\nprint(formatted_string)\n```\n\n결과:\n\n```js\nName: Alice, Age: 30\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 방법은 다양한 형식 요구에 유연하게 대응할 수 있도록 위치 및 키워드 인수를 포함할 수 있습니다.\n\n## f-Strings 사용하기\n\nPython 3.6에서 소개된 f-strings는 문자열 리터럴 내부에 표현식을 잘 포함하는 간결한 방법을 제공합니다.\n\n```js\nname = \"Alice\"\nage = 30\nformatted_string = f\"Name: {name}, Age: {age}\"\nprint(formatted_string)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n결과:\n\n```js\n이름: Alice, 나이: 30\n```\n\nf-Strings는 format()보다 읽기 쉬우면서 더 빠릅니다.\n\n# 문자열 메서드\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## join()\n\njoin() 메서드는 지정된 구분자로 문자열의 이터러블을 연결하는 데 사용됩니다.\n\n```js\nwords = [\"Python\", \"is\", \"awesome\"]\nsentence = \" \".join(words)\nprint(sentence)\n```\n\n결과:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n파이썬은 멋지다\n```\n\n이 방법은 루프에서 + 연산자를 사용하는 것보다 효율적입니다.\n\n## split()\n\nsplit() 메서드는 지정된 구분기호를 사용하여 문자열을 리스트로 분할합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nsentence = \"Python is awesome\"\nwords = sentence.split(\" \")\nprint(words)\n```\n\n결과:\n\n```js\n['Python', 'is', 'awesome']\n```\n\n기본적으로 split()은 모든 공백을 구분자로 사용합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 문자열 변환\n\n## replace()\n\nreplace() 메서드는 문자열에서 지정된 부분 문자열을 다른 부분 문자열로 대체합니다.\n\n```js\ntext = \"Hello, world!\"\nnew_text = text.replace(\"world\", \"Python\")\nprint(new_text)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n결과:\n\n```js\n안녕하세요, 파이썬!\n```\n\n이 방법은 원본 문자열에서 부분 문자열의 모든 발생을 대체할 수 있습니다.\n\n## translate()\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n더 복잡한 대체 작업을 위해서는 str.maketrans()와 결합된 translate()가 강력합니다.\n\n```python\ntranslation_table = str.maketrans(\"aeiou\", \"12345\")\ntext = \"Hello, world!\"\ntranslated_text = text.translate(translation_table)\nprint(translated_text)\n```\n\n결과:\n\n```python\nH2ll4, w4rld!\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 방법은 한 번의 패스로 여러 문자를 교체하는 데 유용합니다.\n\n# 고급 패턴 매칭\n\n## startswith() 및 endswith() 사용\n\n이러한 메서드는 문자열이 지정된 부분 문자열로 시작하거나 끝나는지 확인합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\r\n텍스트 = \"Python 프로그래밍\"\r\nprint(텍스트.startswith(\"Python\"))\r\nprint(텍스트.endswith(\"프로그래밍\"))\r\n```\r\n\r\n결과:\r\n\r\n```js\r\nTrue\r\nTrue\r\n```\r\n\r\n이 메서드들은 간단한 패턴 매칭에 정규식을 사용하는 것보다 더 빠릅니다.\r\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 문자열 정렬\n\n## ljust(), rjust(), center() 사용하기\n\n이러한 메서드들은 지정된 너비 내에서 문자열을 정렬합니다.\n\n```js\ntext = \"Python\"\nprint(text.ljust(10, '-'))\nprint(text.rjust(10, '-'))\nprint(text.center(10, '-'))\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n결과:\n\n```js\r\nPython----\n----Python\n--Python--\r\n```\n\n이 방법들은 텍스트 기반 UI나 보고서에서 서식이 있는 출력을 만드는 데 유용합니다.\n\n# 원치 않는 문자 제거\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## strip(), lstrip(), 그리고 rstrip()\n\n이 메서드들은 선행하거나 후행에 있는 문자들을 제거합니다.\n\n```js\ntext = \"   Python   \"\nprint(text.strip())\nprint(text.lstrip())\nprint(text.rstrip())\n```\n\n결과:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nPython\nPython   \n   Python\n```\n\n기본적으로 이러한 메소드들은 공백을 제거하지만, 다른 문자를 지정할 수도 있어요.\n\n# 대소문자 변환\n\n## upper(), lower(), title(), capitalize()\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 메서드들은 문자열의 대소문자를 변경합니다.\n\n```js\ntext = \"python programming\"\nprint(text.upper())\nprint(text.lower())\nprint(text.title())\nprint(text.capitalize())\n```\n\n결과:\n\n```js\nPYTHON PROGRAMMING\npython programming\nPython Programming\nPython programming\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이러한 방법들은 텍스트 데이터를 정규화하는 데 유용합니다.\n\nPython에서 고급 문자열 조작을 숙달하면 텍스트를 더 효율적이고 우아하게 처리할 수 있습니다. 문자열 포맷, 메소드 및 변환을 활용하여 더 깨끗하고 강력한 Python 코드를 작성할 수 있습니다. 이 글에서 다룬 기술은 중급 Python 개발자가 익숙해져야 하는 기본 도구로, 더 복잡한 텍스트 처리 작업에 대비할 수 있는 견고한 기반을 제공합니다.","ogImage":{"url":"/assets/img/2024-07-09-AdvancedStringManipulationsinPython_0.png"},"coverImage":"/assets/img/2024-07-09-AdvancedStringManipulationsinPython_0.png","tag":["Tech"],"readingTime":9},{"title":"Python 리스트 내포 List Comprehension 문법의 진정한 강점 단순한 문법 설탕이 아님","description":"","date":"2024-07-09 19:26","slug":"2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar","content":"\n\n아마 수많은 기사들을 보면, 파이썬에서 for-loop 대신 리스트 컴프리헨션을 사용하는 것을 권장하는 내용이 많다는 것을 이미 알아차렸을 것 같아요. 저도 많이 봤어요. 그런데 놀랍게도 그 이유에 대해 설명한 기사는 거의 찾아보기 힘들었죠.\n\n\"파이썬 다운\"이라거나 \"가독성\"과 같은 이유들만으로는 제가 같은 사람들을 쉽게 설득할 수 없을 거에요. 이런 \"이유\"들은 실제로는 파이썬 초보자들에게 잘못된 인상을 줄 수 있어요. 즉, 파이썬 리스트 컴프리헨션이 단순히 문법적 설탕에 불과하다는 거죠.\n\n사실, 리스트 컴프리헨션은 파이썬에서 큰 최적화 중 하나에요. 이 기사에서는 이러한 메커니즘에 대해 심층적으로 살펴볼 거에요. 아래 질문들에 대한 답을 얻을 수 있습니다.\n\n- 파이썬의 리스트 컴프리헨션은 무엇인가요?\n- 왜 리스트 컴프리헨션의 성능이 일반적으로 for-loop보다 우수한가요?\n- 언제 리스트 컴프리헨션을 사용해서는 안 되나요?\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 1. 간단한 성능 비교\n\n![image](/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_0.png)\n\n우리는 간단한 프로그램을 작성할 것이다. 먼저 for 루프와 리스트 컴프리헨션을 사용한 방법으로 각각의 성능을 비교해보자.\n\n```js\nfactor = 2\nresults = []\n\nfor i in range(100):\n    results.append(i * factor)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위 코드는 100번 실행되는 for 루프를 정의합니다. range(100) 함수는 100개의 정수를 생성하고 각각은 요소와 곱해집니다. 이전에 정의된 요소는 2입니다.\n\n이제 리스트 컴프리헨션 버전을 살펴봅시다.\n\n```js\r\nfactor = 2\nresults = [i * factor for i in range(100)]\r\n```\n\n이 예제에서는 훨씬 더 쉽고 가독성이 좋습니다. 이 두 개의 동일한 코드 스니펫을 실행해보고 성능을 비교해봅시다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_1.png)\n\n결과는 리스트 컴프리헨션이 일반 for-loop보다 거의 2배 빠르다는 것을 보여줬어.\n\n놀라운 건 아무것도 없어, 많은 기사들이 이미 말해줬던 내용이야. 하지만, 이 기사에서는 리스트 컴프리헨션이 왜 더 빠른지에 대해 집중적으로 다루고 있고, 내부에서 어떤 주요 차이가 있는지에 대해 논의할 거야.\n\n이 기사의 나머지 내용을 설명할 수 있는 모든 설명의 근거와 기준을 얻기 위해, 위의 두 구현, 즉 for-loop와 리스트 컴프리헨션의 bytecode를 얻기 위해 Python 내장 dis 모듈을 사용해보자.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n```js\nimport dis\n\ndis.dis(\"\"\"\nfactor = 2\nresults = []\n\nfor i in range(100):\n    results.append(i * factor)\n\"\"\")\n\ndis.dis(\"\"\"\nfactor = 2\nresults = [i * 2 for i in range(100)]\n\"\"\")\n```\n\n실행 결과는 다음과 같습니다. 바이트 코드를 이해할 필요는 없습니다. 단지 바이트 코드의 \"작업\"은 \"운영 코드\" 또는 간단히 \"opcode\"라고 불립니다. 나중에 해당 내용을 참조하겠습니다.\n\n![Python List Comprehension](/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_2.png)\n\n![Python List Comprehension](/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_3.png)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 2. 전역 변수 대 로컬 변수\n\n![이미지](/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_4.png)\n\n가장 큰 차이점은 변수의 범위입니다. 위의 바이트 코드에서 다음과 같이 나타납니다.\n\n- for 루프의 LOAD_NAME 대 리스트 함축의 LOAD_FAST\n- for 루프의 STORE_NAME 대 리스트 함축의 STORE_FAST\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n확실하게 말씀드리자면, for-loop 버전의 변수 i는 전역 범위에 있지만, 리스트 컴프리헨션의 변수 i는 지역 범위에 있어 실행 중에만 존재합니다.\n\n## 변수의 범위(scopes)를 어떻게 확인할까요?\n\nPython, Jupyter 또는 Google Colab과 같은 노트북 환경에서 이를 쉽게 확인할 수 있습니다. 새로운 세션을 시작한 후에 for-loop 버전을 실행한 다음 %whos 매직 명령어를 실행하면 현재 세션에 정의된 모든 사용자 변수가 나열됩니다.\n\n```python\nfactor = 2\nresults = []\n\nfor i in range(100):\n    results.append(i * factor)\n```\n\n```python\n%whos\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_5.png)\n\n여기에는 for 루프가 끝난 후에도 변수 i가 여전히 남아 있는 것을 보여줍니다. 지금 global() 메소드를 실행하면 거기에도 변수 i를 찾을 수 있습니다.\n\n그러나 세션을 재시작하고 리스트 내포를 실행하면 변수 i가 표시되지 않습니다.\n\n![이미지](/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_6.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이는 변수 i가 리스트 내포 구현에서 로컬 변수임을 증명했습니다.\n\n## 왜 성능이 다를까요?\n\n작업이 전역 네임스페이스에 있는 변수에 액세스해야 할 때, 전역 네임스페이스의 모든 객체 목록을 통과해야 합니다. 전역 네임스페이스에 무엇이 있는지 궁금하다면 세션에서 globals() 메서드를 실행해 보세요.\n\n![이미지](/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_7.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n내 경우에는 Google Colab에서 새 세션을 시작했습니다. for 루프를 실행한 후 전역 네임스페이스 사전에 이미 26개의 객체가 있습니다. 더 복잡한 Python 애플리케이션을 실행한다고 상상해보면, 성능이 더 나빠질 수도 있습니다.\n\n반면에 \"로컬 변수\"는 어떤가요?\n\n안타깝게도, 리스트 내포에서 로컬 변수를 실행 중에 보여주는 것은 쉽지 않습니다. 따라서 간단한 함수를 사용하여 설명해보겠습니다. 함수 내부에 print() 메서드를 추가할 수 있기 때문이죠.\n\n```js\ndef my_function(x, y):\n    z = x + y\n    print(\"로컬 변수:\", locals())\n    return z\n\nmy_function(1, 2)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 예시에서 x, y 및 z는 지역 변수입니다. 컴파일 시간에는 모든 지역 변수를 보유할 배열이 생성되며 각 변수에 고정된 인덱스가 지정됩니다. 개념적으로, 지역 변수 배열은 다음과 같이 나타낼 수 있습니다:\n\n- x는 인덱스 0에 있음\n- y는 인덱스 1에 있음\n- z는 인덱스 2에 있음\n\n따라서 함수(리스트 컴프리헨션)가 지역 변수에 액세스해야 할 때는 해당 인덱스를 사용합니다. 따라서 전역 네임스페이스에서 검색하는 것과 비교했을 때 훨씬 효율적입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 변수 대비 상수\n\n변수 i를 제외하고 또 하나의 최적화는 로컬 변수 때문에 발생하고 있습니다.\n\n변수 요소에 주의해주세요. 실제로, 요소 변수를 리스트 내포 밖에서 정의했지만, 그것은 로컬 상수로 리스트 내포에 로드될 것입니다.\n\n![이미지](/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_9.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 바이트 코드에서. 변수 factor를 모든 루프에서 전역 변수로 로드해야 합니다.\n\n![image](/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_10.png)\n\n그러나 리스트 컴프리헨션에서는 컴파일러가 factor의 값을 변경할 수 없는 상수로 로드하고 지역 범위에 유지해도 충분히 안전합니다. 따라서 전역 네임스페이스에서 변수를 검색할 필요가 없습니다.\n\n물론, 이것은 리스트 컴프리헨션의 성능에 기여하는 다른 요소입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 3. 일반 메소드 vs 최적화된 메소드\n\n![image](/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_11.png)\n\n또 다른 주요한 차이점은 append() 메소드에서 나타납니다. 두 가지 구현 방법의 단계를 보여드리겠습니다.\n\nfor 루프 버전에서:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- LOAD_METHOD은 리스트 객체 결과에서 append() 메서드를 로드합니다.\n- LOAD_NAME은 변수 i를 로드합니다.\n- LOAD_NAME은 변수 factor를 로드합니다.\n- BINARY_MULTIPLY는 수학 연산을 수행합니다.\n- CALL_METHOD은 append() 메서드를 호출하여 실행하고, 즉 결과를 결과 목록에 추가합니다.\n\n리스트 컴프리헨션 버전에서:\n\n- LOAD_FAST는 로컬 변수에서 변수 i를 로드합니다.\n- LOAD_CONST는 변수 factor의 값인 상수 2를 로드합니다.\n- BINARY_MULTIPLY는 수학 연산을 수행합니다.\n- LIST_APPEND는 결과를 로컬 변수에서도 있는 목록에 추가합니다.\n\n리스트 컴프리헨션 버전의 성능이 더 우수한 이유는 단순히 한 단계가 덜 있기 때문만이 아니라 내부적인 메커니즘 때문입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## LOAD_METHOD과 LIST_APPEND가 왜 다른가요?\n\n우리는 결과 목록에서 append() 메서드를 호출합니다. 즉, results.append(...)입니다. 이를 실행할 때 Python 런타임은 List 객체 공간에서 메서드를 찾아야 합니다. 이는 객체에 대해 dir() 메서드를 호출하는 것과 거의 동일합니다.\n\n```js\nprint(dir(results))\n```\n\n\u003cimg src=\"/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_12.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n당연히 이 \"검색\" 작업은 모든 루프에서 발생할 것입니다.\n\n그러나 리스트 내포 버전에서 결과 리스트도 로컬 변수입니다. 이 메커니즘은 리스트가 생성될 것이고, 리스트 내포 실행과 함께 만들어진다는 것입니다.\n\n비유를 들어보겠습니다. 작은 항목을 큰 컨테이너에 정리하는 것으로 상상해 보겠습니다.\n\nfor 루프 버전은 append() 메서드를 사용하는 것이 매번 우리가 항목과 상자를 다른 사람에게 주고, 이 사람이 항목을 넣은 후에 우리에게 컨테이너를 다시 돌려주는 것처럼합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n리스트 내포 버전을 사용하면 다른 사람의 도움 없이 항목을 컨테이너에 넣을 수 있어요. 따라서 성능도 훨씬 좋아요.\n\n# 4. 리스트 내포를 사용해서는 안 되는 경우\n\n![Python List Comprehension](/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_13.png)\n\n물론, 리스트 내포는 남용해서는 안 돼요. 다시 말해, 사용은 가능하지만 특정 상황에서는 사용해서는 안 되는 경우가 있어요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n한 가지 전형적인 시나리오는 필터 조건이 너무 복잡하다는 것입니다. 다음 예를 고려해보세요. 학생들의 이름과 시험 점수가 들어있는 튜플 목록이 있습니다.\n\n```js\nstudents = [(\"Alice\", 85), (\"Bob\", 95), (\"Cindy\", 100), (\"David\", 65), (\"Eva\", 70)]\n```\n\n그런 다음, 특정 조건에 따라 이름을 필터링하려고 합니다. 점수는 80보다 커야하고, 이름은 \"A\" 또는 \"C\"로 시작해야 합니다. 아래는 for 루프 구현입니다.\n\n```js\nfiltered_names = []\n\nfor name, score in students:\n    if score \u003e 80 and name.startswith((\"A\", \"C\")):\n        filtered_names.append(name)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기에 리스트 컴프리헨션 구현방법이 있습니다.\n\n```js\nfiltered_names = [name for name, score in students if score \u003e 80 and name.startswith((\"A\", \"C\"))]\n```\n\n\u003cimg src=\"/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_14.png\" /\u003e\n\n음, 리스트 컴프리헨션의 성능은 여전히 for 루프보다 조금 더 나은 편이에요. 그러나 복잡한 조건 때문에 리스트 컴프리헨션은 가독성이 많이 떨어지기 시작했다고 말씀드려야 할 것 같아요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n가독성과 디버깅 유연성을 희생해서 성능을 조금 향상시키는 것이 매우 주관적일 수 있습니다. 결정은 여러분에게 맡기겠습니다. :)\n\n# 요약\n\n![이미지](/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_15.png)\n\n이 글에서는 리스트 컴프리헨션의 성능이 일반 for-loop보다 우수한 이유에 대해 소개했습니다. 그것이 단순히 구문적인 설탕이 아니라 성능 최적화임을 증명했습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n두 구현의 바이트 코드를 표시하여 증거가 발굴되었습니다. 주요 차이점은 지역 vs. 전역 네임스페이스와 일반 메서드 vs. 최적화된 메서드입니다.\n\n물론, 모든 시나리오에서 리스트 내포를 사용하는 것이 권장되지는 않습니다. 예를 들어, 조건이 매우 많은 계층과 보다 복잡한 조건을 갖는 경우입니다. 여전히 리스트 내포를 사용할 가치가 있는지 고려해야 합니다.","ogImage":{"url":"/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_0.png"},"coverImage":"/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_0.png","tag":["Tech"],"readingTime":13}],"page":"4","totalPageCount":19,"totalPageGroupCount":1,"lastPageGroup":19,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"4"},"buildId":"OY-qm1-_Mz9jLZ5863EbF","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>