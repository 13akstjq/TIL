<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>TIL</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//posts/4" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="TIL" data-gatsby-head="true"/><meta property="og:title" content="TIL" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//posts/4" data-gatsby-head="true"/><meta name="twitter:title" content="TIL" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/7978fe7362f7d4c9.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/7978fe7362f7d4c9.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/873-eb138c3217d71553.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/posts/%5Bpage%5D-de1dc5579188f9be.js" defer=""></script><script src="/TIL/_next/static/B2TETmJptwqhd4vJNGZoH/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/B2TETmJptwqhd4vJNGZoH/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="PyCaret Auto ML로 아이리스 데이터셋에서 다중 클래스 분류하는 방법" href="/TIL/post/2024-07-14-Multi-ClassClassificationofIrisDatasetusingPyCaretAutoML"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="PyCaret Auto ML로 아이리스 데이터셋에서 다중 클래스 분류하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-Multi-ClassClassificationofIrisDatasetusingPyCaretAutoML_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="PyCaret Auto ML로 아이리스 데이터셋에서 다중 클래스 분류하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">PyCaret Auto ML로 아이리스 데이터셋에서 다중 클래스 분류하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Seaborn을 활용한 데이터 시각화 방법" href="/TIL/post/2024-07-14-DataVisualizationwithSeaborn"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Seaborn을 활용한 데이터 시각화 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-DataVisualizationwithSeaborn_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Seaborn을 활용한 데이터 시각화 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Seaborn을 활용한 데이터 시각화 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">14<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="데이터 분석 문제를 해결하는 15가지 최고의 Python 팁" href="/TIL/post/2024-07-14-Top15PythonTipstoSolveYourDataAnalysisChallenges"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="데이터 분석 문제를 해결하는 15가지 최고의 Python 팁" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/no-image.jpg"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="데이터 분석 문제를 해결하는 15가지 최고의 Python 팁" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">데이터 분석 문제를 해결하는 15가지 최고의 Python 팁</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="파이썬과 Sentinel 2 데이터를 활용한 간단한 토지 변화 감지 방법" href="/TIL/post/2024-07-14-SimplelandchangedetectionmethodologyusingPythonandSentinel2data"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="파이썬과 Sentinel 2 데이터를 활용한 간단한 토지 변화 감지 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-SimplelandchangedetectionmethodologyusingPythonandSentinel2data_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="파이썬과 Sentinel 2 데이터를 활용한 간단한 토지 변화 감지 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">파이썬과 Sentinel 2 데이터를 활용한 간단한 토지 변화 감지 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="AlpineJS와 HTMX로 Dash 애플리케이션 성능 극대화하기" href="/TIL/post/2024-07-14-SuperchargingDashApplicationswithAlpineJSandHTMX"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="AlpineJS와 HTMX로 Dash 애플리케이션 성능 극대화하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-SuperchargingDashApplicationswithAlpineJSandHTMX_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="AlpineJS와 HTMX로 Dash 애플리케이션 성능 극대화하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">AlpineJS와 HTMX로 Dash 애플리케이션 성능 극대화하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="1만 5천 달러로 트레이딩 봇 운영하기 단계별 가이드" href="/TIL/post/2024-07-14-RunningATradingBotWith15000Step-By-StepGuideOnHowToDoIt"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="1만 5천 달러로 트레이딩 봇 운영하기 단계별 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-RunningATradingBotWith15000Step-By-StepGuideOnHowToDoIt_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="1만 5천 달러로 트레이딩 봇 운영하기 단계별 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">1만 5천 달러로 트레이딩 봇 운영하기 단계별 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="PPDA가 축구에서 어떤 영향을 미치는지 알아보는 방법 수비 효율성 분석" href="/TIL/post/2024-07-14-DecodingDefensiveEfficiencyUnravelingtheImpactofPPDAinfootball"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="PPDA가 축구에서 어떤 영향을 미치는지 알아보는 방법 수비 효율성 분석" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-DecodingDefensiveEfficiencyUnravelingtheImpactofPPDAinfootball_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="PPDA가 축구에서 어떤 영향을 미치는지 알아보는 방법 수비 효율성 분석" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">PPDA가 축구에서 어떤 영향을 미치는지 알아보는 방법 수비 효율성 분석</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Python 덕분에 250만 원 절약한 방법 그리고 큰 골칫거리를 피한 비결" href="/TIL/post/2024-07-14-PythonSavedMeOver2500andaMajorHeadache"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Python 덕분에 250만 원 절약한 방법 그리고 큰 골칫거리를 피한 비결" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-PythonSavedMeOver2500andaMajorHeadache_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Python 덕분에 250만 원 절약한 방법 그리고 큰 골칫거리를 피한 비결" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Python 덕분에 250만 원 절약한 방법 그리고 큰 골칫거리를 피한 비결</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="초고속 언어 Mojo 간단 소개  Python의 슈퍼셋" href="/TIL/post/2024-07-14-AQuickIntroductiontoMojoaSupersetofPythonThatIsSuperFast"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="초고속 언어 Mojo 간단 소개  Python의 슈퍼셋" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-AQuickIntroductiontoMojoaSupersetofPythonThatIsSuperFast_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="초고속 언어 Mojo 간단 소개  Python의 슈퍼셋" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">초고속 언어 Mojo 간단 소개  Python의 슈퍼셋</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="PySpark 윈도우 연산을 마스터하기 위한 5가지 예제" href="/TIL/post/2024-07-14-5ExamplestoMasterPySparkWindowOperations"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="PySpark 윈도우 연산을 마스터하기 위한 5가지 예제" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-5ExamplestoMasterPySparkWindowOperations_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="PySpark 윈도우 연산을 마스터하기 위한 5가지 예제" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">PySpark 윈도우 연산을 마스터하기 위한 5가지 예제</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">16<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/TIL/posts/1">1</a><a class="link" href="/TIL/posts/2">2</a><a class="link" href="/TIL/posts/3">3</a><a class="link posts_-active__YVJEi" href="/TIL/posts/4">4</a><a class="link" href="/TIL/posts/5">5</a><a class="link" href="/TIL/posts/6">6</a><a class="link" href="/TIL/posts/7">7</a><a class="link" href="/TIL/posts/8">8</a><a class="link" href="/TIL/posts/9">9</a><a class="link" href="/TIL/posts/10">10</a><a class="link" href="/TIL/posts/11">11</a><a class="link" href="/TIL/posts/12">12</a><a class="link" href="/TIL/posts/13">13</a><a class="link" href="/TIL/posts/14">14</a><a class="link" href="/TIL/posts/15">15</a><a class="link" href="/TIL/posts/16">16</a><a class="link" href="/TIL/posts/17">17</a><a class="link" href="/TIL/posts/18">18</a><a class="link" href="/TIL/posts/19">19</a><a class="link" href="/TIL/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"PyCaret Auto ML로 아이리스 데이터셋에서 다중 클래스 분류하는 방법","description":"","date":"2024-07-14 20:31","slug":"2024-07-14-Multi-ClassClassificationofIrisDatasetusingPyCaretAutoML","content":"\n\n![이미지](/TIL/assets/img/2024-07-14-Multi-ClassClassificationofIrisDatasetusingPyCaretAutoML_0.png)\n\nScikit Learn은 수년간 가장 인기 있는 머신러닝 라이브러리였습니다. 그러나 이제는 우리의 작업을 더 쉽게 만들어 줄 새로운 라이브러리를 사용할 때가 왔습니다.\n\n이 글에서는 Pycaret라는 Auto ML 라이브러리를 소개하려고 합니다. 저는 PyCaret 라이브러리를 사용하여 붓꽃 데이터셋에서 분류를 수행하는 방법을 설명하겠습니다.\n\n이 글에서 사용된 머신러닝 소스 코드는 다음에서 확인하실 수 있습니다: github.com\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 링크를 통해 PyCaret에 대해 더 자세히 알아보세요:\n\n## PyCaret이 뭐죠?\n\nPyCaret은 머신러닝 모델 개발 전체 과정을 자동화하는 저코드, 오픈소스 파이썬 머신러닝 라이브러리입니다. PyCaret의 목표는 대부분의 작업을 자동화하여 머신러닝 모델의 개발, 배포 및 관리의 효율성을 증가시키는 것이며, 사용자가 매우 적은 코드를 사용하는 것입니다. PyCaret은 코드 작성 없이 복잡한 작업을 완료할 수 있기 때문에 초심자부터 전문가까지에게 좋은 옵션입니다.\n\n공식 문서: PyCaret\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 아이리스 데이터셋\n\n분석을 시작하기 전에, 데이터셋을 살펴봅시다.\n\n아이리스는 통계 및 머신 러닝에서 잘 알려진 데이터셋입니다.\n\n![img](/TIL/assets/img/2024-07-14-Multi-ClassClassificationofIrisDatasetusingPyCaretAutoML_1.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n1936년, 영국 수학자이자 생물학자인 로날드 피셔는 그의 논문 \"The Use of Multiple Measurements in Taxonomic Problems\"에서 판별 분석을 통한 이를 설명하기 위해 제시했습니다.\n\n이 데이터셋은 150개의 붓꽃 샘플과 각각의 네 가지 특징인 꽃받침의 길이, 꽃받침의 너비, 꽃잎의 길이, 그리고 꽃잎의 너비로 구성되어 있습니다. 타깃 변수는 붓꽃의 종입니다:\n\n- 부채붓꽃 (Irissetosa)\n- 세토사붓꽃 (Irisversicolor)\n- 버지니카붓꽃 (Irisvirginica).\n\n# Auto ML 절차 — 단계별 설명\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 기사에서는 다음 단계를 따라갑니다:\n\n시작해 봅시다!\n\n## 단계 1: 라이브러리 가져오기 및 데이터셋 불러오기\n\n먼저, 필요한 라이브러리를 가져와서 PyCaret을 사용하여 Iris 데이터셋을 로드해야 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\n# pycaret 설치\npip install pycaret\n```\n\n```python\n# 필요한 라이브러리 가져오기\nfrom pycaret.datasets import get_data\nfrom pycaret.classification import *\nimport pandas as pd\n\n# 데이터 불러오기\ndata = get_data('iris')\n```\n\n## 단계 2: 탐색적 데이터 분석 (EDA)\n\nEDA는 데이터를 이해하는 데 도움이 됩니다. 먼저 대상 변수의 분포, 요약 통계 및 데이터 세트의 처음 몇 행을 살펴보겠습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n#데이터셋의 처음 몇 행 표시\nprint(data.head())\n```\n\n표는 데이터셋의 처음 몇 행을 보여줍니다. 각 붓꽃의 측정값과 종을 확인할 수 있습니다.\n\n```js\n#데이터셋의 요약 통계\nprint(data.describe())\n```\n\n요약 통계는 각 기능의 분포를 보여줍니다. 평균, 표준편차, 백분위 등이 포함됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 타겟 변수 분포\nprint(data['species'].value_counts())\n```\n\n데이터셋은 각 종별로 50개의 샘플로 완벽히 균형을 이룹니다.\n\n## 시각화:\n\n특성 간의 관계를 이해하기 위해 페어 플롯(pair plots) 및 박스 플롯(box plots)과 같은 시각화를 사용할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n표 태그를 Markdown 형식으로 변경하겠습니다.\n\n## Pair plot\n\n![Pair plot](/TIL/assets/img/2024-07-14-Multi-ClassClassificationofIrisDatasetusingPyCaretAutoML_2.png)\n\nPair plot은 각 특성 쌍 간의 관계를 종에 따라 색칠하여 보여줍니다. 꽃잎 길이와 꽃잎 너비와 같은 몇 가지 특성 쌍은 종 간에 명확한 분리를 보여줍니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 상자 그림\n\n![Box Plot](/TIL/assets/img/2024-07-14-Multi-ClassClassificationofIrisDatasetusingPyCaretAutoML_3.png)\n\n상자 그림은 각 특징이 서로 다른 종에 대해 분포를 보여줍니다. 이는 서로 다른 종에 대해 몇 가지 특징이 구별되는 분포를 가지고 있음을 나타내며, 이는 분류에 유용할 수 있습니다.\n\n## 단계 3: 환경 설정\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음으로, PyCaret 환경을 설정해보겠습니다. 이 단계에는 데이터셋과 대상 변수를 지정하는 과정이 포함됩니다.\n\n```js\nclf = setup(data, target='species', session_id=123, log_experiment=True, experiment_name='iris_classification')\n```\n\n- setup(): PyCaret 환경을 초기화하며, 범주형 변수의 인코딩, 누락된 값의 보간, 데이터를 학습 및 테스트 세트로 분할하는 전처리 작업을 처리합니다.\n- data: 사용할 데이터셋입니다.\n- target: 예측하고자 하는 대상 변수입니다.\n- session_id: 재현성을 위한 랜덤 시드입니다.\n- log_experiment: 실험 로깅을 활성화합니다.\n- experiment_name: 실험에 이름을 지정합니다.\n\n## 단계 4: 모델 학습 및 선택\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nPyCaret은 여러 모델을 쉽게 학습하고 비교할 수 있게 해줍니다. compare_models() 함수를 사용하여 최상의 성능을 낼 모델을 찾을 수 있습니다.\n\n이전에 models() 명령어로 사용 가능한 모든 모델을 확인할 수 있습니다.\n\n![image](/TIL/assets/img/2024-07-14-Multi-ClassClassificationofIrisDatasetusingPyCaretAutoML_4.png)\n\n목록을 확인한 후에는 데이터 및 해당 특징에 기반하여 비교할 필요가 있는 모델을 선택합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기서는 Random Forest (rf), Decision Tree (dt), Light Gradient Boosting Machine (lightgbm), Extra Trees Classifier (et) 및 Extreme Gradient Boosting (xgboost)와 같은 트리 기반 모델을 비교하기 위해 선택했습니다.\n\n![image](/TIL/assets/img/2024-07-14-Multi-ClassClassificationofIrisDatasetusingPyCaretAutoML_5.png)\n\ncompare_models() 함수는 기본 하이퍼파라미터를 사용하여 여러 모델을 학습하고 정확도, 정밀도, 재현율 및 F1 점수를 포함한 다양한 메트릭을 사용하여 성능을 평가합니다. 결과에 따라 가장 우수한 성능을 보이는 모델을 반환하고 최상위 모델을 강조합니다.\n\n## 단계 5: 모델 평가\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n최적 모델을 선택한 후, 다양한 메트릭과 시각화를 사용하여 모델의 성능을 평가합니다.\n\n![이미지](/TIL/assets/img/2024-07-14-Multi-ClassClassificationofIrisDatasetusingPyCaretAutoML_6.png)\n\n`evaluate_model()`은 혼동 행렬, ROC 곡선, 분류 보고서와 같은 모델 성능을 평가하기 위한 여러 메트릭과 시각화 도구를 제공합니다.\n\n이것은 `evaluate_model()`에 의해 생성된 의사결정 경계 플롯입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-Multi-ClassClassificationofIrisDatasetusingPyCaretAutoML_7.png\" /\u003e\n\n## 단계 6: 모델 튜닝\n\ntune_model() 함수를 사용하여 모델의 하이퍼파라미터를 조정하여 성능을 향상시킬 수 있습니다.\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-Multi-ClassClassificationofIrisDatasetusingPyCaretAutoML_8.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n선택한 모델의 하이퍼파라미터를 최적화하여 성능을 향상시킵니다. 최적의 하이퍼파라미터 조합을 찾기 위해 그리드 탐색 또는 랜덤 탐색 방법을 사용합니다.\n\n최종 모델 파이프라인은 다음과 같습니다\n\n![이미지](/TIL/assets/img/2024-07-14-Multi-ClassClassificationofIrisDatasetusingPyCaretAutoML_9.png)\n\n## 단계 7: 플로팅과 시각화\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n모델 성능과 특성 중요도를 시각화하기 위해 PyCaret은 다양한 플로팅 함수를 제공합니다.\n\n![Multi-Class Classification of Iris Dataset using PyCaret AutoML](/TIL/assets/img/2024-07-14-Multi-ClassClassificationofIrisDatasetusingPyCaretAutoML_10.png)\n\n생성된 혼동 행렬은 모델의 성능을 실제 양성, 실제 음성, 거짓 양성 및 거짓 음성 측면에서 시각화합니다.\n\n![Multi-Class Classification of Iris Dataset using PyCaret AutoML](/TIL/assets/img/2024-07-14-Multi-ClassClassificationofIrisDatasetusingPyCaretAutoML_11.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 그림은 예측을 하는 데 각 기능의 중요성을 나타냅니다. 이것은 어떤 기능이 가장 영향력이 있는지 이해하는 데 도움이 됩니다.\n\n조정된 모델의 최적 매개변수는 다음과 같습니다:\n\n![그림](/TIL/assets/img/2024-07-14-Multi-ClassClassificationofIrisDatasetusingPyCaretAutoML_12.png)\n\nplot_model() 함수는 모델 성능과 해석 가능성을 평가하는 시각화를 생성합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 단계 8: 모델 해석\n\n모델을 해석하는 것은 모델이 예측을 어떻게 생성하는지 이해하는 데 중요합니다. 모델의 출력은 SHAP(Shapley Additive exPlanations) 값을 사용하여 설명됩니다. 이를 통해 각 피쳐가 모델에 의해 만들어진 예측에 어떤 영향을 미치는지에 대한 소중한 관점을 제공합니다.\n\n![image](/TIL/assets/img/2024-07-14-Multi-ClassClassificationofIrisDatasetusingPyCaretAutoML_13.png)\n\n`interpret_model()`은 SHAP 값을 사용하여 피쳐 중요도와 모델 예측에 대한 통찰을 제공합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 단계 10: 모델 예측\n\n튜닝된 모델의 예측 전체적인 정확도를 확인할 수 있습니다.\n\n![이미지](/TIL/assets/img/2024-07-14-Multi-ClassClassificationofIrisDatasetusingPyCaretAutoML_14.png)\n\n보시다시피, 97.7%의 정확도를 얻었습니다. 좋은 결과입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 단계 10: 모델 배포\n\n마지막으로, 모델을 저장하여 나중에 사용하고 다시 불러오는 방법을 시연할 수 있습니다.\n\n```js\n# 모델 저장하기\nsave_model(tuned_model, 'best_ensembled_model')\n# 모델 불러오기\nloaded_model = load_model('best_ensembled_model')\n```\n\n여기서, save_model()은 훈련된 모델을 디스크에 저장하고, load_model()은 디스크에서 저장된 모델을 불러오는 데 사용됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론\n\n이 프로젝트에서는 PyCaret을 사용하여 아이리스 데이터셋을 분류했습니다. PyCaret은 로우코드 방법론과 다양한 기능 세트로 효율적으로 머신러닝 모델을 생성하고 구현하는데 훌륭한 도구입니다.\n\n제 블로그를 읽어 주셔서 감사합니다!!! 이 글이 여러분께 새로운 것을 배울 수 있는데 도움이 되었으면 좋겠어요!\n\n가기 전에, 이미 하지 않았다면:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- ⭐️ 만약 이에 쏟은 시간과 노력에 감사하시다면, 제 팔로우와 박수👏 부탁드립니다. 감사합니다🙌\n- ⭐️ 피드백을 댓글로 남겨주세요! 🙂\n- ⭐️ 제 YouTube 채널 구독해주세요. 새 동영상이 곧 업로드됩니다!\n- ⭐️ Github, Github, LinkedIn을 팔로우해주세요. 어떤 것이든 상관없습니다.\n다음에 또 봐요!","ogImage":{"url":"/TIL/assets/img/2024-07-14-Multi-ClassClassificationofIrisDatasetusingPyCaretAutoML_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-Multi-ClassClassificationofIrisDatasetusingPyCaretAutoML_0.png","tag":["Tech"],"readingTime":13},{"title":"Seaborn을 활용한 데이터 시각화 방법","description":"","date":"2024-07-14 20:29","slug":"2024-07-14-DataVisualizationwithSeaborn","content":"\n\n\n![그림](/TIL/assets/img/2024-07-14-DataVisualizationwithSeaborn_0.png)\n\n데이터 시각화는 데이터 과학에서 중요한 기술로, 분석가들이 데이터에서 숨겨진 패턴과 통찰을 발견할 수 있게 합니다. Seaborn은 Matplotlib 위에 구축된 Python 라이브러리로, 매력적이고 유익한 통계 그래픽을 만들기 위한 고수준 인터페이스를 제공합니다. Seaborn은 아름다운 시각화를 만드는 과정을 간단하게 만들어주며, 다양한 플롯 스타일과 색상 팔레트를 제공하면서 Matplotlib이 사용자에게 맡기는 복잡성 중 많은 부분을 처리합니다. 특히 탐색적 데이터 분석에 적합하며 Pandas 데이터 구조와 원활하게 통합됩니다.\n\n환경 설정하기\n\n시각화에 들어가기 전에, Seaborn이 설치되어 있는지 확인해 주세요:\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n!pip install seaborn\n```\n\nSeaborn을 설치했으면, 다른 필요한 라이브러리와 함께 불러올 수 있어요:\n\n```js\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport pandas as pd\n```\n\n동물원 데이터셋 불러오기\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저희 동물원 프로젝트를 위해 동물의 다양한 속성을 포함하는 데이터셋이 필요합니다. 시연 목적을 위해 가상의 데이터셋을 만들어 보겠습니다:\n\n```js\n# 샘플 동물원 데이터셋\ndata = {\n    '동물': ['사자', '호랑이', '곰', '얼룩말', '기린'],\n    '물_수요': [350, 410, 290, 220, 300],\n    '체길이': [1.8, 2.0, 1.5, 2.5, 3.0],\n    '줄무늬': [0, 0, 0, 1, 0]\n}\nzoo_df = pd.DataFrame(data)\n```\n\n# 기본 시각화 생성\n\n## 막대 그래프\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n막대 플롯은 각 사각형의 높이로 수치 변수의 중심 경향 추정을 나타내고 오차 막대를 사용하여 해당 추정 주변의 불확실성을 표시합니다.\n\n\nsns.barplot(x='Animal', y='Water_Need', data=zoo_df)\nplt.title('Water Need by Animal')\nplt.show()\n\n\n출력\n\n![Image](/TIL/assets/img/2024-07-14-DataVisualizationwithSeaborn_1.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 히스토그램\n\n히스토그램은 수치 변수의 분포를 나타내는데, x-축을 구간으로 나누고 각 구간에 속하는 관측치의 수를 세는 방식입니다.\n\n```js\nsns.histplot(zoo_df['Body_Length'], bins=5)\nplt.title('Distribution of Body Lengths')\nplt.show()\n```\n\n결과\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](/TIL/assets/img/2024-07-14-DataVisualizationwithSeaborn_2.png)\n\n## 산점도\n\n산점도는 변수 간의 관계를 관찰하는 데 사용됩니다. Seaborn의 scatterplot 기능은 이러한 플롯을 만드는 데 편리한 인터페이스를 제공합니다.\n\n```js\nsns.scatterplot(x='Body_Length', y='Water_Need', data=zoo_df)\nplt.title('체길 길이 대 물 필요량')\nplt.show()\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n출력\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-DataVisualizationwithSeaborn_3.png\" /\u003e\n\n## Jointplot\n\nSeaborn을 사용하여 jointplot은 두 변수 간의 관계를 표시하며 각 변수의 주변 분포를 함께 보여줍니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nsns.jointplot(x='Body_Length', y='Water_Need', data=zoo_df, kind='reg')\nplt.suptitle('Jointplot of Body Length and Water Need')\nplt.show()\n```\n\n결과\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-DataVisualizationwithSeaborn_4.png\" /\u003e\n\n## Pairplot\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n`pairplot` 함수는 데이터 세트의 각 변수가 한 행을 통해 y 축을 공유하고 한 열을 통해 x 축을 공유하도록 하는 Axes 그리드를 생성합니다.\n\n```python\nsns.pairplot(zoo_df)\nplt.suptitle('Zoo 데이터 세트의 Pairplot')\nplt.show()\n```\n\n출력\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-DataVisualizationwithSeaborn_5.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 차트 서식의 기본\n\nSeaborn은 차트의 미학을 사용자 정의하여 더 매력적이고 해석하기 쉽게 만들 수 있는 여러 가지 방법을 제공합니다.\n\n테마와 스타일\n\nSeaborn은 모든 차트에 전역적으로 적용할 수 있는 사전 설정된 테마를 제공합니다. 예를 들어, darkgrid 테마를 설정하는 것은 매우 간단합니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\nsns.set_theme(style=\"darkgrid\")\n\n\n이 명령은 차트에 어두운 배경과 그리드 라인을 즉시 적용하여 플롯을 통해 값들을 추적하는 데 도움이 됩니다.\n\nset_style로 사용자 정의하기\n\nset_style을 사용하여 플롯의 모양을 더욱 사용자 정의할 수 있습니다. 이 함수를 사용하면 배경, 그리드 라인 및 spines를 제어할 수 있습니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nsns.set_style(\"whitegrid\", {\"grid.linestyle\": \":\"})\n```\n\n이 코드는 점선 그리드 라인이 있는 흰색 그리드 배경을 설정합니다.\n\n다양한 맥락에 맞게 그래프 크기 조정하기\n\nSeaborn의 set_context 함수를 사용하면 그래프 요소의 크기를 조정하여 프레젠테이션, 포스터 또는 보고서에 적합한 차트를 만들 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nsns.set_context(\"talk\")\n```\n\n이 명령은 레이블 및 선과 같은 요소를 확대하여 토크나 프레젠테이션 설정에서 더 읽기 쉽게 만듭니다.\n\n색상 팔레트 사용자 정의\n\nSeaborn은 프로젝트 테마에 맞게 색상 팔레트를 사용자 정의하거나 색맹 뷰어들을 위해 가독성을 향상시킬 수 있도록 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ncustom_palette = sns.color_palette(\"Paired\", 9)\nsns.set_palette(custom_palette)\n```\n\n이 코드 조각은 쌍으로 된 색상으로 사용자 정의 색상 팔레트를 생성하고 설정합니다. 이것은 범주 간의 구분을 좋게하는 데 좋습니다.\n\n플롯 요소 수정\n\n축, 범례 및 제목과 같은 플롯의 특정 요소를 수정하여 명확성과 미학을 향상시킬 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 커스터마이즈된 요소로 플로팅하기\nax = sns.barplot(x=\"동물\", y=\"수분_요구량\", data=zoo_data)\nax.set_title(\"동물과 그들의 수분 요구량\")\nax.set_xlabel(\"동물\")\nax.set_ylabel(\"수분 요구량(리터)\")\nsns.despine()  # 상단과 우측의 가장자리를 제거합니다\n```\n\n이 예제는 제목과 레이블이 달린 축을 가진 막대 플롯을 생성하며, 깔끔한 모습을 위해 불필요한 가장자리를 제거합니다.\n\n# FacetGrid 이해하기\n\nFacetGrid는 조건부 관계를 플로팅하기 위한 다중 플롯 그리드입니다. 데이터셋의 하위 그룹 내에서 여러 변수의 분포를 비교하거나 변수 간의 관계를 비교하고 싶을 때 특히 유용합니다. 생성된 플롯은 종종 \"lattice\", \"trellis\", 또는 \"small-multiple\" 그래픽이라고 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n동물원 데이터 세트 로딩\n\n우리의 동물원 프로젝트를 위해, 우리는 동물들의 종류, 수분 요구량 및 몸길이와 같은 다양한 속성을 포함하는 zoo.csv 데이터 세트를 가정해 봅시다. 아래는 데이터를 로드하는 방법입니다:\n\n```js\nimport pandas as pd\nzoo_data = pd.read_csv('zoo.csv')\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nFacetGrid을 사용한 기본적인 워크플로우는 세 단계로 구성됩니다:\n\n- 데이터셋 및 그리드 구조를 정의하는 변수와 함께 FacetGrid 객체를 초기화합니다.\n- 각 하위 집합에 하나 이상의 플로팅 함수를 적용하려면 FacetGrid.map() 또는 FacetGrid.map_dataframe()을 호출합니다.\n- 축 레이블을 변경하거나 범례를 추가하는 등의 작업을 수행하기 위해 다른 메서드를 사용하여 그림을 수정합니다.\n\n그리드 초기화하기\n\n우리의 동물원 데이터셋에서 각 동물 유형에 대해 별도의 플롯을 생성하고 싶다고 가정해 봅시다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ng = sns.FacetGrid(zoo_data, col=\"species\", col_wrap=4, height=3)\n```\n\n이 코드는 각 열이 다른 동물 유형을 나타내며 네 개의 열에서 줄바꿈되고 각 플롯의 높이가 세 인치인 그리드를 초기화합니다.\n\n플롯 매핑\n\n이제 각 패싯에 플로팅 함수를 매핑할 수 있습니다. 예를 들어 각 동물의 수분 필요량을 시각화하려고 한다고 가정해 보겠습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ng.map(sns.barplot, \"동물\", \"물 필요량\")\n```\n\n각 그리드 면에 막대 그래프를 만들어동물별 물 필요량을 보여줍니다.\n\n그리드 사용자 정의\n\n마지막으로, 우리는 그리드를 사용자 정의하여 정보를 더 잘 전달하고 시각적으로 매력적으로 만들 수 있습니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 각 패싯에 제목 설정\ng.set_titles(\"{col_name}\")\n# 축 레이블 설정\ng.set_axis_labels(\"동물\", \"수요량 (리터)\")\n# 범례 추가\ng.add_legend()\n# 플롯 보이기\nplt.show()\n```\n\n다중 변수 시각화\n\n동물의 몸 길이와 수요량을 시각화하는 FacetGrid를 만들어보겠습니다. 이는 동물의 종류와 줄무늬 여부에 따라 나뉩니다.\n\n```js\n# 그리드 초기화\ng = sns.FacetGrid(zoo_data, row=\"줄무늬 여부\", col=\"동물 종류\", margin_titles=True)\n# 각 패싯에 산점도 매핑\ng.map(sns.scatterplot, \"몸 길이\", \"물 수요량\")\n# 그리드 사용자 지정\ng.set_titles(col_template=\"{col_name} 동물\", row_template=\"줄무늬: {row_name}\")\ng.set_axis_labels(\"몸 길이 (센티미터)\", \"물 수요량 (리터)\")\ng.add_legend()\n# 플롯 보이기\nplt.show()\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 예시에서 그리드의 각 행은 줄무늬가 있는 동물과 없는 동물을 나타내고, 각 열은 다른 종류의 동물을 나타냅니다. 산점도는 이 하위 집합들 간의 몸 길이와 수분 필요량 사이의 관골을 보여줍니다.\n\n# Seaborn과 Matplotlib의 시너지\n\nSeaborn은 Matplotlib을 기반으로 구축되었으며, Pandas 데이터 구조와 긴밀하게 통합되어 있어 통계적 데이터 시각화에 이상적인 선택지입니다.\n\n동물원 프로젝트에서 데이터를 시각화하여 실제 예시에 대해 자세히 살펴보겠습니다. 서로 다른 종, 서식지 및 다양한 특성 간의 관골을 탐색해 보겠습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nZoo.cvs\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-DataVisualizationwithSeaborn_6.png\" /\u003e\n\n```js\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport pandas as pd\n# 동물원 데이터셋 불러오기\nzoo_data = pd.read_csv('zoo.csv')\n# 데이터셋 개요 출력\nprint(zoo_data.head())\n# 변수간 관계 시각화를 위한 페어플롯 생성\nsns.pairplot(zoo_data, hue='species')\nplt.show()\n# 각 종의 water_need 분포 시각화\nplt.figure(figsize=(12, 6))\nsns.boxplot(x='species', y='water_need', data=zoo_data)\nplt.title('종에 따른 수분 필요량')\nplt.show()\n# 서식지 면적을 바이올린 플롯으로 분석\nplt.figure(figsize=(12, 6))\nsns.violinplot(x='habitat_area', y='species', data=zoo_data, scale='width')\nplt.title('종에 따른 서식지 면적 분포')\nplt.show()\n```\n\n결과\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 코드에서는 필요한 라이브러리를 가져와서 동물원 데이터셋을 로드하는 방식으로 시작합니다. 그런 다음 sns.pairplot()을 사용하여 변수 간의 쌍별 관계를 이해할 수 있게 해주는 산점도 그리드를 만들고, 종에 따라 색칠합니다. 그다음 sns.boxplot()을 사용하여 서로 다른 종 간의 수분 요구량 분포를 시각화하여 요구 사항에 대한 통찰을 얻습니다. 마지막으로 sns.violinplot()을 사용하여 각 종의 서식지 면적 분포에 대한 더 깊은 이해를 제공하며, scale='width' 매개변수가 각 바이올린이 동일한 폭을 갖도록 하며 데이터의 밀도를 나타냅니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nSeaborn과 Matplotlib의 통합은 정교한 데이터 시각화를 만들기 위한 견고한 프레임워크를 제공합니다. 함께 사용하면 우리의 동물원 프로젝트 데이터를 통찰력 있고 매력적인 시각적 이야기로 변화시킬 수 있는 강력한 조합이 됩니다.\n\n데이터 시각화 관련 기사:\n\nMatplotlib를 이용한 데이터 시각화\n\nPlotly를 이용한 데이터 시각화\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Image](/TIL/assets/img/2024-07-14-DataVisualizationwithSeaborn_10.png)","ogImage":{"url":"/TIL/assets/img/2024-07-14-DataVisualizationwithSeaborn_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-DataVisualizationwithSeaborn_0.png","tag":["Tech"],"readingTime":14},{"title":"데이터 분석 문제를 해결하는 15가지 최고의 Python 팁","description":"","date":"2024-07-14 20:27","slug":"2024-07-14-Top15PythonTipstoSolveYourDataAnalysisChallenges","content":"\n\n## 실용적인 파이썬 데이터 분석 팁 15가지\n\n데이터 분석에 처음이든 경험이 풍부한 전문가든, 이 기사는 여러분의 여정을 돕는 소중한 가이드가 될 것입니다. 우리는 데이터 처리 능력을 향상시키는 데 도움이 되는 파이썬 데이터 분석에 대한 15가지 실용적인 팁을 알아볼 것입니다.\n\n# 1. 데이터 가져오기: 판다스가 당신의 친구입니다\n\n데이터 분석을 위한 중요한 요소인 판다스는 데이터 가져오기를 쉽게 만들어줍니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nimport pandas as pd\ndata = pd.read_csv('data.csv')  # `read_csv` 함수로 CSV 파일 가져오기\nprint(data.head())  # 처음 다섯 행 확인하기\n```\n\n`pd.read_csv()` 함수로 CSV 파일을 읽어올 수 있고, `head()`를 사용하여 데이터를 미리 확인하여 모든 것이 괜찮은지 확인할 수 있습니다.\n\n# 2. 데이터 정제: 누락된 값 다루기\n\n누락된 데이터를 식별하고 처리하는 것은 데이터 분석의 중요한 단계입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\ndata.dropna(inplace=True)  # 누락된 값이 있는 행 제거\ndata['column_name'].fillna(value, inplace=True)  # 열의 누락된 값 채우기\n```\n\n중요한 정보를 잃지 않으려면 빈 값 처리 방법을 신중하게 선택하세요.\n\n# 3. 데이터 유형 변환\n\n올바른 데이터 유형을 유지하는 것이 분석에 중요합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ndata['column'] = data['column'].astype(float)  # 열을 float으로 변환\n\n```\n\n이것은 수학 연산을 수행하거나 데이터 일관성을 보장하는 데 도움이 됩니다.\n\n# 4. 데이터 필터링\n\n조건에 따라 데이터 행을 선택합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nfiltered_data = data[data['age'] \u003e 18]  # 18세보다 나이가 많은 레코드 선택\n\n```\n\n효율적인 필터링을 위해 부울 인덱싱을 사용하세요.\n\n# 5. 데이터 집계 및 그룹화\n\n`groupby()`를 사용하여 데이터를 그룹화한 다음 집계하세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ngrouped_data = data.groupby('category').mean()  # 카테고리별 평균 계산\n```\n\n데이터 구조와 패턴을 이해하는 데 중요합니다.\n\n# 6. 데이터 시각화: Matplotlib 및 Seaborn\n\n시각화는 데이터를 이해하기 쉽게 만듭니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport matplotlib.pyplot as plt\ndata['value'].hist()  # 히스토그램 그리기\nplt.show()\n```\n\nSeaborn은 상자 그림과 열지도와 같은 고급 차트를 제공합니다.\n\n# 7. 시계열 분석\n\n시간순으로 정렬된 데이터를 처리하세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\ndata['date'] = pd.to_datetime(data['date'])  # 문자열을 날짜로 변환합니다\ndata.set_index('date', inplace=True)  # 날짜를 인덱스로 설정합니다\n```\n\n시계열 데이터를 리샘플링하려면 `resample()`을 사용하세요.\n\n# 8. 데이터 전처리: 표준화 및 정규화\n\n모델 훈련을 위해 데이터를 준비하세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nfrom sklearn.preprocessing import StandardScaler\nscaler = StandardScaler()\nscaled_data = scaler.fit_transform(data[['feature1', 'feature2']])\n```\n\n알고리즘 학습에 도움이 됩니다. 특히 서로 다른 특성 스케일에 대해서 좋습니다.\n\n# 9. 이상 탐지: 특이값 식별\n\n통계적 방법이나 기계 학습을 사용하여 이상값을 식별합니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 기초 감지를 위해 Z-점수 또는 IQR 사용\n- 고급: DBSCAN 알고리즘 사용\n\n```python\nfrom sklearn.cluster import DBSCAN\n\n# 샘플 데이터 생성\ndata = pd.DataFrame({\n    'value1': np.random.normal(0, 1, 100),\n    'value2': np.random.normal(0, 1, 100)\n})\ndata.loc[0] = [10, 10]  # 이상치 추가\n\n# 클러스터링을 위해 DBSCAN 사용\ndbscan = DBSCAN(eps=0.5, min_samples=5)\ndata['cluster'] = dbscan.fit_predict(data[['value1', 'value2']])\n\n# 이상치 표시 (-1은 잡음 포인트 또는 이상치를 나타냄)\ndata['is_outlier'] = data['cluster'] == -1\n\nprint(data)\n```\n\n# 10. 데이터 병합 및 조인\n\n여러 데이터셋을 하나로 결합합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nmerged_data = pd.merge(data1, data2, on='common_column')  # 공통 열을 기준으로 병합합니다.\n\n# 사용자 행동 데이터를 제품 정보와 병합하여 종합적인 분석을 수행합니다.\n\n# 11. 판다스 프로파일링을 사용한 빠른 데이터 탐색\n\n# 데이터 개요를 이해하기 위해 빠르게 데이터 보고서를 생성합니다.\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n!pip install pandas_profiling  # 설치\nimport pandas_profiling\nreport = pandas_profiling.ProfileReport(data)\nreport.to_html(\"data_report.html\")  # HTML 보고서 생성\n```\n\n코드를 많이 작성하지 않고 데이터의 특징에 대한 심층적인 통찰력을 얻을 수 있어요.\n\n# 12. 시계열 예측: ARIMA 모델\n\n미래 추세를 예측하는 고급 도구에요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 데이터가 시계열 형식에 맞는지 확인하세요.\n- `statsmodels`를 사용하여 ARIMA 모델을 구축하세요.\n\n```python\nfrom statsmodels.tsa.arima.model import ARIMA\nmodel = ARIMA(data['value'], order=(5,1,0))  # 예시 매개변수\nresults = model.fit()\nforecast = results.forecast(steps=10)  # 다음 10개의 시간 지점을 예측합니다.\n```\n\nACF 및 PACF 플롯 분석을 기반으로 ARIMA 매개변수를 선택하세요. \n\n# 13. 데이터 정제에서의 정규 표현식\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n텍스트 처리에 강력한 도구입니다.\n\n```js\nimport re\ndata['column'] = data['column'].str.replace(r'\\D+', '', regex=True)  # 숫자가 아닌 문자를 제거합니다\n```\n\n`re` 모듈은 효율적으로 텍스트 데이터를 정리합니다.\n\n# 14. NumPy를 사용한 계산 최적화\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n넘파이는 대규모 수치 계산에 꼭 필요한 라이브러리에요.\n\n```js\nimport numpy as np\nmean_value = np.mean(data['column'])  # 평균을 빠르게 계산해보세요\n```\n\n일반적으로 넘파이 배열 연산은 동등한 판다스 연산보다 빠릅니다.\n\n# 15. 고급 데이터 시각화: 대화형 차트\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nPlotly이나 Bokeh를 사용하여 대화형 차트를 만들어보세요.\n\n```python\nimport plotly.express as px\nfig = px.scatter(data, x='feature1', y='feature2', color='category')\nfig.show()\n```\n\n대화형 차트를 통해 더 깊은 데이터 통찰력을 얻을 수 있어요.\n\n# 결론\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 실전 팁: 실제 데이터셋을 선택하고 데이터 가져오기부터 고급 분석까지 단계별로 적용해 보세요.\n- 도구 활용: 대규모 데이터셋의 경우 Pandas 대신 Dask 또는 Vaex를 고려하여 효율성을 높일 수 있습니다.\n- 참고: 언제나 데이터 개인 정보 보호와 보안을 우선시하며 규정을 준수하세요.\n\n이러한 실용적인 전략과 팁을 적용하면 데이터 분석 능력이 크게 향상될 것입니다.\n\n최신 AI 이야기를 전달받으려면 Substack에서 저희와 연락하여 봐 주세요. 함께 AI의 미래를 함께 만들어요!\n\n최신 Python 이야기를 받아보려면 Substack에서 저희와 연락하여 봐 주세요. 함께 Python을 배우죠!","ogImage":{"url":"/TIL/assets/no-image.jpg"},"coverImage":"/TIL/assets/no-image.jpg","tag":["Tech"],"readingTime":9},{"title":"파이썬과 Sentinel 2 데이터를 활용한 간단한 토지 변화 감지 방법","description":"","date":"2024-07-14 20:26","slug":"2024-07-14-SimplelandchangedetectionmethodologyusingPythonandSentinel2data","content":"\n\n# 소개\n\nYouTube를 둘러보다가 남부 이집트의 Toshka 프로젝트에 대한 매료되는 영상을 발견했습니다. 그 지역 농업에 미친 영향에 흥미가 생겨 이 주제를 더 깊이 알아보았습니다. 프로젝트가 수자원을 활용하고 메마른 풍경을 비옥한 농지로 변화시키는 데 초점을 맞춘 것이 혁명적으로 다가왔습니다. 이 기사에서는 Toshka 프로젝트가 농업에 미치는 영향에 대해 탐구하고, 물과 농업 변화 감지의 간단하고 효과적인 방법을 통해 어떻게 영향을 미쳤는지 살펴보려 합니다. 이러한 접근 방식은 실용적인 것뿐만 아니라 종합적인 사례 연구에서 필수적이며, 실행 가능한 통찰을 제공하지 못할 수 있는 지나치게 복잡한 방법론을 피하기 위한 것입니다.\n\n## 연구 지역\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-SimplelandchangedetectionmethodologyusingPythonandSentinel2data_0.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 준비 사항\n\n이 여정에서는 다음을 설치해야합니다:\n\n- Python 3.10+\n- 시각화를 위한 QGIS 3.X.X +\n\n이 외에도 필요한 것들이 있습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Copernicus 사이트에서 다운로드할 데이터셋은 2024년 4월 말과 2017년의 두 Sentinel 2 2A 이미지를 사용할 예정입니다 (이미지 참조: T36QUL_20170223 및 T36QUL_20240227).\n- 이 데이터는 Copernicus 플랫폼에서 다운로드할 수 있습니다. 데이터 다운로드에 대한 자세한 내용은 문서를 확인해보세요.\n\n# 방법론\n\n수면 및 식물의 변화를 모니터링하기 위해 여러 지수를 사용할 수 있습니다. NDVI는 식물 변화를 감지하는 데 적합하며, 정규화된 수면 차이 지수 (NDWI)는 수면의 변화를 탐지하는 데 효과적입니다.\n\n아래는 채택할 수 있는 기본 방법론의 그림입니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![Image before significant advancement](/TIL/assets/img/2024-07-14-SimplelandchangedetectionmethodologyusingPythonandSentinel2data_1.png)\n\nLet’s take a look at our images. Here is the image before the significant advancement in the project:\n\n![Image before significant advancement](/TIL/assets/img/2024-07-14-SimplelandchangedetectionmethodologyusingPythonandSentinel2data_2.png)\n\nAnd a recent image from last February of this year:\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/TIL/assets/img/2024-07-14-SimplelandchangedetectionmethodologyusingPythonandSentinel2data_3.png)\n\n보시다시피 중요한 변화가 있습니다. 그래서 여기서의 질문은 이러한 변화를 어떻게 감지하고, 또 다른 수준에서 어떻게 양적으로 표현할 것인가 하는 것입니다. 이 프리젠테이션에서는 첫 번째 질문에 초점을 맞추어 농작물과 물에 대한 변화에 특히 집중할 것입니다.\n\n# 실용적인 조치\n\n## 1. 리포지토리(Clone) 복제\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n먼저 변경 감지 스크립트를 가져와 봅시다:\n\n```js\ngit clone https://github.com/kokatic/rs-sentinel2-rf.git\n```\n\n가져와야 할 파일은 아래와 같습니다:\n\n![이미지](/TIL/assets/img/2024-07-14-SimplelandchangedetectionmethodologyusingPythonandSentinel2data_4.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\ns2_ndvi_ndwi_changes.py를 사용할 것입니다. 스크립트를 간단히 살펴봅시다:\n\n```js\nimport numpy as np\nimport rasterio\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import ListedColormap\n\ndef read_band(file_path):\n    \"\"\"GeoTIFF 이미지에서 단일 밴드를 읽어 numpy 배열로 반환하고 메타데이터와 함께 반환합니다.\"\"\"\n    with rasterio.open(file_path) as src:\n        band = src.read(1).astype('float32') # 첫 번째(유일한) 밴드 읽기\n        meta = src.profile\n    return band, meta\n\n...\n\n# 여러 함수와 주요 작업들이 정의되어 있습니다.\n\n...\n\n# 과제에 따라 ndwi_threshold 및 ndvi_threshold 값을 조정하는 등 특정 요구에 맞게 코드를 사용자 정의할 수 있습니다.\n\n# 2. 가상 환경을 만들고 요구 사항을 설치하는 방법:\n```\n\n여러 함수와 주요 작업이 정의되어 있는 기본적인 스크립트이며, 특정 요구에 맞게 코드를 수정할 수 있습니다. 특히 ndwi_threshold 및 ndvi_threshold 값을 필요에 맞게 조정할 수 있습니다.\n\n## 2. 가상 환경 만들기 및 요구 사항 설치:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n현재 작업 폴더 디렉토리 내에서 명령줄 인터페이스를 열어 주세요:\n\n```js\npython -m venv venv\n```\n\n그런 다음 가상 환경을 활성화하세요:\n\nWindows의 경우 (CMD):\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nvenv\\Scripts\\activate\n```\n\nLinux에서는 다음을 실행하세요:\n\n```js\nsource venv/bin/activate\n```\n\n그런 다음 필요한 패키지 설치하세요:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\npip install -r requirements.txt\n```\n\n## 3. 스크립트 실행\n\n스크립트를 실행해 보세요:\n\n```js\npython .\\s2_ndvi_ndwi_changes.py\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n조금 시간이 걸리겠지만, 주요 변경 사항의 이미지를 matplotlib을 사용하여 내보낼 것입니다:\n\n![image](/TIL/assets/img/2024-07-14-SimplelandchangedetectionmethodologyusingPythonandSentinel2data_5.png)\n\n## 4. 결과 해석\n\n각 지수를 독립적으로 확인해 봅시다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNDWI 변화:\n\n물이 이미 운하를 통해 토슈카 호수로 펌프되었다는 사실을 아래에서 확인할 수 있습니다:\n\n![image](/TIL/assets/img/2024-07-14-SimplelandchangedetectionmethodologyusingPythonandSentinel2data_6.png)\n\nNDVI 변화:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n대박, 물은 생명을 부르죠! 이미지 속 2024년 새로운 피벗들이 2017년 이미지 위에 초록색으로 나타나 보이는 것처럼, 물이 성장을 촉진하는 방법을 보여줍니다.\n\n![이미지](/TIL/assets/img/2024-07-14-SimplelandchangedetectionmethodologyusingPythonandSentinel2data_7.png)\n\n두 가지 변경 사항: NDVI 및 NDWI\n\n![이미지](/TIL/assets/img/2024-07-14-SimplelandchangedetectionmethodologyusingPythonandSentinel2data_8.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/TIL/assets/img/2024-07-14-SimplelandchangedetectionmethodologyusingPythonandSentinel2data_9.png)\n\n# 결론\n\nNDVI 및 NDWI 지수를 사용한 분석은 식물 및 물체의 중요한 변화를 시간 경과에 따라 강조했습니다. 서로 다른 연도의 이미지를 비교하면 2024년에 신규 녹색 피벗이 2017년과 비교했을 때 농업 확장에 물 가용성이 미치는 영향을 명확히 보여줍니다. 이는 수자원이 농업 성장과 생태계 건강 유지에 중요한 역할을 한다는 것을 보여줍니다. 이러한 방법의 추가 세부 조정 및 지속적인 모니터링은 미래에 국가적 의사결정과 지속 가능한 자원 관리에 필수적일 것입니다.\n\n# 팔로우 해주세요\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 내 랜딩 페이지\n- 내 Youtube 채널\n- 내 SaaS 서비스\n- 내 GitHub\n\n# 간단한 영어로 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나기 전에:\n\n- 작가를 박수와 팔로우해주세요 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문하기: CoFeed | Differ\n- PlainEnglish.io에서 더 많은 콘텐츠 확인하기","ogImage":{"url":"/TIL/assets/img/2024-07-14-SimplelandchangedetectionmethodologyusingPythonandSentinel2data_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-SimplelandchangedetectionmethodologyusingPythonandSentinel2data_0.png","tag":["Tech"],"readingTime":9},{"title":"AlpineJS와 HTMX로 Dash 애플리케이션 성능 극대화하기","description":"","date":"2024-07-14 20:25","slug":"2024-07-14-SuperchargingDashApplicationswithAlpineJSandHTMX","content":"\n\n![](/TIL/assets/img/2024-07-14-SuperchargingDashApplicationswithAlpineJSandHTMX_0.png)\n\n웹 개발 세계에서는 최고의 도구들을 통합시키면 여러분의 애플리케이션의 기능성과 사용자 경험을 크게 향상시킬 수 있습니다. AlpineJS와 HTMX같은 두 강력한 도구가 있습니다. 이 포스트에서는 이 도구들이 무엇인지, Dash 애플리케이션에 어떻게 통합할 수 있는지, 그리고 몇 가지 실용적인 코드 예제와 사용 사례를 제공할 것입니다.\n\n# AlpineJS 및 HTMX 소개\n\n# AlpineJS란?\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n알파인JS는 Vue 또는 React와 같은 대형 프레임워크의 반응형 및 선언적인 특성을 훨씬 낮은 비용으로 제공하기 위해 설계된 가벼운 JavaScript 프레임워크입니다. HTML에서 간단한 상호작용 및 상태 관리를 직접 처리하는 데 이상적이며, 무겁고 복잡한 JavaScript 프레임워크 없이도 응용 프로그램에 대화식 요소를 추가하는 좋은 선택입니다.\n\n# HTMX란 무엇인가요?\n\nHTMX를 사용하면 최신 브라우저 기능에 HTML에서 직접 액세스하여 웹 페이지에 동적 콘텐츠를 간단하게 추가할 수 있습니다. HTMX를 사용하면 AJAX 요청, WebSocket 연결 및 심지어 서버 전송 이벤트를 간단한 HTML 속성으로 처리할 수 있습니다. 이를 통해 최소한의 JavaScript로 높은 상호 작용성 및 반응성을 갖는 웹 애플리케이션을 생성하는 우수한 도구가 됩니다.\n\n# Dash와 AlpineJS 통합하기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n댓쉬는 대화형 데이터 시각화를 만들기 위해 주로 사용되는 파이썬 프레임워크로, 대시의 기본 기능만으로는 복잡한 프론트엔드 상호작용을 다루기에는 부족할 수 있습니다. 이때 알파인JS가 빛을 발할 수 있습니다.\n\n# 대시 호환성을 위한 알파인JS 접두사 변경\n\n대시는 추가 HTML 태그 속성을 허용하지 않기 때문에 알파인JS에서 기본 x- 접두사를 사용하면 오류가 발생합니다. 이 문제를 해결하기 위해 알파인JS 접두사를 대시에서 허용하는 접두사로 변경할 수 있습니다. 예를 들어, 접두사를 data-x-로 변경하면 이 문제를 해결할 수 있습니다.\n\n다음은 대시 애플리케이션에서 이 작업을 수행하는 방법입니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nimport dash\nfrom dash import dcc, html\n\napp = dash.Dash(__name__)\n\napp.layout = html.Div([\n    dcc.Location(id='url', refresh=False),\n    html.Script(src=\"https://cdn.jsdelivr.net/gh/alpinejs/alpine@v2.x.x/dist/alpine.min.js\", defer=True),\n    html.Script(\n        \"\"\"\n        document.addEventListener('alpine:init', () =\u003e {\n            Alpine.prefix('data-x-')\n        })\n        \"\"\", \n        type='text/javascript'\n    ),\n    html.Div(\n        [\n            html.Button(\"Toggle\", **{'data-x-on:click': \"open = !open\"}),\n            html.Div(\"Hello, AlpineJS!\", **{'data-x-show': \"open\"})\n        ],\n        **{'data-x-data': \"{ open: false }\"}\n    )\n])\n\nif __name__ == '__main__':\n    app.run_server(debug=True)\n```\n\n# 사용 예시\n\n## URL 변경 시 구성 요소 숨기기\n\n현재 URL을 기반으로 AlpineJS를 사용하여 구성 요소를 숨기거나 표시할 수 있습니다. 이를 통해 페이지를 다시로드하거나 복잡한 콜백 설정 없이도 동적 콘텐츠 변경이 가능합니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\napp.layout = html.Div([\n    dcc.Location(id='url', refresh=False),\n    html.Div(\n        \"이 내용은 /some-path에만 표시됩니다.\",\n        **{'data-x-data': \"{ open: window.location.pathname === '/some-path' }\", 'data-x-show': \"open\"}\n    )\n])\n```\n\n## 동적 스타일링 및 상태 관리\n\n사용자 상호작용에 기반하여 구성 요소의 스타일을 동적으로 변경하는 데 AlpineJS를 사용할 수 있습니다. 예를 들어, 클릭 시 구성 요소의 배경색을 변경할 수 있습니다:\n\n```js\napp.layout = html.Div([\n    html.Div(\n        [\n            html.Button(\n                \"버튼 1\", \n                **{'data-x-on:click': \"active = 1\", 'data-x-bind:class': \"{ 'bg-blue-500': active === 1 }\"}\n            ),\n            html.Button(\n                \"버튼 2\", \n                **{'data-x-on:click': \"active = 2\", 'data-x-bind:class': \"{ 'bg-blue-500': active === 2 }\"}\n            )\n        ],\n        **{'data-x-data': \"{ active: null }\"}\n    )\n])\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 로그인한 사용자 이름 표시하기\n\n알파인JS를 사용하여 로그인한 사용자의 이름을 동적으로 표시할 수 있습니다. 사용자 정보를 가져오는 피치 요청을 시뮬레이션하고 HTML을 업데이트하여 사용자 이름을 표시할 수 있습니다.\n\n```js\napp.layout = html.Div([\n    dcc.Location(id='url', refresh=False),\n    html.Script(src=\"https://cdn.jsdelivr.net/gh/alpinejs/alpine@v2.x.x/dist/alpine.min.js\", defer=True),\n    html.Script(\n        \"\"\"\n        document.addEventListener('alpine:init', () =\u003e {\n            Alpine.prefix('data-x-')\n        })\n        \"\"\", \n        type='text/javascript'\n    ),\n    html.Div(\n        [\n            html.Button(\"Toggle\", **{'data-x-on:click': \"open = !open\"}),\n            html.Div(\"Hello, AlpineJS!\", **{'data-x-show': \"open\"})\n        ],\n        **{'data-x-data': \"{ open: false }\"}\n    ),\n    html.Div(\n        \"사용자 정보 불러오는 중...\",\n        **{'data-x-data': \"{ user: null, fetchUser() { fetch('/get-user').then(res =\u003e res.json()).then(data =\u003e this.user = data) } }\", 'data-x-init': \"fetchUser()\"}\n    ),\n    html.Template(\n        \"\"\"\n        \u003ctemplate x-if=\"user\"\u003e\n            \u003cdiv\u003e\n                환영합니다, \u003cspan x-text=\"user.name\"\u003e\u003c/span\u003e님!\n            \u003c/div\u003e\n        \u003c/template\u003e\n        \"\"\"\n    )\n])\n```\n\n이 예제에서는 컴포넌트가 초기화될 때 /get-user 엔드포인트에서 사용자 정보를 가져와 HTML을 업데이트하여 사용자의 이름을 표시합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# HTMX로 Dash 기능 향상시키기\n\nHTMX를 사용하면 HTML 속성에서 직접 AJAX 요청과 같은 기능을 활성화하여 더 동적이고 상호 작용적인 Dash 애플리케이션을 만들 수 있습니다.\n\n# 예제: HTMX를 사용하여 콘텐츠 로드하기\n\nHTMX를 사용하여 추가 콜백 작성 없이 Dash 컴포넌트에 콘텐츠를 로드할 수 있습니다. 예를 들어, div에 데이터를 로드하는 방법:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n```js\napp.layout = html.Div([\n    html.Div(\n        \"데이터를 불러오는 중...\",\n        **{'hx-get': \"/data-endpoint\", 'hx-trigger': \"load\"}\n    )\n])\n```\n\n# 예시: HTMX를 사용한 양식 제출\n\nHTMX는 양식 제출도 원활하게 처리할 수 있습니다:\n\n```js\napp.layout = html.Div([\n    html.Form(\n        [\n            dcc.Input(type=\"text\", name=\"data\"),\n            html.Button(\"제출\", type=\"submit\")\n        ],\n        **{'hx-post': \"/submit-endpoint\", 'hx-swap': \"outerHTML\"}\n    )\n])\n```  \n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론\n\nDash에 AlpineJS와 HTMX를 통합함으로써, 웹 애플리케이션의 상호 작용성과 응답성을 현저히 향상시킬 수 있습니다. AlpineJS는 상태를 관리하고 간단한 상호 작용을 처리하는 가벼운 직관적인 방법을 제공하며, HTMX는 HTML에서 직접 강력한 동적 콘텐츠로딩 및 폼 처리를 가능하게 합니다. 이러한 도구들을 함께 사용하여, 코드 추가를 최소화하면서 더 매력적이고 사용자 친화적인 Dash 애플리케이션을 만들 수 있습니다.\n\n댓글에서 여러분만의 고급 사용 사례와 팁을 공유하십시오. 즐거운 코딩 되세요!","ogImage":{"url":"/TIL/assets/img/2024-07-14-SuperchargingDashApplicationswithAlpineJSandHTMX_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-SuperchargingDashApplicationswithAlpineJSandHTMX_0.png","tag":["Tech"],"readingTime":8},{"title":"1만 5천 달러로 트레이딩 봇 운영하기 단계별 가이드","description":"","date":"2024-07-14 20:24","slug":"2024-07-14-RunningATradingBotWith15000Step-By-StepGuideOnHowToDoIt","content":"\n\n![Binance Testnet](/TIL/assets/img/2024-07-14-RunningATradingBotWith15000Step-By-StepGuideOnHowToDoIt_0.png)\n\n얼마 전부터 거래 봇을 만들고 작업하는 것을 즐기고 있어요. 거의 1.5년 정도예요. 그 과정에서 저는 계정을 활용하면서 Python과 거래 지식을 비동기적으로 향상시켰어요.\n\n오늘의 블로그 포스트에서는 여러분도 자신만의 거래 봇을 개발하고 테스트하는 여정을 시작할 수 있는 방법에 대해 알아볼 거에요! 🤩\n\n자, 시작해봅시다... 🥁... 바이낸스 테스트넷!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 트레이딩 봇을 사용하는 이유\n\n주식 거래란 회사의 주식을 사고 팔아서 가격 변동에 기반해 돈을 벌려고 하는 것을 의미합니다.\n\n![Trading Bot](/TIL/assets/img/2024-07-14-RunningATradingBotWith15000Step-By-StepGuideOnHowToDoIt_1.png)\n\n주식을 암호화폐로 바꾸면 동일한 정의가 됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n거래 전략은 분당 또는 심지어 초당으로 여러 거래를 배치하고 구성할 수 있기 때문에 거래 봇을 활용하여이 프로세스를 자동화하는 것은 많은 사람들에게 매우 유용합니다!\n\n어느 정도까지는 거래의 감정적인 부분을 제거하기도하며, 이것이 많은 경우에 훌륭한 거래자와 나쁜 거래자를 구분하는 중요한 부분입니다!\n\n# 테스트넷이 무엇인가요?\n\n이것은 여러분의 테스트 환경입니다. 바이낸스와 같은 대형 암호 화폐 거래소들은 이를 우리에게 우리의 전략을 테스트하고 수익을 잃지 않도록 도와주는 도구로 제공합니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그 목표는 실제 거래 환경을 모방하지만 `푸가지`(가짜) 돈을 사용하는 것입니다. 💸\n\n![이미지](https://miro.medium.com/v2/resize:fit:490/1*WNIJgycm4pTBkdcFU5Pb5w.gif)\n\n# 환경 설정하기\n\n이제 첫 번째 거래 봇을 개발하고, 바이낸스 테스트넷에서 실행하여 15,000달러의 암호화폐 지갑으로 무엇을 할 수 있는지 살펴봅시다! 🤑\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## IDE 설정\n\n이 프로젝트에서는 VisualStudio Code를 IDE로 사용할 것입니다.\n\nPyCharm이나 다른 개발 플랫폼을 자유롭게 사용해주세요!\n\n## 바이낸스 테스트넷 계정\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음으로, Binance 테스트넷 계정을 설정하세요. 아래는 그 방법을 단계별로 안내해드립니다!👇\n\n마지막에는 테스트넷 계정용 API_KEY 및 API_SECRET이 있어야 합니다.\n\n위 과정을 진행하는 데 어려움을 겪는다면 메시지나 댓글을 남겨주세요. 도와드릴 시간을 내어 도와드리겠습니다! 💪\n\n# 우리의 트레이딩 봇 만들기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리는 미래에 이동 평균을 사용하여 추세를 식별하는데 트레이더 사이에서 인기 있는 도구 중 하나인 바이낸스 선물 거래 봇을 만들 것입니다.\n\n우리는 단순 이동 평균(SMA) 교차 전략을 사용할 것인데, 이는 단기 이동 평균이 장기 이동 평균을 꺾을 때 매수(하이 포지션)하고, 그 반대의 경우에 매도(숏 포지션)하는 전략입니다.\n\n![image](/TIL/assets/img/2024-07-14-RunningATradingBotWith15000Step-By-StepGuideOnHowToDoIt_2.png)\n\n## 1. 이 봇에 사용할 라이브러리를 정의합시다\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nfrom binance.client import Client # pip install python-binance\nfrom binance.enums import *\nimport pandas as pd # pip install pandas\nimport numpy as np # pip install numpy\n```\n\n모두 `라이브러리 이름`을 이용해서 pip install 명령어로 설치할 수 있어요.\n\n## 2. 이제, 우리의 바이낸스 클라이언트를 정의해봅시다.\n\n여기서 매우 중요한 부분인데, `메인 계정이 아닌 Testnet API_KEY 및 API_SECRET을 사용하세요. 메인 계정과는 호환되지 않습니다!\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\r\nAPI_KEY = '\u003c상기 테스트넷 설정 과정에서 생성한 키\u003e'\r\nAPI_SECRET = '\u003c상기 테스트넷 설정 과정에서 생성한 시크릿\u003e'\r\n\r\nclient = Client(api_key=API_KEY, api_secret=API_SECRET, testnet=True)\r\n```\r\n\r\n‼️ API 키와 시크릿을 저장하는 위치와 방법에 주의하세요. 심지어 테스트넷 계정의 경우에도 dotenv와 같은 도구를 사용하여 로컬에 안전하게 저장하고 GitHub에 공개하지 말아주세요! 😅\r\n\r\n## 3. 전략 및 함수 정의\r\n\r\n```js\r\n# 캔들스틱 데이터를 가져오는 함수:\r\ndef fetch_data(symbol, interval, lookback):\r\n    bars = client.futures_historical_klines(symbol, interval, lookback)\r\n    df = pd.DataFrame(bars, columns=['timestamp', 'open', 'high', 'low', 'close'])\r\n    df['close'] = pd.to_numeric(df['close'])\r\n    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')\r\n    return df[['timestamp', 'close']] # 데이터 중 필요한 부분만 반환\r\n\r\n# 주요 전략 로직 및 실행부 👇\r\ndef sma_strategy(symbol='BTCUSDT', interval='1h', short_window=50, long_window=200, lookback='30 days ago UTC'):\r\n    data = fetch_data(symbol, interval, lookback)\r\n    \r\n    data['short_sma'] = data['close'].rolling(window=short_window).mean()\r\n    data['long_sma'] = data['close'].rolling(window=long_window).mean()\r\n    \r\n    # 포지션 없이 시작한다고 가정\r\n    in_position = False\r\n\r\n    # SMA 교차 확인\r\n    # SMA가 LMA를 아래로 교차할 때 (암호화폐 매수)👇\r\n    if data['short_sma'].iloc[-2] \u003c data['long_sma'].iloc[-2] and data['short_sma'].iloc[-1] \u003e data['long_sma'].iloc[-1]:\r\n\r\n        if not in_position:\r\n            print(\"매수 신호!\")\r\n            order = client.futures_create_order(symbol=symbol, side='BUY', type='MARKET', quantity=0.01)\r\n            in_position = True\r\n            print(order)\r\n\r\n    # LMA가 SMA를 아래로 교차할 때 (암호화폐 매도) 👇  \r\n    elif data['short_sma'].iloc[-2] \u003e data['long_sma'].iloc[-2] and data['short_sma'].iloc[-1] \u003c data['long_sma'].iloc[-1]:\r\n\r\n        if in_position:\r\n            print(\"매도 신호!\")\r\n            order = client.futures_create_order(symbol=symbol, side='SELL', type='MARKET', quantity=0.01)\r\n            in_position = False\r\n            \r\n\r\nif __name__ == '__main__':\r\n    sma_strategy()\r\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n너무 세부적으로 언급하지 않겠습니다. 이것은 기본 전략이고 코드는 복잡해 보일지 몰라도 이해하기 어렵지 않습니다!\n\n가장 중요한 점은 이동평균간의 교차점이 발생할 때, 우리는 바이낸스 테스트넷에서 숏 또는 롱 선물 주문을 실행합니다!\n\n## 4. 거래 모니터링\n\n![거래 모니터링](/TIL/assets/img/2024-07-14-RunningATradingBotWith15000Step-By-StepGuideOnHowToDoIt_3.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래에서 아직 실행되지 않은 오픈 주문들을 볼 수 있습니다. 이것은 내가 설정한 가격에 충족되지 않았기 때문에 실행되지 않았습니다.\n\n오른쪽에는 제 계정 잔액을 보실 수 있어요. 현재 약 13k 정도입니다. 좀 더 복잡한 봇을 작업한 결과로, 기능들을 테스트하기 위해 여러 거래를 실행했죠. 😅\n\n설정에 문제가 있거나 도움이 필요하면 언제든지 연락해주세요! 언제든 도움이나 조언을 드릴 수 있어요! 🤲\n\nLinkedIn: https://www.linkedin.com/in/kbor/\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 Markdown 형식으로 변경된 내용입니다.\n\nDiscord: @ konstantinmb\n\nTwitter/X: [https://twitter.com/konstantinmbv](https://twitter.com/konstantinmbv)\n\n# Experiment\n\n![Experiment](/TIL/assets/img/2024-07-14-RunningATradingBotWith15000Step-By-StepGuideOnHowToDoIt_4.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n💪 소프트웨어 엔지니어링 및 다른 분야에서 가장 중요한 모토 중 하나일 거예요. 실제로 실습하는 것을 이길 게 없죠. 스스로 시도해보는 것만큼 가르쳐줄 수 있는 자습서는 없어요!\n\n🆓 바이낸스 테스트넷을 통해 가상 화폐를 사용하고 실제 플랫폼에서 원하는 대로 실험할 수 있어요! 이 프로그래밍 거래 기술을 개발할 수 있는 놀라운 기회라구요!\n\n저도 현재 그렇게 하고 있어요! 함께 해요! 🍻\n\n즐거웠길 바랄게요! 저는 거래 봇을 만드는 것을 좋아하며 여기와 Substack에서 나의 경험을 더 많이 공유할 거에요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기서 다른 블로그도 확인해보세요 👇\n\n이와 함께 👏을 클릭하고 제 프로필 @ Konstantin Borimechkov을 구독해 주세요. 이와 같은 콘텐츠를 더 보고 싶다면!\n\n글쓰기와 지식 공유를 사랑하고 있어요. 여러분의 지원은 저에게 큰 힘이 됩니다! 💚","ogImage":{"url":"/TIL/assets/img/2024-07-14-RunningATradingBotWith15000Step-By-StepGuideOnHowToDoIt_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-RunningATradingBotWith15000Step-By-StepGuideOnHowToDoIt_0.png","tag":["Tech"],"readingTime":9},{"title":"PPDA가 축구에서 어떤 영향을 미치는지 알아보는 방법 수비 효율성 분석","description":"","date":"2024-07-14 20:22","slug":"2024-07-14-DecodingDefensiveEfficiencyUnravelingtheImpactofPPDAinfootball","content":"\n\n수비 조치 당 패스(Passes per defensive action)는 최근 몇 년 동안 등장한 가장 흥미로운 축구 통계 중 하나입니다.\n\n# 목차\n\n- 지표 소개\n- 스크래핑\n- 상관 관계\n- 최종 리그 순위\n- 결론\n\n# 지표 소개\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n수비 조치 당당당시에 이용하며, 이후로 PPDA 라고 칭할 것입니다. PPDA 는 상대방이 공격 팀의 수비 없이 몇 번의 패스를 허용하면서 공을 볼 수 있는지를 측정하는 축구 통계치입니다. 낮은 PPDA 는 공을 보유하기를 원하는 팀이 높은 공격 스타일을 채택한다는 것을 나타냅니다. 이는 공격팀이 수비팀의 저항을 만나기 전에 더 적은 패스를 허용하는 것을 의미합니다. 그런 성격상으로 높은 PPDA 지표는 수비라인을 형성하고 어떤 경우에는 버스 주차 전술을 하는 팀을 나타냅니다!\n\n저희가 필드에서 낮은 PPDA 와 높은 PPDA 의 숫자가 어떻게 시각적으로 보일지 알아보겠습니다.\n\n저의 데이터셋에서 발견된 가장 극단적인 값인 PPDA 152의 예시를 소개하겠습니다! (처음에는 믿기 어렵죠, 첨부된 링크에서 원본 데이터를 확인할 수 있습니다) 2018/19 시즌 바이에른 뮌헨 대 한노버 경기에서 발생한 이 값에서는 한노버팀이 55분부터 10명으로 적혀 있었으나 그래도 그들의 PPDA 허용치는 그들이 굉장히 깊게 수비하고 총 점유율을 허용했다는 것을 나타낸다. 베이언에게는 712회의 총 패스가 이뤄지는 반면, 한노버에게는 310회의 패스만 이뤄졌다. 이 숫자와 관련하여 데이터 유효성 문제가 있을 수 있다고 의심하지만, 게임 하이라이트를 보면 한노버가 얼마나 깊게 수비하고 있는지, 그들의 포메이션이 얼마나 혼란스러운지 즉시 알 수 있습니다. 아래의 사진에서 한 노버의 선수 10명이 본인의 골대 내부에 있어 공을 처리하고 있는 코만에게 외곽 수비작전이라고 인식되는 모습입니다. 이 스냅샷은 전반에서 나온 것이라, 10명으로 줄어든 후에는 단순히 바이에른팀으로부터 가속력을 받지 않도록 하는 것만이 더욱 확실해졌을 것입니다.\n\n![이미지](/TIL/assets/img/2024-07-14-DecodingDefensiveEfficiencyUnravelingtheImpactofPPDAinfootball_0.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n데이터 소스에서 이 예시가 너무 극단적이기 때문에 현재 시즌 23/24에서 웨스트햄 대 맨체스터 시티 경기에서 다른 예시를 살펴봤어요. Understat에 따르면 웨스트햄은 맨체스터 시티에 대해 42.25의 PPDA를 기록했고 맨체스터 시티는 11.4를 기록했어요. Pep의 맨체스터 시티를 공격하려는 것은 대부분의 팀에 대해 좋은 아이디어가 아니기 때문에 웨스트햄은 반격하는 스타일을 선택하고 전반전에 1-0으로 앞서나갔어요. 골 이전에 우리는 수비수들로 이루어진 깊은 라인업을 볼 수 있었는데, 이것은 세계 최고의 팀에 대해 전혀 흔한 것입니다.\n\n![이미지](/TIL/assets/img/2024-07-14-DecodingDefensiveEfficiencyUnravelingtheImpactofPPDAinfootball_1.png)\n\n골 이후에도 계획은 변경되지 않았어요 (그리고 왜 변경되어야 할까요!) 이 시점까지는 영토와 패스를 헌 내어주는 것이 옳은 선택임이 입증되었어요. 맨체스터 시티는 빨리 공을 되찾았지만 전반전에는 파고들기 어려웠어요. 그 모든 것이 후반전에 바뀌기 시작했지만 이제 저 블록이 경기장에 어떻게 나타나는지 시각적으로 확인할 수 있고 대략적으로 그에 따른 PPDA 값은 30 이상입니다.\n\n![이미지](/TIL/assets/img/2024-07-14-DecodingDefensiveEfficiencyUnravelingtheImpactofPPDAinfootball_2.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n반면에 피피다(PPDA) 값이 낮은 것이 경기장에서 시각적으로 어떻게 나타나는지 살펴보겠습니다. 리버풀은 22/23 시즌 노팅엄 숲과의 홈 경기에서 리버풀의 PPDA 값이 2.53으로 기록되었고, 숲의 PPDA 값은 32.45로 나타났습니다. 이를 그림 형식으로 시각화하는 것은 어렵기 때문에 죄송하지만 리버풀은 내 DNA의 유튜브 비디오를 첨부하겠습니다. 클롭 아래의 리버풀의 엉뚱한 프레싱을 볼 수 있습니다.\n\n그래서 이제 우리는 PPDA에 대해 모두 알았습니다. 이 지표의 높고 낮은 값이 경기장에서 실제로 어떻게 나타나는지를 살펴보겠습니다. 이 연습에서 저는 EPL, 라리가, 리그 1, 분데스리가, 세리에 A의 11시즌치 게임 데이터를 수집했습니다.\n\n# 데이터 수집\n\n이전에 언급한 대로 데이터 원천으로 Understat.com을 선택했습니다. 이 사이트는 선수권 선수궁 리그에 관한 포괄적인 무료 데이터 가이드이며 JSON 형식으로 상대적으로 쉽게 스크래핑할 수 있습니다. 다음 코드는 각 리그와 관련된 각 페이지를 브라우징하고 각 팀의 시즌 매치 데이터를 검색한 후 마지막에 약간의 정리를 통해 PPDA 및 PPDA 허용 메트릭스를 변환합니다. PPDA를 팀의 수비력이라고 생각하고 PPDA 허용을 그들이 프레스에 얼마나 잘 저항했는지로 생각할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport json\nimport numpy as np\nfrom selenium.webdriver.chrome.service import Service\nfrom selenium import webdriver\nfrom selenium.webdriver.chrome.options import Options\nfrom selenium.webdriver.common.by import By\nfrom time import sleep, time\nimport pandas as pd\nimport warnings\nfrom bs4 import BeautifulSoup\nimport requests\nimport time\nfrom tqdm import tqdm\nimport re\n\n# 타이머 시작\nstart_time = time.time()\n\nwarnings.filterwarnings('ignore')\n\n# URL을 저장할 빈 리스트 생성\nbase_urls = []\nurls = []\ndf_data = []\n\nseasons = [2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023]\n\nchrome_path = \"C:/usr/local/bin/chromedriver.exe\"\n\n# 'La_Liga', 'Bundesliga', 'Ligue_1', 'Serie_A'\n\ncompetitions = ['EPL', 'La_Liga', 'Bundesliga', 'Ligue_1', 'Serie_A']\n\nfor competition in competitions:\n    for season in seasons:\n        base_url = f'https://understat.com/league/{competition}/{season}'\n        base_urls.append(base_url)\n\n        season_col_value = int(base_url[-4:])\n        competition_value = competition\n\n        # Chrome 옵션 설정\n        chrome_options = Options()\n        chrome_options.headless = True\n\n        # Chrome 서비스 생성\n        service = Service(chrome_path)\n\n        # 서비스와 옵션을 사용하여 Chrome 웹드라이버 생성\n        driver = webdriver.Chrome(service=service, options=chrome_options)\n\n        # URL로 이동\n        driver.get(base_url)\n\n        html_content = requests.get(base_url)\n        # 'html_content'에 HTML 콘텐츠가 있는 것으로 가정\n        soup = BeautifulSoup(html_content.content, 'html.parser')\n        \n        # 지정된 JSON 문자열을 포함한 스크립트 태그 찾기\n        \n        def find_league_standings(tag):\n            return tag.name == 'script' and 'teamsData ' in tag.text\n\n        # match_info를 포함하는 모든 스크립트 태그를 가져오기 위해 사용자 정의 함수 사용\n        league_Standings_html = soup.find_all(find_league_standings)\n\n        league_info = league_Standings_html[0].string\n        \n        ind_start = league_info.index(\"teamsData \") + 24\n        ind_end = league_info.index(\");\\n\") - 1\n\n        json_data = league_info[ind_start:ind_end]\n        json_data = json_data.encode('utf8').decode('unicode_escape')\n        json_data = json.loads(json_data)\n\n        for team_id, team_data in json_data.items():\n            for match_data in team_data['history']:\n                row = {'team_id': team_id, 'team_title': team_data['title'], 'season': season_col_value,\n                       'competition': competition}\n                row.update(match_data)\n                df_data.append(row)\n\ndf = pd.DataFrame(df_data)\n\ndf['ppda'] = df.apply(lambda x: x['ppda']['att'] / x['ppda']['def'] if x['ppda']['def'] != 0 else np.nan, axis=1)\ndf['ppda_allowed'] = df.apply(\n    lambda x: x['ppda_allowed']['att'] / x['ppda_allowed']['def'] if x['ppda_allowed']['def'] != 0 else np.nan, axis=1)\n\ndf['date'] = pd.to_datetime(df.date, format='ISO8601')\ndf = df.sort_values(['date', 'season', 'team_id'], ascending=True).reset_index(drop=True)\n\ndriver.quit()\n```\n\n# 상관 관계\n\n팀의 방어 전략은 상대팀의 품질에 따라 다를 수 있습니다. 이전에 West Ham의 경우에 그들의 접근 방식은 집에서 Sheffield United와는 다를 것입니다. 이에 따라 PPDA 값에 대한 결론을 작은 샘플 크기로 만드는 것은 위험합니다. PPDA와 xPts 사이의 상관 행렬을 살펴보았습니다. 이를 통해 PPDA 점수가 높거나 낮을 때 포인트를 획득할 가능성에 어떤 영향을 미치는지 알 수 있습니다.\n\n관심 있는 줄은 xPts의 맨 아래 줄입니다. 피어슨 상관 계수는 -1에서 1까지의 범위를 갖습니다. 같은 변수끼리 비교할 때 항상 1임을 주의해야 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 1의 값은 완벽한 양의 선형 관계를 나타냅니다.\n- -1의 값은 완벽한 음의 선형 관계를 나타냅니다.\n- 0의 값은 선형 관계가 없음을 나타냅니다.\n\n![image](/TIL/assets/img/2024-07-14-DecodingDefensiveEfficiencyUnravelingtheImpactofPPDAinfootball_3.png)\n\nxG가 가장 강한 상관관계가 있음을 볼 수 있습니다. 이는 xPts 메트릭이 이 수치로부터 계산되기 때문에 놀라운 것은 아닙니다. PPDA 기록은 -0.27이고 PPDA 허용은 0.29입니다.\n\n이는 PPDA에 대해 xPts와 더 약한 음의 관계가 있다는 것을 의미합니다. -0.29의 상관 계수는 두 변수가 반대 방향으로 움직일 경향이 있다는 것을 나타냅니다. 그러므로 PPDA가 낮아지면 xPts가 증가하는 경향이 있지만 상당히 작은 관계라고 말할 수 있습니다. 세계 최고의 팀이 하이 프레스 스타일로 경기를 펼치고 있기 때문에 이것이 발생하는 것일 수도 있습니다. 그 반대로, PPDA 허용은 xPts와 양의 관계가 있어 한 변수가 증가하면 다른 변수도 증가하는 경향이 있습니다. 다시 말하면, 이 결과에 대한 내 가능한 가설은 게임 상태와 관련이 있는 것입니다. 팀이 이제 이기고 있으면 영토와 점유율을 양보하고 수비적인 접근을 취하게 될 가능성이 높으므로 이 결과는 어느 정도 이치에 맞는 것으로 생각됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n0-0로 끝난 모든 게임을 살펴봤는데, 게임 상태 관련 성능을 개선할 수 있는지 확인했습니다. 같은 부정적(PPDA) 및 긍정적(PPDA_ALLOWED) 측면이 여전히 나타납니다. 그들 간의 상관 관계 차이가 약간 좁아졌습니다. PPDA_ALLOWED가 xPts에 더 강한 상관 관계를 보이는 이유에 대한 제 생각은, 격찬된 게임에서 특히 막판에 경기 관리가 매우 중요한 요소이며, 축구가 득점이 적은 스포츠이기 때문에 공을 더 잘 지켜내는 능력이 상대편보다 더 많은 예상 포인트를 의미한다는 것입니다.\n\n![image](/TIL/assets/img/2024-07-14-DecodingDefensiveEfficiencyUnravelingtheImpactofPPDAinfootball_4.png)\n\n위 도표에서 나타나는 것은 PPDA 및 PPDA_ALLOWED가 중요하지만 xG 및 xG 허용과 같은 다른 통계요소들과 마찬가지로 xPts와 실제 경기 결과를 결정하는 데 중요하다는 것입니다. 하지만 이러한 값들이 완전히 중복되는 것은 아닙니다.\n\n# 최종 리그 순위\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음 섹션은 평균 PPDA 및 허용된 PPDA를 조사한 내용 및 최종 리그 순위에 미치는 영향에 대해 설명합니다. 각 시즌의 챔피언들이 기록한 것과 각 팀이 어떻게 성적을 올렸는지 살펴보고 싶었어요.\n\n먼저 EPL의 최종 순위 표에서 PPDA 및 PPDA_ALLOWED의 평균 값을 살펴봅시다. 도표 3는 매우 흥미로운데요, xPts의 감소는 현재 시즌이 아직 끝나지 않았기 때문입니다. PPDA 관점에서 모든 리그 챔피언들이 공통적으로 갖는 특징은 낮은 수치입니다. 대부분의 시즌에서 20 이하로, 이는 리그 우승을 차지하는 팀들이 좋은 압박을 가하는 팀이며 개입하기 전에 많은 패스를 허용하지 않습니다. 여기서 초록색 막대기는 맥락을 고려하면 매우 중요합니다. 높은 숫자는 리그 챔피언들이 압박에 대해 보유를 성공적으로 유지했음을 의미합니다. 2016년에는 2015년의 콘테의 첼시 이후 숫자가 감소했습니다. 그 이유는 레스터시티입니다! 이 지표에서 꽤 이상한 값들을 보여주는 것은 기억에 남는데, 우리는 그들의 저 공격 높은 수비적인 플레이를 기억합니다. 그러나 시각적으로 이후에 보는 것과는 상반되는 많은 점이 있습니다. 더 많은 보유를 하는 팀이 지속적으로 리그에서 승리했습니다.\n\n실제로, 이러한 데이터를 모든 대회로 확장할 때 추세는 계속 유지됩니다. 이 지표는 리그별로 집계된 중앙값입니다. 리그 챔피언들이 효과적이고 빠르게 공을 회수하며 압박에 저항하는 능력이 뛰어나다는 점을 나타내는 낮은 ppda 값과 높은 ppda_allowed 값들은 그대로 유지됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n친구 같은 톤으로 위의 텍스트를 한국어로 번역해드리겠습니다.\n\n재미있는 점은, 지난 시즌 최하위로 끝난 팀으로 계산을 할 때 PPDA 값이 높고, PPDA_ALLOWED 값은 훨씬 낮습니다. 이는 이러한 팀들이 공을 되찾는 데 효과가 떨어지고, 더 중요한 것은 압박에 저항하는 데 얼마나 별로인지를 보여줍니다.\n\n# 결론\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nPPDA는 경기 분석을 기반으로 한 유용한 측정 항목으로, 팀이 수비적으로 전술적으로 어떻게 동작하는지 통찰력을 제공합니다. 그러나 한 경기에 대한 결과를 토대로 오랜 기간의 결론을 내리는 것은 위험할 수 있습니다. 왜냐하면 팀들은 분명 약한 상대에 대해 다르게 설정할 것이기 때문입니다. 상관 관계 플롯은 PPDA와 xPts 사이에 약한 음의 관계를 나타내며, PPDA 값이 낮아질수록 xPts가 증가하는 경향이 있음을 보여줍니다. 반면 PPDA_ALLOWED는 약한 양의 상관 관계를 유지했습니다. 축구는 공격과 수비의 경기이며 점수 획득 관점에서 볼 때, 이 분석은 ppda 지표 측면에서 방어가 공격보다 중요함을 나타냅니다. 이러한 지표 자체가 여러 시즌 동안 리그 챔피언은 일반적으로 낮은 PPDA 값을 가지고 있고 높은 PPDA_ALLOWED 값을 가지며 이 두 가지가 결합하여 그들의 우위를 표현함을 증명합니다. 강등된 팀들, 즉 실제 점수 측면에서 그 시즌에 그 부문에서 최악의 팀들은 상당히 높은 PPDA 값을 가지고 있고 매우 낮은 PPDA_ALLOWED 값을 보여주며, 그들이 프레싱과 공 보유에서 얼마나 약한지를 나타냅니다.\n\n내견은 ppda 지표가 전혀 관련이 없는 것은 아니지만 장기적으로 팀의 능력을 종합적으로 제공하는 다른 설명적 게임 지표와 결합하여 유용합니다. 공격 코치들은 팀의 ppda 지표에 주의를 기울여야 합니다. 웨스트햄처럼 팀이 아스널에 대해 동일한 방식으로 세팅할 가능성이 높고 그에 따라 계획하도록 해야 합니다. 마찬가지로 맨체스터 시티와 경기하는 팀들은 그들에게 고 프레싱을 피해야 할 것입니다. 그것은 엘리트 선수들이 계속적으로 이용할 수 있는 커다란 간격으로 이어질 가능성이 높기 때문입니다. 그들이 경기를 영향력을 가지고 더 위에서 더 높은 위치에서 수비하는 유사한 도구와 능력을 가지고 있지 않는 한. 나는 아스날을 바라보고 있어요.","ogImage":{"url":"/TIL/assets/img/2024-07-14-DecodingDefensiveEfficiencyUnravelingtheImpactofPPDAinfootball_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-DecodingDefensiveEfficiencyUnravelingtheImpactofPPDAinfootball_0.png","tag":["Tech"],"readingTime":12},{"title":"Python 덕분에 250만 원 절약한 방법 그리고 큰 골칫거리를 피한 비결","description":"","date":"2024-07-14 20:20","slug":"2024-07-14-PythonSavedMeOver2500andaMajorHeadache","content":"\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-PythonSavedMeOver2500andaMajorHeadache_0.png\" /\u003e\n\n약 1년 반 전에 나는 남동 펜실베니아 소도시에서 나시빌, 테네시로 일하기 위해 이사했습니다. 그 지역에서는 어릴 때 한 지역에서 자랐고 다른 지역에서 엔지니어링 역할로 일했던 경험이 많았습니다. 당시 치과의사(이웃 포함)를 좋아했고, 함께 쌓아온 관계와 상생을 대신할만한 사람을 찾는 데 어려움을 겪었습니다. 다른 미국 사람들처럼 나도 치과에 대한 작은 두려움을 가지고 있고, 치과용 픽스와 드릴에 대해 생각하면 맥박이 조금 빨라집니다. 나시빌로 이사한 후에 새로운 임대 계약을 체결하고 주소를 변경하고 새 은행과 일반 의료 제공자를 구하며 그러한 성인들이 필요로 하는 새로운 자원을 찾아다니는 과정에서 나는 권장되는 6개월 간격의 치과 클리닝을 약간 소홀히 하게 되었습니다. 결국 나는 내 치과 보험 웹사이트를 살펴보아 우편번호에서 20분 이내 거리에 있는 새로운 제공자를 찾았고 결과에 압도당했습니다.\n\n그건 엄청난 양이며, 게다가 MetLife 웹사이트는 실제로 나에게 필요한 데이터량을 제공하지 않아 결과를 필터링하기에 내게 큰 어려움을 줍니다. 대부분의 환자들에게는 필터링을 위한 제공된 기준이 중요하지 않을 것이기 때문입니다. 아래에 예시가 있습니다.\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-PythonSavedMeOver2500andaMajorHeadache_1.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n일반적인 식별 정보인 이름 및 연락 정보뿐만 아니라 신규 환자, 언어, 교육 등에 대한 세부 정보도 포함되어 있습니다. 대부분의 경우 추가 필터는 경계 조건을 강조하며, 필터가 비영어권 사용자나 특정 전문 분야를 선호하는 사람들에게 적합한 경우가 있지만, 주로 \"신규 환자 접수\"가 모두가 활성화하기를 원할 유일한 필터입니다. 또 다른 불평은 특정 실천법이나 회사를 제거하는 것과 같이 집계용 필터가 없다는 것입니다. 저는 지역과 강한 평판을 가진 \"맘앤팝\" 치과 의사들을 국가적인 치과 의사 대기업보다 선호하며, 주관적으로 더 많은 쿠키 커터 및 비인간적인 상황을 경험했습니다. 책임을 물을 리뷰도 표시되지 않습니다!\n\n몇 달 전 가장 가까운 치과의사에게 예약을 했는데, 그는 현재 신규 환자를 받고 있었고, 그곳은 대규모 체인의 사무실이었습니다. 불행히도, 최고의 경험을 하지 못했습니다. 치과 위생사가 치은을 닦는 동안 조금 거칠었고 나에게 따뜻함을 느끼지 못했습니다. 그럼 의사가 나에게 내 엑스레이 사진을 가져왔습니다. 서로 인접한 둘의 모알이가 뿌리 치료 및 치아 왕관으로 교체되어야 한다고 생각했습니다. 정말 깜짝 놀랐습니다! 저는 통증이나 민감도, 그 곳에 대한 부정적인 느낌이 없었습니다. 엑스레이는 뿌리에서 검은 선이 보였는데, 그에게 \"뿌리 채과나 안녕과 상관없이 추가적인 부패일 수 있지만 뿌리 치과로 대체되어야 한다\"고 말했습니다. 어차피 어떤 치료 전 단계로서 뿌리 치료가 거의 마지막 단계라고 하자, 증상이 치료를 정당화할 때까지 어떤 치료도 보류하겠다고 말했습니다.\n\n지난 달, 제 몇 개의 어금니가 아프다는 느낌을 느끼기 시작했습니다. \"문제 치아\"뿐만 아니라 전체적으로 입안이 괴로웠습니다. 저는 항상 수면 중에 이감요증이라는 습관이 있었고 아마 이것이 휴일 스트레스와 너무 많은 여행을 관통했을 수도 있습니다. 이번에도 두 번째 방문한 같은 치과 의사는 다른 변화를 의심하지 않았지만 이제 빨리 뿌리치료를 강조하며 다음 주에 시간이 있는지 물어보았습니다. 저는 연말에 시간이 날 것이며 견적을 요청했습니다.\n\n보험 없이는 수술, 노동 및 재료에 대해 1만 달러 이상의 요금을 부담해야 했을 것이며, 이는 당신의 고용주가 제공하면 보험 가입이 중요함을 미국의 모든 독자들에게 알리는 교훈이되어야 합니다. 제 보험으로는 그 금액이 2,500 달러로 줄었습니다. 여전히 엄청난 금액이지만 이전 숫자보다 훨씬 부담이 적었습니다. 또한 내 보험에 직접 청구된 몇 가지 의심스러운 요금을 발견했습니다. 그것을 \"사기\"라고 단정하진 않지만, 절대적인 긴급 상황이 아닌 한 돌아가지 않기로 결정했습니다. 그 후 다른 치과를 찾기로 결정했습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n새 의료 공급업체를 찾는 가장 좋은 방법이 무엇인가요? 이 문제에 대한 충고를 열 명의 다른 사람에게 물어보면 열 가지 다른 답변을 받을 것 같아요. 저는 먼저 지역 사람들이 신뢰하는 사람과 내 보험을 받는 사람에 대해 알고 싶었어요. 추천 사항을 공유하는 지역 주민을 위한 페이스북 그룹에 가입했어요. 삼 개의 서류를 전화로 확인해 보았는데 모두 내 보험을 받지 않았어요. 그 후 나시빌에 몇 년간 살았던 동료에게 선호하는 의료 공급업체에 대해 물어봤어요 — 그래도 즉시 의견을 얻을 수 없었어요. 많은 사무실들이 단순히 연휴로 인해 휴무 중이었고 1월 중후 다시 오픈할 예정이었어요. 이웃들에게 선호하는 곳을 물어봤더니 마침내 제가 찾던 답을 얻었어요. 그 사이트에는 내 보험을 받는다고 명시되어 있었지만 전화한 결과 새해에는 더 이상 보험을 받지 않는다고 밝혀졌어요. 어이쿠.\n\n전화와 웹사이트를 번갈아가며 다섯-여섯 일 동안의 시간을 보낸 후, 나에게 가장 적합한 치과의사를 찾는 나만의 해결책을 찾을 수 있는지 보기 위해 다시 보험사의 웹사이트를 방문하기로 결정했어요.\n\n## 웹사이트 읽기\n\n제공자를 식별하기 위한 도구를 구축하는 첫 번째 단계는 보험사의 웹사이트가 어떻게 작동하는지 이해하는 것이에요. Chrome 화면 (또는 비슷한 명령을 갖춘 다른 선택한 브라우저) 내에서 마우스 오른쪽 버튼을 클릭하고 시트를 \"검사\"하는 것으로 할 수 있어요. 구체적으로는 \"Fetch/XHR\" 선택에서 JSON 또는 유사한 데이터 기반의 쿼리와 응답을 찾으며 이것들을 발견할 수 있어요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-PythonSavedMeOver2500andaMajorHeadache_2.png\" /\u003e\n\n다양한 응답을 살펴보면 실제 창에서 보았던 결과에 대한 의미 있는 데이터를 찾아냈어요. \"API\" 호출의 내용이 환자들에게 표시된 결과를 채우는 것을 발견했지요. 구체적으로, 각 치과 의사에 대한 데이터를 볼 수 있었고, 실제 고객에게 표시된 것보다 더 많은 데이터가 백엔드에 있었어요. 엄청난 일이지요! 리뷰까지도 존재했어요! 쿼리에서 인식하기 어려운 나쁜 요소들이나 제 참여를 원하지 않는 실천단체들을 제거하는 것이 얼마나 유용한지 알 수 있었겠죠. 여기에는 응답에서 선택 가능한 기준의 완전한 목록이 있어요:\n\n```js\nIndex(['links', 'item.number', 'item.self', 'item.name.firstName',\n       'item.name.middleName', 'item.name.lastName', 'item.name.suffix',\n       'item.businessName', 'item.acceptsNewPatients', 'item.genderCode',\n       'item.typeCode', 'item.specialties', 'item.degrees', 'item.networks',\n       'item.languages', 'item.distance.value', 'item.distance.unitCode',\n       'item.distance.unitDescription', 'item.phoneNumbers', 'item.addresses',\n       'item.locationCoordinate', 'item.emails', 'item.websites',\n       'item.extension.facilityNumber', 'item.extension.preferredName',\n       'item.extension.visitHours',\n       'item.extension.isSpecialNeedsCareAvailable',\n       'item.extension.hasHospitalAdmitPrivileges',\n       'item.extension.isProviderAvailableByReferral',\n       'item.extension.admitPrivilegedHospitals',\n       'item.extension.nationalProviderIdentifier',\n       'item.extension.isBoardCertified', 'item.extension.licenseNumber',\n       'item.extension.hasHandicapAccess', 'item.extension.vendors',\n       'item.extension.memberOfNetwork',\n       'item.extension.isYelpCacheRefreshEnabled', 'item.genderDescription',\n       'item.typeDescription', 'metadata.lastModifiedDate',\n       'item.extension.yelpReviews.providerCode',\n       'item.extension.yelpReviews.businessIdentifier',\n       'item.extension.yelpReviews.businessName',\n       'item.extension.yelpReviews.self',\n       'item.extension.yelpReviews.reviewCount',\n       'item.extension.yelpReviews.rating',\n       'item.extension.businessIdentifier', 'item.extension.localmedURL'],\n      dtype='object')\n```\n\n다음 과제는 Python으로 이 과정을 시뮬레이션하여 1,500개 이상의 결과 중 25개씩이 아니라 전부를 추출하고 필터링 및 조사할 수 있는 포괄적인 데이터 세트를 작성하는 것이었어요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n비교적 간단하게 해결할 수 있습니다. 필요한 몇 가지 라이브러리만 사용하면 됩니다. 아래에서 해당 라이브러리를 구현해보겠습니다.\n\n```js\nimport requests\nimport json\nimport pandas as pd\nimport time\n```\n\n다음으로는 웹 사이트에 발행할 로드를 미리 입력해야 합니다. 이를 위해 쿠키, 헤더 및 JSON 데이터를 구성해야 합니다. 이 작업은 수동으로 수행하는 것이 까다로울 수 있습니다. Chrome은 간단한 \"파이썬으로 페이로드 복사\" 기능을 제공하지 않지만, 검사 화면에서 API 응답을 선택하고 마우스 오른쪽 단추로 클릭하여 \"curl로 복사\"할 수 있습니다. 그런 다음 온라인 웹 서비스인 curl converter를 사용하여 이를 파이썬으로 변환할 수 있습니다.\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-PythonSavedMeOver2500andaMajorHeadache_3.png\" /\u003e\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 표를 Markdown 형식으로 변경해 주세요.\n\n웹사이트마다 모든 쿠키와 헤더가 필요한 것은 아니지만, 저희는 단순히 우리 연결로부터 웹사이트가 일반적으로 받는 것을 모사하고 있기 때문에, 다른 웹사이트에 대한 쿼리를 구성하는 데 조정이 필요할 수 있다는 점을 참고해 주세요. 또한 웹 스크레이핑은 책임있게 수행되어야 합니다 — 즉, 윤리적이고 적절한 허가를 받은 경우에 진행되어야 하며, 응답 서버를 악의적으로 과도하게 무리하게 하는 일이 없어야 합니다. 그러나 몇 분에 걸쳐 각각의 데이터를 선택하면, 이 웹사이트에서 한 번 선택하는 것만으로는 일반적인 응답을 클릭하는 것보다 큰 영향을 미치지 않았습니다.\n\n다음 스크립트를 사용하여 Python으로 데이터를 검색할 수 있습니다.\n\n```js\n쿠키 = {\n  #쿠키 내용 입력\n}\n\n헤더 = {\n  #헤더 내용 입력\n}\n데이터_리스트 = []\nfor i in range(0, 27):\n    페이지 = 50 * i\n    json_데이터 = {\n        'operation': 'dispatch',\n        'data': {\n            'origin': '/findDentist?searchType=findDentistMetLife\u0026networkID=1\u0026zip=37209\u0026qsType=DPPO',\n            'screenId': 'us-metlocator-screen',\n            'viewId': 'view-us-metlocator-container',\n            'eventName': 'clickPagination',\n            'eventData': '/v1/tenants/{tenantId}/providers/search?product.typeCode=200\u0026product.nameCode=202\u0026networks.typeCode=N001\u0026locationCoordinate\u0026radius.value=25\u0026radius.unitCode=301\u0026limit=50\u0026'+f'offset={페이지}\u0026orderBy=distance.value,name.lastName,name.firstName',\n        },\n    }\n\n    응답 = requests.post('https://providers.online.metlife.com/findDentist/api', cookies=쿠키, headers=헤더, json=json_데이터)\n    print(len(응답.text))\n    데이터 = 응답.json()\n    제공자 = 데이터['presentation']['views']['update'][1]['model']['application']['responseFromPagination']['items']\n    df = pd.json_normalize(제공자)\n    데이터_리스트.append(df)\n```\n\n위의 코드에서 출력을 offset을 채워가며 페이지를 반복하고 있는 것을 알 수 있습니다. 처음 50개 결과 이후에는 offset을 50으로 설정하여 그 다음 50개, 100개, 150개 등을 보려 합니다. 모든 결과를 반복하려면 필요한 총 페이지 수를 통해 범위를 설정할 수 있습니다. 각 응답마다 JSON 응답을 pandas 데이터프레임으로 정규화하고 모든 응답의 목록을 작성하고 있습니다. pandas 데이터프레임은 우리 목적에 따라 필터링하고 조작할 수 있는 테이블과 동의어입니다. 우리가 필요한 데이터만 추출하는 프로세스는 각 웹사이트의 응답에 따라 맞춤화되어야 합니다. 이 작업은 노트북에서 시행착오가 필요할 수 있습니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n마스터 = pd.concat(list_of_dfs) \n마스터\n```\n\n그런 다음에 우리는 모든 응답을 하나의 큰 데이터프레임으로 연결할 수 있어요. 보여지는 결과는 적절한 데이터프레임이 어떻게 보일지에 대한 예시를 보여줘요.\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-PythonSavedMeOver2500andaMajorHeadache_4.png\" /\u003e\n\n이전에 지정한 응답에서 모든 열을 선택했다는 점을 주목해 주세요! 우리는 이 값들을 다루어 우리가 적절하다고 생각하는 데이터를 필터링하거나 데이터셋을 확장하기 위해 이 데이터셋을 결합할 수 있어요. 제 경우에는 Yelp 리뷰와 카운트를 문자열 응답에서 숫자로 변환하고 5점 평점을 가진 치과 의사만 보기 위해 필터를 추가했어요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nmaster['item.extension.yelpReviews.rating'] = pd.to_numeric(master['item.extension.yelpReviews.rating'])\nmaster['item.extension.yelpReviews.reviewCount'] = pd.to_numeric(master['item.extension.yelpReviews.reviewCount'])\nmaster[master['item.extension.yelpReviews.rating']==5]\n```\n\n제가 수천 명의 치과의사 목록을 42명까지 줄였어요. 그후에 해당되지 않는 전문분야를 수동으로 제외하고 새 환자를 받는 병원을 선택했고, 계속 진행하려 했던 병원을 찾았어요. 그리고 구글 리뷰 시스템을 참고한 결과, 해당 병원은 5성급 평가를 받은 리뷰가 300개가 넘었고 전화를 걸었어요. 새 환자를 받고 있었을 뿐만 아니라 다음 주에 예약을 잡을 수 있었어요!\n\n치과 진료 날이 드디어 다가왔어요. 병원으로 들어가자마자 매우 친절한 스태프와 안심할 수 있는 치위생사에 의해 맞이받았어요. 추가적인 엑스레이를 찍었고, 진단에 대한 두 번째 의견을 듣기 위해 치과의사를 만났어요. 의사는 의심스러운 치아 어느쪽에 대해서도 뿌리 채움을 권장하지 않았을 뿐만 아니라, 채우는 것도 하고 싶지 않았어요! 안도가 되는 순간이었어요! 엑스레이를 확인한 후, 그는 채우기물의 색상이 약간 다른 것은 단지 혼성재료의 유형 때문에 뿐이라고 믿었고, 그 이후 많은 경험으로 이에 대해 처리해 온 상황들이라했어요. 심지어 그는 치아조각도 만지고 싶지 않았어요! 그러나 그는 뚜렷한 씹고 이물질이 생겼다는 증거를 발견했고, 이것이 일반적인 예민성을 높이고 있다는 것을 알아채고, $2,500에 비해 $50으로 만들어진 입냄새보호대를 처방하고 싶어했어요. 난 동의했고, 빠른 장착을 위해 3D 스캔을 했고 서류에 서명했어요. 그 후로 따뜻한 수건과 선물 가방을 받고 길을 나가기 전에 이야기를 나누었어요. 아무래도 이 보수적인 방법이 나에게 편안해요, 가다가 한날 채움물을 더 교체하는 엄청난 절차를 필요로 할 때일지라도 말이에요. 나중에 6개월간의 재방문을 똑같은 제공 업체로 잡았어요.\n\n모든 날이 파이썬을 사용해 문제를 해결할 수 있는 것은 아니지만, 일상적인 문제를 해결하도록 데이터 과학을 활용할 수 있게 되어 있다면 항상 신나는 일이에요. 여기서 사용한 방법과 문제 해결 프로세스를 사용하여 더 나은 의료 전문가를 찾고, 불편을 피하며, 당신에게 관련된 정보에 대한 품질과 접근성을 향상시킬 수 있기를 바랍니다. 또한 보험회사에 당신의 상황에 적절한 정보를 제공하도록 요청하여 우리가 건강에 대해 판단할 수 있도록 하고, 그에 따라 우리의 삶도 더 나아질 수 있기를 바라요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 것과 다르게 하고 싶은 점이 있으면 자유롭게 아래에 알려주세요. 그리고 LinkedIn에서 연결하고 네트워킹을 하고 싶어요!","ogImage":{"url":"/TIL/assets/img/2024-07-14-PythonSavedMeOver2500andaMajorHeadache_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-PythonSavedMeOver2500andaMajorHeadache_0.png","tag":["Tech"],"readingTime":12},{"title":"초고속 언어 Mojo 간단 소개  Python의 슈퍼셋","description":"","date":"2024-07-14 20:18","slug":"2024-07-14-AQuickIntroductiontoMojoaSupersetofPythonThatIsSuperFast","content":"\n\n\n![Mojo Language](/TIL/assets/img/2024-07-14-AQuickIntroductiontoMojoaSupersetofPythonThatIsSuperFast_0.png)\n\n2023년에 등장한 Mojo라는 새로운 언어가 눈에 띄게 화제가 되었습니다. Swift 프로그래밍 언어의 원조 아키텍트 인 크리스 라트너에 의해 만들어졌습니다. Mojo는 Python의 상위 집합으로 설계되었습니다. 구문은 Python과 매우 유사하여 Python 개발자들에게 매우 친숙합니다.\n\nMojo는 컴파일 언어이며 Python보다 훨씬 빠릅니다. 특히 ML/AI 관련 계산을 위해 최적화되어 있어 일반 Python 개발자들에게 흥미롭고 도움이 될 수 있습니다.\n\n이 게시물에서는 Mojo의 매우 기본 개념을 소개하고 Python과 비교합니다. Python과 비교했을 때 Mojo의 구문과 효율성에 놀라실 것입니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 왜 모조?\n\nMojo는 현재 AI 회사 모듈러(Modular)에서 개발한 프로프리어터리(소유권이 있는) 프로그래밍 언어로, 복잡성을 제거하고 AI 개발에 유연성과 속도를 더하는 확장 가능하고 통합된 AI 플랫폼을 구축하는 것을 목표로 합니다. 그리고 이 플랫폼을 위해 개발된 새로운 언어인 Mojo는 AI 인프라 확장 및 가속화 문제를 해결하기 위해 개발되었습니다. 이 언어는 현대 CPU 및 GPU를 포함한 이종 하드웨어에 이상적인 컴파일러 인프라인 MLIR로 구축된 첫 번째 프로그래밍 언어입니다. 요약하자면, Mojo는 AI를 위한 새로운 언어입니다.\n\n## Mojo와 Python\n\nMojo는 Python의 슈퍼셋(또는 고급 버전)으로 디자인되었으며, TypeScript가 JavaScript의 슈퍼셋인 것과 유사합니다. 이것은 JavaScript를 크게 향상시키는 것처럼 Python 개발자들이 Mojo를 시작하는 것이 매우 쉽다는 것을 의미합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파이썬은 머신 러닝/인공지능 및 기타 많은 분야에서 주목받는 언어입니다. 특히 데이터 관련 분야에서는 파이썬이 많이 사용됩니다. 그러나 파이썬은 저수준 성능과 동시성을 위한 글로벌 인터프리터 잠금(GIL) 등의 문제가 있습니다. 이러한 문제들은 오랫동안 파이썬 개발자들에게 머리아픈 문제였으며, 사람들이 파이썬이 느리고 동시성이 떨어진다고 말하는 부끄러운 이유입니다. 이는 또한 파이썬 개발을 제한시키는 중요한 사실이며, 이로 인해 파이썬이 모든 핵심 기능이 C와 같은 더 효율적인 컴파일된 언어로 개발된 '접착제 언어'로 끝나게 되었습니다.\n\nMojo는 파이썬의 인기와 간편함과 C 및 Rust와 같은 컴파일된 언어의 효율성 사이의 간극을 메우기 위해 디자인되었습니다. Mojo는 활발하게 파이썬 커뮤니티를 수용하고, 컴파일 및 메모리 관리와 같은 모든 복잡성을 숨겨 효율적인 코드 실행을 위해 배경에서 발생하는 작업을 쉽고 쉽게 만들려고 노력합니다.\n\n이 게시물에서는 Mojo의 기본 사항을 직접 Python과 비교하여 안내합니다. 변수, 함수 및 구조체와 같은 언어 기본 사항을 소개할 것입니다. 마지막으로, 동일한 코드 조각에 대한 Mojo와 Python의 효율성을 비교하고 Python 코드를 Mojo에서 직접 실행하는 방법을 알려드릴 것입니다. 그러면 이 새로운 언어에 대해 더 나은 이해를 얻을 수 있고, 귀하의 특정 영역에서의 사용 가능성을 확인할 수 있을 것입니다.\n\n## Mojo 설치\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 명령어를 사용하여 Linux 컴퓨터에 Mojo를 설치할 수 있어요:\n\n```js\ncurl https://get.modular.com | sh - \u0026\u0026 \\\nmodular auth mut_73b76eabd7a04555be4daa751d3e7088\n\nmodular install mojo\n```\n\n다른 플랫폼에 대한 지침은 여기서 찾을 수 있어요.\n\n설치가 완료되면 콘솔에서 Mojo를 설정하는 지침이 표시될 거예요:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![Mojo Introduction 1](/TIL/assets/img/2024-07-14-AQuickIntroductiontoMojoaSupersetofPythonThatIsSuperFast_1.png)\n\nCopy and run the corresponding commands for your shell so you can start using Mojo:\n\n![Mojo Introduction 2](/TIL/assets/img/2024-07-14-AQuickIntroductiontoMojoaSupersetofPythonThatIsSuperFast_2.png)\n\nThe `print` command works the same as in Python, and we've just written our first \"Hello World\" code in Mojo!\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n모조 REPL을 종료하려면 Python의 quit()이나 iPython의 exit과 달리 콜론(:)을 누르고 quit를 입력해야 합니다.\n\n## 변수\n\nPython과 비슷하게, Mojo에서도 이름과 값을 가진 변수를 만들 수 있습니다:\n\n```js\n  1\u003e x = 1 \n  2.  \n(Int) x = 1\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음과 같이 선언된 변수는 변할 수 있으므로, mutable합니다:\n\n```js\n  2\u003e x = 2 \n  3. print(x) \n  4.  \n2\n```\n\n그러나 Mojo는 엄격한 유형을 가지고 있기 때문에 변수의 유형을 변경할 수 없습니다:\n\n```js\n  4\u003e x = \"a\" \n  5.  \n[사용자] 오류: 표현식 [2]:1:5: 대입 중에 'StringLiteral' 값을 'Int'으로 암시적으로 변환할 수 없습니다\nx = \"a\"\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테이블 태그를 마크다운 형식으로 변경하십시오.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n  1\u003e let x = 1 \n  2. x = 2 \n  3. print(x) \n  4.  \n[User] error: Expression [0]:2:1: expression must be mutable in assignment\nx = 2\n```\n\nMojo는 현재 Python의 \"상위집합\"으로 설계되었지만 아직 완전히 그렇지는 않습니다. 따라서 Python처럼 보이지만 때로는 문법이 다를 수 있습니다. 예를 들어, 유형 주석을 위한 키워드가 다릅니다:\n\n```js\n  1\u003e var x: Int = 1 \n  2. var y: String = \"a\" \n  3. var z: Bool = True\n```\n\n## 함수들\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nMojo 함수는 fn 또는 def 키워드로 선언할 수 있습니다.\n\n함수를 선언할 때 def를 사용하면 인수 유형과 반환 유형을 지정할 필요가 없고 이름과 값만으로 변수를 생성할 수 있습니다. 이것은 파이썬에서 할 수 있는 것과 정확히 동일합니다:\n\n```js\ndef sum_up(n):\n    sum = 0\n    for i in range(1, n+1):\n        sum += i\n\n    return sum\n```\n\nfn 키워드를 사용하여 정의된 동일한 함수는:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nfn sum_up(n: Int) -\u003e Int:\n    var sum: Int = 0\n    for i in range(1, n+1):\n        sum += i\n    \n    return sum\n```\n\nfn으로 정의된 함수는 엄격한 타입을 갖고 있으며 컴파일 시간에 함수가 올바른 타입을 입력 받고 반환하는지 확인합니다. def 키워드를 지원하는 것은 Python 사용자들이 Mojo의 구문을 이해하고 시작하기 쉽게 만들기 위한 것일 뿐입니다. Mojo 코드를 작성할 때 좋은 습관으로 간주되지는 않습니다. Mojo 코드를 더 읽어보면 대부분의 함수가 fn 키워드로 정의되어 있는 것을 보실 수 있습니다.\n\n## Mojo 구조체\n\nMojo의 구조체는 Python의 클래스와 유사합니다. 둘 다 프로퍼티, 메서드, 데코레이터 등을 지원합니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파이썬에서 간단한 클래스를 정의해 봅시다:\n\n```python\nclass Dog:\n    def __init__(self, name):\n        self.name = name\n\n    def run(self):\n        print(f\"{self.name} is running.\")\n\ndog = Dog('Teddy')\ndog.run()\n```\n\nMojo에서 해당하는 구조체는 다음과 같습니다:\n\n```python\nstruct Dog:\n    var name: String\n\n    fn __init__(inout self, name: String):\n        self.name = name\n\n    fn run(self):\n        print(self.name, \" is running.\")\n\nlet dog = Dog('Teddy')\ndog.run()\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기 몇 가지 주요 차이점이 있어요:\n\n- 속성을 먼저 정의하고 생성자(__init__())에서 값을 할당해야 해요.\n- __init__()의 첫 번째 인자는 관례상 self로 불리며, Python에서는 inout 키워드로 정의되어 있어요. 이는 self가 가변 참조임을 의미해요. 이것은 복잡한 개념이지만, 이 글에서는 그 정도까지 깊게 파고들 필요는 없어요.\n- 아직 Mojo에서 f-string은 지원되지 않으므로 일반적인 프린팅을 사용해야 해요.\n\n변수와 함수의 기본을 알면, 두 요소의 조합인 구조체의 구문을 배우는 것은 쉬워요. 그러나 Mojo의 구조체는 복잡한 개념이며, 더 깊이 파고들고 싶다면 Mojo의 모든 것을 다루고 있어요. 심지어 Int, String, Bool과 같은 기본 유형도 내부적으로는 구조체이며, 이것이 클래스/구조체와 같은 대문자로 시작하는 이유에요.\n\n## Python과 Mojo 코드의 효율성 비교\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n알겠어요, 이제 Mojo의 매우 기본적인 구문을 알았으니, Python과 Mojo 코드의 효율성을 비교하고 최근 왜 많은 관심을 받고 있는지 살펴봅시다.\n\n다음 코드를 sum_up.py라는 Python 파일에 넣어봅시다:\n\n```python\ndef sum_up(n):\n    sum = 0\n    for i in range(1, n+1):\n        sum += i\n    \n    return sum\n\ndef main():\n    print(sum_up(1000_000_000))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n그리고 이 코드를 sum_up.mojo라는 Mojo 파일에 넣어봅시다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nfn sum_up(n: Int) -\u003e Int:\n    var sum: Int = 0\n    for i in range(1, n+1):\n        sum += i\n    \n    return sum\n\nfn main():\n    print(sum_up(1000_000_000))\n```\n\nMojo 파일의 경우, 진입 지점으로 main() 함수를 정의해야 하지만 호출할 필요는 없습니다.\n\nLinux에서는 time 명령어를 사용하여 명령어의 실행 시간을 측정할 수 있습니다. 먼저 Mojo 파일을 실행해봅시다. 그렇지 않으면 Python 파일을 먼저 실행하면 인내심을 잃을 수 있습니다 😅:\n\n```js\n$ time mojo sum_up.mojo \n500000000500000000\n\nreal    0m0,134s\nuser    0m0,161s\nsys     0m0,004s\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테이블 태그를 Markdown 형식으로 변경하였습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nMojo는 컴파일된 언어이고 Python은 해석된 언어이기 때문에 이유가 달라요. 컴파일된 언어에서 동일한 코드는 Python에서보다 100배 빠를 수 있다는 것은 놀라운 일이 아닙니다. 그러나 Python과 구문이 매우 유사하고 Python 사용자에게 친숙하기 때문에 꽤 놀라운 것입니다. 만약 우리 모든 데이터 처리 및 ML/AI 코드가 코드를 최소한으로 변경하면서 100배 빠르다면 환상적일 것입니다.\n\n## Mojo에서 Python 코드 직접 실행\n\n장기적으로, Mojo가 성숙해지고 Python의 실제 상위 집합이되면 바로 Mojo를 사용하고 Python 코드를 Mojo에서 직접 실행할 수 있어야 합니다. 마치 TypeScript에서 유효한 JavaScript 코드를 작성할 수 있는 것처럼요.\n\n그러나 현재는 Mojo에서 Python 모듈을 가져와서 Mojo 코드에서 Python 함수를 호출하고 Python 객체와 상호 작용할 수 있습니다. 위의 sum_up.py 모듈을 생성하고 Mojo에서 바로 실행하는 call_python_in_mojo.mojo라는 새 파일을 만들어 보죠.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n```js\nPython 모듈이 Mojo에서 찾을 수 있도록 경로를 추가해야합니다. 다음 명령어로 이 코드를 실행할 수 있습니다:\n\ntime mojo call_python_in_mojo.mojo\n\nPython을 직접 실행하는 것과 속도가 같다는 것을 알 수 있습니다. 조금 실망스러운 일이죠. 하지만 Mojo가 아직 초기 개발 중이고 많은 기능이 아직 구현되지 않았다는 것을 감안해야 합니다. 시간이 흐를수록 Python과의 사용성 및 통합이 훨씬 개선될 것으로 기대됩니다.\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 게시물에서는 Mojo라는 새로운 프로그래밍 언어의 매우 기초적인 부분을 소개했습니다. Mojo는 Python의 상위 집합으로 설계되어 Python과 매우 유사한 구문을 가지고 있습니다. 우리는 Mojo 코드의 간단한 구문과 놀라운 속도를 경험했는데, 이는 데이터 처리와 기계 학습에 매우 매력적일 수 있습니다.\n\n그러나 Mojo는 아직 매우 새로운 언어이며 아직 완전히 성숙해지지 않았습니다. 보편적인 개발자들이 일할 준비가 되기까지 어느 정도 시간이 필요합니다. 그럼에도 불구하고, 이 언어를 계속 주시하고 AI의 새 시대를 놓치지 않기 위해 시간을 할애하는 가치가 있습니다. 그리고 준비가 되면 우리는 효율성을 향상시키기 위해 빠르게 전환할 수 있으며, 이는 게임 체인저 이벤트가 될 수도 있습니다.\n\n## 관련 게시물:\n\n- Python typing and validation with mypy and pedantic\n- Python에서 쉘 명령어를 올바르게 실행하는 방법","ogImage":{"url":"/TIL/assets/img/2024-07-14-AQuickIntroductiontoMojoaSupersetofPythonThatIsSuperFast_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-AQuickIntroductiontoMojoaSupersetofPythonThatIsSuperFast_0.png","tag":["Tech"],"readingTime":13},{"title":"PySpark 윈도우 연산을 마스터하기 위한 5가지 예제","description":"","date":"2024-07-14 20:16","slug":"2024-07-14-5ExamplestoMasterPySparkWindowOperations","content":"\n\n\n![Window Operations](/TIL/assets/img/2024-07-14-5ExamplestoMasterPySparkWindowOperations_0.png)\n\n내가 사용해 본 모든 데이터 분석 및 조작 도구에는 윈도우 연산이 있습니다. 일부는 다른 것보다 유연하고 능력이 높지만, 윈도우에서 계산을 할 수 있는 것이 필수적입니다.\n\n데이터 분석에서 윈도우란 무엇인가요?\n\n윈도우는 어떤 방식으로 관련된 행들의 집합입니다. 이 관련은 동일한 그룹에 속하거나 연속적인 n일에 존재하는 것일 수 있습니다. 필요한 제약 조건으로 윈도우를 생성한 후, 해당 윈도우에서 계산이나 집계를 수행할 수 있습니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 기사에서는 PySpark를 사용하여 창 작업에 대해 포괄적으로 이해할 수 있는 5가지 구체적인 예제를 살펴보겠습니다. 우리는 파티션과 함께 윈도우를 생성하는 방법, 이러한 윈도우를 사용자 정의하는 방법, 그리고 이를 통해 계산을 수행하는 방법을 배울 것입니다.\n\nPySpark는 대규모 데이터 처리에 사용되는 분석 엔진인 Spark의 Python API입니다.\n\n# 데이터\n\n이 기사를 위해 모의 데이터로 샘플 데이터셋을 준비했고, 해당 데이터셋은 제 저장소에서 다운로드할 수 있습니다. 이 기사에서 사용할 데이터셋은 \"sample_sales_pyspark.csv\"라고 부릅니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자, spark 세션을 시작하고 이 데이터셋으로부터 DataFrame을 생성해 봅시다.\n\n```js\nfrom pyspark.sql import SparkSession\nfrom pyspark.sql import Window, functions as F\n\nspark = SparkSession.builder.getOrCreate()\n\ndata = spark.read.csv(\"sample_sales_pyspark.csv\", header=True)\n\ndata.show(15)\n\n# output\n+----------+------------+----------+---------+---------+-----+\n|store_code|product_code|sales_date|sales_qty|sales_rev|price|\n+----------+------------+----------+---------+---------+-----+\n|        B1|       89912|2021-05-01|       14|    17654| 1261|\n|        B1|       89912|2021-05-02|       19|    24282| 1278|\n|        B1|       89912|2021-05-03|       15|    19305| 1287|\n|        B1|       89912|2021-05-04|       21|    28287| 1347|\n|        B1|       89912|2021-05-05|        4|     5404| 1351|\n|        B1|       89912|2021-05-06|        5|     6775| 1355|\n|        B1|       89912|2021-05-07|       10|    12420| 1242|\n|        B1|       89912|2021-05-08|       18|    22500| 1250|\n|        B1|       89912|2021-05-09|        5|     6555| 1311|\n|        B1|       89912|2021-05-10|        2|     2638| 1319|\n|        B1|       89912|2021-05-11|       15|    19575| 1305|\n|        B1|       89912|2021-05-12|       21|    28182| 1342|\n|        B1|       89912|2021-05-13|        7|     9268| 1324|\n|        B1|       89912|2021-05-14|       17|    22576| 1328|\n|        B1|       89912|2021-05-15|       16|    20320| 1270|\n+----------+------------+----------+---------+---------+-----+\n```\n\n## 예제 1\n\n우선, 파티션과 정렬 열을 기준으로 윈도우를 생성합니다. DataFrame에서는 각 제품의 누적 판매량을 각 상점별로 계산하려면 윈도우를 다음과 같이 정의합니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nwindow = Window.partitionBy(\"store_code\", \"product_code\").orderBy(\"sales_date\")\n```\n\n누적 판매량을 계산하려면 이 윈도우 위에 sum 함수를 적용하기만 하면 됩니다:\n\n```js\ndata = data.withColumn(\"total_sales\", F.sum(\"sales_qty\").over(window))\n```\n\n이 코드는 \"total_sales\"라는 새 열을 만들며, 이전에 정의한 윈도우 상에서 계산된 판매 수량의 누적 합계를 포함합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\" B1\" 스토어의 첫 30개 행을 확인해봐서 누적값이 올바르게 계산되었는지 확인해보세요:\n\n```js\ndata \\\n.filter((F.col(\"store_code\")==\"B1\")) \\\n.select(\"store_code\", \"product_code\", \"sales_date\", \"sales_qty\", \"total_sales\") \\\n.show(30)\n\n# output\n+----------+------------+----------+---------+-----------+\n|store_code|product_code|sales_date|sales_qty|total_sales|\n+----------+------------+----------+---------+-----------+\n|        B1|       89912|2021-05-01|       14|       14.0|\n|        B1|       89912|2021-05-02|       19|       33.0|\n|        B1|       89912|2021-05-03|       15|       48.0|\n|        B1|       89912|2021-05-04|       21|       69.0|\n|        B1|       89912|2021-05-05|        4|       73.0|\n|        B1|       89912|2021-05-06|        5|       78.0|\n|        B1|       89912|2021-05-07|       10|       88.0|\n|        B1|       89912|2021-05-08|       18|      106.0|\n|        B1|       89912|2021-05-09|        5|      111.0|\n|        B1|       89912|2021-05-10|        2|      113.0|\n|        B1|       89912|2021-05-11|       15|      128.0|\n|        B1|       89912|2021-05-12|       21|      149.0|\n|        B1|       89912|2021-05-13|        7|      156.0|\n|        B1|       89912|2021-05-14|       17|      173.0|\n|        B1|       89912|2021-05-15|       16|      189.0|\n|        B1|       89915|2021-05-01|       20|       20.0|\n|        B1|       89915|2021-05-02|        0|       20.0|\n|        B1|       89915|2021-05-03|       10|       30.0|\n|        B1|       89915|2021-05-04|       13|       43.0|\n|        B1|       89915|2021-05-05|       21|       64.0|\n|        B1|       89915|2021-05-06|        4|       68.0|\n|        B1|       89915|2021-05-07|       20|       88.0|\n|        B1|       89915|2021-05-08|       16|      104.0|\n|        B1|       89915|2021-05-09|       21|      125.0|\n|        B1|       89915|2021-05-10|        2|      127.0|\n|        B1|       89915|2021-05-11|       15|      142.0|\n|        B1|       89915|2021-05-12|       15|      157.0|\n|        B1|       89915|2021-05-13|       14|      171.0|\n|        B1|       89915|2021-05-14|        3|      174.0|\n|        B1|       89915|2021-05-15|        1|      175.0|\n+----------+------------+----------+---------+-----------+\n```\n\n첫 15개 행은 제품 89912에 속하므로 총 판매액 열은 판매 수량 열의 값들의 누적 합을 보여줍니다. 16번째 행에서 제품 코드가 변경되어 누적 합이 초기화됩니다. 이는 우리가 스토어 코드와 제품 코드로 분할된 윈도우를 생성했기 때문입니다.\n\n## 예시 2\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n창을 생성한 후에는 다양한 집계를 계산할 수 있어요. 예를 들어, 앞에서 정의한 창에 대해 max 함수를 적용하면, 결과는 주어진 상점의 제품의 누적 최대 가격이 될 거예요.\n\n창을 생성하는 코드를 작성할 테니까, 위를 계속 찾지 않아도 돼요.\n\n```js\n# 창 정의\nwindow = Window.partitionBy(\"store_code\", \"product_code\").orderBy(\"sales_date\")\n\n# 누적 최대 가격\ndata = data.withColumn(\"max_price\", F.max(\"price\").over(window))\n\n# 결과 확인\ndata \\\n.filter((F.col(\"store_code\")==\"B1\")) \\\n.select(\"store_code\", \"product_code\", \"sales_date\", \"price\", \"max_price\") \\\n.show(15)\n\n# 결과\n+----------+------------+----------+-----+---------+\n|store_code|product_code|sales_date|price|max_price|\n+----------+------------+----------+-----+---------+\n|        B1|       89912|2021-05-01| 1261|     1261|\n|        B1|       89912|2021-05-02| 1278|     1278|\n|        B1|       89912|2021-05-03| 1287|     1287|\n|        B1|       89912|2021-05-04| 1347|     1347|\n|        B1|       89912|2021-05-05| 1351|     1351|\n|        B1|       89912|2021-05-06| 1355|     1355|\n|        B1|       89912|2021-05-07| 1242|     1355|\n|        B1|       89912|2021-05-08| 1250|     1355|\n|        B1|       89912|2021-05-09| 1311|     1355|\n|        B1|       89912|2021-05-10| 1319|     1355|\n|        B1|       89912|2021-05-11| 1305|     1355|\n|        B1|       89912|2021-05-12| 1342|     1355|\n|        B1|       89912|2021-05-13| 1324|     1355|\n|        B1|       89912|2021-05-14| 1328|     1355|\n|        B1|       89912|2021-05-15| 1270|     1355|\n+----------+------------+----------+-----+---------+\n```\n\n\"max_price\" 열의 값은 증가하거나 동일하게 유지돼요. 7번째 행에서는 가격이 실제로 낮아지지만, 누적 최대 값이 표시돼서 최대 가격 값은 그대로 유지돌아요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 예제 3\n\nlag 및 lead는 일반적으로 사용되는 윈도우 함수 중 일부입니다. 시계열 데이터를 분석할 때 자주 사용합니다. 현재 행의 앞이나 뒤에 오프셋된 값을 반환합니다.\n\n- lag(\"sales_qty\", 1) : 1행 전\n- lag(\"sales_qty\", 2) : 2행 전\n- lead(\"sales_qty\", 1) : 1행 후\n- lead(\"sales_qty\", 2) : 2행 후\n\nlag의 음수 값을 사용하여 오프셋을 지정할 수 있으므로 lag(\"sales_qty\", 1)은 lead(\"sales_qty\", -1)과 동일합니다. 둘 다 이전 행의 값을 제공합니다. 테스트해 봅시다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 창을 정의합니다\nwindow = Window.partitionBy(\"store_code\", \"product_code\").orderBy(\"sales_date\")\n\n# 전일 판매 수량\ndata = data.withColumn(\"prev_day_sales_lag\", F.lag(\"sales_qty\", 1).over(window))\ndata = data.withColumn(\"prev_day_sales_lead\", F.lead(\"sales_qty\", -1).over(window))\n\n# 다른 제품-매장 쌍에 대한 출력 확인\ndata \\\n.filter((F.col(\"store_code\")==\"A1\") \u0026 (F.col(\"product_code\")==\"95955\")) \\\n.select(\"sales_date\", \"sales_qty\", \"prev_day_sales_lag\", \"prev_day_sales_lead\") \\\n.show(15)\n\n# 출력 결과\n+----------+---------+------------------+-------------------+\n|sales_date|sales_qty|prev_day_sales_lag|prev_day_sales_lead|\n+----------+---------+------------------+-------------------+\n|2021-05-01|       13|              NULL|               NULL|\n|2021-05-02|        3|                13|                 13|\n|2021-05-03|       22|                 3|                  3|\n|2021-05-04|       17|                22|                 22|\n|2021-05-05|       20|                17|                 17|\n|2021-05-06|       14|                20|                 20|\n|2021-05-07|       10|                14|                 14|\n|2021-05-08|       10|                10|                 10|\n|2021-05-09|       15|                10|                 10|\n|2021-05-10|       15|                15|                 15|\n|2021-05-11|        8|                15|                 15|\n|2021-05-12|        9|                 8|                  8|\n|2021-05-13|       13|                 9|                  9|\n|2021-05-14|        6|                13|                 13|\n|2021-05-15|       21|                 6|                  6|\n+----------+---------+------------------+-------------------+\n```\n\n첫 번째 행의 전일 값은 NULL입니다. 이는 해당 행이 이전 날짜를 가지고 있지 않기 때문에 발생합니다.\n\n## 예시 4\n\n행을 기반으로 한 창을 정의한 후, rowsBetween 메소드를 사용하여 범위를 좁힐 수 있습니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n요즘 세 가지 이유로 판매량의 평균을 계산하려면 이 창을 다음과 같이 정의할 수 있습니다:\n\n```js\nwindow = Window \\\n.partitionBy(\"store_code\", \"product_code\") \\\n.orderBy(\"sales_date\") \\\n.rowsBetween(-3, -1)\n```\n\n첫 번째 매개변수가 시작이고 두 번째 매개변수가 끝입니다. 각 행에 대한 마지막 세 행을 포함하는 창을 사용자 정의했습니다. \"-1\"은 현재 행의 이전 행을 가리키고 \"-3\"은 현재 행의 세 번째 이전 행을 나타냅니다.\n\n![이미지](/TIL/assets/img/2024-07-14-5ExamplestoMasterPySparkWindowOperations_1.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지난 세 날 동안의 평균 판매 수량을 계산하려면 이 윈도우에 mean 함수를 적용하기만 하면 됩니다.\n\n```js\n# 윈도우 정의\nwindow = Window \\\n.partitionBy(\"store_code\", \"product_code\") \\\n.orderBy(\"sales_date\") \\\n.rowsBetween(-3, -1)\n\n# 평균 계산\ndata = data.withColumn(\"last_3_day_avg\", F.mean(\"sales_qty\").over(window))\n\n# 데이터 표시\ndata \\\n.filter((F.col(\"store_code\")==\"A1\") \u0026 (F.col(\"product_code\")==\"95955\")) \\\n.select(\"sales_date\", \"sales_qty\", \"last_3_day_avg\") \\\n.show()\n\n# 결과\n+----------+---------+------------------+\n|sales_date|sales_qty|    last_3_day_avg|\n+----------+---------+------------------+\n|2021-05-01|       13|              NULL|\n|2021-05-02|        3|              13.0|\n|2021-05-03|       22|               8.0|\n|2021-05-04|       17|12.666666666666666|\n|2021-05-05|       20|              14.0|\n|2021-05-06|       14|19.666666666666668|\n|2021-05-07|       10|              17.0|\n|2021-05-08|       10|14.666666666666666|\n|2021-05-09|       15|11.333333333333334|\n|2021-05-10|       15|11.666666666666666|\n|2021-05-11|        8|13.333333333333334|\n|2021-05-12|        9|12.666666666666666|\n|2021-05-13|       13|10.666666666666666|\n|2021-05-14|        6|              10.0|\n|2021-05-15|       21| 9.333333333333334|\n+----------+---------+------------------+\n```\n\n예를 들어, 네 번째 행인 \"2021-05-04\"의 경우, 지난 세 행(13, 3, 22)의 값의 평균인 13.75입니다.\n\n## 예시 5\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n입력 데이터의 각 행에서 정의된 창 내의 열의 누적 평균 값을 계산해야 하는 경우를 생각해보세요. 각 행에 대해 계산은 창의 첫 번째 행과 현재 행 사이의 행을 포함해야 합니다.\n\n이를 위해 unboundedPreceding으로 시작점을 정의할 수 있습니다. 마찬가지로, 창의 끝까지 가려면 unboundedFollowing을 사용할 수 있습니다.\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-5ExamplestoMasterPySparkWindowOperations_2.png\" /\u003e\n\n창을 정의한 후 나머지는 동일합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 윈도우 정의\nwindow = Window \\\n.partitionBy(\"store_code\", \"product_code\") \\\n.orderBy(\"sales_date\") \\\n.rowsBetween(Window.unboundedPreceding, -1)\n\n# 평균 계산\ndata = data.withColumn(\"누적평균\", F.mean(\"sales_qty\").over(window))\n\n# 데이터 출력\ndata \\\n.filter((F.col(\"store_code\")==\"A1\") \u0026 (F.col(\"product_code\")==\"95955\")) \\\n.select(\"sales_date\", \"sales_qty\", \"누적평균\") \\\n.show()\n\n# 결과\n+----------+---------+------------------+\n|sales_date|sales_qty|   누적평균       |\n+----------+---------+------------------+\n|2021-05-01|       13|              NULL|\n|2021-05-02|        3|              13.0|\n|2021-05-03|       22|               8.0|\n|2021-05-04|       17|12.666666666666666|\n|2021-05-05|       20|             13.75|\n|2021-05-06|       14|              15.0|\n|2021-05-07|       10|14.833333333333334|\n|2021-05-08|       10|14.142857142857142|\n|2021-05-09|       15|            13.625|\n|2021-05-10|       15|13.777777777777779|\n|2021-05-11|        8|              13.9|\n|2021-05-12|        9|13.363636363636363|\n|2021-05-13|       13|              13.0|\n|2021-05-14|        6|              13.0|\n|2021-05-15|       21|              12.5|\n+----------+---------+------------------+\n```\n\n누적평균 열에는 현재 행까지의 모든 행의 평균 판매량이 포함됩니다 (현재 행은 제외됨). 현재 행을 누적 평균 계산에 포함하려면 다음과 같이 윈도우를 정의할 수 있습니다:\n\n```js\nwindow = Window \\\n.partitionBy(\"store_code\", \"product_code\") \\\n.orderBy(\"sales_date\") \\\n.rowsBetween(Window.unboundedPreceding, Window.currentRow)\n```\n\n# 마지막으로\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n윈도우 작업은 데이터 분석에 있어 근본적인 작업입니다. 특히 시계열 데이터를 다루거나 시계열 데이터에 대한 예측 분석을 위해 머신러닝 모델을 만들 때 다양한 피처를 생성하기 위해 윈도우 작업을 사용합니다.\n\n대부분의 데이터 분석 및 조작 도구는 윈도우 작업을 수행하는 데 도움이 되는 기능을 제공합니다. 이 글에서는 PySpark를 사용하여 이러한 작업을 수행하는 방법을 배웠습니다.\n\n읽어 주셔서 감사합니다. 피드백이 있으시면 언제든지 알려주세요.","ogImage":{"url":"/TIL/assets/img/2024-07-14-5ExamplestoMasterPySparkWindowOperations_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-5ExamplestoMasterPySparkWindowOperations_0.png","tag":["Tech"],"readingTime":16}],"page":"4","totalPageCount":35,"totalPageGroupCount":2,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"4"},"buildId":"B2TETmJptwqhd4vJNGZoH","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>