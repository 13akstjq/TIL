<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>TIL</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//posts/3" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="TIL" data-gatsby-head="true"/><meta property="og:title" content="TIL" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//posts/3" data-gatsby-head="true"/><meta name="twitter:title" content="TIL" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/7978fe7362f7d4c9.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/7978fe7362f7d4c9.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/873-eb138c3217d71553.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/posts/%5Bpage%5D-de1dc5579188f9be.js" defer=""></script><script src="/TIL/_next/static/X4OrKfmLtU3-3BijwfHe6/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/X4OrKfmLtU3-3BijwfHe6/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Next.js 15 서버 컴포넌트 HMR 캐시 동작 원리와 최적화 방법" href="/TIL/post/2025-04-22-serverComponentsHmrCache"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15 서버 컴포넌트 HMR 캐시 동작 원리와 최적화 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15 서버 컴포넌트 HMR 캐시 동작 원리와 최적화 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15 서버 컴포넌트 HMR 캐시 동작 원리와 최적화 방법</strong><div class="PostList_meta__VCFLX"><span class="date">7 hours ago</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js 15에서 sassOptions 설정 방법" href="/TIL/post/2025-04-22-sassOptions"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15에서 sassOptions 설정 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15에서 sassOptions 설정 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15에서 sassOptions 설정 방법</strong><div class="PostList_meta__VCFLX"><span class="date">7 hours ago</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nextjs 15에서 웹페이지 이동한 것처럼 보이게 만들기 (rewrites)" href="/TIL/post/2025-04-22-rewrites"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nextjs 15에서 웹페이지 이동한 것처럼 보이게 만들기 (rewrites)" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nextjs 15에서 웹페이지 이동한 것처럼 보이게 만들기 (rewrites)" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Nextjs 15에서 웹페이지 이동한 것처럼 보이게 만들기 (rewrites)</strong><div class="PostList_meta__VCFLX"><span class="date">8 hours ago</span><span class="PostList_reading_time__6CBMQ">23<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="ReactJS에서 maxHeadersLength 설정하는 방법" href="/TIL/post/2025-04-22-reactMaxHeadersLength"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="ReactJS에서 maxHeadersLength 설정하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="ReactJS에서 maxHeadersLength 설정하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">ReactJS에서 maxHeadersLength 설정하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">8 hours ago</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nextjs 15에서 reactStrictMode 사용하는 방법" href="/TIL/post/2025-04-22-reactStrictMode"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nextjs 15에서 reactStrictMode 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nextjs 15에서 reactStrictMode 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Nextjs 15에서 reactStrictMode 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">8 hours ago</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nextjs 15 웹사이트에서 다른 url로 보내는 방법" href="/TIL/post/2025-04-22-redirects"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nextjs 15 웹사이트에서 다른 url로 보내는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nextjs 15 웹사이트에서 다른 url로 보내는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Nextjs 15 웹사이트에서 다른 url로 보내는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">8 hours ago</span><span class="PostList_reading_time__6CBMQ">21<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nextjs 15에서 부분 사전 렌더링 하는 방법(Partial Prerendering)" href="/TIL/post/2025-04-22-ppr"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nextjs 15에서 부분 사전 렌더링 하는 방법(Partial Prerendering)" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nextjs 15에서 부분 사전 렌더링 하는 방법(Partial Prerendering)" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Nextjs 15에서 부분 사전 렌더링 하는 방법(Partial Prerendering)</strong><div class="PostList_meta__VCFLX"><span class="date">8 hours ago</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js 15에서 Production Browser Source Maps 설정하는 방법" href="/TIL/post/2025-04-22-productionBrowserSourceMaps"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15에서 Production Browser Source Maps 설정하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15에서 Production Browser Source Maps 설정하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15에서 Production Browser Source Maps 설정하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">8 hours ago</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Nextjs 15 에서 reactCompiler 사용하는 방법" href="/TIL/post/2025-04-22-reactCompiler"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Nextjs 15 에서 reactCompiler 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Nextjs 15 에서 reactCompiler 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Nextjs 15 에서 reactCompiler 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">8 hours ago</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Next.js 15 pageExtensions로 마크다운 페이지 만들기" href="/TIL/post/2025-04-22-pageExtensions"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Next.js 15 pageExtensions로 마크다운 페이지 만들기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/nextjs.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Next.js 15 pageExtensions로 마크다운 페이지 만들기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Next.js 15 pageExtensions로 마크다운 페이지 만들기</strong><div class="PostList_meta__VCFLX"><span class="date">8 hours ago</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/TIL/posts/1">1</a><a class="link" href="/TIL/posts/2">2</a><a class="link posts_-active__YVJEi" href="/TIL/posts/3">3</a><a class="link" href="/TIL/posts/4">4</a><a class="link" href="/TIL/posts/5">5</a><a class="link" href="/TIL/posts/6">6</a><a class="link" href="/TIL/posts/7">7</a><a class="link" href="/TIL/posts/8">8</a><a class="link" href="/TIL/posts/9">9</a><a class="link" href="/TIL/posts/10">10</a><a class="link" href="/TIL/posts/11">11</a><a class="link" href="/TIL/posts/12">12</a><a class="link" href="/TIL/posts/13">13</a><a class="link" href="/TIL/posts/14">14</a><a class="link" href="/TIL/posts/15">15</a><a class="link" href="/TIL/posts/16">16</a><a class="link" href="/TIL/posts/17">17</a><a class="link" href="/TIL/posts/18">18</a><a class="link" href="/TIL/posts/19">19</a><a class="link" href="/TIL/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Next.js 15 서버 컴포넌트 HMR 캐시 동작 원리와 최적화 방법","description":"","date":"2025-04-22 13:25","slug":"2025-04-22-serverComponentsHmrCache","content":"\n\n# serverComponentsHmrCache 옵션 알아보기\n\n안녕하세요! 오늘은 Next.js에서 실험적으로 제공하는 `serverComponentsHmrCache` 옵션에 대해 알려드릴게요. 이 옵션은 로컬 개발 환경에서 서버 컴포넌트(Server Components)의 `fetch` 응답을 HMR(Hot Module Replacement, 핫 모듈 교체) 과정 중에 캐싱해줘서, API 호출 비용도 줄이고 응답 속도도 빠르게 해준답니다.\n\n---\n\n## serverComponentsHmrCache가 뭘까?\n\n기본적으로 개발 중에 코드를 수정하면 HMR 기능이 작동하면서 줄줄이 새로고침 됐었죠? 그런데 이때마다 서버 컴포넌트에서 fetch 요청이 다시 일어나 느려질 수 있고, 과도한 API 호출로 비용이 발생할 수 있어요.\n\n이 옵션을 켜두면, 로컬에서 HMR 리프레시가 일어날 때 fetch가 반환한 데이터를 캐시에 저장해두고 재활용해요. 그래서 매번 API를 새로 호출하지 않고 빠르게 데이터를 불러올 수 있답니다.\n\n---\n\n## 기본 동작\n\n- HMR 캐시는 모든 fetch 요청에 적용돼요.\n- 심지어 `cache: \"no-store\"` 옵션이 붙은 요청도 캐시가 사용돼서 **새로운 데이터가 바로 반영되지 않을 수 있어요.**\n- 단, 브라우저에서 페이지를 이동하거나 전체 새로고침을 하면 캐시는 초기화됩니다.\n\n---\n\n## 이 옵션 끄고 싶으면?\n\n`next.config.js` 파일에 아래처럼 설정하면 돼요:\n\n```js\n// next.config.js\nmodule.exports = {\n  experimental: {\n    serverComponentsHmrCache: false,\n  },\n}\n```\n\n---\n\n## 팁! 알아두면 좋은 점\n\n- 이 옵션은 오로지 로컬 개발 환경에서만 의미 있어요. 실제 배포 시에는 캐시가 적용되지 않습니다.\n- HMR 중 데이터가 제대로 갱신되어야 할 때는 끄는 게 좋습니다. 예를 들어, 실시간으로 변하는 데이터를 테스트하거나, 캐시 때문에 최신 상태가 보이지 않을 때요.\n- 서버 컴포넌트와 클라이언트 컴포넌트가 섞여 있는 프로젝트에서, 서버 컴포넌트가 데이터 로딩을 담당한다면 속도 향상을 꽤 느낄 수 있어요.\n\n---\n\n요약하자면, `serverComponentsHmrCache` 옵션은 개발 생산성을 올려주고 API 사용 비용을 아껴주는 좋은 도구예요. 다만, 데이터 갱신이 중요한 경우에는 캐시를 조심해서 사용하시고요! 궁금한 점 있으면 댓글로 남겨주세요~\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 `serverComponentsHmrCache` 설정을 꺼두는 방법에 대해 이야기해볼게요.\n\n```js\nimport type { NextConfig } from 'next'\n\nconst nextConfig: NextConfig = {\n  experimental: {\n    serverComponentsHmrCache: false, // 기본값은 true입니다\n  },\n}\n\nexport default nextConfig\n```\n\n위 코드는 Next.js 설정에서 `serverComponentsHmrCache`를 `false`로 설정하는 예제인데요. 이 값은 기본적으로 `true`로 되어 있어서 서버 컴포넌트의 핫 모듈 리로딩을 캐시를 활용해 빠르게 처리해줍니다. 하지만 개발 상황이나 특정 버그를 해결할 때 이 캐시를 끄고 싶을 때가 있죠.\n\n### 참고할 만한 팁!\n\n개발할 때 fetch 요청의 캐시 적중(hit)과 실패(miss)를 제대로 추적하고 싶다면 `logging.fetches` 옵션을 켜보세요. 이렇게 하면 콘솔에서 캐시가 잘 작동하는지, 아니면 새로 fetch하는지를 한눈에 볼 수 있어서 디버깅할 때 훨씬 편합니다.\n\n```js\nconst nextConfig: NextConfig = {\n  experimental: {\n    logging: {\n      fetches: true,\n    },\n  },\n}\n```\n\n이 설정을 켜두면 개발 중 네트워크 호출 캐시 상태를 실시간으로 파악할 수 있으니까, fetch가 잘 캐시되고 있나 궁금할 때 도움됩니다.\n\n---\n\n### 추가로 알아두면 좋은 점\n\n- `serverComponentsHmrCache`는 서버 컴포넌트 개발자 경험 향상을 위한 옵션이에요. 이걸 꺼두면 개발 중 일부 반응 속도가 느려질 수 있지만, 환경에 따라서는 문제 해결에 도움이 됩니다.\n- Next.js 최신 버전이나 기능 업데이트 때, experimental 옵션이 변할 수도 있으니 공식 문서를 꼭 확인하세요.\n\n이 정도만 알아두면 `experimental` 섹션에서 실험적인 기능 다룰 때 도움이 될 거예요. 행복한 Next.js 개발하세요! 🚀","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":3},{"title":"Next.js 15에서 sassOptions 설정 방법","description":"","date":"2025-04-22 13:24","slug":"2025-04-22-sassOptions","content":"\n\n# sassOptions란 무엇인가요?\n\n`sassOptions`는 Next.js에서 Sass 컴파일러를 설정할 때 사용하는 옵션입니다. 간단히 말해서, Sass 파일을 어떻게 처리할지 세부적으로 설정할 수 있게 도와주는 녀석이죠.\n\n아래 예제를 보면서 살짝 살펴볼게요:\n\n```js\nimport type { NextConfig } from 'next'\n\nconst sassOptions = {\n  additionalData: `\n    $var: red;\n  `,\n}\n\nconst nextConfig: NextConfig = {\n  sassOptions: {\n    ...sassOptions,\n    implementation: 'sass-embedded',\n  },\n}\n\nexport default nextConfig\n```\n\n위 코드에서 `additionalData`는 Sass 파일이 컴파일될 때마다 자동으로 추가되는 코드입니다. 여기서는 Sass 변수 `$var`에 `red` 색상을 지정하고 있죠. 이렇게 하면 모든 Sass 파일에서 이 변수를 사용할 수 있게 돼서 일일이 변수 선언할 필요 없이 편리해요.\n\n그리고 `implementation` 옵션에 `'sass-embedded'`를 지정했는데요, 이는 Dart Sass의 임베디드 버전을 사용한다는 뜻입니다. Next.js는 보통 기본적으로 Dart Sass를 사용하지만, 여기에 다른 Sass 컴파일러를 직접 명시해주고 싶을 때 쓰는 부분이에요.\n\n\u003e 참고로, Next.js는 `sassOptions`의 여러 속성을 모두 타입으로 관리하고 있지 않아서, `implementation` 말고는 타입 추론이 조금 제한적이에요. 그래서 필요한 옵션만 적절히 넣어주면 됩니다.\n\n---\n\n### 추가로 알아두면 좋은 팁!\n\n- **`additionalData` 활용법**  \n  예를 들어 여러 Sass 파일에서 공통으로 사용할 변수나 믹스인, 함수 등이 있다면, `additionalData`에 미리 등록해두면 코드 중복을 줄일 수 있어요.\n\n- **퍼포먼스 최적화**  \n  Sass 설정에 따라 빌드 속도에 영향을 줄 수 있으니, 꼭 필요한 옵션만 넣고 불필요한 설정은 피하는 게 좋아요.\n\n- **Next.js 공식 문서 확인하기**  \n  Next.js 자체 문서나 Sass 공식 문서를 참고하면 더 많은 옵션과 사례를 확인할 수 있어요.\n\nSass를 Next.js 프로젝트에서 제대로 세팅해두면 스타일 관리가 훨씬 깔끔해지고 유지보수도 쉬워지니 꼭 한번 시도해 보시길 추천해요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":2},{"title":"Nextjs 15에서 웹페이지 이동한 것처럼 보이게 만들기 (rewrites)","description":"","date":"2025-04-22 13:21","slug":"2025-04-22-rewrites","content":"\n\n# 리라이트(rewrites)란?\n\n리라이트는 들어오는 요청 경로를 다른 목적지 경로로 바꿔주는 기능이에요.\n\n이걸 간단히 말하면, 사용자가 웹사이트에서 이동한 것처럼 보이지만 실제로는 다른 경로에서 데이터를 가져오는 거예요. URL 자체는 바뀌지 않아서 '나는 여전히 같은 페이지에 있어!'라고 느껴지게 만드는 거죠. 이 점에서 리다이렉트와 큰 차이가 있어요. 리다이렉트는 말 그대로 URL이 바뀌면서 새 페이지로 이동하게 되거든요.\n\nNext.js에서 리라이트를 사용하고 싶다면, `next.config.js` 파일 안에 `rewrites` 키를 활용하면 돼요. \n\n예를 들어 이렇게 설정할 수 있어요:\n\n```js\nmodule.exports = {\n  async rewrites() {\n    return [\n      {\n        source: '/old-path/:slug*',\n        destination: '/new-path/:slug*',\n      },\n    ];\n  },\n};\n```\n\n이렇게 하면 사용자가 `/old-path/anything` 으로 요청해도 실제 서버에선 `/new-path/anything` 을 처리하지만, 브라우저 주소창은 그대로 `/old-path/anything` 으로 유지돼요.\n\n---\n\n### 추가 팁!\n\n- 리라이트는 특히 API 경로나 내부 구조를 바꾸고 싶을 때 유용해요. 예를 들어, API 버전을 변경할 때 외부에는 이전 API 경로를 그대로 노출하면서 내부에서는 새 버전을 쓸 수 있죠.\n- 다만 리라이트가 작동하려면 Next.js가 해당 목적지 URL을 처리할 수 있어야 해요. 외부 도메인으로는 리라이트가 불가능하니 참고하세요.\n- 만약 URL이 바뀌는 걸 원한다면, 리다이렉트를 사용해야 하는 점 기억하세요!\n\n리라이트를 잘 활용하면 사용자 경험을 훨씬 깔끔하게 유지하면서 서버 구조를 유연하게 바꿀 수 있답니다. 고민되는 부분 있으면 언제든 질문해 주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 `rewrites` 설정을 쓰면 클라이언트 사이드 라우팅 시 URL 경로를 원하는 대로 바꿔서 보여줄 수 있어요. 예를 들어, 위 코드처럼 `/about` 경로를 `/` (홈 페이지)로 다시 매핑할 수 있죠.\n\n```js\nmodule.exports = {\n  async rewrites() {\n    return [\n      {\n        source: '/about',\n        destination: '/',\n      },\n    ]\n  },\n}\n```\n\n이렇게 하면 코드 안에서 `\u003cLink href=\"/about\"\u003e`을 사용해도 실제로는 `/` 경로로 라우팅 됩니다.  \n\n### rewrites 함수\n- async 함수로, 반환값은 **객체 혹은 배열** 형태입니다.  \n- 반환 값 안에는 `{ source, destination }` 객체들이 들어가죠.\n\n| 속성명       | 설명                                                                  |\n|--------------|-----------------------------------------------------------------------|\n| `source`     | 들어오는 요청의 경로 패턴 (예: `/about`)                              |\n| `destination`| 실제로 라우팅할 경로                                                 |\n| `basePath`   | `false` 혹은 `undefined` - `false`면 기본 `basePath`를 경로에서 제외 (외부 URL rewrite에 쓰임) |\n| `locale`     | `false` 혹은 `undefined` - 지역화(locale) 경로 포함 여부 설정          |\n| `has`        | 조건 배열 - 특정 헤더, 쿠키, 쿼리 값 등이 있을 때만 rewrite 적용 가능  |\n| `missing`    | 조건 배열 - 특정 헤더, 쿠키, 쿼리 값이 없을 때만 rewrite 적용 가능    |\n\n---\n\n### 추가 팁!\n\n- `rewrites`는 URL을 '숨긴다'고 생각하면 쉬워요. 사용자가 `about` 페이지로 접속한 것 같지만 실제론 루트 페이지를 보여주니까요.  \n- SEO에 영향을 안 주고 프론트엔드에서 URL만 바꾸고 싶을 때 유용해요.  \n- 복잡한 조건문으로 특정 쿠키가 있거나 쿼리 파라미터에 따라 경로를 다르게 바꾸고 싶다면 `has`나 `missing` 옵션을 이용해보세요.  \n\n예를 들어:\n\n```js\nrewrites: async () =\u003e [\n  {\n    source: '/dashboard',\n    has: [\n      { type: 'cookie', key: 'token' }, // 로그인 되어 있는 사람만 접근 가능하게 \n    ],\n    destination: '/dashboard',\n  },\n  {\n    source: '/dashboard',\n    missing: [\n      { type: 'cookie', key: 'token' }, // 로그인 안 되어 있으면 로그인 페이지로 \n    ],\n    destination: '/login',\n  },\n],\n```\n\n이렇게 하면 사용자가 로그인이 되어 있는지 쿠키로 검사해 조건부 리다이렉트도 구현할 수 있어요.\n\n---\n\nNext.js 공식 문서에서는 `rewrites` 외에도 `redirects`, `headers` 같은 유용한 설정들을 제공하니, 사이트 라우팅 컨트롤이 필요할 때 꼭 한 번 정독해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 rewrites 설정을 다룰 때, `rewrites` 함수가 배열을 반환하면, 이 리라이트(재작성) 규칙들은 파일 시스템(페이지와 /public 파일) 확인 후, 동적 라우트 검사 전에 적용돼요. 그런데 Next.js 10.1 버전부터는 `rewrites` 함수가 특정 구조의 객체 안에 배열들을 반환할 수 있는데요, 이 방식은 리라이트가 적용되는 타이밍을 좀 더 세밀하게 조정할 수 있게 해 줍니다.\n\n아래 코드를 보면 각 배열이 어떤 역할을 하는지 쉽게 이해할 수 있어요:\n\n```js\nmodule.exports = {\n  async rewrites() {\n    return {\n      beforeFiles: [\n        // headers/redirects 확인 후, 모든 파일 (예: _next/public 포함) 확인 전\n        // 여기에 선언한 리라이트들은 페이지 파일들을 덮어쓸 수도 있어요\n        {\n          source: '/some-page',\n          destination: '/somewhere-else',\n          has: [{ type: 'query', key: 'overrideMe' }],\n        },\n      ],\n      afterFiles: [\n        // 페이지와 public 파일 확인 후, 동적 라우트 검사 전\n        {\n          source: '/non-existent',\n          destination: '/somewhere-else',\n        },\n      ],\n      fallback: [\n        // 페이지/public 파일과 동적 라우트 모두 확인 후\n        {\n          source: '/:path*',\n          destination: `https://my-old-site.com/:path*`,\n        },\n      ],\n    }\n  },\n}\n```\n\n### 테이블로 정리하면 이렇게 볼 수 있어요\n\n| 구분           | 적용 시점                                                         | 특징 및 설명                                              |\n|----------------|------------------------------------------------------------------|-----------------------------------------------------------|\n| `beforeFiles`  | headers/redirects 검사 후, 파일 시스템 검사(페이지, public) 전    | 페이지 파일 덮어쓰기 가능, 모든 `beforeFiles`가 확인될 때까지 계속 검사 |\n| `afterFiles`   | 페이지 및 public 파일 확인 후, 동적 라우트 확인 전                | 일반 파일은 없고 동적 라우트는 남아있을 때 사용             |\n| `fallback`     | 페이지/public 파일과 동적 라우트 검사 모두 완료 후                | 모든 검사 끝난 후 리라이트를 적용, 외부 사이트로 프록시 등 활용 가능 |\n\n---\n\n### 좀 더 알려볼게요!\n\n- **`beforeFiles` 내 리라이트는 매칭되더라도 모든 `beforeFiles` 배열의 규칙들을 다 검사해요.** 즉, 첫번째 매치에서 멈추지 않고, 다음 규칙도 계속 확인하는 거죠. 이는 오버라이드나 여러 조건에 유리해요.\n\n- 여러분이 리라이트를 통해 어떤 페이지를 완전히 다른 페이지로 교체하거나(예: A → B), 혹은 외부 URL로 프록시하려면 `fallback` 위치에 정의하는 게 적합해요.\n\n- 동적 라우트(`/:id` 같은 경로)를 조작하고 싶다면 `afterFiles` 위치를 활용하면 되는데요, 이 영역은 기본 페이지, public 파일 검사를 마친 후에 처리됩니다.\n\n- 파일 시스템 검사(실제로 그 경로에 맞는 파일이나 페이지가 있는지 확인)는 성능에도 영향을 끼치기 때문에, 필요한 경우에만 세밀하게 조절하는 게 중요해요.\n\n---\n\n### 마무리\n\nNext.js의 rewrites 기능, 특히 v10.1 이후 객체 모양의 `rewrites` 반환은 라우팅 제어를 정말 유연하게 만들어줍니다. 상황에 맞게 `beforeFiles`, `afterFiles`, `fallback`을 잘 조합해서, 내가 원하는 대로 페이지 흐름을 완벽하게 관리해 보세요! 개발자의 상상력과 요구에 유연하게 대응할 수 있다는 점이 Next.js의 큰 장점 중 하나랍니다. \n\n필요하면 다음에 `redirects`와 `headers` 설정에 대해서도 재미있고 쉽게 설명해 드릴게요! 😊\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 라우팅과 리다이렉트, 그리고 리라이트(rewrite)가 어떻게 작동하는지 한번 정리해볼게요. 개발할 때 이 흐름을 이해하고 있으면 문제 생겼을 때 원인 찾기가 훨씬 수월해져요.\n\n---\n\n### Next.js 요청 처리 순서\n\n| 순서 | 처리 내용 |\n|-------|------------|\n| 1 | 헤더(headers) 체크 및 적용 |\n| 2 | 리다이렉트(redirects) 체크 및 적용 |\n| 3 | `beforeFiles` 리라이트(rewrites) 체크 및 적용 |\n| 4 | 정적 파일(public 디렉토리, `_next/static` 파일)과 비동적(non-dynamic) 페이지를 체크 및 서빙 |\n| 5 | `afterFiles` 리라이트 체크 및 적용 — 여기서 매칭되면 다이나믹 라우트나 정적 파일을 다시 체크 |\n| 6 | fallback 리라이트 체크 및 적용 — 404 페이지를 렌더링하기 전에, 다이나믹 라우트와 정적 자산 모두 체크한 뒤 수행. getStaticPaths에서 `fallback: true`나 `blocking`을 사용했다면 이 fallback 리라이트는 실행되지 않습니다. |\n\n---\n\n### 리라이트(rewrite)에서 파라미터 사용 시 참고\n\n리라이트 할 때 **destination** URL에 파라미터를 직접 사용하지 않으면, 자동으로 쿼리(query)로 전달돼요.\n\n예를 들어,\n\n```js\nmodule.exports = {\n  async rewrites() {\n    return [\n      {\n        source: '/old-about/:path*',\n        destination: '/about',  // 여기서는 :path를 직접 쓰지 않았으니 쿼리로 전달됨\n      },\n    ]\n  },\n}\n```\n\n위처럼 작성하면 `/old-about/some/page` 로 접속했을 때, `/about?path=some/page`로 처리되는 셈이에요.\n\n만약 파라미터를 destination에 포함시키고 싶다면 이렇게 써야 해요:\n\n```js\ndestination: '/about/:path*',\n```\n\n그러면 `/old-about/whatever`가 `/about/whatever`로 바로 바뀌죠.\n\n---\n\n### 이런 내용이 왜 중요하냐면?\n\n- 리다이렉트는 URL을 완전히 바꿔서 클라이언트가 새 주소로 이동하도록 하는 반면  \n- 리라이트는 내부적으로 경로를 변경해서 유저는 주소가 변하지 않는 것처럼 유지하면서 다른 페이지나 리소스를 보여줄 수 있어요.\n\n그래서 이미지 요청이나 API 프록시, 특정 조건에서 페이지 렌더링 방식을 유연하게 제어할 때 리라이트를 많이 씁니다.\n\n---\n\n혹시 Next.js 라우팅, 리다이렉트, 리라이트 중 어디에 더 궁금한 점 있으면 언제든 질문 주세요! 직접 써보고 경험한 팁도 더 알려드릴게요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 `rewrites` 설정을 할 때, 이 부분이 살짝 헷갈릴 수 있는데요. 오늘은 `rewrites`에서 파라미터가 목적지(`destination`)에 어떻게 전달되는지, 그리고 자동으로 쿼리로 넘어가지 않는 경우를 함께 살펴볼게요.\n\n---\n\n### 파라미터가 목적지에 사용될 경우, 다른 파라미터는 쿼리에 자동으로 전달되지 않아요\n\n다음 코드를 보시면,\n\n```js\nmodule.exports = {\n  async rewrites() {\n    return [\n      {\n        source: '/docs/:path*',\n        destination: '/:path*', // :path 파라미터를 destination에서 이미 사용하고 있어요.\n      },\n    ]\n  },\n}\n```\n\n`source`에 `/docs/:path*`가 있는데, `destination`에서도 똑같이 `/:path*`를 사용 중이에요. 중요한 점은 이렇게 `destination`에서 이미 파라미터를 사용하면, 나머지 파라미터는 **자동으로 쿼리 스트링에 전달되지 않는다**는 것!\n\n즉, 만약 다른 파라미터가 있었다면 자동으로 `?파라미터=값` 형태로 넘겨주지 않으니 주의해야 해요.\n\n---\n\n### 쿼리 파라미터를 직접 지정하면 수동으로 전달할 수 있어요\n\n필요해서 쿼리에도 파라미터를 넘기고 싶다면 이렇게 직접 명시해주면 됩니다.\n\n```js\nmodule.exports = {\n  async rewrites() {\n    return [\n      {\n        source: '/:first/:second',\n        destination: '/:first?second=:second',\n        // :first는 destination 경로에서 이미 사용중이라,\n        // :second는 자동 쿼리 전달이 안 되는데 직접 쿼리에 넣어줬어요.\n      },\n    ]\n  },\n}\n```\n\n`/:first/:second` 경로에서 `destination`이 `/:first?second=:second`이니, `first`는 경로에, `second`는 쿼리스트링에 직접 넣어주면서 목적지 URL을 생성합니다.\n\n---\n\n### 어떻게 활용하면 좋을까?\n\n- 복잡한 URL 매핑 할 때 각 파라미터를 어떻게 쓸지 정리하기 편해요.\n- 특정 파라미터를 경로에 반드시 넣어야 할 때, 나머지는 쿼리로 주고 싶다면 위처럼 수동 지정해야 합니다.\n- 자동 쿼리 전달이 원치 않는 경우에도 활용할 수 있죠.\n\n---\n\n### 참고: Next.js `rewrites` 공식 문서\n\n[Next.js Rewrites 공식 문서](https://nextjs.org/docs/api-reference/next.config.js/rewrites)에서 더 다양한 예시와 옵션을 확인할 수 있으니, 실제 프로젝트에 바로 적용하기 전에 한 번쯤 훑어보시길 추천드려요!\n\n---\n\n재미있는 점은, 이런 기본 동작을 이해하면 라우팅을 더 유연하게 다룰 수 있다는 거예요. 다음에도 이런 실용적인 팁으로 찾아올게요. 궁금한 점 있으면 언제든 질문 환영입니다! 😄\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003e 참고할 점: Automatic Static Optimization이나 rewrites에서 사용하는 prerendering 파라미터를 통해 생성된 정적 페이지들은 hydration 이후 클라이언트에서 파싱되고, 이 정보가 쿼리로 제공됩니다.\n\n## 경로 매칭(Path Matching)\n\nNext.js에서 경로 매칭은 매우 유연하게 사용할 수 있는데요. 예를 들어 `/blog/:slug` 같은 패턴은 `/blog/hello-world` 같은 경로와 매칭됩니다. 여기서 `:slug`는 동적으로 변할 수 있는 부분입니다. 단, 중첩된 경로(예: `/blog/2023/03` 같은)는 매칭하지 않으니 참고하세요.\n\n다음은 `rewrites` 설정 예시입니다:\n\n```js\nmodule.exports = {\n  async rewrites() {\n    return [\n      {\n        source: '/blog/:slug',\n        destination: '/news/:slug', // 매칭된 파라미터를 destination 경로에서도 사용할 수 있습니다.\n      },\n    ]\n  },\n}\n```\n\n### 좀 더 알아보기\n\n- `rewrites`는 클라이언트가 요청한 URL을 내부적으로 다른 경로로 매핑해 주는 기능이라, 실제로 URL은 바뀌지 않으면서 다른 페이지의 콘텐츠를 보여줄 수 있습니다.\n- 매개변수 `:slug` 같은 동적 세그먼트를 활용하면 더욱 깔끔하고 유연한 URL 구조를 만들 수 있죠.\n- 중첩 경로나 와일드카드 사용이 필요하다면 Next.js의 다른 기능들(ex. catch-all routes)을 활용하는 것도 좋은 방법입니다.\n\n이 기능을 잘 활용하면 URL 디자인을 자유롭게 변경하면서도, 기존에 만들어 둔 페이지 컴포넌트 재사용이 가능해집니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 와일드카드 경로 매칭 (Wildcard Path Matching)\n\nNext.js에서 와일드카드 경로를 매칭하고 싶다면, 경로 매개변수 뒤에 `*`를 붙여주면 돼요. 예를 들어 `/blog/:slug*` 라고 쓰면 `/blog/a/b/c/d/hello-world` 같은 경로도 한 번에 매칭이 된답니다.\n\n```js\nmodule.exports = {\n  async rewrites() {\n    return [\n      {\n        source: '/blog/:slug*',\n        destination: '/news/:slug*', // 매칭된 파라미터를 목적지 경로에서도 사용할 수 있어요\n      },\n    ]\n  },\n}\n```\n\n여기서 중요한 점!  \n`:slug*`에서 `*`는 이 뒤에 어떤 경로가 와도 다 잡아준다는 의미에요. 즉, `/blog/a`도 되고, `/blog/a/b/c`도 다 같은 규칙으로 잡히는 거죠.\n\n이걸 이용하면 블로그 포스트나 여러 단계로 깊은 경로를 리다이렉트할 때 아주 유용합니다.\n\n---\n\n### 정규식(Regex) 경로 매칭\n\nNext.js `rewrites` 설정에서 복잡한 경로 지정이 필요할 때는 정규식을 써서 더욱 세밀한 매칭도 가능해요.  \n정규식은 보통 문자열 패턴 매칭에 강력한 무기인 만큼, 유연한 라우팅 구현에 큰 도움이 됩니다.\n\n예를 들어, `/post/:id(\\\\d+)` 라는 경로는 숫자(id)가 들어가는 경로만 정확히 잡고 싶을 때 쓸 수 있어요.  \n즉 `/post/123`는 매칭되고 `/post/abc`는 매칭 안되도록 하는 거죠.\n\n---\n\n여기까지 와일드카드와 정규식 경로 매칭에 대해서 간단히 살펴봤는데요,  \n다음에는 정규식을 써서 실제로 어떻게 경로를 재작성하는지 예제를 들어서 더 쉽게 알려드릴게요!  \n궁금한 점 있으면 댓글로 남겨주세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n정규식(Regex)로 경로를 매칭하고 싶다면, 파라미터 뒤에 괄호() 안에 정규식을 감싸서 사용할 수 있어요. 예를 들어, `/blog/:slug(\\\\d{1,})`라고 하면 `/blog/123`처럼 숫자로만 된 경로는 매칭되고 `/blog/abc` 같은 문자는 매칭되지 않아요.\n\n아래 예시를 볼게요:\n\n```js\nmodule.exports = {\n  async rewrites() {\n    return [\n      {\n        source: '/old-blog/:post(\\\\d{1,})',\n        destination: '/blog/:post', // 매칭된 파라미터를 목적지 경로에서 사용할 수 있어요\n      },\n    ]\n  },\n}\n```\n\n위 코드에서 `:post(\\\\d{1,})`는 1자리 이상 숫자가 와야 매칭돼요. 그래서 `/old-blog/123`으로 요청하면 `/blog/123`으로 리다이렉트되는 거죠.\n\n---\n\n추가로, 정규식에서 특수문자들인 `(`, `)`, `'`, ` `, `[`, `]`, `|`, `\\`, `^`, `.`, `:`, `*`, `+`, `-`, `?`, `$` 같은 문자는 그냥 쓰면 안 되고, 그냥 문자열로 매칭하고 싶으면 반드시 앞에 역슬래시(`\\`)를 붙여서 이스케이프 해야 해요.\n\n예를 들어, 경로에 괄호가 포함된 pattern을 매칭하고 싶을 때는 이렇게 작성하시면 됩니다:\n\n```js\nmodule.exports = {\n  async rewrites() {\n    return [\n      {\n        // `/english(default)/something` 처럼 괄호가 포함된 경로를 매칭합니다\n        source: '/english\\\\(default\\\\)/:slug',\n        destination: '/en-us/:slug',\n      },\n    ]\n  },\n}\n```\n\n이 경우 `/english(default)/page1`로 들어오는 요청은 `/en-us/page1`으로 리다이렉트되죠.\n\n---\n\n정리하면, Next.js rewrites 등에서 경로 매칭 시 정규식을 사용할 때는\n\n- 파라미터 뒤에 괄호로 정규식을 감싸서 세부 매칭 조건을 줄 수 있고\n- 특수문자는 `\\\\`로 꼭 이스케이프해서 사용하세요.\n\n그래야 원하는 경로를 정확히 매칭할 수 있고 의도치 않은 오류를 예방할 수 있습니다. \n\n이 방식으로 유연하게 URL 경로 패턴을 조절해보세요! 개발할 때 알아두면 꽤 유용합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 헤더, 쿠키, 쿼리 매칭하기\n\n리라이트(rewrite)를 특정 조건에 맞출 때 헤더, 쿠키, 쿼리 값이 특정 값과 맞아야 하거나, 특정 값이 없어야 할 때도 있죠? 이럴 때 사용하는 게 바로 `has` 필드와 `missing` 필드입니다. \n\n여기서 중요한 점은, 리라이트가 적용되려면 **source**와 `has`에 정의된 모든 항목이 일치해야 하고, 동시에 `missing`에 정의된 항목은 전부 일치하지 않아야 한다는 거예요. 쉽게 말해, 필요한 건 있어야 하고 없어야 할 건 없어야 한다는 뜻이죠.\n\n### has와 missing에서 사용할 수 있는 항목들\n\n| 필드 이름 | 타입 | 설명 |\n|---|---|---|\n| type | String | `header`, `cookie`, `host`, `query` 중 하나로 요청의 어디를 검사할지 지정 |\n| key | String | 검사하려는 항목의 키(이름), 예를 들어 헤더 이름이나 쿠키 이름 등 |\n| value | String 또는 undefined | 검사할 값. 만약 `undefined`면 어떤 값이든 매치 |  \n\n특히 `value`에는 정규표현식처럼 작동하는 문자열도 쓸 수 있어요. 예를 들어, `first-(?paramName.*)`라는 값을 쓰면, 실제 값 `first-second`에서 `second` 부분만 뽑아서 나중에 리라이트 목적지(destination)에서 `:paramName`라는 이름으로 활용할 수 있다는 점도 참신하죠?\n\n---\n\n### 조금 더 풀어보자면\n\n- `has`는 “이것들이 있어야 한다”는 의미예요.\n- `missing`은 “이것들이 없어야 한다”는 조건이죠.\n\n예를 들어,\n\n- `has`에 `{ type: 'header', key: 'x-user', value: 'admin' }`가 있으면, `x-user` 헤더가 `admin`이어야 리라이트됩니다.\n- `missing`에 `{ type: 'cookie', key: 'session', value: undefined }`가 있으면, `session`이라는 쿠키가 없어야 리라이트가 적용됩니다.\n\n이런 조건들을 조합하면 꽤 상세하고 구체적인 요청 매칭을 할 수 있답니다!\n\n---\n\n이 기능을 활용하면 더 똑똑하고 유연한 리라이트를 구현할 수 있어서, 특정 조건에 따라 페이지를 다르게 보여주거나 API 요청처리를 달리 할 때 정말 유용해요. 다음에 직접 예제도 만들어서 보여드릴게요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js의 `rewrites` 기능을 사용하면 특정 요청에 대해 URL 경로를 내부 또는 외부 URL로 \"재작성(rewrite)\"할 수 있어요. 이 기능은 특히 점진적으로 Next.js를 도입하거나, 내부 URL을 사용자에게 숨기고 싶을 때 유용하게 쓰입니다.\n\n### 헤더, 쿼리, 쿠키, 호스트에 따른 rewrites 예시\n\n```js\nmodule.exports = {\n  async rewrites() {\n    return [\n      // 1. 요청 헤더에 'x-rewrite-me'가 있으면 '/another-page'로 보낸다\n      {\n        source: '/:path*',\n        has: [\n          { type: 'header', key: 'x-rewrite-me' },\n        ],\n        destination: '/another-page',\n      },\n      // 2. 요청 헤더에 'x-rewrite-me'가 없으면 '/another-page'로 보낸다\n      {\n        source: '/:path*',\n        missing: [\n          { type: 'header', key: 'x-rewrite-me' },\n        ],\n        destination: '/another-page',\n      },\n      // 3. 쿼리 'page=home'이고 쿠키 'authorized=true'일 때 '/specific/:path*/home'으로 보낸다\n      {\n        source: '/specific/:path*',\n        has: [\n          { type: 'query', key: 'page', value: 'home' },\n          { type: 'cookie', key: 'authorized', value: 'true' },\n        ],\n        destination: '/:path*/home',\n      },\n      // 4. 헤더 'x-authorized'에 'yes' 또는 'true'가 포함되어 있으면 '/home'에 쿼리로 authorized 값 붙이기\n      {\n        source: '/:path*',\n        has: [\n          { type: 'header', key: 'x-authorized', value: '(?\u003cauthorized\u003eyes|true)' },\n        ],\n        destination: '/home?authorized=:authorized',\n      },\n      // 5. 호스트가 'example.com'이면 '/another-page'로 보낸다\n      {\n        source: '/:path*',\n        has: [\n          { type: 'host', value: 'example.com' },\n        ],\n        destination: '/another-page',\n      },\n    ]\n  },\n}\n```\n\n위 예시에서 볼 수 있듯이, 단순히 경로만 보고 리다이렉트하는 게 아니라 헤더, 쿠키, 쿼리 파라미터, 심지어 호스트까지 고려해서 경로를 바꿀 수 있습니다. 만약 조건에 맞는 헤더가 있으면 rewrite를 다르게 적용하는 식으로 세밀한 컨트롤이 가능해요.\n\n---\n\n## 외부 URL로도 리라이트가 가능합니다!\n\n재밌는 점은 내부 페이지뿐 아니라 외부 URL로도 갈 수 있다는거예요. 예를 들어, 기존 웹사이트의 특정 경로를 Next.js 안에서 재작성해서 외부 사이트로 연결하고 싶을 때 아주 유용하죠.\n\n```js\nmodule.exports = {\n  async rewrites() {\n    return [\n      // '/blog' 경로는 https://example.com/blog 로 이동\n      {\n        source: '/blog',\n        destination: 'https://example.com/blog',\n      },\n      // '/blog/:slug' 경로도 https://example.com/blog/:slug 로 매칭되는 대로 이동\n      {\n        source: '/blog/:slug',\n        destination: 'https://example.com/blog/:slug',\n      },\n    ]\n  },\n}\n```\n\n이처럼 외부 URL도 `destination`에 바로 적으면 그쪽으로 요청을 보낼 수 있답니다. 특히 마이그레이션 기간에 기존 서비스와 신 서비스를 자연스럽게 연결할 때 매우 유용해요.\n\n---\n\n### 추가 팁!\n\n- **rewrites vs redirects:** rewrites는 URL을 바꿔서 서버에서 다른 페이지를 보여주지만, 실제 사용자에게는 원래 URL이 유지돼요. 반면 redirects는 사용자를 다른 URL로 실제로 이동시키고 브라우저 주소창도 바뀝니다.\n- **조건이 많을 때는 꼭 주의:** 너무 복잡한 조건을 걸면 관리하기 어려우니, 가독성을 고려해서 몇 개의 룰을 잘 분리해서 쓰는 게 좋아요.\n- **value를 안쓰거나 캡처 그룹을 쓰면 경로 파라미터 활용 가능:** 위 예시처럼 `(??\u003cauthorized\u003eyes|true)` 처럼 정규표현식 캡처 그룹을 쓰면 재작성 대상 경로에 캡처된 값을 쉽게 쓸 수 있어요.\n\n이제 필요에 따라 세밀하게 페이지 경로를 조작해보세요! Next.js rewrites 기능은 생각보다 강력해서 몇 가지 응용만 알면 정말 다양한 케이스에 적용할 수 있답니다. 🙂\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nnext.js에서 `trailingSlash: true` 설정을 사용할 때 꼭 알아둬야 할 점이 있어요. 바로 리다이렉트(rewrites) 설정할 때 `source` 경로 끝에도 꼭 슬래시(/)를 붙여줘야 한다는 거죠. 목적지(destination) URL도 마찬가지예요. 만약 원격 서버가 슬래시를 기대한다면 destination 경로 끝에도 슬래시를 붙여줘야 정상적으로 동작합니다.\n\n예를 들어, 아래와 같이 설정하면 `/blog/` 또는 `/blog/` 하위 경로로 들어오는 요청을 정확히 리다이렉트할 수 있어요.\n\n```js\nmodule.exports = {\n  trailingSlash: true,\n  async rewrites() {\n    return [\n      {\n        source: '/blog/',\n        destination: 'https://example.com/blog/',\n      },\n      {\n        source: '/blog/:path*/',\n        destination: 'https://example.com/blog/:path*/',\n      },\n    ]\n  },\n}\n```\n\n여기서 `:path*`는 와일드카드처럼 동작해서 `/blog/anything/here/` 같은 하위 경로도 전부 포괄해줍니다.\n\n---\n\n### Next.js 점진적 도입 (Incremental adoption)\n\n또 하나 재미있는 점은, 기존에 운영 중인 웹사이트가 있을 때 Next.js로 점진적으로 옮겨갈 수 있다는 거예요. Next.js가 먼저 자신의 라우트들을 검사한 후에 해당 경로가 없다면 기존 서버 쪽으로 프록시(proxy) 요청을 넘기는 방법이죠.\n\n이 방식을 사용하면 한 번에 모든 페이지를 Next.js로 옮기지 않아도 되고, 조금씩 옮기면서 안정적으로 서비스를 개선할 수 있답니다.\n\n---\n\n#### 추가 팁!\n\n- `trailingSlash` 옵션을 켜면 빌드된 정적 파일들도 자동으로 폴더 형식으로 생성됩니다. 예를 들어 `/about`은 `/about/index.html`로 만들어지고, 브라우저에서는 `/about/` URL로 접근하게 되죠.\n- 리다이렉트 설정에서 슬래시는 사소해 보여도, 이 부분이 틀리면 404 에러가 날 수 있으니 꼭 신경 써 주세요.\n- 점진적 도입을 고려한다면, Next.js의 `rewrites`와 `fallback` 기능을 적극 활용해보세요. 개발할 때 훨씬 유연해질 거예요!\n\n다음에도 Next.js 관련해서 재미있고 쓸모 있는 팁 있으면 계속 공유할게요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js로 더 많은 페이지를 마이그레이션할 때, 리라이트(rewrites) 설정을 매번 바꿀 필요가 없도록 하는 방법을 알려 드릴게요.\n\n```js\nmodule.exports = {\n  async rewrites() {\n    return {\n      fallback: [\n        {\n          source: '/:path*',\n          destination: `https://custom-routes-proxying-endpoint.vercel.app/:path*`,\n        },\n      ],\n    }\n  },\n}\n```\n\n이렇게 하면 어떤 경로로 들어오든 `https://custom-routes-proxying-endpoint.vercel.app` 쪽으로 다 연결해주는 역할을 해요. 그래서 점진적으로 Next.js로 옮겨가는 중에도 기존 경로를 일일이 바꿀 필요 없이 한 번에 처리할 수 있죠.\n\n---\n\n### basePath 지원하는 리라이트\n\nNext.js에서 `basePath`를 사용하면서 리라이트를 할 때는 `source`와 `destination` 양쪽 경로 모두 자동으로 `basePath`가 앞에 붙어요. 만약 어떤 리라이트에서 `basePath`를 붙이고 싶지 않으면, 아래처럼 `basePath: false`를 추가하면 됩니다.\n\n```js\nmodule.exports = {\n  async rewrites() {\n    return {\n      fallback: [\n        {\n          source: '/custom-path/:path*',\n          destination: 'https://external-site.com/:path*',\n          basePath: false,  // basePath 자동 접두사 안붙임\n        },\n      ],\n    }\n  },\n}\n```\n\n이렇게 쓰면 `basePath`가 없는 그대로 외부 도메인 주소로 리다이렉션하게 돼요. \n\n---\n\n**추가 팁!**\n\n1. `rewrites`는 URL 경로를 클라이언트에게 그대로 보여주면서 내부적으로 다른 경로로 연결해주는 기능이에요. SEO나 UX에 민감한 상황에서 유용하죠.\n2. `fallback` 속성은 일치하는 리라이트 규칙이 없을 때 마지막으로 적용되는 규칙이라, 넓은 범위의 라우팅을 처리할 때 깔끔하게 쓸 수 있어요.\n3. 만약 API 요청 경로나 이미지 리퀘스트에 리라이트를 복잡하게 적용해야 한다면, 별도의 규칙으로 꼼꼼히 테스트해보세요.\n\nNext.js에서 라우팅을 다루는 게 어렵게 느껴질 수 있지만, 이런 설정들을 잘 활용하면 한결 유연하고 깔끔하게 관리할 수 있으니 꼭 한번 시도해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nmodule.exports = {\n  basePath: '/docs',\n\n  async rewrites() {\n    return [\n      {\n        source: '/with-basePath', // /docs/with-basePath로 자동 변환됨\n        destination: '/another',  // /docs/another로 자동 변환됨\n      },\n      {\n        // basePath: false가 설정되어 있어 /docs가 붙지 않음\n        // 참고: 내부 리다이렉트(예: destination: '/another')에는 사용할 수 없음\n        source: '/without-basePath',\n        destination: 'https://example.com',\n        basePath: false,\n      },\n    ]\n  },\n}\n```\n\n---\n\n## 버전 히스토리\n\n| Version   | Changes           |\n|-----------|-------------------|\n| `v13.3.0` | `missing` 추가됨  |\n| `v10.2.0` | `has` 추가됨      |\n| `v9.5.0`  | Headers 추가됨    |\n\n---\n\n### 살짝 더 알려드려요!\n\n- **basePath**는 Next.js에서 모든 경로 앞에 특정 기본 경로를 붙이고 싶을 때 사용해요. 예를 들어, 위 예제처럼 `basePath: '/docs'`를 설정하면, 모든 페이지와 API가 `/docs` 하위에 위치해요.  \n- `rewrites`는 요청 경로를 다른 경로나 외부 URL로 내부적으로 바꿔주는 역할을 하죠. 위 코드에서는 `/with-basePath` 요청이 `/docs/with-basePath`로, `/another` 경로로도 매핑되는 걸 볼 수 있어요.\n- 그런데 `basePath: false` 옵션이 들어간 리라이트는 좀 특별해요. 이 옵션을 주면 기본 경로가 붙지 않고, 외부 URL(예: `https://example.com`)로 바로 연결할 수 있어요. 다만, 내부 경로 리라이트에선 사용할 수 없으니 주의하세요.\n- 버전 히스토리를 보면 점차 기능이 추가되고 확장된 걸 알 수 있는데, 개발 중인 프로젝트에 필요한 기능이 어느 버전부터 생겼는지 참고하면 좋아요!\n\n다음에 또 재미있는 개발 팁 들고 올게요! 궁금한 점 있으면 언제든 물어봐 주세요~","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":23},{"title":"ReactJS에서 maxHeadersLength 설정하는 방법","description":"","date":"2025-04-22 13:19","slug":"2025-04-22-reactMaxHeadersLength","content":"\n\n# reactMaxHeadersLength 설정 알아보기\n\n리액트에서 정적 렌더링(static rendering)을 할 때, 응답 헤더에 추가할 수 있는 여러 헤더들을 만들어낼 수 있어요. 이 헤더들은 브라우저가 폰트, 스크립트, 스타일시트 같은 리소스를 미리 불러오게(preload) 도와서 페이지 로딩 속도를 쑥~ 올려주는 역할을 해주죠.\n\n디폴트 값은 6000인데, 환경에 따라 이 크기를 조절하고 싶다면 `next.config.js` 파일에서 `reactMaxHeadersLength` 옵션을 직접 설정할 수 있어요. 예를 들어, 헤더 총 길이를 1000으로 제한하려면 이렇게 작성하면 됩니다:\n\n```js\nmodule.exports = {\n  reactMaxHeadersLength: 1000,\n}\n```\n\n\u003e 참고! 이 옵션은 App Router를 사용할 때만 적용 가능하니, 기존 Pages Router를 이용 중이라면 신경쓰지 않아도 됩니다.\n\n추가로, 이 옵션을 너무 낮게 설정하면 preload 헤더가 잘려서 필요한 리소스가 미리 로드되지 않을 수 있으니 주의하세요. 반대로 너무 높게 설정하면 헤더 크기가 너무 커져서 네트워크 효율이 떨어질 수 있으니 적당한 균형을 찾는 게 중요합니다.\n\n요약하자면, 정적 렌더링 성능 최적화를 위해 헤더 길이를 적절히 설정하는 `reactMaxHeadersLength` 옵션을 활용해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n브라우저와 서버 사이에 어떤 종류의 프록시가 있느냐에 따라 HTTP 헤더가 잘려버릴 수 있어요. 예를 들어, 리버스 프록시(reverse proxy)를 사용하는데 이 프록시가 긴 헤더를 제대로 처리하지 못한다면, 헤더가 중간에 잘릴 위험이 있답니다. 그래서 이럴 땐 헤더 길이 제한 값을 낮춰서 잘리지 않도록 세팅하는 게 좋아요.\n\n사실 이런 문제는 특히 대용량 쿠키나 토큰을 헤더에 넣을 때 종종 발생하곤 해요. 리버스 프록시뿐만 아니라, 네트워크 장비나 보안 솔루션에도 헤더 길이 제한이 있기 때문에 어디서든 문제가 될 수 있죠. 그래서 개발할 때 이 점을 염두에 두고, 너무 큰 헤더를 보내지 않도록 주의하는 게 좋습니다.\n\n간단히 정리해보면:\n\n| 상황                 | 해결 방법                             |\n|--------------------|---------------------------------|\n| 프록시가 긴 헤더를 못 처리할 때 | 헤더 길이 제한 값을 낮춰 설정                   |\n| 대용량 쿠키나 토큰 사용 시       | 필요 없는 데이터 제거 또는 쿠키 분할 등 최적화 작업 |\n| 헤더 길이 제한으로 인한 문제 발견  | 프록시 및 네트워크 장비 설정 점검 및 조정          |\n\n이런 이슈들은 특히 트래픽이 많은 서비스에서 쉽게 지나치기 쉬운데, 한 번 겪으면 서비스 안정성에 큰 영향을 미치니 꼭 체크해보시길 바랍니다!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":2},{"title":"Nextjs 15에서 reactStrictMode 사용하는 방법","description":"","date":"2025-04-22 13:19","slug":"2025-04-22-reactStrictMode","content":"\n\n# reactStrictMode\n\n\u003e 참고할 점: Next.js 13.5.1 버전부터는 app router를 사용할 때 기본적으로 Strict Mode가 활성화되어 있어서, 위에서 말한 설정은 오직 pages 디렉터리에 대해서만 필요해요. 물론 `reactStrictMode: false`로 설정해서 Strict Mode를 끌 수도 있습니다.\n\n\u003e 추천: Next.js 애플리케이션에서 Strict Mode를 꼭 켜두는 걸 강력하게 추천해요. 앞으로 React가 발전해가는 방향에 잘 대비할 수 있기 때문이죠.\n\n## React의 Strict Mode란?\n\nStrict Mode는 개발할 때만 활성화되는 기능으로, 앱에서 발생할 수 있는 잠재적인 문제를 미리 파악할 수 있도록 도와줘요. 예를 들어, 위험한 라이프사이클 메서드 사용이나 구버전 API 사용 같은 흔히 간과하기 쉬운 부분들을 찾아내죠.\n\n좀 더 쉽게 말하면, 실수를 잡아내는 ‘개발자 전용 사이렌’ 같은 역할을 한다고 보면 돼요. 그래서 실서비스에 영향을 주지 않고도 코드 품질을 높이고 문제를 미리 예방할 수 있습니다.\n\n### 참고로 알아두면 좋은 점\n\n- Strict Mode를 켜면 일부 컴포넌트가 두 번 렌더링되기도 하는데, 이것도 문제를 찾아내기 위한 의도된 동작이에요.\n- 라이프사이클 메서드 중 일부가 더 이상 권장되지 않거나 향후 React 버전에서 제거될 예정인 경우 Strict Mode가 알려줍니다.\n- 앱이 커질수록 이런 문제를 미리 발견하는 게 복잡한 버그 잡는 것보다 훨씬 효율적이에요.\n\nNext.js를 쓰면서 `next.config.js`에 아래처럼 설정하면 됩니다:\n\n```js\nmodule.exports = {\n  reactStrictMode: true,\n};\n```\n\n마지막으로, Strict Mode가 자동으로 켜지는 app router 환경에서는 따로 설정할 필요 없으니 참고하세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js 런타임은 기본적으로 React의 Strict Mode 규격을 잘 준수하고 있어요. 만약 여러분이 Next.js 프로젝트 전체에 Strict Mode를 적용하고 싶다면, 아래처럼 `next.config.js` 파일에 옵션을 설정해주면 됩니다.\n\n```js\nmodule.exports = {\n  reactStrictMode: true,\n}\n```\n\n이렇게 하면 프로젝트 전체가 Strict Mode로 동작하게 돼요.\n\n하지만 만약 팀이나 프로젝트 상황상, 전체 앱에 한꺼번에 Strict Mode를 적용하기 부담스럽다면 걱정하지 마세요! 꼭 전체에 적용할 필요 없이, React의 `\u003cReact.StrictMode\u003e` 컴포넌트를 사용해서 페이지 단위로 조금씩 마이그레이션 할 수 있답니다.\n\n예를 들어, 특정 페이지 파일에서 아래처럼 감싸주면 그 페이지만 Strict Mode로 작동하게 돼요.\n\n```jsx\nimport React from 'react';\n\nexport default function MyPage() {\n  return (\n    \u003cReact.StrictMode\u003e\n      {/* 여기에 페이지 컴포넌트 JSX */}\n    \u003c/React.StrictMode\u003e\n  );\n}\n```\n\n이렇게 하면 단계적으로 코드 품질을 높여가면서 안정적으로 Strict Mode를 적용할 수 있죠.\n\n사실 Strict Mode는 개발 중에만 활성화되는 체크 기능이라, 프로덕션에는 영향이 없는 점도 참고하세요. React에서 권장하는 좋은 코딩 습관을 지키고, 잠재적인 버그를 미리 잡아내기에 매우 유용하니, 서서히 도입해보시길 추천합니다!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":3},{"title":"Nextjs 15 웹사이트에서 다른 url로 보내는 방법","description":"","date":"2025-04-22 13:19","slug":"2025-04-22-redirects","content":"\n\n# Redirects (리다이렉트)\n\n리다이렉트는 사용자가 특정 URL로 접속했을 때, 다른 URL로 자동으로 이동시키는 기능이에요. 예를 들어, 예전 페이지 주소가 바뀌었거나, 좀 더 깔끔한 URL로 바꾸고 싶을 때 유용하게 쓰이죠.\n\nNext.js에서는 `next.config.js` 파일 안에 `redirects`라는 키를 써서 쉽게 리다이렉트를 설정할 수 있어요.\n\n```js\nmodule.exports = {\n  async redirects() {\n    return [\n      {\n        source: '/about',       // 리다이렉트가 발생할 원본 경로\n        destination: '/',       // 이동할 대상 경로\n        permanent: true,        // 301 리다이렉트 여부 (true면 301, false면 302)\n      },\n    ]\n  },\n}\n```\n\n- **source**: 사용자가 접속할 원래 경로\n- **destination**: 사용자를 보내고 싶은 새 경로\n- **permanent**: 영구 리다이렉트인가? (true=301, false=302)\n\n### 추가로 알고 가면 좋은 점\n\n- **동적 라우팅도 가능해요.** 예를 들어 `/blog/:slug` 같은 패턴을 잡아서 리다이렉트할 수 있어요.\n- **프론트엔드에서 직접 처리하는 리다이렉트와 다릅니다.** 이 설정은 빌드 타임에 Next.js 서버 레벨에서 처리하기 때문에 SEO에도 긍정적이에요.\n- 만약 조건부로 리다이렉트를 하고 싶다면, 이 함수 내에서 자유롭게 로직을 짤 수도 있습니다.\n\n리다이렉트를 적절히 활용하면 사용자의 URL 접근 경험도 깔끔해지고, 잘못된 주소로 들어오는 걸 막는 것도 가능해서 사이트 운영에 큰 도움이 돼요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nredirects는 비동기(async) 함수로, source, destination, permanent 속성을 가진 객체들을 요소로 하는 배열을 반환해야 합니다.\n\n| 속성           | 설명                                                                                                   |\n|--------------|------------------------------------------------------------------------------------------------------|\n| **source**      | 들어오는 요청 경로 패턴입니다.                                                                           |\n| **destination** | 라우팅하려는 경로입니다.                                                                                  |\n| **permanent**   | true이면 308 상태 코드를 사용해 클라이언트/검색엔진이 영구적으로 리다이렉트를 캐싱하도록 하고, false이면 307 상태 코드를 사용해 임시 리다이렉트이며 캐싱하지 않습니다. |\n\n### 왜 Next.js는 307과 308 상태 코드를 사용할까?\n\n전통적으로 임시 리다이렉트는 302, 영구 리다이렉트는 301 상태 코드를 사용했는데요, 문제는 많은 브라우저들이 리다이렉트를 처리하면서 원래 요청 메서드(GET, POST 등)를 무시하고 무조건 GET으로 바꿔버리는 경우가 있었어요.\n\n예를 들어, POST /v1/users 요청이 302 상태 코드와 Location 헤더(/v2/users)를 반환하면, 브라우저가 다음 요청을 POST가 아니라 GET /v2/users로 보낼 수도 있다는 거죠. 이게 의도와 다르니까 개발자 입장에서 곤란해질 수 있습니다.\n\n그래서 Next.js는 이 문제를 해결하기 위해 **307 (임시 리다이렉트)** 과 **308 (영구 리다이렉트)** 상태 코드를 사용해, 리다이렉트 시에도 원래 HTTP 메서드를 꼭 유지하도록 명시해줍니다.\n\n---\n\n그 외에도 redirects 객체 안에 쓸 수 있는 속성들이 있어요:\n\n| 속성       | 설명                                                                                               |\n|----------|--------------------------------------------------------------------------------------------------|\n| **basePath** | false 혹은 undefined. false면 basePath가 매칭 경로에 포함되지 않으며, 주로 외부 리다이렉트 시에 사용합니다.          |\n| **locale**   | false 혹은 undefined. false면 locale이 매칭 경로에 포함되지 않습니다.                                      |\n| **has**      | has 객체들의 배열입니다. 각 객체는 type, key, value 속성을 포함합니다. 추가 조건을 확인할 때 사용합니다.             |\n| **missing**  | missing 객체들의 배열입니다. 각 객체는 type, key, value 속성을 포함하며, 특정 조건이 없을 때 적용됩니다.               |\n\n---\n\n### 개인적으로 팁 하나!\n\nredirects를 잘 활용하면, 앱이나 웹사이트를 운영할 때 URL 구조가 바뀌더라도 깨지지 않는 깨끗한 리다이렉트를 만들 수 있어요. 예를 들어, 특정 구간에서 사용자 위치에 따라 다르게 리다이렉트한다거나, 인증 여부에 따른 분기처리를 쉽게 구현할 수 있죠.\n\n여기에 `has` 와 `missing` 조건을 적절히 조합하면, 복잡한 조건별 리다이렉트도 깔끔하게 처리할 수 있으니 꼭 기억해두세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n리다이렉트(Redirect)는 페이지와 /public 파일 등 실제 파일 시스템을 확인하기 전에 먼저 체크됩니다.\n\nPages Router를 사용할 때, 리다이렉트는 클라이언트 사이드 라우팅(예: Link 컴포넌트나 router.push)에는 적용되지 않아요. 단, Middleware가 존재하고 해당 경로와 일치하는 경우에만 예외입니다. 즉, 클라이언트 쪽에서 URL을 바꿀 때는 기본적으로 리다이렉트가 자동으로 작동하지 않는 거죠.\n\n그리고 중요한 점! 리다이렉트가 발생하면, 원래 요청에 있던 쿼리(query) 값들은 그대로 리다이렉트 목적지로 전달됩니다. 예를 들어, 다음과 같은 리다이렉트 설정이 있다고 가정해 봅시다:\n\n\n| 속성        | 설명                                                      |\n|-------------|-----------------------------------------------------------|\n| source      | '/old-blog/:path*'                                        |\n| destination | '/blog/:path*'                                            |\n| permanent   | false (임시 리다이렉트, 상태 코드 307/302로 처리됨)         |\n\n\n이 설정은 `/old-blog/어떤경로`로 접속하면 `/blog/어떤경로`로 이동하라는 뜻이에요. 예를 들어, `/old-blog/post-1?ref=google` 로 접속하면, 이 쿼리 값 `?ref=google` 도 그대로 `/blog/post-1?ref=google`로 전달됩니다.\n\n추가로, permanent 옵션을 true로 설정하면 301 영구 리다이렉트가 발생합니다. SEO에 민감하거나 URL 구조가 완전히 바뀐 경우 permanent를 true로 바꾸는 게 좋아요. 반대로, 아직 리다이렉트가 임시임을 알리고 싶다면 false로 두면 되구요.\n\n요약하자면, 리다이렉트는 서버 쪽에서 우선 처리되고 쿼리는 유지되며, 클라이언트 사이드 라우팅에는 Middleware 없이는 기본으로 적용되지 않는다는 점 기억하세요! 개발하면서 경로 변경이나 사이트 구조를 리팩토링할 때 이 부분 꼭 챙기세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003e 참고! 경로 파라미터에서 소스와 목적지 경로를 작성할 때는 콜론(:) 앞에 꼭 슬래시(/)를 붙여줘야 해요. 만약 슬래시 없이 콜론만 쓰면 그 경로가 단순한 문자열로 인식돼서 무한 리다이렉트 문제가 발생할 수 있답니다.\n\n예를 들어, 클라이언트가 `/old-blog/post-1?hello=world`를 요청하면, `/blog/post-1?hello=world`로 리다이렉트된다는 걸 기억하세요.\n\n## 경로 매칭 (Path Matching)\n\n경로 매칭은 이렇게 부분적으로도 가능합니다. 예를 들어 `/old-blog/:slug`로 설정하면, `/old-blog/hello-world` 같은 경로와 매칭이 되구요. 단, 중첩 경로(예: `/old-blog/hello-world/extra`)는 매칭되지 않습니다.\n\n아래 표로 예시를 정리해봤어요.\n\n| 설정된 경로          | 매칭되는 요청 경로         | 설명                         |\n|-----------------|---------------------|----------------------------|\n| `/old-blog/:slug` | `/old-blog/hello-world` | 매칭됨 - 단일 경로 파라미터           |\n| `/old-blog/:slug` | `/old-blog`          | 매칭 안됨 - 파라미터가 없기 때문           |\n| `/old-blog/:slug` | `/old-blog/hello-world/extra` | 매칭 안됨 - 중첩 경로는 지원하지 않음 |\n\n만약 더 복잡한 경로 매칭이 필요하면, 정규 표현식이나 다른 라우팅 라이브러리를 활용하는 방법도 있으니 참고하세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자, 이번에는 Next.js에서 리다이렉트(redirects)를 설정하는 방법에 대해 이야기해볼게요. 사실 개발하면서 기존 URL들을 새 URL로 깔끔하게 바꿔주고 싶을 때 리다이렉트 설정만 잘 해줘도 SEO나 사용자 경험에 큰 도움이 되거든요.\n\n---\n\n### 기본 리다이렉트 설정\n\n```js\nmodule.exports = {\n  async redirects() {\n    return [\n      {\n        source: '/old-blog/:slug',\n        destination: '/news/:slug', // 동적으로 들어온 slug 값을 destination에서도 쓸 수 있어요\n        permanent: true, // 301 영구 리다이렉트\n      },\n    ]\n  },\n}\n```\n\n위 코드처럼 `redirects` 함수 안에 리다이렉트 규칙을 배열로 리턴해주면 돼요.  \n- `source`는 기존 URL 패턴,  \n- `destination`은 새로운 URL 경로,  \n- 그리고 `permanent: true`는 301 리다이렉트, 즉 영구 이동을 의미해요.\n\n여기서 주목할 점은 `:slug`라고 쓴 부분인데요, URL에서 동적으로 변하는 값(예: 글의 고유 아이디, 제목 등)을 변수처럼 잡아낼 수 있어요. 그리고 그 변수를 바뀐 URL 쪽에서도 그대로 쓸 수 있다는 점!\n\n---\n\n### 와일드카드 경로 매칭하기\n\n하나의 파라미터가 여러 단계의 하위 경로를 모두 커버해야 한다면 어떻게 할까요? 바로 `*`(별표)를 뒤에 붙여서 와일드카드로 사용할 수 있어요!\n\n```js\nmodule.exports = {\n  async redirects() {\n    return [\n      {\n        source: '/blog/:slug*',\n        destination: '/news/:slug*', // 여러 단계 하위 경로도 그대로 넘겨줘요\n        permanent: true,\n      },\n    ]\n  },\n}\n```\n\n위처럼 `:slug*`라고 하면 `/blog/a/b/c` 같은 여러 하위 경로까지 다 매칭해 줍니다. 그리고 destination에서도 똑같이 써서 경로 구성을 유지할 수 있죠.\n\n---\n\n### 추가 Tip!\n\n- 리다이렉트 설정은 빌드 시에만 적용되기 때문에, 동적으로 변하는 값을 잘 조합해서 만들면 SEO에도 엄청 도움 됩니다.\n- `permanent: false`로 설정하면 임시 리다이렉트(302)가 돼요. 테스트할 때 이 옵션을 잘 활용하면 좋겠죠?\n- Next.js 리다이렉트 경로 설정은 서버나 클라이언트 쪽 둘 다에서 작동하니, 유저가 URL을 직접 접근해서 잘못된 페이지로 가지 않도록 꼼꼼히 설정해 주세요.\n\n---\n\n요약하자면, Next.js의 `redirects()`에서 `source` 경로에 파라미터(`:slug`)와 와일드카드(`*`)를 적절히 사용하면, 원하는 URL 구조를 자유롭게 리다이렉트 시킬 수 있다는 이야기에요.  \n코드를 직접 만져보면서 이해하면 훨씬 쉬우니, 간단한 프로젝트에서 한번 바로 적용해보길 추천합니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### Regex 경로 매칭\n\n간단히 말해, 경로에서 특정 패턴을 정규식으로 매칭하고 싶을 때는 파라미터 뒤에 소괄호로 정규식을 감싸주면 돼요. 예를 들어, `/post/:slug(\\d{1,})` 이렇게 작성하면 `/post/123` 같은 숫자만 매칭되고 `/post/abc` 같은 문자는 매칭되지 않아요.\n\n```js\nmodule.exports = {\n  async redirects() {\n    return [\n      {\n        source: '/post/:slug(\\\\d{1,})',\n        destination: '/news/:slug', // 매칭된 파라미터를 목적지 경로에서도 사용할 수 있어요\n        permanent: false,\n      },\n    ]\n  },\n}\n```\n\n조금 설명을 덧붙이자면, 여기서 `:slug(\\\\d{1,})` 부분은 'slug'라는 이름의 파라미터가 숫자 1개 이상이어야 한다는 의미입니다.\n\n추가로 참고하면 좋은 점! 정규식에 포함된 특수문자 중 `(`, `)`, `'`, `:`, `*`, `+`, `?` 같은 글자들은 일반 문자로 쓰고 싶을 땐 앞에 `\\\\`를 붙여서 이스케이프(escape) 처리를 해줘야 한다는 점 기억하세요.\n\n| 특수문자 | 설명                         | 사용 시 주의사항       |\n|----------|------------------------------|-----------------------|\n| ( )      | 그룹핑 또는 매칭 범위 지정   | `\\\\(`, `\\\\)`로 이스케이프 |\n| '        | 문자열 리터럴 등에서 사용    | `\\\\'`로 이스케이프           |\n| :        | 파라미터 시작 표시            | `\\\\:`로 이스케이프           |\n| *        | 0개 이상 반복                | `\\\\*`로 이스케이프           |\n| +        | 1개 이상 반복                | `\\\\+`로 이스케이프           |\n| ?        | 0개 또는 1개, 또는 선택적     | `\\\\?`로 이스케이프           |\n\n만약 이들 문자를 이스케이프 하지 않으면 정규식이 제대로 동작하지 않거나 의도하지 않은 매칭이 발생할 수 있으니 꼭 기억하세요!\n\n---\n\n이 기능을 활용하면 특정 URL 패턴만 선별해서 리다이렉트하거나, 라우팅을 매우 세밀하게 제어할 수 있어요. 예를 들어 블로그 글 번호가 숫자로만 이루어져 있을 때, 해당 번호를 이용해 다른 경로로 넘긴다거나 할 때 유용하죠.\n\n혹시 처음 써보는 분이라면 정규식 문법에 대해 기본적인 공부를 해보는 것도 추천합니다! 어렵게 느껴질 수 있지만, 익숙해지면 웹 개발에서 진짜 강력한 무기가 되니 꼭 한번 도전해보세요 :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nmodule.exports = {\n  async redirects() {\n    return [\n      {\n        // `/english(default)/something` 경로로 요청이 들어올 때 매칭됩니다.\n        source: '/english\\\\(default\\\\)/:slug',\n        destination: '/en-us/:slug',\n        permanent: false,  // 영구 리다이렉트가 아님을 의미\n      },\n    ]\n  },\n}\n```\n\n## Header, Cookie, 그리고 Query 값 조건에 따른 리다이렉트\n\n위 예시처럼 단순한 URL 매칭 외에도, 요청 헤더(header), 쿠키(cookie), 쿼리(query) 값에 따라서만 리다이렉트를 적용할 수 있어요. \n\n이를 위해 `has` 필드와 `missing` 필드를 활용할 수 있는데요,  \n- `has`: 지정한 조건들이 **모두** 일치해야 합니다. 예를 들어, 특정 쿠키가 있어야 한다거나, 쿼리 파라미터가 특정 값이어야 하죠.  \n- `missing`: 지정한 조건들이 **모두** 존재하지 않아야 합니다.\n\n즉, `source` 경로에 대한 매칭과 `has`의 모든 조건 만족, 그리고 `missing`의 모든 조건 불일치가 동시에 성립할 때만 해당 리다이렉트가 적용된답니다.\n\n---\n\n### has와 missing이 지원하는 필드 종류\n\n| 필드명     | 설명                   | 비고                                 |\n|------------|------------------------|------------------------------------|\n| `type`     | 검사 대상 유형          | `header`, `cookie`, `query` 중 하나 |\n| `key`      | 검사할 특정 헤더, 쿠키, 쿼리의 키 | 값이 없으면 전체 검사                  |\n| `value`    | 키에 대응되는 값 일치 여부 | 정규 표현식도 가능                   |\n\n예를 들어, `has`에 아래와 같은 형식으로 넣으면:\n\n```js\nhas: [\n  {\n    type: 'cookie',\n    key: 'user-preference',\n    value: 'dark-mode',\n  },\n  {\n    type: 'header',\n    key: 'x-custom-header',\n    value: '^special-value$',\n  },\n]\n```\n\n- 쿠키 `user-preference`가 `dark-mode`여야 하고,  \n- 헤더 `x-custom-header`가 정확히 `special-value`여야  \n리다이렉트가 동작합니다.\n\n---\n\n### 참고 팁!\n\n- `value`에 정규표현식을 쓸 땐, 슬래시(`/`)로 감싸지 않아도 되고, 그냥 문자열로 입력 후 내부적으로 정규식 매칭이 됩니다.  \n- 쿠키값이나 헤더값이 조금 복잡한 경우, 정규표현식의 패턴을 잘 작성해주면 원하는 조건만 정확히 걸러낼 수 있어요.  \n- 여러 조건을 조합해 리다이렉트를 세밀하게 컨트롤할 수 있으니, 사용자 환경에 따른 맞춤 경로 안내 같은 데 활용해보세요!\n\n---\n\n다음은 기본적인 테이블 마크다운 형식으로 정리한 `has`와 `missing` 필드 지원 항목입니다:\n\n| 필드      | 설명                               |\n|-----------|----------------------------------|\n| type      | 검사할 대상 타입 (header/cookie/query) |\n| key       | 검색할 특정 키 이름                      |\n| value     | 키에 매칭할 값 (정규표현식 가능)        |\n\n이 내용을 바탕으로, 조건부 리다이렉트를 만들 때 깔끔하고 유용하게 활용해보시길 바랍니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번에는 Next.js에서 제공하는 리디렉션(redirect) 설정 방법을 한 번 살펴볼게요. 특히 `has` 나 `missing` 속성으로 조건을 걸어 리퀘스트 헤더, 쿠키, 호스트, 쿼리 파라미터에 따라 리디렉션을 다르게 하는 예시인데요, 직접 써보면 확실히 서버단에서 세밀한 리디렉션 제어가 가능해서 아주 유용해요.\n\n---\n\n### 주요 옵션 설명\n\n| 옵션명     | 타입       | 설명                                                                                         |\n|------------|------------|----------------------------------------------------------------------------------------------|\n| type       | String     | 조건 유형 지정 (header, cookie, host, query 중 하나)                                        |\n| key        | String     | type에 따라 비교할 키 값을 지정                                                               |\n| value      | String or undefined | 비교할 값, undefined면 key에 해당하는 아무 값이라도 OK. 정규표현식 형태로 사용 가능 (named capture group 포함 가능) |\n\n- 예를 들어 `value: 'first-(?\u003cparamName\u003e.*)'` 이렇게 설정하면 실제로 `first-second`가 들어왔을 때 `:paramName` 으로 second 값을 받아서 destination에 활용할 수 있답니다.\n\n---\n\n### 예시 코드와 설명\n\n```js\nmodule.exports = {\n  async redirects() {\n    return [\n      // 1. x-redirect-me 헤더가 있으면 /another-page로 리디렉션\n      {\n        source: '/:path((?!another-page$).*)',\n        has: [\n          {\n            type: 'header',\n            key: 'x-redirect-me',\n          },\n        ],\n        permanent: false,\n        destination: '/another-page',\n      },\n      // 2. x-do-not-redirect 헤더가 없으면 /another-page로 리디렉션\n      {\n        source: '/:path((?!another-page$).*)',\n        missing: [\n          {\n            type: 'header',\n            key: 'x-do-not-redirect',\n          },\n        ],\n        permanent: false,\n        destination: '/another-page',\n      },\n      // 3. 쿼리 ?page=home 와 쿠키 authorized=true 가 모두 만족할 때만 리디렉션\n      {\n        source: '/specific/:path*',\n        has: [\n          {\n            type: 'query',\n            key: 'page',\n            value: 'home',\n          },\n          {\n            type: 'cookie',\n            key: 'authorized',\n            value: 'true',\n          },\n        ],\n        permanent: false,\n        destination: '/another/:path*',\n      },\n      // 4. x-authorized 헤더가 yes 또는 true 라는 값을 포함하면 해당 값 받아와서 쿼리에 넣음\n      {\n        source: '/',\n        has: [\n          {\n            type: 'header',\n            key: 'x-authorized',\n            value: '(?\u003cauthorized\u003eyes|true)',\n          },\n        ],\n        permanent: false,\n        destination: '/home?authorized=:authorized',\n      },\n      // 5. 호스트가 example.com이면 리디렉션\n      {\n        source: '/:path((?!another-page$).*)',\n        has: [\n          {\n            type: 'host',\n            value: 'example.com',\n          },\n        ],\n        permanent: false,\n        destination: '/another-page',\n      },\n    ]\n  },\n}\n```\n\n---\n\n### 중요한 팁 — basePath가 있을 때 리디렉션 설정\n\nNext.js에서 `basePath`를 사용 중이라면 리디렉션 설정 시에도 `source`와 `destination` 경로 앞에 자동으로 `basePath`가 붙어요. 만약 특정 리디렉션에 대해 `basePath`를 붙이고 싶지 않으면 아래처럼 `basePath: false` 옵션을 추가하면 됩니다.\n\n```js\n{\n  source: '/some-path',\n  destination: '/other-path',\n  basePath: false, // basePath 자동 추가 안함\n  permanent: true,\n}\n```\n\n이 점은 API 요청이나 다른 조건에 따라 `basePath` 적용 유무를 조절하고 싶을 때 매우 유용합니다.\n\n---\n\n### 정리하며...\n\n- `has`와 `missing` 으로 헤더, 쿠키, 쿼리, 호스트 조건을 세밀하게 걸 수 있어요.\n- 값에 정규식(named capture group)도 사용할 수 있어서 동적 리디렉션도 가능!\n- basePath 쓰면 기본적으로 경로 앞에 붙으니 필요한 경우 옵션으로 조절 가능.\n\n이 기능 하나만 잘 쓰면, 사용자 환경이나 상태에 따라 맞춤형 리디렉션 처리가 가능해서 리액트 앱 유저 경험 개선에 큰 도움이 돼요! 필요하신 분들은 꼭 활용해보시길 바랍니다 :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 basePath와 i18n를 사용할 때 리다이렉트 설정을 해보신 적 있나요? 오늘은 이 부분을 쉽게 설명해드릴게요. 코드 예제를 보면서 어떻게 작동하는지 함께 공부해봐요!\n\n---\n\n### 1. basePath와 함께하는 리다이렉트\n\n```js\nmodule.exports = {\n  basePath: '/docs',\n\n  async redirects() {\n    return [\n      {\n        source: '/with-basePath',      // /docs/with-basePath로 자동 변환\n        destination: '/another',       // /docs/another로 자동 변환\n        permanent: false,\n      },\n      {\n        // basePath가 false로 설정되어 '/docs'가 붙지 않음\n        source: '/without-basePath',\n        destination: 'https://example.com',\n        basePath: false,\n        permanent: false,\n      },\n    ];\n  },\n}\n```\n\n- `basePath: '/docs'`를 설정하면 내 모든 경로에 `/docs`가 기본적으로 붙어요.\n- 리다이렉트할 때도 그게 기본 적용되죠! 그래서 `/with-basePath`는 `/docs/with-basePath`로 해석돼요.\n- 만약 특정 리다이렉트에서 `basePath: false`를 붙이면 `/docs`가 붙지 않고 원래 경로 그대로 사용해요.\n- 외부 URL로 갈 때는 보통 이렇게 `basePath: false`를 많이 쓴답니다.\n\n---\n\n### 2. i18n 지원과 함께하는 리다이렉트\n\n다국어 사이트를 만들 때 유용한 i18n 옵션이 있죠. 리다이렉트 설정도 이 부분과 맞추어 써야 해서 조금 헷갈릴 수 있는데, 여기서 핵심만 짚어드릴게요.\n\n```js\nmodule.exports = {\n  i18n: {\n    locales: ['en', 'fr', 'de'],\n    defaultLocale: 'en',\n  },\n\n  async redirects() {\n    return [\n      {\n        source: '/with-locale',  // 모든 locale 자동 대응: /en/with-locale, /fr/with-locale 등\n        destination: '/another', // 이동할 때도 locale 자동 전달\n        permanent: false,\n      },\n      {\n        // locale 자동 처리 비활성화 (false)\n        source: '/nl/with-locale-manual',\n        destination: '/nl/another',\n        locale: false,\n        permanent: false,\n      },\n      {\n        // 기본 locale(en) 경로를 직접 지정 (locale: false)\n        source: '/en',\n        destination: '/en/another',\n        locale: false,\n        permanent: false,\n      },\n      {\n        // locale 변수를 직접 쓰면서 모든 로케일에 대응하기 (locale: false)\n        source: '/:locale/page',\n        destination: '/en/newpage',\n        permanent: false,\n        locale: false,\n      },\n      {\n        // /(en|fr|de)/(.*)로 변환됨. 루트 경로나 /fr 같은 최상위 경로에는 매칭 안됨\n        source: '/(.*)',\n        destination: '/another',\n        permanent: false,\n      },\n    ];\n  },\n}\n```\n\n- `locales` 배열에 우리가 지원하는 언어들이 있어요 (`en`, `fr`, `de`).\n- 기본 언어는 `en`으로 설정되어 있어요.\n- 보통 리다이렉트에서 `locale: false`를 안 달면, 설정된 모든 언어 경로에 알아서 적용되죠.\n- 하지만 `locale: false`를 작성하면, 자동으로 언어 접두사를 붙이지 않아요. 이때는 `source`와 `destination` 경로에 직접 언어 접두사를 넣어줘야 해요.\n- 예를 들어 `/en`으로 시작하는 경로나 `/nl` 같은 직접 작성한 경로에만 맞게 리다이렉트할 수 있다는 뜻입니다.\n\n---\n\n### 덧붙여서\n\n- `basePath`와 `i18n`를 같이 사용하면 경로가 꽤 복잡해질 수 있어요. 항상 경로가 어떻게 변환될지 테스트해보는 걸 추천합니다.\n- 특히 다국어 서버사이드 렌더링(SSR)을 할 때 경로가 제대로 처리되는지 확인하는 게 중요하답니다.\n\n---\n\n### 요약\n\n| 설정 키           | 역할                                                      | 특징                                   |\n|------------------|---------------------------------------------------------|--------------------------------------|\n| `basePath`       | 모든 URL 앞에 붙는 기본 경로                                | 기본에는 모든 라우트에 적용, false 가능   |\n| `basePath: false`| 해당 리다이렉트에만 basePath 적용 안 함                      | 외부 URL 리다이렉트에 주로 사용          |\n| `i18n.locales`   | 지원하는 언어 리스트                                       | `['en', 'fr', 'de']` 같은 배열           |\n| `i18n.defaultLocale`| 기본 언어                                                | 기본 경로에 적용되는 언어 지정           |\n| `locale: false`  | 리다이렉트에 자동 언어 접두사 붙이는 걸 끔                     | 경로 직접 작성해야 함                    |\n\n---\n\nNext.js 리다이렉트를 설정하면서 `basePath`와 `i18n`를 함께 쓰는 상황, 이제 좀 더 이해되셨죠? 꼭 직접 적용해보고 다양한 상황에서 어떻게 변하는지 실험해보세요! 혹시 더 궁금한 점 있으면 언제든 물어봐 주세요~\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n가끔씩 아주 드물게, 오래된 HTTP 클라이언트에서 제대로 리다이렉트를 처리하려면 커스텀 상태 코드를 지정해야 할 때가 있어요. 이럴 때는 `permanent` 속성 대신 `statusCode` 속성을 사용할 수 있는데, 두 개를 동시에 사용하면 안 돼요. 참고로, IE11 같은 구형 브라우저 호환성을 위해 308 상태 코드를 사용할 때는 자동으로 `Refresh` 헤더가 추가된답니다.\n\n## 리다이렉트 활용 팁\n\n- API 라우트나 라우트 핸들러 안에서는 들어오는 요청에 따라 리다이렉트를 자유롭게 할 수 있어요.\n- `getStaticProps`나 `getServerSideProps` 내부에서도 요청 시점에 특정 페이지로 리다이렉트하는 게 가능하답니다.\n\n## 버전 히스토리\n\n| 항목 | 내용 |\n| --- | --- |\n| 커스텀 상태 코드 | 오래된 HTTP 클라이언트 호환을 위해 statusCode 속성 사용 가능 (permanent와는 상호 배타적) |\n| IE11 대응 | 308 상태 코드 사용 시 자동으로 Refresh 헤더 추가 |\n| 리다이렉트 위치 | API 라우트, 라우트 핸들러, getStaticProps, getServerSideProps에서 가능 |\n\n참고로, 최신 브라우저들은 대부분 3xx 상태 코드를 잘 처리하지만, 레거시 호환을 신경 써야 할 때 이렇게 상태 코드랑 헤더를 적절히 써주면 좋아요! 혹시 더 궁금한 리다이렉트 관련 팁이 있으면 언제든 질문 주세요 :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 버전별로 추가된 기능들을 정리한 표입니다. \n\n| Version   | Changes          |\n|-----------|------------------|\n| `v13.3.0` | `missing` added. |\n| `v10.2.0` | `has` added.     |\n| `v9.5.0`  | `redirects` added.|\n\n이 표를 보시면 각 버전에 어떤 기능들이 새롭게 추가되었는지 한눈에 파악할 수 있죠. 특히 버전 업데이트 때마다 기능이 어떻게 점점 추가되고 개선되는지 살펴보면 프로젝트 관리나 코드 유지보수에 큰 도움이 됩니다. 만약 여러분이 특정 기능(`missing`, `has`, `redirects`)을 사용하려면 어느 버전부터 지원하는지 꼭 확인하세요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":21},{"title":"Nextjs 15에서 부분 사전 렌더링 하는 방법(Partial Prerendering)","description":"","date":"2025-04-22 13:18","slug":"2025-04-22-ppr","content":"\n\n# ppr (Partial Prerendering, 부분 사전 렌더링)\n\nPartial Prerendering, 줄여서 PPR은 같은 경로(Route) 안에서 정적 컴포넌트와 동적 컴포넌트를 함께 사용할 수 있게 해주는 기능이에요. 쉽게 말해, 웹 페이지 내에서 변하지 않는 부분은 미리 만들어두고, 변하는 부분은 계속 업데이트할 수 있다는 거죠. 이 덕분에 사용자 경험이 더 좋아지고, 성능도 한층 더 최적화됩니다.\n\n자세한 내용은 [PPR 공식 문서](https://nextjs.org/docs/pages/building-your-application/rendering/static-and-dynamic-rendering)를 참고해보세요!\n\n## Partial Prerendering 사용법\n\n### 점진적 도입 (버전 15 부터)\n\nNext.js 같은 프레임워크에서 PPR을 점진적으로 도입할 수 있는데요, 예를 들어 조금씩 기존 코드에 PPR을 도입하면서 전체 애플리케이션에 적용하는 방식을 말합니다.  \n이렇게 하면 기존 서비스에 큰 무리 없이 성능 개선을 시도할 수 있죠.\n\n---\n\n### 제가 덧붙이고 싶은 팁!\n\n- PPR을 활용할 때는 동적 부분과 정적 부분을 명확히 구분하는 게 중요해요.  \n예를 들어, 사용자 프로필처럼 자주 변경되는 데이터는 동적으로, 홈페이지 배너 같이 변하지 않는 요소는 정적으로 처리하는 식이죠.\n\n- SEO(Search Engine Optimization)에도 도움이 되니, 검색엔진이 페이지 내용을 잘 읽게 하고 싶으면 PPR을 적극 활용해 보세요.\n\n- PPR을 제대로 이해하면, 서버 사이드 렌더링(SSR)과 정적 사이트 생성(SSG)의 장점을 모두 취할 수 있습니다!\n\n다음 번에는 실제 사용하는 예제 코드와 함께 더 쉽게 설명해 드릴게요. 궁금한 점 있으면 언제든지 댓글 남겨주세요~\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js 15에서는 Partial Prerendering(PPR)을 점진적으로 도입할 수 있어요. 이걸 적용하려면 먼저 `next.config.js` 파일에서 `ppr` 옵션을 `'incremental'`로 설정해줘야 합니다. 그리고 각 레이아웃이나 페이지 파일 최상단에 `experimental_ppr` 옵션을 export해서 해당 라우트에서 PPR을 사용하도록 명시해줘야 해요.\n\n예를 들어, `next.config.js`는 이렇게 설정할 수 있죠:\n\n```js\nimport type { NextConfig } from 'next'\n\nconst nextConfig: NextConfig = {\n  experimental: {\n    ppr: 'incremental',\n  },\n}\n\nexport default nextConfig\n```\n\n그리고 페이지 파일에서는 이렇게요:\n\n```js\nimport { Suspense } from \"react\"\nimport { StaticComponent, DynamicComponent, Fallback } from \"@/app/ui\"\n\nexport const experimental_ppr = true\n\nexport default function Page() {\n  return (\n     \u003c\u003e\n      \u003cStaticComponent /\u003e\n      \u003cSuspense fallback={\u003cFallback /\u003e}\u003e\n        \u003cDynamicComponent /\u003e\n      \u003c/Suspense\u003e\n     \u003c/\u003e\n  );\n}\n```\n\n### 여기서 잠깐! 알아두면 좋은 점들\n\n| 내용 | 설명 |\n|------|--------|\n| 기본값 | `experimental_ppr` 옵션을 설정하지 않은 라우트는 기본값이 `false`로 PPR이 적용되지 않아요. 따라서 각 라우트마다 명시적으로 활성화해줘야 합니다. |\n| 적용 범위 | `experimental_ppr`을 활성화하면 해당 라우트 세그먼트의 모든 하위 레이아웃과 페이지에도 적용돼요. 그래서 꼭 모든 파일에 넣지 않고 최상위 라우트 파일에만 넣으면 됩니다. |\n| 비활성화 | 하위 세그먼트에서 PPR을 끄고 싶다면 그 세그먼트 파일에서 `experimental_ppr = false`를 설정하면 됩니다. |\n\n---\n\n### Partial Prerendering(PPR)이 왜 좋냐면?\n\n기존에는 전체 페이지를 SSR(서버사이드 렌더링)하거나 SSG(정적 생성)으로 렌더링해야 했는데, Next.js 15부터는 정적 컴포넌트와 동적 컴포넌트를 섞어서 레이아웃이나 페이지 단위로 점진적 프리렌더링을 할 수 있어서 성능과 사용자 경험을 모두 챙길 수 있어요.\n\n이에 따라, 특정 컴포넌트는 빌드시 미리 렌더링하고, 나머지는 클라이언트 사이드에서 비동기로 렌더링할 수 있습니다. 덕분에 초기 로딩 속도 향상과 동시에 최신 데이터도 빠르게 가져올 수 있는 장점이 있습니다.\n\n\u003e 참고로, React의 `Suspense`와 함께 사용하는 것이 핵심입니다. `Suspense`는 비동기 컴포넌트 로딩이나 데이터 페칭 시 로딩 상태를 우아하게 보여주기 때문에 PPR과 아주 잘 어울려요.\n\n---\n\n여러분도 Next.js 15의 Partial Prerendering 기능을 적극 활용해서, 유연하고 빠른 웹사이트 만들어보세요! 급할 때는 조금 복잡해 보일 수 있는데, 천천히 한 단계씩 익히면 앞으로 개발 흐름이 훨씬 자유로워질 거예요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n| Version   | Changes                             |\n|-----------|-----------------------------------|\n| `v15.0.0` | experimental `incremental` value introduced |\n| `v14.0.0` | experimental `ppr` introduced      |\n\n위 표는 버전별로 새롭게 도입된 실험적 기능들을 간단히 정리한 거예요. 여기서 `incremental`과 `ppr`은 각각 점진적으로 변화하는 기능과 PPR(Pre-Processing Rendering) 같은 실험적 기능을 의미하는데, 보통 이런 기능들은 안정화 전이라 실제 프로젝트에 도입할 때는 주의가 필요해요. 그래도 최신 기능들을 미리 체험해보고 싶거나, 성능 최적화에 관심 있는 개발자분들께는 놓치기 아까운 내용이죠!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":4},{"title":"Next.js 15에서 Production Browser Source Maps 설정하는 방법","description":"","date":"2025-04-22 13:18","slug":"2025-04-22-productionBrowserSourceMaps","content":"\n\n# productionBrowserSourceMaps\n\n개발할 때는 **Source Maps**가 기본적으로 켜져 있어서, 디버깅하기가 편해요. 근데 문제는, 이렇게 소스맵이 켜진 상태로 프로덕션(실제 서비스) 빌드를 하면, 사용자가 내 소스 코드를 어느 정도 볼 수 있게 된다는 거예요. 그래서 Next.js는 프로덕션 빌드 시에는 소스맵을 끄는 게 기본 설정이에요.\n\n그런데 만약 여러분이 일부러 프로덕션 환경에서도 소스맵을 사용하고 싶다면, 설정에서 `productionBrowserSourceMaps` 플래그를 `true`로 바꾸면 돼요:\n\n```js\nmodule.exports = {\n  productionBrowserSourceMaps: true,\n}\n```\n\n### 왜 프로덕션에서 소스맵을 켜는 걸 선택할까?\n\n- 디버깅이 훨씬 쉬워짐: 프로덕션 환경에서 발생하는 오류도 원래 소스 코드 위치로 쉽게 매핑돼서 문제를 빠르게 찾을 수 있어요.\n- 에러 추적 툴과 같이 사용: Sentry 같은 에러 추적 서비스에 소스맵을 업로드하면, 실제 코드 라인 단위까지 에러를 파악할 수 있어서 유지보수가 좋아지죠.\n\n### 주의할 점!\n\n- **코드 노출 위험**: 소스맵은 결국 여러분의 원본 코드를 어느 정도 노출시키니까, 보안이 매우 중요한 프로젝트라면 신중하게 결정해야 해요.\n- 빌드 시간 증가: 소스맵 생성으로 인해 빌드 시간이 약간 더 걸릴 수 있어요.\n\n그래서 정리하자면, 개발 중에는 당연히 소스맵 켜고 디버깅하는 게 편리하고, 프로덕션에서는 기본적으로 끄지만 상황에 따라 켜서 쓰면 된다는 이야기입니다. 필요에 맞게 설정을 조절해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 productionBrowserSourceMaps 옵션을 활성화하면, 소스 맵(source maps)이 JavaScript 파일과 같은 디렉터리에 생성돼요. 그리고 Next.js가 요청이 들어오면 이 파일들을 자동으로 서빙해주죠.\n\n하지만 여기서 알아둘 점이 몇 가지 있어요:\n\n| 장점 / 단점          | 설명                                         |\n|------------------|--------------------------------------------|\n| 장점                | 디버깅할 때 원본 소스 코드를 쉽게 확인할 수 있어요.      |\n| 단점 1             | 빌드 속도가 느려질 수 있어요.                         |\n| 단점 2             | 빌드 시 메모리 사용량이 증가해요.                       |\n\n그래서 프로덕션 환경에서 디버깅을 자주 해야 하거나 버그 추적이 필요한 특별한 상황이 아니라면, 이 옵션을 활성화하는 걸 신중하게 결정하는 게 좋아요. 소스 맵을 포함하면 빌드 시간이 길어지고 서버 자원도 더 쓰이기 때문에, 적절한 타이밍에 켜는 걸 추천합니다.\n\n추가로, 만약 빌드 사이즈 최소화에 집중하고 싶다면, 소스 맵 없이 문제를 해결하는 방법도 고민해보세요! 예를 들어, 개발 환경에서만 소스 맵을 켜고 프로덕션 빌드에선 끄는 식으로 설정할 수 있거든요.","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":2},{"title":"Nextjs 15 에서 reactCompiler 사용하는 방법","description":"","date":"2025-04-22 13:18","slug":"2025-04-22-reactCompiler","content":"\n\n# reactCompiler\n\nNext.js 15에서는 React Compiler를 공식 지원하기 시작했어요. 이 컴파일러는 성능을 쑥 올려주는 마법 같은 역할을 하는데요, 컴포넌트 렌더링을 자동으로 최적화해줘서 개발자가 직접 useMemo나 useCallback 같은 API를 통해 메모이제이션을 신경 쓸 필요가 훨씬 줄어들게 되었답니다.\n\n사용 방법도 간단해요! Next.js 15 버전으로 업그레이드한 뒤, `babel-plugin-react-compiler`를 설치하면 끝!  \n설치 명령어는 다음과 같아요:\n\n```bash\nnpm install babel-plugin-react-compiler\n```\n\n\u003e 참고로, 이 컴파일러는 특히 복잡한 상태 로직을 가진 대규모 애플리케이션에서 효과가 크게 나타나요. 기존에 매번 리렌더링 때문에 고민했던 부분들이 자연스럽게 해소될 수 있으니 꼭 활용해보세요.\n\n또 한 가지, babel 플러그인을 설정하는 부분은 `babel.config.js`나 `.babelrc` 파일에 다음과 같이 추가해주시면 돼요:\n\n```js\nmodule.exports = {\n  plugins: [\"babel-plugin-react-compiler\"],\n};\n```\n\n이렇게만 해주면 Next.js 15와 함께 더욱 빠르고 깔끔한 React 앱을 만들 준비가 끝난 거예요! 앞으로는 불필요한 렌더링 걱정 없이 개발에 집중할 수 있겠네요 :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그럼 next.config.js 파일에 experimental.reactCompiler 옵션을 추가해볼게요:\n\n```js\nimport type { NextConfig } from 'next'\n\nconst nextConfig: NextConfig = {\n  experimental: {\n    reactCompiler: true,\n  },\n}\n\nexport default nextConfig\n```\n\n\u003e 참고: React Compiler는 현재 Next.js에서 Babel 플러그인을 통해서만 사용할 수 있어요. 이 옵션을 켜면 Next.js 기본 Rust 기반 컴파일러를 사용하지 않게 되어서, 빌드 시간이 조금 더 길어질 수 있어요. 하지만 Next.js 팀에서 앞으로 React Compiler를 기본 컴파일러로 지원할 계획이라고 하니 기대해도 좋습니다!\n\n## 주석(Annotations)\n\n'Annotations'는 코드나 설정 등에 부가적인 설명이나 메타데이터를 달아주는 역할을 해요. 예를 들면, 함수나 컴포넌트 위에 달리는 주석들이나 TypeScript의 데코레이터(@) 같은 것도 일종의 애노테이션이죠. Next.js에서는 여러 실험적 옵션들에 대해 주석이나 문서화 작업을 통해 개발자를 돕고 있답니다.\n\n추가로, React Compiler를 통해 얻을 수 있는 장점은 다음과 같아요:\n\n- 더 빠른 렌더링 속도\n- 중간 빌드 산출물 감소\n- 향상된 개발자 경험(에러 메시지 개선 등)\n\n하지만 아직은 실험 단계라서 호환성 문제나 빌드 속도 저하가 생길 수 있으니, 프로덕션 환경에서는 신중하게 테스트해보는 걸 추천해요.\n\n필요하면 이 옵션을 켜고 끄면서 빌드 성능과 동작 안정성을 직접 체험해보는 것도 좋은 공부가 될 거예요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번에는 Next.js에서 컴파일러를 'opt-in' 모드로 설정하는 방법을 공유할게요. 이 설정을 통해 필요한 컴포넌트나 훅에만 React의 메모이제이션(캐싱)을 적용할 수 있는데요, 크게 두 단계가 있어요.\n\n### 1. Next.js 설정 변경하기\n\n먼저 `next.config.js` 혹은 `next.config.ts` 파일에서 컴파일러의 `compilationMode`를 `'annotation'`으로 설정해줘야 해요. 이렇게 하면 코드 내 특정 위치에만 메모이제이션을 활성화할 수 있게 돼요.\n\n```js\nimport type { NextConfig } from 'next'\n\nconst nextConfig: NextConfig = {\n  experimental: {\n    reactCompiler: {\n      compilationMode: 'annotation',\n    },\n  },\n}\n\nexport default nextConfig\n```\n\n`experimental` 아래에 있는 설정이라 아직 완전히 안정화된 기능은 아닐 수 있으니, 프로젝트 상황에 맞게 테스트해보는 걸 추천합니다.\n\n### 2. 특정 컴포넌트에 메모이제이션 적용하기\n\n설정이 끝나면, 메모이제이션을 적용하고 싶은 컴포넌트나 훅에 `'use memo'`라는 디렉티브를 추가하세요. 아래처럼 컴포넌트 함수 최상단에 문자열로 선언하면 됩니다.\n\n```js\nexport default function Page() {\n  'use memo'\n  // 이 컴포넌트는 React 메모이제이션의 혜택을 받게 돼요.\n}\n```\n\n이걸 붙이는 순간, React 컴파일러가 이 컴포넌트를 최적화 대상으로 인식해 불필요한 리렌더링을 줄일 수 있어요.\n\n---\n\n### 추가 팁!\n- `compilationMode`에 `'annotation'` 외에도 `'global'` 모드가 있는데, 이건 모든 컴포넌트에 자동으로 최적화를 적용하는 방식이에요. 하지만, 상황에 따라 부작용이 있을 수 있으니 꼭 필요한 부분에만 최적화를 적용하려면 `'annotation'` 모드를 추천합니다.\n- React의 이와 같은 실험적인 최적화 기능은 프로젝트 규모가 크거나 복잡한 상태일 때 성능에 도움이 될 수 있어요. 하지만 작거나 단순한 프로젝트에서는 오히려 디버깅이 복잡해질 수 있으니 신중히 적용하세요.\n\n이상으로 Next.js에서 React 컴파일러를 opt-in 모드로 활용하는 방법이었습니다. 필요할 때만 선택적으로 메모이제이션을 켜서 성능과 관리의 균형을 잘 맞춰보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n참고로, React에서는 \"use no memo\"라는 지시어도 사용할 수 있는데요, 이건 반대로 컴포넌트나 훅을 메모이제이션에서 제외하고 싶을 때 쓰는 방법이에요. 즉, 특정 컴포넌트나 훅이 리렌더링 될 때마다 항상 새롭게 실행되도록 하고 싶다면 이 지시어를 적용할 수 있죠.\n\n메모이제이션(memoization)이란, 컴포넌트가 같은 props나 상태를 가진다면 이전에 계산한 결과를 재사용해서 불필요한 렌더링을 줄이는 최적화 기법이에요. 그런데 때로는 업데이트가 항상 필요하거나 캐싱을 원하지 않는 상황도 있거든요. 그럴 때 \"use no memo\"를 사용하는 게 도움이 됩니다.\n\n참고로 \"use no memo\"는 공식 React API에 포함된 기능은 아니고, 보통 개발자들이 직접 구현하거나 특정 라이브러리에서 제공하는 기능인데요. 이름만큼이나 'no memo' 효과를 내어 성능을 제어하는 데 사용됩니다. 따라서 사용 시 문서나 라이브러리 가이드를 꼭 확인하는 게 좋아요.","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":5},{"title":"Next.js 15 pageExtensions로 마크다운 페이지 만들기","description":"","date":"2025-04-22 13:17","slug":"2025-04-22-pageExtensions","content":"\n\n# pageExtensions 설정으로 확장자 추가하기\n\n안녕하세요! 오늘은 Next.js에서 기본으로 인정하는 페이지 확장자 설정을 바꾸는 방법을 살짝 알려드릴게요. 기본적으로 Next.js는 `.tsx`, `.ts`, `.jsx`, `.js` 파일만 페이지로 인식하는데요, 가끔은 마크다운 파일(`.md`, `.mdx`)도 페이지로 쓰고 싶을 때가 있죠? 그런 경우엔 `pageExtensions` 옵션을 활용하면 됩니다.\n\n예를 들어, 마크다운(MD, MDX) 파일을 페이지로 추가하고 싶을 땐, 이렇게 해보세요:\n\n```js\nconst withMDX = require('@next/mdx')()\n\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  pageExtensions: ['js', 'jsx', 'ts', 'tsx', 'md', 'mdx'],\n}\n\nmodule.exports = withMDX(nextConfig)\n```\n\n여기서 `pageExtensions` 배열에 원하는 확장자를 추가해줌으로써, Next.js가 해당 확장자의 파일들도 자동으로 페이지로 인식해요. 그리고 `@next/mdx` 같은 플러그인을 통해 MDX 파일을 컴포넌트처럼 다룰 수 있게 도와주죠.\n\n---\n\n\u003e **Tip!**  \n\u003e 만약 여러분이 `.md`, `.mdx` 외에 또 다른 확장자를 쓰고 싶다면, 이 배열에 추가만 하면 됩니다. 예를 들어 `.vue` 나 `.svelte` 같은 확장자를 넣으면 되는데, 그걸 다루는 로더나 플러그인이 추가로 필요하다는 점 꼭 기억하세요!\n\nNext.js는 생각보다 커스터마이징이 자유로워서, 여러분 프로젝트에 필요한 파일 확장자는 얼마든지 추가해서 쓰셔도 좋아요. 이렇게 하면 페이지 관리를 더 유연하게 할 수 있답니다. 😉\n\n그럼 오늘 내용도 도움이 되셨으면 좋겠습니다! 다음에도 유용한 팁으로 찾아올게요~","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":1}],"page":"3","totalPageCount":50,"totalPageGroupCount":3,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"3"},"buildId":"X4OrKfmLtU3-3BijwfHe6","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>