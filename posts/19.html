<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>TIL</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//posts/19" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="TIL" data-gatsby-head="true"/><meta property="og:title" content="TIL" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//posts/19" data-gatsby-head="true"/><meta name="twitter:title" content="TIL" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/7978fe7362f7d4c9.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/7978fe7362f7d4c9.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/873-eb138c3217d71553.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/posts/%5Bpage%5D-de1dc5579188f9be.js" defer=""></script><script src="/TIL/_next/static/o6AmBAY_j9v9JmbaRA39X/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/o6AmBAY_j9v9JmbaRA39X/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="파이썬으로 AI를 사용해 과학 지식 자동으로 가져오는 방법" href="/TIL/post/2024-07-12-AutomatingScientificKnowledgeRetrievalwithAIinPython"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="파이썬으로 AI를 사용해 과학 지식 자동으로 가져오는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-12-AutomatingScientificKnowledgeRetrievalwithAIinPython_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="파이썬으로 AI를 사용해 과학 지식 자동으로 가져오는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">파이썬으로 AI를 사용해 과학 지식 자동으로 가져오는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 12, 2024</span><span class="PostList_reading_time__6CBMQ">24<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="코딩 없이 바로 사용할 수 있는 실용적인 파이썬 팁 5가지" href="/TIL/post/2024-07-12-5PracticalPythonTipsNoCodingRequiredReadytoUse"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="코딩 없이 바로 사용할 수 있는 실용적인 파이썬 팁 5가지" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-12-5PracticalPythonTipsNoCodingRequiredReadytoUse_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="코딩 없이 바로 사용할 수 있는 실용적인 파이썬 팁 5가지" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">코딩 없이 바로 사용할 수 있는 실용적인 파이썬 팁 5가지</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 12, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="형태학적 이미지 처리 실용 가이드" href="/TIL/post/2024-07-12-Apracticalguidetomorphologicalimageprocessing"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="형태학적 이미지 처리 실용 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="형태학적 이미지 처리 실용 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">형태학적 이미지 처리 실용 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 12, 2024</span><span class="PostList_reading_time__6CBMQ">15<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="게으른 개발자를 위한 필수 효율적인 파이썬 데코레이터 5가지" href="/TIL/post/2024-07-12-EssentialforLazyDevelopersFiveEfficientPythonDecorators"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="게으른 개발자를 위한 필수 효율적인 파이썬 데코레이터 5가지" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-12-EssentialforLazyDevelopersFiveEfficientPythonDecorators_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="게으른 개발자를 위한 필수 효율적인 파이썬 데코레이터 5가지" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">게으른 개발자를 위한 필수 효율적인 파이썬 데코레이터 5가지</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 12, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="위성으로 보이지 않는 용암 흐름과 활활 타오르는 산불을 어떻게 포착할 수 있을까 Python 사용법" href="/TIL/post/2024-07-12-SatellitesCanSeeInvisibleLavaFlowsandActiveWildfiresButHowPython"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="위성으로 보이지 않는 용암 흐름과 활활 타오르는 산불을 어떻게 포착할 수 있을까 Python 사용법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-12-SatellitesCanSeeInvisibleLavaFlowsandActiveWildfiresButHowPython_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="위성으로 보이지 않는 용암 흐름과 활활 타오르는 산불을 어떻게 포착할 수 있을까 Python 사용법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">위성으로 보이지 않는 용암 흐름과 활활 타오르는 산불을 어떻게 포착할 수 있을까 Python 사용법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 12, 2024</span><span class="PostList_reading_time__6CBMQ">23<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Polars V10 출시 소식 놓치지 마세요" href="/TIL/post/2024-07-12-PolarsV10released"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Polars V10 출시 소식 놓치지 마세요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/no-image.jpg"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Polars V10 출시 소식 놓치지 마세요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Polars V10 출시 소식 놓치지 마세요</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 12, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="키워드 검색이 모든 것을 해결해줄까" href="/TIL/post/2024-07-12-Maybekeywordsearchisallyouneed"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="키워드 검색이 모든 것을 해결해줄까" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-12-Maybekeywordsearchisallyouneed_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="키워드 검색이 모든 것을 해결해줄까" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">키워드 검색이 모든 것을 해결해줄까</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 12, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="파이썬 속도를 떨어뜨리는 다섯 가지 코딩 실수 및 오늘 해결하는 방법" href="/TIL/post/2024-07-12-5PythonCodingErrorsThatAreKillingYourSpeedAndHowtoFixThemToday"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="파이썬 속도를 떨어뜨리는 다섯 가지 코딩 실수 및 오늘 해결하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-12-5PythonCodingErrorsThatAreKillingYourSpeedAndHowtoFixThemToday_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="파이썬 속도를 떨어뜨리는 다섯 가지 코딩 실수 및 오늘 해결하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">파이썬 속도를 떨어뜨리는 다섯 가지 코딩 실수 및 오늘 해결하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 12, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="FinalMLP 추천 시스템을 위한 간단하지만 강력한 Two-Stream MLP 모델 사용 방법" href="/TIL/post/2024-07-12-FinalMLPASimpleyetPowerfulTwo-StreamMLPModelforRecommendationSystems"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="FinalMLP 추천 시스템을 위한 간단하지만 강력한 Two-Stream MLP 모델 사용 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-12-FinalMLPASimpleyetPowerfulTwo-StreamMLPModelforRecommendationSystems_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="FinalMLP 추천 시스템을 위한 간단하지만 강력한 Two-Stream MLP 모델 사용 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">FinalMLP 추천 시스템을 위한 간단하지만 강력한 Two-Stream MLP 모델 사용 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 12, 2024</span><span class="PostList_reading_time__6CBMQ">22<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="범주형 및 수치형 데이터를 위한 Gower 거리 설명" href="/TIL/post/2024-07-12-GowersDistanceforMixedCategoricalandNumericalData"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="범주형 및 수치형 데이터를 위한 Gower 거리 설명" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-12-GowersDistanceforMixedCategoricalandNumericalData_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="범주형 및 수치형 데이터를 위한 Gower 거리 설명" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">범주형 및 수치형 데이터를 위한 Gower 거리 설명</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 12, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/TIL/posts/1">1</a><a class="link" href="/TIL/posts/2">2</a><a class="link" href="/TIL/posts/3">3</a><a class="link" href="/TIL/posts/4">4</a><a class="link" href="/TIL/posts/5">5</a><a class="link" href="/TIL/posts/6">6</a><a class="link" href="/TIL/posts/7">7</a><a class="link" href="/TIL/posts/8">8</a><a class="link" href="/TIL/posts/9">9</a><a class="link" href="/TIL/posts/10">10</a><a class="link" href="/TIL/posts/11">11</a><a class="link" href="/TIL/posts/12">12</a><a class="link" href="/TIL/posts/13">13</a><a class="link" href="/TIL/posts/14">14</a><a class="link" href="/TIL/posts/15">15</a><a class="link" href="/TIL/posts/16">16</a><a class="link" href="/TIL/posts/17">17</a><a class="link" href="/TIL/posts/18">18</a><a class="link posts_-active__YVJEi" href="/TIL/posts/19">19</a><a class="link" href="/TIL/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"파이썬으로 AI를 사용해 과학 지식 자동으로 가져오는 방법","description":"","date":"2024-07-12 20:53","slug":"2024-07-12-AutomatingScientificKnowledgeRetrievalwithAIinPython","content":"\n\n\n![Automating Scientific Knowledge Retrieval with AI in Python](/TIL/assets/img/2024-07-12-AutomatingScientificKnowledgeRetrievalwithAIinPython_0.png)\n\n과학 논문, 데이터 집합 및 학술 논문의 거대한 양은 오늘날 연구원, 학자 및 전문가들에게 그들의 분야에서 최신 개발 동향을 따라가기 위한 어려움을 제기합니다.\n\n이러한 도전은 과학적 지식 검색 프로세스를 효율적이고 효과적으로 만드는 혁신적인 접근 방식의 필요성을 강조합니다.\n\nAI 및 의미 검색은 정보 접근 및 상호 작용 방식을 변혁하는 데 놀라운 가능성을 보여 주었습니다. 이러한 혁신의 선두에서는 OpenAI 함수의 응용이 있으며, 자연어 입력을 구조화된 출력이나 함수 호출로 변환합니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예를 들어, 최신 재생 에너지 기술에 대한 질문을 처리해야 할 때 OpenAI의 모델은 최근 논문을 살펴보고 주요 논문과 결과물을 식별하여 연구 트렌드를 요약할 수 있습니다. 특정 키워드에 국한되지 않고 작동할 수 있어요.\n\n이 능력은 연구 과정을 가속화할 뿐만 아니라, 전통적인 검색 방법으로는 즉시 발견하기 어렵거나 연결점과 통찰을 발견하는 데 도움이 됩니다.\n\n이 기사의 목적은 OpenAI 기능과 arXiv API를 활용하여 학술 연구 결과물의 검색, 요약 및 제시를 간소화하는 데 사용할 수 있는 Python 코드를 제공하는 것입니다.\n\n이 안내서의 구성은 다음과 같습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 1. 솔루션 아키텍처\n\n연구 챗봇을 위한 솔루션 아키텍처는 사용자에게 과학적 지식을 처리하고 전달하기 위한 다층 접근 방식을 구체화합니다.\n\n워크플로우는 복잡한 사용자 쿼리를 처리하고 외부 API와 상호작용하여 정보를 제공하는 데 설계되었습니다.\n\n이 아키텍처는 초기 사용자 입력부터 최종 응답 전달까지의 정보 흐름을 용이하게 하는 다양한 구성 요소를 통합합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*fjRg85xwRpokyLaOjM3USg.gif)\n\n1. 사용자 인터페이스 (UI): 사용자는 이 인터페이스를 통해 쿼리를 제출합니다. 이 경우 주피터 노트북에서 제출됩니다.\n\n2. 대화 관리: 이 모듈은 대화를 처리하여 사용자 상호작용 중에 문맥이 유지되도록 합니다.\n\n3. 쿼리 처리: 사용자의 쿼리는 이곳에서 해석되며, 의도를 이해하고 후속 조치를 위해 준비됩니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n4. OpenAI API 통합 (임베딩 및 완성):\n\n- 완성 부분은 일부 쿼리에 대해 즉시 응답을 생성하는 쿼리를 직접 처리합니다.\n- 임베딩 요청은 학술 논문 검색이 필요한 쿼리에 사용되며 관련 문서를 찾기 위한 벡터를 생성합니다.\n\n5. 외부 API (arXiv): 이 부분은 챗봇이 쿼리를 기반으로 arXiv와 같은 외부 데이터베이스와 상호작용하여 과학 논문을 가져오는 곳입니다.\n\n6. 기사 가져오기 \u0026 요약: 이 기능은 기사를 검색한 후 쿼리의 맥락에 따라 요약할 기사를 우선순위로 설정하기 위해 임베딩을 사용합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n7. PDF 처리, 텍스트 추출 및 청킹: 자세한 정보가 필요한 경우, 시스템은 PDF를 처리하고 텍스트를 추출하여 작은 조각으로 나누어 요약 작업을 준비합니다.\n\n8. 응답 생성:\n   - OpenAI API Completion 서비스에서 응답을 통합합니다.\n   - arXiv API에서 검색하고 처리된 논문 요약을 포함하며, 이는 이전에 생성된 임베딩을 기반으로 합니다.\n\n9. 사용자에게 제공: AI가 생성한 답변과 논문 요약을 결합한 응집된 응답이 사용자에게 제공되는 마지막 단계입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 2. Python 시작하기\n\n## 2.1 필수 라이브러리 설치\n\n우리는 다양한 Python 라이브러리를 활용하며, 각각이 특정 기능을 제공하여 과학적 지식의 검색 및 처리를 용이하게 합니다. 각 라이브러리와 역할에 대한 개요는 다음과 같습니다:\n\n- scipy: 과학 계산에 필수적이며, 최적화, 선형 대수, 적분 등을 위한 모듈을 제공합니다.\n- tenacity: 실패한 작업을 다시 시도하는 기능을 제공하며, 외부 API 또는 데이터베이스에 안정적으로 요청을 보내는 데 유용합니다.\n- token: OpenAI 모델과 함께 사용하기 위해 설계된 빠른 BPE 토크나이저로, GPT-4와 같은 AI 모델을 처리하기 위한 텍스트의 효율적인 토큰화를 용이하게 합니다.\n- termcolor: 컬러링된 터미널 출력을 가능하게 하여, 로그 메시지나 디버깅을 편하게 구분할 수 있습니다.\n- openai: GPT-3와 같은 OpenAI API와 상호 작용하기 위한 공식 라이브러리로, AI 모델 응답을 쿼리하고 수신하는 데 중요합니다.\n- requests: 웹 서비스 또는 API에 HTTP 요청을 보내기 위한 라이브러리로, 데이터 검색이나 과학 자원과의 상호 작용에 활용될 수 있습니다.\n- arxiv: arXiv.org의 과학 논문을 검색, 가져오기 및 관리를 간소화합니다.\n- pandas: 대용량 데이터 처리 및 분석에 중요한 역할을 하며, 대규모 데이터 세트를 처리하는 데 사용되는 구조 및 기능을 제공합니다.\n- PyPDF2: PDF 파일로부터 텍스트를 추출할 수 있도록 하며, PDF 형식의 과학 논문을 처리하는 데 필수적입니다.\n- tqdm: 루프나 장기 실행 프로세스에 대한 진행 표시 막대를 생성하여 사용자 경험을 향상시킵니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 2.2 환경 설정하기\n\n먼저 OpenAI 플랫폼에 계정을 만들고 계정 설정의 API 섹션에서 API 키를 얻어야 합니다.\n\n```js\nopenai.api_key = \"API_KEY\"\n\nGPT_MODEL = \"gpt-3.5-turbo-0613\"\nEMBEDDING_MODEL = \"text-embedding-ada-002\"\n```\n\n## 2.3 프로젝트 설정\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다운로드한 논문이나 데이터를 관리하기 위한 구조화된 디렉토리를 만드는 것은 조직화와 쉬운 접근성을 위해 매우 중요합니다. 필요한 디렉토리를 설정하는 방법을 알려드리겠습니다:\n\n- 디렉토리 구조 생성: 프로젝트의 필요에 맞는 구조를 결정하세요. 다운로드한 논문을 관리하기 위해 ./data/papers 디렉토리가 제안됩니다.\n- 구현: Python의 os 라이브러리를 사용하여 이러한 디렉토리의 존재 여부를 확인하고 없는 경우 생성하세요:\n\n```python\nimport os\n\ndirectory = './data/papers'\nif not os.path.exists(directory):\n    os.makedirs(directory)\n```\n\n이 코드 조각을 통해 스크립트가 수동 디렉토리 설정 없이 모든 시스템에서 실행될 수 있도록 보장하여 프로젝트의 이식성과 사용자 친화성을 높일 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 3. 핵심 기능\n\n과학 지식 검색을 용이하게 하는 것을 목적으로 설계된 연구 챗봇은 여러 가지 핵심 기능을 통합하고 있습니다.\n\n자연어 쿼리 처리, 학술 콘텐츠 검색 및 요약, 그리고 고급 NLP 기법을 활용하여 사용자 상호작용을 향상하는 것이 중심입니다.\n\n아래에서는 이러한 기능들을 자세히 설명하며, 그 구현을 보여주는 구체적인 코드 조각을 강조하겠습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 3.1 임베딩 생성\n\n사용자 쿼리를 효과적으로 이해하고 처리하기 위해 챗봇은 임베딩을 활용합니다. 임베딩은 텍스트의 의미를 포착하는 수치적인 표현으로, 이는 과학 논문과 쿼리 간의 관련성을 결정하는 작업에 중요합니다.\n\n```js\n@retry(wait=wait_random_exponential(min=1, max=40), stop=stop_after_attempt(3))\ndef embedding_request(text):\n    response = openai.Embedding.create(input=text, model=EMBEDDING_MODEL)\n    return response['data']['embeddings']\n```\n\n이 함수는 재시도 메커니즘으로 OpenAI API에서 임베딩을 요청하며, 잠재적인 API 오류나 요청 한도에 대응하여 견고성을 보장합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 3.2 학술 논문 검색\n\n쿼리를 이해한 후, 챗봇은 arXiv와 같은 외부 데이터베이스와 직접 통신하는 능력을 보여주며 관련 학술 논문을 가져옵니다.\n\n```js\n# arXiv에서 기사 가져오는 함수\ndef get_articles(query, library=paper_dir_filepath, top_k=5):\n    \"\"\"\n    사용자 쿼리와 관련 있는 상위 'k'개의 학술 논문을 arXiv 데이터베이스에서 검색하고 가져옵니다.\n    이 함수는 arXiv API를 사용하여 논문을 검색하는데, 검색 기준은 사용자 쿼리이고 결과 수는 'top_k'로 제한됩니다.\n    찾은 각 논문에는 제목, 요약, URL과 같은 관련 정보를 리스트에 저장합니다.\n    또한 각 논문의 PDF를 다운로드하고, 제목, 다운로드 경로, 논문 제목의 임베딩을 포함한 참조를 'library'로 지정된 CSV 파일에 저장합니다.\n    나중에 검색 및 분석을 위해 논문과 임베딩을 기록하는 데 유용합니다.\n    이 함수는 read_article_and_summarize에서 사용됩니다.\n    \"\"\"\n    search = arxiv.Search(\n        query=query, max_results=top_k, sort_by=arxiv.SortCriterion.Relevance\n    )\n    result_list = []\n    for result in search.results():\n        result_dict = {}\n        result_dict.update({\"title\": result.title})\n        result_dict.update({\"summary\": result.summary})\n\n        # 첫 번째로 제공된 URL 사용\n        result_dict.update({\"article_url\": [x.href for x in result.links][0]})\n        result_dict.update({\"pdf_url\": [x.href for x in result.links][1]})\n        result_list.append(result_dict)\n\n        # 참조를 라이브러리 파일에 저장\n        response = embedding_request(text=result.title)\n        file_reference = [\n            result.title,\n            result.download_pdf(data_dir),\n            response[\"data\"][0][\"embedding\"],\n        ]\n\n        # 파일에 기록\n        with open(library, \"a\") as f_object:\n            writer_object = writer(f_object)\n            writer_object.writerow(file_reference)\n            f_object.close()\n    return result_list\n```\n\n## 3.3 순위 매기기 및 요약하기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n해당 논문을 손에 쥐고 있으면 시스템은 쿼리와 관련성에 따라 그들을 순위를 매기고 내용을 요약하여 사용자에게 간결하고 통찰력 있는 정보를 제공합니다.\n\n```python\n# 쿼리 문자열과 관련성을 기준으로 문자열을 순위 매기는 함수\ndef strings_ranked_by_relatedness(\n    query: str,\n    df: pd.DataFrame,\n    relatedness_fn=lambda x, y: 1 - spatial.distance.cosine(x, y),\n    top_n: int = 100,\n) -\u003e list[str]:\n\n    \"\"\"\n    함수는 주어진 쿼리 문자열과 관련성을 기준으로 DataFrame에서 문자열 목록을 순위 매기고 반환합니다.\n    함수는 먼저 쿼리 문자열에 대한 임베딩을 얻습니다. 그런 다음 DataFrame의 각 문자열과의 관련성을 계산합니다.\n    여기서 제공된 'relatedness_fn'을 사용하여 쿼리와의 관련성을 계산하며, 기본값은 임베딩 간의 코사인 유사도를 계산합니다.\n    이러한 문자열을 관련성에 따라 내림차순으로 정렬하여 상위 'n'개의 문자열을 반환합니다.\n    \"\"\"\n    query_embedding_response = embedding_request(query)\n    query_embedding = query_embedding_response[\"data\"][0][\"embedding\"]\n\n    strings_and_relatednesses = [\n        (row[\"filepath\"], relatedness_fn(query_embedding, row[\"embedding\"]))\n        for i, row in df.iterrows()\n    ]\n    \n    strings_and_relatednesses.sort(key=lambda x: x[1], reverse=True)\n    strings, relatednesses = zip(*strings_and_relatednesses)\n    return strings[:top_n]\n```\n\n## 3.4 학술 논문 요약\n\n관련 논문을 식별한 후, 챗봇은 과학 문서의 본질을 요약하는 과정을 사용합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\n# 청크를 요약하고 종합 요약을 반환하는 함수\ndef summarize_text(query):\n    \"\"\"\n    사용자 쿼리와 관련된 학술 논문을 요약하는 프로세스를 자동화합니다. 다음을 포함합니다:\n    1. 데이터 읽기: 논문 및 임베딩 정보가 포함된 'arxiv_library.csv'를 읽습니다.\n    2. 관련 논문 식별: 쿼리의 임베딩을 CSV 파일의 임베딩과 비교하여 가장 유사한 항목을 찾습니다.\n    3. 텍스트 추출: 식별된 논문의 PDF를 읽어 내용을 문자열로 변환합니다.\n    4. 텍스트 청킹: 효율적인 처리를 위해 추출된 텍스트를 관리 가능한 청크로 나눕니다.\n    5. 청킹 요약: 각 텍스트 청크는 'extract_chunk' 함수를 사용하여 병렬로 요약됩니다.\n    6. 요약 병합: 개별 요약을 최종 종합 요약으로 결합합니다.\n    7. 요약 제공: 사용자 쿼리와 관련된 주요 통찰을 중점으로 한 논문의 간략한 개요를 제공합니다.\n    \"\"\"\n\n    # 입력된 논문을 재귀적으로 요약하는 방법을 지시하는 메시지\n    summary_prompt = \"\"\"학술 논문의 텍스트를 요약하세요. 이유와 함께 중요한 요점을 추출하세요.\\n\\n내용:\"\"\"\n\n    # 라이브러리가 비어 있는 경우(아직 검색된 항목이 없는 경우) 한 번 수행하고 결과를 다운로드합니다.\n    library_df = pd.read_csv(paper_dir_filepath).reset_index()\n    if len(library_df) == 0:\n        print(\"아직 검색된 논문이 없습니다. 처음으로 다운로드합니다.\")\n        get_articles(query)\n        print(\"논문 다운로드 완료, 계속 진행합니다.\")\n        library_df = pd.read_csv(paper_dir_filepath).reset_index()\n    library_df.columns = [\"title\", \"filepath\", \"embedding\"]\n    library_df[\"embedding\"] = library_df[\"embedding\"].apply(ast.literal_eval)\n    strings = strings_ranked_by_relatedness(query, library_df, top_n=1)\n    print(\"논문에서 텍스트 청킹\")\n    pdf_text = read_pdf(strings[0])\n\n    # 토크나이저 초기화\n    tokenizer = tiktoken.get_encoding(\"cl100k_base\")\n    results = \"\"\n\n    # 문서를 1500 토큰 청크로 분할\n    chunks = create_chunks(pdf_text, 1500, tokenizer)\n    text_chunks = [tokenizer.decode(chunk) for chunk in chunks]\n    print(\"각 텍스트 청크를 요약합니다.\")\n\n    # 요약을 병렬 처리합니다.\n    with concurrent.futures.ThreadPoolExecutor(\n        max_workers=len(text_chunks)\n    ) as executor:\n        futures = [\n            executor.submit(extract_chunk, chunk, summary_prompt)\n            for chunk in text_chunks\n        ]\n        with tqdm(total=len(text_chunks)) as pbar:\n            for _ in concurrent.futures.as_completed(futures):\n                pbar.update(1)\n        for future in futures:\n            data = future.result()\n            results += data\n\n    # 최종 요약\n    print(\"전체 요약으로 요약합니다.\")\n    response = openai.ChatCompletion.create(\n        model=GPT_MODEL,\n        messages=[\n            {\n                \"role\": \"user\",\n                \"content\": f\"\"\"학술 논문에서 추출한 주요 요점을 바탕으로 종합된 요약을 작성합니다.\n                        요약은 핵심 주장, 결론 및 증거를 강조하고 사용자 쿼리에 답변해야 합니다.\n                        사용자 쿼리: {query}\n                        요약은 Core Argument, Evidence, 그리고 Conclusions의 제목을 따라 목록으로 구성되어야 합니다.\n                        주요 요점:\\n{results}\\nSummary:\\n\"\"\",\n            }\n        ],\n        temperature=0,\n    )\n    return response\n```\n\n## 3.5 OpenAI 함수의 통합과 사용\n\n연구용 챗봇은 OpenAI 함수를 활용하여 복잡한 쿼리를 처리하고 응답하기 위한 능력을 향상시킵니다.\n\n이러한 함수들은 챗봇과 다양한 외부 데이터 소스 및 도구 간의 원활한 상호작용을 허용하여 사용자에게 자세하고 정확하며 맥락에 맞는 정보를 제공하여 사용자 경험을 크게 향상시킵니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nOpenAI 함수들은 외부 계산 또는 데이터 검색을 모델의 처리 과정에 직접 통합하여 OpenAI 모델의 기능을 확장하는 데 사용됩니다.\n\n### 3.5.1 사용자 정의 OpenAI 함수\n\n- **get_articles 함수**: 사용자의 쿼리와 관련된 학술 논문을 arXiv 데이터베이스에서 검색하여, 챗봇이 외부 소스에서 실시간 데이터에 접근하는 능력을 보여줍니다.\n- **read_article_and_summarize 함수**: 사용자의 쿼리와 관련된 학술 논문을 arXiv 데이터베이스에서 검색하여, 챗봇이 외부 소스에서 실시간 데이터에 접근하는 능력을 보여줍니다.\n\n구현:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# Function to initiate our get_articles and read_article_and_summarize functions\narxiv_functions = [\n    {\n        \"name\": \"get_articles\",\n        \"description\": \"\"\"Use this function to get academic papers from arXiv to answer user questions.\"\"\",\n        \"parameters\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"query\": {\n                    \"type\": \"string\",\n                    \"description\": f\"\"\"\n                            User query in JSON. Responses should be summarized and should include the article URL reference\n                            \"\"\",\n                }\n            },\n            \"required\": [\"query\"],\n        },\n    },\n    {\n        \"name\": \"read_article_and_summarize\",\n        \"description\": \"\"\"Use this function to read whole papers and provide a summary for users.\n        You should NEVER call this function before get_articles has been called in the conversation.\"\"\",\n        \"parameters\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"query\": {\n                    \"type\": \"string\",\n                    \"description\": f\"\"\"\n                            Description of the article in plain text based on the user's query\n                            \"\"\",\n                }\n            },\n            \"required\": [\"query\"],\n        },\n    }\n]\r\n```\n\n이러한 기능을 챗봇의 작업 흐름에 통합하면 OpenAI의 API의 고급 사용 사례를 보여줍니다. 여기서는 대화 컨텍스트에 따라 특정 작업(예: 학술 조사)에 맞게 맞춤형 함수가 실행됩니다.\n\n## 3.6 완전한 코드\n\n필요한 함수 및 대화형 챗봇 상호작용이 포함된 전체 코드를 참조하세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 프로젝트 유형뿐만 아니라 AI, 데이터 과학 및 기술 분야의 다양한 혁신적인 데이터 기반 이니셔티브에 대해 www.entreprenerdly.com의 다양한 자원을 살펴보기를 권장합니다.\n\n![image](/TIL/assets/img/2024-07-12-AutomatingScientificKnowledgeRetrievalwithAIinPython_1.png)\n\n## 4. 연구 챗봇과 상호작용하기\n\n이 섹션에서는 사용자-시스템 상호작용 흐름을 설명하는 예제들과 함께 연구 챗봇의 구현과 기능에 대해 깊이 파고들어 논의합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 4.1 구현 개요\n\n챗봇은 OpenAI API를 기반으로 구축되었으며, GPT-3 또는 GPT-4와 같은 모델을 활용하여 복잡한 쿼리를 이해하고 사람과 유사한 답변을 생성할 수 있습니다.\n\n구현은 사용자가 쿼리를 입력할 수 있는 인터페이스(명령줄 인터페이스 또는 웹 기반 UI)를 설정하는 것을 포함합니다. 그런 다음 시스템은 이러한 쿼리를 처리하고 OpenAI API와 상호 작용하여 사용자에게 다시 응답을 제시합니다.\n\n## 4.2 기능\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n연구 챗봇의 핵심 기능은 다음과 같습니다:\n\n- 질의 이해: 챗봇은 먼저 사용자의 질문을 해석하여 OpenAI 모델의 이해 능력을 활용하여 질문 뒤에 숨은 맥락과 의도를 파악합니다.\n- 정보 검색: 챗봇은 질의에 따라 교육된 지식베이스를 활용하여 직접 답변을 생성하거나 관련 과학 논문과 문서를 가져와 응답을 작성할 수 있습니다.\n- 응답 생성: 챗봇은 검색하거나 생성한 정보를 일관되고 간결한 답변으로 종합하여 사용자에게 제시합니다.\n\n## 4.3 사용자-시스템 상호작용 흐름\n\n- 사용자 질의 예시: 사용자가 “양자 컴퓨팅의 최신 발전은 무엇인가요?”라고 묻습니다. 질의 처리:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nresponse = openai.Completion.create(\n  engine=\"davinci\",\n  prompt=\"양자 컴퓨팅의 최신 발전 사항은 무엇입니까?\",\n  max_tokens=100\n)\n```\n\n- 답변 생성: 시스템은 답변을 구성하여 양자 컴퓨팅의 최근의 폭발적인 발전을 요약할 수 있습니다.\n- 답변 제시: 챗봇은 사용자의 이해를 돕기 위해 합성된 정보를 출력합니다.\n\n## 4.3.1 관련 논문 검색\n\n이 단계는 사용자가 챗봇에게 특정 주제에 대한 논문을 식별하고 검색하는 것을 포함합니다.  \n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 시스템 메시지로 시작합니다\npaper_system_message = \"\"\"안녕하세요, 저는 arXivGPT입니다. 사용자의 질문에 답변하기 위해 학술 논문을 가져오는 유용한 도우미입니다.\n논문을 명확하게 요약하여 고객이 질문에 대한 답변을 얻기 위해 어떤 논문을 읽어야 하는지 결정할 수 있도록 도와드립니다.\n사용자가 논문의 이름을 이해하고 액세스하려면 항상 article_url과 title을 제공합니다.\n시작하세요!\"\"\"\npaper_conversation = Conversation()\npaper_conversation.add_message(\"system\", paper_system_message)\n\n\n# 사용자 메시지 추가\npaper_conversation.add_message(\"user\", \"시장 효율성에 대한 최신 정보는 무엇인가요?\") # PPO 강화 학습은 어떻게 작동하나요?\nchat_response = chat_completion_with_function_execution(\n    paper_conversation.conversation_history, functions=arxiv_functions\n)\n\nassistant_message = chat_response[\"choices\"][0][\"message\"][\"content\"]\npaper_conversation.add_message(\"assistant\", assistant_message)\ndisplay(Markdown(assistant_message))\n```\n\n## 4.3.2 논문 요약하기\n\n적절한 논문을 가져온 후, 챗봇은 사용자의 요청을 더 처리하여 특정 논문의 내용을 요약하여 제공함으로써 간결하고 통찰에 풍부한 요약을 제공하며 상호작용을 개선합니다.\n\n```js\n# 두 번째 도구를 사용하도록 시스템을 유도하기 위해 다른 사용자 메시지 추가\npaper_conversation.add_message(\n    \"user\",\n    \"시장 효율적 교차 시장 추천을 위한 시장-인식 모델 논문을 읽고 요약을 제공해줄 수 있나요?\",\n)\nupdated_response = chat_completion_with_function_execution(\n    paper_conversation.conversation_history, functions=arxiv_functions\n)\ndisplay(Markdown(updated_response[\"choices\"][0][\"message\"][\"content\"]))\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 5. 도전과 솔루션\n\n## 5.1 다양한 데이터 소스 통합\n\n- 도전: 과학적 지식은 학술 저널부터 프리프린트 서버 및 기관 저장소까지 다양한 플랫폼과 형식으로 분산되어 있습니다.\n- 솔루션: 여러 소스에서 데이터를 가져와 정규화하기 위해 다양한 API 및 웹 스크래핑 기술과 연결할 수 있는 모듈식 데이터 수집 프레임워크를 개발해야 합니다.\n\n## 5.2 사용자-시스템 상호 작용 흐름\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 도전: 특히 다단계 정보 검색 및 처리가 필요한 복잡한 쿼리에 대해 대화 플로우를 자연스럽고 매력적으로 유지하는 것이 도전입니다.\n- 해결책: 사용자 경험을 향상시키기 위해, 챗봇이 사용자와 상호 작용하는 동안 정보 검색을 백그라운드에서 처리하면서 상호 작용적인 세션을 유지할 수 있는 멀티 스레드 요청 처리 시스템을 구현할 수 있습니다.\n\n## 5.3 연속적인 학습과 개선 보장\n\n- 도전: 챗봇이 사용자 상호작용에서 지속적으로 학습하고 개선하여 시간이 지남에 따라 정확도와 효과성을 향상시키는 것입니다.\n- 해결책: 사용자가 챗봇의 응답의 relevance 및 정확도를 평가할 수 있는 피드백 루프 메커니즘을 구현합니다. 이 피드백은 모델을 세밀하게 조정하고 응답 품질을 향상시키는 데 사용됩니다.\n\n## 5.4 실시간 데이터 동기화\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 도전 과제: 챗봇의 데이터베이스를 실시간으로 최신 과학 논문과 동기화하는 것. 새로운 연구가 계속 발표되고 있기 때문에, 챗봇이 가장 최신 정보를 제공하는 것은 상당한 도전입니다.\n- 해결책: 대형 과학 논문 데이터베이스의 웹훅과 RSS 피드를 사용하여 실시간 데이터 동기화 매커니즘을 구현할 수 있습니다. 이를 통해 새로운 논문이 제공되는 즉시 시스템이 자동으로 레포지토리를 업데이트할 수 있습니다.\n\n## 6. 실용적 응용\n\n### 6.1 학술 연구\n\n다양한 학문 분야의 연구자들은 이 시스템을 활용하여 문헌 검토 과정을 간소화하고 효율적으로 관련 연구를 찾을 수 있습니다. 연구 주제와 관련된 구체적인 쿼리를 입력함으로써, 시스템은 과학 논문을 신속히 검색하여 주요 결과, 방법론 및 결과를 식별하고 요약할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 6.2 산업 연구 및 개발\n\n제약, 공학 및 기술 연구개발 부서의 빠른 환경에서는 최신 과학적 발견에 대한 최신 정보를 충분히 파악하는 것이 혁신과 경쟁 우위를 유지하는 데 중요합니다. 시스템은 이러한 산업에 최신 연구, 실험 결과 및 기술 발전을 신속하게 접근할 수 있는 강력한 도구를 제공합니다.\n\n## 6.3 교육\n\n교육자와 학생 모두 시스템을 활용하여 학습 경험을 풍부하게 하고 학업 연구를 지원할 수 있습니다. 교사들은 강의를 준비하기 위한 최신 정보를 찾아 수업 내용을 현재와 관련성 있게 전달할 수 있습니다. 마찬가지로 학생들은 에세이, 프로젝트 또는 논문을 위한 소스, 참고 자료 및 사례 연구를 찾기 위해 시스템을 활용할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 6.4 데이터 과학 및 AI\n\n데이터 과학가와 AI 연구원들에게는 시스템이 데이터 세트를 확보하고 복잡한 알고리즘을 이해하며 기존 연구에 대한 벤치마킹을 제공하는 중요한 자원으로 작용합니다. 사용자들은 시스템에서 특정 프로젝트에 가장 최근이고 관련성 있는 데이터 세트를 쿼리할 수 있으며, 데이터 세트의 크기, 다양성 및 응용에 대한 자세한 정보를 얻을 수 있습니다.\n\n# 결론과 향후 작업\n\n이 연구 및 과학적 지식 검색 시스템의 개발과 구현은 인공지능의 변혁적 잠재력을 강조하며, 과학적 조사의 접근성과 효율성을 향상시키는 데 중요한 역할을 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n미래 작업은 AI 및 기계 학습의 최신 발전을 활용하여 식별된 과제에 대응하며, 시스템이 최첨단 기술 선두에 머무르고 다양한 사용자들의 요구를 계속 충족할 수 있도록 보장하는 데 초점을 맞추게 될 것입니다.\n\n읽어 주셔서 감사합니다. 만약 이 글이 유익했다면 앞으로의 콘텐츠 지원을 위해 박수를 부탁드립니다. 👏\n\nEntreprenerdly.com에는 행동 가능한 지식을 제공하기 위해 설계된 전체 자습서, 코드 및 전략이 제공됩니다.\n\n![2024-07-12-AutomatingScientificKnowledgeRetrievalwithAIinPython_2.png](/TIL/assets/img/2024-07-12-AutomatingScientificKnowledgeRetrievalwithAIinPython_2.png)","ogImage":{"url":"/TIL/assets/img/2024-07-12-AutomatingScientificKnowledgeRetrievalwithAIinPython_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-AutomatingScientificKnowledgeRetrievalwithAIinPython_0.png","tag":["Tech"],"readingTime":24},{"title":"코딩 없이 바로 사용할 수 있는 실용적인 파이썬 팁 5가지","description":"","date":"2024-07-12 20:52","slug":"2024-07-12-5PracticalPythonTipsNoCodingRequiredReadytoUse","content":"\n\n## 파이썬 기술\n\n요즘에는 Python이 복잡한 기능을 달성하기 위해 더 적은 코드를 작성할 수 있도록 해서 인기를 얻었습니다. Python 개발자 커뮤니티는 복잡한 구현을 캡슐화하면서도 사용자 친화적인 도구를 환영합니다.\n\n그러나 Python의 단순함은 여기서 끝나지 않습니다. 아무 코드도 작성하지 않고 Python을 사용할 수 있다고 믿을 수 있나요? 다음 기사에서는 코드를 작성하지 않고 Python의 내장 기능을 사용하는 다섯 가지 예제를 소개하겠습니다.\n\n# Python CLI \"-m\" 매개변수\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파이썬 CLI (명령줄 인터페이스)로 시작해봅시다. 나중에 언급할 기능들을 사용하기 위해 코드를 작성할 필요는 없지만, 파이썬이 우리가 무엇을 하고 싶은지 알 수 있도록 파이썬 명령줄을 사용해야 합니다.\n\n컴퓨터에 파이썬이 설치되어 있다면, 파이썬 명령줄에 `python --help`를 입력하여 지원되는 모든 매개변수를 표시할 수 있습니다.\n\n![이미지](/TIL/assets/img/2024-07-12-5PracticalPythonTipsNoCodingRequiredReadytoUse_0.png)\n\n출력이 길기 때문에 위 이미지는 일부만 보여줍니다. 여기서 강조하고 싶은 것은 `-m mod` 매개변수인데, 이는 파이썬 모듈을 스크립트로 실행합니다. 모듈이 명령줄 작업을 지원한다면, 해당 모듈을 명령줄에서 바로 사용할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 서버 포트 테스트\n\n가끔은 IP 포트의 아웃바운드 네트워크 트래픽을 테스트하고 싶을 때가 있습니다. 보통 telnet 명령어를 사용하는 것이 좋습니다. Windows에서는 telnet이 기본적으로 설치되어 있지 않아 수동으로 설치해야 합니다. 간단한 테스트를 위해서 telnet을 설치하는 것은 자원의 낭비일 수도 있습니다.\n\n하지만 Python이 설치되어 있다면 별도로 telnet을 설치할 필요가 없습니다. Python에 내장된 모듈이 있기 때문입니다. Google 검색 사이트의 443 포트를 테스트할 수 있습니다.\n\n```js\npython -m telnetlib -d 142.250.70.174 443\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 로컬 웹 서버 시작하기\n\n많은 Python 사용자들은 처음에 이 소식을 듣고 놀랍습니다. 네, Python을 사용하여 어떤 코드도 작성하지 않고도 웹 서버를 시작할 수 있습니다. 명령줄에서 다음 명령을 실행하기만 하면 됩니다.\n\n```js\npython -m http.server\n```\n\n실행한 후에는 서비스가 로컬 8000 포트에서 수신 대기합니다. 그런 다음 브라우저에서 http://localhost:8000/을 통해 접속할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![2024-07-12-5PracticalPythonTipsNoCodingRequiredReadytoUse_1](/TIL/assets/img/2024-07-12-5PracticalPythonTipsNoCodingRequiredReadytoUse_1.png)\n\n이 웹 서버는 로컬 파일 시스템을 명령 시작 경로의 루트 디렉토리로 표시합니다. 다시 말해서 우리는 그의 상위 디렉토리에 액세스할 수 없습니다.\n\n이 기능의 사용처는 무엇인가요? 예를 들어, 컴퓨터의 디렉토리에서 많은 텍스트/PDF/이미지 파일/하위 디렉토리를 친구들과 공유하려고 한다면, 이 방법을 사용하면 쉽습니다.\n\n![2024-07-12-5PracticalPythonTipsNoCodingRequiredReadytoUse_2](/TIL/assets/img/2024-07-12-5PracticalPythonTipsNoCodingRequiredReadytoUse_2.png)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# JSON 문자열 확인 및 서식 지정\n\nJSON 문자열이 매우 길고 서식이 지정되지 않았다면, 읽기가 어려울 수 있습니다. 보통 저는 Sublime이나 VS Code와 같은 JSON 플러그인이 있는 텍스트 편집기를 사용하여 JSON 문자열을 서식 지정합니다. 하지만 이러한 도구를 사용할 수 없는 경우, Python이 일시적인 해결책이 될 수 있습니다. 아래는 짧은 JSON 문자열을 사용한 예제입니다.\n\n```js\necho '{\"name\": {\"first_name\":\"Chris\", \"last_name\":\"Tao\"} \"age\":33}'\n```\n\n위 명령줄 도구로는 원래의 형식으로 표시되지만, Python의 `json.tool` 도구를 사용하면 JSON 문자열이 잘 서식이 지정됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n죄송합니다! JSON 문자열이 잘못되었네요. `json.tool`을 사용하면 문제를 파악할 수 있어요. \"name\" 객체 뒤에 쉼표를 빠뜨렸네요. 쉼표를 추가하면 JSON이 올바르게 됩니다.\n\n이제 JSON 문자열은 완벽히 들여쓰기된 형식으로 출력되어 가독성이 좋아졌어요.\n\n# 텍스트 에디터 만들기\n\n맞아요, Python을 사용하여 텍스트 에디터를 \"만들\" 수 있어요. 물론 기능이 제한적이지만, 더 나은 옵션이 없을 때 유용해요. Vim이나 Nano와 기능 면에서 비교할 수 없지만, 명령줄 텍스트 에디터가 아닌 UI 에디터에요. 이 에디터는 Tkinter를 기반으로 한 `idlelib` 모듈에 의해 만들어졌기 때문에 크로스 플랫폼이에요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n간단한 Python 프로그램을 작성하여 현재 시간을 표시하려고 합니다. 큰 코드 편집기를 다운로드하고 설치하지 않고 빠르게 코드를 작성하려면 다음 명령을 실행해 봅시다.\n\n```js\nmkdir get_time_app\npython -m idlelib get_time_app/print_time.py\n```\n\n파일 디렉토리가 존재하지 않으면 `idlelib`가 생성할 수 없으므로 필요한 경우 직접 만들어야 합니다. 명령을 실행한 후 `print_time.py` 파일은 저장되어 로컬에만 생성됩니다. 이제 편집기가 나타나며 구문 강조 기능이 있는 코드를 작성할 수 있습니다.\n\n![Image](/TIL/assets/img/2024-07-12-5PracticalPythonTipsNoCodingRequiredReadytoUse_3.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n`ctrl+s`를 사용하여 코드를 저장하고 편집기를 닫으세요. 명령줄에서 편집된 코드 파일을 확인하고 문제가 없어야 합니다.\n\n```js\ncat get_time_app/print_time.py\n```\n\n# 실행 가능한 애플리케이션 만들기\n\n현재 시간을 가져오는 간단한 애플리케이션을 만들고 싶다면, PyInstaller와 같은 서드파티 도구가 필요하지 않습니다. Python의 내장 Zipapp을 사용할 수 있습니다. \"현재 시간 가져오기\" 애플리케이션으로 패키지하려면, 명령줄에서 다음 명령을 실행하세요.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\npython -m zipapp get_time_app -m \"print_time:main\"\n\n\n우리는 `zipapp` 이름을 `get_time_app`으로 설정하고, 파이썬 프로그램의 진입 파일과 진입 함수를 지정하기만 하면 됩니다. `.pyz` 확장자를 가진 파일이 우리가 만든 애플리케이션입니다. 이 프로젝트를 폴더가 아닌 단일 파일로 배포할 수 있습니다.\n\n![image](/TIL/assets/img/2024-07-12-5PracticalPythonTipsNoCodingRequiredReadytoUse_4.png)\n\n프로그램을 실행하는 것은 간단합니다. Python을 사용하여 직접 호출하면 됩니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\npython get_time_app.pyz\r\n```\r\n\r\n안녕하세요! 제가 \"Medium에서 빠르게 팔로워를 얻는 방법\"에 관한 이북을 쓰고 있습니다. 저는 최고의 증거이기 때문에 말이죠. 딱 한 달 만에 5,000명 이상의 팔로워를 얻었습니다. 계속해서 소식을 지켜봐 주세요!\r\n\r\n저는 Substack에서 \"GPT 소개\" 시리즈를 쓰고 있어요. 관심이 있으시면 팔로우 해주세요!\r\n\r\n총 10편의 글 중 8번째 글이 이미 완료되었습니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 글을 읽어 주셔서 감사합니다!📖 형광펜으로 강조해 주시고🖍️ 박수를 보내 주시고👏 댓글을 남겨 주시고💬 공유해 주셔서 감사합니다🗣️. \"미디엄의 친구\"로서 매일 열심히 노력하고 있습니다.\n\n또한, 뉴스레터를 구독하여 제가 위와 같은 멋진 콘텐츠를 게시할 때마다 알림을 받을 수 있습니다📰. 고맙습니다, 친애하는 챔프!🤓\n\n최신 Python 이야기를 따르려면 Substack에서 저희와 연락하십시오. 함께 Python의 미래를 함께 만들어 봅시다!\n\n# 즐기세요","ogImage":{"url":"/TIL/assets/img/2024-07-12-5PracticalPythonTipsNoCodingRequiredReadytoUse_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-5PracticalPythonTipsNoCodingRequiredReadytoUse_0.png","tag":["Tech"],"readingTime":8},{"title":"형태학적 이미지 처리 실용 가이드","description":"","date":"2024-07-12 20:50","slug":"2024-07-12-Apracticalguidetomorphologicalimageprocessing","content":"\n\n## | 인공지능 | 컴퓨터 비전 | 전처리 |\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_0.png\" /\u003e\n\nPython에서 모폴로지 연산을 어떻게 구현하는지 및 왜 디지털 이미지 처리에서 중요한지에 대해 설명하는 가이드입니다.\n\n이전 시리즈의 기사는 다음과 같습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 형태학 소개\n\n![이미지](/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_1.png)\n\n형태학(가끔 수학적 형태학으로도 불립니다)은 이웃 처리의 한 분야로 여겨질 수 있습니다. 1964년 Georges Matheron과 Jean Serra에 의해 개발되었으며, 광물 단면의 특성을 정량화하기 위해 고안되었지만 다른 다양한 응용 분야에서도 가치가 있다는 것이 입증되었습니다. 일반적으로 형태학은 이미지에 일관된 노출이 없는 경우에 발생하는 노이즈를 제거하는 데 사용할 수 있습니다. 실제로 형태학은 역처리로 얻은 바이너리 이미지와 매우 잘 작동하지만(하지만 그레이스케일 이미지에서도 사용할 수 있습니다).\n\n예를 들어, 임계 처리 후 몇 가지 상황이 발생할 수 있고, 이를 형태학으로 해결할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![A practical guide to morphological image processing](/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_2.png)\n\n여기서 나는 히트 또는 핏 연산, 팽창, 침식을 적용했는데, 이에 대해 자세히 알아볼 것이다.\n\n형태학은 다양한 흥미로운 응용 프로그램을 갖고 있습니다. 예를 들어 광학 문자 인식(OCR)의 전처리 단계로 사용되며, 바코드 및 자동차 번호판은 감지하는 데 사용됩니다. 형태학 연산은 간단하고 계산 비용이 적고 결합하여 효율적으로 사용할 수 있어 시간과 계산 자원을 절약할 수 있습니다. 실제로 여러 가지 작업을 수행하기 위해 복잡한 알고리즘이 필요하지 않을 때가 많으며, 적은 고급 기술도 우아하고 효율적인 솔루션으로 이어질 수 있습니다. 또한, 이러한 연산은 다양한 컴퓨터 비전 알고리즘에서 매우 유용하며 실제로 학습할 가치가 있습니다.\n\n# 형태학\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_3.png)\n\n임계처리는 전역 작업으로 (이미지의 모든 픽셀에 대해) 지역 위치를 고려하지 않고 수행되며, 결과적으로 과소 세분화 또는 과대 세분화된 영역을 유발할 수 있습니다.\n\n대신, 형태학은 이웃 처리와 비슷하게 적용됩니다. 이 경우에는 값이 아닌 모양이 중요합니다 (상자 모양 커널은 날카로운 모서리를 보존하고 둥근/디스크 모양 커널은 모서리를 둥글게 만듭니다).\n\n![image](/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_4.png)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 커널은 이미지에있는 객체 (또는 요소)에만 적용됩니다. 따라서 커널이 클수록 이미지에 미치는 영향도 커집니다. 이러한 절차는 일반적으로 1이 전경을 나타내고 0이 배경을 나타내는 바이너리 이미지에서 수행됩니다.\n\n## 맞추기와 맞추기\n\n이 알고리즘에서는 위에서 본 것과 같은 모양의 커널을 특정 위치에 놓은 다음 커널에 의해 커버되는 픽셀의 값을 고려합니다. 아이디어는 커널을 고려할 때, 특정 위치에있는 픽셀이 커널에도 1이면 1로 설정하려는 것입니다 (이를 '맞춤'이라고 함). 일치하는 경우 출력 이미지의 픽셀이 1로 설정됩니다. 맞춤 (또는 맞춤)에서 이미지 전체를 스캔하는 것이 아니라 특정 위치와 커널을 선택하고 커널 및 해당 위치의 픽셀의 일치 여부를 확인합니다.\n\n맞춤의 경우에는 커널에있는 것처럼 동일한 위치의 모든 픽셀이 1인지 확인합니다 (참이면 이미지가 맞는 것입니다). 모든 픽셀에 대해 일치하는 경우, 모든 픽셀을 출력 이미지에서 1로 설정하고, 그렇지 않은 경우 모두 0으로 설정합니다. 아래 두 위치에 맞춤 또는 맞춤을 적용합니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![풍부한 이진화와 침식](/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_5.png)\n\n## 팽창과 침식\n\n전체 이미지에 히트를 적용하는 것을 '팽창'이라고 합니다. 왜냐하면 그 이미지의 요소들이 변환 후에 크기가 증가하기 때문입니다. 또한, 작은 구멍이 닫히고 일부 객체가 병합됩니다. 증가량은 커널 요소의 크기에 따라 달라지거나, 대안으로 작은 커널을 반복적으로 적용할 수 있습니다. 문제는 잡음이 있는 객체도 확대될 수 있다는 것입니다. 커널 k를 사용한 방정식은 다음과 같습니다:\n\n![팽창과 침식](/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_6.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n⊕은 벡터 하위 공간의 합을 나타냅니다.\n\n말했듯이, 커널 크기는 영향을 미치며 작은 커널을 반복적으로 적용할 때 영향이 유사합니다 (예: 6x6 커널은 3x3 커널을 2배 적용한 것과 유사한 효과를 줍니다). 이미지에 다른 커널의 효과를 시도해 보겠습니다. 우선 이전 튜토리얼에서 언급했던대로 이미지에 Otsu의 임계값 처리를 적용한 이미지로 시작하겠습니다 (이는 일정 임계값 이상인 픽셀이 255 또는 흰색이 되고 나머지는 0인 바이너리 이미지를 반환합니다).\n\n![image](/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_7.png)\n\n그런 다음 이 바이너리 이미지에 다양한 커널 크기와 팽창을 적용합니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\n# 확장\nfrom scipy import ndimage\nfrom skimage.filters import threshold_otsu\nfrom skimage.morphology import disk\nfrom skimage.morphology import erosion\n\nfig, axes = plt.subplots(ncols=4, nrows=1, sharex=True, sharey=True, figsize=(12, 5))\n\nimage = im\nthresh = threshold_otsu(image)\nbinary = image \u003e thresh\n\ndilated = ndimage.binary_dilation(binary, structure=np.ones((3,3)))\ndilated1 = ndimage.binary_dilation(binary, structure=np.ones((5,5)))\ndilated2 = ndimage.binary_dilation(binary, structure=np.ones((9,9)))\n```\n\n![image](/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_8.png)\n\n물체가 커지고 이미지의 구멍이 메꿔지며 일부 잡음 요소가 확대되는 것을 알 수 있습니다.\n\n침식은 확장과 정반대입니다. 이 경우에는 모든 이미지에 대해 맞추고 있습니다. 효과는 객체 크기의 일반적인 축소와 작은 객체의 제거로 이어집니다. 더불어 종종 더 큰 객체가 더 작은 객체로 분할됩니다. 우리는 잡음을 제거하지만 관심 대상 객체는 파손됩니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기 방정식입니다:\n\n![equation](/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_9.png)\n\n여기에 Python 구현이 있습니다:\n\n```python\n#침식\n\nfig, axes = plt.subplots(ncols=4, nrows=1, sharex=True, sharey=True, figsize=(12, 5))\n\nimage = im\nthresh = threshold_otsu(image)\nbinary = image \u003e thresh\n\neroded = ndimage.binary_erosion(binary, structure=np.ones((3,3)))\neroded1 = ndimage.binary_erosion(binary, structure=np.ones((5,5)))\neroded2 = ndimage.binary_erosion(binary, structure=np.ones((9,9)))\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래의 표를 마크다운 형식으로 바꿔보세요.\n\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_10.png\" /\u003e\n\n주의할 점은 작은 물체가 사라지는 것과, 관심 대상물체에 구멍이 형성되는 것입니다.\n\n침식과 팽창의 조합으로 우리는 개방, 폐쇄, 경계 감지와 같은 복합 연산을 유도합니다.\n\n## 폐쇄와 개방\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n보통 클로징은 구멍을 메우는 연산입니다. 팽창에 이어 침식이 이루어지면 얻을 수 있습니다. 이미지 내부의 구멍은 보통 이 작업 이후에 닫힙니다. 팽창을 사용하여 객체의 크기 (그리고 잡음의 크기)를 키우고 출력 객체는 입력 크기와 같습니다. 따라서 클로징이 이 문제를 해결합니다. 다음 작업을 위한 커널의 크기도 동일합니다. 클로징 연산은 항등성을 갖고 있어 한 번만 사용할 수 있습니다. 그렇지 않으면 이미지 전체를 축소시키는 것만 일어나서 뚜렷한 효과가 없습니다 (경계 문제). 아래 방정식을 볼 수 있습니다:\n\n![](/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_11.png)\n\n여기서 커널의 크기를 다르게 사용하는 경우 무슨 일이 일어나는지 주목해 보세요:\n\n```js\nclosed = ndimage.binary_closing(binary, structure=np.ones((3,3)))\nclosed1 = ndimage.binary_closing(binary, structure=np.ones((5,5)))\nclosed2 = ndimage.binary_closing(binary, structure=np.ones((9,9)))\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![Opening operation](/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_12.png)\n\nOpening is generally used to avoid fractioning bigger objects when removing the noise. In this case, we use first erosion and then dilation. The output image presents an object with the original size but the noise is removed. Another idempotent transformation and the equation is:\n\n![Idempotent transformation](/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_13.png)\n\nLet’s also test the opening operation to see what is happening:\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nopened = ndimage.binary_opening(binary, structure=np.ones((3,3)))\nopened1 = ndimage.binary_opening(binary, structure=np.ones((5,5)))\nopened2 = ndimage.binary_opening(binary, structure=np.ones((9,9)))\n```\n\n![Image](/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_14.png)\n\n두 가지 과정을 결합할 수도 있지만, 커널은 서로 달라야 합니다 (opening에 사용되는 것과 closing에 사용되는 것이 서로 다른 커널이어야 함)\n\n5x5 커널을 사용하여 모든 연산을 함께 확인해보겠습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_15.png)\n\nBoundary detection is an edge detection technique on binary images, where you subtract the eroded image, obtaining the boundary. The idea is that with eroding we are obtaining a smaller version of the object and if we subtract the image only the boundary will remain. In formula:\n\n![formula](/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_16.png)\n\n```js\neroded = ndimage.binary_erosion(binary, structure=np.ones((3,3)))\nboundary =binary ^ eroded\n``` \n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_17.png\" /\u003e\n\n뺄셈이 아니라 두 개의 논리 마스크 (참/거짓)를 사용하기 때문에 논리 연산자 AND를 사용하는 것에 유의하세요. 그렇지 않으면 Numpy가 오류를 반환합니다. (하지만 원리는 같습니다)\n\n## 약간의 실제 예시\n\n마이크로스코프 이미지에서 핵 윤곽선을 선택하여 분석을 수행하려면 몇 가지 조작만으로 가능합니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 핵을 선택하려고 합니다.\n# 따라서, 파란색 부분만 선택합니다.\nim = a[:,:,2]\nimage = im\nthresh = threshold_otsu(image)\nbinary = image \u003e thresh\neroded = ndimage.binary_erosion(binary, structure=np.ones((7,7)))\nopening = ndimage.binary_opening(eroded, structure=np.ones((11,11)))\nboundary = binary ^ opening\n```\n\n![image](/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_18.png)\n\n보너스 예제: 자동차 이미지의 번호판을 읽고 싶다면, 복잡한 딥 러닝 모델 대신 간단한 전처리 단계로 시작할 수 있습니다. 하얀색과 검은색 모자(흰색은 회색 이미지에서 개방 이미지를 뺀 것이고 검은색은 회색 입력 이미지에서 닫힘을 뺀 것)와 같은 몇 가지 간단한 연산을 사용할 수 있습니다. 여기서 우리는 번호판이 가로보다 세로가 길기 때문에 사각형 커널을 사용했습니다. 그리고 임의의 크기의 커널을 사용할 수 있습니다. 몇 가지 간단한 작업만으로도 결과가 꽤 좋아집니다.\n\n```js\nimage = im\nthresh = threshold_otsu(image)\nbinary = image \u003e thresh\nopening = ndimage.binary_opening(binary, structure=np.ones((13,5)))\nclosing = ndimage.binary_closing(binary, structure=np.ones((13,5)))\nblack_hat =  im - closing\nwhite_hat = im - opening\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_19.png\" /\u003e\n\n# 마무리\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_20.png\" /\u003e\n\n우리는 간단한 연산으로 다양한 결과를 얻을 수 있는 형태학적 연산이 얼마나 강력한지 보았습니다. 각 연산에는 그만의 반대가 있다는 것을 주목할 가치가 있으며, 이들을 결합하여 더 정교한 작업을 수행할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n합성에서는 침식 기법을 사용하여 물체를 연결하는 작은 링크를 제거하거나 작은 잡음 물체를 제거하고 바이너리 이미지에서 경계를 감지할 수 있습니다. 반면 팽창은 이미지의 부분을 연결하는 데 유용합니다. 열림은 물체를 파괴하지 않고 작은 물체를 제거할 수 있게 하며, 폐쇄는 물체 크기를 늘리지 않으면서 구멍을 메울 수 있습니다. 그리고 이러한 작업을 필요에 맞게 반복 및 조합할 수도 있습니다. 간단한 작업에 대해 나쁘지 않죠?\n\n이전 글은 여기서 확인할 수 있습니다. 여기에서는 핵심 코드만을 보여줬지만, 사용된 모든 코드는 여기에 있습니다.\n\n## 어떻게 생각하세요? 이러한 작업을 시도해 보셨나요? 댓글로 알려주세요.\n\n# 흥미로우셨다면:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n제 다른 글을 찾아보실 수 있고, LinkedIn에서 연락이나 소통할 수도 있습니다. 매주 업데이트되는 머신 러닝 및 인공 지능 뉴스가 포함된 이 저장소를 확인해보세요. 협업 및 프로젝트에 대해 열려 있으며 LinkedIn에서 저에게 연락할 수 있습니다.\n\n제 GitHub 저장소 링크는 다음과 같습니다. 거기에는 머신 러닝, 인공 지능 등과 관련된 코드와 다양한 자료를 모아두고 있습니다.\n\n또는 최근 글 중 하나에 관심이 있을 수도 있습니다:\n\n## 추가 자료\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 형태학 연산에 대해: 일반적으로 (여기, 여기, 여기) 및 OpenCV로 (여기, 여기, 여기)\n- 화이트와 블랙 햇에 관해: 여기\n\n# 평문으로 이해하기 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 계속 진행하기 전에:\n\n- 작가를 박수 치고 팔로우해 주세요 👏\n- 팔로우: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문: Stackademic | CoFeed | Venture\n- PlainEnglish.io에서 더 많은 콘텐츠 확인하기","ogImage":{"url":"/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-Apracticalguidetomorphologicalimageprocessing_0.png","tag":["Tech"],"readingTime":15},{"title":"게으른 개발자를 위한 필수 효율적인 파이썬 데코레이터 5가지","description":"","date":"2024-07-12 20:47","slug":"2024-07-12-EssentialforLazyDevelopersFiveEfficientPythonDecorators","content":"\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-EssentialforLazyDevelopersFiveEfficientPythonDecorators_0.png\" /\u003e\n\n파이썬은 가독성이 뛰어나고 데이터 분석 및 웹 개발과 같은 여러 분야에서 강력한 응용 프로그램을 제공하여 개인적으로 가장 좋아하는 프로그래밍 언어입니다.\n\n하지만, 충분한 코드를 작성하고 있음에도 불구하고, 제가 절대적으로 필요한 경우가 아닌 한 @staticmethod를 사용하여 클래스 내의 정적 메서드를 꾸미는 데코레이터를 거의 사용하지 않습니다.\n\n그러나 코드 리뷰 중에 코드에 소개된 예외 처리 데코레이터를 발견했는데, 이는 제 생각을 바꾸어 코드를 더 읽기 쉽게 만들었으며 간결한 형태로 강력한 기능을 제공했습니다. 이것이 나의 호기심을 자극하여 데코레이터의 다른 기능을 탐구하게 만들었으므로, 이 글에서는 데코레이터의 개념을 깊이 탐구하고 우리의 파이썬 코드를 개선하는 데 도움이 되는 다섯 가지 실용적인 데코레이터를 소개하겠습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 데코레이터란\n\n![image](/TIL/assets/img/2024-07-12-EssentialforLazyDevelopersFiveEfficientPythonDecorators_1.png)\n\n데코레이터는 파이썬의 강력한 언어 기능으로, 원본 함수 코드를 수정하지 않고도 기능을 동적으로 추가하거나 함수 동작을 수정할 수 있게 해줍니다. 데코레이터는 다른 함수나 클래스를 매개변수로 받아 새로운 함수나 클래스를 반환하는 함수입니다.\n\n데코레이터는 함수를 수정, 확장 또는 래핑하여 코드를 보다 가독성 있고 유지보수하기 쉽게 만드는 간결하고 우아한 방법을 제공합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n데코레이터는 일반적으로 다음과 같은 시나리오에서 사용됩니다:\n\n- 추가 기능 또는 로직 추가, 로깅, 성능 분석, 입력 유효성 검사 등;\n- 함수의 동작 수정, 결과 캐싱, 재시도 메커니즘 추가 또는 입력 매개변수를 가로채서 매개변수를 확인하고 많은 assert 문을 사용하는 대신;\n- 관심을 분리하고 자르로 자르로 사용되는 관심사항을 핵심 비즈니스 로직과 분리합니다.\n\n# 5 매우 간단하지만 유용한 데코레이터\n\n## 01 타이머: 함수 실행 시간 측정\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n코드 성능 최적화는 매우 중요합니다. 이 데코레이터는 특정 함수의 실행 시간을 추적하고 경과 시간을 출력하는 데 도움을 줍니다. 이 데코레이터로 함수를 감싸면 병목 현상을 신속하게 식별하고 코드의 핵심 부분을 최적화할 수 있습니다.\n\n```js\nimport time\n\ndef timer(func):\n    def wrapper(*args, **kwargs):\n        # 타이머 시작\n        start_time = time.time()\n        # 데코레이트된 함수 호출\n        result = func(*args, **kwargs)\n        # 시간 다시 측정\n        end_time = time.time()\n        # 경과 시간 계산 및 출력\n        execution_time = end_time - start_time\n        print(f\"실행 시간: {execution_time} 초\")\n        # 데코레이트된 함수 실행 결과 반환\n        return result\n    # wrapper 함수에 대한 참조 반환\n    return wrapper\n```\n\n파이썬에서 데코레이터를 만들려면 timer라는 함수를 정의해야 합니다. 이 함수는 데코레이터 함수임을 나타내는 func라는 매개변수를 받습니다. timer 함수 내부에서는 원하는 함수를 데코레이트하기 위해 매개변수를 일반적으로 전달하는 wrapper라는 다른 함수를 정의합니다.\n\nwrapper 함수 내에서는 제공된 인수를 사용하여 필요한 함수를 호출합니다. 이렇게 할 수 있습니다: result = func(*args, **kwargs).\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마지막으로, 래퍼 함수는 장식된 함수의 실행 결과를 반환합니다. 데코레이터 함수는 방금 만든 래퍼 함수에 대한 참조를 반환해야 합니다.\n\n데코레이터를 활용하기 위해서는 원하는 함수에 @ 기호를 사용하여 적용하면 됩니다.\n\n```js\n@timer\ndef train_model():\n    print(\"Starting the model training function...\")\n    # 프로그램을 5초간 일시 중지하여 함수 실행을 시뮬레이션합니다\n    print(\"Model training completed!\")\n\ntrain_model()\n```\n\n## 02 debugger: Make Debug Easier\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n유용한 추가 래퍼 함수를 만들어 디버깅을 용이하게 할 수 있습니다. 각 함수의 입력 및 출력을 출력하여 실행 흐름을 확인할 수 있습니다. 이 방법을 통해 복수의 print 문으로 애플리케이션을 혼란스럽게 만들 필요가 없습니다.\n\n```python\ndef debugger(func):\n    def wrapper(*args, **kwargs):\n        # 함수 이름과 인수 출력\n        print(f\"Calling {func.__name__} with args: {args} kwargs: {kwargs}\")\n        # 함수 호출\n        result = func(*args, **kwargs)\n        # 결과 출력\n        print(f\"{func.__name__} returned: {result}\")\n        return result\n    return wrapper\n```\n\n호출된 함수의 이름을 가져오기 위해 __name__ 매개변수를 사용할 수 있으며, args와 kwargs 매개변수를 사용하여 전달된 내용을 출력할 수 있습니다.\n\n```python\n@debugger\ndef add_numbers(x, y):\n    return x + y\nadd_numbers(7, y=5)  \n# 출력: Calling add_numbers with args: (7,) kwargs: {'y': 5}\n# add_numbers returned: 12\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 03 memoize: 반환 결과 캐시\n\n우리는 코드 베이스에서 특정 코드 조각들의 동작을 거의 변경하지 않습니다. 그러나 이러한 코드들의 반복 실행은 상당한 컴퓨팅 자원을 소비할 수 있습니다. 이 경우 memoize 데코레이터를 사용하여 함수 호출을 캐시할 수 있습니다.\n\n이 시점에서 입력이 동일하면 함수는 한 번만 실행됩니다. 각 후속 실행에서는 결과가 캐시에서 가져옵니다. 따라서 비용이 많이 드는 계산을 항상 수행할 필요가 없습니다.\n\n```js\ndef memoize(func):\n    cache = {}\n    def wrapper(*args):\n        if args in cache:\n            return cache[args]\n        else:\n            result = func(*args)\n            cache[args] = result\n            return result\n    return wrapper\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n데코레이터는 함수 매개변수와 반환 값을 저장하는 사전(dictionary)을 사용합니다. 이 함수를 실행할 때, 데코레이터는 이전 결과 사전을 확인합니다. 저장된 값이 없을 때만 실제 함수가 호출됩니다.\n\n아래는 피보나치 수 계산 함수입니다. 이 함수는 재귀적으로 작동하므로 동일한 함수가 여러 번 실행됩니다. 그러나 캐싱을 사용하면 이 과정을 빠르게 만들 수 있습니다.\n\n```js\n@memoize\ndef fibonacci(n):\n    if n \u003c= 1:\n        return n\n    else:\n        return fibonacci(n-1) + fibonacci(n-2)\n```\n\n이 함수의 실행 시간을 캐시를 사용하거나 사용하지 않을 때 각각 측정한 결과입니다. 캐시된 버전은 실행에 몇 밀리초만 소요되지만, 캐시되지 않은 버전은 거의 1분이 소요됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이전 실행 결과를 저장할 때 사전을 사용하는 것은 간단하고 직관적인 방법입니다. 더 강력한 기능을 제공하기 위해 데이터를 캐시하는 인메모리 데이터베이스인 Redis나 Memcache와 같은 것을 사용할 수 있습니다.\n\n## 04 재시도: 실행 재시도\n\n데이터 과학과 소프트웨어 개발에서는 종종 외부 시스템에 의존하지만 모든 외부 시스템이 신뢰성있는 것은 아닙니다.\n\n예기치 않은 이벤트가 발생할 때 코드가 일정 시간을 기다려 외부 시스템이 복구되기를 기다리고 다시 시도할 수 있기를 원할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그런 retry 로직을 Python 데코레이터로 구현하는 것이 좋습니다. 이렇게 하면 재시도 동작을 어떤 함수에든 적용할 수 있어요.\n\n```python\nimport time\n\ndef retry(max_attempts, delay=1):\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            attempts = 0\n            while attempts \u003c max_attempts:\n                try:\n                    return func(*args, **kwargs)\n                except Exception as e:\n                    attempts += 1\n                    print(f\"Attempt {attempts} failed: {e}\")\n                    time.sleep(delay)\n            print(f\"Function failed after {max_attempts} attempts\")\n        return wrapper\n    return decorator\n```\n\n우리는 데코레이터에 대한 다른 래퍼 함수를 정의할 수 있어요. 이전 예제와 유사하게 구현해요. 그러나 이번에는 검증 함수를 입력 변수로 전달하는 대신 max_attempts와 delay와 같은 특정 매개변수를 전달해요.\n\n데코레이터 함수가 호출되면 wrapper 함수가 호출돼요. 이 함수는 시도 횟수(0부터 시작)를 기록하고 while 루프에 진입해요. 루프는 장식된 함수를 실행하려고 시도하고, 성공하면 결과를 즉시 반환해요. 그러나 예외가 발생하면 시도 횟수를 증가시키고, 시도 횟수와 발생한 특정 예외를 나타내는 오류 메시지를 출력해요. 지정된 지연 시간 동안 함수를 다시 시도하기 전에 time.sleep을 사용해요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 함수를 호출하려면 각 함수 호출 사이의 최대 시도 횟수와 시간 간격(초)을 지정할 수 있습니다.\n\n```js\n@retry(max_attempts=3, delay=2)\ndef fetch_data(url):\n    print(\"데이터를 가져오는 중..\")\n    # 서버 응답 없음을 모의하기 위해 시간 초과 오류 발생..\n    raise TimeoutError(\"서버가 응답하지 않습니다.\")\nfetch_data(\"https://example.com/data\")  \n# 시도 간격이 2초인 3번 재시도\n```\n\n## 05 exception_handler: Graceful Exception Handling\n\nexception_handler는 함수에서 발생한 모든 예외를 잡아 적절히 처리할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n요구 사항에 맞게 래퍼 함수에서 예외 처리를 사용자 정의할 수 있습니다. 예를 들어 예외를 로깅하거나 추가 오류 처리 단계를 수행할 수 있습니다.\n\n```js\ndef exception_handler(func):\n    def wrapper(*args, **kwargs):\n        try:\n            return func(*args, **kwargs)\n        except Exception as e:\n            # 예외 처리\n            print(f\"예외가 발생했습니다: {str(e)}\")\n            # 선택적으로 추가 오류 처리 또는 로깅 수행\n            # 필요한 경우 예외를 다시 발생시킵니다.\n    return wrapper\n```\n\n이것은 우리의 코드를 간소화하고 예외 처리 및 오류 로깅을 처리하는 통합된 절차를 수립하는 데 매우 유용합니다.\n\n```js\n@exception_handler\ndef divide(x, y):\n    result = x / y\n    return result\ndivide(10, 0)  \n# 출력: 예외가 발생했습니다: division by zero\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 요약\n\n![이미지](/TIL/assets/img/2024-07-12-EssentialforLazyDevelopersFiveEfficientPythonDecorators_2.png)\n\n데코레이터는 함수에 새로운 동작을 쉽게 적용할 수 있는 매우 편리한 방법입니다. 래퍼(wrapper)를 사용하여 복잡한 작업을 간소화하고 코드 가독성을 높이며 생산성을 향상시킬 수 있습니다.\n\n![이미지](/TIL/assets/img/2024-07-12-EssentialforLazyDevelopersFiveEfficientPythonDecorators_3.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 👋 만약 이 게시물이 도움이 된다면, 작가를 지원하는 의미로 아래 👏 버튼을 클릭해 주세요 \n\n## 🚀 FAUN 개발자 커뮤니티에 가입하고 매주 이메일로 유사한 이야기를 받아보세요","ogImage":{"url":"/TIL/assets/img/2024-07-12-EssentialforLazyDevelopersFiveEfficientPythonDecorators_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-EssentialforLazyDevelopersFiveEfficientPythonDecorators_0.png","tag":["Tech"],"readingTime":11},{"title":"위성으로 보이지 않는 용암 흐름과 활활 타오르는 산불을 어떻게 포착할 수 있을까 Python 사용법","description":"","date":"2024-07-12 20:44","slug":"2024-07-12-SatellitesCanSeeInvisibleLavaFlowsandActiveWildfiresButHowPython","content":"\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-SatellitesCanSeeInvisibleLavaFlowsandActiveWildfiresButHowPython_0.png\" /\u003e\n\n# 목차\n\n- 🌟 소개\n- 🔍 Sentinel-2 (분광대역)\n- 🌐 Sentinel-2 이미지 다운로드\n- ⚙️ Sentinel-2 이미지 처리 (클리핑 및 리샘플링)\n- 🌋 Sentinel-2 이미지 시각화 (화산)\n- 🔥 Sentinel-2 이미지 시각화 (산불)\n- 📄 결론\n- 📚 참고 자료\n\n## 🌟 소개\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n알고 계실지 모르겠지만, 우리 눈은 가시 영역(파란색, 녹색, 빨간색의 밴드)의 물체만 볼 수 있어요. 하지만 빛이 물체에 닿아 반사되면, 적외선과 같은 다른 스펙트럼 영역의 정보도 담고 있어요. 적외선 빛은 짙은 가스, 예를 들어 연기와 같은 것을 통과해 명확한 시야를 제공하죠. 하지만 우리 눈은 일부 동물들(뱀 등)과 달리 적외선 영역에 있는 물체를 보지 못해요. 지난 수십 년 동안 적외선 빛을 탐지하는 센서 개발에 상당한 진전이 있었어요. 이러한 센서들은 실용적인 응용에 활용되고 있어요.\n\n나는 항상 위성이 가시 영역에서는 볼 수 없는 적외선 영역에서 중요한 정보를 감지할 수 있는 좋은 예시를 찾고 있었어요. 지난 주에는 2023년 12월 이후 세 번째로 활동을 시작한 아이슬란드 화산에 대해 읽었어요. 그것은 나에게 위성이 촬영한 화산의 이미지를 확인하고 싶다는 생각을 일으켰어요. 나는 운이 좋아서 화산으로부터 올라오는 연기를 보여주는 선명한 위성 이미지를 발견할 수 있다면 좋겠다고 바랬어요. 그것은 가시 영역에서 빛이 흩어지는 것과 적외선 영역에서 연기를 통과해 용암 흐름을 드러내는 모습을 보여줄 수 있는 완벽한 예시가 될 것 같았죠.\n\n내가 확인한 여러 위성 중 하나가 완벽한 타이밍으로 있었어요! 화산은 2월 8일 목요일 아침에 폭발했고, Sentinel-2가 2월 8일 정오쯤에 지나갔어요. 나는 이것이 위성 이미지가 가시 영역에선 흐리더라도 적외선 영역의 센서로 장착된 위성 이미지가 우리에게 화산을 모니터링하고 화산재를 탐지하는 데 어떻게 도움이 되는지 보여주는 완벽한 예시가 될 수 있다고 생각했어요.\n\n매우 짙은 연기가 있는 상황에서 적외선 밴드의 응용을 탐구하려고, 나는 캘리포니아에서 발생한 2020년 최대 화재 중 하나를 캡처한 또 다른 Sentinel-2 이미지를 시각화하기로 결정했어요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 이야기에서는 아이슬란드 레이키아네스 반도의 화산과 2020년 캘리포니아의 크릭 파이어를 위해 캡처된 두 개의 센티넬-2 이미지를 다운로드할 것입니다. 우리는 파이썬을 사용하여 이 두 이미지를 시각화하기 위해 시각적 및 적외선 지역의 다른 밴드 조합을 사용할 것입니다. 적외선 정보가 활동 중인 용암 흐름 및 화재 지점을 보여줄 수 있음을 알 수 있을 것입니다. 이것이 흥미롭게 들린다면 계속 읽어보세요!\n\n## 🔍 센티넬-2 (분광대 업무)\n\n센티넬-2 미션은 유럽 우주국 (ESA)가 Copernicus 프로그램의 일환으로 개발한 쌍둥이 위성인 센티넬-2A와 센티넬-2B로 구성되어 있습니다. 센티넬-2 위성에는 데이터를 캡처하는 다중 스펙트럼 장비가 있습니다. 각 밴드는 특정 파장 범위를 갖고 있어 다양한 지구 관측 응용프로그램을 지원합니다. 이 게시물에서는 가시 지역의 밴드와 적외선 영역의 세 개의 밴드를 사용할 것입니다. 여기에는 이러한 밴드 목록이 있습니다:\nBand 2 (Blue): 496.6 nm\nBand 3 (Green): 560.0 nm\nBand 4 (Red): 664.5 nm\nBand 8 (NIR - 근적외선): 835.1 nm\nBand 11 (SWIR1- 단파 적외선): 1613.7 nm\nBand 12 (SWIR2- 단파 적외선): 2202.4 nm\n\nBand 2 (Blue), 3 (Green), 4 (Red), 및 8 (NIR)의 공간 해상도는 10 미터이며, Band 11 및 12 (단파 적외선)은 20 미터입니다. 이는 화산 및 산불을 시각화하는 데 충분합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 🌐 센티넬-2 이미지 다운로드\n\n이미 Python 및 R에서 센티넬-2 이미지를 다운로드하는 두 가지 튜토리얼을 작성했어요. 회원가입하는 방법, 자격 증명을 설정하고 이미지를 다운로드하는 방법을 알고 싶다면, 다음 게시물들을 참조하세요. 이번 게시물에서 이미지 다운로드를 위한 코드의 필요한 수정 사항을 설명했습니다:\n\n해당 스크립트를 바탕으로 관심 영역의 좌표, 이미지 날짜, 그리고 화산 및 산불을 위한 파란색, 녹색, 빨간색, 근적외선 및 단파대역을 다운로드해야 합니다.\n\n각 사례에 필요한 정보는 다음과 같아요:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 아이슬란드 화산:\n\n```js\n위성 = \"SENTINEL-2\"\n레벨 = \"S2MSI1C\"\n\n관심지점 = \"POINT(-22.411503 63.892295)\"\n\n시작일 = \"2024-02-07\"\n종료일 = \"2024-02-10\"\n```\n## 크리크 산불:\n\n```js\n위성 = \"SENTINEL-2\"\n레벨 = \"S2MSI1C\"\n\n관심지점 = \"POINT(-119.26 37.1914)\"\n\n시작일 = \"2020-09-07\"\n종료일 = \"2020-09-10\"\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이슬란드 화산:\n\n![이슬란드 화산](/TIL/assets/img/2024-07-12-SatellitesCanSeeInvisibleLavaFlowsandActiveWildfiresButHowPython_1.png)\n\n화산 분화는 현지 시간으로 2월 8일 목요일 오전 5시 30분에 발생했으며, 화면 캡처에 표시된 바와 같이 분화 후 정확히 7시간 후인 2월 8일 13:03 UTC(현지 시간 12시 30분)에 촬영된 이미지가 하나만 가능합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 크릭 파이어:\n\n![크릭 파이어](/TIL/assets/img/2024-07-12-SatellitesCanSeeInvisibleLavaFlowsandActiveWildfiresButHowPython_2.png)\n\n크릭 파이어는 9월 4일에 발생했으며 12월 24일에 소멸되었습니다. 목록의 두 이미지 모두 8일에 촬영되었습니다 (산불 발생 후 4일이 지난 후), 그러나 두 번째 이미지의 컨텐츠 길이는 0입니다. 따라서, 이 게시물에서는 첫 번째 이미지 (S2A_MSIL1C_20200908T183921_N0500_R070_T11SKB_20230309T124945)를 사용하겠습니다.\n\n두 블로그 게시물에서 Sentinel-2 이미지를 다운로드하는 코드를 실행하기 전에 시각 영역 (파랑, 초록, 빨강)에서 세 개의 밴드와 적외선 영역 (근적외선 및 단파적 외선 밴드)에서 세 개의 밴드를 포함해야 합니다. 다음 라인은 이러한 밴드에 해당됩니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nf\"{product_name}/{root[0][0][12][0][0][12].text}.jp2\" # Blue\nf\"{product_name}/{root[0][0][12][0][0][12].text}.jp2\" # Green\nf\"{product_name}/{root[0][0][12][0][0][12].text}.jp2\" # Red\nf\"{product_name}/{root[0][0][12][0][0][12].text}.jp2\" # Near-infrared\nf\"{product_name}/{root[0][0][12][0][0][12].text}.jp2\" # Shortwave infrared-1\nf\"{product_name}/{root[0][0][12][0][0][12].text}.jp2\" # Shortwave infrared-2\n```\n\n위 단계를 올바르게 따라왔다면, 각 예제당 아래 파일들이 디렉토리에 저장되어 있어야 합니다:\n\n## 아이슬란드 화산:\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-SatellitesCanSeeInvisibleLavaFlowsandActiveWildfiresButHowPython_3.png\" /\u003e\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Creek Fire:\n\n![Creek Fire Image](/TIL/assets/img/2024-07-12-SatellitesCanSeeInvisibleLavaFlowsandActiveWildfiresButHowPython_4.png)\n\n⚙️ Processing Sentinel-2 Images (Clipping and Downscaling)\n\nAfter downloading those images, we need to clip each band for the area of interest (AOI) around the volcano and the wildfire. Since we have the coordinates for each incident, we can create a buffer polygon (3 km for the volcano and 10 km for the wildfire) using this function:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport math\n\ndef calculate_new_coordinates(center_lat, center_lon, distance, bearing):\n    # 지구 반지름 (킬로미터)\n    earth_radius = 6371.0\n\n    # 좌표를 라디안으로 변환\n    center_lat_rad = math.radians(center_lat)\n    center_lon_rad = math.radians(center_lon)\n\n    # 새로운 위도 계산\n    new_lat_rad = math.asin(math.sin(center_lat_rad) * math.cos(distance / earth_radius) +\n                            math.cos(center_lat_rad) * math.sin(distance / earth_radius) * math.cos(bearing))\n\n    # 새로운 경도 계산\n    new_lon_rad = center_lon_rad + math.atan2(math.sin(bearing) * math.sin(distance / earth_radius) * math.cos(center_lat_rad),\n                                              math.cos(distance / earth_radius) - math.sin(center_lat_rad) * math.sin(new_lat_rad))\n\n    # 다시 도 단위로 변환\n    new_lat = math.degrees(new_lat_rad)\n    new_lon = math.degrees(new_lon_rad)\n\n    return new_lon, new_lat \n```\n\n## 아이슬란드 화산(AOI)을 위해 위의 함수 사용하기:\n\n```js\n# 중심 좌표\ncenter_lat = 63.892295\ncenter_lon = -22.411503\n\n# 버퍼 거리 (킬로미터)\nbuffer_distance = 3\n\n# 네 모퉁이의 좌표 계산\nnorth_lon, north_lat = calculate_new_coordinates(center_lat, center_lon, buffer_distance, 0)\nsouth_lon, south_lat = calculate_new_coordinates(center_lat, center_lon, buffer_distance, math.pi)\neast_lon, east_lat = calculate_new_coordinates(center_lat, center_lon, buffer_distance, math.pi / 2)\nwest_lon, west_lat = calculate_new_coordinates(center_lat, center_lon, buffer_distance, -math.pi / 2)\n\n# 원하는 형식으로 좌표 출력\nprint(f\"({west_lon:.4f} {north_lat:.4f}, {east_lon:.4f} {north_lat:.4f}, {east_lon:.4f} {south_lat:.4f}, {west_lon:.4f} {south_lat:.4f}, {west_lon:.4f} {north_lat:.4f})\")\n```\n\n```js\n# 출력:\n(-22.4728 63.9193, -22.3502 63.9193, -22.3502 63.8653, -22.4728 63.8653, -22.4728 63.9193)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Creek Fire (AOI)에 대한 위의 함수를 사용하십시오:\n\n```js\n# 중심 좌표\ncenter_lat = 37.19147\ncenter_lon = -119.261175\n\n# 킬로미터 단위의 버퍼 거리\nbuffer_distance = 10\n\n# 네 꼭지점의 좌표 계산\nnorth_lon, north_lat = calculate_new_coordinates(center_lat, center_lon, buffer_distance, 0)\nsouth_lon, south_lat = calculate_new_coordinates(center_lat, center_lon, buffer_distance, math.pi)\neast_lon, east_lat = calculate_new_coordinates(center_lat, center_lon, buffer_distance, math.pi / 2)\nwest_lon, west_lat = calculate_new_coordinates(center_lat, center_lon, buffer_distance, -math.pi / 2)\n\n# 원하는 형식으로 좌표 출력\nprint(f\"({west_lon:.4f} {north_lat:.4f}, {east_lon:.4f} {north_lat:.4f}, {east_lon:.4f} {south_lat:.4f}, {west_lon:.4f} {south_lat:.4f}, {west_lon:.4f} {north_lat:.4f})\")\n```\n\n```js\n# 결과:\n(-119.3741 37.2814, -119.1483 37.2814, -119.1483 37.1015, -119.3741 37.1015, -119.3741 37.2814)\n```\n\n그런 다음 jp2 파일을 클리핑하기 위해 \"aoi_polygon_wkt\"에 이러한 좌표를 사용할 수 있습니다. 이는 본 게시물의 \"AOI에 스택 형식으로 변환하고 클리핑하기\" 섹션에서 설명한 대로입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# Volcano: 다각형 WKT\naoi_polygon_wkt = \"POLYGON ((-22.4728 63.9193, -22.3502 63.9193, -22.3502 63.8653, -22.4728 63.8653, -22.4728 63.9193))\"\n\n# Wildfire: 다각형 WKT\naoi_polygon_wkt = \"POLYGON ((-119.3741 37.2814, -119.1483 37.2814, -119.1483 37.1015, -119.3741 37.1015, -119.3741 37.2814))\"\n```\n\n이 다각형들을 사용하여 JP2 파일을 AOI에 맞게 자를 수 있습니다. 그러나 시각화 부분에서 이 레이어를 쌓기 전에, 다른 밴드들 (파랑, 녹색, 빨강 및 근적외선)의 크기와 호환되도록 단파적적 적외선 밴드를 20m에서 10m로 축소해야 합니다. 이를 수행하는 함수는 다음과 같습니다:\n\n```js\nimport rasterio\nfrom scipy.ndimage import zoom\n\ndef downscale_raster(input_path, output_path, scale_factor):\n    with rasterio.open(input_path) as src:\n        # 데이터 읽기\n        data = src.read(1)\n\n        # 새로운 치수 계산\n        new_height = int(src.height / scale_factor)\n        new_width = int(src.width / scale_factor)\n\n        # 리샘플링을 위해 scipy의 zoom 함수 사용\n        resampled_data = zoom(data, 1/scale_factor, order=3)\n\n        # 새 래스터의 메타데이터 업데이트\n        transform = src.transform * src.transform.scale(\n            (src.width / resampled_data.shape[1]),\n            (src.height / resampled_data.shape[0])\n        )\n\n        new_profile = src.profile\n        new_profile.update({\n            'driver': 'JP2OpenJPEG',\n            'height': new_height,\n            'width': new_width,\n            'transform': transform\n        })\n\n        # 새 파일에 리샘플된 래스터 작성\n        with rasterio.open(output_path, 'w', **new_profile) as dst:\n            dst.write(resampled_data, 1)\n```\n\n그런 다음, 각 사용 사례에 대해 20m에서 10m로 단파 밴드를 축소하는 데 이 함수를 적용할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 아이슬란드 화산에 대한 위 함수 사용:\n\n```js\n# 사용법\ninput_band_path_B11 = \"/content/T27VVL_20240208T130311_B11.jp2\"\noutput_band_path_B11 = \"/content/T27VVL_20240208T130311_B11_resampled.jp2\"\n\ninput_band_path_B12 = \"/content/T27VVL_20240208T130311_B12.jp2\"\noutput_band_path_B12 = \"/content/T27VVL_20240208T130311_B12_resampled.jp2\"\n\nscale_factor = 1/2  # 20m to 10m\n\ndownscale_raster(input_band_path_B11, output_band_path_B11, scale_factor)\ndownscale_raster(input_band_path_B12, output_band_path_B12, scale_factor)\n```\n\n## 크릭 파이어에 대한 위 함수 사용:\n\n```js\n# 사용법\ninput_band_path_B11 = \"/content/T11SKB_20200908T183921_B11.jp2\"\noutput_band_path_B11 = \"/content/T11SKB_20200908T183921_B11_resampled.jp2\"\n\ninput_band_path_B12 = \"/content/T11SKB_20200908T183921_B12.jp2\"\noutput_band_path_B12 = \"/content/T11SKB_20200908T183921_B12_resampled.jp2\"\n\nscale_factor = 1/2  # 20m to 10m\n\ndownscale_raster(input_band_path_B11, output_band_path_B11, scale_factor)\ndownscale_raster(input_band_path_B12, output_band_path_B12, scale_factor)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 단계를 마치면 디렉토리에 두 개의 파일이 더 생겼어요:\n\n## Iceland Volcano:\n\n![Iceland Volcano](/TIL/assets/img/2024-07-12-SatellitesCanSeeInvisibleLavaFlowsandActiveWildfiresButHowPython_5.png)\n\n## Creek Fire:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-SatellitesCanSeeInvisibleLavaFlowsandActiveWildfiresButHowPython_6.png\" /\u003e\n\n같은 차원의 모든 밴드를 가지고 있으므로 이제 이 게시물의 \"스택, Geotiff로 변환한 다음 AOI( TOA)에 자르기\" 섹션을 기반으로 스택 파일을 생성할 수 있습니다.\n\n## 🌋 센티넬-2 이미지 시각화 (화산)\n\n이제 화산 사건을 위한 하나의 스택 파일과 산불 사건을 위한 다른 하나의 스택 파일이 있다면, 각각을 다른 밴드 조합을 사용하여 플로팅할 수 있습니다. 구체적으로, 우리는 세 가지 플롯을 만들 것입니다. 하나는 오직 가시적인 밴드(빨강, 초록, 파랑)을 기반으로 하고, 다른 하나는 가시적 및 근적외선 밴드(초록, 빨강, 그리고 근적외선)의 결합을 기반으로 하며, 세 번째는 적외선 영역에만 초점을 맞춘 것입니다(근적외선 및 단파 밴드) 데이터를 적외선 영역의 데이터를 생략한다면 어떤 정보를 놓칠 수 있는지 이해하기 위함입니다. 아래에 표시된 플롯과 비슷한 플롯을 생성하려면 이 게시물의 \"TOA 및 표면 반사 이미지의 실제 색상 플로팅\" 섹션을 참조하실 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 아이슬란드 화산:\n\n![아이슬란드 화산](/TIL/assets/img/2024-07-12-SatellitesCanSeeInvisibleLavaFlowsandActiveWildfiresButHowPython_7.png)\n\n이 그림은 시각적 영역에서 기록된 것으로, 화산 주변에 용암이 퍼져 있음을 볼 수 있습니다 (검은 픽셀), 화산의 연기 기둥, 그리고 몇 가지 매우 작은 빨간색 영역은 활성 용암을 보여줍니다. 앞에서 언급한 대로, 시각 대역에서 빛은 쉽게 산란되어, 우리는 이 이미지에서 연기 기둥을 흰색 픽셀로 볼 수 있습니다. 시각 대역에서 빛의 산란은 물체를 가리는데, 연기 아래에 있는 활성 용암을 관측하기 어렵게 만듭니다. 스크립트의 밝기를 제어하는 이득 매개변수를 조정해도 (스크립트의 이득 매개변수), 서쪽으로 흐르는 용암 흐름만 볼 수 있습니다:\n\n![활성 용암을 볼 수 있나요?](/TIL/assets/img/2024-07-12-SatellitesCanSeeInvisibleLavaFlowsandActiveWildfiresButHowPython_8.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n가시 스펙트럼에서 조정된 이득 매개 변수로 인해 화산재가 서쪽으로 이동하는 것을 더 명확하게 볼 수 있습니다. 하지만 여전히 연기 구름 아래에서 무슨 일이 일어나고 있는지는 모릅니다. 이번에는 근적외선 정보를 추가하여 이미지를 다시 그려보겠습니다.\n\n![image](/TIL/assets/img/2024-07-12-SatellitesCanSeeInvisibleLavaFlowsandActiveWildfiresButHowPython_9.png)\n\n이것을 통해 해당 시간에 두 개의 활동적인 용암 흐름이 있었음을 알 수 있습니다. 하나는 서쪽으로 향하는 것으로서 가시 스펙트럼에서 어느 정도 감지할 수 있었으며, 다른 하나는 남쪽으로 이동하고 있었는데 이는 근적외선 빛을 통해 확인되었습니다. 남쪽으로 향하는 흐름은 그리인다비크 근처에 있었는데, 해당 지역은 이전 11월의 분출 이후 대피된 지역입니다.\n\n소개에서 언급했지만, 이에 대한 주요 이유는 적외선 빛이 가시 파장 대비 더 긴 파장을 가지고 있다는 것입니다. 이것은 가시 파장과 달리 미립자와 같은 미립현을 통과하여 흩어지지 않고 밀집된 가스와 연기를 통과할 수 있게 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n앞으로 나아가서 이미지를 다시 그려봅시다. 이번에는 단파적 초적외선 및 근적외선 대역만 사용하겠습니다:\n\n![image](/TIL/assets/img/2024-07-12-SatellitesCanSeeInvisibleLavaFlowsandActiveWildfiresButHowPython_10.png)\n\n단파적 초적외선을 추가함으로써 이미지에 또 다른 정보가 더해졌음을 확인할 수 있습니다. 화산재를 나타내는 더 밝은 픽셀에 더해, 첫 번째와 두 번째 이미지의 검은 용암이 이제 두 영역으로 분리되었음을 보실 수 있습니다: 붉은색과 검은색. 붉은 영역은 새롭게 화재가 발생한 지역을 나타내며, 단파적 대역에서 더 많이 반사되는 온한 용암을 포함하고 있을 가능성이 높습니다. 나머지 부분은 활동이 없는 용암을 보여줍니다.\n\n## 🔥 Sentinel-2 이미지 시각화 (산불)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이전 섹션과 유사하게, 화재를 위한 센티넬-2 이미지를 플로팅할 것인데요. 이를 위해 가시 파장대 (적색, 청색, 녹색), 가시 및 근적외선 파장대 (녹색, 적색, 근적외선), 그리고 적외선 파장대(단파 및 근적외선)을 결합하여 사용할 거에요. 우선 가시 영역부터 시작해보죠:\n\n![Sentinel-2 이미지](/TIL/assets/img/2024-07-12-SatellitesCanSeeInvisibleLavaFlowsandActiveWildfiresButHowPython_11.png)\n\n이 사진은 Creek Fire를 위한 가시 파장대를 사용해 촬영한 센티넬-2 이미지입니다. 앞서 언급한 대로 이 지역에서 빛은 쉽게 산란되기 때문에, 보이는 것은 불타는 지역으로부터 대기로 솟아 오르는 매우 밀도 높은 연기 구름뿐입니다. 그러나 화산 예시와 같이, 적외선 영역의 빛은 연기로 투과할 수 있어 가시 영역에서 보이지 않는 것을 드러낼 수 있습니다. 연기 속 상황을 평가하기 위해, 가까운 적외선과 가시 파장대를 사용해 이미지를 플로팅하여 연기 아래에서 무슨 일이 일어나고 있는지 알아봅시다:\n\n![Sentinel-2 이미지](/TIL/assets/img/2024-07-12-SatellitesCanSeeInvisibleLavaFlowsandActiveWildfiresButHowPython_12.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n별 차이가 없네요!!\n\n여기에 설명된 대로, 화산 상황과는 달리 근적외선은 가시적인 대역과 유사하게 산란되어 연기 아래에서 무슨 일이 일어나는지 밝혀내기에 유용하지 않았습니다. Sentinel-2에는 근적외선보다 파장이 긴 두 개의 단파장 적외선 대역이 있기 때문에, 이 이미지를 그 두 개의 단파장 적외선 대역과 근적외선을 사용하여 한 번 더 그려보고 시각화에서 가시 대역을 제거했습니다:\n\n![이미지](/TIL/assets/img/2024-07-12-SatellitesCanSeeInvisibleLavaFlowsandActiveWildfiresButHowPython_13.png)\n\n인상적이지 않나요?\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n단파적 적외선 대역은 짙은 연기를 관통하여 불 타는 지역(반짝이고 황금빛 픽셀)을 굵은 연기층 아래서 보여줄 수 있었습니다. 이러한 지역을 찾는 것은 적외선 대역만으로 또는 가시적 및 근적외선 영역의 조합으로는 볼 수 없었던 것들을 고 관리 및 산불 모니터링에 중요할 수 있습니다.\n\n마지막 단계로, 이들을 함께 모아서 이 템플릿을 사용하여 예시별 이미지를 옆에 놓고 그림을 그리겠습니다:\n\n```js\nimport rasterio\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# 쌓인 이미지 플로팅\nwith rasterio.open(\"stacked_TOA.tif\") as src:\n    # 밴드 인덱스 정의\n    blue_band = 1\n    green_band = 2\n    red_band = 3\n    nir_band = 4\n    swir1_band = 5\n    swir2_band = 6\n\n    # 밴드 읽기\n    red = src.read(red_band)\n    green = src.read(green_band)\n    blue = src.read(blue_band)\n    nir = src.read(nir_band)\n    swir1 = src.read(swir1_band)\n    swir2 = src.read(swir2_band)\n\n    # 게인 적용\n    gain = 2\n    red_n = np.clip(red * gain / 10000, 0, 1)\n    green_n = np.clip(green * gain / 10000, 0, 1)\n    blue_n = np.clip(blue * gain / 10000, 0, 1)\n    nir_n = np.clip(nir * gain / 10000, 0, 1)\n    swir1_n = np.clip(swir1 * gain / 10000, 0, 1)\n    swir2_n = np.clip(swir2 * gain / 10000, 0, 1)\n\n    # 다른 컴포지트 생성\n    rgb_composite = np.dstack((red_n, green_n, blue_n))\n    nir_composite = np.dstack((nir_n, red_n, green_n))\n    swir_composite = np.dstack((swir2_n, swir1_n, nir_n))\n\n    # 컴포지트 플로팅\n    plt.figure(figsize=(24, 8))\n\n    plt.subplot(131)\n    plt.title('Red, Green and Blue', fontsize=18, fontweight='bold')\n    plt.imshow(rgb_composite)\n    plt.axis('off')\n\n    plt.subplot(132)\n    plt.title('Near-infrared, Red, Green', fontsize=18, fontweight='bold')\n    plt.imshow(nir_composite)\n    plt.axis('off')\n\n    plt.subplot(133)\n    plt.title('Infrared Bands: Shortwave and Near-infrared', fontsize=18, fontweight='bold')\n    plt.imshow(swir_composite)\n    plt.axis('off')\n    \n    # 플롯 저장\n    plt.savefig('composite_plot.png')\n\n    plt.show()\r\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-SatellitesCanSeeInvisibleLavaFlowsandActiveWildfiresButHowPython_14.png\" /\u003e\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-SatellitesCanSeeInvisibleLavaFlowsandActiveWildfiresButHowPython_15.png\" /\u003e\n\nSentinel-2 섹션에서 언급했듯이, 이 위성은 13개의 밴드를 가지고 있으며, 이 중 9개는 적외선 영역에 해당됩니다. 우리는 연기 아래 숨겨진 물체들을 드러내기 위해 적외선 영역의 세 밴드만 사용했습니다. 다른 적외선 밴드들인 레드 엣지(Band 5, 6, 7, 그리고 8A)를 사용하여 용암이나 화재가 발생한 지역의 시각화를 탐색해보세요. 그 결과에 미치는 영향을 관찰해보세요.\n\n## 📄 결론\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이미지 비교 — 하나는 가시 영역에서 촬영되었고 다른 것들은 적외선 대역에서 촬영된 것입니다. 이 비교를 통해 다양한 전자기 스펙트럼에서 눈과 센서를 가지고 있는 능력과 중요성이 드러났습니다. 적외선 데이터의 추가적인 레이어는 RGB 이미지에서 보이지 않던 활성화된 용암 흐름과 화재 지역을 명확하게 식별하고 매핑할 수 있게 해줍니다. 가시광에 비해 적외선 대역의 우수한 침투력은 센서가 연기로 가려져있는 활성 용암과 활성 화재와 같은 물체의 존재를 감지할 수 있게 합니다. 이 능력은 이러한 사건들의 잠재적 위험을 평가하고 재난 완화를 위한 적시의 결정을 내릴 수 있는 능력을 향상시킵니다.\n\n## 📚 참고 자료\n\nCopernicus Sentinel 데이터 [2024]에 대한 Sentinel 데이터\n\nCopernicus 서비스 정보 [2024]에 대한 Copernicus 서비스 정보\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n📱 저와 더 많은 콘텐츠를 공유하기 위해 다른 플랫폼에서 저와 연결해보세요! LinkedIn, ResearchGate, Github, 그리고 Twitter.\n\n이 링크를 통해 확인할 수 있는 관련 게시물이 있습니다:","ogImage":{"url":"/TIL/assets/img/2024-07-12-SatellitesCanSeeInvisibleLavaFlowsandActiveWildfiresButHowPython_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-SatellitesCanSeeInvisibleLavaFlowsandActiveWildfiresButHowPython_0.png","tag":["Tech"],"readingTime":23},{"title":"Polars V10 출시 소식 놓치지 마세요","description":"","date":"2024-07-12 20:43","slug":"2024-07-12-PolarsV10released","content":"\n\nPolars, 현대적인 Python DataFrame 라이브러리를 개발한 분들께 축하드립니다! 최근에 제품의 1.0 버전을 출시했군요. 이 릴리스로 Polars는 이제 공식적으로 프로덕션에 준비되었으며 시스템 전반에 자유롭게 사용할 수 있습니다.\n\n릴리스를 발표한 블로그 포스트에서 Polars 팀은 앞으로의 로드맵에 대한 몇 가지 힌트를 주었습니다.\n\n## 스트리밍 엔진 재디자인\n\n이 혁신적인 디자인은 morsel-driven 병렬성을 Rust의 비동기 상태 머신과 융합하여 하이브리드 푸시/풀 엔진을 만들었습니다. 이 엔진은 morsel-driven 병렬성의 캐시 지역성, 병렬성 및 NUMA 인식을 활용하면서, 유연한 연산자 디자인을 사용하여 러스트로 관리되는 상태 머신으로 컴파일되어 복잡성을 관리합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n스트리밍은 많은 작업 부하에 대해 매우 빠르고 메모리를 효율적으로 사용하지만 특정 시계열 작업에 대해 최적으로 작동하지 않을 수 있습니다. 롤링 윈도우 및 윈도우 함수와 같은 작업은 스트리밍 중에 동기화가 더 많이 필요하며 그에 비해 메모리에서 실행할 때보다 더 많은 동기화가 필요합니다. 이러한 함수의 경우, Polars는 모든 작업 부하에 최적의 성능을 보장하기 위해 그것의 메모리 엔진으로 되돌아갑니다.\n\n## NVIDIA RAPIDS를 사용한 GPU 가속화\n\n또 다른 흥미로운 발전은 Polars에 GPU 가속화를 추가한 것입니다. 이 분야에서 상당한 진전이 이루어지고 이미 Polars 테스트 스위트의 상당 부분이 GPU에서 실행됩니다. GPU 가속화를 Polars 옵티마이저와 결합하면 최적의 성능과 GPU에 대한 메모리 압력이 줄어듭니다. GPU는 병렬성을 처리하고 옵티마이저는 실행되는 최소한의 작업량을 보장합니다.\n\n## Polars 클라우드\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nPolars Cloud를 사용하면 조직이 Polars를 호스팅하고 확장하는 복잡성을 줄일 수 있는 관리 서비스를 제공하는 것을 목표로 합니다. Polars Cloud의 개발은 꾸준히 진행 중이며, 올해 초기 베타 테스트를 시작할 준비가 되어 있습니다. Polars Cloud의 많은 요구 사항은 오픈 소스 프로젝트의 개선으로 직접 이어지고 있습니다. 예를 들어, 새로운 1.0 릴리스는 하이브 파티션 데이터셋의 스캔을 지원하고 클라우드 파일 캐싱 및 다양한 형식에 대한 클라우드 지원 확장을 가져 왔습니다. 우리는 관리 서비스에서 Polars 오픈 소스 엔진을 사용하여 개선 사항이 Polars Cloud 사용자뿐만 아니라 오픈 소스 사용자에게도 이점을 제공하도록 하겠습니다.\n\n## 다른 주목할 만한 목표\n\n단기 로드맵에 포함된 다른 계획에는 right joins, non-equi joins, 확장된 메타데이터 지원, 조인 재정렬 최적화, 그리고 확장된 SQL 지원이 포함되어 있습니다.\n\nPolars의 미래 방향에 관심이 많습니다. 함께 많은 일을 이루어나갈 Polars 팀을 기대하고 있어요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nPolars에 대해 더 자세히 알고 싶다면, 그들의 웹사이트를 확인해보세요.\n\n만약 이 콘텐츠가 마음에 들었다면, 여기에 다른 관련 기사들이 있습니다. 함께 읽어보세요.","ogImage":{"url":"/TIL/assets/no-image.jpg"},"coverImage":"/TIL/assets/no-image.jpg","tag":["Tech"],"readingTime":3},{"title":"키워드 검색이 모든 것을 해결해줄까","description":"","date":"2024-07-12 20:41","slug":"2024-07-12-Maybekeywordsearchisallyouneed","content":"\n\n\n\n![이미지](/TIL/assets/img/2024-07-12-Maybekeywordsearchisallyouneed_0.png)\n\n의미 검색이 자연어 강점을 강조하며 주목을 받는 동안, 클래식 키워드 검색은 여전히 가치 있는 도구로 남아 있습니다. Retrieval Augmented Generation이 유명해지거나, 때로는 사용자 의도가 분명하지 않을 수 있기 때문일지도 모릅니다. 이유가 무엇이든 의미 검색만이 인기 있는 주제인 것 같습니다.\n\n정말 그게 그렇게 필요한가요? 모든 시간에 복잡한 검색이 필요한가요?\n\n# 의미 검색과 키워드 검색의 차이점은 무엇인가요?\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n먼저 몇 가지 간단한 정의들을 살펴봐요.\n\n키워드 검색(Keyword Search): 데이터 내에서 특정 키워드나 구에서의 정확한 존재에 의존하는 리터럴 일치 기반 시스템.\n\n의미 검색(Semantic Search): 질의의 의미와 의도를 이해하려고 하는 보다 정교한 방법으로, 단어와 개념 간의 맥락과 관계를 고려합니다.\n\n그래서 의미 검색과 키워드 검색의 주요 차이는 의미 검색이 검색 용어 뒤의 맥락과 의도에 초점을 맞추는 데 반해, 키워드 검색은 검색에 사용된 키워드에 기반하여 검색 기록을 일치시킨다는 것이에요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# also a keyword search is all you need\n\n“올드 스쿨” 방식인 키워드 검색이 빛을 발하는 시나리오를 살펴봅시다. 그리고 어떤 유형의 데이터에서 빛을 발하는지 알아봅시다.\n\n1. 정밀함이 최고입니다: 클래식 키워드 검색은 정확히 무엇을 찾고 있는지 알 때 매우 명확한 결과를 제공합니다. 특정 문서 제목이나 정확한 구절이 필요한가요? 적절한 키워드를 목걸이처럼 연결하여 정확성을 확보할 수 있습니다.\n\n2. 간단하고 명확합니다: 이 직관적인 방식은 모호성을 제거합니다. 키워드를 입력하면 해당 키워드를 포함한 결과를 얻습니다. 잘못 해석하거나 의도하지 않은 연상을 피할 수 있어서 법적 연구나 기술 문서 검색과 같은 작업에 이상적입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n3. **속도 악당**: 직접적인 매칭에 의존하기 때문에 클래식 검색 알고리즘은 쿼리를 더 빨리 처리합니다. 이 효율성은 과학 데이터베이스나 금융 거래 플랫폼과 같이 실시간 응답을 필요로 하는 대규모 데이터 세트나 응용 프로그램에 중요합니다.\n\n4. **당신의 통제**: 검색어를 지정하여 예상치 못한 결과에 대한 여지를 남기지 않습니다. 데이터베이스를 키워드로 풍부하게 하는 경우, 검색 기준을 더욱 좁혀 설정할 수 있습니다. 이 통제는 규정 준수나 브랜드 안전 검사와 같이 특정 기준을 엄수해야 하는 작업에 가치가 있습니다.\n\n![Image](/TIL/assets/img/2024-07-12-Maybekeywordsearchisallyouneed_1.png)\n\n5. **구조화된 데이터의 낙원**: 클래식 검색은 제품 카달로그, 분류 체계, 메타 데이터 풍부한 데이터베이스와 같이 잘 구조화된 데이터에서 번성합니다. 정확한 키워드는 이러한 조직화된 시스템을 레이저 포커스로 탐색하여 특정 정보를 효율적으로 검색할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n6. 친숙한 친구: 전통적인 검색 방법에 익숙한 사용자들에게는 클래식한 접근 방식이 편안한 인터페이스를 제공합니다. 그들은 게임의 규칙을 이해하므로 학습 곡선 없이 필요한 것을 쉽게 찾을 수 있습니다.\n\n7. 비용 효율적인 옵션: 클래식한 검색 인프라를 구현하고 유지하는 데는 의미론적 대응물에 비해 더 적은 계산 성능과 자원이 필요합니다. 이는 작은 조직이나 복잡하지 않은 검색 요구 사항을 가진 애플리케이션에게 예산 친화적인 솔루션이 됩니다.\n\n# 컨셉 증명 — 나의 기사들을 키워드 검색하기\n\n그래서 나는 직접 테스트해 보기로 결정했습니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n100개의 미디엄 기사를 텍스트 파일로 저장하고 데이터베이스를 구축하기 시작했어요. 목표는(참 간단해 보일 수 있지만...) 내 기사들의 모든 키워드를 안내해주는 검색 창을 갖는 것이에요.\n\n![이미지](/TIL/assets/img/2024-07-12-Maybekeywordsearchisallyouneed_2.png)\n\n# 어려움\n\n먼저 필요한 db의 종류를 결정해야 했어요. 이건 간단한 검색이니까 전통적인 데이터베이스가 적당할 거 같아요. 저는 pandas 데이터프레임을 선택했어요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n두 번째로 고려해야 할 사항은 데이터베이스 내의 관계입니다: 키워드를 검색하고 쿼리와 일치하는 텍스트 청크를 반환하고 싶습니다. 그러나 동일한 키워드가 매우 동일한 청크를 반환하면 해당 청크 중 하나만 원합니다. 이해를 돕기 위해 설명드리겠습니다:\n\n저의 기사 'Hugging Face로 LLM을 통한 히치하이커 안내서'에는 많은 청크가 있고, 각각에는 3개 또는 4개의 키워드(예: hitchhiker, llm, guide, ai)가 있습니다.\n\n![이미지](/TIL/assets/img/2024-07-12-Maybekeywordsearchisallyouneed_3.png)\n\n첫 두 hits에서 청크가 동일하지만 다른 키워드를 가리키는 것을 볼 수 있습니다. 실제로 쿼리에서 요청한 것과 일치합니다. 동일한 적용은 세 번째와 네 번째 태그(키워드)에도 적용되며 동일한 문서 청크가 반환됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리는 결과를 유일하게 유지하고 싶어해요 (이미 언급된 청크가 있으면 그 중 하나만 남겨둡니다).\n\n# 데이터 준비 방법\n\n데이터 수집 및 처리가 이 작업의 주요 관점입니다. 좋은 점은 우리가 풍부해질 때 필요한 단계를 사용하여 RAG 전략도 향상할 수 있다는 것입니다.\n\n데이터 수집 중 (우리의 기사들) 우리는 사용자 지정 청크로 나누고, LangChain 문서 형식으로 저장하기 전에 그 특정 청크의 키워드를 추출하기 위해 KeyBERT (이 매우 빠릅니다)를 실행합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그런 다음 키워드도 메타데이터로 추가합니다.\n\n다음 단계는 데이터베이스를 생성하는 것입니다: 관계형 데이터베이스가 아니기 때문에, 각 청크마다 키워드 하나 당 레코드를 갖기를 원합니다.\n\n허들 섹션으로 돌아가 볼까요: 같은 예제를 사용하면, 기사 \"A Hitchhiker Guide to LLM with Hugging Face\"의 첫 번째 청크에는 4개의 키워드가 있습니다 (예: hitchhiker, llm, guide, ai). 데이터베이스에는 이 청크에 대해 4개의 항목이 있어야 합니다. 즉, 하나는 hitchhiker, 하나는 llm, 하나는 guide, 그리고 마지막으로 ai에 대한 항목이 있어야 합니다.\n\n데이터베이스가 엄청나게 커질 거에요!!! 하지만 누가 신경을 쓰겠어요? Pandas는 정말 효율적이고 간단한 키워드 일치를 실행할 것이기 때문에 복잡하지 않아요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 그래픽 인터페이스\n\n정말 간단해야 해요.\n\n검색을 간소화하기 위해 Streamlit에서 multiselect 라는 특별한 위젯을 사용할 거에요. 이 위젯은 가능한 선택 사항 목록을 전달할 수 있는 화제적인 대화형 입력 위젯으로, 여러 개를 선택할 수 있고, 또한 타이핑을 시작하면 기존 목록에서 일치하는 항목이 나타나요.\n\n그래서 중요한 작업 중 하나는 db에서 모든 키워드 태그를 추출하고, 중복을 제거하는 거에요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nst.session_state.kwcollection = st.session_state.df['tag'].unique()\n```\n\n다중 선택 객체는 파이썬 리스트를 반환합니다. 이것은 매우 좋은데, pandas 데이터프레임을 .isin() 메서드로 필터링할 수 있기 때문입니다.\n\n```js\ndfsearch1 = st.session_state.df[st.session_state.df['tag'].isin(kw)]\n```\n\n여기서 kw는 다중 선택 객체에서 얻은 파이썬 리스트이며, st.session_state.df는 세션 상태 객체에 저장된 데이터프레임입니다. 이렇게 함으로써 전역 변수로 사용되며 Streamlit이 재 실행될 때마다 변경되지 않습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론\n\n만약 백그라운드에서 사용된 코드를 보고 싶다면 알려주세요. 직접 시도해보는 것이 가장 좋을 거예요. 판다스 작업을 다시 해보는 것은 항상 좋은 기회가 되거든.\n\n의견을 남겨주시고, 필요하다면 후속 내용을 작성할게요 😉\n\n이 검색 전략이 얼마나 빠른지 볼 수는 있지만... 기억하세요, 고전적인 키워드 검색이 항상 만병통치약은 아니라는 걸요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n세세한 질문이나 다양한 관점을 탐구하려면, 의미론적 검색은 명백한 장점을 제공합니다.\n\n그러나 정밀도, 속도, 통제 및 익숙함이 중요할 때는, 특히 잘 구조화된 데이터와 함께 사용될 때, 이 검증된 방법은 올바른 사람의 손에 강력한 도구로 남아 있습니다.\n\n이 기사를 즐겨보셨으면 좋겠습니다. 만약 이 이야기가 가치를 제공했고 조금이라도 지원하고 싶다면 다음을 해볼 수 있습니다:\n\n- 이 이야기에 대해 많이 클랩하기\n- 기억하기에 더 적합한 부분을 강조하기 (나중에 찾기 쉽고, 나는 더 나은 기사를 쓸 수 있습니다)\n- 자체 인공지능 구축 방법을 배우려면 이 무료 eBook 다운로드하기\n- 나의 링크를 사용하여 미디엄 멤버십 가입하기 (매월 $5로 무제한 미디엄 이야기 읽기)\n- 미디엄에서 나를 팔로우하기\n- 내 최신 기사 읽기 https://medium.com/@fabio.matricardi\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n더 많은 정보를 원하시면 아래의 아이디어를 확인해보세요:\n\n## Medium의 Boost / AI 라이프 해킹 / 무료 GPT 대안 / AI 아트","ogImage":{"url":"/TIL/assets/img/2024-07-12-Maybekeywordsearchisallyouneed_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-Maybekeywordsearchisallyouneed_0.png","tag":["Tech"],"readingTime":9},{"title":"파이썬 속도를 떨어뜨리는 다섯 가지 코딩 실수 및 오늘 해결하는 방법","description":"","date":"2024-07-12 20:38","slug":"2024-07-12-5PythonCodingErrorsThatAreKillingYourSpeedAndHowtoFixThemToday","content":"\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-5PythonCodingErrorsThatAreKillingYourSpeedAndHowtoFixThemToday_0.png\" /\u003e\n\n안녕하세요, 파이썬 개발자 여러분! 저는 구글 출신인 다니엘입니다. 현재는 Django를 사용하여 웹 애플리케이션을 개발하고 파이썬에 대한 집착을 키우는 데 시간을 할애하고 있습니다. 저는 주말에는 Medium에서 활발하게 활동하며 시간이 흐른 만큼 축적한 가치 있는 통찰을 전달하고, 여러분을 프로그래밍 대가로 변신시키기 위해 노력하고 있습니다.\n\n솔직히 말해서, 무력한 거북이 속도로 작동하는 파이썬 스크립트로 인한 특정 유형의 좌절감이 있죠. 웹 사이트가 느려 보이거나 데이터 분석 업무가 몇 시간 동안 계속되는 경우든, 느린 코드는 모든 관련자들에게 나쁜 경험을 안겨주며 프로젝트의 성과를 위협할 수도 있습니다.\n\n하지만 걱정하지 마세요! 이 글에서는 제가 보고(심지어 제가 직접 한 것) 온갖 성능 저하 요인을 분석해 보여드릴 것입니다. 그리고 어떤 것을 하지 말아야 하는지뿐만 아니라, 실제 해결책과 코드 예제를 제공하여 여러분의 스크립트를 부드럽고 강력한 파이썬 기계로 만들어 줄 겁니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 실수 #1: 1999년처럼 루핑하기\n\n알다시피, 제가 다른 개발자들처럼 잘 만들어진 for 루프에 대한 애정이 매우 큽니다. 이것들은 우리 작업의 많은 부분을 이루는 기초를 형성합니다. 그러나 특히 대규모 데이터셋에서 순수한 속도에 대해 논의할 때, 신뢰할 수 있는 루프들은 부스트보다는 무게 같이 느껴질 수 있습니다.\n\n## 예시: 몇 개의 숫자를 더해봅시다\n\n거대한 숫자 목록의 제곱을 합산해야 한다고 상상해보세요. 여기에는 루프 방식이 있습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nnumbers = [1, 2, 3, 4, 5, ... , 10000]  # A big list\ntotal = 0\nfor number in numbers:\n    squared = number * number\n    total += squared\n```\n\n이렇게 해도 괜찮아 보이지만 실제로는 Python이 각 요소마다 많은 개별 계산을 수행하고 있습니다.\n\n## 해결책: NumPy가 구해줄게요!\n\n이것이 NumPy가 슈퍼히어로처럼 나타나는 곳입니다. 이것은 벡터화에 관한 모든 것입니다 — 한 번에 전체 배열에 대한 연산 수행하기. 그 예시를 다시 써보겠습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nimport numpy as np\n\nnumbers = np.array([1, 2, 3, 4, 5, ... , 10000])  \nsquared = numbers * numbers  # Vectorized squaring!\ntotal = squared.sum()\n```\n\nBoom! Instead of processing element by element, NumPy takes care of the entire calculation in one go.\n\n## Bonus: The Comprehensible Compromise\n\nList comprehensions are like the stealthy middle ground:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ntotal = sum(number * number for number in numbers)\n```\n\n일반적인 루프보다 빠르지만, 강력한 숫자 계산을 위한 NumPy만큼의 세기는 아닐 수 있습니다.\n\n# 실수 #2: 잘못된 도구 선택\n\n망치 하나만으로 집을 짓는다고 상상해보세요. 집을 완성할 수는 있지만, 정말 혼란스러울 것입니다. 마찬가지로, Python에서 모든 작업에 대해 리스트만을 의존하는 것은 등이 뒤로 돌아가있는 채 프로그래밍하는 것과 같습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 예시: 내 전화번호는 어디에?\n\n만약 다음과 같이 연락처 목록이 있다면:\n\n```js\ncontacts = [\n    {\"name\": \"Alice\", \"phone\": \"123-4567\"},\n    {\"name\": \"Bob\", \"phone\": \"789-0123\"},\n    # ... 추가 연락처\n]\n```\n\nBob의 전화번호를 찾으려면 목록을 훑어봐야 합니다. 모든 연락처를 확인해야 할 수도 있어요! 어떡하지?\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 문제 해결: 초능력을 지닌 데이터 구조들\n\n- Dictionaries: 키를 이용한 신속한 검색 파트너 키(예: \"이름\")로 검색하는 경우, 사전이 당신의 신뢰할 수 있는 도우미가 될 것입니다.\n\n```js\ncontacts_dict = {\n    \"Alice\": \"123-4567\",\n    \"Bob\": \"789-0123\",\n    # ... 더 많은 연락처\n}\nbobs_number = contacts_dict[\"Bob\"]  # 즉시 접근!\n```\n\n- Sets: 고유성 강제하기 고유한 웹사이트 방문자들을 추적해야 하는가요? Set은 중복을 자동으로 제거합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\r\nunique_visitors = set()\r\nunique_visitors.add(\"192.168.1.100\")\r\nunique_visitors.add(\"124.58.23.5\")\r\nunique_visitors.add(\"192.168.1.100\")  # No duplicate added\r\n```\r\n\r\n파이썬 노하우 도구로는 순서가 있는 딕셔너리, 특별 큐를 위한 데크 등이 준비되어 있어요. 이 도구를 언제 사용해야 하는지 알아두면 좋은 스크립트와 훌륭한 스크립트를 구분할 수 있어요.\r\n\r\n# 실수 #3: 어둠 속에서 최적화하기\r\n\r\n코드가 느릴 것 같은 느낌을 익히 알고 계실 거예요. 그런데 그 이유가 왜 그런지는 모르겠다고요. 토치(Torch) 없이 누수하는 천장을 고치는 것과 유사합니다. 화가 난답니다! 여기서 프로파일러(Profiler)가 등장합니다.\r\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 예시: 예상하지 못한 범인\n\n가정해 봅시다. 피보나치 수를 계산하는 복잡한 함수가 있다고 상상해 보세요. 수학을 정밀하게 다듬기 위해 많은 노력을 기울였지만 여전히 속도가 느립니다. 결과를 파일에 기록하는 방식이 마치 은밀한 것처럼 작용하는 것이 병목일 수도 있습니다.\n\n## 해결책: cProfile이 구원해줍니다!\n\nPython의 내장 cProfile 모듈이 성능 탐지 요원이 됩니다. 다음은 그 사용법입니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nimport cProfile\n\ndef my_function():\n    # 프로파일링할 코드 입력\n\ncProfile.run('my_function()')\n```\n\n이 코드는 여러 가지 통계를 생성합니다. 주요 확인 사항은 다음과 같습니다:\n\n- ncalls: 함수가 호출된 횟수.\n- tottime: 함수 내에서 총 소요된 시간.\n- cumtime: tottime과 유사하지만 해당 함수 내에서 호출된 모든 함수에서 소요된 시간을 포함합니다.\n\n단서를 통해 정보 확인하기 위해 이러한 숫자들은 실제 병목 현상을 찾아내는 데 도움이 됩니다. 최적화 노력을 가장 큰 영향을 줄 수 있는 곳에 집중할 수 있도록 도와줍니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 오류 #4: DIY 함정\n\n여기 뭐든지 처음부터 만드는 충동이 강하죠. 이해해요! 하지만 때로는 발명의 바퀴를 다시 만드는 것은 비행기에 타지 않고 나라를 걸어 다니기로 결정하는 것과 같아요. Python은 극도로 최적화된 내장 함수로 여러분을 지원해줄 거예요.\n\n## 예시: 정렬해봅시다\n\n숫자 목록을 정렬해야 하나요? 버블 정렬을 구현해 볼 수도 있지만... Python의 sorted()를 사용해보는 것은 어떨까요?\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nmy_list = [5, 3, 1, 4, 2]\n\n# The long way (probably pretty slow)\ndef my_bubble_sort(list): \n   # ... your sorting code here\n\n# The Pythonic way\nsorted_list = sorted(my_list)\n```\n\n아마도 사용자 정의 정렬 알고리즘은 내장 알고리즘의 효율성에 거의 미치지 못할 것입니다.\n\n문제 해결법: 보물 창고를 발견하세요\n\nPython 표준 라이브러리는 개발자의 가장 좋은 친구입니다. 이러한 강력한 기능들을 알아보세요:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- itertools: 이터레이터 작업을 강화해주는 모듈 (효율적인 반복문을 위한 상급 루프라고 생각해보세요)\n- heapq: 힙(heap)을 관리하기 위한 모듈 (우선순위 큐에 관심 있으신가요?)\n- bisect: 정렬된 리스트를 유지하고 빠르게 동작하는 모듈\n\n기억해주세요: 내장 함수를 배우는 데 시간을 투자하면 나중에 최적화하는 데 시간을 절약할 수 있습니다.\n\n# 실수 #5: 하드 드라이브와 너무 많이 대화하기\n\n컴퓨터의 메모리(RAM)를 초고속 작업 영역, 하드 디스크를 도시 반대편에 있는 저장 창고로 생각해보세요. 파일에 접근하거나 수정할 때마다 전달원을 왕복하도록 하는 것과 같습니다. 너무 많은 왕복으로 코드가 대기하는 것처럼 느껴지기 시작합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 예시: 라인별 처리 지연\n\n대용량 로그 파일을 처리한다고 가정해보겠습니다:\n\n```js\nwith open(\"huge_log.txt\", \"r\") as file:\n    for line in file:\n        # 각 라인을 천천히 처리합니다\n```\n\n각 라인을 읽을 때마다 하드 드라이브에서 별도의 가져오기가 필요합니다. 아야!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 문제 해결: 더 똑똑하게 일하기\n\n- 한 번에 모두 읽기(용량이 작을 때): 작은 파일의 경우, 때로는 파일 전체를 메모리에 한꺼번에 불러오는 것이 가장 빠릅니다:\n\n```js\nwith open(\"huge_log.txt\", \"r\") as file:\n    contents = file.read() \n    # 메모리에서 내용 처리\n```\n\n- 버퍼링으로 구조화: 세밀한 제어가 필요할 때, 버퍼링이 도움이 됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nwith open(\"huge_log.txt\", \"r\") as file:\n    while True:\n        chunk = file.read(4096)  # Read in chunks\n        if not chunk:\n            break\n        # Process the chunk\n```\n\n블록으로 생각하라, 바이트로는 아니다. \"창고\"로의 왔다갔다를 최소화하면 굉장한 영향을 미친다.\n\n# 결론: 파이썬에 올인하세요!\n\n자, 이제 우리의 속도 저하는 원인을 다시 한 번 요약해 봅시다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 루프 과부화: NumPy로 벡터화를 활용해보세요.\n- 잘못된 도구: 룩업에는 사전, 고유성에는 세트... 현명하게 선택하세요!\n- 맹목적 최적화: 실제 병목 현상을 확인하기 위해 cProfile로 프로파일링하세요.\n- 직접 만들기 열풍: Python의 내장 함수들은 여러분의 친구입니다. 활용하세요!\n- 디스크 부하 너무 많이: 전략적으로 읽고 현명하게 버퍼링하세요.\n\n성능은 일회성 수정이 아닙니다. 이것을 마라톤 훈련처럼 생각해보세요: 코드를 프로파일링하고 핫 스팟을 최적화한 뒤, 이 과정을 반복하세요. 곧 여러분은 치타처럼 우아하게 실행되는 Python 스크립트를 가지게 될 것입니다.\n\n## 행동 요구\n\n이것을 실천하실 준비가 되셨나요? 여러분의 코드에서 이러한 실수를 찾아보세요! 여러분이 얻는 속도 향상에 대한 소식을 듣고 싶습니다. 결과를 댓글로 공유해주세요. 함께 최적화를 축하해봐요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 더 알고 싶나요?\n\n만약 이 내용이 도움이 되었다면, 더 많은 Python 팁과 트릭을 보기 위해 제 Medium을 팔로우해주세요. 좋은 리뷰는 언제나 환영이에요 😉. 그리고, 컨텐츠를 좋아하신다면, Patreon에 가입하여 독점 혜택을 받거나, 제가 Python에 대해 종일 이야기를 나누는 Discord 커뮤니티에 가입해보세요.\n\n## 즐거운 코딩되세요!\n\n# 쉽게 이해할 수 있는 English 🚀\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nIn Plain English 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 클랩하고 팔로우해 주세요 👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io에서 더 많은 콘텐츠 확인 가능합니다","ogImage":{"url":"/TIL/assets/img/2024-07-12-5PythonCodingErrorsThatAreKillingYourSpeedAndHowtoFixThemToday_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-5PythonCodingErrorsThatAreKillingYourSpeedAndHowtoFixThemToday_0.png","tag":["Tech"],"readingTime":12},{"title":"FinalMLP 추천 시스템을 위한 간단하지만 강력한 Two-Stream MLP 모델 사용 방법","description":"","date":"2024-07-12 20:35","slug":"2024-07-12-FinalMLPASimpleyetPowerfulTwo-StreamMLPModelforRecommendationSystems","content":"\n\n이 게시물은 Rafael Guedes와 공동 저자로 작성되었습니다.\n\n# 소개\n\n세계는 모두가 원하는 것을 거의 한 번 클릭으로 모두 얻을 수 있는 디지턈 시대로 발전해 왔습니다. 접근성, 편의성 및 다양한 제공 효과는 소비자에게 새로운 도전과 함께 제공됩니다. 소비자가 옵션의 바다 속에서 검색하는 대신 맞춤 선택을 받을 수 있는 방법은 무엇일까요? 바로 추천 시스템이 여기에서 나타납니다.\n\n추천 시스템은 조직이 교차 판매와 장꼬 아이템의 판매를 증가시키고, 고객들이 가장 좋아하는 것을 분석하여 의사 결정을 개선하는 데 유용합니다. 뿐만 아니라, 고객의 과거 행동을 학습하여 특정한 고객 선호도에 따라 제품 집합을 순위 매길 수 있습니다. 추천 시스템을 사용하는 조직은 향상된 고객 경험을 제공함으로써 경쟁사보다 한 발 앞서 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 기사에서는 온라인 광고 및 추천 시스템에서의 클릭 수 예측을 향상시키기 위해 설계된 새로운 모델인 FinalMLP에 초점을 맞춥니다. Advanced features like gating and interaction aggregation layers를 갖춘 두 개의 다층 퍼셉트론(MLP) 네트워크를 통합하여, FinalMLP은 기존의 단일 스트림 MLP 모델과 고급 두 개의 스트림 CTR 모델보다 우수한 성능을 보입니다. 저자들은 FinalMLP의 효과를 벤치마크 데이터셋 및 실제 온라인 A/B 테스트를 통해 확인했습니다.\n\nFinalMLP의 상세한 내용과 작동 방식에 초점을 맞추면서, 공개 데이터셋에 적용하고 구현하는 방법에 대한 안내도 제공합니다. 우리는 책 추천 설정에서 FinalMLP의 정확도를 테스트하고, 저자들이 제안한 두 개의 스트림 아키텍처를 활용하여 예측을 설명하는 능력을 평가합니다.\n\n항상 그렇듯이, 코드는 저희의 GitHub에서 이용 가능합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# FinalMLP: 두 개의 MLP 위에 (F)eature gating 및 (IN)teraction (A)ggregation (L)ayers가 추가된 모델\n\nFinalMLP [1]은 DualMLP [2] 위에 구축된 두 개의 스트림 Multi-Layer Perceptron (MLP) 모델로, 다음과 같은 2가지 새로운 개념을 도입하여 향상시킵니다:\n\n- Gating 기반의 특징 선택은 두 스트림 간의 차이를 증가시켜, 각 스트림이 서로 다른 특징 세트로부터 서로 다른 패턴을 학습하도록 만듭니다. 예를 들어, 하나의 스트림은 사용자 특징을 처리하고, 다른 하나는 항목 특징에 중점을 둡니다.\n- Multi-Head Bilinear Fusion은 두 스트림에서 나온 출력을 결합하는 방법을 개선하여 특징 상호작용을 모델링합니다. 이는 덧셈 또는 연결과 같은 선형 연산에 의존하는 전통적인 방식을 사용할 때 발생하지 않을 수 있습니다.\n\n![이미지](/TIL/assets/img/2024-07-12-FinalMLPASimpleyetPowerfulTwo-StreamMLPModelforRecommendationSystems_1.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 작동 방법은 무엇인가요?\n\n이전에 언급한 대로, FinalMLP는 서로 다른 관점에서 특징 상호 작용을 학습하는 두 개의 간단하고 병렬 MLP 네트워크로 구성된 Two-Stream CTR 모델입니다. 다음과 같은 주요 구성 요소로 구성되어 있습니다:\n\n특징 임베딩 레이어는 고차원 및 희소한 원시 특징을 밀집 숫자 표현으로 매핑하는 일반적인 방법입니다. 범주형, 숫자, 또는 다중 값이어도 각 특징은 임베딩 벡터로 변환되고 Feature Selection 모듈에 입력하기 전에 연결됩니다.\n\n범주형 특징은 원-핫 특징 벡터로 변환되며, 학습 가능한 임베딩 행렬에 의해 곱해져 어휘 크기 n과 임베딩 차원 d를 가진 임베딩을 생성합니다[3].\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n숫자형 특성은 1) 숫자 값을 이산형 특성으로 버킷팅하고 이를 범주형 특성으로 다루거나 2) 정규화된 스칼라 값 xj가 주어지면, 임베딩은 xj를 field j의 모든 특성에 대한 공유 임베딩 벡터 vj와 곱한 것으로 주어질 수 있습니다 [3].\n\n다중값 특성은 값 시퀀스를 하나의 길이가 k인 원-핫 인코딩 벡터로 변환한 다음 학습 가능한 임베딩 행렬과 곱하여 임베딩을 생성할 수 있습니다 [3].\n\n![이미지](/TIL/assets/img/2024-07-12-FinalMLPASimpleyetPowerfulTwo-StreamMLPModelforRecommendationSystems_2.png)\n\n특성 선택 레이어는 모델 예측에 중요한 영향을 미치도록 중요한 특성에 더 높은 영향을 미치도록 잡음이 많은 특성을 억제하기 위한 특성 중요도 가중치를 얻기 위해 사용됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n언급한 대로, FinalMLP는 게이팅 기반 특성 선택, 그리고 게이트 메커니즘을 갖춘 MLP를 사용합니다. 이 MLP는 임베딩을 입력으로 받아들이고, 입력과 동일한 차원의 가중치 벡터를 생성합니다. 특성 중요도 가중치는 시그모이드 함수를 가중치 벡터에 적용하여 [0, 2] 범위의 벡터를 생성하는 방식으로 얻어집니다. 가중된 특성은 특성 임베딩과 특성 중요도 가중치 사이의 요소별 곱셈을 통해 얻어집니다.\n\n이 과정을 통해 두 스트림 간 균질한 학습이 감소되어 특성 상호작용의 보다 보완적인 학습이 가능해집니다. 유저나 아이템 차원에 집중하도록 각 스트림에 독립적으로 적용되어 특성 입력을 구분합니다.\n\n![](/TIL/assets/img/2024-07-12-FinalMLPASimpleyetPowerfulTwo-StreamMLPModelforRecommendationSystems_3.png)\n\n양 스트림의 출력을 결합하여 최종 예측 확률을 얻기 위해 스트림 수준 융합 계층이 필요합니다. 일반적으로 두 출력을 결합하는 것은 합산 또는 연결 작업을 기반으로 합니다. 그러나 FinalMLP의 저자들은 선형 조합이 실패할 수 있는 특성 상호작용 정보를 얻기 위해 두 출력을 결합하는 데에 양선형 상호작용 집계 계층을 제안합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저자들은 어텐션 레이어에서 영감을 받아 멀티 헤드 바이리니어 퓨전 레이어로 발전시킨 바이리니어 퓨전을 소개했습니다. 이는 계산 복잡성을 줄이고 모델의 확장성을 향상시키는 데 사용됩니다.\n\n바이리니어 퓨전 방정식은 다음과 같이 구성됩니다:\n\n![image](/TIL/assets/img/2024-07-12-FinalMLPASimpleyetPowerfulTwo-StreamMLPModelforRecommendationSystems_4.png)\n\n여기서 σ는 시그모이드 함수, b는 편향 항목이며, o1은 한 스트림의 출력입니다. w1은 o1에 적용되는 학습 가능한 가중치이고, o2는 다른 스트림의 출력이며, w2는 o2에 적용되는 학습 가능한 가중치입니다. 마지막으로, w3는 특성 상호작용 정보를 추출하는 바이리니어 항목의 학습 가능한 매트릭스입니다. w3가 제로 매트릭스로 설정되면 전통적인 연결 퓨전으로 약화됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nBilinear Fusion과 Multi-Head Bilinear Fusion의 차이점은, 두 스트림에서 전체 벡터를 사용하는 대신 출력 o1과 o2를 k 개의 하위 공간으로 나눈다는 것입니다. 각 하위 공간에서 이루어진 bilinear 퓨전은 sigmoid 함수에 공급하여 최종 확률을 생성합니다.\n\n![그림](/TIL/assets/img/2024-07-12-FinalMLPASimpleyetPowerfulTwo-StreamMLPModelforRecommendationSystems_5.png)\n\n# FinalMLP로 도서 추천 모델 만들기\n\n이 섹션에서는 FinalMLP를 Kaggle의 Public Domain 라이선스(CC0)로 공개된 데이터셋에 구현할 것입니다. 이 데이터셋에는 사용자, 책, 그리고 사용자가 책에 부여한 등급에 관한 정보가 포함되어 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n데이터셋은 다음과 같이 구성되어 있습니다:\n\n- 사용자 ID — 사용자를 식별하는 ID\n- 위치 — 사용자의 도시, 주, 국가가 콤마로 구분된 문자열\n- 나이 — 사용자의 나이\n- ISBN — 책 식별자\n- 책 평점 — 특정 책에 대한 사용자의 평점\n- 책 제목 — 책의 제목\n- 책 저자 — 책의 저자\n- 출판 연도 — 책이 출판된 연도\n- 출판사 — 책을 출판한 편집자\n\n우리는 각 사용자에 대한 관련성을 기반으로 책을 순위 지정할 것입니다. 그 후에는 우리의 순위 지정과 실제 순위(사용자가 지정한 평점에 따라 책을 정렬함)를 비교하기 위해 정규화 된 할인 누적 이익 (nDCG)를 사용할 것입니다.\n\nnDCG는 결과의 순위를 측정하여 추천 시스템의 품질을 평가하는 메트릭스입니다. 각 항목의 관련성과 결과 목록에서의 위치를 고려하여 상위 순위에 더 많은 중요성을 부여합니다. nDCG는 낮은 순위 항목의 이익을 할인하는 할인 누적 이익(DCG)과 완벽한 순위를 감안한 이상적인 DCG (iDCG)를 비교하여 계산됩니다. 이 정규화된 점수는 0에서 1 사이의 범위를 가지며, 1은 이상적인 순위를 나타냅니다. 따라서 nDCG는 어떻게 시스템이 사용자에게 관련 정보를 효과적으로 제공하는지 이해하는 데 도움이 됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리는 먼저 라이브러리를 가져와요:\n\n```python\n%matplotlib inline\n%load_ext autoreload\n%autoreload 2\n\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport random\nfrom sklearn.metrics import ndcg_score\nfrom sklearn.decomposition import PCA\nfrom sentence_transformers import SentenceTransformer\nimport os\nimport logging\nfrom fuxictr.utils import load_config, set_logger, print_to_json\nfrom fuxictr.features import FeatureMap\nfrom fuxictr.pytorch.torch_utils import seed_everything\nfrom fuxictr.pytorch.dataloaders import H5DataLoader\nfrom fuxictr.preprocess import FeatureProcessor, build_dataset\nimport src\nimport gc\nimport os\n```\n\n그런 다음, 세 개의 데이터 세트를로드하고 단일 데이터 세트로 병합합니다:\n\n```python\nbooks_df = pd.read_csv('data/book/Books.csv')\nusers_df = pd.read_csv('data/book/Users.csv')\nratings_df = pd.read_csv('data/book/Ratings.csv')\n\ndf = pd.merge(users_df, ratings_df, on='User-ID', how='left')\ndf = pd.merge(df, books_df, on='ISBN', how='left')\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그 후, 데이터에 문제점을 식별하기 위해 탐색적 데이터 분석을 수행합니다:\n\n- 사용자가 책에 평가를 내리지 않은 관측치를 제거합니다.\n\n```js\ndf = df[df['Book-Rating'].notnull()]\n```\n\n- 누락된 값 확인 및 누락된 Book-Author 및 Publisher를 알 수 없는 카테고리로 대체합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nprint(df.columns[df.isna().any()].tolist())\n\ndf['Book-Author'] = df['Book-Author'].fillna('unknown')\ndf['Publisher'] = df['Publisher'].fillna('unknown')\n```\n\n- Remove observations with missing information about the book.\n\n```js\ndf = df[df['Book-Title'].notnull()]\n```\n\n- Replace non-integer Year-of-Publication with null values.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\ndf['Year-Of-Publication'] = pd.to_numeric(df['Year-Of-Publication'], errors='coerce')\n```\n\n- 이상을 식별하려면 나이, 출판 연도 및 도서 평점 분포를 확인해보세요.\n\n```python\nplt.rcParams[\"figure.figsize\"] = (20, 3)\nsns.histplot(data=df, x='Age')\nplt.title('나이 분포')\nplt.show()\n\nsns.histplot(data=df, x='Year-Of-Publication')\nplt.title('출판 연도 분포')\nplt.show()\n\nsns.histplot(data=df, x='Book-Rating')\nplt.title('도서 평점 분포')\nplt.show()\n```\n\n![이미지](/TIL/assets/img/2024-07-12-FinalMLPASimpleyetPowerfulTwo-StreamMLPModelforRecommendationSystems_6.png)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마침내, 데이터 정리를 다음과 같이 진행합니다:\n\n- 나이가 100 (오기로 보이는 값)인 경우, 나중에 처리할 결측값으로 대체합니다.\n- 데이터셋이 Kaggle에 발행된 시점인 2021년을 상한으로 제한하고, 발행년도가 0인 경우에는 나중에 처리할 결측값으로 대체합니다.\n- 사용자가 독서는 했지만 평점은 남기지 않은 경우 평점이 0인 관측치를 제거합니다.\n- 위치 정보에서 3가지 새로운 특성(도시, 주, 국가)를 생성합니다. 너무 노이즈가 많은 도시 정보는 사용하지 않습니다.\n- FinalMLP를 위한 이진 레이블을 생성합니다. 평점이 7보다 높은 책을 사용자에게 관련성 있는 것으로 간주합니다.\n\n```js\ndf['Age'] = np.where(df['Age'] \u003e 100, None, df['Age'])\n\ndf['Year-Of-Publication'] = np.where(df['Year-Of-Publication'].clip(0, 2021) \u003c= 0, None, df['Year-Of-Publication'])\ndf = df[df['Book-Rating'] \u003e 0]\ndf['city'] = df['Location'].apply(lambda x: x.split(',')[0].strip()) # too noisy, we will not use\ndf['state'] = df['Location'].apply(lambda x: x.split(',')[1].strip())\ndf['country'] = df['Location'].apply(lambda x: x.split(',')[2].strip())\ndf['label'] = (df['Book-Rating'] \u003e 7)*1\n```\n\n데이터셋을 정리하면, 랜덤으로 사용자의 70%를 훈련용, 10%를 검증용, 20%를 테스트용으로 나눠서 데이터를 분할합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 고유 사용자 목록 생성\nusers = df['User-ID'].unique()\n\n# 목록 섞기\nrandom.shuffle(users)\n# 학습용, 검증용 및 테스트용 사용자 목록 생성\ntrain_users = users[:int(0.7*len(users))]\nval_users = users[int(0.7*len(users)):int(0.8*len(users))]\ntest_users = users[int(0.8*len(users)):]\n# 학습, 검증 및 테스트 데이터프레임\ntrain_df = df[df['User-ID'].isin(train_users)]\nval_df = df[df['User-ID'].isin(val_users)]\ntest_df = df[df['User-ID'].isin(test_users)]\r\n```\n\n모델에 데이터를 제공하기 전에 데이터에 일부 전처리를 적용할 것입니다:\n\n텍스트 특성인 Book-Title에 대한 다국어 인코더를 사용하여 임베딩을 생성하고, 80%의 분산이 설명되도록 PCA를 사용하여 차원을 축소합니다.\n\n다국어 인코더를 사용하는 이유는 제목이 서로 다른 언어로 작성되기 때문입니다. 또한, 책이 다른 책보다 더 많은 사용자에 의해 읽혔을 경우 차원 축소에 편향이 주입되지 않도록 먼저 고유한 Book-Title을 추출합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 임베딩 생성\ntrain_embeddings = utils.create_embeddings(train_df.copy(), \"Book-Title\")\nval_embeddings = utils.create_embeddings(val_df.copy(), \"Book-Title\")\ntest_embeddings = utils.create_embeddings(test_df.copy(), \"Book-Title\")\n\n# PCA를 사용하여 차원 축소\ntrain_embeddings, pca = utils.reduce_dimensionality(train_embeddings, 0.8)\nval_embeddings = pca.transform(val_embeddings)\ntest_embeddings = pca.transform(test_embeddings)\n# 데이터프레임에 임베딩 추가\ntrain_df = utils.add_embeddings_to_df(train_df, train_embeddings, \"Book-Title\")\nval_df = utils.add_embeddings_to_df(val_df, val_embeddings, \"Book-Title\")\ntest_df = utils.add_embeddings_to_df(test_df, test_embeddings, \"Book-Title\")\n```\n\n숫자형 특성의 결측값은 중앙값으로 채우고 MinMaxScaler를 사용하여 데이터를 정규화합니다.\n\n```js\n# 숫자형 열 설정\nNUMERICAL_COLUMNS = [i for i in train_df.columns if \"Book-Title_\" in i] + ['Age', 'Year-Of-Publication']\n\n# 전처리 파이프라인 정의 및 데이터 변환\npipe = utils.define_pipeline(NUMERICAL_COLUMNS)\ntrain_df[NUMERICAL_COLUMNS] = pipe.fit_transform(train_df[NUMERICAL_COLUMNS])\nval_df[NUMERICAL_COLUMNS] = pipe.transform(val_df[NUMERICAL_COLUMNS])\ntest_df[NUMERICAL_COLUMNS] = pipe.transform(test_df[NUMERICAL_COLUMNS])\n```\n\nFinalMLP에 제공할 준비가 된 모든 데이터로 dataset_config.yaml 및 model_config.yaml 두 개의 yaml 구성 파일을 만들어야 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\ndataset_config.yaml 파일은 모델에서 사용할 feature들을 정의하는 역할을 합니다. 또한 이들의 데이터 유형을 정의하고(Embedding 레이어에서 다르게 처리됨) 훈련, 검증, 테스트 세트의 경로를 정의합니다. 아래는 구성 파일의 주요 부분을 확인할 수 있습니다:\n\n\nFinalMLP_book:\n    data_root: ./data/book/\n    feature_cols:\n    -   active: true\n        dtype: float\n        name: [Age, Book-Title_0, Book-Title_1, Book-Title_2, Book-Title_3, Book-Title_4, Book-Title_5, Book-Title_6, Book-Title_7,\n        Book-Title_8, ...]\n        type: numeric\n    -   active: true\n        dtype: str\n        name: [Book-Author, Year-Of-Publication, Publisher, state, country]\n        type: categorical\n        fill_na: unknown\n    label_col: {dtype: float, name: label}\n    min_categr_count: 1\n    test_data: ./data/book/test.csv\n    train_data: ./data/book/train.csv\n    valid_data: ./data/book/valid.csv\n\n\nmodel_config.yaml 파일은 모델의 하이퍼파라미터를 설정하는 역할을 합니다. 사용자 feature를 처리할 스트림과 아이템 feature를 처리할 스트림을 정의해야 합니다. 파일은 다음과 같이 정의되어야 합니다:\n\n\nFinalMLP_book:\n dataset_id: FinalMLP_book\n fs1_context: [Age, state, country]\n fs2_context: [Book-Author, Year-Of-Publication, Publisher, Book-Title_0, Book-Title_1, Book-Title_2, Book-Title_3,\n     Book-Title_4, Book-Title_5, ...]\n model_root: ./checkpoints/FinalMLP_book/\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파이썬으로 돌아가서 최근에 생성된 설정 파일을 로드합니다. 그런 다음, 특성 매핑을 만듭니다 (즉, 각 범주형 특성에 몇 가지 카테고리가 있는지, 다른 특성에서 누락된 값이 있을 경우 어떻게 대체해야 하는지 등). CSV 파일을 h5 파일로 변환합니다.\n\n```python\n# 모델 및 데이터셋 구성 가져오기\nexperiment_id = 'FinalMLP_book'\nparams = load_config(f\"config/{experiment_id}/\", experiment_id)\nparams['gpu'] = -1 # CPU\nset_logger(params)\nlogging.info(\"Params: \" + print_to_json(params))\nseed_everything(seed=params['seed'])\n\n# 특성 매핑 생성 및 데이터를 h5 형식으로 변환\ndata_dir = os.path.join(params['data_root'], params['dataset_id'])\nfeature_map_json = os.path.join(data_dir, \"feature_map.json\")\nif params[\"data_format\"] == \"csv\":\n    # 특성 매핑 빌드 및 h5 데이터 변환\n    feature_encoder = FeatureProcessor(**params)\n    params[\"train_data\"], params[\"valid_data\"], params[\"test_data\"] = \\\\\n        build_dataset(feature_encoder, **params)\nfeature_map = FeatureMap(params['dataset_id'], data_dir)\nfeature_map.load(feature_map_json, params)\nlogging.info(\"Feature specs: \" + print_to_json(feature_map.features))\n```\n\n이후에 모델의 훈련 프로세스를 시작할 수 있습니다.\n\n```python\nmodel_class = getattr(src, params['model'])\nmodel = model_class(feature_map, **params)\nmodel.count_parameters() # 모델에서 사용하는 매개변수 수를 출력\n\ntrain_gen, valid_gen = H5DataLoader(feature_map, stage='train', **params).make_iterator()\nmodel.fit(train_gen, validation_data=valid_gen, **params)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마침내 보이지 않는 데이터를 예측할 수 있게 되었습니다. 관측치들의 점수를 얻기 위해 배치 크기를 1로 변경하기만 하면 됩니다.\n\n```js\n# 관측치들의 점수를 얻기\nparams['batch_size'] = 1\ntest_gen = H5DataLoader(feature_map, stage='test', **params).make_iterator()\ntest_df['score'] = model.predict(test_gen)\n```\n\n우리는 한 명의 고객을 선택했는데, 이 고객은 여러 권의 책을 평가하고 각 책에 대해 다른 평점을 매겨서 맞춤 순위를 설정할 수 있도록 했습니다. nDCG 점수는 0.986362로 나타났는데, 2권의 책을 1위에서 잘못 배치했기 때문입니다.\n\n우리는 FinalMLP를 평가하기 위해 Recall을 사용했습니다. Recall은 시스템이 전체 중에서 모든 관련 항목을 식별하는 능력을 측정하는 지표로, 전체 관련 항목 중 검색된 관련 항목의 비율로 나타냅니다. Recall@K와 같이 Recall@3을 지정하면 시스템이 상위 K개의 추천 내에서 관련 항목을 식별하는 능력에 초점을 맞춥니다. 이것은 사용자들이 주로 상위 추천에 주목하는 추천 시스템을 평가하는 데 중요합니다. K(예: 3)의 선택은 일반적인 사용자 행동과 애플리케이션 맥락에 따라 달라집니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 고객의 Recall@3을 살펴보면, 상위 3위 안에 가장 관련성 있는 책이 세 권 모두 들어있기 때문에 100%입니다.\n\n```js\ntrue_relevance = np.asarray([test_df[test_df['User-ID'] == 1113]['Book-Rating'].tolist()])\ny_relevance = np.asarray([test_df[test_df['User-ID'] == 1113]['score'].tolist()])\n\nndcg_score(true_relevance, y_relevance)\n```\n\n남은 테스트 세트에 대한 nDCG 점수를 계산하고, Figure 7에서 FinalMLP 성능을 CatBoost Ranker와 비교했습니다. 두 모델 모두 잘 수행했지만, 이 테스트 세트에서 FinalMLP가 조금 더 우수한 성능을 보였습니다. 사용자 당 평균 nDCG가 0.963298인 반면 CatBoost Ranker는 0.959977에 그쳤습니다.\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-FinalMLPASimpleyetPowerfulTwo-StreamMLPModelforRecommendationSystems_7.png\" /\u003e\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n해석 가능성 측면에서 이 모델은 특성 선택을 수행하여 가중치 벡터를 추출할 수 있게 합니다. 그러나 각 특성의 중요성을 해석하고 이해하는 것은 간단하지 않습니다. 임베딩 레이어 이후에는 930차원 벡터가 생성되어 원래 특성으로 재매핑하기가 어려워집니다. 그럼에도 불구하고, 이전에 언급된 선형 항으로 주어진 선형 처리 후 각 스트림의 출력의 절대값을 추출함으로써 각 스트림의 중요성을 이해해 볼 수 있습니다.\n\n이를 위해 InteractionAggregation 모듈을 변경하고 각 단계 후에 선형 변환된 값 추출을 위해 다음 코드 라인을 추가해야 합니다:\n\n```js\n...     \n    self.x_importance = []\n    self.y_importance = []\n  def forward(self, x, y):\n          self.x_importance.append(torch.sum(torch.abs(self.w_x(x))))\n          self.y_importance.append(torch.sum(torch.abs(self.w_y(y))))\n...\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n한 번 훈련을 받으면, 각 스트림의 선형 변환 결과에서 절대 값을 예측하고 플롯할 수 있습니다. 그림 8에 보여진 것처럼, 상품 스트림이 사용자 스트림보다 중요성이 높습니다. 이는 상품에 대한 기능이 훨씬 많기 때문이지만 사용자 특성이 상당히 일반적이기 때문에 발생합니다.\n\n![이미지](/TIL/assets/img/2024-07-12-FinalMLPASimpleyetPowerfulTwo-StreamMLPModelforRecommendationSystems_9.png)\n\n# 결론\n\n추천 시스템은 사용자 경험을 향상시켜 맞춤형 추천을 제공하며, 성장과 혁신을 이끄는 데이터 기반 의사 결정을 기관에 제공하여 사용자 경험을 향상시킵니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 기사에서는 추천 시스템용으로 개발된 가장 최근 모델 중 하나를 소개했습니다. FinalMLP는 두 개의 독립 네트워크를 가진 딥 러닝 모델입니다. 각 네트워크는 사용자와 항목 이 두 가지 다른 관점 중 하나에 중점을 둡니다. 각 네트워크로부터 학습된 다른 패턴은 그 다음 각 네트워크의 학습 내용을 결합하는 책합층에 공급됩니다. 사용자-항목 쌍 상호 작용의 단일 뷰를 생성하여 최종 점수를 생성합니다. 이 모델은 CatBoost Ranker를 이겼으며 우리의 사용 사례에서 잘 수행했습니다.\n\n알고리즘 선택은 해결하려는 문제와 데이터셋에 따라 다를 수 있음을 유의해 주세요. 항상 여러 방법을 상호 비교하는 것이 좋은 실천 방법입니다. 또한 xDeepFM, AutoInt, DHEN 또는 DLRM을 테스트하는 것도 고려할 수 있습니다.\n\n# 내 소개\n\n인공지능 분야의 시리얼 기업가 및 리더입니다. 비즈니스를 위한 인공지능 제품을 개발하고 인공지능에 초점을 맞춘 스타트업에 투자합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n창립자 @ ZAAI | LinkedIn | X/Twitter\n\n# 참고 문헌\n\n[1] Kelong Mao, Jieming Zhu, Liangcai Su, Guohao Cai, Yuru Li, Zhenhua Dong. FinalMLP: CTR 예측을 위한 향상된 이차원 MLP 모델. arXiv:2304.00902, 2023.\n\n[2] Jiajun Fei, Ziyu Zhu, Wenlei Liu, Zhidong Deng, Mingyang Li, Huanjun Deng, Shuo Zhang. DuMLP-Pin: 집합 특성 추출을 위한 이중-MLP-내적 불변 네트워크. arXiv:2203.04007, 2022.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n[3] Jieming Zhu, Jinyang Liu, Shuai Yang, Qi Zhang, Xiuqiang He. BARS-CTR: Open Benchmarking for Click-Through Rate Prediction. arXiv:2009.05794, 2020.","ogImage":{"url":"/TIL/assets/img/2024-07-12-FinalMLPASimpleyetPowerfulTwo-StreamMLPModelforRecommendationSystems_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-FinalMLPASimpleyetPowerfulTwo-StreamMLPModelforRecommendationSystems_0.png","tag":["Tech"],"readingTime":22},{"title":"범주형 및 수치형 데이터를 위한 Gower 거리 설명","description":"","date":"2024-07-12 20:33","slug":"2024-07-12-GowersDistanceforMixedCategoricalandNumericalData","content":"\n\n# 거리 측정이란 무엇인가요?\n\n아마도 맨해튼 거리 또는 유클리드 거리에 대해 들어보았을 것입니다. 이들은 두 주어진 데이터 포인트가 얼마나 멀리 떨어져 있는지 (또는 얼마나 다른지)에 대한 정보를 제공하는 두 가지 다른 측정 기준입니다.\n\n![image](/TIL/assets/img/2024-07-12-GowersDistanceforMixedCategoricalandNumericalData_0.png)\n\n간단히 말해서, 유클리드 거리는 점 A에서 점 B까지의 최단 거리입니다. 맨해튼 거리는 x와 y 좌표 간의 절대적인 차이들의 합을 계산하고, 대각선 방향으로 움직일 수 없고 위, 아래, 왼쪽 또는 오른쪽으로만 이동할 수 있는 격자 상에 위치한 것처럼 두 점 사이의 거리를 찾습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n거리 측정 항목은 종종 k-평균 클러스터링과 같은 클러스터링 알고리즘의 기초를 이룹니다. 이 알고리즘은 유클리드 거리를 사용합니다. 데이터 포인트 간의 유사성 또는 차이를 먼저 알아야 하므로 이 점이 타당합니다.\n\n## 2점 사이의 거리 계산하기\n\n이 프로세스를 보여주기 위해 유클리드 거리를 사용한 예제를 통해 시작하겠습니다.\n\n![image](/TIL/assets/img/2024-07-12-GowersDistanceforMixedCategoricalandNumericalData_1.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위에 그린 차트를 사용하면 점 A의 좌표가 (50,50)이고 점 B의 좌표가 (300,500)이라고 가정해 봅시다:\n\n```js\nd(A,B) = sqrt ((300-50)^2 + (500-50)^2))\nd(A,B) = sqrt (62,500 + 202,500)\nd(A,B) ≈ 514.78\n```\n\n정말 간단하죠. 이제 Python 데이터 세트에서 데이터프레임을 사용하여 2개의 데이터 포인트(행) 사이에 유사도 점수를 계산하고 싶다면 어떻게 해야 할지 살펴봅시다.\n\n## 인구 조사 데이터에서의 거리 (Distances in Census Income data)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n앞으로 제 모든 예시를 설명하는 데에 UCI Machine Learning Repository에서 제공하는 인구 조사 소득 데이터 세트 (CC BY 4.0)를 사용할 것입니다.\n\n이 데이터 세트는 다양한 인구 특징(나이, 인종, 성별, 직업 등)와 개인이 '$50K 미만' 또는 '$50K 이하'의 소득을 갖고 있는지를 나타내는 바이너리 대상 변수를 가지고 있는 분류 데이터 세트입니다.\n\n이 데이터 세트를 통계 작업에 사용하지는 않겠지만, 유사한 특징을 가진 데이터 포인트 간에는 타겟 변수에 대한 유사성도 보일 수 있기 때문에 거리 측정 지표를 시연하는 데 좋은 예시가 됩니다.\n\n이 데이터를 직접 가져오려면 다음 코드를 실행하세요:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nfrom ucimlrepo import fetch_ucirepo\n\n# 데이터셋 불러오기\ncensus_income = fetch_ucirepo(id=20)\n\n# 데이터 (판다스 데이터프레임 형태)\nX = census_income.data.features\ny = census_income.data.targets\n\n# 변수 정보\nprint(census_income.variables)\n```\n\n이 데이터셋에 포함된 특성 변수 중 하나는 \"나이(Age)\"입니다. 이 경우 나이는 17세에서 90세까지의 숫자 변수입니다. 다른 숫자 변수로는 \"자본이득(Capital gains)\"이 있습니다. 이 두 변수는 사람의 총 소득과 관련이 깊을 것으로 예상됩니다.\n\n이제 이 두 열을 가지고 데이터 포인트/행에 대한 거리 추정을 얻을 수 있는지 확인해 봅시다.\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-GowersDistanceforMixedCategoricalandNumericalData_2.png\" /\u003e\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 두 데이터 포인트 사이의 거리를 찾으려면 위에서 정의한 식에 값을 입력해야 합니다.\n\n각 열은 차원(x 또는 y)이 되고 각 행은 숫자 1 또는 2가 됩니다.\n\n따라서 나이 열은 x가 되고 값(39, 50)은 x1 및 x2가 됩니다. 자본 이득 열은 y1 및 y2 값에 해당합니다.\n\n```js\nd(Row1, Row2) = sqrt((50-39)^2 +\n(2174-0)^2))\n\nd(Row1, Row2) = 2174.027\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n총 이동 거리가 자본 이득 열의 차이와 거의 동일한 것을 알 수 있습니다. 이는 값의 연령 범위가 값의 자본 이익 범위보다 훨씬 작기 때문입니다. 따라서 경우에 따라 유클리드 거리를 계산하기 전에 StandardScaler와 같은 것을 사용하여 데이터를 스케일링해야 할 수도 있습니다.\n\n# Gower 거리: 방정식에 범주형 변수 추가\n\n이제 만약 이 첫 번째 두 데이터 포인트 사이의 거리를 계산하려면 “workclass”와 “education”과 같은 범주형 변수도 포함해서 어떻게 해야 할까요?\n\n여기서 Gower 거리가 중요합니다. Gower 거리는 숫자형 및 범주형 특성에 대해 서로 다른 거리 계산을 수행하여 특성간 유사성의 가중 평균을 취하여 2개 데이터 포인트 사이의 점수를 계산합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2가지 범주형 특성 간 유사도 점수를 계산할 때, 식은 매우 간단합니다. 값이 동일한 경우 점수는 1입니다. 다른 경우에는 점수가 0입니다.\n\n두 객체(데이터 포인트) i와 j를 비교할 때, 수치/연속적인 특성 k를 비교하는 경우, 유사도 점수는 다음과 같습니다:\n\n\\[ \\frac{|x_{ik} - x_{jk}|}{R(k)} \\]\n\n여기서 R(k)는 특성 k의 범위를 나타냅니다. 값의 차이의 절대값은 범위로 나눠줌으로써 특성을 정규화하고 0과 1 사이의 값으로 얻습니다. (이는 매우 큰 값이 포함된 특성이 방정식을 지배하는 문제를 해결하는 데 도움이 될 것입니다.)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 각 feature에 대한 점수가 있으므로, p개의 feature가 있는 두 개의 객체 i와 j에 대한 전체 Gower 거리가 계산됩니다:\n\n\n… where w(ijk) is the weight for that feature (Default is 1).\n\n\n## Python 구현\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파이썬 구현은 배열 내 모든 객체를 서로 비교하여 Gower 거리를 반환하는 행렬을 생성합니다.\n\n파이썬에서 이 작업이 어떻게 이루어지는지 보시려고 작은 예제를 소개하겠습니다. 그리고 이것이 대규모 데이터셋에서 어떻게 작동하는지 살펴보겠습니다.\n\n```python\n# 먼저 \"pip install gower\"를 실행했다고 가정합니다.\nimport gower\nimport numpy as np\n\n# 특성 정의\nfeatures = ['age', 'capital-gain', 'education', 'workclass']\n\n# workclass 열에 일부 누락된 데이터가 \"?\" 형태로 포함되어 있기 때문에\n# 이를 먼저 제거했습니다.\nX = X.loc[X['workclass']!='?']\n\n# 가능한 다른 열에서는 널 값을 제거하고 인덱스를 재설정했습니다.\nX.dropna(inplace=True)\nX.reset_index(inplace=True)\n\n# 정의된 특성만 선택합니다.\nX = X[features]\n\n# 처음 2개 행만 포함하는 작은 데이터프레임 생성\n# 이 두 행을 Gower 거리를 사용하여 비교할 것입니다.\nsmall_X = X.iloc[0:2,:]\n\n# 나이 열을 부동 소수점으로 변환합니다. 왜냐하면 자본 이익은 실수이며,\n# 숫자 열은 동일한 데이터 유형이어야 합니다.\nsmall_X['age'] = small_X['age'].astype(float)\n\n# gower 거리 행렬 생성\n# cat_features는 각 열의 인덱스에 해당하는 목록입니다.\n# 0은 열이 숫자임을 나타내고, 1은 범주형임을 나타냅니다. 처음 2개 열 (나이 및 자본 이익)\n# 는 0으로 표시되고, 마지막 2개 열 (교육, 직업)은 1로 표시됩니다.\ngower.gower_matrix(np.asarray(small_X),cat_features=[0,0,1,1])\n```\n\ngower.gower_matrix를 호출하면 이 배열이 반환됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\narray([[0. , 1.5],\n       [1.5, 0. ]], dtype=float32)\n```\n\n각 요소는 다음을 나타냅니다:\n\n- 요소 [0,0] = 행 1과 행 1 간의 거리 점수\n- 요소 [0,1] = 행 1과 행 2 간의 거리 점수\n- 요소 [1,0] = 행 2와 행 1 간의 거리 점수\n- 요소 [1,1] = 행 2와 행 2 간의 거리 점수\n\n행 1을 행 1과 비교하면 features 측면에서 동일함을 보여주기 때문에 거리는 0으로 표시됩니다. 행 2를 행 2와 비교한 결과도 마찬가지입니다. 행 2를 행 1과 비교하면 행 1을 행 2와 비교했을 때와 동일한 결과가 나오므로 이 요소에서 점수가 동일합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 Gower 거리의 구성 요소를 이해했으니 전체 데이터 세트에 이 gower.gower_matrix 함수를 적용해 봅시다.\n\n```js\n# 참고: 인구조사 데이터 집합은 40,000개 이상의 행이 있습니다. 이 작업은 \n# 계산 비용이 매우 높을 수 있습니다. 저는 제 자신의 코드에서 이 작업을 \n# 첫 5000개 행에 대해서만 실행했지만, 데이터 세트에 따라 다를 수 있습니다.\ngower.gower_matrix(np.asarray(X),cat_features=[0,0,1,1])\n```\n\n이렇게 하면 각 행을 모든 다른 행들과 비교한 Gower 거리 점수 행렬이 반환됩니다.\n\nGower 거리의 효과를 더 테스트하기 위해, 첫 번째 레코드와 가장 유사한 10개 레코드를 해당 특성을 사용하여 찾은 다음, 그들의 대상 값(소득 수준)이 유사한지 확인해 보겠습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 데이터 세트의 첫 번째 행을 가져와 나머지 데이터와 비교합니다. 상위 10개 값의 인덱스를 반환합니다\ngower_topn_index = gower.gower_topn(X.iloc[0:1,:], X.iloc[:,], n = 10)['index']\n\n# 원본 df에서 인덱스를 쿼리합니다\nX.iloc[gower_topn_index]\n```\n\n다음은 제 결과입니다:\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-GowersDistanceforMixedCategoricalandNumericalData_5.png\" /\u003e\n\n여기서 첫 번째 레코드와 가장 유사한 레코드는 해당 레코드 자체입니다. 이는 Gower가 각각의 레코드를 모든 레코드와 비교하기 때문입니다. 레코드 1과 가장 유사한 상위 n개의 레코드를 가져오고 레코드 1을 제외한 결과를 얻고 싶다면, 초기에 상위 n+1을 가져와 X.iloc[gower_topn_index][1:]를 쿼리하면 해당 최상위 레코드를 결과에서 제외시킬 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 y.loc[gower_topn_index]을 호출하면, 첫 번째 행에 대한 가장 유사한 상위 10개 레코드의 대응하는 타겟 값을 볼 수 있습니다.\n\n![image](/TIL/assets/img/2024-07-12-GowersDistanceforMixedCategoricalandNumericalData_6.png)\n\n여기서 가장 유사한 상위 10개 레코드 중에서 9개 중 6개가 첫 번째 레코드의 수입(≤50K)과 일치했음을 볼 수 있습니다. 9개 중 3개만 일치하지 않고 '50K'를 만들었습니다. 이것은 우리가 4가지 기능만 가지고 있었기 때문에 꽤 괜찮은 결과입니다!\n\n## 기억해 둘 사항\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다른 기계 학습 알고리즘과 마찬가지로 특성을 추가할수록 Gower metric의 정확도가 높아질 것으로 예상됩니다. 이는 레코드가 더욱 유사해진다는 것을 의미합니다. 이때 주의할 점은 범주형 특성이 종종 (연속 값이 아니라 0 또는 1이 될 것이기 때문에 0과 1 사이의 연속적인 값보다) 수치적 특성보다 더욱 중요하다는 것입니다.\n\n이를 균형있게 유지하기 위해 수치적 특성에 더 높은 가중치를 부여하여 실험할 수 있습니다 (weight 인자를 사용).\n\nweight 인자는 cat_features 인자와 유사하게 작동합니다. 여러분은 목록을 전달하고 각 열에 대해 가중치를 지정합니다. 예를 들어 weight = [2, 2, 1, 1]로 설정하면 수치적인 나이와 자본 이득이 포함된 처음 2개 열이 (마지막 2개 범주형 특성보다 최종 거리 공식에서 두 배 높이 가중됩니다.\n\n## 결론\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위에서 볼 수 있듯이, 고워 거리는 혼합 데이터 유형의 기능을 포함하는 두 개체 간의 거리를 계산하는 강력한 메트릭입니다. 이는 단순히 가장 유사한 레코드를 찾는 것에서부터 클러스터링 알고리즘에 사용될 때까지 다양한 용도가 있습니다. 더 많은 정보와 예제는 여기에서 찾을 수 있습니다.\n\n## 읽어 주셔서 감사합니다","ogImage":{"url":"/TIL/assets/img/2024-07-12-GowersDistanceforMixedCategoricalandNumericalData_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-GowersDistanceforMixedCategoricalandNumericalData_0.png","tag":["Tech"],"readingTime":11}],"page":"19","totalPageCount":41,"totalPageGroupCount":3,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"19"},"buildId":"o6AmBAY_j9v9JmbaRA39X","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>