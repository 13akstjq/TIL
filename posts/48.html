<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>TIL</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//posts/48" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="TIL" data-gatsby-head="true"/><meta property="og:title" content="TIL" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//posts/48" data-gatsby-head="true"/><meta name="twitter:title" content="TIL" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/7d7290728862aada.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/7d7290728862aada.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/873-eb138c3217d71553.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/posts/%5Bpage%5D-de1dc5579188f9be.js" defer=""></script><script src="/TIL/_next/static/olPs1cVezSGTqD7OaewDI/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/olPs1cVezSGTqD7OaewDI/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="최신 파이썬 멀티페이지 Streamlit 애플리케이션으로 올림픽 결과 분석하는 방법" href="/TIL/post/2024-07-06-ATimelyPythonMulti-pageStreamlitApplicationonOlympicResults"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="최신 파이썬 멀티페이지 Streamlit 애플리케이션으로 올림픽 결과 분석하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-06-ATimelyPythonMulti-pageStreamlitApplicationonOlympicResults_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="최신 파이썬 멀티페이지 Streamlit 애플리케이션으로 올림픽 결과 분석하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">최신 파이썬 멀티페이지 Streamlit 애플리케이션으로 올림픽 결과 분석하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 6, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="일상에서 유용한 놀라운 17가지 Python 자동화 스크립트" href="/TIL/post/2024-07-06-17MindblowingPythonAutomationScriptsIUseEveryday"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="일상에서 유용한 놀라운 17가지 Python 자동화 스크립트" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-06-17MindblowingPythonAutomationScriptsIUseEveryday_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="일상에서 유용한 놀라운 17가지 Python 자동화 스크립트" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">일상에서 유용한 놀라운 17가지 Python 자동화 스크립트</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 6, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Django 앱 사이에서 모델을 이동하는 방법" href="/TIL/post/2024-07-06-HowToMoveAModelFromOneDjangoAppToAnother"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Django 앱 사이에서 모델을 이동하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-06-HowToMoveAModelFromOneDjangoAppToAnother_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Django 앱 사이에서 모델을 이동하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Django 앱 사이에서 모델을 이동하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 6, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="아직 FastAPI를 프로덕션에 사용하면 안 되는 이유" href="/TIL/post/2024-07-06-ThisisWhyFastAPIisNOTProduction-ReadyYet"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="아직 FastAPI를 프로덕션에 사용하면 안 되는 이유" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-06-ThisisWhyFastAPIisNOTProduction-ReadyYet_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="아직 FastAPI를 프로덕션에 사용하면 안 되는 이유" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">아직 FastAPI를 프로덕션에 사용하면 안 되는 이유</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 6, 2024</span><span class="PostList_reading_time__6CBMQ">17<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="구글 Python 팀 전원 해고, Flutter 팀도 위기 직면" href="/TIL/post/2024-07-06-GooglePythonTeamEntirelyLaidOffFlutterTeamAlsoFacingtheAxe"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="구글 Python 팀 전원 해고, Flutter 팀도 위기 직면" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-06-GooglePythonTeamEntirelyLaidOffFlutterTeamAlsoFacingtheAxe_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="구글 Python 팀 전원 해고, Flutter 팀도 위기 직면" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">구글 Python 팀 전원 해고, Flutter 팀도 위기 직면</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 6, 2024</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="1921680024 이해하기 - 30초만에 설명" href="/TIL/post/2024-07-06-The24in1921680024Explainedin30Seconds"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="1921680024 이해하기 - 30초만에 설명" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-06-The24in1921680024Explainedin30Seconds_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="1921680024 이해하기 - 30초만에 설명" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">1921680024 이해하기 - 30초만에 설명</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 6, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="무료로 배우는 Nvidia 최신 기술 2024" href="/TIL/post/2024-07-06-LearnforfreefromNvidia"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="무료로 배우는 Nvidia 최신 기술 2024" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-06-LearnforfreefromNvidia_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="무료로 배우는 Nvidia 최신 기술 2024" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">무료로 배우는 Nvidia 최신 기술 2024</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 6, 2024</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="제로 투 마스터리 아카데미 2024 세일 정보" href="/TIL/post/2024-07-06-ZerotoMasteryAcademySALE2024"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="제로 투 마스터리 아카데미 2024 세일 정보" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-06-ZerotoMasteryAcademySALE2024_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="제로 투 마스터리 아카데미 2024 세일 정보" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">제로 투 마스터리 아카데미 2024 세일 정보</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 6, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="AutoGluon으로 AutoML 시작하기 4줄 코드로 완료하는 ML 워크플로우" href="/TIL/post/2024-07-06-AutoMLwithAutoGluonMLworkflowwithJustFourLinesofCode"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="AutoGluon으로 AutoML 시작하기 4줄 코드로 완료하는 ML 워크플로우" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-06-AutoMLwithAutoGluonMLworkflowwithJustFourLinesofCode_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="AutoGluon으로 AutoML 시작하기 4줄 코드로 완료하는 ML 워크플로우" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">AutoGluon으로 AutoML 시작하기 4줄 코드로 완료하는 ML 워크플로우</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 6, 2024</span><span class="PostList_reading_time__6CBMQ">30<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바스크립트와 파이썬의 비동기 프로그래밍 비교 어떤 언어가 더 나을까" href="/TIL/post/2024-07-06-AsyncProgramminginJavaScriptvsPython"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바스크립트와 파이썬의 비동기 프로그래밍 비교 어떤 언어가 더 나을까" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-06-AsyncProgramminginJavaScriptvsPython_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바스크립트와 파이썬의 비동기 프로그래밍 비교 어떤 언어가 더 나을까" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">자바스크립트와 파이썬의 비동기 프로그래밍 비교 어떤 언어가 더 나을까</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 6, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/TIL/posts/41">41</a><a class="link" href="/TIL/posts/42">42</a><a class="link" href="/TIL/posts/43">43</a><a class="link" href="/TIL/posts/44">44</a><a class="link" href="/TIL/posts/45">45</a><a class="link" href="/TIL/posts/46">46</a><a class="link" href="/TIL/posts/47">47</a><a class="link" href="/TIL/posts/48">48</a><a class="link" href="/TIL/posts/49">49</a><a class="link" href="/TIL/posts/50">50</a></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"최신 파이썬 멀티페이지 Streamlit 애플리케이션으로 올림픽 결과 분석하는 방법","description":"","date":"2024-07-06 10:27","slug":"2024-07-06-ATimelyPythonMulti-pageStreamlitApplicationonOlympicResults","content":"\n/assets/img/2024-07-06-ATimelyPythonMulti-pageStreamlitApplicationonOlympicResults_0.png\n\nStreamlit은 데이터 과학자들이 쉽게 대화형 웹 애플리케이션을 만들 수 있도록 하는 오픈 소스 응용 프로그램 프레임워크입니다.\n\n파이썬 몇 줄만 사용하면 데이터 스크립트를 공유 가능한 웹 앱으로 변환할 수 있습니다.\n\nPlotly와 같은 데이터 시각화 라이브러리와 결합하면 몇 줄의 코드로 아름다운 차트와 지도를 만들 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 글에서는 Streamlit을 사용하여 올림픽 메달 데이터를 시각화하는 멀티페이지 대화형 애플리케이션을 만드는 방법을 안내하겠습니다.\n\n이 애플리케이션은 세 가지 페이지로 구성될 것입니다:\n\n- 메달 수에 대한 개요,\n- 특정 국가 분석, 그리고\n- 전 세계 메달 분포를 보여주는 코로플레스 맵.\n\n시작해봅시다!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 데이터 세트\n\n이 작업을 수행하는 데 사용된 데이터는 \"국가별 올림픽 메달\" 데이터 세트입니다. Kaggle에서 이용할 수 있습니다.\n\n이 데이터 세트에는 연도, 국가 및 \"Gold\", \"Silver\" 및 \"Bronze\" 메달의 수가 포함되어 있습니다. 데이터 세트의 처음 15행을 캡처한 화면은 다음과 같습니다:\n","ogImage":{"url":"/assets/img/2024-07-06-ATimelyPythonMulti-pageStreamlitApplicationonOlympicResults_0.png"},"coverImage":"/TIL/assets/img/2024-07-06-ATimelyPythonMulti-pageStreamlitApplicationonOlympicResults_0.png","tag":["Tech"],"readingTime":2},{"title":"일상에서 유용한 놀라운 17가지 Python 자동화 스크립트","description":"","date":"2024-07-06 10:26","slug":"2024-07-06-17MindblowingPythonAutomationScriptsIUseEveryday","content":"\n## 해야 할 자동화 스크립트 (컬렉션)\n\n/assets/img/2024-07-06-17MindblowingPythonAutomationScriptsIUseEveryday_0.png\n\n저는 거의 5년 동안 Python을 사용해왔는데, 아직도 저를 끌어들이고 더 많은 연구에 동기를 부여하는 것은 Python의 자동화 기능입니다. 지난 1년 동안 저는 Python의 자동화 부분을 탐험해 왔고, 놀라운 Python 패키지, 사실, 흥미로운 스크립트를 발견했습니다. 이 블로그에서는 저가 매일 사용하며 제 생산성과 성능을 향상시킨 여러 자동화 스크립트를 공유하겠습니다.\n\n# 1. Speakify\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n책을 좋아하지만 혼자 읽는 것은 싫어해요. 대신에 책을 듣는 걸 좋아해요. 이 자동화 스크립트는 정말 생명 구조자인데요. PDF 파일을 듣기 위해 많이 사용해요.\n\n```js\nimport PyPDF2\nimport pyttsx3\n\n# PDF 파일 열기 (PDF 파일 경로 입력)\nfile = open('story.pdf', 'rb')\nreadpdf = PyPDF2.PdfReader(file)\n\n# 텍스트 음성 변환 엔진 초기화\nspeaker = pyttsx3.init()\nrate = speaker.getProperty('rate')   # 현재 말하는 속도 가져오기\nspeaker.setProperty('rate', 200)\n\nvolume = speaker.getProperty('volume')\nspeaker.setProperty('volume', 1)  # 볼륨 설정 (0.0 ~ 1.0)\n\n# 가져오고…\n```\n","ogImage":{"url":"/assets/img/2024-07-06-17MindblowingPythonAutomationScriptsIUseEveryday_0.png"},"coverImage":"/TIL/assets/img/2024-07-06-17MindblowingPythonAutomationScriptsIUseEveryday_0.png","tag":["Tech"],"readingTime":2},{"title":"Django 앱 사이에서 모델을 이동하는 방법","description":"","date":"2024-07-06 10:26","slug":"2024-07-06-HowToMoveAModelFromOneDjangoAppToAnother","content":"\n/assets/img/2024-07-06-HowToMoveAModelFromOneDjangoAppToAnother_0.png\n\n소프트웨어 개발자로서, 때로는 Django 모델을 한 앱에서 다른 앱으로 옮기는 도전에 직면할 수 있습니다. 이 작업을 수행하는 여러 가지 방법이 있지만, 여기서는 가장 쉬운 방법에 대해 이야기하겠습니다. 이 방법은 다운타임 없이 데이터 손실 없이 진행됩니다.\n\n여기서는 Django 수준의 변경만을 다루며, 데이터베이스 상태는 전혀 변경되지 않습니다.\n\n공용 앱에서 사용자 앱으로 고객 모델을 이전하는 예시가 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 초기 모델 구조를 고려하십시오\n\ncommon/models.py 파일에는 Customer 모델이 포함되어 있습니다.\n\n```python\nfrom django.db import models\n\nclass Customer(models.Model):\n  class Meta:\n    app_label = \"common\"\n    db_table = \"common_customer\"\n\n  first_name = CleanCharField(max_length=30, null=False)\n  last_name = CleanCharField(max_length=150, null=False)\n  email = models.EmailField(null=False)\n  address = models.ForeignKey('common.Address', on_delete=models.SET_NULL, null=True, blank=True, default=None)\n\n  def __str__(self) -\u003e str:\n    return f\"{self.first_name} {self.last_name}\"\n```\n\n## 이제 모델을 새 앱으로 이동하세요\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\ncommon/models.py 파일에서 Customer 모델을 잘라내어 users/models.py 파일에 붙여넣으세요.\n\n```js\nfrom django.db import models\n\nclass Customer(models.Model):\n  class Meta:\n    app_label = \"users\"\n    db_table = \"common_customer\"\n\n  first_name = CleanCharField(max_length=30, null=False)\n  last_name = CleanCharField(max_length=150, null=False)\n  email = models.EmailField(null=False)\n  address = models.ForeignKey('common.Address', on_delete=models.SET_NULL, null=True, blank=True, default=None)\n\n  def __str__(self) -\u003e str:\n    return f\"{self.first_name} {self.last_name}\"\n```\n\n- app_label 매개변수를 users로 변경하세요.\n- 데이터베이스 테이블 이름을 변경하지 않으므로 db_table 매개변수를 common_customer로 유지하세요.\n\n## 데이터베이스 마이그레이션 생성\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 이 명령어를 실행하여 마이그레이션 파일을 생성하세요.\n\n```js\npython manage.py makemigrations\n```\n\n이 명령어를 실행하면 2개의 마이그레이션 파일이 생성됩니다.\n\n- 하나는 공통 앱에서 모델을 삭제하는 것입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nfrom django.db import migrations\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        # Dependencies\n    ]\n\n    operations = [\n        migrations.DeleteModel(\n            name='Customer',\n        ),\n    ]\n```\n\n- 사용자 앱에서 모델을 생성하세요.\n\n```js\nfrom django.db import migrations, models\nimport django.db.models.deletion\nimport django_utils.models.base\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        # Dependencies\n    ]\n\n    operations = [\n        migrations.CreateModel(\n            name='Customer',\n            fields=[\n                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),\n                ('first_name', django_utils.models.base.CleanCharField(max_length=30)),\n                ('last_name', django_utils.models.base.CleanCharField(max_length=150)),\n                ('email', models.EmailField(max_length=254)),\n                ('address', models.ForeignKey(blank=True, default=None, null=True, on_delete=django.db.models.deletion.SET_NULL, to='common.address')),\n            ],\n            options={\n                'db_table': 'common_customer',\n            },\n        ),\n    ]\n```\n\n## 데이터 손실을 방지하세요.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 데이터베이스 테이블 이름을 변경하지 않았기 때문에 여전히 common_customer 테이블입니다.\n- 데이터베이스에 DeleteModel 작업이 적용되지 않도록 해야 합니다.\n- DeleteModel 작업을 SeparateDatabaseAndState으로 감싸주세요. 이렇게 수정된 최종 마이그레이션 파일은 common 앱에서 다음과 같이 보여야 합니다:\n\n```js\nfrom django.db import migrations\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        # 의존성\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.DeleteModel(\n                    name='Customer',\n                ),\n            ]\n        )\n    ]\n```\n\n- 이미 데이터베이스에 테이블이 존재하기 때문에 다시 만들 필요가 없습니다.\n- 데이터베이스에 CreateModel 작업이 적용되지 않도록 해야 하며, 그렇지 않으면 오류가 발생합니다.\n- CreateModel 작업을 SeparateDatabaseAndState으로 감싸주세요. 이렇게 수정된 최종 마이그레이션 파일은 usersapp에서 다음과 같이 보여야 합니다:\n\n```js\nfrom django.db import migrations, models\nimport django.db.models.deletion\nimport django_utils.models.base\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        # 의존성\n    ]\n\n    operations = [\n        migrations.SeparateDatabaseAndState(\n            state_operations=[\n                migrations.CreateModel(\n                    name='Customer',\n                    fields=[\n                        ('id',\n                         models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),\n                        ('first_name', django_utils.models.base.CleanCharField(max_length=30)),\n                        ('last_name', django_utils.models.base.CleanCharField(max_length=150)),\n                        ('email', models.EmailField(max_length=254)),\n                        ('address', models.ForeignKey(blank=True, default=None, null=True,\n                                                      on_delete=django.db.models.deletion.SET_NULL,\n                                                      to='common.address')),\n                    ],\n                    options={\n                        'db_table': 'common_customer',\n                    },\n                ),\n            ]\n        )\n    ]\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 마이그레이션 적용\n\n변경 사항을 적용하기 위해 마이그레이션을 실행하세요\n\n```js\npython manage.py migrate\n```\n\n성공적으로 공통 앱에서 사용자 앱으로 Customer 모델을 이동했고, 데이터베이스 변경이나 데이터 손실 없이 처리되었습니다. 완료되었습니다!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n알림: 이 방법은 매우 안전하지만 데이터베이스 작업을 수행하기 전에 데이터베이스를 백업하는 것이 좋습니다 (이 문서에서는 데이터베이스 변경을 수행하지 않지만 마이그레이션 작업을 수행하고 있습니다). 특히 프로덕션 환경에서는 항상 백업을 권장합니다.\n\n## 연락처를 유지합시다:\n\n질문, 제안 또는 개선 사항이 있으시면 연락해 주세요.\n\n- Github → https://github.com/shwetasinghh\n- LinkedIn → https://www.linkedin.com/in/shweta-singh-200280117/\n","ogImage":{"url":"/assets/img/2024-07-06-HowToMoveAModelFromOneDjangoAppToAnother_0.png"},"coverImage":"/TIL/assets/img/2024-07-06-HowToMoveAModelFromOneDjangoAppToAnother_0.png","tag":["Tech"],"readingTime":8},{"title":"아직 FastAPI를 프로덕션에 사용하면 안 되는 이유","description":"","date":"2024-07-06 10:24","slug":"2024-07-06-ThisisWhyFastAPIisNOTProduction-ReadyYet","content":"\n# 요약\n\n현대 웹 개발에서 효율적으로 종속 항목을 관리하는 것이 확장 가능하고 유지 관리 가능한 애플리케이션을 만드는 데 중요합니다. 의존성 주입(Dependency Injection, DI) 및 제어의 역전(Inversion of Control, IoC)은 이 요구를 해결하는 두 가지 디자인 원칙입니다. 본 문서에서는 DI와 IoC가 두 가지 인기 있는 Python 프레임워크인 FastAPI 및 PyNest에서 어떻게 구현되는지 알아봅니다. 우리는 두 프레임워크를 소개하고, DI에 대한 접근 방식을 자세히 살펴보며, 다음 프로젝트에 최적인 선택을 도와줄 종합적인 비교를 제공할 것입니다.\n\n/assets/img/2024-07-06-ThisisWhyFastAPIisNOTProduction-ReadyYet_0.png\n\n# FastAPI 소개\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nFastAPI은 표준 Python 타입 힌트를 기반으로 하는 Python 3.7+용 현대적이고 빠른 웹 프레임워크입니다. OpenAPI와 JSON Schema의 자동 생성 기능을 제공하여 API를 빠르고 효율적으로 만드는 데 매우 편리합니다. FastAPI의 DI(Dependency Injection) 접근 방식은 내장되어 있으며, Python의 타입 힌트를 활용하여 의존성을 원활하게 주입합니다.\n\n# FastAPI의 DI(Dependency Injection) 접근 방식\n\nFastAPI에서는 의존성 주입이 함수 시그니처 내의 Depends 키워드를 사용하여 처리됩니다. 이는 FastAPI에게 의존성 함수를 호출하도록 지시하고 해당 매개변수의 인수 값으로 결과를 사용하도록 합니다.\n\n## 예시: FastAPI 의존성 주입\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nfrom fastapi import Depends, FastAPI\n\napp = FastAPI()\n\n# 의존성 함수\nasync def common_parameters(q: str = None, skip: int = 0, limit: int = 100):\n    return {\"q\": q, \"skip\": skip, \"limit\": limit}\n\n# 해당 의존성을 사용하는 라우트\n@app.get(\"/items/\")\nasync def read_items(commons: dict = Depends(common_parameters)):\n    return commons\n```\n\n이 예에서 `common_parameters`은 `/items/` 라우트에 접근할 때마다 실행되는 의존성 함수입니다.\n\n## 의존성 주입에서의 중복성\n\nFastAPI는 각 라우트의 함수 수준에서 의존성이 주입되어야 합니다. 여러 라우트가 동일한 의존성을 필요로 하는 경우 각 라우트 핸들러 함수에 별도로 주입해야 합니다. 특히 많은 수의 라우트와 공유 의존성이 있는 응용 프로그램에서 반복적이고 장황한 코드로 이어질 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 예제\n\n```js\nfrom fastapi import Depends, FastAPI\n\napp = FastAPI()\n\n# 의존성\nclass Logger:\n    def __init__(self):\n        print(\"로거 시작\")\n        time.sleep(2)\n        print(f\"로거 시작됨 - {self}\")\n\n    def log(self, message):\n        print(f\"로깅 - {message}\")\n\n\n# 동일한 의존성을 주입하는 여러 라우트\n@app.get(\"/items/\")\nasync def read_items(logger: Annotated[Logger, Depends(Logger)]):\n    logger.log(\"아이템 목록\")\n    return {\"message\": \"아이템\"}\n\n@app.post(\"/items/\")\nasync def create_item(logger: Annotated[Logger, Depends(Logger)]):\n    logger.log(\"아이템 생성 중\")\n    return {\"message\": \"아이템 생성됨\"}\n```\n\n새로운 DB가 필요한 모든 새로운 라우트에서 우리는 DB를 명시적으로 주입해야 합니다. 약간 크게 확장해보면 모든 라우트가 공유된 로거, 공유된 설정, 그리고 DB 연결을 주입해야 한다고 상상해보면, 같은 코드를 계속 반복해서 작성해야 하는 상황이 생길 것입니다.\n\n# FastAPI에서 클래스 의존성 주입하기\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nFastAPI 루트에서 단일 및 여러 종속성을 주입하고 모든 호출마다 객체를 재설정하는 문제를 탐색해 보는 시나리오를 살펴봅시다.\n\n단일 종속성 주입 - 이 예시에서는 API 루트로 주입될 Logger 객체를 만듭니다.\n\n```python\nfrom fastapi import FastAPI, Depends\nimport time\n\napp = FastAPI()\n\nclass Logger:\n    def __init__(self):\n        print(\"Logger Starting\")\n        time.sleep(2)\n        print(f\"Logger Started at - {self}\")\n        self.params = {}\n\n    def log(self, message):\n        print(f\"Logging - {message}\")\n\n@app.get(\"/\")\ndef get(logger: Logger = Depends(Logger)):\n    logger.log(\"Endpoint hit\")\n    return \"Logger works\"\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n```\n\n출력:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n로그 출력 시작\n로그 출력 시작 위치 - \u003cmain.Logger object at 0x102f3ddf0\u003e\n로그 - 엔드포인트 요청\n정보: 127.0.0.1:64670 - \"GET / HTTP/1.1\" 200 OK\n\n로그 출력 시작\n로그 출력 시작 위치 - \u003cmain.Logger object at 0x102f3dbe0\u003e\n로그 - 엔드포인트 요청\n정보: 127.0.0.1:64670 - \"GET / HTTP/1.1\" 200 OK\n\n로그 출력 시작\n로그 출력 시작 위치 - \u003cmain.Logger object at 0x102f3dbb0\u003e\n로그 - 엔드포인트 요청\n정보: 127.0.0.1:64670 - \"GET / HTTP/1.1\" 200 OK\n\n위의 결과를 살펴보겠습니다. 애플리케이션의 루트 경로에 접속하려고 할 때, 로거 객체가 초기화되고 \"0x102f3ddf0\" 위치로 설정되었음을 볼 수 있습니다. 그런 다음 두 번째로 동일한 경로에 액세스하면 로거 객체가 다시 초기화됩니다. 이 때는 다른 메모리 위치에 설정됩니다. 루트 경로를 호출할 때마다 로거 초기화에 2초의 대기 시간이 소요됩니다.\n\n그렇다면 로거에 의존하는 서비스가 필요한 경우 어떻게 될까요?\n\nfrom fastapi import FastAPI, Depends\nimport time\nimport random\n\nclass Logger:\ndef **init**(self):\nprint(\"로그 출력 시작\")\ntime.sleep(2)\nprint(f\"로그 출력 시작 위치 - {self}\")\n\n    def log(self, message):\n        print(f\"로그 - {message}\")\n\nclass Service:\ndef **init**(self, logger: Logger = Depends(Logger)):\nself.logger = logger\nprint(\"서비스 시작\")\ntime.sleep(1)\nprint(f\"서비스 시작 위치 - {self}\")\n\n    def 실행(self):\n        self.logger.log(\"어떤 작업을 수행 중\")\n        return f\"작업 수행, {random.random()}\"\n\napp = FastAPI()\n\n@app.get(\"/\")\ndef get(service: Service = Depends(Service)):\nreturn f\"{service.실행()}\"\n\nif **name** == \"**main**\":\nimport uvicorn\nuvicorn.run(app, host=\"0.0.0.0\", port=8000)\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n당연히요! FastAPI 및 IOC 컨테이너에서의 지원 부족은 이 엔드포인트를 호출할 때마다 이미 초기화된 객체들을 초기화하기 위해 3초의 지연 시간을 지불해야 한다는 주된 이유입니다. 이 패턴은 진정한 안티-패턴이며, FastAPI의 약점을 드러낼 수도 있습니다.\n\n이 문제를 해결하려고 수십 시간을 낭비한 후, FastAPI 자체가 그러한 기능을 제공하지 못하며, 새롭고 더 통합적인 접근이 필요하다는 것을 이해했습니다. 그래서 저는 PyNest를 만들게 되었습니다. 이는 의존성 주입과 모듈성에 중점을 둔 Python 메타-프레임워크입니다.\n\n# PyNest: 모듈식 DI 접근 방식\n\nPyNest의 DI 시스템은 반복적인 코드를 줄이고 대규모 애플리케이션에 특히 유용한 개발 프로세스를 간소화하는 데에 디자인되었습니다. PyNest는 의존성이 한 번에 한 번씩 주입되는 구조화된 DI 시스템을 제공하며, 대체로 컨트롤러 클래스 수준에서 이루어집니다. 이 구조는 한 번 의존성이 컨트롤러에 주입되면 더 이상 주입이 필요하지 않고 코드가 재사용되며 DRY 원칙을 준수할 수 있음을 의미합니다. 이 구조를 통해 한 번 의존성이 컨트롤러에 주입되면 더 이상의 주입이 필요 없이 해당 컨트롤러의 모든 경로 메서드에서 사용될 수 있으므로 코드베이스를 간소화할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n/assets/img/2024-07-06-ThisisWhyFastAPIisNOTProduction-ReadyYet_1.png\n\n# 한 번 주입하고 여러 번 사용하기\n\nPyNest의 모듈화된 아키텍처를 사용하면 컨트롤러 클래스의 생성자에 종속성을 주입할 수 있어서 매번 모든 라우트에 종속성을 반복해서 주입할 필요 없이 모든 라우트에서 이 종속성을 사용할 수 있습니다.\n\n예시 —\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nfrom nest.core import Injectable, Controller, Get, Post\n\n@Injectable\nclass Logger:\n    def __init__(self):\n        print(\"Logger Starting\")\n        time.sleep(2)\n        print(f\"Logger Started at - {self}\")\n\n    def log(self, message):\n        print(f\"Logging - {message}\")\n\n\n@Controller(\"items\")\nclass ItemsController:\n\n  # Inject Once\n  def __init__(self, logger: Logger):\n      self.logger = logger\n\n\n  # Use Many\n  @Get(\"/\")\n  async def read_items(self):\n      self.logger.log(\"list of items\")\n      return {\"message\": \"Items\"}\n\n  @Post(\"/{item}\")\n  async def create_item(self, item: str):\n      self.logger.log(\"creating item\")\n      return {\"message\": f\"Item created - {item}\"}\n```\n\n이 모듈화된 접근 방식을 통해 컨트롤러 생성자에 필요한 만큼의 의존성을 주입하고 이러한 의존성을 클래스 메서드에서 액세스할 수 있습니다. 이 결과로 코드가 훨씬 더 깔끔해지며 코드를 다시 작성하거나 복잡하게 만들 필요가 없어집니다.\n\n# 싱글턴 패턴의 힘을 받아들이세요\n\n이전에 논의한 바와 같이, FastAPI의 DI 매커니즘의 가장 큰 단점은 종속성을 관리하기 위해 싱글턴 패턴을 사용하지 않는 것입니다. 우리는 종속성이 모든 들어오는 요청마다 초기화되어야 한다는 것을 관찰했습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nPyNest에서는 현역에서 \"injector\" 라이브러리를 활용합니다. 이 라이브러리는 현대적인 Python 애플리케이션에서 종속성을 관리하기 위한 패키지입니다. injector은 싱글톤 패턴과 멀티 바인딩을 지원합니다. 클래스가 Injectable로 표시되어 종속성으로 등록되면, injector는 해당 클래스의 인스턴스를 생성하고 그 참조를 저장합니다. 이 injectable 객체에 대한 모든 호출은 injector를 통해 이루어지며, injectable 객체의 싱글톤 인스턴스를 반환합니다.\n\n## 코드로 살펴보기\n\n먼저, PyNest에서 모든 관련 import문을 정리해 봅시다\n\n```python\nimport logging\nimport os\n\nfrom nest.core import (\n    Controller,\n    Delete,\n    Get,\n    Injectable,\n    Module,\n    Post,\n    Put,\n    PyNestFactory,\n)\nimport time\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음으로 주입하려는 두 개의 제공자와 로직 레이어를 포함하는 주요 서비스를 선언할 것입니다.\n\n```js\n# 구성 제공자\n@Injectable()\nclass ConfigService:\n    def __init__(self):\n        time.sleep(2)\n        print(f\"ConfigService 시작 - {self}\")\n        self.config = os.environ\n\n    def get(self, key: str):\n        return self.config.get(key)\n\n# 로거 제공자\n@Injectable()\nclass Logger:\n    def __init__(self, config_service: ConfigService):\n        time.sleep(2)\n        print(f\"로거 시작 - {self}\")\n        self.config_service = config_service\n        self.log = logging.getLogger(__name__)\n\n# 주요 서비스\n@Injectable()\nclass ItemService:\n    def __init__(self, logger: Logger):\n        time.sleep(2)\n        print(f\"ItemService 시작 - {self}\")\n        self.logger = logger\n        self.items = [{\"item_name\": \"Foo\"}, {\"item_name\": \"Bar\"}, {\"item_name\": \"Baz\"}]\n\n    def get(self):\n        self.logger.log.info(\"엔드포인트 호출됨\")\n        return self.items\n\n    def post(self, item: dict):\n        self.items.append(item)\n        return self.items\n\n    def put(self, item: dict):\n        self.items.append(item)\n        return self.items\n\n    def delete(self, item: dict):\n        self.items.remove(item)\n        return self.items\n```\n\n이제 Controller를 생성하고 서비스에 주입합니다 —\n\n```js\n@Controller(\"items\")\nclass ItemController:\n    def __init__(self, item_service: ItemService):\n        print(\"ItemController 시작 - {self}\")\n        self.item_service = item_service\n\n    @Get(\"/\")\n    def get(self):\n        return self.item_service.get()\n\n    @Post(\"/\")\n    def post(self, item: dict):\n        return self.item_service.post(item)\n\n    @Put(\"/\")\n    def put(self, item: dict):\n        return self.item_service.put(item)\n\n    @Delete(\"/\")\n    def delete(self, item: dict):\n        return self.item_service.delete(item)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n대단해요, 거의 다 왔어요. 이제 앱 모듈을 정의하고 애플리케이션을 실행해 봅시다 -\n\n```js\n@Module(\n    controllers=[ItemController],\n    providers=[Logger],\n)\nclass AppModule:\n    pass\n\n\napp = PyNestFactory.create(AppModule)\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app.http_server, host=\"0.0.0.0\", port=8623)\n```\n\n결과 —\n\n```js\nConfigService starting - \u003c__main__.ConfigService object at 0x10444d580\u003e\nLogger Starting - \u003c__main__.Logger object at 0x10444daf0\u003e\nItemService starting - \u003c__main__.ItemService object at 0x10444d190\u003e\n\nINFO:     Started server process [64770]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\nINFO:     Uvicorn running on http://0.0.0.0:8623 (Press CTRL+C to quit)\n\n\nINFO:     127.0.0.1:63810 - \"GET /items/ HTTP/1.1\" 200 OK\nINFO:     127.0.0.1:63824 - \"PUT /items/ HTTP/1.1\" 200 OK\nINFO:     127.0.0.1:63840 - \"POST /items/ HTTP/1.1\" 200 OK\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n와우! 정말 멋지네요. 우리는 Injectables 객체를 한 번만 초기화하고, 그 이후로는 컨테이너가 해당 객체들의 인스턴스를 관리한다는 것을 알 수 있어요.\n\n/assets/img/2024-07-06-ThisisWhyFastAPIisNOTProduction-ReadyYet_2.png\n\n# PyNest DI 매니페스트\n\n## 주입 가능한 객체\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Injectable-to-Injectable Injection: Injectable 객체는 다른 Injectable 객체를 주입할 수 있어서 일관성 있고 통합된 종속성 계층을 만들 수 있습니다.\n\n## Controllers\n\n- Controller Injection: 컨트롤러는 Injectable 객체를 주입할 수 있어서 필요에 따라 서비스와 리포지토리에 책임을 위임할 수 있습니다.\n\n## Dependency Graph\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 비순환 의존성 그래프: 의존성은 유향 비순환 그래프 (DAG)를 형성해야 합니다. 순환 의존성이 없어야 하며, 이를 통해 처리 가능한 의존성 해결 및 런타임 오류나 무한 루프를 방지할 수 있습니다.\n\n## 의존성 해결과 관리\n\n- 애플리케이션 초기화 과정에서 IoC 컨테이너는 모든 의존성을 해결하고, 아직 등록되지 않은 개체의 인스턴스를 생성하며, 이러한 인스턴스를 관리하여 주입하는 위치에서 제공될 수 있도록 합니다.\n\n## 제공자(Providers) 내보내기\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 모듈은 제공자를 내보낼 수 있으며, 이는 응용 프로그램 내의 다른 모듈에서 사용되거나 주입될 수 있습니다.\n\n## 모듈 간 제공자 주입\n\n- 다른 모듈에서 제공자를 주입하려면 해당 원하는 제공자를 포함하는 모듈을 명시적으로 가져와야 합니다.\n\n## 인스턴스 참조 및 재사용\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 애플리케이션이 삽입된 공급자를 호출하면 이미 초기화된 인스턴스를 참조하여 재사용합니다. 이렇게 함으로써 필요 없는 공급자 인스턴스의 생성을 방지하고 필요할 때 싱글톤과 같은 패턴을 준수합니다.\n\n# 결론: DI에 있어 PyNest가 선호되는 이유\n\nPyNest의 DI 접근 방식은 코드 조직화와 유지 보수 측면에서 명확한 장점을 제공하며, 특히 모듈화 및 반복을 피하는 것이 중요한 대규모 프로젝트에 적합합니다. 응용 프로그램 구조 내에서 더 높은 수준에서 의존성을 주입할 수 있도록 함으로써, PyNest는 보다 DRY(반복하지 마라) 코드베이스를 용이하게 만들어 줌으로써 오류 가능성을 줄이고 리팩터링 및 테스트 프로세스를 간소화합니다.\n\n반면에 FastAPI의 DI 시스템은 각자의 강점을 갖고 있지만, 함수 수준에서의 주입 요구는 불필요하고 중복적인 요소를 도입할 수 있으며, 웹 애플리케이션이 복잡성을 더해감에 따라 유지 보수 및 확장성에서 오히려 역효과를 낼 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 자원\n\n- 비동기 마법: PyNest와 SQLAlchemy 2.0이 파이썬 앱 성능을 25% 향상시킵니다.\n- FastAPI 이상: PyNest를 이용한 2024년 파이썬 마이크로서비스의 진화\n- 의존성 주입 101 - PyNest를 이용한 파이썬 웹 앱의 의존성 주입 단순화\n- PyNest PyPI: https://pypi.org/project/pynest-api\n- 공식 문서: https://pythonnest.github.io/PyNest/\n- GitHub 저장소: https://github.com/PythonNest/PyNest\n\n# 간단하게 설명하기 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 계속하시기 전에:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 글쓴이를 클랩하고 팔로우해주세요! 👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문하기: CoFeed | Differ\n- 더 많은 콘텐츠: PlainEnglish.io\n","ogImage":{"url":"/assets/img/2024-07-06-ThisisWhyFastAPIisNOTProduction-ReadyYet_0.png"},"coverImage":"/TIL/assets/img/2024-07-06-ThisisWhyFastAPIisNOTProduction-ReadyYet_0.png","tag":["Tech"],"readingTime":17},{"title":"구글 Python 팀 전원 해고, Flutter 팀도 위기 직면","description":"","date":"2024-07-06 02:32","slug":"2024-07-06-GooglePythonTeamEntirelyLaidOffFlutterTeamAlsoFacingtheAxe","content":"\n/assets/img/2024-07-06-GooglePythonTeamEntirelyLaidOffFlutterTeamAlsoFacingtheAxe_0.png\n\n지난 주 금요일, 구글의 모회사 알파벳은 올해의 첫 분기 재무 보고서를 발표했습니다. 매출이 697.87억 달러였던 작년 동기 대비 15% 증가한 805.39억 달러를 기록했습니다. 이는 2022년 초 이래 가장 빠른 성장을 나타내며, 흥미로운 사실은 Meta의 주가가 실적 보고 이후 15% 급락한 반면, 구글은 공식적으로 \"2조 클럽\"에 가입했습니다!\n\n/assets/img/2024-07-06-GooglePythonTeamEntirelyLaidOffFlutterTeamAlsoFacingtheAxe_1.png\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n알파벳은 AI에 크게 투자해 왔습니다. 검색 및 각종 서비스에 생성 AI 기능을 통합했습니다. 수익 통화 중에 구글 CEO인 선다르 피차이는 \"AI의 중요한 역할을 강조하며 AI 연구 및 인프라 분야의 선도적인 역할과 전 세계 제품 배포 체계는 다음 AI 혁신의 장을 준비해놓은 상태\"라고 말했습니다.\n\n그런데 AI에 대한 이렇게 확고한 투자를 한 채 구글이 어째서 갑자기 파이썬 인프라팀 전원을 해고했는지 이해하기 어렵네요!\n\n해커뉴스의 한 댓글러가 잘 표현한 대로 이야기하자면: 구글은 AI 중심 회사입니다. 구글의 미래는 AI 제품과 밀접하게 연관되어 있습니다. 모든 AI는...\n","ogImage":{"url":"/assets/img/2024-07-06-GooglePythonTeamEntirelyLaidOffFlutterTeamAlsoFacingtheAxe_0.png"},"coverImage":"/TIL/assets/img/2024-07-06-GooglePythonTeamEntirelyLaidOffFlutterTeamAlsoFacingtheAxe_0.png","tag":["Tech"],"readingTime":1},{"title":"1921680024 이해하기 - 30초만에 설명","description":"","date":"2024-07-06 02:32","slug":"2024-07-06-The24in1921680024Explainedin30Seconds","content":"\n/assets/img/2024-07-06-The24in1921680024Explainedin30Seconds_0.png\n\n저는 지금 직장에서 이 문제를 다루고 있는데, 처음에는 이게 너무 직관적이지 않았어요 (사이버 보안 경험이 제한된 사람으로서)\n\n그래서 여기서 IP 주소에 익숙하지 않은 분들을 위해 최대한 간단하게 설명하려고 해봤어요.\n\n# 192.168.0.0\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n192.168.0.0은 단일 IP 주소입니다. 간단하지요!\n\n# IP 주소에 /와 숫자를 추가하는 방법\n\n- 192.168.0.0/32는 IP 주소 범위입니다.\n- 192.168.0.0/31도 IP 주소 범위입니다.\n- 192.168.0.0/30도 IP 주소 범위입니다.\n- 192.168.0.0/29도 IP 주소 범위입니다.\n- 192.168.0.0/28도 IP 주소 범위입니다.\n- 그리고 그렇게 계속됩니다.\n\n/ 뒤에 붙이는 숫자는 0부터 32까지입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 이 범위 내의 IP를 찾기\n\n먼저 이 범위 내의 IP 주소 개수를 찾아 봅시다.\n\n예를 들어 192.168.0.0/30이 있다고 해봅시다:\n","ogImage":{"url":"/assets/img/2024-07-06-The24in1921680024Explainedin30Seconds_0.png"},"coverImage":"/TIL/assets/img/2024-07-06-The24in1921680024Explainedin30Seconds_0.png","tag":["Tech"],"readingTime":2},{"title":"무료로 배우는 Nvidia 최신 기술 2024","description":"","date":"2024-07-06 02:31","slug":"2024-07-06-LearnforfreefromNvidia","content":"\n/assets/img/2024-07-06-LearnforfreefromNvidia_0.png\n\n제가 20대였을 때를 생각해보면, 새로운 것을 배우려면 좋은 책을 사야 했어요. 하지만 프로그래밍 책은 이해하기 어려웠어요. 아마 제가 그렇게 느낀 것일 뿐일지도 몰라요. 또한 튜토리얼을 찾는 것도 어려웠는데, 그냥 몇 권의 전문 잡지를 찾아보는게 전부였죠. 그 잡지에는 놀라운 자료와 단계별 가이드가 가득 했어요.\n\n하지만 오늘날은 반대의 경향을 보여요: 인터넷에서 거의 모든 것을 찾을 수 있어요. 거의 모든 과학에 대한 다양한 문학이 제공되고 있죠. 하지만 그 중에서 좋은 것을 찾는 것은 다른 문제예요!\n\nNVidia는 교육 플랫폼에 관한 소위 '어제의 웃음꽃'입니다. 누구나 NVidia는 무엇인지 알지만, 거의 아무도 그 Deep Learning Institute와 놀라운 AI 무료 강좌 카탈로그를 알지 못하는 것 같아요.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n함께 탐험해 봐요!\n","ogImage":{"url":"/assets/img/2024-07-06-LearnforfreefromNvidia_0.png"},"coverImage":"/TIL/assets/img/2024-07-06-LearnforfreefromNvidia_0.png","tag":["Tech"],"readingTime":1},{"title":"제로 투 마스터리 아카데미 2024 세일 정보","description":"","date":"2024-07-06 02:30","slug":"2024-07-06-ZerotoMasteryAcademySALE2024","content":"\n/assets/img/2024-07-06-ZerotoMasteryAcademySALE2024_0.png\n\n안녕하세요 여러분, 여러분과 공유하고 싶은 훌륭한 소식이 있어요. ZTM Academy에서 2024년 여름 세일을 진행하고 있어요. 어떤 ZTM 멤버십이든 평생 21% 할인을 제공해요.\n\n할인 코드 ZTMMAX를 사용하면 됩니다. 자세한 내용을 알아보려면 여기를 클릭하세요.\n\nZero to Mastery(ZTM) Academy가 무엇인지 모르시는 분들을 위해 간단히 소개하자면, 전 세계적으로 유명한 강사 Andrei Neagoie가 설립한 ZTM Academy는 혁신적인 기술 교육을 제공하는 종합 교육 플랫폼이에요. 절대 초보자부터 취업 준비가 완료된 전문가까지 이끌어주는 콘텐츠로 구성되어 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Zero to Mastery Academy(줄여서 ZTM Academy)란 무엇인가요?\n\nZTM Academy는 웹 개발, 데이터 과학, 기계 학습 등에서 포괄적인 프로젝트 중심 강좌를 제공하는 온라인 학습 플랫폼입니다. 실용적인 기술과 실제 응용을 중점으로 삼아 ZTM 강좌는 이론적 지식과 함께 견고한 포트폴리오를 작성하는 데 도움이 되도록 설계되었습니다.\n\n# ZTM Academy에 가입하는 이유\n\n- 전문적인 지도: 여러 해의 산업 경험을 가진 시니어 소프트웨어 개발자인 안드레이 네아고이(Andrei Neagoie)로부터 배우세요.\n- 최신 콘텐츠: 강좌는 최신 산업 동향과 기술을 반영하기 위해 정기적으로 업데이트됩니다.\n- 프로젝트 중심 학습: 실제 세계 프로젝트를 구축하여 포트폴리오와 실용적 기술을 향상시킬 수 있습니다.\n- 지원하는 커뮤니티: 활기찬 학습자들의 네트워킹과 지원을 위한 커뮤니티에 참여하세요.\n- 채용 지원: 취업 및 경력 발전을 위한 리소스에 액세스하세요.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# ZTM Academy의 인기 강좌\n\n## 1. 2024년까지 완전한 웹 개발자: 제로 투 마스터리\n\n초보자에게 완벽한 강좌로, 풀스택 웹 개발자가 되기 위해 필요한 모든 것을 다룹니다.\n\n## 2. 주니어에서 시니어 웹 개발자로의 완전한 로드맵\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지식을 높이고 시니어 개발자가 되는 데 필요한 것을 배워보세요.\n\n## 3. 코딩 인터뷰 마스터하기: 데이터 구조 + 알고리즘\n\nDS\u0026A에 대한 포괄적인 코스로 기술 인터뷰에서 뛰어나게 성공하세요.\n\n## 4. JavaScript: 고급 개념\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n깊게 파고들어 고급 JavaScript 개념을 배워 JS 전문가가 되어보세요.\n\n### 5. 2024년 완벽한 React 개발자가 되는 방법 (리덕스, 훅, 그래프큐엘 포함)\n\nReact 및 그 생태계를 마스터하여 현대적인 웹 애플리케이션을 개발하세요.\n\n### 6. 2024년 완벽한 Python 개발자되는 방법: 제로 투 마스터리\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기초부터 고급까지 넓은 지식을 갖춘 Python 개발자가 되어보세요.\n\n## 7. 완벽한 기계 학습 및 데이터 과학: 제로 투 마스터리\n\n이 포괄적인 코스로 기계 학습과 데이터 과학의 흥미로운 세계로 뛰어들어보세요.\n\n그 외 주목할 만한 코스들:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Learning to Learn [Efficient Learning]: Zero to Mastery\n- Deno: The Complete Guide Zero to Mastery\n- JavaScript Web Projects: 20 Projects to Build Your Portfolio\n- Complete SQL + Databases Bootcamp: Zero to Mastery\n- Complete Web \u0026 Mobile Designer in 2024: UI/UX, Figma + more\n- Master the Coding Interview: Big Tech (FAANG) Interviews\n- Complete Ethical Hacking Bootcamp 2024: Zero to Mastery\n\n코딩 여정을 시작하고 싶은 분이나 기술을 향상시키고자 하는 분을 위해 ZTM Academy에는 적합한 과정이 있습니다. Zero to Mastery로 경력을 바꾼 수천 명의 성공한 학생들에 합류하세요. 여러분의 기술 미래는 여기에서 시작됩니다!\n\n지금 가입하시고 21% 할인 혜택을 받으려면 여기를 클릭하고 할인 코드 : ZTMMAX 를 사용하세요\n","ogImage":{"url":"/assets/img/2024-07-06-ZerotoMasteryAcademySALE2024_0.png"},"coverImage":"/TIL/assets/img/2024-07-06-ZerotoMasteryAcademySALE2024_0.png","tag":["Tech"],"readingTime":4},{"title":"AutoGluon으로 AutoML 시작하기 4줄 코드로 완료하는 ML 워크플로우","description":"","date":"2024-07-06 02:26","slug":"2024-07-06-AutoMLwithAutoGluonMLworkflowwithJustFourLinesofCode","content":"\n## AutoGluon이 캐글 대회를 석권한 방법 및 여러분도 이김을 거두는 방법. 4줄의 코드로 99%의 데이터 과학자들을 이겨낸 알고리즘입니다.\n\n/assets/img/2024-07-06-AutoMLwithAutoGluonMLworkflowwithJustFourLinesofCode_0.png\n\nAutoGluon 연구논문에서 발췌한 이 문장이 오늘 우리가 살펴볼 것을 완벽하게 요약합니다: 최소한의 코딩으로 인상적인 성능을 제공하는 머신러닝 프레임워크입니다. ML 파이프라인을 설정하는 데 4줄의 코드만 필요합니다. 그렇습니다, 4줄의 코드로 말이죠! 직접 확인해보세요:\n\n```python\nfrom autogluon.tabular import TabularDataset, TabularPredictor\n\ntrain_data = TabularDataset('train.csv')\npredictor = TabularPredictor(label='Target').fit(train_data, presets='best_quality')\npredictions = predictor.predict(train_data)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 네 줄은 각 열의 데이터 유형을 자동으로 인식하여 데이터 전처리를 처리하고, 유용한 열 조합을 찾아 특성 공학을 수행하며, 주어진 시간 내에서 최적의 성능을 보이는 모델을 식별하기 위해 앙상블을 통해 모델을 학습합니다. 머신러닝 작업(회귀/분류)의 유형조차 명시하지 않았다는 점을 주목하세요. AutoGluon은 레이블을 검토하여 작업을 스스로 결정합니다.\n\n이 알고리즘을 옹호하고 있나요? 꼭 그렇지는 않아요. AutoGluon의 성능을 인정하지만, 저는 데이터 과학을 카글 대회의 정확도 점수만 낼 수 있는 것으로 축소시키지 않는 솔루션을 선호합니다. 그러나 이러한 모델들이 점점 더 인기를 얻고 널리 채택되는 상황에서는, 그들이 어떻게 작동하는지, 그들 뒤에 숨은 수학과 코드를 이해하고, 그들을 활용하거나 능가하는 방법을 파악하는 것이 중요합니다.\n\n# 1: AutoGluon 개요\n\nAutoGluon은 아마존 웹 서비스(AWS)에서 만든 오픈소스 머신러닝 라이브러리입니다. 이는 데이터 준비부터 최적의 모델 선택과 설정 조정까지 전체 머신러닝 프로세스를 자동으로 처리하기 위해 설계되었습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAutoGluon은 간편함과 우수한 성능을 결합한 머신 러닝 라이브러리입니다. 앙상블 학습과 자동 하이퍼파라미터 튜닝과 같은 고급 기술을 활용하여 생성하는 모델이 높은 정확도를 유지하도록 합니다. 이는 기술적인 세부사항에 갇히지 않고도 강력한 머신 러닝 솔루션을 개발할 수 있다는 것을 의미합니다.\n\n이 라이브러리는 데이터 전처리, 특성 선택, 모델 훈련 및 평가를 처리하여 견고한 머신 러닝 모델을 구축하는 데 필요한 시간과 노력을 크게 줄여줍니다. 게다가 AutoGluon은 작은 프로젝트와 대규모 복잡한 데이터셋 모두에 적합한 규모 조정이 잘 되어 있습니다.\n\nTabular data의 경우, AutoGluon은 데이터를 각기 다른 그룹으로 분류하는 분류 작업과 계속적인 결과를 예측하는 회귀 작업을 모두 처리할 수 있습니다. 또한 텍스트 데이터를 지원하여 감정 분석이나 주제 분류와 같은 작업에 유용합니다. 또한 이미지 데이터를 처리하며 이미지 인식 및 물체 검출에 도움이 됩니다. AutoGluon의 여러 변형은 시계열 데이터, 텍스트 및 이미지를 더 잘 처리하기 위해 만들어졌지만, 여기서는 Tabular data를 처리하는 변형에 초점을 맞출 것입니다. 이 글이 마음에 들었는지, 앞으로 AutoGluon에 대한 깊은 탐구를 원하시는 경우 알려주세요. (AutoGluon 팀, \"AutoGluon: AutoML for Text, Image, and Tabular Data.\" 2020)\n\n# 2: AutoML의 영역\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 2.1: AutoML이란 무엇인가요?\n\nAutoML은 Automated Machine Learning의 약자로, 머신러닝을 실제 문제에 자동으로 적용하는 전체 프로세스를 자동화하는 기술입니다. AutoML의 주요 목표는 머신러닝을 보다 접근 가능하고 효율적으로 만들어 사람들이 심층 전문 지식이 없이도 모델을 개발할 수 있게 하는 것입니다. 이미 알고 있듯이, 이는 데이터 전처리, 특성 공학, 모델 선택 및 하이퍼파라미터 튜닝과 같은 보통 복잡하고 시간이 많이 소요되는 작업을 처리합니다 (He et al., \"AutoML: A Survey of the State-of-the-Art\", 2019).\n\nAutoML 개념은 시간이 흐름에 따라 크게 발전해 왔습니다. 초기에는 머신러닝이 특성을 신중하게 선택하고 하이퍼파라미터를 튜닝하고 올바른 알고리즘을 선택해야 했던 전문가들의 많은 수동 노력이 필요했습니다. 이 분야가 성장함에 따라 점점 크고 복잡한 데이터셋을 처리하기 위해 자동화된 필요성도 증가했습니다. 프로세스 일부를 자동화하기 위한 초기 노력이 현대 AutoML 시스템의 길을 열었습니다. 오늘날, AutoML은 앙상블 학습과 베이지안 최적화와 같은 고급 기술을 사용하여 최소한의 인간 개입으로 높은 품질의 모델을 생성합니다 (Feurer et al., \"Efficient and Robust Automated Machine Learning\", 2015).\n\nAutoML 공간에는 개별적인 기능과 기능을 제공하는 여러 업체들이 등장했습니다. Amazon Web Services가 개발한 AutoGluon은 다양한 데이터 유형에서의 사용 편의성과 강력한 성능으로 유명합니다 (AutoGluon Team, \"AutoGluon: AutoML for Text, Image, and Tabular Data\", 2020). Google Cloud AutoML은 개발자들이 최소한의 노력으로 고품질 모델을 훈련할 수 있는 머신러닝 제품 스위트를 제공합니다. H2O.ai는 감독 및 비감독 학습 작업을 위한 자동 머신러닝 기능을 제공하는 H2O AutoML을 제공합니다 (H2O.ai, \"H2O AutoML: Scalable Automatic Machine Learning\", 2020). DataRobot은 기업용 AutoML 솔루션에 초점을 맞춰 모델 배포 및 관리를 위한 견고한 도구를 제공합니다. Microsoft의 Azure Machine Learning에는 다른 Azure 서비스와 통합되어 포괄적인 머신러닝 솔루션을 제공하는 AutoML 기능이 포함되어 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 2.2: AutoML의 주요 구성 요소\n\n![AutoML Workflow](/TIL/assets/img/2024-07-06-AutoMLwithAutoGluonMLworkflowwithJustFourLinesofCode_1.png)\n\n머신 러닝 파이프라인에서의 첫 번째 단계는 데이터 전처리입니다. 이는 결측값 처리, 중복 제거, 오류 수정 등을 통해 데이터를 정리하는 것을 포함합니다. 데이터 전처리에는 값의 정규화, 범주형 변수의 인코딩, 피처의 스케일 조정과 같이 분석에 적합한 형식으로 데이터를 변환하는 것도 포함됩니다. 적절한 데이터 전처리는 데이터의 품질이 머신 러닝 모델의 성능에 직접적으로 영향을 미치기 때문에 매우 중요합니다.\n\n데이터가 정리되면, 다음 단계는 피처 엔지니어링입니다. 이 프로세스는 모델의 성능을 개선하기 위해 새로운 피처를 만들거나 기존 피처를 수정하는 것을 포함합니다. 피처 엔지니어링은 기존 데이터를 기반으로 새 열을 만드는 것처럼 간단할 수도 있고, 의미 있는 피처를 생성하기 위해 도메인 지식을 사용하는 것처럼 복잡할 수도 있습니다. 적절한 피처는 모델의 예측 능력을 높일 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n데이터 준비가 완료되고 피쳐가 엔지니어링되었다면, 다음 단계는 모델 선택입니다. 해결해야 할 문제에 따라 각각의 강점과 약점을 가진 다양한 알고리즘이 있습니다. AutoML 시스템은 여러 모델을 평가하여 주어진 작업에 가장 적합한 모델을 식별합니다. 이는 의사 결정 트리, 서포트 벡터 머신, 신경망 등과 같은 모델들을 비교하여 데이터와 가장 잘 작용하는 모델을 확인하는 과정을 포함할 수 있습니다.\n\n모델을 선택한 후 다음 과제는 하이퍼파라미터 최적화입니다. 하이퍼파라미터는 머신러닝 알고리즘의 동작을 제어하는 설정들입니다. 이는 신경망의 학습률이나 의사 결정 트리의 깊이와 같은 것들을 포함할 수 있습니다. 하이퍼파라미터의 최적 조합을 찾는 것은 모델의 성능을 크게 향상시킬 수 있습니다. AutoML은 이 과정을 자동화하기 위해 그리드 탐색, 랜덤 탐색 및 베이지안 최적화와 같은 방법을 사용하여 모델이 가장 최적화되도록 보장합니다.\n\n마지막 단계는 모델 평가 및 선택입니다. 이는 모델이 새로운 데이터에 얼마나 잘 일반화되는지 평가하기 위해 교차 검증과 같은 기술을 사용하는 과정을 포함합니다. 정확도, 정밀도, 재현율, F1-점수 등과 같은 다양한 성능 지표를 사용하여 모델의 효과를 측정합니다. AutoML 시스템은 이평가 과정을 자동화하여 선택된 모델이 주어진 작업에 가장 잘 맞는지 보장합니다. 평가가 완료되면, 최적의 성능을 보인 모델이 배포를 위해 선택됩니다. (AutoGluon 팀. \"AutoGluon: 텍스트, 이미지 및 표 형식 데이터를 위한 AutoML.\" 2020).\n\n## 2.3: AutoML의 도전과제\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n오토ML은 시간과 노력을 절약해주지만, 컴퓨팅 자원 측면에서 상당히 요구되는 경우가 있습니다. 하이퍼파라미터 튜닝과 모델 선택 같은 작업을 자동화하기 위해서는 여러 번의 반복과 다수의 모델 학습이 필요할 수 있는데, 이는 고성능 컴퓨팅 자원에 접근할 수 없는 소규모 조직이나 개인에게는 어려운 과제가 될 수 있습니다.\n\n다른 어려움은 맞춤화에 대한 요구사항입니다. 오토ML 시스템은 많은 상황에서 매우 효과적일 수 있지만, 항상 원하는 요구 사항을 즉시 충족시키지 못할 수 있습니다. 때로는 자동화된 과정이 특정 데이터셋이나 문제의 고유한 측면을 완전히 포착하지 못할 수 있습니다. 사용자는 워크플로우의 일부를 조정해야 할 수 있으며, 시스템이 충분한 유연성을 제공하지 않거나 사용자가 필요한 전문 지식을 갖추지 못한 경우에는 어려울 수 있습니다.\n\n하지만 이러한 어려움에도 불구하고, 오토ML의 혜택은 종종 단점을 상회합니다. 생산성을 크게 향상시키고 접근성을 확대하며 확장 가능한 솔루션을 제공하여 더 많은 사람들이 머신러닝의 힘을 활용할 수 있게 합니다 (Feurer 등, “효율적이고 견고한 자동화 머신러닝”, 2015).\n\n# 3: AutoGluon 뒤의 수학\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 3.1: AutoGluon의 구조\n\nAutoGluon의 구조는 데이터 전처리부터 모델 배포까지 전체 기계 학습 워크플로우를 자동화하는 데 설계되었습니다. 이 구조는 특정 단계를 처리하는 여러 연결된 모듈로 구성되어 있습니다.\n\n첫 번째 단계는 데이터 모듈입니다. 이 모듈은 데이터를 로드하고 전처리하는 작업을 처리합니다. 이 모듈은 데이터를 정리하고 누락된 값을 처리하며 데이터를 분석에 적합한 형식으로 변환하는 작업을 다룹니다. 예를 들어, 누락된 값이 있는 데이터 세트 X가 있다고 가정해 보겠습니다. Data Module은 이러한 누락된 값을 평균이나 중앙값을 사용하여 보완할 수 있습니다:\n\n```python\nfrom sklearn.impute import SimpleImputer\nimputer = SimpleImputer(strategy='mean')\nX_imputed = imputer.fit_transform(X)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n데이터 전처리가 완료되면 특성 엔지니어링 모듈이 작동합니다. 이 구성 요소는 새로운 기능을 생성하거나 기존 기능을 변환하여 모델의 예측 능력을 향상시킵니다. 범주형 변수에 대한 원핫 인코딩 또는 숫자 데이터에 다항식 기능을 생성하는 기술이 일반적입니다. 예를 들어, 범주형 변수의 인코딩은 다음과 같이 보일 수 있습니다:\n\n```js\nfrom sklearn.preprocessing import OneHotEncoder\nencoder = OneHotEncoder()\nX_encoded = encoder.fit_transform(X)\n```\n\nAutoGluon의 핵심은 모델 모듈입니다. 이 모듈에는 의사 결정 트리, 신경망 및 그래디언트 부스팅 머신과 같은 다양한 머신러닝 알고리즘이 포함되어 있습니다. 이 모듈은 데이터 세트에서 여러 모델을 훈련하고 그 성능을 평가합니다. 예를들어, 의사 결정 트리를 훈련하는 방법은 다음과 같습니다:\n\n```js\nfrom sklearn.tree import DecisionTreeClassifier\nmodel = DecisionTreeClassifier()\nmodel.fit(X_train, y_train)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하이퍼파라미터 최적화 모듈은 각 모델에 대한 최상의 하이퍼파라미터를 자동으로 탐색합니다. 그리드 탐색, 랜덤 탐색 및 베이지안 최적화와 같은 방법을 사용합니다. Snoek 등이 2012년 논문에서 상세히 설명한 바에이지안 최적화는 탐색 프로세스를 안내하기 위해 확률 모델을 구축합니다:\n\n```python\nfrom skopt import BayesSearchCV\nsearch_space = {'max_depth': (1, 32)}\nbayes_search = BayesSearchCV(estimator=DecisionTreeClassifier(), search_spaces=search_space)\nbayes_search.fit(X_train, y_train)\n```\n\n학습 후 평가 모듈은 정확도, 정밀도, 재현율 및 F1 점수와 같은 메트릭을 사용하여 모델 성능을 평가합니다. 모델이 새로운 데이터에 잘 일반화되도록 보장하기 위해 교차 검증이 일반적으로 사용됩니다:\n\n```python\nfrom sklearn.model_selection import cross_val_score\nscores = cross_val_score(model, X, y, cv=5, scoring='accuracy')\nmean_score = scores.mean()\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAutoGluon은 여러 모델의 예측을 결합하여 더 정확한 단일 예측을 생성하는 Ensemble Module이 뛰어나다. 스태킹, 배깅, 블렌딩과 같은 기술이 사용된다. 예를 들어, 배깅은 BaggingClassifier를 사용하여 구현할 수 있다:\n\n```python\nfrom sklearn.ensemble import BaggingClassifier\nbagging = BaggingClassifier(base_estimator=DecisionTreeClassifier(), n_estimators=10)\nbagging.fit(X_train, y_train)\n```\n\n마지막으로, Deployment Module은 가장 좋은 모델 또는 앙상블을 제품으로 배포하는 작업을 다룬다. 이는 모델을 내보내고, 새로운 데이터에 대한 예측을 생성하고, 모델을 기존 시스템에 통합하는 것을 포함한다:\n\n```python\nimport joblib\njoblib.dump(bagging, 'model.pkl')\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이러한 구성 요소들은 머신 러닝 파이프라인을 자동화하여 사용자가 빠르고 효율적으로 고품질 모델을 구축하고 배포할 수 있도록합니다.\n\n## 3.2: AutoGluon에서 앙상블 학습\n\n앙상블 학습은 AutoGluon의 핵심 기능으로, 고품질 모델을 제공하는 능력을 향상시킵니다. 여러 모델을 결합함으로써 앙상블 방법은 예측 정확도와 견고성을 향상시킵니다. AutoGluon은 세 가지 주요 앙상블 기법을 활용합니다: 스태킹, 배깅 및 블렌딩.\n\n**스태킹**\n스태킹은 동일한 데이터 집합에서 여러 기본 모델을 학습하고 그 예측을 상위 수준 모델에 입력 기능으로 사용하는 방식입니다. 이 접근 방식은 다양한 알고리즘의 강점을 활용하여 앙상블이 더 정확한 예측을 할 수 있도록 합니다. 스태킹 프로세스는 다음과 같이 수학적으로 표현할 수 있습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n/assets/img/2024-07-06-AutoMLwithAutoGluonMLworkflowwithJustFourLinesofCode_2.png\n\n여기서 h_1은 기본 모델을 나타내며, h_2는 메타 모델입니다. 각 기본 모델 h_1은 입력 피처 x_i를 가져와 예측을 생성합니다. 이러한 예측은 메타 모델 h_2의 입력 피처로 사용되어 최종 예측 y^가 이루어집니다. 다양한 기본 모델의 출력을 결합함으로써 스태킹은 데이터의 보다 넓은 범위의 패턴을 포착하여 예측 성능을 향상시킬 수 있습니다.\n\n배깅\n배깅은 Bootstrap Aggregating의 줄임말로, 동일한 모델의 여러 인스턴스를 데이터의 다른 부분집합에 학습시킴으로써 모델의 안정성과 정확도를 향상시킵니다. 이러한 부분집합은 원본 데이터셋을 대체로 무작위로 샘플링하여 생성됩니다. 최종 예측은 일반적으로 회귀 작업의 경우 모든 모델의 예측을 평균 내거나 분류 작업의 경우 다수결 투표로 이루어집니다.\n\n수학적으로, 배깅은 다음과 같이 표현할 수 있습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n회귀 분석:\n\n![AutoMLwithAutoGluonMLworkflowwithJustFourLinesofCode_3](/TIL/assets/img/2024-07-06-AutoMLwithAutoGluonMLworkflowwithJustFourLinesofCode_3.png)\n\n분류:\n\n![AutoMLwithAutoGluonMLworkflowwithJustFourLinesofCode_4](/TIL/assets/img/2024-07-06-AutoMLwithAutoGluonMLworkflowwithJustFourLinesofCode_4.png)\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n각각 데이터 하위 집합에서 훈련된 i번째 모델을 h_i로 나타냅니다. 회귀의 경우, 최종 예측 값 y^는 각 모델이 만든 예측의 평균입니다. 분류의 경우, 최종 예측 값 y^는 모델들 중 가장 빈도가 높은 클래스로 예측됩니다.\n\n배깅의 분산 감소 효과는 다수의 모델에서 예측의 평균이 기대값으로 수렴하여 전체 분산을 줄이고 예측의 안정성을 향상시키는 큰 수의 법칙에 의해 설명될 수 있습니다. 이는 아래와 같이 설명할 수 있습니다:\n\n/assets/img/2024-07-06-AutoMLwithAutoGluonMLworkflowwithJustFourLinesofCode_5.png\n\n데이터의 다른 하위 집합에서 훈련함으로써 배깅은 오버피팅을 줄이고 모델의 일반화 성능을 향상시키는 데 도움이 됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nBlending\nBlending은 stacking과 유사하지만 더 간단하게 구현됩니다. Blending에서 데이터는 학습 세트와 검증 세트로 분할됩니다. 기본 모델은 학습 세트에서 학습되며, 검증 세트에서의 예측값은 최종 모델인 블렌더 또는 메타-러너를 학습하는 데 사용됩니다. Blending은 홀드아웃 검증 세트를 사용하여 구현이 빠를 수 있습니다:\n\n```js\n# 단순한 학습-검증 분리를 사용한 블렌딩 예시\ntrain_meta, val_meta, y_train_meta, y_val_meta = train_test_split(X, y, test_size=0.2)\nbase_model_1.fit(train_meta, y_train_meta)\nbase_model_2.fit(train_meta, y_train_meta)\npreds_1 = base_model_1.predict(val_meta)\npreds_2 = base_model_2.predict(val_meta)\nmeta_features = np.column_stack((preds_1, preds_2))\nmeta_model.fit(meta_features, y_val_meta)\n```\n\n이러한 기술은 최종 예측이 더 정확하고 견고하게 되도록 보장하며, 다중 모델의 다양성과 강점을 활용하여 우수한 결과를 제공합니다.\n\n# 3.3: 하이퍼파라미터 최적화\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하이퍼파라미터 최적화는 모델의 성능을 극대화하기 위해 최적의 설정을 찾는 작업을 말합니다. AutoGluon은 베이지안 최적화, 조기 중지, 스마트 자원 할당과 같은 고급 기술을 활용하여 이 프로세스를 자동화합니다.\n\n베이지안 최적화\n베이지안 최적화는 목적 함수의 확률 모델을 구축하여 최적의 하이퍼파라미터 세트를 찾는 것을 목표로 합니다. 이는 이전 평가 결과를 활용하여 다음에 시도할 하이퍼파라미터를 결정하는 데 도움을 줍니다. 이는 특히 크고 복잡한 하이퍼파라미터 공간을 효율적으로 탐색하고 최적 구성을 찾기 위해 필요한 평가 수를 줄이는 데 유용합니다.\n\n여기서 f(θ)는 최적화하려는 목적 함수를 나타내며, 예를 들어 모델 정확도나 손실입니다. θ는 하이퍼파라미터를 나타냅니다. E[f(θ)]는 하이퍼파라미터 θ가 주어졌을 때 목적 함수의 기대값을 나타냅니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n베이지안 최적화에는 두 가지 주요 단계가 포함됩니다:\n\n- Surrogate Modeling: 이전 평가를 기반으로 목적 함수를 근사하는 확률 모델, 일반적으로 가우시안 프로세스가 구축됩니다.\n- Acquisition Function: 이 함수는 탐색(하이퍼파라미터 공간의 새로운 영역을 시도)과 활용(잘 수행하는 영역에 집중)을 균형있게 고려하여 다음 세트의 하이퍼파라미터를 결정합니다. 일반적인 획득 함수로는 예상 향상(EI) 및 상한 신뢰구간(UCB)이 포함됩니다.\n\n최적화는 최적의 하이퍼파라미터 집합에 도달할 때까지 후보 모델을 실제로 평가하는 횟수를 그리드나 무작위 검색 방법에 비해 줄일 수 있도록 순환적으로 대리 모델과 획득 함수를 업데이트합니다.\n\n조기 중지 기술\n조기 중지는 오버피팅을 방지하고 검증 세트에서 모델의 성능 향상이 멈출 때 교육 프로세스를 중단하여 교육 시간을 단축합니다. AutoGluon은 교육 중에 모델의 성능을 모니터링하고 추가 교육이 큰 향상을 기대하기 힘들 때 프로세스를 중지합니다. 이 기술은 계산 자원을 절약할 뿐만 아니라 모델이 새로운 데이터에도 잘 일반화되도록 보장합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import log_loss\n\nX_train, X_val, y_train, y_val = train_test_split(X, y, test_size=0.2)\nmodel = DecisionTreeClassifier()\nbest_loss = np.inf\n\nfor epoch in range(100):\n    model.fit(X_train, y_train)\n    val_preds = model.predict(X_val)\n    loss = log_loss(y_val, val_preds)\n    if loss \u003c best_loss:\n        best_loss = loss\n    else:\n        break\n```\n\n자원 할당 전략\n효과적인 자원 할당은 제한된 컴퓨팅 자원을 다룰 때 하이퍼파라미터 최적화에 중요합니다. AutoGluon은 다양한 성능 최적화 전략을 사용합니다. 시스템은 초기에 일부 데이터 또는 더 적은 에폭으로 모델을 훈련하여 빠르게 잠재력을 평가합니다. 유망한 모델에는 이후에 더 많은 자원이 할당되어 철저한 평가를 수행합니다. 이 접근 방식은 탐색과 활용을 균형 있게 유지하여 컴퓨팅 자원이 효율적으로 사용되도록 합니다:\n\n![AutoML with AutoGluon ML workflow with Just Four Lines of Code](/TIL/assets/img/2024-07-06-AutoMLwithAutoGluonMLworkflowwithJustFourLinesofCode_7.png)\n\n이 공식에서:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- h_i는 i번째 모델을 나타냅니다.\n- C_i는 모델 h_i와 관련된 비용으로, 계산 시간이나 사용된 자원과 같은 것들을 의미합니다.\n- Resource(h_i)는 모델 h_i에 할당된 총 자원 비율을 나타냅니다.\n\n먼저 낮은 충실도를 가진 모델을 학습합니다(예: 더 적은 데이터 포인트 또는 epoch 사용). Multi-fidelity 최적화를 통해 빠르게 유망한 후보자를 식별합니다. 그런 후보자들은 더 높은 충실도로 학습시켜, 계산 자원을 효율적으로 사용한다는 것을 보장합니다. 이 방법은 하이퍼파라미터 공간의 탐색과 이미 알려진 좋은 구성을 활용하는 것을 균형 있게 유지하여, 효율적이고 효과적인 하이퍼파라미터 최적화를 이끌어냅니다.\n\n## 3.4: 모델 평가 및 선택\n\n모델 평가 및 선택은 선정된 모델이 새로운, 보지 못한 데이터에서 잘 수행되도록 보장합니다. AutoGluon은 교차 검증 기술, 성능 지표 및 자동 모델 선택 기준을 사용하여 이 프로세스를 자동화합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n교차 검증 기법\n교차 검증은 데이터를 여러 폴드로 분할하고 모델을 서로 다른 하위 집합에서 훈련한 후 나머지 부분에서 유효성을 검사하는 과정을 말합니다. AutoGluon은 k-fold cross-validation과 같은 기술을 사용합니다. 데이터가 k개의 하위 집합으로 나뉘고 모델이 k번 훈련 및 유효성을 검사하며 각 시도마다 다른 하위 집합을 검증 세트로 사용합니다. 이를 통해 모델의 성능을 신뢰할 수 있는 추정치로 얻을 수 있으며 특정 train-test 분할에 의한 평가가 편향되지 않도록 합니다.\n\n성능 지표\n모델의 품질을 평가하기 위해 AutoGluon은 특정 작업에 따라 다양한 성능 지표를 활용합니다. 분류 작업의 경우 일반적으로 정확도, 정밀도, 재현율, F1 점수 및 ROC 곡선 아래 영역 (AUC-ROC)과 같은 지표가 사용됩니다. 회귀 작업의 경우 평균 절대 오차 (MAE), 평균 제곱 오차 (MSE), R제곱 등의 지표가 자주 사용됩니다. AutoGluon은 평가 과정에서 이러한 지표를 자동으로 계산하여 모델의 강점과 약점을 종합적으로 파악할 수 있습니다:\n\n```js\nfrom sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score\ny_pred = model.predict(X_val)\naccuracy = accuracy_score(y_val, y_pred)\nprecision = precision_score(y_val, y_pred)\nrecall = recall_score(y_val, y_pred)\nf1 = f1_score(y_val, y_pred)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자동 모델 선택 기준\n모델을 평가한 후 AutoGluon은 최상의 성능을 발휘하는 모델을 선택하는 자동 기준을 사용합니다. 이때는 다양한 모델들 사이의 성능 지표를 비교하고, 해당 작업에 가장 관련성 높은 지표에서 우수한 성과를 보이는 모델을 선택합니다. AutoGluon은 또한 모델 복잡성, 학습 시간, 자원 효율성과 같은 요소도 고려합니다. 자동 모델 선택 프로세스는 선택된 모델이 우수한 성능을 보이는 것뿐만 아니라, 현실 세계 시나리오에서 실제로 배포하고 사용하기에 실용적인지를 보장합니다. 이 선택을 자동화함으로써, AutoGluon은 인간의 편향을 제거하고 최고의 모델을 선택하는 것에 일관되고 객관적인 접근을 보장합니다:\n\n```python\nbest_model = max(models, key=lambda model: model['score'])\n```\n\n# 4: Python에서의 AutoGluon\n\nAutoGluon을 사용하기 위해 환경을 설정해야 합니다. 이에는 필요한 라이브러리와 종속성을 설치하는 과정이 포함됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파이프를 사용하여 AutoGluon을 설치할 수 있어요. 터미널이나 명령 프롬프트를 열고 다음 명령을 실행해주세요:\n\n```js\npip install autogluon\n```\n\n이 명령은 AutoGluon과 필요한 종속성을 함께 설치할 거에요.\n\n다음으로 데이터를 다운로드해야 해요. 이 예제용 데이터 집합을 다운로드하려면 Kaggle을 설치해야 해요:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\npip install kaggle\n```\n\n설치가 완료되면 터미널에서 이 명령을 실행하여 데이터 세트를 다운로드하세요. 노트북 파일이 있는 동일한 디렉토리에 있는지 확인해주세요:\n\n```js\nmkdir data\ncd data\nkaggle competitions download -c playground-series-s4e6\nunzip \"Academic Succession/playground-series-s4e6.zip\"\n```\n\n또는 최근 Kaggle 대회 \"Academic Success Dataset\"을 통해 데이터 세트를 수동으로 다운로드할 수 있습니다. 이 데이터 세트는 상업적 이용을 위해 무료로 제공됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n환경 설정이 완료되면 AutoGluon을 사용하여 기계 학습 모델을 구축하고 평가할 수 있습니다. 먼저 데이터 세트를 로드하고 준비해야 합니다. AutoGluon을 사용하면이 프로세스를 간단하게 수행할 수 있습니다. 학습 데이터가 포함 된 train.csv라는 CSV 파일이 있다고 가정해보십시오.\n\n```js\nfrom autogluon.tabular import TabularDataset, TabularPredictor\n\n# 데이터 세트 로드\ntrain_df = TabularDataset('data/train.csv')\n```\n\n데이터를 로드 한 후에 AutoGluon을 사용하여 모델을 훈련할 수 있습니다. 이 예에서는 'Target'라는 대상 변수를 예측하는 모델을 훈련하고 평가 메트릭으로 정확도를 사용합니다. 또한 하이퍼파라미터 튜닝과 자동 스택을 활성화하여 모델 성능을 향상시키겠습니다.\n\n```js\n# 모델 훈련\npredictor = TabularPredictor(\n    label='Target',\n    eval_metric='accuracy',\n    verbosity=1\n).fit(\n    train_df,\n    presets=['best_quality'],\n    hyperparameter_tune=True,\n    auto_stack=True\n)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n훈련 후에 모델의 성능을 평가할 수 있습니다. 리더보드를 사용하여 모델이 훈련 데이터에 대해 어떻게 수행되는지 요약된 정보를 제공합니다:\n\n```js\n# 모델 평가\n리더보드 = predictor.leaderboard(train_df, silent=True)\nprint(리더보드)\n```\n\n리더보드를 통해 AutoGluon에 의해 훈련된 모든 모델을 자세히 비교할 수 있습니다.\n\n/assets/img/2024-07-06-AutoMLwithAutoGluonMLworkflowwithJustFourLinesofCode_9.png\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n주요 열을 자세히 살펴보겠습니다:\n\n- model: 이 열은 모델의 이름을 나열합니다. 예를 들어, RandomForestEntr_BAG_L1은 엔트로피를 기준으로 사용하고 레벨 1에서 배깅한 랜덤 포레스트 모델을 의미합니다.\n- score_test: 이는 데이터셋에 대한 모델의 정확도를 보여줍니다. 일부 모델의 경우 1.00의 점수는 완벽한 정확도를 의미합니다. 이름과는 반대로, score_test는 모델 훈련 중에 사용된 훈련 데이터셋을 나타냅니다.\n- score_val: 이는 검증 데이터셋에 대한 모델의 정확도를 보여줍니다. 모델이 보이지 않는 데이터에서 얼마나 잘 수행되는지 보여주므로 주의깊게 살펴보세요.\n- eval_metric: 여기서 사용된 평가 지표인 정확도.\n- pred_time_test: 테스트 데이터에 대한 예측 시간.\n- pred_time_val: 검증 데이터에 대한 예측 시간.\n- fit_time: 모델 훈련에 소요된 시간.\n- pred_time_test_marginal: 테스트 데이터셋에서 앙상블 모델에 의해 추가된 예측 시간.\n- pred_time_val_marginal: 검증 데이터셋에서 앙상블 모델에 의해 추가된 예측 시간.\n- fit_time_marginal: 앙상블 모델에서 추가된 훈련 시간.\n- stack_level: 모델의 스태킹 레벨을 나타냅니다. 레벨 1 모델은 기본 모델이며, 레벨 2 모델은 레벨 1 모델의 예측을 특성으로 사용하는 메타 모델입니다.\n- can_infer: 모델이 추론에 사용될 수 있는지를 나타내는 표시입니다.\n- fit_order: 모델이 훈련된 순서.\n\n제공된 리더보드를 살펴보면, RandomForestEntr_BAG_L1 및 RandomForestGini_BAG_L1과 같은 일부 모델은 완벽한 훈련 정확도(1.000000)를 보이지만 약간 낮은 검증 정확도를 가지며, 잠재적인 과적합을 시사합니다. 레벨 1 모델의 예측을 결합하는 WeightedEnsemble_L2는 일반적으로 베이스 모델의 강점을 균형있게 유지하여 좋은 성능을 보여줍니다.\n\nLightGBMLarge_BAG_L1 및 XGBoost_BAG_L1과 같은 모델은 경쟁력 있는 검증 점수와 합리적인 훈련 및 예측 시간을 가지고 있어, 배포를 위한 강력한 후보 모델이 될 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nfit_time 및 pred_time 열은 각 모델의 계산 효율성에 대한 통찰을 제공하며, 이는 실용적인 응용 프로그램에 중요합니다.\n\n리더보드 외에 AutoGluon은 균형 잡힌 데이터 세트를 처리하고 하이퍼파라미터 튜닝을 수행하며, 훈련 프로세스를 사용자 정의하는 여러 고급 기능을 제공합니다.\n\nfit 메서드의 매개변수를 조정하여 훈련 프로세스의 다양한 측면을 사용자 정의할 수 있습니다. 예를 들어, 훈련 반복 횟수를 변경하거나 사용할 다른 알고리즘을 지정하거나 각 알고리즘에 맞춤형 하이퍼파라미터를 설정할 수 있습니다.\n\n```python\nfrom autogluon.tabular import TabularPredictor, TabularDataset\n\n# 데이터 세트 로드\ntrain_df = TabularDataset('train.csv')\n\n# 사용자 정의 하이퍼파라미터 정의\nhyperparameters = {\n    'GBM': {'num_boost_round': 200},\n    'NN': {'epochs': 10},\n    'RF': {'n_estimators': 100},\n}\n\n# 사용자 정의 설정으로 모델 훈련\npredictor = TabularPredictor(\n    label='Target',\n    eval_metric='accuracy',\n    verbosity=2\n).fit(\n    train_data=train_df,\n    hyperparameters=hyperparameters\n)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n불균형 데이터셋은 도전적일 수 있지만 AutoGluon은 이를 효과적으로 처리할 수 있는 도구를 제공합니다. 소수 클래스의 오버샘플링, 다수 클래스의 언더샘플링, 또는 비용 민감한 학습 알고리즘 적용과 같은 기술을 사용할 수 있습니다. AutoGluon은 데이터셋에서 불균형을 자동으로 감지하고 처리할 수 있습니다.\n\nMarkdown 형식의 표로 변경하였습니다.\n\n```js\nfrom autogluon.tabular import TabularPredictor, TabularDataset\n\n# 데이터셋 로드\ntrain_df = TabularDataset('train.csv')\n\n# 사용자 지정 매개변수 지정하여 불균형 데이터셋 처리\n# AutoGluon이 내부적으로 처리할 수 있지만 명확히하기 위해 여기서 지정\nhyperparameters = {\n    'RF': {'n_estimators': 100, 'class_weight': 'balanced'},\n    'GBM': {'num_boost_round': 200, 'scale_pos_weight': 2},\n}\n\n# 불균형 처리를 위한 설정으로 모델 훈련\npredictor = TabularPredictor(\n    label='Target',\n    eval_metric='accuracy',\n    verbosity=2\n).fit(\n    train_data=train_df,\n    hyperparameters=hyperparameters\n)\n```\n\n모델 성능 최적화를 위해 하이퍼파라미터 튜닝이 중요합니다. AutoGluon은 베이지안 최적화와 같은 고급 기술을 사용하여 이 과정을 자동화합니다. 하이퍼파라미터 튜닝을 활성화하려면 fit 메서드에서 hyperparameter_tune=True로 설정할 수 있습니다.\n\n```js\nfrom autogluon.tabular import TabularPredictor, TabularDataset\n\n# 데이터셋 로드\ntrain_df = TabularDataset('train.csv')\n\n# 하이퍼파라미터 튜닝을 적용하여 모델 훈련\npredictor = TabularPredictor(\n    label='Target',\n    eval_metric='accuracy',\n    verbosity=2\n).fit(\n    train_data=train_df,\n    presets=['best_quality'],\n    hyperparameter_tune=True\n)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자동 머신 학습 모델을 능가할 수 있는 방법에 대해 알아보겠습니다. 손실 지표를 개선하는 것을 주요 목표로 삼고, 지연 시간, 계산 비용 또는 다른 지표에 초점을 맞추는 대신 고려해 보겠습니다.\n\n딥러닝에 적합한 대규모 데이터셋이 있다면, 딥러닝 아키텍처를 실험하는 것이 더 쉬울 수 있습니다. 자동 머신 학습 프레임워크는 이 영역에서 어려움을 겪을 수 있습니다. 딥러닝은 데이터셋에 대한 깊은 이해를 필요로 하며, 모델을 맹목적으로 적용하는 것은 많은 시간과 자원을 소비할 수 있습니다. 다음은 딥러닝을 시작하는 데 도움이 되는 몇 가지 자료입니다:\n\n그러나 실제 도전은 전통적인 머신 러닝 작업에서 자동 머신 학습 모델을 능가하는 데 있습니다. 자동 머신 학습 시스템은 일반적으로 앙상블을 사용하므로, 결과적으로 마찬가지일 가능성이 높습니다. 좋은 시작 전략은 먼저 AutoML 모델을 맞추는 것일 수 있습니다. 예를 들어, AutoGluon을 사용하여 어떤 모델이 가장 잘 수행되었는지 확인할 수 있습니다. 그런 다음 이러한 모델을 가져와 AutoGluon이 사용한 앙상블 아키텍처를 재현할 수 있습니다. Optuna와 같은 기술로 이러한 모델을 더 최적화하여 더 나은 성능을 달성할 수도 있습니다. Optuna를 정복하는 포괄적인 안내서:\n\n또한 특성 엔지니어링에 도메인 지식을 적용하는 것이 도움이 될 수 있습니다. 데이터의 구체적인 내용을 이해하면 의미 있는 특성을 생성할 수 있어 모델의 성능을 크게 향상시킬 수 있습니다. 적용 가능한 경우, 데이터셋을 확장하여 더 다양한 학습 예제를 제공함으로써 모델의 견고성을 향상시킬 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위 전략들을 초기 AutoML 모델로부터 얻은 통찰과 결합하여, 자동화된 방식을 능가하고 뛰어난 결과를 달성할 수 있습니다.\n\n# 결론\n\nAutoGluon은 데이터 전처리부터 모델 배포까지 모든 것을 자동화하여 머신러닝 프로세스를 혁신합니다. 최첨단 아키텍처, 강력한 앙상블 학습 기술 및 정교한 하이퍼파라미터 최적화를 통해, AutoGluon은 초보자와 경험 많은 데이터 과학자에게 필수 도구로 자리매김하고 있습니다. AutoGluon을 사용하면 복잡하고 시간 소모적인 작업을 간소화된 워크플로우로 변환하여, 전례없는 속도와 효율성으로 최고 수준의 모델을 구축할 수 있습니다.\n\n그러나 머신러닝에서 진정으로 뛰어나기 위해서는 AutoGluon에만 의존하는 것이 아닌, 핵심 모델 전략에 대한 통찰을 얻고 프로젝트를 가속화하기 위한 토대로 활용해야 합니다. 거기서부터 데이터를 이해하고 효과적인 모델 전략을 적용하기 위해 도메인 지식을 활용하세요. 사용자 지정 모델을 실험하고 AutoGluon의 초기 제안을 넘어서 세밀하게 조정해보세요.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 참고 문헌\n\n- Erickson, N., Mueller, J., Charpentier, P., Kornblith, S., Weissenborn, D., Norris, E., … \u0026 Smola, A. (2020). AutoGluon-Tabular: Structured Data에 대한 견고하고 정확한 AutoML. arXiv 사전 인쇄 arXiv:2003.06505.\n- Snoek, J., Larochelle, H., \u0026 Adams, R. P. (2012). 머신러닝 알고리즘의 실용적인 베이지안 최적화. 신경 정보 처리 시스템 발전, 25.\n- Pedregosa, F., Varoquaux, G., Gramfort, A., Michel, V., Thirion, B., Grisel, O., … \u0026 Duchesnay, É. (2011). Scikit-learn: Python에서 머신러닝. 기계 학습 연구 저널, 12(Oct), 2825–2830.\n- AutoGluon 팀. “AutoGluon: 텍스트, 이미지 및 테이블 데이터용 AutoML.” 2020.\n- Feurer, Matthias 등. “효율적이고 견고한 자동화된 머신러닝.” 2015.\n- He, Xin 등. “AutoML: 최신 기술 조사.” 2020.\n- Hutter, Frank 등. “자동화된 머신러닝: 방법, 시스템, 도전과제.” 2019.\n- H2O.ai. “H2O AutoML: 확장 가능한 자동 머신러닝.” 2020.\n","ogImage":{"url":"/assets/img/2024-07-06-AutoMLwithAutoGluonMLworkflowwithJustFourLinesofCode_0.png"},"coverImage":"/TIL/assets/img/2024-07-06-AutoMLwithAutoGluonMLworkflowwithJustFourLinesofCode_0.png","tag":["Tech"],"readingTime":30},{"title":"자바스크립트와 파이썬의 비동기 프로그래밍 비교 어떤 언어가 더 나을까","description":"","date":"2024-07-06 02:24","slug":"2024-07-06-AsyncProgramminginJavaScriptvsPython","content":"\n비동기 프로그래밍은 작업을 더 효율적으로 실행할 수 있게 해주는 주요 패러다임입니다, 특히 I/O 바운드 작업에서 더욱 그렇습니다. JavaScript와 Python은 모두 비동기 프로그래밍을 지원하지만, 각각의 설계 철학과 런타임 환경에 따라 다른 방식으로 지원합니다.\n\n이 기사는 JavaScript와 Python에서의 비동기 프로그래밍을 비교하여, 그들의 메커니즘, 성능 및 사용 사례를 살펴봅니다.\n\n## 비동기 프로그래밍 소개\n\n비동기 프로그래밍은 프로그램이 장기 실행 작업이 완료될 때까지 기다리는 동안 다른 작업을 수행할 수 있게 합니다. 이 패러다임은 네트워크 요청, 파일 I/O 및 데이터베이스 상호 작용과 같은 I/O 작업이 지연을 일으킬 수 있는 환경에서 중요합니다. 주 스레드를 차단하지 않음으로써, 비동기 프로그래밍은 응용 프로그램의 반응성과 효율성을 향상시킵니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## JavaScript에서의 비동기 프로그래밍\n\nJavaScript는 본질적으로 비동기적이며 단일 스레드이며, 비동기 작업을 처리하기 위해 이벤트 루프를 의존합니다. 이벤트 루프는 JavaScript가 시스템의 커널에 일부 작업을 오프로드하고 작업이 완료되면 콜백을 실행하여 여러 작업을 동시에 처리할 수 있는 핵심 메커니즘입니다.\n\n주요 구성 요소:\n\n- 호출 스택: 호출 스택은 현재 실행 중인 함수를 보유합니다. 함수가 호출되면 스택에 푸시되고 반환되면 스택에서 팝됩니다.\n- Web API: 이는 브라우저 (또는 Node.js)에서 제공하는 API로 DOM 조작, HTTP 요청 및 타이머와 같은 작업을 처리합니다. 비동기 작업이 수행될 때, 이러한 API로 작업이 전달됩니다.\n- 콜백 대기열: 비동기 작업이 완료되면 해당 콜백이 콜백 대기열에 배치됩니다.\n- 이벤트 루프: 이벤트 루프는 지속적으로 호출 스택과 콜백 대기열을 확인합니다. 호출 스택이 비어 있으면 대기열에서 첫 번째 콜백을 가져와 실행을 위해 스택에 푸시합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n/assets/img/2024-07-06-AsyncProgramminginJavaScriptvsPython_0.png\n\n[YouTube Link](https://www.youtube.com/watch?v=eiC58R16hb8)\n\nCallbacks\n\n초반에 JavaScript는 비동기 작업을 처리하기 위해 콜백을 사용했습니다. 콜백은 다른 함수로 전달되는 함수로, 이후에 외부 함수 내에서 호출되어 특정 루틴이나 작업을 완료하는 데 사용됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예시:\n\n```js\nfunction fetchData(callback) {\n  setTimeout(() =\u003e {\n    callback(\"데이터를 가져왔어요\");\n  }, 1000);\n}\nfetchData((message) =\u003e {\n  console.log(message);\n});\n```\n\n콜백은 기능적이지만 종종 \"콜백 지옥\"이라고 알려진 깊게 중첩된 구조로 이어질 수 있어 코드를 읽기 어렵게 만들기도 합니다.\n\n프로미스\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n약속은 비동기 작업을 처리하는 더 깔끔하고 관리하기 쉬운 방법을 제공합니다. 이들은 현재 이용 가능하거나 미래에 이용 가능할 수도 있고 아예 없을 수도 있는 값을 나타냅니다. 약속은 연결할 수 있고 콜백보다 중첩될 가능성이 적습니다.\n\n예시:\n\n```js\nlet fetchData = new Promise((resolve, reject) =\u003e {\n  setTimeout(() =\u003e {\n    resolve(\"Data fetched\");\n  }, 1000);\n});\nfetchData.then((message) =\u003e {\n  console.log(message);\n});\n```\n\n약속은 콜백 지옥을 피하고 더 나은 오류 처리 메커니즘을 제공하여 비동기 코드의 가독성을 크게 향상시킵니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n비동기/대기\n\nECMAScript 2017에서 도입된 async 및 await 키워드는 프로미스 위에 구문 설탕을 제공하여 비동기 코드가 동기 코드처럼 보이고 동작하도록 만들어줍니다. 이를 통해 코드를 작성, 읽고 유지하기가 더 쉬워집니다.\n\n예시:\n\n```js\nasync function fetchData() {\n  let promise = new Promise((resolve, reject) =\u003e {\n    setTimeout(() =\u003e resolve(\"데이터를 가져왔습니다\"), 1000);\n  });\n  let result = await promise;\n  console.log(result);\n}\nfetchData();\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nasync/await 구문을 사용하면 개발자가 직관적이고 선형적인 비동기 코드를 작성할 수 있어서 복잡한 비동기 작업을 관리하는 데 따르는 인지 부하를 줄일 수 있습니다.\n\n구현 내부:\n\n- async 함수는 항상 Promise를 반환합니다.\n- await 키워드는 async 함수의 실행을 일시 중지시키고, 계속하기 전에 Promise가 해결되거나 거부될 때까지 기다립니다.\n\n## Python에서의 비동기 프로그래밍\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAsyncio 모듈\n\n파이썬의 비동기 프로그래밍을 위한 주요 메커니즘은 Python 3.4에서 도입된 asyncio 모듈입니다. asyncio는 JavaScript와 유사한 이벤트 루프를 제공하지만 명시적으로 호출해야 합니다. 이 모듈은 협력적인 멀티태스킹을 지원하여 개발자가 단일 스레드 내에서 여러 작업을 관리할 수 있도록 합니다.\n\nAsyncio 작동 방식:\n\n- 이벤트 루프: asyncio의 핵심인 이벤트 루프는 asyncio 작업 및 콜백을 실행하고 네트워크 I/O 작업을 수행하며 서브프로세스를 실행합니다.\n- 코루틴: 일시 중지 및 재개할 수 있는 async def로 정의된 함수들입니다.\n- 작업: 코루틴을 감싸서 이벤트 루프에서 실행할 수 있도록 하는 래퍼입니다.\n- 퓨처: 아직 사용 가능하지 않을 수 있는 비동기 작업의 결과를 나타냅니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n코루틴\n\n파이썬에서 코루틴은 async def를 사용하여 정의되며, 일시 중지되고 재개될 수 있는 함수들로, 비동기 프로그래밍에 적합합니다. 코루틴은 직접 대기하거나 이벤트 루프에서 실행되도록 스케줄링하여 대기해야 합니다.\n\n예시:\n\n```python\nimport asyncio\nasync def fetch_data():\n    await asyncio.sleep(1)\n    return \"데이터 가져오기 완료\"\nasync def main():\n    result = await fetch_data()\n    print(result)\nasyncio.run(main())\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n코루틴은 파이썬의 비동기 프로그래밍의 중추를 이루며, 여러 작업을 동시에 실행할 수 있게 합니다.\n\n작업과 미래\n\nasyncio는 작업(Task)과 미래(Future)와 같은 구조체를 제공하여 코루틴의 동시 실행을 처리할 수 있게 합니다. 작업은 백그라운드에서 실행할 수 있도록 코루틴을 감싸는 래퍼이며, 미래는 아직 사용 가능하지 않은 결과를 나타냅니다.\n\n예시:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport asyncio\nasync def fetch_data():\n    await asyncio.sleep(1)\n    return \"Data fetched\"\nasync def main():\n    task = asyncio.create_task(fetch_data())\n    result = await task\n    print(result)\nasyncio.run(main())\n```\n\nTasks and Futures Internals:\n\n- Tasks: 작업을 생성하면 이벤트 루프에서 실행할 수 있도록 예약됩니다. 작업은 코루틴을 실행하고 그 실행을 관리합니다.\n- Futures: 퓨처는 처음에는 알려지지 않지만 어느 시점에는 사용 가능한 결과를 나타내는 객체입니다. 퓨처는 일반적으로 동기 및 비동기 코드 간의 다리를 제공하기 위해 하위 수준 API에 사용됩니다.\n\n## JavaScript와 Python 비동기 프로그래밍 비교\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n**이벤트 루프 및 논블로킹 I/O**\n\n![AsyncProgramminginJavaScriptvsPython_1](/TIL/assets/img/2024-07-06-AsyncProgramminginJavaScriptvsPython_1.png)\n\n**구문 및 가독성**\n\n![AsyncProgramminginJavaScriptvsPython_2](/TIL/assets/img/2024-07-06-AsyncProgramminginJavaScriptvsPython_2.png)\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n성능\n\n/assets/img/2024-07-06-AsyncProgramminginJavaScriptvsPython_3.png\n\n생태계 및 라이브러리\n\n/assets/img/2024-07-06-AsyncProgramminginJavaScriptvsPython_4.png\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n사용 사례\n\n/assets/img/2024-07-06-AsyncProgramminginJavaScriptvsPython_5.png\n\nPython의 asyncio 모듈은 코루틴을 사용하여 단일 스레드 동시 코드를 작성할 수 있도록 강력한 비동기 프로그래밍 프레임워크를 제공합니다. 그러나 성능을 더욱 향상시키고자 하는 경우, uvloop는 기본 이벤트 루프에 대안적인 솔루션을 제공합니다.\n\n## uvloop란 무엇인가요?\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nuvloop은 Python의 asyncio 모듈을 위한 이벤트 루프 구현체로, Node.js의 이벤트 루프를 구동하는 libuv 라이브러리를 기반으로 합니다. 기본 이벤트 루프를 uvloop로 대체하면, I/O 바운드 애플리케이션에서 상당한 성능 향상을 얻을 수 있습니다.\n\n## uvloop의 주요 기능\n\n- 고성능: uvloop은 빠를 것으로 설계되어 있습니다. asyncio 작업의 오버헤드를 크게 줄여, Node.js의 성능 수준과 유사한 성능을 제공할 수 있습니다.\n- 호환성: uvloop은 asyncio API와 완벽하게 호환되어, 기존 애플리케이션에 최소한의 변경으로 통합하기 쉽습니다.\n- 신뢰성: libuv 기반으로 만들어진 uvloop은 이 실전 경험에 기반을 둔 안정성과 견고함을 상속받았습니다.\n\n## uvloop 설치하기\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\npip install uvloop\n```\n\n## asyncio로 uvloop 사용하기\n\nasyncio 애플리케이션에서 이벤트 루프로 uvloop를 사용하려면 기본 이벤트 루프로 설정해야 합니다. 다음은 그 방법입니다:\n\n```js\nimport asyncio\nimport uvloop\n\nasync def fetch_data():\n    await asyncio.sleep(1)\n    return \"데이터 가져옴\"\n\nasync def main():\n    data = await fetch_data()\n    print(data)\n\nif __name__ == \"__main__\":\n    # uvloop를 기본 이벤트 루프로 설정\n    asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())\n    asyncio.run(main())\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 예시에서는 메인 코루틴을 실행하기 전에 uvloop를 기본 이벤트 루프 정책으로 설정합니다. 이렇게 함으로써 모든 asyncio 작업이 uvloop의 고성능 이벤트 루프를 사용하도록 보장됩니다.\n\n## 웹 서버\n\n다양한 I/O 작업을 처리하는 웹 서버는 uvloop에서 큰 이점을 얻을 수 있습니다. aiohttp와 Sanic과 같은 프레임워크는 uvloop를 활용하여 요청 처리 성능을 향상시킬 수 있습니다.\n\naiohttp를 활용한 예시:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nfrom aiohttp import web\nimport uvloop\n\nasync def handle(request):\n    return web.Response(text=\"안녕, 세상\")\n\napp = web.Application()\napp.add_routes([web.get('/', handle)])\n\nif __name__ == \"__main__\":\n    web.run_app(app, loop=uvloop.new_event_loop())\n```\n\n# 결론\n\n자바스크립트와 파이썬 모두 풍부한 비동기 프로그래밍 기능을 갖추고 있지만, 그들의 접근 방식은 내재적인 설계 철학과 런타임 환경의 차이로 인해 다릅니다. 자바스크립트의 비동기 프로그래밍은 단일 스레드 및 이벤트 기반 아키텍처와 긴밀하게 통합되어 웹 개발에 매우 효율적입니다. 파이썬의 asyncio는 언어에 강력한 비동기 기능을 제공하며 다양한 응용 프로그램에 적합하지만 조금 더 많은 보일러플레이트 코드가 필요합니다.\n\n파이썬에서 asyncio 기반 애플리케이션에 uvloop을 통합함으로써 Node.js의 성능 수준을 달성할 수 있으면서도 파이썬의 풍부한 생태계와 사용 편의성을 계속 누릴 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n참고 자료:\n\n- [https://youtu.be/8aGhZQkoFbQ?si=xYY9tHFrJzKLRaok](https://youtu.be/8aGhZQkoFbQ?si=xYY9tHFrJzKLRaok)\n- [https://www.youtube.com/watch?v=eiC58R16hb8](https://www.youtube.com/watch?v=eiC58R16hb8)\n","ogImage":{"url":"/assets/img/2024-07-06-AsyncProgramminginJavaScriptvsPython_0.png"},"coverImage":"/TIL/assets/img/2024-07-06-AsyncProgramminginJavaScriptvsPython_0.png","tag":["Tech"],"readingTime":12}],"page":"48","totalPageCount":50,"totalPageGroupCount":3,"lastPageGroup":10,"currentPageGroup":2},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"48"},"buildId":"olPs1cVezSGTqD7OaewDI","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>