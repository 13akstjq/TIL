<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>TIL</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//posts/5" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="TIL" data-gatsby-head="true"/><meta property="og:title" content="TIL" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//posts/5" data-gatsby-head="true"/><meta name="twitter:title" content="TIL" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/7978fe7362f7d4c9.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/7978fe7362f7d4c9.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/873-eb138c3217d71553.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/posts/%5Bpage%5D-de1dc5579188f9be.js" defer=""></script><script src="/TIL/_next/static/jKAIrnIuHBv4ZHjiQbX6i/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/jKAIrnIuHBv4ZHjiQbX6i/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="강화 학습을 이용한 동적 가격 책정 최적화 방법" href="/TIL/post/2024-07-14-OptimizingDynamicPricingwithReinforcementLearning"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="강화 학습을 이용한 동적 가격 책정 최적화 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-OptimizingDynamicPricingwithReinforcementLearning_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="강화 학습을 이용한 동적 가격 책정 최적화 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">강화 학습을 이용한 동적 가격 책정 최적화 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">16<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="네트워크 과학으로 예측한 다음에 죽을 왕좌의 게임 캐릭터는 누구" href="/TIL/post/2024-07-14-NetworkSciencePredictsWhoDiesNextinGameofThrones"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="네트워크 과학으로 예측한 다음에 죽을 왕좌의 게임 캐릭터는 누구" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-NetworkSciencePredictsWhoDiesNextinGameofThrones_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="네트워크 과학으로 예측한 다음에 죽을 왕좌의 게임 캐릭터는 누구" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">네트워크 과학으로 예측한 다음에 죽을 왕좌의 게임 캐릭터는 누구</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="벨만-포드 알고리즘으로 최단 경로 찾는 방법" href="/TIL/post/2024-07-14-FindShortestPathsWithBellman-Ford"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="벨만-포드 알고리즘으로 최단 경로 찾는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-FindShortestPathsWithBellman-Ford_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="벨만-포드 알고리즘으로 최단 경로 찾는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">벨만-포드 알고리즘으로 최단 경로 찾는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Python에서 BERT를 사용한 토픽 모델링 방법" href="/TIL/post/2024-07-14-TopicModellingwithBERTtopicinPython"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Python에서 BERT를 사용한 토픽 모델링 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-TopicModellingwithBERTtopicinPython_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Python에서 BERT를 사용한 토픽 모델링 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Python에서 BERT를 사용한 토픽 모델링 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="데이터 과학에서 자주 오해받는 5가지 단어" href="/TIL/post/2024-07-14-FiveMassivelyMisusedWordsinDataScience"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="데이터 과학에서 자주 오해받는 5가지 단어" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-FiveMassivelyMisusedWordsinDataScience_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="데이터 과학에서 자주 오해받는 5가지 단어" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">데이터 과학에서 자주 오해받는 5가지 단어</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="코드 없는 GenAI 에이전트 워크플로우 오케스트레이션 로컬 Mistral AI 모델과 함께하는 AutoGen Studio 사용법" href="/TIL/post/2024-07-14-NoCodeGenAIAgentsWorkflowOrchestrationAutoGenStudiowithLocalMistralAImodel"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="코드 없는 GenAI 에이전트 워크플로우 오케스트레이션 로컬 Mistral AI 모델과 함께하는 AutoGen Studio 사용법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-NoCodeGenAIAgentsWorkflowOrchestrationAutoGenStudiowithLocalMistralAImodel_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="코드 없는 GenAI 에이전트 워크플로우 오케스트레이션 로컬 Mistral AI 모델과 함께하는 AutoGen Studio 사용법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">코드 없는 GenAI 에이전트 워크플로우 오케스트레이션 로컬 Mistral AI 모델과 함께하는 AutoGen Studio 사용법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="선형 회귀 쉽게 이해하기  실생활 예시와 함께하는 초보자 가이드" href="/TIL/post/2024-07-14-SimplifyingLinearRegressionABeginnersGuidewithareal-worldPracticalExample"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="선형 회귀 쉽게 이해하기  실생활 예시와 함께하는 초보자 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-SimplifyingLinearRegressionABeginnersGuidewithareal-worldPracticalExample_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="선형 회귀 쉽게 이해하기  실생활 예시와 함께하는 초보자 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">선형 회귀 쉽게 이해하기  실생활 예시와 함께하는 초보자 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Django로 튼튼한 웹 애플리케이션을 만드는 15가지 팁" href="/TIL/post/2024-07-14-15TipsforBuildingRobustWebApplicationswithDjango"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Django로 튼튼한 웹 애플리케이션을 만드는 15가지 팁" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-15TipsforBuildingRobustWebApplicationswithDjango_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Django로 튼튼한 웹 애플리케이션을 만드는 15가지 팁" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">Django로 튼튼한 웹 애플리케이션을 만드는 15가지 팁</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="PySpark의 Repartition 진실 놀랄 준비 하세요" href="/TIL/post/2024-07-14-TheTruthAboutPySparksRepartitionPreparetoBeSurprised"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="PySpark의 Repartition 진실 놀랄 준비 하세요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-TheTruthAboutPySparksRepartitionPreparetoBeSurprised_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="PySpark의 Repartition 진실 놀랄 준비 하세요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">PySpark의 Repartition 진실 놀랄 준비 하세요</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="데이터 사이언스 마스터를 위한 11가지 필수 Python Matplotlib 시각화" href="/TIL/post/2024-07-14-11EssentialPythonMatplotlibVisualizationsforDataScienceMastery"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="데이터 사이언스 마스터를 위한 11가지 필수 Python Matplotlib 시각화" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/TIL/assets/img/2024-07-14-11EssentialPythonMatplotlibVisualizationsforDataScienceMastery_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="데이터 사이언스 마스터를 위한 11가지 필수 Python Matplotlib 시각화" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><span class="writer">TIL</span></div><strong class="PostList_title__loLkl">데이터 사이언스 마스터를 위한 11가지 필수 Python Matplotlib 시각화</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 14, 2024</span><span class="PostList_reading_time__6CBMQ">16<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/TIL/posts/1">1</a><a class="link" href="/TIL/posts/2">2</a><a class="link" href="/TIL/posts/3">3</a><a class="link" href="/TIL/posts/4">4</a><a class="link posts_-active__YVJEi" href="/TIL/posts/5">5</a><a class="link" href="/TIL/posts/6">6</a><a class="link" href="/TIL/posts/7">7</a><a class="link" href="/TIL/posts/8">8</a><a class="link" href="/TIL/posts/9">9</a><a class="link" href="/TIL/posts/10">10</a><a class="link" href="/TIL/posts/11">11</a><a class="link" href="/TIL/posts/12">12</a><a class="link" href="/TIL/posts/13">13</a><a class="link" href="/TIL/posts/14">14</a><a class="link" href="/TIL/posts/15">15</a><a class="link" href="/TIL/posts/16">16</a><a class="link" href="/TIL/posts/17">17</a><a class="link" href="/TIL/posts/18">18</a><a class="link" href="/TIL/posts/19">19</a><a class="link" href="/TIL/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"강화 학습을 이용한 동적 가격 책정 최적화 방법","description":"","date":"2024-07-14 20:13","slug":"2024-07-14-OptimizingDynamicPricingwithReinforcementLearning","content":"\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-OptimizingDynamicPricingwithReinforcementLearning_0.png\" /\u003e\n\n# 1. 소개\n\n소매 가격 전략은 매출과 이익을 최적화하는 데 중요합니다. 효과적인 가격 책정은 수요, 시장 상황 및 경쟁을 고려하여 소비자 행동을 영향을 주고 매출을 극대화합니다. 예를 들어 소매업체는 가격을 전략적으로 조정하고 할인을 적용하여 매출을 촉진하고 수익을 증가시킬 수 있습니다.\n\n본 논문은 Deep Deterministic Policy Gradient (DDPG) 알고리즘을 사용한 강화 학습 접근 방식을 통해 가격 전략을 최적화하는 것을 탐구합니다. 가격과 할인을 동적으로 조정함으로써 가격 결정을 개선할 수 있습니다. 또한 SHAP (Shapley Additive Explanations) 값은 모델의 결정에 미치는 가격, 할인 및 매출의 영향에 대한 통찰을 제공합니다. 이러한 복합 접근 방식은 실시간 분석 및 설명 가능한 인공지능 기술을 통합하여 전통적인 가격 모델을 향상시킵니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 2. 소매 업계의 가격 정책 모델링\n\n소매 업계의 가격 정책은 수익과 이윤을 최적화하기 위해 수학적으로 모델링될 수 있습니다. 매출 기능은 다음과 같이 작성할 수 있습니다:\n\n![매출 기능](/TIL/assets/img/2024-07-14-OptimizingDynamicPricingwithReinforcementLearning_1.png)\n\n이는 매출이 주로 가격과 할인과 같은 여러 요소에 의존한다는 것을 의미합니다. 일반적으로 가격이 증가하면 매출이 감소하고 그 반대도 마찬가지입니다. 최적의 가격을 찾아 매출이나 이윤을 극대화하는 것이 목표입니다. 예를 들어, 매출 기능이 이차 함수를 따른다면:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![optimization](/TIL/assets/img/2024-07-14-OptimizingDynamicPricingwithReinforcementLearning_2.png)\n\n상수 a와 b가 있는 경우, 최적화 기법으로는 이차 또는 선형 프로그래밍을 사용하여 최적 가격을 찾을 수 있습니다.\n\n하지만 전통적인 최적화 방법에는 한계가 있습니다. 실시간 적응성이 부족해 즉각적인 시장 변화에 기초한 효율적인 가격 조정이 어려울 수 있습니다. 또한 판매에 영향을 미치는 요소에 대한 사전지식이 필요한데, 동적인 시장에서는 항상 실행 가능하지 않을 수 있습니다.\n\n실시간 데이터 및 강화 학습과 같은 고급 머신러닝 모델은 이러한 도전에 대한 해결책을 제공합니다. 이러한 모델은 가격 전략을 동적으로 조정하고 다양한 요소의 영향을 분석하여 소매 환경에서 더 효과적이고 반응력있는 가격 결정을 지원할 수 있습니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 3. Pricing Strategies를 위한 강화 학습\n\n강화 학습 (RL)은 환경과 상호 작용하여 누적 보상을 극대화하기 위해 최적의 조치를 학습하는 기계 학습 기술입니다. 우리의 가격 전략에서는:\n\n- 환경: 소매 시장\n- 에이전트: 가격 모델\n- 목표: 가격과 할인을 동적으로 조정하여 매출과 이윤을 최적화\n\n우리는 실시간 의사 결정에 이상적인 정책 기반 및 가치 기반 학습을 결합한 Deep Deterministic Policy Gradient (DDPG) 알고리즘을 활용합니다. DDPG의 작동 방식은 다음과 같습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n정책 기반 학습: 강화 학습의 정책 함수인 액터-네트워크를 사용합니다:\n\n![Policy-Based Learning](/TIL/assets/img/2024-07-14-OptimizingDynamicPricingwithReinforcementLearning_3.png)\n\n상태 s가 주어진 경우 동작 a를 선택합니다. θ^π는 정책 네트워크의 매개변수입니다.\n\n가치 기반 학습: 비평가 네트워크(Q 함수)를 사용합니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](/TIL/assets/img/2024-07-14-OptimizingDynamicPricingwithReinforcementLearning_4.png)\n\n행동-가치 함수를 평가하기 위해.\n\n학습 과정:\n\n- Actor-Critic 아키텍처: Actor는 기대값 반환의 그래디언트를 따라 정책을 업데이트하며, Critic은 벨만 방정식을 사용하여 가치 추정을 업데이트합니다.\n- Experience Replay: 과거 경험 (s,a,r,s′)을 재생 버퍼에 저장하여 상관 관계를 끊고 학습을 안정화합니다.\n- Target Networks: 학습을 안정화하도록 학습된 네트워크를 천천히 추적하기 위해 목표 네트워크 세트 θ^π′ 및 θ^Q′를 유지합니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nDDPG의 장점은 다음과 같습니다:\n\n- 적응성: DDPG는 최신 시장 데이터를 기반으로 실시간으로 조정을 제공합니다.\n- 세밀한 결정: 연속적인 액션 공간은 정확한 가격 조정을 가능하게 합니다.\n- 데이터 기반 통찰력: 다양한 요소(가격, 할인 등)가 매출에 미치는 영향을 이해하는 데 도움이 되어 보다 효과적인 가격 전략을 도와줍니다.\n\n# 4. 코딩 및 데이터 실험\n\n이제 강화 학습(RL) 프레임워크 내에서 딥 디터미니스틱 정책 그라디언트(DDPG) 알고리즘을 구현하여 소매 가격 전략을 최적화해봅니다. 이 접근 방식은 매출과 이익을 극대화하기 위해 가격과 할인을 동적으로 조정합니다. 게다가, SHAP(Shapley Additive Explanations) 분석을 사용하여 모델 결정에 각 기능이 미치는 영향을 이해하여 RL 기반 가격 모델의 해석 가능성을 향상시킵니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n강화학습 환경 설정:\n\n- 환경 초기화: 우리는 맞춤 gym 환경인 SalesPredictionEnv를 정의합니다. 이 환경은 소매 시장을 시뮬레이션합니다. 환경은 초기 가격과 할인을 입력으로 받고 진짜 판매 기능을 사용하여 판매를 시뮬레이션합니다. 액션 공간은 가격과 할인을 연속적으로 조정할 수 있으며 관찰 공간에는 현재 가격, 할인 및 예측된 판매가 포함됩니다.\n\n```python\nclass SalesPredictionEnv(gym.Env):\n    def __init__(self, initial_price, initial_discount, true_sales_function):\n        super(SalesPredictionEnv, self).__init__()\n        self.initial_price = initial_price\n        self.initial_discount = initial_discount\n        self.true_sales_function = true_sales_function\n\n        self.action_space = spaces.Box(low=-0.1, high=0.1, shape=(2,), dtype=np.float32)\n        self.observation_space = spaces.Box(low=0, high=np.inf, shape=(3,), dtype=np.float32)\n\n        self.price = self.initial_price\n        self.discount = self.initial_discount\n        self.sales = self.true_sales_function(self.price, self.discount)\n        self.done = False\n\n    def reset(self, seed=None, options=None):\n        super().reset(seed=seed)\n        self.price = self.initial_price\n        self.discount = self.initial_discount\n        self.sales = self.true_sales_function(self.price, self.discount)\n        return np.array([self.price, self.discount, self.sales], dtype=np.float32), {}\n\n    def step(self, action):\n        self.price += action[0]\n        self.discount += action[1]\n        new_sales = self.true_sales_function(self.price, self.discount)\n\n        reward = -abs(self.sales - new_sales)\n        self.sales = new_sales\n        self.done = False\n\n        return np.array([self.price, self.discount, self.sales], dtype=np.float32), reward, False, False, {}\n\n    def render(self, mode='human'):\n        print(f'Price: {self.price}, Discount: {self.discount}, Sales: {self.sales}')\n```\n\n진짜 판매 함수: 그런 다음 가격, 할인 및 판매 간의 관계를 모델링하는 판매 함수를 정의합니다. 이 함수는 강화학습(RL) 구현에서 소매 환경을 시뮬레이션할 수 있습니다. RL 에이전트가 다양한 가격과 할인 수준이 판매에 어떤 영향을 미치는지 이해할 수 있도록 합니다. 이 함수는 다음과 같이 공식화됩니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ndef true_sales_function(가격, 할인):\n    return -0.5 * 가격 ** 2 + 가격 + 11 + 2 * 할인\n```\n\n실제 세계의 강화학습 구현에서는 이러한 함수들이 종종 과거 판매 데이터, 경험적 연구 또는 도메인 전문 지식을 기반으로 실제 시장 행위를 모방하는 데 사용됩니다. 이 이차 함수 형태는 중간 가격 상승이 판매를 촉진할 수 있지만, 과도한 가격이나 할인은 전반적인 판매에 부정적인 영향을 미칠 수 있다.\n\n환경 및 모델 설정: check_env를 사용하여 환경을 초기화합니다. 그런 다음 환경에 DDPG 에이전트를 설정합니다.\n\n```js\nenv = SalesPredictionEnv(initial_price=5.0, initial_discount=1.0, true_sales_function=true_sales_function)\ncheck_env(env)\nmodel = DDPG('MlpPolicy', env, verbose=1)\nmodel.learn(total_timesteps=10000)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nSHAP 분석:\n\nSHAP (Shapley Additive Explanations)은 각 특징이 예측에 미치는 영향을 양적으로 설명하여 모델을 해석 가능하게 합니다. RL 설정에서 SHAP를 구현하는 과정은 다음과 같습니다:\n\n- SHAP를 위한 데이터 수집: 환경을 재설정하고 SHAP 분석을 위해 상태와 행동을 수집합니다.\n\n```js\nobs, _ = env.reset()\nstates = []\nactions = []\nfor _ in range(10):\n    action, _states = model.predict(obs)\n    obs, rewards, terminated, truncated, _ = env.step(action)\n    env.render()\n    states.append(obs)\n    actions.append(action)\n\nstates = np.array(states)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nSHAP 예측 래퍼: SHAP의 올바른 출력 형식을 보장하기 위해 래퍼 함수를 정의합니다.\n\n```js\ndef predict_wrapper(observations):\n    predictions = []\n    for obs in observations:\n        action, _states = model.predict(obs)\n        predictions.append(action.flatten())\n    return np.array(predictions)\n```\n\n예측 DataFrame: 예측을 저장할 DataFrame을 생성하고 추가 분석을 위해 Excel 파일에 저장합니다.\n\n```js\npredictions = {\n    'ID': list(range(len(states))),\n    'price': states[:, 0],\n    'discount': states[:, 1],\n    'sales': states[:, 2],\n    'predicted_action_0': [None] * len(states),\n    'predicted_action_1': [None] * len(states)\n}\n\nfor idx, state in enumerate(states):\n    action, _states = model.predict(state)\n    predictions['predicted_action_0'][idx] = action[0]\n    predictions['predicted_action_1'][idx] = action[1]\n\npredictions_df = pd.DataFrame(predictions)\npredictions_df.to_excel(\"reinforcement_learning_predictions.xlsx\", index=False)\nprint(predictions_df.head(10))\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nSHAP Explainer 및 Visualization: 우리는 SHAP를 사용하여 모델의 의사결정에 미치는 다른 feature들의 영향을 분석하고 결과를 시각화합니다.\n\n```js\nexplainer = shap.Explainer(predict_wrapper, states)\nshap_values = explainer(states)\n\nshap_values_price = shap_values[..., 0]\n\nshap.plots.beeswarm(shap_values_price)\nshap.plots.bar(shap_values_price[0])\n```\n\n상위 영향력 있는 feature들: 각 state의 상위 영향력 있는 feature들을 추출하여 DataFrame에 저장하여 쉬운 분석을 할 수 있습니다.\n\n```js\ndata = {\n    'ID': list(range(len(states))),\n    'price': states[:, 0],\n    'discount': states[:, 1],\n    'sales': states[:, 2],\n    'top_feature1': [None] * len(states),\n    'top_feature2': [None] * len(states),\n    'importance1': [None] * len(states),\n    'importance2': [None] * len(states)\n}\n\nfeatures = ['price', 'discount', 'sales']\nfor i in range(len(states)):\n    sorted_indices = np.argsort(-np.abs(shap_values.values[i][:, 0]))\n    data['top_feature1'][i] = features[sorted_indices[0]]\n    data['importance1'][i] = shap_values.values[i][sorted_indices[0], 0]\n\n    if len(sorted_indices) \u003e 1:\n        data['top_feature2'][i] = features[sorted_indices[1]]\n        data['importance2'][i] = shap_values.values[i][sorted_indices[1], 0]\n\nreason_df = pd.DataFrame(data)\nprint(reason_df.head(10))\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 5. 분석과 인사이트\n\n다음의 SHAP 막대 그래프는 Price(가격), Discount(할인) 및 Sales(판매)가 특정 인스턴스에 대한 모델의 가격 결정에 미치는 영향을 보여줍니다:\n\n- SHAP 막대 그래프는 Price(가격), Discount(할인) 및 Sales(판매)가 특정 인스턴스에 대한 모델의 가격 결정에 미치는 영향을 보여줍니다:\n- Sales(판매): 가장 높은 긍정적 영향을 나타내며, 높은 판매량이 모델이 가격과 할인을 유지하거나 높이는 데 강력한 영향을 미친다는 것을 시사합니다.\n- Discount(할인): 높은 할인은 결과에 부정적인 영향을 미치며, 과도한 할인을 피하기 위해 할인액을 줄이는 것을 권장하는 모델의 결론으로 이어집니다.\n- Price(가격): 약간의 긍정적 영향을 나타내며, 결과를 향상시키기 위해 가격을 약간 올리는 것을 선호하는 모델이고 판매량에 큰 영향을 미치지 않는다는 것을 나타냅니다.\n\n![이미지](/TIL/assets/img/2024-07-14-OptimizingDynamicPricingwithReinforcementLearning_5.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n모델은 가격 책정 전략을 안내하기 위해 판매를 우선시하며, 수익을 극대화하기 위해 신중한 할인 관리와 약간의 가격 인상을 권장합니다. 막대 도표는 모델의 특정 사례에 대한 가격 결정에 영향을 미치는 Sales, Price 및 Discount가 어떻게 변하는지를 강조합니다.\n\n다음은 SHAP beeswarm 도표로, 여러 사례에 걸쳐 Price, Discount 및 Sales가 모델의 가격 결정에 미치는 영향을 보여줍니다:\n\n- Sales (Feature 2): 높은 값(빨강)은 모델의 출력을 증가시키고, 낮은 값(파랑)은 감소시킵니다.\n- Price (Feature 0): 낮은 값(파랑)은 부정적인 영향을 미치며, 더 높은 값(빨강)은 긍정적인 영향을 미칩니다.\n- Discount (Feature 1): 높은 값(빨강)은 모델의 출력을 감소시키고, 낮은 값(파랑)은 긍정적인 영향을 미칩니다.\n\n![도표 이미지](/TIL/assets/img/2024-07-14-OptimizingDynamicPricingwithReinforcementLearning_6.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n벌집 그림은 매출, 가격 및 할인이 모델의 결정에 미치는 영향이 여러 인스턴스에 걸쳐 어떻게 변하는지를 제공하여 그들이 모델의 결정에 미치는 중요성과 일관성을 강조합니다.\n\n예측된 작업 테이블은 다른 기능에 대한 모델의 예측을 제시합니다:\n\n![Predicted Actions Table](/TIL/assets/img/2024-07-14-OptimizingDynamicPricingwithReinforcementLearning_7.png)\n\n- 가격 조정: 가격에 대한 예측된 작업은 약간 부정적이며(예측 작업 0), 가격이 감소함에 따라 약간의 인하를 시사합니다.\n- 할인 조정: 할인에 대한 예측된 작업(예측 작업 1)도 약간 부정적이며, 소폭의 감소를 나타냅니다. 모델은 수익성을 유지하기 위해 신중한 할인을 권장하는 일관된 경향을 보입니다.\n- 매출 영향: 가격과 할인이 감소함에 따라 매출이 증가하며, 전형적인 시장 행동을 반영합니다. 모델이 가격과 할인을 약간 감소시킨 것은 수익성을 유지하면서 매출을 최적화할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nFeature Importance Table은 각 인스턴스에 대해 모델 결정에 영향을 줄인 최상위 두 가지 기능과 그 중요도 값을 식별합니다:\n\n- 판매량: 모든 인스턴스에서 가장 중요한 기능(top_feature1)으로 일관되게 나타납니다.\n- 가격 및 할인: 교체 가능 기능(top_feature2)은 다양한 중요도 값을 가지며, 판매량에 높은 중요도 값이 해당 기능이 모델 예측에 미치는 강력한 영향을 나타냅니다.\n\n![image](/TIL/assets/img/2024-07-14-OptimizingDynamicPricingwithReinforcementLearning_8.png)\n\n요약하면, 판매가격은 모델의 가격 결정에서 우세한 요소이며, 가격 및 할인은 보조이지만 중요한 역할을 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 6. 결론\n\n본 연구는 소매 가격 전략을 최적화하기 위해 Deep Deterministic Policy Gradient (DDPG) 알고리즘을 활용합니다. 강화 학습 (RL)과 SHAP (Shapley Additive Explanations)을 결합하여 가격 및 할인을 조정하여 매출과 이익을 극대화할 수 있습니다.\n\n장점:\n\n- 적응성: 전통적인 가격 모델과 달리 RL은 실시간 데이터로부터 계속 학습하여 시장 변화에 즉각 대응할 수 있습니다.\n- 정밀성: DDPG의 연속적인 행동 공간은 섬세한 가격 결정을 가능하게 합니다.\n- 통찰력: SHAP 값은 다양한 요인의 영향에 대한 설명 가능한 통찰력을 제공하여 의사 결정 투명성을 향상시킵니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n단점:\n\n- 복잡성: 강화 학습 모델을 구현하는 데는 상당한 컴퓨팅 자원과 전문 지식이 필요합니다.\n- 데이터 의존성: 강화 학습의 효과는 사용 가능한 데이터의 품질과 양에 매우 의존합니다.\n- 안정성: 동적 환경에서 안정적인 학습을 보장하는 것은 어려울 수 있으며 하이퍼파라미터를 세심히 조정해야 합니다.\n\n개선 제안:\n\n- 혼합 모델: 강화 학습과 전통적 최적화 방법을 결합함으로써 안전성과 성능을 향상시킬 수 있습니다.\n- 향상된 데이터 통합: 고객 피드백 및 경쟁사 가격과 같은 다양한 데이터 원본을 통합하여 모델의 정확성을 향상시킬 수 있습니다.\n- 확장성: 확장 가능한 강화 학습 프레임워크를 개발하여 소매 세그먼트와 시장 전반에 이러한 방법을 도움이 될 수 있습니다.\n- 지속적인 모니터링: 비즈니스 목표 및 시장 조건과 일치하는 모델의 결정을 보장하기 위해 모니터링 및 검증 프로세스를 구현합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nGitHub의 내 저장소에 있는 Python 스크립트는 다음과 같습니다: [datalev001/Reinforcement_price](https://github.com/datalev001/Reinforcement_price)","ogImage":{"url":"/TIL/assets/img/2024-07-14-OptimizingDynamicPricingwithReinforcementLearning_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-OptimizingDynamicPricingwithReinforcementLearning_0.png","tag":["Tech"],"readingTime":16},{"title":"네트워크 과학으로 예측한 다음에 죽을 왕좌의 게임 캐릭터는 누구","description":"","date":"2024-07-14 20:11","slug":"2024-07-14-NetworkSciencePredictsWhoDiesNextinGameofThrones","content":"\n\n\n![Network Science Predicts Who Dies Next in Game of Thrones](/TIL/assets/img/2024-07-14-NetworkSciencePredictsWhoDiesNextinGameofThrones_0.png)\n\n# 소셜 네트워크 분석과 머신 러닝은 최근 몇 년간 수많은 응용 분야에서 사용되고 있습니다. 예를 들어, 2017년에 이루어진 이 짧은 프로젝트는 몇 가지 미디어 관심을 끌었는데, 주된 목표는 네트워크 과학과 예측 모델링을 결합하여 인기 있는 TV 및 도서 시리즈인 'Game of Thrones'의 주요 캐릭터들 중 어떤 이들이 그들의 최후를 맞이할 가능성이 높은지 예측하는 것이었습니다.\n\n# 1. 소개\n\n이 글은 2017년에 발표된 두 개의 블로그 포스트 [1, 2]를 요약한 것으로, 이들은 네트워크 과학, 예측 모델링, TV 프로그램 (및 책 시리즈적 적응) 'Game of Thrones'을 결합하여 시리즈의 그 당시 에피소드에서 주요 인물들이 그들의 최후를 맞이할 가능성이 높은 캐릭터를 식별하기 위해 노력했습니다. 다양한 미디어에서 받은 높은 관심으로 인해 [4–10], 저자는 이 프로젝트를 요약하였습니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 프로젝트에서는 TV 시리즈의 라벨이 붙은 자막을 기반으로 작업했어요. 여기에는 발화된 텍스트 뿐만 아니라 발화자의 이름도 포함되어 있었죠. 게다가 사용된 데이터셋 [11]은 서로 다른 장면 사이의 구분 요소에 대한 정보를 가지고 있었어요. 이 두 가지 정보를 결합하여 모든 장면에 나타나는 캐릭터 목록을 추출했어요. 총 600명 정도였죠. 그런 다음 이러한 장면을 쇼의 사회 시스템의 기본 구성 요소로 가정하고 웨스테로스의 사회 지도를 작성하는 데 사용했어요. 이 네트워크에서 각 주요 캐릭터는 네트워크 노드로 표시되며, 같은 장면에서 함께 출연한 경우에는 두 플레이어 사이에 연결이 있어요. 게다가, 그들이 함께 출연하는 빈도가 더 높을수록 연결이 더 강해져요. 그런 다음 이러한 캐릭터(네트워크 노드)의 다양한 네트워크 중심성 측정 값을 계산하여 예측 기능으로 사용했고, 이들 캐릭터가 6시즌 동안 살았는지 여부를 라벨링했어요. 마지막으로, 아직 살아있는 캐릭터 중 어떤 캐릭터가 죽을 가능성이 높은지 예측하기 위해 널리 사용되는 선형 모델인 서포트 벡터 머신을 적용했어요.\n\n두 번째 섹션에서는 처음 6시즌의 자막을 기반으로 한 원래 예측에 대한 자세한 내용이 소개되었습니다. 세 번째 섹션에서는 7시즌 이후의 예측이 업데이트되었어요. 나중에 추가된 요약은 최종 결과에 대한 간단한 평가를 제공해요.\n\n# 2. 왕좌의 게임 예측\n\n왕좌의 게임의 새 시즌이 곧 다가오며 팬들은 무엇을 기대할지 흥분하고 있어요. 제가 즐겼던 캐릭터 중 어떤 캐릭터가 죽을 것인지, 누가 다음 시즌에 살아남을지 궁금해서 혼자만은 아니에요. 그래서 캐릭터들을 순위 매기기로 결정했어요. 왕좌의 게임은 사회적 위치와 진정한 친구들이 꽤 중요한 복잡한 세계이기 때문에 각 캐릭터의 사회 상호 작용 패턴을 네트워크 과학 도구를 사용하여 양적으로 표현했어요. 그런 다음 기계 학습 방법을 사용하여 그들의 운명을 예측했죠.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2.1. 웨스테로스의 네트워크 만들기\n\n데이터 원본으로는 팬 웹사이트 [11]에서 대화 형식으로 수집된 쇼 자막을 사용했습니다. 불행하게도 2, 3 시즌 대부분의 에피소드가 누락되어 있지만, 나머지 네 시즌에는 거의 600개의 장면이 포함된 일관된 형식으로 제공됩니다.\n\n먼저 왕국 사회 체계의 집계된 네트워크를 구축했습니다. 이 네트워크에서 각 노드는 이야기의 캐릭터를 나타내고 각 쌍의 캐릭터 사이의 연결 가중치는 그들의 사회적 상호 작용의 강도를 상징합니다. 사회 상호 작용의 기본 단위로 장면을 고려했습니다 (평균 에피소드에는 약 스무 개의 장면이 포함됩니다). 이는 한 장면에서 한 번 (두 번) 나온 모든 사람들이 강도가 하나 (둘)인 관계를 가지며, 장면 내에서는 모든 사람이 서로 연결되어 있다는 것을 의미합니다. 다시 말하면, 장면은 모든 사람들 간의 관계를 한 단계씩 높여 모두가 서로 강하게 연결된 완전 그래프 또는 클리크입니다. 이러한 장면 수준의 완전 네트워크를 계산한 다음 이를 집계하여 우리는 웨스테로스의 글로벌 사회 네트워크 (도식 1)에 도달하게 되며, 거의 400개의 노드와 3000개 이상의 엣지를 갖습니다.\n\n네트워크 시각화에서 (도식 1) 위대한 가문의 모든 구성원은 서로 다른 색상으로 표시됩니다 (예: 파랑 - 스타크, 빨강 - 란니스터, 노랑 - 마텔). 다른 사람들은 회색으로 표시됩니다. 노드 크기는 각 사람이 가진 연락처 수에 비례하며 가장 인기 있는 캐릭터 이름이 레이블로 추가됩니다. 연결 중심성이 매우 낮은 흥미로운 없는 노드는 걸러집니다. 월 주변 야인들 주변에 분리된 공동체가 보이며, 요한 스노우 주변의 사람들은 왕국의 나머지와의 연락이 거의 없다는 것을 보여줍니다. 티리온은 별도의 역할을 맡고 있습니다: 그는 다이네리스 타거리엔를 네트워크의 중앙에 있는 왕의 땅을 포함하여 연결하고 있습니다. 이곳에서 두 개의 큰 공동체를 볼 수 있습니다. 이들은 스타크와 란니스터 그리고 스타크와 탈리 가문 간의 결속 및 란니스터와 마텔 간의 갈등과 같은 영향영역 및 상호작용을 형성하여 이야기의 핵심부에서 밀집된 웹을 형성하고 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n수학으로 넘어가 봅시다. 우리는 노드의 중요성을 측정할 수 있는 다양한 지표를 계산할 수 있어요. 우리는 이러한 측정값을 캐릭터에 연결하여 이 사회 생태계에서의 중요성을 설명할 거예요. 이러한 측정값 중 일부는 i) 노드 차수 — 사람이 가지는 연락 수; ii) 가중치된 차수 — 특정 노드의 엣지 가중치 총합; iii) 클러스터링 — 노드의 연락처 쌍이 자주 연락하는 정도; 그리고 iv) 중심성, 그 노드가 얼마나 정보 흐름에서 다리 역할을 하는지를 나타내는 중요도, 다른 노드 쌍 사이의 최단 경로 상에 얼마나 자주 위치하는지를 측정합니다 (Table 2). 중요한 사람과 중요하지 않은 사람을 더 잘 파악할 뿐만 아니라, 어떤 캐릭터가 최초 6시즌에서 사망했는지 데이터로부터 알아낼 수도 있어요. 그래서 우리의 목표는 네트워크 위치와 생존을 연결하는 것입니다: 한 가지를 다른 가지와 연결시키는 것은 가능할까요? 다시 말해, 캐릭터가 사망했는지 여부를 예측하는 데 어떤 네트워크 측정값이 도움이 될지 알아내기 위해 알고리즘을 훈련하고 싶어요.\n\n**2.2. 예측**\n\n우리에게는 관심 있는 94명의 캐릭터 집합이 있어요. 모든 캐릭터는 사회적인 중요성의 다양한 측면을 나타내는 일곱 가지 다른 네트워크 기반 특성으로 설명됩니다. 또한 우리는 그 중 61명이 이미 사망한 캐릭터를 알고 있어요. 이 지식을 바탕으로 우리는 누가 곧 죽을지 굉장히 예측할 수 있어요: 아직 살아 있는 사람 중에서 이미 사망한 사람과 비슷한 특성을 가진 사람은 누구일까요? 이 문제는 데이터 과학에서 널리 연구된 이탈 문제와 비슷합니다. 다양한 분류 기반 알고리즘으로 이 문제를 해결할 수 있어요. 이 분석에서는 가장 정확한 Support Vector Machine (SVM)을 사용했어요. 이 알고리즘은 Python에서 쉽게 사용할 수 있어요. 이 기능을 집에서 시도해보고 싶다면 사용해보세요.\n\n기계 학습 알고리즘은 모든 특성을 고려하고 대상 변수의 가능한 값을 예측합니다. 이를 위해 샘플 데이터를 무작위로 테스트 세트와 훈련 세트로 분할하고 여러 번 반복해 예측을 수행한 후 최종 결과를 평가합니다. 이 교차 검증 전략을 통해 SVM 분류기는 경우의 72.3%에서 올바른 클래스(사망 또는 생존)를 예측했어요. 데이터의 규모와 성격을 고려하면 이는 만족스러운 결과입니다. 정확성을 설명하기 위해 모델은 8명의 캐릭터가 사망해서는 안 되지만 이야기 속에서는 그런 캐릭터들이 사망했음을 말해요 — 여왕의 죽음은 왕보다 덜 가능성이 있다는 것인데, 그리고 강력한 친구들이 그를 구할 수 없었던 진노스 슬린트도 그렇습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Network Science Predicts Who Dies Next in Game of Thrones](/TIL/assets/img/2024-07-14-NetworkSciencePredictsWhoDiesNextinGameofThrones_1.png)\n\n다른 유형의 특징(예: 성별, 귀족 가문의 일원 여부, 연설의 감정 분석)을 포함하거나 보다 완전한 데이터셋을 사용하거나 TV 프로그램을 책과 비교하는 등의 작업은 예측의 정확성을 높일 수 있습니다. 또한, 이 모델은 Jon Snow가 죽었다가 부활하거나 Benjen Stark가 중간 어딘가에 있는 등의 불일치를 무시합니다.\n\n2.3. 결과 — 스포일러 주의\n\nSVM 모델을 사용하여 각 살아있는 잘 알려진 캐릭터가 죽을 확률을 얻을 수 있습니다. 네트워크 측정값들은 종종 매우 상관관계가 있기 때문에 단독으로 높은 예측력을 가진 하나 또는 둘을 선택할 수 없지만, 보이는 바와 같이 betweenness가 높고 clustering이 낮으며 차수가 높은 캐릭터들은 죽을 가능성이 더 낮습니다. 어쨌든 기계 학습 접근 방식의 강점은 많은 특징들 중에서 숨겨진 관계를 발견하는 것입니다. 예측 중에 5-fold 교차 검증을 사용하였고, 이를 100번 반복하여 각 확률의 통계적 값 및 오차에 대한 추정을 얻었습니다. 마지막으로, 최종 예측 모델에 따라 생존 순으로 순위 매겨진 캐릭터 목록이 여기에 있습니다 (테이블 2).\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Network Science Predicts Who Dies Next in Game of Thrones](/TIL/assets/img/2024-07-14-NetworkSciencePredictsWhoDiesNextinGameofThrones_2.png)\n\n이 목록은 많은 흥미로운 것을 알려줍니다. 첫째, 다네리스는 상당히 죽을 가능성이 높아 보이며, 많은 추측과 겹칩니다. 반면 티리온과 존 스노우는 비교적 안전해 보입니다. 둘째, 항상 인기 있는 아리아 스타크와 덜 친절한 하운드는 이미 죽을 위기를 여러 차례 겪었는데도 위험한 위치에 있습니다. 놀랍게도 현재 철 왕좌에 앉아있는 세르세이와 그곳에 오르려는 베일리시는 훨씬 좋은 위치에 있는 것으로 보입니다. 조라 몰몬트는 화파병에 대한 치료법을 찾을 것으로 보이며, 그가 겪어온 모든 것에도 불구하고 테온 그레이조이는 아마도 살아남을 것입니다. 안타깝게도, 에린 가족에 대해서는 그렇지 못할 것으로 보입니다.\n\n# 3. 게임 오브 스론 예측 2.0\n\n뜻밖의 소식을 가져오고 끊임없는 논쟁을 일으킨 게임 오브 스론 7시즌이 끝났고 중요한 캐릭터들을 자연스럽게 죽였습니다. 그래서 이제 이전 예측을 검증할 수 있는 기회가 왔습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n3.1. 지금까지 무슨 일이 있었나요?\n\n이전 블로그 게시물에서 TV 프로그램의 에피소드를 사용하여 웨스테로스 왕국의 소셜 네트워크를 만들고 죽은 캐릭터와 살아있는 캐릭터의 다양한 중심성 매개변수를 결정하고, 각 살아있는 캐릭터가 죽을 가능성을 예측하기 위해 서포트 벡터 머신 모델을 사용했습니다. 결과는 살아있는 캐릭터들이 시리즈 종료 전에 죽을 가능성에 따라 순위가 매겨진 캐릭터 목록 형태로 나왔습니다. 제 예측은 시간을 고려하지 않습니다: 캐릭터가 첫 번째 에피소드에서 즉시 죽을지 또는 막바지에야 죽을지는 예측하지 않습니다. 그래서 최종 시즌은 아직 남아 있지만, 모델의 예비 결과에 대해 이야기하고 싶습니다. 이전 예측은 34명의 잘 알려진 캐릭터의 운명을 다루었으며, 그 중 대부분은 최신 시즌에 나타났습니다. 그러나 그중에는 지금까지 4명이 죽었는데, 만약 죽음이 무작위로 발생했다면 모든 캐릭터가 죽을 확률은 대략 11%를 의미합니다. 모델의 한계와 단순함에도 불구하고, 상당히 잘 수행했습니다(Table 3): 목록의 처음에 있는 타인, 그리고 올레나 타이렐과 페티르 베일리쉬의 사망을 예측했지만, 타인의 자매 사망은 예측하지 못했습니다. 반면, 조라는 (죽을 것으로 생각되는) 치명적인 질병에 대한 치료법을 발견하고 생존할 것으로 예측한 것이 맞았습니다. 마찬가지로, 테온은 모든 고통을 겪었음에도 계속해서 살아갈 것이라는 것에 대한 정확한 예측이었습니다.\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-NetworkSciencePredictsWhoDiesNextinGameofThrones_3.png\" /\u003e\n\n3.2. 예측 2.0\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이전에 소개된 방법론을 사용하여 캐릭터들의 사망 확률에 기반한 현재 순위도 계산해보았어요. 이 정보는 약간의 스포일러가 포함되어 있으니 이 게시물의 끝에서 확인할 수 있어요.\n\n가장 중요한 이벤트는 의심할 여지 없이 다네리스와 존, 그리고 세르세이와의 만남입니다. 이것이 바로 이 네트워크의 (도식 2) 이전에 연결되지 않았던 도메인들이 마침내 연결되었다는 의미에요 (도식 3). 이를 통해 많은 새로운 연결이 생성되고 원래의 소셜 네트워크가 변형되며, 이는 또한 캐릭터들의 예측된 미래를 바꾸게 된다고 해요. 제1-6 시즌을 기반으로 한 중심 캐릭터들의 필터링된 네트워크는 도식 2에서 확인할 수 있고, 1-7 시즌을 기반으로 한 네트워크는 도식 3에 나와 있어요. 노드는 연결 강도의 총량에 비례하는 크기로 캐릭터들을 나타내고, 색상은 7 시즌에 등장하는 대가문을 나타내는 색으로 설정되어 있어요 (파란색 - 스타크, 빨간색 - 란니스터, 마젠타색 - 타르가르엔, 초록색 - 타이렐, 노란색 - 그레이조이).\n\n![Figure 2](/TIL/assets/img/2024-07-14-NetworkSciencePredictsWhoDiesNextinGameofThrones_4.png)\n\n![Figure 3](/TIL/assets/img/2024-07-14-NetworkSciencePredictsWhoDiesNextinGameofThrones_5)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n리스트와 네트워크를 통해 몇 가지 사실을 추론할 수 있습니다:\n\n- 거의 모든 네트워크 측정을 기반으로 중요한 캐릭터인 Jon;\n- Bran은 결국 행동에 가까워졌는데, 그는 불길한 미래를 암시하는 것으로 보입니다;\n- Daenerys는 영향력 있는 친구들을 충분히 얻었는데, 그러나 그녀 주변의 사람들이 그녀의 임무를 위해 희생될 수도 있습니다;\n- Cersei 주변의 사람들이 사라지는 것을 보면 (그림 3에서 란니스터 가문과 유사한 작은 빨간 지역을 보십시오), 그녀와 가까이 있는 사람들에게 영향을 미치는 것 같습니다;\n- Theon과 Jorah는 생존할 가능성이 높아 보이며 (아마 이전 경험에 기반할지도 모릅니다);\n- 많은 사람들에게 친애받는 와일링 Tormund는 폐쇄되는 성벽에서 탈출뿐만 아니라 전쟁 전체에서도 생존할 것으로 보입니다.\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-NetworkSciencePredictsWhoDiesNextinGameofThrones_6.png\" /\u003e\n\n# 4. 결론\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nFigure 4에서 예측된 확률이 87% 미만에서 명확한 신호와 일치하지 않았지만 무작위 기준선(동전 던지기로 예측을 구축했다면 얻을 확률) 주변에 매우 겹치고 변동했습니다. 그러나 예측된 적중이 실제 적중과 매우 겹치는 87% 이상의 임계값을 넘어서 빠르고 명확한 증가를 보았습니다. 이 결론은 네트워크 특징이 '왕좌의 게임'에서 가장 명백한 죽음을 포착할 수 있었다는 것을 시사합니다. 그러나 불확실한 상황에서는 잘 작동하지 않았을 수 있습니다.\n\n![Image](/TIL/assets/img/2024-07-14-NetworkSciencePredictsWhoDiesNextinGameofThrones_7.png)\n\n부정확성과 한계는 여러 가지 차원이 있습니다. 먼저, 데이터의 청결함과 양을 개선할 수 있었을 것입니다. 둘째, 데이터 형식과 특징을 확장할 수 있었고, 예를 들어, 인물에 대한 메타 정보(예: 나이, 성별)를 이용하여 네트워크 특징을 보강하고 TV 시리즈 및 원작 책에서 정보를 결합할 수 있습니다. 마지막으로 가장 흥미로운 사항은 예측된 기간인 시즌 7과 8이 책을 기반으로 하지 않았다는 점입니다. 한편 다른 훈련 데이터는 그랬습니다. 이 차원은 성이 구축된 방식에 대한 논리가 어떻게 구성되었는지에 대한 관점에서 매우 중요하지만, 양적 방법으로 연구하기가 매우 어렵고 분명한 미래 연구 대상이 될 것입니다.\n\n# 5. 데이터 접근성\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 연구와 관련된 지원 파일은 https://github.com/milanjanosov/GameOfThron에서 찾을 수 있습니다.\n\n## 6. 면책 조항\n\n블로그 게시물은 원본 형태 그대로 섹션 두와 세에 게시되었지만, 일부 오타 및 문법 문제가 수정되었습니다. 이는 텍스트 의미에 영향을 미치지 않았습니다.\n\n## 7. 감사의 글\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저자는 중앙 유럽 대학교 학술 글쓰기 센터의 Ágnes Diós-Tóth, Thomas Rooney 및 Robin Bellers에게 이 논문과 원본 블로그 포스트의 여러 부분을 검토해 준 것에 대해 감사의 말씀을 전합니다.","ogImage":{"url":"/TIL/assets/img/2024-07-14-NetworkSciencePredictsWhoDiesNextinGameofThrones_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-NetworkSciencePredictsWhoDiesNextinGameofThrones_0.png","tag":["Tech"],"readingTime":12},{"title":"벨만-포드 알고리즘으로 최단 경로 찾는 방법","description":"","date":"2024-07-14 20:09","slug":"2024-07-14-FindShortestPathsWithBellman-Ford","content":"\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-FindShortestPathsWithBellman-Ford_0.png\" /\u003e\n\n최단 경로 찾기는 컴퓨터 과학에서 기본적인 문제로, 네트워크 라우팅 프로토콜부터 그래프 분석까지 다양한 알고리즘과 응용프로그램의 기초를 형성합니다. 현실에서는 물류 및 통신 네트워크에서 효율적인 경로를 찾고 여행 시간을 최소화하는 데 핵심적인 문제입니다.\n\n이 문제가 이렇게 중요하기 때문에 많은 사람들이 이를 해결하는 방법에 대해 고민했습니다. 이는 다양한 가정과 실행 시간을 가진 다양한 알고리즘의 동물원으로 이어졌습니다. 이 글에서는 벨만-포드 알고리즘의 작동 방식과 Python 및 Rust에서의 구현 방법을 보여 드리고자 합니다.\n\n# (Shimbel-)벨만-포드(-무어) 알고리즘\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n알고리즘의 이름부터 헷갈릴 수 있어요. 문헌에서는 벨만-포드 알고리즘으로 알려져 있지만 많은 사람들이 관여했습니다. Alexander Schrijver의 논문 \"조합 최적화의 역사에 대하여\"에 따르면, Alfonso Shimbel은 1955년에 동등한 알고리즘을 개발했고, Richard Bellman과 Lester Ford Jr.은 각각 1958년과 1956년에 이 알고리즘을 설명했습니다. 이후 Edward F. Moore가 1959년에 알고리즘의 변형을 발표했어요. 하지만 걱정하지 마세요, 이 알고리즘 자체는 그 역사보다 이해하기 쉬워요.\n\n이들의 알고리즘은 여러분이 주어진 그래프의 고정된 노드에서 시작하여 다른 각 노드까지의 최단 경로 문제를 해결해요. 다음과 같은 그래프를 예시로 삼아볼게요:\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-FindShortestPathsWithBellman-Ford_1.png\" /\u003e\n\n총 6개의 방향성이 있는 에지로 연결된 네 개의 노드를 볼 수 있어요. 각 에지는 가중치가 있습니다. 예를 들어, 3에서 0으로 가는 에지의 가중치는 1이에요. 노드 0에서 노드 2로의 최단 경로는 직접적인 0-2가 아닌 총 비용이 (-1)+1+0 = 0인 0-1-3-2일 수 있어요. 이제 이러한 경로를 알고리즘적으로 찾는 고수준 아이디어에 대해 이야기해볼게요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 아이디어\n\n알고리즘은 시작 노드로부터 i개 이하의 엣지를 사용하여 다른 모든 노드까지의 최단 경로의 길이를 배열 형태로 유지하는 간단한 아이디어를 중심으로 돌아갑니다.\n\n이 배열을 i = 0, 1, ...부터 순차적으로 계산합니다. 각 반복에서 i에 대한 정보는 이전 반복 i-1의 배열과 그래프의 엣지를 사용합니다.\n\n## 예시\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자 그럼 이제 작은 예제를 사용해보자. 노드 0에서 다른 모든 노드로 가는 최단 경로 길이를 찾고 싶다고 가정해보자. 나중 단계에서 실제 경로도 재구성할 것이지만, 일단은 일 노드 간의 경로 길이에만 관심을 갖자.\n\n거리 배열을 [0, ∞, ∞, ∞]로 시작한다. 즉, 우리는 최대 edge 0을 사용하여 0 노드에서 0 노드로 총 길이 0만큼 도달할 수 있다는 것이다. 이것은 우리가 정한 정의다. 두 번째 항목은 0 노드에서 1 노드로 최대 edge 0을 사용하여 ∞ 길이로 도달할 수 있음을 의미하는데, 즉 해당 노드에 도달할 수 없다는 것이다. 동일한 이유로 0 노드에서 2와 3으로 가는 것도 동일하다.\n\n거리를 해당 노드 옆에 써보자:\n\n![이미지](/TIL/assets/img/2024-07-14-FindShortestPathsWithBellman-Ford_2.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음 반복에서는 최소경로 길이를 포함하는 다른 배열 [a, b, c, d]를 채우려고 합니다. 이 배열은 노드 0에서 최대 한 개의 엣지를 사용하여 다른 모든 노드까지의 최단 경로 길이를 포함합니다. 이전 배열을 사용하여 이를 어떻게 계산하는지 살펴봅시다. 예를 들어, 노드 0에서 1까지의 최단 경로 길이를 알고 싶다면 두 가지 가능성이 있습니다:\n\n- 0에서 1까지 엣지를 사용하지 않고 이동하거나\n\n- 0에서 1까지 추가 엣지를 사용하여 이동합니다.\n\n옵션 1은 이전 배열 [0, ∞, ∞, ∞]에서 볼 수 있듯이 길이가 ∞입니다. 두 번째 옵션의 길이는 -1이며 그래프를 통해 노드 0에서 노드 1로 -1의 비용으로 이동할 수 있습니다. 분명히 이전에 보았던 ∞보다 -1이 더 작으므로 배열에 이를 넣어 보겠습니다. 다른 노드에 대해 동일한 작업을 수행하면 업데이트된 배열 [0, -1, 1, ∞]이 됩니다. 이제 이 반복이 완료되었습니다.\n\n그래픽적으로表시하면:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/TIL/assets/img/2024-07-14-FindShortestPathsWithBellman-Ford_3.png)\n\n다음 이터레이션에서는 같은 게임을 다시 합니다. 노드 0에서 다른 모든 노드로 가는 최단 경로 길이가 최대 두 개의 변을 사용하여 [a, b, c, d]를 채우고 싶습니다. 예를 들어, 노드 0에서 노드 3까지의 최단 경로 길이를 계산해 봅시다. 노드 0에서 노드 3으로 가는 여러 옵션이 있습니다:\n\n- 단일 변을 사용하여 0에서 3으로 이동: 길이는 이전 이터레이션의 배열에서 볼 수있는대로 ∞입니다.\n- 먼저 노드 1로 이동한 다음 1에서 3으로 가는 변을 사용할 수 있습니다. 하나의 변만 사용하여 노드 1로 가는 데 드는 비용은 배열에서 확인할 수 있는대로 -1입니다. 노드 1에서 노드 3으로 한 단계 더 가는 데 드는 비용은 그래프에서 확인할 수 있는대로 1입니다. 따라서 이미 이전 옵션보다 작은 비용인 0으로 노드 0에서 노드 3에 도달할 수 있습니다.\n- 먼저 노드 2로 이동한 다음 2에서 3으로 가는 변을 사용할 수 있습니다. 따라서 노드 0에서 노드 3으로 2 단계로 도달하여 비용은 1 + 2 = 3입니다.\n\n다른 옵션이 없으므로 두 번째 옵션에서 최단 경로 길이는 0입니다. 다른 노드에 대해도 수행하면 배열 [0, -1, 1, 0]을 얻을 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![이미지](/TIL/assets/img/2024-07-14-FindShortestPathsWithBellman-Ford_4.png)\n\n이전 배열 [0, -1, 1, 0]에서 시작하는 한 번 더의 반복 작업을 합니다. 이번 반복에서는 노드 0에서 노드 2로의 최단 경로 길이가 변하는 것 외에는 큰 변화가 없습니다. 이전 배열에서 볼 수 있듯이, 최대 두 개의 엣지를 사용하여 길이가 1인 것을 알 수 있습니다. 그러나 처음에 우리는 실제로 길이가 (-1) + 1 + 0 = 0인 0–1–3–2의 최단 경로를 보았습니다. 우리는 현재 반복에서 이 경로 길이를 찾을 것이며, 그러면 알고리즘이 종료됩니다. 이것은 네 개의 노드를 가지면 최단 경로가 최대 세 개의 엣지만을 포함해야 하거나 일반적으로 N 노드를 가지면 N— 1개의 엣지를 포함해야 하기 때문입니다.\n\n![이미지](/TIL/assets/img/2024-07-14-FindShortestPathsWithBellman-Ford_5.png)\n\n## 음수 순환이란\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마지막 문장에서 조금 거짓말을 한 것 같아요. 음의 순환이 존재할 수 있다는 건데요, 예를 들어 노드 u에서 자신으로 돌아와 경로의 총 길이가 0보다 작은 것입니다. 이 경우 순환을 돌 때마다 경로의 길이를 줄일 수 있기 때문에 최단한 경로가 없는 것이죠. 음의 순환을 찾으려면 N개의 노드가 있을 때 N번째 반복을 실행해야 합니다. 음의 순환하지 않는다면 이 반복에서 우리 배열이 변하지 않아야 합니다. 이것이 여전히 변경된다면, 어딘가에 음의 순환이 있다는 것을 알 수 있습니다. 이를 복원할 수도 있지만, 여기서는 그렇게 하지 않겠습니다.\n\n# 구현\n\n작은 코드량에 대한 많은 글입니다. 두 가지 다른 프로그래밍 언어인 Python과 Rust로 어떻게 하는지 살펴봅시다.\n\n## Python\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기 있습니다. 제가 경로 길이 뿐만 아니라 가장 짧은 경로를 재구성할 수 있는 다른 배열 prev도 계산합니다.\n\n```js\nN = 4\ngraph = {0: {1: -1, 2: 1}, 1: {3: 1}, 2: {3: 2}, 3: {0: 1, 2: 0}}\nstart = 0\n\ndists = [float(\"inf\") for i in range(N)]\nprev = [None for i in range(N)]\n\ndists[start] = 0\nprev[start] = start\n\nfor _i in range(N):\n    for node, edges in graph.items():            # 모두에 대해 반복\n        for next_node, weight in edges.items():  # `node`에서 시작하는 모든 간선에 대해 반복\n            candidate_length = dists[node] + weight\n            if candidate_length \u003c dists[next_node]:\n                dists[next_node] = candidate_length\n                prev[next_node] = node # `node`에서 `next_node`로 이동하는 것이 이전 경로보다 나은 것\n\nfor node, edges in graph.items():\n    for next_node, weight in edges.items():\n        if dists[node] + weight \u003c dists[next_node]:\n            print(\"음의 사이클이 감지되었습니다!\")\n\nprint(dists)\nprint(prev)\n```\n\n출력은 다음과 같습니다.\n\n```js\n[0, -1, 0, 0]\n[0, 0, 3, 1]\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n첫 번째 배열은 노드 0부터 노드 0, 1, 2 및 3으로 가는 가장 짧은 경로가 각각 0, -1, 0 및 0임을 나타냅니다.\n\n노드 0에서 노드 2로 길이가 0인 경로를 어떻게 얻을 수 있을까요? 두 번째 배열 prev를 살펴봅시다. 거기서 prev[2] == 3 이므로 노드 3에서 노드 2로 이동합니다. 따라서 경로는 3–2로 끝납니다. 또한 노드 3에서 노드 1로 이동한다는 것을 알 수 있습니다. 따라서 경로는 1–3–2로 끝납니다. 그리고 노드 1에서 노드 0으로 이동한다는 것을 알 수 있습니다. 따라서 전체 경로는 0–1–3–2 입니다.\n\n좋아요, Rust에서 같은 작업을 해봅시다!\n\n## Rust\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n한 줄 씩 번역해 보았습니다. Rust에 관심이 있는 분들에게 도움이 될 수도 있을 것 같아요.\n\n```rust\nuse std::collections::HashMap;\n\nfn main() {\n    const N: usize = 4;\n    let graph: HashMap\u003cusize, HashMap\u003cusize, f32\u003e\u003e = HashMap::from([\n        (0, HashMap::from([(1, -1.), (2, 1.)])),\n        (1, HashMap::from([(3, 1.)])),\n        (2, HashMap::from([(3, 2.)])),\n        (3, HashMap::from([(0, 1.), (2, 0.)])),\n    ]);\n    let start: usize = 0;\n\n    let mut dists = [f32::INFINITY; N];\n    let mut prev = [None::\u003cusize\u003e; N];\n\n    dists[start] = 0.0;\n    prev[start] = Some(start);\n\n    for _i in 0..N - 1 {\n        for (node, edges) in graph.iter() {\n            for (next_node, weight) in edges.iter() {\n                let candidate_length = dists[*node] + *weight;\n                if candidate_length \u003c dists[*next_node] {\n                    dists[*next_node] = candidate_length;\n                    prev[*next_node] = Some(*node);\n                }\n            }\n        }\n    }\n\n    for (node, edges) in graph.iter() {\n        for (next_node, weight) in edges.iter() {\n            if dists[*node] + *weight \u003c dists[*next_node] {\n                println!(\"Negative cycle detected!\");\n            }\n        }\n    }\n\n    println!(\"{:?}\", dists);\n    println!(\"{:?}\", prev);\n}\n```\n\n## 실행 시간과 메모리\n\n이 알고리즘은 그래프의 노드 수를 의미하는 N과 그래프의 간선 수를 의미하는 E에 대해 O(N · E) 시간에 실행된다는 것을 확인할 수 있어요. 이는 모든 N 노드를 순회하는 루프와 모든 E 간선을 순회하는 내부 루프가 중첩되어 있기 때문에 나타나는 직접적인 결과입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n메모리 사용량 측면에서는 추가로 크기가 N인 두 개의 배열과 몇 개의 상수만 저장하면 되므로 추가 메모리 복잡도는 O(N)이 됩니다.\n\n프로그래밍 언어의 성능 측정가들을 위해: 내 Python 버전은 평균적으로 노드당 10개의 이웃을 갖는 랜덤 1000개 노드 그래프에서 3초가 걸렸지만, Rust 버전은 동일한 그래프에서 0.5초가 걸렸습니다.\n\n# 결론\n\n이 글에서는 한 노드로부터 모든 노드까지의 최단 경로 길이와 최단 경로를 찾는 방법을 배웠습니다. 이를 위해 우리는 벨만-포드 알고리즘을 선택했습니다. 이 알고리즘은 빠르고 간단하며 효율적으로 구현할 수 있으며 추가 메모리를 많이 사용하지 않는 편리한 알고리즘입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n더 빠른 알고리즘인 다익스트라 알고리즘을 사용할 수는 없지만, 우리 예시에는 사용할 수 없습니다. 다익스트라 알고리즘은 양의 간선 가중치를 전제로 하기 때문이죠. 그래서 약간의 음의 간선 가중치를 더해 다른 알고리즘을 사용해야 했어요. 😉\n\n그래서 최단 경로 알고리즘을 구현하거나 이를 대신 처리해주는 라이브러리를 사용해야 할 때, 그 알고리즘이 어떻게 작동하는지 이해하게 되었으면 합니다.\n\n오늘 새롭고 흥미로운 가치있는 것을 배우셨기를 바랍니다. 읽어주셔서 감사합니다!","ogImage":{"url":"/TIL/assets/img/2024-07-14-FindShortestPathsWithBellman-Ford_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-FindShortestPathsWithBellman-Ford_0.png","tag":["Tech"],"readingTime":11},{"title":"Python에서 BERT를 사용한 토픽 모델링 방법","description":"","date":"2024-07-14 20:08","slug":"2024-07-14-TopicModellingwithBERTtopicinPython","content":"\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-TopicModellingwithBERTtopicinPython_0.png\" /\u003e\n\n토픽 모델링(즉, 텍스트 데이터 코퍼스에서의 토픽 식별)은 라텐트 디리클레 할당(LDA) 모델이 발표된 이후 빠르게 발전해왔습니다. 그러나 이 클래식한 토픽 모델은 단어들 간의 관계를 잘 포착하지 못합니다. 왜냐하면 단어 가방이라는 통계적 개념에 기반하기 때문입니다. 최근에는 임베딩 기반의 Top2Vec와 BERTopic 모델이 사전 훈련된 언어 모델을 활용하여 토픽을 생성함으로써 이러한 단점을 극복하고 있습니다.\n\n이 기사에서는 Maarten Grootendorst의 (2022) BERTopic을 사용하여 정치 연설 원고에서 토픽을 대표하는 용어를 식별할 것입니다. 이 모델은 다양한 코퍼스에서의 토픽 모델링 지표에서 전통적이고 현대적인 대부분의 토픽 모델을 능가하며, 기업, 학계(Chagnon, 2024) 및 공공부문에서 활용되어왔습니다. 우리는 다음을 파이썬 코드를 통해 살펴볼 것입니다:\n\n- 데이터를 효과적으로 전처리하는 방법\n- Bigram 토픽 모델을 생성하는 방법\n- 시간이 지남에 따라 가장 빈번한 용어를 탐색하는 방법.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 1. 예제 데이터\n\n예제 데이터 세트로는 Efat et al. (2023) 논문의 일환으로 공개된 Empoliticon: Political Speeches-Context \u0026 Emotion 데이터 세트를 사용합니다. 해당 데이터 세트는 국제 저작권 4.0 라이센스에 따라 출시되었으며 미국, 영국, 중국 및 러시아 대통령/총리의 정치 연설 2010개의 대본을 포함하고 있습니다. 주제 모델을 더 집중시키기 위해 하위 집합에는 러시아 리더들의 556개 연설만 포함되어 있습니다:\n\n![image](/TIL/assets/img/2024-07-14-TopicModellingwithBERTtopicinPython_1.png)\n\n# 2. 데이터 전처리\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n텍스트 데이터셋 작업은 복잡합니다. 단순한 정리만으로도 데이터셋에서 모든 불필요한 정보를 체계적으로 제거해야 하는 여러 단계가 필요합니다. 이 프로젝트의 모든 요구 사항을 확인해 주세요.\n\n### 2.1. 못 읽는 문자(mojibake) 오류 수정\n\n못 읽는 문자(mojibake)는 문자 인코딩 오류로 인해 나타나는 혼란스러운 텍스트를 의미하는 일본어 단어입니다. 다음은 예시입니다:\n\n![example](/TIL/assets/img/2024-07-14-TopicModellingwithBERTtopicinPython_2.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n클리닝을 시작하기 전에 이 단계를 포함하는 것이 유용합니다. 인코딩 관련 오류를 수정하는 것은 간단합니다:\n\n2.2. 특수 문자, 구두점 및 숫자 정리\n\n이 단계는 인코딩 오류를 수정한 후에 바로 이어져야 합니다. 가장 간단한 방법은 cleantext 라이브러리를 사용하는 것입니다. 또한 소문자화를 고려하세요. 데이터 집합에서 \"노동\"과 \"Labor\"가 같은 의미인가요? 그렇다면 lowercase 매개변수를 추가하고 클리닝 함수를 적용하십시오:\n\n2.3. 불용어 제거 전략 정의\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n일반적으로 불용어 목록을 제거하는 것은 필수적입니다. 프로젝트의 초점에 따라, 가치를 더하지 않는 추가적인 불용어 목록에서 데이터를 정리하는 것도 유용할 수 있습니다. BERTopic의 문서에 작성된 것처럼:\n\n대신, 주제 모델 생성 중 임베딩을 생성한 후 문서를 전처리하는 데 CountVectorizer를 사용합니다.\n\n# 3. 주제 생성\n\n보다 깔끔한 데이터셋으로, 영어 불용어와 추가 불용어 목록을 제거하고, 주제 바이그램 모델을 생성한 후 데이터에 적용할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nnr_topics parameter은 7로 설정되어 있으며, 6개의 토픽을 생성합니다. 나머지 토픽은 이상치를 유지하는 데 사용됩니다.\n\n# 4. 토픽 시각화\n\n다음 단계에서는 결과를 더 잘 표현하기 위해 히트맵으로 데이터를 시각화해보겠습니다. 결과는 다음과 같습니다:\n\n![Topic Modelling with BERT topic in Python](/TIL/assets/img/2024-07-14-TopicModellingwithBERTtopicinPython_3.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래와 같이 하겠습니다. 토픽 모델에서 바이그램과 그 확률을 추출하여 6개 주제에 대한 데이터 프레임을 작성할 것입니다:\n\n다음으로, 이 코드는 Figure 1에 히트맵을 생성합니다.\n\n## 5. 시간별 토큰 빈도\n\n이제, 시간에 따른 바이그램의 발전에 대한 관점을 추가할 것입니다. 러시아 지도자의 연설에서 어떤 연도에 바이그램이 가장 자주 사용되었는지 살펴볼 것입니다. Figure 2의 히트맵은 각 연도별로 5개 가장 빈도가 높은 바이그램의 빈도를 표시합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](/TIL/assets/img/2024-07-14-TopicModellingwithBERTtopicinPython_4.png)\n\nThe arabica library, which is now forthcoming in the Journal of Open Source Software (Koráb \u0026 Poměnková, 2024), was developed for this purpose. Here is the code generating the heatmap in Figure 2:\n\n![image](/TIL/assets/img/2024-07-14-TopicModellingwithBERTtopicinPython_5.png)\n\n# Conclusions\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 기사는 BERTopic을 사용한 토픽 모델링에 대해 간단히 소개했습니다. 이 모델의 프레임워크는 다양한 확장, 세밀 조정 및 시각화 방법을 제공합니다(문서 참조). 주요 결과를 요약해보겠습니다:\n\n- 토픽 모델은 방어 정책(토픽 1), 경제 발전(토픽 2), 제2차 세계대전(토픽 3), 내부 정책(토픽 4), 건강 및 인구통계(토픽 5), 교육(토픽 6)에 대해 6가지 명확한 토픽을 보여줍니다.\n- Arabica와 BERTopic을 결합하면 외교 및 방위 정책 토픽(“군사”, “러시아 연방”, “법 집행”)이 2012년 이전에 더 자주 논의되었음을 볼 수 있습니다. 반면 교육 및 건강관련 주제가 특히 2010년 이후에는 적게 논의되었습니다.\n- Arabica가 절대 빈도를 반환하기 때문에 데이터셋에는 제2차 세계대전, 외교 및 방위 정책 용어가 더 많이 포함되어 있습니다. 그러나 지역적 맥락을 알지 못하면 결과를 잘 해석하기 어렵습니다.\n\n이전 기사에서 간단한 LDA를 사용한 토픽 모델링 접근 방식에 대해 설명한 바 있습니다. 이 튜토리얼의 완전한 코드는 내 GitHub에 있습니다.\n\n제 작품을 즐기신다면 커피를 사주시고 글쓰기를 지원할 수 있습니다. 또한 새 기사 발행 알림을 받기 위해 이메일 목록을 구독할 수도 있습니다. 감사합니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 참고 자료\n\n[1] Blei, Ng, Jordan (2003). Latent Dirichlet Allocation. Journal Of Machine Learning Research 3, pp. 993–1022.\n\n[2] Chagnon, Pandolfi, Donatelli, Ushizima (2024). Benchmarking topic models on scientific articles using BERTeley. Natural Language Processing Journal 6.\n\n[3] Efat, Atiq, Abeed, Momin, Alam (2023). Empoliticon: NLP 및 MLBased Approach를 사용한 정치 연설에서 컨텍스트 및 감정 분류. IEEE Access, vol. 11.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n[4] Grootendorst (2022). Bertopic: Neural Topic Modeling With A Class-Based TF-IDF Procedure. Computer Science.\n\n[5] Koráb, Poměnková (2024). Arabica: A Python package for exploratory analysis of text data. In The Journal of Open Source Software. Journal of Open Source Software. https://doi.org/10.5281/zenodo.10866697.","ogImage":{"url":"/TIL/assets/img/2024-07-14-TopicModellingwithBERTtopicinPython_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-TopicModellingwithBERTtopicinPython_0.png","tag":["Tech"],"readingTime":7},{"title":"데이터 과학에서 자주 오해받는 5가지 단어","description":"","date":"2024-07-14 20:06","slug":"2024-07-14-FiveMassivelyMisusedWordsinDataScience","content":"\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-FiveMassivelyMisusedWordsinDataScience_0.png\" /\u003e\n\n우리 모두가 아는 대로, 데이터 과학은 우리의 세계에 매우 새로운 학문입니다. 이로 인해 이는 일할 때 매우 흥미로운 분야가 됩니다. 그러나 이로 인해 문제가 발생하기도 합니다. 오늘은 그 중 하나인 문제에 대해 이야기하고 싶습니다: 데이터 과학 결과나 개념을 설명할 때 잘못된 용어를 사용하는 문제입니다.\n\n제가 항상 다뤄야 하는 다섯 가지 자주 오용되는 단어와 전형적인 오용에 대한 설명이 있습니다. 이를 통해 데이터 과학 결과의 전달 및 구현에서의 함정에 대해 더 많이 인식하게 된다면 좋겠습니다.\n\n## 1. 예측적인\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n와우, 사람들은 세상을 예측하는 걸 정말 좋아하네요, 그렇죠? 2010년쯤 유행하기 시작한 이후로, p-단어처럼 흔히 들어본 말은 없는 것 같아요. 계수가 통계적으로 유의미한 변수인 x는 선형 모델에서 중요하다고 하더라도, 그 변수가 예측력이 있는 것은 아닙니다. 그건 상당히 무리인 주장이죠.\n\n훈련된 통계 모델에서 유의미한 영향을 끼치는 변수들도, 그 효과가 미미해서 사실상 중요하지 않을 수도 있어요. 따라서, 그 변수들을 '예측적으로' 설명한다는 것은 현실을 잘못 표현할 수도 있어요. 새로운 데이터에 대한 테스트 과정이 필요한데, 이를 통해 모델이나 변수들을 실제로 '예측적인지' 설명할 수 있어요. 며칠 전에 로지스틱 회귀 모델 결과를 사람이 '예측적이다'라고 설명했을 때, 저는 훈련 및 테스트 데이터를 나누지 않았고, 예측을 시도하고 있지도 않았는데요. 규칙적으로, 왼쪽에 빼놓은 테스트 샘플을 사용하여 예측 효과를 확인하지 않으면 변수나 모델을 '예측적으로' 설명하지 마세요.\n\n## 2. R-squared\n\nR-squared는 대체로 선형, 가법적 모델의 모델 품질 측정으로만 적용됩니다. 그런데 제가 종종 확률 모델이나 분류기에 '높은 R-squared'를 갖고 있다고 하는 사람들을 듣곤 해요. 그게 무슨 뜻일까요? 심플한 일반화된 선형 모델조차도 전체적인 모델 품질을 정의하는 여러 방법이 있어요. 이러한 모델들에는 적어도 5가지 다른 유사 R-squared 메트릭스가 있고, 그 결과는 크게 다를 수 있으며 해석하기 어려울 수 있어요. 예측 정확도 메트릭스인 ROC AUC, F1-score와 같은 지표까지 더해져서 혼란스러울 수 있죠.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n사람들이 한 접근 방식의 용어를 다른 접근 방식에서 무언가를 설명할 때 사용하지 못하도록 허락하지 마세요. 이것은 좋지 않은 실천이며 지적으로 정직하지 못할 수도 있습니다. 미리 적합한 품질 측정 항목을 합의하고 사람들이 그것을 준수하도록 유도하세요.\n\n### 3. 확률\n\n확률 모델링을 하다보면 odds(승산) 용어를 자주 만날 것입니다. 이 모델의 계수를 해석할 때 odds가 자연스럽게 발생합니다. 그러나 odds는 확률을 의미하지 않습니다. 이 오해는 odds 비율을 사람들에게 설명할 때 정말 나쁠 수 있습니다. 모델에서 변수가 300%의 odds 비율을 가진다면, 사람들은 종종 해당 변수의 단위 증가가 결과의 확률을 세 배로 만든다고 생각합니다. 정말 멋지게 들리죠! 그것은 틀렸습니다. 결과에 미치는 확률의 영향은 사전 확률이 무엇이었느냐에 달려 있습니다. 이미 매우 높은 경우, 300%의 odds 비율은 거의 영향을 주지 않을 것입니다. 매우 낮은 경우, 실제로 300%의 영향을 줄 것이지만, 작은 것의 300%는 아마도 여전히 작을 것입니다. 더 읽고 싶다면 이 주제에 대한 제 기사를 확인하세요.\n\n### 4. 증명\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n통계 검정에서 잘못 사용되는 또 다른 p 단어는 입증(Prove)이다. 가설을 입증하거나 반박하지 않습니다. 귀무 가설(null hypothesis)을 기각하거나 기각하지 못합니다. 많은 사람들이 제대로 이해하지 않는 철학이며, 이는 분명히 의미론적인 것이 아닙니다.\n\n예를 들어, 12세에서 16세 사이의 소년과 소녀가 친구의 평균 수가 동일한지 테스트하고 싶다고 가정해봅시다. 해당 연령대의 충분한 샘플을 조사하여 모든 소년과 소녀 사이의 평균 친구 수에 차이가 없다는 귀무가설을 세우고, 우리가 가진 표본의 통계적 특성을 고려하여 그 귀무가설이 얼마나 진실일지 확인합니다. 무작위로 설정된 확률 막대(알파)를 사용하여(`보통 5% 정도) 귀무가설을 기각할 수 있다고 선언할 수도 있습니다.\n\n소년과 소년이 서로 다른 평균 친구 수를 가진다는 것을 증명했다고 말할 수 없습니다. 두 그룹이 같은 친구 수를 가질 가능성은 낮다고 말할 수 있거나 '통계적 검정이 알파 0.05에서 귀무가설을 기각했다'라고 말할 수 있습니다. 입증은 100% 확신을 의미하며, 표본을 다룰 때는 그 정도에 도달할 수 없습니다.\n\n## 5. 파워\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n통계적 파워라는 또 다른 p로 시작하는 용어는 종종 사람들이 그 의미를 이해하지 못하는 사람들 사이에서 사용되는 것입니다. 많은 사람들이 무언가가 높거나 낮은 통계적 파워를 갖고 있다고 말하지만, 실제로 의미하는 것은 낮거나 높은 p-값 또는 높거나 낮은 표본 크기입니다. 통계적 파워가 무엇인지 정의할 수 있는지 스스로에게 묻는 것이 중요합니다.\n\n통계적 파워는 사실 대안 가설이 참일 때 널 가설을 기각할 확률을 나타냅니다. 이것은 기본적으로 널 가설의 기각이 얼마나 신뢰할 수 있는지 나타내는 측정 지표입니다. 이는 p-값 이상으로 많은 요소에 의해 결정되며, 샘플 크기, 알파, 효과 크기를 사용하여 계산됩니다. 실제로 더 높은 알파나 낮은 샘플 크기를 갖는 결과가 더 높은 통계적 파워를 가질 수 있는 것은 완전히 가능합니다.\n\n데이터 과학이나 통계학에서 자주 오용되는 용어가 있나요? 그러한 경우가 있다면 언제든지 댓글을 남겨주세요.","ogImage":{"url":"/TIL/assets/img/2024-07-14-FiveMassivelyMisusedWordsinDataScience_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-FiveMassivelyMisusedWordsinDataScience_0.png","tag":["Tech"],"readingTime":4},{"title":"코드 없는 GenAI 에이전트 워크플로우 오케스트레이션 로컬 Mistral AI 모델과 함께하는 AutoGen Studio 사용법","description":"","date":"2024-07-14 20:04","slug":"2024-07-14-NoCodeGenAIAgentsWorkflowOrchestrationAutoGenStudiowithLocalMistralAImodel","content":"\n\n자유 링크 — 이 LinkedIn 게시물을 좋아해 주세요\n\nAutoGen은 Microsoft에서 개발한 프레임워크로, 특히 LLM 에이전트를 조정하는 다중 에이전트 애플리케이션 개발을 간소화하기 위해 설계되었습니다.\n\n다중 에이전트 애플리케이션은 여러 LLM 또는 다중 모달 에이전트 또는 엔티티가 전체 워크플로에서 상호 작용하여 특정 목표나 작업을 달성하는 시스템을 의미합니다. 이러한 에이전트는 LLM 에이전트, 검색에이전트 또는 독립적인 결정을 내리거나 기능 호출 또는 조치를 취할 수 있는 다른 에이전트일 수 있습니다.\n\nAutoGen에 대해 더 알고 싶다면 이전 기사를 참조해주세요: AutoGen In-depth yet Simple.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n미스트랄 AI는 2023년 4월에 메타와 구글 연구원 출신인 프랑스의 AI 회사입니다. 이 회사는 오픈 대형 언어 모델 (LLM)을 제작하는 데 중점을 두며 오픈 소스 AI 모델의 중요성을 강조합니다.\n\n이 기사에서는 AutoGen Studio의 직관적인 노코드 플랫폼과 지역 통합 미스트랄 AI 모델의 혁명적인 융합에 초점을 맞출 것입니다. 이 조합은 AI를 응용프로그램에 쉽게 통합하는 데만 그치는 것이 아니라, 다양한 생성적 AI 에이전트를 어떻게 상호 작용, 배포하며 현실적인 업계 업무 흐름에서 혜택을 누르는 데에 도움을 주는 데 있습니다.\n\n# AutoGen Studio의 인터페이스 탐색:\n\n## AutoGen Studio 설치\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAutoGen Studio는 오픈 소스 코드로 여기에서 사용할 수 있으며 pip를 통해 설치할 수 있습니다.\n\n```js\npip install autogenstudio\n```\n\n## Autogen Studio 실행\n\n설치가 완료되면 터미널에 다음을 입력하여 웹 UI를 실행할 수 있습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\nautogenstudio ui --port 8082\n\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-NoCodeGenAIAgentsWorkflowOrchestrationAutoGenStudiowithLocalMistralAImodel_0.png\" /\u003e\n\nAutoGen Studio는 다중 에이전트 AI 응용 프로그램의 생성 및 관리를 용이하게 하는 간소화되고 사용자 친화적인 인터페이스를 제공합니다. 이 인터페이스는 Skills, Models, Agents 및 Workflows와 같은 몇 가지 섹션으로 분할되어 있으며, 각각이 응용 프로그램 개발에 필수적인 역할을 합니다.\n\n## Skills\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기술 섹션에서는 에이전트가 작업을 해결하는 데 사용할 Python 함수를 개발하고 저장할 수 있습니다. 여기는 응용 프로그램의 기능이 정의되고 개발되는 프로그래밍 환경입니다.\n\n## 모델\n\n모델 섹션은 GPT-4 및 기타 로컬 또는 사용자 정의 모델을 구성하고 관리할 수 있는 사용자 모델입니다.\n\n사용자는 Mistral AI와 같은 모델을 설정할 수 있으며, 스튜디오가 로컬 AI 모델 통합 및 관리를 지원한다는 것을 나타냅니다. 이러한 유연성을 통해 OpenAI의 GPT-4 같은 강력한 모델 및 특정 작업에 맞게 개발된 자사의 또는 전문화된 모델을 함께 사용할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 에이전트\n\n'에이전트' 섹션은 재사용 가능한 에이전트를 구성하는 데 사용됩니다. 사용자는 로컬 어시스턴트, 주 에이전트, 사용자 프록시 등 다양한 에이전트의 역할을 생성하고 정의할 수 있으며, 이들이 앱의 워크플로우 내에서 상호 작용하는 방식을 조율할 수 있습니다.\n\n# 워크플로우\n\n'워크플로우' 섹션은 마법이 일어나는 곳입니다. 사용자는 시스템이 작업을 처리하는 방식을 정의하는 복잡한 워크플로우를 설계할 수 있습니다. 이곳에서 모든 구성 요소가 하나로 결합됩니다: 'Skills'는 논리를 제공하고, 'Models'는 AI의 지능을 제공하며, '에이전트'는 작업을 수행하며, '워크플로우'는 모든 것을 일관된 시스템으로 연결합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n플랫폼의 인터페이스는 직관적이며 각 섹션이 명확히 표시되어 있고 시각적 레이아웃을 통해 네비게이션을 간단하게 유도합니다. 새로운 에이전트, 모델 또는 기술을 추가하는 경우, 일반적으로 몇 번의 클릭만으로 간단한 프로세스로 진행됩니다. 생생한 색상과 현대적인 디자인 요소의 사용으로 사용자 경험을 쾌적하고 사용하기 쉽게 만듭니다.\n\n## 지역 미스트랄 AI 모델 통합\n\n지역 미스트랄 AI 모델을 AutoGen Studio의 생태계에 통합하는 것은 매우 쉽고 직관적입니다. 사용자는 자신의 지역 모델을 스튜디오에 추가하고 앱 내의 다른 구성 요소와 상호작용하는 방법을 정의할 수 있습니다. GPT-4 비전, GPT 3.5, GPT 4 turbo와 같은 다중 모달 모델의 파워와 미스트랄 AI와 같은 지역 모델을 결합해야 하는 사용자들에게 특히 유용합니다.\n\n요약하자면, AutoGen Studio는 다중 에이전트 AI 기반 응용 프로그램을 구축하기 위한 포괄적이고 접근하기 쉬운 도구로, 다양한 AI 모델 및 사용자 정의 기술을 수용하여 개발자와 비즈니스에게 다재다능한 선택지를 제공합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 로컬 Mistral AI 모델 설정하기:\n\n로컬 Mistral AI 모델 설정은 여러 단계로 이루어져 있으며, 각 단계마다 시스템이 Ollama사의 Mistral 모델과 같은 대규모 언어 모델을 로컬에서 실행할 수 있는 환경으로 준비됩니다. 각 단계와 그 필요성에 대한 설명은 다음과 같습니다:\n\n- Ollama 설치: Ollama는 대규모 언어 모델에 액세스할 수 있는 플랫폼입니다. Ollama를 설치하는 것은 첫 번째 단계이며, Mistral 모델이 실행될 환경입니다. 이를 통해 사용자는 Llama 2, Code Llama, Mistral과 같은 기존 모델을 실행하거나 사용자 정의 및 배포할 수 있습니다. Ollama는 다음 링크에서 다운로드할 수 있습니다: https://ollama.ai/\n\n![이미지](/TIL/assets/img/2024-07-14-NoCodeGenAIAgentsWorkflowOrchestrationAutoGenStudiowithLocalMistralAImodel_1.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2. Ollama Mistral 실행: Ollama 플랫폼에서 아래 명령을 실행하여 Mistral 모델을 시작합니다. 이 명령은 모델을 설정하고 필요한 데이터를 로드하며 쿼리 처리를 담당하는 서비스를 시작합니다.\n\n```js\nollama run mistral\n```\n\n2. LiteLLM 설치: LiteLLM 라이브러리는 http 엔드포인트에서 언어 모델을 실행하는 데 도움을 주는 도구입니다. LiteLLM을 설치하거나 업그레이드하면 라이브러리의 최신 버전을 사용할 수 있어서 호환성과 기능의 관점에서 중요합니다.\n\n```js\npip install litellm --upgrade\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n3. Gunicorn 설치: Gunicorn은 UNIX 시스템용 Python WSGI HTTP 서버로, Python 웹 애플리케이션을 실행하는 데 사용됩니다. LiteLLM 프록시를 실행하는 데 필요하며 이를 통해 귀하의 언어 모델에 로컬 HTTP 요청을 보낼 수 있습니다.\n\n```js\npip install gunicorn\n```\n\n4. Ollama/Mistral 모델을 사용하여 LiteLLM 실행: 이 단계는 모델을 초기화하고 실행할 준비를 하는 과정입니다. 이 명령은 LiteLLM이 Ollama가 제공하는 Mistral 모델을 사용하도록 지시합니다. 상호작용을 위해 모델을 준비하여 쿼리를 시작하고 응답을 받을 수 있게 합니다.\n\n이 프로세스가 끝나면 로컬의 Mistral 모델이 0.0.0.0:8000에서 1개의 워커와 함께 시작됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이러한 각 단계는 로컬에서 AI 모델과 상호 작용할 수 있는 완전한 작업 환경을 설정하는 데 필요합니다. 이 로컬 설정을 통해 개발자는 클라우드 서비스와 지속적으로 통신할 필요 없이 AI 모델을 테스트하고 통합할 수 있습니다. 이는 개발 속도, 오프라인 기능, API 호출 비용 절감 등에 도움이 될 수 있습니다.\n\n![image](/TIL/assets/img/2024-07-14-NoCodeGenAIAgentsWorkflowOrchestrationAutoGenStudiowithLocalMistralAImodel_2.png)\n\n# AutoGen 및 Mistral AI와의 Workflow Orchestration:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파이썬 스크립트를 작성하여 사인 파형을 그래프로 그리고 'sine_wave.png' 파일로 저장하는 상황에서 AutoGen과 Mistral AI를 함께 사용하여 원활한 워크플로우를 만들 수 있습니다. AutoGen Studio는 멀티 에이전트 애플리케이션을 구축하고 관리하기 위한 인터페이스로 작용하며, Mistral AI는 로컬 모델을 통해 처리 능력을 제공합니다.\n\n다음은 두 플랫폼의 기능을 활용하여 오케스트레이션하는 방법입니다:\n\n## 1. 워크플로우 생성:\n\n- AutoGen Studio에서 사인 파형 이미지를 생성하는 특정 작업을 위한 새로운 워크플로우를 시작합니다.\n- 우리는 워크플로우에 \"Local mistral Agent Workflow\"와 같은 이름을 구성합니다.\n- 워크플로우 사양에는 송신자 및 수신자 에이전트가 포함되어 있으며, 'userproxy'가 요청을 시작하는 송신자로, 'primary_assistant'가 요청을 처리하고 출력을 제공하는 수신자로 지정될 수 있습니다.\n- 사용자 프록시의 역할은 사용자와 상호 작용하고 primary_assistant가 생성한 코드를 실행하는 것입니다. 코드에 오류가 발생하면 해당 오류를 primary_assistant 에이전트에 보냅니다.\n- primary_assistant 에이전트는 로컬 Mistral AI 모델을 활용하여 우리 시나리오에서 코드를 생성합니다. 코드에 오류가 있으면 사용자 프록시 에이전트가 보낸 실행 오류에 따라 코드를 조정합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 2. 모델 구성:\n\n- '미스트랄 로컬 모델'이라는 모델이 AutoGen Studio 내에 설정되어 Mistral AI와 상호 작용하도록 구성됩니다.\n- 모델의 API 엔드포인트는 Mistral AI가 실행 중인 로컬 서버 주소로 구성됩니다 (예: http://0.0.0.0:8000).\n- 이 설정을 통해 AutoGen Studio가 데이터를 Mistral AI 모델로 보내고 처리된 결과를 받을 수 있습니다.\n\n## 3. 세션 실행:\n\n- AutoGen Studio의 'Playground' 인터페이스에서 사용자는 '로컬 미스트랄 에이전트 워크플로'를 선택하여 새 세션을 시작합니다.\n- 사용자는 삼각파 플롯을 생성하기 위한 명령 또는 요청을 입력합니다.\n- 요청은 사용자 프록시 에이전트가 주요 어시스턴트 에이전트로 전송되어 Mistral AI 모델을 활용합니다. 이렇게 하여 Python 스크립트가 생성되고 사용자 프록시 에이전트가 코드를 실행합니다. 오류가 발생하면 이를 주요 어시스턴트 에이전트로 되돌려보냅니다. 주요 어시스턴트 에이전트가 코드를 재조정하여 사용자 프록시 에이전트로 다시 전송하고 코드가 작동되어 삼각파 플롯 이미지를 생성합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 4. 결과 및 검토:\n\n- Mistral AI에서 스크립트를 실행하면 'sine_wave.png' 파일이 생성되어 디스크에 저장됩니다.\n- AutoGen Studio 인터페이스에서는 세션 진행 상황 및 결과가 표시되며, 'sine_wave.png' 파일과 'sine_wave'를 플로팅하는 파이썬 코드가 생성됩니다.\n- 사용자는 결과를 검토하고, 널리 사용할 수 있도록 워크플로를 게시하거나, 처음부터 다시 시작하려면 모델을 삭제하거나, 스크립트를 개선하고 워크플로 매개변수를 더 세밀하게 조정하기 위해 추가적으로 반복할 수 있습니다.\n\n# 결론:\n\nAutoGen Studio와 로컬 Mistral AI 모델은 GenAI 에이전트의 워크플로를 조정하는 데 주요한 진전을 보여줍니다. 이 아키텍처는 AutoGen Studio의 직관적인 디자인과 Mistral AI의 우수한 성능을 결합하여, 다중 에이전트가 기여할 수 있는 환경을 구축합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAutoGen Studio와 로컬 Mistral AI 모델의 장점:\n\n- 쉬운 통합: 로컬 Mistral AI 모델이 AutoGen Studio에 쉽게 통합되어 다양한 LLM 모델을 한 배포로 효율적으로 활용하는 과정을 간소화합니다.\n- 맞춤 및 유연성: 개발자들은 AI 모델을 특정 요구 사항에 맞게 맞춤화하여 하나의 프로젝트의 다양한 필요에 완벽히 맞는 맞춤형 솔루션을 제공할 수 있습니다.\n- 향상된 성능: AutoGen과 함께 로컬에서 AI 모델을 실행하면 지연 시간이 줄어들고 응답 시간이 향상되어 실시간 애플리케이션 및 민감한 작업에 중요합니다.\n- 데이터 개인 정보 보호 및 보안: AI 모델의 로컬 실행은 데이터에 대한 완전한 통제를 제공하며 외부 환경에 노출되어서는 안 되는 민감하거나 전문성이 있는 정보에 대해 핵심적인 역할을 합니다.\n- 비용 효율성: 클라우드 기반 AI 서비스에 대한 의존을 최소화하여 데이터 전송 및 LLM API 사용과 관련된 비용을 크게 절감할 수 있습니다.\n- 오프라인 기능: 로컬 Mistral AI 모델을 사용하면 인터넷 연결이 없어도 시스템이 작동되는 것을 보장하여 AI 기반 솔루션의 오프라인 기능을 허용합니다.\n- UI로 복잡한 AI 워크플로우 작성: 사용자는 AutoGen Studio의 노코드 인터페이스를 활용하여 AI 기반 워크플로우를 직관적으로 설계하고 관리할 수 있습니다.\n\n이 기사에서는 AutoGen Studio와 로컬 Mistral AI 모델의 통합이 GenAI 워크플로우의 세계에서 혁명적인 발전을 가져왔습니다. 성장하는 고급 AI 애플리케이션 수요를 충족시키는 사용자 친화적이고 유연하며 비용 효율적인 솔루션을 제공하여 AI 애플리케이션을 만들기가 언제보다 쉬워졌습니다.\n\n# 떠나기 전에! 🦸🏻‍♀️\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 만약 이 글이 유익하다고 느끼신다면, 이 LinkedIn 글을 ‘좋아요’해 주세요. 또한 무료 친구 링크를 LinkedIn 글에서 찾을 수 있습니다. 여러분의 참여는 이 글을 더 홍보하는 데 도움이 될 것이며, 여러분의 지지는 저에게 큰 원동력이 됩니다. ✍🏻🦾❤️\n- 이 글을 50번 클랩해 주시면, 정말로 저를 도와주시고 다른 사람들에게 이 글을 알릴 수 있습니다. 👏\n- 제 최신 글을 보려면 Medium, LinkedIn에서 팔로우하고 구독해주세요. 🫶\n\n# 흥미 있는 주제라면, 더 많은 글을 읽어보실 수 있습니다.","ogImage":{"url":"/TIL/assets/img/2024-07-14-NoCodeGenAIAgentsWorkflowOrchestrationAutoGenStudiowithLocalMistralAImodel_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-NoCodeGenAIAgentsWorkflowOrchestrationAutoGenStudiowithLocalMistralAImodel_0.png","tag":["Tech"],"readingTime":12},{"title":"선형 회귀 쉽게 이해하기  실생활 예시와 함께하는 초보자 가이드","description":"","date":"2024-07-14 20:03","slug":"2024-07-14-SimplifyingLinearRegressionABeginnersGuidewithareal-worldPracticalExample","content":"\n\n선형 회귀는 머신 러닝 세계에서 가장 기본적인 알고리즘 중 하나이며, 분석의 ABC와 같습니다.\n\n하늘의 별무리를 통해 가장 적합한 선을 만든다고 생각해보세요. 여기서 각 별은 데이터 점을 나타냅니다.\n\n오늘은 선형 의존성의 클래식 예시 중 하나인 키와 몸무게를 활용해 실제 세계 머신 러닝에 대해 알아보겠습니다 👇🏻\n\n# 기본 원리 이해하기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n간단한 선형 회귀는 가장 기본적인 머신러닝 알고리즘입니다. 데이터 모델링에 대한 여정을 시작하는 대부분의 경우입니다.\n\n신장과 몸무게를 그래프로 그려보면, 신장이 증가함에 따라 몸무게도 증가하는 선이 대략적으로 나타날 것입니다.\n\n그것이 선형 회귀의 핵심입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러니까 이 작업을 어떻게 수행할 수 있는지 살펴보겠습니다...\n\n## #1. 데이터 탐색 - 뛰기 전에 훔쳐보기\n\n분석에 들어가기 전에 데이터와 친해지는 것부터 시작해봐요.\n\n세 개의 열이 있는 테이블을 상상해보세요: 성별, 키, 몸무게.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](/TIL/assets/img/2024-07-14-SimplifyingLinearRegressionABeginnersGuidewithareal-worldPracticalExample_1.png)\n\n파이썬의 df.info()로 간단히 살펴보면 수천 개의 항목이 있고 중요한 것은 결측값이 없다는 것입니다.\n\n그리고 데이터의 분포는 어떤가요?\n\n키에 대한 종모양 곡선 하나와 몸무게에 대한 종모양 곡선 하나를 생각해보세요. 두 곡선 모두 나비 날개만큼 대칭적인데요 — 바로 여기가 우리의 정규 분포입니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-SimplifyingLinearRegressionABeginnersGuidewithareal-worldPracticalExample_2.png\" /\u003e\n\n# #2. 최적 선을 찾는 방법\n\n우리의 최적 선을 얻기 위해서는 여러 가지 방법이 있습니다. 오늘날 대다수의 사람들은 scikit-learn을 활용하여 미리 빌드된 선형 회귀 알고리즘을 적용할 것입니다.\n\n그러나 이번에는 최초로 세 가지 다른 방법을 시도해 봅시다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 2 DIY — 모두 스스로 알고리즘 생성.\n- 1 최종 방법은 scikit-learn 활용하는 것.\n\n## 접근 방법 #1: 최소 제곱법 (OLS)\n\n최소 제곱법(OLS)의 목적은 예측 오차의 제곱을 최소화하여 최적의 계수 A와 B를 결정하는 것입니다 — 이것이 바로 선형 회귀의 비용 함수인 MSE입니다.\n\n미적분을 활용하여 비용 함수의 최소값을 찾기 위해 편미분의 성질을 이용합니다. 그리고 이러한 편미분이 0이 되는 지점이 최소값에 해당합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위 수학 문제를 해결하여 A와 B에 대한 정확한 닫힌 수학 공식을 얻게 되면, 가장 정확한 선형 모델로 향하는 직접적인 경로를 얻을 수 있습니다.\n\n![링크](/TIL/assets/img/2024-07-14-SimplifyingLinearRegressionABeginnersGuidewithareal-worldPracticalExample_3.png)\n\n이것은 이러한 수학적인 닫힌 해결책을 찾기 위해 몇 줄의 코드를 정의하는 것으로 번역됩니다. 그래서 매우 직관적입니다.\n\n## 방법 #2: 경사하강법 — 산에서의 하이킹\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n경사 하강은 비용 함수를 최소화하는 데 사용되는 중요한 최적화 알고리즘으로, 예측 모델의 가장 정확한 가중치 값을 찾는 데 도움을 줍니다.\n\n언덕 꼭대기에 서 있는 것으로 상상해보세요. 여러분의 목표는 아래의 계곡에 있습니다. 이것은 비용 함수의 최솟값을 나타냅니다.\n\n이를 달성하기 위해 가중치 A와 B에 대한 초기 추정치로 시작하여 이 추정치를 반복적으로 개선합니다.\n\n이 과정은 언덕을 내려가는 것과 유사합니다. 각각의 단계에서 우리는 주변 환경을 평가하고, 각각의 다음 단계가 계곡 바닥에 더 가까워지도록 우리의 궤적을 조정합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이러한 단계는 학습 속도에 의해 안내됩니다 — 방정식에서 lr로 상징되는 중요한 하이퍼파라미터입니다. 이 학습 속도는 매개변수 A와 B에 대한 조정이나 단계의 크기를 제어하여 최소값을 초과하지 않도록 합니다.\n\n![image](/TIL/assets/img/2024-07-14-SimplifyingLinearRegressionABeginnersGuidewithareal-worldPracticalExample_4.png)\n\n각 단계에서 비용 함수의 A 및 B에 대한 편도함수인 dA와 dB를 계산합니다. 이 도함수는 우리에게 비용 함수가 가장 빨리 감소하는 방향을 가리키는데, 이것은 비유적인 언덕에서 가장 가파른 하강 경로를 찾는 것과 유사합니다.\n\n각 반복에서 A와 B에 대한 업데이트된 방정식은 다음과 같습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지침대로 테이블 태그를 마크다운 형식으로 변경하겠습니다.\n\n\nThis meticulous process is repeated until we reach a point where the cost function’s decrease is negligible, suggesting we’ve arrived at or near the global minimum — our destination where the predictive error is minimized, and our model’s accuracy is maximized.\n\n![Image](/TIL/assets/img/2024-07-14-SimplifyingLinearRegressionABeginnersGuidewithareal-worldPracticalExample_5.png)\n\nThis translates into defining two main functions:\n\n- The function to compute MSE\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- A 및 B를 업데이트하는 기능\n\n우리는 코드를 다음과 같이 초기화합니다:\n\n- A = 0\n- B = 0\n- 학습률 0.0001(학습률은 알고리즘이 더 빠르게 또는 더 느리게 학습할 수 있도록 합니다).\n- 최대 반복 횟수\n\n그래서 최종 코드는 다음과 같습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 접근 방법 #3: Sci-Kit Learn — 파이썬의 강력한 무브\n\n파이썬을 좋아하는 사람들을 위해, Sci-Kit Learn은 머신 러닝을 위한 스위스 아미 나이프입니다. 회귀, 분류, 클러스터링 등을 위한 다양한 도구로 가득합니다.\n\n우리가 해야 할 일은 LinearRegression 라이브러리를 가져와서 객체를 만들고, 데이터로 훈련시키는 것뿐입니다.\n\n몇 줄의 코드로 이를 구현할 수 있습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n왔어요!\n\n우리의 모델이 준비되었습니다.\n\n# 3. 최종 결과\n\n우리의 기술을 적용한 후, 공식이 생성되었습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](/TIL/assets/img/2024-07-14-SimplifyingLinearRegressionABeginnersGuidewithareal-worldPracticalExample_6.png)\n\nWith the data we crunched, A turned out to be around 7.17, and B was approximately -350.73.\n\nWhat does this mean?\n\nFor every inch of height, the weight increases by about 7.17 units, minus our intercept value.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 가정 게임\n\n어떤 모델도 완벽하지 않으며, 선형 회귀는 특정 가정에 의존합니다:\n\n- 선형성: 우리의 데이터는 선이 되어야 합니다. 기억해주세요. 이미 간단한 산점도로 이 선형 패턴을 첫 번째 분석에서 확인했습니다.\n- 독립성: 입력 변수는 서로 독립적이어야 합니다.\n- 잔차의 정규 분포: 관측값과 예측값의 차이는 종 모양의 곡선을 형성해야 합니다.\n\n![이미지](/TIL/assets/img/2024-07-14-SimplifyingLinearRegressionABeginnersGuidewithareal-worldPracticalExample_7.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 잔차의 등분산성: 오차의 퍼짐은 독립 변수의 모든 값에서 일관되어야 합니다.\n\n![image](/TIL/assets/img/2024-07-14-SimplifyingLinearRegressionABeginnersGuidewithareal-worldPracticalExample_8.png)\n\n# 마무리의 생각\n\n선형 회귀는 간단한 것처럼 보일 수 있지만, 데이터 과학 무기함에 속한 강력한 도구입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n데이터 분석의 매력은 그 간단함에 있습니다.\n\n복잡한 모델을 사용하는 것이 중요한 게 아니라, 올바른 모델을 올바른 상황에 사용하는 것이 중요한 거죠.\n\n이 개념을 소화하면, 당신은 데이터 속에 숨겨진 이야기를 발견하는 길에 여러분이 잘 나아가고 있습니다.\n\n호기심을 가져라, 데이터 우주를 계속 탐험해 보세요! 🤓\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음의 GitHub 저장소에서 코드를 확인할 수 있어요.\n\nForCode’Sake를 팔로우하면 이와 유사한 기사를 더 많이 볼 수 있어요! ✨\n\nMLBasics 이슈가 마음에 드셨나요? 그렇다면 DataBites 뉴스레터에 가입하여 최신 내용을 이메일로 받아보세요!\n\n유니크한 콘텐츠를 약속합니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 Markdown 형식의 표를 확인하세요.\n\n![이미지](/TIL/assets/img/2024-07-14-SimplifyingLinearRegressionABeginnersGuidewithareal-worldPracticalExample_9.png)\n\n데이터 과학자 또는 데이터 엔지니어가 되기 위한 훌륭한 데이터 과학 로드맵을 확인해보세요! 🤓\n\n또한 ML, SQL, Python 및 DataViz에 관한 매일 게시하는 치트 시트를 확인할 수 있는 X, Threads 및 LinkedIn에서 저를 만날 수도 있습니다.","ogImage":{"url":"/TIL/assets/img/2024-07-14-SimplifyingLinearRegressionABeginnersGuidewithareal-worldPracticalExample_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-SimplifyingLinearRegressionABeginnersGuidewithareal-worldPracticalExample_0.png","tag":["Tech"],"readingTime":10},{"title":"Django로 튼튼한 웹 애플리케이션을 만드는 15가지 팁","description":"","date":"2024-07-14 20:01","slug":"2024-07-14-15TipsforBuildingRobustWebApplicationswithDjango","content":"\n\n\n![image](/TIL/assets/img/2024-07-14-15TipsforBuildingRobustWebApplicationswithDjango_0.png)\n\n장고는 강력하고 다재다능한 웹 프레임워크로 개발자들이 빠르고 효율적으로 견고한 웹 애플리케이션을 구축할 수 있습니다. 그러나 진정으로 견고한 애플리케이션을 구축하려면 모범 사례와 고급 기술에 주의를 기울여야 합니다. 이곳에는 Django로 견고한 웹 애플리케이션을 구축하는 데 도움이 되는 15가지 팁이 있습니다.\n\n## 1. 가상 환경 사용\n\n가상 환경은 의존성을 관리하고 프로젝트별 라이브러리를 격리하는 데 필수적입니다. 이를 통해 패키지 간 충돌을 방지하고 일관된 개발 환경을 유지할 수 있습니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 가상 환경 생성하기\npython -m venv env\n\n# 가상 환경 활성화하기\n# Windows에서는\nenv\\Scripts\\activate\n# Unix나 MacOS에서는\nsource env/bin/activate\n```\n\n# 2. 장고 프로젝트 구조 따르기\n\n장고에서 권장하는 프로젝트 구조를 준수하여 애플리케이션을 구조화하고 유지보수 가능하게 유지하세요. 이는 앱, 템플릿, 정적 파일 및 설정을 분리하는 것을 포함합니다.\n\n```js\nmyproject/\n    manage.py\n    myproject/\n        __init__.py\n        settings.py\n        urls.py\n        wsgi.py\n    myapp/\n        __init__.py\n        admin.py\n        apps.py\n        models.py\n        tests.py\n        views.py\n        migrations/\n        templates/\n        static/\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 3. Django Admin을 활용하여 신속한 프로토타이핑\n\nDjango의 내장 관리자 인터페이스는 관리 인터페이스를 빠르게 생성하는 강력한 도구입니다. 필요에 맞게 사용자 정의하고 신속한 프로토타이핑 및 애플리케이션 데이터 관리에 활용하세요.\n\n```js\n# admin.py에서 모델 등록\nfrom django.contrib import admin\nfrom .models import MyModel\n\nadmin.site.register(MyModel)\n```\n\n# 4. 클래스 기반 뷰 사용\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n클래스 기반 뷰(CBVs)는 함수 기반 뷰(FBVs)에 비해 더 유연하고 재사용 가능한 접근 방식을 제공합니다. 이를 통해 코드 재사용과 더 나은 구성을 촉진합니다.\n\n```js\nfrom django.views import View\nfrom django.http import HttpResponse\n\nclass MyView(View):\n    def get(self, request):\n        return HttpResponse('Hello, World!')\n```\n\n# 5. 커스텀 사용자 모델 구현\n\n장고의 기본 사용자 모델은 모든 요구 사항을 충족하지 못할 수 있습니다. 프로젝트 초기에 사용자 모델을 사용자 정의하여 나중에 복잡성을 피하도록 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nfrom django.contrib.auth.models import AbstractUser\n\nclass CustomUser(AbstractUser):\n    # 여기에 사용자 정의 필드를 추가하세요\n    pass\n\n# settings.py 업데이트\nAUTH_USER_MODEL = 'myapp.CustomUser'\n```\n\n# 6. 로직 분리를 위해 시그널 사용하기\n\nDjango 시그널을 사용하면 응용 프로그램의 구성 요소를 분리하여 통지를 보내고 받을 수 있습니다. 모델 변경이나 사용자 작업과 같은 이벤트를 처리하기 위해 시그널을 사용하세요.\n\n```python\nfrom django.db.models.signals import post_save\nfrom django.dispatch import receiver\nfrom .models import MyModel\n\n@receiver(post_save, sender=MyModel)\ndef my_model_post_save(sender, instance, created, **kwargs):\n    if created:\n        # 어떤 동작 수행\n        pass\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 7. 데이터베이스 쿼리 최적화\n\n효율적인 데이터베이스 쿼리는 성능에 중요합니다. Django의 ORM 기능인 select_related와 prefetch_related를 사용하여 쿼리의 수를 최소화하세요.\n\n```js\n# select_related 사용\nqueryset = MyModel.objects.select_related('related_model').all()\n\n# prefetch_related 사용\nqueryset = MyModel.objects.prefetch_related('related_set').all()\n```\n\n# 8. 캐싱 구현\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n캐싱은 자주 액세스하는 데이터를 저장하여 성능을 향상시킵니다. Django는 Memcached와 Redis와 같은 다양한 캐싱 백엔드를 지원합니다.\n\n```js\n# settings.py 업데이트\nCACHES = {\n    'default': {\n        'BACKEND': 'django.core.cache.backends.memcached.MemcachedCache',\n        'LOCATION': '127.0.0.1:11211',\n    }\n}\n\n# 뷰에서 캐싱 사용\nfrom django.views.decorators.cache import cache_page\n\n@cache_page(60 * 15)\ndef my_view(request):\n    # 뷰 로직 여기에 작성\n    pass\n```\n\n# 9. 미들웨어 현명하게 사용하기\n\n미들웨어를 사용하면 요청과 응답을 전역적으로 처리할 수 있습니다. 미들웨어를 신중하게 사용하여 기능을 향상시키고 불필요한 복잡성을 추가하지 않도록 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 사용자 정의 미들웨어\nclass MyMiddleware:\n    def __init__(self, get_response):\n        self.get_response = get_response\n\n    def __call__(self, request):\n        # 뷰가 호출되기 전 각 요청에 대해 실행되는 코드\n        response = self.get_response(request)\n        # 뷰가 호출된 후 각 응답에 대해 실행되는 코드\n        return response\n\n# settings.py 업데이트\nMIDDLEWARE = [\n    'myproject.middleware.MyMiddleware',\n    # 다른 미들웨어\n]\r\n```\n\n# 10. 양식 유효성 검사 구현\n\n견고한 양식 유효성 검사는 데이터 무결성을 보장하고 사용자 경험을 향상시킵니다. Django의 양식 클래스를 사용하여 유효성 검사와 오류 처리를 처리하세요.\n\n```js\nfrom django import forms\n\nclass MyForm(forms.Form):\n    name = forms.CharField(max_length=100)\n    email = forms.EmailField()\n\n    def clean_email(self):\n        email = self.cleaned_data.get('email')\n        if not email.endswith('@example.com'):\n            raise forms.ValidationError('잘못된 이메일 도메인')\n        return email\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 11. 애플리케이션 보안 강화하기\n\n웹 애플리케이션에서 보안은 매우 중요합니다. Django의 기본 보안 기능인 CSRF 보호, XSS 보호 및 안전한 비밀번호 해싱 기능을 사용하세요.\n\n```js\n# CSRF 미들웨어가 활성화되어 있는지 확인\nMIDDLEWARE = [\n    'django.middleware.csrf.CsrfViewMiddleware',\n    # 다른 미들웨어\n]\n\n# Django의 기본 비밀번호 해시 함수 사용하기\nfrom django.contrib.auth.hashers import make_password\n\npassword = make_password('my_secure_password')\n```\n\n# 12. 비동기 작업에 Celery 사용하기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n셀러리는 장고와 잘 통합되는 비동기 작업 큐/작업 큐입니다. 이를 사용하여 시간이 오래 걸리는 작업을 백그라운드에서 처리할 수 있어요.\n\n```js\n# Celery 설치하기\npip install celery\n\n# Celery 인스턴스 생성하기\nfrom celery import Celery\n\napp = Celery('myproject', broker='redis://localhost:6379/0')\n\n# settings.py에서 Celery 구성하기\nCELERY_BROKER_URL = 'redis://localhost:6379/0'\n\n# 작업 정의하기\n@app.task\ndef my_task():\n    # 작업 로직 작성\n    pass\n\n# 작업 호출하기\nmy_task.delay()\n```\n\n# 13. 테스트 작성하기\n\n테스트를 작성하면 애플리케이션의 신뢰성과 안정성을 보장할 수 있어요. 장고의 내장 테스트 프레임워크를 사용하여 단위 테스트, 통합 테스트, 기능 테스트를 작성해보세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\nfrom django.test import TestCase\r\nfrom .models import MyModel\r\n\r\nclass MyModelTest(TestCase):\r\n    def test_str(self):\r\n        my_model = MyModel(name='Test')\r\n        self.assertEqual(str(my_model), 'Test')\r\n\n\r\n## 14. Logging 사용\r\n\r\nLogging을 사용하면 애플리케이션의 모니터링과 디버깅에 도움이 됩니다. 중요 이벤트와 오류를 캡처하기 위해 Django의 로깅 프레임워크를 구성하세요.\r\n\r\n```python\r\n# settings.py 업데이트\r\nLOGGING = {\r\n    'version': 1,\r\n    'disable_existing_loggers': False,\r\n    'handlers': {\r\n        'file': {\r\n            'level': 'DEBUG',\r\n            'class': 'logging.FileHandler',\r\n            'filename': 'debug.log',\r\n        },\r\n    },\r\n    'loggers': {\r\n        'django': {\r\n            'handlers': ['file'],\r\n            'level': 'DEBUG',\r\n            'propagate': True,\r\n        },\r\n    },\r\n}\r\n\r\n# view에서 logging 사용\r\nimport logging\r\n\r\nlogger = logging.getLogger(__name__)\r\n\r\ndef my_view(request):\r\n    logger.debug('디버그 메시지입니다')\r\n    # 뷰 로직은 여기에\r\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 15. 최선의 실천 방법으로 배포하기\n\nDjango 애플리케이션을 배포하는 것은 제품 환경에서 원할하게 실행되도록 하는 여러 단계를 거칩니다. 견고한 배포 설정을 위해 Gunicorn, Nginx, Docker와 같은 도구들을 사용하세요.\n\n```js\n# 예시 Gunicorn 명령어\ngunicorn myproject.wsgi:application --bind 0.0.0.0:8000\n\n# 예시 Dockerfile\nFROM python:3.9\nENV PYTHONUNBUFFERED 1\nWORKDIR /app\nCOPY requirements.txt /app/\nRUN pip install -r requirements.txt\nCOPY . /app/\nCMD [\"gunicorn\", \"myproject.wsgi:application\", \"--bind\", \"0.0.0.0:8000\"]\n```\n\n이 15가지 팁을 따르면 Django로 견고하고 안전하며 효율적인 웹 애플리케이션을 만들 수 있습니다. 소규모 프로젝트나 대규모 애플리케이션을 개발하더라도 최선의 실천 방법을 준수하고 Django의 강력한 기능을 활용하면 애플리케이션이 유지보수 가능하고 성능이 우수하며 확장 가능하도록 보장할 수 있습니다. 즐거운 코딩 되세요!","ogImage":{"url":"/TIL/assets/img/2024-07-14-15TipsforBuildingRobustWebApplicationswithDjango_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-15TipsforBuildingRobustWebApplicationswithDjango_0.png","tag":["Tech"],"readingTime":10},{"title":"PySpark의 Repartition 진실 놀랄 준비 하세요","description":"","date":"2024-07-14 20:00","slug":"2024-07-14-TheTruthAboutPySparksRepartitionPreparetoBeSurprised","content":"\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-TheTruthAboutPySparksRepartitionPreparetoBeSurprised_0.png\" /\u003e\n\n데이터 엔지니어로서, 데이터 파이프라인을 다루고 성능을 최적화하는 데 수많은 시간을 보냈습니다. PySpark에 대해 꽤 잘 알고 있을 줄 알았지만, 몇 가지 부분에 대해 틀렸던 것을 깨달았습니다 — 특히 repartition() 함수에 관한 부분이 그렇습니다.\n\n많은 분들처럼, 저도 repartition() 함수가 어떻게 작동하는지에 대해 많은 가정을 했습니다. 그러나 몇몇 가정이 사실은 크게 틀렸던 것으로 판명이 났습니다. 이 블로그 게시물에서는 PySpark에서 분할에 대한 일반적인 오해 몇 가지를 해소해보겠습니다. repartition() 함수에 집중하고, 실제로 데이터가 파티션으로 어떻게 분산되는지 살펴보겠습니다.\n\n그러나 스크롤 다운하기 전에 — df.repartition(columnName)이 columnName의 값을 기반으로 데이터를 분배한다고 알고 계셨나요? 아래 이미지와 같은 방식으로 말이죠? 이것은 흔히 퍼지는 미신입니다! 사실은 대부분의 사람들이 생각하는 방식으로 작동하지 않습니다. 흥미를 느껴지나요? 이어서 진실을 밝혀보고 파티션 전략을 최적화하는 방법을 배워보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](/TIL/assets/img/2024-07-14-TheTruthAboutPySparksRepartitionPreparetoBeSurprised_1.png)\n\n파이스파크에서는 두 가지 주로 사용되는 파티션 전략을 알고 있습니다. 첫 번째는 df.repartition()이고 두 번째는 df.repartitionByRange()입니다. 이 두 함수는 데이터프레임 내에서 데이터를 파티션 간에 재분배하기 위해 일정한 로직을 사용합니다. 오늘은 repartition() 함수에 중점을 둘 것입니다.\n\n# 신화\n\n일반적으로 SQL 언어에서는 데이터를 파티션 키(예: 국가)로 파티션하면 해당 데이터가 국가 별로 여러 청크로 분할될 것이라는 개념을 자주 접하게 됩니다. 예를 들어, 이것은 일반적으로 사용되는 T-SQL 코드입니다:\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n```js\nSELECT\n    Country,\n    COUNT(Name) OVER (PARTITION BY Country) AS CountPerCountry\nFROM sample_data;\n```\n\nDatabricks의 Delta Tables을 사용하더라도 간단한 Spark SQL 절로 테이블을 파티션할 수 있어요:\n\n```js\nCREATE TABLE partitioned_country_table\nUSING DELTA\nPARTITIONED BY (Country)\nAS SELECT * FROM sample_data;\n```\n\nPySpark DataFrames를 사용할 때 파티션을 어떻게 볼지를 다시 고려하는 것이 중요해요. 확장 가능한 병렬 컴퓨팅을 위해 설계된 Spark에서는 파티션을 주로 데이터를 효율적으로 worker 노드에 분산시키는 데 사용하며 집계를 수행하는 데 사용되지는 않아요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n.repartition(columnName)을 사용하면 데이터가 columnName의 고유 값에 따라 자동으로 그룹화된다는 흔한 오해가 있습니다. 이 오해는 사람들이 \"repartition\"이란 용어가 데이터를 해당 열 값에 따라 별도의 그룹으로 재구성한다고 직감적으로 생각하기 때문에 발생합니다. 하지만 Spark에서는 .repartition(columnName)이 데이터를 재분배하여 병렬성을 달성하고 성능을 향상시키지만 모든 columnName 값을 가진 행이 반드시 동일한 파티션에 포함되는 것을 보장하지는 않습니다.\n\n가짜 데이터로 이를 증명해 봅시다.\n\n```python\nfrom faker import Faker\nimport random\nfrom pyspark.sql import SparkSession\nfrom pyspark.sql.types import *\nfrom pyspark.sql.functions import spark_partition_id, countDistinct\n\nspark_session = (\n    SparkSession.builder.master(\"local\")\n    .appName(\"Spark Repartitioning\")\n    .config(\"spark.sql.adaptive.enabled\", \"false\")\n    .getOrCreate()\n)\n\n# Faker 초기화\nfake = Faker()\n\n# 샘플 데이터 생성\ndef generate_data(num_records):\n    data = []\n    for _ in range(num_records):\n        name = fake.name()\n        country = fake.country()\n        data.append((name, country))\n    return data\n\ndata = generate_data(1000)  # 1000개 레코드 생성\ndata = spark_session.sparkContext.parallelize(data)\n\n# 데이터의 스키마 정의\nschema = StructType(\n    [\n        StructField(\"Name\", StringType(), True),\n        StructField(\"Country\", StringType(), True),\n    ]\n)\n\n# 데이터와 스키마를 사용하여 DataFrame 생성\ndf: DataFrame = spark_session.createDataFrame(data, schema)\ndf = df.repartition(\"Country\").withColumn(\"partitionId\", spark_partition_id())\n\n(\n    df.groupBy(\"partitionId\")\n    .agg(countDistinct(\"Country\").alias(\"DistinctCount\"))\n    .filter(\"DistinctCount \u003e 1\")\n    .show()\n)\n\n```\n\n```python\n+-----------+-------------+\n|partitionId|DistinctCount|\n+-----------+-------------+\n|         31|            2|\n|         85|            2|\n|         65|            3|\n|        155|            3|\n|         26|            4|\n|        103|            2|\n|         91|            2|\n|         22|            2|\n|        157|            2|\n|        177|            2|\n|         52|            2|\n|         13|            3|\n|         86|            2|\n|        178|            2|\n|         20|            2|\n|         40|            3|\n|         57|            2|\n|        120|            2|\n|         96|            2|\n|         48|            2|\n+-----------+-------------+\n상위 20개 행만 표시됨\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n보시다시피, 일부 DataFrame 파티션에는 파티션당 하나 이상의 나라가 포함되어 있어서, 처음에 기대했던 것과는 다릅니다. 그런데 왜 이런 일이 발생하는 걸까요?\n\n이 진실은 PySpark의 배경에 숨어 있습니다. repartition() 함수는 내부적으로 HashPartitioner를 호출하여 (이 멋진 Stack Overflow 댓글에서 설명된대로) 데이터를 파티션으로 분산합니다. 이 파티셔너는 데이터를 파티션에 따라 분배하기 위해 다음과 같이 정의된 공식을 사용합니다: hash(partitionKey) % numPartitions\n\n아래 다이어그램에 따라 데이터를 파티션에 분배합니다.\n\n![다이어그램](/TIL/assets/img/2024-07-14-TheTruthAboutPySparksRepartitionPreparetoBeSurprised_2.png)\n\n한 열을 계산하기 위해 스파크의 해시 파티셔너 동작을 모방하는데, 실제로는 해시 코드 및 파티션 수에 대한 음수가 아닌 모듈화가 발생한다는 점에 유의하십시오 (소스 코드에 따르면).\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](/TIL/assets/img/2024-07-14-TheTruthAboutPySparksRepartitionPreparetoBeSurprised_3.png)\n\n위의 다이어그램을 복제하는 PySpark 코드입니다.\n\n```python\nfrom pyspark.sql.functions import hash, col, lit, spark_partition_id, udf\n\ndata = [(\"Marshall Islands\",), (\"Tuvalu\",), (\"Somalia\",), (\"USA\",)]\n\nschema = StructType([StructField(\"Country\", StringType(), True)])\n\n# 파티션 수\nnum_partitions = 2\n\n# 해시 및 파티션 계산\ndf2 = df.withColumn(\"hash\", hash(col(\"Country\")))\ndf2 = df2.withColumn(\"num_partitions\", lit(num_partitions))\ndf2 = df2.withColumn(\n    \"hash(Country) % numPartitions\",\n    (col(\"hash\") % col(\"num_partitions\") + col(\"num_partitions\"))\n    % col(\"num_partitions\"),\n)\ndf2 = df2.repartition(num_partitions, col(\"Country\"))\ndf2 = df2.withColumn(\"spark_partition_id\", spark_partition_id())\ndf2.show()\n```\n\n![image](/TIL/assets/img/2024-07-14-TheTruthAboutPySparksRepartitionPreparetoBeSurprised_4.png)\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n보시다시피, 레코드가 어느 파티션에 끝날지 예측할 수 있으므로 .repartition() 함수가 더 이해하기 쉬워집니다.\n\n# 이게 왜 중요한가요?\n\n저는 직접 참여한 프로젝트에서의 실제 사용 사례로 생각해보겠습니다. 저희는 Databricks와 PySpark를 사용하여 수백 테라바이트의 매우 큰 데이터 세트를 이관했습니다. 데이터가 처리된 후에는 Spark MSSQL Connector를 사용하여 Azure SQL Server에 저장되었습니다. 테이블을 파티션별로 데이터를 저장할 때 높은 동시성을 보장하기 위해 경쟁과 대기 시간을 줄이기 위해 노력했습니다. 초기 접근 방식은 쓰기 프로세스 이전에 .repartition()을 사용하는 것이었는데, 이로 인해 일부 속도 이점을 얻었습니다. 그러나 여전히 락과 경합이 발생했습니다. 최종적으로 우리는 repartitionByRange()로 전환했고, 이 방법이 더 결정론적이며 우리의 SQL Server 테이블 파티셔닝 전략과 더 잘 부합한다는 것을 알게 되었습니다.\n\n이것은 한 가지 사용 사례에 불과하지만, 이 개념을 이해하는 것은 잠재적인 병목 현상을 식별하는 데 도움이 됩니다. repartitionByRange() 대 repartition()과 그들의 성능 영향에 대한 장단점에 대한 구체적인 기사를 쓰기로 계획하고 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론\n\nPySpark에서의 Repartitioning은 파이프라인 성능에 중요한 측면입니다. PySpark 파티션 내 데이터의 분포는 병렬성 뿐만 아니라 리소스 활용에도 영향을 미칩니다. 리소스를 더 효율적으로 사용하기 위해서는 적절한 파티셔닝이 필요합니다.\n\nrepartition() 메서드가 모든 문제를 해결해 주지는 않지만, 그 동작을 이해하는 것이 중요합니다. 이 메서드는 데이터를 분할하는 데 있어 파티션 키를 기준으로 결정적으로 분할하는 것이 아니라, 작업 노드에 데이터를 골고루 분배하여 성능과 병렬화를 향상시키는 데 사용됩니다.\n\n# 연락 유지하기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 이 글을 즐겼다면, 다른 파티션 함수에 대해 더 알고 싶다면 망설이지 말고 나를 팔로우해주세요. 그래야 최신 글들이 더 빨리 당신에게 전달될 거에요.\n\n- 더 이상 이야기들을 원하신다면 Medium에서 제게 팔로우해주세요.\n- LinkedIn에서 연락해주세요.\n\n참고해 주셔서 감사합니다 :)\n\n# 간단히 말해 🚀\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 클랩하고 팔로우해주세요 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io에서 더 많은 콘텐츠 만나보세요","ogImage":{"url":"/TIL/assets/img/2024-07-14-TheTruthAboutPySparksRepartitionPreparetoBeSurprised_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-TheTruthAboutPySparksRepartitionPreparetoBeSurprised_0.png","tag":["Tech"],"readingTime":10},{"title":"데이터 사이언스 마스터를 위한 11가지 필수 Python Matplotlib 시각화","description":"","date":"2024-07-14 19:59","slug":"2024-07-14-11EssentialPythonMatplotlibVisualizationsforDataScienceMastery","content":"\n\n## 파이썬 맷플롯립 시각화\n\n맷플롯립을 사용하면 파이썬으로 멋진 그림을 그릴 수 있어요. 데이터를 다양한 방식으로 표시할 수 있습니다. 많은 양의 코드가 필요하지 않아요. 선 그래프, 막대 차트 및 여러 종류의 차트를 만들 수 있어요.\n\n# 간단한 선 그래프\n\n- figures 와 axes: 맷플롯립에서 figure 는 상자 같아요. 플롯의 모든 부분을 보유해요. axes 는 figure 내부의 더 작은 상자처럼 생겼어요. 주변에 선들과 플롯의 의미를 알려주는 단어들이 있어요.\n- 변수 명명: Figure 객체는 일반적으로 `fig`로 이름을 짓고, axes 객체는 `ax`로 이름을 지어요.\n- 데이터 플로팅: `ax.plot` 메서드를 사용하여 axes에 데이터를 플로팅하세요.\n- Pylab 인터페이스: MATLAB과 유사한 인터페이스를 제공하여 자동으로 figure와 axes를 만들어줘요.\n- 여러 선: 동일한 figure에 여러 선을 그리려면 `plot` 함수를 여러 번 호출하세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport numpy as np\nimport matplotlib.pyplot as plt\nplt.style.use('seaborn-v0_8-whitegrid')\nfig = plt.figure()\nax = plt.axes()\nx = np.linspace(0, 10, 1000)\nplt.plot(x, np.sin(x))\nplt.plot(x, np.cos(x))\nplt.show()\n```\n\n![image](/TIL/assets/img/2024-07-14-11EssentialPythonMatplotlibVisualizationsforDataScienceMastery_0.png)\n\n# 간단한 산점도\n\n- 무엇인가: 산점도는 순서가 없는 점들을 가지고 있습니다. 선 그래프는 점들이 연결되어 있습니다.\n- 만드는 방법: 산점도를 그리려면 `plt.plot` 또는 `ax.plot`을 사용할 수 있습니다.\n- 점 스타일: 특별한 코드로 점의 모양을 변경할 수 있습니다. 문서에 어떤 코드를 사용해야 하는지 설명되어 있습니다.\n- `plt.scatter`의 재미있는 점: 각 점을 특별하게 만들 수 있습니다. 크기와 색상이 다를 수 있습니다. 이를 위해 데이터 세트를 사용합니다.\n- 투명한 점: 점을 서로 겹치게 만들 때 `alpha` 설정으로 점을 투명하게 만들 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport numpy as np\nimport matplotlib.pyplot as plt\nplt.style.use('seaborn-v0_8-whitegrid')\nrng = np.random.RandomState(0)\nx = rng.randn(100)\ny = rng.randn(100)\ncolors = rng.rand(100)\nsizes = 1000 * rng.rand(100)\nplt.scatter(x, y, c=colors, s=sizes, alpha=0.3,\n            cmap='viridis')\nplt.colorbar();\nplt.show()\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-11EssentialPythonMatplotlibVisualizationsforDataScienceMastery_1.png\" /\u003e\n\n# 오류 시각화\n\n- 왜 중요한가: 과학에서는 오류를 올바르게 이해하는 것이 측정 자체보다 중요하다.\n- 예를 들어: 허블 상수를 추측할 때 오류에 대해 고려해야 합니다. 이를 통해 서로 다른 측정 결과가 일치하는지 알 수 있습니다.\n- 불확실함 표현: 측정 값을 보고할 때 얼마나 확신이 없는지도 함께 말해야 합니다 (예: 71±2.5 (km/s)/Mpc). 이렇게 하면 데이터를 더 잘 비교할 수 있습니다.\n- 오류 표시: 차트에 오류를 넣으면 더 다양하고 정확한 정보를 얻을 수 있습니다.\n- `fmt` 설정: 차트에서 선과 점이 어떻게 보이는지를 제어합니다. `plt.plot` 코드와 비슷한 역할을 합니다.\n- `errorbar` 함수: 오차 막대 기호의 모양을 변경할 수 있게 해줍니다. 예를 들어, 가로로 만들어 진해지게 만들 수 있습니다.\n- 자신만의 스타일: 측면 오차 막대, 단측 오차 막대 등에 대한 더 많은 `errorbar` 설정을 활용하여 차트를 원하는 대로 꾸밉니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nplt.style.use('seaborn-v0_8-whitegrid')\nx = np.linspace(0, 10, 50)\ndy = 0.8\ny = np.sin(x) + dy * np.random.randn(50)\nplt.errorbar(x, y, yerr=dy, fmt='o', color='black',\n             ecolor='lightgray', elinewidth=3, capsize=0)\nplt.show()\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-11EssentialPythonMatplotlibVisualizationsforDataScienceMastery_2.png\" /\u003e\n\n# 밀도 및 등고도 플롯\n\n- 3D 데이터 시각화: 3D 데이터를 2D 차트로 표현하는 등고선 플롯이나 히트맵과 같은 차트 사용.\n- 함수 사용: 등고선 플로팅에는 `plt.contour`, 채워진 등고선 플로팅에는 `plt.contourf`, 이미지 형태로 플로팅에는 `plt.imshow` 사용.\n- 데이터 전처리: 1차원 배열로부터 2차원 그리드 생성하는 데 `np.meshgrid` 활용.\n- 등고선 플로팅하기: `plt.contour`는 그리드와 높이 값을 나타내는 `x`, `y`, `z`가 필요.\n- 선 스타일: 흑백 등고선 플롯에서 점선은 음수를, 실선은 양수를 의미.\n- 컬러 맵: `cmap`을 활용하여 등고선 색상 지정. 예를 들어, `RdGy`는 군집 데이터에 적합.\n- 컬러 바: 색상표를 만들기 위해 `plt.colorbar` 사용. 컬러 값의 범위를 보여줌.\n- 채워진 등고선 플로팅: `plt.contourf`를 사용하여 등고선 플로팅을 채움. 간격이 적고 보기 좋음.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n```js\nimport numpy as np\nimport matplotlib.pyplot as plt\nplt.style.use('seaborn-v0_8-whitegrid')\ndef f(x, y):\n    return np.sin(x) ** 10 + np.cos(10 + y * x) * np.cos(x)\nx = np.linspace(0, 5, 50)\ny = np.linspace(0, 5, 40)\nX, Y = np.meshgrid(x, y)\nZ = f(X, Y)\nplt.contourf(X, Y, Z, 20, cmap='RdGy')\nplt.colorbar();\nplt.show()\n```\n\n![Image](/TIL/assets/img/2024-07-14-11EssentialPythonMatplotlibVisualizationsforDataScienceMastery_3.png)\n\n# 히스토그램, Binning 및 Density\n\n- 기본 히스토그램: Matplotlib의 `hist()` 함수를 사용하여 빠르게 기본 히스토그램을 생성합니다.\n- 매개변수 조정: `hist()`는 히스토그램 계산 및 표시를 조정하기 위한 매개변수를 제공합니다.\n- 설정 변경: 더 이상 `normed`를 사용하지 마세요. 대신 정규화하기 위해 `density`를 사용하세요.\n- 자신만의 스타일: `histtype='stepfilled'` 및 `alpha`를 사용하여 투명한 막대를 만들어서 서로 다른 데이터를 일치시키는 데 유용합니다.\n- 자세히 알아보기: `plt.hist` 문서를 확인하여 변경할 수 있는 방법에 대해 더 배우세요.\n- 숫자만 필요한 경우: 플롯 없이 히스토그램 숫자만 얻으려면 `np.histogram()`을 사용하세요.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport numpy as np\nimport matplotlib.pyplot as plt\nplt.style.use('seaborn-v0_8-whitegrid')\nx1 = np.random.normal(0, 0.8, 1000)\nx2 = np.random.normal(-2, 1, 1000)\nx3 = np.random.normal(3, 2, 1000)\nkwargs = dict(histtype='stepfilled', alpha=0.3, density=True, bins=40)\nplt.hist(x1, **kwargs)\nplt.hist(x2, **kwargs)\nplt.hist(x3, **kwargs);\nplt.show()\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-11EssentialPythonMatplotlibVisualizationsforDataScienceMastery_4.png\" /\u003e\n\n# 사용자 정의 범례\n\n- 중요성: 범례는 시각화에 의미를 부여하여 다양한 차트 요소를 명확하게 해줍니다.\n- 키 만들기: 이름으로 차트 부분에 키를 만들려면 `plt.legend()`를 사용합니다.\n- 다양한 설정: 키가 위치하게 할 곳을 선택하세요. 상자를 제거하세요. 여러 행을 사용하세요. 둥근 모서리 또는 그림자를 사용하세요. 투명도와 단어 간 간격을 조절하세요.\n- 표시할 항목 선택: 키에 들어갈 부분과 이름을 지정하세요. 이를 수행하려면 'plot'이 제공하는 것을 설정하세요.\n- 다수의 선: `plt.plot`은 여러 개의 선을 제공할 수 있습니다. 원하는대로 키를 만들려면 `plt.legend()`에 제공할 선을 선택하세요.\n- 부분에 이름 지정: 차트 부분에 직접 이름을 지정하세요. 그런 다음 키에 그 이름을 넣어서 쉽게 식별할 수 있도록 하세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nplt.style.use('seaborn-v0_8-whitegrid')\nx = np.linspace(0, 10, 1000)\ny = np.sin(x[:, np.newaxis] + np.pi * np.arange(0, 2, 0.5))\n\nplt.plot(x, y[:, 0], label='first')\nplt.plot(x, y[:, 1], label='second')\nplt.plot(x, y[:, 2:])\nplt.legend(framealpha=1, frameon=True)\nplt.show()\n```\n\n![Custom Colorbars](/TIL/assets/img/2024-07-14-11EssentialPythonMatplotlibVisualizationsforDataScienceMastery_5.png)\n\n# 사용자 정의 컬러바\n\n범례 vs. 컬러바: 범례는 이산적인 레이블을 나타내는 반면, 컬러바는 연속값-색상 관계를 나타냅니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n색상 막대 만들기: `plt.colorbar()`을 사용하여 색상 막대를 만듭니다.\n\n칼라맵: `cmap` 매개변수를 사용하여 칼라맵을 지정합니다.\n\n칼라맵 자원: 모든 사용 가능한 칼라맵은 `plt.cm` 모듈에서 찾을 수 있습니다. 칼라맵을 나열하려면 IPython의 탭 자동완성을 사용하세요.\n\n칼라맵 유형:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- a. 연속 색상지도: `binary` 또는 `viridis`와 같은 단일 연속 색상 시리즈입니다.\n- b. 발산 색상지도: `RdBu` 또는 `PuOr`와 같은 두 가지 대조되는 색상 시리즈입니다.\n- c. 질적 색상지도: `rainbow` 또는 `jet`과 같이 연속적이지 않은 색상 조합입니다.\n\n```js\nimport numpy as np\nimport matplotlib.pyplot as plt\nplt.style.use('classic')\nx = np.linspace(0, 10, 1000)\nI = np.sin(x) * np.cos(x[:, np.newaxis])\nplt.imshow(I, aspect='auto', cmap='viridis')\nplt.colorbar()\nplt.show()\n```\n\n![Visualization](/TIL/assets/img/2024-07-14-11EssentialPythonMatplotlibVisualizationsforDataScienceMastery_6.png)\n\n# 다중 서브플롯\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 컨셉: Matplotlib은 데이터를 옆으로 나란히 표시하기 위해 단일 그림에서 여러 서브플롯을 허용합니다.\n- 서브플롯 생성: `plt.axes()`를 사용하여 서브플롯을 생성하고, 위치와 크기를 `[왼쪽, 아래, 너비, 높이]`의 리스트 매개변수로 지정합니다.\n- 기본 동작: `plt.axes()`는 보통 전체 그림 영역을 채우는 축 객체를 만듭니다.\n- 정렬: `plt.subplot()`을 사용하여 그리드 안에 서브플롯을 생성하고, 행, 열 및 서브플롯 인덱스에 대한 매개변수를 사용합니다.\n- 다중 행/열: `plt.GridSpec()`를 사용하여 여러 행 또는 열에 걸쳐있는 서브플롯을 만들고, 그리드 레이아웃을 정의합니다.\n- GridSpec 사용법: `plt.GridSpec()`은 그리드 레이아웃을 정의하고, 서브플롯 생성 시 `plt.subplot()`에 전달할 수 있습니다.\n- GridSpec 특징: 직접 차트를 만들지는 않지만 서브플롯 그리드 레이아웃을 정의합니다.\n\n```js\nimport numpy as np\nimport matplotlib.pyplot as plt\nplt.style.use('seaborn-v0_8-whitegrid')\nmean = [0, 0]\ncov = [[1, 1], [1, 2]]\nx, y = np.random.multivariate_normal(mean, cov, 3000).T\n# GridSpec를 사용하여 그리드를 생성하고 서브플롯을 추가합니다\nfig = plt.figure(figsize=(6, 6))\ngrid = plt.GridSpec(4, 4, hspace=0.2, wspace=0.2)\nmain_ax = fig.add_subplot(grid[:-1, 1:])\ny_hist = fig.add_subplot(grid[:-1, 0], xticklabels=[], sharey=main_ax)\nx_hist = fig.add_subplot(grid[-1, 1:], yticklabels=[], sharex=main_ax)\n# 주요 서브플롯에 산점도를 플롯합니다\nmain_ax.plot(x, y, 'ok', markersize=3, alpha=0.2)\n# x와 y 방향으로 히스토그램을 플롯합니다\nx_hist.hist(x, 40, histtype='stepfilled',\n            orientation='vertical', color='gray')\nx_hist.invert_yaxis() # x축 히스토그램의 y축 방향을 반전합니다 (우측 하단에 위치)\ny_hist.hist(y, 40, histtype='stepfilled',\n            orientation='horizontal', color='gray')\ny_hist.invert_xaxis() # y축 히스토그램의 x축 방향을 반전합니다 (상단 좌측에 위치)\nplt.show()\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-11EssentialPythonMatplotlibVisualizationsforDataScienceMastery_7.png\" /\u003e\n\n# 텍스트 및 주석\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 목적: 시각화는 데이터 뒤에 숨겨진 이야기를 독자에게 전달하기 위해 노력합니다.\n- 표현: 일부 차트는 그 자체로 이야기를 전달하지만, 다른 차트는 텍스트 지원이 필요합니다.\n- 주석: 차트에 텍스트 주석을 추가하여 독자의 주의를 끌고 이해를 돕습니다.\n- 텍스트 배치: 차트의 특정 위치(`x`, `y`)에 텍스트를 추가하려면 `plt.text` 또는 `ax.text`를 사용하세요.\n- 가이드: 정보 전달을 향상시키기 위해 텍스트 주석을 통해 독자를 주요 차트 기능으로 안내하세요.\n\n```js\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport matplotlib.dates as mdates\nplt.style.use('seaborn-v0_8-whitegrid')\n# 샘플 데이터셋 생성\ndates = pd.date_range(start='1969-01-01', end='1988-12-31', freq='D')\ndata = np.random.randint(3000, 5000, size=len(dates))\nbirths = pd.DataFrame(data, columns=['births'], index=dates)\nfig, ax = plt.subplots(figsize=(12, 4))\nbirths_by_date = births.pivot_table('births', [births.index.month, births.index.day])\nbirths_by_date.index = [pd.Timestamp(year=2012, month=month, day=day) for month, day in births_by_date.index]\nbirths_by_date.plot(ax=ax)\n# 선 플롯의 특정 위치에 주석 추가\nstyle = dict(size=10, color='gray')\nax.text(pd.Timestamp('2012-1-1'), 3950, \"New Year's Day\", **style)\nax.text(pd.Timestamp('2012-7-4'), 4250, \"Independence Day\", ha='center', **style)\nax.text(pd.Timestamp('2012-9-4'), 4850, \"Labor Day\", ha='center', **style)\nax.text(pd.Timestamp('2012-10-31'), 4600, \"Halloween\", ha='right', **style)\nax.text(pd.Timestamp('2012-11-25'), 4450, \"Thanksgiving\", ha='center', **style)\nax.text(pd.Timestamp('2012-12-25'), 3850, \"Christmas\", ha='right', **style)\n# 제목과 y축 레이블 설정\nax.set(title='USA births by day of year (1969-1988)',\n       ylabel='average daily births')\n# x축에 월 레이블을 중앙에 정렬\nax.xaxis.set_major_locator(mdates.MonthLocator())\nax.xaxis.set_minor_locator(mdates.MonthLocator(bymonthday=15))\nax.xaxis.set_major_formatter(plt.NullFormatter())\nax.xaxis.set_minor_formatter(mdates.DateFormatter('%b'))\nplt.show()\n```\n\n# 커스텀 눈금\n\n- 눈금 변경: Matplotlib의 보통 눈금은 대부분의 차트에 적합합니다. 그러나 일부를 위해 변경해야 할 수도 있습니다.\n- 물건 속의 물건: Matplotlib의 모든 차트 부분은 물건입니다. 도표에는 축이 있습니다. 축에는 차트 요소가 있습니다.\n- 축 요소: 축에는 `xaxis`와 `yaxis`가 있습니다. 이들은 선, 눈금, 이름 등을 가지고 있습니다.\n- 새 버전: Matplotlib 2.0 이후로 긴 축에 작은 눈금이 숨겨지게 되었습니다. 이것은 `xlim`과 `ylim`으로 변경할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\n\r\nplt.style.use('seaborn-v0_8-whitegrid')\r\nfig, ax = plt.subplots()\r\nx = np.linspace(0, 3 * np.pi, 1000)\r\nax.plot(x, np.sin(x), lw=3, label='Sine')\r\nax.plot(x, np.cos(x), lw=3, label='Cosine')\r\nax.grid(True)\r\nax.legend(frameon=False)\r\nax.axis('equal')\r\nax.set_xlim(0, 3 * np.pi)\r\nplt.show()\r\n```\r\n\r\n\u003cimg src=\"/TIL/assets/img/2024-07-14-11EssentialPythonMatplotlibVisualizationsforDataScienceMastery_8.png\" /\u003e\r\n\r\n# Matplotlib에서 3D 플롯 만들기\r\n\r\n- 2D에서 3D로: Matplotlib은 처음에는 2D 플롯만 지원했지만, 3D 플롯 도구는 버전 1.0에서 소개되었습니다.\r\n- 3D 도구 모음: 3D 플로팅은 Matplotlib과 함께 제공되는 `mplot3d` 도구 모음을 로드하여 수행됩니다.\r\n- 3D 플롯 유형: 3D 축을 활성화한 후 3D 라인 및 산점도와 같은 다양한 3D 플롯을 그릴 수 있습니다.\r\n- 3D 플로팅 함수: 3D 라인 플롯 및 산점도 플롯에는 각각 `ax.plot3D` 및 `ax.scatter3D`를 사용합니다.\r\n- 투명도와 깊이: 깊이를 나타내기 위해 산점도 플롯에는 다양한 투명도가 적용됩니다.\r\n- 대화식 뷰: 대화식 뷰를 통해 더 나은 3D 시각 경험을 제공합니다.\r\n- 3D 버프 맵: `mplot3d` 도구 모음에는 3D 버프 맵을 만드는 도구가 있습니다. 이것들은 2D `ax.contour`와 유사합니다.\r\n- 3D 표면 차트: 표면 차트는 색의 변화로 3D 표면을 보여줍니다. 와이어 차트보다 더 나은 시각적 효과를 제공합니다.\r\n- 그리드 데이터 이미지: 그리드 데이터에서 생성된 3D 이미지에는 와이어 차트와 표면 차트가 있습니다. 데이터를 3D 모양에 표시하여 더 명확하고 설득력있게 만듭니다.\r\n- 틱 스타일 변경: 일반 틱 스타일은 대부분의 작업에 적합하지만, 사인 및 코사인 차트와 같은 특정 차트에 대해 변경해야 할 수 있습니다.\r\n- 사용자 정의 예제: 틱이 위치하고 어떻게 보이는지 변경하면 차트가 무엇을 의미하는지 더 잘 보여줄 수 있습니다. 데이터에 딱 맞게 맞출 수 있습니다.\r\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfig = plt.figure()\nax = plt.axes(projection='3d')\ndef f(x, y):\n    return np.sin(np.sqrt(x ** 2 + y ** 2))\nx = np.linspace(-6, 6, 30)\ny = np.linspace(-6, 6, 30)\nX, Y = np.meshgrid(x, y)\nZ = f(X, Y)\nax.set_xlabel('x')\nax.set_ylabel('y')\nax.set_zlabel('z')\n# Flatten the X, Y, Z arrays for plot_trisurf\nax.plot_trisurf(X.flatten(), Y.flatten(), Z.flatten(),\n                cmap='viridis', edgecolor='none')\nplt.show()\n\n\n![Image](/TIL/assets/img/2024-07-14-11EssentialPythonMatplotlibVisualizationsforDataScienceMastery_9.png)\n\n저는 \"Medium에서 팔로워를 빠르게 얻는 법\"에 대한 전자책을 쓰고 있어요. 왜냐하면 제가 최고의 증거이기 때문이죠 – 딱 한 달 만에 5,000명 이상의 팔로워를 얻었어요. 기대해 주세요!\n\nSubstack에서 \"GPT 소개\" 시리즈를 쓰고 있어요. 관심 있으시면 팔로우 해주세요!\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n총 10개의 글 중 일곱 번째가 이미 완료되었어요!\n\n독서📖, 형광펜 강조🖍️, 박수👏, 댓글💬, 공유🗣️해 주셔서 감사합니다. \"Medium 친구\"로서, 매일 작가 친구들에게 호의를 돌려드릴 수 있도록 최선을 다하고 있어요.\n\n또한, 뉴스레터📰를 구독하여 이와 같은 멋진 콘텐츠가 올라올 때마다 알림을 받을 수 있어요. 고맙구나, 친애하는 챔프!🤓\n\n최신 파이썬 이야기를 계속해서 받아보려면 Substack에서 저희와 연결해주세요. 함께 파이썬의 미래를 함께 만들어요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 즐겨보세요","ogImage":{"url":"/TIL/assets/img/2024-07-14-11EssentialPythonMatplotlibVisualizationsforDataScienceMastery_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-11EssentialPythonMatplotlibVisualizationsforDataScienceMastery_0.png","tag":["Tech"],"readingTime":16}],"page":"5","totalPageCount":34,"totalPageGroupCount":2,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"5"},"buildId":"jKAIrnIuHBv4ZHjiQbX6i","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>