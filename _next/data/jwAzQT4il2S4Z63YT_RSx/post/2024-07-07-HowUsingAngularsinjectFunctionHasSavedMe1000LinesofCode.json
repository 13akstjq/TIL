{"pageProps":{"post":{"title":"Angular의 inject 함수 사용으로 1000줄의 코드를 절약한 방법","description":"","date":"2024-07-07 21:51","slug":"2024-07-07-HowUsingAngularsinjectFunctionHasSavedMe1000LinesofCode","content":"\n\n# inject() 함수란 무엇인가요?\n\nAngular 14에서 소개된 inject() 함수는 서비스, 컴포넌트, 디렉티브 등에 종속성을 주입하는 데 사용됩니다. 클래스 생성자를 사용하여 종속성을 주입하는 대신 inject() 함수를 사용할 수 있습니다.\n\n![이미지](/assets/img/2024-07-07-HowUsingAngularsinjectFunctionHasSavedMe1000LinesofCode_0.png)\n\n## 생성자를 사용하여 종속성을 주입하는 예전 방식:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport { Component } from '@angular/core';\n\n@Component({ /* ... */ })\nexport class MyComponent {\n  constructor(\n    @Inject(SOME_TOKEN) private readonly someToken: string,\n    private readonly myService: MyService,\n    private readonly httpClient: HttpClient,\n  ) {}\n}\n```\n\n## inject() 함수를 사용한 의존성 주입의 새로운 방법:\n\n```js\nimport { Component, inject } from '@angular/core';\n\n@Component({ /* ... */ })\nexport class MyComponent {\n  private readonly someToken = inject(SOME_TOKEN);\n  private readonly myService = inject(MyService);\n  private readonly httpClient = inject(HttpClient);\n}\n```\n\n# inject() 사용의 장점 vs 생성자 사용하기\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n주목하신 대로, 생성자 대신 inject()을 사용하는 것에는 여러 가지 장점이 있습니다:\n\n- 코드를 더 깔끔하고 가독성이 좋고 일관성 있게 만듭니다 (토큰 vs 서비스 주입 시에도)\n- 타입이 자동으로 추론되어 수동으로 지정할 필요가 없습니다\n- 상속이 간편하고 덜 장황합니다 (자세한 내용은 아래에서 설명)\n\n# 더 나은 상속\n\n저는 상속과 관련된 경우 inject() 함수가 특히 유용하다고 생각합니다. 코드를 재사용하고 여러 자식 클래스에 의해 확장될 부모 서비스 추상 클래스가 있는 시나리오를 고려해 보세요:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nexport abstract class ParentService {\n  constructor(\n    protected readonly configKey: string,\n    protected readonly httpClient: HttpClient,\n    protected readonly helperService: HelperService,\n  ) {}\n\n  // ... some code here that will be reused in the children of ParentService\n}\n```\n\nParentService의 하위 클래스는 다음과 같이 확장됩니다:\n\n```js\n@Injectable({ providedIn: 'root' })\nexport class ChildService extends ParentService {\n  constructor(\n    protected readonly httpClient: HttpClient,\n    protected readonly helperService: HelperService,\n  ) {\n    super('my-config-key', httpClient, helperService);\n  }\n\n  // ... some child-specific code here\n}\n```\n\n보시다시피 많은 반복이 있습니다: 모든 자식 클래스들은 HttpClient와 HelperService를 가져와야 하는데 이는 ParentService의 생성자가 필요하기 때문입니다.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\ninject() 함수 덕분에 이 불필요한 반복을 피할 수 있어요:\n\n```js\nexport abstract class ParentService {\n  protected abstract readonly configKey: string; // \"abstract\"을 사용하여 자식 클래스가 이 필드를 초기화하도록 강제합니다\n  protected readonly httpClient = inject(HttpClient);\n  protected readonly helperService = inject(HelperService);\n\n  // ... 부모 서비스의 자식에서 재사용될 코드가 있습니다 ...\n}\n\n@Injectable({ providedIn: 'root' })\nexport class ChildService extends ParentService {\n  protected readonly configKey = 'my-config-key';\n\n  // ... 자식에만 해당하는 코드가 있습니다\n}\n```\n\n결과적으로 코드가 훨씬 깔끔해지고 반복을 피할 수 있습니다: ParentService의 자식들은 HttpClient 및 HelperService를 가져와 부모에게 전달할 필요가 없지만, 필요한 경우에 this.httpClient 및 this.helperService에 액세스 할 수 있습니다.\n\n의존성이 많고 많은 자식이 기본 클래스를 확장하는 시나리오를 상상해보세요, inject()를 사용하면 많은 코드 라인을 절약할 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 실제 사용 사례 예\n\n2019년에 Angular을 사용하여 구축한 오래된 프로젝트를 리팩토링할 때 inject() 함수를 사용했습니다. 생성자를 없애거나 사용을 줄이는 것만으로 약 1000줄 이상의 코드를 제거할 수 있었습니다. 변경 내용은 이 커밋에서 확인할 수 있습니다.\n\n네, 무엇을 생각하고 계시는지 알겠어요. 상속 대신 구성을 고려해볼 수 있었다는 주장을 할 수 있겠지만, 이에 대한 논의는 이 글의 범위를 벗어납니다.\n\n# 결론\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- inject() 함수는 일반적으로 생성자를 사용하는 것보다 선호되는 의존성을 효율적이고 현대적인 방법으로 주입해주는 기능을 제공합니다.\n- inject()를 사용하도록 코드베이스를 마이그레이션하는 것이 쉽고, 특히 상속을 다루어야 할 때 유용할 것입니다.\n- 기존 레거시 프로젝트에서도 gradually(점진적으로) inject()를 채택할 수 있으며, 코드베이스를 한꺼번에 마이그레이션할 필요가 없습니다.","ogImage":{"url":"/assets/img/2024-07-07-HowUsingAngularsinjectFunctionHasSavedMe1000LinesofCode_0.png"},"coverImage":"/assets/img/2024-07-07-HowUsingAngularsinjectFunctionHasSavedMe1000LinesofCode_0.png","tag":["Tech"],"readingTime":5},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<h1>inject() 함수란 무엇인가요?</h1>\n<p>Angular 14에서 소개된 inject() 함수는 서비스, 컴포넌트, 디렉티브 등에 종속성을 주입하는 데 사용됩니다. 클래스 생성자를 사용하여 종속성을 주입하는 대신 inject() 함수를 사용할 수 있습니다.</p>\n<p><img src=\"/assets/img/2024-07-07-HowUsingAngularsinjectFunctionHasSavedMe1000LinesofCode_0.png\" alt=\"이미지\"></p>\n<h2>생성자를 사용하여 종속성을 주입하는 예전 방식:</h2>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Component</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@angular/core'</span>;\n\n@<span class=\"hljs-title class_\">Component</span>({ <span class=\"hljs-comment\">/* ... */</span> })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyComponent</span> {\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">\n    @Inject(SOME_TOKEN) private readonly someToken: string,\n    private readonly myService: MyService,\n    private readonly httpClient: HttpClient,\n  </span>) {}\n}\n</code></pre>\n<h2>inject() 함수를 사용한 의존성 주입의 새로운 방법:</h2>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Component</span>, inject } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@angular/core'</span>;\n\n@<span class=\"hljs-title class_\">Component</span>({ <span class=\"hljs-comment\">/* ... */</span> })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyComponent</span> {\n  private readonly someToken = <span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-variable constant_\">SOME_TOKEN</span>);\n  private readonly myService = <span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-title class_\">MyService</span>);\n  private readonly httpClient = <span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-title class_\">HttpClient</span>);\n}\n</code></pre>\n<h1>inject() 사용의 장점 vs 생성자 사용하기</h1>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>주목하신 대로, 생성자 대신 inject()을 사용하는 것에는 여러 가지 장점이 있습니다:</p>\n<ul>\n<li>코드를 더 깔끔하고 가독성이 좋고 일관성 있게 만듭니다 (토큰 vs 서비스 주입 시에도)</li>\n<li>타입이 자동으로 추론되어 수동으로 지정할 필요가 없습니다</li>\n<li>상속이 간편하고 덜 장황합니다 (자세한 내용은 아래에서 설명)</li>\n</ul>\n<h1>더 나은 상속</h1>\n<p>저는 상속과 관련된 경우 inject() 함수가 특히 유용하다고 생각합니다. 코드를 재사용하고 여러 자식 클래스에 의해 확장될 부모 서비스 추상 클래스가 있는 시나리오를 고려해 보세요:</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">export</span> abstract <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ParentService</span> {\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">\n    protected readonly configKey: string,\n    protected readonly httpClient: HttpClient,\n    protected readonly helperService: HelperService,\n  </span>) {}\n\n  <span class=\"hljs-comment\">// ... some code here that will be reused in the children of ParentService</span>\n}\n</code></pre>\n<p>ParentService의 하위 클래스는 다음과 같이 확장됩니다:</p>\n<pre><code class=\"hljs language-js\">@<span class=\"hljs-title class_\">Injectable</span>({ <span class=\"hljs-attr\">providedIn</span>: <span class=\"hljs-string\">'root'</span> })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ChildService</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">ParentService</span> {\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">\n    protected readonly httpClient: HttpClient,\n    protected readonly helperService: HelperService,\n  </span>) {\n    <span class=\"hljs-variable language_\">super</span>(<span class=\"hljs-string\">'my-config-key'</span>, httpClient, helperService);\n  }\n\n  <span class=\"hljs-comment\">// ... some child-specific code here</span>\n}\n</code></pre>\n<p>보시다시피 많은 반복이 있습니다: 모든 자식 클래스들은 HttpClient와 HelperService를 가져와야 하는데 이는 ParentService의 생성자가 필요하기 때문입니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>inject() 함수 덕분에 이 불필요한 반복을 피할 수 있어요:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">export</span> abstract <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ParentService</span> {\n  protected abstract readonly <span class=\"hljs-attr\">configKey</span>: string; <span class=\"hljs-comment\">// \"abstract\"을 사용하여 자식 클래스가 이 필드를 초기화하도록 강제합니다</span>\n  protected readonly httpClient = <span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-title class_\">HttpClient</span>);\n  protected readonly helperService = <span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-title class_\">HelperService</span>);\n\n  <span class=\"hljs-comment\">// ... 부모 서비스의 자식에서 재사용될 코드가 있습니다 ...</span>\n}\n\n@<span class=\"hljs-title class_\">Injectable</span>({ <span class=\"hljs-attr\">providedIn</span>: <span class=\"hljs-string\">'root'</span> })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ChildService</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">ParentService</span> {\n  protected readonly configKey = <span class=\"hljs-string\">'my-config-key'</span>;\n\n  <span class=\"hljs-comment\">// ... 자식에만 해당하는 코드가 있습니다</span>\n}\n</code></pre>\n<p>결과적으로 코드가 훨씬 깔끔해지고 반복을 피할 수 있습니다: ParentService의 자식들은 HttpClient 및 HelperService를 가져와 부모에게 전달할 필요가 없지만, 필요한 경우에 this.httpClient 및 this.helperService에 액세스 할 수 있습니다.</p>\n<p>의존성이 많고 많은 자식이 기본 클래스를 확장하는 시나리오를 상상해보세요, inject()를 사용하면 많은 코드 라인을 절약할 수 있습니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h2>실제 사용 사례 예</h2>\n<p>2019년에 Angular을 사용하여 구축한 오래된 프로젝트를 리팩토링할 때 inject() 함수를 사용했습니다. 생성자를 없애거나 사용을 줄이는 것만으로 약 1000줄 이상의 코드를 제거할 수 있었습니다. 변경 내용은 이 커밋에서 확인할 수 있습니다.</p>\n<p>네, 무엇을 생각하고 계시는지 알겠어요. 상속 대신 구성을 고려해볼 수 있었다는 주장을 할 수 있겠지만, 이에 대한 논의는 이 글의 범위를 벗어납니다.</p>\n<h1>결론</h1>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>inject() 함수는 일반적으로 생성자를 사용하는 것보다 선호되는 의존성을 효율적이고 현대적인 방법으로 주입해주는 기능을 제공합니다.</li>\n<li>inject()를 사용하도록 코드베이스를 마이그레이션하는 것이 쉽고, 특히 상속을 다루어야 할 때 유용할 것입니다.</li>\n<li>기존 레거시 프로젝트에서도 gradually(점진적으로) inject()를 채택할 수 있으며, 코드베이스를 한꺼번에 마이그레이션할 필요가 없습니다.</li>\n</ul>\n</body>\n</html>\n"},"__N_SSG":true}