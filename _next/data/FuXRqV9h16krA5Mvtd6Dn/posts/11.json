{"pageProps":{"posts":[{"title":"Fed 모델을 이용한 주식 시장 가치 평가 및 방향 예측 방법","description":"","date":"2024-07-13 19:06","slug":"2024-07-13-PredictingStockMarketValuationandDirectionUsingtheFedModel","content":"\n\n![image](/TIL/assets/img/2024-07-13-PredictingStockMarketValuationandDirectionUsingtheFedModel_0.png)\n\n코르델 태니(Cordell Tanny)는 금융 서비스 분야에서 24년 이상의 경험을 보유한 전문가로, 주로 양적 금융에 특화되어 있습니다. 코르델는 이전에 주요 캐나다 기관에서 양적 분석가 및 포트폴리오 매니저로 근무하며 20억 달러 규모의 다자산 소매 투자 프로그램을 관리했습니다.\n\n현재 코르델는 Trend Prophets의 대표이사이자 공동 창립자로 활동하고 있으며, 양적 금융 및 AI 솔루션 기업인 DigitalHub Insights의 경영 이사로도 활동하고 있습니다. 또한, 코르델는 맥길 대학(McGill University)에서 생물학 학사 학위를 취득한 바 있습니다. 그는 CFA 채터홀더로서 금융 리스크 관리자 자격증을 보유하고 있으며, 금융 데이터 전문가 자격증을 소지하고 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\ntrendprophets.com을 방문하여 더 많은 정보를 얻을 수 있어요.\n\n이 기사에 대한 모든 Python 코드는 code templates를 등록하면 여기에서 찾을 수 있어요 (페이지 하단의 code templates에 등록하기란 부분에 있어요).\n\nS&P 500의 역사적 PE 데이터는 macrotrends.net의 공짜 다운로드로 이용 가능해요.\n\nGitHub 저장소에도 이용 가능해요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 간단 버전\n\n요약\n\nFed Model Basics: S&P 500의 수익률을 10년 만기 미국 국채 수익률과 비교하여 시장의 매력도를 평가합니다.\n\n스프레드 해석: 양의 스프레드는 주식이 저평가되었음을 나타내고, 음의 스프레드는 채권이 더 매력적이라는 것을 시사합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n인기를 얻은 Ed Yardeni에 의해 만들어진 이 모델은 혼돈스럽지만 여전히 유용한 가치평가 도구로 남아 있습니다.\n\n중요한 점\n\n투자 전략: 이 스프레드를 이해하면 투자자가 주식과 채권 간 자산배분에 관한 판단을 내릴 수 있습니다.\n\n현재 시장 상황: 16년 만에 처음으로 스프레드가 마이너스로 전환되었으며, 이는 주식이 과대평가되었을 가능성과 채권의 매력성을 시그널하는 신호입니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n인플레이션의 역할: 그레인저 인과관계 검정 결과에 따르면, 과거 CPI 인플레이션율은 연방준비제도 모형 차이를 예측할 수 있어 시장 예측에 통찰을 제공합니다.\n\n자세한 내용과 전체 이야기를 원하시는 분은 아래를 참조해주세요.\n\n# 큰 그림\n\n## 소개\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nFed Model은 주식이 채권보다 더 매력적인지 여부를 식별하는 데 도움을 주는 두 가지 지표를 사용하는 비교적 단순한 분석 기법입니다. 또한 시장 타이밍 모델로 활용될 수 있습니다. 이 두 가지 지표는 다음과 같습니다:\n\n- S&P 500의 주당 순이익률(주가 이익 비율의 역수)\n- 최근 10년 만기 미국 국채의 수익률\n\nFed Model은 주당 순이익률과 채권 수익률의 차이로 계산됩니다. 주당 순이익률은 지수가 얼마나 많이 벌어들이고 있는지(지수 안의 회사들의 모든 기업 이익의 합)를 나타내며 인덱스의 달러 가치당 가격의 누적 가치(인덱스 내의 모든 기업들의 가치의 누적 달러 가치)를 나타냅니다. 높은 주당 순이익률은 투자자들이 총 가격의 백분율로 초과 이익을 획득하고 있다는 것을 시사합니다.\n\n## 스프레드 해석과 그 영향\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nFed 모델은 S&P 500의 수익률과 10년 만기 미국 국채의 이자율 간의 차이로 정의됩니다. 이 차이는 투자자가 주식과 채권 간 상대적 매력성을 비교하는 데 도움을 줍니다.\n\n- 양수 차이: S&P 500의 수익률이 10년 만기 미국 국채의 수익률보다 높을 때 차이가 양수입니다. 이는 주식에 대한 투자자가 채권 대비 더 높은 수익을 얻고 있음을 나타냅니다. 양수 차이는 주식이 적정 가치에 있을 수도 있거나 상대적으로 안전한 채권 대비 주식 시장이 더 나은 성장 가능성을 제공할 수 있다는 점을 시사합니다.\n\n- 음수 차이: 반대로, 수익률이 10년 만기 국채의 이자율보다 낮을 때 차이는 음수입니다. 이 상황은 주식 대비로 채권이 더 매력적인 것을 시사할 수도 있습니다. 주식 시장이 과도하게 평가되었거나 경제 전망이 불확실할 경우 투자자들은 채권의 안전성을 추구할 수 있습니다.\n\n## Fed 모델의 (매우) 간단한 역사\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n내가 가장 좋아하는 투자 전략가 중 한 명이 페드 모델을 인기 있게 만들었어. 에드 야르데니는 주식 시장 수익과 장기 국채 수익률 사이의 관계를 분석한 작업을 기반으로 상당한 양의 작업물을 제작했지. 페드는 주식 수익률과 채권 수익률 사이의 관계를 보여주는 그래프를 많이 제작했지만, 그것을 모델로 형식화하거나 발표하거나 공식적으로 보증한 적은 없었어. 앨런 그린스팬은 중앙은행을 이끌 때 몇몇 기자회견에서 그에 대해 언급했어.\n\n이 모델의 간단함이 매우 매력적이지. 스프레드가 양수이면 주식을 사고, 음수이면 채권을 사라고. 시간 지표로서의 신뢰성은 조금 불안정하지만. 특히 2008년 대공황의 시간을 잘 맞추지 못했어. 그러나 완벽한 지표는 없으니까 우리는 항상 다른 지표들로부터 확인을 받아보는 게 좋지. 그러나 이는 확실하게 채권과 주식 사이의 상대적 가치 측정 수단이야.\n\n## 모델 시간에 따른 간단한 검토\n\n![이미지](/TIL/assets/img/2024-07-13-PredictingStockMarketValuationandDirectionUsingtheFedModel_1.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n제 1표는 1991년 이후 레세션 밴드가 중첩된 Fed 모델의 플롯을 보여줍니다. 우리는 또한 스프레드가 음수가 될 때를 나타내기 위해 y=0에 수평선을 그렸습니다. 이제 이는 스프레드이므로 양수 또는 음수의 판독이 발생할 수 있다는 점을 기억해야 합니다.\n\n- 주식 가격이 급격히 상승하여 과대평가가 되는 경우 (또는 그 반대).\n- 채권 금리가 너무 낮아 전혀 매력적이지 않은 경우.\n- 위의 요소들의 조합.\n\n1991년을 살펴보면, 연간 기준으로 인플레이션이 6% 이상이었지만 비교적 강한 어음 수입이 있었습니다 (우리는 침체 상황에서여서 가격이 꽤 떨어져 있었습니다). 높은 인플레이션은 엄격한 Fed 정책과 높은 이자율을 초래함으로써 해당 수십년 동안 음수 스프레드를 설명했습니다. 90년대 후반에는 어음 수입이 급락하여 닷컴 붐으로 인해 \"이성을 잃은 열정\"으로 유명한 앨런 그린스펀이 유명하게 부른 것과 유사한 상황이 발생했습니다.\n\n닷컴 붕괴 이후 2002년부터 2007년까지의 회복을 고려해봅시다. 인플레이션은 낮았으며 채권 금리는 3-5% 범위 내에 유지되었으며 어음 수입은 한 시점에서 6%를 초과했습니다. 2007년, 스프레드가 처음으로 부호를 바꾸고 2002년 이후 처음으로 음수로 전환된 것을 볼 수 있습니다. 2008년 침체가 곧 발생했습니다. 물론, 그때는 약간의 음수 지역에 빠질 정도가 아무것도 표시하지 않았을 것입니다. 오늘날 예지의 혜택이 주어져 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리는 이제 최저 금리의 10년대에 접어들었습니다. 그래서 다음 10년 동안 스프레드가 그렇게 높게 유지되는 것은 놀라운 일이 아닙니다. 채권은 단순히 수익을 제공하지 않았습니다. 올해에는 16년 만에 처음으로 스프레드가 음수로 전환되었습니다.\n\n그래서, 중요한 질문은, 이것이 의미하는 바가 있는지입니다.\n\n현재 상황을 살펴보겠습니다:\n\n- 고 인플레이션 시기.\n- 매우 오랜 시간 동안 보지 못한 수준의 급증한 이자율과 채권 금리.\n- 주식 시장이 역대 최고치를 경신하고 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n함께 하면 우리는 주식이 기업 실적 추격을 못하고 높은 수준에 이르렀으면서, 채권은 안정적인 이율을 제공하고 있다는 결론을 내릴 수 있습니다. 여전히 미 연방준비제도(Federal Reserve)의 계획이 불확실한 상황에서 채궘으로의 주요 자금 회전이 없다는 것을 감안하면, 현재 채권이 꽤 매력적으로 보입니다.\n\n그래서 현재 주식은 고평가되었고 채권이 매력적으로 보입니다. 이것에 놀라지 말아야 합니다.\n\n## 인플레이션은 채권 모델에 영향을 미칩니까?\n\n다음으로, 저는 인플레이션과 연방 모델 간의 관계를 조사하고 그 유무를 확인하고 싶었습니다. 직관적으로, 우리는 인플레이션이 두 자산 클래스의 가치에 영향을 미쳤다는 것을 알기 때문에 관련성이 있어야 하며, 이것은 몇 가지 양적 기법을 시도해보는 기회를 제공했습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n먼저, 연간 기준 소비자물가지수(CPI) 플롯을 Fed 모델과 함께 살펴보겠습니다 (그림 2). 흥미로운 그래프군요. 경기 침체 시에는 분명한 관련성이 있습니다. 그러나 이 그래프에서 어떤 결론을 도출하는 것은 매우 어렵습니다.\n\n![Figure 2](/TIL/assets/img/2024-07-13-PredictingStockMarketValuationandDirectionUsingtheFedModel_2.png)\n\n그림 3은 각 시리즈의 월별 값에 대한 산점도를 보여줍니다. 두 값 사이에 상관관계가 전혀 없음을 알 수 있습니다 (로 = -0.11). 그러나 이 관계는 선형일 필요는 없으며, 연이어 발생하는 상관관계를 고려하지 않았습니다. 선형 관계가 없으므로 표준 회귀 분석도 도움이 되지 않을 것입니다.\n\n![Figure 3](/TIL/assets/img/2024-07-13-PredictingStockMarketValuationandDirectionUsingtheFedModel_3.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nThe Granger Causality Test\n\n그레인저 인과관계 검정은 한 시계열이 다른 시계열을 예측할 수 있는지를 결정하기 위해 사용되는 통계적 가설 검정입니다. 이 방법은 그레인저라는 사람에 의해 개발되었는데, 이 기법에 대한 작업으로 노벨 경제학상을 수상했습니다. 이 검정은 변수 X가 변수 Y를 그레인저 인과로 유발한다면, X의 과거값은 Y의 과거값만으로는 예측할 수 없는 Y를 예측하는 데 도움이 되는 정보를 포함해야 한다는 원리에 기초합니다.\n\n이 분석에서는 과거 소비자물가지수(CPI) 인플레이션율이 Fed 모델차와를 예측할 수 있는지를 검정합니다. 결과는 3~4개월의 지연으로 중요한 예측력을 보여주며, 이는 지난 인플레이션 데이터가 Fed 모델에 의한 시장 가치평가를 예측하는 데 도움이 되는 것으로 나타납니다 (테이블 1, Python 함수에서의 결과). 이는 인플레이션의 과거값(3 또는 4개월 전)이 Fed 모델의 미래 방향을 추론하는 데 사용될 수 있다는 것을 시사합니다!\n  \n![image](/TIL/assets/img/2024-07-13-PredictingStockMarketValuationandDirectionUsingtheFedModel_4.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 일부 생각\n\n구현 중이던 코드를 다시 살펴볼 때, 페드 모델을 새롭게 살펴보기로 결정했고, 이제 한동안 보지 않았다는 것을 깨달았는데, 워렌 버핏식으로 매우 흥미로워 보입니다. 어디에 서 있는지 보는 것이 재미있을 것 같았어요.\n\n하지만 이러한 결과를 예상하지 못했습니다.\n\n최종 결론:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 지난 몇 년 동안 페드 모델에 대한 언급을 많이 보지 못했는데, 16년 만에 처음으로 부정적으로 전환된 사실을 전략가들이 주목해야 합니다.\n- 인플레이션을 잠재적 요인으로 확인하는 것은 직관적입니다. 더 많은 변수를 테스트하고 아마도 regime classification에 도움이 될 멋진 비지도 학습 모델을 만들어 볼 수 있을 것입니다.\n\n그리고 이는 또 다른 데이터 과학 프로젝트의 주제가 될 것입니다!\n\n한 테스트 결과에 결론을 내리기 위해 완전히 의존할 수는 없다는 것을 기억하세요. 이 잠재적 관련성에 대해 더 명확하게 이해하기 위해 다른 기법을 테스트해 보았지만, 그것이 쉽지는 않습니다. 이것이 왜 양적 금융이 재미있는 이유입니다.\n\n본문의 모든 Python 코드는 여기서 코드 템플릿을 등록하면 찾을 수 있습니다(페이지 하단의 \"코드 템플릿 등록\" 부분).\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nLinkedIn이나 Medium에서 나를 팔로우해 주세요!","ogImage":{"url":"/TIL/assets/img/2024-07-13-PredictingStockMarketValuationandDirectionUsingtheFedModel_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-PredictingStockMarketValuationandDirectionUsingtheFedModel_0.png","tag":["Tech"],"readingTime":11},{"title":"FAISS 벡터 공간 시각화를 통한 RAG 성능 이해하기","description":"","date":"2024-07-13 19:04","slug":"2024-07-13-VisualizingFAISSVectorSpacetoUnderstanditsInfluenceonRAGPerformance","content":"\n\n<img src=\"/TIL/assets/img/2024-07-13-VisualizingFAISSVectorSpacetoUnderstanditsInfluenceonRAGPerformance_0.png\" />\n\n오픈 소스 대형 언어 모델의 성능이 계속해서 향상되면서, 코드 작성 및 분석, 추천, 텍스트 요약 및 질문-응답(QA)을 포함한 다양한 응용 프로그램에 진입하고 있습니다. QA 관련 질문에 대해 언어 모델이 자주 실패하는데, 이는 훈련 중에 사용되지 않은 문서와 관련된 질문들에 적용될 때 발생합니다. 그리고 이러한 내부 문서들 중 많은 것들은 규정 준수, 영업 비밀 또는 개인 정보 보호를 위해 기업의 벽 안에 유지되어야 합니다. 이러한 문서에 대해 쿼리를 실행할 때, 언어 모델은 가상 현상을 겪는데, 이는 관련 없거나 가짜 또는 일관성 없는 내용을 생성합니다.\n\n이러한 도전과제를 해결하기 위한 하나의 기술은 검색 보강 생성(Retrieval-Augmented Generation, RAG)입니다. 이는 답변 생성 이전에 훈련 데이터 소스 외부의 권위 있는 지식 베이스를 참조하여 언어 모델의 응답을 개선하는 과정을 포함합니다. RAG 어플리케이션은 말뭉치로부터 관련 문서 단편을 가져오는 검색 시스템과, 검색된 단편을 컨텍스트로 사용하여 답변을 생성하는 언어 모델로 구성됩니다. 당연히, 말뭉치의 품질과 그것이 표현된 벡터 공간, 즉 임베딩(embeddings)은 RAG의 정확도에 중요한 역할을 할 것입니다.\n\n본 기사에서는 FAISS 벡터 공간의 다차원 임베딩을 renumics-spotlight 시각화 라이브러리를 사용하여 2차원으로 시각화하는 방법을 살펴보겠습니다. 특정 핵심 벡터화 매개변수를 변화시킴으로써 RAG 응답 정확도를 향상시킬 기회를 찾아보겠습니다. 그리고 선택한 언어 모델로는 TinyLlama 1.1B Chat을 채택할 것인데, 이는 Llama 2와 동일한 아키텍처와 토크나이저를 갖추고 있습니다 [1]. 이 모델은 리소스 풋프린트가 상당히 작고 빠른 실행 시간을 가지고 있으면서 정확도가 비례적으로 감소하지 않는 장점을 갖추고 있습니다. 이는 빠른 실험에 이상적입니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 목차\n1.0 환경 설정\n2.0 설계 및 구현\n   2.1 LoadFVectorize 모듈\n   2.2 주요 모듈\n3.0 테스트 실행\n   3.1 청크 크기 및 중첩 매개변수 테스트\n4.0 최종 생각\n\n# 1.0 환경 설정\n\n이 실험은 8GB RAM을 갖춘 MacBook Air M1에서 수행될 예정입니다. 여기서 사용하는 Python 버전은 3.10.5입니다. 먼저, 이 프로젝트를 관리하기 위해 가상 환경을 생성해 봅시다. 환경을 생성하고 활성화하기 위해 다음을 실행해 봅시다:\n\n```js\npython3.10 -m venv mychat\nsource mychat/bin/activate\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nLibrary renumics-spotlight은 UMAP와 유사한 시각화를 사용하여 고차원 임베딩을 더 관리하기 쉬운 2D 시각화로 줄이는 동시에 중요한 속성을 보존합니다 [2]. 이제 필요한 모든 라이브러리를 설치해 보겠습니다:\n\n```js\npip install langchain faiss-cpu sentence-transformers flask-sqlalchemy psutil unstructured pdf2image unstructured_inference pillow_heif opencv-python pikepdf pypdf\npip install renumics-spotlight\nCMAKE_ARGS=\"-DLLAMA_METAL=on\" FORCE_CMAKE=1 pip install --upgrade --force-reinstall llama-cpp-python --no-cache-dir\n```\n\n위의 마지막 줄은 M1 프로세서에서 하드웨어 가속을 사용하여 TinyLlama를 로드하는 데 사용될 메탈 지원이 포함된 llama-cpp-python 라이브러리를 설치하는 것을 의미합니다. Metal을 사용하면 계산이 GPU에서 실행됩니다.\n\n환경이 준비되었으므로 시스템 설계를 살펴보고 구현을 따라갑시다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 2.0 디자인 및 구현\n\n이 QA 시스템에는 그림 1에 설명된 두 모듈이 있습니다.\n\n![이미지](/TIL/assets/img/2024-07-13-VisualizingFAISSVectorSpacetoUnderstanditsInfluenceonRAGPerformance_1.png)\n\nLoadFVectorize 모듈은 PDF 또는 웹 문서를 로드하는 작업을 포함합니다. 초기 테스트 및 시각화를 위해, 최근에 출시된 (2023년 12월) 440페이지의 벤더 배포 가이드가 관심 문서로 사용됩니다. 이 모듈은 문서의 분할 및 벡터화를 처리합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n두 번째 모듈은 LLM을 로드하고 FAISS 검색기를 인스턴스화한 후, LLM, 검색기 및 사용자 정의 프롬프트를 포함하는 검색 체인을 생성하는 것으로 구성되어 있습니다. 마지막으로 벡터 공간 시각화를 시작합니다.\n\n두 모듈의 세부 정보는 더 설명되어 있습니다.\n\n## 2.1 Module LoadFVectorize\n\n이 모듈은 3가지 함수로 구성되어 있습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- load_doc 함수는 온라인 pdf 문서를 로드하고, 512자씩 묶어 chunk 단위로 나누며 100자의 overlap을 가지고 문서 목록을 반환합니다.\n- vectorize 함수는 위 load_doc 함수를 호출하여 문서의 chunked 목록을 가져와 임베딩을 생성하고 opdf_index 로컬 디렉토리에 저장한 뒤 FAISS 인스턴스를 반환합니다.\n- load_db 함수는 opdf_index 디렉토리 내에 FAISS 벡터 저장소가 있는지 확인하고, 없는 경우 vectorize 함수를 호출하여 문서를 로드하고 벡터화합니다. 최종적으로 FAISS 객체를 반환합니다.\n\n이 모듈의 전체 코드 목록은 아래와 같습니다.\n\n```python\n# LoadFVectorize.py\n\nfrom langchain_community.embeddings import HuggingFaceEmbeddings\nfrom langchain_community.document_loaders import OnlinePDFLoader\nfrom langchain.text_splitter import RecursiveCharacterTextSplitter\nfrom langchain_community.vectorstores import FAISS\n\n# 온라인 pdf에 접근\ndef load_doc() -> 'List[Document]':\n    loader = OnlinePDFLoader(\"https://support.riverbed.com/bin/support/download?did=7q6behe7hotvnpqd9a03h1dji&version=9.15.0\")\n    documents = loader.load()\n    text_splitter = RecursiveCharacterTextSplitter(chunk_size=512, chunk_overlap=100)\n    docs = text_splitter.split_documents(documents)\n    return docs\n\n# 벡터화 및 디스크에 저장\ndef vectorize(embeddings_model) -> 'FAISS':\n    docs = load_doc()\n    db = FAISS.from_documents(docs, embeddings_model)\n    db.save_local(\"./opdf_index\")\n    return db\n\n# 디스크에서 벡터 저장소를 로드하려고 시도\ndef load_db() -> 'FAISS':\n    embeddings_model = HuggingFaceEmbeddings()\n    try:\n        db = FAISS.load_local(\"./opdf_index\", embeddings_model)\n    except Exception as e:\n        print(f'Exception: {e}\\n디스크에 인덱스가 없음, 새로 생성 중...')\n        db = vectorize(embeddings_model)\n    return db\n```\n\n## 2.2 메인 모듈\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n주요 모듈은 먼저 TinyLlama에 대한 프롬프트 템플릿을 정의합니다. 템플릿은 다음과 같습니다:\n\n`|system|`'context'`/s``|user|`'question'`/s``|assistant|`\n\nLLM 메모리 사용량을 더 줄이기 위해, TheBloke의 HuggingFace 레포지토리 [3]에서 TinyLlama의 양자화된 버전을 채택할 것입니다. 이는 모델 매개변수에 더 적은 비트를 사용하는 방식입니다. 이 LLM에 대한 추가적인 배경 정보나 활성화 기술에 대해 더 자세히 알고 싶은 분들은 이전에 작성한 기사를 확인해보세요. GGUF 형식으로 양자화된 LLM을 로드하기 위해 LlamaCpp를 사용합니다. 이전 모듈에서 반환된 FAISS 객체를 사용하여 FAISS retriever가 생성됩니다. 이러한 객체들을 사용하여 RetrievalQA 체인을 생성하고 질문에 사용합니다.\n\n아래 코드는 이러한 단계를 포착합니다.\n\n```js\n# main.py\nfrom langchain.chains import RetrievalQA\nfrom langchain.prompts import PromptTemplate\nfrom langchain_community.llms import LlamaCpp\nfrom langchain_community.embeddings import HuggingFaceEmbeddings\nimport LoadFVectorize\nfrom renumics import spotlight\nimport pandas as pd\nimport numpy as np\n\n# 프롬프트 템플릿\nqa_template = \"\"\"<|system|>\n정확하게 대답하는 친근한 채팅 봇입니다. \n알 수 없는 답변일 경우 공손하게 알려드릴 것입니다.\n다음 맥락을 사용하여 아래 질문에 답변해주세요:\n{context}</s>\n<|user|>\n{question}</s>\n<|assistant|>\n\"\"\"\n\n# 프롬프트 인스턴스 생성\nQA_PROMPT = PromptTemplate.from_template(qa_template)\n# LLM 로드\nllm = LlamaCpp(\n    model_path=\"./models/tinyllama_gguf/tinyllama-1.1b-chat-v1.0.Q5_K_M.gguf\",\n    temperature=0.01,\n    max_tokens=2000,\n    top_p=1,\n    verbose=False,\n    n_ctx=2048\n)\n# 벡터화 및 retriever 생성\ndb = LoadFVectorize.load_db()\nfaiss_retriever = db.as_retriever(search_type=\"mmr\", search_kwargs={'fetch_k': 3}, max_tokens_limit=1000)\n# QA 체인 정의\nqa_chain = RetrievalQA.from_chain_type(\n    llm,\n    retriever=faiss_retriever,\n    chain_type_kwargs={\"prompt\": QA_PROMPT}\n)\n\nquery = 'What versions of TLS supported by Client Accelerator 6.3.0?'\n\nresult = qa_chain({\"query\": query})\nprint(f'--------------\\nQ: {query}\\nA: {result[\"result\"]}')\n\nvisualize_distance(db,query,result[\"result\"])\r\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n벡터 공간 시각화 자체는 위 코드 목록의 마지막 줄인 visualize_distance에 의해 처리됩니다. 이 기능 또한 이 모듈에 정의되어 있습니다.\n\nvisualize_distance 함수에서는 먼저 FAISS 객체의 __dict__ 속성에 액세스해야 합니다. 이는 인스턴스 변수용 사전입니다. 이를 통해 docstore에 액세스할 수 있습니다. 인스턴스 변수 index_to_docstore_id는 키 인덱스로 값 docstore-id의 사전입니다. 벡터화에 사용된 총 문서 수는 인덱스 객체의 ntotal 속성으로 나타냅니다.\n\n```js\n    vs = db.__dict__.get(\"docstore\")\n    index_list = db.__dict__.get(\"index_to_docstore_id\").values()\n    doc_cnt = db.index.ntotal\n```\n\n벡터 공간을 대략적으로 복원하기 위해 우리는 단순히 객체 인덱스의 메서드인 reconstruct_n을 기본 매개변수와 함께 호출합니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n   embeddings_vec = db.index.reconstruct_n()\n```\n\n이제 인덱스 목록으로 문서 저장소 ID 목록이 있으므로, 관련 문서 객체를 찾아 해당 ID, 문서 메타데이터, 문서 내용 및 벡터 공간 내 임베딩을 포함하는 리스트를 생성해보겠습니다. 아래 코드를 참조해주세요.\n\n```js\n   doc_list = list() \n   for i, doc_id in enumerate(index_list):\n       a_doc = vs.search(doc_id)\n       doc_list.append([doc_id, a_doc.metadata.get(\"source\"), a_doc.page_content, embeddings_vec[i]])\n```\n\n그런 다음 이 리스트를 사용하여 열 제목이 있는 데이터프레임을 생성한 후, 시각화를 만들기 위해 spotlight 호출에 사용될 것입니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\n    df = pd.DataFrame(doc_list, columns=['id', 'metadata', 'document', 'embedding'])\n```\n\n시각화를 진행하기 전에 질문과 답변을 통합할 방법을 찾아야 합니다. 질문 및 답변을 위한 별도의 데이터프레임을 생성하고 주요 데이터프레임과 병합하여 두 데이터가 나머지 문서 청크와 함께 어디에 나타나는지 보여줄 수 있도록합니다:\n\n```python\n    # 질문 및 답변을 위한 행 추가\n    embeddings_model = HuggingFaceEmbeddings()\n    question_df = pd.DataFrame(\n        {\n            \"id\": \"question\",\n            \"question\": question,\n            \"embedding\": [embeddings_model.embed_query(question)],\n        })\n    answer_df = pd.DataFrame(\n        {\n            \"id\": \"answer\",\n            \"answer\": answer,\n            \"embedding\": [embeddings_model.embed_query(answer)],\n        })\n    df = pd.concat([question_df, answer_df, df])\n```\n\n이 공간에서 질문과 문서 간의 유클리드 거리를 찾으려면 질문을 위한 임베딩을 만든 다음 문서와 질문 임베딩 차이에 대해 numpy의 `linalg.norm`을 사용하십시오:  \n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n    question_embedding = embeddings_model.embed_query(question)\n    # 벡터 거리를 나타내는 열 추가\n    df[\"dist\"] = df.apply(                                                                                                                                                                         \n        lambda row: np.linalg.norm(\n            np.array(row[\"embedding\"]) - question_embedding\n        ),axis=1,)\n```\n\n데이터프레임을 얻었으면 spotlight.show를 호출하여 시각화를 생성합니다.\n\n```js\nspotlight.show(df)\n```\n\n왔어요! 이렇게 하면 브라우저 창에서 spotlight가 열리고 pandas 데이터프레임이 탐색 준비가 됩니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래 GitHub 저장소에서 모든 코드에 액세스할 수 있습니다:\n\n## 3.0 테스트 실행\n\n첫 번째 실험을 용이하게하기 위해 선택된 샘플 질문은 아래와 같습니다:\n\n채택된 문서에 따르면, 올바른 답은 :\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n또한, 다음 추가 정보가 응답에 포함될 수 있습니다.\n\n아래는 위 질문에 대한 TinyLlama의 응답입니다:\n\n이 응답은 실제 답변과 꽤 유사해 보이지만, 이 TLS 버전들이 기본값은 아니라는 점에서 완전히 정확하지는 않습니다.\n\nFig. 2는 스포트라이트의 스크린샷을 나타냅니다. 왼쪽 상단의 테이블 섹션에는 데이터프레임의 모든 열이 표시되고 시각화는 유사성 맵 탭 뷰 내에서 표시됩니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![링크 텍스트](/TIL/assets/img/2024-07-13-VisualizingFAISSVectorSpacetoUnderstanditsInfluenceonRAGPerformance_2.png)\n\n가시적인 열 버튼을 사용하여 표시되는 열을 제어할 수 있습니다. \"dist\"로 테이블을 정렬하면 상위에 질문, 답변 및 가장 관련성 높은 문서 스니펫이 나타납니다. 임베딩 시각화를 살펴보면 여기의 거의 모든 문서를 하나의 클러스터로 나타냅니다. 이는 원래 pdf가 특정 제품의 배포 가이드임을 감안할 때 합리적일 것으로 생각됩니다. Similarity Map 탭 내의 필터 아이콘을 클릭하면 선택한 문서 목록만 강조 표시되며 나머지는 회색으로 표시됩니다(Fig. 3 참조).\n\n![링크 텍스트](/TIL/assets/img/2024-07-13-VisualizingFAISSVectorSpacetoUnderstanditsInfluenceonRAGPerformance_3.png)\n\n## 3.1 테스트 청크 크기 및 겹치기 매개변수\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n리트리버가 RAG 성능에 중요한 영향을 미친다고 해서, 우리는 임베딩 공간에 영향을 주는 몇 가지 매개변수를 살펴보겠습니다. 테이블 1은 문서 분할 중 TextSplitter의 청크 크기 (1000, 2000) 및/또는 오버랩 (100, 200) 매개변수가 다양하게 변할 때, TinyLlama의 응답을 포착하고 정리합니다.\n\n![Image](/TIL/assets/img/2024-07-13-VisualizingFAISSVectorSpacetoUnderstanditsInfluenceonRAGPerformance_4.png)\n\n첫눈에, 모든 조합의 LLM 응답이 비슷해 보입니다. 그러나 정확한 답변과 각 응답을 주의 깊게 비교하면, 정확한 답변은 (1000, 200) 조합에 해당합니다. 다른 응답에서의 부정확한 세부사항은 빨간색으로 강조되었습니다. 이러한 행동을 설명하기 위해, Fig. 3은 각 조합에 대한 임베딩 맵을 옆으로 나란히 보여줍니다.\n\n![Image](/TIL/assets/img/2024-07-13-VisualizingFAISSVectorSpacetoUnderstanditsInfluenceonRAGPerformance_5.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n왼쪽부터 오른쪽으로 청크 크기를 증가시키면서 벡터 공간이 더 드문 형태로 변해갑니다. 아래에서 위로 가면 겹침이 두 배가 된 곳에서도 벡터 공간의 특성이 급격하게 변하지는 않습니다. 이 모든 맵에서 전체 컬렉션은 여전히 한 클러스터처럼 보이며 몇 개의 이상치만 존재합니다. 이는 생성된 응답에서 명확히 반영되며, 이들은 상당히 유사합니다. 질의가 클러스터의 중심에 있는 경우, 이웃들이 다를 가능성이 높으므로 이러한 매개변수의 변화에 따라 응답이 상당히 달라질 수 있습니다.\n\nRAG 애플리케이션이 특정 질문에 대해 기대한 답변을 제공하지 않는 경우, 해당 질문들과 함께 위와 같은 시각화를 생성함으로써 말뭉치를 어떻게 분할하여 전체 성능을 개선할지에 대한 추가 통찰을 얻을 수 있습니다.\n\n그리고 좀 더 설명하기 위해, 상관 없는 도메인의 두 개의 위키백과 문서가 차지하는 벡터 공간을 시각화해 봅시다. 이를 위해 LoadFVectorize 모듈 내 load_doc 함수의 첫 줄을 수정하여 웹 기반 두 URL의 WebBasedLoader를 구현하면 됩니다. 하나는 그래미 어워즈에 관한 것이고, 다른 하나는 JWST 망원경에 대한 것입니다. 아래와 같이 나타납니다.\n\n```js\ndef load_doc():\n    loader = WebBaseLoader(['https://en.wikipedia.org/wiki/66th_Annual_Grammy_Awards','https://en.wikipedia.org/wiki/James_Webb_Space_Telescope'])\n    documents = loader.load()\n    ...\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n나머지 코드는 그대로 유지하고 있는 것을 확인하면, 우리는 그림 5에 나타난 벡터 공간 시각화를 얻을 수 있습니다.\n\n<img src=\"/TIL/assets/img/2024-07-13-VisualizingFAISSVectorSpacetoUnderstanditsInfluenceonRAGPerformance_6.png\" />\n\n예상대로, 여기에는 두 개의 명확하게 겹치지 않는 클러스터가 있습니다. 우리가 두 클러스터 모두 벗어난 질문을 하면, 검색기에서 얻는 결과 문맥은 적어도 LLM에게 도움이 되지는 않을 것이지만 오히려 해로울 것입니다. 그리고 재미로, 나는 이전에 묻은 같은 질문을 한 번 더 던져보기로 결정했습니다. 그리고 확실히 LLM은 환각하기 시작했습니다.\n\n여기 우리 시스템 디자인에는 벡터 저장을 위해 FAISS를 사용했습니다. 만약 당신이 ChromaDB를 사용하고 비슷한 시각화를 수행하는 방법을 궁금해 한다면, 당신은 운이 좋습니다. renumics-spotlight 라이브러리 개발자 중 Markus Stoll이 여기에 관련된 흥미로운 기사를 썼습니다. 확인해보세요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 4.0 마무리\n\nRetrieval-Augmented Generation (RAG)은 내부 문서에 교육되지 않은 큰 언어 모델(LM)을 활용할 수 있게 해줍니다. RAG은 벡터 저장소에서 여러 관련 문서 청크를 검색하여 LM이 생성을 위한 문맥으로 사용합니다. 따라서 임베딩의 품질은 RAG 성능에 중요한 역할을 합니다.\n\n이 기사에서는 주요 벡터화 매개변수 중 일부가 전체 LM 성능에 미치는 영향을 시연하고 시각화했습니다. 우리는 리소스 풋프린트가 훨씬 작지만 여전히 높은 정확도를 자랑하는 TinyLlama 1.1B Chat를 선택했습니다. 라이브러리 'renumics-spotlight'를 사용하여 FAISS 벡터 공간 전체를 데이터프레임으로 표현하는 방법을 보여주었으며, 이를 사용하여 한 줄의 코드로 임베딩을 시각화했습니다. Spotlight의 직관적인 UI를 통해 질문에 대한 벡터 공간을 탐색하고, 이를 통해 LM의 응답을 더 잘 이해할 수 있습니다. 특정 벡터화 매개변수를 조정함으로써, 성능을 향상시키기 위해 생성 및 행동을 제어할 수 있습니다.\n\n읽어 주셔서 감사합니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 참고 자료\n\n1. [TinyLlama-1.1B-Chat-v1.0](https://huggingface.co/TinyLlama/TinyLlama-1.1B-Chat-v1.0)\n2. [spotlight](https://github.com/Renumics/spotlight)\n3. [TinyLlama-1.1B-Chat-v1.0-GGUF](https://huggingface.co/TheBloke/TinyLlama-1.1B-Chat-v1.0-GGUF)","ogImage":{"url":"/TIL/assets/img/2024-07-13-VisualizingFAISSVectorSpacetoUnderstanditsInfluenceonRAGPerformance_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-VisualizingFAISSVectorSpacetoUnderstanditsInfluenceonRAGPerformance_0.png","tag":["Tech"],"readingTime":17},{"title":"와 를 사용해서 Python 함수 파라미터를 깔끔하게 정리하는 방법","description":"","date":"2024-07-13 19:03","slug":"2024-07-13-UseandtoMakeYourPythonFunctionParametersLookNeater","content":"\n\n![TIL 이미지](/TIL/assets/img/2024-07-13-UseandtoMakeYourPythonFunctionParametersLookNeater_0.png)\n\n파이썬에서는 위치 매개변수 또는 키워드 매개변수를 사용하여 함수에 데이터를 전달할 수 있습니다. 이는 파이썬에서 함수를 매우 유연하게 사용할 수 있게 해줍니다. 그러나 이에는 일부 제한 사항이 있습니다. 예를 들어, 일부 매개변수를 위치 전용으로 지정하고 일부를 키워드 전용으로 지정할 수 있습니다. 또 다른 일반적인 사용 사례는 기본 값이 있는 매개변수를 기본 값이 없는 매개변수보다 먼저 놓아 매개변수가 더 구성되고 사용하기 쉽도록 만드는 것입니다. 이러한 요청은 파이썬의 * 및 / 기호를 사용하여 수행할 수 있습니다.\n\n## 기본 동작\n\n이미 알고 있듯이, 파이썬에서는 위치 매개변수 또는 키워드 매개변수를 사용하여 함수에 데이터를 전달할 수 있습니다. 여기에 간단한 함수 예제가 있습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\ndef echo(x, y, z):\n    print(f\"{x=}, {y=}, {z=}\")\n```\n\n이 함수를 호출할 때 위치 매개변수나 키워드 매개변수를 사용할 수 있습니다. 단, 키워드 매개변수는 위치 매개변수 뒤에 있어야 합니다:\n\n```python\necho(1, 2, 3)\necho(1, 2, z=3)\necho(1, y=2, z=3)\necho(x=1, y=2, z=3)\n# x=1, y=2, z=3\n```\n\n모두 작동하고 동일한 결과를 출력합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## /를 사용하여 위치 전용 매개변수 지정하기\n\n함수 정의에서 / 기호 앞에 배치된 매개변수는 위치 전용으로 전달돼야 합니다. echo() 함수를 업데이트하여 /를 사용해봅시다:\n\n```js\ndef echo(x, /, y, z):\n    print(f\"{x=}, {y=}, {z=}\")\n```\n\n이 업데이트로 x는 위치 매개변수로만 전달될 수 있으며, y와 z는 여전히 위치 및 키워드 매개변수로 모두 전달될 수 있습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n```js\necho(1, 2, 3)\necho(1, 2, z=3)\necho(1, y=2, z=3)\n# x=1, y=2, z=3\n```\n\n그리고 x가 키워드 매개변수로 전달되면 TypeError가 발생합니다:\n\n```js\necho(x=1, y=2, z=3)\n# TypeError: echo() got some positional-only arguments passed as keyword arguments: 'x'\n```\n\n## *를 사용하여 키워드 전용 매개변수 지정하기\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n함수 정의에서 * 기호 뒤에 올 파라미터는 키워드 인수로 전달되어야 합니다. echo() 함수에서 / 대신 *를 사용해보겠습니다:\n\n```js\ndef echo(x, *, y, z):\n    print(f\"{x=}, {y=}, {z=}\")\n```\n\n이제 x는 위치 인수 또는 키워드 인수로 전달할 수 있지만, y와 z는 키워드 인수로 반드시 전달되어야 합니다 (x가 위치 매개변수로 전달되더라도):\n\n```js\necho(1, y=2, z=3)\necho(x=1, y=2, z=3)\n# x=1, y=2, z=3\n\necho(1, 2, z=3)\n# TypeError: echo() takes 1 positional argument but 2 positional arguments (and 1 keyword-only argument) were given\n\necho(1, 2, 3)\n# TypeError: echo() takes 1 positional argument but 3 were given\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n* 기호의 매우 유용한 기능 중 하나는 매개변수를 보다 구성되게 보이도록 기본값이 설정된 매개변수를 기본값이 없는 매개변수보다 먼저 배치할 수 있다는 것입니다. 예를 들어, * 기호를 사용하여 y에 기본값을 지정하고 여전히 y 뒤에 z를 놓을 수 있습니다:\n\ndef echo(x, *, y=2, z):\n    print(f\"{x=}, {y=}, {z=}\")\n\n이것은 Python에서 유효한 구문이며 복잡한 함수 매개변수를 갖는 서드 파티 Python 라이브러리에서 흔히 사용됩니다.\n\n이제 y와 z 둘 다 키워드 매개변수로 전달되어야 하며 y에는 기본값이 설정되어 있습니다:\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n```js\necho(1, z=3)\necho(1, y=2, z=3)\n# x=1, y=2, z=3\n```\n\n## 함수 정의에서 *와 /를 결합하기\n\n*와 /를 결합하여 위치 매개변수와 키워드 전용 매개변수를 가진 함수를 정의할 수 있습니다:\n\n```js\ndef echo(x, /, *, y=2, z):\n    print(f\"{x=}, {y=}, {z=}\")\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 경우에는 x는 위치 전용이고 y와 z는 키워드 전용 매개변수입니다:\n\n```js\necho(1, z=3)\necho(1, y=2, z=3)\n# x=1, y=2, z=3\n\necho(x=1, z=3)\n# TypeError: echo() got some positional-only arguments passed as keyword arguments: 'x'\n```\n\n이 게시물에서는 함수 정의에서 *와 / 기호를 사용한 것을 소개했는데, 이들은 다음과 같은 흥미로운 유틸리티를 가지고 있습니다:\n\n- 일부 매개변수를 위치 전용으로 지정하고 일부를 키워드 전용으로 지정합니다.\n- 기본값을 가진 매개변수는 기본값이 없는 매개변수 앞에 두어 매개변수를 더욱 구성하기 쉽고 사용하기 편리하게 합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 관련 포스트:\n\n- 특별한 Python 문자열 포맷팅으로 로깅 및 단위 변환하기\n- Python 코드를 더 전문적으로 만들기 위해 black, mypy, pylint 사용하기","ogImage":{"url":"/TIL/assets/img/2024-07-13-UseandtoMakeYourPythonFunctionParametersLookNeater_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-UseandtoMakeYourPythonFunctionParametersLookNeater_0.png","tag":["Tech"],"readingTime":6},{"title":"파이썬으로 모멘텀 및 되돌림 트레이딩 전략 구축 방법","description":"","date":"2024-07-13 19:01","slug":"2024-07-13-BuildingAMomentumandReversionTradingStrategyWithPython","content":"\n\n양적 거래에서는 금융 시장에서 우위를 차지하기 위해 다양한 전략이 사용됩니다. 모멘텀 및 추세 기반 전략은 인기가 많지만, 종종 중요한 알파를 창출하는 데 어려움을 겪습니다. 이들은 종종 유튜브에서 금융 강좌로 판매될 때만 알파를 창출하게 됩니다.\n\n모멘텀 및 추세 접근법은 최근 가격 상승을 보이는 자산이 가까운 미래에 상승세를 이어갈 것이라는 아이디어를 활용하거나, 손실을 보이는 자산이 계속해서 하락할 것이라는 아이디어를 기반으로 합니다. 추세와 모멘텀을 구분하는 것이 중요합니다.\n\n- 추세 추종은 시장 베타를 분석하여 특정 방향의 절대 수익을 목표로 합니다.\n- 반면에, 모멘텀 전략은 상대 수익에 초점을 맞추며, 분류나 섹터 내에서 교차부문 성능을 평가하여 시장 중립적 입장을 유지합니다.\n\n회귀 전략은 가격이 특정 기간 동안 평균 또는 다중 평균 값으로 되돌아갈 것이라는 믿음에 기반합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 기사에서는 이러한 전략을 검토하고 해당 분석을 위한 Python 코드 구현을 제공할 것입니다. 우리는 페어 트레이딩을 포함한 더 세련된 전략과 분석을 진행할 것입니다.\n\n우리의 분석은 최근의 시장 상황, 특히 팬데믹 이후의 주식 가격을 기준으로 살펴볼 것입니다. 모든 논의된 전략은 롱 온리이며 레버리지가 걸리지 않은 전략입니다.\n\n시작하기 전에, 투자 커뮤니티에 가입하실 것을 초대합니다. 가입하시면 중요한 기사를 놓치지 않고 투자자로서 스킬을 향상시킬 수 있습니다.\n\nPython 환경을 설정하는 것은 효율적으로 Python 코드를 작성, 실행 및 관리하기 위해 필요한 도구와 라이브러리를 갖추는 것을 포함합니다. Python 환경을 설정하는 자세한 안내서는 여기 있습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 1. 파이썬 설치하기:\n\n만약 여러분의 컴퓨터에 아직 파이썬이 설치되어 있지 않다면, 공식 파이썬 웹사이트([https://www.python.org/](https://www.python.org/))에서 다운로드하고 설치해주세요. 여러분의 운영 체제(Windows, macOS, 또는 Linux)에 맞는 올바른 버전을 선택해야 합니다. 가장 최신의 안정 버전을 설치하는 것이 좋습니다.\n\n# 2. 텍스트 편집기 또는 IDE 선택하기:\n\n파이썬으로 코딩할 때 텍스트 편집기나 통합 개발 환경(IDE)을 선택해주세요. 널리 사용되는 몇 가지 옵션으로는:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Visual Studio Code: 내장된 Python 지원과 다양한 확장 기능을 갖춘 가벼운 사용자 정의 가능한 편집기입니다.\n- PyCharm: 코드 완성, 디버깅 및 버전 관리 시스템과 통합된 Python 개발을 위해 최적화된 견고한 IDE입니다.\n- Jupyter Notebook: 데이터 분석 및 시각화 작업에 이상적인 웹 브라우저에서 Python 코드를 작성하고 실행할 수 있는 인터랙티브 노트북 인터페이스입니다.\n\n## 3. 가상 환경 설정하기 (선택 사항이지만 권장됨):\n\n가상 환경은 종속성을 관리하고 프로젝트 환경을 격리하는 데 유용합니다. 가상 환경을 만들려면 터미널이나 명령 프롬프트를 열고 프로젝트 디렉토리로 이동한 다음 다음 명령을 실행하십시오:\n\n```js\npython -m venv myenv\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n해당 명령어는 프로젝트 디렉토리에 `env`라는 가상 환경을 만듭니다. 가상 환경을 활성화하려면 다음 명령어를 사용하십시오 (사용하는 운영 체제에 따라 명령어가 다를 수 있습니다):\n\n## Windows:\n\n```js\n.\\env\\Scripts\\activate\n```\n\n## macOS/Linux:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nsource env/bin/activate\n```\n\n활성화된 후에 `pip`를 사용하여 프로젝트별 종속성을 설치할 수 있습니다. 이 가상 환경 안에 이들이 포함되어 다른 프로젝트와의 충돌을 방지합니다.\n\n# 4. 필요한 패키지 설치:\n\n```js\npython -m venv myenv\npip install numpy pandas matplotlib\npip install -r requirements.txt\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 트렌드와 모멘텀 전략\n\n예를 들어 설명하자면, 만약 자산의 가격이 지난 일주일 동안 상승 추세를 보였다면, 그 자산은 같은 방향으로 계속 움직일 가능성이 높습니다. 이 전략은 미래 가격 변동이 과거 움직임의 패턴을 따르리라는 아이디어에 기반을 두고 있습니다. 월스트리트벳 커뮤니티가 자주 외친 것처럼, 주식은 주로 상승하는 경향이 있습니다.\n\n비록 이 전략이 간단하긴 하지만, 다음과 같은 단점이 있습니다:\n\n- 시장 소음과 중요한 이벤트를 무시하여 중요한 변동을 완화할 수 있습니다.\n- 빈번한 거래는 거래 수수료 누적으로 이어질 수 있습니다.\n- 폭넓게 사용되기 때문에 이 전략을 활용하는 데 경쟁 우위가 제한적이거나 전혀 없을 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 이동평균 교차 전략\n\n다음 코드는 이 전략을 구현합니다:\n\n```js\ndef double_simple_moving_average_signals(ticker_ts_df, short_window=5, long_window=30):\n    \"\"\"\n    이중 단순 이동평균 (SMA) 전략을 기반으로 거래 신호를 생성합니다.\n    매개변수:\n    - ticker_ts_df (pandas.DataFrame): 주식의 과거 데이터가 포함 된 DataFrame.\n    - short_window (int): 단기 SMA의 창 크기.\n    - long_window (int): 장기 SMA의 창 크기.\n    반환값:\n    - signals (pandas.DataFrame): 거래 신호를 포함하는 DataFrame.\n    \"\"\"\n    signals = pd.DataFrame(index=ticker_ts_df.index)\n    signals['signal'] = 0.0\n    signals['short_mavg'] = ticker_ts_df['Close'].rolling(window=short_window,\n                                                          min_periods=1,\n                                                          center=False).mean()\n    signals['long_mavg'] = ticker_ts_df['Close'].rolling(window=long_window,\n                                                         min_periods=1,\n                                                         center=False).mean()\n    # SMAs가 교차 되었을 때 신호 생성\n    signals['signal'] = np.where(\n        signals['short_mavg'] > signals['long_mavg'], 1, 0)\n    signals['orders'] = signals['signal'].diff()\n    signals.loc[signals['orders'] == 0, 'orders'] = None\n    return signals\n```\n\n필요한 함수를 생성하기 위한 단계를 살펴보겠습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 단기 및 장기 이동평균 값 계산: 단기(빠른) 및 장기(느린) 단순 이동평균(SMA)을 계산하는 함수를 생성하세요.\n- 거래 신호 생성: 단기와 장기 이동평균 값을 비교하여 매수 및 매도 신호를 생성하는 함수를 개발하세요.\n- 시간에 따른 자본 계산: 생성된 신호를 기반으로 자본을 계산하는 유틸리티 함수를 구현하세요.\n- 결과 시각화: 주식의 시계열 데이터와 진입 및 퇴출 신호를 함께 그리는 함수를 작성하세요.\n\n```js\ndef load_ticker_time_series(ticker, start_date, end_date):\n    \"\"\"\n    Yahoo Finance API에서 시간 시리즈 금융 데이터를 검색하고 캐시합니다.\n    매개변수:\n    - ticker (str): 주식 티커 심볼 (예: 애플의 경우 'AAPL').\n    - start_date (str): 데이터 검색을 위한 'YYYY-MM-DD' 형식의 시작 날짜.\n    - end_date (str): 데이터 검색을 위한 'YYYY-MM-DD' 형식의 종료 날짜.\n    반환값:\n    - df (pandas.DataFrame): 금융 시계열 데이터를 포함하는 DataFrame.\"\"\"\n    dir_path = './data'\n    cached_file_path = f'{dir_path}/{ticker}_{start_date}_{end_date}.pkl'\n    try:\n        if os.path.exists(cached_file_path):\n            df = pd.read_pickle(cached_file_path)\n        else:\n            df = yf.download(ticker, start=start_date, end=end_date)\n            if not os.path.exists(dir_path):\n                os.makedirs(dir_path)\n            df.to_pickle(cached_file_path)\n    except FileNotFoundError:\n        print(\n            f'주식: {ticker}에 대한 파일을 다운로드 및 캐시하는 중 오류가 발생했습니다.')\n    return df\n\ndef calculate_profit(signals, prices):\n    \"\"\"\n    거래 신호와 주식 가격을 기반으로 누적 수익을 계산합니다.\n    매개변수:\n    - signals (pandas.DataFrame): 거래 신호를 포함하는 DataFrame (매수: 1, 매도: -1).\n    - prices (pandas.Series): 신호 날짜에 해당하는 주식 가격을 포함하는 Series.\n    반환값:\n    - cum_profit (pandas.Series): 시간에 따른 누적 수익을 포함하는 Series.\n    \"\"\"\n    profit = pd.DataFrame(index=prices.index)\n    profit['profit'] = 0.0\n    buys = signals[signals['orders'] == 1].index\n    sells = signals[signals['orders'] == -1].index\n    while sells[0] < buys[0]:\n        # 롱 포지션 전용 전략입니다. 판매로 시작할 수 없습니다.\n        sells = sells[1:]\n    if len(buys) == 0 or len(sells) == 0:\n        # 아무 조치도 취하지 않았습니다.\n        return profit\n    if len(sells) < len(buys):\n        # 마지막에 판매하는 것으로 가정합니다.\n        sells = sells.append(pd.Index(prices.tail(1).index))\n    buy_prices = prices.loc[buys]\n    sell_prices = prices.loc[sells]\n    profit.loc[sells, 'profit'] = sell_prices.values - buy_prices.values\n    profit['profit'] = profit['profit'].fillna(0)\n    # 누적 수익 생성\n    profit['cum_profit'] = profit['profit'].cumsum()\n    return profit['cum_profit']\n\ndef plot_strategy(prices_df, signal_df, profit):\n    \"\"\"\n    매수 및 매도 신호 및 누적 수익을 포함하는 거래 전략을 시각화합니다.\n    매개변수:\n    - prices (pandas.Series): 주식 가격을 포함하는 Series.\n    - signals (pandas.DataFrame): 매수(1) 및 매도(-1) 신호를 포함하는 DataFrame.\n    - profit (pandas.Series): 시간에 따른 누적 수익을 포함하는 Series.\n    반환값:\n    - ax1 (matplotlib.axes.Axes): 주식 가격과 신호를 표시하는 상단 서브플롯.\n    - ax2 (matplotlib.axes.Axes): 누적 수익을 표시하는 하단 서브플롯.\n    \"\"\"\n    fig, (ax1, ax2) = plt.subplots(2, 1, gridspec_kw={'height_ratios': (3, 1)},\n                                   figsize=(18, 12))\n    ax1.set_xlabel('날짜')\n    ax1.set_ylabel('달러 단위의 가격')\n    ax1.plot(prices_df.index, prices_df, color='g', lw=0.25)\n    # 매수 및 매도 신호를 플롯합니다.\n    ax1.plot(signal_df.loc[signal_df.orders == 1.0].index,\n             prices_df[signal_df.orders == 1.0],\n             '^', markersize=12, color='blue', label='매수')\n    ax1.plot(signal_df.loc[signal_df.orders == -1.0].index,\n             prices_df[signal_df.orders == -1.0],\n             'v', markersize=12, color='red', label='매도')\n    ax2.plot(profit.index, profit, color='b')\n    ax2.set_ylabel('누적 수익 (%)')\n    ax2.set_xlabel('날짜')\n    return ax1, ax2\n```\n\n모두를 결합합시다\n\n```js\naapl_ts_df = load_ticker_ts_df('AAPL',\n                               start_date='2021-01-01',\n                               end_date='2023-01-01')\nsignal_df = double_simple_moving_average_signals(aapl_ts_df, 5, 30)\nprofit_series = calculate_profit(signal_df, aapl_ts_df[\"Adj Close\"])\nax1, ax2 = plot_strategy(aapl_ts_df[\"Adj Close\"], signal_df, profit_series)\n\n# 단기 및 장기 이동평균 추가\nax1.plot(signal_df.index, signal_df['short_mavg'],\n         linestyle='--', label='빠른 SMA')\nax1.plot(signal_df.index, signal_df['long_mavg'],\n         linestyle='--', label='느린 SMA')\nax1.legend(loc='upper left', fontsize=10)\nplt.show()\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![Strategy](/TIL/assets/img/2024-07-13-BuildingAMomentumandReversionTradingStrategyWithPython_0.png)\n\n지난 2년 동안 이 전략은 30%의 수익을 창출했습니다. 최근 S&P 500의 10%의 수익과 비교했을 때, 강력한 전략으로 보입니다.\n\n## 단순 관성 전략\n\n이 전략은 가격 상승 또는 하락의 빈도에 기초합니다. 연속된 일정 기간 동안 가격이 지속적으로 상승하면 매수 기회를, 하락하면 매도 기회로 간주합니다.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이전에 논의 된 간단한 이동 평균 (SMA) 전략에서 일부 유틸리티 함수를 재사용할 것입니다.\n\n다음은이 전략의 기본 버전을 구현하는 코드입니다:\n\n```js\ndef naive_momentum_signals(ticker_ts_df, nb_conseq_days=2):\n    \"\"\"\n    연이은 양수 또는 음수 가격 변동에 기반한 소박한 모멘텀 트레이딩 신호를 생성합니다.\n    매개변수:\n    - ticker_ts_df (pandas.DataFrame): 과거 주식 데이터가 포함 된 DataFrame입니다.\n    - nb_conseq_days (int): 신호를 트리거 할 연속적 양수 또는 음수 일수입니다.\n    반환 값:\n    - signals (pandas.DataFrame): 구매 (1) 및 판매 (-1) 신호가 포함 된 'orders' 열이있는 DataFrame입니다.\n    \"\"\"\n    signals = pd.DataFrame(index=ticker_ts_df.index)\n    signals['orders'] = 0\n\n    price = ticker_ts_df['Adj Close']\n    price_diff = price.diff()\n    signal = 0\n    cons_day = 0\n    for i in range(1, len(ticker_ts_df)):\n        if price_diff[i] > 0:\n            cons_day = cons_day + 1 if price_diff[i] > 0 else 0\n            if cons_day == nb_conseq_days and signal != 1:\n                signals['orders'].iloc[i] = 1\n                signal = 1\n        elif price_diff[i] < 0:\n            cons_day = cons_day - 1 if price_diff[i] < 0 else 0\n            if cons_day == -nb_conseq_days and signal != -1:\n                signals['orders'].iloc[i] = -1\n                signal = -1\n    return signals\n\nsignal_df = naive_momentum_signals(aapl_ts_df)\nprofit_series = calculate_profit(signal_df, aapl_ts_df[\"Adj Close\"])\nax1, _ = plot_strategy(aapl_ts_df[\"Adj Close\"], signal_df, profit_series)\nax1.legend(loc='upper left', fontsize=10)\nplt.show()\n```\n\n<img src=\"/TIL/assets/img/2024-07-13-BuildingAMomentumandReversionTradingStrategyWithPython_1.png\" />\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안타깝지만, 이 전략은 수익을 창출하지 않았고 수익을 얻지 못했습니다.\n\n그러나 모델을 단순히 반전시킴으로써 더 나은 성과를 거둘 수도 있었을 것입니다 (이 기법은 WallStreetBets의 주식 분석에 많이 제안된 방법 중 하나입니다). 이를 위해 거래 신호를 -1로 곱하면 됩니다. 이 반전 접근법은 전략의 원래 신호가 효과적이지 않을 때 일반적으로 효과적입니다.\n\n솔직히 말해서, 이 전략은 일반적으로 개별 상품이 아닌 더 넓은 시장에 적용되며 더 짧은 시간대에 구현됩니다.\n\n# 회귀 전략\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예를 들어, 일론 머스크가 테슬라에 블록체인을 통합할 것이라는 트윗을 올리면, 테슬라 주식에 과도한 매수 열풍이 불고 있을 것입니다. 그러나 다음 날에는 투자자들이 아무런 근본적인 변화가 없다는 것을 깨닫고 시장이 관심을 잃으면, 가격은 더 합리적인 수준으로 회귀할 것입니다.\n\n따라서 어떤 상품이나 도구가 어느 방향으로든 표준 지수에서 너무 빠르게 벗어날 경우, 결국 오랜 기간에 걸쳐 표준 지수로 돌아가게 될 것입니다.\n\n트렌드와 모멘텀 전략과 유사하게, 회귀 전략은 시장 역학을 간소화하고 시장 참가자들이 일반적으로 사용하는 전략입니다.\n\n# 평균 회귀\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n평균 회귀 전략에서는 주식 가격이 시간이 지남에 따라 평균값 또는 평균값에 가까워질 것이라는 가정 하에 운영합니다.\n\n아래는 이 전략을 구현하는 신호 코드입니다:\n\n```js\ndef mean_reversion_signals(ticker_ts_df, entry_threshold=1.0, exit_threshold=0.5):\n    \"\"\"\n    이동 평균과 임계값을 기반으로 한 평균 회귀 트레이딩 신호 생성.\n    매개변수:\n    - ticker_ts_df (pandas.DataFrame): 주식의 역사적 데이터가 포함된 DataFrame.\n    - entry_threshold (float): 표준 편차의 배수로 표시된 진입 임계값.\n    - exit_threshold (float): 표준 편차의 배수로 표시된 종료 임계값.\n    반환:\n    - signals (pandas.DataFrame): 'orders' 열을 포함한 Buy(1) 및 Sell(-1) 신호가 포함된 DataFrame.\n    \"\"\"\n    signals = pd.DataFrame(index=ticker_ts_df.index)\n    signals['mean'] = ticker_ts_df['Adj Close'].rolling(\n        window=20).mean()  # 필요한대로 창 크기 조정\n    signals['std'] = ticker_ts_df['Adj Close'].rolling(\n        window=20).std()  # 필요한대로 창 크기 조정\n    signals['signal'] = np.where(ticker_ts_df['Adj Close'] > (\n        signals['mean'] + entry_threshold * signals['std']), 1, 0)\n    signals['signal'] = np.where(ticker_ts_df['Adj Close'] < (\n        signals['mean'] - exit_threshold * signals['std']), -1, 0)\n    signals['orders'] = signals['signal'].diff()\n    signals.loc[signals['orders'] == 0, 'orders'] = None\n\n    return signals\n```\n\n이 함수에서는 주식 가격 데이터의 표준 편차와 평균을 결정합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n가격이 평균에서 일정 표준 편차 수로 벗어날 때 신호가 생성됩니다.\n\n이전에 만든 함수를 사용하여 함께 테스트해보겠습니다:\n\n```js\nsignal_df = mean_reversion_signals(aapl_ts_df)\nprofit_series = calculate_profit(signal_df, aapl_ts_df[\"Adj Close\"])\nax1, _ = plot_strategy(aapl_ts_df[\"Adj Close\"], signal_df, profit_series)\n\nax1.plot(signal_df.index, signal_df['mean'], linestyle='--', label=\"평균\")\nax1.plot(signal_df.index, signal_df['mean'] +\n         signal_df['std'], linestyle='--', label=\"상한 표준편차\")\nax1.plot(signal_df.index, signal_df['mean'] -\n         signal_df['std'], linestyle='--', label=\"하한 표준편차\")\nax1.legend(loc='upper left', fontsize=10)\nplt.show()\n```\n\n<img src=\"/TIL/assets/img/2024-07-13-BuildingAMomentumandReversionTradingStrategyWithPython_2.png\" />\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n종이 상으로 10%의 수익률은 만족스럽게 보일 수 있지만, 실제로는 넓은 S&P 500 지수 펀드에 투자함으로써 유사한 결과를 달성할 수 있습니다.\n\n앞으로의 글에서는 Pair-Trading과 통계적 화폐 섹터에 속한 보다 정교한 형태의 복귀 전략을 탐구할 것입니다. 또한 전략 지표인 Sharpe 비율과 같은 전략 평가를 돕는 지표들을 살펴볼 것입니다. 이 분석을 통해 우리는 S&P 500 지수의 수익률에 맞게 하는 이 전략이 왜 약한 것으로 여겨지는지를 이해할 수 있을 것입니다.\n\n저의 추천 링크를 통해 Tradingview 구독비를 최대 100% 할인받을 수 있습니다. 해당 링크에 접속하면 페이지 상단 왼쪽에 있는 Tradingview 아이콘을 클릭하여 원하는 무료 요금제로 이동하세요.\n\n➡️여기에서 제 구독하기 ➡️ https://medium.com/@aamurtazin/subscribe\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n내가 곧 올릴 블로그에서 많은 내용을 공유할 거야.","ogImage":{"url":"/TIL/assets/img/2024-07-13-BuildingAMomentumandReversionTradingStrategyWithPython_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-BuildingAMomentumandReversionTradingStrategyWithPython_0.png","tag":["Tech"],"readingTime":17},{"title":"드롭할지 유지할지 수학적 최적화로 비디오 게임 인벤토리 문제를 해결하는 방법","description":"","date":"2024-07-13 18:58","slug":"2024-07-13-ToDrop-ItortoKeep-ItHowtoSolveaVideoGameInventoryProblemwithMathematicalOptimization","content":"\n\n![게임 인벤토리 문제 해결을 위한 수학적 최적화를 통한 비디오 게임 인벤토리 문제 해결 방법](/TIL/assets/img/2024-07-13-ToDrop-ItortoKeep-ItHowtoSolveaVideoGameInventoryProblemwithMathematicalOptimization_0.png)\n\n지금은 벌써 늦은 밤입니다. 비디오 게임을 즐기고 있고 몇 시간 동안 보석을 모으고 있습니다 🎮 (경험치 또는 아이템을 얻기 위해 동일한 적과 반복적으로 싸우는 것). 갑자기, 당신이 몇 일째 찾고 있던 방어구를 떨어뜨린 적이 나타납니다. 하지만 이미 인벤토리가 꽉 차 있어서 넣을 수가 없습니다. 재배열을 시도해봐도 맞추기 힘듭니다. 이제 무엇을 유지하고 무엇을 버릴지 결정해야 합니다. 다차원 배낭 문제의 흥미로운 세계로 환영합니다. 이 기사에서는 이 문제에 대한 수학적 프로그래밍 모델을 만드는 방법을 보여주고, 파이썬과 Gurobi를 사용하여 문제를 해결하며, 이를 해결하기 위해 적용할 수 있는 일부 휴리스틱 절차를 간단히 논의하겠습니다.\n\n문제와 관련된 수학에 대해 자세히 들어가기 전에, 비디오 게임에서 이 문제가 어떻게 나타나는지와 다른 맥락에서 이를 어떻게 만날 수 있는지에 대해 시간을 할애하고 싶습니다. 오늘날 인벤토리 관리 시스템은 거의 모든 비디오 게임에서 만나볼 수 있습니다. 특히 액션 RPG(역할 재생 게임) 장르인 Diablo 시리즈 및 MMO(대규모 다중 참여 온라인 게임)인 World of Warcraft 또는 Final Fantasy XIV와 같은 게임에서. 이 시스템의 기원은 중세 및 드래곤 게임(Dungeons & Dragons)과 같은 펜 앤지 RPG에 거름될 수 있으며, 이것은 운반 용량 및 부담을 고려한 객체의 무게를 고려했습니다. 그러나 처음으로 이 인벤토리 메커니즘을 통합한 비디오 게임은 1977년 Atari의 클래식 Colossal Cave Adventure였습니다. 그 이후로 많은 비디오 게임이 이 메커니즘의 어떤 버전을 채택했습니다. Pokémon, Dragon Quest, Final Fantasy와 같은 게임은 플레이어가 특정한 수(일반적으로 99)의 항목을 운반할 수 있는 수를 제한한 99 규칙을 적용한 1차원 인벤토리 시스템을 사용했습니다.\n\n게임이 발전함에 따라 이 1차원 시스템은 희소성을 포함하고 게임 경험을 향상시키기 위해 보다 정교해졌습니다. 예를 들어, 저는 현재 Paper Mario: The Thousand-Year Door를 다시 살펴보고 있는데, 아직 간단하고 1차원인데도 더 복잡한 인벤토리 시스템을 갖췄습니다. 이 게임은 플레이어의 인벤토리가 언제든지 15개의 항목을 초과할 수 없도록 하는 규정을 부여했습니다. 플레이어가 무엇을 유지하거나 버릴지를 결정해야 하는 것을 강요하여 모든 항목이 인벤토리에 들어가지 않는다는 사실에 직면하게 합니다. 내게 소모품을 수집하고 세계 곳곳에 흩어진 모든 항목을 모으고 발견하고 싶은 자연스런 수집가로서, 이제 무엇을 유지하거나 버릴지 결정할 때 어떤 기준을 사용해야 하는지 결정해야 합니다. 내 경우엔 항목의 판매 가격을 사용하는 편입니다. Paper Mario에서 해결하려는 문제는 정확히 제한된 항목 수를 초과하지 않고 인벤토리의 총 판매 가격을 최대화하는 것입니다. 이 정확한 문제는 0-1 배낭 문제 또는 1차원 이진 배낭 문제로 알려져 있으며, 다음 섹션에서 공식적으로 설명하겠습니다. 하지만 그 전에, 다른 게임이 보다 정교한 인벤토리 시스템을 개발한 방식을 살펴보겠습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n일부 다른 게임, 특히 RPG 판타지 장르의 게임들은 다른 방향을 선택하여 유명한 격자 인벤토리 메카닉 시스템을 구축했습니다. 최초로 이러한 시스템을 시사한 것 중 하나는 The Legend of Zelda (1986)였지만, Baldur's Gate와 Diablo (1997)와 같은 시리즈는 실제로 격자 인벤토리 시스템을 경험의 핵심 부분으로 확립했습니다. 이 시스템에서 플레이어는 고정 크기의 인벤토리 화면을 가지며 각 아이템은 일정한 공간을 필요로 합니다. 이러한 인벤토리 시스템의 예시가 그림 1에 나와 있습니다. 이 메카닉은 플레이어가 인벤토리를 구성하고 아이템의 위치를 최적화하여 독특한 게임 메카닉 경험을 만들 수 있게 합니다. 플레이어는 무엇을 남길지 버릴지 결정하는 것 뿐만 아니라 인벤토리에 아이템을 맞추기 위해 어떻게 배열할지도 결정해야 합니다.\n\n격자 인벤토리 시스템은 많은 유명한 RPG들에서 널리 사용되어 왔지만 놀랍게도, 이 메카닉을 가장 복잡한 형태로 만들어낸 게임은 RPG가 아니라 액션 호러 게임인 Resident Evil 4 (RE4)였습니다. 이 게임에서는 플레이어의 인벤토리가 주인공 레온 S. 케네디의 서류가방으로 제시됩니다. 이전의 격자 인벤토리 시스템과 마찬가지로, 플레이어는 인벤토리 내에서 아이템의 위치를 변경하여 공간을 최적화할 수 있습니다. 그러나 RE4은 플레이어가 아이템을 회전하여 최적의 위치를 달성할 수 있는 추가 자유도를 제공하는 혁신을 도입했습니다. 이 기능을 통해 RE4는 본 게임 안에 \"테트리스\"와 유사한 미니 게임을 효과적으로 도입했습니다. (그림 2 참조)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이것은 이러한 메커니즘이 구현된 유일한 게임이 아닙니다. 예를 들어, 유명한 어려운 첫인상의 일인칭 슈팅 게임 \"타르코프 탈출\"도 이 시스템의 변형을 갖추고 있습니다. 게다가, 이 문제의 유사한 버전을 아느 쾌적한 농업 게임에서 찾을 수 있습니다. 스타듀 밸리나 명문화된 문에 같은 문제를 겪습니다. 이 게임에서는 땅을 갖고 있고 그 수익에 따라 심을 작물을 결정해야 합니다. 이어티만 일정량의 시간과 에너지를 소비하는 제약 조건이 있습니다.\n\n더 중요한 것은, 이러한 이차원 배낭 문제에는 비디오 게임 이상의 여러 응용 분야가 있습니다. 물류, 시설 설계, 생산 프로세스 및 기타 다양한 분야 [2-4]에서 이러한 문제를 만납니다. 이 기사의 다음 섹션에서는 학술 논문에서 제시되는 문제를 공식적으로 연구할 것입니다. 수학적 프로그래밍 공식 및 파이썬에서 Gurobi를 사용하여 문제를 해결하는 방법을 살펴볼 것입니다. 마지막으로, 이러한 문제를 해결하는 데 사용할 수 있는 휴리스틱 절차를 간단히 논의할 것입니다.\n\n이제 Gurobi를 사용한 적이 없는 경우, 특히 이 기사에서 사용할 Google Colab(이 기사에서 사용할 IDE)으로부터 Gurobi를 설정하는 방법에 대해 설명한 이전 기사 중 하나를 읽어보시기를 권장합니다. 아래에 기사 링크를 찾을 수 있습니다:\n\n만약 선형 프로그래밍(LP) 또는 정수 프로그래밍(IP) 기술에 대한 자습서와 자세한 정보가 필요하다면, Bruno Scalia C. F. Leite가 작성한 훌륭한 기사를 꼭 확인하시기 바랍니다. 아래에 링크가 있습니다. 또 다른 좋은 소스로는 William의 수학 프로그래밍에 대한 책도 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n기사 목차:\n\n- 라이브러리 설치 및 Colab 환경 설정\n- 0-1 낱개 문제\n- 2차원 낱개 문제\n- 입력 데이터 및 전처리\n- Gurobipy로 문제 해결\n- 휴리스틱 접근 방식\n- 결론\n- 참고 문헌\n\n# 라이브러리 설치 및 Colab 환경 설정\n\nGoogle Colab에서 Gurobi를 사용하려면 다음 코드를 사용하여 먼저 설치해야 합니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n!pip install gurobipy\n```\n\n설치가 완료되면이 프로젝트에 필요한 라이브러리를 가져와서 사용할 수 있습니다.\n\n```js\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Rectangle\nfrom itertools import chain, combinations, permutations, product\nimport gurobipy as gp\nfrom gurobipy import GRB\nfrom copy import deepcopy\n```\n\n또한 gurobi 세션을 초기화해야 하므로 gurobi 라이센스의 모든 관련 정보를 params 딕셔너리로 만들어야 합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nWLSACCESSID = '<여기에 WLSACCESSID를 복사하세요>'\nWLSSECRET = '<여기에 WLSSECRET를 복사하세요>'\nLICENSEID = '<여기에 LICENSEID를 복사하세요>'\n```\n\n```js\nparams = {\n\"WLSACCESSID\": WLSACCESSID,\n\"WLSSECRET\": WLSSECRET,\n\"LICENSEID\": LICENSEID,\n}\nenv = gp.Env(params=params)  # 이 줄은 gurobi 환경을 초기화합니다.\n```\n\n# 나머지 가방 문제\n\n나머지 가방 문제는 조합 최적화의 고전적인 문제이며, 더 넓은 절단 및 패킹 (Cutting and Packing, C&P) 문제 클래스의 일부입니다. 나머지 가방 문제에서는 값과 크기가 있는 엔터티 세트가 주어집니다. 목표는 선택된 엔터티들의 값의 합이 최대화되는 동안 크기의 합이 주어진 한계를 초과하지 않도록 한 개 이상의 엔터티를 선택하는 것입니다(가방의 크기). 이것은 Paper Mario에서 설명된 문제와 유사합니다. 비디오 게임에서 바로 적용되는 것 외에도, 나머지 가방 문제는 화물 적재, 프로젝트 선택, 예산 통제, 자본예산편성, 도서관에서 저널 선택 등 산업 환경에서 다양한 응용 분야가 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n표 태그를 Markdown 형식으로 변경하십시오.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 이 섹션을 계속 읽기로 결정했다면, 우리는 내 문제 해결을 통한 Paper Mario: The Thousand-Year Door 인벤토리 문제를 예시로 삼아 진행할 것입니다. 목표는 마리오의 인벤토리 아이템의 판매 가격을 최대화하는 것인데, 전체 15개의 아이템이 필요하다는 것을 고려합니다. 🌶️ Spice things up을 위해, knapsack 형식의 다양성을 보여주기 위해 추가적인 제약 조건을 소개할 것입니다. 마리오의 인벤토리에는 최소한 25의 치유 능력, 적어도 25의 FP 능력, 최소 1개의 상태 복구 아이템, 그리고 적어도 2개의 공격 아이템을 제공하는 조합의 아이템이 포함되어야 합니다. 게다가 각 아이템은 구매 가격이 있으므로, 인벤토리의 총 비용이 200코인을 초과하지 않도록 할 것입니다. 게임에서 동일한 아이템을 여러 번 구매할 수 있기 때문에, 이진 변수 대신 정수 변수를 사용할 것입니다. 문제를 구성하고 해결하는 데 필요한 모든 정보가 아래 표 1에 제시되어 있습니다. 나는 Paper Mario 위키 페이지에서 정보를 추출했습니다. 이 링크에서 CSV 형식의 데이터를 다운로드할 수 있습니다.\n\n이 문제를 gurobipy에서 구성하고 해결하려면, 아래의 코드 스니펫을 따라 하면 됩니다:\n\n```js\npaper_mario = pd.read_csv('https://raw.githubusercontent.com/ceche1212/Youtube_optimization/main/paper_mario_items_knapsack.csv')\n\nI = range(len(paper_mario)) # 아이템 I의 세트\n\nmodel = gp.Model(\"paper_mario_knp\", env=env)\n\n# 변수 생성\nx = model.addVars(I, vtype=GRB.INTEGER, name='x')\n\n# 목적 함수\nmodel.setObjective(gp.quicksum(x[i]*paper_mario['판매 가격'][i] for i in I), GRB.MAXIMIZE);\n\n# 제약 조건\nmodel.addConstr(gp.quicksum(x[i] for i in I) == 15) # 15개 미만의 아이템\nmodel.addConstr(gp.quicksum(x[i]*paper_mario['구매 가격'][i] for i in I) <= 200) # 200 이하의 예산\nmodel.addConstr(gp.quicksum(x[i]*paper_mario['치유 능력'][i] for i in I) >= 25) # 최소 25의 치유 능력\nmodel.addConstr(gp.quicksum(x[i]*paper_mario['FP 능력'][i] for i in I) >= 25) # 최소 25의 FP 능력 아이템\nmodel.addConstr(gp.quicksum(x[i]*paper_mario['상태 플레이어'][i] for i in I) >= 1) # 최소 1개의 플레이어 상태 아이템\nmodel.addConstr(gp.quicksum(x[i]*paper_mario['공격'][i] for i in I) >= 3) # 최소 2개의 공격 아이템\n\n# params 설정\ntl = 120\nmipgap = 0.0\n\nmodel.setParam('TimeLimit', tl)\nmodel.setParam('MIPGap', mipgap)\n\n# 문제 해결\nmodel.optimize()\n```\n\n모든 것이 계획대로 진행된다면, 총 knapsack 가치는 69가 되어야 하며, 아래 Figure 4와 같은 출력을 볼 수 있어야 합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/TIL/assets/img/2024-07-13-ToDrop-ItortoKeep-ItHowtoSolveaVideoGameInventoryProblemwithMathematicalOptimization_3.png\" />\n\n문제를 해결한 후에는 아래 코드 스니펫을 사용하여 솔루션을 쉽게 추출할 수 있습니다:\n\n```js\nprint(\"아이템:\")\nfor item in x.keys():\n  if x[item].x >= 0.99:\n    print(\"- \",paper_mario['Item'][item],\"QTY:\", x[item].x)\nprint(\"인벤토리의 총 가치:\",model.ObjVal)\n```\n\n<img src=\"/TIL/assets/img/2024-07-13-ToDrop-ItortoKeep-ItHowtoSolveaVideoGameInventoryProblemwithMathematicalOptimization_4.png\" />\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 2차원 배낭 문제\n\n이제 당신은 배낭 문제의 간단한 버전에 익숙해졌으니, 좀 더 어려운 버전에 도전할 준비가 되었습니다. 물건의 기하학적 형태와 방향을 고려하면, 재고 목록의 각 항목마다 결정해야 할 것이 세 가지로 늘어났습니다: 해당 물건을 인벤토리(배낭)에 넣을지 여부, 포함된 경우 어디에 놓을지, 그리고 사용할 방향(수직 또는 수평) [8]. 간단함을 위해, 모든 항목이 직사각형 또는 정사각형이라고 가정할 것입니다. 그러나 불규칙한 모양을 고려하는 이 문제의 변형도 있다는 점에 유의해야 합니다 [5], 이는 더 복잡한 문제 해결을 필요로 합니다.\n\n이 문제는 비디오 게임 캐릭터의 인벤토리 정리를 넘어서 다양한 응용 분야가 있습니다. 물류 및 운송 분야뿐만 아니라 제품의 생산 및 제조에도 자주 사용됩니다. 형식적으로, 우리의 문제는 주어진 동일한 크기 또는 다른 크기의 직사각형 집합을 선택하고 배치하여, 고정된 크기의 직사각형 내에서 중첩되지 않게, 선택된 항목들의 총 가치를 최대화하는 것으로 정의됩니다. 이전 섹션의 예와 유사하게, 필요시 추가적인 제약 조건을 포함하여 문제를 쉽게 조정할 수 있습니다.\n\n이 문제에는 다음과 같은 변수가 필요합니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![이미지](/TIL/assets/img/2024-07-13-ToDrop-ItortoKeep-ItHowtoSolveaVideoGameInventoryProblemwithMathematicalOptimization_5.png)\n\n- 변수 z_i는 재고에 항목 i를 포함할지 여부에 대한 결정에 해당합니다.\n- 변수 x_i 및 y_i는 문제의 각 자산을 나타내는 “사각형”의 (x, y) 좌표에 해당합니다. 우리의 문제에는 모든 자산 또는 사각형으로 구성된 I라는 집합이 있습니다.\n- 변수 b_i_j_k는 모델에서 \"OR\" 조건을 설정하는 데 필요한 보조 이진 변수로, 그 사용법은 나중에 자세히 설명됩니다.\n- 마지막으로 각 사각형 i는 자산 i가 회전되는지 여부를 결정하는 데 사용될 변수 r_i를 가지게 됩니다.\n\n또한 문제는 다음과 같은 입력 매개변수를 필요로 합니다:\n\n![이미지](/TIL/assets/img/2024-07-13-ToDrop-ItortoKeep-ItHowtoSolveaVideoGameInventoryProblemwithMathematicalOptimization_6.png)\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위에서 설명한 변수와 입력 매개변수를 사용하여 문제를 수학적으로 모델링하면 다음과 같은 공식을 사용할 수 있습니다:\n\n\nThe formulation above might look daunting at first sight, but it is actually quite simple. The objective function above is exactly the same as in the “vanilla” 🍦 0–1 Knapsack problem. It is just the sum of the values v_i of the items that are placed inside the inventory (for these items z_i is going to be equal to 1).\n\nConstraint (1) ensures that the the x-coordinate plus the width of each item does not exceeds the Width W of the inventory (considering that the item could be rotated). Similarly, constraint (2) ensures that the the y-coordinate plus the height of each item does not exceeds the Height H of the inventory (considering that the item could be rotated).\n\n\n위의 공식은 처음 보면 복잡해 보일 수 있지만 실제로는 매우 간단합니다. 위의 목적 함수는 \"일반적인\" 🍦 0-1 배낭 문제와 정확히 동일합니다. 인벤토리 안에 배치된 항목의 값을 나타내는 v_i의 합일 뿐입니다. (이러한 항목에 대해 z_i가 1이 됩니다.)\n\n제약 조건(1)은 각 항목의 x 좌표 및 너비를 합한 값이 인벤토리의 너비 W를 초과하지 않도록 보장합니다(항목이 회전될 수 있다는 것을 고려합니다). 비슷하게, 제약 조건(2)는 각 항목의 y 좌표와 높이를 합한 값이 인벤토리의 높이 H를 초과하지 않도록 보장합니다(항목이 회전될 수 있다는 것을 고려합니다).\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nConstraints (3-7)은 서로 다른 항목의 위치 간에 겹침이 없도록 보장합니다. 이러한 제약 조건은 OR 조건으로 작동하며, 변수 b_i_j_1, b_i_j_2, b_i_j_3, 및 b_i_j_4를 각 항목에 사용하고, Big-M 방법을 사용합니다. 요약하면, 한 항목은 다른 항목의 왼쪽, 오른쪽, 위, 또는 아래에 위치할 수 있지만, 겹치지는 않습니다.\n\nConstraints (8-11)은 단순히 변수가 적절한 도메인에 속해 있는지 확인합니다.\n\n# 입력 데이터 및 전처리\n\n간단히하기 위해, 10개의 항목으로 구성된 다섯 그룹을 사용하겠습니다. 각 그룹 내의 모든 항목은 동일한 차원을 가질 것입니다. 재고는 폭(W)이 15 단위이고 높이(H)가 8 단위인 것으로 합니다. 예제 항목의 차원 및 모든 관련 정보는 아래의 테이블에 표시되어 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n데이터가 사용 가능하도록 하려면 각 값을 리스트에 저장한 다음 각 항목을 별도의 행으로 준비하는 확장된 데이터프레임을 만들 것입니다. 아래의 코드를 사용하여 이를 구현할 수 있습니다:\n\n```js\nwidths = [6, 1, 2, 3, 3]\nheights = [2, 1, 1, 2, 4]\ncolors = ['red', 'skyblue', 'green', 'yellow', 'orange']\nvalues = [15, 2, 2, 7, 20]\n\nW = 15\nH = 8\nquants = [10, 10, 10, 10, 10]\n\ntop = max(W, H)\n\ndf = pd.DataFrame()\ndf['quantity'] = quants\ndf['heights'] = heights\ndf['widths'] = widths\ndf['color'] = colors\ndf['values'] = values\n\nWIDTHS = []\nHEIGHTS = []\nVALUES = []\nCOLORS = []\nfor q, w, h, v, c in zip(quants, widths, heights, values, colors):\n    for x in range(q):\n        HEIGHTS.append(w)\n        WIDTHS.append(h)\n        VALUES.append(v)\n        COLORS.append(c)\n\ndata_df = pd.DataFrame()\ndata_df['HEIGHTS'] = HEIGHTS\ndata_df['WIDTHS'] = WIDTHS\ndata_df['VALUES'] = VALUES\ndata_df['COLORS'] = COLORS\n\nN = len(WIDTHS)\nM = max(sum(WIDTHS), sum(HEIGHTS))\n\nI = range(N)  # 각 자산 \"i\"의 인덱스를 위해\nK = range(4)  # OR 변수 \"b\"의 인덱스를 위해\n```\n\n# Gurobipy를 사용하여 문제 해결\n\n이제 필요한 모든 라이브러리와 입력 데이터가 준비되었으므로 Figure 8에 설명된 수학 모델을 만들어볼 차례입니다. GurobiPy를 사용하여 이 모델을 구현하려면 아래의 코드 스니펫을 따라하면 됩니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nmodel = gp.Model(\"두 차원 배낭 문제\", env=env)\n\n# 변수 생성\nx = model.addVars(I, lb=0, ub=top, vtype=GRB.CONTINUOUS, name=\"x\")\ny = model.addVars(I, lb=0, ub=top, vtype=GRB.CONTINUOUS, name=\"y\")\n\nZ = model.addVars(I, vtype=GRB.BINARY, name='Z')\n\nb_vars = [(i, j, k) for i in I for j in I if j != i for k in K]\n\nB = model.addVars(b_vars, vtype=GRB.BINARY, name=\"B\")\n\nR = model.addVars(I, vtype=GRB.BINARY, name='R') \n\n# 목적 함수\nmodel.setObjective(gp.quicksum(Z[i] * data_df['VALUES'][i] for i in I), GRB.MAXIMIZE);\n\n# 제약 조건\nfor i in I:\n    model.addConstr(x[i] + (data_df['WIDTHS'][i] * R[i] + data_df['HEIGHTS'][i] * (1 - R[i])) * Z[i] <= W)\n    model.addConstr(y[i] + (data_df['HEIGHTS'][i] * R[i] + data_df['WIDTHS'][i] * (1 - R[i])) * Z[i] <= H)\n\nfor i in I:\n    for j in I:\n        if i == j:\n            continue\n        else:\n            model.addConstr(x[i] + (data_df['WIDTHS'][i] * R[i] + data_df['HEIGHTS'][i] * (1 - R[i])) * Z[i] <= x[j] + M * (1 - B[i,j,0]))\n            model.addConstr(x[j] + (data_df['WIDTHS'][j] * R[j] + data_df['HEIGHTS'][j] * (1 - R[j])) * Z[j] <= x[i] + M * (1 - B[i,j,1]))\n\n            model.addConstr(y[i] + (data_df['HEIGHTS'][i] * R[i] + data_df['WIDTHS'][i] * (1 - R[i])) * Z[i] <= y[j] + M * (1 - B[i,j,2]))\n            model.addConstr(y[j] + (data_df['HEIGHTS'][j] * R[j] + data_df['WIDTHS'][j] * (1 - R[j])) * Z[j] <= y[i] + M * (1 - B[i,j,3]))\n\n            model.addConstr(B[i,j,0] + B[i,j,1] + B[i,j,2] + B[i,j,3] >= 1)\r\n```\n\n주의해야 할 점은 제약조건 (8-11)이 변수 생성 과정에서 이미 설정되었으므로, model.addConstr 메서드를 통해 명시적으로 추가할 필요가 없다는 것입니다. 이제 모델이 완성되었으므로 문제를 해결해 볼 수 있습니다. 이 문제는 복잡하기 때문에 600초(10분) 동안 실행해 보겠습니다. 또한 최적화 과정이 최적값의 5% 이내에 있으면 프로세스를 종료하고 현재까지 얻은 최상의 해를 얻을 수 있도록 설정합니다. 문제를 해결하려면 아래 코드를 따라하세요:\n\n```js\ntl = 600\nmip_gap = 0.05\n\nmodel.setParam('TimeLimit', tl)\nmodel.setParam('MIPGap', mip_gap)\nmodel.optimize()\r\n```\n\n600초 후에 아직 최적해를 확인하지 못했습니다(저희가 모르는 사이에 이미 최적이라고 생각됩니다), 그러나 재고 가치는 상당히 증가했습니다. 초기 값이 35에서 최종 값인 195로 증가했습니다. 이는 원래 값의 거의 6배이며, 꽤 좋은 결과입니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n문제가 해결되었으니, 솔루션을 추출하고 이를 플롯하는 것만 남았어요. 아래 코드를 따라하면 matplotlib의 Rectangle 객체를 사용하여 쉽게 이를 수행할 수 있습니다:\n\n```js\nfor item in Z.keys():\n  if Z[item].x >= 0.99:\n    print(COLORS[item],Z[item].x,R[item].x >0.5,x[item].x,y[item].x,(WIDTHS[item],HEIGHTS[item]))\n```\n\n아래는 Markdown 표 형식으로 나타낸 print 문의 솔루션 출력을 찾을 수 있습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n| Color   | Z_i | 회전     | x    | y    | 크기       |\n|---------|-----|----------|------|------|------------|\n| skyblue | 1.0 | False    | 9.0  | 7.0  | (1, 1)     |\n| skyblue | 1.0 | False    | 0.0  | 5.0  | (1, 1)     |\n| skyblue | 1.0 | False    | 14.0 | 7.0  | (1, 1)     |\n| skyblue | 1.0 | False    | 1.0  | 7.0  | (1, 1)     |\n| skyblue | 1.0 | False    | 3.0  | 7.0  | (1, 1)     |\n| skyblue | 1.0 | False    | 10.0 | 7.0  | (1, 1)     |\n| skyblue | 1.0 | False    | 0.0  | 4.0  | (1, 1)     |\n| skyblue | 1.0 | False    | 2.0  | 7.0  | (1, 1)     |\n| skyblue | 1.0 | False    | 8.0  | 7.0  | (1, 1)     |\n| skyblue | 1.0 | False    | 11.0 | 7.0  | (1, 1)     |\n| green   | 1.0 | False    | 12.0 | 7.0  | (1, 2)     |\n| green   | 1.0 | False    | 4.0  | 7.0  | (1, 2)     |\n| green   | 1.0 | False    | 6.0  | 7.0  | (1, 2)     |\n| green   | 1.0 | True     | 0.0  | 6.0  | (1, 2)     |\n| yellow  | 1.0 | True     | 9.0  | 4.0  | (2, 3)     |\n| orange  | 1.0 | False    | 3.0  | 0.0  | (4, 3)     |\n| orange  | 1.0 | False    | 12.0 | 0.0  | (4, 3)     |\n| orange  | 1.0 | True     | 1.0  | 4.0  | (4, 3)     |\n| orange  | 1.0 | False    | 9.0  | 0.0  | (4, 3)     |\n| orange  | 1.0 | True     | 5.0  | 4.0  | (4, 3)     |\n| orange  | 1.0 | False    | 6.0  | 0.0  | (4, 3)     |\n| orange  | 1.0 | False    | 0.0  | 0.0  | (4, 3)     |\n| orange  | 1.0 | True     | 11.0 | 4.0  | (4, 3)     |\r\n\n\r\n저희 인벤토리에는 빨간색 항목이 선택되지 않았는지 확인할 수 있습니다. 공간이 소비되었으나 포함하지 않을 가치가 충분하지 않아 보입니다. 아래 표 10을 확인하여 최종 인벤토리의 시각적 표현을 확인할 수도 있습니다.\r\n\r\n<img src=\"/TIL/assets/img/2024-07-13-ToDrop-ItortoKeep-ItHowtoSolveaVideoGameInventoryProblemwithMathematicalOptimization_9.png\" />\r\n\r\n# 휴리스틱 접근법\r\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n문제에서 언급했듯이 이 문제는 건설적 휴리스틱을 사용하여 문헌에서 다루어졌습니다. 왜 휴리스틱이 사용되는지 궁금할 수 있습니다. 답은 간단합니다. 휴리스틱은 빠르고 계산 비용이 적습니다. 휴리스틱은 최적성을 보장하지는 않지만 품질 측면에서 놀랍도록 좋은 해결책을 빠르고 비용 효율적으로 제공합니다.\n\n다행히도, 이 문제를 해결하기 위해 특별히 설계된 Python 라이브러리인 rectpack이라는 라이브러리가 있습니다. 이 라이브러리는 재고의 항목 배열만 다루며 문제의 가치 최대화 부분을 직접 해결하지는 않습니다. 그러나 라이브러리에서 제공하는 여러 알고리즘을 시도함으로써 어떤 것이 최상의 재고 가치를 제공하는지 확인할 수 있습니다. 이 라이브러리 사용에 대한 자세한 내용은 Samir Saci가 쓴 훌륭한 Medium 게시물을 추천합니다.\n\n# 결론\n\n마지막으로, 이 기사는 수학적 프로그래밍을 사용하여 2차원 낙석 문제를 해결하는 과정을 안내해드렸습니다. 우리는 기본 0-1 낙석 문제와 그것을 Gurobi에서 구현하는 방법으로부터 시작했습니다. 그런 다음, 우리는 문제의 2차원 버전을 위한 혼합 정수 선형 프로그래밍(MILP) 공식과 그 문제를 Gurobi를 사용하여 어떻게 해결할지 탐구했습니다. 마지막으로, 건설적 휴리스틱과 rectpack 라이브러리를 간단히 논의했습니다. 이 기사를 즐겨주셨고 실생활 맥락에서 비슷한 변형의 문제에 대해 더 알고 싶다면, 이전에 게시한 2차원 조합 문제에 관한 기사를 확인하시기를 권장합니다. 기사 링크는 아래에 제공되어 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n제 RE4 인벤토리를 최적화하거나 스타듀 밸리의 농장 플롯을 개선하려는 누구에게든 도움이 되는 리소스로 써드루 밸리의 코드 개발을 포함한 이 기사가 도움이 되었으면 좋겠어요 😂. 이 기사에 대한 완전한 노트북은 아래 GitHub 저장소 링크에 있습니다.\n\n정말로 이 기사가 유용하고 재미있었기를 바라며, 만약 그렇다면 귀하의 생각을 듣고 싶습니다! 의견을 남기거나 👏 클랩으로 감사를 표현해주시면 감사하겠습니다. 그리고 제 최신 기사를 업데이트하고 싶다면, Medium에서 저를 팔로우해보세요. 귀하의 지지와 피드백이 저에게 더 탐구하고 이 매력적인 분야를 공유하도록 동기를 부여합니다. 읽어주셔서 감사하며, 다음 기사에서 더 많은 통찰력을 기대해주세요!\n\n# 참고 자료\n\n- [1] Williams HP. Model Building in Mathematical Programming. 4판. Chichester: Wiley; 1999\n- [2] Caprara, A. 및 Monaci, M., 2004. On the two-dimensional knapsack problem. Operations Research Letters, 32(1), pp.5–14.\n- [3] Baker, B.S.; Coffman Jr, E.G.; Rivest, R.L. (1980) Orthogonal packings in two dimensions. SIAM Journal of Computing 9(4): 846–855.\n- [4] Del Valle, A.M.; Queiroz, T.A.; Miyazawa, F.K.; Xavier, E.C. (2012) Heuristics for two-dimensional knapsack and cutting stock problems with items of irregular shape. Expert Systems with Applications 39(16): 12589–12598.\n- [5] DellaFave, R. (2014) Designing an RPG Inventory System That Fits: https://gamedevelopment.tutsplus.com/designing-an-rpg-inventory-system-that-fits-preliminary-steps--gamedev-14725a\n- [6] Martello, S. & Toth, P. (1990) Knapsack Problems: Algorithms and computer implementations. John Wiley & Sons, West Sussex.\n- [7] Salkin, H.M. & de Kluyver, C.A. (1975) The Knapsack Problem: a survey. Naval Research Logistics Quarterly 22(1): 127–144.\n- [8] Bortfeldt, A. & Winter, T. (2009) A genetic algorithm for the Two-dimensional Knapsack Problem with rectangular pieces. International Transactions in Operational Research 16: 685–713.","ogImage":{"url":"/TIL/assets/img/2024-07-13-ToDrop-ItortoKeep-ItHowtoSolveaVideoGameInventoryProblemwithMathematicalOptimization_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-ToDrop-ItortoKeep-ItHowtoSolveaVideoGameInventoryProblemwithMathematicalOptimization_0.png","tag":["Tech"],"readingTime":23},{"title":"의사결정자들이 수학을 더 배워야 하는 이유","description":"","date":"2024-07-12 21:05","slug":"2024-07-12-DecisionMakersNeedMoreMath","content":"\n\n<img src=\"/TIL/assets/img/2024-07-12-DecisionMakersNeedMoreMath_0.png\" />\n\n최근에 직장에서 일에 대해 곤란해하는 친구와 대화를 나누었어요. 그 친구는 자신이 판매 인력부에서 주도하는 주요 소프트웨어 롤아웃에 책임이 있었지만, 그 일에 대해 믿지 않았어요. 사실 그의 동료들도 그렇게 생각하지 않았다고 해요. 그가 묘사한 상황은 정말 안좋고 동기 부여가 안 되는 상황 같았어요.\n\n나는 당연하게도 어떻게 이런 상황이 발생했는지 물어보았어요. 그 친구는 롤아웃을 추진할 결정이 경영진 사이에서 유포된 '킬러 차트'에서 비롯되었다고 설명했어요. 차트는 두 그룹의 판매 결과를 비교하여 특정 소프트웨어 제품을 현장에서 사용한 한 그룹이 더 효과적이라는 결론을 내렸다고 해요.\n\n내가 한 질문은 두가지였어요. 먼저, 그들이 두 그룹의 차이가 우연 때문이 아닌지 확인했느냐 물어보았고, 그 다음으로 소프트웨어 사용이 그 차이를 일으켰다는 것이 결정적으로 입증되었는지 확인했느냐 물었어요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n말끔히 당황했다. 그는 우연히 차이가 발생할 수 있다는 것을 전혀 몰랐다며 원인과 결과에 대한 질문은 심지어 논의되지 않았다고 말했다. 그는 경영진이 단지 차트를 삼켜버리고 숫자들과 그 의미에 대한 추가 논쟁 없이 결정을 내렸다고 설명했다.\n\n우리가 도출한 결론은 이 모든 것이 그룹 내에서 수학에 대해 아무도 모르기 때문에 발생했다는 것이었다! 분석 자료 한 조각이 그룹 전체를 휩쓴 바 있었고, 관련된 사람들은 모두 그것을 올바르게 비평할 경험이나 지식이 없었다.\n\n나는 이러한 상황이 급속히 확대되고 있고, 그로 인해 수백만 달러의 잘못된 결정이 이루어지고 있다는 것을 우려한다.\n\n## 왜 수학이 더 중요해지고 있는 것일까?\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n간단히 말하면, 데이터의 양이 많이 증가했습니다. IBM에 따르면, 우리는 이제 매일 2.5 퀸틸리언 바이트 이상의 데이터를 생성하고 있습니다. 이러한 추세가 계속될 것으로 보여주는 다양한 통계가 있습니다:\n\n- McKinsey의 연구에 따르면, 거의 50%의 영업 및 마케팅 기능이 자신들을 '분석 및 빅데이터에 의해 변형되었다'고 설명하고 있습니다.\n- Statista에 따르면, 빅데이터 시장은 다음 10년 동안 연간 10% 이상 성장할 것으로 보고 있습니다.\n- 최근 업무 설문 조사에 따르면, 기업의 84%가 고급 분석 및 빅데이터 프로젝트를 시작하여 의사 결정을 개선하고 있습니다.\n\n명확한 사실은 의사 결정자들이 10년이나 20년 전보다 훨씬 많은 데이터 주도 문서와 차트를 마주하게 될 것이라는 것입니다. 하지만 이러한 데이터 풍부한 환경에서 정확한 결정을 내릴 수 있는 능력을 가진 의사 결정자들이 더 잘 갖추어져 있는지 궁금합니다.\n\n![이미지](/TIL/assets/img/2024-07-12-DecisionMakersNeedMoreMath_1.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 수학 능력은 높아지고 있지만 기술은 부족합니다\n\n데이터 중심의 의사 결정과 분석 붐으로 인해 경영진의 수학 능력도 함께 높아져야 합니다. 분석을 의심하고 비평할 수 있는 능력이 없다면 의사 결정자들은 판촉 활동과 편향된 의도에 휘둘릴 수밖에 없습니다. 상관 관계, 회귀, 통계적 유의성 및 예측 정확도와 같은 개념들이 언급되고 있지만, 의사 결정자들이 그것들을 이해할 만큼 충분히 잘 갖추고 있는지에 대한 증거가 없습니다.\n\n- 영국의 케임브리지 평가 연구에 따르면, 고도의 데이터 중심인 것이 아닌 직무에서도 고용주들은 수리능력을 중요시하며, 그러나 현재의 업무 인원은 이를 충족시키기에 적절한 수준이 되지 못하고 있다고 강조합니다.\n- 미국 노동부는 다음 10년 동안 수학 관련 직종이 다른 직종보다 4배 빠른 속도로 성장할 것으로 예상되지만, OECD에 따르면 미국은 성인의 수리 능력 평균으로 볼 때 30개국 중 24위를 차지합니다.\n- 최근 하버드 대학의 연구에 따르면, 미래 직업 시장에서 수학은 가장 필수적인 기술 중 하나가 될 것으로 예상되며, 최근의 가장 큰 일자리 증가는 수학이 필요한 포지션으로 집중되고 있다는 것을 보여줍니다.\n\n# 의사 결정자들이 알아야 할 것은 무엇인가요?\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n세련된 매크로 요소와 트렌드 가운데, 데이터 중심 환경에서 의사 결정자가 알아야 할 몇 가지 기본적인 요소들이 있다고 생각이 듭니다:\n\n- 상관 관계의 의미와 다양한 유형의 데이터에 대한 상관 계수 측정 방법\n- 인과 관계의 의미, 상관 관계와의 차이, 그리고 인과 관계를 증명하는 방법\n- 가설 검증의 통계적 방법과 가설 검정에 기반한 통계적 조건\n\n데이터 중심 환경에서 일하고 계시는데 이러한 것들에 대해 충분히 이해하고 있다고 느끼지 않으시다면, 지금이라도 대책을 세우도록 권장드립니다. 더불어 동료 의사 결정자들도 비슷한 입장에 있다고 느낀다면, 상황은 더욱 시급해진다고 할 수 있습니다.\n\n매년마다 직장에서 수학적 지식이 더욱 중요해지는 건 의심할 여지가 없습니다. 우리가 좋아하든 안 하든, 노력을 기울여 학습을 해 나가야 할 필요가 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n수학이 당신의 업무에서 얼마나 중요한가요? 자유롭게 의견을 남겨주세요.","ogImage":{"url":"/TIL/assets/img/2024-07-12-DecisionMakersNeedMoreMath_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-DecisionMakersNeedMoreMath_0.png","tag":["Tech"],"readingTime":4},{"title":"빅데이터 처리를 위한 Python 사용 방법","description":"","date":"2024-07-12 21:01","slug":"2024-07-12-PythonforBigData","content":"\n\n빅 데이터는 인간의 행동과 상호 작용과 관련된 패턴, 동향 및 관련성을 밝히기 위해 계산적으로 분석할 수 있는 극도로 큰 데이터 세트를 가리킵니다. 네 가지 V - Volume, Velocity, Variety, 그리고 Veracity. 이러한 V는 빅 데이터를 특징 짓는데, 함께 간단하게 알아보도록 하죠:\n\n- Volume: 매초 생성되는 데이터의 양은 엄청나게 많습니다. 소셜 미디어 업데이트부터 거래 기록까지 규모는 거대합니다.\n- Velocity: 데이터는 이례적으로 빠른 속도로 생성되며, 실시간 또는 거의 실시간 처리가 요구됩니다.\n- Variety: 데이터는 다양한 형식으로 제공됩니다 - 구조화된, 반구조화된 그리고 비구조화된 데이터 형식으로, 텍스트, 이미지, 비디오 등이 있습니다.\n- Veracity: 데이터의 품질과 정확도는 매우 다양할 수 있으며, 신중한 데이터 관리 및 처리 기술이 필요합니다.\n\nPython은 간단함과 데이터 처리 및 분석을 위한 강력한 라이브러리가 많이 제공되어 인기 있는 언어입니다. Python이 빅 데이터 기술과 어떻게 결합되는지 알아봅시다.\n\n![Python을 위한 빅 데이터 이미지](/TIL/assets/img/2024-07-12-PythonforBigData_0.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 대용량 데이터 처리를 위해 PySpark와 같은 라이브러리 사용하기\n\n## PySpark 소개\n\nPySpark는 대규모 데이터 처리를 위한 오픈 소스 통합 분석 엔진인 Apache Spark의 파이썬 API입니다. Spark는 암시적 데이터 병렬 처리와 오류 허용을 통해 전체 클러스터를 프로그래밍하는 인터페이스를 제공합니다.\n\n## PySpark 설정하기\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nPySpark을 사용하려면 먼저 설치해야 합니다. PySpark는 다음과 같이 pip을 통해 설치할 수 있습니다:\n\n```js\npip install pyspark\n```\n\n## PySpark을 사용한 기본 작업\n\nPySpark를 사용하여 몇 가지 기본 작업을 살펴보겠습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nSparkSession을 초기화하는 방법:\n\n```python\nfrom pyspark.sql import SparkSession\n\nspark = SparkSession.builder \\\n    .appName(\"BigDataWithPySpark\") \\\n    .getOrCreate()\n```\n\n데이터 읽기:\n\n다양한 소스에서 데이터를 읽을 수 있습니다. CSV 파일을 읽는 예제는 다음과 같습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ndf = spark.read.csv(\"파일경로/당신의/csv파일.csv\", header=True, inferSchema=True)\n```\n\n데이터 변환 수행하기:\n\nPySpark 데이터프레임은 강력한 데이터 처리 기능을 제공합니다. 여기에 일반적인 변환 작업 몇 가지가 있습니다:\n\n```js\n# 특정 열 선택\ndf_selected = df.select(\"column1\", \"column2\")\n\n# 행 필터링\ndf_filtered = df.filter(df[\"column1\"] > 50)\n\n# 그룹화 및 집계\ndf_grouped = df.groupBy(\"column2\").agg({\"column1\": \"mean\"})\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n실행 중인 작업:\n\n작업은 DataFrame에 대한 변환 실행을 트리거합니다:\n\n```js\n# DataFrame 표시\ndf.show()\n\n# 결과를 로컬 리스트로 수집\ndata = df.collect()\n```\n\n예시: PySpark를 사용한 단어 카운트\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n큰 데이터 처리의 고전적인 예로 단어 수 세기 문제가 있습니다.\n\n```python\n# 텍스트 파일에서 RDD 생성\ntext_file = spark.sparkContext.textFile(\"경로/텍스트파일.txt\")\n\n# 단어 수 세기 수행\nword_counts = text_file.flatMap(lambda line: line.split(\" \")) \\\n    .map(lambda word: (word, 1)) \\\n    .reduceByKey(lambda a, b: a + b)\n\n# 결과 수집\nresults = word_counts.collect()\nfor word, count in results:\n    print(f\"{word}: {count}\")\n```\n\n## 파이썬을 하둡 및 다른 빅데이터 기술과 통합하기\n### 하둡 및 HDFS\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하둡은 대규모 데이터 집합의 분산 처리를 위해 컴퓨터 클러스터 간에 사용되는 프레임워크입니다. 하둡 분산 파일 시스템 (HDFS)은 방대한 양의 데이터를 저장하고 고 처리량 액세스를 제공하기 위해 설계되었습니다.\n\n## PyArrow를 사용하여 HDFS에 액세스하기\n\nPyArrow는 인메모리 데이터를 처리하기 위한 크로스-언어 개발 플랫폼입니다. 이를 사용하여 HDFS와 상호작용할 수 있습니다.\n\nPyArrow 설치 방법:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\npip install pyarrow\n```\n\nHDFS와 상호 작용하기:\n\n```js\nimport pyarrow.fs as fs\n\n# HDFS에 연결하기\nhdfs = fs.HadoopFileSystem('hdfs://your-hdfs-namenode:8020')\n\n# HDFS 디렉토리의 파일 목록 가져오기\nfiles = hdfs.get_file_info(fs.FileSelector('/path/in/hdfs'))\n\nfor file in files:\n    print(file)\n```\n\n## Apache Hive 통합\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nHive은 SQL을 사용하여 분산 저장소에 저장된 대규모 데이터 세트의 읽기, 쓰기 및 관리를 용이하게 하는 데이터 웨어하우스 소프트웨어입니다.\n\n## PyHive를 사용하여 Hive에 연결하는 방법\n\nPyHive 설치하기:\n\n```js\npip install pyhive\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파이썬에서 Hive 쿼리하기:\n\n```js\nfrom pyhive import hive\n\n# Hive에 연결\nconn = hive.Connection(host='your-hive-server', port=10000, username='your-username')\n\n# 쿼리 실행\ncursor = conn.cursor()\ncursor.execute(\"SELECT * FROM your_table LIMIT 10\")\n\n# 결과 가져오기\nresults = cursor.fetchall()\nfor row in results:\n    print(row)\n```\n\n## Apache Kafka와 통합\n\nKafka는 하루에 수조 건의 이벤트를 처리할 수 있는 분산 이벤트 스트리밍 플랫폼입니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## Kafka 통합을 위한 Kafka-Python 사용하기\n\nKafka-Python 설치:\n\n```js\npip install kafka-python\n```\n\n메시지 생성 및 소비:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nfrom kafka import KafkaProducer, KafkaConsumer\n\n# Kafka 프로듀서 생성\nproducer = KafkaProducer(bootstrap_servers='your-kafka-broker:9092')\nproducer.send('your_topic', b'This is a test message')\n\n# Kafka 컨슈머 생성\nconsumer = KafkaConsumer('your_topic', bootstrap_servers='your-kafka-broker:9092')\nfor message in consumer:\n    print(message.value.decode('utf-8'))\n```\n\n## Python이 대용량 데이터 처리에 적합한 이유\n\n다양한 생태계: Python은 복잡한 데이터 처리 작업을 간단하게 만드는 라이브러리와 프레임워크가 풍부한 생태계를 자랑합니다. 예를 들어, PySpark는 Apache Spark의 강력한 기능을 활용하여 대규모 데이터 처리를 쉽게 처리하고, PyArrow는 HDFS와의 원활한 상호작용을 용이하게 합니다.\n\n학습과 사용의 용이성: Python의 문법은 깨끗하고 배우기 쉬워 초보자부터 숙련된 프로그래머까지 접근하기 쉽습니다. 이러한 사용의 용이성은 개발 프로세스를 가속화시켜 빠른 프로토타이핑과 반복을 가능하게 합니다.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n확장성: 파이썬은 하둡, 하이브, 카프카와 같은 강력한 빅데이터 기술과 통합되어 있어, 응용 프로그램이 대규모 데이터 세트의 요구를 충족하기 위해 확장 가능합니다. 이 확장성은 실시간으로 데이터를 처리하고 분석해야 하는 비즈니스에 중요합니다.\n\n커뮤니티 지원: 파이썬 커뮤니티는 크고 활발하여 지속적으로 새로운 도구를 개발하고 기존 도구를 개선하고 있습니다. 이 활기찬 커뮤니티 지원은 파이썬이 빅데이터 기술 분야의 기술적 발전을 선도하고 있음을 의미합니다.\n\n## 실용적인 응용분야\n\n파이썬이 빅데이터 분야에서 활용되는 실용적인 응용분야는 매우 다양하고 광범위합니다. 각 산업의 기업들이 파이썬을 활용하여 데이터로부터 통찰을 얻고 있습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n금융: 금융 기관은 부정 행위 감지, 리스크 관리 및 알고리즘 거래에 파이썬을 사용합니다. 거래 및 시장 데이터의 대량 데이터 세트를 처리하고 분석하여 패턴을 식별하고 신중한 결정을 내립니다.\n\n건강 관리: 의료 분야에서는 예측 분석, 환자 데이터 관리 및 맞춤 의료에 파이썬을 사용합니다. 의료 기록과 연구 데이터의 대량을 분석하여 환자 결과를 개선하고 운영을 최적화합니다.\n\n소매: 소매업체는 고객 행동을 분석하고 재고를 관리하며 마케팅을 맞춤화하는 데 파이썬을 사용합니다. 빅데이터 분석을 통해 구매 패턴을 이해하고 고객 경험을 향상시킵니다.\n\n제조업: 제조업체는 예측 유지보수, 공급망 최적화 및 품질 관리를 위해 파이썬을 활용합니다. 센서 데이터와 생산 지표를 분석하여 효율성을 향상시키고 다운타임을 줄이는 데 도움을 줍니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 미래 전망\n\n데이터 양이 기하급수적으로 증가함에 따라 효율적이고 확장 가능한 데이터 처리 솔루션이 더욱 중요해질 것입니다. Python은 계속해서 이러한 변화하는 환경에서 중심적인 역할을 하게 될 것입니다.\n\n머신 러닝과 인공 지능: Python은 TensorFlow, Keras, scikit-learn과 같은 머신 러닝 라이브러리와의 통합을 통해 고급 분석 및 대용량 데이터로부터 학습하는 AI 모델의 개발을 가능케 합니다.\n\n실시간 분석: 실시간 분석의 필요성이 더욱 두드러지게 되고 있습니다. Python은 Apache Kafka와 같은 스트리밍 데이터 플랫폼과 작업할 수 있는 능력을 통해 기업이 데이터가 도착하는 대로 신속하게 반응하여 적시에 통찰력과 조치를 제공할 수 있도록 합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n데이터 프라이버시와 보안: 데이터 프라이버시와 보안에 대한 관심이 증가함에 따라, Python은 데이터 마스킹, 암호화 및 규정 준수 기능에 대한 능력이 더욱 중요해지고 있습니다. 데이터가 안전하게 처리되고 저장되는 동시에 규정 준수를 유지하는 것이 매우 중요합니다.\n\n클라우드 통합: 데이터 저장 및 처리를 위한 클라우드 기반 솔루션으로의 이전이 계속해서 확대되고 있습니다. Python의 AWS, Azure, Google Cloud와 호환되는 특성은 확장 가능하고 비용 효율적인 빅 데이터 솔루션을 제공합니다.\n\n요약하면, Python은 빅 데이터 분야에서 다양하고 지속적으로 확장되는 역할을 하고 있습니다. 견고한 생태계, 사용 편의성 및 강력한 통합을 통해 대규모 데이터 처리 작업에 대한 필수 언어가 되었습니다. 분산 컴퓨팅을 위한 PySpark, HDFS 상호작용을 위한 PyArrow, 대규모 데이터 쿼리를 위한 PyHive, 이벤트 스트림 처리를 위한 Kafka-Python을 통해 Python은 데이터 전문가가 방대한 데이터 집합에서 의미 있는 통찰을 얻을 수 있도록 도와줍니다.\n\n산업이 빅 데이터의 파워를 활용할수록, Python은 데이터 분석의 중심요소로 남아 있을 것이며 혁신을 주도하고 더 스마트한 의사 결정을 가능하게 합니다. Python의 새로운 기술과 트렌드에 대한 적응력은 빅 데이터 분석 분야에서 매우 중요한 도구로 남을 것을 보장합니다. 빅 데이터를 위해 Python을 수용함으로써 현재의 데이터 문제를 해결할뿐만 아니라 미래 기술 발전을 이용해 지속적인 성장과 경쟁 우위를 확보할 수 있도록 조직을 준비시킬 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n귀하는 소중한 지원을 해주셨습니다. 만약 이 글이 유익하거나 통찰력을 준다면 박수를 부탁드리겠습니다. 제 작품을 계속해서 업데이트하려면 저를 Medium에서 팔로우해주세요. 읽어주시고 글에 참여해주셔서 감사드립니다!","ogImage":{"url":"/TIL/assets/img/2024-07-12-PythonforBigData_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-PythonforBigData_0.png","tag":["Tech"],"readingTime":12},{"title":"리소스가 제한된 시스템을 위한 Quantized Mistral 7B vs TinyLlama 비교분석","description":"","date":"2024-07-12 20:59","slug":"2024-07-12-QuantizedMistral7BvsTinyLlamaforResource-ConstrainedSystems","content":"\n\n<img src=\"/TIL/assets/img/2024-07-12-QuantizedMistral7BvsTinyLlamaforResource-ConstrainedSystems_0.png\" />\n\n프랑스 스타트업인 Mistral이 공개한 오픈 소스 언어 모델 Mistral 7B를 소개하면서 ChatGPT나 claude.ai와 같은 전용 모델이 보여준 놀라운 성능이 오픈 소스 커뮤니티에서도 이용 가능해졌습니다. 이 모델을 리소스가 제한된 시스템에서 사용할 수 있는 가능성을 탐색하기 위해 양자화된 버전은 훌륭한 성능을 유지했습니다.\n\n이전 연구에서 2비트 양자화된 Mistral 7B 모델이 정확성 테스트를 훌륭히 통과했지만, 맥에서 질문에 대한 평균 응답 시간이 약 2분이 걸리는 문제가 있었습니다. 그래서 Llama 2와 동일한 아키텍처와 토크나이저를 사용한 3조 토큰으로 사전학습된 1.1B 언어 모델인 TinyLlama[1]이 출시되었습니다. 이 모델은 더 많은 리소스가 제한된 환경을 위해 고안되었습니다.\n\n이 기사에서는 양자화된 Mistral 7B와 양자화된 TinyLlama 1.1B의 질문-응답 능력의 정확성과 응답 시간 성능을 앙상블 검색 증강 생성 (RAG) 설정에서 비교할 것입니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n목차\n- 활성화 기술\n- 시스템 아키텍처\n- 환경 설정\n- 구현\n- 결과 및 토론\n- 최종 생각\n\n## 활성화 기술\n\n이 테스트는 8GB RAM을 장착한 MacBook Air M1에서 수행됩니다. 계산 및 메모리 자원이 제한되어 있기 때문에 우리는 이 LLM들의 양자화된 버전들을 채택하고 있습니다. 본질적으로 양자화란 모델의 매개변수를 더 적은 비트로 표현하는 것을 의미하며, 이는 모델을 압축하는 효과를 냅니다. 이 압축은 메모리 사용량을 줄이고 더 빠른 실행 시간 및 증가된 에너지 효율성을 가져오지만 정확도를 희생해야 합니다. 이 연구에서는 2비트 양자화된 Mistral 7B Instruct 및 5비트 양자화된 TinyLlama 1.1B Chat 모델을 GGUF 형식으로 사용할 것입니다. GGUF는 모델의 빠른 로딩과 저장을 위해 설계된 이진 형식입니다. 이러한 GGUF 모델을 로드하기 위해 llama-cpp-python 라이브러리를 사용할 것입니다. llama-cpp-python은 llama.cpp 라이브러리에 대한 Python 바인딩입니다.\n\n검색 증가 생성 (RAG)은 LLM의 출력을 향상시키는 과정으로, 응답 생성 이전에 교육 데이터 소스 외부의 신뢰할 수 있는 지식 베이스를 참조하는 것입니다. RAG 응용 프로그램은 문헌에서 관련 문서 조각을 검색하기 위한 검색기 시스템과, 검색된 조각을 컨텍스트로 사용하여 응답을 생성하는 LLM으로 구성됩니다. 검색기는 RAG의 주요 요소이며, 전체 질문-답변 (QA) 시스템의 성능에 상당한 영향을 미칩니다. LLM과 함께 작업할 수 있는 강력한 프레임워크 라이브러리인 LangChain은 재견러(EnsembleRetriever)를 포함하고 있습니다. 재견러는 입력으로 검색기 목록을 받아 상호 순위 조합 알고리즘을 기반으로 결과를 조합하고 재정렬합니다. 서로 다른 알고리즘의 장점을 활용함으로써, 과거에 더 높은 정확도를 달성했다는 것을 보여주었습니다. 본 문서에서 우리는 앙상블을 위해 BM25 검색기와 FAISS 검색기를 0.3:0.7 비율로 결합할 것입니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이러한 지원 요소를 모두 함께 가져오기 위해 시스템 아키텍처를 살펴보겠습니다.\n\n# 시스템 아키텍처\n\n이전 글에서 소개한 모듈식 아키텍처를 재사용할 것입니다. 아래와 같이: \n\n![아키텍처 이미지](/TIL/assets/img/2024-07-12-QuantizedMistral7BvsTinyLlamaforResource-ConstrainedSystems_1.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 QA 시스템에는 세 가지 모듈이 있습니다:\n\n- 첫 번째 모듈은 온라인 PDF 문서를 로드하고 벡터화하는 작업을 포함합니다.\n- 두 번째 모듈은 양자화된 LLM을 로드하고 FAISS 리트리버를 인스턴스화하며 FAISS와 BM25 리트리버로 구성된 앙상블 리트리버 인스턴스를 만드는 작업을 포함합니다. 이후 LLM, 앙상블 및 사용자 정의 프롬프트를 포함하는 리트리버 체인을 생성합니다.\n- 세 번째 모듈은 이 RAG를 위한 도우미 모듈로 작동합니다. 이 모듈은 코사인 유사도 및 모델 응답 시간을 계산하여 질문 세트 전체에서 LLM 성능을客客하게하게 합니다.\n\n구현을 살펴보기 전에, 환경 설정을 먼저 해보겠습니다.\n\n# 환경 설정\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기서 사용하는 Python 버전은 3.10.5입니다. 이 프로젝트를 관리하기 위해 가상 환경을 생성할 거에요. 환경을 생성하고 활성화하기 위해 다음 단계를 따라봐요:\n\n```bash\npython3.10 -m venv mychat\nsource mychat/bin/activate\n```\n\n이제 모든 필요한 라이브러리를 설치하러 가볼까요? (의존 라이브러리도 함께 설치됩니다):\n\n```bash\npip install langchain==0.0.259\npip install faiss-cpu\npip install rank_bm25\npip install sentence_transformers\nCMAKE_ARGS=\"-DLLAMA_METAL=on\" FORCE_CMAKE=1 pip install --upgrade --force-reinstall llama-cpp-python --no-cache-dir\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n최근에 langchain이 리팩토링되었기 때문에 코드에 사용된 특정 버전이 위에 표시되어 있습니다. M1 프로세서에서 하드웨어 가속화를 사용하여 llama-cpp-python 라이브러리를 사용하려면 위의 마지막 설치 명령어는 Metal 지원을 활성화합니다. Metal을 사용하면 연산이 GPU에서 실행됩니다.\n\nfaiss-cpu는 GPU가 아닌 CPU를 사용하여 밀도가 높은 벡터의 유사성 검색 및 클러스터링을 위한 효율적인 라이브러리입니다. Okapi BM25로도 알려진 rank_bm25는 문서가 주어진 검색 쿼리와 얼마나 관련되는지를 추정하는 랭킹 함수입니다. sentence-transformers는 문장 및 기타 것들의 임베딩을 계산하는 간단한 방법을 제공합니다.\n\n이제 코드를 살펴볼 준비가 되었습니다.\n\n# 구현\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저희 시스템 아키텍처에 따르면 LoadVectorize, LLMPerfMonitor 및 주요 모듈이 총 3개의 모듈이 있습니다. 처음 두 모듈은 수정 없이 이전 연구에서 재사용되었습니다. 첫 번째 모듈에서 로드된 샘플 문서는 최근 출시된 600페이지 이상의 가속화 장치 가이드인 SteelHead입니다.\n\nLLM을 로드하기 위해 LlamaCpp 인스턴스를 일반적인 모델 매개변수로 인스턴스화할 것입니다. 모델 GGUF 파일은 이미 미리 다운로드되어 특정 디렉토리에 저장되어 있습니다. Mistral 7B Instruct 또는 TinyLlama Chat 모델을 로드하려면 LlamaCpp 인스턴스의 model_path 속성에 다른 값이 지정되어야 합니다. 그런 다음 FAISS와 BM25 리트리버가 함께 하는 EnsembleRetriever 인스턴스를 생성할 것입니다. 마지막으로 LLamaCpp 인스턴스, EnsembleRetriever 및 프롬프트로 RetrievalQA 체인을 생성할 것입니다.\n\nMistral 프롬프트는 다음 템플릿을 따릅니다:\n\n`s`[INST] 'context' [/INST]`/s`'question'\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nTinyLlama 프롬프트는 다음과 같습니다:\n\n\n|system| 'context' </s> |user| 'question' </s> |assistant|\n\n\n따라서, 아래 코드 목록은 TinyLlama 애플리케이션의 메인 모듈을 나타냅니다.\n\n```python\n# main.py\nfrom langchain.retrievers import EnsembleRetriever\nfrom langchain.chains import RetrievalQA\nfrom langchain.prompts import PromptTemplate\nfrom langchain.llms import LlamaCpp\nimport LoadVectorize\nimport LLMPerfMonitor\nimport timeit\n\n# Prompt template \nqa_template = \"\"\"<|system|>\nYou are a friendly chatbot who always responds in a precise manner. If answer is \nunknown to you, you will politely say so.\nUse the following context to answer the question below:\n{context}</s>\n<|user|>\n{question}</s>\n<|assistant|>\n\"\"\"\n\n# Create a prompt instance \nQA_PROMPT = PromptTemplate.from_template(qa_template)\n\nllm = LlamaCpp(\n    model_path=\"../models/tinyllama_gguf/tinyllama-1.1b-chat-v1.0.Q5_K_M.gguf\",\n    temperature=0.01,\n    max_tokens=2000,\n    top_p=1,\n    verbose=False,\n    n_ctx=2048\n)\n# load doc, vectorize and create retrievers\ndb,bm25_r = LoadVectorize.load_db()\nfaiss_retriever = db.as_retriever(search_type=\"mmr\", search_kwargs={'fetch_k': 3}, max_tokens_limit=1000)\nr = 0.3 # ensemble ratio\nensemble_retriever = EnsembleRetriever(retrievers=[bm25_r,faiss_retriever],weights=[r,1-r])\n# Custom QA Chain \nqa_chain = RetrievalQA.from_chain_type(\n    llm,\n    retriever=ensemble_retriever,\n    chain_type_kwargs={\"prompt\": QA_PROMPT}\n)\n\n# List of questions \nqa_list = LLMPerfMonitor_EN.get_questions_answers()\nprint('model;question;cosine;resp_time')\nfor i,query in enumerate(qa_list[::2]):\n   start = timeit.default_timer()\n   result = qa_chain({\"query\": query})\n   cos_sim = LLMPerfMonitor_EN.calc_similarity(qa_list[i*2+1],result[\"result\"])\n   time = timeit.default_timer() - start # seconds\n   print(f'bm25-{r:.1f}_f-{1-r:.1f};Q{i+1};{cos_sim:.5};{time:.2f}')\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결과 및 토의\n\n응답의 정확성을 이해하기 위해 모델 응답과 전문가의 샘플 답변 사이의 코사인 유사도를 계산했습니다. 예를 들어, 다음은 두 모델에 대해 질문을 제시한 것입니다:\n\n이 질문에 대한 답변은 SteelHead RiOS v9.7입니다. 각 모델의 응답은 아래와 같습니다.\n\n두 LLM이 올바른 코드 버전을 식별할 수 있었습니다. 그러나 둘 다 추가 세부 정보를 포함한 응답이 완전히 정확하지는 않습니다. 특히 TinyLlama에 대해서는 좋은 결과입니다. 10개의 질문에 대한 정확도는 도형 2에 트리맵 차트로 나타냈습니다. Treemap은 내재적 분류 체계를 사용하여 데이터를 효과적으로 표현할 수 있으며 선택한 측정 항목의 크기와 색상 음영을 사용하여 구분할 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래 표는 마크다운 형식으로 변환해 주세요.\n\n이미지는 래이블을 명시해 볼 수는 있지만, Markdown은 이미 HTML인 요소보다 더 적합하고, 깨끗한 마크업을 보여주는 방법입니다. 역할에 따라 Markdown의 사용은 더 효과적일 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n선택한 질문에 대한 결과를 기반으로 보면, TinyLlama는 정확성 측면에서 꽤 잘 수행했습니다. 더 중요한 점은 더 정확한 Mistral 7B 모델보다 훨씬 더 빠르게 응답할 수 있었습니다. 주장대로라면, TinyLlama는 자원이 제한된 시스템에서 좋은 성능을 보이는 모델로 보입니다.\n\n#최종 생각\n\n몇 달 전 Mistral 7B 모델이 소개된 이후, 오픈 소스 LLM은 정확도에서 큰 발전을 이루었습니다. 내부 문서에서 이 모델이 훈련되지 않았더라도, 우리는 검색 보감 생성(RAG) 설정에서 이 능력을 활용할 수 있습니다. 그러나 이러한 대형 모델을 자원이 제한된 환경에서 실행하는 것은 완전히 현실적이지는 않습니다. 이 곳에서 양자화는 모델의 매개변수에 사용된 비트 수를 줄이는 데 도움이 됩니다. 게다가, 자원 풋프린트가 작은 모델들이 이러한 제한된 환경을 위해 소개되었고, TinyLlama가 그러한 모델 중 하나입니다.\n\n이 기사에서 우리는 정량화된 Mistral 7B Instruct와 TinyLlama 1.1B Chat의 정확성과 질문 응답 시간을 비교했습니다. 정확성 측면에서 큰 모델 Mistral 7B가 TinyLlama보다 여전히 우수하지만, 응답 시간 측면에서 TinyLlama의 응답이 Mistral 7B보다 훨씬 빨랐습니다. 한 예에서 TinyLlama의 응답 시간이 Mistral 7B보다 17배 빨랐습니다. 따라서 정확도에 약간의 하락이 허용되는 애플리케이션의 경우, TinyLlama는 자원이 제한된 시스템에 완벽하게 적합합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안녕하세요!\n\n# 참고 자료\n\n[1] https://huggingface.co/TinyLlama/TinyLlama-1.1B-Chat-v1.0\n[2] https://python.langchain.com/docs/modules/data_connection/retrievers/ensemble\n[3] Mistral 7B를 사용하여 앙상블 리트리버의 컨텍스트와 함께 내부 문서 조사하기","ogImage":{"url":"/TIL/assets/img/2024-07-12-QuantizedMistral7BvsTinyLlamaforResource-ConstrainedSystems_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-QuantizedMistral7BvsTinyLlamaforResource-ConstrainedSystems_0.png","tag":["Tech"],"readingTime":11},{"title":"Pandas DataFrame에 데이터 로드하는 방법","description":"","date":"2024-07-12 20:58","slug":"2024-07-12-PandasLoadingdataintoaDataFrame","content":"\n\n<img src=\"/TIL/assets/img/2024-07-12-PandasLoadingdataintoaDataFrame_0.png\" />\n\n판다스는 파이썬 데이터 라이브러리 중 주축에 서 있으며, 데이터 조작을 위한 다양한 함수 보물 묶음을 제공합니다. 핵심은 데이터프레임(DataFrame)으로, 이를 사용하여 테이블 형식의 데이터를 쉽게 저장하고 조작할 수 있습니다.\n\n## 타이타닉 데이터셋 불러오기\n\n다음은 캐글(Kaggle)에서 다운로드할 수 있는 데이터셋 링크입니다. [링크 바로가기](https://www.kaggle.com/competitions/titanic/data?select=train.csv)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![Pandas Loading Data into a DataFrame](/TIL/assets/img/2024-07-12-PandasLoadingdataintoaDataFrame_1.png)\n\n타이타닉 데이터셋은 카글에서 제공하는 클래식한 챌린지로, 비극적인 타이타닉 호에 탑승한 승객들에 대한 데이터를 제공합니다. 이 데이터셋을 Pandas DataFrame으로 로드해보겠습니다:\n\n```python\nimport pandas as pd\n# 타이타닉 데이터셋 로드\ntitanic_df = pd.read_csv('train.csv')\n# 처음 몇 행 확인\nprint(titanic_df.head())\n```\n\n이 코드 조각은 타이타닉 CSV 파일을 DataFrame으로 읽어와 우리가 분석할 데이터를 엿볼 수 있도록 해줍니다.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n더 깊게 파기\n\n이제, 판다스를 사용하여 타이타닉 데이터셋에서 수행할 수 있는 몇 가지 더 많은 작업을 살펴봅시다:\n\n생존율 분석\n\n타이타닉에 관한 가장 감동적인 질문 중 하나는 생존과 관련이 있습니다. 우리는 판다스를 사용하여 다양한 기능에 기반한 생존율을 분석할 수 있습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# 클래스별 생존률 계산\n생존률 = titanic_df.groupby('Pclass')['Survived'].mean()\nprint(생존률)\n```\n\n이 코드는 승객 클래스별로 데이터를 그룹화하고 각 클래스의 평균 생존률을 계산합니다.\n\n기능 엔지니어링: 가족 규모 열 생성\n\n기존 데이터에서 새로운 기능을 만들어 추가 정보를 얻을 수 있습니다. 예를 들어 'FamilySize' 열을 만들어보겠습니다:\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# Create a new column for family size\ntitanic_df['FamilySize'] = titanic_df['SibSp'] + titanic_df['Parch'] + 1\n# Analyze survival rates by family size\nfamily_survival = titanic_df.groupby('FamilySize')['Survived'].mean()\nprint(family_survival)\n```\n\n이 코드 블록은 DataFrame에 새 열을 추가하고, 그런 다음 가족 규모별로 데이터를 그룹화하여 생존율에 영향을 미쳤는지 확인합니다.\n\n로딩 매개변수 조정\n\n데이터를 로드하는 방식을 더 세밀하게 조정해야 할 때가 있습니다. Pandas는 이 과정을 세밀하게 조정할 수 있는 많은 매개변수를 제공합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# 행을 건너뛰고 누락된 값 설정 및 열 제한을 위한 매개변수 조정\ndf = pd.read_csv('train.csv', skiprows=4, na_values=['?'], usecols=['Name', 'Sex', 'Age'])\n```\n\n여러분은 행을 건너뛰고 누락된 값 처리를 할 수 있으며 특정 열만을 선택하여 로드할 수 있습니다.\n\nDataFrame 미리보기\n\n로드된 후에는 모든 것이 올바르게 보이는지 확인하기 위해 DataFrame을 미리보는 것이 좋습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\n# DataFrame의 첫 몇 행 미리보기\nprint(df.head())\n# DataFrame의 마지막 몇 행 미리보기\nprint(df.tail())\n```\n\n이러한 방법들은 데이터를 로드한 후 빠르게 데이터의 개요를 제공해줍니다.\n\n요약 통계량 사용하기\n\n판다스는 요약 통계량을 통해 데이터의 포괄적인 개요를 제공하는 데 뛰어납니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n# Get summary statistics for numerical columns\nprint(df.describe())\n# Get summary statistics for all columns including categorical\nprint(df.describe(include='all'))\n\n\n이 명령어들은 데이터셋의 중심 경향성, 분산 및 형태를 요약하는 기술통계를 생성합니다.\n\n# 동물원 프로젝트의 더 많은 예제\n\n배운 내용을 더 실용적으로 적용해 보겠습니다 — 동물원 프로젝트입니다. 데이터를 로드하고 정리한 다음, 각 동물 종에 대한 평균 식량 필요량을 계산해 봅시다:\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# 동물원 데이터 분석\nzoo_df = pd.read_csv('zoo_data.csv')\n# 데이터 정제\nzoo_df.dropna(inplace=True)\n# 종 별 평균 사료 소비량 계산\naverage_food = zoo_df.groupby('species')['food_per_day'].mean()\nprint(average_food)\n```\n\n메소드 체이닝: 코드를 더 깔끔하게 작성하는 방법\n\n판다스의 메소드 체이닝을 사용하면 한 줄 안에 여러 작업을 쉽게 수행할 수 있습니다. 각 메소드가 다음으로 자연스럽게 이어지는 책의 장이라고 생각해보세요.\n\n```js\nimport pandas as pd\n# 샘플 동물원 데이터\ndata = {\n    'Animal': ['사자', '호랑이', '곰', '얼룩말'],\n    '이름': ['레오', '줄무늬', '발루', '자라'],\n    '나이': [5, 7, 3, 4],\n    '무게': [250, 220, 350, 380]\n}\nzoo_df = pd.DataFrame(data)\n# 메소드 체이닝 예시\nzoo_df.assign(월령=lambda x: x['나이'] * 12).sort_values(by='나이')\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 예에서 우리는 먼저 나이를 월로 변환한 다음 나이를 기준으로 DataFrame을 정렬합니다. 이 모든 작업을 한 표현식으로 처리합니다. 이렇게 하면 코드가 더 깔끔해지고 더 효율적으로 됩니다. \n\n```js\n결과\n  동물 이름   나이   무게  월 단위 나이\n2 Bear   Baloo   3   350       36\n3 Zebra  Zara    4   380       48\n0 Lion   Leo     5   250       60\n1 Tiger  Stripes 7   220       84\n```\n\n데이터 정렬 및 순위 매기기: 데이터 조직화\n\n데이터를 정렬하는 것은 가장 중요한 항목이나 덜 중요한 항목을 분석할 때 중요합니다. 판다스는 이러한 작업을 위해 sort_values() 및 sort_index()를 제공합니다. 반면에 순위 매기기는 데이터에 순위를 할당하여 리더보드와 유사하게 만듭니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# 체중순으로 정렬\nsorted_zoo = zoo_df.sort_values(by='Weight', ascending=False)\n# 나이순으로 동물 순위 매기기\nzoo_df['Age_rank'] = zoo_df['Age'].rank(method='min', ascending=False)\n```\n\n데이터 걸러내기 및 그룹화: 데이터 살펴보기\n\n필터링을 통해 특정 기준을 충족하는 데이터만 볼 수 있습니다. groupby()와 함께 사용되는 그룹화로 카테고리화된 데이터에 대한 작업을 수행할 수 있습니다.\n\n```js\n# 300 파운드 이상의 동물 필터링\nheavy_animals = zoo_df[zoo_df['Weight'] > 300]\n# 동물 종류별로 그룹핑하여 평균 체중 계산\navg_weight_by_animal = zoo_df.groupby('Animal')['Weight'].mean()\n우리의 동물 데이터셋에 대한 통찰을 제공하기 위해 동물공원 프로젝트를 위한 복잡한 코드 예제를 함께 구성해 보겠습니다. 동물원 주민을 필터링, 정렬, 순위 매기는 메소드를 연쇄적으로 적용하여 데이터를 처리할 것입니다.\n# 동물원 프로젝트를 위한 복잡한 메소드 체이닝\n(zoo_df\n  .query('Weight >= 200')\n  .assign(Age_in_months=lambda x: x['Age'] * 12)\n  .sort_values(by=['Animal', 'Age_in_months'], ascending=[True, False])\n  .groupby('Animal')\n  .agg({'Name': 'first', 'Age_in_months': 'max', 'Weight': 'mean'})\n  .rename(columns={'Name': 'Oldest_Animal', 'Age_in_months': 'Oldest_Age', 'Weight': 'Avg_Weight'})\n  .reset_index()\n)\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n결과\n    동물      가장 나이 많은 동물    가장 나이     평균 무게\n0    곰       발루           36            50.0\n1    사자      레오           60           250.0\n2    호랑이    스트라이프     84           220.0\n3    얼룩말    자라           48           380.0\n```\n\n이 블록에서는 200 파운드보다 무겁지 않은 동물을 걸러내고, 나이를 개월로 변환하며, 동물 유형과 나이순으로 정렬하여 동물 유형별로 그룹화한 다음, 가장 나이 많은 동물과 평균 무게를 찾기 위해 집계합니다. 이를 통해 데이터를 명확하고 조직적으로 볼 수 있으며, 추가 분석이나 보고에 이상적입니다.\n\n계속해서 찾아주시기 바랍니다 (-̀ᴗ-́ )و\n\n이전 포스트: `- Pandas: 파이썬에서 데이터 분석의 중추`\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 - Pandas: 데이터 정리 및 변형","ogImage":{"url":"/TIL/assets/img/2024-07-12-PandasLoadingdataintoaDataFrame_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-PandasLoadingdataintoaDataFrame_0.png","tag":["Tech"],"readingTime":9},{"title":"이진 트리 출력용 파이썬 패키지 제작기 재미로 했어요","description":"","date":"2024-07-12 20:57","slug":"2024-07-12-ICreatedAPythonPackageToPrintBinaryTreesForFun","content":"\n\n<img src=\"/TIL/assets/img/2024-07-12-ICreatedAPythonPackageToPrintBinaryTreesForFun_0.png\" />\n\n이번에 이진 트리와 힙을 다루다가, 나만의 트리를 빠르고 쉽게 표시하고 시각화하는 방법이 필요했어요.\n\n그래서 온라인에서 Python 패키지를 검색해보니 몇 개가 그 역할을 해줄 수 있었어요. 그래도 사용하기가 귀찮은 경우가 많았어요.\n\n기존 솔루션을 사용하고 코드를 약간 더 써가며 내 시간을 낭비하는 대신, 개발자들이 흔히 하는 것처럼, 몇 일을 허비해서 처음부터 내가 직접 패키지를 만들기로 결정했죠.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 내 패키지 — print-btree\n\n내 패키지를 설치하는 방법:\n\n```js\npip install print-btree\n```\n\nGithub: https://github.com/zlliu246/print_btree\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 기본 사용 방법\n\n```js\nfrom print_btree import print_btree\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\n# 이진 트리를 만드세요\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\n\nprint_btree(root)\n\n'''\n\n __1__\n |   |\n_2_  3 \n| |    \n4 5   \n\n'''\n```\n\n만약 이진 트리 Node가 .val .left 및 .right를 사용한다면, print_btree 함수를 간단히 가져와 트리를 출력할 수 있습니다\n\n# 노드가 다른 이름을 사용하는 경우 어떻게 하나요?\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nfrom print_btree import print_btree\n\nclass BNode:\n    def __init__(self, value):\n        self.value = value\n        self.left_node = None\n        self.right_node = None\n\nroot = BNode(1)\nroot.left_node = BNode(2)\nroot.right_node = BNode(3)\nroot.left_node.left_node = BNode(4)\nroot.left_node.right_node = BNode(5)\nroot.right_node.right_node = BNode(100)\n\n# we pass in the names here\nprint_btree(root, \n            val='value',\n            left='left_node',\n            right='right_node')\n\n'''\n\n __1__\n |   |\n_2_  3__\n| |    |\n4 5   100\n\n'''\n```\n\n저희 클래스는 다음과 같이 사용합니다:\n\n- 노드 대신 BNode\n- .val 대신 .value\n- .left 대신 .left_node\n- .right 대신 .right_node\n\n문제없이 이 이름들을 print_btree에 전달할 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 일부로 매우 긴 값 이름을 지원합니다\n\n```js\nfrom print_btree import print_btree\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nroot = Node('apple')\nroot.left = Node('pie')\nroot.right = Node('juice')\nroot.left.left = Node('pear')\nroot.left.right = Node('pineapplejuice')\nroot.right.right = Node('durian')\n\nprint_btree(root)\n\n'''\n       ________apple________\n       |                   |\n _____pie_____           juice_\n |           |                |\npear   pineapplejuice       durian\n\n'''\n```\n\n물론, Node(`appleorangepearwithcherriesontop`) 같은 값이 들어있는 경우, 출력된 이진 트리 모양은 여전히 잘못 보일 수 있어요\n\n# 빠른 논리 요약\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n가정하에 이진 트리를 출력해야 한다고 가정합시다.\n\n```python\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nroot = Node('apple')\nroot.left = Node('pie')\nroot.right = Node('juice')\nroot.left.left = Node('pear')\nroot.left.right = Node('pineapplejuice')\nroot.right.right = Node('durian')\n\n'''\n       ________apple________\n       |                   |\n _____pie_____           juice_\n |           |                |\npear   pineapplejuice       durian\n'''\n```\n\n단계 1) 이진 트리를 2D 리스트로 변환하세요.\n\n```python\n# 입력\nroot\n\n# 출력\n[\n    ['apple'],\n    ['pie', 'juice'],\n    ['pear', 'pineapplejuice', None, 'durian']\n]\n\n# 참고: None 값은 순서를 유지하기 위해 유지됩니다.\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테이블 태그를 마크다운 형식으로 변경해주세요.\n\nStep 2) 가장 아래에 있는 목록에서 문자열 생성하기\n\n```js\n['pear', 'pineapplejuice', None, 'durian']\n\n# 다음과 같은 형태로 변환\n\n'pear   pineapplejuice  ?   durian'\n\n# None 값은 ?으로 변환됩니다\n```\n\nStep 3) 이전 문자열에서 값과 일치하는 파이프 |를 포함하는 문자열 생성하기\n\n```js\n# 다음과 같은 문자열에서\n'pear   pineapplejuice  ?   durian'\n\n# 다음을 생성\n' |           |          |    |'\n\n\n# 현재는 트리의 기초만 갖추어져 있습니다\n'''\n |           |         |     |\npear   pineapplejuice  ?   durian\n'''\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\"4단계) 다음으로 아래에 있는 목록에서 문자열 생성하기\n\n```js\n# from \n['pie', 'juice']    # 그리고\n' |        |      |      |  '\n\n# generate\n' _____pie_____           juice_'\n\n\n# 현재 우리가 가지고 있는 것\n'''\n _____pie_____          _juice_\n |           |          |     |\npear   pineapplejuice   ?   durian\n'''\n```\n\n5단계) 루트에 도달할 때까지 단계 3과 4 반복하기\n\n```js\n'''\n _____pie_____          _juice_\n |           |          |     |\npear   pineapplejuice   ?   durian\n'''\n\n# 다음으로\n\n'''\n       |                   |\n _____pie_____          _juice_\n |           |          |     |\npear   pineapplejuice   ?   durian\n'''\n\n# 그리고 아래처럼 변환됩니다\n\n'''\n       ________apple________\n       |                   |\n _____pie_____          _juice_\n |           |          |     |\npear   pineapplejuice   ?   durian\n'''\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결론\n\n이 작은 프로젝트가 이진 트리와 힙 등을 다룰 때 조금이나마 도움이 되었으면 좋겠어요.\n\n만약 버그를 발견하거나 이 패키지에 대한 제안이 있으시다면 언제든지 알려주세요!\n\n응원합니다\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 만약 제가 만든 작품을 지원하고 싶다면\n\n- 제 책을 구입해주세요! — 101가지 파이썬에 대해 몰랐던 것들\n- 구입처: [여기를 클릭하세요](https://payhip.com/b/vywcf)\n- 이 이야기에 박수를 50번 치십시오\n- 여러분의 생각을 댓글로 나누어 주세요\n- 이야기 중에서 가장 좋아하는 부분을 강조해 주세요\n\n감사합니다! 이런 작은 동작들이 큰 도움이 되고, 저는 정말로 감사하게 생각합니다!\n\nYouTube: [여기를 클릭하세요](https://www.youtube.com/@zlliu246)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nLinkedIn: [https://www.linkedin.com/in/zlliu/](https://www.linkedin.com/in/zlliu/)","ogImage":{"url":"/TIL/assets/img/2024-07-12-ICreatedAPythonPackageToPrintBinaryTreesForFun_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-ICreatedAPythonPackageToPrintBinaryTreesForFun_0.png","tag":["Tech"],"readingTime":8}],"page":"11","totalPageCount":34,"totalPageGroupCount":2,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}