{"pageProps":{"posts":[{"title":"배포 후 머신러닝 모델을 관리해야 하는 이유","description":"","date":"2024-07-14 23:49","slug":"2024-07-14-WhyyouneedtobabysitMLmodelsafterdeployment","content":"\n\n![TIL](/TIL/assets/img/2024-07-14-WhyyouneedtobabysitMLmodelsafterdeployment_0.png)\n\n머신 러닝 모델을 배포한 후 모니터링을 중요시하는 이유가 궁금했던 적이 있나요? 매주 매출 예측을 통해 소매점에서 포스트-배포 모델 모니터링 개념을 탐구하는 흥미로운 이야기를 살펴보겠습니다.\n\n이 이야기를 따라가면 실제 월마트 매출 데이터 세트를 사용해볼 것입니다. 매출 예측 모델을 구축하고 이 머신 러닝 모델의 성능을 운영 중에 모니터링할 것입니다. Google Colab 노트북 내에서 운영 환경을 직접 모방하여 간단히 따라할 수 있을 것입니다.\n\n우리는 실제 세계의 변화로 인해 시간이 지남에 따라 머신 러닝 모델이 악화되는 방법과 모니터링 부족이 상당한 재정 손실로 이어질 수 있는 이유를 발견할 것입니다. 그리고 ML 모델의 성능 모니터링에 nannyML을 사용하는 방법과 nannyML에 의해 발명된 확률적 모델이 필요한 이유를 알아볼 것입니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 댄니 씨의 소매점\n\n![댄니 씨의 소매점](/TIL/assets/img/2024-07-14-WhyyouneedtobabysitMLmodelsafterdeployment_1.png)\n\n댄니 씨가 대형 소매점을 열면서 월마트와 유사한 상점이 열립니다. 상점이 성장함에 따라 주간 매출을 예측하고자 합니다. 따라서 댄니 씨는 데이터 과학자를 고용하여 주간 매출을 예측할 수 있는 기계 학습 모델을 구현하고자 합니다. 이를 통해 미래의 트렌드와 매출을 예측하여 재고와 수요를 미리 계획할 수 있습니다.\n\n데이터 과학자는 댄니 씨의 주간 매출을 예측하는 인상적인 모델을 개발하여 테스트 데이터에서 97%의 정확도를 달성했습니다. 이 모델을 배포한 후, 데이터 과학자는 작별 인사를 남기고 갔습니다. :*)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n<img src=\"/TIL/assets/img/2024-07-14-WhyyouneedtobabysitMLmodelsafterdeployment_2.png\" />\n\nMr. Danny initially used the model in production. However, after some time, he noticed the model began to fail and gave incorrect predictions. He incurred a financial loss. Can you guess why the model performance degraded⁉️\n\nMr. Danny, who had limited technical knowledge, hired an ML Engineer. He identified the cause of the previous model failure as data drift. Simply put, data drift happens when real-world data changes in ways the model wasn’t trained for, leading to a decline in model performance.\n\nThe ML Engineer provided two possible reasons for the decline in model performance:\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 단변량 드리프트: 생산 중에 온도 패턴이 갑자기 변하여 쇼핑 패턴이 변경되었습니다. 예를 들어, 자외선 차단제와 탄산음료의 판매량이 증가했습니다.\n- 다변량 드리프트: 고용률, 경기 침체 및 온도 변화가 모두 판매 패턴과 소비자 행동에 영향을 미쳤습니다. 이러한 요인들 사이의 복잡한 관계가 변화함에 따라 다변량 드리프트가 발생했습니다.\n\n자세히 알아보려면 [Hypothesis Testing를 사용한 데이터 드리프트 감지 방법](https://nannyml.com)을 방문해보세요.\n\nML 엔지니어는 모니터링 솔루션의 중심에 데이터 드리프트를 두는 것을 주장했습니다. Danny씨는 이 아이디어를 수용하고 모델 성능 모니터링을 시작했습니다. 그 결과, 그는 매일 모델로부터 다수의 경고를 받았습니다. 이는 그에게 상당한 정신적 스트레스를 야기했습니다.\n\n그러나 Danny씨가 실제 '주간 매출'값 (해당 주의 실제 매장 판매액)을 받자, 대부분의 경고가 잘못되었음을 알게 되었습니다. 경고 중 90% 이상이 잘못되었고, 모델 성능 하락을 올바르게 표시한 경고는 10% 미만이었습니다. 결과적으로, 중앙 모니터링 전략으로 데이터 드리프트에 집중하는 것은 실패로 끝나게 되었습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![이미지](/TIL/assets/img/2024-07-14-WhyyouneedtobabysitMLmodelsafterdeployment_3.png)\n\n마침내 Mr. Danny는 nannyML이라는 라이브러리를 발견했습니다. 이 도구는 그의 ML 모델을 간병하는 역할을 할 수 있어서 지속적으로 성능을 모니터링하고 거짓 경보를 생성하지 않습니다. 그는 정답 데이터에 액세스하지 않고 ML 모델의 성능을 추정하고 데이터 드리프트를 감지할 수 있도록 했습니다.\n\n![이미지](/TIL/assets/img/2024-07-14-WhyyouneedtobabysitMLmodelsafterdeployment_4.png)\n\n![이미지](/TIL/assets/img/2024-07-14-WhyyouneedtobabysitMLmodelsafterdeployment_5.png)\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음으로, 우리는 Kaggle에서 사용할 수 있는 인기 있는 Walmart 판매 데이터 세트를 사용할 것입니다. 댄니 씨가 그의 가게를 위한 유사한 데이터를 가지고 있다고 가정해 봅시다. 우리는 NannyML을 사용하여 모델 모니터링 및 모델 성능 평가 방법을 탐색할 것입니다.\n\n![이미지](/TIL/assets/img/2024-07-14-WhyyouneedtobabysitMLmodelsafterdeployment_6.png)\n\n이것은 2010년 2월 5일부터 2012년 11월 1일까지의 판매를 다루는 기록 데이터입니다. 미국 전역에 위치한 여러 Walmart 매장에서 얻은 데이터가 포함되어 있습니다.\n\n![이미지](/TIL/assets/img/2024-07-14-WhyyouneedtobabysitMLmodelsafterdeployment_7.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 🤖nannyML의 모델 배포 후 모니터링을 위한 사용\n\n우리가 할 일:\n\n- 이 데이터를 사용하여 매장 수요를 예측하여 주간 매출을 예측합니다.\n- 이 데이터에 nannyML 도구를 적용하여 모델 배포 후 모니터링을 결정합니다.\n- 왜 댄니씨의 경우 대부분의 알람이 잘못 트리거되었는지 조사합니다.\n\n# 주간 매출 데이터 소개\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![Image](/TIL/assets/img/2024-07-14-WhyyouneedtobabysitMLmodelsafterdeployment_8.png)\n\n우리는 캐글에서 접근 가능한 널리 사용되는 월마트 판매 데이터셋을 활용할 것입니다. 이 데이터셋은 미국 전역에 위치한 여러 월마트 매장의 과거 판매 데이터를 포함하고 있습니다. 우리의 목표는 소매 수요 예측을 수행하고 주간 판매를 예측하는 것입니다.\n\n![Image](/TIL/assets/img/2024-07-14-WhyyouneedtobabysitMLmodelsafterdeployment_9.png)\n\n이 데이터는 2010년 2월 5일부터 2012년 11월 1일까지의 판매를 다루는 과거 데이터입니다:\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 기능 설명\n\n- Store - 상점 번호\n- Date - 판매 주\n- 주간 판매 - 해당 상점의 매출\n- 휴일 플래그 - 주가 특별한 휴일 주인지 여부 1 - 휴일 주 0 - 비휴일 주\n- 온도 - 판매 일의 온도\n- 연료 가격 - 지역의 연료 비용\n- 소비자 물가 지수 - 현행 소비자 물가 지수\n- 실업률 - 현행 실업률\n- 월, 년, 계절 - 시간 관련 특성\n\n# EDA 및 전처리\n\n일부 기본적인 탐색적 데이터 분석을 수행하고 일부 특성의 분포를 분석해보겠습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![Image 1](/TIL/assets/img/2024-07-14-WhyyouneedtobabysitMLmodelsafterdeployment_10.png)\n\n- CPI와 Fuel_Price는 이중분포를 가지고 있으며, Temperature와 Unemployment는 정규분포를 가지고 있습니다.\n\n![Image 2](/TIL/assets/img/2024-07-14-WhyyouneedtobabysitMLmodelsafterdeployment_11.png)\n\n- Weekly_Sales 분포는 우측으로 치우쳐져 있으며, 이상치가 있습니다.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![image](/TIL/assets/img/2024-07-14-WhyyouneedtobabysitMLmodelsafterdeployment_12.png)\n\n- 겨울 및 휴일에는 주간 매출이 특히 11월과 12월에 높음\n\n![image](/TIL/assets/img/2024-07-14-WhyyouneedtobabysitMLmodelsafterdeployment_13.png)\n\n- 모든 특성의 상관 관계 히트맵은 각 입력 특성 간의 흥미로운 관계를 보여줍니다.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 데이터 전처리 및 이상치 제거\n\n```js\n#이상치 제거\nnum_features = ['Temperature', 'Fuel_Price', 'CPI', 'Unemployment', 'Weekly_Sales']\nfor feature in num_features:\n    q1 = df[feature].quantile(0.25)\n    q3 = df[feature].quantile(0.75)\n    iqr = q3 - q1\n    lower = q1 - 1.5 * iqr\n    upper = q3 + 1.5 * iqr\n    df = df[(df[feature] >= lower) & (df[feature] <= upper)]\n\n# 숫자형 변수 정규화\nsc = StandardScaler()\ndf[num_features] = sc.fit_transform(df[num_features])\ncategoric_columns = ['Store', 'Season']\n# 범주형 특성 인코딩\ndf[categoric_columns] = df[categoric_columns].astype('category')\nencoder = BinaryEncoder(cols=categoric_columns)\ndf = encoder.fit_transform(df)\n```\n\n# 데이터를 nannyML에 맞게 분할 및 처리\n\n일반적으로 데이터는 학습, 검증 및 테스트 세트로 나누지만, nannyML에서는 데이터를 네 부분으로 나눕니다. 모델 모니터링 워크플로우는 제품 데이터를 모방하는 또 다른 세트를 필요로 합니다. 이는 시스템이 성능 하락을 올바르게 감지하고 올바른 알고리즘을 사용하여 어떤 문제가 발생했는지 보고하기 위함입니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![이미지](/TIL/assets/img/2024-07-14-WhyyouneedtobabysitMLmodelsafterdeployment_14.png)\n\n이 삽화는 데이터 분할에 관한 모든 것을 설명합니다. 깊이 이해하려면 코드를 읽어보세요.\n\n참조 세트는 모델 모니터링 문맥에서 사용되는 테스트 세트의 다른 이름입니다. NannyML은 테스트 세트에서 모델의 성능을 기준으로 생산 성능을 측정합니다.\n\n분석 세트는 모델에 의해 생성된 예측을 포함하는 생산 데이터이며 여기서는 실제 값(우리의 경우에는 미래 주의 소매점 매출)은 사용할 수 없습니다.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# 참고 - 여기서는 유효성 데이터를 생성하지 않습니다.\n# 코드 이해를 돕기 위해 위 이미지를 참고하세요.\n\n# 데이터 파티션 생성\ndf['partition'] = pd.cut(\n    df['Date'],\n    bins=[pd.to_datetime('2010-02-12'),\n          pd.to_datetime('2012-02-12'),\n          pd.to_datetime('2012-06-12'),\n          pd.to_datetime('2012-10-26')],\n    right=False,\n    labels=['train', 'test', 'prod']\n)\n# 타겟과 특성 설정\ntarget = 'Weekly_Sales'\nfeatures = [col for col in df.columns if col not in [target, 'Date', 'partition']]\n# 데이터 분할\nX_train = df.loc[df['partition'] == 'train', features]\ny_train = df.loc[df['partition'] == 'train', target]\nX_test = df.loc[df['partition'] == 'test', features]\ny_test = df.loc[df['partition'] == 'test', target]\nX_prod = df.loc[df['partition'] == 'prod', features]\ny_prod = df.loc[df['partition'] == 'prod', target]\r\n```\n\n따라서 최종 데이터 분포 분할은 다음과 같습니다: \n\n- X_train 및 y_train: 2010-02-12 이후 데이터 (4725개)\n- X_test 및 y_test: 2012-02-12 이후 데이터 (945개)\n- X_prod 및 y_prod: 2012-06-12 이후 데이터 (675개)\n\n# 기계 학습 모델 훈련하기\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 LightGBM 회귀 모델을 훈련 데이터에 맞추어, 모델 예측과 기준 예측의 평균 절대 오차(MAE)를 계산하고 훈련 및 테스트 세트에 대한 예측을 수행할 것입니다.\n\n```js\n#모델 훈련\nmodel = LGBMRegressor(random_state=111)\nmodel.fit(X_train, y_train)\n\n# 예측 수행\ny_pred_train = model.predict(X_train)\ny_pred_test = model.predict(X_test)\n# 기준 예측 수행\ny_pred_train_baseline = np.ones_like(y_train) * y_train.mean()\ny_pred_test_baseline = np.ones_like(y_test) * y_train.mean()\n# 훈련, 테스트 및 기준 성능 측정\nmae_train = mean_absolute_error(y_train, y_pred_train).round(4)\nmae_test = mean_absolute_error(y_test, y_pred_test).round(4)\nmae_train_baseline = mean_absolute_error(y_train, y_pred_train_baseline).round(4)\nmae_test_baseline = mean_absolute_error(y_test, y_pred_test_baseline).round(4)\n```\n\n모델을 평가하기 위해, 모델의 훈련 및 테스트 MAE(Mean Absolute Error)를 주간_매출 열의 평균으로 지속적으로 예측하는 기준 모델과 비교할 것입니다.\n\n<img src=\"/TIL/assets/img/2024-07-14-WhyyouneedtobabysitMLmodelsafterdeployment_15.png\" />\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![Training and Testing Data Scatter Plots](/TIL/assets/img/2024-07-14-WhyyouneedtobabysitMLmodelsafterdeployment_16.png)\n\n우리는 두 개의 산점도를 그렸습니다. 하나는 훈련용으로 실제와 예측값을, 또 다른 하나는 테스트 데이터에 대한 예측값을 표현한 것입니다. 두 경우 모두 평균 절대 오차가 비교적 낮은 수준으로 나타났습니다. 이는 모델이 이용 사례에 대해 충분히 잘 작동함을 의미합니다.\n\n![Feature Importance](/TIL/assets/img/2024-07-14-WhyyouneedtobabysitMLmodelsafterdeployment_17.png)\n\n또한 우리는 특성 중요도를 계산했는데, 그 결과로 위 세 가지 중요한 특성은 소비자 물가 지수 (CPI), 실업률, 그리고 연료 가격임을 알게 되었습니다.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# nannyML에서 성능 측정 예측\n\nnannyML은 회귀 및 분류 모델의 성능을 추정하는 데 두 가지 주요 알고리즘을 제공합니다:\n\n우리는 회귀 작업에 대한 직접 손실 추정 알고리즘(DLE)을 사용할 것입니다. DLE는 생성 모델의 성능을 그라운드 트루스 없이 측정하고 RMSE, RMSLE, MAE 등과 같은 다양한 회귀 유사 메트릭을 보고할 수 있습니다.\n\n```js\ny_pred_prod = model.predict(X_prod) #생산 데이터에 대한 주간 매출 예측\n\nreference_df = X_test.copy() # 참조용 테스트 세트\nreference_df['y_pred'] = y_pred_test # 참조 예측\nreference_df['Weekly_Sales'] = y_test # 그라운드 트루스(올바른 타겟)\nreference_df = reference_df.join(df['Date']) # 날짜\nanalysis_df = X_prod.copy() # 특성\nanalysis_df['y_pred'] = y_pred_prod #생산 예측\nanalysis_df = analysis_df.join(df['Date']) # 날짜\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nDLE를 사용하기 위해서는 먼저 기준 성능을 설정하기 위한 참조값을 맞춰야 합니다.\n\n<img src=\"/TIL/assets/img/2024-07-14-WhyyouneedtobabysitMLmodelsafterdeployment_18.png\" />\n\n```js\ndle = nml.DLE(\n    metrics=['mae'],\n    y_true='Weekly_Sales',\n    y_pred='y_pred',\n    feature_column_names=features,\n    timestamp_column_name='Date',\n    chunk_period='w'\n)\n\ndle.fit(reference_df) # 참조(테스트) 데이터에 fit\nestimated_performance = dle.estimate(analysis_df) # 제품 데이터에 대한 추정값\n```\n\n성능 문제가 감지되지 않았으며, 추정된 성능이 임계값 내에 있음을 관찰했습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n미스터 댄니는 미래 주간 판매액에 대한 실제 데이터를 가지고 있지 않지만, 거짓 경고 없이 철저한 모델 성능 보고서를 받고 있습니다.\n\n몇 일 후에 댄니씨가 Weekly_Sales(목표값이 사용 가능해지면) 실제 모델 성능을 계산할 수 있습니다. 이것을 제작 데이터의 실제 성능이라고도 합니다. 아래 셀에서는 실제 성능을 계산하고 이를 nannyML의 추정치와 비교합니다.\n\n```js\ncalculator = nml.PerformanceCalculator(\nproblem_type=\"regression\",\ny_true='Weekly_Sales',\ny_pred=\"y_pred\",\nmetrics=[\"mae\"],\ntimestamp_column_name='Date',\nchunk_period='w'\n)\ncalculator.fit(reference_df)\nrealized_performance = calculator.calculate(analysis_df.assign(Weekly_Sales = y_prod)\n```\n\n<img src=\"/TIL/assets/img/2024-07-14-WhyyouneedtobabysitMLmodelsafterdeployment_19.png\" />\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 위 그림에서 추정 성능이 실제 성능과 밀접하게 일치하여, DLE의 추정이 정확했음을 나타냅니다.\n\n# 왜 잘못된 경보가 발생하는 것일까요?\n\n이제 이 데이터에 대한 단변량 및 다변량 drift를 검토하고, 이것이 Danny씨의 경우에 실패한 이유를 설명하겠습니다.\n\n```js\ndrdc = nml.DataReconstructionDriftCalculator(\ncolumn_names=features,\ntimestamp_column_name='Date',\nchunk_period='d',\n)\n\ndrdc.fit(reference_df)\nmultivariate_data_drift = drdc.calculate(analysis_df)\nmultivariate_data_drift.plot()\n```  \n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![Image](/TIL/assets/img/2024-07-14-WhyyouneedtobabysitMLmodelsafterdeployment_20.png)\n\n다변량 이동 방법을 통해 분석 데이터에 대한 경고를 받았습니다. 이는 모델 성능에 영향을 미치지 않았기 때문에 잘못된 경고입니다.\n\n```js\nudc = nml.UnivariateDriftCalculator(\ncolumn_names=features,\ntimestamp_column_name='Date',\nchunk_period='w',\n)\n\nudc.fit(reference_df)\nunivariate_data_drift = udc.calculate(analysis_df)\nunivariate_data_drift.filter(period='all', metrics='jensen_shannon', column_names=['Unemployment']).plot(kind='distribution')\n```\n\n![Image](/TIL/assets/img/2024-07-14-WhyyouneedtobabysitMLmodelsafterdeployment_21.png)\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n비슷하게, 일변량 드리프트 방법은 우리에게 분석 데이터에 대한 경고를 주었습니다. 그것은 잘못된 경고였습니다. 왜냐하면 모델 성능에 영향을 미치지 않았기 때문입니다. 따라서 잘못된 경보가 발생했음을 보았습니다. 데이터 드리프트 방법이 모니터링 솔루션의 중심에 놓여 있었기 때문입니다.\n\n# 요약\n\n우리는 nannyML이 소매 판매 예측을 위해 실제 월마트 데이터에 적용되는 방법을 탐색했습니다. 소비자 행동과 시장 트렌드의 변화에 대한 도전을 극복했습니다.\n\n모델 모니터링의 중요성을 배웠지만, 효과적인 모니터링을 방해할 수있는 잘못된 경고 문제도 배웠습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기까지 오셨다면, NannyML의 문서를 살펴보시고 여러 사용 사례에서 어떻게 혜택을 받을 수 있는지 확인하는 것을 강력히 추천합니다. 더 많은 정보를 원하신다면 그들의 웹사이트도 방문해보세요.","ogImage":{"url":"/TIL/assets/img/2024-07-14-WhyyouneedtobabysitMLmodelsafterdeployment_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-WhyyouneedtobabysitMLmodelsafterdeployment_0.png","tag":["Tech"],"readingTime":18},{"title":"대기업 취업을 위한 필수 Python 면접 질문 10선","description":"","date":"2024-07-14 23:47","slug":"2024-07-14-10Must-KnowPythonInterviewQuestionsforTechGiants","content":"\n\n## TOP 10 PYTHON INTERVIEW QUESTIONS\n\n회사나 역할에 따라 자주 나오는 인터뷰 질문이 다양하지만, 일반적으로 큰 기술 회사의 인터뷰에서는 기본 지식, 알고리즘, 시스템 디자인 질문이 흔합니다. 이 블로그에서는 대형 기술 회사 인터뷰에서 자주 나오는 10가지 질문을 다루고 있습니다.\n\n# 1. Python의 특징은 무엇인가요?\n\n- 배우기 쉽다\n- 객체지향 프로그래밍\n- 해석형 언어\n- 강력한 표준 및 서드 파티 라이브러리\n- 크로스 플랫폼\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 2. Python 코드는 어떻게 실행되나요?\n\n- 해석기는 Python 코드를 읽고 구문 또는 형식 오류를 확인합니다.\n- 오류가 없다면 해석기는 코드를 바이트 코드로 변환합니다.\n- 이 바이트 코드는 Python 가상 머신에 실행을 위임합니다. 실행 중 오류가 발생하면 프로세스가 중단됩니다; 그렇지 않으면 결과가 표시됩니다.\n\n![](/TIL/assets/img/2024-07-14-10Must-KnowPythonInterviewQuestionsforTechGiants_0.png)\n\n# 3. 이터레이터와 제너레이터의 차이점은 무엇인가요?\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 반복자(Iterator): `next()` 작업을 지원하는 객체로, 일련의 요소를 포함합니다. `next()` 메서드는 요소를 하나씩 반환하고 모든 요소가 반환된 경우 `StopIteration`을 발생시킵니다. 반복자는 `__iter__()`와 `__next__()` 메서드를 구현합니다.\n- 생성자(Generator): `yield` 키워드를 사용하여 생성자 객체를 반환하는 함수입니다. 이 객체는 실행을 일시 중단하고 다시 시작할 수 있습니다. 생성자에서 `next()`를 호출하면 `yield` 문에 도달할 때까지 실행이 계속되며, 생성자는 요청 시 값을 생성하여 메모리를 절약하고 효율성을 높일 수 있습니다.\n- 차이점: 생성자는 함수 및 `yield` 키워드를 사용하여 정의된 특별한 반복자로, 내장 `iter()` 함수로 생성된 표준 반복자와 달리 호출 가능한 일반 함수이며 값들을 순차적으로 생성합니다.\n\n# 4. `yield`를 사용하는 방법\n\n- `yield`는 함수에서 생성자를 반환하는 Python 키워드입니다. 생성자는 모든 데이터를 한 번에 메모리에 저장하지 않기 때문에 대규모 데이터나 복잡한 구조에 유용한 지연 계산을 허용합니다.\n- `yield`를 포함하는 함수를 **생성자 함수(Generator function)**라고 합니다. 값의 시리즈를 생성하고 각 호출 시 이전 상태에서 실행을 계속합니다.\n\n```js\n# 원래 방법: 대형 목록은 많은 메모리를 사용합니다\ndef create_numbers(n):\n    num_list = []\n    for i in range(n):\n        num_list.append(i)\n    return num_list\n\n# yield 사용: 메모리를 효율적으로 사용하는 데이터 스트림 생성\ndef create_numbers(n):\n    for i in range(n):\n        yield i\n\nnums = create_numbers(5)\nfor num in nums:\n    print(num)\n```  \n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 5. 파이썬2와 파이썬3의 차이점은 무엇인가요?\n\n- 정수 타입: 파이썬2는 int와 long을 구분하지만, 파이썬3는 구분하지 않습니다.\n- 문자열 포매팅: 파이썬3는 포매팅을 위해 f-문자열을 도입했습니다.\n- 정수 나눗셈: 파이썬2는 정수 나눗셈을 수행하고, 파이썬3는 부동 소수점을 반환합니다.\n- 인코딩: 파이썬2는 기본적으로 ASCII를 사용하며, 파이썬3는 유니코드를 사용합니다.\n- 출력문: 파이썬2는 `print`를 사용하고, 파이썬3는 `print()`를 사용합니다.\n- `range()` 함수: 파이썬2는 리스트를 반환하지만, 파이썬3는 이터레이터를 반환합니다.\n- `input()`과 `raw_input()`: 파이썬2는 문자열에 대해 `raw_input()`을 사용하고, 파이썬3는 `input()`을 사용합니다.\n\n# 6. 파이썬은 어떻게 메모리를 관리하나요?\n\n참조 카운팅과 가비지 콜렉션:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 참조 카운팅은 객체 참조를 추적합니다. 카운트가 제로에 도달하면 객체가 삭제됩니다.\n- 가비지 컬렉션은 순환 참조를 처리하며, 객체를 수명에 따라 세대로 나누고 그에 따라 쓰레기를 수거합니다.\n\n이러한 메커니즘들은 Python이 메모리를 자동으로 관리할 수 있게 하며, 개발자들이 메모리 세부사항에 집중하는 대신 논리에 집중할 수 있게 합니다.\n\n# 7. 깊은 복사와 얕은 복사의 차이는 무엇인가요?\n\n- 얕은 복사: 객체의 외부 레이어 멤버(기본 데이터 유형 및 문자열)를 복사합니다. 내부 멤버(중첩된 객체 또는 참조)는 참조에 의해 복사되어 새로운 인스턴스를 생성하지 않습니다. 내부 멤버의 변경은 원본 및 복사된 객체 양쪽에 영향을 줍니다.\n- 깊은 복사: 전체 객체를 재귀적으로 복사하며, 모든 내부 멤버와 중첩된 객체를 포함한 새로운 메모리에 새 인스턴스를 생성합니다. 원본 객체의 내부 멤버를 변경해도 복사된 객체에 영향을 미치지 않습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 8. 클로저란 무엇인가요?\n\n클로저는 내부 함수가 외부 함수의 변수에 의존하고, 외부 함수가 내부 함수를 반환할 때 생성됩니다. 이는 외부 함수가 실행을 마친 후에도 내부 함수가 이러한 변수에 액세스를 유지할 수 있게 합니다.\n\n```js\ndef out_function(y):\n    def in_function(x):\n        return x + y\n    return in_function\n\nf = out_function(5)\nprint(f(3))  # 8\n```\n\n# 9. `is not`과 `!=`의 차이점은 무엇인가요?\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- `!=`: 두 객체가 서로 다른 값을 가지는지 확인합니다.\n- `is not`: 두 객체가 메모리에서 서로 다른지 확인합니다.\n\n# 10. 람다 함수란 무엇인가요?\n\n람다 함수 또는 익명 함수는 이름이 없는 한 줄짜리 함수입니다. 여러 매개변수를 가질 수 있지만 표현식은 하나뿐입니다.\n\n최신 AI 이야기를 탑재하려면 Substack에서 저희와 연락을 유지하세요. 함께 AI의 미래를 함께 만들어 봅시다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파이썬 이야기를 업데이트 받으려면 Substack에서 우리와 함께하세요. 함께 파이썬을 배워봐요!","ogImage":{"url":"/TIL/assets/img/2024-07-14-10Must-KnowPythonInterviewQuestionsforTechGiants_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-10Must-KnowPythonInterviewQuestionsforTechGiants_0.png","tag":["Tech"],"readingTime":6},{"title":"Sentinel 2 데이터를 이용한 Python으로 EVI 지도 생성하는 방법","description":"","date":"2024-07-14 23:46","slug":"2024-07-14-ProduceEVImapswithPythonSentinel2Data","content":"\n\n# TL;TR\n\n증강 식물 지수 (EVI)는 원격 감지에서 널리 사용되는 분광 지수로, 위성 영상을 통해 식물 건강 및 영역을 평가하는 데 사용됩니다. 일반화된 차이 식물 지수 (NDVI)를 개선하여 대기 영향을 최소화하고 수관 구조 변화 및 밀집 식물 지역에 대한 민감도를 향상시켰습니다.\n\n## EVI의 주요 특징:\n\n- 식물에 대한 민감도: EVI는 대기 영향을 최소화하고 수관 특성에 대한 민감도를 증가시킴으로써 특히 밀집 식물 지역에서 효과적으로 작동하도록 설계되었습니다.\n- 공식: EVI 공식은 빨강, 근적외선 (NIR), 파랑 분광대를 포함하여 식물에 대한 민감도를 개선합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/TIL/assets/img/2024-07-14-ProduceEVImapswithPythonSentinel2Data_0.png\" />\n\n여기서:\n\n- NIR은 근적외선 대역의 반사율입니다.\n- Red는 빨간 대역의 반사율입니다.\n- Blue는 파란 대역의 반사율입니다.\n- G는 이득 요소입니다 (기본값: 2.5).\n- C1 및 C2는 대기의 영향을 최소화하기 위한 계수입니다 (기본값: 각각 6 및 7.5).\n- L은 수관 배경 조정 요소입니다 (기본값: 1).\n\n값의 범위: EVI 값은 일반적으로 -1에서 1 사이의 범위를 갖습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 높은 값은 밀도가 높은 식물을 나타냅니다.\n- 0 또는 음수에 가까운 값은 비식물 또는 희소식물이 자리 잡은 지역을 나타냅니다.\n\n## 응용:\n\n- 식물 모니터링: EVI는 식물 동태를 모니터링하는 데 널리 사용되며 성장 패턴, 건강 평가, 그리고 환경 요소 또는 인간 활동으로 인한 변화 감지에 도움이 됩니다.\n- 토지 이용 및 토지 피복 매핑: 특히 식물로 지배되는 토지 이용 유형을 매핑하고 분류하는 데 도움이 됩니다.\n- 생태학 연구: 식물 분포를 분석하는 데 유용하며, 생물 다양성 평가 및 서식지 매핑에 활용됩니다.\n\n## 장점:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 민감도 향상: NDVI와 비교하여 밀집 식물 지역의 변화에 대한 감도를 향상시켰습니다.\n- 대기 보정: 대기 간섭을 줄이기 위한 계수를 포함하여 대기 보정을 통해 전 세계 및 지역 규모의 응용 프로그램에 더 견고하게 만들었습니다.\n\n## 고려 사항:\n\n- 데이터 요구 사항: 일반적으로 중고해상도 위성 플랫폼에서 널리 사용되는 빨강, NIR 및 파랑 밴드를 갖춘 다중 스펙트럼 위성 영상이 필요합니다.\n- 매개변수 민감도: 계수 G, C1, C2 및 L의 선택에 민감하며 특정 환경 조건 및 연구 목표에 따라 조정이 필요할 수 있습니다.\n\n## 선행 조건:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 여정에서는 다음을 설치해야 합니다:\n\n- Python 3.10+\n- 시각화를 위한 QGIS 3.X.X +\n\n또한 다음이 필요합니다:\n\n- Copernicus 사이트에서 다운로드할 데이터 세트. 2024년 2월 27일 센티넬 2 2A 이미지로 작업할 예정입니다 (이미지 참조: T36QUL_20240227T082911).\n- Copernicus 플랫폼에서 다운로드할 수 있습니다; 데이터 다운로드에 대한 문서를 확인할 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Sentinel-2 데이터를 활용한 실제 적용:\n\n## 1. 저장소 복제\n\n분류 스크립트 및 학습 샘플을 가져오세요:\n\n```js\ngit clone https://github.com/kokatic/remote_sensing\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이렇게 작성하시면 됩니다 :\n\n\n<img src=\"/TIL/assets/img/2024-07-14-ProduceEVImapswithPythonSentinel2Data_1.png\" />\n\n내 레포지토리(/data/)에 데이터 폴더를 추가했습니다. 이 폴더에는 2024년 4월 30일 에르 우에드 지역의 Sentinel-2 데이터가 포함되어 있습니다. 기준 이미지는 T32SKC_20240430T102021이며, 밴드 4와 8을 포함하고 있습니다.\n\n## 2. 가상 환경 생성 및 필수 모듈 설치\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n현재 작업 폴더 디렉토리에서 명령 줄 인터페이스를 엽니다:\n\n```js\npython -m venv venv\n```\n\n그런 다음 가상 환경을 활성화합니다:\n\nWindows용 (CMD)에서:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\nvenv\\Scripts\\activate # Linux의 경우: source venv/bin/activate\n\n\n필요한 패키지 설치 후:\n\n\npip install -r requirements.txt\n\n\n## 3. 스크립트 실행\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n동일한 폴더에서 스크립트를 실행하려면 터미널 또는 명령 프롬프트를 열고 스크립트가 있는 폴더로 이동한 다음 다음 명령을 실행하세요:\n\n```js\nimport rasterio\nimport numpy as np\n\ndef calculate_evi(red_band_path, nir_band_path, blue_band_path, output_path):\n    try:\n        # rasterio 데이터셋으로 빨간색, NIR, 파란색 밴드 열기\n        with rasterio.open(red_band_path) as red_dataset, \\\n             rasterio.open(nir_band_path) as nir_dataset, \\\n             rasterio.open(blue_band_path) as blue_dataset:\n\n            # rasterio 데이터셋에서 데이터 읽기\n            red = red_dataset.read(1, masked=True).astype('float32')\n            nir = nir_dataset.read(1, masked=True).astype('float32')\n            blue = blue_dataset.read(1, masked=True).astype('float32')\n\n            # EVI 계산\n            G = 2.5\n            C1 = 6\n            C2 = 7.5\n            L = 1\n            epsilon = 1e-6  # 0으로 나누기를 피하기 위한 작은 엡실론 값\n            denominator = nir + C1 * red - C2 * blue + L\n            evi = np.where(denominator != 0, G * ((nir - red) / denominator), np.nan)\n\n            # EVI 값을 [-1, 1] 범위로 클리핑\n            evi = np.clip(evi, -1, 1)\n\n            # EVI 출력을 위한 프로필 업데이트\n            profile = red_dataset.profile\n            profile.update(dtype=rasterio.float32, count=1, compress='lzw')\n\n            # 새 GeoTIFF 파일에 EVI 결과 작성\n            with rasterio.open(output_path, 'w', **profile) as dst:\n                dst.write(evi.astype(np.float32), 1)\n\n    except Exception as e:\n        print(f\"오류가 발생했습니다: {e}\")\n\n# 예시 파일 경로\nred_band_path = 'data/Toshka/S2A_MSIL2A_20240227T082911/T36QUL_20240227T082911_B04_10m.jp2'  # 빨간색 밴드\nnir_band_path = 'data/Toshka/S2A_MSIL2A_20240227T082911/T36QUL_20240227T082911_B08_10m.jp2'  # 근적외선 밴드\nblue_band_path = 'data/Toshka/S2A_MSIL2A_20240227T082911/T36QUL_20240227T082911_B02_10m.jp2'  # 파란색 밴드\noutput_path = 'output/evi.tif'  # EVI 출력 파일\n\ncalculate_evi(red_band_path, nir_band_path, blue_band_path, output_path)\n```\n\n스크립트를 실행한 후 output/ 폴더에 EVI 출력물을 찾을 수 있습니다:\n\n![EVI 출력물](/TIL/assets/img/2024-07-14-ProduceEVImapswithPythonSentinel2Data_2.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n3- 결과 확인: 시각화와 분석\n\n- EVI 출력 파일 (evi.tif)을 QGIS에 로드합니다.\n- 더 밀집한 식물 상층을 나타내는 더 높은 EVI 값의 시각화를 위해 적합한 컬러 팔레트를 적용합니다.\n- EVI 값에 기반하여 관심 영역을 강조하기 위해 시각화 설정을 조정하여 식물 건강 평가 및 토지 피복 맵핑을 지원합니다.\n\n![이미지1](/TIL/assets/img/2024-07-14-ProduceEVImapswithPythonSentinel2Data_3.png)\n\n![이미지2](/TIL/assets/img/2024-07-14-ProduceEVImapswithPythonSentinel2Data_4.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결론\n\n요약하자면, 향상된 식물지수(EVI)는 원격 감지 응용 프로그램에 강력한 도구로, 식물 역학 및 건강 평가에 대한 감도를 향상시켜줍니다. Sentinel-2 위성 이미지와 Python 및 QGIS와 같은 컴퓨터 도구를 활용하여 연구원 및 실무자는 효과적으로 식물 변화를 모니터링하고 토지 피복 유형을 분류하며 생태학 연구 및 환경 관리에 기여할 수 있습니다. 더 자세한 내용이나 문의 사항이 있으시면 언제든지 댓글을 남기거나 직접 연락해주세요.\n\n# 팔로우\n\n- 내 랜딩 페이지\n- 내 Youtube 채널\n- 내 SaaS 서비스\n- 내 GitHub","ogImage":{"url":"/TIL/assets/img/2024-07-14-ProduceEVImapswithPythonSentinel2Data_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-ProduceEVImapswithPythonSentinel2Data_0.png","tag":["Tech"],"readingTime":8},{"title":"코드 효율성을 높이는 7가지 파이썬 메모리 최적화 비법","description":"","date":"2024-07-14 23:44","slug":"2024-07-14-7PythonMemoryOptimizationTricksToEnhanceYourCodesEfficiency","content":"\n\n## 파이썬\n\n프로젝트가 점점 커지면서, 컴퓨팅 자원을 효율적으로 관리하는 것은 불가피한 요구사항입니다.\n\n안타깝게도, 특히 C나 C++과 같은 저수준 언어와 비교할 때 파이썬은 메모리 효율적이지 못한 것으로 보입니다.\n\n지금 프로그래밍 언어를 바꾸는 것이 좋을까요?\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n물론이죠.\n\n사실, 파이썬 프로그램의 메모리 사용량을 최적화하는 많은 방법이 있습니다. 훌륭한 모듈과 도구부터 고급 데이터 구조와 알고리즘까지 다양한 방법이 있어요.\n\n이 기사는 파이썬의 내장 메커니즘에 초점을 맞추고 7가지 기본적이지만 효과적인 메모리 최적화 요령을 소개할 거에요. 이들을 숙달하면 파이썬 프로그래밍 스킬이 상당히 향상될 거예요.\n\n# 1. 클래스 정의에서 __slots__ 사용하기\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파이썬은 동적 타이핑 언어로 객체 지향 프로그래밍에 있어 유연성을 가지고 있습니다. 좋은 예시로 파이썬 클래스에 런타임에서 추가적인 속성과 메서드를 넣는 기능이 있습니다.\n\n예를 들어, 아래 코드는 'Author'라는 클래스를 정의합니다. 원래 'name'과 'age'라는 두 속성이 있었지만 나중에 손쉽게 하나를 더 추가할 수 있습니다:\n\n```python\nclass Author:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\nme = Author('Yang Zhou', 30)\nme.job = 'Software Engineer'\nprint(me.job)\n# Software Engineer\n```\n\n그러나 동전에는 양면이 있다고 하죠. 이 유연성은 내부에서 더 많은 메모리를 낭비합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파이썬의 클래스의 모든 인스턴스는 인스턴스 변수를 저장하는 특별한 사전(__dict__)을 유지합니다. 이 사전은 해시 테이블 기반의 구현 때문에 메모리 효율이 좋지 않기 때문에 상당한 양의 메모리를 소비합니다.\n\n대부분의 경우에는 인스턴스의 변수나 메서드를 런타임에 변경할 필요가 없으며, 클래스 정의 이후에는 __dict__가 변경되지 않습니다. 따라서 __dict__ 사전을 유지하는 것을 피하는 것이 좋습니다.\n\n파이썬은 이를 위해 마법처럼 동작하는 속성을 제공합니다: __slots__.\n\n이는 클래스의 모든 유효한 속성 이름을 지정하여 화이트리스트로 작동합니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nclass Author:\n    __slots__ = ('name', 'age')\n\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\nme = Author('양주', 30)\nme.job = '소프트웨어 엔지니어'\nprint(me.job)\n# AttributeError: 'Author' object has no attribute 'job'\n```\n\n위의 코드에서 보듯이, 런타임 중에 job 속성을 더 이상 추가할 수 없습니다. 왜냐하면 __slots__ 화이트리스트에서는 name과 age 속성만을 정의했기 때문입니다.\n\n이론적으로 속성이 지금 고정되어 있기 때문에, Python은 더 이상 이를 위한 사전을 유지할 필요가 없습니다. __slots__에서 정의된 속성에 필요한 메모리 공간만 할당하면 됩니다.\n\n이것이 실제로 작동하는지 여부를 확인하기 위해 간단한 비교 프로그램을 작성해 봅시다:\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport sys\n\nclass Author:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\nclass AuthorWithSlots:\n    __slots__ = ['name', 'age']\n\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n# Creating instances\nme = Author('Yang', 30)\nme_with_slots = AuthorWithSlots('Yang', 30)\n\n# Comparing memory usage\nmemory_without_slots = sys.getsizeof(me) + sys.getsizeof(me.__dict__)\nmemory_with_slots = sys.getsizeof(me_with_slots)  # __slots__ classes don't have __dict__\n\nprint(memory_without_slots, memory_with_slots)\n# 152 48\nprint(me.__dict__)\n# {'name': 'Yang', 'age': 30}\nprint(me_with_slots.__dict__)\n# AttributeError: 'AuthorWithSlots' object has no attribute '__dict__'\n```\n\n위 코드에서 볼 수 있듯이, __slots__를 사용하기 때문에 me_with_slots 인스턴스는 __dict__ 사전이 없습니다. 이는 me 인스턴스와 비교하여 추가 사전을 유지해야 하는 리소스를 효과적으로 절약합니다.\n\n# 2. Generators 사용\n\nGenerators는 Python에서 리스트의 게으른 평가 버전입니다.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그들은 요소를 생성하는 공장처럼 작동합니다: 모든 항목을 한꺼번에 계산하는 대신 next() 메서드가 호출될 때마다 항목을 생성합니다.\n\n그렇기 때문에 대규모 데이터셋을 처리할 때 매우 메모리를 효율적으로 사용합니다.\n\n```js\ndef number_generator():\n    for i in range(100):\n        yield i\n\nnumbers = number_generator()\nprint(numbers)\n# <generator object number_generator at 0x104a57e40>\nprint(next(numbers))\n# 0\nprint(next(numbers))\n# 1\n```\n\n위 코드는 제너레이터를 작성하고 사용하는 기본적인 예제를 보여줍니다. yield 키워드가 제너레이터의 정의 핵심입니다. 이를 적용하면 항목 i는 next() 메서드가 호출될 때에만 생성됩니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 제너레이터와 리스트를 비교해보면 어떤 쪽이 더 메모리를 효율적으로 사용하는지 살펴봅시다:\n\n```python\nimport sys\n\nnumbers = []\nfor i in range(100):\n    numbers.append(i)\n\ndef number_generator():\n    for i in range(100):\n        yield i\n\nnumbers_generator = number_generator()\nprint(sys.getsizeof(numbers_generator))\n# 112\nprint(sys.getsizeof(numbers))\n# 920\n```\n\n위 프로그램의 결과는 제너레이터를 사용하면 메모리 사용량을 크게 절약할 수 있다는 사실을 입증합니다.\n\n그런데, 리스트 컴프리헨션의 대괄호를 괄호로 변환하면 제너레이터 표현식이 됩니다. 이것이 파이썬에서 제너레이터를 정의하는 더 간단한 방법입니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nimport sys\n\nnumbers = [i for i in range(100)]\nnumbers_generator = (i for i in range(100))\n\nprint(sys.getsizeof(numbers_generator))\n# 112\nprint(sys.getsizeof(numbers))\n# 920\n```\n\n# 3. 대용량 파일 처리를 위한 메모리 맵 파일 지원 활용\n\n메모리 맵 파일 I/O, 줄여서 \"mmap\"이라고도 불리는 것은 OS 수준의 최적화입니다.\n\n간단히 말해서, mmap 기술을 사용하여 파일을 메모리 맵핑하면 현재 프로세스의 가상 메모리 공간에 파일의 맵핑이 직접 생성되어 파일 전체를 메모리에 로드하는 대신 처리합니다.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테이블 태그를 Markdown 형식으로 변경할 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nimport mmap\n\nwith open('test.txt', \"r+b\") as f:\n    # 파일을 메모리 매핑하여 사용할 수 있습니다. 크기 0은 전체 파일을 의미합니다.\n    with mmap.mmap(f.fileno(), 0) as mm:\n        # 표준 파일 메서드를 사용하여 내용 읽기\n        print(mm.read())\n        # 슬라이스 표기법을 사용하여 내용 읽기\n        snippet = mm[0:10]\n        print(snippet.decode('utf-8'))\n```\n\n위에서 보여진 대로, Python은 메모리 매핑된 파일 I/O 기술의 사용을 편리하게 만듭니다. 우리가 해야 할 일은 단지 mmap.mmap() 메서드를 적용하고, 표준 파일 메서드나 슬라이싱 표기법을 통해 개방된 객체를 처리하는 것뿐입니다.\n\n# 4. 전역 변수 사용 최소화\n\n전역 변수는 글로벌 스코프를 갖기 때문에 프로그램이 실행되는 동안 메모리에 유지됩니다.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n전역 변수가 큰 데이터 구조를 보유하는 경우 프로그램 수명 전체 동안 메모리를 점유하므로 비효율적인 메모리 사용으로 이어질 수 있습니다.\n\n파이썬 코드에서 전역 변수 사용을 최소화해야 합니다.\n\n# 5. 논리 연산자의 단축 평가 활용\n\n이 꿀팁은 섬세해 보일 수 있지만, 스마트하게 사용하면 프로그램의 메모리 사용량을 중대하게 절약할 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예를 들어, 반환된 boolean 값에 따라 최종 결과를 얻는 간단한 코드 스니펫이 있습니다:\n\n```js\nresult_a = expensive_function_a()\nresult_b = expensive_function_b()\nresult = result_a if result_a else result_b\n```\n\n위의 코드는 동작하지만 실제로 두 가지 메모리 비효율적인 함수를 실행합니다.\n\n동일한 결과를 얻는 더 스마트한 방법은 다음과 같습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nresult = expensive_function1() or expensive_function2()\n```\n\n위 코드의 논리 연산자는 단락 평가 규칙을 따르기 때문에, expensive_function1()이 True 인 경우, 위 코드의 expensive_function2()는 실행되지 않습니다. 이는 불필요한 메모리 사용을 절약할 수 있습니다.\n\n# 6. 데이터 유형 신중히 선택하기\n\n고급 Python 개발자는 데이터 유형을 신중하고 정확하게 선택할 것입니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n특정 상황에서는 다른 데이터 유형을 사용하는 것이 다른 것보다 더 메모리를 효율적으로 사용합니다.\n\n## 튜플은 리스트보다 메모리를 효율적으로 사용합니다\n\n튜플은 변경할 수 없는(생성 후에 변경할 수 없음) 특성 때문에 Python은 메모리 할당 측면에서 최적화를 할 수 있습니다.\n\n하지만, 리스트는 변경 가능하기 때문에 잠재적인 수정 사항을 수용하기 위해 추가 공간이 필요합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport sys\n\nmy_tuple = (1, 2, 3, 4, 5)\nmy_list = [1, 2, 3, 4, 5]\n\nprint(sys.getsizeof(my_tuple))\n# 80\nprint(sys.getsizeof(my_list)) \n# 120\n```\n\n위 코드 조각에서 보듯이, 같은 요소를 포함하고 있어도 튜플인 my_tuple이 리스트보다 적은 메모리를 사용합니다.\n\n따라서, 데이터를 생성한 후에 변경할 필요가 없다면 리스트 대신 튜플을 사용하는 것이 좋습니다.\n\n## 배열은 리스트보다 메모리를 더 효율적으로 사용합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파이썬의 배열은 요소들이 동일한 데이터 유형이어야 합니다(예: 모두 정수 또는 모든 부동 소수점 수), 그러나 리스트는 다른 유형의 객체를 저장할 수 있기 때문에 더 많은 메모리가 필요합니다.\n\n따라서 배열을 사용하면 리스트 요소가 모두 동일한 유형인 경우 더 메모리 효율적입니다:\n\n```python\nimport sys\nimport array\n\nmy_list = [i for i in range(1000)]\n\nmy_array = array.array('i', [i for i in range(1000)])\n\nprint(sys.getsizeof(my_list))  \n# 8856\nprint(sys.getsizeof(my_array)) \n# 4064\n```\n\n## 우수한 데이터 과학 모듈이 내장 데이터 유형보다 효율적입니다\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파이썬은 데이터 과학의 주요 언어입니다. NumPy와 Pandas와 같은 강력한 타사 모듈과 도구들이 더 많은 데이터 유형을 제공합니다.\n\n만약 NumPy가 제공하는 많은 기능이 필요하지 않고 단순한 1차원 숫자 배열만 필요하다면, 파이썬의 내장 배열이 좋은 선택일 수 있습니다.\n\n하지만 복잡한 행렬 조작이 필요한 경우에는, NumPy가 제공하는 배열을 사용하는 것이 모든 데이터 과학자에게 첫 번째이자 아마도 최상의 선택일 것입니다.\n\n# 7. 동일한 문자열에 문자열 인터닝 기술을 적용\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n많은 개발자들을 혼란스럽게 만들 수 있는 코드는 다음과 같습니다:\n\n```js\na = 'Y'*4096\nb = 'Y'*4096\na is b\nTrue\nc = 'Y'*4097\nd = 'Y'*4097\nc is d\nFalse\n```\n\nis 연산자는 두 변수가 메모리에서 동일한 객체를 참조하는지 확인하는 데 사용됩니다. 이는 == 연산자와는 다릅니다. == 연산자는 두 객체의 값을 비교합니다.\n\n그래서 a is b는 True를 반환하지만, c is d는 False를 반환하는 이유는 무엇인가요?\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파이썬에는 숨겨진 보석이 있습니다 — 문자열 인터닝 기술이 그것입니다.\n\n값이 같은 몇 개의 작은 크기 문자열들이 있다면, 파이썬은 암묵적으로 그들을 인터닝하고 메모리에서 동일한 객체를 참조합니다.\n\n작은 문자열을 정의하는 마법 숫자는 4096입니다.\n\nc와 d의 길이가 4097이므로, 두 개의 객체가 메모리에 있기 때문에, 암묵적인 문자열 인터닝은 일어나지 않습니다. 따라서 c is d를 실행하면 False를 얻습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n문자열 인터닝은 메모리 사용량을 최적화하는 강력한 기술입니다. 명시적으로 수행하려면 sys.intern() 메서드를 활용해야 합니다:\n\n```js\n>>> import sys\n>>> c = sys.intern('Y'*4097)\n>>> d = sys.intern('Y'*4097)\n>>> c is d\nTrue\n```\n\n그리고, 문자열 인터닝 외에도 Python은 작은 정수에 대해서도 인터닝 기법을 적용합니다. 이를 메모리 최적화 목적으로 활용할 수도 있습니다.\n\n독서해 주셔서 감사합니다. ❤️ 마음에 드셨다면, 연결하고 싶습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nX | Linkedin | Medium \n\n파이썬 메모리 관리 메커니즘에 관한 인터뷰 질문:","ogImage":{"url":"/TIL/assets/no-image.jpg"},"coverImage":"/TIL/assets/no-image.jpg","tag":["Tech"],"readingTime":14},{"title":"Python에서 Factory Method 패턴 사용하는 방법","description":"","date":"2024-07-14 23:43","slug":"2024-07-14-FactoryMethodpatterninPython","content":"\n\n디자인 패턴은 미래에 이를 유지하는 것이 더 쉬운 방식으로 반복되는 여러 가지 문제를 해결할 수 있게 해줍니다.\n\n이를 감안할 때 각 디자인 패턴을 알아야 특정 문제를 해결할 때 더 큰 유연성을 가질 수 있습니다.\n\n내가 보는 문제는 보통 이 디자인 패턴 중 하나를 배우려고 할 때 실제로 직면한 문제를 알지 못한 채로 아주 긴 설명들을 마주하게 된다는 것입니다.\n\n이 이야기에서는 공장 메서드 패턴을 가능한 간단히 설명해 보겠습니다. 이렇게 함으로써 해당 패턴이 해결하고 있는 문제와 어떻게 구현되는지 이해할 수 있을 것입니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n<img src=\"/TIL/assets/img/2024-07-14-FactoryMethodpatterninPython_0.png\" />\n\n# Factory Method 패턴을 사용하지 않은 예제\n\n다른 종류의 문서인 이력서와 보고서를 가진 예제를 만들어 봅시다.\n\n이러한 문서 유형은 고유한 생성자를 가질 것입니다:\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nfrom abc import ABC, abstractmethod\n\n# 제품 인터페이스 정의\nclass Document(ABC):\n    @abstractmethod\n    def create(self):\n        pass\n\n# 구체적인 제품 생성\nclass Resume(Document):\n    def create(self):\n        return \"이력서 생성됨\"\n\nclass Report(Document):\n    def create(self):\n        return \"보고서 생성됨\"\n```\n\n이후에는 이 유형의 문서를 선택하는 함수가 있을 것입니다:\n\n```js\ndef create_document(document_type: str) -> Document:\n    if document_type == \"resume\":\n        return Resume()\n    elif document_type == \"report\":\n        return Report()\n    else:\n        raise ValueError(f\"알 수 없는 문서 유형: {document_type}\")\n```\n\n이후 팩토리 메서드 패턴을 통해 이 함수의 구현을 개선할 수 있음을 나중에 확인하게 될 것입니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n나머지 코드는 문서 유형을 사용하는 방법을 보여줍니다:\n\n```js\ndef client_code(document_type: str):\n    document = create_document(document_type)\n    print(document.create())\n\nif __name__ == \"__main__\":\n    print(\"이력서 생성:\")\n    client_code(\"resume\")\n    \n    print(\"\\n보고서 생성:\")\n    client_code(\"report\")\n```\n\n# 팩토리 메서드 사용\n\n리팩토링에서는 여전히 각 객체의 생성자가 있습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nfrom abc import ABC, abstractmethod\n\n# 제품 인터페이스 정의\nclass Document(ABC):\n    @abstractmethod\n    def create(self):\n        pass\n\n# 구체적인 제품 생성\nclass Resume(Document):\n    def create(self):\n        return \"이력서 생성됨\"\n\nclass Report(Document):\n    def create(self):\n        return \"보고서 생성됨\"\n```\n\n그러나 이제 각 유형의 문서 생성을 탈 중앙화했습니다:\n\n```python\n# 팩토리 메서드를 사용하여 생성자 클래스 정의\nclass DocumentCreator(ABC):\n    @abstractmethod\n    def factory_method(self):\n        pass\n\n    def create_document(self):\n        # 제품을 얻기 위해 팩토리 메서드 호출\n        document = self.factory_method()\n        return document.create()\n\n# 구체적인 생성자 구현\nclass ResumeCreator(DocumentCreator):\n    def factory_method(self):\n        return Resume()\n\nclass ReportCreator(DocumentCreator):\n    def factory_method(self):\n        return Report()\n```\n\n새로운 문서 유형을 추가하는 것은 새로운 구체적인 생성자 클래스를 만드는 것만큼 간단합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n나머지 코드는 문서 유형을 사용하는 방법을 보여줍니다:\n\n```js\ndef client_code(creator: DocumentCreator):\n    print(creator.create_document())\n\nif __name__ == \"__main__\":\n    print(\"이력서 생성 중:\")\n    resume_creator = ResumeCreator()\n    client_code(resume_creator)\n    \n    print(\"\\n보고서 생성 중:\")\n    report_creator = ReportCreator()\n    client_code(report_creator)\n```\n\n# 차이점 설명\n\n주요 차이점은 팩토리 메서드 패턴을 사용하지 않을 때, 객체를 프로그램 로직을 정의하는 곳과 동일한 위치에서 생성한다는 것입니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\ndef create_document(document_type: str) -> Document:\n    if document_type == \"resume\":\n        return Resume()\n    elif document_type == \"report\":\n        return Report()\n    else:\n        raise ValueError(f\"Unknown document type: {document_type}\")\n```\n\n위의 예제는 매우 간단합니다. 새로운 문서 유형을 추가하거나 삭제할 때 이 논리를 변경하는 것은 비교적 쉬우지만, 더 복잡한 경우에는 더 비용이 많이 들 수 있습니다.\n\n게다가, 이것에는 훌륭한 논리가 없습니다. 각 if/else 이후에 일련의 동작이 수행된다고 상상해보세요.\n\n## 비교\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 팩토리 메소드 없이: 문서 생성 로직은 create_document 함수에 중앙 집중화되어 있습니다. 이는 더 간단하지만 코드를 유연하게 만들고 유지하기 어렵게 만듭니다. 새로운 유형의 문서를 추가하려면 create_document 함수를 수정해야 하며, 이로 인해 버그가 발생할 수 있고 전체 함수의 로직을 이해해야 합니다.\n- 팩토리 메소드 사용: 생성 로직이 분산됩니다. 각 구체적인 생성자는 자체 유형의 문서를 생성하는 방법을 알고 있습니다. 새로운 유형의 문서를 추가하는 것은 새로운 구체적인 생성자 클래스를 만드는 것만큼 간답습니다. 이 접근 방식은 개방/폐쇄 원칙을 준수하며 코드를 보다 모듈식으로 만들고 확장하기 쉽게 만듭니다.\n\n![Factory Method Pattern](/TIL/assets/img/2024-07-14-FactoryMethodpatterninPython_1.png)\n\n# 어떻게 인식할까요?\n\n이 패턴을 사용해야 하는 시점은 로직 일부가 서로 다른 객체 유형을 생성하는 if/else if/else를 사용하고 있을 때 가장 쉽게 인식할 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n# 예시\ndef mainfuntion():\n    if option==1:\n        Object1=Object_constructor()\n        action1()\n        action2()\n    elif option==2:\n        Object2=Object_constructor2()\n        action3()\n        action4()\n    else:\n        Object3=Object_constructor3()\n        action5()\n        action6()\n\n\n우리는 보듯이, 이 논리는 사용된 객체의 유형에 매우 의존합니다. 다른 유형의 객체를 사용해야 한다면 프로그램의 논리를 바꿀 필요가 있습니다.\n\n이러한 패턴을 보게 되면, 팩토리 메서드를 사용하여 개선을 고려할 수 있습니다.\n\n# 결론\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n인터넷에서 찾을 수 있는 것들과는 조금 다른 방식으로 이 디자인 패턴을 설명해 보았어요. 가능한 가장 간단한 방법으로 설명해 보았답니다.\n\n저는 이러한 패턴에 대해 다양한 정보원에서 배우는 것이 이상적이라고 생각해요. 각각의 예시를 보면서 개념을 더 깊이 이해할 수 있을 거예요.\n\n이야기가 마음에 들기를 바랍니다.\n\n관심 가져 주셔서 정말 감사합니다!","ogImage":{"url":"/TIL/assets/img/2024-07-14-FactoryMethodpatterninPython_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-FactoryMethodpatterninPython_0.png","tag":["Tech"],"readingTime":7},{"title":"주가 분석 종합 데이터 사이언스 접근 방법","description":"","date":"2024-07-14 23:41","slug":"2024-07-14-StockPriceAnalysisAComprehensiveDataScienceApproach","content":"\n\n고급 데이터 과학과 금융 통찰력을 통합하여 전략적 투자 결정을 내리기\n\n![Stock Price Analysis](/TIL/assets/img/2024-07-14-StockPriceAnalysisAComprehensiveDataScienceApproach_0.png)\n\n소개\n\n본 글에서는 주식 가격을 더 정확하게 예측하기 위해 데이터 과학과 금융 분석을 결합한 방법을 소개합니다. 이번 방법에 대한 간단한 소개입니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n트렌드 발견하기: 우리는 주식 시세를 부드럽게 만들어 트렌드를 파악하는데, cubic spline interpolation이라는 기술을 사용합니다.\n\n주식 그룹화: 비슷한 주식들은 이러한 트렌드를 기반으로 그룹화되어, 그들을 집단으로 분석하기가 더 쉽습니다.\n\n모델 만들기: 한 그룹을 선택하면, 우리는 미래 주식 수익을 예측하는 모델을 만듭니다.\n\n주요 요인 설명: 우리는 SHAP 값들을 사용하여 예측에 가장 영향을 많이 주는 요인을 이해합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n최적 주식 선택: Response Surface Methodology (RSM)을 통해 잠재력이 높은 주식을 식별합니다.\n\n게다가, 이 방법은 핵심 재무 개념에 대한 새로운 통찰력을 제공합니다:\n\n시계열 한계 해결: 이 방법은 효율적 시장 가설을 고려한 안정적이고 신뢰할 수 있는 대안을 제공하여 시계열 분석의 복잡성을 탐색합니다.\n\n샤프 비율 새로이 상상하기: 우리는 수익률 대 위험을 측정하는 방식을 개선하는 샤프 비율의 향상된 버전을 탐구합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n제 목표는 깊은 분석과 판단 전략을 결합하여 주식 가격을 예측하는 철저하고 효과적인 시스템을 만드는 것입니다.\n\n데이터 수집 및 초기 정리\n\n우선 Python을 통해 시장 데이터에 직접 액세스하기 위해 yfinance 라이브러리를 설치하세요:\n\n```js\npip install yfinance --upgrade\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n설치 후 yfinance를 사용하면 선택한 기간 동안 다양한 티커에 대한 일일 주식 가격 및 거래량을 조회할 수 있습니다:\n\n```js\nimport pandas as pd\nimport yfinance as yf\n\ndef get_data_by_day(ticker_list, start, end):\n    interval = '1d'\n    # 루프에서 데이터를 추가하는 것을 피하기 위해 DataFrame을 위한 열들을 미리 정의합니다\n    columns = ['Date', 'Open', 'High', 'Low', 'Close', 'Volume', 'ticker']\n    data_list = []\n    for ticker in ticker_list:\n        df = yf.download(ticker, start=start, end=end, interval=interval)\n        if not df.empty:\n            df['ticker'] = ticker\n            data_list.append(df)\n    download_data = pd.concat(data_list).reset_index()\n    download_data = download_data[columns]  # 열 재정렬 및 관련 열 선택\n    \n    unique_dates = download_data['Date'].drop_duplicates().sort_values(ascending=False).reset_index(drop=True)\n    date_map = pd.Series(range(1, len(unique_dates) + 1), index=unique_dates)\n    download_data['dayseq'] = download_data['Date'].map(date_map)\n    download_data = download_data.sort_values(['ticker', 'Date'], ascending=[False, False])\n    return download_data\n```\n\n데이터 수집 후: 극히 낮은 가격 또는 거래량을 가진 주식 및 음수 값으로 데이터의 정확성을 보장하기 위해 필터링하여 분석을 왜곡할 수 있는 가능성이 있는 에러를 제거합니다:\n\n```js\n# 일관성을 위해 열 이름 조정\ndf = df[['ticker', 'date_dt', 'Close', 'Volume']].rename(columns={'date_dt': 'date', 'Close': 'price', 'Volume': 'Volume'})\n# $1 미만의 주가를 가진 주식 제거\nmin_prices = df.groupby('ticker')['price'].min().reset_index()\ndf = df[~df.ticker.isin(min_prices[min_prices.price < 1].ticker)]\n# 비양수 거래량을 갖는 주식 제거\nmin_volumes = df.groupby('ticker')['Volume'].min().reset_index()\ndf = df[~df.ticker.isin(min_volumes[min_volumes.Volume < 1].ticker)]\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n분석 작업을 위해 2022년 6월 7일부터 2023년 6월 7일까지 384개의 신중히 선정된 주식에 대한 데이터가 편성되었습니다. 선정 기준은 무작위가 아니며, 다양한 부문, 자산 규모, 가격 대 역까지 다양한 요소를 고려해 종합적인 시장 전체를 포착하려는 것입니다. 이 다양성을 통해 분석 결과가 전체 시장 역학을 반영할 수 있을 것으로 기대합니다.\n\n원활한 데이터 기능을 활용한 분석 강화\n\n분석을 개선하고 보다 정확한 예측 모델을 개발하기 위해 일일 원시 데이터 대신 원활화된 데이터를 선택했습니다. 이 방법론은 여러 가지 장점에 기반해 있습니다:\n\n- 시장 소음 최소화: 금융 시장의 빈번한 가격 흔들림이 분석을 방해할 수 있습니다. 원활화는 이러한 변동성을 완화시켜 더 명확한 그림을 제공합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n· 패턴 발견: 주식 가격에 영향을 미치는 기본적인 추세를 발견하고 연구하는 것이 더 간단해집니다.\n\n· 더 나은 군집화: 부드러운 데이터를 사용하면 유사한 가격 추세를 가지는 주식을 더 정확하게 그룹화할 수 있습니다.\n\n· 향상된 모델링: 부드럽게 처리된 특징을 사용하면 예측 모델의 초점이 좀 더 선명해지며 효과를 증대시킬 수 있습니다.\n\n파이썬을 사용하여 금융 데이터에 부드럽게 처리 기술을 적용하는 단계를 요약하면 다음과 같습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 데이터 분리 및 정렬: 주식 데이터를 분리하고 날짜별로 정렬합니다.\n\n- X 값 설정: 각 데이터 포인트를 인덱싱하기 위한 정수 시퀀스를 생성합니다.\n\n- Cubic Spline 적용: 가격 및 거래량 데이터에 3을 사용하여 부드러운 cubic spline interpolation을 적용하여 부드러운 곡선을 생성합니다.\n\n- 주요 지점 선택: 이러한 곡선에서 균일 간격으로 30개의 지점을 선택하여 데이터셋을 간단화합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n감사합니다. 아래는 주식 데이터를 스무딩하는 파이썬 코드입니다:\n\n```python\n# 부드럽게 정리된 데이터 저장\n부드럽게 정리된 데이터를 참조할 수 있는 인덱스 열을 포함한 DataFrame에 저장합니다.\n\n# 데이터 통합\n개별 DataFrame을 통합된 데이터 세트로 병합하여 추가 분석을 수행합니다.\n\n최종 데이터 세트는 원래 250개의 일일 데이터 포인트에서 간격이 8개의 거래일을 두고 30개의 가격 노드로 축소되었습니다.\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nimport pandas as pd\nimport numpy as np\nfrom scipy.interpolate import make_interp_spline\n\n# 'df'이 데이터프레임으로, ['ticker', 'date', 'price', 'Volume'] 열을 가지고 있다고 가정합니다.\nresult_df = pd.DataFrame()\n\nfor ticker in df['ticker'].unique():\n    df_ticker = df[df['ticker'] == ticker].sort_values(by='date')\n    # x 값 생성 후 가격과 거래량에 대해 cubic spline interpolation 적용합니다.\n    x_vals = np.arange(len(df_ticker))\n    spline_price = make_interp_spline(x_vals, df_ticker['price'], k=3)(np.linspace(x_vals.min(), x_vals.max(), 300))\n    spline_volume = make_interp_spline(x_vals, df_ticker['Volume'], k=3)(np.linspace(x_vals.min(), x_vals.max(), 300))\n\n    # 부드러운 곡선에서 30개의 등간격 포인트를 선택합니다.\n    indices = np.linspace(0, 299, 30, dtype=int)\n    # 해당 종목의 부드럽게 처리된 데이터를 위한 DataFrame을 준비합니다.\n    df_smooth = pd.DataFrame({\n        'ticker': ticker,\n        'smooth_price': spline_price[indices],\n        'smooth_volume': spline_volume[indices],\n        'seq': np.arange(30, 0, -1)  # 30부터 1까지 역순으로 순번을 부여합니다.\n    })\n\n    # 부드럽게 처리된 데이터를 추가합니다.\n    result_df = pd.concat([result_df, df_smooth], ignore_index=True)\n```\n\n여기에 AAPL을 예시로 한 부드럽게 처리된 데이터가 표시되어 있습니다:\n\n![AAPL Smoothed Data](/TIL/assets/img/2024-07-14-StockPriceAnalysisAComprehensiveDataScienceApproach_1.png)\n\n주식 군집을 통해 금융 모델을 향상시킬 수 있습니다.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n시계열 모델의 도전:\n\nARIMA와 같은 모델로 주가를 예측하는 것은 효율적 시장 가설로 인한 도전에 직면합니다. 이 이론은 현재 주가가 모든 기존 정보를 반영하고 있어서, 시장 가격이 새로운 정보에 예측할 수 없이 반응함에 따라 예측이 랜덤 워크를 모방하게 됨을 시사합니다.\n\n다양한 데이터의 한계:\n\n여러 주식을 함께 모델링하는 것은 페어 트레이딩에서 사용되는 것처럼 유용한 상관 관계를 발견할 수 있습니다. 그러나 서로 다른 주식들 간의 독특한 패턴과 추세(예: AAPL 대 TSLA)는 일관된 모델 개발을 방해합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n전략적 접근 - 클러스터링:\n\n주식을 행동 또는 추세의 유사성을 기반으로 클러스터로 그룹화하면 더 정확하고 그룹별 모델링이 가능해져 예측의 정확도가 향상됩니다.\n\nKMeans를 사용한 주식 클러스터링:\n\n- 데이터 구조화: 스무딩된 주식 데이터를 중심 가격 30개와 일치시켜야 합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n· 정규화: 데이터에 표준화를 적용하여 일관된 KMeans 분할을 실시합니다.\n\n· 클러스터 최적화: KMeans 및 Elbow Method를 사용하여 이상적인 클러스터 수를 결정하고 WCSS에 초점을 맞춥니다.\n\n· 클러스터링 평가: KMeans를 사용하여 주식을 그룹화하고 실루엣 점수를 통해 효과를 평가합니다.\n\n여기에는 파이썬 코드가 포함되어 있습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.cluster import KMeans\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom sklearn import metrics\n\n# 데이터 피벗\nresult_df_pivoted = result_df.pivot(index='ticker', columns='seq', values=['smooth_price', 'smooth_volume'])\nresult_df_pivoted.columns = [f'{val}_{i}' for val, i in result_df_pivoted.columns]\nresult_df_pivoted.reset_index(inplace=True)\n# 데이터 표준화\nscaler = StandardScaler()\nprice_columns = [col for col in result_df_pivoted.columns if 'smooth_price' in col]\nresult_df_pivoted[price_columns] = scaler.fit_transform(result_df_pivoted[price_columns])\nresult_df_std = result_df_pivoted[['ticker'] + price_columns]\n\n# 최적 클러스터 수 결정\nK = range(1, 10)\nsum_of_squared_distances = []\nfor k in K:\n    kmeans = KMeans(n_clusters=k).fit(result_df_std.drop('ticker', axis=1))\n    sum_of_squared_distances.append(kmeans.inertia_)\nplt.plot(K, sum_of_squared_distances, 'bx-')\nplt.xlabel('K values')\nplt.ylabel('Sum of Squared Distances')\nplt.title('Elbow Method for Optimal K')\nplt.show()\n```\n\n![Stock Price Analysis Image](/TIL/assets/img/2024-07-14-StockPriceAnalysisAComprehensiveDataScienceApproach_2.png)\n\nWCSS 곡선 분석 결과, 명확한 팔꿈치 지점으로 4가 최적 클러스터 수로 나타났습니다.\n\n4개 클러스터로 진행하여, 실루엣 지수를 통해 각 클러스터의 품질을 평가합니다.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nkmeans = KMeans(n_clusters=4)\nresult_df_std['cluster'] = kmeans.fit_predict(result_df_std.drop('ticker', axis=1))\n# 성능 평가\nsilhouette_score = metrics.silhouette_score(result_df_std.drop(['ticker', 'cluster'], axis=1), result_df_std['cluster'])\nprint(f'실루엣 점수: {silhouette_score}')\n```\n\n실루엣 지수가 0.594로, 클러스터링 구조는 상당히 좋은 것으로 보여져 적절하게 구분된 그룹을 나타냅니다.\n\n클러스터 분포를 시각화하기 위해 주성분 분석(PCA)를 적용하여 차원을 축소합니다:\n\n```python\nfrom sklearn.decomposition import PCA\n\n# PCA 초기화 및 X를 두 가지 구성 요소로 축소\npca = PCA(n_components=2)\nX_pca = pca.fit_transform(result_df_std[cols])\n\n# 분할별로 색칠된 PCA 변환 기능 표시\nplt.figure(figsize=(10, 6))\nscatter = plt.scatter(X_pca[:, 0], X_pca[:, 1], c=labels, cmap='viridis', alpha=0.75, s=7)\nplt.title('주식 티커의 주성분 분석')\nplt.xlabel('첫 번째 주성분')\nplt.ylabel('두 번째 주성분')\nplt.colorbar(scatter, label='분할')\nplt.show()\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/TIL/assets/img/2024-07-14-StockPriceAnalysisAComprehensiveDataScienceApproach_3.png\" />\n\n주식 가격의 동일한 행동 양식을 강조하여 주식의 명확한 그룹화를 보여주는 그림입니다.\n\n주식 수익률 예측을 단순화하기 위한 목표 개요\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n목표는 식별된 클러스터 내 주식 수익률을 예측하는 모델을 개발하는 것입니다. 주요 준비 단계는 다음과 같습니다:\n\n- 피처 선택: 이 프로젝트의 범위 내에서 오버피팅의 약간의 위험을 갖고 있지만, 다수의 피처(smooth_price1 ~ smooth_price30)를 클러스터링에 활용합니다. 더 좁은 피처 세트(smooth_price1 ~ smooth_price20)를 사용하더라도 클러스터 무결성에 큰 영향을 미치지 않습니다.\n\n- 인구 밀집 클러스터에 집중: 모델링 노력을 인구 밀집된 클러스터에 집중하여 관찰된 패턴의 신뢰도와 일관성을 향상시키고 모델의 정밀도를 향상시킵니다.\n\n- 모델 결과 평가: 주요 영향요인 검토와 예측 성능 평가가 포함됩니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n샤프 지수 통합\n\n리스크-프리 자산에 대한 투자 성과를 평가하는 데 중요한 지표인 샤프 지수는 저희 방법론의 기반이 됩니다:\n\n![image](/TIL/assets/img/2024-07-14-StockPriceAnalysisAComprehensiveDataScienceApproach_4.png)\n\nWhere:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n표 태그를 다음과 같이 마크다운 형식으로 변경하세요.\n\n| S: 샤프 비율 |\n| E: 기대 자산 수익률과 기준 수익률의 차이 |\n| R: 자산 초과 수익의 표준 편차 |\n\n선형 회귀 포함: 우리는 샤프 비율 (S)을 선형 회귀 모형에서 계수로 통합하여 주식 성과를 클러스터 내에서 평가합니다. 더 높은 비율은 우수한 결과와 관련되어 있습니다. 응용 프로그램 목적을 위해, 우리는 R로 '위험' (주식 수익의 변동성 또는 수익의 표준 편차)을 대체하고 E로 실제 주식 수익을 대체합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/TIL/assets/img/2024-07-14-StockPriceAnalysisAComprehensiveDataScienceApproach_5.png\" />\n\n샤프 비율에 관한 맥락에서 중요한 점은 선형 회귀 모델이 예측 모델이 아닌 것을 알아야 합니다. 대신, 이 모델은 주식 수익과 위험 사이의 상관 관계를 동일한 시간 프레임 내에서 반영합니다. 더 나아가, 선형 회귀는 개별 주식의 특성에 속하는 샤프 비율을 유도하기 위해 다양한 주식 그룹에 대해 적용될 수 없습니다.\n\n그러나 이 회귀 접근법을 다양한 주식 클러스터에 적용함으로써, 이러한 클러스터의 성능을 평가하고 차별화하는 비교적인 샤프 비율과 비슷한 특성을 생성할 수 있습니다. 이 방법은 샤프 비율을 과거 지표로 활용하여, 어떻게 투자가 위험 조정 수익 측면에서 진행되었는지를 보여줍니다.\n\n주식 예측을 위한 샤프 비율 사용의 한계\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n종목 예측에 Sharpe Ratio에 의존하는 주요 과제는 다음과 같습니다:\n\n- 복잡한 상호 작용: Sharpe Ratio와 수익의 관계는 상이할 수 있으며, 일부 주식에 대해 양의 값을 가지는 반면, 다른 주식에 대해서는 음의 값을 가질 수 있어서 단일 관점으로 캡처할 수 없는 다양한 상호 작용을 나타낼 수 있습니다.\n\n- 불완전한 그림: 위험과 수익을 단일 측정 값으로 요약함으로써, 과거 수익 추세와 같은 중요한 요소를 놓치게 됩니다.\n\n- 단순한 관계: 미래 수익과 단일 측정 값 간의 선형 관계를 가정하는 것은 복잡하고 비선형적인 동력을 간과하며, 이는 이차식 관계와 같은 비선형 표현에 대한 모델을 개선하고 최적화하는 것을 어렵게 합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모델 강화 전략\n\n모델을 개선함에 있어 Sharpe Ratio 개념에서 영감을 받아 한계를 극복하기 위해 다음과 같은 전략을 사용합니다:\n\n- 향상된 피처 엔지니어링: 수익 변동성 및 과거 수익의 이차식과 같은 보다 다양한 변수를 포함하여 정밀도를 향상시킵니다.\n\n- 타겟 클러스터 트레이닝: 비슷한 주식 군집의 데이터를 활용하여 맞춤형 모델링을 수행합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 대상 변환: 미래 수익을 더 잘 예측하기 위해 대상 변수를 수정합니다.\n\n- GLM 활용: 일반화 선형 모델(GLM) 기법을 사용하여 연속적인 수익 예측에는 선형 회귀를, 범주형 예측에는 로지스틱 회귀를 적용합니다.\n\n- 선택적 특징 통합: 예측 성능을 향상시키기 위해 특징 선택 전략을 사용합니다.\n\n모델 형식은 다음과 같습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 Markdown 형식으로 표현한 내용입니다.\n\n![Stock Price Analysis](/TIL/assets/img/2024-07-14-StockPriceAnalysisAComprehensiveDataScienceApproach_6.png)\n\n주식 수익률(E)의 링크 함수:\n\n- 모델 1: Y = f(E) = E: 선형 회귀\n- 모델 2: Y = f(E) = (E`t) + 0: 이진 분류\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예측 기간 및 특성 생성:\n\n가장 최근 시점부터 10번째까지의 수익률을 예측하기 위해 다음과 같이 계산합니다:\n\n```js\ntrain_df['return'] = 100 * (train_df['smooth_price_1'] - train_df['smooth_price_10']) / train_df['smooth_price_10']\n```\n\n포함된 특성은 다음과 같습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n**수익률의 변동성:** 연속된 부드러운 가격 간 백분율 변동의 표준편차입니다.\n\n**과거 수익률 특징:** \"smooth_price11\"과 이후 가격 간 수익률 구간을 위한 9개의 새 열(past_return_1에서 past_return_9)입니다.\n\n**이차 상호 작용 항목:** 특성 선택 이후 선택된 것입니다.\n\n파이썬으로 구현된 특성 엔지니어링:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nfor i in range(24, 0, -1):\n    train_df[f'return_{i}'] = (train_df[f'smooth_price_{i}'] - train_df[f'smooth_price_{i+1}']) / train_df[f'smooth_price_{i+1}']\n\ntrain_df['risk_return'] = train_df[return_columns[0:15]].std(axis=1)\ntrain_df['risk_return_2'] = train_df['risk_return']**2\n```\n\nGeneralized Linear Models (GLM)을 사용한 모델링:\n\n특성 선택 후에, 중요한 특성들인 risk_return, 과거_return_2의 이차항, 그리고 이 둘의 상호작용을 사용하여 주식 수익률 예측을 위해 GLM을 적용합니다.\n\n```js\nimport statsmodels.api as sm\n\nX = sm.add_constant(train_df_clus0[['risk_return', 'past_return_2_squared', 'risk_past_interaction']])\ny = np.log(train_df_clus0['return'] + 1)  # 안정성을 위한 로그 변환\nmodel = sm.OLS(y, X).fit()\n\nprint(model.summary())\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 모델은 이 예제에서 다루지 않은 특징 선택 과정을 거친 후 선택된 특징을 사용합니다:\n\n![image](/TIL/assets/img/2024-07-14-StockPriceAnalysisAComprehensiveDataScienceApproach_7.png)\n\n모델의 수정된 R-제곱은 약 29%로, 주식 시장에서 정확한 수익률 예측에는 제한이 있음을 나타냅니다. 그러나 주식 선택에 대한 유용성은 주목할만 합니다. 중요한 예측 변수에는 risk_return, past_return_2의 이차항 및 risk_return과 past_return_2의 상호 작용 항이 포함되어 있으며, 이들이 분석에서의 관련성을 보여줍니다.\n\n이진 분류를 위한 로지스틱 회귀:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n특정 수익 임계값을 넘을지 예측하는 데 적합한 경우, 로지스틱 회귀 모델을 구축하였습니다:\n\n```python\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import roc_auc_score, roc_curve\n\nlogist_model = LogisticRegression().fit(X_train, y_train)\npred_probs = logist_model.predict_proba(X_test)[:, 1]\nauc = roc_auc_score(y_test, pred_probs)\n\nprint(f'AUC: {auc}, KS 통계량: {ks}')\n```\n\nAUC가 82%이고 KS 통계량이 61%인 경우, 로지스틱 모델은 테스트 데이터에서 주식 선택을 검증하는 데 강력한 성능을 보여줍니다. 이러한 메트릭은 해당 수익 임계값을 초과할 것으로 예상되는 주식을 구분하는 모델의 능력을 강조합니다.\n\nSHAP 값을 사용하여 주식 성과를 분석합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nSHAP 값은 개별 주식 영향을 깊이 이해하게 도와주며, 정확한 전략 개발을 가능케 합니다. 'std'와 같은 특정 원인을 강조함으로써, SHAP 값은 변동성이 수익 잠재력에 미치는 영향을 나타내며, 전반적인 특성 분석을 보완하면서 모델 정확도를 직접적으로 평가하지 않아도 됩니다.\n\n먼저 shap_values를 사용하여 모델의 모든 핵심 원인에 대한 전역 영향을 보여주는 막대 그래프를 생성합니다:\n\n```js\nmodel = sm.OLS(y, X[cols]).fit()\n# 모델의 p-값을 얻기 위해 모델 요약을 출력합니다\nexplainer = shap.Explainer(model.predict, X[cols])\n\n# SHAP 값을 계산합니다\nshap_values = explainer(X[cols])\nshap.plots.bar(shap_values)\n```\n\n<img src=\"/TIL/assets/img/2024-07-14-StockPriceAnalysisAComprehensiveDataScienceApproach_8.png\" />\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n과거 위험_수익 및 과거 수익과 상호 작용 항목이 중요하게 나타나는 것을 보여주며, 막대 플롯은 전체 효과를 시각화합니다.\n\n자세한 영향 분포를 보려면 bee swarm plot을 사용할 수 있습니다:\n\n```js\nshap.plots.beeswarm(shap_values)\n```\n\n<img src=\"/TIL/assets/img/2024-07-14-StockPriceAnalysisAComprehensiveDataScienceApproach_9.png\" />\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n상호 작용 변수 risk_past_interaction에는 값에 따라 다양한 기여도가 있음을 보여줍니다.\n\n'ORCL'과 같은 개별 주식에 중요한 주요 요인의 영향을 조사하려면 로컬 막대 플롯이 유용합니다:\n\n```js\nORCL_index = X[X['ticker'] == 'ORCL'].index\nORCL_shap_values = shap_values[ORCL_index[0]]\nshap.plots.bar(ORCL_shap_values)\n```\n\n<img src=\"/TIL/assets/img/2024-07-14-StockPriceAnalysisAComprehensiveDataScienceApproach_10.png\" />\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n클러스터 내 각 주식에 대한 주요 영향을 미치는 기능을 수집하는 것은 효과적인 거래 전략을 만드는 데 중요합니다. 아래는 이러한 주요 요인을 정확하게 파악하고 정리하기 위해 설계된 Python 코드입니다:\n\n```js\nimport pandas as pd\nimport numpy as np\n\n# 'tickers'를 'X'의 관측치와 맞춘다고 가정\ntickers = train_df_clus0['ticker'].values\n# 데이터를 수집하기 위한 딕셔너리 준비\ndata = {\n    'ticker': [],\n    'top_feature1': [], 'top_feature2': [], 'top_feature3': [],\n    'importance1': [], 'importance2': [], 'importance3': []}\n\n# 각 주식에 대해 상위 3개의 주요 영향 요소를 추출하기 위해 SHAP 값 순서대로 반복\nfor i, ticker in enumerate(tickers):\n    sorted_indices = np.argsort(-np.abs(shap_values.values[i]))[:3]\n    data['ticker'].append(ticker)\n    data['top_feature1'].append(cols[sorted_indices[0]])\n    data['top_feature2'].append(cols[sorted_indices[1]])\n    data['top_feature3'].append(cols[sorted_indices[2]])\n    data['importance1'].append(shap_values.values[i][sorted_indices[0]])\n    data['importance2'].append(shap_values.values[i][sorted_indices[1]])\n    data['importance3'].append(shap_values.values[i][sorted_indices[2]])\n\n# 수집한 데이터를 쉽게 분석하기 위해 DataFrame으로 변환\ndf_key_drivers = pd.DataFrame(data)\n```\n\n여기에는 각 주식의 상위 2개 기능 및 그 중요성을 보유한 결과 데이터 프레임이 있으며, 목표 주식 선택을 돕습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n주식 선정 최적화를 위한 응답 표면 방법론 (RSM)\n\n이 프로젝트는 RSM을 사용하여 주식 선택을 최적화하며, 과거 변동성과 성과 사이의 이차 관계를 활용하여 미래 수익을 예측합니다. 우리는 리스크_리턴(수익률 변동성)과 과거 수익을 포함하는 회귀 모델을 사용하여 재무 데이터의 비선형 경향과 변동성을 고려합니다.\n\n우리는 RSM을 적용하여 두 가지 주요 목표를 가지고 있습니다:\n\n- 과거 가격, 변동성 및 미래 수익 사이의 관계 모델링.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 예측된 미래 수익을 극대화하는 최적 조건을 찾기.\n\n다음은 응답 표면을 시각화하는 Python 코드입니다:\n\n```js\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\n\n# 모델 적합 및 응답 표면 데이터 생성\nX = sm.add_constant(train_df_clus0[['risk_return', 'past_return_2_squared', 'risk_past_interaction']])\nmodel = sm.OLS(y, X).fit()\nx_range = np.linspace(DF['past_return'].min(), DF['past_return'].max(), 100)\ny_range = np.linspace(DF['risk_return'].min(), DF['risk_return'].max(), 100)\nx_grid, y_grid = np.meshgrid(x_range, y_range)\nz_grid = model.params[0] + \\\n   model.params[1]*y_grid +  model.params[2]*x_grid**2 + \\\n   model.params[3]*x_grid*y_grid    \n\n# 응답 표면 플로팅\nfig = plt.figure()\nax = fig.add_subplot(111, projection='3d')\nax.plot_surface(x_grid, y_grid, z_grid, cmap='viridis')\nax.set_xlabel('x')\nax.set_ylabel('y')\nax.set_zlabel('z')\nplt.show()\n```\n\n![](/TIL/assets/img/2024-07-14-StockPriceAnalysisAComprehensiveDataScienceApproach_12.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n표면의 곡선은 이차 관계를 통합하는 모델의 용량을 확인합니다.\n\n최고 주식을 정확하게 찾기 위해 각 주식의 위치를 이상적인 지점과 비교하여, 거리 측정 기준에 따라 가장 가까운 다섯 개를 선택합니다:\n\n```js\n # 최적 지점까지의 거리 계산\nDF['distance'] = np.sqrt((DF['past_return'] - optimal_x)**2 + (DF['risk_return'] - optimal_y)**2)\n\n# 'distance' 열을 기준으로 DataFrame 정렬\nDF_sorted = DF.sort_values('distance')\n\n# 최적 지점에 가장 가까운 상위 10개의 주식 선택\ntop_10_stocks = DF_sorted.head(10)\n\nprint(\"최적 지점에 가장 가까운 상위 10개 주식:\")\nprint(top_10_stocks[['ticker', 'past_return', 'risk_return', 'distance']])\n```\n\n여기에 선택된 상위 10개 주식이 있습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 Markdown 형식으로 변경한 표입니다.\n\n\n![Stock Price Analysis](/TIL/assets/img/2024-07-14-StockPriceAnalysisAComprehensiveDataScienceApproach_13.png)\n\n우리는 최적 지점에 독점적으로 의존하지는 않지만, 그것은 이상적인 주식 조건에 대한 기준을 제공합니다. 이를 찾기 위해:\n\n```python\n# 미래 수익을 극대화하기 위한 최적 지점 찾기\noptimal_idx = np.argmax(z_grid)\noptimal_x = x_range[optimal_idx // 100]\noptimal_y = y_range[optimal_idx % 100]\noptimal_z = z_grid.flatten()[optimal_idx]\nprint(f\"최적 지점: 과거 수익 = {optimal_x}, 위험 수익 = {optimal_y}, 미래 수익 = {optimal_z}\")\n\n최적 지점: 과거 수익 = 0.544199942617375, 위험 수익 = 0.2085424594952841, 미래 수익 = 4.13061405635688\n```\n\nRSM을 활용하여 유망한 주식 선정을 신호하는 시장 조건을 전략적으로 식별할 수 있습니다.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n결론\n\n이 분석에서는 주식 가격 예측과 투자 전략 수립을 향상시키기 위해 데이터 과학 기술과 금융 통찰력을 결합했습니다. 추세 식별을 위한 데이터 평활화, 주식 분류를 통한 집중 조사, 예측 모델의 배치를 통해 주식 시장 흐름의 복잡성을 탐색했습니다.\n\n이 연구는 특정 시간대의 데이터를 기반으로 하고 있다는 점을 인지하는 것이 중요합니다. 시장 흐름(bull/bear phase), 이자율, 세계 경제 풍향, 산업 특정 트렌드를 포함한 다양한 변수에 민감한 금융 시장을 고려할 때, 우리 모델의 적용 가능성은 서로 다른 기간에 따라 다를 수 있습니다.\n\n이러한 한계에도 불구하고, 본 연구는 페어 트레이딩이나 예측 응답을 기반으로 한 선택적 주식 투자와 같은 실행 가능한 전략을 제시하여 전략적 사고를 강화하고자 합니다. 이러한 데이터 과학과 전통적인 금융 분석의 결합은 빠르고 예측할 수 없는 변화에 취약한 시장에서 투자자가 결정을 내리는 데 도움이 되는 도구를 제공하기 위한 것입니다.","ogImage":{"url":"/TIL/assets/img/2024-07-14-StockPriceAnalysisAComprehensiveDataScienceApproach_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-StockPriceAnalysisAComprehensiveDataScienceApproach_0.png","tag":["Tech"],"readingTime":28},{"title":"Python 패키지 관리를 위한 로컬 PyPi 저장소 서버 설정 방법","description":"","date":"2024-07-14 23:39","slug":"2024-07-14-HowtoSetUpYourOwnLocalPyPiRepositoryServerforPythonPackageManagement","content":"\n\n<img src=\"/TIL/assets/img/2024-07-14-HowtoSetUpYourOwnLocalPyPiRepositoryServerforPythonPackageManagement_0.png\" />\n\n파이썬 패키지 저장소는 파이썬 패키지를 호스팅하여 개발자가 라이브러리를 게시하고 배포할 수 있는 중앙 웹 사이트입니다. PyPI(Python Package Index)를 호스팅하거나 미러링하여 네트워크 내에서 Python 패키지에 빠르고 신뢰할 수 있는 액세스를 제공하는 것이 중요합니다. 특히 네트워크 대역폭이 제한되었거나 인터넷 연결이 불안정한 환경에서는 더욱 중요합니다.\n\n# 전제 조건\n\n- 관리 권한이 있는 Red Hat 또는 Rocky Linux 8 시스템이 있어야 합니다.\n- 필요한 패키지를 다운로드하려면 인터넷에 액세스해야 합니다.\n- PyPI 저장소를 위한 충분한 저장 공간(1TB)이 필요할 수 있으며, 해당 패키지를 저장할 데이터 파티션을 설정할 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 실행 단계\n\n— Bandersnatch 사용\n\n- 필수 패키지 설치: python3, pip, virtualenv이 설치되어 있는지 확인해주세요.\n\n```bash\nsudo dnf install python2 python3 python3-pip python3-virtualenv vim -y\npython3 -m venv venv\nsource venv/bin/activate\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2. Bandersnatch 설치: Bandersnatch는 PyPI를 미러링하는 도구입니다.\n\n```js\npip install --upgrade pip\npip install dataclasses\npip install bandersnatch\n```\n\n3. Bandersnatch 구성: 초기 구성 파일을 생성하고 편집하세요.\n\na. 구성 파일을 생성하려면 처음으로 bandersnatch 미러 명령을 실행하십시오.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n밴더스내치 미러\n2024–07–14 00:04:36,297 경고: 설정 파일 ‘/etc/bandersnatch.conf’이 누락되어 기본 설정이 생성되었습니다.\n2024–07-14 00:04:36,297 경고: 설정 파일을 검토한 후 ‘bandersnatch’를 다시 실행해주세요.\n```\n\nb. 거울 데이터를 저장할 디렉토리에 대한 구성 파일 매개변수를 업데이트하세요. 제 경우에는 데이터 파티션을 만드는 것이죠. 여러분의 설정은 다를 수 있어요.\n\n```js\nvim /etc/bandersnatch.conf\n\n...\ndirectory = /data/\n...\n```\n\n파일을 저장하세요.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n명령을 다시 실행하면 bandersnatch mirror가 실행됩니다.\n\n```js\nbandersnatch mirror\n2024-07-14 00:09:40,793 INFO: 선택된 스토리지 백엔드: 파일 시스템\n2024-07-14 00:09:40,860 ERROR: swift_plugin = bandersnatch_storage_plugins.swift:SwiftStorage 진입점 로드 불가능: 'keystoneauth1' 모듈을 찾을 수 없음\n2024-07-14 00:09:40,911 INFO: 미러 디렉토리 설정 중: /data/web/simple\n2024-07-14 00:09:40,912 INFO: 미러 디렉토리 설정 중: /data/web/packages\n2024-07-14 00:09:40,913 INFO: 미러 디렉토리 설정 중: /data/web/local-stats/days\n2024-07-14 00:09:40,913 INFO: 생성 파일이 누락되었습니다. 상태 파일을 다시 초기화합니다.\n2024-07-14 00:09:40,914 INFO: status 파일 /data/status 누락됨. 처음부터 다시 시작합니다.\n2024-07-14 00:09:40,914 INFO: https://pypi.org와 동기화 중.\n2024-07-14 00:09:40,914 INFO: 현재 미러 일련번호: 0\n2024-07-14 00:09:40,914 INFO: 모든 패키지 동기화 중.\n```\n\n명령이 다시 실행되어 모든 패키지가 pypi 웹사이트에서 다운로드됩니다.\n\n이 데이터를 웹 서버로 복사하거나 웹 서버를 설정해보세요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n4. 웹 서버 설치: 아파치 httpd 웹 서버를 설치합니다.\n\n```js\nsudo dnf install httpd\nsudo systemctl start httpd\nsudo systemctl enable httpd\n```\n\n5. 웹 서버 구성: 웹 서버를 PyPI 미러가 저장된 디렉토리로 지정합니다.\n\n```js\nsudo vim /etc/httpd/conf.d/pypi_repo.conf\n\nAlias /pypi /var/www/html/pypi\n<Directory /var/www/html/pypi>\n    Options Indexes FollowSymLinks\n    AllowOverride None\n    Require all granted\n</Directory>\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nsudo systemctl restart httpd\n```\n\n6. 클라이언트가 로컬 저장소를 사용하도록 구성하기: 클라이언트 기기에서 pip를 사용하여 로컬 PyPI 미러를 사용하도록 구성합니다.\n\n```js\nmkdir -p ~/.config/pip\ncat << EOF > ~/.config/pip/pip.conf\n[global]\nindex-url = http://mywebserver.example.com/pypi/simple\nEOF\n```\n\nBandersnatcher의 문제는 선택적 미러링을 할 수 없다는 것입니다. 왜냐하면 pypi 서버로부터 전체 내용을 가져오기 때문입니다. 이 문제를 해결하기 위해 개발자가 모든 선택적 다운로드를 위한 라이브러리 minirepo를 제공했고, 이를 아래에서 나열해보겠습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n— Minirepo과 pypi-server를 사용 중\n\n안녕하세요! 라즈베리 파이를 설정한 사람의 정보를 바탕으로 이 라이브러리들을 테스트하고 있는데, 재미있는 일이 있었어요. 여러 오류를 마주쳤지만 그 덕분에 코드에서 버그를 발견하고 고칠 수 있었어요. 저의 수정 사항은 여기에서 확인할 수 있어요. 필요하시면 제 수정 사항을 자유롭게 적용해 보세요.\n\n- Python3 호환성 문제\n- XML 구문 분석 오류 문제\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파이썬 파이프 파이프 파프리리바 리프 파이사이사이 사이브\n\n이제 처음으로 minirepo를 실행하면 json 형식의 .minirepo 파일 이름을 요청합니다.\n\n```js\nminirepo\n\n/******** Minirepo ********/\nTraceback (most recent call last):\n File \"/root/venv/lib64/python3.6/site-packages/minirepo.py\", line 206, in get_config\n config = json.load(open(config_file))\nFileNotFoundError: [Errno 2] No such file or directory: '/root/.minirepo'\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 텍스트를 친근한 톤으로 한국어로 번역하면 다음과 같습니다.\n\n```js\n파일을 생성해 봅시다.\n\ncat << EOF > /root/.minirepo\n{\n  \"processes\": 10,\n  \"package_types\": [\n    \"bdist_egg\",\n    \"bdist_wheel\",\n    \"sdist\"\n  ],\n  \"extensions\": [\n    \"bz2\",\n    \"egg\",\n    \"gz\",\n    \"tgz\",\n    \"whl\",\n    \"zip\"\n  ],\n  \"python_versions\": [\n    \"3.0\",\n    \"3.1\",\n    \"3.2\",\n    \"3.3\",\n    \"3.4.10\",\n    \"3.5.7\",\n    \"3.6.9\",\n    \"any\",\n    \"cp27\",\n    \"py2\",\n    \"py2.py3\",\n    \"py27\",\n    \"source\"\n  ],\n  \"repository\": \"/data\"\n}\nEOF\n\n이제 실행해 봅시다.\n\nminirepo \n\n(venv) [root@localhost ~]# minirepo \n/******** Minirepo ********/\nextensions      = ['bz2', 'egg', 'gz', 'tgz', 'whl', 'zip']\npackage_types   = ['bdist_egg', 'bdist_wheel', 'sdist']\nprocesses       = 10\npython_versions = ['3.0', '3.1', '3.2', '3.3', '3.4.10', '3.5.7', '3.6.9', 'any', 'cp27', 'py2', 'py2.py3', 'py27', 'source']\nrepository      = /data\n설정 파일 사용 중 /root/.minirepo\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파이썬 코드를 이용하여 pypi 웹사이트를 파싱하고 패키지를 다운로드할 것입니다.\n\n.......\n[zzzutils 다운로드](/simple/zzzutils/)\n[zzz-web 다운로드](/simple/zzz-web/)\n[zzzymobbe 다운로드](/simple/zzzymobbe/)\n[zzzz 다운로드](/simple/zzzz/)\n[zzzZZZzzz 다운로드](/simple/zzzzzzzzz/)\n</body>\n</html>\n/tmp/tmpvt3vfas8/worker.2565 파일에서 워커 시작...\n/tmp/tmpvt3vfas8/worker.2566 파일에서 워커 시작...\n/tmp/tmpvt3vfas8/worker.2567 파일에서 워커 시작...\n/tmp/tmpvt3vfas8/worker.2568 파일에서 워커 시작...\n/tmp/tmpvt3vfas8/worker.2569 파일에서 워커 시작...\n/tmp/tmpvt3vfas8/worker.2570 파일에서 워커 시작...\n/tmp/tmpvt3vfas8/worker.2571 파일에서 워커 시작...\n/tmp/tmpvt3vfas8/worker.2572 파일에서 워커 시작...\n/tmp/tmpvt3vfas8/worker.2573 파일에서 워커 시작...\n/tmp/tmpvt3vfas8/worker.2574 파일에서 워커 시작...\n2024-07-14 12:58:06,098:경고: 다운로드 완료: jira_test-0.0.1.tar.gz                             Ok pid:2567 0% [1/55510.0]\n2024-07-14 12:58:06,127:경고: 다운로드 완료: nvitop-1.3.2.tar.gz                                Ok pid:2565 0% [1/55509.0]\n\n이제 PyPi 패키지를 로컬 저장소에 복제했으며, 클라이언트에 설치된 pip를 통해 해당 패키지를 직접 설치할 수 있습니다. 이제 pypiserver가 등장합니다. pypiserver는 로컬 패키지 인덱스를 제공하여 네트워크를 통해 저장소에서 패키지를 찾을 수 있도록 하는 역할을 합니다.\n\n우리는 도커를 사용하여 pypi 서버를 배포할 것입니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nservices:\n  pypi-server:\n    image: pypiserver/pypiserver:latest\n    ports:\n      - 8082:8080\n    volumes:\n      - type: volume\n        source: pypi-server\n        target: /data\n    command: -P . -a . /data/\n    restart: always\nvolumes:\n  pypi-server:\r\n\n![How to Set Up Your Own Local PyPi Repository Server for Python Package Management](/TIL/assets/img/2024-07-14-HowtoSetUpYourOwnLocalPyPiRepositoryServerforPythonPackageManagement_1.png)\n\n![Reference](https://miro.medium.com/v2/resize:fit:960/0*6KpBJVtYreNzCL3G.gif)\n\n# 참고 문헌\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n[1] https://bandersnatch.readthedocs.io/en/latest/\n\n[2] https://vuyisile.com/pypi-in-a-box-using-a-raspberry-pi-as-a-portable-pypi-server/","ogImage":{"url":"/TIL/assets/img/2024-07-14-HowtoSetUpYourOwnLocalPyPiRepositoryServerforPythonPackageManagement_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-HowtoSetUpYourOwnLocalPyPiRepositoryServerforPythonPackageManagement_0.png","tag":["Tech"],"readingTime":10},{"title":"BlockNote의 Text-To-Speech 기능 구현 방법 - Nextjs 사용 ","description":"","date":"2024-07-14 20:49","slug":"2024-07-14-ImplementingText-To-SpeechFunctionalityForBlockNoteInNextJs","content":"\n\n## 와우: WYSIWYG 편집기로 텍스트 음성 변환 기능!\n\n로켓 과학을 해결했습니다! 물론 거짓말이에요. BlockNote에 텍스트 음성 변환 기능을 Next.Js에서 어떻게 구현할지 알아냈습니다. BlockNote를 모르시면, Next.js에서 WYSIWYG 편집기 문제에 대한 해결책을 발견한 기사를 읽어보세요.\n\n그러니까 읽어보세요. 하지만 여러분의 지식 부족함에도 불구하고, 저는 계속 이 기사를 쓸 겁니다. BlockNote를 아는 여러분은 이 기사로 들어가 봅시다. 출발!\n\n![이미지](/TIL/assets/img/2024-07-14-ImplementingText-To-SpeechFunctionalityForBlockNoteInNextJs_0.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 요약\n\n우리는 블록을 HTML로 변환하여 Firebase에 BlockNote 데이터를 저장하는 방법을 배웠어요. 그 기사를 읽었다면 가상으로 엄지척을 할게요. 그럼, 코드는 지금 이렇게 보일 거예요:\n\n```js\n'use client';\nimport React, { useState, useEffect, useRef, ChangeEvent, useCallback } from 'react';\nimport { useSearchParams } from 'next/navigation';\nimport { firestore } from '../../../../../firebase';\nimport { getDoc, doc, updateDoc } from 'firebase/firestore';\nimport \"@blocknote/core/fonts/inter.css\";\nimport { useCreateBlockNote } from \"@blocknote/react\";\nimport { BlockNoteView } from \"@blocknote/mantine\";\nimport \"@blocknote/mantine/style.css\";\nimport { Block } from \"@blocknote/core\";\n\nfunction Document() {\n const params = useSearchParams();\n const docId = params.get(\"id\");\n const [title, setTitle] = useState('');\n const [value, setValue] = useState('');\n const [blocks, setBlocks] = useState<Block[]>([]);\n\n   useEffect(() => {\n   const fetchDocument = async () => {\n     if (!docId) return;\n\n     const docRef = doc(firestore, `documents/${docId}`);\n     try {\n       const docSnap = await getDoc(docRef);\n       if (docSnap.exists()) {\n         const data = docSnap.data();\n         setTitle(data.title || '');\n         setValue(data.content || '');\n       } else {\n         console.log('Document does not exist');\n       }\n     } catch (error) {\n       console.error('Error fetching document: ', error);\n     }\n   };\n\n   fetchDocument();\n }, [docId]);\n\n const editor = useCreateBlockNote();\n\n useEffect(() => {\n   async function loadInitialHTML() {\n     const blocks = await editor.tryParseHTMLToBlocks(value);\n     editor.replaceBlocks(editor.document, blocks);\n   }\n   loadInitialHTML();\n }, [editor, value]);\n\n const saveDocument = async () => {\n   if (!docId) return;\n\n   const content = await editor.blocksToHTMLLossy(blocks);\n\n   try {\n     await updateDoc(doc(firestore, `documents/${docId}`), {\n       content: content,\n     });\n\n     console.log('Document saved successfully');\n   } catch (error) {\n     console.error('Error saving document: ', error);\n   }\n };\n\n return (\n   <div>\n     <h1>{title}</h1>\n     <BlockNoteView editor={editor} onChange={() => { setBlocks(editor.document); }} />\n     <button onClick={saveDocument}>Save Document</button>\n   </div>\n );\n}\n\nexport default Document;\n```\n\n우리가 머릿속을 새롭게 한 이제, 뭔가 추가해봐요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 이것을 어떻게 할 건가요???\n\n좋은 질문이네요! 제가 떠올렸기 때문에 알고 있어요. 웹 스피치 API를 사용하여 텍스트 음성 변환 기능을 구현할 거에요.\n\n웹 스피치 API를 활용하면 음성 데이터를 웹 앱에 통합할 수 있어요. 이 경우는 Next.js 애플리케이션에서 사용할 거에요.\n\n이러한 종류의 기능을 추가하기 위해 SpeechSynthesis라고 불리는 Web 스피치 API의 인터페이스를 사용할 거에요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 구현\n\n우리의 코드에는 단지 한 가지 함수와 버튼을 추가하면 됩니다. 그게 다에요. 코드에 다음 함수를 추가하세요:\n\n```js\nfunction speak() {\n  const text = blocks\n  .map(block => block?.content)\n  .filter(content => content !== undefined)\n  .flatMap(content => {\n    if (Array.isArray(content)) {\n      return content\n        .filter(contentItem => contentItem.type === 'text')\n        .map(contentItem => contentItem.text);\n    } else {\n      return [];\n    }\n  })\n  .join(' ');\n  let utterance = new SpeechSynthesisUtterance(text);\n  let voicesArray = speechSynthesis.getVoices();\n  utterance.voice = voicesArray[2];\n  speechSynthesis.speak(utterance);\n}\n```\n\n이 함수는 문서에서 콘텐츠를 가져와서 콘텐츠가 텍스트 유형인 경우 에디터 내용을 말합니다. 간단하죠. 이제 '말하기' 버튼을 화면에 표시하세요:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```jsx\n<button onClick={speak}>Speak</button>\n```\n\n# 더 깊이 파고들기\n\n만약 음성 합성의 피치, 속도, 볼륨을 변경하여 사용자 정의하고 싶다면 어떻게 할까요? 잘하셨어요! 이제 이에 대해 알아볼게요. 이 뒤에 광고가 나와야죠! 농담이죠: 여기는 유튜브가 아니에요.\n\n피치 변경하기\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n음 높이를 조절하려면 이 줄을 추가하세요:\n\n```js\nutterance.pitch = 4; // 원하는 값으로 숫자를 변경하세요\n```\n\n속도 변경하기\n\n속도를 조절하려면 이 줄을 추가하세요:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nutterance.rate= 5; // 원하는 값으로 숫자를 변경해주세요\n```\n\n볼륨 조절하기\n\n```js\nutterance.volume= 0.4; // 원하는 값으로 소수를 변경해주세요\n```\n\n지금까지 코드에 텍스트 음성 변환 기능을 구현하는 단 기사를 마무리 지어보았습니다. 만약 이 기사가 도움이 되었다면 박수를 보내주세요, 팔로우를 눌러주세요, 또는 응답을 달아주세요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n행복한 코딩하세요!","ogImage":{"url":"/TIL/assets/img/2024-07-14-ImplementingText-To-SpeechFunctionalityForBlockNoteInNextJs_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-ImplementingText-To-SpeechFunctionalityForBlockNoteInNextJs_0.png","tag":["Tech"],"readingTime":7},{"title":"초보자를 위한 TypeScript 데이터 구조 배우기 Part 2","description":"","date":"2024-07-14 20:48","slug":"2024-07-14-LearningDataStructureinTypeScriptforBeginnerPart2","content":"\n\n<img src=\"/TIL/assets/img/2024-07-14-LearningDataStructureinTypeScriptforBeginnerPart2_0.png\" />\n\n# 소개\n\n이전 글에서 기본 데이터 구조에 대해 논의했습니다.\n\n- 이 글에서는 몇 가지 일반적인 데이터 구조 (연결 리스트, 큐, 스택, 해시 테이블, 이진 트리, 이진 힙)의 JavaScript 구현을 살펴보았습니다.\n- 이 시리즈에서는 프린스턴의 기본 데이터 구조에 대한 구체적인 내용을 Java 구현을 통해 배웠습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n기본 데이터 구조 이외에도 여전히 유용한 데이터 구조가 있습니다. 이러한 데이터 구조들은 우리 애플리케이션의 성능을 향상시키는 데 도움이 될 수 있습니다.\n\n## 안내\n\n본 글에서는 두 가지 데이터 구조를 고려하여 실제 프론트엔드 애플리케이션 사례를 개선해보겠습니다.\n\n- Trie (접두사 트리)\n- 그래프 — 인접 리스트 표현\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 1. Trie (접두사 트리)\n\n다음 스크린샷은 자동 완성 검색 바에서 가져온 것입니다. 제가 배열에 단어들을 넣어 후보 제시 항목으로 사용했어요. 실제로 목록에서 단어를 검색할 때 성능이 아주 좋지 않다고 해요. (소스 코드를 확인해주세요)\n\n성능을 향상시킬 수 있는 방법이 있을까요?\n\n<img src=\"/TIL/assets/img/2024-07-14-LearningDataStructureinTypeScriptforBeginnerPart2_1.png\" />\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 위 케이스의 원본 솔루션은 후보 항목을 배열에 저장하는 것입니다. 배열을 필터링하여 동일한 접두사를 가진 항목을 검색하는 데 걸리는 시간은 O(L)입니다. 여기서 L은 배열의 길이입니다.\n- 성능을 개선하기 위해 후보 항목을 Trie 구조에 저장할 수 있습니다. 이 경우 단어의 길이를 나타내는 n에 대해 O(n)이 걸립니다.\n\n## Trie의 정의\n\n![Trie 구조 이미지](/TIL/assets/img/2024-07-14-LearningDataStructureinTypeScriptforBeginnerPart2_2.png)\n\n## 구현 방법\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nTypeScript에서 어떻게 작동하는지 확인해 보겠습니다.\n\n1. TrieNode 구조 만들기\n\n- 역할\n  - 1. HashTable을 사용하여 자식을 효율적으로 저장, 검색 및 나열함 (O(1))\n  - 2. addChild는 쉽게 단일 가지를 탐색할 수 있도록 자식을 반환해야 함\n  - 3. 문자가 단어의 끝인 경우 isCompleted를 true로 표시합니다. 그 노드 아래에 새로운 자식이 추가될 때 업데이트됩니다.\n\n2. Trie 구조 만들기\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 책임\n- TrieNode의 인스턴스를 소유하여 단어 삽입, 단어 검색 및 특정 접두사로 단어 확인 수행\n\n2. Trie에 단어 삽입\n\n- addWord는 자식을 재귀적으로 추가하는 것을 목표로 한다.\n- 이는 연결 리스트를 탐색하는 방법과 유사하다. 자식을 추가하고 입력 문자열의 끝에 도달할 때까지 포인터를 자식으로 이동시킨다.\n- 성능\n- 시간 복잡도: O(n), n은 단어의 길이이다.\n- 공간 복잡도: O(1)\n\n3. Trie에서 단어 검색\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- getLastCharacterNode 함수는 입력 문자열의 끝에 도달했을 때에만 노드를 검색하고, 그 외의 경우에는 null을 반환합니다.\n- 성능\n- 시간 복잡도: O(n), 여기서 n은 문자열의 길이입니다.\n- 공간 복잡도: O(1)\n\n4. Trie에서 단어 검색하기 (DFS 사용)\n\n- getLastCharacterNode를 사용하여 검색하는 단점은 다음 자식 노드를 찾을 수 없다면 작동을 멈출 수 있다는 것입니다.\n- 예를 들어, abc를 삽입한 후 a.c인 경우 true를 반환해야 하는 새로운 요구 사항이 있다고 가정해보겠습니다.\n- 대안적인 해결책은 다음 글자가 .인 경우에는 모든 다음 자식을 시도하는 것입니다.\n\n5. Trie에서 특정 접두어를 가진 단어가 있는지 확인하기\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 마지막 문자 노드를 얻은 후 getSuggestedNextCharacters 목록의 자식 키\n- 성능\n- 시간 복잡성: O(n), n은 단어의 길이입니다.\n- 공간 복잡성: O(1)\n\n## 2. 그래프 — 인접 리스트 표현\n\n그래프 시각화 예시가 있습니다. 이 그래프를 탐색하는 새로운 요구 사항이 있다면 우리 코드의 성능이 나빠질 수 있습니다. (소스 코드 확인)\n\n성능을 향상시킬 방법이 있을까요?\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![이미지](/TIL/assets/img/2024-07-14-LearningDataStructureinTypeScriptforBeginnerPart2_3.png)\n\n- 현재 소스 코드에는 순회 알고리즘이 구현되어 있지 않습니다. 만약 구현해야 한다면, O(V * E)가 걸릴 것입니다. 여기서 V는 노드의 수이고, E는 간선의 수입니다(각 노드마다 해당 노드의 이웃 노드를 얻기 위해 모든 간선을 확인해야 합니다).\n- 성능을 개선하기 위해 데이터 구조를 재구성하고 인접 리스트를 만듭니다. 이는 O(V + E)가 소요됩니다. 여기서 V는 노드의 수이고, E는 그래프 순회에 필요한 간선의 수입니다.\n\n## 정의\n\n![이미지](/TIL/assets/img/2024-07-14-LearningDataStructureinTypeScriptforBeginnerPart2_4.png)\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 구현\n\nTypeScript에서 어떻게 작동하는지 확인해 봐요.\n\n1. Edge 구조체를 만들기\n\n- Edge는 두 개의 노드 사이의 연결이에요\n- 역할\n    - 노드와의 관계 확인: hasSourceNode 및 hasTargetNode는 노드가 Edge의 일부인지 아닌지 확인할 수 있어요 (라인 14 ~ 20)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2. 노드 구조 생성하기\n\n- 노드는 엣지의 출발지 또는 도착지입니다.\n- 책임\n  - 1. 링크드 리스트를 사용하여 이웃 엣지를 효율적으로 저장 및 검색합니다 (O(n)) (라인 26 ~ 42)\n  - 2. 노드와의 관계를 기반으로 차수, 인바운드 차수, 아웃바운드 차수를 제공합니다 (라인 8 ~ 20)\n\n3. 그래프 구조\n\n- 그래프는 노드와 엣지로 이루어진 비선형 데이터 구조입니다.\n- 책임\n  - 1. 노드와 엣지를 저장합니다.\n  - 2. 노드와 엣지에 대한 작업을 수행합니다 (예: 추가, 탐색 등).\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n4. 그래프 순회\n\n두 가지 종류의 순회가 있습니다. 너비 우선 탐색 (라인 7~31)과 깊이 우선 탐색 (라인 36~51).\n\n- 목적:\n- BFS: 다음 레이어 방문 전에 모든 이웃을 걸어다닌다\n- DFS: 모든 이웃을 걸어다니기 전에 가장 먼 레이어에 도착\n- 시간 복잡도:\n- BFS, 너비 우선 탐색: O(V + E), V는 노드 수, E는 간선 수\n- DFS, 깊이 우선 탐색: O(V + E), V는 노드 수, E는 간선 수\n- 공간 복잡도:\n- BFS, 너비 우선 탐색: O(V), V는 노드 수\n- DFS, 깊이 우선 탐색: O(V), V는 노드 수\n\n# 참고\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Trie 데이터 구조 이해하기\n- 해시 테이블 대 트라이 (접두사 트리)\n- 트라이 데이터 구조 | 삽입 및 검색\n- 그래프 알고리즘 재방문\n- 그래프\n\n# 요약\n\n기다려 주셔서 감사합니다. 저는 션입니다. 소프트웨어 엔지니어로 일하고 있어요.\n\n이 글은 제 노트입니다. 만약에 어떤 실수가 있다면 자유롭게 조언해주세요. 당신의 피드백을 기다리고 있어요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 저를 구독해 주세요\n\n- 기사를 공유하는 페이스북 페이지\n\n- 최신 사이드 프로젝트: 매일 학습\n\n# 관련 주제\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n두방향 바인딩을 Knout.js와 ReactJS에서 어떻게 사용하는지 알아보세요!\n\nSignalR을 사용하여 채팅방 애플리케이션을 만드는 방법을 배워보세요.\n\n'효과적인 SQL'에 대한 내 반성: \n\nIT 및 네트워크:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n데이터베이스:","ogImage":{"url":"/TIL/assets/img/2024-07-14-LearningDataStructureinTypeScriptforBeginnerPart2_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-LearningDataStructureinTypeScriptforBeginnerPart2_0.png","tag":["Tech"],"readingTime":9},{"title":"TypeScript 코드를 더 잘 쓰는 방법","description":"","date":"2024-07-14 20:46","slug":"2024-07-14-HowtowritebetterTypescriptcodes","content":"\n\n## TYPESCRIPT\n\n<img src=\"/TIL/assets/img/2024-07-14-HowtowritebetterTypescriptcodes_0.png\" />\n\n## #1 Optional Chaining (?.):\n\nOptional chaining(?.)은 중첩된 프로퍼티 또는 메소드에 안전하게 접근할 수 있게 해줍니다. null 또는 undefined 값에 대해 걱정할 필요가 없습니다. 중간 프로퍼티 중 하나라도 null 또는 undefined이면 평가가 중단됩니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nconst user = {\n  name: 'Piotr',\n  address: {\n    city: 'Warsaw',\n    postalCode: '00-240'\n  }\n};\n\n\nconst postalCode = user.address?.postalCode;\nconsole.log(postalCode); // 00-240\n\nconst invalidCode = user.address?.postalCode?.toLowerCase();\nconsole.log(invalidCode); // Output: undefined\n```\n\n## #2 Use Mapped Types for Transformation\n\nMapped types allow you to create new types by transforming properties of existing types.\n\n```js\ntype Readonly<T> = {\n  readonly [P in keyof T]: T[P];\n};\ntype Partial<T> = {\n  [P in keyof T]?: T[P];\n};\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## #3 유틸리티 유형\n\nTypeScript는 일반적인 유형 변환을 돕기 위해 여러 유틸리티 유형을 제공합니다.\n\ni) Partial`T`: 모든 속성을 선택적으로 만듭니다.\nii) Required`T`: 모든 속성을 필수로 만듭니다.\niii) Readonly`T`: 모든 속성을 읽기 전용으로 만듭니다.\niv) Record`K, T`: 키가 K이고 유형이 T인 유형을 생성합니다.\n\n```js\ntype Person = {\n  name: string;\n  age: number;\n};\ntype PartialPerson = Partial<Person>;\ntype ReadonlyPerson = Readonly<Person>;\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## #4 타입 가드\n\n타입 가드를 사용하여 조건 블록 내에서 타입을 좁힐 수 있습니다.\n\n```js\nfunction isString(value: unknown): value is string {\n  return typeof value === 'string';\n}\n```\n\n## #5 템플릿 리터럴 타입\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n표 태그를 마크다운 형식으로 변경해주세요.\n\n\nTese allow you to create new string types by combining string literals.\n\n```js\ntype EventName = 'click' | 'hover';\ntype EventHandlerName = `${EventName}Handler`; // 'clickHandler' | 'hoverHandler'\n```\n\n## #6 Indexed Access Types\n\nUse indexed access types to extract the type of a property.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n유형 Person = { 이름: string; 나이: number };\n유형 NameType = Person['name']; // string\n```\n\n## #7 키 리매핑을 통한 Mapped Types\n\n새로운 유형을 생성하는 동안 키를 변환합니다.\n\n```js\n유형 PrefixKeys<T, P extends string> = {\n  [K in keyof T as `${P}${K & string}`]: T[K]\n};\n유형 PrefixedPerson = PrefixKeys<{ 이름: string; 나이: number }, 'prefix_'>;\n// { prefix_name: string; prefix_age: number }\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## #8 공용체\n\n이들은 서로 다른 유형의 조합을 만들고 유형 안전한(타입 세이프) 공용체를 만드는 데 도움을 줍니다.\n\n```js\ntype Shape =\n  | { kind: 'circle'; radius: number }\n  | { kind: 'square'; side: number };\n\nfunction getArea(shape: Shape) {\n  switch (shape.kind) {\n    case 'circle': return Math.PI * shape.radius ** 2;\n    case 'square': return shape.side ** 2;\n  }\n}\n```\n\n## #9 제네릭에서 추론된 유형\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n`infer`를 사용하여 조건형 내에서 타입을 추출하고 사용하세요.\n\n```js\ntype ReturnType<T> = T extends (...args: any[]) => infer R ? R : any;\ntype Fn = () => number;\ntype Result = ReturnType<Fn>; // number\n```\n\n## #10 모듈 확장\n\n기존 모듈에 새로운 기능을 추가하세요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```typescript\n// augmentations.ts\nimport 'express';\ndeclare module 'express' {\n  interface Request {\n    user?: { id: string; role: string };\n  }\n}\n```\n\n## #11 Declare Merged Interfaces\n\nMerge interfaces to extend types, especially useful with third-party libraries.\n\n```typescript\ninterface Window {\n  myCustomProperty: string;\n}\nwindow.myCustomProperty = 'Hello!';\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## #12 기능 오버로딩\n\n더 나은 유형 확인을 위해 여러 함수 시그니처를 제공합니다.\n\n```js\nfunction createDate(timestamp: number): Date;\nfunction createDate(year: number, month: number, day: number): Date;\nfunction createDate(x: number, y?: number, z?: number): Date {\n  return y !== undefined && z !== undefined ? new Date(x, y, z) : new Date(x);\n}\n```\n\n## #13 브랜드된 타입\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n브랜드화된 타입을 사용하여 명목적 타이핑을 만들어봐요.\n\n```js\ntype UserId = string & { _brand: 'UserId' };\nfunction createUserId(id: string): UserId {\n  return id as UserId;\n}\n```\n\n## #14 템플릿 리터럴 타입과 컨디셔널 타입\n\n템플릿 리터럴 타입과 컨디셔널 타입을 결합하여 고급 문자열 조작을 해보세요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ntype ExtractRouteParams<T extends string> = T extends `/${infer Param}/${infer Rest}`\n  ? { param: Param } & ExtractRouteParams<`/${Rest}`>\n  : {};\n\ntype Params = ExtractRouteParams<'/user/:id/posts/:postId'>;\n// { param: 'user' } & { param: 'posts' }\n```\n\n#15 Variadic Tuple Types\n\nTypescript 4+는 가변 튜플 타입을 지원하여 튜플이 배열의 나머지 부분을 캡처할 수 있도록 합니다.\n\n```js\ntype Push<T extends any[], V> = [...T, V];\ntype Result = Push<[1, 2, 3], 4]; // [1, 2, 3, 4]\n```","ogImage":{"url":"/TIL/assets/img/2024-07-14-HowtowritebetterTypescriptcodes_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-HowtowritebetterTypescriptcodes_0.png","tag":["Tech"],"readingTime":8}],"page":"2","totalPageCount":34,"totalPageGroupCount":2,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}