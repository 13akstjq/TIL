{"pageProps":{"posts":[{"title":"Amazon Bedrock Agents 및 AI로 작업 자동화하는 방법","description":"","date":"2024-07-07 13:00","slug":"2024-07-07-AutomatingtasksusingAmazonBedrockAgentsandAI","content":"\n<img src=\"/TIL/assets/img/2024-07-07-AutomatingtasksusingAmazonBedrockAgentsandAI_0.png\" />\n\n## 서문\n\n👍 Amazon Bedrock Agents가 무엇인지 알아볼 거에요.\n👍 AWS 아키텍처를 자세히 살펴볼 거에요.\n👍 TypeScript 및 AWS CDK 코드를 살펴볼 거에요.\n👍 작동 방식을 보기 위해 몇 가지 테스트를 진행해 볼 거에요.\n\n# 소개 👋🏽\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAmazon Bedrock Agents은 당신이 회사 내에서 스스로 작업을 수행할 수 있는 자율 에이전트를 구축하고 사용자 정의할 수 있도록 도와줍니다. 이러한 에이전트는 기관 데이터와 사용자 입력을 활용하여 대화형 채팅과 AI를 이용해 작업을 수행하여 최종 사용자가 작업을 완료하는 데 도움을 줍니다.\n\n이들은 기본 모델, 데이터 소스, 지식베이스, 소프트웨어 응용 프로그램 및 사용자 대화 간의 상호작용을 관리하는 조정자 역할을 합니다. 추가로, 이들은 API 호출을 자동화하여 조치를 수행하고 이러한 조치와 관련된 정보를 풍부하게 하는 지식 베이스에 접근합니다.\n\n![Automating tasks using Amazon Bedrock Agents and AI](/TIL/assets/img/2024-07-07-AutomatingtasksusingAmazonBedrockAgentsandAI_1.png)\n\n본 문서에서는 가상의 호텔 및 스파 회사인 LJ Resorts를 다루어 AWS 구조와 코드를 살펴보겠습니다. 우리의 고객은 당사 애플리케이션을 사용하여 호텔 숙박, 골프 세션 및 스파 치료를 한꺼번에 예약하거나 이용 가능한 치료 및 할인, 영업 시간과 같은 회사 정보를 요청할 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Image 1](/TIL/assets/img/2024-07-07-AutomatingtasksusingAmazonBedrockAgentsandAI_2.png)\n\nThe full code repository can be found here:\n\n👇 Before we go any further — please connect with me on LinkedIn for future blog posts and Serverless news [Lee James Gilmore](https://www.linkedin.com/in/lee-james-gilmore/)\n\n![Image 2](/TIL/assets/img/2024-07-07-AutomatingtasksusingAmazonBedrockAgentsandAI_3.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 아마존 베드락 에이전트란 무엇인가요? 🤖\n\n이제 아마존 베드락 에이전트에 대해 이야기해보겠습니다. 어떤 일을 하는지 알아보면서 시작해봅시다. 먼저 중요한 약어 몇 가지를 이해해 봅시다.\n\n## 약어\n\n시작하기 전에 약어 몇 가지와 그 의미에 대해 알아봅시다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n✔️ FM - 기본 모델\n\n✔️ 액션 그룹\n\n✔️ 지침\n\n🤖 \"고객이 호텔 객실, 스파 세션, 그리고 골프 예약을 도와주시고, 해당하는 날짜와 예약 유형에 따라 특별 혜택을 제공해 주세요. 예약을 완료하기 전에 오프닝 타임이나 가격에 대해 고객에게 안내하고, 호텔 정책을 고려해 주세요.\"\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Automating tasks using Amazon Bedrock Agents and AI](/TIL/assets/img/2024-07-07-AutomatingtasksusingAmazonBedrockAgentsandAI_4.png)\n\n## Amazon Bedrock 에이전트는 어떻게 작동하나요? 🤖\n\n아래 다이어그램에서 볼 수 있듯이, 우리는 고객의 입력부터 시작합니다. 이 입력은 프롬프트 스토어로 증가되어 세션 스토어에서 가져온 이전 대화 내용과 함께 바탕 모델을 호출하여 보강됩니다.\n\n다음으로 Orchestration prompt는 응답을 구문 분석하고 우리의 OpenAPI 사양 문서에 정의된 작업에 따라 액션 그룹 람다를 호출하며 Bedrock Knowledge Base에서 필요한 추가 정보를 가져옵니다. Orchestration이 완료되면 결과가 고객에게 반환됩니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/TIL/assets/img/2024-07-07-AutomatingtasksusingAmazonBedrockAgentsandAI_5.png)\n\n다음 섹션에서는 본문에서 무엇을 구축 중인지 살펴보겠습니다. 그러면 코드를 살펴보고 응용 프로그램을 배포하고 테스트할 수 있습니다.\n\n# 무엇을 만들고 있을까요? 🛠️\n\n그래, 이제 Amazon Bedrock와 함께 에이전트에 대해 깊이 파고들었으며 이론적으로 작동 방식을 이해했으니, 이제 이 글에서 무엇을 만들고 있는지 살펴봅시다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/TIL/assets/img/2024-07-07-AutomatingtasksusingAmazonBedrockAgentsandAI_6.png\" />\n\n저희는 이전 글에서 Amazon Bedrock Knowledge Bases에 대해 다뤘었는데, 해당 글은 여기에서 찾아볼 수 있어요:\n\n위 다이어그램에서 볼 수 있는 것은 다음과 같아요:\n\n- 고객이 자신의 프롬프트로 Lambda 함수 URL을 탭합니다.\n- 이는 쿼리 Lambda 함수를 호출하며, 이 함수는 다시 Amazon Bedrock 에이전트를 호출합니다.\n- 에이전트는 특정 회사 데이터를 사용한 배포된 Knowledge Base와 S3 버킷에 있는 OpenAPI 사억을 기반으로 한 Lambda 함수를 사용하여 고객의 작업을 완료하기 위해 다른 내부 시스템에 경로를 지정합니다 (여러 호출을 우리를 대신하여 조정할 것입니다).\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 고수준 아키텍처를 논의했으니, 다음 섹션에서 예시 상호작용을 살펴봅시다.\n\n# 상호작용이 어떻게 보일까요? ⛳\n\n아래 예시 상호작용을 살펴보면 고객이 에이전트와 채팅하는 모습을 볼 수 있습니다. 사실, 이는 실제 프롬프트와 출력값을 사용하여 우리의 예시 솔루션을 통해 실행된 것입니다:\n\nCustomer: “Hi, what special deals do you have on at the moment for hotels?”\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n에이전트: \"현재 이용 가능한 호텔 특별 할인은 다음과 같습니다: - 월요일 스테이케이션 특가: 객실 요금 20% 할인 (월요일만) - 급행 투숙 특가: 당일 예약 시 15% 할인 (화요일만) - 연박 할인: 3박 숙박 20% 할인 (수요일만) - 스위트 업그레이드: 익스큐티브 스위트 무료 업그레이드 (목요일만) - 주말 여행 패키지: 2박 숙박 10% 할인 (금요일만)\"\n\n고객: \"2024년 02월 25일에 호텔 객실을 예약하고 싶어요, 현재 무엇이 가능한가요?\"\n\n에이전트: \"2024년 02월 25일 이용 가능한 객실은 다음과 같습니다: - 101호 객실(스탠다드, $100): 퀸 사이즈 침대가 있는 아늑한 표준 객실 - 102호 객실(스탠다드, $100): 두 개의 더블 침대가 있는 넓은 표준 객실 - 103호 객실(디럭스, $150): 킹 사이즈 침대와 전망이 있는 호화로운 디럭스 객실 - 104호 객실(스위트, $200): 별도의 거실 공간과 침실이 있는 우아한 스위트 - 105호 객실(스탠다드, $90): ..생략..\"\n\n고객: \"2024년 02월 25일에 디럭스 객실을 $160에 예약할 수 있나요?\"\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n에이전트: \"2024년 2월 25일에 109호 객실을 예약해드렸습니다. 이 객실은 명품 욕실이 있는 디럭스 객실이며, 160달러입니다. 필요한 것이 있으면 언제든지 알려주세요!\"\n\n고객: \"어떤 스파 시술이 가능한가요?\"\n\n에이전트: \"오늘 가능한 스파 시술 목록입니다: — 스웨디시 마사지: 긴장을 완화하고 이완을 촉진하는 전신 마사지. 가격: 80달러 — 페이셜: 피부를 재생하고 활기를 되찾는 깊은 클렌징 페이셜. 가격: 70달러 — 핫 스톤 마사지: 가열된 돌을 사용한 치료적인 마사지로 근육을 진정시키고 혈류를 향상시킵니다. 가격: 90달러 — 아로마테라피: 아로마 향기로 편안함과 웰빙을 높이는 섬세한 마사지. 가격: 85달러 — ….'간략히 하기 위해 나머지 제거됨'\"\n\n고객: \"핫 스톤 마사지를 예약할 수 있나요?\"\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAgent: \"네, 오늘 당신을 위해 핫 스톤 마사지를 예약했어요. 이 치료 마사지는 가열된 돌을 사용하여 근육을 진정시키고 혈액 순환이 향상됩니다. 비용은 $90이에요. 더 필요한 게 있으면 언제든지 말해주세요!\"\n\nCustomer: \"골프의 영업 시간은 어떻게 되나요?\"\n\nAgent: \"LJ 리조트의 골프 영업 시간은 다음과 같아요: 월요일부터 금요일까지: 오전 9시 — 오후 6시 토요일 및 일요일: 오전 7시 — 오후 7시\"\n\nCustomer: \"해당 날에도 아침에는 골프 세션도 있나요?\"\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n에이전트: \"오늘 가능한 골프 세션을 확인해보니 아침 세션 하나가 있네요: 아침 티 타임: 아침에 멋진 전망과 함께 골프를 즐기세요. 비용: $80 이 아침 골프 세션을 예약해 드릴까요?\"\n\n고객: \"제가 $80에 그 날 골프 세션을 예약할 수 있을까요?\"\n\n에이전트: \"네, $80에 아침 골프 세션을 오늘 예약해 드렸습니다. 이 세션에서는 아침에 멋진 경치를 감상하며 골프를 즐길 수 있을 거예요. 더 필요한 사항이 있으시면 언제든지 말해 주세요!\"\n\n고객: \"제 예약의 총 비용이 얼마인가요?\"\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n에이전트: \"대화 기록을 기반으로 하면, 핫 스톤 마사지를 90달러에 예약하셨고, 아침 골프 세션을 80달러에 예약하셨습니다. 예약 총 비용은 90달러 + 80달러 = 170달러입니다.\"\n\n이것은 베드락 에이전트가 얼마나 강력한지 보여줍니다. 이것은 사람이 여러 시스템에 액세스해 고객과 직접 대면해야 하는 작업을 대체한 것입니다. 인공지능이 전체 프로세스를 자동화하는 데 사용되었습니다.\n\n이제 고객과 에이전트 간에 발생할 수있는 상호 작용을 살펴 보았으니, 주요 코드를 살펴 보겠습니다.\n\n# 주요 코드 설명하기 👨‍💻\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n알겠어요, 우리는 이 기본 예제를 실제로 본 것이고, 이제 TypeScript 및 CDK 코드를 살펴보겠습니다. 전체 솔루션은 여기에서 찾으실 수 있습니다.\n\n## Stateful Stack\n\n먼저 상태 유지 스택부터 시작해봅시다. 여기서 먼저 에이전트 람다 함수를 생성합니다:\n\n```js\n// create the lambda for the agent - this is the lambda that determines\n// what the prompt looks like with regards to mapping to the schema\nconst actionGroupAgentLambda: nodeLambda.NodejsFunction = new nodeLambda.NodejsFunction(this, \"AgentLambda\", {\n  functionName: \"action-group-executor\",\n  runtime: lambda.Runtime.NODEJS_20_X,\n  entry: path.join(__dirname, \"./src/adapters/primary/action-group-executor/action-group-executor.adapter.ts\"),\n  memorySize: 1024,\n  handler: \"handler\",\n  timeout: cdk.Duration.minutes(5),\n  description: \"action group lambda function\",\n  architecture: lambda.Architecture.ARM_64,\n  tracing: lambda.Tracing.ACTIVE,\n  bundling: {\n    minify: true,\n  },\n  environment: {\n    ...lambdaConfig,\n  },\n});\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음은 아래에 표시된대로 우리의 Amazon Bedrock 에이전트를 생성합니다:\n\n```js\n// bedrock 에이전트 생성\nconst agent = new bedrock.Agent(this, \"BedrockAgent\", {\n  name: \"에이전트\",\n  description: \"호텔, 스파 및 골프 예약을 위한 에이전트입니다.\",\n  foundationModel: bedrock.BedrockFoundationModel.ANTHROPIC_CLAUDE_V2,\n  instruction:\n    \"고객이 호텔 객실, 스파 세션 및 골프 예약을 도와주셔서 감사하겠습니다. 그들에게 요일 및 예약 유형에 따라 특별 제공상품에 대해 알려주시고, 예약을 완료하기 전에 오픈 시간이나 가격을 안내해주시고, 또한 호텔 정책을 고려해주시기 바랍니다.\",\n  idleSessionTTL: cdk.Duration.minutes(10),\n  knowledgeBases: [kb],\n  shouldPrepareAgent: true,\n  aliasName: \"에이전트\",\n});\n```\n\n위의 코드에서 보듯이, 에이전트에게 세션 지속 시간, Amazon Bedrock 지식 베이스에 대한 링크, FM 유형(Claud V2) 및 이 에이전트가 수행해야 할 작업에 대한 지시 사항과 같은 주요 속성들을 지정합니다.\n\n다음으로, 아래와 같이 Action 그룹을 생성합니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n// 예약을 위한 동작 그룹을 추가합니다.\nnew bedrock.AgentActionGroup(this, \"AgentActionGroup\", {\n  actionGroupName: \"agent-action-group\",\n  description: \"예약을 위한 동작 그룹\",\n  agent: agent,\n  apiSchema: bedrock.S3ApiSchema.fromAsset(path.join(__dirname, \"./schema/api-schema.json\")),\n  actionGroupState: \"ENABLED\",\n  actionGroupExecutor: actionGroupAgentLambda,\n  shouldPrepareAgent: true,\n});\n```\n\n우리는 에이전트가 할 수 있는 것을 상세히 설명하는 Open API 스키마와 동작에 대한 프록시로 호출되는 람다 함수를 제공한다는 것을 알 수 있습니다. 이제 Open API 사양이 어떻게 보이는지 살펴보겠습니다:\n\n```js\n{\n  \"openapi\": \"3.0.0\",\n  \"info\": {\n    \"title\": \"LJ 리조트를 위한 호텔, 스파 및 골프 예약 API\",\n    \"version\": \"1.0.0\",\n    \"description\": \"고객의 호텔, 스파 및 골프 예약을 관리하기 위한 API입니다.\"\n  },\n  \"paths\": {\n    \"/rooms\": {\n      \"get\": {\n        \"summary\": \"이용 가능한 모든 객실 목록을 가져옵니다\",\n        \"description\": \"특정 날짜에 이용 가능한 모든 객실 목록을 가져옵니다\",\n        \"operationId\": \"getAllAvailableRooms\",\n        \"responses\": {\n          \"200\": {\n            \"description\": \"특정 날짜에 이용 가능한 모든 객실 목록을 가져옵니다\",\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"type\": \"array\",\n                  \"items\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"roomId\": {\n                        \"type\": \"string\",\n                        \"description\": \"객실의 고유 ID입니다.\"\n                      },\n                      \"roomType\": {\n                        \"type\": \"string\",\n                        \"description\": \"객실 유형입니다.\"\n                      },\n                      \"roomDescription\": {\n                        \"type\": \"string\",\n                        \"description\": \"객실 설명입니다.\"\n                      },\n                      \"date\": {\n                        \"type\": \"string\",\n                        \"description\": \"객실 예약 가능한 날짜입니다.\"\n                      },\n                      \"cost\": {\n                        \"type\": \"string\",\n                        \"description\": \"객실 비용(1박당)입니다.\"\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      },\n      \"post\": {\n        \"summary\": \"특정 날짜에 이용 가능한 객실을 예약합니다\",\n        \"description\": \"특정 날짜에 객실을 예약합니다\",\n        \"operationId\": \"bookRoom\",\n        \"requestBody\": {\n          \"required\": true,\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"type\": \"object\",\n                \"properties\": {\n                  \"roomId\": {\n                    \"type\": \"string\",\n                    \"description\": \"예약할 객실의 ID입니다\"\n                  },\n                  \"date\": {\n                    \"type\": \"string\",\n                    \"description\": \"객실 예약 날짜입니다\"\n                  }\n                },\n                \"required\": [\"roomId\", \"date\"]\n              }\n            }\n          }\n        },\n        \"responses\": {\n          \"200\": {\n            \"description\": \"객실 예약 성공\"\n          }\n        }\n      }\n    },\n    \"/spa-sessions\": {\n      ...\n    },\n    \"/golf-sessions\": {\n      ...\n    }\n  }\n}\n```\n\n모델이 수행해야 할 작업을 결정하는 중요한 부분은 설명, 경로, 메서드 및 작업 ID입니다. 예를 들어, 모든 호텔 객실을 나열하기 위해 사용하는 것은 다음과 같습니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n**Description** - \"특정 날짜에 대한 모든 이용 가능한 객실 목록을 가져옵니다\".\n**OperationId** - \"getAllAvailableRooms\".\n**Path** - ‘/rooms’.\n**Method** - ‘GET’.\n\n우리의 람다 함수가 호출되면 해당 세부 정보를 활용하여 호출해야 하는 다른 시스템을 결정합니다:\n\n```js\nimport { MetricUnits, Metrics, logMetrics } from \"@aws-lambda-powertools/metrics\";\nimport { Tracer, captureLambdaHandler } from \"@aws-lambda-powertools/tracer\";\nimport { golfSessions, rooms, spaTreatments } from \"stateful/src/data\";\n\nimport { injectLambdaContext } from \"@aws-lambda-powertools/logger\";\nimport middy from \"@middy/core\";\nimport { logger } from \"@shared/index\";\n\nconst tracer = new Tracer();\nconst metrics = new Metrics();\n\nexport const adapter = async ({\n  inputText,\n  apiPath,\n  httpMethod,\n  actionGroup,\n  messageVersion,\n  requestBody,\n  sessionAttributes,\n  promptSessionAttributes,\n}: Event): Promise<Response> => {\n  let body;\n  let httpStatusCode = 200;\n\n  try {\n    logger.info(`inputText: ${inputText}, apiPath: ${apiPath}, httpMethod: ${httpMethod}`);\n\n    // 참고: 실제로는 람다 FURLS 또는 다른 DB 또는 API/서비스를 호출할 것이지만,\n    // 작동 방식을 보여주기 위해 기사용 가짜 스텁 데이터를 사용합니다.\n    switch (apiPath) {\n      case \"/rooms\":\n        if (httpMethod === \"GET\") {\n          body = rooms;\n        } else if (httpMethod === \"POST\") {\n          body = rooms.find((room) => room.roomId === \"109\");\n        }\n        break;\n\n      case \"/spa-sessions\":\n        if (httpMethod === \"GET\") {\n          body = spaTreatments;\n        } else if (httpMethod === \"POST\") {\n          body = spaTreatments.find((treatment) => treatment.treatmentId === \"3\");\n        }\n        break;\n\n      case \"/golf-sessions\":\n        if (httpMethod === \"GET\") {\n          body = golfSessions;\n        } else if (httpMethod === \"POST\") {\n          body = golfSessions.find((session) => session.sessionId === \"1\");\n        }\n        break;\n\n      default:\n        httpStatusCode = 500;\n        body = \"Sorry, I am unable to help you with that. Please try asking the question in a different way perhaps.\";\n        break;\n    }\n\n    metrics.addMetric(\"SuccessfulActionGroupQuery\", MetricUnits.Count, 1);\n\n    return {\n      messageVersion,\n      response: {\n        apiPath,\n        actionGroup,\n        httpMethod,\n        httpStatusCode,\n        sessionAttributes,\n        promptSessionAttributes,\n        responseBody: {\n          \"application-json\": {\n            body: JSON.stringify(body),\n          },\n        },\n      },\n    };\n  } catch (error) {\n    let errorMessage = \"Unknown error\";\n    if (error instanceof Error) errorMessage = error.message;\n    logger.error(errorMessage);\n\n    metrics.addMetric(\"ActionGroupQueryError\", MetricUnits.Count, 1);\n\n    throw error;\n  }\n};\n\nexport const handler = middy(adapter)\n  .use(injectLambdaContext(logger))\n  .use(captureLambdaHandler(tracer))\n  .use(logMetrics(metrics));\n```\n\n위의 예제에서는 다른 시스템을 호출하는 대신 반환된 데이터를 간단히 하드코딩했음을 볼 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![스테이트리스 스택](/TIL/assets/img/2024-07-07-AutomatingtasksusingAmazonBedrockAgentsandAI_7.png)\n\n이제 우리 에이전트를 쿼리하는 스테이트리스 스택을 살펴보겠습니다.\n\n## 스테이트리스 스택\n\n먼저 스트리밍이 설정된 쿼리 람다 함수를 생성합니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n// 에이전트 쿼리를 위한 람다 함수를 생성합니다.\nconst queryModelLambda: nodeLambda.NodejsFunction = new nodeLambda.NodejsFunction(this, \"QueryModelLambda\", {\n  functionName: \"query-model-lambda\",\n  runtime: lambda.Runtime.NODEJS_20_X,\n  entry: path.join(__dirname, \"./src/adapters/primary/query-model/query-model.adapter.ts\"),\n  memorySize: 1024,\n  handler: \"handler\",\n  timeout: cdk.Duration.minutes(3),\n  description: \"쿼리 모델 람다 함수\",\n  architecture: lambda.Architecture.ARM_64,\n  tracing: lambda.Tracing.ACTIVE,\n  bundling: {\n    minify: true,\n  },\n  environment: {\n    AGENT_ID: agentId,\n    AGENT_ALIAS_ID: agentAliasId,\n    ...lambdaConfig,\n  },\n});\n\n// 쿼리 람다에 대한 함수 URL을 스트림 응답으로 추가합니다.\nconst queryModelLambdaUrl = queryModelLambda.addFunctionUrl({\n  authType: lambda.FunctionUrlAuthType.NONE,\n  invokeMode: lambda.InvokeMode.RESPONSE_STREAM,\n  cors: {\n    allowedOrigins: [\"*\"],\n  },\n});\n```\n\n그런 다음, 아래와 같이 에이전트 호출 권한을 부여합니다:\n\n```js\n// 쿼리 람다 함수가 모델/KB/에이전트를 쿼리할 수 있도록 허용합니다.\nqueryModelLambda.addToRolePolicy(\n  new iam.PolicyStatement({\n    actions: [\"bedrock:RetrieveAndGenerate\", \"bedrock:Retrieve\", \"bedrock:InvokeModel\", \"bedrock:InvokeAgent\"],\n    resources: [\"*\"],\n  })\n);\n```\n\n이제 사용자가 함수 URL을 통해 프롬프트를 제공하고 에이전트를 호출하는 Query Lambda 함수를 살펴보겠습니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport { MetricUnits, Metrics } from \"@aws-lambda-powertools/metrics\";\nimport {\n  BedrockAgentRuntimeClient,\n  InvokeAgentCommand,\n  InvokeAgentRequest,\n  InvokeAgentResponse,\n} from \"@aws-sdk/client-bedrock-agent-runtime\";\nimport { ResponseStream, streamifyResponse } from \"lambda-stream\";\n\nimport { config } from \"@config\";\nimport { ValidationError } from \"@errors/validation-error\";\nimport { logger } from \"@shared/index\";\nimport { APIGatewayProxyEventV2 } from \"aws-lambda\";\n\nconst metrics = new Metrics();\nconst client = new BedrockAgentRuntimeClient();\n\nconst agentId = config.get(\"agentId\");\nconst agentAliasId = config.get(\"agentAliasId\");\n\nfunction parseBase64(message: Uint8Array): string {\n  return Buffer.from(message).toString(\"utf-8\");\n}\n\nexport const queryModelAdapter = async (\n  { body }: APIGatewayProxyEventV2,\n  responseStream: ResponseStream\n): Promise<void> => {\n  try {\n    responseStream.setContentType(\"application/json\");\n\n    if (!body) throw new ValidationError(\"no payload body\");\n    const request = JSON.parse(body);\n\n    const { sessionAttributes, promptSessionAttributes, sessionId, prompt } = request;\n\n    const input: InvokeAgentRequest = {\n      sessionState: {\n        sessionAttributes,\n        promptSessionAttributes,\n      },\n      agentId,\n      agentAliasId,\n      sessionId,\n      inputText: prompt,\n    };\n\n    const command: InvokeAgentCommand = new InvokeAgentCommand(input);\n    const response: InvokeAgentResponse = await client.send(command);\n\n    const chunks = [];\n    const completion = response.completion || [];\n\n    for await (const chunk of completion) {\n      if (chunk.chunk && chunk.chunk.bytes) {\n        const parsed = parseBase64(chunk.chunk.bytes);\n\n        chunks.push(parsed);\n      }\n    }\n\n    const returnMessage = {\n      sessionId: response.sessionId,\n      contentType: response.contentType,\n      message: chunks.join(\" \"),\n    };\n\n    metrics.addMetric(\"SuccessfulQueryModel\", MetricUnits.Count, 1);\n\n    // Note: In the example we are not streaming, we are using the FURL request timeout feature\n    // but we could easily write the stream during the for loop if we wanted to\n    responseStream.write(returnMessage);\n    responseStream.end();\n  } catch (error) {\n    let errorMessage = \"Unknown error\";\n    if (error instanceof Error) errorMessage = error.message;\n    logger.error(errorMessage);\n\n    metrics.addMetric(\"QueryModelError\", MetricUnits.Count, 1);\n\n    responseStream.end();\n    throw error;\n  }\n  responseStream.end();\n};\n\nexport const handler = streamifyResponse(queryModelAdapter);\n```\n\n위의 코드에서는 에이전트로부터 반환된 응답을 'chunks'로 스트림으로 전송하고 있습니다. 그러나 이 예제에서는 사용자에게 실시간으로 업데이트를 제공하지 않고 완료될 때까지 기다린 후 JSON 객체로 응답합니다. 이제 다음 섹션에서 이를 테스트해보겠습니다!\n\n# 어플리케이션 테스트 🧪\n\n## Postman을 통한 테스트하기\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n당신은 postman/Bedrock Agents.postman_collection.json 파일을 사용하여 자신의 Lambda 함수 URL 정보로 테스트할 수 있습니다.\n\n다음과 같은 예시 JSON 페이로드를 사용하여 테스트할 수 있습니다:\n\n```js\n{\n  \"agentId\": \"agentId\",\n  \"agentAliasId\": \"agentAliasId\",\n  \"sessionId\": \"1f6aa00e-e585-49aa-aa2d-16adb64857c6\",\n  \"prompt\": \"Can I please book a morning golf session on 2024-02-25\"\n}\n```\n\n그리고 우리의 에이전트가 다음과 같이 응답하는 것을 확인할 수 있습니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리 에이전트는 여러 가지 작업을 조정했습니다. 첫 번째로 그날 이용할 수 있는 골프 세션을 확인하는 것이었습니다.\n\n에이전트는 먼저 '/golf-sessions/'에 'GET'을 실행해야 한다고 결정했는데, 이렇게 하면 그 날 이용 가능한 모든 골프 세션이 반환됩니다.\n\n그런 다음 예약을 하기 위해 '/golf-sessions/'에 두 번째 작업 'POST'를 연이어 실행했습니다.\n\n여기서 대화형 AI의 힘과 자율 에이전트의 역할을 볼 수 있습니다. 고객을 지원하기 위해 여러 가지 작업을 조합했습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/TIL/assets/img/2024-07-07-AutomatingtasksusingAmazonBedrockAgentsandAI_8.png)\n\n지금은 다른 시나리오에서도 이를 테스트할 수 있어요. 예를 들면 거래 확인, 스파 세션 예약 등등! 댓글에서 솔루션을 어떻게 찾았는지 알려주세요!\n\n# 마무리 인사 👋🏽\n\n이 글을 즐겨 읽어주셨기를 바랍니다. 만약 즐겁게 읽었다면 공유하고 피드백 주세요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n비슷한 콘텐츠를 위해 내 YouTube 채널을 구독해주세요!\n\n![Automating tasks using Amazon Bedrock Agents and AI](/TIL/assets/img/2024-07-07-AutomatingtasksusingAmazonBedrockAgentsandAI_9.png)\n\n아래의 링크를 통해 연락하고 싶어요:\n\n[LinkedIn - Lee James Gilmore](https://www.linkedin.com/in/lee-james-gilmore/)\n[Twitter - Lee James Gilmore](https://twitter.com/LeeJamesGilmore)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n게시물을 즐겁게 보셨다면 더 많은 게시물/시리즈를 보려면 내 프로필 Lee James Gilmore를 팔로우해주세요! 또한 인사를 건네고 Hi를 말하는 것을 잊지 마세요 👋\n\n게시물 하단의 '박수' 기능도 사용해보세요. 만약 게시물을 즐겼다면 '박수'를 또 클릭할 수 있습니다!!\n\n# 자기소개\n\n\"안녕하세요, 저는 영국을 기반으로 하는 AWS 커뮤니티 빌더, 블로거, AWS 인증 클라우드 아키텍트이자 기술 및 아키텍처 부문 글로벌 팀장 Lee입니다. 현재는 City Electrical Factors(UK) & City Electric Supply(US)에서 근무 중이며, 지난 6년 동안 주로 AWS 상에서 full-stack JavaScript로 작업해 왔습니다.\"\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저는 AWS를 사랑하는 서버리스 선구자라고 생각해요. 혁신, 소프트웨어 아키텍처, 그리고 기술에 대한 모든 것을 좋아해요.\n\n** 제공된 정보는 제 개인적인 견해이며, 해당 정보 사용에 대한 책임을 지지 않습니다. **\n\n아래 내용도 참고해보세요:\n","ogImage":{"url":"/assets/img/2024-07-07-AutomatingtasksusingAmazonBedrockAgentsandAI_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-AutomatingtasksusingAmazonBedrockAgentsandAI_0.png","tag":["Tech"],"readingTime":26},{"title":"드래그 앤 드롭 Nextjs 프로젝트에 커스텀 아이템 추가하는 방법","description":"","date":"2024-07-07 12:59","slug":"2024-07-07-AddingCustomDraggableItemsToDrag-And-DropNextJsProject","content":"\n## 이전 글의 연속입니다.\n\n만약 여러분이 Medium 회원이 아니라면, 이 기사를 여기서 읽을 수 있습니다. [niftylittleme.com](https://niftylittleme.com)로 이동하세요.\n\n참고: 이 기사는 Next.js 앱 라우터를 사용합니다.\n\n이전 글을 읽거나 살펴본 적이 있다면, 여러분의 프로젝트에 드래그 앤 드롭 기능이 있을 것입니다. 그러나 만약 작은 상자가 아닌 다른 것들을 드래그 앤 드롭하고 싶다면 어떻게 할까요? 실제로 엘리먼트를 드래그 앤 드롭하고 싶다면요? 뭔가 더 멋진 것을 원한다면, 이 튜토리얼은 여러분을 위한 것입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 시작하기 전에 여기서 정확히 무엇을 하는지 이해하려면 이전 기사를 읽어야 합니다. 그래서 그것을 확인하고 돌아와주세요. 여러분과 공유할 많은 코드가 있습니다. 그러니 함께 시작해봅시다!\n\n![이미지](/TIL/assets/img/2024-07-07-AddingCustomDraggableItemsToDrag-And-DropNextJsProject_0.png)\n\n# 이전 프로그래밍 팁에서\n\n드래그 앤 드롭 라이브러리와 킷들이 별로 구리다 보니, 우리는 Next.js 프로젝트에서 드래그 앤 드롭 기능을 처음부터 만들어야 했습니다. 드래그 가능한 항목들을 생성하고, 줌 인/아웃 기능이 있는 그리드 드롭 존을 만들었으며, 드래그 가능한 항목과 듭 존을 화면에 표시했습니다.\n","ogImage":{"url":"/assets/img/2024-07-07-AddingCustomDraggableItemsToDrag-And-DropNextJsProject_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-AddingCustomDraggableItemsToDrag-And-DropNextJsProject_0.png","tag":["Tech"],"readingTime":1},{"title":"Markdown에서 Angular 컴포넌트 렌더링 하는 방법","description":"","date":"2024-07-07 12:58","slug":"2024-07-07-RenderAngularComponentsinMarkdown","content":"\n먼저, `markdown-render` 컴포넌트를 설정하여 .md 파일을 렌더링할 것입니다. 그리고 Angular 컴포넌트를 렌더링하는 방법을 살펴볼 것입니다.\n\n# Markdown 렌더러\n\n필요한 종속성을 설치하세요:\n\n```js\nnpm i highlight.js marked marked-highlight\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 단계 1: markdown-renderer/highlight-code-block.ts 파일 생성\n\n이 함수는 마크다운 파일에서 코드를 강조 표시하는 데 사용됩니다.\n\n```js\nimport highlightJs from \"highlight.js\";\n\nexport function highlightCodeBlock(code: string, language: string | undefined) {\n  if (language) {\n    return highlightJs.highlight(code, {\n      language,\n    }).value;\n  }\n  return code;\n}\n```\n\n# 단계 2: markdown-renderer/transform-markdown.ts 파일 생성\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 기능은 Markdown을 HTML로 변환하는 데 사용될 것입니다.\n\n```js\nimport { marked } from \"marked\";\nimport { markedHighlight } from \"marked-highlight\";\nimport { highlightCodeBlock } from \"./highlight-code-block\";\n\nmarked.use(markedHighlight({ highlight: highlightCodeBlock }));\nexport const markdownToHtml = (content: string) => {\n  return marked(content);\n};\n```\n\n# 단계 3: markdown-renderer/markdown.service.ts 만들기\n\n이 서비스는 구성 요소에서 .md 파일을 로컬 또는 외부 위치에서 읽어 HTML로 변환하는 데 사용될 것입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport { HttpClient } from '@angular/common/http';\nimport { Injectable, inject } from '@angular/core';\nimport { map } from 'rxjs';\nimport { markdownToHtml } from './transform-markdown';\n@Injectable({\n  providedIn: 'root',\n})\nexport class MarkdownService {\n  private httpClient = inject(HttpClient);\n  htmlContent(src: string) {\n    return this.httpClient.get(src, { responseType: 'text' }).pipe(\n      map((markdownContent) => {\n        return markdownToHtml(markdownContent);\n      })\n    );\n  }\n}\n```\n\n# 단계 4: markdown-renderer/markdown-renderer.ts 파일 생성하기\n\n마지막으로, 마크다운 파일을 렌더링하는 데 사용할 수 있는 컴포넌트를 만듭니다.\n\n```js\nimport { Component, ElementRef, effect, inject, input } from '@angular/core';\nimport { MarkdownService } from './markdown.service';\nimport { take } from 'rxjs';\nimport highlightJs from 'highlight.js';\n\n@Component({\n  selector: 'markdown-renderer',\n  template: '문서 로딩 중...',\n  standalone: true,\n})\nexport class MarkdownRendererComponent {\n  src = input.required<string>();\n  textContent = '';\n  private _elementRef = inject<ElementRef>(ElementRef);\n  private markdownService = inject(MarkdownService);\n  constructor() {\n    effect(() => {\n      const src = this.src();\n      this.setDataFromSrc(src);\n    });\n  }\n  setDataFromSrc(src: string) {\n    this.markdownService\n      .htmlContent(src)\n      .pipe(take(1))\n      .subscribe((htmlContent) => {\n        this.updateDocument(htmlContent as string);\n      });\n  }\n  updateDocument(rawHTML: string) {\n    this._elementRef.nativeElement.innerHTML = rawHTML;\n    this.textContent = this._elementRef.nativeElement.textContent;\n    highlightJs.highlightAll();\n  }\n}\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 단계 5: HTTP 제공\n\n```js\nbootstrapApplication(App, {\n  providers: [provideHttpClient(withFetch())],\n});\n```\n\n# 단계 6: 사용법\n\n이제 어디에서든 markdown을 렌더링하고 싶을 때, 간단히 `markdown-renderer`를 사용하면 됩니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport { Component } from \"@angular/core\";\nimport { MarkdownRendererComponent } from \"./markdown-renderer/markdown-renderer\";\n@Component({\n  selector: \"article\",\n  standalone: true,\n  template: `<markdown-renderer src=\"/assets/article.md\"></markdown-renderer>`,\n  imports: [MarkdownRendererComponent],\n})\nexport class ArticleComponent {}\n```\n\n# 마크다운에 Angular 구성 요소 추가하기\n\n필요한 종속성 설치:\n\n```js\nnpm i @angular/elements\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 단계 1: custom-elements.service.ts 파일 만들기\n\n이 서비스는 Angular 구성 요소를 사용자 지정 요소로 변환하는 데 사용됩니다. 이렇게 하면 .md 파일에서 Angular 구성 요소를 쉽게 사용할 수 있습니다.\n\n```typescript\nimport { inject, Injectable, Injector } from \"@angular/core\";\nimport { createCustomElement } from \"@angular/elements\";\nimport { SubscribeComponent } from \"./components/subscribe\";\nimport { CounterComponent } from \"./components/counter\";\n\n@Injectable({ providedIn: \"root\" })\nexport class CustomElementsService {\n  private _injector = inject(Injector);\n\n  setupCustomElements() {\n    const subscribeElement = createCustomElement(SubscribeComponent, {\n      injector: this._injector,\n    });\n    customElements.define(\"subscribe-component\", subscribeElement);\n\n    const counterElement = createCustomElement(CounterComponent, {\n      injector: this._injector,\n    });\n    customElements.define(\"counter-component\", counterElement);\n  }\n}\n```\n\n# 단계 2: APP_INITIALIZER를 통해 setupCustomElements 호출하기\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n커스텀 요소를 초기화 단계에서부터 사용하고 싶기 때문에 APP_INITIALIZER를 사용할 것입니다.\n\n```js\nbootstrapApplication(App, {\n  providers: [\n    provideHttpClient(withFetch()),\n    {\n      provide: APP_INITIALIZER,\n      useFactory: initializeCustomElements,\n      multi: true,\n      deps: [CustomElementsService],\n    },\n  ],\n});\n```\n\n# 단계 3: 사용 방법\n\n마지막으로 파일에서 커스텀 요소를 사용하면 Angular 컴포넌트가 렌더링됩니다. 아래와 같이 간단히 사용할 수 있습니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n<subscribe-component></subscribe-component>\n<counter-component></counter-component>\n```\n\n# 코드\n\n# 자유 콘텐츠 생성 지원\n\n코스와 기사는 무료로 제공되지만, 최고 수준의 교육 콘텐츠를 전달하는 제 야망을 지원해 주시면 감사히 받아들일 것입니다. 기여를 결정하는 것은 계속해서 코스를 개선하고 추가 자료를 작성하며 이러한 자료에 대한 접근성을 유지하는 데 도움이 됩니다. 기여하고 의미 있는 변화를 만들어주시는 것에 감사드립니다!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Render Angular Components in Markdown](/TIL/assets/img/2024-07-07-RenderAngularComponentsinMarkdown_0.png)\n","ogImage":{"url":"/assets/img/2024-07-07-RenderAngularComponentsinMarkdown_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-RenderAngularComponentsinMarkdown_0.png","tag":["Tech"],"readingTime":8},{"title":"Nodejs 프로젝트에서 TypeScript 설정하는 방법","description":"","date":"2024-07-07 12:58","slug":"2024-07-07-TypeScriptsetupforNodejsproject","content":"\n![이미지](/TIL/assets/img/2024-07-07-TypeScriptsetupforNodejsproject_0.png)\n\n지난 몇 년 동안 저는 Angular를 사용하여 프런트엔드 애플리케이션을 작성해 왔는데, 이 기간 동안 TypeScript가 일반 JavaScript보다 강력함을 느꼈습니다. Svelte 앱을 구현할 때 Node.js 기반의 TypeScript를 사용하여 작은 백엔드 서비스도 개발했습니다. 이 작은 기사에서는 코딩 프로세스를 간소화하는 데 도움이 된 구성에 대해 설명하고 싶습니다.\n\n## 의존성\n\n### 빌드\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n개발할 때 잘 알려진 Express.js 프레임워크를 사용했어요. TypeScript와 함께 사용하려면 해당 타입 정의를 명시적으로 추가해야 하며 Node 자체에 대한 것도요. 그러면 어떤 Node.js 환경으로도 이식할 수 있는 JavaScript 번들 하나만 얻고 싶었어요. 모든 것을 하나의 파일로 묶기 위해 특별한 구성 없이 esbuild를 사용했어요. 이것만으로 애플리케이션을 빌드하는 데 필요한 것이 거의 다 준비된 거죠.\n\n## 개발\n\n개발 과정에서 몇 가지 요구 사항도 있었어요. 그중 하나는 파일이 변경될 때 애플리케이션을 다시 실행해야 한다는 점이에요. 프론트엔드 애플리케이션에서의 개발 서버에 익숙해져 있어서 그랬나 봐요. 또 다른 기능은 별칭을 사용하는 것이라 개발자로서 좀 더 편리하다고 생각해요.\n\nTypeScript로 작성된 Node.js 애플리케이션을 실행하려면 ts-node 실행 엔진이 필요해요. 코드가 변경된 후 애플리케이션을 다시 빌드하기 위해 nodemon이 필요해요. 물론 TypeScript도 설치해야 하고 별칭을 사용하려면 tsconfig-paths도 추가해야 해요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## package.json\n\n제 package.json에서 추출한 내용입니다:\n\n```js\n{\n  \"scripts\": {\n    \"start\": \"nodemon\",\n    \"build\": \"esbuild main.ts --bundle --platform=node --outfile=dist/app.js --analyze\"\n  },\n  \"dependencies\": {\n    \"express\": \"^4.18.2\"\n  },\n  \"devDependencies\": {\n    \"@types/express\": \"^4.17.17\",\n    \"@types/node\": \"^18.15.11\",\n    \"esbuild\": \"^0.17.16\",\n    \"nodemon\": \"^2.0.22\",\n    \"ts-node\": \"^10.9.1\",\n    \"tsconfig-paths\": \"^4.2.0\",\n    \"typescript\": \"^5.0.4\"\n  }\n}\n```\n\n의미 없는 부분은 건너뛰고 관련 있는 부분만 남겼습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 별칭 및 nodemon 설정\n\n## 구성\n\nTypeScript 컴파일러를 사용할 때는 tsconfig.json 파일에서 특정 디렉토리에 대한 별칭을 정의할 수 있습니다. 아래는 추출된 코드입니다:\n\n```js\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \"./\",\n  \"paths\": {\n    \"@app/*\": [\"src/*\"]\n    }\n  }\n}\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다른 컴파일러 옵션에 대해서는 대부분 기본값을 사용했습니다. 엔진 `ts-node`는 이 구성 파일을 사용하지만 별칭을 사용하려면 별칭을 관리하는 모듈을 명시적으로 로드하도록 Node.js에 알려주어야 합니다. 이는 다음과 같이 `tsconfig.json` 안에서 수행할 수 있습니다:\n\n```js\n{\n \"ts-node\": {\n   \"require\": [\"tsconfig-paths/register\"]\n }\n}\n```\n\n또는 명령 인수를 사용하여 다음과 같이 처리할 수도 있습니다:\n\n```js\nnode -r tsconfig-paths/register -r ts-node/register main.ts\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nts-node과 함께 사용된 nodemon이 더 명확해보였기 때문에 두 번째 변형을 사용하는 것이 더 나은 것 같았습니다. nodemon 구성에 추가할 수 있기 때문입니다. nodemon.config.json에서 추출한 내용은 다음과 같습니다:\n\n```js\n{\n  \"ignore\": [\"**/*.test.ts\", \"**/*.spec.ts\", \".git\", \"node_modules\"],\n  \"watch\": [\"src\", \".\"],\n  \"exec\": \"node -r tsconfig-paths/register -r ts-node/register main.ts\",\n  \"ext\": \"ts\"\n}\n```\n\n여기에서 TypeScript 파일에 대해서만 감시자를 설정하고 감시할 디렉토리 및 무시할 파일에 대한 규칙을 설정했습니다.\n\n## 어플리케이션을 초기화합니다\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nExpress.js 위에 몇 가지 래퍼를 구현해 두었어요. 애플리케이션을 초기화하기 위해서는 main.ts에서 해당 클래스를 사용할 수 있습니다:\n\n```js\nimport { App } from \"@app/app\";\n\nconst app: App = new App();\napp.listen(8080);\n```\n\n# 요약\n\nNode.js 프로젝트에 적용할 수 있는 기본 설정을 설명했습니다. 이 설정에는 애플리케이션 자동 재시작, 단일 파일 빌드를 위한 간단한 구성, TypeScript 별칭 사용이 포함되어 있어요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 기사에서는 Node.js 구성에 전념한 것으로 응용 프로그램 클래스 구현 설명을 생략했습니다. 또한 서로 다른 디렉터리에 매핑된 여러 별칭을 사용하고 JavaScript로 작성된 모듈을 지원할 수 있습니다.\n\n저의 저장소에 있는 응용 프로그램 예시: https://github.com/aleksei-golubev/article-full-stack-development-svelte-express/tree/main/backend.\n\nSvelte 사용에 대한 참고 사항: https://medium.com/@aleksei_golubev/angular-developer-trying-svelte-e54898ca986b.\n","ogImage":{"url":"/assets/img/2024-07-07-TypeScriptsetupforNodejsproject_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-TypeScriptsetupforNodejsproject_0.png","tag":["Tech"],"readingTime":6},{"title":"UV vs PIP 2024년에 Python 패키지 관리를 혁신하는 방법","description":"","date":"2024-07-07 12:57","slug":"2024-07-07-UVvsPIPRevolutionizingPythonPackageManagement","content":"\n파이썬은 단순한 자동화 스크립트부터 복잡한 머신 러닝 응용프로그램까지 모든 것에 선호되는 언어로 계속해서 주도하고 있습니다. 이에 효율적인 패키지 관리는 중요합니다. 과거에는 파이썬의 패키지 설치 관리자인 pip이 이 관리 시스템의 최전선에 있었습니다. 그러나 Rust로 작성된 현대적인 패키지 설치 관리자인 UV의 등장은 속도, 효율성, 신뢰성을 향상시켜 혁명적인 변화를 약속합니다. 이 블로그는 UV와 pip 사이의 성능, 기능 및 파이썬 개발에 미치는 전반적인 영향에 초점을 맞추어 차이점을 탐구합니다.\n\n![UV와 PIP를 비교하는 이미지](/TIL/assets/img/2024-07-07-UVvsPIPRevolutionizingPythonPackageManagement_0.png)\n\n# PIP 개요\n\nPip는 많은 해 동안 파이썬 패키지 관리의 기반이었습니다. 사용자들이 파이썬 패키지 인덱스(PyPI)에서 가져온 소프트웨어 패키지를 설치하고 관리할 수 있도록 합니다. pip의 전형적인 워크플로는 다음과 같습니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 패키지 설치 : `pip install packagename`과 같은 명령어를 실행합니다.\n- 요구 사항 관리 : `requirements.txt` 파일을 사용하여 프로젝트 종속성을 관리합니다.\n- 가상 환경 처리 : 가상 환경을 활용하여 서로 다른 프로젝트의 종속성을 격리하고 관리합니다.\n\n파이프는 매우 유용하지만 대형 종속성을 처리할 때 속도에 어려움을 겪거나 종속성 충돌 해결 및 디스크 공간 사용을 최적화하는 효율적인 메커니즘이 부족한 경우가 많습니다.\n\n# UV 소개\n\nUV는 파이프의 대체품으로 설계된 고성능 대안으로 등장합니다. Rust로 제작된 UV는 속도와 효율성을 중시하여 개발되었으며, 다양한 시나리오에서 pip와 비교했을 때 10-100배의 성능 향상을 자랑합니다. 주요 기능은 다음과 같습니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 속도: UV는 패키지 설치에 필요한 시간을 크게 줄입니다.\n- 디스크 공간 효율성: 종속성 중복을 방지하기 위해 전역 캐시를 구현합니다.\n- 고급 종속성 관리: 고급 해결 전략 및 최고 수준의 오류 메시지를 제공합니다.\n- 크로스 플랫폼 지원: macOS, Linux 및 Windows에서 실행되며 다양한 고급 pip 기능을 지원합니다.\n\n# 주요 차이점\n\n## 성능\n\nUV가 pip보다 가장 큰 장점을 가지고 있는 부분은 속도입니다. 벤치마크 결과 UV가 종속성 설치를 훨씬 빠르게 처리할 수 있다는 것을 보여주며, 시간과 자원이 중요한 환경에서 작업하는 개발자들에게 필수적인 도구로 작용합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 디스크 사용량\n\nUV는 pip과 달리 패키지 종속성을 중복으로 저장하지 않고 디스크 공간을 효율적으로 관리하는 전역 캐싱 메커니즘을 사용합니다. 이 기능은 같은 기계에서 여러 프로젝트를 다루는 개발자에게 매우 유용합니다.\n\n## 오류 처리 및 메시지\n\nUV는 향상된 오류 진단 기능을 제공하여 pip에서 자주 나타나는 암호화된 오류 메시지와 비교하여 의존성 문제의 디버깅을 훨씬 쉽게 만듭니다. 이 기능 하나만으로도 개발자가 수십 시간을 소비하는 문제 해결을 막아줄 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 실용적인 비교\n\n간단한 판다스 설치 예제를 사용하여 두 가지를 비교해보겠습니다.\n\n![이미지 1](/TIL/assets/img/2024-07-07-UVvsPIPRevolutionizingPythonPackageManagement_1.png)\n\n![이미지 2](/TIL/assets/img/2024-07-07-UVvsPIPRevolutionizingPythonPackageManagement_2.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 사용자 CPU 시간:\n\n  - pip: 1.61 초\n  - uv: 0.28 초\n  - 분석: UV는 사용자 CPU 시간을 현저히 적게 사용합니다. 이는 UV가 Python 수준 작업의 계산 및 처리를 더 효율적으로 수행한다는 것을 시사합니다.\n\n- 시스템 CPU 시간:\n\n  - pip: 0.18 초\n  - uv: 0.42 초\n  - 분석: UV는 더 높은 시스템 시간을 갖고 있는데, 이는 UV가 파일 I/O 또는 네트워크 작업을 더 적극적이거나 다르게 처리하기 때문일 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n3. CPU 사용률:\n\n- pip: 67%\n- uv: 58%\n- 분석: 두 도구 모두 CPU의 상당 부분을 활용하지만 UV가 더 효율적으로 작동하여 더 적은 CPU를 사용하여 전반적으로 빠른 완료를 달성합니다.\n\n4. 총 경과 시간:\n\n- pip: 총 2.624초\n- uv: 총 1.216초\n- 분석: UV가 pip보다 걸리는 시간의 거의 절반에 설치를 완료합니다. 이는 UV의 성능 우위를 현실 세계에서 강조하며, 속도가 중요한 환경에서 유용한 선택으로 만듭니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 주요 포인트:\n\n- 속도: UV는 동일한 패키지를 설치할 때 전체 경과 시간에서 pip보다 약 두 배 더 빠릅니다. 이 속도 향상은 여러 패키지를 자주 설치하고 업데이트하는 환경에서 작업하는 개발자들에게 중요합니다.\n- 효율성: UV는 특히 해결 및 패키지 설치 속도에서 전반적인 효율성이 더 좋습니다.\n- 자원 사용: UV가 시스템 리소스를 다르게 활용하는 방식(시스템 시간을 더 사용, 사용자 시간을 덜 사용)은 일반적으로 시스템 수준 작업에서 더 효율적인 Rust 기반 실행 때문에 낮은 수준에서 더 많은 작업을 수행할 수 있을 것으로 보입니다.\n\n# UV로 시작하기: Python 패키지 더 빠르게 관리하는 방법\n\n```js\n# macOS 및 Linux에서.\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# Windows에서.\npowershell -c \"irm https://astral.sh/uv/install.ps1 | iex\"\n\n# 특정 버전으로.\ncurl -LsSf https://astral.sh/uv/0.2.21/install.sh | sh\npowershell -c \"irm https://astral.sh/uv/0.2.21/install.ps1 | iex\"\n\n# pip로.\npip install uv\n\n# pipx로.\npipx install uv\n\n# Homebrew로.\nbrew install uv\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Python 패키지 관리의 미래\n\nUV는 단순한 패키지 설치 도구가 아닙니다. 더 넓은 비전의 일환으로서 \"Python용 Cargo\"를 만들기 위한 종합 도구입니다. UV의 개발 로드맵에는 환경 통합, 패키지 게시 도구, 심지어 Python 프로젝트를 관리하는 네이티브 GUI와 같은 강력한 기능이 포함될 예정입니다.\n\n# 결론\n\nUV는 Python 패키지 관리에서 큰 발전을 의미하며, pip의 오랜 논란이었던 여러 문제점을 해결하고 현대적인 개발 워크플로에 부합하는 고급 기능을 도입합니다. UV를 채택함으로써, 개발자들은 더 빠른 설치, 더 나은 자원 관리, 그리고 의존성을 보다 직관적으로 다룰 수 있는 혜택을 누릴 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 마지막으로\n\nUV를 개발한 창조자들에게 축하드립니다. 여러분의 노고와 혁신이 파이썬 커뮤니티에 진정으로 감사하게 생각합니다 👏👏.\n\nUV를 다음 파이썬 프로젝트에 사용해보세요. UV가 파이썬 개발 환경을 어떻게 변화시킬 것이라고 생각하시나요?\n","ogImage":{"url":"/assets/img/2024-07-07-UVvsPIPRevolutionizingPythonPackageManagement_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-UVvsPIPRevolutionizingPythonPackageManagement_0.png","tag":["Tech"],"readingTime":7},{"title":"FastAPI에서 Pydantic 직렬화 단계별 가이드","description":"","date":"2024-07-07 12:56","slug":"2024-07-07-PydanticserializationstepbystepsforFastAPI","content":"\n![이미지](/TIL/assets/img/2024-07-07-PydanticserializationstepbystepsforFastAPI_0.png)\n\nFastAPI 프레임워크를 사용하여 API를 구축하려면 pydantic에 대해 알아야 합니다. 'post' 요청은 본문 매개변수만 허용하기 때문입니다. 본문 매개변수를 읽으려면 pydantic 모델을 구현해야 합니다.\n\n그러나 문제는 이 pydantic 모델의 데이터를 사용할 때, 원본 pydantic보다 쉬운 데이터 유형(파이썬 사전 또는 JSON일 수 있음)으로 변환해야 한다는 것입니다. 이 데이터 유형으로 작업하는 것이 원본 pydantic보다 쉽기 때문입니다.\n\n이 프로세스를 직렬화라고 합니다. 이름에서 알 수 있듯, 이 문제에 대해 심각하게 생각할 필요가 없습니다. 이 주제에 대해 알아야 할 모든 것을 단순화할 것입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nFastAPI에서 데이터를 반환할 때 pydantic 모델과 정확히 동일한 데이터를 반환하고 싶다면 직렬화 방법을 사용할 필요가 없습니다. FastAPI가 이를 자동으로 처리하기 때문입니다. 그러나 pydantic 데이터 출력을 사용자 정의하려면 (적어도 새 필드를 추가하거나 기존 필드를 제거하는) pydantic에서 어떤 종류의 직렬화 방법을 사용하는 것이 좋습니다. model_dump(), dict() 및 model_dump_json()과 같은 방법이 있습니다.\n\n먼저 어떻게 무조건적으로 pydantic 모델과 동일한 데이터를 반환하는지 알아보겠습니다.\n\n```python\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\nclass University(BaseModel):\n    name : str\n    place : str\n@app.post('/create')\nasync def addUniversity(university : University):\n    # 업무 로직을 수행한 후\n    # pydantic 모델 그대로 반환합니다\n    return university\n```\n\n그리고 위의 pydantic 모델을 수정하여 (다른 필드를 추가하는 간단한 예) 직렬화 방법을 사용하지 않고 반환하는 방법을 살펴보겠습니다. 이것은 어려운 주제가 아닙니다. 그저 새로운 사전을 만들고 출력으로 반환하는 것뿐입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\nclass University(BaseModel):\n    name : str\n    place : str\n@app.post('/create')\nasync def addUniversity(university : University):\n    newUniversity = {\n        'name' : university.name,\n        'place' : university.place,\n        'contactNum' : +1234678\n    }\n    return newUniversity\n```\n\n만약 직렬화(serialization)에 대해 익숙하지 않다면, 위와 같은 방법으로 해야 한다고 생각할 수 있습니다. 하지만 이제 직렬화 메서드를 적용하는 방법을 살펴본 후, 우리의 작업을 더 쉽게 할 수 있는 방법을 알아보겠습니다.\n\n```python\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\nclass University(BaseModel):\n    name : str\n    place : str\n@app.post('/create')\nasync def addUniversity(university : University):\n    # 새로운 대학 변수를 정의하고 직렬화된 데이터를 할당합니다.\n    newUniversity = university.model_dump()\n    # 새 데이터 추가\n    newUniversity['contactNum'] = 12345678\n    # 값을 반환합니다.\n    return newUniversity\n```\n\n따라서 직렬화를 사용할 수 있는 유용한 방법 중 하나를 보여드렸습니다. 이 주제에 대해 더 자세히 알아보고 싶다면, 직렬화에 대해 알아야 할 모든 것을 간단하게 설명해드리겠습니다.\npydantic에는 세 가지 주요 기본 직렬화 메서드가 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## model_dump( )\n\n이 함수는 Pydantic 모델을 사전으로 변환하는 데 사용됩니다. 사전으로 변환한 후에는 아래와 같이 출력을 사용자 지정하는 여러 옵션이 있습니다.\n\n```js\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel, Field\n\napp = FastAPI()\nclass University(BaseModel):\n    name : str\n    place : str = Field(alias='location place')\n    rank : int\n    specialize : int = Field(default=1)\n@app.post('/create')\nasync def addUniversity(university : University):\n    newUniversity = university.model_dump(exclude='rank', include=['name', 'place', 'specialize'], mode='python', by_alias=True, exclude_defaults=True)\n    # 비즈니스 로직 구현\n    # 데이터베이스에 저장\n    # 결과 반환\n    return newUniversity\n```\n\n코드 설명\naddUniversity()가 데이터베이스에 새로운 대학을 추가하는 엔드포인트로 상상해 봅시다. 사용자가 프론트엔드에서 데이터를 제출하면 이 API 엔드포인트는 데이터를 받아서 Pydantic 모델에 전달합니다. addUniversity() 함수 내에서 University 데이터 모델을 model_bump() 메서드를 사용하여 직렬화하는 새로운 변수 newUniversity를 선언합니다. 여기에서 우리는 Pydantic 모델의 출력을 원하는 대로 사용자 정의할 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\"exclude\": 이 옵션을 사용하여 Pydantic 모델에서 가져온 필드를 제거할 수 있습니다.\n\n\"include\": 여기서 함수 내에서 계산에 필요한 필드를 지정할 수 있습니다.\n\n\"by_alias\": Pydantic 모델의 각 필드에 대한 대체 이름을 이미 정의했다면, by_alias는 사용 여부에 대한 옵션을 제공합니다.\n\n\"exclude_default\": Pydantic 모델의 특정 필드에 대한 기본값을 정의했기 때문에, 기본값과 같은 값을 가진 필드를 제외하려면 이 옵션을 사용할 수 있습니다. 이 옵션은 그 목적을 위해 사용됩니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 다른 옵션들을 더 탐색하고 싶다면, `API documentation` Pydantic 문서 `Base model` `model_dump` 를 확인해보세요.\n\n## dict()\n\n여기서 제공하는 것 또한 `model_dump()` 메서드와 비슷합니다. 왜냐하면 이 역시 파이썬 딕셔너리를 반환하기 때문입니다. 하지만 다른 점은 customize our pydantic model을 위해 사용할 수 있는 몇 가지 옵션이 있다는 것입니다.\n\n## model_dump_json()\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 JSON 출력 또는 직렬화 출력을 JSON 형식으로 받고 싶다면 `model_dump_json()`을 사용하세요. `model_dump` 메서드에서 사용 가능한 모든 옵션들을 여기에도 사용할 수 있습니다.\n\n# 다른 직렬화 옵션들은 무엇이 있을까요\n\n## @field_serializer\n\n예를 들어 Pydantic 모델에서 특정 필드를 커스텀하고자 할 때, 함수나 엔드포인트로 Pydantic 모델 데이터를 가져오기 전에 그 필드를 수정하고 싶을 수 있습니다. 다시 말해 Pydantic 모델을 호출한 후 일부 필드를 수정해 해당 데이터를 함수나 엔드포인트로 반환하고자 하는 경우가 있을 수 있습니다. 이런 경우 `@field_serializer`를 사용해야합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel, field_serializer\n\napp = FastAPI()\nclass University(BaseModel):\n    name: str\n    place: str\n    rank: str\n    specialize: int\n\n    @field_serializer('rank', when_used='always')\n    def rank_serialize(rank: str):\n        rank = 'world rank - ' + rank\n        return rank\n\n@app.post('/create')\nasync def addUniversity(university: University):\n    return university\n```\n\n**코드 설명**\n\nUniversity pydantic 모델은 name, place, specialize와 함께 rank와 같은 여러 필드를 허용합니다. 이 모델에 데이터를 전달할 때 rank 필드의 값은 문자열입니다. 그러나 이 코드 외부에서 데이터를 전달할 때 rank의 값으로 숫자만 받습니다. \"01\", \"02\"와 같은 링크를 사용하지만 이 pydantic 모델 외부에서 데이터를 전달할 때 rank의 값을 \"world rank - 01\"과 같이 바꾸고 싶습니다. 간단히 말해 출력은 다음과 같아야 합니다.\n\n```python\n{\n  \"name\": \"string\",\n  \"place\": \"string\",\n  \"rank\": \"world rank - 01\",\n  \"specialize\": 0\n}\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\njs\n{\n\"name\": \"string\",\n\"place\": \"string\",\n\"rank\": \"01\",\n\"specialize\": 0\n}\n\n단일 필드만 직렬화하려면 Pydantic 모델 내에서 새로운 함수를 선언해야 합니다. 이 함수에는 '@field_serializer' 데코레이터를 사용해야 합니다. 하지만 먼저 해당 데코레이터를 Pydantic 모델에서 import해야 합니다. 여러 매개변수를 받을 수 있지만, 여기서는 두 가지만 언급합니다. 첫 번째는 어떤 필드를 직렬화할지를 나타내는 것입니다. 여기서는 'rank' 필드를 사용했습니다. 두 번째는 'when_use'입니다. 이곳에서 언제 이 필드 직렬화기를 사용할지 알려주어야 합니다. 이 예시에서는 'always'를 사용합니다.\n\n그런 다음 해당 함수 내에서 원하는 작업을 수행하고, 마지막으로 반환하면 됩니다. 그게 전부입니다. 간단하지요?\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## @model_serializer\n\n이 메서드에서는 엔드포인트나 함수로 반환하기 전에 원하는대로 pydantic 모델을 직렬화할 수 있습니다. 이는 field_serializer와 매우 유사합니다. 더 잘 이해하기 위해 예제를 살펴봅시다.\n\n```js\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel, model_serializer\n\napp = FastAPI()\nclass University(BaseModel):\n    name : str\n    place : str\n    @model_serializer()\n    def rank_serialize(self):\n        return {\n        'name' : 'the ' + self.name,\n        'place' : self.place + ', sri lanka'\n        }\n@app.post('/create')\nasync def addUniversity(university : University):\n    return university\n```\n\n이렇게 출력을 얻고 싶습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n{\n  \"name\": \"콜롬보 대학\",\n  \"place\": \"스리랑카 콜롬보\"\n}\n```\n\n대신에 모델 시리얼라이저를 사용해보세요.\n\n```js\n{\n  \"name\": \"콜롬보 대학\",\n  \"place\": \"콜롬보\"\n}\n```\n\n첫 번째로 해야 할 일은 pydantic 모델에서 model_serializer를 import하는 것입니다. 그런 다음 모델 내부에서 '@model_serializer' 데코레이터가 달린 함수를 선언하고 원하는 방식으로 출력을 구성하십시오. 마지막으로 반환하십시오. 더 자세한 내용은 pydantic 문서 `API Documentation`의 `Functional serializer` 섹션을 참조하십시오.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그냥 간단하게 Pydantic에서 serializer를 사용하는 방법이야. 더 자세한 내용을 원한다면 문서를 확인하고 이해를 돕기 위해 뭔가를 구현해보세요...\n\n코딩 즐겁게 하시고 또 다른 FastAPI 주제에서 만나요...\n","ogImage":{"url":"/assets/img/2024-07-07-PydanticserializationstepbystepsforFastAPI_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-PydanticserializationstepbystepsforFastAPI_0.png","tag":["Tech"],"readingTime":10},{"title":"파이썬 해시 테이블 구현 방법 단계별 설명","description":"","date":"2024-07-07 12:53","slug":"2024-07-07-ImplementingaHashTableinPythonStep-by-Step","content":"\n<img src=\"/TIL/assets/img/2024-07-07-ImplementingaHashTableinPythonStep-by-Step_0.png\" />\n\n# 1. 소개\n\n해시 테이블은 소프트웨어 개발에서 효율적인 데이터 저장 및 검색의 기초입니다. 고유한 키를 통해 데이터에 빠르게 액세스할 수 있도록 함으로써, 해시 테이블은 높은 속도로 조회, 삽입 및 삭제를 가능케 하여, 데이터베이스 인덱싱 및 캐싱 솔루션과 같이 성능이 중요한 시나리오에서 필수적입니다.\n\n해시 테이블의 본질은 해싱 메커니즘에 있습니다. 이 메커니즘은 해시 함수를 사용하여 키를 배열 인덱스로 변환합니다. 선택된 인덱스는 배열에 해당 값이 저장되는 위치를 결정합니다. 이 함수가 키를 배열 전체에 균일하게 분산시키고 이중 해싱(double hashing) 및 제곱 프로빙(quadratic probing)과 같은 고급 충돌 해결 기술을 사용함으로써, 해시 테이블은 충돌을 최소화하고 데이터 검색 시간을 최적화할 수 있습니다. 이러한 방법은 해시 테이블이 빠른 액세스를 유지하도록 도와주며, 높은 부하 요소에서도 성능을 유지하는 데 중요합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 2. 기초 이해하기\n\n## 2.1 해시 테이블의 주요 구성 요소 설명\n\n해시 테이블은 데이터를 효율적으로 저장하고 관리하기 위해 함께 작동하는 여러 가지 핵심 구성 요소로 구성되어 있습니다:\n\n해시 함수: 이것은 해시 테이블의 핵심입니다. 해시 함수는 입력 키를 가져와 버킷이나 슬롯 배열 내에서 해당 값이 저장된 위치의 인덱스를 계산합니다. 해시 함수의 효율성은 테이블 내 데이터의 분배에 영향을 미치므로 중요합니다. 좋은 해시 함수는 충돌을 최소화하고 항목들을 버킷들 사이에 균일하게 분배합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n버켓 또는 슬롯: 이들은 데이터 항목이 저장되는 배열 내의 위치입니다. 각 버켓은 하나 이상의 항목을 저장할 수 있습니다. 가장 간단한 형태에서 버켓은 키-값 쌍을 하나 보유합니다. 그러나 충돌 처리 전략에 따라, 더 복잡한 데이터 구조나 항목 목록을 보유할 수도 있습니다.\n\n충돌 처리: 두 키가 동일한 인덱스로 해싱될 때 충돌이 발생합니다. 충돌을 효율적으로 관리하는 것은 해시 테이블의 성능을 유지하는 데 중요합니다. 충돌을 처리하는 여러 방법이 있습니다. 그 중 일부는 다음과 같습니다:\n\n- 연결 방식: 이 방법은 더 복잡한 데이터 구조(예: 연결 리스트 또는 다른 해시 테이블)를 사용하여 동일한 인덱스에 여러 요소를 저장하는 것을 포함합니다. 특정 인덱스의 각 버켓이 동일한 해시 인덱스를 공유하는 항목 목록의 헤드를 가리킵니다.\n- 개방 주소 방식: 개방 주소 방식에서 모든 요소는 배열에 직접 저장됩니다. 충돌이 발생하면 해시 테이블이 미리 정의된 시퀀스에 따라 다음 사용 가능한 슬롯을 탐색하거나 검색합니다. 일반적인 전략으로는 선형 조사, 이차 조사 및 두 번 해싱이 포함됩니다. 각 방법은 구현의 용이성과 충돌 감소 효과면에서 다른 이점을 제공합니다.\n\n## 2.2 소프트웨어 개발에서 해시 테이블의 일반적 사용 사례 개요\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n해시 테이블은 소프트웨어 개발에서 널리 사용되며 효율성과 다용성으로 인해 귀중히 여겨집니다. 다음은 일반적인 사용 사례입니다:\n\n- 데이터베이스 색인: 해시 테이블은 데이터베이스 색인 시스템의 성능에 필수적인 빠른 데이터 검색을 제공합니다.\n- 캐싱: 해시 테이블은 빠른 캐시된 데이터 조회가 중요한 캐싱 애플리케이션에 이상적입니다. 효율적인 삽입, 조회 및 삭제가 가능합니다.\n- 데이터 중복 제거: 데이터 중복을 최소화해야 하는 상황에서 해시 테이블은 중복 데이터를 신속하게 식별하는 데 도움을 줄 수 있습니다.\n- 연관 배열: 많은 프로그래밍 언어가 연관 배열(맵 또는 사전이라고도 함)을 구현하는 데 해시 테이블을 사용합니다. 사용자 정의 키를 기반으로 데이터를 검색하고 저장할 수 있습니다.\n- 고유한 데이터 표현: 해시 테이블은 고유한 항목 집합을 유지하는 데 유용하며 반복 검사가 필요한 구현에서 널리 사용됩니다.\n\n# 3. 파이썬 환경 설정\n\n## 필요한 도구 및 라이브러리\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파이썬에서 해시 테이블을 구현하려면, 파이썬 인터프리터와 텍스트 편집기 또는 통합 개발 환경(IDE)이 필요합니다. 파이썬의 표준 라이브러리만으로 해시 테이블을 구축하는 데 충분하므로 이 기본적인 구현에는 추가적인 라이브러리가 필요하지 않습니다. 그러나 해시 테이블을 고급 기능으로 확장하거나 특정 애플리케이션에 사용하기 위해 NumPy와 같은 라이브러리를 사용하는 것을 고려할 수 있습니다. 성능 최적화를 위해 NumPy를 사용하거나 pytest를 사용하여 구현을 테스트할 수 있습니다.\n\n시스템에 파이썬을 설치했는지 확인하세요. 파이썬 3.8 이상을 권장합니다. 개선된 기능과 지원으로 인해 최신 버전의 파이썬을 공식 파이썬 웹사이트에서 다운로드하거나 macOS의 brew나 Ubuntu Linux의 apt와 같은 패키지 관리자를 사용할 수 있습니다.\n\n## 해시 테이블을 위한 파이썬 스크립트 또는 모듈의 초기 설정\n\n- 새로운 파이썬 파일 만들기: 먼저 hash_table.py라는 새로운 파이썬 파일을 만들어 시작하세요. 이 파일에는 해시 테이블 구현과 관련된 모든 코드가 포함됩니다.\n- 해시 테이블 클래스의 구조 정의: HashTable이라는 클래스를 정의하여 시작하세요. 이 클래스는 삽입, 삭제, 조회 등 해시 테이블의 모든 기능을 캡슐화할 것입니다. 다음은 시작할 수 있는 기본 구조입니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/TIL/assets/img/2024-07-07-ImplementingaHashTableinPythonStep-by-Step_1.png)\n\n- 테스트 설정: 해시 테이블을 작성하는 과정에서 확인할 수 있는 간단한 테스트 메커니즘을 설정하는 것이 좋습니다. Python의 내장된 unittest 프레임워크를 사용하여 테스트 케이스를 작성할 수 있습니다:\n\n![이미지](/TIL/assets/img/2024-07-07-ImplementingaHashTableinPythonStep-by-Step_2.png)\n\n- 스크립트 실행: 명령줄에서 파일이 있는 디렉토리로 이동하여 python hash_table.py를 실행하여 스크립트를 실행하고 작성한 테스트를 실행할 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 4. 해시 테이블 클래스 구현\n\n## 4.1 해시테이블 클래스 구조 정의\n\n해시테이블 클래스는 우리의 해시 테이블의 청사진 역할을 합니다. 이는 키-값 쌍의 저장, 검색 및 삭제를 효율적으로 관리하기 위해 설계되었습니다. 아래는 초기화, 데이터 처리를 위한 메서드 및 해시 함수를 적용하는 메서드가 포함된 클래스의 기본 구조입니다:\n\n![해시테이블 클래스 구조](/TIL/assets/img/2024-07-07-ImplementingaHashTableinPythonStep-by-Step_3.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 4.2 메소드 추가\n\n- **init**: 해시 테이블 초기화. 이 메소드는 지정된 크기로 해시 테이블을 설정하고 버킷을 초기화합니다. 충돌 처리 전략에 따라 버킷은 체이닝을 위한 리스트로 구현하거나 오픈 어드레싱을 위한 빈 슬롯으로 구현할 수 있습니다.\n- insert: 해시 테이블에 아이템 추가. 이 메소드는 새로운 키-값 쌍을 해시 테이블에 삽입합니다. 해시 함수를 사용하여 키의 해시 인덱스를 계산하고 값을 적절한 버킷에 배치하며, 필요에 따라 충돌을 처리합니다.\n- get: 키로 아이템 조회. get 메소드는 해시 테이블에서 키를 검색하고 해당하는 값 반환합니다. 가능한 충돌을 처리하고, 키를 찾을 수 없는 경우 None을 반환하여 견고한 데이터 검색을 보장합니다.\n- delete: 키로 아이템 삭제. 이 메소드는 키를 사용하여 해시 테이블에서 키-값 쌍을 제거합니다. 올바른 버킷을 찾아 해당 아이템을 제거하며, 이후 요소에 영향을 미칠 수 있는 충돌을 관리합니다.\n- \\_hash: 해시 함수 적용을 위한 내부 메소드. 이는 키에 대해 해시 함수를 적용하는 과정을 단순화하는 도우미 메소드입니다. 이를 통해 키가 버킷 리스트의 범위 내에서 유효한 인덱스로 변환됩니다.\n\n## 4.3 체이닝(링크드 리스트) 또는 오픈 어드레싱을 이용한 충돌 처리 설명\n\n- 체이닝(링크드 리스트): 체이닝은 충돌 해결 기법으로, 배열 내 특정 인덱스의 각 버킷이 연결 리스트를 시작할 수 있습니다. 동일한 인덱스로 해싱된 모든 키-값 쌍은 이 리스트에 저장되어 같은 인덱스에 여러 항목을 보관하도록 허용하지만, 최악의 경우 원소를 검색하는 시간 복잡성이 증가할 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/TIL/assets/img/2024-07-07-ImplementingaHashTableinPythonStep-by-Step_4.png)\n\n- Open Addressing: Open addressing stores all elements directly in the array and resolves collisions by finding another empty slot within the array. The common strategies for open addressing include linear probing, quadratic probing, and double hashing, each with distinct approaches to resolving collisions efficiently.\n\nHere’s an implementation of linear probing:\n\n![image](/TIL/assets/img/2024-07-07-ImplementingaHashTableinPythonStep-by-Step_5.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음은 이차 조사법의 구현 예시입니다:\n\n![quadric_probing](/TIL/assets/img/2024-07-07-ImplementingaHashTableinPythonStep-by-Step_6.png)\n\n다음은 두 번째 해싱(double hashing)의 구현 예시입니다:\n\n![double_hashing](/TIL/assets/img/2024-07-07-ImplementingaHashTableinPythonStep-by-Step_7.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 5. 충돌 처리\n\n## 5.1 체이닝의 상세 설명 및 Python에서의 구현\n\n체이닝은 해시 테이블에서 충돌을 처리하는 일반적인 방법으로, 특정 인덱스의 각 버킷이 하나 이상의 요소를 보유할 수 있습니다. 이 접근 방식은 동일한 인덱스로 해싱된 여러 항목을 저장하는 데 연결 목록과 같은 보조 데이터 구조를 사용합니다. 각 버킷이 항목 리스트를 저장할 수 있도록 함으로써 체이닝은 충돌을 우아하게 처리하고 높은 부하 요인에서도 성능을 유지합니다.\n\nPython에서의 구현: 해시 테이블에서 체이닝을 구현하는 상세 예제입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/TIL/assets/img/2024-07-07-ImplementingaHashTableinPythonStep-by-Step_8.png)\n\n이 구현에서 각 버킷은 연결 리스트로 연결된 여러 항목을 잠재적으로 저장할 수 있습니다. 새 키-값 쌍이 삽입될 때 해시 테이블은 계산된 인덱스에 이미 항목이 있는지 확인합니다. 버킷이 비어있으면 새 노드를 간단히 삽입합니다. 그렇지 않으면 기존 키를 업데이트하거나 키가 존재하지 않으면 체인 끝에 새 노드를 추가합니다. 이 방법은 메모리 사용량 면에서 효율적이며 충돌 처리를 단순화합니다.\n\n체이닝의 장점:\n\n- 체이닝은 구현이 간단합니다.\n- 높은 충돌 시나리오를 우아하게 처리할 수 있습니다. 해시 테이블은 버킷 수보다 더 많은 항목을 저장할 수 있습니다.\n- 전체 테이블의 크기를 조정할 필요가 없습니다. 영향을 받는 체인만 조정하면 됩니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n체이닝의 단점:\n\n- 체이닝은 링크드 리스트 포인터와 관련된 오버헤드로 인해 더 많은 메모리를 사용합니다.\n- 많은 요소가 동일한 인덱스로 해싱되는 최악의 경우에는 요소를 찾는 작업이 느려질 수 있습니다. 이는 링크드 리스트를 탐색해야 하기 때문입니다.\n\n이 충돌 처리 방법은 하중 계수가 높고 해시 테이블이 효율적으로 많은 충돌을 처리해야 하는 경우에 적합합니다.\n\n## 5.2 대체 방법: 오픈 어드레싱 방법 구현\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n열린 주소 할당은 해시 테이블 내에서 다양한 버킷 위치를 조사하여 충돌을 해결합니다.\n\n선형 조사: 해시 테이블에서 충돌을 해결하는 간단한 열린 주소 할당 전략입니다. 연결 리스트와 달리 충돌은 동일한 인덱스의 항목을 연결하는 것이 아니라, 선형 조사는 배열 내에서 새 항목을 저장할 다음 사용 가능한 슬롯을 찾습니다. 이 방법을 통해 모든 항목이 배열 내에 직접 저장되므로 캐시 성능이 향상되고 공간을 더 효율적으로 사용할 수 있습니다.\n\nPython에서의 구현:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 구현에서 충돌이 발생하는 경우(즉, 해시된 인덱스가 이미 사용 중인 경우), 해시 테이블은 다음 사용 가능한 슬롯을 선형적으로 탐색합니다. 이 방법은 간단하고 효과적이지만 연속적인 슬롯이 채워져 클러스터링이 발생할 수 있어 테이블이 채워질수록 평균 검색 시간이 증가할 수 있습니다.\n\n선형 조사의 장점:\n\n- 주 메인 테이블 외 추가 메모리가 필요하지 않아 공간을 효율적으로 사용합니다.\n- 구현 및 이해하기 쉽습니다.\n- 연속적인 메모리 사용으로 인한 좋은 캐시 성능을 지니고 있습니다.\n\n선형 조사의 단점:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 클러스터링은 고부하 시나리오에서 성능에 상당한 영향을 미칠 수 있습니다.\n- 부하 요소 임계값에 도달하면 전체 테이블을 조정해야 하므로 계산 비용이 많이 들 수 있습니다.\n\n선형 조사는 부하 요소가 낮고 중간 수준인 테이블에 적합하며, 삭제 빈도가 낮을 때 특히 효과적입니다. 삭제는 조사 순서를 복잡하게 만들 수 있는 간격을 만들 수 있기 때문입니다.\n\n제곱 조사: 해시 테이블에서 충돌을 해결하는 고급 개방 주소 지정 기술이며, 클러스터링 문제를 해결하여 선형 조사보다 큰 개선을 제공합니다. 선형 조사가 선형 시퀀스에서 다음 사용 가능한 슬롯을 찾는 것과 달리, 제곱 조사는 제곱 다항식을 사용하여 조사 간의 간격을 계산하므로 클러스터를 생성할 가능성을 줄입니다.\n\n파이썬에서의 구현:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/TIL/assets/img/2024-07-07-파이썬 단계별 해시테이블 구현_10.png\" />\n\n이 구현에서는 이차 탐사가 선형 탐사에서 발생하는 주요 클러스터링 문제를 크게 줄이기 위해 탐사 시도 횟수의 이차 함수를 사용하여 다음 인덱스를 계산합니다. 탐사 함수는 다음과 같은 공식을 사용합니다: (index + c1*trial + c2*trial^2) % table_size, 여기서 c1과 c2는 상수이고, trial은 빈 슬롯을 찾거나 루프가 감지될 때까지 각 탐사마다 1씩 증가합니다.\n\n이차 탐사의 장점:\n\n- 선형 탐사와 비교하여 클러스터링을 줄입니다.\n- 클러스터링 된 항목을 효율적으로 분산하여 해시 테이블 공간을 더 효과적으로 활용합니다.\n- 다음 인덱스를 계산하는 과정은 여전히 비교적 간단하고 빠릅니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n제곱 탐사의 단점:\n\n- 선형 탐사보다는 심각성이 적긴 하지만 부착 현상이 발생할 수 있습니다.\n- c1 및 c2 값의 선택이 성능에 상당한 영향을 미치며 신중한 조정이 필요합니다.\n- 다른 개방 주소 메서드와 마찬가지로 테이블이 너무 가득 차면 크기를 조정해야 합니다.\n\n제곱 탐사는 중간 부하 인자에 대해 효과적인 충돌 해결 기술이며 해시 테이블 크기를 충분히 크게 유지하여 자주 크기 조정을 피할 수 있는 시나리오에서 특히 유익합니다.\n\n더블 해싱: 간단한 형태의 탐사와 관련된 클러스터링 문제를 크게 줄이는 데 기여하는 두 개의 해시 함수를 사용하는 개방 주소의 정교한 방법입니다. 선형 또는 제곱 탐사와 달리, 더블 해싱은 충돌이 발생한 후 단계 크기를 계산하기 위해 두 번째 해시 함수를 사용하여 각 탐사가 키를 기반으로 한 독특한 순서를 따르도록 합니다. 이 방법은 항목을 해시 테이블 전체에 골고루 분배하여 효율적이고 효과적인 것으로 알려져 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파이썬에서의 구현:\n\n![Implementing a Hash Table in Python Step-by-Step](/TIL/assets/img/2024-07-07-ImplementingaHashTableinPythonStep-by-Step_11.png)\n\n이 구현에서 첫 번째 해시 함수는 초기 슬롯을 결정하고 충돌이 발생하는 경우 두 번째 해시 함수는 다음 프로브를 위한 오프셋을 제공합니다. 이는 단순 혹은 제곱 프로빙과는 다르며 단계가 고정되어 있거나 예측 가능한 패턴으로 증가하는 것이 아닙니다. 따라서 더블 해싱은 주요 및 보조 클러스터링을 모두 줄여 데이터 분포를 더 균일하게 만듭니다.\n\n더블 해싱의 장점:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 다른 조사 기법보다 클러스터링을 더 효과적으로 최소화합니다.\n- 높은 부하 계수를 가진 해시 테이블에서 높은 성능을 제공합니다.\n- 각 키는 고유한 조사 시퀀스를 받아 다른 조사 방법보다 성능을 향상시킵니다.\n\n더블 해싱의 단점:\n\n- 선형 또는 이차 조사보다 구현이 더 복잡합니다.\n- 두 번째 해시 함수를 계산하기 위해 추가 계산이 필요합니다.\n- 성능은 두 해시 함수의 품질에 매우 의존합니다.\n\n더블 해싱은 해시 테이블이 높은 트래픽을 경험하거나 키 분포로 인해 충돌이 자주 발생할 수 있는 애플리케이션에서 특히 유용합니다. 입력을 효율적으로 분배하는 능력으로 대규모 데이터 세트에 대한 훌륭한 선택입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 5.3 각 충돌 해결 기술의 장단점\n\n체이닝: 장점: 구현하기 쉽고 높은 충돌 상황을 우아하게 처리함; 크기 조정 시 전체 테이블을 다시 해싱할 필요가 없음. 단점: 더 많은 메모리를 사용함; 연결 리스트 작업이 비연속 메모리 할당 때문에 느릴 수 있음.\n\n오픈 어드레싱: 장점: 해시 테이블 배열 자체에 모든 요소를 저장하여 공간을 효율적으로 사용함; 연속적인 메모리 사용으로 인한 더 나은 캐시 성능. 단점: 클러스터링이 발생하여 효율성이 감소할 수 있음; 테이블이 가득 찰 경우 리사이징이 필요함; 리사이징을 구현하기 복잡함.\n\n각 충돌 처리 방법은 상충 관계가 있으며 특정 유형의 응용 프로그램에 가장 적합합니다. 체이닝은 불특정하거나 매우 변동적인 부하를 갖는 해시 테이블에 적합할 수 있으며, 오픈 어드레싱은 안정적인 데이터 세트와 충돌을 최소화하기 위한 좋은 해시 함수가 있는 응용 프로그램에 더 적합할 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 6. 테스트 및 디버깅\n\n## 6.1 해시 테이블을 위한 테스트 케이스 작성\n\n해시 테이블의 효과적인 테스트는 다양한 조건에서 데이터를 처리하는 신뢰성과 효율성을 보장하기 위해 중요합니다. 서로 다른 프로빙 기법을 사용하여 해시 테이블 구현을 위한 포괄적인 테스트 케이스를 작성하는 방법은 다음과 같습니다:\n\n요소 삽입, 검색 및 삭제:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 기본 작업(삽입, 가져오기, 삭제)이 예상대로 작동하는지 확인하는 간단한 테스트부터 시작해보세요. 해시 테이블에 요소를 추가하고, 키를 사용하여 그 값을 검색하고, 일부 요소를 제거하여 테이블이 올바르게 업데이트되는지 확인하는 것이 포함됩니다.\n\n고부하로 성능 확인:\n\n- 해시 테이블이 로드 팩터가 증가함에도 효율적으로 작동하는지 확인하세요. 많은 수의 요소를 삽입하고 다양한 작업에 걸리는 시간을 측정하여 수행할 수 있습니다. 해시 테이블이 용량 한계에 가까워지는 경우와 리사이징을 처리하는 방법에 대한 테스트를 해보세요.\n\n충돌 처리에 대한 스트레스 테스트:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 동일한 값으로 해싱되는 많은 키가 있는 시나리오를 만들어 충돌 처리를 테스트합니다. 이는 충돌 처리 메커니즘의 효율성 (체이닝, 선형 조사, 제곱 조사, 이중 해싱)과 강압하에서의 구조적 무결성을 테스트하는 것을 포함합니다.\n\n## 샘플 테스트 구현:\n\n- 체이닝: pytest 픽스처를 사용하여 여러 항목이 동일한 버킷으로 해싱되는 시나리오를 만들고 해당 항목이 검색 및 삭제 가능한지 확인합니다. 버킷 내에서 광범위한 목록을 처리하는 체이닝이 어떻게 처리되는지 테스트합니다.\n\n![이미지](/TIL/assets/img/2024-07-07-ImplementingaHashTableinPythonStep-by-Step_12.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2. Linear Probing: 해시 테이블이 충돌을 해결하는 방법을 테스트하는 것에 초점을 맞추세요. 다음으로 사용 가능한 슬롯을 찾아 보세요. 항목이 올바르게 덮어쓰기되거나 업데이트되는지, 그리고 테이블이 필요에 따라 어떻게 확장되는지 확인하세요.\n\n![이미지](/TIL/assets/img/2024-07-07-ImplementingaHashTableinPythonStep-by-Step_13.png)\n\n3. Quadratic Probing: 선형 조사와 유사하지만 다른 초기 충돌을 테스트하고, 이차 단계 계산이 항목을 충돌하지 않는 슬롯에 올바르게 배치하는지 확인하세요.\n\n![이미지](/TIL/assets/img/2024-07-07-ImplementingaHashTableinPythonStep-by-Step_14.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n4. 더블 해싱: 보조 해시 함수를 사용하여 충돌을 줄이는 효과를 테스트해보세요. 더블 해싱 방법이 다른 방법보다 항목을 테이블에 더 균등하게 분배하는지 확인해보세요.\n\n![image](/TIL/assets/img/2024-07-07-ImplementingaHashTableinPythonStep-by-Step_15.png)\n\n## 6.2 해시 테이블 구현에서 발생하는 일반적인 문제 해결\n\n해시 테이블을 디버깅하는 것은 주로 충돌 처리, 해시 함수 분포, 동적 크기 조절과 관련된 문제를 식별하는 것을 포함합니다. 다음은 몇 가지 전략입니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 충돌 처리: 요소가 자주 손실되거나 덮어써지는 경우 충돌 해결 논리를 검토해보세요. 삽입, 삭제 및 조회가 충돌하는 키를 올바르게 처리하도록 확인해주세요.\n- 해시 함수 품질: 해시 함수에 의한 부족한 분포는 성능 병목 현상으로 이어질 수 있습니다. 특정 버킷이 과도하게 사용되는 경우 해시 함수를 수정하는 것을 고려해보세요. 키들이 버킷 간에 어떻게 분산되는지 테스트하여 이 문제를 확인할 수 있습니다.\n- 메모리 누수 및 오버플로우: 수동 메모리 관리가 있는 언어에서 특히 관련됩니다만, Python에서는 쓰레기 수집을 방해하는 의도하지 않은 참조를 확인하세요. 또한, 메모리 오버플로우나 과도한 재할당을 유발하지 않으면서 크기 조정 로직이 메모리를 적절히 관리하는지 확인하세요.\n- 동시성 문제: 해시 테이블이 멀티 스레드 응용 프로그램에서 사용되는 경우 경합 조건이 데이터 구조를 손상시킬 수 있습니다. 잠금을 구현하거나 동시성 데이터 구조를 사용하여 스레드 안전성을 보장하세요.\n\n# 7. 고급 주제\n\n## 7.1 동적 크기 조절을 통한 해시 테이블 성능 향상\n\n요소 수가 증가함에 따라 해시 테이블에서 효율적인 성능을 유지하기 위해 동적 크기 조정은 중요한 기능입니다. 크기 조정 없이는 로드 팩터(요소 수 대비 버킷 수의 비율)이 증가하여 더 많은 충돌이 발생하고 따라서 더 긴 검색 시간이 발생합니다. 성능을 향상시키기 위해 해시 테이블은 다음과 같이 동적으로 크기를 조절할 수 있습니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 크기 두 배로 확장: 해시 테이블의 로드 계수가 특정 임계값을 초과할 때(일반적으로 0.7 또는 0.75로 설정), 해시 테이블의 크기가 두 배로 증가합니다. 이 과정은 두 배의 버킷 수를 갖는 새로운 해시 테이블을 만들고 모든 기존 요소를 새 테이블로 재해싱하는 것을 포함합니다.\n- 크기 반으로 축소: 마찬가지로 로드 계수가 낮은 임계값(예: 0.1)보다 낮아지면, 해시 테이블의 크기가 반으로 줄어들어 공간을 절약하고 데이터 크기가 작아지는 시나리오에서 효율을 유지합니다.\n\n동적 크기 조정을 구현하는 것은 리사이징 작업 중 데이터 무결성과 최소한의 성능 영향을 보장하기 위해 신중한 처리가 필요합니다.\n\n## 7.2 해시 테이블의 실제 응용 및 최적화에 대한 토론\n\n해시 테이블은 소프트웨어 엔지니어링에서 만능으로 사용되며, 빠른 데이터 검색이 중요한 다양한 응용 프로그램에서 사용됩니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 데이터베이스: 해시 테이블은 많은 데이터베이스 인덱스 메커니즘을 구동하여 레코드의 신속한 조회, 삽입 및 삭제를 가능하게 합니다.\n- 캐싱 시스템: 많은 웹 및 응용프로그램 서버는 해시 테이블을 사용하여 캐싱을 하며, 자주 액세스되는 데이터를 빠르게 검색 가능한 형식으로 저장하여 데이터베이스로의 요청 횟수를 줄입니다.\n- 유일한 항목 추적: 해시 테이블은 고유한 항목을 추적하거나 항목의 존재 여부를 확인하는 작업에 이상적이며, 그들의 일정한 실행 시간 특성 때문에 유용합니다.\n\n최적화는 콜리전 최소화를 위해 올바른 해시 함수 선택, 유니버설 해싱 같은 기법 사용, 캐시 성능 향상을 위한 메모리 할당 전략 최적화 등이 포함될 수 있습니다.\n\n## 7.3 Python의 내장 dict와 사용자 정의 해시 테이블 비교\n\nPython의 내장 dict는 사실상 Python 언어에 통합된 하이퍼 최적화된 해시 테이블입니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 성능: 파이썬의 dict는 C로 구현되어 있어 순수 파이썬으로 작성된 사용자 지정 해시 테이블보다 속도가 빠릅니다. 이는 하위 수준의 최적화와 Python의 동적 타이핑으로 인한 오버헤드가 없기 때문입니다.\n- 기능: 파이썬의 dict는 순서를 유지하는 추가 기능을 제공합니다 (Python 3.7부터), 이는 일반적인 해시 테이블 구현에서 일반적으로 제공되지 않는 기능입니다.\n- 사용 편의성: 내장 유형인 dict는 Python 구문과 표준 라이브러리에서 직접 지원되므로 사용자 정의 해시 테이블을 구현하는 것보다 편리하게 사용할 수 있습니다.\n\n사용자 정의 해시 테이블은 특정 필요에 맞게 맞춤 설정할 수 있지만, 대부분의 응용 프로그램에 대해 파이썬의 dict는 충분한 성능과 기능을 제공하므로 dict가 지원하지 않는 특정 동작이 필요하지 않는 한 사용자 정의 해시 테이블을 구현할 필요는 없습니다. 예를 들어, 다른 충돌 처리 방법이나 실시간 크기 조정 임계값 등을 필요로 할 때입니다.\n\n# 결론\n\n이 기사를 통해 Python에서 해시 테이블을 구현하는 것에 대해 깊이 있는 내용을 제공했습니다. 체이닝, 선형 조사, 이차 조사, 두 배 해싱을 포함한 충돌 해결 방법을 탐색했습니다. 각 방법이 충돌을 처리하고 해시 테이블의 성능을 최적화하는 방법을 자세히 설명했으며, 효과적인 응용에 대한 포괄적인 가이드를 제공했습니다. 또한 다양한 시나리오에서 해시 테이블의 신뢰성과 효율성을 보장하기 위한 상세한 테스트 접근 방법에 대해 다루었습니다. 이 논의는 데이터 구조에 대한 이해력을 향상시킬 뿐만 아니라 Python 프로젝트에서 복잡한 데이터 관리 도전에 대비하기 위한 실용적 기술을 갖추도록 도와줍니다. 철저한 테스트 실천을 통해 구현의 무결성과 성능을 향상하는 방법을 보여주었습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 친절한 영어로 🚀\n\nIn Plain English 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 갈치하고 팔로우하세요 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠를 다루는 블로깅 플랫폼에 질려셨나요? Differ를 시도해 보세요\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요\n","ogImage":{"url":"/assets/img/2024-07-07-ImplementingaHashTableinPythonStep-by-Step_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-ImplementingaHashTableinPythonStep-by-Step_0.png","tag":["Tech"],"readingTime":23},{"title":"JAX를 배워야 하는 이유 분자동역학 적용 사례 소개","description":"","date":"2024-07-07 12:50","slug":"2024-07-07-WhyYouShouldLearnJAXAMolecularDynamicsShowcase","content":"\n파이썬 스크립트를 최적화하기 위해 PyTorch에 실망한 후 JAX를 사용하기 시작했습니다. 내 프로젝트는 주로 두 가지 주요 구성 요소로 이루어져 있었습니다: 원자 위치를 기반으로 설명자를 계산하고 이러한 설명자를 여러 신경망에 입력으로 사용하여 입자 시스템의 총 잠재 에너지와 힘을 예측하는 것이었습니다. 신경망 부분은 충분히 빠르지만, 특히 TorchScript를 사용한 후에도 설명자 계산, 특히 그래디언트 평가는 효율적으로 수행되지 않았습니다. 자동 미분을 지원하는 Python의 대체 프레임워크를 찾던 중 JAX를 발견했습니다. (물리학적인) 머신러닝 모델을 구축하는 데 매우 효과적이었고 필요한 유연성과 성능을 모두 제공했습니다.\n\n![이미지](/TIL/assets/img/2024-07-07-WhyYouShouldLearnJAXAMolecularDynamicsShowcase_0.png)\n\nPyTorch를 사용하는 데 이의를 제기하는 것은 없습니다. 사실, 자주 사용하여 언어 처리나 객체 탐지 작업을 포함한 머신러닝 모델을 구축할 때 사용합니다. 그러나 Python에서 사용자 정의 및 최적화된 모델을 개발하려는 경우, 아마도 PyTorch가 가장 적합한 선택이 아닐 수도 있습니다. PyTorch는 여러 면에서 뛰어나지만 매우 사용자 정의 및 특정한 모델 아키텍처에 대해서는 성능이 좀 더 우수한 대안이 있을 수 있습니다.\n\nJAX는 자동 미분(autodiff), Just-In-Time (JIT) 컴파일, GPU 가속 컴퓨팅 및 벡터화된 계산 지원을 포함한 제 요구 사항과 완벽하게 일치하는 기능 세트를 제공했습니다. 게다가 JAX는 기능적 프로그래밍 패러다임과 일치하는 방법으로 가변성을 처리합니다. 이 게시물을 통해 JAX를 사용한 제 경험을 공유하고 여러분이 자신의 프로젝트에 JAX를 탐구하고 활용할 동기부여를 제공하는 것이 제 목표입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 필수 패키지\n\n이 가이드를 따라가려면 몇 가지 Python 패키지를 설치해야 합니다.\n\n- **JAX**: 파이썬의 고성능 수치 계산 라이브러리로, 자동 미분과 CPU 및 GPU에서 최적화된 실행을 제공합니다. 이 설치 지침을 따르세요.\n- **ASE**: 분자 시뮬레이션을 설정, 조작 및 분석하는 도구상자로, 계산재료과학 분야에서 널리 사용됩니다.\n  설치: `$ pip install ase`\n- **Pantea**: 나의 Python 패키지로, 현재 개발 중이며 분자 간 포텐셜을 위한 기계 학습 모델을 개발하는 데 사용됩니다.\n  설치: `$ pip install pantea`\n- **NGLView** (옵션): 분자 구조 및 궤적을 대화식으로 보기 위한 주피터 위젯입니다.\n  설치: `conda install nglview -c conda-forge`\n\nJAX는 시스템의 GPU를 자동으로 사용하며, 이용할 수 없을 경우 CPU를 사용합니다. 또한 JAX_PLATFORM_NAME 환경 변수를 미리 조정하여 연산 장치를 수동으로 설정할 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n기본적으로 JAX는 플로트32 데이터 유형을 사용하며, 이는 싱글 포인트 정밀도를 나타냅니다. 그러나 과학 시뮬레이션에서는 높은 정확성을 위해 더블 정밀도 플로트64가 필요합니다. 개선된 계산 성능을 위해 가능한 한 낮은 정밀도를 선택하고 메모리 사용량을 줄이는 것이 권장됩니다(약 2배 정도).\n\n다음 스크립트는 JAX를 구성하여 장치를 선택하고 더블 정밀도를 활성화하는 방법을 보여줍니다.\n\n```js\nimport os\nos.environ[\"JAX_PLATFORM_NAME\"] = \"cpu\"  # GPU 컴퓨팅 비활성화\nos.environ[\"JAX_ENABLE_X64\"] = \"1\"       # 더블 정밀도 활성화\n\nimport jax\n...\n```\n\n간단한 예제의 경우 기본 float32 정밀도를 사용하지만 분자 동역학을 시연할 때는 더블 정밀도를 사용할 것입니다. 또한, 이 글에서 모든 계산은 명시적으로 다른 장치가 명시되지 않는 한 제 노트북의 GeForce MX130 GPU에서 실행됩니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위에서 안내한 단계를 따르면이 포스트에서 다룬 예제를 재현하는 데 필수 도구를 제공받을 수 있습니다. 시작해 봅시다!\n\n# JAX란 무엇인가요?\n\nJAX는 JIT 컴파일, 가속 컴퓨팅 및 자동 미분을 통해 고성능 수치 계산을 가능하게 하는 배열지향 컴퓨테이션용 오픈 소스이자 구성 가능한 파이썬 라이브러리입니다. 머신 러닝, 최적화 및 과학 시뮬레이션과 같은 고성능 수치 계산을 위한 사용자가 익숙한 NumPy 구문을 사용하여 코드를 작성하면 자동으로 효율적으로 해당 코드를 GPU 및 TPU에서 실행할 수 있도록 변환해줍니다. 이는 계산이 많이 필요한 작업에 높은 효율성을 가지며 매우 적합합니다. 선형 대수 가속화 X(LAX)는 JAX 라이브러리 내에서 서브 모듈 역할을 하며 다양한 선형 대수 루틴의 최적화된 구현을 제공합니다. JAX 문서 페이지를 방문하여 자세한 내용을 확인하는 것을 강력히 권장하며 다양한 정보와 자원을 제공하는데 도움이 됩니다. 예를 들어 이 튜토리얼을 참조해보세요.\n\n일부 사람들은 JAX를 단순히 멀티스레드 NumPy 라이브러리로 설명하지만, 저는 그렇지 않다고 주장합니다. 그 이상의 기능을 제공합니다. 후속 섹션에서는 제 프로젝트 개발에 중요한 역할을 한 JAX의 주요 기능 몇 가지를 소개하겠습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## I. JIT 컴파일\n\nJust-In-Time (JIT) 컴파일은 코드를 런타임에 컴파일하는 방법으로, 미리 컴파일하는 것이 아니라 코드를 컴파일하는 방법입니다. 이로 인해 코드를 실행 중인 특정 시스템에 맞게 최적화할 수 있으며, 미리 컴파일된 코드보다 성능이 향상될 수 있습니다. Python 스크립트는 해석되는데, 즉, 코드가 Python 인터프리터에 의해 한 줄씩 읽히고 실행됩니다. 이는 각 코드 줄을 처리한 후 실행해야 하기 때문에 컴파일된 코드보다 느릴 수 있습니다.\n\n이와 대조적인 JIT 컴파일은 Python 코드를 런타임에 기계 코드로 변환하므로 컴퓨터의 CPU에서 직접 실행할 수 있습니다. 이는 Python의 오버헤드를 효과적으로 제거하고 해석된 코드보다 성능을 향상시킬 수 있습니다. 배열을 입력으로 받아 결과를 반환하는 더미 커널 함수의 예를 살펴보겠습니다:\n\n```python\nimport jax.numpy as jnp\n\ndef kernel(x):\n  \"\"\"더미 커널 함수.\"\"\"\n  result = 0\n  for i in range(10):\n      result += i * jnp.sin(jnp.cos(x))\n  return result.sum()\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n랜덤 입력 배열을 생성하고 JIT 컴파일 없이 구현된 함수 호출의 실행 시간을 측정해 봅시다.\n\n```js\nimport jax\n\nx = jax.random.normal(jax.random.key(2024), shape=(100_000, ))\n# Array([ 0.8188207 ,  0.70407075, -0.553007  , ..., -0.07251461,\n#       -1.353674  , -0.21451078], dtype=float32)\n\n%timeit kernel(x).block_until_ready()\n2.34 ms ± 134 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\n```\n\n%timeit은 Jupyter 노트북과 IPython에서 사용되는 매직 커맨드로, 코드 조각의 실행 시간을 측정하는 데 사용됩니다. 여러 번 코드를 실행하여 평균 실행 시간을 얻으며, 상당한 변동성을 고려하여 성능을 더 정확하게 측정합니다.\n\nJAX는 비동기 디스패치를 사용하므로, JAX 배열에 block_until_ready() 메서드를 호출하면 해당 배열이 계산을 완료할 때까지 Python 프로그램 실행이 차단됩니다. 계산 시간의 마이크로 벤치마킹을 작성할 때 이것을 권장합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n보고된 결과인 2.34 ms ± 134 µs per loop은 각각 100번 실행되는 7회의 실행을 기반으로 한 루프 당 평균 소요 시간 및 표준 편차를 나타냅니다.\n\n이제 이 함수의 JIT 컴파일된 버전(또는 데코레이터를 사용하여 적용할 수도 있음)을 생성하고, 이후에 실행 시간을 다시평가하겠습니다.\n\n```js\nimport jax\n\njitted_kernel = jax.jit(kernel)\n\n# 웜업 호출\n# jitted_kernel(x)\n\n%timeit jitted_kernel(x).block_until_ready()\n82.5 µs ± 1.9 µs per loop (mean ± std. dev. of 7 runs, 10,000 loops each)\n속도 향상:  29배\n```\n\nJIT 함수에 대한 웜업 호출은 일반적으로 속도를 평가하기 전에 컴파일하고 최적화하는 목적으로 실행됩니다. 함수 구현이 직관적하기 때문에 이 단계를 생략했습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n컴파일된 함수는 JIT 컴파일을 통해 심각한 성능 향상을 이루며, 컴파일되지 않은 버전보다 29배 빠르게 실행됩니다. 이 JAX 기능은 고성능 Python 함수를 작성할 수 있도록 돕습니다.\n\n## II. 자동 미분\n\n자동 미분은 함수의 도함수를 자동으로 계산하는 계산 기술입니다. 유한한 차이를 사용하여 도함수를 근사하는 수치 미분이나 표현식을 조작하여 도함수를 찾는 기호 미분과는 달리, 자동 미분은 미분을 정확하고 효율적으로 평가하기 위해 미적분의 연쇄 법칙을 체계적으로 적용합니다. 요즘에는 자동 미분이 PyTorch, TensorFlow 및 JAX와 같은 딥 러닝 프레임워크에서 중요한 역할을 합니다. 효율적인 기울기 계산을 가능하게 하기 때문에 기울기 하강과 같은 최적화 알고리즘에 필수적인 기울기의 효율적인 계산이 허용됩니다.\n\n자동 미분은 JAX의 핵심 기능으로, 기울기를 계산하는 프로세스를 단순화하고 가속화합니다. JAX는 여러 가지 함수를 제공하여 미분을 수행하며, 가장 두드러진 함수는 입력 변수에 대한 스칼라 값 함수의 기울기를 계산하는 jax.grad입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이전 예제 커널을 고려해 봅시다. jax.grad를 사용하여 다음 코드를 통해 간단히 각 입력에 대한 출력의 기울기를 계산할 수 있습니다.\n\n```js\nimport jax\n\ngradient_kernel = jax.grad(kernel)\n\nkernel(x)\n# Array(2401043.5, dtype=float32)\n\ngradient_kernel(x)\n# Array([-25.491356 , -21.069756 ,  15.582619 , ...,   1.7687505,\n#        42.92778  ,   5.35899  ], dtype=float32)\n\n%timeit gradient_kernel(x).block_until_ready()\n56.3 ms ± 7.11 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)\n```\n\n게다가, JAX의 조합 가능한 기능 덕분에 jax.grad를 jax.jit과 원활하게 결합하여 커널의 기울기를 자동으로 계산하는 최적화된 함수를 만들 수 있습니다. 이를 통해 JAX의 자동 미분 기능을 활용하여 효율적으로 그래디언트를 계산하는 동시에 JIT 컴파일을 통해 성능을 향상시킬 수 있습니다.\n\n```js\nimport jax\n\njitted_gradient_kernel = jax.jit(gradient_kernel)\n\n%timeit jitted_gradient_kernel(x).block_until_ready()\n192 µs ± 37.7 µs per loop (mean ± std. dev. of 7 runs, 1 loop each)\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n분자 시뮬레이션 맥락에서, 물리적 시스템 내 이차력은 총 포텐셜 에너지 함수의 그래디언트에서 얻어집니다. 이 관계는 자동 미분의 중요성을 강조하는데, 이를 통해 힘의 구성요소를 정확하고 효율적으로 계산할 수 있는 수단을 제공합니다. 자동 미분을 사용함으로써, 포텐셜 에너지 함수의 필요한 도함수를 정확하게 계산하여 힘의 구성요소가 고정밀로 결정되도록 할 수 있습니다.\n\n## III. 자동 벡터화\n\n벡터화된 계산은 개별 요소가 아닌 전체 배열에 작업을 적용하는 과정을 말합니다. 이는 현대 CPU 및 GPU의 가능성 (즉, SIMD)을 활용하여 연산을 병렬로 수행함으로써 전통적인 루프 기반 접근법에 비해 실행 시간이 크게 단축됩니다. Python에서 효율적인 코드를 작성하기 위해서 대부분의 경우 루프 사용을 피하고 배열에 작용하는 범용 함수의 효율적인 구현에 의존해야 합니다. 제 경험 상, 숫자 Python으로 전환하면 사고 방식 변화가 필요할 수 있습니다. C/C++와 같은 저수준 프로그래밍 언어는 여러 개의 루프를 일반적으로 사용하나, 숫자 Python의 접근 방식은 루프를 피하고 논리를 벡터 함수로 변환하는 것이 강조됩니다. 벡터화된 계산을 활용하면 전체 성능이 크게 향상됩니다. NumPy는 함수와 벡터화된 계산을 통해 혜택을 얻으며, 실제로 이는 그 성능과 효율성의 핵심 요소 중 하나입니다.\n\njax.vmap 변환은 함수의 벡터화된 구현을 자동으로 생성하여 배열에 대해 함수를 병렬 및 효율적으로 적용하는 것을 쉽게 만듭니다. 또한 명시적인 루프가 필요 없어지므로 코드를 간소화시킵니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 예시를 통해 위치 벡터 배열 간의 거리를 계산하는 방법이 얼마나 중요한지 살펴보겠습니다. 원자들 간의 거리를 결정하는 것은 분자 시뮬레이션에서 잠재 에너지를 평가하는 데 필수적입니다. 두 개의 배열 x와 y가 있다고 가정해보겠습니다. 각각은 일련의 원자들을 위한 위치 벡터를 포함하고 있습니다. 두 배열 모두 차원이 (natoms, 3)인데, 여기서 natoms은 원자의 수를 나타내고 배열의 각 벡터는 원자의 3D 좌표를 포함합니다. 우리의 목표는 이러한 배열에서 각각의 벡터 쌍 간의 거리를 포착하는 거리 행렬을 계산하는 것입니다. 아래 함수는 두 입력 배열 간의 이러한 거리 행렬을 반환합니다:\n\n```js\nimport jax.numpy as jnp\n\ndef calculate_distances(x, y):\n    distances = []\n    nrows, _ = x.shape\n    for i in range(nrows):\n        distances_from_single_point = jnp.sqrt(((x[i] - y)**2).sum(axis=1))\n        distances.append(distances_from_single_point)\n    return jnp.array(distances)\n```\n\n여기서 배열 계산을 사용하여 배열 x에 있는 각 지점에서 배열 y의 모든 지점까지의 거리를 효율적으로 계산했습니다. 예를 들어, 브로드캐스트된 항목 x[i] — y를 사용하여 명시적인 루프 없이 요소별 뺄셈을 수행할 수 있어 계산 효율성과 명확성을 높였습니다.\n\n이 프로세스는 JAX에서 자동적으로 효율적으로 vectorize될 수 있습니다. jax.vmap을 사용하면 입력 배열의 첫 번째 인덱스를 효율적으로 처리하도록 일관되게 작동하는 함수로 단일 특정 지점에서 작동하는 함수를 변환할 수 있습니다. 이러한 기능을 실행하기 위해 먼저 한 지점을 처리하는 함수를 정의한 다음 jax.vmap을 사용하여 입력 배열의 첫 번째 인덱스에 대해이 함수를 일괄 처리하도록 일반화하여 루프 없이 일괄 처리에 대한 효율적인 계산을 가능하게 합니다. 이 방식은 코드를 단순화하는 데 도움이 되며 빠른 실행을 위해 JAX의 최적화 기능을 활용합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nimport jax\n\ndef calculate_distances_from_single_point(xi, y):\n    return jnp.sqrt(((xi - y)**2).sum(axis=1))\n\nvmapped_calculate_distances = jax.vmap(\ncalculate_distances_from_single_point,\nin_axes=(0, None)\n)\n```\n\nin_axes=(0, None)는 벡터화된 함수의 입력 축을 지정합니다. 이 경우 첫 번째 인자 (xi)가 첫 번째 축 (0)을 따라 매핑되고, 두 번째 인자 (y)는 변경되지 않습니다(None). 이것은 모든 연산에서 동일하게 유지됨을 나타냅니다.\n\n두 구현 모두 동일한 결과를 생성합니다. 아래 단언문은 루프를 사용한 구현으로 계산된 거리와 벡터화된 구현으로 계산된 거리가 동일함을 보장합니다.\n\n```python\nimport jax\n\n# shape=(natoms, dim)의 무작위 배열 생성\nx = jax.random.normal(jax.random.key(2024), shape=(100, 3))\n\nassert jnp.allclose(\n  calculate_distances(x, x),\n  calculate_distances_vmap(x, x)\n)\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그럼에도 불구하고, 매핑된 함수의 성능은 벡터화가 더 잘 되어있기 때문에 크게 향상되었습니다. 또한 구현이 더 읽기 쉽습니다. 시간 프로필링 결과는 다음과 같이 이러한 차이점을 분명히 보여줍니다:\n\n```js\n%timeit calculate_distances(x, x).block_until_ready()\n93.5 ms ± 6.04 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)\nSpeed up:  1x\n\n%timeit vmapped_calculate_distances(x, x).block_until_ready()\n2.54 ms ± 147 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\nSpeed up:  36x\n```\n\n우리는 이제 다시 JIT 컴파일을 jax.vmap과 결합하여 더 나은 성능을 달성할 수 있습니다.\n\n```js\njitted_vmapped_calculate_distances = jax.jit(vmapped_calculate_distances)\n\n%timeit jitted_vmapped_calculate_distances(x, x).block_until_ready()\n60.3 µs ± 1.59 µs per loop (mean ± std. dev. of 7 runs, 10,000 loops each)\nSpeed up: 1558x\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 조합은 JAX의 고급 최적화 기법을 최대한 활용하여 계산의 효율성을 극대화합니다. 이 글에서 이에 대해 논의하고자 합니다.\n\n다음 섹션에서는 JAX가 실제 문제 해결과 파이썬에서 고성능 애플리케이션을 개발하는 믿을 수 있는 프레임워크가 될 수 있는 분자동역학 쇼케이스를 소개할 것입니다.\n\n# 분자동역학 쇼케이스\n\n문서에서 명확하고 명확하게 정의된 코드 예제는 종종 복잡한 문제에 대처할 때 단점이 됩니다. 더욱 심각한 문제와 상호작용하는 것은 항상 우리의 이해력을 향상시키고 최적화된 응용 프로그램을 개발하기 위해 고급 기능을 활용할 수 있게 만들어줍니다. 분자 시뮬레이션의 복잡한 세부 사항에 심취하지 않아도 이 쇼케이스가 도움이 되었으면 좋겠습니다. 그 세부 전문 지식을 요구하는 분야에 대한 이해를 강조하기 위해 간단한 원자 시스템에 초점을 맞추어 JAX 스크립트 최적화에 필요한 주요 기능을 강조하기로 결정했습니다. 이 예는 기본 도메인 지식에 대한 더 명확한 이해를 용이하게 하기 위해 일부러 단순하게 유지되었습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## MD 시뮬레이션이란?\n\n분자동력학(MD) 시뮬레이션은 원자와 분자의 물리적 움직임을 연구하는 데 사용되는 강력한 계산 방법입니다. 이는 이러한 입자들의 움직임을 시뮬레이션하여 복잡한 시스템의 물리적 및 화학적 특성에 대한 세부적인 통찰력을 제공합니다. MD 시뮬레이션은 물리학, 화학, 재료과학과 같은 다양한 분야에서 널리 사용되며 실험적으로 포착하기 어려운 현상의 미시적인 관점을 제공합니다.\n\nMD 시뮬레이션의 중요한 부분은 힘 필드(force field)입니다. 이는 분자 시스템의 잠재 에너지를 정의하는 수학적 함수와 매개 변수들의 모음입니다. 이는 원자들이 서로 상호작용하는 방식을 결정하며, 이들의 움직임을 이끄는 힘을 제공합니다. 원자들은 뉴턴의 운동 방정식에 따라 움직이며, 이는 입자의 위치와 속도가 어떻게 시간이 지남에 따라 변하는지를 설명하며, 그들에게 작용하는 힘에 반응합니다. Verlet 알고리즘은 뉴턴의 운동 방정식을 해결하기 위한 흔히 사용되는 수치 적분 방법입니다.\n\n## 초기 구조\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nMD 시뮬레이션을 시작하려면 일반적으로 원자의 위치와 속도가 실험 구조나 무작위로 생성된 배열과 같은 특정 구성을 기반으로 초기화됩니다. 따라서 아래 코드는 ASE 패키지를 사용하여 헬륨 원자들의 간단한 입방격자 구조를 생성하고, JAX 배열에서 원자 좌표 및 관련 정보를 저장하는 컨테이너인 Pantea에 해당 구조를 만듭니다:\n\n```js\nfrom ase import Atoms\nfrom ase.visualize import view\nfrom pantea.atoms import Structure\n\nd = 6  # Angstrom 단위의 원자 간 거리\nunit_cell = Atoms('He', positions=[(d/2, d/2, d/2)], cell=(d, d, d))\ninitial_structure = Structure.from_ase(unit_cell.repeat((10, 10, 10)))\n\nview(atoms=initial_structure.to_ase(), viewer='ngl')\n```\n\n<img src=\"/TIL/assets/img/2024-07-07-WhyYouShouldLearnJAXAMolecularDynamicsShowcase_1.png\" />\n\n## 레너드-존스 힘장력\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n두 원자 간 상호 작용을 설명하기 위한 간단한 힘장 중 하나는 Lennard-Jones (LJ)입니다. 이는 약한 분자간 인력과 척력을 모델링하는 데 특히 유용합니다. 우리는 주어진 입력 구조에 대해 총 Lennard-Jones 포텐셜 에너지와 힘 성분을 계산하는 잠재 클래스를 정의해 보겠습니다.\n\n```js\nimport jax\nimport jax.numpy as jnp\nfrom jax import Array\nfrom pantea.atoms import Structure\nfrom typing import NamedTuple, Optional\n\nclass LJPotentialParams(NamedTuple):\n    epsilon: Array\n    sigma: Array\n\nclass LJPotential:\n    \"\"\"Lennard-Jones 포텐셜의 간단한 구현입니다.\"\"\"\n    def __init__(\n        self,\n        sigma: float,\n        epsilon: float,\n        r_cutoff: float,\n    ) -> None:\n        self.sigma = jnp.array(sigma)\n        self.epsilon = jnp.array(epsilon)\n        self.r_cutoff = jnp.array(r_cutoff)\n    def __call__(self, structure: Structure) -> Array:\n        \"\"\"총 포텐셜 에너지를 계산합니다.\"\"\"\n        return _compute_total_energy(\n            LJPotentialParams(self.epsilon, self.sigma),\n            structure.positions,\n            structure.lattice,\n            self.r_cutoff,\n        )\n    def compute_forces(self, structure: Structure) -> Array:\n        \"\"\"모든 원자에 대한 힘 성분을 계산합니다.\"\"\"\n        return _compute_forces(\n            LJPotentialParams(self.epsilon, self.sigma),\n            structure.positions,\n            structure.lattice,\n            self.r_cutoff,\n        )\n```\n\nLJPotentialParams는 Lennard-Jones 포텐셜을 위해 두 가지 필수 매개변수를 저장하는 네임드 튜플입니다.\n\nLJPotential 클래스는 입력 구조를 가져와 필수 인자를 두 내부 커널 함수인 \\_compute_total_energy와 \\_compute_forces로 전달하여 원하는 물리적 양을 계산하고 반환하는 역할을 실제로 담당합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기서 흥미로운 부분은 JAX 기능을 활용하여 함수를 최적화하는 것입니다. 다음으로, 에너지와 힘 계산의 핵심인 커널에 대해 별도로 설명하겠습니다.\n\n## 위치 에너지\n\n이론\n두 원자 간의 레너드-존스 포텐셜은 다음 방정식으로 정의됩니다:\n\n![equation](/TIL/assets/img/2024-07-07-WhyYouShouldLearnJAXAMolecularDynamicsShowcase_2.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nV(r)은 두 입자 간의 거리 r의 함수로 표현되는 포텐셜 에너지이다. ε 매개변수는 인력의 강도를 나타내는 포텐셜 우물의 깊이를 의미한다. σ 매개변수는 상호작용하는 입자 간의 포텐셜이 제로가 되는 유한 거리로, 원자의 유효 지름을 나타낸다. 첫 번째 항은 보통 더 긴 범위에서 우세한 인력적 반 데르 발스 힘을 설명하고, 두 번째 항은 매우 짧은 거리에서 겹치는 전자 궤도 때문의 폴리 원자간 척반을 설명한다. rcut은 포텐셜이 제로로 간주되는 거리 범위를 나타내는 절단 반경이다. 일반적으로 상호작용 범위를 제한하여 효율성과 물리적 정확성을 향상시키기 위해 절단이 사용된다.\n\nN 입자로 이루어진 시스템의 총 포텐셜 에너지 U는 모든 입자 쌍에 걸친 쌍별 상호작용의 합으로 다음과 같이 나타낼 수 있다:\n\n[테이블 태그를 마크다운 형식으로 변경합니다.]\n\n여기서, rij는 입자 i와 입자 j 사이의 거리이다. 각 입자 쌍이 한 번만 고려되도록 해야 하며 (중복 계산 없음), 자기 상호작용은 무시해야 한다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n구현\n아래의 Python 코드는 원자 쌍 간의 Lennard-Jones 포텐셜 에너지를 계산하는 함수를 정의합니다.\n\n```js\ndef _compute_pair_energies(params: LJPotentialParams, r: Array) -> Array:\n    term = params.sigma / r\n    term6 = term**6\n    return 4.0 * params.epsilon * term6 * (term6 - 1.0)\n```\n\n\\_compute_pair_energies 함수는 주어진 거리 (r)에 따른 원자 쌍의 Lennard-Jones 포텐셜 에너지를 계산합니다. 이 함수는 포텐셜 매개변수 (params)를 사용하고 계산 (식 1)을 수행하여 포텐셜 에너지의 배열을 반환합니다.\n\n다음으로, 우리는 아래와 같이 원자 시스템의 총 Lennard-Jones 포텐셜 에너지를 계산하기 위한 JIT 컴파일된 함수를 정의합니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport jax\nimport jax.numpy as jnp\nfrom pantea.atoms.neighbor import _calculate_masks_with_aux_from_structure\n\n@jax.jit\ndef _compute_total_energy(\n    params: LJPotentialParams,\n    positions: Array,\n    lattice: Optional[Array],\n    r_cutoff: Array,\n) -> Array:\n    masks, (rij, _) = _calculate_masks_with_aux_from_structure(\n        positions, r_cutoff, lattice\n    )\n    pair_energies = _compute_pair_energies(params, rij)\n    pair_energies_inside_cutoff = jnp.where(masks, pair_energies, 0.0)\n    return 0.5 * jnp.sum(pair_energies_inside_cutoff)\n```\n\n\\_calculate_masks_with_aux_from_structure 함수는 불리언 배열(masks)을 계산하여 각 원자 쌍이 cutoff 거리 내에 있는지를 나타내는데, 자기 상호작용은 제외됩니다. 또한 원자 쌍 간의 거리를 담은 배열(rij)을 반환하여, pair potential 평가를 위해 이 거리를 재계산하는 것을 피합니다. 이 함수는 Pantea에서 가져온 것이며, 이를 통해 토론을 간소화합니다. 거리를 계산하기 위해, 시뮬레이션 상자의 주기적 경계 조건(lattice)도 고려됩니다.\n\n이전에 설명한 대로, \\_compute_pair_energies 함수는 잠재 에너지 매개변수와 거리(rij)를 사용하여 각 원자 쌍의 LJ 포텐셜 에너지를 계산합니다.\n\njnp.where는 masks를 적용하여 cutoff 거리 밖에 있는 원자 쌍에 대한 에너지를 0으로 설정하는 데 사용됩니다. 이 메서드는 루프를 사용하지 않고 배열에 조건부 논리를 효율적으로 적용합니다. np.where는 내부적으로 고도로 최적화된 C 코드로 구현되어 있습니다. 한꺼번에 전체 배열에 작용하여 벡터화된 작업을 수행할 수 있는 JAX의 능력을 활용합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n총 에너지는 jnp.sum을 사용하여 반환됩니다. 각 쌍의 상호 작용이 두 번 계산되기 때문에 0.5를 곱하여 계산합니다. 각 쌍이 두 번 고려되기 때문에 0.5를 곱해서 각 쌍의 상호 작용을 총 에너지로 계산합니다.\n\n간단히 말해서 \\_compute_total_energy 함수는 원자 시스템의 전체 Lennard-Jones 포텐셜 에너지를 계산합니다. 먼저, 두 원자 쌍이 cutoff 거리 내에 있는지를 결정하기 위해 부울 마스크를 생성합니다. 그런 다음, rij를 사용하여 모든 쌍에 대한 레너드-존스 에너지를 계산하고, cutoff 내부의 쌍 에너지를 필터링하여 cutoff 거리를 고려한 쌍 에너지를 합산합니다. 이 함수는 원자 위치에 기초하여 총 상호 작용 에너지를 제공하는 MD 시뮬레이션에서 중요한 역할을 합니다.\n\n원자별로 쌍 에너지를 계산해야 한다면 비효율적으로 보일 수 있습니다. 과거에는 이를 피하기 위해 if 문을 추가했지만, 이 구현에 비해 성능이 상당히 떨어지는 것을 발견했습니다. 이 구현은 벡터화된 계산을 사용하며, 전통적인 저수준 언어 접근 방식에서 벗어나 핵심 계산을 위해 배열 계산에 중점을 둘 필요가 있음을 강조합니다. C/C++로 모든 것을 최적화하려면 몇 일이 걸릴 수 있지만, Python의 이 방법을 통해 벡터화를 통해 훨씬 더 나은 성능을 달성하고 개발 시간을 크게 단축할 수 있습니다. 게다가, JAX 작업은 내부적으로 병렬화되어 있으며 실행 시간을 더 최적화하기 위해 여러 스레드를 활용합니다.\n\n아래 예시 코드는 1000개의 원자를 포함하는 입력 구조체에 대한 총 포텐셜을 계산하는 방법과 예상 실행 시간을 보여줍니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nljpot(initial_structure)\n# Array(-0.00114392, dtype=float64)\n\n%timeit ljpot(initial_structure).block_until_ready()\n5.12 ms ± 38.9 µs per loop (mean ± std. dev. of 7 runs, 100 loops each))\n```\n\n## Force vector\n\n이론\n레너드-존스 시스템 내 두 입자 사이의 힘은 포텐셜 에너지에서 유도될 수 있습니다. i 입자에 대한 입자 j로 인한 힘 벡터 Fij는 레너드-존스 포텐셜 V(rij)의 음의 그래디언트로 주어집니다:\n\n<img src=\"/TIL/assets/img/2024-07-07-WhyYouShouldLearnJAXAMolecularDynamicsShowcase_4.png\" />\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nrij = ri — rj은 j 입자에서 i 입자를 가리키는 벡터를 나타냅니다. 우리는 힘에 대한 cutoff도 적용합니다. 입자 i에 작용하는 총 힘을 계산할 때, 다른 모든 입자 j로부터의 기여를 합산합니다:\n\n![image](/TIL/assets/img/2024-07-07-WhyYouShouldLearnJAXAMolecularDynamicsShowcase_5.png)\n\n이는 시스템 내의 다른 모든 입자들로 인해 입자 i에 작용하는 순 힘을 제공하면서 자기 상호작용은 제외합니다.\n\n구현\n아래 코드는 Equation 3을 사용하여 원자 쌍 간의 힘을 계산합니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ndef _compute_pair_forces(params: LJPotentialParams, r: Array, R: Array) -> Array:\n    term = params.sigma / r\n    term6 = term**6\n    coefficient = -24.0 * params.epsilon / (r * r) * term6 * (2.0 * term6 - 1.0)\n    return jnp.expand_dims(coefficient, axis=-1) * R\n```\n\n\\_compute_pair_forces 함수는 레너드-존스 포텐셜을 사용하여 원자 쌍 간의 힘을 계산합니다. 이 함수는 잠재력 정의 매개변수, 원자 쌍 간의 거리 및 상대적인 위치 벡터를 입력으로 받습니다.\n\njnp.expand_dims(factor, axis=-1) \\* R: 상대적인 위치 벡터 R을 계산된 힘 인자로 확장하고, 곱셈 방송에 적합한 차원을 보장하기 위해 expand_dims를 사용합니다. 결과 배열은 각 원자 쌍 간의 힘을 나타냅니다.\n\n다음으로, 우리는 다음과 같이 방정식 4를 사용하여 총 힘을 계산합니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\n@jax.jit\ndef _compute_forces(\n    params: LJPotentialParams,\n    positions: Array,\n    lattice: Optional[Array],\n    r_cutoff: Array,\n) -> Array:\n    masks, (rij, Rij) = _calculate_masks_with_aux_from_structure(\n        positions, r_cutoff, lattice\n    )\n    pair_forces = _compute_pair_forces(params, rij, Rij)\n    pair_forces_inside_cutoff = jnp.where(\n        jnp.expand_dims(masks, axis=-1),\n        pair_forces,\n        jnp.zeros_like(Rij),\n    )\n    return jnp.sum(pair_forces_inside_cutoff, axis=1)\n```\n\n\\_compute_forces 함수는 최적화를 위해 JIT 컴파일로 각 원자에 작용하는 총 힘을 계산합니다.\n\n\\_calculate_masks_with_aux_from_structure 함수는 cutoff 불리언 마스크를 계산하고 더불어 페어와이즈 거리 (rij) 및 상대적인 위치 벡터 (Rij)를 반환합니다.\n\njnp.where 함수는 마스크가 True일 때에만 계산된 페어 힘을 적용합니다. jnp.expand_dims(masks, axis=-1)는 브로드캐스팅을 위해 마스크 차원이 Rij와 일치하도록 합니다. 마스크가 False일 때는 0 힘 벡터를 할당합니다 (jnp.zeros_like(Rij)). 또한 JAX는 오버헤드를 줄이기 위해 메모리 풀을 사용하므로 제로 크기 벡터를 할당하는 것은 계산적으로 비용이 크지 않습니다. 배열에 대한 참조 재할당은 OS로부터 실제 메모리 할당이 포함되지 않기 때문입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마지막으로, jnp.sum(pair_forces, axis=1)를 반환하면 각 원자에 작용하는 총 힘을 계산하여 모든 다른 원자를 고려합니다.\n\n상자 내 모든 원자의 힘 구성 요소를 계산하고 실행 시간을 측정하는 유사한 예제 코드:\n\n```js\nljpot.compute_forces(initial_structure)\n# Array([[ 1.11173074e-21,  1.11173074e-21,  1.11173074e-21],\n#       ...,\n#       [-1.87935435e-21, -1.87935435e-21, -1.87935435e-21]],  dtype=float64)\n\n%timeit ljpot.compute_forces(initial_structure).block_until_ready()\n6.71 ms ± 4.63 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\n```\n\n지금까지 잘 진행되고 있어요!\n여기까지 우리는 MD 시뮬레이션에 필요한 Lennard-Jones 포텐셜의 JAX 버전을 구현했습니다. 다음 단계는 이 포텐셜과 초기 구조를 사용하여 시스템을 시간에 따라 시뮬레이션하는 것입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 분자동력학 시뮬레이션\n\n시스템을 시뮬레이션하기 위해 Pantea에 있는 MDSimulator 모듈을 사용합니다. 이 모듈은 시뮬레이션이 어떻게 진행될지를 정의하며, 적분 알고리즘, 열장치 및 필요한 기타 시뮬레이션 설정을 포함합니다. 시스템을 일정한 온도에서 시뮬레이션하므로 온도조절기를 정의하는 것이 필요합니다.\n\n다음 매개변수를 사용하여 MD 시뮬레이터를 초기화해 봅시다:\n\n```js\nfrom pantea.simulation import MDSimulator, BrendsenThermostat\n\ntime_step = 0.5 * units.FROM_FEMTO_SECOND      # 0.5e-15 초\nthermostat = BrendsenThermostat(               # 온도 제어\n  target_temperature=300.0,                    # 26도의 상온\n  time_constant=100 * time_step                # 온도 조절 속도\n)\nsimulator = MDSimulator(time_step, thermostat)\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음으로, 우리는 사실 원자들과 그들 사이의 상호 작용을 단순히 표현한 시스템을 만들 것입니다. 이 시스템은 원자의 위치, 속도, 그리고 상호 작용 매개 변수와 같은 정보를 포함합니다. 입력 구조로부터 시스템을 다음과 같이 생성할 수 있습니다:\n\n```js\nfrom pantea.simulation import System\n\nsystem = System.from_structure(\n  initial_structure,   # 원자의 초기 위치\n  potential=ljpot,     # 상호 작용을 LJ로 설정\n  temperature=300.0    # 온도에 기반하여 원자 속도 초기화\n)\n```\n\n마지막으로, MD 시뮬레이션을 실행하기 위해 simulate 함수를 호출합니다.\n\n```js\nfrom pantea.simulation import simulate\n\n# simulate(sys, simulator) # 워밍업 단계\nsimulate(system, simulator, num_steps=10000, output_freq=1000)\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nnum_steps=10000: 이 매개변수는 수행할 총 시뮬레이션 단계의 수를 설정합니다. 각 단계는 일반적으로 시뮬레이션된 시간의 작은 증가에 해당하며 해당 기간 동안 원자의 위치와 속도가 업데이트됩니다.\n\noutput_freq=1000: 이 매개변수는 시뮬레이션 결과를 얼마나 자주 출력할지 지정합니다. 이 경우 데이터는 1000개의 시뮬레이션 단계마다 저장되거나 출력됩니다.\n\n결과적으로 각 1000단계 후에 단계, 온도, 포텐셜 에너지 및 압력과 같은 물리적 특성을 출력합니다.\n\n![링크 텍스트](/TIL/assets/img/2024-07-07-WhyYouShouldLearnJAXAMolecularDynamicsShowcase_6.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래 그림은 주기 상자 내의 1000개 헬륨 원자를 사용한 MD 시뮬레이션의 시간 진화를 설명합니다:\n\n![그림](https://miro.medium.com/v2/resize:fit:1400/1*7S2L0PRoZSHhxMf3UtIvxA.gif)\n\n성능\n아래 그래프에서 볼 수 있듯이, 우리의 JAX 커널은 GPU (장치 1)의 거의 전체 용량을 효율적으로 활용하여 시뮬레이션을 수행합니다. 이 높은 수준의 자원 이용은 GPU의 계산 성능이 최대화되어 시뮬레이션의 속도와 성능이 크게 향상되는 것을 보장합니다.\n\n![그림](/TIL/assets/img/2024-07-07-WhyYouShouldLearnJAXAMolecularDynamicsShowcase_7.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저는 노트북 CPU와 더 강력한 GPU인 A100에서 동일한 MD 시뮬레이션을 수행했습니다. 결과는 GPU 계산으로 인한 상당한 속도 향상을 보여줍니다. GPU 하드웨어 사용의 중요성을 강조하기 위해 원자가 2000개인 시스템을 시뮬레이션했습니다. JAX의 훌륭한 기능 중 하나는 원본 코드를 수정하지 않고 CPU에서 GPU로 코드 실행을 원활하게 전환할 수 있다는 것이며, 이는 상당한 시간과 노력을 절약할 수 있습니다.\n\n![image](/TIL/assets/img/2024-07-07-WhyYouShouldLearnJAXAMolecularDynamicsShowcase_8.png)\n\n나노초당 일은 MD 시뮬레이션의 성능과 효율성을 나타내는 일반적인 측정 지표로, 시뮬레이션이 얼마나 빠르게 진행되는지를 보여줍니다. 그림에서 나타나듯이 GPU 가속 컴퓨팅은 코드의 성능을 수십 배 향상시킬 수 있습니다. 대규모 시뮬레이션의 경우, 도메인 분해를 사용하여 시스템을 병렬화하는 것이 최적의 접근 방식입니다. 이 방법을 사용하면 각 도메인은 제한된 GPU 메모리 요구 사항을 가지고 힘을 계산하고 원자 상태를 업데이트하는 데 사용할 수 있습니다.\n\n# 마무리\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 게시물이 여러분의 호기심을 자극하고 JAX를 탐구하고 배우며 여러분의 프로젝트에 적용하는 데 도움이 되기를 바랍니다.\n\n아래 링크된 저장소를 통해 JAX와 함께 하는 내 Pantea 프로젝트에 대해 더 알아보실 수 있습니다. 거기서는 JAX의 자동 미분 기능을 널리 활용하고 있습니다. 이 작업은 아직 진행 중이며 피드백이나 의견을 환영합니다.\n\n읽어주셔서 감사합니다. JAX를 더 깊이 파고들어 작업에 최대한의 잠재력을 발휘하도록 장려합니다!\n","ogImage":{"url":"/assets/img/2024-07-07-WhyYouShouldLearnJAXAMolecularDynamicsShowcase_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-WhyYouShouldLearnJAXAMolecularDynamicsShowcase_0.png","tag":["Tech"],"readingTime":31},{"title":"코스 파이썬으로 퀀트 트레이더 되기 - 최고 품질 데이터 얻는 방법","description":"","date":"2024-07-07 12:49","slug":"2024-07-07-CourseBecomeaQuantTraderwithPythonHowtoGetTopQualityData","content":"\n![이미지](/TIL/assets/img/2024-07-07-CourseBecomeaQuantTraderwithPythonHowtoGetTopQualityData_0.png)\n\n주식 거래를 위해 Python으로 알고리즘을 코딩하기 시작하는 경우, 가장 중요한 질문은 무엇을 찾고 어디서 찾을지입니다. 저는 정확히 그것을 연구하는 데 상당한 시간을 할애했고 도움을 줄 수 있습니다.\n\n이 기사에서는 승리를 창출하는 알고리즘을 만들기 위해 필요한 모든 것을 담은 매우 포괄적인 데이터프레임을 구축할 것입니다. 그리고 더 중요한 점은 여기에서 공유하는 코드가 데이터의 다른 시간대를 가져오기에 매우 쉽게 적응할 수 있도록 설계된 것입니다. 따라서 필요할 때 작업을 가속화하는 데 도움이 될 것입니다.\n\n우선, 주식 데이터를 가지고 있는 다양한 API가 있지만, 양적 분석을 위해 알파베티지(https://www.alphavantage.co/)를 추천할 것입니다. 왜냐하면 이미 다양한 지표가 계산되어 있고 1분 단위의 투자자에게 필요한 내부 시장성에 대한 데이터도 제공하기 때문입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 데이터 가져오기\n\n다음 코드 조각은 선택한 티커에 대한 데이터를 자동으로 가져와 데이터프레임으로 연결합니다:\n\n```js\n!pip install alpha_vantage\nfrom datetime import datetime\nfrom datetime import timedelta\n\nfrom alpha_vantage.timeseries import…\n```\n","ogImage":{"url":"/assets/img/2024-07-07-CourseBecomeaQuantTraderwithPythonHowtoGetTopQualityData_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-CourseBecomeaQuantTraderwithPythonHowtoGetTopQualityData_0.png","tag":["Tech"],"readingTime":2},{"title":"내 GSoC 여정  1단계","description":"","date":"2024-07-07 12:47","slug":"2024-07-07-MyGSoCJourneyPhase1","content":"\n제가 말한 블로그 시리즈의 첫 부분을 아직 확인하지 않으셨다면 확인해주세요. 이것은 필수는 아니지만 일부 맥락을 제공합니다.\n\n# 소개 - PictoPy\n\nPictoPy는 디지털 사진의 처리 방식을 혁신적으로 바꿔주기 위해 설계된 현대적인 데스크탑 앱입니다. 이 앱은 사물, 얼굴 또는 장면을 기반으로 한 사진에 대한 스마트 태깅 기능을 제공하여 효율적인 갤러리 관리를 용이하게 해줍니다.\n\n이 프로젝트는 AOSSIE에 의해 발표되었으며 처음부터 구현되기로 했습니다. 이는 Google 사진과 유사하게 객체 감지 및 얼굴 유사성과 같은 기능을 제공합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 배경\n\nGSoC 이전에 프로젝트에 몇 개의 Pull Request를 이미 제출했습니다. 우리가 무엇을 하려고 하는지 이해하려 머리를 쥐어뜯았습니다. 이 Pull Request에는 주로 Google Colab에서 다양한 유형의 모델을 테스트하고 마지막으로 출력을 제공하고 추론 속도를 벤치마킹하는 것이 포함되었습니다.\n\n당시, 물체 탐지 및 얼굴 탐지를 위해 다양한 모델을 탐구했습니다. 우리가 시도한 첫 번째 모델은 Ultralytics의 YOLOv8 모델이었습니다. 이 모델은 훌륭한 추론 속도와 많은 온라인 자습서를 가지고 있어서 바로 이것을 사용할 수 있을 것이라는 것이 명백했습니다. 이 프로젝트는 처음부터 만들어지고 있기 때문에 시작할 때 모든 것을 결정하고 확정하기가 매우 어렵습니다.\n\n그러나 얼굴 탐지 및 인식은 더 어려웠습니다. 얼굴 임베딩과 유사성 측정을 제공하는 많은 라이브러리와 모델이 있었습니다. 당시에 직면한 공통 문제 중 하나는 어린이의 얼굴을 잘 탐지하지 못하는 것이었습니다(예: 파이썬의 facial_recognition 라이브러리). 모든 유형의 얼굴을 탐지할 수 있는 몇 가지 모델이 있었지만, 이러한 모델들은 유사성 성능이 우수했습니다. 우리는 궁극적으로 결정을 내렸습니다. 얼굴 탐지에는 다른 라이브러리를 사용하고, 얼굴 인식에는 다른 라이브러리를 사용할 것입니다. 두 가지 모두 최고의 성과를 얻을 수 없었으므로, 우리가 선택한 얼굴 탐지 모델은 yolo-face 모델이었고, 이 모델에서 얼굴을 자르고 정렬한 후 임베딩을 추출하여 face recognition에 전달했습니다. facial_recognition 라이브러리는 이를 잘 수행했습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지금까지 우리는 애플리케이션에 후보가 될 수 있는 몇 가지 모델을 가지고 있었고 마인드에 워크플로우도 있었습니다. 아마도 전면 갤러리 측면에 대해 아직 논의하지 않았을 것을 알아채셨을 것입니다. 단지 백엔드 부분(특히 CNNs)에 대해 더 관심이 있었기 때문입니다. 백엔드에서 기반 준비가 되면 앱 갤러리를 생성하여 API 호출을 할 수 있을 만큼 React(및 Electron)을 사용하는 방법을 알고 있었으며 백엔드 준비가 되었을 때 구현할 수 있을 것이라고 확신했어요. 또한 공개 소스 세계에서는 언제든지 누군가가 도와줄 것이므로 그때는 프론트엔드로 걱정할 필요가 없었습니다. 디자인에 있어서는 나보다 더 창의력과 기술을 가진 사람들이 분명히 있기 때문이죠. 그럼에도 불구하고 제 제안서에는 프로젝트의 프론트엔드와 백엔드 부분을 어떻게 다룰 것인지 언급했고 가끔가다 제가 쓴 내용을 다시 상기시키기 위해 그것을 다시 참고했습니다.\n\nGSoC 참여자가 발표된 후 PictoPy에는 저 외에 두 명의 사람이 선택되었습니다. 이로써 우리 모두가 이 프로젝트를 다양한 각도에서 접근하고 충분히 아이디어 회의를 진행할 수 있었습니다. 커뮤니티 결속 기간 동안 우리는 멘토와 빈도 있는 회의를 갖고 최종 제품을 위한 기술 스택, 아키텍처 및 디자인에 대해 논의했어요. 최종 선택 수에 따라 목표가 변경되어 우리 모두는 계획을 재정의하고 작업을 분배해야 했습니다.\n\n# 우리의 접근\n\n## 1. 설정\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n백앤드에서는 다른 프로젝트에서 가져온 스타터 FastAPI 코드를 설정했어요. 이것에는 표준 디렉토리 구조 및 명명 규칙과 Linux에서는 uvcorn을 사용하여 bash 스크립트에서 빠르게 실행되는 앱, Windows에서는 bat 파일이 포함되어 있었어요.\n\n멘토와 프로젝트의 스키마를 논의하면서 객체 탐지 모델을 찾았어요. 우리가 직면한 한 가지 문제는 라이브러리의 크기가 최종 제품 측면에서 다소 크다는 것이었어요. Ultralytics 라이브러리 (PyTorch를 사용하는)는 5GB 크기의 가상 환경과 함께 제공되었는데, 이를 cpu 모드로 설치하면 이 크기가 2GB로 줄었어요.\n\n2GB는 여전히 많은 것 같았어요. 우리가 필요한 모델이 약 80MB 크기면서도요. 그때 ONNX 형식에 대해 알게 되었어요. 이것은 큰 도움이 되었고, 우리는 대략 400MB의 가상 환경과 우리가 사용하는 모델 크기를 더한 객체 탐지 모델을 설정할 수 있었어요.\n\n![image](/TIL/assets/img/2024-07-07-MyGSoCJourneyPhase1_0.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n요거 간단해졌네요. 이제 우리는 사용하는 모델들의 ONNX 형식과의 호환성을 찾아야 한다는 것을 알았고, 그것을 다시 사용할 수 있었으며, 마침내 애플리케이션 크기를 어느 정도로 컨트롤할 수 있게 된 것 같아요.\n\n## 2. 병렬 처리를 이용한 라우팅 로직\n\n라우팅 로직을 다루면서, 우리는 FastAPI를 사용하고 있었기 때문에 프론트엔드에서의 요청이 블로킹되지 않도록 하는 방법을 찾아야 했어요. 다시 말해, 프론트엔드는 이미지 처리가 끝날 때까지 기다리지 않아야 했고, 갤러리에 더 많은 사진을 추가할 수 있어야 했어요. 갤러리에 사진을 추가하고 프론트엔드에 표시하는 것은 이 사진들을 처리하고 클래스를 감지하는 것보다 훨씬 빠른 단계예요. 이는 백엔드에서 실행될 수 있기 때문이죠.\n\n이런 결정들은 나중에 이 백엔드가 미래의 다른 어플리케이션과 호환이 되도록 하기 위해 적절한 엔드포인트를 제공하고 프론트엔드와의 낮은 결합 디자인을 유지하는 것을 염두에 두고 내려졌어요. 이를 위해 우리는 우리의 갤러리 앱에 추가된 여러 이미지를 병렬로 처리하는 방법을 찾아야 했어요. 그때 우리는 파이썬의 스레딩과 같은 옵션들을 시도해보았는데, 그때는 파이썬에서 한 번에 하나의 스레드만 실행할 수 있는 Global Interpreter Lock에 대해 알 지 못했었어요. 이에 대해 더 읽고 싶다면 아래에서 공유한 자료들을 따라보세요. 이외에도 우리는 애플리케이션에 복잡성을 도입한 multiprocessing 라이브러리를 사용해 보기도 했어요. 우리는 FastAPI와 uvicorn 그리고 기본적으로 하나의 워커 프로세스로 실행되는 gunicorn 워커를 사용하고 있었는데, multiprocessing을 실행하기 위해 각각 FastAPI 애플리케이션의 인스턴스를 갖는 여러 워커 프로세스를 구성해야 했고, uvicorn을 사용함으로써 교차 플랫폼 호환성 문제에 부딪히기도 했었어요. 결국 우리는 hypercorn을 사용하게 되었어요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마침내, 우리는 asyncio를 사용하기로 결정했어요. FastAPI는 asyncio를 완전히 지원하는 비동기 웹 프레임워크인 Starlette 위에서 구축되었어요.\n\n![이미지](/TIL/assets/img/2024-07-07-MyGSoCJourneyPhase1_1.png)\n\n이러한 결정들은 커뮤니티, 팀 및 멘토의 피드백을 기반으로 시간이 지남에 따라 개선되었어요.\n\n## 3. 데이터베이스 설계\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n전통적인 이미지 갤러리 데스크톱 애플리케이션으로, 구조화된 방식으로 작업을 수행하기 위해 일종의 데이터베이스 스키마가 필요했습니다. 이미지에 대한 경로를 키로 원래 저장하면서(이는 클라이언트로부터의 페이로드이기도 합니다), 이미지를 처리하여 모델이 감지한 클래스를 기반으로 해당 객체에 속하는 인덱스를 추가했습니다. 이미지의 메타데이터(생성 날짜, 크기, 형식 등)도 저장하고, 미래에는 이미지에서 발견된 얼굴 임베딩 목록(파란색으로 표시)을 저장할 예정입니다.\n\n![이미지](/TIL/assets/img/2024-07-07-MyGSoCJourneyPhase1_2.png)\n\n이렇게 구성된 상태에서 우리는 앨범 스키마를 정의하여 앞으로 나아갔는데, 이는 많은 이미지와 일부 앨범 기능으로 이루어져 있었습니다. 여기서 주요 키는 앨범 이름 자체이며, 사용자가 필요한 경우 제공할 수 있는 간단한 설명이 함께 포함된 앨범의 경로입니다.\n\n![이미지](/TIL/assets/img/2024-07-07-MyGSoCJourneyPhase1_3.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리 갤러리 앱의 특성과 모델과의 호환성 때문에 이러한 스키마는 시간이 지남에 따라 계속 변화합니다. 더 구체적인 매핑을 얻기 위해 더 많은 스키마를 생성할 계획이며, 예를 들어 이미지 경로의 숫자/uuID를 포함하는 별도의 테이블을 생성하여 이를 모든 곳에서 주 키로 사용할 예정입니다. 미래에 예상되는 어려움 중 하나는 사용자가 파일 시스템을 통해 응용 프로그램 외부에서 이미지를 수동으로 삭제하는 경우에 대처해야 할 것입니다.\n\n# 우리의 미래 목표\n\n다양한 얼굴 인식 모델을 탐색하면서 이러한 모델이 ONNX 형식과 호환되는지 확인해야 했습니다. 이를 위해 ONNX 저장소에는 그러한 인식 모델의 예제가 있습니다. arcface가 그 중 하나입니다. 이것이 우리가 필요한 바로 그것이며, 우리 애플리케이션에 이를 통합할 것입니다.\n\n우리가 흔히 하는 작업 흐름 중 하나는 아이디어를 고안하는 것, 이 아이디어에 대한 모델을 찾는 것, 이러한 모델의 ONNX 형식 지원을 찾는 것, 그리고 이를 통합하는 것입니다. 이 작업에 OpenVINO를 사용하는 것이 좋았습니다. 훌륭한 문서와 모델을 실행하는 데 사용할 수 있는 예제 노트북이 포함된 Model Zoo가 제공되었습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이것은 우리 응용 프로그램에 많은 가능성을 열어 주었습니다. Linux, Windows 및 MacOS에서 런타임을 사용하여 교차 플랫폼 호환성을 보장할 수 있습니다. 이것은 다양한 모델을 제공하며 중간 표현(IR)으로 변환하여 사용할 수 있습니다. 다행히도 arcface는 OpenVINO에서 문서화 된 모델 중 하나였습니다. 우리는 정렬 없이 LFW 데이터셋의 이러한 모델들을 테스트한 결과 얼굴 모델의 사이즈가 약 200MB 정도일 때 꽤 잘 동작합니다. 이것은 얼굴 정렬과 landmark detection (눈, 코, 입 등)을 위한 MTCNN을 지원하며, 우리는 이를 향후 통합할 계획입니다.\n\n나중에 이러한 임베딩을 사용하여 비슷한 얼굴을 포함하는 사진을 클러스터링하여 사용자에게 구글 포토와 유사하게 특정인의 이미지를 반환하는 옵션을 제공할 수 있습니다. OpenVINO를 사용한다면 저장한 태그에 기반한 검색 기능도 추가할 수 있습니다.\n\n# 도전과 배운점\n\n내가 처음에 제안한 계획과는 달리, 환경 및 런타임의 변화로 인해 위에 설명한 기술들이 다르게 진행되었습니다. 이는 ONNX 및 OpenVINO의 문서를 찾아본 적이 없기 때문에 어려움을 겪은 첫 번째 경험이었습니다. 팀원들이 직면한 어려움과 그들이 그것을 해결하는 방법을 알게 된 것 또한 좋은 경험이었습니다. 파이썬에서의 다중 처리에 대해 사전에 알지 못했고, 동시성에 대한 초기 접근 방식이 달라졌기 때문에 지속적인 도전은 앞으로 이 프로젝트에 참여할 다른 기여자들을 고려하여 결정을 내리는 것이었습니다. 저는 딥러닝 모델을 기반으로 개발된 도구들과 Python 언어 전반에 대해 더 강한 이해를 가지게 되었습니다. 이러한 배움들을 다른 부수 프로젝트와 학업 프로젝트에도 적용할 수 있었으며, 전체적으로 배우는 것이 정말 즐거웠습니다. 이 프로젝트에서 작업하는 동안 참고한 자료 목록을 추가하고, 여러분에게도 도움이 되기를 바랍니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 자원\n\n- 객체 검출을 위한 Ultralytics YOLO 모델\n- ONNX 형식의 YOLOv8 모델 사용 예시를 보여주는 저장소\n- ORM에 관한 블로그\n- YOLOv8 얼굴 모델\n- ONNX 모델의 모음\n- OpenVINO Toolkit의 Open Model Zoo\n- asyncio, concurrency 및 GIL에 대한 Real Python 튜토리얼\n- 이미지에서 메타데이터 추출에 대한 Python 코드 튜토리얼\n\n이 블로그 시리즈의 첫 번째 부분을 이 링크에서 확인하지 않으셨으면 확인하세요. 그리고 이 블로그 시리즈의 다음 부분을 기대해 주세요. GitHub 및 LinkedIn에서 저와 연락할 수 있습니다. 읽어 주셔서 감사합니다!\n","ogImage":{"url":"/assets/img/2024-07-07-MyGSoCJourneyPhase1_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-MyGSoCJourneyPhase1_0.png","tag":["Tech"],"readingTime":9}],"page":"30","totalPageCount":34,"totalPageGroupCount":2,"lastPageGroup":14,"currentPageGroup":1},"__N_SSG":true}