{"pageProps":{"posts":[{"title":"프로처럼 파이썬 폼 만드는 방법","description":"","date":"2024-07-07 02:31","slug":"2024-07-07-HowtoMakePythonFormsasaPro","content":"\r\n<img src=\"/TIL/assets/img/2024-07-07-HowtoMakePythonFormsasaPro_0.png\" />\r\n\r\n과거에 설문은 데이터 수집의 효과적인 수단이었지만, 오늘날의 빠른 세상에서는 사람들이 길거리에서 질문에 답변하기 위해 멈추기에는 너무 바쁘다. 인터넷을 둘러보는 동안 온라인 양식을 작성하는 것이 그들에게 더 편리하며, 출근길에 낯선 사람에게 5분을 할애하는 것보다 더 나은 방법이다. 결과적으로, 회사와 개인은 이제 사람들에게 접근하는 대신 Google Forms와 같은 디지털 도구를 사용하고 있다.\r\n\r\nGoogle Forms은 실제로 굉장히 유용한 도구이다. 무료이며 사용하기 매우 쉽고 누구에게나 접근 가능하다. 또한 데이터 분석 및 원활한 내보내기 옵션과 같은 고급 기능을 제공한다. 그러나, 빌더들은 내장 위젯과 몇 가지 사용자 정의 기능에 국한되어 있어서, 눈길을 떼게 할 만한 양식보다는 다소 매력이 떨어지는 양식을 만들게 된다.\r\n\r\nJotform, Formly, Canva와 같은 다른 옵션들도 Google Forms보다 더 많은 사용자 정의 기능과 매력적인 디자인을 제공하지만, 이들은 가격이 따른다는 단점이 있다. 그러므로 누구나 지불하기를 원하지 않을 수도 있을 것이다.\r\n","ogImage":{"url":"/assets/img/2024-07-07-HowtoMakePythonFormsasaPro_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-HowtoMakePythonFormsasaPro_0.png","tag":["Tech"],"readingTime":1},{"title":"로컬에서 LLM 실행하는 방법","description":"","date":"2024-07-07 02:31","slug":"2024-07-07-RunningLLMLocally","content":"\nTransformer 아키텍처의 소개로 자연어 처리에서 중요한 전환점이 시작되었습니다. 많은 주요 언어 모델이 지금은 이를 주요 아키텍처로 사용하고 있어요. 우리가 알다시피 큰 언어 모델(LLM)은 우리 삶을 더 쉽게 만들어줍니다.\n\nLLM 모델의 크기를 생각해보세요. GPT-3은 1750억 개의 파라미터를 가지고 있고, 각각 16비트(2바이트)의 크기를 가지고 있어요. 약 350GB의 저장 공간이 필요합니다. 다른 모델들 중에는 1조를 초과하는 파라미터 크기가 있는 것도 많아요. 그래서 계산량이 매우 많습니다. 로컬에서 실행하는 것을 상상하기도 어렵죠.\n\n하지만, 이 기사는 모두 Ollama 프레임워크에 관한 것입니다. 이를 사용하여 대규모 언어 모델을 로컬에서 실행할 수 있어요.\n\nOllama는 Llama 3, Mistral 등 다양한 대규모 언어 모델을 운영할 수 있게 해주는 오픈 소스 플랫폼입니다. 또한 애플리케이션에 맞게 모델을 사용자 정의하고, 쉽게 제품에 배포하는 것까지 가능하도록 해줘요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/TIL/assets/img/2024-07-07-RunningLLMLocally_0.png\" />\n\n여기서는 다른 모델들을 실행하는 유사한 프로세스를 따라 우리의 로컬 시스템에서 Llama3 모델 실행에 초점을 맞춥니다.\n\nOllama는 Windows, Linux 및 macOS와 호환됩니다. 다운로드하기 위해 아래 링크를 사용하십시오.\n\nMac: https://ollama.com/download/mac\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nLinux: [https://ollama.com/download/linux](https://ollama.com/download/linux)\n\nWindows: [https://ollama.com/download/windows](https://ollama.com/download/windows)\n\nLet’s try LLama 3:\n\n- Refer to the article link: [https://ollama.com/library/llama3:8b](https://ollama.com/library/llama3:8b). It has all the information about the model size, variants, benchmark, and API information.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n먼저 컴퓨터의 명령 프롬프트에 \"ollama --version\"을 입력하여 설정이 올바르게 되어 있는지 확인하십시오.\n\n![image](https://miro.medium.com/v2/resize:fit:996/1*WXzD_p2lBl1vK4wMStW8Ug.gif)\n\nLlama 3 다운로드 :\n\n채팅/대화 사례 모델을 다운로드하려면 \"ollama pull llama3\" 명령을 사용하십시오.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다른 모델 목록은 여기에서 확인할 수 있어요: https://ollama.com/library. 동일한 명령어를 사용하여 다른 모델을 가져와서 사용할 수 있어요.\n\n![RunningLLMLocally_1](/TIL/assets/img/2024-07-07-RunningLLMLocally_1.png)\n\nLlama 3 실행:\n\n“llama run llama3” 명령을 사용하여 모델을 직접 실행할 수 있어요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/TIL/assets/img/2024-07-07-RunningLLMLocally_2.png\" />\n\nAPI 사용 방법:\n\n만약 동일한 모델을 위해 API를 사용하고 싶다면, 몇 가지 간단한 단계를 따라주세요.\n\n- \"ollama serve\"를 사용하여 로컬 서버를 시작하세요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/TIL/assets/img/2024-07-07-RunningLLMLocally_3.png)\n\n- 이제 \"curl\"이나 다른 코드를 사용하여 요청을 보낼 수 있습니다. 여기서는 Postman 도구를 사용하여 llama3 모델에 요청했습니다.\n\n![이미지](/TIL/assets/img/2024-07-07-RunningLLMLocally_4.png)\n\n- 이 요청과 함께 전달할 수 있는 다른 매개변수도 있습니다. 자세한 API를 탐색할 수 있는 링크는 아래에 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAPI 문서: [https://github.com/ollama/ollama/blob/main/docs/api.md](https://github.com/ollama/ollama/blob/main/docs/api.md)\n\n유용한 링크:\n","ogImage":{"url":"/assets/img/2024-07-07-RunningLLMLocally_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-RunningLLMLocally_0.png","tag":["Tech"],"readingTime":5},{"title":"Flask와 SQLAlchemy를 사용한 데이터베이스 통합 방법","description":"","date":"2024-07-07 02:30","slug":"2024-07-07-UsingFlaskwithSQLAlchemyforDatabaseIntegration","content":"\n이 기사에서는 SQLAlchemy를 사용하여 Flask 애플리케이션에 데이터베이스를 통합하는 방법에 대해 살펴볼 것입니다. SQLAlchemy는 데이터베이스 상호 작용을 훨씬 쉽게 만드는 파이썬용 강력한 SQL 툴킷 및 객체 관계 매핑(ORM) 라이브러리입니다.\n\n![이미지](/TIL/assets/img/2024-07-07-UsingFlaskwithSQLAlchemyforDatabaseIntegration_0.png)\n\nSQLAlchemy란 무엇인가요?\nSQLAlchemy는 개발자들이 파이썬 객체를 사용하여 데이터베이스 작업을 수행할 수 있는 인기 있는 ORM 라이브러리로, 원시 SQL 쿼리를 작성하지 않고도 데이터베이스 작업을 더 쉽게 관리할 수 있게 해줍니다.\n\n## Flask 및 SQLAlchemy 설정하기\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우선, 컴퓨터에 Python이 설치되어 있는지 확인하세요. 그런 다음 pip를 사용하여 Flask와 SQLAlchemy를 설치하세요:\n\n```js\npip install Flask SQLAlchemy\n```\n\nSQLAlchemy를 사용한 기본 Flask 애플리케이션 만들기\n\n- 프로젝트 구조: 프로젝트 구조를 다음과 같이 설정하세요:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nflask_sqlalchemy_example/\n├── app.py\n├── config.py\n├── models.py\n└── requirements.txt\n```\n\n2. Configuration: 데이터베이스 구성을 저장하는 config.py 파일을 만들어보세요:\n\n```python\nimport os\n\nbasedir = os.path.abspath(os.path.dirname(__file__))\n\nclass Config:\n    SQLALCHEMY_DATABASE_URI = 'sqlite:///' + os.path.join(basedir, 'app.db')\n    SQLALCHEMY_TRACK_MODIFICATIONS = False\n```\n\n3. 모델 정의: 데이터베이스 모델을 정의하는 models.py 파일을 생성하세요:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\n아래는 Flask 애플리케이션을 개발하기 위한 코드 예제입니다.\n\nfrom flask_sqlalchemy import SQLAlchemy\n\ndb = SQLAlchemy()\n\nclass User(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    username = db.Column(db.String(80), unique=True, nullable=False)\n    email = db.Column(db.String(120), unique=True, nullable=False)\n\n    def __repr__(self):\n        return f'<User {self.username}>'\n\n4. Flask 애플리케이션 생성: 메인 애플리케이션 파일인 app.py를 생성하세요.\n\nfrom flask import Flask\nfrom config import Config\nfrom models import db, User\n\napp = Flask(__name__)\napp.config.from_object(Config)\ndb.init_app(app)\n\n@app.before_first_request\ndef create_tables():\n    db.create_all()\n\n@app.route('/')\ndef home():\n    return \"Flask with SQLAlchemy 예제에 오신 것을 환영합니다!\"\n\nif __name__ == '__main__':\n    app.run(debug=True)\n\n5. 애플리케이션 실행: 애플리케이션을 실행하고 데이터베이스를 생성하세요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\npython app.py\n\n## CRUD 작업 추가하기\n\n이제 사용자 모델을 관리하기 위해 CRUD(Create, Read, Update, Delete) 작업을 추가해 봅시다.\n\n- 사용자 생성: 새 사용자를 생성하는 라우트를 추가하세요:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nfrom flask import request, jsonify\n\n@app.route('/users', methods=['POST'])\ndef create_user():\n    data = request.get_json()\n    new_user = User(username=data['username'], email=data['email'])\n    db.session.add(new_user)\n    db.session.commit()\n    return jsonify({'message': '사용자가 성공적으로 생성되었습니다!'}), 201\n\n2. 모든 사용자 가져오기: 모든 사용자를 가져오는 라우트를 추가합니다:\n\n@app.route('/users', methods=['GET'])\ndef get_users():\n    users = User.query.all()\n    return jsonify([{'id': user.id, 'username': user.username, 'email': user.email} for user in users])\n\n3. 단일 사용자 가져오기: ID로 사용자를 가져오는 라우트를 추가합니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n@app.route('/users/<int:id>', methods=['GET'])\ndef get_user(id):\n    user = User.query.get_or_404(id)\n    return jsonify({'id': user.id, 'username': user.username, 'email': user.email})\n\n4. 사용자 업데이트: ID로 사용자를 업데이트하는 라우트를 추가하세요:\n\n@app.route('/users/<int:id>', methods=['PUT'])\ndef update_user(id):\n    data = request.get_json()\n    user = User.query.get_or_404(id)\n    user.username = data['username']\n    user.email = data['email']\n    db.session.commit()\n    return jsonify({'message': '사용자가 성공적으로 업데이트되었습니다!'})\n\n5. 사용자 삭제: ID로 사용자를 삭제하는 라우트를 추가하세요:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n@app.route('/users/<int:id>', methods=['DELETE'])\ndef delete_user(id):\n    user = User.query.get_or_404(id)\n    db.session.delete(user)\n    db.session.commit()\n    return jsonify({'message': '사용자가 성공적으로 삭제되었습니다!'})\n\n최종 app.py 코드\n\nCRUD 작업이 모두 포함된 완성된 app.py는 아래와 같습니다:\nfrom flask import Flask, request, jsonify\nfrom config import Config\nfrom models import db, User\n\napp = Flask(__name__)\napp.config.from_object(Config)\ndb.init_app(app)\n\n@app.before_first_request\ndef create_tables():\n    db.create_all()\n\n@app.route('/')\ndef home():\n    return \"Flask with SQLAlchemy 예제에 오신 것을 환영합니다!\"\n\n@app.route('/users', methods=['POST'])\ndef create_user():\n    data = request.get_json()\n    new_user = User(username=data['username'], email=data['email'])\n    db.session.add(new_user)\n    db.session.commit()\n    return jsonify({'message': '사용자가 성공적으로 생성되었습니다!'}), 201\n\n@app.route('/users', methods=['GET'])\ndef get_users():\n    users = User.query.all()\n    return jsonify([{'id': user.id, 'username': user.username, 'email': user.email} for user in users])\n\n@app.route('/users/<int:id>', methods=['GET'])\ndef get_user(id):\n    user = User.query.get_or_404(id)\n    return jsonify({'id': user.id, 'username': user.username, 'email': user.email})\n\n@app.route('/users/<int:id>', methods=['PUT'])\ndef update_user(id):\n    data = request.get_json()\n    user = User.query.get_or_404(id)\n    user.username = data['username']\n    user.email = data['email']\n    db.session.commit()\n    return jsonify({'message': '사용자가 성공적으로 업데이트되었습니다!'})\n\n@app.route('/users/<int:id>', methods=['DELETE'])\ndef delete_user(id):\n    user = User.query.get_or_404(id)\n    db.session.delete(user)\n    db.session.commit()\n    return jsonify({'message': '사용자가 성공적으로 삭제되었습니다!'})\n\nif __name__ == '__main__':\n    app.run(debug=True)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 글에서는 SQLAlchemy를 Flask와 통합하여 데이터베이스 작업을 관리하는 방법을 다루었습니다. 우리는 간단한 사용자 모델을 생성하고 데이터베이스와 상호 작용하기 위한 CRUD 작업을 구현했습니다. SQLAlchemy의 ORM 기능은 Flask 애플리케이션에서 데이터베이스 관리를 위한 강력한 도구로 만들어 줍니다.\n```\n","ogImage":{"url":"/assets/img/2024-07-07-UsingFlaskwithSQLAlchemyforDatabaseIntegration_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-UsingFlaskwithSQLAlchemyforDatabaseIntegration_0.png","tag":["Tech"],"readingTime":8},{"title":"몰랐으면 후회할 8가지 Python Dictionary 사용 꿀팁","description":"","date":"2024-07-07 02:29","slug":"2024-07-07-8PythonDictionaryThingsIRegretNotKnowingEarlier","content":"\n![이미지](/TIL/assets/img/2024-07-07-8PythonDictionaryThingsIRegretNotKnowingEarlier_0.png)\n\n이러한 팁들 덕분에 Python에서 사전(Dictionary)를 다루는 것이 더 즐겁고 우아해졌고, 조금 더 늦게 배워서 아쉬운 점이 있습니다.\n\n# 1) dict(key=value)를 사용하여 사전 생성하기\n\n참고 - 우리 개발팀이 95%의 경우에 사전을 만드는 방법입니다. ''는 그다지 사용하지 않습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 딕셔너리를 만드는 일반적인 방법\n\nd = {'apple':4, 'orange':5, 'pear':6, 'pineapple':7}\n\n# 동일한 딕셔너리를 만드는 '더 좋은' 방법\n\nd = dict(apple=4, orange=5, pear=6, pineapple=7)\n\n더 좋은 방법이 더 좋은 이유:\n\n- ''를 사용하면 문자열 키에 따옴표 문자를 입력해야 함\n- 예를 들어, `apple` `orange`와 같은 방식\n- 따옴표 문자를 입력해야 하는 것은 키가 많아질수록 기하급수적으로 귀찮아짐\n- dict()를 사용하면 따옴표 문자를 무시할 수 있음\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n물론, dict() 방법은 문자열이 아닌 키와 함께 사용할 수 없어서 두 가지 방법에는 각각의 용도가 있습니다.\n\n# 2) \\*\\*를 사용하여 딕셔너리를 결합하는 방법\n\n```js\n# 여기에 2개의 딕셔너리가 있습니다.\n\na = {1:1, 2:2}\nb = {3:3, 4:4}\n```\n\n```js\n# **를 사용하여 두 개를 결합할 수 있습니다.\n\nx = {**a, **b}\n\nprint(x) #… 출력결과를 확인하세요\n```\n","ogImage":{"url":"/assets/img/2024-07-07-8PythonDictionaryThingsIRegretNotKnowingEarlier_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-8PythonDictionaryThingsIRegretNotKnowingEarlier_0.png","tag":["Tech"],"readingTime":2},{"title":"파이썬으로 파킨슨 변동성 계산하는 방법","description":"","date":"2024-07-07 02:29","slug":"2024-07-07-CalculatingParkinsonsVolatilityinPython","content":"\n![Parkinson’s volatility](/TIL/assets/img/2024-07-07-CalculatingParkinsonsVolatilityinPython_0.png)\n\n파킨슨 변동성은 특정 기간 동안 금융 상품의 고가 및 저가를 활용한 역사적 변동성의 측정입니다. 일일 가격 범위를 반영하여 내일의 가격 변동에 대한 추가 정보를 제공하기 때문에 표준 종가 대 종가 변동성 추정치보다 더 효율적이라고 여겨집니다.\n\n이 기사에서는 이 변동성 측정 방법을 자세히 소개하고 Python을 사용하여 시계열에서 롤링 계산을 하는 방법을 보여줍니다.\n\n# 파킨슨 변동성 이해하기\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n복잡한 변동성 모델을 논의하기 전에, 항상 역사적 표준편차라는 가장 기본적인 변동성 모델(또는 계산)을 완전히 이해하는 것이 좋습니다. 역사적 메소드를 사용한 표준편차는 과거 가격 데이터를 기반으로 금융 상품의 변동성을 측정하는 일반적인 방법입니다.\n\n이는 값의 변동이나 분산의 양을 측정합니다. 금융 분야에서는 일반적으로 일별 수익의 평균 주변의 변동을 측정합니다. 표준편차를 계산하는 방법은 다음과 같습니다:\n\n- 차분(첫 번째...\n","ogImage":{"url":"/assets/img/2024-07-07-CalculatingParkinsonsVolatilityinPython_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-CalculatingParkinsonsVolatilityinPython_0.png","tag":["Tech"],"readingTime":1},{"title":"GreenNet 에너지 효율성을 높이는 방법","description":"","date":"2024-07-07 02:28","slug":"2024-07-07-GreenNetEmpoweringEnergyEfficiency","content":"\n# 소개\n\n![이미지](/TIL/assets/img/2024-07-07-GreenNetEmpoweringEnergyEfficiency_0.png)\n\n저는 대규모 에너지 소비 관리 시스템의 중요 구성 요소 중 하나인 독립형 마이크로 서비스 프로젝트에 참여할 기회가 있었습니다. 우리 프로젝트는 다양한 엔지니어가 다양한 구성 요소에 작업하는 이 대규모 이니셔티브의 한 부분이었습니다.\n\n이 프로젝트의 개념은 원래 ALX에서 나의 동료가 고안하여 에너지 소비를 관리하는 포괄적인 시스템을 상상했습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 프로젝트는 Engineer 2:가 주도하였고, 꽉 끼인 3주의 일정 내에 완료되었습니다.\n\n## 프로젝트 세분화: 세그먼트 및 엔지니어\n\n아래는 각 프로젝트를 담당한 다른 세그먼트 및 엔지니어에 대한 개요입니다:\n\n## 세그먼트:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 에너지 소비 추적기: 에너지 소비 데이터를 수집하고 처리하여 에너지 사용에 대한 통찰과 분석을 제공하며, 에너지 소비 임계값 및 장치 오작동에 대한 사용자 알림을 전송합니다.\n- 그린넷: 에너지 관리를 위한 안전한 사용자 인증 및 장치 모니터링.\n- 챗펄스: 사용자와 관리자 간의 커뮤니케이션을 통한 실시간 사용자 지원 및 참여.\n\n## 엔지니어:\n\n- 엔지니어 1 (Okoyen Ebisine Precious): 그린넷을 위한 사용자 관리 및 장치 관리 마이크로서비스 개발.\n- 엔지니어 2 (Joshua Benjamin): 에너지 소비 및 알림 마이크로서비스 개발을 위한 엔지지 소비 추적기.\n- 엔지니어 3 (Benedict Akosa): 모니터링 및 커뮤니케이션 마이크로서비스, 그리고 실시간 커뮤니케이션과 지원을 위한 챗펄스 챗 마이크로서비스를 담당합니다.\n\n저는 개인적으로 팀 엔지니어 1로서 견고하고 확장 가능한 인증 시스템을 설계하고 구현하는 데 초점을 맞추었습니다. 엔지니어 팀 2는 에너지 소비 분석 모듈을 개발하였으며, 엔지니어 팀 3은 실시간 커뮤니케이션과 지원을 위한 마이크로서비스를 구현하는 데 초점을 맞추었습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 그린넷으로의 여정\n\n그린넷을 만들기 위한 여정을 되돌아보면, 몇 주 전에 겪었던 어려움이 생생하게 떠오릅니다. 학습 일정에서 뒤처지고 있었고, 프로젝트를 맡아야 한다는 생각이 겁나기 시작했습니다. 자신에게 의심이 들고, 복잡한 작업에 도전할 준비가 되어있는지 의문이 들었습니다.\n\n![GreenNet](/TIL/assets/img/2024-07-07-GreenNetEmpoweringEnergyEfficiency_1.png)\n\n하지만, 친구 Chymezy(Engineer 2)와 나눈 대화가 모든 것을 바꿨습니다. 그가 제시한 아이디어는 나에게 와닿았습니다. '보안을 최우선으로 하는 프로젝트를 만들면 어떨까?' 라는 생각이 날 것 같습니다. 생각을 많이 해보니, 나에게는 이 어려움을 극복하고 의미 있는 것을 만들어낼 기회가 된다는 것을 깨달았습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 프로젝트 성과\n\n저희의 프로젝트인 GreenNet의 결과를 공유해 드리게 되어 정말 기쁩니다. GreenNet은 안전한 사용자 인증 및 에너지 관리에서 기기 모니터링을 제공하기 위해 설계된 마이크로 서비스 기반 플랫폼입니다.\n\n## 아키텍처 다이어그램\n\n아래는 GreenNet의 아키텍처 다이어그램입니다. 응용 프로그램을 통해 데이터가 어떻게 흘러가는지를 보여줍니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![GreenNet](/TIL/assets/img/2024-07-07-GreenNetEmpoweringEnergyEfficiency_2.png)\n\n## 사용된 기술\n\nGreenNet을 만들기 위해 견고하고 확장 가능한 애플리케이션을 구축하는 데 중점을 두기 위해 다양한 기술을 결합했습니다.\n\n백엔드에서는 Python을 선택했습니다. 그 이유는 간단함, 유연성 및 다양한 라이브러리 때문입니다. 이를 통해 빠르게 안전한 사용자 인증 시스템을 개발할 수 있었습니다. Node.js를 선택할 수도 있었지만, Python의 사용 편의성과 다양성으로 인해 이상적인 선택이었습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프론트엔드에서 반응형 및 사용자 친화적 인터페이스를 구축하기 위해 HTML, CSS 및 JavaScript를 선택했습니다. HTML, CSS 및 JS가 제공하는 유연성과 사용 편의성 때문에 Angular 또는 React와 같은 프레임워크를 사용하지 않기로 결정했습니다. Bootstrap도 UI를 개선하고 일관된 디자인을 제공하는 데 사용되었습니다.\n\n## 완료된 기능\n\n다음은 완료한 주요 기능 몇 가지입니다:\n\n- 안전한 사용자 인증: 안전한 사용자 회원 가입, 로그인 및 로그아웃 기능을 구현하여 사용자 데이터가 보호되고 안전성이 확보되었습니다.\n- 반응형 및 사용자 친화적 인터페이스: 프론트엔드 사용자 인터페이스는 HTML, CSS 및 Bootstrap을 사용하여 반응형 및 사용자 친화적인 경험을 제공합니다. JavaScript 스크립트도 UI를 개선하고 동적 기능을 제공하는 데 사용되었습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그린넷이 제공하는 이러한 기능들은 그저 시작에 불과해요. 사용자들에게 원활하고 효율적인 경험을 제공하기 위해 이 플랫폼을 계속 발전시키고 개선하는 것을 기대하고 있어요.\n\n# 직면한 기술적인 도전\n\n그린넷 프로젝트 도중, 사용 중이었던 웹 프레임워크인 Flask가 데이터베이스를 초기화하고 이관하는 데 실패하여 중요한 기술적 도전에 직면했어요. 이 문제는 프로젝트 초반에 발생했기 때문에 진행에 상당한 영향을 미쳤고, 이를 해결하기 위해 노력했어요.\n\n![이미지](/TIL/assets/img/2024-07-07-GreenNetEmpoweringEnergyEfficiency_3.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 도전을 극복하기 위해 저는 작업 환경을 바꾸고 새 컴퓨터로 전환하기로 결정했습니다. 이 결정은 나에게 프로젝트를 처음부터 다시 시작할 수 있는 기회를 제공하여 결국 큰 도움이 되었습니다. 가져오기 문제를 해결한 후에는 초기보다 두 배 빠른 속도로 작업할 수 있어 생산성이 상당히 향상된 것을 알게 되었습니다.\n\n이 도전을 통해 겪은 경험은 기술적 어려움에 직면했을 때 순응력과 회복력의 중요성을 배울 수 있었습니다. 문제에 직면하여 해결책을 찾아내고, 새로운 에너지와 집중력으로 프로젝트를 계속 개발할 수 있었습니다.\n\n# 배운 교훈과 향후 방향\n\nGreenNet과 함께한 내 여정을 되새기면서, 미래의 소프트웨어 엔지니어링에 대한 접근 방식을 형성할 가치 있는 통찰을 얻었습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 기술적인 포인트\n\n이 프로젝트에서 가장 중요한 기술적 교훈 중 하나는 에너지 관리에서 견고한 사용자 인증과 장치 모니터링의 중요성입니다. Python의 간결함과 유연성을 활용하여 안전하고 확장 가능한 응용 프로그램을 개발할 수 있다는 것을 배웠습니다. 또한 HTML, CSS 및 JavaScript에 대한 경험을 통해 반응형이고 사용자 친화적인 인터페이스를 만들 수 있었습니다.\n\n## 다르게 할 점\n\n아마도 더 안전하고 사용자 친화적인 시스템을 구축하는 데 집중하고, 기기, 위치 또는 연결 여부에 관계없이 최종 사용자가 에너지 사용량을 추적하는 데 원활한 경험을 제공하는 것에 초점을 맞출 것입니다. 모든 사용자가 플랫폼에 접근하고 효율적으로 사용할 수 있도록 혁신적인 솔루션을 탐색하는 것이 포함될 것입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nGreenNet은 소프트웨어 엔지니어링에서의 다양한 가능성을 내게 보여준 중요한 프로젝트였어요. 사람들의 삶에 영향을 미치는 혁신적인 해결책을 만드는 열정을 다시 한 번 느낄 수 있었어요. 앞으로 나아가면서, 배운 기술과 지식을 활용하여 더 복잡한 문제를 해결하고 저와 업계의 밝은 미래를 만들어가는 것에 기대돼요.\n\n이 프로젝트를 통해 VIM과 Emacs를 비롯한 다양한 도구와 기술을 활용할 수 있는 기회를 가졌어요. 그중에서도 여전히 VIM을 선호하는 편인데, 그 이유는 그 간결함과 사용 편의성 때문이에요.\n\n## 결론\n\n요약하자면, GreenNet과의 경험은 저에게 끈기, 적응력 및 혁신에 관한 소중한 교훈을 전달해 주었어요. 내가 이룬 성과에 자랑스럽고, 앞으로의 프로젝트에 배운 기술과 지식을 적용하는 것에 기대가 되요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 나에 대해\n\n저는 열정적이고 목표 지향적인 소프트웨어 엔지니어인 오코옌 에비신 프레셔스입니다. 기술을 통해 긍정적인 영향을 줄 수 있는 강한 열망을 가지고 있습니다. 사람들의 삶에 영향을 미칠 수 있는 혁신적인 솔루션을 개발할 기회를 항상 찾고 있습니다. 제 프로젝트인 GreenNet에 대해 더 많은 정보를 GitHub 링크에서 확인할 수 있습니다. 배포된 프로젝트 페이지와 랜딩 페이지는 링크에서 접속할 수 있습니다. 또한 LinkedIn 프로필 링크에서 저와 연락할 수도 있습니다.\n","ogImage":{"url":"/assets/img/2024-07-07-GreenNetEmpoweringEnergyEfficiency_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-GreenNetEmpoweringEnergyEfficiency_0.png","tag":["Tech"],"readingTime":8},{"title":"멋진 데이터 시각화를 위한 최고의 10가지 Python 도구","description":"","date":"2024-07-07 02:27","slug":"2024-07-07-Top10PythonToolsforStunningDataVisualizations","content":"\n## 파이썬 시각화\n\n오늘은 독특하고 인상적인 열 가지 파이썬 시각화 도구를 소개하겠습니다.\n\n### Matplotlib\n\nMatplotlib은 고품질의 선 그래프, 산점도, 막대 그래프 등을 생성할 수 있는 파이썬 플로팅 라이브러리입니다. 다른 많은 시각화 라이브러리들의 기반입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.linspace(0, 10, 100)\ny = np.sin(x)\n\nplt.plot(x, y)\nplt.show()\n```\n\n![Image](/TIL/assets/img/2024-07-07-Top10PythonToolsforStunningDataVisualizations_0.png)\n\n# Seaborn\n\nSeaborn은 Matplotlib을 기반으로 한 Python 데이터 시각화 라이브러리로, 히트맵, 바이올린 플롯, 오차 막대를 사용한 선 그래프와 같은 통계 그래픽을 위해 설계되었습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport seaborn as sns\nimport pandas as pd\n\ndf = pd.read_csv('data.csv')\n\nsns.boxplot(x='day', y='total_bill', data=df)\n```\n\n# Plotly\n","ogImage":{"url":"/assets/img/2024-07-07-Top10PythonToolsforStunningDataVisualizations_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-Top10PythonToolsforStunningDataVisualizations_0.png","tag":["Tech"],"readingTime":2},{"title":"파이썬  데이터 분석 프로젝트 1 15개의 해결된 질문 포함","description":"","date":"2024-07-07 02:26","slug":"2024-07-07-PythonDataAnalysisProject1With15SolvedQuestions","content":"\n## 날씨 데이터 분석\n\n![이미지](/TIL/assets/img/2024-07-07-PythonDataAnalysisProject1With15SolvedQuestions_0.png)\n\n이 글에서는 날씨 데이터셋을 활용한 데이터 분석을 배워보겠습니다. 주어진 질문을 해결하기 위해 Python 프로그래밍 언어를 사용할 것입니다. 이곳에서 사용하는 IDE는 Jupyter Notebook입니다. Jupyter Lab, Google Colab 등 다른 IDE도 사용할 수 있습니다.\n\n날씨 데이터셋은 특정 위치에서 발생한 날씨 조건에 대한 시계열 데이터 세트입니다. 온도, 이슬점 온도, 상대 습도, 풍속, 가시성, 압력 및 조건을 기록합니다. 이 데이터는 CSV 파일로 제공됩니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 데이터셋을 기반으로 여러 질문이 제시되었고, 우리는 Python의 Pandas 라이브러리를 사용하여 하나씩 해결할 것입니다. Pandas 라이브러리는 데이터 분석을 위한 최고의 라이브러리입니다.\n\n우선 Pandas 라이브러리를 설치하겠습니다.\n\n![이미지](/TIL/assets/img/2024-07-07-PythonDataAnalysisProject1With15SolvedQuestions_1.png)\n\n다음으로, 날씨 데이터셋을 가져올 것입니다. 데이터셋이 csv 형식이므로, 구문은 다음과 같을 것입니다: pd.read_csv(\"..데이터셋 파일 경로..\")\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/TIL/assets/img/2024-07-07-PythonDataAnalysisProject1With15SolvedQuestions_2.png\" />\n\n여기서부터는 데이터 집합을 'df'로 참조할 것입니다. 코드에서 'r'을 써서 유니코드 오류를 제거하였습니다. 'r' 다음에는 우리 데이터 집합 파일의 경로를 따옴표로 전달할 것입니다.\n\n따라서 위의 코드를 실행한 후에 우리 데이터 집합은 이렇게 보일 것입니다.\n\n<img src=\"/TIL/assets/img/2024-07-07-PythonDataAnalysisProject1With15SolvedQuestions_3.png\" />\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 몇 가지 기본 Pandas 명령을 사용하여 데이터 세트를 탐색해 보겠습니다.\n\n## 1. head( )\n\n이렇게 하면 데이터의 첫 N개의 행을 표시합니다 (기본값은 N=5). 즉, 상위 5개 행을 보여줍니다.\n\n![이미지](/TIL/assets/img/2024-07-07-PythonDataAnalysisProject1With15SolvedQuestions_4.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 2. 형태\n\n데이터셋(데이터프레임)의 총 행 수와 열 수를 보여줍니다.\n\n![이미지](/TIL/assets/img/2024-07-07-PythonDataAnalysisProject1With15SolvedQuestions_5.png)\n\n## 3. 인덱스\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 속성은 데이터프레임의 인덱스 범위를 제공합니다. 인덱스는 0부터 8784까지 시작합니다. 여기서 step=1은 인덱스가 0, 1, 2, 3, 4, 5, ... 와 같이 1씩 증가하는 것을 나타냅니다.\n\n![image](/TIL/assets/img/2024-07-07-PythonDataAnalysisProject1With15SolvedQuestions_6.png)\n\n## 4. columns\n\n데이터프레임에 있는 각 열의 이름을 보여줍니다. 여기서 8개의 열 이름이 모두 표시됩니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/TIL/assets/img/2024-07-07-PythonDataAnalysisProject1With15SolvedQuestions_7.png)\n\n## 5. dtypes( )\n\n각 열의 데이터 유형을 보여줍니다. 여기서 두 개의 열은 'object' (문자열) 형식이며, 네 개의 열은 'float' 형식이며, 두 개의 열은 'integer' 형식입니다.\n\n![image](/TIL/assets/img/2024-07-07-PythonDataAnalysisProject1With15SolvedQuestions_8.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 6. unique( )\n\n한 열에서 모든 고유한 값을 표시합니다. 이 함수는 전체 데이터프레임이 아니라 단일 열에만 적용할 수 있습니다.\n\n![이미지](/TIL/assets/img/2024-07-07-PythonDataAnalysisProject1With15SolvedQuestions_9.png)\n\n여기서 Weather 열의 모든 고유한 값을 표시하고 있습니다. 고유한 값이 너무 많아서 그 수를 세는 것이 어려울 수 있습니다. 다음으로 열의 고유한 값의 총 개수를 표시하는 함수를 사용할 것입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 7. nunique( )\n\n각 열의 고유한 값의 총수를 보여줍니다. 단일 열 뿐만 아니라 전체 데이터프레임에도 적용할 수 있습니다.\n\n![테이블 이미지](/TIL/assets/img/2024-07-07-PythonDataAnalysisProject1With15SolvedQuestions_10.png)\n\n해당 열인 Weather에 50개의 고유한 값이 있다는 것을 보여줍니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 데이터프레임의 각 열에 있는 고유 값의 수를 확인하려면 어떻게 해야 할까요? 그러려면 열이 아닌 전체 데이터프레임에 nunique()를 적용하면 됩니다.\n\n![image](/TIL/assets/img/2024-07-07-PythonDataAnalysisProject1With15SolvedQuestions_11.png)\n\n그래서 한 번에 각 열의 고유 값 수를 얻을 수 있습니다.\n\n## 8. count()\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n각 열의 전체 비 널 값 수를 보여줍니다. 단일 열뿐만 아니라 전체 데이터프레임에도 적용할 수 있습니다.\n\n![이미지](/TIL/assets/img/2024-07-07-PythonDataAnalysisProject1With15SolvedQuestions_12.png)\n\n데이터프레임의 모든 열에 8784개의 비 널 값을 가지고 있으며, 이는 데이터프레임의 총 행 수와 같습니다. 따라서 어떤 열에도 널 값이 없습니다.\n\n## 9. value_counts( )\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n한 열에서 고유 값과 해당 개수가 모두 표시됩니다. 단일 열에만 적용할 수 있습니다.\n\n![image](/TIL/assets/img/2024-07-07-PythonDataAnalysisProject1With15SolvedQuestions_13.png)\n\n## 10. info( )\n\n데이터프레임에 대한 기본 정보를 제공합니다. 범위 인덱스, 모든 열 이름 및 비널 값 수와 해당 데이터 유형이 표시됩니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/TIL/assets/img/2024-07-07-PythonDataAnalysisProject1With15SolvedQuestions_14.png)\n\n다시 한 번 데이터프레임을 살펴보겠습니다.\n\n![이미지](/TIL/assets/img/2024-07-07-PythonDataAnalysisProject1With15SolvedQuestions_15.png)\n\n데이터프레임의 상위 2개 레코드가 표시됩니다. 참고용으로만 확인해주세요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n먼저 '풍속' 열의 고유한 값 개수를 nunique 함수를 사용하여 확인할 수 있습니다.\n\n![image](/TIL/assets/img/2024-07-07-PythonDataAnalysisProject1With15SolvedQuestions_16.png)\n\n이 열에는 34개의 고유한 값이 있습니다. 이제 이 값들이 무엇인지 확인해보겠습니다. unique 함수를 사용하면 됩니다.\n\n![image](/TIL/assets/img/2024-07-07-PythonDataAnalysisProject1With15SolvedQuestions_17.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그래서, 'Wind Speed_km/h' 열의 모든 고유한 값이 여기 있습니다.\n\n이 질문을 해결하는 데 두 가지 방법을 사용할 것입니다. 첫 번째는 필터링이고, 두 번째는 Groupby 함수입니다.\n\n먼저 value_count 함수를 사용하여 각 열의 고유한 값 수를 확인해 봅시다.\n\n![이미지](/TIL/assets/img/2024-07-07-PythonDataAnalysisProject1With15SolvedQuestions_18.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 열에서 '맑음'의 수는 1326입니다. 따라서 날씨가 맑았던 횟수는 1326번이라는 뜻입니다.\n\n이제 필터링을 사용하여 이 1326개의 레코드를 표시할 것입니다.\n\n![image](/TIL/assets/img/2024-07-07-PythonDataAnalysisProject1With15SolvedQuestions_19.png)\n\n질문에서 요청한 대로 날씨가 '맑음'인 모든 레코드(행)가 여기에 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그룹화( ) 함수를 사용하여 출력을 얻을 수 있는 또 다른 함수는 groupby( ) 입니다. groupby 함수를 사용하여 날씨 열(weather column)의 각 고유한 값들을 그룹화하고 '맑음(clear)'에 대한 출력을 얻을 것입니다. get_group( )를 사용합니다.\n\n![이미지](/TIL/assets/img/2024-07-07-PythonDataAnalysisProject1With15SolvedQuestions_20.png)\n\n# 계속됩니다 ….\n","ogImage":{"url":"/assets/img/2024-07-07-PythonDataAnalysisProject1With15SolvedQuestions_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-PythonDataAnalysisProject1With15SolvedQuestions_0.png","tag":["Tech"],"readingTime":10},{"title":"주말 AI 프로젝트 PC와 Raspberry Pi에서 YOLO를 사용한 객체 탐지 방법","description":"","date":"2024-07-07 02:24","slug":"2024-07-07-AWeekendAIProjectObjectDetectionwithYOLOonPCandRaspberryPi","content":"\n<img src=\"/TIL/assets/img/2024-07-07-AWeekendAIProjectObjectDetectionwithYOLOonPCandRaspberryPi_0.png\" />\n\n컴퓨터 비전은 다양한 규모의 ML 앱에 중요한 역할을 할 수 있습니다. $20,000에 이르는 테슬라 로봇이나 자율 주행 자동차부터 스마트 도어벨과 진공 청소기까지 다양한 영역에 활용될 수 있습니다. 그러나 실제 엣지 디바이스에는 클라우드 인프라와 비교할 때 하드웨어 사양이 제약되어 있는 경우가 많아 도전적인 과제로 여겨집니다.\n\nYOLO(You Only Look Once)는 인기 있는 객체 검출 라이브러리로, 첫 번째 버전은 2015년에 만들어졌습니다. YOLO는 임베디드 디바이스에서 특히 흥미로운데, 거의 모든 곳에서 실행될 수 있습니다. 파이썬 뿐만 아니라 C++(ONNX 및 OpenVINO) 및 Rust 버전도 제공됩니다. 1년 전에 저는 Raspberry Pi 4에서 YOLO v8을 테스트했습니다. 요즘에는 많은 변화가 있었는데, 새로운 Raspberry Pi 5가 출시되었고, 더 새로운 YOLO v10도 출시되었습니다. 따라서 새 모델을 새 하드웨어에서 실행했을 때 더 빠르고 정확하게 작동할 것으로 기대합니다.\n\n본문에 제시된 코드는 크로스 플랫폼이므로 Raspberry Pi가 없는 독자들도 Windows, Linux 또는 OS X 컴퓨터에서 실행할 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n계속해서, 어떻게 작동하는지 살펴보겠습니다!\n\n## Raspberry Pi\n\n라즈베리 파이에 대해 들어보지 못한 사람을 위해 간단히 설명해보겠습니다...\n","ogImage":{"url":"/assets/img/2024-07-07-AWeekendAIProjectObjectDetectionwithYOLOonPCandRaspberryPi_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-AWeekendAIProjectObjectDetectionwithYOLOonPCandRaspberryPi_0.png","tag":["Tech"],"readingTime":2},{"title":"Python이 너무 느려요 우리 응용 프로그램에 사용할 수 없는 이유 5가지","description":"","date":"2024-07-07 02:24","slug":"2024-07-07-PythonisTooSlowWeCantUseItforOurApplication","content":"\n\n안녕하세요 여러분, 다니엘 부일레스쿠입니다. 프리랜서 웹 개발자이자 에이전시 소유자로서, 다양한 팀 역학을 경험해왔어요. 그중에서도 인상적이었던 이야기가 있어요. 새로운 기술을 주도하는 팀 리더를 설득하여 웹 앱에 파이썬을 사용하도록 한 적이 있어요. 그 분은 항상 최신이며 눈부신 도구를 찾아내려는 리더였는데, 때때로 그것이 일에 가장 적합한 것은 아니더라도 말이에요. 이 프로젝트도 예외는 아니었어요. 속도에 관해서만 얘기하던 그 분은 파이썬 아이디어에 처음에는 반대했죠. 어떻게 그의 마음을 바꿨는지 (그리고 아마 여러분의 것도) 이야기할게요!\n\n# 팀 리더의 관점: 열정적인 혹평가자\n\n우리 팀 리더는 모든 기술 뉴스레터를 구독하고 있었으며, 유명인의 인스타그램만큼 화려한 GitHub 프로필을 가지고 있었어요. 그 분은 최신 JavaScript 프레임워크와 실험적인 언어를 좋아했죠. 그래서 우리가 새로운 웹 애플리케이션을 개발하게 된다면, 이미 가장 첨단 기술 스택을 상상하고 있었어요.\n\n하지만 문제가 있었어요: 저는 이 작업에 파이썬이 적절한 도구라고 알고 있었어요. 그것은 웹 개발에 완벽한, 견고한 언어였거든요. 그러나 제 팀 리더는 파이썬이 너무 느리다고 생각했어요. 그 분은 몇몇 자신이 관심을 가진 최신 언어들과 비교했을 때 특히 파이썬은 느리다고 주장했어요. 고객이 많은 트래픽을 처리하고 빠른 속도를 제공할 수 있는 언어가 필요하다고 하면서 계속해서 벤치마크와 사례 연구들을 거론했죠...","ogImage":{"url":"/TIL/assets/no-image.jpg"},"coverImage":"/TIL/assets/no-image.jpg","tag":["Tech"],"readingTime":1}],"page":"31","totalPageCount":34,"totalPageGroupCount":2,"lastPageGroup":14,"currentPageGroup":1},"__N_SSG":true}