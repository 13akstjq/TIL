{"pageProps":{"post":{"title":"파이썬에서 SOLID 원칙 적용하는 방법","description":"","date":"2024-07-09 14:45","slug":"2024-07-09-SOLIDprinciplesinPython","content":"\n\n\n![SOLID principles in Python](/assets/img/2024-07-09-SOLIDprinciplesinPython_0.png)\n\n# SOLID이란 무엇인가요?\n\n객체 지향 프로그래밍은 모든 프로그래머의 도구 상자에서 매우 유용한 도구입니다. 그러나 사용할 때 대부분의 사람들이 빠지는 흔한 함정이 있습니다.\n\nSOLID 원칙은 이러한 함정을 피하고 깔끔하고 유지보수 가능한 코드를 작성하는 데 도움이 되는 일련의 지침입니다.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\"SOLID\"은 다음을 나타내는 머리글자입니다:\n\n- 단일 책임 원칙 (SRP)\n- 개방/폐쇠 원칙 (OCP)\n- 리스코프 치환 원칙 (LSP)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 인터페이스 분리 원칙\n\n- 의존성 역전 원칙\n\n## 1. 단일 책임 원칙 (SRP)\n\n로버트 C. 마틴 (a.k.a 아저씨 밥)이 \"OOD의 원칙\"이라는 기사에서 만들어진 단일 책임 원칙은 다음과 같습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n한 클래스는 한 가지 책임만 가져야 합니다. 한 클래스가 여러 가지 일을 한다면, 여러 클래스로 분리해야 합니다.\n\n간단한 예를 통해 이를 설명해보겠습니다. 우리가 Google 드라이브 또는 Dropbox에서 객체를 읽고 쓰는 클래스가 있다고 가정해 봅시다.\n\n```js\nclass StorageClient:\n    _instance = None\n    _google_client = None\n    _dropbox_client = None\n\n    def __init__(self, google_credentials, dropbox_credentials) -> None:\n        self._google_client = \"Google 클라이언트\"\n        self._dropbox_client = \"Dropbox 클라이언트\"\n\n    @classmethod    \n    def get_or_create_instance(cls, google_credentials, dropbox_credentials) -> \"StorageClient\":\n        if not cls._instance:\n            cls._instance = StorageClient(google_credentials, dropbox_credentials)\n\n        return cls._instance\n        \n    def read_from_google(self, key):\n        ...\n\n    def upload_to_google(self, key, value):\n        ...\n\n    def read_from_dropbox(self, key):\n        ...\n    \n    def upload_to_dropbox(self, key, value):\n        ...\n```\n\n이 클래스의 문제는 두 가지 책임을 가지고 있다는 점입니다. Google 드라이브 및 Dropbox에서 객체를 읽고 쓰는 데에 대한 별도의 로직을 구현해야 합니다. SRP를 준수하기 위해 이 클래스를 GoogleStorageClient와 DropboxStorageClient로 분리할 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\r\nclass GoogleStorageClient:\r\n    _instance = None\r\n    _google_client = None\r\n\r\n    def __init__(self, google_credentials) -> None:\r\n        self._google_client = \"Google client\"\r\n\r\n    @classmethod    \r\n    def get_or_create_instance(cls, google_credentials) -> \"GoogleStorageClient\":\r\n        if not cls._instance:\r\n            cls._instance = GoogleStorageClient(google_credentials)\r\n\r\n        return cls._instance\r\n        \r\n    def read(self, key):\r\n        ...\r\n\r\n    def upload(self, key, value):\r\n        ...\r\n\r\n\r\nclass DropboxStorageClient:\r\n    _instance = None\r\n    _dropbox_client = None\r\n\r\n    def __init__(self, dropbox_credentials) -> None:\r\n        self._dropbox_client = \"Dropbox client\"\r\n\r\n    @classmethod    \r\n    def get_or_create_instance(cls, dropbox_credentials) -> \"DropboxStorageClient\":\r\n        if not cls._instance:\r\n            cls._instance = DropboxStorageClient(dropbox_credentials)\r\n\r\n        return cls._instance\r\n        \r\n    def read(self, key):\r\n        ...\r\n\r\n    def upload(self, key, value):\r\n        ...\r\n```\r\n\r\n조금 더 상세하게 작성하더라도, 두 클라이언트를 개별적으로 개발하고 코드를 더 유지보수하기 쉽게 만듭니다. 예를 들어 Google 클라이언트를 작업하는 사람은 Dropbox 클라이언트의 작동 방식을 알 필요가 없으며 그 반대도 마찬가지입니다.\r\n\r\n## 2. 개방/폐쇄 원칙 (OCP)\r\n\r\n버트랜드 메이어는 1988년 저술한 \"객체지향 소프트웨어 구성\"에서 개방-폐쇄 원칙을 처음 제안한 것으로 일반적으로 알려져 있습니다. 그러나 1990년대에 이 원칙은 언클 밥이 1996년에 발표한 \"개방-폐쇄 원칙\"으로 현재의 형태로 재정의되었습니다.\r\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n개방/폐쇄 원칙은 다음을 의미합니다:\n\n클래스에 새 기능을 추가할 수 있어야 하며 기존 코드를 변경하지 않아도 됩니다.\n\n예를 들어, 다음 클래스는 개방/폐쇄 원칙을 위반합니다:\n\n```js\nclass Vehicle:\n    def __init__(self, vehicle_type, **kwargs) -> None:\n        self.vehicle = vehicle_type\n        if self.vehicle_type == \"car\":\n            self.tires = kwargs[\"tires\"]\n            self.mode = kwargs[\"mode\"]\n        elif self.vehicle_type == \"boat\":\n            self.motors = kwargs[\"motors\"]\n            self.mode = kwargs[\"mode\"]\n\n    def get_specifications(self) -> str:\n        if self.vehicle_type == \"car\":\n            return f\"This {self.vehicle_type} has {self.tires} tires and can drive on {self.mode}.\"\n        elif self.vehicle_type == \"boat\":\n            return f\"This {self.vehicle_type} has {self.motors} motors and can float on {self.mode}.\"\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 클래스의 문제점은 새로운 차량, 예를 들어 비행기를 추가하려면 기존 클래스를 수정해야 한다는 것입니다.\n\n기존 코드를 수정하는 것은 위험할 수 있으며 버그를 도입할 수도 있고 유닛 테스트를 실패할 수도 있습니다.\n\n대신 추상 기본 클래스를 정의하고 상속을 사용하여 클래스가 개방/폐쇄 원칙을 따르도록 할 수 있습니다.\n\n```js\nfrom abc import ABC, abstractmethod\n\nclass Vehicle(ABC):\n    def __init__(self, mode) -> None:\n        self.mode = mode\n\n    @abstractmethod\n    def get_specifications(self) -> str:\n        ...\n\nclass Car(Vehicle):\n    def __init__(self, tires) -> None:\n        super().__init__(\"lane\")\n        self.tires = tires\n\n    def get_specifications(self) -> str:\n        return f\"This car has {self.tires} tires and can drive on {self.mode}.\"\n\nclass Boat(Vehicle):\n    def __init__(self, motors) -> None:\n        super().__init__(\"water\")\n        self.motors = motors\n\n    def get_specifications(self) -> str:\n        return f\"This boat has {self.motors} motors and can float on {self.mode}.\"\n\nclass Plane(Vehicle):\n    def __init__(self, engines) -> None:\n        super().__init__(\"air\")\n        self.engines = engines\n\n    def get_specifications(self) -> str:\n        return f\"This plane has {self.engines} engines and can fly through the {self.mode}.\"\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 새 차량을 추가하고 싶다면, 단순히 Vehicle 클래스를 상속하고 get_specifications 메서드를 구현하는 새 클래스를 생성하면 됩니다.\n\n## 3. 리스코프 치환 원칙 (LSP)\n\n리스코프 치환 원칙은 1987년 OOPSLA 컨퍼런스에서 Barbara Liskov에 의해 소개되었습니다. 이 원칙은 다음과 같습니다:\n\n다시 말해, 만약 `S`가 `T`의 서브 클래스라면, `T` 타입의 객체를 `S` 타입의 객체로 대체할 수 있어야 하며, 프로그램의 기능을 변경하지 않아야 합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예를 들어, 다음과 같은 클래스를 고려해보세요:\n\n```python\nclass Person:\n    def __init__(self, name, age) -> None:\n        self.name = name\n        self.age = age\n\n    def get_name(self) -> str:\n        return self.name\n\n    def vote(self, give_vote) -> int:\n        if give_vote:\n            return 1\n        return 0\n\nclass Child(Person):\n    def __init__(self, name, age) -> None:\n        super().__init__(name, age)\n\n    def vote(self) -> None:\n        raise NotImplementedError(\"어린이는 투표할 수 없습니다.\")\n```\n\n이 코드의 문제는 Child 클래스가 리스코프 치환 원칙을 위반한다는 것입니다. Person 타입의 객체를 Child 타입의 객체로 대체하려고 하면, 예를 들어 vote 메서드를 사용하려고 할 때 프로그램이 예상대로 동작하지 않을 것입니다.\n\n이 문제를 해결하기 위해서는 Person을 추상 기본 클래스로 변환하고, 그것을 상속하는 Child와 Adult 두 클래스를 만들면 됩니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\nfrom abc import ABC, abstractmethod\n\n\nclass Person(ABC):\n    def __init__(self, name, age) -> None:\n        self.name = name\n        self.age = age\n\n    def get_name(self) -> str:\n        return self.name\n\n\nclass Child(Person):\n    def __init__(self, name, age) -> None:\n        super().__init__(name, age)\n\n    def go_to_school(self) -> None:\n        print(f\"{self.name} is going to school.\")\n\n\nclass Adult(Person):\n    def __init__(self, name, age) -> None:\n        super().__init__(name, age)\n\n    def vote(self) -> int:\n        return 1\n\n\n이제 프로그램의 정확성에 영향을 주지 않고 Person 유형의 객체를 Child 또는 Adult 유형의 객체로 대체할 수 있습니다.\n\n## 4. Interface Segregation Principle (ISP)\n\n인터페이스 분리 원칙(Interface Segregation Principle, ISP)은 Uncle Bob이 만들었습니다. 이 원칙은 다음과 같이 설명합니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n큰 인터페이스를 피해야 합니다. 이는 모든 클라이언트가 구현하는 인터페이스 메서드를 사용하지 않는 대규모 인터페이스를 의미합니다.\n\n예를 들어, 다음과 같은 인터페이스를 고려해 보세요:\n\n```python\nfrom abc import ABC, abstractmethod\n\nclass Printer(ABC):\n    def scan(self) -> None: ...\n\n    def fax(self) -> None: ...\n\n    def print(self) -> None: ...\n\n\nclass SimplePrinter(Printer):\n    def scan(self) -> None:\n        raise NotImplementedError(\"This printer cannot scan.\")\n\n    def fax(self) -> None:\n        raise NotImplementedError(\"This printer cannot fax.\")\n\n    def print(self) -> None:\n        print(\"Printing...\")\n\n\nclass AdvancedPrinter(Printer):\n    def scan(self) -> None:\n        print(\"Scanning...\")\n\n    def fax(self) -> None:\n        print(\"Faxing...\")\n\n    def print(self) -> None:\n        print(\"Printing...\")\n```\n\n이 경우, SimplePrinter 클래스는 scan 및 fax 메서드가 필요하지 않지만, Printer 인터페이스를 구현하므로 이들을 구현해야 합니다. 이는 인터페이스 격리 원칙을 위반하는 것입니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그 대신, Printer 인터페이스를 Scanner, Fax 및 Printer 세 개의 별도의 인터페이스로 분리할 수 있습니다.\n\n```js\nfrom abc import ABC, abstractmethod\n\n\nclass Scanner(ABC):\n    @abstractmethod\n    def scan(self) -> None:\n        ...\n\n\nclass Fax(ABC):\n    @abstractmethod\n    def fax(self) -> None:\n        ...\n\n\nclass Printer(ABC):\n    @abstractmethod\n    def print(self) -> None:\n        ...\n\n\nclass SimplePrinter(Printer):\n    def print(self) -> None:\n        print(\"Printing...\")\n\n\nclass AdvancedPrinter(Scanner, Fax, Printer):\n    def scan(self) -> None:\n        print(\"Scanning...\")\n\n    def fax(self) -> None:\n        print(\"Faxing...\")\n\n    def print(self) -> None:\n        print(\"Printing...\")\n```\n\n이제 SimplePrinter 클래스는 Printer 인터페이스만 구현하면 되고, AdvancedPrinter 클래스는 세 인터페이스를 모두 구현할 수 있습니다.\n\n이 방식을 통해 코드를 이해하기 쉽게 만들고 SimplePrinter 클래스에 불필요한 메서드가 필요 없어졌습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 5. 의존성 역전 원칙\n\n언클 밥이 만든 의존성 역전 원칙은 다음과 같습니다:\n\n이 원칙은 고수준 모듈과 저수준 모듈을 결합을 느슨하게 하기 위해 그들 사이에 추상화 계층을 도입하는 것에 관한 것입니다. 이를 통해 결합이 적고 유연한 시스템을 만들 수 있습니다.\n\n다음은 의존성 역전 원칙을 위반하는 예시입니다. 고수준 모듈인 PaymentService가 저수준 모듈인 PaypalProcessor에 직접 의존하는 것입니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nclass PaypalProcessor:\n    def process_payment(self, amount):\n        print(f\"Processing payment of ${amount} via PayPal\")\n\n\nclass PaymentService:\n    def __init__(self) -> None:\n        self.payment_processor = PaypalProcessor()\n\n    def perform_payment(self, amount):\n        self.payment_processor.process_payment(amount)\n\n\npayment_service = PaymentService()\npayment_service.perform_payment(100)\n```\n\n만약 다른 결제 게이트웨이로 전환하고 싶다면, PaymentService 클래스를 수정해야 하는데 이는 개방-폐쇄 원칙을 위배합니다.\n\n대신, 우리가 결제를 처리하는 PaymentService 고수준 모듈과 PayPal, Stripe와 같은 다른 결제 게이트웨이와 상호 작용할 수 있는 추상 인터페이스인 PaymentProcessor가 있는 것으로 가정해 봅시다.\n\n```python\nfrom abc import ABC, abstractmethod\n\n\nclass PaymentProcessor(ABC):\n    @abstractmethod\n    def process_payment(self, amount):\n        pass\n\n\nclass PayPalPaymentProcessor(PaymentProcessor):\n    def process_payment(self, amount):\n        print(f\"Processing payment of ${amount} via PayPal\")\n        \n\nclass StripePaymentProcessor(PaymentProcessor):\n    def process_payment(self, amount):\n        print(f\"Processing payment of ${amount} via Stripe\")\n\n\nclass PaymentService:\n    def __init__(self, payment_processor):\n        self.payment_processor = payment_processor\n\n    def perform_payment(self, amount):\n        self.payment_processor.process_payment(amount)\n\n\npaypal_processor = PayPalPaymentProcessor()\npayment_service = PaymentService(paypal_processor)\npayment_service.perform_payment(100)\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이렇게하면 PaymentService 클래스는 특정 결제 프로세서 구현에 의존하지 않습니다. 대신 PaymentProcessor 인터페이스에 의존하고 있어서 PaymentService 클래스를 수정하지 않고도 다양한 결제 프로세서 간에 전환할 수 있습니다.\n\n# 결론\n\nSOLID 원칙은 깨끗하고 유지보수 가능하며 유연한 코드를 작성하는 데 도움이 되는 일련의 지침입니다. 이러한 원칙을 따르면 이해하기 쉬우며 테스트하고 유지하기 쉬운 코드를 만들 수 있습니다. 이러한 원칙에 적응하는 데는 시간이 걸릴 수 있지만, 확실히 더 나은 프로그래머가 되고 더 나은 소프트웨어를 만들 수 있도록 도와줄 것입니다. 이들은 가이드라인이며 절대적인 규칙이 아니므로 현명하게 사용하고 특정 요구사항에 맞게 적용하십시오.","ogImage":{"url":"/assets/img/2024-07-09-SOLIDprinciplesinPython_0.png"},"coverImage":"/assets/img/2024-07-09-SOLIDprinciplesinPython_0.png","tag":["Tech"],"readingTime":15},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-07-09-SOLIDprinciplesinPython_0.png\" alt=\"SOLID principles in Python\"></p>\n<h1>SOLID이란 무엇인가요?</h1>\n<p>객체 지향 프로그래밍은 모든 프로그래머의 도구 상자에서 매우 유용한 도구입니다. 그러나 사용할 때 대부분의 사람들이 빠지는 흔한 함정이 있습니다.</p>\n<p>SOLID 원칙은 이러한 함정을 피하고 깔끔하고 유지보수 가능한 코드를 작성하는 데 도움이 되는 일련의 지침입니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>\"SOLID\"은 다음을 나타내는 머리글자입니다:</p>\n<ul>\n<li>단일 책임 원칙 (SRP)</li>\n<li>개방/폐쇠 원칙 (OCP)</li>\n<li>리스코프 치환 원칙 (LSP)</li>\n</ul>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>\n<p>인터페이스 분리 원칙</p>\n</li>\n<li>\n<p>의존성 역전 원칙</p>\n</li>\n</ul>\n<h2>1. 단일 책임 원칙 (SRP)</h2>\n<p>로버트 C. 마틴 (a.k.a 아저씨 밥)이 \"OOD의 원칙\"이라는 기사에서 만들어진 단일 책임 원칙은 다음과 같습니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>한 클래스는 한 가지 책임만 가져야 합니다. 한 클래스가 여러 가지 일을 한다면, 여러 클래스로 분리해야 합니다.</p>\n<p>간단한 예를 통해 이를 설명해보겠습니다. 우리가 Google 드라이브 또는 Dropbox에서 객체를 읽고 쓰는 클래스가 있다고 가정해 봅시다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">StorageClient</span>:\n    _instance = <span class=\"hljs-title class_\">None</span>\n    _google_client = <span class=\"hljs-title class_\">None</span>\n    _dropbox_client = <span class=\"hljs-title class_\">None</span>\n\n    def <span class=\"hljs-title function_\">__init__</span>(self, google_credentials, dropbox_credentials) -> <span class=\"hljs-title class_\">None</span>:\n        self.<span class=\"hljs-property\">_google_client</span> = <span class=\"hljs-string\">\"Google 클라이언트\"</span>\n        self.<span class=\"hljs-property\">_dropbox_client</span> = <span class=\"hljs-string\">\"Dropbox 클라이언트\"</span>\n\n    @classmethod    \n    def <span class=\"hljs-title function_\">get_or_create_instance</span>(cls, google_credentials, dropbox_credentials) -> <span class=\"hljs-string\">\"StorageClient\"</span>:\n        <span class=\"hljs-keyword\">if</span> not cls.<span class=\"hljs-property\">_instance</span>:\n            cls.<span class=\"hljs-property\">_instance</span> = <span class=\"hljs-title class_\">StorageClient</span>(google_credentials, dropbox_credentials)\n\n        <span class=\"hljs-keyword\">return</span> cls.<span class=\"hljs-property\">_instance</span>\n        \n    def <span class=\"hljs-title function_\">read_from_google</span>(self, key):\n        ...\n\n    def <span class=\"hljs-title function_\">upload_to_google</span>(self, key, value):\n        ...\n\n    def <span class=\"hljs-title function_\">read_from_dropbox</span>(self, key):\n        ...\n    \n    def <span class=\"hljs-title function_\">upload_to_dropbox</span>(self, key, value):\n        ...\n</code></pre>\n<p>이 클래스의 문제는 두 가지 책임을 가지고 있다는 점입니다. Google 드라이브 및 Dropbox에서 객체를 읽고 쓰는 데에 대한 별도의 로직을 구현해야 합니다. SRP를 준수하기 위해 이 클래스를 GoogleStorageClient와 DropboxStorageClient로 분리할 수 있습니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">GoogleStorageClient</span>:\r\n    _instance = <span class=\"hljs-title class_\">None</span>\r\n    _google_client = <span class=\"hljs-title class_\">None</span>\r\n\r\n    def <span class=\"hljs-title function_\">__init__</span>(self, google_credentials) -> <span class=\"hljs-title class_\">None</span>:\r\n        self.<span class=\"hljs-property\">_google_client</span> = <span class=\"hljs-string\">\"Google client\"</span>\r\n\r\n    @classmethod    \r\n    def <span class=\"hljs-title function_\">get_or_create_instance</span>(cls, google_credentials) -> <span class=\"hljs-string\">\"GoogleStorageClient\"</span>:\r\n        <span class=\"hljs-keyword\">if</span> not cls.<span class=\"hljs-property\">_instance</span>:\r\n            cls.<span class=\"hljs-property\">_instance</span> = <span class=\"hljs-title class_\">GoogleStorageClient</span>(google_credentials)\r\n\r\n        <span class=\"hljs-keyword\">return</span> cls.<span class=\"hljs-property\">_instance</span>\r\n        \r\n    def <span class=\"hljs-title function_\">read</span>(self, key):\r\n        ...\r\n\r\n    def <span class=\"hljs-title function_\">upload</span>(self, key, value):\r\n        ...\r\n\r\n\r\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DropboxStorageClient</span>:\r\n    _instance = <span class=\"hljs-title class_\">None</span>\r\n    _dropbox_client = <span class=\"hljs-title class_\">None</span>\r\n\r\n    def <span class=\"hljs-title function_\">__init__</span>(self, dropbox_credentials) -> <span class=\"hljs-title class_\">None</span>:\r\n        self.<span class=\"hljs-property\">_dropbox_client</span> = <span class=\"hljs-string\">\"Dropbox client\"</span>\r\n\r\n    @classmethod    \r\n    def <span class=\"hljs-title function_\">get_or_create_instance</span>(cls, dropbox_credentials) -> <span class=\"hljs-string\">\"DropboxStorageClient\"</span>:\r\n        <span class=\"hljs-keyword\">if</span> not cls.<span class=\"hljs-property\">_instance</span>:\r\n            cls.<span class=\"hljs-property\">_instance</span> = <span class=\"hljs-title class_\">DropboxStorageClient</span>(dropbox_credentials)\r\n\r\n        <span class=\"hljs-keyword\">return</span> cls.<span class=\"hljs-property\">_instance</span>\r\n        \r\n    def <span class=\"hljs-title function_\">read</span>(self, key):\r\n        ...\r\n\r\n    def <span class=\"hljs-title function_\">upload</span>(self, key, value):\r\n        ...\n</code></pre>\n<p>조금 더 상세하게 작성하더라도, 두 클라이언트를 개별적으로 개발하고 코드를 더 유지보수하기 쉽게 만듭니다. 예를 들어 Google 클라이언트를 작업하는 사람은 Dropbox 클라이언트의 작동 방식을 알 필요가 없으며 그 반대도 마찬가지입니다.</p>\n<h2>2. 개방/폐쇄 원칙 (OCP)</h2>\n<p>버트랜드 메이어는 1988년 저술한 \"객체지향 소프트웨어 구성\"에서 개방-폐쇄 원칙을 처음 제안한 것으로 일반적으로 알려져 있습니다. 그러나 1990년대에 이 원칙은 언클 밥이 1996년에 발표한 \"개방-폐쇄 원칙\"으로 현재의 형태로 재정의되었습니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>개방/폐쇄 원칙은 다음을 의미합니다:</p>\n<p>클래스에 새 기능을 추가할 수 있어야 하며 기존 코드를 변경하지 않아도 됩니다.</p>\n<p>예를 들어, 다음 클래스는 개방/폐쇄 원칙을 위반합니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Vehicle</span>:\n    def <span class=\"hljs-title function_\">__init__</span>(self, vehicle_type, **kwargs) -> <span class=\"hljs-title class_\">None</span>:\n        self.<span class=\"hljs-property\">vehicle</span> = vehicle_type\n        <span class=\"hljs-keyword\">if</span> self.<span class=\"hljs-property\">vehicle_type</span> == <span class=\"hljs-string\">\"car\"</span>:\n            self.<span class=\"hljs-property\">tires</span> = kwargs[<span class=\"hljs-string\">\"tires\"</span>]\n            self.<span class=\"hljs-property\">mode</span> = kwargs[<span class=\"hljs-string\">\"mode\"</span>]\n        elif self.<span class=\"hljs-property\">vehicle_type</span> == <span class=\"hljs-string\">\"boat\"</span>:\n            self.<span class=\"hljs-property\">motors</span> = kwargs[<span class=\"hljs-string\">\"motors\"</span>]\n            self.<span class=\"hljs-property\">mode</span> = kwargs[<span class=\"hljs-string\">\"mode\"</span>]\n\n    def <span class=\"hljs-title function_\">get_specifications</span>(self) -> <span class=\"hljs-attr\">str</span>:\n        <span class=\"hljs-keyword\">if</span> self.<span class=\"hljs-property\">vehicle_type</span> == <span class=\"hljs-string\">\"car\"</span>:\n            <span class=\"hljs-keyword\">return</span> f<span class=\"hljs-string\">\"This {self.vehicle_type} has {self.tires} tires and can drive on {self.mode}.\"</span>\n        elif self.<span class=\"hljs-property\">vehicle_type</span> == <span class=\"hljs-string\">\"boat\"</span>:\n            <span class=\"hljs-keyword\">return</span> f<span class=\"hljs-string\">\"This {self.vehicle_type} has {self.motors} motors and can float on {self.mode}.\"</span>\n</code></pre>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>이 클래스의 문제점은 새로운 차량, 예를 들어 비행기를 추가하려면 기존 클래스를 수정해야 한다는 것입니다.</p>\n<p>기존 코드를 수정하는 것은 위험할 수 있으며 버그를 도입할 수도 있고 유닛 테스트를 실패할 수도 있습니다.</p>\n<p>대신 추상 기본 클래스를 정의하고 상속을 사용하여 클래스가 개방/폐쇄 원칙을 따르도록 할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">from</span> abc <span class=\"hljs-keyword\">import</span> <span class=\"hljs-variable constant_\">ABC</span>, abstractmethod\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Vehicle</span>(<span class=\"hljs-variable constant_\">ABC</span>):\n    def <span class=\"hljs-title function_\">__init__</span>(self, mode) -> <span class=\"hljs-title class_\">None</span>:\n        self.<span class=\"hljs-property\">mode</span> = mode\n\n    @abstractmethod\n    def <span class=\"hljs-title function_\">get_specifications</span>(self) -> <span class=\"hljs-attr\">str</span>:\n        ...\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Car</span>(<span class=\"hljs-title class_\">Vehicle</span>):\n    def <span class=\"hljs-title function_\">__init__</span>(self, tires) -> <span class=\"hljs-title class_\">None</span>:\n        <span class=\"hljs-variable language_\">super</span>().<span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-string\">\"lane\"</span>)\n        self.<span class=\"hljs-property\">tires</span> = tires\n\n    def <span class=\"hljs-title function_\">get_specifications</span>(self) -> <span class=\"hljs-attr\">str</span>:\n        <span class=\"hljs-keyword\">return</span> f<span class=\"hljs-string\">\"This car has {self.tires} tires and can drive on {self.mode}.\"</span>\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Boat</span>(<span class=\"hljs-title class_\">Vehicle</span>):\n    def <span class=\"hljs-title function_\">__init__</span>(self, motors) -> <span class=\"hljs-title class_\">None</span>:\n        <span class=\"hljs-variable language_\">super</span>().<span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-string\">\"water\"</span>)\n        self.<span class=\"hljs-property\">motors</span> = motors\n\n    def <span class=\"hljs-title function_\">get_specifications</span>(self) -> <span class=\"hljs-attr\">str</span>:\n        <span class=\"hljs-keyword\">return</span> f<span class=\"hljs-string\">\"This boat has {self.motors} motors and can float on {self.mode}.\"</span>\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Plane</span>(<span class=\"hljs-title class_\">Vehicle</span>):\n    def <span class=\"hljs-title function_\">__init__</span>(self, engines) -> <span class=\"hljs-title class_\">None</span>:\n        <span class=\"hljs-variable language_\">super</span>().<span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-string\">\"air\"</span>)\n        self.<span class=\"hljs-property\">engines</span> = engines\n\n    def <span class=\"hljs-title function_\">get_specifications</span>(self) -> <span class=\"hljs-attr\">str</span>:\n        <span class=\"hljs-keyword\">return</span> f<span class=\"hljs-string\">\"This plane has {self.engines} engines and can fly through the {self.mode}.\"</span>\n</code></pre>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>이제 새 차량을 추가하고 싶다면, 단순히 Vehicle 클래스를 상속하고 get_specifications 메서드를 구현하는 새 클래스를 생성하면 됩니다.</p>\n<h2>3. 리스코프 치환 원칙 (LSP)</h2>\n<p>리스코프 치환 원칙은 1987년 OOPSLA 컨퍼런스에서 Barbara Liskov에 의해 소개되었습니다. 이 원칙은 다음과 같습니다:</p>\n<p>다시 말해, 만약 <code>S</code>가 <code>T</code>의 서브 클래스라면, <code>T</code> 타입의 객체를 <code>S</code> 타입의 객체로 대체할 수 있어야 하며, 프로그램의 기능을 변경하지 않아야 합니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>예를 들어, 다음과 같은 클래스를 고려해보세요:</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Person</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, name, age</span>) -> <span class=\"hljs-literal\">None</span>:\n        self.name = name\n        self.age = age\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">get_name</span>(<span class=\"hljs-params\">self</span>) -> <span class=\"hljs-built_in\">str</span>:\n        <span class=\"hljs-keyword\">return</span> self.name\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">vote</span>(<span class=\"hljs-params\">self, give_vote</span>) -> <span class=\"hljs-built_in\">int</span>:\n        <span class=\"hljs-keyword\">if</span> give_vote:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Child</span>(<span class=\"hljs-title class_ inherited__\">Person</span>):\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, name, age</span>) -> <span class=\"hljs-literal\">None</span>:\n        <span class=\"hljs-built_in\">super</span>().__init__(name, age)\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">vote</span>(<span class=\"hljs-params\">self</span>) -> <span class=\"hljs-literal\">None</span>:\n        <span class=\"hljs-keyword\">raise</span> NotImplementedError(<span class=\"hljs-string\">\"어린이는 투표할 수 없습니다.\"</span>)\n</code></pre>\n<p>이 코드의 문제는 Child 클래스가 리스코프 치환 원칙을 위반한다는 것입니다. Person 타입의 객체를 Child 타입의 객체로 대체하려고 하면, 예를 들어 vote 메서드를 사용하려고 할 때 프로그램이 예상대로 동작하지 않을 것입니다.</p>\n<p>이 문제를 해결하기 위해서는 Person을 추상 기본 클래스로 변환하고, 그것을 상속하는 Child와 Adult 두 클래스를 만들면 됩니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>from abc import ABC, abstractmethod</p>\n<p>class Person(ABC):\ndef <strong>init</strong>(self, name, age) -> None:\nself.name = name\nself.age = age</p>\n<pre><code>def get_name(self) -> str:\n    return self.name\n</code></pre>\n<p>class Child(Person):\ndef <strong>init</strong>(self, name, age) -> None:\nsuper().<strong>init</strong>(name, age)</p>\n<pre><code>def go_to_school(self) -> None:\n    print(f\"{self.name} is going to school.\")\n</code></pre>\n<p>class Adult(Person):\ndef <strong>init</strong>(self, name, age) -> None:\nsuper().<strong>init</strong>(name, age)</p>\n<pre><code>def vote(self) -> int:\n    return 1\n</code></pre>\n<p>이제 프로그램의 정확성에 영향을 주지 않고 Person 유형의 객체를 Child 또는 Adult 유형의 객체로 대체할 수 있습니다.</p>\n<h2>4. Interface Segregation Principle (ISP)</h2>\n<p>인터페이스 분리 원칙(Interface Segregation Principle, ISP)은 Uncle Bob이 만들었습니다. 이 원칙은 다음과 같이 설명합니다:</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>큰 인터페이스를 피해야 합니다. 이는 모든 클라이언트가 구현하는 인터페이스 메서드를 사용하지 않는 대규모 인터페이스를 의미합니다.</p>\n<p>예를 들어, 다음과 같은 인터페이스를 고려해 보세요:</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">from</span> abc <span class=\"hljs-keyword\">import</span> ABC, abstractmethod\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Printer</span>(<span class=\"hljs-title class_ inherited__\">ABC</span>):\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">scan</span>(<span class=\"hljs-params\">self</span>) -> <span class=\"hljs-literal\">None</span>: ...\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">fax</span>(<span class=\"hljs-params\">self</span>) -> <span class=\"hljs-literal\">None</span>: ...\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-params\">self</span>) -> <span class=\"hljs-literal\">None</span>: ...\n\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SimplePrinter</span>(<span class=\"hljs-title class_ inherited__\">Printer</span>):\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">scan</span>(<span class=\"hljs-params\">self</span>) -> <span class=\"hljs-literal\">None</span>:\n        <span class=\"hljs-keyword\">raise</span> NotImplementedError(<span class=\"hljs-string\">\"This printer cannot scan.\"</span>)\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">fax</span>(<span class=\"hljs-params\">self</span>) -> <span class=\"hljs-literal\">None</span>:\n        <span class=\"hljs-keyword\">raise</span> NotImplementedError(<span class=\"hljs-string\">\"This printer cannot fax.\"</span>)\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-params\">self</span>) -> <span class=\"hljs-literal\">None</span>:\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Printing...\"</span>)\n\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AdvancedPrinter</span>(<span class=\"hljs-title class_ inherited__\">Printer</span>):\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">scan</span>(<span class=\"hljs-params\">self</span>) -> <span class=\"hljs-literal\">None</span>:\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Scanning...\"</span>)\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">fax</span>(<span class=\"hljs-params\">self</span>) -> <span class=\"hljs-literal\">None</span>:\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Faxing...\"</span>)\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-params\">self</span>) -> <span class=\"hljs-literal\">None</span>:\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Printing...\"</span>)\n</code></pre>\n<p>이 경우, SimplePrinter 클래스는 scan 및 fax 메서드가 필요하지 않지만, Printer 인터페이스를 구현하므로 이들을 구현해야 합니다. 이는 인터페이스 격리 원칙을 위반하는 것입니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>그 대신, Printer 인터페이스를 Scanner, Fax 및 Printer 세 개의 별도의 인터페이스로 분리할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">from</span> abc <span class=\"hljs-keyword\">import</span> <span class=\"hljs-variable constant_\">ABC</span>, abstractmethod\n\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Scanner</span>(<span class=\"hljs-variable constant_\">ABC</span>):\n    @abstractmethod\n    def <span class=\"hljs-title function_\">scan</span>(self) -> <span class=\"hljs-title class_\">None</span>:\n        ...\n\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Fax</span>(<span class=\"hljs-variable constant_\">ABC</span>):\n    @abstractmethod\n    def <span class=\"hljs-title function_\">fax</span>(self) -> <span class=\"hljs-title class_\">None</span>:\n        ...\n\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Printer</span>(<span class=\"hljs-variable constant_\">ABC</span>):\n    @abstractmethod\n    def <span class=\"hljs-title function_\">print</span>(self) -> <span class=\"hljs-title class_\">None</span>:\n        ...\n\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SimplePrinter</span>(<span class=\"hljs-title class_\">Printer</span>):\n    def <span class=\"hljs-title function_\">print</span>(self) -> <span class=\"hljs-title class_\">None</span>:\n        <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"Printing...\"</span>)\n\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AdvancedPrinter</span>(<span class=\"hljs-title class_\">Scanner</span>, <span class=\"hljs-title class_\">Fax</span>, <span class=\"hljs-title class_\">Printer</span>):\n    def <span class=\"hljs-title function_\">scan</span>(self) -> <span class=\"hljs-title class_\">None</span>:\n        <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"Scanning...\"</span>)\n\n    def <span class=\"hljs-title function_\">fax</span>(self) -> <span class=\"hljs-title class_\">None</span>:\n        <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"Faxing...\"</span>)\n\n    def <span class=\"hljs-title function_\">print</span>(self) -> <span class=\"hljs-title class_\">None</span>:\n        <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"Printing...\"</span>)\n</code></pre>\n<p>이제 SimplePrinter 클래스는 Printer 인터페이스만 구현하면 되고, AdvancedPrinter 클래스는 세 인터페이스를 모두 구현할 수 있습니다.</p>\n<p>이 방식을 통해 코드를 이해하기 쉽게 만들고 SimplePrinter 클래스에 불필요한 메서드가 필요 없어졌습니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h2>5. 의존성 역전 원칙</h2>\n<p>언클 밥이 만든 의존성 역전 원칙은 다음과 같습니다:</p>\n<p>이 원칙은 고수준 모듈과 저수준 모듈을 결합을 느슨하게 하기 위해 그들 사이에 추상화 계층을 도입하는 것에 관한 것입니다. 이를 통해 결합이 적고 유연한 시스템을 만들 수 있습니다.</p>\n<p>다음은 의존성 역전 원칙을 위반하는 예시입니다. 고수준 모듈인 PaymentService가 저수준 모듈인 PaypalProcessor에 직접 의존하는 것입니다:</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">PaypalProcessor</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">process_payment</span>(<span class=\"hljs-params\">self, amount</span>):\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f\"Processing payment of $<span class=\"hljs-subst\">{amount}</span> via PayPal\"</span>)\n\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">PaymentService</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self</span>) -> <span class=\"hljs-literal\">None</span>:\n        self.payment_processor = PaypalProcessor()\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">perform_payment</span>(<span class=\"hljs-params\">self, amount</span>):\n        self.payment_processor.process_payment(amount)\n\n\npayment_service = PaymentService()\npayment_service.perform_payment(<span class=\"hljs-number\">100</span>)\n</code></pre>\n<p>만약 다른 결제 게이트웨이로 전환하고 싶다면, PaymentService 클래스를 수정해야 하는데 이는 개방-폐쇄 원칙을 위배합니다.</p>\n<p>대신, 우리가 결제를 처리하는 PaymentService 고수준 모듈과 PayPal, Stripe와 같은 다른 결제 게이트웨이와 상호 작용할 수 있는 추상 인터페이스인 PaymentProcessor가 있는 것으로 가정해 봅시다.</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">from</span> abc <span class=\"hljs-keyword\">import</span> ABC, abstractmethod\n\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">PaymentProcessor</span>(<span class=\"hljs-title class_ inherited__\">ABC</span>):\n<span class=\"hljs-meta\">    @abstractmethod</span>\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">process_payment</span>(<span class=\"hljs-params\">self, amount</span>):\n        <span class=\"hljs-keyword\">pass</span>\n\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">PayPalPaymentProcessor</span>(<span class=\"hljs-title class_ inherited__\">PaymentProcessor</span>):\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">process_payment</span>(<span class=\"hljs-params\">self, amount</span>):\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f\"Processing payment of $<span class=\"hljs-subst\">{amount}</span> via PayPal\"</span>)\n        \n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">StripePaymentProcessor</span>(<span class=\"hljs-title class_ inherited__\">PaymentProcessor</span>):\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">process_payment</span>(<span class=\"hljs-params\">self, amount</span>):\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f\"Processing payment of $<span class=\"hljs-subst\">{amount}</span> via Stripe\"</span>)\n\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">PaymentService</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, payment_processor</span>):\n        self.payment_processor = payment_processor\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">perform_payment</span>(<span class=\"hljs-params\">self, amount</span>):\n        self.payment_processor.process_payment(amount)\n\n\npaypal_processor = PayPalPaymentProcessor()\npayment_service = PaymentService(paypal_processor)\npayment_service.perform_payment(<span class=\"hljs-number\">100</span>)\n</code></pre>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>이렇게하면 PaymentService 클래스는 특정 결제 프로세서 구현에 의존하지 않습니다. 대신 PaymentProcessor 인터페이스에 의존하고 있어서 PaymentService 클래스를 수정하지 않고도 다양한 결제 프로세서 간에 전환할 수 있습니다.</p>\n<h1>결론</h1>\n<p>SOLID 원칙은 깨끗하고 유지보수 가능하며 유연한 코드를 작성하는 데 도움이 되는 일련의 지침입니다. 이러한 원칙을 따르면 이해하기 쉬우며 테스트하고 유지하기 쉬운 코드를 만들 수 있습니다. 이러한 원칙에 적응하는 데는 시간이 걸릴 수 있지만, 확실히 더 나은 프로그래머가 되고 더 나은 소프트웨어를 만들 수 있도록 도와줄 것입니다. 이들은 가이드라인이며 절대적인 규칙이 아니므로 현명하게 사용하고 특정 요구사항에 맞게 적용하십시오.</p>\n</body>\n</html>\n"},"__N_SSG":true}