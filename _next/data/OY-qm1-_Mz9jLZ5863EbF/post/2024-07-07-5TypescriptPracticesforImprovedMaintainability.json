{"pageProps":{"post":{"title":"유지보수성을 높이는 5가지 TypeScript 실천법","description":"","date":"2024-07-07 19:20","slug":"2024-07-07-5TypescriptPracticesforImprovedMaintainability","content":"\n\n\n![이미지](/assets/img/2024-07-07-5TypescriptPracticesforImprovedMaintainability_0.png)\n\n아래의 권장 사항은 Typescript를 사용하여 더 유지보수가 용이한 코드를 만드는 데 도움이 되었던 몇 가지 조언에 대한 것입니다. 이 조언들은 새로운 구성 요소에서 Typescript를 사용하고 기존 페이지에서는 여전히 순수 JavaScript를 사용하는 프런트엔드 코드 베이스에서 특히 유용했습니다. 여러분에게도 조금 도움이 되기를 바랍니다.\n\n다음 섹션에서는 제가 제공하는 제안의 요약과 각 포인트가 더 유지보수가 용이한 코드를 만드는 데 왜 도움이 되는지에 대한 몇 가지 핵심 요점에 대해 설명한 후, 이러한 조언을 실제로 어떻게 실천할 수 있는지를 보여주는 몇 가지 예제를 제시할 것입니다.\n\n# 팁 #1: 난해한 API 값 해결 및 타입의 힘을 활용하여 이름 변경하기\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n가끔 우리가 작업하는 API는 매우 약어화된 또는 난해한 값 이름을 포함한 데이터 본문을 제공할 수 있습니다. 백엔드와 프론트엔드 사이의 분리 정도에 따라, 이는 코드가 어떤 작업을 수행하고 어떻게 상호 작용해야 하는지 이해하는 데 문제가 될 수 있습니다. 이 문제를 해결하기 위해 API 데이터를 새 객체로 해석하고 더 나은 명명 규칙으로 유형을 지정할 수 있습니다.\n\n## 왜 해야 하나요?\n\n- 다른 사람들과 미래의 자신이 코드를 읽고 이해하기 쉽게 만듭니다.\n- 사용 사례를 명확히 설명합니다 (특히 난해한 이름을 가진 부울 값의 경우).\n- 코드와 API 설명서 간을 계속 왔다갔다해야 하거나 과도한 콘솔 로깅을 하지 않아도 됩니다.\n\n## 예시\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n// API에서 수신된 데이터\n// `f_n`은 `firstName`이 됩니다.\n// `l_n`은 `lastName`이 됩니다.\n// `users`는 `canEditUsers`가 됩니다.\nconst rawUserData = [\n  {\n    id: 1654,\n    f_n: \"Jose\",\n    l_n: \"Sanchez\",\n    users: true,\n  },\n  {\n    id: 3297,\n    f_n: \"Bob\",\n    l_n: \"Richards\",\n    users: false,\n  },\n  {\n    id: 4572,\n    f_n: \"Janet\",\n    l_n: \"Wong\",\n    users: true,\n  },\n];\n\nconst UsersPage = () => {\n  // 원시 데이터 값을 더 쉽게 사용할 수 있는 키로 해석합니다.\n  const resolvedUserData = rawUserData.map((userData) => ({\n    id: userData.id,\n    firstName: userData.f_n ?? \"\",\n    lastName: userData.l_n ?? \"\",\n    canEditUsers: Boolean(userData.users),\n  })) as Users[];\n\n  // 해석된 데이터로 UsersList를 렌더링합니다.\n  return <UsersList users={resolvedUserData} />;\n};\n\nexport default UsersPage;\n\n// 다른 파일에서...\n\n// API에서 원시 키 이름을 알려주는 JSDoc을 추가했음에 주목하세요.\n// GraphQL 또는 Prisma와 같은 프론트엔드와 API 사이의 레이어가 있는 경우 특히 중요합니다.\n/**\n * @type firstName: Raw `f_n`\n * @type lastName: Raw `l_n`\n * @type canEditUsers: Raw `users`\n */\ntype Users = {\n  id: number;\n  firstName: string; // 원시: f_n\n  lastName: string; // 원시: l_n\n  canEditUsers: boolean; // 원시: users\n};\n\n// 원시 API 키와 비교했을 때 가독성이 향상되는 점에 주목하세요.\n// UsersList 구성 요소가 부모로부터 추상화되고 입력을 사용하여 사용자 데이터를 업데이트하기 시작할 때\n// 이 사항은 점점 더 중요해집니다.\nconst UsersList = ({ users }: { users: Users[] }) => {\n  return (\n    <div>\n      {users.map((user) => (\n        <div key={user.id}>\n          <div>\n            이름: {user.firstName} {user.lastName}\n          </div>\n          <div>사용자 수정 가능? {`${user.canEditUsers}`}</div>\n          <br />\n          <br />\n        </div>\n      ))}\n    </div>\n  );\n};\n```\n\n# 팁 #2: 모든 하드코딩된 문자열 값을 enum, object 또는 string 리터럴 유니온으로 대체하세요 (사용 사례에 따라 다름)\n\n기능을 처음 구현할 때는 단순한 로직을 수행하기 위해 문자열 값과 같은 기본 유형을 하드코딩하는 것이 더 쉬울 수 있습니다.\n그러나 코드베이스가 커지고 여러 컴포넌트로 분할되면, 이는 많은 중복을 야기하고 유지 관리의 어려움을 증가시킬 수 있습니다.\n이 문제를 해결하기 위해 이러한 분산된 하드코딩된 문자열을 재사용 가능한 enum, object 또는 유니언으로 통합할 수 있습니다.\n\n## 왜 이렇게 해야 하나요?\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 코드 완성 기능을 사용하여 유형을 사용할 수 있게 해서 더 많이 추측할 필요가 없도록 합니다\n- 구성 요소를 더 재사용 가능하게 만듭니다\n- 리듀서와 컨텍스트 또는 상태 관리자와 유형을 사용하는 것을 더 간단하게 만듭니다\n- 서로 다른 함수와 구성 요소 사이에서 상태를 전달하는 것을 간단하게 만듭니다\n- 잘못된 입력 및 유형을 검출하는 데 도움이 됩니다\n- 기본값으로 사용할 \"unknown\"과 같은 예외 유형을 추가할 수 있도록 합니다\n\n## 예시\n\n```js\n/** \n* 예시 1: 열거형\n* 사용 시기:이 것을 사용할 모든 파일이 ts인 경우\n* 장점: 변경할 수 없는 상수\n  더 나은 형식 안전성, 유형으로 더 쉽게 작업할 수 있음\n  사용자 정의 로직에 대한 switch 케이스 사용이 쉬움\n* 단점: 바닐라 js와 사용할 수 없음\n*/\nenum Fruits {\n  APPLE = \"Apple\",\n  ORANGE = \"Orange\",\n  BANANA = \"Banana\",\n}\n\nexport const FruitsFromEnumDropdown = () => {\n  type FruitOptionsFromEnum = {\n    label: Fruits;\n    value: keyof typeof Fruits;\n  };\n\n  const fruitOptions = Object.entries(Fruits).map(\n    ([value, label]) =>\n      ({\n        label: label,\n        value: value,\n      } as FruitOptionsFromEnum)\n  );\n\n  const [selectedFruit, setSelectedFruit] = React.useState(\n    fruitOptions[0].value\n  );\n\n  const onSelectFruit = (selectedFruit: FruitOptionsFromEnum[\"value\"]) => {\n    const selectedOption = fruitOptions.find(\n      (fruit) => fruit.value === selectedFruit\n    );\n    if (selectedOption) {\n      setSelectedFruit(selectedOption?.value);\n    }\n  };\n\n  return (\n    <>\n      <div>열거형에서 선택한 과일 : {selectedFruit}</div>\n      <select\n        onChange={(e) =>\n          onSelectFruit(e.target.value as FruitOptionsFromEnum[\"value\"])\n        }\n      >\n        {fruitOptions.map((fruit) => (\n          <option key={fruit.value} value={fruit.value}>\n            {fruit.label}\n          </option>\n        ))}\n      </select>\n    </>\n  );\n};\n\n/**\n* 예시 2: 객체 사용하기\n* 사용 시기: 코드 베이스의 일부가 아직 바닐라 js를 사용하는 경우\n* 장점: 복사하거나 'let' 및 'as const'가 아닌 경우 할당 가능\n  ts 및 js 파일 간에 사용 가능\n* 단점: enums보다 유형을 사용하기 어려울 수 있음, 'as const'조차도\n*/\nconst FruitsObject = {\n  APPLE: \"Apple\",\n  ORANGE: \"Orange\",\n  BANANA: \"Banana\",\n} as const;\n\nexport const FruitsFromObjectDropdown = () => {\n  type FruitOptionsFromObject = {\n    label: (typeof FruitsObject)[keyof typeof FruitsObject];\n    value: keyof typeof FruitsObject;\n  };\n\n  const fruitOptions = Object.entries(FruitsObject).map(\n    ([v, k]) =>\n      ({\n        label: k,\n        value: v,\n      } as FruitOptionsFromObject)\n  );\n\n  const [selectedFruit, setSelectedFruit] = React.useState(\n    fruitOptions[0].value\n  );\n\n  const onSelectFruit = (selectedFruit: FruitOptionsFromObject[\"value\"]) => {\n    const selectedOption = fruitOptions.find(\n      (fruit) => fruit.value === selectedFruit\n    );\n    if (selectedOption) {\n      setSelectedFruit(selectedOption?.value);\n    }\n  };\n\n  return (\n    <>\n      <div>객체에서 선택한 과일 : {selectedFruit}</div>\n      <select\n        onChange={(e) =>\n          onSelectFruit(e.target.value as FruitOptionsFromObject[\"value\"])\n        }\n      >\n        {fruitOptions.map((fruit) => (\n          <option key={fruit.value} value={fruit.value}>\n            {fruit.label}\n          </option>\n        ))}\n      </select>\n    </>\n  );\n};\n\n/**\n* 예시 3: 문자열 유니언\n* 사용 시기: 백엔드에서 유형을 확장해야하거나 대안으로 enums를 대체해야할 때\n* 장점: 쉽게 확장 가능\n  ts 및 js 간에 재사용 가능\n  사용자 정의 로직에 대한 switch 케이스 사용이 쉬움\n* 단점: enums와 같이 할당할 수 없으며, 문자열은 순수한 리터럴임\n*/\ntype StatusStringUnion = \"saved\" | \"saving\" | \"standby\" | \"error\" | \"unknown\";\nexport const FormStatus = () => {\n  const [currentStatus, setCurrentStatus] =\n    React.useState<StatusStringUnion>(\"unknown\");\n\n  return (\n    <StatusRow>\n      상태: <Label>{currentStatus}</Label>\n      <Dot status={currentStatus} />\n    </StatusRow>\n  );\n};\n\n//다른 파일에서는 ...\nconst StatusRow = styled.div`\n  display: flex;\n  justify-content: center;\n  align-content: center;\n`;\n\nconst Label = styled.div`\n  margin-left: 0.25rem;\n  font-size: 12pt;\n  font-weight: 600;\n`;\n\n//사용자 정의 StyledComponents 로직 사용 예시\n//enum 또는 문자열 유니언은 이러한 경우에 가장 적합합니다\nconst Dot = styled.div<{ status: StatusStringUnion }>`\n  display: flex;\n  justify-content: center;\n  align-content: start;\n  clip-path: circle(5px);\n  width: 1rem;\n  background: ${({ status }) => {\n    switch (status) {\n      case \"saved\":\n        return \"green\";\n      case \"saving\":\n        return \"yellow\";\n      case \"error\":\n        return \"red\";\n      case \"standby\":\n        return \"none\";\n      case \"unknown\":\n        return \"gray\";\n      default:\n        return \"gray\";\n    }\n  };\n  margin-left: 0.25rem;\n`;\n\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n내가 작업한 많은 코드에서, 유형은 일반적으로 변경할 수 없는 값을 나타내는 비-nullable로 기본 설정됩니다. 그러나 값은 때로 바뀔 수 있고, 앱의 내부 논리 구조가 복잡해지면 예기치 않은 null 또는 undefined 값이 발생하여 프로덕션 코드에서 유형 오류를 발생시키기 쉬워집니다. 이를 피하는 한 가지 방법은 다른 방향으로 기본값을 nullable 값으로 설정하는 것입니다. 기본적으로, 이 값이 어떤 상황에서 null 또는 undefined가 될 수 있는 경우(또는 확실하지 않은 경우), 선택 사항 유형으로 만드는 것입니다.\n\n## 이유\n\n- 백엔드와 프론트엔드가 강하게 결합되어 있지 않은 경우(즉, 풀스택 개발자가 아닌 경우), 두 계약 사이의 값 유형이 제대로 문서화되지 않을 수 있음\n- 데이터베이스가 커지고 복잡해지면 예상치 못한 값(예: null 및 undefined)이 부정적으로 발생할 확률이 높아집니다\n- 앱이 사용자 입력을 수락하는 경우, 프론트엔드와 백엔드의 유효성 검사 엣지 케이스가 데이터베이스에 이상한 값이 저장되도록 할 수 있음\n- 나중에 요구 사항이 변경되어 null/undefined 값을 허용하는 경우가 생길 수 있음\n- null/undefined이면 명시적으로 기본값을 설정할 수 있어, 문자열이 항상 \" \"와 같은 문자열이 되도록 보장할 수 있음\n- 입력 값에 일부 값을 필수로 만들면, 유효성 검사의 추가 계층을 추가하고 부정적인 값이 백엔드로 전송되지 않도록 보장할 수 있음\n\n## 예시\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n/**\n * @type firstName: Raw `f_n`\n * @type lastName: Raw `l_n`\n * @type canEditUsers: Raw `users`\n */\ntype Users = {\n  id: number;\n  firstName?: string; //Raw: f_n\n  lastName?: string; //Raw: l_n\n  canEditUsers?: boolean; //Raw: users\n};\n\n//만약 아래의 사용자(user)를 접근하려고 할 때 값 중 하나라도 null이 허용되지 않는\n//즉, 필수값이면 타입 오류를 발생시키고 렌더를 충돌시킬 수 있습니다.\n//이는 널 병합 연산자를 사용할 수 있게 하여 Typescript가\n//해당 사용법을 강제하는 것을 가능하게 합니다.\nconst UsersList = ({ users }: { users: Users[] }) => {\n  return (\n    <div>\n      {users.map((user) => (\n        <div key={user.id}>\n          <div>\n            Name: {user?.firstName} {user?.lastName}\n          </div>\n          <div>Can edit users? {`${user?.canEditUsers}`}</div>\n          <br />\n          <br />\n        </div>\n      ))}\n    </div>\n  );\n};\n\n# 팁 #4: 일반적으로 재사용되는 유형을 제네릭을 사용하여 유틸 파일에 저장하기\n\n코드 베이스가 커지면 앱 전반에서 유사한 유형을 재사용해야 할 수 있습니다. 가장 일반적으로 재사용되는 유형을 제네릭의 힘을 이용하여 더 재사용할 수 있게 할 수 있으며, 이는 기본 유형이 완벽하게 일치하지 않을 때도 유형이 여러 컨텍스트에서 재사용될 수 있음을 의미합니다. 이러한 접근 방식을 사용하면 재사용 가능한 유틸 함수가 Typescript의 모든 기능을 최대한 활용할 수 있음을 의미합니다.\n\n## 왜 이것을 하는가\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 수동으로 모든 사용법을 입력할 필요가 없다는 것을 의미합니다.\n- 한 곳에서 유형을 업데이트하는 것이 더 쉽습니다.\n- 재사용 가능하고 매우 복잡한 유형을 만들 수 있습니다.\n- 코드 베이스의 라이브러리에서 기초로 하는 유형을 만들 수 있습니다(예: Relay).\n- 해당 유형을 사용하는 구성 요소를 지저분하게 만들지 않고 찾기, 문서화, 사용하기가 더 쉽습니다.\n\n## 예시\n\n```js\n/** Example 1: 제네릭을 사용한 재사용 가능한 유형 */\n// `utils/reusableTypes.ts` 파일 내에서\nimport React from \"react\";\nimport { Disposable, UseMutationConfig } from \"react-relay\";\nimport { MutationParameters } from \"relay-runtime\";\n\n/**\n * @description 주어진 유형에서 값을 가져오는 유형\n * @example { fieldName: FormProps, value: ValueOf<FormProps> }\n */\nexport type ValueOf<T> = T[keyof T];\n\n/**\n * @description Relay 변경 사항으로부터 유형 만들기\n * @example type UserContextTypes = {\n *   createUser: MutationTypeOf<createUserMutation>\n * }\n */\nexport type MutationTypeOf<T extends MutationParameters> = (\n  config: UseMutationConfig<T>\n) => Disposable;\n\n//다른 파일에서 ...\nimport React from \"react\";\nimport { ValueOf } from \"../utils/reusableTypes\";\n\nenum Fruits {\n  APPLE = \"Apple\",\n  ORANGE = \"Orange\",\n  BANANA = \"Banana\",\n}\n\nexport const GenericFruitsFromEnumDropdown = () => {\n  const fruitOptions = Object.entries(Fruits).map(([value, label]) => ({\n    label: label,\n    value: value,\n  }));\n\n  const [selectedFruit, setSelectedFruit] = React.useState(\n    fruitOptions[0].value\n  );\n\n//거의 모든 다른 데이터 유형과 함께`ValueOf`의 제네릭 유형을 사용할 수 있습니다.\n//단, Fruits 열거형을 포함한다.\n  const onSelectFruit = (selectedFruit: ValueOf<Fruits>) => {\n    const selectedOption = fruitOptions.find(\n      (fruit) => fruit.value === selectedFruit\n    );\n    if (selectedOption) {\n      setSelectedFruit(selectedOption?.value);\n    }\n  };\n\n  //ValueOf를 사용하면 열거형 값과의 비교를 수행할 수 있습니다.\n  console.log(selectedFruit === Fruits.APPLE);\n\n  return (\n    <>\n      <div>선택된 열거형 과일: {selectedFruit}</div>\n      <select onChange={(e) => onSelectFruit(e.target.value)}>\n        {fruitOptions.map((fruit) => (\n          <option key={fruit.value} value={fruit.value}>\n            {fruit.label}\n          </option>\n        ))}\n      </select>\n    </>\n  );\n};\n```\n\n```js\n/** Example 2: 제네릭을 사용한 재사용 가능한 함수 */\n// `utils/reusableFunctions.ts` 파일 내에서\nimport React from \"react\";\n\n/**\n * @description 주어진 기본 값이 배열에서 중복되는지 여부를 확인합니다.\n * @example\n * const myNumberArray = [4, 5, 5, 1, 6, 3];\n * primitiveIsDuplicatedInArray(3, myNumberArray); //false\n * primitiveIsDuplicatedInArray(5, myNumberArray); //true\n *\n * const myStringArray = ['z', 'b', 'b', 'a', 'f', 'd'];\n * const isADuplicated = primitiveIsDuplicatedInArray(3, myStringArray); //3은 숫자이므로 TypeScript 오류가 발생합니다.\n */\nexport const primitiveIsDuplicatedInArray = <T>(givenValue: T, arr: T[]) =>\n  arr.filter((value) => value === givenValue).length > 1;\n\n//다른 파일에서 ...\nimport React from \"react\";\nimport { primitiveIsDuplicatedInArray } from \"../utils/reusableFunctions\";\n\nconst GenericFunctions = () => {\n//`primitiveIsDuplicatedInArray`에서 제네릭 유형을 사용하면\n//숫자, 문자열 및 다른 기본 유형을 가진 배열에서 중복 항목을 찾을 수 있습니다.\n  const myNumberArray = [4, 5, 5, 1, 6, 3];\n  const isThreeDuplicated = primitiveIsDuplicatedInArray(3, myNumberArray);\n  const isFiveDuplicated = primitiveIsDuplicatedInArray(5, myNumberArray);\n\n  const myStringArray = [\"z\", \"b\", \"b\", \"a\", \"f\", \"d\"];\n  const isBDuplicated = primitiveIsDuplicatedInArray(\"b\", myStringArray);\n  const isFDuplicated = primitiveIsDuplicatedInArray(\"f\", myStringArray);\n\n  return (\n    <div>\n      <div>내 숫자 배열: {`[${myNumberArray}]`}</div>\n      <div>3이 중복되었나요? {`${isThreeDuplicated}`}</div>\n      <div>5가 중복되었나요? {`${isFiveDuplicated}`}</div>\n      <br />\n      <br />\n      <div>내 문자열 배열: {`[${myStringArray}]`}</div>\n      <div>b가 중복되었나요? {`${isBDuplicated}`}</div>\n      <div>f가 중복되었나요? {`${isFDuplicated}`}</div>\n    </div>\n  );\n};\n\nexport default GenericFunctions;\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 팁 #5: 암시적 타입 및 구조 분해에 의존하기보다 함수 props를 명시적으로 입력하세요\n\n함수와 컴포넌트에 props를 전달하는 방식은 최종적으로 개인의 선택이지만, 명시적 props를 사용하는 것이 동료들이 이해하기 쉽고 유지 보수하기 쉽도록 코드를 만드는 데 도움이 된다고 주장합니다. 기능적인 측면에서 컴포넌트와 함수를 이해하기 쉽게 만들며, 암시적 타입의 한계에서 발생하는 실제 버그를 줄여줍니다.\n\n- 암시적 타입은 함수나 컴포넌트를 검사하는 요구가 있지만, 명시적 타입은 최신 편집기에서 코드 완성을 제공합니다\n- 여러 컴포넌트나 함수에 대한 재사용 가능한 타입을 만들 수 있으며 Partial 및 Omit과 같은 고급 타입을 사용할 수 있게 합니다\n- 여러 파일을 통해 props를 추적하는 것이 훨씬 쉽습니다 (특히 다중 하위 컴포넌트로 prop을 전달하는 경우)\n- 함수와 재사용 가능한 컴포넌트를 문서화하기가 훨씬 더 쉽습니다\n- props에 대한 암시적 타입은 함수로 전달된 props가 잘못된 순서로 전달되거나 prop이 생략될 때 버그를 발생시킵니다\n\n## 예시들\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n/** 예제 1: 컴포넌트에 속성(props) 전달하기 */\nimport React from \"react\";\n\ntype FormStatus = \"saved\" | \"saving\" | \"standby\" | \"error\" | \"unknown\";\n\ntype User = {\n  id: number;\n  firstName?: string;\n  lastName?: string;\n};\n\n/** 예제 A: 속성(props) 구조 분해하기 */\ntype DestructuringProps = {\n  users: User[];\n  formStatus: FormStatus;\n};\n\n// `props`를 그냥 전달하는 것은 특히 재사용되는 고도로 추상화된 컴포넌트에서 prop 추적을 매우 어렵게 만들 수 있습니다. 심지어 타입을 지정해도요\nconst Destructuring = (props: DestructuringProps) => {\n  // 이렇게 구조 분해할 때, 이 prop들은 모두 널이 아니라는 것을 주목하세요\n  const { users, formStatus } = props;\n\n  return (\n    <div>\n      <div>상태: {formStatus}</div>\n      {users.map((user) => (\n        <div key={user.id}>\n          {user.firstName} {user.lastName}\n        </div>\n      ))}\n    </div>\n  );\n};\n\n/** 예제 B: 명시적인 속성(props) */\ntype ExplicitProps = {\n  users: User[];\n  formStatus: FormStatus;\n};\n\n// 속성을 명시적으로 전달하고 타입을 지정하는 것은 추적을 훨씬 간단하게 만듭니다\nconst Explicit = ({ users, formStatus }: ExplicitProps) => {\n  return (\n    <div>\n      <div>상태: {formStatus}</div>\n      {users.map((user) => (\n        <div key={user.id}>\n          {user.firstName} {user.lastName}\n        </div>\n      ))}\n    </div>\n  );\n};\n\nconst DifferentPropTypes = () => {\n  const users = [\n    {\n      id: 1654,\n      firstName: \"Jose\",\n      lastName: \"Sanchez\",\n    },\n    {\n      id: 3297,\n      firstName: \"Bob\",\n      lastName: \"Richards\",\n    },\n    {\n      id: 4572,\n      firstName: \"Janet\",\n      lastName: \"Wong\",\n    },\n  ];\n\n  const formStatus = \"standby\" as FormStatus;\n\n  const props = {\n    users,\n    formStatus,\n  };\n\n// 여기서 `props`가 상위 레벨에서 스프레드 연산자를 통해 전달되었다고 상상해보세요. \n// 최상위 레벨까지 거슬러 올라가지 않고 그 당시의 props가 무엇인지 추적할 수 있을까요?\n  return (\n    <div>\n      <Destructuring {...props} />\n      <br />\n      <br />\n      <Explicit users={users} formStatus={formStatus} />\n      <br />\n      <br />\n    </div>\n  );\n};\n\nexport default DifferentPropTypes;\n```\n\n```js\n/** 예제 2: 함수에 속성(props) 전달하기 */\n\nimport React from \"react\";\n\n// 예제 A: 구조 분해는 사용 방법을 애매하게 만들 수 있습니다\ntype DestructuredProps = {\n  userName: string;\n  userNamesArray: string[];\n};\n\nexport const userNameIsDuplicatedDestructuredProps = (\n  props: DestructuredProps\n) => {\n// 이렇게 구조 분해할 때, 이 prop들은 모두 널이 아니라는 것을 주목하세요\n  const { userName, userNamesArray } = props;\n  return userNamesArray.filter((value) => value === userName).length > 1;\n};\n\n// 예제 B: 암시적인 속성은 전달 순서에 의존하고 타입 완성도가 낮아서 버그를 유발할 수 있습니다\nexport const userNameIsDuplicatedImplicitProps = (\n  userName: string,\n  userNamesArray: string[]\n) => userNamesArray.filter((value) => value === userName).length > 1;\n\n// 예제 C: 명시적 속성은 속성 순서와 타입을 강제화합니다\ntype ExplicitProps = {\n  userName: string;\n  userNamesArray: string[];\n};\n\nexport const userNameIsDuplicatedExplicitProps = ({\n  userName,\n  userNamesArray,\n}: ExplicitProps) =>\n  userNamesArray.filter((value) => value === userName).length > 1;\n\n// 데이터\nexport const TypingFnProps = () => {\n  const users = [\n    {\n      id: 1654,\n      firstName: \"Jose\",\n      lastName: \"Sanchez\",\n    },\n    {\n      id: 3297,\n      firstName: \"Bob\",\n      lastName: \"Richards\",\n    },\n    {\n      id: 4572,\n      firstName: \"Janet\",\n      lastName: \"Wong\",\n    },\n    {\n      id: 8725,\n      firstName: \"Janet\",\n      lastName: \"Wong\",\n    },\n  ];\n\n  const userNamesArray = users.map(\n    ({ firstName, lastName }) => `${firstName} ${lastName}`\n  );\n\n  const props = {\n    userNamesArray,\n    userName: \"Janet Wong\",\n  };\n\n  const isJanetDuplicatedDestructuredProps =\n    userNameIsDuplicatedDestructuredProps(props);\n\n  const isJanetDuplicatedImplicitProps = userNameIsDuplicatedImplicitProps(\n    \"Janet Wong\",\n    userNamesArray\n  );\n\n  const isJanetDuplicatedExplicitProps = userNameIsDuplicatedExplicitProps({\n    userName: \"Janet Wong\",\n    userNamesArray,\n  });\n\n// 이것을 변경해가며 출력과 타입 체크 차이를 관찰해보세요\n  return (\n    <div>\n      <div>Janet이 중복되었나요? {`${isJanetDuplicatedDestructuredProps}`}</div>\n      <br />\n      <br />\n      <div>Janet이 중복되었나요? {`${isJanetDuplicatedImplicitProps}`}</div>\n      <br />\n      <br />\n      <div>Janet이 중복되었나요? {`${isJanetDuplicatedExplicitProps}`}</div>\n    </div>\n  );\n};\n\nexport default TypingFnProps;\n```\n\n안내드린 내용 외에도 TypeScript로 유지보수 가능한 코드를 작성하는 더 많은 팁이 있지만, 이 중에서 저가 일반적으로 사용하는 팁들이었습니다.\n\n전체 소스 코드: [https://github.com/lbd1607/ts-blog](https://github.com/lbd1607/ts-blog)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n행복한 코딩하세요 :)","ogImage":{"url":"/assets/img/2024-07-07-5TypescriptPracticesforImprovedMaintainability_0.png"},"coverImage":"/assets/img/2024-07-07-5TypescriptPracticesforImprovedMaintainability_0.png","tag":["Tech"],"readingTime":20},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-07-07-5TypescriptPracticesforImprovedMaintainability_0.png\" alt=\"이미지\"></p>\n<p>아래의 권장 사항은 Typescript를 사용하여 더 유지보수가 용이한 코드를 만드는 데 도움이 되었던 몇 가지 조언에 대한 것입니다. 이 조언들은 새로운 구성 요소에서 Typescript를 사용하고 기존 페이지에서는 여전히 순수 JavaScript를 사용하는 프런트엔드 코드 베이스에서 특히 유용했습니다. 여러분에게도 조금 도움이 되기를 바랍니다.</p>\n<p>다음 섹션에서는 제가 제공하는 제안의 요약과 각 포인트가 더 유지보수가 용이한 코드를 만드는 데 왜 도움이 되는지에 대한 몇 가지 핵심 요점에 대해 설명한 후, 이러한 조언을 실제로 어떻게 실천할 수 있는지를 보여주는 몇 가지 예제를 제시할 것입니다.</p>\n<h1>팁 #1: 난해한 API 값 해결 및 타입의 힘을 활용하여 이름 변경하기</h1>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>가끔 우리가 작업하는 API는 매우 약어화된 또는 난해한 값 이름을 포함한 데이터 본문을 제공할 수 있습니다. 백엔드와 프론트엔드 사이의 분리 정도에 따라, 이는 코드가 어떤 작업을 수행하고 어떻게 상호 작용해야 하는지 이해하는 데 문제가 될 수 있습니다. 이 문제를 해결하기 위해 API 데이터를 새 객체로 해석하고 더 나은 명명 규칙으로 유형을 지정할 수 있습니다.</p>\n<h2>왜 해야 하나요?</h2>\n<ul>\n<li>다른 사람들과 미래의 자신이 코드를 읽고 이해하기 쉽게 만듭니다.</li>\n<li>사용 사례를 명확히 설명합니다 (특히 난해한 이름을 가진 부울 값의 경우).</li>\n<li>코드와 API 설명서 간을 계속 왔다갔다해야 하거나 과도한 콘솔 로깅을 하지 않아도 됩니다.</li>\n</ul>\n<h2>예시</h2>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// API에서 수신된 데이터</span>\n<span class=\"hljs-comment\">// `f_n`은 `firstName`이 됩니다.</span>\n<span class=\"hljs-comment\">// `l_n`은 `lastName`이 됩니다.</span>\n<span class=\"hljs-comment\">// `users`는 `canEditUsers`가 됩니다.</span>\n<span class=\"hljs-keyword\">const</span> rawUserData = [\n  {\n    <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">1654</span>,\n    <span class=\"hljs-attr\">f_n</span>: <span class=\"hljs-string\">\"Jose\"</span>,\n    <span class=\"hljs-attr\">l_n</span>: <span class=\"hljs-string\">\"Sanchez\"</span>,\n    <span class=\"hljs-attr\">users</span>: <span class=\"hljs-literal\">true</span>,\n  },\n  {\n    <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">3297</span>,\n    <span class=\"hljs-attr\">f_n</span>: <span class=\"hljs-string\">\"Bob\"</span>,\n    <span class=\"hljs-attr\">l_n</span>: <span class=\"hljs-string\">\"Richards\"</span>,\n    <span class=\"hljs-attr\">users</span>: <span class=\"hljs-literal\">false</span>,\n  },\n  {\n    <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">4572</span>,\n    <span class=\"hljs-attr\">f_n</span>: <span class=\"hljs-string\">\"Janet\"</span>,\n    <span class=\"hljs-attr\">l_n</span>: <span class=\"hljs-string\">\"Wong\"</span>,\n    <span class=\"hljs-attr\">users</span>: <span class=\"hljs-literal\">true</span>,\n  },\n];\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">UsersPage</span> = (<span class=\"hljs-params\"></span>) => {\n  <span class=\"hljs-comment\">// 원시 데이터 값을 더 쉽게 사용할 수 있는 키로 해석합니다.</span>\n  <span class=\"hljs-keyword\">const</span> resolvedUserData = rawUserData.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">userData</span>) =></span> ({\n    <span class=\"hljs-attr\">id</span>: userData.<span class=\"hljs-property\">id</span>,\n    <span class=\"hljs-attr\">firstName</span>: userData.<span class=\"hljs-property\">f_n</span> ?? <span class=\"hljs-string\">\"\"</span>,\n    <span class=\"hljs-attr\">lastName</span>: userData.<span class=\"hljs-property\">l_n</span> ?? <span class=\"hljs-string\">\"\"</span>,\n    <span class=\"hljs-attr\">canEditUsers</span>: <span class=\"hljs-title class_\">Boolean</span>(userData.<span class=\"hljs-property\">users</span>),\n  })) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">Users</span>[];\n\n  <span class=\"hljs-comment\">// 해석된 데이터로 UsersList를 렌더링합니다.</span>\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">UsersList</span> <span class=\"hljs-attr\">users</span>=<span class=\"hljs-string\">{resolvedUserData}</span> /></span></span>;\n};\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">UsersPage</span>;\n\n<span class=\"hljs-comment\">// 다른 파일에서...</span>\n\n<span class=\"hljs-comment\">// API에서 원시 키 이름을 알려주는 JSDoc을 추가했음에 주목하세요.</span>\n<span class=\"hljs-comment\">// GraphQL 또는 Prisma와 같은 프론트엔드와 API 사이의 레이어가 있는 경우 특히 중요합니다.</span>\n<span class=\"hljs-comment\">/**\n * <span class=\"hljs-doctag\">@type</span> firstName: Raw `f_n`\n * <span class=\"hljs-doctag\">@type</span> lastName: Raw `l_n`\n * <span class=\"hljs-doctag\">@type</span> canEditUsers: Raw `users`\n */</span>\ntype <span class=\"hljs-title class_\">Users</span> = {\n  <span class=\"hljs-attr\">id</span>: number;\n  <span class=\"hljs-attr\">firstName</span>: string; <span class=\"hljs-comment\">// 원시: f_n</span>\n  <span class=\"hljs-attr\">lastName</span>: string; <span class=\"hljs-comment\">// 원시: l_n</span>\n  <span class=\"hljs-attr\">canEditUsers</span>: boolean; <span class=\"hljs-comment\">// 원시: users</span>\n};\n\n<span class=\"hljs-comment\">// 원시 API 키와 비교했을 때 가독성이 향상되는 점에 주목하세요.</span>\n<span class=\"hljs-comment\">// UsersList 구성 요소가 부모로부터 추상화되고 입력을 사용하여 사용자 데이터를 업데이트하기 시작할 때</span>\n<span class=\"hljs-comment\">// 이 사항은 점점 더 중요해집니다.</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">UsersList</span> = (<span class=\"hljs-params\">{ users }: { users: Users[] }</span>) => {\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>\n      {users.map((user) => (\n        <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">{user.id}</span>></span>\n          <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>\n            이름: {user.firstName} {user.lastName}\n          <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n          <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>사용자 수정 가능? {`${user.canEditUsers}`}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n          <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">br</span> /></span>\n          <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">br</span> /></span>\n        <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n      ))}\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n  );\n};\n</code></pre>\n<h1>팁 #2: 모든 하드코딩된 문자열 값을 enum, object 또는 string 리터럴 유니온으로 대체하세요 (사용 사례에 따라 다름)</h1>\n<p>기능을 처음 구현할 때는 단순한 로직을 수행하기 위해 문자열 값과 같은 기본 유형을 하드코딩하는 것이 더 쉬울 수 있습니다.\n그러나 코드베이스가 커지고 여러 컴포넌트로 분할되면, 이는 많은 중복을 야기하고 유지 관리의 어려움을 증가시킬 수 있습니다.\n이 문제를 해결하기 위해 이러한 분산된 하드코딩된 문자열을 재사용 가능한 enum, object 또는 유니언으로 통합할 수 있습니다.</p>\n<h2>왜 이렇게 해야 하나요?</h2>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>코드 완성 기능을 사용하여 유형을 사용할 수 있게 해서 더 많이 추측할 필요가 없도록 합니다</li>\n<li>구성 요소를 더 재사용 가능하게 만듭니다</li>\n<li>리듀서와 컨텍스트 또는 상태 관리자와 유형을 사용하는 것을 더 간단하게 만듭니다</li>\n<li>서로 다른 함수와 구성 요소 사이에서 상태를 전달하는 것을 간단하게 만듭니다</li>\n<li>잘못된 입력 및 유형을 검출하는 데 도움이 됩니다</li>\n<li>기본값으로 사용할 \"unknown\"과 같은 예외 유형을 추가할 수 있도록 합니다</li>\n</ul>\n<h2>예시</h2>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">/** \n* 예시 1: 열거형\n* 사용 시기:이 것을 사용할 모든 파일이 ts인 경우\n* 장점: 변경할 수 없는 상수\n  더 나은 형식 안전성, 유형으로 더 쉽게 작업할 수 있음\n  사용자 정의 로직에 대한 switch 케이스 사용이 쉬움\n* 단점: 바닐라 js와 사용할 수 없음\n*/</span>\nenum <span class=\"hljs-title class_\">Fruits</span> {\n  <span class=\"hljs-variable constant_\">APPLE</span> = <span class=\"hljs-string\">\"Apple\"</span>,\n  <span class=\"hljs-variable constant_\">ORANGE</span> = <span class=\"hljs-string\">\"Orange\"</span>,\n  <span class=\"hljs-variable constant_\">BANANA</span> = <span class=\"hljs-string\">\"Banana\"</span>,\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">FruitsFromEnumDropdown</span> = (<span class=\"hljs-params\"></span>) => {\n  type <span class=\"hljs-title class_\">FruitOptionsFromEnum</span> = {\n    <span class=\"hljs-attr\">label</span>: <span class=\"hljs-title class_\">Fruits</span>;\n    <span class=\"hljs-attr\">value</span>: keyof <span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-title class_\">Fruits</span>;\n  };\n\n  <span class=\"hljs-keyword\">const</span> fruitOptions = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">entries</span>(<span class=\"hljs-title class_\">Fruits</span>).<span class=\"hljs-title function_\">map</span>(\n    <span class=\"hljs-function\">(<span class=\"hljs-params\">[value, label]</span>) =></span>\n      ({\n        <span class=\"hljs-attr\">label</span>: label,\n        <span class=\"hljs-attr\">value</span>: value,\n      } <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">FruitOptionsFromEnum</span>)\n  );\n\n  <span class=\"hljs-keyword\">const</span> [selectedFruit, setSelectedFruit] = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">useState</span>(\n    fruitOptions[<span class=\"hljs-number\">0</span>].<span class=\"hljs-property\">value</span>\n  );\n\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">onSelectFruit</span> = (<span class=\"hljs-params\">selectedFruit: FruitOptionsFromEnum[<span class=\"hljs-string\">\"value\"</span>]</span>) => {\n    <span class=\"hljs-keyword\">const</span> selectedOption = fruitOptions.<span class=\"hljs-title function_\">find</span>(\n      <span class=\"hljs-function\">(<span class=\"hljs-params\">fruit</span>) =></span> fruit.<span class=\"hljs-property\">value</span> === selectedFruit\n    );\n    <span class=\"hljs-keyword\">if</span> (selectedOption) {\n      <span class=\"hljs-title function_\">setSelectedFruit</span>(selectedOption?.<span class=\"hljs-property\">value</span>);\n    }\n  };\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>열거형에서 선택한 과일 : {selectedFruit}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">select</span>\n        <span class=\"hljs-attr\">onChange</span>=<span class=\"hljs-string\">{(e)</span> =></span>\n          onSelectFruit(e.target.value as FruitOptionsFromEnum[\"value\"])\n        }\n      >\n        {fruitOptions.map((fruit) => (\n          <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">{fruit.value}</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">{fruit.value}</span>></span>\n            {fruit.label}\n          <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">option</span>></span>\n        ))}\n      <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">select</span>></span>\n    <span class=\"hljs-tag\">&#x3C;/></span></span>\n  );\n};\n\n<span class=\"hljs-comment\">/**\n* 예시 2: 객체 사용하기\n* 사용 시기: 코드 베이스의 일부가 아직 바닐라 js를 사용하는 경우\n* 장점: 복사하거나 'let' 및 'as const'가 아닌 경우 할당 가능\n  ts 및 js 파일 간에 사용 가능\n* 단점: enums보다 유형을 사용하기 어려울 수 있음, 'as const'조차도\n*/</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">FruitsObject</span> = {\n  <span class=\"hljs-attr\">APPLE</span>: <span class=\"hljs-string\">\"Apple\"</span>,\n  <span class=\"hljs-attr\">ORANGE</span>: <span class=\"hljs-string\">\"Orange\"</span>,\n  <span class=\"hljs-attr\">BANANA</span>: <span class=\"hljs-string\">\"Banana\"</span>,\n} <span class=\"hljs-keyword\">as</span> <span class=\"hljs-keyword\">const</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">FruitsFromObjectDropdown</span> = (<span class=\"hljs-params\"></span>) => {\n  type <span class=\"hljs-title class_\">FruitOptionsFromObject</span> = {\n    <span class=\"hljs-attr\">label</span>: (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-title class_\">FruitsObject</span>)[keyof <span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-title class_\">FruitsObject</span>];\n    <span class=\"hljs-attr\">value</span>: keyof <span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-title class_\">FruitsObject</span>;\n  };\n\n  <span class=\"hljs-keyword\">const</span> fruitOptions = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">entries</span>(<span class=\"hljs-title class_\">FruitsObject</span>).<span class=\"hljs-title function_\">map</span>(\n    <span class=\"hljs-function\">(<span class=\"hljs-params\">[v, k]</span>) =></span>\n      ({\n        <span class=\"hljs-attr\">label</span>: k,\n        <span class=\"hljs-attr\">value</span>: v,\n      } <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">FruitOptionsFromObject</span>)\n  );\n\n  <span class=\"hljs-keyword\">const</span> [selectedFruit, setSelectedFruit] = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">useState</span>(\n    fruitOptions[<span class=\"hljs-number\">0</span>].<span class=\"hljs-property\">value</span>\n  );\n\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">onSelectFruit</span> = (<span class=\"hljs-params\">selectedFruit: FruitOptionsFromObject[<span class=\"hljs-string\">\"value\"</span>]</span>) => {\n    <span class=\"hljs-keyword\">const</span> selectedOption = fruitOptions.<span class=\"hljs-title function_\">find</span>(\n      <span class=\"hljs-function\">(<span class=\"hljs-params\">fruit</span>) =></span> fruit.<span class=\"hljs-property\">value</span> === selectedFruit\n    );\n    <span class=\"hljs-keyword\">if</span> (selectedOption) {\n      <span class=\"hljs-title function_\">setSelectedFruit</span>(selectedOption?.<span class=\"hljs-property\">value</span>);\n    }\n  };\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>객체에서 선택한 과일 : {selectedFruit}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">select</span>\n        <span class=\"hljs-attr\">onChange</span>=<span class=\"hljs-string\">{(e)</span> =></span>\n          onSelectFruit(e.target.value as FruitOptionsFromObject[\"value\"])\n        }\n      >\n        {fruitOptions.map((fruit) => (\n          <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">{fruit.value}</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">{fruit.value}</span>></span>\n            {fruit.label}\n          <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">option</span>></span>\n        ))}\n      <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">select</span>></span>\n    <span class=\"hljs-tag\">&#x3C;/></span></span>\n  );\n};\n\n<span class=\"hljs-comment\">/**\n* 예시 3: 문자열 유니언\n* 사용 시기: 백엔드에서 유형을 확장해야하거나 대안으로 enums를 대체해야할 때\n* 장점: 쉽게 확장 가능\n  ts 및 js 간에 재사용 가능\n  사용자 정의 로직에 대한 switch 케이스 사용이 쉬움\n* 단점: enums와 같이 할당할 수 없으며, 문자열은 순수한 리터럴임\n*/</span>\ntype <span class=\"hljs-title class_\">StatusStringUnion</span> = <span class=\"hljs-string\">\"saved\"</span> | <span class=\"hljs-string\">\"saving\"</span> | <span class=\"hljs-string\">\"standby\"</span> | <span class=\"hljs-string\">\"error\"</span> | <span class=\"hljs-string\">\"unknown\"</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">FormStatus</span> = (<span class=\"hljs-params\"></span>) => {\n  <span class=\"hljs-keyword\">const</span> [currentStatus, setCurrentStatus] =\n    <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-property\">useState</span>&#x3C;<span class=\"hljs-title class_\">StatusStringUnion</span>>(<span class=\"hljs-string\">\"unknown\"</span>);\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">StatusRow</span>></span>\n      상태: <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Label</span>></span>{currentStatus}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">Label</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Dot</span> <span class=\"hljs-attr\">status</span>=<span class=\"hljs-string\">{currentStatus}</span> /></span>\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">StatusRow</span>></span></span>\n  );\n};\n\n<span class=\"hljs-comment\">//다른 파일에서는 ...</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">StatusRow</span> = styled.<span class=\"hljs-property\">div</span><span class=\"hljs-string\">`\n  display: flex;\n  justify-content: center;\n  align-content: center;\n`</span>;\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Label</span> = styled.<span class=\"hljs-property\">div</span><span class=\"hljs-string\">`\n  margin-left: 0.25rem;\n  font-size: 12pt;\n  font-weight: 600;\n`</span>;\n\n<span class=\"hljs-comment\">//사용자 정의 StyledComponents 로직 사용 예시</span>\n<span class=\"hljs-comment\">//enum 또는 문자열 유니언은 이러한 경우에 가장 적합합니다</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Dot</span> = styled.<span class=\"hljs-property\">div</span>&#x3C;{ <span class=\"hljs-attr\">status</span>: <span class=\"hljs-title class_\">StatusStringUnion</span> }><span class=\"hljs-string\">`\n  display: flex;\n  justify-content: center;\n  align-content: start;\n  clip-path: circle(5px);\n  width: 1rem;\n  background: <span class=\"hljs-subst\">${({ status }) => {\n    <span class=\"hljs-keyword\">switch</span> (status) {\n      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"saved\"</span>:\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"green\"</span>;\n      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"saving\"</span>:\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"yellow\"</span>;\n      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"error\"</span>:\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"red\"</span>;\n      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"standby\"</span>:\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"none\"</span>;\n      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"unknown\"</span>:\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"gray\"</span>;\n      <span class=\"hljs-keyword\">default</span>:\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"gray\"</span>;\n    }\n  };\n  margin-left: <span class=\"hljs-number\">0.</span>25rem;\n<span class=\"hljs-string\">`;\n\n\n\n&#x3C;!-- TIL 수평 -->\n&#x3C;ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\">&#x3C;/ins>\n&#x3C;script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n&#x3C;/script>\n\n내가 작업한 많은 코드에서, 유형은 일반적으로 변경할 수 없는 값을 나타내는 비-nullable로 기본 설정됩니다. 그러나 값은 때로 바뀔 수 있고, 앱의 내부 논리 구조가 복잡해지면 예기치 않은 null 또는 undefined 값이 발생하여 프로덕션 코드에서 유형 오류를 발생시키기 쉬워집니다. 이를 피하는 한 가지 방법은 다른 방향으로 기본값을 nullable 값으로 설정하는 것입니다. 기본적으로, 이 값이 어떤 상황에서 null 또는 undefined가 될 수 있는 경우(또는 확실하지 않은 경우), 선택 사항 유형으로 만드는 것입니다.\n\n## 이유\n\n- 백엔드와 프론트엔드가 강하게 결합되어 있지 않은 경우(즉, 풀스택 개발자가 아닌 경우), 두 계약 사이의 값 유형이 제대로 문서화되지 않을 수 있음\n- 데이터베이스가 커지고 복잡해지면 예상치 못한 값(예: null 및 undefined)이 부정적으로 발생할 확률이 높아집니다\n- 앱이 사용자 입력을 수락하는 경우, 프론트엔드와 백엔드의 유효성 검사 엣지 케이스가 데이터베이스에 이상한 값이 저장되도록 할 수 있음\n- 나중에 요구 사항이 변경되어 null/undefined 값을 허용하는 경우가 생길 수 있음\n- null/undefined이면 명시적으로 기본값을 설정할 수 있어, 문자열이 항상 \" \"와 같은 문자열이 되도록 보장할 수 있음\n- 입력 값에 일부 값을 필수로 만들면, 유효성 검사의 추가 계층을 추가하고 부정적인 값이 백엔드로 전송되지 않도록 보장할 수 있음\n\n## 예시\n\n&#x3C;!-- TIL 수평 -->\n&#x3C;ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\">&#x3C;/ins>\n&#x3C;script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n&#x3C;/script>\n\n/**\n * @type firstName: Raw `</span>f_n<span class=\"hljs-string\">`\n * @type lastName: Raw `</span>l_n<span class=\"hljs-string\">`\n * @type canEditUsers: Raw `</span>users<span class=\"hljs-string\">`\n */\ntype Users = {\n  id: number;\n  firstName?: string; //Raw: f_n\n  lastName?: string; //Raw: l_n\n  canEditUsers?: boolean; //Raw: users\n};\n\n//만약 아래의 사용자(user)를 접근하려고 할 때 값 중 하나라도 null이 허용되지 않는\n//즉, 필수값이면 타입 오류를 발생시키고 렌더를 충돌시킬 수 있습니다.\n//이는 널 병합 연산자를 사용할 수 있게 하여 Typescript가\n//해당 사용법을 강제하는 것을 가능하게 합니다.\nconst UsersList = ({ users }: { users: Users[] }) => {\n  return (\n    &#x3C;div>\n      {users.map((user) => (\n        &#x3C;div key={user.id}>\n          &#x3C;div>\n            Name: {user?.firstName} {user?.lastName}\n          &#x3C;/div>\n          &#x3C;div>Can edit users? {`</span>${user?.canEditUsers}<span class=\"hljs-string\">`}&#x3C;/div>\n          &#x3C;br />\n          &#x3C;br />\n        &#x3C;/div>\n      ))}\n    &#x3C;/div>\n  );\n};\n\n# 팁 #4: 일반적으로 재사용되는 유형을 제네릭을 사용하여 유틸 파일에 저장하기\n\n코드 베이스가 커지면 앱 전반에서 유사한 유형을 재사용해야 할 수 있습니다. 가장 일반적으로 재사용되는 유형을 제네릭의 힘을 이용하여 더 재사용할 수 있게 할 수 있으며, 이는 기본 유형이 완벽하게 일치하지 않을 때도 유형이 여러 컨텍스트에서 재사용될 수 있음을 의미합니다. 이러한 접근 방식을 사용하면 재사용 가능한 유틸 함수가 Typescript의 모든 기능을 최대한 활용할 수 있음을 의미합니다.\n\n## 왜 이것을 하는가\n</span></span></span></code></pre>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>수동으로 모든 사용법을 입력할 필요가 없다는 것을 의미합니다.</li>\n<li>한 곳에서 유형을 업데이트하는 것이 더 쉽습니다.</li>\n<li>재사용 가능하고 매우 복잡한 유형을 만들 수 있습니다.</li>\n<li>코드 베이스의 라이브러리에서 기초로 하는 유형을 만들 수 있습니다(예: Relay).</li>\n<li>해당 유형을 사용하는 구성 요소를 지저분하게 만들지 않고 찾기, 문서화, 사용하기가 더 쉽습니다.</li>\n</ul>\n<h2>예시</h2>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">/** Example 1: 제네릭을 사용한 재사용 가능한 유형 */</span>\n<span class=\"hljs-comment\">// `utils/reusableTypes.ts` 파일 내에서</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react\"</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Disposable</span>, <span class=\"hljs-title class_\">UseMutationConfig</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react-relay\"</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">MutationParameters</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"relay-runtime\"</span>;\n\n<span class=\"hljs-comment\">/**\n * <span class=\"hljs-doctag\">@description</span> 주어진 유형에서 값을 가져오는 유형\n * <span class=\"hljs-doctag\">@example</span> {<span class=\"hljs-type\"> fieldName: FormProps, value: ValueOf&#x3C;FormProps> </span>}\n */</span>\n<span class=\"hljs-keyword\">export</span> type <span class=\"hljs-title class_\">ValueOf</span>&#x3C;T> = T[keyof T];\n\n<span class=\"hljs-comment\">/**\n * <span class=\"hljs-doctag\">@description</span> Relay 변경 사항으로부터 유형 만들기\n * <span class=\"hljs-doctag\">@example</span> type UserContextTypes = {\n *   createUser: MutationTypeOf&#x3C;createUserMutation>\n * }\n */</span>\n<span class=\"hljs-keyword\">export</span> type <span class=\"hljs-title class_\">MutationTypeOf</span>&#x3C;T <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">MutationParameters</span>> = <span class=\"hljs-function\">(<span class=\"hljs-params\">\n  config: UseMutationConfig&#x3C;T>\n</span>) =></span> <span class=\"hljs-title class_\">Disposable</span>;\n\n<span class=\"hljs-comment\">//다른 파일에서 ...</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react\"</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">ValueOf</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"../utils/reusableTypes\"</span>;\n\nenum <span class=\"hljs-title class_\">Fruits</span> {\n  <span class=\"hljs-variable constant_\">APPLE</span> = <span class=\"hljs-string\">\"Apple\"</span>,\n  <span class=\"hljs-variable constant_\">ORANGE</span> = <span class=\"hljs-string\">\"Orange\"</span>,\n  <span class=\"hljs-variable constant_\">BANANA</span> = <span class=\"hljs-string\">\"Banana\"</span>,\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">GenericFruitsFromEnumDropdown</span> = (<span class=\"hljs-params\"></span>) => {\n  <span class=\"hljs-keyword\">const</span> fruitOptions = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">entries</span>(<span class=\"hljs-title class_\">Fruits</span>).<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">[value, label]</span>) =></span> ({\n    <span class=\"hljs-attr\">label</span>: label,\n    <span class=\"hljs-attr\">value</span>: value,\n  }));\n\n  <span class=\"hljs-keyword\">const</span> [selectedFruit, setSelectedFruit] = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">useState</span>(\n    fruitOptions[<span class=\"hljs-number\">0</span>].<span class=\"hljs-property\">value</span>\n  );\n\n<span class=\"hljs-comment\">//거의 모든 다른 데이터 유형과 함께`ValueOf`의 제네릭 유형을 사용할 수 있습니다.</span>\n<span class=\"hljs-comment\">//단, Fruits 열거형을 포함한다.</span>\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">onSelectFruit</span> = (<span class=\"hljs-params\">selectedFruit: ValueOf&#x3C;Fruits></span>) => {\n    <span class=\"hljs-keyword\">const</span> selectedOption = fruitOptions.<span class=\"hljs-title function_\">find</span>(\n      <span class=\"hljs-function\">(<span class=\"hljs-params\">fruit</span>) =></span> fruit.<span class=\"hljs-property\">value</span> === selectedFruit\n    );\n    <span class=\"hljs-keyword\">if</span> (selectedOption) {\n      <span class=\"hljs-title function_\">setSelectedFruit</span>(selectedOption?.<span class=\"hljs-property\">value</span>);\n    }\n  };\n\n  <span class=\"hljs-comment\">//ValueOf를 사용하면 열거형 값과의 비교를 수행할 수 있습니다.</span>\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(selectedFruit === <span class=\"hljs-title class_\">Fruits</span>.<span class=\"hljs-property\">APPLE</span>);\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>선택된 열거형 과일: {selectedFruit}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">select</span> <span class=\"hljs-attr\">onChange</span>=<span class=\"hljs-string\">{(e)</span> =></span> onSelectFruit(e.target.value)}>\n        {fruitOptions.map((fruit) => (\n          <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">{fruit.value}</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">{fruit.value}</span>></span>\n            {fruit.label}\n          <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">option</span>></span>\n        ))}\n      <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">select</span>></span>\n    <span class=\"hljs-tag\">&#x3C;/></span></span>\n  );\n};\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">/** Example 2: 제네릭을 사용한 재사용 가능한 함수 */</span>\n<span class=\"hljs-comment\">// `utils/reusableFunctions.ts` 파일 내에서</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react\"</span>;\n\n<span class=\"hljs-comment\">/**\n * <span class=\"hljs-doctag\">@description</span> 주어진 기본 값이 배열에서 중복되는지 여부를 확인합니다.\n * <span class=\"hljs-doctag\">@example</span>\n * const myNumberArray = [4, 5, 5, 1, 6, 3];\n * primitiveIsDuplicatedInArray(3, myNumberArray); //false\n * primitiveIsDuplicatedInArray(5, myNumberArray); //true\n *\n * const myStringArray = ['z', 'b', 'b', 'a', 'f', 'd'];\n * const isADuplicated = primitiveIsDuplicatedInArray(3, myStringArray); //3은 숫자이므로 TypeScript 오류가 발생합니다.\n */</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> primitiveIsDuplicatedInArray = &#x3C;T><span class=\"hljs-function\">(<span class=\"hljs-params\">givenValue: T, arr: T[]</span>) =></span>\n  arr.<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">value</span>) =></span> value === givenValue).<span class=\"hljs-property\">length</span> > <span class=\"hljs-number\">1</span>;\n\n<span class=\"hljs-comment\">//다른 파일에서 ...</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react\"</span>;\n<span class=\"hljs-keyword\">import</span> { primitiveIsDuplicatedInArray } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"../utils/reusableFunctions\"</span>;\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">GenericFunctions</span> = (<span class=\"hljs-params\"></span>) => {\n<span class=\"hljs-comment\">//`primitiveIsDuplicatedInArray`에서 제네릭 유형을 사용하면</span>\n<span class=\"hljs-comment\">//숫자, 문자열 및 다른 기본 유형을 가진 배열에서 중복 항목을 찾을 수 있습니다.</span>\n  <span class=\"hljs-keyword\">const</span> myNumberArray = [<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">3</span>];\n  <span class=\"hljs-keyword\">const</span> isThreeDuplicated = <span class=\"hljs-title function_\">primitiveIsDuplicatedInArray</span>(<span class=\"hljs-number\">3</span>, myNumberArray);\n  <span class=\"hljs-keyword\">const</span> isFiveDuplicated = <span class=\"hljs-title function_\">primitiveIsDuplicatedInArray</span>(<span class=\"hljs-number\">5</span>, myNumberArray);\n\n  <span class=\"hljs-keyword\">const</span> myStringArray = [<span class=\"hljs-string\">\"z\"</span>, <span class=\"hljs-string\">\"b\"</span>, <span class=\"hljs-string\">\"b\"</span>, <span class=\"hljs-string\">\"a\"</span>, <span class=\"hljs-string\">\"f\"</span>, <span class=\"hljs-string\">\"d\"</span>];\n  <span class=\"hljs-keyword\">const</span> isBDuplicated = <span class=\"hljs-title function_\">primitiveIsDuplicatedInArray</span>(<span class=\"hljs-string\">\"b\"</span>, myStringArray);\n  <span class=\"hljs-keyword\">const</span> isFDuplicated = <span class=\"hljs-title function_\">primitiveIsDuplicatedInArray</span>(<span class=\"hljs-string\">\"f\"</span>, myStringArray);\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>내 숫자 배열: {`[${myNumberArray}]`}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>3이 중복되었나요? {`${isThreeDuplicated}`}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>5가 중복되었나요? {`${isFiveDuplicated}`}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">br</span> /></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">br</span> /></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>내 문자열 배열: {`[${myStringArray}]`}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>b가 중복되었나요? {`${isBDuplicated}`}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>f가 중복되었나요? {`${isFDuplicated}`}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n  );\n};\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">GenericFunctions</span>;\n</code></pre>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h1>팁 #5: 암시적 타입 및 구조 분해에 의존하기보다 함수 props를 명시적으로 입력하세요</h1>\n<p>함수와 컴포넌트에 props를 전달하는 방식은 최종적으로 개인의 선택이지만, 명시적 props를 사용하는 것이 동료들이 이해하기 쉽고 유지 보수하기 쉽도록 코드를 만드는 데 도움이 된다고 주장합니다. 기능적인 측면에서 컴포넌트와 함수를 이해하기 쉽게 만들며, 암시적 타입의 한계에서 발생하는 실제 버그를 줄여줍니다.</p>\n<ul>\n<li>암시적 타입은 함수나 컴포넌트를 검사하는 요구가 있지만, 명시적 타입은 최신 편집기에서 코드 완성을 제공합니다</li>\n<li>여러 컴포넌트나 함수에 대한 재사용 가능한 타입을 만들 수 있으며 Partial 및 Omit과 같은 고급 타입을 사용할 수 있게 합니다</li>\n<li>여러 파일을 통해 props를 추적하는 것이 훨씬 쉽습니다 (특히 다중 하위 컴포넌트로 prop을 전달하는 경우)</li>\n<li>함수와 재사용 가능한 컴포넌트를 문서화하기가 훨씬 더 쉽습니다</li>\n<li>props에 대한 암시적 타입은 함수로 전달된 props가 잘못된 순서로 전달되거나 prop이 생략될 때 버그를 발생시킵니다</li>\n</ul>\n<h2>예시들</h2>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">/** 예제 1: 컴포넌트에 속성(props) 전달하기 */</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react\"</span>;\n\ntype <span class=\"hljs-title class_\">FormStatus</span> = <span class=\"hljs-string\">\"saved\"</span> | <span class=\"hljs-string\">\"saving\"</span> | <span class=\"hljs-string\">\"standby\"</span> | <span class=\"hljs-string\">\"error\"</span> | <span class=\"hljs-string\">\"unknown\"</span>;\n\ntype <span class=\"hljs-title class_\">User</span> = {\n  <span class=\"hljs-attr\">id</span>: number;\n  firstName?: string;\n  lastName?: string;\n};\n\n<span class=\"hljs-comment\">/** 예제 A: 속성(props) 구조 분해하기 */</span>\ntype <span class=\"hljs-title class_\">DestructuringProps</span> = {\n  <span class=\"hljs-attr\">users</span>: <span class=\"hljs-title class_\">User</span>[];\n  <span class=\"hljs-attr\">formStatus</span>: <span class=\"hljs-title class_\">FormStatus</span>;\n};\n\n<span class=\"hljs-comment\">// `props`를 그냥 전달하는 것은 특히 재사용되는 고도로 추상화된 컴포넌트에서 prop 추적을 매우 어렵게 만들 수 있습니다. 심지어 타입을 지정해도요</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Destructuring</span> = (<span class=\"hljs-params\">props: DestructuringProps</span>) => {\n  <span class=\"hljs-comment\">// 이렇게 구조 분해할 때, 이 prop들은 모두 널이 아니라는 것을 주목하세요</span>\n  <span class=\"hljs-keyword\">const</span> { users, formStatus } = props;\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>상태: {formStatus}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n      {users.map((user) => (\n        <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">{user.id}</span>></span>\n          {user.firstName} {user.lastName}\n        <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n      ))}\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n  );\n};\n\n<span class=\"hljs-comment\">/** 예제 B: 명시적인 속성(props) */</span>\ntype <span class=\"hljs-title class_\">ExplicitProps</span> = {\n  <span class=\"hljs-attr\">users</span>: <span class=\"hljs-title class_\">User</span>[];\n  <span class=\"hljs-attr\">formStatus</span>: <span class=\"hljs-title class_\">FormStatus</span>;\n};\n\n<span class=\"hljs-comment\">// 속성을 명시적으로 전달하고 타입을 지정하는 것은 추적을 훨씬 간단하게 만듭니다</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Explicit</span> = (<span class=\"hljs-params\">{ users, formStatus }: ExplicitProps</span>) => {\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>상태: {formStatus}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n      {users.map((user) => (\n        <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">{user.id}</span>></span>\n          {user.firstName} {user.lastName}\n        <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n      ))}\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n  );\n};\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">DifferentPropTypes</span> = (<span class=\"hljs-params\"></span>) => {\n  <span class=\"hljs-keyword\">const</span> users = [\n    {\n      <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">1654</span>,\n      <span class=\"hljs-attr\">firstName</span>: <span class=\"hljs-string\">\"Jose\"</span>,\n      <span class=\"hljs-attr\">lastName</span>: <span class=\"hljs-string\">\"Sanchez\"</span>,\n    },\n    {\n      <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">3297</span>,\n      <span class=\"hljs-attr\">firstName</span>: <span class=\"hljs-string\">\"Bob\"</span>,\n      <span class=\"hljs-attr\">lastName</span>: <span class=\"hljs-string\">\"Richards\"</span>,\n    },\n    {\n      <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">4572</span>,\n      <span class=\"hljs-attr\">firstName</span>: <span class=\"hljs-string\">\"Janet\"</span>,\n      <span class=\"hljs-attr\">lastName</span>: <span class=\"hljs-string\">\"Wong\"</span>,\n    },\n  ];\n\n  <span class=\"hljs-keyword\">const</span> formStatus = <span class=\"hljs-string\">\"standby\"</span> <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">FormStatus</span>;\n\n  <span class=\"hljs-keyword\">const</span> props = {\n    users,\n    formStatus,\n  };\n\n<span class=\"hljs-comment\">// 여기서 `props`가 상위 레벨에서 스프레드 연산자를 통해 전달되었다고 상상해보세요. </span>\n<span class=\"hljs-comment\">// 최상위 레벨까지 거슬러 올라가지 않고 그 당시의 props가 무엇인지 추적할 수 있을까요?</span>\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Destructuring</span> {<span class=\"hljs-attr\">...props</span>} /></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">br</span> /></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">br</span> /></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Explicit</span> <span class=\"hljs-attr\">users</span>=<span class=\"hljs-string\">{users}</span> <span class=\"hljs-attr\">formStatus</span>=<span class=\"hljs-string\">{formStatus}</span> /></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">br</span> /></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">br</span> /></span>\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n  );\n};\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">DifferentPropTypes</span>;\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">/** 예제 2: 함수에 속성(props) 전달하기 */</span>\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react\"</span>;\n\n<span class=\"hljs-comment\">// 예제 A: 구조 분해는 사용 방법을 애매하게 만들 수 있습니다</span>\ntype <span class=\"hljs-title class_\">DestructuredProps</span> = {\n  <span class=\"hljs-attr\">userName</span>: string;\n  <span class=\"hljs-attr\">userNamesArray</span>: string[];\n};\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">userNameIsDuplicatedDestructuredProps</span> = (<span class=\"hljs-params\">\n  props: DestructuredProps\n</span>) => {\n<span class=\"hljs-comment\">// 이렇게 구조 분해할 때, 이 prop들은 모두 널이 아니라는 것을 주목하세요</span>\n  <span class=\"hljs-keyword\">const</span> { userName, userNamesArray } = props;\n  <span class=\"hljs-keyword\">return</span> userNamesArray.<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">value</span>) =></span> value === userName).<span class=\"hljs-property\">length</span> > <span class=\"hljs-number\">1</span>;\n};\n\n<span class=\"hljs-comment\">// 예제 B: 암시적인 속성은 전달 순서에 의존하고 타입 완성도가 낮아서 버그를 유발할 수 있습니다</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">userNameIsDuplicatedImplicitProps</span> = (<span class=\"hljs-params\">\n  userName: string,\n  userNamesArray: string[]\n</span>) => userNamesArray.<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">value</span>) =></span> value === userName).<span class=\"hljs-property\">length</span> > <span class=\"hljs-number\">1</span>;\n\n<span class=\"hljs-comment\">// 예제 C: 명시적 속성은 속성 순서와 타입을 강제화합니다</span>\ntype <span class=\"hljs-title class_\">ExplicitProps</span> = {\n  <span class=\"hljs-attr\">userName</span>: string;\n  <span class=\"hljs-attr\">userNamesArray</span>: string[];\n};\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">userNameIsDuplicatedExplicitProps</span> = (<span class=\"hljs-params\">{\n  userName,\n  userNamesArray,\n}: ExplicitProps</span>) =>\n  userNamesArray.<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">value</span>) =></span> value === userName).<span class=\"hljs-property\">length</span> > <span class=\"hljs-number\">1</span>;\n\n<span class=\"hljs-comment\">// 데이터</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">TypingFnProps</span> = (<span class=\"hljs-params\"></span>) => {\n  <span class=\"hljs-keyword\">const</span> users = [\n    {\n      <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">1654</span>,\n      <span class=\"hljs-attr\">firstName</span>: <span class=\"hljs-string\">\"Jose\"</span>,\n      <span class=\"hljs-attr\">lastName</span>: <span class=\"hljs-string\">\"Sanchez\"</span>,\n    },\n    {\n      <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">3297</span>,\n      <span class=\"hljs-attr\">firstName</span>: <span class=\"hljs-string\">\"Bob\"</span>,\n      <span class=\"hljs-attr\">lastName</span>: <span class=\"hljs-string\">\"Richards\"</span>,\n    },\n    {\n      <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">4572</span>,\n      <span class=\"hljs-attr\">firstName</span>: <span class=\"hljs-string\">\"Janet\"</span>,\n      <span class=\"hljs-attr\">lastName</span>: <span class=\"hljs-string\">\"Wong\"</span>,\n    },\n    {\n      <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">8725</span>,\n      <span class=\"hljs-attr\">firstName</span>: <span class=\"hljs-string\">\"Janet\"</span>,\n      <span class=\"hljs-attr\">lastName</span>: <span class=\"hljs-string\">\"Wong\"</span>,\n    },\n  ];\n\n  <span class=\"hljs-keyword\">const</span> userNamesArray = users.<span class=\"hljs-title function_\">map</span>(\n    <span class=\"hljs-function\">(<span class=\"hljs-params\">{ firstName, lastName }</span>) =></span> <span class=\"hljs-string\">`<span class=\"hljs-subst\">${firstName}</span> <span class=\"hljs-subst\">${lastName}</span>`</span>\n  );\n\n  <span class=\"hljs-keyword\">const</span> props = {\n    userNamesArray,\n    <span class=\"hljs-attr\">userName</span>: <span class=\"hljs-string\">\"Janet Wong\"</span>,\n  };\n\n  <span class=\"hljs-keyword\">const</span> isJanetDuplicatedDestructuredProps =\n    <span class=\"hljs-title function_\">userNameIsDuplicatedDestructuredProps</span>(props);\n\n  <span class=\"hljs-keyword\">const</span> isJanetDuplicatedImplicitProps = <span class=\"hljs-title function_\">userNameIsDuplicatedImplicitProps</span>(\n    <span class=\"hljs-string\">\"Janet Wong\"</span>,\n    userNamesArray\n  );\n\n  <span class=\"hljs-keyword\">const</span> isJanetDuplicatedExplicitProps = <span class=\"hljs-title function_\">userNameIsDuplicatedExplicitProps</span>({\n    <span class=\"hljs-attr\">userName</span>: <span class=\"hljs-string\">\"Janet Wong\"</span>,\n    userNamesArray,\n  });\n\n<span class=\"hljs-comment\">// 이것을 변경해가며 출력과 타입 체크 차이를 관찰해보세요</span>\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>Janet이 중복되었나요? {`${isJanetDuplicatedDestructuredProps}`}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">br</span> /></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">br</span> /></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>Janet이 중복되었나요? {`${isJanetDuplicatedImplicitProps}`}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">br</span> /></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">br</span> /></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>Janet이 중복되었나요? {`${isJanetDuplicatedExplicitProps}`}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n  );\n};\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">TypingFnProps</span>;\n</code></pre>\n<p>안내드린 내용 외에도 TypeScript로 유지보수 가능한 코드를 작성하는 더 많은 팁이 있지만, 이 중에서 저가 일반적으로 사용하는 팁들이었습니다.</p>\n<p>전체 소스 코드: <a href=\"https://github.com/lbd1607/ts-blog\" rel=\"nofollow\" target=\"_blank\">https://github.com/lbd1607/ts-blog</a></p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>행복한 코딩하세요 :)</p>\n</body>\n</html>\n"},"__N_SSG":true}