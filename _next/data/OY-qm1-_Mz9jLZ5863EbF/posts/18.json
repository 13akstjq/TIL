{"pageProps":{"posts":[{"title":"자바스크립트와 파이썬의 비동기 프로그래밍 비교 어떤 언어가 더 나을까","description":"","date":"2024-07-06 02:24","slug":"2024-07-06-AsyncProgramminginJavaScriptvsPython","content":"\n\n비동기 프로그래밍은 작업을 더 효율적으로 실행할 수 있게 해주는 주요 패러다임입니다, 특히 I/O 바운드 작업에서 더욱 그렇습니다. JavaScript와 Python은 모두 비동기 프로그래밍을 지원하지만, 각각의 설계 철학과 런타임 환경에 따라 다른 방식으로 지원합니다.\n\n이 기사는 JavaScript와 Python에서의 비동기 프로그래밍을 비교하여, 그들의 메커니즘, 성능 및 사용 사례를 살펴봅니다.\n\n## 비동기 프로그래밍 소개\n\n비동기 프로그래밍은 프로그램이 장기 실행 작업이 완료될 때까지 기다리는 동안 다른 작업을 수행할 수 있게 합니다. 이 패러다임은 네트워크 요청, 파일 I/O 및 데이터베이스 상호 작용과 같은 I/O 작업이 지연을 일으킬 수 있는 환경에서 중요합니다. 주 스레드를 차단하지 않음으로써, 비동기 프로그래밍은 응용 프로그램의 반응성과 효율성을 향상시킵니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## JavaScript에서의 비동기 프로그래밍\n\nJavaScript는 본질적으로 비동기적이며 단일 스레드이며, 비동기 작업을 처리하기 위해 이벤트 루프를 의존합니다. 이벤트 루프는 JavaScript가 시스템의 커널에 일부 작업을 오프로드하고 작업이 완료되면 콜백을 실행하여 여러 작업을 동시에 처리할 수 있는 핵심 메커니즘입니다.\n\n주요 구성 요소:\n\n- 호출 스택: 호출 스택은 현재 실행 중인 함수를 보유합니다. 함수가 호출되면 스택에 푸시되고 반환되면 스택에서 팝됩니다.\n- Web API: 이는 브라우저 (또는 Node.js)에서 제공하는 API로 DOM 조작, HTTP 요청 및 타이머와 같은 작업을 처리합니다. 비동기 작업이 수행될 때, 이러한 API로 작업이 전달됩니다.\n- 콜백 대기열: 비동기 작업이 완료되면 해당 콜백이 콜백 대기열에 배치됩니다.\n- 이벤트 루프: 이벤트 루프는 지속적으로 호출 스택과 콜백 대기열을 확인합니다. 호출 스택이 비어 있으면 대기열에서 첫 번째 콜백을 가져와 실행을 위해 스택에 푸시합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n/assets/img/2024-07-06-AsyncProgramminginJavaScriptvsPython_0.png\n\n[YouTube Link](https://www.youtube.com/watch?v=eiC58R16hb8)\n\nCallbacks\n\n초반에 JavaScript는 비동기 작업을 처리하기 위해 콜백을 사용했습니다. 콜백은 다른 함수로 전달되는 함수로, 이후에 외부 함수 내에서 호출되어 특정 루틴이나 작업을 완료하는 데 사용됩니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예시:\n\n```js\nfunction fetchData(callback) {\n    setTimeout(() => {\n        callback(\"데이터를 가져왔어요\");\n    }, 1000);\n}\nfetchData((message) => {\n    console.log(message);\n});\n```\n콜백은 기능적이지만 종종 \"콜백 지옥\"이라고 알려진 깊게 중첩된 구조로 이어질 수 있어 코드를 읽기 어렵게 만들기도 합니다.\n\n프로미스\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n약속은 비동기 작업을 처리하는 더 깔끔하고 관리하기 쉬운 방법을 제공합니다. 이들은 현재 이용 가능하거나 미래에 이용 가능할 수도 있고 아예 없을 수도 있는 값을 나타냅니다. 약속은 연결할 수 있고 콜백보다 중첩될 가능성이 적습니다.\n\n예시:\n\n```js\nlet fetchData = new Promise((resolve, reject) => {\n    setTimeout(() => {\n        resolve(\"Data fetched\");\n    }, 1000);\n});\nfetchData.then((message) => {\n    console.log(message);\n});\n```\n\n약속은 콜백 지옥을 피하고 더 나은 오류 처리 메커니즘을 제공하여 비동기 코드의 가독성을 크게 향상시킵니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n비동기/대기\n\nECMAScript 2017에서 도입된 async 및 await 키워드는 프로미스 위에 구문 설탕을 제공하여 비동기 코드가 동기 코드처럼 보이고 동작하도록 만들어줍니다. 이를 통해 코드를 작성, 읽고 유지하기가 더 쉬워집니다.\n\n예시:\n\n```js\nasync function fetchData() {\n    let promise = new Promise((resolve, reject) => {\n        setTimeout(() => resolve(\"데이터를 가져왔습니다\"), 1000);\n    });\n    let result = await promise;\n    console.log(result);\n}\nfetchData();\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nasync/await 구문을 사용하면 개발자가 직관적이고 선형적인 비동기 코드를 작성할 수 있어서 복잡한 비동기 작업을 관리하는 데 따르는 인지 부하를 줄일 수 있습니다.\n\n구현 내부:\n\n- async 함수는 항상 Promise를 반환합니다.\n- await 키워드는 async 함수의 실행을 일시 중지시키고, 계속하기 전에 Promise가 해결되거나 거부될 때까지 기다립니다.\n\n## Python에서의 비동기 프로그래밍\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAsyncio 모듈\n\n파이썬의 비동기 프로그래밍을 위한 주요 메커니즘은 Python 3.4에서 도입된 asyncio 모듈입니다. asyncio는 JavaScript와 유사한 이벤트 루프를 제공하지만 명시적으로 호출해야 합니다. 이 모듈은 협력적인 멀티태스킹을 지원하여 개발자가 단일 스레드 내에서 여러 작업을 관리할 수 있도록 합니다.\n\nAsyncio 작동 방식:\n\n- 이벤트 루프: asyncio의 핵심인 이벤트 루프는 asyncio 작업 및 콜백을 실행하고 네트워크 I/O 작업을 수행하며 서브프로세스를 실행합니다.\n- 코루틴: 일시 중지 및 재개할 수 있는 async def로 정의된 함수들입니다.\n- 작업: 코루틴을 감싸서 이벤트 루프에서 실행할 수 있도록 하는 래퍼입니다.\n- 퓨처: 아직 사용 가능하지 않을 수 있는 비동기 작업의 결과를 나타냅니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n코루틴\n\n파이썬에서 코루틴은 async def를 사용하여 정의되며, 일시 중지되고 재개될 수 있는 함수들로, 비동기 프로그래밍에 적합합니다. 코루틴은 직접 대기하거나 이벤트 루프에서 실행되도록 스케줄링하여 대기해야 합니다.\n\n예시:\n```python\nimport asyncio\nasync def fetch_data():\n    await asyncio.sleep(1)\n    return \"데이터 가져오기 완료\"\nasync def main():\n    result = await fetch_data()\n    print(result)\nasyncio.run(main())\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n코루틴은 파이썬의 비동기 프로그래밍의 중추를 이루며, 여러 작업을 동시에 실행할 수 있게 합니다.\n\n작업과 미래\n\nasyncio는 작업(Task)과 미래(Future)와 같은 구조체를 제공하여 코루틴의 동시 실행을 처리할 수 있게 합니다. 작업은 백그라운드에서 실행할 수 있도록 코루틴을 감싸는 래퍼이며, 미래는 아직 사용 가능하지 않은 결과를 나타냅니다.\n\n예시:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport asyncio\nasync def fetch_data():\n    await asyncio.sleep(1)\n    return \"Data fetched\"\nasync def main():\n    task = asyncio.create_task(fetch_data())\n    result = await task\n    print(result)\nasyncio.run(main())\n```\n\nTasks and Futures Internals:\n\n- Tasks: 작업을 생성하면 이벤트 루프에서 실행할 수 있도록 예약됩니다. 작업은 코루틴을 실행하고 그 실행을 관리합니다.\n- Futures: 퓨처는 처음에는 알려지지 않지만 어느 시점에는 사용 가능한 결과를 나타내는 객체입니다. 퓨처는 일반적으로 동기 및 비동기 코드 간의 다리를 제공하기 위해 하위 수준 API에 사용됩니다.\n\n## JavaScript와 Python 비동기 프로그래밍 비교\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n**이벤트 루프 및 논블로킹 I/O**\n\n![AsyncProgramminginJavaScriptvsPython_1](/assets/img/2024-07-06-AsyncProgramminginJavaScriptvsPython_1.png)\n\n**구문 및 가독성**\n\n![AsyncProgramminginJavaScriptvsPython_2](/assets/img/2024-07-06-AsyncProgramminginJavaScriptvsPython_2.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n성능\n\n/assets/img/2024-07-06-AsyncProgramminginJavaScriptvsPython_3.png\n\n생태계 및 라이브러리\n\n/assets/img/2024-07-06-AsyncProgramminginJavaScriptvsPython_4.png\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n사용 사례\n\n/assets/img/2024-07-06-AsyncProgramminginJavaScriptvsPython_5.png\n\nPython의 asyncio 모듈은 코루틴을 사용하여 단일 스레드 동시 코드를 작성할 수 있도록 강력한 비동기 프로그래밍 프레임워크를 제공합니다. 그러나 성능을 더욱 향상시키고자 하는 경우, uvloop는 기본 이벤트 루프에 대안적인 솔루션을 제공합니다.\n\n## uvloop란 무엇인가요?\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nuvloop은 Python의 asyncio 모듈을 위한 이벤트 루프 구현체로, Node.js의 이벤트 루프를 구동하는 libuv 라이브러리를 기반으로 합니다. 기본 이벤트 루프를 uvloop로 대체하면, I/O 바운드 애플리케이션에서 상당한 성능 향상을 얻을 수 있습니다.\n\n## uvloop의 주요 기능\n\n- 고성능: uvloop은 빠를 것으로 설계되어 있습니다. asyncio 작업의 오버헤드를 크게 줄여, Node.js의 성능 수준과 유사한 성능을 제공할 수 있습니다.\n- 호환성: uvloop은 asyncio API와 완벽하게 호환되어, 기존 애플리케이션에 최소한의 변경으로 통합하기 쉽습니다.\n- 신뢰성: libuv 기반으로 만들어진 uvloop은 이 실전 경험에 기반을 둔 안정성과 견고함을 상속받았습니다.\n\n## uvloop 설치하기\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\npip install uvloop\n```\n\n## asyncio로 uvloop 사용하기\n\nasyncio 애플리케이션에서 이벤트 루프로 uvloop를 사용하려면 기본 이벤트 루프로 설정해야 합니다. 다음은 그 방법입니다:\n\n```js\nimport asyncio\nimport uvloop\n\nasync def fetch_data():\n    await asyncio.sleep(1)\n    return \"데이터 가져옴\"\n\nasync def main():\n    data = await fetch_data()\n    print(data)\n\nif __name__ == \"__main__\":\n    # uvloop를 기본 이벤트 루프로 설정\n    asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())\n    asyncio.run(main())\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 예시에서는 메인 코루틴을 실행하기 전에 uvloop를 기본 이벤트 루프 정책으로 설정합니다. 이렇게 함으로써 모든 asyncio 작업이 uvloop의 고성능 이벤트 루프를 사용하도록 보장됩니다.\n\n## 웹 서버\n\n다양한 I/O 작업을 처리하는 웹 서버는 uvloop에서 큰 이점을 얻을 수 있습니다. aiohttp와 Sanic과 같은 프레임워크는 uvloop를 활용하여 요청 처리 성능을 향상시킬 수 있습니다.\n\naiohttp를 활용한 예시:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nfrom aiohttp import web\nimport uvloop\n\nasync def handle(request):\n    return web.Response(text=\"안녕, 세상\")\n\napp = web.Application()\napp.add_routes([web.get('/', handle)])\n\nif __name__ == \"__main__\":\n    web.run_app(app, loop=uvloop.new_event_loop())\n```\n\n# 결론\n\n자바스크립트와 파이썬 모두 풍부한 비동기 프로그래밍 기능을 갖추고 있지만, 그들의 접근 방식은 내재적인 설계 철학과 런타임 환경의 차이로 인해 다릅니다. 자바스크립트의 비동기 프로그래밍은 단일 스레드 및 이벤트 기반 아키텍처와 긴밀하게 통합되어 웹 개발에 매우 효율적입니다. 파이썬의 asyncio는 언어에 강력한 비동기 기능을 제공하며 다양한 응용 프로그램에 적합하지만 조금 더 많은 보일러플레이트 코드가 필요합니다.\n\n파이썬에서 asyncio 기반 애플리케이션에 uvloop을 통합함으로써 Node.js의 성능 수준을 달성할 수 있으면서도 파이썬의 풍부한 생태계와 사용 편의성을 계속 누릴 수 있습니다.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n참고 자료:\n- [https://youtu.be/8aGhZQkoFbQ?si=xYY9tHFrJzKLRaok](https://youtu.be/8aGhZQkoFbQ?si=xYY9tHFrJzKLRaok)\n- [https://www.youtube.com/watch?v=eiC58R16hb8](https://www.youtube.com/watch?v=eiC58R16hb8)","ogImage":{"url":"/assets/img/2024-07-06-AsyncProgramminginJavaScriptvsPython_0.png"},"coverImage":"/assets/img/2024-07-06-AsyncProgramminginJavaScriptvsPython_0.png","tag":["Tech"],"readingTime":12},{"title":"시계열 예측을 위한 범용 머신 러닝 프레임워크","description":"","date":"2024-07-06 02:23","slug":"2024-07-06-AGeneralizedMachineLearningFrameworkforTimeSeriesForecasting","content":"\n\n\n/assets/img/2024-07-06-AGeneralizedMachineLearningFrameworkforTimeSeriesForecasting_0.png\n\n# 소개\n\n시계열 예측은 예측 모델링에서 필수적이며 데이터 과학자들의 큰 관심을 끕니다. 그 응용 분야는 공급망 수요 예측부터 금융 시장 예측까지 다양합니다. 전통적인 모델과는 달리, 시계열 예측 모델은 시간의 고유한 변동성으로 인해 불안정할 수 있습니다.\n\n최근 게시한 글, '시계열 예측: SARIMAX, RNN, LSTM, Prophet, 그리고 Transformer의 비교 분석'에서 여러 시계열 예측 방법을 비교 분석했습니다. 기계 학습 접근 방법을 포함해야 했으나 글이 너무 길어졌습니다. 따라서 이 논문을 발표하여 그 갭을 해결하고자 합니다.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 게시물에서는 시계열 모델을 계속 탐구하겠습니다. 이 모델들은 어떻게 작동하는지, 그리고 왜 특성 엔지니어링을 사용하여 거래 데이터를 예측하기 위한 일반화된 머신러닝 프레임워크를 제안했는지에 대해 계속 알아보겠습니다. 머신러닝을 시계열 예측에 적용하는 것은 새로운 것은 아니지만, 제안하는 일반화된 프레임워크는 다양한 시나리오에서 실제 시계열 예측에 대한 도전 과제를 해결하려고 합니다.\n\n# 1: 예측의 개요 대 ...","ogImage":{"url":"/assets/img/2024-07-06-AGeneralizedMachineLearningFrameworkforTimeSeriesForecasting_0.png"},"coverImage":"/assets/img/2024-07-06-AGeneralizedMachineLearningFrameworkforTimeSeriesForecasting_0.png","tag":["Tech"],"readingTime":1},{"title":"초보자를 위한 NumPy 입문 가이드","description":"","date":"2024-07-06 02:23","slug":"2024-07-06-IntroductiontoNumPy","content":"\n\n/assets/img/2024-07-06-IntroductiontoNumPy_0.png\n\nNumPy은 Numerical Python의 약자로, 수치 계산에 사용되는 파이썬의 강력한 라이브러리입니다. NumPy는 대규모 다차원 배열과 행렬을 지원하며, 이러한 배열에 효율적으로 작동하는 수학 함수 모음을 제공합니다. NumPy는 파이썬의 많은 과학 계산 및 데이터 분석 라이브러리의 기초를 형성합니다.\n\n## NumPy의 주요 기능:\n\n- 배열: NumPy의 주요 객체는 동질적인 다차원 배열입니다. 이는 양수로 이루어진 튜플로 색인화된 동일한 유형의 요소(일반적으로 숫자)로 구성된 테이블입니다.\n- 효율적인 연산: NumPy는 배열에 대한 효율적인 수학 연산을 제공하여 복잡한 계산을 쉽고 빠르게 수행할 수 있습니다.\n- 브로드캐스팅: 브로드캐스팅은 NumPy가 산술 연산을 수행할 때 서로 다른 모양의 배열을 작업할 수 있는 강력한 메커니즘으로, 코드를 더 간결하고 가독성 있게 만듭니다.\n- 벡터화된 연산: NumPy 연산은 벡터화되어 있어 배열의 요소별로 수행되며, 종종 전통적인 반복적 접근 방식보다 더 깔끔하고 간결한 코드를 만들게 됩니다.\n- 다른 라이브러리와의 통합: NumPy는 SciPy(과학 계산용), Matplotlib(그래픽 및 시각화용) 및 Pandas(데이터 조작 및 분석용) 등 다른 파이썬 라이브러리와 완벽하게 통합됩니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## NumPy 설치하는 방법:\n\nNumPy를 설치하는 방법은 2가지가 있어요:\n\n- pip install numpy\n- Anaconda를 설치하고 Jupyter Notebook을 열어요\n\n## NumPy를 불러오는 방법:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport numpy as np\n```\n\n```js\nimport numpy\n```\n\n이만큼이에요, 제 다음 블로그에서 NumPy에 대해 더 자세히 알아보겠어요.\n\n그리고 제 Github 프로필에서 더 많은 것을 배울 수 있어요:\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n또한, Github에서 Matplotlib 학습 자료를 참고해보세요:\n\n즐거운 학습 되세요 :)","ogImage":{"url":"/assets/img/2024-07-06-IntroductiontoNumPy_0.png"},"coverImage":"/assets/img/2024-07-06-IntroductiontoNumPy_0.png","tag":["Tech"],"readingTime":2},{"title":"견고성 원칙으로 정적 타입 검사기 무력화하는 방법","description":"","date":"2024-07-06 02:22","slug":"2024-07-06-Silencethestatictypecheckerwiththerobustnessprinciple","content":"\n\n/assets/img/2024-07-06-Silencethestatictypecheckerwiththerobustnessprinciple_0.png\n\n타입 힌트는 mypy나 pyright와 같은 정적 타입 체커와 결합하여 Python 코드의 견고성과 유지 보수성을 크게 향상시킬 수 있습니다. 프로그램을 실행하기 전에 전체 클래스의 버그를 감지하고 수정할 수 있다는 것은 매우 유용합니다. 무모한 리팩터링을 가능하게 하며 테스트 작성 부담을 크게 줄여줍니다.\n\n또한, 타입 힌트는 사용자와 유지 보수자가 코드 조각이 무엇을 해야 하는지 빠르게 알 수 있도록 도와주는 최소한의 문서 역할을 합니다.\n\n하지만 많은 Python 개발자들 — 특히 강력한 타입 시스템을 경험하지 않은 경우 — 타입 힌팅에 어려움을 겪습니다. 내장된 데이터 유형을 사용하는 단순한 예제를 넘어서면 타입 체커의 모든 규칙을 따르기는 끝없는 오류의 연속으로 이어질 수 있습니다. 타입 체커와의 장시간의 싸움 끝에 대부분의 개발자들은 수많은 Any 주석이나 # type: ignore 주석을 사용하여 항복하게 됩니다. 이는 결국 타입 체크로부터 얻는 안전 보장을 피하는 결과를 초래합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파이썬 개발자들이 타입 힌트에 어려움을 겪는 주요 이유 중 하나는 전투 규칙을 정확히 모르기 때문입니다. 타입 힌트는 함께...","ogImage":{"url":"/assets/img/2024-07-06-Silencethestatictypecheckerwiththerobustnessprinciple_0.png"},"coverImage":"/assets/img/2024-07-06-Silencethestatictypecheckerwiththerobustnessprinciple_0.png","tag":["Tech"],"readingTime":1},{"title":"2025년까지 파이썬이 IT 산업을 지배할 7가지 이유","description":"","date":"2024-07-06 02:21","slug":"2024-07-06-TheReasonsPythonWillDominatetheITIndustryby2025","content":"\n\n/assets/img/2024-07-06-TheReasonsPythonWillDominatetheITIndustryby2025_0.png\n\n전화로 피자 주문을 하는 과거를 떠올려보세요. 그리고 배달원이 당신의 주소를 제대로 기억했는지 손가락 교차하며 기다리던 시절을 생각해보세요. 오늘날, 자율 주행 자동차가 당신에게 뜨거운 피자를 가져다 줄 수 있고, 당신은 잡지보다 작은 화면에서 최신 시리즈를 시청할 수 있습니다. 이 놀라운 기술 대부분이 파이썬에서 유래했다는 것을 알고 계셨나요?\n\n파이썬은 학계와 컴퓨터 애호가들을 넘어서 확장되어 왔습니다. 최신 동향을 따라가지 않은 사람들에게 놀랄만한 소식일지도 모릅니다. 지능적인 기계와 자율 주행 자동차 개발부터 웹사이트 제작과 데이터 분석까지 파이썬은 모든 다른 언어를 빠르게 대체하고 있습니다. 내 확고한 확신은 파이썬이 2025년에 기술 세계에서 최고로 거론될 것이라는 것입니다.\n\n## 파이썬의 묻힌 영웅: 사용 편의성, 커뮤니티, 다양성\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파이썬의 엄청난 유연성은 그 중요한 특징 중 하나입니다. 프로그래머들을 위한 범용 도구 세트와 같이 매우 다재다능합니다. 웹사이트를 만들고 싶으신가요? Django와 Flask는 여러분의 요구를 충족시킬 수 있는 많은 파이썬 프레임워크 중의 두 가지에 불과합니다. 데이터 과학을 깊게 탐험하고 싶으신가요? NumPy, pandas, 그리고 matplotlib과 같은 라이브러리들이 귀중한 동반자가 될 것을 알게 되실 것입니다...","ogImage":{"url":"/assets/img/2024-07-06-TheReasonsPythonWillDominatetheITIndustryby2025_0.png"},"coverImage":"/assets/img/2024-07-06-TheReasonsPythonWillDominatetheITIndustryby2025_0.png","tag":["Tech"],"readingTime":2},{"title":"TS Types와 Interfaces를 사용하는 방법 및 시기","description":"","date":"2024-07-02 21:53","slug":"2024-07-02-TSWhentouseTypesandwhentouseInterfaces","content":"\nTypeScript를 처음 접했을 때 인터페이스와 타입이 서로 교환 가능해 보일 수 있습니다, 특히 객체 모양을 설명할 때입니다. 실제로 TPerson 및 IPerson을 모두 가져오는 코드를 볼 수 있는데, 이는 둘 다 클래스 또는 객체 구조를 정의할 수 있다는 것을 시사합니다. 이 명백한 유사성은 각각을 사용해야 할 때에 대한 혼란을 야기할 수 있습니다.\n\n그러나 중요한 차이가 존재합니다: 인터페이스는 객체 및 클래스를 설명하는 데 사용되지만, 타입은 어떤 유형의 데이터 구조든 표현할 수 있습니다. 이 기본적인 대조는 TypeScript 프로젝트에서 각각을 언제 사용해야 할지에 대한 기준을 마련합니다.\n\n# 명백한 유사성\n\n다음과 같이 보이는 동등한 정의를 고려해보세요:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ninterface IPerson {\n  name: string;\n  age: number;\n}\n\ntype TPerson = {\n  name: string,\n  age: number,\n};\n\nconst person1: IPerson = { name: \"Alice\", age: 30 };\nconst person2: TPerson = { name: \"Bob\", age: 25 };\n```\n\nIPerson과 TPerson은 둘 다 이름과 나이 속성을 가진 객체를 설명할 수 있지만, 그 기능은 여기서부터 다릅니다.\n\n# 인터페이스: 클래스 제한을 위한 전문가\n\nTypeScript의 인터페이스는 특정 목적에 맞게 설계되었습니다: 객체와 클래스의 형태를 설명하는 데 사용됩니다. 원시 값의 별칭을 만들거나, 결합 유형 또는 교차 유형을 생성하는 데 사용할 수 없습니다. 이 특화된 기능은 인터페이스를 객체지향 프로그래밍 시나리오에서 특히 강력하게 만듭니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nTypeScript을 공부할 때 인터페이스와 타입의 차이를 이해하는 것이 중요합니다. 기억해야 할 주요 차이는 인터페이스는 객체와 클래스를 설명하는 데만 사용되지만, 타입은 어떤 종류의 데이터 구조든 나타낼 수 있다는 점입니다. 이 기본적인 대조는 TypeScript 프로젝트에서 각각을 언제 어떻게 사용해야 하는지를 결정합니다.\n\n인터페이스의 주요 장점은 다음과 같습니다:\n\n- 객체 모양 정의: 인터페이스는 객체가 특정 구조를 준수하는지 확실하게 보장하는 방법을 제공합니다.\n- 확장성: 인터페이스를 확장할 수 있어 복잡한 객체 유형을 시간이 지남에 따라 발전시키는 데 이상적입니다.\n- 클래스 구현: implements 키워드를 이용하여 클래스를 제한하고 인터페이스 계약을 준수하도록 함으로써 코드의 견고성을 향상시킵니다.\n\n간단한 예시를 살펴보겠습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ninterface IAnimal {\n  name: string;\n  age: number;\n  speak(): void;\n}\n\nclass Dog implements IAnimal {\n  name: string;\n  age: number;\n\n  constructor(name: string, age: number) {\n    this.name = name;\n    this.age = age;\n  }\n\n  speak() {\n    console.log(\"Woof!\");\n  }\n}\n```\n\n그리고 여기에 `extends` 키워드를 잘 활용한 예제가 있어요.\n\n```js\ninterface IAnimal {\n  name: string;\n  speak(): void;\n}\n\ninterface IDog extends IAnimal {\n  breed: string;\n  wagTail(): void;\n}\n\nclass Dog implements IDog {\n  name: string;\n  breed: string;\n\n  constructor(name: string, breed: string) {\n    this.name = name;\n    this.breed = breed;\n  }\n\n  speak() {\n    console.log(\"Woof!\");\n  }\n\n  wagTail() {\n    console.log(`${this.name}가 꼬리를 흔들고 있어요.`);\n  }\n}\n\nconst myDog = new Dog(\"Buddy\", \"Labrador\");\nmyDog.speak();\nmyDog.wagTail();\n```\n\n주의하셔야 할 점은 아래의 문법이 객체를 제한하는 경우에서는 클래스가 아닌 객체를 제한하는 경우에만 맞는 구문이에요:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```typescript\n인터페이스 IPerson {\n  이름: 문자열;\n  나이: 숫자;\n}\n\n상수 person1: IPerson = { 이름: \"Alice\", 나이: 30 };\n```\n\n# 타입: 다재다능한 파워하우스\n\n인터페이스는 객체 모양에만 제한되지만, 타입은 더 다양한 가능성을 제공합니다:\n\n- 다재다능성: 타입은 객체뿐만 아니라 기본 유형, 유니온, 교차, 튜플 등을 대표할 수 있습니다.\n- 복잡한 타입 작성: 유니언(|) 및 교차(&) 연산자로 타입을 정교하게 정의할 수 있습니다.\n- 별칭: 타입 별칭은 복잡한 타입에서 코드 가독성을 높일 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음은 예제 입니다:\n\n```js\ntype TName = string;\ntype TAge = number;\n\ntype TPerson = {\n  name: TName,\n  age: TAge,\n};\n\ntype TAnimal = {\n  name: string,\n  age: number,\n  speak(): void,\n};\n\ntype TDog = TAnimal & { breed: string };\n\nconst myDog: TDog = {\n  name: \"Buddy\",\n  age: 5,\n  breed: \"Golden Retriever\",\n  speak() {\n    console.log(\"Woof!\");\n  },\n};\n```\n\n# 인터페이스와 유형 사이 선택하기\n\n각각의 한계와 강점을 이해하고, 다음 권장 사항을 고려해보세요:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Interfaces를 사용하는 경우:\n\n  - 오브젝트나 클래스와 작업할 때\n  - 오브젝트가 지켜야 하는 계약을 정의할 때\n  - 오브젝트 정의를 확장하거나 병합해야 할 때\n\n- Types를 사용하는 경우:\n  - 오브젝트를 포함한 모든 종류의 타입 정의를 생성할 때\n  - 유니언, 교차 또는 기본형과 작업할 때\n  - 타입 생성에서 최대 유연성이 필요할 때\n\n# 결론\n\nTypeScript에서의 인터페이스와 타입의 차이는 분명합니다: 인터페이스는 오브젝트 형태를 설명하는 데 특화되어 있고, 타입은 모든 종류의 타입 정의에 대해 더 큰 유연성을 제공합니다. 이 기본적인 차이를 이해하면 TypeScript 프로젝트에서 보다 정보를 얻고 더 나은 결정을 내릴 수 있습니다.\n\n인터페이스는 클래스 기반 시나리오에서 뛰어나며, 오브젝트 구조의 일관성을 보장해야 하는 경우에 유용합니다. 타입은 그들의 다양성으로 인해 복잡한 정의와 다양한 데이터 구조에 대한 가독성 향상에 필요한 도구입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마지막으로, 클래스와 타입을 제한하는 데 인터페이스를 사용하고 그 외에는 거의 모든 것에 인터페이스를 사용해야 합니다. 이렇게 하면 더 표현력이 뛰어나고 유지보수하기 쉽고 견고한 TypeScript 코드를 작성할 수 있습니다. 기억하세요, 이 도구들을 사용하여 시간이 지나도 유지할 수 있는 명확하고 자기 설명적인 코드를 작성하는 것이 목표입니다.\n","ogImage":{"url":"/TIL/assets/img/2024-07-02-TSWhentouseTypesandwhentouseInterfaces_0.png"},"coverImage":"/TIL/assets/img/2024-07-02-TSWhentouseTypesandwhentouseInterfaces_0.png","tag":["Tech"],"readingTime":6},{"title":"Nextjs 사용이 점점 더 어려워지는 이유","description":"","date":"2024-07-02 21:52","slug":"2024-07-02-ItsnotjustyouNextjsisgettinghardertouse","content":"\n![image 1](/TIL/assets/img/2024-07-02-ItsnotjustyouNextjsisgettinghardertouse_0.png)\n\n이전에 언급한 것처럼, Next.js 미들웨어를 사용하면 서버 컴포넌트가 부과한 일부 제한을 해결하는 데 유용할 수 있다는 블로그 글을 썼어요. 이에 대한 토론으로 인해 Next.js 개발 경험이 좋지 않다는 의견이 나왔어요.\n\n![image 2](/TIL/assets/img/2024-07-02-ItsnotjustyouNextjsisgettinghardertouse_1.png)\n\n저의 관점에서, Next.js 의 앱 라우터에는 채택하기 어렵게 만드는 두 가지 주요 문제가 있어요:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 보통 기초적인 작업을 하려면 내부 동작에 대해 많은 것을 이해해야 합니다.\n- 옵트인(opt-in)이 아닌 옵트아웃(opt-out)인 방식으로 발을 쏘기 쉬운 많은 방법이 있습니다.\n\n더 잘 이해하려면, 이전 버전인 Pages Router를 살펴보겠습니다.\n\n# Pages Router 간단히 살펴보기\n\nNext.js에 대해 처음 알게 되었을 때, 주요 \"경쟁자\"는 Create React App (CRA)였습니다. 나는 모든 프로젝트에 CRA를 사용했지만 두 가지 이유로 Next.js로 전환했습니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 파일 기반 라우팅이 마음에 들었어요. 왜냐하면 보일러플레이트 코드를 적게 작성할 수 있어서요.\n- 개발 서버를 실행할 때마다 CRA는 빠르게 짜증나는 http://localhost:3000을 열었는데, Next.js는 그렇지 않았어요.\n\n두 번째 이유는 조금 어리석게 들릴 수 있지만, 나에게는 Next.js가 였어요:\n\n더 나은 기본 설정이 있는 React.\n\n그리고 그게 내가 정말 원했던 것이었어요. 후에 Next.js가 갖고 있는 다른 기능을 발견했을 때에는 꽤 놀랐어요. API 라우트는 추가 인프라를 설정할 필요 없이 서버리스 함수를 제공해주어서 \"Contact Us\" 양식 같은 것을 만드는 것에 아주 유용했어요. getServerSideProps를 사용하면 페이지가 로드되기 전에 서버에서 기본 함수를 실행할 수 있었어요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그 개념들은 강력하지만 동시에 간단하기도 했어요.\n\nAPI route는 다른 라우트 핸들러와 매우 비슷하게 보였고 동작했어요. Express나 Cloudflare Workers를 사용해봤다면 라우트 핸들러를 자세히 보면 이미 알고 있던 개념들이 그대로 적용돼 있는 걸 느낄 수 있어요. getServerSideProps는 약간 다르긴 했지만, 한번 요청을 받는 방법과 응답 형식을 이해하면 꽤 간단한 거라는 걸 알게 되었어요.\n\n# 앱 라우터 릴리스\n\nNext 13 릴리스에서는 앱 라우터를 도입했고 많은 새로운 기능들이 추가됐어요. 서버 컴포넌트를 사용하면 React 컴포넌트를 서버에서 렌더링하고 클라이언트에 전달해야하는 데이터 양을 줄일 수 있어요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n레이아웃은 여러 경로에서 공유되는 UI의 측면을 정의할 수 있어서 매번 탐색할 때마다 다시 렌더링할 필요가 없었습니다.\n\n캐싱 기능이... 더욱 정교해졌습니다.\n\n이러한 기능들이 흥미로웠지만, 가장 큰 손실은 간단함이었습니다.\n\n# 프레임워크가 생각했던대로 동작하지 않을 때\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n개발자로서 머리를 벽에 쿵쿵 치며 \"왜 이게 작동하지 않지?\" 하고 외치는 것은 상당히 보편적인 경험입니다.\n\n모두가 다 그런 적이 있고, 항상 짜증이 납니다. 제 경우, 코드에 버그가 아니라 어떻게 작동해야 하는지 잘 몰랐을 때가 더 고통스러웠습니다.\n\n이제 더 이상 \"왜 이게 작동하지 않지?\" 라고 말하지 않고, \"왜 이게 저렇게 작동하지?\" 라고 이제 말할 것입니다.\n\n앱 라우터는 안타깝게도 이러한 섬세한 점들로 가득합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n내 원래 문제를 다시 살펴보겠어요: 서버 컴포넌트에서 URL을 얻고 싶었어요. 주제에 대한 인기 있는 Github 이슈에 대한 답변을 준비했는데, 그 중 일부를 여기에 올려볼게요:\n\n이 응답은 정말 대단하다고 생각해요. 잘 쓰여졌고, 많은 기본적인 문제들을 이해하는데 도움이 되며, 저는 전혀 고려하지 못한 다양한 접근 방식과 관련된 절충안에 대한 통찰력을 얻게 되었어요.\n\n하지만 말해야 할 한 가지는, 개발자이고 서버 컴포넌트에서 URL을 얻으려는 것이라면, 아마도 이것을 읽은 후에 아마도 코드를 다시 구조화해야 한다는 것을 깨달을 때까지 5가지 더 찾아보고 있을 것이라는 것이죠.\n\n이 글은 나의 느낌을 요약한 것 같아요:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/TIL/assets/img/2024-07-02-ItsnotjustyouNextjsisgettinghardertouse_2.png)\n\n그것이 반드시 잘못된 것은 아니라는 점을 유의하십시오.\n\n원문에는 몇 가지 미묘한 점도 언급되어 있습니다. 하나의 보편적인 함정은 쿠키 처리 방식에 있습니다. 어디에서든 cookies().set(\"key\", \"value\")를 호출할 수 있고 이것은 타입 체크가 가능하지만, 일부 경우에는 런타임에서 실패할 수 있습니다.\n\n서버에서 거의 모든 것을 할 수 있었던 \"옛\" 방식과 비교하면, 복잡성이 증가했다고 말할 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n제가 말씀드리고 싶은 것은 \"기본으로 켜진 캐싱\"은 다소 거친 경험이라는 점입니다. 많은 사람들이 캐싱에 동의하기를 기대하는 것이 오히려 캐싱 비활성화 방법을 찾기 위해 많은 문서를 살펴야 한다고 생각합니다.\n\n다른 회사들도 우리와 유사한 문제를 겪었을 거라고 확신합니다. PropelAuth에서 종종 버그 신고를 받는데, 그것들은 실제로 버그가 아니라 \"API 호출을 한 줄로 생각했지만 실제로는 호출하지 않았고, 캐시된 결과만 읽고 있는 것\"이라고 할 수 있습니다.\n\n그리고 이 모든 것은 다시 한 번 질문을 던집니다. 이러한 기능과 최적화는 과연 누구를 위한 것인가요?\n\n# 모두에게 맞는 제품을 만드는 것은 매우 어려운 일입니다\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n너가 너무 복잡하다고 느끼는 기능들은 실제로 몇몇 사람에겐 중요할 수 있어요. 예를 들어 전자상거래 플랫폼을 개발 중이라면, 이 기능들이 정말 유용할 거예요.\n\n작은 양의 데이터를 클라이언트에 전달하기 때문에 페이지가 빨리 로드됩니다. 모든 것이 강력하게 캐시되어 있어 페이지가 빨리 로드됩니다. 사용자가 새로운 페이지로 이동할 때 페이지의 일부만 다시 렌더링해야 하기 때문에 페이지가 더 빨리 로드됩니다. 전자상거래 세계에서 페이지가 빠르게 로드될수록 더 많은 수익이 발생하니, 이런 기능들을 위해 좀 더 복잡한 프레임워크를 사용하겠죠.\n\n하지만 SaaS 애플리케이션용 대시보드를 개발 중이라면… 이런 부분에 별로 신경 쓰지 않을 거예요. 기능을 빠르게 출시하는 속도를 더 중요하게 생각하고, 복잡성은 개발 팀에 부담이 될 거예요.\n\n제 개인적인 경험과 App Router에 대한 답답함은 다른 사람의 것과 다를 수 있어요. 제품, 사용 사례, 그리고 리소스가 모두 다르기 때문이에요. B2B SaaS 애플리케이션을 많이 작성하고 다른 사람들이 그것을 작성할 때 도와주는 사람으로서 말씀드리면, App Router DX는 Pages Router보다 한 단계 아래 수준이에요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 프레임워크가 성장함에 따라 불가피한가요?\n\n제품/프레임워크가 성장하면 복잡해지는 경향이 있습니다. 고객들이 더 많은 것을 요청합니다. 대규모 고객들은 더 구체적인 것을 요청합니다. 대규모 고객들이 더 많은 금액을 지불하기 때문에 특정 기능을 우선적으로 개발합니다.\n\n이전에 모든 것의 간단함을 좋아했던 고객들은 일부 복잡한 점을 다루어야 한다고 느끼기 시작하고... 오, 보세요, 더 간단한 새로운 프레임워크가 나타났네요. 우리는 그것으로 모두 변경해야 합니다!\n\n이러한 상황을 피하는 것은 어려울 수 있지만, 일부 사람들이 필요로 하는 복잡성을 모두의 문제로 만들지 않는 방법 중 하나입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 그저 뭔가가 추천된다고 해서, 그게 당신에게 맞는 것은 아니라는 뜻은 아니에요\n\n앱 라우터를 사용함에 있어서 제가 겪은 가장 큰 문제 중 하나는 딱 이거였어요:\n\n![이미지](/TIL/assets/img/2024-07-02-ItsnotjustyouNextjsisgettinghardertouse_3.png)\n\nNext.js는 제품으로 충분히 준비되기 전부터 공식적으로 앱 라우터를 사용할 것을 권장해 왔어요. Next.js는 TypeScript, ESLint, Tailwind가 프로젝트에 적합한지 여부에 대한 권장사항을 갖고 있지 않아요 (TS/ESLint에는 기본 값으로 Yes, Tailwind에는 No를 제공하지만, Tailwind 팬들에게는 죄송합니다). 그러나, Next.js는 분명히 당신이 앱 라우터를 사용해야 한다고 믿고 있어요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n공식 React 문서는 같은 의견을 공유하지 않습니다. 현재 그들은 페이지 라우터를 권장하고 앱 라우터를 \"최신형 React 프레임워크\"로 설명하고 있습니다.\n\n그 렌즈를 통해 앱 라우터를 바라볼 때, 더 많은 의미를 부여할 수 있습니다. React에 대한 권장 기본값으로 생각하는 대신, 베타 릴리스로 생각할 수 있습니다. 사용 경험이 더 복잡해지며, 몇 가지 쉬웠던 것들이 지금은 어려워지거나 불가능해졌습니다. 하지만 \"최신형\"인 것으로부터 무엇을 기대하겠습니까?\n\n따라서 다음 프로젝트를 위해 프레임워크를 선택할 때, 앱 라우터에는 여전히 많은 가공되지 않은 점이 있음을 인식하는 것이 중요합니다. 당신의 사용 사례에 더 적합한 다른 도구를 찾는 것이 더 나은 결과를 가져올 수도 있습니다.\n","ogImage":{"url":"/TIL/assets/img/2024-07-02-ItsnotjustyouNextjsisgettinghardertouse_0.png"},"coverImage":"/TIL/assets/img/2024-07-02-ItsnotjustyouNextjsisgettinghardertouse_0.png","tag":["Tech"],"readingTime":9},{"title":"TypeScript와 함께 작업할 때 정직이 최선의 정책인 이유  거짓말의 대가","description":"","date":"2024-07-02 21:49","slug":"2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript","content":"\n![이미지](/TIL/assets/img/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript_0.png)\n\n# 서문\n\n코드베이스로 새로운 풀 리퀘스트 '라이브러리 A 마이너 업데이트'를 받았다고 상상해보세요. 변경 사항을 검토하고 모든 것이 좋아 보입니다: 유닛 테스트를 통과했고, 통합 테스트가 성공했으며, 수동 테스트에서는 문제가 발견되지 않았습니다. 자신감을 갖고 PR을 프로덕션에 병합합니다. 성공적인 배포 후, 한 잠깐 쉬어도 좋을 것 같은 시간에 복어 잇님 모님 캆시 닦고 동료들과 이야기를 나눕니다. 정말 좋은 하루가 되고 있습니다.\n\n그러나 당신이 책상에 돌아가 앉은 순간, 예상치 못한 광경이 당신을 반격합니다: 슬랙 인박스에 99개의 읽지 않은 메시지가 있는 것입니다. 무엇이 잘못되었을까요?\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/TIL/assets/img/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript_1.png)\n\n코드 세계에서 거짓말은 현실 세계에서와 마찬가지로 치명적일 수 있습니다. TypeScript 컴파일러를 속이면 전체 응용 프로그램의 무결성이 위험에 빠집니다. 모든 X와 같이 알 수 없는 것은 시간이 지남에 따라 증가할 수 있는 가격이 따릅니다.\n\n이 기사는 다음 측면을 밝히는 데 목표를 두고 있습니다:\n\n- 코드베이스로 속임수를 도입하는 메커니즘\n- 이러한 실천으로 이어지는 근본적인 이유들\n- 기만의 사이클에서 벗어나 보다 투명한 코딩 접근 방식을 채택하는 전략\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Chapter 1: 속임수의 기술\n\n우선, \"거짓말\"의 정의부터 시작해 봅시다:\n\n하지만 거짓말은 프로그래밍과 무슨 공통점이 있는 걸까요 🤔? 실은 상당히 많은 부분이 비슷합니다.\n\n![이미지](/TIL/assets/img/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript_2.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 거짓의 정의를 이해했으니, 우리에게 한 가지 질문을 해 보겠습니다:\n\n그럼, 한 가지 더 물어볼게요: 코드로 무언가를 수행하려고 하는 상황에서 TypeScript가 너무 엄격하거나 필요한 유연성을 제공하지 않는 상황에 처했던 적이 있나요? 혹시 '유형 단언'이나 명시적 형 변환을 시도해 보았는데, 컴파일러를 속이는 방법으로 기술적으로 올바르지만 예상과 맞지 않는 코드를 수용하도록 했던 적이 있나요?\n\nTypeScript는 우리 코드의 유형을 추론하는 데 탁월한 성과를 거두고 있습니다. 예를 들어, 이 스니펫에서 애완동물의 유형을 완벽하게 포착해냅니다:\n\n```js\nlet pets = [new Dog(), new Cat(), new Bird()];\nlet pets: (Dog | Cat | Bird)[];\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n실제 코딩은 종종 예상과는 다르게 복잡할 때가 많아요!\n\n개발자 생활에서 아래와 같은 경우를 만날 수도 있습니다:\n\n## 사례 1.\n\n```javascript\nconst params = new URL(document.location).searchParams;\nconst name = params.get(\"name\");\n\nconst hello = `Welcome ${name!}`;\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## Case 2.\n\n```js\nimport { ColorsEnum } from 'happy-lib/colors';\nimport { LocalColorsEnum } from '../enums/color';\n...\n\nconst handleColorChange = async (colorToUpdate: LocalColorsEnum) => {\n    await callImaginaryApi('/colors', {\n        color: colorToUpdate as unknown as ColorsEnum\n    })\n}\n```\n\n## Case 3.\n\n```js\ntype UserType = 'admin' | 'superadmin' | 'user'\ntype SpecialUsers = Extract<UserType, 'admin' | 'superadmin'>\n\nconst allowList = ['admin', 'superadmin'] as const satisfies SpecialUsers[];\n\nconst doAdminStuff = (userType: SpecialUsers) => {\n  // magic\n}\n\nconst checkIfAllowed = (userType: UserType) => {\n  if (allowList.includes(userType)) {\n    doAdminStuff(userType as SpecialUsers)\n  }\n}\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 한 발자국 물러나서 이 경우들을 다시 살펴보고 \"거짓말\"을 찾아보세요.\n\n![이미지](/TIL/assets/img/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript_3.png)\n\n찾았나요? 네, 아니오? (혹시라도? 모르겠어요). 네라면, 축하해요 🎉 찾지 못했다면 걱정마시고 계속해서 읽어보세요.\n\n우리 함께 모든 경우를 해결해 낼 거에요 💪.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 케이스 1\n\n```js\nconst params = new URL(document.location).searchParams;\nconst name = params.get(\"name\");\n\nconst hello = `환영합니다, ${name}님!`;\n```\n\n여기에는 URL에서 검색 매개변수를 구문 분석하는 클래식 프론트엔드 사례가 있습니다. 이름 매개변수를 검색하고 환영 메시지를 반환하려고 합니다. 안타깝게도, 이 코드는 거짓말을 하고 있습니다.\n\n```js\nconst hello = `환영합니다, ${name}님!`;\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n당신이 왜 이것을 문제로 생각하는지 궁금할 수도 있습니다. URL에 이름 매개변수가 없는 경우, \"이름이 정의되지 않은 상태에서 '안녕하세요'가 표시됩니다. 코드에는 TypeScript에게 모든 것이 괜찮다고 확신하는! - non-null assertion operator가 포함되어 있습니다. (여기서는 사실이 아닙니다 😠). 우리에게 다행히, 해결책은 간단합니다:\n\n```js\nconst params = new URL(document.location).searchParams;\nconst name = params.get(\"name\");\n\nif (!name) {\n  // 오류 케이스를 좀 더 세련되게 처리\n}\n\nconst hello = `환영합니다 ${name}`;\n```\n\nTypeScript를 사용하여 narrowing을 하고, 오래된 if 문의 도움으로 이제 if 블록 바깥에서 name을 사용할 때 항상 값이 있다고 확신할 수 있습니다. 잠재적인 오류를 숨겨도 오류가 사라질 것이라는 보장은 없다는 것을 기억하는 것이 매우 중요합니다.\n\n## 케이스 2\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport { ColorsEnum } from 'happy-lib/colors';\nimport { LocalColorsEnum } from '../enums/color';\n...\n\nconst handleColorChange = async (colorToUpdate: LocalColorsEnum) => {\n    await callImaginaryApi('/colors', {\n        color: colorToUpdate as unknown as ColorsEnum\n    })\n}\n```\n\n여기서 볼 수 있는 것은 상상 속의 API를 사용하여 색상을 업데이트하는 간단한 경우입니다. 현재 코드가 어떻게 보이는지에 따라 모든 것이 괜찮아 보입니다. 수동으로 작동을 테스트하고 유닛 테스트를 추가했습니다. 네, colorToUpdate을 다른 열거형으로 수용하지만, 값이 동일하고 변경되지 않을 것을 알고 있습니다.\n\n불행하게도, 위의 줄은 거짓말이 들어 있으며 찾기 어려운 것입니다.\n\n아래 줄에 집중해보겠습니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n...\ncolor: colorToUpdate as unknown as ColorsEnum\n...\n```\n\n이 코드는 TypeScript에게 다음을 알려줍니다:\n\nhappy-lib/colors 패키지가 주요 패치를 받을 경우를 가정해 봅시다. 알 수없는 이유로 ColorsEnum이 변경되어 열거형의 키 케이싱이 바뀝니다. 이러한 열거형은 더 이상 동일한 값을 보유하지 않습니다. TypeScript 컴파일러는 이러한 사항에 대해 경고하지 않고 단위 테스트에서는 문제를 포착하지 못할 것입니다. 이 문제를 포착하는 것은 수동 또는 엔드투엔드 테스트에 달려 있습니다. 그러나 이럴 필요는 없습니다.\n\n우리는 진실을 이야기하기 위해 이 코드를 다시 작성해보겠습니다. 이 연습의 목적을 위해 colorToUpdate 유형을 변경할 수 없으며, 이 작업을 함수 내부에서 처리해야 합니다. TypeScript(또는 JavaScript)에서 열거형을 비교하는 것은 어렵습니다. 우리가 할 수 있는 것은 번역기를 작성하거나(또는 사전을 사용하는 것)하는 것입니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nfunction transformColorEnum(localColor: LocalColorsEnum): ColorsEnum | null {\n  switch (localColor.toString()) {\n    case LocalColorsEnum.Red:\n      return ColorsEnum.Red;\n    case LocalColorsEnum.Green:\n      return ColorsEnum.Green;\n    case LocalColorsEnum.Blue:\n      return ColorsEnum.Blue;\n    default:\n      return null;\n  }\n}\n\nconst handleColorChange = async (colorToUpdate: LocalColorsEnum) => {\n  const translatedColor = transformColorEnum(colorToUpdate);\n\n  if (!translatedColor) {\n    // 에러 케이스를 처리하세요\n  }\n\n  await callImaginaryApi(\"/colors\", {\n    color: colorToUpdate,\n  });\n};\n```\n\n여기서 우리는 무엇을 달성했을까요? 이제 API 변경으로 인해 잘못된 값이 전송되는 경우를 방지할 수 있게 되었습니다.\n\n맞아요. 이 코드를 개선할 다양한 방법이 있습니다(어떤 라이브러리도 사용하지 않고도), 하지만 이번에는 Zod 라이브러리를 사용하여 이를 처리하는 방법을 보여드리고 싶었어요:\n\n```js\nimport z from \"zod\";\n\nconst handleColorChange = async (colorToUpdate: LocalColorsEnum) => {\n  const translatedColor = z.nativeEnum(ColorsEnum).safeParse(colorToUpdate);\n\n  if (!translatedColor.success) {\n    // 에러 케이스를 처리하세요\n  }\n\n  await callImaginaryApi(\"/colors\", {\n    color: colorToUpdate,\n  });\n};\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 케이스 3\n\n```js\ntype UserType = 'admin' | 'superadmin' | 'user'\ntype SpecialUsers = Extract<UserType, 'admin' | 'superadmin'>\n\nconst allowList = ['admin', 'superadmin'] as const satisfies SpecialUsers[];\n\nconst doAdminStuff = (userType: SpecialUsers) => {\n  // magic\n}\n\nconst checkIfAllowed = (userType: UserType) => {\n  if (allowList.includes(userType)) {\n    doAdminStuff(userType as SpecialUsers)\n  }\n}\n```\n\n이미 1과 2번 케이스를 해결했다면, 여기서 형 변환을 하고 있다는 것을 빠르게 지적할 수 있을 것입니다. 그리고 당신은 맞을 것입니다! 다행히 이번에는 상황이 심각하지는 않습니다. 사용자가 권한 배열에 포함되어 있는지 확인하기 때문에 안전합니다. 그러나 우리는 가져야 할 정보 유형을 잃어버렸습니다. 거의 동일한 로직을 유지하면서 정보 유형을 복구해 봅시다.\n\n```js\ntype UserType = 'admin' | 'superadmin' | 'user';\ntype SpecialUsers = Extract<UserType, 'admin' | 'superadmin'>;\n\nconst allowList = ['admin', 'superadmin'] as const satisfies SpecialUsers[];\n\nconst doAdminStuff = (userType: SpecialUsers) => {\n  // magic\n};\n\nconst isSpecialUser = (userType: UserType): userType is SpecialUsers => {\n  return allowList.includes(userType as SpecialUsers);\n};\n\nconst checkIfAllowed = (userType: UserType) => {\n  if (isSpecialUser(userType)) {\n    doAdminStuff(userType);\n  }\n};\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 형변환(casting)이 안전한 이유는 `isSpecialUser` 유형 가드 함수 내부에서 사용하기 때문입니다. TypeScript는 includes 확인이 통과되면 `userType`이 `SpecialUsers` 유형이어야 한다는 것을 이해합니다. 따라서 형변환은 안전하며 유형 안전성을 위반하지 않습니다. 이렇게 하면 `userType` 변수는 if 블록의 범위 내에서 `SpecialUsers` 유형을 유지합니다.\n\n![이미지](/TIL/assets/img/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript_4.png)\n\n3/3 사건 마무리 수사관 - 훌륭한 일했어요.\n\n# 2장: 거짓말의 해부학.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저희 코드에서 문제점을 파악했습니다. 이제는 그 문제들이 처음에 발생한 이유를 이해해야 합니다.\n\n코딩 세계에서는 종종 특정 목표를 이루기 위해 의도적으로 유형이나 데이터 구조를 조작하는 상황에 처합니다. 실생활에서 무언가에 대해 확신이 없거나 단축키를 사용하길 원할 때 사람들이 진실을 왜곡하는 것과 비슷한 상황이죠.\n\n## 알 수 없는 데이터\n\n가장 일반적으로 '거짓말'을 하는 경우는 데이터가 불확실한 출처에서 올 때입니다. 예를 들어, 이 코드 조각을 살펴보죠:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n// API에서 사용자 데이터를 가져옵니다\nconst response = await getUsers();\nconst users = await response.json();\n```\n\n사용자가 특정 유형임을 정확히 알 수 있을까요? 대부분, 다음과 같은 것을 볼 수 있습니다:\n\n```js\nconst users: Users = await response.json() as Users;\n```\n\n대부분의 경우에는 잘 작동합니다. 그러나 이 코드는 실제로 안전하지 않습니다. 우리가 호출하는 엔드포인트가 지정된 형식의 데이터를 반환하는지 알 방법이 없습니다. 유형 단언(as Users)을 사용하여 사실상 코드에 거짓말을 하고 원하는 것이 맞다고 코드에 알려주는 것입니다. 하지만 이러한 \"소백한 거짓말\"은 종종 미래 문제의 근본 원인이 되며 오류 케이스를 무시합니다. getUsers가 반환하는 유형이 변경되면 어떻게 될까요? TypeScript에 모든 것이 괜찮고 특정 유형(e.g., Users)이 반환될 것이 확실하다고 확신할 수 있지만, 실제로는 코드가 예기치 않은 유형을 처리할 준비가 되어 있지 않습니다. 이는 프로덕션 코드를 망가뜨릴 수 있는 런타임 오류로 이어질 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/TIL/assets/img/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript_5.png\" />\n\n## 게으름 (좋은겁니다 😎)\n\n가끔은 사소해 보이지만 디버깅하기 어려울 수 있는 거짓말도 있어요.\n\n예를 들어 단위 테스트에서 대량의 모의 객체가 있는 경우를 생각해봅시다. 특정 속성만 신경 쓰지만 자동완성과 타입 안전성의 이점을 원한다면, 이런 식의 코드가 될 수 있습니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nconst veryBigObjectMock: BigObjectType = {\n    ...{} as BigObjectType,\n    keyIWantToMock: 'myMock'\n};\n```\n\n컴파일러가 만족하고 테스트가 의도대로 실행됩니다...지금까지는요. 그러나 어느 날 테스트가 실패하면서 데이터 구조가 변경되었다는 것을 알고 있음에도 TypeScript의 타입 체커(tsc)가 문제를 보고하지 않는 것을 발견할 수 있습니다. 아마도 당신이 로직을 잘못 이해한 것인지 생각해 볼지도 모르겠죠.\n\n무엇이 잘못되었는지 알아내려고 몇 시간을 낭비한 후, 오래된 키 이름을 가진 잊혀진 목 객체를 기억낼 수 있습니다. 시간을 낭비한 셈이죠.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 준비되지 않은 데이터 사용\n\n준비되지 않은 데이터를 사용하는 것은 일반적인 함정일 수 있습니다. 우리는 밑바닥 데이터를 안전하게 사용할 수 있는지 확인하지 않고 속성이나 메서드에 액세스하려는 유혹을 느낄 수 있습니다.\n\n예를 살펴봅시다. 비동기적으로 가져온 할 일 항목을 표시하는 TodoList 컴포넌트가 있다고 가정해 봅시다. 이 할 일 항목은 리덕스의 useSelector 훅을 통해 반환됩니다 (물론 다른 상태 관리 라이브러리일 수도 있습니다):\n\n```js\nimport * as React from \"react\";\nimport { useSelector } from \"react-redux\";\n\ntype Todo = { id: string, name: string };\n\nconst TodoList = () => {\n  const todos: Todo[] | null = useSelector((state) => state.todos);\n\n  return (\n    <ul>\n      {todos?.map((todo) => (\n        <li key={todo.id}>{todo.name}</li>\n      ))}\n    </ul>\n  );\n};\nexport default TodoList;\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 컴포넌트를 사용할 때는 잘 렌더링됩니다. 그러나 주의 깊게 관찰하거나 인터넷 연결이 느린 경우에는 1초 미만의 깜빡임이 발생할 수도 있습니다. 하지만 받는 데 시간이 걸리는 경우나 애플리케이션에서 할 일 항목에 대한 실시간 업데이트를 보여주려는 경우에는 어떨까요? 이 순진한 방법을 사용하면 사용자 경험이 좋지 않을 수 있습니다. TypeScript는 할 일 항목이 비어 있을 수 있다고 알려줬는데도 우리는 그 경고를 무시하기로 결정했습니다.\n\n# 제 3장: 진실의 힘.\n\n![이미지](/TIL/assets/img/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript_6.png)\n\n지금까지 코드에서 거짓이 어떻게 보이는지와 그 코드베이스에 나타난 이유에 중점을 두었습니다. 그러나 우리는 진실을 말할 수 있는 방법이 무엇이며 어떻게 거짓을 멈출 수 있을까요?\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다행히도, 쉬운 일은 아니지만 우리 삶을 많이 개선해 줄 것입니다.\n\n**Typescript을 믿으세요.**\n\nTypescript는 당신을 위해 최선을 다해줍니다. 당신에게 경고를 주고 실수를 예방해줍니다. 코드에서 보이는 오류와 경고에는 그 이유가 있습니다.\n\n**엄격한 eslint 및 tsconfig 규칙을 추가하세요.**\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n자동화할 수 있는 것은 자동화하고 엄격한 @typescript-eslint 구성을 사용하세요. 이는 오류를 보여주는 것뿐만 아니라 미래 실수를 방지하는 데 도움이 될 수 있습니다. 최상의 관행과 권장 사항을 사용하여 tsconfig를 설정하세요 (예: https://www.totaltypescript.com/tsconfig-cheat-sheet). 이렇게 하면 올바른 방향으로 유지될 수 있습니다. 수동으로 확인할 필요가 줄수록 더 좋습니다.\n\n## TypeScript에게 일을 시키세요.\n\nif-else 조건문 및 switch 문과 같은 흐름 제어문을 사용하면 TypeScript가 변수 유형에 대한 이해를 더욱 정확하게 할 수 있습니다. 다음과 같이 할 수 있습니다:\n\n```js\nconst optionalValue: string | null = getOptionalValue();\n\nif (!optionalValue) {\n  return;\n} else {\n  // 코드의 나머지 부분\n}\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\noptionalValue에 값이 항상 있으므로 else 본문에서 수동 타입 체크가 필요하지 않습니다.\n\n## 확실히 움직이세요.\n\n값이 undefined 또는 null일 가능성이 있는 경우, 그러한 경우가 발생할 가능성이 높으므로 이에 대비하고 정상적으로 처리하세요. 입력 유효성 검사, 방어적 프로그래밍 및 타입 체크를 통해 가능성을 좁힙니다. 기본값 제공, 오류 처리 구현, 그리고 작업 전에 이러한 경우를 확인하고 처리하는 방어적 코드 작성과 같은 전략을 활용하세요.\n\n## 런타임에서 유효성 검사하세요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예방 조치인 입력 유효성 검사와 유형 검사와 같은 것들은 중요하지만, 알려지지 않거나 신뢰할 수 없는 객체를 다룰 때는 런타임에 데이터를 유효성 검사하는 것이 매우 중요합니다. 이를 달성하는 강력한 도구 중 하나는 zod입니다. TypeScript를 기반으로 한 스키마 유효성 검사 라이브러리로 데이터의 예상 형태와 유형을 정의하는 엄격한 스키마를 설정할 수 있습니다. 데이터 구조물의 청사진과 같은 개념입니다! Zod를 사용하면 런타임에서 잘못된 또는 예기치 않은 데이터에 대해 경고를 내어주는 강력한 스키마를 만들 수 있습니다. 예를 들어, 외부 API나 사용자 입력에서 데이터를 받는 경우, 해당 데이터의 예상 구조를 나타내는 Zod 스키마를 정의하고 해당 스키마를 사용하여 들어오는 데이터를 유효성 검사할 수 있습니다. 이를 통해 지정된 유형, 형태 및 제약 조건을 준수하는지 확인할 수 있습니다. 데이터가 이러한 기대에 미치지 않는 경우, Zod는 유용한 오류를 발생시켜 이 문제를 세련되게 처리할 수 있게 도와줍니다. 또한, 유형 가드나 어서션 함수와 같은 기술을 구현하는 자체 파서를 작성할 수도 있습니다.\n\n# Chapter 4: 마무리.\n\nTypeScript의 타입 어설션을 사용하면 값의 유형에 대해 컴파일러에게 거짓 정보를 전달할 수 있습니다. 유효한 사용 사례가 제한적이지만 자주 남용되며, 정적 유형 확인 목적을 해치는 잔인한 유형 오류를 초래할 수 있습니다.\n\n완벽한 세상에서는 사용하는 라이브러리에서 모든 타이핑을 처리할 수 있고 가능한 한 순수 JavaScript에 가까운 코드만 작성할 수 있을 것입니다. 불행하게도, 이것은 현실적으로 어렵고, 타입을 어떻게 구조화할지에 대해 신중해야 합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nTypeScript는 개발자가 오류를 잡고 코드 품질을 향상시키는 데 도움을 주도록 설계되었지만, 마법같은 해결책은 아닙니다. 여전히 그 아래에는 옛날의 JavaScript가 있다는 것을 기억해야 합니다. TypeScript는 정적 유형 검사를 위한 강력한 도구를 제공하지만 모든 잠재적인 런타임 오류를 제거할 수는 없습니다.\n\n이 글을 처음부터 끝까지 함께 읽어주셔서 감사합니다. 그리고 기억하세요:\n\n거짓말 하지 마세요.\n\n![이미지](/TIL/assets/img/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript_7.png)\n","ogImage":{"url":"/TIL/assets/img/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript_0.png"},"coverImage":"/TIL/assets/img/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript_0.png","tag":["Tech"],"readingTime":19},{"title":"Nextjs에서 Tailwind와 Swiper로 썸네일 슬라이더 만드는 방법","description":"","date":"2024-07-02 21:47","slug":"2024-07-02-CreatingaThumbnailSliderinNextjswithTailwindandSwiper","content":"\n## Next.js, Tailwind CSS, 및 Swiper를 사용하여 썸네일 슬라이더 만들기 단계별 가이드\n\n썸네일은 더 큰 이미지의 작은 이미지 표현입니다.\n\n썸네일 슬라이더는 클릭할 수 있는 주요 이미지와 그 아래 일련의 썸네일을 포함하는 슬라이더입니다.\n\n위 내용을 기반으로, Next.js, Tailwind CSS, 및 Swiper를 사용하여 자체 썸네일 슬라이더를 만드는 것을 시작해보겠습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 프로젝트 설정\n\n우선, 새로운 Next.js 프로젝트를 설정해보세요. 터미널을 열고 다음 명령어를 실행하세요:\n\n```js\nnpx create-next-app@latest\n```\n\n그런 다음에 뒤이어 나오는 프롬프트에 답변하세요. 내 개인적인 답변은 각 줄의 괄호 안에 있습니다. \"Tailwind CSS\"에 대해 \"Yes\"로 선택하는 것을 잊지 마세요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n프로젝트의 이름은 무엇인가요? my-app (thumbnail-slider)\n\nTypeScript를 사용하시겠습니까? 아니요 / 예 (예)\n\nESLint를 사용하시겠습니까? 아니요 / 예 (예)\n\nTailwind CSS를 사용하시겠습니까? 아니요 / 예 (예)\n\n`src/` 디렉토리를 사용하시겠습니까? 아니요 / 예 (아니요)\n\nApp Router를 사용하시겠습니까? (권장) 아니요 / 예 (예)\n\n기본 import 별칭 (@/*)을 사용자 정의하시겠습니까? 아니요 / 예 (아니요)\n```\n\n다음으로, 프로젝트 디렉토리에 들어간 후에 Swiper를 설치하세요.\n\n```js\nnpm install swiper\n```\n\n# 썸네일 슬라이더 구축하기\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 Thumbnail Slider를 구축하기 위한 필수 구성 요소를 생성해 봅시다.\n\n- 프로젝트 디렉토리에 components라는 새 디렉토리를 만듭니다.\n- components 디렉토리 내부에 ThumbnailSlider.tsx 또는 .jsx라는 새 파일을 만듭니다(typescript를 사용하지 않는 경우).\n\n## 필수 구성 요소 가져오기\n\nswiper에 필요한 가져오기를 추가하는 것부터 시작해 봅시다. 아래 코드를 그대로 복사하세요:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n\"use client\";\n\nimport React, { useState } from \"react\";\nimport Image from \"next/image\";\n\n// Swiper React 컴포넌트 가져오기\nimport { Swiper, SwiperSlide } from \"swiper/react\";\n\n// Swiper 유형 가져오기\nimport { Swiper as SwiperType } from \"swiper\";\n\n// Swiper 스타일 가져오기\nimport \"swiper/css\";\nimport \"swiper/css/navigation\";\nimport \"swiper/css/thumbs\";\n\n// 필요한 모듈 가져오기\nimport { Thumbs } from \"swiper/modules\";\n```\n\n설명:\n\n- 컴포넌트 가져오기: Swiper 및 SwiperSlide는 Swiper 라이브러리의 React 모듈에서 가져옵니다. 이러한 컴포넌트는 캐러셀/슬라이더와 개별 슬라이드를 만들고 관리하는 데 사용됩니다.\n- 유형 가져오기: Swiper as SwiperType은 TypeScript 유형 안전성을 위해 가져옵니다. 이를 통해 적절한 코드 지원과 오류 확인이 가능합니다.\n- 스타일 가져오기: Swiper CSS 파일을 가져와서 캐러셀에 필요한 중요한 스타일을 적용합니다. 이는 네비게이션 버튼 및 썸네일 네비게이션을 포함합니다.\n- Thumbs 모듈: Thumbs는 \"swiper/modules\"에서 가져온 것입니다. 이 모듈은 Swiper 슬라이더의 썸네일 네비게이션 기능을 제공합니다.\n\n## 개별 컴포넌트 생성하기\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 썸네일 슬라이더 컴포넌트를 만들어볼 차례에요. 슬라이더 컴포넌트와 썸네일 컴포넌트와 함께 만들 것인데요, 이들은 한 컴포넌트에 모은 코드양을 줄이기 위해 분리되어 있어요.\n\n```js\nconst ThumbnailSlider = ({ images }: { images: string[] }) => {\n  return (\n    // 메인 슬라이더와 썸네일 슬라이더를 담는 컨테이너\n    <div className=\"w-4/5 h-4/5 flex flex-col gap-4\">\n      <Slider images={images} /> {/* 메인 이미지 슬라이더 */}\n      <Thumbnail images={images} /> {/* 썸네일 내비게이션 슬라이더 */}\n    </div>\n  );\n};\n\nconst Slider = ({ images }: { images: string[] }) => {\n  return (\n    // 메인 이미지 슬라이더 컴포넌트\n    <div className=\"w-full h-full flex-1 overflow-hidden\">\n      <Swiper className=\"h-full\" grabCursor loop>\n        {/* 각 이미지 슬라이드를 만들기 위해 이미지를 반복합니다. */}\n        {images.map((image, index) => (\n          <SwiperSlide key={index}>\n            <div className=\"relative w-full h-full\">\n              {/* 각 슬라이드의 이미지 컴포넌트 */}\n              <Image\n                src={image}\n                alt=\"slide\"\n                fill\n                className=\"object-cover\"\n                sizes=\"70vw\"\n                priority={index === 0 && true} // 첫 번째 이미지가 우선적으로 로드되도록 합니다.\n              />\n            </div>\n          </SwiperSlide>\n        ))}\n      </Swiper>\n    </div>\n  );\n};\n\nconst Thumbnail = ({ images }: { images: string[] }) => {\n  return (\n    // 썸네일 내비게이션 슬라이더 컴포넌트\n    <div className=\"relative flex gap-2 justify-center h-14\">\n      <Swiper className=\"w-2/4 h-full\" loop slidesPerView={4} spaceBetween={8}>\n        {/* 각 썸네일을 만들기 위해 이미지를 반복합니다. */}\n        {images.map((image, index) => (\n          <SwiperSlide\n            key={index}\n            className=\"rounded-md cursor-pointer border-[3px] border-solid border-transparent overflow-hidden\"\n          >\n            <div className=\"relative w-full h-full\">\n              {/* 썸네일 이미지 컴포넌트 */}\n              <Image src={image} alt=\"thumbnail\" fill className=\"object-cover\" sizes=\"100px\" />\n            </div>\n          </SwiperSlide>\n        ))}\n      </Swiper>\n    </div>\n  );\n};\n\nexport default ThumbnailSlider;\n```\n\n## 슬라이더와 썸네일 컴포넌트 연결하기\n\n여기까지 오면 썸네일 슬라이더는 거의 완성되었어요. 유일한 문제는 현재 각각 따로 움직인다는 것이죠. 하지만 우리가 원하는 것은 이들이 연결된 것처럼 함께 움직이도록 하는 것입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이를 달성하기 위해 ThumbnailSlider 컴포넌트에 다음을 추가할 것입니다:\n\n```js\nconst [thumbsSwiper, setThumbsSwiper] = (useState < SwiperType) | (null > null);\n```\n\n그런 다음 이를 Slider 및 Thumbnail 컴포넌트로 props로 전달하세요.\n\n```js\n<Slider images={images} thumbs={ thumbsSwiper, setThumbsSwiper } />\n<Thumbnail images={images} thumbs={ thumbsSwiper, setThumbsSwiper } />\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n물론, Slider 및 Thumbnail 컴포넌트에 새로운 속성(props)을 전달하고 있기 때문에 해당 코드를 업데이트해야 합니다.\n\nTypescript를 사용 중이라면, 다음과 같이 타입 안전성을 위한 인터페이스를 붙여넣으세요:\n\n```js\ninterface SliderProps {\n  images: string[];\n  thumbs: {\n    thumbsSwiper: SwiperType | null,\n    setThumbsSwiper: React.Dispatch<React.SetStateAction<SwiperType | null>>,\n  };\n}\n```\n\n이제 정의한 상태를 사용하도록 Slider 및 Thumbnail 컴포넌트를 편집해 보겠습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n슬라이더 컴포넌트에서 다음 작업을 수행하십시오:\n\n```js\nconst Slider = ({ images, thumbs }: SliderProps) => {\n  const { thumbsSwiper } = thumbs;\n\n  return (\n    <div className=\"w-full h-full flex-1 overflow-hidden\">\n      {/* 이미지 슬라이더용 주 스와이퍼 컴포넌트 */}\n      <Swiper\n        className=\"h-full\"\n        grabCursor\n        loop\n\n        thumbs={{ swiper: thumbsSwiper }} // 메인 슬라이더를 썸네일 싱크를 위해 썸네일 스와이퍼에 연결\n        modules={[Thumbs]} // 썸네일 탐색을 위해 Thumbs 모듈을 활성화\n      >\n       // 이전 코드를 여기에 추가하세요...\n      </Swiper>\n    </div>\n```\n\n썸네일 컴포넌트에서 다음 작업을 수행하십시오:\n\n```js\nconst Thumbnail = ({ images, thumbs }: SliderProps) => {\n  const { setThumbsSwiper } = thumbs;\n\n  return (\n    <div className=\"relative flex gap-2 justify-center h-14\">\n      {/* 썸네일 탐색용 스와이퍼 컴포넌트 */}\n      <Swiper\n        className=\"w-2/4 h-full\"\n        loop\n        slidesPerView={4} // 한 뷰 당 썸네일 수\n        spaceBetween={8} // 썸네일 간 간격\n        onSwiper={setThumbsSwiper} // 컴포넌트가 마운트될 때 썸네일 스와이퍼 설정\n        freeMode // 스냅 포인트 없이 자유롭게 슬라이딩 허용\n        watchSlidesProgress // 썸네일의 슬라이드 진행 상황을 감시\n      >\n        // 이전 코드를 여기에 추가하세요...\n      </Swiper>\n    </div>\n  );\n};\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 활성 썸네일 요소 스타일링\n\n지금은 섬네일 슬라이더가 제대로 작동해야 하지만, 현재 활성화된 썸네일을 강조하고 싶다면 globals.css 파일을 /app 디렉토리에서 열어서 다음 CSS 코드를 추가할 수 있어요:\n\n```js\n.swiper-slide-thumb-active {\n    border-color: black;\n}\n```\n\n## 썸네일 슬라이더 컴포넌트 사용하기\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n최종적으로 코드에서 썸네일 슬라이더를 사용하려면 간단히 가져와서 다음과 같이 호출하면 됩니다:\n\n```js\nimport ThumbnailSlider from \"@/components/ThumbnailSlider\";\n\nexport default function Home() {\n  return (\n    <main className=\"w-full h-screen flex items-center justify-center\">\n      <ThumbnailSlider images={images} />\n    </main>\n  );\n}\n```\n\n썸네일 슬라이더가 작동하려면 이미지 URL을 나타내는 문자열 배열을 제공해야 합니다. 아래는 그 예시입니다:\n\n```js\n// 별칭을 사용하여 components 디렉토리에서 ThumbnailSlider 컴포넌트 가져오기\nimport ThumbnailSlider from \"@/components/ThumbnailSlider\";\n\n// 홈 페이지를 위한 기본 함수 컴포넌트\nexport default function Home() {\n  // 동적으로 생성된 이미지 URL 배열\n  const images = Array(4)\n    .fill(null)\n    .map((_, index) => `/random/image (${index + 1}).png`);\n\n  // 주요 콘텐츠 영역 렌더링\n  return (\n    <main className=\"w-full h-screen flex items-center justify-center\">\n      {/* 동적으로 생성된 이미지를 사용하여 ThumbnailSlider 컴포넌트 렌더링 */}\n      <ThumbnailSlider images={images} />\n    </main>\n  );\n}\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위 글을 읽어주셔서 정말 감사합니다! 😊\n만약 이 글이 도움이 되었다면 반드시 박수를 치고 팔로우해주세요! 👏\n","ogImage":{"url":"/TIL/assets/img/2024-07-02-CreatingaThumbnailSliderinNextjswithTailwindandSwiper_0.png"},"coverImage":"/TIL/assets/img/2024-07-02-CreatingaThumbnailSliderinNextjswithTailwindandSwiper_0.png","tag":["Tech"],"readingTime":11},{"title":"코믹 힙에서 요소 추가 및 제거 과정 이해하기","description":"","date":"2024-07-02 21:45","slug":"2024-07-02-ComicHowAddingRemovingStuffFromHeapsWork","content":"\n![image](/TIL/assets/img/2024-07-02-ComicHowAddingRemovingStuffFromHeapsWork_0.png)\n\n# 간단한 소개\n\n힙(heap)은 우선순위 큐(priority queue)의 구현 방식입니다. 힙에서는 우선 순위가 가장 높은 요소가 먼저 나갑니다. 우선 순위는 다음과 같이 정의될 수 있습니다:\n\n- 최대 힙(max heap)의 경우 가장 큰 숫자가 먼저 나갑니다.\n- 최소 힙(min heap)의 경우 가장 작은 숫자가 먼저 나갑니다.\n","ogImage":{"url":"/TIL/assets/img/2024-07-02-ComicHowAddingRemovingStuffFromHeapsWork_0.png"},"coverImage":"/TIL/assets/img/2024-07-02-ComicHowAddingRemovingStuffFromHeapsWork_0.png","tag":["Tech"],"readingTime":1}],"page":"18","totalPageCount":19,"totalPageGroupCount":1,"lastPageGroup":19,"currentPageGroup":0},"__N_SSG":true}