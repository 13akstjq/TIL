{"pageProps":{"posts":[{"title":"Leetcode 200 섬의 개수 완벽 정복 가이드","description":"","date":"2024-07-09 09:07","slug":"2024-07-09-PerfectingLeetcode200NumberofIslands","content":"\n\nLeetCode의 \"섬의 개수\" 문제는 '1' (육지)과 '0' (물)로 구성된 m x n 그리드가 포함되어 있습니다. 이 문제는 그리드 내의 섬의 개수를 결정하는 것입니다. 여기서 섬은 수평 또는 수직으로 연결된 '1'의 그룹으로 정의되며, 물 ('0')로 완전히 둘러싸여 있습니다.\n\n<img src=\"/assets/img/2024-07-09-PerfectingLeetcode200NumberofIslands_0.png\" />\n\n예를 들어, 예제 1에서는 총 3개의 섬이 있고, 예제 2에서는 하나의 섬이 있습니다. 중요한 점은 '1'들이 수평 또는 수직 연결을 통해서만 다른 '1'들에 연결될 수 있다는 것입니다.\n\n## 그래서, 이 문제에 적합한 알고리즘은 무엇일까요?\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 문제는 그리드를 탐색하고 인접한 노드들을 체계적으로 탐색해야 하기 때문에 BFS가 가장 효율적인 알고리즘입니다. 그리드나 그래프 구조에서 연결된 구성 요소를 탐색하고 식별할 수 있는 능력은 이 작업에 잘 어울립니다.\n\n## BFS가 그리드에서 섬을 발견하는 방식을 시각화해 봅시다!\n\n- 알고리즘은 각 셀을 탐색하면서 그리드 안의 행과 열을 하나씩 탐색합니다.\n- 방문하지 않은 '1'로 표시된 셀을 탐색하기 위해 BFS를 사용합니다. 작업을 최적화하고 중복 방문을 피하기 위해 '방문함' 집합을 사용하여 이미 탐색한 노드를 추적합니다.\n- BFS는 방문해야 할 다음 노드를 유지하기 위해 큐도 필요합니다.\n\n![그림](/assets/img/2024-07-09-PerfectingLeetcode200NumberofIslands_1.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 셀 [0, 0]에서 탐사를 시작합니다. '1'이 포함되어 있기 때문에 섬의 일부로 간주되어 'visited' 세트에 추가됩니다. 이제 [0, 0]에서 4가지 방향으로 이동할 수 있습니다: [0, 1], [1, 0], [-1, 0], [0, -1]. 그리드를 벗어나지 않도록 하기 위해 [1, 0]과 [0, 1]만 남습니다. 이 두 셀은 현재 탐색 중인 동일한 섬의 일부라는 것을 나타내는 '1'입니다. 따라서 이러한 셀을 큐에 추가하여 다음에 방문합니다. (그림 1)\n- 다음으로 [1, 0]을 pop하고 visited 세트에 추가합니다. [1, 0]에서 4방향으로 갈 수 있습니다: [0, 0], [1, -1], [1, 1], [2, 0]. 그리드를 벗어나지 않기 때문에 [1, -1]을 버립니다. [0, 0]은 이미 방문했으므로 방문을 스킵합니다. [2, 0]은 '0'이므로 물이므로 방문할 필요가 없습니다. 방문되지 않은 [1, 1]은 '1'이므로 큐에 추가합니다. (그림 2)\n- '1'을 보면 새로운 셀을 큐에 추가하면서 계속해서 큐에서 셀을 탐색합니다. 현재 조사 중인 섬에 더 이상 탐색할 '1'이 없을 때까지 큐는 활성 상태를 유지합니다. 해당 섬을 완전히 탐색하면 그 섬에 대한 BFS가 중지됩니다. 한 섬을 완전히 탐사한 후에는 그리드에서 추가적인 섬이 있는지 검색합니다. (그림 3 및 그림 4)\n\n![그림](/assets/img/2024-07-09-PerfectingLeetcode200NumberofIslands_2.png)\n\n- [2, 2] 셀의 경우 주변에 계속 탐색할 '1'이 없습니다. 이것은 다른 섬의 발견을 나타냅니다. 이 시점에서 큐가 비어 있으므로 다음 BFS 이터레이션으로 넘어갑니다.\n\n![그림](/assets/img/2024-07-09-PerfectingLeetcode200NumberofIslands_3.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- [3, 3]에 위치하면 [3, 4]로만 이동할 수 있습니다. 여전히 발견되지 않은 '1' 이므로 큐에 넣어줍니다.\n- [3, 4]를 팝하여 방문했다고 표시하고, 주변에 더 이상 발견되지 않은 '1'이 없기 때문에, 이 섬을 대상으로 하는 BFS 및 이후 알고리즘을 완료합니다.\n\n따라서, 총 3개의 섬을 찾았습니다.\n\n## 파이썬 구현:\n\n```js\nimport collections\n\nclass Solution(object):\n def numIslands(self, grid):\n  \n  if not grid:\n   return 0\n  \n  islands = 0\n  visited = set()\n  rows, cols = len(grid), len(grid[0])\n  directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]\n\n  def bfs(r, c):\n   q = collections.deque()\n\n   visited.add((r, c))\n   q.append((r, c))\n\n   while q: \n    cur_r, cur_c = q.popleft()\n\n    for dr, dc in directions:\n\n     new_dr = cur_r + dr\n     new_dc = cur_c + dc\n\n     if (new_dr in range(rows) and new_dc in range(cols) and\n      grid[new_dr][new_dc] == \"1\" and (new_dr, new_dc) not in visited):\n      \n      visited.add((new_dr, new_dc))\n      q.append((new_dr, new_dc))\n\n  for r in range(rows):\n   for c in range(cols):\n    if (grid[r][c] == \"1\" and \n     (r, c) not in visited):\n     bfs(r, c)\n     islands += 1\n  \n  return islands\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 시간 복잡도:\n\n그래서, m x n 그리드에서, 여기서 m은 행의 수를 나타내고 n은 열의 수를 나타냅니다. 이 알고리즘은 각 셀을 정확히 한 번씩 통과합니다. 따라서, 이 알고리즘의 전체 시간 복잡도는 O(m×n)입니다.\n\n읽어 주셔서 감사합니다! 즐거운 코딩하세요!","ogImage":{"url":"/assets/img/2024-07-09-PerfectingLeetcode200NumberofIslands_0.png"},"coverImage":"/assets/img/2024-07-09-PerfectingLeetcode200NumberofIslands_0.png","tag":["Tech"],"readingTime":5},{"title":"Apache Airflow와 Amazon-S3를 사용한 End-to-End ETL 파이프라인 구축 하는 방법","description":"","date":"2024-07-09 09:06","slug":"2024-07-09-End-to-EndETLPipelinewithApacheAirflowandAmazon-S3","content":"\n\n# 프로젝트 개요\n\n이 프로젝트는 Apache Airflow와 Amazon S3를 사용하여 end-to-end ETL (추출, 변환, 로드) 파이프라인을 개발하는 데 중점을 둡니다.\n\n이 파이프라인은 OpenWeather API에서 날씨 데이터를 검색하여 구조화된 형식으로 변환하고 S3 버킷에로드합니다. 이 프로젝트를 완료하면 희망하는 빈도로 예약된 파이프라인을 실행할 수 있는 완전히 기능하는 파이프라인을 보유하게 됩니다.\n\n# 프로젝트 구조\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 날씨 데이터 가져오기: OpenWeather API에서 날씨 데이터를 가져옵니다.\n- 날씨 데이터 변환: API에서 가져온 데이터는 JSON 형식이며, 변환 작업은 JSON 개체에서 데이터프레임을 만들고 데이터프레임을 CSV 파일로 변환하는 작업을 포함합니다.\n- S3에 데이터로드: 변환된 데이터를 S3 버킷에 저장합니다.\n\n# 사전 준비 및 사용된 도구\n\n- Apache Airflow: 워크플로우를 프로그래밍 방식으로 작성, 예약, 모니터링할 수 있는 강력하고 유연한 플랫폼입니다.\n- OpenWeather API: 여러 도시의 날씨 데이터를 제공하는 서비스입니다.\n- Amazon S3: Amazon Web Services (AWS)의 확장 가능한 객체 스토리지 서비스입니다.\n- Pandas: 데이터 조작 및 분석을 위해 사용되는 Python 라이브러리입니다.\n- Boto3: Python 개발자가 S3와 같은 Amazon 서비스를 활용하는 소프트웨어를 작성할 수 있게 해주는 AWS SDK for Python입니다.\n- DAG 파일: Apache Airflow에서 작업 및 종속성을 정의하는 작업열로서 사용되는 중요한 개념인 Directed Acyclic Graph(DAG) 파일입니다.\n\n# 구현\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- API와 연결하여 데이터를 가져오는 DAG 스크립트를 작성하세요. 데이터는 데이터프레임에 저장됩니다. DAG 코드는 이 페이지의 맨 아래에서 찾을 수 있습니다.\n- EC2 인스턴스를 생성하고 인스턴스를 시작하여 콘솔에 연결하세요. 저는 무료티어 AWS를 사용하여 이 인스턴스를 생성했습니다. 사양은 t2.micro 및 우분투 22 버전입니다.\n\n![이미지](/assets/img/2024-07-09-End-to-EndETLPipelinewithApacheAirflowandAmazon-S3_0.png)\n\n인스턴스가 실행되면 콘솔에 연결하여 다음을 설치하세요.\n\n```js\nsudo apt-get update\nsudo install python3-pip\nsudo pip install requests pandas boto3 s3fs pyarrow apache-airflow\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n3. 한 번 설치되면, Airflow가 올바르게 설치되었는지 확인하세요. airflow 명령어를 사용하여 확인하고 초기 로그인 자격 증명을 위해 스탠드얼론 명령어를 실행하십시오. 자격 증명을 복사하여 나중에 사용하세요.\n\n```bash\nairflow\nairflow standalone\n```\n\n4. 실행 중인 인스턴스에서 보안으로 이동하여 보안 그룹에 액세스하세요. 인바운드 규칙을 편집하고 새 역할을 생성하세요. \"모든 트래픽\", \"IPv4 어디서나\"로 설정하세요.\n\n5. Airflow 서버와 스케줄러를 시작하세요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n에어플로우 스케줄러 및 에어플로우 웹서버 - 포트 8080\n\n6. 공개 IP 주소를 복사하고 포트를 추가하세요. 예: 172.31.22.254:8080. 이로써 에어플로우 어플리케이션을 열 수 있습니다. 기본 자격 증명을 사용하여 로그인하고 마음에 드는 비밀번호로 재설정하세요.\n\n7. AWS에서 데이터를 저장할 S3 버킷을 만드세요. IAM 역할을 사용하여 권한을 조정하세요. 새 IAM 역할을 만들고 S3 및 EC2에 권한을 부여하세요.\n\n8. DAG 파일에 관련 있는 S3 버킷 이름을 추가하고 저장하세요.\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n9. 인스턴스 콘솔에서 서버를 중지하고 명령을 실행하세요. 이렇게 하면 airflow의 DAGs 폴더에 액세스할 수 있어요. 원하는 경우 DAG 파일을 추가하고 필요할 때 수정할 수 있어요.\n\n```js\nairflow\ncd airflow\nls\nsudo nano airflow.cfg\n```\n\nDAGs 폴더에서 파일 이름을 조정하세요. 수정된 버퍼를 저장하고 종료하세요.\n\n10. 파일을 저장한 후 airflow 명령을 다시 실행하고 로그인하세요. 그러면 airflow 내에서 Dag 파일을 볼 수 있어요. 보이는 형태는 이렇습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 Markdown 형식으로 변경된 테이블입니다.\n\n\n11. 파일을 열어서 수동으로 실행할 수 있어야 합니다. Airflow의 내장 그래프 기능을 사용하여 DAG 파일의 상태를 모니터링할 수 있습니다. 초록 테두리는 성공적인 실행을 나타냅니다.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n12. 실행이 성공하면 데이터가 S3 버킷에 표시됩니다.\n\n![Airflow-S3](/assets/img/2024-07-09-End-to-EndETLPipelinewithApacheAirflowandAmazon-S3_4.png)\n\nDAG 파일과 설명:\n\n```js\nfrom datetime import datetime, timedelta\nfrom airflow import DAG\nfrom airflow.operators.python_operator import PythonOperator\nimport requests\nimport pandas as pd\nimport boto3\nfrom io import StringIO\n\n# Configuration\nAPI_KEY = 'xxxxxxxxxxxxxxxxxxxxxxxxxxx'  # OpenWeather의 API 키\nCITY = 'Arizona'  # 날씨 데이터를 가져올 도시\nS3_BUCKET = 'open-weather-s3-bucket'  # 데이터가 저장될 S3 버킷 이름\nS3_KEY = 'weather_data/weather.csv'  # S3 오브젝트 키 (버킷 내 파일 경로)\n\n# DAG를 위한 기본 인수\ndefault_args = {\n    'owner': 'airflow',  # DAG 소유자\n    'depends_on_past': False,  # 작업 인스턴스는 과거 실행에 의존하지 않음\n    'start_date': datetime(2024, 7, 5),  # DAG 시작 날짜\n    'email_on_failure': False,  # 실패 시 이메일 알림 비활성화\n    'email_on_retry': False,  # 재시도 시 이메일 알림 비활성화\n    'retries': 1,  # 실패 시 재시도 횟수\n    'retry_delay': timedelta(minutes=5),  # 재시도 간의 지연\n}\n\n# 스케줄러가 없는 DAG 정의\ndag = DAG(\n    'OpenWeather_to_s3',\n    default_args=default_args,\n    description='날씨 데이터를 가져와 변환한 후 S3로 로드합니다.',\n    schedule_interval=None,  # schedule_interval을 None으로 설정하여 스케줄러 비활성화\n)\n\ndef fetch_weather_data():\n    \"\"\"OpenWeather API에서 날씨 데이터 가져오기\"\"\"\n    url = f\"http://api.openweathermap.org/data/2.5/weather?q={CITY}&appid={API_KEY}\"  # 도시와 API 키를 포함한 API 엔드포인트\n    response = requests.get(url)  # API에 GET 요청 보내기\n    data = response.json()  # 응답을 JSON으로 변환\n    return data  # 데이터 반환\n\ndef transform_weather_data(**kwargs):\n    \"\"\"가져온 날씨 데이터 변환하기\"\"\"\n    ti = kwargs['ti']  # 작업 인스턴스 가져오기\n    data = ti.xcom_pull(task_ids='fetch_weather_data')  # XCom을 사용하여 'fetch_weather_data' 작업에서 데이터 가져오기\n\n    weather = {\n        'city': data['name'],  # 도시 이름 추출\n        'temperature': data['main']['temp'],  # 온도 추출\n        'pressure': data['main']['pressure'],  # 기압 추출\n        'humidity': data['main']['humidity'],  # 습도 추출\n        'weather': data['weather'][0]['description'],  # 날씨 설명 추출\n        'wind_speed': data['wind']['speed'],  # 풍속 추출\n        'date': datetime.utcfromtimestamp(data['dt']).strftime('%Y-%m-%d %H:%M:%S')  # 타임스탬프를 읽기 가능한 날짜로 변환\n    }\n\n    df = pd.DataFrame([weather])  # 날씨 데이터를 판다스 DataFrame으로 변환\n    return df  # DataFrame 반환\n\ndef load_data_to_s3(**kwargs):\n    \"\"\"변환된 데이터를 S3 버킷에 로드하기\"\"\"\n    ti = kwargs['ti']  # 작업 인스턴스 가져오기\n    df = ti.xcom_pull(task_ids='transform_weather_data')  # XCom을 사용하여 'transform_weather_data' 작업에서 변환된 데이터 가져오기\n\n    csv_buffer = StringIO()  # 인메모리 버퍼 생성\n    df.to_csv(csv_buffer, index=False)  # DataFrame을 CSV로 버퍼에 작성\n    print(df)  # DataFrame 출력 (선택 사항)\n\n    s3_resource = boto3.resource('s3')  # boto3 S3 리소스 생성\n    s3_resource.Object(S3_BUCKET, S3_KEY).put(Body=csv_buffer.getvalue())  # CSV 데이터를 지정한 S3 버킷 및 키에 업로드\n\n# PythonOperator를 사용하여 작업 정의\nfetch_task = PythonOperator(\n    task_id='fetch_weather_data',  # 작업 ID\n    python_callable=fetch_weather_data,  # 호출 가능한 함수\n    dag=dag,  # 작업이 속한 DAG\n)\n\ntransform_task = PythonOperator(\n    task_id='transform_weather_data',  # 작업 ID\n    python_callable=transform_weather_data,  # 호출 가능한 함수\n    provide_context=True,  # 호출 가능한 함수에 컨텍스트 제공\n    dag=dag,  # 작업이 속한 DAG\n)\n\nload_task = PythonOperator(\n    task_id='load_data_to_s3',  # 작업 ID\n    python_callable=load_data_to_s3,  # 호출 가능한 함수\n    provide_context=True,  # 호출 가능한 함수에 컨텍스트 제공\n    dag=dag,  # 작업이 속한 DAG\n)\n\n# 작업 간 의존성 정의 (작업 실행 순서)\nfetch_task >> transform_task >> load_task  # 작업 실행 순서 설정: 가져오기 -> 변환 -> 로드\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n설명:\n\n- Imports 및 구성: 필요한 라이브러리를 import하고 구성 변수를 설정합니다.\n- 기본 인수: DAG의 기본 인수를 정의합니다. 예를 들어, 소유자, 시작 날짜, 재시도 정책 등이 포함됩니다.\n- DAG 정의: DAG 개체를 설명과 일정 간격으로 생성합니다 (일정을 비활성화하려면 None으로 설정 가능합니다).\n- 작업 함수: 사용할 Python 함수를 작업으로 정의합니다.\n\n- fetch_weather_data: OpenWeather API에서 날씨 데이터를 가져옵니다.\n- transform_weather_data: 가져온 데이터를 Pandas DataFrame으로 변환합니다.\n- load_data_to_s3: 변환된 데이터를 S3 버킷에 로드합니다.\n\n5. 작업 생성: PythonOperator를 사용하여 정의된 함수를 호출하는 작업을 생성합니다.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n6. 종속성 설정: 비트 시프트 연산자를 사용하여 작업을 실행할 순서를 정의하세요.\n\n# 자료들","ogImage":{"url":"/assets/img/2024-07-09-End-to-EndETLPipelinewithApacheAirflowandAmazon-S3_0.png"},"coverImage":"/assets/img/2024-07-09-End-to-EndETLPipelinewithApacheAirflowandAmazon-S3_0.png","tag":["Tech"],"readingTime":9},{"title":"훌륭한 베이즈 통계 개념 입문","description":"","date":"2024-07-09 09:05","slug":"2024-07-09-AFantasticIntroductiontotheConceptofBayesianStatistics","content":"\n\n저는 최근 캠브리지 대학 입학 시험지에 나온 매우 어려워 보이지만 창의적으로 표현된 문제를 발견했습니다. 처음에는 매우 복잡해 보였지만, 몇 년간 수학을 연습한 경험으로 배운 한 가지는, 당장 무슨 일을 하는지 모르는 경우에는 가지고 있는 정보들을 적도록 하는 것이 중요하다는 것입니다. 그렇게 하면 종종 해결법이 나타날 겁니다.\n\n이제 문제부터 시작해보죠. 여기 있습니다. 이런 질문을 쓰는 것은 아마 작가가 창의적으로 시도할 수 있는 소중한 기회 중 하나인 것 같아서 웃음이 나네요 😂\n\n이렇게 정보를 적어 보겠습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그 곳에 많은 정보가 제공되었기 때문에, 질문을 다루기 전에 유용한 형식으로 모두 적어 두기로 결정했습니다. 질문이 주로 넥타이와 바지의 조합과 관련이 있다고 생각해서 간단한 표가 정보를 잡아낼 수 있을 것이라고 판단하여, 바지 선택을 행으로 하는 표를 만들었습니다. 넥타이 선택을 열로 했습니다. 표의 각 셀은 바지에 따른 넥타이 선택의 확률입니다...","ogImage":{"url":"/assets/img/2024-07-09-AFantasticIntroductiontotheConceptofBayesianStatistics_0.png"},"coverImage":"/assets/img/2024-07-09-AFantasticIntroductiontotheConceptofBayesianStatistics_0.png","tag":["Tech"],"readingTime":1},{"title":"당신의 삶을 안전하고, 쉬우며, 행복하게 만들어주는 7가지 유용한 Python 스크립트","description":"","date":"2024-07-09 09:04","slug":"2024-07-09-7HandyPythonScriptsThatMadeYourLifeSecurerEasierandHappier","content":"\n\n## 파이썬\n\n![Python](/assets/img/2024-07-09-7HandyPythonScriptsThatMadeYourLifeSecurerEasierandHappier_0.png)\n\n파이썬 프로그래밍 기술은 적절히 활용할 수 있다면 취업뿐만 아니라 삶을 더욱 효율적으로 자동화하고 간소화할 수 있습니다.\n\n우리 일상 생활과 업무에는 지루하고 반복적인 작업이 많습니다. 디지털 형태로 표현될 수 있는 작업이라면 파이썬으로 최적화할 수 있습니다. (아마도 파이썬은 현재로서는 정원 가꾸는 데는 크게 도움을 줄 수 없을 것입니다.)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 기사에서는 이 목적을 위한 7가지 유용한 파이썬 스크립트를 소개합니다.\n\n# 1. 디지털 안전을 위해 강력하고 예측할 수 없는 암호 생성하기\n\n온라인 계정의 비밀번호로 여전히 생일을 사용하고 있나요?\n\n디지털 보안을 향상시키는 때입니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 강력하고 예측 불가능한 암호를 얻는 것은 쉽지 않습니다. 그래서 이 작업을 Python에 맡겨두는 것이 좋은 아이디어입니다.\n\n다음은 이 유형의 암호를 생성하는 Python 스크립트입니다:\n\n```js\n# 강력하고 예측 불가능한 암호를 생성하기 위한 Python 스크립트\n# 저자: 양 조우\nimport secrets\nimport string\n\n\ndef generate_strong_password(length=8):\n    alphabet = string.ascii_letters +…","ogImage":{"url":"/assets/img/2024-07-09-7HandyPythonScriptsThatMadeYourLifeSecurerEasierandHappier_0.png"},"coverImage":"/assets/img/2024-07-09-7HandyPythonScriptsThatMadeYourLifeSecurerEasierandHappier_0.png","tag":["Tech"],"readingTime":2},{"title":"2024년에 풀스택 데이터 과학자가 되는 방법","description":"","date":"2024-07-09 09:03","slug":"2024-07-09-Howwillyoubeafull-stackdatascientistin2024","content":"\n\n![이미지](/assets/img/2024-07-09-Howwillyoubeafull-stackdatascientistin2024_0.png)\n\n내 꿈이었던 직업은 데이터 과학자가 되는 것이었습니다. 이 끝없는 여정은 2021년 9월 7일에 시작되었습니다. 고등학교 때부터 컴퓨터 과학에 관심을 가졌습니다. 삶은 나를 산업계의 생산 엔지니어로 이끌었습니다. 경력 동안 많은 데이터 주도 비즈니스 개발 프로젝트를 수행했습니다. 코로나 시기 이후, 내 열정을 찾고 미래로 나아가기로 결심했습니다. 파이썬 프로그래밍 언어를 배우기 시작했습니다. 학습 습관을 형성하는 데 74일이 걸렸습니다. 학습을 멈추지 않았습니다. 파이썬이 데이터 과학에서 가장 인기 있는 언어임을 알아보고 목표를 데이터 과학 분야로 변경했습니다. 제 생애 13년을 제조 엔지니어로 보낸 뒤에 데이터 과학이 경력 전환에 가장 적합한 분야임을 깨달았습니다.\n\n항상 기초가 중요하다고 믿었습니다. 파이썬에 몰두했습니다. 6개월이 걸렸습니다. 동시에 Numpy, Pandas, Matplotlib, Seaborn, Scikit-learn 같은 파이썬의 인기 있는 라이브러리를 배우기 시작했습니다. 또한 데이터 과학 부트캠프에 등록했습니다. 성장 마인드셋을 채택했습니다. 가치 있는 데이터 과학 소셜 네트워크를 구축했습니다. 새로운 데이터 과학 기회를 얻을 수 있는 기술을 표현하는 자신감을 얻었습니다. 3개월 후에 데이터 관련 직무를 시작했습니다.\n\n새로운 역할을 맡은 때에도 아직 달성해야 할 목표가 있었습니다. 기대치를 높였습니다. 프로그래밍의 객체 지향 접근법을 배웠습니다. 객체 지향 프로그래밍을 잘 이해하기 위해 자바 프로그래밍 언어를 공부했고, 이 접근법을 파이썬을 사용해 데이터 과학 프로젝트에 적용했습니다. 예측 분석을 위한 파이프라인을 구축했습니다. 이를 통해 확장 가능하고 유연한 모델과 유지 보수가 쉬운 보고 도구를 구축할 수 있었습니다. 상사들로부터 매우 감명깊은 피드백을 받았습니다. 이는 제 동기부여에 도움이 되었습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이번 성공 이후, 경쟁 예측 분석 도구를 해킹하기 위해 역공학을 수행했습니다. 예측 분석을 위한 클러스터링 머신 러닝 알고리즘의 나만의 버전을 만들었고, 아직 개발 중에 있습니다.\n\n이 기간 동안 GPT 시스템에 대한 혹평에 실망했습니다. GPT 시스템을 해킹할 방법을 찾기 시작했고, V자형 직원이 데이터 과학에서 더 많은 잠재력을 가지고 있다는 것을 발견했습니다. 클라우드 컴퓨팅이 미래라고 생각했고, 풀 스택 데이터 과학자가 되는 목표를 세웠습니다. 이 모델에서 데이터 과학에 대한 심도 있는 지식을 개발하고, 데이터 엔지니어링, 데이터 분석, 프로젝트 관리, 소프트웨어 엔지니어링, ML/AI 엔지니어링 및 DevOps 지식을 확장하고 싶습니다.\n\nAWS, Azure 및 GCP의 기본 클라우드 컴퓨팅 자격증 준비를 시작했습니다. Europe와 미국의 수요가 많은 기술을 찾기 위해 LinkedIn의 구인 게시판을 분석했으며, 아래 목록을 만들었습니다. 더 추가하고 싶은 항목이 있으면 댓글을 남겨주세요. 데이터 과학에 대한 열정이 계속됩니다.\n\n\n- Agile\n- Amazon Kinesis\n- Apache Airflow\n- Apache Cassandra\n- Apache Hadoop\n- Apache Hive\n- Apache Kafka\n- Apache Spark\n- Apheris\n- ARIMA\n- Atlassian Bitbucket\n-AWS\n- AWS Athena\n- AWS Bedrock\n- AWS Glue\n- AWS Redshift\n- AWS S3\n- AWS SageMaker\n- Azure\n- Azure AI Services\n- Azure CosmosDB\n- Azure Data factory\n- Azure Data Lake\n- Azure Data storage\n- Azure Databricks\n- Azure HDInsight\n- Azure Machine Learning Studio\n- Azure SQL\n- Azure Stream Analytics\n- Azure Synapse Analytics\n- Bash\n- Bigquery\n- C\n- C#\n- C++\n- Catboost\n- CI/CD\n- Circle CI\n- Databricks\n- Datashield\n- DAX\n- DBT\n- Deep Learning\n- DevOps\n- Digital Signal Processing\n- Docker\n- DOMO\n- Elasticsearch\n- ETL\n- FA/FL\n- Fast Fourier Analysis\n- FastAPI\n- Feature Engineering\n- Fivetran\n- FPGA\n- GCP\n- GCP Looker\n- Git\n- GitHub\n- GitLab\n- GraphQL\n- IBM Cognos Analytics\n- Java\n- Javascript\n- Jenkins\n- Jupyter\n- Kubeflow\n- Kubernetes\n- LangChain\n- LightGBM\n- Linux\n- LLM\n- LSTM\n- Matplotlib\n- Metabase\n- Microsoft 365\n- Microsoft Language Studio\n- Microsoft SQL Server\n- MLflow\n- Monai\n- MongoDB\n- MySQL\n- NLP\n- NLTK\n- NoSQL\n- Numpy\n- Nvidia Flare\n- NWP\n- OOP\n- OpenAI API\n- OpenCL\n- Oracle\n- Pandas\n- PostgreSQL\n- Power BI\n- PySpark\n- Pytest\n- Python\n- PyTorch\n- QlikSense\n- Qlikview\n- R\n- RAG\n- Rest API\n- SAS\n- Scala\n- Scikit-learn\n- Scipy\n- Scrum\n- SDLC\n- Snowflake\n- Spacy\n- Spinnaker\n- SQL\n- SQLAlchemy\n- Streamlit\n- Tableau\n- Tensorflow\n- Tensorflow Lite\n- Time Series\n- Travis CI\n- Vector Database\n- XGBoost\n","ogImage":{"url":"/assets/img/2024-07-09-Howwillyoubeafull-stackdatascientistin2024_0.png"},"coverImage":"/assets/img/2024-07-09-Howwillyoubeafull-stackdatascientistin2024_0.png","tag":["Tech"],"readingTime":4},{"title":"TypeScript 맵드 타입 알아보기 기초부터 고급까지 8가지 예제","description":"","date":"2024-07-07 22:01","slug":"2024-07-07-ExploringMappedTypesinTypeScript8ExamplesfromBasictoAdvanced","content":"\n\nMarkdown 형식의 표를 변경하실게요.\n\n![Mapped types in TypeScript](/assets/img/2024-07-07-ExploringMappedTypesinTypeScript8ExamplesfromBasictoAdvanced_0.png)\n\nTypeScript의 Mapped types은 한 타입의 속성을 다른 타입으로 변환하는 강력한 도구입니다. 이들은 map과 filter와 비슷한 배열 메서드와 유사하지만, 이러한 작업들은 타입에 대해 수행됩니다. 우리는 실용적인 예제를 통해 그들의 사용법을 이해할 것입니다. 다음으로, 우리는 기초부터 고급까지 총 8가지 Mapped 타입 예제를 차근차근 시연하면서, 여러분이 이 강력한 타입 변환 도구를 쉽게 마스터할 수 있도록 돕겠습니다.\n\n# I. 기초적인 타입 변환\n\nTypeScript에서는 때때로 한 타입의 속성을 다른 타입으로 변환해야 할 때가 있습니다. 이것은 Mapped types를 사용하여 쉽게 실현할 수 있습니다. 아래에서는 한 Product 타입의 속성을 문자열 타입으로 변환하는 방법을 구체적인 예제를 통해 시연하겠습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 1. 제품 유형 정의하기\n\n먼저, 세 가지 속성인 이름 (문자열 유형), 가격 (숫자 유형), 재고 여부 (부울린 유형)을 포함한 제품 유형을 정의합니다.\n\n```js\ntype Product = {\n    name: string;\n    price: number;\n    inStock: boolean;\n};\n```\n\n## 2. 제품을 문자열로 변환하는 유형 정의하기\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그 다음, 우리는 새로운 타입인 ProductToString을 정의합니다. 이 타입은 Product 타입의 모든 속성을 문자열 타입으로 변환합니다.\n\n```js\ntype…\n```","ogImage":{"url":"/assets/img/2024-07-07-ExploringMappedTypesinTypeScript8ExamplesfromBasictoAdvanced_0.png"},"coverImage":"/assets/img/2024-07-07-ExploringMappedTypesinTypeScript8ExamplesfromBasictoAdvanced_0.png","tag":["Tech"],"readingTime":2},{"title":"shadcn-ui UI 코드베이스 분석 shadcn-ui CLI는 어떻게 작동하나요  27부","description":"","date":"2024-07-07 22:00","slug":"2024-07-07-shadcn-uiuicodebaseanalysisHowdoesshadcn-uiCLIworkPart27","content":"\n\nshadcn-ui CLI가 어떻게 작동하는지 알아보고 싶었어요. 이 글에서는 shadcn-ui/ui CLI를 구축하는 데 사용된 코드에 대해 이야기하고 있어요.\n\n2.6 부에서는 프로젝트의 ts-config.json 파일에서 사용되는 별칭을 반환하는 getTsConfigAliasPrefix 함수를 살펴봤어요.\n\n이제 다음 코드 라인으로 넘어가 봅시다.\n\n![이미지](/assets/img/2024-07-07-shadcn-uiuicodebaseanalysisHowdoesshadcn-uiCLIworkPart27_0.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nL84에서는 projectType 또는 tailwindCssFile 또는 tsConfigAliasPrefix 중 하나라도 존재하지 않는 경우 null을 반환하는 간단한 확인 작업입니다.\n\nisTypescriptProject(cwd)에 대해 더 알아보겠습니다.\n\n```js\nconst isTsx = await isTypeScriptProject(cwd)\n```\n\nisTypescriptProject는 ui/packages/cli/src/utils/get-project-info.ts로부터 가져온 함수이며, 이 함수는 현재 작업 디렉토리(cwd)에 tsconfig.json 파일이 있는지 확인합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nexport async function isTypeScriptProject(cwd: string) {\n  // cwd에 tsconfig.json 파일이 있는지 확인합니다.\n  return pathExists(path.resolve(cwd, \"tsconfig.json\"))\n}\n```\n\n# pathExists\n\npathExists는 fs-extra에서 가져온 함수입니다.\n\n```js\nimport fs, { pathExists } from \"fs-extra\"\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결론:\n\n프로젝트가 TypeScript를 사용하는지 확인하려면 shadcn-ui/ui CLI 패키지와 같은 작업을 수행할 수 있습니다. 즉, fs-extra에서 제공하는 pathExists 함수를 사용하여 지정된 cwd에 있는 tsconfig.json 경로가 있는지 확인하면 됩니다.\n\n# 나에 대해:\n\n웹사이트: [https://ramunarasinga.com/](https://ramunarasinga.com/)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nLinkedin: [링크드인](https://www.linkedin.com/in/ramu-narasinga-189361128/)\n\nGithub: [깃허브](https://github.com/Ramu-Narasinga)\n\n이메일: ramu.narasinga@gmail.com\n\nshadcn-ui/ui를 처음부터 만들기\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 참고 자료:\n\n- [shadcn-ui 프로젝트 정보 가져오기](https://github.com/shadcn-ui/ui/blob/main/packages/cli/src/utils/get-project-info.ts#L84C3-L88C47)\n- [shadcn-ui 프로젝트 정보 가져오기](https://github.com/shadcn-ui/ui/blob/main/packages/cli/src/utils/get-project-info.ts#L174)\n- [shadcn-ui 프로젝트 정보 가져오기](https://github.com/shadcn-ui/ui/blob/main/packages/cli/src/utils/get-project-info.ts#L10)\n- [fs-extra 패키지](https://www.npmjs.com/package/fs-extra)","ogImage":{"url":"/assets/img/2024-07-07-shadcn-uiuicodebaseanalysisHowdoesshadcn-uiCLIworkPart27_0.png"},"coverImage":"/assets/img/2024-07-07-shadcn-uiuicodebaseanalysisHowdoesshadcn-uiCLIworkPart27_0.png","tag":["Tech"],"readingTime":4},{"title":"초보 부트스트래퍼를 위한 간단한 기술 스택 추천","description":"","date":"2024-07-07 21:59","slug":"2024-07-07-ASimpleTechStackforBeginnerBootstrappers","content":"\n\n최근에 테이블 화면 클립을 CSV 파일로 변환하는 도구를 만들어서 론칭했어요.\n\n이 도구는 이메일 인증과 Stripe를 이용한 실제 결제 기능을 갖춘 기능적인 앱이에요.\n\n여기에는 해당 도구를 구축하기 위해 사용한 기술 스택을 공유해봤어요. 입문자 루트 개발자들에게 완벽한 간단한 스택이라고 생각해요 (초보에서 중급 프로그래머들 😉). \n\n![image](/assets/img/2024-07-07-ASimpleTechStackforBeginnerBootstrappers_0.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 메인 애플리케이션 (Next.js)\n\n도구의 핵심은 Next.js 애플리케이션입니다. Next.js는 React로 구축된 풀스택 프레임워크입니다.\n\n웹 애플리케이션을 시작하는 데 Next.js를 사용하는 것을 좋아하는 몇 가지 이유가 있습니다:\n\n- JavaScript / TypeScript로 모든 것을 작성할 수 있는 풀스택 지원.\n- 현대적인 App Router 접근 방식을 통해 앱의 아키텍처를 쉽게 설계할 수 있습니다. 디렉토리와 페이지를 추가하면 라우팅이 자동으로 처리됩니다.\n- 문서는 초보자에게도 잘 구성되어 있고 쉽게 접근할 수 있습니다.\n- Vercel도 함께 사용하면 배포도 매우 쉽습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 미리 알았더라면 좋았을 것들\n\n## 서버 및 클라이언트 컴포넌트에 대해 문서를 읽는 데 시간을 보내세요.\n\n이 모델에 익숙해지는 데 시간이 걸립니다. 하지만 결국 직관적이 되어 이 현대 웹 애플리케이션의 방향이 왜 그런지 볼 수 있습니다.\n\n- 모든 컴포넌트는 기본적으로 서버 컴포넌트입니다. 이는 로딩 시간, 보안 및 SEO에 이점이 있습니다.\n- 클라이언트 컴포넌트는 가져와서 서버 컴포넌트에서 사용할 수 있습니다.\n- 서버 컴포넌트는 클라이언트 컴포넌트로 가져올 수 없습니다. 그러나 프롭스로 전달할 수 있습니다.\n- 그 결과로 클라이언트 컴포넌트는 인터랙티브한 기능이 필요한 곳으로 컴포넌트 트리 아래로 밀어 넣어야 합니다 (예: 폼 및 버튼).\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 컴포넌트가 어떻게 조합되는지를 잘 익히면 Next.js를 사용한 생산성이 크게 향상될 것입니다.\n\n## 컴포넌트를 어떻게 구성할지에 대한 초기 결정을 내리세요\n\n나는 세 가지 주요 방법이 있다고 생각해요.\n\n- 'page.tsx' 파일 옆의 라우트 디렉터리 내에 컴포넌트를 위치시킵니다.\n- 별도의 'components' 디렉터리에 컴포넌트를 위치시킵니다.\n- 방법 1과 2를 혼합해서 사용합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n내 도구를 개발할 때 여러 접근 방법을 시도해 보았고, 결국 2번째 방법으로 정착했습니다.\n\n라우트 디렉토리 내에서 구성 요소를 찾는 것은 금방 번거로워지는 반면, 한 디렉토리에 모든 것을 찾아야 했기 때문에 구성 요소의 재사용성에 대해 더 신중히 고민해야 했습니다.\n\n## 컴포넌트 라이브러리 사용\n\n컴포넌트 라이브러리를 사용하면 많은 시간을 절약할 수 있습니다. 하지만 그러면 다음 문제는 어떤 컴포넌트 라이브러리를 사용해야 할지입니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저는 shadcn/ui를 좋아해요. CLI를 사용하면 컴포넌트의 전체 코드가 프로젝트에 자동으로 붙여지기 때문이에요.\n\n컴포넌트들은 합리적인 스타일링 기본 설정을 가지고 시작할 때 편리하며, 코드를 쉽게 검사할 수 있는 능력은 (제 경우처럼) 견고한 재사용 가능한 컴포넌트가 어떻게 만들어지는지 배우고자 하는 분들에겐 좋은 기회가 되요.\n\n# 유용한 링크\n\n- React 소개\n- Next.js 소개\n- ByteGrad에서 제공하는 Next.js 관련 멋진 튜토리얼 비디오\n- Next.js와 shadcn/ui 설정하는 방법\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 데이터베이스 (Supabase)\n\n데이터베이스로 Supabase를 사용했어요. 선택한 이유는 다음과 같아요:\n\n- Next.js 애플리케이션과 매우 잘 통합돼요.\n- 인증 제공자로 사용할 수 있어요.\n- 오픈 소스에요.\n- 문서가 매우 훌륭해요 ✨.\n\n# 미리 알았더라면 좋았을 것들\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## Next.js와 Supabase 스타터 프로젝트 사용하기\n\n어플리케이션을 처음부터 만들어가던 중 Next.js와 Supabase가 기본 인증이 구축된 스타터 프로젝트로 협업한 것을 발견했어요.\n\n내 제안은 이 스타터를 사용하되 코드를 익히면서 작동 방식을 배우는 거예요.\n\n스타터를 사용하면 Vercel 마법사를 사용해 설정하면 좋아요. 그러면 대부분의 배포 구성이 이미 완료된 프로젝트로 시작할 수 있어요 (아래 링크 참조).\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 유용한 링크\n\n- Next.js와 Supabase 시작 프로젝트 배포하기\n\n# 결제 (Stripe)\n\n제 알기로는 애플리케이션을 구축할 때 Stripe가 결제 분야의 사실상 표준이라고 생각됩니다 (다르게 생각하시면 말씀해주세요).\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nStripe 문서에는 시작하는 데 도움이되는 꽤 좋은 정보와 보일러플레이트 코드가 있습니다.\n\n# 처음에 알았으면 하는 것들\n\n## 결제 링크를 사용하여 체크아웃 세션을 시작하십시오\n\nStripe 결제 링크는 Stripe를 사용하여 결제를 받는 가장 쉬운 방법입니다. Stripe 대시 보드 내에서 코딩없이 구성할 수 있습니다. 그런 다음 앱 내의 버튼이나 다른 구성요소가 사용자를 결제 링크로 안내하면 됩니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 결제 링크로 클라이언트 참조를 전달할 수 있습니다.\n\n사용자를 결제 링크로 이동시킬 때 클라이언트 참조 ID를 전달할 수 있습니다. 인증된 Supabase 사용자 ID를 전달하면 결제가 완료된 후에 해당 사용자와 조정할 수 있습니다.\n\n## 사용자가 결제를 완료한 후 로직에 웹훅을 사용하세요\n\n사용자가 결제 프로세스를 진행할 때 Stripe는 결제 의도 설정이나 체크아웃 세션 완료와 같이 다양한 '이벤트'를 생성합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nStripe는 업데이트를 수신하는 앱을 알 수 있도록 해당 이벤트를 보낼 대상을 필요로 합니다. 이 대상을 웹훅의 형태로 제공합니다.\n\n당신의 앱의 웹훅은 Stripe 이벤트를 '청취'합니다. 그런 다음 통과하는 다양한 이벤트를 어떻게 처리할지 결정합니다.\n\n가장 중요한 이벤트는 'checkout.session.completed'로, 이는 결제 프로세스가 원활하게 완료되었음을 의미합니다.\n\n# 유용한 링크\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Stripe 결제링크 개요\n- 클라이언트 참조 ID를 결제 링크에 전달하는 방법\n- Next.js와 Stripe를 사용하는 Vercel 기사 - 이 기사는 stripe checkout 세션을 사용하는 방법에 대한 것이며 (결제링크보다 복잡함), Stripe 웹훅을 위한 유용한 보일러플레이트 코드도 포함되어 있습니다.\n\n# 이메일 제공업체 (재전송)\n\n대부분의 애플리케이션은 사용자에게 어느 시점에서라도 이메일을 보내야 할 필요가 있습니다. 예를 들어 사용자가 가입한 경우 이메일 주소를 확인하는 이메일로 이메일을 확인할 수 있습니다.\n\nResend는 Supabase의 권장사항 중 하나였습니다. 합리적인 무료 티어를 갖추고 있으며 통합이 매우 원활하다고 생각했습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 미리 알았더라면 좋았을 것들\n\n## Supabase 이메일 인증이 제한되어 있습니다\n\nSupabase 이메일 인증 설정은 간단한데, 제작용으로 설계되어 있지 않다는 점을 알아두세요. 애플리케이션을 배포할 때 당신을 위해 이메일을 보낼 수 있는 SMTP (Simple Mail Transfer Protocol) 제공업체가 필요합니다.\n\n# 유용한 링크\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Resend와 Next.js\n- Supabase에서 사용자 정의 SMTP 구성\n\n여기에 있습니다! 부트스트랩된 애플리케이션을 위한 로드맵과 간단한 기술 스택이에요. 만약 간단한 도구에 대한 아이디어가 있다면, 이 아키텍처를 사용하여 시작할 수 있어요. 저가 일찍 알았으면 하는 몇 가지를 공유해드려서 유용하고 프로세스를 가속화할 수 있기를 바랍니다.\n\n떠나실 때!\n\n만약 이 이야기를 즐겁게 읽었다면 몇 손가락 운동을 하셔서 이 게시물을 좋아요 👏🏻 를 눌러주시겠어요? 읽고 싶어하시는 내용을 쓰고 있는지를 알려주어서 도움이 돼요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n기술 활용과 온라인 존재감 구축에 관한 더 많은 이야기를 듣고 싶다면 저를 팔로우해주세요. (저는 막 시작한 입장이니, 함께 배우세요.)\n\n다음에 만나요! 감사합니다! 🙏🏻","ogImage":{"url":"/assets/img/2024-07-07-ASimpleTechStackforBeginnerBootstrappers_0.png"},"coverImage":"/assets/img/2024-07-07-ASimpleTechStackforBeginnerBootstrappers_0.png","tag":["Tech"],"readingTime":9},{"title":"React와 TypeScript로 Google Analytics 사용 방법","description":"","date":"2024-07-07 21:58","slug":"2024-07-07-GoogleAnalyticsWithReactTypescript","content":"\n\n<img src=\"/assets/img/2024-07-07-GoogleAnalyticsWithReactTypescript_0.png\" />\n\n## GA 란?!!\n\nGoogle Analytics (GA)은 웹사이트 트래픽 및 사용자 행동을 추적하고 분석하는 강력한 도구입니다.\n\n다음은 그 동작 방식입니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n당신의 웹사이트에서 GA는 JavaScript 추적 코드를 사용하여 데이터를 수집합니다. 이 코드는 웹사이트 페이지에 삽입되어 방문자에 대한 정보를 수집하고 Google의 서버로 보내어 처리되며 다양한 보고서에서 제공됩니다.\n\n## 구현은 어떻게 작동하나요?\n\nuseGoogleAnalytics.ts는 GA와 통합하기 위한 기본 파일로 사용됩니다. 우리는 유연성과 미래 지향성을 위해 GA 통합을 처리하기 위해 객체를 사용하고 있습니다.\n\nGoogleAnalyticsProvider.tsx는 라우트를 감싸는 공급자 컴포넌트로 사용됩니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nApp.tsx 파일을 수정하여 GoogleAnalyticsProvider 컴포넌트를 추가해주세요.\n\n이 방법을 선택한 이유는?\n\n- 다양한 기능 지원: 페이지 뷰, 이벤트 추적 및 초기화 후 구성을 쉽게 관리할 수 있습니다.\n\n- 미래를 대비: ReactGA에서 다른 솔루션(예: 미래의 GA 버전)으로 전환하더라도 코드 베이스의 각 인스턴스를 모두 업데이트해야 하는 것이 아니라 이 객체만 업데이트하면 됩니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n* React 방식: 이 방법은 React의 최상의 실천 방법을 따르며 부작용을 처리하기 위해 컴포넌트를 사용합니다.\n\n// 코드에 있는 주석들\n앱에서 이를 검색하여 로직을 이해하고 앱에서 구현을 더 잘 할 수 있도록 하는 것을 추천합니다: `// 추천:` 및 `// 설명:`\n\nGitHub 저장소: ‘google-analytics-react-ts’\n\nuseGoogleAnalytics.ts.tsx\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport { useEffect } from 'react';\nimport ReactGA from 'react-ga4';\n\n// 추천: 환경 변수를 사용하여 비밀로 유지하는 것이 좋습니다.\nexport const trackingId = \"GA_ID\"\nconst appVersion = \"APP_VERSION\"\n// 참고: 분석을 보다 나은 것으로 만들기 위해 앱에서 사용자 ID를 사용하십시오.\n// 추천: Redux로 구현하는 것이 좋습니다.\nconst id = \"user-id\"\n\nconst useGoogleAnalytics = () => {\n\n  useEffect(() => {\n    if (trackingId) {\n      try {\n        ReactGA.initialize([\n          {\n            trackingId,\n            gaOptions: {\n              anonymizeIp: true,\n              clientId: id\n            }\n          }\n        ]);\n        ReactGA.set({ app_version: appVersion });\n      } catch (error) {\n        // 추천: 이 오류를 오류 추적 서비스에 보고하는 것이 좋습니다.\n        console.log(\"Google Analytics 초기화 오류\", { Error: error });\n      }\n    }\n  }, [id]);\n\n  const setOption = (key: string, value: unknown) => {\n    ReactGA.set({ [key]: value });\n  };\n\n  const setUserId = (userId: string | number) => {\n    setOption(\"userId\", userId);\n  };\n\n  const sendData = (type: string, data: Object) => {\n    ReactGA.send({ hitType: type, ...data });\n  };\n\n  const trackPageView = (pagePath?: string) => {\n    if (!pagePath) {\n      pagePath = location.href;\n    }\n\n    setOption('app_version', appVersion);\n    sendData(\"pageview\", { page: pagePath });\n  };\n\n  const trackEvent = (category: string, action: string, label?: string, value?: number) => {\n    setOption('app_version', appVersion);\n    ReactGA.event({ category, action, label, value });\n  };\n\n  return {\n    setOption,\n    setUserId,\n    trackPageView,\n    trackEvent,\n  };\n};\n\nexport default useGoogleAnalytics;\n```\n\nGoogleAnalyticsProvider.tsx\n\n```js\nimport React, { useEffect, PropsWithChildren } from 'react';\nimport { useLocation } from 'react-router-dom';\nimport useGoogleAnalytics, { trackingId } from '../hooks/useGoogleAnalytics';\n\nconst GoogleAnalyticsProvider: React.FC<PropsWithChildren<{}>> = ({ children }) => {\n    const { trackPageView } = useGoogleAnalytics();\n    const location = useLocation();\n\n    useEffect(() => {\n        if (trackingId) {\n            try {\n                trackPageView(location.pathname + location.search);\n            } catch (error) {\n                // 추천: 이 오류를 오류 추적 서비스에 보고하는 것이 좋습니다.\n                console.log(\"Google Analytics의 trackPageView 실행 오류\", { Error: error });\n            }\n        }\n    }, [location, trackPageView]);\n    // 참고: GoogleAnalyticsProvider가 UI에 영향을 미치지 않고 다른 컴포넌트를 감쌀 수 있도록 합니다.\n    return <>{children}</>;\n}\n\nexport default GoogleAnalyticsProvider;\n```\n\nApp.tsx\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport { BrowserRouter as Router, Route, Routes, useLocation } from 'react-router-dom';\nimport './App.css';\nimport GoogleAnalyticsProvider from './providers/GoogleAnalyticsProvider';\n\nconst App: React.FC = () => {\n\n  return (\n    // 참고: GoogleAnalyticsProvider를 어디에 배치할지 확인하여 최적의 위치를 지정-\n    // 모든 route 변경을 추적하기 위해 초기화를 최소화하고 오류를 캡처합니다 (오류 추적 서비스 사용 시)\n    <GoogleAnalyticsProvider>\n      <Routes>\n        <Route\n          path=\"/\"\n          element={\n            <div>\n              Google Analytics React TypeScript\n            </div>\n          }\n        />\n      </Routes>\n    </GoogleAnalyticsProvider >\n  );\n}\n\nexport default App;\nexport default App;\n```\n\n## 2가지 구현 방법\n\n1. 일반 추적 (현재 레포지토리) :sunglasses:\n\n장점:\n* 간단한 초기화: 설정을 통해 GAInitializer 컴포넌트가 마운트될 때 Google Analytics가 한 번만 초기화됩니다.\n* 페이지 뷰 추적: 페이지 뷰를 추적하는 방법을 제공하여 각 페이지 방문이 로그에 기록되도록 수동으로 처리할 수 있습니다.\n* 사용자 정의 이벤트: trackEventBuilder 메서드를 사용하면 다양한 사용자 상호작용을 추적하는 유연성을 제공합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n단점:\n- 수동 페이지 뷰 추적: App 컴포넌트만 래핑하고 각 route 변경을 래핑하지 않기 때문에 각 route 변경마다 trackPageView를 수동으로 호출해야 합니다. 안 할 경우 인간 에러가 발생할 수 있습니다.\n- route 변경 추적 부족: route 변경을 자동으로 추적하지 않기 때문에, 각 컴포넌트에서 명시적으로 trackPageView를 호출하지 않으면 일부 페이지 뷰 로깅을 놓칠 수 있습니다.\n- 제한된 사용자 컨텍스트: 기본 GA가 수집한 것 이상의 상세한 사용자 상호작용 또는 인구통계 데이터를 추적하지 않습니다.\n\n장점:\n\n- 이벤트 추적 기능을 모든 추적하고 싶은 이벤트에 추가\n- 세밀한 제어: 추적할 이벤트와 해당 라벨을 정확하게 제어할 수 있어 매우 상세하고 구체적인 분석 데이터를 얻을 수 있습니다.\n- 사용자 정의: 각 이벤트를 특정 범주, 동작, 라벨 및 값으로 사용자 정의할 수 있어 사용자의 행동과 상호작용에 대한 풍부한 통찰을 제공합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n단점:\n\n- 유지보수 부담 : 애플리케이션이 커지면 수많은 개별 추적 호출을 관리하는 것이 시간이 오래 걸리고 일관되게 유지하는 것이 어려워질 수 있습니다.\n- 코드 중복 : 여러 구성 요소나 함수에서 유사한 추적 코드를 반복해야 할 수 있으며, 결과적으로 DRY (Don't Repeat Yourself) 코드가 줄어들 수 있습니다.\n\n## 콘텐츠 보안 정책 (CSP)\n\nGA를 구현하기 위해 GA 스크립트를 웹 애플리케이션에 포함하고 코드에서 추적을 설정하세요. 'https://www.google-analytics.com`를 script-src 및 connect-src 지시문에 추가하여 GA 서버로의 연결을 허용하도록 CSP를 구성하세요. Google Tag Manager를 사용하는 경우 script-src 지시문에 ‘https://www.googletagmanager.com`도 포함하고 CSP 구성을 철저히 테스트하세요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 참고 자료\n\nMedium: ‘Google Analytics TypeScript로 React에 구현하기’\n\nYouTube: ‘React JS에 Google Analytics 추가하기’","ogImage":{"url":"/assets/img/2024-07-07-GoogleAnalyticsWithReactTypescript_0.png"},"coverImage":"/assets/img/2024-07-07-GoogleAnalyticsWithReactTypescript_0.png","tag":["Tech"],"readingTime":8},{"title":"Nextjs 마스터하기 깔끔하고 확장 가능하며 타입 안전한 개발을 위한 모범 사례","description":"","date":"2024-07-07 21:56","slug":"2024-07-07-MasteringNextjsBestPracticesforCleanScalableandType-SafeDevelopment","content":"\n\n현대 웹 개발에서 Next.js는 견고하고 동적인 웹 애플리케이션을 구축하는 강력한 프레임워크로 떠오르고 있습니다. 그 유연성과 서버 측 렌더링(SSR) 및 정적 사이트 생성(SSG)과 같은 기능들로 인해, 개발자들이 고성능 웹 사이트를 만드는 데 선택하는 주요 도구가 되었습니다. 그러나 Next.js의 최대 잠재력을 활용하려면, 코드 품질, 유지 보수성 및 확장성을 보장하는 최상의 사례에 따라야 합니다. 본 문서에서는 SOLID 원칙, TypeScript 지침 및 Next.js 특화 전략을 아우르는 포괄적인 최상의 사례를 탐구하여, Next.js 프로젝트를 탁월한 수준으로 발전시킬 수 있도록 돕겠습니다.\n\n![이미지](/assets/img/2024-07-07-MasteringNextjsBestPracticesforCleanScalableandType-SafeDevelopment_0.png)\n\n## 제 1장: Next.js 개발에서 객체 지향 원칙\n\n객체 지향 프로그래밍(OOP)은 \"객체\"라는 개념을 기반으로 하는 프로그래밍 패러다임으로, 이 객체는 필드(속성 또는 프로퍼티)에 데이터와 프로시저(메서드 또는 함수)에 코드를 포함할 수 있습니다. OOP 원칙을 준수하면 소프트웨어 시스템을 모듈식, 유연하고 유지보수하기 쉽게 설계하고 구현할 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 캡슐화\n\n- 캡슐화는 데이터를 해당 데이터에 작용하는 메서드와 함께 묶거나, 객체의 일부 구성 요소에 대한 직접 액세스를 제한하는 것을 말합니다. 이는 객체의 내부 상태를 숨기고 상호 작용하는 데 제어된 인터페이스만 노출함으로써 도와줍니다.\n- 자물쇠가 있는 금고를 생각해보세요. 자물쇠는 금고 안의 보물을 캡슐화하여 키(메서드)를 가진 사람들만 액세스할 수 있도록 합니다. 이렇게 함으로써 보물이 무단으로 액세스되거나 수정되는 것을 방지할 수 있습니다.\n\n```js\nclass Post {\n  constructor(title, content) {\n    this._title = title; // 캡슐화된 속성\n    this._content = content; // 캡슐화된 속성\n  }\n\n  getTitle() {\n    return this._title; // 게터 메서드\n  }\n\n  setContent(content) {\n    this._content = content; // 세터 메서드\n  }\n\n  getContent() {\n    return this._content;\n  }\n}\n```\n\n## 추상화\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 추상화는 복잡한 구현 세부 사항을 숨기고 객체의 핵심 기능만 표시하는 과정입니다. 이는 객체가 무엇을 하는지에 초점을 맞춘 채 그것이 어떻게 하는지보다는 복잡성을 관리하는 데 도움이 됩니다.\n- 자동차 계기판을 생각해보십시오. 이는 차의 내부 메커니즘을 공개하지 않고 속력, 연료 수준 및 엔진 온도와 같은 중요한 정보를 운전자에게 제공합니다. 이 추상화로 인해 운전자는 불필요한 세부 정보에 압도되지 않고 운전에 집중할 수 있습니다.\n\n```js\nclass Post {\n  constructor(title, content) {\n    this.title = title;\n    this.content = content;\n  }\n\n  displayPost() {\n    console.log(`Title: ${this.title}`);\n    console.log(`Content: ${this.content}`);\n  }\n}\n```\n\n## 상속\n\n- 상속은 새 클래스가 기존 클래스로부터 속성과 메서드를 파생하는 메커니즘입니다. 이는 코드의 재사용성을 촉진하고 각 하위 클래스가 상위 클래스에서 속성과 동작을 상속받아 클래스 계층 구조를 생성하는 것을 허용합니다.\n- 이전 세대로부터 일부 특성과 특징을 상속받는 가족 계보를 상상해보십시오. 마찬가지로 OOP에서는 하위 클래스가 상위 클래스로부터 속성과 메서드를 상속받아 클래스 계층 구조를 형성합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nclass Person {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n\n  displayInfo() {\n    console.log(`Name: ${this.name}`);\n    console.log(`Age: ${this.age}`);\n  }\n}\n\nclass User extends Person {\n  constructor(name, age, email) {\n    super(name, age); // 상위 클래스 생성자 호출\n    this.email = email;\n  }\n\n  displayUser() {\n    super.displayInfo(); // 상위 클래스 메서드 호출\n    console.log(`Email: ${this.email}`);\n  }\n}\n```\n\n## 다형성\n\n- 다형성은 서로 다른 클래스의 객체를 공통 슈퍼클래스의 객체로 취급할 수 있게 합니다. 이는 메서드를 슈퍼클래스에서 정의하고 서브클래스에서 오버라이드할 수 있어 코드의 유연성과 확장성을 제공합니다.\n- “draw”라는 메서드를 가진 모양 클래스를 생각해보세요. 이 draw 메서드는 각 모양 서브클래스(e.g., 원, 사각형, 삼각형)마다 다르게 구현될 수 있어 각 모양이 고유한 방식으로 그려질 수 있으면서도 여전히 모양으로 처리될 수 있습니다.\n\n```js\nclass Admin extends User {\n  constructor(name, age, email, role) {\n    super(name, age, email);\n    this.role = role;\n  }\n\n  displayUser() {\n    super.displayUser();\n    console.log(`Role: ${this.role}`);\n  }\n}\n\nclass Guest extends User {\n  constructor(name, age, email, status) {\n    super(name, age, email);\n    this.status = status;\n  }\n\n  displayUser() {\n    super.displayUser();\n    console.log(`Status: ${this.status}`);\n  }\n}\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 옵젝트 지향 원칙들을 적용하여 Next.js 개발을 하면 모듈화되고 유연하며 유지보수가 용이한 코드를 디자인할 수 있어 애플리케이션을 구축하고 확장하기가 더 용이해집니다.\n\n# Chapter 2: SOLID 원칙\n\n## 단일 책임 원칙 (SRP)\n\n- SRP는 클래스가 변경될 이유가 하나여야 한다고 이야기합니다. 이것은 클래스가 하나의 책임이나 역할만을 가져야 한다는 것을 의미합니다. 이 원칙은 클래스를 보다 집중적으로 만들어 이해하기 쉽고 버그 발생 가능성을 줄이는 데 도움이 됩니다.\n- 예를 들어 빵을 굽는 일을 담당하는 제빵사가 있다고 상상해보세요. 만약 제빵사가 갑자기 빵을 굽는 일에 더해 고객에게 빵을 배달하는 책임도 맡는다면, 빵의 품질이 하락할 수 있습니다. 굽기에만 집중함으로써, 제빵사는 항상 완벽하게 빵을 굽을 수 있음을 보장할 수 있습니다.\n- 다음은 Next.js에서 SRP를 적용하는 예시입니다. Card 컴포넌트를 만들고 싶다고 가정해봅시다. Card 폴더를 만들어 컴포넌트 자체와 필요한 상수들이 포함되도록 합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 컴포넌트인 Card.tsx입니다.\n\n```js\nimport React from \"react\";\nimport { CardProps } from \"./constants\";\n\nconst Card: React.FC<CardProps> = ({ title, desc, color }) => {\n return (\n  <div\n   data-testid=\"card\"\n   style={{ backgroundColor: `#${color}` }}\n   className=\"p-12 w-[348px] h-full lg:h-[438px] rounded-[30px] shadow-lg\"\n  >\n   <h2 className=\"text-lg font-bold mb-3\">{title}</h2>\n   <p>{desc}</p>\n  </div>\n );\n};\n\nexport default Card;\n```\n\n2. 상수들을 저장하는 constants.ts.\n\n```js\nexport type CardProps = {\n title: string;\n desc: string;\n color: string;\n};\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 두 가지를 분리함으로써 코드의 전반적인 가독성을 향상시킬 수 있습니다.\n\n## 개방/폐쇄 원칙 (OCP)\n\n- OCP는 소프트웨어 엔티티가 확장 가능하도록 열려 있지만 변경에는 폐쇄되어야 함을 명시합니다. 이는 기존 코드를 변경하지 않고 시스템에 새 기능을 추가할 수 있어야 함을 의미합니다.\n- 차량을 예로 들어보겠습니다. 켄버파블 로프 랙이나 스포일러와 같은 다양한 액세서리로 쉽게 사용자 정의할 수 있도록 설계된 차량을 고려해보세요. 차량의 디자인은 이러한 액세서리를 추가하거나 제거할 수 있도록 해줌으로써 차량의 핵심 구조를 수정할 필요가 없게 합니다.\n- Next.js에서 OCP를 구현하는 방법은 컴포넌트 확장의 사용입니다. 함수 컴포넌트를 확장하고 처음/기본 컴포넌트에 영향을 주지 않고 새 UI 컴포넌트를 추가할 수 있습니다. 이것이 각각 확장 가능하게 열려 있지만 수정에는 폐쇄된 구현입니다.\n\n```js\n# Card.tsx\ntype CardProps = {\n  title: string;\n  desc: string;\n}\n\nconst Card: React.FC<CardProps> = ({title, desc}) => {\n  return (\n    <div>\n      <h1>{title}</h1>\n      <p>{desc}</p>\n    </div>\n  )\n}\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# ExtendedCard.tsx\n타입 ExtendedCardProps = {\n  CardProps CardProps;\n  좋아요 갯수 number;\n}\n\nconst ExtendedCard: React.FC<ExtendedCardProps> = ({CardProps, 좋아요 갯수}) => {\n  return (\n    <div>\n      <Card 속성={...CardProps} />\n      <p>{좋아요 갯수}</p>\n    </div>\n  )\n}\n```\n\nExtendedCard 컴포넌트는 Card 컴포넌트에 새로운 요소를 추가하여 props 및 컴포넌트 자체를 확장합니다.\n\n## Liskov Substitution Principle (LSP)\n\n- LSP는 슈퍼클래스의 객체가 서브클래스의 객체로 대체될 수 있어야하며 프로그램의 정확성에 영향을 주지 않아야한다고 명시합니다. 즉, 서브클래스는 에러를 발생시키지 않고 기본 클래스를 대체할 수 있어야 합니다.\r\n- 리모컨 자동차를 생각해보세요. 서로 다른 종류의 배터리를 교체할 수 있는 경우를 말합니다. 배터리가 맞고 필요한 전원을 제공한다면 어떤 브랜드나 종류의 배터리든 자동차의 작동에 영향을주지 않고 사용할 수 있습니다.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음은 Next.js 컴포넌트에서 LSP 구현 예제입니다. 이 예제에서는 DisabledButton 컴포넌트가 Button 컴포넌트의 하위 클래스입니다. DisabledButton 컴포넌트는 기본 Button 컴포넌트의 기능을 확장하여 disabled 속성을 추가합니다. 하위 클래스임에도 불구하고, DisabledButton 컴포넌트는 Button 컴포넌트와 심리스하게 교체할 수 있으며 애플리케이션의 동작에 영향을 주지 않기 때문에 LSP를 준수합니다.\n\n```js\n// components/Button.tsx\nimport React from \"react\";\n\ninterface ButtonProps {\n  onClick: () => void;\n}\n\nconst Button: React.FC<ButtonProps> = ({ onClick, children }) => {\n  return <button onClick={onClick}>{children}</button>;\n};\n\nexport default Button;\n```\n\n```js\n// components/DisabledButton.tsx\nimport React from \"react\";\nimport Button from \"./Button\";\n\ninterface DisabledButtonProps {\n  onClick: () => void;\n}\n\nconst DisabledButton: React.FC<DisabledButtonProps> = ({ onClick, children }) => {\n  return (\n    <Button onClick={onClick} disabled>\n      {children}\n    </Button>\n  );\n};\n\nexport default DisabledButton;\n```\n\n```js\n// pages/index.tsx\nimport React from \"react\";\nimport Button from \"../components/Button\";\nimport DisabledButton from \"../components/DisabledButton\";\n\nconst Home: React.FC = () => {\n  const handleClick = () => {\n    console.log(\"Button clicked!\");\n  };\n\n  return (\n    <div>\n      <h1>Hello, Next.js!</h1>\n      <Button onClick={handleClick}>Click me!</Button>\n      <DisabledButton onClick={handleClick}>Click me!</DisabledButton>\n    </div>\n  );\n};\n\nexport default Home;\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## Interface Segregation Principle (ISP)\n\n- ISP는 클라이언트가 사용하지 않는 인터페이스에 의존하지 않아야 한다는 원칙을 말합니다. 대신, 인터페이스는 클라이언트의 필요에 맞게 더 작고 더 집중된 인터페이스로 분리되어야 합니다.\n- 예를 들어 사전 설치된 다양한 앱이 함께 제공되는 스마트폰을 상상해보세요. 모든 일을 처리하는 하나의 앱이 아니라 각 앱은 메시지, 이메일 또는 지도와 같이 특정 작업을 위해 설계되어 있어 전화 사용이 더욱 효율적이고 쉬워집니다.\n\n이 예시에서 Card 구성 요소는 TextCardProps, ImageCardProps, VideoCardProps와 같은 필요한 인터페이스에만 의존하여 인터페이스 분리 원칙을 따르며, 애플리케이션에서 유지 보수 및 유연성이 향상됩니다.\n\n```js\n// Card/constants.ts\ninterface TextCardProps {\n  type: \"text\";\n  text: string;\n}\n\ninterface ImageCardProps {\n  type: \"image\";\n  imageUrl: string;\n}\n\ninterface VideoCardProps {\n  type: \"video\";\n  videoUrl: string;\n}\n\ntype CardProps = TextCardProps | ImageCardProps | VideoCardProps;\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n// Card/Card.tsx\nimport React from \"react\";\nimport { CardProps } from \"../interfaces\";\n\nconst Card: React.FC<CardProps> = ({ type, ...props }) => {\n  switch (type) {\n    case \"text\":\n      return <div>{(props as TextCardProps).text}</div>;\n    case \"image\":\n      return <img src={(props as ImageCardProps).imageUrl} alt=\"Card\" />;\n    case \"video\":\n      return <video src={(props as VideoCardProps).videoUrl} controls />;\n    default:\n      return null;\n  }\n};\n\nexport default Card;\n```\n\n```js\n// pages/Home.tsx\nimport React from \"react\";\nimport Card from \"../components/Card\";\n\nconst Home: React.FC = () => {\n  return (\n    <div>\n      <h1>Cards</h1>\n      <Card type=\"text\" text=\"This is a text card\" />\n      <Card type=\"image\" imageUrl=\"https://example.com/image.jpg\" />\n      <Card type=\"video\" videoUrl=\"https://example.com/video.mp4\" />\n    </div>\n  );\n};\n\nexport default Home;\n```\n\n## 의존 역전 원칙 (DIP)\n\n- DIP(Dependency Inversion Principle)은 고수준 모듈이 저수준 모듈에 의존하지 않아야 한다는 것을 말합니다. 그 대신 둘 다 추상화에 의존해야 합니다. 이는 모듈들을 분리하여 재사용 가능하고 테스트하기 쉽게 만들어줍니다.\n- 벽돌로 지어진 집을 생각해보세요. 각 벽돌이 아래 벽돌에 의존하는 대신, 모든 벽돌이 기초에 의존합니다. 기초가 튼튼하면 개별 벽돌을 교체해도 집은 안정적으로 유지됩니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서는 React의 Context API 또는 의존성 주입을 사용하여 의존성 역전 원칙(Dependency Inversion Principle, DIP)을 구현할 수 있습니다. 여기서 StoreProvider 컴포넌트는 나머지 애플리케이션에 Redux 스토어를 제공하는 역할을 합니다. 이를 통해 스토어의 생성을 사용하는 컴포넌트와 분리하여 테스트와 재사용성을 촉진합니다.\n\n```js\n// providers/StoreProvider.tsx\n\"use client\";\n\nimport React, { useRef } from \"react\";\nimport { Provider } from \"react-redux\";\nimport { makeStore, AppStore } from \"../context/hamburgerContext/store\";\n\nexport default function StoreProvider({ children }: { children: React.ReactNode }) {\n const storeRef = useRef<AppStore>();\n if (!storeRef.current) {\n  // 처음 렌더링될 때 스토어 인스턴스를 생성합니다.\n  storeRef.current = makeStore();\n  storeRef.current.dispatch({ type: \"INITIALIZE_HAMBURGER\" });\n }\n\n return <Provider store={storeRef.current}>{children}</Provider>;\n}\n```\n\n```js\n// pages/_app.tsx\nimport \"@/styles/globals.css\";\nimport \"@/styles/carousel.style.css\";\nimport type { AppProps } from \"next/app\";\nimport TranslateProvider from \"../providers/TranslateProvider\";\nimport BaseLayout from \"../components/elements/layout/BaseLayout\";\nimport StoreProvider from \"../providers/StoreProvider\";\n\nexport default function App({ Component, pageProps }: AppProps) {\n return (\n  <TranslateProvider>\n   <StoreProvider>\n    <BaseLayout>\n     <Component {...pageProps} />\n    </BaseLayout>\n   </StoreProvider>\n  </TranslateProvider>\n );\n}\n```\n\n## SOLID 원칙의 구현 장점\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js 프로젝트에서 SOLID 원칙을 적용하면 여러 가지 이점을 누릴 수 있어요. \n\n- 향상된 코드 품질: SOLID 원칙을 따르면 더 깨끗하고 조직화된 코드를 작성할 수 있어요. 이는 이해하기 쉽고 유지보수하기 쉬운 코드로 이어지며 버그가 적어지고 개발 주기가 빨라집니다. \n- 더 나은 확장성: SOLID 원칙은 모듈화된 설계를 촉진하여 새로운 기능을 추가하거나 애플리케이션을 확장할 때 쉬워집니다. 기존 기능을 수정하지 않고 기능을 확장할 수 있어요. 이는 코드 재사용을 촉진하고 버그 발생 가능성을 줄입니다. \n- 향상된 유지보수성: SOLID 원칙을 적용하면 각 구성 요소가 단일 책임을 가지게 되어 문제가 발생했을 때 이를 분리하고 수정하기 쉬워집니다. 이는 새로운 개발자가 코드베이스에 익숙해지고 이해하기 쉽게 만들어 줘요. \n- 더 큰 유연성: SOLID 원칙을 따르면 Next.js 애플리케이션의 동작을 쉽게 변경하거나 확장할 수 있습니다. 이 유연성은 요구 사항의 변화에 적응하거나 새로운 기능을 통합하는 데 중요합니다. \n- 쉬운 테스트: SOLID 원칙은 격리된 환경에서 테스트하기 쉬운 코드를 촉진합니다. 이는 신뢰할 수 있는 테스트와 코드 정확성에 대한 더 높은 수준의 신뢰를 보장해 줍니다. 특히 Next.js 프로젝트에서는 구성 요소간 복잡한 상호작용으로 인해 테스트가 어려울 수 있습니다.\n\n요약하자면, Next.js 프로젝트에서 SOLID 원칙을 적용하면 더 견고하고 유지보수하기 쉬운 확장 가능한 애플리케이션으로 이끌어줍니다. 이는 개발 경험과 최종 제품의 품질을 향상시킵니다.\n\n# 제 3장: Next.js 및 Typescript Best Practices\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 장에서는 Next.js와 TypeScript를 사용하는 최상의 방법에 대해 알아보겠습니다. 이는 강력한 React 프레임워크의 장점과 정적 타이핑의 안전성 및 명확성을 결합한 것입니다. TypeScript가 어떻게 Next.js에서 개발 경험을 향상시키는지에 대해 살펴보겠습니다. 프로젝트 설정부터 컴포넌트 구조화 및 데이터 처리까지! 함께 알아봅시다!\n\n1. `Avoid any and type everything`. 항상 any가 아닌 다른 타입으로 변수 또는 상수를 선언해야 합니다. TypeScript에서 타입 없이 변수나 상수를 선언할 때, 변수/상수의 타입은 할당된 값에 따라 추론됩니다. 새 프로젝트에서는 모든 엄격한 타입 확인 옵션을 활성화하기 위해 tsconfig.json 파일에서 strict:true를 설정하는 것이 좋습니다.\n\n```json\n{\n  \"compilerOptions\": {\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"allowJs\": true,\n    \"skipLibCheck\": true,\n    \"strict\": true,\n    \"noEmit\": true,\n    \"esModuleInterop\": true,\n    \"module\": \"esnext\",\n    \"moduleResolution\": \"node\",\n    \"resolveJsonModule\": true,\n    \"isolatedModules\": true,\n    \"jsx\": \"preserve\",\n    \"incremental\": true,\n    \"paths\": {\n      \"@/*\": [\"./src/*\"]\n    }\n  },\n  \"include\": [\"next-env.d.ts\", \"**/*.ts\", \"**/*.tsx\"],\n  \"exclude\": [\"node_modules\"]\n}\n```\n\n2. `Type Annotations for Props and State`. Next.js에서 TypeScript를 사용할 때, 컴포넌트의 props와 state에 대한 유형 주석을 제공하는 것이 중요합니다. 이는 컴포넌트로 흐르는 데이터의 올바른 유형을 보장하여 런타임 오류의 가능성을 줄입니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![Mastering Next.js: Best Practices for Clean, Scalable, and Type-Safe Development](/assets/img/2024-07-07-MasteringNextjsBestPracticesforCleanScalableandType-SafeDevelopment_1.png)\n\n![Mastering Next.js: Best Practices for Clean, Scalable, and Type-Safe Development](/assets/img/2024-07-07-MasteringNextjsBestPracticesforCleanScalableandType-SafeDevelopment_2.png)\n\n3. Leverage Functional Components and React Hooks. Functional components and React hooks are a powerful combination in Next.js. Functional components are easier to read and maintain, while hooks like useState and useEffect provide a cleaner way to manage state and side effects.\n\n![Mastering Next.js: Best Practices for Clean, Scalable, and Type-Safe Development](/assets/img/2024-07-07-MasteringNextjsBestPracticesforCleanScalableandType-SafeDevelopment_3.png)\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n4. TypeScript 유틸리티 타입(Partial, Required, Omit) 사용하기. Partial, Required, Omit과 같은 TypeScript 유틸리티 타입을 활용하면 더 정확한 타입 정의를 만들 수 있습니다. Partial을 사용하면 타입의 모든 속성을 옵션으로 만들 수 있고, Required는 타입의 모든 속성이 필수임을 보장하며, Omit은 기존 타입에서 특정 속성을 제외한 새로운 타입을 생성합니다.\n\n5. ESLint로 코드 서식 일관성 유지 설정하기. ESLint는 코드 서식 지원 도구로 프로젝트 전체에서 일관된 코드 스타일을 유지하는 데 도움을 줍니다. Next.js 프로젝트에 설정하면 코드가 일관되게 서식이 맞춰져 가독성과 유지보수가 쉬워집니다.\n\n![이미지](/assets/img/2024-07-07-MasteringNextjsBestPracticesforCleanScalableandType-SafeDevelopment_4.png)\n\n6. \"?\"로 옵션으로 지정하기. TypeScript에서는 타입 정의에서 속성 이름 뒤에 \"?\"를 추가하여 속성을 옵션으로 표시할 수 있습니다. 이는 가끔 필요하지 않은 프롭스나 상태 속성이 있는 경우 유용합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n7. 조건부 렌더링. 조건부 렌더링은 특정 조건에 따라 다른 컴포넌트나 요소를 렌더링할 수 있습니다. 이를 위해 일반 JavaScript if 문이나 삼항 연산자를 JSX 코드 내에서 사용할 수 있습니다.\n\n8. Redux를 사용하여 전역 상태 관리 활성화하기. Redux는 React 및 Next.js 애플리케이션에 많이 사용되는 상태 관리 라이브러리입니다. Redux를 사용하면 전역 상태를 유지할 수 있어 어떤 컴포넌트에서든 액세스할 수 있으며, 컴포넌트 트리의 여러 수준을 통해 props를 전달할 필요가 없습니다 (state drilling).\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-07-07-MasteringNextjsBestPracticesforCleanScalableandType-SafeDevelopment_7.png)\n\n9. 타입 정의, 인터페이스 및 상수를 하나의 파일로 분리하세요. 타입 정의, 인터페이스 및 상수를 하나의 파일에 유지하면 깔끔하고 조직적인 프로젝트 구조를 유지할 수 있습니다. 이렇게 하면 프로젝트가 성장함에 따라 타입 정의를 찾고 관리하는 것이 쉬워집니다.\n\n![이미지](/assets/img/2024-07-07-MasteringNextjsBestPracticesforCleanScalableandType-SafeDevelopment_8.png)\n\n10. 항목 목록을 만들고 배열을 반복하여 컴포넌트 목록을 만드세요. Next.js에서 항목 목록을 렌더링할 때 map 함수를 사용하여 배열을 반복하고 각 항목에 대해 컴포넌트를 렌더링할 수 있습니다. 이를 통해 기본 데이터가 변경될 때 자동으로 업데이트되는 동적 목록을 만들 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-07-07-MasteringNextjsBestPracticesforCleanScalableandType-SafeDevelopment_9.png)\n\n## Next.js의 장점 - TypeScript Best Practice\n\nNext.js와 TypeScript를 결합하면 강력한 유형 시스템을 제공하여 코드 가독성과 유지 관리성을 향상시킬 수 있습니다. 이는 개발 중에 오류를 잡는 데 도움이 되며 이 조합은 더 견고하고 신뢰할 수 있는 애플리케이션을 만드는 데 기여할 수 있습니다. 또한 Next.js에서 TypeScript를 사용하면 더 나은 코드 구성 및 확장성을 구현할 수 있어 더 큰 코드베이스를 관리하고 개발팀 간 협업을 더 쉽게 할 수 있습니다.\n\n참고문헌","ogImage":{"url":"/assets/img/2024-07-07-MasteringNextjsBestPracticesforCleanScalableandType-SafeDevelopment_0.png"},"coverImage":"/assets/img/2024-07-07-MasteringNextjsBestPracticesforCleanScalableandType-SafeDevelopment_0.png","tag":["Tech"],"readingTime":20}],"page":"11","totalPageCount":19,"totalPageGroupCount":1,"lastPageGroup":19,"currentPageGroup":0},"__N_SSG":true}