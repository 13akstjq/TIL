{"pageProps":{"posts":[{"title":"AI 버전의 나를 만드는 방법","description":"","date":"2024-07-09 19:14","slug":"2024-07-09-HowICreatedanAIVersionofMyself","content":"\n![이미지](/TIL/assets/img/2024-07-09-HowICreatedanAIVersionofMyself_0.png)\n\n생성적 AI는 화가 나게 만드는 괴로운 발전으로 가장 잘 설명될 수 있습니다. 2022년 말에 처음 출시된 ChatGPT는 자연어의 품질에 대해 현혹되고 광활한 놀라움을 줬습니다. 그 이후로 그 제품에 대한 다수의 업데이트와 경쟁 제품이 등장했습니다.\n\n하지만 초기의 흥분은 기술에 대한 다수의 좌절로 바뀌었습니다. 이러한 모델의 출력을 조절하는 것은 어려운 것으로 보이며, 환각 때문에 생성물의 내용이 항상 신속하지만 신뢰할 수 없다는 것이 문제입니다. 마감일 때문에 내용이 뒤늦어지고, 모델은 특정 요청에 대한 배경지식이 부족하기 때문에 대답이 종종 올바르지 않거나 유용하지 않게 일반적일 수 있습니다, 특히 조직이나 비즈니스 설정에서.\n\n검색 증강 생성(RAG)은 큰 언어 모델을 더 효과적으로 사용하는 방법입니다. 비용이 크게 들지 않고 간단한 워크플로우를 사용하여, 모델에 관련된 맥락 정보를 제공하고 주어진 정보를 기반으로 답변하거나 주어진 정보를 우선시하여 반응하도록 제한할 수 있습니다. 이러한 방식으로, 큰 언어 모델의 실제 가치가 발휘됩니다 — 컨텐츠의 자동 자연어 요약기로서, 환각과 같은 원치 않는 행동은 최소화되거나 아예 제거될 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 내용을 번역하겠습니다.\n\n이를 설명하기 위해 저는 통계 교재 Regression Modeling Handbook에 관한 질문에 답변하는 RAG 애플리케이션의 최소 버전을 만들었던 기술적 자습서를 제작했습니다. 이 자습서의 끝에서는 교재에 있는 내용만을 기반으로 질문을 할 수 있는 간단한 파이프라인을 만들었을 것입니다. 그래서 이것은 귀하의 질문에 답변하기 위해 제 통계 지식만을 사용하는 제 AI 버전과 같습니다.\n\n이 자습서는 제 교재를 포함한 모든 자료가 오픈 소스로 제공되기 때문에 완전히 재현 가능합니다. 심지어 제가 사용하는 LLM도 오픈 소스인데요 (Google의 Gemma-7b LLM, 그것이 Gemini 제품의 기초입니다). 그러나 주의할 점이 있습니다: 저는 극도로 고사양의 기계인 MacBook M1 Max with 128GB RAM을 사용하고 있으므로 Gemma를 로컬에서만 실행할 수 있습니다. 만약 귀하가 그러한 고사양 기기를 가지고 있지 않다면 클라우드 자원을 사용하거나 chatGPT와 같은 호스팅된 LLM의 API를 사용해야 할 것입니다.\n\n## Retrieval Augmented Generation (RAG) 개요\n\n![이미지](/TIL/assets/img/2024-07-09-HowICreatedanAIVersionofMyself_1.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n전형적인 LLM 상호작용에서 사용자는 직접 LLM에 프롬프트를 보내고 LLM의 훈련 세트에 기반한 응답을 받게 됩니다. 일반적인 작업에는 유용하지만 전문적인 지식이나 맥락이 필요한 경우 응답은 대개 만족스럽지 않을 수 있습니다.\n\nRAG의 아이디어는 프롬프트가 전문 지식 데이터베이스를 방문하여 몇 가지 관련 문서를 가져와 LLM에 전달하는 것입니다. 프롬프트는 LLM이 동반된 문서를 기반으로만 답변하도록 제한된 프롬프트로 구성될 수 있으며, 이를 통해 보다 맥락에 맞는 응답의 품질을 보장할 수 있습니다.\n\n위 다이어그램에 나타난 아키텍처는 두 가지 구성 요소로 간주할 수 있습니다:\n\n- 정보 검색 구성 요소는 문서 저장소에서 프롬프트와 가장 유사한 문서를 찾아 추출합니다. 이는 벡터 데이터베이스를 사용하여 문서 유사성을 판별하는 방식으로 이루어집니다.\n- LLM 구성 요소는 원래 프롬프트와 일치하는 문서를 사용하여 새로운 프롬프트를 작성하고 이를 우리 LLM에 보내 응답을 유도합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 튜토리얼에서는 Python을 사용하여 이 구조의 최소 예제를 만들 것입니다. 전체 Jupyter 노트북은 여기에서 찾을 수 있어요.\n\n## 문서를 가져오고 준비하기\n\n문서 저장소에는 교과서 내용이 포함될 것이며, 해당 교과서는 이 Github 저장소에서 오픈 소스 형태로 제공됩니다. 이 책은 14장과 텍스트, 코드 및 수학 공식이 포함된 섹션으로 구성되어 있으며, 각각이 마크다운 문서에서 생성됩니다.\n\n먼저 필요한 몇 가지 패키지를 설치할 것입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport torch\nfrom langchain_community.document_loaders import DataFrameLoader\nfrom langchain.text_splitter import RecursiveCharacterTextSplitter\nfrom transformers import AutoTokenizer, AutoModelForCausalLM\nfrom dotenv import load_dotenv\nfrom huggingface_hub import login\nimport os\nimport pandas as pd\n```\n\n이제 교과서의 모든 14 장의 텍스트를 가져와서 Pandas 데이터프레임에 저장할 겁니다:\n\n```js\nimport requests\n\n# 장(chapter)은 다음과 같은 이름을 가진 Rmd 파일들입니다.\nchapter_list = [\n    \"01-intro\",\n    \"02-basic_r\",\n    \"03-primer_stats\",\n    \"04-linear_regression\",\n    \"05-binomial_logistic_regression\",\n    \"06-multinomial_regression\",\n    \"07-ordinal_regression\",\n    \"08-hierarchical_data\",\n    \"09-survival_analysis\",\n    \"10-tidy_modeling\",\n    \"11-power_tests\",\n    \"12-further\",\n    \"13-solutions\",\n    \"14-bibliography\"\n]\n\n# 각 장의 텍스트를 가져오는 함수 생성\ndef get_text(chapter: str) -> str:\n    # Rmd 파일이 저장된 Github의 URL\n    github_url = f\"https://raw.githubusercontent.com/keithmcnulty/peopleanalytics-regression-book/master/r/{chapter}.Rmd\"\n\n    result = requests.get(github_url)\n    return result.text\n\n# 각 장의 URL을 순회하며 텍스트 내용을 가져오기\nbook_text = []\nfor chapter in chapter_list:\n    chapter_text = get_text(chapter)\n    book_text.append(chapter_text)\n\n# 데이터프레임에 작성\nbook_data = dict(chapter = list(range(14)), text = book_text)\nbook_data = pd.DataFrame.from_dict(book_data)\n```\n\n현재, 저는 길이가 상당히 긴 14개의 문서를 가지게 되었습니다. 앞으로 생각해보면, LLM에 보낼 모든 문서는 그 문맥 창에 맞게 맞춰져야 합니다. 현재 문서의 길이에서는 이를 제어할 수 없으므로, 이러한 문서를 더 많은 짧은 문서로 분할해야 할 필요가 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러나 무작위로 나눌 수는 없어요. 의미론적으로 분할해야 해요. 이렇게 하면 개별 문서가 어디서든 갑자기 잘려서 의미가 낯설지 않고 문서 전체가 의미론적으로 완성될 거예요. langchain Python 패키지의 멋진 기능을 사용할 거에요. 내 문서들을 1000단어로 제한하고 그 사이에 최대 150단어의 중복이 허용되도록 할 거예요.\n\n```js\n# 문단을 의미론적으로 1000의 최대 길이로 분할\nloader = DataFrameLoader(book_data, page_content_column=\"text\")\ndata = loader.load()\ntext_splitter = RecursiveCharacterTextSplitter(chunk_size=1000, chunk_overlap=150)\ndocs = text_splitter.split_documents(data)\n\n# 몇 개의 문서가 나왔나요?\nlen(docs)\n\n## 578\n```\n\n내 14개의 원본 문서가 578개의 작은 문서로 분할되었어요. langchain의 문서 형식이 어떻게 생겼는지 확인하기 위해 첫 번째 문서를 살펴보죠:\n\n```js\n# 예상대로 문서가 보이는지 확인하기 위해 문서를 살펴봅시다\ndocs[0]\n\n## Document(page_content=\"`r if (knitr::is_latex_output()) '\\\\\\\\mainmatter'`\\n\\n# The Importance of Regression in People Analytics {#inf-model}\\n\\nIn the 19th century,\n## when Francis Galton first used the term 'regression' to describe a statistical phenomenon (see Chapter \\\\@ref(linear-reg-ols)), little did he know how important that\n## term would be today.  Many of the most powerful tools of statistical inference that we now have at our disposal can be traced back to the types of early analysis that\n## Galton and his contemporaries were engaged in.  The sheer number of different regression-related methodologies and variants that are available to researchers and practitioners\n## today is mind-boggling, and there are still rich veins of ongoing research that are focused on defining and refining new forms of regression to tackle new problems.\",\n## metadata={'chapter': 0})\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n문서 개체에 페이지 내용 키와 관심 대상 텍스트가 포함되어 있음을 알 수 있습니다. 또한 메타데이터 키도 포함되어 있지만 우리에게는 관심이 없습니다.\n\n## 나의 문서를 포함하는 벡터 데이터베이스 설정하기\n\n![이미지](/TIL/assets/img/2024-07-09-HowICreatedanAIVersionofMyself_2.png)\n\n적절한 길이의 문서를 보유하게 되었으므로, 이제 해당 문서를 벡터 데이터베이스에 로드해야 합니다. 벡터 데이터베이스는 텍스트를 원본 형식으로 저장하는데 더불어 임베딩으로도 저장합니다. 임베딩은 대규모의 부동 소수점 수 배열로, 대형 언어 모델이 언어를 처리하는 데 기본적인 역할을 합니다. 다차원 공간에서 '근접한' 임베딩을 가진 단어, 문장 또는 문서는 콘텐츠 면에서 서로 밀접한 관련성을 가질 것입니다. 임베딩 개념의 2D 그래픽 단순화된 다이어그램은 위의 도표를 참조하십시오.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n제가 프롬프트를 제출하면, 벡터 데이터베이스는 프롬프트의 임베딩을 사용하여 포함된 문서들 중에서 가장 가까운 임베딩을 찾게 될 거예요. '가장 가까운'을 정의하는 방법에는 여러 가지 옵션이 있어요. 이 경우에는 코사인 유사도를 사용할 거에요. 코사인 유사도는 두 벡터 사이의 각도의 코사인을 사용하여 거리를 결정해요. 코사인 유사도가 높을수록 두 문서가 관련성이 높다고 볼 수 있어요.\n\n이 작업을 쉽게 하기 위해 저는 chromadb Python 패키지를 사용할 거에요. 이 패키지를 사용하면 로컬 컴퓨터에 벡터 데이터베이스를 설정할 수 있어요. 먼저 데이터베이스를 설정하고 임베딩을 생성할 때 사용할 언어 모델과 거리 측정 방법을 정의해야 해요. 이를 위해 표준이고 효율적인 언어 모델을 선택할 거에요.\n\n```js\nimport chromadb\nfrom chromadb.utils import embedding_functions\nfrom chromadb.utils.batch_utils import create_batches\nimport uuid\n\n# ChromaDB 설정\nCHROMA_DATA_PATH = \"./chroma_data_regression_book/\"\nEMBED_MODEL = \"all-MiniLM-L6-v2\"\nCOLLECTION_NAME = \"regression_book_docs\"\n\nclient = chromadb.PersistentClient(path=CHROMA_DATA_PATH)\n\n# 코사인 유사도를 거리 측정 방법으로 사용하여 DB 활성화\nembedding_func = embedding_functions.SentenceTransformerEmbeddingFunction(\n    model_name=EMBED_MODEL\n)\n\ncollection = client.create_collection(\n    name=COLLECTION_NAME,\n    embedding_function=embedding_func,\n    metadata={\"hnsw:space\": \"cosine\"},\n)\n```\n\n이제 문서를 로드할 준비가 되었어요. 벡터 데이터베이스는 한 번에 로드할 수 있는 문서의 제한이 있어요. 제 경우에는 몇 백 개의 문서밖에 없어서 괜찮을 것 같지만, 그래도 안전하게 하기 위해 일괄 로드를 설정하겠어요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# DB에 텍스트 뭉치를 일괄적으로 작성합니다\nbatches = create_batches(\n    api=client,\n    ids=[f\"{uuid.uuid4()}\" for i in range(len(docs))],\n    documents=[doc.page_content for doc in docs],\n    metadatas=[{'source': './handbook_of_regression_modeling', 'row': k} for k in range(len(docs))]\n)\n\nfor batch in batches:\n    print(f\"크기가 {len(batch[0])}인 일괄 처리를 추가합니다\")\n    collection.add(ids=batch[0],\n                   documents=batch[3],\n                   metadatas=batch[2])\n\n## 크기가 578인 일괄 처리를 추가 중\n\n한 번에 한 개의 일괄 처리만이 필요했지만, 더 많은 문서 세트로 시도할 경우 위의 코드를 사용하여 여러 개의 일괄 처리를 로드할 수 있습니다.\n\n이제 문서 저장소가 설정되었습니다. 이제 테스트할 차례입니다. 쿼리에 유사한 문서를 반환하는지 확인해보겠습니다. 통계적 질문을 하고 세 개의 가장 가까운 매칭 문서를 요청하겠습니다.\n\nresults = collection.query(\n    query_texts=[\"어떤 방법을 추천하시겠습니까?\"],\n    n_results=3,\n    include=['documents']\n)\n\nresults\n\n# {'ids': [['371eeda2-c01f-420b-80c6-2b61894d0069',\n#   '94fc3891-4b37-49b9-a797-e73a11eec739',\n#   '3360431f-6857-47ac-a329-af10b6528c61']],\n#   'distances': None,\n#   'metadatas': None,\n#   'embeddings': None,\n#   'documents': [['# Proportional Odds Logistic Regression for Ordered Category Outcomes {#ord-reg}',\n#   \"# Multinomial Logistic Regression for Nominal Category Outcomes\\n\\n`r if (knitr::is_latex_output()) '\\\\\\\\index{multinomial logistic regression|(}'`\\n이전 장에서 우리는 로지스틱 함수를 사용하여 이항 또는 이분적 결과를 모델링하는 방법을 살펴보았습니다. 이 장에서는 결과가 어떤 순서도 없는 여러 범주를 가질 때 이를 어떻게 확장하는지 살펴보겠습니다. 결과가 이 명목적 범주형 형태를 갖추면 방향감이 없습니다. '더 좋은' 또는 '더 나쁜'과 같은 개념도 없고 '더 높은' 또는 '더 낮은'과 같은 개념도 없습니다. 다만 '다른' 것 뿐입니다.\\n\\n## 언제 사용해야 하나요?\\n\\n### 다항 로지스틱 회귀에 대한 직관\\n\\n이전 장에서 공부한 이항 또는 이분적 결과는 사실 두 가지 범주를 갖추는 명목적 결과입니다. 원칙적으로 우리는 이미 이 문제를 공부할 기본 기술을 갖추고 있습니다. 하지만 우리가 만들고자 하는 종류의 추론에 따라 문제에 접근하는 방식이 다를 수 있습니다.\",\n#   '사실, 서열 결과의 추론적 모델링에 대해 다양한 알려진 방법이 있으며, 이 모두는 이전 장에서 다룬 선형, 이항 및 다항 로지스틱 회귀 이론을 기반으로 합니다. 이 장에서는 가장 흔히 채택되는 방법에 초점을 맞출 것입니다: *비례오즈*(proportional odds) 로지스틱 회귀. 비례오즈 모델(가끔은 제한된 누적 로지스틱 모델이라고도 함)은 해석하기 쉬운 장점이 있지만 근본적인 가정을 중요한 확인 없이 사용할 수 없습니다. \\n\\n## 언제 사용해야 하나요?\\n\\n### 비례오즈 로지스틱 회귀에 대한 직관 {#ord-intuit}']],\n#  'uris': None,\n#  'data': None}\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저는 꽤 잘 되어 있는 것 같아요! 이제 정보 검색 레이어를 완료했네요. 이제 LLM 레이어로 넘어가는 시간이에요.\n\n## 내 컴퓨터에 구글의 Gemma-7b-it LLM 설정하기\n\nGemma-7b-it은 구글의 Gemini를 위한 70억 개 파라미터 지침 조정 버전의 기초 모델입니다. 이 모델은 약 20GB 크기로 Huggingface에서 사용할 수 있어요. 모델을 다운로드하고 사용하기 위해서는 약관에 동의하고 액세스 키를 받아야 해요. 이 크기의 모델을 사용하려면 상당히 강력한 CPU, GPU 및 RAM이 필요할 거예요.\n\n먼저 모델에 접근하여 다운로드할 거에요. 처음으로 이를 수행할 때는 시간이 좀 걸릴 수 있지만, 한 번 다운로드되어 캐시에 저장되면 빨리 로드될 거예요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 내 토큰을 사용하여 Huggingface에 로그인합니다.\nload_dotenv()\nlogin(token=os.getenv(\"HF_TOKEN\"))\n\n# Gemma-7b-it 다운로드하기\nmodel = AutoModelForCausalLM.from_pretrained(\"google/gemma-7b-it\")\ntokenizer = AutoTokenizer.from_pretrained(\"google/gemma-7b-it\", padding=True, truncation=True, max_length=512)\n\n이제 테스트해 봅시다. 이 모델은 대화 형식으로 모델과 사용자 간의 대화 형식으로 프롬프트를 받는 것을 좋아합니다. 다음은 권장하는 프롬프트 형식입니다:\n\nprompt = \"\"\"\n<start_of_turn>user\n뉴멕시코에서 무슨 음식을 먹어봐야 할까요?<end_of_turn>\n<start_of_turn>model\n\"\"\"\n\n이제 이 프롬프트를 Gemma가 이해할 수 있는 임베딩으로 변환하고, Gemma에게 응답 생성을 요청하고, 해당 응답을 텍스트로 디코딩하고, Gemma가 제공한 새로운 부분을 잘라냅니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 프롬프트를 임베드합니다\ninput_ids = tokenizer(prompt, return_tensors=\"pt\")\n\n# 답변을 생성합니다\noutputs = model.generate(**input_ids, max_new_tokens=512)\n\n# 답변을 디코드합니다\ntokenizer.decode(outputs[0], skip_special_tokens=True).split('model\\n', 1)[1]\n\n# \"뉴멕시코는 독특한 Native American, 스페인, 멕시코 영향을 혼합한 독특한 요리로 유명합니다. 여기 랜드 오브 엔찬트먼트에서 꼭 먹어봐야 할 음식 목록이 있습니다:\\n\\n**전통적인 Native American 음식:**\\n\\n* **인디언 타코:** 고기(흔히 양 또는 소), 콩, 치즈, 상추, 토마토 및 빨간 고추 가루가 들어간 옥수수 토르티야.\\n* **칠레스 엔 노갓:** 빨간색과 녹색 칠레, 감자, 채소가 들어간 맛있는 소스로 쌓인 요리.\\n* **소파이피야스:** 종종 꿀이나 잼과 함께 제공되는 바삭한 튀긴 도우 구이.\\n* **포솔레:** 콘 토르티야와 빨간 고추 가루로 제공되는 풍미 있는 수육이 들어간 요리.\\n\\n**스페인과 멕시코 영향:**\\n\\n* **해치 칠레:** 해치, 뉴멕시코에서 재배된 녹색과 빨간색 칠레는 독특한 맛과 맵기로 유명합니다.\\n* **빨간색과 녹색 칠레 스튜:** 빨간색과 녹색 칠레, 채소, 고기를 넣고 끓여 만든 푸짐한 스튜.\\n* **까르네 아도바다:** 빨간 고추 가루로 절여진 천천히 굽는 소고기.\\n* **비스코치토스:** 시나몬과 설탕이 묻힌 바삭한 튀긴 과자.\\n* **소파피야스:** 과일, 꿀 또는 치즈가 들어간 튀긴 도우로 만든 달콤한 또는 짠 간식.\\n\\n**다른 꼭 먹어봐야 할 음식:**\\n\\n* **녹색 칠레 치즈버거:** 빨간 대신 녹색 칠레가 들어간 클래식 치즈버거 개량 버전.\\n* **블루 콘:** 짙은 파란색의 독특한 옥수수 종류로, 주로 토르티야와 다른 요리에 사용됩니다.\\n* **터콰즈 아이스크림:** 터콰즈색 아이스크림 파우더로 만든 상쾌한 아이스크림.\\n\\n**추가 팁:**\\n\\n* **매운맛에 대해 고려하세요:** 뉴멕시코 요리는 매운 정도로 유명합니다. 맵지 않은 음식에 익숙하지 않다면 온순한 버전을 요청하세요.\\n* **현지 레스토랑을 시식하세요:** 뉴멕시코에는 전통 요리를 제공하는 많은 훌륭한 현지 레스토랑이 있습니다.\\n* **음식 축제를 방문하세요:** 뉴멕시코에는 연중 음식 축제가 많이 열립니다.\\n* **현지 맥주를 꼭 맛보세요:** 뉴멕시코에는 번창하는 크래프트 맥주 씬이 있습니다.\"\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\ndef ask_question(question: str, model: AutoModelForCausalLM = model, tokenizer: AutoTokenizer = tokenizer, collection: str = COLLECTION_NAME, n_docs: int = 3) -> str:\n\n    # Find close documents in chromadb\n    collection = client.get_collection(collection)\n    results = collection.query(\n       query_texts=[question],\n       n_results=n_docs\n    )\n\n    # Collect the results in a context\n    context = \"\\n\".join([r for r in results['documents'][0]])\n\n    prompt = f\"\"\"\n    <start_of_turn>user\n    통계학과 사람들 분석에 적용된 분야에 대한 전문가입니다.\n    여기 질문이 있습니다: {question}\\n\\n 다음 정보를 참조하여만 답해주세요: {context}.<end_of_turn>\n    <start_of_turn>model\n    \"\"\"\n\n    # Generate the answer using the LLM\n    input_ids = tokenizer(prompt, return_tensors=\"pt\")\n\n    # Return the generated answer\n    outputs = model.generate(**input_ids, max_new_tokens=512)\n    return tokenizer.decode(outputs[0], skip_special_tokens=True).split('model\\n', 1)[1]\n\n## 나를 AI 버전으로 테스트하기\n\n이제 교재에 써 놓은 지식을 기반으로 응답하는지 확인하기 위해 몇 가지 질문을 해보겠습니다.\n\nask_question(\"순서대로 범주형 결과를 모델링하는 데 어떤 방법을 추천하시겠습니까? 그리고 그 이유는 무엇인가요?\")\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이렇게 답하는 것 같아요. 또 다른 것을 해보죠:\n\nask_question('Proportional Odds 회귀분석을 사용할 때 주의해야 할 점은 무엇인가요?')\n\n## Proportional Odds 회귀분석을 사용할 때 주의해야 할 점은 다음과 같습니다:\\n\\n\n## * **Proportional Odds 가정 검정:** 모델을 실행하기 전에 데이터에 적합한지 확인하기 위해 Proportional Odds 가정을 테스트해야 합니다. 가정이 실패하면 순서형 결과에 대한 대안 모델을 고려해야 합니다.\\n\n## * **변수 제거:** 가정이 실패하면 결과에 영향을 미치지 않는 변수를 제거할 수 있습니다. 그러나 이를 하는 것이 적합한지 여부는 전반적인 모델 적합도에 대한 영향에 매우 의존합니다.\\n\n## * **대안 모델:** 변수 제거에 대해 편안하지 않다면, 순서형 결과에 대한 대안 모델을 고려해야 합니다. 가장 일반적인 대안 모델로는 누적 로짓 모델, 순위 기반 모델, 기준 기반 모델 등이 있습니다.'\n\n다시, 제가 한 말 같네요. 그러면 교재에 다루지 않는 주제에 대해 물어본다면 어떨까요?\n\nask_question('물리학의 표준 모델은 무엇인가요?')\n\n## 교재에는 물리학의 표준 모델에 대한 정보가 제공되지 않았기 때문에 이 질문에 대답할 수 없습니다.'\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n좋아요! 그것이 내가 할 것처럼 그 자리에 머물러 있네요.\n\n## 그래서 우리가 배운 것은 무엇인가요?\n\nAI Keith를 만드는 것이 재미있었을 뿐만 아니라, 이것은 LLM의 능력을 활용하되 맥락 정보로 보완하고 망상하는 경향을 통제할 수 있는 간단한 아키텍처를 보여줍니다. 이는 지식 검색에 상당한 응용 가능성이 있으며, 큰 지식 저장소의 검색을 요약하는 길을 제공하는 이 아키텍처는 가치가 있습니다.\n\nAI Keith에 대해서는, 곧 오픈할 계획이 없습니다. 우선 이 예제는 너무 소규모이고, 이러한 아키텍처를 프로덕션에 호스팅하고 항상 사용 가능하게 유지하려는 시도는 비용이 너무 많이 들어 사용 이유를 정당화하기 힘들 것입니다. 하지만 더 큰 규모의 상황에서의 가능성을 보시게 되기를 희망합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAI Keith에 대해 어떻게 생각하시나요? RAG 아키텍처를 다뤄보신 적이 있나요? 자유롭게 의견을 남겨주세요!\n```\n","ogImage":{"url":"/assets/img/2024-07-09-HowICreatedanAIVersionofMyself_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-HowICreatedanAIVersionofMyself_0.png","tag":["Tech"],"readingTime":18},{"title":"파이썬에서 덮어쓰기 헷갈리지만 위험하고 강력한 방법","description":"","date":"2024-07-09 19:09","slug":"2024-07-09-OverwritinginPythonTrickyDangerousPowerful","content":"\n## 파이썬 프로그래밍\n\n![이미지](/TIL/assets/img/2024-07-09-OverwritinginPythonTrickyDangerousPowerful_0.png)\n\n파이썬에서 여러 가지 객체를 덮어썼습니다. 여러분도 파이썬으로 코딩하는데 많은 시간을 보냈다면 이를 경험했을 것입니다. 적어도 파이썬에서는 객체를 덮어쓰는 것이 이 언어의 핵심이기 때문입니다.\n\n변수를 덮어썼지만 함수, 클래스, 그리고 클래스 메서드까지도 덮어썼습니다. 때로는 예외까지 덮어썼습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그리고 실제로 변수 덮어쓰기와 호출 가능한 객체 덮어쓰기 사이에는 차이가 있습니다. 이 두 가지 프로세스 간의 차이는 실제로 상당히 중요합니다. 후자는 더 까다롭기 때문에요. 호출 가능한 객체 덮어쓰기에 초점을 맞추고 있지만, 좀 더 고급 기술인 것으로 알려진 것이기 때문에 변수 덮어쓰기에 대해서도 이야기할 것입니다. 그것은 이야기를 이어가는 좋은 시작점을 제공하기 때문이죠.\n\n파이썬은 거의 모든 것을 덮어쓸 수 있습니다. 거의는, 즉 모든 것이 아닌 거의 모든 것 — 예를 들어 in 키워드를 덮어쓰려고 하면 실패할 것입니다(언어의 문법 자체를 수정하려는 의도라면 다르겠지만, 우리는 오늘 이에 대해 언급하지 않을 것입니다). 그러나 이러한 몇 가지 예외를 제외하고는 변수, 함수, 사용자 정의 클래스, 내장 클래스, 클래스의 인스턴스, 클래스의 메서드, 예외, 람다 또는 부분 함수 등 모든 것을 덮어쓸 수 있습니다.\n\n덮어쓰기에 대해 이야기하는 것은 파이썬에서 객체를 교체하거나 재할당하는 것과 관련이 있습니다. 클래스에서 상속된 메서드의 구현을 기술하는 객체지향 프로그래밍 개념인 오버라이딩과는 다른 개념입니다. 더 중요한 것은 덮어쓰기와 확장(예: 클래스에 새로운 메서드 추가), 서브클래스화(객체지향 프로그래밍의 상속 형태) 간의 차이를 이해하는 것입니다.\n\n그럼에도 불구하고 나는 '덮어쓰기'라는 용어를 넓은 의미로 사용합니다. 특정 상황에서는 더 정확한 용어가 특정 형태의 덮어쓰기를 더 잘 설명할 수 있습니다. 오버로딩과 몽키 패칭과 같은 형태의 덮어쓰기를 보다 정확하게 설명하는 것이요. 오버로딩은 다양한 유형의 입력에 대해 작동하도록 함수를 정의하는 것을 말합니다. 몽키 패칭은 실행 시간에 클래스, 함수 또는 모듈의 동적 수정을 참조하며, 원본 객체를 수정하지 않고 호출 가능한 객체의 동작을 변경할 때 자주 사용됩니다. 그러나 이러한 용어들은 모두 덮어쓰기의 특정 사례입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 기사는 당신에게 덮어쓰기 기술을 가르치려는 것이 아닙니다. 오히려 덮어쓰기가 어떻게 작동하는지, 왜 위험할 수 있는지 및 주의해야 할 위험과 결과에 대해 이해하는 데 도움을 주고자 합니다.\n\n우리는 호출 가능한 객체를 덮어쓰는 데 초점을 맞출 것입니다. 이것들이 가장 흥미로운(동시에 가장 까다로운) 사용 사례를 이루기 때문입니다. 그러나 처음에 변수를 덮어쓰는 방법부터 시작할 것이며, 나중에 호출 가능한 객체를 덮어쓰는 방법에 대해 논의할 것입니다. 그 후 실제 예시들을 보여줄 테니 주제를 이해하는 데 도움이 될 것입니다. 그러면 덮어쓰기의 여러 위험과 잠재적 결과에 대해 이동할 것입니다. Python 객체를 덮어쓰기 전에 완전히 안전한지, 그 효과가 실제로 원하는 효과인지 심사숙고해야 한다는 것을 당신에게 납득시키고 싶습니다.\n\n# 덮어쓰기란?\n\n일반적으로, Python에서 덮어쓰기란 이름에 새 객체를 할당하는 것을 의미합니다. 그러니까:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 덮어씌워지기 전: 이름 x는 특정 객체를 저장하는 메모리 주소와 연관되어 있습니다. 파이썬 용어로 말하면, x는 해당 객체를 참조합니다.\n- 덮어씌워진 후: x에 새로운 객체를 할당하면, 그 참조가 새로운 객체가 저장된 다른 메모리 주소를 가리키도록 변경됩니다. 이제 이름 x는 이 새로운 객체를 참조합니다.\n\n이 기본 개념은 Python의 변수 관리와 메모리 처리를 이해하는 데 중요합니다. x에 의해 참조되는 이전 객체가 모든 참조를 잃으면 가비지 수집 기능인 Python의 메모리 해제를 위한 후보가 됩니다.\n\n일상적인 Python 코딩에서 변수 값을 재할당하는 등 덮어쓰기를 마주할 확률이 높습니다. 아래 예시처럼:\n\n```js\n>>> x = 10\n>>> x\n10\n>>> x = 20\n>>> x\n20\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기에 있습니다:\n\n```js\n>>> x = 10\n>>> x\n10\n>>> x = \"하! 나는 x의 유형을 변경했어요!\"\n>>> x\n'하! 나는 x의 유형을 변경했어요!'\n```\n\n본래 문제가 없지만 변수 덮어쓰기는 유형 변경을 포함할 때 조금 미묘해집니다. 위의 두 코드 블록을 비교해 보면, 전자는 유형 변경이 없는 반면 후자는 유형 변경이 있습니다. Python은 동적으로 유형이 지정되는 언어이기 때문에 변수의 유형을 변경하는 것(예: 정수에서 문자열로 다시 할당하는 것)은 오르지 않습니다. 그러나 가독성과 유지보수에 일부 도전을 가져올 수도 있습니다.\n\nPython의 동적 유형 시스템은 변수가 수명 주기의 어느 시점에서든 어떤 유형의 개체를 참조할 수 있도록하는 중요한 수준의 유연성을 제공합니다. 이에 대해 자세히 읽을 수 있는 다음 글이 있으니 참고하세요:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파이썬의 강점 중 하나인 이 유연성은 신속한 개발과 간단한 데이터 흐름을 가능하게 합니다. 그러나 많은 권한이 따르기 때문에 큰 책임도 따라옵니다. 그리고 이것이 파이썬의 동적 환경에도 적용됩니다. 변수 유형을 바꾸는 간편성은 특히 대규모 코드 기반에서 코드의 가독성을 떨어뜨릴 수 있습니다.\n\n이러한 도전에 대처하기 위해 파이썬에서는 예상 유형의 변수, 함수 매개변수 및 반환 값 등을 명시할 수 있게 해주는 타입 힌트를 소개했습니다. 자세한 내용은 여기를 참조해주세요:\n\n타입 힌트는 파이썬의 동적 성격에는 직접적으로 영향을 미치지 않습니다. 대신, 타입 힌트는 정적 유형의 장점에 간접적으로 (그리고 선택적으로) 이점을 제공하는 다리 역할을 합니다. 예전에는 아직 파이썬 환경의 일부가 아니었을 때 이미 다른 타입 힌팅은 많은 파이썬 개발자들이 꿈꿔왔던 것입니다.\n\n한편으로, 파이썬의 동적 타이핑은 변수가 수명 동안 다른 유형의 값들을 보관할 수 있도록 합니다. 다른 한편으로, 타입 힌트의 도입은 예상 유형을 명시하는 방법을 제공하면서 코드의 가독성을 향상시키고 정적 분석 도구를 지원합니다. 예를 들어, 타입 힌트 관점에서 첫 번째 코드 블록에서 x를 덮어쓰는 것은 완전히 올바릅니다. 그러나 두 번째 블록에서는 그렇지 않습니다. 이는 정수를 새 이름 x에 할당할 때 타입 힌트를 넣지 않고 실제로는 x가 정수임을 간접적으로 타입 검사기에 알렸기 때문입니다. 이후에 x를 문자열로 덮어쓰기 때문입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 문제를 피하기 위해 다음을 할 수 있습니다:\n\n```js\n>>> from typing import Union\n>>> x: Union[int, str] = 10\n>>> x\n10\n>>> x = \"하! x의 유형을 변경했지만 여전히 정상입니다!\"\n>>> x\n'하! x의 유형을 변경했지만 여전히 정상입니다!'\n```\n\nx가 정수 또는 문자열일 수 있다고 알려주면, 타입 체커는 이 코드에서 아무 문제가 없다고 볼 것입니다.\n\n잠깐, 뭐라구요?! 왜 타입 힌트에 대해 그렇게 많이 언급하나요? 우리는 파이썬에서 덮어쓰기에 대해 얘기하고 싶지 않았나요? 왜 이걸 하고 있지 않나요?\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그렇습니다. Type hint는 우리를 보호합니다. 모든 의도치 않은 유형의 값으로 변수를 잘못 덮어쓸 경우를 방지해줍니다. 따라서 Python에서 변수를 덮어쓸 때 Type hint는 안전장치 역할을 합니다. 타입 체커가 특정 덮어쓰기에 대해 경고를 보내면, 우리 스스로 좋은 일을 위해 그것이 올바른지 확인하고 의도한 결과가 실제로 달성되는지 확인해야 합니다.\n\n변수를 덮어쓰는 것은 Python에서 가장 간단한 덮어쓰기 형태입니다. 다음 섹션에서는 해당 주제에 대해 더 자세히 살펴보며 콜러블(함수, 클래스, 클래스 메서드)을 덮어쓸 때 발생할 수 있는 리스크에 대해 논의할 것입니다. 이러한 형태의 덮어쓰기는 복잡한 도전 과제를 도입하고 신중한 처리를 하지 않으면 심각한 문제로 이어질 수 있는 가능성이 있습니다.\n\n# 함수, 클래스 및 클래스 메서드 덮어쓰기\n\n다양한 객체 유형을 다루지만 관련 위험요소가 기본적으로 동일하기 때문에 세 가지 덮어쓰기 형태를 함께 설명하기로 결정했습니다. 따라서 가독성을 위해 함수에 대해 설명하겠지만, 모든 내용은 동일하게 클래스, 클래스 메서드 및 기타 콜러블 객체에도 적용됩니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n기존 함수를 덮어쓰는 이유에 대해 궁금할 수 있습니다. 그냥 다르게 구현하면 안 되는 걸까요? 사실, 우리가 다르게 구현할 수 있는 상황도 있습니다. 따라서 덮어쓸 필요가 없는 경우도 있습니다. 그러나 외부 패키지에서 함수(또는 여러 함수)를 덮어써야 하는 상황도 있을 수 있습니다. 그 이유는 다양할 수 있습니다. 조금 다른 동작이 필요하거나 다른 데이터 유형과 호환되어야 하거나 성능을 개선해야 할 수도 있고, 또는 원래 구현에서 버그가 발견되었지만 수정된 공식 릴리스를 기다릴 수 없는 경우일 수도 있습니다.\n\n저는 이러한 상황을 여러 번 경험해왔고, 덮어쓰기가 종종 좋은 해결책이 되었습니다. 패키지의 주요 기능을 제공하는 외부(PyPi에서 가져온) Python 패키지에서 수십 개의 함수와 클래스 메서드를 덮어써야 했던 Python 프로젝트 중 하나가 있습니다. 이는 해당 패키지가 큰 코드베이스를 갖고 있지만 부주의하고 때로는 잘못된 코드가 포함되어 있었지만, 사용해야 했기 때문입니다.\n\n함수를 덮어쓰는 예제를 살펴보겠습니다. Python은 매우 유연하기 때문에 내장 함수를 덮어쓰기가 매우 쉽습니다:\n\n\\[이미지 첨부: \"2024-07-09-OverwritinginPythonTrickyDangerousPowerful_1.png\"\\]\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위에서 sum 함수를 max 함수로 덮어썼습니다. 그러나 더 많은 것을 할 수 있습니다. 아래에서 sum 함수를 문자열로 덮어씁니다!\n\n![이미지](/TIL/assets/img/2024-07-09-OverwritinginPythonTrickyDangerousPowerful_2.png)\n\n파이썬에서 덮어쓰기가 어떻게 작동하는지 이해하려면 파이썬에서 전역 변수가 어떻게 작동하는지 이해하는 것이 중요합니다. 이와 관련한 자세한 내용은 다음 기사에서 확인할 수 있습니다:\n\n간단히 말하면, 한 모듈에서 sum을 덮어쓰면 다른 모듈에 영향을 미치지 않습니다. 따라서 sum은 여기에 덮어씌워지지 않습니다. 이것은 기억해야 할 중요한 사항입니다. 왜냐하면 위에서 보여준대로 sum을 덮어쓰면 두 개의 다른 sum 함수가 만들어지기 때문입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 덮어쓴 합계는 덮어쓰기를 수행한 모듈에서 발생합니다.\n- 프로그램의 모든 다른 모듈(그리고 사실 다른 프로그램들에서의 기본 내장 합계)에는 원래 기본 내장 합계가 있습니다.\n\n객체를 전역으로 덮어쓰려면 내장 모듈을 활용하는 특정 기술이 필요합니다. 그러나 여기서 이 주제를 심도깊게 다루지는 않겠습니다. 더 알아보고 싶다면 (그리고 왜 주의해서 진행해야 하는지 이해하고 싶다면) 위의 기사를 읽어보세요. 거기에서 그 방법을 설명했지만 관련된 위험성도 설명했습니다.\n\n특정 모듈이나 외부 패키지의 모듈(파이썬 표준 라이브러리 모듈 포함)에서 함수를 전역으로 덮어써도 전역으로 덮어씌우지 않고 싶다면 다른 접근 방법이 필요합니다. 이 기술에 대해 아래 기사에서 설명했습니다:\n\n이 글은 파이썬에서 전역 변수와 파이썬 모듈에서 객체를 가져오는 다양한 방법에 대한 두 가지 기사로, 파이썬에서 덮어쓰기가 어떻게 작동하는지 이해하는 데 필요한 지식을 제공합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 섹션에서는 기능을 덮어쓰는 매우 잘 알려진 Python 기법인 'decoration'을 소개합니다.\n\n## Decoration은 덮어쓰기!\n\n하하! 여러분 중 일부에게 충격을 주었을지도 모르겠네요 — 먼저 덮어쓰기를 해킹의 일종으로 논의했는데, 이제 Python의 가장 흥미로운 및 인기 있는 문법 설탕 중 하나인 'decoration'이 덮어쓰기의 한 형태라고 말하고 있습니다!\n\n더 많은 Python decoration에 대해 알고 싶다면, 다음 기사에서 기본 및 고급 정보를 찾을 수 있습니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n장식은 실제로 덮어쓰기의 한 특정 버전입니다: 일반적으로 가져오는 시간에 발생하며 되돌릴 수 없습니다. 다시 말해, 한 번 장식되면 항상 장식되어 있습니다. \"일반적으로\" 라고 했습니다, 왜냐하면 해당 프로세스를 되돌릴 수 있는 기술이 있기 때문입니다; 이와 같은 것을 배우고 장식에 대해 더 알고 싶다면 위의 기사를 참조하세요.\n\n이제 표준 장식의 논리를 분석해 봅시다:\n\n- 원본 함수인 original_func가 있다고 가정합니다.\n- 특정 방식으로 함수의 동작을 변경하려고 하지만 여전히 같은 이름인 original_func를 사용하여 새 버전의 함수를 호출하려면,\n- 함수의 동작을 변경하는 장식자(클래스나 함수일 수 있음)를 생성합니다. 장식자를 사용하여 원본 함수를 장식할 수 있지만 다른 함수도 가능합니다.\n- original_func를 장식하여 그 동작을 변경합니다. 기술적으로, 장식은 원본 함수를 새로운 동작이 있는 함수로 덮어씁니다. 새로운 함수는 일반적으로 장식의 효과로 인해 원본 함수를 호출하지만, 장식된 함수가 그렇게 할 필요는 없습니다.\n- 따라서 original_func를 호출하면 사실 새 함수가 호출됩니다. 이 새 함수는 original_func를 통해서만 접근할 수 있습니다. 함수 이름이 original_func인 함수를 가지고 있더라도 원본 함수에 접근할 수 없습니다.\n\n4번째 단계에서 무엇을 했는지 주목했나요? 다른 것이 아니라 덮어쓰기입니다 — 이것이 장식이 덮어쓰기의 한 형태인 이유입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n함수를 꾸며주는 것은 매우 조심스러워야 한다는 뜻인가요?\n\n정확히 그렇습니다! 함수를 꾸미는 것은 덮어쓴다는 의미이기 때문에 조심해야 합니다. 그럼에도 불구하고, 꾸미기에는 좋은 점이 하나 있습니다. 파이썬을 알고 계시다면 꾸미는 방법을 이미 알고 계셔서, 꾸며진 함수가 동작이 변경되고 원래 함수가 덮어씌워진다는 것을 이미 알고 계실 겁니다.\n\n즉, 꾸미기는 함수를 덮어쓰는 비교적 안전한 방법이라는 뜻입니다. 안전한 이유는 꾸미는 것이 명확하며, 특히 '@' 구문을 사용하여 수행할 때 명확하기 때문입니다. 꾸민다는 것은 개발자가 외치는 것과 같습니다: \"안 봤어요? 이 함수를 덮어씌우고 있어요! 다르게 동작할 거에요!\"\n\n지금 이 방식을 다른 모듈에 숨겨진 한 줄로 함수를 덮어씌우는 방식과 비교해보세요. 꾸미기는 덮어쓰기를 알려주고 있지만, 후자의 방식은 조용히 속삭이는 것과 같습니다: \"쉿... 덮어쓰고 있어요... 이 함수를... 다르게 동작하게 할 거에요...\"\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 섹션에서 중요한 결론이 나오는데요. Python에서 함수, 클래스 및 클래스 메서드 덮어쓰기 기법은 눈에 띄게 할 수도 있고 눈에 띄지 않을 수도 있습니다. 가능한 경우 더 눈에 띄는 방법을 선택해야 합니다. 코드에서 알기 어려운 덮어쓰기 기술을 사용하지 않도록 하세요. 이는 코드의 기능을 혼란스럽게 만들고 이해를 방해할 수 있습니다.\n\n# 예시 1: 프로덕션 코드\n\n이 섹션에서는 덮어쓰기가 중요한 역할을 하는 많은 가능한 상황 중 하나를 분석할 것입니다. 그러나 이는 넓은 주제에 대한 특정 예시일 뿐이므로 모든 가능한 위험 요소를 다루지는 않습니다. 따라서 이 섹션을 예시로 취급하고, 다음 섹션에서 덮어씌기의 위험에 대해 좀 더 일반적으로 논의할 것입니다.\n\n다음 가상이지만 완전히 타당한 사례 연구를 고려해 보겠습니다. 이 시나리오를 읽고 분석하면서 개발자의 역할을 맡아주세요. 실수를 저지른 사람은 아니지만 그 결과물과 씨름해야 하는 사람이 바로 여러분입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n5년 이상 프로젝트에 참여한 수많은 개발자들이 작업한 코드를 이어 받았습니다. 코드 베이스에는 20개의 모듈 중 하나인 큰 모듈이 있고, 이 모듈에는 read_info_from_db라는 중요한 기능이 있습니다. 이 기능은 사용 중인 20개 모듈 중 15개에서 사용되며, 사용되는 프로세스에 중요한 정보를 제공합니다. 그러니까 현재까지는 잘 작동하고 있습니다.\n\n하지만 여기서 모르는 사실이 하나 있습니다. 개발자 중 한 명이 이 함수의 동작을 변경했습니다. 더 심각한 문제는 이 개발자가 모든 모듈이 아닌 7개 모듈에서만 이를 수행했다는 것입니다. 이 개발자는 해당 함수를 또 다른 함수로 덮어쓰는 해킹을 했는데, 이를 통해 이 7개 모듈에서만 다르게 동작했습니다. 게다가, 덮어쓰기는 특정 모듈이 가져올 때의 프로세스 중간에 이루어졌습니다.\n\n결과적으로, 이상한 출력물이 발생했지만 초기에는 조금 이상했을 뿐입니다. 출력물이 너무 조금 변하고 오류가 발생하지 않았기 때문에 심지어 그 변화에 대해 인식하지 못했습니다. 본인의 작업 20주차를 마치고 나서야 변경 사항을 알게 되었습니다.\n\n21주차에 드디어 출력물의 문제를 인식하게 되었습니다. 처음에 데이터에 문제가 있을 수 있다는 것을 알아차렸지만, 이를 찾지 못했습니다. 코드를 디버깅했지만 덮어쓰기를 알지 못했습니다 — 코드 전체를 한 줄씩 디버깅하는 것은 선택지가 아니었고, 적어도 처음에는 가능한 방법이 아니었습니다. 왜냐하면 10만 줄 이상의 코드를 다루는데, 버그를 찾을 위치조차 알 길이 없기 때문입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n결국, 해결되지 않은 디버깅을 3일 더 한 후에 모든 것이 다운되었습니다. E-V-E-R-Y-T-H-I-N-G!\n\n![image](/TIL/assets/img/2024-07-09-OverwritinginPythonTrickyDangerousPowerful_3.png)\n\n모든 유닛 테스트는 통과했는데, 이는 해당 시나리오를 커버하지 않았다는 것을 의미합니다. 해킹은 심지어 설명서에도 언급되지 않았습니다. 그래서 그것을 간과한 것이 당연한 일이었습니다.\n\n따라서 첫 번째 결론은: 덮어쓰기 해킹을 사용할 때는 항상 명확하게 문서화하고, 해당되는 유닛 테스트를 구현하고, 그것들을 철저하게 만드는 것입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n단위 테스트나 해킹에 대한 문서가 없었던 이유는 무엇일까요? 아마도 일시적인 해결책이었거나 코드 리팩토링되지 않은 상태로 남아있었을 수도 있습니다. 혹은 개발자가 회사를 떠나기 전에 작성하지 못한 것일 수도 있습니다. 또는 개발자가 대충 처리했을 수도 있습니다. 그 이유는 중요하지 않습니다 — 결과가 중요합니다. 지금은 애플리케이션 코드와 버그를 찾는 작업에 책임이 있는 건 여러분입니다.\n\n어쨌든, 해킹을 발견하기 위해 하루 종일 디버깅에 시간을 들였습니다. 일곱 개의 모듈에서 사용할 다른 기능으로 원래 함수를 덮어씌우는 것이 이 해킹이었습니다. 결과적으로 같은 이름을 가진 두 개의 다른 함수가 되었는데, 한 함수는 여덟 개 모듈에서 호출되고 다른 하나는 일곱 개 모듈에서 호출되었습니다. 처음에는 해킹된 함수가 잘 작동했지만, 어느 순간 데이터가 변경되면서 해킹된 함수가 무의미한 데이터를 반환하기 시작했습니다.\n\n이와 같은 상황은 완전한 재앙을 초래할 수 있으므로 코드 설계 측면에서 심각한 문제입니다. 이는 해킹을 절대 적용해서는 안 된다는 것을 의미하는 것이 아니라, 오히려 조심성을 가지고 적용하고 문서화하며 테스트하며 가급적 빨리 리팩토링해야 한다는 것을 의미합니다(최적의 해결책을 나타내는 경우를 제외하고). 더구나, 해킹을 문서화하지 않는 것은 위험합니다.\n\n이 예에서 덮어쓰기는 해킹이었습니다. 그러나 항상 그런 것은 아닙니다. 종종 이는 의도적인 결정일 수 있습니다. Python은 다양한 상황에서 다양한 개체를 덮어쓸 수 있도록 허용하기 때문에 이 기법을 사용하는 데 주저하지 마세요. 그러나 이를 할 때 항상 주의해야 합니다. 결과 코드가 불분명해질 위험이 있다면, 이를 문서화하고 이 특정 객체를 덮어쓰기로 선택한 이유를 설명하세요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 주요 위험과 결과\n\n안녕하세요! 이 기사의 본질로 넘어갈 때입니다: Python에서 객체를 덮어쓰는 것, 특히 함수, 클래스 메소드 또는 전체 클래스를 덮어쓸 때 발생할 수 있는 위험과 가능한 결과에 대해 이야기하려고 합니다.\n\n하지만 기억해 주세요, 객체를 덮어쓰는 것은 위험할 수 있지만, 이것은 일반적인 코딩 기술입니다. 따라서 이것을 모든 방법으로 피하는 것이 아니라 올바르게 사용하는 것이 중요합니다. 더 나은 해결책을 찾을 수 있다면 사용하세요 — 이는 모든 코딩 기술에 대해 말할 수 있는 것입니다. 따라서 덮어쓰기를 두려워하지 마세요, 그러나 코드를 개선하는 방향으로 신중하게 사용하세요. 이는 코드를 불분명하게 하거나 취약하게 만드는 것보다 더 나은 방법입니다.\n\n아래에서 덮어쓰기의 가능한 위험 목록을 찾을 수 있습니다. 이 목록이 완전한 것은 아니지만, 가장 중요한 위험을 다루고 있다고 생각합니다. 객체를 덮어쓸 때 이러한 위험들을 인식하는 것이 좋습니다 — 특히 덮어쓰기가 복잡하거나 비표준적이거나 불분명할 때입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 1. 예상치 못한 동작\n\n이것은 아마도 가장 빈번하고 명백하며 눈에 띄는 문제일 것입니다. 덮어씌우기는 프로그램의 예상 기능을 런타임에서 변경함으로써 부작용, 예측할 수 없는 동작 및 결과를 초래할 수 있습니다.\n\n더욱이, 이러한 덮어씌우기는 덮어쓴 함수에 직간접적으로 의존하는 다른 객체들에도 영향을 줄 수 있어서 코드와 애플리케이션의 복잡성과 기능성이 증가할 수 있습니다.\n\n## 2. 유지보수\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n코드의 복잡도를 줄이는 것은 유지 보수 중에 덮어쓰기가 어려운 문제를 일으킬 수 있습니다. 여기서 명확한 문서화가 도움이 될 수 있습니다: 덮어쓰기의 이유, 메커니즘 및 가능한 위험을 명확히 설명해야 합니다. 문서는 또한 덮어쓰기를 리팩토링할 수 있는지 분석해야 합니다.\n\n## 3. 호환성\n\n덮어쓰기가 현재 환경에서 완벽하게 작동하더라도, 외부 라이브러리의 나중 버전이나 파이썬 자체에서는 비슷하게 작동할 것을 보장할 수 없습니다. 이러한 업데이트는 원래 함수의 동작이나 함수 간 상호작용의 변경으로 인해 덮어쓰기에 의해 도입된 새로운 동작에 영향을 줄 수 있습니다.\n\n따라서 이러한 변경은 업데이트 후 진단하기 어려운 오류로 이어질 수 있습니다. 덮어씌운 기능에 대한 좋은 단위 및 통합 테스트가 도움이 될 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 4. 보안\n\n적절한 보안 조치가 누락된 중요한 메서드나 함수를 덮어쓰면 덮어쓴 버전이 원본과 동일한 보안 관행을 준수하지 않는 경우에 보안 취약점이 발생할 수 있습니다. 함수를 덮어쓰는 경우, 항상 해당 보안 수준을 분석하고 내 버전에 반영하려고 노력하세요. 심지어 개선할 수도 있을지도 모르죠? 실제로, 보안을 강화하기 위해 일부 덮어쓰기가 추가 보안 조치를 구현하는 것을 목표로 합니다.\n\n작업 중인 코드에서 발견한 덮어쓰기를 분석할 때에는 항상 보안에 특별히 주의를 기울이고, 덮어쓴 버전이 충분히 안전한지 확인하세요.\n\n## 5. 성능\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n많은 표준 라이브러리 모듈과 외부 패키지에는 C로 작성된 매우 최적화된 구현이 포함되어 있어, 사용자 정의 Python 코드로 유사한 성능을 달성하기가 어렵거나 불가능할 수도 있습니다. 이러한 최적화가 너무 우수하여, C 확장으로 비슷한 성능을 달성하는 것조차 어려울 뿐만 아니라 향상시키기도 어려울 수 있습니다. 성능이 중요할 때는 이러한 기능을 덮어쓰기 전에 고려해 보세요.\n\n가끔은 단순한 벤치마크가 덮어쓰기가 비효율적이지 않은지 결정하는 데 충분할 수 있습니다. 응용 프로그램에 덮어쓴 함수나 클래스를 유지하기로 선택한 경우, 성능 테스트를 진행하는 것이 좋습니다. 이러한 경우에는 perftester 패키지가 유용한 도구일 수 있습니다. 이 패키지는 실행 시간 및 메모리 사용량 측면에서 벤치마킹 및 성능 테스트를 위한 도구를 제공합니다. 해당 리포지토리의 패키지 설명서를 읽어보세요.\n\n아래 기사는 해당 패키지를 사용한 시간 기반 벤치마킹에 대해 다룹니다:\n\n물론 성능이 중요하지 않다면, 벤치마킹에 미친 듯이 집착할 필요는 없습니다. 그렇다고 완전히 무시해선 안 됩니다. 이러한 경우에도 특정 함수나 클래스를 덮어써서 코드를 천 배 느리게 만들지 않았는지 확인하세요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 6. 의존성 오해\n\n대규모 프로젝트에서는 의존성을 관리하는 것이 어려울 수 있습니다. 복잡한 환경에서 상호 연결된 의존성을 다루는 것은 이 어려움을 더욱 증가시킬 수도 있습니다. 가끔은 함수나 클래스를 덮어쓰면 이러한 의존성이나 환경 자체가 변경될 수 있습니다. 이는 덮어쓰기를 위해 새로운 의존성을 도입하거나 새로운 함수/클래스가 원본과 다른 import를 필요로 할 때 발생할 수 있습니다.\n\n이러한 변경 사항이 제대로 문서화되지 않고 미래 개발 팀에서 명확히 이해하지 못한다면, 덮어쓴 함수/클래스가 있는 애플리케이션이 원본 함수가 있는 애플리케이션이 아닌 다른 환경에서 실행될 때 문제가 발생할 수 있습니다. 이러한 상황은 복잡성을 증가시킬 수 있습니다.\n\n이 추가된 복잡성이 반드시 문제가 되지는 않지만, 혼동과 오해로 이어질 수 있습니다. 따라서, 덮어쓰기로 인해 애플리케이션에서 발생하는 환경 변경 사항을 문서화하는 것을 기억해 주세요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 7. 디자인 파괴하기\n\n코드와 응용 프로그램의 디자인은 코드 품질을 보장하는 데 중요한 역할을 합니다. 기술적으로는 불량 및 잘 디자인된 응용 프로그램에서 동일한 기능을 달성하는 것이 가능하지만, 나쁜 디자인은 코드베이스의 가독성을 현저히 감소시키고 복잡성을 증가시키며 취약점을 도입할 수 있습니다. 결과적으로 항상 코드와 응용 프로그램 디자인의 명확성을 추구해야 합니다.\n\n모든 코드 디자인의 중요한 측면은 추상화 계층입니다. 덮어쓰기는 클래스 또는 모듈의 기본 구조를 망치는 일이 될 수 있습니다. 예를 들어, 개인용으로 설계된 클래스 속성(메소드 포함)을 변경하거나 또는 원래 개인적인 속성을 공개적으로 만드는 것을 포함할 수 있습니다. 개발자가 속성을 개인으로 설정할 때 그 뒤에 일반적으로 이유가 있습니다. 일반적으로 사용자에 의해 직접 액세스되지 않도록 의도합니다.\n\n클래스의 개인 속성을 덮어쓰면 원래 개발자가 방지하려고 했던 것을 정확히 하는 것입니다. 때로는 원래 개발자가 계획하지 않은 기능을 달성하기 위해 필요할 수 있지만, 그럼에도 불구하고 이러한 조치는 객체 지향 프로그래밍(OOP)의 기본 원칙에 도전할 수 있어서 불안정한 코드로 이어질 수 있습니다. OOP 원칙을 훼손한다고 생각하는 사람들도 있는데, 이는 강한 표현이지만 무리가 없는 발언입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n따라서, 속성을 덮어쓰는 것은 OOP의 근본적인 원칙을 위반한다고 생각될 수 있다는 것을 인식하는 것이 중요합니다. 가끔은 속성 하나 대신 클래스 전체를 덮어쓰는 것이 더 나아 보일 수도 있습니다. 그러나 OOP 순수주의자들은 여전히 이를 OOP의 핵심 원칙에 위배된다고 간주할 것입니다.\n\n이 토론에서 저는 절대적인 권장 사항을 제공하는 대신 인식을 높이려고 합니다. 특히 다른 사람이 사용할 수 있도록 설계된 프레임워크나 보통의 Python 코드를 작업할 때 이와 같은 점을 기억해 주시기를 바랍니다.\n\n## 8. 테스트 중의 어려움\n\n이전에 언급했듯이, 덮어쓴 기능에 대한 새로운 단위 및 통합 테스트를 구현하는 것은 효과적이며 종종 필수적인 안전장치입니다. 그러나 기존 기능의 동작을 변경하면 기존 테스트에 영향을 미칠 것이라는 점을 기억하는 것이 중요합니다. 최소한 일부 기존 동작을 고려한 테스트 중 몇 개는 실패해야 합니다. 그리고 그것은 놀랄 일이 아니어야 합니다. 왜냐하면 우리는 다른 동작을 얻기 위해 기능을 덮어썼기 때문입니다. 사실, 이러한 중요한 변경사항 이후에 모든 원래 테스트가 여전히 통과한다면, 원래 테스트가 충분히 설계되지 않았을 수도 있다는 것을 나타낼 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n따라서 함수, 클래스 메소드 또는 전체 클래스를 덮어쓸 때는 새로운 테스트를 구현하는 것만큼 원래 테스트를 다시 평가하는 것이 중요합니다. 이를 다양한 방법으로 할 수 있지만, 실패한 테스트를 표시하는 것을 권장합니다. 예를 들어, 아래 Pytest의 foo() 함수 테스트에서 다음을 수행할 수 있습니다:\n\n```js\n@pytest.mark.xfail(reason=\"foo() 덮어쓰기로 인한 실패\")\ndef test_foo_blahblah():\n    ...\n```\n\n또는, 테스트를 건너뛰도록 선택할 수 있습니다:\n\n```js\n@pytest.mark.skip(reason=\"foo() 덮어쓰기로 인한 실패\")\ndef test_foo_blahblah():\n    ...\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n보통 나는 전자의 방식을 선호해요. 왜냐하면 실제로 무언가를 수행하기 때문이죠. 테스트를 건너뛰기만 하는 것이 아니에요. 덮어쓴 기능 때문에 실패할 것으로 예상된 테스트를 표시하는 것은 테스트 자체에 대한 통찰력을 제공해줘요. 만약 원래의 foo() 함수나 새로운 (덮어쓴) 버전 중 하나를 수정한 후에 테스트가 더 이상 실패하지 않으면, 이는 더 깊은 분석이 필요하다는 신호예요. 왜 이전에 실패해야 했는데 더 이상 실패하지 않는 테스트가 있을까요? 이런 미묘한 차이는 단순히 새로운 기능 때문에 테스트를 건너뛰면 놓칠 수 있어요.\n\n이로 인해 테스트 스위트의 복잡성과 전체 코드 베이스의 방식이 증가한다는 것에 유의하세요. 여러 함수, 클래스 및/또는 클래스 메서드를 덮어쓰는 경우를 상상해보세요. 덮어씌운 부분 자체가 그리 복잡하지 않았더라도 테스트 스위트는 훨씬 더 복잡해질 수 있어요. 이것은 코드를 다른 관점에서 바라봐야 한다는 것을 보여줍니다.\n\n따라서, 만약 덮어쓰기를 코드에 그대로 둘 것으로 결정한다면, 해당 테스트를 리팩토링하는 것을 고려해야 해요. 경우에 따라서는 해당 테스트를 건너뛰고 새로운 테스트를 구현하는 것이 나을 수도 있어요. 아니면 이전의 테스트를 완전히 제거하는 것이 좋을지도 모르겠어요 — 덮어쓰기가 일시적인 해결책일 땐 하지 말아야 할 일이죠?\n\n## 9. 디버깅의 어려움\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n앱을 디버깅할 때 덮어씌운 함수, 클래스 및/또는 메서드가 있는 경우 코드의 복잡성 때문에 문제 해결이 더 어려울 수 있습니다. 특히 덮어쓴 함수 또는 메서드 내에 오류가 있는 경우에는 그렇습니다. 덮어쓰기가 잘 문서화되지 않은 경우 특히 더 그럴 수 있습니다.\n\n디버깅을 단순화하는 한 가지 해결책은 정보를 제공하는 사용자 정의 예외 클래스를 정의하는 것일 수 있습니다. 예를 들어, foomodule 모듈의 foo() 함수를 덮어써야 할 필요가 있다면 상상해보십시오. 해당 함수는 세 개의 인수 x, y, z를 가져옵니다. (프로토타입 단계이므로 유형 힌트를 건너 뛸 수 있습니다.) 이것이 메인 진입점에서 함수를 덮어쓰는 방법입니다:\n\n```js\n# __main__.py\nimport foomodule\n\ndef foo_overwritten(x, y, z):\n    ...\n\nif __name__ == \"__main__\":\n    foomodule.foo = foomodule.foo_overwritten\n    foomodule.foo(1, 2, 3) # calls foo_overwritten(1, 2, 3)\n```\n\n다음과 같이 할 수 있습니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# __main__.py\nimport foomodule\n\nclass OverwritingError(Exception):\n    ...\n\ndef foo_overwritten(x, y, z):\n    try:\n        ...\n    except Exception as e:\n        raise OverwritingError(\n            f\"Overwritten된 foo() 함수에서 오류 발생\"\n        ) from e\n\nif __name__ == \"__main__\":\n    foomodule.foo = foomodule.foo_overwritten\n    foomodule.foo(1, 2, 3) # foo_overwritten(1, 2, 3) 호출\n```\n\n만약 원래의 foo() 함수가 예외를 일으키면 일반적인 방식으로 예외가 발생합니다. 그러나 Overwriting된 함수가 예외를 일으키면, OverwritingError가 원래의 예외에서 발생합니다. 따라서 Overwriting된 함수에서 발생한 오류를 즉시 확인할 수 있으며, 예외 메시지를 확인할 수 있습니다.\n\n예외 발생에 대한 일반적인 시나리오입니다. 위 예제에서 모든 foo() 호출은 Overwriting된 버전을 호출하는 것을 의미하지만, 이와 같이 원본과 Overwriting된 버전을 모두 사용하려는 경우가 있습니다. 그렇다면 이 두 버전에서 발생한 예외를 구별할 수 있습니다. 이는 프로세스 중간에 foo() 함수를 덮어쓰는 경우에도 작동합니다:\n\n```js\n# __main__.py\nimport foomodule\n\nclass OverwritingError(Exception):\n    ...\n\ndef foo_overwritten(x, y, z):\n    try:\n        ...\n    except Exception as e:\n        raise OverwritingError(\n            f\"Overwritten된 foo() 함수에서 오류 발생\"\n        ) from e\n\nif __name__ == \"__main__\":\n    foomodule.foo(1, 2, 3) # FLAG 1: foo(1, 2, 3) 호출\n    foomodule.foo = foomodule.foo_overwritten\n    foomodule.foo(1, 2, 3) # FLAG 2: foo_overwritten(1, 2, 3) 호출\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 FLAG 1로 표시된 줄을 실행하는 동안 예외가 발생하면, foomodule.foo()에서의 원시 예외가 발생합니다. 그러나 FLAG 2 줄을 실행하는 동안 예외가 발생하면, foomodule.foo()에서는 OverwritingError 및 foo_overwritten() 함수에서 발생한 실제 예외가 발생합니다.\n\n# 개발 도구로서의 덮어쓰기\n\n지금까지 우리는 덮어쓰기를 주로 생산 솔루션으로 논의해왔습니다. 일시적이든 영구적이든 상관없이요. 또한, 논의한 리스크는 이 시나리오를 의미했습니다.\n\n이 섹션에서는 다른 시나리오로서의 덮어쓰기 사용에 대해 이야기하고 싶습니다. 보통 이러한 경우에는 그 정도 리스크를 안고있지 않고, 때로는 전혀 리스크가 없을 수도 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 상황을 상상해보세요. 테스트 파일에서 collections.Counter 클래스를 사용하여 두 리스트를 비교하는 데 사용될 예정인 30개 이상의 어설션을 구현했습니다. 예를 들어 여기에서와 같이요:\n\n```js\n>>> from collections import Counter\n>>> list_1 = [1, 2, 3, 4]\n>>> list_2 = [1, 2, 4, 3]\n>>> list_3 = [1, 2, 4, 5]\n>>> list_1 == list_2\nFalse\n>>> Counter(list_1) == Counter(list_2)\nTrue\n>>> list_1 == list_3\nFalse\n>>> Counter(list_1) == Counter(list_3)\nFalse\n>>> list_2 == list_3\nFalse\n>>> Counter(list_2) == Counter(list_3)\nFalse\n```\n\n(이 예제에서 사용되는 것보다 더 많은 기능을 제공하는 collections.Counter 클래스가 있습니다. 즉, 두 리스트의 요소를 비교하는 것 등이 가능합니다.)\n\nCounter를 적용한 Counter 인스턴스를 비교하는 것은 요소를 비교하고 순서는 무시한다는 것을 보실 수 있습니다. 따라서 list_1과 list_2가 동일한 요소를 가지고 있더라도 요소의 순서가 다르기 때문에 서로 다르다는 것이죠. 그러나 이들 리스트에 Counter를 적용한 후에 비교하는 경우, 비교 결과는 True를 반환합니다. list_3는 이들 중 양쪽과 다른 요소를 가지고 있기 때문에, list_1 및 list_2로부터 Counter를 적용한 비교에서 실패합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 특정 시점에 다른 테스트 로직을 확인해보기로 생각했습니다. Counter 클래스를 사용하여 리스트를 비교하는 대신 전통적인 방식으로 비교하고 싶습니다:\n\n```js\n>>> list_1 == list_2\nFalse\n>>> list_1 == list_3\nFalse\n```\n\n위에서 언급한대로 Counter 클래스를 사용하는 30개 이상의 어설션을 가지고 있습니다. 이와 관련된 모든 코드 줄을 수동으로 변경하지 않고 이러한 비교 방법이 어떻게 작동하는지 확인하려면 어떻게 해야 할까요?\n\n하나씩 확인할 수 있습니다. 한편으로, 이는 각 어설션을 개별적으로 확인하기 때문에 좋은 방법일 수 있습니다. 그러나 반대로 이것은 상당히 시간 소요가 될 수 있습니다, 특히 새로운 어설션이 모두 통과하는 경우가 발생할 때. 그렇다면 빠르게 이 작업을 수행할 방법이 있는가요?\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n네, 있습니다. 사실 두 가지 해결책을 생각해 냈습니다. 둘 중 하나는 다른 것보다 나은 방법입니다.\n\n첫 번째 해결책은 조금 거칠어요. 편집기나 IDE에서 Counter를 빈 문자열로 모두 바꿔주면 됩니다 (즉, Counter(list_1)에서 (list_1)으로 바뀝니다). (다만 이 방법은 호출할 때 추가 인수가 필요한 클래스/함수에 사용할 수 없습니다.) 이 방법으로 변경한 버전에서 다시 Counter로 되돌아가고 싶다면 작업을 다시 해야 하는 번거로움이 있습니다. 따라서 동일한 세션에서 작업해야 하며, 대체 모두 도구를 사용한 후에 추가 작업을 수행해서는 안됩니다. 그렇게 되면 모두 다시 해야 하게 됩니다.\n\n솔직히 말해서 이 해결책은 크게 좋아하는 편이 아닙니다. 다소 기계적인 방법이기 때문입니다. 텍스트 편집기/IDE를 사용하여 코드를 변경하게 되는데, 이는 위험성이 따릅니다. 이러한 변경으로 예상치 못한 변화가 발생할 수 있습니다. 예를 들어, 'encounter'라는 함수를 구현하거나 이 이름을 사용하는 변수가 있는 경우, 'encounter'가 'en'으로 변경될 수 있습니다. 따라서 대체 도구를 사용할 때 주의해야 합니다.\n\n대신 덮어쓰기를 사용할 수 있습니다. 이 특정 상황에서는 실제로 매우 간단합니다. Counter(list_1)을 list_1이나 일반적으로 Counter(obj)를 obj와 같은 의미로 만들고 싶은 경우, Counter를 동일한 함수로 덮어씌우면 됩니다. 동일한 함수는 객체(예: obj)를 받아서 변경하지 않은 채로 반환하는 함수입니다. 이를 정의하는 것은 매우 간단합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n>>> def identity(obj): return obj\n```\n\n그러나 identity 함수를 정의할 필요는 없고 collections.Counter 클래스를 덮어쓰기 해야 합니다. 따라서 덮어쓰기를 사용할 테스트 모듈의 imports 블록 바로 뒤에 다음을 수행하는 것이 충분합니다:\n\n```js\n... # imports\nfrom collections import Counter\n... # imports\n\nCounter = lambda obj: obj\n```\n\n당연히 일반적인 def 정의를 사용할 수도 있습니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n... # 가져오기\nfrom collections import Counter\n... # 가져오기\n\ndef Counter(obj): return obj\n```\n\n위와 같이 작성하셨습니다! Counter의 유형이 변경됩니다: 더 이상 클래스가 아니라 함수가 됩니다. 우리의 특정 상황에서는 문제가 되지 않지만, Counter는 호출 가능한 클래스이며, 우리의 코드에서 추가 인수 없이 호출합니다 (즉, Counter(list_1)와 같이 사용)하고 클래스의 다른 메서드를 사용하지 않습니다. 다른 메서드를 사용했다면 더 복잡한 monkey patching을 사용해야 했을 것입니다.\n\n여기까지입니다! 이 매우 간단한 덮어쓰기는 Counter가 작동하는 방식을 변경합니다:\n\n```js\n>>> list_1 == list_2\nFalse\n>>> Counter(list_1) == Counter(list_2)\nTrue\n>>> Counter = lambda obj: obj\n>>> list_1 == list_2\nFalse\n>>> Counter(list_1) == Counter(list_2)\nFalse\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n물론, 이것은 항상 출력을 변경한다는 것을 의미하지는 않아요:\n\n```js\n>>> list_4 = [1, 2, 2, 5]\n>>> list_5 = [1, 2, 2, 5]\n>>> list_4 == list_5\nTrue\n>>> Counter(list_4) == Counter(list_5)\nTrue\n>>> Counter = lambda obj: obj\n>>> list_1 == list_2\nTrue\n>>> Counter(list_1) == Counter(list_2)\nTrue\n```\n\n덮어쓰기 기교를 완료하면, Counter의 모든 인스턴스를 제거하거나 원래 코드로 돌아가야 해요. 후자를 위해, Counter의 정의를 아이덴티티 함수로 조작하는 코드 한 줄만 제거하면 됩니다.\n\n이것은 개발 기술에 불과하다는 것을 기억하세요. 얼마나 유혹적인지에 관계없이 실제 코드에서 사용해서는 안 됩니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이름이 지정된 람다 정의를 사용한 것을 알아 보셨나요? 이것은 제품 코드에서 하지 말아야 할 것이지만, 임시 개발 기술로 이름이 지정된 람다 함수를 사용하는 데는 아무런 문제가 없다고 생각해요. 마찬가지로 임시 데이터 분석 코드에서 사용하는 것이 잘못된 일이라고 보지 않아요.\n\n이런 경우에는 결과에 너무 걱정하실 필요가 없지만, 예외 사항이 있어요. 예를 들어 코드가 제품용 데이터베이스와 통신하는 경우라면, 제품 코드를 작성하거나 개발 목적의 일회성 임시 속임수를 사용하더라도 항상 매우 주의해야 해요.\n\n# 결론\n\n덮어쓰기가 종종 해킹으로 여겨지기도 하지만 항상 그런 것은 아니에요. 개발자의 도구 세트에서 표준적이고 귀중한 도구가 될 수 있어요. 그러나 단순 변수 외의 복잡한 객체에 덮어쓰기를 사용하는 경우에는 기본적인 조건을 기억해야 해요. 개발 목적의 일시적인 해결책이 아닌 경우, 덮어쓰기의 각 인스턴스는 충분히 문서화되고 명확하고 포괄적인 테스트로 처리되어야 해요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n새로운 callable 객체를 덮어쓰는 아이디어가 떠오를 때, 저는 원본 구현을 이해하기 위해 노력합니다. 이를 이해하지 않으면 덮어쓰기가 무엇을 하는지, 그리고 왜 원본 버전과는 다르게 동작하는지 이해할 수 없을 것입니다.\n\n맥락과 원본 함수를 이해한 후, 덮어쓰기의 목적과 덮어쓰기가 정말 가장 좋은 방법인지 파악하려고 합니다. 함수를 다시 정의하거나 메서드를 서브클래싱하는 것으로 동일한 결과를 얻을 수 있을지 생각해 봅니다. 또는 callable 인스턴스를 가진 클래스에 메서드를 추가하는 등의 방식으로 기능을 확장할 수 있을지도 모릅니다.\n\n아직도 덮어쓰기가 최선의 해결책으로 보인다면, 이에 따른 위험과 결과를 고려합니다. 이는 심각한 사고 과정처럼 보일 수도 있지만, 사실 그렇습니다. 덮어쓰기의 장단점을 따져 봐야 합니다. 장점이 단점을 상회하고 위험이 심하지 않다고 판단되면 사용하기로 결정합니다. 상황이 명확하지 않을 때도... 결정은 필요합니다. 혼자 작업하는 경우에는 본능에 귀를 기울이세요. 팀 프로젝트인 경우, 덮어쓰기가 중요한 변화처럼 보일 때는 팀원들과 상의하는 것이 항상 좋은 생각입니다.\n\n이 글을 계획할 때, 상당히 간단할 것으로 예상했습니다. 덮어쓰기의 위험에 대해 얼마나 많은 얘기를 할 수 있겠는가? 그러나 주제에 더 깊이 파고들수록 그 안에 복잡한 부분들을 보게 되었습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 코딩 기법으로 덮어쓰기를 주의 깊게 살펴보면, 첫눈에 보이는 것보다 더 위험할 수 있다는 것을 알 수 있죠? 그래서 이 글의 주요 목적은 파이썬에서 객체를 덮어쓰고 싶다면 신중히 생각해야 한다는 것을 설득하는 것이었습니다. 만약 그렇게 하기로 결정한다면, 덮어쓰기를 주의 깊게 실행하고, 테스트 스위트의 해당 부분을 재설계하고 확장하며, 덮어쓰기의 이유를 문서화하여 설명하는 것이 중요합니다.\n\n일시적 개발 기법으로 덮어쓰기를 사용하는 것을 넘어서 조심해야 할 사항이 몇 가지 있을 수 있습니다. 예를 들어, 잘 알려진 데코레이터를 표준 사용 사례로 사용하는 경우, 그다지 신중하지 않아도 될 수도 있습니다. 이 규칙은 모든 데코레이터에 대한 보편적인 것이 아니지만, 널리 사용되는 것들에 해당합니다. 사용자가 코드가 무슨 일이 일어나고 있는지 이해하지 못하게 만드는 것을 피하기 위해 사용자 정의 데코레이터는 투명성과 명확성을 요구합니다. 여기서 \"경솔한 것 보다는 안전한 것이 좋다\" 원칙이 적용됩니다: 데코레이터를 설명하는 한 두 문장을 더 쓰는 것이 사용자가 무슨 일이 일어나고 있는지 이해하지 못할 위험을 감수하는 것보다 낫습니다.\n\n저는 파이썬에서 객체를 덮어쓰지 말 것을 설득하려고 한 것이 아닙니다. 그 반대로, 저는 덮어쓰기를 굉장히 강력한 파이썬 프로그래밍 도구로 보지만 동시에 도전적이고 책임 있는 도구로도 보고 있습니다. 강력한 도구는 종종 부작용을 일으킬 수 있으며, 덮어쓰기도 그러한 부작용을 가질 수 있습니다. 그래서 제 조언은 다음과 같습니다: 덮어쓰기를 두려워하지 마세요, 하지만 사용할 때 조심하세요. 먼저 생각하고, 그런 다음 덮어씁니다.\n","ogImage":{"url":"/assets/img/2024-07-09-OverwritinginPythonTrickyDangerousPowerful_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-OverwritinginPythonTrickyDangerousPowerful_0.png","tag":["Tech"],"readingTime":34},{"title":"Python 코드 가독성을 높이는 어노테이션 사용법","description":"","date":"2024-07-09 19:05","slug":"2024-07-09-EnhancingReadabilityofPythonCodeviaAnnotations","content":"\n## 파이썬 프로그래밍\n\n![Python Image](/TIL/assets/img/2024-07-09-EnhancingReadabilityofPythonCodeviaAnnotations_0.png)\n\n코드의 명확성은 덕목이자 필수불가결한 것입니다. 코드를 명확하고 가독성 있게 작성한다면, 다른 개발자가 이해할 수 있고, 사용자들도 어떻게 사용해야 하는지 이해할 수 있으며, 미래의 여러분도 시간이 흐르면서 구현한 코드의 세부사항을 대부분 잊어버릴텐데, 그때에도 그 코드를 감사히 여기게 될 것입니다. 프로젝트와 코드베이스의 규모가 커질수록 코드의 명확성은 더욱 중요해집니다.\n\n프로그래밍 언어 중에서 파이썬은 매우 가독성이 좋은 코드를 제공합니다. 아니, 오히려 매우 가독성이 좋은 코드를 제공할 수 있는데, 이를 가독성 좋은 코드로 만드는 방법을 알아야 합니다. 저는 파이썬이 매우 인기를 얻은 이유 중 하나가 코드의 가독성 때문이라고도 말씀드릴 수 있습니다. 그래서 우리는 좋은 파이썬 코드를 작성하는 책임이 있습니다. 이를 위해 우리는 도구가 필요합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파이썬 코드 품질을 향상시키는 도구가 많이 있어요. 먼저, 좋은 파이썬 코드의 표준을 충족시키는 코드를 작성해야 해요. 이러한 표준은 PEP 8에서 제공돼요.\n\n많은 내용을 학습하고 수많은 규칙이 있지만 걱정하지 마세요: 하나씩 차근차근 배우다 보면 언젠가는 대부분의 규칙을 따르게 될 거예요. 얼마 지나지 않아 PEP 8을 다시 참고할 필요 없이 제시된 표준을 사용할 수 있을 거예요. 좋은, 관습적인 파이썬 코드를 작성하는 방법을 자연스럽게 습득하게 될 거예요.\n\n코드 가독성을 높이는 스타일 가이드만 있는 게 아니에요. 오늘은 다른 도구, 즉 코드 어노테이션에 대해 이야기해보려고 해요. 개발 중인 코드의 가독성을 향상시키는 도구임을 기억하세요. 어노테이션은 대문자로 작성된 구문으로, 코드 개발자나 유지 관리자, 덜 자주이지만 사용자에게 주의를 기울일 필요가 있음을 알려주는 표현이에요.\n\n가장 흔한 예로는 TODO, NOTE, FIXME, BUG 및 REVIEW가 있어요. 더 많은 어노테이션이 있고, 필요하다면 사용자 정의 어노테이션도 만들 수 있어요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n간략히 말하자면, 코드 주석은 단순한 코멘트 이상입니다. 이들은 코드의 주목이나 개선을 필요로 하는 부분을 강조하는 표준화된 방법입니다.\n\nVisual Studio Code (VSC)와 같은 고급 통합 개발 환경(IDE)에서 작업할 때, 주석은 코딩을 크게 향상시킬 수 있습니다. 이것들은 코드 실행 방식을 변경하는 것이 아니라 코드와 상호 작용하는 방식을 변경해서 개발 과정을 원활하게 돕습니다.\n\n저는 VSC 사용자입니다. 만약 당신도 VSC를 사용한다면, TODO Highlight 확장 프로그램(현재 TODO Highlight v2도 사용 가능)을 설치하여 주석을 강조할 수 있습니다. 이를 통해 주석을 놓치기 어려울 정도로 강조해줍니다. 이 글에서는 조금 후에 이 확장 프로그램을 사용하는 방법에 대해 논의할 것입니다. VSC를 사용하지 않는다면, 당신이 사용하는 IDE나 편집기가 주석 강조 기능을 제공하는지 확인해보세요. 그렇지 않더라도 주석을 사용할 수 있습니다. 강조 기능 없이는 약간 덜 눈에 띌 수 있겠지만, 그럼에도 불구하고 코드 품질 및 팀 간 소통을 개선하는 강력한 도구로 남아 있을 것입니다.\n\n이 글은 Python 개발에서 코드 주석의 유용성을 탐구합니다. 또한 Visual Studio Code에서의 주석 강조 기능이 어떻게 작동하는지 보여드리겠습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 주석\n\n파이썬에서 \"주석(Annotation)\"과 \"주석 처리(Annotate)\"라는 용어는 두 가지 다른 의미를 가질 수 있습니다. 첫째로, 파이썬 함수에 주석 처리하는 것은 주로 해당 함수에 타입 힌트(Type hints)를 추가하는 것을 의미합니다. 따라서 함수의 주석은 타입 힌트를 추가한 시그니처로 구성됩니다.\n\n본 문서에서는 다른 의미, 즉 코드에 대한 중요한 측면을 가리키는 대문자로 된 단어를 추가하여 코드에 주석을 다는 것에 대해 논의하고 있습니다.\n\n이 부분이 혼란스러울 수 있습니다. 예를 들어, \"foo() 함수에 주석 처리를 추가해주세요.\" 라는 문장은 두 가지 의미를 가질 수 있습니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- foo() 함수에 타입 힌트를 추가해주세요. 이 문장의 전형적인 의미입니다.\n- foo() 함수에 주석을 추가해주세요. 혼동을 줄일 수 있으므로, “foo() 함수의 독스트링이나 코드에 이런-저런 주석을 추가해주세요”와 같이 다른 표현을 사용하는 것이 좋습니다.\n\n따라서 항상 \"annotation(주석)\"과 \"annotate(주석을 추가하다)\"이라는 단어를 사용하여 의미를 명확히 해주세요.\n\n## 주석의 종류\n\n저는 두 종류의 주석을 사용합니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 프로그래밍에서 일반적으로 사용되는 주석들; 이것들을 훨씬 더 자주 사용해요.\n- 특정 코드 조각을 주석 처리하는 데 개인적인 필요성을 반영한 사용자 정의 주석; 절약해서 사용합니다.\n\n이러한 전형적인 코드 주석들은 다음과 같습니다:\n\n- TODO: 구현해야 할 작업, 개선사항 또는 특징을 나타냅니다. 가장 일반적으로 사용되는 주석 중 하나이며 아마도 가장 자주 사용됩니다.\n- NOTE: 모듈, 클래스, 메소드 또는 함수(문서 문자열에 있는 경우)에 대한 중요한 정보를 강조하는 데 사용됩니다. 내장 주석으로 사용될 경우에는 해당 코드 조각 앞에 배치되며, 구현, 사용 또는 컨텍스트와 관련된 것일 수 있습니다. 개발자가 알아야 할 사항입니다.\n- BUG: 코드 내의 버그를 표시합니다. 버그에 대한 설명과 기타 중요한 정보와 함께 제공해야 합니다. 알고 있는 특정 버그일 수도 있고, 알 수 없는 버그가 있는 코드 조각의 표시일 수도 있습니다.\n- FIXME: 수정해야 하는 코드 내의 문제점을 표시합니다. 그러나 BUG와는 다릅니다. BUG는 코드에서 실제로 실수를 나타내는 반면, FIXME는 단순한 버그가 아닌 문제점을 나타내며, 쓸데없거나 비효율적인 구현, 비즈니스 로직의 잘못된 구현, 불분명한 코드와 관려될 수 있습니다.\n- REVIEW: 리뷰어가 특정 코드 조각에 주의를 기울여야 함을 알리는 신호를 보냅니다. 따라서 맥락을 명확히 설명해야 합니다.\n\n이외에도 가끔씩 두 가지 사용자 정의 코드 주석을 사용하는 것을 좋아해요:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 이것을 생각해보세요: 이것은 깊이 있는 사고를 필요로 하는 코드 조각이나 아이디어(문서 문자열에 위치한 경우)를 나타냅니다. 주로 기술적인 측면이 아니라 비즈니스 로직과 관련이 있는 경우가 많습니다.\n- 재고를 위해 다시 고려해보세요: 재고가 필요한 코드 조각을 나타냅니다. 설명 없이는 혼란스럽기 때문에 이유나 아이디어를 제공해야 합니다.\n\n당신이 지켜야 할 규칙은 주석을 명확하게 설명하는 것입니다. RECONSIDER로 설명된 것처럼, 설명이 없는 주석은 혼란스러울 수 있습니다. 이 설명은 간결하고 명확해야 합니다. 주석은 확실히 자세한 논의를 위한 도구로 사용되어서는 안 됩니다.\n\n우리는 종종 TODO가 주석이라고 말하지만, 사실 주석은 TODO와 같이 설명이 있는 주석 태그입니다.\n\n## 주석은 누구에게 주로 작성되나요?\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n의도된 수신자별로 주석을 그룹화할 수도 있습니다. 다음 수신자에게 주석을 지정할 수 있습니다:\n\n- 개발자: 주석의 가장 일반적인 사용은 개발 중에 코드의 중요한 측면을 개발팀에 알리는 데 사용됩니다.\n- 코드 사용자: 덜 흔한 사용 사례입니다. 이러한 주석은 사용자들에게 사용 중요 사항을 알리는 데 사용됩니다. 예를 들어, 폐기 예정, 동작 변경, 함수가 구현하는 로직에 대한 중요한 정보 등입니다. 개발자를 위한 주석과는 다른 종류의 정보를 전달합니다. 이러한 주석은 코드가 아닌 문서에 위치합니다.\n- 유지관리자: 가장 흔하지 않은 주석 유형이며, 신중하게 사용해야 합니다. 코드 기반이 생산 환경에 있고 코드가 사용자에게 사용되는 경우, 사용자는 코드 설명서에 이러한 주석을 보게 되면 혼란스러울 수 있습니다. 따라서 코드 유지자를 위해 주석을 사용해야 하는 경우 사용자를 대상으로 한 문서(예: docstrings)에 하지 마십시오. 필요 시 인라인 주석이나 유지 문서에 사용하십시오.\n\n이 세 가지 유형의 주석을 세밀하게 일치시킬 수는 없습니다. 개발자, 유지관리자 및 사용자를 위해 주석에 NOTE를 사용할 수는 있지만, FIXME 주석은 코드 사용자를 대상으로 지정하지 않습니다.\n\n중요한 점은 코드에 주석을 달 때 주석 대상이 누구인지 항상 염두에 두는 것입니다. 주석 태그 자체로는 이를 달성하는 데 충분하지 않습니다: NOTE 주석 태그를 보더라도 해당 주석이 어디로 지정된 것인지 알 수 없습니다. 주석의 설명이 맥락을 설명합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이게 혼란스러울 수 있다는 걸 알아요. 이렇게 해보는 건 어떨까요? 예를 들어 주석 태그들을 구별해서 세 가지 유형의 주석들을 구분하는 방법을 시도해 볼 수도 있어요. 그러나, 그렇게 하면 주석이 더 길어져서 가독성이 떨어질 수도 있어요. 이와 관련된 시도나 비슷한 작업을 한 사례에 대해 알고 있지는 않아요.\n\n그래서 코드 주석을 추가할 때는 가능한 한 명확하게 작성해 보세요. 또한, 누구를 위해 코드를 주석 처리하는지 명확히 하는 것도 중요하답니다.\n\n## 주석은 무엇을 위해 사용되나요?\n\n저는 주석의 목적을 세 가지로 간주해요:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 팀 의사 소통을 증진시킵니다. 코드에 주석을 추가하면 다른 개발자들에게 무언가 일어나고 있는지 알릴 수 있습니다. 예를 들어, 다음 작업이나 릴리스에서 무언가를 할 예정이라고 알릴 수 있습니다 (TODO). 그렇게 하면 코드 리뷰어들은 왜 이 작업을 하지 않았는지 궁금해하지 않아도 되며 코드에서 직접 이 정보를 알 수 있습니다 (또 다른 접근 방법은 풀 리퀘스트에 이를 작성하는 것이지만, 흥미롭게도 많은 리뷰어들은 이것을 읽지 않습니다...).\n- 주석을 사용하는 것은 개발자들을 위한 기억 기법(mnemonic technique)입니다. 주석은 기억 기호로 작동하며 코드의 특정 부분을 강조하는 것을 넘어서 개발자들이 빠르게 문제를 식별하고 기억하며 미래 고려를 위해 해당 영역으로 이동하는 데 도움을 줍니다. 주석은 쉽게 발견하기 쉽고 IDE나 편집기의 텍스트 검색 도구를 사용하여 쉽게 찾을 수 있습니다.\n- 의논을 위한 장소를 제공합니다. 코드는 그 복잡성을 논의하기에 좋은 장소가 거의 없지만, 코드에 주석을 달고 의문점에 대해 논의하면 이는 유용한 도구로 변합니다. 그러나 이러한 논의를 최대한 간결하게 유지하도록 기억하세요.\n\n이 세 가지 목적 중 첫 번째는 팀워크를 나타내며 두 번째는 주석이 혼자 작업할 때에도 사용될 수 있다는 것을 보여줍니다. 저도 그렇게 사용하고 있으며, 무엇을 해야 하는지 (TODO) 상기시키는 데 훌륭한 도구로 생각하며 코드의 중요한 측면을 논의하는 데 좋은 도구라고 생각합니다 (예: NOTE, FIXME, RECONSIDER, 그리고 문제에 따라 다른 어노테이션도 있음).\n\n팀에 속해 있을 때, 주석은 코드뿐만 아니라 문서에서도 무언가를 가리키는 가장 효율적인 방법일 수 있습니다. 물론, 개발자들과의 직접적인 의사 소통, 저장소에 코멘트 남기기 등 다른 도구들을 사용할 수 있습니다. 그러나 주석처럼 효율적이지 않을 때가 더 많습니다. 주석은 바로 그 곳에 있어야 하며 따라서 간과하기 어려운 이러한 위치에 있습니다.\n\n## 주석은 얼마나 길어야 할까요?\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n주석은 가능한 한 짧게 작성하여 메시지를 전달해야 합니다. 이 규칙을 어길 경우가 있지만, 주로 그렇습니다.\n\n주석이 너무 길어지면 주석답지 않게 보일 수 있습니다. 독자들이 혼란스러워하거나 주석을 읽고 있는지조차 잊을 수도 있습니다.\n\n그러므로 주석은 짧을수록 좋습니다. 문장 단편은 허용되지만, 일반적으로 전체 문장을 사용하면 이해가 높아집니다.\n\n## 주석이란 무엇을 의미하는가?\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n코드에서 어노테이션을 많이 볼 때 — 특히 그 양이 많을 때 — 대부분 코드가 개발 중에 있는 것을 의미합니다. 이것은 어노테이션이 주로 개발 도구이기 때문입니다.\n\n물론 예외도 있습니다. 때로는 코드 유지보수자들이 사용하는 어노테이션을 발견할 수도 있어요. 그래서 그 존재가 여전히 코드가 개발 중에 있다는 것을 의미할 필요는 없습니다. 또한 미래 릴리스에 대한 경고나 코드 동작 변경과 관련된 어노테이션을 코드 사용자를 위해 볼 수도 있습니다.\n\n그러나 프로덕션 코드에서 어노테이션을 과도하게 사용하는 것은 좋은 습관이 아닙니다. 중요한 정보를 전달하는 몇 개의 어노테이션은 괜찮지만, 모든 다른 함수나 클래스 메서드마다 어노테이션을 보게 되는 프로덕션 코드는 좋지 않아요. 프로덕션 코드에 어노테이션으로 가득 찬 것을 볼 때는, 신중한 결정이었는지 여부와는 상관없이 애플리케이션이 미성숙하게 배포된 것 같은 느낌을 받아요.\n\n## 어노테이션을 사용하는 곳?\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n코드 주석은 코드에 직접 추가되기 때문에 눈에 띄기 어려워요. 게다가 IDE 하이라이터를 사용하면 주석이 더욱 더 눈에 띌 수도 있어요. BUG와 같은 주석은 그렇게 되어야 해요; 코드에 버그가 있다는 사실을 크게 알고 싶어하는 거니까요. 이것은 곧 예시로 보여줄게요.\n\n저는 네 곳에 주석을 사용해요:\n\n- 모듈 독스트링: 모듈 독스트링에는 주로 TODO를 사용하지만, NOTE도 사용해요. 모듈 독스트링은 버그를 주석으로 처리하거나 특정 함수에서 무엇이 잘못되었는지 설명하는 곳이 아니에요. 그래서 모듈 독스트링에 주석을 달 일은 상대적으로 적어요. 달게 되면 보통 모듈 독스트링 끝에 주석을 달아요만, 이것이 규칙은 아니에요.\n- 클래스/메서드/함수 독스트링: 이것은 인라인 주석(아래 설명될)과 함께 가장 일반적인 주석 위치 중 하나에요. 클래스/메서드/함수 수준의 모든 주석을 작성할 수 있는 전형적인 위치에요. 함수가 비즈니스 로직을 잘못 구현했을 수도, 성능을 높일 수도, 병목이 될 수도, 어딘가에 버그가 있지만 어디에 있는지는 확인되지 않았을 수도 있는 경우에 이 위치가 가장 좋아요. 주석이 메서드/함수 코드를 참조할 때, 주로 해당 독스트링 끝에 두곤 해요. 다시 말하지만, 이것이 규칙은 아니에요: 주석이 독스트링이 전달하는 내용을 참조할 때는 때로는 독스트링 내부에 더 잘 맞을 수 있어요.\n- 인라인 주석: 위에서 언급한 클래스/메서드/함수 독스트링에 해당되는 첫 번째 문장이 여기에도 적용돼요. 그러나 인라인 주석은 코드 수준에 사용돼요. 주석은 일반적으로 참조하는 코드 단편 바로 앞에 두게 되요.\n- 문서 파일: 이 경우는 훨씬 덜 빈번한 사용 사례에요. 때때로 저는 문서 파일, 주로 README에서 주석을 사용해요. 예를 들어 새로운 섹션이 추가되어야 할 때 표시하거나, 특정 섹션이 완전하지 않거나 자세한 경우를 나타내거나, 특정 기능이 아직 예정대로 작동하지 않음을 강조하기 위해 이렇게 하죠. 문서 파일에 주석이 있는 위치에 주석을 달아요 — 해당 측면이 (또는 있어야 할 곳) 논의되는 곳에요.\n\n많은 사람들이 문서 파일이 실제로 코드의 일부가 아니라고 주장할 수 있지만, README와 같은 파일은 보통 코드 저장소의 중요한 부분을 구성해요. 이런 파일에 주석을 다는 것은 주의를 끄는 훌륭한 방법이에요. 그래서 왜 문서 파일에서 주석을 사용하는 것을 피해야 할까요? 🌟\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\ndocstring에 대해 이야기해보죠. 사용자에게 중요한 정보를 docstring에 추가해야 한다면, 주석을 사용할 필요가 없습니다. Docstring은 문서화의 중요한 요소이기 때문에 그 안에 포함된 내용은 중요해야 합니다. 그러므로, 사용자를 위한 주석 사용은 정보가 극히 중요하고 강조되어야 하는 경우에만 제한하는 것이 좋습니다.\n\n# Example\n\n다음 스크립트를 살펴보죠. 코드가 간단하고 유용한 일은 하지 않지만, 주석을 강조하는 방법을 보여주는 데 완벽히 적합할 것입니다. 실제 코드에서 사용한 것보다 더 많은 주석을 사용할 것이지만, 예를 들어 모듈을 디자인할 때 이렇게 할 수 있다고 상상할 수 있습니다.\n\n여기 텍스트 파일에 있는 코드의 원시 버전입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n\"\"\"이것은 예시 어노테이션 모듈입니다.\n\n할 일: 확장 프로그램을 설치하세요.\n다시 고려: 다른 어노테이션을 동일한 방식으로 포맷해야 할까요?\n\"\"\"\ndef foo(x, y, z):\n    \"\"\"세 요소로 구성된 튜플을 생성합니다.\n\n    예시:\n    >>> foo(1, 2, 3)\n    (1, 2, 3)\n    >>> foo('1', '2', 3)\n    ('1', '2', 3)\n\n    할 일: *args를 사용하여 더 많은 인수를 허용하세요.\n    다시 고려: 이 함수가 정말 중요한가요?\n    \"\"\"\n    return x, y, z\n\ndef bar(x: int) -> tuple[int, float, str]:\n    \"\"\"세 가지 유형을 갖는 int 튜플을 생성합니다.\n\n    할 일: \"세 가지 유형을 갖는 int 튜플\"이 무엇인지 설명하세요.\n    할 일: 독스트링을 추가하세요.\n    \"\"\"\n    # 수정 필요: tuple에 대한 직접 호출을 제거하세요.\n    return tuple(x, float(x), str(x))\n\ndef baz(x: float) -> tuple[int, float, str]:\n    \"\"\"float에서 세 가지 유형을 갖는 int 튜플을 생성합니다.\n\n    할 일: \"세 가지 유형을 갖는 int 튜플\"이 무엇인지 설명하세요.\n    할 일: 독스트링을 추가하세요.\n    \"\"\"\n    # 버그: x는 float이므로 튜플의 첫 번째 위치를 float로 변환해야 합니다.\n    # 수정 필요: tuple에 대한 직접 호출을 제거하세요.\n    return tuple(x, x, str(x))\n```\n\n여기서 네 가지 유형의 어노테이션을 사용했어요. 세 개는 일반적인 것들(TODO, NOTE, FIXME, BUG)이고 하나는 사용자 정의(RECONSIDER)입니다.\n\n코드 하이라이팅 없이도 어노테이션이 돋보이는 것을 알 수 있어요. 코드에 어노테이션이 가득해도 스크립트에 약간의 어노테이션만 있는 경우보다 어노테이션을 더 쉽게 발견할 수 있고 하이라이팅이 없는 텍스트 파일에서도 쉽게 간과되지 않음을 동의하실 거에요.\n\n이제 일반적인 Python 코드 하이라이팅을 사용해 스크립트를 확인해보겠습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n\"\"\"이것은 예제 어노테이션 모듈입니다.\n\n할 일: 확장 프로그램을 설치하세요.\n재고: 서로 다른 어노테이션이 동일한 방식으로 서식이 있는지 확인해야 합니까?\n\"\"\"\ndef foo(x, y, z):\n    \"\"\"세 요소의 튜플을 만듭니다.\n\n    예시:\n    >>> foo(1, 2, 3)\n    (1, 2, 3)\n    >>> foo('1', '2', 3)\n    ('1', '2', 3)\n\n    할 일: 더 많은 인수를 허용하도록 *args를 사용하세요.\n    재고: 이 함수가 정말 중요한가요?\n    \"\"\"\n    return x, y, z\n\ndef bar(x: int) -> tuple[int, float, str]:\n    \"\"\"세 가지 유형의 int 튜플을 만듭니다.\n\n    할 일: \"세 가지 유형의 int 튜플\"이 무엇인지 설명하세요.\n    할 일: 문서 테스트 추가하기.\n    \"\"\"\n    # 수정 필요: tuple에 대한 직접 호출 제거하기:\n    return tuple(x, float(x), str(x))\n\ndef baz(x: float) -> tuple[int, float, str]:\n    \"\"\"소수로부터 세 가지 유형의 int 튜플을 만듭니다.\n\n    할 일: \"세 가지 유형의 int 튜플\"이 무엇인지 설명하세요.\n    할 일: 문서 테스트 추가하기.\n    \"\"\"\n    # 버그: x가 float이므로 float로 변환되어야 합니다 (튜플의 첫 번째 위치 참조)\n    # 수정 필요: tuple에 대한 직접 호출 제거하기:\n    return tuple(x, x, str(x))\n```\n\n저는 Medium 스토리 편집기와 해당 코드 강조 도구를 사용했습니다. 일부 어노테이션을 굵은 글꼴로 서식을 지정하여 강조하고 있음을 확인할 수 있습니다. 그러나 이는 인라인 주석에 대해서만 적용되며 독스트링에는 적용되지 않습니다.\n\n귀하의 IDE나 편집기가 어노테이션 하이라이팅을 제공하는지 확인하고 해당 기능이 어떻게 작동하는지 확인한 후 설정해보세요. 이 작업은 중요합니다. 때로는 어노테이션 하이라이팅이 너무 불편할 수 있습니다. 하이라이팅을 과도하게 사용하면 코드 자체에 집중하는 데 문제가 발생할 수 있습니다. 어노테이션이 너무 눈에 띄면 무시할 수 없도록 지나치게 두드러질 수 있습니다.\n\n이는 코드 어노테이션에 대한 재미있는 점입니다. 어노테이션은 관심을 끌기 위해 존재하지만 작성하거나 읽은 후에는 그 존재를 잊을 수 있어야 합니다. 그 존재를 무시할 수 없다면 당신을 방해할 것입니다. 따라서 코드 개발 중에 그들의 주목성과 보이지 않음 사이의 적절한 균형을 찾아야 합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n코드 개발 중의 무시할 수 있는 역할에 대해 이야기해 보겠습니다. 이 아이디어는 주석을 쓴 후에도 그것을 무시할 수 있어야 하며, 읽은 후에도 무시할 수 있어야 합니다. 따라서 개발자가 주석을 읽고 그 내용을 이해하면, 코드 작업 중에 주석을 무시할 수 있어서 주의를 산만하게 하지 않아도 됩니다.\n\n전문 IDE나 고급 기능을 갖춘 텍스트/코드 편집기를 사용할 때, 주석을 강조 표시하는 기능을 제공하는지 확인해 보세요. 그리고 이 기능이 있다면, 도구를 구성하여 원하는 주석 강조 표시 설정을 찾아보세요.\n\n그러므로 자신과 팀원들을 위해 작동하는 주석 강조 표시 구성을 찾아야 합니다. 보통 여러분이 작성한 주석을 사용하는 유일한 사람은 아니기 때문입니다. 아래에서 Visual Studio Code에서 이를 어떻게 하는지 보여드리겠습니다. 우리는 작업의 기술적 부분에 집중할 것이며, 결론에서는 나의 프로젝트에서 사용하는 주석 강조 표시 구성을 소개할 것입니다.\n\n# Visual Studio Code에서 주석(annotation)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 섹션은 Visual Studio Code에 관련된 내용입니다:\n\n아마도 이것은 PyCharm과 함께 두 가지 가장 자주 사용되는 Python IDE 중 하나일 것입니다. 아래 예시에서는 Visual Studio Code의 1.87.2 버전을 사용하고 있습니다.\n\nVSC에는 단순한 내장 어노테이션 강조 기능이 있습니다. 우리 예시 스크립트에서는 이 기능이 어떻게 작동하는지 살펴보겠습니다:\n\n![example](/TIL/assets/img/2024-07-09-EnhancingReadabilityofPythonCodeviaAnnotations_1.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위에서 보듯이, VSC는 인라인 주석이나 문서 문자열에 상관없이 표준 주석을 강조 표시합니다; 여기서는 TODO, NOTE, FIXME 및 BUG입니다. 사용자 정의 주석인 RECONSIDER는 강조 표시되지 않습니다.\n\n이 강조 표시는 주석이 다른 글꼴 색상으로 인쇄되기 때문에 상당히 미묘합니다. 이는 종종 동작하지만 우리는 더 많은 기능을 원할 수 있습니다:\n\n- 일부 주석은 다른 주석보다 더 눈에 띄게 표시될 수 있습니다. 특히 BUG 및 FIXME와 같이 중요한 주석들은 더욱 눈에 띌 수 있습니다.\n- 예를 들어 RECONSIDER와 같은 사용자 정의 주석을 강조 표시하고 싶을 것입니다.\n\nVSC에는 주석을 강조 표시하는 도구가 있으며 TODO Highlight 확장 프로그램으로 제공됩니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n도구가 조금 오래되었어요. 마지막 커밋과 릴리즈가 2021년 10월에 있었지만 여전히 아주 잘 작동해요. 여기가 그 저장소입니다.\n\n그래서, 확장 프로그램을 설치해봐요:\n\n![이미지](/TIL/assets/img/2024-07-09-EnhancingReadabilityofPythonCodeviaAnnotations_2.png)\n\n\"설치\" 버튼을 누른 후에, 우리는 확장 프로그램 버전 1.0.5를 사용할 수 있을 거에요. 스크립트가 있는 탭으로 이동한 후에, 이것을 볼 수 있을 거에요:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/TIL/assets/img/2024-07-09-EnhancingReadabilityofPythonCodeviaAnnotations_3.png\" />\n\n이번에는 주요 주석이 훨씬 더 눈에 띄게 표시됩니다. 그러나 모두가 아닙니다. 명확히 말하자면 TODO Highlight는 모든 주석을 주석 처리하지 않습니다. 예를 들어, 이 예제에서 BUG와 NOTE, 심지어 사용자 정의 주석 중 하나인 RECONSIDER도 주석 처리하지 않습니다. BUG와 NOTE는 여전히 강조 표시되지만 내장 VSC 주석 강조 기능에 의해 강조 표시됩니다.\n\n이로운 경우가 많습니다. 팀에서 작업하는 경우 모든 팀원이 확장 프로그램을 설치하면 동일한 강조 표시가 표시되므로 이 접근 방식의 장점이 됩니다. 때로는 강조 표시기를 확장하고 싶을 수도 있습니다. 그리고 다음 섹션에서 이를 진행할 것입니다.\n\n## 사용자 정의 설정으로 TODO Highlight 확장하기\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n기본 구성이 충분하지 않다면 사용자 팀이나 개인 설정을 추가할 수 있습니다. 이를 위해 VSC 설치의 모든 사용자 설정을 포함하는 settings.json 파일을 편집해야 합니다.\n\n기본 설정을 확인하려면 F1을 누르고 \"default settings\"를 입력하세요. 다음을 보게 됩니다:\n\n![이미지](/TIL/assets/img/2024-07-09-EnhancingReadabilityofPythonCodeviaAnnotations_4.png)\n\n이 파일을 읽어 기본 설정을 확인할 수 있지만 수정하지 마세요. 사용자 설정은 다른 파일에 있으므로 다시 F1을 누르고 \"user settings\"를 입력하세요:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Screenshot of the second option](/TIL/assets/img/2024-07-09-EnhancingReadabilityofPythonCodeviaAnnotations_5.png)\n\n두 번째 옵션인 사용자 설정이 있는 JSON 파일을 선택해주세요. 이곳에는 TODO Highlighter를 위한 사용자 지정 설정을 추가할 수 있습니다. 이를 하는 방법은 확장 프로그램을 열고 DETAILS 탭을 읽어보시면 알 수 있습니다:\n\n![Screenshot of the DETAILS tab](/TIL/assets/img/2024-07-09-EnhancingReadabilityofPythonCodeviaAnnotations_6.png)\n\n확장 프로그램이 강조하지 않는 주석을 스크립트에 추가해보겠습니다: BUG, NOTE 및 RECONSIDER입니다. 이를 위해서는 새로운 필드인 todohighlight.keywords를 추가하는 단 한 줄의 코드를 추가해야 합니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Image](/TIL/assets/img/2024-07-09-EnhancingReadabilityofPythonCodeviaAnnotations_7.png)\n\n만약 콜론을 강조하고 싶다면, 주석의 일부로 취급해야 합니다. 그렇지 않으면, 이러한 주석은 콜론 없이 강조되어 표시됩니다. 이는 내장 주석에 대해 TODO 하이라이터가 사용하는 동작과 다른 동작입니다 (다음 이미지에서 TODO가 어떻게 강조되는지 확인해보세요).\n\nsettings.JSON에 사용자 정의 구성을 추가하면 확장 프로그램이 즉시 업데이트됩니다. 방금 추가한 주석이 설정 파일 및 다른 열린 파일에서 위 화면샷과 같이 강조 표시될 것을 볼 수 있습니다.\n\n이제 스크립트는 다음과 같이 보일 것입니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/TIL/assets/img/2024-07-09-EnhancingReadabilityofPythonCodeviaAnnotations_8.png)\n\n좋아요! 그리고 자주 그것만으로 충분합니다.\n\n하지만 한 발 더 나아가 다른 색상으로 설정하고 싶다면 — 사실 더 많은 것도 할 수 있습니다 — 이 파일에서 할 수 있습니다. 지금처럼 BUG 주석을 더 강조해 봅시다:\n\n![image](/TIL/assets/img/2024-07-09-EnhancingReadabilityofPythonCodeviaAnnotations_9.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이것이 어떻게 작동하는지 확인할 수 있어요. 정말로 눈에 띄고, 이게 전체적인 목적이었죠. baz() 함수에 대해서만 확인해 보겠습니다:\n\n![이미지](/TIL/assets/img/2024-07-09-EnhancingReadabilityofPythonCodeviaAnnotations_10.png)\n\n어노테이션이 추가적인 줄로 확장되는 경우, baz() 함수의 BUG처럼 그 부분은 전혀 강조되지 않아요. 어노테이션 태그만 강조될 때는 문제가 되지 않지만, 여기서는 전체 줄을 강조하려고 해요. 그래서 baz()에서 버그를 설명하는 두 줄 모두 태그가 달려 있어요.\n\n첫눈에 보면, 독자들은 두 어노테이션(그리고 두 버그)을 보고 있다고 생각할 수 있어요. 그래서 두 번째 줄을 들여쓰기하여 이전 줄의 연속임을 시각적으로 나타낼 수 있어요(표시하지 않음).\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저는 어떻게 해야 할지 보여드렸는데, 전체 줄을 강조하는 것은 지나치게 하지 마세요. 이것은 혼란스럽고 주의를 산만하게 만들기 때문에, 주석 태그만 강조하는 것을 선호합니다.\n\n다양한 주석에 대해 설정을 다르게 할 수 있습니다:\n\n![Python Readability Annotations](/TIL/assets/img/2024-07-09-EnhancingReadabilityofPythonCodeviaAnnotations_11.png)\n\n여기서는 BUG에 대해 자세한 설정을 제공하고, FIXME에 대해서는 덜 자세한 설정을 하며, NOTE 및 RECONSIDER 주석을 기본 설정으로 사용할 것입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n설정 파일에 추가한 주석이 어떻게 강조되는지 확인할 수 있어요. 그런데 가끔은 방금 한 변경 사항이 보이지 않아서 뭔가 잘못되었다고 생각할 수도 있어요. 이럴 때는 설정된 JSON 파일을 새로고침해주면 됩니다 (닫고 다시 열거나) 또는 변경 사항을 반영한 후 다른 탭으로 이동하면 예상대로 강조 표시기가 작동할 거에요.\n\n마지막으로, TODO 하이라이트의 기본 스타일을 변경하는 방법을 보여드릴게요:\n\n![TODO 하이라이트 기본 스타일 변경](/TIL/assets/img/2024-07-09-EnhancingReadabilityofPythonCodeviaAnnotations_12.png)\n\n이제 다음 구성으로 예시 스크립트가 어떻게 보이는지 확인해볼게요:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/TIL/assets/img/2024-07-09-EnhancingReadabilityofPythonCodeviaAnnotations_13.png\" />\n\n이게 스크립트야:\n\n<img src=\"/TIL/assets/img/2024-07-09-EnhancingReadabilityofPythonCodeviaAnnotations_14.png\" />\n\n# 결론 및 제안\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n주석을 사용하면 코드의 가독성을 크게 높일 수 있어요. 그러나 지나치게 사용하면 오히려 반대 효과를 낼 수 있어요. 특히 화려한 강조 표시를 사용하거나 지나치게 긴 설명을 쓰는 경우에는 코드가 더 이해하기 어려워질 수 있어요.\n\n여기 파이썬 코드에서 주석을 사용하는 방법에 대한 제안이 있어요:\n\n## 사용은 하되 지나치지는 말아요\n\n먼저, 주석을 사용하지만 지나치게 사용하지는 마세요. 주석은 특히 중요한 내용을 전달해야 할 때 사용하세요. 그 내용이 코드에서 잊혀지거나 간과될 수 있는 경우 주석을 달아주세요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n동시에 사용에 대해 걱정하지 마세요: 과도한 강조만 사용하지 않는다면, 주석은 제대로 돌아 봐야 할 방법으로 제대로 들어날 수 있습니다. 따라서, 어떤 경우에도 섬세한 강조를 사용하세요. 솔직히 말하자면, 과하게 강조된 항목보다는 강조되지 않은 주석이 더 잘 작동합니다.\n\n## 주석은 중요한 정보에만 사용하세요\n\n주석은 무의미한 코멘트가 아닙니다. 진짜 말해야 하는 것입니다. 코드나 프로젝트, 코드 검토, 또는 다른 것에 중요할 수 있지만, 반드시 중요해야 합니다.\n\n그러므로 주석을 단순히 무언가를 말하는 멋진 방법으로 취급하지 마세요. 중요한 정보를 전달하는 데 있어서 효율적인 (가시성 면에서) 방법으로 취급하세요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 커스텀 주석 사용을 자제해주세요\n\n팀원들이 이해하기 어려워할 수도 있는 커스텀 주석은 피하는 것이 좋습니다. 이는 커스텀 주석을 전혀 사용하지 말아야 한다는 의미가 아니라, 보통 주석이 더 잘할 수 있는 경우에는 커스텀 주석을 사용하지 않는 것이 좋다는 것입니다. 만약 그렇다면, 사실 더 나은 일을 합니다 — 다른 사람들이 쉽게 알아차리고 이해하기 쉬울 것이며, 주석을 처리하고 상황을 이해하는 데 몇 초간 멈춰야 할 필요가 없을 것입니다.\n\n이는 커스텀 주석을 전혀 피해야 한다는 것이 아닙니다. 팀 프로젝트에서는 최대한 사용하지 않으려고 노력하지만, 혼자 작업하거나 두세 명의 개발자로 이루어진 작은 팀에서 일할 때 필요하다면 때로는 커스텀 주석을 사용하기도 합니다.\n\n상황이 커스텀 주석이 필요함을 시사하는 것 같다면, 다른 방법을 찾아보려고 노력해보세요. 두 번 생각하고, 다시 한 번 검토하세요. 여전히 최선의 접근 방식이라고 생각한다면, 한 번 더 생각해보세요. 혹시 팀원들과 상의해보는 것은 어떨까요?\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테이블 태그를 마크다운 형식으로 바꾸세요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 주석 설정을 신중히 구성하세요\n\n너무 많은 주석 설정으로 과도하게 하지 마세요. 시각적으로 다른 형식으로 서식이 지정된 많은 주석이 포함된 코드는 시각적으로 혼잡해집니다.\n\n사실, 예제 스크립트에 사용한 일부 설정은 지나치게 과장되었습니다. 예를 들어, BUG를 한 줄 전체를 강조하는 설정과 같은 것입니다. 종종, 새로운 주석을 추가하고 각각 개별적으로 설정하는 대신 기본 설정을 사용하는 것이 가장 좋을 수 있습니다.\n\n일부 주석을 다른 주석과 구별하고 싶다면 — 예를 들어, BUG 및 FIXME — 여기와 같이 작은 변경만으로 충분합니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/TIL/assets/img/2024-07-09-EnhancingReadabilityofPythonCodeviaAnnotations_15.png\" />\n\nVSC의 확장 기능 TODO Highlight에서, 가장 인기있는 주석들을 주석 처리하는 것을 의미합니다: TODO, NOTE, REVIEW, BUG 및 FIXME. 내장 TODO Highlight의 주석인 TODO는 자체 색상을 갖게 될 것입니다. BUG 및 FIXME는 다른 주석들과 달리 동일한 스타일을 사용합니다. BUG에는 \"color\": \"white\"를 추가해야 했는데, 그렇지 않으면 기본 색상으로 검정색이 사용되었을 것입니다:\n\n<img src=\"/TIL/assets/img/2024-07-09-EnhancingReadabilityofPythonCodeviaAnnotations_16.png\" />\n\n이로써 다음 효과가 발생합니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/TIL/assets/img/2024-07-09-EnhancingReadabilityofPythonCodeviaAnnotations_17.png)\n\n안녕하세요! 파이썬 코드의 가독성과 코드 개발의 효율성을 높일 수 있는 주석에 대해 이야기해봅니다. 그러나 주석을 과하게 사용하지 않는 것이 중요합니다. 과도한 구성은 주석을 너무 눈에 띄게 만들어 코드에 불필요한 시각적 혼란을 줄 수 있습니다.\n\n그러므로 주석 사용을 꺼리지 말고 현명하게 활용해보세요. 자신에게 유혹이 되지 않는다면, 일단 주석이 어떻게 작동하는지 이해하는 것이 중요합니다. 왜냐하면 늦게나마 주석을 사용하는 팀에 속하거나 주석이 포함된 외부 패키지를 사용할 수도 있기 때문입니다.\n\n그러므로 주석이 어떻게 작동하는지 이해하는 것이 중요합니다. 이 글이 도움이 되었으면 좋겠습니다. 그럼에도 주석에는 주관적인 면이 있습니다. 이 글에서도 주석을 어떻게 보고, 어떻게 생각하는지를 설명했지만, 다른 사람들은 다른 의견을 가질 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-07-09-EnhancingReadabilityofPythonCodeviaAnnotations_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-EnhancingReadabilityofPythonCodeviaAnnotations_0.png","tag":["Tech"],"readingTime":28},{"title":"SpaceX 이중 부스터 착륙 비디오 분석과 Python 모델 구축 방법","description":"","date":"2024-07-09 19:02","slug":"2024-07-09-VideoAnalysisandPythonModeloftheSpaceXDoubleBoosterLanding","content":"\n비디오에서도 놀랍게 멋진 광경이에요. 두 개의 로켓이 빠르게 다가오지만 각자의 플랫폼에 옆으로 착륙하는 걸 볼 수 있어요. 이게 바로 SpaceX 파이콘 헤비 부스터의 작동 방식이에요. 이 비디오를 보세요.\n\n아티스트가 사랑스러운 꽃을 그리듯이, 나는 이 황홀한 사건을 감상하기 위해 약간의 물리학을 사용해야 해요. 이 경우에는 Tracker Video Analysis(무료 소프트웨어)를 사용해서 착륙하는 이 부스터들의 움직임을 살펴볼 거에요. 정말 재미 있을 거예요.\n\n익숙하지 않다면, 비디오 분석의 기본 아이디어를 설명해 드릴게요. 비디오를 찍으면 각 프레임에서 물체의 위치를 볼 수 있어요. 프레임 번호에서 시간 데이터를 얻을 수 있고 (재생 프레임 속도가 실제 속도와 같다고 가정할 때), 비디오 프레임의 물체 크기를 알고 있다면 x와 y 위치도 얻을 수 있어요. 참 많은 것이죠.\n\n# 비디오 크기 조정 및 프레임 수정\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n첫 번째 단계는 비디오의 크기를 조정하는 것입니다. 이 경우에는 부스터 자체의 길이를 사용할 수 있습니다. 이 SpaceX 페이지에는 Falcon Heavy의 길이가 70m로 나와 있습니다. 이를 통해 부스터의 길이를 측정할 수 있습니다.\n\n![이미지](/TIL/assets/img/2024-07-09-VideoAnalysisandPythonModeloftheSpaceXDoubleBoosterLanding_0.png)\n\n이를 통해 높이가 약 46m임을 알았습니다. 완벽한 측정이 아니더라도 괜찮습니다. 이제 이 길이를 비디오에서 사용할 수 있습니다. 그런데 기다려 보세요! 이 착륙 중에 카메라가 팬 및 줌을 조정합니다. 걱정하지 마세요. Tracker Video에서 코디네이트 참조 프레임을 조정할 수 있습니다(보정 포인트 쌍을 사용).\n\n만약 카메라가 움직이지 않았다면 이렇게 보일 것입니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:960/1*x5UudQB-ajAgQDgS8pfj5g.gif)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 단계를 준비했습니다.\n\n# 움직임 추적\n\n각 프레임에 설정된 좌표 시스템으로 각 로켓의 위치를 표시할 수 있습니다. 실제로 각 로켓에 대해 두 개의 위치를 표시할 거에요 — 상단 위치와 하단 위치를 표시할 거에요. 그래도, 여기 하나의 로켓에 대한 시간에 따른 수직 위치입니다.\n\n![image](/TIL/assets/img/2024-07-09-VideoAnalysisandPythonModeloftheSpaceXDoubleBoosterLanding_1.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n데이터는 어느 정도 패러볼릭한 모습입니다. 그래서 이 데이터에 맞는 패러본을 적합할 수 있어요(Tracker curve fit을 사용해서). 운동방정식도 1/2 times 가속도가 t² 용어 앞에 오는 패러본 형태이기 때문에, 이를 사용해서 가속도를 결정할 수 있어요. 적합 매개변수를 통해 가속도가 6.38 m/s² 인 것으로 나왔는데, 꽤 합리적으로 보입니다.\n\n# 3D 로켓 만들기\n\n로켓의 위치를 시간의 함수로만 표시하는 것 이상의 것을 할 수 있어요. 두 로켓의 움직임을 나타내는 3D 모델을 만들 수 있어요. 그게 바로 Web VPython에서 할 거예요. 간단히 말해 Web VPython은 파이썬과 비슷한 코드를 사용하여 3D 모델을 만드는 온라인 플랫폼이에요(정말 멋져요). 모든 세부사항을 자세히 다루지는 않겠지만, 이 정보로도 충분히 이해할 수 있을 거예요.\n\n첫 번째 단계는 각 로켓의 상단과 하단의 위치-시간 데이터를 어떻게든 Web VPython으로 가져오는 것이에요. 안타깝게도 이 작업을 수행하는 훌륭한 방법은 없어요. 대신 Tracker에서 데이터 값을 복사한 다음 그대로 Web VPython에 붙여넣기할 거예요. 마치 90년대 후반의 코딩 야만인인 것처럼요. 얼마나 마법처럼 보이는 일인지, 여기 좀 꿀팁을 하나 주죠. 값을 텍스트 편집기에 붙여넣으면 엔터 키를 제거하고 쉼표로 대체해서 파이썬에 더 적합하게 맞출 수 있어요. 아래가 어떻게 보이는지 확인해보세요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/TIL/assets/img/2024-07-09-VideoAnalysisandPythonModeloftheSpaceXDoubleBoosterLanding_2.png)\n\n빠른 참고 — 만약 파이썬에서의 리스트에 서투르다면, 여기 튜토리얼(또는 리프레셔)가 있어요. 그리고, 물어보기 전에 — 아니요, 이걸 넘파이 배열로 변환할 수 없어요. 웹 VPython이 실제 파이썬이 아니라서 우리가 사용할 모듈들에 모두 접근할 수 없어요 (넘파이를 사용할 수 있는 방법은 있지만, 이 자리에서는 건드리지 않겠어요). 아마도 (명확하지 않다면) 잘라 말할 필요가 있을 것 같아요 — 이들은 긴 리스트에요 — 362개의 요소가 있어요. 제 파이썬 고대인 방식으로 모든 것이 제대로 가져와졌는지 확인하기 위해 길이를 프린트했어요.\n\n로켓 2의 데이터를 얻은 후 (나의 데이터 목록에서 딱 첫 번째였어요), 로켓 1을 위해 이 과정을 반복해야 해요. 또한, 시간 값들을 위한 리스트가 필요할 것인데, 이는 프레임 속도의 역수인 0.0166833의 균일한 시간 간격으로 만들 수 있어요.\n\n이제 3D 마술을 해보죠. 웹 VPython에는 여러 다양한 객체들이 포함되어 있어요 — 이 경우, 우리는 실린더를 사용하여 블로스터들을 만들 거예요. 다음 코드로 실린더를 만들 수 있어요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Image of Video Analysis](/TIL/assets/img/2024-07-09-VideoAnalysisandPythonModeloftheSpaceXDoubleBoosterLanding_3.png)\n\n한쪽 끝에서 다른 쪽 끝으로 향하는 축 벡터가 있을 때 pos는 실린더의 한쪽 끝의 벡터 위치이고 axis는 축 벡터입니다. 반지름은 여기서 다루기 까다로울 수 있어요. 도움이 될 만한 그림이 있어요.\n\n![Image of Cylinder](/TIL/assets/img/2024-07-09-VideoAnalysisandPythonModeloftheSpaceXDoubleBoosterLanding_4.png)\n\n적은 문제가 있어요. 실린더의 맨 위와 맨 아래에 대한 벡터 위치가 있는게 맞아요. 이러한 벡터 값들을 사용하여 축 벡터를 찾을 수 있겠죠. 그러나 이러한 벡터 위치는 약간 변경될 수 있어 로켓 부스터의 길이가 약간 변할 수 있어요. 그래서 대신에 이러한 맨 위와 맨 아래 위치를 사용하여 축 벡터의 방향을 찾고, 그 후에 상수 길이를 곱해서 사용할 거예요. 아, 코드를 보여드릴게요. 그게 더 쉬울 거에요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 이 코드에 대한 주석입니다:\n\n- 부스터의 길이인 L이 분명히 되어 있기를 바랍니다 (그것을 주석으로도 넣었죠).\n- r1a는 로켓의 아래에서 위로 향하는 벡터입니다. 맨 위와 맨 아래 x 및 y 위치의 값 목록에서 데이터를 사용하여 이러한 위치를 벡터로 먼저 구성해야 합니다. 다소 어색할 수 있지만 작동합니다.\n- 실린더의 경우, 위치는 아래 벡터 값으로, 축은 길이(L)이고 r1a 방향의 단위 벡터로 곱한 값입니다. 내장 된 norm() 함수를 사용하여 이 작업을 수행할 수 있습니다.\n- 아, 실린더의 정의에 make_trail=True를 추가할 것입니다. 이렇게하면 분명히 경로가 만들어집니다 (때로는 코드가 간단합니다).\n\n# 부스터 동작 애니메이션화하기\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n부스터용 3D 모델을 만들었습니다. 이제 그들을 움직이도록 해야 합니다. 이 경우에는 데이터 목록의 각 값을 통해 시간 단계마다 실린더를 새 위치로 이동시키는 것만 할 거에요.\n\n좀더 살펴봐야 할 점이 있어요, 그러니까 일단 코드의 간단한 버전부터 시작해볼까요? 이거 봐봐요.\n\n![이미지](/TIL/assets/img/2024-07-09-VideoAnalysisandPythonModeloftheSpaceXDoubleBoosterLanding_6.png)\n\n자세한 내용은 아래와 같아요:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 시간 값 목록(t)이 있음을 기억해주세요. 26번째 줄은 이 목록의 길이를 따라가며 변수 i를 사용하여 계산합니다. 다른 목록의 인덱스로 사용할 수 있도록 유용합니다.\n- 아, 파이썬의 루프에는 :가 필요하며, 그 아래에 탭으로 들여쓴 모든 내용이 루프의 일부입니다.\n- 27번째 줄은 이상하게 보일 수 있습니다. rate(100)라는 문을 가지고 있으면, 파이썬에게 초당 최대 100번의 루프만 수행하라고 알립니다. 애니메이션을 특정 속도로 실행하려고 하는 것이 중요합니다. 이 경우에는 rate(1/dt)를 사용하여 \"실시간\"으로 실행되도록 합니다.\n- 28번째 줄과 29번째 줄에서는 부스터의 바닥과 꼭대기에 대한 벡터 값을 생성합니다.\n- 30번째 줄에서는 부스터의 위치를 업데이트 합니다. 이것이 실제로 3D 애니메이션에서 이동하는 것을 만듭니다.\n- 31번째 줄에서는 축을 업데이트 합니다.\n\n이 모든 내용으로 아래는 애니메이션입니다.\n\n![애니메이션](https://miro.medium.com/v2/resize:fit:1000/1*KmXJ7wLB0IqLBEUD4CF3kA.gif)\n\n전체 코드가 필요하시다면, 여기에서 확인하실 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 숙제\n\n앗, 누군가가 숙제 과제를 원한다고 했던 것 같아요. 제가 준비해왔어요.\n\n- 이 애니메이션에서 두 로켓은 동일한 z-위치(화면 내외)를 가지고 있습니다. 촬영 위치와 착륙 장소의 z-값을 조정하기 위해 추정해보세요.\n- 로켓의 각 크기를 이용하여 z-위치를 결정할 수 있을까요? 힌트: 제 생각에는 불가능한데, 왜 작동하지 않을까요?\n- 그 로켓 엔진에 일부 화염을 붙이는 건 어떨까요? 가능할까요?\n- 부스터의 가속도와 추정 질량을 사용하여 연료 사용률을 계산해보세요.\n- 애니메이션을 더 멋지게 만들어보세요. 화염을 추가하는 것 외에도, 지면을 착륙 패드(아마도 몇 개의 타워도)로 만들어보세요.\n","ogImage":{"url":"/assets/img/2024-07-09-VideoAnalysisandPythonModeloftheSpaceXDoubleBoosterLanding_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-VideoAnalysisandPythonModeloftheSpaceXDoubleBoosterLanding_0.png","tag":["Tech"],"readingTime":8},{"title":"통계학 시계열 분석  기본 개념 총정리","description":"","date":"2024-07-09 18:59","slug":"2024-07-09-StatisticsTimeSeriesAnalysisCompilationofthefundamentalconcepts","content":"\n## 통계 및 수학\n\n시각화 및 자세한 수학적 유도를 통한 시계열 분석 기초를 친절하게 소개합니다\n\n![image](/TIL/assets/img/2024-07-09-StatisticsTimeSeriesAnalysisCompilationofthefundamentalconcepts_0.png)\n\n요즘 시험을 위해 기본적인 통계적 시계열 분석에 대해 공부하고 있어요 [1]. 하지만 무서운 수학 공식들 때문에 머리에 남지 않는다구요. 그래서 자기상관, 자기상관성, 정상성 및 시계열 프로세스와 같은 기본적인 개념들을 시각화를 통해 정리하기로 했어요. 이 블로그에서는 시각화를 통해 이러한 개념을 가능한 한 자세히 설명하고 파이썬으로 구현해 볼 거에요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 목차\n\n- 시계열이란 무엇인가? — 자기공분산, 자기상관 및 정상성\n- 대표적인 시계열 과정\n\n  - 2.1 백색 소음(white noise)\n  - 2.2 자기회귀(AR) 과정\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 2.3 이동평균(MA) 프로세스\n\n- 2.4 자기회귀 이동평균(ARMA) 및 ARIMA 프로세스\n\n3. 시계열에 대한 통계 검정\n\n- 3.1 증가된 디키-퓰러(ADF) 검정\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n-3.2 더빈-왓슨 검정\n\n## 1. 시계열 데이터란? — 자기공분산, 자기상관 및 정상성\n\n이름에서 알 수 있듯이 시계열은 시간과 관련이 있습니다. 시간이 흐름에 따라 관측된 데이터를 시계열 데이터라고합니다. 예를 들어, 심박수 모니터링, 일일 최고 기온 등이 있습니다. 이러한 예는 규칙적인 간격으로 관측되지만 시간이 불규칙한 간격으로 관측되는 시계열 데이터도 있습니다. 예를 들어, 일중 주식 거래, 임상 시험 등이 있습니다. 이 블로그는 규칙적인 간격으로 관측되는 단일 변수(일변량 시계열)의 시계열 데이터를 사용할 것입니다. 수학적으로 시계열은 다음과 같이 정의될 수 있습니다:\n\n![image alt text](/TIL/assets/img/2024-07-09-StatisticsTimeSeriesAnalysisCompilationofthefundamentalconcepts_1.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 Xₜ를 랜덤 변수로 간주한다면, 관측 시점 t에 따라 평균과 분산을 정의할 수 있습니다.\n\n![StatisticsTimeSeriesAnalysisCompilationofthefundamentalconcepts_2](/TIL/assets/img/2024-07-09-StatisticsTimeSeriesAnalysisCompilationofthefundamentalconcepts_2.png)\n\n시계열 데이터의 경우, 과거와 현재 데이터를 비교해보고 싶을 수 있습니다. 이를 위해 자기공분산과 자기상관이라는 두 가지 필수 개념이 추가 논의를 위해 필요합니다. 그러니 이제 그것들을 자세히 살펴봅시다!\n\n자기공분산\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n기술적으로 자기공분산은 공분산과 같습니다. 공분산은 다음과 같은 공식을 갖습니다:\n\n![Covariance Formula](/TIL/assets/img/2024-07-09-StatisticsTimeSeriesAnalysisCompilationofthefundamentalconcepts_3.png)\n\n이 경우, 공분산은 두 변수 X와 Y 간의 관계를 계산합니다. 표본 공분산을 계산할 때는 각 관측치와 평균의 차이를 n-1로 나누는 것에 유의하세요. 자기공분산의 경우 이전 관측치와 현재 관측치 간의 표본 공분산을 계산합니다. 공식은 아래와 같습니다:\n\n![Autocovariance Formula](/TIL/assets/img/2024-07-09-StatisticsTimeSeriesAnalysisCompilationofthefundamentalconcepts_4.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n헤이지는 래그로 불리며, 래그된 X는 h만큼 이동된 직전 X 값입니다. 공분산과 동일한 수식을 가지고 있는 것을 볼 수 있습니다.\n\n자기상관\n\n자기상관은 자기상관과 마찬가지로 상관 관계를 나타내며, 자기공분산과 같습니다. 상관 계수 공식은 다음과 같습니다.\n\n<img src=\"/TIL/assets/img/2024-07-09-StatisticsTimeSeriesAnalysisCompilationofthefundamentalconcepts_5.png\" />\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n상관관계는 변수 X와 Y의 표준 편차로 공분산을 나누어 계산됩니다. 상관관계는 정규화된 공분산과 유사하게 생각할 수 있습니다. 자기 상관관계의 경우, 이전 및 현재 관측치 사이의 상관관계를 계산합니다. 여기서 h는 이 공식에서의 지연을 나타냅니다.\n\n![이미지](/TIL/assets/img/2024-07-09-StatisticsTimeSeriesAnalysisCompilationofthefundamentalconcepts_6.png)\n\n두 변수 X와 Y가 긍정적인 관계를 가질 때, 공분산 및 상관관계가 더 높은 양수 값을 가집니다. 자기공분산과 자기상관관계는 어떨까요? 시각화를 통해 확인해보겠습니다.\n\n첫 번째 예제에서는 AR(1) 과정에서 데이터를 생성했습니다(나중에 자세히 살펴보겠습니다). 이는 잡음이 섞인 데이터처럼 보입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래 표는 Markdown 형식으로 변경되었습니다.\n\n![autocovariance](/TIL/assets/img/2024-07-09-StatisticsTimeSeriesAnalysisCompilationofthefundamentalconcepts_7.png)\n\n이 경우, 자기상관 및 자기상관도 그래프는 아래와 같습니다. x축은 래그(lag)를 나타냅니다.\n\n![autocorrelation](/TIL/assets/img/2024-07-09-StatisticsTimeSeriesAnalysisCompilationofthefundamentalconcepts_8.png)\n\n자기상관 및 자기상관도가 비슷한 경향을 보입니다. 따라서, 자기상관은 정규화된 자기상관으로 볼 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 예제에서는 AirPassengers [4]와 같은 실제 데이터를 사용할 것입니다. AirPassengers 데이터는 명확한 상승 경향을 보입니다.\n\n![AirPassengers](/TIL/assets/img/2024-07-09-StatisticsTimeSeriesAnalysisCompilationofthefundamentalconcepts_9.png)\n\n이 경우, 자기공분산 및 자기상관도 그래프는 아래와 같습니다. x 축은 지연을 나타냅니다.\n\n![Autocovariance and Autocorrelation](/TIL/assets/img/2024-07-09-StatisticsTimeSeriesAnalysisCompilationofthefundamentalconcepts_10.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n비슷하게, 자기 공분산과 자기 상관은 비슷한 경향을 가집니다. 이 데이터는 첫 번째 예제보다 더 많은 상관관계와 더 큰 지연을 가지고 있습니다.\n\n이제 두 가지 주요 개념인 자기 공분산과 자기 상관에 대해 이해했습니다. 다음으로, '정상성(stationarity)'이라는 새로운 개념에 대해 이야기해보겠습니다. 정상성을 갖는 시계열은 평균, 분산 및 공분산과 같은 데이터 속성이 관측 시간에 의존하지 않음을 의미합니다. 정상성에는 다음 두 가지 유형이 있습니다:\n\n- 약한 정상성(2차 정상성)\n- 엄격한 정상성(강한 정상성)\n\n정의를 확인해 봅시다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n1. 약한 정상성(2차 정상성)\n\n위 과정은 약한 정상성, 2차 정상성 또는 공분산 정상성이라고 불리는 관계를 가지고 있습니다. (많은 방법으로 불릴 수 있습니다.)\n\n![image](/TIL/assets/img/2024-07-09-StatisticsTimeSeriesAnalysisCompilationofthefundamentalconcepts_11.png)\n\n여기서 µ는 상수이고 𝛾ₜ는 𝛕에 의존하지 않습니다. 이러한 공식들은 평균과 분산이 시간에 따라 안정적이며, 공분산은 시간 지연에 의해 결정된다는 것을 보여줍니다. 예를 들어, 이전 단락의 첫 번째 예제는 약한 정상성을 갖습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2. 엄격한 정상성(강한 정상성)\n\nFx(・)로 결합 밀도 함수를 나타낼 때, 엄격한 정상성은 다음과 같이 설명됩니다:\n\n![이미지](/TIL/assets/img/2024-07-09-StatisticsTimeSeriesAnalysisCompilationofthefundamentalconcepts_12.png)\n\n모든 시계열 데이터의 결합 분포가 시간 변화에 대해 불변일 때, 해당 시계열은 엄격한 정상성을 갖습니다. 엄격한 정상성은 약한 정상성을 함축합니다. 이 특성은 현실 세계에서 매우 제한적입니다. 따라서 많은 응용 프로그램은 약한 정상성에 의존합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n시계열 데이터가 정상인지 확인하는 몇 가지 통계적 검정 방법이 있습니다. 2장에서 대표적인 시계열 프로세스를 배우면 보다 이해하기 쉬울 것입니다. 그래서 이를 3장에서 소개하겠습니다.\n\n## 2. 대표적인 시계열 프로세스\n\n이제부터 흰 잡음(white noise), 자기회귀(AR), 이동평균(MA), ARMA, ARIMA와 같은 대표적인 시계열 프로세스를 살펴볼 것입니다.\n\n## 2.1 흰 잡음\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n시계열 데이터가 다음 특성을 가질 때 해당 시계열 데이터는 화이트 노이즈를 가지고 있습니다.\n\n![화이트 노이즈](/TIL/assets/img/2024-07-09-StatisticsTimeSeriesAnalysisCompilationofthefundamentalconcepts_13.png)\n\n화이트 노이즈는 평균이 0이고, 분산이 시간 단계별로 동일합니다. 게다가 공분산이 0이며, 시계열과 그 시간 지연된 버전은 상관 관계가 없음을 의미합니다. 따라서 자기상관도는 0을 가집니다. 주로 시계열 회귀 분석에서 잔차 항이 만족해야 하는 가정으로 사용됩니다. 화이트 노이즈의 플롯은 아래와 같이 보입니다.\n\n![화이트 노이즈 플롯](/TIL/assets/img/2024-07-09-StatisticsTimeSeriesAnalysisCompilationofthefundamentalconcepts_14.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n표 태그를 Markdown 형식으로 변환할 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nUₜ이 백색 잡음이라고 가정하며, 𝜙은 한 단계 이전 값에 해당하는 알려지지 않은 매개변수입니다. Uₜ는 충격(shock)이라고도 불립니다. 과거 단계로 수식 (1)을 해결할 때 아래의 공식을 얻을 수 있습니다.\n\n![image](/TIL/assets/img/2024-07-09-StatisticsTimeSeriesAnalysisCompilationofthefundamentalconcepts_16.png)\n\n위 공식에서 𝜙ᵗ₁는 Y 시리즈에만 영향을 미칩니다. 따라서 아래의 사항을 깨달을 수 있습니다:\n\n- 만약 |𝜙₁| ` 1이면, 단계가 지남에 따라 과거 값의 영향이 점점 작아집니다.\n- 만약 |𝜙₁| = 1이면, 과거 값의 영향은 시차(Lags)에 관계없이 일정합니다.\n- 만약 |𝜙₁| ` 1이면, 과거 값의 영향이 단계가 지남에 따라 현재 값에 영향을 줍니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n각 케이스의 시각화를 확인해 봅시다.\n\n![Visualization](/TIL/assets/img/2024-07-09-StatisticsTimeSeriesAnalysisCompilationofthefundamentalconcepts_17.png)\n\n𝜙₁의 값이 커질수록 현재 스텝이 이전 스텝의 값에 따라 이루어집니다. 따라서 값이 증가함에 따라 부드러워 보이며, 𝜙₁ = 1이 될 때까지 값이 증가합니다. 𝜙₁가 1보다 큰 값일 때는 값이 무한대로 증가하므로 시리즈가 최종 그래프처럼 보입니다.\n\n|𝜙₁| ` 1인 경우 약간의 정상 프로세스가 있습니다. AR(1) 프로세스가 약한 정상성을 만족할 때 평균과 공분산은 다음과 같습니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![그림](/TIL/assets/img/2024-07-09-StatisticsTimeSeriesAnalysisCompilationofthefundamentalconcepts_18.png)\n\n평균에 대해서는 시간에 따라 평균을 일정하게 사용합니다. 화이트 노이즈가 평균이 0이라는 사실을 이용하여 다음과 같은 공식을 유도할 수 있습니다.\n\n![그림](/TIL/assets/img/2024-07-09-StatisticsTimeSeriesAnalysisCompilationofthefundamentalconcepts_19.png)\n\n공분산에 대해서는 먼저 공식 (1)을 변경해야 합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Image 1](/TIL/assets/img/2024-07-09-StatisticsTimeSeriesAnalysisCompilationofthefundamentalconcepts_20.png)\n\nThen, we need to derive the variance and the covariance in this order. For the variance, we can derive it by taking a square of the above derived formula.\n\n![Image 2](/TIL/assets/img/2024-07-09-StatisticsTimeSeriesAnalysisCompilationofthefundamentalconcepts_21.png)\n\nFor the covariance, we can derive it by multiplying the subtraction of the previous step value and the mean.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/TIL/assets/img/2024-07-09-StatisticsTimeSeriesAnalysisCompilationofthefundamentalconcepts_22.png\" />\n\nAR(p) process를 비슷하게 고려할 수 있습니다.\n\n<img src=\"/TIL/assets/img/2024-07-09-StatisticsTimeSeriesAnalysisCompilationofthefundamentalconcepts_23.png\" />\n\n보통, AR(p) 과정은 다음 조건(5)(6)을 만족할 때 약정상태(weak-stationary)가 될 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/TIL/assets/img/2024-07-09-StatisticsTimeSeriesAnalysisCompilationofthefundamentalconcepts_24.png)\n\n공식 (5)와 (6)은 모든 공식 (5)의 루트가 단위 원 밖에 있어야 함을 의미합니다. p 번을 아무리 확장해도 결국 현실 세계에서의 여러 이전 단계들을 생각하는 것이 충분합니다.\n\n## 2.3 이동 평균 (MA) 프로세스\n\n이동 평균(MA) 프로세스는 현재와 이전 충격의 합으로 이루어져 있습니다. MA 프로세스에는 이전 잔차 또는 충격(Uₜ)의 수를 나타내는 순서(order)가 있습니다. 이를 MA(순서)로 표기합니다. 간단히, MA(1) 프로세스를 살펴봅시다. 다음 공식이 MA(1) 프로세스를 나타냅니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Time Series Analysis](/TIL/assets/img/2024-07-09-StatisticsTimeSeriesAnalysisCompilationofthefundamentalconcepts_25.png)\n\nUₜ가 백색 잡음이라고 가정하고, θ₁은 1단계 전 완강을 나타내는 알려지지 않은 파라미터입니다. MA(1) 과정은 백색 잡음으로 구성되어 있기 때문에 평균은 항상 µ입니다. 반면, 분산 및 공분산은 다음과 같이 유도될 수 있습니다:\n\n![Variance and Covariance](/TIL/assets/img/2024-07-09-StatisticsTimeSeriesAnalysisCompilationofthefundamentalconcepts_26.png)\n\n분산은 다음과 같이 유도할 수 있습니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마찬가지로, 공분산을 다음과 같이 유도할 수 있습니다:\n\n![image 1](/TIL/assets/img/2024-07-09-StatisticsTimeSeriesAnalysisCompilationofthefundamentalconcepts_27.png)\n\n화이트 노이즈는 각 변수가 다른 변수와 독립적이라고 가정하므로 이를 취소할 수 있습니다. 따라서 MA(1) 프로세스는 어떤 매개변수 θ₁에 대해서도 약한 정상 프로세스입니다. 이제 시각화를 통해 이를 확인해보겠습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래와 같이 보시다시피, 평균과 분산은 AR(1) 프로세스와 비교했을 때 동일해 보입니다. 파라미터 값이 증가할수록 시리즈가 상대적으로 부드러워집니다. MA(1) 프로세스와 백색 잡음의 분산이 다르다는 점을 참고해 주세요.\n\n일반적으로 MA(q) 프로세스도 약정상태(weak-stationary)입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n평균과 공분산은 다음과 같이 정의할 수 있습니다.\n\n![image](/TIL/assets/img/2024-07-09-StatisticsTimeSeriesAnalysisCompilationofthefundamentalconcepts_31.png)\n\n실제 세계에서는 AR 과정과 같은 몇 가지 이전 단계를 고려하는 것이 충분합니다.\n\n## 2.4 자기회귀 이동평균(ARMA) 과정 및 ARIMA 과정\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n자신의 이름에서 알 수 있듯이 자기회귀 이동 평균(ARMA) 과정은 AR 및 MA 과정을 결합합니다. 직관적으로 ARMA 과정은 서로의 약점을 보완하고 데이터를 더 유연하게 나타낼 수 있습니다. 수학적 표현은 다음과 같습니다:\n\n![ARMA process](/TIL/assets/img/2024-07-09-StatisticsTimeSeriesAnalysisCompilationofthefundamentalconcepts_32.png)\n\n우리는 ARMA 과정을 ARMA(p, q)로 표시합니다. 매개변수 p와 q는 AR 및 MA 과정의 매개변수에 해당합니다. MA 과정은 항상 약한 정상성을 갖기 때문에 ARMA 과정의 약한 정상성은 AR 부분에 따라 달라집니다. 따라서, 식 (14)의 AR 부분이 식 (5)(6)을 만족하면 약한 정상성을 갖습니다.\n\n시각화를 통해 ARMA 과정이 어떻게 보이는지 확인해보겠습니다. AR(p=1, q=1) 과정은 다음과 같이 보입니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAR(p=3, q=2) 프로세스는 아래 그래프와 같이 나타납니다.\n\n![AR(p=3, q=2) graph](/TIL/assets/img/2024-07-09-StatisticsTimeSeriesAnalysisCompilationofthefundamentalconcepts_34.png)\n\n보시다시피, AR 및 MA 프로세스만 사용했을 때보다 더 복잡한 데이터 구조를 잘 파악할 수 있습니다. 매개변수 값이 증가할수록 그래프가 더 부드러워집니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마침내, Autoregressive-integrated-moving average(ARIMA) 프로세스는 ARMA 프로세스와 일부를 공유합니다. 차이점은 ARIMA에 통합된 부분 (I)이 있다는 것입니다. 통합된 부분이란 데이터를 평상태로 만들기 위해 차이를 몇 번 해야 하는지를 의미합니다. 이게 무슨 의미일까요? 먼저, 미분 연산자 ∇를 다음과 같이 정의합니다:\n\n![image](/TIL/assets/img/2024-07-09-StatisticsTimeSeriesAnalysisCompilationofthefundamentalconcepts_35.png)\n\n더 많이 차이를 원할 때, 우리는 반복하여 거듭제곱으로 확장할 수 있습니다:\n\n![image](/TIL/assets/img/2024-07-09-StatisticsTimeSeriesAnalysisCompilationofthefundamentalconcepts_36.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 차이 매개변수를 사용하여 ARIMA(p, d, q) 프로세스를 정의할 수 있습니다.\n\np는 AR 프로세스의 순서이고, d는 차별화를 할 횟수이며, q는 MA 프로세스의 순서입니다. 따라서 데이터를 차별화한 후 ARIMA 프로세스는 ARMA 프로세스가 됩니다. ARIMA 프로세스는 시계열에서 평균이 다른 경우 유용합니다. 즉, 시계열이 정상적이지 않을 때 사용됩니다. AirPassengers 데이터 세트를 기억해 주세요. 이 데이터 세트는 시리즈 전체에서 동일한 평균이 없습니다. 이 시리즈에 nabla를 적용하면 그래프가 다음과 같이 보입니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n오른쪽 그래프의 평균은 왼쪽 그래프의 원본 데이터와 비교하여 시계열에서 안정적으로 보입니다. 이제 미분을 한 후 ARMA 프로세스를 적합시키고 싶습니다. 그러나 문제가 있습니다. 파라미터를 어떻게 정의해야 할까요? 다음과 같은 몇 가지 방법이 있습니다.\n\n- MA 프로세스의 순서(q)를 결정하기 위해 자기상관 함수(ACF) 플롯을 사용하고 AR 프로세스의 순서(p)를 결정하기 위해 부분자기상관 함수(PACF) 플롯을 사용합니다.\n- AIC 또는 BIC를 사용하여 최적의 적합 파라미터를 결정합니다.\n\n첫 번째 방법에 따르면 ACF와 PACF 플롯을 사용하여 MA 및 AR 프로세스의 순서를 결정합니다. PACF도 자기상관이지만 Yₜ와 Yₜ+ₖ 사이의 간접적 상관을 0 `n` k 범위를 통해 제거합니다. 더 자세한 내용은 강의 pdf [5][6]를 참조하실 수 있습니다. 그러나 종종 플롯만으로는 파라미터를 결정할 수 없을 때가 있습니다. 그러므로 두 번째 방법을 사용하는 것을 권장합니다. AIC와 BIC는 다른 모델에 비해 모델 품질을 추정하는 데 사용되는 정보 기준입니다. 라이브러리 pmdarima [7] 덕분에 우리는 위의 정보 기준을 기반으로 최적의 파라미터를 쉽게 찾을 수 있습니다. 예를 들어, AirPassengers 데이터를 추정하기 위해 pmdarima를 사용할 때 결과는 다음과 같습니다.\n\n```js\n# 스텝바이스 자동-ARIMA 적합\narima = pm.auto_arima(y_train, start_p=1, start_q=1,\n                             max_p=3, max_q=3, # m=12,\n                             seasonal=False,\n                             d=d, trace=True,\n                             error_action='ignore',  # 주문이 작동하지 않는 경우 알 필요 없음\n                             suppress_warnings=True,  # 수렴 경고가 없으면 안됨\n                             stepwise=True)  # 스텝바이스로 설정\narima.summary()\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Statistics Time Series Analysis Compilation of the fundamental concepts](/TIL/assets/img/2024-07-09-StatisticsTimeSeriesAnalysisCompilationofthefundamentalconcepts_39.png)\n\n몇 줄만 써도 좋은 품질로 데이터를 맞출 수 있고 예측할 수 있습니다. 게다가, pmdarima는 SARIMA와 같은 고급 모델을 사용하여 시계열을 추정할 수 있습니다. 따라서 pmdarima는 실용적인 사용 사례에서 매우 유용합니다.\n\n## 3. 시계열을 위한 통계 테스트\n\n마지막 섹션에서는 시계열을 위해 사용되는 두 가지 유명한 통계 테스트를 소개하겠습니다. 이러한 테스트는 데이터가 정상 상태인지 또는 잔차 항이 자기상관성을 가지고 있는지 확인하기 위해 자주 사용됩니다. 각 테스트에 들어가기 전에, 단위근이라는 중요한 개념이 있습니다. 시계열에 단위근이 있는 경우 정상 상태가 아닙니다. 따라서 AR(p) 프로세스가 식(5)의 적어도 하나의 근이 1과 같다면, AR(p) 프로세스가 정상 상태가 아님을 의미하므로 AR(p) 프로세스에는 단위근이 있다고 할 수 있습니다. 이 개념을 사용하여 몇 가지 통계 테스트가 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 3.1 Augmented Dickey-Fuller(ADF) test\n\n증강 딕키-풀러(ADF) 검정은 주어진 일변량 시계열에 단위근이 존재하는지를 평가합니다.\n\nADF 검정은 아래의 공식을 사용합니다. 이 공식은 공식(10)에서 유도되었습니다.\n\n![image](/TIL/assets/img/2024-07-09-StatisticsTimeSeriesAnalysisCompilationofthefundamentalconcepts_40.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그럼, 다음은 귀무 가설과 대립 가설을 설정합니다.\n\n![귀무 가설과 대립 가설](/TIL/assets/img/2024-07-09-StatisticsTimeSeriesAnalysisCompilationofthefundamentalconcepts_41.png)\n\n통계량은 다음과 같은 수식입니다.\n\n![통계량 수식](/TIL/assets/img/2024-07-09-StatisticsTimeSeriesAnalysisCompilationofthefundamentalconcepts_42.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n분자가 음수여야만 시계열이 정상 상태일 때입니다. 실제로는, 여러 라이브러리에서 ADF 테스트를 계산할 수 있기 때문에 구현할 필요가 없어요. 아래 예시는 세 가지 시계열 데이터의 예시를 보여줍니다. 왼쪽은 AR(1) 프로세스를 참조하고, 가운데는 MA(1) 프로세스를 참조하며, 마지막은 AirPassenger 데이터셋을 사용합니다. 그래프 제목에는 프로세스 이름과 ADF 테스트의 p-값이 표시됩니다.\n\n![Time Series Example](/TIL/assets/img/2024-07-09-StatisticsTimeSeriesAnalysisCompilationofthefundamentalconcepts_43.png)\n\n정상 데이터인 좌측과 가운데의 데이터는 임계값의 유의수준보다 작아서 귀무가설을 기각할 수 있어요. 이는 데이터가 정상 상태임을 의미해요. 반면에, 비정상 데이터인 우측은 임계값보다 더 유의미하기 때문에 귀무가설을 기각할 수 없어요. 이는 데이터가 정상 상태가 아님이라는 뜻입니다.\n\n## 3.2 Durbin-Watson 테스트\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nDurbin-Watson 테스트는 시계열 회귀 모델의 잔차 항이 자기상관성을 갖고 있는지를 평가합니다. 이를 어떻게 활용할 수 있을까요? 다음과 같은 시계열을 사용하는 회귀 모델을 가정했을 때, 최소자승법을 사용하여 매개변수를 추정할 수 있습니다.\n\n만약 Uₜ가 백색 잡음을 따르지 않는다면, 모델의 품질이 좋지 않을 수 있습니다. Uₜ에 일부 자기상관 또는 연속 상관이 있다고 생각할 여지가 있으며, 이를 모델에 포함해야 합니다. 이를 확인하기 위해 Durbin-Watson 테스트를 사용할 수 있습니다. Durbin-Watson 테스트는 잔차 항이 AR(1) 모델을 가정합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음은 귀무가설과 대립가설을 설정합니다.\n\n![귀무가설 및 대립가설](/TIL/assets/img/2024-07-09-StatisticsTimeSeriesAnalysisCompilationofthefundamentalconcepts_46.png)\n\n우리는 다음과 같은 Durbin-Watson 통계량을 사용합니다.\n\n![Durbin-Watson 통계량](/TIL/assets/img/2024-07-09-StatisticsTimeSeriesAnalysisCompilationofthefundamentalconcepts_47.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 공식은 좀 더 직관적일 수 있습니다. 따라서 바꿔보겠습니다. 우리는 T가 다음과 같은 관계에 충분히 크다고 가정합니다.\n\n![formula_1](/TIL/assets/img/2024-07-09-StatisticsTimeSeriesAnalysisCompilationofthefundamentalconcepts_48.png)\n\n이러한 공식을 사용하여 Durbin-Watson 통계량을 다음과 같이 변환할 수 있습니다.\n\n![formula_2](/TIL/assets/img/2024-07-09-StatisticsTimeSeriesAnalysisCompilationofthefundamentalconcepts_49.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nγ는 적자 순서 자기 상관 관계를 의미합니다. DW 통계량은 자기 상관 관계가 0에 가까울수록 2에 가까워지며, 이는 시계열에 거의 자기 상관 관계가 없음을 의미합니다. 반면, 시계열에 자기 상관 관계가 있는 경우 DW 통계량은 2보다 작아집니다.\n\n![이미지](/TIL/assets/img/2024-07-09-StatisticsTimeSeriesAnalysisCompilationofthefundamentalconcepts_50.png)\n\n섹션 2.4에서 생성한 ARIMA 모델을 사용하여 DW 통계량을 확인해보겠습니다.\n\n```js\nfrom statsmodels.stats.stattools import durbin_watson\n\narima = pm.arima.ARIMA(order=(2,1,2))\narima.fit(y_train)\n\ndw = durbin_watson(arima.resid())\nprint('DW 통계량: ', dw)\n# DW 통계량:  1.6882339836228373\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nDW 통계량은 2보다 작기 때문에 자기상관 또는 연령상관성이 남아 있습니다. 아래 잔차 플롯을 보면 잔차에 여전히 일부 상관 관계가 있음을 알 수 있습니다.\n\n![Residual Plot](/TIL/assets/img/2024-07-09-StatisticsTimeSeriesAnalysisCompilationofthefundamentalconcepts_51.png)\n\n이 경우, 데이터를 올바르게 맞추기 위해 더 고급 모델을 사용해야 합니다. SARIMA, 반복 신경망, prophets 등을 사용할 수 있습니다.\n\n이 블로그에서 결과를 생성하기 위해 아래 코드를 사용했습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 블로그의 끝입니다. 제 블로그를 읽어주셔서 감사합니다!\n\n## 참고 자료\n\n- 統計検定 準一級\n- Wang, D., Lecture Notes, University of South Carolina\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n[3] Buteikis, A., 02 Stationary time series\n\n[4] AirPassengers dataset, kaggle\n\n[5] Eshel, G., The Yule Walker Equations for the AR coefficients\n\n[6] Bartlett, P., Introduction to Time Series Analysis. Lecture 12, Berkeley university\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n[7] pmdarima: Python에서 사용할 수 있는 ARIMA 추정 도구\n","ogImage":{"url":"/assets/img/2024-07-09-StatisticsTimeSeriesAnalysisCompilationofthefundamentalconcepts_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-StatisticsTimeSeriesAnalysisCompilationofthefundamentalconcepts_0.png","tag":["Tech"],"readingTime":28},{"title":"OpenAI와 Google Sheets 통합으로 Slack 봇 만드는 방법","description":"","date":"2024-07-09 18:55","slug":"2024-07-09-BuildingaSlackBotwithOpenAIandGoogleSheetsIntegration","content":"\n이 글에서 OpenAI Assistants의 기능을 활용하고 Google Sheets와 통합하여 사용자 쿼리에 지능적으로 응답하는 Slack 봇을 만드는 방법을 안내할 거에요. 이 봇은 사용자가 어려움을 겪을 때 Slack에서 지원 티켓을 생성할 수도 있어요. 이 튜토리얼을 마치면 Google Sheets 문서에서 관련 정보를 가져와 질문에 답하거나 티켓을 생성할 수 있는 봇을 보유하게 될 거에요.\n\n# 프로젝트 개요\n\n이 프로젝트의 주요 구성 요소는 다음과 같아요:\n\n- app.py: Slack 앱을 초기화하고 수신된 메시지를 처리합니다.\n- assistants.py: OpenAI API와의 상호 작용을 관리하고 사용자 쿼리를 처리합니다.\n- google_sheets_integration.py: Google Sheets를 통합하여 사용자 쿼리에 대한 답변에 필요한 관련 정보를 가져옵니다.\n- create_ticket.py: 특정 Slack 채널에서 지원 티켓을 생성합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n각 구성 요소를 살펴보고 어떻게 작동하여 기능적인 Slack 봇을 만드는지 알아봅시다.\n\n# 단계 1: 환경 설정\n\n먼저, 환경을 설정해야 합니다. 환경 변수를 관리하기 위해 dotenv를 사용할 것입니다. 다음 종속성이 설치되어 있는지 확인해주세요:\n\n![image](/TIL/assets/img/2024-07-09-BuildingaSlackBotwithOpenAIandGoogleSheetsIntegration_0.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAPI 키 및 토큰을 저장하는 .env 파일을 만들어보세요:\n\n![Image](/TIL/assets/img/2024-07-09-BuildingaSlackBotwithOpenAIandGoogleSheetsIntegration_1.png)\n\n# 단계 2: Slack 앱 초기화\n\napp.py 스크립트는 Slack 앱을 초기화하고 수신 메시지를 처리합니다. 이는 OpenAI API를 사용하여 응답을 생성하고 쓰레드 메시지의 컨텍스트를 유지합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Image](/TIL/assets/img/2024-07-09-BuildingaSlackBotwithOpenAIandGoogleSheetsIntegration_2.png)\n\n# 단계 3: OpenAI 통합\n\nassistants.py 스크립트는 OpenAI API와 상호 작용을 관리하고 사용자 쿼리를 처리합니다. Google Sheets 문서에서 정보를 기반으로 응답이 이루어지도록 합니다.\n\n![Image](/TIL/assets/img/2024-07-09-BuildingaSlackBotwithOpenAIandGoogleSheetsIntegration_3.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 단계 4: Google Sheets와 통합하기\n\n구글 시트 통합 스크립트인 google_sheets_integration.py는 사용자 쿼리에 답변하기 위한 관련 정보를 가져 오는 데 Google Sheets와 통합됩니다.\n\n![이미지](/TIL/assets/img/2024-07-09-BuildingaSlackBotwithOpenAIandGoogleSheetsIntegration_4.png)\n\n# 단계 5: 지원 티켓 생성하기\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\ncreate_ticket.py 스크립트는 지정된 Slack 채널에 지원 티켓을 생성합니다.\n\n![ticket image](/TIL/assets/img/2024-07-09-BuildingaSlackBotwithOpenAIandGoogleSheetsIntegration_5.png)\n\n# 마무리\n\n이 가이드를 따라가면, OpenAI 및 Google Sheets와 통합된 Slack 봇을 설정하여 사용자 쿼리에 지능적으로 응답하고 지원 티켓을 생성할 수 있습니다. 이 프로젝트는 다양한 사용 사례에 맞게 확장 및 사용자 정의할 수 있는 기본 기반입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n일부 오류가 발생할 수 있고, 봇을 사용자의 요구에 맞게 맞추기 위해 조정이 필요할 수 있습니다. 그러나 이 구현은 프로젝트에 좋은 출발점을 제공해줄 것입니다. 즐거운 코딩되세요!\n","ogImage":{"url":"/assets/img/2024-07-09-BuildingaSlackBotwithOpenAIandGoogleSheetsIntegration_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-BuildingaSlackBotwithOpenAIandGoogleSheetsIntegration_0.png","tag":["Tech"],"readingTime":4},{"title":"웹 서비스 개발을 위한 언어 선택 가이드","description":"","date":"2024-07-09 15:08","slug":"2024-07-09-Decidingonalanguageforyourwebservice","content":"\nSingularity에서는 주로 웹 서비스에 Python을 사용합니다. 프론트 엔드에서는 Typescript를 사용합니다. 또한 실시간 푸시 서버에는 Elixir를 사용합니다. 최근에 매우 높은 I/O 처리량이 필요한 프로젝트를 시작했는데, Python이 그 사용 사례에서 최선의 도구가 아닐 수도 있다는 걱정이 들었습니다. 그래서 우리는 다음과 같은 질문을 하였습니다:\n\n## 높은 처리량 웹 서비스에 어떤 언어를 사용해야 할까요?\n\n팀 내부의 경험을 기반으로, 우리는 성능을 벤치마킹하고 싶은 몇 가지 후보 언어를 가지고 있었습니다. 팀으로서 우리는 다음을 시험해보기로 결정했습니다:\n\n- NodeJS\n- Java\n- Rust\n- C++\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리는 커뮤니티 지원이 많고 철저한 문서화가 있는 프레임워크와 함께 각 언어를 만들기로 약 2시간을 할애하기로 결정했습니다. 웹 서버들은 PostgreSQL 데이터베이스와 상호 작용하는 도커 컴포즈 네트워크에서 작동할 것입니다. 이 웹 서버들은 ID로 항목을 가져오는 두 가지 Endpoints를 가지게 될 것이며, 페이지/오프셋 매개변수로 항목 목록을 페이징 처리합니다.\n\n## 테스트\n\n실제로 테스트한 언어 및 프레임워크는 다음과 같습니다:\n\n- Python (Flask/SQLAlchemy/psycopg2)\n- NodeJS (express/TypeORM)\n- Rust (Actix Web/tokio_postgres)\n- Async Python (FastAPI/SQLAlchemy/asyncpg)\n- Elixir (Phoenix/Ecto)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리는 C++와 Java도 시도하기로 합의했지만, 심플한 케이스에서도 설정에 어려움을 겪었습니다. 관련 조사를 하는 데 너무 많은 시간이 걸리고, 제가 찾을 수 있는 (공개된) 자료와 커뮤니티 지원이 부족했으며, JSON API → PostgreSQL db 서비스를 짧은 시간에 작동시키지 못했습니다. 나중에 다시 시도해보겠지만, 그 접근의 어려움으로 이번 테스트 세트에 대해 그만두기로 결정했습니다.\n\n나열된 모든 프레임워크와 언어에 대해, 제가 제작한 프로덕션 레디 도커 이미지를 생성하는 데 공식 문서에서 권장하는 방법을 따랐습니다. 그런 다음 나는 이들 이미지를 내 랩탑에서 도커 네트워크에서 컨테이너로 실행했는데, 내 랩탑에는 PostgreSQL 16 도커 컨테이너가 실행 중이어서 모두 같은 데이터베이스에 접근했습니다. 저는 Locust를 사용하여 로컬 환경에서 테스트를 실행했습니다.\n\n이 기사는 각 결과 집합의 이유에 대해서 파헤치지 않을 것입니다. 그렇게 하면 연구와 기사가 훨씬 더 길어질 것입니다. 게다가, 이 연속은 서버의 최고의 IO 처리량을 빨리 배울 수 있는 것이 목적입니다.\n\n각 결과 집합마다, 우리는 동시 사용자 수와 각 프레임워크가 그들을 어떻게 다뤄갔는지 살펴볼 것입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 1,000명 미만의 사용자\n\n각각 1, 10, 100명의 동시 사용자를 대상으로 최대 초당 2개의 요청을 보내는 테스트 세트입니다.\n\nPython\n\n![이미지](/TIL/assets/img/2024-07-09-Decidingonalanguageforyourwebservice_0.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNodeJS\n\n![NodeJS](/TIL/assets/img/2024-07-09-Decidingonalanguageforyourwebservice_1.png)\n\nElixir\n\n![Elixir](/TIL/assets/img/2024-07-09-Decidingonalanguageforyourwebservice_2.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nRust\n\n![Rust](/TIL/assets/img/2024-07-09-Decidingonalanguageforyourwebservice_3.png)\n\nAsync Python\n\n![Async Python](/TIL/assets/img/2024-07-09-Decidingonalanguageforyourwebservice_4.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 세트의 테스트에서 예상한 대로 동작하는 것을 볼 수 있었습니다. 거의 모든 설정이 약 200개의 동시 요청을 그대로 처리하고 제공합니다. 유일한 예외는 async/await 구문을 사용하는 Python입니다. 불행히도, 약 50%의 오류율이 있었습니다. 로그에 기록된 오류를 살펴보면 다음과 같습니다:\n\nsorry, too many clients already\n\n이 오류는 asyncpg 드라이버에서 전파되었습니다. 이 오류를 찾아보니 PostgreSQL db에서 직접 발생한 오류로, 응용 프로그램 코드의 오류가 아니었습니다. 이 설정을 잘 작동하게 하기 위해 몇 가지 조정과 구성 변경을 할 수 있겠지만, 그렇게 하면 연습의 목적을 상실하게 될 것 같습니다.\n\n이후의 모든 테스트에서는 Async Python 설정을 제외하겠습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 1,000 사용자\n\n파이썬\n\n![이미지](/TIL/assets/img/2024-07-09-Decidingonalanguageforyourwebservice_5.png)\n\nNodeJS\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Elixir](/TIL/assets/img/2024-07-09-Decidingonalanguageforyourwebservice_6.png)\n\n![Rust](/TIL/assets/img/2024-07-09-Decidingonalanguageforyourwebservice_7.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/TIL/assets/img/2024-07-09-Decidingonalanguageforyourwebservice_8.png)\n\n여기서는 초당 약 2,000개의 요청에 대한 설정을 유지하도록 요청하고 있습니다. 모든 프레임워크가 이를 처리하는 데 예쁘게 처리하지만 Python은 그렇지 않습니다. Python은 왜 따라잡지 못할까요? 왜 약 200개의 요청/초까지 제한될까요? 제 정확한 설정은 무엇인가요?\n\n모두 좋은 질문이고, 저도 궁금하지만, 이 문제의 요점은 아닙니다. 그러나 오류가 발생하지 않았기 때문에, 제가 마지막 테스트 세트에 Python을 포함시키겠습니다.\n\n## 2,000 사용자\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nPython\n\n![Python image](/TIL/assets/img/2024-07-09-Decidingonalanguageforyourwebservice_9.png)\n\nNodeJS\n\n![NodeJS image](/TIL/assets/img/2024-07-09-Decidingonalanguageforyourwebservice_10.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Elixir\n\n![Elixir](/TIL/assets/img/2024-07-09-Decidingonalanguageforyourwebservice_11.png)\n\n# Rust\n\n![Rust](/TIL/assets/img/2024-07-09-Decidingonalanguageforyourwebservice_12.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기서는 초당 약 4,000개의 요청을 처리할 수 있도록 세팅할 것을 요청하고 있습니다. 이 수준에 도달하려는 모든 프레임워크들이 제대로 따라가기 어려운 것으로 보입니다. 그러나 (Python을 제외한) 모든 세팅이 매우 유사한 동작을 보이는 것으로 보아, 테스트를 실행하는 데 사용하는 노트북에 병목 현상이 있을 수도 있고, 실제 세팅 자체에 병목 현상이 있는 것일 수도 있습니다. 이것이 사실인지 아닌지는 확실하지 않습니다.\n\n# 결론\n\n입출력(IO)이 병목 현상인 고처리량 워크로드에 대해서는, 이러한 세팅 중 어느 것을 선택하고 학습해도 문제가 없어 보입니다. 단, Python을 제외한 모든 것들에 대한 선택을 권합니다.\n\nPython을 사용하길 꺼리지는 않겠습니다. 몇 년간 사용해온 것이며, 설정의 용이성과 문법을 즐기고 있으며, 데이터 분석 및 조작 워크로드에 특히 유용하기 때문에 계속해서 사용할 것입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러나 이 테스트를 실시한 이유는 곧 이전 제품과는 다른 작업량을 갖는 새 제품을 출시할 예정이기 때문입니다. 새 제품을 보다 잘 지원하기 위해 스택을 변경해야 할 지 알아보고 싶었어요.\n\n새 제품이 무엇인지 궁금하신가요? 우리의 스택에 관심이 있으신가요? 결과에 동의하지 않으시나요?\n\n소프트웨어 엔지니어를 채용 중입니다! 메일을 보내서 여러분의 생각을 알려주세요. 의견을 기다리고 있습니다 🌱\n","ogImage":{"url":"/assets/img/2024-07-09-Decidingonalanguageforyourwebservice_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-Decidingonalanguageforyourwebservice_0.png","tag":["Tech"],"readingTime":8},{"title":"파이썬 코딩 시작하기 5 딕셔너리 2부","description":"","date":"2024-07-09 15:07","slug":"2024-07-09-StartCodingwithPython5DictionariespartII","content":"\n\n딕셔너리를 반복하는 방법을 배울 거에요. 딕셔너리는 다양한 방식으로 정보를 저장할 수 있기 때문에, 이를 반복하는 여러 가지 방법이 있어요. 주어진 딕셔너리의 키, 값 또는 모든 키-값 쌍을 반복할 수 있어요.\n\n## 키-값 쌍을 반복하기\n\n세 개의 키-값 쌍을 포함하는 scientist_0 딕셔너리를 고려해봅시다.\n\n```js\n# 파일 이름: scientist.py\n\nscientist_0 = {\n    'username': 'rfeynman',\n    'first name': 'richard',\n    'last name': 'feynman',\n    }\n\nfor key, value in scientist_0.items():\n    print(f\"\\nKey: {key}\")\n    print(f\"Value: {value}\")\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테이블 태그를 Markdown 형식으로 변경해주세요.","ogImage":{"url":"/TIL/assets/no-image.jpg"},"coverImage":"/TIL/assets/no-image.jpg","tag":["Tech"],"readingTime":1},{"title":"초보 때 알았더라면 좋았을 Python 코딩 꿀팁 10가지","description":"","date":"2024-07-09 15:05","slug":"2024-07-09-PythonCodingTipsLessonsIWishIKnewWhenIStartedCoding","content":"\n![Python Coding Tips](/TIL/assets/img/2024-07-09-PythonCodingTipsLessonsIWishIKnewWhenIStartedCoding_0.png)\n\n코딩 여정을 시작할 때 파이썬 세계에 뛰어 들어가면서 약간의 어려움을 겪었어요. 코딩의 기본은 이해했지만, 내 코드를 효율적으로 만드는 방법을 알아내는 것은 퍼즐을 푸는 것처럼 어려웠죠. 예전에는 종종 파이썬의 신이 이끌어 준다는 말을 기억해요 — 정말 좋은 조언이긴 하지만, 내 생각에는 너무 추상적이었어요. 더 구체적인 예시가 필요했고, 그래서 이 가이드를 만들게 되었답니다.\n\n재미있게도, ChatGPT 시대 이후에 코딩을 배우기 시작한 사람들이 어떻게 코딩을 접근하는지에 변화를 주목했어요. ChatGPT 시대에 배운 사람들은 오류 수정과 디버깅에 뛰어나는 것 같아요. 그 반면, GPT 이전에 코딩한 사람들은 답을 분석하고 Stack Overflow나 문서와 같은 자료를 활용하는 데 능숙해요 — 아마도 조금의 복사-붙여넣기 기술도 있겠죠! ;)\n\n![Python Coding Tips](/TIL/assets/img/2024-07-09-PythonCodingTipsLessonsIWishIKnewWhenIStartedCoding_1.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n사진: Kelly Sikkema 님의 Unsplash\n\n저는 Python으로 코딩을 하는 7년 간에 중요한 차이를 만들어 준 몇 가지 개념을 경험해 왔습니다. 이 글에서는 제 경험을 바탕으로 27가지 직관적인 코딩 팁을 공유하고 싶습니다. 이러한 팁들은 제 코딩 속도를 높이는 데 도움이 되었을 뿐만 아니라, 제 코드를 더 깔끔하고 이해하기 쉽게 만들었습니다. 이러한 소중한 팁을 나누는 동안 함께해 주세요. 혹시 당신의 코딩 여정과 맞닿는 팁을 발견할 수도 있을 것입니다!\n\n# 1. F-Strings: 동적 문자열 포맷팅\n\n장점:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 간결하고 읽기 쉬운 구문.\n- 문자열 내부에 쉽게 표현식을 넣을 수 있습니다.\n\n단점:\n\n- Python 3.6 이상에서만 사용 가능합니다.\n- 보안 취약점에 주의해야 합니다; SQL Injection\n\n예시:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nname = \"John\"\nage = 25\nmessage = f\"My name is {name}, and I am {age} years old.\"\n```\n\n## 2. 데코레이터: 기능 동적으로 개선하기\n\n장점:\n\n- 함수의 동작을 확장하는 깔끔한 방법을 제공합니다.\n- 코드 재사용성을 향상시킵니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nCons:\n\n- 데코레이터를 과도하게 사용하면 코드를 이해하기 어렵게 만들 수 있습니다.\n\n예시:\n\n```python\nimport time\ndef timer_decorator(func):\n    def wrapper(*args, **kwargs):\n        start_time = time.time()\n        result = func(*args, **kwargs)\n        end_time = time.time()\n        print(f\"{func.__name__} executed in {end_time - start_time} seconds\")\n        return result\n    return wrapper\n@timer_decorator\ndef example_function():\n    # 함수 로직이 여기에 있습니다\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 3. Python 숙련도 향상을 위한 help() 함수 활용\n\n장점:\n\n- 즉각적인 문서화: 코드 내에서 Python 객체, 모듈 또는 함수에 대한 문서를 빠르게 참조할 수 있습니다.\n- 대화식 학습: Python 인터프리터나 스크립트에서 직접 생소한 모듈이나 함수를 탐색하고 학습하기에 이상적입니다.\n\n단점:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 제한된 정보: help()를 통해 제공되는 정보는 때로 간결할 수 있으며, 복잡한 주제에 대해서는 보다 자세한 문서가 필요할 수 있습니다. help()의 효과는 코드 내 docstrings의 존재와 품질에 따라 달라집니다.\n\n예시:\n\n```js\n# 예시: help() 함수 사용하기\ndef calculate_square(number):\n    \"\"\"\n    주어진 숫자의 제곱을 계산합니다.매개변수:\n    - number (int): 입력 숫자.\n    반환:\n    - int: 입력 숫자의 제곱 값.\n    \"\"\"\n    return number ** 2\n# calculate_square 함수에 대한 도움말 얻기\nhelp(calculate_square)\n```\n\n# 4. List Comprehensions: 간결한 리스트 생성\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n장점:\n\n- 목록 생성 로직을 간결하게 만들어 가독성을 향상시킵니다.\n- 기존 루프와 비교하여 성능을 향상시키는 경우가 많습니다.\n\n단점:\n\n- 특히 복잡한 로직에서는 가독성을 높이기 위해 중첩된 리스트 컴프리헨션을 피해야 합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예시:\n\n```js\n# 범위 내에서 짝수의 제곱값 찾기\nsquares = [x**2 for x in range(10) if x % 2 == 0]\n```\n\n# 5. 루프에서의 else 절\n\n장점:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 루프가 break 문이 없이 자연스럽게 완료될 때 코드를 실행할 수 있습니다.\n- 특정 동작이 성공적인 루프를 따라야 하는 시나리오에 이상적입니다.\n\n단점:\n\n- 종종 간과되거나 오해되어 잠재적인 논리 오류로 이어질 수 있습니다.\n\n예시:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# else 절을 사용하여 소수 찾기\nfor n in range(2, 10):\n    for x in range(2, n):\n        if n % x == 0:\n            break\n    else:\n        print(n, \"은(는) 소수입니다.\")\n```\n\n# 6. 람다 함수: 빠르고 익명의 함수\n\n장점:\n\n- 간단한 함수를 간결하게 한 줄에 작성할 수 있습니다.\n- 형식적인 함수 정의가 필요하지 않습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n단점:\n\n- 단일 표현식에 한정되어 복잡한 논리에 적합하지 않음.\n- 과다 사용 시 코드 가독성을 떨어뜨릴 수 있음.\n\n예시:\n\n```js\n# 람다 함수를 사용하여 두 숫자 더하기\nadd_numbers = lambda x, y: x + y\nresult = add_numbers(3, 5)\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 7. enumerate 및 zip을 활용한 파이썬적인 Iteration\n\n팁: enumerate()와 zip() 함수를 활용하여 시퀀스를 더 파이썬스럽게 반복하세요.\n\n장점:\n\n- enumerate(): 인덱스와 값 모두를 사용하여 반복을 간단하게 만듭니다.\n- zip(): 여러 리스트에 대해 병렬 반복을 용이하게 합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nCons:\n\n- 중요한 단점은 없음; 코드 가독성과 간결함을 향상시킴.\n\n예시:\n\n```python\n# enumerate와 zip을 사용한 Pythonic한 반복\nnames = [\"Alice\", \"Bob\", \"Charlie\"]\nages = [25, 30, 22]\n# 인덱스와 값을 함께 사용하는 Enumerate\nfor index, name in enumerate(names):\n    print(f\"사람 {index + 1}: {name}\")\n# 병렬 반복을 위한 Zip\nfor name, age in zip(names, ages):\n    print(f\"{name}은(는) {age}살입니다.\")\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 8. \\*args 와 \\*\\*kwargs: 유연한 함수 인수\n\n장점:\n\n- 가변 개수의 인수를 처리하는 데 이상적입니다.\n- 다양한 함수와 래퍼를 생성할 수 있습니다.\n\n단점:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 기능 시그니처가 모든 가능한 인수를 나타내지 않을 수 있으므로 주의 깊은 문서화가 필요합니다.\n\n예시:\n\n```js\n# 주어진 모든 인수를 곱하는 함수\ndef multiply(*args):\n    result = 1\n    for num in args:\n        result *= num\n    return result\n```\n\n# 9. try 및 except를 사용한 안정적인 오류 처리\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n장점:\n\n- 오류 내구성: 예기치 못한 오류로 인해 프로그램이 충돌하는 것을 방지합니다.\n- 향상된 디버깅: 무엇이 잘못되었는지에 대한 통찰을 제공하여 효과적인 디버깅을 돕습니다.\n- 사용자 친화적: 사용자에게 구체적인 오류 메시지를 전달하여 더 나은 경험을 제공합니다.\n\n단점:\n\n- 오버헤드: try와 except를 사용할 경우 일부 경우에 약간의 성능 오버헤드가 발생할 수 있습니다.\n- 잠재적인 실수: 오류를 잘못 잡거나 억제하는 경우 근본적인 문제를 숨길 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예시:\n\n```js\n# 예시: graceful try와 except를 활용한 오류 처리\ndef divide_numbers(a, b):\n    try:\n        result = a / b\n        print(f\"{a}를 {b}로 나눈 결과는: {result}\")\n    except ZeroDivisionError:\n        print(\"0으로 나눌 수 없습니다! 0이 아닌 값으로 나누어 주세요.\")\n    except Exception as e:\n        print(f\"예상치 못한 오류가 발생했습니다: {e}\")\n    else:\n        print(\"나눗셈 성공!\")\n# 함수 테스트\ndivide_numbers(10, 2)  # 일반적인 나눗셈\ndivide_numbers(5, 0)   # 0으로 나누기\ndivide_numbers(\"a\", 2) # 예상치 못한 오류 (TypeError)\n```\n\n# 10. 리스트 슬라이싱: 강력하면서 표현력이 있는 사용법\n\n장점:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 하위 목록 추출, 뒤집기, 요소 건너뛰기 등의 작업을 쉽게 수행할 수 있습니다.\n- 코드 가독성을 향상시키고 명시적인 반복문이 필요 없도록 합니다.\n\n단점:\n\n- 복잡한 슬라이싱을 과도하게 사용하면 코드 가독성에 영향을 줄 수 있습니다.\n\n예시:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# 인덱스 2부터 5까지의 서브리스트 추출\noriginal_list = [1, 2, 3, 4, 5, 6, 7]\nsublist = original_list[2:6]\n```\n\n# 11. 제너레이터: 메모리 효율적인 반복\n\n장점:\n\n- 대규모 데이터 세트를 효율적으로 처리합니다.\n- 아이템을 실시간으로 생성하여 메모리를 절약합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n단점:\n\n- 생성기는 일회용 반복자입니다. 한 번 소비되면 재사용할 수 없습니다.\n\n예:\n\n```js\n# 피보나치 수열 생성기\ndef fibonacci(n):\n    a, b = 0, 1\n    for _ in range(n):\n        yield a\n        a, b = b, a + b\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 12. 단언문: 자신감을 가지고 디버깅하기\n\n장점:\n\n- 잠재적 문제를 미리 잡아내어 코드 신뢰성을 향상시킵니다.\n- 코드에 대한 가정을 확인하는 방법을 제공합니다.\n\n단점:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 제품 코드에서 오버 사용하면 성능에 영향을 줄 수 있습니다.\n\n예시:\n\n```js\n# 변수가 양수인지 확인하는 어설션\nnum = -5\nassert num > 0, \"숫자는 양수여야 합니다.\"\n```\n\n# 13. 깊은 복사 vs 얕은 복사: 현명하게 복제하기\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n장점:\n\n- 얕은 복사: 동일한 객체에 대한 참조를 가진 새로운 컬렉션을 생성합니다.\n- 깊은 복사: 원본 객체 및 모든 내용의 독립적인 복제본을 생성합니다.\n\n단점:\n\n- deepcopy가 필요한데 얕은 복사를 사용하면 원본 데이터의 의도치 않은 수정이 발생할 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예시:\n\n```js\n# 중첩된 목록을 얕은 복사와 깊은 복사로 복제하는 방법\nimport copy\noriginal = [[1, 2, 3], [4, 5, 6]]\nshallow = copy.copy(original)\ndeep = copy.deepcopy(original)\n```\n\n# 14. 랜덤 모듈: 예측할 수 없는 것을 환영하세요\n\n장점:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 시뮬레이션, 게임 또는 예측할 수 없는 상황에 유용합니다.\n- 다양한 무작위화 기능을 제공합니다.\n\n단점:\n\n- 결과는 실제로 무작위적이지 않고 의사난수입니다.\n\n예시:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport random\n# 1과 10 사이의 난수 생성\nrandom_number = random.randint(1, 10)\n```\n\n### 15. Defaultdict: 사전 조작 간소화하기\n\n장점:\n\n- 존재하지 않는 키에 대한 기본값을 제공하여 코드를 간소화합니다.\n- 명시적인 키 존재 여부 검사를 없애줍니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nCons:\n\n- collections 모듈을 가져와야 함.\n\n예시:\n\n```python\nfrom collections import defaultdict\nword = \"pythonic\"\nletter_count = defaultdict(int)\nfor letter in word:\n    letter_count[letter] += 1\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 16. 해저 쇠사자 연산자(:=): 효율적인 인라인 할당\n\n장점:\n\n- 효율적으로 값을 할당하고 동일한 표현식 내에서 사용합니다.\n- 특정 조건에서 중복을 줄여줍니다.\n\n단점:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 이를 과도하게 사용하면 연산자에 익숙하지 않은 사람들에게 코드를 읽는 데 어렵게 만들 수 있습니다.\n\n예시:\n\n```js\n# 파일에서 빈 줄을 찾을 때까지 줄을 읽는 방법\nwith open('file.txt', 'r') as f:\n    while (line := f.readline().strip()):\n        print(line)\n```\n\n# 17. 타입 힌팅: 코드 가독성 향상하기\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n장점:\n\n- 코드 가독성과 유지 관리성을 향상시킵니다.\n- 더 나은 IDE 지원 및 정적 유형 검사를 가능하게 합니다.\n\n단점:\n\n- Python은 여전히 동적으로 유형이 할당되는 언어이며, 유형 힌트는 옵션이며 강제되지 않습니다 — 인간 눈을 위한 것이죠 ;) .\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예시:\n\n```js\n# 타입 힌트가 있는 함수\ndef greet(name: str) -> str:\n    return f\"Hello, {name}!\"\n```\n\n# 18. Namedtuples: 스스로 설명하는 데이터 구조\n\n장점:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 가볍고 변경할 수 없는 데이터 구조를 제공합니다.\n- 각 필드에 이름을 지정하여 코드 가독성을 향상시킵니다.\n\n단점:\n\n- 변경할 수 없으며, 생성 후 수정할 수 없습니다.\n- 가변 구조를 위해서는 데이터 클래스를 사용하는 것을 고려해보세요 (Python 3.7+).\n\n예시:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\n# 사람을 위한 namedtuple 만들기\nfrom collections import namedtuple\nPerson = namedtuple('Person', ['name', 'age'])\nalice = Person(name=\"Alice\", age=30)\n```\n\n# 19. 리스트를 병합하고 해제하는 방법: 순차열 결합 및 해제\n\n장점:\n\n- 동시에 여러 리스트를 반복하는 것을 간단하게 만듭니다.\n- 서로 다른 리스트에서 항목을 함께 처리해야 하는 작업에 편리합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n단점:\n\n- zip()은 입력 리스트 중 가장 짧은 곳에서 멈춥니다. 크기가 다른 iterable을 사용할 경우 itertools.zip_longest()을 고려해보세요.\n\n예시:\n\n```js\n# 퀴즈에서 사용자 입력과 해당 답변을 매칭하는 예시\nnames = [\"Alice\", \"Bob\"]\nscores = [85, 92]\nfor name, score in zip(names, scores):\n    print(f\"{name}: {score}\")\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 20. Dictionaries — get()과 setdefault(): 우아한 키 처리\n\n장점:\n\n- get(): 키의 값을 검색하여, 해당 키가 존재하지 않을 경우 기본값을 제공합니다.\n- setdefault(): 키가 존재하지 않을 경우 기본값을 설정하여, 중복된 키 확인을 방지합니다.\n\n단점:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 이러한 방법을 간과하면 중복 코드를 확인하는 데 유용합니다.\n\n예시:\n\n```js\ndata = { name: \"Alice\" };\nage = data.get(\"age\", 30);\ndata.setdefault(\"country\", \"USA\");\n```\n\n# 21. **main** 가드: 스크립트 실행을 제어하기\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n장점:\n\n- 특정 코드가 스크립트가 직접 실행될 때만 실행되고 가져올 때는 실행되지 않도록 보장합니다.\n- 기능으로 가져와서 함수를 사용하거나 작업을 위해 직접 실행할 수 있는 유틸리티 스크립트에 유용합니다.\n\n단점:\n\n- 이 가드를 사용하는 것을 잊으면 모듈이 가져올 때 예기치 않은 동작을 초래할 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예시:\n\n```js\nif __name__ == \"__main__\":\n    print(\"이 스크립트는 직접 실행 중입니다!\")\n```\n\n# 22. 가상 환경: 프로젝트별 개발을 위한 종속성 격리\n\n장점:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 각 프로젝트를 위한 깨끗하고 격리된 환경을 보장합니다.\n- 의존성 관리를 용이하게 하고 충돌을 피할 수 있습니다.\n\nCons:\n\n- 가상 환경을 활성화하는 것을 잊으면 전역 Python 환경에 의도하지 않은 패키지 설치로 이어질 수 있습니다.\n\nExample:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```bash\n# 가상 환경 생성 및 활성화\npython -m venv my_project_env\nsource my_project_env/bin/activate\n```\n\n# 23. 별표 (\\*) 연산자: 다재다능하고 강력함\n\n장점:\n\n- 컬렉션을 각각의 요소로 효율적으로 언패킹한다.\n- 함수 내에서 동적인 인수 처리를 용이하게 한다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n단점:\n\n- 여러번의 언패킹을 연속적으로 사용하는 경우에는 코드 가독성이 감소할 수 있습니다.\n\n예시:\n\n```js\n# 함수에 별도의 인수를 기대하는 동적 목록 값 전달\ndef func(a, b, c):\n    return a + b + c\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nvalues = [1, 2, 3]\nprint(func(*values))\n```\n\n# 24. 컨텍스트 매니저(with 문): 리소스 관리의 간편함\n\n장점:\n\n- 리소스의 적절한 설정 및 해제를 보장합니다.\n- 코드 가독성을 향상시키고 리소스 누수 가능성을 줄입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n단점:\n\n- 유익할 때 with 문을 사용하지 않는 것은 리소스 관련 문제로 이어질 수 있습니다.\n\n예시:\n\n```js\n# 컨텍스트 매니저를 사용하여 파일 열고 읽기\nwith open('file.txt', 'r') as f:\n    content = f.read()\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 25. 파이썬의 언더스코어(\\_) 사용법: 명명과 루프에서의 다재다능함\n\n장점:\n\n- 명명 규칙에서 \"보호된\" 변수를 나타냄.\n- REPL 환경에서 마지막 결과를 재사용함.\n- 루프에서 루프 변수가 필요하지 않을 때 일회용 변수로 작용함.\n\n단점:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 다양한 용도로 사용되면 특히 새로운 코더들에게 혼란스러울 수 있어요.\n\n예시:\n\n```js\n# 루프 카운터가 필요 없는 특정 횟수만큼 반복하기\nfor _ in range(5):\n    print(\"Hello, World!\")\n```\n\n# 26. 맵, 필터 및 리듀스: 파이썬에서의 함수형 프로그래밍\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n장점:\n\n- map(): 컬렉션의 각 항목에 함수를 적용합니다.\n- filter(): 조건에 따라 항목을 선택합니다.\n- reduce(): 함수를 누적적으로 적용하여 시퀀스를 단일 값으로 축소합니다.\n\n단점:\n\n- Python 3.x에서 map()과 filter()는 반복자를 반환하므로 필요하다면 리스트로 변환하세요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예시:\n\n```js\n# map()을 사용하여 문자열을 대문자로 변환하기\nnames = [\"alice\", \"bob\", \"charlie\"]\nupper_names = list(map(str.upper, names))\n```\n\n# 27. 딕셔너리 병합: 딕셔너리 작업을 간단하게 만들기\n\n장점:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 여러 사전의 내용을 결합하는 것을 간편하게 해줍니다.\n- 병합 방법을 선택하는 데 유연성을 제공합니다.\n\n단점:\n\n- 이 접근을 과도하게 사용하면 중첩된 사전을 처리할 때 예상치 못한 결과로 이어질 수 있습니다.\n\n예시:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 딕셔너리를 update() 메서드를 사용하여 병합하기\n\ndict1 = {'a': 1, 'b': 2}\ndict2 = {'b': 3, 'c': 4}\ndict1.update(dict2)\n\n# 축하해요! 마침내 완료했어요!\n\n이 파이썬 코딩 팁을 마무리하며, 여러분은 여러분의 코딩 도구 상자에 유용한 속임수들을 배운 것을 기대합니다. 코딩 전문가이든 초보자이든, 새로운 팁으로 색다르게 유지하는 것은 언제나 좋은 선택입니다. 이것들을 적용해보고, 여러분에게 도움이 되는 것을 확인하고, 여러분의 파이썬 코딩 실력을 조금씩 향상시키는 여정을 즐기세요. 즐거운 코딩 되세요!\n","ogImage":{"url":"/assets/img/2024-07-09-PythonCodingTipsLessonsIWishIKnewWhenIStartedCoding_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-PythonCodingTipsLessonsIWishIKnewWhenIStartedCoding_0.png","tag":["Tech"],"readingTime":25},{"title":"3일차, 4일차  진도가 부족한 이유","description":"","date":"2024-07-09 15:04","slug":"2024-07-09-Day3Day4NotEnoughProgress","content":"\n## 30일 코딩 챌린지\n\n![이미지](/TIL/assets/img/2024-07-09-Day3Day4NotEnoughProgress_0.png)\n\n저의 지역에서 전원 문제가 지속되고 있습니다. 어제인 'Day 3'에 한 일은 이전 날(데이 2의 업데이트를 읽으려면 아래로 스크롤하세요👇)의 온도 변환기를 다듬은 것 뿐입니다.\n\n제게 궁금증을 자아냅니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n어쨌든, 그걸 생각하느라 시간을 낭비하지 말아요. 여기 오늘(4일차)의 내 보고서가 있어요:\n\n이전 날들과는 달리, 오늘은 조직된 계획이 없었어요.\n\nTkinter를 통해 내 온도 변환기의 두 번째 버전을 위한 창을 만들어보려고 했어요.\n\n하지만, 아마도 내 코드에 집중하지 못하고 거의 전혀 진전이 없었어요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이유는요? 다른 급한 일이 더 많아서 그래요.\n\n그래서, 음, 오늘은 지금까지 최악의 날이었어요.\n\n그리고 그 이유는 프로젝트를 진행하기 위한 수단과 의지가 있었는데도 집중할 수 없었기 때문이에요. 충분한 양을 처리하지 못하는 것 같아요.\n\n어쨌든, IDE를 열고 어제보다 더 많은 시간을 프로젝트에 쏟은 사실을 고려하면 오늘을 \"완료\"로 표시할 수 있어요.\n","ogImage":{"url":"/assets/img/2024-07-09-Day3Day4NotEnoughProgress_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-Day3Day4NotEnoughProgress_0.png","tag":["Tech"],"readingTime":2}],"page":"21","totalPageCount":34,"totalPageGroupCount":2,"lastPageGroup":14,"currentPageGroup":1},"__N_SSG":true}