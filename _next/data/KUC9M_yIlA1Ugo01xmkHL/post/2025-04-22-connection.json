{"pageProps":{"post":{"title":"Next.js 15에서 Connection 관리하는 방법","description":"","date":"2025-04-22 02:59","slug":"2025-04-22-connection","content":"\n# connection 함수 살펴보기\n\n오늘은 Next.js에서 제공하는 `connection()` 함수에 대해 이야기해볼게요. 이 함수는 이름만 들으면 네트워크 연결처럼 느껴지지만, 실제로는 렌더링 시점을 제어하는 역할을 한답니다.\n\n## connection() 함수가 뭐예요?\n\n쉽게 말해, `connection()` 함수는 렌더링을 잠시 멈췄다가 **유저의 요청이 들어올 때까지 기다렸다가** 렌더링을 계속하도록 해줘요.\n\n왜 이런 기능이 필요하냐고요? 보통 컴포넌트들은 프리렌더링(빌드 타임에 미리 화면을 만들어두는 것)을 하거든요. 그런데 우리가 원하는 건 프리렌더링이 아니라, **실시간으로 변화하는 값**을 화면에 보여주는 거라면 다르게 처리해야 해요.\n\n예를 들면 `Math.random()`이나 `new Date()`처럼 매번 다른 결과를 내는 값들이 그러하죠. 이런 값들은 빌드할 때 계산해버리면, 그 결과가 계속 고정되어 버리잖아요? 그래서 유저가 접속할 때마다 새로 계산해서 보여줘야 하는 경우가 있어요.\n\n이럴 때 `connection()` 함수를 쓰면, 빌드 타임에 렌더링하는 대신 유저 요청 시점에 렌더링하도록 하는 거죠.\n\n## 간단한 예제 코드\n\n```jsx\nimport { connection } from \"next/server\";\n\nexport default async function Page() {\n  await connection();\n  // 이 아래에서 작성한 코드는 빌드 시점이 아니라,\n  // 실제 요청이 들어올 때 실행돼요!\n  const rand = Math.random();\n  return <span>{rand}</span>;\n}\n```\n\n보시면 `await connection()`을 호출하는 순간부터 아래 코드는 빌드 타임에 무시되고, 유저가 페이지를 요청했을 때 실행된답니다.\n\n## 이런 점도 알아두면 좋아요!\n\n- `connection()`은 서버에서만 동작해요. 그래서 클라이언트 쪽 코드에서는 사용할 수 없고, 주로 서버 컴포넌트 안에서 써요.\n- 프리렌더링을 완전히 안 하니까, 렌더링 속도는 약간 느릴 수 있어요. 그러니 꼭 필요할 때만 사용하는 게 좋아요.\n- `connection()` 없이도 `force-dynamic` 같은 옵션으로도 비슷한 효과를 낼 수 있는데, 사용 의도에 따라 적절하게 선택하면 돼요.\n\n## 마무리\n\n정리하자면, `connection()`은 **빌드 타임이 아닌 요청 시점에 렌더링을 하도록 만들어주는 함수**에요. 그래서 동적인 데이터를 실시간에 가깝게 보여야 할 때 정말 유용하답니다.\n\nNext.js를 쓸 때 이 함수가 왜 필요한지, 어떻게 쓰는지 이해하면 좀 더 유연한 서버 컴포넌트를 만들 수 있어요. 나중에 실시간 데이터 처리 혹은 매번 변하는 값을 렌더링해야 할 때 한 번 써보면 좋겠습니다!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 참고 자료\n\n### 함수 타입\n\n```js\nfunction connection(): Promise<void>\n```\n\n### 파라미터\n\n이 함수는 딱히 파라미터를 받지 않아요. 그냥 연결을 시도하고, 연결이 성공하면 `Promise`가 해결되고, 실패하면 에러가 발생하는 구조입니다.\n\n---\n\n함수 이름인 `connection`으로 봤을 때, 아마도 데이터베이스 연결이나 네트워크 연결 같은 걸 담당하는 함수가 아닐까 싶은데요. 실제로 이런 함수는 비동기 작업이 많기 때문에 `Promise<void>`를 반환하는 게 일반적입니다.\n\n`Promise<void>`라는 건, 작업이 성공적으로 끝나면 별다른 값을 반환하지 않는다는 뜻이에요. 그래서 이 함수를 사용할 때는 `await connection()` 처럼 쓰거나, `.then()`을 사용해서 연결이 끝난 후에 실행할 코드를 작성하면 됩니다.\n\n```js\nasync function initApp() {\n  try {\n    await connection();\n    console.log(\"연결 완료!\");\n  } catch (error) {\n    console.error(\"연결 실패:\", error);\n  }\n}\n```\n\n연결이 성공했는지 여부에 따라서 애플리케이션 로직이 달라질 수 있기 때문에, 꼭 `try-catch` 문이나 `.catch()`를 활용해 에러 처리를 해주시는 게 좋아요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 이 함수는 어떠한 매개변수도 받지 않습니다.\n\n### 반환 값\n\n- 함수는 void를 반환하는 Promise를 리턴합니다. 즉, 호출자가 결과 값을 활용하도록 설계된 함수가 아니에요.\n\n## 알아두면 좋은 점\n\n이런 타입의 함수는 보통 내부에서 비동기 작업을 처리하지만, 결과를 직접적으로 반환하거나 전달하지 않고 그냥 처리만 하고 끝나는 경우에 많이 쓰여요. 예를 들어 로그를 저장하거나, 캐시를 비우는 작업처럼 \"결과가 있으면 좋지만 없어도 되는\" 경우에요.\n\n만약 함수의 처리가 실패할 수 있다면, Promise를 리턴하니 async/await나 then/catch로 에러를 잡아주는 걸 잊지 마세요! 그래야 앱이 예기치 않게 멈추는 걸 막을 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- connection이 unstable_noStore를 대체해서, 앞으로 Next.js의 방향에 더 잘 맞게 업데이트되었어요.\n- 이 함수는 동적 렌더링이 꼭 필요할 때만 사용하면 되며, 일반적인 Dynamic API들을 사용할 경우에는 필요하지 않아요.\n\n### 버전 히스토리\n\n| 버전         | 변경사항                 |\n| ------------ | ------------------------ |\n| `v15.0.0`    | `connection`가 안정화됨. |\n| `v15.0.0-RC` | `connection` 도입됨.     |\n\n참고로, Next.js가 점점 더 SSR(서버 사이드 렌더링)과 SSG(정적 사이트 생성)을 효율적으로 처리할 수 있도록 많은 개선을 하고 있어서, 이런 함수들이 안정화되는 게 개발자 입장에서 꽤 반가운 소식이에요. 특히 동적 콘텐츠를 다룰 때 성능과 안정성을 높이는 데 도움이 된답니다!\n","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":4},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<h1>connection 함수 살펴보기</h1>\n<p>오늘은 Next.js에서 제공하는 <code>connection()</code> 함수에 대해 이야기해볼게요. 이 함수는 이름만 들으면 네트워크 연결처럼 느껴지지만, 실제로는 렌더링 시점을 제어하는 역할을 한답니다.</p>\n<h2>connection() 함수가 뭐예요?</h2>\n<p>쉽게 말해, <code>connection()</code> 함수는 렌더링을 잠시 멈췄다가 <strong>유저의 요청이 들어올 때까지 기다렸다가</strong> 렌더링을 계속하도록 해줘요.</p>\n<p>왜 이런 기능이 필요하냐고요? 보통 컴포넌트들은 프리렌더링(빌드 타임에 미리 화면을 만들어두는 것)을 하거든요. 그런데 우리가 원하는 건 프리렌더링이 아니라, <strong>실시간으로 변화하는 값</strong>을 화면에 보여주는 거라면 다르게 처리해야 해요.</p>\n<p>예를 들면 <code>Math.random()</code>이나 <code>new Date()</code>처럼 매번 다른 결과를 내는 값들이 그러하죠. 이런 값들은 빌드할 때 계산해버리면, 그 결과가 계속 고정되어 버리잖아요? 그래서 유저가 접속할 때마다 새로 계산해서 보여줘야 하는 경우가 있어요.</p>\n<p>이럴 때 <code>connection()</code> 함수를 쓰면, 빌드 타임에 렌더링하는 대신 유저 요청 시점에 렌더링하도록 하는 거죠.</p>\n<h2>간단한 예제 코드</h2>\n<pre><code class=\"hljs language-jsx\"><span class=\"hljs-keyword\">import</span> { connection } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"next/server\"</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Page</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">connection</span>();\n  <span class=\"hljs-comment\">// 이 아래에서 작성한 코드는 빌드 시점이 아니라,</span>\n  <span class=\"hljs-comment\">// 실제 요청이 들어올 때 실행돼요!</span>\n  <span class=\"hljs-keyword\">const</span> rand = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">random</span>();\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">span</span>></span>{rand}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">span</span>></span></span>;\n}\n</code></pre>\n<p>보시면 <code>await connection()</code>을 호출하는 순간부터 아래 코드는 빌드 타임에 무시되고, 유저가 페이지를 요청했을 때 실행된답니다.</p>\n<h2>이런 점도 알아두면 좋아요!</h2>\n<ul>\n<li><code>connection()</code>은 서버에서만 동작해요. 그래서 클라이언트 쪽 코드에서는 사용할 수 없고, 주로 서버 컴포넌트 안에서 써요.</li>\n<li>프리렌더링을 완전히 안 하니까, 렌더링 속도는 약간 느릴 수 있어요. 그러니 꼭 필요할 때만 사용하는 게 좋아요.</li>\n<li><code>connection()</code> 없이도 <code>force-dynamic</code> 같은 옵션으로도 비슷한 효과를 낼 수 있는데, 사용 의도에 따라 적절하게 선택하면 돼요.</li>\n</ul>\n<h2>마무리</h2>\n<p>정리하자면, <code>connection()</code>은 <strong>빌드 타임이 아닌 요청 시점에 렌더링을 하도록 만들어주는 함수</strong>에요. 그래서 동적인 데이터를 실시간에 가깝게 보여야 할 때 정말 유용하답니다.</p>\n<p>Next.js를 쓸 때 이 함수가 왜 필요한지, 어떻게 쓰는지 이해하면 좀 더 유연한 서버 컴포넌트를 만들 수 있어요. 나중에 실시간 데이터 처리 혹은 매번 변하는 값을 렌더링해야 할 때 한 번 써보면 좋겠습니다!</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h2>참고 자료</h2>\n<h3>함수 타입</h3>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">connection</span>(<span class=\"hljs-params\"></span>): <span class=\"hljs-title class_\">Promise</span>&#x3C;<span class=\"hljs-keyword\">void</span>>\n</code></pre>\n<h3>파라미터</h3>\n<p>이 함수는 딱히 파라미터를 받지 않아요. 그냥 연결을 시도하고, 연결이 성공하면 <code>Promise</code>가 해결되고, 실패하면 에러가 발생하는 구조입니다.</p>\n<hr>\n<p>함수 이름인 <code>connection</code>으로 봤을 때, 아마도 데이터베이스 연결이나 네트워크 연결 같은 걸 담당하는 함수가 아닐까 싶은데요. 실제로 이런 함수는 비동기 작업이 많기 때문에 <code>Promise&#x3C;void></code>를 반환하는 게 일반적입니다.</p>\n<p><code>Promise&#x3C;void></code>라는 건, 작업이 성공적으로 끝나면 별다른 값을 반환하지 않는다는 뜻이에요. 그래서 이 함수를 사용할 때는 <code>await connection()</code> 처럼 쓰거나, <code>.then()</code>을 사용해서 연결이 끝난 후에 실행할 코드를 작성하면 됩니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">initApp</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">try</span> {\n    <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">connection</span>();\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"연결 완료!\"</span>);\n  } <span class=\"hljs-keyword\">catch</span> (error) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">\"연결 실패:\"</span>, error);\n  }\n}\n</code></pre>\n<p>연결이 성공했는지 여부에 따라서 애플리케이션 로직이 달라질 수 있기 때문에, 꼭 <code>try-catch</code> 문이나 <code>.catch()</code>를 활용해 에러 처리를 해주시는 게 좋아요!</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>이 함수는 어떠한 매개변수도 받지 않습니다.</li>\n</ul>\n<h3>반환 값</h3>\n<ul>\n<li>함수는 void를 반환하는 Promise를 리턴합니다. 즉, 호출자가 결과 값을 활용하도록 설계된 함수가 아니에요.</li>\n</ul>\n<h2>알아두면 좋은 점</h2>\n<p>이런 타입의 함수는 보통 내부에서 비동기 작업을 처리하지만, 결과를 직접적으로 반환하거나 전달하지 않고 그냥 처리만 하고 끝나는 경우에 많이 쓰여요. 예를 들어 로그를 저장하거나, 캐시를 비우는 작업처럼 \"결과가 있으면 좋지만 없어도 되는\" 경우에요.</p>\n<p>만약 함수의 처리가 실패할 수 있다면, Promise를 리턴하니 async/await나 then/catch로 에러를 잡아주는 걸 잊지 마세요! 그래야 앱이 예기치 않게 멈추는 걸 막을 수 있습니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>connection이 unstable_noStore를 대체해서, 앞으로 Next.js의 방향에 더 잘 맞게 업데이트되었어요.</li>\n<li>이 함수는 동적 렌더링이 꼭 필요할 때만 사용하면 되며, 일반적인 Dynamic API들을 사용할 경우에는 필요하지 않아요.</li>\n</ul>\n<h3>버전 히스토리</h3>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>버전</th><th>변경사항</th></tr></thead><tbody><tr><td><code>v15.0.0</code></td><td><code>connection</code>가 안정화됨.</td></tr><tr><td><code>v15.0.0-RC</code></td><td><code>connection</code> 도입됨.</td></tr></tbody></table>\n<p>참고로, Next.js가 점점 더 SSR(서버 사이드 렌더링)과 SSG(정적 사이트 생성)을 효율적으로 처리할 수 있도록 많은 개선을 하고 있어서, 이런 함수들이 안정화되는 게 개발자 입장에서 꽤 반가운 소식이에요. 특히 동적 콘텐츠를 다룰 때 성능과 안정성을 높이는 데 도움이 된답니다!</p>\n</body>\n</html>\n"},"__N_SSG":true}