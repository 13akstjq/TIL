{"pageProps":{"post":{"title":"iTransformer 최신 시계열 예측 기법 대공개","description":"","date":"2024-07-09 19:21","slug":"2024-07-09-iTransformerTheLatestBreakthroughinTimeSeriesForecasting","content":"\n![2024-07-09-iTransformerTheLatestBreakthroughinTimeSeriesForecasting](/TIL/assets/img/2024-07-09-iTransformerTheLatestBreakthroughinTimeSeriesForecasting_0.png)\n\n예측 분야에서는 Lag-LLaMA, Time-LLM, Chronos, Moirai와 같은 모델들이 2024년 초부터 제안되어 기초 모델 분야에서 많은 활동을 보이고 있습니다.\n\n그러나 이러한 모델들의 성능은 조금 아쉬운 면이 있습니다 ([재현 가능한 벤치마크를 보려면 여기를 참조하십시오](여기)) 그리고 저는 데이터 특화 모델이 여전히 현재 최적의 해결책이라고 믿습니다.\n\n이에 따라 Transformer 아키텍처가 다양한 형태로 시계열 예측에 적용되어왔으며, PatchTST는 장기 예측에서 최고 수준의 성능을 달성하였습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n도전적인 PatchTST에 이어 2024년 3월에 제안된 iTransformer 모델이 등장했습니다. 논문 \"iTransformer: Inverted Transformers Are Effective for Time Series Forecasting\"에서 소개되었습니다.\n\n이 기사에서는 iTransformer의 놀라운 간단한 개념을 발견하고 그 아키텍처를 탐구합니다. 그런 다음 해당 모델을 소규모 실험에 적용하고 그 성능을 TSMixer, N-HiTS 및 PatchTST와 비교합니다.\n\n더 자세한 내용은 원본 논문을 읽어보세요.\n\n시작해봅시다!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# iTransformer 탐색\n\niTransformer의 아이디어는 바닐라 Transformer 모델이 시간 토큰을 사용한다는 깨달음에서 나왔어요.\n\n이것은 모델이 단일 시간 단계에서 모든 특징을 살펴본다는 것을 의미합니다. 그래서 모델이 한 번에 한 시간 단계씩 살펴볼 때 시간 의존성을 학습하는 것이 어려울 수 있어요.\n\n그 문제에 대한 해결책은 PatchTST 모델과 함께 제안된 패칭이에요. 패칭을 사용하면 토큰화하고 임베딩하기 전에 시간 지점을 단순히 그룹화할 수 있어요. 아래에서 보여준 것처럼요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![iTransformer image 1](/TIL/assets/img/2024-07-09-iTransformerTheLatestBreakthroughinTimeSeriesForecasting_1.png)\n\nIn iTransformer, we push patching to the extreme by simply applying the model on the inverted dimensions.\n\n![iTransformer image 2](/TIL/assets/img/2024-07-09-iTransformerTheLatestBreakthroughinTimeSeriesForecasting_2.png)\n\nIn the figure above, we can see how the iTransformer differs from the vanilla Transformer. Instead of looking at all features at one time step, it looks at one feature across many time steps. This is done simply by inverting the shape of the input.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이렇게하면 어텐션 레이어가 다변량 상관 관계를 학습하고 피드포워드 네트워크가 전체 입력 시퀀스의 표현을 인코딩합니다.\n\niTransformer의 일반 아이디어를 이해했으니, 이제 더 자세히 살펴보겠습니다.\n\n## iTransformer의 아키텍처\n\niTransformer는 2017년에 Attention Is All You Need에서 처음으로 제안된 임베딩, 프로젝션 및 트랜스포머 블록을 사용한 바닐라 인코더-디코더 아키텍처를 채택합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 그림에서 건물 블록들은 동일하지만 기능은 완전히 다르다는 것을 볼 수 있습니다. 좀 더 자세히 살펴보겠습니다.\n\n임베딩 레이어\n\n먼저, 입력 시리즈는 독립적으로 토큰으로 임베딩됩니다. 다시 말해서, 이는 입력의 서브시퀀스를 토큰화하는 대신, 모델이 전체 입력 시퀀스를 토큰화하는 극단적인 경우와 같습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다변량 주의력\n\n그런 다음, 임베딩은 주의층으로 전송되어 다변량 상관 맵을 학습할 것입니다.\n\n이는 역전 모델이 각 특징을 독립된 프로세스로 간주하기 때문에 가능합니다. 이러한 결과로 주의 메커니즘은 특징들 사이의 상관 관계를 학습하게 되며, 이로써 iTransformer는 특히 다변량 예측 작업에 적합합니다.\n\n층 정규화\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n어텐션 레이어의 출력은 정규화 레이어로 전송됩니다.\n\n전통적인 트랜스포머 아키텍처에서는 정규화가 모든 특성에 대해 고정된 타임스탬프에서 이루어집니다. 이는 모델이 쓸모없는 관계를 학습하게 될 수 있는 상호작용 소음을 도입할 수 있습니다. 또한, 지나치게 매끄러운 신호를 초래할 수 있습니다.\n\n반면, iTransformer는 차원을 뒤집으므로 정규화가 타임스탬프를 횡단하여 이루어집니다. 이는 모델이 비정상적인 시계열에 대처하도록 도와주며, 시계열의 소음을 줄여줍니다.\n\n피드포워드 네트워크\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마지막으로, 피드 포워드 네트워크(FFN)는 들어오는 토큰의 깊은 표현을 학습합니다.\n\n다시 말해서, 모양이 반전되어 있기 때문에 다층 퍼셉트론(MLP)은 주기성이나 진폭과 같은 다른 시계열 속성을 학습할 수 있습니다. 이는 MLP 기반 모델(N-BEATS, N-HiTS, TSMixer 등)의 능력을 모방합니다.\n\n프로젝션\n\n여기서 간단히 많은 블록을 쌓는 것으로 이루어진 단계입니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 주의 층\n- 계층 정규화\n- 피드포워드 네트워크\n- 계층 정규화\n\n각 블록은 입력 시리즈의 다른 표현을 학습합니다. 그런 다음, 블록 스택의 출력은 최종 예측을 얻기 위해 선형 투사 단계를 거쳐 전송됩니다.\n\n요약하자면, iTransformer는 새로운 아키텍처가 아니며 Transformer를 새롭게 만들어내지는 않습니다. 단순히 입력의 역된 차원에 Transformer를 적용하여 모델이 다변량 상관 관계를 학습하고 시간적 특성을 포착할 수 있도록 합니다.\n\n이제 iTransformer 모델에 대한 깊은 이해를 갖고 작은 예측 실험에서 적용해 보겠습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# iTransformer를 사용한 예측\n\n이 작은 실험에서는 Creative Commons 라이선스로 공개된 전기 변압기 데이터셋에 iTransformer 모델을 적용합니다.\n\n중국 한 성의 두 지역에서 전기 변압기의 오일 온도를 추적하는 인기 있는 벤치마크 데이터셋입니다. 두 지역 모두 1시간마다 샘플링된 데이터셋을 가지고 있으며, 15분마다 샘플링된 데이터셋이 있어 총 네 개의 데이터셋이 있습니다.\n\niTransformer는 근본적으로 다변량 모델이지만, 우리는 96개의 시간 단계에 걸친 일변량 예측 능력을 테스트합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 실험에 대한 코드는 GitHub에서 확인할 수 있어요.\n\n자, 시작해봅시다!\n\n초기 설정\n\n이 실험에서는 neuralforecast라는 라이브러리를 사용하는데, 이 라이브러리가 딥러닝 방법의 가장 빠르고 직관적인 사용 가능한 구현을 제공한다고 믿습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfrom datasetsforecast.long_horizon import LongHorizon\n\nfrom neuralforecast.core import NeuralForecast\nfrom neuralforecast.models import NHITS, PatchTST, iTransformer, TSMixer\n```\n\n본 글을 작성하는 시점에서 iTransformer가 아직 neuralforecast의 공개 릴리스에 포함되지 않았음을 참고하세요. 즉시 해당 모델에 액세스하려면 다음을 실행하세요:\n\n```js\npip install git+https://github.com/Nixtla/neuralforecast.git\n```\n\n이제 ETT 데이터셋을로드하고, 검증 크기, 테스트 크기, 그리고 주기를 포함하는 함수를 작성해봅시다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ndef load_data(name):\n    if name == \"ettm1\":\n        Y_df, *_ = LongHorizon.load(directory='./', group='ETTm1')\n        Y_df = Y_df[Y_df['unique_id'] == 'OT']\n        Y_df['ds'] = pd.to_datetime(Y_df['ds'])\n        val_size = 11520\n        test_size = 11520\n        freq = '15T'\n    elif name == \"ettm2\":\n        Y_df, *_ = LongHorizon.load(directory='./', group='ETTm2')\n        Y_df = Y_df[Y_df['unique_id'] == 'OT']\n        Y_df['ds'] = pd.to_datetime(Y_df['ds'])\n        val_size = 11520\n        test_size = 11520\n        freq = '15T'\n    elif name == 'etth1':\n        Y_df, *_ = LongHorizon.load(directory='./', group='ETTh1')\n        Y_df['ds'] = pd.to_datetime(Y_df['ds'])\n        val_size = 2880\n        test_size = 2880\n        freq = 'H'\n    elif name == \"etth2\":\n        Y_df, *_ = LongHorizon.load(directory='./', group='ETTh2')\n        Y_df['ds'] = pd.to_datetime(Y_df['ds'])\n        val_size = 2880\n        test_size = 2880\n        freq = 'H'\n\n    return Y_df, val_size, test_size, freq\n```\n\nThe above function conveniently loads the data in the required format for neuralforecast. It includes a unique_id column to identify time series, a ds column for timestamps, and a y column for series values.\n\nPlease note that the validation and test sizes align with standards in the scientific community for publishing research papers.\n\nWe are all set to start training the models.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 훈련 및 예측\n\niTransformer 모델을 훈련시키기 위해서는 단순히 다음을 지정해주면 됩니다:\n\n- 예측 기간\n- 입력 크기\n- 시리즈 수\n\niTransformer가 본질적으로 다변량 모델이기 때문에 모델을 적합할 때 시리즈 수를 지정해야 합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n단변량 시나리오이므로 n_series=1입니다.\n\n```js\niTransformer(\n  (h = horizon),\n  (input_size = 3 * horizon),\n  (n_series = 1),\n  (max_steps = 1000),\n  (early_stop_patience_steps = 3)\n);\n```\n\n위의 코드 블록에서는 최대 학습 단계 수를 지정하고, 과적합을 방지하기 위해 조기 중지를 3번 반복으로 설정합니다.\n\n나머지 모델들에 대해 같은 작업을 수행한 후, 리스트에 넣어줍니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nhorizon = 96;\n\nmodels = [\n  iTransformer(\n    (h = horizon),\n    (input_size = 3 * horizon),\n    (n_series = 1),\n    (max_steps = 1000),\n    (early_stop_patience_steps = 3)\n  ),\n  TSMixer(\n    (h = horizon),\n    (input_size = 3 * horizon),\n    (n_series = 1),\n    (max_steps = 1000),\n    (early_stop_patience_steps = 3)\n  ),\n  NHITS((h = horizon), (input_size = 3 * horizon), (max_steps = 1000), (early_stop_patience_steps = 3)),\n  PatchTST((h = horizon), (input_size = 3 * horizon), (max_steps = 1000), (early_stop_patience_steps = 3)),\n];\n```\n\n좋아요! 이제 우리는 단순히 NeuralForecast 객체를 초기화하면 되는데, 이 객체는 학습, 교차 검증 및 예측을 위한 메서드에 액세스할 수 있게 해줍니다.\n\n```js\nnf = NeuralForecast((models = models), (freq = freq));\nnf_preds = nf.cross_validation((df = Y_df), (val_size = val_size), (test_size = test_size), (n_windows = None));\n```\n\n마지막으로, 우리는 각 모델의 성능을 utilsforecast 라이브러리를 사용하여 평가합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nfrom utilsforecast.losses import mae, mse\nfrom utilsforecast.evaluation import evaluate\n\nettm1_evaluation = evaluate(df=nf_preds, metrics=[mae, mse], models=['iTransformer', 'TSMixer', 'NHITS', 'PatchTST'])\nettm1_evaluation.to_csv('ettm1_results.csv', index=False, header=True)\n```\n\n이 단계는 모든 데이터셋에 대해 반복됩니다. 이 실험을 실행하는 완전한 함수는 아래에 표시됩니다.\n\n```js\nfrom utilsforecast.losses import mae, mse\nfrom utilsforecast.evaluation import evaluate\n\ndatasets = ['ettm1', 'ettm2', 'etth1', 'etth2']\n\nfor dataset in datasets:\n\n    Y_df, val_size, test_size, freq = load_data(dataset)\n\n    horizon = 96\n\n    models = [\n        iTransformer(h=horizon, input_size=3*horizon, n_series=1, max_steps=1000, early_stop_patience_steps=3),\n        TSMixer(h=horizon, input_size=3*horizon, n_series=1, max_steps=1000, early_stop_patience_steps=3),\n        NHITS(h=horizon, input_size=3*horizon, max_steps=1000, early_stop_patience_steps=3),\n        PatchTST(h=horizon, input_size=3*horizon, max_steps=1000, early_stop_patience_steps=3)\n    ]\n\n    nf = NeuralForecast(models=models, freq=freq)\n    nf_preds = nf.cross_validation(df=Y_df, val_size=val_size, test_size=test_size, n_windows=None)\n    nf_preds = nf_preds.reset_index()\n\n    evaluation = evaluate(df=nf_preds, metrics=[mae, mse], models=['iTransformer', 'TSMixer', 'NHITS', 'PatchTST'])\n    evaluation.to_csv(f'{dataset}_results.csv', index=False, header=True)\n```\n\n이 작업을 완료하면 모든 데이터셋에 대해 모든 모델의 예측이 있게 됩니다. 그런 다음 평가로 넘어갈 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 성능 평가\n\n성능 지표를 모두 CSV 파일에 저장했으므로, pandas를 사용하여 이를 읽고 각 모델의 각 데이터셋에 대한 성능을 그릴 수 있습니다.\n\n```python\nfiles = ['etth1_results.csv', 'etth2_results.csv', 'ettm1_results.csv', 'ettm2_results.csv']\ndatasets = ['etth1', 'etth2', 'ettm1', 'ettm2']\n\ndataframes = []\n\nfor file, dataset in zip(files, datasets):\n    df = pd.read_csv(file)\n    df['dataset'] = dataset\n\n    dataframes.append(df)\n\nfull_df = pd.concat(dataframes, ignore_index=True)\nfull_df = full_df.drop(['unique_id'], axis=1)\n```\n\n이후, 지표를 그래프로 그리려면:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndataset_names = full_df['dataset'].unique()\nmodel_names = ['iTransformer', 'TSMixer', 'NHITS', 'PatchTST']\n\nfig, axs = plt.subplots(2, 2, figsize=(15, 15))\nbar_width = 0.35\n\naxs = axs.flatten()\n\nfor i, dataset_name in enumerate(dataset_names):\n    df_subset = full_df[(full_df['dataset'] == dataset_name) & (full_df['metric'] == 'mae')]\n    mae_vals = df_subset[model_names].values.flatten()\n    df_subset = full_df[(full_df['dataset'] == dataset_name) & (full_df['metric'] == 'mse')]\n    mse_vals = df_subset[model_names].values.flatten()\n\n    indices = np.arange(len(model_names))\n\n    bars_mae = axs[i].bar(indices - bar_width / 2, mae_vals, bar_width, color='skyblue', label='MAE')\n    bars_mse = axs[i].bar(indices + bar_width / 2, mse_vals, bar_width, color='orange', label='MSE')\n\n    for bars in [bars_mae, bars_mse]:\n        for bar in bars:\n            height = bar.get_height()\n            axs[i].annotate(f'{height:.2f}',\n                            xy=(bar.get_x() + bar.get_width() / 2, height),\n                            xytext=(0, 3),\n                            textcoords=\"offset points\",\n                            ha='center', va='bottom')\n\n    axs[i].set_xticks(indices)\n    axs[i].set_xticklabels(model_names, rotation=45)\n    axs[i].set_title(dataset_name)\n    axs[i].legend(loc='best')\n\nplt.tight_layout()\n```\n\n![Image](/TIL/assets/img/2024-07-09-iTransformerTheLatestBreakthroughinTimeSeriesForecasting_4.png)\n\nFrom the figure above, we can see that the iTransformer performs fairly well on all datasets, but TSMixer is overall slightly better than iTransformer, and PatchTST is the overall champion model in this experiment.\n\nOf course, keep in mind that we did not leverage the multivariate capabilities of iTransformer, and we only tested on a single forecast horizon. Therefore, it is not a complete assessment of the iTransformer’s performance.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그럼에도 불구하고, 모델이 PatchTST와 매우 유사하게 수행되는 것을 볼 때, Transformer를 사용한 시계열 예측에서 새로운 성능에 도달하는 데 그룹화 시간 단계를 토큰화하기 전에 묶는 아이디어를 더 지원하는 점이 흥미로운 부분입니다.\n\n# 결론\n\niTransformer는 베이닐라 Transformer 아키텍처를 적용한 뒤 입력 시리즈의 역방향 모양으로 그냥 적용합니다.\n\n이렇게 하면 전체 시리즈가 토큰화되고 PatchTST에서 제안한 것과 같이 극단적인 케이스를 모방합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모델이 주의 매커니즘을 사용하여 다변량 상관 관계를 학습하고, 피드포워드 네트워크가 시계열의 시간적 특성을 학습합니다.\n\niTransformer는 많은 벤치마크 데이터셋에서 장기 예측에 대한 최신 기술을 보여주었으며, 우리의 한정된 실험에서는 PatchTST가 전반적으로 가장 우수한 성과를 보였습니다.\n\n모든 문제는 고유한 해결책이 필요하다고 단언합니다. 이제 iTransformer를 도구 상자에 추가하고 여러분의 프로젝트에 적용할 수 있습니다.\n\n읽어 주셔서 감사합니다! 즐겁게 읽으셨기를 바라며 새로운 지식을 얻으셨기를 기대합니다!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만나서 반가워요 🌟\n\n# 저를 지원해주세요\n\n제 작업을 즐기고 계신가요? Buy me a coffee로 제게 지원을 표현해주세요. 여러분의 응원을 받으면 저는 커피 한 잔을 즐길 수 있어요! 만약 그렇게 느끼신다면, 아래 버튼을 클릭해주세요 👇\n\n![Image](/TIL/assets/img/2024-07-09-iTransformerTheLatestBreakthroughinTimeSeriesForecasting_5.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 참고 자료\n\niTransformer: Inverted Transformers Are Effective for Time Series Forecasting by Yong Liu, Tengge Hu, Haoran Zhang, Haixu Wu, Shiyu Wang, Lintao Ma, Mingsheng Long\n","ogImage":{"url":"/assets/img/2024-07-09-iTransformerTheLatestBreakthroughinTimeSeriesForecasting_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-iTransformerTheLatestBreakthroughinTimeSeriesForecasting_0.png","tag":["Tech"],"readingTime":19},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/TIL/assets/img/2024-07-09-iTransformerTheLatestBreakthroughinTimeSeriesForecasting_0.png\" alt=\"2024-07-09-iTransformerTheLatestBreakthroughinTimeSeriesForecasting\"></p>\n<p>예측 분야에서는 Lag-LLaMA, Time-LLM, Chronos, Moirai와 같은 모델들이 2024년 초부터 제안되어 기초 모델 분야에서 많은 활동을 보이고 있습니다.</p>\n<p>그러나 이러한 모델들의 성능은 조금 아쉬운 면이 있습니다 (<a href=\"%EC%97%AC%EA%B8%B0\">재현 가능한 벤치마크를 보려면 여기를 참조하십시오</a>) 그리고 저는 데이터 특화 모델이 여전히 현재 최적의 해결책이라고 믿습니다.</p>\n<p>이에 따라 Transformer 아키텍처가 다양한 형태로 시계열 예측에 적용되어왔으며, PatchTST는 장기 예측에서 최고 수준의 성능을 달성하였습니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>도전적인 PatchTST에 이어 2024년 3월에 제안된 iTransformer 모델이 등장했습니다. 논문 \"iTransformer: Inverted Transformers Are Effective for Time Series Forecasting\"에서 소개되었습니다.</p>\n<p>이 기사에서는 iTransformer의 놀라운 간단한 개념을 발견하고 그 아키텍처를 탐구합니다. 그런 다음 해당 모델을 소규모 실험에 적용하고 그 성능을 TSMixer, N-HiTS 및 PatchTST와 비교합니다.</p>\n<p>더 자세한 내용은 원본 논문을 읽어보세요.</p>\n<p>시작해봅시다!</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h1>iTransformer 탐색</h1>\n<p>iTransformer의 아이디어는 바닐라 Transformer 모델이 시간 토큰을 사용한다는 깨달음에서 나왔어요.</p>\n<p>이것은 모델이 단일 시간 단계에서 모든 특징을 살펴본다는 것을 의미합니다. 그래서 모델이 한 번에 한 시간 단계씩 살펴볼 때 시간 의존성을 학습하는 것이 어려울 수 있어요.</p>\n<p>그 문제에 대한 해결책은 PatchTST 모델과 함께 제안된 패칭이에요. 패칭을 사용하면 토큰화하고 임베딩하기 전에 시간 지점을 단순히 그룹화할 수 있어요. 아래에서 보여준 것처럼요.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p><img src=\"/TIL/assets/img/2024-07-09-iTransformerTheLatestBreakthroughinTimeSeriesForecasting_1.png\" alt=\"iTransformer image 1\"></p>\n<p>In iTransformer, we push patching to the extreme by simply applying the model on the inverted dimensions.</p>\n<p><img src=\"/TIL/assets/img/2024-07-09-iTransformerTheLatestBreakthroughinTimeSeriesForecasting_2.png\" alt=\"iTransformer image 2\"></p>\n<p>In the figure above, we can see how the iTransformer differs from the vanilla Transformer. Instead of looking at all features at one time step, it looks at one feature across many time steps. This is done simply by inverting the shape of the input.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>이렇게하면 어텐션 레이어가 다변량 상관 관계를 학습하고 피드포워드 네트워크가 전체 입력 시퀀스의 표현을 인코딩합니다.</p>\n<p>iTransformer의 일반 아이디어를 이해했으니, 이제 더 자세히 살펴보겠습니다.</p>\n<h2>iTransformer의 아키텍처</h2>\n<p>iTransformer는 2017년에 Attention Is All You Need에서 처음으로 제안된 임베딩, 프로젝션 및 트랜스포머 블록을 사용한 바닐라 인코더-디코더 아키텍처를 채택합니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>위의 그림에서 건물 블록들은 동일하지만 기능은 완전히 다르다는 것을 볼 수 있습니다. 좀 더 자세히 살펴보겠습니다.</p>\n<p>임베딩 레이어</p>\n<p>먼저, 입력 시리즈는 독립적으로 토큰으로 임베딩됩니다. 다시 말해서, 이는 입력의 서브시퀀스를 토큰화하는 대신, 모델이 전체 입력 시퀀스를 토큰화하는 극단적인 경우와 같습니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>다변량 주의력</p>\n<p>그런 다음, 임베딩은 주의층으로 전송되어 다변량 상관 맵을 학습할 것입니다.</p>\n<p>이는 역전 모델이 각 특징을 독립된 프로세스로 간주하기 때문에 가능합니다. 이러한 결과로 주의 메커니즘은 특징들 사이의 상관 관계를 학습하게 되며, 이로써 iTransformer는 특히 다변량 예측 작업에 적합합니다.</p>\n<p>층 정규화</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>어텐션 레이어의 출력은 정규화 레이어로 전송됩니다.</p>\n<p>전통적인 트랜스포머 아키텍처에서는 정규화가 모든 특성에 대해 고정된 타임스탬프에서 이루어집니다. 이는 모델이 쓸모없는 관계를 학습하게 될 수 있는 상호작용 소음을 도입할 수 있습니다. 또한, 지나치게 매끄러운 신호를 초래할 수 있습니다.</p>\n<p>반면, iTransformer는 차원을 뒤집으므로 정규화가 타임스탬프를 횡단하여 이루어집니다. 이는 모델이 비정상적인 시계열에 대처하도록 도와주며, 시계열의 소음을 줄여줍니다.</p>\n<p>피드포워드 네트워크</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>마지막으로, 피드 포워드 네트워크(FFN)는 들어오는 토큰의 깊은 표현을 학습합니다.</p>\n<p>다시 말해서, 모양이 반전되어 있기 때문에 다층 퍼셉트론(MLP)은 주기성이나 진폭과 같은 다른 시계열 속성을 학습할 수 있습니다. 이는 MLP 기반 모델(N-BEATS, N-HiTS, TSMixer 등)의 능력을 모방합니다.</p>\n<p>프로젝션</p>\n<p>여기서 간단히 많은 블록을 쌓는 것으로 이루어진 단계입니다:</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>주의 층</li>\n<li>계층 정규화</li>\n<li>피드포워드 네트워크</li>\n<li>계층 정규화</li>\n</ul>\n<p>각 블록은 입력 시리즈의 다른 표현을 학습합니다. 그런 다음, 블록 스택의 출력은 최종 예측을 얻기 위해 선형 투사 단계를 거쳐 전송됩니다.</p>\n<p>요약하자면, iTransformer는 새로운 아키텍처가 아니며 Transformer를 새롭게 만들어내지는 않습니다. 단순히 입력의 역된 차원에 Transformer를 적용하여 모델이 다변량 상관 관계를 학습하고 시간적 특성을 포착할 수 있도록 합니다.</p>\n<p>이제 iTransformer 모델에 대한 깊은 이해를 갖고 작은 예측 실험에서 적용해 보겠습니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h1>iTransformer를 사용한 예측</h1>\n<p>이 작은 실험에서는 Creative Commons 라이선스로 공개된 전기 변압기 데이터셋에 iTransformer 모델을 적용합니다.</p>\n<p>중국 한 성의 두 지역에서 전기 변압기의 오일 온도를 추적하는 인기 있는 벤치마크 데이터셋입니다. 두 지역 모두 1시간마다 샘플링된 데이터셋을 가지고 있으며, 15분마다 샘플링된 데이터셋이 있어 총 네 개의 데이터셋이 있습니다.</p>\n<p>iTransformer는 근본적으로 다변량 모델이지만, 우리는 96개의 시간 단계에 걸친 일변량 예측 능력을 테스트합니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>이 실험에 대한 코드는 GitHub에서 확인할 수 있어요.</p>\n<p>자, 시작해봅시다!</p>\n<p>초기 설정</p>\n<p>이 실험에서는 neuralforecast라는 라이브러리를 사용하는데, 이 라이브러리가 딥러닝 방법의 가장 빠르고 직관적인 사용 가능한 구현을 제공한다고 믿습니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd\n<span class=\"hljs-keyword\">import</span> numpy <span class=\"hljs-keyword\">as</span> np\n<span class=\"hljs-keyword\">import</span> matplotlib.<span class=\"hljs-property\">pyplot</span> <span class=\"hljs-keyword\">as</span> plt\n\n<span class=\"hljs-keyword\">from</span> datasetsforecast.<span class=\"hljs-property\">long_horizon</span> <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">LongHorizon</span>\n\n<span class=\"hljs-keyword\">from</span> neuralforecast.<span class=\"hljs-property\">core</span> <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">NeuralForecast</span>\n<span class=\"hljs-keyword\">from</span> neuralforecast.<span class=\"hljs-property\">models</span> <span class=\"hljs-keyword\">import</span> <span class=\"hljs-variable constant_\">NHITS</span>, <span class=\"hljs-title class_\">PatchTST</span>, iTransformer, <span class=\"hljs-title class_\">TSMixer</span>\n</code></pre>\n<p>본 글을 작성하는 시점에서 iTransformer가 아직 neuralforecast의 공개 릴리스에 포함되지 않았음을 참고하세요. 즉시 해당 모델에 액세스하려면 다음을 실행하세요:</p>\n<pre><code class=\"hljs language-js\">pip install git+<span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//github.com/Nixtla/neuralforecast.git</span>\n</code></pre>\n<p>이제 ETT 데이터셋을로드하고, 검증 크기, 테스트 크기, 그리고 주기를 포함하는 함수를 작성해봅시다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\">def <span class=\"hljs-title function_\">load_data</span>(name):\n    <span class=\"hljs-keyword\">if</span> name == <span class=\"hljs-string\">\"ettm1\"</span>:\n        Y_df, *_ = <span class=\"hljs-title class_\">LongHorizon</span>.<span class=\"hljs-title function_\">load</span>(directory=<span class=\"hljs-string\">'./'</span>, group=<span class=\"hljs-string\">'ETTm1'</span>)\n        Y_df = Y_df[Y_df[<span class=\"hljs-string\">'unique_id'</span>] == <span class=\"hljs-string\">'OT'</span>]\n        Y_df[<span class=\"hljs-string\">'ds'</span>] = pd.<span class=\"hljs-title function_\">to_datetime</span>(Y_df[<span class=\"hljs-string\">'ds'</span>])\n        val_size = <span class=\"hljs-number\">11520</span>\n        test_size = <span class=\"hljs-number\">11520</span>\n        freq = <span class=\"hljs-string\">'15T'</span>\n    elif name == <span class=\"hljs-string\">\"ettm2\"</span>:\n        Y_df, *_ = <span class=\"hljs-title class_\">LongHorizon</span>.<span class=\"hljs-title function_\">load</span>(directory=<span class=\"hljs-string\">'./'</span>, group=<span class=\"hljs-string\">'ETTm2'</span>)\n        Y_df = Y_df[Y_df[<span class=\"hljs-string\">'unique_id'</span>] == <span class=\"hljs-string\">'OT'</span>]\n        Y_df[<span class=\"hljs-string\">'ds'</span>] = pd.<span class=\"hljs-title function_\">to_datetime</span>(Y_df[<span class=\"hljs-string\">'ds'</span>])\n        val_size = <span class=\"hljs-number\">11520</span>\n        test_size = <span class=\"hljs-number\">11520</span>\n        freq = <span class=\"hljs-string\">'15T'</span>\n    elif name == <span class=\"hljs-string\">'etth1'</span>:\n        Y_df, *_ = <span class=\"hljs-title class_\">LongHorizon</span>.<span class=\"hljs-title function_\">load</span>(directory=<span class=\"hljs-string\">'./'</span>, group=<span class=\"hljs-string\">'ETTh1'</span>)\n        Y_df[<span class=\"hljs-string\">'ds'</span>] = pd.<span class=\"hljs-title function_\">to_datetime</span>(Y_df[<span class=\"hljs-string\">'ds'</span>])\n        val_size = <span class=\"hljs-number\">2880</span>\n        test_size = <span class=\"hljs-number\">2880</span>\n        freq = <span class=\"hljs-string\">'H'</span>\n    elif name == <span class=\"hljs-string\">\"etth2\"</span>:\n        Y_df, *_ = <span class=\"hljs-title class_\">LongHorizon</span>.<span class=\"hljs-title function_\">load</span>(directory=<span class=\"hljs-string\">'./'</span>, group=<span class=\"hljs-string\">'ETTh2'</span>)\n        Y_df[<span class=\"hljs-string\">'ds'</span>] = pd.<span class=\"hljs-title function_\">to_datetime</span>(Y_df[<span class=\"hljs-string\">'ds'</span>])\n        val_size = <span class=\"hljs-number\">2880</span>\n        test_size = <span class=\"hljs-number\">2880</span>\n        freq = <span class=\"hljs-string\">'H'</span>\n\n    <span class=\"hljs-keyword\">return</span> Y_df, val_size, test_size, freq\n</code></pre>\n<p>The above function conveniently loads the data in the required format for neuralforecast. It includes a unique_id column to identify time series, a ds column for timestamps, and a y column for series values.</p>\n<p>Please note that the validation and test sizes align with standards in the scientific community for publishing research papers.</p>\n<p>We are all set to start training the models.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h2>훈련 및 예측</h2>\n<p>iTransformer 모델을 훈련시키기 위해서는 단순히 다음을 지정해주면 됩니다:</p>\n<ul>\n<li>예측 기간</li>\n<li>입력 크기</li>\n<li>시리즈 수</li>\n</ul>\n<p>iTransformer가 본질적으로 다변량 모델이기 때문에 모델을 적합할 때 시리즈 수를 지정해야 합니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>단변량 시나리오이므로 n_series=1입니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">iTransformer</span>(\n  (h = horizon),\n  (input_size = <span class=\"hljs-number\">3</span> * horizon),\n  (n_series = <span class=\"hljs-number\">1</span>),\n  (max_steps = <span class=\"hljs-number\">1000</span>),\n  (early_stop_patience_steps = <span class=\"hljs-number\">3</span>)\n);\n</code></pre>\n<p>위의 코드 블록에서는 최대 학습 단계 수를 지정하고, 과적합을 방지하기 위해 조기 중지를 3번 반복으로 설정합니다.</p>\n<p>나머지 모델들에 대해 같은 작업을 수행한 후, 리스트에 넣어줍니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\">horizon = <span class=\"hljs-number\">96</span>;\n\nmodels = [\n  <span class=\"hljs-title function_\">iTransformer</span>(\n    (h = horizon),\n    (input_size = <span class=\"hljs-number\">3</span> * horizon),\n    (n_series = <span class=\"hljs-number\">1</span>),\n    (max_steps = <span class=\"hljs-number\">1000</span>),\n    (early_stop_patience_steps = <span class=\"hljs-number\">3</span>)\n  ),\n  <span class=\"hljs-title class_\">TSMixer</span>(\n    (h = horizon),\n    (input_size = <span class=\"hljs-number\">3</span> * horizon),\n    (n_series = <span class=\"hljs-number\">1</span>),\n    (max_steps = <span class=\"hljs-number\">1000</span>),\n    (early_stop_patience_steps = <span class=\"hljs-number\">3</span>)\n  ),\n  <span class=\"hljs-title function_\">NHITS</span>((h = horizon), (input_size = <span class=\"hljs-number\">3</span> * horizon), (max_steps = <span class=\"hljs-number\">1000</span>), (early_stop_patience_steps = <span class=\"hljs-number\">3</span>)),\n  <span class=\"hljs-title class_\">PatchTST</span>((h = horizon), (input_size = <span class=\"hljs-number\">3</span> * horizon), (max_steps = <span class=\"hljs-number\">1000</span>), (early_stop_patience_steps = <span class=\"hljs-number\">3</span>)),\n];\n</code></pre>\n<p>좋아요! 이제 우리는 단순히 NeuralForecast 객체를 초기화하면 되는데, 이 객체는 학습, 교차 검증 및 예측을 위한 메서드에 액세스할 수 있게 해줍니다.</p>\n<pre><code class=\"hljs language-js\">nf = <span class=\"hljs-title class_\">NeuralForecast</span>((models = models), (freq = freq));\nnf_preds = nf.<span class=\"hljs-title function_\">cross_validation</span>((df = Y_df), (val_size = val_size), (test_size = test_size), (n_windows = <span class=\"hljs-title class_\">None</span>));\n</code></pre>\n<p>마지막으로, 우리는 각 모델의 성능을 utilsforecast 라이브러리를 사용하여 평가합니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">from</span> utilsforecast.<span class=\"hljs-property\">losses</span> <span class=\"hljs-keyword\">import</span> mae, mse\n<span class=\"hljs-keyword\">from</span> utilsforecast.<span class=\"hljs-property\">evaluation</span> <span class=\"hljs-keyword\">import</span> evaluate\n\nettm1_evaluation = evaluate(df=nf_preds, metrics=[mae, mse], models=[<span class=\"hljs-string\">'iTransformer'</span>, <span class=\"hljs-string\">'TSMixer'</span>, <span class=\"hljs-string\">'NHITS'</span>, <span class=\"hljs-string\">'PatchTST'</span>])\nettm1_evaluation.<span class=\"hljs-title function_\">to_csv</span>(<span class=\"hljs-string\">'ettm1_results.csv'</span>, index=<span class=\"hljs-title class_\">False</span>, header=<span class=\"hljs-title class_\">True</span>)\n</code></pre>\n<p>이 단계는 모든 데이터셋에 대해 반복됩니다. 이 실험을 실행하는 완전한 함수는 아래에 표시됩니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">from</span> utilsforecast.<span class=\"hljs-property\">losses</span> <span class=\"hljs-keyword\">import</span> mae, mse\n<span class=\"hljs-keyword\">from</span> utilsforecast.<span class=\"hljs-property\">evaluation</span> <span class=\"hljs-keyword\">import</span> evaluate\n\ndatasets = [<span class=\"hljs-string\">'ettm1'</span>, <span class=\"hljs-string\">'ettm2'</span>, <span class=\"hljs-string\">'etth1'</span>, <span class=\"hljs-string\">'etth2'</span>]\n\n<span class=\"hljs-keyword\">for</span> dataset <span class=\"hljs-keyword\">in</span> <span class=\"hljs-attr\">datasets</span>:\n\n    Y_df, val_size, test_size, freq = <span class=\"hljs-title function_\">load_data</span>(dataset)\n\n    horizon = <span class=\"hljs-number\">96</span>\n\n    models = [\n        <span class=\"hljs-title function_\">iTransformer</span>(h=horizon, input_size=<span class=\"hljs-number\">3</span>*horizon, n_series=<span class=\"hljs-number\">1</span>, max_steps=<span class=\"hljs-number\">1000</span>, early_stop_patience_steps=<span class=\"hljs-number\">3</span>),\n        <span class=\"hljs-title class_\">TSMixer</span>(h=horizon, input_size=<span class=\"hljs-number\">3</span>*horizon, n_series=<span class=\"hljs-number\">1</span>, max_steps=<span class=\"hljs-number\">1000</span>, early_stop_patience_steps=<span class=\"hljs-number\">3</span>),\n        <span class=\"hljs-title function_\">NHITS</span>(h=horizon, input_size=<span class=\"hljs-number\">3</span>*horizon, max_steps=<span class=\"hljs-number\">1000</span>, early_stop_patience_steps=<span class=\"hljs-number\">3</span>),\n        <span class=\"hljs-title class_\">PatchTST</span>(h=horizon, input_size=<span class=\"hljs-number\">3</span>*horizon, max_steps=<span class=\"hljs-number\">1000</span>, early_stop_patience_steps=<span class=\"hljs-number\">3</span>)\n    ]\n\n    nf = <span class=\"hljs-title class_\">NeuralForecast</span>(models=models, freq=freq)\n    nf_preds = nf.<span class=\"hljs-title function_\">cross_validation</span>(df=Y_df, val_size=val_size, test_size=test_size, n_windows=<span class=\"hljs-title class_\">None</span>)\n    nf_preds = nf_preds.<span class=\"hljs-title function_\">reset_index</span>()\n\n    evaluation = evaluate(df=nf_preds, metrics=[mae, mse], models=[<span class=\"hljs-string\">'iTransformer'</span>, <span class=\"hljs-string\">'TSMixer'</span>, <span class=\"hljs-string\">'NHITS'</span>, <span class=\"hljs-string\">'PatchTST'</span>])\n    evaluation.<span class=\"hljs-title function_\">to_csv</span>(f<span class=\"hljs-string\">'{dataset}_results.csv'</span>, index=<span class=\"hljs-title class_\">False</span>, header=<span class=\"hljs-title class_\">True</span>)\n</code></pre>\n<p>이 작업을 완료하면 모든 데이터셋에 대해 모든 모델의 예측이 있게 됩니다. 그런 다음 평가로 넘어갈 수 있습니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h2>성능 평가</h2>\n<p>성능 지표를 모두 CSV 파일에 저장했으므로, pandas를 사용하여 이를 읽고 각 모델의 각 데이터셋에 대한 성능을 그릴 수 있습니다.</p>\n<pre><code class=\"hljs language-python\">files = [<span class=\"hljs-string\">'etth1_results.csv'</span>, <span class=\"hljs-string\">'etth2_results.csv'</span>, <span class=\"hljs-string\">'ettm1_results.csv'</span>, <span class=\"hljs-string\">'ettm2_results.csv'</span>]\ndatasets = [<span class=\"hljs-string\">'etth1'</span>, <span class=\"hljs-string\">'etth2'</span>, <span class=\"hljs-string\">'ettm1'</span>, <span class=\"hljs-string\">'ettm2'</span>]\n\ndataframes = []\n\n<span class=\"hljs-keyword\">for</span> file, dataset <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">zip</span>(files, datasets):\n    df = pd.read_csv(file)\n    df[<span class=\"hljs-string\">'dataset'</span>] = dataset\n\n    dataframes.append(df)\n\nfull_df = pd.concat(dataframes, ignore_index=<span class=\"hljs-literal\">True</span>)\nfull_df = full_df.drop([<span class=\"hljs-string\">'unique_id'</span>], axis=<span class=\"hljs-number\">1</span>)\n</code></pre>\n<p>이후, 지표를 그래프로 그리려면:</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">import</span> matplotlib.pyplot <span class=\"hljs-keyword\">as</span> plt\n<span class=\"hljs-keyword\">import</span> numpy <span class=\"hljs-keyword\">as</span> np\n\ndataset_names = full_df[<span class=\"hljs-string\">'dataset'</span>].unique()\nmodel_names = [<span class=\"hljs-string\">'iTransformer'</span>, <span class=\"hljs-string\">'TSMixer'</span>, <span class=\"hljs-string\">'NHITS'</span>, <span class=\"hljs-string\">'PatchTST'</span>]\n\nfig, axs = plt.subplots(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>, figsize=(<span class=\"hljs-number\">15</span>, <span class=\"hljs-number\">15</span>))\nbar_width = <span class=\"hljs-number\">0.35</span>\n\naxs = axs.flatten()\n\n<span class=\"hljs-keyword\">for</span> i, dataset_name <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">enumerate</span>(dataset_names):\n    df_subset = full_df[(full_df[<span class=\"hljs-string\">'dataset'</span>] == dataset_name) &#x26; (full_df[<span class=\"hljs-string\">'metric'</span>] == <span class=\"hljs-string\">'mae'</span>)]\n    mae_vals = df_subset[model_names].values.flatten()\n    df_subset = full_df[(full_df[<span class=\"hljs-string\">'dataset'</span>] == dataset_name) &#x26; (full_df[<span class=\"hljs-string\">'metric'</span>] == <span class=\"hljs-string\">'mse'</span>)]\n    mse_vals = df_subset[model_names].values.flatten()\n\n    indices = np.arange(<span class=\"hljs-built_in\">len</span>(model_names))\n\n    bars_mae = axs[i].bar(indices - bar_width / <span class=\"hljs-number\">2</span>, mae_vals, bar_width, color=<span class=\"hljs-string\">'skyblue'</span>, label=<span class=\"hljs-string\">'MAE'</span>)\n    bars_mse = axs[i].bar(indices + bar_width / <span class=\"hljs-number\">2</span>, mse_vals, bar_width, color=<span class=\"hljs-string\">'orange'</span>, label=<span class=\"hljs-string\">'MSE'</span>)\n\n    <span class=\"hljs-keyword\">for</span> bars <span class=\"hljs-keyword\">in</span> [bars_mae, bars_mse]:\n        <span class=\"hljs-keyword\">for</span> bar <span class=\"hljs-keyword\">in</span> bars:\n            height = bar.get_height()\n            axs[i].annotate(<span class=\"hljs-string\">f'<span class=\"hljs-subst\">{height:<span class=\"hljs-number\">.2</span>f}</span>'</span>,\n                            xy=(bar.get_x() + bar.get_width() / <span class=\"hljs-number\">2</span>, height),\n                            xytext=(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>),\n                            textcoords=<span class=\"hljs-string\">\"offset points\"</span>,\n                            ha=<span class=\"hljs-string\">'center'</span>, va=<span class=\"hljs-string\">'bottom'</span>)\n\n    axs[i].set_xticks(indices)\n    axs[i].set_xticklabels(model_names, rotation=<span class=\"hljs-number\">45</span>)\n    axs[i].set_title(dataset_name)\n    axs[i].legend(loc=<span class=\"hljs-string\">'best'</span>)\n\nplt.tight_layout()\n</code></pre>\n<p><img src=\"/TIL/assets/img/2024-07-09-iTransformerTheLatestBreakthroughinTimeSeriesForecasting_4.png\" alt=\"Image\"></p>\n<p>From the figure above, we can see that the iTransformer performs fairly well on all datasets, but TSMixer is overall slightly better than iTransformer, and PatchTST is the overall champion model in this experiment.</p>\n<p>Of course, keep in mind that we did not leverage the multivariate capabilities of iTransformer, and we only tested on a single forecast horizon. Therefore, it is not a complete assessment of the iTransformer’s performance.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>그럼에도 불구하고, 모델이 PatchTST와 매우 유사하게 수행되는 것을 볼 때, Transformer를 사용한 시계열 예측에서 새로운 성능에 도달하는 데 그룹화 시간 단계를 토큰화하기 전에 묶는 아이디어를 더 지원하는 점이 흥미로운 부분입니다.</p>\n<h1>결론</h1>\n<p>iTransformer는 베이닐라 Transformer 아키텍처를 적용한 뒤 입력 시리즈의 역방향 모양으로 그냥 적용합니다.</p>\n<p>이렇게 하면 전체 시리즈가 토큰화되고 PatchTST에서 제안한 것과 같이 극단적인 케이스를 모방합니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>모델이 주의 매커니즘을 사용하여 다변량 상관 관계를 학습하고, 피드포워드 네트워크가 시계열의 시간적 특성을 학습합니다.</p>\n<p>iTransformer는 많은 벤치마크 데이터셋에서 장기 예측에 대한 최신 기술을 보여주었으며, 우리의 한정된 실험에서는 PatchTST가 전반적으로 가장 우수한 성과를 보였습니다.</p>\n<p>모든 문제는 고유한 해결책이 필요하다고 단언합니다. 이제 iTransformer를 도구 상자에 추가하고 여러분의 프로젝트에 적용할 수 있습니다.</p>\n<p>읽어 주셔서 감사합니다! 즐겁게 읽으셨기를 바라며 새로운 지식을 얻으셨기를 기대합니다!</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>만나서 반가워요 🌟</p>\n<h1>저를 지원해주세요</h1>\n<p>제 작업을 즐기고 계신가요? Buy me a coffee로 제게 지원을 표현해주세요. 여러분의 응원을 받으면 저는 커피 한 잔을 즐길 수 있어요! 만약 그렇게 느끼신다면, 아래 버튼을 클릭해주세요 👇</p>\n<p><img src=\"/TIL/assets/img/2024-07-09-iTransformerTheLatestBreakthroughinTimeSeriesForecasting_5.png\" alt=\"Image\"></p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h1>참고 자료</h1>\n<p>iTransformer: Inverted Transformers Are Effective for Time Series Forecasting by Yong Liu, Tengge Hu, Haoran Zhang, Haixu Wu, Shiyu Wang, Lintao Ma, Mingsheng Long</p>\n</body>\n</html>\n"},"__N_SSG":true}