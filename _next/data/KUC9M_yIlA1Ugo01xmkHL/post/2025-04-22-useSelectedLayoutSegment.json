{"pageProps":{"post":{"title":"Nextjs 15에서 useSelectedLayoutSegment 훅을 활용하는 방법","description":"","date":"2025-04-22 12:56","slug":"2025-04-22-useSelectedLayoutSegment","content":"\n\n# useSelectedLayoutSegment 훅이란?\n\n`useSelectedLayoutSegment`는 클라이언트 컴포넌트에서 사용할 수 있는 훅으로, 호출한 레이아웃 바로 아래에 있는 활성화된(활성 상태인) 라우트 세그먼트를 읽을 수 있게 도와줘요.\n\n### 언제 쓰면 좋을까?\n\n예를 들면, 부모 레이아웃 안에 여러 자식 탭이 있을 때 각 탭의 활성화 여부에 따라 스타일을 바꾸고 싶을 때 유용해요. 즉, 현재 어떤 세그먼트(탭 혹은 페이지의 구간)가 활성화 되어 있는지 쉽게 알 수 있어서, 그 정보를 UI에 반영하면 됩니다.\n\n### 코드 예시\n\n```jsx\n'use client'\n\nimport { useSelectedLayoutSegment } from 'next/navigation'\n\nexport default function ExampleClientComponent() {\n  const segment = useSelectedLayoutSegment()\n\n  return <p>Active segment: {segment}</p>\n}\n```\n\n이렇게 하면 현재 활성화된 세그먼트 이름이 화면에 출력되죠.\n\n---\n\n### 추가 팁!\n\n- `useSelectedLayoutSegment`는 부모 레이아웃 아래 한 단계의 세그먼트만 읽어올 수 있다는 점을 기억하세요. 예를 들어 `/dashboard/settings/profile` 같은 경로에서, `dashboard` 레이아웃 내에서 이 훅을 쓰면 `settings` 세그먼트만 받아옵니다. `profile`까지 깔끔하게 가져오려면 다른 방식이 필요해요!\n- 복수 개의 세그먼트가 활성화되는 상황(중첩 라우팅 등)에서는 `useSelectedLayoutSegments`라는 복수형 훅도 있어서, 필요하면 함께 살펴보시는 것도 좋습니다.\n- 네비게이션 UI를 만들 때 이 훅 덕분에 상태 관리나 URL 파싱 없이도 현재 위치를 쉽게 파악할 수 있어 개발 효율이 훨씬 올라가요!\n\nNext.js의 App Router와 함께 쓸 때 특히 훌륭한 툴이니 다음 프로젝트에 바로 활용해보세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n> 알아두면 좋은 점:  \nuseSelectedLayoutSegment 훅은 클라이언트 컴포넌트에서 사용해야 합니다. 왜냐하면 레이아웃(Layout)은 기본적으로 서버 컴포넌트이기 때문이죠. 그래서 보통 useSelectedLayoutSegment는 레이아웃 안에 임포트된 클라이언트 컴포넌트에서 호출하게 됩니다.  \n그리고 이 훅은 현재 활성화된 세그먼트 중 한 단계 아래(자식 레벨) 세그먼트만 반환해요. 만약 활성화된 모든 세그먼트를 한꺼번에 받고 싶다면 useSelectedLayoutSegments라는 훅을 참고하세요.\n\n## 파라미터\n\n| 파라미터명          | 타입         | 설명                                                                                  |\n|------------------|------------|-------------------------------------------------------------------------------------|\n| parallelRoutesKey | string (옵션) | 특정 슬롯 내에서 활성화된 경로 세그먼트를 읽고 싶을 때 사용합니다. 예를 들어 병렬 라우트가 여러 개인 경우 해당 슬롯을 지정할 수 있어요. |\n\n```js\nconst segment = useSelectedLayoutSegment(parallelRoutesKey?: string)\n```\n\n---\n\n### 추가로 알려드릴 팁!  \nNext.js의 앱 디렉토리 구조에서 라우트 세그먼트(segment)는 URL 경로의 일부를 의미합니다. 예를 들어 `/dashboard/settings`라면 `dashboard`와 `settings`가 각각 하나의 세그먼트죠.  \nuseSelectedLayoutSegment 훅을 활용하면 현재 화면에서 어느 경로 세그먼트가 활성화되어 있는지를 쉽게 알 수 있어서, 조건부 렌더링이나 UI 상태 관리에 굉장히 유용합니다.\n\n또한, parallelRoutesKey를 지정하는 경우는 조금 특별한데요, 예를 들어 하나의 레이아웃에 여러 병렬 경로 슬롯이 있다면, 어느 슬롯의 세그먼트를 조회할지 명확히 할 수 있어 좋습니다. 예전에는 복잡한 라우팅 정보를 관리하기 위해 별도의 로직을 짜야 했던 점을 생각하면, 이 훅이 확실히 편리함을 더해주죠!\n\n꼭 클라이언트 컴포넌트 안에서만 쓸 수 있다는 점 기억하시고, 서버 컴포넌트라면 클라이언트 컴포넌트를 분리해서 함께 사용하는 구조로 짜시면 됩니다. 이 부분은 Next.js 13 이후 앱 디렉토리 사용 시 자주 보게 될 패턴이라 익숙해지면 개발이 한결 수월해질 거예요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## Returns\n\n`useSelectedLayoutSegment`은 현재 활성화된 세그먼트의 문자열을 반환하며, 만약 활성 세그먼트가 없다면 `null`을 반환합니다.\n\n아래 표는 다양한 레이아웃과 방문한 URL에 따른 반환값 예시를 보여주는데요, 한눈에 이해하기 쉽게 정리해봤어요.\n\n| Layout                    | 방문한 URL              | 반환 값          |\n|---------------------------|-------------------------|------------------|\n| `app/layout.js`            | `/`                     | `null`           |\n| `app/layout.js`            | `/dashboard`            | `'dashboard'`    |\n| `app/dashboard/layout.js`  | `/dashboard`            | `null`           |\n| `app/dashboard/layout.js`  | `/dashboard/settings`   | `'settings'`     |\n| `app/dashboard/layout.js`  | `/dashboard/analytics`  | `'analytics'`    |\n| `app/dashboard/layout.js`  | `/dashboard/analytics/monthly` | `'analytics'` |\n\n여기서 중요한 점은, 상위 레이아웃에서 `/dashboard` 같은 경로를 방문했을 때는 세그먼트가 바로 반환되지만, 하위 레이아웃에서는 경로에 따라 조금 다르게 동작한다는 거예요.\n\n예를 들어, `app/dashboard/layout.js` 안에서 `/dashboard/analytics/monthly`를 방문하면 가장 가까운 하위 세그먼트인 `'analytics'`를 반환하죠. 이 부분은 레이아웃과 라우팅 계층 구조를 잘 이해하면 훨씬 더 효과적으로 활용할 수 있을 거예요.\n\n추가 팁을 드리자면, 이 훅은 주로 동적으로 현재 경로에 따라 UI를 변경하거나, 세그먼트 기반으로 조건부 렌더링 해야 할 때 유용하게 사용할 수 있어요. React 내비게이션 상태 관리와 잘 결합하면 복잡한 네비게이션 로직을 훨씬 간결하고 명확하게 만들 수 있답니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 예제\n\n### 활성화된 링크 컴포넌트 만들기\n\n`useSelectedLayoutSegment` 훅을 활용해서 현재 활성화된 세그먼트에 따라 스타일이 바뀌는 활성 링크 컴포넌트를 만들 수 있어요. 예를 들어, 블로그 사이드바에 자주 보여주는 게시글 리스트를 구현할 때 유용하죠.\n\n```js\n'use client'\n\nimport Link from 'next/link'\nimport { useSelectedLayoutSegment } from 'next/navigation'\n\n// 이 *클라이언트* 컴포넌트는 블로그 레이아웃에 포함돼서 사용됩니다.\nexport default function BlogNavLink({\n  slug,\n  children,\n}: {\n  slug: string\n  children: React.ReactNode\n}) {\n  // 예를 들어 `/blog/hello-world` 에서 현재 선택된 레이아웃 세그먼트는 'hello-world'가 됩니다.\n  const segment = useSelectedLayoutSegment()\n  const isActive = slug === segment\n\n  return (\n    <Link\n      href={`/blog/${slug}`}\n      // 링크가 활성화 됐을 때는 폰트가 굵게, 그렇지 않으면 기본 스타일로 표시합니다.\n      style={{ fontWeight: isActive ? 'bold' : 'normal' }}\n    >\n      {children}\n    </Link>\n  )\n}\n```\n\n---\n\n여기서 살짝 더 알려드리자면, `useSelectedLayoutSegment`는 현재 URL 경로 중 해당 레이아웃의 세그먼트를 반환해주기 때문에, 특정 경로가 선택됐는지 쉽게 알 수 있어요. 이걸 활용해 사이드바 메뉴, 탭 네비게이션 등에서 '현재 위치' 표시를 깔끔하게 할 수 있답니다.\n\n또한, 스타일뿐만 아니라 클래스명을 바꾸거나 아이콘을 변경하는 방식 등으로도 확장할 수 있으니 필요한 UI에 맞게 조절해보세요! Next.js 13의 레이아웃과 내비게이션 시스템을 활용하면 이런 사용자 경험이 훨씬 자연스럽고 간편해집니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n// 클라이언트 컴포넌트인 BlogNavLink를 부모 레이아웃(Server Component)에 임포트하는 예제입니다.\nimport { BlogNavLink } from './blog-nav-link'\nimport getFeaturedPosts from './get-featured-posts'\n\nexport default async function Layout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  // 비동기로 추천 포스트를 받아옵니다.\n  const featuredPosts = await getFeaturedPosts()\n\n  return (\n    <div>\n      {/* 받아온 추천 포스트들을 하나씩 돌면서 BlogNavLink 컴포넌트에 slug와 제목을 넘겨 렌더링합니다. */}\n      {featuredPosts.map((post) => (\n        <div key={post.id}>\n          <BlogNavLink slug={post.slug}>{post.title}</BlogNavLink>\n        </div>\n      ))}\n      {/* 하위 컴포넌트(children)를 렌더링 합니다. */}\n      <div>{children}</div>\n    </div>\n  )\n}\n```\n\n---\n\n### Version History\n\n| Version   | Changes                      |\n|-----------|------------------------------|\n| `v13.0.0` | `useSelectedLayoutSegment` 훅이 도입되었습니다. |\n\n---\n\n#### 간단 팁!\n\n- `Layout` 컴포넌트는 React의 **서버 컴포넌트(Server Component)**로 설계되어 있습니다. 서버에서 데이터를 받아오고 렌더링하는 데 최적화되어 있죠.\n- 클라이언트 컴포넌트를 렌더링하려면(예: 여기서 `BlogNavLink`) 반드시 클라이언트 컴포넌트로 만들어야 하며, 이 부분은 \"use client\" 지시어를 파일 상단에 넣어야 합니다.\n- Next.js 13의 새로운 라우팅 시스템에서 레이아웃은 중첩 구조를 가질 수 있어, 이처럼 하위 컴포넌트(children)를 받는 패턴이 일반적입니다.\n- `useSelectedLayoutSegment`는 라우트가 활성화되었는지 알 수 있게 해줘서, 네비게이션 메뉴 활성화 등에 자주 사용되는 커스텀 훅이에요!\n\n이 코드를 활용해서 동적인 네비게이션이나 블로그 포스트 목록 등을 서버 측에서 불러와서 쉽게 만들 수 있다는 점, 꼭 기억하세요 :)","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":8},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<h1>useSelectedLayoutSegment 훅이란?</h1>\n<p><code>useSelectedLayoutSegment</code>는 클라이언트 컴포넌트에서 사용할 수 있는 훅으로, 호출한 레이아웃 바로 아래에 있는 활성화된(활성 상태인) 라우트 세그먼트를 읽을 수 있게 도와줘요.</p>\n<h3>언제 쓰면 좋을까?</h3>\n<p>예를 들면, 부모 레이아웃 안에 여러 자식 탭이 있을 때 각 탭의 활성화 여부에 따라 스타일을 바꾸고 싶을 때 유용해요. 즉, 현재 어떤 세그먼트(탭 혹은 페이지의 구간)가 활성화 되어 있는지 쉽게 알 수 있어서, 그 정보를 UI에 반영하면 됩니다.</p>\n<h3>코드 예시</h3>\n<pre><code class=\"hljs language-jsx\"><span class=\"hljs-string\">'use client'</span>\n\n<span class=\"hljs-keyword\">import</span> { useSelectedLayoutSegment } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'next/navigation'</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">ExampleClientComponent</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> segment = <span class=\"hljs-title function_\">useSelectedLayoutSegment</span>()\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">p</span>></span>Active segment: {segment}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">p</span>></span></span>\n}\n</code></pre>\n<p>이렇게 하면 현재 활성화된 세그먼트 이름이 화면에 출력되죠.</p>\n<hr>\n<h3>추가 팁!</h3>\n<ul>\n<li><code>useSelectedLayoutSegment</code>는 부모 레이아웃 아래 한 단계의 세그먼트만 읽어올 수 있다는 점을 기억하세요. 예를 들어 <code>/dashboard/settings/profile</code> 같은 경로에서, <code>dashboard</code> 레이아웃 내에서 이 훅을 쓰면 <code>settings</code> 세그먼트만 받아옵니다. <code>profile</code>까지 깔끔하게 가져오려면 다른 방식이 필요해요!</li>\n<li>복수 개의 세그먼트가 활성화되는 상황(중첩 라우팅 등)에서는 <code>useSelectedLayoutSegments</code>라는 복수형 훅도 있어서, 필요하면 함께 살펴보시는 것도 좋습니다.</li>\n<li>네비게이션 UI를 만들 때 이 훅 덕분에 상태 관리나 URL 파싱 없이도 현재 위치를 쉽게 파악할 수 있어 개발 효율이 훨씬 올라가요!</li>\n</ul>\n<p>Next.js의 App Router와 함께 쓸 때 특히 훌륭한 툴이니 다음 프로젝트에 바로 활용해보세요!</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<blockquote>\n<p>알아두면 좋은 점:<br>\nuseSelectedLayoutSegment 훅은 클라이언트 컴포넌트에서 사용해야 합니다. 왜냐하면 레이아웃(Layout)은 기본적으로 서버 컴포넌트이기 때문이죠. 그래서 보통 useSelectedLayoutSegment는 레이아웃 안에 임포트된 클라이언트 컴포넌트에서 호출하게 됩니다.<br>\n그리고 이 훅은 현재 활성화된 세그먼트 중 한 단계 아래(자식 레벨) 세그먼트만 반환해요. 만약 활성화된 모든 세그먼트를 한꺼번에 받고 싶다면 useSelectedLayoutSegments라는 훅을 참고하세요.</p>\n</blockquote>\n<h2>파라미터</h2>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>파라미터명</th><th>타입</th><th>설명</th></tr></thead><tbody><tr><td>parallelRoutesKey</td><td>string (옵션)</td><td>특정 슬롯 내에서 활성화된 경로 세그먼트를 읽고 싶을 때 사용합니다. 예를 들어 병렬 라우트가 여러 개인 경우 해당 슬롯을 지정할 수 있어요.</td></tr></tbody></table>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> segment = <span class=\"hljs-title function_\">useSelectedLayoutSegment</span>(parallelRoutesKey?: string)\n</code></pre>\n<hr>\n<h3>추가로 알려드릴 팁!</h3>\n<p>Next.js의 앱 디렉토리 구조에서 라우트 세그먼트(segment)는 URL 경로의 일부를 의미합니다. 예를 들어 <code>/dashboard/settings</code>라면 <code>dashboard</code>와 <code>settings</code>가 각각 하나의 세그먼트죠.<br>\nuseSelectedLayoutSegment 훅을 활용하면 현재 화면에서 어느 경로 세그먼트가 활성화되어 있는지를 쉽게 알 수 있어서, 조건부 렌더링이나 UI 상태 관리에 굉장히 유용합니다.</p>\n<p>또한, parallelRoutesKey를 지정하는 경우는 조금 특별한데요, 예를 들어 하나의 레이아웃에 여러 병렬 경로 슬롯이 있다면, 어느 슬롯의 세그먼트를 조회할지 명확히 할 수 있어 좋습니다. 예전에는 복잡한 라우팅 정보를 관리하기 위해 별도의 로직을 짜야 했던 점을 생각하면, 이 훅이 확실히 편리함을 더해주죠!</p>\n<p>꼭 클라이언트 컴포넌트 안에서만 쓸 수 있다는 점 기억하시고, 서버 컴포넌트라면 클라이언트 컴포넌트를 분리해서 함께 사용하는 구조로 짜시면 됩니다. 이 부분은 Next.js 13 이후 앱 디렉토리 사용 시 자주 보게 될 패턴이라 익숙해지면 개발이 한결 수월해질 거예요!</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h2>Returns</h2>\n<p><code>useSelectedLayoutSegment</code>은 현재 활성화된 세그먼트의 문자열을 반환하며, 만약 활성 세그먼트가 없다면 <code>null</code>을 반환합니다.</p>\n<p>아래 표는 다양한 레이아웃과 방문한 URL에 따른 반환값 예시를 보여주는데요, 한눈에 이해하기 쉽게 정리해봤어요.</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>Layout</th><th>방문한 URL</th><th>반환 값</th></tr></thead><tbody><tr><td><code>app/layout.js</code></td><td><code>/</code></td><td><code>null</code></td></tr><tr><td><code>app/layout.js</code></td><td><code>/dashboard</code></td><td><code>'dashboard'</code></td></tr><tr><td><code>app/dashboard/layout.js</code></td><td><code>/dashboard</code></td><td><code>null</code></td></tr><tr><td><code>app/dashboard/layout.js</code></td><td><code>/dashboard/settings</code></td><td><code>'settings'</code></td></tr><tr><td><code>app/dashboard/layout.js</code></td><td><code>/dashboard/analytics</code></td><td><code>'analytics'</code></td></tr><tr><td><code>app/dashboard/layout.js</code></td><td><code>/dashboard/analytics/monthly</code></td><td><code>'analytics'</code></td></tr></tbody></table>\n<p>여기서 중요한 점은, 상위 레이아웃에서 <code>/dashboard</code> 같은 경로를 방문했을 때는 세그먼트가 바로 반환되지만, 하위 레이아웃에서는 경로에 따라 조금 다르게 동작한다는 거예요.</p>\n<p>예를 들어, <code>app/dashboard/layout.js</code> 안에서 <code>/dashboard/analytics/monthly</code>를 방문하면 가장 가까운 하위 세그먼트인 <code>'analytics'</code>를 반환하죠. 이 부분은 레이아웃과 라우팅 계층 구조를 잘 이해하면 훨씬 더 효과적으로 활용할 수 있을 거예요.</p>\n<p>추가 팁을 드리자면, 이 훅은 주로 동적으로 현재 경로에 따라 UI를 변경하거나, 세그먼트 기반으로 조건부 렌더링 해야 할 때 유용하게 사용할 수 있어요. React 내비게이션 상태 관리와 잘 결합하면 복잡한 네비게이션 로직을 훨씬 간결하고 명확하게 만들 수 있답니다!</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h2>예제</h2>\n<h3>활성화된 링크 컴포넌트 만들기</h3>\n<p><code>useSelectedLayoutSegment</code> 훅을 활용해서 현재 활성화된 세그먼트에 따라 스타일이 바뀌는 활성 링크 컴포넌트를 만들 수 있어요. 예를 들어, 블로그 사이드바에 자주 보여주는 게시글 리스트를 구현할 때 유용하죠.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-string\">'use client'</span>\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Link</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'next/link'</span>\n<span class=\"hljs-keyword\">import</span> { useSelectedLayoutSegment } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'next/navigation'</span>\n\n<span class=\"hljs-comment\">// 이 *클라이언트* 컴포넌트는 블로그 레이아웃에 포함돼서 사용됩니다.</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">BlogNavLink</span>(<span class=\"hljs-params\">{\n  slug,\n  children,\n}: {\n  slug: string\n  children: React.ReactNode\n}</span>) {\n  <span class=\"hljs-comment\">// 예를 들어 `/blog/hello-world` 에서 현재 선택된 레이아웃 세그먼트는 'hello-world'가 됩니다.</span>\n  <span class=\"hljs-keyword\">const</span> segment = <span class=\"hljs-title function_\">useSelectedLayoutSegment</span>()\n  <span class=\"hljs-keyword\">const</span> isActive = slug === segment\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Link</span>\n      <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">{</span>`/<span class=\"hljs-attr\">blog</span>/${<span class=\"hljs-attr\">slug</span>}`}\n      // <span class=\"hljs-attr\">링크가</span> <span class=\"hljs-attr\">활성화</span> <span class=\"hljs-attr\">됐을</span> <span class=\"hljs-attr\">때는</span> <span class=\"hljs-attr\">폰트가</span> <span class=\"hljs-attr\">굵게</span>, <span class=\"hljs-attr\">그렇지</span> <span class=\"hljs-attr\">않으면</span> <span class=\"hljs-attr\">기본</span> <span class=\"hljs-attr\">스타일로</span> <span class=\"hljs-attr\">표시합니다.</span>\n      <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{{</span> <span class=\"hljs-attr\">fontWeight:</span> <span class=\"hljs-attr\">isActive</span> ? '<span class=\"hljs-attr\">bold</span>' <span class=\"hljs-attr\">:</span> '<span class=\"hljs-attr\">normal</span>' }}\n    ></span>\n      {children}\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">Link</span>></span></span>\n  )\n}\n</code></pre>\n<hr>\n<p>여기서 살짝 더 알려드리자면, <code>useSelectedLayoutSegment</code>는 현재 URL 경로 중 해당 레이아웃의 세그먼트를 반환해주기 때문에, 특정 경로가 선택됐는지 쉽게 알 수 있어요. 이걸 활용해 사이드바 메뉴, 탭 네비게이션 등에서 '현재 위치' 표시를 깔끔하게 할 수 있답니다.</p>\n<p>또한, 스타일뿐만 아니라 클래스명을 바꾸거나 아이콘을 변경하는 방식 등으로도 확장할 수 있으니 필요한 UI에 맞게 조절해보세요! Next.js 13의 레이아웃과 내비게이션 시스템을 활용하면 이런 사용자 경험이 훨씬 자연스럽고 간편해집니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 클라이언트 컴포넌트인 BlogNavLink를 부모 레이아웃(Server Component)에 임포트하는 예제입니다.</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">BlogNavLink</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./blog-nav-link'</span>\n<span class=\"hljs-keyword\">import</span> getFeaturedPosts <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./get-featured-posts'</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Layout</span>(<span class=\"hljs-params\">{\n  children,\n}: {\n  children: React.ReactNode\n}</span>) {\n  <span class=\"hljs-comment\">// 비동기로 추천 포스트를 받아옵니다.</span>\n  <span class=\"hljs-keyword\">const</span> featuredPosts = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">getFeaturedPosts</span>()\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>\n      {/* 받아온 추천 포스트들을 하나씩 돌면서 BlogNavLink 컴포넌트에 slug와 제목을 넘겨 렌더링합니다. */}\n      {featuredPosts.map((post) => (\n        <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">{post.id}</span>></span>\n          <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">BlogNavLink</span> <span class=\"hljs-attr\">slug</span>=<span class=\"hljs-string\">{post.slug}</span>></span>{post.title}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">BlogNavLink</span>></span>\n        <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n      ))}\n      {/* 하위 컴포넌트(children)를 렌더링 합니다. */}\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>{children}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n  )\n}\n</code></pre>\n<hr>\n<h3>Version History</h3>\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>Version</th><th>Changes</th></tr></thead><tbody><tr><td><code>v13.0.0</code></td><td><code>useSelectedLayoutSegment</code> 훅이 도입되었습니다.</td></tr></tbody></table>\n<hr>\n<h4>간단 팁!</h4>\n<ul>\n<li><code>Layout</code> 컴포넌트는 React의 **서버 컴포넌트(Server Component)**로 설계되어 있습니다. 서버에서 데이터를 받아오고 렌더링하는 데 최적화되어 있죠.</li>\n<li>클라이언트 컴포넌트를 렌더링하려면(예: 여기서 <code>BlogNavLink</code>) 반드시 클라이언트 컴포넌트로 만들어야 하며, 이 부분은 \"use client\" 지시어를 파일 상단에 넣어야 합니다.</li>\n<li>Next.js 13의 새로운 라우팅 시스템에서 레이아웃은 중첩 구조를 가질 수 있어, 이처럼 하위 컴포넌트(children)를 받는 패턴이 일반적입니다.</li>\n<li><code>useSelectedLayoutSegment</code>는 라우트가 활성화되었는지 알 수 있게 해줘서, 네비게이션 메뉴 활성화 등에 자주 사용되는 커스텀 훅이에요!</li>\n</ul>\n<p>이 코드를 활용해서 동적인 네비게이션이나 블로그 포스트 목록 등을 서버 측에서 불러와서 쉽게 만들 수 있다는 점, 꼭 기억하세요 :)</p>\n</body>\n</html>\n"},"__N_SSG":true}