{"pageProps":{"post":{"title":"Next.js 15에서 useSelectedLayoutSegments로 레이아웃 세그먼트 선택하는 방법","description":"","date":"2025-04-22 12:57","slug":"2025-04-22-useSelectedLayoutSegments","content":"\n\n# useSelectedLayoutSegments 훅 쉽게 이해하기\n\n`useSelectedLayoutSegments`는 Next.js에서 클라이언트 컴포넌트 안에서 사용할 수 있는 아주 유용한 훅이에요. 이 훅은 호출된 Layout 컴포넌트 아래에서 활성화된(즉, 현재 URL 경로에서 사용 중인) 라우트 세그먼트(segment)를 읽어올 수 있어요.\n\n예를 들어, 부모 Layout에서 자식 라우트가 어떤 상태인지 알아야 할 때, 특히 현재 페이지 경로를 기반으로 빵 부스러기(브레드크럼) 같은 UI를 만들 때 유용하답니다!\n\n---\n\n## 어떻게 쓰는지 간단한 예시\n\n```js\n'use client'\n \nimport { useSelectedLayoutSegments } from 'next/navigation'\n \nexport default function ExampleClientComponent() {\n  const segments = useSelectedLayoutSegments()\n \n  return (\n    <ul>\n      {segments.map((segment, index) => (\n        <li key={index}>{segment}</li>\n      ))}\n    </ul>\n  )\n}\n```\n\n위의 코드는 현재 활성화된 라우트 세그먼트들을 배열로 받아와서 `<ul>`로 나열해주는 아주 기본적인 사용법입니다. 예를 들어 현재 경로가 `/products/electronics` 라면, `segments`는 `['products', 'electronics']` 형태가 될 거에요.\n\n---\n\n## 참고하면 좋은 점!\n\n- **클라이언트 컴포넌트에서만 작동해요**  \n  당연히 내부에 `'use client'` 지시자가 꼭 있어야 하고, 서버 컴포넌트에선 사용할 수 없어요.\n\n- **Breadcrumbs 만들기에 매우 좋아요!**  \n  부모 레이아웃에서 자식 경로를 확인해 빵 부스러기 네비게이션 UI를 만들거나, 현재 위치에 따라 다른 스타일을 적용하는 상황에 활용하기 딱이죠.\n\n- **동적 라우트도 문제없어요!**  \n  예를 들어 `/blog/[slug]` 같은 동적 경로를 사용할 때 현재 어떤 슬러그를 보고 있는지 쉽게 알 수 있어요.\n\n- **배열 형태 반환**  \n  항상 배열로 반환되니까 각 세그먼트를 간단히 `.map()` 해서 처리할 수 있답니다.\n\n---\n\n### 조금 더 발전된 활용 팁\n\n```js\n'use client'\n\nimport { useSelectedLayoutSegments } from 'next/navigation'\n\nexport default function Breadcrumbs() {\n  const segments = useSelectedLayoutSegments()\n\n  // 각 세그먼트를 적절히 대문자로 변환해서 보여주기\n  const formattedSegments = segments.map(seg => seg.charAt(0).toUpperCase() + seg.slice(1))\n\n  // 링크 처리를 할 때는, 현재까지의 경로를 누적해서 만들어줍니다.\n  let path = ''\n  return (\n    <nav aria-label=\"breadcrumb\">\n      <ul style={{ display: 'flex', gap: '8px' }}>\n        {formattedSegments.map((segment, idx) => {\n          path += '/' + segments[idx]\n          return (\n            <li key={idx}>\n              <a href={path}>{segment}</a>\n              {idx < segments.length - 1 && ' / '}\n            </li>\n          )\n        })}\n      </ul>\n    </nav>\n  )\n}\n```\n\n이렇게 하면 현재 위치에 따른 링크가 포함된 빵 부스러기 네비게이션을 만들 수 있답니다. 정말 간단하죠?\n\n---\n\n이 훅을 잘 활용하면 레이아웃 안에서 현재 경로 정보를 쉽게 읽어와 다양한 UI 변화를 줄 수 있으니 꼭 한 번 사용해보세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n> 알아두면 좋은 점:  \nuseSelectedLayoutSegments는 클라이언트 컴포넌트 훅이고, 레이아웃(Layout)은 기본적으로 서버 컴포넌트라서, 보통 useSelectedLayoutSegments는 레이아웃 안에 임포트된 클라이언트 컴포넌트를 통해 호출됩니다.  \n그리고 이 훅이 반환하는 segments 배열에는 경로 그룹(Route Groups)도 포함되는데, UI에 굳이 표시하고 싶지 않은 경우가 많아요. 그럴 땐 filter() 배열 메서드를 써서 대괄호로 시작하는 항목들(예: [group])을 제외하면 됩니다.\n\n## 파라미터\n\n| 파라미터          | 설명                                                      |\n|------------------|---------------------------------------------------------|\n| parallelRoutesKey | 선택적으로 사용 가능한 문자열로, 활성화된 특정 슬롯 내 경로 세그먼트를 읽을 때 사용 |\n\n\n```js\nconst segments = useSelectedLayoutSegments(parallelRoutesKey?: string)\n```\n\nuseSelectedLayoutSegments는 parallelRoutesKey를 인자로 받을 수 있는데, 이 키를 넘기면 해당 슬롯의 활성화된 라우트 세그먼트를 읽어올 수 있어요. 예를 들어, 하나의 레이아웃 안에 여러 병렬 라우트가 있을 때 유용하죠.\n\n---\n\n### 추가 팁!  \n경로 그룹(Route Groups)은 파일이나 폴더 이름에 대괄호([])를 써서 만든 가상의 라우트 구획입니다. 보통 URL 경로에는 표시되지 않지만, 내부적으로 라우팅에 도움이 되죠. 그래서 UI에 표시하려면 걸러내는 게 좋고, 예를 들어 이렇게 쓰면 됩니다:\n\n```js\nconst filteredSegments = segments.filter(segment => !segment.startsWith('['));\n```\n\n이런 세세한 관리가 가능해서, 내비게이션 UI나 Breadcrum 같은 컴포넌트를 만들 때 훨씬 깔끔한 결과물을 얻을 수 있답니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 반환값 (Returns)\n\n`useSelectedLayoutSegments` 훅은 호출된 레이아웃으로부터 **한 단계 아래에 있는 활성화된 세그먼트들**을 문자열 배열로 반환해줘요. 만약 그런 세그먼트가 전혀 없다면, 빈 배열을 반환합니다.\n\n조금 더 쉽게 예를 들어볼게요. 다음과 같은 레이아웃 구조와 방문 URL이 있다고 할 때, 반환되는 세그먼트는 아래 표와 같이 나옵니다:\n\n| Layout             | 방문한 URL           | 반환되는 세그먼트          |\n|--------------------|----------------------|----------------------------|\n| `app/layout.js`     | `/`                  | `[]`                        |\n| `app/layout.js`     | `/dashboard`          | `['dashboard']`             |\n| `app/layout.js`     | `/dashboard/settings` | `['dashboard', 'settings']` |\n| `app/dashboard/layout.js` | `/dashboard`      | `[]`                        |\n| `app/dashboard/layout.js` | `/dashboard/settings` | `['settings']`              |\n\n---\n\n### 좀 더 설명을 덧붙이자면\n\n- 이 훅은 **현재 레이아웃 위치(폴더) 기준으로 다음 하위 경로들을 배열로 반환**하는 기능이에요. 예를 들어, `app/layout.js` 아래에서 호출하면 전체 경로의 첫 세그먼트부터 하나씩 배열로 주고, `app/dashboard/layout.js` 아래에서 호출하면 그 기준 폴더 바로 아래의 세그먼트들만 반환하는 거죠.\n- 그래서 URL 경로가 길더라도 각 레이아웃별로 자신과 바로 아래 경로 구간을 정확하게 인지할 수 있어서, 복잡한 네스팅 구조에서도 유용하게 쓸 수 있어요.\n\n> 만약 Next.js 같은 프레임워크를 쓰고 있고, 다이나믹 라우팅을 하거나 레이아웃별로 상태관리를 하고 싶다면 `useSelectedLayoutSegments`를 잘 활용해보세요. 현재 위치한 레이아웃 기준으로 어떤 세그먼트가 활성화되어 있는지 쉽게 파악할 수 있답니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 버전 히스토리\n\n| 버전       | 변경 사항                     |\n|------------|------------------------------|\n| `v13.0.0`  | `useSelectedLayoutSegments`가 새롭게 추가됨. |\n\n---\n\n이렇게 간단하게 버전별로 변경된 내용을 정리해두면, 나중에 업데이트 내역을 한눈에 파악하기 너무 편해요. 특히 라이브러리나 프레임워크를 사용할 때는 어떤 기능이 새로 생겼는지, 어떤 버그가 고쳐졌는지 알아두는 게 중요하거든요.\n\n참고로, 여기서 소개한 `useSelectedLayoutSegments`는 특정 레이아웃 세그먼트(구간)를 선택하는 데 도움을 주는 hook인데요, React 같은 환경에서 라우팅이나 UI를 좀 더 세밀하게 제어할 때 유용하게 쓸 수 있답니다. 만약 더 궁금하면 관련 예제도 알려드릴게요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":6},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<h1>useSelectedLayoutSegments 훅 쉽게 이해하기</h1>\n<p><code>useSelectedLayoutSegments</code>는 Next.js에서 클라이언트 컴포넌트 안에서 사용할 수 있는 아주 유용한 훅이에요. 이 훅은 호출된 Layout 컴포넌트 아래에서 활성화된(즉, 현재 URL 경로에서 사용 중인) 라우트 세그먼트(segment)를 읽어올 수 있어요.</p>\n<p>예를 들어, 부모 Layout에서 자식 라우트가 어떤 상태인지 알아야 할 때, 특히 현재 페이지 경로를 기반으로 빵 부스러기(브레드크럼) 같은 UI를 만들 때 유용하답니다!</p>\n<hr>\n<h2>어떻게 쓰는지 간단한 예시</h2>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-string\">'use client'</span>\n \n<span class=\"hljs-keyword\">import</span> { useSelectedLayoutSegments } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'next/navigation'</span>\n \n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">ExampleClientComponent</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> segments = <span class=\"hljs-title function_\">useSelectedLayoutSegments</span>()\n \n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">ul</span>></span>\n      {segments.map((segment, index) => (\n        <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">{index}</span>></span>{segment}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">li</span>></span>\n      ))}\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">ul</span>></span></span>\n  )\n}\n</code></pre>\n<p>위의 코드는 현재 활성화된 라우트 세그먼트들을 배열로 받아와서 <code>&#x3C;ul></code>로 나열해주는 아주 기본적인 사용법입니다. 예를 들어 현재 경로가 <code>/products/electronics</code> 라면, <code>segments</code>는 <code>['products', 'electronics']</code> 형태가 될 거에요.</p>\n<hr>\n<h2>참고하면 좋은 점!</h2>\n<ul>\n<li>\n<p><strong>클라이언트 컴포넌트에서만 작동해요</strong><br>\n당연히 내부에 <code>'use client'</code> 지시자가 꼭 있어야 하고, 서버 컴포넌트에선 사용할 수 없어요.</p>\n</li>\n<li>\n<p><strong>Breadcrumbs 만들기에 매우 좋아요!</strong><br>\n부모 레이아웃에서 자식 경로를 확인해 빵 부스러기 네비게이션 UI를 만들거나, 현재 위치에 따라 다른 스타일을 적용하는 상황에 활용하기 딱이죠.</p>\n</li>\n<li>\n<p><strong>동적 라우트도 문제없어요!</strong><br>\n예를 들어 <code>/blog/[slug]</code> 같은 동적 경로를 사용할 때 현재 어떤 슬러그를 보고 있는지 쉽게 알 수 있어요.</p>\n</li>\n<li>\n<p><strong>배열 형태 반환</strong><br>\n항상 배열로 반환되니까 각 세그먼트를 간단히 <code>.map()</code> 해서 처리할 수 있답니다.</p>\n</li>\n</ul>\n<hr>\n<h3>조금 더 발전된 활용 팁</h3>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-string\">'use client'</span>\n\n<span class=\"hljs-keyword\">import</span> { useSelectedLayoutSegments } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'next/navigation'</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Breadcrumbs</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> segments = <span class=\"hljs-title function_\">useSelectedLayoutSegments</span>()\n\n  <span class=\"hljs-comment\">// 각 세그먼트를 적절히 대문자로 변환해서 보여주기</span>\n  <span class=\"hljs-keyword\">const</span> formattedSegments = segments.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">seg</span> =></span> seg.<span class=\"hljs-title function_\">charAt</span>(<span class=\"hljs-number\">0</span>).<span class=\"hljs-title function_\">toUpperCase</span>() + seg.<span class=\"hljs-title function_\">slice</span>(<span class=\"hljs-number\">1</span>))\n\n  <span class=\"hljs-comment\">// 링크 처리를 할 때는, 현재까지의 경로를 누적해서 만들어줍니다.</span>\n  <span class=\"hljs-keyword\">let</span> path = <span class=\"hljs-string\">''</span>\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">nav</span> <span class=\"hljs-attr\">aria-label</span>=<span class=\"hljs-string\">\"breadcrumb\"</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">ul</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{{</span> <span class=\"hljs-attr\">display:</span> '<span class=\"hljs-attr\">flex</span>', <span class=\"hljs-attr\">gap:</span> '<span class=\"hljs-attr\">8px</span>' }}></span>\n        {formattedSegments.map((segment, idx) => {\n          path += '/' + segments[idx]\n          return (\n            <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">{idx}</span>></span>\n              <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">{path}</span>></span>{segment}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">a</span>></span>\n              {idx &#x3C; segments.length - 1 &#x26;&#x26; ' / '}\n            <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">li</span>></span>\n          )\n        })}\n      <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">ul</span>></span>\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">nav</span>></span></span>\n  )\n}\n</code></pre>\n<p>이렇게 하면 현재 위치에 따른 링크가 포함된 빵 부스러기 네비게이션을 만들 수 있답니다. 정말 간단하죠?</p>\n<hr>\n<p>이 훅을 잘 활용하면 레이아웃 안에서 현재 경로 정보를 쉽게 읽어와 다양한 UI 변화를 줄 수 있으니 꼭 한 번 사용해보세요!</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<blockquote>\n<p>알아두면 좋은 점:<br>\nuseSelectedLayoutSegments는 클라이언트 컴포넌트 훅이고, 레이아웃(Layout)은 기본적으로 서버 컴포넌트라서, 보통 useSelectedLayoutSegments는 레이아웃 안에 임포트된 클라이언트 컴포넌트를 통해 호출됩니다.<br>\n그리고 이 훅이 반환하는 segments 배열에는 경로 그룹(Route Groups)도 포함되는데, UI에 굳이 표시하고 싶지 않은 경우가 많아요. 그럴 땐 filter() 배열 메서드를 써서 대괄호로 시작하는 항목들(예: [group])을 제외하면 됩니다.</p>\n</blockquote>\n<h2>파라미터</h2>\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>파라미터</th><th>설명</th></tr></thead><tbody><tr><td>parallelRoutesKey</td><td>선택적으로 사용 가능한 문자열로, 활성화된 특정 슬롯 내 경로 세그먼트를 읽을 때 사용</td></tr></tbody></table>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> segments = <span class=\"hljs-title function_\">useSelectedLayoutSegments</span>(parallelRoutesKey?: string)\n</code></pre>\n<p>useSelectedLayoutSegments는 parallelRoutesKey를 인자로 받을 수 있는데, 이 키를 넘기면 해당 슬롯의 활성화된 라우트 세그먼트를 읽어올 수 있어요. 예를 들어, 하나의 레이아웃 안에 여러 병렬 라우트가 있을 때 유용하죠.</p>\n<hr>\n<h3>추가 팁!</h3>\n<p>경로 그룹(Route Groups)은 파일이나 폴더 이름에 대괄호([])를 써서 만든 가상의 라우트 구획입니다. 보통 URL 경로에는 표시되지 않지만, 내부적으로 라우팅에 도움이 되죠. 그래서 UI에 표시하려면 걸러내는 게 좋고, 예를 들어 이렇게 쓰면 됩니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> filteredSegments = segments.<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">segment</span> =></span> !segment.<span class=\"hljs-title function_\">startsWith</span>(<span class=\"hljs-string\">'['</span>));\n</code></pre>\n<p>이런 세세한 관리가 가능해서, 내비게이션 UI나 Breadcrum 같은 컴포넌트를 만들 때 훨씬 깔끔한 결과물을 얻을 수 있답니다!</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h2>반환값 (Returns)</h2>\n<p><code>useSelectedLayoutSegments</code> 훅은 호출된 레이아웃으로부터 <strong>한 단계 아래에 있는 활성화된 세그먼트들</strong>을 문자열 배열로 반환해줘요. 만약 그런 세그먼트가 전혀 없다면, 빈 배열을 반환합니다.</p>\n<p>조금 더 쉽게 예를 들어볼게요. 다음과 같은 레이아웃 구조와 방문 URL이 있다고 할 때, 반환되는 세그먼트는 아래 표와 같이 나옵니다:</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>Layout</th><th>방문한 URL</th><th>반환되는 세그먼트</th></tr></thead><tbody><tr><td><code>app/layout.js</code></td><td><code>/</code></td><td><code>[]</code></td></tr><tr><td><code>app/layout.js</code></td><td><code>/dashboard</code></td><td><code>['dashboard']</code></td></tr><tr><td><code>app/layout.js</code></td><td><code>/dashboard/settings</code></td><td><code>['dashboard', 'settings']</code></td></tr><tr><td><code>app/dashboard/layout.js</code></td><td><code>/dashboard</code></td><td><code>[]</code></td></tr><tr><td><code>app/dashboard/layout.js</code></td><td><code>/dashboard/settings</code></td><td><code>['settings']</code></td></tr></tbody></table>\n<hr>\n<h3>좀 더 설명을 덧붙이자면</h3>\n<ul>\n<li>이 훅은 <strong>현재 레이아웃 위치(폴더) 기준으로 다음 하위 경로들을 배열로 반환</strong>하는 기능이에요. 예를 들어, <code>app/layout.js</code> 아래에서 호출하면 전체 경로의 첫 세그먼트부터 하나씩 배열로 주고, <code>app/dashboard/layout.js</code> 아래에서 호출하면 그 기준 폴더 바로 아래의 세그먼트들만 반환하는 거죠.</li>\n<li>그래서 URL 경로가 길더라도 각 레이아웃별로 자신과 바로 아래 경로 구간을 정확하게 인지할 수 있어서, 복잡한 네스팅 구조에서도 유용하게 쓸 수 있어요.</li>\n</ul>\n<blockquote>\n<p>만약 Next.js 같은 프레임워크를 쓰고 있고, 다이나믹 라우팅을 하거나 레이아웃별로 상태관리를 하고 싶다면 <code>useSelectedLayoutSegments</code>를 잘 활용해보세요. 현재 위치한 레이아웃 기준으로 어떤 세그먼트가 활성화되어 있는지 쉽게 파악할 수 있답니다!</p>\n</blockquote>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h2>버전 히스토리</h2>\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>버전</th><th>변경 사항</th></tr></thead><tbody><tr><td><code>v13.0.0</code></td><td><code>useSelectedLayoutSegments</code>가 새롭게 추가됨.</td></tr></tbody></table>\n<hr>\n<p>이렇게 간단하게 버전별로 변경된 내용을 정리해두면, 나중에 업데이트 내역을 한눈에 파악하기 너무 편해요. 특히 라이브러리나 프레임워크를 사용할 때는 어떤 기능이 새로 생겼는지, 어떤 버그가 고쳐졌는지 알아두는 게 중요하거든요.</p>\n<p>참고로, 여기서 소개한 <code>useSelectedLayoutSegments</code>는 특정 레이아웃 세그먼트(구간)를 선택하는 데 도움을 주는 hook인데요, React 같은 환경에서 라우팅이나 UI를 좀 더 세밀하게 제어할 때 유용하게 쓸 수 있답니다. 만약 더 궁금하면 관련 예제도 알려드릴게요!</p>\n</body>\n</html>\n"},"__N_SSG":true}