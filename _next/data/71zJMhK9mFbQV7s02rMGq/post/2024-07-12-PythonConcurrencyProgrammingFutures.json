{"pageProps":{"post":{"title":"Python 동시성 프로그래밍 Futures 사용법","description":"","date":"2024-07-12 20:22","slug":"2024-07-12-PythonConcurrencyProgrammingFutures","content":"\n\n\n![Image](/TIL/assets/img/2024-07-12-PythonConcurrencyProgrammingFutures_0.png)\n\n협업 프로그래밍을 올바르고 합리적으로 사용하면 우리 프로그램에 상당한 성능 향상을 가져다 줄 것입니다. 오늘의 글에서는 파이썬에서 동시성 프로그래밍 및 Future를 중점으로 하는 동시성 프로그래밍을 이해하고 적용하는 방법을 안내하겠습니다.\n\n# 동시성과 병렬성: 차이 이해하기\n\n동시성 프로그래밍에 대해 학습할 때 동시성과 병렬성이라는 용어를 함께 사용하는 경우가 많습니다. 이로 인해 많은 사람들이 두 용어가 동일한 것으로 생각되는 오해를 하게 됩니다. 그러나 이는 오인입니다.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n먼저 일반적으로 오해되는 것을 명확하게 해 봅시다: 파이썬에서 동시성은 여러 작업(스레드 또는 태스크)이 동시에 동시에 발생한다는 것을 의미하지 않습니다. 대신, 한 번에 하나의 작업만 진행되도록 허용하고, 스레드 또는 태스크가 완료될 때까지 서로 전환됩니다. 아래 다이어그램을 살펴보겠습니다:\n\n![Concurrency Diagram](/TIL/assets/img/2024-07-12-PythonConcurrencyProgrammingFutures_1.png)\n\n이 다이어그램은 태스크 전환을 관리하는 두 가지 다른 방법을 보여줍니다. 이는 파이썬에서 동시성의 두 형태에 대응됩니다: 스레딩과 asyncio입니다.\n\n스레딩의 경우, 운영 체제는 각 스레드의 모든 세부 정보를 알고 있기 때문에 필요에 따라 스레드 전환을 처리합니다. 여기서의 장점은 프로그래머가 전환 프로세스를 관리할 필요가 없기 때문에 코드를 작성하기가 더 쉽다는 것입니다. 그러나 이는 레이스 컨디션과 같은 문제로 이어질 수 있습니다. 이는 스레드가 단일 명령문 실행 도중에 서로 간섭할 수 있는 상황을 말합니다(e.g., x += 1).\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러나 asyncio를 사용할 경우, 주 프로그램이 작업을 전환할 수 있다는 것을 명시적으로 알려주어야 합니다. 이러한 설계는 asyncio 이벤트 루프에 의해 제어되는 방식으로 전환되므로 실행 중에 작업이 충돌하지 않도록 보장하여 경쟁 조건을 피할 수 있도록 도와줍니다.\n\n병렬성에 대해 이야기하면, 동시에 동시에 실행되는 작업을 가리킵니다. Python에서 이는 멀티 프로세싱을 통해 달성됩니다. 예를 들어, 컴퓨터가 6코어 프로세서를 사용한다면, 실행 속도를 높이기 위해 6개의 프로세스를 동시에 실행할 수 있습니다. 멀티 프로세싱의 기본 아이디어는 다음과 같이 나타낼 수 있습니다:\n\n![멀티 프로세싱](/TIL/assets/img/2024-07-12-PythonConcurrencyProgrammingFutures_2.png)\n\n두 가지를 비교해보면:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n동시성은 빈번한 I/O 작업이 발생하는 시나리오에서 자주 사용됩니다. 예를 들어, 웹 사이트에서 여러 파일을 다운로드할 때, I/O 작업에 소요되는 시간이 CPU 처리에 소요되는 시간보다 크게 늘어날 수 있습니다.\n\n반면에 병렬성은 CPU 집중적인 시나리오에 더 적합합니다. 예를 들어, MapReduce 병렬 계산에서 여러 대의 기계와 프로세서를 사용하여 작업을 여러 코어 또는 시스템에 분산시켜 실행 속도를 높이는 데 활용됩니다.\n\n# 동시성 프로그래밍의 Futures\n\n## 단일 스레드 및 다중 스레드 접근 방식의 성능 비교\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음으로, 코드 관점에서 Futures를 이해하고 단일 스레드 방식과 성능을 비교하기 위한 구체적인 예제를 사용해보겠습니다.\n\n여러 웹사이트에서 콘텐츠를 다운로드하고 결과를 출력하는 작업이 있다고 가정해봅시다. 단일 스레드 방식을 사용한다면, 코드 구현은 다음과 같이 보일 것입니다 (단순함을 위해 예외 처리는 간단히 생략했습니다):\n\n```js\nimport requests\nimport time\n \ndef download_one(url):\n    resp = requests.get(url)\n    print('{}에서 {}를 읽었습니다.'.format(url, len(resp.content)))\n    \ndef download_all(sites):\n    for site in sites:\n        download_one(site)\n \ndef main():\n    sites = [\n        'https://en.wikipedia.org/wiki/Portal:Arts',\n        'https://en.wikipedia.org/wiki/Portal:History',\n        'https://en.wikipedia.org/wiki/Portal:Society',\n        'https://en.wikipedia.org/wiki/Portal:Biography',\n        'https://en.wikipedia.org/wiki/Portal:Mathematics',\n        'https://en.wikipedia.org/wiki/Portal:Technology',\n        'https://en.wikipedia.org/wiki/Portal:Geography',\n        'https://en.wikipedia.org/wiki/Portal:Science',\n        'https://en.wikipedia.org/wiki/Computer_science',\n        'https://en.wikipedia.org/wiki/Python_(programming_language)',\n        'https://en.wikipedia.org/wiki/Java_(programming_language)',\n        'https://en.wikipedia.org/wiki/PHP',\n        'https://en.wikipedia.org/wiki/Node.js',\n        'https://en.wikipedia.org/wiki/The_C_Programming_Language',\n        'https://en.wikipedia.org/wiki/Go_(programming_language)'\n    ]\n    start_time = time.perf_counter()\n    download_all(sites)\n    end_time = time.perf_counter()\n    print('{}개 사이트를 {}초에 다운로드했습니다.'.format(len(sites), end_time - start_time))\n    \nif __name__ == '__main__':\n    main()\n```\n\n이 방식은 직접적이고 간단한 접근 방식입니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n먼저 웹사이트 목록을 순회합니다. 그 후, 현재 웹사이트에 대한 다운로드 작업을 수행합니다. 현재 작업이 완료될 때까지 기다렸다가 다음 웹사이트로 넘어가며, 모든 작업이 완료될 때까지 이 과정을 계속합니다.\n\n총 소요 시간은 약 2.4초인 것을 확인할 수 있습니다. 단일 스레드 방식의 장점은 간단함에 있지만, 대부분의 시간이 I/O 작업을 기다리며 보내므로 효율적이지 않습니다. 프로그램은 각 웹사이트의 다운로드가 끝날 때까지 기다려야 다음 작업을 시작할 수 있습니다. 웹사이트 다운로드해야 하는 수가 수천 개에 달하는 현실적인 프로덕션 환경에서는 이 방식이 실행하기에 적합하지 않습니다.\n\n그 다음, 코드의 멀티 스레드 버전을 살펴봅시다:\n\n```js\nimport concurrent.futures\nimport requests\nimport threading\nimport time\n \ndef download_one(url):\n    resp = requests.get(url)\n    print('Read {} from {}'.format(len(resp.content), url))\n \ndef download_all(sites):\n    with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:\n        executor.map(download_one, sites)\n \ndef main():\n    sites = [\n        'https://en.wikipedia.org/wiki/Portal:Arts',\n        'https://en.wikipedia.org/wiki/Portal:History',\n        'https://en.wikipedia.org/wiki/Portal:Society',\n        'https://en.wikipedia.org/wiki/Portal:Biography',\n        'https://en.wikipedia.org/wiki/Portal:Mathematics',\n        'https://en.wikipedia.org/wiki/Portal:Technology',\n        'https://en.wikipedia.org/wiki/Portal:Geography',\n        'https://en.wikipedia.org/wiki/Portal:Science',\n        'https://en.wikipedia.org/wiki/Computer_science',\n        'https://en.wikipedia.org/wiki/Python_(programming_language)',\n        'https://en.wikipedia.org/wiki/Java_(programming_language)',\n        'https://en.wikipedia.org/wiki/PHP',\n        'https://en.wikipedia.org/wiki/Node.js',\n        'https://en.wikipedia.org/wiki/The_C_Programming_Language',\n        'https://en.wikipedia.org/wiki/Go_(programming_language)'\n    ]\n    start_time = time.perf_counter()\n    download_all(sites)\n    end_time = time.perf_counter()\n    print('Download {} sites in {} seconds'.format(len(sites), end_time - start_time))\n\nif __name__ == '__main__':\n    main()\n\n## Output\nRead 151021 from https://en.wikipedia.org/wiki/Portal:Mathematics\nRead 129886 from https://en.wikipedia.org/wiki/Portal:Arts\nRead 107637 from https://en.wikipedia.org/wiki/Portal:Biography\nRead 224118 from https://en.wikipedia.org/wiki/Portal:Society\nRead 184343 from https://en.wikipedia.org/wiki/Portal:History\nRead 167923 from https://en.wikipedia.org/wiki/Portal:Geography\nRead 157811 from https://en.wikipedia.org/wiki/Portal:Technology\nRead 91533 from https://en.wikipedia.org/wiki/Portal:Science\nRead 321352 from https://en.wikipedia.org/wiki/Computer_science\nRead 391905 from https://en.wikipedia.org/wiki/Python_(programming_language)\nRead 180298 from https://en.wikipedia.org/wiki/Node.js\nRead 56765 from https://en.wikipedia.org/wiki/The_C_Programming_Language\nRead 468461 from https://en.wikipedia.org/wiki/PHP\nRead 321417 from https://en.wikipedia.org/wiki/Java_(programming_language)\nRead 324039 from https://en.wikipedia.org/wiki/Go_(programming_language)\nDownload 15 sites in 0.19936635800002023 seconds\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n총 시간이 약 0.2초로 나타나는 것은 효율성이 10배 이상 향상되었다는 사실을 알 수 있어요.\n\n다중 스레드 버전과 단일 스레드 버전 사이의 주요 차이점을 살펴보겠어요:\n\n```js\nwith concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:\n        executor.map(download_one, sites)\n```\n\n여기서는 5개의 스레드를 사용할 수 있는 스레드 풀을 생성했어요. executor.map()은 파이썬 내장 map() 함수와 유사하며, 각각의 urls 요소에 download_one() 함수를 동시에 적용해요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여담이지만, download_one() 함수에서 사용하는 requests.get() 메서드는 스레드 안전(thread-safe)하므로 경합 상태를 일으키지 않고 여러 스레드 환경에서 안전하게 사용할 수 있습니다.\n\n또한, 스레드의 개수는 사용자가 정의할 수 있지만, 더 많은 스레드가 항상 좋은 것은 아닙니다. 그 이유는 스레드를 생성, 유지 및 소멸하는 데 일정한 오버헤드가 발생하기 때문입니다. 스레드의 개수를 지나치게 높게 설정하면 오히려 성능이 떨어질 수 있습니다. 종종 실제 요구 사항에 기반하여 최적의 스레드 개수를 찾기 위해 몇 가지 테스트를 수행해야 합니다.\n\n물론 프로그램 효율성을 향상시키기 위해 병렬성(parallelism)을 사용할 수도 있습니다. 이를 위해 download_all() 함수에서 다음과 같이 변경할 수 있습니다:\n\n```js\nwith futures.ThreadPoolExecutor(workers) as executor\n=>\nwith futures.ProcessPoolExecutor() as executor:\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n코드를 변경해야 하는 부분에서는 ProcessPoolExecutor() 함수를 사용하여 병렬로 작업을 실행할 수 있는 프로세스 풀을 생성합니다. 그러나 여기서 worker 매개변수를 종종 생략하는데, 시스템이 사용 가능한 CPU 코어 수를 자동으로 프로세스로 활용할 수 있기 때문입니다.\n\n이전에 언급한 대로, 병렬성은 일반적으로 CPU 바운드 시나리오에서 사용됩니다. I/O 바운드 작업의 경우 대부분의 시간이 대기 상태에 소요되며, 여러 프로세스를 사용하는 것은 멀티 스레딩과 비교하여 효율성을 향상시키지 않습니다. 실제로 CPU 코어의 제한으로 인해 멀티 프로세싱의 성능이 종종 멀티 스레딩보다 나쁠 수 있습니다.\n\n# Futures란 정확히 무엇인가요?\n\n파이썬에서 Futures 모듈은 concurrent.futures와 asyncio에 위치하며, 둘 다 지연된 작업을 나타냅니다. Futures는 대기 상태에 있는 작업을 래핑하여 큐에 배치합니다. 이러한 작업의 상태는 언제든지 쿼리할 수 있으며, 작업이 완료된 후 결과 또는 예외를 검색할 수도 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n일반적으로 사용자들은 미래(Futures)를 생성하는 방법에 대해 걱정할 필요가 없습니다. 내부 메커니즘이 대신 처리해 주기 때문이죠. 실제로 해야 할 일은 이러한 Futures를 실행할 수 있도록 예약하는 것입니다.\n\n예를 들어, Futures 모듈에서 Executor 클래스를 사용하면 executor.submit(func) 메서드를 사용하여 작업을 제출할 수 있습니다. 이 메서드는 func() 함수를 실행할 수 있도록 예약하고 작업을 나타내는 Future 객체를 반환합니다. 그런 다음 이 Future 객체를 사용하여 작업의 상태를 조회하거나 결과를 검색할 수 있습니다.\n\nFutures 모듈에서 자주 사용되는 몇 가지 메서드는 다음과 같습니다:\n\n- done(): 해당 작업이 완료되었는지 확인하는 메서드입니다. True는 작업이 완료되었음을 나타내고, False는 아직 진행 중이라는 뜻입니다. done()은 비차단 방식으로 동작하며 결과를 즉시 반환합니다.\n- add_done_callback(fn): 이 메서드는 Future가 완료되면 실행될 콜백 함수 fn을 등록합니다. 콜백 함수 fn은 Future가 작업을 완료한 후에 알림을 받고 호출됩니다.\n- result(): 이 메서드는 Future의 결과 또는 예외를 반환합니다. Future가 완료되었을 때 호출합니다. Future가 예외를 만났다면 result()는 해당 예외를 발생시킵니다.\n- as_completed(fs): 이 함수는 Futures fs의 반복자를 가져와 완료될 때마다 Futures를 생성하는 반복자를 반환합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그래서, 앞서 언급한 예제는 다음과 같은 형식으로도 작성할 수 있습니다:\n\n```js\nimport concurrent.futures\nimport requests\nimport time\n\ndef download_one(url):\n    resp = requests.get(url)\n    print('Read {} from {}'.format(len(resp.content), url))\n\ndef download_all(sites):\n    with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:\n        to_do = []\n        for site in sites:\n            future = executor.submit(download_one, site)\n            to_do.append(future)\n\n        for future in concurrent.futures.as_completed(to_do):\n            future.result()\n\ndef main():\n    sites = [\n        'https://en.wikipedia.org/wiki/Portal:Arts',\n        'https://en.wikipedia.org/wiki/Portal:History',\n        'https://en.wikipedia.org/wiki/Portal:Society',\n        'https://en.wikipedia.org/wiki/Portal:Biography',\n        'https://en.wikipedia.org/wiki/Portal:Mathematics',\n        'https://en.wikipedia.org/wiki/Portal:Technology',\n        'https://en.wikipedia.org/wiki/Portal:Geography',\n        'https://en.wikipedia.org/wiki/Portal:Science',\n        'https://en.wikipedia.org/wiki/Computer_science',\n        'https://en.wikipedia.org/wiki/Python_(programming_language)',\n        'https://en.wikipedia.org/wiki/Java_(programming_language)',\n        'https://en.wikipedia.org/wiki/PHP',\n        'https://en.wikipedia.org/wiki/Node.js',\n        'https://en.wikipedia.org/wiki/The_C_Programming_Language',\n        'https://en.wikipedia.org/wiki/Go_(programming_language)'\n    ]\n    start_time = time.perf_counter()\n    download_all(sites)\n    end_time = time.perf_counter()\n    print('Download {} sites in {} seconds'.format(len(sites), end_time - start_time))\n\nif __name__ == '__main__':\n    main()\n\n## 결과\nhttps://en.wikipedia.org/wiki/Portal:Arts에서 129,886을 읽음\nhttps://en.wikipedia.org/wiki/Portal:Biography에서 107,634을 읽음\nhttps://en.wikipedia.org/wiki/Portal:Society에서 224,118을 읽음\nhttps://en.wikipedia.org/wiki/Portal:Mathematics에서 158,984을 읽음\nhttps://en.wikipedia.org/wiki/Portal:History에서 184,343을 읽음\nhttps://en.wikipedia.org/wiki/Portal:Technology에서 157,949을 읽음\nhttps://en.wikipedia.org/wiki/Portal:Geography에서 167,923을 읽음\nhttps://en.wikipedia.org/wiki/Portal:Science에서 94,228을 읽음\nhttps://en.wikipedia.org/wiki/Python_(programming_language)에서 391,905을 읽음\nhttps://en.wikipedia.org/wiki/Computer_science에서 321,352을 읽음\nhttps://en.wikipedia.org/wiki/Node.js에서 180,298을 읽음\nhttps://en.wikipedia.org/wiki/Java_(programming_language)에서 321,417을 읽음\nhttps://en.wikipedia.org/wiki/PHP에서 468,421을 읽음\nhttps://en.wikipedia.org/wiki/The_C_Programming_Language에서 56,765을 읽음\nhttps://en.wikipedia.org/wiki/Go_(programming_language)에서 324,039을 읽음\n15개 사이트를 0.21698231499976828초에 다운로드함\n```\n\n여기서, 우리는 먼저 executor.submit()를 호출하여 각 웹사이트에서 내용을 다운로드하는 작업을 to_do라는 미래 큐에 넣고 실행을 대기시킵니다. 그런 다음 as_completed() 함수를 사용하여 각 미래가 완료될 때마다 결과를 출력합니다.\n\n그러나 미래가 완료되는 순서가 목록의 순서와 일치하는 것은 아님을 유의해야 합니다. 완료 순서는 시스템 스케줄링 및 각 미래의 실행 시간에 따라 달라집니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 왜 멀티스레딩에서 한 번에 하나의 스레드만 실행될 수 있을까요?\n\n이전에 파이썬에서 메인 프로그램에서 한 번에 하나의 스레드만 실행될 수 있다고 언급했습니다. 이게 왜 그런 걸까요?\n\n나중에 더 자세히 배울 Global Interpreter Lock (GIL) 개념을 간단히 소개해 드리겠습니다.\n\n사실 파이썬 인터프리터는 스레드로부터 안전하지 않습니다. 동시 스레드로 인한 레이스 컨디션과 같은 문제를 해결하기 위해 파이썬은 Global Interpreter Lock (GIL)를 도입했습니다. 이 잠금은 한 번에 한 스레드만 파이썬 바이트코드를 실행할 수 있도록 보장합니다. 그러나 스레드가 I/O 작업으로 인해 차단될 때 GIL이 해제되어 다른 스레드가 계속해서 실행될 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결론\n\n이 글에서는 파이썬에서 동시성과 병렬성의 개념과 차이점을 먼저 살펴보았습니다.\n\n동시성은 스레드와 작업 간에 전환을 통해 달성되지만, 어떤 순간에는 한 스레드 또는 작업만 실행될 수 있습니다. 반면에 병렬성은 여러 프로세스가 동시에 실행되는 것을 의미합니다.\n\n동시성은 일반적으로 빈번한 I/O 작업이 있는 시나리오에서 사용되고, 병렬성은 CPU 집약적인 작업에 더 적합합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리는 웹 사이트 콘텐츠를 다운로드하는 예제를 통해 단일 스레드 방식과 Futures를 사용한 멀티 스레딩 버전 사이의 성능 차이를 비교했습니다. 잘 구현된 멀티 스레딩 접근 방식이 프로그램의 효율성을 크게 향상시킬 수 있다는 것이 명백합니다.\n\n또한 Futures의 구체적인 원리를 탐구했습니다. done(), result(), as_completed()과 같은 일반적인 함수들을 다루며, 예제를 통해 그 사용법을 설명했습니다.\n\n기억해야 할 중요한 점은 Python이 글로벌 인터프리터 락(GIL) 때문에 한 번에 하나의 스레드만 실행되도록 한다는 것입니다. 그러나 I/O 작업에 대해서는 스레드가 차단될 때 GIL이 해제되어 다른 스레드가 계속 실행될 수 있습니다.\n\n<img src=\"/TIL/assets/img/2024-07-12-PythonConcurrencyProgrammingFutures_3.png\" />","ogImage":{"url":"/TIL/assets/img/2024-07-12-PythonConcurrencyProgrammingFutures_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-PythonConcurrencyProgrammingFutures_0.png","tag":["Tech"],"readingTime":17},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/TIL/assets/img/2024-07-12-PythonConcurrencyProgrammingFutures_0.png\" alt=\"Image\"></p>\n<p>협업 프로그래밍을 올바르고 합리적으로 사용하면 우리 프로그램에 상당한 성능 향상을 가져다 줄 것입니다. 오늘의 글에서는 파이썬에서 동시성 프로그래밍 및 Future를 중점으로 하는 동시성 프로그래밍을 이해하고 적용하는 방법을 안내하겠습니다.</p>\n<h1>동시성과 병렬성: 차이 이해하기</h1>\n<p>동시성 프로그래밍에 대해 학습할 때 동시성과 병렬성이라는 용어를 함께 사용하는 경우가 많습니다. 이로 인해 많은 사람들이 두 용어가 동일한 것으로 생각되는 오해를 하게 됩니다. 그러나 이는 오인입니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>먼저 일반적으로 오해되는 것을 명확하게 해 봅시다: 파이썬에서 동시성은 여러 작업(스레드 또는 태스크)이 동시에 동시에 발생한다는 것을 의미하지 않습니다. 대신, 한 번에 하나의 작업만 진행되도록 허용하고, 스레드 또는 태스크가 완료될 때까지 서로 전환됩니다. 아래 다이어그램을 살펴보겠습니다:</p>\n<p><img src=\"/TIL/assets/img/2024-07-12-PythonConcurrencyProgrammingFutures_1.png\" alt=\"Concurrency Diagram\"></p>\n<p>이 다이어그램은 태스크 전환을 관리하는 두 가지 다른 방법을 보여줍니다. 이는 파이썬에서 동시성의 두 형태에 대응됩니다: 스레딩과 asyncio입니다.</p>\n<p>스레딩의 경우, 운영 체제는 각 스레드의 모든 세부 정보를 알고 있기 때문에 필요에 따라 스레드 전환을 처리합니다. 여기서의 장점은 프로그래머가 전환 프로세스를 관리할 필요가 없기 때문에 코드를 작성하기가 더 쉽다는 것입니다. 그러나 이는 레이스 컨디션과 같은 문제로 이어질 수 있습니다. 이는 스레드가 단일 명령문 실행 도중에 서로 간섭할 수 있는 상황을 말합니다(e.g., x += 1).</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>그러나 asyncio를 사용할 경우, 주 프로그램이 작업을 전환할 수 있다는 것을 명시적으로 알려주어야 합니다. 이러한 설계는 asyncio 이벤트 루프에 의해 제어되는 방식으로 전환되므로 실행 중에 작업이 충돌하지 않도록 보장하여 경쟁 조건을 피할 수 있도록 도와줍니다.</p>\n<p>병렬성에 대해 이야기하면, 동시에 동시에 실행되는 작업을 가리킵니다. Python에서 이는 멀티 프로세싱을 통해 달성됩니다. 예를 들어, 컴퓨터가 6코어 프로세서를 사용한다면, 실행 속도를 높이기 위해 6개의 프로세스를 동시에 실행할 수 있습니다. 멀티 프로세싱의 기본 아이디어는 다음과 같이 나타낼 수 있습니다:</p>\n<p><img src=\"/TIL/assets/img/2024-07-12-PythonConcurrencyProgrammingFutures_2.png\" alt=\"멀티 프로세싱\"></p>\n<p>두 가지를 비교해보면:</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>동시성은 빈번한 I/O 작업이 발생하는 시나리오에서 자주 사용됩니다. 예를 들어, 웹 사이트에서 여러 파일을 다운로드할 때, I/O 작업에 소요되는 시간이 CPU 처리에 소요되는 시간보다 크게 늘어날 수 있습니다.</p>\n<p>반면에 병렬성은 CPU 집중적인 시나리오에 더 적합합니다. 예를 들어, MapReduce 병렬 계산에서 여러 대의 기계와 프로세서를 사용하여 작업을 여러 코어 또는 시스템에 분산시켜 실행 속도를 높이는 데 활용됩니다.</p>\n<h1>동시성 프로그래밍의 Futures</h1>\n<h2>단일 스레드 및 다중 스레드 접근 방식의 성능 비교</h2>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>다음으로, 코드 관점에서 Futures를 이해하고 단일 스레드 방식과 성능을 비교하기 위한 구체적인 예제를 사용해보겠습니다.</p>\n<p>여러 웹사이트에서 콘텐츠를 다운로드하고 결과를 출력하는 작업이 있다고 가정해봅시다. 단일 스레드 방식을 사용한다면, 코드 구현은 다음과 같이 보일 것입니다 (단순함을 위해 예외 처리는 간단히 생략했습니다):</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> requests\n<span class=\"hljs-keyword\">import</span> time\n \ndef <span class=\"hljs-title function_\">download_one</span>(url):\n    resp = requests.<span class=\"hljs-title function_\">get</span>(url)\n    <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">'{}에서 {}를 읽었습니다.'</span>.<span class=\"hljs-title function_\">format</span>(url, <span class=\"hljs-title function_\">len</span>(resp.<span class=\"hljs-property\">content</span>)))\n    \ndef <span class=\"hljs-title function_\">download_all</span>(sites):\n    <span class=\"hljs-keyword\">for</span> site <span class=\"hljs-keyword\">in</span> <span class=\"hljs-attr\">sites</span>:\n        <span class=\"hljs-title function_\">download_one</span>(site)\n \ndef <span class=\"hljs-title function_\">main</span>():\n    sites = [\n        <span class=\"hljs-string\">'https://en.wikipedia.org/wiki/Portal:Arts'</span>,\n        <span class=\"hljs-string\">'https://en.wikipedia.org/wiki/Portal:History'</span>,\n        <span class=\"hljs-string\">'https://en.wikipedia.org/wiki/Portal:Society'</span>,\n        <span class=\"hljs-string\">'https://en.wikipedia.org/wiki/Portal:Biography'</span>,\n        <span class=\"hljs-string\">'https://en.wikipedia.org/wiki/Portal:Mathematics'</span>,\n        <span class=\"hljs-string\">'https://en.wikipedia.org/wiki/Portal:Technology'</span>,\n        <span class=\"hljs-string\">'https://en.wikipedia.org/wiki/Portal:Geography'</span>,\n        <span class=\"hljs-string\">'https://en.wikipedia.org/wiki/Portal:Science'</span>,\n        <span class=\"hljs-string\">'https://en.wikipedia.org/wiki/Computer_science'</span>,\n        <span class=\"hljs-string\">'https://en.wikipedia.org/wiki/Python_(programming_language)'</span>,\n        <span class=\"hljs-string\">'https://en.wikipedia.org/wiki/Java_(programming_language)'</span>,\n        <span class=\"hljs-string\">'https://en.wikipedia.org/wiki/PHP'</span>,\n        <span class=\"hljs-string\">'https://en.wikipedia.org/wiki/Node.js'</span>,\n        <span class=\"hljs-string\">'https://en.wikipedia.org/wiki/The_C_Programming_Language'</span>,\n        <span class=\"hljs-string\">'https://en.wikipedia.org/wiki/Go_(programming_language)'</span>\n    ]\n    start_time = time.<span class=\"hljs-title function_\">perf_counter</span>()\n    <span class=\"hljs-title function_\">download_all</span>(sites)\n    end_time = time.<span class=\"hljs-title function_\">perf_counter</span>()\n    <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">'{}개 사이트를 {}초에 다운로드했습니다.'</span>.<span class=\"hljs-title function_\">format</span>(<span class=\"hljs-title function_\">len</span>(sites), end_time - start_time))\n    \n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    <span class=\"hljs-title function_\">main</span>()\n</code></pre>\n<p>이 방식은 직접적이고 간단한 접근 방식입니다:</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>먼저 웹사이트 목록을 순회합니다. 그 후, 현재 웹사이트에 대한 다운로드 작업을 수행합니다. 현재 작업이 완료될 때까지 기다렸다가 다음 웹사이트로 넘어가며, 모든 작업이 완료될 때까지 이 과정을 계속합니다.</p>\n<p>총 소요 시간은 약 2.4초인 것을 확인할 수 있습니다. 단일 스레드 방식의 장점은 간단함에 있지만, 대부분의 시간이 I/O 작업을 기다리며 보내므로 효율적이지 않습니다. 프로그램은 각 웹사이트의 다운로드가 끝날 때까지 기다려야 다음 작업을 시작할 수 있습니다. 웹사이트 다운로드해야 하는 수가 수천 개에 달하는 현실적인 프로덕션 환경에서는 이 방식이 실행하기에 적합하지 않습니다.</p>\n<p>그 다음, 코드의 멀티 스레드 버전을 살펴봅시다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> concurrent.<span class=\"hljs-property\">futures</span>\n<span class=\"hljs-keyword\">import</span> requests\n<span class=\"hljs-keyword\">import</span> threading\n<span class=\"hljs-keyword\">import</span> time\n \ndef <span class=\"hljs-title function_\">download_one</span>(url):\n    resp = requests.<span class=\"hljs-title function_\">get</span>(url)\n    <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">'Read {} from {}'</span>.<span class=\"hljs-title function_\">format</span>(<span class=\"hljs-title function_\">len</span>(resp.<span class=\"hljs-property\">content</span>), url))\n \ndef <span class=\"hljs-title function_\">download_all</span>(sites):\n    <span class=\"hljs-keyword\">with</span> concurrent.<span class=\"hljs-property\">futures</span>.<span class=\"hljs-title class_\">ThreadPoolExecutor</span>(max_workers=<span class=\"hljs-number\">5</span>) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-attr\">executor</span>:\n        executor.<span class=\"hljs-title function_\">map</span>(download_one, sites)\n \ndef <span class=\"hljs-title function_\">main</span>():\n    sites = [\n        <span class=\"hljs-string\">'https://en.wikipedia.org/wiki/Portal:Arts'</span>,\n        <span class=\"hljs-string\">'https://en.wikipedia.org/wiki/Portal:History'</span>,\n        <span class=\"hljs-string\">'https://en.wikipedia.org/wiki/Portal:Society'</span>,\n        <span class=\"hljs-string\">'https://en.wikipedia.org/wiki/Portal:Biography'</span>,\n        <span class=\"hljs-string\">'https://en.wikipedia.org/wiki/Portal:Mathematics'</span>,\n        <span class=\"hljs-string\">'https://en.wikipedia.org/wiki/Portal:Technology'</span>,\n        <span class=\"hljs-string\">'https://en.wikipedia.org/wiki/Portal:Geography'</span>,\n        <span class=\"hljs-string\">'https://en.wikipedia.org/wiki/Portal:Science'</span>,\n        <span class=\"hljs-string\">'https://en.wikipedia.org/wiki/Computer_science'</span>,\n        <span class=\"hljs-string\">'https://en.wikipedia.org/wiki/Python_(programming_language)'</span>,\n        <span class=\"hljs-string\">'https://en.wikipedia.org/wiki/Java_(programming_language)'</span>,\n        <span class=\"hljs-string\">'https://en.wikipedia.org/wiki/PHP'</span>,\n        <span class=\"hljs-string\">'https://en.wikipedia.org/wiki/Node.js'</span>,\n        <span class=\"hljs-string\">'https://en.wikipedia.org/wiki/The_C_Programming_Language'</span>,\n        <span class=\"hljs-string\">'https://en.wikipedia.org/wiki/Go_(programming_language)'</span>\n    ]\n    start_time = time.<span class=\"hljs-title function_\">perf_counter</span>()\n    <span class=\"hljs-title function_\">download_all</span>(sites)\n    end_time = time.<span class=\"hljs-title function_\">perf_counter</span>()\n    <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">'Download {} sites in {} seconds'</span>.<span class=\"hljs-title function_\">format</span>(<span class=\"hljs-title function_\">len</span>(sites), end_time - start_time))\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    <span class=\"hljs-title function_\">main</span>()\n\n## <span class=\"hljs-title class_\">Output</span>\n<span class=\"hljs-title class_\">Read</span> <span class=\"hljs-number\">151021</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//en.wikipedia.org/wiki/Portal:Mathematics</span>\n<span class=\"hljs-title class_\">Read</span> <span class=\"hljs-number\">129886</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//en.wikipedia.org/wiki/Portal:Arts</span>\n<span class=\"hljs-title class_\">Read</span> <span class=\"hljs-number\">107637</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//en.wikipedia.org/wiki/Portal:Biography</span>\n<span class=\"hljs-title class_\">Read</span> <span class=\"hljs-number\">224118</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//en.wikipedia.org/wiki/Portal:Society</span>\n<span class=\"hljs-title class_\">Read</span> <span class=\"hljs-number\">184343</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//en.wikipedia.org/wiki/Portal:History</span>\n<span class=\"hljs-title class_\">Read</span> <span class=\"hljs-number\">167923</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//en.wikipedia.org/wiki/Portal:Geography</span>\n<span class=\"hljs-title class_\">Read</span> <span class=\"hljs-number\">157811</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//en.wikipedia.org/wiki/Portal:Technology</span>\n<span class=\"hljs-title class_\">Read</span> <span class=\"hljs-number\">91533</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//en.wikipedia.org/wiki/Portal:Science</span>\n<span class=\"hljs-title class_\">Read</span> <span class=\"hljs-number\">321352</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//en.wikipedia.org/wiki/Computer_science</span>\n<span class=\"hljs-title class_\">Read</span> <span class=\"hljs-number\">391905</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//en.wikipedia.org/wiki/Python_(programming_language)</span>\n<span class=\"hljs-title class_\">Read</span> <span class=\"hljs-number\">180298</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//en.wikipedia.org/wiki/Node.js</span>\n<span class=\"hljs-title class_\">Read</span> <span class=\"hljs-number\">56765</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//en.wikipedia.org/wiki/The_C_Programming_Language</span>\n<span class=\"hljs-title class_\">Read</span> <span class=\"hljs-number\">468461</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//en.wikipedia.org/wiki/PHP</span>\n<span class=\"hljs-title class_\">Read</span> <span class=\"hljs-number\">321417</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//en.wikipedia.org/wiki/Java_(programming_language)</span>\n<span class=\"hljs-title class_\">Read</span> <span class=\"hljs-number\">324039</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//en.wikipedia.org/wiki/Go_(programming_language)</span>\n<span class=\"hljs-title class_\">Download</span> <span class=\"hljs-number\">15</span> sites <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">0.19936635800002023</span> seconds\n</code></pre>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>총 시간이 약 0.2초로 나타나는 것은 효율성이 10배 이상 향상되었다는 사실을 알 수 있어요.</p>\n<p>다중 스레드 버전과 단일 스레드 버전 사이의 주요 차이점을 살펴보겠어요:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">with</span> concurrent.<span class=\"hljs-property\">futures</span>.<span class=\"hljs-title class_\">ThreadPoolExecutor</span>(max_workers=<span class=\"hljs-number\">5</span>) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-attr\">executor</span>:\n        executor.<span class=\"hljs-title function_\">map</span>(download_one, sites)\n</code></pre>\n<p>여기서는 5개의 스레드를 사용할 수 있는 스레드 풀을 생성했어요. executor.map()은 파이썬 내장 map() 함수와 유사하며, 각각의 urls 요소에 download_one() 함수를 동시에 적용해요.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>여담이지만, download_one() 함수에서 사용하는 requests.get() 메서드는 스레드 안전(thread-safe)하므로 경합 상태를 일으키지 않고 여러 스레드 환경에서 안전하게 사용할 수 있습니다.</p>\n<p>또한, 스레드의 개수는 사용자가 정의할 수 있지만, 더 많은 스레드가 항상 좋은 것은 아닙니다. 그 이유는 스레드를 생성, 유지 및 소멸하는 데 일정한 오버헤드가 발생하기 때문입니다. 스레드의 개수를 지나치게 높게 설정하면 오히려 성능이 떨어질 수 있습니다. 종종 실제 요구 사항에 기반하여 최적의 스레드 개수를 찾기 위해 몇 가지 테스트를 수행해야 합니다.</p>\n<p>물론 프로그램 효율성을 향상시키기 위해 병렬성(parallelism)을 사용할 수도 있습니다. 이를 위해 download_all() 함수에서 다음과 같이 변경할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">with</span> futures.<span class=\"hljs-title class_\">ThreadPoolExecutor</span>(workers) <span class=\"hljs-keyword\">as</span> executor\n=>\n<span class=\"hljs-keyword\">with</span> futures.<span class=\"hljs-title class_\">ProcessPoolExecutor</span>() <span class=\"hljs-keyword\">as</span> <span class=\"hljs-attr\">executor</span>:\n</code></pre>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>코드를 변경해야 하는 부분에서는 ProcessPoolExecutor() 함수를 사용하여 병렬로 작업을 실행할 수 있는 프로세스 풀을 생성합니다. 그러나 여기서 worker 매개변수를 종종 생략하는데, 시스템이 사용 가능한 CPU 코어 수를 자동으로 프로세스로 활용할 수 있기 때문입니다.</p>\n<p>이전에 언급한 대로, 병렬성은 일반적으로 CPU 바운드 시나리오에서 사용됩니다. I/O 바운드 작업의 경우 대부분의 시간이 대기 상태에 소요되며, 여러 프로세스를 사용하는 것은 멀티 스레딩과 비교하여 효율성을 향상시키지 않습니다. 실제로 CPU 코어의 제한으로 인해 멀티 프로세싱의 성능이 종종 멀티 스레딩보다 나쁠 수 있습니다.</p>\n<h1>Futures란 정확히 무엇인가요?</h1>\n<p>파이썬에서 Futures 모듈은 concurrent.futures와 asyncio에 위치하며, 둘 다 지연된 작업을 나타냅니다. Futures는 대기 상태에 있는 작업을 래핑하여 큐에 배치합니다. 이러한 작업의 상태는 언제든지 쿼리할 수 있으며, 작업이 완료된 후 결과 또는 예외를 검색할 수도 있습니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>일반적으로 사용자들은 미래(Futures)를 생성하는 방법에 대해 걱정할 필요가 없습니다. 내부 메커니즘이 대신 처리해 주기 때문이죠. 실제로 해야 할 일은 이러한 Futures를 실행할 수 있도록 예약하는 것입니다.</p>\n<p>예를 들어, Futures 모듈에서 Executor 클래스를 사용하면 executor.submit(func) 메서드를 사용하여 작업을 제출할 수 있습니다. 이 메서드는 func() 함수를 실행할 수 있도록 예약하고 작업을 나타내는 Future 객체를 반환합니다. 그런 다음 이 Future 객체를 사용하여 작업의 상태를 조회하거나 결과를 검색할 수 있습니다.</p>\n<p>Futures 모듈에서 자주 사용되는 몇 가지 메서드는 다음과 같습니다:</p>\n<ul>\n<li>done(): 해당 작업이 완료되었는지 확인하는 메서드입니다. True는 작업이 완료되었음을 나타내고, False는 아직 진행 중이라는 뜻입니다. done()은 비차단 방식으로 동작하며 결과를 즉시 반환합니다.</li>\n<li>add_done_callback(fn): 이 메서드는 Future가 완료되면 실행될 콜백 함수 fn을 등록합니다. 콜백 함수 fn은 Future가 작업을 완료한 후에 알림을 받고 호출됩니다.</li>\n<li>result(): 이 메서드는 Future의 결과 또는 예외를 반환합니다. Future가 완료되었을 때 호출합니다. Future가 예외를 만났다면 result()는 해당 예외를 발생시킵니다.</li>\n<li>as_completed(fs): 이 함수는 Futures fs의 반복자를 가져와 완료될 때마다 Futures를 생성하는 반복자를 반환합니다.</li>\n</ul>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>그래서, 앞서 언급한 예제는 다음과 같은 형식으로도 작성할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> concurrent.<span class=\"hljs-property\">futures</span>\n<span class=\"hljs-keyword\">import</span> requests\n<span class=\"hljs-keyword\">import</span> time\n\ndef <span class=\"hljs-title function_\">download_one</span>(url):\n    resp = requests.<span class=\"hljs-title function_\">get</span>(url)\n    <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">'Read {} from {}'</span>.<span class=\"hljs-title function_\">format</span>(<span class=\"hljs-title function_\">len</span>(resp.<span class=\"hljs-property\">content</span>), url))\n\ndef <span class=\"hljs-title function_\">download_all</span>(sites):\n    <span class=\"hljs-keyword\">with</span> concurrent.<span class=\"hljs-property\">futures</span>.<span class=\"hljs-title class_\">ThreadPoolExecutor</span>(max_workers=<span class=\"hljs-number\">5</span>) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-attr\">executor</span>:\n        to_do = []\n        <span class=\"hljs-keyword\">for</span> site <span class=\"hljs-keyword\">in</span> <span class=\"hljs-attr\">sites</span>:\n            future = executor.<span class=\"hljs-title function_\">submit</span>(download_one, site)\n            to_do.<span class=\"hljs-title function_\">append</span>(future)\n\n        <span class=\"hljs-keyword\">for</span> future <span class=\"hljs-keyword\">in</span> concurrent.<span class=\"hljs-property\">futures</span>.<span class=\"hljs-title function_\">as_completed</span>(to_do):\n            future.<span class=\"hljs-title function_\">result</span>()\n\ndef <span class=\"hljs-title function_\">main</span>():\n    sites = [\n        <span class=\"hljs-string\">'https://en.wikipedia.org/wiki/Portal:Arts'</span>,\n        <span class=\"hljs-string\">'https://en.wikipedia.org/wiki/Portal:History'</span>,\n        <span class=\"hljs-string\">'https://en.wikipedia.org/wiki/Portal:Society'</span>,\n        <span class=\"hljs-string\">'https://en.wikipedia.org/wiki/Portal:Biography'</span>,\n        <span class=\"hljs-string\">'https://en.wikipedia.org/wiki/Portal:Mathematics'</span>,\n        <span class=\"hljs-string\">'https://en.wikipedia.org/wiki/Portal:Technology'</span>,\n        <span class=\"hljs-string\">'https://en.wikipedia.org/wiki/Portal:Geography'</span>,\n        <span class=\"hljs-string\">'https://en.wikipedia.org/wiki/Portal:Science'</span>,\n        <span class=\"hljs-string\">'https://en.wikipedia.org/wiki/Computer_science'</span>,\n        <span class=\"hljs-string\">'https://en.wikipedia.org/wiki/Python_(programming_language)'</span>,\n        <span class=\"hljs-string\">'https://en.wikipedia.org/wiki/Java_(programming_language)'</span>,\n        <span class=\"hljs-string\">'https://en.wikipedia.org/wiki/PHP'</span>,\n        <span class=\"hljs-string\">'https://en.wikipedia.org/wiki/Node.js'</span>,\n        <span class=\"hljs-string\">'https://en.wikipedia.org/wiki/The_C_Programming_Language'</span>,\n        <span class=\"hljs-string\">'https://en.wikipedia.org/wiki/Go_(programming_language)'</span>\n    ]\n    start_time = time.<span class=\"hljs-title function_\">perf_counter</span>()\n    <span class=\"hljs-title function_\">download_all</span>(sites)\n    end_time = time.<span class=\"hljs-title function_\">perf_counter</span>()\n    <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">'Download {} sites in {} seconds'</span>.<span class=\"hljs-title function_\">format</span>(<span class=\"hljs-title function_\">len</span>(sites), end_time - start_time))\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    <span class=\"hljs-title function_\">main</span>()\n\n## 결과\n<span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//en.wikipedia.org/wiki/Portal:Arts에서 129,886을 읽음</span>\n<span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//en.wikipedia.org/wiki/Portal:Biography에서 107,634을 읽음</span>\n<span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//en.wikipedia.org/wiki/Portal:Society에서 224,118을 읽음</span>\n<span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//en.wikipedia.org/wiki/Portal:Mathematics에서 158,984을 읽음</span>\n<span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//en.wikipedia.org/wiki/Portal:History에서 184,343을 읽음</span>\n<span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//en.wikipedia.org/wiki/Portal:Technology에서 157,949을 읽음</span>\n<span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//en.wikipedia.org/wiki/Portal:Geography에서 167,923을 읽음</span>\n<span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//en.wikipedia.org/wiki/Portal:Science에서 94,228을 읽음</span>\n<span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//en.wikipedia.org/wiki/Python_(programming_language)에서 391,905을 읽음</span>\n<span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//en.wikipedia.org/wiki/Computer_science에서 321,352을 읽음</span>\n<span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//en.wikipedia.org/wiki/Node.js에서 180,298을 읽음</span>\n<span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//en.wikipedia.org/wiki/Java_(programming_language)에서 321,417을 읽음</span>\n<span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//en.wikipedia.org/wiki/PHP에서 468,421을 읽음</span>\n<span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//en.wikipedia.org/wiki/The_C_Programming_Language에서 56,765을 읽음</span>\n<span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//en.wikipedia.org/wiki/Go_(programming_language)에서 324,039을 읽음</span>\n<span class=\"hljs-number\">15</span>개 사이트를 <span class=\"hljs-number\">0.21698231499976828</span>초에 다운로드함\n</code></pre>\n<p>여기서, 우리는 먼저 executor.submit()를 호출하여 각 웹사이트에서 내용을 다운로드하는 작업을 to_do라는 미래 큐에 넣고 실행을 대기시킵니다. 그런 다음 as_completed() 함수를 사용하여 각 미래가 완료될 때마다 결과를 출력합니다.</p>\n<p>그러나 미래가 완료되는 순서가 목록의 순서와 일치하는 것은 아님을 유의해야 합니다. 완료 순서는 시스템 스케줄링 및 각 미래의 실행 시간에 따라 달라집니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h2>왜 멀티스레딩에서 한 번에 하나의 스레드만 실행될 수 있을까요?</h2>\n<p>이전에 파이썬에서 메인 프로그램에서 한 번에 하나의 스레드만 실행될 수 있다고 언급했습니다. 이게 왜 그런 걸까요?</p>\n<p>나중에 더 자세히 배울 Global Interpreter Lock (GIL) 개념을 간단히 소개해 드리겠습니다.</p>\n<p>사실 파이썬 인터프리터는 스레드로부터 안전하지 않습니다. 동시 스레드로 인한 레이스 컨디션과 같은 문제를 해결하기 위해 파이썬은 Global Interpreter Lock (GIL)를 도입했습니다. 이 잠금은 한 번에 한 스레드만 파이썬 바이트코드를 실행할 수 있도록 보장합니다. 그러나 스레드가 I/O 작업으로 인해 차단될 때 GIL이 해제되어 다른 스레드가 계속해서 실행될 수 있습니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h1>결론</h1>\n<p>이 글에서는 파이썬에서 동시성과 병렬성의 개념과 차이점을 먼저 살펴보았습니다.</p>\n<p>동시성은 스레드와 작업 간에 전환을 통해 달성되지만, 어떤 순간에는 한 스레드 또는 작업만 실행될 수 있습니다. 반면에 병렬성은 여러 프로세스가 동시에 실행되는 것을 의미합니다.</p>\n<p>동시성은 일반적으로 빈번한 I/O 작업이 있는 시나리오에서 사용되고, 병렬성은 CPU 집약적인 작업에 더 적합합니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>우리는 웹 사이트 콘텐츠를 다운로드하는 예제를 통해 단일 스레드 방식과 Futures를 사용한 멀티 스레딩 버전 사이의 성능 차이를 비교했습니다. 잘 구현된 멀티 스레딩 접근 방식이 프로그램의 효율성을 크게 향상시킬 수 있다는 것이 명백합니다.</p>\n<p>또한 Futures의 구체적인 원리를 탐구했습니다. done(), result(), as_completed()과 같은 일반적인 함수들을 다루며, 예제를 통해 그 사용법을 설명했습니다.</p>\n<p>기억해야 할 중요한 점은 Python이 글로벌 인터프리터 락(GIL) 때문에 한 번에 하나의 스레드만 실행되도록 한다는 것입니다. 그러나 I/O 작업에 대해서는 스레드가 차단될 때 GIL이 해제되어 다른 스레드가 계속 실행될 수 있습니다.</p>\n<img src=\"/TIL/assets/img/2024-07-12-PythonConcurrencyProgrammingFutures_3.png\">\n</body>\n</html>\n"},"__N_SSG":true}