{"pageProps":{"post":{"title":"게으른 개발자를 위한 필수 효율적인 파이썬 데코레이터 5가지","description":"","date":"2024-07-12 20:47","slug":"2024-07-12-EssentialforLazyDevelopersFiveEfficientPythonDecorators","content":"\n\n<img src=\"/TIL/assets/img/2024-07-12-EssentialforLazyDevelopersFiveEfficientPythonDecorators_0.png\" />\n\n파이썬은 가독성이 뛰어나고 데이터 분석 및 웹 개발과 같은 여러 분야에서 강력한 응용 프로그램을 제공하여 개인적으로 가장 좋아하는 프로그래밍 언어입니다.\n\n하지만, 충분한 코드를 작성하고 있음에도 불구하고, 제가 절대적으로 필요한 경우가 아닌 한 @staticmethod를 사용하여 클래스 내의 정적 메서드를 꾸미는 데코레이터를 거의 사용하지 않습니다.\n\n그러나 코드 리뷰 중에 코드에 소개된 예외 처리 데코레이터를 발견했는데, 이는 제 생각을 바꾸어 코드를 더 읽기 쉽게 만들었으며 간결한 형태로 강력한 기능을 제공했습니다. 이것이 나의 호기심을 자극하여 데코레이터의 다른 기능을 탐구하게 만들었으므로, 이 글에서는 데코레이터의 개념을 깊이 탐구하고 우리의 파이썬 코드를 개선하는 데 도움이 되는 다섯 가지 실용적인 데코레이터를 소개하겠습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 데코레이터란\n\n![image](/TIL/assets/img/2024-07-12-EssentialforLazyDevelopersFiveEfficientPythonDecorators_1.png)\n\n데코레이터는 파이썬의 강력한 언어 기능으로, 원본 함수 코드를 수정하지 않고도 기능을 동적으로 추가하거나 함수 동작을 수정할 수 있게 해줍니다. 데코레이터는 다른 함수나 클래스를 매개변수로 받아 새로운 함수나 클래스를 반환하는 함수입니다.\n\n데코레이터는 함수를 수정, 확장 또는 래핑하여 코드를 보다 가독성 있고 유지보수하기 쉽게 만드는 간결하고 우아한 방법을 제공합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n데코레이터는 일반적으로 다음과 같은 시나리오에서 사용됩니다:\n\n- 추가 기능 또는 로직 추가, 로깅, 성능 분석, 입력 유효성 검사 등;\n- 함수의 동작 수정, 결과 캐싱, 재시도 메커니즘 추가 또는 입력 매개변수를 가로채서 매개변수를 확인하고 많은 assert 문을 사용하는 대신;\n- 관심을 분리하고 자르로 자르로 사용되는 관심사항을 핵심 비즈니스 로직과 분리합니다.\n\n# 5 매우 간단하지만 유용한 데코레이터\n\n## 01 타이머: 함수 실행 시간 측정\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n코드 성능 최적화는 매우 중요합니다. 이 데코레이터는 특정 함수의 실행 시간을 추적하고 경과 시간을 출력하는 데 도움을 줍니다. 이 데코레이터로 함수를 감싸면 병목 현상을 신속하게 식별하고 코드의 핵심 부분을 최적화할 수 있습니다.\n\n```js\nimport time\n\ndef timer(func):\n    def wrapper(*args, **kwargs):\n        # 타이머 시작\n        start_time = time.time()\n        # 데코레이트된 함수 호출\n        result = func(*args, **kwargs)\n        # 시간 다시 측정\n        end_time = time.time()\n        # 경과 시간 계산 및 출력\n        execution_time = end_time - start_time\n        print(f\"실행 시간: {execution_time} 초\")\n        # 데코레이트된 함수 실행 결과 반환\n        return result\n    # wrapper 함수에 대한 참조 반환\n    return wrapper\n```\n\n파이썬에서 데코레이터를 만들려면 timer라는 함수를 정의해야 합니다. 이 함수는 데코레이터 함수임을 나타내는 func라는 매개변수를 받습니다. timer 함수 내부에서는 원하는 함수를 데코레이트하기 위해 매개변수를 일반적으로 전달하는 wrapper라는 다른 함수를 정의합니다.\n\nwrapper 함수 내에서는 제공된 인수를 사용하여 필요한 함수를 호출합니다. 이렇게 할 수 있습니다: result = func(*args, **kwargs).\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마지막으로, 래퍼 함수는 장식된 함수의 실행 결과를 반환합니다. 데코레이터 함수는 방금 만든 래퍼 함수에 대한 참조를 반환해야 합니다.\n\n데코레이터를 활용하기 위해서는 원하는 함수에 @ 기호를 사용하여 적용하면 됩니다.\n\n```js\n@timer\ndef train_model():\n    print(\"Starting the model training function...\")\n    # 프로그램을 5초간 일시 중지하여 함수 실행을 시뮬레이션합니다\n    print(\"Model training completed!\")\n\ntrain_model()\n```\n\n## 02 debugger: Make Debug Easier\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n유용한 추가 래퍼 함수를 만들어 디버깅을 용이하게 할 수 있습니다. 각 함수의 입력 및 출력을 출력하여 실행 흐름을 확인할 수 있습니다. 이 방법을 통해 복수의 print 문으로 애플리케이션을 혼란스럽게 만들 필요가 없습니다.\n\n```python\ndef debugger(func):\n    def wrapper(*args, **kwargs):\n        # 함수 이름과 인수 출력\n        print(f\"Calling {func.__name__} with args: {args} kwargs: {kwargs}\")\n        # 함수 호출\n        result = func(*args, **kwargs)\n        # 결과 출력\n        print(f\"{func.__name__} returned: {result}\")\n        return result\n    return wrapper\n```\n\n호출된 함수의 이름을 가져오기 위해 __name__ 매개변수를 사용할 수 있으며, args와 kwargs 매개변수를 사용하여 전달된 내용을 출력할 수 있습니다.\n\n```python\n@debugger\ndef add_numbers(x, y):\n    return x + y\nadd_numbers(7, y=5)  \n# 출력: Calling add_numbers with args: (7,) kwargs: {'y': 5}\n# add_numbers returned: 12\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 03 memoize: 반환 결과 캐시\n\n우리는 코드 베이스에서 특정 코드 조각들의 동작을 거의 변경하지 않습니다. 그러나 이러한 코드들의 반복 실행은 상당한 컴퓨팅 자원을 소비할 수 있습니다. 이 경우 memoize 데코레이터를 사용하여 함수 호출을 캐시할 수 있습니다.\n\n이 시점에서 입력이 동일하면 함수는 한 번만 실행됩니다. 각 후속 실행에서는 결과가 캐시에서 가져옵니다. 따라서 비용이 많이 드는 계산을 항상 수행할 필요가 없습니다.\n\n```js\ndef memoize(func):\n    cache = {}\n    def wrapper(*args):\n        if args in cache:\n            return cache[args]\n        else:\n            result = func(*args)\n            cache[args] = result\n            return result\n    return wrapper\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n데코레이터는 함수 매개변수와 반환 값을 저장하는 사전(dictionary)을 사용합니다. 이 함수를 실행할 때, 데코레이터는 이전 결과 사전을 확인합니다. 저장된 값이 없을 때만 실제 함수가 호출됩니다.\n\n아래는 피보나치 수 계산 함수입니다. 이 함수는 재귀적으로 작동하므로 동일한 함수가 여러 번 실행됩니다. 그러나 캐싱을 사용하면 이 과정을 빠르게 만들 수 있습니다.\n\n```js\n@memoize\ndef fibonacci(n):\n    if n <= 1:\n        return n\n    else:\n        return fibonacci(n-1) + fibonacci(n-2)\n```\n\n이 함수의 실행 시간을 캐시를 사용하거나 사용하지 않을 때 각각 측정한 결과입니다. 캐시된 버전은 실행에 몇 밀리초만 소요되지만, 캐시되지 않은 버전은 거의 1분이 소요됩니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이전 실행 결과를 저장할 때 사전을 사용하는 것은 간단하고 직관적인 방법입니다. 더 강력한 기능을 제공하기 위해 데이터를 캐시하는 인메모리 데이터베이스인 Redis나 Memcache와 같은 것을 사용할 수 있습니다.\n\n## 04 재시도: 실행 재시도\n\n데이터 과학과 소프트웨어 개발에서는 종종 외부 시스템에 의존하지만 모든 외부 시스템이 신뢰성있는 것은 아닙니다.\n\n예기치 않은 이벤트가 발생할 때 코드가 일정 시간을 기다려 외부 시스템이 복구되기를 기다리고 다시 시도할 수 있기를 원할 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그런 retry 로직을 Python 데코레이터로 구현하는 것이 좋습니다. 이렇게 하면 재시도 동작을 어떤 함수에든 적용할 수 있어요.\n\n```python\nimport time\n\ndef retry(max_attempts, delay=1):\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            attempts = 0\n            while attempts < max_attempts:\n                try:\n                    return func(*args, **kwargs)\n                except Exception as e:\n                    attempts += 1\n                    print(f\"Attempt {attempts} failed: {e}\")\n                    time.sleep(delay)\n            print(f\"Function failed after {max_attempts} attempts\")\n        return wrapper\n    return decorator\n```\n\n우리는 데코레이터에 대한 다른 래퍼 함수를 정의할 수 있어요. 이전 예제와 유사하게 구현해요. 그러나 이번에는 검증 함수를 입력 변수로 전달하는 대신 max_attempts와 delay와 같은 특정 매개변수를 전달해요.\n\n데코레이터 함수가 호출되면 wrapper 함수가 호출돼요. 이 함수는 시도 횟수(0부터 시작)를 기록하고 while 루프에 진입해요. 루프는 장식된 함수를 실행하려고 시도하고, 성공하면 결과를 즉시 반환해요. 그러나 예외가 발생하면 시도 횟수를 증가시키고, 시도 횟수와 발생한 특정 예외를 나타내는 오류 메시지를 출력해요. 지정된 지연 시간 동안 함수를 다시 시도하기 전에 time.sleep을 사용해요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 함수를 호출하려면 각 함수 호출 사이의 최대 시도 횟수와 시간 간격(초)을 지정할 수 있습니다.\n\n```js\n@retry(max_attempts=3, delay=2)\ndef fetch_data(url):\n    print(\"데이터를 가져오는 중..\")\n    # 서버 응답 없음을 모의하기 위해 시간 초과 오류 발생..\n    raise TimeoutError(\"서버가 응답하지 않습니다.\")\nfetch_data(\"https://example.com/data\")  \n# 시도 간격이 2초인 3번 재시도\n```\n\n## 05 exception_handler: Graceful Exception Handling\n\nexception_handler는 함수에서 발생한 모든 예외를 잡아 적절히 처리할 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n요구 사항에 맞게 래퍼 함수에서 예외 처리를 사용자 정의할 수 있습니다. 예를 들어 예외를 로깅하거나 추가 오류 처리 단계를 수행할 수 있습니다.\n\n```js\ndef exception_handler(func):\n    def wrapper(*args, **kwargs):\n        try:\n            return func(*args, **kwargs)\n        except Exception as e:\n            # 예외 처리\n            print(f\"예외가 발생했습니다: {str(e)}\")\n            # 선택적으로 추가 오류 처리 또는 로깅 수행\n            # 필요한 경우 예외를 다시 발생시킵니다.\n    return wrapper\n```\n\n이것은 우리의 코드를 간소화하고 예외 처리 및 오류 로깅을 처리하는 통합된 절차를 수립하는 데 매우 유용합니다.\n\n```js\n@exception_handler\ndef divide(x, y):\n    result = x / y\n    return result\ndivide(10, 0)  \n# 출력: 예외가 발생했습니다: division by zero\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 요약\n\n![이미지](/TIL/assets/img/2024-07-12-EssentialforLazyDevelopersFiveEfficientPythonDecorators_2.png)\n\n데코레이터는 함수에 새로운 동작을 쉽게 적용할 수 있는 매우 편리한 방법입니다. 래퍼(wrapper)를 사용하여 복잡한 작업을 간소화하고 코드 가독성을 높이며 생산성을 향상시킬 수 있습니다.\n\n![이미지](/TIL/assets/img/2024-07-12-EssentialforLazyDevelopersFiveEfficientPythonDecorators_3.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 👋 만약 이 게시물이 도움이 된다면, 작가를 지원하는 의미로 아래 👏 버튼을 클릭해 주세요 \n\n## 🚀 FAUN 개발자 커뮤니티에 가입하고 매주 이메일로 유사한 이야기를 받아보세요","ogImage":{"url":"/TIL/assets/img/2024-07-12-EssentialforLazyDevelopersFiveEfficientPythonDecorators_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-EssentialforLazyDevelopersFiveEfficientPythonDecorators_0.png","tag":["Tech"],"readingTime":11},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<img src=\"/TIL/assets/img/2024-07-12-EssentialforLazyDevelopersFiveEfficientPythonDecorators_0.png\">\n<p>파이썬은 가독성이 뛰어나고 데이터 분석 및 웹 개발과 같은 여러 분야에서 강력한 응용 프로그램을 제공하여 개인적으로 가장 좋아하는 프로그래밍 언어입니다.</p>\n<p>하지만, 충분한 코드를 작성하고 있음에도 불구하고, 제가 절대적으로 필요한 경우가 아닌 한 @staticmethod를 사용하여 클래스 내의 정적 메서드를 꾸미는 데코레이터를 거의 사용하지 않습니다.</p>\n<p>그러나 코드 리뷰 중에 코드에 소개된 예외 처리 데코레이터를 발견했는데, 이는 제 생각을 바꾸어 코드를 더 읽기 쉽게 만들었으며 간결한 형태로 강력한 기능을 제공했습니다. 이것이 나의 호기심을 자극하여 데코레이터의 다른 기능을 탐구하게 만들었으므로, 이 글에서는 데코레이터의 개념을 깊이 탐구하고 우리의 파이썬 코드를 개선하는 데 도움이 되는 다섯 가지 실용적인 데코레이터를 소개하겠습니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h1>데코레이터란</h1>\n<p><img src=\"/TIL/assets/img/2024-07-12-EssentialforLazyDevelopersFiveEfficientPythonDecorators_1.png\" alt=\"image\"></p>\n<p>데코레이터는 파이썬의 강력한 언어 기능으로, 원본 함수 코드를 수정하지 않고도 기능을 동적으로 추가하거나 함수 동작을 수정할 수 있게 해줍니다. 데코레이터는 다른 함수나 클래스를 매개변수로 받아 새로운 함수나 클래스를 반환하는 함수입니다.</p>\n<p>데코레이터는 함수를 수정, 확장 또는 래핑하여 코드를 보다 가독성 있고 유지보수하기 쉽게 만드는 간결하고 우아한 방법을 제공합니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>데코레이터는 일반적으로 다음과 같은 시나리오에서 사용됩니다:</p>\n<ul>\n<li>추가 기능 또는 로직 추가, 로깅, 성능 분석, 입력 유효성 검사 등;</li>\n<li>함수의 동작 수정, 결과 캐싱, 재시도 메커니즘 추가 또는 입력 매개변수를 가로채서 매개변수를 확인하고 많은 assert 문을 사용하는 대신;</li>\n<li>관심을 분리하고 자르로 자르로 사용되는 관심사항을 핵심 비즈니스 로직과 분리합니다.</li>\n</ul>\n<h1>5 매우 간단하지만 유용한 데코레이터</h1>\n<h2>01 타이머: 함수 실행 시간 측정</h2>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>코드 성능 최적화는 매우 중요합니다. 이 데코레이터는 특정 함수의 실행 시간을 추적하고 경과 시간을 출력하는 데 도움을 줍니다. 이 데코레이터로 함수를 감싸면 병목 현상을 신속하게 식별하고 코드의 핵심 부분을 최적화할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> time\n\ndef <span class=\"hljs-title function_\">timer</span>(func):\n    def <span class=\"hljs-title function_\">wrapper</span>(*args, **kwargs):\n        # 타이머 시작\n        start_time = time.<span class=\"hljs-title function_\">time</span>()\n        # 데코레이트된 함수 호출\n        result = <span class=\"hljs-title function_\">func</span>(*args, **kwargs)\n        # 시간 다시 측정\n        end_time = time.<span class=\"hljs-title function_\">time</span>()\n        # 경과 시간 계산 및 출력\n        execution_time = end_time - start_time\n        <span class=\"hljs-title function_\">print</span>(f<span class=\"hljs-string\">\"실행 시간: {execution_time} 초\"</span>)\n        # 데코레이트된 함수 실행 결과 반환\n        <span class=\"hljs-keyword\">return</span> result\n    # wrapper 함수에 대한 참조 반환\n    <span class=\"hljs-keyword\">return</span> wrapper\n</code></pre>\n<p>파이썬에서 데코레이터를 만들려면 timer라는 함수를 정의해야 합니다. 이 함수는 데코레이터 함수임을 나타내는 func라는 매개변수를 받습니다. timer 함수 내부에서는 원하는 함수를 데코레이트하기 위해 매개변수를 일반적으로 전달하는 wrapper라는 다른 함수를 정의합니다.</p>\n<p>wrapper 함수 내에서는 제공된 인수를 사용하여 필요한 함수를 호출합니다. 이렇게 할 수 있습니다: result = func(*args, **kwargs).</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>마지막으로, 래퍼 함수는 장식된 함수의 실행 결과를 반환합니다. 데코레이터 함수는 방금 만든 래퍼 함수에 대한 참조를 반환해야 합니다.</p>\n<p>데코레이터를 활용하기 위해서는 원하는 함수에 @ 기호를 사용하여 적용하면 됩니다.</p>\n<pre><code class=\"hljs language-js\">@timer\ndef <span class=\"hljs-title function_\">train_model</span>():\n    <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"Starting the model training function...\"</span>)\n    # 프로그램을 <span class=\"hljs-number\">5</span>초간 일시 중지하여 함수 실행을 시뮬레이션합니다\n    <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"Model training completed!\"</span>)\n\n<span class=\"hljs-title function_\">train_model</span>()\n</code></pre>\n<h2>02 debugger: Make Debug Easier</h2>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>유용한 추가 래퍼 함수를 만들어 디버깅을 용이하게 할 수 있습니다. 각 함수의 입력 및 출력을 출력하여 실행 흐름을 확인할 수 있습니다. 이 방법을 통해 복수의 print 문으로 애플리케이션을 혼란스럽게 만들 필요가 없습니다.</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">debugger</span>(<span class=\"hljs-params\">func</span>):\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">wrapper</span>(<span class=\"hljs-params\">*args, **kwargs</span>):\n        <span class=\"hljs-comment\"># 함수 이름과 인수 출력</span>\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f\"Calling <span class=\"hljs-subst\">{func.__name__}</span> with args: <span class=\"hljs-subst\">{args}</span> kwargs: <span class=\"hljs-subst\">{kwargs}</span>\"</span>)\n        <span class=\"hljs-comment\"># 함수 호출</span>\n        result = func(*args, **kwargs)\n        <span class=\"hljs-comment\"># 결과 출력</span>\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f\"<span class=\"hljs-subst\">{func.__name__}</span> returned: <span class=\"hljs-subst\">{result}</span>\"</span>)\n        <span class=\"hljs-keyword\">return</span> result\n    <span class=\"hljs-keyword\">return</span> wrapper\n</code></pre>\n<p>호출된 함수의 이름을 가져오기 위해 <strong>name</strong> 매개변수를 사용할 수 있으며, args와 kwargs 매개변수를 사용하여 전달된 내용을 출력할 수 있습니다.</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-meta\">@debugger</span>\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">add_numbers</span>(<span class=\"hljs-params\">x, y</span>):\n    <span class=\"hljs-keyword\">return</span> x + y\nadd_numbers(<span class=\"hljs-number\">7</span>, y=<span class=\"hljs-number\">5</span>)  \n<span class=\"hljs-comment\"># 출력: Calling add_numbers with args: (7,) kwargs: {'y': 5}</span>\n<span class=\"hljs-comment\"># add_numbers returned: 12</span>\n</code></pre>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h2>03 memoize: 반환 결과 캐시</h2>\n<p>우리는 코드 베이스에서 특정 코드 조각들의 동작을 거의 변경하지 않습니다. 그러나 이러한 코드들의 반복 실행은 상당한 컴퓨팅 자원을 소비할 수 있습니다. 이 경우 memoize 데코레이터를 사용하여 함수 호출을 캐시할 수 있습니다.</p>\n<p>이 시점에서 입력이 동일하면 함수는 한 번만 실행됩니다. 각 후속 실행에서는 결과가 캐시에서 가져옵니다. 따라서 비용이 많이 드는 계산을 항상 수행할 필요가 없습니다.</p>\n<pre><code class=\"hljs language-js\">def <span class=\"hljs-title function_\">memoize</span>(func):\n    cache = {}\n    def <span class=\"hljs-title function_\">wrapper</span>(*args):\n        <span class=\"hljs-keyword\">if</span> args <span class=\"hljs-keyword\">in</span> <span class=\"hljs-attr\">cache</span>:\n            <span class=\"hljs-keyword\">return</span> cache[args]\n        <span class=\"hljs-attr\">else</span>:\n            result = <span class=\"hljs-title function_\">func</span>(*args)\n            cache[args] = result\n            <span class=\"hljs-keyword\">return</span> result\n    <span class=\"hljs-keyword\">return</span> wrapper\n</code></pre>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>데코레이터는 함수 매개변수와 반환 값을 저장하는 사전(dictionary)을 사용합니다. 이 함수를 실행할 때, 데코레이터는 이전 결과 사전을 확인합니다. 저장된 값이 없을 때만 실제 함수가 호출됩니다.</p>\n<p>아래는 피보나치 수 계산 함수입니다. 이 함수는 재귀적으로 작동하므로 동일한 함수가 여러 번 실행됩니다. 그러나 캐싱을 사용하면 이 과정을 빠르게 만들 수 있습니다.</p>\n<pre><code class=\"hljs language-js\">@memoize\ndef <span class=\"hljs-title function_\">fibonacci</span>(n):\n    <span class=\"hljs-keyword\">if</span> n &#x3C;= <span class=\"hljs-number\">1</span>:\n        <span class=\"hljs-keyword\">return</span> n\n    <span class=\"hljs-attr\">else</span>:\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">fibonacci</span>(n-<span class=\"hljs-number\">1</span>) + <span class=\"hljs-title function_\">fibonacci</span>(n-<span class=\"hljs-number\">2</span>)\n</code></pre>\n<p>이 함수의 실행 시간을 캐시를 사용하거나 사용하지 않을 때 각각 측정한 결과입니다. 캐시된 버전은 실행에 몇 밀리초만 소요되지만, 캐시되지 않은 버전은 거의 1분이 소요됩니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>이전 실행 결과를 저장할 때 사전을 사용하는 것은 간단하고 직관적인 방법입니다. 더 강력한 기능을 제공하기 위해 데이터를 캐시하는 인메모리 데이터베이스인 Redis나 Memcache와 같은 것을 사용할 수 있습니다.</p>\n<h2>04 재시도: 실행 재시도</h2>\n<p>데이터 과학과 소프트웨어 개발에서는 종종 외부 시스템에 의존하지만 모든 외부 시스템이 신뢰성있는 것은 아닙니다.</p>\n<p>예기치 않은 이벤트가 발생할 때 코드가 일정 시간을 기다려 외부 시스템이 복구되기를 기다리고 다시 시도할 수 있기를 원할 수 있습니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>그런 retry 로직을 Python 데코레이터로 구현하는 것이 좋습니다. 이렇게 하면 재시도 동작을 어떤 함수에든 적용할 수 있어요.</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">import</span> time\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">retry</span>(<span class=\"hljs-params\">max_attempts, delay=<span class=\"hljs-number\">1</span></span>):\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">decorator</span>(<span class=\"hljs-params\">func</span>):\n        <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">wrapper</span>(<span class=\"hljs-params\">*args, **kwargs</span>):\n            attempts = <span class=\"hljs-number\">0</span>\n            <span class=\"hljs-keyword\">while</span> attempts &#x3C; max_attempts:\n                <span class=\"hljs-keyword\">try</span>:\n                    <span class=\"hljs-keyword\">return</span> func(*args, **kwargs)\n                <span class=\"hljs-keyword\">except</span> Exception <span class=\"hljs-keyword\">as</span> e:\n                    attempts += <span class=\"hljs-number\">1</span>\n                    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f\"Attempt <span class=\"hljs-subst\">{attempts}</span> failed: <span class=\"hljs-subst\">{e}</span>\"</span>)\n                    time.sleep(delay)\n            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f\"Function failed after <span class=\"hljs-subst\">{max_attempts}</span> attempts\"</span>)\n        <span class=\"hljs-keyword\">return</span> wrapper\n    <span class=\"hljs-keyword\">return</span> decorator\n</code></pre>\n<p>우리는 데코레이터에 대한 다른 래퍼 함수를 정의할 수 있어요. 이전 예제와 유사하게 구현해요. 그러나 이번에는 검증 함수를 입력 변수로 전달하는 대신 max_attempts와 delay와 같은 특정 매개변수를 전달해요.</p>\n<p>데코레이터 함수가 호출되면 wrapper 함수가 호출돼요. 이 함수는 시도 횟수(0부터 시작)를 기록하고 while 루프에 진입해요. 루프는 장식된 함수를 실행하려고 시도하고, 성공하면 결과를 즉시 반환해요. 그러나 예외가 발생하면 시도 횟수를 증가시키고, 시도 횟수와 발생한 특정 예외를 나타내는 오류 메시지를 출력해요. 지정된 지연 시간 동안 함수를 다시 시도하기 전에 time.sleep을 사용해요.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>이 함수를 호출하려면 각 함수 호출 사이의 최대 시도 횟수와 시간 간격(초)을 지정할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\">@<span class=\"hljs-title function_\">retry</span>(max_attempts=<span class=\"hljs-number\">3</span>, delay=<span class=\"hljs-number\">2</span>)\ndef <span class=\"hljs-title function_\">fetch_data</span>(url):\n    <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"데이터를 가져오는 중..\"</span>)\n    # 서버 응답 없음을 모의하기 위해 시간 초과 오류 발생..\n    raise <span class=\"hljs-title class_\">TimeoutError</span>(<span class=\"hljs-string\">\"서버가 응답하지 않습니다.\"</span>)\n<span class=\"hljs-title function_\">fetch_data</span>(<span class=\"hljs-string\">\"https://example.com/data\"</span>)  \n# 시도 간격이 <span class=\"hljs-number\">2</span>초인 <span class=\"hljs-number\">3</span>번 재시도\n</code></pre>\n<h2>05 exception_handler: Graceful Exception Handling</h2>\n<p>exception_handler는 함수에서 발생한 모든 예외를 잡아 적절히 처리할 수 있습니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>요구 사항에 맞게 래퍼 함수에서 예외 처리를 사용자 정의할 수 있습니다. 예를 들어 예외를 로깅하거나 추가 오류 처리 단계를 수행할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\">def <span class=\"hljs-title function_\">exception_handler</span>(func):\n    def <span class=\"hljs-title function_\">wrapper</span>(*args, **kwargs):\n        <span class=\"hljs-attr\">try</span>:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">func</span>(*args, **kwargs)\n        except <span class=\"hljs-title class_\">Exception</span> <span class=\"hljs-keyword\">as</span> <span class=\"hljs-attr\">e</span>:\n            # 예외 처리\n            <span class=\"hljs-title function_\">print</span>(f<span class=\"hljs-string\">\"예외가 발생했습니다: {str(e)}\"</span>)\n            # 선택적으로 추가 오류 처리 또는 로깅 수행\n            # 필요한 경우 예외를 다시 발생시킵니다.\n    <span class=\"hljs-keyword\">return</span> wrapper\n</code></pre>\n<p>이것은 우리의 코드를 간소화하고 예외 처리 및 오류 로깅을 처리하는 통합된 절차를 수립하는 데 매우 유용합니다.</p>\n<pre><code class=\"hljs language-js\">@exception_handler\ndef <span class=\"hljs-title function_\">divide</span>(x, y):\n    result = x / y\n    <span class=\"hljs-keyword\">return</span> result\n<span class=\"hljs-title function_\">divide</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">0</span>)  \n# 출력: 예외가 발생했습니다: division by zero\n</code></pre>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h1>요약</h1>\n<p><img src=\"/TIL/assets/img/2024-07-12-EssentialforLazyDevelopersFiveEfficientPythonDecorators_2.png\" alt=\"이미지\"></p>\n<p>데코레이터는 함수에 새로운 동작을 쉽게 적용할 수 있는 매우 편리한 방법입니다. 래퍼(wrapper)를 사용하여 복잡한 작업을 간소화하고 코드 가독성을 높이며 생산성을 향상시킬 수 있습니다.</p>\n<p><img src=\"/TIL/assets/img/2024-07-12-EssentialforLazyDevelopersFiveEfficientPythonDecorators_3.png\" alt=\"이미지\"></p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h2>👋 만약 이 게시물이 도움이 된다면, 작가를 지원하는 의미로 아래 👏 버튼을 클릭해 주세요</h2>\n<h2>🚀 FAUN 개발자 커뮤니티에 가입하고 매주 이메일로 유사한 이야기를 받아보세요</h2>\n</body>\n</html>\n"},"__N_SSG":true}