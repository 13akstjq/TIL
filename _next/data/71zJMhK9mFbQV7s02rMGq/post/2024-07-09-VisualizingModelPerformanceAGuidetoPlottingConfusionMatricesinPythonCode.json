{"pageProps":{"post":{"title":"모델 성능 시각화 Python 코드로 혼동 행렬 그리는 방법 가이드","description":"","date":"2024-07-09 14:27","slug":"2024-07-09-VisualizingModelPerformanceAGuidetoPlottingConfusionMatricesinPythonCode","content":"\n<img src=\"/TIL/assets/img/2024-07-09-VisualizingModelPerformanceAGuidetoPlottingConfusionMatricesinPythonCode_0.png\" />\n\n안녕하세요! 이 기사에서는 머신러닝 모델을 평가하는데 있어서 혼동 행렬의 중요성에 대해 살펴보겠습니다. 혼동 행렬이 무엇이며, 어떻게 작동하는지, 그리고 분류 모델의 성능을 평가하는 데 왜 중요한지에 대한 자세한 설명을 제공할 것입니다. 게다가, 우리는 혼동 행렬을 그리는 Python 함수를 살펴보고, 결과를 효과적으로 해석하는 방법에 대한 통찰을 제공할 것입니다.\n\n## 혼동 행렬 소개\n\n혼동 행렬은 분류 알고리즘의 성능을 평가하는 데 사용되는 표입니다. 예측된 레이블을 실제 레이블과 비교하여 모델이 얼마나 잘 수행되고 있는지 명확하게 보여줍니다. 이 행렬은 모델이 어떤 종류의 오류를 범하고 있는지 이해하는 데 특히 유용하며, 개선할 부분을 식별하는 데 도움이 됩니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 혼동 행렬의 구조\n\n이진 분류 문제의 혼동 행렬은 일반적으로 다음과 같은 모습을 갖습니다:\n\n![Confusion Matrix](/TIL/assets/img/2024-07-09-VisualizingModelPerformanceAGuidetoPlottingConfusionMatricesinPythonCode_1.png)\n\n다중 클래스 분류 문제의 경우, 행렬은 더 많은 클래스를 수용하도록 확장됩니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 정확도: 정확도 점수 이상의 자세한 정확도 정보를 제공합니다.\n- 오류 분석: 오류 유형(거짓 양성 및 거짓 음성)을 식별하는 데 도움이 됩니다.\n- 모델 개선: 오분류를 이해함으로써 모델을 개선하는 데 유용한 통찰을 제공합니다.\n\n## Python으로 혼동 행렬 플로팅\n\n```js\nimport itertools\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndef plot_confusion_matrix(cm, class_labels=None, normalize=False, figsize=(10, 10)):\n    \"\"\"\n    레이블 및 백분율로 혼동 행렬을 플로팅합니다.\n\n    Args:\n        cm (numpy.ndarray): 혼동 행렬.\n        class_labels (list, optional): 클래스에 대한 사용자 정의 레이블. 기본값은 None입니다.\n        normalize (bool, optional): 백분율을 위해 혼동 행렬을 정규화할지 여부. 기본값은 False입니다.\n        figsize (tuple, optional): 도표의 크기. 기본값은 (10, 10)입니다.\n\n    Returns:\n        None\n    \"\"\"\n    n_classes = cm.shape[0]\n\n    # 플로팅을 위한 도표 및 축 생성\n    fig, ax = plt.subplots(figsize=figsize)\n\n    # 혼동 행렬 시각화를 위한 컬러맵 생성\n    cax = ax.matshow(cm, cmap=plt.cm.Blues)  # 다른 컬러맵을 사용할 수 있습니다\n\n    # 플롯에 컬러바 추가\n    fig.colorbar(cax)\n\n    # 축 레이블 (선택사항)\n    if class_labels is not None:\n        labels = class_labels\n    else:\n        labels = np.arange(cm.shape[0])\n\n    # 축 레이블 및 제목 설정\n    ax.set(\n        title=\"혼동 행렬\",\n        xlabel=\"예측된 레이블\",\n        ylabel=\"실제 레이블\",\n        xticks=np.arange(n_classes),\n        yticks=np.arange(n_classes),\n        xticklabels=labels,\n        yticklabels=labels,\n    )\n\n    # 가독성을 높이기 위해 x축 레이블 회전\n    ax.xaxis.set_label_position(\"bottom\")\n    ax.xaxis.tick_bottom()\n\n    # 레이블 크기 조정\n    plt.setp(ax.xaxis.get_majorticklabels(), size=20)\n    plt.setp(ax.yaxis.get_majorticklabels(), size=20)\n    ax.title.set_size(20)\n\n    # 텍스트 색상 임계값 계산\n    threshold = (cm.max() + cm.min()) / 2.\n\n    # 필요한 경우 혼동 행렬 정규화\n    if normalize:\n        cm = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis]\n\n    # 혼동 행렬의 각 요소를 순회하고 텍스트 주석 추가\n    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):\n        # 값 및 백분율 표시 (선택사항)\n        text = f\"{cm[i, j]:.2f}\" if normalize else f\"{cm[i, j]}\"\n\n        # 임계값에 기반한 텍스트 색상 설정\n        color = \"white\" if cm[i, j] > threshold else \"black\"\n\n        # 중앙 정렬 및 적절한 크기로 텍스트 주석 추가\n        ax.text(\n            j,\n            i,\n            text,\n            ha=\"center\",\n            va=\"center\",\n            color=color,\n            fontsize=15,\n        )\n\n    # 혼동 행렬 플롯 표시\n    plt.show()\n```\n\nPlot Confusion Matrix 함수 사용 방법\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 혼동 행렬 생성: 플로팅하기 전에 모델의 예측과 실제 레이블을 이용해 혼동 행렬을 생성해야 합니다. 이를 위해 sklearn.metrics.confusion_matrix를 사용할 수 있습니다.\n\n```js\nfrom sklearn.metrics import confusion_matrix\n\ny_pred = model.predict(X_test)\ncm = confusion_matrix(y_test, y_pred)\n```\n\n2. 혼동 행렬 플로팅: 생성된 행렬로 plot_confusion_matrix 함수를 호출하세요.\n\n```js\nplot_confusion_matrix(cm, (class_labels = [\"Class 0\", \"Class 1\"]), (normalize = True));\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n혼동 행렬은 분류 모델의 성능을 평가하는 강력한 도구입니다. 이들은 모델이 얼마나 잘 수행되고 있는지에 대한 포괄적인 관점을 제공하며 개선이 필요한 부분을 강조합니다. 혼동 행렬을 시각화함으로써, 모델의 동작에 대한 더 깊은 통찰력을 얻고 미래 개선을 위한 정보를 파악할 수 있습니다.\n\n본 문서에서는 혼동 행렬을 플로팅하는 Python 함수를 제공하고 사용 방법을 설명했습니다. 이 함수를 워크플로에 통합함으로써, 모델의 예측을 효과적으로 분석하고 해석할 수 있어 더 나은 정확도의 머신 러닝 모델에 이르게 될 것입니다.\n","ogImage":{"url":"/assets/img/2024-07-09-VisualizingModelPerformanceAGuidetoPlottingConfusionMatricesinPythonCode_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-VisualizingModelPerformanceAGuidetoPlottingConfusionMatricesinPythonCode_0.png","tag":["Tech"],"readingTime":5},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<img src=\"/TIL/assets/img/2024-07-09-VisualizingModelPerformanceAGuidetoPlottingConfusionMatricesinPythonCode_0.png\">\n<p>안녕하세요! 이 기사에서는 머신러닝 모델을 평가하는데 있어서 혼동 행렬의 중요성에 대해 살펴보겠습니다. 혼동 행렬이 무엇이며, 어떻게 작동하는지, 그리고 분류 모델의 성능을 평가하는 데 왜 중요한지에 대한 자세한 설명을 제공할 것입니다. 게다가, 우리는 혼동 행렬을 그리는 Python 함수를 살펴보고, 결과를 효과적으로 해석하는 방법에 대한 통찰을 제공할 것입니다.</p>\n<h2>혼동 행렬 소개</h2>\n<p>혼동 행렬은 분류 알고리즘의 성능을 평가하는 데 사용되는 표입니다. 예측된 레이블을 실제 레이블과 비교하여 모델이 얼마나 잘 수행되고 있는지 명확하게 보여줍니다. 이 행렬은 모델이 어떤 종류의 오류를 범하고 있는지 이해하는 데 특히 유용하며, 개선할 부분을 식별하는 데 도움이 됩니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h2>혼동 행렬의 구조</h2>\n<p>이진 분류 문제의 혼동 행렬은 일반적으로 다음과 같은 모습을 갖습니다:</p>\n<p><img src=\"/TIL/assets/img/2024-07-09-VisualizingModelPerformanceAGuidetoPlottingConfusionMatricesinPythonCode_1.png\" alt=\"Confusion Matrix\"></p>\n<p>다중 클래스 분류 문제의 경우, 행렬은 더 많은 클래스를 수용하도록 확장됩니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>정확도: 정확도 점수 이상의 자세한 정확도 정보를 제공합니다.</li>\n<li>오류 분석: 오류 유형(거짓 양성 및 거짓 음성)을 식별하는 데 도움이 됩니다.</li>\n<li>모델 개선: 오분류를 이해함으로써 모델을 개선하는 데 유용한 통찰을 제공합니다.</li>\n</ul>\n<h2>Python으로 혼동 행렬 플로팅</h2>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> itertools\n<span class=\"hljs-keyword\">import</span> matplotlib.<span class=\"hljs-property\">pyplot</span> <span class=\"hljs-keyword\">as</span> plt\n<span class=\"hljs-keyword\">import</span> numpy <span class=\"hljs-keyword\">as</span> np\n\ndef <span class=\"hljs-title function_\">plot_confusion_matrix</span>(cm, class_labels=<span class=\"hljs-title class_\">None</span>, normalize=<span class=\"hljs-title class_\">False</span>, figsize=(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">10</span>)):\n    <span class=\"hljs-string\">\"\"</span><span class=\"hljs-string\">\"\n    레이블 및 백분율로 혼동 행렬을 플로팅합니다.\n\n    Args:\n        cm (numpy.ndarray): 혼동 행렬.\n        class_labels (list, optional): 클래스에 대한 사용자 정의 레이블. 기본값은 None입니다.\n        normalize (bool, optional): 백분율을 위해 혼동 행렬을 정규화할지 여부. 기본값은 False입니다.\n        figsize (tuple, optional): 도표의 크기. 기본값은 (10, 10)입니다.\n\n    Returns:\n        None\n    \"</span><span class=\"hljs-string\">\"\"</span>\n    n_classes = cm.<span class=\"hljs-property\">shape</span>[<span class=\"hljs-number\">0</span>]\n\n    # 플로팅을 위한 도표 및 축 생성\n    fig, ax = plt.<span class=\"hljs-title function_\">subplots</span>(figsize=figsize)\n\n    # 혼동 행렬 시각화를 위한 컬러맵 생성\n    cax = ax.<span class=\"hljs-title function_\">matshow</span>(cm, cmap=plt.<span class=\"hljs-property\">cm</span>.<span class=\"hljs-property\">Blues</span>)  # 다른 컬러맵을 사용할 수 있습니다\n\n    # 플롯에 컬러바 추가\n    fig.<span class=\"hljs-title function_\">colorbar</span>(cax)\n\n    # 축 레이블 (선택사항)\n    <span class=\"hljs-keyword\">if</span> class_labels is not <span class=\"hljs-title class_\">None</span>:\n        labels = class_labels\n    <span class=\"hljs-attr\">else</span>:\n        labels = np.<span class=\"hljs-title function_\">arange</span>(cm.<span class=\"hljs-property\">shape</span>[<span class=\"hljs-number\">0</span>])\n\n    # 축 레이블 및 제목 설정\n    ax.<span class=\"hljs-title function_\">set</span>(\n        title=<span class=\"hljs-string\">\"혼동 행렬\"</span>,\n        xlabel=<span class=\"hljs-string\">\"예측된 레이블\"</span>,\n        ylabel=<span class=\"hljs-string\">\"실제 레이블\"</span>,\n        xticks=np.<span class=\"hljs-title function_\">arange</span>(n_classes),\n        yticks=np.<span class=\"hljs-title function_\">arange</span>(n_classes),\n        xticklabels=labels,\n        yticklabels=labels,\n    )\n\n    # 가독성을 높이기 위해 x축 레이블 회전\n    ax.<span class=\"hljs-property\">xaxis</span>.<span class=\"hljs-title function_\">set_label_position</span>(<span class=\"hljs-string\">\"bottom\"</span>)\n    ax.<span class=\"hljs-property\">xaxis</span>.<span class=\"hljs-title function_\">tick_bottom</span>()\n\n    # 레이블 크기 조정\n    plt.<span class=\"hljs-title function_\">setp</span>(ax.<span class=\"hljs-property\">xaxis</span>.<span class=\"hljs-title function_\">get_majorticklabels</span>(), size=<span class=\"hljs-number\">20</span>)\n    plt.<span class=\"hljs-title function_\">setp</span>(ax.<span class=\"hljs-property\">yaxis</span>.<span class=\"hljs-title function_\">get_majorticklabels</span>(), size=<span class=\"hljs-number\">20</span>)\n    ax.<span class=\"hljs-property\">title</span>.<span class=\"hljs-title function_\">set_size</span>(<span class=\"hljs-number\">20</span>)\n\n    # 텍스트 색상 임계값 계산\n    threshold = (cm.<span class=\"hljs-title function_\">max</span>() + cm.<span class=\"hljs-title function_\">min</span>()) / <span class=\"hljs-number\">2.</span>\n\n    # 필요한 경우 혼동 행렬 정규화\n    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-attr\">normalize</span>:\n        cm = cm.<span class=\"hljs-title function_\">astype</span>(<span class=\"hljs-string\">'float'</span>) / cm.<span class=\"hljs-title function_\">sum</span>(axis=<span class=\"hljs-number\">1</span>)[:, np.<span class=\"hljs-property\">newaxis</span>]\n\n    # 혼동 행렬의 각 요소를 순회하고 텍스트 주석 추가\n    <span class=\"hljs-keyword\">for</span> i, j <span class=\"hljs-keyword\">in</span> itertools.<span class=\"hljs-title function_\">product</span>(<span class=\"hljs-title function_\">range</span>(cm.<span class=\"hljs-property\">shape</span>[<span class=\"hljs-number\">0</span>]), <span class=\"hljs-title function_\">range</span>(cm.<span class=\"hljs-property\">shape</span>[<span class=\"hljs-number\">1</span>])):\n        # 값 및 백분율 표시 (선택사항)\n        text = f<span class=\"hljs-string\">\"{cm[i, j]:.2f}\"</span> <span class=\"hljs-keyword\">if</span> normalize <span class=\"hljs-keyword\">else</span> f<span class=\"hljs-string\">\"{cm[i, j]}\"</span>\n\n        # 임계값에 기반한 텍스트 색상 설정\n        color = <span class=\"hljs-string\">\"white\"</span> <span class=\"hljs-keyword\">if</span> cm[i, j] > threshold <span class=\"hljs-keyword\">else</span> <span class=\"hljs-string\">\"black\"</span>\n\n        # 중앙 정렬 및 적절한 크기로 텍스트 주석 추가\n        ax.<span class=\"hljs-title function_\">text</span>(\n            j,\n            i,\n            text,\n            ha=<span class=\"hljs-string\">\"center\"</span>,\n            va=<span class=\"hljs-string\">\"center\"</span>,\n            color=color,\n            fontsize=<span class=\"hljs-number\">15</span>,\n        )\n\n    # 혼동 행렬 플롯 표시\n    plt.<span class=\"hljs-title function_\">show</span>()\n</code></pre>\n<p>Plot Confusion Matrix 함수 사용 방법</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>혼동 행렬 생성: 플로팅하기 전에 모델의 예측과 실제 레이블을 이용해 혼동 행렬을 생성해야 합니다. 이를 위해 sklearn.metrics.confusion_matrix를 사용할 수 있습니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">from</span> sklearn.<span class=\"hljs-property\">metrics</span> <span class=\"hljs-keyword\">import</span> confusion_matrix\n\ny_pred = model.<span class=\"hljs-title function_\">predict</span>(X_test)\ncm = <span class=\"hljs-title function_\">confusion_matrix</span>(y_test, y_pred)\n</code></pre>\n<ol start=\"2\">\n<li>혼동 행렬 플로팅: 생성된 행렬로 plot_confusion_matrix 함수를 호출하세요.</li>\n</ol>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">plot_confusion_matrix</span>(cm, (class_labels = [<span class=\"hljs-string\">\"Class 0\"</span>, <span class=\"hljs-string\">\"Class 1\"</span>]), (normalize = <span class=\"hljs-title class_\">True</span>));\n</code></pre>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>혼동 행렬은 분류 모델의 성능을 평가하는 강력한 도구입니다. 이들은 모델이 얼마나 잘 수행되고 있는지에 대한 포괄적인 관점을 제공하며 개선이 필요한 부분을 강조합니다. 혼동 행렬을 시각화함으로써, 모델의 동작에 대한 더 깊은 통찰력을 얻고 미래 개선을 위한 정보를 파악할 수 있습니다.</p>\n<p>본 문서에서는 혼동 행렬을 플로팅하는 Python 함수를 제공하고 사용 방법을 설명했습니다. 이 함수를 워크플로에 통합함으로써, 모델의 예측을 효과적으로 분석하고 해석할 수 있어 더 나은 정확도의 머신 러닝 모델에 이르게 될 것입니다.</p>\n</body>\n</html>\n"},"__N_SSG":true}