{"pageProps":{"posts":[{"title":"초보 때 알았더라면 좋았을 Python 코딩 꿀팁 10가지","description":"","date":"2024-07-09 15:05","slug":"2024-07-09-PythonCodingTipsLessonsIWishIKnewWhenIStartedCoding","content":"\n![Python Coding Tips](/TIL/assets/img/2024-07-09-PythonCodingTipsLessonsIWishIKnewWhenIStartedCoding_0.png)\n\n코딩 여정을 시작할 때 파이썬 세계에 뛰어 들어가면서 약간의 어려움을 겪었어요. 코딩의 기본은 이해했지만, 내 코드를 효율적으로 만드는 방법을 알아내는 것은 퍼즐을 푸는 것처럼 어려웠죠. 예전에는 종종 파이썬의 신이 이끌어 준다는 말을 기억해요 — 정말 좋은 조언이긴 하지만, 내 생각에는 너무 추상적이었어요. 더 구체적인 예시가 필요했고, 그래서 이 가이드를 만들게 되었답니다.\n\n재미있게도, ChatGPT 시대 이후에 코딩을 배우기 시작한 사람들이 어떻게 코딩을 접근하는지에 변화를 주목했어요. ChatGPT 시대에 배운 사람들은 오류 수정과 디버깅에 뛰어나는 것 같아요. 그 반면, GPT 이전에 코딩한 사람들은 답을 분석하고 Stack Overflow나 문서와 같은 자료를 활용하는 데 능숙해요 — 아마도 조금의 복사-붙여넣기 기술도 있겠죠! ;)\n\n![Python Coding Tips](/TIL/assets/img/2024-07-09-PythonCodingTipsLessonsIWishIKnewWhenIStartedCoding_1.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n사진: Kelly Sikkema 님의 Unsplash\n\n저는 Python으로 코딩을 하는 7년 간에 중요한 차이를 만들어 준 몇 가지 개념을 경험해 왔습니다. 이 글에서는 제 경험을 바탕으로 27가지 직관적인 코딩 팁을 공유하고 싶습니다. 이러한 팁들은 제 코딩 속도를 높이는 데 도움이 되었을 뿐만 아니라, 제 코드를 더 깔끔하고 이해하기 쉽게 만들었습니다. 이러한 소중한 팁을 나누는 동안 함께해 주세요. 혹시 당신의 코딩 여정과 맞닿는 팁을 발견할 수도 있을 것입니다!\n\n# 1. F-Strings: 동적 문자열 포맷팅\n\n장점:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 간결하고 읽기 쉬운 구문.\n- 문자열 내부에 쉽게 표현식을 넣을 수 있습니다.\n\n단점:\n\n- Python 3.6 이상에서만 사용 가능합니다.\n- 보안 취약점에 주의해야 합니다; SQL Injection\n\n예시:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nname = \"John\"\nage = 25\nmessage = f\"My name is {name}, and I am {age} years old.\"\n```\n\n## 2. 데코레이터: 기능 동적으로 개선하기\n\n장점:\n\n- 함수의 동작을 확장하는 깔끔한 방법을 제공합니다.\n- 코드 재사용성을 향상시킵니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nCons:\n\n- 데코레이터를 과도하게 사용하면 코드를 이해하기 어렵게 만들 수 있습니다.\n\n예시:\n\n```python\nimport time\ndef timer_decorator(func):\n    def wrapper(*args, **kwargs):\n        start_time = time.time()\n        result = func(*args, **kwargs)\n        end_time = time.time()\n        print(f\"{func.__name__} executed in {end_time - start_time} seconds\")\n        return result\n    return wrapper\n@timer_decorator\ndef example_function():\n    # 함수 로직이 여기에 있습니다\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 3. Python 숙련도 향상을 위한 help() 함수 활용\n\n장점:\n\n- 즉각적인 문서화: 코드 내에서 Python 객체, 모듈 또는 함수에 대한 문서를 빠르게 참조할 수 있습니다.\n- 대화식 학습: Python 인터프리터나 스크립트에서 직접 생소한 모듈이나 함수를 탐색하고 학습하기에 이상적입니다.\n\n단점:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 제한된 정보: help()를 통해 제공되는 정보는 때로 간결할 수 있으며, 복잡한 주제에 대해서는 보다 자세한 문서가 필요할 수 있습니다. help()의 효과는 코드 내 docstrings의 존재와 품질에 따라 달라집니다.\n\n예시:\n\n```js\n# 예시: help() 함수 사용하기\ndef calculate_square(number):\n    \"\"\"\n    주어진 숫자의 제곱을 계산합니다.매개변수:\n    - number (int): 입력 숫자.\n    반환:\n    - int: 입력 숫자의 제곱 값.\n    \"\"\"\n    return number ** 2\n# calculate_square 함수에 대한 도움말 얻기\nhelp(calculate_square)\n```\n\n# 4. List Comprehensions: 간결한 리스트 생성\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n장점:\n\n- 목록 생성 로직을 간결하게 만들어 가독성을 향상시킵니다.\n- 기존 루프와 비교하여 성능을 향상시키는 경우가 많습니다.\n\n단점:\n\n- 특히 복잡한 로직에서는 가독성을 높이기 위해 중첩된 리스트 컴프리헨션을 피해야 합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예시:\n\n```js\n# 범위 내에서 짝수의 제곱값 찾기\nsquares = [x**2 for x in range(10) if x % 2 == 0]\n```\n\n# 5. 루프에서의 else 절\n\n장점:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 루프가 break 문이 없이 자연스럽게 완료될 때 코드를 실행할 수 있습니다.\n- 특정 동작이 성공적인 루프를 따라야 하는 시나리오에 이상적입니다.\n\n단점:\n\n- 종종 간과되거나 오해되어 잠재적인 논리 오류로 이어질 수 있습니다.\n\n예시:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# else 절을 사용하여 소수 찾기\nfor n in range(2, 10):\n    for x in range(2, n):\n        if n % x == 0:\n            break\n    else:\n        print(n, \"은(는) 소수입니다.\")\n```\n\n# 6. 람다 함수: 빠르고 익명의 함수\n\n장점:\n\n- 간단한 함수를 간결하게 한 줄에 작성할 수 있습니다.\n- 형식적인 함수 정의가 필요하지 않습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n단점:\n\n- 단일 표현식에 한정되어 복잡한 논리에 적합하지 않음.\n- 과다 사용 시 코드 가독성을 떨어뜨릴 수 있음.\n\n예시:\n\n```js\n# 람다 함수를 사용하여 두 숫자 더하기\nadd_numbers = lambda x, y: x + y\nresult = add_numbers(3, 5)\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 7. enumerate 및 zip을 활용한 파이썬적인 Iteration\n\n팁: enumerate()와 zip() 함수를 활용하여 시퀀스를 더 파이썬스럽게 반복하세요.\n\n장점:\n\n- enumerate(): 인덱스와 값 모두를 사용하여 반복을 간단하게 만듭니다.\n- zip(): 여러 리스트에 대해 병렬 반복을 용이하게 합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nCons:\n\n- 중요한 단점은 없음; 코드 가독성과 간결함을 향상시킴.\n\n예시:\n\n```python\n# enumerate와 zip을 사용한 Pythonic한 반복\nnames = [\"Alice\", \"Bob\", \"Charlie\"]\nages = [25, 30, 22]\n# 인덱스와 값을 함께 사용하는 Enumerate\nfor index, name in enumerate(names):\n    print(f\"사람 {index + 1}: {name}\")\n# 병렬 반복을 위한 Zip\nfor name, age in zip(names, ages):\n    print(f\"{name}은(는) {age}살입니다.\")\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 8. \\*args 와 \\*\\*kwargs: 유연한 함수 인수\n\n장점:\n\n- 가변 개수의 인수를 처리하는 데 이상적입니다.\n- 다양한 함수와 래퍼를 생성할 수 있습니다.\n\n단점:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 기능 시그니처가 모든 가능한 인수를 나타내지 않을 수 있으므로 주의 깊은 문서화가 필요합니다.\n\n예시:\n\n```js\n# 주어진 모든 인수를 곱하는 함수\ndef multiply(*args):\n    result = 1\n    for num in args:\n        result *= num\n    return result\n```\n\n# 9. try 및 except를 사용한 안정적인 오류 처리\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n장점:\n\n- 오류 내구성: 예기치 못한 오류로 인해 프로그램이 충돌하는 것을 방지합니다.\n- 향상된 디버깅: 무엇이 잘못되었는지에 대한 통찰을 제공하여 효과적인 디버깅을 돕습니다.\n- 사용자 친화적: 사용자에게 구체적인 오류 메시지를 전달하여 더 나은 경험을 제공합니다.\n\n단점:\n\n- 오버헤드: try와 except를 사용할 경우 일부 경우에 약간의 성능 오버헤드가 발생할 수 있습니다.\n- 잠재적인 실수: 오류를 잘못 잡거나 억제하는 경우 근본적인 문제를 숨길 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예시:\n\n```js\n# 예시: graceful try와 except를 활용한 오류 처리\ndef divide_numbers(a, b):\n    try:\n        result = a / b\n        print(f\"{a}를 {b}로 나눈 결과는: {result}\")\n    except ZeroDivisionError:\n        print(\"0으로 나눌 수 없습니다! 0이 아닌 값으로 나누어 주세요.\")\n    except Exception as e:\n        print(f\"예상치 못한 오류가 발생했습니다: {e}\")\n    else:\n        print(\"나눗셈 성공!\")\n# 함수 테스트\ndivide_numbers(10, 2)  # 일반적인 나눗셈\ndivide_numbers(5, 0)   # 0으로 나누기\ndivide_numbers(\"a\", 2) # 예상치 못한 오류 (TypeError)\n```\n\n# 10. 리스트 슬라이싱: 강력하면서 표현력이 있는 사용법\n\n장점:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 하위 목록 추출, 뒤집기, 요소 건너뛰기 등의 작업을 쉽게 수행할 수 있습니다.\n- 코드 가독성을 향상시키고 명시적인 반복문이 필요 없도록 합니다.\n\n단점:\n\n- 복잡한 슬라이싱을 과도하게 사용하면 코드 가독성에 영향을 줄 수 있습니다.\n\n예시:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# 인덱스 2부터 5까지의 서브리스트 추출\noriginal_list = [1, 2, 3, 4, 5, 6, 7]\nsublist = original_list[2:6]\n```\n\n# 11. 제너레이터: 메모리 효율적인 반복\n\n장점:\n\n- 대규모 데이터 세트를 효율적으로 처리합니다.\n- 아이템을 실시간으로 생성하여 메모리를 절약합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n단점:\n\n- 생성기는 일회용 반복자입니다. 한 번 소비되면 재사용할 수 없습니다.\n\n예:\n\n```js\n# 피보나치 수열 생성기\ndef fibonacci(n):\n    a, b = 0, 1\n    for _ in range(n):\n        yield a\n        a, b = b, a + b\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 12. 단언문: 자신감을 가지고 디버깅하기\n\n장점:\n\n- 잠재적 문제를 미리 잡아내어 코드 신뢰성을 향상시킵니다.\n- 코드에 대한 가정을 확인하는 방법을 제공합니다.\n\n단점:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 제품 코드에서 오버 사용하면 성능에 영향을 줄 수 있습니다.\n\n예시:\n\n```js\n# 변수가 양수인지 확인하는 어설션\nnum = -5\nassert num > 0, \"숫자는 양수여야 합니다.\"\n```\n\n# 13. 깊은 복사 vs 얕은 복사: 현명하게 복제하기\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n장점:\n\n- 얕은 복사: 동일한 객체에 대한 참조를 가진 새로운 컬렉션을 생성합니다.\n- 깊은 복사: 원본 객체 및 모든 내용의 독립적인 복제본을 생성합니다.\n\n단점:\n\n- deepcopy가 필요한데 얕은 복사를 사용하면 원본 데이터의 의도치 않은 수정이 발생할 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예시:\n\n```js\n# 중첩된 목록을 얕은 복사와 깊은 복사로 복제하는 방법\nimport copy\noriginal = [[1, 2, 3], [4, 5, 6]]\nshallow = copy.copy(original)\ndeep = copy.deepcopy(original)\n```\n\n# 14. 랜덤 모듈: 예측할 수 없는 것을 환영하세요\n\n장점:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 시뮬레이션, 게임 또는 예측할 수 없는 상황에 유용합니다.\n- 다양한 무작위화 기능을 제공합니다.\n\n단점:\n\n- 결과는 실제로 무작위적이지 않고 의사난수입니다.\n\n예시:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport random\n# 1과 10 사이의 난수 생성\nrandom_number = random.randint(1, 10)\n```\n\n### 15. Defaultdict: 사전 조작 간소화하기\n\n장점:\n\n- 존재하지 않는 키에 대한 기본값을 제공하여 코드를 간소화합니다.\n- 명시적인 키 존재 여부 검사를 없애줍니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nCons:\n\n- collections 모듈을 가져와야 함.\n\n예시:\n\n```python\nfrom collections import defaultdict\nword = \"pythonic\"\nletter_count = defaultdict(int)\nfor letter in word:\n    letter_count[letter] += 1\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 16. 해저 쇠사자 연산자(:=): 효율적인 인라인 할당\n\n장점:\n\n- 효율적으로 값을 할당하고 동일한 표현식 내에서 사용합니다.\n- 특정 조건에서 중복을 줄여줍니다.\n\n단점:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 이를 과도하게 사용하면 연산자에 익숙하지 않은 사람들에게 코드를 읽는 데 어렵게 만들 수 있습니다.\n\n예시:\n\n```js\n# 파일에서 빈 줄을 찾을 때까지 줄을 읽는 방법\nwith open('file.txt', 'r') as f:\n    while (line := f.readline().strip()):\n        print(line)\n```\n\n# 17. 타입 힌팅: 코드 가독성 향상하기\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n장점:\n\n- 코드 가독성과 유지 관리성을 향상시킵니다.\n- 더 나은 IDE 지원 및 정적 유형 검사를 가능하게 합니다.\n\n단점:\n\n- Python은 여전히 동적으로 유형이 할당되는 언어이며, 유형 힌트는 옵션이며 강제되지 않습니다 — 인간 눈을 위한 것이죠 ;) .\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예시:\n\n```js\n# 타입 힌트가 있는 함수\ndef greet(name: str) -> str:\n    return f\"Hello, {name}!\"\n```\n\n# 18. Namedtuples: 스스로 설명하는 데이터 구조\n\n장점:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 가볍고 변경할 수 없는 데이터 구조를 제공합니다.\n- 각 필드에 이름을 지정하여 코드 가독성을 향상시킵니다.\n\n단점:\n\n- 변경할 수 없으며, 생성 후 수정할 수 없습니다.\n- 가변 구조를 위해서는 데이터 클래스를 사용하는 것을 고려해보세요 (Python 3.7+).\n\n예시:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\n# 사람을 위한 namedtuple 만들기\nfrom collections import namedtuple\nPerson = namedtuple('Person', ['name', 'age'])\nalice = Person(name=\"Alice\", age=30)\n```\n\n# 19. 리스트를 병합하고 해제하는 방법: 순차열 결합 및 해제\n\n장점:\n\n- 동시에 여러 리스트를 반복하는 것을 간단하게 만듭니다.\n- 서로 다른 리스트에서 항목을 함께 처리해야 하는 작업에 편리합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n단점:\n\n- zip()은 입력 리스트 중 가장 짧은 곳에서 멈춥니다. 크기가 다른 iterable을 사용할 경우 itertools.zip_longest()을 고려해보세요.\n\n예시:\n\n```js\n# 퀴즈에서 사용자 입력과 해당 답변을 매칭하는 예시\nnames = [\"Alice\", \"Bob\"]\nscores = [85, 92]\nfor name, score in zip(names, scores):\n    print(f\"{name}: {score}\")\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 20. Dictionaries — get()과 setdefault(): 우아한 키 처리\n\n장점:\n\n- get(): 키의 값을 검색하여, 해당 키가 존재하지 않을 경우 기본값을 제공합니다.\n- setdefault(): 키가 존재하지 않을 경우 기본값을 설정하여, 중복된 키 확인을 방지합니다.\n\n단점:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 이러한 방법을 간과하면 중복 코드를 확인하는 데 유용합니다.\n\n예시:\n\n```js\ndata = { name: \"Alice\" };\nage = data.get(\"age\", 30);\ndata.setdefault(\"country\", \"USA\");\n```\n\n# 21. **main** 가드: 스크립트 실행을 제어하기\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n장점:\n\n- 특정 코드가 스크립트가 직접 실행될 때만 실행되고 가져올 때는 실행되지 않도록 보장합니다.\n- 기능으로 가져와서 함수를 사용하거나 작업을 위해 직접 실행할 수 있는 유틸리티 스크립트에 유용합니다.\n\n단점:\n\n- 이 가드를 사용하는 것을 잊으면 모듈이 가져올 때 예기치 않은 동작을 초래할 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예시:\n\n```js\nif __name__ == \"__main__\":\n    print(\"이 스크립트는 직접 실행 중입니다!\")\n```\n\n# 22. 가상 환경: 프로젝트별 개발을 위한 종속성 격리\n\n장점:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 각 프로젝트를 위한 깨끗하고 격리된 환경을 보장합니다.\n- 의존성 관리를 용이하게 하고 충돌을 피할 수 있습니다.\n\nCons:\n\n- 가상 환경을 활성화하는 것을 잊으면 전역 Python 환경에 의도하지 않은 패키지 설치로 이어질 수 있습니다.\n\nExample:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```bash\n# 가상 환경 생성 및 활성화\npython -m venv my_project_env\nsource my_project_env/bin/activate\n```\n\n# 23. 별표 (\\*) 연산자: 다재다능하고 강력함\n\n장점:\n\n- 컬렉션을 각각의 요소로 효율적으로 언패킹한다.\n- 함수 내에서 동적인 인수 처리를 용이하게 한다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n단점:\n\n- 여러번의 언패킹을 연속적으로 사용하는 경우에는 코드 가독성이 감소할 수 있습니다.\n\n예시:\n\n```js\n# 함수에 별도의 인수를 기대하는 동적 목록 값 전달\ndef func(a, b, c):\n    return a + b + c\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nvalues = [1, 2, 3]\nprint(func(*values))\n```\n\n# 24. 컨텍스트 매니저(with 문): 리소스 관리의 간편함\n\n장점:\n\n- 리소스의 적절한 설정 및 해제를 보장합니다.\n- 코드 가독성을 향상시키고 리소스 누수 가능성을 줄입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n단점:\n\n- 유익할 때 with 문을 사용하지 않는 것은 리소스 관련 문제로 이어질 수 있습니다.\n\n예시:\n\n```js\n# 컨텍스트 매니저를 사용하여 파일 열고 읽기\nwith open('file.txt', 'r') as f:\n    content = f.read()\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 25. 파이썬의 언더스코어(\\_) 사용법: 명명과 루프에서의 다재다능함\n\n장점:\n\n- 명명 규칙에서 \"보호된\" 변수를 나타냄.\n- REPL 환경에서 마지막 결과를 재사용함.\n- 루프에서 루프 변수가 필요하지 않을 때 일회용 변수로 작용함.\n\n단점:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 다양한 용도로 사용되면 특히 새로운 코더들에게 혼란스러울 수 있어요.\n\n예시:\n\n```js\n# 루프 카운터가 필요 없는 특정 횟수만큼 반복하기\nfor _ in range(5):\n    print(\"Hello, World!\")\n```\n\n# 26. 맵, 필터 및 리듀스: 파이썬에서의 함수형 프로그래밍\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n장점:\n\n- map(): 컬렉션의 각 항목에 함수를 적용합니다.\n- filter(): 조건에 따라 항목을 선택합니다.\n- reduce(): 함수를 누적적으로 적용하여 시퀀스를 단일 값으로 축소합니다.\n\n단점:\n\n- Python 3.x에서 map()과 filter()는 반복자를 반환하므로 필요하다면 리스트로 변환하세요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예시:\n\n```js\n# map()을 사용하여 문자열을 대문자로 변환하기\nnames = [\"alice\", \"bob\", \"charlie\"]\nupper_names = list(map(str.upper, names))\n```\n\n# 27. 딕셔너리 병합: 딕셔너리 작업을 간단하게 만들기\n\n장점:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 여러 사전의 내용을 결합하는 것을 간편하게 해줍니다.\n- 병합 방법을 선택하는 데 유연성을 제공합니다.\n\n단점:\n\n- 이 접근을 과도하게 사용하면 중첩된 사전을 처리할 때 예상치 못한 결과로 이어질 수 있습니다.\n\n예시:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 딕셔너리를 update() 메서드를 사용하여 병합하기\n\ndict1 = {'a': 1, 'b': 2}\ndict2 = {'b': 3, 'c': 4}\ndict1.update(dict2)\n\n# 축하해요! 마침내 완료했어요!\n\n이 파이썬 코딩 팁을 마무리하며, 여러분은 여러분의 코딩 도구 상자에 유용한 속임수들을 배운 것을 기대합니다. 코딩 전문가이든 초보자이든, 새로운 팁으로 색다르게 유지하는 것은 언제나 좋은 선택입니다. 이것들을 적용해보고, 여러분에게 도움이 되는 것을 확인하고, 여러분의 파이썬 코딩 실력을 조금씩 향상시키는 여정을 즐기세요. 즐거운 코딩 되세요!\n","ogImage":{"url":"/assets/img/2024-07-09-PythonCodingTipsLessonsIWishIKnewWhenIStartedCoding_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-PythonCodingTipsLessonsIWishIKnewWhenIStartedCoding_0.png","tag":["Tech"],"readingTime":25},{"title":"3일차, 4일차  진도가 부족한 이유","description":"","date":"2024-07-09 15:04","slug":"2024-07-09-Day3Day4NotEnoughProgress","content":"\n## 30일 코딩 챌린지\n\n![이미지](/TIL/assets/img/2024-07-09-Day3Day4NotEnoughProgress_0.png)\n\n저의 지역에서 전원 문제가 지속되고 있습니다. 어제인 'Day 3'에 한 일은 이전 날(데이 2의 업데이트를 읽으려면 아래로 스크롤하세요👇)의 온도 변환기를 다듬은 것 뿐입니다.\n\n제게 궁금증을 자아냅니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n어쨌든, 그걸 생각하느라 시간을 낭비하지 말아요. 여기 오늘(4일차)의 내 보고서가 있어요:\n\n이전 날들과는 달리, 오늘은 조직된 계획이 없었어요.\n\nTkinter를 통해 내 온도 변환기의 두 번째 버전을 위한 창을 만들어보려고 했어요.\n\n하지만, 아마도 내 코드에 집중하지 못하고 거의 전혀 진전이 없었어요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이유는요? 다른 급한 일이 더 많아서 그래요.\n\n그래서, 음, 오늘은 지금까지 최악의 날이었어요.\n\n그리고 그 이유는 프로젝트를 진행하기 위한 수단과 의지가 있었는데도 집중할 수 없었기 때문이에요. 충분한 양을 처리하지 못하는 것 같아요.\n\n어쨌든, IDE를 열고 어제보다 더 많은 시간을 프로젝트에 쏟은 사실을 고려하면 오늘을 \"완료\"로 표시할 수 있어요.\n","ogImage":{"url":"/assets/img/2024-07-09-Day3Day4NotEnoughProgress_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-Day3Day4NotEnoughProgress_0.png","tag":["Tech"],"readingTime":2},{"title":"빠른 푸리에 변환을 이용한 주식 시장 신호 분석 방법","description":"","date":"2024-07-09 15:03","slug":"2024-07-09-StockMarketSignalAnalysisUsingFastFourierTransform","content":"\n# 소개\n\n금융 시장은 본질적으로 소음이 많고 예측할 수 없어서, 수익성 있는 기회를 식별하고 활용하려는 트레이더와 투자자에게 상당한 어려움을 줍니다.\n\n이 복잡성을 해결하기 위해 현대 트레이더들은 수학적 및 통계적 기술을 활용하여 소음을 걸러내고 데이터의 기저 주기/트렌드를 더 명확히 이해하기 위한 다양한 기법을 사용합니다. FFT(Fast Fourier Transform) 알고리즘은 이러한 강력한 도구 중 하나로, 어떤 신호/파형을 주파수가 변하는 사인 성분들의 합으로 표현하는 데 사용되는 알고리즘입니다. 따라서 시간 영역에서 주파수 영역으로 신호를 변환합니다.\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*e-_z80BnbHWyFTfRLblJ_w.gif)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 기사에서 논의하는 FFT 알고리즘은 신호 처리를 사용하여 가장 중요한 주파수를 감지하고 데이터에서 잡음을 제거합니다.\n\n# FFT를 사용하는 이유?\n\n## 주기와 패턴 감지\n\n주식 가격이나 거래량과 같은 금융 시계열은 다양한 경제 주기, 계절성 또는 투자자 행동으로 인해 주기적인 패턴을 나타내는 경우가 많습니다. 푸리에 변환은 이러한 주기와 해당 주파수를 식별하는 데 도움이 됩니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 소음 필터링\n\n금융 데이터는 종종 무작위 변동으로 인해 소음이 발생합니다. 데이터를 주파수 영역으로 변환하여 분석가들은 고주파 소음을 제거하여 중요한 저주파수 트렌드에 집중할 수 있습니다.\n\n## 예측 모델링\n\n주파수를 식별함으로써, 분석가들은 역사적인 패턴을 기반으로 미래 가격 변동이나 트렌드에 대한 예측을 할 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 기계 학습을 위한 기능 추출\n\nFourier 변환에서 얻은 주파수 구성 요소는 머신 러닝 모델에서 특징으로 사용되어 예측의 정확도를 향상시킬 수 있습니다.\n\n# 코드 및 단계별 분석\n\n## 노트북 설정 및 주식 데이터 수집\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n필요한 기본 주식 데이터 수집 및 데이터 프레임 조작을 위한 라이브러리 가져오기가 첫 번째 단계입니다.\n\n또한, 분석 기간을 1년으로 설정하고 분석할 주식은 Tata Consultancy Services (TCS)입니다. 필요한 주식의 OLHCAV 데이터는 'df'라는 데이터 프레임에 저장되어 있습니다.\n\n```js\n#라이브러리 가져오기\nimport pandas as pd\nfrom pandas_datareader import data as pdr\nimport numpy as np\nimport math\nimport datetime\nimport scipy.stats as stats\nimport matplotlib.pyplot as plt\nimport yfinance as yfin\nyfin.pdr_override()\n\n# 분석 기간 설정\nend_date = datetime.datetime.now()\nstart_date = end_date - datetime.timedelta(365)\nticker = 'TCS'\n\ndf = pdr.get_data_yahoo(ticker + '.NS', start = start_date, end = end_date)\n```\n\n## FFT의 적용\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nnp.fft.fft()을 사용하여 푸리에 변환을 수행할 것이며, np.fft.fftfreq()를 사용하여 주파수를 얻을 것입니다. 가장 중요한 주파수가 나타나는 때를 나타내기 위해 진폭 대 주기를 그래프로 그려볼 수 있습니다.\n\n```js\nfft_result = np.fft.fft(df['Close'])\nfrequencies = np.fft.fftfreq(len(fft_result), d=1)  # assuming daily data, d=1\nmagnitude = np.abs(fft_result)\nperiods = 1 / frequencies\n```\n\n## 가격 및 주파수 영역 표현 시각화\n\n아래의 주파수 플롯은 시계열 내에서 우세한 주파수를 강조합니다. 이러한 주파수는 역 FFT를 수행하거나 원래 시계열을 다시 만들거나 잡음을 줄인 버전을 생성하는 데 사용될 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# 가격의 간단한 시각화\nplt.figure(figsize=(10, 8))\nplt.subplot(2, 1, 1)\nplt.plot(df.index, df['Close'])\nplt.title('TCS 시계열')\nplt.xlabel('날짜')\nplt.ylabel('가격')\n\n# 주파수 도메인 표현\nplt.subplot(2, 1, 2)\nplt.plot(periods, magnitude)\nplt.title('TCS의 FFT')\nplt.xlabel('기간 (일)')\nplt.ylabel('크기')\nplt.xlim(0, max(periods[1:]))  # 중요한 주기를 보기 위한 x-축 제한 (큰 주기 무시)\nplt.ylim(0, max(magnitude[1:]) * 1.1)  # 제로 주파수 구성요소 무시\n\nplt.tight_layout()\nplt.show()\n```\n\n<img src=\"/TIL/assets/img/2024-07-09-StockMarketSignalAnalysisUsingFastFourierTransform_0.png\" />\n\n하지만, 이러한 우세 주파수의 중요성은 단순히 시계열을 재구성하는 데서 그치지 않습니다. 이들은 시계열 구조에 영향을 미치는 주요 경제 보고서나 거시경제 사건과 관련될 수 있습니다.\n\n## 원래 주식 시장 데이터 복구하기\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nnp.fft.ifft() 함수를 사용하여 원래의 시계열을 복원할 수 있습니다. 이 함수는 fft_results를 역변환합니다. 아래 그래프에서 볼 수 있듯이 완벽하게 재구성되었습니다.\n\n```js\nrecovered = np.fft.ifft(fft_result);\nplt.figure((figsize = (14, 6)));\nplt.plot(df.index, df[\"Close\"], (label = \"Original\"));\nplt.plot(df.index, recovered, (label = \"Recovered\"));\nplt.title(\"TCS 시계열: FFT 역변환\");\nplt.xlabel(\"날짜\");\nplt.ylabel(\"가격\");\nplt.legend();\nplt.show();\n```\n\n<img src=\"/TIL/assets/img/2024-07-09-StockMarketSignalAnalysisUsingFastFourierTransform_1.png\" />\n\n## 주요 주파수를 갖는 파형의 재구성\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이것은 상위 25개 FFT 주파수만 사용하여 재구성된 신호를 생성합니다. 이것은 데이터의 노이즈 제거를 의미합니다.\n\n```js\ndominant_periods = pd.Series(periods, (index = magnitude)).nlargest(25);\ndominant_periods.to_frame(\"주기 (일)\");\ntop_periods = dominant_periods.index;\ntop_fft_result = fft_result.copy();\ntop_fft_result[np.abs(frequencies) > 1 / top_periods.min()] = 0;\ntop_recovered = np.fft.ifft(top_fft_result);\n\nplt.figure((figsize = (14, 6)));\nplt.plot(df.index, df[\"Close\"], (label = \"원본\"));\nplt.plot(df.index, top_recovered, (label = \"복원된\"));\nplt.title(\"TCS 시계열: FFT 역변환\");\nplt.xlabel(\"날짜\");\nplt.ylabel(\"가격\");\nplt.legend();\nplt.show();\n```\n\n<img src=\"/TIL/assets/img/2024-07-09-StockMarketSignalAnalysisUsingFastFourierTransform_2.png\" />\n\n# 결론\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 문서에서 설명한 알고리즘은 산업 전문가들이 사용하는 분석을 지나치게 단순화한 것입니다. 성능을 개선하기 위해 일반적으로 매일 모델을 조정합니다.\n\n도움이 되었기를 바라며, 여기에 GitHub 파일을 찾을 수 있습니다: [https://github.com/karantha-kur/Signal-Analysis-Using-FFT/tree/main](https://github.com/karantha-kur/Signal-Analysis-Using-FFT/tree/main)\n","ogImage":{"url":"/assets/img/2024-07-09-StockMarketSignalAnalysisUsingFastFourierTransform_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-StockMarketSignalAnalysisUsingFastFourierTransform_0.png","tag":["Tech"],"readingTime":7},{"title":"NanoLlava 가장 작은 시각적 언어란","description":"","date":"2024-07-09 15:02","slug":"2024-07-09-NanoLlavaisthesmallestVisualLanguage","content":"\n![이미지](/TIL/assets/img/2024-07-09-NanoLlavaisthesmallestVisualLanguage_0.png)\n\n요즘 뉴스에는 시각 언어 모델이 많이 등장하고 있어요. 지난 몇 일간의 발표 속에 믿기 어려운 소식이 많았는데, 이미지를 통해 대화를 하려면 돈을 내야 할까요?\n\nGPT-4o, Gemini-flash, PaliGemma, Copilot+PC… 이 모든 것이 1주일 안에 나왔어요!\n\n아무도 알지 못했지만 Abetlen이 GGUF 버전의 가장 작은 언어 모델인 TINIEST을 출시했다는 사실이죠.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n전체 모델은 NanoLlava를 만나실 수 있는 컴퓨터의 2GB 하드 디스크 공간에 저장됩니다.\n\n이 기사에서는 모델을 양자화하여 어떤 컴퓨터에서도 실행하는 방법을 배우게 될 것입니다. 전용 GPU 없이도 작업을 완료할 수 있습니다.\n\n```js\n# 목차\n---\n작고 강력한 모델\n모델을 시각적으로 만드는 것은 무엇인가요?\nPC에서 NanoLlava\n - 환경 설정\nInference call - textual\nStreamlit Application\n```\n\n# 작고 강력한\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n나노라바는 Sub 1B 비전-언어 모델입니다. 네, 정확히 들으셨어요! GPT-4o 수행능력을 기대하지 마세요 (그렇게 할 수는 있지만, ...혹은 소유중인 경우에만 가능합니다.)\n","ogImage":{"url":"/assets/img/2024-07-09-NanoLlavaisthesmallestVisualLanguage_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-NanoLlavaisthesmallestVisualLanguage_0.png","tag":["Tech"],"readingTime":2},{"title":"뉴럴 네트워크 손실 함수 이해 및 구현 방법 기초부터","description":"","date":"2024-07-09 15:01","slug":"2024-07-09-UnderstandingImplementingDifferentLossFunctionsofNeuralNetworksfromScratch","content":"\n<img src=\"/TIL/assets/img/2024-07-09-UnderstandingImplementingDifferentLossFunctionsofNeuralNetworksfromScratch_0.png\" />\n\n신경망의 매혹적인 세계에서 손실 함수는 훈련 과정을 정확한 예측으로 이끄는 안내 나침반 같은 역할을 합니다. 이러한 함수들을 숙달하는 것은 딥러닝에 진지하게 임하는 사람들에게 중요합니다. 왜냐하면 손실 함수를 선택하는 것은 모델의 성능에 상당한 영향을 미칠 수 있기 때문입니다. 신진 데이터 과학자든 경험 많은 기계 학습 엔지니어든, 이 블로그는 다양한 손실 함수를 해독하고 그 목적을 설명하며, 처음부터 구현하는 방법을 보여줍니다.\n\n자, 이러한 수학적 도구가 어떻게 신경망 훈련을 변화시킬 수 있는지 알아봅시다!\n\n그래서, 우리 마음에 떠오르는 첫 번째 질문은 '손실 함수란 무엇인가요?'입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/TIL/assets/img/2024-07-09-UnderstandingImplementingDifferentLossFunctionsofNeuralNetworksfromScratch_1.png)\n\n핵심적으로, 손실 함수(J로 표시됨)는 두 개의 매개변수를 입력으로 받는 수학 함수입니다:\n\n- 예측된 출력\n- 실제 출력\n\n이 함수는 모델의 예측 값과 모델이 생성해야 하는 실제 값과 비교하여 모델이 얼마나 잘 작동하는지를 평가하기 위해 사용됩니다. 예측 값이 실제 값과 크게 다를 경우 손실 값은 크게 나타납니다. 반면, 낮은 손실 값은 두 값이 거의 유사할 때 발생합니다. 따라서 효율적인 손실 함수를 사용하여 모델을 올바르게 훈련시키는 것이 중요합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n높은 손실 값은 모델의 예측이 부정확하다는 것을 시사하며, 네트워크를 크게 재조정해야 한다는 것을 의미합니다. 반면에 낮은 손실 값은 모델이 효과적으로 작동하고 있으며, 가중치를 매우 약간만 조정해야 한다는 것을 나타냅니다.\n\n이러한 시나리오는 새로운 요리법을 만드는 것과 유사합니다. 요리물이 실패하면 \"손실\"이 높아지고, 요리사는 다음에 요리물을 개선하기 위해 재료나 조리 방법에 상당한 변화를 해야 합니다. 그러나 요리물이 잘 나오면 이미 효과적인 레시피와 기술이기 때문에 필요한 경우에는 작은 조정만 필요합니다. 이 조정은 향후 블로그에서 논의할 하이퍼파라미터를 조정함으로써 수행할 수 있습니다. 이제 손실 함수가 무엇인지 이해했으므로, 다음으로 궁금한 것은 어떤 종류의 손실 함수가 있고 이를 어떻게 구현하는지에 대한 것입니다.\n\n신경망에서의 손실 함수 유형\n\n회귀 손실 함수\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 평균 제곱 오차 (MSE)\n\nMSE는 회귀 문제에 사용되는 가장 인기 있는 손실 함수 중 하나입니다. 이는 예측 값과 실제 값 사이의 오차의 제곱의 평균을 측정합니다. MSE는 이상치에 민감합니다.\n\n사용 사례: MSE는 주택 가격이나 온도와 같은 연속적인 값을 예측하는 회귀 문제에서 흔히 사용됩니다.\n\n수학적 공식:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 Markdown 형식으로 표시된 내용입니다.\n\n![이미지](/TIL/assets/img/2024-07-09-UnderstandingImplementingDifferentLossFunctionsofNeuralNetworksfromScratch_2.png)\n\nwhere,\n\n![이미지](/TIL/assets/img/2024-07-09-UnderstandingImplementingDifferentLossFunctionsofNeuralNetworksfromScratch_3.png)\n\n코드 구현:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\ndef mean_squared_error(y_true, y_predicted):\n    total_error = 0\n    for yt, yp in zip(y_true, y_predicted):\n        total_error += (yt-yp)**2\n    mse = total_error/len(y_true)\n    return mse\n```\n\n2. Mean Absolute Error (MAE)\n\nMAE는 예측 값과 실제 값 사이의 절대 오차의 평균을 측정합니다. MSE보다 이상치에 민감하지 않습니다.\n\n사용 사례: MAE는 중앙값 주택 가격을 예측하는 경우와 같이, 이상치에 민감하지 않은 손실 함수를 원할 때 사용됩니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n수학 공식:\n\n![수식](/TIL/assets/img/2024-07-09-UnderstandingImplementingDifferentLossFunctionsofNeuralNetworksfromScratch_4.png)\n\n코드 구현:\n\n```python\ndef mean_abs_error(y_predicted, y_true):\n    total_error = 0\n    for yp, yt in zip(y_predicted, y_true):\n        total_error += abs(yp - yt)\n    mae = total_error/len(y_predicted)\n    return mae\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n3. 휴버 손실\n\n휴버 손실은 MSE와 MAE의 우수한 특성을 결합하여, MSE보다 이상치에 민감하지 않고 MAE보다 원점 주변에서 부드럽습니다.\n\n사용 사례: 휴버 손실은 이상치의 영향을 줄이고 손실 함수를 미분 가능하게 유지하고자 하는 견고한 회귀 문제에서 자주 사용됩니다.\n\n수학적 공식:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Image](/TIL/assets/img/2024-07-09-UnderstandingImplementingDifferentLossFunctionsofNeuralNetworksfromScratch_5.png)\n\n코드 구현:\n\n```python\ndef huber_loss(y_true, y_pred, delta=1.0):\n    n = len(y_true)\n    loss = 0\n    for i in range(n):\n        diff = y_true[i] - y_pred[i]\n        if abs(diff) <= delta:\n            loss += 0.5 * diff ** 2\n        else:\n            loss += delta * (abs(diff) - 0.5 * delta)\n    return loss / n\n```\n\n분류 손실 함수\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n1. Binary Cross-Entropy 손실\n\nBinary Cross-Entropy 손실은 이진 분류 작업에 사용됩니다. 출력이 0과 1 사이의 확률 값인 분류 모델의 성능을 측정합니다.\n\n사용 사례: 스팸 감지나 사기 탐지와 같은 이진 분류 문제에 이 손실 함수가 이상적입니다.\n\n수학적 공식:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이미지 태그를 Markdown 형식으로 변경하세요.\n\n![UnderstandingImplementingDifferentLossFunctionsofNeuralNetworksfromScratch](/TIL/assets/img/2024-07-09-UnderstandingImplementingDifferentLossFunctionsofNeuralNetworksfromScratch_6.png)\n\n코드 구현:\n\n```python\nimport math\n\ndef binary_crossentropy(y_true, y_pred):\n    n = len(y_true)\n    loss = 0\n    for i in range(n):\n        loss += y_true[i] * math.log(y_pred[i]) + (1 - y_true[i]) * math.log(1 - y_pred[i])\n    return -loss / n\n```\n\n2. 범주형 Cross-Entropy Loss\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n범주형 크로스 엔트로피 손실은 다중 클래스 분류 작업에 사용됩니다. 이는 여러 클래스에 대한 확률 분포인 분류 모델의 성능을 측정합니다.\n\n활용 사례: 이 손실 함수는 숫자 인식(MNIST)이나 물체 검출과 같은 다중 클래스 분류 문제에 적합합니다.\n\n수학적 공식:\n\n![수식](/TIL/assets/img/2024-07-09-UnderstandingImplementingDifferentLossFunctionsofNeuralNetworksfromScratch_7.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n구현된 코드:\n\n```js\nimport math\n\ndef categorical_crossentropy(y_true, y_pred):\n    n = len(y_true)\n    c = len(y_true[0])\n    loss = 0\n    for i in range(n):\n        for j in range(c):\n            if y_true[i][j] == 1:\n                loss += y_true[i][j] * math.log(y_pred[i][j])\n    return -loss / n\n```\n\n3. Sparse Categorical Cross-Entropy Loss\n\nSparse Categorical Cross-Entropy는 목표 레이블이 원-핫 인코딩된 벡터가 아닌 정수일 때 사용됩니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n사용 사례: 이 손실 함수는 타겟 레이블이 one-hot 벡터가 아닌 정수 레이블 형태인 다중 클래스 분류 문제에서 사용됩니다.\n\n수학적 공식:\n\n![이미지](/TIL/assets/img/2024-07-09-UnderstandingImplementingDifferentLossFunctionsofNeuralNetworksfromScratch_8.png)\n\n코드 구현:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ndef sparse_categorical_cross_entropy(y_true, y_pred):\n    n = len(y_true)\n    loss = 0\n    for i in range(n):\n        loss += y_true[i] * math.log(y_pred[i]))\n    return -loss / n\n```\n\n거기에는 몇 가지 더 특별한 손실 함수가 있어요:\n\n- Kullback-Leibler Divergence\n- Cosine Similarity Loss\n- Dice Loss\n- Quantile Loss\n- Hinge Loss\n\n이제 손실 함수에 대해 간결하고 명확하게 이해하셨기를 바랍니다. 다가오는 블로그에서는 특별한 손실 함수, 사용 사례 및 구현에 대해 논의할 예정이에요. 컴퓨터 비전과 딥 러닝에 관한 더 많은 기사를 위해 블로그를 팔로우해 주세요. 궁금한 사항이 있거나 특정 부분에 대한 추가 정보가 필요하면 언제든지 의견을 남겨주세요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마크다운 형식으로 표 태그를 변경하세요: Linkedin\n","ogImage":{"url":"/assets/img/2024-07-09-UnderstandingImplementingDifferentLossFunctionsofNeuralNetworksfromScratch_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-UnderstandingImplementingDifferentLossFunctionsofNeuralNetworksfromScratch_0.png","tag":["Tech"],"readingTime":10},{"title":"Mojo, Python보다 90,000배 빠르다 드디어 오픈소스 공개 출시 즉시 17,000 스타 돌파","description":"","date":"2024-07-09 15:00","slug":"2024-07-09-Mojo90000TimesFasterThanPythonFinallyOpenSourcedJustLaunchedAlreadySurpassing17000Stars","content":"\n2024년 3월 29일, Modular Inc.은 Mojo의 핵심 구성 요소를 오픈 소스화한다고 발표했습니다.\n\nMojo는 작년 8월에 공식적으로 출시된 인공 지능 소프트웨어를 작성하기 위해 특별히 설계된 프로그래밍 언어입니다. 그 이후로 17만 5천 명 이상의 개발자와 5천 개 이상의 기관이 모아졌습니다.\n\n인공 지능 모델은 종종 여러 프로그래밍 언어로 작성됩니다. 개발자는 일반적으로 가장 간단한 신경망의 일부를 구현하기 위해 Python을 사용합니다. Python은 배우기 쉽지만 비교적 느린 속도 때문에 사용됩니다. 남은 코드는 보통 C++로 작성되며, C++은 더 빠르지만 학습하기에 복잡합니다.\n\nModular은 Mojo를 더 편리한 대안으로 위치시킵니다. Python과 유사한 쉬운 구문을 제공하지만 수천 배 더 빠른 실행 속도를 갖도록 하며, 이를 통해 개발자들은 C++과 같은 복잡한 언어를 배우지 않고도 빠른 AI 모델을 작성할 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/TIL/assets/img/2024-07-09-Mojo90000TimesFasterThanPythonFinallyOpenSourcedJustLaunchedAlreadySurpassing17000Stars_0.png\" />\n\n지난해 Mojo가 소개됐을 때, 일부 개발자들은 그 등장에 들뜬 기대를 표현했습니다. 그러나 Chris Lattner은 디스코드에서 오픈 소스 날짜에 대해 물어볼 때 \"알았다면 말했을 거야.\" 라고 말했습니다. 약 1년 동안 많은 개발자들이 관찰하며 의심의 태도를 보였습니다:\n","ogImage":{"url":"/assets/img/2024-07-09-Mojo90000TimesFasterThanPythonFinallyOpenSourcedJustLaunchedAlreadySurpassing17000Stars_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-Mojo90000TimesFasterThanPythonFinallyOpenSourcedJustLaunchedAlreadySurpassing17000Stars_0.png","tag":["Tech"],"readingTime":2},{"title":"PyFilesystem2 OpenCV로 캡처한 프레임을 메모리 파일 시스템에 저장하는 방법","description":"","date":"2024-07-09 14:59","slug":"2024-07-09-PyFilesystem2StoringFramesCapturedbyOpenCVinanIn-MemoryFilesystem","content":"\n<img src=\"/TIL/assets/img/2024-07-09-PyFilesystem2StoringFramesCapturedbyOpenCVinanIn-MemoryFilesystem_0.png\" />\n\n소개\nPyFilesystem2은 Python에서 파일 시스템을 다루는 강력하고 유연한 라이브러리로, 개발자들이 파일과 디렉토리를 쉽게 관리할 수 있습니다. PyFilesystem2의 매력적인 기능 중 하나는 인메모리 파일 시스템을 지원한다는 점인데, 이는 테스트, 데이터 캐싱, 빠른 처리 등 다양한 목적에 유용할 수 있습니다. 본 문서에서는 OpenCV로 캡처된 비디오 프레임을 인메모리 파일 시스템에 저장하는 방법을 알아보겠습니다.\n\n필수 조건\n시작하려면 PyFilesystem2 및 OpenCV 두 라이브러리를 설치해야 합니다. 다음 명령어로 pip를 사용하여 이 라이브러리들을 설치할 수 있습니다:\n\n인메모리 파일 시스템 생성\n먼저 인메모리 파일 시스템을 생성해야 합니다. 이 작업은 PyFilesystem2 라이브러리의 `MemoryFS` 클래스를 사용하여 수행할 수 있습니다. 아래는 인메모리 파일 시스템을 생성하고 그 안에 간단한 파일을 저장하는 예제입니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nOpenCV을 사용하여 비디오 프레임 캡처하기\n비디오 프레임을 캡처하기 위해 OpenCV 라이브러리를 사용할 것입니다. OpenCV는 이미지 및 비디오 처리에 사용되는 오픈 소스 라이브러리입니다. 카메라 또는 비디오 파일에서 비디오 프레임을 캡처하는 방법은 다음과 같습니다:\n\n인메모리 파일 시스템에 프레임 저장하기\n이제 비디오 프레임을 캡처할 수 있으므로, 이러한 프레임을 인메모리 파일 시스템에 저장해야 합니다. 이를 위해 먼저 프레임을 이미지 형식 (예: PNG)으로 변환한 다음 파일 시스템에 저장합니다.\n\n결론\n본 문서에서는 PyFilesystem2를 사용하여 OpenCV로 캡처한 비디오 프레임을 인메모리 파일 시스템에 저장하는 방법을 살펴보았습니다. 이 접근 방식을 사용하면 실시간 및 임시 처리 작업에 매우 유용한 비디오 프레임을 빠르게 임시로 저장할 수 있습니다. PyFilesystem2는 다양한 유형의 파일 시스템을 쉽게 관리하고 프로젝트에서 활용할 수 있는 강력한 도구입니다.\n","ogImage":{"url":"/assets/img/2024-07-09-PyFilesystem2StoringFramesCapturedbyOpenCVinanIn-MemoryFilesystem_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-PyFilesystem2StoringFramesCapturedbyOpenCVinanIn-MemoryFilesystem_0.png","tag":["Tech"],"readingTime":2},{"title":"주식 거래에서 가장 인기 있는 10가지 금융 지표","description":"","date":"2024-07-09 14:59","slug":"2024-07-09-TheMostPopularFinancialMetricsinStockTrading","content":"\n\n주식 거래에서 사용되는 금융 지표는 많지만, 가장 인기 있는 일부는 다음과 같습니다:\n\n- 주당 순이익 (EPS): 주당 순이익은 기업의 이익 중 주당 주식에 배정된 부분입니다. 기업의 수익성과 성장 잠재력을 평가하는 데 사용되는 주요 지표입니다.\n- 주가 이익 비율 (P/E 비율): 주가 이익 비율은 주식 가격을 주당 이익과 비교하는 가격 평가 비율입니다. 기업의 현재 주가를 이익과 비교하며, 다른 기업의 가치를 비교하는 데 사용됩니다.\n- 배당 수익률: 배당 수익률은 기업의 연간 배당 지급액을 현재 주가로 나눈 값입니다. 주식 투자의 수익 잠재력을 평가하는 데 사용됩니다.\n- 시가 총액: 시가 총액은 기업의 유통 중인 주식의 총 가치입니다. 기업의 규모를 평가하고 다른 기업의 상대적 규모를 비교하는 데 사용됩니다.\n- 자기 자본 수익률 (ROE): 자기 자본 수익률은 기업이 주주 자본 양에 비례하여 얼마나 많은 이익을 창출하는지를 측정하는 수익성 비율입니다. 기업의 수익성과 효율성을 평가하는 데 사용됩니다.\n- 부채 자본 비율: 부채 자본 비율은 기업의 총 부채를 총 자본에 비교하는 금융 비율입니다. 부채 비율을 평가하는 것에 사용됩니다.","ogImage":{"url":"/TIL/assets/no-image.jpg"},"coverImage":"/TIL/assets/no-image.jpg","tag":["Tech"],"readingTime":1},{"title":"NiceGUI를 만나보세요 곧 여러분의 최애 파이썬 UI 라이브러리가 될 이유","description":"","date":"2024-07-09 14:57","slug":"2024-07-09-MeettheNiceGUIYourSoon-to-beFavoritePythonUILibrary","content":"\n## 사용자 정의 웹 앱을 쉽고 빠르게 만드세요\n\n![이미지](/TIL/assets/img/2024-07-09-MeettheNiceGUIYourSoon-to-beFavoritePythonUILibrary_0.png)\n\n만나보세요, NiceGUI! 이 간단한 Python 기반 UI 프레임워크는 웹 브라우저나 데스크톱 앱에서 원활하게 작동합니다. 작은 웹 앱, 대시보드, 또는 로봇 프로젝트를 만들고 있는 중이던 중이든, NiceGUI는 쉬운 인터페이스와 다양한 기능으로 여러분을 도와줄 거예요.\n\n이 글의 목표는 이 라이브러리의 장단점을 나열하고 어떻게 NiceGUI 앱을 만들고 배포할 수 있는지 보여줌으로써 여러분이 한 번 시도해보길 설득하는 것입니다. (이 게시물은 후원받은 것이 아니에요, 그냥 이 라이브러리를 좋아해서 쓴거에요 🙃)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nStreamlit 대 NiceGUI: 왜 바꾸어야 할까요?\n\nStreamlit은 대화형 앱을 만드는 데 좋지만, 이벤트 및 상태 처리가 어려울 수 있습니다. 특히 큰 프로젝트의 경우 더 그렇습니다. NiceGUI는 다릅니다. NiceGUI를 사용하면 추가적인 단계나 고난한 해결책 없이 상태와 상호작용을 직접 제어할 수 있습니다.\n\n간단한 상태 관리\n\nNiceGUI는 상태를 쉽게 관리할 수 있습니다. Streamlit과 달리 예상치 못한 상태 재설정이 발생하지 않습니다. NiceGUI는 시작 상태든 사용자가 만든 변경 사항이든 모든 것을 안정적으로 유지합니다. 사용자 상호작용을 처리하기 위해 콜백을 사용할 수 있으며 전체 페이지 새로고침으로 인한 괴롭힘 없이 상태 데이터를 유지할 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n많은 기능들\n\nNiceGUI에는 여러 가지 멋진 기능들이 많이 있어요:\n\n- 상호 작용을 위한 버튼, 스위치, 슬라이더, 입력 등 다양한 요소들이 있어요.\n- 화면에 요소들을 쉽게 배치할 수 있는 방법이 있어요.\n- 차트, 테이블, 심지어 3D 씬까지 시각화에 사용할 수 있어요.\n- Matplotlib 또는 Plotly와 같은 데이터 시각화 라이브러리와 통합이 되어 있어요.\n- 색상과 스타일을 쉽게 사용자 정의할 수 있어요.\n- 코딩과 테스트에 도움이 되는 도구들이 있어요.\n- 주 개발자들은 항상 질문에 대답할 준비가 되어 있고, GitHub 공간에 피드백을 매우 긍정적으로 반영해요.\n- 인기 있는 프레임워크 위에 구축되어 있어요: FastAPI, Vue3, Tailwind, Quasar.\n- 전체 사이트가 NiceGUI 라이브러리로 제작되었어요: https://nicegui.io/documentation\n\n제한사항\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNiceGUI은 정말 멋지지만, 작은 커뮤니티 규모 때문에 다소 제약이 있을 수 있습니다. Streamlit과 같이 인기 있는 프레임워크보다 학습 곡선이 조금 더 길 수도 있습니다. 라이브러리의 기능을 최대한 활용하려면 CSS와 Tailwind CSS에 익숙해지는 것이 좋습니다. 또한, FastAPI, Vue, 그리고 Quasar에 대한 지식은 더 큰 유연성을 제공하고 구현할 수 있는 기능을 확장할 수 있습니다.\n\n# 실습\n\n이제 NiceGUI의 몇 가지 기능을 탐험하고 데모 앱을 만들고 배포해 봅시다.\n\n## 기본 앱\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n먼저 NiceGUI를 설치해주세요:\n\n```js\npip install nicegui[highcharts]\n```\n\n주요 문서의 예제에서 시작해보겠습니다:\n\n```js\n# https://nicegui.io/documentation/section_data_elements\nfrom nicegui import ui\nfrom random import random\n\nchart = ui.highchart({\n    'title': False,\n    'chart': {'type': 'bar'},\n    'xAxis': {'categories': ['A', 'B']},\n    'series': [\n        {'name': 'Alpha', 'data': [0.1, 0.2]},\n        {'name': 'Beta', 'data': [0.3, 0.4]},\n    ],\n}).classes('w-full h-64')\n\ndef update():\n    chart.options['series'][0]['data'][0] = random()\n    chart.update()\n\nui.button('Update', on_click=update)\n\nui.run()\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기서 UI 모듈은 UI 요소를 만들 수 있도록합니다.\n이 예시에서 먼저 Highchart 요소를 생성하는데, 이에 w-full과 h-64의 tailwind 클래스를 할당합니다. w-full은 반응형으로 화면 전체를 가로로 사용하고 h-64는 높이를 지정합니다.\n\n![image](https://miro.medium.com/v2/resize:fit:1162/1*IbE0mHsejGUzviDgE2He3g.gif)\n\n버튼을 클릭하면 콜백 함수가 트리거됩니다. 이 콜백은 차트에 사용되는 데이터를 업데이트하고 그것을 순조롭게 다시 렌더링합니다.\n\n또한, 새로운 막대를 추가하기 위해 콜백을 변경할 수도 있습니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ndef update():\n    chart.options[\"xAxis\"][\"categories\"].append(random.choice(string.ascii_uppercase))\n    for series in chart.options['series']:\n        series[\"data\"].append(random.random())\n    chart.update()\n```\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*P-IGyImlGMvNFut9LluamA.gif)\n\n또한 페이지를 새로 고침해도 데이터가 손실되지 않는다는 것을 알아두세요! 이것은 다른 Python UI 라이브러리로는 할 수 없는 일입니다. 이렇게 작동하는 이유는 데이터가 모든 사용자 사이에서 공유되기 때문이지만, 앱 저장소의 사용자 객체나 앱 저장소 브라우저같은 방법으로 데이터를 사용자별로 유지하는 방법이 많이 있습니다. @ui.page 데코레이터로 감싸기 위해 app.storage.user 객체나 app.storage.browser를 사용할 수 있습니다.\n\n하지만 주기적 타이머를 사용하여 UI를 업데이트하고 싶다면 어떻게 할까요? 쉽습니다! 버튼 요소를 ui.timer로 변경해주기만 하면 됩니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nui.timer(5, callback=lambda: (update(), ui.notify(\"데이터가 업데이트되었습니다\")))\n```\n\n![gif](https://miro.medium.com/v2/resize:fit:1400/1*wwSF1ib9720JW1FlKDOc0g.gif)\n\n자, 이제 사용자가 범주를 선택한 다음 무작위로 Chuck Norris Fact를 생성할 수 있는 데모 앱을 만들어 봅시다.\n\n먼저, 여기에 메인 코드가 있습니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nimport requests  # HTTP 요청을 만들기 위해 requests 라이브러리를 가져옵니다\nfrom nicegui import ui  # NiceGUI 라이브러리에서 UI 구성 요소를 가져옵니다\nfrom nicegui_app.header import add_head_html  # HTML 헤드 내용을 추가하는 함수를 가져옵니다\n\n# Chuck Norris 사실 카테고리 목록\nCATEGORIES = [\n    \"동물\",\n    \"직업\",\n    \"연예인\",\n    \"개발\",\n    \"패션\",\n    \"음식\",\n    \"돈\",\n    \"영화\",\n    \"음악\",\n    \"과학\",\n    \"스포츠\",\n    \"여행\",\n]\n\n# Chuck Norris 사실을 처리하는 클래스\nclass Fact:\n    def __init__(self):\n        self.fact = None  # fact 속성을 None으로 초기화\n\n    # 주어진 카테고리를 기반으로 사실을 업데이트하는 메서드\n    def update_fact(self, category):\n        url = f\"https://api.chucknorris.io/jokes/random?category={category}\"  # Chuck Norris API URL\n\n        for i in range(10):  # 유효한 사실을 가져오려고 최대 10번 시도\n            result = requests.get(url)  # Chuck Norris API로 GET 요청을 보냄\n\n            if result.status_code == 200:  # 요청이 성공하면\n                result_json = result.json()  # JSON 응답을 파싱\n                if self.fact != result_json[\"value\"]:  # 가져온 사실이 현재 사실과 다르면\n                    self.fact = result_json[\"value\"]  # 사실을 업데이트하고\n                    break  # 루프를 종료\n\n# Chuck Norris 사실 UI를 생성하는 함수\ndef chuck():\n    add_head_html()  # NiceGUI 앱에 HTML 헤드 내용 추가\n\n    default_value = CATEGORIES[0]  # Chuck Norris 사실의 기본 카테고리\n\n    fact = Fact()  # Fact 클래스의 인스턴스 생성\n    fact.update_fact(default_value)  # 기본 카테고리로 사실을 업데이트\n\n    # 12개 열을 가진 그리드 레이아웃 생성\n    with ui.grid(columns=12).classes(\"w-full\"):\n        # 카테고리 선택을 위한 열\n        with ui.column().classes(\"col-span-4 sm:col-span-2 space-x-0\"):\n            ui.label(\"사실 카테고리 선택:\")  # 카테고리 선택을 위한 레이블 표시\n            # 카테고리 선택을 위한 라디오 버튼 그룹\n            category = ui.radio(\n                CATEGORIES,\n                value=default_value,\n                on_change=lambda _: fact.update_fact(category.value),  # 카테고리가 변경되면 사실 업데이트\n            ).classes(\"w-full\")\n            # 선택한 카테고리에 대한 사실을 다시 생성하는 버튼\n            ui.button(\n                \"⟳ 다시 생성\", on_click=lambda _: fact.update_fact(category.value)\n            )\n\n        # Chuck Norris 사실을 표시하는 열\n        with ui.column().classes(\n            \"flex col-span-8 sm:col-span-10 w-full justify-center mx-auto max-w-screen-md\"\n        ):\n            # Chuck Norris 사실을 표시하기 위한 레이블, Fact 인스턴스의 fact 속성에 바인딩\n            ui.label().bind_text_from(fact, \"fact\").classes(\n                \"text-lg sm:text-3xl text-gray-800 bg-gray-100 rounded-lg shadow-lg p-6\"\n            )\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nclass Fact:\n    def __init__(self):\n        self.fact = None  # fact 속성을 None으로 초기화합니다.\n\n    # 주어진 카테고리에 따라 팩트를 업데이트하는 메소드\n    def update_fact(self, category):\n        url = f\"https://api.chucknorris.io/jokes/random?category={category}\"  # 척 노리스 API의 URL입니다.\n\n        for i in range(10):  # 유효한 팩트를 가져오기 위해 최대 10번 시도합니다.\n            result = requests.get(url)  # 척 노리스 API에 GET 요청을 보냅니다.\n\n            if result.status_code == 200:  # 요청이 성공한 경우\n                result_json = result.json()  # JSON 응답을 파싱합니다.\n                if self.fact != result_json[\"value\"]:  # 가져온 팩트가 현재 팩트와 다른 경우\n                    self.fact = result_json[\"value\"]  # 팩트 속성을 업데이트합니다.\n                    break  # 루프를 종료합니다\n```\n\n이 클래스는 \"fact\" 속성에 팩트를 저장하고 Chuck Norris 팩트 API를 호출하는 update_fact 메소드를 가지고 있습니다. https://api.chucknorris.io\n\n다음으로, \"chuck\" 함수에서 페이지를 정의합니다. NiceGUI는 여러 모듈과 Python 파일을 거쳐 앱을 정의할 수 있는 모듈식 접근 방식을 채택합니다.\n\n우리는 데이터 클래스의 인스턴스인 fact = Fact()을 정의합니다. 이는 각 사용자별로 구체적인 인스턴스입니다. 그리고 다음으로 update_fact 메소드를 사용하여 팩트를 초기화합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 UI 요소를 정의하기 시작합니다.\n\n두 개의 열을 갖는 그리드를 정의합니다:\n\n- 카테고리 옵션 및 생성 버튼이있는 첫 번째 열입니다. 이 열은 다음과 같은 tailwind 클래스를 갖습니다: col-span-4 sm:col-span-2. 이것은 매우 작은 화면의 경우 화면의 4/12을 사용하고, 그렇지 않으면 화면의 2/12을 사용합니다. 이렇게 함으로써 디자인을 모바일 전화에서도 작동하게 할 수 있습니다.\n- 사실을 표시할 두 번째 열입니다.\n\n첫 번째 열을 위해:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 라디오 메뉴 `ui.radio`.\n- 무작위 사실을 생성하는 버튼이 있습니다.\n\n두 요소 모두 클릭되거나 변경될 때 `fact.update_fact`를 호출하는 콜백을 사용합니다.\n\n두 번째 열에 대해서:\n\n- `fact.fact` 값을 바인딩하는 `ui.label`이 있습니다. 이 변수가 변경될 때마다 디스플레이가 자동으로 업데이트됩니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래에 있는 테일윈드 클래스를 가진 레이블입니다: text-lg sm:text-3xl 이렇게 하면 텍스트가 작은 화면에서 더 작아집니다.\n\n다음 앱을 얻게 되요:\n\n![앱 이미지](https://miro.medium.com/v2/resize:fit:1400/1*ElNrpcoZndHh1If8Cme9kQ.gif)\n\n멋지죠?\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 배포\n\n앱을 배포하는 것은 쉬워요! 예를 들어 CloudRun을 사용하면 매우 간단해요. Dockerfile을 생성한 다음 다음 gcloud 명령어를 실행하기만 하면 돼요:\n\n```js\nPROJECT_ID=$(gcloud config get-value project)\nREPO=\"demo\"\nLOCATION=\"europe-west1\"\nIMAGE=\"nicegui_app\"\nSERVICE_NAME=\"nicegui-app\"\nVERSION=\"0.0.1\"\nGAR_TAG=$LOCATION-docker.pkg.dev/$PROJECT_ID/$REPO/$IMAGE:$VERSION\n\n# 저장소 생성\ngcloud artifacts repositories create $REPO --repository-format=docker \\\n    --location=$LOCATION --description=\"Docker repository\" \\\n    --project=$PROJECT_ID  || true # 이미 존재하는 경우를 위해 실패해도 괜찮아요\n\n# 이미지 빌드\ngcloud builds submit --tag $GAR_TAG\n\n# Cloud Run 배포\ngcloud run deploy $SERVICE_NAME --image=$GAR_TAG --max-instances=1 --min-instances=0 --port=8080 \\\n --allow-unauthenticated --region=europe-west1 --memory=0.5Gi --cpu=1 -q --no-cpu-throttling --session-affinity\n```\n\n이렇게 하면 클라우드 빌드를 사용하여 도커 이미지를 빌드한 다음 CloudRun에 배포할 수 있어요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기서 유일한 키큰 옵션은 다음과 같습니다: \"— no-cpu-throttling — session-affinity\". 이를 통해 동일한 사용자가 가능한 경우 동일한 컨테이너로 라우팅되고 요청 사이에 CPU가 활성 상태로 유지됩니다.\n\n마지막으로\n\nNiceGUI는 파이썬을 사용해 빠르고 쉽게 사용자 인터페이스를 만들고 싶을 때 좋은 선택입니다. 여기에서는 내부 상태를 완전히 제어하고 테스트하고 쉽게 배포할 수 있는 강력한 파이썬 앱을 구축할 수 있습니다. 이를 통해 데이터 과학 프로젝트에서도 도구로 제한받지 않고 창의성을 발휘할 수 있을 것입니다.\n\n여기에 표시된 내용은 NiceGUI로 할 수 있는 작은 부분에 불과합니다. 아래 링크를 따라가면 더 많은 것을 배울 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n자원:\n\n- Chuck Norris (매우 과장된) 사실 API: [https://api.chucknorris.io/](https://api.chucknorris.io/)\n- NiceGUI 문서: [https://nicegui.io/documentation](https://nicegui.io/documentation)\n- NiceGUI 예제: [https://github.com/zauberzeug/nicegui/tree/main/examples](https://github.com/zauberzeug/nicegui/tree/main/examples)\n- 이 게시물의 코드: [https://github.com/CVxTz/nicegui_tutorial](https://github.com/CVxTz/nicegui_tutorial)\n","ogImage":{"url":"/assets/img/2024-07-09-MeettheNiceGUIYourSoon-to-beFavoritePythonUILibrary_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-MeettheNiceGUIYourSoon-to-beFavoritePythonUILibrary_0.png","tag":["Tech"],"readingTime":14},{"title":"GRASP 원칙 견고하고 유지보수 가능한 코드의 기초","description":"","date":"2024-07-09 14:55","slug":"2024-07-09-GRASPPrinciplesTheFoundationofRobustandMaintainableCode","content":"\n## 일반 책임 할당 소프트웨어 패턴\n\n![그림](/TIL/assets/img/2024-07-09-GRASPPrinciplesTheFoundationofRobustandMaintainableCode_0.png)\n\nGRASP(일반 책임 할당 소프트웨어 패턴) 원칙은 객체지향 설계에서 객체와 클래스에 책임을 할당하는 데 도움이 되는 지침 세트입니다.\n\n이러한 원칙은 처음으로 Craig Larman이 그의 책 \"UML과 패턴 적용\"에서 소개했습니다. 그 책 정말 좋아요; 이전에 읽지 않았다면 읽어보시기를 추천합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/TIL/assets/img/2024-07-09-GRASPPrinciplesTheFoundationofRobustandMaintainableCode_1.png\" />\n\n이러한 패턴들은 개발자가 핵심 객체 지향 설계 원칙을 이해하고 적용하는 데 도움이 되는 교육 도구입니다. 이 패턴들은 개발자들이 책임을 클래스와 객체에 체계적으로 할당하고, 잘 구조화되고 유지보수 가능한 소프트웨어를 촉진하는 데 도움을 줍니다.\n\nGRASP를 따르면, 개발자들은 합리적이고 설명 가능한 설계 결정을 내릴 수 있도록 하여, 시스템의 각 구성 요소가 명확하고 정당화된 역할을 갖도록 보장할 수 있습니다.\n\n## 책임 주도 설계\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nRDD는 소프트웨어 설계 방법으로, 소프트웨어 구성 요소에 명확한 책임을 할당하는 것을 강조합니다. 각 구성 요소(일반적으로 객체 또는 클래스)는 잘 정의된 역할과 다른 구성 요소와의 상호 작용을 갖습니다.\n\nGRASP 패턴의 주요 원칙은 역할을 찾아 객체에 할당하는 것입니다. 즉, 이러한 할당을 안내하는 원칙 세트를 제공합니다.\n\nLarman의 책에서 역할을 두 가지 주요 유형으로 나눕니다:\n\n역할 인식: 객체는\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 그 데이터 또는 상태 (캡슐화)입니다.\n- 그 주변의 기타 관련된 객체들 (결합 등). 누구와 협력하나요?\n- 비즈니스. 무슨 일을 할 건가요? 어떻게 할 건가요?\n\n기능 책임: 객체가 하는 일\n\n- 비즈니스 계산 수행 또는 객체 생성과 같은 동작을 수행합니다. (원자적 작업)\n- 다른 객체에게 작업을 수행하도록 유발합니다.\n- 다른 객체들에서 작업 (비즈니스 프로세스)을 조정합니다. (조정 작업)\n\nGRASP 원칙:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 정보 전문가\n- 생성자\n- 높은 응집도\n- 낮은 결합도\n- 컨트롤러\n- 다형성\n- 순수한 가공물\n- 간접성\n- 보호된 변화\n\n## 정보 전문가\n\n해당 작업을 수행하는 데 필요한 정보를 갖고 있는 클래스에 책임을 할당해야 합니다. 가장 관련성 있는 데이터를 갖고 있는 클래스가 관련된 동작을 처리하는 책임을 져야 합니다.\n\n이는 캡슐화를 강조하고 데이터 결합을 피하기 위한 것입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예를 들어, 작업을 수행하는 메서드를 가지고 있다고 가정해보겠습니다. 이 메서드가 데이터를 사용한다면, 해당 메서드는 데이터가 포함된 클래스에 배치되어야 합니다.\n\n![이미지](/TIL/assets/img/2024-07-09-GRASPPrinciplesTheFoundationofRobustandMaintainableCode_2.png)\n\n제품에 대한 할인을 계산하려고 합니다.\n\n좋지 않은 예: DiscountCalculator 클래스가 제품 클래스에서 데이터를 사용하여 할인 가격을 계산합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nclass Product:\n    def __init__(self, name: str, price: float, discount: float):\n        self.name = name\n        self.price = price\n        self.discount = discount\n\nclass Order:\n    def __init__(self, product: Product, quantity: int):\n        self.product = product\n        self.quantity = quantity\n\n    def calculate_total_price(self) -> float:\n        return self.product.price * self.quantity\n\nclass DiscountCalculator:\n    def calculate_discounted_price(self, order: Order) -> float:\n        discount = order.product.price * (order.product.discount / 100)\n        return order.product.price - discount\n```\n\nDiscountCalculator 클래스가 필요한 정보를 스스로 캡슐화하지 않고 외부 데이터에 의존합니다.\n\nProduct는 책임이 없습니다. 실제 클래스가 아닙니다.\n\n좋은 점: 할인을 계산하는 메서드가 필요한 데이터를 포함한 클래스에 위치합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nclass Product:\n    def __init__(self, name: str, price: float, discount: float):\n        self.name = name\n        self.price = price\n        self.discount = discount\n\n    def calculate_discounted_price(self) -> float:\n        discount = self.price * (self.discount / 100)\n        return self.price - discount\n\nclass Order:\n    def __init__(self, product: Product, quantity: int):\n        self.product = product\n        self.quantity = quantity\n\n    def calculate_total_price(self) -> float:\n        return self.product.calculate_discounted_price() * self.quantity\n```\n\nProduct 클래스에는 할인 가격을 계산하는 calculate_discounted_price 메서드가 있습니다. 이 메서드는 가격과 할인율과 같은 필요한 정보를 포함하는 Product 클래스 내에 위치합니다. 이렇게 함으로써 관련된 동작을 다루는 관련 데이터를 포함하는 클래스가 해당 동작을 처리하므로 정보 전문가 원칙을 따르며 캡슐화를 촉진하고 데이터 결합을 줄입니다.\n\n## Creator\n\n다른 클래스의 인스턴스를 생성하는 책임이 있는 클래스에 대한 지침을 제공합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n창작자 원칙에 따르면 클래스 B는 다음 조건 중 하나 이상이 참일 때 클래스 A의 인스턴스를 생성하는 역할을 수행해야 합니다:\n\n- 집약: B가 A 객체를 집약함.\n- 합성: B가 A 객체를 포함함.\n- 초기화: B가 A 객체를 밀접하게 사용함.\n- 연관: B가 A 객체를 생성하기 위한 초기화 데이터를 가짐.\n- 의존성: B가 A 객체의 인스턴스를 기록함.\n\n이러한 관계를 기억하는 데 도움이 될 수 있습니다:\n\n여러 옵션이 적용되는 경우 집약 또는 포함 (우선 순위가 높음)하는 클래스 B를 선호합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# Class B는 클래스 A의 객체들을 모으는 역할을 합니다.\n\nclass A:\n    def __init__(self, value):\n        self.value = value\n\nclass B:\n    def __init__(self):\n        self.a_objects = []\n\n    def add_a(self, value):\n        a = A(value)  # B가 A를 생성합니다\n        self.a_objects.append(a)\n```\n\n```js\n# Class B는 클래스 A의 객체들을 포함합니다.\n\nclass A:\n    def __init__(self, value):\n        self.value = value\n\nclass B:\n    def __init__(self, value1, value2):\n        self.a1 = A(value1)  # B가 A를 생성합니다\n        self.a2 = A(value2)  # B가 A를 생성합니다\n```\n\n```js\n# Class B는 클래스 A의 객체들을 밀접하게 사용합니다.\n\nclass A:\n    def __init__(self, value):\n        self.value = value\n\nclass B:\n    def __init__(self, value):\n        self.a = A(value)  # B가 A를 생성합니다\n\n    def get_a_value(self):\n        return self.a.value\n```\n\n```js\n# Class B는 클래스 A의 객체를 만들기 위한 초기화 데이터를 갖습니다.\n\nclass A:\n    def __init__(self, value):\n        self.value = value\n\nclass B:\n    def __init__(self, value):\n        self.a = self.create_a(value)  # B가 A를 생성합니다\n\n    def create_a(self, value):\n        return A(value)\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# Class B은 Class A의 인스턴스를 기록합니다.\n\nclass A:\n    def __init__(self, value):\n        self.value = value\n\nclass B:\n    def __init__(self):\n        self.a_objects = []\n\n    def add_a(self, value):\n        a = A(value)  # B가 A를 생성\n        self.a_objects.append(a)\n```\n\n위 내용에서 알 수 있듯이, 이 원리는 객체 지향 설계에서 객체를 생성하는 데 특히 책임이 있는 생성 디자인 패턴과 관련이 있습니다.\n\n예를 들어, Factory 디자인 패턴은 슈퍼클래스에서 객체를 생성하는 인터페이스를 제공합니다.\n\nFactory 디자인 패턴에서는 세부 사항을 알 필요가 없습니다. 이 패턴은 \"필요한 데이터를 제공하면 객체를 생성할 테니까\"라고 합니다. 그것은 객체를 만드는 방법을 알지만 그것을 사용하지는 않습니다. 그저 생성합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 높은 응집도 & 낮은 결합도\n\n낮은 결합도는 클래스 간의 의존성을 줄여 시스템을 더 모듈화하고 유지 관리하기 쉽게 만듭니다.\n\n높은 응집도는 각 클래스가 명확한 목적을 갖도록 합니다.\n\n이 두 가지 개념에 대해 이미 다른 게시물에서 설명했기 때문에 여기서 다시 설명하지는 않겠습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## Controller\n\n입력 시스템 이벤트가 발생했을 때(예: 사용자가 버튼을 클릭하거나 타이머가 만료되거나 센서가 변경을 감지한 경우), Controller 원칙은 어떤 클래스가 이벤트를 처리해야 하는지 결정하는 데 도움을 줍니다. Controller는 필요한 조치를 조정하고 다른 객체에 작업을 위임할 것입니다.\n\nController는 전체 시스템, 특정 장치 또는 서브시스템을 나타내는 퍼사드 컨트롤러로 작용할 수 있습니다. 이 퍼사드 컨트롤러는 시스템 이벤트를 처리하기 위한 중앙 진입점 역할을 하며, 시스템 내에서 상호 작용을 조정하고 고수준 작업을 관리하는 단순화된 일관된 인터페이스를 제공합니다.\n\n```python\nclass User:\n    def __init__(self, username):\n        self.username = username\n        self.logged_in = False\n\n    def login(self):\n        self.logged_in = True\n        print(f\"{self.username} 님이 로그인했습니다.\")\n\n    def logout(self):\n        self.logged_in = False\n        print(f\"{self.username} 님이 로그아웃했습니다.\")\n\nclass SystemController:\n    def __init__(self):\n        self.users = {}\n\n    def handle_input(self, action, username):\n        if action == \"login\":\n            self.login_user(username)\n        elif action == \"logout\":\n            self.logout_user(username)\n        else:\n            print(\"알 수 없는 동작입니다.\")\n\n    def login_user(self, username):\n        if username not in self.users:\n            self.users[username] = User(username)\n        user = self.users[username]\n        user.login()\n\n    def logout_user(self, username):\n        user = self.users.get(username)\n        if user and user.logged_in:\n            user.logout()\n        else:\n            print(f\"{username} 님은 로그인되어 있지 않거나 존재하지 않습니다.\")\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nSystemController은 퍼사드 컨트롤러 역할을 하며 사용자 로그인 및 로그아웃 작업을 단일화하여 처리합니다. 사용자 사전을 유지하고 시스템 입력의 로그인 및 로그아웃 작업을 처리하는 메서드를 제공합니다.\n\n컨트롤러를 구현하는 다른 방법은 특정 사용 사례나 시나리오를 나타내는 곳에서 시스템 이벤트가 발생하는 것을 나타내는 것입니다. 이 유형의 컨트롤러는 종종 `UseCaseName`Handler, `UseCaseName`Coordinator 또는 `UseCaseName`Session으로 참조됩니다.\n\n이 사용 사례 또는 세션 컨트롤러는 특정 사용 사례와 관련된 작업과 상호 작용의 순서를 관리하여 모든 필요한 단계가 올바르게 실행되고 올바른 순서대로 실행되도록 보장합니다.\n\n```js\nclass User:\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n        self.logged_in = False\n\n    def check_password(self, password):\n        return self.password == password\n\n    def login(self):\n        self.logged_in = True\n        print(f\"{self.username}님이 로그인하였습니다.\")\n\n    def logout(self):\n        self.logged_in = False\n        print(f\"{self.username}님이 로그아웃하였습니다.\")\n\nclass LoginSession:\n    def __init__(self, users):\n        self.users = users\n\n    def handle_login(self, username, password):\n        user = self.users.get(username)\n        if user and user.check_password(password):\n            user.login()\n        else:\n            print(\"유효하지 않은 사용자 이름 또는 비밀번호.\")\n\n    def handle_logout(self, username):\n        user = self.users.get(username)\n        if user and user.logged_in:\n            user.logout()\n        else:\n            print(f\"{username}님은 로그인되어 있지 않거나 사용자가 존재하지 않습니다.\")\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n로그인 세션은 로그인 시나리오를 위한 유즈 케이스 컨트롤러 역할을 합니다. 로그인 및 로그아웃 프로세스를 처리하며 적절한 단계(예: 비밀번호 확인 및 로그인 상태 업데이트)가 따라지도록 합니다.\n\n일반적으로 컨트롤러는 수행해야 하는 작업을 다른 객체에게 위임해야 합니다. 주요 역할은 활동을 조정하거나 관리하는 것입니다. 컨트롤러 자체가 방대한 업무를 수행해서는 안 됩니다.\n\n```js\nclass Worker:\n    def perform_task(self, task_name):\n        print(f\"Worker is performing task: {task_name}\")\n\nclass TaskController:\n    def __init__(self):\n        self.worker = Worker()\n\n    def handle_task(self, task_name):\n        # 컨트롤러는 실제 작업을 Worker에 위임합니다\n        self.worker.perform_task(task_name)\n```\n\n컨트롤러 클래스가 담당해야 할 책임이 너무 많아지고 논리와 기능을 더 다루게 되면 컨트롤러가 부풀어 오르는 상황이 발생합니다. 보통 이런 상황은 컨트롤러가 다른 객체나 클래스에 효과적으로 작업을 위임하지 않아서 발생하며, 관심사의 명확한 분리가 이루어지지 않는 것이 일반적입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 과도한 책임\n- 부적절한 위임\n- 복잡성\n- 유지 관리 도전\n- 재사용성 감소\n\n```js\nclass TaskController:\n    def __init__(self):\n        self.tasks = []\n        self.users = {}\n        self.logged_in_user = None\n\n    # 사용자 관리 메서드\n    def register_user(self, username, password):\n        if username in self.users:\n            print(f\"'{username}' 사용자는 이미 존재합니다.\")\n        else:\n            self.users[username] = password\n            print(f\"'{username}' 사용자가 등록되었습니다.\")\n\n    def login_user(self, username, password):\n        if username in self.users and self.users[username] == password:\n            self.logged_in_user = username\n            print(f\"'{username}' 사용자가 로그인되었습니다.\")\n        else:\n            print(\"유효하지 않은 사용자 이름 또는 비밀번호입니다.\")\n\n    def logout_user(self):\n        if self.logged_in_user:\n            print(f\"'{self.logged_in_user}' 사용자가 로그아웃되었습니다.\")\n            self.logged_in_user = None\n        else:\n            print(\"로그인된 사용자가 없습니다.\")\n\n    # 업무 관리 메서드\n    def add_task(self, task_name):\n        if self.logged_in_user:\n            self.tasks.append((task_name, self.logged_in_user))\n            print(f\"'{task_name}' 작업이 {self.logged_in_user}에 의해 추가되었습니다.\")\n        else:\n            print(\"로그인된 사용자가 없습니다.\")\n\n    def remove_task(self, task_name):\n        if self.logged_in_user:\n            task = next((t for t in self.tasks if t[0] == task_name and t[1] == self.logged_in_user), None)\n            if task:\n                self.tasks.remove(task)\n                print(f\"'{task_name}' 작업이 {self.logged_in_user}에 의해 제거되었습니다.\")\n            else:\n                print(f\"'{task_name}' 작업을 {self.logged_in_user} 사용자가 찾을 수 없습니다.\")\n        else:\n            print(\"로그인된 사용자가 없습니다.\")\n\n    ...\n\n    # 작업 스케줄링 메서드\n    def schedule_task(self, task_name, time):\n        if self.logged_in_user:\n            print(f\"'{task_name}' 작업이 {self.logged_in_user}에 의해 {time}에 예약되었습니다.\")\n        else:\n            print(\"로그인된 사용자가 없습니다.\")\n```\n\nTaskController는 사용자 인증, 작업 관리 및 스케줄링을 처리하므로 지나치게 복잡합니다. (과도한 책임)\n\n모든 로직이 컨트롤러 내에서 처리되어 서로 강하게 결합되어 유지 관리하기 어려운 코드로 이어집니다. (부적절한 위임)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n컨트롤러의 메서드는 관련 없는 여러 작업을 처리하므로 오류 발생 및 코드 이해가 어려워질 수 있습니다. (높은 복잡성)\n\n사용자 관리, 작업 처리 또는 일정 로직에 대한 변경은 TaskController 수정을 필요로 하여 유지 관리를 복잡하게 하고 기능을 확장합니다. (유지보수 도전)\n\n리팩토링:\n\n```js\nclass User:\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n        self.logged_in = False\n\n    def check_password(self, password):\n        return self.password == password\n\n    def login(self):\n        self.logged_in = True\n        print(f\"{self.username} 로그인되었습니다.\")\n\n    def logout(self):\n        self.logged_in = False\n        print(f\"{self.username} 로그아웃되었습니다.\")\n\nclass Task:\n    def __init__(self, name):\n        self.name = name\n\n    def perform(self):\n        print(f\"작업 수행 중: {self.name}\")\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks = {}\n\n    def add_task(self, task, username):\n        self.tasks[(task.name, username)] = task\n        print(f\"작업 '{task.name}'가 {username}에 의해 추가되었습니다.\")\n\n    def remove_task(self, task_name, username):\n        if (task_name, username) in self.tasks:\n            del self.tasks[(task_name, username)]\n            print(f\"작업 '{task_name}'가 {username}에 의해 제거되었습니다.\")\n        else:\n            print(f\"사용자 {username}에 대한 작업 '{task_name}'을 찾을 수 없습니다.\")\n\n    def get_task(self, task_name, username):\n        return self.tasks.get((task_name, username), None)\n\nclass UserController:\n    def __init__(self):\n        self.users = {}\n        self.logged_in_user = None\n\n    def register_user(self, username, password):\n        if username in self.users:\n            print(f\"'{username}' 사용자가 이미 존재합니다.\")\n        else:\n            self.users[username] = User(username, password)\n            print(f\"'{username}' 사용자가 등록되었습니다.\")\n\n    def login_user(self, username, password):\n        user = self.users.get(username)\n        if user and user.check_password(password):\n            self.logged_in_user = user\n            user.login()\n        else:\n            print(\"유효하지 않은 사용자 이름 또는 비밀번호입니다.\")\n\n    def logout_user(self):\n        if self.logged_in_user:\n            self.logged_in_user.logout()\n            self.logged_in_user = None\n        else:\n            print(\"로그인된 사용자가 없습니다.\")\n\n    def get_logged_in_user(self):\n        return self.logged_in_user\n\nclass TaskScheduler:\n    def schedule_task(self, task_name, time, username):\n        print(f\"'{task_name}' 작업이 {username}에 의해 {time}에 예약되었습니다.\")\n\nclass TaskController:\n    def __init__(self, user_controller, task_manager, task_scheduler):\n        self.user_controller = user_controller\n        self.task_manager = task_manager\n        self.task_scheduler = task_scheduler\n\n    def handle_add_task(self, task_name):\n        user = self.user_controller.get_logged_in_user()\n        if user:\n            task = Task(task_name)\n            self.task_manager.add_task(task, user.username)\n        else:\n            print(\"로그인된 사용자가 없습니다.\")\n\n    def handle_remove_task(self, task_name):\n        user = self.user_controller.get_logged_in_user()\n        if user:\n            self.task_manager.remove_task(task_name, user.username)\n        else:\n            print(\"로그인된 사용자가 없습니다.\")\n\n    def handle_perform_task(self, task_name):\n        user = self.user_controller.get_logged_in_user()\n        if user:\n            task = self.task_manager.get_task(task_name, user.username)\n            if task:\n                task.perform()\n                self.task_manager.remove_task(task_name, user.username)\n            else:\n                print(f\"사용자 {user.username}에 대해 작업 '{task_name}'을 찾을 수 없습니다.\")\n        else:\n            print(\"로그인된 사용자가 없습니다.\")\n\n    def handle_schedule_task(self, task_name, time):\n        user = self.user_controller.get_logged_in_user()\n        if user:\n            self.task_scheduler.schedule_task(task_name, time, user.username)\n        else:\n            print(\"로그인된 사용자가 없습니다.\")\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n각 클래스는 하나의 명확한 책임을 갖습니다.\n\n## 다형성\n\n다형성은 OOP의 기본 개념으로, 다른 클래스의 객체를 공통 상위 클래스의 객체로 처리할 수 있게 해줍니다.\n\n## 순수 가공\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n가끔은 우리의 문제 도메인에 직접적으로 대응되지 않지만 코드를 더 잘 관리하기 위해 만든 클래스가 필요할 수 있습니다. 이러한 클래스들은 우리의 주요 클래스를 복잡하게 만들지 않고 원활하게 작동하도록 도와주는 편리한 도구들과 같습니다.\n\n```js\nclass Resource:\n    def __init__(self):\n        print(\"리소스를 로딩 중입니다...\")\n        # 리소스 집약 작업을 시뮬레이션합니다\n        import time\n        time.sleep(2)\n        print(\"리소스가 로딩되었습니다.\")\n\n    def use(self):\n        print(\"리소스를 사용 중입니다.\")\n```\n\n이 예시에서 Resource 클래스는 리소스를 로딩하기 위해 과도한 시간이 소요될 수 있습니다. Resource 객체를 생성할 때마다 리소스 집약적인 작업을 즉시 수행하며, 실제로 사용하지 않아도 됩니다.\n\n이제 Resource 객체가 필요한 경우에만 생성되도록 액세스를 제어하는 ResourceProxy 클래스를 소개해보겠습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nclass Resource:\n    def __init__(self):\n        print(\"리소스를 불러오는 중...\")\n        # 리소스 집약적인 작업을 시뮬레이션합니다\n        import time\n        time.sleep(2)\n        print(\"리소스가 불러졌습니다.\")\n\n    def use(self):\n        print(\"리소스를 사용 중입니다.\")\n\nclass ResourceProxy:\n    def __init__(self):\n        self._resource = None\n\n    def use(self):\n        if self._resource is None:\n            self._resource = Resource()  # 게으른 초기화\n        self._resource.use()\n```\n\n`ResourceProxy`는 `Resource` 객체에 대한 프록시 역할을 하며, 액세스를 제어하고 필요할 때만 생성되도록 보장합니다(게으른 초기화).\n\n원본 클래스를 복잡하게 만들지 않으면서도 가치를 더하는 도우미 클래스를 소개했습니다.\n\n`순수 가상화`는 문제 도메인 내에서 실제 세계 개념을 나타내지 않는 인공 클래스를 생성하는 디자인 원칙입니다. 이 클래스는 고유한 디자인 목표인 높은 응집력, 낮은 결합도, 재사용성을 달성하기 위해 도입됩니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n기본적으로 \"상상의 산물\"이며, 이는 깔끔하고 효율적인 설계를 유지하는 데 도움이 되는 발명된 구조라는 뜻입니다. 이 상상한 클래스에 할당된 책임은 다른 클래스와 높은 응집성을 유지하고 최소한으로 결합되도록 보장하여 모듈식이고 유지보수가 쉬운 코드베이스를 유지하는 데 도움이 되어야 합니다.\n\n목표는 각 클래스가 집중된 목적을 가지고 있으며 최소한의 의존성을 갖도록하여 전체적으로 깔끔한 아키텍처를 유발하는 시스템을 설계하는 것입니다. 순수한 가공은 때로 디자이너가 시스템의 복잡성을 효과적으로 관리해야 할 때 창의적인 솔루션으로 사용됩니다.\n\n```js\n# 나쁜 예\n\nclass Customer:\n    def __init__(self, name, email):\n        self.name = name\n        self.email = email\n\n    def save_to_database(self):\n        # 데이터베이스에 저장하는 것을 모의로 시뮬레이션\n        print(f\"{self.name} 고객을 데이터베이스에 저장합니다.\")\n\n# 좋은 예\nclass Customer:\n    def __init__(self, name, email):\n        self.name = name\n        self.email = email\n\nclass CustomerRepository:\n    def save(self, customer):\n        # 데이터베이스에 저장하는 것을 모의로 시뮬레이션\n        print(f\"{customer.name} 고객을 데이터베이스에 저장합니다.\")\n```\n\n## 간접성\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n간접 역참조의 원칙은 다른 구성 요소 사이에 중간 클래스를 생성하는 것을 포함합니다. 이 중간 클래스는 클래스들을 분리하여 시스템에서 유연성과 재사용성을 촉진하는 데 도움이 됩니다.\n\n```js\nclass Database:\n    def save_user(self, username):\n        print(f\"사용자 {username}을(를) 데이터베이스에 저장했습니다.\")\n\nclass UserRepository:\n    def __init__(self, database):\n        self.database = database\n\n    def save(self, username):\n        self.database.save_user(username)\n\nclass User:\n    def __init__(self, username, user_repository):\n        self.username = username\n        self.user_repository = user_repository\n\n    def save(self):\n        self.user_repository.save(self.username)\n```\n\nUserRepository는 User와 Database 클래스 간의 상호 작용을 추상화하는 중개자 역할을 합니다. 이 리포지토리는 통신을 중재하고 데이터 작업을 관리합니다.\n\nUser 클래스는 Database 클래스와 직접 상호 작용하지 않으므로 종속성이 줄어듭니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 보호된 변이\n\nProtected Variations은 시스템의 요소들을 안정적인 인터페이스 뒤에 변경 또는 다른 요소의 변화로부터 보호하는 것을 목표로 합니다.\n\n본질적으로, 이는 우리 시스템에서 변경될 가능성이 높거나 불안정할 수 있는 부분을 식별하고, 이러한 부분 주변에 안정적인 인터페이스를 생성하여 이러한 변경으로부터 시스템의 나머지 부분을 보호하는 것입니다.\n\n이 원칙을 구현하기 위해 우리는 먼저 시스템 내에서 변경이 가장 가능성이 높은 지점을 식별합니다. 이를 \"변이 지점\"이라고 합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그럼, 우리는 이러한 가변 부분과 상호 작용하는 안정적이고 일관된 방법을 제공하는 인터페이스나 추상 클래스를 생성합니다.\n\n이를 통해 시스템을 통해 전파되는 잠재적인 변경사항이나 불안정성을 방지하여 버그를 도입하는 위험을 최소화하고 광범위한 리팩터링이 필요한 필요성을 줄입니다.\n\n간단한 예제를 통해 **보호된 변형** 원칙을 보여줍시다. 여기서는 다양한 결제 방법을 지원해야 할 수 있는 결제 시스템을 가정합니다.\n\n```python\nclass CreditCardPayment:\n    def process_payment(self, amount):\n        print(f\"금액 ${amount}의 신용카드 결제 처리중\")\n\nclass PayPalPayment:\n    def process_payment(self, amount):\n        print(f\"금액 ${amount}의 PayPal 결제 처리중\")\n\nclass Order:\n    def __init__(self, amount):\n        self.amount = amount\n\n    def process_payment(self, payment_method):\n        if payment_method == \"credit_card\":\n            payment = CreditCardPayment()\n            payment.process_payment(self.amount)\n        elif payment_method == \"paypal\":\n            payment = PayPalPayment()\n            payment.process_payment(self.amount)\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nOrder 클래스는 특정 결제 방법 구현과 직접 상호 작용합니다.\n\n이제 결제 방법의 변화를 캡슐화하기 위한 안정적인 인터페이스를 소개합시다.\n\n```python\nfrom abc import ABC, abstractmethod\n\nclass PaymentMethod(ABC):\n    @abstractmethod\n    def process_payment(self, amount):\n        pass\n\nclass CreditCardPayment(PaymentMethod):\n    def process_payment(self, amount):\n        print(f\"카드로 ${amount} 결제 진행 중\")\n\nclass PayPalPayment(PaymentMethod):\n    def process_payment(self, amount):\n        print(f\"PayPal로 ${amount} 결제 진행 중\")\n\nclass Order:\n    def __init__(self, amount, payment_method):\n        self.amount = amount\n        self.payment_method = payment_method\n\n    def process_payment(self):\n        self.payment_method.process_payment(self.amount)\n```\n\n결제 처리 로직은 특정 결제 방법 클래스 내에 캡슐화되어 있습니다. 새로운 결제 방법이 도입되면 Order 클래스를 수정하지 않고 PaymentMethod 인터페이스를 구현하는 새 클래스를 생성하여 추가할 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 더 읽어보기\n\n## 출처\n\nApplying UML and Patterns, Craig Larman\n\nhttps://www.geeksforgeeks.org/grasp-design-principles-in-ooad/\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위키백과 링크의 표를 마크다운 형식으로 변경하세요.\n","ogImage":{"url":"/assets/img/2024-07-09-GRASPPrinciplesTheFoundationofRobustandMaintainableCode_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-GRASPPrinciplesTheFoundationofRobustandMaintainableCode_0.png","tag":["Tech"],"readingTime":28}],"page":"22","totalPageCount":35,"totalPageGroupCount":2,"lastPageGroup":15,"currentPageGroup":1},"__N_SSG":true}