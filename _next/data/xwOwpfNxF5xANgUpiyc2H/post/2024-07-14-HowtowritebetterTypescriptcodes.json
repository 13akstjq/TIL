{"pageProps":{"post":{"title":"TypeScript 코드를 더 잘 쓰는 방법","description":"","date":"2024-07-14 20:46","slug":"2024-07-14-HowtowritebetterTypescriptcodes","content":"\n\n## TYPESCRIPT\n\n<img src=\"/TIL/assets/img/2024-07-14-HowtowritebetterTypescriptcodes_0.png\" />\n\n## #1 Optional Chaining (?.):\n\nOptional chaining(?.)은 중첩된 프로퍼티 또는 메소드에 안전하게 접근할 수 있게 해줍니다. null 또는 undefined 값에 대해 걱정할 필요가 없습니다. 중간 프로퍼티 중 하나라도 null 또는 undefined이면 평가가 중단됩니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nconst user = {\n  name: 'Piotr',\n  address: {\n    city: 'Warsaw',\n    postalCode: '00-240'\n  }\n};\n\n\nconst postalCode = user.address?.postalCode;\nconsole.log(postalCode); // 00-240\n\nconst invalidCode = user.address?.postalCode?.toLowerCase();\nconsole.log(invalidCode); // Output: undefined\n```\n\n## #2 Use Mapped Types for Transformation\n\nMapped types allow you to create new types by transforming properties of existing types.\n\n```js\ntype Readonly<T> = {\n  readonly [P in keyof T]: T[P];\n};\ntype Partial<T> = {\n  [P in keyof T]?: T[P];\n};\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## #3 유틸리티 유형\n\nTypeScript는 일반적인 유형 변환을 돕기 위해 여러 유틸리티 유형을 제공합니다.\n\ni) Partial`T`: 모든 속성을 선택적으로 만듭니다.\nii) Required`T`: 모든 속성을 필수로 만듭니다.\niii) Readonly`T`: 모든 속성을 읽기 전용으로 만듭니다.\niv) Record`K, T`: 키가 K이고 유형이 T인 유형을 생성합니다.\n\n```js\ntype Person = {\n  name: string;\n  age: number;\n};\ntype PartialPerson = Partial<Person>;\ntype ReadonlyPerson = Readonly<Person>;\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## #4 타입 가드\n\n타입 가드를 사용하여 조건 블록 내에서 타입을 좁힐 수 있습니다.\n\n```js\nfunction isString(value: unknown): value is string {\n  return typeof value === 'string';\n}\n```\n\n## #5 템플릿 리터럴 타입\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n표 태그를 마크다운 형식으로 변경해주세요.\n\n\nTese allow you to create new string types by combining string literals.\n\n```js\ntype EventName = 'click' | 'hover';\ntype EventHandlerName = `${EventName}Handler`; // 'clickHandler' | 'hoverHandler'\n```\n\n## #6 Indexed Access Types\n\nUse indexed access types to extract the type of a property.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n유형 Person = { 이름: string; 나이: number };\n유형 NameType = Person['name']; // string\n```\n\n## #7 키 리매핑을 통한 Mapped Types\n\n새로운 유형을 생성하는 동안 키를 변환합니다.\n\n```js\n유형 PrefixKeys<T, P extends string> = {\n  [K in keyof T as `${P}${K & string}`]: T[K]\n};\n유형 PrefixedPerson = PrefixKeys<{ 이름: string; 나이: number }, 'prefix_'>;\n// { prefix_name: string; prefix_age: number }\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## #8 공용체\n\n이들은 서로 다른 유형의 조합을 만들고 유형 안전한(타입 세이프) 공용체를 만드는 데 도움을 줍니다.\n\n```js\ntype Shape =\n  | { kind: 'circle'; radius: number }\n  | { kind: 'square'; side: number };\n\nfunction getArea(shape: Shape) {\n  switch (shape.kind) {\n    case 'circle': return Math.PI * shape.radius ** 2;\n    case 'square': return shape.side ** 2;\n  }\n}\n```\n\n## #9 제네릭에서 추론된 유형\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n`infer`를 사용하여 조건형 내에서 타입을 추출하고 사용하세요.\n\n```js\ntype ReturnType<T> = T extends (...args: any[]) => infer R ? R : any;\ntype Fn = () => number;\ntype Result = ReturnType<Fn>; // number\n```\n\n## #10 모듈 확장\n\n기존 모듈에 새로운 기능을 추가하세요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```typescript\n// augmentations.ts\nimport 'express';\ndeclare module 'express' {\n  interface Request {\n    user?: { id: string; role: string };\n  }\n}\n```\n\n## #11 Declare Merged Interfaces\n\nMerge interfaces to extend types, especially useful with third-party libraries.\n\n```typescript\ninterface Window {\n  myCustomProperty: string;\n}\nwindow.myCustomProperty = 'Hello!';\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## #12 기능 오버로딩\n\n더 나은 유형 확인을 위해 여러 함수 시그니처를 제공합니다.\n\n```js\nfunction createDate(timestamp: number): Date;\nfunction createDate(year: number, month: number, day: number): Date;\nfunction createDate(x: number, y?: number, z?: number): Date {\n  return y !== undefined && z !== undefined ? new Date(x, y, z) : new Date(x);\n}\n```\n\n## #13 브랜드된 타입\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n브랜드화된 타입을 사용하여 명목적 타이핑을 만들어봐요.\n\n```js\ntype UserId = string & { _brand: 'UserId' };\nfunction createUserId(id: string): UserId {\n  return id as UserId;\n}\n```\n\n## #14 템플릿 리터럴 타입과 컨디셔널 타입\n\n템플릿 리터럴 타입과 컨디셔널 타입을 결합하여 고급 문자열 조작을 해보세요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ntype ExtractRouteParams<T extends string> = T extends `/${infer Param}/${infer Rest}`\n  ? { param: Param } & ExtractRouteParams<`/${Rest}`>\n  : {};\n\ntype Params = ExtractRouteParams<'/user/:id/posts/:postId'>;\n// { param: 'user' } & { param: 'posts' }\n```\n\n#15 Variadic Tuple Types\n\nTypescript 4+는 가변 튜플 타입을 지원하여 튜플이 배열의 나머지 부분을 캡처할 수 있도록 합니다.\n\n```js\ntype Push<T extends any[], V> = [...T, V];\ntype Result = Push<[1, 2, 3], 4]; // [1, 2, 3, 4]\n```","ogImage":{"url":"/TIL/assets/img/2024-07-14-HowtowritebetterTypescriptcodes_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-HowtowritebetterTypescriptcodes_0.png","tag":["Tech"],"readingTime":8},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<h2>TYPESCRIPT</h2>\n<img src=\"/TIL/assets/img/2024-07-14-HowtowritebetterTypescriptcodes_0.png\">\n<h2>#1 Optional Chaining (?.):</h2>\n<p>Optional chaining(?.)은 중첩된 프로퍼티 또는 메소드에 안전하게 접근할 수 있게 해줍니다. null 또는 undefined 값에 대해 걱정할 필요가 없습니다. 중간 프로퍼티 중 하나라도 null 또는 undefined이면 평가가 중단됩니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> user = {\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'Piotr'</span>,\n  <span class=\"hljs-attr\">address</span>: {\n    <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'Warsaw'</span>,\n    <span class=\"hljs-attr\">postalCode</span>: <span class=\"hljs-string\">'00-240'</span>\n  }\n};\n\n\n<span class=\"hljs-keyword\">const</span> postalCode = user.<span class=\"hljs-property\">address</span>?.<span class=\"hljs-property\">postalCode</span>;\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(postalCode); <span class=\"hljs-comment\">// 00-240</span>\n\n<span class=\"hljs-keyword\">const</span> invalidCode = user.<span class=\"hljs-property\">address</span>?.<span class=\"hljs-property\">postalCode</span>?.<span class=\"hljs-title function_\">toLowerCase</span>();\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(invalidCode); <span class=\"hljs-comment\">// Output: undefined</span>\n</code></pre>\n<h2>#2 Use Mapped Types for Transformation</h2>\n<p>Mapped types allow you to create new types by transforming properties of existing types.</p>\n<pre><code class=\"hljs language-js\">type <span class=\"hljs-title class_\">Readonly</span>&#x3C;T> = {\n  readonly [P <span class=\"hljs-keyword\">in</span> keyof T]: T[P];\n};\ntype <span class=\"hljs-title class_\">Partial</span>&#x3C;T> = {\n  [P <span class=\"hljs-keyword\">in</span> keyof T]?: T[P];\n};\n</code></pre>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h2>#3 유틸리티 유형</h2>\n<p>TypeScript는 일반적인 유형 변환을 돕기 위해 여러 유틸리티 유형을 제공합니다.</p>\n<p>i) Partial<code>T</code>: 모든 속성을 선택적으로 만듭니다.\nii) Required<code>T</code>: 모든 속성을 필수로 만듭니다.\niii) Readonly<code>T</code>: 모든 속성을 읽기 전용으로 만듭니다.\niv) Record<code>K, T</code>: 키가 K이고 유형이 T인 유형을 생성합니다.</p>\n<pre><code class=\"hljs language-js\">type <span class=\"hljs-title class_\">Person</span> = {\n  <span class=\"hljs-attr\">name</span>: string;\n  <span class=\"hljs-attr\">age</span>: number;\n};\ntype <span class=\"hljs-title class_\">PartialPerson</span> = <span class=\"hljs-title class_\">Partial</span>&#x3C;<span class=\"hljs-title class_\">Person</span>>;\ntype <span class=\"hljs-title class_\">ReadonlyPerson</span> = <span class=\"hljs-title class_\">Readonly</span>&#x3C;<span class=\"hljs-title class_\">Person</span>>;\n</code></pre>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h2>#4 타입 가드</h2>\n<p>타입 가드를 사용하여 조건 블록 내에서 타입을 좁힐 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">isString</span>(<span class=\"hljs-params\">value: unknown</span>): value is string {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">typeof</span> value === <span class=\"hljs-string\">'string'</span>;\n}\n</code></pre>\n<h2>#5 템플릿 리터럴 타입</h2>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>표 태그를 마크다운 형식으로 변경해주세요.</p>\n<p>Tese allow you to create new string types by combining string literals.</p>\n<pre><code class=\"hljs language-js\">type <span class=\"hljs-title class_\">EventName</span> = <span class=\"hljs-string\">'click'</span> | <span class=\"hljs-string\">'hover'</span>;\ntype <span class=\"hljs-title class_\">EventHandlerName</span> = <span class=\"hljs-string\">`<span class=\"hljs-subst\">${EventName}</span>Handler`</span>; <span class=\"hljs-comment\">// 'clickHandler' | 'hoverHandler'</span>\n</code></pre>\n<h2>#6 Indexed Access Types</h2>\n<p>Use indexed access types to extract the type of a property.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\">유형 <span class=\"hljs-title class_\">Person</span> = { 이름: string; 나이: number };\n유형 <span class=\"hljs-title class_\">NameType</span> = <span class=\"hljs-title class_\">Person</span>[<span class=\"hljs-string\">'name'</span>]; <span class=\"hljs-comment\">// string</span>\n</code></pre>\n<h2>#7 키 리매핑을 통한 Mapped Types</h2>\n<p>새로운 유형을 생성하는 동안 키를 변환합니다.</p>\n<pre><code class=\"hljs language-js\">유형 <span class=\"hljs-title class_\">PrefixKeys</span>&#x3C;T, P <span class=\"hljs-keyword\">extends</span> string> = {\n  [K <span class=\"hljs-keyword\">in</span> keyof T <span class=\"hljs-keyword\">as</span> <span class=\"hljs-string\">`<span class=\"hljs-subst\">${P}</span><span class=\"hljs-subst\">${K &#x26; string}</span>`</span>]: T[K]\n};\n유형 <span class=\"hljs-title class_\">PrefixedPerson</span> = <span class=\"hljs-title class_\">PrefixKeys</span>&#x3C;{ 이름: string; 나이: number }, <span class=\"hljs-string\">'prefix_'</span>>;\n<span class=\"hljs-comment\">// { prefix_name: string; prefix_age: number }</span>\n</code></pre>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h2>#8 공용체</h2>\n<p>이들은 서로 다른 유형의 조합을 만들고 유형 안전한(타입 세이프) 공용체를 만드는 데 도움을 줍니다.</p>\n<pre><code class=\"hljs language-js\">type <span class=\"hljs-title class_\">Shape</span> =\n  | { <span class=\"hljs-attr\">kind</span>: <span class=\"hljs-string\">'circle'</span>; <span class=\"hljs-attr\">radius</span>: number }\n  | { <span class=\"hljs-attr\">kind</span>: <span class=\"hljs-string\">'square'</span>; <span class=\"hljs-attr\">side</span>: number };\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getArea</span>(<span class=\"hljs-params\">shape: Shape</span>) {\n  <span class=\"hljs-keyword\">switch</span> (shape.<span class=\"hljs-property\">kind</span>) {\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'circle'</span>: <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-property\">PI</span> * shape.<span class=\"hljs-property\">radius</span> ** <span class=\"hljs-number\">2</span>;\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'square'</span>: <span class=\"hljs-keyword\">return</span> shape.<span class=\"hljs-property\">side</span> ** <span class=\"hljs-number\">2</span>;\n  }\n}\n</code></pre>\n<h2>#9 제네릭에서 추론된 유형</h2>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p><code>infer</code>를 사용하여 조건형 내에서 타입을 추출하고 사용하세요.</p>\n<pre><code class=\"hljs language-js\">type <span class=\"hljs-title class_\">ReturnType</span>&#x3C;T> = T <span class=\"hljs-keyword\">extends</span> (...<span class=\"hljs-attr\">args</span>: any[]) => infer R ? R : any;\ntype <span class=\"hljs-title class_\">Fn</span> = <span class=\"hljs-function\">() =></span> number;\ntype <span class=\"hljs-title class_\">Result</span> = <span class=\"hljs-title class_\">ReturnType</span>&#x3C;<span class=\"hljs-title class_\">Fn</span>>; <span class=\"hljs-comment\">// number</span>\n</code></pre>\n<h2>#10 모듈 확장</h2>\n<p>기존 모듈에 새로운 기능을 추가하세요.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-comment\">// augmentations.ts</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'express'</span>;\n<span class=\"hljs-keyword\">declare</span> <span class=\"hljs-variable language_\">module</span> <span class=\"hljs-string\">'express'</span> {\n  <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Request</span> {\n    user?: { <span class=\"hljs-attr\">id</span>: <span class=\"hljs-built_in\">string</span>; <span class=\"hljs-attr\">role</span>: <span class=\"hljs-built_in\">string</span> };\n  }\n}\n</code></pre>\n<h2>#11 Declare Merged Interfaces</h2>\n<p>Merge interfaces to extend types, especially useful with third-party libraries.</p>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Window</span> {\n  <span class=\"hljs-attr\">myCustomProperty</span>: <span class=\"hljs-built_in\">string</span>;\n}\n<span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">myCustomProperty</span> = <span class=\"hljs-string\">'Hello!'</span>;\n</code></pre>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h2>#12 기능 오버로딩</h2>\n<p>더 나은 유형 확인을 위해 여러 함수 시그니처를 제공합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createDate</span>(<span class=\"hljs-params\">timestamp: number</span>): <span class=\"hljs-title class_\">Date</span>;\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createDate</span>(<span class=\"hljs-params\">year: number, month: number, day: number</span>): <span class=\"hljs-title class_\">Date</span>;\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createDate</span>(<span class=\"hljs-params\">x: number, y?: number, z?: number</span>): <span class=\"hljs-title class_\">Date</span> {\n  <span class=\"hljs-keyword\">return</span> y !== <span class=\"hljs-literal\">undefined</span> &#x26;&#x26; z !== <span class=\"hljs-literal\">undefined</span> ? <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>(x, y, z) : <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>(x);\n}\n</code></pre>\n<h2>#13 브랜드된 타입</h2>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>브랜드화된 타입을 사용하여 명목적 타이핑을 만들어봐요.</p>\n<pre><code class=\"hljs language-js\">type <span class=\"hljs-title class_\">UserId</span> = string &#x26; { <span class=\"hljs-attr\">_brand</span>: <span class=\"hljs-string\">'UserId'</span> };\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createUserId</span>(<span class=\"hljs-params\">id: string</span>): <span class=\"hljs-title class_\">UserId</span> {\n  <span class=\"hljs-keyword\">return</span> id <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">UserId</span>;\n}\n</code></pre>\n<h2>#14 템플릿 리터럴 타입과 컨디셔널 타입</h2>\n<p>템플릿 리터럴 타입과 컨디셔널 타입을 결합하여 고급 문자열 조작을 해보세요.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\">type <span class=\"hljs-title class_\">ExtractRouteParams</span>&#x3C;T <span class=\"hljs-keyword\">extends</span> string> = T <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-string\">`/<span class=\"hljs-subst\">${infer Param}</span>/<span class=\"hljs-subst\">${infer Rest}</span>`</span>\n  ? { <span class=\"hljs-attr\">param</span>: <span class=\"hljs-title class_\">Param</span> } &#x26; <span class=\"hljs-title class_\">ExtractRouteParams</span>&#x3C;<span class=\"hljs-string\">`/<span class=\"hljs-subst\">${Rest}</span>`</span>>\n  : {};\n\ntype <span class=\"hljs-title class_\">Params</span> = <span class=\"hljs-title class_\">ExtractRouteParams</span>&#x3C;<span class=\"hljs-string\">'/user/:id/posts/:postId'</span>>;\n<span class=\"hljs-comment\">// { param: 'user' } &#x26; { param: 'posts' }</span>\n</code></pre>\n<p>#15 Variadic Tuple Types</p>\n<p>Typescript 4+는 가변 튜플 타입을 지원하여 튜플이 배열의 나머지 부분을 캡처할 수 있도록 합니다.</p>\n<pre><code class=\"hljs language-js\">type <span class=\"hljs-title class_\">Push</span>&#x3C;T <span class=\"hljs-keyword\">extends</span> any[], V> = [...T, V];\ntype <span class=\"hljs-title class_\">Result</span> = <span class=\"hljs-title class_\">Push</span>&#x3C;[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>], <span class=\"hljs-number\">4</span>]; <span class=\"hljs-comment\">// [1, 2, 3, 4]</span>\n</code></pre>\n</body>\n</html>\n"},"__N_SSG":true}