{"pageProps":{"posts":[{"title":"PyTorch 입문  커스텀 데이터 사용 방법","description":"","date":"2024-07-12 20:17","slug":"2024-07-12-PyTorchIntroductionUsingCustomData","content":"\n\n<img src=\"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_0.png\" />\n\n파이토치는 현재 딥 러닝 분야에서 가장 핫한 라이브러리 중 하나입니다. ChatGPT가 출시된 이후 데이터 과학가와 머신 러닝 엔지니어들 사이에서 딥 러닝 라이브러리가 아마도 가장 많은 관심을 받고 있다고 볼 수 있습니다. 특히 이러한 라이브러리는 매우 빠르게 복잡한 다차원 계산을 수행하는 능력이 뛰어나며, 이러한 라이브러리는 우리가 신경망 모델을 훈련하는 방식을 바꾸었습니다. 특히 이러한 모델이 저장하고 최적화하는 많은 수의 가중치를 관리하는 데 매우 도움이 됩니다. TensorFlow(구글의 프레임워크)와 경쟁하며, PyTorch는 Meta의 오픈 소스 프레임워크로, 아주 멋지고 실용적인 문법을 사용하여 딥 러닝 모델을 훈련할 수 있는 기회를 제공합니다.\n\n지금까지 이 PyTorch 시리즈에서 이 라이브러리를 사용하는 기본 개념을 배워왔습니다. 예를 들어:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 텐서에 대한 기본 사항을 배우기\n- PyTorch를 사용하여 처음 선형 모델(회귀)을 만드는 방법 이해하기\n- 비선형 활성화 함수 및 비선형 문제 해결하는 방법 배우기\n\n저희는 예제와 이전 블로그 게시물에서 몇 가지 사용자 정의 데이터셋을 사용했습니다. 이 시리즈에서 딥 러닝 모델을 교육하는 방향으로 진행하면서, PyTorch의 맥락에서 다양한 데이터셋을 통합하는 방법을 이해하는 데 매우 도움이 됩니다. 이 블로그 게시물에서는 라이브러리에서 사용자 정의 데이터셋을 다루는 방법을 배우고, 특히 세 가지 다른 유형의 데이터를 통합하는 방법을 다룰 것입니다:\n\n- CSV 파일\n- 이미지 데이터\n- 텍스트 데이터\n\n또한 데이터 배치의 개념에 대해 살펴보고, 이를 위해 PyTorch 사용자 정의 DataLoader를 사용하는 방법도 알아볼 것입니다. 이 블로그 게시물의 일부 영감은 Zero to Mastery Pytorch 무료 강좌에서 온 것입니다 — 많은 흥미로운 학습 예제가 있는 이 멋진 자료를 확인해보세요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n시작해 봅시다!\n\n# 랜덤 데이터셋 생성\n\n먼저, Pytorch에서 랜덤 데이터셋을 생성하여 DataLoader를 어떻게 사용할 수 있는지 이해해 봅시다:\n\n```python\nimport torch\nfrom torch.utils.data import Dataset, DataLoader\n\nclass RandomIntDataset(Dataset):\n    def __init__(self, start, stop, x, y):\n        self.data = torch.randint(start, stop, (x,y))\n        self.labels = torch.randint(0, 10, (x,))\n\n    def __len__(self):\n        return len(self.labels)\n\n    def __str__(self):\n        return str(torch.cat((self.data, self.labels.unsqueeze(1)), 1))\n\n    def __getitem__(self, i):\n        return self.data[i], self.labels[i]\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저희 RandomIntDataset은 랜덤한 torch 객체와 레이블을 생성합니다. 클래스에 던더 메서드를 도입하고 torch.utils.data.Dataset을 상속했음을 주목해주세요. (특히 데이터셋을 DataLoader와 결합할 때 유용하게 사용될 것입니다).\n\n이전 클래스를 기반으로 첫 번째 데이터셋 객체를 생성해봅시다!\n\n```js\ndataset = RandomIntDataset(100, 1000, 500, 10)\n```\n\n다시 말씀드리지만, Pytorch의 기본 클래스를 상속받았기 때문에 DataLoader를 사용하여 좋은 이터러블을 생성할 수 있습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\r\ndataset_loader = DataLoader(dataset, batch_size=10, shuffle=True)\r\n```\r\n\r\n신경망 내에서 데이터를 배치로 전달하는 것은 매우 흔한 일이며 DataLoader 생성자가 깔끔한 batch_size 인자를 통해 이를 처리합니다! dataset_loader는 반복 가능하므로 순차적인 데이터 배치를 얻기 위해 next 및 iter를 사용할 수 있습니다.\r\n\r\n```js\r\ndata, labels = next(iter(dataset_loader))\r\ndata\r\n```\r\n\r\n<img src=\"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_1.png\" />\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n새로운 iteration을 실행하고 data_loader의 다음 배치가 어떻게 이동하는지 확인해보세요! 이를 통해 데이터 및 레이블 객체 내부의 다른 데이터가 표시됩니다.\n\n물론, 이 무작위 데이터 세트는 실제로 \"사용자 지정 데이터 세트\"로 간주하기 어렵습니다. 무작위 생성된 데이터와 작업하려고 할 가능성은 매우 낮습니다. 그러나 배치 처리에 익숙해지는 데 도움이 되는 이 소개 후에 첫 번째 CSV 파일을 PyTorch 파이프라인에 포함하여 계속 진행할 준비가 되었습니다!\n\n# DataLoader와 사용자 지정 데이터 세트 결합\n\n우리가 보았듯이, 무작위 데이터 세트 사용은 단순한 연습일 뿐입니다. 그러나 이제 DataLoader와 데이터 배치가 어떻게 작동하는지 알기 때문에 이 지식을 사용하여 새로운 클래스를 만들어 PyTorch 데이터 세트를 사용할 수 있습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nimport pandas as pd\n\nclass TaxiSample(Dataset):\n    def __init__(self):\n        super().__init__()\n        df = pd.read_csv('data/taxi_data_sample.csv')\n        \n        features = ['passenger_count',\n                    'pickup_longitude',\n                    'pickup_latitude',\n                    'dropoff_longitude',\n                    'dropoff_latitude']\n        \n        target = 'trip_duration'\n        \n        self.features = torch.tensor(df[features].values, \n                                     dtype=torch.float32)\n\n        self.labels = torch.tensor(df[target].values, \n                                   dtype=torch.float32)\n\n    def __len__(self):\n        return len(self.labels)\n\n    def __getitem__(self, idx):\n        return self.features[idx], self.labels[idx]\n```\n\n참고: 라이브러리를 게시물에서 지날 때까지 가져오고 있지만 모든 라이브러리는 스크립트의 처음에 가져와야 합니다!\n\n우리가 사용하는 데이터셋은 Kaggle의 택시 여행 소요 시간 경쟁의 샘플 버전입니다. 여기서 csv를 init에 전달하고 있습니다 (이 기능을 더 다룰 수 있도록 인수로도 전달할 수 있습니다). DataLoader와 잘 어울리는지 확인해봅시다:\n\n```python\ndata_taxi = TaxiSample()\ndataset_loader = DataLoader(data_taxi, batch_size=20, shuffle=True)\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리의 배치 크기가 20인 경우, 이 데이터셋에서 이터레이터를 만들 수 있습니다:\n\n```js\ndata_iterator = iter(dataset_loader)\ndata, labels = next(data_iterator)\n```\n\n<img src=\"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_2.png\" />\n\n멋져요! 이것들은 데이터셋에서 무작위로 선택한 처음 20개의 예시입니다. 위 이미지에서는 피처와 해당 레이블을 확인할 수 있어요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n있는 이미지 데이터를 사용 해보세요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 블로그 게시물의 이 섹션에서는 이미지 데이터 처리 능력을 보여주기 위해 Microsoft Research Cats. vs Dogs. 데이터셋과 함께 Pytorch를 사용할 것입니다. 먼저 pathlib를 사용하여 경로를 정의해 보겠습니다:\n\n```python\nfrom pathlib import Path\ndata_path = Path(“data/dogs_cats”)\n```\n\n폴더 안에는 강아지 이미지와 고양이 이미지가 있는 두 개의 폴더가 있습니다. 각 폴더에서 이미지 경로를 추출해 봅시다:\n\n![이미지](/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_3.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 섹션에서는 일반적인 컴퓨터 비전 변환 및 아키텍처를 제공하는 pytorch의 멋진 확장인 torchvision이 필요합니다.\n\n```js\nfrom torchvision import datasets, transforms\n```\n\n다음으로 jpg 파일 이름을 읽어보겠습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimage_dogs_list = list((data_path/'dogs').glob(\"*.jpg\"))\nimage_cats_list = list((data_path/'cats').glob(\"*.jpg\"))\n```\n\n.. and combining our lists into a single object:\n\n```js\nimage_paths = image_cats_list + image_dogs_list\n```\n\nLet’s see if everything is working fine by extracting a random image from our list:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nimport random\nfrom PIL import Image\n\nrandom.seed(20)\n\nrandom_image_path = random.choice(image_paths)\nimage_class = random_image_path.parent.stem\n\nimg = Image.open(random_image_path)\n\nprint(f\"Random image path: {random_image_path}\")\nprint(f\"Image class: {image_class}\")\nprint(f\"Image height: {img.height}\") \nprint(f\"Image width: {img.width}\")\nimg\n```\n\n![Cute little doggo!](/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_5.png)\n\n귀여운 강아지!\n\n이미지를 텐서로 변환할 때 일반적인 단계 중 하나는 이미지를 일반적인 포맷으로 조정하는 것입니다. transforms 라이브러리를 사용하여 이미지 크기를 조정하고 첫 번째 비전 파이프라인을 설정할 수 있습니다!\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\ndata_transform = transforms.Compose([\n # 이미지 크기를 조정합니다\n transforms.Resize(size=(64, 64)),\n # 이미지를 수평으로 무작위로 뒤집습니다 — 이는 데이터 증가를 위한 단계입니다\n transforms.RandomHorizontalFlip(p=0.5),\n transforms.ToTensor()])\n```\n\n위 transforms 파이프라인에서 우리는 다음을 수행합니다:\n\n- 이미지를 64x64 픽셀 크기로 크기 조정합니다.\n- 무작위로 수평으로 이미지를 뒤집습니다 — 이는 데이터 증가를 위한 일반적인 단계입니다.\n- 이미지를 텐서로 변환합니다.\n\n한 이미지와 해당 변환된 버전을 나란히 그래플로 표시합니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport matplotlib.pyplot as plt\n\ndef plot_transformed_images(image_paths: list, \n                            transform: transforms.Compose, \n                            n=3, \n                            seed=100):\n    random.seed(seed)\n    random_image_paths = random.sample(image_paths, k=n)\n    for image_path in random_image_paths:\n        with Image.open(image_path) as f:\n            fig, ax = plt.subplots(1, 2)\n            ax[0].imshow(f) \n            ax[0].set_title(f\"Original Image \\nSize: {f.size}\")\n            ax[0].axis(\"off\") \n            transformed_image = transform(f).permute(1, 2, 0) \n            ax[1].imshow(transformed_image) \n            ax[1].set_title(f\"Transformed Image \\nSize: {transformed_image.shape}\")\n            ax[1].axis(\"off\")\n            fig.suptitle(f\"Class: {image_path.parent.stem}\", fontsize=16)\n```\n\n```js\nplot_transformed_images(image_paths, \n transform=data_transform, \n n=1)\n```\n\n<img src=\"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_6.png\" />\n\n저런! 변환을 통해 기본 텐서에 액세스하는 방법을 살펴보겠습니다. 예를 들어, 첫 번째 이미지의 경우:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimage_path = image_paths[0]\ndata_transform(Image.open(image_path))\n```\n\n![image](/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_7.png)\n\n데이터 변환은 RGB 채널이 3개이고 64x64 텐서를 생성했습니다!\n\n우리가 넘어가기 전에 더해야 할 마지막 단계 하나가 있습니다. 빠르게 텐서와 레이블을 생성하는 대안이 있습니다. 우리는 ImageFolder를 사용하여 편리하게 훈련 데이터를 생성할 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ntrain_data = datasets.ImageFolder(root=data_path, transform=data_transform, target_transform=None)\n```\n\n`datasets.ImageFolder`을 사용해요\n\n```js\nclass_names = train_data.classes\nclass_names\n```\n\n<img src=\"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_8.png\" />\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nclass_names에는 현재 태그(폴더 이름에서 읽음)가 컴퓨터 비전 모델에 포함되어 있습니다. train_data에는 컴퓨터 비전 프로세스에 대한 중요한 메타데이터가 포함되어 있습니다:\n\n![이미지](/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_9.png)\n\n그리고 이제 데이터 세트 ImageFolders를 DataLoaders로 변환하는 것은 매우 간단합니다:\n\n```js\ntrain_dataloader = DataLoader(dataset=train_data, \n batch_size=5,\n num_workers=1, \n shuffle=True)\n\ntrain_dataloader\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n보면 이터러블이 있네요:\n\n```python\nimg, label = next(iter(train_dataloader))\nprint(f\"이미지 형태: {img.shape} -> [배치 크기, 색상 채널, 높이, 너비]\")\nprint(f\"레이블 형태: {label.shape}\")\n```\n\n![image](/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_10.png)\n\n멋져요! 이 배치 크기가 5인 경우, 3채널(RGB)의 64x64 픽셀 이미지를 나타내는 3x64x64 텐서를 얻을 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 이 데이터 배치를 사용하여 강아지와 고양이 이미지를 인식하는 머신러닝 모델을 훈련할 수 있어요! (사실, 이 시리즈의 다음 블로그 게시물에서 이를 진행할 예정이에요!)\n\n# 텍스트 데이터 사용\n\n이 글의 마지막 부분에서는 sklearn.datasets의 fetch_20newsgroups를 사용하여 문자열과 정수 간 매핑을 생성할 거에요:\n\n```js\nfrom sklearn.datasets import fetch_20newsgroups\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음의 내용을 newsgroups에서 로드해 보겠습니다:\n\n```python\nfrom sklearn.datasets import fetch_20newsgroups\n\ncategories = [\n    'comp.os.ms-windows.misc',\n    'rec.sport.baseball',\n    'rec.sport.hockey',\n]\n\ndataset = fetch_20newsgroups(subset='train', categories=categories, shuffle=True, remove=('headers', 'footers', 'quotes'))\ncorpus = [item for item in dataset['data']]\n```\n\n다음 함수는 텍스트를 전처리할 것입니다:\n\n```python\nimport nltk\nimport re\n\ndef preprocess_text(text: str) -> str:\n    '''\n    입력 데이터에서 텍스트를 전처리하여 특수 문자와 숫자를 제거합니다.\n    \n    토큰 목록을 반환합니다.\n    '''\n    # 특수 문자 및 숫자 제거\n    text = re.sub(\"[^A-Za-z]+\", \" \", text)\n    tokens = nltk.word_tokenize(text.lower())\n    return tokens\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 우리 어휘를 생성하는 함수입니다:\n\n```js\ndef get_vocab(training_corpus):\n  # 특수 문자 추가\n  # 패딩, 라인 끝, 알 수 없는 용어\n  vocab = {'__PAD__': 0, '__</e>__': 1, '__UNK__': 2}\n  for item in training_corpus: \n    processed_text = preprocess_text(item)\n    processed_text.sort()\n    for word in processed_text:\n      if word not in vocab:\n        vocab[word] = len(vocab) \n  return vocab  \n```\n\n전체 어휘 사이즈는 얼마인가요?\n\n```js\nvocab = get_vocab(corpus)\nlen(vocab)\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이미지 파일:\n\n![이미지 파일](/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_11.png)\n\n단어장은 2만 6천 개가 조금 넘는 단어를 포함하고 있으며, 각 단어는 정수로 매핑되어 있습니다:\n\n이미지 파일:\n\n![이미지 파일](/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_12.png)\n\n이렇게 설정을 했으면, 문자를 정수로 변환하여 텐서로 변환하는 함수를 사용할 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\ndef text_to_tensor(text: str, vocab_dict: dict) -> torch.tensor:\n    '''\n    텍스트를 전처리하고 텐서 형식의 정수 매핑을 생성합니다.\n    '''   \n    word_l = preprocess_text(text)\n        \n    # 빈 텐서 초기화\n    tensor_l = [] \n    \n    # 단어 목록에서 __UNK__ 값을 가져옴\n    unk_ID = vocab_dict['__UNK__']\n            \n    # 각 단어에 대해:\n    for word in word_l:\n        # 인덱스 가져옴\n        # 단어가 vocab_dict에 없으면 UNK로 할당\n        word_ID = vocab_dict.get(word, unk_ID)\n        # 텐서 목록에 추가\n        tensor_l.append(word_ID)\n\n    return torch.tensor(tensor_l)\n```\n\n이 함수가 텍스트를 텐서로 어떻게 변환하는지에 대한 예시는 아래와 같습니다. 첫 번째 텍스트의 처음 200 단어를 사용하여 검사합니다:\n\n```python\nsnippet = corpus[0][0:200]\nprint('텍스트 \"{}\"는 다음과 같이 텐서로 표현됩니다: {}'.format(snippet, text_to_tensor(snippet, vocab)))\n```\n\n<img src=\"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_13.png\" />\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테이블 태그를 마크다운 형식으로 변경해주세요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 PyTorch 시리즈의 더 많은 포스트를 알아보려면 다음 링크를 확인해보세요:\n\n- Tensor 소개;\n- 선형 모델 만들기;\n- 활성화 함수 및 비선형 문제;\n\n이 게시물의 자료:\n\n- 택시 여행 기간 — https://www.nyc.gov/site/tlc/about/tlc-trip-record-data.page\n- 고양이와 개 이미지 인용: @Inproceedings (컨퍼런스)'asirra-a-captcha-that-exploits-interest-aligned-manual-image-categorization,\n저자 = 'Elson, Jeremy 및 Douceur, John (JD) 및 Howell, Jon 및 Saul, Jared',\n제목 = 'Asirra: A CAPTCHA that Exploits Interest-Aligned Manual Image Categorization',\n책 제목 = 'Proceedings of 14th ACM Conference on Computer and Communications Security (CCS)',\n연도 = '2007',\n월 = '10월',\n발행사 = 'Association for Computing Machinery, Inc.',\nurl = 'https://www.microsoft.com/en-us/research/publication/asirra-a-captcha-that-exploits-interest-aligned-manual-image-categorization/',\n판본 = 'Proceedings of 14th ACM Conference on Computer and Communications Security (CCS)',\n'","ogImage":{"url":"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_0.png","tag":["Tech"],"readingTime":19},{"title":"완전 무료 강좌 Python과 데이터 엔지니어링 완벽 가이드","description":"","date":"2024-07-12 20:16","slug":"2024-07-12-CompleteFreeCourseonPythonandDataEngineering","content":"\n\n파이썬에는 네 가지 복잡한 유형이 있습니다: 리스트, 튜플, 세트 및 사전이 있습니다. 각각에 대해 별도로 이야기하고 실제 예제를 제공하겠습니다.\n\n무료로 읽으려면 다음 링크를 확인하십시오:\n\n## 리스트:\n\n- 리스트는 변경 가능한 요소입니다.\n- 문자열, 문자, 정수 및 부동 소수점 숫자와 같은 서로 다른 유형의 항목을 포함 할 수 있습니다.\n- 인덱스는 0부터 시작합니다.\n- 순서가 있고 중복된 요소가 있습니다. append, remove 및 수정과 같은 연산이 가능합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래 코드는 실제 예시입니다:\n\n\n![image](/TIL/assets/img/2024-07-12-CompleteFreeCourseonPythonandDataEngineering_0.png)\n\n\n# 튜플:\n\n- 변경할 수 없는 데이터입니다.\n- 변경할 수 없는 리스트로 사용될 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\ntuple = (1, 2, 3, 4, 5, \"b\", \"c\", \"d\")\n```\n\n3. 필드의 컬렉션으로 사용될 수 있으며, 요소의 수가 고정되어 있고 순서가 중요합니다.\n\n```python\ncity, year, pop, chg, area = ('Tokyo', 2003, 32_450, 0.66, 8014)\n```\n\n아래 코드는 실제 예시입니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![Course Image](/TIL/assets/img/2024-07-12-CompleteFreeCourseonPythonandDataEngineering_1.png)\n\n# Sets:\n\n- Mutable data.\n- Elements are not ordered, nor duplicated.\n- Sets are hashable so it’s highly optimized.\n- Sets use a hashtable as its underlying data structure. This explains the O(1) membership checking, since looking up an item in a hashtable is an O(1) operation, on average.\n- Operations between sets can be union, intersection, difference, or symmetric difference.\n\nThe code below is a practical example:\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![이미지](/TIL/assets/img/2024-07-12-CompleteFreeCourseonPythonandDataEngineering_2.png)\n\n# 딕셔너리:\n\n- 키-값 쌍이다.\n- 키: 어떤 불변 유형이며 유일하다.\n- 값: 불변 또는 가변 유형이 될 수 있다.\n- 데이터를 효율적으로 조회한다.\n- 키로 접근한다.\n- 파이썬에서 딕셔너리는 해시 테이블로 구현된다.\n- 키는 해시 가능한 객체여야 한다. 적절한 __hash__ 및 __eq__ 메서드를 구현해야 한다.\n- 키에 의한 항목 접근은 매우 빠르다. 딕셔너리에 수백만 개의 키가 있을 수 있지만, 파이썬은 키의 해시 코드를 계산하고 해시 테이블에 대한 색인 오프셋을 파생하여 키를 직접 찾을 수 있으며 일치하는 항목을 찾기 위해 소수의 시도를 하게 된다.\n- Python 3.7부터 dict 내장의 새로운 개선 사항은 다음과 같다: 사전 객체의 삽입 순서 보존 속성은 파이썬 언어 사양의 공식 부분으로 선언되었다. 이는 더 이상 OrderedDict가 필요하지 않다는 것을 의미한다. 거의 똑같다.\n\n![이미지](/TIL/assets/img/2024-07-12-CompleteFreeCourseonPythonandDataEngineering_3.png)\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# NumPy Arrays:\n\n- 동일한 유형의 객체로 구성된 다차원 배열이다.\n- NumPy 배열은 List보다 우수하다:\n- List보다 효율적으로 저장된다.\n- 수학 연산을 벡터화할 수 있어, Python에서 List를 순회하는 것보다 성능이 높다.\n- 연산:\n- 숫자 연산: sin, cos, max, mean, variance, standard deviation, dot product.\n- 비숫자 연산: 색인, 슬라이싱, 쌓기, 분할, 논리 연산.\n\n# 참고 자료:\n\n세트는 어떻게 구현되었나요?\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nDict 대 OrderedDict\n\nDict은 파이썬의 해시 테이블입니다.\n\n파이썬 공부 교재\n\n# 감사 노트:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n각자의 시간을 내어 저의 글을 읽어 주셔서 감사의 말씀 전하고 싶습니다. 여러분의 지지와 참여는 저에게 너무나 소중하며, 이 멋진 청중과 제 생각과 통찰을 나눌 수 있는 기회에 진심으로 감사드립니다. 여러분의 팔로우는 저에게 가치 있는 내용을 만들기 위해 더 나은 자아를 추구하도록 영감을 줍니다. 오랜 구독자이든 새로 오신 독자이든, 여러분의 존재가 중요하며, 지지에 깊은 감사를 표합니다. 여러분과 공감되고 영감을 주는 고품질 글을 제공하기 위해 헌신할 것입니다. 여러분의 피드백과 댓글은 글쓰기에 대한 열정을 불어 넣어주고, 지속적인 성장을 동기부여합니다. 이 청중의 일원으로 함께해 주셔서 감사합니다. 여러분이 제 커뮤니티의 일원으로 있어 기쁘게 생각하며, 미래에도 여러분과 여러 새로운 아이디어를 공유하기를 기대합니다.\n\n코드가 필요하시다면 구독하고 메시지 보내주세요.\n\n감사합니다.","ogImage":{"url":"/TIL/assets/img/2024-07-12-CompleteFreeCourseonPythonandDataEngineering_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-CompleteFreeCourseonPythonandDataEngineering_0.png","tag":["Tech"],"readingTime":5},{"title":"Python으로 WhatsApp에서 AI를 사용하여 자신 복제하는 방법","description":"","date":"2024-07-12 20:13","slug":"2024-07-12-CloningYourselfonWhatsAppwithAIinPython","content":"\n\n\n![Cloning Yourself on WhatsApp with AI in Python](/TIL/assets/img/2024-07-12-CloningYourselfonWhatsAppwithAIinPython_0.png)\n\n친구들, 가족, 동료들로부터 온 WhatsApp 메시지를 계속해서 따라갈 수 있는 자신을 복제할 수 있다면 얼마나 좋을까요? 이 글에서는 정확히 그렇게 해볼 것입니다.\n\n우리는 여러분을 대신해 대화를 처리할 수 있는 챗봇을 만드는 방법을 보여드리겠습니다. OpenAI의 GPT 모델과 Twilio의 WhatsApp API를 사용하여 여러분의 채팅 스타일을 모방하고 이미지를 이해하여 여러분을 위해 대화할 수 있는 디지털 친구를 만들어볼 것입니다.\n\n이 글의 구성은 다음과 같습니다:\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 1. 환경 설정\n\n## 단계 1. Twilio에 가입하기\n\n- Twilio 웹 사이트로 이동합니다.\n- 무료 체험 계정을 등록합니다. $15의 무료 크레딧이 제공됩니다.\n- 가입 프로세스 중에 이메일과 전화번호를 인증합니다.\n\n## 단계 2. Twilio WhatsApp 샌드박스 설정\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Twilio 콘솔에 로그인합니다.\n- ‘All Products & Services’ -> ‘Programmable Messaging’ -> ‘Try it Out’ -> ‘Try WhatsApp’로 이동합니다.\n- WhatsApp 샌드박스를 설정하는 지침에 따릅니다. WhatsApp을 통해 Twilio 번호로 코드를 보내어 샌드박스에 참여합니다.\n- 가입하고 나면 샌드박스 번호를 메모해 둡니다.\n\n## 단계 3. Ngrok 설정\n\nNgrok은 로컬 개발 환경으로 안전한 터널을 생성하여 로컬 서버를 인터넷에 노출시킬 수 있는 도구입니다.\n\n이는 Twilio와 같은 서비스와의 웹훅 통합을 테스트하는 데 특히 유용합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n1. ngrok을 ngrok.com/download에서 다운로드하세요.\n\n2. 다운로드한 파일 압축 해제: 다운로드 후 ngrok 파일을 압축 해제하세요.\n\n3. Ngrok 인증: ngrok을 사용하기 전에 ngrok 인증 토큰을 사용하여 인증해야 합니다. ngrok 대시보드에서 인증 토큰을 찾을 수 있습니다. 터미널이나 명령 프롬프트를 열고 다음 명령을 실행하여 ngrok 인증 토큰을 실제 ngrok 인증 토큰으로 바꿔치기하세요: \n\n[2024-07-12-CloningYourselfonWhatsAppwithAIinPython_1.png](/TIL/assets/img/2024-07-12-CloningYourselfonWhatsAppwithAIinPython_1.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n4. 포트 5000을 터널링하기 위해 Ngrok 실행: Flask 애플리케이션은 일반적으로 기본적으로 포트 5000에서 실행됩니다. 따라서 이 포트를 터널링할 필요가 있습니다. 터미널이나 명령 프롬프트에서 ngrok이 위치한 디렉토리로 이동한 후 다음 명령을 실행하세요:\n\n```js\nngrok http 5000\n```\n\n만약 이 명령이 작동하지 않는다면, 대신 다음 명령을 시도해보세요:\n\n```js\n./ngrok http 5000\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![이미지](/TIL/assets/img/2024-07-12-CloningYourselfonWhatsAppwithAIinPython_2.png)\n\n5. 전달 URL 주의: ngrok가 실행되면 https://12345.ngrok.io와 같은 전달 URL을 제공합니다. 이 URL은 WhatsApp에서 수신된 메시지를 받기 위해 Twilio 구성에서 웹훅 URL로 사용됩니다.\n\n중요 사항:\n\n- 애플리케이션을 테스트하는 동안 ngrok를 계속 실행하십시오. ngrok를 중지하면 전달 URL이 작동하지 않게 되며 새로운 전달 URL로 Twilio의 웹훅 URL을 업데이트해야 합니다.\n- 무료 버전의 ngrok는 임시 URL을 제공하며, ngrok를 다시 시작할 때마다 변경됩니다. 장기간 테스트 또는 개발에 안정적인 URL이 필요한 경우 유료 ngrok 플랜으로 업그레이드를 고려해보세요.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 단계 4. Twilio 샌드박스 설정하기\n\n- Twilio 콘솔의 WhatsApp 샌드박스로 돌아갑니다.\n- ngrok URL 다음에 /whatsapp 엔드포인트가 이어지도록 '메시지 수신 시' 웹훅을 구성합니다. https://12345.ngrok.io/whatsapp와 같은 형식이어야 합니다. 아래 이미지를 참고하세요.\n- 변경 사항을 저장하세요.\n\n![이미지](/TIL/assets/img/2024-07-12-CloningYourselfonWhatsAppwithAIinPython_3.png)\n\n## 단계 5. Twilio 자격 증명 얻기\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nTwilio 대시보드에서 \"설정\"으로 이동하여 \"계정 SID\" 및 \"인증 토큰\"을 메모해주세요. 이 정보는 Python에서 API 요청을 인증하는 데 사용됩니다.\n\n![이미지](/TIL/assets/img/2024-07-12-CloningYourselfonWhatsAppwithAIinPython_4.png)\n\n## 단계 6. OpenAI API 자격 증명 획득\n\nOpenAI의 모델과 상호 작용하려면 API 자격 증명을 획득해야 합니다. 이를 통해 요청이 인증됩니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/TIL/assets/img/2024-07-12-CloningYourselfonWhatsAppwithAIinPython_5.png\" />\n\n# 2. Python Automation Script\n\n## 2.1. Install Python Libraries\n\n코딩을 시작하기 전에 몇 가지 라이브러리를 설치해야 합니다. 터미널이나 명령 프롬프트를 열고 다음 명령을 입력하세요:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n```js\npip install flask twilio openai\n```\n\n## 2.2. Python에서 자격 증명 설정\n\n이제 코드 편집기에서 자격 증명을 설정할 차례입니다. 단순함을 위해 VS Code 안의 Jupyter Notebook을 사용하고 있습니다.\n\n플레이스홀더를 실제 Twilio 및 OpenAI 자격 증명으로 교체해주세요.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nfrom flask import Flask, request\nfrom twilio.rest import Client\nimport openai\nimport requests\nfrom requests.auth import HTTPBasicAuth\nimport base64\nimport os\n\n# Twilio credentials\naccount_sid = ''\nauth_token = ''\ntwilio_number = 'whatsapp:+14155238886'\ntwilio_client = Client(account_sid, auth_token)\n# OpenAI API Key\nopenai_api_key = ''\n```\n\n## 2.3. 플라스크 어플리케이션 설정\n\n우리는 Flask를 사용하여 웹 서버를 생성하여 새로운 WhatsApp 메시지가 도착할 때 Twilio가 호출할 수 있는 URL 엔드포인트(라우트)를 정의하는데 사용합니다. \n\n파이썬 파일의 자격 증명들 아래에서 Flask 어플리케이션을 초기화하고 업로드를위한 디렉토리를 설정합니다.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\napp = Flask(__name__)\n\nuploads_dir = 'uploads'\nos.makedirs(uploads_dir, exist_ok=True)\n```\n\n이 코드 라인은 Flask 클래스의 인스턴스를 생성합니다. __name__은 Python의 특별한 변수로, 모듈로 import되었을 때는 모듈의 이름을 가리키지만, 스크립트가 직접 실행될 때는 `__main__`으로 설정됩니다.\n\nFlask 및 첫 Flask 애플리케이션을 설정하는 방법에 대해 더 많이 알아 보려면 공식 Flask 문서를 참조하십시오.\n\n## 2.4. 트위리오(Twilio)와 WhatsApp 통합하기\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nTwilio는 WhatsApp과 프로그래밍적으로 상호 작용하는 간편한 방법을 제공합니다. Twilio의 WhatsApp 샌드박스를 사용하면 WhatsApp 비즈니스 API를 직접 설정해야 하는 복잡성 없이 메시지를 보내고 받을 수 있습니다.\n\nWhatsApp 번호에서 메시지를 받을 때마다 Twilio는 Flask 앱에서 지정한 라우트로 HTTP POST 요청을 보냅니다. 그런 다음 Flask 앱은 이 메시지를 처리합니다.\n\nWhatsApp을 Twilio와 통합하려면 SMS, 음성, 비디오, 이메일 및 WhatsApp과 같은 메시징 앱을 통해 통신을 관리하는 일련의 도구를 제공하는 Twilio API를 사용합니다.\n\n여기 작동 방식의 간소화된 개요입니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 플라스크 애플리케이션은 서버에서 실행되며 특정 경로에서 수신되는 HTTP POST 요청을 수신합니다.\n- Twilio는 WhatsApp 번호가 메시지를 수신할 때마다 해당 경로로 HTTP POST 요청을 보냅니다.\n- 서버는 요청을 처리하고 (메시지에 회신하는 등) Twilio에 다시 응답합니다.\n\nTwilio와 WhatsApp을 통합하려면 WhatsApp용 Twilio API 문서를 참조하십시오.\n\n이미지와 같은 미디어 메시지를 처리하려면 Twilio가 요청할 때 보내는 MediaUrl 매개변수를 처리해야 합니다.\n\n이러한 URL은 서버에서 가져와 처리할 수 있는 미디어 콘텐츠를 가리킵니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nTwilio를 사용하여 미디어 메시지를 수신하는 방법에 대한 자세한 내용은 Twilio를 사용하여 미디어 메시지를받는 섹션을 참조하십시오.\n\n```js\n@app.route(\"/whatsapp\", methods=['POST'])\ndef reply_whatsapp():\n    # 여기서 수신된 메시지를 처리합니다\n    pass\n```\n\n## 2.5. 수신된 메시지 처리하기\n\nreply_whatsapp 함수 내에서 수신된 메시지를 처리하고 그것들을 저장할 위치를 설정하기 시작하세요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n플라스크에서 수신 메시지를 처리하려면 다음을 수행해야 합니다:\n\n- 새 메시지가 도착했을 때 Twilio가 호출할 수 있는 라우트를 정의합니다.\n- 요청에서 메시지 내용 및 발신자 정보를 추출합니다.\n- 메시지 내용에 따라 어떻게 응답하거나 작동할지 결정합니다.\n\n저희 경우, 자동 챗봇을 구축 중이므로 수신 메시지에서 텍스트나 미디어 URL을 가져와 응답을 생성할 예정입니다.\n\n이러한 수신 메시지를 처리하는 방법에 대한 자세한 내용은 Twilio의 메시지 수신 및 답장 가이드를 확인해주세요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nconversation_histories = {}\n\n@app.route(\"/whatsapp\", methods=['POST'])\ndef reply_whatsapp():\n    incoming_msg = request.values.get('Body', '').lower()\n    from_number = request.values.get('From')\n    user_history = conversation_histories.get(from_number, [])\n    # We will continue to build on this function\n    return 'OK', 200\n```\n\n## 2.6. OpenAI의 GPT 모델 통합\n\n다음과 같은 두 가지 목적으로 OpenAI의 두 모델을 사용할 것입니다:\n\n- 텍스트용 GPT-4: 이러한 모델은 입력에 기반하여 인간과 같은 텍스트를 이해하고 생성할 수 있습니다. WhatsApp 봇의 맥락에서는 텍스트 메시지에 대한 답변을 생성하는 데 사용할 수 있습니다.\n- 이미지용 GPT-4 비전: 이미지와 같은 미디어를 처리할 때 모델의 비전 기능을 사용하여 이미지의 내용을 이해하고 설명을 제공할 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n대화를 관리하기 위해 각 채팅의 컨텍스트를 저장하기 위해 conversation_histories 사전을 사용합니다.\n\n이렇게 하면 사용자로부터 메시지를 받을 때 사용자의 대화 기록을 새 메시지와 함께 OpenAI에 전송하여 모델이 일관된 응답을 생성할 수 있게 됩니다.\n\n## 2.7. 대화 기록 구축하기\n\n대화 기록을 유지하는 것은 우리의 AI가 상호 작용 과정에서 더 일관되고 관련성 있는 응답을 생성할 수 있도록 컨텍스트를 유지하는 데 도움이 됩니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n어떻게 만들까요:\n\n- 각 대화를 송신자의 번호를 키로 사용하여 사전(dictionary)에 저장합니다.\n- 새로운 메시지를 대화 기록에 추가한 후 OpenAI의 API로 전송합니다.\n- API 요청마다 대화 기록이 함께 전달되도록 합니다.\n\n## 2.8. 완성된 코드\n\n이제 모든 것을 완성된 코드로 조합해 봅시다. 다음은 전체 스크립트가 어떻게 보일지에 대한 자세한 설명이 포함된 것입니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nfrom flask import Flask, request\nfrom twilio.rest import Client\nimport openai\nimport requests\nfrom requests.auth import HTTPBasicAuth\nimport base64\nimport os\n\napp = Flask(__name__)\n\n# Twilio credentials\naccount_sid = ''\nauth_token = ''\ntwilio_number = ''\ntwilio_client = Client(account_sid, auth_token)\n\n# OpenAI API Key\nopenai_api_key = ''\n\n# Ensure the 'uploads' directory exists\nuploads_dir = 'uploads'\nos.makedirs(uploads_dir, exist_ok=True)\n\nconversation_histories = {}\n\n@app.route(\"/whatsapp\", methods=['POST'])\ndef reply_whatsapp():\n    incoming_msg = request.form.get('Body', '').lower()\n    media_url = request.form.get('MediaUrl0')\n    from_number = request.form.get('From')\n    message_sid = request.form.get('MessageSid')\n\n    # Prepare the headers for OpenAI API\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"Authorization\": f\"Bearer {openai_api_key}\"\n    }\n\n    # Get the user's conversation history, if it exists\n    user_history = conversation_histories.get(from_number, [])\n\n    if media_url:\n        # Process as an image\n        print('Image URL detected, attempting to retrieve the image...')\n        response = requests.get(media_url, auth=HTTPBasicAuth(account_sid, auth_token))\n        if response.status_code == 200:\n            # Save the image to a file in the 'uploads' directory\n            image_path = os.path.join(uploads_dir, f'{message_sid}.png')\n            with open(image_path, \"wb\") as image_file:\n                image_file.write(response.content)\n\n            # Encode the image in base64\n            base64_image = encode_image(image_path)\n\n            # Prepare the payload for the OpenAI API\n            payload = {\n                \"model\": \"gpt-4-vision-preview\",  # Use the correct model name for images\n                \"messages\": user_history + [\n                    {\n                        \"role\": \"user\",\n                        \"content\": [\n                            {\n                                \"type\": \"image_url\",\n                                \"image_url\": {\n                                    \"url\": f\"data:image/png;base64,{base64_image}\"\n                                }\n                            }\n                        ]\n                    }\n                ],\n                \"max_tokens\": 300\n            }\n\n            # Send the request to the OpenAI API\n            openai_response = requests.post(\"https://api.openai.com/v1/chat/completions\", headers=headers, json=payload)\n            description = openai_response.json().get('choices')[0].get('message').get('content') if openai_response.ok else \"Failed to get a description from OpenAI.\"\n            \n            # Update the user's conversation history with the image description\n            user_history.append({\"role\": \"assistant\", \"content\": description})\n            conversation_histories[from_number] = user_history\n\n            # Respond back on WhatsApp with the description\n            twilio_client.messages.create(\n                body=description,\n                from_=twilio_number,\n                to=from_number\n            )\n        else:\n            print('Failed to retrieve the image.')\n    else:\n        # Process as text\n        print('No image URL found, processing text...')\n        payload = {\n            \"model\": \"gpt-4\",  # Use the appropriate model for text\n            \"messages\": user_history + [\n                {\n                    \"role\": \"user\",\n                    \"content\": incoming_msg\n                }\n            ],\n            \"max_tokens\": 300\n        }\n        # Send the request to OpenAI API for text messages\n        openai_response = requests.post(\"https://api.openai.com/v1/chat/completions\", headers=headers, json=payload)\n        response_text = openai_response.json().get('choices')[0].get('message').get('content') if openai_response.ok else \"Failed to get a response.\"\n\n        # Update the user's conversation history\n        user_history.append({\"role\": \"assistant\", \"content\": response_text})\n        conversation_histories[from_number] = user_history\n\n        # Respond back on WhatsApp with the text response\n        twilio_client.messages.create(\n            body=response_text,\n            from_=twilio_number,\n            to=from_number\n        )\n\n    return 'OK', 200\n\ndef encode_image(image_path):\n    with open(image_path, \"rb\") as image_file:\n        return base64.b64encode(image_file.read()).decode('utf-8')\n\nif __name__ == '__main__':\n    app.run(debug=True, use_reloader=False)\n``` \n\n# 3. OpenAI 어시스턴트로 자동화하기\n\n이 섹션에서는 개인 대화 스타일을 모방하고 Twilio와 통합하며 텍스트 및 이미지 메시지를 처리하는 OpenAI 어시스턴트를 생성하는 방법에 대해 알아보겠습니다.\n\nOpenAI 어시스턴트 사용의 장점은 더 정확하게 파일을 첨부하고 동작을 수정하여 개인 커뮤니케이션 스타일을 가장 유사하게 모방할 수 있다는 데 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 3.1 대화 기록 정리하기\n\n대화 스타일을 모방할 수 있는 OpenAI 어시스턴트를 만들기 위해 WhatsApp 대화 기록을 정리해야 합니다.\n\n이것이 중요한 이유는 어시스턴트가 개인의 의사 소통 스타일과 일관된 방식으로 응답하는 방법을 배우기 위해 이 기록을 사용하기 때문입니다.\n\n고려해야 할 주요 사항:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 3.2 특정 사람의 대화 스타일을 복제할 수 있는 Open AI 어시스턴트 생성\n\n특정 사람의 대화 스타일을 과거 채팅 데이터를 기반으로 재현할 수 있는 AI 어시스턴트를 만드는 방법:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- WhatsApp 대화 기록을 구문 분석하고 OpenAI가 훈련에 사용할 수 있는 형식으로 변환합니다.\n- openai.File.create() 메서드를 사용하여 이 대화 기록을 OpenAI에 업로드하고 이를 사용하여 사용자 정의 어시스턴트를 훈련시킵니다.\n- openai.Assistant.create()를 사용하여 업로드한 파일을 어시스턴트의 훈련 참조로 제공하여 어시스턴트를 생성합니다.\n\n고려 사항:\n\n- 어시스턴트는 AI 성격을 드러내지 않아야 하며, 인간과 유사한 상호 작용의 환영을 유지해야 합니다.\n- 이미지 설명을 포함한 다양한 입력을 처리하여 대화를 원활하게 이어가야 합니다.\n\n```js\nimport openai\nfrom openai import OpenAI\n\ndef parse_whatsapp_history(file_path):\n    # WhatsApp 채팅 기록을 구문 분석하는 함수\n\n# OpenAI API 키 설정\nopenai.api_key = ''\n\n# OpenAI 클라이언트 초기화\nclient = OpenAI(api_key=openai.api_key)\n\n# WhatsApp 대화 기록 구문 분석\nwhatsapp_messages = parse_whatsapp_history(r\"WhatsApp Conversation between Alex.txt\")\n\n# WhatsApp 메시지를 파일로 업로드\nfile = client.files.create(\n    file=open(r\"WhatsApp Conversation between Alex.txt\", 'rb'),\n    purpose='assistants'\n)\n\ninstructions = (\n    \"당신은 Alex입니다. WhatsApp 기록을 기반으로 Alex의 대화 스타일을 모방합니다.\"\n    \"반드시 AI임을 밝히지 마십시오.\"\n    \"가끔 이미지 설명을 받을 수 있습니다.\"\n    \"대화에 자연스럽게 이 설명을 통합하고 어떠한 파일의 존재에 대해 언급하지 않습니다.\"\n    \"이미지를 직접 본 것처럼 행동합니다.\"\n    \"대화의 흐름을 유지합니다.\"\n)\n\n# 검색 도구가 활성화된 사용자 정의 어시스턴트 생성\nassistant = client.beta.assistants.create(\n    name=\"나의 WhatsApp 클론\",\n    instructions=instructions,\n    # 모델\n    # 파일\n    # 도구\n)\r\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nOpenAI 어시스턴트를 사용하여 WhatsApp 대화를 자동화하는 방법을 자세히 살펴보고 싶은 분들을 위해 www.entreprenerdly.com에서 상세한 안내가 제공되고 있어요:\n\n![이미지](/TIL/assets/img/2024-07-12-CloningYourselfonWhatsAppwithAIinPython_6.png)\n\n## 3.3 Twilio와 어시스턴트 통합\n\n훈련된 OpenAI 어시스턴트를 Twilio API와 통합하여 WhatsApp 메시지에 응답하도록 설정하는 것에 대해 알아봐요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n통합하는 방법:\n\n- Flask를 사용하여 Twilio가 새 메시지를 수신할 때 HTTP POST 요청을 보낼 수 있는 웹 서버를 생성합니다.\n- Flask 라우트 핸들러를 사용하여 수신된 메시지 및 미디어를 처리합니다.\n- openai.Completion.create()를 사용하여 텍스트 응답 또는 openai.Image.create()를 사용하여 이미지 처리를 위해 OpenAI 어시스턴트와 상호 작용합니다.\n- Twilio의 메시징 API를 통해 어시스턴트의 응답을 사용자에게 보냅니다.\n\n주요 통합 단계:\n\n- Flask 앱에 Twilio에서의 POST 요청을 처리할 수 있는 라우트를 설정합니다 (/whatsapp으로 코드에서).\n- requests 라이브러리를 사용하여 Twilio 번호로 보낸 이미지를 검색하고 OpenAI API와 상호 작용합니다.\n- 어시스턴트로부터 응답을 사용자에게 보내기 위해 대화 기록을 유지합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nfrom flask import Flask, request\nfrom twilio.rest import Client\nimport openai\nimport requests\nfrom requests.auth import HTTPBasicAuth\nimport base64\nimport os\nimport time\n\napp = Flask(__name__)\n\n# Twilio credentials\naccount_sid = ''\nauth_token = ''\ntwilio_number = 'whatsapp:+14155238886'\ntwilio_client = Client(account_sid, auth_token)\n\n# OpenAI API Key\nopenai_api_key = ''\n\n# Ensure the 'uploads' directory exists\nuploads_dir = 'uploads'\nos.makedirs(uploads_dir, exist_ok=True)\n\nconversation_histories = {}\n\n# Initialize the OpenAI client\nclient = openai.OpenAI(api_key=openai_api_key)\n\n# Create the custom assistant (replace 'assistant_id' with your actual assistant ID)\nassistant_id = assistant.id #'asst_g5yiS6TewzdO75JSrBuNBwEV'\n\n@app.route(\"/whatsapp\", methods=['POST'])\ndef reply_whatsapp():\n    # Function to handle incoming WhatsApp messages\n\ndef interact_with_assistant(assistant_id, message_content, image_path=None):\n    # Function to interact with assistant using text and images\n\ndef encode_image(image_path):\n    with open(image_path, \"rb\") as image_file:\n        return base64.b64encode(image_file.read()).decode('utf-8')\n\nif __name__ == '__main__':\n    app.run(debug=True, use_reloader=False)\n```\n\n## 4. Further Practical Applications\n\n알아봤던 OpenAI와 Twilio를 사용하여 WhatsApp 대화를 자동화하는 기술은 개인 메시지 이상의 폭넓은 실용적인 응용 프로그램을 갖고 있습니다. 이 기술이 어떻게 적응되고 다른 시나리오에서 적용될 수 있는지 살펴보겠습니다:\n\n### 4.1 고객 지원 자동화\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n자주 묻는 질문과 흔한 문제에 대한 대답을 자동화하여 고객 지원의 응답 시간과 효율성을 높일 수 있습니다.\n\n구현 방안:\n\n- 지난 고객 서비스 상호작용에 대한 AI 모델을 세밀하게 조정하여 일반적인 쿼리를 처리합니다.\n- CRM 시스템과 통합하여 고객 이력을 기반으로 개인화된 응답을 제공합니다.\n- 복잡한 문제가 발생할 때에는 인적 에이전트들에게 일을 넘깁니다.\n\n자원:\n이미 개발된 솔루션을 사용하려면 Salesforce의 AI 기반 고객 관계 관리 솔루션인 Einstein AI를 확인해보세요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 4.2 전자 상거래 챗봇\n\n제품 추천, 재고 업데이트 및 주문 추적을 제공할 수 있는 인공 지능 챗봇을 활용하여 온라인 쇼핑 경험을 향상시킵니다.\n\n구현:\n\n- 실시간 정보를 제공하기 위해 전자 상거래 플랫폼의 데이터베이스와 상호 작용하는 챗봇을 개발합니다.\n- 대화형 인공 지능을 사용하여 고객이 구매 프로세스를 안내하거나 상품을 업셀링/크로스셀링 할 수 있습니다.\n- 채팅 인터페이스를 통해 사용자가 주문을 직접 할 수 있도록 거래 기능을 구현합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n리소스:\n이미 개발된 솔루션을 위해 Magento와 Shopify은 AI를 전자 상거래 플랫폼에 통합하기 위한 API 및 개발자 리소스를 제공합니다.\n\n## 4.3 정신 건강 지원\n\n자동화된 공감 표현 응답을 통해 예비 정신 건강 지원 및 위기 대응을 제공합니다.\n\n구현:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- AI를 프로그램하여 정신 건강에 대한 언어를 인식하고 지원 자원을 제공하도록 합니다.\n- 기밀을 보장하고 전문적인 도움 링크를 제공합니다.\n- 상황의 긴급성을 판단하기 위해 감정 분석을 사용하고 필요시 인간 상담자에게 경고할 수 있습니다.\n\n자원:\n이미 개발된 솔루션에 대해 Woebot 등의 AI 기반 정신 건강 플랫폼을 참고하여 학습하십시오.\n\n## 4.4 교육 튜터 및 언어 학습\n\n컨셉을 설명하고 질문에 답변하며 언어 학습을 돕는 대화형 AI로 교육 자료를 보강하세요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n구현:\n\n- 교육 콘텐츠에 특화된 도우미를 만들어 숙제와 시험 준비를 돕습니다.\n- 사용자와 대화하여 실수를 바로 잡고 개선점을 제안하는 언어 학습 봇을 구축합니다.\n\n자원:\n이미 개발된 솔루션을 찾으려면 Duolingo의 언어 연습용 챗봇을 살펴보세요.\n\n## 4.5 이벤트 계획과 알림\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n친절한 톤으로 번역해보겠습니다.\n\n캘린더를 관리하는 데 도움을 주어 이벤트 계획을 자동화하고 리마인더를 보내며 약속을 재스케줄링할 수 있습니다.\n\n구현:\n\n- 캘린더 API와 동기화하여 사용자가 WhatsApp을 통해 이벤트를 추가하고 쿼리할 수 있도록 합니다.\n- 대화에서 날짜와 시간 참조를 이해하기 위해 자연어 처리를 사용합니다.\n\n자원:\n이미 개발된 솔루션의 경우 Google Calendar API는 이벤트를 프로그래밍 방식으로 관리하는 기능을 제공합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 5. 도전과 한계\n\n오픈 에이 아이(OpenAI)와 트윌리오(Twilio)를 사용하여 WhatsApp 대화를 자동화하는 것은 여러 이점을 제공하지만, 발생할 수 있는 도전과 한계를 인식하는 것이 중요합니다.\n\n## 5.1 프라이버시와 보안에 대한 고려 사항\n\n도전: 민감한 개인 데이터를 처리하는 것은 개인정보 보호 법 및 보안 조치를 엄격히 준수하여 데이터 침해를 방지해야 합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n고려 사항:\n\n- GDPR 및 HIPAA와 같은 규정 준수 보장\n- 데이터 전송 및 저장을 위해 end-to-end 암호화 구현\n- 새로운 위협에 대비하기 위해 보안 프로토콜을 정기적으로 감사 및 업데이트\n\n## 5.2 대화 맥락과 일관성\n\n도전 과제: AI 모델이 긴 또는 복잡한 대화에서 맥락과 일관성을 유지하는 것은 도전적일 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n고려 사항:\n\n- 고급 자연 언어 처리 기술을 활용하여 맥락을 이해합니다.\n- 계속해서 새로운 데이터로 모델을 훈련하여 일관성을 유지하는 능력을 향상시킵니다.\n- AI가 일관된 응답을 제공할 수 없는 상황을 우아하게 처리하기 위한 후행 메커니즘을 구현합니다.\n\n## 5.3 모호함과 오해 다루기\n\n도전: 자연어는 종종 모호하며, AI 모델은 사용자 의도나 감정을 오해할 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n고려해야 할 사항:\n\n- 메시지의 감정적 톤을 더 잘 이해하기 위해 감성 분석을 사용하세요.\n- 모호성을 해소하고 정확한 응답을 보장하기 위해 명확한 질문을 사용하세요.\n- 반복되는 문제를 식별하고 수정하기 위해 AI 응답을 정기적으로 모니터링하고 검토하세요.\n\n## 5.4 확장성 및 성능\n\n도전 과제: 사용자 수가 증가함에 따라 성능과 확장성을 유지하는 것이 어려워질 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n고려해야 할 사항:\n\n- 고효율로 대량의 요청을 처리하기 위해 백엔드 인프라를 최적화합니다.\n- 수요 변동을 관리하기 위해 로드 밸런싱과 자동 확장을 구현합니다.\n- 시스템 성능을 정기적으로 모니터링하고 필요에 따라 조정합니다.\n\n## 5.5 윤리적 및 사회적 영향\n\n과제: AI의 개인 커뮤니케이션에서 윤리적 문제가 발생할 수 있습니다. 예를 들어 사람을 흉내내거나 인간 상호작용의 침해가 될 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n고려사항:\n\n- 사용자에게 AI 사용 사실을 명확히 알리고 동의를 받습니다.\n- 사용자의 복지와 개인정보 보호를 우선시하는 책임 있는 AI 사용을 위한 지침을 개발합니다.\n- 윤리적 우려를 다루고 사회 기대에 적응하기 위해 이해 관계자와 지속적인 대화에 참여합니다.\n\n## 5.6 기술적 제약사항\n\n과제: 현재 AI 모델은 복잡한 언어 뉘앙스, 관용구 및 문화적 언급을 이해하는 데 제약이 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n고려 사항:\n\n- 언어 능력을 향상시키기 위해 AI 모델을 지속적으로 업데이트하고 개선합니다.\n- 다양한 교육 데이터를 통합하여 모델이 다양한 언어와 문화를 이해하도록 합니다.\n- AI의 능력과 한계에 대해 사용자들에게 현실적인 기대를 설정합니다.\n\n# 마무리\n\n자신을 복제하는 개념은 의사 소통을 관리하는 것을 넘어, 자동으로 작동할 수 있는 대체 디지털 존재를 만드는 것입니다. 언젠가 그 대체 존재가 우리 대신에 일과 개인 생활의 측면을 처리할 수도 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n기술, 철학적 및 규제적 도전 과제로 가득한 여정은 신중하게 탐색되어야 합니다. 인상적인 기술이기는 하지만 결함이 없는 것은 아니며, 배치되는 과정은 주의 깊게 그리고 전망을 내다보는 마음가짐으로 다뤄져야 합니다.\n\n읽어 주셔서 감사합니다. 만약 이 기사가 유익하다고 생각되시면 👏를 눌러서 향후 콘텐츠를 지원해 주시기 바랍니다.\n\nEntrepren erdly.com에서는 행동 가능한 지식으로 권한을 부여하는 튜토리얼, 코드 및 전략 전체 스위트를 제공합니다.\n\n<img src=\"/TIL/assets/img/2024-07-12-CloningYourselfonWhatsAppwithAIinPython_7.png\" />\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 관련 기사:","ogImage":{"url":"/TIL/assets/img/2024-07-12-CloningYourselfonWhatsAppwithAIinPython_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-CloningYourselfonWhatsAppwithAIinPython_0.png","tag":["Tech"],"readingTime":30},{"title":"로컬에서 Florence 2 시작하는 방법","description":"","date":"2024-07-12 20:11","slug":"2024-07-12-StartingwithFlorence2locally","content":"\n\n플로렌스-2는 Microsoft의 고급 비전 기반 모델로, 프롬프트 기반 방식을 사용하여 다양한 비전 및 비전-언어 작업을 처리하기 위해 설계되었습니다. 로컬에서 플로렌스-2를 설정하고 실행하는 데 도움이 되는 시작 스크립트가 여기 있어요.\n\n![이미지](/TIL/assets/img/2024-07-12-StartingwithFlorence2locally_0.png)\n\n# 시작 스크립트\n\n플로렌스-2를 실행하는 데 사용할 수 있는 시작 스크립트입니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nimport os\nfrom transformers import AutoProcessor, AutoModelForCausalLM  \nfrom PIL import Image\nimport requests\nfrom unittest.mock import patch\nfrom transformers.dynamic_module_utils import get_imports\n\ndef run_example(task_prompt, text_input=None):\n    if text_input is None:\n        prompt = task_prompt\n    else:\n        prompt = task_prompt + text_input\n    inputs = processor(text=prompt, images=image, return_tensors=\"pt\")\n    generated_ids = model.generate(\n        input_ids=inputs[\"input_ids\"].cuda(),\n        pixel_values=inputs[\"pixel_values\"].cuda(),\n        max_new_tokens=1024,\n        early_stopping=False,\n        do_sample=False,\n        num_beams=3,\n    )\n    generated_text = processor.batch_decode(generated_ids, skip_special_tokens=False)[0]\n    parsed_answer = processor.post_process_generation(\n        generated_text, \n        task=task_prompt, \n        image_size=(image.width, image.height),\n    )\n    return parsed_answer\n\n# Example usage\nfn = 'ray_ban_meta.jpeg'\nimage = Image.open(fn)\ntask_prompt = '<MORE_DETAILED_CAPTION>'\nret = run_example(task_prompt)\nprint(ret)\n```\n\n## 너무 괴롭히지 마세요\n\n만약 지역에서 실행하는 모든 시도 끝에도 이 예외를 받게 된다면: `pip install flash_attn`를 실행해 보세요.\n\n```python\nFile \"C:\\Users\\alex_\\aichat\\florence2_vision\\myenv\\lib\\site-packages\\transformers\\dynamic_module_utils.py\", line 182, in check_imports\n    raise ImportError(\nImportError: 이 모델링 파일은 환경에 없는 다음 패키지가 필요합니다: flash_attn. `pip install flash_attn`을 실행해 보세요.\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n상태 코드를 Markdown 형식으로 변경하십시오.\n\n```js\nFile \"C:\\Users\\alex_\\aichat\\florence2_vision\\myenv\\lib\\site-packages\\flash_attn\\flash_attn_interface.py\", line 10, in <module>\n    import flash_attn_2_cuda as flash_attn_cuda\nImportError: DLL load failed while importing flash_attn_2_cuda: The specified procedure could not be found.\n```\n\n청소한 상태에서 Miniconda를 사용하여 시작해 보세요.\n\n# 깔끔한 환경 설정\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음과 같이 새로운 conda 환경을 만들어 보세요:\n\n```js\nconda create -n florence2 python=3.11 -y\nconda activate florence2\n```\n\nCUDA 설치 여부 확인:\n\nCUDA가 설치되어 있는지 확인해주세요:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\r\nnvcc --version\n\nnvcc: NVIDIA (R) Cuda 컴파일러 드라이버\nCopyright (c) 2005-2024 NVIDIA Corporation\n2024년 4월 17일 수요일에 빌드됨\nCuda 컴파일 도구, 릴리즈 12.5, V12.5.40\n빌드 cuda_12.5.r12.5/compiler.34177558_0\r\n```\n\nCUDA 경로 설정:\n\n```js\r\nset \"CUDA_PATH=C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.5\"\nset \"CUDA_HOME=C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.5\"\r\n```\n\nPyTorch 및 종속성 설치하기:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\npip install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu121\npip install transformers einops timm\n```\n\n# Flash 어텐션 불필요\n\ntransformers 의존성에서 요구되지도 않고 알려진 문제입니다.\n\n이것이 해결책이에요:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# With Python 3.11.7, transformers==4.36.2\nimport os\nfrom unittest.mock import patch\n\nfrom transformers import AutoModelForCausalLM\nfrom transformers.dynamic_module_utils import get_imports\n\n\ndef fixed_get_imports(filename: str | os.PathLike) -> list[str]:\n    \"\"\"https://huggingface.co/microsoft/phi-1_5/discussions/72을 위한 해결책.\"\"\"\n    if not str(filename).endswith(\"/modeling_phi.py\"):\n        return get_imports(filename)\n    imports = get_imports(filename)\n    imports.remove(\"flash_attn\")\n    return imports\n\n\nwith patch(\"transformers.dynamic_module_utils.get_imports\", fixed_get_imports):\n    model = AutoModelForCausalLM.from_pretrained(\"microsoft/phi-1_5\", trust_remote_code=True)\r\n```\n\n# OCR 테스트\n\n## 입력 이미지\n\n<img src=\"/TIL/assets/img/2024-07-12-StartingwithFlorence2locally_1.png\" />\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음은 스크립트를 실행한 후의 업데이트 내용입니다:\n\n```js\nD:\\DEV\\MODELS\\modules\\transformers_modules\\microsoft\\Florence-2-large-ft\\3112cd2e25c969cfdcb600a01489c56737d943d3\\modeling_florence2.py:1209: UserWarning: 1Torch was not compiled with flash attention. (Triggered internally at ..\\aten\\src\\ATen\\native\\transformers\\cuda\\sdp_utils.cpp:455.)\n  attn_output = torch.nn.functional.scaled_dot_product_attention(\n{'<OCR>': '2310Z8MOOWN - RW4008 6015IC 26243-4003RCID 2AYOA-403'}\n```\n\n잘 작동합니다! 좀 그렇지만요. 일부 숫자가 누락되었지만, 그건 다음에 다시 이야기할 주제입니다.\n\n# 마지막으로\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 단계를 따르면 어려움 없이 Florence-2를 로컬에서 실행할 수 있을 것입니다. 다른 문제가 발생하면 모든 의존성이 올바르게 설치되어 있는지, 환경이 올바르게 구성되어 있는지 확인해주세요.\n\n# Hugging Face Spaces\n\n환경을 로컬로 설정하기를 원치 않는다면 Hugging Face Spaces를 사용하여 Florence-2를 실행할 수도 있습니다. 이는 로컬 구성이 필요 없이 모델에 액세스할 수 있는 클라우드 기반 솔루션을 제공합니다. Hugging Face의 Florence-2 스페이스를 확인해보세요: Hugging Face Spaces\n\n# 출처","ogImage":{"url":"/TIL/assets/img/2024-07-12-StartingwithFlorence2locally_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-StartingwithFlorence2locally_0.png","tag":["Tech"],"readingTime":7},{"title":"추론을 추상화하는 방법 이해를 돕는 구체적 사례 포함","description":"","date":"2024-07-12 20:10","slug":"2024-07-12-HowtoAbstractYourReasoning","content":"\n\n\n![Screenshot](/TIL/assets/img/2024-07-12-HowtoAbstractYourReasoning_0.png)\n\n고등학교 수학 학생에서 박사 후 수준의 최첨단 순수 수학 연구에 이르기까지 여정을 거친 개발자로서, 이러한 다른 교육 수준에서 뇌가 어떻게 작동하는지에 대한 한 가지 중요한 차이점을 강조하고 싶습니다.\n\n고등학교 학생들은 수학을 연습할 때 일반적으로 특정 문제에 자신들의 교과지식을 적용하여 학습합니다. 이 문제들은 일반적으로 특정 값, 객체 또는 함수와 관련이 있습니다. 예를 들어, 고등학교 학생들은 보통 정수, 실수 또는 복소수, 또는 정수 다항식과 작업할 것입니다. 이로써 그들은 전문 수학자가 되기 위해 필요한 지식과 패턴인식을 향상시킵니다.\n\n그러나 완전히 발전된 전문 수학자들은 최대한 일반화하고 추상화하여 생각하는 데 훈련 받습니다. 정수나 확립된 일상적인 숫자 구조와 작업하는 대신, 그들은 그룹, 환, 모듈 또는 체와 같은 추상 대수 구조와 작업합니다. 이는 많은 알려진 보다 구체적인 구조를 포괄하는데, 그 결과로 그들의 결과물은 더 강력해지며 보다 일반적인 구조와 문제에 적용할 수 있게 됩니다.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 문장은 조금 추상적이에요. 웃음을 포함하기 위해 말장난을 쓰는 걸 용서해주세요. 수학적 통찰을 일반화하는 기회를 잡는다면 더 강력해질 수 있다는 간단한 예시를 보여드리겠어요. 이 옥스퍼드 수학 입학 시험 문제에서 고등학생은 특정 상황에 대해 결론을 내야 하죠. 그러나 접근법의 일반화를 발견하려는 순간에 훨씬 더 일반적인 결론을 내릴 수 있다는 것이 밝혀졌어요. 시험지에서의 문제로 시작해볼게요.\n\n## 원본 MAT 문제 및 해답\n\n![image](/TIL/assets/img/2024-07-12-HowtoAbstractYourReasoning_1.png)\n\n미국 독자분들을 위해, '사탕'에 대한 미국식 단어는 '과자'입니다 😊\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n문제를 적혀 있는 그대로 해결해 보겠습니다. 그리고 우리의 해결책에 대해 일반화할 수 있는 부분이 있는지 살펴보겠습니다.\n\n(i)부분에서 우리는 어떤 날이든 미리암이 이득을 얻는 것을 알 수 있습니다. 따라서 미리암은 여행 중 첫 15일이 맑은 날이 되도록 하여 이득을 극대화할 것입니다. 따라서 첫 15일 동안 이득을 한개씩 더 해가며, 총 15일 후에는 15개의 숫자의 합, 즉 ½ × 15 × 16 = 120개의 사탕을 얻을 것입니다. 그리고 나머지 15일 동안은 하루에 15개의 사탕을 받을 것이며, 이로써 추가로 15²= 225개의 사탕을 얻게 됩니다. 따라서 미리암의 가장 많은 사탕의 개수는 120 + 225 = 345개가 됩니다. (부모님은 이곳에서 수학을 한 결과에 확실히 경악할 것입니다)! 반대 경우는 미리암이 가장 적은 사탕의 수를 받는 경우입니다. 즉, 처음 15일이 비 오는 날이고 사탕을 전혀 받지 않으며, 마지막 15일이 맑은 날이고 각각 하나의 사탕을 받는 경우로, 이 경우 총 120개의 사탕을 받게 됩니다.\n\n(ii)부분에서, 처음 15일이 맑은 날인 경우 아담은 이 날들에 사탕을 전혀 받지 않습니다. 그런 다음 16일차에 16개의 사탕을 받고, 17일차에 17개의 사탕을 받는 식으로 30번째 날에 30개의 사탕을 받게 됩니다. 따라서 아담이 받는 총 사탕의 수는 16부터 30까지의 모든 정수를 더한 것으로, 이는 미리암과 마찬가지로 345개가 됩니다. 처음 15일이 비 오는 날인 경우, 아담은 1일차에 1개의 사탕을 받고, 2일차에 2개의 사탕을 받는 식으로 15일차에는 15개의 사탕을 받습니다. 그 후에는 사탕을 받지 않습니다. 따라서 이 경우 아담이 받는 사탕 역시 처음 15개의 정수를 더한 값인 120개입니다.\n\n(iii)부분에서, 우선 하루가 비 오는 날이고 다음 날이 맑은 날인 미리암의 경우를 살펴보겠습니다. 그리고 k를 이 비 오는 날을 포함하여 지난 휴가 중에 발생한 맑은 날의 수라고 가정합니다. 그러면 오늘이 미리암이 총 사탕을 받는 데에 k개에 기여할 것이고, 내일은 k+1개를 기여할 것입니다. 따라서 오늘과 내일 모두 미리암의 총 사탕에 2k+1개를 기여합니다. 이제 이 두 날을 바꿔 봅시다. 그러면 오늘이 미리암에게 k+1개의 사탕을 기여할 것이고, 내일 또한 k+1개를 기여하므로, 따라서 이 두 날은 미리암의 총 사탕에 2k+2개를 기여합니다. 이 교환이 다른 날들이 미리암의 총 사탕에 기여하는 데에 영향을 주지 않는다는 것에 유의하면, 이 교환은 미리암의 총 사탕을 한 개 더 늘어나게 합니다. 아담의 경우에도 동일한 방법을 사용하면, k일이 비 오는 날이라고 가정하고 그 다음 k+1일이 맑은 날인 경우를 생각해봅시다. 그러면 k일이 아담의 총 사탕에 k개를 기여하고 k+1일이 0을 기여하는데, 따라서 총 k개를 기여할 것입니다. 이들을 교환하면, k일이 0을 기여하고 k+1일이 k+1을 기여하므로, 총 기여하는 양은 k+1개가 됩니다. 따라서 아담의 경우에도 이 교환으로 인해 한 개의 사탕을 더 받습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n(iv) 부분에서는 실제로 지금까지 한 작업을 약간의 일반적화하도록 유도받았습니다. 처음 두 부분에서 알 수 있듯이 첫 15일이 비 오는 휴일과 다음 15일이 맑음인 경우, 아담과 미리암이 같은 양의 사탕을 먹는다는 것을 알았습니다. 그러나 여기서 중요한 깨달음은 — 이 시나리오로 시작한다면 — 우리는 점진적으로 인접한 비와 맑은 날을 교환하여 15일 간의 비와 맑은 날의 어떤 구성도 얻을 수 있다는 것입니다. 예를 들어, 주어진 구성에서 첫 맑은 날이 ` 16일인 경우, 우리는 초기 시나리오로 돌아가서 15일과 16일을 교환합니다. k가 15이면, 14일과 15일을 교환하고, 이렇게 반복하여 k에 첫 맑은 날을 배치합니다. 그런 다음 j ` k 위치에 다음 맑은 날을 배치하고, 이를 반복합니다. 이제 (iii)부분에서 어떤 교환 시리즈도 미리암과 아담의 합계에 동일한 영향을 준다는 것에 주목합니다. 따라서 그들은 같은 총 사탕 양으로 시작하며, 우리가 만드는 모든 인접한 교환은 그들의 총 사탕에 동일한 영향을 미치므로, 미리암과 아담이 같은 총 사탕 양을 가질 것이라고 결론지을 수 있습니다. 15일 동안 비와 맑은 날이 있는 휴일에 대해서도 마찬가지입니다. 그럼 이 내용으로 마칩니다.\n\n## 여기서 멈추는 이유가 있을까요?\n\n우리가 위에서 한 내용을 일반화하여, 휴일이 얼마나 길든 날씨가 어떻든 상관없이 미리암과 아담이 가질 사탕 양의 차이를 계산하는 데 기회를 발견했나요? 다시 한번 살펴보고, 이번에는 계산을 추상화해 봅시다!\n\n휴일이 30일이고 15일 동안 비가 오고 15일 동안 맑은 날이라는 것 대신에, 휴일이 q일이라고 가정하고 k ≤ q인 비 오는 날이 k개이고 맑은 날이 q-k개인 경우를 생각해 봅시다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 방법에서 알 수 있듯이, 우리는 k일 동안의 비가 내린 날이 모두 달의 시작부터인 것으로 가정할 수 있습니다. 인접한 비 오는 날과 맑은 날을 교환하는 일련의 작업으로 이를 통해 어떤 구성도 유도할 수 있고, 이것이 어린이들이 받는 사탕의 총 수를 변경하지 않음을 알 수 있습니다. 따라서 k일 동안 비가 내린 다음 q-k일 동안 맑은 날이 있는 이 초기 구성에서 사탕의 차이를 계산하는 것으로 충분합니다.\n\n아담의 경우, 이 구성에서 그는 0개의 사탕에서 시작하여 처음 k일 동안 매일 추가로 한 개의 사탕을 받은 후 더 이상 사탕을 받지 않게 됩니다. 따라서 아담은 다음과 같은 수의 사탕을 받게 됩니다:\n\n![image](/TIL/assets/img/2024-07-12-HowtoAbstractYourReasoning_2.png)\n\n미리암의 경우, 처음 k일 동안은 사탕을 받지 않다가 k+1일에 한 개의 사탕을 받은 후 마지막 날(q일)까지 각각의 추가적인 날마다 한 개의 사탕을 받습니다. 따라서 미리암은 다음과 같은 수의 사탕을 받게 됩니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![Miriam and Adam sweets difference equation](/TIL/assets/img/2024-07-12-HowtoAbstractYourReasoning_3.png)\n\nWhen we subtract these two and perform some algebraic simplification, we obtain a general expression for the difference in the number of sweets received by Miriam and Adam for any holiday lasting q days with k ≤ q rainy days:\n\n![General expression for sweets difference](/TIL/assets/img/2024-07-12-HowtoAbstractYourReasoning_4.png)\n\nIt's clear from this equation that for holidays with an equal number of rainy and sunny days (i.e., q = 2k), the difference in sweets is zero, and both children will receive the same number of sweets. Furthermore, the number is positive when there are more sunny days than rainy days (favoring Miriam), and negative when there are more rainy days than sunny days (favoring Adam).\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n시험 문제의 이 추상화에 대해 어떻게 생각하셨나요? 자유롭게 의겢하여 주세요.","ogImage":{"url":"/TIL/assets/img/2024-07-12-HowtoAbstractYourReasoning_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-HowtoAbstractYourReasoning_0.png","tag":["Tech"],"readingTime":7},{"title":"아직 잘 알려지지 않은 5가지 파이썬 데이터 시각화 기법","description":"","date":"2024-07-12 20:09","slug":"2024-07-12-Top5PythonDataVisualizationTechniquesYouProbablyArentUsing","content":"\n\n\n![이미지](/TIL/assets/img/2024-07-12-Top5PythonDataVisualizationTechniquesYouProbablyArentUsing_0.png)\n\n## 이 5가지 고급 시각화 차트를 마스터하세요\n\n이 다섯 가지 고급 시각화 차트를 마스터하면 데이터 시각화가 쉬워집니다. 이 라이브러리들은 서로 보완하여 데이터 표현을 극대화합니다.\n\n# 1. 화음도표\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nChord Diagram(코드 다이어그램)은 데이터 포인트 간의 복잡한 관계를 창조적으로 보여줍니다. 노드들이 원 주위에 배열되어 아크로 연결됩니다. 아크의 길이는 연결 값을 반영하며 두께는 관계의 중요도를 나타냅니다. 색상은 데이터를 분류하여 비교를 쉽게 만듭니다. 유전자 데이터 시각화를 위해 특히 다양한 분야에서 널리 사용됩니다.\n\n![Chord Diagram example](/TIL/assets/img/2024-07-12-Top5PythonDataVisualizationTechniquesYouProbablyArentUsing_1.png)\n\n![Chord Diagram example 2](/TIL/assets/img/2024-07-12-Top5PythonDataVisualizationTechniquesYouProbablyArentUsing_2.png)\n\n다음은 Holoviews 및 Bokeh를 사용하여 다섯 개국 간의 무역 관계를 보여주는 코드 다이어그램 예시입니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nimport holoviews as hv\nfrom holoviews import opts\nimport pandas as pd\nimport numpy as np\nhv.extension('bokeh')\n\n# 5개 국가 간의 수출량을 나타내는 표본 행렬\nexport_data = np.array([[0, 50, 30, 20, 10],   \n                        [10, 0, 40, 30, 20],   \n                        [20, 10, 0, 35, 25],   \n                        [30, 20, 10, 0, 40],   \n                        [25, 15, 30, 20, 0]]) \n\nlabels = ['USA', 'China', 'Germany', 'Japan', 'India']\n\n# 판다스 데이터프레임 생성\ndf = pd.DataFrame(export_data, index=labels, columns=labels)\ndf = df.stack().reset_index()\n\ndf.columns = ['source', 'target', 'value']\n\n# Chord 객체 생성\nchord = hv.Chord(df)\n\n# Chord 다이어그램 스타일링\nchord.opts(\n    opts.Chord(\n        cmap='Category20', edge_cmap='Category20', \n        labels='source', label_text_font_size='10pt',  \n        edge_color='source', node_color='index', \n        width=700, height=700 \n    )\n).select(value=(5, None)) \n\n# 플롯 출력\nchord\n```\n\n![Chord Diagram](/TIL/assets/img/2024-07-12-Top5PythonDataVisualizationTechniquesYouProbablyArentUsing_3.png)\n\n- [Chord 호환성](https://holoviews.org/reference/elements/matplotlib/Chord.html)\n- [pyCirclize GitHub](https://github.com/moshi4/pyCirclize)\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 2. 썬버스트 차트\n\n썬버스트 차트는 계층적 데이터를 명확하게 표시하여 전통적인 원형 및 링 차트를 능가합니다. 각각 계층을 나타내는 동심원을 사용합니다. 중심은 루트이며 세그먼트는 노드를 나타냅니다. 각 세그먼트의 크기는 해당 값을 반영하여 데이터의 중요성을 직관적으로 이해하게 합니다. 파일 시스템 계층 구조, 사용자 탐색 경로, 시장 세분화 및 유전 데이터의 시각화에 유용합니다.\n\n다음은 Plotly 라이브러리를 사용하여 썬버스트 차트를 만드는 예시입니다.\n\n```js\nimport plotly.express as px\nimport numpy as np\n\ndf = px.data.gapminder().query(\"year == 2007\")\n\nfig = px.sunburst(df, path=['continent', 'country'], \n                  values='pop',\n                  color='lifeExp', \n                  hover_data=['iso_alpha'],\n                  color_continuous_scale='RdBu',\n                  color_continuous_midpoint=np.average(df['lifeExp'], weights=df['pop']))\nfig.show()\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n[그림](https://plotly.com/python/sunburst-charts/)\n\n# 3. Hexbin Plot\n\n[그림](/TIL/assets/img/2024-07-12-Top5PythonDataVisualizationTechniquesYouProbablyArentUsing_5.png)\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n헥스빈 플롯 또는 육각형 바이닝은 데이터 점이 밀집되어 있을 때 특히 2D 데이터 분포를 시각화하는 데 효과적입니다. 데이터 공간을 육각형 바인으로 분할하며 색상은 각 바인 내의 점 수를 나타내어 데이터 분포를 명확하게 표현합니다.\n\nPython과 Matplotlib을 사용하여 공기 품질 지수(AQI)와 병원 방문 간의 상관 관계를 시연한 헥스빈 플롯을 만드는 예제를 보여드릴게요.\n\n```js\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mplhexbin import HexBin\n\n# 시뮬레이션 데이터\nnp.random.seed(0)  # 재현성 확보\nn_points = 10000\nx = np.random.rand(n_points) * 100  # 공기 품질 지수(AQI) 범위: 0에서 100\ny = 5 * np.sin(x * np.pi / 50) + np.random.randn(n_points) * 15  # 시뮬레이션된 병원 방문, AQI와 관련 있지만 잡음이 있음\n\n# 새로운 그림 생성\nfig, ax = plt.subplots(figsize=(10, 8))\n\n# HexBin을 사용하여 육각형 바인 플롯 생성\nhb = HexBin(ax, gridsize=20, cmap='viridis', extent=[0, 100, -30, 50])  # 그리드 크기, 색상 지도 및 범위 설정\nhb.hexbin(x, y, mincnt=1)  # 육각형 바인 플롯 그리기, mincnt는 최소 카운트 임계값을 설정합니다\n\n# 제목 및 축 레이블 추가\nax.set_title('공기 품질 지수(AQI)와 병원 방문 간의 관계')\nax.set_xlabel('공기 품질 지수(AQI)')\nax.set_ylabel('병원 방문')\n\n# 그림 표시\nplt.colorbar(hb.cmap, ax=ax, label='데이터 포인트 수')  # 컬러바 추가 및 레이블 설정\nplt.show()\n```\n\n<img src=\"/TIL/assets/img/2024-07-12-Top5PythonDataVisualizationTechniquesYouProbablyArentUsing_6.png\" />\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nhttps://matplotlib.org/stable/gallery/statistics/hexbin_demo.html\n\n# 4. 샌키 다이어그램\n\n샌키 다이어그램은 엔터프라이즈 시스템과 시계열 데이터의 흐름을 시각적으로 보여주는 차트입니다. 데이터의 유입과 유출을 보여주며 주로 에너지, 재료, 금융 데이터에 사용됩니다. 매튜 헨리 핀리어스 릴 샌키(Mattew Henry Phineas Riall Sankey)의 이름을 따와 만들어졌습니다. 다이어그램은 시스템의 단계들 간의 데이터 양을 바로 알 수 있게 해줍니다. 노드의 너비는 흐름의 양과 비례하기 때문에 데이터의 규모와 방향을 이해하기 쉽습니다.\n\n<img src=\"/TIL/assets/img/2024-07-12-Top5PythonDataVisualizationTechniquesYouProbablyArentUsing_7.png\" />\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 파이썬을 사용하여 생산원에서 작은 도시 소비자에게 에너지 흐름을 보여주는 샌키 다이어그램을 생성하는 예제입니다.\n\n```python\nimport plotly.graph_objects as go\n\nlabels = [\"Coal\", \"Solar\", \"Wind\", \"Nuclear\", \"Residential\", \"Industrial\", \"Commercial\"]\n\nsource = [0, 1, 2, 3, 0, 1, 2, 3] \ntarget = [4, 4, 4, 4, 5, 5, 5, 5] \nvalue = [25, 10, 40, 20, 30, 15, 25, 35] \n\n# 샌키 다이어그램 객체 생성\nfig = go.Figure(data=[go.Sankey(\n    node=dict(\n        pad=15,  \n        thickness=20, \n        line=dict(color=\"black\", width=0.5),\n        label=labels \n    ),\n    link=dict(\n        source=source,  \n        target=target, \n        value=value  \n    ))])\n\nfig.update_layout(title_text=\"모델 도시의 에너지 흐름\", font_size=12)\nfig.show()\n```\n\n[이미지 바로가기](/TIL/assets/img/2024-07-12-Top5PythonDataVisualizationTechniquesYouProbablyArentUsing_8.png)\n\n[Plotly 샌키 다이어그램 자세히 보기](https://plotly.com/python/sankey-diagram/)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 5. 스트림 그래프 (테마 리버)\n\n스트림 그래프는 변화를 나타내는 강을 닮았습니다. 색상이 카테고리를 구분하며, \"강\"의 너비는 각 카테고리의 값으로 나타냅니다. 데이터 동태를 이해하기 쉽게 보여주며, 추세와 관계를 시각적으로 표현합니다.\n\n![Stream Graph](/TIL/assets/img/2024-07-12-Top5PythonDataVisualizationTechniquesYouProbablyArentUsing_9.png)\n\n여기에는 Altair 라이브러리를 사용하여 스트림 그래프를 만드는 예시가 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport altair as alt\nfrom vega_datasets import data\n\nsource = data.unemployment_across_industries.url\n\nalt.Chart(source).mark_area().encode(\n    alt.X('yearmonth(date):T',\n        axis=alt.Axis(format='%Y', domain=False, tickSize=0)\n    ),\n    alt.Y('sum(count):Q', stack='center', axis=None),\n    alt.Color('series:N',\n        scale=alt.Scale(scheme='category20b')\n    )\n).interactive()\n```\n\n<img src=\"/TIL/assets/img/2024-07-12-Top5PythonDataVisualizationTechniquesYouProbablyArentUsing_10.png\" />\n\nhttps://altair-viz.github.io/gallery/streamgraph.html\n\n최신 AI 이야기를 계속 읽으려면 Substack에서 저희와 함께하세요. 우리 함께 AI의 미래를 모습을 만들어 봅시다!\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파이썬 이야기를 업데이트 받으려면 Substack에서 저희와 함께 연락하십시오. 함께 파이썬을 배워봐요!","ogImage":{"url":"/TIL/assets/img/2024-07-12-Top5PythonDataVisualizationTechniquesYouProbablyArentUsing_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-Top5PythonDataVisualizationTechniquesYouProbablyArentUsing_0.png","tag":["Tech"],"readingTime":9},{"title":"수학적 프로그래밍으로 자산 저장 문제 해결하는 방법","description":"","date":"2024-07-12 20:05","slug":"2024-07-12-HowtoSolveanAssetStorageProblemwithMathematicalProgramming","content":"\n\n<img src=\"/TIL/assets/img/2024-07-12-HowtoSolveanAssetStorageProblemwithMathematicalProgramming_0.png\" />\n\n이사는 어려워요. 솔직히 말해서, 매우 귀찮아요. 좀 짜증나죠. 특히 새로 이사갈 곳이 없으면 더 어려워요. 그런 경우에는 친구 집에 머물면서 물건을 임시 보관할 곳을 빌려야 할 수도 있는데, 보관 장소는 사용 면적에 따라 요금을 부과하기 때문에 가격이 비싸질 수 있어요. (그런 일은 절대 없다고 하시기 전에, 프랑스에서 폴란드로 이사 올 때 제 친구 중 한 명에게 일어났던 정황을 알려드립니다.)\n\n개인에게 이사가 이미 어려운 상황이라면, 정식으로 이사를 하고 전체 공장을 임시 보관하는 작업의 복잡함을 상상해보세요. 아마 \"와, 루이스, 이건 미친 소리인데\"라고 생각하실 수도 있지만, 실제로 이런 상황이 발생해요. 제게도 일어난 일이었고, 그 당시에는 이를 처리할 수 있는 분석 도구가 없었어요.\n\n저는 석유 및 가스 서비스 업종에서 일했었어요. 나라 내에서 비즈니스 환경이 급격히 악화되고 불안정해졌던 시기가 있었어요. 일부 서비스에 대해서는 상황이 더 이상 지속할 수 없어져, 경영진이 손실을 줄이기 위해 그 서비스를 폐쇄하기로 결정했어요. 이 서비스들이 발생한 중요한 비용 중 하나는 운영 시설의 임대료인데, 임대료를 절약하기 위해 그 시설을 사용 중지하는 것이 합리적이었어요. 그러나 시설을 폐쇄한다는 것은 전체 작업장을 닫고 모든 자산을 보관 장소로 이동해야 한다는 것을 의미했어요. 기억하세요, 이건 석유 및 가스 산업입니다. 이 자산들은 수십억 달러의 가치를 지닌 고도로 정교한 도구들이에요. 이 자산 중 일부 스페어 파츠만 수천 달러의 가치를 지니며 도둑질과 불법 시장 매매의 쉬운 표적이었어요. 그래서 도전 과제는 자산을 이동시키는 것뿐만 아니라 임시로 보관하고 그 중요성을 지키는 것이었어요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n제 매니저인 뛰어난 분이 이 문제를 제게 제기했어요. 우리는 전체 서비스 부문의 모든 자산을 본 시설로 이전하여 안전하고 제한된 공간에 보관할 계획이라고 말씀해 주셨어요. 이러한 자산들이 매우 귀중하기 때문에 도난이나 손상 가능성을 최대한 피하고 싶었습니다. 특히 몇몇 특수 트럭은 수천 달러가치의 부품이 장착되어 있었고, 국가의 상황을 감안할 때 도난 유혹이 높았어요. 따라서, 관리 부서의 허락이 없는 한 누구도 안전 구역에 들어가선 안 되었죠. 이 규칙을 시행하기 위해 우리는 전기 울타리와 경계를 침범한 사람이 있을 경우 알람이 울리도록 연결된 적외선 센서로 해당 영역을 둘러쌌어요 (진짜 말이죠; 이건 실화입니다). 그러나 이 계획의 문제는 그 모든 방어 조치가 비용이 많이 든다는 것이었고, 이 방어 시스템을 빌려주는 회사는 총 둘러싸인 영역을 기준으로 비용을 부과했어요. 제 매니저는 안전 구역 면적을 최소화하여 비용을 줄이기 위해 이 자산들의 공간 배치 방법을 찾아보라고 했어요. 전기 울타리 회사는 둘러싸인 영역이 직사각형이나 정사각형이어야 한다고 요구했어요. 게다가, 자산에 손상을 피하기 위해 자산을 쌓을 수 없었죠 (트럭 위에 다른 트럭을 올릴 수 없어요). 그래서 우리는 문서에 공통되게 \"조합 문제\"라고 알려진 이차원 저장 문제를 다루게 되었어요.\n\n![](/TIL/assets/img/2024-07-12-HowtoSolveanAssetStorageProblemwithMathematicalProgramming_1.png)\n\n수학적 프로그래밍 능력으로 이 문제를 해결했다고 말씀 드리고 싶지만, 그렇지는 않아요. 이것은 나에게 박사 학위를 취득하기 훨씬 이전의 일이었고, 그 당시에는 이 문제를 수학적 최적화로 어떻게 다루어야 하는지 조차 모르고 있었거든요 - 사실, 어떻게 검색을 시작해야 하는지에 대해선 전혀 알고 있었을 리도 없었어요 (문제가 \"조합 문제\"라는 걸 어떻게 알고 시작해야 하는지 말이죠?). 삶에선 때로는 아무것도 모르는 걸 모르는 법이 있어요.\n\n사실, 이러한 문제를 해결하는 방법을 배우는 것이 제 학습을 계속하는 주된 동기였어요. 그래서 이 기사에서는 이 문제를 어떻게 구성하는지, 파이썬과 gurobipy를 사용하여 어떻게 해결하는지, 그리고 마지막에는 이를 해결하기 위해 적용할 수 있는 일부 휴리스틱 절차에 대해 간단히 이야기할 거예요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nGurobi를 사용해본 적이 없다면, 특히 Google Colab에서 사용하는 경우, Gurobi 웹 라이선스를 Colab 환경에 설정하는 방법을 설명한 이전의 제 글 중 하나를 읽어보시기를 권유드립니다. 아래에서 해당 글 링크를 찾아볼 수 있어요:\n\n만약 선형 프로그래밍(LP) 또는 정수 프로그래밍(IP) 기술에 대한 자습서와 더 많은 정보가 필요하다면, Bruno가 쓴 훌륭한 글들을 확인하는 걸 강력 추천해요. 또 다른 좋은 소스는 William의 수학적 프로그래밍에 대한 책이에요 [1].\n\n글 목차:\n\n- Assortment 문제\n- 라이브러리 설치 및 Colab 환경 설정\n- 입력 데이터 및 전처리\n- Gurobipy로 문제 해결\n- 구성적 휴리스틱 솔루션\n- 휴리스틱에서 웜 스타트를 통한 문제 해결\n- 결론\n- 참고 문헌\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 아이템 조합 문제\n\n아이템 조합 문제의 일반적인 버전은 큰 세트에서 항목의 부분집합을 선택하여 선반 공간이나 예산과 같은 제약 조건 하에 수익 또는 이윤을 극대화하는 것을 포함합니다. 이는 소매 및 운영 관리에서 흔히 볼 수 있는 문제로, 최적화 기술과 종종 소비자 선택 모델링을 포함합니다. 이 글에서 다루는 특정 아이템 조합 문제는 물류 및 생산 상황에서 자주 나타나는 2D 직사각형 패킹 문제로도 알려져 있습니다.\n\n이 문제에서의 목표는 개별 작은 단위가 잘릴 수 있는 객체의 최소 크기를 결정하는 것입니다. 형식적으로는, 동일하거나 다른 크기의 직사각형 모음을 최소 영역 내에 서로 겹치지 않도록 배치하는 문제로 정의될 수 있습니다. 시설 배치 상황에서 이 문제는 여러 응용이 있으며, 이를 해결하기 위한 다양한 휴리스틱 접근법이 있습니다.\n\n이 문제에 필요한 변수는 다음과 같습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![image](/TIL/assets/img/2024-07-12-HowtoSolveanAssetStorageProblemwithMathematicalProgramming_2.png)\n\n- 변수 x_i와 y_i는 우리 문제의 각 \"사각형\" 자산의 (x, y) 좌표에 해당합니다. 모든 자산 또는 직사각형을 포함하는 I 집합이 있습니다.\n- 변수 b_i_j_k는 모델에서 \"OR\" 조건을 설정하기 위해 필요한 보조 이진 변수이며, 사용 방법은 나중에 자세히 설명됩니다.\n- 변수 X와 Y는 모든 자산을 배치하여 얻은 총 폭과 총 높이에 해당하며, 이 두 변수를 사용하여 모든 자산을 저장하는 데 사용된 총 면적을 계산할 것입니다.\n- 마지막으로 각 직사각형 i는 회전할지 여부를 결정하는 변수 r_i를 갖게 됩니다.\n\n다음과 같은 포맷을 사용하여 문제를 모델링할 수 있습니다\n\n![image](/TIL/assets/img/2024-07-12-HowtoSolveanAssetStorageProblemwithMathematicalProgramming_3.png)\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 공식은 처음에는 복잡해 보일 수 있지만 실제로는 꽤 간단합니다. 목적 함수는 총 면적에 해당하며, 이는 폭과 높이인 X와 Y의 곱입니다.\n\n제약 조건 (1)은 총 폭 값 X가 각 항목의 x 좌표와 너비를 더한 것보다 커야 함을 보장합니다. 비슷하게, 제약 조건 (2)은 총 높이 값 Y가 각 항목의 y 좌표와 높이를 더한 것보다 커야 함을 보장합니다.\n\n제약 조건 (3-7)은 서로 다른 항목들의 위치 간에 겹침이 없도록 보장합니다. 이러한 제약 조건은 각 항목에 대해 변수 b_i_j_1, b_i_j_2, b_i_j_3 및 b_i_j_4를 이용하며 Big-M 방법을 활용하여 OR 조건으로 작동합니다. 요약하면 한 항목은 다른 항목의 왼쪽, 오른쪽, 위 또는 아래에 위치할 수 있지만, 절대로 겹치지 않습니다.\n\n제약 조건 (8-11)은 변수가 적절한 도메인에 속하는 것을 보장합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 라이브러리 설치 및 콜랩 환경 설정하기\n\n구글 콜랩에서 Gurobi를 사용하려면 먼저 다음 코드를 사용하여 설치해야 합니다:\n\n```js\n!pip install gurobipy\n```\n\n설치가 완료되면 이 프로젝트에 필요한 라이브러리를 가져올 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Rectangle\nfrom itertools import chain, combinations, permutations, product\nimport gurobipy as gp\nfrom gurobipy import GRB\nfrom copy import deepcopy\n```\n\n또한 gurobi 세션을 초기화해야 하므로 gurobi 라이선스의 모든 관련 정보를 포함한 params 사전을 만들어야 합니다.\n\n```js\nWLSACCESSID = '< 여기에 귀하의 WLSACCESSID를 복사하세요 >'\nWLSSECRET = '< 여기에 귀하의 WLSSECRET를 복사하세요 >'\nLICENSEID = '< 여기에 귀하의 LICENSEID를 복사하세요 >'\n\nparams = {\n\"WLSACCESSID\": WLSACCESSID,\n\"WLSSECRET\": WLSSECRET,\n\"LICENSEID\": LICENSEID,\n}\nenv = gp.Env(params=params) #이 줄은 gurobi 환경을 초기화합니다\n```\n\n# 입력 데이터 및 전처리\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n간편함을 위해, 7가지 다른 차원의 34개 아이템만 사용하겠습니다. 이 값들은 설명을 위해 작게 유지했습니다. 이전 경험상으로는 수백 개의 엄청난 크기의 자산들과 실제로 무거운 화물 트럭들도 처리해야 했었습니다. 예시 아이템들의 차원은 표 1에 나와 있습니다.\n\n데이터를 사용할 수 있도록 보장하기 위해, 서로 다른 값을 리스트에 저장한 다음, 각 항목을 따로 행으로 준비한 확장된 데이터프레임을 만들 것입니다. 다음 코드로 이를 실현할 수 있습니다:\n\n```js\nwidths = [4,1,2,3,2,6,10]\nheights = [3,1,1,2,4,2,4]\nquants = [4,10,8,5,2,3,2]\n\nWIDTHS = []\nHEIGHTS = []\nfor q, w, h in zip(quants, widths, heights):\n  for x in range(q):\n    HEIGHTS.append(w)\n    WIDTHS.append(h)\n\ndata_df = pd.DataFrame()\ndata_df['HEIGHTS'] = HEIGHTS\ndata_df['WIDTHS'] = WIDTHS\n\nN = len(data_df) # 항목 개수\ntop = max(data_df['HEIGHTS'].sum(), data_df['WIDTHS'].sum()) # X 또는 Y의 최댓값\nM = top # OR 조건에 사용될 큰 M\n\nI = range(N) # 각 자산 \"i\"의 인덱스\nK = range(4) # OR 변수 \"b\"의 인덱스\n```\n\n# Gurobipy로 문제 해결\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 필요한 모든 라이브러리와 입력 데이터가 준비되었으니, Figure 3에 설명된 수학 모델을 생성할 차례입니다. GurobiPy를 사용하여 이 모델을 구현하려면 아래의 코드 스니펫을 따르면 됩니다:\n\n```js\nmodel = gp.Model(\"Assortment\",env=env)\n\n# (x,y) 좌표 변수\nx = model.addVars(I,lb = 0,ub = top,vtype=GRB.CONTINUOUS, name=\"x\")\ny = model.addVars(I,lb = 0,ub = top,vtype=GRB.CONTINUOUS, name=\"y\")\n\n# 회전 변수\nR = model.addVars(I,vtype=GRB.BINARY,name = 'R')\n\nX = model.addVar(lb=0,ub = top,vtype = GRB.CONTINUOUS,name = \"X\")\nY = model.addVar(lb=0,ub = top,vtype = GRB.CONTINUOUS,name = \"Y\")\n\n# OR 조건을 위한 b 변수\nb_vars = [(i,j,k) for i in I for j in I if j!=i for k in K]\nB = model.addVars(b_vars,vtype = GRB.BINARY,name = \"B\")\n\n# 목적 함수\nmodel.setObjective(X*Y,GRB.MINIMIZE);\n\n# 제약 조건 (1) 및 (2)\nfor i in I:\n\n  model.addConstr(X >= x[i] + WIDTHS[i]*R[i] + (1-R[i])*HEIGHTS[i])\n  model.addConstr(Y >= y[i] + HEIGHTS[i]*R[i] + (1-R[i])*WIDTHS[i])\n\n\n# 제약 조건 (3-7)\nfor i in I:\n  for j in I:\n    if i == j:\n      continue\n    else:\n      #제약 조건 (3)\n      model.addConstr(x[i] + WIDTHS[i]*R[i] + (1-R[i])*HEIGHTS[i] <= x[j] + M*(1-B[i,j,0]))\n      #제약 조건 (4)\n      model.addConstr(x[j] + WIDTHS[j]*R[j] + (1-R[j])*HEIGHTS[j] <= x[i] + M*(1-B[i,j,1]))\n      #제약 조건 (5)\n      model.addConstr(y[i] + HEIGHTS[i]*R[i] + (1-R[i])*WIDTHS[i] <= y[j] + M*(1-B[i,j,2]))\n      #제약 조건 (6)\n      model.addConstr(y[j] + HEIGHTS[j]*R[j] + (1-R[j])*WIDTHS[j] <= y[i] + M*(1-B[i,j,3]))\n      #제약 조건 (7)\n      model.addConstr(B[i,j,0] + B[i,j,1] + B[i,j,2] + B[i,j,3] >= 1)\r\n```\n\n참고로 제약 조건 (8–11)은 변수 생성 단계에서 설정되었으므로 model.addConstr 메서드를 통해 명시적으로 추가할 필요가 없습니다. 이제 모델이 완성되었으니 해결할 수 있습니다. 이 문제를 해결하기 위해 아래 코드를 따라주세요:\n\n```js\ntl = 600\nmip_gap = 0.05\n\nmodel.setParam('TimeLimit', tl)\nmodel.setParam('MIPGap', mip_gap)\nmodel.optimize()\r\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n600초 후에도 최적 솔루션에는 아직 멀리 떨어져 있지만 사용 영역이 크게 줄어들었습니다. 초기 값 620에서 최종 값 238로 줄었습니다. 이는 초기 솔루션의 약 1/3에 해당하는 값입니다. 나쁘지 않죠.\n\n![이미지](/TIL/assets/img/2024-07-12-HowtoSolveanAssetStorageProblemwithMathematicalProgramming_4.png)\n\n문제가 해결되었으므로 솔루션을 추출하고 플롯해야 합니다. 다음 코드를 따라하기만 하면 matplotlib의 Rectangle 객체를 사용하여 쉽게 이 작업을 수행할 수 있습니다:\n\n```javascript\nall_vars = model.getVars()\nvalues = model.getAttr(\"X\", all_vars)\nnames = model.getAttr(\"VarName\", all_vars)\n\nobj = round(model.getObjective().getValue(),0)\n\ntotal_X = int(round((X.x),0))\ntotal_Y = int(round((Y.x),0))\n\nfig, ax = plt.subplots()\n\nfor item in I:\n\n  coords = (x[item].x,y[item].x)\n\n  if R[item].x <= 0.01:\n    wid = HEIGHTS[item]\n    hig = WIDTHS[item]\n  else:\n    wid = WIDTHS[item]\n    hig = HEIGHTS[item]\n\n  ax.add_patch(Rectangle(coords, wid, hig,\n            edgecolor = 'black',\n            facecolor = \"Grey\",\n            fill = True,\n            alpha = 0.5,\n            lw=2))\nax. set_xlim(0, total_X )\nax. set_ylim(0, total_Y )\n\nax.set_xticks(range(total_X+1))\nax.set_yticks(range(total_Y+1))\nax.grid()\nax.set_title(f\" Total area {total_X} x {total_Y} = {int(obj)}\")\n\nplt.show()\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래의 그림 5에서 얻은 조합 솔루션을 시각화할 수 있습니다.\n\n![Figure 5](/TIL/assets/img/2024-07-12-HowtoSolveanAssetStorageProblemwithMathematicalProgramming_5.png)\n\n마지막으로, 솔루션을 데이터프레임에 저장할 수 있습니다. 이후 동료와 공유하고 싶을 때 CSV 또는 Excel 파일로 다운로드할 수 있습니다. 아래 코드 스니펫을 따라하면 됩니다:\n\n```js\noutput_list = []\nfor i in I:\n  print(f\"item {i} x:{x[i].x}, y:{y[i].x}, Rotated:{R[i].x <= 0.01}\")\n  row = {'item':i,'x':round(x[i].x,2),'y':round(y[i].x,2),'Rotated':R[i].x <= 0.01}\n  output_list.append(row)\n\noutput_df = pd.DataFrame(output_list)\noutput_df.to_csv(\"output_solution.csv\") # 솔루션을 .csv 파일로 다운로드\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 휴리스틱 솔루션 구성\n\n소개에서 언급한대로, 이 문제를 이전 섹션의 수학적 프로그래밍 공식을 사용하여 최적으로 해결하고 싶었지만, 이 도전에 처음 직면할 때 이러한 기술을 알지 못했습니다. 그러나 그렇다고 해서 해결책을 제공하지 않았던 것은 아닙니다. 사실, 모든 자산을 정리하고 안전한 영역에 포장했습니다. 솔루션은 최적은 아니지만, 그래도 솔루션이었습니다. 어떻게 하였을까요? 아마도 휴리스틱이나 여러 가지 휴리스틱의 조합을 사용했을 것입니다.\n\n정식으로는, 휴리스틱이란 \"완전히 최적화되거나 완전히 최적화되지 않은, 완벽하게 되찾거나 합리화되지 않은 현실적인 방법을 사용하는 문제 해결 방법\"입니다. 우리는 인지하지 못해도, 우리는 상당히 휴리스틱을 적용하여 문제를 해결하며, 이 문제 조합 문제도 예외가 아닙니다. 다양한 구성 휴리스틱을 만들어낼 수 있습니다. 다음 섹션에서 두 가지에 대해 논의할 것입니다.\n\n## FFDH: 첫 번째 적합 감소 높이 휴리스틱\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 접근 방식으로는, 간단히 사각형을 높이 순으로 정렬한 다음 각 자산을 왼쪽에서 오른쪽으로 이동하면서 맞는 첫 번째 위치에 배치합니다. 이 휴리스틱을 구현하기 위해 Python에서 새로운 클래스를 만든 후 해당 클래스의 인스턴스와 함께 작동하는 함수로 휴리스틱을 개발할 것입니다. 아래의 코드를 사용하여 간단히 새 클래스를 만들고 각 자산을 인스턴스화할 수 있습니다:\n\n```js\n# 새 클래스 정의\nclass Rectangle_class:\n    # 생성자\n    def __init__(self, width, height, index):\n        self.width = width\n        self.height = height\n        self.x = 0\n        self.y = 0\n        self.index = index\n\n# 모든 자산의 목록 만들기\nrectangles = [] \n\n# 각 자산을 위해 사각형 인스턴스 초기화\nfor i in range(len(data_df)): \n    h, w = data_df.iloc[i,0], data_df.iloc[i,1]\n    REC = Rectangle_class(w, h, i)\n    rectangles.append(REC)\n```\n\n아래의 코드를 사용하여 휴리스틱 함수를 구현할 수 있습니다:\n\n```js\ndef ffdh(rectangles):\n    # 높이를 기준으로 사각형 정렬(내림차순)\n    rectangles.sort(key=lambda rect: rect.height, reverse=True)\n\n    # 위치 추적을 위한 변수 초기화\n    current_y = 0\n    current_x = 0\n    row_height = 0\n    total_width = 0\n\n    for rect in rectangles:\n        if current_x + rect.width > total_width:\n            total_width = current_x + rect.width\n        # 현재 행에 사각형이 맞는지 확인\n        if current_x + rect.width <= total_width:\n            rect.x = current_x\n            rect.y = current_y\n            current_x += rect.width\n            row_height = max(row_height, rect.height)\n        else:\n            # 다음 행으로 이동\n            current_y += row_height\n            rect.x = 0\n            rect.y = current_y\n            current_x = rect.width\n            row_height = rect.height\n\n    total_height = current_y + row_height\n    return rectangles, total_width, total_height\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 함수는 수정된 좌표와 함께 자산의 총 너비와 높이를 반환합니다. 이 휴리스틱을 사용하여 34개의 자산 문제에 대해 어떤 결과를 얻을 수 있는지 확인해보겠습니다.\n\n```js\n# 함수 호출 및 출력값 저장\npacked_rectangles, total_width, total_height = ffdh(rectangles)\n\ntotal_X = total_width\ntotal_Y = total_height\n\n# 사용된 최종 영역 계산\nobj = total_X * total_Y\n\n# 솔루션 플롯\nfig, ax = plt.subplots(figsize=(16, 6))\n\nfor rect in packed_rectangles:\n    coords = (rect.x, rect.y)\n    wid, hig = rect.width, rect.height\n\n    ax.add_patch(Rectangle(coords, wid, hig,\n            edgecolor='black',\n            facecolor=\"Grey\",\n            fill=True,\n            alpha=0.5,\n            lw=2))\nax.set_xlim(0, total_X)\nax.set_ylim(0, total_Y)\n\nax.set_xticks(range(total_X+1))\nax.set_yticks(range(total_Y+1))\nax.grid()\nax.set_title(f\" 총 면적 {total_X} x {total_Y} = {int(obj)}\")\nplt.xticks(rotation=30)\nplt.show()\n```\n\n얻은 출력 솔루션은 아래 그림 6에 표시되어 있습니다:\n\n<img src=\"/TIL/assets/img/2024-07-12-HowtoSolveanAssetStorageProblemwithMathematicalProgramming_6.png\" />\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 휴리스틱으로 제공된 솔루션은 총 620의 면적을 갖고 있습니다. 우연히도 이 값은 Gurobi의 시작점이기도 했습니다. 솔루버가 가지-및-한정 알고리즘을 시작하기 전에, 초기 솔루션을 미세 조정하기 위해 여러 휴리스틱을 적용하며, 아마도 이 휴리스틱이 하나일 것입니다.\n\n## 선반 휴리스틱\n\n이 휴리스틱은 최대 너비 제약 조건(우리가 제공하는 경우)으로 자산들을 높이 기준으로 정렬하여 평면 상에 배치합니다. 휴리스틱은 현재 선반이 가로 제한에 도달할 때까지 자산들을 배치하고, 그 후에 새로운 선반으로 이동하여 총 너비와 높이를 갱신합니다. 아래 함수를 사용하여 휴리스틱을 구현했습니다:\n\n```js\ndef shelf_heuristic(rectangles, max_width):\n    # 자산들을 높이 기준으로 내림차순 정렬\n    rectangles.sort(key=lambda rect: rect.height, reverse=True)\n\n    current_x = 0\n    current_y = 0\n    shelf_height = 0\n\n    for rect in rectangles:\n        if current_x + rect.width > max_width:\n            # 새로운 선반으로 이동\n            current_x = 0\n            current_y += shelf_height\n            shelf_height = 0\n\n        # 직사각형 배치\n        rect.x = current_x\n        rect.y = current_y\n        current_x += rect.width\n        shelf_height = max(shelf_height, rect.height)\n\n    total_width = max([rec.x + rec.width for rec in rectangles])\n    total_height = max([rec.y + rec.height for rec in rectangles])\n\n    return rectangles, total_width, total_height\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n좌표와 폭, 높이 값을 결정한 뒤, 해당 사각형을 도형으로 그려보세요. 이것이 우리가 34개의 자산과 선반 너비 20을 사용했을 때 발생한 결과입니다. 결과는 아래 그림 7에 표시되어 있습니다:\n\n```js\ncontainer_width = 20\npacked_rectangles,total_width, total_height = shelf_heuristic(rectangles, container_width)\n\ntotal_X = total_width\ntotal_Y = total_height\n\nobj = total_X*total_Y\n\n# 솔루션의 그래프 생성\nfig, ax = plt.subplots(figsize=(16, 6))\n\nfor rect in packed_rectangles:\n\n  coords = (rect.x,rect.y)\n  wid,hig = rect.width,rect.height\n\n  ax.add_patch(Rectangle(coords, wid, hig,\n            edgecolor = 'black',\n            facecolor = \"Grey\",\n            fill = True,\n            alpha = 0.5,\n            lw=2))\nax. set_xlim(0, total_X )\nax. set_ylim(0, total_Y )\n\nax.set_xticks(range(total_X+1))\nax.set_yticks(range(total_Y+1))\nax.grid()\nax.set_title(f\" Total area {total_X} x {total_Y} = {int(obj)}\")\nplt.xticks(rotation=30)\nplt.show()\n```\n\n위 코드를 사용하여 얻은 출력 결과는 아래 그림 7에 표시되어 있습니다:\n\n<img src=\"/TIL/assets/img/2024-07-12-HowtoSolveanAssetStorageProblemwithMathematicalProgramming_7.png\" />\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 휴리스틱으로 제공된 솔루션은 총 340의 면적을 가지고 있으며, FFDH로부터 얻은 면적의 거의 절반이 됩니다. 이는 이 휴리스틱처럼 빠르게 실행되는 휴리스틱이며, 자산의 회전을 허용하지 않기 때문에 휴리스틱의 품질이 크게 향상될 것으로 예상되는 것을 고려할 때 훌륭합니다. 이 문제에는 수십 개의 휴리스틱이 있음을 유의해 주세요. 저희는 인기 있는 두 가지만 다루었을 뿐이니, 더 자세한 정보는 참고 문헌 [6-8]을 확인해 주세요.\n\n아마도 \"와, 루이스야, 이 340 면적에서 시작하는 솔버가 있으면 좋겠다\"고 생각 중일 수도 있으시겠죠? 그렇다면 틀림없습니다. 그래서 다음 섹션에서 이에 대해 다룰 것입니다.\n\n# 휴리스틱에서 시작하는 웜 스타트로 문제 해결하기\n\nGurobi와 같은 최신 솔버는 사용자가 모델을 설정할 때 \"웜 스타트\" 솔루션을 제공할 수 있도록 합니다. 이 초기 솔루션은 최적화 프로세스를 더 효율적으로 만들어 줍니다. 저희의 선반 휴리스틱으로부터 얻은 솔루션에서 값을 추출하고 모델에서 기대하는 형식으로 솔루션을 변환할 수 있습니다. 기억하세요, 이에는 좌표 뿐만 아니라 총 너비, 높이, 회전 변수 및 겹치는 변수 b_i_j_k도 포함됩니다. 아래의 코드 스니펫을 사용하여 휴리스틱에서 솔루션을 쉽게 변환할 수 있습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nheuristic_dict = dict()\nfor rect in packed_rectangles: \n  index = rect.index\n  heuristic_dict[index] = rect\n\nb_values = dict()\nfor i in I:\n  for j in I:\n    if i == j:\n      continue\n    else:\n      rect_i = heuristic_dict[i]\n      rect_j = heuristic_dict[j]\n      \n      # b의 초기값을 0으로 설정\n      b_values[(i,j,0)] = 0\n      b_values[(i,j,1)] = 0\n      b_values[(i,j,2)] = 0\n      b_values[(i,j,3)] = 0\n\n      # 각 조건을 확인하고 b의 실제 값을 설정\n      if rect_i.x + rect_i.width <= rect_j.x:\n        b_values[(i,j,0)] = 1\n\n      if rect_j.x + rect_j.width <= rect_i.x:\n        b_values[(i,j,1)] = 1\n\n      if rect_i.y + rect_i.height <= rect_j.y:\n        b_values[(i,j,2)] = 1\n\n      if rect_j.y + rect_j.height <= rect_i.y:\n        b_values[(i,j,3)] = 1   \n\n# x, y 및 r의 솔루션 값을 저장\nx_dict = dict()\ny_dict = dict()\nr_dict = dict()\n\nfor i in I:\n  REC = heuristic_dict[i]\n  x_dict[i] = REC.x\n  y_dict[i] = REC.y\n  r_dict[i] = 1  # 모든 자산은 회전되지 않음\n```\n\n이제 휴리스틱 솔루션을 추출하고 모델이 예상하는 적절한 형식으로 변환했으므로 이 솔루션을 시작점으로 추가하여 모델을 다시 실행할 수 있습니다. 아래 코드는 새로운 모델을 작성하고 웜 스타트 솔루션을 추가하는 방법을 보여줍니다.\n\n```js\n# 이전과 같은 모델\nmodel = gp.Model(\"Assortment_warm_start\", env=env)\n\nx = model.addVars(I, lb=0, ub=top, vtype=GRB.CONTINUOUS, name=\"x\")\ny = model.addVars(I, lb=0, ub=top, vtype=GRB.CONTINUOUS, name=\"y\")\n\nR = model.addVars(I, vtype=GRB.BINARY, name='R')\n\nX = model.addVar(lb=0, ub=top, vtype=GRB.CONTINUOUS, name=\"X\")\nY = model.addVar(lb=0, ub=top, vtype=GRB.CONTINUOUS, name=\"Y\")\n\nb_vars = [(i, j, k) for i in I for j in I if j != i for k in K]\nB = model.addVars(b_vars, vtype=GRB.BINARY, name=\"B\")\n\nmodel.setObjective(X*Y, GRB.MINIMIZE)\n\nfor i in I:\n  model.addConstr(X >= x[i] + WIDTHS[i]*R[i] + (1-R[i])*HEIGHTS[i])\n  model.addConstr(Y >= y[i] + HEIGHTS[i]*R[i] + (1-R[i])*WIDTHS[i])\n\nfor i in I:\n  for j in I:\n    if i == j:\n      continue\n    else:\n      model.addConstr(x[i] + WIDTHS[i]*R[i] + (1-R[i])*HEIGHTS[i] <= x[j] + M*(1-B[i,j,0]))\n      model.addConstr(x[j] + WIDTHS[j]*R[j] + (1-R[j])*HEIGHTS[j] <= x[i] + M*(1-B[i,j,1]))\n      model.addConstr(y[i] + HEIGHTS[i]*R[i] + (1-R[i])*WIDTHS[i] <= y[j] + M*(1-B[i,j,2]))\n      model.addConstr(y[j] + HEIGHTS[j]*R[j] + (1-R[j])*WIDTHS[j] <= y[i] + M*(1-B[i,j,3]))\n      model.addConstr(B[i,j,0] + B[i,j,1] + B[i,j,2] + B[i,j,3] >= 1)\n\n# 휴리스틱 솔루션을 추가\nfor var in x:\n  x[var].Start = x_dict[var]\n  y[var].Start = y_dict[var]\n  R[var].Start = r_dict[var]\n\nX.Start = total_X\nY.start = total_Y\n\nfor var in B:\n  B[var] = b_values[var]\n```\n\n이제 모델이 웜 스타트로 초기화되었으므로 해결할 수 있습니다.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ntl = 600\nmip_gap = 0.05\n\nmodel.setParam('TimeLimit', tl)\nmodel.setParam('MIPGap', mip_gap)\nmodel.optimize()\n```\n\n만약 모든 게 예정대로 진행된다면, 최적화 프로세스를 시작하기 위해 사용자가 제공한 솔루션으로부터 시작한다는 솔버의 메시지가 나타날 것입니다. 아래 그림 8과 같이 보일 것입니다.\n\n![Figure 8](/TIL/assets/img/2024-07-12-HowtoSolveanAssetStorageProblemwithMathematicalProgramming_8.png)\n\n# 결론\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 글을 마무리하며, 수학적 프로그래밍을 사용하여 2차원 배열 문제를 해결하는 방법에 대한 세부적인 여정을 안내했습니다. 이 문제에 대한 혼합 정수 선형 프로그래밍 공식 및 일부 고전적인 인공 지능을 사용하여 이 문제를 해결하는 방법에 대해 논의했습니다. 또한 이러한 인공 지능에서 얻은 해결책을 우리의 솔버에 대한 초기 설정값으로 사용하는 방법을 다뤘습니다. 이 글이 현재 직무에서 비슷한 도전에 직면한 사람들에게 유용한 자원으로 기여하기를 희망합니다. 그당시 이 지식을 가지고 있었으면 정말 좋았을 텐데, 그럼에도 불구하고 항상 배우는 것은 늦지 않습니다. 이 글에 사용된 코드 전체를 포함한 노트북은 아래 나의 GitHub 저장소 링크에서 찾을 수 있습니다.\n\n이 글이 유익하고 즐거우셨기를 진심으로 바라고 있습니다. 그렇다면, 귀하의 생각을 듣고 싶습니다! 의견을 자유롭게 남겨주시거나 박수 👏로 감사의 의미를 표현해주세요. 그리고 최신 글을 계속해서 받아보고 싶다면 저를 Medium에서 팔로우해보세요. 여러분의 지지와 피드백이 제게 이 흥미로운 분야에서 계속 탐험하고 공유하는 원동력이 됩니다. 읽어 주셔서 감사합니다. 앞으로 더 많은 통찰력을 기대해주세요!\n\n# 참고문헌\n\n- [1] William HP. 수학적 프로그래밍에서 모델 작성. 4판. Chichester: Wiley; 1999\n- [2] Huang, Y.H., Lu, H.C., Wang, Y.C., Chang, Y.F. 및 Gao, C.K., 2020. 제조 산업의 2차원 커팅 재고 문제에 대한 글로벌 방법론. 비즈니스 및 경영에서 의사결정 과학의 응용, p.167.\n- [3] Li HL, Chang CT. 조합 문제에 대한 대략적인 글로벌 최적화 방법. 유럽 운영 연구 저널. 1998;105:604–612\n- [4] Martello S, Vigo D. 2차원 유한 바이너리 패킹 문제에 대한 정확한 해법. 경영 과학. 1998;44:388–399\n- [5] Chen CS, Sarin S, Balasubramanian R. 특정 조합 문제를 위한 혼합 정수 프로그래밍 모델. 유럽 운영 연구 저널. 1993;65:362–367\n- [6] Apple, J.M., 및 Deisenroth, M.P., “컴퓨터화된 공장 배치 및 평가 기술 — PLANET”, AIIE 연례 회의 논문집, 1973년 5월, 121.\n- [7] Buffa, E.S., Armour, G.C., 및 Vollman, T.E., “CRAFT를 사용하여 시설 할당”, 하버드 비즈니스 리뷰, 1964년 3-4월, 130.\n- [8] Seehof, J.M., and Evans, W.O., “자동화된 배치 설계 프로그램 (ALDEP)”, 산업 공학 잡지 1967년 12월, 690.","ogImage":{"url":"/TIL/assets/img/2024-07-12-HowtoSolveanAssetStorageProblemwithMathematicalProgramming_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-HowtoSolveanAssetStorageProblemwithMathematicalProgramming_0.png","tag":["Tech"],"readingTime":25},{"title":"소형 언어 모델의 가정 내 수용 테스트 방법","description":"","date":"2024-07-12 20:03","slug":"2024-07-12-HomeAcceptanceTestforSmallLanguageModels","content":"\n\n<img src=\"/TIL/assets/img/2024-07-12-HomeAcceptanceTestforSmallLanguageModels_0.png\" />\n\n요즘 인공지능 커뮤니티에서 멋진 소식들이 있었어요. 모두가 작은 언어 모델과 낮은 계산 자원 가용성과 관련이 있어요.\n\n예를 들면, 1.58비트(32비트 대신) 대규모 언어 모델을 실행하는 Transformer를 상상해봐요: 이를 위해 GPU가 필요하지 않아요.\n\n지금으로선, 이것은 아직 가능한 미래에 해당해요. 현실은 새로운 작은 언어 모델이 챗봇 어시스턴트로 놀라운 성능을 발휘할 수 있다는 거죠.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n집에서 손쉽게 직접 테스트해보고 싶지 않으세요?\n\n컴퓨터에 전용 GPU가 없는 경우에 대한 완벽한 직접 테스트 가이드를 제공해 드릴게요.\n\n![이미지](/TIL/assets/img/2024-07-12-HomeAcceptanceTestforSmallLanguageModels_1.png)\n\n# 전문적인 사전 설명\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nH2O.ai는 Apache-2 라이센스로 출시되었고 놀라운 SML을 제공합니다: h2oai/h2o-danube-1.8b-chat라고 불린답니다.\n\n마찬가지로, MBZUAI(모하메드 빈 자이드 인공지능 대학교 - LaMini 모델의 창조자)의 사랑받는 친구들은 새로운 람가 무리를 발표했습니다. 최고 러너는 MobiLlama-1B-Chat입니다.\n\n이제 다양한 Small AI가 제공되어 일상적인 작업에 파트너를 선택할 수 있습니다.\n\n이 기사에서 제공하는 방법은 로컬 컴퓨터뿐만 아니라 동일한 네트워크에 연결된 친구나 동료와 공유할 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 방법을 사용하면 Python 코드에서 변경해야 하는 유일한 부분은 페이지 제목입니다!\n\n# Home Acceptance Test\n\n이 용어는 계측 공학에서 상속 받은 것입니다. 공장 수락 테스트는 제조업체의 공장에서 수행하는 일련의 절차와 테스트로, 제조업체가 제공할 장비를 확인하는 것입니다. FAT(공장 수락 테스트) 중에 시스템이 요청한 요구사항을 준수하는지 확인해야 합니다.\n\n우리의 Small Language Models에 대해 우리 중 누구도 기대를 갖고 있습니다. 이를 확인할 방법은 없는 것일까요?\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저는 귀하의 GitHub Repo에 3가지 예제를 만들어서 귀하가 3분 안에 설정하고 수정하며 Hugging Face Hub의 거의 모든 모델과 페어링할 수 있도록 했습니다.\n\n# 홈 랩 설정 방법\n\n이 프로젝트를 가능한 한 호환성 있게 만들기 위해 최소한의:\n\n- 파이썬 라이브러리 수\n- 가장 쉬운 GGUF 추론 방법\n- 그래픽 인터페이스의 쉬운 사용자 정의를 사용했습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n따라서 이 프로젝트를 위한 새 폴더를 만들고 가상 환경을 생성한 다음 활성화하세요 (여기서 제시된 지침은 Windows 사용자를 위한 것입니다).\n\n저는 아직 Python 3.10을 사용 중이지만 3.11도 괜찮습니다. Sentencepiece를 사용하려면 3.12를 사용하지 마세요 (아직 지원되지 않음).\n\n```js\nmkdir HAT\ncd HAT\npython -m venv venv\n\nvenv\\Scripts\\activate\n```\n\n가상 환경이 활성화된 상태이므로 필요한 3개의 라이브러리만 설치해야 합니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\npip install llama-cpp-python[server]==0.2.53\npip install openai\npip install streamlit\n```\n\n라마-cpp-python 라이브러리는 CPU 만 사용하여 양자화된 모델을 실행할 수 있을뿐만 아니라 서버로서도 작동할 수 있습니다!\n\n처음에는 놀랐어요. 한 줄의 명령어로 이게 다 가능하다니요!\n\n로컬 모델을 호출하기 위해 openai Python 라이브러리가 필요합니다. 여기서의 차이점은 ChatGPT를 호출할 때와 동일한 방법으로 로컬 모델을 호출할 것이지만 인터넷 연결이 필요하지 않으며 API 키나 돈을 요청하지 않을 것입니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그리고 웹 그래픽 인터페이스로 Streamlit을 사용할 것입니다.\n\n마지막으로, 모델 파일을 잊지 말아야 합니다. 우리는 오직 CPU 자원을 사용할 계획이므로 모델의 양자화된 GGUF 형식을 사용하려고 합니다.\n\n모델을 다운로드하여 모델 하위 폴더에 저장해주세요.\n\n- https://huggingface.co/brittlewis12/h2o-danube-1.8b-chat-GGUF\n- https://huggingface.co/asedmammad/gemma-2b-it-GGUF/tree/main\n- https://huggingface.co/tsunemoto/cosmo-1b-GGUF/tree/main\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기 3개의 모델 링크를 제공해드리겠습니다 (danube-1.8B-chat Q5_K_M, Gemma-2B-it Q4_K_M, 그리고 Cosmo-1b Q4_K_M): 하지만 이 외에도 그 이상의 모델들을 사용할 수 있다는 것을 기억해 주세요.\n\n이제 모든 설정이 완료되었습니다.\n\ncosmo-1b.Q4_K_M.gguf, gemma-2b-it.q4_K_M.gguf, 그리고 h2o-danube-1.8b-chat.Q5_K_M.gguf의 모델 파일들은 model이라는 하위 폴더에 있어야 합니다.\n\n![이미지](/TIL/assets/img/2024-07-12-HomeAcceptanceTestforSmallLanguageModels_2.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# H2O Danube-1.8b-chat 테스트 벤치에서\n\n파이썬 파일을 여기 리포지토리에서 다운로드할 수 있어요. 여기서 모델을 실행하고 사용자 정의하는 과정에 대해 설명할 거예요.\n\n코드 워크스루를 원하신다면 아래 기사를 참고하세요:\n\n모델을 API로 실행한 다음 streamlit을 실행하려면 두 개의 터미널 창이 필요해요: 하나는 FastAPI 서버를 시작하고, 또 다른 하나는 Streamlit GUI 서버 역할을 할 걘이에요. 두 터미널은 모두 venv를 활성화해야 해요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n왼쪽 터미널에서 다음 명령으로 llama-cpp-server를 실행하십시오:\n\n```js\npython -m llama_cpp.server --host 0.0.0.0 --model model/h2o-danube-1.8b-chat.Q5_K_M.gguf --n_ctx 16384\n```\n\n오른쪽 터미널에서 다음 명령으로 Streamlit 서버를 시작하십시오:\n\n```js\nstreamlit run .\\Danube1.8-stChat_API.py\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n기본 브라우저를 열어 기본 챗봇 그래픽 인터페이스를 확인하세요.\n\n![Chatbot Interface](/TIL/assets/img/2024-07-12-HomeAcceptanceTestforSmallLanguageModels_3.png)\n\n바로 채팅을 시작할 수 있어요. 몇 가지 매개변수를 변경할 수 있어요 (예를 들어\n\n- 온도\n- 출력의 최대 토큰 수\n- 어시스턴트와 사용자의 턴 수와 관련된 다른 유용한 매개변수는 버퍼 메모리에 유지할 대화의 수입니 12개의 작은 모델인 Cosmo-1B이 좋은 숫자입니다. \n- 대화 전체가 txt 로그 파일에 저장됩니다. (매우 유용함)\n- '이전 대화 모두 삭제' 버튼을 클릭하면 이전 대화 내용이 모두 지워지고 처음부터 시작하게 됩니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![image](/TIL/assets/img/2024-07-12-HomeAcceptanceTestforSmallLanguageModels_4.png)\n\n# 모든 마법이 일어나는 곳은 어디인가요?\n\n실제로 동일한 Streamlit 파일을 다른 챗봇 모델과 함께 사용할 수 있는 사실은 llama-cpp-python의 힘 덕분입니다.\n\n호환되는 openai-webserver는 기본적으로 우리에게 모델과 상호작용하는 표준 방식을 제공해줍니다(API의 힘입니다...).\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n서버에서 사용 가능한 옵션 전체 목록을 보려면 명령줄에 다음과 같이 입력하면 됩니다.\n\n```js\npython3 -m llama_cpp.server --help  # 리눅스/맥 용\npython -m llama_cpp.server --help   # 윈도우 용\n```\n\n서버를 로드하는 명령줄에서 이전에 우리가 chat-format을 지정했다는 것을 알았을 것입니다. 편의를 위해, 명령줄에 전달되는 각 인수에 대해 새 줄을 추가할 것입니다.\n\n```js\npython -m llama_cpp.server \n--host 0.0.0.0 \n--model model/gemma-2b-it.q4_K_M.gguf \n--chat_format gemma \n--n_ctx 8192\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- --host 0.0.0.0: 이 argument는 서버의 노출된 IP 주소를 지정하는 데 사용됩니다. 0.0.0.0으로 설정하면 컴퓨터가 네트워크에 할당한 IP를 사용하도록 지정하는 것입니다.\n\n- --model model/gemma-2b-it.q4_K_M.gguf: 이는 GGUF 파일의 위치를 제공하는 데 사용됩니다.\n\n- --chat-format gemma: 이 argument는 채팅 템플릿에 책임이 있습니다. 각 LLM이 특정 형식의 스타일로 프롬프트를 받는 것을 기억해야 합니다. 여기서 llama-cpp가 이미 구축한 기존 채팅 템플릿을 지정합니다.\n\n- --n_ctx 8192: 이는 모델이 계산할 수 있는 컨텍스트 창입니다. Gemma-2b는 8,192토큰, Danube-1.8b는 16,384토큰의 창을 가지고 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n놀라운 엔지니어링 작업이 여기 정확히 있습니다. Andrei aka abetlen은 채팅을 처리하는 매우 똑똑한 방법을 만들었습니다 (소스는 여기에 있습니다):\n\n모델은 다음 우선 순위 순서로 메시지를 단일 프롬프트로 포맷팅합니다:\n\n- 제공된 경우 chat_handler 사용\n- 제공된 경우 chat_format 사용\n- gguf 모델의 메타데이터에서 tokenizer.chat_template 사용 (대부분의 새로운 모델에 작동해야 함, 오래된 모델에는 없을 수 있음)\n- 그렇지 않으면, llama-2 채팅 형식으로 대체\n\n의미를 보여드리기 위해 다누브-1.8b-채팅 모델의 llama-cpp-server의 로딩 시퀀스를 살펴보겠습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nGGUF 파일에는 모델 토크나이저가 포함되어 있습니다. 모델을 로드하는 동안 llama-cpp-python은 토크나이저.template을 구문 분석하여 우리가 사용할 수 있는 chat.template으로 변환합니다!\n\n이는 터미널 창에서 추출한 내용입니다.\n\n이제 다른 Streamlit 앱을 실행하지 않아도 채팅을 할 수 있습니다. Danube를 읽고 Gemma와 대화하는 것은 상당히 이상할 수 있지만 중요한 것은 챗봇이 임무를 제대로 수행하고 있다는 것입니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*2oMOmJlYp0LFWxzVycN90A.gif\" />\n\n## 그래서, Chat-formats이 뭔가요?\n\n만약 명령줄에서 챗형식을 지정하려면, llama-cpp-python이 내장된 해결책으로 제공하는 옵션들은 다음과 같습니다:\n\n```js\nllama_cpp.llama_chat_format(valid formats: [\n'llama-2', 'alpaca', 'qwen', 'vicuna', 'oasst_llama', \n'baichuan-2', 'baichuan', 'openbuddy', 'redpajama-incite', \n'snoozy', 'phind', 'intel', 'open-orca', 'mistrallite', \n'zephyr', 'pygmalion', 'chatml', 'mistral-instruct', \n'chatglm3', 'openchat', 'saiga', 'gemma', 'functionary', \n'functionary-v2', 'functionary-v1', 'chatml-function-calling'])\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결론\n\n이미 언급했듯이, 그리고 멈추지 않고 계속 말할 테니 매주 새로운 모델이 나오고 있습니다. 많은 사람들이 그 중 하나를 쫓아가느라 시간을 낭비하지 말라고 말할지도 모릅니다.\n\n하지만 저는 그것에 반대합니다! 다른 사람들의 판단에 항상 의지해서는 안 됩니다. 게다가, 작은 언어 모델(30억 파라미터 미만)은 매우 유망하며 매우 적은 추론 시간으로 CPU에서 실행할 수 있습니다.\n\n이러한 작은 모델들의 파라미터 조정은 결과를 극적으로 바꿀 수 있으며, 모든 주요 지표에서 높은 벤치마크 점수를 가질 수는 없지만 이는 전혀 좋지 않거나 특정 목적에 완벽하지 않다는 것을 의미하지 않습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n자신을 판단하는 최선의 방법은 당신 자신입니다. 홈 수용 테스트는 정말 좋은 해결책이죠!\n\n만약 놓치셨다면, 다시 한번 GitHub Repo를 확인해보세요:\n\n이 기사를 즐기셨기를 바랍니다. 이 이야기가 가치를 제공했고 조금이라도 지원을 표현하고 싶다면:\n\n- 이 이야기에 대해 많이 박수를 보내세요.\n- 기억해야 할 중요한 부분을 강조하세요(나중에 찾을 때 더 쉽고 더 나은 기사를 작성하는 데 도움이 됩니다).\n- 자신만의 AI를 만드는 방법을 배우려면 이 무료 eBook을 다운로드하세요.\n- 제 링크를 사용하여 Medium 멤버십 가입하기 ($5/월로 무제한 Medium 기사 읽기).\n- Medium에서 제 팔로우하기.\n- 제 최신 기사는 https://medium.com/@fabio.matricardi에서 읽을 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음은 몇 가지 더 자료입니다:\n\n## 챗봇 구축을 위한 자원 및 참고 자료:\n\n## 출력을 스트리밍하는 방법을 배우려면:\n\n## 채팅 템플릿 유도\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Stackademic 🎓\n\n내용을 끝까지 읽어주셔서 감사합니다. 떠나기 전에:\n\n- 작가를 클립하고 팔로우해주시면 감사하겠습니다! 👏\n- 저희를 팔로우해 주세요: X | LinkedIn | YouTube | Discord\n- 다른 플랫폼에서도 저희를 만나보세요: In Plain English | CoFeed | Venture | Cubed\n- 더 많은 콘텐츠는 Stackademic.com에서 확인하세요.","ogImage":{"url":"/TIL/assets/img/2024-07-12-HomeAcceptanceTestforSmallLanguageModels_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-HomeAcceptanceTestforSmallLanguageModels_0.png","tag":["Tech"],"readingTime":13},{"title":"파이썬을 사용하여 Log Analytics 작업 영역 데이터를 쿼리하는 방법","description":"","date":"2024-07-12 20:01","slug":"2024-07-12-HowtoQueryLogAnalyticsWorkspaceDataUsingPython","content":"\n\n# 문제 😕\n\n데이터는 새로운 석유입니다. 점점 더 많은 조직이 중요한 이유로 Azure 리소스 로그를 로그 분석 워크스페이스로 전송하기를 선택하고 있습니다:\n\n- 로그 분석 워크스페이스의 보존 기간을 최대 12년까지 구성할 수 있습니다. 이는 감사와 같은 요구 사항을 보완합니다.\n- Kusto 쿼리 언어 구문을 사용하여 강력한 쿼리를 실행할 수 있어 필요한 데이터만 좁혀 보거나 시각화하여 시가 차트 등을 사용할 수 있습니다.\n\n로그 분석 워크스페이스로 전송되는 데이터 예시로는 Cosmos DB(NoSQL 데이터베이스)에서 활성화된 CDBDataPlaneRequests 테이블이 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n해당 테이블에서 어떤 유용한 데이터를 얻을 수 있을까요?\n\n![Table Screenshot](/TIL/assets/img/2024-07-12-HowtoQueryLogAnalyticsWorkspaceDataUsingPython_0.png)\n\n이는 전체 테이블 중 일부에 불과합니다. 실제로 Cosmos DB에서 사용할 수 있는 테이블은 더 많습니다. 더불어, 모든 Azure 리소스를 위한 가능한 모든 테이블을 상상해보세요!\n\n일반적으로 Azure 리소스에서 로그를 전송할 수 있는 기능은 \"진단 설정(diagnostic settings)\"이며, 데이터는 테이블 형식으로 전송됩니다. 진단 설정에 대한 자세한 내용은 여기에서 확인해주세요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모든 그 귀중한 데이터를 활용할 수 있게 되면 아마도 즉시 분석을 수행할 수 있어서 설레일 것입니다. 다른 말로 하면, \"데이터 과학\".\n\n로그 분석 워크스페이스에 프로그래밍 방식으로 액세스하면 데이터로 수행 가능한 작업은 무궁무진합니다. Python Jupyter 노트북에서 데이터를 쉽게 분석할 수도 있고요.\n\n이것의 제한을 궁금해하시나요? 이 설명서를 즐겨찾기에 추가해주세요.\n\n이제 세부 사항에 대해 깊이 파고들어볼까요?\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 사전 준비 사항 📚\n\n![이미지](/TIL/assets/img/2024-07-12-HowtoQueryLogAnalyticsWorkspaceDataUsingPython_1.png)\n\n이 글을 처음부터 끝까지 따라하고 싶다면 이 사항을 준비해주세요:\n\n- Visual Studio Code (VS Code)를 사용하는 IDE (VS Code에 특화된 확장 프로그램을 사용할 것입니다)\n- Python의 기본 지식\n- azure-identity, azure-monitor-query, pandas 등의 비기본 라이브러리가 설치된 Python 환경\n- 로그를 보내는 기존의 Log Analytics 워크스페이스\n- [선택 사항] 가능하다면 진단 설정 로그를 Log Analytics 워크스페이스로 보내기 위한 Cosmos DB 계정이 있어야 합니다. 저의 스크립트는 이에 기반합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지금은 로그 분석 워크스페이스에서 데이터를 검색하는 Python 스크립트를 확인해 봅시다.\n\n# 솔루션 💯\n\n<img src=\"/TIL/assets/img/2024-07-12-HowtoQueryLogAnalyticsWorkspaceDataUsingPython_2.png\" />\n\n이 섹션에서는 샘플 Python 스크립트를 부분별로 분해합니다. 모든 부분을 이해한 후에 모두 조합해도 괜찮습니다(부분은 위에서 아래로 순서대로 나열되어 있습니다)!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## [1] 필요한 라이브러리 가져오기\n\n이미 해당 Python 라이브러리들이 없는 경우에는 설치해야 할 수도 있습니다: azure-identity, azure-monitor-query, pandas\n\n```js\nimport os\nimport pandas as pd\nfrom datetime import datetime, timezone\nfrom azure.monitor.query import LogsQueryClient, LogsQueryStatus\nfrom azure.identity import DefaultAzureCredential\nfrom azure.core.exceptions import HttpResponseError\n```\n\n## [2] 스크립트에 필요한 클라이언트 초기화하기\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리는이 스크립트를위한 두 개의 별개의 클라이언트를 시작해야합니다. 간단함을 위해 동기 클라이언트를 선택하겠습니다:\n\n```js\n# 필요한 클라이언트 생성 (동기, 공용 클라우드)\ncredential = DefaultAzureCredential()\nclient = LogsQueryClient(credential)\n```\n\nDefaultAzureCredential() 클래스를 이해하는 데 어려움이 있는 경우 이 설명서를 읽어보십시오.\n\n## [3] Log Analytics 워크스페이스 ID 정의\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nLog Analytics 워크 스페이스 ID를 얻으려면 Azure Portal로 이동하여 'Log Analytics 워크 스페이스 - 개요'로 이동하면 됩니다. 예시:\n\n![이미지](/TIL/assets/img/2024-07-12-HowtoQueryLogAnalyticsWorkspaceDataUsingPython_3.png)\n\n![이미지](/TIL/assets/img/2024-07-12-HowtoQueryLogAnalyticsWorkspaceDataUsingPython_4.png)\n\n```js\n# 로그 분석 워크 스페이스 ID를 정의합니다\nLA_WORKSPACE_ID = \"<당신의-로그-분석-워크 스페이스-ID>\"\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## [4] 쿼리 정의\n\n로그 분석 워크스페이스에서 데이터를 가져오는 쿼리는 Kusto Query Language (KQL) 형식으로 작성됩니다. 특정 예시에서는 Cosmos DB와 관련된 로그를 확인하고 있습니다:\n\n```js\n# 쿼리 정의 (Kusto Query Language)\nquery = \"\"\"\nCDBDataPlaneRequests \n| where AccountName == toupper('al-nosql')\n| where TimeGenerated > ago(2h)\n| take 10\n\"\"\"\n```\n\nAzure 자원이 전송한 로그에 적합한 쿼리로 위의 쿼리를 자유롭게 수정해보세요. 대부분의 Azure 자원에 대해 동작하는 매우 일반적인 쿼리는 다음과 유사합니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\r\n\"\"\"\nAzureDiagnostics\n| take 1\n\"\"\"\r\n```\n\n## [5] 쿼리의 시간 범위를 정의하세요 (선택 사항)\n\n쿼리의 시간 범위를 KQL 쿼리 내에서도 정의할 수 있는 옵션이 있음을 유의해주세요 (3단계에서 설명됨).\n\n본 문서를 위해, 사용자의 쿼리가 너무 비싼 비용이 들지 않도록 고려하여 클라이언트를 초기화할 때 상대적으로 작은 시간 범위를 강제로 적용하도록 해둡니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\n# 쿼리를 위한 시간 범위 정의 (위의 쿼리에서도 이를 정의할 수 있음)\nstart_time=datetime(2024,2,25, tzinfo=timezone.utc)\nend_time=datetime(2024, 2, 26, tzinfo=timezone.utc)\n```\n\n## [6] Log Analytics 작업 영역에서 쿼리하세요!\n\n이제 Log Analytics 작업 영역에서 모든 흥미로운 데이터를 가져오는 시간입니다.\n\n아래 코드에 오류 처리가 추가되었음을 주목하고 Pandas 데이터프레임을 표시할 것임을 확인하세요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ntry:\n    response = client.query_workspace(\n        workspace_id=LA_WORKSPACE_ID,\n        query=query,\n        timespan=(start_time, end_time)\n        )\n    if response.status == LogsQueryStatus.PARTIAL:\n        error = response.partial_error\n        data = response.partial_data\n        print(data)\n    elif response.status == LogsQueryStatus.SUCCESS:\n        data = response.tables\n    for table in data:\n        df = pd.DataFrame(data=table.rows, columns=table.columns)\n        print(df)\nexcept HttpResponseError as err:\n    print(f\"Encountered error: {err}\")\n```\n\n하지만 많은 열이 있는 경우 인쇄된 데이터 프레임이 모든 내용을 표시하지 않을 수 있음을 알 수 있습니다. 더 나쁜 점은 즉각적인 분석을 위해 예쁘고 조직적으로 보이지 않는다는 것입니다.\n\n아마도 CSV로 데이터 프레임을 보내보는 게 좋을 수 있습니다. : )\n\n## [7] 데이터를 CSV 파일로 전송\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nCSV 파일을 사용하면 적어도 Microsoft Excel/Google Sheets 스프레드시트로 가져올 수 있는 등 재미있는 일을 할 수 있어요.\n\n아래 코드 조각에서 CSV 파일 경로를 정의해주세요:\n\n```js\n# 데이터프레임을 csv로 내보내기\ncsv_filename = \"<원하는-경로>/output.csv\"\ndf.to_csv(csv_filename)\n```\n\n## [보너스] VS Code 확장 기능을 사용하여 멋진 형식의 테이블을 볼 수도 있어요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n좋은 소식은 몇 가지 변경만으로 Jupyter 노트북을 활용할 수 있다는 것입니다.\n\n1. 우선, 스크립트 확장자를 \".ipynb\"로 변경하세요:\n\n![Change your script extension to \".ipynb\"](https://yourwebsite.com/TIL/assets/img/2024-07-12-HowtoQueryLogAnalyticsWorkspaceDataUsingPython_5.png)\n\n2. VS Code에서 Jupyter 노트북을 실행할 수 있도록 필요한 확장 프로그램/패키지를 설치하세요. 처음으로 노트북을 실행하려고 시도하면 아래 항목을 설치하라는 메시지가 자동으로 표시됩니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 파이썬 확장\n\n- 주피터 확장\n\n- ipykernel 패키지\n\n![image](/TIL/assets/img/2024-07-12-HowtoQueryLogAnalyticsWorkspaceDataUsingPython_6.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nVS Code를 설치한 후에는 VS Code를 다시 로드해주세요.\n\n[3] 위의 모든 것들을 설치한 후에는 VS Code에서 Jupyter Notebook을 실행할 수 있어야 합니다! 그러나 실행하면 출력물이 잘못 서식이 지정된 것을 볼 수 있습니다 (아래 스크린샷이 잘린 상태로 표시됨):\n\n![screenshot](/TIL/assets/img/2024-07-12-HowtoQueryLogAnalyticsWorkspaceDataUsingPython_7.png)\n\n[4] Jupyter 노트북의 오른쪽 상단 어딘가에서 \"Variables\" 탭을 클릭하세요:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![이미지](/TIL/assets/img/2024-07-12-HowtoQueryLogAnalyticsWorkspaceDataUsingPython_8.png)\n\n[5] 터미널에 새 탭이 생성됩니다. \"JUPYTER: VARIABLES\"라고 표시된 탭을 찾아 \"df\" 변수를 찾은 다음, 사각형 기호 위로 커서를 가져가면 \"데이터 뷰어에 변수 표시\"라는 메시지가 표시됩니다. 이것을 클릭하세요.\n\n![이미지](/TIL/assets/img/2024-07-12-HowtoQueryLogAnalyticsWorkspaceDataUsingPython_9.png)\n\n[6] 그러면 이전에 찾고 있던 완벽하게 표시된 결과를 보여주는 새 탭이 열립니다:\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 배운 점 👊\n\n![image](/TIL/assets/img/2024-07-12-HowtoQueryLogAnalyticsWorkspaceDataUsingPython_10.png)\n\n만약 지금까지 이 글을 주의 깊게 따라오셨다면 다음 개념들을 배우셨을 것입니다:\n\n- Log Analytics 워크스페이스를 쿼리하는 데 필요한 필수 Python 라이브러리 파악\n- 필요한 Python 클라이언트 파악\n- KQL 및 효율적인 쿼리를 작성하는 데 최선의 방법에 대한 고수준 이해\n- 무엇보다 중요한 것은 Python을 사용하여 Log Analytics 워크스페이스를 쿼리하고 VS Code에서 멋지게 표 형식으로 결과를 표시하는 방법\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 다음 스텝 🤔\n\n![image](/TIL/assets/img/2024-07-12-HowtoQueryLogAnalyticsWorkspaceDataUsingPython_11.png)\n\n이 글에 대한 궁금한 점이나 피드백이 있다면 댓글로 남겨주세요 (네, 댓글을 확인해요). 또한 쓸 주제에 대한 제안도 환영합니다.\n\n제가 하는 일이 궁금하다면 아래 링크를 확인해보세요:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 내 개인 웹사이트\n- LinkedIn에서 연락하세요\n- 내 Fiverr 서비스를 확인하세요\n- 커피 한 잔 사주세요\n\n다음에 또 뵙겠습니다!\n\n# 간단한 영어로 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 작가를 칭찬하고 팔로우하는 것 잊지 마세요! 👏️️\r\n- 저희를 팔로우하세요: X | LinkedIn | YouTube | Discord | 뉴스레터\r\n- 다른 플랫폼에서 더 많은 콘텐츠를 즐길 수 있어요: Stackademic | CoFeed | Venture | Cubed\r\n- 더 많은 콘텐츠: PlainEnglish.io","ogImage":{"url":"/TIL/assets/img/2024-07-12-HowtoQueryLogAnalyticsWorkspaceDataUsingPython_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-HowtoQueryLogAnalyticsWorkspaceDataUsingPython_0.png","tag":["Tech"],"readingTime":13},{"title":"RAG 설정에서 기본 및 고급 검색 기능을 통해 Gemma 2B 종합 평가하기","description":"","date":"2024-07-12 19:58","slug":"2024-07-12-ComprehensiveEvaluationofGemma2BinaRAGsetupwithBasicandAdvancedRetrievers","content":"\n\n![image](/TIL/assets/img/2024-07-12-ComprehensiveEvaluationofGemma2BinaRAGsetupwithBasicandAdvancedRetrievers_0.png)\n\n몇 주 전에 Google은 Gemma 언어 모델을 소개했습니다. 두 가지 크기의 경량 모델, Gemma 2B와 7B가 있습니다. 이러한 모델들은 다른 오픈 소스 모델과 비교했을 때 해당 크기에 대해 최고 수준의 성능을 달성한다고 주장됩니다. 이 모델들은 주로 소비자급 장치를 대상으로 하고 있습니다. Google의 테스트에서도, 특정 주요 성능 기준에서 Gemma가 일부 더 큰 모델들을 크게 능가했음이 확인되었습니다. 그 결과는 그림 1에서 확인할 수 있습니다.\n\n![image](/TIL/assets/img/2024-07-12-ComprehensiveEvaluationofGemma2BinaRAGsetupwithBasicandAdvancedRetrievers_1.png)\n\n이 기사에서는 Gemma 2B를 검색 보강 생성(RAG) 설정에서 사용하여, 모델이 훈련 중에 본 적이 없는 문서에 대한 질문-응답에 활용할 것입니다. RAG는 모델의 응답을 향상시키는 프로세스로, 훈련 데이터 외부의 권위 있는 지식 소스를 활용합니다. 검색 시스템은 관련 문서 스니펫을 검색하여 Gemma가 생성에 영향을 미치기 위한 컨텍스트로 사용할 것입니다. 우리는 어떻게 Gemma가 기본 검색기와 고급 검색기로부터 컨텍스트를 활용하는지 다양한 성능 각도에서 평가할 것입니다. 또한, 해당 성능은 제한된 자원 시스템을 위한 또 다른 LLM로, TinyLlama 1.1B와 비교될 것입니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 목차\n1.0 환경 설정\n2.0 디자인 및 구현\n   2.1 모듈 LoadVectorize\n   2.2 모듈 LLMPerfMonitor\n   2.3 주요 모듈\n3.0 초기 테스트\n   3.1 젬마 2B 대 TinyLlama 1.1B의 응답 정확도\n4.0 앙상블 리트리버 구동된 RAG\n   4.1 고급 리트리버와 함께 젬마 vs TinyLlama의 성능 비교\n5.0 최종 생각\n\n# 1.0 환경 설정\n\n이 실험은 MacBook Air M1(8GB RAM)에서 진행됩니다. 여기서 사용되는 Python 버전은 3.10.5입니다. 먼저 이 프로젝트를 관리하기 위해 가상 환경을 생성해 보겠습니다. 환경을 생성하고 활성화하려면 다음을 실행하세요:\n\n```js\npython3.10 -m venv mychat\nsource mychat/bin/activate\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 필요한 모든 라이브러리를 설치할 수 있습니다:\n\n```js\npip install langchain faiss-cpu sentence-transformers flask-sqlalchemy psutil unstructured pdf2image unstructured_inference pillow_heif opencv-python pikepdf pypdf\nCMAKE_ARGS=\"-DLLAMA_METAL=on\" FORCE_CMAKE=1 pip install --upgrade --force-reinstall llama-cpp-python --no-cache-dir\n```\n\n위의 두 번째 줄은 Metal 지원이 포함된 llama-cpp-python 라이브러리를 설치하는 것입니다. 이 라이브러리는 M1 프로세서에서 하드웨어 가속을 이용하여 LLM을 불러오는 데 사용될 것입니다. Metal을 사용하면 계산이 GPU에서 실행됩니다.\n\n환경이 준비되었으니 우리의 RAG 시스템 설계 및 구현을 살펴보겠습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 2.0 디자인 및 구현\n\n이 QA 시스템에는 그림 2에 설명된 세 가지 모듈이 있습니다.\n\n![모듈](/TIL/assets/img/2024-07-12-ComprehensiveEvaluationofGemma2BinaRAGsetupwithBasicandAdvancedRetrievers_2.png)\n\n이 다이어그램에서 강조된 두 구성 요소는 이 기사의 후반에서 성능 향상을 위해 다시 다룰 예정입니다. 각 모듈의 역할은 다음과 같습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 왼쪽에 있는 첫 번째 모듈은 온라인 PDF 문서를 로드하고 벡터화하는 과정을 포함합니다.\n- 오른쪽에 있는 더 작은 모듈은 보조 모듈 역할을 합니다. 이 모듈은 코사인 유사도를 계산하고 모델 응답 시간을 평가함으로써 일련의 질문을 통해 시스템 성능을 객관적으로 측정할 수 있도록 도와줍니다. 또한 시스템 메모리 사용량도 측정합니다.\n- 중앙에 있는 주요 모듈은 LLM을 로드하고 FAISS 리트리버를 인스턴스화한 뒤, LLM, 리트리버 및 사용자 정의 프롬프트를 포함하는 리트리버 체인을 생성하는 것을 포함합니다.\n\n이제 주요 구현 결정 사항과 코드를 자세히 살펴보겠습니다.\n\n## 2.1 모듈 LoadVectorize\n\n이 모듈은 다음과 같이 3가지 함수로 구성됩니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- load_doc 함수는 온라인 PDF 문서를 로드하는 데 사용되며, 처음에는 100자씩 청크로 분할하고 20자의 오버랩이 있는 문서 목록을 반환합니다.\n- vectorize 함수는 위 load_doc 함수를 호출하여 문서의 청크 목록을 가져와 임베딩을 생성하고 opdf_index라는 로컬 디렉토리에 커밋하며 FAISS 객체를 반환합니다.\n- load_db 함수는 opdf_index 디렉토리 내에 FAISS vectorstore가 있는지 확인하고 로드를 시도합니다. 그렇지 않은 경우 이전 함수 vectorize를 호출하여 문서를 로드하고 벡터화합니다. 마지막으로 FAISS 객체를 반환합니다.\n\n이 모듈은 이전 작업 [2]에서 소개되었으며 초기에 여기서 그대로 사용되었습니다.\n\n## 2.2 Module LLMPerfMonitor\n\n이 모듈은 또한 3개의 함수로 구성됩니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 함수 get_questions_answers은 디스크에있는 파일에서 질문 목록과 예상 답변을 읽습니다. 이러한 답변은 모델의 반환된 응답과 함께 사용되어 코사인 유사성을 계산하는 데 사용됩니다.\n- 함수 calc_similarity은 두 개의 문자열 인수를 허용합니다. 두 문자열은 초기에 텐서 임베딩으로 변환됩니다. 그런 다음 sentence_transformers의 util.pytorch_cos_sim 함수가 모든 i와 j에 대해 코사인 유사성 cos_sim(a[i], b[j])을 계산합니다. 문장이 의미적으로 매우 유사하면 코사인 유사성은 1에 가까울 것입니다. 그들이 정반대라면, 이 값은 이상적으로 0에 가까워야 합니다.\n- 함수 get_mem_cpu_util은 부모 프로세스 ID(ppid)를 인자로 사용하여 psutil을 사용하여 해당 메모리 사용량 (물리적 RAM 사용량을 나타냄)을 구합니다.\n\n이 모듈의 전체 코드 목록은 아래에 표시되어 있습니다.\n\n```python\n# LLMPermMonitor.py\n\nfrom sentence_transformers import SentenceTransformer, util\nimport os, psutil\n\nimport nltk\nfrom nltk.translate import meteor\nfrom nltk import word_tokenize\n\ndef get_questions_answers() -> list[str]:\n    # 질문과 답변이 교차된 목록을 반환합니다.\n    with open(\"sh_qa_list.txt\") as qfile:\n        lines = [line.rstrip()[3:] for line in qfile]\n    return lines\n\ndef calc_similarity(sent1, sent2) -> float:\n    # 임베딩을 생성하고 코사인 유사성을 계산하여 값을 반환합니다.\n    model = SentenceTransformer('sentence-transformers/all-MiniLM-L6-v2')\n    # 두 문자열에 대한 임베딩 계산\n    embedding_1 = model.encode(sent1, convert_to_tensor=True)\n    embedding_2 = model.encode(sent2, convert_to_tensor=True)\n    return util.pytorch_cos_sim(embedding_1, embedding_2).item()\n\ndef get_mem_cpu_util(ppid) -> tuple[float, float]:\n    # RSS를 GB로 수집하고 총 CPU 이용률을 반환합니다.\n    process = psutil.Process(ppid)  # 부모 프로세스 반환\n    mem_usage = process.memory_info().rss / 1024 ** 3  # GB 단위로                                                                                                                                   \n    cpu_usage = sum(psutil.cpu_percent(percpu=True))\n    return mem_usage, cpu_usage\n```\n\n## 2.3 주요 모듈\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n주요 모듈은 주로 QA 파이프라인을 정의하는 데 관여합니다. 또한 이 앱의 리소스 사용 추적을 용이하게하기 위해 별도의 스레드에서 수행될 때에만 가능합니다. 따라서 본 모듈은 메인 스레드가 전체 LangChain 파이프라인을 수행하고, 단일 자식 스레드가 일정 간격으로 부모의 통계를 수집하고 공유 데이터 구조에 저장하는 간단한 멀티 스레드 시스템을 가능하게 합니다. 이러한 병렬 처리 설계를 캡처한 스레드 다이어그램은 Figure 3에 나와 있습니다.\n\n![Thread Diagram](/TIL/assets/img/2024-07-12-ComprehensiveEvaluationofGemma2BinaRAGsetupwithBasicandAdvancedRetrievers_3.png)\n\n부모는 자신의 pid, 리스트 객체인 공유 데이터 구조 및 스레딩 이벤트 객체를 사용하여 자식을 생성합니다. 이벤트 객체는 자식이 종료할 때를 결정하는 데 사용됩니다. 자식이 작동 중일 때, 1초 간격으로 메모리 및 CPU 사용량을 수집하고 이를 리스트인 shared_list에 저장합니다. 부모는 각 쿼리에 대해 QA 체인을 실행하고, 자식이 수집한 데이터를 사용하여 통계를 계산합니다. 부모가 모든 질문을 실행한 후, 이벤트 객체를 설정하고 자식이 종료될 때까지 기다립니다. 자식이 이벤트가 설정된 것을 확인하면, 1초 내에 가장 길게 while 루프를 종료하고 부모도 종료됩니다.\n\nQA 파이프라인의 경우, 이 모듈은 우선 Gemma에 대한 프롬프트 템플릿을 다음 템플릿으로 정의합니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n`bos``start_of_turn`user\n'context'\n'question'`end_of_turn`\n`start_of_turn`model\n\nLLM 메모리 풋프린트를 더 줄이기 위해 lmstudio-ai의 HuggingFace repo [3]의 Gemma의 양자화된 버전을 채택할 예정입니다. 양자화된 모델은 모델 파라미터에 더 적은 비트를 사용합니다. 양자화된 LLM을 GGUF 형식으로 로드하기 위해서는 LlamaCpp가 사용됩니다. LoadVectorize 모듈에서 반환된 FAISS 객체를 사용하여 FAISS 검색기가 초기 테스트를 위한 기본 검색기로 생성됩니다. 위의 객체를 사용하여 RetrievalQA 체인이 인스턴스화되며, 질의에 사용됩니다.\n\n주요 모듈의 전체 목록은 다음과 같습니다.\n\n```js\n# main.py\n\nfrom langchain.chains import RetrievalQA\nfrom langchain.prompts import PromptTemplate\nfrom langchain_community.llms import LlamaCpp\nfrom langchain_community.embeddings import HuggingFaceEmbeddings                                                                                                                                 \nimport LoadVectorize\nimport LLMPerfMonitor\nimport threading                                                                                                                          \nimport os\nimport time\nimport timeit\n\n# 자식 작업\ndef monitor_thread(event, ppid, shared_list):\n    while not event.is_set():\n        mem,cpu = LLMPerfMonitor.get_mem_cpu_util(ppid)  # 스레드의 이벤트 루프에서 비동기 작업 실행\n        shared_list += [mem,cpu]\n        time.sleep(1)\n\ndef main():\n    event = threading.Event()  # 이벤트 개체 생성\n    shared_list = []  # 공유 큐 객체 생성\n    child = threading.Thread(target=monitor_thread, args=(event,os.getpid(),shared_list))\n    child.start()\n\n    # 검색기 생성\n    db = LoadVectorize.load_db()\n    faiss_retriever = db.as_retriever(search_type=\"mmr\", search_kwargs={'fetch_k': 3}, max_tokens_limit=1000)\n\n    # 질문과 답변 목록\n    qa_list = LLMPerfMonitor.get_questions_answers()\n\n    # 프롬프트 템플릿 \n    qa_template = \"\"\"\n    <bos><start_of_turn>user\n    {context}\n    {question}<end_of_turn>\n    <start_of_turn>model\n    \"\"\"\n\n    # 프롬프트 인스턴스 생성\n    QA_PROMPT = PromptTemplate.from_template(qa_template)\n\n    llm = LlamaCpp(\n        model_path=\"./models/gemma_2b/gemma-2b-it-q4_k_m.gguf\",\n        temperature=0.01,\n        max_tokens=2000,\n        top_p=1,\n        verbose=False,\n        n_ctx=2048\n    )\n    # 사용자 정의 QA 체인 \n    qa_chain = RetrievalQA.from_chain_type(\n        llm,\n        retriever=faiss_retriever,\n        chain_type_kwargs={\"prompt\": QA_PROMPT}\n    )\n    print('model;question;cosine;resp_time;memory_util;cpu_util')\n    # 질문, 통계 계산 루프\n    for i,query in enumerate(qa_list[::2]):\n        start = timeit.default_timer()\n        result = qa_chain({\"query\": query})\n        time = timeit.default_timer() - start # 초\n        avg_mem = sum(shared_list[::2])/len(shared_list[::2])\n        #avg_cpu = sum(shared_list[1::2])/len(shared_list[1::2])\n        shared_list.clear()\n        cos_sim = LLMPerfMonitor.calc_similarity(qa_list[i*2+1],result[\"result\"])\n        print(f'gemma_2b;Q{i+1};{cos_sim:.5};{time:.2f};{avg_mem:.2f};{avg_cpu:.2f}')\n\n    event.set()  # 자식 스레드가 종료되도록 이벤트를 설정합니다\n    child.join()  # 자식 스레드가 종료될 때까지 대기\n\nif __name__ == \"__main__\":\n    main()\n```\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nTinyLlama에 대해서는 동일한 시스템 아키텍처가 채택될 것입니다. 또한, 소수의 코드 변경이 필요한 유일한 모듈은 주 모듈이며, 여기서 LlamaCpp의 인스턴스 속성인 module_path와 변수 qa_template이 유일한 차이점입니다.\n\n# 3.0 초기 테스트\n\n우리의 초기 테스트에서는 청크 크기와 중첩 매개변수를 변경하여 테스트 머신에서 최상의 정확도를 제공하는 최적의 구성을 결정합니다. 텍스트 분할기가 벡터화 단계의 일부로 사용하는 청크 크기는 100, 250, 500, 750부터 1,000 자까지 다양하게 변경되었습니다. 중첩 매개변수는 항상 청크 크기의 20%로 유지되었습니다. 각 청크 크기에 대해 RAG 시스템은 10가지 다른 질문에 대해 테스트되었습니다. 응답 정확도 측면에서, 청크 크기 500이 가장 우수한 결과를 반환했습니다.\n\n예를 들어, 다음은 8번째 질문이었습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음은 LLM이 청크 크기 100에서의 응답이었으나, 이는 올바르지 않습니다:\n\n그리고 청크 크기 500에서, 이 LLM의 응답은 아래와 같았습니다:\n\n이것이 올바른 답입니다! 이는 지난 시간 여러 다른 모델들에게 (현재 연구의 일부가 아님) 동일한 질문이 제기되었을 때 그들이 전혀 성공하지 못한 반면, 젬마에게 큰 승리로 이어집니다.\n\n게다가, 이 시스템은 벡터화 구성에서 평균 응답 시간도 가장 낮았습니다. 그림 4에서 보이는 바와 같이, 이 그래프는 95% 신뢰 구간과 함께 표시되었습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 실험 결과를 바탕으로, 청크 크기 500과 해당하는 겹침 크기 100이 이후 모든 테스트에 채택되었습니다.\n\n이러한 매개변수가 변할 때 벡터 공간 속성의 변경을 표시하기 위해, 그림 5는 라이브러리 renumics-spotlight를 사용하여 임베딩 시각화를 보여줍니다. 이 시각화에 관심 있는 분들이나 이를 작성하는 방법을 알아보고 싶은 분들은 우리의 이전 작업을 확인해보세요. [2].\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 내용을 변경하면 벡터 공간에 상당한 영향을 미친다는 것이 분명하다. 왼쪽에서는 100자의 청크 크기를 사용하면, 임베딩이 몇 개의 이상치를 가진 단일 밀집 클러스터처럼 보입니다. 반면에 다른 끝에서 1,000자의 청크 크기를 사용하면, 여전히 단일 클러스터로 보이지만 지역 밀도가 다양하고 각 벡터마다 다른 가장 가까운 이웃들이 있을 것으로 예상됩니다.\n\n## 3.1 젬마 2B 대화모델 대 티니람마 1.1B 대화모델 응답 정확도\n\n이 첫 번째 성능 비교에서, 우리는 그들의 응답 정확도를 살펴볼 것입니다. 다음은 사용된 질문 중 하나와 해당하는 기대되는 답변입니다:\n\n젬마 LLM은 다음과 같이 응답했습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n작은라마 LLM은 다음과 같이 응답했습니다:\n\n두 모델 모두 정확한 응답을 내놨습니다! 다음으로 제시된 또 다른 질문은 다음과 같습니다:\n\n이 경우, Gemma는 주어진 맥락으로 대답할 수 없다고 응답했으며 아래와 같이 나와 있습니다:\n\n반면에, TinyLlama는 동일한 맥락으로 응답을 제공할 수 있었지만 응답은 부분적으로 부정확했습니다. 아래에서 확인할 수 있습니다 (일부 추출; 포인트 2가 잘못됨):\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n더 넓은 성능 비교를 진행하기 전에, 먼저 검색 성능을 향상시키는 것을 살펴보겠습니다.\n\n# 4.0 RAG 앙상블 리트리버로 구성된\n\nLangChain은 EnsembleRetriever라는 고급 리트리버를 보유하고 있습니다. 이 리트리버는 리트리버 목록을 입력으로 받아 앙상블하고 결과를 재정렬하여 RAG 성능을 향상시킵니다. FAISS와 BM25 리트리버의 장점을 3:7 비율로 이용하여 이전 작업[4]에서 최상의 응답 정확도를 달성했습니다.\n\n그림 2에 나와 있는 동일한 시스템 아키텍처를 사용하면, 이 고급 리트리버에 맞추기 위해 LoadVectorize 모듈과 메인 모듈을 약간 수정해야 합니다. LoadVectorize 모듈의 vectorize 함수에는 BM25 리트리버를 인스턴스화하는 새로운 단계가 포함될 것입니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\ndef vectorize(embeddings) -> tuple[FAISS, BM25Retriever]:\n    docs = load_doc()\n    db = FAISS.from_documents(docs, embeddings)\n    db.save_local(\"./opdf_index\")\n    bm25_retriever = BM25Retriever.from_documents(docs)         <<<<<\n    bm25_retriever.k = 5                                        <<<<<\n    return db, bm25_retriever\n```\n\n주요 모듈 내에서 EnsembleRetriever를 인스턴스화하는 라인은 아래와 같이 추가됩니다:\n\n```python\n    db, bm25_r = LoadVectorize.load_db()\n    faiss_retriever = db.as_retriever(search_type=\"mmr\", search_kwargs={'fetch_k': 3}, max_tokens_limit=1000)\n    r = 0.3\n    ensemble_retriever = EnsembleRetriever(retrievers=[bm25_r, faiss_retriever], weights=[r, 1-r])\n```\n\n이 앙상블 검색기는 이후 QA 체인에서 사용될 것입니다. 이 QA 시스템이 EnsembleRetriever를 사용하도록 변경하는 데 필요한 변경점은 여기까지입니다.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n해당 시스템의 모든 코드에는 GitHub의 다음 저장소에서 확인할 수 있습니다:\n\n이제 Gemma와 TinyLlama 간의 보다 포괄적인 성능 비교를 살펴보려고 합니다.\n\n## 4.1 Gemma 대 TinyLlama 성능 비교 (고급 리트리버 사용)\n\n본 비교 실험에서는 같은 10가지 질문을 고급 리트리버를 이용하여 동일하게 Gemma 2B와 TinyLlama 1.1B에 제시하고, 성능 비교를 위해 이들의 응답 정확도, 응답 시간, 메모리 사용 및 CPU 이용률을 기록할 것입니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nGemma가 FAISS 리트리버에서의 컨텍스트로 급유되었을 때, 제6번 질문에 대한 응답을 제공하지 못했습니다. 하지만 앙상블 리트리버로 구동된 Gemma가 다음과 같이 응답했습니다:\n\n정확한 답변입니다! 이 모델이 향상된 유일한 질문은 아닙니다. Gemma의 응답 정확도가 4개에서 8개로 두 배로 증가했습니다. 반면에 TinyLlama의 정확한 응답률은 3개에서 5개로 증가했습니다.\n\n간접적으로 응답 정확도를 파악하기 위해, 그림 6은 모든 질문에 대한 LLMs 간의 코사인 유사도를 사용하여 샘플 답변에 대한 트리맵 차트를 보여줍니다. 답변이 잘못되었더라도 선택된 단어 때문에 높은 유사도 값이 있을 수 있으니 주의해야 합니다. 이 결과를 나타내기 위해 트리맵을 채택했습니다. 이 데이터에는 내재된 계층 구조가 있으며, 차트에서 직사각형의 면적과 색상 음영을 사용하여 선택한 측정 항목의 크기를 구별할 수 있습니다. 이 차트에서 Gemma는 더 어두운 음영의 사각형이 많고, 심지어 LLM 수준에서도 더 짙은 파란색 음영을 갖고 있습니다. 이는 Gemma가 TinyLlama보다 더 높은 응답 정확도를 자랑한다는 것을 의미합니다.\n\n<img src=\"/TIL/assets/img/2024-07-12-ComprehensiveEvaluationofGemma2BinaRAGsetupwithBasicandAdvancedRetrievers_6.png\" />\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nLLM의 응답 시간을 비교하기 위해 Treemap이 그림 7에 표시되어 있습니다. 거의 모든 TinyLlama 질문 사각형이 연하게 그려져 있어요. 평균적으로 Gemma는 TinyLlama에 비해 질문에 대한 응답이 1.5배 더 오래 걸렸어요. TinyLlama가 크기적으로 더 작은 모델이기 때문에 빠르게 응답할 것으로 예상됩니다.\n\n![Figure 7](/TIL/assets/img/2024-07-12-ComprehensiveEvaluationofGemma2BinaRAGsetupwithBasicandAdvancedRetrievers_7.png)\n\n그림 8에서 Gemma와 TinyLlama의 메모리 사용량이 나타나 있어요. 여기서 더 짙은 색이 낮은 메모리 사용을 나타내요. 앞과 마찬가지로, TinyLlama가 1.1B 모델인 반면 Gemma 2B와 비교했을 때, 전자가 더 낮은 메모리 사용량을 갖고 있어요.\n\n![Figure 8](/TIL/assets/img/2024-07-12-ComprehensiveEvaluationofGemma2BinaRAGsetupwithBasicandAdvancedRetrievers_8.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n요약하자면, Gemma 2B는 뛰어난 응답 정확도를 자랑하며, EnsembleRetriever와 같은 고급 retriever를 사용함으로써 더욱 향상되었습니다. TinyLlama와 비교했을 때, Gemma는 메모리 풋프린트가 16% 크고, 평균 14초 추가 지연이 있지만, 합리적으로 보입니다.\n\n# 5.0 최종 결론\n\n작년 후반부터 오픈소스 대형 언어 모델은 정확도에서 거대한 발전을 이루었습니다. 이러한 모델이 내부 문서에 훈련되어 있지 않더라도, Retrieval-Augmented Generation (RAG) 설정에서 그들의 능력을 활용할 수 있습니다. 그러나 자원이 제한된 환경에서 대형 모델을 실행하는 것은 불가능합니다. TinyLlama 1.1B는 이 분야에서 유망한 모델 중 하나입니다.\n\n이 기사에서는 Gemma 2B에 대해 포괄적으로 살펴보았습니다. RAG 설정에서 ensemble retriever와 결합되었을 때, 이 모델은 최근 문서에 대한 질문에 대해 80% 이상의 정확한 답변을 제공하는 것으로 입증되었으며, 이는 TinyLlama보다 33% 우수한 성과를 보여주었습니다. 이 개선은 메모리 풋프린트가 16% 크고 응답 지연이 1.5배 길어진 비용이 들지만, 합리적인 대가로 보입니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위 내용을 읽어 주셔서 감사합니다!\n\n참고 자료\n1. Gemma: Google DeepMind의 Gemini 연구 및 기술에 기반한 개방 모델\n2. RAG 성능에 미치는 FAISS 벡터 공간의 영향을 이해하기 위한 시각화\n3. https://huggingface.co/lmstudio-ai/gemma-2b-it-GGUF\n4. Ensembled Retriever에서 Context를 사용하여 Mistral 7B를 이용한 내부 문서 쿼리하기","ogImage":{"url":"/TIL/assets/img/2024-07-12-ComprehensiveEvaluationofGemma2BinaRAGsetupwithBasicandAdvancedRetrievers_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-ComprehensiveEvaluationofGemma2BinaRAGsetupwithBasicandAdvancedRetrievers_0.png","tag":["Tech"],"readingTime":20}],"page":"12","totalPageCount":33,"totalPageGroupCount":2,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}