{"pageProps":{"posts":[{"title":"파이썬 해시 테이블 구현 방법 단계별 설명","description":"","date":"2024-07-07 12:53","slug":"2024-07-07-ImplementingaHashTableinPythonStep-by-Step","content":"\n<img src=\"/TIL/assets/img/2024-07-07-ImplementingaHashTableinPythonStep-by-Step_0.png\" />\n\n# 1. 소개\n\n해시 테이블은 소프트웨어 개발에서 효율적인 데이터 저장 및 검색의 기초입니다. 고유한 키를 통해 데이터에 빠르게 액세스할 수 있도록 함으로써, 해시 테이블은 높은 속도로 조회, 삽입 및 삭제를 가능케 하여, 데이터베이스 인덱싱 및 캐싱 솔루션과 같이 성능이 중요한 시나리오에서 필수적입니다.\n\n해시 테이블의 본질은 해싱 메커니즘에 있습니다. 이 메커니즘은 해시 함수를 사용하여 키를 배열 인덱스로 변환합니다. 선택된 인덱스는 배열에 해당 값이 저장되는 위치를 결정합니다. 이 함수가 키를 배열 전체에 균일하게 분산시키고 이중 해싱(double hashing) 및 제곱 프로빙(quadratic probing)과 같은 고급 충돌 해결 기술을 사용함으로써, 해시 테이블은 충돌을 최소화하고 데이터 검색 시간을 최적화할 수 있습니다. 이러한 방법은 해시 테이블이 빠른 액세스를 유지하도록 도와주며, 높은 부하 요소에서도 성능을 유지하는 데 중요합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 2. 기초 이해하기\n\n## 2.1 해시 테이블의 주요 구성 요소 설명\n\n해시 테이블은 데이터를 효율적으로 저장하고 관리하기 위해 함께 작동하는 여러 가지 핵심 구성 요소로 구성되어 있습니다:\n\n해시 함수: 이것은 해시 테이블의 핵심입니다. 해시 함수는 입력 키를 가져와 버킷이나 슬롯 배열 내에서 해당 값이 저장된 위치의 인덱스를 계산합니다. 해시 함수의 효율성은 테이블 내 데이터의 분배에 영향을 미치므로 중요합니다. 좋은 해시 함수는 충돌을 최소화하고 항목들을 버킷들 사이에 균일하게 분배합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n버켓 또는 슬롯: 이들은 데이터 항목이 저장되는 배열 내의 위치입니다. 각 버켓은 하나 이상의 항목을 저장할 수 있습니다. 가장 간단한 형태에서 버켓은 키-값 쌍을 하나 보유합니다. 그러나 충돌 처리 전략에 따라, 더 복잡한 데이터 구조나 항목 목록을 보유할 수도 있습니다.\n\n충돌 처리: 두 키가 동일한 인덱스로 해싱될 때 충돌이 발생합니다. 충돌을 효율적으로 관리하는 것은 해시 테이블의 성능을 유지하는 데 중요합니다. 충돌을 처리하는 여러 방법이 있습니다. 그 중 일부는 다음과 같습니다:\n\n- 연결 방식: 이 방법은 더 복잡한 데이터 구조(예: 연결 리스트 또는 다른 해시 테이블)를 사용하여 동일한 인덱스에 여러 요소를 저장하는 것을 포함합니다. 특정 인덱스의 각 버켓이 동일한 해시 인덱스를 공유하는 항목 목록의 헤드를 가리킵니다.\n- 개방 주소 방식: 개방 주소 방식에서 모든 요소는 배열에 직접 저장됩니다. 충돌이 발생하면 해시 테이블이 미리 정의된 시퀀스에 따라 다음 사용 가능한 슬롯을 탐색하거나 검색합니다. 일반적인 전략으로는 선형 조사, 이차 조사 및 두 번 해싱이 포함됩니다. 각 방법은 구현의 용이성과 충돌 감소 효과면에서 다른 이점을 제공합니다.\n\n## 2.2 소프트웨어 개발에서 해시 테이블의 일반적 사용 사례 개요\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n해시 테이블은 소프트웨어 개발에서 널리 사용되며 효율성과 다용성으로 인해 귀중히 여겨집니다. 다음은 일반적인 사용 사례입니다:\n\n- 데이터베이스 색인: 해시 테이블은 데이터베이스 색인 시스템의 성능에 필수적인 빠른 데이터 검색을 제공합니다.\n- 캐싱: 해시 테이블은 빠른 캐시된 데이터 조회가 중요한 캐싱 애플리케이션에 이상적입니다. 효율적인 삽입, 조회 및 삭제가 가능합니다.\n- 데이터 중복 제거: 데이터 중복을 최소화해야 하는 상황에서 해시 테이블은 중복 데이터를 신속하게 식별하는 데 도움을 줄 수 있습니다.\n- 연관 배열: 많은 프로그래밍 언어가 연관 배열(맵 또는 사전이라고도 함)을 구현하는 데 해시 테이블을 사용합니다. 사용자 정의 키를 기반으로 데이터를 검색하고 저장할 수 있습니다.\n- 고유한 데이터 표현: 해시 테이블은 고유한 항목 집합을 유지하는 데 유용하며 반복 검사가 필요한 구현에서 널리 사용됩니다.\n\n# 3. 파이썬 환경 설정\n\n## 필요한 도구 및 라이브러리\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파이썬에서 해시 테이블을 구현하려면, 파이썬 인터프리터와 텍스트 편집기 또는 통합 개발 환경(IDE)이 필요합니다. 파이썬의 표준 라이브러리만으로 해시 테이블을 구축하는 데 충분하므로 이 기본적인 구현에는 추가적인 라이브러리가 필요하지 않습니다. 그러나 해시 테이블을 고급 기능으로 확장하거나 특정 애플리케이션에 사용하기 위해 NumPy와 같은 라이브러리를 사용하는 것을 고려할 수 있습니다. 성능 최적화를 위해 NumPy를 사용하거나 pytest를 사용하여 구현을 테스트할 수 있습니다.\n\n시스템에 파이썬을 설치했는지 확인하세요. 파이썬 3.8 이상을 권장합니다. 개선된 기능과 지원으로 인해 최신 버전의 파이썬을 공식 파이썬 웹사이트에서 다운로드하거나 macOS의 brew나 Ubuntu Linux의 apt와 같은 패키지 관리자를 사용할 수 있습니다.\n\n## 해시 테이블을 위한 파이썬 스크립트 또는 모듈의 초기 설정\n\n- 새로운 파이썬 파일 만들기: 먼저 hash_table.py라는 새로운 파이썬 파일을 만들어 시작하세요. 이 파일에는 해시 테이블 구현과 관련된 모든 코드가 포함됩니다.\n- 해시 테이블 클래스의 구조 정의: HashTable이라는 클래스를 정의하여 시작하세요. 이 클래스는 삽입, 삭제, 조회 등 해시 테이블의 모든 기능을 캡슐화할 것입니다. 다음은 시작할 수 있는 기본 구조입니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/TIL/assets/img/2024-07-07-ImplementingaHashTableinPythonStep-by-Step_1.png)\n\n- 테스트 설정: 해시 테이블을 작성하는 과정에서 확인할 수 있는 간단한 테스트 메커니즘을 설정하는 것이 좋습니다. Python의 내장된 unittest 프레임워크를 사용하여 테스트 케이스를 작성할 수 있습니다:\n\n![이미지](/TIL/assets/img/2024-07-07-ImplementingaHashTableinPythonStep-by-Step_2.png)\n\n- 스크립트 실행: 명령줄에서 파일이 있는 디렉토리로 이동하여 python hash_table.py를 실행하여 스크립트를 실행하고 작성한 테스트를 실행할 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 4. 해시 테이블 클래스 구현\n\n## 4.1 해시테이블 클래스 구조 정의\n\n해시테이블 클래스는 우리의 해시 테이블의 청사진 역할을 합니다. 이는 키-값 쌍의 저장, 검색 및 삭제를 효율적으로 관리하기 위해 설계되었습니다. 아래는 초기화, 데이터 처리를 위한 메서드 및 해시 함수를 적용하는 메서드가 포함된 클래스의 기본 구조입니다:\n\n![해시테이블 클래스 구조](/TIL/assets/img/2024-07-07-ImplementingaHashTableinPythonStep-by-Step_3.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 4.2 메소드 추가\n\n- **init**: 해시 테이블 초기화. 이 메소드는 지정된 크기로 해시 테이블을 설정하고 버킷을 초기화합니다. 충돌 처리 전략에 따라 버킷은 체이닝을 위한 리스트로 구현하거나 오픈 어드레싱을 위한 빈 슬롯으로 구현할 수 있습니다.\n- insert: 해시 테이블에 아이템 추가. 이 메소드는 새로운 키-값 쌍을 해시 테이블에 삽입합니다. 해시 함수를 사용하여 키의 해시 인덱스를 계산하고 값을 적절한 버킷에 배치하며, 필요에 따라 충돌을 처리합니다.\n- get: 키로 아이템 조회. get 메소드는 해시 테이블에서 키를 검색하고 해당하는 값 반환합니다. 가능한 충돌을 처리하고, 키를 찾을 수 없는 경우 None을 반환하여 견고한 데이터 검색을 보장합니다.\n- delete: 키로 아이템 삭제. 이 메소드는 키를 사용하여 해시 테이블에서 키-값 쌍을 제거합니다. 올바른 버킷을 찾아 해당 아이템을 제거하며, 이후 요소에 영향을 미칠 수 있는 충돌을 관리합니다.\n- \\_hash: 해시 함수 적용을 위한 내부 메소드. 이는 키에 대해 해시 함수를 적용하는 과정을 단순화하는 도우미 메소드입니다. 이를 통해 키가 버킷 리스트의 범위 내에서 유효한 인덱스로 변환됩니다.\n\n## 4.3 체이닝(링크드 리스트) 또는 오픈 어드레싱을 이용한 충돌 처리 설명\n\n- 체이닝(링크드 리스트): 체이닝은 충돌 해결 기법으로, 배열 내 특정 인덱스의 각 버킷이 연결 리스트를 시작할 수 있습니다. 동일한 인덱스로 해싱된 모든 키-값 쌍은 이 리스트에 저장되어 같은 인덱스에 여러 항목을 보관하도록 허용하지만, 최악의 경우 원소를 검색하는 시간 복잡성이 증가할 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/TIL/assets/img/2024-07-07-ImplementingaHashTableinPythonStep-by-Step_4.png)\n\n- Open Addressing: Open addressing stores all elements directly in the array and resolves collisions by finding another empty slot within the array. The common strategies for open addressing include linear probing, quadratic probing, and double hashing, each with distinct approaches to resolving collisions efficiently.\n\nHere’s an implementation of linear probing:\n\n![image](/TIL/assets/img/2024-07-07-ImplementingaHashTableinPythonStep-by-Step_5.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음은 이차 조사법의 구현 예시입니다:\n\n![quadric_probing](/TIL/assets/img/2024-07-07-ImplementingaHashTableinPythonStep-by-Step_6.png)\n\n다음은 두 번째 해싱(double hashing)의 구현 예시입니다:\n\n![double_hashing](/TIL/assets/img/2024-07-07-ImplementingaHashTableinPythonStep-by-Step_7.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 5. 충돌 처리\n\n## 5.1 체이닝의 상세 설명 및 Python에서의 구현\n\n체이닝은 해시 테이블에서 충돌을 처리하는 일반적인 방법으로, 특정 인덱스의 각 버킷이 하나 이상의 요소를 보유할 수 있습니다. 이 접근 방식은 동일한 인덱스로 해싱된 여러 항목을 저장하는 데 연결 목록과 같은 보조 데이터 구조를 사용합니다. 각 버킷이 항목 리스트를 저장할 수 있도록 함으로써 체이닝은 충돌을 우아하게 처리하고 높은 부하 요인에서도 성능을 유지합니다.\n\nPython에서의 구현: 해시 테이블에서 체이닝을 구현하는 상세 예제입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/TIL/assets/img/2024-07-07-ImplementingaHashTableinPythonStep-by-Step_8.png)\n\n이 구현에서 각 버킷은 연결 리스트로 연결된 여러 항목을 잠재적으로 저장할 수 있습니다. 새 키-값 쌍이 삽입될 때 해시 테이블은 계산된 인덱스에 이미 항목이 있는지 확인합니다. 버킷이 비어있으면 새 노드를 간단히 삽입합니다. 그렇지 않으면 기존 키를 업데이트하거나 키가 존재하지 않으면 체인 끝에 새 노드를 추가합니다. 이 방법은 메모리 사용량 면에서 효율적이며 충돌 처리를 단순화합니다.\n\n체이닝의 장점:\n\n- 체이닝은 구현이 간단합니다.\n- 높은 충돌 시나리오를 우아하게 처리할 수 있습니다. 해시 테이블은 버킷 수보다 더 많은 항목을 저장할 수 있습니다.\n- 전체 테이블의 크기를 조정할 필요가 없습니다. 영향을 받는 체인만 조정하면 됩니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n체이닝의 단점:\n\n- 체이닝은 링크드 리스트 포인터와 관련된 오버헤드로 인해 더 많은 메모리를 사용합니다.\n- 많은 요소가 동일한 인덱스로 해싱되는 최악의 경우에는 요소를 찾는 작업이 느려질 수 있습니다. 이는 링크드 리스트를 탐색해야 하기 때문입니다.\n\n이 충돌 처리 방법은 하중 계수가 높고 해시 테이블이 효율적으로 많은 충돌을 처리해야 하는 경우에 적합합니다.\n\n## 5.2 대체 방법: 오픈 어드레싱 방법 구현\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n열린 주소 할당은 해시 테이블 내에서 다양한 버킷 위치를 조사하여 충돌을 해결합니다.\n\n선형 조사: 해시 테이블에서 충돌을 해결하는 간단한 열린 주소 할당 전략입니다. 연결 리스트와 달리 충돌은 동일한 인덱스의 항목을 연결하는 것이 아니라, 선형 조사는 배열 내에서 새 항목을 저장할 다음 사용 가능한 슬롯을 찾습니다. 이 방법을 통해 모든 항목이 배열 내에 직접 저장되므로 캐시 성능이 향상되고 공간을 더 효율적으로 사용할 수 있습니다.\n\nPython에서의 구현:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 구현에서 충돌이 발생하는 경우(즉, 해시된 인덱스가 이미 사용 중인 경우), 해시 테이블은 다음 사용 가능한 슬롯을 선형적으로 탐색합니다. 이 방법은 간단하고 효과적이지만 연속적인 슬롯이 채워져 클러스터링이 발생할 수 있어 테이블이 채워질수록 평균 검색 시간이 증가할 수 있습니다.\n\n선형 조사의 장점:\n\n- 주 메인 테이블 외 추가 메모리가 필요하지 않아 공간을 효율적으로 사용합니다.\n- 구현 및 이해하기 쉽습니다.\n- 연속적인 메모리 사용으로 인한 좋은 캐시 성능을 지니고 있습니다.\n\n선형 조사의 단점:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 클러스터링은 고부하 시나리오에서 성능에 상당한 영향을 미칠 수 있습니다.\n- 부하 요소 임계값에 도달하면 전체 테이블을 조정해야 하므로 계산 비용이 많이 들 수 있습니다.\n\n선형 조사는 부하 요소가 낮고 중간 수준인 테이블에 적합하며, 삭제 빈도가 낮을 때 특히 효과적입니다. 삭제는 조사 순서를 복잡하게 만들 수 있는 간격을 만들 수 있기 때문입니다.\n\n제곱 조사: 해시 테이블에서 충돌을 해결하는 고급 개방 주소 지정 기술이며, 클러스터링 문제를 해결하여 선형 조사보다 큰 개선을 제공합니다. 선형 조사가 선형 시퀀스에서 다음 사용 가능한 슬롯을 찾는 것과 달리, 제곱 조사는 제곱 다항식을 사용하여 조사 간의 간격을 계산하므로 클러스터를 생성할 가능성을 줄입니다.\n\n파이썬에서의 구현:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/TIL/assets/img/2024-07-07-파이썬 단계별 해시테이블 구현_10.png\" />\n\n이 구현에서는 이차 탐사가 선형 탐사에서 발생하는 주요 클러스터링 문제를 크게 줄이기 위해 탐사 시도 횟수의 이차 함수를 사용하여 다음 인덱스를 계산합니다. 탐사 함수는 다음과 같은 공식을 사용합니다: (index + c1*trial + c2*trial^2) % table_size, 여기서 c1과 c2는 상수이고, trial은 빈 슬롯을 찾거나 루프가 감지될 때까지 각 탐사마다 1씩 증가합니다.\n\n이차 탐사의 장점:\n\n- 선형 탐사와 비교하여 클러스터링을 줄입니다.\n- 클러스터링 된 항목을 효율적으로 분산하여 해시 테이블 공간을 더 효과적으로 활용합니다.\n- 다음 인덱스를 계산하는 과정은 여전히 비교적 간단하고 빠릅니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n제곱 탐사의 단점:\n\n- 선형 탐사보다는 심각성이 적긴 하지만 부착 현상이 발생할 수 있습니다.\n- c1 및 c2 값의 선택이 성능에 상당한 영향을 미치며 신중한 조정이 필요합니다.\n- 다른 개방 주소 메서드와 마찬가지로 테이블이 너무 가득 차면 크기를 조정해야 합니다.\n\n제곱 탐사는 중간 부하 인자에 대해 효과적인 충돌 해결 기술이며 해시 테이블 크기를 충분히 크게 유지하여 자주 크기 조정을 피할 수 있는 시나리오에서 특히 유익합니다.\n\n더블 해싱: 간단한 형태의 탐사와 관련된 클러스터링 문제를 크게 줄이는 데 기여하는 두 개의 해시 함수를 사용하는 개방 주소의 정교한 방법입니다. 선형 또는 제곱 탐사와 달리, 더블 해싱은 충돌이 발생한 후 단계 크기를 계산하기 위해 두 번째 해시 함수를 사용하여 각 탐사가 키를 기반으로 한 독특한 순서를 따르도록 합니다. 이 방법은 항목을 해시 테이블 전체에 골고루 분배하여 효율적이고 효과적인 것으로 알려져 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파이썬에서의 구현:\n\n![Implementing a Hash Table in Python Step-by-Step](/TIL/assets/img/2024-07-07-ImplementingaHashTableinPythonStep-by-Step_11.png)\n\n이 구현에서 첫 번째 해시 함수는 초기 슬롯을 결정하고 충돌이 발생하는 경우 두 번째 해시 함수는 다음 프로브를 위한 오프셋을 제공합니다. 이는 단순 혹은 제곱 프로빙과는 다르며 단계가 고정되어 있거나 예측 가능한 패턴으로 증가하는 것이 아닙니다. 따라서 더블 해싱은 주요 및 보조 클러스터링을 모두 줄여 데이터 분포를 더 균일하게 만듭니다.\n\n더블 해싱의 장점:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 다른 조사 기법보다 클러스터링을 더 효과적으로 최소화합니다.\n- 높은 부하 계수를 가진 해시 테이블에서 높은 성능을 제공합니다.\n- 각 키는 고유한 조사 시퀀스를 받아 다른 조사 방법보다 성능을 향상시킵니다.\n\n더블 해싱의 단점:\n\n- 선형 또는 이차 조사보다 구현이 더 복잡합니다.\n- 두 번째 해시 함수를 계산하기 위해 추가 계산이 필요합니다.\n- 성능은 두 해시 함수의 품질에 매우 의존합니다.\n\n더블 해싱은 해시 테이블이 높은 트래픽을 경험하거나 키 분포로 인해 충돌이 자주 발생할 수 있는 애플리케이션에서 특히 유용합니다. 입력을 효율적으로 분배하는 능력으로 대규모 데이터 세트에 대한 훌륭한 선택입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 5.3 각 충돌 해결 기술의 장단점\n\n체이닝: 장점: 구현하기 쉽고 높은 충돌 상황을 우아하게 처리함; 크기 조정 시 전체 테이블을 다시 해싱할 필요가 없음. 단점: 더 많은 메모리를 사용함; 연결 리스트 작업이 비연속 메모리 할당 때문에 느릴 수 있음.\n\n오픈 어드레싱: 장점: 해시 테이블 배열 자체에 모든 요소를 저장하여 공간을 효율적으로 사용함; 연속적인 메모리 사용으로 인한 더 나은 캐시 성능. 단점: 클러스터링이 발생하여 효율성이 감소할 수 있음; 테이블이 가득 찰 경우 리사이징이 필요함; 리사이징을 구현하기 복잡함.\n\n각 충돌 처리 방법은 상충 관계가 있으며 특정 유형의 응용 프로그램에 가장 적합합니다. 체이닝은 불특정하거나 매우 변동적인 부하를 갖는 해시 테이블에 적합할 수 있으며, 오픈 어드레싱은 안정적인 데이터 세트와 충돌을 최소화하기 위한 좋은 해시 함수가 있는 응용 프로그램에 더 적합할 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 6. 테스트 및 디버깅\n\n## 6.1 해시 테이블을 위한 테스트 케이스 작성\n\n해시 테이블의 효과적인 테스트는 다양한 조건에서 데이터를 처리하는 신뢰성과 효율성을 보장하기 위해 중요합니다. 서로 다른 프로빙 기법을 사용하여 해시 테이블 구현을 위한 포괄적인 테스트 케이스를 작성하는 방법은 다음과 같습니다:\n\n요소 삽입, 검색 및 삭제:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 기본 작업(삽입, 가져오기, 삭제)이 예상대로 작동하는지 확인하는 간단한 테스트부터 시작해보세요. 해시 테이블에 요소를 추가하고, 키를 사용하여 그 값을 검색하고, 일부 요소를 제거하여 테이블이 올바르게 업데이트되는지 확인하는 것이 포함됩니다.\n\n고부하로 성능 확인:\n\n- 해시 테이블이 로드 팩터가 증가함에도 효율적으로 작동하는지 확인하세요. 많은 수의 요소를 삽입하고 다양한 작업에 걸리는 시간을 측정하여 수행할 수 있습니다. 해시 테이블이 용량 한계에 가까워지는 경우와 리사이징을 처리하는 방법에 대한 테스트를 해보세요.\n\n충돌 처리에 대한 스트레스 테스트:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 동일한 값으로 해싱되는 많은 키가 있는 시나리오를 만들어 충돌 처리를 테스트합니다. 이는 충돌 처리 메커니즘의 효율성 (체이닝, 선형 조사, 제곱 조사, 이중 해싱)과 강압하에서의 구조적 무결성을 테스트하는 것을 포함합니다.\n\n## 샘플 테스트 구현:\n\n- 체이닝: pytest 픽스처를 사용하여 여러 항목이 동일한 버킷으로 해싱되는 시나리오를 만들고 해당 항목이 검색 및 삭제 가능한지 확인합니다. 버킷 내에서 광범위한 목록을 처리하는 체이닝이 어떻게 처리되는지 테스트합니다.\n\n![이미지](/TIL/assets/img/2024-07-07-ImplementingaHashTableinPythonStep-by-Step_12.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2. Linear Probing: 해시 테이블이 충돌을 해결하는 방법을 테스트하는 것에 초점을 맞추세요. 다음으로 사용 가능한 슬롯을 찾아 보세요. 항목이 올바르게 덮어쓰기되거나 업데이트되는지, 그리고 테이블이 필요에 따라 어떻게 확장되는지 확인하세요.\n\n![이미지](/TIL/assets/img/2024-07-07-ImplementingaHashTableinPythonStep-by-Step_13.png)\n\n3. Quadratic Probing: 선형 조사와 유사하지만 다른 초기 충돌을 테스트하고, 이차 단계 계산이 항목을 충돌하지 않는 슬롯에 올바르게 배치하는지 확인하세요.\n\n![이미지](/TIL/assets/img/2024-07-07-ImplementingaHashTableinPythonStep-by-Step_14.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n4. 더블 해싱: 보조 해시 함수를 사용하여 충돌을 줄이는 효과를 테스트해보세요. 더블 해싱 방법이 다른 방법보다 항목을 테이블에 더 균등하게 분배하는지 확인해보세요.\n\n![image](/TIL/assets/img/2024-07-07-ImplementingaHashTableinPythonStep-by-Step_15.png)\n\n## 6.2 해시 테이블 구현에서 발생하는 일반적인 문제 해결\n\n해시 테이블을 디버깅하는 것은 주로 충돌 처리, 해시 함수 분포, 동적 크기 조절과 관련된 문제를 식별하는 것을 포함합니다. 다음은 몇 가지 전략입니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 충돌 처리: 요소가 자주 손실되거나 덮어써지는 경우 충돌 해결 논리를 검토해보세요. 삽입, 삭제 및 조회가 충돌하는 키를 올바르게 처리하도록 확인해주세요.\n- 해시 함수 품질: 해시 함수에 의한 부족한 분포는 성능 병목 현상으로 이어질 수 있습니다. 특정 버킷이 과도하게 사용되는 경우 해시 함수를 수정하는 것을 고려해보세요. 키들이 버킷 간에 어떻게 분산되는지 테스트하여 이 문제를 확인할 수 있습니다.\n- 메모리 누수 및 오버플로우: 수동 메모리 관리가 있는 언어에서 특히 관련됩니다만, Python에서는 쓰레기 수집을 방해하는 의도하지 않은 참조를 확인하세요. 또한, 메모리 오버플로우나 과도한 재할당을 유발하지 않으면서 크기 조정 로직이 메모리를 적절히 관리하는지 확인하세요.\n- 동시성 문제: 해시 테이블이 멀티 스레드 응용 프로그램에서 사용되는 경우 경합 조건이 데이터 구조를 손상시킬 수 있습니다. 잠금을 구현하거나 동시성 데이터 구조를 사용하여 스레드 안전성을 보장하세요.\n\n# 7. 고급 주제\n\n## 7.1 동적 크기 조절을 통한 해시 테이블 성능 향상\n\n요소 수가 증가함에 따라 해시 테이블에서 효율적인 성능을 유지하기 위해 동적 크기 조정은 중요한 기능입니다. 크기 조정 없이는 로드 팩터(요소 수 대비 버킷 수의 비율)이 증가하여 더 많은 충돌이 발생하고 따라서 더 긴 검색 시간이 발생합니다. 성능을 향상시키기 위해 해시 테이블은 다음과 같이 동적으로 크기를 조절할 수 있습니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 크기 두 배로 확장: 해시 테이블의 로드 계수가 특정 임계값을 초과할 때(일반적으로 0.7 또는 0.75로 설정), 해시 테이블의 크기가 두 배로 증가합니다. 이 과정은 두 배의 버킷 수를 갖는 새로운 해시 테이블을 만들고 모든 기존 요소를 새 테이블로 재해싱하는 것을 포함합니다.\n- 크기 반으로 축소: 마찬가지로 로드 계수가 낮은 임계값(예: 0.1)보다 낮아지면, 해시 테이블의 크기가 반으로 줄어들어 공간을 절약하고 데이터 크기가 작아지는 시나리오에서 효율을 유지합니다.\n\n동적 크기 조정을 구현하는 것은 리사이징 작업 중 데이터 무결성과 최소한의 성능 영향을 보장하기 위해 신중한 처리가 필요합니다.\n\n## 7.2 해시 테이블의 실제 응용 및 최적화에 대한 토론\n\n해시 테이블은 소프트웨어 엔지니어링에서 만능으로 사용되며, 빠른 데이터 검색이 중요한 다양한 응용 프로그램에서 사용됩니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 데이터베이스: 해시 테이블은 많은 데이터베이스 인덱스 메커니즘을 구동하여 레코드의 신속한 조회, 삽입 및 삭제를 가능하게 합니다.\n- 캐싱 시스템: 많은 웹 및 응용프로그램 서버는 해시 테이블을 사용하여 캐싱을 하며, 자주 액세스되는 데이터를 빠르게 검색 가능한 형식으로 저장하여 데이터베이스로의 요청 횟수를 줄입니다.\n- 유일한 항목 추적: 해시 테이블은 고유한 항목을 추적하거나 항목의 존재 여부를 확인하는 작업에 이상적이며, 그들의 일정한 실행 시간 특성 때문에 유용합니다.\n\n최적화는 콜리전 최소화를 위해 올바른 해시 함수 선택, 유니버설 해싱 같은 기법 사용, 캐시 성능 향상을 위한 메모리 할당 전략 최적화 등이 포함될 수 있습니다.\n\n## 7.3 Python의 내장 dict와 사용자 정의 해시 테이블 비교\n\nPython의 내장 dict는 사실상 Python 언어에 통합된 하이퍼 최적화된 해시 테이블입니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 성능: 파이썬의 dict는 C로 구현되어 있어 순수 파이썬으로 작성된 사용자 지정 해시 테이블보다 속도가 빠릅니다. 이는 하위 수준의 최적화와 Python의 동적 타이핑으로 인한 오버헤드가 없기 때문입니다.\n- 기능: 파이썬의 dict는 순서를 유지하는 추가 기능을 제공합니다 (Python 3.7부터), 이는 일반적인 해시 테이블 구현에서 일반적으로 제공되지 않는 기능입니다.\n- 사용 편의성: 내장 유형인 dict는 Python 구문과 표준 라이브러리에서 직접 지원되므로 사용자 정의 해시 테이블을 구현하는 것보다 편리하게 사용할 수 있습니다.\n\n사용자 정의 해시 테이블은 특정 필요에 맞게 맞춤 설정할 수 있지만, 대부분의 응용 프로그램에 대해 파이썬의 dict는 충분한 성능과 기능을 제공하므로 dict가 지원하지 않는 특정 동작이 필요하지 않는 한 사용자 정의 해시 테이블을 구현할 필요는 없습니다. 예를 들어, 다른 충돌 처리 방법이나 실시간 크기 조정 임계값 등을 필요로 할 때입니다.\n\n# 결론\n\n이 기사를 통해 Python에서 해시 테이블을 구현하는 것에 대해 깊이 있는 내용을 제공했습니다. 체이닝, 선형 조사, 이차 조사, 두 배 해싱을 포함한 충돌 해결 방법을 탐색했습니다. 각 방법이 충돌을 처리하고 해시 테이블의 성능을 최적화하는 방법을 자세히 설명했으며, 효과적인 응용에 대한 포괄적인 가이드를 제공했습니다. 또한 다양한 시나리오에서 해시 테이블의 신뢰성과 효율성을 보장하기 위한 상세한 테스트 접근 방법에 대해 다루었습니다. 이 논의는 데이터 구조에 대한 이해력을 향상시킬 뿐만 아니라 Python 프로젝트에서 복잡한 데이터 관리 도전에 대비하기 위한 실용적 기술을 갖추도록 도와줍니다. 철저한 테스트 실천을 통해 구현의 무결성과 성능을 향상하는 방법을 보여주었습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 친절한 영어로 🚀\n\nIn Plain English 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 갈치하고 팔로우하세요 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠를 다루는 블로깅 플랫폼에 질려셨나요? Differ를 시도해 보세요\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요\n","ogImage":{"url":"/assets/img/2024-07-07-ImplementingaHashTableinPythonStep-by-Step_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-ImplementingaHashTableinPythonStep-by-Step_0.png","tag":["Tech"],"readingTime":23},{"title":"JAX를 배워야 하는 이유 분자동역학 적용 사례 소개","description":"","date":"2024-07-07 12:50","slug":"2024-07-07-WhyYouShouldLearnJAXAMolecularDynamicsShowcase","content":"\n파이썬 스크립트를 최적화하기 위해 PyTorch에 실망한 후 JAX를 사용하기 시작했습니다. 내 프로젝트는 주로 두 가지 주요 구성 요소로 이루어져 있었습니다: 원자 위치를 기반으로 설명자를 계산하고 이러한 설명자를 여러 신경망에 입력으로 사용하여 입자 시스템의 총 잠재 에너지와 힘을 예측하는 것이었습니다. 신경망 부분은 충분히 빠르지만, 특히 TorchScript를 사용한 후에도 설명자 계산, 특히 그래디언트 평가는 효율적으로 수행되지 않았습니다. 자동 미분을 지원하는 Python의 대체 프레임워크를 찾던 중 JAX를 발견했습니다. (물리학적인) 머신러닝 모델을 구축하는 데 매우 효과적이었고 필요한 유연성과 성능을 모두 제공했습니다.\n\n![이미지](/TIL/assets/img/2024-07-07-WhyYouShouldLearnJAXAMolecularDynamicsShowcase_0.png)\n\nPyTorch를 사용하는 데 이의를 제기하는 것은 없습니다. 사실, 자주 사용하여 언어 처리나 객체 탐지 작업을 포함한 머신러닝 모델을 구축할 때 사용합니다. 그러나 Python에서 사용자 정의 및 최적화된 모델을 개발하려는 경우, 아마도 PyTorch가 가장 적합한 선택이 아닐 수도 있습니다. PyTorch는 여러 면에서 뛰어나지만 매우 사용자 정의 및 특정한 모델 아키텍처에 대해서는 성능이 좀 더 우수한 대안이 있을 수 있습니다.\n\nJAX는 자동 미분(autodiff), Just-In-Time (JIT) 컴파일, GPU 가속 컴퓨팅 및 벡터화된 계산 지원을 포함한 제 요구 사항과 완벽하게 일치하는 기능 세트를 제공했습니다. 게다가 JAX는 기능적 프로그래밍 패러다임과 일치하는 방법으로 가변성을 처리합니다. 이 게시물을 통해 JAX를 사용한 제 경험을 공유하고 여러분이 자신의 프로젝트에 JAX를 탐구하고 활용할 동기부여를 제공하는 것이 제 목표입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 필수 패키지\n\n이 가이드를 따라가려면 몇 가지 Python 패키지를 설치해야 합니다.\n\n- **JAX**: 파이썬의 고성능 수치 계산 라이브러리로, 자동 미분과 CPU 및 GPU에서 최적화된 실행을 제공합니다. 이 설치 지침을 따르세요.\n- **ASE**: 분자 시뮬레이션을 설정, 조작 및 분석하는 도구상자로, 계산재료과학 분야에서 널리 사용됩니다.\n  설치: `$ pip install ase`\n- **Pantea**: 나의 Python 패키지로, 현재 개발 중이며 분자 간 포텐셜을 위한 기계 학습 모델을 개발하는 데 사용됩니다.\n  설치: `$ pip install pantea`\n- **NGLView** (옵션): 분자 구조 및 궤적을 대화식으로 보기 위한 주피터 위젯입니다.\n  설치: `conda install nglview -c conda-forge`\n\nJAX는 시스템의 GPU를 자동으로 사용하며, 이용할 수 없을 경우 CPU를 사용합니다. 또한 JAX_PLATFORM_NAME 환경 변수를 미리 조정하여 연산 장치를 수동으로 설정할 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n기본적으로 JAX는 플로트32 데이터 유형을 사용하며, 이는 싱글 포인트 정밀도를 나타냅니다. 그러나 과학 시뮬레이션에서는 높은 정확성을 위해 더블 정밀도 플로트64가 필요합니다. 개선된 계산 성능을 위해 가능한 한 낮은 정밀도를 선택하고 메모리 사용량을 줄이는 것이 권장됩니다(약 2배 정도).\n\n다음 스크립트는 JAX를 구성하여 장치를 선택하고 더블 정밀도를 활성화하는 방법을 보여줍니다.\n\n```js\nimport os\nos.environ[\"JAX_PLATFORM_NAME\"] = \"cpu\"  # GPU 컴퓨팅 비활성화\nos.environ[\"JAX_ENABLE_X64\"] = \"1\"       # 더블 정밀도 활성화\n\nimport jax\n...\n```\n\n간단한 예제의 경우 기본 float32 정밀도를 사용하지만 분자 동역학을 시연할 때는 더블 정밀도를 사용할 것입니다. 또한, 이 글에서 모든 계산은 명시적으로 다른 장치가 명시되지 않는 한 제 노트북의 GeForce MX130 GPU에서 실행됩니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위에서 안내한 단계를 따르면이 포스트에서 다룬 예제를 재현하는 데 필수 도구를 제공받을 수 있습니다. 시작해 봅시다!\n\n# JAX란 무엇인가요?\n\nJAX는 JIT 컴파일, 가속 컴퓨팅 및 자동 미분을 통해 고성능 수치 계산을 가능하게 하는 배열지향 컴퓨테이션용 오픈 소스이자 구성 가능한 파이썬 라이브러리입니다. 머신 러닝, 최적화 및 과학 시뮬레이션과 같은 고성능 수치 계산을 위한 사용자가 익숙한 NumPy 구문을 사용하여 코드를 작성하면 자동으로 효율적으로 해당 코드를 GPU 및 TPU에서 실행할 수 있도록 변환해줍니다. 이는 계산이 많이 필요한 작업에 높은 효율성을 가지며 매우 적합합니다. 선형 대수 가속화 X(LAX)는 JAX 라이브러리 내에서 서브 모듈 역할을 하며 다양한 선형 대수 루틴의 최적화된 구현을 제공합니다. JAX 문서 페이지를 방문하여 자세한 내용을 확인하는 것을 강력히 권장하며 다양한 정보와 자원을 제공하는데 도움이 됩니다. 예를 들어 이 튜토리얼을 참조해보세요.\n\n일부 사람들은 JAX를 단순히 멀티스레드 NumPy 라이브러리로 설명하지만, 저는 그렇지 않다고 주장합니다. 그 이상의 기능을 제공합니다. 후속 섹션에서는 제 프로젝트 개발에 중요한 역할을 한 JAX의 주요 기능 몇 가지를 소개하겠습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## I. JIT 컴파일\n\nJust-In-Time (JIT) 컴파일은 코드를 런타임에 컴파일하는 방법으로, 미리 컴파일하는 것이 아니라 코드를 컴파일하는 방법입니다. 이로 인해 코드를 실행 중인 특정 시스템에 맞게 최적화할 수 있으며, 미리 컴파일된 코드보다 성능이 향상될 수 있습니다. Python 스크립트는 해석되는데, 즉, 코드가 Python 인터프리터에 의해 한 줄씩 읽히고 실행됩니다. 이는 각 코드 줄을 처리한 후 실행해야 하기 때문에 컴파일된 코드보다 느릴 수 있습니다.\n\n이와 대조적인 JIT 컴파일은 Python 코드를 런타임에 기계 코드로 변환하므로 컴퓨터의 CPU에서 직접 실행할 수 있습니다. 이는 Python의 오버헤드를 효과적으로 제거하고 해석된 코드보다 성능을 향상시킬 수 있습니다. 배열을 입력으로 받아 결과를 반환하는 더미 커널 함수의 예를 살펴보겠습니다:\n\n```python\nimport jax.numpy as jnp\n\ndef kernel(x):\n  \"\"\"더미 커널 함수.\"\"\"\n  result = 0\n  for i in range(10):\n      result += i * jnp.sin(jnp.cos(x))\n  return result.sum()\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n랜덤 입력 배열을 생성하고 JIT 컴파일 없이 구현된 함수 호출의 실행 시간을 측정해 봅시다.\n\n```js\nimport jax\n\nx = jax.random.normal(jax.random.key(2024), shape=(100_000, ))\n# Array([ 0.8188207 ,  0.70407075, -0.553007  , ..., -0.07251461,\n#       -1.353674  , -0.21451078], dtype=float32)\n\n%timeit kernel(x).block_until_ready()\n2.34 ms ± 134 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\n```\n\n%timeit은 Jupyter 노트북과 IPython에서 사용되는 매직 커맨드로, 코드 조각의 실행 시간을 측정하는 데 사용됩니다. 여러 번 코드를 실행하여 평균 실행 시간을 얻으며, 상당한 변동성을 고려하여 성능을 더 정확하게 측정합니다.\n\nJAX는 비동기 디스패치를 사용하므로, JAX 배열에 block_until_ready() 메서드를 호출하면 해당 배열이 계산을 완료할 때까지 Python 프로그램 실행이 차단됩니다. 계산 시간의 마이크로 벤치마킹을 작성할 때 이것을 권장합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n보고된 결과인 2.34 ms ± 134 µs per loop은 각각 100번 실행되는 7회의 실행을 기반으로 한 루프 당 평균 소요 시간 및 표준 편차를 나타냅니다.\n\n이제 이 함수의 JIT 컴파일된 버전(또는 데코레이터를 사용하여 적용할 수도 있음)을 생성하고, 이후에 실행 시간을 다시평가하겠습니다.\n\n```js\nimport jax\n\njitted_kernel = jax.jit(kernel)\n\n# 웜업 호출\n# jitted_kernel(x)\n\n%timeit jitted_kernel(x).block_until_ready()\n82.5 µs ± 1.9 µs per loop (mean ± std. dev. of 7 runs, 10,000 loops each)\n속도 향상:  29배\n```\n\nJIT 함수에 대한 웜업 호출은 일반적으로 속도를 평가하기 전에 컴파일하고 최적화하는 목적으로 실행됩니다. 함수 구현이 직관적하기 때문에 이 단계를 생략했습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n컴파일된 함수는 JIT 컴파일을 통해 심각한 성능 향상을 이루며, 컴파일되지 않은 버전보다 29배 빠르게 실행됩니다. 이 JAX 기능은 고성능 Python 함수를 작성할 수 있도록 돕습니다.\n\n## II. 자동 미분\n\n자동 미분은 함수의 도함수를 자동으로 계산하는 계산 기술입니다. 유한한 차이를 사용하여 도함수를 근사하는 수치 미분이나 표현식을 조작하여 도함수를 찾는 기호 미분과는 달리, 자동 미분은 미분을 정확하고 효율적으로 평가하기 위해 미적분의 연쇄 법칙을 체계적으로 적용합니다. 요즘에는 자동 미분이 PyTorch, TensorFlow 및 JAX와 같은 딥 러닝 프레임워크에서 중요한 역할을 합니다. 효율적인 기울기 계산을 가능하게 하기 때문에 기울기 하강과 같은 최적화 알고리즘에 필수적인 기울기의 효율적인 계산이 허용됩니다.\n\n자동 미분은 JAX의 핵심 기능으로, 기울기를 계산하는 프로세스를 단순화하고 가속화합니다. JAX는 여러 가지 함수를 제공하여 미분을 수행하며, 가장 두드러진 함수는 입력 변수에 대한 스칼라 값 함수의 기울기를 계산하는 jax.grad입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이전 예제 커널을 고려해 봅시다. jax.grad를 사용하여 다음 코드를 통해 간단히 각 입력에 대한 출력의 기울기를 계산할 수 있습니다.\n\n```js\nimport jax\n\ngradient_kernel = jax.grad(kernel)\n\nkernel(x)\n# Array(2401043.5, dtype=float32)\n\ngradient_kernel(x)\n# Array([-25.491356 , -21.069756 ,  15.582619 , ...,   1.7687505,\n#        42.92778  ,   5.35899  ], dtype=float32)\n\n%timeit gradient_kernel(x).block_until_ready()\n56.3 ms ± 7.11 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)\n```\n\n게다가, JAX의 조합 가능한 기능 덕분에 jax.grad를 jax.jit과 원활하게 결합하여 커널의 기울기를 자동으로 계산하는 최적화된 함수를 만들 수 있습니다. 이를 통해 JAX의 자동 미분 기능을 활용하여 효율적으로 그래디언트를 계산하는 동시에 JIT 컴파일을 통해 성능을 향상시킬 수 있습니다.\n\n```js\nimport jax\n\njitted_gradient_kernel = jax.jit(gradient_kernel)\n\n%timeit jitted_gradient_kernel(x).block_until_ready()\n192 µs ± 37.7 µs per loop (mean ± std. dev. of 7 runs, 1 loop each)\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n분자 시뮬레이션 맥락에서, 물리적 시스템 내 이차력은 총 포텐셜 에너지 함수의 그래디언트에서 얻어집니다. 이 관계는 자동 미분의 중요성을 강조하는데, 이를 통해 힘의 구성요소를 정확하고 효율적으로 계산할 수 있는 수단을 제공합니다. 자동 미분을 사용함으로써, 포텐셜 에너지 함수의 필요한 도함수를 정확하게 계산하여 힘의 구성요소가 고정밀로 결정되도록 할 수 있습니다.\n\n## III. 자동 벡터화\n\n벡터화된 계산은 개별 요소가 아닌 전체 배열에 작업을 적용하는 과정을 말합니다. 이는 현대 CPU 및 GPU의 가능성 (즉, SIMD)을 활용하여 연산을 병렬로 수행함으로써 전통적인 루프 기반 접근법에 비해 실행 시간이 크게 단축됩니다. Python에서 효율적인 코드를 작성하기 위해서 대부분의 경우 루프 사용을 피하고 배열에 작용하는 범용 함수의 효율적인 구현에 의존해야 합니다. 제 경험 상, 숫자 Python으로 전환하면 사고 방식 변화가 필요할 수 있습니다. C/C++와 같은 저수준 프로그래밍 언어는 여러 개의 루프를 일반적으로 사용하나, 숫자 Python의 접근 방식은 루프를 피하고 논리를 벡터 함수로 변환하는 것이 강조됩니다. 벡터화된 계산을 활용하면 전체 성능이 크게 향상됩니다. NumPy는 함수와 벡터화된 계산을 통해 혜택을 얻으며, 실제로 이는 그 성능과 효율성의 핵심 요소 중 하나입니다.\n\njax.vmap 변환은 함수의 벡터화된 구현을 자동으로 생성하여 배열에 대해 함수를 병렬 및 효율적으로 적용하는 것을 쉽게 만듭니다. 또한 명시적인 루프가 필요 없어지므로 코드를 간소화시킵니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 예시를 통해 위치 벡터 배열 간의 거리를 계산하는 방법이 얼마나 중요한지 살펴보겠습니다. 원자들 간의 거리를 결정하는 것은 분자 시뮬레이션에서 잠재 에너지를 평가하는 데 필수적입니다. 두 개의 배열 x와 y가 있다고 가정해보겠습니다. 각각은 일련의 원자들을 위한 위치 벡터를 포함하고 있습니다. 두 배열 모두 차원이 (natoms, 3)인데, 여기서 natoms은 원자의 수를 나타내고 배열의 각 벡터는 원자의 3D 좌표를 포함합니다. 우리의 목표는 이러한 배열에서 각각의 벡터 쌍 간의 거리를 포착하는 거리 행렬을 계산하는 것입니다. 아래 함수는 두 입력 배열 간의 이러한 거리 행렬을 반환합니다:\n\n```js\nimport jax.numpy as jnp\n\ndef calculate_distances(x, y):\n    distances = []\n    nrows, _ = x.shape\n    for i in range(nrows):\n        distances_from_single_point = jnp.sqrt(((x[i] - y)**2).sum(axis=1))\n        distances.append(distances_from_single_point)\n    return jnp.array(distances)\n```\n\n여기서 배열 계산을 사용하여 배열 x에 있는 각 지점에서 배열 y의 모든 지점까지의 거리를 효율적으로 계산했습니다. 예를 들어, 브로드캐스트된 항목 x[i] — y를 사용하여 명시적인 루프 없이 요소별 뺄셈을 수행할 수 있어 계산 효율성과 명확성을 높였습니다.\n\n이 프로세스는 JAX에서 자동적으로 효율적으로 vectorize될 수 있습니다. jax.vmap을 사용하면 입력 배열의 첫 번째 인덱스를 효율적으로 처리하도록 일관되게 작동하는 함수로 단일 특정 지점에서 작동하는 함수를 변환할 수 있습니다. 이러한 기능을 실행하기 위해 먼저 한 지점을 처리하는 함수를 정의한 다음 jax.vmap을 사용하여 입력 배열의 첫 번째 인덱스에 대해이 함수를 일괄 처리하도록 일반화하여 루프 없이 일괄 처리에 대한 효율적인 계산을 가능하게 합니다. 이 방식은 코드를 단순화하는 데 도움이 되며 빠른 실행을 위해 JAX의 최적화 기능을 활용합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nimport jax\n\ndef calculate_distances_from_single_point(xi, y):\n    return jnp.sqrt(((xi - y)**2).sum(axis=1))\n\nvmapped_calculate_distances = jax.vmap(\ncalculate_distances_from_single_point,\nin_axes=(0, None)\n)\n```\n\nin_axes=(0, None)는 벡터화된 함수의 입력 축을 지정합니다. 이 경우 첫 번째 인자 (xi)가 첫 번째 축 (0)을 따라 매핑되고, 두 번째 인자 (y)는 변경되지 않습니다(None). 이것은 모든 연산에서 동일하게 유지됨을 나타냅니다.\n\n두 구현 모두 동일한 결과를 생성합니다. 아래 단언문은 루프를 사용한 구현으로 계산된 거리와 벡터화된 구현으로 계산된 거리가 동일함을 보장합니다.\n\n```python\nimport jax\n\n# shape=(natoms, dim)의 무작위 배열 생성\nx = jax.random.normal(jax.random.key(2024), shape=(100, 3))\n\nassert jnp.allclose(\n  calculate_distances(x, x),\n  calculate_distances_vmap(x, x)\n)\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그럼에도 불구하고, 매핑된 함수의 성능은 벡터화가 더 잘 되어있기 때문에 크게 향상되었습니다. 또한 구현이 더 읽기 쉽습니다. 시간 프로필링 결과는 다음과 같이 이러한 차이점을 분명히 보여줍니다:\n\n```js\n%timeit calculate_distances(x, x).block_until_ready()\n93.5 ms ± 6.04 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)\nSpeed up:  1x\n\n%timeit vmapped_calculate_distances(x, x).block_until_ready()\n2.54 ms ± 147 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\nSpeed up:  36x\n```\n\n우리는 이제 다시 JIT 컴파일을 jax.vmap과 결합하여 더 나은 성능을 달성할 수 있습니다.\n\n```js\njitted_vmapped_calculate_distances = jax.jit(vmapped_calculate_distances)\n\n%timeit jitted_vmapped_calculate_distances(x, x).block_until_ready()\n60.3 µs ± 1.59 µs per loop (mean ± std. dev. of 7 runs, 10,000 loops each)\nSpeed up: 1558x\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 조합은 JAX의 고급 최적화 기법을 최대한 활용하여 계산의 효율성을 극대화합니다. 이 글에서 이에 대해 논의하고자 합니다.\n\n다음 섹션에서는 JAX가 실제 문제 해결과 파이썬에서 고성능 애플리케이션을 개발하는 믿을 수 있는 프레임워크가 될 수 있는 분자동역학 쇼케이스를 소개할 것입니다.\n\n# 분자동역학 쇼케이스\n\n문서에서 명확하고 명확하게 정의된 코드 예제는 종종 복잡한 문제에 대처할 때 단점이 됩니다. 더욱 심각한 문제와 상호작용하는 것은 항상 우리의 이해력을 향상시키고 최적화된 응용 프로그램을 개발하기 위해 고급 기능을 활용할 수 있게 만들어줍니다. 분자 시뮬레이션의 복잡한 세부 사항에 심취하지 않아도 이 쇼케이스가 도움이 되었으면 좋겠습니다. 그 세부 전문 지식을 요구하는 분야에 대한 이해를 강조하기 위해 간단한 원자 시스템에 초점을 맞추어 JAX 스크립트 최적화에 필요한 주요 기능을 강조하기로 결정했습니다. 이 예는 기본 도메인 지식에 대한 더 명확한 이해를 용이하게 하기 위해 일부러 단순하게 유지되었습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## MD 시뮬레이션이란?\n\n분자동력학(MD) 시뮬레이션은 원자와 분자의 물리적 움직임을 연구하는 데 사용되는 강력한 계산 방법입니다. 이는 이러한 입자들의 움직임을 시뮬레이션하여 복잡한 시스템의 물리적 및 화학적 특성에 대한 세부적인 통찰력을 제공합니다. MD 시뮬레이션은 물리학, 화학, 재료과학과 같은 다양한 분야에서 널리 사용되며 실험적으로 포착하기 어려운 현상의 미시적인 관점을 제공합니다.\n\nMD 시뮬레이션의 중요한 부분은 힘 필드(force field)입니다. 이는 분자 시스템의 잠재 에너지를 정의하는 수학적 함수와 매개 변수들의 모음입니다. 이는 원자들이 서로 상호작용하는 방식을 결정하며, 이들의 움직임을 이끄는 힘을 제공합니다. 원자들은 뉴턴의 운동 방정식에 따라 움직이며, 이는 입자의 위치와 속도가 어떻게 시간이 지남에 따라 변하는지를 설명하며, 그들에게 작용하는 힘에 반응합니다. Verlet 알고리즘은 뉴턴의 운동 방정식을 해결하기 위한 흔히 사용되는 수치 적분 방법입니다.\n\n## 초기 구조\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nMD 시뮬레이션을 시작하려면 일반적으로 원자의 위치와 속도가 실험 구조나 무작위로 생성된 배열과 같은 특정 구성을 기반으로 초기화됩니다. 따라서 아래 코드는 ASE 패키지를 사용하여 헬륨 원자들의 간단한 입방격자 구조를 생성하고, JAX 배열에서 원자 좌표 및 관련 정보를 저장하는 컨테이너인 Pantea에 해당 구조를 만듭니다:\n\n```js\nfrom ase import Atoms\nfrom ase.visualize import view\nfrom pantea.atoms import Structure\n\nd = 6  # Angstrom 단위의 원자 간 거리\nunit_cell = Atoms('He', positions=[(d/2, d/2, d/2)], cell=(d, d, d))\ninitial_structure = Structure.from_ase(unit_cell.repeat((10, 10, 10)))\n\nview(atoms=initial_structure.to_ase(), viewer='ngl')\n```\n\n<img src=\"/TIL/assets/img/2024-07-07-WhyYouShouldLearnJAXAMolecularDynamicsShowcase_1.png\" />\n\n## 레너드-존스 힘장력\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n두 원자 간 상호 작용을 설명하기 위한 간단한 힘장 중 하나는 Lennard-Jones (LJ)입니다. 이는 약한 분자간 인력과 척력을 모델링하는 데 특히 유용합니다. 우리는 주어진 입력 구조에 대해 총 Lennard-Jones 포텐셜 에너지와 힘 성분을 계산하는 잠재 클래스를 정의해 보겠습니다.\n\n```js\nimport jax\nimport jax.numpy as jnp\nfrom jax import Array\nfrom pantea.atoms import Structure\nfrom typing import NamedTuple, Optional\n\nclass LJPotentialParams(NamedTuple):\n    epsilon: Array\n    sigma: Array\n\nclass LJPotential:\n    \"\"\"Lennard-Jones 포텐셜의 간단한 구현입니다.\"\"\"\n    def __init__(\n        self,\n        sigma: float,\n        epsilon: float,\n        r_cutoff: float,\n    ) -> None:\n        self.sigma = jnp.array(sigma)\n        self.epsilon = jnp.array(epsilon)\n        self.r_cutoff = jnp.array(r_cutoff)\n    def __call__(self, structure: Structure) -> Array:\n        \"\"\"총 포텐셜 에너지를 계산합니다.\"\"\"\n        return _compute_total_energy(\n            LJPotentialParams(self.epsilon, self.sigma),\n            structure.positions,\n            structure.lattice,\n            self.r_cutoff,\n        )\n    def compute_forces(self, structure: Structure) -> Array:\n        \"\"\"모든 원자에 대한 힘 성분을 계산합니다.\"\"\"\n        return _compute_forces(\n            LJPotentialParams(self.epsilon, self.sigma),\n            structure.positions,\n            structure.lattice,\n            self.r_cutoff,\n        )\n```\n\nLJPotentialParams는 Lennard-Jones 포텐셜을 위해 두 가지 필수 매개변수를 저장하는 네임드 튜플입니다.\n\nLJPotential 클래스는 입력 구조를 가져와 필수 인자를 두 내부 커널 함수인 \\_compute_total_energy와 \\_compute_forces로 전달하여 원하는 물리적 양을 계산하고 반환하는 역할을 실제로 담당합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기서 흥미로운 부분은 JAX 기능을 활용하여 함수를 최적화하는 것입니다. 다음으로, 에너지와 힘 계산의 핵심인 커널에 대해 별도로 설명하겠습니다.\n\n## 위치 에너지\n\n이론\n두 원자 간의 레너드-존스 포텐셜은 다음 방정식으로 정의됩니다:\n\n![equation](/TIL/assets/img/2024-07-07-WhyYouShouldLearnJAXAMolecularDynamicsShowcase_2.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nV(r)은 두 입자 간의 거리 r의 함수로 표현되는 포텐셜 에너지이다. ε 매개변수는 인력의 강도를 나타내는 포텐셜 우물의 깊이를 의미한다. σ 매개변수는 상호작용하는 입자 간의 포텐셜이 제로가 되는 유한 거리로, 원자의 유효 지름을 나타낸다. 첫 번째 항은 보통 더 긴 범위에서 우세한 인력적 반 데르 발스 힘을 설명하고, 두 번째 항은 매우 짧은 거리에서 겹치는 전자 궤도 때문의 폴리 원자간 척반을 설명한다. rcut은 포텐셜이 제로로 간주되는 거리 범위를 나타내는 절단 반경이다. 일반적으로 상호작용 범위를 제한하여 효율성과 물리적 정확성을 향상시키기 위해 절단이 사용된다.\n\nN 입자로 이루어진 시스템의 총 포텐셜 에너지 U는 모든 입자 쌍에 걸친 쌍별 상호작용의 합으로 다음과 같이 나타낼 수 있다:\n\n[테이블 태그를 마크다운 형식으로 변경합니다.]\n\n여기서, rij는 입자 i와 입자 j 사이의 거리이다. 각 입자 쌍이 한 번만 고려되도록 해야 하며 (중복 계산 없음), 자기 상호작용은 무시해야 한다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n구현\n아래의 Python 코드는 원자 쌍 간의 Lennard-Jones 포텐셜 에너지를 계산하는 함수를 정의합니다.\n\n```js\ndef _compute_pair_energies(params: LJPotentialParams, r: Array) -> Array:\n    term = params.sigma / r\n    term6 = term**6\n    return 4.0 * params.epsilon * term6 * (term6 - 1.0)\n```\n\n\\_compute_pair_energies 함수는 주어진 거리 (r)에 따른 원자 쌍의 Lennard-Jones 포텐셜 에너지를 계산합니다. 이 함수는 포텐셜 매개변수 (params)를 사용하고 계산 (식 1)을 수행하여 포텐셜 에너지의 배열을 반환합니다.\n\n다음으로, 우리는 아래와 같이 원자 시스템의 총 Lennard-Jones 포텐셜 에너지를 계산하기 위한 JIT 컴파일된 함수를 정의합니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport jax\nimport jax.numpy as jnp\nfrom pantea.atoms.neighbor import _calculate_masks_with_aux_from_structure\n\n@jax.jit\ndef _compute_total_energy(\n    params: LJPotentialParams,\n    positions: Array,\n    lattice: Optional[Array],\n    r_cutoff: Array,\n) -> Array:\n    masks, (rij, _) = _calculate_masks_with_aux_from_structure(\n        positions, r_cutoff, lattice\n    )\n    pair_energies = _compute_pair_energies(params, rij)\n    pair_energies_inside_cutoff = jnp.where(masks, pair_energies, 0.0)\n    return 0.5 * jnp.sum(pair_energies_inside_cutoff)\n```\n\n\\_calculate_masks_with_aux_from_structure 함수는 불리언 배열(masks)을 계산하여 각 원자 쌍이 cutoff 거리 내에 있는지를 나타내는데, 자기 상호작용은 제외됩니다. 또한 원자 쌍 간의 거리를 담은 배열(rij)을 반환하여, pair potential 평가를 위해 이 거리를 재계산하는 것을 피합니다. 이 함수는 Pantea에서 가져온 것이며, 이를 통해 토론을 간소화합니다. 거리를 계산하기 위해, 시뮬레이션 상자의 주기적 경계 조건(lattice)도 고려됩니다.\n\n이전에 설명한 대로, \\_compute_pair_energies 함수는 잠재 에너지 매개변수와 거리(rij)를 사용하여 각 원자 쌍의 LJ 포텐셜 에너지를 계산합니다.\n\njnp.where는 masks를 적용하여 cutoff 거리 밖에 있는 원자 쌍에 대한 에너지를 0으로 설정하는 데 사용됩니다. 이 메서드는 루프를 사용하지 않고 배열에 조건부 논리를 효율적으로 적용합니다. np.where는 내부적으로 고도로 최적화된 C 코드로 구현되어 있습니다. 한꺼번에 전체 배열에 작용하여 벡터화된 작업을 수행할 수 있는 JAX의 능력을 활용합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n총 에너지는 jnp.sum을 사용하여 반환됩니다. 각 쌍의 상호 작용이 두 번 계산되기 때문에 0.5를 곱하여 계산합니다. 각 쌍이 두 번 고려되기 때문에 0.5를 곱해서 각 쌍의 상호 작용을 총 에너지로 계산합니다.\n\n간단히 말해서 \\_compute_total_energy 함수는 원자 시스템의 전체 Lennard-Jones 포텐셜 에너지를 계산합니다. 먼저, 두 원자 쌍이 cutoff 거리 내에 있는지를 결정하기 위해 부울 마스크를 생성합니다. 그런 다음, rij를 사용하여 모든 쌍에 대한 레너드-존스 에너지를 계산하고, cutoff 내부의 쌍 에너지를 필터링하여 cutoff 거리를 고려한 쌍 에너지를 합산합니다. 이 함수는 원자 위치에 기초하여 총 상호 작용 에너지를 제공하는 MD 시뮬레이션에서 중요한 역할을 합니다.\n\n원자별로 쌍 에너지를 계산해야 한다면 비효율적으로 보일 수 있습니다. 과거에는 이를 피하기 위해 if 문을 추가했지만, 이 구현에 비해 성능이 상당히 떨어지는 것을 발견했습니다. 이 구현은 벡터화된 계산을 사용하며, 전통적인 저수준 언어 접근 방식에서 벗어나 핵심 계산을 위해 배열 계산에 중점을 둘 필요가 있음을 강조합니다. C/C++로 모든 것을 최적화하려면 몇 일이 걸릴 수 있지만, Python의 이 방법을 통해 벡터화를 통해 훨씬 더 나은 성능을 달성하고 개발 시간을 크게 단축할 수 있습니다. 게다가, JAX 작업은 내부적으로 병렬화되어 있으며 실행 시간을 더 최적화하기 위해 여러 스레드를 활용합니다.\n\n아래 예시 코드는 1000개의 원자를 포함하는 입력 구조체에 대한 총 포텐셜을 계산하는 방법과 예상 실행 시간을 보여줍니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nljpot(initial_structure)\n# Array(-0.00114392, dtype=float64)\n\n%timeit ljpot(initial_structure).block_until_ready()\n5.12 ms ± 38.9 µs per loop (mean ± std. dev. of 7 runs, 100 loops each))\n```\n\n## Force vector\n\n이론\n레너드-존스 시스템 내 두 입자 사이의 힘은 포텐셜 에너지에서 유도될 수 있습니다. i 입자에 대한 입자 j로 인한 힘 벡터 Fij는 레너드-존스 포텐셜 V(rij)의 음의 그래디언트로 주어집니다:\n\n<img src=\"/TIL/assets/img/2024-07-07-WhyYouShouldLearnJAXAMolecularDynamicsShowcase_4.png\" />\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nrij = ri — rj은 j 입자에서 i 입자를 가리키는 벡터를 나타냅니다. 우리는 힘에 대한 cutoff도 적용합니다. 입자 i에 작용하는 총 힘을 계산할 때, 다른 모든 입자 j로부터의 기여를 합산합니다:\n\n![image](/TIL/assets/img/2024-07-07-WhyYouShouldLearnJAXAMolecularDynamicsShowcase_5.png)\n\n이는 시스템 내의 다른 모든 입자들로 인해 입자 i에 작용하는 순 힘을 제공하면서 자기 상호작용은 제외합니다.\n\n구현\n아래 코드는 Equation 3을 사용하여 원자 쌍 간의 힘을 계산합니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ndef _compute_pair_forces(params: LJPotentialParams, r: Array, R: Array) -> Array:\n    term = params.sigma / r\n    term6 = term**6\n    coefficient = -24.0 * params.epsilon / (r * r) * term6 * (2.0 * term6 - 1.0)\n    return jnp.expand_dims(coefficient, axis=-1) * R\n```\n\n\\_compute_pair_forces 함수는 레너드-존스 포텐셜을 사용하여 원자 쌍 간의 힘을 계산합니다. 이 함수는 잠재력 정의 매개변수, 원자 쌍 간의 거리 및 상대적인 위치 벡터를 입력으로 받습니다.\n\njnp.expand_dims(factor, axis=-1) \\* R: 상대적인 위치 벡터 R을 계산된 힘 인자로 확장하고, 곱셈 방송에 적합한 차원을 보장하기 위해 expand_dims를 사용합니다. 결과 배열은 각 원자 쌍 간의 힘을 나타냅니다.\n\n다음으로, 우리는 다음과 같이 방정식 4를 사용하여 총 힘을 계산합니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\n@jax.jit\ndef _compute_forces(\n    params: LJPotentialParams,\n    positions: Array,\n    lattice: Optional[Array],\n    r_cutoff: Array,\n) -> Array:\n    masks, (rij, Rij) = _calculate_masks_with_aux_from_structure(\n        positions, r_cutoff, lattice\n    )\n    pair_forces = _compute_pair_forces(params, rij, Rij)\n    pair_forces_inside_cutoff = jnp.where(\n        jnp.expand_dims(masks, axis=-1),\n        pair_forces,\n        jnp.zeros_like(Rij),\n    )\n    return jnp.sum(pair_forces_inside_cutoff, axis=1)\n```\n\n\\_compute_forces 함수는 최적화를 위해 JIT 컴파일로 각 원자에 작용하는 총 힘을 계산합니다.\n\n\\_calculate_masks_with_aux_from_structure 함수는 cutoff 불리언 마스크를 계산하고 더불어 페어와이즈 거리 (rij) 및 상대적인 위치 벡터 (Rij)를 반환합니다.\n\njnp.where 함수는 마스크가 True일 때에만 계산된 페어 힘을 적용합니다. jnp.expand_dims(masks, axis=-1)는 브로드캐스팅을 위해 마스크 차원이 Rij와 일치하도록 합니다. 마스크가 False일 때는 0 힘 벡터를 할당합니다 (jnp.zeros_like(Rij)). 또한 JAX는 오버헤드를 줄이기 위해 메모리 풀을 사용하므로 제로 크기 벡터를 할당하는 것은 계산적으로 비용이 크지 않습니다. 배열에 대한 참조 재할당은 OS로부터 실제 메모리 할당이 포함되지 않기 때문입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마지막으로, jnp.sum(pair_forces, axis=1)를 반환하면 각 원자에 작용하는 총 힘을 계산하여 모든 다른 원자를 고려합니다.\n\n상자 내 모든 원자의 힘 구성 요소를 계산하고 실행 시간을 측정하는 유사한 예제 코드:\n\n```js\nljpot.compute_forces(initial_structure)\n# Array([[ 1.11173074e-21,  1.11173074e-21,  1.11173074e-21],\n#       ...,\n#       [-1.87935435e-21, -1.87935435e-21, -1.87935435e-21]],  dtype=float64)\n\n%timeit ljpot.compute_forces(initial_structure).block_until_ready()\n6.71 ms ± 4.63 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\n```\n\n지금까지 잘 진행되고 있어요!\n여기까지 우리는 MD 시뮬레이션에 필요한 Lennard-Jones 포텐셜의 JAX 버전을 구현했습니다. 다음 단계는 이 포텐셜과 초기 구조를 사용하여 시스템을 시간에 따라 시뮬레이션하는 것입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 분자동력학 시뮬레이션\n\n시스템을 시뮬레이션하기 위해 Pantea에 있는 MDSimulator 모듈을 사용합니다. 이 모듈은 시뮬레이션이 어떻게 진행될지를 정의하며, 적분 알고리즘, 열장치 및 필요한 기타 시뮬레이션 설정을 포함합니다. 시스템을 일정한 온도에서 시뮬레이션하므로 온도조절기를 정의하는 것이 필요합니다.\n\n다음 매개변수를 사용하여 MD 시뮬레이터를 초기화해 봅시다:\n\n```js\nfrom pantea.simulation import MDSimulator, BrendsenThermostat\n\ntime_step = 0.5 * units.FROM_FEMTO_SECOND      # 0.5e-15 초\nthermostat = BrendsenThermostat(               # 온도 제어\n  target_temperature=300.0,                    # 26도의 상온\n  time_constant=100 * time_step                # 온도 조절 속도\n)\nsimulator = MDSimulator(time_step, thermostat)\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음으로, 우리는 사실 원자들과 그들 사이의 상호 작용을 단순히 표현한 시스템을 만들 것입니다. 이 시스템은 원자의 위치, 속도, 그리고 상호 작용 매개 변수와 같은 정보를 포함합니다. 입력 구조로부터 시스템을 다음과 같이 생성할 수 있습니다:\n\n```js\nfrom pantea.simulation import System\n\nsystem = System.from_structure(\n  initial_structure,   # 원자의 초기 위치\n  potential=ljpot,     # 상호 작용을 LJ로 설정\n  temperature=300.0    # 온도에 기반하여 원자 속도 초기화\n)\n```\n\n마지막으로, MD 시뮬레이션을 실행하기 위해 simulate 함수를 호출합니다.\n\n```js\nfrom pantea.simulation import simulate\n\n# simulate(sys, simulator) # 워밍업 단계\nsimulate(system, simulator, num_steps=10000, output_freq=1000)\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nnum_steps=10000: 이 매개변수는 수행할 총 시뮬레이션 단계의 수를 설정합니다. 각 단계는 일반적으로 시뮬레이션된 시간의 작은 증가에 해당하며 해당 기간 동안 원자의 위치와 속도가 업데이트됩니다.\n\noutput_freq=1000: 이 매개변수는 시뮬레이션 결과를 얼마나 자주 출력할지 지정합니다. 이 경우 데이터는 1000개의 시뮬레이션 단계마다 저장되거나 출력됩니다.\n\n결과적으로 각 1000단계 후에 단계, 온도, 포텐셜 에너지 및 압력과 같은 물리적 특성을 출력합니다.\n\n![링크 텍스트](/TIL/assets/img/2024-07-07-WhyYouShouldLearnJAXAMolecularDynamicsShowcase_6.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래 그림은 주기 상자 내의 1000개 헬륨 원자를 사용한 MD 시뮬레이션의 시간 진화를 설명합니다:\n\n![그림](https://miro.medium.com/v2/resize:fit:1400/1*7S2L0PRoZSHhxMf3UtIvxA.gif)\n\n성능\n아래 그래프에서 볼 수 있듯이, 우리의 JAX 커널은 GPU (장치 1)의 거의 전체 용량을 효율적으로 활용하여 시뮬레이션을 수행합니다. 이 높은 수준의 자원 이용은 GPU의 계산 성능이 최대화되어 시뮬레이션의 속도와 성능이 크게 향상되는 것을 보장합니다.\n\n![그림](/TIL/assets/img/2024-07-07-WhyYouShouldLearnJAXAMolecularDynamicsShowcase_7.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저는 노트북 CPU와 더 강력한 GPU인 A100에서 동일한 MD 시뮬레이션을 수행했습니다. 결과는 GPU 계산으로 인한 상당한 속도 향상을 보여줍니다. GPU 하드웨어 사용의 중요성을 강조하기 위해 원자가 2000개인 시스템을 시뮬레이션했습니다. JAX의 훌륭한 기능 중 하나는 원본 코드를 수정하지 않고 CPU에서 GPU로 코드 실행을 원활하게 전환할 수 있다는 것이며, 이는 상당한 시간과 노력을 절약할 수 있습니다.\n\n![image](/TIL/assets/img/2024-07-07-WhyYouShouldLearnJAXAMolecularDynamicsShowcase_8.png)\n\n나노초당 일은 MD 시뮬레이션의 성능과 효율성을 나타내는 일반적인 측정 지표로, 시뮬레이션이 얼마나 빠르게 진행되는지를 보여줍니다. 그림에서 나타나듯이 GPU 가속 컴퓨팅은 코드의 성능을 수십 배 향상시킬 수 있습니다. 대규모 시뮬레이션의 경우, 도메인 분해를 사용하여 시스템을 병렬화하는 것이 최적의 접근 방식입니다. 이 방법을 사용하면 각 도메인은 제한된 GPU 메모리 요구 사항을 가지고 힘을 계산하고 원자 상태를 업데이트하는 데 사용할 수 있습니다.\n\n# 마무리\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 게시물이 여러분의 호기심을 자극하고 JAX를 탐구하고 배우며 여러분의 프로젝트에 적용하는 데 도움이 되기를 바랍니다.\n\n아래 링크된 저장소를 통해 JAX와 함께 하는 내 Pantea 프로젝트에 대해 더 알아보실 수 있습니다. 거기서는 JAX의 자동 미분 기능을 널리 활용하고 있습니다. 이 작업은 아직 진행 중이며 피드백이나 의견을 환영합니다.\n\n읽어주셔서 감사합니다. JAX를 더 깊이 파고들어 작업에 최대한의 잠재력을 발휘하도록 장려합니다!\n","ogImage":{"url":"/assets/img/2024-07-07-WhyYouShouldLearnJAXAMolecularDynamicsShowcase_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-WhyYouShouldLearnJAXAMolecularDynamicsShowcase_0.png","tag":["Tech"],"readingTime":31},{"title":"코스 파이썬으로 퀀트 트레이더 되기 - 최고 품질 데이터 얻는 방법","description":"","date":"2024-07-07 12:49","slug":"2024-07-07-CourseBecomeaQuantTraderwithPythonHowtoGetTopQualityData","content":"\n![이미지](/TIL/assets/img/2024-07-07-CourseBecomeaQuantTraderwithPythonHowtoGetTopQualityData_0.png)\n\n주식 거래를 위해 Python으로 알고리즘을 코딩하기 시작하는 경우, 가장 중요한 질문은 무엇을 찾고 어디서 찾을지입니다. 저는 정확히 그것을 연구하는 데 상당한 시간을 할애했고 도움을 줄 수 있습니다.\n\n이 기사에서는 승리를 창출하는 알고리즘을 만들기 위해 필요한 모든 것을 담은 매우 포괄적인 데이터프레임을 구축할 것입니다. 그리고 더 중요한 점은 여기에서 공유하는 코드가 데이터의 다른 시간대를 가져오기에 매우 쉽게 적응할 수 있도록 설계된 것입니다. 따라서 필요할 때 작업을 가속화하는 데 도움이 될 것입니다.\n\n우선, 주식 데이터를 가지고 있는 다양한 API가 있지만, 양적 분석을 위해 알파베티지(https://www.alphavantage.co/)를 추천할 것입니다. 왜냐하면 이미 다양한 지표가 계산되어 있고 1분 단위의 투자자에게 필요한 내부 시장성에 대한 데이터도 제공하기 때문입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 데이터 가져오기\n\n다음 코드 조각은 선택한 티커에 대한 데이터를 자동으로 가져와 데이터프레임으로 연결합니다:\n\n```js\n!pip install alpha_vantage\nfrom datetime import datetime\nfrom datetime import timedelta\n\nfrom alpha_vantage.timeseries import…\n```\n","ogImage":{"url":"/assets/img/2024-07-07-CourseBecomeaQuantTraderwithPythonHowtoGetTopQualityData_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-CourseBecomeaQuantTraderwithPythonHowtoGetTopQualityData_0.png","tag":["Tech"],"readingTime":2},{"title":"내 GSoC 여정  1단계","description":"","date":"2024-07-07 12:47","slug":"2024-07-07-MyGSoCJourneyPhase1","content":"\n제가 말한 블로그 시리즈의 첫 부분을 아직 확인하지 않으셨다면 확인해주세요. 이것은 필수는 아니지만 일부 맥락을 제공합니다.\n\n# 소개 - PictoPy\n\nPictoPy는 디지털 사진의 처리 방식을 혁신적으로 바꿔주기 위해 설계된 현대적인 데스크탑 앱입니다. 이 앱은 사물, 얼굴 또는 장면을 기반으로 한 사진에 대한 스마트 태깅 기능을 제공하여 효율적인 갤러리 관리를 용이하게 해줍니다.\n\n이 프로젝트는 AOSSIE에 의해 발표되었으며 처음부터 구현되기로 했습니다. 이는 Google 사진과 유사하게 객체 감지 및 얼굴 유사성과 같은 기능을 제공합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 배경\n\nGSoC 이전에 프로젝트에 몇 개의 Pull Request를 이미 제출했습니다. 우리가 무엇을 하려고 하는지 이해하려 머리를 쥐어뜯았습니다. 이 Pull Request에는 주로 Google Colab에서 다양한 유형의 모델을 테스트하고 마지막으로 출력을 제공하고 추론 속도를 벤치마킹하는 것이 포함되었습니다.\n\n당시, 물체 탐지 및 얼굴 탐지를 위해 다양한 모델을 탐구했습니다. 우리가 시도한 첫 번째 모델은 Ultralytics의 YOLOv8 모델이었습니다. 이 모델은 훌륭한 추론 속도와 많은 온라인 자습서를 가지고 있어서 바로 이것을 사용할 수 있을 것이라는 것이 명백했습니다. 이 프로젝트는 처음부터 만들어지고 있기 때문에 시작할 때 모든 것을 결정하고 확정하기가 매우 어렵습니다.\n\n그러나 얼굴 탐지 및 인식은 더 어려웠습니다. 얼굴 임베딩과 유사성 측정을 제공하는 많은 라이브러리와 모델이 있었습니다. 당시에 직면한 공통 문제 중 하나는 어린이의 얼굴을 잘 탐지하지 못하는 것이었습니다(예: 파이썬의 facial_recognition 라이브러리). 모든 유형의 얼굴을 탐지할 수 있는 몇 가지 모델이 있었지만, 이러한 모델들은 유사성 성능이 우수했습니다. 우리는 궁극적으로 결정을 내렸습니다. 얼굴 탐지에는 다른 라이브러리를 사용하고, 얼굴 인식에는 다른 라이브러리를 사용할 것입니다. 두 가지 모두 최고의 성과를 얻을 수 없었으므로, 우리가 선택한 얼굴 탐지 모델은 yolo-face 모델이었고, 이 모델에서 얼굴을 자르고 정렬한 후 임베딩을 추출하여 face recognition에 전달했습니다. facial_recognition 라이브러리는 이를 잘 수행했습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지금까지 우리는 애플리케이션에 후보가 될 수 있는 몇 가지 모델을 가지고 있었고 마인드에 워크플로우도 있었습니다. 아마도 전면 갤러리 측면에 대해 아직 논의하지 않았을 것을 알아채셨을 것입니다. 단지 백엔드 부분(특히 CNNs)에 대해 더 관심이 있었기 때문입니다. 백엔드에서 기반 준비가 되면 앱 갤러리를 생성하여 API 호출을 할 수 있을 만큼 React(및 Electron)을 사용하는 방법을 알고 있었으며 백엔드 준비가 되었을 때 구현할 수 있을 것이라고 확신했어요. 또한 공개 소스 세계에서는 언제든지 누군가가 도와줄 것이므로 그때는 프론트엔드로 걱정할 필요가 없었습니다. 디자인에 있어서는 나보다 더 창의력과 기술을 가진 사람들이 분명히 있기 때문이죠. 그럼에도 불구하고 제 제안서에는 프로젝트의 프론트엔드와 백엔드 부분을 어떻게 다룰 것인지 언급했고 가끔가다 제가 쓴 내용을 다시 상기시키기 위해 그것을 다시 참고했습니다.\n\nGSoC 참여자가 발표된 후 PictoPy에는 저 외에 두 명의 사람이 선택되었습니다. 이로써 우리 모두가 이 프로젝트를 다양한 각도에서 접근하고 충분히 아이디어 회의를 진행할 수 있었습니다. 커뮤니티 결속 기간 동안 우리는 멘토와 빈도 있는 회의를 갖고 최종 제품을 위한 기술 스택, 아키텍처 및 디자인에 대해 논의했어요. 최종 선택 수에 따라 목표가 변경되어 우리 모두는 계획을 재정의하고 작업을 분배해야 했습니다.\n\n# 우리의 접근\n\n## 1. 설정\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n백앤드에서는 다른 프로젝트에서 가져온 스타터 FastAPI 코드를 설정했어요. 이것에는 표준 디렉토리 구조 및 명명 규칙과 Linux에서는 uvcorn을 사용하여 bash 스크립트에서 빠르게 실행되는 앱, Windows에서는 bat 파일이 포함되어 있었어요.\n\n멘토와 프로젝트의 스키마를 논의하면서 객체 탐지 모델을 찾았어요. 우리가 직면한 한 가지 문제는 라이브러리의 크기가 최종 제품 측면에서 다소 크다는 것이었어요. Ultralytics 라이브러리 (PyTorch를 사용하는)는 5GB 크기의 가상 환경과 함께 제공되었는데, 이를 cpu 모드로 설치하면 이 크기가 2GB로 줄었어요.\n\n2GB는 여전히 많은 것 같았어요. 우리가 필요한 모델이 약 80MB 크기면서도요. 그때 ONNX 형식에 대해 알게 되었어요. 이것은 큰 도움이 되었고, 우리는 대략 400MB의 가상 환경과 우리가 사용하는 모델 크기를 더한 객체 탐지 모델을 설정할 수 있었어요.\n\n![image](/TIL/assets/img/2024-07-07-MyGSoCJourneyPhase1_0.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n요거 간단해졌네요. 이제 우리는 사용하는 모델들의 ONNX 형식과의 호환성을 찾아야 한다는 것을 알았고, 그것을 다시 사용할 수 있었으며, 마침내 애플리케이션 크기를 어느 정도로 컨트롤할 수 있게 된 것 같아요.\n\n## 2. 병렬 처리를 이용한 라우팅 로직\n\n라우팅 로직을 다루면서, 우리는 FastAPI를 사용하고 있었기 때문에 프론트엔드에서의 요청이 블로킹되지 않도록 하는 방법을 찾아야 했어요. 다시 말해, 프론트엔드는 이미지 처리가 끝날 때까지 기다리지 않아야 했고, 갤러리에 더 많은 사진을 추가할 수 있어야 했어요. 갤러리에 사진을 추가하고 프론트엔드에 표시하는 것은 이 사진들을 처리하고 클래스를 감지하는 것보다 훨씬 빠른 단계예요. 이는 백엔드에서 실행될 수 있기 때문이죠.\n\n이런 결정들은 나중에 이 백엔드가 미래의 다른 어플리케이션과 호환이 되도록 하기 위해 적절한 엔드포인트를 제공하고 프론트엔드와의 낮은 결합 디자인을 유지하는 것을 염두에 두고 내려졌어요. 이를 위해 우리는 우리의 갤러리 앱에 추가된 여러 이미지를 병렬로 처리하는 방법을 찾아야 했어요. 그때 우리는 파이썬의 스레딩과 같은 옵션들을 시도해보았는데, 그때는 파이썬에서 한 번에 하나의 스레드만 실행할 수 있는 Global Interpreter Lock에 대해 알 지 못했었어요. 이에 대해 더 읽고 싶다면 아래에서 공유한 자료들을 따라보세요. 이외에도 우리는 애플리케이션에 복잡성을 도입한 multiprocessing 라이브러리를 사용해 보기도 했어요. 우리는 FastAPI와 uvicorn 그리고 기본적으로 하나의 워커 프로세스로 실행되는 gunicorn 워커를 사용하고 있었는데, multiprocessing을 실행하기 위해 각각 FastAPI 애플리케이션의 인스턴스를 갖는 여러 워커 프로세스를 구성해야 했고, uvicorn을 사용함으로써 교차 플랫폼 호환성 문제에 부딪히기도 했었어요. 결국 우리는 hypercorn을 사용하게 되었어요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마침내, 우리는 asyncio를 사용하기로 결정했어요. FastAPI는 asyncio를 완전히 지원하는 비동기 웹 프레임워크인 Starlette 위에서 구축되었어요.\n\n![이미지](/TIL/assets/img/2024-07-07-MyGSoCJourneyPhase1_1.png)\n\n이러한 결정들은 커뮤니티, 팀 및 멘토의 피드백을 기반으로 시간이 지남에 따라 개선되었어요.\n\n## 3. 데이터베이스 설계\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n전통적인 이미지 갤러리 데스크톱 애플리케이션으로, 구조화된 방식으로 작업을 수행하기 위해 일종의 데이터베이스 스키마가 필요했습니다. 이미지에 대한 경로를 키로 원래 저장하면서(이는 클라이언트로부터의 페이로드이기도 합니다), 이미지를 처리하여 모델이 감지한 클래스를 기반으로 해당 객체에 속하는 인덱스를 추가했습니다. 이미지의 메타데이터(생성 날짜, 크기, 형식 등)도 저장하고, 미래에는 이미지에서 발견된 얼굴 임베딩 목록(파란색으로 표시)을 저장할 예정입니다.\n\n![이미지](/TIL/assets/img/2024-07-07-MyGSoCJourneyPhase1_2.png)\n\n이렇게 구성된 상태에서 우리는 앨범 스키마를 정의하여 앞으로 나아갔는데, 이는 많은 이미지와 일부 앨범 기능으로 이루어져 있었습니다. 여기서 주요 키는 앨범 이름 자체이며, 사용자가 필요한 경우 제공할 수 있는 간단한 설명이 함께 포함된 앨범의 경로입니다.\n\n![이미지](/TIL/assets/img/2024-07-07-MyGSoCJourneyPhase1_3.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리 갤러리 앱의 특성과 모델과의 호환성 때문에 이러한 스키마는 시간이 지남에 따라 계속 변화합니다. 더 구체적인 매핑을 얻기 위해 더 많은 스키마를 생성할 계획이며, 예를 들어 이미지 경로의 숫자/uuID를 포함하는 별도의 테이블을 생성하여 이를 모든 곳에서 주 키로 사용할 예정입니다. 미래에 예상되는 어려움 중 하나는 사용자가 파일 시스템을 통해 응용 프로그램 외부에서 이미지를 수동으로 삭제하는 경우에 대처해야 할 것입니다.\n\n# 우리의 미래 목표\n\n다양한 얼굴 인식 모델을 탐색하면서 이러한 모델이 ONNX 형식과 호환되는지 확인해야 했습니다. 이를 위해 ONNX 저장소에는 그러한 인식 모델의 예제가 있습니다. arcface가 그 중 하나입니다. 이것이 우리가 필요한 바로 그것이며, 우리 애플리케이션에 이를 통합할 것입니다.\n\n우리가 흔히 하는 작업 흐름 중 하나는 아이디어를 고안하는 것, 이 아이디어에 대한 모델을 찾는 것, 이러한 모델의 ONNX 형식 지원을 찾는 것, 그리고 이를 통합하는 것입니다. 이 작업에 OpenVINO를 사용하는 것이 좋았습니다. 훌륭한 문서와 모델을 실행하는 데 사용할 수 있는 예제 노트북이 포함된 Model Zoo가 제공되었습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이것은 우리 응용 프로그램에 많은 가능성을 열어 주었습니다. Linux, Windows 및 MacOS에서 런타임을 사용하여 교차 플랫폼 호환성을 보장할 수 있습니다. 이것은 다양한 모델을 제공하며 중간 표현(IR)으로 변환하여 사용할 수 있습니다. 다행히도 arcface는 OpenVINO에서 문서화 된 모델 중 하나였습니다. 우리는 정렬 없이 LFW 데이터셋의 이러한 모델들을 테스트한 결과 얼굴 모델의 사이즈가 약 200MB 정도일 때 꽤 잘 동작합니다. 이것은 얼굴 정렬과 landmark detection (눈, 코, 입 등)을 위한 MTCNN을 지원하며, 우리는 이를 향후 통합할 계획입니다.\n\n나중에 이러한 임베딩을 사용하여 비슷한 얼굴을 포함하는 사진을 클러스터링하여 사용자에게 구글 포토와 유사하게 특정인의 이미지를 반환하는 옵션을 제공할 수 있습니다. OpenVINO를 사용한다면 저장한 태그에 기반한 검색 기능도 추가할 수 있습니다.\n\n# 도전과 배운점\n\n내가 처음에 제안한 계획과는 달리, 환경 및 런타임의 변화로 인해 위에 설명한 기술들이 다르게 진행되었습니다. 이는 ONNX 및 OpenVINO의 문서를 찾아본 적이 없기 때문에 어려움을 겪은 첫 번째 경험이었습니다. 팀원들이 직면한 어려움과 그들이 그것을 해결하는 방법을 알게 된 것 또한 좋은 경험이었습니다. 파이썬에서의 다중 처리에 대해 사전에 알지 못했고, 동시성에 대한 초기 접근 방식이 달라졌기 때문에 지속적인 도전은 앞으로 이 프로젝트에 참여할 다른 기여자들을 고려하여 결정을 내리는 것이었습니다. 저는 딥러닝 모델을 기반으로 개발된 도구들과 Python 언어 전반에 대해 더 강한 이해를 가지게 되었습니다. 이러한 배움들을 다른 부수 프로젝트와 학업 프로젝트에도 적용할 수 있었으며, 전체적으로 배우는 것이 정말 즐거웠습니다. 이 프로젝트에서 작업하는 동안 참고한 자료 목록을 추가하고, 여러분에게도 도움이 되기를 바랍니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 자원\n\n- 객체 검출을 위한 Ultralytics YOLO 모델\n- ONNX 형식의 YOLOv8 모델 사용 예시를 보여주는 저장소\n- ORM에 관한 블로그\n- YOLOv8 얼굴 모델\n- ONNX 모델의 모음\n- OpenVINO Toolkit의 Open Model Zoo\n- asyncio, concurrency 및 GIL에 대한 Real Python 튜토리얼\n- 이미지에서 메타데이터 추출에 대한 Python 코드 튜토리얼\n\n이 블로그 시리즈의 첫 번째 부분을 이 링크에서 확인하지 않으셨으면 확인하세요. 그리고 이 블로그 시리즈의 다음 부분을 기대해 주세요. GitHub 및 LinkedIn에서 저와 연락할 수 있습니다. 읽어 주셔서 감사합니다!\n","ogImage":{"url":"/assets/img/2024-07-07-MyGSoCJourneyPhase1_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-MyGSoCJourneyPhase1_0.png","tag":["Tech"],"readingTime":9},{"title":"프로처럼 파이썬 폼 만드는 방법","description":"","date":"2024-07-07 02:31","slug":"2024-07-07-HowtoMakePythonFormsasaPro","content":"\r\n<img src=\"/TIL/assets/img/2024-07-07-HowtoMakePythonFormsasaPro_0.png\" />\r\n\r\n과거에 설문은 데이터 수집의 효과적인 수단이었지만, 오늘날의 빠른 세상에서는 사람들이 길거리에서 질문에 답변하기 위해 멈추기에는 너무 바쁘다. 인터넷을 둘러보는 동안 온라인 양식을 작성하는 것이 그들에게 더 편리하며, 출근길에 낯선 사람에게 5분을 할애하는 것보다 더 나은 방법이다. 결과적으로, 회사와 개인은 이제 사람들에게 접근하는 대신 Google Forms와 같은 디지털 도구를 사용하고 있다.\r\n\r\nGoogle Forms은 실제로 굉장히 유용한 도구이다. 무료이며 사용하기 매우 쉽고 누구에게나 접근 가능하다. 또한 데이터 분석 및 원활한 내보내기 옵션과 같은 고급 기능을 제공한다. 그러나, 빌더들은 내장 위젯과 몇 가지 사용자 정의 기능에 국한되어 있어서, 눈길을 떼게 할 만한 양식보다는 다소 매력이 떨어지는 양식을 만들게 된다.\r\n\r\nJotform, Formly, Canva와 같은 다른 옵션들도 Google Forms보다 더 많은 사용자 정의 기능과 매력적인 디자인을 제공하지만, 이들은 가격이 따른다는 단점이 있다. 그러므로 누구나 지불하기를 원하지 않을 수도 있을 것이다.\r\n","ogImage":{"url":"/assets/img/2024-07-07-HowtoMakePythonFormsasaPro_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-HowtoMakePythonFormsasaPro_0.png","tag":["Tech"],"readingTime":1},{"title":"로컬에서 LLM 실행하는 방법","description":"","date":"2024-07-07 02:31","slug":"2024-07-07-RunningLLMLocally","content":"\nTransformer 아키텍처의 소개로 자연어 처리에서 중요한 전환점이 시작되었습니다. 많은 주요 언어 모델이 지금은 이를 주요 아키텍처로 사용하고 있어요. 우리가 알다시피 큰 언어 모델(LLM)은 우리 삶을 더 쉽게 만들어줍니다.\n\nLLM 모델의 크기를 생각해보세요. GPT-3은 1750억 개의 파라미터를 가지고 있고, 각각 16비트(2바이트)의 크기를 가지고 있어요. 약 350GB의 저장 공간이 필요합니다. 다른 모델들 중에는 1조를 초과하는 파라미터 크기가 있는 것도 많아요. 그래서 계산량이 매우 많습니다. 로컬에서 실행하는 것을 상상하기도 어렵죠.\n\n하지만, 이 기사는 모두 Ollama 프레임워크에 관한 것입니다. 이를 사용하여 대규모 언어 모델을 로컬에서 실행할 수 있어요.\n\nOllama는 Llama 3, Mistral 등 다양한 대규모 언어 모델을 운영할 수 있게 해주는 오픈 소스 플랫폼입니다. 또한 애플리케이션에 맞게 모델을 사용자 정의하고, 쉽게 제품에 배포하는 것까지 가능하도록 해줘요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/TIL/assets/img/2024-07-07-RunningLLMLocally_0.png\" />\n\n여기서는 다른 모델들을 실행하는 유사한 프로세스를 따라 우리의 로컬 시스템에서 Llama3 모델 실행에 초점을 맞춥니다.\n\nOllama는 Windows, Linux 및 macOS와 호환됩니다. 다운로드하기 위해 아래 링크를 사용하십시오.\n\nMac: https://ollama.com/download/mac\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nLinux: [https://ollama.com/download/linux](https://ollama.com/download/linux)\n\nWindows: [https://ollama.com/download/windows](https://ollama.com/download/windows)\n\nLet’s try LLama 3:\n\n- Refer to the article link: [https://ollama.com/library/llama3:8b](https://ollama.com/library/llama3:8b). It has all the information about the model size, variants, benchmark, and API information.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n먼저 컴퓨터의 명령 프롬프트에 \"ollama --version\"을 입력하여 설정이 올바르게 되어 있는지 확인하십시오.\n\n![image](https://miro.medium.com/v2/resize:fit:996/1*WXzD_p2lBl1vK4wMStW8Ug.gif)\n\nLlama 3 다운로드 :\n\n채팅/대화 사례 모델을 다운로드하려면 \"ollama pull llama3\" 명령을 사용하십시오.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다른 모델 목록은 여기에서 확인할 수 있어요: https://ollama.com/library. 동일한 명령어를 사용하여 다른 모델을 가져와서 사용할 수 있어요.\n\n![RunningLLMLocally_1](/TIL/assets/img/2024-07-07-RunningLLMLocally_1.png)\n\nLlama 3 실행:\n\n“llama run llama3” 명령을 사용하여 모델을 직접 실행할 수 있어요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/TIL/assets/img/2024-07-07-RunningLLMLocally_2.png\" />\n\nAPI 사용 방법:\n\n만약 동일한 모델을 위해 API를 사용하고 싶다면, 몇 가지 간단한 단계를 따라주세요.\n\n- \"ollama serve\"를 사용하여 로컬 서버를 시작하세요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/TIL/assets/img/2024-07-07-RunningLLMLocally_3.png)\n\n- 이제 \"curl\"이나 다른 코드를 사용하여 요청을 보낼 수 있습니다. 여기서는 Postman 도구를 사용하여 llama3 모델에 요청했습니다.\n\n![이미지](/TIL/assets/img/2024-07-07-RunningLLMLocally_4.png)\n\n- 이 요청과 함께 전달할 수 있는 다른 매개변수도 있습니다. 자세한 API를 탐색할 수 있는 링크는 아래에 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAPI 문서: [https://github.com/ollama/ollama/blob/main/docs/api.md](https://github.com/ollama/ollama/blob/main/docs/api.md)\n\n유용한 링크:\n","ogImage":{"url":"/assets/img/2024-07-07-RunningLLMLocally_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-RunningLLMLocally_0.png","tag":["Tech"],"readingTime":5},{"title":"Flask와 SQLAlchemy를 사용한 데이터베이스 통합 방법","description":"","date":"2024-07-07 02:30","slug":"2024-07-07-UsingFlaskwithSQLAlchemyforDatabaseIntegration","content":"\n이 기사에서는 SQLAlchemy를 사용하여 Flask 애플리케이션에 데이터베이스를 통합하는 방법에 대해 살펴볼 것입니다. SQLAlchemy는 데이터베이스 상호 작용을 훨씬 쉽게 만드는 파이썬용 강력한 SQL 툴킷 및 객체 관계 매핑(ORM) 라이브러리입니다.\n\n![이미지](/TIL/assets/img/2024-07-07-UsingFlaskwithSQLAlchemyforDatabaseIntegration_0.png)\n\nSQLAlchemy란 무엇인가요?\nSQLAlchemy는 개발자들이 파이썬 객체를 사용하여 데이터베이스 작업을 수행할 수 있는 인기 있는 ORM 라이브러리로, 원시 SQL 쿼리를 작성하지 않고도 데이터베이스 작업을 더 쉽게 관리할 수 있게 해줍니다.\n\n## Flask 및 SQLAlchemy 설정하기\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우선, 컴퓨터에 Python이 설치되어 있는지 확인하세요. 그런 다음 pip를 사용하여 Flask와 SQLAlchemy를 설치하세요:\n\n```js\npip install Flask SQLAlchemy\n```\n\nSQLAlchemy를 사용한 기본 Flask 애플리케이션 만들기\n\n- 프로젝트 구조: 프로젝트 구조를 다음과 같이 설정하세요:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nflask_sqlalchemy_example/\n├── app.py\n├── config.py\n├── models.py\n└── requirements.txt\n```\n\n2. Configuration: 데이터베이스 구성을 저장하는 config.py 파일을 만들어보세요:\n\n```python\nimport os\n\nbasedir = os.path.abspath(os.path.dirname(__file__))\n\nclass Config:\n    SQLALCHEMY_DATABASE_URI = 'sqlite:///' + os.path.join(basedir, 'app.db')\n    SQLALCHEMY_TRACK_MODIFICATIONS = False\n```\n\n3. 모델 정의: 데이터베이스 모델을 정의하는 models.py 파일을 생성하세요:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\n아래는 Flask 애플리케이션을 개발하기 위한 코드 예제입니다.\n\nfrom flask_sqlalchemy import SQLAlchemy\n\ndb = SQLAlchemy()\n\nclass User(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    username = db.Column(db.String(80), unique=True, nullable=False)\n    email = db.Column(db.String(120), unique=True, nullable=False)\n\n    def __repr__(self):\n        return f'<User {self.username}>'\n\n4. Flask 애플리케이션 생성: 메인 애플리케이션 파일인 app.py를 생성하세요.\n\nfrom flask import Flask\nfrom config import Config\nfrom models import db, User\n\napp = Flask(__name__)\napp.config.from_object(Config)\ndb.init_app(app)\n\n@app.before_first_request\ndef create_tables():\n    db.create_all()\n\n@app.route('/')\ndef home():\n    return \"Flask with SQLAlchemy 예제에 오신 것을 환영합니다!\"\n\nif __name__ == '__main__':\n    app.run(debug=True)\n\n5. 애플리케이션 실행: 애플리케이션을 실행하고 데이터베이스를 생성하세요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\npython app.py\n\n## CRUD 작업 추가하기\n\n이제 사용자 모델을 관리하기 위해 CRUD(Create, Read, Update, Delete) 작업을 추가해 봅시다.\n\n- 사용자 생성: 새 사용자를 생성하는 라우트를 추가하세요:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nfrom flask import request, jsonify\n\n@app.route('/users', methods=['POST'])\ndef create_user():\n    data = request.get_json()\n    new_user = User(username=data['username'], email=data['email'])\n    db.session.add(new_user)\n    db.session.commit()\n    return jsonify({'message': '사용자가 성공적으로 생성되었습니다!'}), 201\n\n2. 모든 사용자 가져오기: 모든 사용자를 가져오는 라우트를 추가합니다:\n\n@app.route('/users', methods=['GET'])\ndef get_users():\n    users = User.query.all()\n    return jsonify([{'id': user.id, 'username': user.username, 'email': user.email} for user in users])\n\n3. 단일 사용자 가져오기: ID로 사용자를 가져오는 라우트를 추가합니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n@app.route('/users/<int:id>', methods=['GET'])\ndef get_user(id):\n    user = User.query.get_or_404(id)\n    return jsonify({'id': user.id, 'username': user.username, 'email': user.email})\n\n4. 사용자 업데이트: ID로 사용자를 업데이트하는 라우트를 추가하세요:\n\n@app.route('/users/<int:id>', methods=['PUT'])\ndef update_user(id):\n    data = request.get_json()\n    user = User.query.get_or_404(id)\n    user.username = data['username']\n    user.email = data['email']\n    db.session.commit()\n    return jsonify({'message': '사용자가 성공적으로 업데이트되었습니다!'})\n\n5. 사용자 삭제: ID로 사용자를 삭제하는 라우트를 추가하세요:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n@app.route('/users/<int:id>', methods=['DELETE'])\ndef delete_user(id):\n    user = User.query.get_or_404(id)\n    db.session.delete(user)\n    db.session.commit()\n    return jsonify({'message': '사용자가 성공적으로 삭제되었습니다!'})\n\n최종 app.py 코드\n\nCRUD 작업이 모두 포함된 완성된 app.py는 아래와 같습니다:\nfrom flask import Flask, request, jsonify\nfrom config import Config\nfrom models import db, User\n\napp = Flask(__name__)\napp.config.from_object(Config)\ndb.init_app(app)\n\n@app.before_first_request\ndef create_tables():\n    db.create_all()\n\n@app.route('/')\ndef home():\n    return \"Flask with SQLAlchemy 예제에 오신 것을 환영합니다!\"\n\n@app.route('/users', methods=['POST'])\ndef create_user():\n    data = request.get_json()\n    new_user = User(username=data['username'], email=data['email'])\n    db.session.add(new_user)\n    db.session.commit()\n    return jsonify({'message': '사용자가 성공적으로 생성되었습니다!'}), 201\n\n@app.route('/users', methods=['GET'])\ndef get_users():\n    users = User.query.all()\n    return jsonify([{'id': user.id, 'username': user.username, 'email': user.email} for user in users])\n\n@app.route('/users/<int:id>', methods=['GET'])\ndef get_user(id):\n    user = User.query.get_or_404(id)\n    return jsonify({'id': user.id, 'username': user.username, 'email': user.email})\n\n@app.route('/users/<int:id>', methods=['PUT'])\ndef update_user(id):\n    data = request.get_json()\n    user = User.query.get_or_404(id)\n    user.username = data['username']\n    user.email = data['email']\n    db.session.commit()\n    return jsonify({'message': '사용자가 성공적으로 업데이트되었습니다!'})\n\n@app.route('/users/<int:id>', methods=['DELETE'])\ndef delete_user(id):\n    user = User.query.get_or_404(id)\n    db.session.delete(user)\n    db.session.commit()\n    return jsonify({'message': '사용자가 성공적으로 삭제되었습니다!'})\n\nif __name__ == '__main__':\n    app.run(debug=True)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 글에서는 SQLAlchemy를 Flask와 통합하여 데이터베이스 작업을 관리하는 방법을 다루었습니다. 우리는 간단한 사용자 모델을 생성하고 데이터베이스와 상호 작용하기 위한 CRUD 작업을 구현했습니다. SQLAlchemy의 ORM 기능은 Flask 애플리케이션에서 데이터베이스 관리를 위한 강력한 도구로 만들어 줍니다.\n```\n","ogImage":{"url":"/assets/img/2024-07-07-UsingFlaskwithSQLAlchemyforDatabaseIntegration_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-UsingFlaskwithSQLAlchemyforDatabaseIntegration_0.png","tag":["Tech"],"readingTime":8},{"title":"몰랐으면 후회할 8가지 Python Dictionary 사용 꿀팁","description":"","date":"2024-07-07 02:29","slug":"2024-07-07-8PythonDictionaryThingsIRegretNotKnowingEarlier","content":"\n![이미지](/TIL/assets/img/2024-07-07-8PythonDictionaryThingsIRegretNotKnowingEarlier_0.png)\n\n이러한 팁들 덕분에 Python에서 사전(Dictionary)를 다루는 것이 더 즐겁고 우아해졌고, 조금 더 늦게 배워서 아쉬운 점이 있습니다.\n\n# 1) dict(key=value)를 사용하여 사전 생성하기\n\n참고 - 우리 개발팀이 95%의 경우에 사전을 만드는 방법입니다. ''는 그다지 사용하지 않습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 딕셔너리를 만드는 일반적인 방법\n\nd = {'apple':4, 'orange':5, 'pear':6, 'pineapple':7}\n\n# 동일한 딕셔너리를 만드는 '더 좋은' 방법\n\nd = dict(apple=4, orange=5, pear=6, pineapple=7)\n\n더 좋은 방법이 더 좋은 이유:\n\n- ''를 사용하면 문자열 키에 따옴표 문자를 입력해야 함\n- 예를 들어, `apple` `orange`와 같은 방식\n- 따옴표 문자를 입력해야 하는 것은 키가 많아질수록 기하급수적으로 귀찮아짐\n- dict()를 사용하면 따옴표 문자를 무시할 수 있음\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n물론, dict() 방법은 문자열이 아닌 키와 함께 사용할 수 없어서 두 가지 방법에는 각각의 용도가 있습니다.\n\n# 2) \\*\\*를 사용하여 딕셔너리를 결합하는 방법\n\n```js\n# 여기에 2개의 딕셔너리가 있습니다.\n\na = {1:1, 2:2}\nb = {3:3, 4:4}\n```\n\n```js\n# **를 사용하여 두 개를 결합할 수 있습니다.\n\nx = {**a, **b}\n\nprint(x) #… 출력결과를 확인하세요\n```\n","ogImage":{"url":"/assets/img/2024-07-07-8PythonDictionaryThingsIRegretNotKnowingEarlier_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-8PythonDictionaryThingsIRegretNotKnowingEarlier_0.png","tag":["Tech"],"readingTime":2},{"title":"파이썬으로 파킨슨 변동성 계산하는 방법","description":"","date":"2024-07-07 02:29","slug":"2024-07-07-CalculatingParkinsonsVolatilityinPython","content":"\n![Parkinson’s volatility](/TIL/assets/img/2024-07-07-CalculatingParkinsonsVolatilityinPython_0.png)\n\n파킨슨 변동성은 특정 기간 동안 금융 상품의 고가 및 저가를 활용한 역사적 변동성의 측정입니다. 일일 가격 범위를 반영하여 내일의 가격 변동에 대한 추가 정보를 제공하기 때문에 표준 종가 대 종가 변동성 추정치보다 더 효율적이라고 여겨집니다.\n\n이 기사에서는 이 변동성 측정 방법을 자세히 소개하고 Python을 사용하여 시계열에서 롤링 계산을 하는 방법을 보여줍니다.\n\n# 파킨슨 변동성 이해하기\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n복잡한 변동성 모델을 논의하기 전에, 항상 역사적 표준편차라는 가장 기본적인 변동성 모델(또는 계산)을 완전히 이해하는 것이 좋습니다. 역사적 메소드를 사용한 표준편차는 과거 가격 데이터를 기반으로 금융 상품의 변동성을 측정하는 일반적인 방법입니다.\n\n이는 값의 변동이나 분산의 양을 측정합니다. 금융 분야에서는 일반적으로 일별 수익의 평균 주변의 변동을 측정합니다. 표준편차를 계산하는 방법은 다음과 같습니다:\n\n- 차분(첫 번째...\n","ogImage":{"url":"/assets/img/2024-07-07-CalculatingParkinsonsVolatilityinPython_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-CalculatingParkinsonsVolatilityinPython_0.png","tag":["Tech"],"readingTime":1},{"title":"GreenNet 에너지 효율성을 높이는 방법","description":"","date":"2024-07-07 02:28","slug":"2024-07-07-GreenNetEmpoweringEnergyEfficiency","content":"\n# 소개\n\n![이미지](/TIL/assets/img/2024-07-07-GreenNetEmpoweringEnergyEfficiency_0.png)\n\n저는 대규모 에너지 소비 관리 시스템의 중요 구성 요소 중 하나인 독립형 마이크로 서비스 프로젝트에 참여할 기회가 있었습니다. 우리 프로젝트는 다양한 엔지니어가 다양한 구성 요소에 작업하는 이 대규모 이니셔티브의 한 부분이었습니다.\n\n이 프로젝트의 개념은 원래 ALX에서 나의 동료가 고안하여 에너지 소비를 관리하는 포괄적인 시스템을 상상했습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 프로젝트는 Engineer 2:가 주도하였고, 꽉 끼인 3주의 일정 내에 완료되었습니다.\n\n## 프로젝트 세분화: 세그먼트 및 엔지니어\n\n아래는 각 프로젝트를 담당한 다른 세그먼트 및 엔지니어에 대한 개요입니다:\n\n## 세그먼트:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 에너지 소비 추적기: 에너지 소비 데이터를 수집하고 처리하여 에너지 사용에 대한 통찰과 분석을 제공하며, 에너지 소비 임계값 및 장치 오작동에 대한 사용자 알림을 전송합니다.\n- 그린넷: 에너지 관리를 위한 안전한 사용자 인증 및 장치 모니터링.\n- 챗펄스: 사용자와 관리자 간의 커뮤니케이션을 통한 실시간 사용자 지원 및 참여.\n\n## 엔지니어:\n\n- 엔지니어 1 (Okoyen Ebisine Precious): 그린넷을 위한 사용자 관리 및 장치 관리 마이크로서비스 개발.\n- 엔지니어 2 (Joshua Benjamin): 에너지 소비 및 알림 마이크로서비스 개발을 위한 엔지지 소비 추적기.\n- 엔지니어 3 (Benedict Akosa): 모니터링 및 커뮤니케이션 마이크로서비스, 그리고 실시간 커뮤니케이션과 지원을 위한 챗펄스 챗 마이크로서비스를 담당합니다.\n\n저는 개인적으로 팀 엔지니어 1로서 견고하고 확장 가능한 인증 시스템을 설계하고 구현하는 데 초점을 맞추었습니다. 엔지니어 팀 2는 에너지 소비 분석 모듈을 개발하였으며, 엔지니어 팀 3은 실시간 커뮤니케이션과 지원을 위한 마이크로서비스를 구현하는 데 초점을 맞추었습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 그린넷으로의 여정\n\n그린넷을 만들기 위한 여정을 되돌아보면, 몇 주 전에 겪었던 어려움이 생생하게 떠오릅니다. 학습 일정에서 뒤처지고 있었고, 프로젝트를 맡아야 한다는 생각이 겁나기 시작했습니다. 자신에게 의심이 들고, 복잡한 작업에 도전할 준비가 되어있는지 의문이 들었습니다.\n\n![GreenNet](/TIL/assets/img/2024-07-07-GreenNetEmpoweringEnergyEfficiency_1.png)\n\n하지만, 친구 Chymezy(Engineer 2)와 나눈 대화가 모든 것을 바꿨습니다. 그가 제시한 아이디어는 나에게 와닿았습니다. '보안을 최우선으로 하는 프로젝트를 만들면 어떨까?' 라는 생각이 날 것 같습니다. 생각을 많이 해보니, 나에게는 이 어려움을 극복하고 의미 있는 것을 만들어낼 기회가 된다는 것을 깨달았습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 프로젝트 성과\n\n저희의 프로젝트인 GreenNet의 결과를 공유해 드리게 되어 정말 기쁩니다. GreenNet은 안전한 사용자 인증 및 에너지 관리에서 기기 모니터링을 제공하기 위해 설계된 마이크로 서비스 기반 플랫폼입니다.\n\n## 아키텍처 다이어그램\n\n아래는 GreenNet의 아키텍처 다이어그램입니다. 응용 프로그램을 통해 데이터가 어떻게 흘러가는지를 보여줍니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![GreenNet](/TIL/assets/img/2024-07-07-GreenNetEmpoweringEnergyEfficiency_2.png)\n\n## 사용된 기술\n\nGreenNet을 만들기 위해 견고하고 확장 가능한 애플리케이션을 구축하는 데 중점을 두기 위해 다양한 기술을 결합했습니다.\n\n백엔드에서는 Python을 선택했습니다. 그 이유는 간단함, 유연성 및 다양한 라이브러리 때문입니다. 이를 통해 빠르게 안전한 사용자 인증 시스템을 개발할 수 있었습니다. Node.js를 선택할 수도 있었지만, Python의 사용 편의성과 다양성으로 인해 이상적인 선택이었습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프론트엔드에서 반응형 및 사용자 친화적 인터페이스를 구축하기 위해 HTML, CSS 및 JavaScript를 선택했습니다. HTML, CSS 및 JS가 제공하는 유연성과 사용 편의성 때문에 Angular 또는 React와 같은 프레임워크를 사용하지 않기로 결정했습니다. Bootstrap도 UI를 개선하고 일관된 디자인을 제공하는 데 사용되었습니다.\n\n## 완료된 기능\n\n다음은 완료한 주요 기능 몇 가지입니다:\n\n- 안전한 사용자 인증: 안전한 사용자 회원 가입, 로그인 및 로그아웃 기능을 구현하여 사용자 데이터가 보호되고 안전성이 확보되었습니다.\n- 반응형 및 사용자 친화적 인터페이스: 프론트엔드 사용자 인터페이스는 HTML, CSS 및 Bootstrap을 사용하여 반응형 및 사용자 친화적인 경험을 제공합니다. JavaScript 스크립트도 UI를 개선하고 동적 기능을 제공하는 데 사용되었습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그린넷이 제공하는 이러한 기능들은 그저 시작에 불과해요. 사용자들에게 원활하고 효율적인 경험을 제공하기 위해 이 플랫폼을 계속 발전시키고 개선하는 것을 기대하고 있어요.\n\n# 직면한 기술적인 도전\n\n그린넷 프로젝트 도중, 사용 중이었던 웹 프레임워크인 Flask가 데이터베이스를 초기화하고 이관하는 데 실패하여 중요한 기술적 도전에 직면했어요. 이 문제는 프로젝트 초반에 발생했기 때문에 진행에 상당한 영향을 미쳤고, 이를 해결하기 위해 노력했어요.\n\n![이미지](/TIL/assets/img/2024-07-07-GreenNetEmpoweringEnergyEfficiency_3.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 도전을 극복하기 위해 저는 작업 환경을 바꾸고 새 컴퓨터로 전환하기로 결정했습니다. 이 결정은 나에게 프로젝트를 처음부터 다시 시작할 수 있는 기회를 제공하여 결국 큰 도움이 되었습니다. 가져오기 문제를 해결한 후에는 초기보다 두 배 빠른 속도로 작업할 수 있어 생산성이 상당히 향상된 것을 알게 되었습니다.\n\n이 도전을 통해 겪은 경험은 기술적 어려움에 직면했을 때 순응력과 회복력의 중요성을 배울 수 있었습니다. 문제에 직면하여 해결책을 찾아내고, 새로운 에너지와 집중력으로 프로젝트를 계속 개발할 수 있었습니다.\n\n# 배운 교훈과 향후 방향\n\nGreenNet과 함께한 내 여정을 되새기면서, 미래의 소프트웨어 엔지니어링에 대한 접근 방식을 형성할 가치 있는 통찰을 얻었습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 기술적인 포인트\n\n이 프로젝트에서 가장 중요한 기술적 교훈 중 하나는 에너지 관리에서 견고한 사용자 인증과 장치 모니터링의 중요성입니다. Python의 간결함과 유연성을 활용하여 안전하고 확장 가능한 응용 프로그램을 개발할 수 있다는 것을 배웠습니다. 또한 HTML, CSS 및 JavaScript에 대한 경험을 통해 반응형이고 사용자 친화적인 인터페이스를 만들 수 있었습니다.\n\n## 다르게 할 점\n\n아마도 더 안전하고 사용자 친화적인 시스템을 구축하는 데 집중하고, 기기, 위치 또는 연결 여부에 관계없이 최종 사용자가 에너지 사용량을 추적하는 데 원활한 경험을 제공하는 것에 초점을 맞출 것입니다. 모든 사용자가 플랫폼에 접근하고 효율적으로 사용할 수 있도록 혁신적인 솔루션을 탐색하는 것이 포함될 것입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nGreenNet은 소프트웨어 엔지니어링에서의 다양한 가능성을 내게 보여준 중요한 프로젝트였어요. 사람들의 삶에 영향을 미치는 혁신적인 해결책을 만드는 열정을 다시 한 번 느낄 수 있었어요. 앞으로 나아가면서, 배운 기술과 지식을 활용하여 더 복잡한 문제를 해결하고 저와 업계의 밝은 미래를 만들어가는 것에 기대돼요.\n\n이 프로젝트를 통해 VIM과 Emacs를 비롯한 다양한 도구와 기술을 활용할 수 있는 기회를 가졌어요. 그중에서도 여전히 VIM을 선호하는 편인데, 그 이유는 그 간결함과 사용 편의성 때문이에요.\n\n## 결론\n\n요약하자면, GreenNet과의 경험은 저에게 끈기, 적응력 및 혁신에 관한 소중한 교훈을 전달해 주었어요. 내가 이룬 성과에 자랑스럽고, 앞으로의 프로젝트에 배운 기술과 지식을 적용하는 것에 기대가 되요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 나에 대해\n\n저는 열정적이고 목표 지향적인 소프트웨어 엔지니어인 오코옌 에비신 프레셔스입니다. 기술을 통해 긍정적인 영향을 줄 수 있는 강한 열망을 가지고 있습니다. 사람들의 삶에 영향을 미칠 수 있는 혁신적인 솔루션을 개발할 기회를 항상 찾고 있습니다. 제 프로젝트인 GreenNet에 대해 더 많은 정보를 GitHub 링크에서 확인할 수 있습니다. 배포된 프로젝트 페이지와 랜딩 페이지는 링크에서 접속할 수 있습니다. 또한 LinkedIn 프로필 링크에서 저와 연락할 수도 있습니다.\n","ogImage":{"url":"/assets/img/2024-07-07-GreenNetEmpoweringEnergyEfficiency_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-GreenNetEmpoweringEnergyEfficiency_0.png","tag":["Tech"],"readingTime":8}],"page":"46","totalPageCount":50,"totalPageGroupCount":3,"lastPageGroup":10,"currentPageGroup":2},"__N_SSG":true}