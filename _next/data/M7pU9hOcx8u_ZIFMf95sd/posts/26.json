{"pageProps":{"posts":[{"title":"Python과 Streamlit으로 주식 등급 시스템 만들기","description":"","date":"2024-07-13 19:13","slug":"2024-07-13-StockgradesystemwithPythonandStreamlit","content":"\n\n![링크](/TIL/assets/img/2024-07-13-StockgradesystemwithPythonandStreamlit_0.png)\n\n주식 시장에 투자하고 싶다니 멋지네요. 어떤 것을 선택하시겠습니까? 투자에 좋은 것과 그렇지 않은 것을 어떻게 정의하겠습니까? 현재 주식 분류를 이해하기 위해 등급 시스템 또는 평가 시스템이 필요할 것입니다. 지금 개발된 해당 시스템의 한 예시를 살펴보죠.\n\n수천 가지의 주식 중에서 선택해야 하는데, 각각이 갖는 메트릭 및 성과 지표가 모두 다르기 때문에, 최상의 투자 기회를 식별하기 위해서는 견고한 분석과 정보에 기반한 의사 결정이 필요합니다. 초보자든 전문가든, 방대한 양의 데이터를 탐색하고 유망한 주식을 강조해 주는 신뢰할 수 있는 도구가 있으면 매우 가치 있을 것입니다.\n\n이 글에서는 기술적 및 기본적 지표를 활용하여 주식을 평가하는 파이썬 기반의 투자 분석 도구를 개발하는 과정을 안내하겠습니다. 이 도구는 장기 투자 가능성을 식별하는 데 도움을 주는 뿐만 아니라 단기 거래 기회를 찾아내도록 돕습니다. 이 안내서를 따라가면, 로컬 머신에서 실행할 수 있는 강력한 스크립트를 보유하게 되며, Streamlit을 사용하여 직관적인 대시보드에 결과를 표시할 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저희는 분석의 기반이 되는 점수 체계를 설명하여 다양한 지표가 각 주식의 잠재력을 평가하는 데 어떻게 사용되는지 자세히 설명하겠습니다. 이 시스템을 이해하는 것은 매우 중요합니다. 왜냐하면 이는 저희 도구의 기초를 형성하고 의사 결정 프로세스를 안내하기 때문입니다. 이제 각 주식의 점수 평가 방법과 해당 점수의 의미에 대해 구체적으로 살펴보겠습니다.\n\n# 점수 체계 설명\n\n점수 체계는 기술적 지표와 기본적 지표를 결합하여 각 주식의 잠재력을 평가하는 데 사용됩니다. 단기적 가격 변동과 장기적 재무 건강 상태를 고려함으로써 서로 다른 투자 전략에 부합하는 균형 잡힌 평가를 도출할 수 있습니다.\n\n기술적 분석은 주식의 가격 움직임과 패턴에 초점을 맞춥니다. 여기서 우리는 두 가지 주요 지표를 사용합니다: 50일 이동평균선(MA)과 상대강도지수(RSI). 주식의 종가가 50일 이동평균선 위에 있는 경우 상승 추세를 나타내므로 해당 주식은 한 점을 받게 됩니다. 또한 RSI가 70 미만인 경우, 해당 주식이 과매수 상태가 아니며 성장할 공간이 있다는 것을 시사하므로 또 한 점을 받게 됩니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n근본적 분석은 회사의 재정 건강 상태를 검토합니다. 우리는 순조 적받지 못한 (P/E) 비율과 부채 대 자본 비율을 살펴봅니다. 20 미만의 순조 P/E 비율은 주식에 1 점을 부여합니다. 이것은 주식이 미래 수익에 비해 저평가될 가능성이 있음을 나타냅니다. 마찬가지로, 1 미만의 부채 대 자본 비율은 회사가 처리 가능한 부채 수준을 갖고 있음을 시사하며, 또 다른 한 점을 획득합니다.\n\n이러한 지표를 결합하여, 점수 체계는 각 주식에 대해 1에서 4 사이의 등급을 지정합니다. 1의 점수는 최소한의 잠재력을 나타내고, 4의 점수는 우수한 잠재력을 나타냅니다. 이 이중 접근법을 통해 우리는 즉시의 시장 심리와 회사의 기본적인 재정 안정성을 동시에 포착하여, 각 주식의 투자 전망에 대해 잘 둘러싼 견해를 제공합니다.\n\n내가 아는 바로는 주식 신뢰도를 이해하는 데 도움이 되는 여러 지표들이 있습니다. 물론, 이 기사는 참된 지표 범위를 보여주는 유일한 것은 아닙니다. 결국, 이것은 실전을 연습하고, 훨씬 더 많은 지표 및 KPI와 함께 나중에 직접 개발한 시스템을 가지기 위한 연습입니다. 아마도 보다 유연하고 맞춤 설정할 수 있을 것입니다. 그러나 다음 빌드의 기초를 마련합시다.\n\n![StockgradesystemwithPythonandStreamlit_1](/TIL/assets/img/2024-07-13-StockgradesystemwithPythonandStreamlit_1.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 필요한 도구들\n\n이 투자 분석 도구를 구축하고 실행하기 위해, 우리는 몇 가지 강력한 Python 라이브러리를 활용할 것입니다. 우리가 사용할 주요 라이브러리는 yfinance, pandas, 그리고 streamlit입니다. 이 도구들 각각은 데이터 수집부터 시각화까지 우리 분석의 다양한 부분에서 중요한 역할을 합니다.\n\nyfinance는 인기 있는 라이브러리로, 우리에게 Yahoo Finance로부터 직접적으로 과거의 시장 데이터를 가져올 수 있는 기회를 제공합니다. 이는 주식 가격 기록, 재무 제표, 그리고 다른 중요한 지표에 쉬운 접근을 제공하여 기술적 및 기본적 분석에 꼭 필요한 자원이 됩니다. yfinance를 사용하여 우리는 각 주식을 평가하는 데 필요한 데이터를 프로그래밍적으로 수집할 수 있습니다.\n\npandas는 다재다능한 데이터 조작 라이브러리로, 우리가 가져온 데이터를 처리하고 분석하는 데 도움이 될 것입니다. pandas를 사용하면 대규모 데이터 세트를 쉽게 처리하고 기술 지표를 계산하며 점수화 프로세스를 관리할 수 있습니다. 강력한 DataFrame 구조를 통해 복잡한 데이터 작업을 간단히 수행할 수 있어 분석이 효율적이고 정확하도록 보장합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nstreamlit은 Python 스크립트에서 직접 인터랙티브 웹 애플리케이션을 만드는 혁신적인 라이브러리입니다. Streamlit을 사용하면 사용자 친화적인 대시보드를 구축하여 투자 제안을 표시할 수 있습니다. 이를 통해 우리는 분석 결과를 명확하고 직관적인 방식으로 시각화하고 데이터를 해석하고 통찰력 있는 결정을 내릴 수 있게 됩니다.\n\n# 모니터링할 메트릭스\n\n우리의 분석에서는 4가지 주요 메트릭스에 집중할 것입니다: 50일 이동평균선(MA), 상대 강도 지수(RSI), 전방 P/E 비율, 그리고 부채 비율입니다. 각 메트릭스는 해당 주식의 성과와 재무 건강 상태에 대한 유용한 통찰을 제공합니다.\n\n50일 이동평균선(MA): 50일 이동평균선은 일별 가격 변동을 완화하여 기본 트렌드를 드러내는 기술적 지표입니다. 주식의 현재 종가를 50일 이동평균선과 비교함으로써 주식이 상승 트렌드인지 하향 트렌드인지 판단할 수 있습니다. 이동평균선 위의 가격은 상승 흐름을 나타내며 성장 잠재력이 있다는 것을 시사합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n상대강도지수 (RSI): RSI는 주식의 가격 움직임 속도와 변화를 측정하는 모멘텀 오실레이터입니다. 값은 0부터 100까지이며, 70 이상의 값은 주식이 과매수 상태에 있을 수 있음을 나타내고, 30 미만의 값은 과매도 상태일 수 있음을 시사합니다. RSI 추적을 통해 주식이 추세 반전을 겪을지 또는 현재 추세를 이어갈지에 대한 판단을 할 수 있습니다.\n\n정방향 주가 이익 비율 (P/E Ratio): 정방향 P/E 비율은 현재 주가를 예상된 미래 주당 순이익과 비교합니다. 낮은 정방향 P/E 비율은 주식이 미래 수익 잠재력에 비해 저평가되어 있을 수 있다는 것을 나타낼 수 있어 투자 가능성이 있는 기회로 여겨질 수 있습니다. 이 지표를 통해 주식의 가치 평가와 성장 가능성을 평가할 수 있습니다.\n\n부채-자본 비율: 이 기본적인 지표는 기업의 총 부채를 지분 자본과 비교합니다. 낮은 부채-자본 비율은 기업이 빌린 자금에 대한 의존도가 낮고 부채를 관리할 재정적 여력이 있는 것을 시사합니다. 이 비율을 분석함으로써 기업의 재정 안정성과 위험을 평가할 수 있습니다.\n\n![이미지](/TIL/assets/img/2024-07-13-StockgradesystemwithPythonandStreamlit_2.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 코드 시작하기\n\n투자 분석 도구를 만들기 위해, 논리적으로 섹션화된 파이썬 스크립트를 작성할 것입니다. 각 섹션은 데이터 수집, 분석 및 시각화의 다른 측면을 다룰 것입니다. 선호하는 파이썬 IDE에서 investment_analysis.py라는 새로운 파이썬 파일을 생성하는 것부터 시작해봅시다.\n\n- 우선, import부터 시작해보겠습니다\n\n```python\nimport yfinance as yf\nimport pandas as pd\nimport time\nimport datetime\nimport os\nimport streamlit as st\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nyfinance: Yahoo Finance에서 주식 시장 데이터를 가져 오는 데 사용됩니다\npandas: 데이터 조작 및 분석에 사용됩니다\ntime: API 요청 간의 지연을 추가하여 요율 제한을 피하기위해 사용됩니다.\ndatetime: 날짜 조작에 사용됩니다\nos: 파일 작업을 처리하는 데 사용됩니다.\nstreamlit: 결과를 표시하는 대화형 웹 대시 보드를 만드는 데 사용됩니다.\n\n2. Get and count: 주식 정보 가져 오기 및 기술 지표 계산\n\n```js\n# 지난 5 일간의 주식 가격 데이터를 가져 오기위한 함수\ndef get_stock_data(ticker):\n    stock = yf.Ticker(ticker)\n    hist = stock.history(period=\"5d\")  # 현재 및 이전 거래일을 포함하는 지난 5 일간의 데이터만 가져옵니다\n    if hist.empty:\n        raise ValueError(f\"{ticker} 에 대한 데이터를 찾을 수 없습니다.\")\n    return hist\n\n# 50일 이동 평균을 계산하는 함수\ndef calculate_moving_average(data, window):\n    data[f\"MA_{window}\"] = data['Close'].rolling(window=window).mean()\n    return data\n\n# 상대 강도 지수(RSI)를 계산하는 함수\ndef calculate_rsi(data, window=14):\n    delta = data['Close'].diff(1)\n    gain = delta.mask(delta < 0, 0)\n    loss = -delta.mask(delta > 0, 0)\n    avg_gain = gain.rolling(window=window).mean()\n    avg_loss = loss.rolling(window=window).mean()\n    rs = avg_gain / avg_loss\n    rsi = 100 - (100 / (1 + rs))\n    data[f\"RSI_{window}\"] = rsi\n    return data\n```\n\nget_stock_data: Yahoo Finance에서 지난 5 일간의 주식 가격 데이터를 가져 옴\ncalculate_moving_average: 지정된 창 기간(이 경우 50 일) 동안 종가의 이동 평균을 계산\ncalculate_rsi: 가격 움직임의 속도와 변화를 측정하는 모멘텀 오실레이터 인 RSI를 계산\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n3. 기초 지식 습득\n\n```js\n# 기초 데이터를 가져오는 함수\ndef get_fundamentals(ticker):\n    stock = yf.Ticker(ticker)\n    fundamentals = stock.info\n    return fundamentals\n```\n\n여기서 AAPL 주식에 대한 기초 데이터 범위를 얻고, 추가적인 필터링을 위해 준비해 봅시다.\n\n4. 시작점을 정해봅시다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# 기술 및 기본 분석에 기반한 주식 평가 함수\ndef score_stock(data, fundamentals):\n    score = 0\n    # 기술적 분석\n    if data['Close'].iloc[-1] > data['MA_50'].iloc[-1]:\n        score += 1\n    if data['RSI_14'].iloc[-1] < 70:\n        score += 1\n    # 기초분석 및 오류 처리\n    try:\n        if fundamentals.get('forwardPE', None) is not None and fundamentals['forwardPE'] < 20:\n            score += 1\n        if fundamentals.get('debtToEquity', None) is not None and fundamentals['debtToEquity'] < 1:\n            score += 1\n    except KeyError as e:\n        print(f\"Key error: {e}\")\n    return score\n```\n\nscore_stock: 주식을 점수화하며, 종가가 50일 이동평균(MA_50)을 초과하고 RSI가 70보다 낮으며, 순방향 P/E 비율이 20 미만이거나 부채 비율이 1 미만인 경우 1을 추가하여 주식에 대한 점수를 매깁니다. 이것이 주식에 대한 점수를 평가하는 척도가 됩니다.\n\n5. 이렇게 분석하고, 저렇게 분석하고, 주식을 분석합니다.\n\n```js\ndef analyze_stock(ticker):\n    try:\n        data = get_stock_data(ticker)\n        data = calculate_moving_average(data, 50)\n        data = calculate_rsi(data)\n        fundamentals = get_fundamentals(ticker)\n        score = score_stock(data, fundamentals)\n        return data, fundamentals, score\n    except (IndexError, ValueError) as e:\n        print(f\"Skipping {ticker} due to error: {e}\")\n        return None, None, None\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nanalyze_stock: 주가 분석을 위해 과거 데이터를 가져오고 기술적 지표를 계산하며 기본 데이터를 가져와서 주식에 점수를 매깁니다. 오류가 발생하면 해당 주식은 건너뜁니다.\n\n6. 상당한 가치평가.\n\n```js\n# 분석된 주식에 기반하여 투자 제안하는 기능\ndef suggest_investments(tickers):\n    suggestions = []\n    for ticker in tickers:\n        data, fundamentals, score = analyze_stock(ticker)\n        if data is not None and fundamentals is not None:\n            suggestions.append((ticker, score, data['Close'].iloc[-1], str(datetime.date.today())))\n        time.sleep(0.25)  # HTTP 429 오류를 피하기 위해 지연 추가\n    suggestions.sort(key=lambda x: x[1], reverse=True)\n    save_suggestions(suggestions)\n    return suggestions\n\n# 제안을 CSV 파일에 저장하는 기능\ndef save_suggestions(suggestions):\n    df = pd.DataFrame(suggestions, columns=['Ticker', 'Score', 'Price', 'Date'])\n    df.to_csv('suggestions.csv', mode='a', header=not os.path.exists('suggestions.csv'), index=False)\n\ndef get_stock_list():\n    # 해당 예시에서는 S&P 500 리스트를 사용하였으나 다른 소스를 사용할 수 있음\n    sp500 = pd.read_html('https://en.wikipedia.org/wiki/List_of_S%26P_500_companies')[0]\n    return sp500['Symbol'].tolist()\r\n```\n\nsuggest_investments: 주식의 점수를 기준으로 투자할 주식을 제안하며 요청 사이에 지연을 추가하고 제안을 CSV 파일에 저장합니다.\nsave_suggestions: 미래 참고를 위해 제안을 CSV 파일에 저장합니다.\nget_stock_list: S&P500에 포함된 주식 목록을 가져옵니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n7. 우리가 가진 내용을 보여줍시다.\n\n```js\ndef display_dashboard(suggestions):\n    st.title(\"투자 제안 대시보드\")\n    for ticker, score, price, date in suggestions:\n        color = \"green\" if score >= 3 else \"red\"\n        st.markdown(f\"<div style='color:{color}'>티커: {ticker}, 점수: {score}, 가격: {price}, 날짜: {date}</div>\", unsafe_allow_html=True)\n\n# 단기 분석을 수행하는 함수\ndef short_term_analysis(tickers):\n    short_term_suggestions = []\n    for ticker in tickers:\n        data, fundamentals, score = analyze_stock(ticker)\n        if data is not None and fundamentals is not None and data['RSI_14'].iloc[-1] < 30:  # 단기 기회를 위한 예시 기준\n            short_term_suggestions.append((ticker, score, data['Close'].iloc[-1], str(datetime.date.today()))\n        time.sleep(0.25)  # HTTP 429 오류를 피하기 위한 지연 추가\n    short_term_suggestions.sort(key=lambda x: x[1], reverse=True)\n    save_suggestions(short_term_suggestions)\n    return short_term_suggestions\n\n# 지난 제안 성과를 평가하는 함수\ndef evaluate_performance():\n    df = pd.read_csv('suggestions.csv')\n    df['평가_날짜'] = pd.to_datetime(df['Date']) + pd.DateOffset(weeks=1)  # 1주 후 평가\n    evaluation_results = []\n    \n    for index, row in df.iterrows():\n        ticker = row['Ticker']\n        initial_price = row['Price']\n        evaluation_date = row['평가_날짜']\n        \n        try:\n            stock = yf.Ticker(ticker)\n            hist = stock.history(start=str(evaluation_date), end=str(evaluation_date + pd.DateOffset(days=1)))\n            final_price = hist['Close'][0]\n            price_change = (final_price - initial_price) / initial_price * 100\n            evaluation_results.append((ticker, row['Date'], initial_price, final_price, price_change))\n        except IndexError:\n            # 평가 일자에 데이터가 없는 경우 처리\n            evaluation_results.append((ticker, row['Date'], initial_price, None, None))\n    \n    eval_df = pd.DataFrame(evaluation_results, columns=['티커', '제안_날짜', '초기_가격', '최종_가격', '가격_변화 (%)'])\n    eval_df.to_csv('evaluation_results.csv', index=False)\r\n```\n\ndisplay_dashboard: 색상으로 구분된 점수를 사용하여 투자 제안을 Streamlit 대시보드에 표시합니다.\nshort_term_analysis: RSI 및 기타 기준에 기반하여 단기 투자 기회를 식별합니다.\nevaluate_performance: 초기 및 최종 가격을 비교하여 지난 투자 제안의 성과를 평가합니다.\n\n8. 작동하도록 만들기 — 스크립트 실행\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nif __name__ == \"__main__\":\n    try:\n        # 주식 분석을 위한 티커 목록 정의\n        tickers = get_stock_list()\n        \n        # 투자 제안서 가져오기\n        suggestions = suggest_investments(tickers)\n        display_dashboard(suggestions)\n\n        # 단기 투자 제안\n        short_term_suggestions = short_term_analysis(tickers)\n        st.title(\"단기 투자 제안\")\n        display_dashboard(short_term_suggestions)\n\n        # 과거 제안의 성능 평가\n        evaluate_performance()\n        evaluation_results_df = pd.read_csv('evaluation_results.csv')\n        st.title(\"평가 결과\")\n        st.write(evaluation_results_df)\n        \n    except KeyboardInterrupt:\n        st.write(\"사용자에 의해 스크립트가 중단되었습니다.\")\n```\n\n마지막으로, 주식 티커 가져오기, 투자 제안, 대시보드 표시 및 성능 평가를 포함한 주요 실행 흐름을 정의합니다.\n사용자에 의해 스크립트가 중단된 경우, 중단을 우아하게 처리하고 메시지를 표시합니다.\n평가 방식:\n\n- 3 또는 4점: 강력한 잠재성이 있음을 나타냅니다. 이러한 주식은 대부분의 기준을 충족하며 좋은 선택지로 간주됩니다.\n- 2점: 중간적인 잠재성이 있음을 나타냅니다. 이러한 주식은 일부 기준을 충족하지만 일부 리스크나 약한 지표가 있을 수 있습니다.\n- 1점: 최소한의 잠재성이 있음을 나타냅니다. 이러한 주식은 매우 적은 기준을 충족하며 상당한 리스크가 있을 수 있습니다.\n- 0점: 우리의 기준에 따라 잠재성이 없음을 나타냅니다. 이러한 주식은 주요 지표 중 어떤 것도 충족하지 않습니다.\n\n이제 다음 명령으로 실행해봅시다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nstreamlit run .\\test.py\n```\n\n![Image](/TIL/assets/img/2024-07-13-StockgradesystemwithPythonandStreamlit_3.png)\n\n결과를 확인하세요:\n\n![Image](/TIL/assets/img/2024-07-13-StockgradesystemwithPythonandStreamlit_4.png)\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n7월 12일 2024일의 경우, 우리의 기준에 맞는 주식이 없어요: SP500의 주식 중에는 아무런 높은 등급의 주식이 존재하지 않아요.\n\n다음에 무엇을 할 수 있을까요?\n\n- 기술지표 조정: RSI나 이동평균에 대해 다양한 임계값을 고려해보세요. 예를 들어, 200일 이동평균을 사용하는 것이 더 나은 신호를 제공할 수도 있습니다.\n- 추가 지표 통합: 수익 성장률, 배당 수익률 또는 다른 기술적 패턴과 같은 더 많은 기본적 또는 기술적 지표를 분석에 추가하세요.\n- 평가: 주식의 성능을 분석하고 실제 재무 결과를 바탕으로 주식을 등급화하여 점수를 매기기 위해 현실적인 등급 시스템을 갖도록 하세요.\n\n일반적인 코드…\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nimport yfinance as yf\nimport pandas as pd\nimport time\nimport datetime\nimport os\nimport streamlit as st\n\ndef get_stock_data(ticker):\n    stock = yf.Ticker(ticker)\n    hist = stock.history(period=\"5d\")  \n    if hist.empty:\n        raise ValueError(f\"{ticker}에 대한 데이터를 찾을 수 없습니다.\")\n    return hist\n\ndef calculate_moving_average(data, window):\n    data[f\"MA_{window}\"] = data['Close'].rolling(window=window).mean()\n    return data\n\ndef calculate_rsi(data, window=14):\n    delta = data['Close'].diff(1)\n    gain = delta.mask(delta < 0, 0)\n    loss = -delta.mask(delta > 0, 0)\n    avg_gain = gain.rolling(window=window).mean()\n    avg_loss = loss.rolling(window=window).mean()\n    rs = avg_gain / avg_loss\n    rsi = 100 - (100 / (1 + rs))\n    data[f\"RSI_{window}\"] = rsi\n    return data\n\ndef get_fundamentals(ticker):\n    stock = yf.Ticker(ticker)\n    fundamentals = stock.info\n    return fundamentals\n\ndef score_stock(data, fundamentals):\n    score = 0\n    if data['Close'].iloc[-1] > data['MA_50'].iloc[-1]:\n        score += 1\n    if data['RSI_14'].iloc[-1] < 70:\n        score += 1\n    try:\n        if fundamentals.get('forwardPE', None) is not None and fundamentals['forwardPE'] < 20:\n            score += 1\n        if fundamentals.get('debtToEquity', None) is not None and fundamentals['debtToEquity'] < 1:\n            score += 1\n    except KeyError as e:\n        print(f\"Key error: {e}\")\n    return score\n\ndef analyze_stock(ticker):\n    try:\n        data = get_stock_data(ticker)\n        data = calculate_moving_average(data, 50)\n        data = calculate_rsi(data)\n        fundamentals = get_fundamentals(ticker)\n        score = score_stock(data, fundamentals)\n        return data, fundamentals, score\n    except (IndexError, ValueError) as e:\n        print(f\"{ticker}을(를) 분석하는 도중 오류가 발생했습니다: {e}\")\n        return None, None, None\n\ndef suggest_investments(tickers):\n    suggestions = []\n    for ticker in tickers:\n        data, fundamentals, score = analyze_stock(ticker)\n        if data is not None and fundamentals is not None:\n            suggestions.append((ticker, score, data['Close'].iloc[-1], str(datetime.date.today())))\n        time.sleep(0.25)   \n    suggestions.sort(key=lambda x: x[1], reverse=True)\n    save_suggestions(suggestions)\n    return suggestions\n\ndef save_suggestions(suggestions):\n    df = pd.DataFrame(suggestions, columns=['주식 코드', '점수', '가격', '날짜'])\n    df.to_csv('suggestions.csv', mode='a', header=not os.path.exists('suggestions.csv'), index=False)\n\ndef get_stock_list():\n    sp500 = pd.read_html('https://en.wikipedia.org/wiki/List_of_S%26P_500_companies')[0]\n    return sp500['Symbol'].tolist()\n\ndef display_dashboard(suggestions):\n    st.title(\"투자 제안 대시보드\")\n    for ticker, score, price, date in suggestions:\n        color = \"green\" if score >= 3 else \"red\"\n        st.markdown(f\"<div style='color:{color}'>주식 코드: {ticker}, 점수: {score}, 가격: {price}, 날짜: {date}</div>\", unsafe_allow_html=True)\n\ndef short_term_analysis(tickers):\n    short_term_suggestions = []\n    for ticker in tickers:\n        data, fundamentals, score = analyze_stock(ticker)\n        if data is not None and fundamentals is not None and data['RSI_14'].iloc[-1] < 30:  # 단기 기회 조건 예시\n            short_term_suggestions.append((ticker, score, data['Close'].iloc[-1], str(datetime.date.today())))\n        time.sleep(0.25)   \n    short_term_suggestions.sort(key=lambda x: x[1], reverse=True)\n    save_suggestions(short_term_suggestions)\n    return short_term_suggestions\n\ndef evaluate_performance():\n    df = pd.read_csv('suggestions.csv')\n    df['평가 날짜'] = pd.to_datetime(df['날짜']) + pd.DateOffset(weeks=1)  # 1주 후에 평가\n    evaluation_results = []\n    \n    for index, row in df.iterrows():\n        ticker = row['주식 코드']\n        initial_price = row['가격']\n        evaluation_date = row['평가 날짜']\n        \n        try:\n            stock = yf.Ticker(ticker)\n            hist = stock.history(start=str(evaluation_date), end=str(evaluation_date + pd.DateOffset(days=1)))\n            final_price = hist['Close'][0]\n            price_change = (final_price - initial_price) / initial_price * 100\n            evaluation_results.append((ticker, row['날짜'], initial_price, final_price, price_change))\n        except IndexError:\n            # 평가 날짜에 데이터가 없는 경우 처리\n            evaluation_results.append((ticker, row['날짜'], initial_price, None, None))\n    \n    eval_df = pd.DataFrame(evaluation_results, columns=['주식 코드', '제안 일자', '초기 가격', '최종 가격', '가격 변동 (%)'])\n    eval_df.to_csv('evaluation_results.csv', index=False)\n\nif __name__ == \"__main__\":\n    try:\n        tickers = get_stock_list()\n        \n        suggestions = suggest_investments(tickers)\n        display_dashboard(suggestions)\n\n        short_term_suggestions = short_term_analysis(tickers)\n        st.title(\"단기 투자 제안\")\n        display_dashboard(short_term_suggestions)\n\n        evaluate_performance()\n        evaluation_results_df = pd.read_csv('evaluation_results.csv')\n        st.title(\"평가 결과\")\n        st.write(evaluation_results_df)\n        \n    except KeyboardInterrupt:\n        st.write(\"사용자에 의해 스크립트가 중단되었습니다.\")\n```\n\n… 그리고 면책 조항.\n\n# 면책 조항\n\n이 글과 함께 제공된 코드는 교육 목적으로만 사용됩니다. 스크립트가 제공하는 제안은 자동 분석의 기능을 보여주기 위한 것이며, 사용자는 제안된 조치를 모니터링하고 시간이 지남에 따라 성공률을 평가해야 합니다. 이 콘텐츠는 행동 요령이 아니며, 재정 자문으로 해석해서는 안 됩니다. 언제든지 본인의 연구를 수행하고 거래 결정을 내리기 전에 전문가와 상의하십시오.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결론\n\n이러한 단계를 따르면 기술적 및 기본적인 지표를 모두 사용하여 주식을 평가하는 견고한 투자 분석 도구를 만들 수 있습니다. 결과는 인터랙티브 한 Streamlit 대시 보드에 표시되어 분석을 해석하고 조치를 취하기가 쉬워집니다. 즐거운 코딩투자를 하세요!","ogImage":{"url":"/TIL/assets/img/2024-07-13-StockgradesystemwithPythonandStreamlit_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-StockgradesystemwithPythonandStreamlit_0.png","tag":["Tech"],"readingTime":22},{"title":"Streamlit 대시보드 만들기 간단한 모듈식 코딩으로 매끄러운 결과 얻기","description":"","date":"2024-07-13 19:11","slug":"2024-07-13-StunningStreamlitDashboardsSimpleModularCodingForSmoothResults","content":"\n\n![Stunning Streamlit Dashboards](/TIL/assets/img/2024-07-13-StunningStreamlitDashboardsSimpleModularCodingForSmoothResults_0.png)\n\nStreamlit은 데이터 과학자와 분석가들이 쉽게 대화형 웹 애플리케이션을 만들 수 있게 하는 오픈 소스 앱 프레임워크입니다.\n\n인기있던 요청에 힘입어, 본 글은 보다 모듈식으로 접근한 다중 페이지 Streamlit 애플리케이션 만들기 과정을 다룹니다. 페이지의 핵심 쉘부터 시작합니다.\n\nData at Depth는 독자들의 지원을 받는 미디어입니다. 새로운 글을 받아보고 제 작품을 지원하기 위해 무료 또는 유료 구독자가 되는 것을 고려해 주세요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파이썬을 몇 줄만 사용하면 데이터 스크립트를 공유 가능한 웹 앱으로 변환할 수 있어요.\n\nStreamlit을 사용하여 다중 페이지 대화형 애플리케이션을 만드는 방법을 안내해 드릴게요. 이번에는 국제 난민기구 (UNHCR) 데이터셋을 활용해서 원산지국 및 피난사 실제 나라를 추적하는 애플리케이션을 만들 거에요.\n\n이 애플리케이션은 다음과 같은 세 가지 데이터 시각화 페이지를 갖을 거예요:\n\n- 피난 사실 대상 나라 개요 (피난처 10대 국가)\n- 피난처 국가별 분석\n- 코로플레스 지도를 활용한 피난신청국 전체 개요\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리가 할 일은 Streamlit 셸 애플리케이션과 데이터 세트를 이용해 모든 것을 처음부터 만들어보는 것입니다.\n\n# Streamlit 셸 애플리케이션 다중 페이지 구조 만들기\n\n모듈화된 다중 페이지 Streamlit 애플리케이션을 만들기 위해 우리는 먼저 애플리케이션의 기본 구조를 설정할 것입니다.\n\n이는 각 페이지에 대한 별도의 함수를 만들고 페이지 간 탐색을 관리하는 주요 함수를 만드는 것을 포함합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 각 페이지를 셸로 사용하여 3페이지 Streamlit 애플리케이션을 설정하는 코드입니다.\n\n```js\nimport streamlit as st\n\n# 페이지 1: 개요\ndef page_overview():\n    st.subheader(\"연도 범위별 전체 비민 결정\")\n    # 시각화 코드를 여기에 넣으세요.\n\n# 페이지 2: 국가별 분석 및 그룹화된 막대 차트\ndef page_country_analysis():\n    st.subheader(\"국가별 분석\")\n    # 시각화 코드를 여기에 넣으세요.\n\n# 페이지 3: 코로플레스 맵\ndef page_choropleth():\n    st.subheader(\"비민 결정의 세계적 분포\")\n    # 시각화 코드를 여기에 넣으세요.\n\n# 주요 앱 및 네비게이션\ndef main():\n    st.set_page_config(page_title=\"비민 결정 대시보드\", layout=\"wide\", initial_sidebar_state=\"expanded\")\n    st.sidebar.title(\"네비게이션\")\n    menu_options = [\"전체 비민 결정\", \"국가 분석\", \"글로벌 매핑\"]\n    menu_choice = st.sidebar.selectbox(\"이동\", menu_options)\n    if menu_choice == \"전체 비민 결정\":\n        page_overview()\n    elif menu_choice == \"국가 분석\":\n        page_country_analysis()\n    elif menu_choice == \"글로벌 매핑\":\n        page_choropleth()\n\nif __name__ == \"__main__\":\n    main()\n```\n## 코드 설명:\n\n- Streamlit 라이브러리를 가져옵니다.\n- 각 페이지를 위한 별도의 함수를 정의합니다: page_overview(), page_country_analysis(), page_choropleth().\n- 각 함수에는 페이지 목적을 나타내는 subheader가 포함되어 있습니다. 데이터 시각화 코드는 나중에 추가됩니다.\n- 페이지 구성을 설정하고 네비게이션을 처리하는 main() 함수를 정의합니다.\n- st.sidebar.selectbox를 사용하여 세 개의 페이지 사이를 이동하는 사이드바 메뉴를 생성합니다.\n- 사용자의 선택에 따라 해당 페이지 함수가 호출되어 페이지 내용이 표시됩니다.\n- 스크립트를 실행할 때 main() 함수가 호출됩니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 쉘은 다중 페이지 Streamlit 애플리케이션의 기본 구조를 설정합니다. 다음 섹션에서는 각 페이지 함수에 데이터 시각화 코드를 추가할 것입니다.\n\n이 코드를 실행하려면 터미널 프롬프트에 액세스해야 합니다. 저는 PyCharm의 내장 터미널 프롬프트를 사용합니다:\n\n![이미지](/TIL/assets/img/2024-07-13-StunningStreamlitDashboardsSimpleModularCodingForSmoothResults_1.png)\n\n애플리케이션은 기본 브라우저에서 실행됩니다. 셸 애플리케이션을 처음으로 살펴보겠습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테이블 태그를 Markdown 형식으로 변경해 주세요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그들의 데이터는 여기에서 자유롭게 접근할 수 있습니다.\n\n다운로드 페이지로 이동한 후에는 선택한 데이터에 대해 더욱 구체적으로 설정할 수 있습니다:\n![이미지](/TIL/assets/img/2024-07-13-StunningStreamlitDashboardsSimpleModularCodingForSmoothResults_3.png)\n\nUNHCR 다운로드 페이지 - \"원국\"과 \"청국\"을 선택합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 프로젝트에서는 각 난민의 출신 국가와 애쉬럼 국가를 가져와 봅시다.\n\n이 데이터를 통해 우리는 두 방향으로의 이동을 보여주는 난민 데이터를 가지고 있습니다:\n\n- 출신 국가에서 — 애움 신청자들이 이동하는 곳\n- 애움 국가에서 — 애움 신청자들이 오는 곳\n\n데이터셋을 다운로드한 후에, 우리는 어떤 데이터를 다루고 있는지 확인하기 위해 스프레드시트 형식으로 열어볼 수 있습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![Dashboard Screenshot](/TIL/assets/img/2024-07-13-StunningStreamlitDashboardsSimpleModularCodingForSmoothResults_4.png)\n\nThis project focuses on the following data fields:\n\n- **Country of origin:** The country from which a person seeking asylum is coming\n- **Country of asylum:** The country where a person is actually seeking asylum\n- **Recognized decisions:** The total number of asylum seekers accepted per country (in numeric format)\n- **Rejected decisions:** The number of asylum seekers denied asylum\n\nBoth the country of origin and asylum have a 3-letter ISO code, which serves as a reliable unique identifier.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 애플리케이션의 각 페이지를 함께 만들어 봅시다.\n\n# 페이지 1: 망명을 받는 상위 10개 국가 (막대/선버스트 차트)\n\n첫 번째 페이지로, 우리는 망명을 받는 상위 10개 국가를 보여주는 막대 차트를 만들 것입니다. 그리고 재미있게도, 가끔 해석하기 어려울 수도 있는 아름다운 선버스트 차트도 만들어 볼 거에요.\n\n우리는 글로벌 망명 결정을 연도 범위별로 보여주는 데이터 시각화 코드를 page_overview() 함수에 추가할 거에요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n데이터 세트를 로드하고 선택한 연도 범위에 따라 데이터를 필터링한 다음 두 가지 시각화를 만들어야 합니다: 총 난민 심사 결과 상위 10개 국가를 보여주는 수평 막대 차트와 출신 국가별로 나눈 Sunburst 차트입니다.\n\n```python\nimport pandas as pd\nimport plotly.express as px\n\n# 데이터 세트 로드\ndata = pd.read_csv('asylum-decisions.csv')\n\n# 난민 심사 결과 수를 얻는 도우미 함수\ndef get_asylum_counts(df, group_by_column):\n    return df.groupby([group_by_column])[\n        ['Recognized decisions', 'Rejected decisions', 'Total decisions']].sum().reset_index()\n```\n\n- 데이터 로드:\n\n- 데이터 세트는 pd.read_csv()를 사용하여 로드되어 data 변수에 저장됩니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2. 도우미 함수:\n\n- get_asylum_counts(df, group_by_column): 이 함수는 데이터를 지정된 열로 그룹화하고 인정된, 거부된 및 총 결정의 합계를 계산합니다.\n\n우리는 데이터에 액세스하기 위해 초기 셸 애플리케이션 상단에 이 코드를 추가해야 합니다.\n\n데이터 시각화가 포함된 page_overview() 함수의 전체 코드는 다음과 같습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# 페이지 1: 개요\ndef page_overview():\n    st.subheader(\"연도 범위별 전체 추방 판정 (범위 선택)\")\n\n    year_filter = st.slider(\"연도 범위\", int(data['Year'].min()), int(data['Year'].max()),\n                            (int(data['Year'].min()), int(data['Year'].max())))\n    filtered_data = data[(data['Year'] >= year_filter[0]) & (data['Year'] <= year_filter[1])]\n    asylum_counts = get_asylum_counts(filtered_data, 'Country of asylum')\n    top_countries = asylum_counts.sort_values(by='Total decisions', ascending=False).head(10)\n    fig_bar = px.bar(top_countries, x='Total decisions', y='Country of asylum', orientation='h',\n                     title=\"총 추방 판정 상위 10개 국가\",\n                     color='Total decisions', color_continuous_scale=px.colors.sequential.YlOrRd)\n    fig_bar.update_layout(showlegend=False, height=400, yaxis={'categoryorder': 'total ascending'})\n    fig_bar.update_coloraxes(showscale=False)  # 색상 스케일 제거\n    st.plotly_chart(fig_bar)\n    top_countries_origins = filtered_data[filtered_data['Country of asylum'].isin(top_countries['Country of asylum'])]\n    fig_sunburst = px.sunburst(top_countries_origins, path=['Country of asylum', 'Country of origin'], values='Total decisions',\n                               title=\"원산지별 상위 10개 국가의 출신국 분포\",\n                               color='Total decisions', color_continuous_scale=px.colors.qualitative.Bold)\n    fig_sunburst.update_layout(height=600, showlegend=False)\n    fig_sunburst.update_coloraxes(showscale=False)  # 색상 스케일 제거\n    st.plotly_chart(fig_sunburst)\r\n```\n\n위 코드에서 설명한 내용:\n\n- 슬라이더(st.slider)를 사용하여 데이터 필터링을 위한 연도 범위를 선택합니다.\n- 선택한 연도 범위를 기반으로 데이터가 필터링되며, 추방 판정 횟수가 계산됩니다.\n- 데이터를 정렬하여 총 추방 판정 상위 10개 국가를 결정합니다.\n- 수평 막대 차트(px.bar)를 사용하여 총 추방 판정 상위 10개 국가를 시각화합니다. 범례와 색상 스케일은 showlegend=False 및 update_coloraxes(showscale=False)를 사용하여 제거됩니다.\n- 상위 10개 국가의 출신국을 나타내기 위해 태양 편포 차트(px.sunburst)가 생성됩니다. 범례와 색상 스케일 역시 showlegend=False 및 update_coloraxes(showscale=False)를 사용하여 제거됩니다.\n\n위 코드를 사용하여 진행 상황을 테스트하고, 성장 중인 애플리케이션을 저장하고 실행할 수 있습니다. 시각적 결과는 다음과 같습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![이미지](/TIL/assets/img/2024-07-13-StunningStreamlitDashboardsSimpleModularCodingForSmoothResults_5.png)\n\n슬라이더를 조정하여 좀 더 집중된 연도 범위를 설정할 수 있습니다. 또한 Plotly sunburst 차트로는 실제 국가 (내부 원에서)를 클릭하여 더 상세한 숫자 세트를 생성할 수 있습니다:\n\n![이미지](/TIL/assets/img/2024-07-13-StunningStreamlitDashboardsSimpleModularCodingForSmoothResults_6.png)\n\n이 보기에서 각 국가 위로 마우스를 올리면 실제 숫자를 볼 수 있습니다.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n좋아요! 이제 우리 페이지 2에 국가별 데이터를 몇 가지 추가해보겠습니다.\n\n# 페이지 2: 국가별 데이터 시각화\n\n이제 페이지_country_analysis() 함수에 데이터 시각화 코드를 추가하여 선택한 국가의 난민 심사 결정을 표시할 수 있습니다.\n\n이 과정에는 두 가지 시각화가 포함됩니다: 연도별 인정된 및 거부된 난민 심사 결정 수를 보여주는 그룹화된 막대형 차트와 선택한 국가의 총 인정된, 거부된 및 총 심사 결정을 보여주는 수평 막대형 차트:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# 페이지 2: 국가별 분석과 그룹화된 막대 차트\ndef page_country_analysis():\n    st.subheader(\"국가별 분석\")\n\n    country = st.selectbox(\"국가 선택\", data['Country of asylum'].unique())\n    country_data = data[data['Country of asylum'] == country]\n    country_data_long = pd.melt(country_data, id_vars=['Year'],\n                                value_vars=['Recognized decisions', 'Rejected decisions'],\n                                var_name='결정 유형', value_name='수량')\n    fig_grouped_bar = px.bar(country_data_long, x='Year', y='수량', color='결정 유형', barmode='group',\n                             title=f\"{country}의 연도별 입국 결정\",\n                             labels={'수량': '결정 수'},\n                             color_discrete_sequence=px.colors.sequential.YlOrRd)\n    fig_grouped_bar.update_layout(height=400, showlegend=True)\n    st.plotly_chart(fig_grouped_bar)\n    total_decisions = country_data[\n        ['Recognized decisions', 'Rejected decisions', 'Total decisions']].sum().reset_index()\n    total_decisions.columns = ['결정 유형', '수량']\n    fig_horizontal_bar = px.bar(total_decisions, x='수량', y='결정 유형', orientation='h',\n                                title=f\"{country}의 총 입국 결정\",\n                                color='결정 유형', color_discrete_sequence=px.colors.sequential.YlOrRd)\n    fig_horizontal_bar.update_layout(height=300, showlegend=False)\n    st.plotly_chart(fig_horizontal_bar)\r\n```\n\n코드 설명:\n\n- 드롭다운 (st.selectbox)을 사용하여 데이터 세트의 국가 목록에서 국가를 선택합니다.\n- 선택한 국가를 기반으로 데이터가 필터링됩니다.\n- pd.melt()를 사용하여 데이터를 wide에서 long 형식으로 변환하여 그룹화된 막대 차트를 생성합니다.\n- 선택한 국가에 대해 연도별로 인정된 및 거부된 입국 결정의 수를 시각화하는 그룹화된 막대 차트 (px.bar)가 생성됩니다. 범례는 showlegend=True를 사용하여 표시됩니다.\n- 선택한 국가의 인정된, 거부된 및 총 결정 수를 계산하고 수평 막대 차트 (px.bar)를 사용하여 표시합니다. 범례는 showlegend=False를 사용하여 제거됩니다.\n\n이 코드를 간단히 복사하여 Page 2의 셸 애플리케이션에 붙여넣고 명령 프롬프트에서 실행할 수 있습니다. 결과:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/TIL/assets/img/2024-07-13-StunningStreamlitDashboardsSimpleModularCodingForSmoothResults_7.png\" />\n\n그럼, 이제 세 분의 길을 거쳐 왔어요. 마지막 페이지로 아름다운 전 세계 Choropleth 지도를 만들어 볼게요.\n\n# 페이지 3: 전 세계 Choropleth 지도\n\n이제 선택한 연도에 대한 전 세계 망명 결정의 분포를 표시하기 위해 데이터 시각화 코드를 page_choropleth() 함수에 추가해 보겠습니다. 이것은 각 나라별로 망명 결정의 총합을 시각화하는 choropleth 지도를 만드는 과정을 포함합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# Page 3: Choropleth Mapping\ndef page_choropleth():\n    st.subheader(\"전체 지도 매핑\")\n\n    year = st.selectbox(\"연도 선택\", sorted(data['Year'].unique()), key='year_select')\n    year_data = data[data['Year'] == year]\n    asylum_counts = get_asylum_counts(year_data, 'Country of asylum')\n    st.subheader(f\"{year}년 전체 난민 심사 분포\")\n    fig = px.choropleth(asylum_counts, locations=\"Country of asylum\", locationmode='country names',\n                        color=\"Total decisions\",\n                        hover_name=\"Country of asylum\", color_continuous_scale=px.colors.sequential.YlOrBr)\n    fig.update_layout(height=500)\n    st.plotly_chart(fig)\n    st.subheader(f\"{year}년 각 국가별 난민 심사결과\")\n    sorted_asylum_counts = asylum_counts.sort_values(by='Total decisions', ascending=False)\n    st.dataframe(sorted_asylum_counts)\n```\n\n위 코드를 설명하자면:\n\n- 드롭다운 (st.selectbox)을 사용하여 데이터 세트에 있는 연도 목록에서 연도를 선택합니다.\n- 선택한 연도를 기반으로 데이터를 필터링하고 난민 결정 횟수를 계산합니다.\n- 선택한 연도에 대한 각 국가의 총 난민 결정을 시각화하기 위해 코로플레스 맵 (px.choropleth)이 생성됩니다. 색상 스케일은 color_continuous_scale=px.colors.sequential.YlOrBr를 사용하여 설정합니다.\n- 난민 결정을 국가별로 내림차순으로 정렬된 데이터 테이블 (st.dataframe)이 표시됩니다.\n\n앞 페이지와 마찬가지로 이 코드를 페이지_choropleth() 함수에 복사하여 저장하고 실행하면 멋진 결과가 나타납니다:\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![이미지](/TIL/assets/img/2024-07-13-StunningStreamlitDashboardsSimpleModularCodingForSmoothResults_8.png)\n\n정말 멋지네요.\n\n네, 멀티페이지 스트림릿 애플리케이션을 만드는 것이 그렇게 간단합니다.\n\n만약 빌드에 문제가 있다면 코드(그리고 데이터셋)는 GitHub에서 찾을 수 있습니다. [여기](링크)\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 요약하자면...\n\nStreamlit은 Plotly와 같은 표준 Python 데이터 시각화 라이브러리를 사용하여 빠르고 쉽게 데이터 시각화를 생성할 수 있는 훌륭한 애플리케이션입니다.\n\n이 프로젝트는 다양한 범위의 연도에 걸쳐 글로벌 UNHCR 망명 데이터를 나타내는 3페이지의 Streamlit 애플리케이션을 보여줍니다.\n\n우리는 사용자에게 이 데이터에 대해 다양한 이야기와 관점을 제공하기 위해 6가지 다른 데이터 시각화를 만들었습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다중 페이지 애플리케이션 셸을 먼저 만들면 각 차트와 페이지를 쉽게 추가, 제거 또는 수정할 수 있습니다. 예를 들어, 네 번째 페이지를 추가하고 싶다면 \"Page 4\" 함수를 만들고 해당 페이지에 시각화를 추가한 다음 페이지 논리에 추가 메뉴 항목을 추가하면 됩니다(첫 번째 단계에서 만듦).\n\n이 내용이 유익하고 도움이 되었기를 바랍니다.\n\nGitHub 저장소: [여기](HERE)\n\n이 유형의 내용이 마음에 든다면 작가로서 저를 지원하고 싶다면 제 Substack를 구독해 주세요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nSubstack에서 매주 두 번 뉴스레터와 다른 플랫폼에서는 찾을 수 없는 기사를 게시하고 있어요.","ogImage":{"url":"/TIL/assets/img/2024-07-13-StunningStreamlitDashboardsSimpleModularCodingForSmoothResults_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-StunningStreamlitDashboardsSimpleModularCodingForSmoothResults_0.png","tag":["Tech"],"readingTime":18},{"title":"폰 노이만 이웃을 사용한 열 확산 시뮬레이션 실용적인 접근 방법","description":"","date":"2024-07-13 19:09","slug":"2024-07-13-SimulatingHeatDiffusionwithvonNeumannNeighborhoodAPracticalApproach","content":"\n\n# 요약\n\n**배경**: 열 확산은 다양한 과학 및 공학 분야에서 근본적인 문제로, 효율적인 계산 모델링 기술이 필요합니다. 셀룰러 오토마타에서 유래된 폰 노이만 이웃은 격자 기반 시스템에서 이러한 과정을 시뮬레이션하는 간단한 프레임워크를 제공합니다.\n\n**문제**: 열 확산을 정확하게 모델링하려면 계산 상 간단함과 이산 셀 간 열 전달의 본질적인 역학을 포착할 수 있는 방법이 필요합니다.\n\n**접근 방식**: 본 글에서는 폰 노이만 이웃을 적용하여 이차원 그리드에서 열 확산을 시뮬레이션하는 방법을 탐구합니다. 이산적인 열 방정식을 사용하여 각 셀의 온도를 업데이트하며, 이웃한 네 방향 (북, 남, 동, 서)의 온도에 기초하여 이루어집니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n결과: 이 시뮬레이션은 중앙 열원으로부터 열이 균일하고 대칭적으로 확산되는 패턴을 명확하게 나타내며, 온도 그래디언트를 적확하게 보여주는 컬러 코딩된 히트맵을 통해 정확하게 표현하고 있습니다. 폰 노이만 이웃은 열의 주요 방향성 흐름을 효과적으로 모델링하며, 이산형 계산 시스템에서의 유틸리티를 입증합니다.\n\n결론: 폰 노이만 이웃은 격자 기반 모델에서 열 확산을 시뮬레이션하는 견고하고 효율적인 방법을 제공합니다. 그 간단함과 효과적인 성능은 엔지니어와 과학자들에게 유용한 도구로, 다양한 실용적인 응용 프로그램에서 열 전달 역학의 정확한 표현을 가능하게 합니다.\n\n키워드: 열 확산; 폰 노이만 이웃; 세포자동기; 계산 모델링; 이산형 열 방정식.\n\n# 소개\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n컴퓨터 모델링에서 일부 개념이 열 확산만큼 광범위하게 적용되는 것은 없습니다. 열 확산은 재료의 열 속성을 최적화하려는 엔지니어이든 기후 패턴을 모델링하는 과학자이든 상관없이, 서로 다른 매체를 통해 열이 이동하는 방식을 이해하는 것이 중요합니다. 그렇다면 이 복잡한 물리적 과정을 컴퓨터 모델로 어떻게 전환할까요? 답은 세포 자동자에서 기본 개념인 폰 노이만 이웃[von Neumann neighborhood]에 있습니다.\n\n![이미지](/TIL/assets/img/2024-07-13-SimulatingHeatDiffusionwithvonNeumannNeighborhoodAPracticalApproach_0.png)\n\n## 폰 노이만 이웃: 세포 자동자의 중추 개념\n\n각각이 재료의 이산적 부분을 나타내는 셀 그리드를 상상해보세요. 각 셀의 온도는 시간이 지남에 따라 변화하며, 주변 셀의 온도에 영향을 받습니다. 이것이 폰 노이만 이웃이 중요한 이유입니다. 천재 수학자 존 폰 노이만에 의해 명명된 이 이웃은 어떤 셀에 대해 직접 인접한 네 개의 셀을 포함합니다: 북, 남, 동, 서. 이는 그리드 기반 시스템에서 상호 작용을 모델링하는 간단하면서도 강력한 방법입니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 열 확산: 기본 개념\n\n열 확산은 열이 높은 온도에서 낮은 온도 영역으로 퍼지는 방식을 설명합니다. 연속적인 매체에서는 열 방정식이 이 과정을 지배하는 편미분 방정식입니다. 그러나 우리 그리드와 같은 이산 시스템에서는 다른 접근 방식이 필요합니다. 여기서는 폰 노이만 이웃의 온도에 기초하여 각 셀의 온도를 업데이트하는 이산 열 방정식을 사용합니다.\n\n# 이론에서 실무로: 열 확산 구현하기\n\n폰 노이만 이웃을 사용하여 열 확산을 실제로 구현하는 방법에 대해 살펴봅시다. 각 셀이 물질의 작은 부분을 나타내는 2차원 그리드를 고려해보세요. 각 셀의 온도는 다음 규칙에 따라 이산 시간 단계에 걸쳐 진화합니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/TIL/assets/img/2024-07-13-SimulatingHeatDiffusionwithvonNeumannNeighborhoodAPracticalApproach_1.png)\n\n여기서 T_(i,j)t은 시각 t에서 (i,j) 위치의 셀 온도를 나타내고, α는 열 확산 상수입니다. 이 방정식은 열 확산의 본질을 포착합니다: 셀의 온도는 주변 셀이 더 뜨거우면 증가하고, 주변 셀이 더 차가우면 감소합니다.\n\n# 실용적 응용 및 그 이상\n\n폰 노이만 이웃과 함께 열 확산을 모델링하는 것은 학계에서만 하는 연습이 아닙니다. 이는 재료과학부터 환경 모델링까지 다양한 분야에서 실제 응용이 있습니다. 엔지니어들은 새로운 소재의 열적 특성을 최적화하기 위해 사용할 수 있으며, 과학자들은 지구 대기나 해양에서 열 흐름을 모델링할 수 있습니다. 또한 이 방법은 유체 역학이나 화학 확산과 같이 더 복잡한 현상으로 확장할 수도 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 단계별 시뮬레이션\n\n이 모델을 구현하는 간단한 Python 스크립트를 사용할 수 있습니다. 가운데 열원을 제외하고 모든 곳의 온도가 0인 그리드로 시작합니다. 시간이 지남에 따라 열이 그리드를 통해 어떻게 퍼지는지 관찰하게 됩니다.\n\n```js\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# 매개변수\nalpha = 0.1  # 열 확산율\n그리드 크기 = 50\n시간 단계 = 100\n\n# 초기 온도 분포가 있는 그리드로 초기화\n그리드 = np.zeros((그리드 크기, 그리드 크기))\n그리드[그리드 크기//2, 그리드 크기//2] = 100  # 초기 열원\n\n# 폰 노이만 이웃에 기반한 그리드를 업데이트하는 함수\ndef update_grid(grid, alpha):\n    new_grid = grid.copy()\n    for i in range(1, 그리드 크기-1):\n        for j in range(1, 그리드 크기-1):\n            new_grid[i, j] = grid[i, j] + alpha * (\n                grid[i+1, j] + grid[i-1, j] + grid[i, j+1] + grid[i, j-1] - 4*grid[i, j])\n    return new_grid\n\n# 시뮬레이션\nfor _ in range(시간 단계):\n    그리드 = update_grid(그리드, alpha)\n\n# 시각화\nplt.imshow(그리드, cmap='hot', interpolation='nearest')\nplt.colorbar()\nplt.title('폰 노이만 이웃을 사용한 열 확산')\nplt.show()\n```\n\n이 스크립트는 가운데 열원이 있는 그리드를 초기화하고 100개의 시간 단계 동안 열 확산 시뮬레이션을 수행합니다. update_grid 함수는 폰 노이만 이웃에 기반하여 각 셀의 온도를 업데이트하는 이산 열 방정식을 적용합니다. 최종 온도 분포는 히트맵을 사용하여 시각화되며, 열이 그리드를 통해 어떻게 퍼지는지 보여줍니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Heat Diffusion Simulation](/TIL/assets/img/2024-07-13-SimulatingHeatDiffusionwithvonNeumannNeighborhoodAPracticalApproach_2.png)\n\n해당 이미지는 폰 노이만 이웃을 사용하여 2차원 그리드에서 열 확산 시뮬레이션 결과를 보여주는 히트맵입니다. 이 히트맵의 해석은 다음과 같습니다:\n\n색상 그라디언트:\n\n- 색상 그라디언트는 검은색(낮은 온도를 나타냄)에서 밝은 노란색/흰색(높은 온도를 나타냄)까지 범위가 있습니다.\n- 열원으로 시작한 중앙 영역이 가장 밝은 색으로, 가장 높은 온도를 나타냅니다.\n- 중심으로부터 멀어질수록 색상이 빨간색과 주황색에서 검은색으로 변하며, 온도가 점진적으로 감소함을 보여줍니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n열 확산 패턴:\n\n- 이 패턴은 대칭적이고 원형이며, 중심점에서 시작되는 확산 과정에 특징적입니다.\n- 폰 노이만 이웃은 열이 주로 북쪽, 남쪽, 동쪽 및 서쪽으로 퍼진 후 다른 셀로 확산되도록 보장합니다.\n\n온도 척도:\n\n- 오른쪽에 있는 컬러 바는 색에 해당하는 온도 값을 나타냅니다.\n- 중앙 영역의 가장 높은 온도는 0.7에 가깝지만, 외부 영역은 0에 가까워집니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n격자 크기 및 경계:\n\n- 격자는 50x50 행렬이며, 축 레이블은 0에서 49까지의 범위입니다.\n- 열원은 중앙에 위치하기 때문에 열이 범위 내에서 충분히 퍼지지 않았기 때문에 격자의 경계는 최저 온도로 유지됩니다.\n\n시뮬레이션 시간 단계:\n\n- 부드러운 그라데이션은 열이 균등하게 확산되도록 여러 번 반복된 것을 시사합니다.\n- 시뮬레이션은 아마도 충분한 시간 단계를 거쳐 이 확산 단계에 도달할 수 있을 만큼 충분히 실행되었을 것으로 보입니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 히트맵은 폰 노이만 이웃을 사용하여 중앙 출처에서 열이 시간이 지남에 따라 어떻게 확산되는지 명확하게 시각화합니다. 이는 방사 대칭과 효과적인 열 확산을 강조하며 이산 열 방정식에 의해 모델링됩니다.\n\n# 결론\n\n요약하면, 폰 노이만 이웃은 이산 시스템에서 열 확산을 시뮬레이션하는 간단하면서도 강력한 프레임워크를 제공합니다. 복잡한 열 전달 과정을 간단한 지역 상호 작용으로 분해함으로써, 우리는 다양한 실용적 응용 프로그램을 가진 정확하고 효율적인 모델을 생성할 수 있습니다. 엔지니어, 과학자, 교육자이든, 이 접근 방식을 이해하고 구현하는 것은 여러분의 작업에서 새로운 가능성을 열 수 있습니다.\n\n폰 노이만 이웃의 원칙이 다른 유형의 확산 과정이나 계산 모델에 어떻게 적용될 수 있을까요? 아래 댓글에서 여러분의 생각과 경험을 공유해주세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 참고자료","ogImage":{"url":"/TIL/assets/img/2024-07-13-SimulatingHeatDiffusionwithvonNeumannNeighborhoodAPracticalApproach_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-SimulatingHeatDiffusionwithvonNeumannNeighborhoodAPracticalApproach_0.png","tag":["Tech"],"readingTime":8},{"title":"파이썬을 사용한 탐색적 데이터 분석EDA을 위한 데이터 시각화 방법","description":"","date":"2024-07-13 19:08","slug":"2024-07-13-DataVisualizationforExploratoryDataAnalysisEDAinPython","content":"\n\n데이터 시각화는 탐색적 데이터 분석의 중요한 부분이에요. 데이터를 분석하고 시각화함으로써 데이터의 분포, 변수 간의 관계, 그리고 이상값을 파악하는데 도움이 되죠.\n\n![Data Visualization Image](/TIL/assets/img/2024-07-13-DataVisualizationforExploratoryDataAnalysisEDAinPython_0.png)\n\n파이썬에는 시각화를 빠르고 효율적으로 만들 수 있는 다양한 라이브러리가 있어요. 파이썬을 사용하여 탐색적 데이터 분석 시 흔히 사용되는 시각화 유형은 다음과 같아요:\n\n- 막대 그래프: 다른 범주 간의 비교를 보여줄 때 사용돼요.\n- 선 그래프: 시간이나 다른 범주에 따른 추이를 보여줄 때 사용돼요.\n- 파이 차트: 각 범주의 비율이나 백분율을 보여줄 때 사용돼요.\n- 히스토그램: 단일 변수의 분포를 보여줄 때 사용돼요.\n- 히트맵: 서로 다른 변수 간의 상관 관계를 보여줄 때 사용돼요.\n- 산점도: 두 연속 변수 사이의 관계를 보여줄 때 사용돼요.\n- 상자 그림: 변수의 분포를 보여주고 이상값을 식별할 때 사용돼요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Python을 사용한 데이터 시각화 작성 단계\n\n- 비즈니스 문제 이해: 첫 번째 단계로, 올바른 시각화를 얻을 수 있도록 집중할 수 있습니다.\n- 필요한 라이브러리 가져오기: Pandas, Seaborn, Matplotlib, Plotly와 같은 필수 라이브러리를 가져옵니다.\n- 데이터셋 로드: 시각화하려는 데이터셋을 불러옵니다.\n- 데이터 정제 및 전처리: 결측치, 중복 및 이상치를 제거하고 범주형 데이터를 수치 데이터로 변환하여 데이터를 정제하고 전처리합니다.\n- 통계 요약: 평균, 중위수, 최빈값, 표준 편차 및 상관 계수와 같은 기술 통계를 계산하여 변수 간의 관계를 이해합니다.\n- 데이터 시각화 및 해석: 데이터의 분포, 관계 및 패턴을 이해하기 위해 시각화를 생성합니다. 이후 시각화를 해석하여 데이터에 대한 깨달음을 얻고 결론을 도출합니다.\n\n# 1. 비즈니스 문제 이해\n\n심혈관 질환은 전 세계적으로 주요 사망 원인입니다. 세계 보건 기구(WHO)에 따르면, 매년 약 1,790만 명이 심장 질환으로 사망합니다. 이들 사망의 85%는 심근경색 및 뇌졸중으로 인한 것입니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 기사에서는 Kaggle의 Heart Attack 데이터셋을 탐색하고 Python을 사용하여 EDA를 위한 데이터 시각화를 만들어볼 것입니다.\n\n해당 데이터셋에는 환자들의 연령, 성별, 혈압, 콜레스테롤 수준 등과 같은 다양한 변수에 대한 데이터가 포함되어 있습니다. 이 데이터셋의 목표는 환자의 의료 속성에 기반하여 해당 환자가 심근 경색 발병 위험에 노출되었는지를 예측하는 것입니다.\n\n# 2. 필요한 라이브러리 가져오기\n\n```js\n# 라이브러리 가져오기\nimport pandas as pd\nimport numpy as np\n\n# 데이터 시각화\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 3. 데이터 세트 로드하기\n\n판다스 데이터프레임에 데이터를 로드하고 탐색을 시작해봅시다.\n\n```python\nheart = pd.read_csv('heart.csv')\n```\n\n데이터를 로드했으니, 데이터프레임의 처음 몇 행을 살펴보며 데이터의 모습을 파악해봅시다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nheart.head()\n```\n\n<img src=\"/TIL/assets/img/2024-07-13-DataVisualizationforExploratoryDataAnalysisEDAinPython_1.png\" />\n\n데이터셋은 환자가 심장마비를 겪었는지 여부를 나타내는 출력 열을 포함한 총 14개의 열을 가지고 있는 것을 확인할 수 있습니다. 이제 시각화 작업을 시작해봅시다.\n\n# 4. 데이터 정리 및 전처리\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n데이터 정리의 목적은 분석하고 시각화할 준비를 하는 것입니다.\n\n```js\n# Null 값이 있는지 확인\nheart.isnull().sum().sort_values(ascending=False).head(11)\n```\n\n![image](/TIL/assets/img/2024-07-13-DataVisualizationforExploratoryDataAnalysisEDAinPython_2.png)\n\n여기서는 누락된 값이 없는 것을 확인할 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```yaml\n# 중복된 값 체크\nheart.duplicated().sum()\n\n![Screenshot](/TIL/assets/img/2024-07-13-DataVisualizationforExploratoryDataAnalysisEDAinPython_3.png)\n\n# 중복된 값 삭제\nheart.drop_duplicates(keep='first', inplace=True)\n\n![Screenshot](/TIL/assets/img/2024-07-13-DataVisualizationforExploratoryDataAnalysisEDAinPython_4.png)\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 데이터가 깔끔해졌어요.\n\n# 5. 통계 요약\n\n```js\n# 데이터셋의 통계 요약을 얻기\nheart.describe().T\n```\n\n<img src=\"/TIL/assets/img/2024-07-13-DataVisualizationforExploratoryDataAnalysisEDAinPython_5.png\" />\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n가장 중요한 결론은 대부분의 열에서, 평균 값이 중앙값(50번째 백분위: 50%)과 유사하다는 것입니다.\n\n# 6. 데이터 시각화 및 해석\n\n- 성별 기반 데이터 시각화\n\n```python\n# 심장 발작 대 성별 비교\ndf = pd.crosstab(heart['output'],heart['sex'])\nsns.set_style(\"white\")\n\ndf.plot(kind=\"bar\",\n        figsize=(6,6),\n        color=['#c64343', '#e1d3c1']);\n\nplt.title(\"심장 발작 위험 대 성별\", fontsize=16)\nplt.xlabel(\"0 = 낮은 위험                  1 = 높은 위험\", fontsize=16)\nplt.ylabel(\"수량\", fontsize=16)\nplt.legend([\"여성\",\"남성\"], fontsize=14)\nplt.xticks(rotation=0)\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![Image](/TIL/assets/img/2024-07-13-DataVisualizationforExploratoryDataAnalysisEDAinPython_6.png)\n\n```js\nfig = px.pie(heart2,\n            names= \"sex\",\n            template= \"presentation\",\n            hole= 0.6,\n            color_discrete_sequence=['#e1d3c1', '#c64343']\n            #color_discrete_sequence=px.colors.sequential.RdBu\n            )\n\n# layout\nfig.update_layout(title_text='Gender Distribution',\n                  title_x=0.5,\n                  font=dict( size=18),\n                  autosize=False,\n                  width=500,\n                  height=500,\n                  showlegend=False)\n\nfig.add_annotation(dict(x=0.5, y=0.5,  align='center',\n                        xref = \"paper\", yref = \"paper\",\n                        showarrow = False, font_size=22,\n                        text=\"<span style='font-size: 26px; color=#555; font-family:Arial'>Gender<br></span>\"))\n\nfig.update_traces(textposition='outside',  textinfo='percent+label', rotation=20)\nfig.show()\n```\n\n![Image](/TIL/assets/img/2024-07-13-DataVisualizationforExploratoryDataAnalysisEDAinPython_7.png)\n\n해석: 남성은 심장 공격의 위험이 더 높습니다.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 연령별 데이터 시각화\n\n```js\nplt.figure(figsize=(14,8))\nsns.set(font_scale=1.2)\nsns.set_style(\"white\")\n\nsns.countplot(x=heart[\"age\"],\n              palette='Reds')\n\nplt.title(\"환자 연령별 수\", fontsize=20)\nplt.xlabel(\"연령\", fontsize=16)\nplt.ylabel(\"수\", fontsize=16)\nplt.show()\n```\n\n![이미지](/TIL/assets/img/2024-07-13-DataVisualizationforExploratoryDataAnalysisEDAinPython_8.png)\n\n```js\n# 연령에 기반한 분석\nsns.set(font_scale=1.3)\n\nplt.figure(figsize=(8,6))\nsns.set_style(\"white\")\nsns.distplot(heart['age'],\n             color='red',\n             kde=True)\n\nplt.title(\"환자 연령대 분포\", fontsize=20)\nplt.xlabel(\"연령\", fontsize=16)\nplt.ylabel(\"밀도\", fontsize=16)\nplt.show()\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![이미지](/TIL/assets/img/2024-07-13-DataVisualizationforExploratoryDataAnalysisEDAinPython_9.png)\n\n해석: 대부분의 환자의 나이는 50-60대입니다. 그 중에서도 가장 많은 환자의 나이는 58세입니다.\n\n- 콜레스테롤 수준에 따른 데이터 시각화\n\n```python\n# 심장병 vs 콜레스테롤 분석\nsns.set(font_scale=1.3)\nplt.figure(figsize=(8,6))\nsns.set_style(\"white\")\n\nsns.distplot(heart[heart[\"output\"]==0][\"chol\"],\n             color=\"blue\")\nsns.distplot(heart[heart[\"output\"]==1][\"chol\"],\n             color=\"red\")\n\nplt.title(\"심장병 발병 위험 vs 콜레스테롤\", size=20)\nplt.xlabel(\"콜레스테롤 수준\", fontsize=16)\nplt.ylabel(\"밀도\", fontsize=16)\nplt.legend([\"낮은 위험\",\"높은 위험\"], fontsize=14)\nplt.show()\n```\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/TIL/assets/img/2024-07-13-DataVisualizationforExploratoryDataAnalysisEDAinPython_10.png\" />\n\n```js\nplt.figure(figsize=(8,6))\n\nsns.lineplot(y=\"chol\",\n             x=\"age\",\n             data=heart,\n             color=\"red\")\nplt.title(\"Cholesterol with Age\",fontsize=20)\nplt.xlabel(\"Age\",fontsize=16)\nplt.ylabel(\"Cholesterol Level\",fontsize=16)\nplt.show()\n```\n\n<img src=\"/TIL/assets/img/2024-07-13-DataVisualizationforExploratoryDataAnalysisEDAinPython_11.png\" />\n\n해석:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 환자들의 대부분은 콜레스테롤 수치가 200–300 사이에 있습니다.\n- 나이가 들수록 체내 콜레스테롤 수치가 증가할 가능성이 높습니다.\n- 가슴 통증 유형별 데이터 시각화\n\n```js\n# 가슴 통증 유형에 따른 심근경색과의 관계\ndf = pd.crosstab(heart3['cp'], heart['output'])\n\n# 크로스탭을 시각적으로 더 효과적으로 표현\nsns.set(font_scale=1.3)\nsns.set_style(\"white\")\n\ndf.plot(kind='bar',\n        figsize=(11,7),\n        color=['#e1d3c1', '#c64343']);\n\nplt.title(\"심근경색 발병 위험 vs. 가슴 통증 유형\", fontsize=20)\nplt.xlabel(\"가슴 통증 유형\", fontsize=16)\nplt.ylabel(\"수량\", fontsize=16)\nplt.legend(['낮은 위험','높은 위험'], fontsize=14)\nplt.xticks(rotation=0);\r\n```\n\n<img src=\"/TIL/assets/img/2024-07-13-DataVisualizationforExploratoryDataAnalysisEDAinPython_12.png\" />\n\n해석:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 대부분의 환자는 전형적인 협심증 유형을 가지고 있습니다.\n- 비협심통을 겪는 환자들은 심근경색 발생 위험이 높습니다.\n- 상관 관계 기반 데이터 시각화\n\n```js\nplt.figure(figsize=(12,10))\nsns.set(font_scale=0.9)\n\nsns.heatmap(heart.corr(),\n            annot=True,\n            cmap='Reds')\n\nplt.title(\"변수 간 상관 관계\", size=15)\nplt.show()\n```\n\n![그림](/TIL/assets/img/2024-07-13-DataVisualizationforExploratoryDataAnalysisEDAinPython_13.png)\n\n해석:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n열이 히트맵을 통해 다음 사항을 알 수 있습니다.\n\n- 가슴 통증 유형(cp)과 결과(Output)\n- 최대 심박수(thalachh)와 결과(Output)\n- 경사(sp)와 결과(Output)\n\n또한 약한 상관 관계를 확인할 수도 있습니다.\n\n- oldpeak: 이전 최고점과 결과(Output)\n- caa: 주요 혈관 수 및 결과(Output)\n- exng: 운동 유도성 협심증\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결론\n\n이 게시물에서는 막대 차트, 파이 차트, 라인 차트, 히스토그램, 히트맵과 같은 몇 가지 플롯을 생성하여 데이터 시각화를 사용하여 데이터 세트를 조사했습니다.\n\n탐색적 데이터 분석(EDA)과 데이터 시각화의 주요 목적은 어떤 가정을 하기 전에 데이터를 이해하는 데 도움을 주는 것입니다. 이것들은 분포, 요약 통계, 변수 간의 관계 및 이상치를 볼 수 있도록 도와줍니다.\n\n# Python 기초 개념\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n감사합니다! 🚀\n\"Python Fundamentals\"에서 더 많은 콘텐츠를 찾아보실 수 있어요 💫\n\n# 쉽게 설명한 것 🚀\n\n\"In Plain English\" 커뮤니티의 일원이 되어 주셔서 감사합니다! 계속하기 전에:\n\n- 글에 박수를 보내고 작가를 팔로우해주세요 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼에서도 만나보세요: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io에서 더 많은 콘텐츠를 확인해보세요","ogImage":{"url":"/TIL/assets/img/2024-07-13-DataVisualizationforExploratoryDataAnalysisEDAinPython_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-DataVisualizationforExploratoryDataAnalysisEDAinPython_0.png","tag":["Tech"],"readingTime":13},{"title":"Fed 모델을 이용한 주식 시장 가치 평가 및 방향 예측 방법","description":"","date":"2024-07-13 19:06","slug":"2024-07-13-PredictingStockMarketValuationandDirectionUsingtheFedModel","content":"\n\n![image](/TIL/assets/img/2024-07-13-PredictingStockMarketValuationandDirectionUsingtheFedModel_0.png)\n\n코르델 태니(Cordell Tanny)는 금융 서비스 분야에서 24년 이상의 경험을 보유한 전문가로, 주로 양적 금융에 특화되어 있습니다. 코르델는 이전에 주요 캐나다 기관에서 양적 분석가 및 포트폴리오 매니저로 근무하며 20억 달러 규모의 다자산 소매 투자 프로그램을 관리했습니다.\n\n현재 코르델는 Trend Prophets의 대표이사이자 공동 창립자로 활동하고 있으며, 양적 금융 및 AI 솔루션 기업인 DigitalHub Insights의 경영 이사로도 활동하고 있습니다. 또한, 코르델는 맥길 대학(McGill University)에서 생물학 학사 학위를 취득한 바 있습니다. 그는 CFA 채터홀더로서 금융 리스크 관리자 자격증을 보유하고 있으며, 금융 데이터 전문가 자격증을 소지하고 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\ntrendprophets.com을 방문하여 더 많은 정보를 얻을 수 있어요.\n\n이 기사에 대한 모든 Python 코드는 code templates를 등록하면 여기에서 찾을 수 있어요 (페이지 하단의 code templates에 등록하기란 부분에 있어요).\n\nS&P 500의 역사적 PE 데이터는 macrotrends.net의 공짜 다운로드로 이용 가능해요.\n\nGitHub 저장소에도 이용 가능해요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 간단 버전\n\n요약\n\nFed Model Basics: S&P 500의 수익률을 10년 만기 미국 국채 수익률과 비교하여 시장의 매력도를 평가합니다.\n\n스프레드 해석: 양의 스프레드는 주식이 저평가되었음을 나타내고, 음의 스프레드는 채권이 더 매력적이라는 것을 시사합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n인기를 얻은 Ed Yardeni에 의해 만들어진 이 모델은 혼돈스럽지만 여전히 유용한 가치평가 도구로 남아 있습니다.\n\n중요한 점\n\n투자 전략: 이 스프레드를 이해하면 투자자가 주식과 채권 간 자산배분에 관한 판단을 내릴 수 있습니다.\n\n현재 시장 상황: 16년 만에 처음으로 스프레드가 마이너스로 전환되었으며, 이는 주식이 과대평가되었을 가능성과 채권의 매력성을 시그널하는 신호입니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n인플레이션의 역할: 그레인저 인과관계 검정 결과에 따르면, 과거 CPI 인플레이션율은 연방준비제도 모형 차이를 예측할 수 있어 시장 예측에 통찰을 제공합니다.\n\n자세한 내용과 전체 이야기를 원하시는 분은 아래를 참조해주세요.\n\n# 큰 그림\n\n## 소개\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nFed Model은 주식이 채권보다 더 매력적인지 여부를 식별하는 데 도움을 주는 두 가지 지표를 사용하는 비교적 단순한 분석 기법입니다. 또한 시장 타이밍 모델로 활용될 수 있습니다. 이 두 가지 지표는 다음과 같습니다:\n\n- S&P 500의 주당 순이익률(주가 이익 비율의 역수)\n- 최근 10년 만기 미국 국채의 수익률\n\nFed Model은 주당 순이익률과 채권 수익률의 차이로 계산됩니다. 주당 순이익률은 지수가 얼마나 많이 벌어들이고 있는지(지수 안의 회사들의 모든 기업 이익의 합)를 나타내며 인덱스의 달러 가치당 가격의 누적 가치(인덱스 내의 모든 기업들의 가치의 누적 달러 가치)를 나타냅니다. 높은 주당 순이익률은 투자자들이 총 가격의 백분율로 초과 이익을 획득하고 있다는 것을 시사합니다.\n\n## 스프레드 해석과 그 영향\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nFed 모델은 S&P 500의 수익률과 10년 만기 미국 국채의 이자율 간의 차이로 정의됩니다. 이 차이는 투자자가 주식과 채권 간 상대적 매력성을 비교하는 데 도움을 줍니다.\n\n- 양수 차이: S&P 500의 수익률이 10년 만기 미국 국채의 수익률보다 높을 때 차이가 양수입니다. 이는 주식에 대한 투자자가 채권 대비 더 높은 수익을 얻고 있음을 나타냅니다. 양수 차이는 주식이 적정 가치에 있을 수도 있거나 상대적으로 안전한 채권 대비 주식 시장이 더 나은 성장 가능성을 제공할 수 있다는 점을 시사합니다.\n\n- 음수 차이: 반대로, 수익률이 10년 만기 국채의 이자율보다 낮을 때 차이는 음수입니다. 이 상황은 주식 대비로 채권이 더 매력적인 것을 시사할 수도 있습니다. 주식 시장이 과도하게 평가되었거나 경제 전망이 불확실할 경우 투자자들은 채권의 안전성을 추구할 수 있습니다.\n\n## Fed 모델의 (매우) 간단한 역사\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n내가 가장 좋아하는 투자 전략가 중 한 명이 페드 모델을 인기 있게 만들었어. 에드 야르데니는 주식 시장 수익과 장기 국채 수익률 사이의 관계를 분석한 작업을 기반으로 상당한 양의 작업물을 제작했지. 페드는 주식 수익률과 채권 수익률 사이의 관계를 보여주는 그래프를 많이 제작했지만, 그것을 모델로 형식화하거나 발표하거나 공식적으로 보증한 적은 없었어. 앨런 그린스팬은 중앙은행을 이끌 때 몇몇 기자회견에서 그에 대해 언급했어.\n\n이 모델의 간단함이 매우 매력적이지. 스프레드가 양수이면 주식을 사고, 음수이면 채권을 사라고. 시간 지표로서의 신뢰성은 조금 불안정하지만. 특히 2008년 대공황의 시간을 잘 맞추지 못했어. 그러나 완벽한 지표는 없으니까 우리는 항상 다른 지표들로부터 확인을 받아보는 게 좋지. 그러나 이는 확실하게 채권과 주식 사이의 상대적 가치 측정 수단이야.\n\n## 모델 시간에 따른 간단한 검토\n\n![이미지](/TIL/assets/img/2024-07-13-PredictingStockMarketValuationandDirectionUsingtheFedModel_1.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n제 1표는 1991년 이후 레세션 밴드가 중첩된 Fed 모델의 플롯을 보여줍니다. 우리는 또한 스프레드가 음수가 될 때를 나타내기 위해 y=0에 수평선을 그렸습니다. 이제 이는 스프레드이므로 양수 또는 음수의 판독이 발생할 수 있다는 점을 기억해야 합니다.\n\n- 주식 가격이 급격히 상승하여 과대평가가 되는 경우 (또는 그 반대).\n- 채권 금리가 너무 낮아 전혀 매력적이지 않은 경우.\n- 위의 요소들의 조합.\n\n1991년을 살펴보면, 연간 기준으로 인플레이션이 6% 이상이었지만 비교적 강한 어음 수입이 있었습니다 (우리는 침체 상황에서여서 가격이 꽤 떨어져 있었습니다). 높은 인플레이션은 엄격한 Fed 정책과 높은 이자율을 초래함으로써 해당 수십년 동안 음수 스프레드를 설명했습니다. 90년대 후반에는 어음 수입이 급락하여 닷컴 붐으로 인해 \"이성을 잃은 열정\"으로 유명한 앨런 그린스펀이 유명하게 부른 것과 유사한 상황이 발생했습니다.\n\n닷컴 붕괴 이후 2002년부터 2007년까지의 회복을 고려해봅시다. 인플레이션은 낮았으며 채권 금리는 3-5% 범위 내에 유지되었으며 어음 수입은 한 시점에서 6%를 초과했습니다. 2007년, 스프레드가 처음으로 부호를 바꾸고 2002년 이후 처음으로 음수로 전환된 것을 볼 수 있습니다. 2008년 침체가 곧 발생했습니다. 물론, 그때는 약간의 음수 지역에 빠질 정도가 아무것도 표시하지 않았을 것입니다. 오늘날 예지의 혜택이 주어져 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리는 이제 최저 금리의 10년대에 접어들었습니다. 그래서 다음 10년 동안 스프레드가 그렇게 높게 유지되는 것은 놀라운 일이 아닙니다. 채권은 단순히 수익을 제공하지 않았습니다. 올해에는 16년 만에 처음으로 스프레드가 음수로 전환되었습니다.\n\n그래서, 중요한 질문은, 이것이 의미하는 바가 있는지입니다.\n\n현재 상황을 살펴보겠습니다:\n\n- 고 인플레이션 시기.\n- 매우 오랜 시간 동안 보지 못한 수준의 급증한 이자율과 채권 금리.\n- 주식 시장이 역대 최고치를 경신하고 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n함께 하면 우리는 주식이 기업 실적 추격을 못하고 높은 수준에 이르렀으면서, 채권은 안정적인 이율을 제공하고 있다는 결론을 내릴 수 있습니다. 여전히 미 연방준비제도(Federal Reserve)의 계획이 불확실한 상황에서 채궘으로의 주요 자금 회전이 없다는 것을 감안하면, 현재 채권이 꽤 매력적으로 보입니다.\n\n그래서 현재 주식은 고평가되었고 채권이 매력적으로 보입니다. 이것에 놀라지 말아야 합니다.\n\n## 인플레이션은 채권 모델에 영향을 미칩니까?\n\n다음으로, 저는 인플레이션과 연방 모델 간의 관계를 조사하고 그 유무를 확인하고 싶었습니다. 직관적으로, 우리는 인플레이션이 두 자산 클래스의 가치에 영향을 미쳤다는 것을 알기 때문에 관련성이 있어야 하며, 이것은 몇 가지 양적 기법을 시도해보는 기회를 제공했습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n먼저, 연간 기준 소비자물가지수(CPI) 플롯을 Fed 모델과 함께 살펴보겠습니다 (그림 2). 흥미로운 그래프군요. 경기 침체 시에는 분명한 관련성이 있습니다. 그러나 이 그래프에서 어떤 결론을 도출하는 것은 매우 어렵습니다.\n\n![Figure 2](/TIL/assets/img/2024-07-13-PredictingStockMarketValuationandDirectionUsingtheFedModel_2.png)\n\n그림 3은 각 시리즈의 월별 값에 대한 산점도를 보여줍니다. 두 값 사이에 상관관계가 전혀 없음을 알 수 있습니다 (로 = -0.11). 그러나 이 관계는 선형일 필요는 없으며, 연이어 발생하는 상관관계를 고려하지 않았습니다. 선형 관계가 없으므로 표준 회귀 분석도 도움이 되지 않을 것입니다.\n\n![Figure 3](/TIL/assets/img/2024-07-13-PredictingStockMarketValuationandDirectionUsingtheFedModel_3.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nThe Granger Causality Test\n\n그레인저 인과관계 검정은 한 시계열이 다른 시계열을 예측할 수 있는지를 결정하기 위해 사용되는 통계적 가설 검정입니다. 이 방법은 그레인저라는 사람에 의해 개발되었는데, 이 기법에 대한 작업으로 노벨 경제학상을 수상했습니다. 이 검정은 변수 X가 변수 Y를 그레인저 인과로 유발한다면, X의 과거값은 Y의 과거값만으로는 예측할 수 없는 Y를 예측하는 데 도움이 되는 정보를 포함해야 한다는 원리에 기초합니다.\n\n이 분석에서는 과거 소비자물가지수(CPI) 인플레이션율이 Fed 모델차와를 예측할 수 있는지를 검정합니다. 결과는 3~4개월의 지연으로 중요한 예측력을 보여주며, 이는 지난 인플레이션 데이터가 Fed 모델에 의한 시장 가치평가를 예측하는 데 도움이 되는 것으로 나타납니다 (테이블 1, Python 함수에서의 결과). 이는 인플레이션의 과거값(3 또는 4개월 전)이 Fed 모델의 미래 방향을 추론하는 데 사용될 수 있다는 것을 시사합니다!\n  \n![image](/TIL/assets/img/2024-07-13-PredictingStockMarketValuationandDirectionUsingtheFedModel_4.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 일부 생각\n\n구현 중이던 코드를 다시 살펴볼 때, 페드 모델을 새롭게 살펴보기로 결정했고, 이제 한동안 보지 않았다는 것을 깨달았는데, 워렌 버핏식으로 매우 흥미로워 보입니다. 어디에 서 있는지 보는 것이 재미있을 것 같았어요.\n\n하지만 이러한 결과를 예상하지 못했습니다.\n\n최종 결론:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 지난 몇 년 동안 페드 모델에 대한 언급을 많이 보지 못했는데, 16년 만에 처음으로 부정적으로 전환된 사실을 전략가들이 주목해야 합니다.\n- 인플레이션을 잠재적 요인으로 확인하는 것은 직관적입니다. 더 많은 변수를 테스트하고 아마도 regime classification에 도움이 될 멋진 비지도 학습 모델을 만들어 볼 수 있을 것입니다.\n\n그리고 이는 또 다른 데이터 과학 프로젝트의 주제가 될 것입니다!\n\n한 테스트 결과에 결론을 내리기 위해 완전히 의존할 수는 없다는 것을 기억하세요. 이 잠재적 관련성에 대해 더 명확하게 이해하기 위해 다른 기법을 테스트해 보았지만, 그것이 쉽지는 않습니다. 이것이 왜 양적 금융이 재미있는 이유입니다.\n\n본문의 모든 Python 코드는 여기서 코드 템플릿을 등록하면 찾을 수 있습니다(페이지 하단의 \"코드 템플릿 등록\" 부분).\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nLinkedIn이나 Medium에서 나를 팔로우해 주세요!","ogImage":{"url":"/TIL/assets/img/2024-07-13-PredictingStockMarketValuationandDirectionUsingtheFedModel_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-PredictingStockMarketValuationandDirectionUsingtheFedModel_0.png","tag":["Tech"],"readingTime":11},{"title":"FAISS 벡터 공간 시각화를 통한 RAG 성능 이해하기","description":"","date":"2024-07-13 19:04","slug":"2024-07-13-VisualizingFAISSVectorSpacetoUnderstanditsInfluenceonRAGPerformance","content":"\n\n<img src=\"/TIL/assets/img/2024-07-13-VisualizingFAISSVectorSpacetoUnderstanditsInfluenceonRAGPerformance_0.png\" />\n\n오픈 소스 대형 언어 모델의 성능이 계속해서 향상되면서, 코드 작성 및 분석, 추천, 텍스트 요약 및 질문-응답(QA)을 포함한 다양한 응용 프로그램에 진입하고 있습니다. QA 관련 질문에 대해 언어 모델이 자주 실패하는데, 이는 훈련 중에 사용되지 않은 문서와 관련된 질문들에 적용될 때 발생합니다. 그리고 이러한 내부 문서들 중 많은 것들은 규정 준수, 영업 비밀 또는 개인 정보 보호를 위해 기업의 벽 안에 유지되어야 합니다. 이러한 문서에 대해 쿼리를 실행할 때, 언어 모델은 가상 현상을 겪는데, 이는 관련 없거나 가짜 또는 일관성 없는 내용을 생성합니다.\n\n이러한 도전과제를 해결하기 위한 하나의 기술은 검색 보강 생성(Retrieval-Augmented Generation, RAG)입니다. 이는 답변 생성 이전에 훈련 데이터 소스 외부의 권위 있는 지식 베이스를 참조하여 언어 모델의 응답을 개선하는 과정을 포함합니다. RAG 어플리케이션은 말뭉치로부터 관련 문서 단편을 가져오는 검색 시스템과, 검색된 단편을 컨텍스트로 사용하여 답변을 생성하는 언어 모델로 구성됩니다. 당연히, 말뭉치의 품질과 그것이 표현된 벡터 공간, 즉 임베딩(embeddings)은 RAG의 정확도에 중요한 역할을 할 것입니다.\n\n본 기사에서는 FAISS 벡터 공간의 다차원 임베딩을 renumics-spotlight 시각화 라이브러리를 사용하여 2차원으로 시각화하는 방법을 살펴보겠습니다. 특정 핵심 벡터화 매개변수를 변화시킴으로써 RAG 응답 정확도를 향상시킬 기회를 찾아보겠습니다. 그리고 선택한 언어 모델로는 TinyLlama 1.1B Chat을 채택할 것인데, 이는 Llama 2와 동일한 아키텍처와 토크나이저를 갖추고 있습니다 [1]. 이 모델은 리소스 풋프린트가 상당히 작고 빠른 실행 시간을 가지고 있으면서 정확도가 비례적으로 감소하지 않는 장점을 갖추고 있습니다. 이는 빠른 실험에 이상적입니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 목차\n1.0 환경 설정\n2.0 설계 및 구현\n   2.1 LoadFVectorize 모듈\n   2.2 주요 모듈\n3.0 테스트 실행\n   3.1 청크 크기 및 중첩 매개변수 테스트\n4.0 최종 생각\n\n# 1.0 환경 설정\n\n이 실험은 8GB RAM을 갖춘 MacBook Air M1에서 수행될 예정입니다. 여기서 사용하는 Python 버전은 3.10.5입니다. 먼저, 이 프로젝트를 관리하기 위해 가상 환경을 생성해 봅시다. 환경을 생성하고 활성화하기 위해 다음을 실행해 봅시다:\n\n```js\npython3.10 -m venv mychat\nsource mychat/bin/activate\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nLibrary renumics-spotlight은 UMAP와 유사한 시각화를 사용하여 고차원 임베딩을 더 관리하기 쉬운 2D 시각화로 줄이는 동시에 중요한 속성을 보존합니다 [2]. 이제 필요한 모든 라이브러리를 설치해 보겠습니다:\n\n```js\npip install langchain faiss-cpu sentence-transformers flask-sqlalchemy psutil unstructured pdf2image unstructured_inference pillow_heif opencv-python pikepdf pypdf\npip install renumics-spotlight\nCMAKE_ARGS=\"-DLLAMA_METAL=on\" FORCE_CMAKE=1 pip install --upgrade --force-reinstall llama-cpp-python --no-cache-dir\n```\n\n위의 마지막 줄은 M1 프로세서에서 하드웨어 가속을 사용하여 TinyLlama를 로드하는 데 사용될 메탈 지원이 포함된 llama-cpp-python 라이브러리를 설치하는 것을 의미합니다. Metal을 사용하면 계산이 GPU에서 실행됩니다.\n\n환경이 준비되었으므로 시스템 설계를 살펴보고 구현을 따라갑시다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 2.0 디자인 및 구현\n\n이 QA 시스템에는 그림 1에 설명된 두 모듈이 있습니다.\n\n![이미지](/TIL/assets/img/2024-07-13-VisualizingFAISSVectorSpacetoUnderstanditsInfluenceonRAGPerformance_1.png)\n\nLoadFVectorize 모듈은 PDF 또는 웹 문서를 로드하는 작업을 포함합니다. 초기 테스트 및 시각화를 위해, 최근에 출시된 (2023년 12월) 440페이지의 벤더 배포 가이드가 관심 문서로 사용됩니다. 이 모듈은 문서의 분할 및 벡터화를 처리합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n두 번째 모듈은 LLM을 로드하고 FAISS 검색기를 인스턴스화한 후, LLM, 검색기 및 사용자 정의 프롬프트를 포함하는 검색 체인을 생성하는 것으로 구성되어 있습니다. 마지막으로 벡터 공간 시각화를 시작합니다.\n\n두 모듈의 세부 정보는 더 설명되어 있습니다.\n\n## 2.1 Module LoadFVectorize\n\n이 모듈은 3가지 함수로 구성되어 있습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- load_doc 함수는 온라인 pdf 문서를 로드하고, 512자씩 묶어 chunk 단위로 나누며 100자의 overlap을 가지고 문서 목록을 반환합니다.\n- vectorize 함수는 위 load_doc 함수를 호출하여 문서의 chunked 목록을 가져와 임베딩을 생성하고 opdf_index 로컬 디렉토리에 저장한 뒤 FAISS 인스턴스를 반환합니다.\n- load_db 함수는 opdf_index 디렉토리 내에 FAISS 벡터 저장소가 있는지 확인하고, 없는 경우 vectorize 함수를 호출하여 문서를 로드하고 벡터화합니다. 최종적으로 FAISS 객체를 반환합니다.\n\n이 모듈의 전체 코드 목록은 아래와 같습니다.\n\n```python\n# LoadFVectorize.py\n\nfrom langchain_community.embeddings import HuggingFaceEmbeddings\nfrom langchain_community.document_loaders import OnlinePDFLoader\nfrom langchain.text_splitter import RecursiveCharacterTextSplitter\nfrom langchain_community.vectorstores import FAISS\n\n# 온라인 pdf에 접근\ndef load_doc() -> 'List[Document]':\n    loader = OnlinePDFLoader(\"https://support.riverbed.com/bin/support/download?did=7q6behe7hotvnpqd9a03h1dji&version=9.15.0\")\n    documents = loader.load()\n    text_splitter = RecursiveCharacterTextSplitter(chunk_size=512, chunk_overlap=100)\n    docs = text_splitter.split_documents(documents)\n    return docs\n\n# 벡터화 및 디스크에 저장\ndef vectorize(embeddings_model) -> 'FAISS':\n    docs = load_doc()\n    db = FAISS.from_documents(docs, embeddings_model)\n    db.save_local(\"./opdf_index\")\n    return db\n\n# 디스크에서 벡터 저장소를 로드하려고 시도\ndef load_db() -> 'FAISS':\n    embeddings_model = HuggingFaceEmbeddings()\n    try:\n        db = FAISS.load_local(\"./opdf_index\", embeddings_model)\n    except Exception as e:\n        print(f'Exception: {e}\\n디스크에 인덱스가 없음, 새로 생성 중...')\n        db = vectorize(embeddings_model)\n    return db\n```\n\n## 2.2 메인 모듈\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n주요 모듈은 먼저 TinyLlama에 대한 프롬프트 템플릿을 정의합니다. 템플릿은 다음과 같습니다:\n\n`|system|`'context'`/s``|user|`'question'`/s``|assistant|`\n\nLLM 메모리 사용량을 더 줄이기 위해, TheBloke의 HuggingFace 레포지토리 [3]에서 TinyLlama의 양자화된 버전을 채택할 것입니다. 이는 모델 매개변수에 더 적은 비트를 사용하는 방식입니다. 이 LLM에 대한 추가적인 배경 정보나 활성화 기술에 대해 더 자세히 알고 싶은 분들은 이전에 작성한 기사를 확인해보세요. GGUF 형식으로 양자화된 LLM을 로드하기 위해 LlamaCpp를 사용합니다. 이전 모듈에서 반환된 FAISS 객체를 사용하여 FAISS retriever가 생성됩니다. 이러한 객체들을 사용하여 RetrievalQA 체인을 생성하고 질문에 사용합니다.\n\n아래 코드는 이러한 단계를 포착합니다.\n\n```js\n# main.py\nfrom langchain.chains import RetrievalQA\nfrom langchain.prompts import PromptTemplate\nfrom langchain_community.llms import LlamaCpp\nfrom langchain_community.embeddings import HuggingFaceEmbeddings\nimport LoadFVectorize\nfrom renumics import spotlight\nimport pandas as pd\nimport numpy as np\n\n# 프롬프트 템플릿\nqa_template = \"\"\"<|system|>\n정확하게 대답하는 친근한 채팅 봇입니다. \n알 수 없는 답변일 경우 공손하게 알려드릴 것입니다.\n다음 맥락을 사용하여 아래 질문에 답변해주세요:\n{context}</s>\n<|user|>\n{question}</s>\n<|assistant|>\n\"\"\"\n\n# 프롬프트 인스턴스 생성\nQA_PROMPT = PromptTemplate.from_template(qa_template)\n# LLM 로드\nllm = LlamaCpp(\n    model_path=\"./models/tinyllama_gguf/tinyllama-1.1b-chat-v1.0.Q5_K_M.gguf\",\n    temperature=0.01,\n    max_tokens=2000,\n    top_p=1,\n    verbose=False,\n    n_ctx=2048\n)\n# 벡터화 및 retriever 생성\ndb = LoadFVectorize.load_db()\nfaiss_retriever = db.as_retriever(search_type=\"mmr\", search_kwargs={'fetch_k': 3}, max_tokens_limit=1000)\n# QA 체인 정의\nqa_chain = RetrievalQA.from_chain_type(\n    llm,\n    retriever=faiss_retriever,\n    chain_type_kwargs={\"prompt\": QA_PROMPT}\n)\n\nquery = 'What versions of TLS supported by Client Accelerator 6.3.0?'\n\nresult = qa_chain({\"query\": query})\nprint(f'--------------\\nQ: {query}\\nA: {result[\"result\"]}')\n\nvisualize_distance(db,query,result[\"result\"])\r\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n벡터 공간 시각화 자체는 위 코드 목록의 마지막 줄인 visualize_distance에 의해 처리됩니다. 이 기능 또한 이 모듈에 정의되어 있습니다.\n\nvisualize_distance 함수에서는 먼저 FAISS 객체의 __dict__ 속성에 액세스해야 합니다. 이는 인스턴스 변수용 사전입니다. 이를 통해 docstore에 액세스할 수 있습니다. 인스턴스 변수 index_to_docstore_id는 키 인덱스로 값 docstore-id의 사전입니다. 벡터화에 사용된 총 문서 수는 인덱스 객체의 ntotal 속성으로 나타냅니다.\n\n```js\n    vs = db.__dict__.get(\"docstore\")\n    index_list = db.__dict__.get(\"index_to_docstore_id\").values()\n    doc_cnt = db.index.ntotal\n```\n\n벡터 공간을 대략적으로 복원하기 위해 우리는 단순히 객체 인덱스의 메서드인 reconstruct_n을 기본 매개변수와 함께 호출합니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n   embeddings_vec = db.index.reconstruct_n()\n```\n\n이제 인덱스 목록으로 문서 저장소 ID 목록이 있으므로, 관련 문서 객체를 찾아 해당 ID, 문서 메타데이터, 문서 내용 및 벡터 공간 내 임베딩을 포함하는 리스트를 생성해보겠습니다. 아래 코드를 참조해주세요.\n\n```js\n   doc_list = list() \n   for i, doc_id in enumerate(index_list):\n       a_doc = vs.search(doc_id)\n       doc_list.append([doc_id, a_doc.metadata.get(\"source\"), a_doc.page_content, embeddings_vec[i]])\n```\n\n그런 다음 이 리스트를 사용하여 열 제목이 있는 데이터프레임을 생성한 후, 시각화를 만들기 위해 spotlight 호출에 사용될 것입니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\n    df = pd.DataFrame(doc_list, columns=['id', 'metadata', 'document', 'embedding'])\n```\n\n시각화를 진행하기 전에 질문과 답변을 통합할 방법을 찾아야 합니다. 질문 및 답변을 위한 별도의 데이터프레임을 생성하고 주요 데이터프레임과 병합하여 두 데이터가 나머지 문서 청크와 함께 어디에 나타나는지 보여줄 수 있도록합니다:\n\n```python\n    # 질문 및 답변을 위한 행 추가\n    embeddings_model = HuggingFaceEmbeddings()\n    question_df = pd.DataFrame(\n        {\n            \"id\": \"question\",\n            \"question\": question,\n            \"embedding\": [embeddings_model.embed_query(question)],\n        })\n    answer_df = pd.DataFrame(\n        {\n            \"id\": \"answer\",\n            \"answer\": answer,\n            \"embedding\": [embeddings_model.embed_query(answer)],\n        })\n    df = pd.concat([question_df, answer_df, df])\n```\n\n이 공간에서 질문과 문서 간의 유클리드 거리를 찾으려면 질문을 위한 임베딩을 만든 다음 문서와 질문 임베딩 차이에 대해 numpy의 `linalg.norm`을 사용하십시오:  \n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n    question_embedding = embeddings_model.embed_query(question)\n    # 벡터 거리를 나타내는 열 추가\n    df[\"dist\"] = df.apply(                                                                                                                                                                         \n        lambda row: np.linalg.norm(\n            np.array(row[\"embedding\"]) - question_embedding\n        ),axis=1,)\n```\n\n데이터프레임을 얻었으면 spotlight.show를 호출하여 시각화를 생성합니다.\n\n```js\nspotlight.show(df)\n```\n\n왔어요! 이렇게 하면 브라우저 창에서 spotlight가 열리고 pandas 데이터프레임이 탐색 준비가 됩니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래 GitHub 저장소에서 모든 코드에 액세스할 수 있습니다:\n\n## 3.0 테스트 실행\n\n첫 번째 실험을 용이하게하기 위해 선택된 샘플 질문은 아래와 같습니다:\n\n채택된 문서에 따르면, 올바른 답은 :\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n또한, 다음 추가 정보가 응답에 포함될 수 있습니다.\n\n아래는 위 질문에 대한 TinyLlama의 응답입니다:\n\n이 응답은 실제 답변과 꽤 유사해 보이지만, 이 TLS 버전들이 기본값은 아니라는 점에서 완전히 정확하지는 않습니다.\n\nFig. 2는 스포트라이트의 스크린샷을 나타냅니다. 왼쪽 상단의 테이블 섹션에는 데이터프레임의 모든 열이 표시되고 시각화는 유사성 맵 탭 뷰 내에서 표시됩니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![링크 텍스트](/TIL/assets/img/2024-07-13-VisualizingFAISSVectorSpacetoUnderstanditsInfluenceonRAGPerformance_2.png)\n\n가시적인 열 버튼을 사용하여 표시되는 열을 제어할 수 있습니다. \"dist\"로 테이블을 정렬하면 상위에 질문, 답변 및 가장 관련성 높은 문서 스니펫이 나타납니다. 임베딩 시각화를 살펴보면 여기의 거의 모든 문서를 하나의 클러스터로 나타냅니다. 이는 원래 pdf가 특정 제품의 배포 가이드임을 감안할 때 합리적일 것으로 생각됩니다. Similarity Map 탭 내의 필터 아이콘을 클릭하면 선택한 문서 목록만 강조 표시되며 나머지는 회색으로 표시됩니다(Fig. 3 참조).\n\n![링크 텍스트](/TIL/assets/img/2024-07-13-VisualizingFAISSVectorSpacetoUnderstanditsInfluenceonRAGPerformance_3.png)\n\n## 3.1 테스트 청크 크기 및 겹치기 매개변수\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n리트리버가 RAG 성능에 중요한 영향을 미친다고 해서, 우리는 임베딩 공간에 영향을 주는 몇 가지 매개변수를 살펴보겠습니다. 테이블 1은 문서 분할 중 TextSplitter의 청크 크기 (1000, 2000) 및/또는 오버랩 (100, 200) 매개변수가 다양하게 변할 때, TinyLlama의 응답을 포착하고 정리합니다.\n\n![Image](/TIL/assets/img/2024-07-13-VisualizingFAISSVectorSpacetoUnderstanditsInfluenceonRAGPerformance_4.png)\n\n첫눈에, 모든 조합의 LLM 응답이 비슷해 보입니다. 그러나 정확한 답변과 각 응답을 주의 깊게 비교하면, 정확한 답변은 (1000, 200) 조합에 해당합니다. 다른 응답에서의 부정확한 세부사항은 빨간색으로 강조되었습니다. 이러한 행동을 설명하기 위해, Fig. 3은 각 조합에 대한 임베딩 맵을 옆으로 나란히 보여줍니다.\n\n![Image](/TIL/assets/img/2024-07-13-VisualizingFAISSVectorSpacetoUnderstanditsInfluenceonRAGPerformance_5.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n왼쪽부터 오른쪽으로 청크 크기를 증가시키면서 벡터 공간이 더 드문 형태로 변해갑니다. 아래에서 위로 가면 겹침이 두 배가 된 곳에서도 벡터 공간의 특성이 급격하게 변하지는 않습니다. 이 모든 맵에서 전체 컬렉션은 여전히 한 클러스터처럼 보이며 몇 개의 이상치만 존재합니다. 이는 생성된 응답에서 명확히 반영되며, 이들은 상당히 유사합니다. 질의가 클러스터의 중심에 있는 경우, 이웃들이 다를 가능성이 높으므로 이러한 매개변수의 변화에 따라 응답이 상당히 달라질 수 있습니다.\n\nRAG 애플리케이션이 특정 질문에 대해 기대한 답변을 제공하지 않는 경우, 해당 질문들과 함께 위와 같은 시각화를 생성함으로써 말뭉치를 어떻게 분할하여 전체 성능을 개선할지에 대한 추가 통찰을 얻을 수 있습니다.\n\n그리고 좀 더 설명하기 위해, 상관 없는 도메인의 두 개의 위키백과 문서가 차지하는 벡터 공간을 시각화해 봅시다. 이를 위해 LoadFVectorize 모듈 내 load_doc 함수의 첫 줄을 수정하여 웹 기반 두 URL의 WebBasedLoader를 구현하면 됩니다. 하나는 그래미 어워즈에 관한 것이고, 다른 하나는 JWST 망원경에 대한 것입니다. 아래와 같이 나타납니다.\n\n```js\ndef load_doc():\n    loader = WebBaseLoader(['https://en.wikipedia.org/wiki/66th_Annual_Grammy_Awards','https://en.wikipedia.org/wiki/James_Webb_Space_Telescope'])\n    documents = loader.load()\n    ...\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n나머지 코드는 그대로 유지하고 있는 것을 확인하면, 우리는 그림 5에 나타난 벡터 공간 시각화를 얻을 수 있습니다.\n\n<img src=\"/TIL/assets/img/2024-07-13-VisualizingFAISSVectorSpacetoUnderstanditsInfluenceonRAGPerformance_6.png\" />\n\n예상대로, 여기에는 두 개의 명확하게 겹치지 않는 클러스터가 있습니다. 우리가 두 클러스터 모두 벗어난 질문을 하면, 검색기에서 얻는 결과 문맥은 적어도 LLM에게 도움이 되지는 않을 것이지만 오히려 해로울 것입니다. 그리고 재미로, 나는 이전에 묻은 같은 질문을 한 번 더 던져보기로 결정했습니다. 그리고 확실히 LLM은 환각하기 시작했습니다.\n\n여기 우리 시스템 디자인에는 벡터 저장을 위해 FAISS를 사용했습니다. 만약 당신이 ChromaDB를 사용하고 비슷한 시각화를 수행하는 방법을 궁금해 한다면, 당신은 운이 좋습니다. renumics-spotlight 라이브러리 개발자 중 Markus Stoll이 여기에 관련된 흥미로운 기사를 썼습니다. 확인해보세요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 4.0 마무리\n\nRetrieval-Augmented Generation (RAG)은 내부 문서에 교육되지 않은 큰 언어 모델(LM)을 활용할 수 있게 해줍니다. RAG은 벡터 저장소에서 여러 관련 문서 청크를 검색하여 LM이 생성을 위한 문맥으로 사용합니다. 따라서 임베딩의 품질은 RAG 성능에 중요한 역할을 합니다.\n\n이 기사에서는 주요 벡터화 매개변수 중 일부가 전체 LM 성능에 미치는 영향을 시연하고 시각화했습니다. 우리는 리소스 풋프린트가 훨씬 작지만 여전히 높은 정확도를 자랑하는 TinyLlama 1.1B Chat를 선택했습니다. 라이브러리 'renumics-spotlight'를 사용하여 FAISS 벡터 공간 전체를 데이터프레임으로 표현하는 방법을 보여주었으며, 이를 사용하여 한 줄의 코드로 임베딩을 시각화했습니다. Spotlight의 직관적인 UI를 통해 질문에 대한 벡터 공간을 탐색하고, 이를 통해 LM의 응답을 더 잘 이해할 수 있습니다. 특정 벡터화 매개변수를 조정함으로써, 성능을 향상시키기 위해 생성 및 행동을 제어할 수 있습니다.\n\n읽어 주셔서 감사합니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 참고 자료\n\n1. [TinyLlama-1.1B-Chat-v1.0](https://huggingface.co/TinyLlama/TinyLlama-1.1B-Chat-v1.0)\n2. [spotlight](https://github.com/Renumics/spotlight)\n3. [TinyLlama-1.1B-Chat-v1.0-GGUF](https://huggingface.co/TheBloke/TinyLlama-1.1B-Chat-v1.0-GGUF)","ogImage":{"url":"/TIL/assets/img/2024-07-13-VisualizingFAISSVectorSpacetoUnderstanditsInfluenceonRAGPerformance_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-VisualizingFAISSVectorSpacetoUnderstanditsInfluenceonRAGPerformance_0.png","tag":["Tech"],"readingTime":17},{"title":"와 를 사용해서 Python 함수 파라미터를 깔끔하게 정리하는 방법","description":"","date":"2024-07-13 19:03","slug":"2024-07-13-UseandtoMakeYourPythonFunctionParametersLookNeater","content":"\n\n![TIL 이미지](/TIL/assets/img/2024-07-13-UseandtoMakeYourPythonFunctionParametersLookNeater_0.png)\n\n파이썬에서는 위치 매개변수 또는 키워드 매개변수를 사용하여 함수에 데이터를 전달할 수 있습니다. 이는 파이썬에서 함수를 매우 유연하게 사용할 수 있게 해줍니다. 그러나 이에는 일부 제한 사항이 있습니다. 예를 들어, 일부 매개변수를 위치 전용으로 지정하고 일부를 키워드 전용으로 지정할 수 있습니다. 또 다른 일반적인 사용 사례는 기본 값이 있는 매개변수를 기본 값이 없는 매개변수보다 먼저 놓아 매개변수가 더 구성되고 사용하기 쉽도록 만드는 것입니다. 이러한 요청은 파이썬의 * 및 / 기호를 사용하여 수행할 수 있습니다.\n\n## 기본 동작\n\n이미 알고 있듯이, 파이썬에서는 위치 매개변수 또는 키워드 매개변수를 사용하여 함수에 데이터를 전달할 수 있습니다. 여기에 간단한 함수 예제가 있습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\ndef echo(x, y, z):\n    print(f\"{x=}, {y=}, {z=}\")\n```\n\n이 함수를 호출할 때 위치 매개변수나 키워드 매개변수를 사용할 수 있습니다. 단, 키워드 매개변수는 위치 매개변수 뒤에 있어야 합니다:\n\n```python\necho(1, 2, 3)\necho(1, 2, z=3)\necho(1, y=2, z=3)\necho(x=1, y=2, z=3)\n# x=1, y=2, z=3\n```\n\n모두 작동하고 동일한 결과를 출력합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## /를 사용하여 위치 전용 매개변수 지정하기\n\n함수 정의에서 / 기호 앞에 배치된 매개변수는 위치 전용으로 전달돼야 합니다. echo() 함수를 업데이트하여 /를 사용해봅시다:\n\n```js\ndef echo(x, /, y, z):\n    print(f\"{x=}, {y=}, {z=}\")\n```\n\n이 업데이트로 x는 위치 매개변수로만 전달될 수 있으며, y와 z는 여전히 위치 및 키워드 매개변수로 모두 전달될 수 있습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n```js\necho(1, 2, 3)\necho(1, 2, z=3)\necho(1, y=2, z=3)\n# x=1, y=2, z=3\n```\n\n그리고 x가 키워드 매개변수로 전달되면 TypeError가 발생합니다:\n\n```js\necho(x=1, y=2, z=3)\n# TypeError: echo() got some positional-only arguments passed as keyword arguments: 'x'\n```\n\n## *를 사용하여 키워드 전용 매개변수 지정하기\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n함수 정의에서 * 기호 뒤에 올 파라미터는 키워드 인수로 전달되어야 합니다. echo() 함수에서 / 대신 *를 사용해보겠습니다:\n\n```js\ndef echo(x, *, y, z):\n    print(f\"{x=}, {y=}, {z=}\")\n```\n\n이제 x는 위치 인수 또는 키워드 인수로 전달할 수 있지만, y와 z는 키워드 인수로 반드시 전달되어야 합니다 (x가 위치 매개변수로 전달되더라도):\n\n```js\necho(1, y=2, z=3)\necho(x=1, y=2, z=3)\n# x=1, y=2, z=3\n\necho(1, 2, z=3)\n# TypeError: echo() takes 1 positional argument but 2 positional arguments (and 1 keyword-only argument) were given\n\necho(1, 2, 3)\n# TypeError: echo() takes 1 positional argument but 3 were given\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n* 기호의 매우 유용한 기능 중 하나는 매개변수를 보다 구성되게 보이도록 기본값이 설정된 매개변수를 기본값이 없는 매개변수보다 먼저 배치할 수 있다는 것입니다. 예를 들어, * 기호를 사용하여 y에 기본값을 지정하고 여전히 y 뒤에 z를 놓을 수 있습니다:\n\ndef echo(x, *, y=2, z):\n    print(f\"{x=}, {y=}, {z=}\")\n\n이것은 Python에서 유효한 구문이며 복잡한 함수 매개변수를 갖는 서드 파티 Python 라이브러리에서 흔히 사용됩니다.\n\n이제 y와 z 둘 다 키워드 매개변수로 전달되어야 하며 y에는 기본값이 설정되어 있습니다:\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n```js\necho(1, z=3)\necho(1, y=2, z=3)\n# x=1, y=2, z=3\n```\n\n## 함수 정의에서 *와 /를 결합하기\n\n*와 /를 결합하여 위치 매개변수와 키워드 전용 매개변수를 가진 함수를 정의할 수 있습니다:\n\n```js\ndef echo(x, /, *, y=2, z):\n    print(f\"{x=}, {y=}, {z=}\")\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 경우에는 x는 위치 전용이고 y와 z는 키워드 전용 매개변수입니다:\n\n```js\necho(1, z=3)\necho(1, y=2, z=3)\n# x=1, y=2, z=3\n\necho(x=1, z=3)\n# TypeError: echo() got some positional-only arguments passed as keyword arguments: 'x'\n```\n\n이 게시물에서는 함수 정의에서 *와 / 기호를 사용한 것을 소개했는데, 이들은 다음과 같은 흥미로운 유틸리티를 가지고 있습니다:\n\n- 일부 매개변수를 위치 전용으로 지정하고 일부를 키워드 전용으로 지정합니다.\n- 기본값을 가진 매개변수는 기본값이 없는 매개변수 앞에 두어 매개변수를 더욱 구성하기 쉽고 사용하기 편리하게 합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 관련 포스트:\n\n- 특별한 Python 문자열 포맷팅으로 로깅 및 단위 변환하기\n- Python 코드를 더 전문적으로 만들기 위해 black, mypy, pylint 사용하기","ogImage":{"url":"/TIL/assets/img/2024-07-13-UseandtoMakeYourPythonFunctionParametersLookNeater_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-UseandtoMakeYourPythonFunctionParametersLookNeater_0.png","tag":["Tech"],"readingTime":6},{"title":"파이썬으로 모멘텀 및 되돌림 트레이딩 전략 구축 방법","description":"","date":"2024-07-13 19:01","slug":"2024-07-13-BuildingAMomentumandReversionTradingStrategyWithPython","content":"\n\n양적 거래에서는 금융 시장에서 우위를 차지하기 위해 다양한 전략이 사용됩니다. 모멘텀 및 추세 기반 전략은 인기가 많지만, 종종 중요한 알파를 창출하는 데 어려움을 겪습니다. 이들은 종종 유튜브에서 금융 강좌로 판매될 때만 알파를 창출하게 됩니다.\n\n모멘텀 및 추세 접근법은 최근 가격 상승을 보이는 자산이 가까운 미래에 상승세를 이어갈 것이라는 아이디어를 활용하거나, 손실을 보이는 자산이 계속해서 하락할 것이라는 아이디어를 기반으로 합니다. 추세와 모멘텀을 구분하는 것이 중요합니다.\n\n- 추세 추종은 시장 베타를 분석하여 특정 방향의 절대 수익을 목표로 합니다.\n- 반면에, 모멘텀 전략은 상대 수익에 초점을 맞추며, 분류나 섹터 내에서 교차부문 성능을 평가하여 시장 중립적 입장을 유지합니다.\n\n회귀 전략은 가격이 특정 기간 동안 평균 또는 다중 평균 값으로 되돌아갈 것이라는 믿음에 기반합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 기사에서는 이러한 전략을 검토하고 해당 분석을 위한 Python 코드 구현을 제공할 것입니다. 우리는 페어 트레이딩을 포함한 더 세련된 전략과 분석을 진행할 것입니다.\n\n우리의 분석은 최근의 시장 상황, 특히 팬데믹 이후의 주식 가격을 기준으로 살펴볼 것입니다. 모든 논의된 전략은 롱 온리이며 레버리지가 걸리지 않은 전략입니다.\n\n시작하기 전에, 투자 커뮤니티에 가입하실 것을 초대합니다. 가입하시면 중요한 기사를 놓치지 않고 투자자로서 스킬을 향상시킬 수 있습니다.\n\nPython 환경을 설정하는 것은 효율적으로 Python 코드를 작성, 실행 및 관리하기 위해 필요한 도구와 라이브러리를 갖추는 것을 포함합니다. Python 환경을 설정하는 자세한 안내서는 여기 있습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 1. 파이썬 설치하기:\n\n만약 여러분의 컴퓨터에 아직 파이썬이 설치되어 있지 않다면, 공식 파이썬 웹사이트([https://www.python.org/](https://www.python.org/))에서 다운로드하고 설치해주세요. 여러분의 운영 체제(Windows, macOS, 또는 Linux)에 맞는 올바른 버전을 선택해야 합니다. 가장 최신의 안정 버전을 설치하는 것이 좋습니다.\n\n# 2. 텍스트 편집기 또는 IDE 선택하기:\n\n파이썬으로 코딩할 때 텍스트 편집기나 통합 개발 환경(IDE)을 선택해주세요. 널리 사용되는 몇 가지 옵션으로는:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Visual Studio Code: 내장된 Python 지원과 다양한 확장 기능을 갖춘 가벼운 사용자 정의 가능한 편집기입니다.\n- PyCharm: 코드 완성, 디버깅 및 버전 관리 시스템과 통합된 Python 개발을 위해 최적화된 견고한 IDE입니다.\n- Jupyter Notebook: 데이터 분석 및 시각화 작업에 이상적인 웹 브라우저에서 Python 코드를 작성하고 실행할 수 있는 인터랙티브 노트북 인터페이스입니다.\n\n## 3. 가상 환경 설정하기 (선택 사항이지만 권장됨):\n\n가상 환경은 종속성을 관리하고 프로젝트 환경을 격리하는 데 유용합니다. 가상 환경을 만들려면 터미널이나 명령 프롬프트를 열고 프로젝트 디렉토리로 이동한 다음 다음 명령을 실행하십시오:\n\n```js\npython -m venv myenv\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n해당 명령어는 프로젝트 디렉토리에 `env`라는 가상 환경을 만듭니다. 가상 환경을 활성화하려면 다음 명령어를 사용하십시오 (사용하는 운영 체제에 따라 명령어가 다를 수 있습니다):\n\n## Windows:\n\n```js\n.\\env\\Scripts\\activate\n```\n\n## macOS/Linux:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nsource env/bin/activate\n```\n\n활성화된 후에 `pip`를 사용하여 프로젝트별 종속성을 설치할 수 있습니다. 이 가상 환경 안에 이들이 포함되어 다른 프로젝트와의 충돌을 방지합니다.\n\n# 4. 필요한 패키지 설치:\n\n```js\npython -m venv myenv\npip install numpy pandas matplotlib\npip install -r requirements.txt\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 트렌드와 모멘텀 전략\n\n예를 들어 설명하자면, 만약 자산의 가격이 지난 일주일 동안 상승 추세를 보였다면, 그 자산은 같은 방향으로 계속 움직일 가능성이 높습니다. 이 전략은 미래 가격 변동이 과거 움직임의 패턴을 따르리라는 아이디어에 기반을 두고 있습니다. 월스트리트벳 커뮤니티가 자주 외친 것처럼, 주식은 주로 상승하는 경향이 있습니다.\n\n비록 이 전략이 간단하긴 하지만, 다음과 같은 단점이 있습니다:\n\n- 시장 소음과 중요한 이벤트를 무시하여 중요한 변동을 완화할 수 있습니다.\n- 빈번한 거래는 거래 수수료 누적으로 이어질 수 있습니다.\n- 폭넓게 사용되기 때문에 이 전략을 활용하는 데 경쟁 우위가 제한적이거나 전혀 없을 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 이동평균 교차 전략\n\n다음 코드는 이 전략을 구현합니다:\n\n```js\ndef double_simple_moving_average_signals(ticker_ts_df, short_window=5, long_window=30):\n    \"\"\"\n    이중 단순 이동평균 (SMA) 전략을 기반으로 거래 신호를 생성합니다.\n    매개변수:\n    - ticker_ts_df (pandas.DataFrame): 주식의 과거 데이터가 포함 된 DataFrame.\n    - short_window (int): 단기 SMA의 창 크기.\n    - long_window (int): 장기 SMA의 창 크기.\n    반환값:\n    - signals (pandas.DataFrame): 거래 신호를 포함하는 DataFrame.\n    \"\"\"\n    signals = pd.DataFrame(index=ticker_ts_df.index)\n    signals['signal'] = 0.0\n    signals['short_mavg'] = ticker_ts_df['Close'].rolling(window=short_window,\n                                                          min_periods=1,\n                                                          center=False).mean()\n    signals['long_mavg'] = ticker_ts_df['Close'].rolling(window=long_window,\n                                                         min_periods=1,\n                                                         center=False).mean()\n    # SMAs가 교차 되었을 때 신호 생성\n    signals['signal'] = np.where(\n        signals['short_mavg'] > signals['long_mavg'], 1, 0)\n    signals['orders'] = signals['signal'].diff()\n    signals.loc[signals['orders'] == 0, 'orders'] = None\n    return signals\n```\n\n필요한 함수를 생성하기 위한 단계를 살펴보겠습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 단기 및 장기 이동평균 값 계산: 단기(빠른) 및 장기(느린) 단순 이동평균(SMA)을 계산하는 함수를 생성하세요.\n- 거래 신호 생성: 단기와 장기 이동평균 값을 비교하여 매수 및 매도 신호를 생성하는 함수를 개발하세요.\n- 시간에 따른 자본 계산: 생성된 신호를 기반으로 자본을 계산하는 유틸리티 함수를 구현하세요.\n- 결과 시각화: 주식의 시계열 데이터와 진입 및 퇴출 신호를 함께 그리는 함수를 작성하세요.\n\n```js\ndef load_ticker_time_series(ticker, start_date, end_date):\n    \"\"\"\n    Yahoo Finance API에서 시간 시리즈 금융 데이터를 검색하고 캐시합니다.\n    매개변수:\n    - ticker (str): 주식 티커 심볼 (예: 애플의 경우 'AAPL').\n    - start_date (str): 데이터 검색을 위한 'YYYY-MM-DD' 형식의 시작 날짜.\n    - end_date (str): 데이터 검색을 위한 'YYYY-MM-DD' 형식의 종료 날짜.\n    반환값:\n    - df (pandas.DataFrame): 금융 시계열 데이터를 포함하는 DataFrame.\"\"\"\n    dir_path = './data'\n    cached_file_path = f'{dir_path}/{ticker}_{start_date}_{end_date}.pkl'\n    try:\n        if os.path.exists(cached_file_path):\n            df = pd.read_pickle(cached_file_path)\n        else:\n            df = yf.download(ticker, start=start_date, end=end_date)\n            if not os.path.exists(dir_path):\n                os.makedirs(dir_path)\n            df.to_pickle(cached_file_path)\n    except FileNotFoundError:\n        print(\n            f'주식: {ticker}에 대한 파일을 다운로드 및 캐시하는 중 오류가 발생했습니다.')\n    return df\n\ndef calculate_profit(signals, prices):\n    \"\"\"\n    거래 신호와 주식 가격을 기반으로 누적 수익을 계산합니다.\n    매개변수:\n    - signals (pandas.DataFrame): 거래 신호를 포함하는 DataFrame (매수: 1, 매도: -1).\n    - prices (pandas.Series): 신호 날짜에 해당하는 주식 가격을 포함하는 Series.\n    반환값:\n    - cum_profit (pandas.Series): 시간에 따른 누적 수익을 포함하는 Series.\n    \"\"\"\n    profit = pd.DataFrame(index=prices.index)\n    profit['profit'] = 0.0\n    buys = signals[signals['orders'] == 1].index\n    sells = signals[signals['orders'] == -1].index\n    while sells[0] < buys[0]:\n        # 롱 포지션 전용 전략입니다. 판매로 시작할 수 없습니다.\n        sells = sells[1:]\n    if len(buys) == 0 or len(sells) == 0:\n        # 아무 조치도 취하지 않았습니다.\n        return profit\n    if len(sells) < len(buys):\n        # 마지막에 판매하는 것으로 가정합니다.\n        sells = sells.append(pd.Index(prices.tail(1).index))\n    buy_prices = prices.loc[buys]\n    sell_prices = prices.loc[sells]\n    profit.loc[sells, 'profit'] = sell_prices.values - buy_prices.values\n    profit['profit'] = profit['profit'].fillna(0)\n    # 누적 수익 생성\n    profit['cum_profit'] = profit['profit'].cumsum()\n    return profit['cum_profit']\n\ndef plot_strategy(prices_df, signal_df, profit):\n    \"\"\"\n    매수 및 매도 신호 및 누적 수익을 포함하는 거래 전략을 시각화합니다.\n    매개변수:\n    - prices (pandas.Series): 주식 가격을 포함하는 Series.\n    - signals (pandas.DataFrame): 매수(1) 및 매도(-1) 신호를 포함하는 DataFrame.\n    - profit (pandas.Series): 시간에 따른 누적 수익을 포함하는 Series.\n    반환값:\n    - ax1 (matplotlib.axes.Axes): 주식 가격과 신호를 표시하는 상단 서브플롯.\n    - ax2 (matplotlib.axes.Axes): 누적 수익을 표시하는 하단 서브플롯.\n    \"\"\"\n    fig, (ax1, ax2) = plt.subplots(2, 1, gridspec_kw={'height_ratios': (3, 1)},\n                                   figsize=(18, 12))\n    ax1.set_xlabel('날짜')\n    ax1.set_ylabel('달러 단위의 가격')\n    ax1.plot(prices_df.index, prices_df, color='g', lw=0.25)\n    # 매수 및 매도 신호를 플롯합니다.\n    ax1.plot(signal_df.loc[signal_df.orders == 1.0].index,\n             prices_df[signal_df.orders == 1.0],\n             '^', markersize=12, color='blue', label='매수')\n    ax1.plot(signal_df.loc[signal_df.orders == -1.0].index,\n             prices_df[signal_df.orders == -1.0],\n             'v', markersize=12, color='red', label='매도')\n    ax2.plot(profit.index, profit, color='b')\n    ax2.set_ylabel('누적 수익 (%)')\n    ax2.set_xlabel('날짜')\n    return ax1, ax2\n```\n\n모두를 결합합시다\n\n```js\naapl_ts_df = load_ticker_ts_df('AAPL',\n                               start_date='2021-01-01',\n                               end_date='2023-01-01')\nsignal_df = double_simple_moving_average_signals(aapl_ts_df, 5, 30)\nprofit_series = calculate_profit(signal_df, aapl_ts_df[\"Adj Close\"])\nax1, ax2 = plot_strategy(aapl_ts_df[\"Adj Close\"], signal_df, profit_series)\n\n# 단기 및 장기 이동평균 추가\nax1.plot(signal_df.index, signal_df['short_mavg'],\n         linestyle='--', label='빠른 SMA')\nax1.plot(signal_df.index, signal_df['long_mavg'],\n         linestyle='--', label='느린 SMA')\nax1.legend(loc='upper left', fontsize=10)\nplt.show()\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![Strategy](/TIL/assets/img/2024-07-13-BuildingAMomentumandReversionTradingStrategyWithPython_0.png)\n\n지난 2년 동안 이 전략은 30%의 수익을 창출했습니다. 최근 S&P 500의 10%의 수익과 비교했을 때, 강력한 전략으로 보입니다.\n\n## 단순 관성 전략\n\n이 전략은 가격 상승 또는 하락의 빈도에 기초합니다. 연속된 일정 기간 동안 가격이 지속적으로 상승하면 매수 기회를, 하락하면 매도 기회로 간주합니다.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이전에 논의 된 간단한 이동 평균 (SMA) 전략에서 일부 유틸리티 함수를 재사용할 것입니다.\n\n다음은이 전략의 기본 버전을 구현하는 코드입니다:\n\n```js\ndef naive_momentum_signals(ticker_ts_df, nb_conseq_days=2):\n    \"\"\"\n    연이은 양수 또는 음수 가격 변동에 기반한 소박한 모멘텀 트레이딩 신호를 생성합니다.\n    매개변수:\n    - ticker_ts_df (pandas.DataFrame): 과거 주식 데이터가 포함 된 DataFrame입니다.\n    - nb_conseq_days (int): 신호를 트리거 할 연속적 양수 또는 음수 일수입니다.\n    반환 값:\n    - signals (pandas.DataFrame): 구매 (1) 및 판매 (-1) 신호가 포함 된 'orders' 열이있는 DataFrame입니다.\n    \"\"\"\n    signals = pd.DataFrame(index=ticker_ts_df.index)\n    signals['orders'] = 0\n\n    price = ticker_ts_df['Adj Close']\n    price_diff = price.diff()\n    signal = 0\n    cons_day = 0\n    for i in range(1, len(ticker_ts_df)):\n        if price_diff[i] > 0:\n            cons_day = cons_day + 1 if price_diff[i] > 0 else 0\n            if cons_day == nb_conseq_days and signal != 1:\n                signals['orders'].iloc[i] = 1\n                signal = 1\n        elif price_diff[i] < 0:\n            cons_day = cons_day - 1 if price_diff[i] < 0 else 0\n            if cons_day == -nb_conseq_days and signal != -1:\n                signals['orders'].iloc[i] = -1\n                signal = -1\n    return signals\n\nsignal_df = naive_momentum_signals(aapl_ts_df)\nprofit_series = calculate_profit(signal_df, aapl_ts_df[\"Adj Close\"])\nax1, _ = plot_strategy(aapl_ts_df[\"Adj Close\"], signal_df, profit_series)\nax1.legend(loc='upper left', fontsize=10)\nplt.show()\n```\n\n<img src=\"/TIL/assets/img/2024-07-13-BuildingAMomentumandReversionTradingStrategyWithPython_1.png\" />\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안타깝지만, 이 전략은 수익을 창출하지 않았고 수익을 얻지 못했습니다.\n\n그러나 모델을 단순히 반전시킴으로써 더 나은 성과를 거둘 수도 있었을 것입니다 (이 기법은 WallStreetBets의 주식 분석에 많이 제안된 방법 중 하나입니다). 이를 위해 거래 신호를 -1로 곱하면 됩니다. 이 반전 접근법은 전략의 원래 신호가 효과적이지 않을 때 일반적으로 효과적입니다.\n\n솔직히 말해서, 이 전략은 일반적으로 개별 상품이 아닌 더 넓은 시장에 적용되며 더 짧은 시간대에 구현됩니다.\n\n# 회귀 전략\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예를 들어, 일론 머스크가 테슬라에 블록체인을 통합할 것이라는 트윗을 올리면, 테슬라 주식에 과도한 매수 열풍이 불고 있을 것입니다. 그러나 다음 날에는 투자자들이 아무런 근본적인 변화가 없다는 것을 깨닫고 시장이 관심을 잃으면, 가격은 더 합리적인 수준으로 회귀할 것입니다.\n\n따라서 어떤 상품이나 도구가 어느 방향으로든 표준 지수에서 너무 빠르게 벗어날 경우, 결국 오랜 기간에 걸쳐 표준 지수로 돌아가게 될 것입니다.\n\n트렌드와 모멘텀 전략과 유사하게, 회귀 전략은 시장 역학을 간소화하고 시장 참가자들이 일반적으로 사용하는 전략입니다.\n\n# 평균 회귀\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n평균 회귀 전략에서는 주식 가격이 시간이 지남에 따라 평균값 또는 평균값에 가까워질 것이라는 가정 하에 운영합니다.\n\n아래는 이 전략을 구현하는 신호 코드입니다:\n\n```js\ndef mean_reversion_signals(ticker_ts_df, entry_threshold=1.0, exit_threshold=0.5):\n    \"\"\"\n    이동 평균과 임계값을 기반으로 한 평균 회귀 트레이딩 신호 생성.\n    매개변수:\n    - ticker_ts_df (pandas.DataFrame): 주식의 역사적 데이터가 포함된 DataFrame.\n    - entry_threshold (float): 표준 편차의 배수로 표시된 진입 임계값.\n    - exit_threshold (float): 표준 편차의 배수로 표시된 종료 임계값.\n    반환:\n    - signals (pandas.DataFrame): 'orders' 열을 포함한 Buy(1) 및 Sell(-1) 신호가 포함된 DataFrame.\n    \"\"\"\n    signals = pd.DataFrame(index=ticker_ts_df.index)\n    signals['mean'] = ticker_ts_df['Adj Close'].rolling(\n        window=20).mean()  # 필요한대로 창 크기 조정\n    signals['std'] = ticker_ts_df['Adj Close'].rolling(\n        window=20).std()  # 필요한대로 창 크기 조정\n    signals['signal'] = np.where(ticker_ts_df['Adj Close'] > (\n        signals['mean'] + entry_threshold * signals['std']), 1, 0)\n    signals['signal'] = np.where(ticker_ts_df['Adj Close'] < (\n        signals['mean'] - exit_threshold * signals['std']), -1, 0)\n    signals['orders'] = signals['signal'].diff()\n    signals.loc[signals['orders'] == 0, 'orders'] = None\n\n    return signals\n```\n\n이 함수에서는 주식 가격 데이터의 표준 편차와 평균을 결정합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n가격이 평균에서 일정 표준 편차 수로 벗어날 때 신호가 생성됩니다.\n\n이전에 만든 함수를 사용하여 함께 테스트해보겠습니다:\n\n```js\nsignal_df = mean_reversion_signals(aapl_ts_df)\nprofit_series = calculate_profit(signal_df, aapl_ts_df[\"Adj Close\"])\nax1, _ = plot_strategy(aapl_ts_df[\"Adj Close\"], signal_df, profit_series)\n\nax1.plot(signal_df.index, signal_df['mean'], linestyle='--', label=\"평균\")\nax1.plot(signal_df.index, signal_df['mean'] +\n         signal_df['std'], linestyle='--', label=\"상한 표준편차\")\nax1.plot(signal_df.index, signal_df['mean'] -\n         signal_df['std'], linestyle='--', label=\"하한 표준편차\")\nax1.legend(loc='upper left', fontsize=10)\nplt.show()\n```\n\n<img src=\"/TIL/assets/img/2024-07-13-BuildingAMomentumandReversionTradingStrategyWithPython_2.png\" />\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n종이 상으로 10%의 수익률은 만족스럽게 보일 수 있지만, 실제로는 넓은 S&P 500 지수 펀드에 투자함으로써 유사한 결과를 달성할 수 있습니다.\n\n앞으로의 글에서는 Pair-Trading과 통계적 화폐 섹터에 속한 보다 정교한 형태의 복귀 전략을 탐구할 것입니다. 또한 전략 지표인 Sharpe 비율과 같은 전략 평가를 돕는 지표들을 살펴볼 것입니다. 이 분석을 통해 우리는 S&P 500 지수의 수익률에 맞게 하는 이 전략이 왜 약한 것으로 여겨지는지를 이해할 수 있을 것입니다.\n\n저의 추천 링크를 통해 Tradingview 구독비를 최대 100% 할인받을 수 있습니다. 해당 링크에 접속하면 페이지 상단 왼쪽에 있는 Tradingview 아이콘을 클릭하여 원하는 무료 요금제로 이동하세요.\n\n➡️여기에서 제 구독하기 ➡️ https://medium.com/@aamurtazin/subscribe\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n내가 곧 올릴 블로그에서 많은 내용을 공유할 거야.","ogImage":{"url":"/TIL/assets/img/2024-07-13-BuildingAMomentumandReversionTradingStrategyWithPython_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-BuildingAMomentumandReversionTradingStrategyWithPython_0.png","tag":["Tech"],"readingTime":17},{"title":"드롭할지 유지할지 수학적 최적화로 비디오 게임 인벤토리 문제를 해결하는 방법","description":"","date":"2024-07-13 18:58","slug":"2024-07-13-ToDrop-ItortoKeep-ItHowtoSolveaVideoGameInventoryProblemwithMathematicalOptimization","content":"\n\n![게임 인벤토리 문제 해결을 위한 수학적 최적화를 통한 비디오 게임 인벤토리 문제 해결 방법](/TIL/assets/img/2024-07-13-ToDrop-ItortoKeep-ItHowtoSolveaVideoGameInventoryProblemwithMathematicalOptimization_0.png)\n\n지금은 벌써 늦은 밤입니다. 비디오 게임을 즐기고 있고 몇 시간 동안 보석을 모으고 있습니다 🎮 (경험치 또는 아이템을 얻기 위해 동일한 적과 반복적으로 싸우는 것). 갑자기, 당신이 몇 일째 찾고 있던 방어구를 떨어뜨린 적이 나타납니다. 하지만 이미 인벤토리가 꽉 차 있어서 넣을 수가 없습니다. 재배열을 시도해봐도 맞추기 힘듭니다. 이제 무엇을 유지하고 무엇을 버릴지 결정해야 합니다. 다차원 배낭 문제의 흥미로운 세계로 환영합니다. 이 기사에서는 이 문제에 대한 수학적 프로그래밍 모델을 만드는 방법을 보여주고, 파이썬과 Gurobi를 사용하여 문제를 해결하며, 이를 해결하기 위해 적용할 수 있는 일부 휴리스틱 절차를 간단히 논의하겠습니다.\n\n문제와 관련된 수학에 대해 자세히 들어가기 전에, 비디오 게임에서 이 문제가 어떻게 나타나는지와 다른 맥락에서 이를 어떻게 만날 수 있는지에 대해 시간을 할애하고 싶습니다. 오늘날 인벤토리 관리 시스템은 거의 모든 비디오 게임에서 만나볼 수 있습니다. 특히 액션 RPG(역할 재생 게임) 장르인 Diablo 시리즈 및 MMO(대규모 다중 참여 온라인 게임)인 World of Warcraft 또는 Final Fantasy XIV와 같은 게임에서. 이 시스템의 기원은 중세 및 드래곤 게임(Dungeons & Dragons)과 같은 펜 앤지 RPG에 거름될 수 있으며, 이것은 운반 용량 및 부담을 고려한 객체의 무게를 고려했습니다. 그러나 처음으로 이 인벤토리 메커니즘을 통합한 비디오 게임은 1977년 Atari의 클래식 Colossal Cave Adventure였습니다. 그 이후로 많은 비디오 게임이 이 메커니즘의 어떤 버전을 채택했습니다. Pokémon, Dragon Quest, Final Fantasy와 같은 게임은 플레이어가 특정한 수(일반적으로 99)의 항목을 운반할 수 있는 수를 제한한 99 규칙을 적용한 1차원 인벤토리 시스템을 사용했습니다.\n\n게임이 발전함에 따라 이 1차원 시스템은 희소성을 포함하고 게임 경험을 향상시키기 위해 보다 정교해졌습니다. 예를 들어, 저는 현재 Paper Mario: The Thousand-Year Door를 다시 살펴보고 있는데, 아직 간단하고 1차원인데도 더 복잡한 인벤토리 시스템을 갖췄습니다. 이 게임은 플레이어의 인벤토리가 언제든지 15개의 항목을 초과할 수 없도록 하는 규정을 부여했습니다. 플레이어가 무엇을 유지하거나 버릴지를 결정해야 하는 것을 강요하여 모든 항목이 인벤토리에 들어가지 않는다는 사실에 직면하게 합니다. 내게 소모품을 수집하고 세계 곳곳에 흩어진 모든 항목을 모으고 발견하고 싶은 자연스런 수집가로서, 이제 무엇을 유지하거나 버릴지 결정할 때 어떤 기준을 사용해야 하는지 결정해야 합니다. 내 경우엔 항목의 판매 가격을 사용하는 편입니다. Paper Mario에서 해결하려는 문제는 정확히 제한된 항목 수를 초과하지 않고 인벤토리의 총 판매 가격을 최대화하는 것입니다. 이 정확한 문제는 0-1 배낭 문제 또는 1차원 이진 배낭 문제로 알려져 있으며, 다음 섹션에서 공식적으로 설명하겠습니다. 하지만 그 전에, 다른 게임이 보다 정교한 인벤토리 시스템을 개발한 방식을 살펴보겠습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n일부 다른 게임, 특히 RPG 판타지 장르의 게임들은 다른 방향을 선택하여 유명한 격자 인벤토리 메카닉 시스템을 구축했습니다. 최초로 이러한 시스템을 시사한 것 중 하나는 The Legend of Zelda (1986)였지만, Baldur's Gate와 Diablo (1997)와 같은 시리즈는 실제로 격자 인벤토리 시스템을 경험의 핵심 부분으로 확립했습니다. 이 시스템에서 플레이어는 고정 크기의 인벤토리 화면을 가지며 각 아이템은 일정한 공간을 필요로 합니다. 이러한 인벤토리 시스템의 예시가 그림 1에 나와 있습니다. 이 메카닉은 플레이어가 인벤토리를 구성하고 아이템의 위치를 최적화하여 독특한 게임 메카닉 경험을 만들 수 있게 합니다. 플레이어는 무엇을 남길지 버릴지 결정하는 것 뿐만 아니라 인벤토리에 아이템을 맞추기 위해 어떻게 배열할지도 결정해야 합니다.\n\n격자 인벤토리 시스템은 많은 유명한 RPG들에서 널리 사용되어 왔지만 놀랍게도, 이 메카닉을 가장 복잡한 형태로 만들어낸 게임은 RPG가 아니라 액션 호러 게임인 Resident Evil 4 (RE4)였습니다. 이 게임에서는 플레이어의 인벤토리가 주인공 레온 S. 케네디의 서류가방으로 제시됩니다. 이전의 격자 인벤토리 시스템과 마찬가지로, 플레이어는 인벤토리 내에서 아이템의 위치를 변경하여 공간을 최적화할 수 있습니다. 그러나 RE4은 플레이어가 아이템을 회전하여 최적의 위치를 달성할 수 있는 추가 자유도를 제공하는 혁신을 도입했습니다. 이 기능을 통해 RE4는 본 게임 안에 \"테트리스\"와 유사한 미니 게임을 효과적으로 도입했습니다. (그림 2 참조)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이것은 이러한 메커니즘이 구현된 유일한 게임이 아닙니다. 예를 들어, 유명한 어려운 첫인상의 일인칭 슈팅 게임 \"타르코프 탈출\"도 이 시스템의 변형을 갖추고 있습니다. 게다가, 이 문제의 유사한 버전을 아느 쾌적한 농업 게임에서 찾을 수 있습니다. 스타듀 밸리나 명문화된 문에 같은 문제를 겪습니다. 이 게임에서는 땅을 갖고 있고 그 수익에 따라 심을 작물을 결정해야 합니다. 이어티만 일정량의 시간과 에너지를 소비하는 제약 조건이 있습니다.\n\n더 중요한 것은, 이러한 이차원 배낭 문제에는 비디오 게임 이상의 여러 응용 분야가 있습니다. 물류, 시설 설계, 생산 프로세스 및 기타 다양한 분야 [2-4]에서 이러한 문제를 만납니다. 이 기사의 다음 섹션에서는 학술 논문에서 제시되는 문제를 공식적으로 연구할 것입니다. 수학적 프로그래밍 공식 및 파이썬에서 Gurobi를 사용하여 문제를 해결하는 방법을 살펴볼 것입니다. 마지막으로, 이러한 문제를 해결하는 데 사용할 수 있는 휴리스틱 절차를 간단히 논의할 것입니다.\n\n이제 Gurobi를 사용한 적이 없는 경우, 특히 이 기사에서 사용할 Google Colab(이 기사에서 사용할 IDE)으로부터 Gurobi를 설정하는 방법에 대해 설명한 이전 기사 중 하나를 읽어보시기를 권장합니다. 아래에 기사 링크를 찾을 수 있습니다:\n\n만약 선형 프로그래밍(LP) 또는 정수 프로그래밍(IP) 기술에 대한 자습서와 자세한 정보가 필요하다면, Bruno Scalia C. F. Leite가 작성한 훌륭한 기사를 꼭 확인하시기 바랍니다. 아래에 링크가 있습니다. 또 다른 좋은 소스로는 William의 수학 프로그래밍에 대한 책도 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n기사 목차:\n\n- 라이브러리 설치 및 Colab 환경 설정\n- 0-1 낱개 문제\n- 2차원 낱개 문제\n- 입력 데이터 및 전처리\n- Gurobipy로 문제 해결\n- 휴리스틱 접근 방식\n- 결론\n- 참고 문헌\n\n# 라이브러리 설치 및 Colab 환경 설정\n\nGoogle Colab에서 Gurobi를 사용하려면 다음 코드를 사용하여 먼저 설치해야 합니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n!pip install gurobipy\n```\n\n설치가 완료되면이 프로젝트에 필요한 라이브러리를 가져와서 사용할 수 있습니다.\n\n```js\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Rectangle\nfrom itertools import chain, combinations, permutations, product\nimport gurobipy as gp\nfrom gurobipy import GRB\nfrom copy import deepcopy\n```\n\n또한 gurobi 세션을 초기화해야 하므로 gurobi 라이센스의 모든 관련 정보를 params 딕셔너리로 만들어야 합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nWLSACCESSID = '<여기에 WLSACCESSID를 복사하세요>'\nWLSSECRET = '<여기에 WLSSECRET를 복사하세요>'\nLICENSEID = '<여기에 LICENSEID를 복사하세요>'\n```\n\n```js\nparams = {\n\"WLSACCESSID\": WLSACCESSID,\n\"WLSSECRET\": WLSSECRET,\n\"LICENSEID\": LICENSEID,\n}\nenv = gp.Env(params=params)  # 이 줄은 gurobi 환경을 초기화합니다.\n```\n\n# 나머지 가방 문제\n\n나머지 가방 문제는 조합 최적화의 고전적인 문제이며, 더 넓은 절단 및 패킹 (Cutting and Packing, C&P) 문제 클래스의 일부입니다. 나머지 가방 문제에서는 값과 크기가 있는 엔터티 세트가 주어집니다. 목표는 선택된 엔터티들의 값의 합이 최대화되는 동안 크기의 합이 주어진 한계를 초과하지 않도록 한 개 이상의 엔터티를 선택하는 것입니다(가방의 크기). 이것은 Paper Mario에서 설명된 문제와 유사합니다. 비디오 게임에서 바로 적용되는 것 외에도, 나머지 가방 문제는 화물 적재, 프로젝트 선택, 예산 통제, 자본예산편성, 도서관에서 저널 선택 등 산업 환경에서 다양한 응용 분야가 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n표 태그를 Markdown 형식으로 변경하십시오.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 이 섹션을 계속 읽기로 결정했다면, 우리는 내 문제 해결을 통한 Paper Mario: The Thousand-Year Door 인벤토리 문제를 예시로 삼아 진행할 것입니다. 목표는 마리오의 인벤토리 아이템의 판매 가격을 최대화하는 것인데, 전체 15개의 아이템이 필요하다는 것을 고려합니다. 🌶️ Spice things up을 위해, knapsack 형식의 다양성을 보여주기 위해 추가적인 제약 조건을 소개할 것입니다. 마리오의 인벤토리에는 최소한 25의 치유 능력, 적어도 25의 FP 능력, 최소 1개의 상태 복구 아이템, 그리고 적어도 2개의 공격 아이템을 제공하는 조합의 아이템이 포함되어야 합니다. 게다가 각 아이템은 구매 가격이 있으므로, 인벤토리의 총 비용이 200코인을 초과하지 않도록 할 것입니다. 게임에서 동일한 아이템을 여러 번 구매할 수 있기 때문에, 이진 변수 대신 정수 변수를 사용할 것입니다. 문제를 구성하고 해결하는 데 필요한 모든 정보가 아래 표 1에 제시되어 있습니다. 나는 Paper Mario 위키 페이지에서 정보를 추출했습니다. 이 링크에서 CSV 형식의 데이터를 다운로드할 수 있습니다.\n\n이 문제를 gurobipy에서 구성하고 해결하려면, 아래의 코드 스니펫을 따라 하면 됩니다:\n\n```js\npaper_mario = pd.read_csv('https://raw.githubusercontent.com/ceche1212/Youtube_optimization/main/paper_mario_items_knapsack.csv')\n\nI = range(len(paper_mario)) # 아이템 I의 세트\n\nmodel = gp.Model(\"paper_mario_knp\", env=env)\n\n# 변수 생성\nx = model.addVars(I, vtype=GRB.INTEGER, name='x')\n\n# 목적 함수\nmodel.setObjective(gp.quicksum(x[i]*paper_mario['판매 가격'][i] for i in I), GRB.MAXIMIZE);\n\n# 제약 조건\nmodel.addConstr(gp.quicksum(x[i] for i in I) == 15) # 15개 미만의 아이템\nmodel.addConstr(gp.quicksum(x[i]*paper_mario['구매 가격'][i] for i in I) <= 200) # 200 이하의 예산\nmodel.addConstr(gp.quicksum(x[i]*paper_mario['치유 능력'][i] for i in I) >= 25) # 최소 25의 치유 능력\nmodel.addConstr(gp.quicksum(x[i]*paper_mario['FP 능력'][i] for i in I) >= 25) # 최소 25의 FP 능력 아이템\nmodel.addConstr(gp.quicksum(x[i]*paper_mario['상태 플레이어'][i] for i in I) >= 1) # 최소 1개의 플레이어 상태 아이템\nmodel.addConstr(gp.quicksum(x[i]*paper_mario['공격'][i] for i in I) >= 3) # 최소 2개의 공격 아이템\n\n# params 설정\ntl = 120\nmipgap = 0.0\n\nmodel.setParam('TimeLimit', tl)\nmodel.setParam('MIPGap', mipgap)\n\n# 문제 해결\nmodel.optimize()\n```\n\n모든 것이 계획대로 진행된다면, 총 knapsack 가치는 69가 되어야 하며, 아래 Figure 4와 같은 출력을 볼 수 있어야 합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/TIL/assets/img/2024-07-13-ToDrop-ItortoKeep-ItHowtoSolveaVideoGameInventoryProblemwithMathematicalOptimization_3.png\" />\n\n문제를 해결한 후에는 아래 코드 스니펫을 사용하여 솔루션을 쉽게 추출할 수 있습니다:\n\n```js\nprint(\"아이템:\")\nfor item in x.keys():\n  if x[item].x >= 0.99:\n    print(\"- \",paper_mario['Item'][item],\"QTY:\", x[item].x)\nprint(\"인벤토리의 총 가치:\",model.ObjVal)\n```\n\n<img src=\"/TIL/assets/img/2024-07-13-ToDrop-ItortoKeep-ItHowtoSolveaVideoGameInventoryProblemwithMathematicalOptimization_4.png\" />\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 2차원 배낭 문제\n\n이제 당신은 배낭 문제의 간단한 버전에 익숙해졌으니, 좀 더 어려운 버전에 도전할 준비가 되었습니다. 물건의 기하학적 형태와 방향을 고려하면, 재고 목록의 각 항목마다 결정해야 할 것이 세 가지로 늘어났습니다: 해당 물건을 인벤토리(배낭)에 넣을지 여부, 포함된 경우 어디에 놓을지, 그리고 사용할 방향(수직 또는 수평) [8]. 간단함을 위해, 모든 항목이 직사각형 또는 정사각형이라고 가정할 것입니다. 그러나 불규칙한 모양을 고려하는 이 문제의 변형도 있다는 점에 유의해야 합니다 [5], 이는 더 복잡한 문제 해결을 필요로 합니다.\n\n이 문제는 비디오 게임 캐릭터의 인벤토리 정리를 넘어서 다양한 응용 분야가 있습니다. 물류 및 운송 분야뿐만 아니라 제품의 생산 및 제조에도 자주 사용됩니다. 형식적으로, 우리의 문제는 주어진 동일한 크기 또는 다른 크기의 직사각형 집합을 선택하고 배치하여, 고정된 크기의 직사각형 내에서 중첩되지 않게, 선택된 항목들의 총 가치를 최대화하는 것으로 정의됩니다. 이전 섹션의 예와 유사하게, 필요시 추가적인 제약 조건을 포함하여 문제를 쉽게 조정할 수 있습니다.\n\n이 문제에는 다음과 같은 변수가 필요합니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![이미지](/TIL/assets/img/2024-07-13-ToDrop-ItortoKeep-ItHowtoSolveaVideoGameInventoryProblemwithMathematicalOptimization_5.png)\n\n- 변수 z_i는 재고에 항목 i를 포함할지 여부에 대한 결정에 해당합니다.\n- 변수 x_i 및 y_i는 문제의 각 자산을 나타내는 “사각형”의 (x, y) 좌표에 해당합니다. 우리의 문제에는 모든 자산 또는 사각형으로 구성된 I라는 집합이 있습니다.\n- 변수 b_i_j_k는 모델에서 \"OR\" 조건을 설정하는 데 필요한 보조 이진 변수로, 그 사용법은 나중에 자세히 설명됩니다.\n- 마지막으로 각 사각형 i는 자산 i가 회전되는지 여부를 결정하는 데 사용될 변수 r_i를 가지게 됩니다.\n\n또한 문제는 다음과 같은 입력 매개변수를 필요로 합니다:\n\n![이미지](/TIL/assets/img/2024-07-13-ToDrop-ItortoKeep-ItHowtoSolveaVideoGameInventoryProblemwithMathematicalOptimization_6.png)\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위에서 설명한 변수와 입력 매개변수를 사용하여 문제를 수학적으로 모델링하면 다음과 같은 공식을 사용할 수 있습니다:\n\n\nThe formulation above might look daunting at first sight, but it is actually quite simple. The objective function above is exactly the same as in the “vanilla” 🍦 0–1 Knapsack problem. It is just the sum of the values v_i of the items that are placed inside the inventory (for these items z_i is going to be equal to 1).\n\nConstraint (1) ensures that the the x-coordinate plus the width of each item does not exceeds the Width W of the inventory (considering that the item could be rotated). Similarly, constraint (2) ensures that the the y-coordinate plus the height of each item does not exceeds the Height H of the inventory (considering that the item could be rotated).\n\n\n위의 공식은 처음 보면 복잡해 보일 수 있지만 실제로는 매우 간단합니다. 위의 목적 함수는 \"일반적인\" 🍦 0-1 배낭 문제와 정확히 동일합니다. 인벤토리 안에 배치된 항목의 값을 나타내는 v_i의 합일 뿐입니다. (이러한 항목에 대해 z_i가 1이 됩니다.)\n\n제약 조건(1)은 각 항목의 x 좌표 및 너비를 합한 값이 인벤토리의 너비 W를 초과하지 않도록 보장합니다(항목이 회전될 수 있다는 것을 고려합니다). 비슷하게, 제약 조건(2)는 각 항목의 y 좌표와 높이를 합한 값이 인벤토리의 높이 H를 초과하지 않도록 보장합니다(항목이 회전될 수 있다는 것을 고려합니다).\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nConstraints (3-7)은 서로 다른 항목의 위치 간에 겹침이 없도록 보장합니다. 이러한 제약 조건은 OR 조건으로 작동하며, 변수 b_i_j_1, b_i_j_2, b_i_j_3, 및 b_i_j_4를 각 항목에 사용하고, Big-M 방법을 사용합니다. 요약하면, 한 항목은 다른 항목의 왼쪽, 오른쪽, 위, 또는 아래에 위치할 수 있지만, 겹치지는 않습니다.\n\nConstraints (8-11)은 단순히 변수가 적절한 도메인에 속해 있는지 확인합니다.\n\n# 입력 데이터 및 전처리\n\n간단히하기 위해, 10개의 항목으로 구성된 다섯 그룹을 사용하겠습니다. 각 그룹 내의 모든 항목은 동일한 차원을 가질 것입니다. 재고는 폭(W)이 15 단위이고 높이(H)가 8 단위인 것으로 합니다. 예제 항목의 차원 및 모든 관련 정보는 아래의 테이블에 표시되어 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n데이터가 사용 가능하도록 하려면 각 값을 리스트에 저장한 다음 각 항목을 별도의 행으로 준비하는 확장된 데이터프레임을 만들 것입니다. 아래의 코드를 사용하여 이를 구현할 수 있습니다:\n\n```js\nwidths = [6, 1, 2, 3, 3]\nheights = [2, 1, 1, 2, 4]\ncolors = ['red', 'skyblue', 'green', 'yellow', 'orange']\nvalues = [15, 2, 2, 7, 20]\n\nW = 15\nH = 8\nquants = [10, 10, 10, 10, 10]\n\ntop = max(W, H)\n\ndf = pd.DataFrame()\ndf['quantity'] = quants\ndf['heights'] = heights\ndf['widths'] = widths\ndf['color'] = colors\ndf['values'] = values\n\nWIDTHS = []\nHEIGHTS = []\nVALUES = []\nCOLORS = []\nfor q, w, h, v, c in zip(quants, widths, heights, values, colors):\n    for x in range(q):\n        HEIGHTS.append(w)\n        WIDTHS.append(h)\n        VALUES.append(v)\n        COLORS.append(c)\n\ndata_df = pd.DataFrame()\ndata_df['HEIGHTS'] = HEIGHTS\ndata_df['WIDTHS'] = WIDTHS\ndata_df['VALUES'] = VALUES\ndata_df['COLORS'] = COLORS\n\nN = len(WIDTHS)\nM = max(sum(WIDTHS), sum(HEIGHTS))\n\nI = range(N)  # 각 자산 \"i\"의 인덱스를 위해\nK = range(4)  # OR 변수 \"b\"의 인덱스를 위해\n```\n\n# Gurobipy를 사용하여 문제 해결\n\n이제 필요한 모든 라이브러리와 입력 데이터가 준비되었으므로 Figure 8에 설명된 수학 모델을 만들어볼 차례입니다. GurobiPy를 사용하여 이 모델을 구현하려면 아래의 코드 스니펫을 따라하면 됩니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nmodel = gp.Model(\"두 차원 배낭 문제\", env=env)\n\n# 변수 생성\nx = model.addVars(I, lb=0, ub=top, vtype=GRB.CONTINUOUS, name=\"x\")\ny = model.addVars(I, lb=0, ub=top, vtype=GRB.CONTINUOUS, name=\"y\")\n\nZ = model.addVars(I, vtype=GRB.BINARY, name='Z')\n\nb_vars = [(i, j, k) for i in I for j in I if j != i for k in K]\n\nB = model.addVars(b_vars, vtype=GRB.BINARY, name=\"B\")\n\nR = model.addVars(I, vtype=GRB.BINARY, name='R') \n\n# 목적 함수\nmodel.setObjective(gp.quicksum(Z[i] * data_df['VALUES'][i] for i in I), GRB.MAXIMIZE);\n\n# 제약 조건\nfor i in I:\n    model.addConstr(x[i] + (data_df['WIDTHS'][i] * R[i] + data_df['HEIGHTS'][i] * (1 - R[i])) * Z[i] <= W)\n    model.addConstr(y[i] + (data_df['HEIGHTS'][i] * R[i] + data_df['WIDTHS'][i] * (1 - R[i])) * Z[i] <= H)\n\nfor i in I:\n    for j in I:\n        if i == j:\n            continue\n        else:\n            model.addConstr(x[i] + (data_df['WIDTHS'][i] * R[i] + data_df['HEIGHTS'][i] * (1 - R[i])) * Z[i] <= x[j] + M * (1 - B[i,j,0]))\n            model.addConstr(x[j] + (data_df['WIDTHS'][j] * R[j] + data_df['HEIGHTS'][j] * (1 - R[j])) * Z[j] <= x[i] + M * (1 - B[i,j,1]))\n\n            model.addConstr(y[i] + (data_df['HEIGHTS'][i] * R[i] + data_df['WIDTHS'][i] * (1 - R[i])) * Z[i] <= y[j] + M * (1 - B[i,j,2]))\n            model.addConstr(y[j] + (data_df['HEIGHTS'][j] * R[j] + data_df['WIDTHS'][j] * (1 - R[j])) * Z[j] <= y[i] + M * (1 - B[i,j,3]))\n\n            model.addConstr(B[i,j,0] + B[i,j,1] + B[i,j,2] + B[i,j,3] >= 1)\r\n```\n\n주의해야 할 점은 제약조건 (8-11)이 변수 생성 과정에서 이미 설정되었으므로, model.addConstr 메서드를 통해 명시적으로 추가할 필요가 없다는 것입니다. 이제 모델이 완성되었으므로 문제를 해결해 볼 수 있습니다. 이 문제는 복잡하기 때문에 600초(10분) 동안 실행해 보겠습니다. 또한 최적화 과정이 최적값의 5% 이내에 있으면 프로세스를 종료하고 현재까지 얻은 최상의 해를 얻을 수 있도록 설정합니다. 문제를 해결하려면 아래 코드를 따라하세요:\n\n```js\ntl = 600\nmip_gap = 0.05\n\nmodel.setParam('TimeLimit', tl)\nmodel.setParam('MIPGap', mip_gap)\nmodel.optimize()\r\n```\n\n600초 후에 아직 최적해를 확인하지 못했습니다(저희가 모르는 사이에 이미 최적이라고 생각됩니다), 그러나 재고 가치는 상당히 증가했습니다. 초기 값이 35에서 최종 값인 195로 증가했습니다. 이는 원래 값의 거의 6배이며, 꽤 좋은 결과입니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n문제가 해결되었으니, 솔루션을 추출하고 이를 플롯하는 것만 남았어요. 아래 코드를 따라하면 matplotlib의 Rectangle 객체를 사용하여 쉽게 이를 수행할 수 있습니다:\n\n```js\nfor item in Z.keys():\n  if Z[item].x >= 0.99:\n    print(COLORS[item],Z[item].x,R[item].x >0.5,x[item].x,y[item].x,(WIDTHS[item],HEIGHTS[item]))\n```\n\n아래는 Markdown 표 형식으로 나타낸 print 문의 솔루션 출력을 찾을 수 있습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n| Color   | Z_i | 회전     | x    | y    | 크기       |\n|---------|-----|----------|------|------|------------|\n| skyblue | 1.0 | False    | 9.0  | 7.0  | (1, 1)     |\n| skyblue | 1.0 | False    | 0.0  | 5.0  | (1, 1)     |\n| skyblue | 1.0 | False    | 14.0 | 7.0  | (1, 1)     |\n| skyblue | 1.0 | False    | 1.0  | 7.0  | (1, 1)     |\n| skyblue | 1.0 | False    | 3.0  | 7.0  | (1, 1)     |\n| skyblue | 1.0 | False    | 10.0 | 7.0  | (1, 1)     |\n| skyblue | 1.0 | False    | 0.0  | 4.0  | (1, 1)     |\n| skyblue | 1.0 | False    | 2.0  | 7.0  | (1, 1)     |\n| skyblue | 1.0 | False    | 8.0  | 7.0  | (1, 1)     |\n| skyblue | 1.0 | False    | 11.0 | 7.0  | (1, 1)     |\n| green   | 1.0 | False    | 12.0 | 7.0  | (1, 2)     |\n| green   | 1.0 | False    | 4.0  | 7.0  | (1, 2)     |\n| green   | 1.0 | False    | 6.0  | 7.0  | (1, 2)     |\n| green   | 1.0 | True     | 0.0  | 6.0  | (1, 2)     |\n| yellow  | 1.0 | True     | 9.0  | 4.0  | (2, 3)     |\n| orange  | 1.0 | False    | 3.0  | 0.0  | (4, 3)     |\n| orange  | 1.0 | False    | 12.0 | 0.0  | (4, 3)     |\n| orange  | 1.0 | True     | 1.0  | 4.0  | (4, 3)     |\n| orange  | 1.0 | False    | 9.0  | 0.0  | (4, 3)     |\n| orange  | 1.0 | True     | 5.0  | 4.0  | (4, 3)     |\n| orange  | 1.0 | False    | 6.0  | 0.0  | (4, 3)     |\n| orange  | 1.0 | False    | 0.0  | 0.0  | (4, 3)     |\n| orange  | 1.0 | True     | 11.0 | 4.0  | (4, 3)     |\r\n\n\r\n저희 인벤토리에는 빨간색 항목이 선택되지 않았는지 확인할 수 있습니다. 공간이 소비되었으나 포함하지 않을 가치가 충분하지 않아 보입니다. 아래 표 10을 확인하여 최종 인벤토리의 시각적 표현을 확인할 수도 있습니다.\r\n\r\n<img src=\"/TIL/assets/img/2024-07-13-ToDrop-ItortoKeep-ItHowtoSolveaVideoGameInventoryProblemwithMathematicalOptimization_9.png\" />\r\n\r\n# 휴리스틱 접근법\r\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n문제에서 언급했듯이 이 문제는 건설적 휴리스틱을 사용하여 문헌에서 다루어졌습니다. 왜 휴리스틱이 사용되는지 궁금할 수 있습니다. 답은 간단합니다. 휴리스틱은 빠르고 계산 비용이 적습니다. 휴리스틱은 최적성을 보장하지는 않지만 품질 측면에서 놀랍도록 좋은 해결책을 빠르고 비용 효율적으로 제공합니다.\n\n다행히도, 이 문제를 해결하기 위해 특별히 설계된 Python 라이브러리인 rectpack이라는 라이브러리가 있습니다. 이 라이브러리는 재고의 항목 배열만 다루며 문제의 가치 최대화 부분을 직접 해결하지는 않습니다. 그러나 라이브러리에서 제공하는 여러 알고리즘을 시도함으로써 어떤 것이 최상의 재고 가치를 제공하는지 확인할 수 있습니다. 이 라이브러리 사용에 대한 자세한 내용은 Samir Saci가 쓴 훌륭한 Medium 게시물을 추천합니다.\n\n# 결론\n\n마지막으로, 이 기사는 수학적 프로그래밍을 사용하여 2차원 낙석 문제를 해결하는 과정을 안내해드렸습니다. 우리는 기본 0-1 낙석 문제와 그것을 Gurobi에서 구현하는 방법으로부터 시작했습니다. 그런 다음, 우리는 문제의 2차원 버전을 위한 혼합 정수 선형 프로그래밍(MILP) 공식과 그 문제를 Gurobi를 사용하여 어떻게 해결할지 탐구했습니다. 마지막으로, 건설적 휴리스틱과 rectpack 라이브러리를 간단히 논의했습니다. 이 기사를 즐겨주셨고 실생활 맥락에서 비슷한 변형의 문제에 대해 더 알고 싶다면, 이전에 게시한 2차원 조합 문제에 관한 기사를 확인하시기를 권장합니다. 기사 링크는 아래에 제공되어 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n제 RE4 인벤토리를 최적화하거나 스타듀 밸리의 농장 플롯을 개선하려는 누구에게든 도움이 되는 리소스로 써드루 밸리의 코드 개발을 포함한 이 기사가 도움이 되었으면 좋겠어요 😂. 이 기사에 대한 완전한 노트북은 아래 GitHub 저장소 링크에 있습니다.\n\n정말로 이 기사가 유용하고 재미있었기를 바라며, 만약 그렇다면 귀하의 생각을 듣고 싶습니다! 의견을 남기거나 👏 클랩으로 감사를 표현해주시면 감사하겠습니다. 그리고 제 최신 기사를 업데이트하고 싶다면, Medium에서 저를 팔로우해보세요. 귀하의 지지와 피드백이 저에게 더 탐구하고 이 매력적인 분야를 공유하도록 동기를 부여합니다. 읽어주셔서 감사하며, 다음 기사에서 더 많은 통찰력을 기대해주세요!\n\n# 참고 자료\n\n- [1] Williams HP. Model Building in Mathematical Programming. 4판. Chichester: Wiley; 1999\n- [2] Caprara, A. 및 Monaci, M., 2004. On the two-dimensional knapsack problem. Operations Research Letters, 32(1), pp.5–14.\n- [3] Baker, B.S.; Coffman Jr, E.G.; Rivest, R.L. (1980) Orthogonal packings in two dimensions. SIAM Journal of Computing 9(4): 846–855.\n- [4] Del Valle, A.M.; Queiroz, T.A.; Miyazawa, F.K.; Xavier, E.C. (2012) Heuristics for two-dimensional knapsack and cutting stock problems with items of irregular shape. Expert Systems with Applications 39(16): 12589–12598.\n- [5] DellaFave, R. (2014) Designing an RPG Inventory System That Fits: https://gamedevelopment.tutsplus.com/designing-an-rpg-inventory-system-that-fits-preliminary-steps--gamedev-14725a\n- [6] Martello, S. & Toth, P. (1990) Knapsack Problems: Algorithms and computer implementations. John Wiley & Sons, West Sussex.\n- [7] Salkin, H.M. & de Kluyver, C.A. (1975) The Knapsack Problem: a survey. Naval Research Logistics Quarterly 22(1): 127–144.\n- [8] Bortfeldt, A. & Winter, T. (2009) A genetic algorithm for the Two-dimensional Knapsack Problem with rectangular pieces. International Transactions in Operational Research 16: 685–713.","ogImage":{"url":"/TIL/assets/img/2024-07-13-ToDrop-ItortoKeep-ItHowtoSolveaVideoGameInventoryProblemwithMathematicalOptimization_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-ToDrop-ItortoKeep-ItHowtoSolveaVideoGameInventoryProblemwithMathematicalOptimization_0.png","tag":["Tech"],"readingTime":23},{"title":"의사결정자들이 수학을 더 배워야 하는 이유","description":"","date":"2024-07-12 21:05","slug":"2024-07-12-DecisionMakersNeedMoreMath","content":"\n\n<img src=\"/TIL/assets/img/2024-07-12-DecisionMakersNeedMoreMath_0.png\" />\n\n최근에 직장에서 일에 대해 곤란해하는 친구와 대화를 나누었어요. 그 친구는 자신이 판매 인력부에서 주도하는 주요 소프트웨어 롤아웃에 책임이 있었지만, 그 일에 대해 믿지 않았어요. 사실 그의 동료들도 그렇게 생각하지 않았다고 해요. 그가 묘사한 상황은 정말 안좋고 동기 부여가 안 되는 상황 같았어요.\n\n나는 당연하게도 어떻게 이런 상황이 발생했는지 물어보았어요. 그 친구는 롤아웃을 추진할 결정이 경영진 사이에서 유포된 '킬러 차트'에서 비롯되었다고 설명했어요. 차트는 두 그룹의 판매 결과를 비교하여 특정 소프트웨어 제품을 현장에서 사용한 한 그룹이 더 효과적이라는 결론을 내렸다고 해요.\n\n내가 한 질문은 두가지였어요. 먼저, 그들이 두 그룹의 차이가 우연 때문이 아닌지 확인했느냐 물어보았고, 그 다음으로 소프트웨어 사용이 그 차이를 일으켰다는 것이 결정적으로 입증되었는지 확인했느냐 물었어요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n말끔히 당황했다. 그는 우연히 차이가 발생할 수 있다는 것을 전혀 몰랐다며 원인과 결과에 대한 질문은 심지어 논의되지 않았다고 말했다. 그는 경영진이 단지 차트를 삼켜버리고 숫자들과 그 의미에 대한 추가 논쟁 없이 결정을 내렸다고 설명했다.\n\n우리가 도출한 결론은 이 모든 것이 그룹 내에서 수학에 대해 아무도 모르기 때문에 발생했다는 것이었다! 분석 자료 한 조각이 그룹 전체를 휩쓴 바 있었고, 관련된 사람들은 모두 그것을 올바르게 비평할 경험이나 지식이 없었다.\n\n나는 이러한 상황이 급속히 확대되고 있고, 그로 인해 수백만 달러의 잘못된 결정이 이루어지고 있다는 것을 우려한다.\n\n## 왜 수학이 더 중요해지고 있는 것일까?\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n간단히 말하면, 데이터의 양이 많이 증가했습니다. IBM에 따르면, 우리는 이제 매일 2.5 퀸틸리언 바이트 이상의 데이터를 생성하고 있습니다. 이러한 추세가 계속될 것으로 보여주는 다양한 통계가 있습니다:\n\n- McKinsey의 연구에 따르면, 거의 50%의 영업 및 마케팅 기능이 자신들을 '분석 및 빅데이터에 의해 변형되었다'고 설명하고 있습니다.\n- Statista에 따르면, 빅데이터 시장은 다음 10년 동안 연간 10% 이상 성장할 것으로 보고 있습니다.\n- 최근 업무 설문 조사에 따르면, 기업의 84%가 고급 분석 및 빅데이터 프로젝트를 시작하여 의사 결정을 개선하고 있습니다.\n\n명확한 사실은 의사 결정자들이 10년이나 20년 전보다 훨씬 많은 데이터 주도 문서와 차트를 마주하게 될 것이라는 것입니다. 하지만 이러한 데이터 풍부한 환경에서 정확한 결정을 내릴 수 있는 능력을 가진 의사 결정자들이 더 잘 갖추어져 있는지 궁금합니다.\n\n![이미지](/TIL/assets/img/2024-07-12-DecisionMakersNeedMoreMath_1.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 수학 능력은 높아지고 있지만 기술은 부족합니다\n\n데이터 중심의 의사 결정과 분석 붐으로 인해 경영진의 수학 능력도 함께 높아져야 합니다. 분석을 의심하고 비평할 수 있는 능력이 없다면 의사 결정자들은 판촉 활동과 편향된 의도에 휘둘릴 수밖에 없습니다. 상관 관계, 회귀, 통계적 유의성 및 예측 정확도와 같은 개념들이 언급되고 있지만, 의사 결정자들이 그것들을 이해할 만큼 충분히 잘 갖추고 있는지에 대한 증거가 없습니다.\n\n- 영국의 케임브리지 평가 연구에 따르면, 고도의 데이터 중심인 것이 아닌 직무에서도 고용주들은 수리능력을 중요시하며, 그러나 현재의 업무 인원은 이를 충족시키기에 적절한 수준이 되지 못하고 있다고 강조합니다.\n- 미국 노동부는 다음 10년 동안 수학 관련 직종이 다른 직종보다 4배 빠른 속도로 성장할 것으로 예상되지만, OECD에 따르면 미국은 성인의 수리 능력 평균으로 볼 때 30개국 중 24위를 차지합니다.\n- 최근 하버드 대학의 연구에 따르면, 미래 직업 시장에서 수학은 가장 필수적인 기술 중 하나가 될 것으로 예상되며, 최근의 가장 큰 일자리 증가는 수학이 필요한 포지션으로 집중되고 있다는 것을 보여줍니다.\n\n# 의사 결정자들이 알아야 할 것은 무엇인가요?\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n세련된 매크로 요소와 트렌드 가운데, 데이터 중심 환경에서 의사 결정자가 알아야 할 몇 가지 기본적인 요소들이 있다고 생각이 듭니다:\n\n- 상관 관계의 의미와 다양한 유형의 데이터에 대한 상관 계수 측정 방법\n- 인과 관계의 의미, 상관 관계와의 차이, 그리고 인과 관계를 증명하는 방법\n- 가설 검증의 통계적 방법과 가설 검정에 기반한 통계적 조건\n\n데이터 중심 환경에서 일하고 계시는데 이러한 것들에 대해 충분히 이해하고 있다고 느끼지 않으시다면, 지금이라도 대책을 세우도록 권장드립니다. 더불어 동료 의사 결정자들도 비슷한 입장에 있다고 느낀다면, 상황은 더욱 시급해진다고 할 수 있습니다.\n\n매년마다 직장에서 수학적 지식이 더욱 중요해지는 건 의심할 여지가 없습니다. 우리가 좋아하든 안 하든, 노력을 기울여 학습을 해 나가야 할 필요가 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n수학이 당신의 업무에서 얼마나 중요한가요? 자유롭게 의견을 남겨주세요.","ogImage":{"url":"/TIL/assets/img/2024-07-12-DecisionMakersNeedMoreMath_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-DecisionMakersNeedMoreMath_0.png","tag":["Tech"],"readingTime":4}],"page":"26","totalPageCount":50,"totalPageGroupCount":3,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true}