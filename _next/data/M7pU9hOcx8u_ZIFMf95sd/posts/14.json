{"pageProps":{"posts":[{"title":"Nextjs 15로 안전하게 업그레이드하는 방법 정리","description":"","date":"2025-04-22 01:45","slug":"2025-04-22-Howtoupgradetoversion15","content":"\n\n# 버전 15로 업그레이드하는 방법\n\n## 14 버전에서 15 버전으로 업그레이드하기\n\nNext.js 15 버전으로 업데이트하려면, 업그레이드용 codemod(codemod는 코드 자동 변경 도구)를 사용하면 편리해요. 터미널에서 아래 명령어를 입력하면 자동으로 코드에 필요한 변경사항을 반영해줍니다.\n\n```bash\nnpx @next/codemod@canary upgrade latest\n```\n\n이 명령어는 Next.js 최신 버전(15)으로 맞춰서 코드와 설정을 업데이트해주기 때문에, 직접 수동으로 하나하나 고치는 번거로움을 많이 줄여준답니다.\n\n---\n\n### 추가 팁\n\n- 항상 업그레이드 전에 현재 프로젝트를 백업하거나 Git에 커밋해 두세요. 혹시 모를 문제 발생 시 빠르게 되돌아갈 수 있어요.\n- 업그레이드 후에는 실제 프로젝트가 잘 돌아가는지 꼭 테스트해보세요. 버전 변경에 따라 작동 방식이 조금씩 바뀔 수 있으니까요.\n- Next.js의 공식 릴리즈 노트를 참고하면 새 버전에서 바뀐 점과 주의할 사항들을 한눈에 파악할 수 있어서 유용해요.\n\n업그레이드가 생각보다 간단하지만, 미리 대비만 잘 하면 훨씬 수월하게 최신 기능도 누리고 안정성도 챙길 수 있답니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n수동으로 설치하는 걸 선호한다면, 꼭 최신 버전의 Next와 React를 설치하는지 확인하세요:\n\n```bash\nnpm i next@latest react@latest react-dom@latest eslint-config-next@latest\n```\n\n> 참고할 점:\n설치 중에 peer dependencies 경고가 뜬다면, react와 react-dom을 권장 버전으로 업데이트해야 할 수도 있어요. 아니면 `--force` 혹은 `--legacy-peer-deps` 옵션을 사용해 경고를 무시할 수도 있습니다. 이 문제는 Next.js 15와 React 19가 안정화되면 자연스럽게 해결될 예정이에요.\n\n## React 19\n\nReact 19 버전에서는 성능 향상과 더불어 새롭게 도입된 기능들이 많이 있습니다. 예를 들어, 더 나은 서버 사이드 렌더링(SSR) 지원과 경량화된 빌드, 그리고 React 에코시스템 전반에 걸친 호환성 강화 등이 포함되어 있죠.\n\n참고로, React와 Next.js는 항상 같이 업데이트하는 게 가장 좋아요. 왜냐하면 Next.js가 React의 기능을 기반으로 동작하기 때문에 버전 불일치 시 예상치 못한 버그가 발생할 수도 있거든요.\n\n앞으로 Next.js 15와 React 19가 공식 안정 버전이 나오면, 더 쉽게 최신 기능을 누릴 수 있으니 그때까지는 위 방법대로 최신 버전으로 업데이트 해두는 걸 추천합니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안녕하세요 여러분! 오늘은 React 19 버전에서 바뀐 점들을 간단하게 정리해보려고 해요. 특히 기존에 사용하던 훅들이 어떻게 바뀌었는지, 그리고 비동기 API 관련 중요한 변경사항들을 다뤄볼게요.\n\n---\n\n### 주요 변경점 요약\n\n| 내용 | 설명 |\n|---|---|\n| React 최소 버전 | 이제 React와 React-DOM 최소 지원 버전이 19가 되었습니다. 기존 버전 사용자분들은 이번 기회에 업그레이드 해주세요! |\n| useFormState → useActionState | `useFormState` 훅은 React 19에서도 사용할 수 있지만 곧 사라질 예정이에요. 대신 `useActionState`를 쓰는 걸 권장합니다. `useActionState`는 대기(pending) 상태를 직접 읽을 수도 있고, 더 많은 프로퍼티를 제공합니다. 좀 더 자세한 내용은 공식 문서를 참고하세요. |\n| useFormStatus 업데이트 | `useFormStatus` 훅도 업데이트되면서 `data`, `method`, `action` 같은 추가 키가 생겼어요. React 19 버전이 아니면 `pending` 키만 사용할 수 있다는 점 꼭 기억하세요. |\n| TypeScript 사용자 주의 | TypeScript를 쓰는 분들은 `@types/react`와 `@types/react-dom` 역시 최신 버전으로 함께 업그레이드 해주세요. 타입 안정성을 위해 꼭 필요합니다! |\n\n---\n\n### 비동기 요청 API 관련 주요 변경사항 (Breaking Change)\n\n예전에는 런타임 정보를 기반으로 동작하는 동기 방식의 Dynamic API들이 있었는데요, 이제 이걸 전부 비동기 방식으로 변경했어요. 이 변화로 인해 비동기 요청을 처리하는 로직을 조금 다르게 써야 할 수도 있답니다.\n\n---\n\n### 추가 팁!\n\n- React 19로 넘어가면서 form 관련 훅들이 많이 바뀌었는데, 특히 서버 액션과 관련된 `useActionState` 같은 훅을 사용하는 게 앞으로 리액트 생태계에서 더 권장됩니다.\n- 새로운 API들이 추가되면서 동작 방식이 세밀해졌으니, 직접 애플리케이션에 적용해 보면서 어떤 점이 달라졌는지 꼭 확인해보세요.\n- 공식 React 19 업그레이드 가이드도 꼭 한 번 읽어보시길 추천합니다. 그 안에 더 자세한 마이그레이션 팁과 변경점들이 잘 정리되어 있으니까요!\n\n---\n\n더 궁금한 점이나 실사용하면서 겪는 문제 있으면 댓글로 알려주세요. 다음에도 유용한 개발 소식으로 찾아올게요! 😊\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- cookies  \n- headers  \n- draftMode  \n- params in layout.js, page.js, route.js, default.js, opengraph-image, twitter-image, icon, and apple-icon.  \n- searchParams in page.js  \n\n마이그레이션을 조금이라도 쉽게 하기 위해서, 자동으로 변환해주는 codemod 도구가 준비되어 있어요. 그리고 새로운 API들은 잠시 동안 동기(synchronous) 방식으로도 접근이 가능해서 천천히 전환할 수 있답니다.\n\n### cookies\n\n#### 권장하는 비동기 사용법 (Async Usage)\n\nNext.js 같은 최신 프레임워크에서는 cookie를 다룰 때도 비동기 방식을 추천하고 있어요. 예를 들어, `cookies()` 함수를 호출할 때 바로 데이터를 받을 수 있도록 `await`를 사용하는 겁니다. 이렇게 하면 네트워크 요청이나 복잡한 작업에 더 유연하게 대응할 수 있죠.\n\n```js\nimport { cookies } from 'next/headers';\n\nexport async function GET() {\n  const cookieStore = cookies();\n  const token = cookieStore.get('token')?.value;\n\n  // 비동기 작업 가능!\n  // 예: 토큰 검증, 다른 API 호출 등\n  if (!token) {\n    return new Response('Unauthorized', { status: 401 });\n  }\n\n  return new Response('Hello, authorized user!');\n}\n```\n\n이렇게 async/await 패턴으로 작성하면, 요청 중간에 필요한 정보를 쉽게 읽고 처리할 수 있어요.  \n\n---\n\n참고로, 만약 기존처럼 동기적으로 쓰고 싶다면 임시로 `cookies().get(...)` 같은 API를 이용할 수 있지만, 장기적으로는 꼭 비동기로 전환하는 게 추후 유지보수나 퍼포먼스 측면에서 좋아요.  \n\n필요하다면, 내가 직접 작성해 본 codemod 스크립트도 공유해줄 수 있으니, 댓글로 알려주세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js 13.4부터 `cookies()` 함수가 비동기 함수로 바뀌었어요. 그래서 예전처럼 동기적으로 `const cookieStore = cookies()` 이렇게 쓰면 안 되고, `await`를 붙여서 `const cookieStore = await cookies()` 이렇게 사용해야 합니다.\n\n```js\nimport { cookies } from 'next/headers'\n\n// 이전 방식\nconst cookieStore = cookies()\nconst token = cookieStore.get('token')\n\n// 변경된 방식\nconst cookieStore = await cookies()\nconst token = cookieStore.get('token')\n```\n\n하지만 아직 완전히 비동기 방식에 적응하지 못한 상황에서는, 아래처럼 타입 캐스팅을 해서 임시로 동기적으로 사용하는 방법도 있어요. 다만 이 방법은 개발 환경에서 경고 메시지가 뜰 수 있으니 참고하세요.\n\n```js\nimport { cookies, type UnsafeUnwrappedCookies } from 'next/headers'\n\n// 임시 동기 처리 방법\nconst cookieStore = cookies() as unknown as UnsafeUnwrappedCookies\nconst token = cookieStore.get('token')\n```\n\n---\n\n### headers 도 비슷해요!\n\n`headers()`도 내부적으로 비동기 방식으로 변경될 수 있으니, 비슷하게 `await`를 붙여주는 게 좋습니다. \n\n---\n\n### 참고로!\n\n- `cookies()`를 쓸 때는 꼭 서버 컴포넌트(server component)나 API Route 등 서버 환경에서만 사용해야 해요. 클라이언트 컴포넌트에서는 동작하지 않으니 주의하세요.\n- Next.js가 계속 발전하면서 내부 API도 조금씩 바뀌니까, 항상 공식 문서를 확인하고 업데이트 내역을 살펴보는 습관을 들여주세요.\n\n이렇게 하면 쿠키를 읽을 때 생기는 비동기 문제를 깔끔하게 해결할 수 있답니다! :)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 추천하는 비동기 사용법 (Async Usage)\n\n```js\nimport { headers } from 'next/headers'\n\n// 예전 방식\nconst headersList = headers()\nconst userAgent = headersList.get('user-agent')\n\n// 요즘 추천 방식 (await 사용)\nconst headersList = await headers()\nconst userAgent = headersList.get('user-agent')\n```\n\nNext.js에서 `headers()`를 사용할 때 이제는 비동기 함수처럼 `await`를 붙여서 호출하는 게 권장됩니다. 이유는 `headers()`가 내부적으로 비동기 작업을 할 수 있기 때문이에요. 이렇게 하면 코드가 더 안정적으로 동작하죠.\n\n---\n\n### 잠깐! 동기 방식 사용법 (Temporary Synchronous Usage)\n\n```js\nimport { headers, type UnsafeUnwrappedHeaders } from 'next/headers'\n\n// 예전 방식\nconst headersList = headers()\nconst userAgent = headersList.get('user-agent')\n\n// 동기 방식 그대로 쓰고 싶다면 (개발 중 경고 떠요)\nconst headersList = headers() as unknown as UnsafeUnwrappedHeaders\nconst userAgent = headersList.get('user-agent')\n```\n\n만약 코드를 당장 고치기 어려운 상황이라면 이렇게 타입을 강제로 변환해서 동기 방식으로 쓸 수는 있어요. 다만 개발 모드에서는 경고가 뜨니 나중에 꼭 비동기 방식으로 바꾸시는 걸 권장합니다.\n\n---\n\n### 추가 팁!\n\n- `headers()`를 비동기 호출로 바꾸려면, 호출하는 함수도 `async` 함수여야 합니다. 예를 들어 서버 컴포넌트나 API 라우트 함수에서 많이 쓰게 돼요.\n- 클라이언트 컴포넌트에서는 `next/headers`를 바로 사용할 수 없고, 서버에서 전달해줘야 한다는 점 꼭 기억하세요.\n- `headers()` 대신 `request.headers`를 직접 다룰 수도 있지만, Next.js에서는 제공하는 `headers()`가 버전업에 맞춰 최적화되어 있답니다.\n\n오늘 내용 참고해서 Next.js 최신 버전에 맞는 헤더 처리 스타일로 코딩해보세요! 개발할 때 헤더 정보를 안전하게 다루는 건 보안과도 직결되는 중요한 부분입니다. 😊\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### draftMode\n\n#### 비동기 방식 사용 추천\n\n```js\nimport { draftMode } from 'next/headers'\n\n// 예전 방식 (동기 방식)\nconst { isEnabled } = draftMode()\n\n// 최신 권장 방식 (비동기 방식)\nconst { isEnabled } = await draftMode()\n```\n\nNext.js에서 `draftMode`를 사용할 때, 요즘은 `await`를 붙여서 비동기적으로 사용하는 걸 추천해요. 왜냐하면 최신 Next.js 환경에서는 내부적으로 비동기 처리를 더 잘 지원하기 때문이죠. 덕분에 코드가 안정적이고 예측 가능하게 동작하게 됩니다.\n\n#### 임시로 동기 방식 사용하기\n\n만약 당장 async/await를 적용하기 어렵거나, 함수가 동기 컨텍스트 안에 있어서 비동기 코드를 쓸 수 없는 상황이라면 임시로 동기적으로 사용할 수 있지만, 가능한 빨리 비동기 방식으로 전환하는 게 좋아요. 동기적으로 쓸 경우 예상치 못한 문제가 생길 수 있거든요.\n\n---\n\n추가 팁: `draftMode`는 Next.js의 미리보기 모드(preview mode)와 비슷한 기능으로, 콘텐츠를 변경하거나 임시 상태를 확인하는 데 유용해요. 미리보기 모드를 쓴 적이 있다면 이해하기 쉬울 거예요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이번에 Next.js를 사용하면서 바뀐 부분들을 직접 공부해 보고 정리해봤어요. 혹시 Next.js에서 draftMode나 params 관련해서 헷갈렸던 부분이 있다면, 이 글이 도움이 될 거예요.\n\n---\n\n## draftMode 사용법 변경\n\n예전에는 이렇게 했죠?\n\n```ts\nconst { isEnabled } = draftMode()\n```\n\n그런데 이제는 이렇게 바뀌었어요.\n\n```ts\nconst { isEnabled } = draftMode() as unknown as UnsafeUnwrappedDraftMode\n```\n\n왜 이런 변경이 있을까요? 사실 개발환경(dev)에선 경고를 띄우기 위한 의도된 타입 캐스팅이에요. 타입스크립트가 더 엄격해지면서 아래와 같은 경고를 피하려고 이중 캐스팅(as unknown as ...)을 해주는 꼼수가 필요해졌죠.\n\n> 간단히 말하면, 공식 API가 안정화되기 전이라 타입 안전성 경고를 잡기 위해서 이렇게 사용한다는 점 참고하세요!\n\n---\n\n## params & searchParams - 비동기 Layout에서 바뀐 점\n\n예전에는 generateMetadata나 Layout에서 params가 바로 객체 형태였어요.\n\n| 구분         | 예전 코드                                | 변경된 코드                                |\n|--------------|----------------------------------------|------------------------------------------|\n| params 타입  | `{ slug: string }`                      | `Promise<{ slug: string }>`              |\n| 호출 시점    | `const { slug } = params`               | `const { slug } = await params`          |\n| 함수         | `function generateMetadata()`           | `async function generateMetadata()`      |\n| Layout 함수  | `function Layout()`                      | `async function Layout()`                 |\n\n직접 비교해보면,\n\n### 예전 코드\n\n```ts\ntype Params = { slug: string }\n\nexport function generateMetadata({ params }: { params: Params }) {\n  const { slug } = params\n}\n\nexport default function Layout({\n  children,\n  params,\n}: {\n  children: React.ReactNode\n  params: Params\n}) {\n  const { slug } = params\n  return <>{children}</>\n}\n```\n\n### 변경된 코드\n\n```ts\ntype Params = Promise<{ slug: string }>\n\nexport async function generateMetadata({ params }: { params: Params }) {\n  const { slug } = await params\n}\n\nexport default async function Layout({\n  children,\n  params,\n}: {\n  children: React.ReactNode\n  params: Params\n}) {\n  const { slug } = await params\n  return <>{children}</>\n}\n```\n\n---\n\n### 왜 params가 Promise로 바뀌었을까?\n\nNext.js 13+의 동적 라우팅에서는 더 좋은 성능과 유연성을 위해, `params`가 비동기적으로 처리되어야 할 경우가 많아요. 예를 들어 API 호출이나 데이터베이스 조회로 라우팅 정보를 가져올 때, `params`는 즉시 사용할 수 있는 값이 아니라 비동기 Promise가 될 수 있어요.\n\n그래서 이를 감안해서 `await`로 `params`를 받아온다는 점! 이 부분을 잊지 마세요.\n\n---\n\n## 정리하자면\n\n| 변경 포인트         | 예전 방식                       | 변경된 방식                             |\n|---------------------|--------------------------------|---------------------------------------|\n| `draftMode` 타입    | `const { isEnabled } = draftMode()` | `const { isEnabled } = draftMode() as unknown as UnsafeUnwrappedDraftMode` |\n| `params` 타입       | `{ slug: string }`              | `Promise<{ slug: string }>`            |\n| 함수 선언          | 동기 함수                      | `async` 함수로 변경                    |\n| params 사용법       | 바로 사용 (`const { slug } = params`) | `await` 처리해서 사용 (`const { slug } = await params`) |\n\n---\n\n## 추가 팁 - 실무에서 주의할 점\n\n- `await params`로 받는 부분에서 실수로 `await`를 빼먹지 않도록 조심하세요. 그러면 타입 오류가 생기거나 런타임 에러가 발생할 수 있어요.\n- `draftMode()`는 아직 공식 문서에도 \"experimental\" 표시가 있을 수 있어요. 실제 프로덕션에서 쓸 땐 신중 체크하시고, 시간이 지나면 정식 API가 나오면서 타입 경고도 사라질 가능성이 높아요.\n- Next.js의 새로운 앱 디렉토리 구조 + 점점 강화되는 타입스크립트 환경에 대응하려면 이런 변경 사항을 꼭 미리 알아두는 게 좋아요.\n\n---\n\n궁금한 점 있으면 댓글 달아주세요! Next.js 최신 기능, 더 재밌고 편리하게 같이 공부해봐요~ 😄✨\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이번에 React 컴포넌트에서 동기와 비동기 데이터를 다루는 방식을 조금 더 최신 방법으로 바꾸는 예제를 소개할게요. 쉬운 예시와 함께 변화한 코드를 설명하니까, 천천히 읽으면서 적용해보세요!\n\n---\n\n### 1. Synchronous Layout (동기 레이아웃)\n\n기존엔 `params`가 그냥 객체였는데, 이걸 `Promise`를 감싸서 비동기 데이터처럼 쓸 수 있도록 바꿨어요.\n\n```tsx\n// Before (예전 방식)\ntype Params = { slug: string }\n\nexport default function Layout({\n  children,\n  params,\n}: {\n  children: React.ReactNode\n  params: Params\n}) {\n  const { slug } = params\n}\n```\n\n```tsx\n// After (최신 방식)\nimport { use } from 'react'\n\ntype Params = Promise<{ slug: string }>\n\nexport default function Layout(props: {\n  children: React.ReactNode\n  params: Params\n}) {\n  const params = use(props.params) // 여기서 비동기 데이터를 바로 처리해버림\n  const slug = params.slug\n}\n```\n\n> 여기서 핵심은 바로 React의 `use` 훅을 활용해서 비동기 Promise 상태를 동기처럼 쓴다는 점이에요. `use`는 React 18에서 실험적으로 도입된 기능으로, Next.js 13같은 최신 프레임워크에서 지원하죠. 이렇게 하면 컴포넌트 내부가 훨씬 깔끔해지고, 비동기 데이터 처리가 자연스러워져요.\n\n---\n\n### 2. Asynchronous Page (비동기 페이지)\n\n페이지 컴포넌트와 `generateMetadata`에서 비동기 params, searchParams를 다루는 예시입니다.\n\n```tsx\n// Before (예전 방식)\ntype Params = { slug: string }\ntype SearchParams = { [key: string]: string | string[] | undefined }\n\nexport function generateMetadata({\n  params,\n  searchParams,\n}: {\n  params: Params\n  searchParams: SearchParams\n}) {\n  const { slug } = params\n  const { query } = searchParams\n}\n\nexport default async function Page({\n  params,\n  searchParams,\n}: {\n  params: Params\n  searchParams: SearchParams\n}) {\n  const { slug } = params\n  const { query } = searchParams\n}\n```\n\n```tsx\n// After (최신 방식)\ntype Params = Promise<{ slug: string }>\ntype SearchParams = Promise<{ [key: string]: string | string[] | undefined }>\n\nexport async function generateMetadata(props: {\n  params: Params\n  searchParams: SearchParams\n}) {\n  const params = await props.params\n  const searchParams = await props.searchParams\n  const slug = params.slug\n  const query = searchParams.query\n}\n\nexport default async function Page(props: {\n  params: Params\n  searchParams: SearchParams\n}) {\n  const params = await props.params\n  const searchParams = await props.searchParams\n  const slug = params.slug\n  const query = searchParams.query\n}\n```\n\n> 여기서는 `params`와 `searchParams`가 Promise로 감싸져서 넘어옵니다. 그래서 컴포넌트나 함수 내에서 `await`으로 값을 받아와 처리하는 거죠. 이렇게 하면 URL 파라미터나 쿼리 스트링이 비동기적으로 처리될 때도 문제없이 데이터를 다룰 수 있어요.\n\n---\n\n### 마무리 - 왜 이렇게 바꾸는 걸까?\n\n- **React 18, Next.js 13** 등 최신 도구들이 비동기를 더 자연스럽게 다루도록 발전하고 있기 때문이에요.\n- `use` 훅으로 비동기 데이터를 처리하면 렌더링 로직이 엄청 깔끔해지고 버그도 줄어듭니다.\n- Promise를 직접 받고 `await` 하면서 컴포넌트가 더 유연하게 변해요.\n\n---\n\n### 간단 요약\n\n| 이전 방식                       | 최신 방식                          |\n|------------------------------|---------------------------------|\n| `params`는 동기 객체              | `params`는 Promise로 감싸진 비동기 객체  |\n| 데이터 바로 사용                  | `use` 훅 (Layout) / `await` (Page) 이용 |\n| 함수 파라미터에 바로 받음           | Promise 감싸진 객체를 `await` 또는 `use`로 처리 |\n\n---\n\n이제 이런 패턴을 알았으니, Next.js 프로젝트나 React 앱에서 URL 파라미터 등을 더 깔끔하고 안전하게 처리해보세요! 필요하면 `use` 훅이 지원되는지, 환경이 맞는지 먼저 확인하는 것도 잊지 마시고요. 궁금한 점 있으면 또 알려드릴게요~!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 동기식 페이지 (Synchronous Page) 코드 전환하기\n\n안녕하세요! 오늘은 Next.js에서 동기식 페이지를 만드는 방법을 조금 더 최신 React 문법에 맞게 바꾸는 방법을 이야기해볼게요. 코드를 조금만 바꾸면 더 깔끔해지고, Promise를 직접 받아서 사용할 수 있게 되는 점이 포인트입니다.\n\n---\n\n#### 기존 코드 Before → 최신 코드 After\n\n##### Before (기존 방식)\n\n```tsx\n// 기존에는 params와 searchParams가 객체로 바로 들어왔어요\ntype Params = { slug: string }\ntype SearchParams = { [key: string]: string | string[] | undefined }\n\nexport default function Page({\n  params,\n  searchParams,\n}: {\n  params: Params\n  searchParams: SearchParams\n}) {\n  const { slug } = params\n  const { query } = searchParams\n}\n```\n\n##### After (업데이트된 방식)\n\n```tsx\nimport { use } from 'react'\n\n// 이제 params와 searchParams가 Promise로 들어옵니다\ntype Params = Promise<{ slug: string }>\ntype SearchParams = Promise<{ [key: string]: string | string[] | undefined }>\n\nexport default function Page(props: {\n  params: Params\n  searchParams: SearchParams\n}) {\n  // react의 use 훅을 써서 Promise를 바로 resolve합니다\n  const params = use(props.params)\n  const searchParams = use(props.searchParams)\n  const slug = params.slug\n  const query = searchParams.query\n}\n```\n\n---\n\n#### 심플 버전도 이렇게 바꿔요!\n\n```tsx\n// Before\nexport default function Page({ params, searchParams }) {\n  const { slug } = params\n  const { query } = searchParams\n}\n\n// After\nimport { use } from \"react\"\n\nexport default function Page(props) {\n  const params = use(props.params)\n  const searchParams = use(props.searchParams)\n  const slug = params.slug\n  const query = searchParams.query\n}\n```\n\n---\n\n### 여기서 잠깐!\n\n- `use` 훅은 React 18부터 도입된 실험적 API 중 하나로, Promise를 받아 바로 결과를 얻을 수 있어요.\n- Next.js의 새로운 데이터 페칭 방식과 잘 어울리는데, async/await를 쓰지 않고도 동기식처럼 코드를 작성할 수 있게 해 줍니다.\n- 물론 아직 안정화 단계이니 실제 프로젝트에 적용할 때는 주의가 필요해요. (React 릴리즈 노트를 꼭 확인해보세요!)\n\n---\n\n#### 마무리\n\n이처럼 Next.js에서 page 컴포넌트에 들어오는 params와 searchParams 타입이 Promise로 변경되었고, React의 `use` 훅을 사용해 데이터를 간편하게 사용할 수 있게 되었습니다. 개발자 경험이 점점 좋아지는 것 같아 기대됩니다!\n\n다음 글에서는 Route Handlers 관련 내용도 다뤄볼 예정이니까 기대해 주세요~\n\n---\n\n궁금한 점 있으면 언제든 댓글 주세요! 😊\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이번에 Next.js에서 `GET` 함수의 파라미터 `params` 타입과 처리 방식에 변화가 생겼어요. 기존에는 `params`가 동기적으로 바로 사용할 수 있는 객체였는데, 이제는 `params`가 `Promise`로 감싸져 비동기 처리를 해야 합니다. 간단히 말하면, `params`를 바로 쓰면 안 되고, `await`으로 비동기 값을 받아와야 한다는 거죠.\n\n아래 예시 코드를 보며 차이점을 살펴볼게요.\n\n```ts\n// Before\ntype Params = { slug: string }\n \nexport async function GET(request: Request, segmentData: { params: Params }) {\n  const params = segmentData.params        // 동기 처리\n  const slug = params.slug\n}\n \n// After\ntype Params = Promise<{ slug: string }>\n \nexport async function GET(request: Request, segmentData: { params: Params }) {\n  const params = await segmentData.params   // 비동기 처리 필수\n  const slug = params.slug\n}\n```\n\n이처럼 `params` 타입이 `Promise`로 변경되면서, `await` 없이는 `slug`를 바로 꺼낼 수 없어요. 이것은 Next.js가 내부 라우팅 파라미터를 더 유연하게 처리하기 위한 변경 사항으로 보입니다.\n\n또한 타입이 명시되어 있지 않은 코드에서도 마찬가지에요.\n\n```ts\n// Before\nexport async function GET(request, segmentData) {\n  const params = segmentData.params    // 동기 처리\n  const slug = params.slug\n}\n \n// After\nexport async function GET(request, segmentData) {\n  const params = await segmentData.params   // 비동기 처리 필수\n  const slug = params.slug\n}\n```\n\n이 부분은 간단하지만, 만약 기존 코드를 그대로 쓴다면 `slug`를 읽으려 할 때 `params`가 `Promise`니까 `undefined`가 나오거나 에러가 날 수 있어요. 따라서 반드시 `await` 키워드를 붙여주셔야 합니다.\n\n---\n\n## 런타임 설정 관련 깨알 변화! - Breaking change\n\n`runtime` 설정을 하실 때, 이전에는 `experimental-edge`와 `edge` 두 가지 옵션을 모두 쓸 수 있었어요. 그런데 이 둘은 사실 같은 걸 의미해요. 그래서 앞으로는 `experimental-edge`를 사용하면 에러가 납니다! 깔끔하게 `edge`로만 쓸 수 있도록 정리한 거죠.\n\n만약 예전에 `experimental-edge`로 설정해둔 게 있다면, 아래처럼 바꾸시면 됩니다.\n\n| Before           | After   |\n|------------------|---------|\n| `experimental-edge` | `edge`   |\n\n귀찮으시다면 자동으로 바꿔주는 코드모드(codemod)도 제공하고 있으니 참고하세요.\n\n---\n\n이 변경 사항들은 Next.js가 더 견고하고 명확한 API를 제공하려는 노력의 일환입니다. 여러분의 API 핸들러 코드를 수정할 때는 이번 `params` 비동기 처리 부분과 `runtime` 설정을 꼭 점검해 주세요. 특히 `await` 처리 누락은 의외로 찾기 힘든 버그가 될 수 있으니 조심하시고요!\n\n추가로, `params`가 이제 `Promise`라는 점은 Next.js가 내부에서 라우트 파람 해석을 비동기로 처리하거나, 더 복잡한 데이터 준비과정이 추가됐기 때문인데요. 앞으로 이런 패턴이 더 확산될 가능성이 높으니, 비동기 처리를 기본으로 생각하는 습관을 들이면 좋겠어요.\n\n필요하다면 `GET` 외에 다른 HTTP 메서드 핸들러(`POST`, `PUT` 등)도 동일하게 바뀌었을 가능성이 있기에 한번 점검해 보시길 권합니다.\n\n오늘 알려드린 내용, 작게는 한 줄 바꾸는 거지만, 다음 프로젝트에서 여러분 코드를 한층 안정적으로 만들어 줄 거예요! 잘 적용해보시길 바랍니다~\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## fetch 요청 캐싱 방식이 바뀌었어요!\n\n이번에 fetch 요청이 기본적으로 더 이상 자동으로 캐싱되지 않는다는 점, 알고 계셨나요? 이전에는 그냥 fetch 호출하면 브라우저가 알아서 캐싱해줬는데, 이제는 기본값이 캐싱 안 함으로 바뀌었답니다.\n\n그래서 만약 특정 fetch 요청을 꼭 캐싱하고 싶다면, fetch 함수에 옵션으로 `cache: 'force-cache'`를 명시해줘야 해요. 예를 들어 아래처럼요:\n\n```js\nexport default async function RootLayout() {\n  // 기본 fetch는 캐시 안 함\n  const a = await fetch('https://...')\n\n  // force-cache 옵션을 주면 캐시 사용!\n  const b = await fetch('https://...', { cache: 'force-cache' })\n  \n  // ...\n}\n```\n\n### 좀 더 알아두면 좋은 점\n- `cache` 옵션은 브라우저의 기본 캐시 정책보다 fetch 요청마다 세밀하게 제어할 수 있게 해줍니다.\n- `force-cache` 외에도 다양한 옵션이 있는데, 예를 들어 `no-cache`는 항상 네트워크에서 새로운 데이터를 가져오고 캐시는 무시하는 기능이에요.\n- 캐시를 적절히 활용하면 네트워크 비용과 로딩 속도를 크게 줄일 수 있으니까, 상황에 맞게 잘 조절해보세요!\n\n요즘은 SSR(서버 사이드 렌더링)이나 SSG(정적 사이트 생성)를 자주 사용하는데, fetch 캐싱 정책이 이런 환경과도 잘 맞게 바뀌었다고 보시면 됩니다. 꼭 최신 정책에 맞게 코드를 작성해보세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nfetch 요청을 페이지나 레이아웃 단위에서 한 번에 캐싱 처리하고 싶다면, `export const fetchCache = 'default-cache'` 설정을 사용하면 됩니다. 이 옵션을 추가하면, 해당 레이아웃이나 페이지 내의 모든 fetch 요청은 별도로 캐시 옵션을 지정하지 않는 이상 기본적으로 캐싱됩니다.\n\n```js\n// 이게 루트 레이아웃이라면, 앱 내 fetch 요청 중\n// 따로 캐시 옵션을 안 줬으면 전부 캐싱됩니다.\nexport const fetchCache = 'default-cache'\n\nexport default async function RootLayout() {\n  const a = await fetch('https://...') // 캐시됨\n  const b = await fetch('https://...', { cache: 'no-store' }) // 캐시 안됨\n\n  // ...\n}\n```\n\n여기서 중요한 점은, 개별 fetch 요청 쪽에서 `cache` 옵션을 직접 지정하면 그 설정이 우선 적용된다는 거예요. 따라서 전체적인 기본 캐싱 전략은 위 설정으로 하고, 특정 요청만 예외를 두고 싶은 경우 각 fetch에 `cache: 'no-store'` 같은 옵션을 직접 지정할 수 있죠.\n\n---\n\n### Route Handlers (라우트 핸들러)에서의 캐시 전략\n\n다음으로, Route Handlers에서 GET 메서드는 기본적으로는 캐싱되지 않아요. 그렇기 때문에 GET 요청을 캐싱하고 싶을 때는 라우트 핸들러 파일에 `export const dynamic = 'force-static'` 같은 설정을 추가해줘야 합니다.\n\n즉, `dynamic` 설정을 통해 해당 라우트의 리소스가 정적(static)으로 처리되어 캐시될 수 있도록 강제하는 거예요.\n\n---\n\n이 내용들을 잘 활용하면, 앱 내 네트워크 요청들을 효과적으로 관리할 수 있습니다. 특히 데이터가 자주 변경되지 않는 경우 캐시를 적극 활용하는 게 로딩 속도를 확실히 높이고 사용자 경험도 개선하니까요!\n\n추가로, Next.js에서 fetch의 `cache` 옵션으로는 'no-store' 외에도 'default', 'reload', 'force-cache' 등이 있는데, 각 옵션의 차이를 익혀두면 상황에 맞는 캐싱 정책을 세우기 좋습니다. 예를 들어:\n\n| 옵션        | 설명                                         |\n|-------------|---------------------------------------------|\n| default     | 기본값, 브라우저/런타임의 기본 캐싱 정책 사용     |\n| no-store    | 캐시하지 않고 항상 네트워크에서 새로 가져오기     |\n| reload      | 캐시 무시하고 항상 네트워크 요청하기             |\n| force-cache | 캐시된 데이터가 있으면 무조건 가져오기             |\n\n이런 차이점도 참고하세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nexport const dynamic = 'force-static';\n\nexport async function GET() {}\n```\n\n## 클라이언트 사이드 라우터 캐시\n\nNext.js 같은 프레임워크에서 `Link`나 `useRouter`를 통해 페이지를 이동할 때, 클라이언트 사이드 라우터 캐시에서 기존 페이지 세그먼트를 재사용하지 않아요. 대신 브라우저의 뒤로 가기, 앞으로 가기 버튼을 누를 때, 그리고 공통 레이아웃(shared layouts)을 사용할 때는 세그먼트를 재사용합니다.\n\n만약 페이지 세그먼트의 캐싱을 활성화하고 싶다면 `staleTimes` 설정 옵션을 활용할 수 있는데요, 이 옵션을 통해 특정 시간 동안 페이지 데이터를 캐시에 저장해 두고 재사용할 수 있어요.\n\n### 좀 더 쉽게 설명하자면!\n\n- **기본 동작:** `Link`나 `useRouter`를 이용한 페이지 이동 시, 매번 새로 데이터를 가져오고 새 페이지를 렌더링합니다.\n- **하지만:** 뒤로 가기 / 앞으로 가기 를 할 땐 캐시된 데이터를 씁니다.\n- **해결 방법:** `staleTimes`를 설정해 캐시된 데이터를 일정 시간 동안 유지할 수 있게 해요.\n\n이렇게 하면 네비게이션 시 유저 경험이 좀 더 부드러워지고, 불필요한 데이터 요청도 줄일 수 있습니다. 만약 대형 앱에서 사용자 인터렉션 빈도가 높다면 캐싱 매커니즘을 활용하는 것을 강력히 추천드려요!\n\n아래 표는 대표적인 `staleTimes` 설정 예시입니다:\n\n| 설정 값         | 설명                                |\n|----------------|-----------------------------------|\n| `staleTimes: 0` | 캐시 사용 안 함 (기본값)             |\n| `staleTimes: 60000` | 1분간 캐시 유지                       |\n| `staleTimes: 300000` | 5분간 캐시 유지                       |\n\n캐싱 시간은 앱의 특성이나 사용자 흐름에 따라 적절히 조절하면 됩니다.\n\n---\n\n필요하다면 다음에 `staleTimes`를 실제 코드에 적용하는 예시도 공유할게요! 언제든 질문 주세요. :)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안녕하세요! 오늘은 Next.js에서 최근에 업데이트된 부분 중 하나를 같이 살펴볼게요.\n\n먼저, 여러분이 보신 것처럼 `next.config.js`에 아래와 같은 설정이 들어갈 수 있습니다.\n\n```js\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  experimental: {\n    staleTimes: {\n      dynamic: 30,\n      static: 180,\n    },\n  },\n}\n\nmodule.exports = nextConfig\n```\n\n### 이 설정, 뭐 하는 거냐?\n\n`staleTimes` 설정은 Next.js에서 페이지를 캐싱하는 시간과 관련된 실험적 기능입니다. 여기서 'dynamic'은 동적 데이터가 있는 페이지에 대한 캐시 시간(초 단위), 'static'은 정적인 페이지에 대한 캐시 시간을 의미해요.\n\n- `dynamic: 30` → 동적 페이지는 30초 동안 캐시를 유지\n- `static: 180` → 정적 페이지는 180초 동안 캐시 유지\n\n이렇게 하면 방문자가 페이지를 빠르게 로드할 수 있게 되면서도, 너무 오래된 데이터가 보여지는 것을 어느 정도 방지할 수 있죠.\n\n하지만 중요한 점! 레이아웃(layouts)이나 로딩 상태(loading states)는 여전히 네비게이션할 때 캐시되고 재사용됩니다. 즉, 페이지 전체가 아닌 일부 컴포넌트의 상태 재사용은 유효하다는 거예요. 이 부분은 개발자가 미리 염두에 두면 사용자 경험을 개선하는 데 도움이 됩니다.\n\n---\n\n### next/font가 사라졌다고?\n\n예전 Next.js에서는 `@next/font`라는 패키지를 통해서 폰트를 쉽게 관리할 수 있었죠. 그런데 이제는 `next/font`가 빌트인 기능으로 통합되면서 별도의 패키지를 설치할 필요가 없게 됐어요.\n\n즉, 옛날 방식으로 `@next/font`에서 import 했다면, 이제는 그냥 `next/font`로 바꾸면 됩니다. 게다가, 이 작업을 안전하고 자동으로 해주는 **codemod** 도구가 제공되고 있으니, 큰 걱정 없이 업그레이드할 수 있습니다.\n\n---\n\n### 개발자로서 알아두면 좋은 팁!\n\n- 이런 실험적 기능들은 실제 프로덕션에 적용하기 전에 꼭 테스트를 해보세요. 자동 캐싱 때문에 데이터가 오래된 상태로 보여질 수 있으니, 데이터 신선도를 유지하는 전략을 같이 고민하는 게 중요합니다.\n- Next.js가 업데이트될 때마다 공식 문서, 마이그레이션 가이드, 그리고 codemod 도구를 적극 활용하면, 시간과 노력을 절약할 수 있어요.\n\nNext.js가 점점 더 사용하기 편리해지고 있어서 앞으로가 더욱 기대됩니다! 다음에도 새롭고 쓸만한 기능이나 팁 있으면 같이 나눠봐요~ 😄\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이번에 Next.js에서 바뀐 import 방식과 설정 옵션에 대해 알아볼게요. 코드를 보면서 쉽게 따라올 수 있도록 차근차근 설명해드릴게요.\n\n---\n\n### 1. 폰트 import 경로 변경\n\n```js\n// Before\nimport { Inter } from '@next/font/google'\n\n// After\nimport { Inter } from 'next/font/google'\n```\n\n예전에는 `@next/font/google` 경로에서 구글 폰트를 가져왔는데, 이제는 `next/font/google` 경로로 바뀌었어요. 굳이 `@next/`가 붙지 않아서 더 깔끔해졌죠.\n\n> 참고로, 이 변경으로 인해 폰트 관련 코드에서 오류가 발생한다면 경로를 꼭 확인해보세요!\n\n---\n\n### 2. 설정 옵션 이름 변경: `bundlePagesExternals` → `bundlePagesRouterDependencies`\n\n```js\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  // Before\n  experimental: {\n    bundlePagesExternals: true,\n  },\n\n  // After\n  bundlePagesRouterDependencies: true,\n}\n\nmodule.exports = nextConfig\n```\n\n기존엔 experimental(실험 기능) 중 하나로 쓰이던 `bundlePagesExternals`가 정식으로 자리 잡으면서 이름도 `bundlePagesRouterDependencies`로 바뀌었어요. 이제 `experimental` 안에 넣지 않고 바로 최상위 옵션으로 작성하면 됩니다.\n\n> 이 옵션은 페이지 라우터에서 의존성들을 묶어서 번들링하는 기능인데요. 페이지별로 필요한 모듈들을 효율적으로 관리할 때 도움되니, 대규모 프로젝트에서는 성능 최적화에 유용합니다.\n\n---\n\n### 요약\n\n| 변경 전                       | 변경 후                         | 설명                                    |\n|------------------------------|--------------------------------|----------------------------------------|\n| `import { Inter } from '@next/font/google'` | `import { Inter } from 'next/font/google'` | 구글 폰트 import 경로 변경                  |\n| `experimental.bundlePagesExternals`         | `bundlePagesRouterDependencies`           | 실험적 기능에서 정식 옵션으로 변경 및 위치 이동 |\n\n---\n\nNext.js는 꾸준히 발전하면서 더 깔끔하고 성능 좋은 설정 방법들을 제시해주니까 자주 공식 문서를 살펴보면서 최신 변화를 체크하는 게 좋아요. 필요하면 새 설정도 실험해보면서 최적화해 보시길 추천드립니다! 😊\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## serverExternalPackages\n\nNext.js에서 `experimental.serverComponentsExternalPackages`가 안정화되어 이제 `serverExternalPackages`로 이름이 변경되었어요.\n\n예전엔 `experimental` 안에 설정했지만, 이제는 그냥 바로 `serverExternalPackages`로 설정하면 됩니다.\n\n```js\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  // 예전 방식\n  experimental: {\n    serverComponentsExternalPackages: ['package-name'],\n  },\n \n  // 최신 방식\n  serverExternalPackages: ['package-name'],\n}\n\nmodule.exports = nextConfig\n```\n\n이 설정은 서버 컴포넌트에서 외부 패키지를 사용할 때 필요한 건데, 특히 기본적으로 서버 컴포넌트에 포함되지 않는 서드파티 패키지를 명시할 때 유용해요. 이렇게 하면 빌드 과정에서 오류를 방지하고, 필요한 패키지를 서버에서 올바르게 로드할 수 있습니다.\n\n추가로, `serverExternalPackages`를 잘 활용하면 서버 컴포넌트의 성능 최적화에 도움이 될 수 있어요. 왜냐하면, 서버쪽에서 필요한 패키지를 명확히 분리해서 로드하니까 클라이언트 번들 사이즈가 줄어들고 불필요한 코드가 포함되는 걸 막을 수 있거든요.\n\n## Speed Insights\n\nNext.js 같은 프레임워크를 쓰면서 성능에 대해 고민하는 건 정말 중요하죠! 구글의 Speed Insights 같은 도구를 통해 내 웹사이트가 얼마나 빠른지, 어느 부분에서 병목 현상이 일어나는지 확인해보는 걸 추천합니다.\n\nSpeed Insights는 페이지 로딩 시간, 사용자 경험, 접근성, SEO 등 다양한 지표를 점수로 보여주는데, 결과에 따라 개선할 수 있는 부분을 구체적으로 안내해줘요.\n\n저도 개발하면서 Speed Insights를 꾸준히 체크하면서 아래 부분들에 주로 신경써요:\n\n- 이미지 최적화 (이미지 사이즈 축소, next/image 컴포넌트 활용)\n- 코드 스플리팅 및 동적 import\n- 불필요한 자바스크립트 제거\n- 서버 쪽 렌더링 활용과 클라이언트에서의 첫 로딩 속도 최적화\n\nNext.js 최신 버전을 활용하는 것 자체가 이미 많은 최적화가 적용되어 있지만, `serverExternalPackages` 같이 서버 컴포넌트 관련 설정을 꼼꼼히 맞추는 것도 결국 Speed Insights 점수를 끌어올리는 데 도움이 됩니다.\n\n웹사이트 속도는 사용자 경험에도 큰 영향을 주니, 한번에 완벽하려고 하기보다 꾸준하게 모니터링하고 개선하는 습관을 들이는 게 가장 좋아요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js 15부터는 Speed Insights를 자동으로 연동해주는 기능이 제거되었어요.\n\n그래서 Speed Insights를 계속 사용하고 싶다면, Vercel에서 제공하는 Speed Insights Quickstart 가이드를 참고해서 직접 설정해줘야 합니다.\n\n---\n\n## NextRequest의 Geolocation 변경점\n\n이전 버전에서는 NextRequest 객체에서 `geo`와 `ip` 같은 지리 정보 관련 속성을 직접 제공했는데요, Next.js 15부터는 이 값들이 호스팅 제공자(예: Vercel)에서 직접 제공되기 때문에 해당 속성들이 제거되었어요.\n\n만약 프로젝트에서 이 부분을 사용하고 있다면, 자동으로 변경해주는 codemod(코드 변환 도구)가 있으니 이를 활용하면 편리하게 마이그레이션 할 수 있습니다.\n\n---\n\n### 덧붙여서\n\n- Speed Insights를 자동으로 처리해주던 기능이 빠진 만큼, 수동 설정 과정에서 분석된 데이터를 직접 확인하고 조작할 수 있다는 장점도 있어요.\n- hosting provider가 제공하는 geo 정보는 좀 더 정확하거나 세밀한 경우가 많으니 이를 활용해보는 것도 추천합니다.\n- Codemod는 CLI 기반 도구로, 프로젝트 루트에서 실행하면 자동으로 코드 패턴을 찾아서 새 구조에 맞게 바꿔줍니다. 사용법은 보통 공식 문서를 참고하면 되고, 큰 규모 프로젝트에서도 안정적으로 변경 가능해요.\n\n더 궁금한 점 있으면 알려주세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 Vercel을 사용하고 있다면, @vercel/functions 패키지에서 제공하는 geolocation과 ipAddress 함수를 활용할 수도 있어요. 이렇게 하면 클라이언트의 위치 정보나 IP 주소를 쉽게 가져올 수 있답니다.\n\n예를 들어, geolocation 함수는 요청 정보를 기반으로 위치 데이터를 반환해줘서, 미들웨어에서 바로 도시 이름(city) 같은 걸 뽑아 쓸 수 있어요:\n\n```js\nimport { geolocation } from '@vercel/functions'\nimport type { NextRequest } from 'next/server'\n \nexport function middleware(request: NextRequest) {\n  const { city } = geolocation(request)\n \n  // 여기서 city 정보를 활용할 수 있습니다.\n}\n```\n\n또한 ipAddress 함수는 요청에서 IP 주소만 딱 반환하기 때문에, IP 기반 처리나 인증 등에 쓸 때 편리해요:\n\n```js\nimport { ipAddress } from '@vercel/functions'\nimport type { NextRequest } from 'next/server'\n \nexport function middleware(request: NextRequest) {\n  const ip = ipAddress(request)\n \n  // ip를 활용하는 로직 작성\n}\n```\n\n참고로, 이 함수들을 쓰면 직접 클라이언트 IP를 헤더에서 뽑거나, 외부 API를 호출해서 위치를 확인하는 등의 번거로운 작업을 줄일 수 있어서 개발 속도가 훨씬 빨라질 거예요. 다만, Vercel 플랫폼에서만 동작하니 로컬이나 다른 환경에서는 호환성에 유의해 주세요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":32},{"title":"Next.js 14 버전으로 업그레이드하는 방법","description":"","date":"2025-04-22 01:44","slug":"2025-04-22-Howtoupgradetoversion14","content":"\n\n# Next.js 14 버전으로 업그레이드하는 방법\n\n## 13버전에서 14버전으로 업그레이드하기\n\nNext.js 14 버전으로 업데이트하려면 아래 명령어를 사용하면 돼요. 자신이 주로 사용하는 패키지 매니저에 맞춰 실행해 주세요!\n\n```bash\nnpm i next@next-14 react@18 react-dom@18 && npm i eslint-config-next@next-14 -D\n```\n\n이 명령어는 Next.js, React, React DOM을 각각 최신 버전(14 버전과 React 18)으로 업데이트해주고, 개발 환경에서 ESLint 설정도 맞게 업그레이드해 줍니다.\n\n> 참고로, Next.js는 React 최신 버전과 호환되도록 설계돼 있어서 React도 같이 업데이트해야 원활한 개발 가능해요.\n\nnpm 대신 yarn을 쓰는 분들은,\n\n```bash\nyarn add next@next-14 react@18 react-dom@18 && yarn add -D eslint-config-next@next-14\n```\n\n이렇게 하면 됩니다.\n\n---\n\n### 추가 팁\n\n- 버전 업그레이드 후에는 의존성 충돌이 없는지, 개발 서버가 정상 실행되는지 꼭 확인하세요.\n- Next.js 14 버전에서는 여러 가지 새로운 기능과 최적화가 들어갔는데, 공식 릴리즈 노트를 한 번 쭉 읽어보는 것도 좋아요.\n- 아무래도 메이저 버전 업그레이드이다 보니 기존 코드 일부는 수정이 필요할 수 있으니, 마이그레이션 문서나 changelog도 참고해 주세요.\n\n저도 최근에 Next.js 13에서 14로 넘어가면서 성능이 좀 더 좋아진 것 같고 깔끔한 API들도 마음에 들었어요. 한번 도전해 보시길 추천드릴게요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안녕하세요, 여러분! 오늘은 Next.js 14 버전과 React 18을 설치하는 방법을 소개해 드릴게요. 그리고 ESLint 설정도 최신 버전으로 맞추는 팁도 함께 알려드리겠습니다.\n\n사실 요즘에는 패키지 매니저가 여러 개 있어서 npm, yarn부터 pnpm, 심지어 bun까지 다양한 선택지가 있죠. 그래서 각 패키지 매니저별로 설치 명령어를 깔끔하게 정리해봤어요.\n\n| 패키지 매니저 | 설치 명령어 |\n|---------------|-------------|\n| yarn          | `yarn add next@next-14 react@18 react-dom@18 && yarn add eslint-config-next@next-14 -D` |\n| pnpm          | `pnpm i next@next-14 react@18 react-dom@18 && pnpm i eslint-config-next@next-14 -D` |\n| bun           | `bun add next@next-14 react@18 react-dom@18 && bun add eslint-config-next@next-14 -D` |\n\n여기서 `-D` 옵션은 ESLint 설정을 개발환경용 의존성(devDependencies)으로 설치하겠다는 의미입니다. ESLint는 코드 품질 유지에 필수적인 도구니까 꼭 함께 설치해 주세요!\n\n> **참고!** 만약 TypeScript를 사용 중이라면 `@types/react`와 `@types/react-dom` 타입 선언 패키지도 꼭 최신 버전으로 업그레이드 해주세요. 그래야 타입 오류 없이 쾌적하게 개발할 수 있답니다.\n\n```bash\nyarn add @types/react@latest @types/react-dom@latest -D\n# 또는\npnpm i @types/react@latest @types/react-dom@latest -D\n# bun은 현재 타입 선언 패키지 직접 설치가 조금 다를 수 있으니 공식 문서 참고하세요.\n```\n\n끝으로, Next.js 14 버전은 많은 성능 개선과 새로운 기능을 담고 있어서 이번 기회에 업그레이드 해보시면 정말 좋을 거예요! 혹시 설치 중 문제가 발생하거나, 관련해서 더 궁금한 점 있으면 언제든지 댓글로 질문 주세요. 즐거운 개발 되세요~ 🚀\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### Next.js v14 요약\n\n안녕하세요! 오늘은 Next.js 최신 버전인 v14의 주요 업데이트 내용을 쉽게 정리해볼게요. 버전 업 할 때 꼭 체크해야 할 부분들이니 한 번 살펴보시길 추천해요.\n\n| 주요 변경 사항 | 설명 |\n|---|---|\n| Node.js 최소 버전 상향 | 기존 16.14에서 18.17로 최소 버전이 올라갔어요. 16.x는 공식적으로 지원이 종료됐기 때문에 최신 환경에서 개발하려면 Node 버전을 꼭 업그레이드하세요. |\n| next export 명령어 삭제 | 기존에 사용하던 `next export` 커맨드가 없어지고, 대신 `output: 'export'` 설정으로 변경됐어요. 정적 사이트 생성 시 설정 방식이 조금 바뀌었으니 공식 문서를 참고해 주세요. |\n| ImageResponse import 경로 변경 | 이미지 생성용 `ImageResponse` 컴포넌트의 import 경로가 `next/server` 대신 `next/og`로 바뀌었습니다. 자동 변환 도구(codemod)가 제공되니 쉽게 적용 가능해요. |\n| @next/font 패키지 제거 | 커스텀 폰트 관련 패키지였던 `@next/font`가 완전히 사라지고, Next.js 내장 `next/font`로 통합됐습니다. 이 부분도 자동 변환 스크립트를 활용해보세요. |\n| next-swc WASM 타겟 제거 | 성능 향상에 사용되던 WebAssembly(WASM) 타겟이 제거됐습니다. 앞으로는 다른 방식으로 최적화가 이뤄질 예정이에요. |\n\n---\n\n#### 추가 팁!\n\n- Node.js 버전 업그레이드는 Next.js뿐 아니라 다른 최신 라이브러리들도 잘 지원하니, 개발 환경 개선을 위한 좋은 기회예요.\n- codemod라는 도구가 자동으로 코드 전반에 걸쳐 변경점을 적용해주니, 수동 작업에 따른 실수를 줄일 수 있어요. 명령어 몇 줄로 업데이트가 가능해서 큰 도움이 됩니다!\n- `next export` 설정 변경은 정적 사이트 생성(SSG) 프로젝트라면 꼭 확인해야 할 부분입니다. 기존 방식과 조금 달라서 배포 플로우에 영향이 있을 수 있으니 사전에 테스트해보세요.\n\n---\n\nNext.js가 계속 발전하면서 새로운 개발 패턴과 최적화가 도입되고 있어요. 빠르게 변경 사항을 따라가면 더 편리하고 안정적인 웹 앱 개발이 가능하니 꾸준히 최신 문서도 살펴보시길 권해드립니다! 도움이 되셨다면 좋아요와 구독도 잊지 마세요 😊","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":4},{"title":"2025년 React 개발자를 위한 codemods 사용법과 예시 정리","description":"","date":"2025-04-22 01:40","slug":"2025-04-22-Codemods","content":"\n# Codemods\n\nCodemods는 코드베이스에 대해 프로그램적으로 실행되는 변환 작업을 말해요. 쉽게 말해, 한 파일 한 파일 수작업으로 고치지 않아도, 많은 파일에 걸쳐 자동으로 코드를 변경할 수 있게 도와주는 도구입니다.\n\nNext.js에서는 API가 업데이트되거나 더 이상 지원되지 않을 때, 코드를 쉽게 업그레이드할 수 있도록 Codemod 변환 스크립트를 제공해요. 덕분에 버전 업그레이드가 한결 수월해지죠.\n\n## 사용법\n\n(이후에 사용법 내용이 이어질 텐데, 필요하면 언제든 알려주세요!)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n터미널에서 프로젝트 폴더로 이동(cd)한 후, 아래 명령어를 실행해보세요:\n\n```bash\nnpx @next/codemod <transform> <path>\n```\n\n여기서 `<transform>`과 `<path>`는 상황에 맞게 바꿔주시면 됩니다.\n\n| 옵션      | 설명                                          |\n| --------- | --------------------------------------------- |\n| transform | 적용할 변환(transform) 이름                   |\n| path      | 변환을 적용할 파일 또는 디렉토리 경로         |\n| --dry     | 실제 코드 변경 없이 시뮬레이션(드라이런) 실행 |\n| --print   | 변경된 결과를 화면에 출력해서 비교 가능       |\n\n---\n\n참고로, `@next/codemod`는 Next.js 프로젝트에서 코드 마이그레이션을 좀 더 쉽게 해주는 도구예요. 예를 들어, Next.js 버전을 업그레이드하면서 API가 변경된 부분을 한꺼번에 자동 변환할 때 자주 사용됩니다.\n\n`--dry` 옵션은 정말 유용해요. 코드를 직접 바꾸기 전에, 어떤 부분이 바뀔지 먼저 확인할 수 있으니까요. `--print` 옵션은 변경된 결과를 터미널에 출력해줘서, 기존 코드와 변경된 코드를 비교할 수 있게 도와줍니다.\n\n만약 여러 transform을 한꺼번에 실행하고 싶다면, 반복해서 실행하거나 스크립트를 만들어서 자동화할 수도 있습니다. 작업 전에 꼭 Git 등의 버전 관리에 커밋을 한 상태에서 진행하시길 추천드려요. 혹시 변환 결과가 마음에 안 들면 쉽게 되돌릴 수 있으니까요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## Codemods\n\n### 15.0 버전\n\n#### App Router Route Segment Config의 runtime 값을 experimental-edge에서 edge로 변경하기\n\n> 참고: 이 codemod는 App Router에만 해당됩니다.\n\n---\n\n여기서 말하는 codemod는 코드 자동 변환 스크립트를 의미해요. 개발하다 보면 API가 변경되거나 새로운 문법이 도입될 때 기존 코드를 한꺼번에 바꿔야 할 때가 많잖아요? 이런 작업을 수동으로 하면 시간도 많이 들고, 실수할 수도 있어서 codemod를 쓰면 편리하죠.\n\n이번 15.0 업데이트에서는 App Router를 사용하는 분들을 위해 route segment 설정에서 `experimental-edge`라는 runtime 값을 `edge`로 변경하는 작업이 필요해요. 기존에는 'experimental'이라는 접두어가 붙는 기능들이 많았는데, 점점 안정화되면서 접두어를 빼는 경우가 많습니다.\n\n만약 App Router를 쓰고 있고, route segment 설정에서 runtime을 직접 지정하셨다면 codemod를 돌려서 일괄적으로 변경해 주시길 추천드려요.\n\n아, 그리고 codemod를 돌리기 전에 반드시 코드 베이스를 백업하거나 Git에 커밋해두는 것 잊지 마세요! 자동 변환 과정에서 예상치 못한 문제가 생길 수도 있으니까요.\n\n궁금하신 점 있으면 언제든 말씀해 주세요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 코드는 Next.js 프로젝트에서 사용하는 codemod 명령어예요.\n\n```bash\nnpx @next/codemod@latest app-dir-runtime-config-experimental-edge .\n```\n\n이 명령어는 Next.js에서 Route Segment Config의 `runtime` 설정 중 `'experimental-edge'`로 되어 있는 값을 `'edge'`로 자동으로 변경해 줍니다.\n\n예를 들어, 기존에 이런 식으로 작성한 코드가 있다면:\n\n```js\nexport const runtime = \"experimental-edge\";\n```\n\n이 codemod를 실행하면 이렇게 바뀌게 되는 거죠:\n\n```js\nexport const runtime = \"edge\";\n```\n\n---\n\n### 왜 이런 변경이 필요할까?\n\nNext.js가 점점 발전하면서, `experimental-edge`라는 이름이 정식으로 `edge`로 바뀌었어요. 이름도 더 간결해지고 안정성이 더 높아졌다는 의미예요. 예전에는 엣지 런타임이 실험적인 단계라 'experimental'이 붙었지만, 이제는 본격적으로 지원하기 때문에 이름이 바뀐 거죠.\n\n그래서 프로젝트를 최신 상태로 유지하려면 이런 codemod를 한번 돌려주는 게 좋아요. 복잡한 파일들을 일일이 찾아 바꾸지 않아서 시간도 절약되고 실수할 위험도 줄어들고요.\n\n---\n\n### 참고로 알아두면 좋은 점\n\n- codemod는 \"코드 변환 도구\"를 뜻해요. 주로 대규모 코드 변경이 필요할 때 사용되며, Next.js뿐 아니라 React, TypeScript 등 여러 생태계에서도 자주 활용돼요.\n- `npx`를 쓰면 별도의 설치 없이 최신 버전의 패키지를 바로 실행할 수 있어서 편리하답니다.\n- 만약 프로젝트가 매우 크거나, 중요한 부분이라면 codemod를 돌리기 전에 git으로 꼭 커밋 해두기, 혹은 별도의 브랜치에서 작업하는 걸 추천해요. 혹시 문제가 생겨도 쉽게 되돌릴 수 있으니까요.\n\n필요하면 제가 codemod 활용법이나 Next.js 엣지 런타임에 관한 더 자세한 글도 써볼게요~!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음과 같이 바뀌었어요:\n\n```js\nexport const runtime = \"edge\";\n```\n\n### 비동기(dynamic) API로 마이그레이션하기\n\n기존에 동기 방식도 지원하던 동적 렌더링 API들이 이제는 완전히 비동기 방식으로 변경됐어요. 이 부분은 프로젝트에 꽤 큰 영향을 줄 수 있으니 [업그레이드 가이드](https://nextjs.org/docs/upgrading)를 꼭 참고해서 차근차근 적용하는 걸 추천드립니다.\n\n---\n\n추가로, 이 변화를 이해할 때 조금 도움이 될만한 점을 덧붙이면, '동적 API'는 요청이 들어올 때마다 서버에서 새로 데이터를 받아서 처리하는 방식인데요, 이전에는 동기 방식이라 처리 완료까지 기다렸다가 결과를 반환했어요. 하지만 비동기로 바뀌면서 처리 효율이 좋아지고 서버 자원 활용도 더 최적화됐답니다.\n\n마이그레이션 하실 때는 async/await 문법에 익숙해지는 게 중요하고, API 핸들러 함수도 `async` 함수로 선언해주셔야 해요! 만약 기존 코드가 동기식으로 작성돼 있다면, 바로 비동기 로직으로 전환하는 게 필수입니다. 코드가 길거나 복잡하다면 조금 시간이 걸릴 수 있지만, 장기적으로는 더 효율적인 서버 리소스 관리와 성능 향상을 기대할 수 있어요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이번에 Next.js에서 동적 API인 `cookies()`, `headers()`, 그리고 `draftMode()` 같은 함수들이 이제 비동기(async) 함수로 바뀌었어요. 이전에는 그냥 바로 호출해서 값을 썼지만, 이제는 `await` 하거나, React 컴포넌트 안에서는 `React.use()`로 감싸줘야 제대로 동작합니다.\n\n그래서 Next.js에서 제공하는 코드를 한번에 자동 변환해주는 codemod가 있는데, 명령어는 이렇게 써주세요:\n\n```bash\nnpx @next/codemod@latest next-async-request-api .\n```\n\n이 코드는 프로젝트 내의 파일들을 찾아서 `cookies()`, `headers()` 같은 비동기 API 호출을 올바르게 변환해줍니다. 예를 들어 TypeScript 파일이면 타입캐스트를 추가하고, 자동 변환이 어려운 부분은 주석으로 알려서 직접 점검하게 도와줘요.\n\n아래 예시 코드를 보면,\n\n```js\nimport { cookies, headers } from \"next/headers\";\n\nconst token = cookies().get(\"token\");\n\nfunction useToken() {\n  const token = cookies().get(\"token\");\n  return token;\n}\n\nexport default function Page() {\n  const name = cookies().get(\"name\");\n}\n\nfunction getHeader() {\n  return headers().get(\"x-foo\");\n}\n```\n\n이렇게 동기적으로 호출하는 부분을 전부 비동기 패턴으로 바꿔줘야 합니다. 즉, `await cookies()` 혹은 React 훅 내에선 `React.use(cookies())`처럼요.\n\n---\n\n### 추가 팁!\n\n- `cookies()`, `headers()`, `draftMode()`가 비동기가 되면서 서버 컴포넌트(React Server Component)에서 사용하는 경우엔 `await`를 달아줘야 하니 주의하세요.\n- 클라이언트 컴포넌트에서는 직접 호출하면 안되고, 서버나 API 라우트 쪽에서 비동기로 사용하거나, Suspense 같은 컴포넌트 내에서 처리해야 해요.\n- 만약 자동 변환이 안 된 부분이 있다면, codemod가 표시한 주석을 놓치지 말고 꼭 확인해서 수동으로 고쳐주세요!\n\n---\n\n요즘 Next.js 프로젝트를 업그레이드하거나, 최신 기능 적용 중이라면 이 codemod 꼭 활용해 보시고, 비동기 호출 방식에 익숙해지시면 좋아요~! React와 Next.js가 점점 더 현대적인 패턴으로 변하고 있답니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n먼저, 주어진 코드 예제를 살펴볼게요. Next.js에서 `cookies`와 `headers`를 가져와서 토큰(token)을 읽는 방식인데, 여기서 중요한 점은 **동기 함수에서 비동기 프로퍼티 접근을 자동으로 감지해서 해당 함수를 async 함수로 변환하거나, 클라이언트 컴포넌트라면 React의 `use` 훅을 사용하는 점**이에요.\n\n예를 들어 아래 코드를 보면:\n\n```js\nconst token = (cookies() as unknown as UnsafeUnwrappedCookies).get('token')\n```\n\n이 코드는 동기적으로 보이지만 사실 `cookies()`가 비동기로 작동할 수 있어서, Next.js는 페이지나 라우트 파일(`page.js`, `layout.js`, `route.js`, `default.js`) 내에서 이런 프로퍼티 접근을 발견하면 함수 선언부를 async로 바꾸고 `await`를 붙여줍니다.\n\n또, 만약 해당 컴포넌트가 클라이언트 컴포넌트라면 `await`을 사용할 수 없으니 `React.use` 훅으로 promise를 언랩핑하는 방식을 써요. 예를 들어:\n\n```js\nfunction useToken() {\n  const token = use(cookies()).get(\"token\");\n  return token;\n}\n```\n\n이렇게 `use` 훅을 써서 비동기 리소스를 처리하죠.\n\n---\n\n### 주요 포인트 정리\n\n| 내용                                    | 설명                                                                                                  |\n| --------------------------------------- | ----------------------------------------------------------------------------------------------------- |\n| 동기 함수에서 비동기 프로퍼티 접근 감지 | `params`나 `searchParams`의 프로퍼티를 조회할 때 해당 함수가 자동으로 `async` 변환되면서 `await` 처리 |\n| 클라이언트 컴포넌트 제한                | 클라이언트 컴포넌트는 async 함수가 될 수 없으므로, React `use` 훅으로 비동기 값을 처리                |\n| 대상 파일                               | `page.js`, `layout.js`, `route.js`, `default.js` 그리고 `generateMetadata`, `generateViewport` API    |\n| 안전하지 않은 타입 처리                 | 내부적으로 `UnsafeUnwrappedCookies`, `UnsafeUnwrappedHeaders` 타입으로 캐스팅해서 다룰 수도 있음      |\n\n---\n\n### 개인적인 팁\n\n- Next.js 13+ 앱 디렉터리에서 `cookies()` 같은 API를 쓸 때, 가끔 이 비동기 처리 꼼수가 꽤 편리해요. 직접 `async/await` 붙이는 수고를 덜어주니까요.\n- 다만 클라이언트 컴포넌트에서 `use(cookies())`처럼 React 훅을 사용하려면, React 18 이상의 환경이 필요하니 버전 확인 필수!\n- 이런 자동 변환 덕분에 페이지 렌더링 시 필요한 헤더값, 쿠키값 등을 간편하게 처리할 수 있어 개발 속도가 빨라집니다.\n\n---\n\n필요하면 Next.js 내부에서 어떻게 이 변환이 처리되는지 좀 더 깊게 살펴볼 수도 있고, 클라이언트/서버 컴포넌트 간 상태 전달 팁도 알려줄게요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n자, 여기서 Next.js 13에서 `page.tsx` 파일 안의 컴포넌트와 `generateMetadata` 함수가 어떻게 변경되는지 보여주는 예시가 있어요.\n\n### 원래 코드\n\n```js\n// page.tsx\nexport default function Page({\n  params,\n  searchParams,\n}: {\n  params: { slug: string }\n  searchParams: { [key: string]: string | string[] | undefined }\n}) {\n  const { value } = searchParams\n  if (value === 'foo') {\n    // ...\n  }\n}\n\nexport function generateMetadata({ params }: { params: { slug: string } }) {\n  const { slug } = params\n  return {\n    title: `My Page - ${slug}`,\n  }\n}\n```\n\n여기서 `Page` 컴포넌트는 `params`와 `searchParams`를 바로 받고 있고, `generateMetadata` 함수도 일반 함수처럼 파라미터에서 `params`를 받는 구조입니다.\n\n---\n\n### 변경된 코드\n\n```js\n// page.tsx\nexport default async function Page(props: {\n  params: Promise<{ slug: string }>\n  searchParams: Promise<{ [key: string]: string | string[] | undefined }>\n}) {\n  const searchParams = await props.searchParams\n  const { value } = searchParams\n  if (value === 'foo') {\n    // ...\n  }\n}\n\nexport async function generateMetadata(props: {\n  params: Promise<{ slug: string }>\n}) {\n  const params = await props.params\n  const { slug } = params\n  return {\n    title: `My Page - ${slug}`,\n  }\n}\n```\n\n변경점은 다음과 같아요:\n\n1. `Page` 함수가 `async` 함수가 되었고, `params`와 `searchParams`가 이제 Promise로 감싸져서 들어와요. 그래서 함수 안에서 `await`해야 값을 얻을 수 있습니다.\n2. `generateMetadata`도 이제 `async` 함수이고, 역시 `params`가 Promise로 전달되니 `await`를 써야 하죠.\n\n---\n\n### 왜 이렇게 바뀌었을까요?\n\nNext.js 13에선 데이터 및 메타데이터가 비동기로 처리되는 경우가 많아져서, 이런 형태가 표준화되었어요. 특히, 서버 컴포넌트 특성상 데이터 fetching이나 메타데이터 생성이 비동기 작업이 될 수 있기 때문이죠.\n\n즉, `async` 함수로 만들어주고, `await`로 받아서 데이터를 처리하는 패턴이 더 자연스러워졌어요.\n\n---\n\n### 추가로 알아두면 좋은 점\n\n- **@next/codemod 주석**: 만약 자동 변환 도구(codemod)가 정확한 변경을 파악하기 어려운 곳이 있으면 `@next/codemod` 주석을 코드에 붙이는데, 이걸 발견하면 수동으로 코드를 확인하고 수정해야 합니다. 빌드 에러가 날 수 있으니 꼭 확인하고 고쳐야 해요.\n- 타입스크립트에서 `Promise` 타입을 파라미터로 받는 상황이 낯설 수 있는데, 이제 이런 패턴이 Next.js의 최신 구조에선 흔하니 익숙해지는 게 좋아요.\n\n---\n\n### 요약\n\n| 이전                                           | 이후                                                                   |\n| ---------------------------------------------- | ---------------------------------------------------------------------- |\n| 동기 함수, 직접 `params`와 `searchParams` 받음 | `async` 함수, `params`와 `searchParams`가 `Promise`라서 `await`해야 함 |\n| `generateMetadata`는 일반 함수                 | `generateMetadata`도 `async` 함수가 되어 `await` 처리 필요             |\n\n---\n\n### 마무리\n\nNext.js 13부터는 데이터와 메타데이터 처리 방식이 좀 더 비동기적이고 유연해졌어요. 그래서 `Page` 컴포넌트나 `generateMetadata`에서 기대하는 props 타입과 함수 선언방식이 바뀌었죠. 처음엔 조금 헷갈릴 수 있지만, 패턴에 익숙해지면 훨씬 효과적으로 서버 컴포넌트와 메타데이터를 다룰 수 있습니다.\n\n궁금한 점 있으면 편하게 물어봐 주세요! 😄\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n#### NextRequest의 geo와 ip 속성을 @vercel/functions로 교체하기\n\nNext.js에서 `NextRequest` 객체의 `geo`와 `ip` 속성을 사용할 때, 이제는 `@vercel/functions` 패키지를 사용하는 방향으로 바뀌고 있어요. 이를 간단하게 자동 변경해주는 코드를 소개할게요.\n\n```bash\nnpx @next/codemod@latest next-request-geo-ip .\n```\n\n이 명령어는 `@vercel/functions`를 설치하고, 프로젝트 내의 `NextRequest` 코드에서 `geo`와 `ip` 관련 속성들을 자동으로 변환해 줍니다.\n\n예를 들어, 기존에 이렇게 쓰던 코드를:\n\n```js\nexport function middleware(request) {\n  const country = request.geo?.country || \"US\";\n  const ipAddress = request.ip;\n  // ...\n}\n```\n\n`@vercel/functions` 방식으로 이렇게 바꿔줘요:\n\n```js\nimport { headers } from \"@vercel/functions\";\n\nexport function middleware(request) {\n  const country = headers()[\"x-vercel-ip-country\"] || \"US\";\n  const ipAddress = headers()[\"x-vercel-ip\"];\n  // ...\n}\n```\n\n사실 `@vercel/functions`를 쓰면 클라우드 엣지 환경에서 제공하는 IP와 지리 정보가 HTTP 헤더 형태로 전달됩니다. 그래서 직접 `NextRequest` 객체에서 속성을 읽는 대신, 헤더를 통해 읽는 방식으로 변경이 필요하답니다.\n\n---\n\n#### 참고 팁!\n\n- 만약 프로젝트에서 IP나 지리 정보가 중요한 로직이라면, 헤더의 키 이름이 변경되거나 누락되는 경우를 대비해서 기본값 처리를 꼭 해주세요.\n- 로컬 개발 환경에서는 이런 헤더가 없을 수 있기 때문에, 로컬 전용 설정이나 예외 처리도 고려하는 게 좋아요.\n- 직접 속성에 접근하는 코드가 많을수록 이 변환 작업을 자동화하는 codemod 도구를 꼭 써보시길 추천합니다. 수작업으로 고치면 빼먹는 코드가 생길 수 있거든요!\n\n이렇게 하면 Vercel에서 더 안정적이고 최신 방식으로 IP와 지역 정보를 활용할 수 있답니다. 멋진 개발하시길! 🚀\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이번에 Next.js API Route에서 클라이언트의 지리 정보(Geo)와 IP 주소를 가져오는 방식에 변화가 생겼네요.\n\n기존에는 NextRequest 객체에서 바로 `geo`와 `ip` 속성을 가져왔는데요, 14.0 버전부터는 `@vercel/functions` 에서 제공하는 `geolocation()`과 `ipAddress()` 함수를 이용해야 합니다.\n\n```js\nimport type { NextRequest } from \"next/server\";\nimport { geolocation, ipAddress } from \"@vercel/functions\";\n\nexport function GET(req: NextRequest) {\n  const geo = geolocation(req);\n  const ip = ipAddress(req);\n}\n```\n\n이렇게 바뀌면서 좀 더 명확하고 함수화된 형태로 관리할 수 있게 됐어요.\n\n한 가지 참고할 점!  \n만약 서버 측에서 클라이언트 IP를 신뢰성 있게 얻고 싶다면, 프록시나 로드 밸런서가 있으면 헤더에서 가져오는 IP가 실제 클라이언트 IP와 다를 수 있으니 주의해야 해요. 이때 `@vercel/functions`에서 제공하는 함수들이 그런 부분을 깔끔하게 처리해주니까 편리하고요.\n\n또한, 국제화나 지역 기반 맞춤 콘텐츠를 제공하려 할 때 거주지 정보를 이렇게 쉽게 뽑아내면 유용하겠죠? 다만 개인정보보호 관련법도 신경 써서 데이터를 다루어야 하는 점도 잊지 마세요!\n\nNext.js 14 버전 업데이트 사항을 반영해서 프로젝트를 개선해보시면 좋을 것 같습니다. 도움이 되셨길!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n#### ImageResponse 임포트 경로 변경하기\n\n다음 명령어를 입력하면 자동으로 `next/server`에서 `next/og`로 임포트 경로를 바꿔줘요. 이 작업은 동적 OG 이미지 생성(Dynamic OG Image Generation)을 사용할 때 필요해요.\n\n```bash\nnpx @next/codemod@latest next-og-import .\n```\n\n즉, 기존에 이렇게 쓰던 코드를\n\n```js\nimport { ImageResponse } from \"next/server\";\n```\n\n이제 이렇게 바꿔줘야 해요.\n\n```js\nimport { ImageResponse } from \"next/og\";\n```\n\n이 변경 덕분에 Next.js가 최신 OG 이미지 생성 방식을 올바르게 인식해서 동적으로 이미지를 잘 만들어줍니다.  \n자동화 도구(codemod)를 사용하면 수동으로 일일이 바꾸지 않아도 돼서 정말 편하답니다!\n\n혹시 `codemod`가 익숙하지 않거나 처음 들어본 분들은, codemod가 코드베이스 내에 여러 파일을 대상으로 특정 패턴을 찾아 자동으로 변경해 주는 도구라고 생각하면 돼요. Next.js에서는 공식적으로 지원하는 codemod 툴이 많아서 버전 업이나 API 변경 시 활용하기 좋아요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nnext.js에서 Open Graph 이미지 생성을 할 때, `ImageResponse`를 임포트하는 경로가 바뀌었어요. 예전에는 `next/server`에서 가져왔는데, 지금은 `next/og`에서 가져와야 합니다.\n\n```js\nimport { ImageResponse } from \"next/og\";\n```\n\n이렇게 바꾸면 공식 문서와도 맞고, 최신 버전에서 문제없이 작동하죠.\n\n---\n\n### 그리고 추가 팁!\n\nOpen Graph 이미지를 만들 때 `viewport` 관련 설정도 꼭 확인해 주세요. 예를 들어, 이미지 사이즈나 화면 배율을 조절할 수 있는데, 이렇게 하면 다양한 디바이스에서 더 예쁘고 정확하게 표시됩니다.\n\n```js\nexport const runtime = \"edge\"; // edge runtime 권장\n\nexport const viewport = {\n  width: 1200,\n  height: 630,\n};\n```\n\n이렇게 하면 1200x630 크기의 이미지를 생성해서 소셜 미디어에서 표준 크기로 잘 보여져요.\n\n---\n\n### 정리\n\n| 항목                        | 이전(Deprecated) | 현재 사용법                  |\n| --------------------------- | ---------------- | ---------------------------- |\n| `ImageResponse` 임포트 위치 | `next/server`    | `next/og`                    |\n| 뷰포트 설정                 | 없음             | `export const viewport` 사용 |\n\n앞으로 next.js Open Graph 이미지 생성 시, 위 변경 사항 기억하시면 편리하게 작업하실 수 있을 거예요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nJS 개발자 중에 Next.js를 사용하는 분들이라면, `npx @next/codemod@latest metadata-to-viewport-export .` 명령어 한 번쯤 들어봤을 거예요.\n\n이 명령어는 **Next.js 메타데이터에서 특정 뷰포트 설정을 'viewport'라는 별도 export로 분리해 주는 자동 변환 도구(codemod)**예요.\n\n### 왜 필요한가?\n\nNext.js 13, 14 버전 넘어가면서 메타데이터 관리 방식이 조금 바뀌었는데, 뷰포트 설정 같은 경우는 기존에 `metadata` 객체 안에 넣어서 관리하다가 앞으로는 `viewport`라는 export로 분리하는 걸 권장하고 있어요. 이걸 손으로 일일이 바꾸기 귀찮으니까, 자동으로 바꿔주는 게 바로 이 codemod입니다.\n\n### 예시를 보면\n\n기존엔 이렇게 작성했었죠:\n\n```js\nexport const metadata = {\n  title: \"My App\",\n  themeColor: \"dark\",\n  viewport: {\n    width: 1,\n  },\n};\n```\n\n이걸 실행하면, `viewport` 부분을 따로 뽑아서 이렇게 바뀔 거예요:\n\n```js\nexport const metadata = {\n  title: \"My App\",\n  themeColor: \"dark\",\n};\n\nexport const viewport = {\n  width: 1,\n};\n```\n\n### 참고할 점\n\n- codemod는 **프로젝트 루트 폴더나 특정 폴더에 적용할 수 있어요.**\n- 실행 전 꼭 백업하거나 Git 커밋 상태로 만들어두는 걸 권장합니다. 자동 변환 과정에서 혹시 모를 문제를 대비하기 위해서죠.\n- 모든 뷰포트 설정이 변환 대상이니, 변환 후엔 `viewport` export한 걸 `next/head`나 다른 컴포넌트에 제대로 적용하는지 확인해주세요.\n\n이렇게 코드를 자동으로 깔끔하게 바꿔주는 도구 덕분에 개발 속도가 더 빨라지고, 공식 권장 방식에 맞출 수 있답니다! 필요하다면 프로젝트에 맞게 직접 변형도 가능하니까 한 번 꼭 써보세요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래 코드를 보면 React나 Next.js 같은 프레임워크에서 자주 볼 수 있는 `metadata`와 `viewport` 설정을 JavaScript 모듈 형식으로 작성한 예제예요.\n\n```js\nexport const metadata = {\n  title: \"My App\",\n};\n\nexport const viewport = {\n  width: 1,\n  themeColor: \"dark\",\n};\n```\n\n- `metadata` 객체는 페이지의 메타 정보를 담고 있어요. 여기서는 간단하게 타이틀만 'My App'으로 지정했네요.\n- `viewport` 객체는 화면 표시 방식과 관련된 설정인데, 보통 `width` 값으로는 'device-width' 같은 문자열이 들어가지만, 여기선 `1`이라는 숫자가 들어가 있어서 실제 환경에선 조금 더 구체적인 설정이 필요할 것 같아요.\n- `themeColor`를 'dark'로 설정해 어두운 테마임을 지정해주는 부분도 눈에 띄네요.\n\n---\n\n### 13.2\n\n#### 내장 폰트 사용하기 (Use Built-in Font)\n\n이제 내장된 시스템 폰트를 활용해보는 것에 관한 이야기예요. 웹에서 폰트를 사용할 때 구글 폰트 같은 외부 폰트를 불러오는 경우가 많지만, 페이지 로딩 시간이나 성능 최적화를 생각하면 운영체제 기본 폰트를 활용하는 것도 좋은 선택입니다.\n\n예를 들어 CSS에서 이렇게 시스템 폰트를 지정할 수 있어요.\n\n```css\nfont-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Oxygen, Ubuntu, Cantarell, \"Open Sans\",\n  \"Helvetica Neue\", sans-serif;\n```\n\n이렇게 지정하면 iOS, Android, Windows, Linux 등 각 플랫폼에 최적화된 기본 폰트가 자동으로 적용돼서 사용자 경험이 훨씬 자연스러워집니다.\n\nNext.js 13.2 버전부터는 내장 폰트를 쉽게 사용할 수 있도록 공식적으로 지원하는 API가 제공되는데, 이를 활용하면 폰트를 import해서 번거롭게 외부에서 불러오는 과정을 줄일 수 있습니다.\n\n예를 들어, Next.js에서 제공하는 내장 폰트를 사용하려면:\n\n```js\nimport { Roboto } from \"next/font/google\";\n\nconst roboto = Roboto({\n  weight: \"400\",\n  subsets: [\"latin\"],\n});\n\nexport default function MyApp() {\n  return <main className={roboto.className}>{/* 앱 내용 */}</main>;\n}\n```\n\n위처럼 하면 별도의 `link` 태그 없이도 해당 폰트를 프로젝트 내에서 쉽게 적용할 수 있습니다.\n\n하지만 내장 폰트가 아닌 운영체제 기본 폰트를 선택하고 싶으면, 스타일 시트에서 위에 언급한 시스템 폰트 스택을 사용하는 방법이 가장 좋습니다.\n\n---\n\n**덧붙여서!**\n\n- 내장 폰트 사용은 페이지 로딩 속도를 개선하는 데 도움을 줍니다.\n- 외부 폰트는 네트워크 이슈에 취약할 수 있지만, 내장 폰트는 그런 걱정이 적죠.\n- 디자인과 사용자 경험에 맞게 내장 폰트와 외부 폰트를 적절히 섞어 사용하는 전략도 고려해보세요!\n\n필요하면 내가 다음에 폰트 최적화 방법에 대해서도 소개해줄게요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안녕하세요! 오늘은 Next.js 프로젝트에서 `@next/font` 패키지를 내장된 `next/font`로 바꿔주는 Codemod를 한번 살펴볼게요.\n\n요즘 Next.js에서는 폰트 처리를 더 간편하게 하기 위해 `@next/font` 대신 내장된 `next/font`를 사용하도록 권장하고 있어요. 그래서 기존에 `@next/font`를 쓰던 코드들을 새 방식으로 자동 변환해주는 도구가 나왔답니다.\n\n사용 방법은 아주 간단해요! 터미널에서 아래 명령어만 실행하면 돼요.\n\n```bash\nnpx @next/codemod@latest built-in-next-font .\n```\n\n- `npx`를 사용해서 최신 버전의 codemod를 실행하고,\n- `built-in-next-font`라는 변환 스크립트,\n- 그리고 마지막 `.`는 현재 폴더를 뜻합니다. 프로젝트 최상위 폴더에서 돌리면 된다는 거죠.\n\n이 툴의 역할은?\n\n- 자동으로 `@next/font` 패키지를 프로젝트에서 제거하고,\n- 코드 안에서 `@next/font`로부터 임포트한 부분을 내장된 `next/font`로 바꿔줘요.\n\n예를 들어, 기존에 이런 코드가 있었다면:\n\n```js\nimport { Inter } from \"@next/font/google\";\n```\n\nCodemod를 돌리고 나면 이렇게 변해요:\n\n```js\nimport { Inter } from \"next/font/google\";\n```\n\n즉, `@next/font/google` → `next/font/google`로 바뀌는 거죠.\n\n---\n\n### 참고로 알아두면 좋은 점!\n\n- 이 변경은 Next.js 13 이상에서 원활하게 동작합니다. 만약 구버전 쓰신다면 잠깐 버전부터 확인해보시는 게 좋아요.\n- 폰트 관련 설정이 빌트인으로 옮겨지기 때문에 설정 파일도 한번 점검해 주세요.\n- Codemod 실행 전에 꼭 깃 커밋 같은 백업을 해놓는 걸 추천합니다. 혹시 모를 문제 상황에 대비해서요.\n\n---\n\n간편한 코드 변환 도구 덕분에 코드를 하나하나 찾아 바꾸는 번거로움에서 벗어날 수 있으니 꼭 활용해 보시길 바랄게요! 혹시 Next.js에서 폰트 관련 다른 팁이 궁금하면 언제든 알려주세요~\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js 13.0 버전에서 바뀐 점 중 하나는 이미지 관련 import 구문 변경입니다. 예전에는 이미지 관련 모듈을 불러올 때 이름이 조금 다르게 쓰였는데요, 최신 버전에서는 좀 더 명확해졌어요.\n\n예를 들어, 기존에는 이미지 관련 파일이나 컴포넌트를 이렇게 불러왔다면:\n\n```js\nimport Image from \"next/image\";\n```\n\n다른 컨텍스트에서는 구글 폰트 같은 걸 불러올 때 이런 식으로 했잖아요:\n\n```js\nimport { Inter } from \"next/font/google\";\n```\n\n이런 import 구문을 최신 Next.js 13.0에 맞게 변경하는 작업이 필요해요. 특히 이미지 관련 라이브러리나 폰트를 사용할 때 Import 경로나 이름들이 리네이밍되거나 경로가 조금 바뀌는 경우가 있거든요.\n\n혹시 프로젝트를 업그레이드 중이라면, 공식 문서를 꼭 참고해서 변경 사항을 맞춰주시는 걸 추천합니다. 또한, 만약 이미지 컴포넌트를 사용하는 경우, 새 방식에서는 추가적인 최적화 옵션이나 속성들이 생겨서 퍼포먼스가 더 좋아졌답니다.\n\n참고로, 구글 폰트 같은 경우 새롭게 제공되는 `next/font` API를 이용하면 CSS 파일 없이도 폰트를 로딩할 수 있어서 개발자 경험이 훨씬 좋아졌어요!\n\n간단 요약해보면:\n\n| 항목             | 변경 전                                    | 변경 후                                                                          |\n| ---------------- | ------------------------------------------ | -------------------------------------------------------------------------------- |\n| 구글 폰트 Import | `import { Inter } from 'next/font/google'` | 그대로 사용하지만 최신 버전 API 이용                                             |\n| 이미지 Import    | `import Image from 'next/image'`           | `import Image from 'next/image'` (유지) - 다만 사용하는 방식과 옵션은 업데이트됨 |\n\nNext.js 13로 업그레이드할 때 이미지와 폰트 import 관련 내용 꼼꼼히 챙기시면 한결 깔끔하고 최신 기능을 활용할 수 있습니다!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js 13으로 업그레이드하면서 이미지 처리 방식이 조금 바뀌었는데요, 기존에 Next.js 10, 11, 12에서 쓰던 `next/image`를 `next/legacy/image`로 변경해주는 작업이 필요해요. 직접 프로젝트를 수정하기 부담스럽다면, `@next/codemod`라는 도구를 활용하면 자동으로 바꿔줄 수 있답니다.\n\n예를 들어, 아래 명령어를 터미널에 입력하면 프로젝트 내 `next/image` import 코드를 `next/legacy/image`로 바꾸고, `next/future/image`는 `next/image`로 안전하게 변경해줘요.\n\n```bash\nnpx @next/codemod@latest next-image-to-legacy-image .\n```\n\n즉, 이런 코드가\n\n```js\nimport Image1 from \"next/image\";\nimport Image2 from \"next/future/image\";\n\nexport default function Home() {\n  return (\n    <div>\n      <Image1 src=\"/test.jpg\" width=\"200\" height=\"300\" />\n      <Image2 src=\"/test.png\" width=\"500\" height=\"400\" />\n    </div>\n  );\n}\n```\n\n자동으로 이렇게 바뀌는 거죠.\n\n```js\nimport Image1 from \"next/legacy/image\";\nimport Image2 from \"next/image\";\n\nexport default function Home() {\n  return (\n    <div>\n      <Image1 src=\"/test.jpg\" width=\"200\" height=\"300\" />\n      <Image2 src=\"/test.png\" width=\"500\" height=\"400\" />\n    </div>\n  );\n}\n```\n\n---\n\n### 왜 이런 변경이 필요할까요?\n\nNext.js 13부터 이미지 컴포넌트가 크게 개선되면서 새 API가 도입됐어요. 그런데 바로 기존 코드 전부 바꾸기엔 위험 부담이 있어, 기존 `next/image` 기능을 그대로 유지하고 싶으면 `next/legacy/image`를 써야 해요. 따라서 자동 도구를 이용해 한 번에 쉽게 바꾸는 게 편리하답니다.\n\n---\n\n### 참고로 알아두면 좋은 점\n\n- `npx`로 실행하면 별도 설치 없이 최신 버전의 codemod 스크립트를 쓸 수 있어요.\n- 소스코드가 많은 프로젝트라면 백업을 꼭 해두고, 변경 후 빌드와 테스트를 꼼꼼히 확인하세요.\n- codemod 외에도 직접 코드를 리팩토링하며 Next.js 13의 새로운 이미지 기능(`next/image`의 새로운 API)을 학습해보는 것도 좋아요.\n\n---\n\n필요하다면 다음에 Next.js 13의 새로운 이미지 컴포넌트 사용법도 정리해볼게요! 궁금한 점 있으면 언제든 질문해주세요 :)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래처럼 `next/image`를 'next/legacy/image'로 바꾸고, 'next/future/image'는 'next/image'로 바꾸는 예시 코드입니다.\n\n```js\n// 'next/image'는 'next/legacy/image'로 변경합니다\nimport Image1 from \"next/legacy/image\";\n// 'next/future/image'는 'next/image'로 변경합니다\nimport Image2 from \"next/image\";\n\nexport default function Home() {\n  return (\n    <div>\n      <Image1 src=\"/test.jpg\" width=\"200\" height=\"300\" />\n      <Image2 src=\"/test.png\" width=\"500\" height=\"400\" />\n    </div>\n  );\n}\n```\n\n그리고 이 작업을 좀 더 자동화하고 싶다면, Next.js에서 제공하는 코드 변환 도구(codemod)를 이용할 수 있는데요, 터미널에서 다음 커맨드만 실행하면 됩니다.\n\n```bash\nnpx @next/codemod@latest next-image-experimental .\n```\n\n이 명령어는 현재 디렉토리(.) 안의 파일들에 대해 'next/image' 관련 변환을 일괄적으로 적용해 줍니다.\n\n---\n\n**조금 더 팁을 드리자면,** Next.js 13부터 이미지 컴포넌트가 더 발전하면서 기존 방식에서 새로운 방식으로 전환하는 게 권장되고 있어요. 새로운 `next/image`는 향상된 성능과 더 편리한 사용성을 제공하기 때문에 가능하면 자동 변환 도구를 활용해서 마이그레이션을 해보시길 추천해요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서 이미지 컴포넌트를 옛날 방식인 `next/legacy/image`에서 새롭게 개선된 `next/image`로 마이그레이션할 때, 주의할 점들을 정리해볼게요. 단, 여기서 소개하는 방법은 스타일을 인라인으로 덧붙이고 필요 없는 props들은 아예 없애는 방식이라, 사용하면서 조금 더 세밀한 조정이 필요할 수 있다는 점 참고하세요.\n\n---\n\n### 1. `layout` prop 제거 후 `style`로 대체하기\n\n예전에는 `layout`이라는 prop로 이미지 크기와 위치를 조절했다면, 이제는 CSS 스타일을 직접 주는 형태로 바뀌었어요.  \n예를 들어,\n\n```jsx\n// 예전 방식\n<Image src=\"/example.png\" layout=\"fill\" />\n\n// 새로운 방식\n<Image src=\"/example.png\" style={{ width: '100%', height: '100%' }} />\n```\n\n---\n\n### 2. `objectFit` 함수 대체하기\n\n`objectFit`도 이제 스타일로 주는 게 기본이에요.\n\n```jsx\n// 예전 방식\n<Image src=\"/example.png\" objectFit=\"cover\" />\n\n// 새로운 방식\n<Image src=\"/example.png\" style={{ objectFit: 'cover' }} />\n```\n\n---\n\n### 3. `objectPosition`도 `style`로 옮기기\n\n위치 조정도 똑같이 스타일로 바꿔주세요.\n\n```jsx\n// 예전 방식\n<Image src=\"/example.png\" objectPosition=\"center center\" />\n\n// 새로운 방식\n<Image src=\"/example.png\" style={{ objectPosition: 'center center' }} />\n```\n\n---\n\n### 4. `lazyBoundary`와 `lazyRoot` 제거하기\n\n이제 `lazyBoundary`나 `lazyRoot` 프로퍼티는 쓰지 않아요. Next.js가 내부적으로 최적화해주기 때문인데요, 대신 Intersection Observer 같은 커스텀한 지연 로딩이 필요하면 별도로 구현해야 합니다.\n\n---\n\n### 5. Link 컴포넌트에서 `a` 태그 제거하기\n\nNext.js 13부터는 Link 컴포넌트 내부에 `a` 태그를 직접 넣을 필요가 없어졌어요.  \n자동으로 링크 역할을 하도록 개선돼서, 기존 코드에 이런 식으로 중복 `a` 태그가 있다면 정리해주는 코드를 실행해보세요.\n\n```bash\nnpx @next/codemod@latest new-link .\n```\n\n한 번 실행하면 프로젝트 전체에 걸쳐 자동으로 바뀝니다!\n\n---\n\n### 추가 팁!\n\n- **인라인 스타일 대신 CSS 클래스 사용**  \n  인라인 스타일이 너무 많이 들어가면 유지보수가 어렵고, 스타일 수정이 귀찮아질 수 있어요. 가능하면 CSS 모듈이나 styled-components 같은 CSS-in-JS를 활용하기도 해보세요.\n\n- **이미지 최적화 재확인**  \n  마이그레이션 후에는 반드시 이미지로드와 관련된 퍼포먼스, 반응형 처리, 레이지 로딩이 제대로 동작하는지 확인하는 게 좋아요.\n\n- **Next.js 버전 요구사항**  \n  새로운 `next/image` 기능은 Next.js 13 이상의 버전에서 확실히 안정적이니, 버전 업그레이드도 같이 고민해보길 추천해요.\n\n---\n\n마이그레이션은 한 번에 두려울 수 있지만, 잘 따라가면 성능과 유지보수 측면에서 분명 이점이 있으니 꼭 적용해보세요!  \n궁금한 점 있으면 언제든지 알려주세요~ :D\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서 `<Link>` 컴포넌트를 사용할 때, 내부에 `<a>` 태그를 중복으로 감싸는 패턴을 고쳐야 하는 경우가 생겼어요. 예전에는 이렇게 썼었죠:\n\n```jsx\n<Link href=\"/about\">\n  <a>About</a>\n</Link>\n```\n\n그런데 최신 Next.js 버전에서는 `<Link>`가 자동으로 `<a>` 태그 역할을 하니까, 불필요한 `<a>`를 제거해주는 게 좋아요. 위 코드는 이렇게 바뀌게 됩니다:\n\n```jsx\n<Link href=\"/about\">About</Link>\n```\n\n만약 `<a>` 태그에 클릭 이벤트 같은 특별한 핸들러를 달아놨다면? 이렇게 말이죠:\n\n```jsx\n<Link href=\"/about\">\n  <a onClick={() => console.log(\"clicked\")}>About</a>\n</Link>\n```\n\n이 경우에도 `<a>` 태그를 없애고, 대신 `<Link>` 컴포넌트에 이벤트를 옮겨줍니다:\n\n```jsx\n<Link href=\"/about\" onClick={() => console.log(\"clicked\")}>\n  About\n</Link>\n```\n\n근데, 모든 상황에서 자동으로 수정하는 게 안 되는 경우도 있어요. 이럴 때는 `legacyBehavior`라는 속성을 `<Link>`에 붙여주면, 기존 방식으로 동작하게 만들어서 문제없이 앱이 돌아가게 할 수 있습니다.\n\n쉽게 정리해 보면,\n\n| 상황                         | 처리 방법                          |\n| ---------------------------- | ---------------------------------- |\n| 일반적인 링크                | `<a>` 태그 제거 후 텍스트만 남기기 |\n| 이벤트 등 핸들러가 있는 경우 | 핸들러를 `<Link>`로 옮기기         |\n| 자동 수정 불가능한 경우      | `<Link legacyBehavior>` 사용       |\n\n### 추가 팁\n\n- 꼭 `<a>` 태그를 안 써야 좋은 것만은 아니에요! SEO나 스타일링 목적상 `<a>`가 필요한 상황도 있죠. 하지만 Next.js 13 이후로는 내부 `<a>` 없이 바로 `<Link>`만 써도 `<a>` 태그처럼 동작하기 때문에, 코드가 조금 더 깔끔해집니다.\n- 만약 프로젝트에 이미 `<a>`가 안고쳐져 있는 게 많다면 `legacyBehavior`를 우선 써두고, 점차 코드 리팩토링하면서 `<a>` 태그를 제거하는 방식을 추천드려요. 이렇게 하면 급작스러운 에러 없이 마이그레이션 할 수 있으니까요!\n\nNext.js 업데이트나 마이그레이션 할 때 자주 보게 되는 이슈니까, 위 내용 꼭 기억해 두세요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n자, 이번에는 Next.js에서 컴포넌트와 링크 처리 방식에 관한 내용을 살펴볼게요.\n\n```js\nconst Component = () => <a>About</a>\n\n<Link href=\"/about\">\n  <Component />\n</Link>\n// 이렇게 작성한 코드는\n<Link href=\"/about\" legacyBehavior>\n  <Component />\n</Link>\n```\n\n위 코드를 보면 `Link` 컴포넌트 안에 `<a>` 태그를 직접 포함한 `Component`를 넣었을 때, Next.js 13 등 최신 버전에서는 `legacyBehavior` 속성을 추가해줘야 한다고 알려줍니다.\n\n이게 왜 필요하냐면, Next.js가 이전 버전까지는 `Link` 내부에 `<a>` 태그를 감싸는 구조였어요. 그런데 최신 버전에서는 `Link` 자체가 `<a>` 태그 역할을 하도록 변경되었기 때문에, 기존 스타일의 링크를 유지하고 싶으면 `legacyBehavior`를 꼭 명시해줘야 한답니다.\n\n즉, 만약 기존에 `<Link><a>...</a></Link>` 구조를 쓰고 있었다면 그냥 넘어가지 말고, 다음처럼 바꾸는 게 좋겠죠?\n\n```jsx\n<Link href=\"/about\" legacyBehavior>\n  <Component />\n</Link>\n```\n\n이렇게 하면 빌드나 렌더링 시에 발생할 수 있는 문제를 방지할 수 있습니다!\n\n---\n\n### CRA(create-react-app)에서 Next.js로 마이그레이션할 때 참고할 점\n\n이 부분도 아주 유용해요. CRA에서 Next.js로 프로젝트를 옮기고 싶을 때, 직접 하나하나 이전하기는 번거로운데요. Next.js 공식에서 제공하는 codemod 툴을 활용하면 훨씬 수월해집니다.\n\n```bash\nnpx @next/codemod cra-to-next\n```\n\n이 명령어를 실행하면, CRA 스타일의 파일들을 Next.js가 이해하는 형식으로 자동 변환해줘요. 예를 들어, `index.js`를 `pages/index.js`로 옮기거나, 라우팅 관련 코드를 Next.js 스타일로 바꾸는 작업들이 포함됩니다.\n\n참고로, 이 도구는 완벽하지 않기 때문에 변환 후에는 반드시 결과물을 꼼꼼히 확인하고, 특히 커스텀 로직이나 특정 라이브러리 통합 부분은 수동으로 수정해줘야 해요!\n\n---\n\n### 개인적으로 한 마디\n\nNext.js가 계속 발전하면서 내부 구조가 조금씩 달라지고 있어요. 그래서 예전 코드를 최신 버전에 맞추려면 가끔 이런 변화를 이해하고 따라가는 게 중요합니다. 특히 라우팅, 링크 처리, 페이지 구조 등 기본 골격에 관련된 부분은 더더욱 그렇죠.\n\n그리고 마이그레이션은 시간도 많이 들고 까다로운 작업이니, 꼭 핵심 부분부터 단계별로 차근차근 접근해보세요. 항상 작은 단위로 테스트하면서 진행하는 게 실패 확률을 낮출 수 있는 비결입니다!\n\n혹시 이런 과정에서 궁금한 점이나 문제가 생기면, 꼭 커뮤니티나 공식 문서를 참고하고 질문하는 것도 좋은 방법입니다. 개발은 혼자가 아니라 같이 성장하는 과정이니까요. 화이팅! 🎉\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nCreate React App 프로젝트를 Next.js로 마이그레이션하면서, 기존 동작 방식을 유지하기 위해 Pages Router와 필요한 설정을 만들어줍니다. 초기에는 서버 사이드 렌더링(SSR) 시 window 객체 사용으로 인한 호환성 문제를 피하기 위해 클라이언트 사이드 렌더링만 사용하게끔 구현되어 있는데요. 이렇게 하면 Next.js의 고유 기능을 점진적으로 도입하기 쉽죠.\n\n이 과정에서 React import문을 추가하는 작업이 포함되어 있습니다. Next.js에서는 자동으로 React를 임포트하지 않으니, 컴포넌트 내에서 React 관련 내용을 쓸 때는 import문을 꼭 넣어줘야 해요.\n\n만약 이 변환 작업에 대해 의견이나 피드백이 있다면, 이 토론에서 자유롭게 나눠주세요!\n\n추가로, Next.js로 전환 시 `pages` 폴더 구조를 활용하는데, 이는 라우팅이 파일 시스템 기반으로 이루어져 관리가 편하고, 서버 사이드 렌더링, 정적 생성 등 다양한 렌더링 방식을 쉽게 적용할 수 있어요. 그리고 점차적으로 기존 CRA에서 벗어나 Next.js의 SSR, SSG 기능을 사용해 보면서 좀 더 최적화된 앱을 만들어 볼 수 있답니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이번에 소개할 명령어는 Next.js 프로젝트에서 React import 구문이 빠진 파일에 자동으로 import 구문을 추가해주는 `@next/codemod`의 `add-missing-react-import`입니다.\n\n```bash\nnpx @next/codemod add-missing-react-import\n```\n\n이 명령어를 실행하면, React를 import하지 않은 파일에 React import 구문이 추가됩니다. 이유는 최신 React JSX 변환 방식에서 명시적으로 React import가 필요하기 때문인데요, 예를 들어 아래와 같은 클래스 컴포넌트가 있다고 합시다:\n\n```js\nexport default class Home extends React.Component {\n  render() {\n    return <div>Hello World</div>;\n  }\n}\n```\n\n위 코드는 React를 import하지 않았기 때문에 컴파일 에러가 날 수 있어요. 이럴 때 `add-missing-react-import`를 돌리면 자동으로 다음과 같이 변환해줍니다:\n\n```js\nimport React from \"react\";\n\nexport default class Home extends React.Component {\n  render() {\n    return <div>Hello World</div>;\n  }\n}\n```\n\n요즘 Next.js와 React 17 이상의 JSX 변환 로직에서는 React를 import하지 않아도 되는 경우가 많지만, 레거시 코드나 일부 환경에서는 여전히 import 구문이 필요하거든요. 특히 클래스 컴포넌트처럼 React를 직접 참조하는 컴포넌트라면 꼭 import를 해줘야 합니다.\n\n한 가지 팁을 드리자면, `@next/codemod`에는 다른 유용한 코드 변환 도구들도 많으니 프로젝트 마이그레이션이나 정리할 때 사용해보면 좋습니다.\n\n요약하자면:\n\n| 명령어                                       | 설명                                 |\n| -------------------------------------------- | ------------------------------------ |\n| `npx @next/codemod add-missing-react-import` | React import가 없는 파일에 자동 추가 |\n\n이렇게 간단하게 대규모 코드에서 빠진 import를 일괄 처리할 수 있으니 꼭 알아두세요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여러분, 리액트 컴포넌트를 작성할 때 익명 컴포넌트(Anonymous Components)를 이름 있는 컴포넌트(Named Components)로 바꾸는 작업은 꽤 중요한 포인트예요. 코드의 가독성도 좋아지고, 디버깅할 때 스택 트레이스에서 컴포넌트 이름이 잘 보이니까 문제 추적이 훨씬 수월해지거든요.\n\n예를 들어, 아래처럼 익명 함수형 컴포넌트를 쓴다고 해봅시다.\n\n```jsx\nexport default () => <div>Hello World</div>;\n```\n\n이걸 이름 있는 함수형 컴포넌트로 바꿔주면\n\n```jsx\nconst Home = () => <div>Hello World</div>;\nexport default Home;\n```\n\n더 나아가, 클래스 컴포넌트도 익명 클래스를 이름 있는 클래스로 변환하는 게 좋아요. 처음에 주신 코드를 보면:\n\n```jsx\nimport React from \"react\";\n\nexport default class Home extends React.Component {\n  render() {\n    return <div>Hello World</div>;\n  }\n}\n```\n\n지금 이미 이름 있는 클래스 컴포넌트로 잘 작성된 상태죠? 이렇게 하면 나중에 개발자 도구에서도 'Home'이라는 이름이 뜨니까, 문제 생겼을 때 찾기 쉽고 유지보수하기도 편해집니다.\n\n실제로 익명으로 쓰면 이런 장점이 사라지니 꼭 이름 붙이시는 걸 추천드려요.\n\n---\n\n### 익명 컴포넌트 vs 이름 있는 컴포넌트 제일 중요한 차이점\n\n| 구분               | 익명 컴포넌트  | 이름 있는 컴포넌트 |\n| ------------------ | -------------- | ------------------ |\n| 디버깅 편의성      | 낮음           | 높음               |\n| 가독성             | 떨어짐         | 좋음               |\n| 재사용 및 유지보수 | 모호할 수 있음 | 명확함             |\n\n---\n\n마지막 팁 하나 더 드리자면, 컴포넌트를 이름 있게 만들고 `displayName` 속성을 직접 지정해주면 리액트 개발자 도구에서 더 명확한 이름으로 확인할 수 있어요. 함수형 컴포넌트에선 이렇게 하죠:\n\n```jsx\nconst Home = () => <div>Hello World</div>;\nHome.displayName = \"Home\";\nexport default Home;\n```\n\n이제 익명 컴포넌트 쓸 때보다 훨씬 편리하겠죠? 오늘은 이 정도로 정리할게요. 다음에 또 유용한 리액트 팁으로 찾아뵙겠습니다~\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안녕하세요! 오늘은 Next.js 9버전 이상부터 사용할 수 있는 아주 유용한 명령어에 대해 이야기해볼게요.\n\n```bash\nnpx @next/codemod name-default-component\n```\n\n이 명령어는 여러분이 작성한 익명(anonymous) 컴포넌트를 '이름 있는(named)' 컴포넌트로 자동 변환해줘요.\n\n왜 이게 중요하냐면?  \nNext.js 9부터 도입된 **Fast Refresh** 기능이 익명 컴포넌트와 잘 작동하지 않는 경우가 있거든요. Fast Refresh는 여러분이 코드를 수정했을 때 빠르게 변경 사항을 브라우저에 반영해주는 기능이에요. 만약 컴포넌트가 익명이면 이 기능이 제대로 동작하지 않을 수 있어요.\n\n그래서 이 codemod를 실행하면 모든 익명 컴포넌트들을 이름 있는 컴포넌트로 바꿔줘서 Fast Refresh가 안정적으로 작동하게 도와줍니다.\n\n### 간단한 예시\n\n```jsx\n// 변환 전 (익명 컴포넌트)\nexport default () => <div>Hello World</div>;\n\n// 변환 후 (이름 있는 컴포넌트)\nconst MyComponent = () => <div>Hello World</div>;\nexport default MyComponent;\n```\n\n이렇게 이름 붙여주면 어떤 컴포넌트인지 더 명확해지고, 디버깅도 조금 더 편해집니다.\n\n---\n\n### 추가 팁!\n\n- **Fast Refresh**를 제대로 활용하려면 JSX 코드가 명확한 컴포넌트 정의 방식을 따르는 게 좋아요.\n- 익명 함수 대신 꼭 이름이 있는 함수나 변수로 컴포넌트를 작성하는 습관을 들이면, 코드 관리가 더 수월해집니다.\n- 만약 여러분 프로젝트에 익명 컴포넌트가 많다면 위 codemod 실행 한번 해보세요. 자동으로 변환해줘서 시간을 많이 절약할 수 있습니다.\n\n오늘은 여기까지입니다! 다음에도 개발 관련 꿀팁 들고 올게요~ 😄\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nexport default function MyComponent() {\n  return <div>Hello World</div>;\n}\n```\n\n위 코드는 파일 이름을 참고해 컴포넌트 이름을 카멜케이스(camelCase) 형식으로 자동으로 붙여주는 변환 예시입니다. 함수형 컴포넌트에 이름이 없으면, React 개발 도구나 디버깅 시 컴포넌트 이름을 바로 확인하기 어렵기 때문에 이런 변환을 해주는 게 좋아요.\n\n또한, 이 방법은 화살표 함수(Arrow Function) 컴포넌트에도 동일하게 적용됩니다. 예를 들어:\n\n```js\nconst MyComponent = () => {\n  return <div>Hello World</div>;\n};\nexport default MyComponent;\n```\n\n위처럼 작성하면 함수 이름이 명확해져서 컴포넌트 관리가 훨씬 편해집니다. 혹시 파일명이 `my-component.jsx`라면, 보통 `MyComponent`처럼 변환하면 되고, 이런 자동화는 빌드 도구(예: Babel plugin)나 에디터 확장 기능을 통해 쉽게 할 수 있어요.\n\n요약하자면,\n\n- 무명 함수형 컴포넌트는 디버깅 시 불편하니 꼭 이름을 붙여주세요.\n- 이름은 파일 이름을 참고해서 카멜케이스로 자동 변환하는 게 일반적입니다.\n- 화살표 함수 컴포넌트에도 적용 가능해서 일관된 네이밍이 가능합니다.\n\n이렇게 하면 코드 품질과 유지보수성이 한층 좋아지니 꼭 기억해두세요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 8\n\n#### AMP HOC를 페이지 설정으로 변환하기\n\nNext.js에서 AMP 페이지를 만들 때 `withAmp` HOC(high-order component)를 사용하는 경우가 있는데요. Next.js 9부터는 이 방법 대신 페이지 설정을 통해 AMP를 지정할 수 있도록 업데이트되었어요.\n\n간단하게 커맨드 한 줄로 기존에 `withAmp`를 쓰던 코드를 페이지 설정으로 변환할 수 있습니다.\n\n```bash\nnpx @next/codemod withamp-to-config\n```\n\n이 명령어를 실행하면 자동으로 `withAmp` HOC를 제거하고 대신 `export const config = { amp: true }` 같은 페이지 설정으로 변환해 줍니다.\n\n---\n\n> 참고!  \n> AMP 페이지를 이렇게 설정하면 유지보수도 편해지고, 코드가 더 깔끔해져 장기적으로 좋습니다.  \n> 그리고 다음 Next.js 버전에서는 `withAmp` 지원이 줄어들 수 있으니 미리 적용해 두면 좋아요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 예시는 Next.js에서 AMP (Accelerated Mobile Pages) 페이지를 만드는 방식이 업데이트된 것을 보여주고 있어요.\n\n예전에는 `withAmp`라는 HOC(Higher-Order Component)를 사용해서 AMP 페이지를 만들었는데요, 이제는 이 방법을 대체하는 새로운 문법이 도입되었답니다.\n\n기존 코드는 이렇게 생겼었죠:\n\n```js\n// Before\nimport { withAmp } from \"next/amp\";\n\nfunction Home() {\n  return <h1>My AMP Page</h1>;\n}\n\nexport default withAmp(Home);\n```\n\n`withAmp`로 컴포넌트를 감싸 AMP 페이지임을 표시했어요.\n\n하지만 최신 Next.js 버전에서는 `withAmp` 대신에 함수형 컴포넌트 자체를 export하고, 별도로 `config` 객체에서 `amp: true` 설정을 해주면 됩니다:\n\n```js\n// After\nexport default function Home() {\n  return <h1>My AMP Page</h1>;\n}\n\nexport const config = {\n  amp: true,\n};\n```\n\n이렇게 바뀌면서 코드가 훨씬 깔끔해졌고, Next.js가 AMP 페이지를 더 명확하고 쉽게 인식할 수 있게 되었어요.\n\n---\n\n### AMP 페이지 만드는 법 간단 요약\n\n| 예전 방식 (before)                   | 최신 방식 (after)                          |\n| ------------------------------------ | ------------------------------------------ |\n| `import { withAmp } from 'next/amp'` | `export const config = { amp: true }` 선언 |\n| `export default withAmp(Component)`  | `export default function Component() {}`   |\n\n---\n\n### 덧붙여서\n\n- AMP 페이지는 모바일 최적화와 빠른 로딩을 위한 기술인데, Next.js는 AMP 페이지를 따로 지원해줘서 개발자들이 쉽게 구현할 수 있어요.\n- 다만 AMP에서는 자바스크립트 사용이 제한적이고, 일부 컴포넌트 사용이 제약되니 해당 부분도 확인해 주세요.\n- Next.js의 AMP 관련 설정은 점점 개선되는 추세라 업데이트된 공식 문서도 자주 확인하는 게 좋아요!\n\n그럼 오늘도 즐거운 코딩 하세요! 🚀\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n#### withRouter 사용하기\n\nNext.js에서 예전에는 페이지 컴포넌트에 자동으로 `url`이라는 프로퍼티가 주어졌었는데, 이게 이제는 deprecated(더 이상 권장되지 않는) 되었어요. 대신 `withRouter`라는 HOC(Higher-Order Component)를 사용해서 `router`라는 프로퍼티를 직접 주입받도록 바뀌었답니다.\n\n만약 기존 코드에 `url` 프로퍼티를 쓰고 있다면, 다음 명령어 한 방으로 자동 변환도 가능해요.\n\n```bash\nnpx @next/codemod url-to-withrouter\n```\n\n이 코맨드는 페이지 컴포넌트에서 `url`을 사용하는 코드를 찾아서 `withRouter`를 씌우고, `router` 프로퍼티를 받도록 바꿔줘요.\n\n이제 간단히 예를 들어볼게요!\n\n```js\n// Before (deprecated)\nfunction Page({ url }) {\n  return <div>Current path: {url.pathname}</div>;\n}\n\nexport default Page;\n```\n\n```js\n// After (withRouter 사용)\nimport { withRouter } from \"next/router\";\n\nfunction Page({ router }) {\n  return <div>Current path: {router.pathname}</div>;\n}\n\nexport default withRouter(Page);\n```\n\n`withRouter`를 쓰면 `router` 안에 현재 경로, 쿼리, asPath 등 다양한 라우팅 정보를 손쉽게 가져올 수 있어 활용도가 높답니다.\n\n자세한 내용은 Next.js 공식 문서에서 확인해봐요:  \nhttps://nextjs.org/docs/messages/url-deprecated\n\n그리고 만약 함수형 컴포넌트에서 훅을 선호한다면, Next.js가 제공하는 `useRouter` 훅도 같이 알아두시면 좋아요!\n\n```js\nimport { useRouter } from \"next/router\";\n\nfunction Page() {\n  const router = useRouter();\n\n  return <div>Current path: {router.pathname}</div>;\n}\n\nexport default Page;\n```\n\n`withRouter` 대신 `useRouter`를 쓰면 훨씬 깔끔하고 현대적인 코드 작성이 가능하니, 새 프로젝트나 리팩토링 시 참고하세요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이번에 React와 Next.js에서 라우팅 정보를 가져오는 방식을 비교해봤어요. 두 코드 예시 모두 현재 URL 경로(pathname)를 화면에 보여주는 간단한 컴포넌트인데, Next.js가 버전 업데이트하면서 props로 라우터 정보를 직접 주던 방식에서 HOC인 withRouter를 사용하는 방식으로 바뀐 걸 볼 수 있죠.\n\n### 첫 번째 코드\n\n```jsx\nimport React from \"react\";\n\nexport default class extends React.Component {\n  render() {\n    const { pathname } = this.props.url;\n    return <div>Current pathname: {pathname}</div>;\n  }\n}\n```\n\n이 코드는 Next.js 6 이하 버전에서 주로 쓰이던 방식이에요. `this.props.url`에서 pathname을 바로 받아서 사용하고 있죠.\n\n### 두 번째 코드\n\n```jsx\nimport React from \"react\";\nimport { withRouter } from \"next/router\";\n\nexport default withRouter(\n  class extends React.Component {\n    render() {\n      const { pathname } = this.props.router;\n      return <div>Current pathname: {pathname}</div>;\n    }\n  }\n);\n```\n\n이건 Next.js 7 이상에서 권장하는 방식으로, `withRouter`라는 고차 컴포넌트를 이용해서 `this.props.router` 안에 라우터 정보를 넣어줘요. 덕분에 함수형 컴포넌트에서도 `useRouter` 훅과 마찬가지로 쉽게 라우터 데이터를 접근할 수 있게 되었습니다.\n\n---\n\n사실 최신 Next.js 프로젝트를 한다면 함수형 컴포넌트와 `useRouter` 훅을 쓰는 걸 추천해요. 예를 들면 이렇게요:\n\n```jsx\nimport { useRouter } from \"next/router\";\n\nexport default function MyComponent() {\n  const router = useRouter();\n  return <div>Current pathname: {router.pathname}</div>;\n}\n```\n\n이렇게 하면 코드도 훨씬 간결해지고, React의 함수형 컴포넌트 철학에도 잘 맞거든요.\n\n---\n\n이 외에도 여러 사례들이 `__testfixtures__`라는 디렉토리에 모여 있다고 하니, Next.js 라우팅 관련 코드를 바꾸거나 참고할 때 아주 좋은 자료가 될 거예요. 저도 이런 예시들을 직접 보면서 공부했답니다.\n\n필요하면 저도 `__testfixtures__` 디렉토리에서 참고한 내용들 중심으로 더 설명해 드릴게요!\n","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":43},{"title":"Next.js 15로 싱글 페이지 애플리케이션(SPA) 쉽게 만드는 방법","description":"","date":"2025-04-22 01:38","slug":"2025-04-22-Howtobuildsingle-pageapplicationswithNextjs","content":"\n\n# Next.js로 싱글 페이지 애플리케이션(SPA) 만들기\n\nNext.js는 싱글 페이지 애플리케이션(SPA) 구축을 완벽하게 지원해요.\n\n빠른 라우트 전환을 위한 사전 페칭(prefetching), 클라이언트 쪽 데이터 가져오기, 브라우저 API 활용하기, 타사 클라이언트 라이브러리 연동, 정적 라우트 생성 등 다양한 기능이 다 포함되어 있죠.\n\n만약 이미 SPA를 가지고 있다면, Next.js로 마이그레이션할 때 코드에 큰 변화를 줄 필요 없이 진행할 수 있어요. 그리고 필요에 따라 서버 기능을 점진적으로 추가해 나갈 수 있다는 점도 큰 장점입니다.\n\n추가로, Next.js는 기본적으로 페이지 기반 라우팅 시스템을 제공해서, 라우트 관리를 훨씬 간편하게 할 수 있어요. React를 잘 다뤄왔다면 Next.js로 넘어오는 과정도 아주 자연스럽게 느껴질 거예요.\n\nSPA를 만들 때 자주 고민하는 SEO 문제도 Next.js가 서버 사이드 렌더링(SSR)이나 정적 사이트 생성(SSG)을 지원하기 때문에 훨씬 수월하게 해결할 수 있답니다. 그래서 성능과 UX, SEO 모두 신경 써야 하는 프로젝트에 정말 적합하죠!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## SPA(싱글 페이지 애플리케이션)이란?\n\n사실 SPA의 정의는 사람마다 조금씩 달라요. 여기서는 “엄격한 SPA” 기준으로 설명해볼게요.\n\n- **클라이언트 사이드 렌더링(CSR)**: 앱이 한 개의 HTML 파일(보통 index.html)로 제공돼요. 다른 페이지로 이동하거나, 화면 전환, 데이터 요청 등 모든 것이 브라우저 안에서 자바스크립트가 처리해요.\n- **전체 페이지 새로고침 없음**: 새로운 페이지를 서버에서 받아오는 대신, 현재 페이지의 DOM(문서 구조)를 자바스크립트가 바꿔주고, 필요한 데이터만 따로 받아와서 화면에 보여줘요.\n\n즉, SPA는 한 번 페이지가 로드되면, 이후에는 전체 페이지 리로드 없이 화면이 바뀌는 웹 앱이라고 보면 돼요.\n\n---\n\n### 그런데 왜 엄격한 SPA는 어려울까?\n\nSPA는 로딩 초반에 많은 자바스크립트를 한꺼번에 내려받아야 해서, 페이지가 제대로 인터랙티브해지기까지 시간이 걸릴 수 있어요. 그리고 클라이언트에서 데이터를 요청하는 순서, 즉 데이터 ‘워터폴’ 문제도 발생할 수 있는데, 이게 길어지면 사용자 경험이 좋지 않을 수 있죠.\n\n이런 문제들을 개선하고 싶다면 Next.js 같은 프레임워크를 써보는 걸 추천해요. Next.js는 서버 사이드 렌더링(SSR)과 CSR을 적절히 섞어서 빠르고 효율적인 웹 앱 개발을 도와주거든요.\n\n---\n\n참고로, 요즘은 SSR, CSR, 그리고 정적 사이트 생성(SSG)까지 적절히 활용하며 사용자 경험과 SEO를 모두 챙기려는 시도가 많아지고 있어요. SPA라고 무조건 자바스크립트만 쓰는 게 아니라는 점도 꼭 기억하세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 왜 Next.js를 사용해서 SPA를 만들까?\n\nNext.js는 여러분이 작성한 JavaScript 코드를 자동으로 쪼개서(bundle splitting) 각각의 라우트마다 필요한 코드만 불러올 수 있게 해줘요. 덕분에 클라이언트 쪽에서는 쓸데없는 자바스크립트 코드를 안 불러와서 번들 크기도 줄고, 페이지 로딩 속도도 훨씬 빨라집니다.\n\n또, Next.js의 `next/link` 컴포넌트는 라우트를 미리 불러오는(prefetch) 기능을 갖고 있어서, 딱딱 끊기지 않는 부드러운 SPA의 빠른 페이지 전환을 경험할 수 있어요. 그뿐만 아니라 URL이 앱의 상태를 계속 담고 있어서, 공유하거나 북마크하기도 편해지죠.\n\n흥미로운 점은, Next.js는 처음부터 정적인 사이트로 시작할 수도 있고, 아무 서버 기능 없이 클라이언트 사이드에서만 렌더링되는 순수 SPA로도 사용할 수 있다는 거예요. 그런데 프로젝트가 점점 커지고 기능이 복잡해지면, 필요한 만큼만 서버 기능(예를 들어 React Server Components나 Server Actions 같은)을 점진적으로 도입할 수도 있어서 유연하답니다.\n\n---\n\n### 한눈에 보는 Next.js의 SPA 장점\n\n| 장점                   | 설명                                                                                 |\n|----------------------|------------------------------------------------------------------------------------|\n| 자동 코드 분할           | 각 페이지별로 필요한 자바스크립트만 로딩해서 번들 크기를 줄이고, 로딩 속도를 높임                     |\n| 라우트 프리패칭          | `next/link`가 미리 라우트를 불러와서 페이지 전환이 빠르고 부드러움                                   |\n| URL 기반 상태 유지       | SPA처럼 빠르면서도 URL에 상태가 포함되어 공유와 북마크가 쉬움                                         |\n| 유연한 서버 렌더링 지원    | 초기엔 정적 사이트나 클라이언트 렌더링 SPA로 시작 가능, 필요하면 점진적으로 서버 기능 추가 가능                |\n\n---\n\n간단히 말해, Next.js는 SPA의 좋은 점과 SSR(server-side rendering)의 장점을 절묘하게 섞어놨어요. 그래서 좀 더 규모가 큰 프로젝트에서 SPA를 관리하기에 훨씬 편하답니다. \n\n이런 장점 덕분에 요즘 많은 개발자들이 Next.js를 선택해 SPAs를 만들고 있어요! 혹시 Next.js로 SPA를 고민하고 있다면, 꼭 한번 써보라고 추천드리고 싶네요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 예시\n\n이번에는 SPA(싱글 페이지 애플리케이션)를 만들 때 자주 사용되는 패턴들을 살펴보고, Next.js가 이 문제들을 어떻게 해결하는지 함께 알아보도록 할게요.\n\n### React의 use 훅을 Context Provider 내에서 사용하기\n\n저희는 데이터를 가져올 때 보통 상위 컴포넌트(또는 레이아웃)에서 데이터를 불러오고, 그 결과로 Promise를 반환한 뒤, 하위 클라이언트 컴포넌트에서 React의 use 훅으로 그 값을 해제하는 방식을 추천해요.\n\n이 방법이 좋은 이유는, 데이터를 한 곳에서 통합 관리할 수 있고 컴포넌트 간에 쉽게 공유가 가능해진다는 점이에요. 또한 Next.js가 제공하는 서버 컴포넌트와 클라이언트 컴포넌트의 장점을 살릴 수 있어서 성능 최적화에도 도움이 된답니다.\n\n여기서 중요한 점은, 서버에서 데이터를 미리 불러오고 그 상태를 클라이언트에서 재사용할 수 있게 하는 흐름 덕분에 불필요한 중복 요청을 줄일 수 있고, 사용자 경험이 자연스럽게 개선된다는 것! 다음에 실제 예제도 함께 볼게요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js는 서버에서 데이터를 미리 가져오는 작업을 빨리 시작할 수 있어요. 예를 들어, 이걸 루트 레이아웃(root layout)에서 한다고 생각해보면, 애플리케이션의 시작점에서 서버가 곧바로 클라이언트에게 응답을 스트리밍할 수 있다는 뜻이죠.\n\n여기서 “데이터 fetching을 루트 레이아웃으로 끌어올린다(hoisting)”는 말은, Next.js가 앱 내 다른 어떤 컴포넌트보다 먼저 서버에서 데이터를 요청하게 만든다는 의미예요. 덕분에 클라이언트에서 서버로 여러 번 왕복하는 ‘워터폴 문제’를 없애고, 네트워크 호출도 줄여주죠. 또, 서버가 보통 데이터베이스와 가까운 위치에 있기에 성능 향상에도 큰 도움이 됩니다.\n\n예를 들어, 다음과 같이 루트 레이아웃에서 getUser() 함수를 호출하지만, await 하지 않고 바로 Promise를 넘겨줄 수 있어요.\n\n```jsx\nimport { UserProvider } from './user-provider'\nimport { getUser } from './user' // 서버 사이드 함수\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  let userPromise = getUser() // 여기서 await 하지 않아요\n\n  return (\n    <html lang=\"en\">\n      <body>\n        <UserProvider userPromise={userPromise}>{children}</UserProvider>\n      </body>\n    </html>\n  )\n}\n```\n\n이렇게 하면 UserProvider 같은 하위 컴포넌트에서 Promise를 필요할 때까지 기다렸다가 데이터를 가져올 수 있죠. 이 패턴 덕분에 서버는 상황에 맞게 데이터를 빠르고 효율적으로 준비할 수 있어요.\n\n> 참고로, Next.js 13부터 도입된 이 ‘룻트 레이아웃에서 데이터 fetching 미리 시작’ 방식은 React의 Suspense와도 잘 맞아서, 사용자 경험 개선에 큰 도움이 됩니다. 실제로 서버와 클라이언트의 역할을 명확히 분리하고, 렌더링 대기 프로세스도 자연스럽게 최적화해준답니다.\n\n혹시 데이터 fetching 타이밍이나 React Suspense에 대해 더 궁금하면 알려주세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n리액트에서 Promise를 클라이언트 컴포넌트에 prop으로 넘겨주는 패턴이 있어요. 특히, React context provider와 함께 사용하면 더 편리해지는데요. 이렇게 하면 커스텀 훅을 통해 클라이언트 컴포넌트 어디서든 쉽게 Promise에 접근할 수 있거든요.\n\n예를 들어, User 정보를 담고 있는 Promise를 React context provider에 전달하는 코드를 한번 볼게요:\n\n```jsx\n'use client';\n\nimport { createContext, useContext, ReactNode } from 'react';\n\ntype User = any;\ntype UserContextType = {\n  userPromise: Promise<User | null>;\n};\n\nconst UserContext = createContext<UserContextType | null>(null);\n\nexport function useUser(): UserContextType {\n  const context = useContext(UserContext);\n  if (!context) {\n    throw new Error('useUser는 UserProvider 안에서만 사용해야 합니다.');\n  }\n  return context;\n}\n\nexport function UserProvider({\n  children,\n  userPromise\n}: {\n  children: ReactNode;\n  userPromise: Promise<User | null>;\n}) {\n  return (\n    <UserContext.Provider value={{ userPromise }}>\n      {children}\n    </UserContext.Provider>\n  );\n}\n```\n\n조금 더 설명을 덧붙이자면, UserProvider 컴포넌트는 userPromise를 받아서 context에 세팅해주고, useUser라는 커스텀 훅으로 이 Promise를 쉽게 사용할 수 있도록 도와줘요.\n\n마지막으로 클라이언트 컴포넌트 내에서 useUser 훅을 호출한 다음 Promise를 풀어내는 방식은 이렇습니다:\n\n```jsx\n'use client';\n\nimport { useEffect, useState } from 'react';\nimport { useUser } from './UserProvider';\n\nexport default function UserProfile() {\n  const { userPromise } = useUser();\n  const [user, setUser] = useState(null);\n\n  useEffect(() => {\n    userPromise.then(setUser);\n  }, [userPromise]);\n\n  if (!user) return <div>로딩 중...</div>;\n\n  return <div>안녕하세요, {user.name}님!</div>;\n}\n```\n\n여기서 핵심은, context를 통해 Promise를 전달받고 클라이언트 컴포넌트가 그 Promise를 풀어서 사용자 데이터를 받아온다는 점이에요. 이렇게 하면 데이터 fetching과 상태 관리가 깔끔하게 분리되면서 유지보수도 수월해집니다.\n\n추가 팁을 드리자면, 이 패턴은 서버에서 데이터를 미리 준비해서 클라이언트로 넘길 때도 유용해요. Next.js 같은 프레임워크에서 서버 컴포넌트가 데이터를 fetch하고 Promise를 클라이언트 컴포넌트로 넘기는 구조에 잘 어울립니다. 그러면 클라이언트에서는 loading 상태 관리나 데이터 fetching 코드를 간단히 처리할 수 있죠.\n\n요약하자면:\n\n| 장점 | 설명 |\n| --- | --- |\n| Context + Promise | 여러 컴포넌트에서 같은 Promise 접근 가능 |\n| 커스텀 훅 활용 | 사용하기 편하고, 오류 관리도 쉬움 |\n| 클라이언트 상태 관리 | Promise 풀어서 상태로 관리 가능 |\n| 서버 - 클라이언트 연동 | 서버에서 데이터 준비 → 클라이언트에서 깔끔하게 소비 |\n\n이 패턴을 프로젝트에 적용해보시면 데이터 흐름이 훨씬 명확해지는 걸 느끼실 거예요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여러분, 리액트에서 비동기 데이터를 다룰 때 `use` 훅을 사용해보셨나요? 예를 들어, 위 코드처럼 `userPromise`를 `use(userPromise)`로 바로 받아서 사용할 수 있는데요, 이렇게 하면 컴포넌트가 데이터를 받을 때까지 ‘서스펜스(suspense)’ 상태가 됩니다.\n\n이게 무슨 말이냐면, 리액트가 아직 데이터가 준비되지 않았을 때는 화면 일부를 잠시 렌더링하지 않고 기다렸다가, 데이터가 준비되면 그 부분만 다시 렌더링하는 ‘부분 하이드레이션(partial hydration)’을 할 수 있다는 거예요. 덕분에 페이지가 완전히 로드되기 전이라도 서버에서 미리 스트리밍한 HTML을 받아서 빠르게 화면을 보여주고, 나중에 자바스크립트가 로드되면 필요한 부분만 채워 넣는 거죠.\n\n---\n\n### SWR과 함께하는 SPA 데이터 패칭\n\n그리고 한편으론, SPA 환경에서 데이터를 불러오는 작업이 자주 필요하죠? 여기서 SWR이라는 React 라이브러리가 정말 많이 쓰입니다. SWR은 ‘stale-while-revalidate’의 약자로, 데이터를 캐시해두고 백그라운드에서 재검증하는 방식을 채택해 사용자 경험을 극대화해요.\n\n예를 들어, 여러분이 어떤 API를 호출해 데이터를 받으면, SWR은 기존 데이터를 먼저 보여주면서 동시에 최신 데이터를 받아 업데이트를 시도합니다. 이렇게 하면 화면이 번쩍이는 걸 막고, 항상 최신 데이터도 유지할 수 있죠. React의 최신 기능인 ‘서스펜스’와도 잘 어울려서, 점점 더 자연스럽게 비동기 데이터를 처리할 수 있게 되었습니다.\n\n---\n\n간단 정리하자면:\n\n| 기능              | 설명                                                      |\n|-------------------|---------------------------------------------------------|\n| `use` 훅           | Promise를 바로 받아서 처리, 컴포넌트 서스펜스 상태 관리          |\n| 부분 하이드레이션   | 서버에서 미리 렌더링한 HTML을 보여주고, 필요한 부분만 자바스크립트로 채우기 |\n| SWR               | 데이터 캐싱 & 백그라운드 갱신으로 빠르고 최신 데이터 제공             |\n\n앞으로 리액트에서 비동기와 데이터 페칭을 어떻게 효과적으로 다룰지 고민할 때, 이렇게 `use` 훅과 SWR 같은 도구들을 잘 활용하면 한결 수월해질 거예요! 궁금한 점 있으면 언제든 댓글로 알려주세요. :)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nSWR 2.3.0과 React 19+를 사용하면, 기존에 클라이언트에서 SWR로 데이터를 가져오던 코드를 점진적으로 서버 기능과 함께 사용해볼 수 있어요. 쉽게 말해, 위에서 말한 use() 패턴을 추상화한 거라고 보면 됩니다. 즉, 데이터 패칭을 클라이언트 쪽에서 하기도 하고 서버 쪽에서 하기도 하거나, 둘 다 섞어서 사용할 수 있다는 거죠!\n\n예를 들어,\n\n- 클라이언트 전용: `useSWR(key, fetcher)`  \n- 서버 전용: `useSWR(key)` + RSC(React Server Components)에서 제공하는 데이터  \n- 혼합 사용: `useSWR(key, fetcher)` + RSC 데이터  \n\n이렇게 다양하게 활용할 수 있습니다.\n\n실제 예제를 보면, 애플리케이션의 최상위 컴포넌트를 `SWRConfig` 컴포넌트로 감싸고 `fallback` 값을 넣어 서버에서 미리 데이터를 준비해두게 할 수 있어요.\n\n```jsx\nimport { SWRConfig } from 'swr'\nimport { getUser } from './user' // 서버 사이드 함수 예시\n\nexport default function RootLayout({ children }) {\n  return (\n    <SWRConfig\n      value={{\n        fallback: {\n          // 여기서 getUser() 결과를 바로 넘기는데,\n          // getUser()를 await 하지 않고 Promise 상태로 넘겨요.\n          // 그래야 실제로 이 데이터를 쓰는 컴포넌트가 렌더링될 때 suspend 하면서 데이터를 기다림\n          '/api/user': getUser(),\n        },\n      }}\n    >\n      {children}\n    </SWRConfig>\n  )\n}\n```\n\n여기서 중요한 포인트는 `getUser()`를 호출할 때 `await`를 하지 않는다는 점인데요. 이렇게 하면 컴포넌트에서 `useSWR('/api/user')`를 호출할 때, 서버에서 이미 준비된 Promise를 그대로 사용하게 되고, 해당 데이터가 준비될 때까지 React가 자동으로 대기(suspend)를 해줘요. 이게 React 19의 서버 컴포넌트와 SWR이 연동되는 굉장히 직관적이고 효율적인 방식입니다.\n\n---\n\n### SWR 2.3.0 & React 19+ 사용하는 팁!\n\n- 이 방식을 쓰면 서버 사이드 데이터 페칭과 클라이언트 사이드 리페칭을 자연스럽게 혼합 가능  \n- 클라이언트 캐시를 미리 서버에서 채우고 싶을 때 유용  \n- 서버 컴포넌트와 클라이언트 컴포넌트 혼합 환경에서 데이터 일관성 유지가 쉬워짐  \n- 성능 최적화에 큰 도움이 되며, 전체 페이지 로딩 UX 개선 가능!\n\n만약 SWR을 쓰고 있고 앞으로 React 19+ 서버 컴포넌트를 시도해보고 싶다면, 이번 버전부터 좀 더 매끄럽게 데이터 관리를 할 수 있으니 꼭 한번 시도해보세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n자, 이번에는 서버 컴포넌트와 클라이언트 컴포넌트 간에 데이터를 주고받을 때 SWR을 어떻게 깔끔하게 쓸 수 있는지 이야기해볼게요.\n\n---\n\n### 서버 컴포넌트에서 getUser() 함수 사용하기\n\n서버 컴포넌트에서는 `getUser()` 같은 함수를 이용해서 **쿠키, 헤더, DB 접근** 등을 안전하게 할 수 있어요. 이 말은 별도의 API 라우트를 만들 필요가 없다는 뜻이죠!\n\n즉, 서버에서 이미 사용자 데이터를 가져와서 그걸 클라이언트 컴포넌트에 바로 전달해줄 수 있다는 거예요.\n\n---\n\n### 클라이언트 컴포넌트에서 SWR로 데이터 재사용하기\n\n클라이언트 컴포넌트는 `SWRConfig` 하위에서 `useSWR()`을 호출할 때 이전에 서버에서 미리 받아온 사용자 데이터를 **fallback**으로 사용할 수 있어요. 이때 SWR를 쓰는 코드는 이전과 똑같이 쓸 수 있답니다.\n\n```js\n'use client'\n\nimport useSWR from 'swr'\n\nexport function Profile() {\n  const fetcher = (url) => fetch(url).then((res) => res.json())\n  // 기존에 쓰던 SWR 코드 그대로!\n  const { data, error } = useSWR('/api/user', fetcher)\n\n  return (\n    <div>\n      {error && <p>사용자 데이터를 불러오지 못했어요.</p>}\n      {!data ? <p>로딩중...</p> : <p>안녕하세요, {data.name}님!</p>}\n    </div>\n  )\n}\n```\n\n---\n\n### 미리 렌더링 된 fallback 데이터의 장점\n\n- 서버에서 데이터를 미리 받아서 **초기 HTML에 포함**시키기 때문에 화면이 빠르게 뜨고, SEO에도 유리해요.\n- 클라이언트에서 `useSWR`가 바로 이 fallback 데이터를 읽어서 재사용하고,\n- SWR의 **폴링, 재검증, 캐싱 기능**은 클라이언트 측에서 계속 잘 동작해 SPA 같은 인터랙티브한 경험을 제공해줘요.\n\n---\n\n### 번거로운 조건문은 이제 그만!\n\n이전에는 데이터를 가져오는 상태에 따라 `data === undefined`인지 체크하고 로딩 UI를 따로 처리해야 했지만, Next.js가 이제는 이런 fallback 데이터를 자동으로 관리해줘서 그런 조건문을 지워도 돼요.\n\n- 데이터가 로드되는 동안에는 가장 가까운 `Suspense` 경계가 알아서 작동해서 로딩 상태를 처리해주고,\n- 개발자는 UI 로직에만 집중할 수 있죠.\n\n---\n\n### 요약 정리\n\n| 항목                         | 설명                                                            |\n|----------------------------|---------------------------------------------------------------|\n| 서버 컴포넌트의 getUser() | 서버에서 안전하게 사용자 데이터를 가져와 바로 컴포넌트에 사용할 수 있음       |\n| 클라이언트 컴포넌트의 SWR | 서버에서 받은 데이터를 fallback으로 사용해 동일한 키로 데이터 재활용 가능      |\n| 초기 fallback 데이터         | 서버에서 미리 받아와 HTML에 포함 → 클라이언트가 즉시 활용, SEO & UX 모두 좋아짐 |\n| 개발 편의성                  | 데이터 undefined 체크 등 복잡한 로딩 처리 코드가 필요없음                    |\n\n---\n\n### 마지막 팁!\n\n몇 가지 참고하면 좋은 점들!\n\n- `SWRConfig`로 글로벌 설정을 해줄 때 `fallback` 데이터를 넘겨주면, 그 아래의 모든 컴포넌트에서 쉽게 같은 데이터를 쓸 수 있어요.\n- `Suspense`를 꽤 적극적으로 활용하면 로딩 상태 관리가 훨씬 깔끔해져요.\n- SWR은 기본적으로 클라이언트 전용이니, 서버에서 데이터를 미리 받아서 넘겨주는 형태가 매우 중요한 패턴이에요.\n\n---\n\n이렇게 서버와 클라이언트를 오가며 데이터를 매끄럽게 공유하면, 코드도 단순해지고 사용자에게 훨씬 부드러운 경험을 줄 수 있답니다. 다음 프로젝트에 꼭 적용해 보세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래 표는 SWR, RSC, 그리고 RSC + SWR 각각의 특징을 비교한 내용입니다. 체크 표시(✅)는 해당 기능을 지원한다는 의미이고, 엑스 표시(❌)는 지원하지 않음을 나타냅니다.\n\n| 기능                | SWR       | RSC       | RSC + SWR  |\n|---------------------|-----------|-----------|------------|\n| SSR 데이터           | ❌        | ✅        | ✅         |\n| SSR 중 스트리밍       | ❌        | ✅        | ✅         |\n| 요청 중복 제거        | ✅        | ✅        | ✅         |\n| 클라이언트 사이드 기능 | ✅        | ❌        | ✅         |\n\n- **SSR 데이터**: 서버 사이드 렌더링 시 미리 데이터를 가져와서 렌더링하는 기능입니다. RSC(리액트 서버 컴포넌트)는 SSR을 완벽히 지원하지만 SWR은 지원하지 않아요.\n- **SSR 중 스트리밍**: 서버 렌더링을 하면서 데이터를 조금씩 점진적으로 보내주는 기능으로, 사용자 경험을 향상시킵니다. RSC는 이를 지원하지만 SWR은 지원하지 않습니다.\n- **요청 중복 제거**: 동일한 요청을 중복해서 보내지 않고 하나로 통합해 서버 부담과 네트워크 낭비를 줄여줍니다. 세 방식 모두 지원합니다.\n- **클라이언트 사이드 기능**: 클라이언트 상태 관리, 캐싱, 리페칭 등 클라이언트 기반 작업을 의미합니다. SWR과 RSC+SWR에서는 가능하지만 RSC 단독으로는 지원 못 해요.\n\n---\n\n### React Query와 Next.js를 활용한 SPA 구현\n\nReact Query는 클라이언트와 서버 양쪽에서 모두 사용할 수 있어서 Next.js와 함께 엄청 유용해요. 덕분에 전통적인 싱글 페이지 애플리케이션(SPA)뿐 아니라 Next.js의 서버 기능도 활용하면서 데이터 요청과 상태 관리를 효율적으로 할 수 있습니다.\n\n예를 들어, 서버 측에서 프리페칭(pre-fetching)을 하거나 캐시된 데이터를 활용하고, 클라이언트에서는 동적인 데이터 갱신이나 리페칭(refetching) 기능을 부드럽게 처리할 수 있죠.\n\nReact Query 공식 문서에서 더 자세한 내용과 예제를 확인해 보세요!  \n(https://react-query.tanstack.com/)\n\n---\n\n> **추가 팁!**  \n> Next.js 13과 같은 최신 버전에서는 React Server Components(RSC)와 클라이언트 상태 관리 라이브러리들을 함께 조합하는 방식이 굉장히 각광받고 있어요. 상황에 맞게 SSR을 적극 활용하면서도 필요할 때는 클라이언트 단에서 쾌적한 UX를 제공할 수 있죠.  \n> 이 표를 참고해서 여러분의 프로젝트에 맞는 최적의 데이터 페칭 전략을 찾아보시길 추천드립니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 브라우저에서만 컴포넌트 렌더링하기\n\nNext.js에서 클라이언트 컴포넌트는 기본적으로 빌드 시점에 미리 렌더링(prerendering)됩니다. 하지만 어떤 컴포넌트를 **오직 브라우저 환경에서만** 렌더링하고 싶다면, 즉 서버에서는 렌더링을 하지 않고 클라이언트에서만 불러오고 싶을 때가 있죠. 이런 경우 `next/dynamic`을 활용하면 됩니다.\n\n```js\nimport dynamic from 'next/dynamic'\n\nconst ClientOnlyComponent = dynamic(() => import('./component'), {\n  ssr: false, // 서버사이드 렌더링 비활성화\n})\n```\n\n여기서 `ssr: false` 옵션이 핵심인데요, 이 옵션을 주면 해당 컴포넌트는 서버에서 렌더링하지 않고 클라이언트(브라우저)에서만 렌더링됩니다.\n\n---\n\n#### 왜 이런 방식이 필요할까요?\n\n예를 들어, 여러분이 `window`나 `document` 같은 브라우저 전용 API를 사용하는 서드파티 라이브러리를 쓸 때 문제가 됩니다. 서버는 이런 API가 없으니까 에러가 나죠. 그래서 클라이언트에서만 로딩하도록 강제하는 겁니다.\n\n또 다른 방법으로는 `useEffect` 훅 안에서 이런 브라우저 API가 있는지 체크하고, 없으면 `null`이나 로딩 컴포넌트를 반환해 미리 렌더링 상태를 조절하는 방식도 있습니다.\n\n```js\nimport { useEffect, useState } from 'react'\n\nfunction BrowserOnlyComponent() {\n  const [isClient, setIsClient] = useState(false)\n\n  useEffect(() => {\n    setIsClient(true)\n  }, [])\n\n  if (!isClient) {\n    return null // 서버나 렌더링 초기 상태에서는 아무것도 보여주지 않음\n  }\n\n  return <YourComponent />\n}\n```\n\n이렇게 하면 서버에서는 렌더링하지 않고, 클라이언트 환경이 됐을 때 컴포넌트가 나타나게 됩니다.\n\n---\n\n### 정리하자면\n\n- `next/dynamic`을 쓰면 SSR(Server Side Rendering)을 끄고 클라이언트에서만 컴포넌트를 불러올 수 있어요.\n- 브라우저 전용 API를 쓰는 라이브러리나 컴포넌트에 유용하죠.\n- 아니면 `useEffect`로 브라우저 여부를 체크해서 조건부 렌더링하는 방법도 있습니다.\n\n이 팁은 Next.js와 같은 SSR 프레임워크에서 개발할 때 자주 쓰게 되니 잘 기억해두세요! 😉\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 클라이언트에서의 Shallow Routing(얕은 라우팅) 이해하기\n\n만약 기존에 Create React App이나 Vite처럼 전통적인 SPA(싱글 페이지 애플리케이션)를 쓰다가 Next.js로 옮겨 오는 중이라면, 아마 URL 상태만 바꾸는 얕은 라우팅(shallow routing)을 사용한 코드가 있을 거예요. 이 방법은 Next.js의 기본 파일 시스템 기반 라우팅을 쓰지 않고도, 애플리케이션 내에서 뷰 전환을 직접 컨트롤할 때 꽤 유용합니다.\n\nNext.js에서는 브라우저의 페이지를 새로 고침하지 않고도 주소(URL) 상태를 업데이트할 수 있게, 네이티브 `window.history.pushState`와 `window.history.replaceState` 메서드를 사용할 수 있도록 지원해 주는데요.  \n이 두 메서드는 브라우저의 히스토리 스택을 수정해 주지만, 페이지 전환은 없고 URL만 바뀌고 싶을 때 아주 딱 맞아요.\n\n흥미로운 점은, Next.js 라우터가 이 `pushState`와 `replaceState` 호출을 잘 인식해서, 내부적으로 `usePathname`이나 `useSearchParams` 같은 훅으로 URL 상태를 동기화 할 수 있다는 겁니다. 그래서 여러분이 직접 `window.history`를 건드려도 Next.js 라우터 상태와 호환되니 걱정할 필요가 없어요.\n\n---\n\n#### 참고로 얕은 라우팅이란?\n- **일반 라우팅:** URL이 바뀌면 Next.js가 서버 혹은 클라이언트에서 완전한 페이지 변화를 처리해서 렌더링을 다시 해요.\n- **얕은 라우팅:** URL은 바뀌지만, 페이지 컴포넌트는 바뀌지 않고 특정 상태만 바꾸거나 부분적으로 업데이트할 때 쓰는 방식이에요.\n\n이 방법은 특히 검색, 필터 등 화면 내 상태 상태변경을 URL과 연동해서 반영할 때 유용하니 알아두면 좋습니다!\n\n---\n\n### 간단한 예시 코드\n\n```jsx\nimport { useRouter } from 'next/router';\n\nexport default function ShallowRoutingExample() {\n  const router = useRouter();\n\n  const handleClick = () => {\n    // URL 쿼리만 바꾸고 페이지는 다시 로드하지 않고 싶을 때\n    router.push('/mypage?tab=profile', undefined, { shallow: true });\n  };\n\n  return <button onClick={handleClick}>Change Tab</button>;\n}\n```\n\n- `shallow: true` 옵션을 주면 Next.js가 페이지 컴포넌트를 다시 렌더링하지 않고 URL만 바뀝니다.\n- 내부적으로 이 방법은 `window.history.pushState`를 사용하고 있어요.\n\n---\n\n### 덧붙여 알려주고 싶은 팁\n\n- **`window.history` 메서드 직접 쓰기:**  \n  직접 `window.history.pushState`를 호출해서 URL을 바꿔도 되지만, Next.js의 라우터 함수를 쓰는 게 유지보수와 리액티브 상태 관리에 더 유리해요.\n\n- **SEO 같은 측면**에서 URL이 바뀌는 것은 좋은데, 얕은 라우팅은 페이지가 완전히 새로고침되지 않으니 서버 기반 데이터 변경이 필요하다면 주의해야 합니다.\n\n- Next.js 13 이상부터는 App Directory와 같은 최신 기능들이 나오면서 라우팅 방식에 변화가 생겼는데, 얕은 라우팅 개념은 여전히 유용하니 필요할 때 잘 활용해보세요!\n\n---\n\n요약하면, Next.js에서 얕은 라우팅은 URL은 변경하면서 페이지를 리로드하지 않고 빠르게 상태 변화를 반영하는 좋은 방법입니다. 기존 SPA에서 익숙했던 히스토리 API를 활용하면서도 Next.js 라우터와 잘 연동되는 덕에, 여러분의 앱에 맞춰 유연하게 써먹으실 수 있어요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여러분, Next.js에서 클라이언트 컴포넌트 내에서 URL 쿼리 스트링을 다루는 간단한 방법을 공유해드릴게요. 위 예제 코드는 `useSearchParams` 훅을 이용해 현재 URL의 쿼리 파라미터를 조회하고, 버튼 클릭으로 정렬 상태(오름차순/내림차순)를 바꾸면서 URL을 업데이트하는 방법이에요.\n\n```jsx\n'use client'\n\nimport { useSearchParams } from 'next/navigation'\n\nexport default function SortProducts() {\n  const searchParams = useSearchParams()\n\n  function updateSorting(sortOrder: string) {\n    const urlSearchParams = new URLSearchParams(searchParams.toString())\n    urlSearchParams.set('sort', sortOrder)\n    window.history.pushState(null, '', `?${urlSearchParams.toString()}`)\n  }\n\n  return (\n    <>\n      <button onClick={() => updateSorting('asc')}>Sort Ascending</button>\n      <button onClick={() => updateSorting('desc')}>Sort Descending</button>\n    </>\n  )\n}\n```\n\n자, 여기서 핵심은 `useSearchParams`로 현재 URL 파라미터를 쉽게 가져오고, `window.history.pushState`를 이용해 페이지를 리로드하지 않고 주소창만 바꿔주는 점이에요. 이렇게 하면 페이지 상태는 유지하면서 URL 파라미터만 변경할 수 있죠. 사용자 경험이 훨씬 부드러워져요.\n\n---\n\n### Next.js 라우팅과 네비게이션 이해하기\n\nNext.js에서는 `useSearchParams`, `useRouter` 같은 훅을 통해 클라이언트 사이드에서 라우팅 정보에 접근하거나 조작하는 게 매우 편리해요. `useSearchParams`는 URL 쿼리값을 읽고 쓸 수 있도록 도와주고, `useRouter`는 `push`, `replace`, `back` 같은 네비게이션 메서드를 써서 라우팅을 제어할 수 있게 해주거든요.\n\n---\n\n### 클라이언트 컴포넌트에서 Server Actions 사용하기\n\nNext.js 13부터 도입된 Server Actions는 클라이언트 컴포넌트에서도 점진적으로 도입 가능해요. 예전에는 API 라우트를 호출하며 로딩 상태 관리, 에러 핸들링 같은 따로 처리해야 할 일이 많았는데 Server Actions로 간단해졌답니다.\n\nReact의 `useActionState` 같은 훅을 함께 쓰면, 로딩 중인지, 에러가 났는지 상태를 자동으로 알려줘서 UI 처리가 한결 쉬워져요. 그래서 클라이언트 컴포넌트 내에서도 서버 데이터를 바로 호출하고, 결과를 바로 반영하는 강력한 패턴으로 자리 잡고 있죠.\n\n---\n\n이런 기능들을 잘 활용하면 복잡한 상태 관리 없이도 매끄럽고 직관적인 사용자 인터페이스를 만들 수 있는데요, 특히 정렬, 필터링 같은 URL 기반 필터 기능 구축에 딱 맞습니다. 혹시 Next.js의 최신 라우팅이나 Server Actions에 대해 궁금한 점 있으면 또 공유할게요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이번에는 처음으로 Server Action을 만들어보는 예시를 들어볼게요!\n\n```js\n'use server'\n \nexport async function create() {}\n```\n\n위처럼 `create`라는 비동기 함수를 `server` 모드에서 정의할 수 있어요. 여기서 중요한 점은, 이 Server Action은 API 엔드포인트를 따로 만들 필요 없이 클라이언트 쪽에서 바로 호출할 수 있다는 거예요.\n\n클라이언트 쪽 컴포넌트에서 이렇게 사용할 수 있죠:\n\n```js\n'use client'\n \nimport { create } from './actions'\n \nexport function Button() {\n  return <button onClick={() => create()}>Create</button>\n}\n```\n\n버튼 클릭 시 `create()`라는 서버 함수가 호출돼요. 마치 일반 자바스크립트 함수를 호출하는 것처럼 간편하죠.\n\n---\n\n### 여기서 조금 더 알아두면 좋은 팁!\n\n- Server Actions 덕분에 클라이언트와 서버 사이의 데이터 통신이 훨씬 간단해졌어요.\n- 전통적인 REST API처럼 별도의 API 라우트 파일을 만들거나 fetch 요청을 직접 작성하지 않아도 돼서 빠르게 개발할 수 있답니다.\n- 물론, Server Action 내부에서 데이터베이스 작업, 인증 검증 등 서버 작업을 마음껏 할 수 있어요.\n- 그러나 이 함수는 클라이언트에서 직접 실행되는 게 아니라 서버에서 실행되며, 클라이언트에 노출되는 코드는 아니라는 점 기억하세요.\n\n이처럼 Server Actions를 활용하면 React 컴포넌트 내에서 서버 작업을 매우 쉽게 할 수 있으니, Next.js나 React Server Components를 사용할 때 꼭 활용해보세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n서버 액션(Server Actions)으로 데이터 변경하기에 대해 좀 더 알아보자!\n\n## 정적 내보내기 (선택 사항)\n\nNext.js는 완전한 정적 사이트를 생성하는 것도 지원해요. 이 방법은 일반적인 SPA(싱글 페이지 애플리케이션)보다 몇 가지 장점이 있답니다!\n\n- **자동 코드 분할**: 보통 SPA라면 하나의 index.html에 모든 코드가 모여서 클라이언트가 로딩하는 데 시간이 걸리는데, Next.js는 각 라우트마다 별도의 HTML 파일을 생성해줘요. 그래서 방문자가 페이지에 더 빨리 접근할 수 있죠.\n- **향상된 사용자 경험**: 모든 라우트에서 최소한의 스켈레톤 화면만 보여주는 대신, 각 라우트마다 완전히 렌더링된 페이지를 먼저 보내요. 클라이언트 사이드에서 이동할 때는 여전히 SPA처럼 부드럽고 즉각적인 전환을 할 수 있어서 사용자가 자연스럽게 느껴집니다.\n\n즉, Next.js의 정적 내보내기는 SEO 최적화도 되고, 초기 로딩 속도와 사용자 경험을 동시에 잡을 수 있는 훌륭한 기능이에요.\n\n추가로, 서버 액션을 활용하면 데이터 변경이 서버 측에서 직접 이루어지므로 보안이나 성능 면에서도 이점이 있어요. 클라이언트에서 불필요하게 데이터를 전달하거나 검증하는 단계가 줄어들거든요. Next.js를 사용한다면 이런 서버 액션과 정적 내보내기를 적절히 조합해서 깔끔하고 빠른 웹사이트를 만들어보세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서 정적 내보내기(Static Export)를 활성화하려면 설정 파일을 아래처럼 업데이트 해주면 돼요:\n\n```js\nimport type { NextConfig } from 'next'\n\nconst nextConfig: NextConfig = {\n  output: 'export',\n}\n\nexport default nextConfig\n```\n\n이렇게 설정하고 나서 `next build` 명령을 실행하면, Next.js가 `out` 폴더를 만들어서 HTML, CSS, JS 같은 정적 자산들을 그 안에 담아줍니다. 덕분에 별도의 서버 없이도 완전히 정적인 웹사이트를 배포할 수 있죠.\n\n---\n\n> 참고: 정적 내보내기를 사용할 경우, Next.js의 서버 사이드 기능들은 지원되지 않습니다. 예를 들어, API 라우트나 getServerSideProps 같은 기능은 쓸 수 없어요.  \n> 만약 서버 기능이 필요하면, 정적 내보내기 대신 ISR(Incremental Static Regeneration)이나 SSR(Server Side Rendering)을 고민해보는 게 좋아요.\n\n---\n\n추가로, 정적 내보내기는 간단한 블로그나 포트폴리오 사이트, 문서 페이지 등에 아주 적합해요. 만약 사용자 맞춤형 데이터나 실시간 정보가 적게 필요하고, 최대한 빠른 로딩이 목표라면 꼭 고려해보세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 기존 프로젝트를 Next.js로 점진적으로 마이그레이션하기\n\nNext.js로 완전히 갈아타기 부담스럽다고? 걱정 마세요! Next.js는 기존 프로젝트를 단계별로 천천히 옮길 수 있게 가이드가 잘 마련되어 있어요.\n\n- Create React App에서 마이그레이션하기\n- Vite에서 마이그레이션하기\n\n이미 SPA를 만들고 Pages Router를 사용 중이라면, App Router를 점진적으로 적용하는 방법도 배울 수 있답니다.\n\n---\n\n사실 큰 프로젝트를 한꺼번에 옮기려면 막막할 수 있잖아요. Next.js는 이런 점을 고려해서 '조각조각' 나눠서 적용할 수 있도록 설계되었거든요. 덕분에 기존 코드도 유지하면서 점차 Next.js의 장점들을 누려볼 수 있어요.\n\n그리고 App Router는 Next.js 최신 기능 중 하나인데, 기존 Pages Router 프로젝트에 조금씩 섞어 쓰다가 완전히 갈아타는 것도 가능해요. 그래서 기존에 만들어 놓은 SPA에 큰 변화 없이도 최신 패턴을 활용할 수 있다는 점, 참고하세요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":26},{"title":"Next.js 15 프로덕션 최적화 완벽 가이드","description":"","date":"2025-04-22 01:36","slug":"2025-04-22-HowtooptimizeyourNextjsapplicationforproduction","content":"\n\n# Next.js 애플리케이션을 프로덕션에 최적화하는 방법\n\nNext.js 애플리케이션을 프로덕션 환경에 배포하기 전에 사용자 경험, 성능, 그리고 보안을 위해 꼭 고려해야 할 최적화 방법과 좋은 패턴들이 있어요.\n\n이 글에서는 애플리케이션을 만들 때, 배포 전에, 그리고 배포 후에 참고할 수 있는 실전 팁들과 Next.js가 자동으로 제공하는 최적화 기능들을 함께 소개할게요. 개발하면서 한 번쯤 꼭 확인해보면 좋아요!\n\n## 자동 최적화 기능들\n\nNext.js는 기본적으로 많은 부분을 자동으로 최적화해줘요. 그래서 우리가 따로 신경 쓰지 않아도 괜찮은 부분들이 있죠. 예를 들어:\n\n| 최적화 요소            | 설명                                                         |\n|---------------------|------------------------------------------------------------|\n| 코드 분할(Code Splitting)    | 페이지 단위로 필요한 코드만 딱 불러와서 초기 로딩 속도를 빠르게 해줘요.              |\n| 정적 사이트 생성(Static Generation) | 빌드 시점에 HTML 파일로 미리 생성해서 서버 부담을 줄이고, 빠른 응답을 가능하게 해줍니다. |\n| 이미지 자동 최적화         | Next.js에서 제공하는 `<Image>` 컴포넌트로 이미지를 자동으로 최적화해서 로딩 속도를 개선합니다. |\n| 트리 쉐이킹(Tree Shaking)      | 사용하지 않는 코드를 제거해서 번들 용량을 줄여줍니다.                                  |\n| 프로덕션 빌드에서 압축       | JS와 CSS 파일을 압축하고 난독화해서 크기를 최소화합니다.                           |\n\n이런 자동화 덕분에 개발자는 기본적인 부분에 신경 쓰지 않고도 빠른 앱을 만들 수 있지만, 더 세밀한 최적화가 가능하다는 것도 잊지 마세요.\n\n다음에는 우리가 직접 적용할 수 있는 최적화 방법들을 살펴볼게요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서 기본으로 제공하는 최적화 기능들을 알려드릴게요! 별도의 설정 없이도 적용되니, 그냥 편하게 개발만 하시면 됩니다.\n\n- **서버 컴포넌트(Server Components)**: Next.js는 기본적으로 서버 컴포넌트를 사용합니다. 서버 컴포넌트는 서버에서만 실행되고, 클라이언트에는 자바스크립트를 전혀 보내지 않아요. 덕분에 클라이언트 사이드 자바스크립트 용량이 줄어들죠. 그리고 필요에 따라 인터랙티브한 부분만 클라이언트 컴포넌트(Client Components)로 만들어 사용하면 됩니다.\n- **코드 분할(Code-splitting)**: 서버 컴포넌트 덕분에 라우트 세그먼트별로 자동 코드 분할이 되어서, 필요한 부분만 내려받게 돼요. 여기에 더해서, 클라이언트 컴포넌트나 서드파티 라이브러리도 지연 로딩(lazy loading)하면 더 효율적입니다.\n- **프리패칭(Prefetching)**: 사용자가 어떤 링크를 화면에서 볼 때, Next.js가 그 라우트를 미리 백그라운드에서 받아오는데요, 덕분에 새로운 페이지로의 이동이 거의 순식간에 이루어진답니다. 상황에 따라 프리패칭을 끌 수도 있어요.\n- **정적 렌더링(Static Rendering)**: Next.js는 빌드 시점에 서버와 클라이언트 컴포넌트를 정적으로 렌더링해 결과를 캐싱하니까, 앱 성능이 좋아집니다. 필요하면 특정 경로에 대해 동적 렌더링(Dynamic Rendering)도 선택 가능합니다.\n- **캐싱(Caching)**: 서버 데이터 요청, 정적 렌더 결과, 정적 자산 등 여러 부분을 캐싱해서 서버나 DB, 백엔드에 가는 네트워크 요청 수를 줄여줍니다. 적절하다면 캐싱을 끄는 것도 가능해요.\n\n---\n\n이 최적화 기본값들은 앱 성능을 향상시키고, 네트워크 요청 때 쓰는 데이터 양과 비용을 줄여주는 효과가 있어요. \n\n---\n\n## 개발 중에는?\n\n다음 답변에서 개발 환경에서의 최적화 적용이나 주의할 점을 자세히 알려드릴게요! 혹시 Next.js 개발 중에 느린 점이나 의문 있으면 언제든 질문 주세요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n애플리케이션을 만들다 보면 성능과 사용자 경험을 최적화하는 게 중요하죠. 그래서 다음 기능들을 사용하는 걸 추천해요!\n\n### 라우팅과 렌더링\n\n- **레이아웃(Layouts)**: 여러 페이지에서 공통 UI를 공유할 수 있어서, 페이지 이동 시 일부만 새로고침하는 부분 렌더링이 가능해요. 덕분에 사용자 경험이 훨씬 매끄럽답니다.\n- **`Link` 컴포넌트**: 클라이언트 사이드 내비게이션할 때 꼭 써주세요. 미리 데이터를 가져오는(prefetch) 기능도 있어서 페이지 전환이 더 빨라져요.\n- **에러 처리(Error Handling)**: 404나 그 외 예기치 못한 오류도 사용자에게 부드럽게 알리려면, 커스텀 에러 페이지를 만들어 놓으세요. 프로덕션 환경에서 꼭 필요하답니다.\n- **컴포지션 패턴(Composition Patterns)**: 서버 컴포넌트와 클라이언트 컴포넌트를 어떻게 구성할지 정해진 패턴을 따르세요. 특히 `\"use client\"` 지시문을 어디에 붙이는지 신경 써야 클라이언트 번들 용량을 불필요하게 늘리지 않아요.\n- **동적 API(Dynamic APIs)**: 쿠키나 `searchParams` 같은 동적 API를 쓰면 그 경로 전체가 동적 렌더링 모드로 전환돼요. 만약 루트 레이아웃에서 쓰면 앱 전체가 그렇게 되니 주의가 필요해요. 꼭 필요한 부분에만 사용하고, 적절하면 `Suspense` 경계로 감싸서 성능 저하를 막으세요.\n\n> 참고: 현재 실험 중인 Partial Prerendering 기능을 사용하면, 라우트의 일부만 동적으로 처리하면서도 전체를 동적 렌더링으로 전환하지 않아도 돼요. 앞으로 더 편리해질 예정이니 기대해도 좋아요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 데이터 페칭과 캐싱에 대해 알아볼까요?\n\n웹 앱 개발할 때 데이터 가져오는 방식과 캐싱 전략이 굉장히 중요하죠. 여기에 몇 가지 팁을 나눠드릴게요.\n\n- **서버 컴포넌트(Server Components) 활용하기**  \n  데이터는 서버에서 가져오는 게 성능상 유리해요. 서버 컴포넌트를 이용하면 클라이언트로 보내기 전에 데이터를 미리 받아서 렌더링할 수 있어요.\n\n- **라우트 핸들러(Route Handlers) 사용법**  \n  클라이언트 컴포넌트에서 백엔드 API에 접근할 때 라우트 핸들러를 사용하세요. 그런데 서버 컴포넌트에서 라우트 핸들러를 호출하는 건 피하는 게 좋아요. 왜냐하면 그러면 서버가 다시 서버에 요청하는 꼴이라 불필요한 추가 요청이 생기거든요.\n\n- **스트리밍(Streaming)으로 사용자 경험 개선하기**  \n  데이터가 완전히 로드될 때까지 기다리지 말고, 로딩 UI와 React Suspense를 활용해 UI를 점진적으로 보여주면 사용자 경험이 훨씬 좋아져요. 페이지 전체가 멈추지 않거든요.\n\n- **병렬 데이터 페칭(Parallel Data Fetching) 활용하기**  \n  여러 데이터를 순차적으로 가져오면 네트워크 병목이 생길 수 있어요. 가능하면 여러 데이터 요청을 동시에 보내서 속도를 앞당겨 보세요. 또, 미리 데이터를 불러오는 프리로딩(preloading)도 고려해볼 만해요.\n\n- **데이터 캐싱(Cache)은 필수**  \n  데이터 요청이 캐싱되고 있는지 꼭 확인하세요. fetch를 사용하지 않는 요청도 캐싱되도록 설정해주면 반복되는 요청을 줄일 수 있답니다.\n\n- **정적 이미지 관리**  \n  애플리케이션에 사용되는 이미지 같은 정적 자산은 `public` 디렉토리에 넣으면 자동으로 캐싱이 돼서 빠르게 로딩돼요.\n\n---\n\n### UI와 접근성에 대해\n\n- **폼과 검증(Form & Validation) 처리하기**  \n  사용자가 폼을 제출할 때 서버 액션(Server Actions)을 이용해 서버에서 검증하고 에러도 처리하세요. 클라이언트에서 모든 검증을 하는 것보다 안정적이고 보안에 더 좋아요.\n\n---\n\n이런 팁들을 활용하면 데이터 흐름을 효과적으로 관리하면서 사용자에게 쾌적한 경험을 줄 수 있어요. 서버 컴포넌트와 라우트 핸들러, React Suspense가 서로 어떻게 시너지를 내는지도 한번 실험해보시고요! 다음에 또 쉽게 이해할 만한 개발 지식으로 찾아올게요 :)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n개발할 때 퍼포먼스와 보안을 신경 쓰는 건 정말 중요한데요, 이번에 제가 정리한 내용을 쉽게 설명해드릴게요.\n\n### 퍼포먼스 최적화 팁\n\n| 기능 | 설명 |\n|---|---|\n| Font Module | 폰트 모듈을 사용하면 폰트 파일을 다른 정적 자원들과 함께 자동으로 호스팅해서 외부 네트워크 요청을 줄이고, 레이아웃 이동(layout shift)도 감소시킬 수 있어요. |\n| `Image` 컴포넌트 | 이미지 컴포넌트는 이미지를 자동으로 최적화해주고, 레이아웃 이동 문제를 막아주며, WebP 같은 현대적인 이미지 포맷으로 제공해줘요. 웹에서 이미지가 빠르게 뜨는 건 사용자 경험 향상에 아주 큰 도움이 되죠. |\n| `Script` 컴포넌트 | 서드파티 스크립트를 최적화하는 데 유용해요. 자동으로 스크립트를 지연 실행(defer) 시켜서 메인 스레드를 막지 않도록 해주거든요. 덕분에 페이지가 더 부드럽고 빠르게 로딩됩니다! |\n| ESLint | 내장된 `eslint-plugin-jsx-a11y` 플러그인을 활용하면 접근성(accessibility) 이슈를 미리 잡아낼 수 있어서, 누구나 쉽게 이용할 수 있는 웹을 만드는 데 도움이 됩니다. |\n\n> 참고로, 레이아웃 시프트(layout shift)는 사용자 경험에 악영향을 주는 요소 중 하나라서 최대한 줄이는 게 좋아요.\n\n---\n\n### 보안 관련 팁\n\n| 기능 | 설명 |\n|---|---|\n| Tainting | 민감한 데이터가 클라이언트 쪽으로 노출되지 않도록 데이터를 '오염(tainting)' 시키는 방법이에요. 특정 값이나 데이터 객체를 표시해서 관리하는 방식이죠. |\n| Server Actions | 서버 액션을 호출할 때 사용자 권한이 꼭 확인되도록 하세요. 공식적으로 권장하는 보안 모범 사례를 정기적으로 리뷰하는 게 중요합니다. |\n| 환경 변수 | `.env.*` 파일은 `.gitignore`에 반드시 추가해서 깃에 올라가지 않게 해야 해요. 공개해야 하는 변수만 `NEXT_PUBLIC_` 접두사를 붙여서 노출 범위를 명확히 관리하는 게 좋습니다. |\n| Content Security Policy (CSP) | CSP는 교차 사이트 스크립팅(XSS), 클릭재킹(clickjacking), 코드 인젝션 같은 보안 위협으로부터 앱을 보호해주는 역할을 해요. 적절한 CSP 설정으로 좀 더 안전한 웹사이트를 만들 수 있습니다. |\n\n---\n\n여기서 한 가지 더! 보안에서 가장 기본적인 걸 깔끔하게 챙기는 게 중요해요. 예를 들어, 환경 변수 처리를 그냥 넘기지 말고, 꼭 `.gitignore`에 추가하는 습관은 실수로 중요한 정보가 유출되는 걸 예방할 수 있답니다. CSP도 조금 복잡해 보일 수 있는데, 보안 헤더 관련 툴이나 라이브러리를 활용하면 설정이 훨씬 수월해지니 참고하세요!\n\n요약하자면, 폰트나 이미지, 스크립트 같은 프론트엔드 자원을 적절히 최적화하고, 보안에서 기본적인 데이터 관리와 권한, 정책 설정을 잘 챙기면 개발 퀄리티가 훨씬 올라간답니다. 앞으로 개발할 때 꼭 한번씩 체크리스트 삼아 활용해보세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 메타데이터와 SEO\n\n- **메타데이터 API**: 메타데이터 API를 활용하면 페이지 제목(title), 설명(description) 등 SEO에 중요한 정보를 손쉽게 추가할 수 있어요. 이렇게 하면 구글 같은 검색 엔진이 내 웹사이트를 더 잘 이해하고, 검색 결과에 더 잘 노출될 수 있답니다.\n- **Open Graph(OG) 이미지**: 페이스북, 트위터 같은 소셜미디어에서 내가 만든 페이지를 공유할 때 멋진 썸네일 이미지가 나오도록 OG 이미지를 만들어두는 게 좋아요. 시각적으로도 훨씬 매력적이니, 공유가 늘어나는 효과도 있답니다.\n- **사이트맵과 Robots 파일**: 사이트맵은 내 웹사이트에 어떤 페이지들이 있는지 검색 엔진에게 알려주는 역할을 해요. Robots.txt 파일은 검색 엔진이 어떤 페이지를 크롤링해도 되는지, 안 되는지를 지정해주는 친구입니다. 이 두 가지를 잘 설정하면 내 사이트가 검색 결과에 잘 노출되는 데 큰 도움이 돼요.\n\n### 타입 안전성(Type Safety)\n\n- **TypeScript와 TS 플러그인**: 자바스크립트는 유동적인 타입 때문에 때때로 예기치 못한 버그가 생기기 쉬운데요, TypeScript는 강력한 타입 시스템 덕분에 이런 문제를 미리 방지할 수 있도록 도와줘요. 게다가 VSCode 같은 개발 도구에서 타입 정보를 활용해서 자동완성도 되고, 에러도 빨리 발견할 수 있답니다. 그래서 요즘 웹 개발자라면 TypeScript를 꼭 배워두는 걸 추천해요!\n\n---\n\n개발하면서 SEO도 신경 쓰고, 코드 안정성도 챙기려면 위 내용들을 잘 활용해보세요. 작지만 이런 세심한 준비가 나중에 서비스 성공에 큰 차이를 만들어 줄 거예요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 배포 전에 꼭 확인해야 할 것들\n\n배포 전에 `next build` 명령어로 애플리케이션을 로컬에서 미리 빌드해보세요. 이렇게 하면 빌드 도중에 발생할 수 있는 오류들을 미리 잡아낼 수 있거든요. 다음으로 `next start`를 실행해서 실제 배포 환경과 비슷한 상황에서 애플리케이션의 성능을 측정해보는 것도 좋은 방법이에요.\n\n### Core Web Vitals\n\n- **Lighthouse**\n  - Lighthouse를 시크릿 모드(Incognito)로 실행해보세요. 이렇게 하면 실제 사용자들이 여러분의 사이트를 어떻게 경험할지 좀 더 정확하게 파악할 수 있어요. 그리고 개선이 필요한 부분도 쉽게 찾을 수 있죠.\n  - 다만 Lighthouse는 시뮬레이션 테스트이기 때문에, 실제 사용자 데이터를 같이 보는 것이 중요해요. 예를 들어, Core Web Vitals 같은 필드 데이터를 참고해서 성능을 좀 더 정확히 평가해보는 걸 추천합니다.\n\n> 추가 팁!\n> \n> Lighthouse 외에도 Chrome DevTools Performance 탭을 활용해서 사이트의 렌더링 과정이나 렌더링 차단 요소가 있는지 직접 분석해보는 것도 좋아요. 그리고 Core Web Vitals는 페이지 로딩 속도, 반응성, 시각적 안정성 등 사용자 경험에 직접적인 영향을 미치는 지표들이라 배포 전후로 꾸준히 모니터링하는 습관을 들이면 사이트 품질 관리에 큰 도움이 됩니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- useReportWebVitals 훅: 이 훅을 사용하면 Core Web Vitals 데이터를 애널리틱스 도구로 전송할 수 있어요. 사이트 성능을 측정하고 개선할 때 유용하답니다.\n\n### 번들 분석하기\n\n@next/bundle-analyzer 플러그인을 활용해 자바스크립트 번들의 크기를 분석해보세요. 어떤 모듈이나 의존성이 큰지 파악해서 성능에 영향을 주는 부분을 쉽게 찾을 수 있어요.\n\n또한, 새로운 의존성을 추가할 때 그 영향력을 알아보는 데 도움이 되는 도구들도 있어요. 이걸 잘 활용하면 불필요하게 무거운 라이브러리가 프로젝트에 들어오는 것을 막을 수 있죠. 대표적으로는 다음과 같은 툴들이 있으니 참고해 보세요:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Import Cost  \n- Package Phobia  \n- Bundle Phobia  \n- bundlejs\n\n## 배포 후\n\n어디에 애플리케이션을 배포하느냐에 따라, 성능을 모니터링하고 개선하는 데 도움이 되는 추가 도구나 통합 기능을 사용할 수 있어요.\n\n예를 들어, Vercel에 배포했다면 다음과 같은 도구들을 써보길 추천해요:\n\n- **Vercel Analytics**: 서버리스 환경에서 자동으로 트래픽과 성능 데이터를 수집해줘서, 별도의 설정 없이도 사용자 경험을 파악할 수 있어요.  \n- **Edge Functions 로그**: 엣지 함수 사용 시 로그를 통해 실행 시간을 모니터링하고 최적화 포인트를 쉽게 찾을 수 있고요.  \n- **Third-party 모니터링 도구 연동**: New Relic, Datadog 같은 도구들과 연동하면, 더 상세한 APM(애플리케이션 성능 관리)까지 할 수 있어요.  \n\n물론 이런 도구들이 꼭 Vercel에만 국한된 건 아니지만, 배포 플랫폼별로 특화된 기능을 잘 활용하면 성능 최적화 작업이 훨씬 수월해진답니다.  \n\n추가로, 배포 후에는 꼭 실시간 트래픽과 사용자 행동을 체크하면서 개선해나가는 걸 잊지 마세요! 이런 루틴이 결국 안정적이고 빠른 서비스 운영의 비결이에요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Analytics  \n: 내장된 분석 대시보드를 통해 애플리케이션의 트래픽을 쉽게 파악할 수 있어요. 예를 들어, 고유 방문자 수, 페이지 조회 수 등 다양한 지표를 확인할 수 있답니다.\n\n- Speed Insights  \n: 실제 방문자 데이터를 바탕으로 한 성능 인사이트를 제공해요. 이를 통해 웹사이트가 실제 환경에서 얼마나 잘 작동하는지 실질적인 성과를 확인할 수 있죠.\n\n- Logging  \n: 런타임 및 활동 로그를 통해 문제를 디버깅하고 프로덕션 환경에서 애플리케이션을 모니터링할 수 있어요. 필요하다면 타사 도구 및 서비스 목록은 통합 페이지에서 찾아볼 수 있습니다.\n\n> 알아두면 좋은 점:  \nVercel에서 프로덕션 배포 시 모범 사례를 종합적으로 이해하고 싶다면, [Vercel Production Checklist](https://vercel.com/docs/concepts/deployments/production-checklist)를 참고해 보세요. 웹사이트 성능 향상을 위한 다양한 전략과 자세한 내용이 담겨 있어서, 더 빠르고 안정적이며 안전한 애플리케이션을 만드는 데 큰 도움이 됩니다.\n\n덧붙여, 이런 도구들을 잘 활용하면 단순히 코드만 잘 짜는 것을 넘어서, 실제 사용자 경험을 개선하고 문제 발생 시 빠르게 대응할 수 있는 능력이 생기니 꼭 챙겨보시길 추천해요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":12},{"title":"Next.js와 Multi-Zones를 활용한 마이크로 프론트엔드 구축 방법 (2025 최신)","description":"","date":"2025-04-22 01:35","slug":"2025-04-22-Howtobuildmicro-frontendsusingmulti-zonesandNextjs","content":"\n# Multi-Zones와 Next.js로 마이크로 프론트엔드 만들기\n\n안녕하세요! 오늘은 'Multi-Zones'라는 개념을 활용해 Next.js로 마이크로 프론트엔드를 구축하는 방법에 대해 이야기해볼게요. '마이크로 프론트엔드'는 큰 애플리케이션을 여러 작은 애플리케이션으로 쪼개 관리하는 방법인데, Multi-Zones 방식은 특히 도메인 내에서 각기 다른 경로 집합(Path Set)별로 Next.js 애플리케이션을 분리하는 거랍니다.\n\n## Multi-Zones가 왜 필요할까요?\n\n대형 웹사이트를 운영하다보면, 서로 관련 없는 페이지들이 한 곳에 모여있을 때가 많아요. 예를 들어, 블로그 섹션과 로그인 후 대시보드, 그리고 일반 사용자용 페이지를 한 앱에서 모두 관리한다면, 빌드 시간이 길어지고 불필요한 코드도 함께 묶이게 됩니다. Multi-Zones를 적용하면 이런 문제를 이렇게 해결할 수 있어요:\n\n- 각 영역(Zone)별로 Next.js 앱을 따로 배포해 빌드 타임을 줄이고,\n- 각 앱에 필요한 코드만 포함해 번들 사이즈를 최소화하며,\n- 완전히 분리된 앱이므로 서로 다른 프레임워크도 혼용할 수 있습니다. 예를 들어, 메인 페이지는 Next.js, 블로그 섹션은 React SPA, 혹은 Vue.js 앱으로 분리할 수 있죠.\n\n## 예제를 들어볼까요?\n\n만약 다음과 같은 페이지 세트를 가지고 있다면:\n\n- `/blog/*` : 모든 블로그 포스트\n- `/dashboard/*` : 로그인 후 대시보드 관련 페이지\n- `/*` : 여기에 포함되지 않은 나머지 일반 페이지\n\n각각을 별도의 Next.js 애플리케이션으로 분리해서 관리하면, 훨씬 유연하고 관리하기 좋은 구조가 됩니다.\n\n---\n\n이렇게 분리된 애플리케이션들은 서로 독립적으로 개발 및 배포 가능하니, 팀별로 담당 영역 개발에 집중하기에도 좋고, 필요에 따라 기술 스택도 다르게 유지할 수 있는 점도 장점이에요.\n\n다음에는 이런 각각의 Zone을 설정하고 라우팅하는 방법, 그리고 배포 시 어떻게 연동하는지 자세한 설정법을 알아볼게요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nMulti-Zones 기능을 활용하면, 같은 도메인에서 서비스되면서 사용자 입장에서는 똑같이 보이는 세 개의 애플리케이션을 만들 수 있어요. 하지만 각 애플리케이션은 독립적으로 개발하고 배포할 수 있다는 점이 큰 장점이죠.\n\n![Multi-Zones 예시 이미지](/TIL/assets/img/2025-04-22-Howtobuildmicro-frontendsusingmulti-zonesandNextjs_0.png)\n\n여기서 재미있는 부분은 '존(zone)' 단위로 페이지 이동할 때의 동작이에요.\n\n- 같은 존 내에서 페이지를 이동하면 **소프트 네비게이션(soft navigation)**이 일어나는데, 이때는 페이지를 새로 고침하지 않고 빠르게 이동이 가능해요. 그림 예시에서 `/`에서 `/products`로 이동하는 경우가 바로 이 소프트 네비게이션에 해당하죠.\n- 반대로, 한 존에서 다른 존으로 이동할 때는 **하드 네비게이션(hard navigation)**이 발생해요. 즉, 현재 페이지의 리소스를 언로드(해제)하고 새로운 페이지 리소스를 다시 로드하는 작업이 이뤄지는 거죠. 예를 들어 `/`에서 `/dashboard`로 이동하는 경우가 여기에 포함돼요.\n\n이 점을 잘 활용하려면, 자주 함께 방문하는 페이지들을 같은 존에 배치하는 게 좋아요. 그래야 하드 네비게이션이 불필요하게 발생하지 않아 사용성도 높아지고, 로드 시간도 줄어들 테니까요.\n\n---\n\n추가로, 이런 Multi-Zones 구조는 마이크로 프론트엔드 아키텍처에 아주 적합해요. 즉, 대규모 애플리케이션을 여러 개의 작은 프론트엔드 애플리케이션으로 분할해서 팀별로 독립적 개발과 배포가 가능하게 만들어 주거든요. Next.js를 사용하면 이러한 Multi-Zones 지원을 비교적 쉽게 구현할 수 있으니, 관심 있는 분들은 공식 문서나 관련 튜토리얼도 함께 참고해보길 추천합니다!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 존(zone) 정의하는 방법\n\n존(zone)이란, 보통의 Next.js 애플리케이션과 비슷한데, 각 존마다 충돌을 방지하기 위해 `assetPrefix`라는 설정을 추가하는 걸 말해요. 이걸로 페이지나 정적 파일들이 다른 존과 겹치지 않게 관리할 수 있답니다.\n\n예를 들어, `assetPrefix`를 `/blog-static`으로 설정하면 이렇게 작성해요:\n\n```js\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  assetPrefix: \"/blog-static\",\n};\n```\n\n그럼 Next.js가 로드하는 JavaScript, CSS 같은 에셋들은 이 `assetPrefix`를 붙여서 `/blog-static/_next/...` 경로로 제공돼요. 이렇게 하면 여러 존에서 동일한 `_next` 폴더를 공유할 때 생길 수 있는 충돌 문제를 자연스럽게 해결할 수 있죠.\n\n### 참고로 알아두면 좋은 점!\n\n- `assetPrefix` 설정을 할 때는 실제로 배포 환경에서 이 경로가 올바르게 매핑되는지 꼭 확인하세요. 예를 들면, CDN이나 웹서버 설정이 `/blog-static` 경로의 요청을 제대로 처리해야 합니다.\n- 만약 로컬에서 개발할 때도 이 프리픽스를 쓰면 경로 이슈가 생길 수 있으니, 보통 개발 모드에선 `assetPrefix`를 빈 문자열로 두고, 프로덕션 빌드에서만 적용하는 방법도 있어요.\n\n이렇게 하면 한 서버 내 여러 개의 Next.js 서비스(존)를 안정적으로 운영할 수 있으니, 멀티 테넌트 환경이나 여러 애플리케이션을 한 곳에서 관리할 때 유용해요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서 기본 애플리케이션, 즉 다른 특정 zone으로 라우팅되지 않는 경로를 처리하는 애플리케이션은 따로 assetPrefix를 지정할 필요가 없어요.\n\n참고로, Next.js 15 버전 이전에는 정적 자산(static assets)을 제대로 처리하기 위해 추가적인 rewrites가 필요했었는데요, Next.js 15부터는 이런 작업이 더 이상 필요하지 않답니다.\n\n예를 들어, 아래처럼 assetPrefix를 지정하고, rewrites를 통해 정적 자산 경로를 다시 매핑해주는 코드가 있었어요.\n\n```js\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  assetPrefix: \"/blog-static\",\n  async rewrites() {\n    return {\n      beforeFiles: [\n        {\n          source: \"/blog-static/_next/:path+\",\n          destination: \"/_next/:path+\",\n        },\n      ],\n    };\n  },\n};\n```\n\n이렇게 하면 `/blog-static` 경로 아래의 `_next` 정적 파일들이 제대로 처리되도록 해줬죠.\n\n---\n\n### 요청을 올바른 zone으로 라우팅하는 방법\n\nNext.js를 여러 zone으로 나눠서 서비스할 때, 요청이 적절한 zone으로 잘 전달되도록 라우팅 설정이 필요해요. 이를 통해 각 zone별로 개별 Next.js 앱을 독립적으로 운영하면서도 마치 하나의 서비스처럼 보이게 할 수 있습니다.\n\n일반적으로 다음과 같은 방식으로 라우팅을 구현합니다:\n\n| 요청 경로 (Request Path) | 라우팅 대상 (Destination Zone)        | 비고                         |\n| ------------------------ | ------------------------------------- | ---------------------------- |\n| `/blog`, `/blog/*`       | 블로그 zone 애플리케이션              | blog 관련 콘텐츠 제공        |\n| `/shop`, `/shop/*`       | 쇼핑 zone 애플리케이션                | 쇼핑몰 서비스 제공           |\n| 기타                     | 기본 zone (기본 Next.js 애플리케이션) | 전체 서비스의 기본 응답 처리 |\n\n이때 각 zone 애플리케이션은 자신만의 assetPrefix를 가지고 있을 수 있고, 이전 Next.js 버전에서는 정적 자산 때문에 추가 rewrites 설정이 필요했지만, Next.js 15부터는 이런 설정 없이도 assetPrefix만으로 처리 가능해졌습니다.\n\n---\n\n#### 끝으로, 제가 경험해본 팁 하나!\n\nNext.js 앱을 멀티 zone으로 구성할 때는 배포와 라우팅 규칙을 명확히 정리하는 게 중요해요. 특히 CDN 캐싱 등과 연동할 때는 assetPrefix를 잘 활용해서 정적 자산들이 꼬이지 않도록 관리하는 걸 추천합니다. 그래야 배포 발란스도 맞고, 사용자 경험도 좋아진답니다!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nMulti Zone 환경에서는 각 경로(path)를 올바른 존(zone)으로 라우팅해줘야 해요. 왜냐하면 서로 다른 존은 각기 다른 애플리케이션에서 서비스되기 때문이죠. 보통 HTTP 프록시를 사용해서 이 작업을 하곤 하는데, Next.js 애플리케이션 중 하나를 이용해 도메인 전체의 요청을 라우팅하는 방법도 있어요.\n\n그럼 Next.js에서 어떻게 라우팅을 할 수 있을까요? 바로 rewrites 기능을 사용하는 거예요. 존마다 서비스하는 경로가 다르면, 그 경로를 해당 존의 도메인으로 보내는 rewrite 규칙을 추가해주면 됩니다. 예를 들어, `/blog` 경로는 블로그 존에서 처리한다면 아래처럼 쓸 수 있어요.\n\n```js\nasync rewrites() {\n  return [\n    {\n      source: '/blog',\n      destination: `${process.env.BLOG_DOMAIN}/blog`,\n    },\n    {\n      source: '/blog/:path+',\n      destination: `${process.env.BLOG_DOMAIN}/blog/:path+`,\n    }\n  ];\n}\n```\n\n여기서 중요한 건 `destination`이 실제 요청을 처리하는 존의 완전한 URL(스킴 + 도메인)을 포함해야 한다는 점이에요. 예를 들어 `https://blog.example.com/blog` 같은 주소가 될 거예요. 프로덕션 환경에선 당연히 존의 실제 도메인을 넣으면 되고, 로컬 개발 중일 땐 `http://localhost:3001/blog` 같은 식으로 로컬 주소로도 라우팅할 수 있습니다.\n\n추가로, rewrites는 클라이언트가 요청한 URL을 실제 내부적으로 다른 경로나 도메인으로 바꿔주는 기능이라서, 사용자가 URL을 바꾸지 않고도 다른 서비스에 요청을 보낼 수 있다는 장점이 있어요. 이런 방식으로 멀티 존 아키텍처를 구성하면 관리가 비교적 편하고, 각 존별로 독립된 애플리케이션을 운영하면서도 하나의 도메인 아래에서 자연스럽게 서비스할 수 있습니다.\n\n정리하면:\n\n| 역할        | 설명                                          |\n| ----------- | --------------------------------------------- |\n| source      | 사용자가 요청하는 경로                        |\n| destination | 실제 서비스하는 존의 URL (스킴 + 도메인 포함) |\n\n이렇게 쓰고, 필요한 경로마다 반복해서 추가해주면 돼요.\n\nNext.js 자체가 라우팅 기능이 뛰어나기는 한데, 멀티 존 환경에서는 이런 rewrite 기능을 활용하면 훨씬더 유연하게 운용할 수 있어서 꼭 한 번 적용해 보시길 추천드립니다!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n> 참고할 점: URL 경로는 각 존(zone)마다 고유해야 해요. 예를 들어, 두 존 모두 /blog 경로를 사용하려고 하면 라우팅 충돌이 발생할 수 있어요.\n\n### 미들웨어를 활용한 라우팅 요청 처리\n\n요청을 라우팅할 때 `rewrites`를 사용하는 게 지연 시간(latency)을 줄이는 데 추천되지만, 상황에 따라 동적으로 라우팅 결정을 해야 할 때는 미들웨어를 쓸 수도 있어요. 예를 들어, 마이그레이션 기간에 특정 경로의 라우팅을 기능 플래그(feature flag)로 제어하고 싶을 때 미들웨어가 아주 유용하답니다.\n\n아래는 그런 경우를 위한 간단한 미들웨어 예시예요:\n\n```js\nexport async function middleware(request) {\n  const { pathname, search } = request.nextUrl;\n  if (pathname === \"/your-path\" && myFeatureFlag.isEnabled()) {\n    return NextResponse.rewrite(`${rewriteDomain}${pathname}${search}`);\n  }\n}\n```\n\n여기서 `myFeatureFlag.isEnabled()`는 기능 플래그가 활성화됐는지 체크하는 함수고, 활성화되면 `/your-path` 경로로 들어오는 요청을 `rewriteDomain`으로 재작성(리라이트)해서 넘겨줘요.\n\n---\n\n추가로, 미들웨어를 너무 남발하면 오히려 성능 저하가 발생할 수 있으니, 꼭 필요한 경우에만 활용하는 게 좋아요. 그리고 미들웨어가 실행될 때는 서버에서 처리되므로, 요청 지연이 생길 수 있답니다. 따라서 단순 경로 변경이 목적이라면 rewrites 설정을 우선 고려해보세요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 존(zone) 간 링크 연결하기\n\n서로 다른 존에 있는 경로(path)로 연결할 때는 Next.js의 `Link` 컴포넌트 대신 일반 HTML의 `<a>` 태그를 사용하는 게 좋아요. 그 이유는 Next.js의 `Link` 컴포넌트는 상대 경로에 대해 사전에 데이터를 불러오고 부드럽게 페이지를 이동하는 동작(prefetch 및 soft navigation)을 시도하는데, 이 방식이 존을 넘나들 때는 제대로 작동하지 않거든요.\n\n즉, 존 간 이동은 그냥 `<a href=\"...\">` 태그를 써서 새로운 페이지를 불러오는 방식을 써야 버그 없이 쓸 수 있어요.\n\n---\n\n## 코드 공유하기\n\n여러 존을 구성하는 Next.js 애플리케이션들은 각기 다른 저장소(repository)에 있을 수도 있고, 한 저장소(monorepo)에 함께 모아 둘 수도 있어요. 개인적으로는 모노레포 구조가 코드 공유나 유지보수 면에서 훨씬 편리하다고 생각해요.\n\n만약 존이 각기 다른 레포에 흩어져 있다면, 공용(public) 또는 사설(private) NPM 패키지 형태로 코드를 공유하는 방법도 있어요. 예를 들어, 공통 유틸리티 함수나 컴포넌트들을 NPM 패키지로 만들어서 필요할 때마다 설치해서 사용하는 거죠.\n\n사실 개발하는 팀이나 프로젝트 규모에 따라 적합한 방식을 선택하면 되지만, 모노레포를 사용한다면 VSCode 같은 도구에서 한 번에 코드 검색도 되고, 빌드하고 테스트하기도 훨씬 수월해진다는 장점이 커요.\n\n---\n\n### 추가로 알아두면 좋은 팁\n\n- **모노레포 관리 툴**: `Nx`, `Turborepo`, `Lerna` 같은 도구를 활용하면 여러 애플리케이션과 패키지를 효과적으로 관리할 수 있어요.\n- **버전 관리**: 공유 NPM 패키지를 사용할 땐, 버전 관리를 잘 해야 하며, SemVer(유의적 버전관리)를 따르는 게 좋아요.\n- **빌드 속도**: 모노레포에서는 캐싱과 병렬 빌드를 적극 활용해서 빌드 속도를 개선할 수 있어요.\n\n이렇게 존 간 연동과 코드 공유를 잘 설계하면 여러 팀과 프로젝트가 협업하기 훨씬 수월해지니 한 번쯤은 이런 구조도 고민해보시길 추천드립니다!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n페이지들이 서로 다른 존(zone)에 걸쳐 있고 각각 출시되는 시기가 다를 수 있어서, 기능 플래그(feature flags)를 사용하면 다양한 존에서 기능을 동시에 켜거나 끌 때 굉장히 유용해요.\n\n특히 Vercel에서 Next.js 애플리케이션을 운영할 때는, 여러 존(zone)에 영향을 주는 코드를 한 번의 git 푸시로 배포하기 위해 모노레포(monorepo)를 사용하는 방법도 추천드려요. 이렇게 하면 관리가 훨씬 편해지고 배포 과정도 깔끔해집니다.\n\n---\n\n## 서버 액션(Server Actions)\n\nMulti-Zones 환경에서 서버 액션을 사용할 때는 사용자 앞단(origin)을 명시적으로 허용해줘야 해요. 왜냐하면 사용자 도메인이 여러 애플리케이션을 서빙할 수 있기 때문인데요. 이를 위해 `next.config.js` 파일에 다음과 같은 설정을 추가해주면 됩니다:\n\n```javascript\nmodule.exports = {\n  experimental: {\n    serverActions: true,\n  },\n  // 사용자 도메인을 명시적으로 허용합니다.\n  serverActions: {\n    allowedOrigins: [\"https://user-facing-domain.com\"],\n  },\n};\n```\n\n> 참고로, `allowedOrigins` 설정은 사용자의 브라우저에서 오는 요청이 신뢰할 수 있는 도메인에서 발생한 것인지 체크하는 역할을 합니다. 이걸 정확하게 설정해주지 않으면, 보안 문제가 발생할 수 있으니 꼭 필요한 도메인만 넣어주세요!\n\n이 외에도 multi-zone 환경에서 서버 액션을 제대로 활용하려면 CORS 설정이나 인증 관련 부분도 꼼꼼하게 챙기는 게 좋아요. 개발할 때 미리 여러 존의 도메인 구조를 파악해두면 배포와 운영이 훨씬 수월해질 거예요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서 `serverActions.allowedOrigins` 설정에 대해 알아볼게요!\n\n```js\nconst nextConfig = {\n  experimental: {\n    serverActions: {\n      allowedOrigins: [\"your-production-domain.com\"],\n    },\n  },\n};\n```\n\n이 설정은 Next.js가 실험적으로 도입한 Server Actions 기능과 관련돼요. Server Actions는 서버 쪽에서 실행되는 함수들을 클라이언트 사이드에서 직접 호출할 수 있게 해주는데, 이때 보안상 어디서 호출할 수 있는지를 제한하는 것이 중요해요. `allowedOrigins`는 그런 호출을 허용할 도메인 목록을 지정해 주는 역할을 해요.\n\n예를 들어, 위 코드에서 `your-production-domain.com` 도메인에서만 Server Actions가 허용되도록 설정한 거죠. 이렇게 하면, 다른 도메인에서 임의로 서버 액션을 호출하는 걸 막아서 보안이 강화돼요.\n\n### 추가로 알아두면 좋은 점\n\n- 이 기능은 아직 실험 단계(`experimental`)이기 때문에, 사용하려면 Next.js 버전과 문서를 수시로 체크하는 것이 좋아요.\n- 개발 환경에서는 `allowedOrigins`에 `localhost`도 넣어야 테스트가 가능해요.\n- 여러 도메인을 허용하고 싶다면 배열 안에 여러 도메인을 추가하면 됩니다.\n- 만약 CORS(Cross-Origin Resource Sharing)에 익숙하다면, 이 옵션이 CORS 정책과 유사하게 동작한다고 생각하면 쉬워요.\n\n```js\nconst nextConfig = {\n  experimental: {\n    serverActions: {\n      allowedOrigins: [\"your-production-domain.com\", \"localhost:3000\"],\n    },\n  },\n};\n```\n\n실제 배포할 때는 꼭 실제 서비스 도메인만 넣어두고, 테스트할 때 일시적으로 localhost를 추가하는 걸 추천해요!\n\n더 자세한 내용과 최신 정보는 공식 Next.js 문서에서 `serverActions.allowedOrigins` 항목을 참고하세요. 늘 변화가 빠른 Next.js에서 이런 실험적인 기능들을 잘 활용하면, 더 안전하고 효율적인 서버-클라이언트 통신이 가능해질 거예요!\n","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":13},{"title":"Vite에서 Next.js 15로 마이그레이션 하는 방법","description":"","date":"2025-04-22 01:30","slug":"2025-04-22-HowtomigratefromVitetoNextjs","content":"\n\n# Vite에서 Next.js로 마이그레이션하는 방법\n\n안녕하세요! 오늘은 Vite로 만들어진 기존 프로젝트를 Next.js로 옮기는 방법에 대해 이야기해볼게요. 요새 React 생태계에서 Next.js가 워낙 대세라서요, 프로젝트 확장성이나 SEO 같은 부분 때문에 넘어가는 분들이 많더라고요. \n\n## 왜 굳이 Next.js로 갈아타야 할까?\n\n사실 Vite도 빠르고 사용하기 편한 툴인데, Next.js로 갈아타는 몇 가지 이유가 있거든요.\n\n| 이유 | 설명 |\n|---|---|\n| **서버 사이드 렌더링(SSR)** | Next.js는 기본적으로 SSR을 지원해서 SEO에 훨씬 유리해요. Vite는 클라이언트 렌더링에 초점이 맞춰져 있죠. |\n| **파일 기반 라우팅** | Next.js는 폴더 구조만 잘 맞추면 라우팅 설정이 자동으로 되어 개발 속도가 빨라져요. Vite는 라우터 설정을 직접 해줘야 하죠. |\n| **API 라우트 지원** | Next.js 내에서 API 엔드포인트를 쉽게 만들 수 있어 백엔드 & 프론트엔드 통합이 편리해요. Vite는 보통 별도의 서버를 띄워야 해요. |\n| **강력한 커뮤니티와 플러그인** | Next.js는 많은 플러그인과 라이브러리가 있어서 생태계가 풍부하고, 지원도 활발해요. |\n\n사실 프로젝트 규모가 커지고, SEO가 중요해지고, 좀 더 안정적인 서버 사이드 렌더링이 필요하다면 Next.js는 거의 필수 선택지라고 할 수 있겠네요!\n\n다음 포스팅에서는 실제로 Vite 프로젝트를 어떻게 Next.js 프로젝트로 옮길지, 단계별로 자세히 알려드릴게요. 기대해주세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 느린 초기 페이지 로딩 시간\n\n만약 기본 Vite 플러그인으로 리액트 애플리케이션을 만들었다면, 여러분의 앱은 순수한 클라이언트 사이드 애플리케이션입니다. 이렇게 클라이언트 사이드에서만 앱을 실행하는 방식, 즉 흔히 싱글 페이지 애플리케이션(SPA)이라고 하죠. 이 방식은 보통 초기 페이지 로딩 속도가 느려지는 문제가 발생합니다. 왜 그런지 간단히 살펴볼게요.\n\n- 브라우저가 여러분의 리액트 코드와 전체 애플리케이션 번들을 내려받고 실행하기 전까지는 데이터 요청조차 시작할 수 없습니다.\n- 시간이 지나면서 기능이 추가되고 의존성도 늘어나면서 애플리케이션 코드가 점점 커져서 더 오래 걸리게 됩니다.\n\n즉, 초기 로딩에 필요한 코드가 한 번에 너무 많아서 브라우저가 버거워하는 상황인 거죠.\n\n### 자동 코드 분할이 없다면?\n\n자동 코드 분할이란 쉽게 말해, 필요한 코드만 쪼개서 나중에 불러오는 걸 의미해요. 하지만 기본 설정으로 만든 Vite + React 프로젝트엔 이 기능이 적용되어 있지 않습니다. 그래서 앱 전체 코드를 한 번에 내려받아야 하죠.\n\n자동 코드 분할이 없으면 다음과 같은 단점이 있어요.\n\n| 문제점              | 설명                                                                                     |\n|-----------------|----------------------------------------------------------------------------------------------|\n| 초기 로딩 느림      | 모든 코드가 한 번에 내려오니까 페이지가 뜨기까지 기다려야 하는 시간이 길어짐                                       |\n| 불필요한 코드 다운로드 | 현재 페이지에서 필요하지 않은 코드도 같이 받게 되어 네트워크 자원이 낭비됨                                                |\n| 사용자 경험 저하    | 로딩 시간이 길어지면 방문자가 페이지 이탈할 확률이 높아짐                                                         |\n\n자동 코드 분할을 도입하면 첫 페이지 로딩은 가볍게, 이후 필요한 기능은 필요한 순간에 불러올 수 있어 앱 속도가 체감상 빨라집니다.\n\n---\n\n### 추가 팁: 해결책으로 SSG/SSR 도입하기\n\n초기 로딩 속도를 확실히 개선하고 싶다면, 서버 사이드 렌더링(SSR)이나 정적 사이트 생성(SSG)을 도입하는 것도 좋은 방법입니다. Next.js 같은 프레임워크는 기본적으로 이 기능들을 지원해요. 요청 시 서버에서 미리 렌더링된 HTML을 보내면 브라우저가 JS 실행을 기다리지 않아도 빠르게 페이지를 보여줄 수 있죠.\n\n단, SSR/SSG는 설정이 좀 더 복잡할 수 있으니 상황과 요구에 맞게 도입하면 됩니다.\n\n---\n\n이처럼 리액트 앱 개발할 때 초기 로딩 속도 문제는 SPA의 흔한 고민이고, 자동 코드 분할 또는 SSR/SSG 같은 기술을 적절히 적용하면 훨씬 개선할 수 있어요. 앞으로 프로젝트에 적용해 보면서 체감 성능을 경험해보시길 바랍니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이전 글에서 언급한 느린 로딩 문제는 코드 스플리팅(code splitting)으로 어느 정도 해결할 수 있어요. 그런데 직접 수동으로 코드 스플리팅을 하려고 하면 오히려 성능이 더 안 좋아질 수도 있어요. 수동으로 코드를 나누다 보면 네트워크 워터폴(Network waterfalls, 요청이 순차적으로 쌓여서 느려지는 현상)이 쉽게 발생할 수 있거든요. 다행히 Next.js는 자체 라우터에 자동 코드 스플리팅 기능이 내장되어 있어서 이런 문제를 훨씬 간편하게 해결할 수 있어요.\n\n### 네트워크 워터폴(Network waterfalls)이란?\n\n네트워크 워터폴은 애플리케이션이 클라이언트와 서버 사이에서 순차적으로 여러 데이터를 요청할 때 발생하는 성능 저하 현상이에요. SPA(싱글 페이지 애플리케이션)에서 데이터를 받아올 때 주로, 처음에는 로딩용 자리 표시자(placeholder)를 렌더링하고, 컴포넌트가 마운트된 후에야 데이터를 받아오는 패턴이 많죠. 이 경우 하위 컴포넌트가 데이터를 요청하려면, 반드시 상위 컴포넌트가 자신의 데이터를 모두 받은 뒤여야 해서 대기시간이 길어질 수밖에 없습니다.\n\nNext.js는 클라이언트에서 데이터를 받아오는 것도 지원하지만, 데이터 페칭을 서버 사이드에서 처리하게끔 선택할 수도 있어요. 서버에서 데이터를 미리 받아서 렌더링하면 이런 클라이언트-서버 워터폴 현상을 완전히 없앨 수 있답니다.\n\n---\n\n마치면서 한 가지 팁!  \n서버 사이드 렌더링(SSR)이나 SSG(정적 사이트 생성)를 활용하면, 페이지 렌더링 전에 데이터를 미리 받아오기 때문에 사용자 입장에서 훨씬 빠른 초기 로딩을 경험할 수 있어요. Next.js의 `getServerSideProps`나 `getStaticProps` 같은 함수들이 그 역할을 하니, 꼭 활용해보세요!\n\n---\n\n| 개념          | 설명                                                                                  |\n|--------------|-------------------------------------------------------------------------------------|\n| 코드 스플리팅    | 자바스크립트 코드를 여러 덩어리로 나누어 필요한 부분만 불러와 초기 로딩 속도를 개선하는 방법                   |\n| 네트워크 워터폴 | 클라이언트와 서버가 요청을 연속적으로 주고받아서 응답시간이 길어지는 현상                                        |\n| Next.js 자동 코드 스플리팅 | Next.js의 라우터가 페이지별로 자동으로 코드 스플리팅을 해주어 성능 최적화를 돕는 기능                           |\n| 서버 사이드 데이터 페칭 | Next.js가 페이지 렌더링 전에 서버에서 데이터를 미리 받아와 클라이언트-서버 간 요청 지연 문제를 해결하는 방식          |\n\n필요하면 다음 글에서 Next.js의 데이터 페칭 방법과 활용법도 자세히 알려드릴게요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 빠르고 의도적인 로딩 상태 관리\n\nReact Suspense가 스트리밍을 기본적으로 지원하면서, 어떤 UI 부분을 먼저 로딩할지, 또 어떤 순서로 로딩할지 더 세심하게 설계할 수 있게 되었습니다. 덕분에 네트워크 워터폴(waterfall) 현상을 피할 수 있죠.\n\n네트워크 워터폴이란, 한 요청이 끝나야 다음 요청이 시작되는 상황을 말하는데, 이게 계속 쌓이면 로딩 속도가 느려져 사용자 경험이 떨어집니다. Suspense를 사용하면 여러 컴포넌트를 병렬로 로딩하면서도 사용자에게 매끄럽게 보여줄 수 있어서, 페이지 로딩 속도도 빨라지고 레이아웃이 불안정하게 변하는 문제(layout shift)도 줄일 수 있습니다.\n\n### 데이터 패칭(가져오기) 전략 선택하기\n\n내가 배운 바로는, 데이터 패칭 전략을 잘 선택하는 게 매우 중요해요. 예를 들어, 모든 데이터를 한 번에 가져오느냐, 필요한 데이터만 나눠서 가져오느냐에 따라 성능과 사용자 경험이 확 달라집니다.\n\n아래 표는 다양한 데이터 패칭 전략과 그 특징을 간단히 정리한 거예요.\n\n| 전략                   | 설명                                  | 장점                          | 단점                          |\n|----------------------|-------------------------------------|-----------------------------|-----------------------------|\n| 전체 데이터 한 번에 로드    | 페이지 로드 시 모든 데이터를 한꺼번에 요청           | 초기 로딩 후 빠른 탐색 가능           | 초기 로딩 시간 길어짐               |\n| 필요한 데이터만 나눠서 로드 | 필요한 부분만 요청, 점진적 로딩 지원                  | 빠른 초기 로딩, 네트워크 부하 분산       | 구현 복잡도 증가                    |\n| 캐싱 활용               | 요청한 데이터를 캐싱하여 재사용                        | 불필요한 중복 요청 방지                 | 데이터 최신성 관리 필요              |\n| 스트리밍                 | React Suspense와 함께 스트리밍 데이터 로딩 활용          | 사용자에게 빠르게 부분 렌더링 가능       | 서버 및 클라이언트 세팅 복잡           |\n\n특히 React Suspense와 같은 최신 기능들을 활용하면, 스트리밍 방식으로 데이터를 점진적으로 받아오면서 사용자에게 빠른 피드백을 줄 수 있어요. 개발자로서 이런 점들을 염두에 두면, 퍼포먼스 좋은 앱을 만드는 데 큰 도움이 됩니다.\n\n---\n\n궁금한 점 있으면 언제든 댓글로 남겨주세요! 앞으로도 이런 실용적인 개발 팁들을 계속 공유할게요 :)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js는 상황에 맞게 페이지나 컴포넌트 단위로 데이터 가져오기 전략을 선택할 수 있도록 유연성을 제공합니다. 예를 들어, 빌드 시점에 데이터를 가져와서 CMS에 있는 블로그 포스트를 렌더링하고, 이를 CDN에 캐시해서 빠르게 서비스할 수 있어요. 또는 서버 요청 시점이나 클라이언트에서 데이터를 받아서 동적으로 처리할 수도 있죠. 이렇게 상황에 따라 가장 적합한 방식을 선택할 수 있다는 게 Next.js의 큰 장점 중 하나랍니다.\n\n### 미들웨어 (Middleware)\n\nNext.js의 미들웨어는 서버에서 요청이 완료되기 전에 코드를 실행할 수 있도록 해줍니다. 예를 들어, 로그인해야 볼 수 있는 페이지에 사용자가 접근했을 때, 잠깐 인증이 안 된 페이지가 보이는 ‘깜빡임(flash)’ 현상을 막고 바로 로그인 페이지로 리다이렉트할 수 있어요. 이 외에도 새로운 기능을 실험해보거나, 다국어 지원 같은 국제화 작업에 아주 유용하죠. 미들웨어가 있다 보니 이런 작업들이 좀 더 자연스럽고 효율적으로 처리됩니다.\n\n### 내장 최적화 기능\n\nNext.js는 개발자가 따로 신경 쓰지 않아도 자동으로 여러 최적화를 수행합니다. 예를 들어, 이미지 최적화, 번들 크기 최소화, 코드 스플리팅, 그리고 사전 렌더링 같은 기능들이 모두 내장되어 있어요. 특히 이미지 최적화는 웹 페이지 로딩 속도를 크게 높여주니, 사용자 경험 개선에 큰 효과가 있답니다. 덕분에 복잡한 설정 없이도 빠르고 효율적인 웹사이트를 만들 수 있어요.\n\n---\n\nNext.js를 처음 접하는 분들은 이런 데이터 페칭과 미들웨어, 그리고 최적화 기능들이 어떻게 연결되는지 이해하는 게 중요해요. 다양한 상황에 맞게 전략을 골라 사용하면 사이트 성능을 최대로 끌어올릴 수 있으니까요! 만약 이 부분들이 더 궁금하다면 다음 포스트에서 각 전략별 예제와 함께 자세히 설명해볼게요 :)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이미지, 폰트, 그리고 서드파티 스크립트는 애플리케이션 성능에 꽤 큰 영향을 줘요. 다행히 Next.js에는 이런 요소들을 자동으로 최적화해주는 내장 컴포넌트들이 있어서 성능 관리를 훨씬 쉽게 해줍니다.\n\n---\n\n## 마이그레이션 단계\n\n이번 마이그레이션 목표는 최대한 빠르게 Next.js 기반의 작동하는 애플리케이션을 만드는 거예요. 그 후에 필요에 따라 Next.js의 여러 기능을 차근차근 적용해 나가면 돼요. 처음에는 기존 라우터를 그대로 두고, 순수 클라이언트 사이드 애플리케이션(SPA)으로만 유지하는 방식으로 진행할 거예요. 이렇게 하면 마이그레이션 중에 발생할 수 있는 문제나 병합 충돌을 최소화할 수 있습니다.\n\n---\n\n### 1단계: Next.js 의존성 설치하기\n\n마이그레이션의 첫걸음은 Next.js 패키지를 프로젝트에 추가하는 것부터 시작합니다. 이 부분은 기본 중의 기본이니까 꼼꼼하게 설치해 주세요! 다음 명령어를 터미널에 입력하면 됩니다:\n\n```bash\nnpm install next react react-dom\n```\n\n또는 yarn을 사용한다면,\n\n```bash\nyarn add next react react-dom\n```\n\n이렇게 하면 Next.js가 필요로 하는 핵심 라이브러리들이 프로젝트에 추가됩니다.\n\n> 참고로, Next.js는 React 기반 프레임워크라 React와 ReactDOM도 함께 설치해야 해요. 이미 설치되어 있다면 중복 설치가 되지 않으니 걱정하지 않아도 됩니다!\n\n설치가 완료됐으면, 다음 단계로 넘어가서 실제로 Next.js 프로젝트 구조에 맞게 파일들을 조금씩 정리해보도록 할게요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n먼저, Next.js를 사용하기 위해서는 프로젝트에 Next를 의존성으로 설치해야 해요:\n\n```bash\nnpm install next@latest\n```\n\n### 2단계: Next.js 설정 파일 만들기\n\n프로젝트 루트에 `next.config.mjs` 파일을 만들어주세요. 이 파일은 Next.js의 다양한 설정 옵션들을 담고 있어요.\n\n> 참고로 이 설정 파일은 JavaScript나 TypeScript 파일처럼 동작하지만, `.mjs` 확장자를 사용하면 ES 모듈 방식을 명확히 하게 돼서 최근 Next.js 프로젝트에서 권장되고 있답니다.  \n\n필요한 설정들을 여기서 자유롭게 추가해서 프로젝트 요구사항에 맞게 조절해보세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n자, 이번에는 Next.js 설정 파일을 조금 바꿔볼게요! 위 예제 코드는 `next.config.js` 파일에 들어갈 내용인데요. \n\n```js\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  output: 'export',    // 이 설정은 Next.js를 SPA(단일 페이지 애플리케이션)로 내보내도록 해줘요.\n  distDir: './dist',   // 빌드 결과물을 기본 폴더가 아닌 './dist' 폴더에 저장해요.\n}\n\nexport default nextConfig\n```\n\n> 참고로, Next.js 설정 파일은 `.js` 뿐만 아니라 `.mjs` 확장자를 써도 무방해요. 그래서 프로젝트 스타일에 맞게 골라 쓰시면 됩니다.\n\n그리고 이제 TypeScript를 쓰는 분들은 tsconfig.json 파일을 수정해줘야 해요! Next.js와 호환되게끔 일부 설정을 바꿔줘야 하거든요. 만약 TypeScript를 쓸 필요가 없다면 이 부분은 건너뛰셔도 되니까 부담 갖지 마세요.\n\n---\n\n### TypeScript 사용자라면 tsconfig.json 수정하는 팁!\n\nNext.js는 TypeScript를 공식 지원하지만, 기본 설정이 Next.js 빌드 시스템에 맞게끔 커스텀 필요가 있어요. 보통은 다음과 같이 `compilerOptions`와 같이 설정합니다:\n\n| 옵션               | 설명                                        |\n|--------------------|---------------------------------------------|\n| `jsx`              | React JSX 변환 설정 (예: `\"react-jsx\"`)      |\n| `module`           | 모듈 시스템 (주로 `\"esnext\"` 사용)            |\n| `target`           | 컴파일 타겟팅 자바스크립트 버전                |\n| `strict`           | 엄격한 타입 체크 설정                         |\n| `baseUrl`           | 절대 경로 기준 디렉토리                          |\n| `paths`            | 모듈 경로 별칭 설정                           |\n\n예를 들어, tsconfig.json에 다음처럼 넣으면 더 편리하답니다:\n\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"es5\",\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"allowJs\": true,\n    \"skipLibCheck\": true,\n    \"strict\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"noEmit\": true,\n    \"esModuleInterop\": true,\n    \"module\": \"esnext\",\n    \"moduleResolution\": \"node\",\n    \"resolveJsonModule\": true,\n    \"isolatedModules\": true,\n    \"jsx\": \"react-jsx\"\n  },\n  \"include\": [\"next-env.d.ts\", \"**/*.ts\", \"**/*.tsx\"],\n  \"exclude\": [\"node_modules\"]\n}\n```\n\n이렇게 하면 Next.js에서 TypeScript를 더 원활하게 사용할 수 있답니다. 더 궁금하면 언제든 물어봐 주세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nTypeScript 설정을 하면서 다음과 같은 변경사항을 적용해봤어요.\n\n- `tsconfig.node.json` 프로젝트 참조 제거\n- `include` 배열에 `./dist/types/**/*.ts` 와 `./next-env.d.ts` 추가\n- `exclude` 배열에 `./node_modules` 추가\n- `compilerOptions`의 `plugins` 배열에 `\"name\": \"next\"` 추가\n- `esModuleInterop`을 `true`로 설정\n- `jsx`를 `\"preserve\"`로 설정\n- `allowJs`를 `true`로 설정\n- `forceConsistentCasingInFileNames`를 `true`로 설정\n- `incremental`을 `true`로 설정\n\n아래는 이렇게 수정된 `tsconfig.json` 예시입니다:\n\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2020\",\n    \"useDefineForClassFields\": true,\n    \"lib\": [\"ES2020\", \"DOM\", \"DOM.Iterable\"],\n    \"module\": \"ESNext\",\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"moduleResolution\": \"bundler\",\n    \"allowImportingTsExtensions\": true,\n    \"resolveJsonModule\": true,\n    \"isolatedModules\": true,\n    \"noEmit\": true,\n    \"jsx\": \"preserve\",\n    \"strict\": true,\n    \"noUnusedLocals\": true,\n    \"noUnusedParameters\": true,\n    \"noFallthroughCasesInSwitch\": true,\n    \"allowJs\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"incremental\": true,\n    \"plugins\": [{ \"name\": \"next\" }]\n  },\n  \"include\": [\"./src\", \"./dist/types/**/*.ts\", \"./next-env.d.ts\"],\n  \"exclude\": [\"./node_modules\"]\n}\n```\n\n---\n\n조금 더 풀어 이야기하자면,\n\n- `esModuleInterop: true`는 CommonJS 모듈과 ES 모듈 간의 호환성을 좋게 해줍니다. 그래서 `import` 구문을 쓸 때 오류를 줄여줘요.\n- `jsx: \"preserve\"`는 JSX를 컴파일하지 않고 그대로 두라는 뜻인데, Next.js가 자체적으로 처리하기 때문에 이렇게 해주는게 일반적이에요.\n- `allowJs: true`를 켜면 자바스크립트 파일도 TS 빌드 대상에 포함할 수 있어서, 점진적으로 타입스크립트로 이전하려는 프로젝트에서 유용합니다.\n- `forceConsistentCasingInFileNames: true` 설정은 대소문자 차이로 생기는 파일 경로 문제를 예방해줍니다. 특히 OS마다 대소문자 구분이 다른 경우에 꼭 필요해요.\n- `incremental: true`는 빌드 속도를 향상시키기 위해 이전 빌드 정보를 캐싱해주는 기능입니다. 개발할 때 시간 절약에 큰 도움이 돼요.\n- 플러그인에 `\"name\": \"next\"`를 넣으면 Next.js에서 권장하는 타입스크립트 플러그인을 사용하게 됩니니다.\n\nNext.js 공식 문서에도 TypeScript 구성에 대한 좋은 안내가 있으니, 필요하면 꼭 참고해보세요.  \nhttps://nextjs.org/docs/basic-features/typescript\n\n이 설정을 기반으로 프로젝트를 구성하면 Next.js + TypeScript 환경에서 좀 더 편리하고 안정적으로 개발하실 수 있습니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 4단계: 루트 레이아웃 만들기\n\nNext.js의 App Router를 사용할 때는 루트 레이아웃(root layout) 파일이 꼭 필요해요. 이 파일은 React Server Component로, 여러분의 앱 안에 있는 모든 페이지를 감싸는 역할을 하죠. 그리고 이 파일은 `app` 디렉토리의 최상단에 위치해야 합니다.\n\n비슷한 개념을 Vite 앱에서 찾자면, 바로 `index.html` 파일이에요. 이 파일이 여러분의 HTML, head, body 태그를 포함하고 있어서, Next.js에서 말하는 루트 레이아웃과 가장 비슷한 역할을 하죠.\n\n이번 단계에서는 여러분의 `index.html` 파일을 Next.js의 루트 레이아웃 파일로 변환해볼 거예요. \n\n---\n\n여기서 꼭 짚고 넘어갈 점은 Next.js에서는 이 루트 레이아웃이 React 컴포넌트라는 거예요. 단순히 HTML 파일이 아니라 리액트 컴포넌트로 작성되니, 필요한 경우 React의 훅이나 다른 컴포넌트로 기능 확장이 훨씬 쉬워요. 즉, 더 동적이고 유연한 레이아웃 구성이 가능하다는 거죠.\n\n그럼 이제 `index.html`에서 어떤 부분을 어떻게 바꿔주면 될지 살펴볼게요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이번에는 Next.js 프로젝트에서 새로운 앱 디렉토리를 만들고, 레이아웃 설정을 하는 방법을 알려드릴게요. 특히 Next.js 13 버전에서 도입된 '새로운 app 디렉토리 구조'를 활용하는 예제인데요, 코드 설명도 곁들여서 천천히 같이 보시죠!\n\n---\n\n### 1. `src` 안에 `app` 디렉토리 만들기\n\n먼저, 프로젝트 폴더 안 `src` 디렉토리 안에 `app` 폴더를 새로 만들어줘요. 여기서부터 우리 앱의 페이지, 레이아웃 등이 관리될 거예요.\n\n\nsrc/\n  └── app/\n\n\n---\n\n### 2. `RootLayout` 컴포넌트 만들기 (`layout.tsx`)\n\n`app` 폴더 안에 `layout.tsx` 파일을 하나 새로 만들어요. 이 파일은 페이지들의 공통 레이아웃을 담당합니다.\n\n```tsx\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return '...'\n}\n```\n\n- `children`은 이 레이아웃 안에 렌더링될 페이지나 하위 컴포넌트들을 의미해요.\n- 중요! `layout.tsx` 같은 레이아웃 파일 확장자는 `.js`, `.jsx`, `.tsx` 중 원하시는 걸로 써도 된답니다.\n\n---\n\n### 3. 기존 `index.html` 내용을 `RootLayout` 안에 넣기\n\n보통 React 프로젝트에는 `public/index.html` 파일이 있는데요, 여기에는 `<body><div id=\"root\"></div></body>` 같은 구조가 있어요. 이것을 Next.js의 레이아웃 컴포넌트에 맞게 바꿔줘야 해요.\n\n- `body` 안의 `<div id=\"root\"></div>` 대신에 JSX 문법을 사용해서 `<div id=\"root\">{children}</div>` 식으로 바꿔줍니다.\n- `<script>` 태그나 직접적으로 body 바로 아래에 있는 태그들은 Next.js의 자동 렌더링 및 페이지 컴포넌트 구조에서 관리하니 제거하거나 옮겨줘야 해요.\n\n아래처럼 작성할 수 있겠죠?\n\n```tsx\nexport default function RootLayout({ children }: { children: React.ReactNode }) {\n  return (\n    <html>\n      <head>\n        {/* 여기에 메타 태그, 폰트 링크 등 head 요소를 넣어줄 수 있어요 */}\n      </head>\n      <body>\n        <div id=\"root\">{children}</div>\n      </body>\n    </html>\n  )\n}\n```\n\n---\n\n### 잠깐, 여기서 팁!\n\n- Next.js 13부터는 `app` 디렉토리 내에서 레이아웃 또는 페이지가 기본적으로 서버 컴포넌트(Server Component)로 동작해요.\n- 따라서 클라이언트 사이드 상태 관리 등이 필요하면 `'use client'`를 꼭 넣어줍니다.\n- 그리고 기존에 `<div id=\"root\">`를 React 엔트리포인트로만 사용했던 것과 달리, Next.js에서는 `app` 구조가 페이지마다 분리돼서 더 깔끔하고 모듈화된 방식으로 관리돼요.\n\n---\n\n요약하자면:  \n`src/app/layout.tsx`를 만들고, 기존 HTML 구조를 이 안에 JSX로 옮기면서 `<div id=\"root\">{children}</div>` 형태로 바꿔주면 이제 Next.js 13 스타일의 앱 레이아웃 설정이 끝! 앞으로 페이지 컴포넌트도 이 안에서 자연스럽게 렌더링 될 거예요.\n\n궁금한 점 있으면 편하게 물어봐 주세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js를 사용하다 보면, 기본적으로 `<head>`에 들어가는 `meta charset`이나 `meta viewport` 태그가 자동으로 포함되어 있다는 점을 알게 될 거예요. 그래서 직접 이런 태그들을 작성할 필요가 없답니다! 조금 더 깔끔하고 관리하기 편하게 아래처럼 수정할 수 있어요.\n\n```js\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <head>\n        <link rel=\"icon\" type=\"image/svg+xml\" href=\"/icon.svg\" />\n        <title>My App</title>\n        <meta name=\"description\" content=\"My App is a...\" />\n      </head>\n      <body>\n        <div id=\"root\">{children}</div>\n      </body>\n    </html>\n  )\n}\n```\n\n여기서 조금 더 팁을 드리자면, favicon.ico, icon.png, robots.txt 같은 메타데이터 파일들이 있다면, 이걸 직접 `<head>`에 `link` 태그로 명시하지 않아도 돼요. Next.js가 여러분의 앱 디렉토리 최상단에 이런 파일들이 있는지 자동으로 체크해서 `<head>`에 넣어주거든요.\n\n즉, 이런 작업 구조가 가능해요:\n\n| 위치                  | 역할                                          |\n|---------------------|---------------------------------------------|\n| `app/favicon.ico`    | 파비콘 자동 등록                              |\n| `app/robots.txt`    | 검색 엔진 크롤러에서 참고하는 robots 파일 자동 포함  |\n| `app/icon.svg`       | SVG 아이콘 자동 등록                            |\n\n따라서, 이런 파일들만 잘 관리해두면 `link` 태그를 따로 추가하거나 지저분하게 관리할 필요가 없답니다.\n\n---\n\n> 🚀 **한가지 알아두면 좋은 점!**  \n> Next.js의 이런 자동화 덕분에 앱 구조가 훨씬 깔끔하고 유지보수가 편해져요. 그리고 혹시 이런 메타데이터를 동적으로 변경하고 싶다면 Next.js 13부터 도입된 `metadata` API도 활용해보세요! 훨씬 더 편리하게 SEO 최적화가 가능합니다.\n\n궁금한 게 있으면 언제든지 물어봐 주세요! 😊\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서 head 태그를 관리하는 새로운 방법, Metadata API에 대해 이야기해볼게요. 원래는 아래처럼 직접 `<head>` 태그 안에 title이나 meta를 적었었죠.\n\n```jsx\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <head>\n        <title>My App</title>\n        <meta name=\"description\" content=\"My App is a...\" />\n      </head>\n      <body>\n        <div id=\"root\">{children}</div>\n      </body>\n    </html>\n  )\n}\n```\n\n그런데 Next.js는 이제 Metadata API라는 깔끔한 방식을 제공합니다. 이걸 쓰면 메타데이터를 컴포넌트 바깥에 `export const metadata`로 분리할 수 있어요. 코드가 더 간결해지고, SEO 최적화나 공유할 때 이점도 커지죠:\n\n```tsx\nimport type { Metadata } from 'next'\n\nexport const metadata: Metadata = {\n  title: 'My App',\n  description: 'My App is a...',\n}\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <body>\n        <div id=\"root\">{children}</div>\n      </body>\n    </html>\n  )\n}\n```\n\n이렇게 바꾸면 `head` 태그 자체는 선언하지 않고도 메타데이터가 Next.js에 의해 자동으로 관리되니까 훨씬 깔끔하고 유지보수도 쉽습니다. 그리고 나중에 동적으로 제목이나 설명을 바꾸고 싶을 때도 이 Metadata API가 더 편리해요.\n\n참고로, 이 방식은 `/app` 디렉토리를 사용하는 Next.js 13 이상에서 권장되는 최신 방법이라는 점 꼭 기억하세요! 만약 아직 `pages` 디렉토리를 쓰고 있다면 다음 업그레이드 때 도입해 보시면 좋을 것 같아요.\n\n요약하자면, Metadata API는 다음과 같은 장점이 있어요:\n\n| 장점            | 설명                                                         |\n|-----------------|--------------------------------------------------------------|\n| 코드 분리       | 메타데이터를 컴포넌트 코드에서 분리해 관리가 편리해짐          |\n| 자동 관리       | Next.js가 head 태그를 자동으로 처리해 실수를 줄임             |\n| SEO & 공유 최적화 | SEO 관련 메타 정보와 소셜 미디어 공유 정보까지 쉽게 설정 가능  |\n| 타입 지원       | 타입스크립트 Metadata 타입 제공으로 안정성 증가               |\n\n이렇게 공식 문서를 따라가면 Next.js 프로젝트가 한층 더 체계적이고 깔끔해질 거예요! 꼭 한번 써보세요 :)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 5단계: 진입점 페이지 만들기\n\nNext.js에서는 앱의 진입점을 만들 때 `page.tsx` 파일을 작성하는 식으로 선언해요. 이걸 Vite로 치환하면, 보통 `main.tsx` 파일이 진입점 역할을 하게 됩니다. 이번 단계에서는 여러분 앱의 진입점(첫 시작점)을 설정해볼 거예요.\n\n- `app` 디렉토리 안에 `[[...slug]]`라는 이름의 폴더를 생성하세요.\n\n여기서 잠깐! 우리가 이번 가이드에서 Next.js를 SPA(싱글 페이지 애플리케이션)처럼 사용하려고 하거든요. 그러려면 앱의 첫 페이지가 모든 가능한 경로를 받아서 처리해야 합니다. 그래서 `app` 디렉토리에 `[[...slug]]`라는 폴더를 만들어서, 어떤 경로든 이 폴더가 잡아내서 라우팅할 수 있도록 하는 거죠.\n\n---\n\n추가로 설명을 좀 하자면, Next.js에서는 `[[...slug]]`와 같은 경로 패턴이 \"캐치올(catch-all)\" 라우팅 기능을 의미해요. 쉽게 말해서, URL에 뭘 붙여도 다 여기서 받겠다는 뜻이죠. 그래서 SPA를 구현할 때 정말 유용합니다. Vite 같은 도구에서는 이런 라우팅을 직접 구현하거나 라이브러리를 붙여야 하는데, Next.js가 너무 잘해주는 부분이죠!\n\n---\n\n혹시 React Router를 써서 SPA를 만든다면, 이런 \"모든 경로를 캐치하는\" 룰을 `<Route path=\"*\">` 같은 식으로 걸어줄 수 있다는 점도 기억해 두세요. SPA의 핵심은 결국 한 페이지에서 모든 라우팅을 내부에서 다 처리하는 거니까요.\n\n---\n\n정리하자면:\n\n- `[[...slug]]` 폴더 생성 → Next.js의 캐치올 라우팅\n- SPA처럼 모든 경로를 한 페이지에서 처리\n- Vite는 `main.tsx`가 진입점\n\n이렇게 세팅하면 여러분 앱이 다양한 경로에서 잘 반응하는 싱글 페이지 앱이 되겠죠? 다음 단계도 같이 기대해 주세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서는 폴더 구조가 라우트를 정의하는 중요한 역할을 해요. 여기서 소개한 `app/[[...slug]]` 디렉토리는 '옵셔널 캐치-올(optional catch-all)' 라우트 세그먼트라고 불려요. 쉽게 말하면, 이 폴더 안에 있는 페이지가 애플리케이션의 모든 경로를 잡아주도록 설정하는 거죠.\n\n### 직접 해보기\n`app/[[...slug]]` 안에 `page.tsx` 파일을 새로 만들고, 아래 내용을 넣어보세요:\n\n```tsx\nimport '../../index.css'\n\nexport function generateStaticParams() {\n  return [{ slug: [''] }]\n}\n\nexport default function Page() {\n  return '...' // 나중에 업데이트할 예정이에요\n}\n```\n\n- 여기서 `generateStaticParams` 함수는 빌드 시에 미리 정적 페이지를 생성하기 위한 파라미터를 반환해요. 예제에선 빈 slug 배열을 반환해서 기본 경로를 세팅하고 있어요.\n- `Page` 컴포넌트는 현재 그냥 문자열을 반환하는 기본 상태인데, 이후에 이 부분을 다양한 경로에 맞게 확장할 수 있습니다.\n\n> 참고로, Next.js에서는 Page 컴포넌트 파일 이름에 `.js`, `.jsx`, `.tsx` 어떤 확장자든 사용할 수 있어요. 여러분이 편한 걸로 쓰면 됩니다!\n\n이렇게 설정하면, 어떤 URL로 접근하든 여기 있는 `page.tsx`가 먼저 실행되어서 복잡한 라우팅 처리를 중앙 집중화 할 때 유용해요. 예를 들어 블로그의 포스트 여러 개를 한 페이지 컴포넌트에서 처리한다든지 할 때 쓰이죠.\n\n---\n\n추가로 Tip!\n- `[...slug]`는 캐치-올 라우트(segment all)인데 필수로 하나 이상의 값이 있어야 합니다.\n- `[[...slug]]`는 옵셔널 캐치-올이라 slug가 없어도 이 라우트가 적용돼요.\n- 이렇게 라우트를 잡으면 동적 경로도 쉽게 만들 수 있어요.\n\nNext.js 라우팅 좀 더 편하게 하고 싶다면, 이런 옵셔널 캐치-올 라우트 구조를 꼭 알아두면 좋아요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 파일은 서버 컴포넌트(Server Component)예요. `next build` 명령어를 실행하면 이 파일은 미리 렌더링(prerendering)되어 정적인 자산(static asset)으로 만들어집니다. 즉, 동적 코드가 필요 없다는 뜻이죠.\n\n이 파일은 글로벌 CSS를 불러오고, `generateStaticParams` 함수에서는 오직 인덱스 경로인 `/` 하나만 정적으로 생성할 것이라고 알려줘요.\n\n그럼 이제 나머지 Vite 애플리케이션 부분을 클라이언트 전용(Client-only)으로 옮겨볼게요. 다음처럼 작성하면 Next.js에서 클라이언트 전용 컴포넌트를 쉽게 다룰 수 있어요.\n\n```jsx\n'use client'\n\nimport React from 'react'\nimport dynamic from 'next/dynamic'\n\nconst App = dynamic(() => import('../../App'), { ssr: false })\n\nexport function ClientOnly() {\n  return <App />\n}\n```\n\n여기서 핵심은 `dynamic` 함수를 쓰면서 `{ ssr: false }` 옵션을 넣는 부분이에요. 이걸 통해서 서버 사이드 렌더링(SSR)을 비활성화하고, 해당 컴포넌트를 클라이언트에서만 불러오도록 설정합니다. 보통 Vite처럼 클라이언트 전용 라이브러리를 사용할 때 이렇게 하면 에러 없이 잘 작동하죠.\n\n또, `'use client'` 디렉티브를 최상단에 넣는 것도 잊지 마세요. 이건 Next.js 13 버전부터 도입된 문법인데, 해당 파일이 클라이언트 컴포넌트임을 명시해줍니다.\n\n---\n\n**TIP**: 클라이언트 컴포넌트를 이렇게 분리해서 관리하면 서버 컴포넌트와 클라이언트 컴포넌트의 역할 분담이 명확해져서 유지보수도 훨씬 쉬워져요. 또한, 초기 페이지 로딩 속도도 더 좋아질 수 있으니 적극 추천합니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 파일은 `use client` 지시어로 정의된 클라이언트 컴포넌트입니다. 클라이언트 컴포넌트라도 Next.js에서는 처음에 서버에서 HTML로 프리렌더링한 후 클라이언트에 전달해요.\n\n하지만 클라이언트에서만 동작하는 애플리케이션을 만들고 싶다면, App 컴포넌트부터 시작해서 전체적으로 프리렌더링을 비활성화할 수 있어요. 이렇게 하면 서버에서는 HTML을 만들지 않고, 클라이언트에서만 렌더링하게 됩니다.\n\n```js\nconst App = dynamic(() => import('../../App'), { ssr: false })\n```\n\n위 코드에서 `dynamic`을 사용하여 App 컴포넌트를 불러오면서 `{ ssr: false }` 옵션을 줬는데요, 이 옵션이 서버 사이드 렌더링을 끄는 역할을 해요.\n\n그 다음에는 진입점(entrypoint) 페이지를 이제 이 동적으로 불러온 `App` 컴포넌트로 교체해주면 됩니다!\n\n> 참고로, 클라이언트 전용 애플리케이션을 만들 때는 서버에서 처리할 필요가 없으니 이렇게 `ssr: false`를 설정하는 게 퍼포먼스 향상에도 도움이 돼요. 하지만 SEO가 중요한 페이지라면 신중하게 사용해야겠죠.  \n\n필요하면 아래처럼 진입점 페이지에서 바로 사용해보세요.\n\n```js\nimport dynamic from 'next/dynamic'\n\nconst App = dynamic(() => import('../../App'), { ssr: false })\n\nexport default function Page() {\n  return <App />\n}\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js와 Vite에서 정적 이미지(import) 다루는 방법이 조금 달라요. Vite에서는 이미지를 import 하면, 프로덕션 빌드 시 이미지의 URL 문자열이 반환돼서 바로 img 태그의 src에 쓸 수 있죠.\n\n```js\nimport image from './img.png' // 빌드 후에는 '/assets/img.2d8efhg.png' 같은 URL이 됨\n\nexport default function App() {\n  return <img src={image} />\n}\n```\n\n근데 Next.js는 이런 식으로 바로 이미지 URL을 가져오는 게 아니라, `next/image` 컴포넌트를 이용해서 이미지 최적화 기능을 활용하도록 권장해요. 만약 그냥 정적 파일처럼 사용하고 싶으면 Next.js의 `public` 폴더에 이미지를 넣고 URL로 접근하는 게 가장 깔끔하답니다.\n\n예를 들어, `public/img.png`에 이미지를 넣었다면:\n\n```jsx\nexport default function App() {\n  return <img src=\"/img.png\" alt=\"example\" />\n}\n```\n\n아니면 Next.js의 Image 컴포넌트를 써서 자동으로 크기 조정, 최적화 기능을 쓰는 것도 좋아요:\n\n```jsx\nimport Image from 'next/image'\nimport img from '../public/img.png'\n\nexport default function App() {\n  return <Image src={img} alt=\"example\" />\n}\n```\n\n이렇게 하면 이미지가 자동으로 최적화되고 레이지 로딩도 적용돼서 퍼포먼스에 유리해요.\n\n---\n\n> **Tip!**  \n> Next.js에서 이미지를 정적으로 import 하려면 `next.config.js`에서 `images` 설정을 잘 해줘야 하는 경우도 있어요. 그리고 외부 URL의 이미지를 쓰려면 도메인을 허용해줘야 하죠.  \n> 이미지 최적화나 로딩 속도가 신경 쓰인다면 `next/image` 컴포넌트를 적극 활용해보세요!\n\n---\n\n결론적으로 Vite처럼 이미지 import 해서 바로 URL 받는 방식은 Next.js에선 조금 다르게 다뤄진다고 생각하면 돼요. 상황에 따라 `public` 폴더에 넣거나, `next/image`를 쓰는 두 가지 방법 중 선택하면 됩니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서 이미지 파일을 정적으로 import하면, 이미지가 객체(object)로 반환돼요. 이 객체는 Next.js의 `Image` 컴포넌트에서 바로 사용할 수도 있고, 기존에 쓰던 `img` 태그에서는 이 객체의 `src` 속성만 꺼내서 쓸 수도 있답니다.\n\n`Image` 컴포넌트의 장점은 자동 이미지 최적화가 된다는 것! 그리고 이미지의 실제 크기를 기반으로 `width`, `height` 속성을 자동으로 넣어줘서 이미지가 로딩될 때 레이아웃이 갑자기 바뀌는 문제(layout shift)를 막아줘요. 다만 주의할 점은 이미지의 한 쪽 치수만 스타일링하고 다른 쪽은 auto로 두지 않으면, 그 치수가 `img` 태그에 자동으로 들어간 크기로 고정돼서 이미지가 왜곡될 수 있다는 거예요.\n\n그래서 기존 `img` 태그를 유지하면 코드 변경량도 줄일 수 있고, 위 문제도 피할 수 있죠. 나중에 필요하면 `Image` 컴포넌트로 단계별 마이그레이션을 할 수 있어요. 이때 직접 로더(loader)를 설정하거나, Next.js 기본 서버를 사용하면 자동 이미지 최적화를 편리하게 활용할 수 있답니다.\n\n끝으로 `/public` 폴더에서 절대경로로 이미지를 import했다면, 상대경로로 바꾸는 것도 잊지 마세요. 이렇게 하면 관리도 더 편해지고 빌드 과정에서 문제도 줄일 수 있어요!\n\n---\n\n### 정리\n\n| 방법                         | 장점                             | 주의 사항                              |\n|----------------------------|--------------------------------|-----------------------------------|\n| `Image` 컴포넌트 사용          | 자동 이미지 최적화, 레이아웃 안정성 확보     | 한쪽 치수만 스타일링 시 이미지 왜곡 가능성         |\n| 기존 `img` 태그 유지           | 코드 변경 최소화, 왜곡 문제 없음           | 이미지 최적화 기능은 직접 구현해야 함           |\n| `/public`에서 이미지 경로 변경  | 경로 관리 용이, 빌드 시 문제 감소         | 절대경로 -> 상대경로 수정 필요               |\n\n---\n\n### 추가 팁: 이미지 최적화 옵션\nNext.js의 `Image` 컴포넌트는 기본적으로 자동 최적화를 지원하지만, 필요하면 `loader`를 정의해 좀 더 세밀한 설정도 가능해요. 예를 들어 외부 이미지 호스팅 서비스를 함께 쓸 때 유용하죠. 혹은 next.config.js에서 domains 옵션에 외부 도메인을 추가해주면, 더 다양한 이미지를 `Image` 컴포넌트로 불러올 수 있습니다.\n\n---\n\n필요에 따라 `Image` 컴포넌트의 장점과 한계를 잘 고려해서 사용하면, 퍼포먼스도 챙기고 개발도 부드럽게 할 수 있어요! 궁금한 점 있으면 언제든 질문 주세요~\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n자바스크립트 코드에서 이미지 파일을 불러올 때 경로나 방식이 조금 바뀌면서 주의할 점들을 정리해봤어요.\n\n---\n\n### 1. 이미지 파일 import 경로 변경하기\n\n```js\n// 이전 방식\nimport logo from '/logo.png'\n\n// 변경된 방식\nimport logo from '../public/logo.png'\n```\n\n이전에는 루트부터 바로 경로를 지정했다면, 이제는 public 폴더를 기준으로 상대 경로를 명확히 써주는 게 좋아요. 그렇지 않으면 이미지가 제대로 불러와지지 않을 수도 있어요.\n\n---\n\n### 2. `img` 태그에 `src` 속성 넘길 때 주의하기\n\n```js\n// 이전 방식\n<img src={logo} />\n\n// 변경된 방식\n<img src={logo.src} />\n```\n\nimport 한 이미지 객체 전체를 `src`에 넘기면 안 되고, 그 안에 실제 URL이 담긴 `.src` 값을 넘겨줘야 이미지가 화면에 제대로 뜹니다.\n\n---\n\n### 3. 대안: 직접 public 폴더 경로 지정하기\n\n이미지 파일이 `public/logo.png`에 있다면, 그냥 `src=\"/logo.png\"`로 바로 작성해도 됩니다.\n\n```js\n<img src=\"/logo.png\" />\n```\n\n이렇게 작성하면 이미지가 `public` 폴더 안에서 찾아지게 되는데, 간단하게 이미지 경로를 관리할 수 있는 방법이기도 해요. 다만, 이 경우 import 없이 스트링 경로를 직접 넣는 형태라는 점 참고하세요.\n\n---\n\n### 추가 팁\n\n- 만약 프로젝트가 Next.js 같은 프레임워크라면 `public` 폴더의 파일은 빌드 시 그대로 공개 경로로 복사돼서 `/이미지이름`으로 접근 가능합니다.\n- 자주 사용하는 공용 이미지들은 `public` 폴더에 모아두는 게 관리도 편하고, 빌드에도 영향을 덜 주는 편이에요.\n- 상대 경로 작성 시 `..` 여러 개를 써야 할 때 헷갈리기 쉬우니, VS Code 같은 편집기의 경로 자동완성기능을 적극 활용하면 좋아요.\n\n---\n\n이제 이미지를 불러올 때 경로 문제로 에러 뜨는 일은 조금 줄어들 거예요! 자~ 다음 프로젝트 때 적용해 보세요. :)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n> 경고: 만약 TypeScript를 사용 중이라면 src 속성에 접근할 때 타입 에러가 발생할 수 있어요. 지금은 무시해도 괜찮고, 이 가이드를 마칠 즈음에는 모두 해결될 테니 걱정 마세요.\n\n### 7단계: 환경 변수 마이그레이션하기\n\nNext.js도 Vite처럼 `.env` 파일을 통해 환경 변수를 관리할 수 있어요. 그런데 크게 차이나는 부분이 하나 있는데, 바로 클라이언트 쪽에서 노출되는 환경 변수에 붙는 접두사(prefix)에요.\n\n| Vite                  | Next.js              |\n|-----------------------|----------------------|\n| `VITE_` (접두사)       | `NEXT_PUBLIC_` (접두사) |\n\n즉, Vite에서 `VITE_`로 시작하는 환경 변수들은 Next.js에서는 `NEXT_PUBLIC_`로 바꿔줘야 클라이언트 사이드 코드에서 접근할 수 있어요. 예를 들어:\n\n```js\n# Vite 환경 변수\nVITE_API_URL=https://api.example.com\n```\n\n위 변수는 Next.js로 옮길 때 이렇게 바꿔줘야 해요:\n\n```js\n# Next.js 환경 변수\nNEXT_PUBLIC_API_URL=https://api.example.com\n```\n\n이걸 꼭 지켜야 클라이언트에서 `process.env.NEXT_PUBLIC_API_URL`로 안전하게 접근할 수 있어요. 만약 접두사를 안 바꾸면 클라이언트 쪽에 변수가 노출되지 않아서 참조할 수 없게 돼요.\n\n---\n\n**추가 팁!**  \n환경 변수를 사용할 때 중요한 건, 민감한 정보(ex: API 키, 비밀번호 등)는 절대 클라이언트에 노출시키면 안 돼요. `NEXT_PUBLIC_` 붙은 변수는 클라이언트에서 볼 수 있기 때문에, 민감 데이터를 담기엔 적합하지 않답니다. 서버 전용 변수는 접두사 없이 그냥 `process.env`에서 바로 사용하세요.\n\n---\n\n앞으로 계속 환경 변수를 변경하면서도, 변수 이름을 이렇게 맞춰주는 게 Next.js와 Vite를 함께 쓰거나 Next.js로 이전할 때 발생하는 흔한 실수 중 하나예요. 신경 써서 관리하면 빌드 문제나 런타임 오류를 줄일 수 있어요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nVite에서는 특별한 import.meta.env 객체를 통해 몇 가지 내장 환경 변수를 제공하는데, Next.js는 이 부분을 지원하지 않아요. 그래서 Vite에서 쓰던 환경 변수들을 Next.js에 맞게 이렇게 바꿔줘야 해요.\n\n| Vite (import.meta.env)       | Next.js (process.env)                  |\n|-----------------------------|--------------------------------------|\n| import.meta.env.MODE         | process.env.NODE_ENV                  |\n| import.meta.env.PROD         | process.env.NODE_ENV === 'production'|\n| import.meta.env.DEV          | process.env.NODE_ENV !== 'production'|\n| import.meta.env.SSR          | typeof window === 'undefined'        |\n\n여기서 살짝 팁을 드리자면, import.meta.env.SSR 은 서버 사이드 렌더링 여부를 체크하기 위한 변수인데, Next.js에서는 window 객체가 없으면 서버 환경으로 인식할 수 있으니 `typeof window === 'undefined'` 로 체크해주면 됩니다.\n\n그리고 한 가지 더! Next.js는 기본적으로 Vite에 있는 BASE_URL 같은 환경 변수를 제공하지 않아요. 하지만 직접 환경 변수를 만들어서 쓸 수는 있답니다. 방법은 간단해요, 프로젝트 루트에 `.env` 파일을 만들고 아래처럼 추가해주시면 됩니다.\n\n```js\nNEXT_PUBLIC_BASE_URL=https://your-domain.com\n```\n\n여기서 NEXT_PUBLIC_ 접두어는 Next.js에서 브라우저 코드에서도 접근할 수 있는 환경 변수를 의미해요. 만약 서버에서만 쓸 거라면 접두어 없이 그냥 선언하면 되고요.\n\n이렇게 하면 코드에서 `process.env.NEXT_PUBLIC_BASE_URL` 로 접근해서 사용할 수 있어요. 예를 들어 API 엔드포인트를 설정할 때 유용하답니다.\n\n정리하자면, Vite에서 Next.js로 넘어올 때 환경 변수 관련 코드를 이렇게 바꿔주시고, 필요한 환경 변수들은 직접 `.env` 파일에 추가해서 관리하시면 됩니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서 기본 경로(basePath)를 환경 변수로 설정하는 방법에 대해 공유할게요. 프로젝트를 하다 보면 `basePath`를 동적으로 설정해야 할 경우가 있는데, 예를 들어 CDN이나 특정 경로에 배포할 때 유용하죠.\n\n### 1. `.env` 파일에 환경 변수 설정하기\n\n```js\nNEXT_PUBLIC_BASE_PATH=\"/some-base-path\"\n```\n\n여기서 중요한 점! `NEXT_PUBLIC_` 접두어로 시작해야 클라이언트 쪽에서도 접근 가능해요.\n\n### 2. `next.config.mjs` 파일에서 basePath 설정하기\n\n다음과 같이 `next.config.mjs`에 `basePath`를 환경 변수로 불러와 세팅해 주세요.\n\n```js\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  output: 'export',      // SPA 형태로 빌드\n  distDir: './dist',     // 빌드 결과물을 'dist' 폴더로 변경\n  basePath: process.env.NEXT_PUBLIC_BASE_PATH,   // env 변수를 basePath로 설정!\n}\n\nexport default nextConfig\n```\n\n> TIP: `next.config.mjs`에서 import.meta.env 대신 `process.env`를 사용해야 하는 점 잊지 마세요. Next.js는 빌드 타임에 `process.env`로 환경 변수값을 주입합니다.\n\n### 3. 코드 내에서 `import.meta.env.BASE_URL` -> `process.env.NEXT_PUBLIC_BASE_PATH`로 변경\n\n기존에 `import.meta.env.BASE_URL` 을 사용하던 부분이 있다면, `process.env.NEXT_PUBLIC_BASE_PATH`로 바꿔줘야 합니다. 이 부분은 Vite 등 다른 빌드 시스템과 차이가 있어요.\n\n```js\nconst basePath = process.env.NEXT_PUBLIC_BASE_PATH || ''\n\n// 사용 예\nconst fullUrl = `${basePath}/some-resource`\n```\n\n### 정리하자면\n\n| 단계               | 설명                                 |\n|-------------------|------------------------------------|\n| 1. env 파일 만들기    | `NEXT_PUBLIC_BASE_PATH` 설정          |\n| 2. next.config.mjs 수정 | `basePath`에 `process.env.NEXT_PUBLIC_BASE_PATH` 지정 |\n| 3. 코드 수정           | `import.meta.env.BASE_URL` → `process.env.NEXT_PUBLIC_BASE_PATH` |\n\n---\n\n이렇게 하면 빌드할 때마다 환경 변수로 기본 경로를 바꾸는 게 가능해져서 다양한 배포 환경에 유연하게 대응할 수 있습니다. Next.js 프로젝트 하면서 경로 문제에 한 번쯤 고민해보셨다면 참고하세요~! 필요하면 basePath 외에도 `assetPrefix`도 같이 고려하는 게 좋아요. 그럼 즐코딩~! 🚀\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 8단계: package.json 스크립트 업데이트하기\n\n이제 Next.js로 마이그레이션을 잘 했는지 확인하기 위해 애플리케이션을 실행해볼 수 있어요. 그런데 그 전에 package.json 안의 스크립트를 Next.js에 맞게 살짝 바꿔줘야 합니다. \n\n기존에 있던 start나 build 명령어 대신 Next.js 명령어를 넣어주면 되는데요:\n\n```json\n{\n  \"scripts\": {\n    \"dev\": \"next dev\",\n    \"build\": \"next build\",\n    \"start\": \"next start\"\n  }\n}\n```\n\n- `\"dev\"`: 개발 모드로 로컬 서버를 띄울 때 사용해요 (hot reload도 지원해서 개발할 때 편리해요)\n- `\"build\"`: 배포 전, 프로덕션용으로 최적화된 빌드를 생성할 때 쓰입니다.\n- `\"start\"`: 빌드된 결과물을 실제 서비스 환경에서 실행할 때 사용하죠.\n\n그리고 Git 관리할 때 필요 없는 파일들을 깃에서 제외하기 위하여 `.gitignore` 파일에도 다음 내용을 추가해주세요:\n\n\n.next\nnext-env.d.ts\ndist\n\n\n- `.next` 폴더는 Next.js가 빌드하면서 생성하는 임시파일들이라 보통 Git에 올리지 않아요.\n- `next-env.d.ts`는 Next.js 타입 지원을 위한 선언 파일로, 자동 생성되므로 따로 관리하지 않습니다.\n- `dist`는 프로젝트마다 다르지만, 빌드 후 결과를 담고 있는 폴더라면 역시 빼는 게 좋습니다.\n\n참고로, `.gitignore`에 이런 빌드 결과 파일들을 미리 넣어두면 협업할 때 불필요한 충돌도 줄일 수 있어요. 다음 단계에서는 이렇게 설정한 상태에서 실제로 `npm run dev` 명령어로 개발 서버를 실행해보면서 잘 작동하는지 확인해보세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 터미널에서 `npm run dev` 명령어를 실행하고, http://localhost:3000 에 접속해 보세요. 그러면 당신의 Next.js 애플리케이션이 잘 실행되고 있는 모습을 확인할 수 있을 거예요.\n\n> 참고로, Vite로 만들어진 애플리케이션을 Next.js로 마이그레이션한 실제 예제를 보고 싶다면 이 [Pull Request](https://github.com/vercel/next.js/pull/####)를 확인해 보세요. (원문에 링크가 있다면 여기에 넣어주세요.)\n\n### 9단계: 정리하기\n\n이제 Vite 관련 파일들이나 설정들은 모두 정리할 차례입니다. 프로젝트에서 Vite와 관련된 불필요한 것들을 깔끔하게 제거해서 코드베이스를 정돈해 주세요!\n\n예를 들어, 다음과 같은 것들을 확인하시면 좋아요:\n\n| 제거 대상                     | 설명                              |\n|------------------------------|----------------------------------|\n| `vite.config.js`              | Vite 설정 파일                   |\n| `index.html`                  | Vite에서 사용했던 진입 HTML 파일 |\n| `package.json`의 Vite 관련 의존성 | `vite`, `@vitejs/plugin-react` 등 |\n| 기타 Vite 전용 스크립트       | 빌드 스크립트나 개발 서버 관련 설정 |\n\n이렇게 정리하고 나면 Next.js만 사용하는 깔끔한 환경을 만들 수 있습니다.\n\n---\n\n만약 다음 단계가 궁금하다면, Next.js의 배포나 최적화 방법 등을 함께 알아보는 것도 추천합니다. Next.js는 기본적으로 SSR(서버 사이드 렌더링)과 SSG(정적 사이트 생성), 그리고 CSR(클라이언트 사이드 렌더링)을 유연하게 사용할 수 있어서 애플리케이션을 더 빠르고 SEO 친화적으로 만들어 주거든요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- main.tsx 삭제  \n- index.html 삭제  \n- vite-env.d.ts 삭제  \n- tsconfig.node.json 삭제  \n- vite.config.ts 삭제  \n- Vite 관련 의존성 제거  \n\n## 다음 단계\n\n만약 지금까지 작업이 잘 됐다면, 이제 Next.js를 기반으로 동작하는 싱글 페이지 애플리케이션을 갖게 된 거예요. 하지만 아직 Next.js가 제공하는 많은 장점들을 완전히 활용하고 있진 않은 상태입니다. 이제부터 점진적으로 개선하면서 Next.js의 진가를 맛보실 수 있는데요, 다음 단계로 고려해볼 만한 사항들을 소개할게요:\n\n| 다음 단계 | 설명 |\n| --- | --- |\n| React Router에서 Next.js App Router로 마이그레이션 | - 자동 코드 분할로 초기 로딩 속도 개선<br>- 스트리밍 서버 사이드 렌더링 지원<br>- React 서버 컴포넌트 활용 가능 |\n| 이미지 최적화 | Next.js `Image` 컴포넌트로 자동 최적화된 이미지 제공 |\n| 폰트 최적화 | `next/font`를 활용해 폰트 로딩 속도 및 성능 개선 가능 |\n| 서드파티 스크립트 최적화 | Next.js `Script` 컴포넌트로 외부 스크립트 로딩 최적화 |\n| ESLint 설정 업데이트 | Next.js 규칙을 지원하도록 ESLint를 구성하여 코드 품질 유지 |\n\n---\n\n여기서 한 가지 팁을 추가하자면, Next.js의 App Router는 전통적인 React Router보다 많은 부분에서 성능과 개발 경험을 향상시키는데요. 특히 서버 컴포넌트(Server Components)를 적극 활용하면 클라이언트에서 불필요한 자바스크립트가 줄어들어 사용자 경험이 좋아집니다. 그리고 이미지나 폰트 최적화는 SEO와 사용자 경험에 직접적인 영향을 주기 때문에 꼭 챙겨보시길 추천드립니다!\n\n조금씩 바꾸면서 Next.js 애플리케이션의 진정한 잠재력을 느껴보세요. 궁금한 점이 있으면 언제든 질문해 주세요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":39},{"title":"Create React App에서 Next.js 15로 마이그레이션하는 과정 정리","description":"","date":"2025-04-22 01:26","slug":"2025-04-22-HowtomigratefromCreateReactApptoNextjs","content":"\n\n# Create React App에서 Next.js로 마이그레이션하는 방법\n\n안녕하세요! 오늘은 여러분이 기존에 만들었던 Create React App(CRA) 프로젝트를 Next.js로 옮기는 과정을 쉽게 도와드리려고 해요. React로 만든 프로젝트를 좀 더 강력하고 효율적으로 운영하고 싶다면 Next.js를 고려해볼 만한데요, 그 이유부터 살펴볼게요.\n\n## 왜 Next.js로 갈아탈까?\n\nCreate React App도 충분히 좋은 툴이지만, Next.js가 제공하는 몇 가지 장점 때문에 많은 분들이 이동하고 있어요:\n\n| 이유 | 설명 |\n|---|---|\n| **서버 사이드 렌더링(SSR)** | Next.js는 서버에서 미리 페이지를 렌더링해서 SEO 최적화와 초기 로딩 속도를 개선해줍니다. 단순히 SPA보다 빠르고 검색 엔진 친화적이에요. |\n| **파일 기반 라우팅** | 별도의 라우팅 설정 없이 `pages` 폴더 내 파일 이름만으로 라우팅이 자동 설정돼서 개발이 훨씬 수월해요. |\n| **정적 사이트 생성(SSG)** | 빌드 시 HTML 페이지를 미리 생성해두고 빠르게 서빙할 수 있어요. 블로그나 홍보 사이트에 딱이죠. |\n| **API 라우트 내장** | 백엔드 API도 Next.js 안에서 바로 만들 수 있어, 풀스택 개발까지 한 번에! |\n| **이미지 최적화** | Next.js 에서 제공하는 `<Image />` 컴포넌트로 자동 이미지 최적화 기능을 쓸 수 있어요. |\n\n이 외에도 커뮤니티 지원, 최신 React 기능과 완벽 연동 등 다양한 이유가 있지만, 대략 이대로만 알아도 충분히 넘어갈 동기부여가 되죠?\n\n다음에는 본격적으로 CRA 프로젝트를 Next.js로 옮기는 구체적인 단계를 천천히 살펴볼게요. \n\n궁금한 점 있으면 댓글로 알려주세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 느린 초기 페이지 로딩 시간\n\nCreate React App은 순수하게 클라이언트 사이드 React를 사용해요. 이렇게 클라이언트 사이드에서만 동작하는 앱, 즉 싱글 페이지 애플리케이션(SPA)은 초기 페이지 로딩이 느려질 때가 많답니다. 왜 그런지 간단히 살펴볼게요.\n\n- 브라우저가 React 코드와 여러분의 애플리케이션 전체 번들을 다 다운로드하고 실행해야만, 데이터 요청을 보낼 수 있어요.\n- 그리고 새로운 기능이나 라이브러리를 추가할수록 애플리케이션 코드가 점점 커지고요.\n\n이런 이유들 때문에 처음 앱을 켤 때 로딩 속도가 느려질 수 있죠.\n\n---\n\n### 자동 코드 분할(Automatic Code Splitting)이 없어요\n\nCreate React App은 기본적으로 자동 코드 분할 기능을 제공하지 않아요. 자동 코드 분할이란, 사용자가 필요로 하는 코드만 그때그때 불러오는 기술을 말하는데요, 이렇게 하면 초기 다운로드 크기를 줄여서 빠르게 화면을 보여줄 수 있습니다.\n\n하지만 Create React App에서는 이런 기능이 자동으로 적용되지 않다 보니, 모든 코드가 한꺼번에 번들링되어 초기 로딩 시간이 길어지는 문제가 생기죠.\n\n---\n\n#### 추가 팁! 빠른 로딩을 위한 대안\n\n- **React.lazy와 Suspense 활용하기:** 수동으로 코드 분할을 적용해 볼 수 있어요. 페이지나 컴포넌트를 동적으로 불러와 초기 로딩 시간을 줄일 수 있답니다.\n- **서버 사이드 렌더링(SSR) 도입:** Next.js 같은 프레임워크를 사용하면 서버에서 미리 HTML을 만들어 보내주기 때문에, 사용자는 빠르게 콘텐츠를 볼 수 있어요.\n- **번들 사이즈 최적화:** 사용하지 않는 라이브러리를 제거하거나, 필요한 부분만 가져오는 트리 쉐이킹(tree shaking)을 신경 써서 코드 크기를 줄여보세요.\n\n---\n\n이렇게 SPA에서 초기 로딩 시간이 느린 원인과 해결 방안을 알아봤는데, 여러분의 프로젝트 상황에 맞게 적절한 방법을 골라 적용해 보세요. 웹 앱 사용성 개선에 큰 도움이 될 거예요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이전 글에서 언급한 느린 로딩 문제는 코드 분할(code splitting)로 어느 정도 해결할 수 있어요. 하지만 직접 수동으로 코드 분할을 하려고 하면 오히려 네트워크 워터폴(network waterfall) 같은 비효율적인 요청 흐름이 생길 수 있습니다. 다행히 Next.js는 라우터와 빌드 파이프라인에 자동 코드 분할과 트리 쉐이킹(tree shaking)을 기본으로 지원해서 이런 문제를 덜어줍니다.\n\n### 네트워크 워터폴(Network waterfalls)이란?\n\n네트워크 워터폴은 앱이 클라이언트와 서버 사이에 연속적으로 요청을 보내면서 성능이 저하되는 상황을 말해요. SPA에서 흔히 볼 수 있는 패턴 중 하나는, 컴포넌트가 먼저 플레이스홀더(자리 표시자)를 렌더링하고, 그 후에 데이터를 가져오는 식이죠. 그런데 문제는, 자식 컴포넌트가 데이터를 가져오기 시작하려면 부모 컴포넌트가 자기 데이터를 다 받아야 하니까 여러 요청이 순차적으로 이어지면서 딜레이가 예상보다 커지는 거에요. 이게 바로 '워터폴'이에요.\n\nNext.js는 클라이언트 사이드에서 데이터 패칭을 지원하지만, 더욱 중요한 점은 서버 사이드로 데이터 패칭을 옮길 수 있게 해 준다는 겁니다. 이렇게 서버에서 미리 데이터를 받아오면, 클라이언트-서버 간의 여러 번의 연속 요청이 아예 없어지거나 크게 줄어들어 워터폴 문제가 대부분 해결되죠.\n\n덧붙여서, Next.js의 getServerSideProps나 getStaticProps 같은 서버 데이터 페칭 메서드를 이용하면 SEO에도 유리하고, 사용자 입장에서도 초기 페이지 로딩 속도가 확실히 좋아지는 걸 체감할 수 있으니 꼭 활용해보시길 추천해요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 빠르고 의도적인 로딩 상태 관리\n\nReact Suspense 덕분에 스트리밍 기능이 내장되어 있어서, UI의 어떤 부분을 먼저 로드할지 그리고 어떤 순서로 로드할지 직접 정할 수 있어요. 덕분에 네트워크 병목 현상을 줄이고, 페이지가 훨씬 빠르게 로딩되도록 만들 수 있죠.\n\n또한 이렇게 하면 화면이 갑자기 바뀌는 레이아웃 시프트(layout shift)를 최소화해서 사용자 경험을 한층 더 부드럽게 만들 수 있답니다.\n\n### 데이터 가져오기 전략 선택하기\n\n여러분이 데이터를 어떻게 가져올지, 즉 데이터 패칭 전략(data fetching strategy)을 선택하는 것도 중요한 부분이에요. API 호출을 어디서, 어떻게 할지 결정하면 성능과 사용자 경험 모두에 큰 영향을 끼치거든요.\n\n예를 들어, 서버 사이드 렌더링(SSR), 정적 사이트 생성(SSG), 클라이언트 사이드 렌더링(CSR) 같은 다양한 패턴 중 상황에 맞는 방법을 선택해서 사용하는 것이죠.\n\n---\n\n만약 React Suspense와 데이터 패칭 방법에 대해 더 궁금하시다면, 이 두 가지를 조합해서 어떻게 더욱 빠르고 안정적인 웹 앱을 만드는지 사례와 함께 설명해 드릴게요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js는 필요에 따라 페이지나 컴포넌트 단위로 데이터 가져오기 방식을 선택할 수 있게 해줘요. 예를 들어, CMS에서 데이터를 가져와 빌드 시점에 블로그 글을 렌더링하는 방식을 사용할 수 있는데, 이걸 SSG(Static Site Generation)라고 부르고요. 이렇게 하면 페이지 로딩 속도가 훨씬 빨라집니다. 반면, 사용자 요청 시점에 데이터를 가져오는 SSR(Server Side Rendering)을 써야 할 경우도 있죠. 이건 예를 들어, 사용자마다 다른 데이터를 보여줘야 할 때 유용해요.\n\n### 미들웨어 (Middleware)\n\nNext.js의 미들웨어는 서버에서 요청이 완성되기 전에 코드를 실행할 수 있게 해줘요. 예를 들어보면, 로그인한 사용자만 볼 수 있는 페이지에서 비로그인 상태의 사용자가 접근하려 할 때, 미들웨어에서 로그인 페이지로 바로 리다이렉트 시켜 ‘비인증 콘텐츠가 잠깐 보이는 현상(플래시)’을 막을 수 있죠. 이외에도 A/B 테스트, 실험 기능, 다국어 지원 등에도 활용할 수 있어요.\n\n### 내장 최적화 기능 (Built-in Optimizations)\n\nNext.js는 기본적으로 다양한 최적화 기능들이 내장돼 있어요. 예를 들어, 이미지를 자동으로 최적화하거나, 코드 분할을 통해 불필요한 코드가 로드되지 않게 하죠. 이런 최적화 덕분에 개발자는 성능에 크게 신경 쓰지 않아도 훌륭한 사용자 경험을 제공할 수 있습니다.\n\n> 개인적으로는 미들웨어를 적극적으로 활용하는 걸 추천해요. 미들웨어 덕분에 서버 단에서 많은 제어가 가능해지고, 보안이나 UX 향상에 큰 도움이 되니까요.\n\n추가로 궁금한 점 있으면 언제든 질문해 주세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이미지, 폰트, 그리고 서드파티(3rd-party) 스크립트는 애플리케이션 성능에 큰 영향을 미칠 수 있어요. 다행히 Next.js에는 이런 리소스들을 자동으로 최적화해주는 특화된 컴포넌트와 API들이 내장되어 있답니다.\n\n## 마이그레이션 단계\n\n우리 목표는 최대한 빠르게 동작하는 Next.js 애플리케이션을 만드는 거예요. 그렇게 하면 Next.js의 여러 기능을 한꺼번에 도입하는 대신, 단계적으로 천천히 적용해 나갈 수 있답니다. 처음에는 기존 라우터를 바로 바꾸지 않고, 순수 클라이언트 사이드 애플리케이션(SPA)처럼 다루면서 시작할 거예요. 이렇게 하면 복잡함도 줄어들고, 코드 머지할 때 충돌도 최소화할 수 있죠.\n\n> 참고: 만약 CRA(Create React App)에서 package.json의 커스텀 홈페이지 설정, 서비스 워커, 또는 Babel/webpack 세부 조정 같은 고급 설정을 사용 중이라면, 이 가이드 맨 마지막 ‘추가 고려사항’ 섹션을 꼭 확인해 보세요. Next.js로 넘어갈 때 이런 설정들을 어떻게 비슷하게 구현하거나 다르게 적용할지 도움이 될 거예요.\n\n---\n\n그리고 한 가지 덧붙이자면, Next.js의 이미지 최적화 컴포넌트(next/image)는 기본적으로 레이지 로딩(lazy loading)을 지원해서 초기 로드 시간을 줄여주고, 폰트 최적화(next/font)는 폰트 로딩 방식도 개선해 줘서 사용자 경험 향상에도 한 몫 한답니다. 그러니 마이그레이션하면서 자연스럽게 퍼포먼스도 같이 챙길 수 있다는 점, 꼭 기억하세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### Step 1: Next.js 설치하기\n\n기존 프로젝트에 Next.js를 설치하려면 터미널에 아래 명령어를 입력하세요:\n\n```bash\nnpm install next@latest\n```\n\n여기서 `next@latest`는 최신 버전의 Next.js를 설치한다는 의미예요. Next.js는 React 기반의 프레임워크로, 서버 사이드 렌더링(SSR)과 정적 사이트 생성(SSG)을 지원해서 빠르고 SEO 친화적인 웹사이트를 만들 때 유용하답니다.\n\n### Step 2: Next.js 설정 파일 만들기\n\nNext.js를 제대로 활용하려면 프로젝트 루트에 `next.config.js` 파일을 만들어서 필요한 설정을 추가해야 해요. 예를 들어, 커스텀 환경변수나 빌드 옵션을 설정할 때 이 파일을 사용하죠.\n\n```js\n// next.config.js\nmodule.exports = {\n  reactStrictMode: true, // React의 엄격 모드 활성화\n  // 여기서 추가 설정을 해보세요!\n};\n```\n\n처음에는 간단하게 `reactStrictMode`만 설정해도 충분해요. 개발 중에 React의 잠재적인 문제를 알려주기 때문에 디버깅할 때 도움이 많이 된답니다.\n\n> 참고로, Next.js에서는 `pages` 폴더 안에 React 컴포넌트를 파일로 작성하면 자동으로 라우팅이 설정되니까, 라우팅 관련 설정은 따로 안 해도 돼요.\n\n다음 단계에서는 페이지를 만들어서 직접 Next.js의 구조를 체험해보면 좋아요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프로젝트 루트 폴더(보통 package.json 파일과 같은 위치)에 `next.config.ts` 파일을 만들어 주세요. 이 파일은 Next.js의 설정 옵션을 담는 곳이에요.\n\n```ts\nimport type { NextConfig } from 'next'\n\nconst nextConfig: NextConfig = {\n  output: 'export', // SPA(Single-Page Application)로 결과물을 내보내겠다는 뜻이에요.\n  distDir: 'build',   // 빌드 결과물이 저장되는 폴더를 기본 '.next' 대신 'build'로 바꿔줘요.\n}\n\nexport default nextConfig\n```\n\n> 참고! 여기서 `output: 'export'`를 설정하면, 정적 사이트로 내보내는 거예요. 그래서 서버사이드 렌더링(SSR)이나 API 같은 서버 기능은 사용할 수 없답니다. 만약 이런 기능들이 필요하면 이 줄을 삭제해 주세요.\n\n---\n\n다음 단계로 루트 레이아웃 파일을 만드는 작업이 이어집니다! 필요하면 알려드릴게요 :)\n\n---\n\n추가 팁!\n\n- `distDir` 옵션을 바꾸면 빌드 폴더 이름이 바뀌어서, 배포 시 원하는 구조로 폴더를 관리하기 좋습니다.\n- Next.js에서 보통 SSR을 쓰냐 정적 export를 쓰냐는 프로젝트 성격에 따라 다르니, `output: 'export'` 설정 전에 어느 방식을 쓸지 고민해보시는 걸 추천해요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js 앱 라우터에서 꼭 필요한 게 바로 루트 레이아웃 파일이에요. 이 파일은 React Server Component 형태로 되어 있고, 앱의 모든 페이지를 감싸는 역할을 하죠.\n\n만약 CRA(Create React App) 환경에서 작업해보셨다면, 이 루트 레이아웃과 가장 비슷한 게 `public/index.html` 파일이에요. 기본적인 `html`, `head`, `body` 태그를 포함하고 있어서 앱의 뼈대를 담당하죠.\n\n그럼 Next.js에서 어떻게 만들면 될지 한번 볼게요!\n\n1. 우선 프로젝트 루트(또는 `src` 폴더 안)에 `app` 이라는 새 디렉터리를 만들어 주세요.\n\n2. 그 안에 `layout.tsx` 혹은 `layout.js` 파일을 만들고, 아래처럼 작성하면 돼요:\n\n```tsx\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"ko\">\n      <head>\n        <title>내 Next.js 앱</title>\n      </head>\n      <body>\n        {children}\n      </body>\n    </html>\n  )\n}\n```\n\n여기서 중요한 점은, 이 루트 레이아웃이 실제로 여러분의 페이지들을 감싸주는 최상위 레이아웃이라는 거예요. 그리고 `children`은 자식 컴포넌트, 즉 각 페이지들의 내용을 의미하죠.\n\n추가로, Next.js 13 App Router에서는 이 레이아웃이 서버에서 렌더링되는 ‘서버 컴포넌트’ 형태라서 SEO 최적화나 초기 렌더링 성능에 유리하답니다.\n\n**팁!**  \n`<head>` 태그 안에는 메타태그, 폰트 로드, SEO 설정 등도 함께 넣을 수 있으니 필요에 따라 꼭 활용해 보세요!  \n그리고 다국어 지원을 하려면 `<html lang=\"en\">` 처럼 `lang` 속성에도 신경 써주시면 좋고요.\n\n한마디로, Next.js 13 App Router의 `app/layout.tsx`는 옛날에 `index.html`이 맡았던 역할을 React 방식으로 훨씬 깔끔하고 유연하게 대체했다고 보면 됩니다.  \n이제 뼈대부터 잘 잡고 멋진 Next.js 프로젝트 시작해봐요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 예전의 index.html 내용을 이 `RootLayout` 컴포넌트로 옮겨보세요. 특히 body 태그 안에 있던 `div#root`와 `noscript` 부분은 다음처럼 `div id=\"root\"` 안에 `children`을 넣는 형태로 바꾸면 됩니다.\n\n```tsx\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <head>\n        <meta charSet=\"UTF-8\" />\n        <link rel=\"icon\" href=\"%PUBLIC_URL%/favicon.ico\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n        <title>React App</title>\n        <meta name=\"description\" content=\"Web site created...\" />\n      </head>\n      <body>\n        <div id=\"root\">{children}</div>\n      </body>\n    </html>\n  )\n}\n```\n\n> 참고: Next.js는 기본적으로 CRA(Create React App)의 `public/manifest.json`, 추가 아이콘들, 그리고 테스트 설정을 무시해요. 만약 이런 것들이 필요하다면, Next.js가 제공하는 Metadata API나 테스트 설정 기능을 활용해 설정할 수 있습니다.\n\n---\n\n### Step 4: Metadata\n\n다음은 메타데이터 설정 단계입니다. Next.js에서는 메타데이터를 효과적으로 관리할 수 있도록 도와주는 API가 있으니, 이를 활용하면 SEO나 웹사이트 정보 관리가 더 편리해집니다.\n\n> 추가 팁: `RootLayout` 같은 전역 레이아웃에서 메타태그를 관리하면 페이지마다 일일이 설정하지 않아도 되고, 일관성 유지에도 좋아요.\n\n필요하면 제가 메타데이터 설정 방법도 따로 정리해 드릴게요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js를 사용하다 보면, `<head>` 태그 안에 `<meta charset=\"UTF-8\" />`나 `<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />` 같은 태그들을 직접 넣지 않아도 자동으로 포함된다는 점을 알게 될 거예요. 그래서 불필요하게 중복되니까, 이런 태그들은 제거해도 OK입니다.\n\n예를 들어, 처음에는 이렇게 작성할 수도 있죠:\n\n```jsx\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <head>\n        <link rel=\"icon\" href=\"%PUBLIC_URL%/favicon.ico\" />\n        <title>React App</title>\n        <meta name=\"description\" content=\"Web site created...\" />\n      </head>\n      <body>\n        <div id=\"root\">{children}</div>\n      </body>\n    </html>\n  )\n}\n```\n\n근데 사실 favicon.ico나 icon.png, robots.txt 같은 메타데이터 파일들을 `app` 디렉토리 최상단에 넣어두면, Next.js가 자동으로 `<head>` 태그에 넣어줘요. 그러니 직접 `<link>` 태그로 선언할 필요가 없습니다.\n\n실제로 앱 디렉토리 내에 이런 파일들을 위치시키고 나서는, `<link rel=\"icon\" ... />` 부분도 지워서 훨씬 깔끔하게 만들 수 있죠:\n\n```jsx\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <head>\n        <title>React App</title>\n        <meta name=\"description\" content=\"Web site created...\" />\n      </head>\n      <body>\n        <div id=\"root\">{children}</div>\n      </body>\n    </html>\n  )\n}\n```\n\n----\n\n### 요점 정리\n\n| 항목                            | 설명                                                         |\n|-------------------------------|------------------------------------------------------------|\n| charset, viewport 메타 태그     | Next.js가 자동으로 포함해 주므로 직접 넣지 않아도 된다.                  |\n| favicon.ico, icon.png, robots.txt 등 | `app` 디렉토리 최상단에 넣어두면 자동으로 `<head>`에 추가됨. 직접 `<link>` 태그 불필요. |\n| `title`, `meta description`   | 직접 넣어야 하며, 앱에 맞게 커스터마이징 가능하다.                        |\n\n이런 자동화 덕분에 `<head>` 태그 관리가 더 쉬워지고 코드도 깔끔해지니, 꼭 활용해보세요! 😊\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마지막으로, Next.js에서는 Metadata API를 활용해서 `head` 태그를 관리할 수 있어요. 즉, 최종 메타데이터 정보를 `export`된 `metadata` 객체로 옮기면 된답니다.\n\n```js\nimport type { Metadata } from 'next'\n\nexport const metadata: Metadata = {\n  title: 'React App',\n  description: 'Web site created with Next.js.',\n}\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <body>\n        <div id=\"root\">{children}</div>\n      </body>\n    </html>\n  )\n}\n```\n\n위 코드처럼, 예전에는 `index.html` 안에서 직접 모든 메타데이터를 선언했지만, 이제는 Next.js의 프레임워크 내장 기능인 **Metadata API**를 이용하는 방식으로 전환했어요. 이 방법 덕분에 SEO(검색 엔진 최적화)와 웹 페이지 공유 시 필요한 메타 정보 관리가 훨씬 간편해집니다.\n\n> 참고로, Metadata API는 페이지 단위로 메타데이터를 설정할 수 있어서, 각 페이지마다 다른 title이나 description을 쉽게 적용할 수 있다는 점도 큰 장점이에요. 또 오픈 그래프(Open Graph) 같은 소셜 미디어 공유 정보를 추가하는 것도 수월해요!\n\n---\n\n### Step 5: Styles\n\n이제 다음 단계는 스타일을 적용하는 것이에요. Next.js에서는 CSS 모듈, 글로벌 CSS, 혹은 Tailwind CSS 같은 유틸리티 퍼스트 프레임워크 등 다양한 스타일링 방법도 지원하니, 여러분 프로젝트에 맞게 골라서 적용하면 됩니다. 앞으로 스타일을 입히는 방법도 차근차근 소개할게요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nCRA(Create React App)처럼 Next.js도 CSS Modules를 기본적으로 지원해요. 그리고 전역으로 적용되는 CSS 파일도 쉽게 불러올 수 있답니다.\n\n만약에 전역 스타일을 관리하는 CSS 파일이 있다면, 보통 `app/layout.tsx` 파일에 이렇게 불러와요:\n\n```tsx\nimport '../index.css'\n\nexport const metadata = {\n  title: 'React App',\n  description: 'Web site created with Next.js.',\n}\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <body>\n        <div id=\"root\">{children}</div>\n      </body>\n    </html>\n  )\n}\n```\n\n여기서 중요한 점은 Next.js는 CSS를 모듈 방식으로도, 전역 스타일로도 사용할 수 있어서 스타일 관리가 훨씬 자유롭다는 거예요. 예를 들어 컴포넌트 단위로 스타일을 캡슐화하고 싶으면 CSS Modules를, 전체 사이트에 공통되는 스타일은 전역 CSS 파일로 관리하면 되죠.\n\n그리고 만약 Tailwind CSS를 쓰고 싶다면, Next.js 공식 문서에서 설치 방법이 자세히 안내되어 있으니 꼭 참고하세요. Tailwind와 Next.js는 사실 찰떡궁합이라서, 빠르게 스타일링을 시작하기에 아주 좋아요!\n\n개발하면서 CSS가 헷갈릴 때는 언제든 이렇게 전역과 모듈 스타일을 적절히 섞어가며 사용해보시길 추천드려요. 그럼 스타일 관리가 훨씬 편해질 거예요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 6단계: 진입점 페이지 만들기\n\nCreate React App에서는 `src/index.tsx`(또는 `index.js`)가 진입점(entry point)이었죠. 근데 Next.js(App Router)에서는 `app` 폴더 안에 있는 각 폴더가 각각의 라우트(경로)가 되고, 그 폴더마다 `page.tsx` 파일이 꼭 있어야 해요.\n\n여기서 우리 목표는 일단 앱을 SPA(싱글 페이지 애플리케이션)처럼 유지하면서 모든 라우트를 한 곳에서 가로채고 싶어요. 그래서 Next.js의 **optional catch-all route**를 사용할 거예요.\n\n즉, `app` 폴더 안에 `[[...slug]]`라는 폴더를 새로 만들어주세요.\n\n---\n\n> **optional catch-all route** 쉽게 설명하자면?  \n> URL 경로가 어떤 형태든 전부 이 곳으로 몰아넣겠다는 뜻이에요. 예를 들어 `/about`, `/posts/123` 같은 경로도 모두 이 `[[...slug]]` 폴더가 담당하게 되죠. 이렇게 하면 SPA처럼 라우팅 처리가 편해집니다.\n\n추가로, Next.js에서 `app/[[...slug]]/page.tsx`를 만들면, 전체 경로를 하나로 묶어 관리하는 훌륭한 방법이 될 수 있답니다! 이 부분 잘 활용하면 복잡한 라우팅도 깔끔하게 처리할 수 있어요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서 `app` 디렉토리 구조를 이렇게 구성하고 있다고 가정해볼게요:\n\n\napp\n ┣ [[...slug]]\n ┃ ┗ page.tsx\n ┣ layout.tsx\n\n\n여기에서 `page.tsx`에 다음과 같은 내용을 추가하는 걸 보셨죠?\n\n```js\nexport function generateStaticParams() {\n  return [{ slug: [''] }]\n}\n\nexport default function Page() {\n  return '...' // 나중에 업데이트 예정\n}\n```\n\n### 이 코드는 대체 무슨 뜻일까요?\n\n- `generateStaticParams` 함수는 Next.js에게 어떤 경로들을 정적으로 생성할지 알려주는 역할을 해요.\n- 여기서 `[{ slug: [''] }]`라는 배열을 반환해서 빈 문자열, 즉 루트 경로 `/`만 정적으로 생성한다는 뜻이죠.\n- `[[...slug]]` 이건 *catch-all* 라우팅을 의미해요. 즉, `/`, `/about`, `/posts/1` 등 어떤 경로든 모두 이 페이지로 매핑됩니다.\n- 하지만 이 상태에선 실제로 정적 경로는 빈 배열 `slug: ['']`만 있으니 루트 경로 하나만 빌드 타임에 정적으로 생성되고, 나머지는 동적으로 처리되는 구조입니다.\n\n### 추가 팁!\n\n- 이 파일(`page.tsx`)은 Server Component이므로, 빌드 타임에 HTML로 미리 렌더링 됩니다. 덕분에 SEO에 유리하고 초기 로딩 속도가 빠르죠.\n- 만약 모든 경로를 정적으로 생성하려면 `generateStaticParams`에서 각각 필요한 `slug`를 다 반환해주면 됩니다. 하지만 그게 무척 많거나 동적이라면 이처럼 빈 경로로 제한하는 게 성능이나 빌드 시간에 유리할 수 있어요.\n\n### 간단 정리\n\n| 함수명                | 역할                                 |\n|--------------------|----------------------------------|\n| `generateStaticParams`   | Next.js가 정적으로 생성할 경로 목록 반환          |\n| `export default Page`    | 해당 경로들에 대해서 보여줄 페이지 컴포넌트           |\n| `[[...slug]]`            | 모든 경로를 한 페이지로 처리하는 catch-all 라우팅   |\n\n이 구조를 이해하고 나면 Next.js의 앱 라우팅과 정적 생성을 훨씬 잘 활용할 수 있답니다! 앞으로는 이 베이스 위에 실제 UI나 데이터를 넣어서 페이지를 만들어보세요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 7단계: 클라이언트 전용 엔트리포인트 추가하기\n\n이번엔 CRA(Create React App)의 루트 App 컴포넌트를 Next.js의 클라이언트 컴포넌트 안에 넣어볼 거예요. 이렇게 하면 모든 로직이 클라이언트 사이드에서만 실행되도록 할 수 있답니다.\n\nNext.js 경험이 처음이라면 참고할 점! 클라이언트 컴포넌트라고 해서 무조건 클라이언트에서만 렌더링되는 건 아니에요. 기본적으로 Next.js는 클라이언트 컴포넌트도 서버에서 미리 렌더링(prerendered)해둡니다. 다만, 클라이언트 컴포넌트는 서버-rendering에 추가해서 클라이언트 자바스크립트를 실행할 수 있는 특징이 있죠.\n\n자, 그럼 `app/[[...slug]]/` 폴더 안에 `client.tsx` (또는 `.js`) 파일을 만들어주세요.\n\n```tsx\n'use client'\n\nimport dynamic from 'next/dynamic'\n\nconst App = dynamic(() => import('../../App'), { ssr: false })\n\nexport function ClientOnly() {\n  return <App />\n}\n```\n\n여기서 중요한 점!  \n`dynamic`의 `ssr: false` 옵션을 줘서 서버 사이드 렌더링(SSR)을 완전히 끄고 클라이언트에서만 렌더링하도록 설정했어요. 이렇게 하면 서버에서는 아예 렌더링 과정이 스킵되니, 오직 브라우저에서만 `App`이 실행되겠죠.\n\n이 방식은 특히 CRA에서 작성한 컴포넌트를 Next.js로 옮길 때 유용해요. CRA는 기본적으로 클라이언트 사이드 앱이라 SSR을 고려하지 않거든요. 이처럼 Next.js의 클라이언트 컴포넌트를 활용하면 기존 코드를 수정하지 않고도 Next.js 프로젝트에 자연스럽게 통합할 수 있습니다.\n\n추가 팁!  \n만약 클라이언트 전용 컴포넌트가 많아지면, 이런 클라이언트 전용 래퍼 컴포넌트를 만들어 재사용하는 것도 좋은 방법이에요. 그래야 중복 코드도 줄이고 유지보수도 편해지니까요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- `use client` 지시어는 해당 파일을 클라이언트 컴포넌트로 만들어 줍니다.\n- `dynamic` import에서 `ssr: false`를 설정하면 해당 컴포넌트는 서버 사이드 렌더링이 되지 않고 완전한 클라이언트 전용 컴포넌트(SPA)로 작동하게 됩니다.\n\n이제 이 내용을 반영해서 `page.tsx` (또는 `page.js`)를 다음처럼 업데이트해보세요:\n\n```js\nimport { ClientOnly } from './client'\n \nexport function generateStaticParams() {\n  return [{ slug: [''] }]\n}\n \nexport default function Page() {\n  return <ClientOnly />\n}\n```\n\n---\n\n### 8단계: Static Image Import 업데이트하기\n\n이제 정적 이미지 import를 업데이트할 차례입니다. Next.js에서는 이미지 최적화를 위해 `next/image` 컴포넌트를 많이 사용하는데요, 이 과정에서 이미지 import 방식을 다르게 해야 할 수도 있어요.\n\n예를 들어, 기존에 이렇게 이미지 파일을 바로 import 했다면:\n\n```js\nimport img from '../public/example.png'\n```\n\nNext.js에서는 이미지를 `next/image` 컴포넌트와 함께 쓰는 게 더 좋은데, 이렇게 바꿔볼 수 있답니다:\n\n```js\nimport Image from 'next/image'\n\nexport default function MyComponent() {\n  return (\n    <Image\n      src=\"/example.png\"\n      alt=\"예시 이미지\"\n      width={500}\n      height={300}\n    />\n  )\n}\n```\n\n이렇게 하면 기본적인 최적화(예: 레이지 로딩, 웹포맷 변환 등)를 자동으로 적용 받을 수 있어요.\n\n---\n\n추가 팁!  \n이미지가 자주 변경되지 않는다면 `next.config.js`에서도 이미지 도메인 설정을 확인해보세요. 외부에서 이미지를 불러온다면 CORS 문제도 방지할 수 있답니다.\n\n끝으로, 이미지 import와 관련해서 더 궁금한 게 있거나 실제 프로젝트에 적용해보고 싶다면 편하게 질문 주세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nCRA(Create React App)와 Next.js에서 이미지 파일을 다루는 방식의 차이를 한번 살펴볼게요.\n\n---\n\n### CRA에서 이미지 import하기\n\nCRA에서는 이미지 파일을 import 하면 이미지의 **공개 URL(문자열)**을 반환해요. 그래서 일반 `<img>` 태그의 `src` 속성에 바로 넣을 수 있죠.\n\n```jsx\nimport image from './img.png';\n\nexport default function App() {\n  return <img src={image} alt=\"example\" />;\n}\n```\n\n이 경우는 아주 직관적이고 사용하기 편해요. 이미지는 빌드 과정에서 public 경로로 복사되고, 이 URL이 변수에 저장됩니다.\n\n---\n\n### Next.js에서 이미지 import하기\n\n반면 Next.js에서는 이미지 import 시 **객체**를 반환해요. 이 객체는 이미지의 여러 메타데이터(예: `src`, `height`, `width`)를 가지고 있죠. 그래서 Next.js의 `Image` 컴포넌트와 같이 쓸 수 있어요.\n\n```jsx\nimport image from './img.png';\nimport Image from 'next/image';\n\nexport default function App() {\n  return <Image src={image} alt=\"example\" />;\n}\n```\n\n만약 기존에 사용하던 `<img>` 태그를 그대로 쓰고 싶으면 `image.src`처럼 객체에서 `src` 속성만 꺼내서 쓸 수도 있어요.\n\n```jsx\nimport image from './img.png';\n\nexport default function App() {\n  return <img src={image.src} alt=\"example\" />;\n}\n```\n\n---\n\n### Next.js `Image` 컴포넌트가 좋은 이유\n\n- **자동 이미지 최적화**: 이미지를 자동으로 최적화해서 브라우저에 적합한 형태로 보여줘요.\n- **너비와 높이 자동 설정**: 이미지 원본 크기 기반으로 `width`, `height` 속성을 자동으로 넣어줍니다. 그래서 이미지 로딩 시 레이아웃이 흔들리는 현상(Cumulative Layout Shift)을 줄여줘요.\n- **반응형 및 로딩 지연 기능**: 화면 크기에 맞춰 크기를 조절하거나, 이미지 로딩을 지연시키는 기능도 내장되어 있습니다.\n\n---\n\n### 알아두면 좋은 팁: styled 이미지와 레이아웃 이슈\n\n`Image` 컴포넌트가 자동으로 `width`와 `height` 속성을 넣어주는 덕분에 레이아웃 안정성이 좋아지지만, **이미지 스타일링에 주의해야 해요**.\n\n- 예를 들어 너비만 고정하고(가로 크기만 지정), 높이는 CSS에서 자동(`auto`)으로 두지 않으면,\n- 그 높이는 원본 이미지 크기가 아닌 `Image` 컴포넌트가 자동으로 지정한 높이 값으로 설정되면서,\n- 이미지가 찌그러지거나 늘어져 보일 수 있어요.\n\n그럴 때는 `height`도 `auto`로 설정하거나, 둘 다 명확한 값을 주도록 CSS를 조절하는 게 좋습니다.\n\n---\n\n### 간단 비교 표\n\n| 구분                    | CRA                        | Next.js                       |\n|-------------------------|----------------------------|-------------------------------|\n| 이미지 import 결과      | 문자열(URL)                 | 객체({ src, width, height })  |\n| 이미지 태그             | `<img src={image} />`       | `<Image src={image} />` or `<img src={image.src} />` |\n| 이미지 최적화           | 별도 설정 필요               | 자동 제공                       |\n| 너비/높이 속성 자동 지정 | X                          | O                              |\n| 레이아웃 흔들림 방지      | 브라우저 기본 영향           | 자동 설정으로 방지 가능         |\n\n---\n\n요약하자면, Next.js는 이미지 최적화와 레이아웃 안정성에 초점을 맞춘 방식이에요. 기존 CRA 방식에 익숙해도 Next.js 방식으로 넘어오면 이런 점들을 기억하면 좋겠죠?  \n\n그럼 다음에도 개발에 꿀팁들로 찾아올게요! 😊\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이미지를 다룰 때 `img` 태그를 계속 사용하면 애플리케이션에 변경 사항을 최소화할 수 있어서 예상치 못한 문제를 줄일 수 있어요. 나중에 여유가 된다면 `Image` 컴포넌트로 천천히 옮겨가면서, 이미지 최적화를 위한 로더 설정을 하거나 Next.js 기본 서버에서 제공하는 자동 이미지 최적화 기능을 활용할 수 있답니다.\n\n그리고 `/public` 폴더에서 이미지를 가져올 때 절대 경로 대신 상대 경로를 쓰는 게 좋아요. 이렇게 하면 경로 문제가 훨씬 덜 생기고, 프로젝트 구조가 좀 더 명확해지거든요:\n\n```js\n// Before\nimport logo from '/logo.png'\n\n// After\nimport logo from '../public/logo.png'\n```\n\n또한, `img` 태그에 이미지를 넘겨줄 땐 이미지 객체 전체를 넘기지 말고, **`src` 속성에 이미지 경로만 넘기는 것**이 좋습니다. 이렇게 하면 불필요한 데이터가 전달되는 걸 막을 수 있거든요.\n\n예를 들어:\n\n```jsx\n// Bad\n<img {...logo} alt=\"logo\" />\n\n// Good\n<img src={logo.src} alt=\"logo\" />\n```\n\n추가로, Next.js의 `Image` 컴포넌트를 쓰면 이미지 로딩 최적화, 레이지 로딩, 적절한 크기 조절 등이 자동으로 처리돼서 퍼포먼스에 큰 도움이 돼요. 처음에는 조금 복잡해 보일 수 있지만, 한두 번 써보면 금방 익숙해질 거예요. 필요에 따라서 점진적으로 바꿔가면서 적용해보세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n앞서 예제로 보여준 이미지 태그 변경 방식에 대해 조금 더 풀어서 설명해볼게요.\n\n```jsx\n// Before\n<img src={logo} />\n\n// After\n<img src={logo.src} />\n```\n\n보통 Next.js나 modern 프레임워크에서 이미지를 다룰 때, 그냥 `logo`만 넘기면 문제가 생길 수 있어요. 그래서 실제 이미지 URL을 가리키는 `logo.src`를 명시해줘야 하죠.\n\n또 다른 방법으로는, 이미지 자산을 `public` 폴더에 넣어서 사용하는 거예요. 예를 들어 `public/logo.png`파일을 두면, HTML에 `<img src=\"/logo.png\" />`처럼 경로를 쓸 수 있고, 이 경우 코드에서는 `src=\"/logo.png\"`라고 작성하면 돼요.\n\n---\n\n### 타입스크립트를 쓴다면 주의할 점!\n\n이미지 객체에서 `.src`프로퍼티를 사용하면 타입 에러가 뜰 수 있어요. 이럴 땐 `tsconfig.json` 파일에 `next-env.d.ts`를 포함시켜줘야 하는데요,\n\n```json\n// tsconfig.json 일부 예시\n{\n  \"include\": [\n    \"next-env.d.ts\",\n    \"**/*.ts\",\n    \"**/*.tsx\"\n  ]\n}\n```\n\n`next-env.d.ts` 파일은 Next.js가 자동으로 생성해주니까, 앱을 한번 실행하면 생성돼요.\n\n---\n\n### 참고로, Step 9: 환경변수 마이그레이션\n\n이제 다음 단계인 9단계는 환경 변수 마이그레이션이에요. 환경 변수는 API 키나 시크릿 같이 숨겨야 하는 정보를 관리할 때 꼭 필요한데, 마이그레이션하면서 설정법이 약간 달라질 수 있으니 꼼꼼히 확인하세요.\n\n---\n\n### 팁!\n\n- Next.js에서 `public` 폴더를 쓰면, 이 폴더에 있는 파일은 경로 그대로 접근할 수 있으니 간단하게 이미지나 favicon 같은 정적 자산을 관리하기 좋아요.\n- 만약 이미지를 import해서 쓰고 싶으면, Next.js Image 컴포넌트(`<Image />`)를 사용하는 것도 성능 최적화에 도움이 됩니다.\n\n이렇게 하면 쉽게 이미지 경로 문제와 타입스크립트 오류를 해결 할 수 있어요. 다음 포스팅에서는 환경변수 마이그레이션에 대해 차근차근 알려드릴게요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서 환경변수 사용법은 Create React App(CRA)과 비슷한데, 브라우저에서 노출하려는 변수에는 반드시 `NEXT_PUBLIC_` 접두사를 붙여야 해요.\n\n여기서 가장 큰 차이는 클라이언트 쪽에 노출할 환경변수에 어떤 접두사를 쓰느냐입니다. CRA에서는 `REACT_APP_` 을 사용했지만, Next.js에서는 이걸 전부 `NEXT_PUBLIC_` 으로 바꿔줘야 해요.\n\n---\n\n### Step 10: package.json 스크립트 업데이트하기\n\n`package.json` 안의 스크립트도 Next.js에 맞게 수정해줘야 합니다. 그리고 `.next` 폴더랑 `next-env.d.ts` 파일은 깃에 커밋할 필요가 없으니 `.gitignore`에 꼭 추가해 주세요.\n\n---\n\n아래는 예시로 바꿔줄 수 있는 문법입니다:\n\n| 기존 (CRA)                            | 변경 후 (Next.js)                             |\n|-------------------------------------|---------------------------------------------|\n| `REACT_APP_API_URL=http://localhost`| `NEXT_PUBLIC_API_URL=http://localhost`      |\n| `npm start`                         | `next start`                                |\n| `npm run build`                    | `next build`                                |\n| `npm run dev`                      | `next dev`                                  |\n\n---\n\n`.gitignore`에 다음 내용 추가하기:\n\n\n.next/\nnext-env.d.ts\n\n\n---\n\n**참고로**  \nNext.js는 서버 사이드 렌더링(SSR)도 지원하기 때문에, 서버에서만 사용할 환경변수와 클라이언트에서도 필요한 환경변수를 구분해서 관리하면 더 효율적입니다. 예를 들어, DB 비밀번호같은 민감한 정보는 `NEXT_PUBLIC_` 없이 관리해서 클라이언트로 노출되지 않도록 하세요.\n\n그럼 다음 단계에서는 Next.js 프로젝트에서 환경변수를 어떻게 효율적으로 사용하는지, 그리고 SSR과의 연계 방법도 살펴보겠습니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안녕하세요! 오늘은 Next.js 프로젝트에서 자주 볼 수 있는 스크립트 설정과 관련된 내용을 간단히 정리해볼게요.\n\n먼저 `package.json` 파일에 다음과 같은 스크립트가 있어요:\n\n```json\n{\n  \"scripts\": {\n    \"dev\": \"next dev --turbopack\",\n    \"build\": \"next build\",\n    \"start\": \"npx serve@latest ./build\"\n  }\n}\n```\n\n### 스크립트 설명\n- `dev`: 개발 모드로 실행하는 스크립트예요. `next dev --turbopack` 명령어는 Next.js 개발 서버를 Turbopack 빌드러로 실행하게 해주는데, Turbopack은 Webpack보다 훨씬 빠른 빌드 속도를 자랑하는 차세대 번들러입니다. 아직 완전한 안정화 단계는 아니지만, 속도가 매우 빠르니 한 번 써보시는 걸 추천해요!\n- `build`: 프로젝트를 빌드합니다. 실제 서비스용으로 준비할 때 사용해요.\n- `start`: 빌드된 결과물을 실행하는 명령어인데, 여기선 `serve` 라는 간단한 HTTP 서버를 실행해서 `./build` 폴더 내부를 서비스하도록 되어 있어요. 이 부분은 간단한 정적 서버를 실행하고 싶을 때 유용해요.\n\n---\n\n그 다음, 프로젝트 폴더 안에는 다음과 같은 파일 or 폴더가 있을 텐데요:\n\n```js\n.next\nnext-env.d.ts\n```\n\n- `.next` 폴더는 Next.js가 빌드하면서 자동으로 생성하는 캐시 및 빌드 결과물 폴더입니다. 이 폴더는 직접 수정하지 않는 게 좋아요.\n- `next-env.d.ts`는 TypeScript를 사용할 때 Next.js에서 자동으로 생성하는 환경 설정 파일이에요. typings 관련 설정이 들어있죠.\n\n---\n\n### 실행 방법\n모든 셋팅이 끝나면, 터미널에서 아래 명령어로 개발 서버를 켤 수 있어요:\n\n```bash\nnpm run dev\n```\n\n이 명령어가 실행되면, `localhost:3000`(기본값)에서 Next.js 애플리케이션을 확인할 수 있습니다!\n\n---\n\n### 추가 팁!\n\n1. **Turbopack 사용 시 주의점**  \n   아직 Turbopack은 실험 단계이므로 일부 패키지나 기능이 제대로 동작하지 않을 수 있어요. 안정적인 개발 환경을 원한다면 `next dev` 명령어를 그냥 쓰거나, 옵션 없이 실행하는 것도 고려해보세요.\n\n2. **`start` 스크립트 변경하기**  \n   `npx serve`는 설치없이 바로 사용할 수 있어 편리하지만, 실제 프로덕션 서버에서는 [PM2](https://pm2.keymetrics.io/) 같은 프로세스 매니저를 쓰거나, Next.js가 자체적으로 제공하는 `next start` 명령어(서버 사이드 렌더링 가능)를 사용하는 게 더 적합합니다.\n\n3. **환경 설정**  \n   Next.js를 본격적으로 다룰 때는 `.env.local` 같은 환경 변수 파일을 사용해 API 키나 민감한 정보를 관리하는 것도 중요해요.\n\n오늘은 Next.js 프로젝트에서 자주 쓰이는 기본 스크립트와 환경을 정리해봤어요. 다음에 더 재밌는 내용으로 찾아올게요! :)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nhttp://localhost:3000 에 접속해보세요. 그러면 Next.js로 실행 중인 여러분의 애플리케이션이 (SPA 모드로) 잘 돌아가는 걸 확인할 수 있을 거예요.\n\n### 11단계: 정리 작업하기\n\n이제 Create React App에서 사용하던 것들을 정리할 차례입니다. Next.js로 완전히 넘어왔으니 불필요한 파일과 설정들을 깔끔하게 치워주면 좋아요.\n\n다음 항목들을 프로젝트에서 제거해 주세요:\n\n| 제거해야 할 항목                        | 설명                                                 |\n|-------------------------------------|----------------------------------------------------|\n| `public/index.html`                  | CRA의 루트 HTML 파일로, Next.js에선 필요 없어요           |\n| `src/index.tsx`                     | CRA의 진입점 파일, Next.js에선 `pages` 폴더가 담당해요 |\n| `src/react-app-env.d.ts`             | CRA 사용 시 타입스크립트 환경설정용 파일                  |\n| reportWebVitals 관련 설정               | 퍼포먼스 측정을 위한 CRA 전용 설정, 필요 없어요                |\n| `react-scripts` 의존성 제거          | `package.json`에서 CRA를 위한 스크립트 의존성도 삭제하세요    |\n\n이렇게 정리하면 프로젝트가 훨씬 깔끔해지고, Next.js에 맞는 환경으로 잘 정돈됩니다. 여기서 더 나아가, 만약 CRA에서 사용하던 스타일링이나 기타 라이브러리가 Next.js와 충돌난다면 버전이나 설정도 한 번 점검해 보세요.\n\n정리 과정에서 궁금한 점 있으면 언제든 물어봐 주세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 추가로 알아두면 좋은 점\n\n### CRA에서 커스텀 홈페이지 경로 사용하기\n\n만약 CRA(Create React App)에서 package.json의 `homepage` 필드를 이용해 앱을 특정 서브 경로(예: `/my-subpath`)에 배포했다면, Next.js에서도 비슷하게 설정할 수 있어요. Next.js는 `next.config.ts`에서 `basePath` 설정을 통해 이 기능을 제공한답니다!\n\n예를 들어, 아래처럼 작성하면 `/my-subpath` 하위 경로에 앱을 서빙할 수 있어요:\n\n```typescript\nimport { NextConfig } from 'next'\n\nconst nextConfig: NextConfig = {\n  basePath: '/my-subpath',\n  // 추가 설정들..\n}\n\nexport default nextConfig\n```\n\n이렇게 설정하면 모든 페이지 경로가 `/my-subpath`를 기준으로 동작하게 돼요. 예를 들어, `/about` 페이지는 실제로 `/my-subpath/about`로 접근하는 식이죠.\n\n> 참고로, `basePath`를 사용하면 정적 자원(css, 이미지 등) 경로도 함께 신경 써야 해요. 보통 Next.js가 알아서 처리하지만, 직접 경로를 지정할 때는 `basePath`를 붙여주는 걸 잊지 마세요!\n\n---\n\n### 추가 팁\n\n- **환경별 경로 분기**: 개발 환경에선 `basePath`를 빈값으로 두고, 배포 환경에선 서브 경로를 지정하는 경우가 많아요. 이 경우 `next.config.ts`에서 환경변수로 분기 처리하는 걸 추천합니다.\n- **Rewrite, Redirect와 함께 쓰기**: `basePath`는 URL 기본 경로를 바꾸는 설정이라, 리라이트나 리다이렉트를 할 때 함께 고려하면 UX를 향상시킬 수 있어요.\n- **Custom 서버 없이 사용 가능**: CRA처럼 별도의 서버 설정 없이도 Next.js가 자체적으로 `basePath` 처리를 해주기 때문에 편리해요.\n\nNext.js로 이전하면서 서브 경로 관련 설정 고민이라면, `basePath`를 꼭 살펴보세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 커스텀 서비스 워커 다루기\n\n만약에 Create React App(CRA)에서 제공하는 serviceWorker.js를 사용했다면, Next.js로 Progressive Web Application(PWA)을 만드는 방법도 알아두면 좋아요. CRA와 Next.js는 서비스 워커를 다루는 방식이 조금 다르지만, Next.js에서는 커스텀 서비스 워커를 직접 등록하고 관리할 수 있기 때문에 더 유연하게 사용할 수 있답니다.\n\n예를 들어, CRA에서는 서비스 워커가 기본적으로 제공되면서 간단하게 PWA를 만들 수 있는 반면, Next.js에서는 `public` 폴더에 직접 서비스 워커 파일을 넣고, `_app.js` 혹은 커스텀된 `_document.js`에서 직접 등록 스크립트를 추가하는 형태로 작업해요. 그래서 더 맞춤형 접근이 가능하고 필요에 따라 기능을 확장하기 편하죠.\n\n참고로, Next.js 공식 문서에도 PWA를 위한 별도 플러그인(next-pwa) 사용법이 소개되어 있는데, 이걸 활용하면 서비스 워커 등록과 캐시 관리가 더 쉬워져요. 관심 있다면 한번 살펴보시는 걸 추천드립니다!\n\n---\n\n### API 요청 프록시 처리하기\n\nCRA에서 `package.json`에 `\"proxy\"` 필드를 넣어 API 요청을 백엔드 서버로 바로 보내는 방식 많이 써봤을 텐데요. Next.js에서는 이 역할을 `next.config.ts` 파일의 `rewrites`로 손쉽게 대체할 수 있어요.\n\n아래는 예시인데요, 앞에 `/api`로 들어오는 요청을 실제 백엔드 API 서버 주소로 '재작성'해주는 역할을 합니다.\n\n```ts\n// next.config.ts\nimport { NextConfig } from 'next'\n\nconst nextConfig: NextConfig = {\n  async rewrites() {\n    return [\n      {\n        source: '/api/:path*', // Next.js 앱에서 /api/** 요청 감지\n        destination: 'https://backend.example.com/api/:path*', // 실제 백엔드 서버 주소로 포워딩\n      },\n    ]\n  },\n}\n\nexport default nextConfig\n```\n\n이렇게 설정하면 클라이언트 쪽에서는 별다른 변경 없이 `/api/`로 요청을 보내면 되고, Next.js가 알아서 백엔드 서버랑 연결해 주니까 개발이 훨씬 편해져요.\n\n> 그리고 한 가지 팁! 만약 배포 환경별로 백엔드 주소가 다르다면, 환경변수를 활용해 `destination` 값을 불러오는 방식을 추천해요. 이렇게 하면 개발/운영 환경을 쉽게 분리해서 관리할 수 있습니다.\n\n---\n\n이상으로 CRA에서 Next.js로 넘어오면서 서비스 워커와 API 프록시 처리를 어떻게 할 수 있는지 간단하게 정리해봤어요. 직접 해보면서 궁금한 점 있으면 언제든 물어봐 주세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서 설정을 확장하거나 API 경로 리라이트를 적용하는 방법에 대해 알려드릴게요. CRA(Create React App)에서 custom webpack이나 Babel 설정을 하셨다면, Next.js에서는 next.config.ts 파일을 통해 비슷한 작업을 할 수 있습니다.\n\n### API 요청 리라이트 설정하기\n\n예를 들어, 프론트엔드에서 `/api/`로 시작하는 경로를 실제 백엔드 서버인 `https://your-backend.com`으로 리다이렉션하고 싶다면, 다음과 같이 `rewrites()` 함수를 사용하면 됩니다.\n\n```ts\nimport { NextConfig } from 'next'\n\nconst nextConfig: NextConfig = {\n  async rewrites() {\n    return [\n      {\n        source: '/api/:path*',\n        destination: 'https://your-backend.com/:path*',\n      },\n    ]\n  },\n}\n\nexport default nextConfig\n```\n\n**간단 설명:**\n\n- `source`: 클라이언트에서 요청하는 경로 패턴입니다.\n- `destination`: 실제 처리할 백엔드 서버 주소로, 여기서 `:path*`는 와일드카드 역할을 해서 `/api` 뒤의 경로가 그대로 유지됩니다.\n\n이렇게 설정하면 서버와 클라이언트 도메인이 달라도 CORS 문제 없이 API 호출이 가능하답니다.\n\n### 커스텀 Webpack 또는 Babel 설정 적용하기\n\nCRA에서는 `webpack.config.js`나 `babel.config.js`를 직접 고치지만, Next.js에서 그런 설정을 건드리고 싶으면 `next.config.ts`에 `webpack` 설정을 추가하세요.\n\n```ts\nimport { NextConfig } from 'next'\n\nconst nextConfig: NextConfig = {\n  webpack: (config, { isServer }) => {\n    // 여기에 커스텀 webpack 설정 작성하기\n    // 예: 특정 플러그인 추가하거나 로더 수정 가능\n    return config\n  },\n}\n\nexport default nextConfig\n```\n\n#### 추가 팁\n\n- `config`는 기본 Next.js가 제공하는 webpack 설정 객체입니다.\n- `isServer`는 해당 설정이 서버용인지 클라이언트용인지를 알려줘요.\n- 필요에 따라 `config.plugins.push()`나 `config.module.rules.push()` 같은 방식으로 원하는 로더, 플러그인을 추가할 수 있습니다.\n\n---\n\nNext.js 설정은 이렇게 하면 되는데, 만약 Babel 설정도 손대고 싶다면 `babel.config.js` 혹은 `.babelrc` 파일을 루트에 만들어서 관리하는 게 좋아요. Next.js는 기본적으로 내장된 Babel 설정을 사용하지만, 커스텀하게 플러그인이나 프리셋을 추가하고 싶을 때는 별도로 설정 가능합니다.\n\nNext.js로 마이그레이션하거나 커스텀 빌드 환경을 조절할 때, 이 부분만 잘 이해하면 성공적인 프로젝트 세팅에 많은 도움이 될 거예요! 혹시 더 궁금한 점 있으면 언제든 물어보세요. 🙂\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n> 참고: 이 작업을 하려면 dev 스크립트에서 --turbopack 옵션을 제거해서 Turbopack을 비활성화해야 합니다.\n\n### TypeScript 설정하기\n\nNext.js는 프로젝트에 tsconfig.json 파일이 있으면 자동으로 TypeScript 환경을 설정해줍니다. 이때 tsconfig.json 파일 내에서 `next-env.d.ts`가 반드시 include 배열에 포함되어야 하는데요, 이렇게 해줘야 Next.js가 타입 정보를 제대로 인식할 수 있어요. 아래처럼 설정하면 됩니다:\n\n```json\n{\n  \"include\": [\"next-env.d.ts\", \"app/**/*\", \"src/**/*\"]\n}\n```\n\n여기서 `next-env.d.ts` 파일은 Next.js가 자동 생성해주는 타입 선언 파일로, 꼭 포함되어 있어야 타입 체크가 정상적으로 작동해요. 만약 이 부분을 빼먹으면 간헐적으로 타입 에러가 발생할 수 있으니 꼭 확인하세요!\n\n추가로, 앱 구조에 따라 `app/**/*`이나 `src/**/*` 대신 다른 폴더 경로를 넣어주셔도 되고, 프로젝트에 맞게 수정하시면 됩니다. 이처럼 include 배열 안에 TypeScript로 작성될 소스 파일 위치들을 모두 포함시켜야 빌드 시 누락 없이 타입 검사가 진행돼요.\n\nTypeScript를 적용하면 코드 안정성도 높아지고, 자동완성 및 인텔리센스 지원도 좋아져서 개발이 훨씬 편해집니다. Next.js에서는 기본적으로 환경 세팅을 많이 도와주니 크게 신경 쓰지 않아도 되지만, 꼼꼼히 한 번 확인만 해주시면 되겠습니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 번들러 호환성\n\nCreate React App과 Next.js는 기본적으로 웹팩(webpack)을 번들러로 사용해요. 다만, Next.js는 로컬 개발을 더 빠르게 할 수 있게 도와주는 새로운 번들러인 Turbopack도 지원하는데요, 이렇게 실행할 수 있어요:\n\n```bash\nnext dev --turbopack\n```\n\n이게 바로 Next.js에서 Turbopack을 활성화하는 명령어입니다. Turbopack은 웹팩보다 훨씬 빠른 빌드 속도를 자랑해서, 특히 개발할 때 생산성을 높여줘요.\n\n하지만 기존에 Create React App에서 쌓아온 웹팩 설정 같은 고급 설정을 그대로 옮기고 싶다면, Next.js에서도 커스텀 웹팩 설정을 적용할 수 있으니 걱정하지 마세요. 개발 환경에 따라 필요에 맞게 유연하게 쓸 수 있다는 점이 장점입니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 다음 단계 (Next Steps)\n\n잘 따라왔다면, 이제 Next.js 애플리케이션이 단일 페이지 애플리케이션(SPA)으로 제대로 동작하고 있을 거예요. 지금은 Next.js의 강력한 기능들, 예를 들어 서버 사이드 렌더링(SSR)이나 파일 기반 라우팅 같은 것을 활용하지 않은 상태인데요. 이제부터 천천히 하나씩 적용해나가면 됩니다!\n\n### 앞으로 해볼 만한 것들\n\n| 작업 | 설명 |\n|---|---|\n| React Router에서 Next.js App Router로 마이그레이션 | Next.js가 제공하는 **자동 코드 분할**, **스트리밍 서버 렌더링**, **React Server Components**를 활용할 수 있어요. |\n| 이미지 최적화 | `Image` 컴포넌트를 사용하면 웹 성능 향상에 크게 도움이 됩니다. |\n| 폰트 최적화 | `next/font`를 활용해 폰트를 최적화하면 페이지 로딩 속도가 더 빨라져요. |\n| 서드파티 스크립트 최적화 | `Script` 컴포넌트를 사용해 외부 스크립트를 효율적으로 로딩하세요. |\n| ESLint 활성화 | `npx next lint`를 실행해 Next.js 추천 규칙으로 ESLint를 설정하고, 프로젝트에 맞게 커스터마이징하면 코드 품질 유지에 좋습니다. |\n\n### 참고 사항\n\n> 지금 만약 `next.config.ts`에서 **출력 형식을 static export (output: `export`)**로 설정했다면, `useParams` 훅이나 다른 서버 사이드 기능들은 사용할 수 없어요. Next.js의 모든 기능을 활용하려면 `output: 'export'` 설정을 삭제하는 게 좋아요.\n\n---\n\n### 추가로 알려드리고 싶은 팁!\n\n- **App Router와 Server Components**: Next.js 13부터 도입된 App Router와 React Server Components는 UI를 효율적으로 렌더링하고 데이터 페칭을 더 직관적으로 처리할 수 있게 해줍니다. 새 프로젝트라면 꼭 도입을 고려해보세요!\n- **이미지 최적화**: 일반 `<img>` 태그 대신 `next/image`를 쓰면 이미지 사이즈에 맞춰 자동 최적화되고, Lazy loading도 기본으로 됩니다. 성능 향상에 크게 기여하죠.\n- **ESLint 도입은 꼭 하자!** Next.js가 기본으로 권장하는 ESLint 규칙은 최신 React 및 Next.js 코딩 스타일에 맞춰져 있으니 꼭 설정해 두시길 권장해요. 초기부터 코드 품질을 잘 관리하면 나중에 유지보수도 한결 쉬워집니다.\n\n이제 Next.js의 진짜 힘을 경험할 준비가 됐네요! 궁금한 점 있으면 언제든 찾아주세요. 같이 멋진 웹 앱 만들어봐요! 🚀","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":40},{"title":"Nextjs 13에서 Pages에서 App Router로 마이그레이션하는 방법 완벽 가이드","description":"","date":"2025-04-22 01:20","slug":"2025-04-22-HowtomigratefromPagestotheAppRouter","content":"\n\n# Pages에서 App Router로 마이그레이션하는 법\n\n이번 글에서는 Next.js 12에서 13으로 업데이트하면서, 기존의 pages 디렉토리 기반 애플리케이션을 app 디렉토리 기반으로 점진적으로 옮기는 방법을 알려드릴게요. 뿐만 아니라 pages와 app 디렉토리 양쪽에서 모두 작동하는 업그레이드 팁도 함께 다룹니다.\n\n## 업그레이드하기\n\n(이하 본문이 계속 이어지겠죠)\n\n---\n\nNext.js 13은 app 디렉토리로 라우팅 방식을 대대적으로 바꾸면서 더 유연하고 강력해졌어요. 하지만 갑작스럽게 모두 바꾸기엔 부담스러우니, 페이지 단위로 조금씩 옮길 수 있도록 설계된 점도 매력 포인트입니다.\n\n특히 기존에 pages 기반으로 만들어둔 큰 프로젝트라면, 한 번에 바꾸기보단 섹션별로 앱 디렉토리 구조를 도입하면서 자연스럽게 최신 기능들을 써볼 수 있어요.\n\n예를 들어 `pages/about.js`는 아직 냅두고, 새로 만들거나 자주 바꾸는 부분부터 app 폴더 내부의 컴포넌트 및 레이아웃으로 점차 변경해보는 걸 추천합니다.\n\n---\n\n뒤에서 더 자세히 살펴볼게요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### Node.js 버전\n\n최소 Node.js 버전이 이제 v18.17로 올라갔어요. 자세한 내용은 [Node.js 공식 문서](https://nodejs.org/en/docs/)에서 확인할 수 있으니 참고해 보세요.\n\n### Next.js 버전\n\nNext.js를 13버전으로 업데이트하려면, 아래 명령어를 사용하는 패키지 매니저에 맞춰 실행하면 됩니다:\n\n```bash\n# npm 사용 시\nnpm install next@13\n\n# yarn 사용 시\nyarn add next@13\n\n# pnpm 사용 시\npnpm add next@13\n```\n\n---\n\n> 여기서 잠깐!  \n> Next.js 13은 여러 신기능과 성능 개선이 함께 들어왔어요. 예를 들어, 새로운 App Router가 도입되어 페이지 라우팅이 더 유연해졌고, React Server Components도 지원하죠. 업데이트 전에 꼭 [Next.js 13 공식 문서](https://nextjs.org/blog/next-13)를 한 번 살펴보시면 도움이 될 거예요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```bash\nnpm install next@latest react@latest react-dom@latest\n```\n\n### ESLint 버전 업데이트\n\n만약 ESLint를 사용하고 있다면, ESLint 버전도 함께 업그레이드해주는 게 좋아요!\n\n```bash\nnpm install -D eslint-config-next@latest\n```\n\n> 참고로 ESLint 설정 파일(.eslintrc.js 등)에서 `eslint-config-next`를 베이스로 사용한다면, 버전이 맞지 않으면 Next.js와 충돌이 날 수 있어서 꼭 같이 업데이트 해주세요.\n\n그리고 혹시 ESLint가 처음이라면, Next.js에서 기본적으로 권장하는 ESLint 설정을 따라서 쓰는 걸 추천해요. 코딩 컨벤션을 맞추고 코드 품질을 높이는 데 도움 되니까요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n알아두면 좋은 팁: ESLint 설정을 변경한 후에는 VS Code에서 ESLint 서버를 재시작해줘야 변경 사항이 제대로 반영될 수 있어요. 재시작 방법은 간단해요! Mac에서는 cmd+shift+p, Windows에서는 ctrl+shift+p를 눌러 커맨드 팔레트를 열고 'ESLint: Restart ESLint Server'를 검색해서 실행하면 됩니다.\n\n---\n\n## 다음 단계\n\n업데이트를 마쳤다면 아래 섹션들을 참고해서 다음 과정을 진행해보세요:\n\n- **새로운 기능 업그레이드하기**: 향상된 Image 컴포넌트와 Link 컴포넌트를 비롯한 새로운 기능들로 업그레이드하는 방법을 알려주는 가이드입니다.  \n- **pages 디렉터리에서 app 디렉터리로 마이그레이션하기**: 기존의 pages 디렉터리에서 점진적으로 app 디렉터리로 전환하는 단계별 가이드로, 프로젝트 구조를 최신 방식으로 바꾸는 데 도움을 줍니다.\n\n---\n\n+ 팁을 한 가지 더 드리자면, ESLint 서버 재시작은 설정 변경 후 바로바로 효과를 보고 싶을 때 꼭 해주는 게 좋아요. 가끔은 VS Code를 전체 종료하고 다시 여는 것보다 훨씬 빠른 해결책이 될 때가 많답니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## Next.js 13에서 새 기능 업그레이드하기\n\nNext.js 13에서는 새로운 App Router가 도입되면서 여러 가지 기능과 컨벤션들이 추가됐어요. 이 새로운 라우터는 `app` 디렉토리 안에서 사용 가능하고, 기존의 `pages` 디렉토리와도 함께 공존할 수 있답니다.\n\n중요한 점은, Next.js 13으로 업그레이드한다고 해서 반드시 App Router를 바로 사용해야 하는 건 아니에요! 기존에 쓰던 `pages` 디렉토리 기반 라우팅도 계속 쓸 수 있고, 두 디렉토리 모두에서 동작하는 최신 기능들도 사용할 수 있다는 점이죠. 예를 들면, 업데이트된 `Image` 컴포넌트, `Link` 컴포넌트, `Script` 컴포넌트, 그리고 폰트 최적화 같은 기능들이 그런 것들이에요.\n\n### `Image` 컴포넌트\n\nNext.js 13에서 `Image` 컴포넌트가 훨씬 더 좋아졌어요! 이전 버전에 비해서 성능과 사용성이 많이 개선됐고, 이제부터는 자동으로 이미지 최적화가 더 강화되었답니다.\n\n#### 주요 특징\n- **자동 사이즈 조절**: 이미지 크기를 코드에 명시하지 않아도, Layout을 통해 적절히 크기를 잡아줘요.\n- **새로운 레이아웃 옵션들**: `fill`, `fixed`, `intrinsic` 등 다양한 레이아웃 옵션이 추가되어 원하는 스타일에 맞게 조절 가능해요.\n- **새로운 `priority` 옵션**: 중요한 이미지를 먼저 불러올 수 있게끔 설정할 수 있어요.\n- **향상된 WebP 변환**: 웹 최적화를 위해 자동으로 WebP 포맷 변환을 지원하고 있어요.\n\n저는 개인적으로 Next.js 13의 `Image` 컴포넌트를 사용하면서 페이지 로딩 속도가 확실히 빨라진 느낌이에요. 그리고 개발자가 직접 신경 써야 하는 부분이 줄어들어서, 더욱 편리하게 이미지를 다룰 수 있다는 점이 너무 좋더라고요.\n\n---\n\n참고로, Next.js 새 기능은 공식 문서가 정말 잘 되어 있으니, 새로운 App Router를 천천히 공부해보고 싶다면 [Next.js 공식 문서](https://nextjs.org/docs)에서 자세한 내용을 꼭 확인해 보시길 추천드릴게요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js 12 버전에서 Image 컴포넌트에 새로운 개선사항이 도입되었는데, 임시로 next/future/image에서 불러오는 방식이었어요. 이 개선사항에는 클라이언트 쪽 자바스크립트가 줄어들고, 이미지 확장과 스타일링이 더 쉬워졌으며, 접근성도 좋아졌고 네이티브 브라우저의 지연 로딩(lazy loading) 기능도 지원되었답니다.\n\n그런데 Next.js 13 버전에서는 이 새로운 동작 방식이 next/image의 기본값으로 완전히 자리잡았어요!\n\n기존 프로젝트에서 이 새로운 Image 컴포넌트로 쉽게 마이그레이션할 수 있도록 두 가지 코드를 변환해주는 'codemod' 스크립트를 제공합니다:\n\n| 코덱모드 이름                     | 설명                                                                                           | 주의사항                                                 |\n|-----------------------------|----------------------------------------------------------------------------------------------|------------------------------------------------------|\n| next-image-to-legacy-image   | next/image로 임포트한 부분을 자동으로 next/legacy/image로 안전하게 이름 변경해줌. 기존 컴포넌트의 동작이 그대로 유지됨. | 이 변환은 안전해서 바로 적용 가능.                         |\n| next-image-experimental      | 인라인 스타일을 과감하게 추가하고, 사용되지 않는 props를 제거함. 기존 컴포넌트 동작이 바뀌어 새로운 기본 동작을 따라가게 됨. | 사용하려면 먼저 next-image-to-legacy-image codemod를 실행해야 함. 변경점이 꽤 크니까 테스트 철저히 할 것! |\n\n마이그레이션할 때 참고해 보세요!\n\n추가로, Image 컴포넌트의 변경덕분에 SEO 최적화, 페이지 렌더링 속도 개선과 같은 장점도 누릴 수 있답니다. 특히 lazy loading은 이미지가 화면에 보일 때만 로드되니 초기 로딩 속도가 확실히 빨라지고, 불필요한 데이터 낭비도 줄어들어요. Next.js 13으로 업데이트 하면서 Image 컴포넌트도 꼭 점검해보세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### `Link` 컴포넌트 변화 소개\n\n안녕하세요! 오늘은 Next.js의 `Link` 컴포넌트 사용법이 어떻게 바뀌었는지 쉽게 알려드릴게요.\n\n옛날 버전인 Next.js 12까지는 `Link`를 사용할 때, 내부에 꼭 `<a>` 태그를 직접 감싸줘야 했어요. 예를 들어, 이렇게요:\n\n```js\n<Link href=\"/about\">\n  <a>About</a>\n</Link>\n```\n\n만약 `<a>`를 안 쓰면 제대로 작동하지 않았죠. 그런데 12.2버전부터는 이게 실험적인 기능으로 바뀌었고, Next.js 13에서는 아예 기본 동작이 바뀌었답니다. 이제는 `<Link>` 자체가 내부적으로 `<a>` 태그를 자동으로 렌더링해줘서, 우리가 굳이 `<a>` 태그를 감싸줄 필요가 없어요!\n\n즉, 이렇게 간단하게 써도 됩니다:\n\n```js\n<Link href=\"/about\">\n  About\n</Link>\n```\n\n이렇게 하면 Next.js가 내부적으로 `<a>` 태그를 알아서 처리해주니까 훨씬 편하죠.\n\n---\n\n> 개인적으로 느낀 점은, 개발할 때 코드가 깔끔해지고, 실수로 `<a>`를 빼먹는 실수도 방지할 수 있다는 점이 좋았어요. 그리고 스타일링도 `Link` 컴포넌트에 바로 props를 넘겨서 할 수 있으니 편리하답니다!\n\n---\n\n요약하자면:  \n- Next.js 12까지는 `<Link>` 안에 직접 `<a>` 태그를 넣어야 했어요.  \n- Next.js 13부터는 `<Link>`가 자동으로 `<a>` 태그를 렌더링합니다.  \n- 코드가 더 깔끔해지고 사용하기 편해졌답니다!\n\n이렇게 간단하지만 개발자 경험을 꽤 개선한 부분이라 꼭 알아두세요~!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js 13로 링크를 업그레이드하려면 `new-link` 코덱모드(codemod)를 활용할 수 있어요. 이건 자동으로 코드를 바꿔주니까 한 번 활용해보면 편리하답니다.\n\n### `Script` 컴포넌트\n\nNext.js 13에서 `next/script`의 동작 방식이 업데이트되면서, pages와 app 디렉토리 양쪽을 지원하지만, 원활하게 마이그레이션 하려면 몇 가지 주의할 점이 있어요.\n\n| 변경 사항 | 설명 |\n| --------- | ----- |\n| beforeInteractive 스크립트 이동 | 기존에 `_document.js`에 넣었던 `beforeInteractive` 스크립트는 `app/layout.tsx` 루트 레이아웃 파일로 옮겨야 해요. 그래야 Next.js 13의 새로운 앱 구조에서 제대로 작동해요. |\n| experimental worker strategy 제한 | `experimental`로 설정된 워커 전략은 아직 `app` 디렉토리에서 완전히 지원되지 않습니다. 따라서 이 전략을 사용 중이라면 삭제하거나, `lazyOnload` 같은 다른 전략으로 바꿔야 해요. |\n| 이벤트 핸들러(onLoad, onReady, onError) | Server Component에서는 이벤트 핸들러가 동작하지 않아요. 따라서 이런 핸들러들은 반드시 Client Component로 옮기거나 아니면 삭제해야 합니다. |\n\n추가 팁으로, 만약 여러분의 프로젝트가 아직 완전히 앱 디렉토리 구조로 전환되지 않았다면, 이 변경 사항들을 적용하기 전에 꼭 백업을 해놓고 점진적으로 바꾸는 것을 추천해요. \n\n그리고 이 `Script` 컴포넌트는 외부 스크립트를 다룰 때 굉장히 유용한데, 적절하게 전략을 변경하면 페이지 렌더링 성능도 훨씬 좋아질 수 있어요. Next.js 13을 더 잘 활용하는 데 있어서 중요한 부분이니 꼭 체크해보세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 폰트 최적화(Font Optimization)\n\n예전에는 Next.js가 폰트 CSS를 인라인(inline) 방식으로 넣어주는 방식으로 폰트를 최적화해줬어요. 그런데 Next.js 13부터는 완전히 새롭게 설계된 **next/font** 모듈이 등장했습니다. 이 모듈을 사용하면 폰트 로딩 방식을 더 세밀하게 조절할 수 있으면서도, 여전히 빠른 성능과 개인정보 보호까지 챙길 수 있답니다.\n\n특히 next/font는 기존의 pages 디렉토리 뿐만 아니라 새로운 app 디렉토리 환경에서도 모두 지원된다는 점이 큰 장점이에요.\n\n예전처럼 CSS를 인라인으로 넣는 방식은 pages에서는 여전히 작동하지만, app에서는 작동하지 않으니 앞으로는 꼭 next/font 모듈을 써야 해요.\n\n더 자세한 사용법은 Next.js 공식 문서의 [Font Optimization](https://nextjs.org/docs/basic-features/font-optimization) 페이지를 참고하면 되고, 직접 써보면 적용도 쉽고 효과도 확실히 느껴질 거예요!\n\n---\n\n> **추가 팁!**  \n> next/font는 구글 폰트뿐 아니라 로컬 폰트도 쉽게 불러올 수 있어서, 사용자 맞춤 폰트를 쓸 때도 아주 유용해요. 그리고 폰트를 가져올 때 불필요한 파일을 제외하고 필요한 글자나 변형만 포함시켜서, 번들 크기가 훨씬 줄어드는 효과까지 있답니다. 실 서비스에 적용하면 조금 더 쾌적한 웹 경험을 제공할 수 있어요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## pages에서 app으로 마이그레이션하기\n\n> 🎥 영상 보기: App Router 점진적 도입 방법 배우기 → YouTube (16분)\n\nApp Router로 이동하는 건 Next.js가 기반으로 삼고 있는 React 기능들, 예를 들어 서버 컴포넌트(Server Components), 서스펜스(Suspense) 등을 처음 사용해보는 경험일 수 있어요. 여기에 Next.js의 새로운 기능들, 예를 들어 특수 파일(special files)과 레이아웃(layouts) 등이 더해지면서 마이그레이션은 새로운 개념, 사고방식, 그리고 동작 방식까지 익혀야 하는 일이 됩니다.\n\n그래서 저희는 이 모든 변화를 한꺼번에 적용하기보다는, 마이그레이션 과정을 작게 쪼개서 단계별로 진행할 것을 추천해요. app 디렉토리는 pages 디렉토리와 동시에 작동하도록 의도적으로 설계되어 있어서, 페이지 단위로 점진적 마이그레이션이 가능하답니다.\n\n---\n\n### 조금 더 풀어 보면\n\n- **서버 컴포넌트(Server Components)**: 서버 쪽에서 렌더링되기 때문에 성능 향상과 번들 크기 감축에 도움이 돼요.\n- **서스펜스(Suspense)**: 데이터가 준비될 때까지 UI를 잠시 멈춰놓고 로딩 상태를 보여주는 React 기능입니다.\n- **레이아웃(Layouts)**: 앱 전반에 걸친 공통 UI를 쉽게 관리할 수 있게 해줍니다.\n\n마이그레이션 중에도 기존 pages 구조를 완전히 버리지 않고, 신규 app 구조와 병행해가며 일부분씩 바꿔나갈 수 있어서 부담이 적죠. \n\n즉, 한번에 다 바꾸려 하지 말고, '한 페이지씩, 한 기능씩' 천천히 옮겨가면서 적응하는 게 가장 좋은 방법이에요. 나중에 완전히 app 디렉토리 기반으로 옮겼을 때도 안정적이고 원활한 전환이 될 테니까요. \n\n이렇게 점진적으로 배우면서 바꾸는 과정, 생각보다 덜 어렵고 훨씬 효율적일 거예요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js의 최신 버전(13.4 이상)부터는 앱 디렉토리(app directory)를 활용한 새로운 방식으로 라우팅과 레이아웃 구성이 가능해졌어요. 이번 포스트에서는 앱 디렉토리를 이용한 Nested Routes(중첩 라우트)와 Layouts(레이아웃) 사용법을 한번 쉽게 정리해볼게요!\n\n---\n\n### 1. 앱 디렉토리는 Nested Routes와 Layouts를 지원해요.\n\n- 폴더 안에 또 폴더를 만들어 중첩 라우트를 정의할 수 있어요.\n- 각 폴더 내에 특별한 파일 `page.js`를 두면 그 경로가 실제 라우트 URL이 돼요.\n- 예를 들어 `app/blog/page.js`는 `/blog` 경로, `app/blog/post/page.js`는 `/blog/post` 경로가 되는 식입니다.\n\n### 2. 특수 파일 규칙\n\n| 파일명         | 역할                                  | 비고                          |\n| ------------- | ----------------------------------- | ----------------------------- |\n| `page.js`     | 해당 경로 고유의 UI를 정의             | 라우트마다 고유 UI 구성 가능   |\n| `layout.js`   | 여러 라우트에서 공유하는 UI를 정의      | 중첩 레이아웃 구성 가능       |\n\n`page.js`와 `layout.js`는 `.js`, `.jsx`, `.tsx` 확장자를 사용할 수 있어요. 즉, TypeScript도 문제없답니다!\n\n### 3. 공통 레이아웃과 개별 페이지 UI 구분!\n\n- `layout.js`는 자식 경로 여러 개에 공통적으로 적용되는 레이아웃을 담당해요.\n- `page.js`는 그 경로 하나만의 UI를 책임져요.\n\n이런 구조 덕분에, 공통 헤더, 사이드바 등은 `layout.js`에 넣고, 경로별 고유한 내용은 `page.js`로 깔끔하게 분리할 수 있어요.\n\n### 4. 앱 폴더 안에 컴포넌트, 스타일, 테스트 파일도 한 곳에!\n\n- `app` 폴더 내에 컴포넌트, 스타일 파일, 테스트, 심지어 헬퍼 함수도 같이 두고 관리할 수 있어요.\n- 덕분에 프로젝트 구조가 훨씬 직관적이고 깔끔해진답니다.\n\n### 5. 데이터 패칭 방식 변화\n\n- 기존 `getServerSideProps`, `getStaticProps`는 `app` 디렉토리에서는 새로운 API로 대체되었어요.\n- `getStaticPaths`도 이제 `generateStaticParams`로 교체되었죠.\n- 서버 사이드 렌더링 및 정적 생성 로직을 훨씬 모던한 방식으로 작성할 수 있어요.\n\n### 6. 페이지 기반 특수 파일들 대체\n\n| 기존 파일                       | 대체 파일                          |\n| ----------------------------- | -------------------------------- |\n| `pages/_app.js`, `pages/_document.js` | `app/layout.js` (루트 레이아웃)     |\n| `pages/_error.js`              | 경로별 `error.js` (더 세밀한 에러처리)|\n| `pages/404.js`                 | `not-found.js`                   |\n| `pages/api/*` (API Routes)     | `route.js` (Route Handler)       |\n\n---\n\n### [Step 1] app 디렉토리 만들고 Next.js 버전 최신화하기\n\n앱 디렉토리를 써보려면 Next.js 13.4 이상이 필요하니 최신 버전으로 업데이트하는 것부터 시작해 볼게요!\n\n```bash\nnpm install next@latest\n```\n\n---\n\n### 추가 꿀팁!\n\n- 중첩 라우트 구조때문에 URL 구조가 더 명확해져서 SEO에도 긍정적이에요.\n- 레이아웃을 여러 겹으로 쌓을 수 있어서 복잡한 UI도 깔끔하게 설계 가능!\n- 이제 `_app.js`나 `_document.js` 없이 루트 레이아웃 하나로 전역 설정 관리할 수 있으니 유지보수가 훨씬 편해졌어요.\n\n---\n\n한번 직접 `app` 폴더를 만들어서 중첩 라우트와 레이아웃을 적용해보는 걸 추천해요. 부담없이 프로젝트에 도입해보면 Next.js의 새로운 매력을 확실히 체감할 수 있을 거예요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프로젝트 루트(또는 src/ 디렉토리)에 새로 app 디렉토리를 만들어주세요.\n\n### 2단계: 루트 레이아웃 만들기\n\n이번에는 app 디렉토리 안에 app/layout.tsx 파일을 생성할 거예요. 이 파일은 app 안에 있는 모든 라우트에 적용되는 루트 레이아웃 역할을 합니다.\n\n```tsx\nexport default function RootLayout({\n  // 레이아웃은 children prop을 반드시 받아야 해요.\n  // 이 children에는 중첩된 레이아웃이나 페이지들이 들어가게 됩니다.\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <body>{children}</body>\n    </html>\n  )\n}\n```\n\n여기서 살짝 중요한 팁을 드리자면, 이 RootLayout은 Next.js의 `app` 디렉토리 구조에서 가장 기본 뼈대가 되기 때문에, 페이지마다 공통적으로 들어가는 요소들(예: `<head>`, 네비게이션 바, 푸터 등)을 이 안에 넣으면 유지보수가 훨씬 편해져요.\n\n그리고 `<html lang=\"en\">` 부분은 사이트의 기본 언어를 설정하는 거라, 한국어 사이트라면 `lang=\"ko\"`로 바꾸는 게 좋아요!\n\n조금 더 완성도를 높이고 싶다면 `<head>` 태그도 커스터마이징해서 메타데이터나 폰트 링크, 파비콘 등을 넣어주는 것도 추천드려요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js의 새로운 app 디렉토리 구조를 사용할 때 알아두면 좋은 몇 가지 핵심 포인트를 정리해봤어요!\n\n---\n\n### 1. app 디렉토리에 **루트 레이아웃(root layout)** 필수!\n\n- `app` 폴더 안에는 반드시 루트 레이아웃 파일이 있어야 해요.\n- 이 루트 레이아웃은 `html`, `body` 태그를 직접 정의해야 해요. Next.js가 자동으로 만들어주지 않거든요.\n- 기존에는 `pages/_app.tsx`와 `pages/_document.tsx`를 사용해서 전체 앱의 구조나 문서 태그를 조절했지만, 이제는 루트 레이아웃이 그 역할을 대신해요.\n- 레이아웃 파일 확장자는 `.js`, `.jsx`, `.tsx` 중 자유롭게 선택할 수 있어요.\n\n---\n\n### 2. SEO 관련 `head` 태그 관리도 간편해요!\n\n- `head` 태그 안에 들어가는 메타정보(예: `title`, `description`)를 관리할 땐 Next.js가 제공하는 내장 SEO 지원을 활용하면 좋아요.\n- 아래처럼 `metadata` 객체를 내보내기(export) 하면 페이지별로 메타정보가 자동으로 적용돼요.\n\n```ts\nimport type { Metadata } from 'next'\n\nexport const metadata: Metadata = {\n  title: 'Home',\n  description: 'Welcome to Next.js',\n}\n```\n\n---\n\n### 3. 기존 `_app.js`와 `_document.js` 마이그레이션\n\n- app 디렉토리를 사용할 때는 이 두 파일이 필요 없어요. 이 둘이 제공하던 기능 대부분이 루트 레이아웃으로 통합되었기 때문입니다.\n- 만약 이전에 작성해둔 커스텀 `_document.js`나 `_app.js`가 있다면, 꼭 app 라우팅 구조에 맞춰 루트 레이아웃으로 다시 작성해주는 게 좋아요.\n\n---\n\n### 개인적인 팁 한마디!\n\n- 루트 레이아웃 내에서 글로벌 CSS나 공통 UI 컴포넌트를 한번만 감싸주면 되니까, 코드가 훨씬 깔끔해지고 유지보수도 쉬워졌어요.\n- 또, `metadata` 덕분에 SEO 설정이 페이지마다 편하게 분리되어서 관리가 편해졌답니다.\n- 다만, `html`과 `body`를 직접 선언해야 하니 꼭 잊지 말고 작성해주세요!\n\n---\n\n다음 포스트에서는 app 디렉토리 구조를 활용하는 구체적인 예제와 함께 useRouter 훅 대신 사용할 새로운 라우팅 방법도 소개할게요. 기대해주세요! 😊\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 기존에 _app이나 _document 파일이 있다면, 그 안에 있던 내용들(예: 전역 스타일들)을 새로 만든 루트 레이아웃(app/layout.tsx)으로 옮길 수 있어요. 그런데 중요한 점은, app/layout.tsx에 있는 스타일은 pages/* 경로에 적용되지 않는다는 거예요. 그래서 마이그레이션하는 동안에는 기존 _app과 _document 파일을 유지하는 게 좋습니다. 그래야 pages/* 경로들이 갑자기 깨지지 않거든요. 모든 마이그레이션이 완전히 끝난 후에야 이 두 파일을 안전하게 지울 수 있답니다.\n\n또 하나, 만약 React Context 프로바이더를 사용 중이라면, 이걸 Client Component로 옮겨야 해요. Next.js의 새로운 앱 디렉토리 구조에서는 서버 컴포넌트와 클라이언트 컴포넌트를 명확하게 구분해서 관리하거든요.\n\n#### getLayout() 패턴에서 Layouts로 마이그레이션하기 (선택 사항)\n\n기존 pages 디렉토리에서는 페이지별로 레이아웃을 적용하기 위해 Page 컴포넌트에 getLayout()이라는 프로퍼티를 붙이는 방식을 많이 썼어요. 하지만 app 디렉토리에서는 **중첩 레이아웃(nested layouts)**을 네이티브로 지원하기 때문에 이 패턴이 불필요해요. 즉, 페이지별로 다른 레이아웃을 적용하고 싶으면, 레이아웃 파일들을 계층적으로 분리해서 구조화하면 된답니다. 훨씬 깔끔하고 유지보수도 쉬워지죠.\n\n---\n\n이제 이런 방식으로 코드를 새롭게 정리하다 보면, 각 페이지에서 레이아웃을 직접 관리할 필요 없이 폴더 구조만으로도 레이아웃이 매끄럽게 연결되는 걸 경험할 수 있을 거예요. Next.js 13부터 도입된 app 디렉토리 방식이 가져다주는 가장 큰 장점 중 하나입니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 3단계: next/head 마이그레이션하기\n\nNext.js의 `pages` 디렉토리에서는 `next/head` 컴포넌트를 이용해서 HTML 문서의 `<head>` 부분, 예를 들어 `title`이나 `meta` 태그를 관리하죠. 그런데 `app` 디렉토리로 넘어오면 `next/head` 대신 새로운 내장 SEO 지원 기능을 사용해야 해요.\n\n기존에는 이렇게 썼었죠:\n\n```js\nimport Head from 'next/head'\n \nexport default function Page() {\n  return (\n    <>\n      <Head>\n        <title>My page title</title>\n      </Head>\n    </>\n  )\n}\n```\n\n---\n\n새로운 `app` 디렉토리에서는 `head` 관리가 훨씬 간편해졌어요. 이제는 페이지 컴포넌트 내에서 별도로 `<Head>` 컴포넌트를 쓸 필요 없이, `metadata`라는 방식을 사용해 `title` 같은 SEO 관련 정보를 설정할 수 있어요.\n\n아래는 간단한 예시입니다:\n\n```js\nexport const metadata = {\n  title: 'My page title',\n  description: '페이지 설명을 여기에 작성하세요',\n}\n\nexport default function Page() {\n  return (\n    <div>\n      {/* 페이지 콘텐츠 */}\n    </div>\n  )\n}\n```\n\n이렇게 `metadata`를 export 하면 Next.js가 알아서 `<head>`에 적절한 태그들을 넣어줘요. 덕분에 코드도 훨씬 깔끔해지고, SEO 관리도 편해집니다.\n\n> 참고로 `metadata`에서 지원하는 옵션은 `title`, `description`, `openGraph`, `twitter` 등 굉장히 다양하니 필요에 맞게 활용해보세요.\n\n---\n\n요약하자면,\n\n| 이전 방식 (`pages` 폴더)        | 새로운 방식 (`app` 폴더)                   |\n|---------------------------|------------------------------------|\n| `import Head from 'next/head'` 사용 | `metadata` 객체 export로 설정             |\n| JSX 안에 `<Head>...</Head>` 작성    | 컴포넌트 밖에 `export const metadata = {...}` 작성 |\n\n이제부터는 `head` 요소를 직접 다루기보단, `metadata`를 통해 쉽고 깔끔하게 SEO를 관리하는 방법에 적응해 보세요! 이는 Next.js가 미래 지향적으로 제공하는 공식적인 추천 방식이기도 합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n자, 위 코드는 Next.js에서 메타데이터를 설정하는 아주 기본적인 예시예요.\n\n```js\nimport type { Metadata } from 'next'\n\nexport const metadata: Metadata = {\n  title: 'My Page Title',\n}\n\nexport default function Page() {\n  return '...'\n}\n```\n\n여기서 `metadata` 객체를 통해 페이지의 타이틀을 설정하고 있어요. 이 방식은 Next.js 13 이상에서 메타데이터를 좀 더 체계적으로 관리할 수 있게 해주는 방법 중 하나랍니다.\n\n---\n\n### 메타데이터 옵션 리스트\n\nNext.js에서 지원하는 메타데이터 옵션은 상당히 다양해요. 예를 들면:\n\n| 옵션 이름          | 설명                       |\n|-----------------|--------------------------|\n| title           | 페이지의 제목 설정               |\n| description     | 페이지 설명(SEO에 중요)         |\n| keywords        | 검색 최적화를 위한 키워드 배열      |\n| openGraph       | 오픈그래프 태그 설정 (SNS 공유 시) |\n| twitter         | 트위터 카드 정보 설정           |\n| robots          | 크롤러를 위한 접근 제어 설정       |\n| manifest       | PWA용 웹앱 매니페스트 연결         |\n\n이 외에도 다양한 옵션들이 있으니 공식 문서를 참고하면 좋아요.\n\n---\n\n### Step 4: 페이지 마이그레이션하기\n\nNext.js 프로젝트를 새 버전으로 옮기면서 기존 페이지들을 어떻게 마이그레이션해야 하는지 고민되시죠? 가장 중요한 건 메타데이터를 더 이상 `head` 태그나 `next/head` 컴포넌트로 관리하지 않고, 위처럼 `metadata` 객체로 관리하는 방식으로 바꾸는 거예요.\n\n또한, 서버 컴포넌트(Server Component)를 적극 활용해서 페이지 성능과 유지보수성을 높일 수 있어요. 예를 들어, 데이터 페칭도 페이지 바로 위에서 처리하고 UI는 순수하게 렌더링만 하도록 분리할 수 있답니다.\n\n마이그레이션할 때는 아래 포인트를 기억하면 좋아요:\n- **메타데이터:** 기존 `Head` 대신 `metadata` 객체 활용\n- **서버 컴포넌트:** 서버에서 데이터 처리하고 UI는 클라이언트 컴포넌트와 분리 가능\n- **라우팅:** app 폴더 기반 라우팅을 잘 이해하고 기존 pages 폴더 구조와 맞게 조정\n- **스타일링:** 글로벌 스타일, CSS 모듈, Tailwind 등 스타일링 방법은 동일하지만 적용 위치에 따라 차이가 있을 수 있음\n\n마이그레이션 전후로 빌드 및 렌더링 결과를 꼭 확인하며 진행하는 게 좋아요!\n\n필요하면 마이그레이션 사례도 따로 정리해볼 테니 궁금한 점 있으면 언제든지 질문해 주세요. 😊\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안녕하세요 여러분! 오늘은 Next.js의 새로운 `app` 디렉토리에 대해 이야기해볼게요. 기존 `pages` 디렉토리와 비교하면서 어떤 점이 달라졌는지, 그리고 마이그레이션하는 가장 쉬운 방법도 함께 소개해드릴게요.\n\n---\n\n### 1. 기본 컴포넌트 유형의 변화\n\n- `app` 디렉토리 내의 페이지들은 **기본적으로 Server Components**로 작동해요.\n- 반면, 기존 `pages` 디렉토리의 페이지들은 **Client Components**가 기본이었죠.\n\n쉽게 말해, `app` 디렉토리는 서버에서 렌더링하는 컴포넌트를 기본으로 하되 필요하면 클라이언트 컴포넌트를 따로 만들어서 사용한다는 점에서 차이가 있어요.\n\n---\n\n### 2. 데이터 패칭 방식 변화\n\n기존 `pages` 디렉토리에서는 `getServerSideProps`, `getStaticProps`, `getInitialProps` 같은 함수들을 사용했는데요, `app` 디렉토리는 이 복잡한 API들을 **더 간단한 API로 교체**했답니다. 데이터를 가져오는 방법이 훨씬 깔끔해졌죠.\n\n---\n\n### 3. 라우팅 방식과 파일 구조\n\n`app` 디렉토리는 중첩 폴더 구조를 이용해 라우트를 정의하고, 각 폴더 안에 `page.js` 파일을 만들어서 해당 경로를 외부에서 접근할 수 있게 해요.\n\n예를 들어, 기존 `pages`와 `app` 디렉토리 라우팅 비교는 다음과 같아요:\n\n| pages 디렉토리       | app 디렉토리             | 라우트 경로       |\n|---------------------|-------------------------|------------------|\n| index.js            | page.js                 | /                |\n| about.js            | about/page.js           | /about           |\n| blog/[slug].js      | blog/[slug]/page.js     | /blog/post-1     |\n\n---\n\n### 4. 마이그레이션 가이드: 가장 쉬운 방법\n\n`pages`에서 `app`으로 옮길 때, 저희가 추천하는 방법은 크게 두 단계예요.\n\n1. **Step 1**: 기존에 기본 내보내기(default export)했던 페이지 컴포넌트를 **새로운 클라이언트 컴포넌트로 옮기기**  \n   - 이 때 `use client` 지시어를 추가하는 걸 잊지 마세요! 클라이언트 전용 컴포넌트임을 명시하는 거죠.\n\n2. **Step 2**: `app` 디렉토리 내에 새로운 `page.js` 파일을 만들고, 거기에 이 클라이언트 컴포넌트를 임포트해서 사용하기\n\n---\n\n### 덧붙여서: 왜 이렇게 하는 게 좋을까?\n\n이 방식이 가장 **`pages` 디렉토리와 비슷한 동작을 보장하기 때문에** 마이그레이션이 가장 쉽고 안정적이에요. 급진적으로 구조를 바꾸지 않고도 기존의 방식을 최대한 유지하면서 새로운 `app` 디렉토리의 장점도 누릴 수 있거든요.\n\n---\n\n이상으로 Next.js의 `app` 디렉토리 기본 사항과 마이그레이션 방법에 대해 간단히 정리해봤어요. 새로워진 Next.js를 활용해서 더 깔끔하고 효율적인 프로젝트를 만들어보세요!\n\n궁금한 점 있으면 댓글로 알려주세요~\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n자, 이제 Next.js 앱에서 'Client Component'를 만들어보는 방법에 대해 설명해볼게요. 너무 딱딱하지 않게 쉽게 풀어서 이야기할게요!\n\n---\n\n## Step 1: 새로운 Client Component 만들기\n\n먼저, `app` 디렉터리 안에 새로운 파일을 만들어줘요. 예를 들면 `app/home-page.tsx` 같은 파일이죠. 이 파일에서 Client Component를 정의하려면, 파일 맨 위에 `'use client'`라는 지시어를 꼭 추가해야 해요. 이건 컴포넌트를 클라이언트 쪽에서 실행하겠다는 뜻이에요.\n\n매우 중요한 점! `pages` 디렉토리에서 작업할 때처럼, Next.js가 초기 페이지 로드 때 이 Client Component를 정적 HTML로 미리 렌더링(prerender)하는 최적화 과정이 있답니다.\n\n기존에 `pages/index.js`에 있던 기본 페이지 컴포넌트를 이제 `app/home-page.tsx`로 옮겨주세요.\n\n다음은 간단한 예시 코드에요:\n\n```js\n'use client'\n\n// 이 컴포넌트는 클라이언트 컴포넌트예요.\n// props로 데이터를 받고, state와 useEffect 같은 훅을 쓸 수 있죠.\n// 그리고 초기 페이지 로드 시 서버에서 미리 렌더링 돼요.\nexport default function HomePage({ recentPosts }) {\n  return (\n    <div>\n      {recentPosts.map((post) => (\n        <div key={post.id}>{post.title}</div>\n      ))}\n    </div>\n  )\n}\n```\n\n---\n\n같은 내용을 조금 더 쉽게 설명하자면: \n\n- `'use client'`를 붙이면 Next.js가 \"아, 이건 브라우저에서 실행될 컴포넌트구나\"라고 인식해요.\n- 클라이언트 컴포넌트 안에서는 **State 관리, 이벤트, useEffect** 같은 React 훅을 활용할 수 있어서 인터랙티브한 UI를 만들기 좋아요.\n- 하지만 Next.js 최적화 덕분에, 초기 화면은 서버에서 미리 렌더링해서 빠르게 띄워줍니다!\n\n---\n\n## Step 2: 새로운 페이지 만들기\n\n이 부분은 다음 메시지에 더 자세히 다룰게요!\n\n---\n\n필요하면 더 궁금한 점이나 코딩 팁도 많이 얘기해 줄게요. Next.js 앱 구조, Client/Server Components 개념이 처음이면 조금 헷갈릴 수 있는데, 천천히 익히면 아주 강력한 UI를 만들 수 있어요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n자, 이번에는 Next.js의 app 디렉토리에서 페이지와 라우팅을 설정하는 방법을 한번 알아볼게요. 기존 pages 디렉토리에서 하던 방식과 비교하면서 쉽게 이해할 수 있도록 설명해볼게요.\n\n---\n\n### 1. app/page.tsx 만들기 (Server Component)\n\n먼저, `app` 폴더 안에 `page.tsx` 파일을 하나 만들어주세요. 여기서 중요한 점은 **app 디렉토리 내 파일들은 기본적으로 서버 컴포넌트(Server Component)**라는 거예요. 서버 컴포넌트는 서버에서 데이터를 직접 받아오고 렌더링을 담당해서 클라이언트보다 효율적이고 느린 데이터 요청에도 영향이 적답니다.\n\n```tsx\n// app/page.tsx\n\n// client 컴포넌트인 홈 페이지를 import 해줘요\nimport HomePage from './home-page'\n\nasync function getPosts() {\n  const res = await fetch('https://...')\n  const posts = await res.json()\n  return posts\n}\n\nexport default async function Page() {\n  // 서버 컴포넌트 안에서 데이터를 바로 fetch해요\n  const recentPosts = await getPosts()\n  \n  // 받아온 데이터를 client 컴포넌트에 넘겨줍니다\n  return <HomePage recentPosts={recentPosts} />\n}\n```\n\n> TIP: `fetch` 작업을 서버 컴포넌트에서 하면 클라이언트가 데이터를 기다리는 상황이 줄어든다는 장점이 있어요.\n\n---\n\n### 2. pages/index.js의 데이터 fetching 로직 옮기기\n\n기존에 `pages/index.js`에서 데이터를 fetch 했던 로직, 그대로 `app/page.tsx`에 옮겨오면 됩니다. 그리고 페이지 컴포넌트가 async 함수로 정의되어 있어야 데이터를 await로 처리할 수 있어요.\n\n---\n\n### 3. 클라이언트 컴포넌트 가져오기\n\n위 코드에서 `HomePage`는 클라이언트 컴포넌트라면 `app/home-page.tsx` 같은 위치에 작성되어 있어야 해요. `useState`, `useEffect` 같은 클라이언트 전용 훅들을 사용하는 컴포넌트라면 `use client` 지시어를 최상단에 적어줘야 합니다.\n\n```tsx\n// app/home-page.tsx\n'use client'\n\nimport React from 'react'\n\nexport default function HomePage({ recentPosts }) {\n  return (\n    <div>\n      <h1>최근 게시물</h1>\n      <ul>\n        {recentPosts.map(post => (\n          <li key={post.id}>{post.title}</li>\n        ))}\n      </ul>\n    </div>\n  )\n}\n```\n\n---\n\n### 4. 새로운 라우팅 훅 사용하기\n\n예전 `pages` 폴더 대비 `app` 디렉토리에서는 routing도 조금 달라졌어요. `useRouter`를 비롯한 라우팅 관련 훅들이 `next/navigation`에서 새롭게 제공됩니다.\n\n```tsx\nimport { useRouter, usePathname, useSearchParams } from 'next/navigation'\n\nexport default function MyComponent() {\n  const router = useRouter()\n  const pathname = usePathname()\n  const searchParams = useSearchParams()\n\n  // 라우팅 변경, 현재 경로, 쿼리 파라미터 읽기 등에 사용 가능\n}\n```\n\n기존 `next/router` 대신 이 훅들을 꼭 사용해주세요!\n\n---\n\n### 5. 개발 서버 실행하고 확인하기\n\n이제 모두 마쳤으면 개발 서버를 실행해 봅시다.\n\n```bash\nnpm run dev\n```\n\n또는\n\n```bash\nyarn dev\n```\n\n그리고 브라우저에서 `http://localhost:3000`에 접속하면, 기존 index 페이지가 `app/page.tsx`를 통해 렌더링 되는 걸 볼 수 있을 거예요.\n\n---\n\n## 정리!\n\n| 단계 | 설명 |\n|---|---|\n| 1 | `app/page.tsx` 생성하여 Server Component로 페이지 작성하기 |\n| 2 | 기존 pages의 데이터 fetching 로직을 서버 컴포넌트 내에서 처리하도록 옮기기 |\n| 3 | 클라이언트 컴포넌트는 `use client` 지시어 붙이고, 데이터 props로 받기 |\n| 4 | `next/navigation`의 새로운 routing 훅(`useRouter`, `usePathname`, `useSearchParams`) 사용하기 |\n| 5 | 개발 서버 돌려서 잘 되는지 확인하기 |\n\n---\n\nNext.js의 `app` 디렉토리는 서버와 클라이언트 컴포넌트가 명확히 구분되고, React의 최신 기능들(Suspense, Server Components 등)을 활용할 수 있어서 성능도 좋아지고 개발도 편해졌어요. 처음 접하면 헷갈릴 수 있으니 차근차근 바꾸면서 적응해보세요!\n\n궁금한 점 있으면 언제든 질문해 주세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서 `useRouter` 훅에 큰 변화가 있었어요! 특히 `app` 디렉터리에서는 이전에 쓰던 `next/router`에서 가져오는 `useRouter`가 지원되지 않고, 대신 `next/navigation`에서 가져오는 새로운 훅을 써야 해요.\n\n---\n\n### 핵심 정리\n\n| 이전(useRouter from next/router) | 최신(useRouter from next/navigation) |\n|---|---|\n| `pages` 디렉터리에서만 사용 가능 | `app` 디렉터리에서 사용 가능 (pages에서는 기존 걸 계속 사용 가능) |\n| `pathname` 문자열 반환 | 반환하지 않음. 대신 `usePathname()` 사용 |\n| `query` 객체 반환 (검색 파라미터 + 동적 라우팅 파라미터 섞여 있음) | 반환하지 않음. 대신 `useSearchParams()`와 `useParams()`를 각각 사용 |\n| `isFallback`, `locale`, `basePath`, `asPath`, `isReady`, `route` 등 여러 프로퍼티 존재 | 여러 속성이 제거됨 (예: `isFallback` 사라짐, `locale` 관련 제거 등) |\n| 서버 및 클라이언트 컴포넌트에서 사용 가능 | 오로지 클라이언트 컴포넌트에서만 사용 가능 |\n\n---\n\n### 새로운 훅 사용법 예시\n\n```jsx\n'use client'\n\nimport { useRouter, usePathname, useSearchParams } from 'next/navigation'\n\nexport default function ExampleClientComponent() {\n  const router = useRouter()\n  const pathname = usePathname()\n  const searchParams = useSearchParams()\n\n  // 예시: 쿼리 파라미터 'id' 값 가져오기\n  const id = searchParams.get('id')\n\n  const goHome = () => {\n    router.push('/')\n  }\n\n  return (\n    <div>\n      <p>현재 경로: {pathname}</p>\n      <p>id 파라미터: {id}</p>\n      <button onClick={goHome}>홈으로 이동</button>\n    </div>\n  )\n}\n```\n\n---\n\n### 조금 더 알아볼 점\n\n- `useSearchParams`는 브라우저 URL의 쿼리스트링 부분을 다룰 때 쓰고,\n- `useParams`는 `[slug]` 같은 동적 세그먼트 파라미터 값을 가져올 때 사용해요.\n- `usePathname`은 현재 경로를 문자열로 알려줍니다.\n\n이 훅들만 조합하면 이전 `useRouter`가 했던 거의 모든 일을 하실 수 있답니다.\n\n---\n\n### 몇 가지 팁\n\n1. **클라이언트 컴포넌트에서만 사용 가능!**  \n   서버 컴포넌트에서는 작동하지 않으니, 위 예시에선 `'use client'` 지시어가 필요한 이유예요.\n\n2. **라우팅 이벤트 감지는?**  \n   `usePathname`과 `useSearchParams`를 조합해서 경로 변경을 감지하세요. 예전처럼 `router.events`는 지원되지 않아요.\n\n3. **국제화(i18n) 지원 변화**  \n   `locale`, `locales` 등 국제화 관련 속성이 사라진 점 참고하세요. `app` 디렉토리에서는 다르게 i18n을 다뤄야 합니다.\n\n4. **`isReady` 사라짐**  \n   예전엔 라우터가 초기화될 때까지 기다리는 상태였는데, 이제는 클라이언트 렌더링 단계에서 알아서 처리합니다.\n\n---\n\n새로운 `useRouter`가 구조가 더 깔끔해졌지만, 그만큼 `usePathname`, `useSearchParams`, `useParams` 같은 훅들을 같이 잘 활용해야 하는 점 기억하세요! Next.js 앱 디렉터리 기반 라우팅을 공부 중이라면 이 변화는 꼭 알아두시고 작업하세요~\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nuseRouter() API 참고하기\n\n#### 페이지와 앱 사이에서 컴포넌트 공유하기\n\nNext.js에서 페이지 라우터와 앱 라우터를 동시에 지원하는 컴포넌트를 만들려면, `next/compat/router`에서 제공하는 `useRouter` 훅을 사용하는 게 좋아요. 이 훅은 페이지 디렉토리에서 쓰이는 `useRouter`와 같지만, 두 라우터 환경 사이에서 컴포넌트를 공유할 때 호환성을 유지하도록 설계되어 있답니다.\n\n그리고 언젠가 앱 라우터만 사용하게 될 시점이 오면, 그때는 `next/navigation`에서 제공하는 최신 `useRouter`로 바꾸는 걸 권장해요. 이렇게 하면 더 깔끔하고 최신 패턴에 맞는 코드가 되니까요!\n\n---\n\n### 6단계: 데이터 가져오기 방법 마이그레이션하기\n\n다음 단계에서는 데이터 패칭 관련 메서드를 어떻게 마이그레이션하는지 살펴볼 거예요. Next.js 13부터는 새롭게 도입된 앱 라우터 환경에 맞춰 데이터 가져오는 방법도 많이 바뀌었으니, 꼭 참고해서 업데이트해보시길 바랍니다.\n\n---\n\n**덧붙여서!**  \n만약 여러분이 컴포넌트를 여러 라우터 환경에서 쓸 일이 많다면, `next/compat/router` 쪽 `useRouter` 훅을 사용하는 게 당분간은 가장 안정적인 방법이에요. 나중에 앱 라우터만 쓰게 되면, `next/navigation`에서 `useRouter`가 훨씬 더 가볍고 빠른 API를 제공하니 그때 갈아타는 걸 추천드립니다!\n\n추가로, `useRouter`를 통해 라우팅 정보를 얻는 법뿐 아니라, 프로그램적으로 라우팅을 제어하는 방법도 익히면 개발 효율이 훨씬 올라가요. 필요하면 언제든 더 자세히 공유할게요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서 데이터 패칭 방식을 다루는 걸 보면, 전통적으로 pages 디렉토리에서는 getServerSideProps와 getStaticProps를 많이 사용해왔어요. 그런데 app 디렉토리에서는 이 패턴이 조금 바뀌어서, fetch()와 React Server Components를 기반으로 더 간단하게 데이터를 가져올 수 있도록 바뀌었답니다.\n\n---\n\n## app 디렉토리의 데이터 패칭 방식\n\n```js\nexport default async function Page() {\n  // 이 요청은 수동으로 무효화될 때까지 캐시됩니다.\n  // getStaticProps와 비슷한 역할.\n  // 'force-cache'가 기본값이라 생략 가능해요.\n  const staticData = await fetch(`https://...`, { cache: 'force-cache' })\n \n  // 이 요청은 매 요청마다 다시 불러옵니다.\n  // getServerSideProps와 비슷하죠.\n  const dynamicData = await fetch(`https://...`, { cache: 'no-store' })\n \n  // 이 요청은 10초 동안만 캐시되고 재검증됩니다.\n  // getStaticProps의 revalidate 옵션과 유사해요.\n  const revalidatedData = await fetch(`https://...`, {\n    next: { revalidate: 10 },\n  })\n \n  return <div>...</div>\n}\n```\n\n여기서 중요한 점은, 이제 더 이상 별도의 데이터 패칭 함수들을 페이지 밖에서 선언할 필요 없이 컴포넌트 내부에서 일반적인 async 함수처럼 fetch를 호출할 수 있다는 점이에요. 그리고 fetch 옵션을 통해 원하는 캐싱 전략을 직접 지정할 수 있죠.\n\n---\n\n## pages 디렉토리의 getServerSideProps\n\npages 디렉토리에서는 getServerSideProps가 서버에서 데이터를 가져와서 props로 넘겨주고, 그 데이터를 기반으로 초기 HTML을 렌더링해요. 이렇게 서버에서 미리 렌더링된 페이지가 클라이언트에서 \"hydrating\" 되어 인터랙티브해집니다.\n\n간단히 말해서:\n\n- **getServerSideProps:** 서버에서 매 요청마다 실행\n- **getStaticProps:** 빌드 시점에 한번 실행, 필요시 revalidate 옵션으로 주기적 재생성\n\n---\n\n## 한마디 정리!\n\n- app 디렉토리에서는 React Server Components와 fetch의 cache 옵션을 이용해 데이터 패칭을 직접 관리.\n- pages 디렉토리에서는 기존처럼 getServerSideProps, getStaticProps를 통해 데이터를 패칭.\n- 앞으로 Next.js를 사용하면서 app 디렉토리를 많이 쓰게 되면 더 선언적이고 코드가 직관적인 fetch 기반 방식을 자주 보게 될 거예요.\n\n---\n\n### 추가 팁\n\n- `cache: 'force-cache'`는 기본값이니, 특별히 동적 데이터를 자주 변경시키지 않는다면 생략해도 무방해요.\n- 반대로 `cache: 'no-store'`를 사용하면 실제로 서버에서만 데이터를 요청하고 클라이언트나 중간 캐시는 전혀 사용하지 않으니 주의하세요.\n- `next: { revalidate: 10 }`를 활용하면 10초마다 캐시를 재검증해서 최신 데이터를 일정 주기로 반영할 수 있어요.\n\n이제 Next.js 데이터 패칭 방식이 훨씬 유연하고 직관적으로 변해서 개발할 때 훨씬 편해질 거예요! 궁금한 점 있으면 언제든 물어봐 주세요~\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js의 pages 디렉토리 방식과 App Router (app 디렉토리) 방식에서 서버 사이드 데이터 패칭을 어떻게 하는지 비교해볼게요.\n\n---\n\n### pages 디렉토리 방식 (기존 방식)\n\n```js\nexport async function getServerSideProps() {\n  const res = await fetch(`https://...`)\n  const projects = await res.json()\n\n  return { props: { projects } }\n}\n\nexport default function Dashboard({ projects }) {\n  return (\n    <ul>\n      {projects.map((project) => (\n        <li key={project.id}>{project.name}</li>\n      ))}\n    </ul>\n  )\n}\n```\n\n- `getServerSideProps`는 페이지 요청 시마다 서버에서 데이터 패칭 후 HTML을 렌더링해서 클라이언트에 보냅니다.\n- 장점: 최신 데이터를 항상 보여줌\n- 단점: 페이지 요청마다 데이터 패칭, 클라이언트로 전송되는 자바스크립트 번들에는 데이터 패칭 코드가 없음\n\n---\n\n### App Router 방식 (app 디렉토리)\n\n```js\n// 이 함수 이름은 자유롭게 지어도 됩니다\nasync function getProjects() {\n  const res = await fetch(`https://...`, { cache: 'no-store' })\n  const projects = await res.json()\n\n  return projects\n}\n\nexport default async function Dashboard() {\n  const projects = await getProjects()\n\n  return (\n    <ul>\n      {projects.map((project) => (\n        <li key={project.id}>{project.name}</li>\n      ))}\n    </ul>\n  )\n}\n```\n\n- React 서버 컴포넌트(Server Components) 내에서 바로 비동기 함수로 데이터를 패칭할 수 있어요.\n- `{ cache: 'no-store' }` 옵션을 주면 `getServerSideProps`처럼 매 요청마다 항상 최신 데이터를 받아옵니다.\n- 클라이언트에 불필요한 자바스크립트가 덜 전달되므로 초기 로딩이 더 빠릅니다.\n- 서버에서 렌더링된 HTML이 바로 클라이언트에 전달되어 SEO에도 좋습니다.\n\n---\n\n### 추가 팁!\n\n- `cache` 옵션에는 `'force-cache'`(기본값, ISR 적용 가능)나 `'no-store'` 외에도 다양한 값이 있어요. 상황에 따라 적절히 선택해 주세요.\n- 서버 컴포넌트 명령문 안에서는 클라이언트 전용 훅 같은 것들을 사용할 수 없으니 주의!\n- 점점 Next.js가 React Server Components 방식을 중심으로 발전하고 있으니 새 프로젝트에서는 app 디렉토리 방식을 고려해보세요.\n\n---\n\nNext.js에서도 이렇게 진화한 서버사이드 데이터 패칭 방식을 활용하면 성능과 개발 경험 모두 잡을 수 있답니다! 궁금한 점 있으면 언제든 물어보세요~\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n#### Request 객체 접근하기\n\nNext.js의 `pages` 디렉토리에서는 Node.js의 HTTP API를 바탕으로 요청(request) 관련 데이터를 쉽게 가져올 수 있어요.\n\n예를 들어, `getServerSideProps` 함수에서 `req` 객체를 받아서 요청의 쿠키나 헤더 정보를 조회할 수 있답니다. 이렇게 하면 서버 사이드에서 특정 쿠키 값이나 인증 헤더 등을 읽어서 조건에 따라 페이지 렌더링을 다르게 처리할 수 있죠.\n\n아래 예시를 보시죠:\n\n```js\n// pages 디렉토리 내에서\n\nexport async function getServerSideProps({ req, query }) {\n  const authHeader = req.getHeaders()['authorization']; // 요청 헤더에서 'authorization' 정보 가져오기\n  const theme = req.cookies['theme']; // 요청 쿠키에서 'theme' 값 가져오기\n\n  return { props: { authHeader, theme } } // props로 페이지 컴포넌트에 전달\n}\n\nexport default function Page(props) {\n  return (\n    <div>\n      <p>Authorization Header: {props.authHeader}</p>\n      <p>Theme from Cookie: {props.theme}</p>\n    </div>\n  )\n}\n```\n\n### 여기서 한 가지 팁!\n- `req.cookies`를 쓰려면 쿠키 파서를 따로 설치하거나 설정해야 할 수도 있어요. 보통 Next.js에서는 내장된 API가 자동으로 쿠키를 파싱해주긴 하지만, 커스텀 미들웨어를 사용할 때 주의해야 합니다.\n- 헤더 이름은 대소문자를 구분하지 않지만, 보통 `authorization`처럼 소문자로 접근하는 게 편해요.\n\n이처럼 서버 사이드에서 요청 관련 데이터를 활용하면 인증, 테마 설정, 사용자 맞춤 데이터 처리 등 다양한 기능을 구현할 수 있어서 강력하답니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이번에는 Next.js의 app 디렉토리에서 제공하는 새로운 읽기 전용 함수인 headers와 cookies에 대해 알려드릴게요. 이 둘은 서버 컴포넌트(Server Components) 내에서 요청(request) 데이터를 쉽게 가져올 수 있게 도와줘요.\n\n---\n\n### headers 와 cookies 함수란?\n\n- **headers**: Web Headers API를 기반으로 만들어졌으며, 서버 컴포넌트 안에서 요청 헤더 정보를 가져올 때 사용해요.\n- **cookies**: Web Cookies API를 기반으로 하며, 서버 컴포넌트에서 쿠키 정보를 가져올 수 있어요.\n\n즉, 클라이언트가 보낸 요청 헤더와 쿠키 값을 서버 컴포넌트 내에서 간편하게 읽을 수 있도록 Next.js에서 제공하는 기능이죠.\n\n---\n\n### 간단한 코드 예시\n\n```jsx\n// app 디렉토리 예시\nimport { cookies, headers } from 'next/headers'\n\nasync function getData() {\n  const authHeader = (await headers()).get('authorization')\n  \n  return '...'\n}\n\nexport default async function Page() {\n  // 직접 Server Components 내부나 데이터 요청 함수에서 cookies, headers 사용 가능\n  const theme = (await cookies()).get('theme')\n  const data = await getData()\n  return '...'\n}\n```\n\n위 예시처럼 `headers()`와 `cookies()` 함수는 async 함수로, 호출하면 각각 헤더와 쿠키 객체를 반환해요. 그리고 그 객체에서 `.get('키 이름')`으로 내가 원하는 값을 꺼낼 수 있죠.\n\n---\n\n### 좀 더 알면 좋은 점\n\n- **읽기 전용임을 기억하세요**: 이 함수들은 요청 시 전달된 헤더나 쿠키를 읽기만 할 수 있어요. 수정이나 생성 기능은 없답니다.\n- **클라이언트 컴포넌트에서는 사용 불가**: 이 함수들은 서버 컴포넌트에서만 사용할 수 있기 때문에 클라이언트 컴포넌트에서 호출하려면 다른 방법을 써야 해요.\n- **getStaticProps 대신 사용 가능**: 기존에 `getStaticProps`로 서버에서 요청 데이터를 다뤘던 부분을 app 디렉토리 기반 서버 컴포넌트에서 훨씬 간단하게 처리할 수 있게 된 거죠.\n\n---\n\n### 마무리\n\nNext.js의 app 디렉토리에서 headers와 cookies 함수는 요청 데이터를 안전하고 간편하게 다룰 수 있도록 해줘서, 서버 컴포넌트를 작성할 때 진짜 편리하답니다. 이제 상태 관리나 요청 처리 로직에 대해 걱정 없이, 필요한 헤더나 쿠키를 바로바로 읽어와서 활용해보세요!\n\n필요하다면 더 깊게 활용하는 방법도 알려드릴게요. 언제든 질문해주세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이번 글에서는 Next.js에서 페이지를 미리 렌더링하고 데이터를 가져오는 방법을 비교해볼게요. 특히 pages 디렉터리와 app 디렉터리에서 각각 어떻게 데이터 페칭을 하는지 살펴보겠습니다.\n\n---\n\n## pages 디렉터리: getStaticProps로 빌드 시 데이터 가져오기\n\npages 디렉터리에서는 `getStaticProps` 함수로 빌드 시점에 데이터를 가져와 페이지를 미리 렌더링해요. 외부 API나 데이터베이스에서 필요한 데이터를 가져와서 페이지 컴포넌트에 props로 넘겨줄 수 있죠.\n\n```js\n// pages/index.js\n\nexport async function getStaticProps() {\n  const res = await fetch(`https://...`)\n  const projects = await res.json()\n\n  return { props: { projects } }\n}\n\nexport default function Index({ projects }) {\n  return projects.map((project) => <div key={project.id}>{project.name}</div>)\n}\n```\n\n- 여기서 `getStaticProps`는 빌드 타임에서만 실행되고, HTML을 미리 만들어두기 때문에 빠른 초기 로딩이 장점이에요.\n- 단, 빌드 후에 데이터 변경사항이 있으면 다시 빌드해야합니다.\n- `project` 리스트를 렌더링할 때는 React의 key prop 챙기는 걸 잊지 마세요!\n\n---\n\n## app 디렉터리: fetch() 사용 시 기본 캐시 전략\n\napp 디렉터리에서는 서버 컴포넌트 내부에서 `fetch()`를 직접 사용해서 데이터를 가져올 수 있는데요, 이때 기본 옵션이 `cache: 'force-cache'`라서 기본적으로 데이터를 캐싱해요. 즉, 빌드 시 캐싱된 값을 계속 사용하다가 수동으로 캐시를 무효화할 때까지 재요청하지 않습니다.\n\n```js\n// app/page.js\n\n// 함수 이름은 자유롭게 지어도 됩니다.\nasync function getProjects() {\n  const res = await fetch(`https://...`)\n  const projects = await res.json()\n\n  return projects\n}\n\nexport default async function Index() {\n  const projects = await getProjects()\n\n  return projects.map((project) => <div key={project.id}>{project.name}</div>)\n}\n```\n\n- 서버 컴포넌트는 async 함수로 작성 가능해서 데이터를 서버에서 바로 받아올 수 있어요.\n- `fetch`의 기본 캐싱 정책 덕분에 getStaticProps와 유사하게 캐시된 데이터를 재사용할 수 있답니다.\n- 물론 필요하면 `fetch` 옵션으로 `cache: 'no-store'` 또는 `revalidate` 값을 조정해서 데이터 최신화 정책을 관리할 수도 있어요.\n\n---\n\n## 요약\n\n| 특징                   | pages 디렉터리 (getStaticProps)               | app 디렉터리 (fetch 기본 캐시)                    |\n|-----------------------|----------------------------------------------|---------------------------------------------------|\n| 데이터 페칭 시점         | 빌드 타임                                     | 서버 컴포넌트 실행 시 (기본 캐시 포함)                |\n| 데이터 캐싱 정책          | 빌드 후에는 고정, 다시 빌드해야 업데이트           | 기본 `force-cache` (캐시 수동 무효화 가능)               |\n| 사용법                  | `getStaticProps` 함수 별도 선언               | 서버 컴포넌트 안에서 바로 fetch                      |\n| 서버 컴포넌트 지원 여부    | 없음                                         | 지원                                            |\n\n---\n\nNext.js 13 버전부터는 app 디렉터리를 점점 더 권장하기 때문에, 기존 pages 디렉터리에서 했던 데이터 페칭 로직을 점차 바꾸는 것도 좋은 방법이에요. 단, 프로젝트 상황에 따라 필요한 캐싱 전략이나 데이터 최신화 정책을 잘 고민해서 적용하는 게 중요합니다.\n\n추가로, app 디렉터리에서는 React Server Components를 활용해서 클라이언트 측 JavaScript를 최소화하는 장점도 있어요. 다음에 React Server Components에 대해서도 한번 같이 살펴볼게요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n#### 다이나믹 경로 (getStaticPaths)\n\nNext.js에서 **pages** 디렉토리에선 `getStaticPaths` 함수를 사용해서 미리 빌드 타임에 생성할 동적 경로들을 정의해줍니다. 예를 들어, 게시글(id가 1, 2인 글)을 미리 만들어두고 싶을 때 이렇게 설정할 수 있죠.\n\n```js\n// pages 디렉토리 예시\nimport PostLayout from '@/components/post-layout'\n \nexport async function getStaticPaths() {\n  return {\n    paths: [{ params: { id: '1' } }, { params: { id: '2' } }],\n  }\n}\n \nexport async function getStaticProps({ params }) {\n  const res = await fetch(`https://.../posts/${params.id}`)\n  const post = await res.json()\n \n  return { props: { post } }\n}\n \nexport default function Post({ post }) {\n  return <PostLayout post={post} />\n}\n```\n\n- `getStaticPaths`는 어떤 경로를 정적 페이지로 미리 만들어둘지 알려주는 역할을 해요.\n- `params` 객체 안에 있는 `id`는 동적 라우트 이름과 일치해야 합니다. 예를 들어 `[id].js` 라면 `id`가 되어야 하죠.\n- 그런 다음 `getStaticProps`에서 `params`를 받아와서 실제 데이터를 불러와 페이지에 props로 넘깁니다.\n\n---\n\n그런데 **Next.js 13부터는 app 디렉토리 구조를 쓸 때는 `getStaticPaths`가 아니라** `generateStaticParams`라는 함수로 바뀌었어요. \n\n`generateStaticParams` 함수가 하는 역할은 거의 비슷하지만, 요즘엔 app 디렉토리에서는 이걸 더 권장하고 있어요. 다음과 같이 쓸 수 있습니다.\n\n```js\nexport async function generateStaticParams() {\n  return [{ id: '1' }, { id: '2' }]\n}\n```\n\n그리고 컴포넌트 쪽에선 `props` 대신에 동적 세그먼트를 바로 받아올 수도 있죠.\n\n---\n\n### 참고로!\n\n- `getStaticPaths` 혹은 `generateStaticParams` 둘 다 빌드 시점에 호출돼서 어떤 경로를 미리 만들어야 할지 결정합니다. 그래서 데이터가 바뀔 가능성이 잦다면 빌드 후에도 데이터가 반영되는 `ISR(Incremental Static Regeneration)` 옵션을 함께 사용하는 게 좋아요.\n- `generateStaticParams`는 app 디렉토리의 새로운 “서버 컴포넌트” 개념과도 맞닿아 있어서, 페이지를 더 쉽게 설계할 수 있게 만들어줍니다. Next.js 13 이상부터는 무조건 `generateStaticParams`를 쓰는 게 트렌드라고 생각하면 편해요.\n\n---\n\n저도 처음에 pages → app 디렉토리 쪽으로 옮겼을 때 좀 헷갈렸는데, 이 부분만 잘 쓰면 Next.js 13의 동적 라우팅도 확실히 깔끔하게 관리할 수 있으니 꼭 써보시길 추천드립니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여러분, Next.js의 `generateStaticParams` 함수에 대해 들어보셨나요? 기존에 많이 쓰이던 `getStaticPaths`와 비슷한 역할을 하지만, API가 훨씬 단순해지고 레이아웃 안에서도 사용할 수 있게 진화했습니다. 여기선 어떤 점이 좋은지, 그리고 어떻게 사용하면 좋은지 쉽게 알려드릴게요!\n\n일단, `generateStaticParams`는 반환 형식이 조금 다른데요. 예전 `getStaticPaths`처럼 중첩된 파라미터 객체 배열이나 경로 문자열 배열 대신, 그냥 각 세그먼트가 담긴 객체 배열을 반환하면 됩니다. 예를 들어:\n\n```js\n// `app` 디렉토리 안에서\nimport PostLayout from '@/components/post-layout'\n\nexport async function generateStaticParams() {\n  return [{ id: '1' }, { id: '2' }]\n}\n\nasync function getPost(params) {\n  const res = await fetch(`https://.../posts/${params.id}`)\n  const post = await res.json()\n\n  return post\n}\n\nexport default async function Post({ params }) {\n  const post = await getPost(params)\n\n  return <PostLayout post={post} />\n}\n```\n\n위 예시는 포스트 ID별로 미리 페이지를 생성할 때 사용되죠. `params` 객체를 받아서 필요한 데이터를 가져오고, 그걸 레이아웃 컴포넌트에 넘겨주는 방식이에요.\n\n---\n\n### 네이밍도 훨씬 직관적으로!\n기존에 `getStaticPaths`라고 하면 \"뭔가 'get' 하는 느낌인데, 정적 경로 정보가 필요한 거지?\" 싶은 이름이었죠. 하지만 요즘은 `generateStaticParams`처럼 \"생성(generate)\"이라는 단어가 들어가서, 실제로 경로를 만드는 과정임을 더 명확히 나타냅니다.\n\n또한, `Paths` 대신 `Params`를 쓰는 것도 큰 변화입니다. 왜냐하면 요즘 Next.js의 라우팅은 중첩 라우팅이나 여러 동적 세그먼트를 사용할 때가 많아서, 경로(path)보다 세그먼트별 파라미터(params)를 잘 표현해 주는 이름이 더 적합하거든요.\n\n---\n\n### `fallback` 속성은 이제 어떻게?\n기존에 `getStaticPaths`에서는 `fallback`이라는 옵션으로 \"경로가 미리 생성되지 않은 경우 처리 방법\"을 지정했죠. 그런데 `generateStaticParams` 사용 시에는 이런 옵션이 더 이상 필요하지 않습니다. 왜냐하면 `app` 디렉토리 기반의 새로운 라우팅 모델이 페이지 생성 자체를 더 선언적이고 유연하게 다루기 때문이에요.\n\n---\n\n### 마치며\n- `generateStaticParams`는 더 간단하고 명확한 API를 제공해요.\n- 레이아웃 레벨에서도 쉽게 경로 파라미터를 생성할 수 있답니다.\n- 네이밍도 훨씬 직관적이고, `fallback` 설정 또한 사라져서 사용법이 깔끔해졌어요.\n\nNext.js의 최신 `app` 디렉토리에서 동적 라우팅과 정적 생성 기능을 쓸 때 꼭 기억하세요! 앞으로 더 많은 기능이 나오면 또 소개해 드릴게요. 궁금한 점 있으면 댓글로 남겨주세요~\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서 페이지를 정적으로 생성할 때, `getStaticPaths`와 `fallback` 옵션이 어떻게 작동하는지 한 번 살펴볼게요. 보통 `pages` 디렉토리에서 많이 쓰는데, 여기에선 특정 페이지를 빌드 타임에 미리 생성하지 않고 상황에 따라 다르게 처리하는 방식을 알려줍니다.\n\n---\n\n### pages 디렉토리에서 fallback 옵션\n\n`getStaticPaths` 함수는 어떤 경로들을 미리 만들어둘지 알려주는 역할을 하고, `fallback` 옵션이 빌드 시 미리 생성되지 않은 경로에 대해서 어떻게 동작할지 결정해요.\n\n- `fallback: true`  \n  빌드 때 없는 페이지라도, 요청 시점에 페이지를 생성하면서 \"로딩 중\" 같은 fallback UI를 보여줄 수 있어요.\n- `fallback: false`  \n  빌드에 없는 페이지는 무조건 404 페이지를 반환해요.\n- `fallback: 'blocking'`  \n  요청이 들어오면 서버에서 페이지 완성까지 기다렸다가 완성된 페이지를 보여줘요. 로딩 중 UI 없이 자연스럽게 보여주는 느낌!\n\n예시 코드:\n\n```js\n// `pages` 디렉토리 예시\n\nexport async function getStaticPaths() {\n  return {\n    paths: [], // 미리 생성할 경로를 정의\n    fallback: 'blocking' // 요청 시 페이지가 없으면 바로 생성 후 반환\n  };\n}\n\nexport async function getStaticProps({ params }) {\n  // params를 활용해 데이터 패칭\n  ...\n}\n\nexport default function Post({ post }) {\n  return (\n    // 데이터 기반 컴포넌트 렌더링\n    ...\n  );\n}\n```\n\n---\n\n### app 디렉토리에서는 어떻게 다를까?\n\nNext.js 새로운 앱 디렉토리 방식에서는 `generateStaticParams`라는 함수로 미리 생성할 경로들을 정의하고, `config.dynamicParams` 옵션이 새롭게 등장했어요. 이 옵션은 `generateStaticParams`에 포함되지 않은 동적 경로들을 어떻게 처리할지 결정합니다.\n\n| config.dynamicParams | 동작 방식                                     |\n|----------------------|---------------------------------------------|\n| true (기본값)         | 미리 없던 경로라도 요청 시 생성 (on demand)  |\n| false                | generateStaticParams에 없는 경로는 404 반환 |\n\n이렇게 바뀌면서 페이지의 유연성이 좀 더 좋아졌고, 앱 디렉토리에선 빌드 방식과 동작 흐름이 좀 더 명확해졌어요. 기존 `fallback`과 역할은 비슷하지만, 옵션 이름과 적용되는 방식이 달라졌으니 참고하세요!\n\n---\n\n### 정리하며\n\n- `pages` 디렉토리에서는 `getStaticPaths`의 `fallback` 옵션이 동적 경로에 대응.\n- `app` 디렉토리에서는 `generateStaticParams` + `config.dynamicParams`로 대응.\n- `fallback: 'blocking'` 같은 옵션은, 사용자에게 매끄럽게 완성된 페이지를 보여주고 싶을 때 유용.\n- 새롭게 앱 디렉토리를 사용한다면 `config.dynamicParams`의 기본값이 true임을 기억!\n\n이 내용 참고해서 Next.js에서 동적 경로를 더 잘 다뤄보세요. 혹시 페이지 생성 타이밍이나 방법에 대해 더 궁금한 부분 있으면 언제든 물어봐 주세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js의 새로운 App 디렉토리에서, 기존 `pages` 디렉토리에서 사용하던 `getStaticPaths`의 `fallback: true | false | 'blocking'` 옵션을 대체하는 방식이 도입되었어요. \n\n특히 `fallback: 'blocking'` 옵션은 이제 `dynamicParams`에서는 제외됐는데, 그 이유는 `'blocking'`과 `true`가 스트리밍 환경에서는 거의 차이가 없기 때문입니다.\n\n아래 예제를 볼까요?\n\n```js\n// app 디렉토리 내 예제\n\nexport const dynamicParams = true;\n\nexport async function generateStaticParams() {\n  return [ /* 미리 생성할 경로들 반환 */ ];\n}\n\nasync function getPost(params) {\n  // params를 기반으로 포스트 데이터 조회\n  ...\n}\n\nexport default async function Post({ params }) {\n  const post = await getPost(params);\n\n  return (\n    // 포스트 데이터를 바탕으로 렌더링\n    ...\n  );\n}\n```\n\n위 코드를 보면 `dynamicParams`가 `true(기본값)`으로 설정돼 있어요. 이 경우, 만약 미리 생성된 경로가 아니라면, 해당 경로 요청 시 서버에서 렌더링 후 결과를 캐시합니다. 쉽게 말해, 없는 페이지를 처음 요청하면 서버가 페이지를 바로 만들어서 보여주고, 이후에는 저장해둔 결과를 빠르게 보여주는 방식이죠.\n\n---\n\n### Incremental Static Regeneration (ISR) (예전 getStaticProps + revalidate 개념)\n\n이 부분은 예전 `pages` 디렉토리에서 `getStaticProps`를 쓸 때 `revalidate` 옵션을 주는 것과 비슷해요. ISR은 빌드 타임에 미리 페이지를 만들어 놓고, 일정 시간이 지나면 다시 서버에서 페이지를 재생성하는 방식이죠. 이렇게 하면 매우 최신 상태의 페이지를 사용자에게 제공하면서도 정적인 페이지의 이점을 유지할 수 있어요.\n\nApp 디렉토리에서도 이런 개념이 비슷하게 적용되고 있으니, `generateStaticParams`와 `dynamicParams`를 적절히 활용해보면 성능과 최신성, 유지보수성을 모두 잡을 수 있습니다.\n\n---\n\n### 정리하자면!\n\n| 옵션             | 설명                                                                     |\n|----------------|------------------------------------------------------------------------|\n| `dynamicParams = true`  | 없는 경로 요청 시 서버에서 바로 생성 후 캐싱. 기본값.                                  |\n| `generateStaticParams()` | 미리 생성할 경로 목록을 지정. 주로 빌드 타임에 호출됨.                                    |\n| `fallback: 'blocking'` (pages) | 앱 디렉토리에선 적용 안 함. 스트리밍 환경에서는 `true`와 비슷한 역할을 하므로 제거됨.      |\n\nNext.js가 이런 식으로 SSR, SSG, ISR 방식을 더 자연스럽고 유연하게 지원하고 있어서, 개발자가 상황에 맞게 잘 선택해서 쓰기 좋아졌답니다.  \n\n필요하면 더 자세한 예제나 활용법도 알려줄게요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서 페이지를 자동으로 재생성하는 방법, `pages` 디렉토리와 `app` 디렉토리 각각에서 어떻게 다르게 동작하는지 알아볼게요.\n\n---\n\n### `pages` 디렉토리에서 `getStaticProps`의 `revalidate`\n\n`pages` 디렉토리에서는 `getStaticProps` 함수 안에 `revalidate` 필드를 넣으면 됩니다. 이 값은 몇 초마다 페이지를 다시 생성할지 정하는 거예요. 예를 들어 `revalidate: 60`이면, 처음 빌드 후 60초가 지나면 페이지가 다시 백그라운드에서 생성됩니다.\n\n```js\nexport async function getStaticProps() {\n  const res = await fetch(`https://.../posts`)\n  const posts = await res.json()\n \n  return {\n    props: { posts },\n    revalidate: 60, // 여기서 60초마다 재생성을 설정\n  }\n}\n \nexport default function Index({ posts }) {\n  return (\n    <Layout>\n      <PostList posts={posts} />\n    </Layout>\n  )\n}\n```\n\n- 이 방식은 페이지 단위로 작동해요.\n- 페이지 전체가 정적으로 빌드되고, 60초마다 업데이트된 내용을 반영해 새로 빌드됩니다.\n- 사용자가 방문할 때마다 항상 최신 데이터가 나오진 않지만, 정해진 시간 간격으로 최신 상태를 유지할 수 있어요.\n\n---\n\n### `app` 디렉토리에서 `fetch`의 `revalidate` 옵션\n\n`app` 디렉토리(Next.js 13의 새로운 앱 라우터 사용 시)에서는 데이터 패칭을 할 때 `fetch` 함수에 `{ next: { revalidate: 60 } }` 옵션을 붙여주면, 이 요청 결과를 60초 동안 캐싱합니다.\n\n```js\nasync function getPosts() {\n  const res = await fetch(`https://.../posts`, { next: { revalidate: 60 } })\n  const data = await res.json()\n \n  return data.posts\n}\n \nexport default async function PostList() {\n  const posts = await getPosts()\n \n  return posts.map((post) => <div>{post.name}</div>)\n}\n```\n\n- 여기서는 데이터 페칭 단위에서 재검증 시간을 설정하는 차이점이 있어요.\n- `fetch` 캐시는 60초 동안 유지되고, 그 사이 다시 요청하면 캐시된 데이터를 바로 씁니다.\n- 60초가 지나면 최신 데이터를 받아오고 캐시를 새로 만듭니다.\n- 이걸 합치면 부분 부분 데이터를 정적으로 캐싱하면서도 페이지 전체는 서버 컴포넌트로 동작하게 할 수 있어요.\n\n---\n\n### 요약하자면\n\n| 특징             | `pages` 디렉토리 (`getStaticProps`) | `app` 디렉토리 (`fetch`의 revalidate)  |\n|----------------|-----------------------------|------------------------------|\n| 동작 단위         | 페이지 단위                      | 데이터 요청 단위                   |\n| 재생성 주기 설정 방식 | `revalidate` 필드로 설정             | `fetch` 메서드 옵션으로 설정         |\n| 정적 생성 방식     | ISR(Incremental Static Regeneration) | 서버 컴포넌트 + 캐시 재검증             |\n| 업데이트 시점      | 방문 시점 기준 60초마다 백그라운드 생성    | 60초 간 캐시 사용 후 다음 요청 시 재검증   |\n\n---\n\n### 팁!\n\n- 만약 `app` 디렉토리에서 `fetch`에 `next: { revalidate: 0 }`를 넣으면 항상 최신 데이터를 가져오게 돼요.\n- 반대로 `next: { revalidate: false }`는 캐시를 아예 하지 않는 뜻이니, 기본 행동과 다르니 주의하세요.\n- `pages`에서 ISR 쓰던 것보다 `app` 디렉토리의 캐시 제어가 훨씬 세밀하고 유연해서 최신 데이터 처리에 더 좋은 편입니다.\n\n---\n\nNext.js 13 이후로는 `app` 디렉토리를 적극 활용하는 걸 추천해요. 서버 컴포넌트이면서도 유연한 캐싱 전략을 쓸 수 있기 때문에 앱 성능, 사용자 경험 면에서 더 나은 결과를 기대할 수 있답니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n#### API 라우트 (API Routes)\n\nNext.js에서 API 라우트는 여전히 `pages/api` 디렉토리에서 그대로 동작해요. 기존 방식과 달라진 점 없이 예전처럼 사용 가능합니다. 그런데 요즘에는 `app` 디렉토리 안에서 **Route Handlers**라는 더 발전된 방식을 많이 씁니다.\n\nRoute Handlers는 Web 표준의 Request와 Response API를 활용해서, 특정 경로에 대한 요청을 더 세밀하게 제어할 수 있게 해줘요. 예를 들어, `GET` 요청을 처리하는 함수를 이렇게 작성할 수 있죠:\n\n```js\nexport async function GET(request: Request) {\n  // 여기에 요청 처리 로직 작성\n}\n```\n\n즉, 함수 하나로 HTTP 메서드별 요청 핸들러를 만들 수 있다는 이야기인데요. 덕분에 서버 코드를 더 깔끔하고 명확하게 관리할 수 있어요.\n\n참고로, Route Handlers를 활용하면 응답 헤더 설정이나 쿠키 다루기 같은 것도 표준 API를 통해 자연스럽게 할 수 있으니, Next.js로 풀스택 개발할 때 아주 편리합니다.\n\n---\n\n### 간단 정리\n\n| 구분           | 설명                                             |\n|----------------|--------------------------------------------------|\n| API Routes     | `pages/api`에서 전통적으로 사용, 변경 없이 동작  |\n| Route Handlers | `app` 디렉토리에서 새롭게 지원, Web Request/Response API 사용 |\n\n작업하는 프로젝트가 최신 버전이고 `app` 디렉토리를 쓴다면 Route Handlers를 적극 활용해보세요! 기존 `pages/api`도 당분간 지원하니 상황에 맞게 선택하시면 됩니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n> 참고할 점: 이전에 클라이언트에서 외부 API를 호출하기 위해 API 라우트를 사용했다면, 이제는 서버 컴포넌트를 활용해 더 안전하게 데이터를 가져올 수 있어요. 데이터 fetching에 대해 더 자세히 알고 싶다면 공식 문서를 참고해보세요.\n\n#### 싱글 페이지 애플리케이션 (SPA)\n\n만약 동시에 SPA에서 Next.js로 마이그레이션하고 있다면, 관련된 문서를 꼭 확인해 보세요. 마이그레이션 과정에서 좋은 팁과 가이드가 포함되어 있으니 도움이 될 거예요.\n\n### 7단계: 스타일링\n\nNext.js로 옮겨오면서 스타일링도 신경 써줘야 해요. CSS, Sass, 또는 CSS-in-JS 등 다양한 스타일링 방법을 사용할 수 있는데, Next.js가 공식적으로 지원하는 방법들을 활용하면 깔끔하고 유지보수 쉬운 스타일링을 할 수 있답니다. 스타일링 관련해서는 따로 정리한 내용도 있으니 필요하면 알려드릴게요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n페이지 디렉토리에서는 글로벌 스타일시트가 오직 pages/_app.js에서만 적용되도록 제한되어 있었어요. 그런데 이제 app 디렉토리에서는 이 제한이 풀려서, 글로벌 스타일을 레이아웃(layout), 페이지, 컴포넌트 어디서든 자유롭게 추가할 수 있게 되었답니다.\n\n여기서 스타일을 다룰 수 있는 방법들을 간단히 정리하면 다음과 같아요:\n\n| 스타일 종류          | 설명                                    |\n|-------------------|---------------------------------------|\n| CSS Modules       | 각 컴포넌트에 scoped된 CSS를 적용하는 방법               |\n| Tailwind CSS      | 유틸리티 클래스 기반의 빠른 스타일링 프레임워크               |\n| Global Styles     | 전체 애플리케이션에 적용하는 전역 스타일                   |\n| CSS-in-JS         | 자바스크립트 파일 내에서 직접 스타일을 작성하는 방식         |\n| External Stylesheets | 외부 CSS 파일을 불러와 사용하는 방법                       |\n| Sass              | CSS 전처리기 중 하나로, 변수나 중첩 같은 기능을 지원           |\n\n---\n\n### Tailwind CSS\n\n만약 Tailwind CSS를 사용 중이라면, app 디렉토리를 tailwind.config.js에 추가해줘야 해요. 이렇게 하면 Next.js의 새 구조와 Tailwind가 잘 연동되어 스타일이 제대로 적용됩니다.\n\n예를 들어, tailwind.config.js 파일에서 아래처럼 설정해봅시다:\n\n```js\nmodule.exports = {\n  content: [\n    \"./app/**/*.{js,ts,jsx,tsx}\", // app 디렉토리에 있는 모든 파일을 대상으로 설정\n    \"./pages/**/*.{js,ts,jsx,tsx}\",\n    \"./components/**/*.{js,ts,jsx,tsx}\",\n  ],\n  theme: {\n    extend: {},\n  },\n  plugins: [],\n}\n```\n\n이렇게 해두면 app 디렉토리 내에 있는 모든 컴포넌트, 페이지, 레이아웃 파일에서 Tailwind 클래스를 제대로 인식하고 스타일이 적용될 거예요.\n\n---\n\n추가로, app 디렉토리 구조에 익숙하지 않은 분들을 위해 한 가지 팁을 알려드리면, app 디렉토리 안에서는 기본적으로 서버 컴포넌트가 활성화되어 있어요. 서버 컴포넌트에서는 CSS나 스타일을 다루는 방식에 약간 제한이 있을 수 있으니, 스타일이 꼭 필요한 클라이언트 컴포넌트는 `'use client'` 지시어를 붙여서 명확하게 구분해주는 게 좋습니다.\n\n궁금한 점 있으면 언제든 질문해 주세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이번 시간에는 Next.js 앱에서 Tailwind CSS를 설정하는 간단한 방법을 공유할게요! Tailwind CSS는 요즘 프론트엔드에서 가장 인기 있는 유틸리티 퍼스트 CSS 프레임워크 중 하나인데, 클래스만 붙여서 빠르게 스타일을 만들 수 있어서 개발 속도가 확실히 빨라집니다.\n\n먼저, Tailwind가 어디서 스타일을 찾아야 하는지 알려주는 설정파일(tailwind.config.js)을 수정해야 해요. 여러분이 만든 컴포넌트나 페이지에 있는 모든 파일을 지정해야 Tailwind가 정확히 필요한 스타일만 뽑아낼 수 있거든요.\n\n```js\nmodule.exports = {\n  content: [\n    './app/**/*.{js,ts,jsx,tsx,mdx}', // 여기에 Next.js app 폴더의 모든 JS/TS/MDX 파일 포함\n    './pages/**/*.{js,ts,jsx,tsx,mdx}', // pages 폴더도 포함\n    './components/**/*.{js,ts,jsx,tsx,mdx}', // 컴포넌트 폴더도 잊지 말고 넣기\n  ],\n}\n```\n\n이렇게 지정해주면, Tailwind가 여러분 프로젝트 안의 모든 화면과 컴포넌트에서 사용된 클래스를 잘 찾아낼 수 있어요.\n\n다음은 글로벌 CSS를 프로젝트에 불러와야 해요. Next.js 13버전부터 app 디렉토리를 사용하는 경우는 app/layout.js에 아래처럼 임포트해주면 된답니다.\n\n```js\nimport '../styles/globals.css'\n\nexport default function RootLayout({ children }) {\n  return (\n    <html lang=\"en\">\n      <body>{children}</body>\n    </html>\n  )\n}\n```\n\ntailwind가 들어간 globals.css 안에 기본 Tailwind 지시어(@tailwind base, @tailwind components, @tailwind utilities)가 들어있다고 가정한 거에요. 그래야 Tailwind 스타일이 전역에서 적용되어요.\n\n---\n\n### 여기서 잠깐!\n\n- `content` 배열에 프로젝트 내 Tailwind 클래스를 사용하는 모든 파일 경로를 넣어야 최적화된 CSS가 만들어져요. 안 넣으면, 실제 쓸 CSS가 빠지거나(디자인 깨짐), 쓰지 않는 CSS가 포함되어 파일 용량이 커져요.\n- Next.js 13버전부터는 `app/layout.js`가 없어도 `app/page.js` 같은 파일에 `import '../styles/globals.css'`를 하는 방식을 간혹 쓰기도 하는데, 공식 문서는 layout에서 임포트하는 걸 권장해요.\n- 만약 `mdx` 파일을 사용 중이라면 `.mdx` 확장자도 꼭 포함시켜야 Tailwind가 MDX 컨텐츠 내 스타일도 인식해요.\n\nTailwind CSS와 Next.js 조합으로 스타일 작업 할 때는, 꼭 위 내용을 체크해보시고 세팅하시면 더 편하고, 빠른 개발이 가능하답니다. 궁금한 점 있으면 언제든 댓글이나 DM 주세요!\n\n더 자세한 Tailwind CSS 활용법은 [공식 Tailwind 문서](https://tailwindcss.com/docs/guides/nextjs)에서 확인할 수 있어요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## App Router와 Pages Router 함께 사용하기\n\nNext.js에서는 App Router와 Pages Router라는 두 가지 라우팅 방식을 지원하는데요. 이 둘을 동시에 사용할 때는 조금 주의해야 할 점이 있습니다.\n\n서로 다른 라우터가 관리하는 경로 간 이동할 때, 기본적으로 하드 네비게이션(페이지 전체를 다시 로드하는 방식)이 발생해요. 그래서 next/link 컴포넌트가 제공하는 자동 링크 프리패칭 기능도 서로 다른 라우터 간에는 동작하지 않습니다.\n\n그렇다고 해서 두 라우터를 함께 쓸 수 없는 건 아니에요! 적절히 최적화하면 App Router와 Pages Router 사이에서도 빠르고 부드러운 페이지 전환을 경험할 수 있습니다. 조금 더 깊게 들어가면 각각의 라우팅 방식을 이해하고, 프리패칭 동작을 직접 구현하거나, 상태를 공유해서 사용자 경험을 개선할 수 있어요.\n\n### 추가 팁으로\n- 앱 규모가 크고, 점진적으로 App Router로 마이그레이션할 때 이 부분을 신경 쓰면 좋아요.\n- 필요하다면, 두 라우터 간 공유 가능한 글로벌 상태 관리 라이브러리(Recoil, Zustand, Redux 등)를 활용해 UI 일관성을 유지할 수 있어요.\n- 공식 문서나 커뮤니티에서 제공하는 팁들을 참고하면서 점진적으로 적용해 보세요.\n\n필요하면 어디서든 추가로 질문해 주세요. 함께 고민해봅시다!\n\n---\n\n## Codemods\n\nNext.js에서 라우팅 구조를 변경하거나 코드 스타일을 바꿀 때 도움을 주는 자동 수정 도구인 Codemods도 알아두시면 좋아요.\n\n설명과 함께 다음 포스트에서 자세히 다뤄볼게요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서는 기능이 더 이상 사용되지 않을 때 코드를 쉽게 업그레이드할 수 있도록 도와주는 Codemod 변환 도구를 제공합니다. Codemod는 자동으로 코드를 변경해 주기 때문에, 직접 하나하나 고치느라 시간을 낭비할 필요가 없어서 정말 편리하답니다.\n\n더 자세한 내용과 사용법은 [Codemods 공식 문서](https://nextjs.org/docs/codemods)를 참고해 보세요. 작업 전에는 꼭 코드 백업이나 버전 관리(Git)를 활용해서 안전하게 변경하는 걸 추천할게요! 혹시 Codemod를 처음 사용한다면, 간단한 테스트 파일부터 적용해보는 것도 좋은 방법입니다.\n\n이런 도구들을 활용하면, Deprecated된 기능 때문에 스트레스 받지 않고 손쉽게 최신 버전으로 코드를 유지할 수 있으니 꼭 한 번 써보시길 바랍니다!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":59},{"title":"Next.js 최신버전으로 업그레이드 하는 방법","description":"","date":"2025-04-22 01:20","slug":"2025-04-22-HowtoupgradeyourNextjsapp","content":"\n\n# Next.js 앱 업그레이드 쉽게 하는 방법\n\n## 최신 버전으로 업데이트하기\n\nNext.js 앱을 최신 버전으로 업그레이드하고 싶다면, 공식에서 제공하는 업그레이드 코드를 이용하면 정말 간단해요! 터미널에서 아래 명령어만 쓱 실행하면 끝납니다:\n\n```bash\nnpx @next/codemod@canary upgrade latest\n```\n\n이 명령어는 현재 프로젝트에 설치된 Next.js 버전을 자동으로 최신 버전으로 바꿔주고, 코드에 필요한 변경점들도 함께 처리해줘서 편리하답니다.\n\n---\n\n### 팁 하나 더!\n\n- 위 명령어는 `npx`를 이용해서 바로 실행하는 거라, 별도의 패키지 설치 없이도 사용 가능합니다.\n- 혹시 직접 `package.json`에서 버전을 수정하고 싶다면, `\"next\"` 버전을 최신 버전으로 바꾸고 `npm install` 또는 `yarn`을 실행해도 돼요.\n- 새로운 버전에서 변경된 주요 기능이나 deprecated된 부분이 있을 수 있으니, [Next.js 공식 릴리즈 노트](https://nextjs.org/blog)도 한 번 살펴보세요. 예상치 못한 버그 방지에 큰 도움이 된답니다!\n\nNext.js 덕분에 React 기반 SSR(서버사이드 렌더링)이 훨씬 쉬워졌는데, 꾸준히 업데이트하면서 최신 기능도 맛보고 앱도 더 빠르게 만들어봐요~!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 수동으로 업그레이드하는 걸 선호한다면, 최신 버전의 Next.js와 React를 이렇게 설치할 수 있어요:\n\n```bash\nnpm i next@latest react@latest react-dom@latest eslint-config-next@latest\n```\n\n---\n\n## 캐나리(Canary) 버전\n\n최신 캐나리 버전으로 업데이트하고 싶다면, 먼저 Next.js가 최신 버전인지 확인하고 현재 프로젝트가 정상적으로 작동하는지 테스트하는 게 중요해요. 안정적인 상태를 확인한 다음, 아래 명령어를 실행하면 됩니다:\n\n```bash\nnpm i next@canary react@canary react-dom@canary eslint-config-next@canary\n```\n\n캐나리 버전은 아직 테스트 중인 기능들이 포함되어 있어서, 최신 기능을 미리 써보고 싶거나 버그를 발견해서 직접 피드백하고 싶을 때 유용해요. 그러나 안정성은 정식 버전보다 떨어질 수 있으니, 중요 프로젝트라면 충분히 테스트한 뒤에 도입하는 걸 추천드려요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n```bash\nnpm i next@canary\n```\n\n### 캔버리 버전에서 사용할 수 있는 기능들\n\n현재 캔버리 버전에서 제공되는 주요 기능들을 살펴볼게요!\n\n- **캐싱(Caching)** :  \n  성능 향상을 위해 콘텐츠를 효율적으로 저장하고 재사용하는 기능이에요. 이 기능 덕분에 페이지 로딩 속도가 빨라지고 서버 부담도 줄일 수 있답니다.\n\n캔버리 버전은 보통 최신 기능을 먼저 접해보고 싶을 때 추천드려요. 안정성은 정식 버전보다 조금 떨어질 수 있으니 중요한 프로젝트엔 주의가 필요해요 :)\n\n만약 캐싱 기능 외에도 어떤 기능들이 있는지 더 궁금하다면, 다음에 또 자세히 다뤄보도록 할게요!\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이번에는 개발하면서 자주 만날 수 있는 몇 가지 키워드와 용어들을 정리해볼게요. 각각 어떤 의미인지, 그리고 어떻게 활용할 수 있는지 함께 살펴보자고요!\n\n| 키워드         | 설명                                                                                 |\n|----------------|--------------------------------------------------------------------------------------|\n| use cache      | 캐시를 사용하는 옵션이나 설정. 서버나 클라이언트에서 자주 요청되는 데이터를 임시로 저장해서 빠르게 응답할 수 있게 도와줘요. |\n| cacheLife      | 캐시가 유지되는 시간. 즉, 캐시 데이터를 얼마 동안 유효하게 쓸지 결정하는 값이에요. 예를 들어, 10분 동안 캐시 유지라면 10분 뒤엔 새로운 데이터를 가져오죠. |\n| cacheTag       | 캐시를 식별하거나 그룹핑하기 위한 태그. 이를 통해 특정 태그가 붙은 캐시만 선택적으로 삭제하거나 갱신할 수 있어요. |\n| dynamicIO      | 동적으로 입출력을 처리하는 기능. 예를 들어, 사용자 입력이나 요청에 따라 실행되는 코드가 동적으로 바뀔 때 쓰여요. 서버와의 실시간 데이터 교환 같은 곳에서 중요해요. |\n\n이제 인증(Authentication) 관련된 용어들도 살펴볼까요? 인증 로직을 짤 때 자주 접하게 되니까 알아두면 좋아요.\n\n| 키워드           | 설명                                                                                  |\n|------------------|---------------------------------------------------------------------------------------|\n| forbidden        | 접근 권한이 없는 자원에 대해 서버가 요청을 거부할 때 사용하는 상태. 보통 HTTP 403 에 해당해요. |\n| unauthorized     | 인증이 필요한 자원에 대해 인증이 안 된 상태에서 접근하려고 할 때 사용하는 상태. HTTP 401과 연결돼요. |\n| forbidden.js     | 접근 금지(403) 관련 로직을 처리하는 자바스크립트 파일일 가능성이 높아요. 예외 처리를 담당하거나 사용자에게 알림을 줄 때 사용하겠죠? |\n| unauthorized.js  | 인증되지 않은 상태(401)를 처리하는 자바스크립트 파일. 로그인 페이지로 리다이렉트하거나 경고 메시지를 띄우는 용도로 쓰일 수 있어요. |\n| authInterrupts   | 인증과 관련된 작업 도중에 흐름을 중단시키거나 인터셉트(가로채기) 하는 기능. 예를 들어, 인증 실패 시 다른 동작을 막고 로그인 화면으로 보내는 등 제어할 때 유용하답니다. |\n\n---\n\n### 덧붙여서\n\n캐시 관련 개념들은 개발 성능 최적화에서 정말 중요해요. 예를 들어, 대규모 서비스에서는 무한정 캐시 데이터를 유지하면 메모리가 부족해질 수 있으니까 `cacheLife` 값을 적절히 조정하는 게 중요하죠. 또한, 만약 여러 캐시 데이터를 그룹화해야 한다면 `cacheTag`를 활용해서 필요한 부분만 빠르게 업데이트할 수 있답니다.\n\n그리고 인증 처리 로직은 보안에 직결되니, 상태 코드(403, 401)를 클라이언트에 명확하게 알려주는 게 중요해요. 그리고 인증 실패나 권한 부족 상황에서 사용자에게 적절한 피드백을 주는 것도 잊지 마시고요.\n\n혹시 실제 코드 구현과 관련해서 추가로 궁금한 점 있으면 언제든 말해 주세요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":5}],"page":"14","totalPageCount":50,"totalPageGroupCount":3,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}