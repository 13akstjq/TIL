{"pageProps":{"post":{"title":"PyTorch 입문  커스텀 데이터 사용 방법","description":"","date":"2024-07-12 20:17","slug":"2024-07-12-PyTorchIntroductionUsingCustomData","content":"\n\n<img src=\"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_0.png\" />\n\n파이토치는 현재 딥 러닝 분야에서 가장 핫한 라이브러리 중 하나입니다. ChatGPT가 출시된 이후 데이터 과학가와 머신 러닝 엔지니어들 사이에서 딥 러닝 라이브러리가 아마도 가장 많은 관심을 받고 있다고 볼 수 있습니다. 특히 이러한 라이브러리는 매우 빠르게 복잡한 다차원 계산을 수행하는 능력이 뛰어나며, 이러한 라이브러리는 우리가 신경망 모델을 훈련하는 방식을 바꾸었습니다. 특히 이러한 모델이 저장하고 최적화하는 많은 수의 가중치를 관리하는 데 매우 도움이 됩니다. TensorFlow(구글의 프레임워크)와 경쟁하며, PyTorch는 Meta의 오픈 소스 프레임워크로, 아주 멋지고 실용적인 문법을 사용하여 딥 러닝 모델을 훈련할 수 있는 기회를 제공합니다.\n\n지금까지 이 PyTorch 시리즈에서 이 라이브러리를 사용하는 기본 개념을 배워왔습니다. 예를 들어:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 텐서에 대한 기본 사항을 배우기\n- PyTorch를 사용하여 처음 선형 모델(회귀)을 만드는 방법 이해하기\n- 비선형 활성화 함수 및 비선형 문제 해결하는 방법 배우기\n\n저희는 예제와 이전 블로그 게시물에서 몇 가지 사용자 정의 데이터셋을 사용했습니다. 이 시리즈에서 딥 러닝 모델을 교육하는 방향으로 진행하면서, PyTorch의 맥락에서 다양한 데이터셋을 통합하는 방법을 이해하는 데 매우 도움이 됩니다. 이 블로그 게시물에서는 라이브러리에서 사용자 정의 데이터셋을 다루는 방법을 배우고, 특히 세 가지 다른 유형의 데이터를 통합하는 방법을 다룰 것입니다:\n\n- CSV 파일\n- 이미지 데이터\n- 텍스트 데이터\n\n또한 데이터 배치의 개념에 대해 살펴보고, 이를 위해 PyTorch 사용자 정의 DataLoader를 사용하는 방법도 알아볼 것입니다. 이 블로그 게시물의 일부 영감은 Zero to Mastery Pytorch 무료 강좌에서 온 것입니다 — 많은 흥미로운 학습 예제가 있는 이 멋진 자료를 확인해보세요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n시작해 봅시다!\n\n# 랜덤 데이터셋 생성\n\n먼저, Pytorch에서 랜덤 데이터셋을 생성하여 DataLoader를 어떻게 사용할 수 있는지 이해해 봅시다:\n\n```python\nimport torch\nfrom torch.utils.data import Dataset, DataLoader\n\nclass RandomIntDataset(Dataset):\n    def __init__(self, start, stop, x, y):\n        self.data = torch.randint(start, stop, (x,y))\n        self.labels = torch.randint(0, 10, (x,))\n\n    def __len__(self):\n        return len(self.labels)\n\n    def __str__(self):\n        return str(torch.cat((self.data, self.labels.unsqueeze(1)), 1))\n\n    def __getitem__(self, i):\n        return self.data[i], self.labels[i]\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저희 RandomIntDataset은 랜덤한 torch 객체와 레이블을 생성합니다. 클래스에 던더 메서드를 도입하고 torch.utils.data.Dataset을 상속했음을 주목해주세요. (특히 데이터셋을 DataLoader와 결합할 때 유용하게 사용될 것입니다).\n\n이전 클래스를 기반으로 첫 번째 데이터셋 객체를 생성해봅시다!\n\n```js\ndataset = RandomIntDataset(100, 1000, 500, 10)\n```\n\n다시 말씀드리지만, Pytorch의 기본 클래스를 상속받았기 때문에 DataLoader를 사용하여 좋은 이터러블을 생성할 수 있습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\r\ndataset_loader = DataLoader(dataset, batch_size=10, shuffle=True)\r\n```\r\n\r\n신경망 내에서 데이터를 배치로 전달하는 것은 매우 흔한 일이며 DataLoader 생성자가 깔끔한 batch_size 인자를 통해 이를 처리합니다! dataset_loader는 반복 가능하므로 순차적인 데이터 배치를 얻기 위해 next 및 iter를 사용할 수 있습니다.\r\n\r\n```js\r\ndata, labels = next(iter(dataset_loader))\r\ndata\r\n```\r\n\r\n<img src=\"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_1.png\" />\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n새로운 iteration을 실행하고 data_loader의 다음 배치가 어떻게 이동하는지 확인해보세요! 이를 통해 데이터 및 레이블 객체 내부의 다른 데이터가 표시됩니다.\n\n물론, 이 무작위 데이터 세트는 실제로 \"사용자 지정 데이터 세트\"로 간주하기 어렵습니다. 무작위 생성된 데이터와 작업하려고 할 가능성은 매우 낮습니다. 그러나 배치 처리에 익숙해지는 데 도움이 되는 이 소개 후에 첫 번째 CSV 파일을 PyTorch 파이프라인에 포함하여 계속 진행할 준비가 되었습니다!\n\n# DataLoader와 사용자 지정 데이터 세트 결합\n\n우리가 보았듯이, 무작위 데이터 세트 사용은 단순한 연습일 뿐입니다. 그러나 이제 DataLoader와 데이터 배치가 어떻게 작동하는지 알기 때문에 이 지식을 사용하여 새로운 클래스를 만들어 PyTorch 데이터 세트를 사용할 수 있습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nimport pandas as pd\n\nclass TaxiSample(Dataset):\n    def __init__(self):\n        super().__init__()\n        df = pd.read_csv('data/taxi_data_sample.csv')\n        \n        features = ['passenger_count',\n                    'pickup_longitude',\n                    'pickup_latitude',\n                    'dropoff_longitude',\n                    'dropoff_latitude']\n        \n        target = 'trip_duration'\n        \n        self.features = torch.tensor(df[features].values, \n                                     dtype=torch.float32)\n\n        self.labels = torch.tensor(df[target].values, \n                                   dtype=torch.float32)\n\n    def __len__(self):\n        return len(self.labels)\n\n    def __getitem__(self, idx):\n        return self.features[idx], self.labels[idx]\n```\n\n참고: 라이브러리를 게시물에서 지날 때까지 가져오고 있지만 모든 라이브러리는 스크립트의 처음에 가져와야 합니다!\n\n우리가 사용하는 데이터셋은 Kaggle의 택시 여행 소요 시간 경쟁의 샘플 버전입니다. 여기서 csv를 init에 전달하고 있습니다 (이 기능을 더 다룰 수 있도록 인수로도 전달할 수 있습니다). DataLoader와 잘 어울리는지 확인해봅시다:\n\n```python\ndata_taxi = TaxiSample()\ndataset_loader = DataLoader(data_taxi, batch_size=20, shuffle=True)\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리의 배치 크기가 20인 경우, 이 데이터셋에서 이터레이터를 만들 수 있습니다:\n\n```js\ndata_iterator = iter(dataset_loader)\ndata, labels = next(data_iterator)\n```\n\n<img src=\"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_2.png\" />\n\n멋져요! 이것들은 데이터셋에서 무작위로 선택한 처음 20개의 예시입니다. 위 이미지에서는 피처와 해당 레이블을 확인할 수 있어요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n있는 이미지 데이터를 사용 해보세요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 블로그 게시물의 이 섹션에서는 이미지 데이터 처리 능력을 보여주기 위해 Microsoft Research Cats. vs Dogs. 데이터셋과 함께 Pytorch를 사용할 것입니다. 먼저 pathlib를 사용하여 경로를 정의해 보겠습니다:\n\n```python\nfrom pathlib import Path\ndata_path = Path(“data/dogs_cats”)\n```\n\n폴더 안에는 강아지 이미지와 고양이 이미지가 있는 두 개의 폴더가 있습니다. 각 폴더에서 이미지 경로를 추출해 봅시다:\n\n![이미지](/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_3.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 섹션에서는 일반적인 컴퓨터 비전 변환 및 아키텍처를 제공하는 pytorch의 멋진 확장인 torchvision이 필요합니다.\n\n```js\nfrom torchvision import datasets, transforms\n```\n\n다음으로 jpg 파일 이름을 읽어보겠습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimage_dogs_list = list((data_path/'dogs').glob(\"*.jpg\"))\nimage_cats_list = list((data_path/'cats').glob(\"*.jpg\"))\n```\n\n.. and combining our lists into a single object:\n\n```js\nimage_paths = image_cats_list + image_dogs_list\n```\n\nLet’s see if everything is working fine by extracting a random image from our list:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nimport random\nfrom PIL import Image\n\nrandom.seed(20)\n\nrandom_image_path = random.choice(image_paths)\nimage_class = random_image_path.parent.stem\n\nimg = Image.open(random_image_path)\n\nprint(f\"Random image path: {random_image_path}\")\nprint(f\"Image class: {image_class}\")\nprint(f\"Image height: {img.height}\") \nprint(f\"Image width: {img.width}\")\nimg\n```\n\n![Cute little doggo!](/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_5.png)\n\n귀여운 강아지!\n\n이미지를 텐서로 변환할 때 일반적인 단계 중 하나는 이미지를 일반적인 포맷으로 조정하는 것입니다. transforms 라이브러리를 사용하여 이미지 크기를 조정하고 첫 번째 비전 파이프라인을 설정할 수 있습니다!\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\ndata_transform = transforms.Compose([\n # 이미지 크기를 조정합니다\n transforms.Resize(size=(64, 64)),\n # 이미지를 수평으로 무작위로 뒤집습니다 — 이는 데이터 증가를 위한 단계입니다\n transforms.RandomHorizontalFlip(p=0.5),\n transforms.ToTensor()])\n```\n\n위 transforms 파이프라인에서 우리는 다음을 수행합니다:\n\n- 이미지를 64x64 픽셀 크기로 크기 조정합니다.\n- 무작위로 수평으로 이미지를 뒤집습니다 — 이는 데이터 증가를 위한 일반적인 단계입니다.\n- 이미지를 텐서로 변환합니다.\n\n한 이미지와 해당 변환된 버전을 나란히 그래플로 표시합니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport matplotlib.pyplot as plt\n\ndef plot_transformed_images(image_paths: list, \n                            transform: transforms.Compose, \n                            n=3, \n                            seed=100):\n    random.seed(seed)\n    random_image_paths = random.sample(image_paths, k=n)\n    for image_path in random_image_paths:\n        with Image.open(image_path) as f:\n            fig, ax = plt.subplots(1, 2)\n            ax[0].imshow(f) \n            ax[0].set_title(f\"Original Image \\nSize: {f.size}\")\n            ax[0].axis(\"off\") \n            transformed_image = transform(f).permute(1, 2, 0) \n            ax[1].imshow(transformed_image) \n            ax[1].set_title(f\"Transformed Image \\nSize: {transformed_image.shape}\")\n            ax[1].axis(\"off\")\n            fig.suptitle(f\"Class: {image_path.parent.stem}\", fontsize=16)\n```\n\n```js\nplot_transformed_images(image_paths, \n transform=data_transform, \n n=1)\n```\n\n<img src=\"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_6.png\" />\n\n저런! 변환을 통해 기본 텐서에 액세스하는 방법을 살펴보겠습니다. 예를 들어, 첫 번째 이미지의 경우:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimage_path = image_paths[0]\ndata_transform(Image.open(image_path))\n```\n\n![image](/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_7.png)\n\n데이터 변환은 RGB 채널이 3개이고 64x64 텐서를 생성했습니다!\n\n우리가 넘어가기 전에 더해야 할 마지막 단계 하나가 있습니다. 빠르게 텐서와 레이블을 생성하는 대안이 있습니다. 우리는 ImageFolder를 사용하여 편리하게 훈련 데이터를 생성할 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ntrain_data = datasets.ImageFolder(root=data_path, transform=data_transform, target_transform=None)\n```\n\n`datasets.ImageFolder`을 사용해요\n\n```js\nclass_names = train_data.classes\nclass_names\n```\n\n<img src=\"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_8.png\" />\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nclass_names에는 현재 태그(폴더 이름에서 읽음)가 컴퓨터 비전 모델에 포함되어 있습니다. train_data에는 컴퓨터 비전 프로세스에 대한 중요한 메타데이터가 포함되어 있습니다:\n\n![이미지](/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_9.png)\n\n그리고 이제 데이터 세트 ImageFolders를 DataLoaders로 변환하는 것은 매우 간단합니다:\n\n```js\ntrain_dataloader = DataLoader(dataset=train_data, \n batch_size=5,\n num_workers=1, \n shuffle=True)\n\ntrain_dataloader\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n보면 이터러블이 있네요:\n\n```python\nimg, label = next(iter(train_dataloader))\nprint(f\"이미지 형태: {img.shape} -> [배치 크기, 색상 채널, 높이, 너비]\")\nprint(f\"레이블 형태: {label.shape}\")\n```\n\n![image](/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_10.png)\n\n멋져요! 이 배치 크기가 5인 경우, 3채널(RGB)의 64x64 픽셀 이미지를 나타내는 3x64x64 텐서를 얻을 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 이 데이터 배치를 사용하여 강아지와 고양이 이미지를 인식하는 머신러닝 모델을 훈련할 수 있어요! (사실, 이 시리즈의 다음 블로그 게시물에서 이를 진행할 예정이에요!)\n\n# 텍스트 데이터 사용\n\n이 글의 마지막 부분에서는 sklearn.datasets의 fetch_20newsgroups를 사용하여 문자열과 정수 간 매핑을 생성할 거에요:\n\n```js\nfrom sklearn.datasets import fetch_20newsgroups\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음의 내용을 newsgroups에서 로드해 보겠습니다:\n\n```python\nfrom sklearn.datasets import fetch_20newsgroups\n\ncategories = [\n    'comp.os.ms-windows.misc',\n    'rec.sport.baseball',\n    'rec.sport.hockey',\n]\n\ndataset = fetch_20newsgroups(subset='train', categories=categories, shuffle=True, remove=('headers', 'footers', 'quotes'))\ncorpus = [item for item in dataset['data']]\n```\n\n다음 함수는 텍스트를 전처리할 것입니다:\n\n```python\nimport nltk\nimport re\n\ndef preprocess_text(text: str) -> str:\n    '''\n    입력 데이터에서 텍스트를 전처리하여 특수 문자와 숫자를 제거합니다.\n    \n    토큰 목록을 반환합니다.\n    '''\n    # 특수 문자 및 숫자 제거\n    text = re.sub(\"[^A-Za-z]+\", \" \", text)\n    tokens = nltk.word_tokenize(text.lower())\n    return tokens\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 우리 어휘를 생성하는 함수입니다:\n\n```js\ndef get_vocab(training_corpus):\n  # 특수 문자 추가\n  # 패딩, 라인 끝, 알 수 없는 용어\n  vocab = {'__PAD__': 0, '__</e>__': 1, '__UNK__': 2}\n  for item in training_corpus: \n    processed_text = preprocess_text(item)\n    processed_text.sort()\n    for word in processed_text:\n      if word not in vocab:\n        vocab[word] = len(vocab) \n  return vocab  \n```\n\n전체 어휘 사이즈는 얼마인가요?\n\n```js\nvocab = get_vocab(corpus)\nlen(vocab)\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이미지 파일:\n\n![이미지 파일](/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_11.png)\n\n단어장은 2만 6천 개가 조금 넘는 단어를 포함하고 있으며, 각 단어는 정수로 매핑되어 있습니다:\n\n이미지 파일:\n\n![이미지 파일](/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_12.png)\n\n이렇게 설정을 했으면, 문자를 정수로 변환하여 텐서로 변환하는 함수를 사용할 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\ndef text_to_tensor(text: str, vocab_dict: dict) -> torch.tensor:\n    '''\n    텍스트를 전처리하고 텐서 형식의 정수 매핑을 생성합니다.\n    '''   \n    word_l = preprocess_text(text)\n        \n    # 빈 텐서 초기화\n    tensor_l = [] \n    \n    # 단어 목록에서 __UNK__ 값을 가져옴\n    unk_ID = vocab_dict['__UNK__']\n            \n    # 각 단어에 대해:\n    for word in word_l:\n        # 인덱스 가져옴\n        # 단어가 vocab_dict에 없으면 UNK로 할당\n        word_ID = vocab_dict.get(word, unk_ID)\n        # 텐서 목록에 추가\n        tensor_l.append(word_ID)\n\n    return torch.tensor(tensor_l)\n```\n\n이 함수가 텍스트를 텐서로 어떻게 변환하는지에 대한 예시는 아래와 같습니다. 첫 번째 텍스트의 처음 200 단어를 사용하여 검사합니다:\n\n```python\nsnippet = corpus[0][0:200]\nprint('텍스트 \"{}\"는 다음과 같이 텐서로 표현됩니다: {}'.format(snippet, text_to_tensor(snippet, vocab)))\n```\n\n<img src=\"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_13.png\" />\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테이블 태그를 마크다운 형식으로 변경해주세요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 PyTorch 시리즈의 더 많은 포스트를 알아보려면 다음 링크를 확인해보세요:\n\n- Tensor 소개;\n- 선형 모델 만들기;\n- 활성화 함수 및 비선형 문제;\n\n이 게시물의 자료:\n\n- 택시 여행 기간 — https://www.nyc.gov/site/tlc/about/tlc-trip-record-data.page\n- 고양이와 개 이미지 인용: @Inproceedings (컨퍼런스)'asirra-a-captcha-that-exploits-interest-aligned-manual-image-categorization,\n저자 = 'Elson, Jeremy 및 Douceur, John (JD) 및 Howell, Jon 및 Saul, Jared',\n제목 = 'Asirra: A CAPTCHA that Exploits Interest-Aligned Manual Image Categorization',\n책 제목 = 'Proceedings of 14th ACM Conference on Computer and Communications Security (CCS)',\n연도 = '2007',\n월 = '10월',\n발행사 = 'Association for Computing Machinery, Inc.',\nurl = 'https://www.microsoft.com/en-us/research/publication/asirra-a-captcha-that-exploits-interest-aligned-manual-image-categorization/',\n판본 = 'Proceedings of 14th ACM Conference on Computer and Communications Security (CCS)',\n'","ogImage":{"url":"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_0.png","tag":["Tech"],"readingTime":19},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<img src=\"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_0.png\">\n<p>파이토치는 현재 딥 러닝 분야에서 가장 핫한 라이브러리 중 하나입니다. ChatGPT가 출시된 이후 데이터 과학가와 머신 러닝 엔지니어들 사이에서 딥 러닝 라이브러리가 아마도 가장 많은 관심을 받고 있다고 볼 수 있습니다. 특히 이러한 라이브러리는 매우 빠르게 복잡한 다차원 계산을 수행하는 능력이 뛰어나며, 이러한 라이브러리는 우리가 신경망 모델을 훈련하는 방식을 바꾸었습니다. 특히 이러한 모델이 저장하고 최적화하는 많은 수의 가중치를 관리하는 데 매우 도움이 됩니다. TensorFlow(구글의 프레임워크)와 경쟁하며, PyTorch는 Meta의 오픈 소스 프레임워크로, 아주 멋지고 실용적인 문법을 사용하여 딥 러닝 모델을 훈련할 수 있는 기회를 제공합니다.</p>\n<p>지금까지 이 PyTorch 시리즈에서 이 라이브러리를 사용하는 기본 개념을 배워왔습니다. 예를 들어:</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>텐서에 대한 기본 사항을 배우기</li>\n<li>PyTorch를 사용하여 처음 선형 모델(회귀)을 만드는 방법 이해하기</li>\n<li>비선형 활성화 함수 및 비선형 문제 해결하는 방법 배우기</li>\n</ul>\n<p>저희는 예제와 이전 블로그 게시물에서 몇 가지 사용자 정의 데이터셋을 사용했습니다. 이 시리즈에서 딥 러닝 모델을 교육하는 방향으로 진행하면서, PyTorch의 맥락에서 다양한 데이터셋을 통합하는 방법을 이해하는 데 매우 도움이 됩니다. 이 블로그 게시물에서는 라이브러리에서 사용자 정의 데이터셋을 다루는 방법을 배우고, 특히 세 가지 다른 유형의 데이터를 통합하는 방법을 다룰 것입니다:</p>\n<ul>\n<li>CSV 파일</li>\n<li>이미지 데이터</li>\n<li>텍스트 데이터</li>\n</ul>\n<p>또한 데이터 배치의 개념에 대해 살펴보고, 이를 위해 PyTorch 사용자 정의 DataLoader를 사용하는 방법도 알아볼 것입니다. 이 블로그 게시물의 일부 영감은 Zero to Mastery Pytorch 무료 강좌에서 온 것입니다 — 많은 흥미로운 학습 예제가 있는 이 멋진 자료를 확인해보세요.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>시작해 봅시다!</p>\n<h1>랜덤 데이터셋 생성</h1>\n<p>먼저, Pytorch에서 랜덤 데이터셋을 생성하여 DataLoader를 어떻게 사용할 수 있는지 이해해 봅시다:</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">import</span> torch\n<span class=\"hljs-keyword\">from</span> torch.utils.data <span class=\"hljs-keyword\">import</span> Dataset, DataLoader\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RandomIntDataset</span>(<span class=\"hljs-title class_ inherited__\">Dataset</span>):\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, start, stop, x, y</span>):\n        self.data = torch.randint(start, stop, (x,y))\n        self.labels = torch.randint(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">10</span>, (x,))\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__len__</span>(<span class=\"hljs-params\">self</span>):\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">len</span>(self.labels)\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__str__</span>(<span class=\"hljs-params\">self</span>):\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">str</span>(torch.cat((self.data, self.labels.unsqueeze(<span class=\"hljs-number\">1</span>)), <span class=\"hljs-number\">1</span>))\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__getitem__</span>(<span class=\"hljs-params\">self, i</span>):\n        <span class=\"hljs-keyword\">return</span> self.data[i], self.labels[i]\n</code></pre>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>저희 RandomIntDataset은 랜덤한 torch 객체와 레이블을 생성합니다. 클래스에 던더 메서드를 도입하고 torch.utils.data.Dataset을 상속했음을 주목해주세요. (특히 데이터셋을 DataLoader와 결합할 때 유용하게 사용될 것입니다).</p>\n<p>이전 클래스를 기반으로 첫 번째 데이터셋 객체를 생성해봅시다!</p>\n<pre><code class=\"hljs language-js\">dataset = <span class=\"hljs-title class_\">RandomIntDataset</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">1000</span>, <span class=\"hljs-number\">500</span>, <span class=\"hljs-number\">10</span>)\n</code></pre>\n<p>다시 말씀드리지만, Pytorch의 기본 클래스를 상속받았기 때문에 DataLoader를 사용하여 좋은 이터러블을 생성할 수 있습니다:</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\">dataset_loader = <span class=\"hljs-title class_\">DataLoader</span>(dataset, batch_size=<span class=\"hljs-number\">10</span>, shuffle=<span class=\"hljs-title class_\">True</span>)\n</code></pre>\n<p>신경망 내에서 데이터를 배치로 전달하는 것은 매우 흔한 일이며 DataLoader 생성자가 깔끔한 batch_size 인자를 통해 이를 처리합니다! dataset_loader는 반복 가능하므로 순차적인 데이터 배치를 얻기 위해 next 및 iter를 사용할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\">data, labels = <span class=\"hljs-title function_\">next</span>(<span class=\"hljs-title function_\">iter</span>(dataset_loader))\r\ndata\n</code></pre>\n<img src=\"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_1.png\">\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>새로운 iteration을 실행하고 data_loader의 다음 배치가 어떻게 이동하는지 확인해보세요! 이를 통해 데이터 및 레이블 객체 내부의 다른 데이터가 표시됩니다.</p>\n<p>물론, 이 무작위 데이터 세트는 실제로 \"사용자 지정 데이터 세트\"로 간주하기 어렵습니다. 무작위 생성된 데이터와 작업하려고 할 가능성은 매우 낮습니다. 그러나 배치 처리에 익숙해지는 데 도움이 되는 이 소개 후에 첫 번째 CSV 파일을 PyTorch 파이프라인에 포함하여 계속 진행할 준비가 되었습니다!</p>\n<h1>DataLoader와 사용자 지정 데이터 세트 결합</h1>\n<p>우리가 보았듯이, 무작위 데이터 세트 사용은 단순한 연습일 뿐입니다. 그러나 이제 DataLoader와 데이터 배치가 어떻게 작동하는지 알기 때문에 이 지식을 사용하여 새로운 클래스를 만들어 PyTorch 데이터 세트를 사용할 수 있습니다:</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">TaxiSample</span>(<span class=\"hljs-title class_ inherited__\">Dataset</span>):\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self</span>):\n        <span class=\"hljs-built_in\">super</span>().__init__()\n        df = pd.read_csv(<span class=\"hljs-string\">'data/taxi_data_sample.csv'</span>)\n        \n        features = [<span class=\"hljs-string\">'passenger_count'</span>,\n                    <span class=\"hljs-string\">'pickup_longitude'</span>,\n                    <span class=\"hljs-string\">'pickup_latitude'</span>,\n                    <span class=\"hljs-string\">'dropoff_longitude'</span>,\n                    <span class=\"hljs-string\">'dropoff_latitude'</span>]\n        \n        target = <span class=\"hljs-string\">'trip_duration'</span>\n        \n        self.features = torch.tensor(df[features].values, \n                                     dtype=torch.float32)\n\n        self.labels = torch.tensor(df[target].values, \n                                   dtype=torch.float32)\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__len__</span>(<span class=\"hljs-params\">self</span>):\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">len</span>(self.labels)\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__getitem__</span>(<span class=\"hljs-params\">self, idx</span>):\n        <span class=\"hljs-keyword\">return</span> self.features[idx], self.labels[idx]\n</code></pre>\n<p>참고: 라이브러리를 게시물에서 지날 때까지 가져오고 있지만 모든 라이브러리는 스크립트의 처음에 가져와야 합니다!</p>\n<p>우리가 사용하는 데이터셋은 Kaggle의 택시 여행 소요 시간 경쟁의 샘플 버전입니다. 여기서 csv를 init에 전달하고 있습니다 (이 기능을 더 다룰 수 있도록 인수로도 전달할 수 있습니다). DataLoader와 잘 어울리는지 확인해봅시다:</p>\n<pre><code class=\"hljs language-python\">data_taxi = TaxiSample()\ndataset_loader = DataLoader(data_taxi, batch_size=<span class=\"hljs-number\">20</span>, shuffle=<span class=\"hljs-literal\">True</span>)\n</code></pre>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>우리의 배치 크기가 20인 경우, 이 데이터셋에서 이터레이터를 만들 수 있습니다:</p>\n<pre><code class=\"hljs language-js\">data_iterator = <span class=\"hljs-title function_\">iter</span>(dataset_loader)\ndata, labels = <span class=\"hljs-title function_\">next</span>(data_iterator)\n</code></pre>\n<img src=\"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_2.png\">\n<p>멋져요! 이것들은 데이터셋에서 무작위로 선택한 처음 20개의 예시입니다. 위 이미지에서는 피처와 해당 레이블을 확인할 수 있어요.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>있는 이미지 데이터를 사용 해보세요.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>이 블로그 게시물의 이 섹션에서는 이미지 데이터 처리 능력을 보여주기 위해 Microsoft Research Cats. vs Dogs. 데이터셋과 함께 Pytorch를 사용할 것입니다. 먼저 pathlib를 사용하여 경로를 정의해 보겠습니다:</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">from</span> pathlib <span class=\"hljs-keyword\">import</span> Path\ndata_path = Path(“data/dogs_cats”)\n</code></pre>\n<p>폴더 안에는 강아지 이미지와 고양이 이미지가 있는 두 개의 폴더가 있습니다. 각 폴더에서 이미지 경로를 추출해 봅시다:</p>\n<p><img src=\"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_3.png\" alt=\"이미지\"></p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>이 섹션에서는 일반적인 컴퓨터 비전 변환 및 아키텍처를 제공하는 pytorch의 멋진 확장인 torchvision이 필요합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">from</span> torchvision <span class=\"hljs-keyword\">import</span> datasets, transforms\n</code></pre>\n<p>다음으로 jpg 파일 이름을 읽어보겠습니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\">image_dogs_list = <span class=\"hljs-title function_\">list</span>((data_path/<span class=\"hljs-string\">'dogs'</span>).<span class=\"hljs-title function_\">glob</span>(<span class=\"hljs-string\">\"*.jpg\"</span>))\nimage_cats_list = <span class=\"hljs-title function_\">list</span>((data_path/<span class=\"hljs-string\">'cats'</span>).<span class=\"hljs-title function_\">glob</span>(<span class=\"hljs-string\">\"*.jpg\"</span>))\n</code></pre>\n<p>.. and combining our lists into a single object:</p>\n<pre><code class=\"hljs language-js\">image_paths = image_cats_list + image_dogs_list\n</code></pre>\n<p>Let’s see if everything is working fine by extracting a random image from our list:</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">import</span> random\n<span class=\"hljs-keyword\">from</span> PIL <span class=\"hljs-keyword\">import</span> Image\n\nrandom.seed(<span class=\"hljs-number\">20</span>)\n\nrandom_image_path = random.choice(image_paths)\nimage_class = random_image_path.parent.stem\n\nimg = Image.<span class=\"hljs-built_in\">open</span>(random_image_path)\n\n<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f\"Random image path: <span class=\"hljs-subst\">{random_image_path}</span>\"</span>)\n<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f\"Image class: <span class=\"hljs-subst\">{image_class}</span>\"</span>)\n<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f\"Image height: <span class=\"hljs-subst\">{img.height}</span>\"</span>) \n<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f\"Image width: <span class=\"hljs-subst\">{img.width}</span>\"</span>)\nimg\n</code></pre>\n<p><img src=\"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_5.png\" alt=\"Cute little doggo!\"></p>\n<p>귀여운 강아지!</p>\n<p>이미지를 텐서로 변환할 때 일반적인 단계 중 하나는 이미지를 일반적인 포맷으로 조정하는 것입니다. transforms 라이브러리를 사용하여 이미지 크기를 조정하고 첫 번째 비전 파이프라인을 설정할 수 있습니다!</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-python\">data_transform = transforms.Compose([\n <span class=\"hljs-comment\"># 이미지 크기를 조정합니다</span>\n transforms.Resize(size=(<span class=\"hljs-number\">64</span>, <span class=\"hljs-number\">64</span>)),\n <span class=\"hljs-comment\"># 이미지를 수평으로 무작위로 뒤집습니다 — 이는 데이터 증가를 위한 단계입니다</span>\n transforms.RandomHorizontalFlip(p=<span class=\"hljs-number\">0.5</span>),\n transforms.ToTensor()])\n</code></pre>\n<p>위 transforms 파이프라인에서 우리는 다음을 수행합니다:</p>\n<ul>\n<li>이미지를 64x64 픽셀 크기로 크기 조정합니다.</li>\n<li>무작위로 수평으로 이미지를 뒤집습니다 — 이는 데이터 증가를 위한 일반적인 단계입니다.</li>\n<li>이미지를 텐서로 변환합니다.</li>\n</ul>\n<p>한 이미지와 해당 변환된 버전을 나란히 그래플로 표시합니다:</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> matplotlib.<span class=\"hljs-property\">pyplot</span> <span class=\"hljs-keyword\">as</span> plt\n\ndef <span class=\"hljs-title function_\">plot_transformed_images</span>(<span class=\"hljs-attr\">image_paths</span>: list, \n                            <span class=\"hljs-attr\">transform</span>: transforms.<span class=\"hljs-property\">Compose</span>, \n                            n=<span class=\"hljs-number\">3</span>, \n                            seed=<span class=\"hljs-number\">100</span>):\n    random.<span class=\"hljs-title function_\">seed</span>(seed)\n    random_image_paths = random.<span class=\"hljs-title function_\">sample</span>(image_paths, k=n)\n    <span class=\"hljs-keyword\">for</span> image_path <span class=\"hljs-keyword\">in</span> <span class=\"hljs-attr\">random_image_paths</span>:\n        <span class=\"hljs-keyword\">with</span> <span class=\"hljs-title class_\">Image</span>.<span class=\"hljs-title function_\">open</span>(image_path) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-attr\">f</span>:\n            fig, ax = plt.<span class=\"hljs-title function_\">subplots</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>)\n            ax[<span class=\"hljs-number\">0</span>].<span class=\"hljs-title function_\">imshow</span>(f) \n            ax[<span class=\"hljs-number\">0</span>].<span class=\"hljs-title function_\">set_title</span>(f<span class=\"hljs-string\">\"Original Image \\nSize: {f.size}\"</span>)\n            ax[<span class=\"hljs-number\">0</span>].<span class=\"hljs-title function_\">axis</span>(<span class=\"hljs-string\">\"off\"</span>) \n            transformed_image = <span class=\"hljs-title function_\">transform</span>(f).<span class=\"hljs-title function_\">permute</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">0</span>) \n            ax[<span class=\"hljs-number\">1</span>].<span class=\"hljs-title function_\">imshow</span>(transformed_image) \n            ax[<span class=\"hljs-number\">1</span>].<span class=\"hljs-title function_\">set_title</span>(f<span class=\"hljs-string\">\"Transformed Image \\nSize: {transformed_image.shape}\"</span>)\n            ax[<span class=\"hljs-number\">1</span>].<span class=\"hljs-title function_\">axis</span>(<span class=\"hljs-string\">\"off\"</span>)\n            fig.<span class=\"hljs-title function_\">suptitle</span>(f<span class=\"hljs-string\">\"Class: {image_path.parent.stem}\"</span>, fontsize=<span class=\"hljs-number\">16</span>)\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">plot_transformed_images</span>(image_paths, \n transform=data_transform, \n n=<span class=\"hljs-number\">1</span>)\n</code></pre>\n<img src=\"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_6.png\">\n<p>저런! 변환을 통해 기본 텐서에 액세스하는 방법을 살펴보겠습니다. 예를 들어, 첫 번째 이미지의 경우:</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\">image_path = image_paths[<span class=\"hljs-number\">0</span>]\n<span class=\"hljs-title function_\">data_transform</span>(<span class=\"hljs-title class_\">Image</span>.<span class=\"hljs-title function_\">open</span>(image_path))\n</code></pre>\n<p><img src=\"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_7.png\" alt=\"image\"></p>\n<p>데이터 변환은 RGB 채널이 3개이고 64x64 텐서를 생성했습니다!</p>\n<p>우리가 넘어가기 전에 더해야 할 마지막 단계 하나가 있습니다. 빠르게 텐서와 레이블을 생성하는 대안이 있습니다. 우리는 ImageFolder를 사용하여 편리하게 훈련 데이터를 생성할 수 있습니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\">train_data = datasets.<span class=\"hljs-title class_\">ImageFolder</span>(root=data_path, transform=data_transform, target_transform=<span class=\"hljs-title class_\">None</span>)\n</code></pre>\n<p><code>datasets.ImageFolder</code>을 사용해요</p>\n<pre><code class=\"hljs language-js\">class_names = train_data.<span class=\"hljs-property\">classes</span>\nclass_names\n</code></pre>\n<img src=\"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_8.png\">\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>class_names에는 현재 태그(폴더 이름에서 읽음)가 컴퓨터 비전 모델에 포함되어 있습니다. train_data에는 컴퓨터 비전 프로세스에 대한 중요한 메타데이터가 포함되어 있습니다:</p>\n<p><img src=\"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_9.png\" alt=\"이미지\"></p>\n<p>그리고 이제 데이터 세트 ImageFolders를 DataLoaders로 변환하는 것은 매우 간단합니다:</p>\n<pre><code class=\"hljs language-js\">train_dataloader = <span class=\"hljs-title class_\">DataLoader</span>(dataset=train_data, \n batch_size=<span class=\"hljs-number\">5</span>,\n num_workers=<span class=\"hljs-number\">1</span>, \n shuffle=<span class=\"hljs-title class_\">True</span>)\n\ntrain_dataloader\n</code></pre>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>보면 이터러블이 있네요:</p>\n<pre><code class=\"hljs language-python\">img, label = <span class=\"hljs-built_in\">next</span>(<span class=\"hljs-built_in\">iter</span>(train_dataloader))\n<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f\"이미지 형태: <span class=\"hljs-subst\">{img.shape}</span> -> [배치 크기, 색상 채널, 높이, 너비]\"</span>)\n<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f\"레이블 형태: <span class=\"hljs-subst\">{label.shape}</span>\"</span>)\n</code></pre>\n<p><img src=\"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_10.png\" alt=\"image\"></p>\n<p>멋져요! 이 배치 크기가 5인 경우, 3채널(RGB)의 64x64 픽셀 이미지를 나타내는 3x64x64 텐서를 얻을 수 있습니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>이제 이 데이터 배치를 사용하여 강아지와 고양이 이미지를 인식하는 머신러닝 모델을 훈련할 수 있어요! (사실, 이 시리즈의 다음 블로그 게시물에서 이를 진행할 예정이에요!)</p>\n<h1>텍스트 데이터 사용</h1>\n<p>이 글의 마지막 부분에서는 sklearn.datasets의 fetch_20newsgroups를 사용하여 문자열과 정수 간 매핑을 생성할 거에요:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">from</span> sklearn.<span class=\"hljs-property\">datasets</span> <span class=\"hljs-keyword\">import</span> fetch_20newsgroups\n</code></pre>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>다음의 내용을 newsgroups에서 로드해 보겠습니다:</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">from</span> sklearn.datasets <span class=\"hljs-keyword\">import</span> fetch_20newsgroups\n\ncategories = [\n    <span class=\"hljs-string\">'comp.os.ms-windows.misc'</span>,\n    <span class=\"hljs-string\">'rec.sport.baseball'</span>,\n    <span class=\"hljs-string\">'rec.sport.hockey'</span>,\n]\n\ndataset = fetch_20newsgroups(subset=<span class=\"hljs-string\">'train'</span>, categories=categories, shuffle=<span class=\"hljs-literal\">True</span>, remove=(<span class=\"hljs-string\">'headers'</span>, <span class=\"hljs-string\">'footers'</span>, <span class=\"hljs-string\">'quotes'</span>))\ncorpus = [item <span class=\"hljs-keyword\">for</span> item <span class=\"hljs-keyword\">in</span> dataset[<span class=\"hljs-string\">'data'</span>]]\n</code></pre>\n<p>다음 함수는 텍스트를 전처리할 것입니다:</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">import</span> nltk\n<span class=\"hljs-keyword\">import</span> re\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">preprocess_text</span>(<span class=\"hljs-params\">text: <span class=\"hljs-built_in\">str</span></span>) -> <span class=\"hljs-built_in\">str</span>:\n    <span class=\"hljs-string\">'''\n    입력 데이터에서 텍스트를 전처리하여 특수 문자와 숫자를 제거합니다.\n    \n    토큰 목록을 반환합니다.\n    '''</span>\n    <span class=\"hljs-comment\"># 특수 문자 및 숫자 제거</span>\n    text = re.sub(<span class=\"hljs-string\">\"[^A-Za-z]+\"</span>, <span class=\"hljs-string\">\" \"</span>, text)\n    tokens = nltk.word_tokenize(text.lower())\n    <span class=\"hljs-keyword\">return</span> tokens\n</code></pre>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>아래는 우리 어휘를 생성하는 함수입니다:</p>\n<pre><code class=\"hljs language-js\">def <span class=\"hljs-title function_\">get_vocab</span>(training_corpus):\n  # 특수 문자 추가\n  # 패딩, 라인 끝, 알 수 없는 용어\n  vocab = {<span class=\"hljs-string\">'__PAD__'</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">'__&#x3C;/e>__'</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">'__UNK__'</span>: <span class=\"hljs-number\">2</span>}\n  <span class=\"hljs-keyword\">for</span> item <span class=\"hljs-keyword\">in</span> <span class=\"hljs-attr\">training_corpus</span>: \n    processed_text = <span class=\"hljs-title function_\">preprocess_text</span>(item)\n    processed_text.<span class=\"hljs-title function_\">sort</span>()\n    <span class=\"hljs-keyword\">for</span> word <span class=\"hljs-keyword\">in</span> <span class=\"hljs-attr\">processed_text</span>:\n      <span class=\"hljs-keyword\">if</span> word not <span class=\"hljs-keyword\">in</span> <span class=\"hljs-attr\">vocab</span>:\n        vocab[word] = <span class=\"hljs-title function_\">len</span>(vocab) \n  <span class=\"hljs-keyword\">return</span> vocab  \n</code></pre>\n<p>전체 어휘 사이즈는 얼마인가요?</p>\n<pre><code class=\"hljs language-js\">vocab = <span class=\"hljs-title function_\">get_vocab</span>(corpus)\n<span class=\"hljs-title function_\">len</span>(vocab)\n</code></pre>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>이미지 파일:</p>\n<p><img src=\"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_11.png\" alt=\"이미지 파일\"></p>\n<p>단어장은 2만 6천 개가 조금 넘는 단어를 포함하고 있으며, 각 단어는 정수로 매핑되어 있습니다:</p>\n<p>이미지 파일:</p>\n<p><img src=\"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_12.png\" alt=\"이미지 파일\"></p>\n<p>이렇게 설정을 했으면, 문자를 정수로 변환하여 텐서로 변환하는 함수를 사용할 수 있습니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">text_to_tensor</span>(<span class=\"hljs-params\">text: <span class=\"hljs-built_in\">str</span>, vocab_dict: <span class=\"hljs-built_in\">dict</span></span>) -> torch.tensor:\n    <span class=\"hljs-string\">'''\n    텍스트를 전처리하고 텐서 형식의 정수 매핑을 생성합니다.\n    '''</span>   \n    word_l = preprocess_text(text)\n        \n    <span class=\"hljs-comment\"># 빈 텐서 초기화</span>\n    tensor_l = [] \n    \n    <span class=\"hljs-comment\"># 단어 목록에서 __UNK__ 값을 가져옴</span>\n    unk_ID = vocab_dict[<span class=\"hljs-string\">'__UNK__'</span>]\n            \n    <span class=\"hljs-comment\"># 각 단어에 대해:</span>\n    <span class=\"hljs-keyword\">for</span> word <span class=\"hljs-keyword\">in</span> word_l:\n        <span class=\"hljs-comment\"># 인덱스 가져옴</span>\n        <span class=\"hljs-comment\"># 단어가 vocab_dict에 없으면 UNK로 할당</span>\n        word_ID = vocab_dict.get(word, unk_ID)\n        <span class=\"hljs-comment\"># 텐서 목록에 추가</span>\n        tensor_l.append(word_ID)\n\n    <span class=\"hljs-keyword\">return</span> torch.tensor(tensor_l)\n</code></pre>\n<p>이 함수가 텍스트를 텐서로 어떻게 변환하는지에 대한 예시는 아래와 같습니다. 첫 번째 텍스트의 처음 200 단어를 사용하여 검사합니다:</p>\n<pre><code class=\"hljs language-python\">snippet = corpus[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>:<span class=\"hljs-number\">200</span>]\n<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">'텍스트 \"{}\"는 다음과 같이 텐서로 표현됩니다: {}'</span>.<span class=\"hljs-built_in\">format</span>(snippet, text_to_tensor(snippet, vocab)))\n</code></pre>\n<img src=\"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_13.png\">\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>테이블 태그를 마크다운 형식으로 변경해주세요.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>이 PyTorch 시리즈의 더 많은 포스트를 알아보려면 다음 링크를 확인해보세요:</p>\n<ul>\n<li>Tensor 소개;</li>\n<li>선형 모델 만들기;</li>\n<li>활성화 함수 및 비선형 문제;</li>\n</ul>\n<p>이 게시물의 자료:</p>\n<ul>\n<li>택시 여행 기간 — <a href=\"https://www.nyc.gov/site/tlc/about/tlc-trip-record-data.page\" rel=\"nofollow\" target=\"_blank\">https://www.nyc.gov/site/tlc/about/tlc-trip-record-data.page</a></li>\n<li>고양이와 개 이미지 인용: @Inproceedings (컨퍼런스)'asirra-a-captcha-that-exploits-interest-aligned-manual-image-categorization,\n저자 = 'Elson, Jeremy 및 Douceur, John (JD) 및 Howell, Jon 및 Saul, Jared',\n제목 = 'Asirra: A CAPTCHA that Exploits Interest-Aligned Manual Image Categorization',\n책 제목 = 'Proceedings of 14th ACM Conference on Computer and Communications Security (CCS)',\n연도 = '2007',\n월 = '10월',\n발행사 = 'Association for Computing Machinery, Inc.',\nurl = '<a href=\"https://www.microsoft.com/en-us/research/publication/asirra-a-captcha-that-exploits-interest-aligned-manual-image-categorization/\" rel=\"nofollow\" target=\"_blank\">https://www.microsoft.com/en-us/research/publication/asirra-a-captcha-that-exploits-interest-aligned-manual-image-categorization/</a>',\n판본 = 'Proceedings of 14th ACM Conference on Computer and Communications Security (CCS)',\n'</li>\n</ul>\n</body>\n</html>\n"},"__N_SSG":true}