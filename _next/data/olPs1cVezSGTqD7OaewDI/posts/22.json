{"pageProps":{"posts":[{"title":"데이터 사이언티스트 인터뷰 꼭 알아야 할 10가지 질문과 답변","description":"","date":"2024-07-14 19:44","slug":"2024-07-14-DataScientistInterview10EssentialQuestionsandAnswers","content":"\n\n데이터 과학자 인터뷰 준비는 어려운 작업일 수 있습니다. 데이터 과학은 프로그래밍, 통계, 데이터 분석 및 도메인 지식을 결합한 다학제적 분야입니다. 다음 데이터 과학자 인터뷰에서 성공하도록 도와 드리기 위해 핵심 개념 및 기술을 평가하는 이러한 인터뷰에서 일반적으로 평가되는 10가지 중요 질문과 답변 목록을 작성했습니다.\n\n![이미지](/TIL/assets/img/2024-07-14-DataScientistInterview10EssentialQuestionsandAnswers_0.png)\n\n# 질문 1: 데이터 과학, 데이터 분석 및 기계 학습과 어떻게 다른가요?\n\n답변: 데이터 과학은 다양한 기술과 도구를 사용하여 데이터에서 가치 있는 통찰과 지식을 추출하는 분야입니다. 데이터 분석과 기계 학습을 포함하지만 그 이상을 다룹니다. 데이터 분석은 데이터를 탐색하고 요약하는 데 중점을 두는 반면, 기계 학습은 예측 모델을 구축하는 데 관심이 있습니다. 데이터 과학은 데이터 수집 및 정리부터 분석, 모델링 및 배포에 이르기까지 전체 데이터 수명주기를 포함합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 질문 2: 데이터 과학 과정을 설명해주세요.\n\n답변: 데이터 과학 과정은 일반적으로 다음 단계를 포함합니다:\n\n- 문제 정의: 해결하고자 하는 문제를 명확히 정의합니다.\n- 데이터 수집: 다양한 소스에서 관련 데이터를 수집합니다.\n- 데이터 정제 및 전처리: 데이터를 정리, 형식화하고 분석을 위해 준비합니다.\n- 탐색적 데이터 분석 (EDA): 데이터를 탐색하여 특성을 이해합니다.\n- 피처 엔지니어링: 모델 성능을 개선하기 위해 새로운 기능을 만들거나 기존 기능을 변환합니다.\n- 모델링: 머신 러닝 모델을 구축하고 훈련합니다.\n- 평가: 적절한 지표를 사용하여 모델 성능을 평가합니다.\n- 배포: 모델을 실제 제품에 적용합니다.\n- 모니터링 및 유지보수: 모델의 성능을 지속적으로 모니터링하고 필요한 경우 업데이트합니다.\n\n# 질문 3: 과적합(Overfitting)은 무엇이며, 어떻게 예방할 수 있나요?\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n답변: 과적합은 기계 학습 모델이 훈련 데이터에서는 잘 수행하지만 보이지 않는 데이터(테스트 데이터)에서는 성능이 저하되는 현상을 말합니다. 과적합을 방지하기 위해 다음을 시도할 수 있습니다:\n\n- 더 많은 훈련 데이터 사용하기.\n- 모델을 간단하게 만들기 (예: 복잡성 줄이기).\n- L1 또는 L2 정규화와 같은 정규화 기법 사용.\n- 모델 성능 평가를 위해 교차 검증 사용.\n- 랜덤 포레스트나 그레디언트 부스팅과 같은 앙상블 방법을 사용하여 과적합 완화 가능.\n\n# 질문 4: 군집화에서 사용되는 일반적인 거리 측정 방법은 무엇인가요?\n\n답변: 군집화에서 사용되는 일반적인 거리 측정 방법에는 다음이 있습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 유클리드 거리: 데이터 포인트 사이의 직선 거리를 측정합니다.\n- 맨해튼 거리: 좌표 사이의 절대 차이의 합을 계산합니다.\n- 코사인 유사도: 두 벡터 사이의 각도의 코사인을 측정합니다.\n- 자카드 유사도: 두 집합의 교집합 크기를 두 집합의 합집합 크기로 나누어 계산합니다.\n- 마할라노비스 거리: 데이터 내의 상관 관계를 고려합니다.\n- 해밍 거리: 이진 데이터에 사용되며 다른 비트를 계산합니다.\n\n# 질문 5: 편향-분산 균형을 설명해주세요.\n\n답변: 편향-분산 균형은 기계 학습에서 근본적인 개념입니다. 이는 모델이 훈련 데이터를 잘 맞추는 능력(낮은 편향)과 보이지 않는 데이터에 일반화하는 능력(낮은 분산) 사이의 균형을 의미합니다.\n\n- 높은 편향: 모델이 높은 편향을 가지면 데이터를 잘 적합하지 못해 기본적인 패턴을 파악하지 못합니다.\n- 높은 분산: 모델이 높은 분산을 가지면 과도하게 복잡하며 데이터의 잡음을 적합하게 되어 부적절한 일반화로 이어집니다. 편향과 분산 사이의 적절한 균형을 찾는 것은 훈련 및 테스트 데이터 모두에서 잘 수행하는 모델을 구축하는 데 중요합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 질문 6: 교차 검증이 무엇이며 왜 중요한가요?\n\n답변: 교차 검증은 모델의 성능을 평가하는 데 사용되는 기술입니다. 데이터를 여러 하위 집합(폴드)으로 나누고 각각의 하위 집합에서 모델을 학습하고 나머지 데이터에서 모델을 평가하는 것을 포함합니다. 교차 검증은 모델의 성능에 대한 보다 견고한 추정을 제공하여 오버피팅과 같은 문제를 감지하는 데 도움이 됩니다. 일반적인 교차 검증 유형에는 k-겹 교차 검증과 LOOCV(leave-one-out cross-validation)가 있습니다.\n\n# 질문 7: 일부 특성 선택 기술은 무엇인가요?\n\n답변: 특성 선택은 모델 성능을 향상시키고 차원을 축소하기 위해 관련 특성의 하위 집합을 선택하는 프로세스입니다. 기술에는 다음이 포함됩니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 필터 방법: 모델과 독립적으로 기능을 평가합니다 (예: 카이제곱 테스트).\n- 래퍼 방법: 특정 모델을 사용하여 기능 부분집합을 평가합니다 (예: 재귀적 기능 제거).\n- 임베디드 방법: 기능 선택이 모델 학습 과정에 통합됩니다 (예: L1 정규화).\n\n## 질문 8: A/B 테스트란 무엇이며 결과를 어떻게 분석하나요?\n\n답변: A/B 테스트는 두 가지 버전(A 및 B)의 웹페이지, 앱 또는 제품을 비교하여 어떤 것이 더 나은 성능을 발휘하는지 결정하는 방법입니다. 결과를 분석하기 위해 일반적으로 t-검정이나 카이제곱 검정과 같은 통계적 가설 검정을 사용하여 관찰된 차이가 통계적으로 유의한지 평가합니다. 또한 실용적인 중요성과 샘플 크기, 테스트 기간과 같은 요인을 고려합니다.\n\n## 질문 9: 머신러닝에서 정규화 개념을 설명해주세요.  \n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n답변: Regularization은 오버피팅을 방지하기 위해 모델의 손실 함수에 패널티 항을 추가하는 기술입니다. 두 가지 일반적인 유형은 L1 정규화(Lasso)와 L2 정규화(Ridge)입니다. L1 정규화는 계수의 절대값을 손실에 추가하여 희소한 해를 장려합니다. L2 정규화는 계수의 제곱을 추가하여 극단적인 값이 나오지 않도록 합니다. 정규화는 모델 복잡성을 제한하는 데 도움이 됩니다.\n\n# 질문 10: 파이썬에서 일반적인 데이터 시각화 라이브러리는 무엇입니까?\n\n답변: 파이썬에서 일반적인 데이터 시각화 라이브러리로는 Matplotlib, Seaborn, Plotly 및 Bokeh가 있으며 정적 및 대화식 플롯을 지원합니다. 특수한 시각화를 위해 NetworkX(네트워크 그래프용) 및 Folium(대화식 지도용)과 같은 라이브러리도 사용됩니다.\n\n마지막으로, 이러한 질문과 답변은 데이터 과학과 기계 학습의 기본 주제를 다루며 일반적으로 면접에서 탐구됩니다. 이러한 질문에 대비하여 준비를 하면 면접에서 잘할 뿐만 아니라 데이터 과학의 중요한 개념에 대한 이해를 더욱 깊게 할 수 있습니다. 기술 면접에 코딩 문제도 자주 포함되므로 코딩과 문제 해결 능력에 대한 연습도 중요합니다. 데이터 과학자 면접 준비를 잘 하시기 바랍니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 파이썬 기초\n\n시간 내어 관심 가져 주셔서 감사합니다! 🚀\n더 많은 콘텐츠는 Python Fundamentals에서 찾을 수 있어요 💫","ogImage":{"url":"/TIL/assets/img/2024-07-14-DataScientistInterview10EssentialQuestionsandAnswers_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-DataScientistInterview10EssentialQuestionsandAnswers_0.png","tag":["Tech"],"readingTime":6},{"title":"지리 공간 빅 데이터를 활용한 짧은 영상 제작을 위한 긴 Python 스크립트","description":"","date":"2024-07-14 19:43","slug":"2024-07-14-ALongPythonScripttoMakeaShortVideoUsingGeospatialBigData","content":"\n\n\n![이미지](/TIL/assets/img/2024-07-14-ALongPythonScripttoMakeaShortVideoUsingGeospatialBigData_0.png)\n\n# 목차\n\n- 🌟 소개\n- 🔍 설정: 설치 및 라이브러리 임포트\n- ⏳ \"NetCDF\" 파일의 쿼리 및 처리\n- 🗺️ 캘리포니아 지역 및 NDVI 지도 플로팅을 위한 이미지 클리핑\n- 🎥 NDVI 지도를 비디오로 내보내기\n- 📝 결론\n- 📚 참고 자료\n\n## 🌟 소개\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n원하는 곳에서 매일 또는 매주 촬영된 위성 이미지를 기반으로 동영상과 애니메이션을 만드는 것을 즐기며 대규모 지리 공간 데이터를 시각화하는 일에 깊은 열정을 갖고 있습니다. 그러나 이 많은 양의 이미지를 처리하는 것은 다운로드, 클리핑, 위성 이미지 표시 등의 단계를 거치기 때문에 시간이 많이 걸립니다. 이 과정에는 API, 코딩, 지리 데이터에 대한 심도 있는 이해, 데이터 시각화에 대한 뛰어난 기술이 필요합니다. 이 이야기는 '위에 언급된 모든' 기술의 조합에 관한 것입니다.\n\n다른 게시물에서 Sentinel-2 및 Sentinel-3 이미지의 시각화에 대해 작성하던 중, 이 중 하나의 위성이 특정 위치 위에서 촬영한 모든 이미지를 모아 애니메이션으로 제시하는 아이디어에 주목했습니다. 오늘은 이 비전을 실현하고 2023년 캘리포니아 위에서 캡처된 Sentinel-3의 NDVI 맵을 탐색해보는 날입니다!\n\n이 이야기에서는 이러한 NDVI 맵을 처리, 시각화하고 애니메이션을 만들기 위해 Google Colab에서 강력한 Python 스크립트를 작성할 것입니다. 여기서는 이미지 다운로드 부분을 다루지 않습니다. 이미 별도의 이야기에서 자세히 다루었기 때문에 해당 링크에서 확인할 수 있습니다:\n\n## 🔍 설정: 설치 및 라이브러리 가져오기\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n첫 번째 단계는 다음 폴더를 생성하는 것입니다: NetCDF, Geotiff, Geotiff_reproj, Geotiff_reproj_clipped, Shapefile, JPEG 및 Animation. 다음과 같이 수행할 수 있습니다:\n\n```js\nimport os\n\n# 폴더 이름 정의\nfolders = ['NetCDF', 'Geotiff', 'Geotiff_reproj', 'Geotiff_reproj_clipped', 'Shapefile', 'JPEG', 'Animation']\n\n# 폴더 생성\nfor folder in folders:\n    if not os.path.exists(folder):\n        os.makedirs(folder)\n\n# 확인 메시지 출력\nprint('폴더가 성공적으로 생성되었습니다!')\n```\n\n<img src=\"/TIL/assets/img/2024-07-14-ALongPythonScripttoMakeaShortVideoUsingGeospatialBigData_1.png\" />\n\nNetCDF 폴더는 Sentinel-3 NDVI의 raw 데이터를 저장합니다. 추가로, Geotiff, Geotiff_reproj, Geotiff_reproj_clipped 폴더는 래스터 파일, 재투영된 래스터 파일 및 래스터 파일 클립을 GeoTIFF 형식으로 저장하기 위해 생성됩니다 (모두 NetCDF 파일에서 변환된 형식). Shapefile 폴더에는 캘리포니아 형태 파일(우리의 관심 영역(AOI)로 Sentinel-3 이미지 클리핑을 위해)이 포함되어 있습니다. JPEG 폴더는 NDVI 맵을 \".jpg\" 형식으로 저장하기 위해 생성되며, Animation 폴더는 최종 비디오를 저장하기 위해 특별히 생성되었습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n또한, Google Colab에 몇 가지 라이브러리를 설치하고 가져와야 합니다.\n\n```js\npip install pandas rasterio netCDF4 rioxarray\n```\n\n```js\nimport os\nimport re\nimport sys\nimport random\nfrom pathlib import Path\n\nimport requests\nimport json\nimport xml.etree.ElementTree as ET\nimport certifi\n\nimport pandas as pd\nimport numpy as np\n\nimport rasterio\nimport matplotlib.pyplot as plt\nimport matplotlib.image\nfrom rasterio.windows import Window\n\nimport netCDF4 as nc\n\nimport rioxarray\n\nfrom rasterio.control import GroundControlPoint\n```\n\n## ⏳ \"NetCDF\" 파일의 쿼리 및 처리\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 단계는 쿼리를 제출하고 시작 날짜, 종료 날짜 및 AOI를 지정하는 것입니다. NDVI 지도는 토양 표면 온도 수준의 부수 데이터이므로, 여전히 레벨 변수로 \"LST\"를 사용할 수 있습니다. 미국의 다른 주에 대한 애니메이션을 만들고 싶다면, AOI 지점이나 폴리곤을 해당하도록 수정하세요. 또한, 시작 날짜와 종료 날짜로 2023년 5월 1일 및 8월 1일을 고려해보세요. 다음과 같은 줄로 이 작업을 수행할 수 있습니다:\n\n```js\nurl_dataspace = \"https://catalogue.dataspace.copernicus.eu/odata/v1\"\n\n# 필터링\nsatellite = \"SENTINEL-3\"\nlevel= \"LST\"\n\naoi_point =\"POINT(-121.669668 38.372428)\"\n#aoi_polygon = \"POLYGON ((-121.0616 37.6391, -120.966 37.6391, -120.966 37.6987, -121.0616 37.6987, -121.0616 37.6391))\"\n\nstart_date = \"2023-05-01\"\nend_date = \"2023-08-01\"\nstart_date_full =start_date+\"T00:00:00.000Z\"\nend_date_full = end_date +\"T00:00:00.000Z\"\n```\n\n이 정보를 통해 쿼리를 제출할 준비가 되었습니다. 데이터베이스에서 사용 가능한 이미지 목록을 내보내야 하므로, 쿼리 끝에 \"&$top=1000&$expand=Attributes\"를 포함해야 합니다. 이는 데이터베이스에서 이미지 내보내기의 기본 수가 20이며, 2023년에 Sentinel-3가 촬영한 이미지 수가 20을 초과하기 때문에 필요합니다:\n\n```js\nquery = f\"{url_dataspace}/Products?$filter=Collection/Name eq '{satellite}' and Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'productType' and att/OData.CSC.StringAttribute/Value eq '{level}') and OData.CSC.Intersects(area=geography'SRID=4326;{aoi_point}') and ContentDate/Start gt {start_date_full} and ContentDate/Start lt {end_date_full}&$top=1000&$expand=Attributes\"\nresponse = requests.get(query).json()\nresult = pd.DataFrame.from_dict(response[\"value\"])\n\n# 'Online' 열이 True인 레코드 필터링\nresult = result[result['Online'] == True]\n\n# 처음 10개 결과 출력\nresult.head(10)\n\nresult.to_csv('result_LST.csv', index=False)\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 단계에서는 온라인에서 사용 가능한 이미지 목록을 필터링하여 정오쯤 촬영된 이미지에 특히 주목할 것입니다. 파일의 감지 시간은 UTM을 기준으로 하기 때문에 18:00:00은 태평양 표준시 (캘리포니아 시간) 기준으로 대략 12:00:00 오후에 해당합니다:\n\n```js\nfiltered_df = result[result[\"Name\"].str.split(\"_\").str[8].str.contains(\"T18\") & result[\"Name\"].str.split(\"_\").str[14].str.contains(\"PS2\") & result[\"Name\"].str.split(\"_\").str[16].str.contains(\"NT\")]\n\nfiltered_df = filtered_df.reset_index(drop=True)\n\nprint(filtered_df['Name'])\n```\n\n```js\nfiltered_df.to_csv('result_LST_Filtered.csv', index=False)\n```\n\n필터링된 데이터프레임을 기반으로, 2023년 5월 1일부터 8월 1일까지 캘리포니아 상공에서 촬영된 Sentinel-3의 53장의 이미지가 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/TIL/assets/img/2024-07-14-ALongPythonScripttoMakeaShortVideoUsingGeospatialBigData_2.png\" />\n\n이미지가 흐릿할 수 있다는 점을 기억하세요. 센티넬-3 이미지를 구름 덮개로 걸러내는 것을 제어할 수 없기 때문입니다.\n\n다음 단계는 필터링된 목록의 제품 ID를 사용하여 NetCDF 파일을 다운로드하는 것을 포함합니다. 이 부분은 이미 다음 포스트의 섹션들(📥 \"NetCDF\" 파일 다운로드 및 🛠️ Geotiff로 변환)에서 설명된 자료의 중복을 피하기 위해 건너뛰었습니다:\n\n## 🗺️ 캘리포니아를 위한 이미지 클리핑과 NDVI 지도 플로팅\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 단계를 자세히 설명하기 전에 다음 패키지를 설치하고 로드해주세요:\n\n```js\npip install matplotlib-scalebar\n```\n\n```js\nimport os\nimport matplotlib.pyplot as plt\nfrom matplotlib import colors\nfrom mpl_toolkits.axes_grid1 import make_axes_locatable\nfrom mpl_toolkits.axes_grid1.inset_locator import inset_axes\nfrom matplotlib_scalebar.scalebar import ScaleBar\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom datetime import datetime\nimport rasterio.plot\n```\n\n이 단계에서는 Geotiff_reproj 폴더에 저장된 53개의 래스터 파일 각각을 읽어올 것입니다. 캘리포니아 쉐이프파일 투영과 래스터 파일 간의 일관성을 확인할 것입니다. 필요한 경우 쉐이프파일을 재투영할 것입니다. 그런 다음, 래스터 파일을 캘리포니아의 경계에 맞게 자릅니다. 해당 플롯을 플로팅하고 JPEG 폴더에 저장할 것입니다. 캘리포니아 쉐이프파일을 다운로드하려면 다음 URL을 방문하여 \"California State Boundry\"를 다운로드하고 Shapefile 폴더에 업로드해주세요:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n[California Geographic Boundaries](https://data.ca.gov/dataset/ca-geographic-boundaries)\n\n![Image](/TIL/assets/img/2024-07-14-ALongPythonScripttoMakeaShortVideoUsingGeospatialBigData_3.png)\n\nThe following code also requires an image for the north arrow symbol. You can either download one from the internet or, like me, draw it in PowerPoint, save it, and upload it to your main folder.\n\n![Image](/TIL/assets/img/2024-07-14-ALongPythonScripttoMakeaShortVideoUsingGeospatialBigData_4.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n맵에 이 아이콘이 표시되는 것은 완전히 선택 사항입니다. 맵에 북쪽 화살표를 표시하고 싶지 않다면 해당 섹션을 주석 처리할 수 있습니다:\n\n```js\n# 디렉토리 경로 설정\ndirectory = '/content/Geotiff_reproj_clipped/'\n\n\n# 디렉토리 내 모든 파일 목록 가져오기\nfiles = os.listdir(directory)\n\n# NDVI TIF 파일만 포함하는 목록 필터링\nndvi_files = [f for f in files if f.endswith('.tif')]\n\n\n# 색상 한계 설정\nvmin = 0\nvmax = 1\nndvi_norm = colors.Normalize(vmin, vmax)\nndvi_cmap = plt.cm.RdYlGn\nndvi_cmap.set_bad(color='white')\n\n# 각각의 NDVI 파일을 루프하여 플롯하기\nfor ndvi_file in ndvi_files:\n    print(ndvi_file)\n    date_str = ndvi_file.split('_')[0]\n    date_obj = datetime.strptime(date_str, \"%Y%m%d\")\n    formatted_date_str = date_obj.strftime(\"%Y/%-m/%-d\")\n\n    # NDVI 래스터 열기\n    with rasterio.open(f\"/content/Geotiff_reproj_clipped/{ndvi_file}\") as ndvi:\n      # shapefile 읽기\n      california_shapefile = gpd.read_file('/content/Shapefile/CA_State_TIGER2016.shp')\n\n      ndvi_data = ndvi.read(1).astype(float)\n      ndvi_data[ndvi_data<=-1]=np.nan\n      ndvi_crs = ndvi.crs\n      extent = rasterio.plot.plotting_extent(ndvi)\n\n      # shapefile을 래스터의 투영과 일치하도록 재투영\n      california_shapefile = california_shapefile.to_crs(ndvi_crs)\n\n\n    # 플롯 생성\n    fig, ax = plt.subplots(figsize=(10, 6))\n\n    \n    image= rasterio.plot.show(ndvi_data, ax=ax, extent=extent, alpha=1, cmap=ndvi_cmap,norm=ndvi_norm,)\n    im = image.get_images()[0]  # 컬러바에 대한 트릭 (rasterio.plot.show와 호환되지 않음)\n    fig.colorbar(im, ax=ax)\n   \n\n    ax.set_title(formatted_date_str, fontsize=16,fontweight='bold')\n    california_shapefile.boundary.plot(ax=ax, color='k', linewidth=1)\n\n    ax.set_xticklabels([])\n    ax.set_yticklabels([])\n\n    # 북쪽 화살표 추가\n    north_arrow_image = plt.imread('North_sign.png')\n    imagebox = OffsetImage(north_arrow_image, zoom=0.25)\n    ab = AnnotationBbox(imagebox, (0.8, 0.99), xycoords='axes fraction', box_alignment=(0, 1), frameon=False)\n    ax.add_artist(ab)\n\n    # 스케일 바 추가\n    scalebar = ScaleBar(1000, 'm', length_fraction=0.2, location='lower right', font_properties={'size':12})\n    ax.add_artist(scalebar)\n\n    # 맵 주변에 네모 상자 끄기\n    ax.axis('off')\n\n    # 플롯을 JPEG 파일로 저장\n    plt.savefig(os.path.join('/content/JPEG', ndvi_file.split('_')[0] + '.jpg'), dpi=300, bbox_inches='tight')\n\n    # 메모리 해제를 위해 플롯 닫기\n    plt.close(fig)\r\n```\n\n이 단계를 완료하면 \"JPEG\" 폴더에 센싱 날짜를 기준으로 저장된 53개의 NDVI 지도가 있게 될 것입니다:\n\n<img src=\"/TIL/assets/img/2024-07-14-ALongPythonScripttoMakeaShortVideoUsingGeospatialBigData_5.png\" />\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 🎥 NDVI 지도를 비디오로 내보내기\n\n3개월 동안 센티넬-3에 의해 촬영된 53개의 NDVI 지도(대략 매 2일마다 1장씩)를 사용하여, 2023년 캘리포니아 지역 전체의 NDVI 패턴과 변화를 보여주는 애니메이션을 만들 수 있습니다. 이 비디오를 생성하려면, 다음 스크립트를 실행하세요:\n\n```js\npip install pillow\n```\n\n```js\nfrom PIL import Image\nimport os\nimport glob\n\n# 'path/to/folder'를 여러분의 jpg 이미지가 저장된 폴더 경로로 교체하세요\nfolder_path = '/content/JPEG'\noutput_gif = os.path.join('/content/Animation', 'NDVI_animation.gif')\n\n# 폴더 내 모든 jpg 파일의 정렬된 목록을 가져옵니다\nfile_list = sorted(glob.glob(os.path.join(folder_path, '*.jpg')))\n\n# 이미지의 원하는 크기를 설정합니다\nwidth, height = 1000, 1000\n\n# 이미지를 읽어서 리스트에 저장합니다\nframes = []\nfor file in file_list:\n    frame = Image.open(file)\n\n    # 이미지 크기 조정\n    frame = frame.resize((width, height), Image.ANTIALIAS)\n\n    # 이미지에 흰색 배경 추가\n    background = Image.new('RGB', frame.size, (255, 255, 255))\n    background.paste(frame)\n    frame = background.convert('RGB')\n\n    # 이미지를 P 모드로 변환하고 전역 색상 테이블을 사용합니다\n    frame = frame.convert('P', palette=Image.ADAPTIVE, colors=256)\n    frames.append(frame)\n\n# 애니메이션 GIF로 프레임을 저장합니다\nif frames:\n    frames[0].save(\n        output_gif,\n        save_all=True,\n        append_images=frames[1:],\n        duration=500,  # 프레임 간 지속 시간(밀리초)을 설정합니다\n        loop=0,  # 루프 횟수를 설정합니다 (0은 무한을 의미합니다)\n        optimize=True,\n    )\nelse:\n    print(\"jpg 파일을 찾을 수 없습니다.\")\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n작업이 완료되면 화면에서 만들어진 지퍼 영상을 다운로드하여 시청할 수 있어요!\n\n![이미지](https://miro.medium.com/v2/resize:fit:1000/1*B8CQ1b8hgqEPrGj33oxrzQ.gif)\n\n구름이 가려져 있기 때문에 지도 내 몇 군데는 흰색 영역으로 표시됩니다. 또한 특정 날짜에 캘리포니아의 모든 영역을 커버하지 않아 일부 이미지가 잘려 나와 있을 수 있습니다. 프레임이 너무 빨리 변경되는 것 같다면, 각 프레임 간의 지속 시간을 조절할 수 있어요. 긴 스크립트를 작성한 후에는 이 아름다운 짧은 애니메이션을 즐기시기 바랍니다.\n\n## 📝 결론\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n요약하자면, 상상력을 데이터 시각화와 코딩을 통해 현실화하는 것은 때로는 꽤 많은 시간을 소요할 수 있습니다. 이 이야기에서는 50초짜리 비디오를 만들기 위해 300줄 이상의 코드를 작성했습니다. 상당한 시간 투자에도 불구하고, 그 노력은 가치가 있다고 믿습니다. 지도의 순차적인 표현은 숨겨진 패턴과 동적 변화를 드러내며 더 많은 탐구를 유도할 수 있습니다. 예를 들어, 이 이야기에서는 6월 이전의 NDVI 변동성 관측과 6월 중순부터 7월까지 안정화된 모습이 우리에게 추가적인 질문을 던지며 더 많은 조사와 답을 발견하도록 동기부여합니다.\n\n## 📚 참고 자료\n\nhttps://documentation.dataspace.copernicus.eu/APIs/OData.html\n\n- 📱 더 많은 상호작용이 있는 콘텐츠를 위해 다른 플랫폼에서 저와 연결하세요! LinkedIn, ResearchGate, Github, 그리고 Twitter.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n해당 링크를 통해 관련 게시물을 확인할 수 있습니다:","ogImage":{"url":"/TIL/assets/img/2024-07-14-ALongPythonScripttoMakeaShortVideoUsingGeospatialBigData_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-ALongPythonScripttoMakeaShortVideoUsingGeospatialBigData_0.png","tag":["Tech"],"readingTime":15},{"title":"상호작용 Python Plotly GIS 지도 제작을 위한 더 나은 GPT-4 프롬프트 작성 방법","description":"","date":"2024-07-14 19:41","slug":"2024-07-14-BetterGPT-4PromptingForInteractivePythonPlotlyGISMaps","content":"\n\n\n![TIL image 0](/TIL/assets/img/2024-07-14-BetterGPT-4PromptingForInteractivePythonPlotlyGISMaps_0.png)\n\n인터넷에는 역사적인 난파선 데이터를 포함한 데이터 세트에 대한 멋진 자료가 많이 있습니다.\n\n사용 가능한 데이터 세트에 대한 나의 지식 확장의 일환으로 매주 업데이트를 받는 소스 중 하나로 Data is Plural이 있습니다:\n\n![TIL image 1](/TIL/assets/img/2024-07-14-BetterGPT-4PromptingForInteractivePythonPlotlyGISMaps_1.png)\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 사이트는 흥미로운 데이터 세트에 관한 주간 뉴스레터를 제공합니다.\n\n가장 최근 버전 (2024년 7월 10일)에는 하버드 대학교에서 가져온 고대 바다 난파선에 관한 데이터 세트가 있습니다. 이 데이터 세트에는 기원전 1500년부터 기원후 1500년까지의 기록이 포함되어 있으며 지중해와 북유럽을 중심으로 하고 있습니다. 정말 멋져요!\n\n저는 이 데이터 세트를 GPT-4에 업로드하여 각 포인트 데이터를 지도에 배치하는 Python 코드를 생성할 수 있는지 궁금했습니다.\n\n답변은? 네, 가능합니다. 다만 주의해서 프롬프트를 할 필요가 있습니다. 여기서 저가 거친 단계를 안내해 드리겠습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 제네릭 GPT-4 프롬프트로 시작하기\n\n우선, GPT-4가 데이터 세트를 의미있는 방식으로 해석할 수 있는지 확인해보고 싶었습니다. GIS 지도 코드를 생성할 수 있는지 보기 위한 일반적인 프롬프트입니다.\n\nGPT-4에 대한 프롬프트: 첨부된 데이터 세트를 사용하여, 각 난파선을 지도상의 점으로 표시하는 전역 지도의 파이썬 코드를 제공해주세요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/TIL/assets/img/2024-07-14-BetterGPT-4PromptingForInteractivePythonPlotlyGISMaps_2.png)\n\n이거 그래프네요! 신기하게도 각 포인트들이 정확해요. 아래에 지도 레이어를 넣으면 정확하게 매칭돼요. 그런데, 이건 우리가 원하는 게 아니에요.\n\n첫 번째 제네릭 프롬프가 반 성공했어요. 여기서 더 구체적으로 알아보아야 해요.\n\nGPT-4에게 프롬프트를 보내면: \"이건 지도가 아니에요. 각 포인트를 실제 지도에 표시하는 파이썬 코드를 생성해 주세요.\"\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이번에는 GPT-4가 matplotlib 및 shapely 라이브러리를 사용하여 Python 코드를 생성했습니다. 결과는 다음과 같습니다:\n\n![이미지](/TIL/assets/img/2024-07-14-BetterGPT-4PromptingForInteractivePythonPlotlyGISMaps_3.png)\n\n이제 지도를 가지고 있지만, 이 지도는 완전히 정적입니다. 확대 및 축소가 불가능하며 상호 작용할 수 없습니다.\n\n또한 각 개별 점을 해석하기가 매우 어렵습니다. 점들이 주로 유럽에 있다는 것을 알 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 대화식 매핑을 위한 안내\n\n더 세부적으로 알아보고 GPT-4에게 상호작용 옵션을 요청해 봅시다.\n\nGPT-4에게 제시할 프롬프트: 저는 상호작용이 필요해요. 지도를 확대해서 볼 수 있고 각 데이터 포인트 위에 마우스를 올려 선박 이름과 화물을 표시할 수 있기를 원합니다.\n\nGPT-4는 툴팁을 사용하여 folium 지도를 만드는 파이썬 코드를 생성합니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/TIL/assets/img/2024-07-14-BetterGPT-4PromptingForInteractivePythonPlotlyGISMaps_4.png)\n\n와, 여기에는 더 많은 세부 정보가 있네요. 개별 난파선을 식별하는 데이터 포인트를 더 명확하게 볼 수 있습니다. 아쉽게도, 이 지도는 HTML 파일로 생성되어 있어 이상적이지는 않습니다. 보기에는 매우 멋지지만 약간 어색한 방법입니다. GPT-4가 필요한 것은 더 엄격한 안내입니다.\n\nGPT-4에게 알려줄 것: 이 방법은 좋아보이지 않아요. 이를 수행하는 데 왜 Plotly를 사용하지 않을까요?\n\nGPT-4의 응답: 정말 좋은 아이디어네요! 더 나은 상호 작용을 위해 Plotly를 사용하여 코드를 다시 작성합시다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport pandas as pd\nimport plotly.express as px\n\n# 데이터셋 불러오기\nfile_path = 'Geodatabase of Shipwrecks Hardard.csv'\nshipwreck_data = pd.read_csv(file_path)\n# 컬럼 헤더 수정\nshipwreck_data.columns = shipwreck_data.iloc[0]\nshipwreck_data = shipwreck_data.drop(0)\n# 유효한 좌표가 없는 행 제외\nshipwreck_data = shipwreck_data.dropna(subset=['Latitude', 'Longitude'])\n# 위도와 경도를 숫자로 변환\nshipwreck_data['Latitude'] = pd.to_numeric(shipwreck_data['Latitude'], errors='coerce')\nshipwreck_data['Longitude'] = pd.to_numeric(shipwreck_data['Longitude'], errors='coerce')\n# 변환 후 유효하지 않은 좌표가 있는 행 제외\nshipwreck_data = shipwreck_data.dropna(subset=['Latitude', 'Longitude'])\n# Plotly와 Mapbox를 사용하여 인터랙티브 맵 생성\nfig = px.scatter_mapbox(shipwreck_data,\n                        lat='Latitude',\n                        lon='Longitude',\n                        hover_name='NAME',\n                        hover_data={'Longitude': False, 'Latitude': False, 'Cargo_1': True},\n                        title='Global Map of Shipwrecks',\n                        mapbox_style='carto-positron')  # Using mapbox\n# 더 나은 모양을 위해 레이아웃 업데이트\nfig.update_traces(marker=dict(color='red', size=10))  # 색상 및 크기 지정\nfig.update_layout(\n    mapbox=dict(\n        accesstoken='your_mapbox_access_token', \n        center={'lat': 44, 'lon': 18},  # 유럽 지도 중심으로 설정\n        zoom=4\n    ),\n    margin=dict(l=0, r=0, t=0, b=0),\n    title_font_size=24,\n    font=dict(size=14)\n)\n# 인터랙티브 맵 표시\nfig.show()\n```\n\n그리고 이 코드는 정말 잘 작동합니다.\n\n결과:\n\n<img src=\"/TIL/assets/img/2024-07-14-BetterGPT-4PromptingForInteractivePythonPlotlyGISMaps_5.png\" />\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n멋지네요, 이제 조금씩 진행 중이네요. 그리고 각 지점 데이터 위에 마우스를 올려서 난파선 이름과 수송품 정보(알려진 경우)를 찾을 수 있어요:\n\n![image](/TIL/assets/img/2024-07-14-BetterGPT-4PromptingForInteractivePythonPlotlyGISMaps_6.png)\n\nGPT-4는 실제로 지도에 GIS 지점 데이터를 표시하는 Python 코드를 효과적으로 생성하는 데 활용될 수 있어요.\n\n이 예제에서 원하는 결과를 생성하도록 GPT-4에 제공해야 하는 정보는 다음과 같아요:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 데이터 세트를로드하고 열 헤더를 수정하십시오.\n- 유효한 좌표가없는 행을 필터링하십시오.\n- 위도와 경도를 숫자 값으로 변환하십시오.\n- Plotly의 scatter_mapbox 함수를 사용하여 대화 형 지도를 만듭니다.\n- 각 포인트의 색상을 빨간색으로 설정하고 크기를 5픽셀로 설정하십시오.\n- 지중해로 확대 된지도를 표시하십시오.\n- Mapbox 타일에 'carto-positron' 스타일을 사용하십시오.\n- 위도 34 및 경도 18을 중심으로하고 줌 레벨이 4 인 맵을 센터에 배치하십시오.\n- 코드의 적절한 위치에 Mapbox 액세스 토큰을 추가하십시오.\n\n모두입니다.\n\n# 요약\n\nGPT-4는 Python 코드를 간단한 CSV 파일에서 GIS 포인트 데이터를지도에 표시하는데 쉽게 생성할 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이거 조심해서 잘 만들어야 해. 이 LLM을 최적화하려면 좋은 결과를 얻을 때까지 여러 번 시도해야 할 수도 있어.\n\nGPT-4를 광범위하게 활용하면서, 최적의 결과를 찾기 전에 여러 가지 방법을 고려할 수 있음을 알았어. GPT-4에게 가능한 접근법을 묻는 것이 좋을 뿐 아니라 (이런 예시처럼) 더 나은 방법을 알고 있다면, GPT-4에게 사용하도록 명확하게 요청해.\n\n그리고 LLM 프롬프팅 작업을 할 때 중요한 점은, GPT-4는 결과물에 변화를 주는 방식으로 설계되었기 때문에, 당신이 프롬프트로 받는 코드가 여기서 보여주는 것과 정확히 일치하지 않을 수 있다는 거야.\n\n코멘트를 남겨서 프롬프팅이 어떻게 진행되었는지 알려줘!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 이 유형의 이야기가 당신의 취향이고 저를 작가로 지원하고 싶다면, 제 Substack에 가입해주세요.\n\nSubstack에서는 매주 두 번 뉴스레터와 다른 플랫폼에서는 찾을 수 없는 기사들을 발행하고 있어요.","ogImage":{"url":"/TIL/assets/img/2024-07-14-BetterGPT-4PromptingForInteractivePythonPlotlyGISMaps_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-BetterGPT-4PromptingForInteractivePythonPlotlyGISMaps_0.png","tag":["Tech"],"readingTime":8},{"title":"튜토리얼 그만 이렇게 프로그래밍을 배워보세요","description":"","date":"2024-07-14 19:40","slug":"2024-07-14-StopDoingTutorialsLearnProgrammingLikeThis","content":"\n\n마크다운 형식으로 테이블 태그를 변경해주세요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그럭저럭요. 처음 프로그래밍 시험을 볼 때, 제가 코딩하는 방법을 모른다는 것을 깨달았어요. 컴퓨터를 바라보며 처음 몇 줄을 어떻게 작성할지 고민했죠.\n\n이게 요즘의 학습 과정을 현실적으로 알렸다는 거야.\n\n그래서 제 경험처럼 하지 마세요. 대신 이렇게 해보세요.\n\n# 코딩을 효과적으로 배우는 방법?\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n효과적으로 학습한다는 것이 무엇을 의미하는지부터 시작해 봅시다.\n\n학습은 단기 기억에서 장기 기억으로 정보를 연결하는 것입니다. 예를 들어 다시 읽거나 다시 시청하는 것은 공부하는 개념에 대한 어느 정도의 숙련도를 제공하지만, 해당 정보를 단기 기억(작동 중인 기억)에 \"보관\"합니다.\n\n이것이 당신이 아직 배우지 않은 것을 배운 것으로 생각하는 이유입니다.\n\n이것은 무언가를 배우는 비효과적인 방법입니다. 반면, 예를 들어 코딩을 효과적으로 배우기 위해서는 공부하는 정보를 회상해야 합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다시 말해, 스스로를 시험하고 배운 것을 적용해야 합니다.\n\n- 악기를 배우고 싶다면 악기를 연습하십시오.\n- 축구를 배우고 싶다면 축구를 연습하세요.\n- 차를 운전하는 법을 배우고 싶다면 차를 운전해 보세요.\n- 프로그래밍을 배우고 싶다면 코딩하세요.\n\n# 운전을 배우는 것은 코딩을 배우는 것과 같다\n\n몇 주 전, 처음으로 차를 운전하는 법을 익혔습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n첫 수업 전에는 몇 개의 비디오를 보고 자동차가 어떻게 작동하는지 및 운전하는 방법에 대한 기본을 읽었어요. 물론, 실제 차와 연습하지 않으면 아무 소용이 없었죠.\n\n악기를 배울 때도 동일한 원리가 적용돼요.\n\n기타를 치는 법, 음계, 음표 등 기술적인 내용을 배울 수 있어요. 기본을 습득한 후 쉬운 즐겨듣는 노래 몇 곡을 배워봐요. 그 순간, 당신은 기억에 접목하는 중이에요.\n\n이것이 효과적인 학습이에요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 예시들은 까부러운 것 같지만, 이렇게 학습하는 많은 학생을 만난 적이 있어요. 그들은 앉아서 강의를 보며, 다시 보며, 어떻게든지 프로그래밍을 배워나가죠.\n\n여기서 배울 점은 코딩 없이는 프로그래밍을 배울 수 없다는 것이에요.\n\n## 초보자를 위한 몇 가지 프로젝트\n\n- 퀴즈 코드 작성하기.\n- 뱀 게임 코드 작성하기.\n- 데스크탑 정리 프로그램.\n- Streamlit을 이용한 데이터 분석 앱.\n- 호텔 데이터 웹 스크래핑 (고급).\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n주말에 보호하 실력을 동기화할 수 있는 5가지 파이썬 프로젝트를 확인해보세요 :)\n\n마지막으로, 정보 회수 실력을 연습하는 몇 가지 팁을 공유하겠습니다. 당신이 공부하는 어떤 주제에든지 이 팁을 적용해보세요 :)\n\n## 팁 1: 자유 회상\n\n- 책을 닫거나 창을 변경하세요.\n- 지금까지 배운 내용을 회상하세요(책을 보지 않고).\n- 옳은 답변에 대한 피드백을 받으세요.\n- 자신이 알고 있는 것과 모르는 것을 확인하세요.\n- 반복하세요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 팁 2: 플래시카드\n\n- 당신의 자료로부터 플래시카드를 만드세요.\n- 정답을 보지 않고 질문에 솔직하게 대답하세요.\n- 스스로를 테스트하고 피드백을 받으세요.\n- 알고 있는 것과 모르는 것을 확인하세요.\n- 반복하세요.\n\n프로젝트가 학습에 중요하긴 하지만, 알고리즘이나 논리적 사고와 같은 기술적인 것을 소홀히하지 마세요.\n\n그것이 또 다른 내 실수였어요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n학습 여정에서 행운을 빕니다!\n\n# 도와드릴 수 있는 방법:\n\n- 내 새로운 무료 뉴스레터 'The Super Learning Lab'을 구독하세요.\n- 곧 나올 무료 학습 전자책과 이메일 코스를 기대해 주세요!\n\n![image](/TIL/assets/img/2024-07-14-StopDoingTutorialsLearnProgrammingLikeThis_1.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 내 최고의 학습 기사:\n\n- Ultralearning으로 모든 것 배우기\n- 초간단 정리: 9가지 울트라러닝 원칙\n- 울트라러닝으로 무료로 2개월만에 독일어 배우는 법\n- 학습을 당신의 슈퍼파워로 만드세요\n- 이렇게 하지 않고 책을 읽는 것을 그만하세요\n\n안녕,\n\nAxel","ogImage":{"url":"/TIL/assets/img/2024-07-14-StopDoingTutorialsLearnProgrammingLikeThis_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-StopDoingTutorialsLearnProgrammingLikeThis_0.png","tag":["Tech"],"readingTime":5},{"title":"TypeScript 네트워크 서버 구축법 Nodejs 멀티스레드 함수 작성하기","description":"","date":"2024-07-13 20:38","slug":"2024-07-13-HowToWriteATypescriptNodeJSMulti-ThreadedFunction","content":"\n\n\n![링크](/TIL/assets/img/2024-07-13-HowToWriteATypescriptNodeJSMulti-ThreadedFunction_0.png)\n\nTypeScript과 Node.js는 단일 스레드 및 이벤트 기반 모드에서 작동합니다. 그러나 Node.js에는 특정 시나리오를 위해 멀티 스레딩을 가능하게 하는 Worker Threads 모듈이 제공됩니다. Worker Threads 모듈을 사용하면 TypeScript 코드를 병렬로 실행하여 필요할 때 여러 스레드를 활용할 수 있습니다.\n\n# Node.js에서 멀티 스레딩\n\n단일 스레드 형식 — 기본적으로 Node.js는 TypeScript 코드를 실행하는 데 단일 스레드를 사용합니다. 이 설계는 여러 스레드를 관리하는 복잡성을 피하므로 비동기 작업을 간단하게 처리할 수 있습니다.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n워커 스레드 모듈 - 워커 스레드 모듈은 Node.js의 기능으로, 개발자가 메인 스레드와 별도로 추가 스레드를 생성할 수 있게 합니다. 이러한 워커 스레드는 TypeScript 코드를 독립적으로 실행하여 작업을 병렬로 처리할 수 있는 방법을 제공합니다.\n\n멀티 스레딩의 사용 사례 - 멀티 스레딩은 CPU 집중형 계산이나 병렬 비동기 작업과 같이 특정 작업을 분할하고 동시에 실행할 수 있는 시나리오에서 유용합니다. 이를 통해 여러 스레드의 처리 능력을 활용하여 응용 프로그램의 전반적인 성능을 향상시킬 수 있습니다.\n\n예제로 넘어가기 전에.... \n\n# 멀티 스레딩에 대한 추가 고려 사항\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n많은 이유로 멀티스레딩을 피하고 Node.js의 싱글 스레드 특성을 활용하는 것이 좋습니다. 전진하기 전에 고려해야 할 몇 가지 중요한 부분이 있습니다.\n\n스레드 관리 오버헤드: 멀티스레딩은 특정 시나리오에서 성능을 향상시킬 수 있지만, 스레드 관리와 관련된 오버헤드도 동반됩니다. 개발자들은 해당 상황에서 멀티스레딩의 이점이 해당 사용 사례에서의 오버헤드를 상회하는지 신중히 검토해야 합니다.\n\n동시성과 동기화: 여러 스레드로 작업할 때, 개발자들은 동시성과 동기화와 관련된 문제들을 다뤄야 합니다. 이는 공유 리소스를 관리하고 경쟁 조건을 방지하며 스레드 간 데이터 일관성을 보장하는 것을 포함합니다.\n\n확장성: 멀티스레딩은 멀티 코어 프로세서에서 사용 가능한 리소스를 효율적으로 활용할 수 있도록 해 확장성을 향상시킬 수 있습니다. 그러나 멀티스레드 애플리케이션을 확장하기 위해서는 부하 분산 및 리소스 경합과 같은 요소들을 신중히 고려하여 최적의 성능을 달성해야 합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n디버깅 복잡성: 멀티스레드 응용 프로그램을 디버깅하는 것은 단일 스레드 응용 프로그램보다 얽힌 스레드 상호작용과 잠재적 동시성 문제로 인해 더 도전적일 수 있습니다. 개발자는 쓰레딩 관련 문제를 효과적으로 진단하고 해결하기 위해 전문적인 디버깅 도구와 기술을 사용해야 할 수도 있습니다.\n\n자원 관리: 멀티스레드 응용 프로그램은 단일 스레드 응용 프로그램보다 더 많은 시스템 자원(예: 메모리 및 CPU)을 소비할 수 있습니다. 개발자는 성능 저하와 잠재적 병목 현상을 피하기 위해 자원 사용을 주의 깊게 관리해야 합니다.\n\n잠재적 함정: 멀티스레드로 인해 성능 이점을 얻을 수 있지만, 데드락, 라이브락 및 스레드 기아와 같은 잠재적 함정이 소개될 수도 있습니다. 개발자는 이러한 개념을 이해하고 응용 프로그램 신뢰도와 성능에 미치는 영향을 완화하기 위해 최선의 방법을 사용해야 합니다.\n\n다음은 Worker Threads를 사용한 TypeScript 예시를 제공하겠습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```typescript\nimport { Worker, isMainThread, parentPort } from 'worker_threads';\n\nfunction runWorkerThread() {\n  if (isMainThread) {\n    // 이것은 메인 스레드입니다\n\n    // 새로운 워커 스레드를 생성합니다\n    const worker = new Worker(__filename);\n\n    // 워커 스레드로부터 메시지를 수신합니다\n    worker.on('message', (result: any) => {\n      console.log('워커로부터 결과:', result);\n    });\n\n    // 워커 스레드로 데이터를 보냅니다\n    worker.postMessage({ data: '메인 스레드로부터 안녕하세요!' });\n  } else {\n    // 이것은 워커 스레드입니다\n\n    // 메인 스레드로부터 메시지를 수신합니다\n    parentPort?.on('message', (message: any) => {\n      console.log('메인 스레드로부터 메시지:', message);\n\n      // 일부 무거운 계산을 수행합니다\n      const result = performHeavyComputation();\n\n      // 결과를 다시 메인 스레드로 보냅니다\n      parentPort?.postMessage(result);\n\n      // 워커 스레드를 종료합니다\n      parentPort?.close();\n    });\n\n    function performHeavyComputation() {\n      // 무거운 계산을 시뮬레이션합니다\n      let result = 0;\n      for (let i = 0; i < 1e9; i++) {\n        result += i;\n      }\n      return result;\n    }\n  }\n}\n\n// 워커 스레드 실행을 위해 함수를 호출합니다\nrunWorkerThread();\r\n```\n\n이 예시는 메인 스레드와 워커 스레드로 구성된 멀티 스레드 설정을 보여줍니다. 무거운 계산은 워커 스레드에서 수행되고, 그 결과가 메인 스레드로 보내집니다.\n\n워커 스레드를 생성하고 관리하는 로직은 runWorkerThread 함수 내에 캡슐화되어 있습니다. 워커 스레드를 시작하려면 이 함수를 필요할 때 호출할 수 있습니다.\n\n본 내용을 즐기셨고 이러한 노력을 지원하고 싶으시다면 다음 링크를 방문해주세요: [https://ko-fi.com/jacobmacinnis](https://ko-fi.com/jacobmacinnis)\n","ogImage":{"url":"/TIL/assets/img/2024-07-13-HowToWriteATypescriptNodeJSMulti-ThreadedFunction_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-HowToWriteATypescriptNodeJSMulti-ThreadedFunction_0.png","tag":["Tech"],"readingTime":5},{"title":"튜토리얼 Typescript로 배우는 함수형 프로그래밍 실전 적용법","description":"","date":"2024-07-13 20:37","slug":"2024-07-13-TutorialFunctionalProgramminginActionwithTypescript","content":"\n\n\n![Tutorial Image](/TIL/assets/img/2024-07-13-TutorialFunctionalProgramminginActionwithTypescript_0.png)\n\n# 소개\n\n내 커리어 초반에 가르쳐진 한 가지는 JavaScript가 객체지향 언어가 아니라는 것이었습니다. 상속보다는 합성을 사용하고 함수(클래스가 아닌)를 일등 시민으로 다루는 것이 더 나은 접근이라는 것이죠. 전체 스택 역할을 하는 Scala가 백엔드 서비스로 사용되는 회사에 들어가니 정말 놀랍더군요. 프로그래밍에 대한 내가 알고 있던 것을 다시 생각해야 했고 Martin Odersky의 목소리를 듣는 데 많은 시간을 보내야 했습니다. 하지만 익숙해지고 나면 한 번도 되돌아보지 않았습니다. 그 이후로 프론트엔드를 위한 몇 가지 FP 트릭을 발견했는데 이를 공유하고 싶습니다.\n\n이 자습서에서는 RxJS, fp-ts 및 io-ts라는 3가지 라이브러리와 그들과 관련된 함수형 프로그래밍 패러다임을 다룰 것입니다. io-ts의 피어 종속성인 fp-ts를 알아야 합니다. \n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# FP 리프레셔\n\n함수형 프로그래밍은 대학 대수 수업에서 순수 함수에 대한 강의를 떠올리게 합니다. 출력이 제공된 입력에만 의존하는 것이 이를 의미합니다. 이는 데이터의 변이를 피하고 \"부작용\"이 없도록 하는 것으로 더 예측 가능한 코드를 작성할 수 있습니다. 이것은 불변 변수의 값이 한 번 설정되면 나중에 변경할 수 없다는 점 때문에 때로는 귀찮음이 될 수도 있습니다.\n\nmap과 같은 고차 함수는 한 개 이상의 함수를 인수로 받아 새로운 함수를 반환하는데 함수형 프로그래밍에서 기본적인 역할을 합니다. 재사용성과 모듈성을 통해 기반 함수를 설정하고 확장해 나가는 데 더 빠르게 이동할 수 있습니다. 객체 지향 프로그래밍 (OOP)은 데이터 변환 프로세스를 다룰 때 복잡해지는 반면, 싱글톤, 정적 함수 또는 정적 변수를 사용해야 하는지 여부에 대한 문제가 발생할 수 있는 반면, 함수형 프로그래밍은 평이한 함수의 사용을 옹호함으로써 이러한 시나리오를 단순화합니다. 말 그대로 모든 것이 함수입니다\n\n<img src=\"/TIL/assets/img/2024-07-13-TutorialFunctionalProgramminginActionwithTypescript_1.png\" />\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# RxJS\n\n이 라이브러리는 특히 클래스 간에 상태 \"반응성\"을 제공할 수 있는 반응형 프로그래밍 라이브러리로서 인기가 있습니다. 이 라이브러리는 JS의 어떤 값의 변경에 반응하기 위해 채울 수 있는 컨테이너 또는 구조물로 생각할 수 있습니다. 아마도 예상하신 대로, React와 아주 잘 작동하며 훅을 위한 일등 지원을 제공합니다. RxJS의 주요 개념들 중 일부는 공식 문서에서 쉽게 찾을 수 있지만, 여러분의 편의를 위해 여기에 간단히 기재하였습니다:\n\n- Observables: RxJS는 시간이 지남에 따라 값 스트림을 방출하는 함수인 Observables 개념을 중심으로 구축되었습니다. Observables는 함수형 반응형 프로그래밍의 핵심 개념이며, 비동기 작업을 합성 및 선언적인 방식으로 표현할 수 있습니다.\n- Operators: RxJS는 Observables을 변환, 필터링, 결합 및 조작하는 데 사용할 수 있는 다양한 방식의 연산자를 제공합니다. Operators는 하나 이상의 observables을 입력으로 사용하고 새로운 observable을 출력으로 반환하는 순수 함수입니다.\n- 함수형 프로그래밍의 원칙들: RxJS는 불변성(한 번 생성되면 변경할 수 없음), 조합성(큰 애플리케이션을 위한 작은 구성 요소), 참조 투명성(동일한 입력은 몇 번 호출되었든 동일한 출력을 생성함)과 같은 많은 함수형 프로그래밍 원칙을 따릅니다. Observables 및 연산자는 부작용이 없는 순수 함수이며, 복합하여 복잡한 비동기 작업을 만들 수 있는 선언적인 방식으로 결합될 수 있습니다.\n\n# fp-ts\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 라이브러리는 RxJS만큼 인기가 없고 조금 더 복잡합니다. 이 라이브러리는 사용자가 숫자뿐만 아니라 어떤 데이터 유형이든 연결할 수 있는 미리 작성된 함수를 제공합니다.\n\n특징\n\n- 대수적 데이터 유형: fp-ts는 Option, Either, Task 등의 대수적 데이터 유형을 제공하여 복잡한 데이터 구조를 안전하고 조립 가능한 방식으로 표현할 수 있습니다. 대수적 데이터 유형은 함수형 프로그래밍의 핵심 개념으로, null/undefined 오류 및 기타 일반적인 런타임 오류를 피하는 데 도움이 됩니다.\n- 타입 클래스: fp-ts는 Functor, Applicative, Monad 등의 타입 클래스를 제공하여 필요한 인터페이스를 구현한 모든 데이터 유형과 작동하는 일반 함수를 정의할 수 있습니다. 타입 클래스는 추상화와 재사용을 위한 강력한 도구이며, 보다 일반적이고 조립 가능한 코드를 작성하는 데 도움이 됩니다.\n- 함수형 프로그래밍 원칙: fp-ts는 불변성, 조합성, 참조 투명성 등 많은 함수형 프로그래밍 원칙을 따릅니다. 대수적 데이터 유형과 타입 클래스는 부작용이 없는 순수 함수로, 안전하고 조립 가능한 방식으로 결합하여 복잡한 프로그램을 만들 수 있습니다.\n\n# io-ts\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 라이브러리는 3개 중 가장 작은 라이브러리이며 TypeScript 코드에 입력 및 출력 도우미를 제공합니다. 일반적인 사용 사례는 API 호출을 보내고 받는 것이지만 오디오 및 비디오와 같은 것들에도 유용합니다.\n\n특징\n\n- 런타임 유형 유효성 검사: io-ts는 데이터 구조에 대한 런타임 유형을 정의하는 방법을 제공하며 정의된 유형과 일치하는 데이터를 자동으로 유효성 검사하고 디코딩할 수 있습니다. 런타임 유형 유효성 검사는 런타임 오류를 방지하고 데이터 일관성을 보장하는 강력한 도구입니다.\n- 유형 추론: io-ts는 런타임 유형 정의에서 TypeScript 유형을 추론할 수 있어 IDE에서 중복되는 유형 주석을 작성하지 않고도 유형 안전성 및 자동완성을 얻을 수 있습니다.\n- 함수형 프로그래밍 원칙: io-ts는 불변성, 합성성, 참조 투명성과 같은 많은 함수형 프로그래밍 원칙을 따릅니다. 런타임 유형 정의는 부작용이 없는 순수 함수이며 선언적 방식으로 조합하고 재사용할 수 있습니다.\n\n# 리액트로 데모하기\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모든 세 가지 라이브러리를 사용하는 일반적인 사례는 API 호출을 필요 이상으로 복잡하게 만드는 것입니다. 우리가 일반적인 React.js 컴포넌트에서 어떻게 작동하는지 살펴봅시다.\n\n```js\nimport React, { useState, useEffect } from 'react';\nimport { Observable } from 'rxjs';\nimport { pipe } from 'fp-ts/lib/pipeable';\nimport { map, fold } from 'fp-ts/lib/Either';\nimport * as t from 'io-ts';\n\nconst ResponseType = t.type({\n  data: t.string,\n});\n\nconst fetchData = (): Observable<t.TypeOf<typeof ResponseType>> => {\n  return Observable.create(({ error, next, complete }) => {\n    fetch('https://example.com/api/data')\n      .then((response) => response.json())\n      .then((data) => {\n        const result = ResponseType.decode(data);\n        pipe(\n          result,\n          fold(\n            error,\n            next,\n          ),\n        );\n        complete();\n      })\n      .catch(error);\n  });\n};\n\nconst MyComponent = () => {\n  const [data, setData] = useState({});\n\n  useEffect(() => {\n    const subscription = fetchData().subscribe(({ data }) => setData(data));\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, []);\n\n  return <div>{data}</div>;\n};\n```\n\n이 예제에서는 io-ts를 사용하여 예상되는 API 응답의 형태를 나타내는 런타임 타입 ResponseType를 정의합니다. 그런 다음 API 호출을 수행하고 응답의 Observable을 반환하는 fetchData 함수를 정의합니다.\n\nReact 컴포넌트에서 useState 훅을 사용하여 검색한 데이터를 추적합니다. 그런 다음 useEffect 훅을 사용하여 fetchData에 의해 반환된 Observable을 구독합니다. 컴포넌트가 마운트될 때 Observable을 구독하고 데이터가 도착하면 검색된 데이터로 상태를 업데이트합니다. 또한 컴포넌트가 마운트 해제될 때 Observable을 구독 취소하여 메모리 누수를 방지합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nfp-ts의 pipe 함수를 사용하여 API 응답의 디코딩과 결과를 Either로 폴딩하는 작업을 조합합니다. 이를 통해 디코딩 오류와 API 오류를 기능적이고 조합 가능한 방식으로 처리할 수 있습니다.\n\n이제 더 고급 사용 사례를 살펴보고 GraphQL API와 함께 웹 데이터 테이블을 표시하는 방법을 살펴봅시다:\n\n```js\nimport React, { useState, useEffect } from 'react';\nimport { pipe } from 'fp-ts/lib/pipeable';\nimport { map, fold } from 'fp-ts/lib/Either';\nimport * as t from 'io-ts';\nimport { ApolloClient, InMemoryCache, gql } from '@apollo/client';\nimport { Observable } from 'rxjs';\n\nconst ResponseType = t.type({\n  data: t.type({\n    users: t.array(\n      t.type({\n        id: t.string,\n        name: t.string,\n        email: t.string,\n        phone: t.string,\n      }),\n    ),\n  }),\n});\n\nconst fetchData = (): Observable<t.TypeOf<typeof ResponseType>> => {\n  const client = new ApolloClient({\n    uri: 'https://mygraphqlapi.com/graphql',\n    cache: new InMemoryCache(),\n  });\n\n  const query = gql`\n    query {\n      users {\n        id\n        name\n        email\n        phone\n      }\n    }\n  `;\n\n  return Observable.create(({ error, next, complete }) => {\n    client\n      .query({ query })\n      .then(({ data }) => {\n        const result = ResponseType.decode(data);\n        pipe(\n          result,\n          fold(\n            error,\n            next,\n          ),\n        );\n        complete();\n      })\n      .catch(error);\n  });\n};\n\nconst UserTable = () => {\n  const [users, setUsers] = useState([]);\n\n  useEffect(() => {\n    const subscription = fetchData().subscribe(({ data: { users } }) => setUsers(users));\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, []);\n\n  return (\n    | 표\n    | 머리글\n    | 승객\n    | 별명\n    | 전자 메일\n    | 전화번호\n    | ------\n    | ----------\n    | -------- \n    | {users.map(({ id, name, email, phone }) => (\n      <tr key={id}>\n        <td>{id}</td>\n        <td>{name}</td>\n        <td>{email}</td>\n        <td>{phone}</td>\n      </tr>\n    ))}\n    | \n  );\n};\n```\n\n이 예제에서는 우리의 GraphQL 응답의 예상 모양을 나타내는 io-ts를 사용하여 런타임 유형인 ResponseType을 정의합니다. ApolloClient를 사용하여 GraphQL API에서 데이터를 가져오고 응답의 Observable을 반환하는 fetchData 함수를 정의합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리의 React 컴포넌트에서는 useState 훅을 사용하여 가져온 데이터를 추적합니다. 그런 다음 useEffect 훅을 사용하여 fetchData에 의해 반환된 Observable을 구독합니다. 컴포넌트가 마운트될 때 Observable을 구독하고 데이터가 도착하면 상태를 업데이트합니다. 또한 컴포넌트가 마운트 해제될 때 Observable을 구독해제하여 메모리 누수를 방지합니다.\n\n마지막으로, 가져온 데이터를 사용하여 웹 데이터 테이블을 렌더링합니다. 사용자 배열을 매핑하고 각 사용자에 대한 행을 렌더링하여 ID, 이름, 이메일 및 전화번호를 표시합니다.\n\n# 결론\n\n제 전문 경력의 대부분에서 프로젝트의 핵심 라이브러리와 기술 스택은 일반적으로 제 입성 전에 구현되었습니다. 새로 합류한 팀에게 다른 방향으로 이주할 것을 설득하는 것은 거의 불가능할 수 있습니다. 이미 있는 것에 헌신하고 나아가야 합니다. 그러나 운이 좋으면 JS 코드베이스에 함수형 프로그래밍 패턴과 라이브러리를 소개할 수있는 경우가 있습니다. 그렇게 하면 훨씬 더 행복할 수 있습니다! 프로그래밍 실수로 인해 버그가 발생할 가능성이 적어진다고 (제 의견으로는) 확신합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안녕하세요! 궁금한 점, 의견, 뜨거운 이야기가 있으면 아래에 남겨주세요!","ogImage":{"url":"/TIL/assets/img/2024-07-13-TutorialFunctionalProgramminginActionwithTypescript_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-TutorialFunctionalProgramminginActionwithTypescript_0.png","tag":["Tech"],"readingTime":10},{"title":"TypeScript의 Record 타입 완벽 마스터하기","description":"","date":"2024-07-13 20:36","slug":"2024-07-13-MasteringTypeScriptsRecordType","content":"\n\n\n![Record Type](/TIL/assets/img/2024-07-13-MasteringTypeScriptsRecordType_0.png)\n\nTypeScript의 Record 타입은 우리가 key-value 쌍 타입을 정의하는 데 도움이 되는 매우 유용한 도구입니다. 이 기사에서는 Record 타입의 다양한 응용 시나리오를 탐구하고, 코드 품질과 유지 관리성을 향상시킬 수 있는 방법에 대해 알아보겠습니다.\n\n# 1. Record Type이란 무엇인가요?\n\nRecord 타입은 TypeScript에서 내장된 일반적인 제네릭 타입으로, 키와 값이 지정된 타입인 객체 타입을 구성하는 데 사용됩니다. 다음과 같이 정의됩니다:\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n유형 레코드`K, T`는 그 키가 유형 K이고 값이 유형 T인 개체를 나타냅니다. 간단한 예제를 살펴봅시다:\n\n유형 사용자 = {\n  이름: 문자열;\n  나이: 숫자;\n};\n\n유형 사용자레코드 = 레코드 <문자열, 사용자>;\n\n상수 사용자: 사용자레코드 = {\n  사용자1 : { 이름: \"앨리스\", 나이: 25 },\n  사용자2 : { 이름: \"밥\", 나이: 30 },\n};\n\n이 예제에서 UserRecord는 키가 문자열 형식이고 값이 사용자 형식인 개체를 나타냅니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 2. 레코드와 튜플의 차이\n\n레코드와 튜플은 TypeScript에서 객체 구조를 정의하는 데 사용되는 도구입니다. 그러나 사용 용도와 특성이 다릅니다.\n\n- 레코드: 키-값 쌍을 정의하는 데 사용되며, 키와 값의 타입이 임의적일 수 있습니다.\n- 튜플: 고정된 길이와 타입의 배열을 정의하는 데 사용됩니다.\n\n## 코드 예제:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\ntype UserTuple = [string, number]; // 튜플 타입\n\nconst userTuple: UserTuple = [\"Alice\", 25]; // 유효함\n// const invalidUserTuple: UserTuple = [25, \"Alice\"]; // 오류: 타입 불일치\n\ntype UserRecord = Record<string, number>;\n\nconst userRecord: UserRecord = {\n  Alice: 25,\n  Bob: 30,\n};\n\n# 3. Record과 Map의 차이점\n\nRecord와 Map은 모두 키-값 쌍을 저장하는 데 사용될 수 있지만, 중요한 차이점이 있습니다:\n\n- Record: 컴파일 시간에 타입 체크를 위해 사용되는 타입 정의 도구.\n- Map: ES6에서 소개된 데이터 구조로, 런타임에서 키-값 쌍을 저장하는 데 사용됨.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 코드 예시:\n\n// Record를 사용\ntype UserAges = Record<string, number>;\n\nconst userAges: UserAges = {\n  Alice: 25,\n  Bob: 30,\n};\n\n// Map 사용\nconst userAgeMap = new Map<string, number>();\nuserAgeMap.set(\"Alice\", 25);\nuserAgeMap.set(\"Bob\", 30);\n\nconsole.log(userAgeMap.get(\"Alice\")); // 결과: 25\n\n# 4. 모든 경우 다루기\n\nRecord 타입을 사용할 때, 모든 가능한 경우를 다루도록 하여 모든 경우에 대해 처리하도록 할 수 있습니다. 특히 유니언 타입을 다룰 때 유용합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 코드 예시:\n\ntype Status = \"success\" | \"error\" | \"loading\";\n\nconst statusMessages: Record<Status, string> = {\n  success: \"작업이 성공적으로 완료되었습니다\",\n  error: \"오류가 발생했습니다\",\n  loading: \"로딩 중...\",\n};\n\n// getStatusMessage 함수를 사용할 때 모든 경우의 수를 처리하도록 보장\nfunction getStatusMessage(status: Status): string {\n  return statusMessages[status];\n}\n\n이 예제에서 Record`Status, string`은 statusMessages 객체에서 모든 가능한 Status 값이 처리되도록 보장하며, getStatusMessage 함수에서 각 상태 메시지에 안전하게 접근할 수 있게 합니다.\n\n# 5. 제네릭 애플리케이션에서 타입 체킹 강제화\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nRecord 유형은 일반 프로그래밍에서 매우 유용하며 키와 값 사이의 일관성을 보장하고 유형 검사를 강제할 수 있게 해줍니다.\n\n## 코드 예시:\n\nfunction createRecord<K extends string, T>(keys: K[], value: T): Record<K, T> {\n  const record: Partial<Record<K, T>> = {};\n  keys.forEach(key => {\n    record[key] = value;\n  });\n  return record as Record<K, T>;\n}\n\nconst record = createRecord([\"Alice\", \"Bob\"], 25);\nconsole.log(record); // 결과: { Alice: 25, Bob: 25 }\n\n이 예시에서 createRecord 함수는 키 배열과 값을 가져와 Record 유형을 사용하여 생성된 객체의 키와 값이 일관되도록 보장합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 6. 선택적 타입 매핑을 위해 Pick 타입과 Record 사용하기\n\n특정 속성만 포함된 객체 타입을 만들기 위해 Pick과 Record 타입을 결합할 수 있습니다.\n\n## 코드 예시:\n\ninterface User {\n  id: number;\n  name: string;\n  age: number;\n  email: string;\n}\n\ntype UserInfo = Pick<User, \"id\" | \"name\">;\n\ntype UserInfoRecord = Record<string, UserInfo>;\n\nconst userInfo: UserInfoRecord = {\n  user1: { id: 1, name: \"Alice\" },\n  user2: { id: 2, name: \"Bob\" },\n};\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 예시에서는 사용자 인터페이스에서 id와 name 속성을 선택하기 위해 Pick 타입을 사용하고, Record 타입을 사용하여 이러한 속성을 포함하는 객체 타입을 생성합니다.\n\n# 7. Record를 사용한 동적 Key-Value 사전 구현\n\nRecord 타입은 동적 키-값 사전을 구현하기에 적합하며, 특히 동적 키와 값이 필요할 때 유용합니다.\n\n## 코드 예시:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\ntype Dictionary<T> = Record<string, T>;\n\nconst stringDictionary: Dictionary<string> = {\n  key1: \"value1\",\n  key2: \"value2\",\n};\n\nconst numberDictionary: Dictionary<number> = {\n  key1: 1,\n  key2: 2,\n};\n\n이 예시에서 Dictionary 타입은 어떤 타입의 key-value 쌍을 저장하는 데 사용할 수 있어 코드를 더 유연하고 일반적으로 만들어줍니다.\n\n# 8. Record와 함께 ReadOnly 사용하기\n\nReadOnly와 Record 타입을 함께 사용하여 수정할 수 없는 key-value 쌍 객체를 만들 수 있습니다. 이를 통해 객체의 프로퍼티가 수정될 수 없도록 보장합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 코드 예시:\n\ntype ReadOnlyUserRecord = Readonly<Record<string, User>>;\n\nconst readOnlyUsers: ReadOnlyUserRecord = {\n  user1: { name: \"Alice\", age: 25 },\n  user2: { name: \"Bob\", age: 30 },\n};\n\n// readOnlyUsers.user1 = { name: \"Charlie\", age: 35 }; // 오류: 'user1'에 할당할 수 없습니다. 읽기 전용 속성이기 때문에\n\n이 예시에서는 Readonly와 Record 타입을 결합하여 수정할 수 없는 사용자 레코드 객체를 만들어 객체의 속성을 수정할 수 없도록 보장합니다.\n\n# 9. Record와 Partial 함께 사용하기\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n부분 및 레코드 유형을 결합하여 모든 속성이 선택적인 객체를 만들 수 있어요.\n\n## 코드 예시:\n\ntype PartialUserRecord = Partial<Record<string, User>>;\n\nconst partialUsers: PartialUserRecord = {\n  user1: { name: \"Alice\", age: 25 },\n  user2: undefined, // 속성이 선택적이므로 유효합니다\n};\n\n이 예시에서 Partial 및 Record의 결합을 통해 속성이 선택적인 객체를 정의할 수 있어서 부분적인 데이터를 처리하는 데 매우 유용합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 10. Record를 사용하여 모든 속성을 필수로 강제하는 방법\n\n어떤 경우에는 객체의 모든 속성이 필수임을 보장해야 할 수도 있습니다. Required와 Record 타입을 결합하여 이를 달성할 수 있습니다.\n\n## 코드 예시:\n\ninterface Config {\n  host?: string;\n  port?: number;\n}\n\ntype RequiredConfig = Required<Config>;\n\ntype ConfigRecord = Record<string, RequiredConfig>;\n\nconst configs: ConfigRecord = {\n  dev: { host: \"localhost\", port: 8080 },\n  prod: { host: \"example.com\", port: 80 },\n};\n\n// 'port'가 필수이기 때문에 에러가 발생합니다\n// const invalidConfigs: ConfigRecord = {\n//   dev: { host: \"localhost\" }\n// };\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 예시에서는 Config 객체의 모든 속성이 필수로 입력되도록 Required 및 Record 유형을 사용하여 구성 객체의 완성도를 보장합니다.\n\n이 글을 통해 TypeScript의 Record 유형의 다양한 응용 프로그램 시나리오를 자세히 살펴보았습니다. Record 유형의 기본 정의, Tuple 및 Map과의 차이점, 그리고 실제 응용프로그램에서 코드 가독성과 유지 관리성을 향상시키기 위해 Record 유형을 사용하는 방법에 대해 배웠습니다. 이러한 예시들이 Record 유형을 더 잘 이해하고 적용할 수 있도록 도와드리고 TypeScript 코드를 더 효율적이고 신뢰할 수 있게 만들기를 바랍니다.","ogImage":{"url":"/TIL/assets/img/2024-07-13-MasteringTypeScriptsRecordType_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-MasteringTypeScriptsRecordType_0.png","tag":["Tech"],"readingTime":9},{"title":"Airflow 변수 완전 정복하는 방법","description":"","date":"2024-07-13 20:34","slug":"2024-07-13-MasteringAirflowVariables","content":"\n\n<img src=\"/TIL/assets/img/2024-07-13-MasteringAirflowVariables_0.png\" />\n\n만약 여러 데이터 파이프라인이 동일한 API 엔드포인트와 상호 작용해야 하는 상황이 있다면, 정말 모든 파이프라인에서 이 엔드포인트를 선언해야 할까요? 이 엔드포인트가 나중에 변경된다면, 모든 파일에서 해당 값을 업데이트해야 합니다.\n\nAirflow 변수는 간단하면서도 가치 있는 구조로, 여러 DAG에서 중복 선언을 방지하는 데 사용됩니다. 이들은 단순히 키와 JSON 직렬화 가능한 값으로 구성된 객체로, Airflow의 메타데이터베이스에 저장됩니다.\n\n그리고 코드가 토큰이나 기타 유형의 비밀을 사용한다면 어떻게 해야 할까요? 평문으로 하드코딩하는 것은 안전한 접근 방식으로 보이지 않습니다. 반복을 줄이는 데 beyond하는 Airflow 변수는 민감한 정보를 관리하는 데도 도움이 됩니다. Airflow에서 변수를 정의하는 여섯 가지 다양한 방법 중에서 적합한 방법을 선택하는 것은 보안과 이식성을 보장하기 위해 중요합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n자주 간과되는 측면 중 하나는 변수 검색이 Airflow 성능에 미치는 영향입니다. 스케줄러가 DAG 파일을 파싱할 때마다 메타데이터베이스에 요청하는 것은 성능에 부담이 될 수 있습니다(기본값은 삼십 초입니다).\n\n이 함정에 빠지기는 꽤 쉽습니다. DAG를 구문 분석하는 방법과 데이터베이스에서 변수를 검색하는 방법을 이해하지 않는 한요하는 베스트 프렉티스를 적용하는 것이 중요합니다.\n\n# Airflow 변수 정의\n\nDAG 파일을 파싱하는 방법과 DAGs를 최적화하기 위해 적용해야 하는 베스트 프렉티스에 대해 논의하기 전에, 기초를 제대로 이해하는 것이 중요합니다. 여기서는 어떻게 Airflow에서 변수를 선언하는지에만 초점을 맞춰 보겠습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이미 언급한 바와 같이, Airflow에서 변수를 선언하는 여러 가지 방법이 있습니다. 그 중 일부는 다른 것보다 더 안전하고 이식성이 뛰어난 것으로 나타나므로, 이들의 장단점을 살펴보고 이해해 봅시다.\n\n## 1. 사용자 인터페이스에서 변수 생성\n\n첫 번째 방법으로, 사용자 인터페이스를 통해 변수를 생성하는 방법을 살펴보겠습니다. 상위 메뉴에서 Admin → Variables → + 를 선택합니다.\n\n키와 값을 입력한 후, 만들기를 클릭하여 생성합니다. 변수는 이제 변수 목록에서 확인할 수 있어야 합니다. 기본적으로 UI에서 생성된 변수는 자동으로 메타데이터 데이터베이스에 저장됩니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n변수 값이 평문으로 표시된다는 것을 알 수 있어요. Airflow 변수 중 민감한 정보를 저장하려면 UI 방식이 가장 적합하지 않을 수 있어요.\n\n또한, 이 방법은 이식성이 떨어집니다. 환경을 재생성하려면 먼저 현재 환경에서 수동으로 내보내고, 마지막으로 새로 만든 환경으로 다시 가져와야 해요.\n\n## 2. 환경 변수를 내보내어 변수 생성하기\n\n두 번째 옵션은 AIRFLOW_VAR_`변수_이름` 표기법을 사용하여 환경 변수를 내보내는 것이에요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 명령어를 사용하여 두 변수인 foo와 bar를 생성할 수 있습니다.\n\n```js\nexport AIRFLOW_VAR_FOO=my_value\nexport AIRFLOW_VAR_BAR='{\"newsletter\":\"Data Pipeline\"}'\n```\n\n이 방법의 장점 중 하나는 환경 변수를 통해 생성된 변수가 UI에 표시되지 않는다는 것입니다(물론 코드에서 참조할 수는 있습니다). 즉, 민감한 정보가 노출되지 않습니다.\n\nUI를 통해 생성된 변수와는 달리, 이 방법은 메타데이터베이스에 지속적으로 저장하지 않습니다. 따라서 환경 변수를 사용하면 데이터베이스 연결을 설정할 필요가 없어 빠르게 검색할 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 여전히 환경 변수를 관리하는 것도 어려울 수 있습니다. 환경 변수가 Airflow 배포를 담당하는 자동화 스크립트에서 사용되는 파일에 저장된 경우 값들을 어떻게 안전하게 보호할 수 있을까요?\n\n## 3. Airflow CLI를 통한 변수 생성\n\nAirflow CLI를 사용하여 변수를 생성할 수도 있습니다. 먼저 Airflow 스케줄러 워커에 연결해야 합니다. 예를 들어 Docker를 통해 Airflow를 실행 중이라면, 먼저 스케줄러의 컨테이너 ID를 찾은 다음 다음 명령을 실행하세요.\n\n```js\ndocker exec -it <airflow-scheduler-container-id> /bin/bash\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAirflow 변수를 만들려면 다음의 명령어를 사용할 수 있어요:\n\n```js\nairflow variables set \\\n    my_cli_var \\\n    my_value \\\n    --description '이 변수는 CLI를 통해 생성되었어요'\n```\n\n만약 특정 변수에 여러 값을 할당하려면 JSON 형식을 사용하는 것이 좋아요:\n\n```js\nairflow variables set \\\n    my_cli_json_var \\\n    '{\"key\": \"value\", \"another_key\": \"another_value\"}' \\\n    --description '이 변수는 CLI를 통해 생성되었어요'\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nJSON 변수를 직렬화하는 옵션도 있습니다. 이를 위해 -j 또는 --json 플래그를 제공하여 수행할 수 있습니다.\n\n```js\nairflow variables set \\\n    --json \\\n    my_cli_serialised_json_var \\\n    '{\"key\": \"value\", \"another_key\": \"another_value\"}' \\\n    --description 'CLI를 통해 생성된 이 변수'\n```\n\n이제 UI의 변수 목록으로 돌아가보면, 이전 단계에서 만든 세 가지 변수가 모두 표시됩니다.\n\nCLI를 통해 생성된 변수는 UI에서 확인할 수 있어 민감한 정보도 노출되고 메타데이터베이스에 저장될 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n내 의견으로는, 이 방법은 개발 환경에서 유용합니다. 특정 변수를 빠르게 생성하고 테스트하거나 해당 변수를 참조하는 기능을 테스트하고 싶을 때 유용합니다. 프로덕션 배포의 경우, 변수를 생성(또는 업데이트)하기 위한 자동화 스크립트를 작성해야 하며, 이 정보는 파일에 저장되어야 합니다. 그렇기 때문에 몇 가지 변수에는 민감한 정보가 포함될 수 있어 처리하기 어려울 수 있습니다.\n\n## 4. REST API를 사용하여 변수 생성\n\n이 네 번째 방법은 REST API를 호출하여 몇 가지 변수를 생성하는 것을 포함합니다. 이는 Airflow CLI 방식과 유사하며 동일한 장단점을 제공합니다.\n\n```js\ncurl -X POST ${AIRFLOW_URL}/api/v1/variables \\\n        -H \"Content-Type: application/json\" \\\n        --user \"${AIRFLOW_USERNAME}:${AIRFLOW_PASSWORD}\" \\\n        -d '{\"key\": \"json_var\", \"value\": \"{\\\"key1\\\":\\\"val1\\\"}\"}'\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 5. 변수를 프로그래밍적으로 생성하기\n\n프로그래밍적으로 변수를 생성하는 것도 실행 가능하고 간단합니다.\n\n```js\ndef create_vars():\n    from airflow.models import Variable\n\n    Variable.set(key='my_var', value='my_val')\n    Variable.set(\n        key='my_json_var', \n        value={'my_key': 23, 'another_key': 'another_val'}, \n        serialize_json=True,\n    )\n\n...\n\nPythonOperator(\n    task_id='create_variables',\n    python_callable=create_vars,\n)\n```\n\n물론 이것은 나쁜 관행이며 프로덕션 배포에서 피해야 합니다. 변수 - 특히 민감한 정보를 포함하는 변수 - 는 DAG 파일에서 선언되어서는 안 되며 코드는 버전 관리되고 UI의 코드 탭에서도 볼 수 있기 때문입니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 6. 시크릿 스토어/백엔드에서 변수 만들기 ❤\n\n환경 변수나 메타스토어 데이터베이스에서 변수를 검색하는 것 외에도 Airflow 변수를 검색하기 위해 대체 시크릿 백엔드를 활성화할 수 있습니다.\n\n현재 Apache Airflow 커뮤니티에서 제공하는 시크릿 백엔드 구현에는 다음이 포함됩니다:\n\n- Amazon (Secrets Manager 및 Systems Manager Parameter Store)\n- Google (Cloud Secret Manager)\n- Microsoft (Azure Key Vault)\n- HashiCorp (Vault)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n사실, Airflow에서 변수를 정의하는 가장 좋고 안전하며 휴대성이 뛰어난 방법입니다.\n\n# 민감한 변수 값 숨기기\n\n이전 섹션에서 설명한 몇 가지 방법 중 일부에서 민감한 정보가 실제로 사용자 인터페이스에 표시될 수 있다고 언급했습니다. 사실, 변수가 올바르게 이름 지어진 경우에는 민감한 값을 숨길 수 있습니다.\n\n변수 이름에 특정 키워드가 포함되어 민감한 정보를 나타낼 수 있다고 생각되면 해당 값이 자동으로 숨겨집니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음은 민감한 정보를 값으로 저장하게끔 변수를 자격 부여할 키워드 목록입니다:\n\n```js\naccess_token\napi_key\napikey\nauthorization\npassphrase\npasswd\npassword\nprivate_key\nsecret\ntoken\nkeyfile_dict\nservice_account\n```\n\n만약 변수 이름에 이 키워드 중 하나가 포함되어 있다면, Airflow는 해당 값을 적절히 처리할 것입니다. 이 기능이 예상대로 작동하는지 확인하기 위해 예제를 시도해 보겠습니다.\n\n먼저, 위에 언급된 키워드 중 하나를 추가하지 않고 새 변수를 만들어 보겠습니다. 우리는 변수의 값이 사용자 인터페이스에서 보이는 것을 확인할 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 화면에서는 새로운 변수인 my_api_key를 생성하려고 시도합니다. 이전에 토론한 대로 변수 이름에 api_key 키워드가 포함되어 있기 때문에 Airflow는 민감한 정보를 보호하는 방식으로 해당 값을 처리해야 합니다.\n\n실제로 지금 UI의 변수 목록으로 돌아가보면 새로 생성된 변수의 값을 숨겨진 것을 볼 수 있습니다.\n\n기존 키워드 목록에 만족스럽지 않다면, 추가적인 키워드를 지정하여 변수 값 숨김 시 고려해야 하는 키워드 목록을 확장할 수도 있습니다. 이는 airflow.cfg( [core] 섹션 내)의 sensitive_var_conn_names를 통해 구성하거나 AIRFLOW__CORE__SENSITIVE_VAR_CONN_NAMES 환경 변수를 내보내는 것으로 설정할 수 있습니다.\n\n# 효율적인 변수 검색\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n기본 설정으로 Airflow DAG는 30초마다 구문 분석됩니다. 스케줄러는 DAG 폴더를 스캔하여 DAG 파일에 대한 변경 사항을 식별합니다. 변수를 올바르게 가져오지 않으면 DAG 구문 분석 프로세스가 곧 병목 현상이 될 수 있습니다.\n\n변수를 선언하는 방법에 따라 Airflow는 DAG 파일에서 선언된 각 변수에 대해 메타스토어 데이터베이스에 연결을 초기화해야 할 수 있습니다.\n\n# 요청으로 메타스토어 과부하 피하기\n\nDAG에서 변수를 검색하기 위해 두 가지 접근 방식을 취할 수 있습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Variable.get() 함수 사용\n- var 템플릿 변수 사용\n\n만약 첫 번째 옵션을 선택하신 경우, Variable.get()은 지정된 변수의 값을 추론하기 위해 메타스토어 데이터베이스와의 새로운 연결을 생성할 것입니다. 이제 DAG 파일에서 이 함수를 호출하는 위치는 성능에 큰 영향을 미칠 수 있습니다.\n\n## 잘못된 예시\n\n만약 이 함수가 태스크 외부에서 호출되거나 DAG Context Manager 내에서 호출된다면, 메타스토어와의 -의미 없는- 새로운 연결이 DAG가 파싱될 때마다 생성될 것입니다(즉, 30초마다).\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nfrom datetime import datetime\n\nfrom airflow import DAG\nfrom airflow.models import Variable\nfrom airflow.operators.python import PythonOperator\n\nmy_var = Variable.get('my_var')\n\nwith DAG('my_dag', start_date=datetime(2024, 1, 1)) as dag:\n    print_var = PythonOperator(\n        task_id='print_var',\n        python_callable=lambda: print(my_var),\n    )\n```\n\n만약 동일한 패턴이 많은 다른 DAG에서 사용된다면, 언젠가는 메타스토어 데이터베이스에 문제가 발생할 수 있습니다.\n\n실제로 이 패턴을 피할 수 없는 몇 가지 예외적인 상황이 있습니다. 예를 들어 변수의 값에 따라 동적으로 작업을 생성하고 싶다고 가정해보겠습니다. 그 경우 해당 함수를 작업 외부에서 호출하거나 Context Manager 내에서 호출해야 할 수도 있습니다. 하지만 가능하면 이 접근 방식을 피하는 것이 중요합니다.\n\n또한, 연산자의 인수에서 Variable.get() 함수를 호출하더라도 동일한 문제가 발생할 것임을 언급하는 것이 중요합니다.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nfrom datetime import datetime\n\nfrom airflow import DAG\nfrom airflow.models import Variable\nfrom airflow.operators.python import PythonOperator\n\ndef _print_var(my_var):\n    print(my_var)\nwith DAG('my_dag', start_date=datetime(2024, 1, 1)) as dag:\n    print_var = PythonOperator(\n        task_id='print_var',\n        python_callable=_print_var,\n        op_args=[Variable.get('my_var')],\n    )\n```\n\n사실 템플릿 엔진을 사용하면 이런 문제를 쉽게 피할 수 있어요.\n\n## Best Practices\n\n기본적으로 Variable.get()를 호출하는 대신에 템플릿 참조를 사용할 수 있어요. 이 기술을 사용하면 변수의 값은 런타임에만 가져와지게 돼요.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래의 코드 스니펫은 JSON 또는 JSON이 아닌 값에 대한 변수의 템플릿 참조를 사용하는 방법을 보여줍니다.\n\n```js\nfrom datetime import datetime\n\nfrom airflow import DAG\nfrom airflow.models import Variable\nfrom airflow.operators.python import PythonOperator\n\ndef _print_var(val1, val2, val3, val4):\n    print(val1)\n    print(val2)\n    print(val3)\n    print(val4)\n\nwith DAG('my_dag', start_date=datetime(2024, 1, 1)) as dag:\n    print_var = PythonOperator(\n        task_id='print_var',\n        python_callable=_print_var,\n        op_args=[\n            '{ var.value.my_var }',\n            '{ var.json.my_vars.key1 }',\n            '{ var.json.my_vars.key2 }',\n            '{ var.json.my_vars.key3 }',\n        ],\n    )\n```\n\n그러나 템플릿 엔진 접근 방식은 템플릿 참조를 제공할 인수에 대해 오퍼레이터가 템플릿화된 필드를 지원하는 경우에만 적용됩니다.\n\n템플릿 참조가 작동하지 않는 경우에는 여전히 Variable.get()이 작업 내에서 호출되도록하여 매번 DAG가 구문 분석될 때 메타스토어 데이터베이스로의 연결이 초기화되지 않도록 할 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nfrom datetime import datetime\n\nfrom airflow import DAG\nfrom airflow.models import Variable\nfrom airflow.operators.python import PythonOperator\n\ndef _print_var():\n    my_var = Variable.get('my_var')\n    print(my_var)\n\nwith DAG('my_dag', start_date=datetime(2024, 1, 1)) as dag:\n    print_var = PythonOperator(\n        task_id='print_var',\n        python_callable=_print_var,\n    )\n```\n\n# 단일 변수에 여러 값을 저장하기\n\n이제 특정 DAG가 세 가지 다른 값을 검색해야 한다고 가정해 봅시다. 이전 섹션에서 소개된 최선의 방법을 따르더라도 메타스토어 데이터베이스에 대해 세 개의 개별 연결을 시작해야 합니다.\n\n```python\nfrom datetime import datetime\n\nfrom airflow import DAG\nfrom airflow.models import Variable\nfrom airflow.operators.python import PythonOperator\n\ndef _print_vars():\n    my_var = Variable.get('my_var')\n    another_var = Variable.get('another_var')\n    one_more_var = Variable.get('one_more_var')\n    print(my_var)\n    print(another_var)\n    print(one_more_var)\n\nwith DAG('my_dag', start_date=datetime(2024, 1, 1)) as dag:\n    print_var = PythonOperator(\n        task_id='print_vars',\n        python_callable=_print_vars,\n    )\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n대신, 세 개의 키-값 쌍으로 구성된 단일 JSON 변수를 생성할 수 있습니다. 당연히 이 작업은 세 값을 한 변수로 압축하는 데 논리적으로 의미가 있는 한 수행해야 합니다.\n\n이제 메타스토어 데이터베이스로의 연결을 한 번만 수행하여 변수에서 지정된 모든 키의 값을 검색할 수 있습니다.\n\n```js\nfrom datetime import datetime\n\nfrom airflow import DAG\nfrom airflow.models import Variable\nfrom airflow.operators.python import PythonOperator\n\ndef _print_vars():\n    my_vars = Variable.get('my_vars', deserialize_json=True)\n    print(my_vars['key1'])\n    print(my_vars['key2'])\n    print(my_vars['key3'])\n\nwith DAG('my_dag', start_date=datetime(2024, 1, 1)) as dag:\n    print_var = PythonOperator(\n        task_id='print_vars',\n        python_callable=_print_vars,\n    )\n```\n\n# 최종 생각..\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n에어플로우 변수 선언은 간단하지만, 가장 좋은 방법을 적용하지 않으면 메타스토어 데이터베이스에서 가져오는 과정이 악몽이 될 수 있습니다.\n\n이 튜토리얼에서는 여섯 가지 다른 방법으로 에어플로우 변수를 생성하는 방법을 보여드렸습니다. 각 접근 방식에는 장단점이 있으며, 그에 맞춰 사용해야 합니다. 프로덕션 배포에서의 최상의 관례는 보안과 이식성을 제공하는 백엔드 시크릿을 사용하는 것입니다.\n\n더 중요한 건, 에어플로우 데이터베이스를 과부하시키지 않기 위해 피해야 할 기술들과 변수 구조 활용의 최적화 방법에 대해 논의했습니다. 이제 변수는 템플릿 참조를 통해 유추하거나 작업 함수 정의 내에서 정의되어야 한다는 점이 분명해졌기를 바랍니다.","ogImage":{"url":"/TIL/assets/img/2024-07-13-MasteringAirflowVariables_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-MasteringAirflowVariables_0.png","tag":["Tech"],"readingTime":17},{"title":"Matplotlib를 사용한 데이터 시각화 방법","description":"","date":"2024-07-13 20:32","slug":"2024-07-13-DataVisualizationwithMatplotlib","content":"\n\n![이미지](/TIL/assets/img/2024-07-13-DataVisualizationwithMatplotlib_0.png)\n\n데이터 시각화는 데이터 작업을 하는 사람들에게 매우 중요한 기술입니다. 이를 통해 복잡한 데이터 세트를 이해하고 결과를 효과적으로 전달할 수 있습니다. Python에서 데이터 시각화에 가장 인기 있는 라이브러리 중 하나인 Matplotlib을 살펴보겠습니다. 동물원 프로젝트와 관련된 코드 예제들은 이러한 개념을 더 잘 이해할 수 있도록 도와줍니다.\n\n# Matplotlib 개요\n\nMatplotlib은 Python 프로그래밍 언어를 위한 플로팅 라이브러리입니다. 일반 GUI 툴킷인 Tkinter, wxPython, Qt 또는 GTK를 사용하여 응용 프로그램에 플롯을 임베딩하기 위한 객체 지향 API를 제공합니다. Matplotlib은 또한 Python에서 정적, 애니메이션 및 대화형 시각화를 만드는 데 인기 있는 라이브러리입니다. 차트나 그래프를 만드는 것이 얼마나 쉬운지 알아보기 위해 몇 가지 코드 예제를 살펴봅시다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport matplotlib.pyplot as plt\nimport numpy as np\n# 간단한 그래프 예제\nx = np.linspace(0, 10, 100)\ny = np.sin(x)\nplt.plot(x, y)\nplt.show()\n```\n\n출력\n\n<img src=\"/TIL/assets/img/2024-07-13-DataVisualizationwithMatplotlib_1.png\" />\n\n이 간단한 예제는 Matplotlib을 사용하여 기본 선 그래프를 만드는 방법을 보여줍니다. 그러나 Matplotlib의 강점은 그 유연성과 복잡한 그래프를 만들 수 있는 능력에서 나옵니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 그림과 축\n\nMatplotlib에서 그림은 플롯을 구성하는 모든 요소를 포함하는 컨테이너로 생각할 수 있습니다. 축은 '플롯'으로 일반적으로 생각되는 요소로, 데이터 공간을 나타냅니다.\n\n그림\n\nMatplotlib에서 그림은 모든 것이 그려지는 전체 창 또는 페이지입니다. 이 그림에는 서브 축, 제목, 범례 및 레이블이 포함됩니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n```js\nfig = plt.figure()  # 아무 축이 없는 빈 그림\nfig, ax = plt.subplots()  # 하나의 축이 있는 그림\nfig, axs = plt.subplots(2, 2)  # 2x2 격자 형태의 축이 있는 그림\n```\n\n축\n\n이것은 우리가 '플롯'이라고 생각하는 것으로, 데이터 공간이 있는 이미지의 영역입니다. 하나의 그림에는 여러 축이 포함될 수 있지만, 특정 축 객체는 하나의 그림에만 있을 수 있습니다.\n\n```js\nfig = plt.figure()\nax1 = fig.add_subplot(211)  # 2행 1열로 구성된 그림에 서브플롯 추가 및 첫 번째 플롯 참조\nax2 = fig.add_subplot(212)  # 2행 1열로 구성된 그림에 서브플롯 추가 및 두 번째 플롯 참조\n``` \n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 동물원 프로젝트를 고려해보겠습니다. 다양한 동물과 그 특성에 관한 데이터가 있습니다. 우리는 Matplotlib을 사용하여 이 데이터를 시각화하고 싶습니다.\n\n```js\nimport pandas as pd\n# 동물원 프로젝트용 DataFrame 'df'가 있다고 가정\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\ndf = pd.DataFrame({\n    'animal': ['lion', 'tiger', 'bear', 'zebra', 'giraffe'],\n    'count': [5, 4, 6, 8, 2],\n    'average_weight': [190, 220, 300, 250, 800]\n})\nfig, ax = plt.subplots()\n# 동물 수에 대한 막대 그래프\nax.bar(df['animal'], df['count'], color='blue', alpha=0.7, label='Count')\n# 평균 무게에 대한 선 그래프, 보조 y-축 사용\nax2 = ax.twinx()\nax2.plot(df['animal'], df['average_weight'], color='red', label='Average Weight')\n# 라벨 및 제목\nax.set_xlabel('동물')\nax.set_ylabel('수')\nax2.set_ylabel('평균 무게 (kg)')\nplt.title('동물원 동물 통계')\n# 범례 표시\nfig.legend(loc=\"upper left\", bbox_to_anchor=(0,1), bbox_transform=ax.transAxes)\nplt.show()\n```\n\n출력\n\n<img src=\"/TIL/assets/img/2024-07-13-DataVisualizationwithMatplotlib_2.png\" />\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 예제에서는 각 동물의 수를 나타내는 막대 플롯과 각 동물의 평균 체중을 나타내는 라인 플롯을 만들었습니다. 두 가지 다른 양을 나타내기 위해 두 개의 y-축을 사용했습니다.\n\n## 서브플롯 이해하기\n\n서브플롯(subplots)은 동일한 그림 안에 여러 플롯을 만드는 방법입니다. 이것은 그리드 시스템과 같이 생각해볼 수 있습니다. 각 셀에는 플롯이 들어갈 수 있는 격자가 있습니다. 같은 그림 내에서 다수의 플롯을 구조적으로 표시하고 싶을 때 매우 유용합니다. Matplotlib에서는 plt.subplots() 함수를 사용하여 서브플롯을 만듭니다. 전달한 두 인수는 우리의 그리드의 행과 열의 수입니다. 예를 들어, plt.subplots(2, 3)은 2개의 행과 3개의 열을 가진 그리드를 만들어 총 6개의 서브플롯을 얻게 됩니다.\n\n```js\nfig, axs = plt.subplots(2, 3)  # 2행 3열의 그리드를 생성합니다\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 axs는 우리가 조작할 수있는 축 (개별 플롯)를 보유하고있는 2D 배열입니다. 예를 들어, axs[0, 1]은 첫 번째 행과 두 번째 열의 서브플롯에 액세스할 수 있습니다.\n\n## 여러 축\n\n가끔은 서로 다른 스케일이나 단위를 가진 서로 다른 데이터 세트를 동일한 플롯에 그리고 싶을 수 있습니다. 그럴 때 다중 축이 유용합니다.\n\nMatplotlib에서는 twinx() 또는 twiny() 메서드를 사용하여 플롯에 두 번째 축을 추가할 수 있습니다. twinx()는 두 번째 y 축을, twiny()는 두 번째 x 축을 생성합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nfig, ax1 = plt.subplots()\n# 첫 번째 y축에 그리기\nax1.plot(x, y1, color='blue')\nax1.set_ylabel('Y1', color='blue')\n# 두 번째 y축 생성 및 그리기\nax2 = ax1.twinx()\nax2.plot(x, y2, color='red')\nax2.set_ylabel('Y2', color='red')\n```\n\n결과\n\n<img src=\"/TIL/assets/img/2024-07-13-DataVisualizationwithMatplotlib_3.png\" />\n\n이 예시에서는 y1과 y2가 동일한 그래프에 표시되지만 각자의 y축을 가지고 있어 서로 다른 척도로 측정할 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 파이플롯 인터페이스\n\n맷플롯립의 파이플롯 인터페이스는 많은 사람들에게 플로팅의 세계로 들어가는 게이트웨이입니다. MATLAB의 플로팅 기능에서 영감을 받아 직관적이고 사용하기 쉽도록 설계되었습니다. 파이플롯을 사용하면 요소에 대한 정교한 제어가 중요하지 않은 빠르고 간단한 플로팅에 적합한 방식으로 도형과 축을 암시적으로 생성할 수 있습니다.\n\n```python\nimport matplotlib.pyplot as plt\n# 간단한 파이플롯 예시\nplt.figure()\nplt.plot([1, 2, 3, 4], [10, 20, 25, 30])\nplt.title('간단한 플롯')\nplt.show()\n```\n\n이 코드 조각은 최소한의 번거로움으로 기본 선 플롯을 생성합니다. 그러나 플로팅 요구 사항이 더 복잡해지면 파이플롯 인터페이스의 제약을 느낄 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 객체 지향 접근 방식\n\n객체 지향(OO) 접근 방식을 소개합니다. 이 방법론은 우리에게 자유를 주며, 플롯의 세부적인 사용자 정의가 가능합니다. Pyplot의 상태 지향에 의존하는 대신, figure 및 axes 객체와 직접 작업합니다. 이는 여러 개의 플롯을 다루거나 플롯 요소를 정확하게 제어해야 할 때 특히 유리합니다.\n\n```js\nimport matplotlib.pyplot as plt\n# 객체 지향 예시\nfig, ax = plt.subplots()\nax.plot([1, 2, 3, 4], [10, 20, 25, 30])\nax.set_title('OO 접근 방식 플롯')\nplt.show()\n```\n\n이 코드 조각에서 우리는 명시적으로 figure와 axes 객체를 생성하여 플롯의 모든 측면을 조정할 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 왜 Pyplot보다 객체 지향을 선택해야 하는가?\n\nOO 접근 방식은 프로젝트가 더 높은 수준의 정교함을 요구할 때 빛을 발합니다. 예를 들어, 서로 다른 동물들의 식이 요구사항을 시각화해야 하는 동물원 프로젝트에서는 OO 접근 방식을 통해 하위그림을 생성하고 범례를 사용자 정의하며 주석을 쉽게 추가할 수 있습니다.\n\n또한 OO 접근 방식은 확장 가능합니다. 프로젝트가 성장함에 따라 시각화를 유지하고 업데이트하는 것이 더 관리하기 쉬워집니다. 우리는 플롯을 포함한 함수를 만들 수 있고, GUI 애플리케이션에 플롯을 삽입할 수 있으며 등등 많은 기능들을 추가할 수 있습니다.\n\n## Matplotlib의 API: 중추부분\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nMatplotlib의 API는 시각화를 만들기 위한 유연한 접근 방식을 제공하는 클래스의 집합입니다. 객체 지향적이기 때문에 플롯을 마치 작업실의 물리적 객체처럼 거의 그대로 조작할 수 있습니다. 우리는 조정하고 세밀하게 다듬을 수 있어서, 정보를 전달하는 데 그치지 않고 매력적인 시각화를 만들 수 있습니다.\n\nAPI는 방대하지만, 핵심은 Figure와 Axes 클래스입니다.\n\n가상의 동물원 프로젝트에서 Matplotlib의 API를 적용해 보겠습니다. 다양한 동물들의 일주일 동안의 급식 일정을 시각화해야 한다고 상상해 보세요. 이 작업은 다수의 데이터 시리즈를 처리하고 한눈에 통찰을 제공할 수 있는 세심한 접근이 필요합니다.\n\nMatplotlib의 API로 무대를 설정해 봅시다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리는 우선적으로 필요한 모듈을 가져와서 데이터를 설정합니다. 동물들의 목록과 일주일 동안의 식량 소비량을 나타내는 배열이 있을 것입니다.\n\n```js\nimport matplotlib.pyplot as plt\nimport numpy as np\nanimals = ['사자', '코끼리', '기린', '원숭이']\nconsumption = np.array([\n    [30, 35, 28, 40, 42, 37, 35],  # 사자\n    [50, 55, 52, 58, 56, 60, 59],  # 코끼리\n    [20, 22, 25, 23, 26, 24, 22],  # 기린\n    [10, 15, 12, 17, 16, 14, 13]   # 원숭이\n])\n```\n\n시각화 만들기\n\n데이터가 준비되었으면, subplots 함수를 사용하여 Figure 및 여러 Axes를 만듭니다. 각 Axes는 일주일의 하루를 나타내며, 각 동물의 식량 소비량을 플롯합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\nfig, axs = plt.subplots(1, 7, figsize=(20, 5), sharey=True)\ndays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']\ncolors = ['red', 'green', 'blue', 'orange']\nfor i, ax in enumerate(axs):\n    for j, animal in enumerate(animals):\n        ax.bar(animal, consumption[j][i], color=colors[j])\n    ax.set_title(days[i])\nfig.suptitle('Zoo Animal Feeding Schedule')\nplt.show()\n\n\n위 코드 블록에서는 매일의 동물별 소비량을 보여주는 막대 차트를 작성했습니다. 공유 y축을 통해 플롯 간 일관성을 유지하고 색상을 사용하여 동물을 구분합니다.\n\n마무리\n\n시각화를 눈에 띄게 만들기 위해 레이블, 범례, 그리고 디자인을 미세조정합니다. Matplotlib의 API를 사용하여 이 작업을 수행할 수 있습니다.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# y 축 레이블 추가\nfig.text(0.04, 0.5, '음식 소비량 (kg)', va='center', rotation='vertical')\n# 범례 추가\nfig.legend(animals, loc='upper right')\n# 가독성을 위한 레이아웃 조정\nplt.tight_layout(rect=[0.03, 0.03, 1, 0.95])\n# 최종 플롯 표시\nplt.show()\n```\n\n출력\n\n<img src=\"/TIL/assets/img/2024-07-13-DataVisualizationwithMatplotlib_4.png\" />\n\n더 많은 기사: Seaborn으로 데이터 시각화","ogImage":{"url":"/TIL/assets/img/2024-07-13-DataVisualizationwithMatplotlib_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-DataVisualizationwithMatplotlib_0.png","tag":["Tech"],"readingTime":11},{"title":"지구과학자를 위한 파이썬 시작 가이드 코드를 개선하는 5가지 방법","description":"","date":"2024-07-13 20:31","slug":"2024-07-13-GettingStartedWithPythonasaGeoscientistHereAre5WaysYouCanImproveYourCode","content":"\n\n![Getting Started With Python as a Geoscientist](/TIL/assets/img/2024-07-13-GettingStartedWithPythonasaGeoscientistHereAre5WaysYouCanImproveYourCode_0.png)\n\n여러 해 동안 지질 과학 및 암페트로물리컬 분야에서 다양한 Python 스크립트를 보고 작업해왔습니다. 그동안 다양한 코딩 스타일을 보았고(또는 작성한 적도 있습니다), 잘 구성된 코드에서 문서화가 잘 되어 있는 것부터 모든 내용이 하나의 Python 파일에 있고 거의 구조화되지 않은 것까지 다양합니다. 후자의 경우, 코드를 몇 달 후에 다시 살펴보면 유지, 디버그 및 이해가 어려울 수 있습니다. 적용된 스타일을 결정하는 요구 사항이 종종 코드 작성 목적을 결정합니다.\n\n한 번 또는 두 번 사용될 수 있는 스크립트를 생성하거나 엄격한 시간 제약과 압박 하에 작업할 때는 원하는 만큼 아름답고 조직적으로 작성할 수 없을 수도 있습니다. 그러나 여러 차례 사용하거나 다른 사용자에게 배포하는 코드를 작성하거나 시간이 허락된다면 나중에 확장할 수 있는 방식으로 코드나 앱을 구조화하고 싶을 것입니다. 이렇게 하면 코드를 다시 확인할 때 시간과 머리 아픈 일을 절약할 수 있을 뿐만 아니라 코드가 무엇을 하는지 혹은 무엇을 하려고 했는지 잊는 딜레마를 피할 수도 있습니다.\n\n지질 과학자로서 코딩이 자연스럽지 않을 수 있습니다. 그러나 동료나 친구들이 만들었거나 얘기하는 앱을 보고 시도해보기를 원하는 영향을 받았을 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 글에서는 몇 년 동안 배운 다섯 가지의 조언을 공유하려고 합니다. 이 조언들은 제 지구과학 Python 애플리케이션을 개선하는 데 도움이 되었고, 처음으로 Python과 머신러닝의 세계로 진입하는 사람들에게도 도움이 될 것입니다.\n\n이 조언은 지구과학자가 아닌 누구에게나 동일하게 적용될 수 있으며, Python을 처음 배우기 시작하는 사람들에게 유용할 것입니다.\n\n# 애플리케이션 폴더 구조 설정\n\nPython 앱을 처음 만들 때 코드를 하나의 폴더에 모두 보관하는 것이 편리하고 쉬울 수 있습니다. 그러나 프로젝트가 성장하고 복잡해지면 코드 베이스를 유지하고 탐색하기가 어려워질 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 작업을 손쉽게 정리하는 방법은 효과적인 폴더 구조를 만드는 것입니다. 프로젝트가 작은 경우라도 데이터 파일과 출력 또는 임시 파일을 각각의 폴더로 분리하는 것이 유용합니다.\n\n예를 들어, 다음 구조는 데이터 처리, 시각화 및 분석을 위한 특정 기능이 분리된 폴더 집합을 유지합니다. 이를 통해 특정 기능을 자체 파일 내에 저장할 수 있습니다. 이러한 기능들은 main.py 파일에서 필요할 때마다 호출할 수 있습니다.\n\n또한, 데이터 파일은 데이터 하위 디렉토리에 배치할 수 있습니다.\n\n\n# 간단한 프로젝트 구조 예시\nyour_project/\n├── data_processing/\n│   └── data_cleaner.py\n├── visualisation/\n│   └── plotter.py\n├── analysis/\n│   └── statistical_model.py\n├── data/\n│   └── raw_data.csv\n└── main.py\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 라이브러리나 플랫폼 전용 어플리케이션(예: Dash)을 개발 중이라면 Cookiecutter와 같은 프레임워크를 살펴볼 가치가 있습니다. 이를 사용하면 여러 미리 정의된 템플릿을 통해 프로젝트 구조를 매우 빠르게 설정할 수 있습니다.\n\n마지막으로, 여러 어플리케이션에서 코드를 재사용할 계획이라면 해당 기능 및 클래스를 저장할 파이썬 라이브러리를 작성하는 것도 고려해보세요.\n\n# 함수와 클래스를 사용하여 재사용 가능한 코드 만들기\n\nPython(또는 다른 어떤 프로그래밍 언어에서도) 작업할 때, 깔끔하고 효율적인 코드를 만드는 관행을 따르는 것은 좋은 습관입니다. 특히 어플리케이션이 점점 커지는 경우에는 더욱 중요합니다. 이를 통해 코드를 쉽게 재사용하고 유지보수하기 쉽게하며 가독성을 높이고 (그 외 여러 가지 이점도 포함하여) 향상시킬 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n함수와 클래스를 통해 코드를 구성하고 기능을 분리하여 반복되는 코드를 줄일 수 있습니다.\n\n## 모듈화된 코드를 위한 함수\n\n함수를 사용하면 호출될 때 실행할 수 있는 코드를 캡슐화할 수 있습니다. 함수에 매개변수를 전달할 수 있으며, 결과를 반환할 수 있습니다.\n\nPython에서 함수를 만들려면 def 키워드를 사용하고, 함수의 이름을 작성한 후, 마지막으로 사용할 매개변수/인수를 지정하면 됩니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예를 들어, 아래 함수는 대용량 밀도 층의 측정값을 바탕으로 밀도 퇴적률을 계산합니다. 이 함수는 세 개의 매개변수( rho_matrix, rho_bulk 및 rho_fluid )를 입력으로 받아 계산을 수행하고 퇴적률 값을 반환합니다.\n\n```js\ndef calculate_density_porosity(rho_matrix, rho_bulk, rho_fluid):\n\n    return (rho_matrix - rho_bulk) / (rho_matrix - rho_fluid)\n```\n\n## 복잡한 데이터 구조를 다루는 클래스\n\n애플리케이션이 커지거나 복잡한 데이터 구조를 처리해야 하는 경우에는 클래스를 고려할 만한 유용한 도구가 될 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파이썬에서 클래스는 객체(블루프린트와 유사한 것)를 생성하고 객체의 동작 방식을 정의하는 데 사용됩니다. 이는 상태(멤버 변수)의 초기 값과 동작(멤버 함수 또는 메소드의 구현)을 제공함으로써 이루어집니다.\n\n## 재사용 가능한 코드를 위한 최상의 관행\n\n여러분의 애플리케이션에서 재사용 가능한 코드를 만들 때 몇 가지 최상의 관행을 소개합니다.\n\n- 단일 책임 원칙: 각 함수 또는 클래스는 단일 책임 또는 목적을 가져야 합니다. 이렇게 하면 코드가 테스트와 유지보수가 더 쉬워집니다.\n- 명확한 명명: 함수나 클래스를 생성할 때 명확한 이름을 가져야 합니다. 이 이름은 그들이 무엇을 하는지 또는 무엇을 나타내는지 명확히 보여주어야 합니다. 명명 규칙에 대한 pep-8 가이드라인을 참고하세요.\n- 문서화: 함수와 클래스의 목적과 사용법을 문서화하기 위해 독스트링을 사용하고 최소한의 계산 또는 방법론 출처에 대한 참조를 포함하세요. 이것은 특히 지구과학 분야에서 함수가 복잡한 계산을 수행하는 데 사용될 때 특히 중요합니다. 문서화는 블록 주석, 인라인 주석 및 문서화 문자열을 포함할 수 있습니다. 자세한 내용은 pep- 지침을 확인하세요.\n- 모듈화된 디자인: 각 부분(함수 또는 클래스)이 개별적으로 테스트 및 사용될 수 있도록 코드를 설계해야 합니다. 이로 인해 한 두 줄짜리 함수가 나올 수도 있지만 이는 더 큰 코드 조각에 감춰진 코드를 가지는 것보다 낫습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 코드에 문서 추가하기\n\n![Python 개발자로 시작하는 방법: 지질학자로 시작하기](/TIL/assets/img/2024-07-13-GettingStartedWithPythonasaGeoscientistHereAre5WaysYouCanImproveYourCode_1.png)\n\n스크립트, 함수 또는 클래스를 작성할 때 문서화가 중요합니다. 코드 내에 주석과 문서화 문자열(docstrings)을 작성하면 몇 달 후에 애플리케이션을 다시 방문했을 때 머리 아픔을 예방하는 데 큰 도움이 될 수 있습니다. 또한, 다른 사람들이 코드를 살펴보는 경우에도 코드를 이해하는 데 도움이 될 수 있습니다.\n\n문서화를 통해 코드의 가독성을 개선하는 세 가지 간단한 방법이 있습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n주석은 코드 섹션 뒤에 있는 아이디어를 설명하거나 복잡한 논리를 분해하거나 코드에 대한 컨텍스트를 제공하는 데 사용됩니다. 주석을 추가하는 아이디어는 코드가 어떻게 작동하는지 설명하는 것이 아니라 코드와 논리 뒤에 있는 '왜'를 설명하는 것입니다.\n\n도움말 문자열은 함수나 클래스가 무엇을 하는지와 함수나 클래스가 요구하는 매개변수가 무엇인지 설명하는 데 사용됩니다. 이는 코드를 사용하는 사람에게 매우 유용합니다.\n\n타입 힌팅은 사용자가 코드를 더 잘 이해할 수 있게 합니다. 이는 주어진 함수나 클래스의 각 매개변수에 대한 데이터 유형이 무엇인지 사용자에게 알려줌으로써 그렇게 합니다.\n\n이전에 본 예제에서는 도움말 문자열을 추가하여 문서를 확장했습니다. 이로써 함수가 무엇을 하는지, 예상되는 각 매개변수가 무엇인지, 예상하는 데이터 유형이 무엇인지 설명합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ndef calculate_density_porosity(rho_matrix: float, rho_bulk: float, rho_fluid: float) -> float:\n    \"\"\"\n    Calculates porosity based on bulk density measurements.\n\n    Parameters:\n      rho_matrix (float): The rock matrix density.\n      rho_bulk (float): The bulk density value.\n      rho_fluid (float): The fluid density.\n    \n    Returns:\n      float: The calculated density porosity.\n    \"\"\"\n    return (rho_matrix - rho_bulk) / (rho_matrix - rho_fluid)\n```\n\nPython 코드에서 문서화를 개선하는 방법에 대해 더 알아보려면 아래 동영상을 확인해보세요. 코드 문서화에 대해 더 자세히 다루었습니다:\n\n또는 다음 매체 기사를 확인할 수도 있습니다.\n\n# 버전 관리\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지구과학자로서 학업 과정에서 여러 버전의 에세이 및 논문을 저장하고 dissertation_version1.docx, dissertation_final.docx 또는 dissertation_final_final.docx와 같은 파일 이름을 만드는 데 익숙할 것으로 확신합니다. 이렇게 하면 매우 혼란스러워지고 나중에 파일을 다시 확인할 때 어떤 것이 진정 최종 버전인지 제대로 추적할 수 없게 됩니다.\n\nGit 또는 GitHub와 같은 온라인 시스템과 같은 시스템을 도입하면 미친 듯한 이름의 여러 파일을 만들지 않고도 다른 버전을 추적할 수 있습니다.\n\n또한 프로젝트 작업 중에 만든 변경 사항을 추적하고 싶을 수 있습니다. 이렇게 하면 이전에 작동했던 함수인데도 변경으로 인해 작동이 멈춘 경우 이전에 작동했던 코드로 롤백할 수 있는 가능성이 있습니다.\n\n버전 관리를 도입하면 다음과 같은 작업을 수행할 수 있습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 시간이 지남에 따라 변경 사항을 추적할 수 있습니다.\n- 다른 사람과 효과적으로 협력할 수 있습니다.\n- 기존 코드를 망가뜨리지 않고 실험할 수 있습니다.\n- 그리고 더 많은 기능들\n\n버전 관리의 개념을 이해하고 탐구하기 위한 좋은 안내서를 확인해보세요:\n\n# 작업하는 동안 테스트 생성하기\n\n코드나 애플리케이션을 개발할 때 함수를 수정하는 경우 특히 예상대로 작동하는지 확인해야 합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n함수를 변경하거나 이에 의존하는 기타 함수들에 대한 어떠한 변경이든 안정성을 확인하는 한 가지 방법은 해당 코드 주변에 테스트를 작성하는 것입니다.\n\nPyTest나 unittest와 같은 여러 Python 테스팅 프레임워크를 사용하면 쉽게 사용할 수 있으며 연속적인 통합 워크플로의 일부로서 자동화할 수도 있습니다.\n\n예를 들어, 아래 코드는 unittest를 사용하고 이전에 본 포로시티 방정식을 감싸는 예시입니다.\n\n```python\nimport unittest\nfrom your_project.geoscience_calculations import calculate_density_porosity\n\nclass TestDensityPorosityCalculation(unittest.TestCase):\n    def test_calculate_density_porosity(self):\n        self.assertAlmostEqual(calculate_density_porosity(2.65, 2.0, 1.0), 0.39)\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 테스트는 calculate_density_porosity 함수가 rho_matrix, rho_bulk, rho_fluid에 대한 특정 값이 주어졌을 때 밀도 산소포도를 올바르게 계산하는지 확인합니다.\n\n그런 다음 assertAlmostEqual 메서드를 사용하여 예상 값이 반환된 값과 근사하게 일치하는지 확인합니다. 부동 소수점 숫자의 특성 때문에 정확한 동일성을 항상 보장할 수 없을 수 있기 때문입니다.\n\n테스팅에 대해 더 알아보려면 다음 기사를 확인해보세요:\n\n# Summary\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지구과학자로서, Python에 익숙하지 않을 수도 있고, 경력이나 학업 중에 가볍게 다뤄본 적이 있을 수도 있습니다. 하지만 애플리케이션을 개발하는 데 더 능숙해지고 싶어하는 경우에 이 다섯 가지 팁이 도움이 될 것입니다.\n\n파이썬 코딩을 배우는 초기 단계에 있을 때나 현재 기술과 지식을 확장할 때에는 코드가 적절히 문서화되어 있고, 주변에는 테스트가 작성되어 있으며, 조직화된 구조 내에 포함되어 있는지 확인하는 것이 중요합니다. 코드의 규모와 복잡성이 증가할 때, 이후에 발생할 수 있는 시간 손실과 머리 아픔을 줄일 수 있습니다. 버전 관리를 사용하여 모든 변경 사항을 추적하고 친구나 동료들과 쉽게 협업할 수 있도록 할 수 있습니다.\n\n읽어 주셔서 감사합니다. 이 글을 마치시기 전에 꼭 저의 콘텐츠를 구독하고 제 글을 이메일로 받아보세요. 이 곳에서 확인하실 수 있습니다! 또한, 이 콘텐츠를 즐기셨다면 감사의 표시로 몇 번 클랩을 눌러주시면 감사하겠습니다.","ogImage":{"url":"/TIL/assets/img/2024-07-13-GettingStartedWithPythonasaGeoscientistHereAre5WaysYouCanImproveYourCode_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-GettingStartedWithPythonasaGeoscientistHereAre5WaysYouCanImproveYourCode_0.png","tag":["Tech"],"readingTime":11}],"page":"22","totalPageCount":50,"totalPageGroupCount":3,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true}