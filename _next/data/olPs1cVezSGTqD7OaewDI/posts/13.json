{"pageProps":{"posts":[{"title":"Next.js 15 서버 사이드 렌더링 사용법(use server)","description":"","date":"2025-04-22 02:14","slug":"2025-04-22-useserver","content":"\n\n# use server\n\n'use server' 지시어는 특정 함수나 파일이 서버 측에서 실행되어야 함을 명시하는 역할을 해요. 파일 맨 위에 쓰면 그 파일 안의 모든 함수가 서버에서 실행된다는 뜻이고, 함수 바로 위에 inline으로 쓰면 그 함수만 서버 함수(Server Function)로 지정할 수 있답니다. 이건 React에서 제공하는 기능이에요.\n\n## 파일 맨 위에 use server 쓰기\n\n아래 예시는 파일 최상단에 `use server` 지시어를 넣은 경우에요. 이렇게 하면 그 안에 있는 모든 함수는 서버에서 실행됩니다.\n\n```js\n'use server';\n\nexport async function getServerData() {\n  // 서버에서만 실행되는 로직\n  const data = await fetch('https://api.example.com/data');\n  return data.json();\n}\n\nexport function helperFunction() {\n  // 이 함수도 서버에서 실행돼요\n}\n```\n\n### 추가 설명!\n\n- `use server`를 쓰는 이유는 클라이언트에서 실행하면 안 되는 무거운 연산, 비밀 정보 처리, 데이터베이스 쿼리 등을 서버 쪽으로 감추기 위함이에요.\n- React 컴포넌트 내에서 서버 함수 호출 시 클라이언트 코드와 서버 코드를 깔끔하게 분리할 수 있어서 보안과 성능 면에서 유리합니다.\n- 만약 한 파일에 서버 함수와 클라이언트 함수가 혼재되어 있으면, 필요한 함수에만 inline으로 `use server`를 붙여서 관리하는 걸 추천해요.\n\n서버 함수 잘 활용하면 앱 구조를 더 명확하게 하고, 유지보수도 쉬워지니 꼭 익혀두시면 좋아요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n// actions.ts\n\"use server\"\n\nimport { db } from '@/lib/db'\n\nexport async function fetchUsers() {\n  const users = await db.user.findMany()\n  return users\n}\n```\n\n이렇게 Server Functions는 `\"use server\"` 지시어를 파일 상단에 작성해줘야 해요. 그리고 만들고 나면 클라이언트 컴포넌트나 서버 컴포넌트 어디에서든 가져다 쓸 수 있게 됩니다.\n\n예를 들어 클라이언트 컴포넌트에서 fetchUsers 함수를 사용하고 싶으면 이렇게 하면 돼요:\n\n```tsx\n\"use client\"\n\nimport { fetchUsers } from './actions'\n\nexport default function UserList() {\n  async function loadUsers() {\n    const users = await fetchUsers()\n    console.log(users)\n  }\n\n  return <button onClick={() => loadUsers()}>Load Users</button>\n}\n```\n\n여기서 포인트는 바로 클라이언트 컴포넌트에선 서버 함수가 비동기(Async) 함수라는 점이에요. 이걸 직접 호출하려면 이렇게 버튼 클릭 같은 이벤트 핸들러 안에서 호출하고 결과를 받아서 화면에 보여 주거나 로그를 찍는 식으로 사용합니다.\n\n---\n\n### Server Functions와 Database 연동 정리\n\n| 설명              | 내용                                                         |\n|-----------------|------------------------------------------------------------|\n| Server Function 생성법    | `use server` 지시어를 파일 상단에 넣고 비동기 함수 작성                |\n| Server 함수 위치          | 별도 파일(actions.ts 등)에 작성해 여러 컴포넌트에서 import 가능          |\n| Client 컴포넌트에서 사용법 | async 함수 안에서 호출, 이벤트 핸들러에서 호출하는 식으로 비동기 처리        |\n| 데이터베이스 연동          | 서버 함수 내에서 직접 `db` 클라이언트를 사용해 데이터 조회/수정 가능         |\n\n---\n\n### 참고 사항\n- 아직 Next.js나 React에서 완전히 SSR과 Client 컴포넌트 경계가 명확하여 이 방식을 적용할 때 내가 직접 어떤 작업이 서버에서 일어나고 있는지 분명히 이해하고 사용해야 해요.\n- 클라이언트에서 서버 함수를 호출할 때는 내부적으로 서버로 요청이 나가게 된다 생각하면 편해요. 그래서 고통 없는 데이터를 직접 다루는 것보다 네트워크 요청 비용이 있으니 꼭 필요한 경우에만 사용하세요.\n- 또, 인증 처리 같은 민감한 로직은 항상 서버 함수에서 관리하는 게 안전합니다.\n\n이 정도 핵심만 잘 이해해 두면 Server Functions를 효과적으로 쓸 수 있어요! 도움이 되었길 바랄게요 :)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이번 시간에는 Next.js의 Server Functions를 사용해서 데이터베이스에서 유저 데이터를 가져오는 예제를 살펴볼게요. 그리고 Fetch Users 함수를 클라이언트 컴포넌트에서 어떻게 호출할 수 있는지도 함께 알아봅니다.\n\n---\n\n### 1. Server Function 작성하기\n\n아래 코드는 `fetchUsers`라는 Server Function입니다. 데이터베이스에서 모든 유저를 가져와서 반환해주죠.\n\n```js\nimport { db } from '@/lib/db' // 데이터베이스 클라이언트 임포트\n\nexport async function fetchUsers() {\n  const users = await db.user.findMany()\n  return users\n}\n```\n\n여기서 `db.user.findMany()`는 Prisma 같은 ORM을 사용한다고 가정하고, 유저들을 모두 조회하는 코드입니다.\n\n---\n\n### 2. 클라이언트 컴포넌트에서 Server Function 호출하기\n\n이제 위에서 만든 `fetchUsers` 함수를 클라이언트 컴포넌트에서 호출해 보겠습니다.\n\n```js\nexport default function MyButton() {\n  return <button onClick={() => fetchUsers()}>Fetch Users</button>\n}\n```\n\n버튼 클릭 시 `fetchUsers`가 실행됩니다.\n\n---\n\n### 참고\n\n- 일반적으로 Server Function은 서버에서 실행하기 때문에, 클라이언트에서 직접 호출하려면 Next.js가 지원하는 방식으로 호출해야 합니다.\n- 만약 바로 클라이언트에서 `fetchUsers`를 호출하면, 서버 측 환경 변수가 없거나 보안 이슈가 생길 수 있으니 주의하세요.\n- Next.js 13 최신 기능 중 하나인 **Inline use server** 문법을 활용하면, 클라이언트 컴포넌트 안에서 서버 함수를 좀 더 쉽게 호출할 수 있습니다.\n\n---\n\n## Using `use server` inline\n\n`use server`는 Server Action 혹은 Server Function을 클라이언트 컴포넌트 내에서 바로 선언하고 사용할 수 있는 문법입니다. 예를 들어,\n\n```js\n'use client'\n\nimport { useState } from 'react'\n\nexport default function MyButton() {\n  async function fetchUsers() {\n    'use server'  // 여기서 서버 함수 선언\n    const users = await db.user.findMany()\n    return users\n  }\n\n  return <button onClick={() => fetchUsers()}>Fetch Users</button>\n}\n```\n\n이런 식으로 하면, `fetchUsers` 함수가 서버에서 실행되고 클라이언트에서 호출할 수 있습니다.\n\n---\n\n## 정리\n\n| 개념                | 설명                                                         |\n|---------------------|--------------------------------------------------------------|\n| Server Function     | 서버에서만 실행되는 함수. 서버 자원에 직접 접근 가능          |\n| 클라이언트에서 호출 | 클라이언트에서 호출 시 서버와 통신하거나, Next.js 방식 활용 필요 |\n| `use server` inline | 클라이언트 컴포넌트 내에서 서버 함수를 선언하고 실행 가능     |\n\n---\n\n이제 여러분도 Next.js에서 Server Functions를 어떻게 만들고 클라이언트에서 호출하는지 감이 좀 오시죠? 요즘 프레임워크가 점점 더 편리해지고 있어서, 서버와 클라이언트 코드 구분이 한결 수월해지고 있어요. 필요할 때 서버 함수를 잘 활용하면 더 깔끔하고 안전한 앱을 만들 수 있답니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n서버 함수(Server Function)를 표시할 때 `use server`를 함수 맨 위에 인라인으로 작성하는 방법에 대해 이야기해볼게요. 아래 예제를 보면, 데이터베이스에서 사용자 목록을 가져오는 함수가 있어요.\n\n```js\nimport { db } from '@/lib/db' // 데이터베이스 클라이언트 불러오기\n\nexport default function UserList() {\n  async function fetchUsers() {\n    const users = await db.user.findMany()\n    return users\n  }\n\n  return <button onClick={() => fetchUsers()}>Fetch Users</button>\n}\n```\n\n이 예제에서는 `fetchUsers` 함수가 서버에서 실행되어야 하는데, 실제로 현재 함수 위에 `use server` 지시어가 빠져 있어요. 이걸 명시하면 Next.js 같은 프레임워크가 이 함수가 서버 전용임을 확실히 알 수 있답니다.\n\n### 서버 함수에 `use server`를 추가할 때는 이렇게!\n\n```js\nimport { db } from '@/lib/db' // 데이터베이스 클라이언트 불러오기\n\nexport default function UserList() {\n  \"use server\"\n  \n  async function fetchUsers() {\n    const users = await db.user.findMany()\n    return users\n  }\n\n  return <button onClick={() => fetchUsers()}>Fetch Users</button>\n}\n```\n\n혹은 함수 바로 앞에 붙이는 경우도 있어요.\n\n```js\nimport { db } from '@/lib/db' // 데이터베이스 클라이언트 불러오기\n\nexport default function UserList() {\n  const fetchUsers = async () => {\n    \"use server\"\n    const users = await db.user.findMany()\n    return users\n  }\n\n  return <button onClick={() => fetchUsers()}>Fetch Users</button>\n}\n```\n\n서버 함수는 클라이언트에 번들되지 않고, 서버에서만 실행되도록 보장해줘서 보안 측면에서 매우 중요해요.\n\n---\n\n## 보안 고려사항 (Security considerations)\n\n`use server` 지시어를 사용해 서버 함수를 작성할 때는 보안을 꼭 염두에 두어야 해요. 서버에서 실행되는 만큼, 다음 사항들을 기억하세요:\n\n| 체크포인트                    | 설명                                                                    |\n|-----------------------------|------------------------------------------------------------------------|\n| 민감한 데이터 보호하기          | 데이터베이스 연결 정보, API 키, 사용자 비밀정보 등은 절대 클라이언트에 노출되면 안 됩니다. 서버 함수 내부에서만 접근하도록 하세요. |\n| 데이터 검증 및 인가 처리       | 클라이언트 요청 시 입력값을 반드시 검증하고, 인증과 권한 체크를 통해 불법 접근을 막으세요.          |\n| 에러 처리 및 로그 관리          | 서버 함수에서 발생하는 예외 처리를 신경쓰고, 보안 관련 로그는 적절히 기록해 두세요.            |\n| XSS 및 Injection 공격 방지    | 쿼리를 생성할 때 SQL 주입 또는 스크립트 주입 공격을 방지하도록 준비된 쿼리 사용과 데이터 정제 수행. |\n\n서버 함수는 서버 전용 코드임을 명확하게 표시하고, 클라이언트에서는 최소한의 정보만 주고받도록 하는 게 핵심입니다. 이런 방법들을 지키면 더욱 안전한 웹 애플리케이션 개발에 한 걸음 더 다가갈 수 있어요.\n\n---\n\n더 자세한 내용이 궁금하면, 사용하는 프레임워크 문서에서 `Server Functions` 또는 `Server Components` 부분을 참고해 보세요. `use server` 지시어를 어떻게 활용하는지, 그리고 클라이언트와 서버 간 데이터 흐름을 어떻게 구성하는지 실무에 큰 도움이 될 거예요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 인증(Authentication)과 인가(Authorization)\n\n서버 쪽에서 중요한 작업을 수행할 때는 항상 사용자가 누구인지 인증(Authentication)하고, 그 작업을 할 권한이 있는지를 확인하는 인가(Authorization)를 먼저 하셔야 해요.\n\n아래 예제 코드를 살짝 바꿔가며 설명해볼게요.\n\n```js\nimport { db } from '@/lib/db' // 데이터베이스 클라이언트\nimport { authenticate } from '@/lib/auth' // 인증 라이브러리\n\nexport async function createUser(data, request) {\n  const user = await authenticate(request) // 요청에서 사용자 인증\n  \n  if (!user) {\n    throw new Error('Unauthorized') // 인증 실패 시 에러 처리\n  }\n  \n  // 인증된 사용자만 새 사용자 생성 가능\n  const newUser = await db.user.create({ data })\n  return newUser\n}\n```\n\n위 코드에서 중요한 포인트는 `authenticate` 함수를 통해 사용자의 신원을 확인하는 과정을 거친다는 점이에요. 인증이 안 된 상태로 `createUser` 같은 주요 작업을 진행한다면 보안 이슈가 생길 수 있으니 꼭 확인해야 합니다.\n\n### 인증과 인가, 이 둘의 차이\n\n- **인증(Authentication)**: \"너 누구야?\" 라며 사용자 신원을 확인하는 과정  \n- **인가(Authorization)**: \"너 이 작업 해도 돼?\" 라며 권한을 확인하는 과정\n\n예를 들어, 로그인된 사용자가 있더라도 그 사람이 게시글 삭제 권한이 없다면 삭제할 수 없게 막는 게 바로 인가 절차가 됩니다.\n\n### 덧붙여서\n\nAPI 설계 시 보통 토큰(JWT 등)을 활용한 인증 방식을 많이 사용해요. 그리고 권한 관리는 역할(Role) 기반으로 하거나 특정 권한을 부여하는 식으로 구현하는 게 실무에서 흔하죠.\n\n또한, 프론트엔드에서도 인증 상태를 관리하고, 서버에는 절대 신뢰할 수 없는 상태로 요청하지 않는 게 중요합니다! 서버가 항상 “내가 진짜 인증한 사용자와 이야기 중인지”를 검증해야 한다는 점, 꼭 기억하세요.\n\n---\n\n## 참고 문서\n\n- [OAuth 2.0 공식 문서](https://oauth.net/2/)\n- [JWT 소개와 활용법](https://jwt.io/introduction)\n- [Node.js Authentication Best Practices](https://blog.nodejs.org/2021/10/05/node-js-authentication-best-practices/)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nReact 공식 문서에서 'use server'에 대한 자세한 내용을 확인할 수 있어요.  \n\n'Use server'는 React 18부터 도입된 기능 중 하나로, 서버 컴포넌트를 사용할 때 주로 활용됩니다. 서버 컴포넌트를 통해 렌더링이 서버에서 이루어지기 때문에 클라이언트 사이드보다 초기 로딩 속도가 빠르고, SEO에도 좋다는 장점이 있어요.  \n\nReact 공식 문서에서는 'use server'가 어떻게 동작하는지, 그리고 서버 컴포넌트를 어떻게 잘 활용할 수 있는지 구체적으로 설명하고 있으니 직접 확인해보시면 많은 도움이 될 거예요.  \n\n또한, 서버 컴포넌트는 데이터 요청(fetch) 같은 작업을 서버에서 직접 처리할 수 있어서 클라이언트의 부담을 줄여주는데, React의 'use server' 기능과 잘 결합하면 더욱 효과적이죠.  \n\n궁금하다면 아래 React 공식 문서 링크에서 자세한 내용 읽어보세요!  \nhttps://reactjs.org/docs/getting-started.html (React 공식 문서 메인 페이지입니다. 'Server Components'나 'use server'를 검색해보시면 도움됩니다.)  \n\n필요하다면 관련 예제나 사용법도 같이 소개해드릴게요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":11},{"title":"Next.js 15에서 클라이언트 사이드 렌더링 하는 방법 (use client)","description":"","date":"2025-04-22 02:13","slug":"2025-04-22-useclient","content":"\n\n# use client\n\nReact에서 `use client`는 컴포넌트를 클라이언트 사이드에서 렌더링하도록 지정하는 지시자입니다. 쉽게 말해, 사용자와 상호작용하는 UI, 예를 들면 상태 관리(state management), 이벤트 처리(event handling), 브라우저 API 접근 등이 필요할 때 이 지시자를 사용해요. 서버에서 렌더링되는 컴포넌트와 달리, 클라이언트 컴포넌트는 브라우저에서 직접 실행되기 때문에 좀 더 동적인 기능을 구현할 수 있죠.\n\n## 사용법\n\n컴포넌트를 클라이언트 컴포넌트로 만들고 싶다면, 파일 제일 상단에 `use client` 지시자를 추가하면 됩니다. 이 지시자는 모든 import문보다 먼저 위치해야 해요.\n\n```jsx\n\"use client\";\n\nimport React, { useState } from \"react\";\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <button onClick={() => setCount(count + 1)}>\n      클릭 수: {count}\n    </button>\n  );\n}\n\nexport default Counter;\n```\n\n> 여기서 중요한 점은 `\"use client\"`가 문자열로서 파일 맨 위에 위치해야 한다는 거예요. 만약 위치가 바뀌면 제대로 작동하지 않을 수 있어요.\n\n---\n\n### 추가 팁!\n\n- React 18부터 도입된 이 기능은 Next.js 13 이상의 App Router와 함께 자주 사용돼요.\n- 클라이언트 컴포넌트에는 서버 전용 데이터 페칭 기능을 직접 사용할 수 없으니, 필요한 데이터는 부모 서버 컴포넌트에서 미리 받아서 props로 전달하는 방식으로 설계해야 합니다.\n- 너무 많은 컴포넌트에 `use client`를 붙이면 클라이언트 번들 크기가 커져서 로딩 속도에 영향을 줄 수 있으니, 필요한 부분에 집중해서 사용하는 게 좋아요.\n\n`use client`를 잘 활용하면 React의 서버-클라이언트 경계에서 효율적인 UI 구성이 가능하답니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```jsx\nimport { useState } from 'react'\n\nexport default function Counter() {\n  const [count, setCount] = useState(0)\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  )\n}\n```\n\n## 서버 컴포넌트 안에 클라이언트 컴포넌트 넣기\n\n여러분, React 최신 트렌드인 서버 컴포넌트(Server Components)와 클라이언트 컴포넌트(Client Components)에 대해 들어보셨나요? 이 두 가지를 잘 섞으면 속도 빠르고 사용자와 상호작용이 뛰어난 앱을 만들 수 있답니다.\n\n| 컴포넌트 종류      | 용도 및 특징                                         |\n|------------------|---------------------------------------------------|\n| 서버 컴포넌트       | 정적인 콘텐츠, 데이터 패칭, SEO 최적화에 적합          |\n| 클라이언트 컴포넌트  | 상태 관리, 이벤트 핸들링, 브라우저 API 사용 등 동적 기능 담당 |\n| 조합 방법           | 서버 컴포넌트 안에 필요한 UI에 클라이언트 컴포넌트를 넣어 사용 |\n\n예를 들어, 서버에서 렌더링하는 부분은 정적으로 두고, 사용자가 버튼을 클릭해 카운터를 올리는 등 동적인 기능이 필요한 부분은 클라이언트 컴포넌트로 처리합니다.\n\n이렇게 하면, 전체 앱의 초기 로딩 속도는 빠르면서도, 사용자와의 상호작용도 놓치지 않는 깔끔한 구조를 유지할 수 있어요.\n\n추가로! 서버 컴포넌트는 기본적으로 클라이언트 상태나 이벤트를 직접 사용할 수 없기 때문에, 꼭 필요할 때만 클라이언트 컴포넌트를 분리해서 넣어주는 게 좋습니다. 이렇게 역할을 명확히 나누면, 코드 관리도 훨씬 수월해지고 최적화도 쉬워져요.\n\n궁금하다면 직접 서버 컴포넌트에서 클라이언트 컴포넌트를 호출하는 예제를 찾아보면서 써보세요! React 18 이후부터 이런 방식이 점점 더 표준이 되고 있답니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 예시를 살펴볼게요:\n\n- **Header**는 정적 콘텐츠를 처리하는 **서버 컴포넌트**입니다.\n- **Counter**는 페이지 내에서 상호작용을 가능하게 하는 **클라이언트 컴포넌트**예요.\n\n```js\nimport Header from './header'\n \nexport default function Page() {\n  return (\n    <div>\n      <Header />\n    </div>\n  )\n}\n```\n\n---\n\n### 좀 더 쉽게 이해해볼까요?\n\n서버 컴포넌트는 서버에서 렌더링되어 HTML 형태로 클라이언트로 전달돼요. 그래서 페이지를 빠르게 보여줄 수 있고, 초기 로드가 더 빨라지죠. 단, 서버 컴포넌트는 React 훅(useState, useEffect 등)을 사용할 수 없고, 사용자와 직접 상호작용하는 기능을 처리하는 데는 적합하지 않아요.\n\n반대로 클라이언트 컴포넌트는 브라우저(클라이언트)에서 실행되므로, 사용자 입력에 반응하거나 실시간으로 변화하는 UI를 만들 수 있어요. 다만, 클라이언트 컴포넌트는 서버 컴포넌트보다 초기 로딩 시 무거울 수 있답니다.\n\n---\n\n### 간단 비교 테이블\n\n| 구분         | 서버 컴포넌트          | 클라이언트 컴포넌트      |\n| ------------ | --------------------- | ----------------------- |\n| 실행 위치     | 서버                  | 브라우저(클라이언트)     |\n| 상태 관리     | 불가능                | 가능                    |\n| 렌더링 속도   | 빠름                  | 상대적으로 느림          |\n| 사용자 상호작용 | 제한적                 | 자유롭게 가능            |\n| 사용 예시     | 헤더, 정적 페이지 등   | 버튼, 폼, 카운터 등       |\n\n---\n\n이렇게 두 가지 컴포넌트의 역할을 잘 나누면, 성능과 개발 효율성을 모두 잡을 수 있습니다. 앞으로 Next.js나 React 최신 버전을 쓸 때 이 점 꼭 기억해 주세요! 필요하다면 서버 컴포넌트 안에서 클라이언트 컴포넌트를 불러 올 수도 있으니, 상황에 맞게 섞어서 써보는 것도 추천합니다.\n\n필요한 자료가 더 있다면 언제든 알려주세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nReact 문서에서 \"use client\"에 대해 더 자세히 알아볼 수 있어요.\n\n사실 \"use client\"는 React 18부터 도입된 개념이라, 클라이언트 사이드 렌더링을 명확히 구분하고자 할 때 많이 사용돼요. 예를 들어, Next.js 13처럼 React 18 기반 프레임워크에서는 서버 컴포넌트와 클라이언트 컴포넌트를 구분해서 작성하는 게 중요하거든요.\n\n\"‘use client’\"라는 지시어를 컴포넌트 파일 상단에 적으면, 이 컴포넌트가 클라이언트 쪽에서 실행된다는 걸 명확히 알릴 수 있어요. 그럼 그 컴포넌트 안에 useState, useEffect 같은 React 훅들을 편하게 쓸 수 있답니다.\n\n더 자세한 내용과 공식 가이드는 리액트 공식 문서에서 확인해 보세요! 여기에 간단 링크도 남겨 둘게요.\n\n- [React 공식 문서 - Client Components](https://reactjs.org/docs/client-components.html) (영문)  \n- Next.js에서 클라이언트 컴포넌트 사용하는 방법도 참고하면 좋아요\n\n이외에 React 18을 쓰면서 새로운 컴포넌트 구분법에 대해 궁금한 점 있으면 언제든 물어봐 주세요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":5},{"title":"Next.js 15에서 Cache 사용법 및 성능 최적화 방법 정리","description":"","date":"2025-04-22 02:11","slug":"2025-04-22-usecache","content":"\n\n# use cache\n\n`use cache` 디렉티브는 라우트(Route), React 컴포넌트, 또는 함수에 캐시 기능을 적용할 수 있게 해줘요. 이걸 사용하면 해당 함수나 컴포넌트의 반환 값을 캐싱해서, 불필요한 재렌더링이나 무거운 작업을 줄일 수 있답니다.\n\n보통 파일 상단에 쓰면 그 파일 내 모든 export에 대해 캐싱을 적용하고, 함수나 컴포넌트 바로 위에 inline으로 쓰면 그 특정 함수의 결과만 캐싱할 수도 있어요.\n\n## 사용법\n\n이 기능은 현재 실험적인(Experimental) 기능이라 정식 버전에서는 조금 달라질 수 있어요. 사용하려면 `next.config.ts` 파일에 `useCache` 옵션을 추가해야 합니다.\n\n```ts\n// next.config.ts\nconst nextConfig = {\n  experimental: {\n    useCache: true,\n  },\n};\n\nexport default nextConfig;\n```\n\n---\n\n### 좀 더 쉽게 설명하자면?\n\nReact를 다루다 보면, 컴포넌트가 똑같은 props를 받았는데도 자꾸 재렌더링되는 경우가 있죠? 이때 `use cache`를 사용하면, 컴포넌트가 이전에 렌더링해서 갖고 있던 결과를 재사용해서 성능을 끌어올릴 수 있어요.\n\n함수에도 적용할 수 있는데, 함수가 복잡한 연산을 수행할 때 매번 그 연산을 반복하지 않고 저장해둔 값을 돌려주는 효과가 있습니다.\n\n### 주의할 점!\n\n- 지금은 실험 기능이니, 안정성이나 호환성 이슈가 있을 수 있어요.\n- 캐싱된 결과는 상태(state)나 컨텍스트 변경에는 반응하지 않으니, 상태에 따라 바뀌어야 하는 값에는 적절하지 않습니다.\n\n### 추가 팁\n\n- Next.js에서 SSR(Server Side Rendering)과 캐시를 함께 사용할 때도 `use cache`를 통해 일부 결과를 캐싱하면 응답 속도를 상당히 단축할 수 있어요.\n- 캐시는 적절히 관리해줘야 메모리 누수 같은 문제를 예방할 수 있으니, 특별히 오래된 캐시를 청소하는 로직도 함께 고려해보시는 걸 추천해요.\n\n요즘엔 이런 캐시 기능이 점점 중요해지고 있으니, 실험 기능이 안정화되면 꼭 적극적으로 써보시길 바랍니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서 `use cache` 옵션을 사용하는 방법을 알려드릴게요! 이 옵션은 캐시를 적극 활용해서 성능을 최적화하고, 데이터 요청을 더 빠르게 처리하는 데 도움을 줘요.\n\n먼저, `next.config.js`나 `next.config.ts` 파일에서 실험 기능인 `useCache`를 활성화해줘야 해요. 이렇게 설정합니다:\n\n```js\nimport type { NextConfig } from 'next'\n\nconst nextConfig: NextConfig = {\n  experimental: {\n    useCache: true,\n  },\n}\n\nexport default nextConfig\n```\n\n### 참고할 점!\n\n`useCache`는 `dynamicIO` 옵션을 통해서도 사용할 수 있어요. 만약 캐시를 동적으로 제어하고 싶다면 `dynamicIO`도 함께 살펴보면 좋겠죠?\n\n---\n\n### `use cache` 사용법\n\n`use cache`를 파일, 컴포넌트, 혹은 함수 단위에서 사용할 수 있어요. 다음 예시를 참고하세요.\n\n| 적용 위치   | 예시 코드                                       | 설명                                    |\n|-------------|------------------------------------------------|-----------------------------------------|\n| 파일 레벨    | `'use cache'`<br>`export default async function Page() { ... }` | 파일 전체에 캐시 사용을 적용             |\n| 컴포넌트 레벨 | `export async function MyComponent() {`<br> `'use cache'`<br> `return <></>`<br> `}` | 특정 컴포넌트만 캐시 사용                 |\n| 함수 레벨    | `export async function getData() {`<br> `'use cache'`<br> `const data = await fetch('/api/data')`<br> `return data`<br> `}` | 특정 함수 내에서만 캐시 사용             |\n\n---\n\n### 추가 팁!\n\n- `'use cache'`는 마치 자바스크립트의 `'use strict'`처럼 바로 함수(혹은 파일) 최상단에 위치해야 인식돼요.\n- 캐시를 잘 활용하면 SSR(서버사이드 렌더링) 환경에서 API 요청 횟수를 줄이고, 페이지 렌더링 속도를 개선할 수 있어요.\n- 다만, 데이터가 자주 변경되는 상황에서는 캐시가 최신 데이터를 반영하지 않을 수도 있으니 캐시 정책을 꼼꼼히 짜는 게 중요해요.\n\n---\n\n이렇게 `use cache`를 적절히 활용해 Next.js 애플리케이션의 퍼포먼스를 한층 올려보세요! 개발하면서 캐시 전략을 고민하는 것이 장기적으로 봤을 때 큰 이득이 될 거예요. 궁금한 점 있으면 언제든 물어보세요 :)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 캐시 사용법\n\n### 캐시 키(Cache keys)\n\n캐시 항목의 키는 입력값을 직렬화한 버전을 사용해서 생성돼요. 여기서 입력값에는 다음이 포함됩니다:\n\n- **빌드 ID**: 빌드할 때마다 새롭게 생성되는 고유한 ID예요.\n- **함수 ID**: 각 함수마다 유일하게 부여된 보안 식별자입니다.\n- **직렬화 가능한 함수 인자(또는 props)**: 함수에 전달되는 인자들이에요. 이 값들을 직렬화해서 키에 포함시킵니다.\n\n즉, 캐시는 단순히 함수 이름만으로 구분하는 게 아니라, '어떤 빌드에서, 어떤 함수에, 어떤 인자들로 호출했는지'를 정확하게 고려해서 고유한 키를 만들고, 그 키를 통해 캐시 데이터를 관리합니다.\n\n이런 방식을 사용하면, 같은 함수라도 인자가 다르면 다른 캐시 항목으로 인식하고, 이전에 수행한 결과를 재사용할지 여부를 정확하게 판단할 수 있어 성능 최적화에 큰 도움이 됩니다.\n\n참고로, 이 과정에서 함수 인자를 직렬화하는 이유는 객체나 배열처럼 복잡한 데이터 타입도 문자열 형태로 변환해서 고유성을 보장하기 위함이에요. 만약 직렬화가 제대로 안 되면 캐시가 잘못된 결과를 반환하거나, 캐시 히트률이 낮아질 수 있으니 신경 쓰셔야 해요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n함수 캐싱할 때 전달되는 인자들과, 함수가 부모 스코프에서 읽는 값들은 자동으로 캐시 키의 일부가 됩니다. 즉, 입력값이 같으면 같은 캐시 항목이 재사용된다는 뜻이죠.\n\n## 직렬화 불가능한 인자들\n\n여기서 중요한 점! 만약 직렬화(serialize)할 수 없는 인자나 props, 혹은 클로저로 묶인 값들이 들어오면, 이 값들은 캐시 함수 안에서 그냥 참조로만 다뤄집니다. 즉, 캐시 함수 내부에서 이 값들을 검사하거나 변경할 수 없고, 단순히 받아서 사용할 뿐이에요. 그리고 이런 직렬화 불가능한 값들은 요청 시점에 채워지고, 캐시 키의 일부가 되지는 않습니다.\n\n예를 들어, 캐시된 함수가 `children` prop으로 JSX를 받는다고 할 때, `div`안에 `children`을 그냥 넣어줄 순 있지만, 실제 `children` 객체 내부를 들여다보지는 못해요. 이런 특성 덕분에 캐시된 컴포넌트 안에 캐싱되지 않은 내용(uncached content)을 자유롭게 중첩해서 사용할 수 있습니다.\n\n---\n\n### 조금 더 쉽게 풀어볼게요!\n\n1. **캐시 키란?** 함수에 들어가는 인자와 외부에서 읽는 변수가 일종의 '이름표'처럼 합쳐져서 캐시 데이터가 저장되는 키가 된다는 거예요.\n2. **직렬화 불가능한 값은 뭐가 있냐면?** 예를 들어 함수, DOM 노드, 혹은 복잡한 객체(내부에 메서드가 있거나 순환 참조가 있는 객체) 등이 있죠. 이런 값들은 그냥 ‘참조’로 넘겨지고 캐시에 포함되지 않습니다.\n3. **왜 이런게 중요하냐면?** 함수가 내부 값을 깊게 분석해서 캐시 키를 만들면 성능이 떨어질 수 있거든요. 그래서 React 같은 라이브러리도 종종 이런 방식으로 캐시 관리를 해요.\n\n캐싱을 잘 활용하면 불필요한 연산을 줄이고, 사용자 경험을 훨씬 부드럽게 만들 수 있으니 꼭 기억해두세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```tsx\nfunction CachedComponent({ children }: { children: ReactNode }) {\n  'use cache'\n  return <div>{children}</div>\n}\n```\n\n## 반환 값(Return values)\n\n캐시 가능한 함수의 반환 값은 반드시 직렬화(serializable)가 가능해야 합니다.  \n이렇게 해야 캐시된 데이터를 올바르게 저장하고 꺼내 쓸 수 있어요. 예를 들어, 함수나 DOM 노드 같은 직렬화 불가능한 값은 캐시 저장소에 넣으면 안 된다는 뜻입니다.\n\n## 빌드 타임에 use cache 사용하기\n\n`'use cache'`는 일반적인 리액트 훅처럼 동작하는 게 아니라, 함수의 결과를 빌드 타임에 캐싱해서 성능 최적화를 도와줍니다.  \n정적 데이터가 자주 변하지 않는 경우라면, 빌드 타임에 캐시를 생성해두면 재랜더 시점에 불필요한 연산을 줄일 수 있죠.\n\n---\n\n### 추가 팁!  \n- 반환값이 객체라면, 반드시 JSON으로 변환 가능한 구조인지 확인하세요.  \n- 복잡한 상태를 캐시해야 한다면, 필요에 따라 커스텀 직렬화 방식을 구현할 수도 있습니다.  \n- `use cache`는 아직 실험적 기능일 수 있으니, 사용 시 React 버전과 호환성도 체크해 주세요!  \n\n이걸 잘 활용하면 서버 컴포넌트나 Next.js 같은 프레임워크에서 렌더링 성능을 꽤 끌어올릴 수 있으니 꼭 알아두세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n레이아웃이나 페이지 상단에 사용하면, 해당 라우트 세그먼트가 미리 렌더링(prerendering)됩니다. 이렇게 하면 나중에 다시 검증(revalidate)할 수 있게 되죠.\n\n하지만 여기서 중요한 점! 이런 프리렌더링을 하면 요청 시점(request-time)에서 사용하는 API들, 예를 들어 쿠키(cookies)나 헤더(headers)를 이용할 수 없다는 점 기억하세요. 즉, 이런 데이터들을 기반으로 동적인 처리를 해야 한다면 프리렌더링과는 맞지 않아요.\n\n---\n\n## 런타임 시점에 캐시 사용하기 (use cache at runtime)\n\n서버에서는 각각의 컴포넌트나 함수들의 캐시 항목이 메모리 내에 저장됩니다. 그러니까 한 번 처리된 결과를 메모리에 담아두고 다시 사용할 수 있다는 뜻이죠. 이 덕분에 성능이 개선되고 불필요한 중복 연산을 피할 수 있습니다.\n\n---\n\n### 추가로 알아두면 좋은 점\n\n- **프리렌더링 vs 런타임 캐시**  \n  프리렌더링은 페이지를 미리 만들어 두고 배포하는 개념이라, 사용자 요청마다 즉시 렌더링하지 않아 서버 부하가 적죠. 대신 실시간 사용자 정보 처리엔 제한적입니다.  \n  반면 런타임 캐시는 요청 시점에 데이터를 활용하면서도, 동일한 데이터 요청에 대해서는 캐시된 결과를 활용하기 때문에 성능과 유연성을 적절히 조절할 수 있어요.\n\n- **캐시 무효화 전략**  \n  캐시는 한번 저장되면 갱신되지 않으면 오래된 데이터를 보여줄 수도 있으니, 적절한 무효화 전략도 꼭 신경써야 합니다. 필요에 따라 주기적으로 다시 검증하거나, 데이터 변경 시 캐시를 삭제하는 방식을 사용할 수 있죠.\n\n이렇게 캐시 사용법과 특성을 이해해서 프로젝트 성격에 맞게 적용하면, 사용자 경험과 서버 성능 모두 잡을 수 있습니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n클라이언트에서는 서버 캐시에서 반환된 모든 콘텐츠가 세션이 유지되는 동안 또는 재검증(revalidation)될 때까지 브라우저 메모리에 저장됩니다.\n\n## 재검증 중에는?\n\n기본적으로 use cache는 서버 측 재검증 기간이 15분으로 설정되어 있어요. 이 기간은 자주 업데이트가 필요 없는 콘텐츠에는 적합하지만, 개별 캐시 항목이 언제 다시 확인되어야 하는지를 더 세밀하게 조정하고 싶다면, cacheLife와 cacheTag API를 이용할 수 있어요.\n\n- **cacheLife**: 캐시 항목의 수명을 설정할 수 있어요. 예를 들어, 10분, 1시간 등 원하는 기간 동안 캐시가 유효하게 만들 수 있어요.\n- **cacheTag**: 특정 태그를 만들어서 필요할 때 해당 태그가 붙은 캐시를 선택적으로 재검증할 수 있어요. 예를 들어, 게시판 글, 뉴스 등 특정 콘텐츠 그룹만 빠르게 새로고침할 때 유용하답니다.\n\n### 추가 팁!\n\n캐시를 잘 활용하면 서버 부하를 많이 줄이고 사용자 경험도 부드럽게 만들 수 있어요. 하지만 캐시가 너무 오래 유지되면 업데이트가 반영되지 않는 문제가 생길 수 있으니, 콘텐츠 특성과 업데이트 빈도에 맞춰 캐시 정책을 적절히 조정하는 게 중요합니다. 특히 실시간 정보가 중요한 서비스라면 재검증 주기를 짧게 가져가는 걸 추천해요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n두 API 모두 클라이언트와 서버 캐싱 계층에 걸쳐 통합해서 사용할 수 있어요. 즉, 캐싱 관련 설정을 한 번만 해주면 어디서든 똑같이 적용된다는 뜻이죠.\n\n캐싱을 더 자세히 알고 싶다면 cacheLife와 cacheTag API 문서도 꼭 참고해보세요. 여기에 캐시 유지 기간이나 태그를 지정하는 방법들이 자세히 나와 있어서요.\n\n## 예시\n\n### use cache로 전체 라우트 캐싱하기\n\n(이 부분부터는 실제 코드 예시나 사용법을 자연스럽게 이어서 작성하면 좋아요.)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n전체 라우트를 미리 렌더링(prerendering)하고 싶다면, 레이아웃(layout)과 페이지(page) 파일 맨 위에 `use cache`를 추가해주면 돼요. 각각의 세그먼트(segments)는 애플리케이션에서 개별 진입점(entry points)으로 간주되고, 각각 독립적으로 캐시가 적용됩니다.\n\n```js\n'use cache'\n\nexport default function Layout({ children }: { children: ReactNode }) {\n  return <div>{children}</div>\n}\n```\n\n여기서 중요한 점! 페이지 파일에 임포트해서 중첩된 컴포넌트들은 페이지가 가진 캐시 동작을 그대로 상속받아요.\n\n```js\n'use cache'\n\nasync function Users() {\n  const users = await fetch('/api/users')\n  // users를 활용해서 렌더링 작업 수행\n}\n\nexport default function Page() {\n  return (\n    <main>\n      <Users />\n    </main>\n  )\n}\n```\n\n조금 더 쉽게 정리하자면, `use cache`를 쓰면 해당 레이아웃이나 페이지가 요청 시마다 새로 렌더링 되는 게 아니라, 한 번 렌더링된 결과를 저장했다가 다음에 같은 요청이 들어오면 저장해둔 캐시를 바로 보여줘서 성능이 훨씬 좋아져요. 다만, 캐시가 적용된 컴포넌트 내부에서 사용하는 데이터가 자주 바뀐다면 그에 맞춰서 캐시를 재검증하거나 적절히 관리해주는 것이 중요합니다.  \n\n이 기능을 통해 SSR(Server Side Rendering)하면서도 서버 부하를 줄이고 빠른 응답을 기대할 수 있으니, 복잡한 데이터 랜더링이 필요한 앱이라면 적극 활용해보세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n좋은 정보 한 가지 알려드릴게요!\n\n만약 use cache를 레이아웃(layout)이나 페이지에만 추가한다면, 그 특정 경로(route) 세그먼트와 거기서 임포트된 컴포넌트들만 캐시가 됩니다. 그런데 만약 경로 내 중첩된 자식 컴포넌트 중에 Dynamic API를 사용하는 컴포넌트가 있다면, 해당 경로는 prerendering(미리 렌더링) 기능을 자동으로 포기하게 돼요.\n\n---\n\n### use cache로 컴포넌트 출력값 캐싱하기\n\nuse cache 훅을 컴포넌트 단위에서 사용하면, 컴포넌트 내부에서 하는 fetch 요청이나 계산 결과를 캐싱할 수 있습니다. 이 캐시는 컴포넌트에 전달된 props가 직렬화한 결과가 동일할 때마다 재사용돼요. 덕분에 불필요한 네트워크 요청이나 리렌더링을 막아서 성능 최적화에 유리합니다.\n\n아래는 예시 코드입니다:\n\n```js\nexport async function Bookings({ type = 'haircut' }: BookingsProps) {\n  async function getBookingsData() {\n    // type을 쿼리 파라미터에 넣어 API 호출\n    const data = await fetch(`/api/bookings?type=${encodeURIComponent(type)}`)\n    return data\n  }\n  return // 실제 렌더링할 JSX를 여기에 작성\n}\n\ninterface BookingsProps {\n  type: string\n}\n```\n\n여기서 캐싱을 제대로 하려면 `type` 값이 바뀔 때마다 fetch가 다시 호출돼야 하겠죠? 그래서 props를 정확히 전달하고, props가 바뀌지 않는 한 데이터는 재활용됩니다.\n\n---\n\n### 덧붙여서\n\n- use cache는 React Server Components 환경에서 많이 쓰이고, fetch와 연계해서 서버에서 데이터를 미리 받아두는데 적합해요.\n- 클라이언트 측에서도 비슷한 기능을 원한다면 SWR, React Query 같은 라이브러리를 활용할 수 있답니다.\n- 또한, 캐시 무효화 전략도 꼭 고민해보세요. 데이터가 자주 바뀌는 경우 캐시가 너무 오래 남으면 오히려 사용에 혼란을 줄 수 있으니까요.\n\n이렇게 use cache를 잘 활용하면 네트워크 요청 수를 줄이고, 페이지 로딩 속도도 훨씬 개선할 수 있으니 꼭 한 번 적용해보시길 추천합니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### use cache로 함수 출력 값 캐싱하기\n\n`use cache`를 이용하면 비동기 함수 어디에든 캐싱 기능을 쉽게 추가할 수 있어요. 그래서 오직 컴포넌트나 라우트에만 국한되지 않고, 네트워크 요청, 데이터베이스 쿼리, 그리고 시간이 오래 걸리는 계산 결과 등도 캐시할 수 있답니다.\n\n예를 들어, 이런 간단한 데이터 요청 함수가 있다고 할게요:\n\n```js\nexport async function getData() {\n  const data = await fetch('/api/data')\n  return data\n}\n```\n\n여기에 `use cache`를 적용하면 매번 서버에 요청하지 않고, 캐시된 결과를 바로 받을 수 있어서 성능이 확실히 좋아집니다.\n\n실무에서는 API 요청이 많거나, DB 쿼리 결과가 자주 변하지 않을 때 이런 캐시를 적절히 써주는 게 매우 효과적이에요. 다만, 데이터가 자주 바뀐다면 캐시 만료 전략도 잘 고려해야겠죠? 예를 들면 캐시 TTL(Time To Live)을 정하거나, 상황에 따라 캐시를 강제로 갱신하는 방식이 이에요.\n\n---\n\n### Interleaving (인터리빙)\n\n(다음에 이어서 설명을 드릴게요! 만약 인터리빙이라는 개념이 생소하다면, 쉽게 말해 여러 작업을 섞어서 동시에 처리하는 방식을 의미합니다. 예를 들어, 서버에서 여러 비동기 요청을 순차적으로 기다리지 않고, 중간에 처리할 수 있는 작업을 끼워 넣어 처리 속도를 높이는 것이죠.)\n\n더 궁금한 게 있다면 언제든 물어봐 주세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n캐시 가능한 함수에 직렬화가 불가능한(non-serializable) 인자를 넘겨야 할 때, 이 인자들을 children으로 전달하면 좋아요. 이렇게 하면 children의 참조가 바뀌어도 캐시에는 영향을 주지 않거든요.\n\n예를 들어, 아래 코드를 한번 살펴볼게요.\n\n```jsx\nexport default async function Page() {\n  const uncachedData = await getData()\n  return (\n    <CacheComponent>\n      <DynamicComponent data={uncachedData} />\n    </CacheComponent>\n  )\n}\n\nasync function CacheComponent({ children }: { children: ReactNode }) {\n  'use cache'\n  const cachedData = await fetch('/api/cached-data')\n  return (\n    <div>\n      <PrerenderedComponent data={cachedData} />\n      {children}\n    </div>\n  )\n}\n```\n\n여기서 `CacheComponent`는 'use cache' 함수로 동작하면서도, children으로 전달된 `DynamicComponent`의 데이터는 캐시 영향 없이 렌더링할 수 있어요. 즉, 캐시된 데이터와 캐시되지 않은 데이터를 함께 다룰 때 유용하죠!\n\n---\n\n또한, 서버 액션(Server Actions)을 캐시된 컴포넌트에 넘겨주고, 그걸 클라이언트 컴포넌트에게 전달할 수도 있어요. 이때 중요한 점은 캐시 함수 내부에서 서버 액션을 바로 호출하면 안 된다는 것! 직접 호출하지 않고, 함수 참조만 넘겨줘야 합니다.\n\n```jsx\nimport ClientComponent from './ClientComponent'\n\nexport default async function Page() {\n  const performUpdate = async () => {\n    'use server'\n    // 서버 쪽 업데이트 작업\n    await db.update(...)\n  }\n\n  return <CacheComponent performUpdate={performUpdate} />\n}\n\nasync function CacheComponent({\n  performUpdate,\n}: {\n  performUpdate: () => Promise<void>\n}) {\n  'use cache'\n  // performUpdate를 여기서 호출하지 마세요!\n  return <ClientComponent action={performUpdate} />\n}\n```\n\n이렇게 하면, 서버 액션 함수를 안전하게 클라이언트 컴포넌트에 props로 넘길 수 있고, 실제 호출은 클라이언트 쪽에서 일어나게 됩니다. React Server Components 환경에서 서버 함수와 클라이언트 함수의 역할 분리가 명확해지는 좋은 방법이죠!\n\n---\n\n요약하자면,\n\n- **children을 이용해 non-serializable 데이터를 캐시 영향 없이 전달하기**\n- **캐시 함수에 서버 액션을 넘길 때, 내부에서 호출하지 말고 함수 참조만 전달하기**\n\n이 두 가지를 잘 활용하면, Next.js 13+의 서버 컴포넌트와 클라이언트 컴포넌트 연동을 깔끔하고 효율적으로 할 수 있답니다!\n\n필요하다면 여러분 프로젝트에 맞게 캐시 전략을 조금씩 조정해가면서 써보세요. 개발하다 보면 이 패턴들이 점점 익숙해질 거예요 :)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 코드는 Next.js 13에서 \"use client\" 디렉티브를 사용한 클라이언트 컴포넌트를 정의하고 있어요. \n\n간단하게 설명하자면, 이 컴포넌트는 action이라는 비동기 함수를 props로 받아서, 버튼 클릭 시 이 함수를 실행하는 역할을 합니다.\n\n조금 더 풀어보면:\n\n- `'use client'` : Next.js 13에서는 React 서버 컴포넌트가 기본이에요. 그런데 클라이언트에서 직접 상호작용을 해야 할 경우, `\"use client\"`라는 지시자를 넣어 클라이언트 전용 코드임을 알려줘야 해요.\n- `action: () => Promise<void>` 타입은, 매개변수로 아무것도 받지 않고, Promise를 반환하는 비동기 함수임을 나타내요.\n- 버튼 클릭하면 `action`이 실행되고, 그 작업이 끝나면 아무 값도 반환하지 않는 구조입니다.\n\n여기서 조금 더 팁을 드리자면:\n\n- `onClick` 핸들러에 async 함수를 바로 넘겨도 되지만, 만약 에러 처리를 하고 싶다면 내부에서 try/catch를 사용하는 게 좋아요.\n- 버튼 클릭 시 로딩 상태 등을 관리하는 상태를 추가하면 UX가 더 좋아집니다. 예를 들어, 버튼이 눌렸을 때 \"Loading...\" 상태를 보여주거나 버튼을 비활성화시킬 수 있어요.\n\n아래는 약간 개선한 예시입니다:\n\n```tsx\n'use client'\n\nimport { useState } from 'react'\n\nexport default function ClientComponent({\n  action,\n}: {\n  action: () => Promise<void>\n}) {\n  const [loading, setLoading] = useState(false)\n\n  const handleClick = async () => {\n    setLoading(true)\n    try {\n      await action()\n    } catch (error) {\n      console.error('업데이트 중 에러 발생:', error)\n      // 사용자가 알 수 있도록 UI에 에러 표시를 추가할 수도 있어요.\n    } finally {\n      setLoading(false)\n    }\n  }\n\n  return (\n    <button onClick={handleClick} disabled={loading}>\n      {loading ? 'Updating...' : 'Update'}\n    </button>\n  )\n}\n```\n\n이렇게 하면 사용자 입장에서 업데이트 중임을 알 수 있고, 여러번 중복 클릭도 막을 수 있답니다.\n\n이 코드와 개념들을 참고해서 상황에 맞게 응용해보세요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":17},{"title":"Next.js 15로 만드는 2025년 최신 Progressive Web Application (PWA)","description":"","date":"2025-04-22 02:09","slug":"2025-04-22-ProgressiveWebApplicationsPWA","content":"\n\n# 프로그레시브 웹 앱 (PWA)란?\n\n프로그레시브 웹 앱(PWA)은 웹 애플리케이션의 접근성과 범위를 그대로 가지면서, 네이티브 모바일 앱처럼 부드럽고 풍부한 사용자 경험을 제공하는 기술이에요. Next.js 같은 프레임워크와 함께 사용하면, 여러 플랫폼에서 작동하는 앱을 단일 코드베이스로 만들 수 있고, 별도의 앱 스토어 심사 과정을 거치지 않아도 되죠.\n\nPWA의 장점은 크게 세 가지예요:\n\n| 장점 | 설명 |\n|---|---|\n| 즉시 업데이트 배포 | 앱 스토어 승인 없이 웹사이트 업데이트하듯 바로 적용할 수 있어요. 사용자는 항상 최신 버전을 바로 받아볼 수 있죠. |\n| 단일 코드베이스로 크로스 플랫폼 지원 | 안드로이드, iOS, 데스크탑 등 다양한 기기에서 같은 코드를 사용해 앱을 만들 수 있어 개발 속도가 빨라져요. |\n| 네이티브와 같은 기능 제공 | 홈 화면에 설치하기, 푸시 알림 같은 기능을 지원해 앱 같은 직관적인 경험을 제공할 수 있어요. |\n\n사실 PWA는 요즘 모바일 환경에서 사용자 접근성을 높이고, 유지보수를 간편하게 하는 데 매우 유용해요. 특히, 네이티브 앱 개발 비용이나 복잡성을 줄이고 싶을 때 강력한 대안이 될 수 있으니, Next.js로 시작해보는 걸 추천드립니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## Next.js로 PWA 만들기\n\n### 1. 웹 앱 매니페스트(Manifest) 만들기\n\nNext.js에서는 App Router를 활용해 웹 앱 매니페스트를 쉽게 생성할 수 있도록 기본 지원을 제공하고 있어요. 여기서 웹 앱 매니페스트란, PWA(Progressive Web App)의 아이콘, 앱 이름, 시작 URL 등 기본 정보를 담는 JSON 파일을 말하죠.\n\nNext.js에서는 정적인 파일로 만들 수도 있고, 필요에 따라 동적으로 매니페스트를 생성할 수도 있어요.\n\n예를 들어 `app/manifest.ts` 혹은 `app/manifest.json` 파일을 이렇게 만들어볼 수 있습니다:\n\n| 파일명          | 설명                          |\n|-----------------|-------------------------------|\n| `app/manifest.ts`  | TypeScript로 동적 매니페스트 생성  |\n| `app/manifest.json` | 정적인 JSON 파일로 매니페스트 작성  |\n\n---\n\n> 참고로, 동적 매니페스트를 만들면 사용자 설정이나 환경 변수에 따라 앱 이름이나 아이콘을 다르게 보여줄 수 있어 유용해요.  \n> 요즘은 PWA가 일반 웹앱보다 앱처럼 동작하는 경험을 제공하기 때문에, 앱처럼 보이게 하는 매니페스트 설정이 중요하답니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이번에는 Next.js에서 PWA(Progressive Web App)를 만들 때 사용되는 manifest 파일에 대해 이야기해볼게요.\n\n위 코드에서 보시는 manifest 함수는 PWA의 메타 정보를 담고 있어요. 간단히 말하면, 이 파일은 여러분의 앱이 스마트폰 홈 화면에 아이콘처럼 설치될 때 필요한 정보들을 담고 있죠. 앱 이름, 아이콘 이미지, 시작 경로, 화면 표시 방식, 배경색과 테마 색 등이 들어갑니다.\n\n```ts\n| 키             | 설명                                               |\n|----------------|----------------------------------------------------|\n| name           | 앱의 전체 이름                                           |\n| short_name     | 아이콘 아래에 표시될 짧은 이름                         |\n| description    | 앱에 대한 설명                                          |\n| start_url      | 앱이 시작될 때의 URL (보통 루트 경로 '/'를 넣음)          |\n| display        | 앱 실행 시 화면 표시 방식 (standalone이면 독립 실행 앱처럼 보임) |\n| background_color | 앱 실행 시 배경색                                         |\n| theme_color    | 모바일 브라우저의 주소창 색상 등 테마 색상                      |\n| icons          | 앱 아이콘 이미지 파일들 (여러 사이즈를 넣어야함)                   |\n```\n\n여기서 중요한 건, 아이콘을 여러 해상도별로 준비해야 한다는 점이에요. 왜냐면 기기별로 해상도가 다르기 때문에 적절한 아이콘이 필요하거든요. 그래서 보통 favicon 생성기 같은 온라인 툴을 이용해서 아이콘 세트를 만들고, public 폴더에 넣는 방식을 많이 씁니다.\n\n팁을 하나 드리자면, 아이콘 만들 때 단순히 크기만 맞춘다고 끝나는 게 아니고, 투명 배경(PNG)이나 마스크 아이콘을 따로 준비해야 완성도 높은 PWA가 될 수 있어요. 특히 iOS는 조금 까다로워서 별도의 아이콘 설정이 필요할 때도 있으니 참고하세요!\n\n---\n\n### 다음으로: 웹 푸시 알림(Web Push Notifications) 구현하기\n\nPWA라고 해서 앱 실행 중에만 알림을 받을 수 있는 건 아니에요. 웹 푸시 알림을 구현해서 사용자가 앱을 닫았어도 중요한 소식이 있으면 알림을 띄울 수 있답니다. 이 기능은 사용자 참여도를 크게 높여주니 꼭 챙겨보세요!\n\n그럼 웹 푸시 알림 구현에 대해서도 곧 다뤄보겠습니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n웹 푸시 알림(Web Push Notifications)은 최신 브라우저 대부분에서 지원되고 있어요. 특히 아래 환경에서 쓸 수 있습니다:\n\n| 플랫폼 / 브라우저                | 지원 버전                             |\n|---------------------------|----------------------------------|\n| iOS                         | 16.4 이상, 홈 화면에 설치된 앱         |\n| Safari                      | 16, macOS 13 이상                     |\n| 크로미엄 기반 브라우저(Chrome, Edge 등) | 최신 버전                           |\n| Firefox                     | 최신 버전                           |\n\n덕분에 PWA(Progressive Web Apps)가 네이티브 앱 못지않은 훌륭한 대안으로 자리 잡았죠. 심지어 오프라인 기능 없이도 설치 유도(install prompt)를 띄울 수 있어서 더 편리해졌답니다.\n\n웹 푸시 알림의 가장 큰 장점은 사용자가 앱을 적극적으로 사용하지 않을 때도 다시 관심을 끌어올 수 있다는 점인데요, 결국 사용자 리텐션 향상에 아주 효과적이에요.\n\n자, 이제 Next.js 앱에 웹 푸시 알림을 어떻게 적용할 수 있는지 간단히 소개할게요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n자, 이번에 Next.js 앱의 메인 페이지 컴포넌트 app/page.tsx를 만들어 볼게요. 코드가 길어질 수 있어서 이해하기 쉽게 나눠서 설명할 예정이에요.\n\n먼저 필요한 import와 유틸 함수를 추가해줍니다. 여기서 Server Actions라고 하는 subscribeUser, unsubscribeUser, sendNotification 함수는 아직 구현 안 돼 있어도 일단 그냥 둬도 괜찮아요. 차근차근 만들어가면 되니까요.\n\n```tsx\n'use client'\n\nimport { useState, useEffect } from 'react'\nimport { subscribeUser, unsubscribeUser, sendNotification } from './actions'\n\n// VAPID 키를 Push 구독에 사용할 수 있는 Uint8Array로 변환하는 함수\nfunction urlBase64ToUint8Array(base64String: string) {\n  const padding = '='.repeat((4 - (base64String.length % 4)) % 4)\n  const base64 = (base64String + padding).replace(/-/g, '+').replace(/_/g, '/')\n\n  const rawData = window.atob(base64)\n  const outputArray = new Uint8Array(rawData.length)\n\n  for (let i = 0; i < rawData.length; ++i) {\n    outputArray[i] = rawData.charCodeAt(i)\n  }\n  return outputArray\n}\n```\n\n위 함수는 Push 알림 등록 시 서버의 VAPID 공개키(보통 환경변수로 관리)를 브라우저에서 사용할 수 있는 형식으로 바꿔주기 위한 거예요. 이 부분은 조금 어렵게 느껴질 수도 있지만, 푸시 알림을 웹 표준에 맞게 구현하는 데 꼭 필요합니다.\n\n다음은 실제로 사용자가 푸시 알림을 구독(subscribe), 구독 해제(unsubscribe), 그리고 테스트 알림을 보내는 UI 및 로직을 담은 컴포넌트입니다.\n\n```tsx\nfunction PushNotificationManager() {\n  const [isSupported, setIsSupported] = useState(false)\n  const [subscription, setSubscription] = useState<PushSubscription | null>(null)\n  const [message, setMessage] = useState('')\n\n  useEffect(() => {\n    // Push API와 Service Worker 지원 여부 체크\n    if ('serviceWorker' in navigator && 'PushManager' in window) {\n      setIsSupported(true)\n      registerServiceWorker()\n    }\n  }, [])\n\n  // Service Worker 등록 함수\n  async function registerServiceWorker() {\n    const registration = await navigator.serviceWorker.register('/sw.js', {\n      scope: '/',\n      updateViaCache: 'none',\n    })\n    const sub = await registration.pushManager.getSubscription()\n    setSubscription(sub)\n  }\n\n  // 푸시 알림 구독 함수\n  async function subscribeToPush() {\n    const registration = await navigator.serviceWorker.ready\n    const sub = await registration.pushManager.subscribe({\n      userVisibleOnly: true,\n      applicationServerKey: urlBase64ToUint8Array(\n        process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY!\n      ),\n    })\n    setSubscription(sub)\n\n    // 푸시 구독 정보를 서버에 전송 (서버 액션 호출)\n    const serializedSub = JSON.parse(JSON.stringify(sub))\n    await subscribeUser(serializedSub)\n  }\n\n  // 푸시 알림 구독 해제 함수\n  async function unsubscribeFromPush() {\n    await subscription?.unsubscribe()\n    setSubscription(null)\n    await unsubscribeUser()\n  }\n\n  // 테스트 알림 전송 함수\n  async function sendTestNotification() {\n    if (subscription) {\n      await sendNotification(message)\n      setMessage('')\n    }\n  }\n\n  if (!isSupported) {\n    return <p>Push notifications are not supported in this browser.</p>\n  }\n\n  return (\n    <div>\n      <h3>Push Notifications</h3>\n      {subscription ? (\n        <>\n          <p>You are subscribed to push notifications.</p>\n          <button onClick={unsubscribeFromPush}>Unsubscribe</button>\n          <input\n            type=\"text\"\n            placeholder=\"Enter notification message\"\n            value={message}\n            onChange={(e) => setMessage(e.target.value)}\n          />\n          <button onClick={sendTestNotification}>Send Test</button>\n        </>\n      ) : (\n        <>\n          <p>You are not subscribed to push notifications.</p>\n          <button onClick={subscribeToPush}>Subscribe</button>\n        </>\n      )}\n    </div>\n  )\n}\n```\n\n### 짧게 정리해볼게요!\n\n| 기능 | 설명 |\n| -------- | ------ |\n| `isSupported` | 이 브라우저가 푸시 알림과 service worker를 지원하는지 여부를 알려줘요 |\n| `subscription` | 현재 푸시 알림 구독 상태를 저장해요 |\n| `registerServiceWorker()` | 서비스 워커를 등록하고 기존 구독이 있다면 불러와요 |\n| `subscribeToPush()` | 새 구독을 만들고 서버에 구독 정보를 보내요 |\n| `unsubscribeFromPush()` | 구독해제하고 서버에도 알려줘요 |\n| `sendTestNotification()` | 입력한 메시지로 테스트 푸시 알림을 보내요 |\n\n---\n\n사실 이 기능을 완성하려면 `./actions`에 있는 서버쪽 함수들도 만들어야 하고, service worker 파일(sw.js)도 준비해야 해요. 다음 글에서 이어서 어떻게 Service Worker를 구성하는지, 그리고 서버 액션을 작성하는 방법도 소개할게요.\n\n웹 푸시 알림은 사용자 경험을 한층 업그레이드시켜주지만 구현 난이도가 약간 있는 편이니까, 천천히 따라오세요! 필요하면 언제든 질문해 주세요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마지막으로, iOS 기기 사용자들에게 홈 화면에 앱을 설치하도록 안내하는 메시지를 띄우는 컴포넌트를 만들어볼게요. 그리고 이 메시지는 앱이 이미 설치되어 있을 때는 보이지 않도록 설정했어요.\n\n```jsx\nfunction InstallPrompt() {\n  const [isIOS, setIsIOS] = useState(false);\n  const [isStandalone, setIsStandalone] = useState(false);\n\n  useEffect(() => {\n    // iOS 기기인지 확인 (iPad, iPhone, iPod)\n    setIsIOS(\n      /iPad|iPhone|iPod/.test(navigator.userAgent) && !(window as any).MSStream\n    );\n\n    // 앱이 독립 실행 모드(홈 화면에 설치된 상태)인지 체크\n    setIsStandalone(window.matchMedia('(display-mode: standalone)').matches);\n  }, []);\n\n  // 이미 설치되어 있으면 설치 안내 UI를 보여주지 않음\n  if (isStandalone) {\n    return null;\n  }\n\n  return (\n    <div>\n      <h3>앱 설치하기</h3>\n      <button>홈 화면에 추가</button>\n      {isIOS && (\n        <p>\n          iOS 기기에서는 아래 방법으로 앱을 설치할 수 있어요. <br />\n          공유 버튼{' '}\n          <span role=\"img\" aria-label=\"share icon\">\n            ⎋\n          </span>{' '}\n          을 누른 후 \"홈 화면에 추가\" <span role=\"img\" aria-label=\"plus icon\">➕</span> 를 선택하세요.\n        </p>\n      )}\n    </div>\n  );\n}\n\nexport default function Page() {\n  return (\n    <div>\n      <PushNotificationManager />\n      <InstallPrompt />\n    </div>\n  );\n}\n```\n\n---\n\n위 코드에서 재미있는 점은 iOS에서는 아직 자동으로 홈 화면에 설치하는 방법이 없다는 거예요. 그래서 직접 사용자가 공유 버튼을 눌러서 '홈 화면에 추가'를 선택하도록 안내해야 하죠. 그리고 `window.matchMedia('(display-mode: standalone)')`를 활용하면, 현재 앱이 이미 독립 실행형 앱처럼 실행 중인지 쉽게 알 수 있어요.\n\n> 참고로, Android 같은 경우 PWA 설치를 위한 브라우저 이벤트를 이용해서 자동 설치 UI를 보여줄 수 있는데, iOS는 아직 그런 기능이 없답니다. 그래서 iOS 사용자에게는 이처럼 직접적인 설명이 꼭 필요해요.\n\n---\n\n자, 이제 이 컴포넌트에서 호출할 Server Actions를 만들어봅시다!\n\n### 3. Server Actions 구현하기\n\n(다음에 이어서 Server Actions를 어떻게 작성할지 소개할게요.)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n새로운 파일 app/actions.ts를 만들어서 구독 생성, 구독 삭제, 알림 전송 기능을 구현하는 코드를 작성해볼게요.\n\n```ts\n'use server'\n\nimport webpush from 'web-push'\n\n// VAPID 키 정보 설정 — 알림 전송 시 인증을 위해 필요해요.\nwebpush.setVapidDetails(\n  'mailto:your-email@example.com',\n  process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY!,\n  process.env.VAPID_PRIVATE_KEY!\n)\n\n// 간단하게 메모리 내에 구독을 저장하도록 했지만,\n// 실제 서비스 환경에서는 DB에 저장해야 영속성을 확보할 수 있어요.\nlet subscription: PushSubscription | null = null\n\n// 구독 정보 등록 함수\nexport async function subscribeUser(sub: PushSubscription) {\n  subscription = sub\n  // TODO: 실제 서비스라면 DB에 저장하는 로직 추가 필요\n  // 예: await db.subscriptions.create({ data: sub })\n  return { success: true }\n}\n\n// 구독 정보 삭제 함수\nexport async function unsubscribeUser() {\n  subscription = null\n  // TODO: DB에서 구독정보 삭제하는 로직 추가 필요\n  // 예: await db.subscriptions.delete({ where: { ... } })\n  return { success: true }\n}\n\n// 알림 전송 함수\nexport async function sendNotification(message: string) {\n  if (!subscription) {\n    throw new Error('구독 정보가 없습니다')\n  }\n\n  try {\n    await webpush.sendNotification(\n      subscription,\n      JSON.stringify({\n        title: 'Test Notification',\n        body: message,\n        icon: '/icon.png',\n      })\n    )\n    return { success: true }\n  } catch (error) {\n    console.error('푸시 알림 전송 중 오류 발생:', error)\n    return { success: false, error: '알림 전송 실패' }\n  }\n}\n```\n\n여기서 핵심은 web-push 라이브러리를 사용해서 서버에서 푸시 알림을 보내는 거예요. 그리고 VAPID 키는 푸시 알림 서비스 제공자에게 내 API 권한을 증명하는 데 필요하니 꼭 환경변수로 설정해줘야 해요.\n\n또, subscribeUser 함수로 구독 정보를 저장하긴 하는데, 이 예제는 간단하게 메모리에 저장하는 구조라서 서버가 재시작하면 초기화돼 버립니다. 실제 서비스라면 데이터베이스에 저장해서 여러 사용자의 구독 상태를 관리할 수 있도록 해야 해요.\n\n마지막으로 알림을 실제로 받는 쪽은 서비스 워커(Service Worker)가 담당하는데, 이 부분은 다음 단계에서 구현합니다. 그러니까 서버가 알림 요청을 보내면, 클라이언트 서비스 워커가 백그라운드에서 알림을 보여주게 되죠.\n\n친절하게 환경설정과 구독 데이터를 다루는 부분을 잘 챙겨서 완성하면, 꽤 훌륭한 푸시 알림 시스템을 갖출 수 있을 거예요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 4. VAPID 키 생성하기\n\nWeb Push API를 사용하기 위해서는 VAPID 키를 만들어야 해요. 이 키는 푸시 서버와 브라우저 간의 신뢰를 보장해주는 역할을 하죠. 가장 간단한 방법은 `web-push`라는 CLI(Command Line Interface)를 사용하는 건데요,\n\n먼저, `web-push`를 전역으로 설치해봅시다!\n\n```bash\nnpm install -g web-push\n```\n\n> npm에 익숙하지 않다면, `npm`은 Node.js 환경에서 패키지를 설치하고 관리할 수 있는 도구예요.  \n> - `-g` 옵션은 전역(global) 설치로, 어떤 프로젝트에서도 CLI 명령어를 바로 사용할 수 있게 해줍니다.\n\n이제 `web-push` 명령어를 사용해서 VAPID 키를 쉽게 만들 수 있답니다! 앞으로 푸시 알림을 구현하면서 꼭 필요한 작업이니 차근차근 따라해보세요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nVAPID 키를 생성하려면 아래 명령어를 터미널에 입력해 주세요:\n\n```bash\nweb-push generate-vapid-keys\n```\n\n그럼 public key와 private key가 출력될 텐데, 이 키들을 복사해서 프로젝트 루트에 있는 `.env` 파일에 붙여 넣으면 됩니다. 예시는 다음과 같아요:\n\n```js\nNEXT_PUBLIC_VAPID_PUBLIC_KEY=your_public_key_here\nVAPID_PRIVATE_KEY=your_private_key_here\n```\n\n여기서 `NEXT_PUBLIC_VAPID_PUBLIC_KEY`는 클라이언트 쪽에서도 접근할 수 있도록 `NEXT_PUBLIC_` 접두어를 붙인 환경 변수입니다. 보통은 public key만 클라이언트에서 필요하고, private key는 서버에서만 안전하게 사용하니 꼭 구분해서 사용하세요.\n\n추가로, `.env` 파일을 깃허브 같은 원격 저장소에 올리지 않도록 `.gitignore`에 포함시키는 것도 잊지 마시고요! 보안에 매우 중요한 키들이니까요.\n\n만약 아직 `web-push` 패키지를 설치하지 않았다면, 다음 명령어로 설치해 주세요:\n\n```bash\nnpm install -g web-push\n```\n\n그러면 전역 명령어로 `web-push`를 사용할 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 5. 서비스 워커 만들기\n\n서비스 워커는 웹 알림(push notification)이나 백그라운드 동작 등에서 중요한 역할을 하는데요, 이번에는 `public/sw.js` 파일을 만들어서 푸시 알림을 받아 처리하는 예제를 살펴볼게요.\n\n```js\nself.addEventListener('push', function (event) {\n  if (event.data) {\n    const data = event.data.json();\n    const options = {\n      body: data.body,\n      icon: data.icon || '/icon.png',\n      badge: '/badge.png',\n      vibrate: [100, 50, 100],\n      data: {\n        dateOfArrival: Date.now(),\n        primaryKey: '2',\n      },\n    };\n    event.waitUntil(self.registration.showNotification(data.title, options));\n  }\n});\n\nself.addEventListener('notificationclick', function (event) {\n  console.log('Notification click received.');\n  event.notification.close();\n  event.waitUntil(clients.openWindow('https://your-website.com'));\n});\n```\n\n여기서 핵심을 몇 가지 짚어볼게요:\n\n- `push` 이벤트 리스너는 서버에서 푸시 메시지를 받으면 실행됩니다. `event.data.json()`으로 전달받은 데이터를 파싱해서 알림에 필요한 내용(제목, 내용, 아이콘 등)을 설정해요.\n- 알림 옵션에 `vibrate`를 넣어 진동 패턴도 줄 수 있어서 사용자 경험을 더 좋게 할 수 있답니다.\n- `notificationclick` 이벤트는 사용자가 알림을 클릭했을 때 발생해요. 여기서는 알림을 닫고 지정한 웹사이트를 새 탭에서 열도록 처리하고 있죠.\n\n### 추가 팁!\n\n- 아이콘 이미지 경로는 실제 프로젝트 구조에 맞게 조정해 주세요.\n- 보통 알림에 `tag`나 `actions` 같은 속성을 더 넣어서 알림 그룹핑이나 버튼 클릭도 처리할 수 있어요.\n- 서비스 워커 파일은 HTTPS 환경에서만 작동하니, 개발 시 로컬 호스트(127.0.0.1 등)나 HTTPS 서버를 사용해야 합니다.\n- 푸시 알림을 잘 구현하려면 서비스 워커 등록과 푸시 구독(subscription) 과정도 같이 구현해야 해요. 다음에는 그 부분에 대해 다뤄볼게요!\n\n서비스 워커가 익숙하지 않다면, 기본적인 흐름은 웹 브라우저에서 백그라운드 이벤트를 받고 처리할 수 있는 스크립트라고 생각하면 편해요. 우리의 앱이 더 똑똑해지는 순간이죠!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 알림 아이콘을 커스텀하고 싶을 때는 `icon`과 `badge` 속성을 사용하면 돼요. 예를 들어, 작은 배지 아이콘이나 알림 아이콘을 따로 지정할 수 있어서 더 직관적인 알림을 만들 수 있답니다.\n- 진동 패턴(`vibrate`)도 조절할 수 있어서 지원하는 기기에서 다양한 진동 알림을 설정할 수 있어요. 예를 들어 `[200, 100, 200]` 같은 배열로 진동-멈춤-진동 패턴을 만들 수 있죠.\n- `data` 속성을 활용하면 알림에 추가 데이터를 붙여서, 클릭했을 때 그 데이터를 참고할 수도 있어요. 예를 들어, 특정 게시물 ID나 사용자 정보를 넘겨서 알림 클릭 시 상세 페이지로 바로 이동하게 할 수 있죠.\n\n그리고 꼭 서비스 워커를 여러 기기와 브라우저 환경에서 잘 동작하는지 꼼꼼하게 테스트해 보세요. 또, 알림 클릭 이벤트(`notificationclick`) 안에서 사용하는 URL(`https://your-website.com`)은 꼭 여러분 앱에 맞게 실제 주소로 바꿔줘야 해요.\n\n### 6. 홈 화면에 추가하기\n\n2단계에서 만든 InstallPrompt 컴포넌트는 iOS 기기 사용자들에게 홈 화면에 앱을 설치하라는 안내 메시지를 보여줘요. iOS는 안드로이드처럼 일반적인 PWA 설치 프로세스가 다르기 때문에, 이렇게 직접 메시지를 띄워 알려주는 게 필요합니다. \n\n사용자가 홈 화면에 앱을 추가하면 더 네이티브 앱 같은 경험을 할 수 있어서, 사용자 참여도와 편리함이 확 올라가게 됩니다. 만약 여러분이 PWA를 개발 중이라면, 이 부분도 꼭 신경 쓰니까 참고하세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모바일 홈 화면에 앱을 설치할 수 있게 하려면 꼭 챙겨야 할 두 가지가 있어요:\n\n- 유효한 웹 앱 매니페스트 (1단계에서 만들었죠)\n- 웹사이트가 HTTPS로 제공되어야 함\n\n요즘 브라우저들은 위 조건만 충족하면 자동으로 설치 안내 팝업을 띄워줘요. 물론 직접 커스텀 설치 버튼을 만들고 싶으면 `beforeinstallprompt` 이벤트를 활용할 수도 있는데요, 이 방법은 크로스 브라우저, 크로스 플랫폼 지원이 완벽하지 않아서(특히 iOS 사파리에서는 작동 안 함) 추천하지는 않아요.\n\n### 7. 로컬 환경에서 테스트하기\n\n앱 배포 전에 로컬 환경에서 제대로 작동하는지 꼭 확인해야 하겠죠? HTTPS가 필수이기 때문에 로컬에서 바로 테스트하려면 약간 손이 필요해요. 보통은 로컬 서버에 SSL 인증서를 적용하거나, 혹은 `localhost`가 HTTPS로 작동하는 개발 도구를 활용하는 방법이 있어요.\n\n예를 들어, [Visual Studio Code의 Live Server](https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer) 같은 플러그인을 사용하면 간단하게 로컬 서버를 띄울 수 있고, `mkcert` 같은 툴로 로컬용 SSL 인증서를 만들어 HTTPS 환경도 만들어 볼 수 있답니다.\n\n그 외에도 크롬 브라우저에서는 `chrome://flags`에서 `Insecure origins treated as secure` 옵션에 로컬 주소를 추가해 HTTPS 없이도 설치 테스트를 해볼 수 있으니, 환경에 맞게 골라서 시도해보세요!\n\n로컬에서 테스트할 때 꼭 스마트폰에서 직접 시도해보고, PWA가 제대로 홈 화면에 추가되고 작동하는지 확인하는 걸 잊지 마세요. 나중에 실제 사용자 환경에서의 문제를 미리 막을 수 있답니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n로컬에서 알림을 제대로 확인하려면 다음 사항들을 꼭 챙겨주세요!\n\n- 로컬 환경에서 HTTPS로 실행 중인지 확인하기  \n  테스트할 때는 `next dev --experimental-https` 명령어를 사용하면 HTTPS 환경에서 개발할 수 있어요.  \n- 사용 중인 브라우저(크롬, 사파리, 파이어폭스 등)에서 알림 권한이 활성화되어 있는지 확인  \n  로컬에서 알림 권한을 요청하면, 꼭 ‘허용’ 버튼을 눌러주세요!  \n- 브라우저 전체에서 알림이 꺼져 있지 않은지도 체크하기  \n- 그래도 알림이 안 뜨면, 다른 브라우저에서 한 번 실행해 보면서 문제를 찾아보세요  \n\n---\n\n### 8. 애플리케이션 보안 강화하기\n\n웹 애플리케이션에서 보안은 정말 중요한 부분이에요. 특히 PWA(Progressive Web App)를 다룰 때는 더더욱 신경 써야 하죠. Next.js를 사용한다면, `next.config.js` 파일을 통해 보안 관련 헤더를 쉽게 설정할 수 있어요.\n\n예를 들어, 아래처럼 보안 헤더를 추가해서 보안을 강화할 수 있답니다:\n\n```js\n// next.config.js 예제\nmodule.exports = {\n  async headers() {\n    return [\n      {\n        source: '/(.*)', // 모든 경로에 대해 적용\n        headers: [\n          {\n            key: 'Content-Security-Policy',\n            value: \"default-src 'self'; img-src *; media-src media1.com media2.com; script-src 'none';\", // Content Security Policy 설정\n          },\n          {\n            key: 'X-Frame-Options',\n            value: 'DENY',  // 클릭재킹 공격 방지\n          },\n          {\n            key: 'X-Content-Type-Options',\n            value: 'nosniff',  // MIME 타입 스니핑 방지\n          },\n          {\n            key: 'Referrer-Policy',\n            value: 'origin-when-cross-origin', // 리퍼러 정보 제한\n          },\n          {\n            key: 'Permissions-Policy',\n            value: 'camera=(), microphone=(), geolocation=()', // 권한 제한\n          },\n        ],\n      },\n    ];\n  },\n};\n```\n\n이렇게 하면 브라우저가 사이트를 더 안전하게 인식할 뿐 아니라, 악성 스크립트나 공격을 예방하는 데 도움이 돼요.  \n사실 보안 설정은 프로젝트마다 요구사항이 조금씩 다르니, 위 예시를 참고해서 필요에 맞게 조절하는 게 좋아요!\n\n그리고 참고로, HTTPS가 기본적으로 보안을 지켜주는 핵심 요소 중 하나이니 꼭 로컬에서도 HTTPS 환경을 구축해서 테스트하세요.요즘은 `next dev --experimental-https` 옵션으로 간단하게 적용할 수 있으니 너무 부담 갖지 않으셔도 됩니다~\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서 HTTP 헤더를 설정하는 코드를 보면, 보안과 관련된 중요한 부분들을 꼼꼼히 챙기고 있네요. 블로그에서 쉽게 설명해 볼게요!\n\n```js\nmodule.exports = {\n  async headers() {\n    return [\n      {\n        source: '/(.*)', // 모든 경로에 적용되는 글로벌 헤더\n        headers: [\n          {\n            key: 'X-Content-Type-Options',\n            value: 'nosniff',\n          },\n          {\n            key: 'X-Frame-Options',\n            value: 'DENY',\n          },\n          {\n            key: 'Referrer-Policy',\n            value: 'strict-origin-when-cross-origin',\n          },\n        ],\n      },\n      {\n        source: '/sw.js', // 서비스 워커에만 적용되는 헤더\n        headers: [\n          {\n            key: 'Content-Type',\n            value: 'application/javascript; charset=utf-8',\n          },\n          {\n            key: 'Cache-Control',\n            value: 'no-cache, no-store, must-revalidate',\n          },\n          {\n            key: 'Content-Security-Policy',\n            value: \"default-src 'self'; script-src 'self'\",\n          },\n        ],\n      },\n    ]\n  },\n}\n```\n\n### 각 헤더가 무슨 역할을 할까?\n\n| 키                                          | 설명                                                                                       |\n|--------------------------------------------|--------------------------------------------------------------------------------------------|\n| **X-Content-Type-Options: nosniff**        | 브라우저가 MIME 타입을 임의로 추측하지 못하게 막아요. 악성 파일 실행 위험을 줄일 수 있어요.               |\n| **X-Frame-Options: DENY**                   | 내 사이트가 iframe 안에 들어가는 걸 막아서, 클릭재킹 공격(clickjacking)을 방어해요.                    |\n| **Referrer-Policy: strict-origin-when-cross-origin** | 다른 도메인으로 요청 보낼 때 referrer 정보를 최소화해서 개인정보 노출을 줄이고, 적당히 기능도 유지해요.      |\n| **Content-Type: application/javascript; charset=utf-8 (서비스 워커)** | 서비스 워커(sw.js)를 자바스크립트로 올바르게 해석하게 해줘요.                               |\n| **Cache-Control: no-cache, no-store, must-revalidate (서비스 워커)** | 서비스 워커가 캐싱되지 않도록 해서 사용자가 항상 최신 버전을 받도록 만들어요.                        |\n| **Content-Security-Policy: default-src 'self'; script-src 'self' (서비스 워커)** | 콘텐츠 보안 정책을 엄격히 해서, 같은 출처에서만 스크립트를 불러오도록 제한해요.                       |\n\n---\n\n서비스 워커(sw.js)는 PWA(Progressive Web App)의 핵심인데, 캐싱 관리를 제대로 안 하면 업데이트가 제대로 안 될 수도 있어요. 그래서 `Cache-Control` 헤더를 꼼꼼하게 관리하는 게 중요합니다.\n\n그리고 `Content-Security-Policy` 는 사이트를 해킹하려는 악성 스크립트를 막는 데 큰 도움이 돼서, 특히 서비스 워커처럼 중요한 스크립트 파일에 적용하는 게 좋아요.\n\n---\n\n이런 헤더들을 Next.js에서 어떻게 설정하느냐고 어렵게 생각할 수 있지만, `next.config.js`에 위처럼 `headers` 메서드를 추가해 주면 끝! Next.js가 빌드할 때 알아서 적용해 줍니다.\n\n더 자세한 내용은 Next.js 공식 문서에서 [Content Security Policy](https://nextjs.org/docs/advanced-features/security-headers) 부분을 참고하면 좋아요.\n\n---\n\n💡 **추가 팁**  \n- 보안 헤더는 사이트 신뢰도 향상에도 도움돼서, SEO에도 긍정적 영향을 줘요!  \n- HTTPS 환경이라면 `Strict-Transport-Security` 헤더도 꼭 넣어 보세요! (HSTS는 사이트를 HTTPS로만 접속하도록 강제합니다)  \n\n필요한 보안 헤더들을 한 번에 정리해서 적용하니 훨씬 편하고 안전한 사이트 운영, 어렵지 않죠? ;)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 다음 단계: PWA와 Next.js 활용 팁\n\n여러분이 Next.js로 앱을 만들고 있다면, 한 번쯤 고려해볼 만한 내용들을 정리해봤어요. 특히 PWA(Progressive Web App) 기능을 강화하거나, 오프라인 지원, 보안 문제 등을 챙기면서 사용자 경험을 더 끌어올리는 방법들을 소개할게요.\n\n- **PWA 기능 탐색하기**  \n  PWA는 다양한 웹 API를 활용해 더 멋진 기능들을 구현할 수 있어요. 예를 들면, 백그라운드에서 동기화하거나, 주기적으로 데이터를 새로 고치는 ‘periodic background sync’, 또는 파일 시스템 접근이 가능한 ‘File System Access API’ 같은 것들이 있어요. 이런 최신 기능들을 잘 살리면 앱이 훨씬 더 강력해지고 편리해지죠. 참고할 만한 좋은 자료는 [What PWA Can Do Today](https://whatpwacando.today/)라는 사이트가 있는데, 최신 지원 기능과 사례를 잘 정리해뒀으니 꼭 한 번 들여다보세요.\n\n- **정적 내보내기(Static Exports)**  \n  만약 서버를 직접 운영하지 않고, 정적 파일만 배포해서 앱을 운영하고 싶다면 Next.js 설정을 통해 정적 내보내기 기능을 활성화할 수 있어요. 이 경우엔 서버 액션(Server Actions) 대신 외부 API를 호출하는 구조로 바꿔야 하고, 커스텀 헤더도 프록시쪽으로 옮겨야 해요. 관련 내용은 [Next.js Static Export 문서](https://nextjs.org/docs/advanced-features/static-html-export)를 참고하시면 도움이 됩니다.\n\n- **오프라인 지원**  \n  오프라인에서도 앱이 동작하도록 만들고 싶다면 ‘Serwist’라는 플러그인을 고려해볼 수 있어요. Next.js와의 통합 예제가 [Serwist 문서](https://serwist.dev/)에 잘 나와 있으니 참고하세요. 다만, 이 플러그인은 현재 webpack 설정을 직접 만져줘야 하니까 사전에 빌드 시스템을 이해하고 있어야 부담이 적겠죠.\n\n- **보안 고려사항**  \n  서비스 워커(Service Worker)를 사용할 때는 반드시 보안을 신경 써야 해요. HTTPS 프로토콜을 사용하고, 푸시 메시지 출처를 검증하며, 에러 처리도 꼼꼼히 해야 합니다. 혹시라도 보안 취약점이 생기면 사용자의 데이터를 위험하게 만들 수 있으니까요.\n\n- **사용자 경험(UX) 개선**  \n  모든 브라우저가 최신 PWA 기능을 지원하는 건 아니에요. 그래서 프로그레시브 향상(progressive enhancement) 기법을 적용해, 지원하지 않는 환경에서도 기본 기능은 잘 동작하도록 하는 것이 중요해요. 예를 들어, 서비스 워커가 없으면 네트워크 기반 방식으로 fallback 하도록 하는 등의 설계가 필요하겠죠.\n\n---\n\n이렇게 조금씩 PWA 기능을 더하고, 오프라인 지원이나 보안까지 챙기면서 앱을 다듬다 보면 사용자에게 더 좋은 경험을 줄 수 있을 거예요. 혹시 Next.js와 PWA 연동 관련해서 더 궁금한 점 있으면 언제든 질문 주세요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":26},{"title":"Next.js 15 디버깅 가이드 - 오류 추적과 해결 방법","description":"","date":"2025-04-22 02:08","slug":"2025-04-22-Debugging","content":"\n# 디버깅하기\n\n이번 글에서는 Next.js 애플리케이션의 프론트엔드와 백엔드 코드를 어떻게 디버깅할 수 있는지 알려드릴게요. 특히 소스맵(source maps) 지원을 완벽하게 활용해서, VS Code 디버거, 크롬 개발자 도구, 파이어폭스 개발자 도구 같은 도구로 손쉽게 디버깅하는 방법을 다룹니다.\n\n사실 Node.js에 붙일 수 있는 디버거라면 Next.js 앱 디버깅에도 다 쓸 수 있어요. 더 자세한 내용은 [Node.js 디버깅 가이드](https://nodejs.org/en/docs/guides/debugging-getting-started)를 참고해 보시면 큰 도움이 됩니다.\n\n---\n\n## VS Code로 디버깅하기\n\nVS Code는 웹 개발자들 사이에서 가장 많이 쓰는 에디터 중 하나인데요, Next.js 개발 환경에서도 디버거와 연동이 정말 편리해요. 혹시 아직 VS Code에 디버거 익스텐션 설치가 안 되어 있다면, 꼭 설치해두세요!\n\nVS Code에서 Next.js 앱을 디버깅하기 위한 기본적인 설정은 `launch.json` 파일에 디버깅 구성을 추가하는 거예요. 이 파일은 `.vscode` 폴더 안에 위치해 있습니다.\n\n```json\n{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"type\": \"node\",\n      \"request\": \"launch\",\n      \"name\": \"Next.js: Launch Server\",\n      \"runtimeExecutable\": \"npm\",\n      \"runtimeArgs\": [\"run\", \"dev\"],\n      \"port\": 9229,\n      \"console\": \"integratedTerminal\",\n      \"cwd\": \"${workspaceFolder}\"\n    },\n    {\n      \"type\": \"chrome\",\n      \"request\": \"launch\",\n      \"name\": \"Next.js: Debug Frontend\",\n      \"url\": \"http://localhost:3000\",\n      \"webRoot\": \"${workspaceFolder}\",\n      \"sourceMaps\": true,\n      \"sourceMapPathOverrides\": {\n        \"webpack:///./*\": \"${workspaceFolder}/*\"\n      }\n    }\n  ]\n}\n```\n\n- 첫 번째 구성은 Next.js 개발 서버를 디버깅 모드로 실행하는 설정이에요. `npm run dev` 명령어를 디버깅 모드로 실행하며, 백엔드 서버에 연결할 수 있도록 포트 9229를 엽니다.\n- 두 번째 구성은 크롬 브라우저를 띄워서 프론트엔드 코드를 디버깅하는 설정이에요. 로컬호스트 3000번 포트(Next.js 기본 포트)에 접속하고, 소스맵을 활용해서 실제 작성한 코드를 보고 디버깅할 수 있도록 해줍니다.\n\n> **팁!** 디버깅을 하다 보면 브레이크포인트가 제대로 안 걸리거나, 소스맵 때문에 헤매는 경우가 있는데요. 위 설정에서 `sourceMapPathOverrides` 부분이 실제 코드 파일 위치와 소스맵 경로를 잘 연결해주니까 꼭 확인하세요.\n\n---\n\n추가로, VS Code는 디버깅할 때 Call Stack, 변수, 워치(Watch), 콘솔 등 유용한 도구들을 한 화면에서 보여주니 디버깅 경험이 훨씬 쾌적해집니다. 특히 서버와 클라이언트 코드가 섞여 있을 때 각각 따로 디버깅할 수 있어서 편리합니다.\n\n다음에는 크롬 개발자 도구나 파이어폭스 개발자 도구로 디버깅하는 방법도 알려드릴게요! 질문이 있으면 댓글에 남겨주세요. 😊\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프로젝트 루트에 `.vscode/launch.json` 파일을 만들어서 다음 내용을 넣어주세요!\n\n```json\n{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"name\": \"Next.js: debug server-side\",\n      \"type\": \"node-terminal\",\n      \"request\": \"launch\",\n      \"command\": \"npm run dev\"\n    },\n    {\n      \"name\": \"Next.js: debug client-side\",\n      \"type\": \"chrome\",\n      \"request\": \"launch\",\n      \"url\": \"http://localhost:3000\"\n    },\n    {\n      \"name\": \"Next.js: debug client-side (Firefox)\",\n      \"type\": \"firefox\",\n      \"request\": \"launch\",\n      \"url\": \"http://localhost:3000\",\n      \"reAttach\": true,\n      \"pathMappings\": [\n        {\n          \"url\": \"webpack://_N_E\",\n          \"path\": \"${workspaceFolder}\"\n        }\n      ]\n    },\n    {\n      \"name\": \"Next.js: debug full stack\",\n      \"type\": \"node\",\n      \"request\": \"launch\",\n      \"program\": \"${workspaceFolder}/node_modules/.bin/next\",\n      \"runtimeArgs\": [\"--inspect\"],\n      \"skipFiles\": [\"<node_internals>/**\"],\n      \"serverReadyAction\": {\n        \"action\": \"debugWithEdge\",\n        \"killOnServerStop\": true,\n        \"pattern\": \"- Local:.+(https?://.+)\",\n        \"uriFormat\": \"%s\",\n        \"webRoot\": \"${workspaceFolder}\"\n      }\n    }\n  ]\n}\n```\n\n> 참고로, VS Code에서 Firefox로 디버깅하려면 `Firefox Debugger` 확장 프로그램을 꼭 설치해야 해요!\n\n그리고 `npm run dev` 명령어는 사용하는 패키지 매니저에 따라 바꿔서 써도 돼요.  \n예를 들어 Yarn을 쓴다면 `yarn dev`, pnpm을 쓴다면 `pnpm dev`로 변경하면 됩니다.\n\n---\n\n### 조금 더 팁을 드리자면!\n\n- **서버 사이드 디버깅**: `\"Next.js: debug server-side\"` 설정은 Next.js 서버 쪽 코드를 디버깅할 때 좋아요. 코드를 수정하고 바로 디버깅할 수 있죠.\n- **클라이언트 사이드 디버깅**: `\"Next.js: debug client-side\"`와 Firefox 버전은 브라우저에서 실행되는 React 컴포넌트 쪽 문제를 잡는 데 유용해요.\n- **풀스택 디버깅**: `\"Next.js: debug full stack\"`은 서버와 클라이언트를 동시에 디버깅 하고 싶을 때 최적이에요. 특히 복잡한 버그를 추적할 때 아주 도움이 됩니다.\n\nVS Code 디버그 설정을 잘 해두면, 브레이크포인트도 걸고 변수도 바로바로 보면서 개발할 수 있어서 디버깅 생산성을 확 올릴 수 있으니 꼭 활용해보세요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\"Next.js: debug full stack\" 설정에서 serverReadyAction.action은 서버가 준비됐을 때 어떤 브라우저를 열지 지정해줘요. 예를 들어 debugWithEdge는 Edge 브라우저를 실행하겠다는 뜻이고, 만약 Chrome을 쓰신다면 이 값을 debugWithChrome으로 바꿔주면 됩니다.\n\n또, 애플리케이션이 시작하는 포트 번호를 바꾸셨다면 http://localhost:3000 중 3000을 새로 쓰는 포트 번호로 교체해 주세요.\n\n그리고 Next.js를 루트 디렉터리가 아닌 다른 경로에서 실행 중이라면(예를 들어 Turborepo를 사용하는 경우), 서버 쪽과 full stack 디버깅 작업에 cwd 옵션도 꼭 추가해야 해요. 예를 들면 이렇게요: `\"cwd\": \"${workspaceFolder}/apps/web\"`.\n\n마지막으로 디버그 패널(Windows/Linux는 Ctrl+Shift+D, macOS는 ⇧+⌘+D)로 가서 실행할 launch 구성을 선택한 뒤, F5를 누르거나 커맨드 팔레트에서 Debug: Start Debugging을 선택하면 디버깅 세션이 시작됩니다.\n\n---\n\n### 추가 팁!\n\n- `cwd` 설정은 현재 작업 디렉토리를 지정하는 건데요, 이게 없으면 디버거가 소스 파일을 제대로 찾지 못해서 오류가 날 수 있으니 꼭 신경 써주세요.\n- 혹시 브라우저가 자동으로 열리지 않는다면, 브라우저 쪽 설정과 VSCode의 디버깅 콘솔 로그를 한 번씩 확인해보는 게 좋아요.\n- 만약 다른 브라우저(예: Firefox)를 쓰고 싶다면, 그에 맞는 `debugWithFirefox` 같은 값이 있는지 플러그인 문서나 설정 참고해보세요.\n\n작게 하나 더! VSCode에서 Next.js 디버깅할 때는 `launch.json` 파일에 이런 설정이 들어가 있어야 하는데, 이를 잘 만들어 놓으면 매번 복잡한 명령어 없이도 쉽게 디버깅할 수 있어요. 초반에 설정이 좀 귀찮긴 하지만, 한 번 해두면 앞으로 엄청 편합니다!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## JetBrains WebStorm에서 디버거 사용하기\n\nWebStorm에서 디버깅을 시작하려면, 먼저 실행 구성(runtime configuration) 드롭다운 메뉴를 클릭하고, **Edit Configurations...**를 선택하세요. 여기서 JavaScript Debug 구성 하나를 새로 만듭니다. URL은 보통 `http://localhost:3000` 같은 로컬 서버 주소로 설정해주고, 필요에 따라 디버깅할 브라우저 종류도 선택할 수 있어요. 또, 이 설정을 프로젝트 파일로 저장할지 여부도 결정할 수 있습니다. 구성 설정이 끝나면 **OK**를 눌러 저장하세요.\n\n이제 이 디버깅 구성을 실행하면, WebStorm이 자동으로 선택한 브라우저를 열어줍니다. 이 상태에서 두 앱이 디버깅 모드로 실행 중입니다: 하나는 Next.js가 실행되는 Node.js 백엔드 애플리케이션, 그리고 다른 하나는 클라이언트 쪽(브라우저) 애플리케이션이죠.\n\n이렇게 하면 백엔드와 프론트엔드를 한곳에서 편리하게 디버깅할 수 있어서, 문제를 더 빠르게 잡아낼 수 있습니다.\n\n---\n\n## 브라우저 개발자 도구(DevTools)를 활용한 디버깅\n\n### 클라이언트 사이드 코드\n\n브라우저 내장 개발자 도구는 여러분이 가장 쉽게 접할 수 있는 디버깅 도구 중 하나예요. WebStorm의 디버그 세션과 함께 사용하면 훨씬 강력하죠.\n\n예를 들어, React 같은 클라이언트 프레임워크를 사용한다면, 개발자 도구에서 `Sources` 탭을 통해 코드에 대한 중단점(breakpoint)을 직접 걸 수 있고, 상태 변수나 호출 스택(call stack)을 살펴볼 수 있습니다. 또한, 콘솔(Console) 탭을 활용해 `console.log` 이상의 상호작용을 하면서, 변수를 실시간으로 확인하거나 함수 실행 결과를 테스트할 수도 있어요.\n\n한 가지 팁을 드리자면, 브라우저의 개발자 도구에서 네트워크(Network) 탭을 통해 API 요청과 응답을 모니터링하면, 백엔드와 클라이언트 간 통신 문제를 빠르게 진단할 수 있습니다. 예를 들어, 요청이 제대로 보내졌는지, 응답 시간이 지연되거나 에러는 없는지 등을 실시간으로 확인할 수 있죠.\n\n또한, React 개발자라면 Chrome 확장 프로그램인 React Developer Tools를 설치해서 컴포넌트 트리 상태를 직접 들여다보는 것도 추천합니다.\n\n---\n\n### 정리하자면\n\n- WebStorm 내에서 JavaScript Debug 구성을 만들어 사용하면, 브라우저를 자동으로 열면서 코드를 단계별로 실행해볼 수 있어서 편리합니다.\n- 동시에 백엔드와 프론트엔드 모두를 디버깅해야 하는 환경에 매우 적합하죠.\n- 브라우저 개발자 도구는 클라이언트 쪽 코드를 빠르게 점검하고 문제를 분석하는 데 필수 도구입니다.\n- 네트워크 요청 모니터링과 다양한 콘솔 기능도 적극 활용해보세요.\n\n다음에는 Next.js 백엔드 코드나 프론트엔드 코드에 실제로 중단점을 걸고, 어떤 방식으로 디버깅하면 좋은지 더 자세히 파헤쳐볼게요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n개발 서버를 시작할 때는 보통 next dev, npm run dev, 혹은 yarn dev 명령어를 사용하면 돼요. 서버가 켜지면 http://localhost:3000 (혹은 설정한 다른 URL)을 브라우저에서 열어보세요.\n\n크롬(Chrome)을 사용할 때는 이렇게 하면 됩니다:\n\n- 크롬 개발자 도구 열기 (윈도우/리눅스: Ctrl+Shift+J, macOS: ⌥+⌘+I)\n- 상단 탭에서 Sources 탭 클릭\n\n파이어폭스(Firefox)를 사용할 때도 비슷한 방식이에요. 다음에 이어서 설명할게요!  \n(필요하면 알려주세요.)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파이어폭스 개발자 도구 열기 (Windows/Linux는 Ctrl+Shift+I, macOS는 ⌥+⌘+I)  \n그리고 나서 디버거(Debugger) 탭으로 이동하세요.\n\n여기서 중요한 팁! 클라이언트 쪽 코드에 `debugger` 문이 나오면 코드 실행이 잠시 멈추고, 그 파일이 디버그 영역에 나타납니다. 직접 브레이크포인트를 설정하고 싶을 때는 파일을 검색해서 찾으면 되는데요.\n\n- 크롬에서는 Windows/Linux는 Ctrl+P, macOS는 ⌘+P를 누르면 돼요.\n- 파이어폭스에서는 같은 단축키로 검색하거나 왼쪽 패널에 있는 파일 트리를 이용해도 됩니다.\n\n참고로, 파일을 검색할 때 소스 파일 경로가 `webpack://_N_E/./`로 시작하는 경우가 많으니 이 점 명심하세요.\n\n추가로, 디버깅할 때 이 파일 경로가 조금 헷갈릴 수 있는데, 이 경로는 웹팩이 번들링하면서 붙인 경로입니다. 만약 소스맵(Source Maps)이 잘 연결되어 있다면, 실제 당신이 작성한 원본 코드 위치로 바로 이동할 수 있으니 소스맵 설정도 미리 확인해 두는 게 좋아요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 서버 사이드 코드 디버깅하기\n\nNext.js로 서버 사이드 코드를 디버깅할 때, 브라우저 개발자 도구를 사용하려면 Node.js 프로세스에 `--inspect` 플래그를 전달해줘야 해요. 간단하게 이렇게 실행하면 됩니다:\n\n```bash\nNODE_OPTIONS='--inspect' next dev\n```\n\n이렇게 하면 서버 코드가 디버깅 모드로 실행되면서, 크롬 같은 브라우저 개발자 도구에서 디버깅이 가능해져요.\n\n> 참고로, 만약 도커 같은 환경에서 로컬호스트가 아닌 외부에서 디버깅 접근을 하려면, 플래그를 조금 바꿔야 해요:\n>\n> bash\n> NODE_OPTIONS='--inspect=0.0.0.0' next dev\n>\n> 이렇게 하면 외부 IP에서도 디버깅 포트에 접속할 수 있어서 원격 디버깅이 가능해집니다. 개발할 때 정말 유용하니 기억해두세요!\n\n덧붙여, 디버깅을 좀 더 효율적으로 하려면 VSCode 같은 에디터의 디버깅 기능과도 연동해서 사용해보는 걸 추천해요. `launch.json` 설정을 통해서 바로 디버깅 세션을 시작할 수 있거든요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약에 `npm run dev` 또는 `yarn dev`로 개발 서버를 실행하고 있다면, package.json 안에 dev 스크립트를 이렇게 수정해줘야 해요:\n\n```json\n{\n  \"scripts\": {\n    \"dev\": \"NODE_OPTIONS='--inspect' next dev\"\n  }\n}\n```\n\n이렇게 하면 Next.js 개발 서버를 띄울 때 `--inspect` 옵션도 같이 붙어서 디버깅이 가능해집니다. 실행하면 터미널에 이런 메시지가 나올 거예요:\n\nDebugger listening on ws://127.0.0.1:9229/0cf90313-350d-4466-a748-cd60f4e47c95\nFor help, see: https://nodejs.org/en/docs/inspector\nready - started server on 0.0.0.0:3000, url: http://localhost:3000\n\n이 메시지는 Node.js의 디버깅 프로토콜이 활성화돼서 디버거가 연결 대기 중이라는 뜻이에요. 크롬 개발자 도구나 VSCode 같은 에디터에서 이 포트를 연결해서 코드를 단계별로 디버깅할 수 있답니다!\n\n추가로, 윈도우 환경에서는 `NODE_OPTIONS='--inspect'` 부분을 이렇게 바꿔줘야 할 수도 있어요:\n\n```json\n\"dev\": \"set NODE_OPTIONS=--inspect&& next dev\"\n```\n\n운영체제별로 환경 변수 설정법이 다르니 참고하세요! 이렇게 하면 Next.js 개발할 때 버그 찾기가 훨씬 편해져요. 기억해두시면 좋겠죠?\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n크롬(Chrome)에서 디버깅하기:\n\n1. 새 탭을 열고 `chrome://inspect`로 이동하세요.\n2. 오른쪽 상단의 **Configure...** 버튼을 클릭해 디버깅 포트가 제대로 등록되어 있는지 확인합니다.\n3. `localhost:9229`와 `localhost:9230`이 목록에 없다면 추가해 주세요.\n4. **Remote Target** 섹션에서 여러분의 Next.js 애플리케이션을 찾습니다.\n5. **Inspect** 버튼을 클릭하면 별도의 DevTools 창이 열립니다.\n6. **Sources** 탭으로 이동해 코드를 살펴보면서 디버깅을 시작하세요.\n\nFirefox에서 디버깅하기:\n\n1. 새 탭을 열고 `about:debugging` 페이지로 이동합니다.\n2. 왼쪽 사이드바에서 **This Firefox**를 클릭합니다.\n3. **Remote Targets** 아래에서 Next.js 애플리케이션을 찾습니다.\n4. **Inspect** 버튼을 눌러 디버거 창을 엽니다.\n5. **Debugger** 탭으로 가서 디버깅할 코드를 확인해 보세요.\n\n---\n\n추가 팁!\n\n- Next.js 앱을 디버깅할 때 Node.js 서버 쪽 디버깅도 중요해요. 보통 `nodemon --inspect` 같은 옵션으로 서버를 실행한 뒤 위에서 설명한 포트를 확인하면 됩니다.\n- 크롬과 파이어폭스 둘 다, 디버깅 포트가 다르면 각각 추가해야 하니 꼭 확인하세요.\n- DevTools에서는 브라우저에서 실행되는 클라이언트 사이드 코드 뿐 아니라, 서버 사이드 렌더링 함수들도 디버깅할 수 있어 아주 유용해요.\n- 혹시 Next.js에서 제공하는 기본 디버깅 툴 외에 더 전문적인 도구를 찾는다면 VS Code의 디버거도 추천합니다. 요즘은 VS Code가 Next.js와 Node.js 디버깅 모두 잘 지원해줘서 편리하게 사용할 수 있어요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n서버 사이드 코드를 디버깅하는 방법은 클라이언트 사이드 디버깅과 굉장히 비슷해요. 예를 들어 파일을 검색할 때 (Ctrl+P 또는 ⌘+P) 소스 파일 경로가 webpack://'application-name'/./ 로 시작하는 걸 볼 수 있는데, 여기서 'application-name'은 package.json에 설정한 여러분의 애플리케이션 이름으로 자동으로 바뀌어요.\n\n### 브라우저 개발자 도구로 서버 에러 살펴보기\n\n에러가 발생했을 때, 소스 코드를 직접 확인하면 원인 찾기가 훨씬 수월해요. Next.js에서는 에러 화면에 Node.js 아이콘이 Next.js 버전 표시 아래에 나타납니다. 이 아이콘을 클릭하면 개발자 도구(DevTools) URL이 클립보드에 복사돼요. 이 URL을 새 탭에 붙여넣으면 Next.js 서버 프로세스를 직접 들여다볼 수 있답니다.\n\n참고로, 이렇게 서버 프로세스를 브라우저에서 디버깅할 수 있다는 점이 정말 편리한데요, 예전에는 터미널에서만 로그를 보거나 복잡한 디버깅 과정을 거쳐야 했거든요. 이 기능 덕분에 코드 흐름을 한눈에 확인하고, 오류 위치를 빨리 찾아낼 수 있어 개발 속도가 확실히 빨라진답니다. 혹시 더 깊이 있는 디버깅이 필요하면, Node.js 전용 디버거(예: VSCode의 디버깅 툴)와 병행해서 사용해보는 것도 추천해요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### Windows에서 디버깅하기\n\nWindows에서 개발하다 보면 `NODE_OPTIONS='--inspect'` 이런 식으로 설정할 때 문제가 생길 수 있어요. 윈도우는 이 문법을 그대로 지원하지 않거든요. 그래서 윈도우, 맥, 리눅스 어디서든 똑같이 작동하도록 하려면 `cross-env`라는 패키지를 활용하는 걸 추천해요.\n\n`cross-env`는 다양한 운영체제 환경에 맞게 환경 변수를 설정해주는 역할을 하는데요, 덕분에 같은 설정으로 모든 플랫폼에서 디버깅이 가능해집니다.\n\n먼저, `cross-env`를 개발 의존성으로 설치해줍니다:\n\n```bash\nnpm install -D cross-env\n# 혹은\nyarn add -D cross-env\n```\n\n그 다음 `package.json`의 `dev` 스크립트를 이렇게 바꿔주세요:\n\n```json\n{\n  \"scripts\": {\n    \"dev\": \"cross-env NODE_OPTIONS='--inspect' next dev\"\n  }\n}\n```\n\n이렇게 설정하면 이제 `npm run dev` 또는 `yarn dev`로 실행할 때 디버거가 잘 붙을 거예요.\n\n> **추가 팁!**  \n> 만약 Windows PowerShell에서 터미널을 사용한다면, `'--inspect'` 대신 `\"--inspect\"`로 바꿔서 실행할 수도 있으니 환경에 따라 테스트해보세요.\n\n개발 환경을 맞추는 건 가끔 깔끔하지 않을 때가 많은데요, `cross-env` 같은 도구를 잘 활용하면 이런 골치 아픈 부분을 많이 덜 수 있어서 강력 추천합니다!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n> 참고하세요: Windows Defender를 내 컴퓨터에서 꼭 비활성화하세요. 이 외부 서비스는 읽는 모든 파일을 검사하는데, 이로 인해 Next.js 개발 시 Fast Refresh 속도가 크게 느려질 수 있다고 알려져 있어요. 이 문제는 Next.js 자체와 관련된 게 아니지만, 개발 환경에는 영향을 미치니까 꼭 체크해두는 게 좋아요.\n\n## 추가 정보\n\n자바스크립트 디버거를 어떻게 사용하는지 더 배우고 싶다면, 아래 문서들을 참고해보세요:\n\n- VS Code에서 Node.js 디버깅: Breakpoints\n- Chrome DevTools: 자바스크립트 디버깅\n- Firefox DevTools: 디버거\n\n디버깅 기능을 잘 활용하면 개발할 때 훨씬 편리하고 효율적으로 오류를 잡을 수 있으니, 시간이 날 때 꼭 한번 익혀보는 걸 추천합니다!\n","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":15},{"title":"Next.js 15 커스텀 서버 구축하는 방법","description":"","date":"2025-04-22 02:07","slug":"2025-04-22-CustomServer","content":"\n# 커스텀 서버(Custom Server) 이해하기\n\nNext.js를 사용하면 기본적으로 `next start` 명령어로 내장된 서버가 바로 실행돼요. 그런데 만약 이미 백엔드 서버가 따로 있다면, 그걸 그대로 유지하면서 Next.js와 함께 사용할 수도 있답니다. 이 경우를 ‘커스텀 서버(Custom Server)’라고 부르지 않아요.\n\n커스텀 Next.js 서버는 필요에 따라 내 프로그램에서 직접 서버를 띄우면서 라우팅이나 요청 처리 방식을 자유롭게 바꾸고 싶을 때 사용해요. 하지만 대부분의 경우에는 Next.js가 제공하는 기본 라우터만으로도 충분하기 때문에 굳이 커스텀 서버를 만들 필요가 없어요.\n\n> **여기서 주의!**\n>\n> - 커스텀 서버는 Next.js의 자동 정적 최적화(Automatic Static Optimization) 같은 중요한 성능 개선 기능들을 포기하는 대가를 치러야 해요.\n> - 그리고 Vercel 같은 Next.js 공식 배포 플랫폼에서는 커스텀 서버를 사용할 수 없어요.\n> - `standalone` 출력 모드를 사용할 때는 커스텀 서버 파일을 함께 추적하지 않고, 대신 최소한의 `server.js` 파일만 따로 만들어내요. 그래서 둘을 동시에 사용할 수도 없으니 주의가 필요해요.\n\n아래는 커스텀 서버의 간단한 예시를 보여드릴게요. 예전에는 Express.js 같은 외부 서버 라이브러리와 함께 Next.js를 이렇게 쓰는 경우가 많았는데, 최근 Next.js가 점점 더 자체 기능을 강화하면서 점차 필요성이 줄고 있죠.\n\n```js\nconst express = require(\"express\");\nconst next = require(\"next\");\n\nconst port = 3000;\nconst app = next({ dev: false });\nconst handle = app.getRequestHandler();\n\napp.prepare().then(() => {\n  const server = express();\n\n  // 커스텀 라우트 예시\n  server.get(\"/p/:id\", (req, res) => {\n    const actualPage = \"/post\";\n    const queryParams = { id: req.params.id };\n    app.render(req, res, actualPage, queryParams);\n  });\n\n  // 나머지는 Next.js 기본 처리\n  server.all(\"*\", (req, res) => {\n    return handle(req, res);\n  });\n\n  server.listen(port, (err) => {\n    if (err) throw err;\n    console.log(`> Ready on http://localhost:${port}`);\n  });\n});\n```\n\n---\n\n### 꼭 알아두면 좋은 팁\n\n- 커스텀 서버는 정말 필요할 때에만 써요! 기본 Next.js 라우팅으로 충분하면 굳이 복잡하게 서버를 직접 관리할 필요 없어요.\n- Vercel 배포에서는 사용 불가라는 점, 잊지 마세요.\n- 서버 없는 환경(serverless)이나 요즘 많이 쓰는 ISR(Incremental Static Regeneration) 기능이랑도 잘 맞지 않아요.\n- 많이 쓰이는 기능은 공식 Next.js 라우터 기능이나 API 라우트를 활용하는 게 더 깔끔하고 이후 유지보수도 편해요.\n\n만약 커스텀 서버와 관련해서 더 궁금한 점 있으면 언제든 질문해 주세요! 혹은 Next.js 기본 라우터들의 여러 팁도 공유해 드릴게요. 😊\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js 프로젝트에서 커스텀 서버를 직접 만들고 싶을 때, 보통 `server.js` 파일을 만들어서 Node.js의 HTTP 서버를 활용하곤 해요. 오늘은 간단한 커스텀 서버 예제와, 이걸 어떻게 실행할지 package.json에 스크립트를 어떻게 추가하는지 알려드릴게요.\n\n먼저, 이 코드를 보시면 서버를 직접 생성하고 Next.js 앱을 `next()` 함수로 감싼 뒤에 준비가 끝나면 HTTP 서버를 띄우는 구조예요.\n\n```js\nimport { createServer } from 'http'\nimport { parse } from 'url'\nimport next from 'next'\n\nconst port = parseInt(process.env.PORT || '3000', 10)\nconst dev = process.env.NODE_ENV !== 'production'\nconst app = next({ dev })\nconst handle = app.getRequestHandler()\n\napp.prepare().then(() => {\n  createServer((req, res) => {\n    const parsedUrl = parse(req.url!, true)\n    handle(req, res, parsedUrl)\n  }).listen(port)\n\n  console.log(\n    `> Server listening at http://localhost:${port} as ${\n      dev ? 'development' : process.env.NODE_ENV\n    }`\n  )\n})\n```\n\n이 코드에서 핵심은 `app.prepare()`가 끝나면 HTTP 서버를 열며, 들어오는 요청을 `handle` 함수로 넘겨서 Next.js가 페이지를 렌더링하도록 한다는 점이에요.\n\n### 그런데 여기서 중요한 점!\n\n`server.js`는 Next.js 컴파일러를 거치지 않고 그냥 Node.js에서 직접 실행되기 때문에, 최신 문법(예: ES 모듈 `import` 구문)을 쓸 때 Node.js 버전과 호환되는지 반드시 확인해야 합니다. 만약 호환 안 되면 직접 `require()`로 바꾸거나, Babel 같은 트랜스파일러 사용을 고려해야 해요.\n\n---\n\n### package.json에 커스텀 서버 실행 스크립트 추가하기\n\n커스텀 서버를 실행하려면 `package.json`의 `scripts`를 이렇게 바꿔줘야 해요.\n\n```json\n{\n  \"scripts\": {\n    \"dev\": \"node server.js\",\n    \"build\": \"next build\",\n    \"start\": \"NODE_ENV=production node server.js\"\n  }\n}\n```\n\n- `dev`: 개발 모드에서 커스텀 서버 바로 실행\n- `build`: Next.js 빌드 수행\n- `start`: 프로덕션 환경에서 커스텀 서버 실행\n\n---\n\n### 덧붙여서…\n\n커스텀 서버를 만들면 유연하게 서버 로직 제어가 가능하지만, Next.js의 기본 서버 기능과 자동 최적화, 배포 플랫폼(예: Vercel) 지원을 덜 받게 돼요. 그러니 정말 필요한 경우가 아니라면 기본 Next.js 빌트인 서버를 쓰는 걸 권장합니다!\n\n그럼, 여러분만의 커스텀 서버 만들어서 원하는 기능 자유롭게 구현해보세요! 궁금한 점 있으면 언제든 질문 남겨주세요. 😄\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n대신에 nodemon을 설정해서 사용할 수도 있어요(예시 참고). 커스텀 서버는 Next.js 애플리케이션과 연결하기 위해 아래와 같은 import 문을 사용합니다:\n\n```js\nimport next from \"next\";\n\nconst app = next({});\n```\n\n여기서 next 함수는 옵션들을 담은 객체를 인자로 받는데요, 주요 옵션들은 다음과 같습니다:\n\n| 옵션         | 타입               | 설명                                                                                |\n| ------------ | ------------------ | ----------------------------------------------------------------------------------- |\n| `conf`       | `Object`           | `next.config.js` 에서 사용하는 설정 객체와 동일해요. 기본값은 `{}` 입니다.          |\n| `dev`        | `Boolean`          | (선택) Next.js를 개발 모드로 실행할지 여부입니다. 기본값은 `false` 입니다.          |\n| `dir`        | `String`           | (선택) Next.js 프로젝트 위치를 지정합니다. 기본값은 현재 폴더 `'.'` 입니다.         |\n| `quiet`      | `Boolean`          | (선택) 서버 정보가 포함된 에러 메시지를 숨길지 결정합니다. 기본값은 `false` 입니다. |\n| `hostname`   | `String`           | (선택) 서버가 실행되는 호스트 이름을 지정합니다.                                    |\n| `port`       | `Number`           | (선택) 서버가 실행되는 포트를 지정합니다.                                           |\n| `httpServer` | `node:http#Server` | (선택) Next.js가 작동 중인 HTTP 서버 객체를 넘겨줄 수 있습니다.                     |\n| `turbo`      | `Boolean`          | (선택) Turbopack을 활성화할지 여부입니다.                                           |\n\n---\n\n**간단 팁!**\n\n- 개발할 때 `dev` 옵션을 `true`로 주면 핫 리로딩도 잡아주고 디버깅이 편해져요.\n- 프로젝트 경로가 현재 폴더가 아니라면 `dir` 옵션으로 정확히 지정해주는 게 중요합니다.\n- `quiet` 옵션을 켜면 서버 에러 로그가 줄어들어 콘솔이 깔끔해져서 가끔 쓰면 좋아요.\n- 그리고 마지막으로 `turbo` 옵션은 Next.js의 차세대 번들러인 Turbopack을 활성화하는건데, 아직 실험적인 기능이라 프로젝트 특성에 따라 테스트해보시는 걸 추천해요.\n\n이렇게 다양한 옵션을 활용해서 커스텀 서버 환경을 자신의 필요에 맞게 세팅해보세요! 개발할 때 내 서버 환경을 좀 더 세밀하게 컨트롤할 수 있어서 편리합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n반환된 앱은 Next.js가 요청을 필요한 대로 처리할 수 있도록 사용하는 데 활용할 수 있어요.\n\n여기서 중요한 점은, Next.js가 기본적으로 서버 사이드 렌더링(SSR)과 정적 생성(SSG) 모두를 지원하기 때문에, 반환된 앱으로 다양한 요청 처리 방식을 유연하게 다룰 수 있다는 거예요.\n\n예를 들어, API 라우트나 커스텀 서버를 구축할 때 조금 더 세밀한 제어가 필요하면 이렇게 반환된 앱을 통해 요청을 직접 처리할 수 있고, 그렇지 않으면 Next.js의 기본 라우팅에 맡길 수도 있죠.\n\n이런 방식을 활용하면 복잡한 서버 로직을 구현할 때도 Next.js의 장점을 최대한 살리면서 개발할 수 있어요!\n","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":7},{"title":"Nextjs15에서 로컬 개발 환경 구축하는 방법","description":"","date":"2025-04-22 02:05","slug":"2025-04-22-LocalDevelopment","content":"\n\n# 로컬 개발 환경\n\nNext.js는 개발자 경험을 최우선으로 설계되었어요. 그런데 프로젝트가 커질수록 로컬에서 개발할 때 컴파일 속도가 느려지는 걸 경험할 수 있답니다. 그래서 이번 글에서는 자주 발생하는 컴파일 시간 지연 문제를 어떻게 발견하고 해결할 수 있는지 알려드릴게요.\n\n## 로컬 개발과 프로덕션 빌드의 차이\n\nNext.js에서 `next dev` 명령어로 로컬 개발을 할 때와, `next build` + `next start`로 프로덕션 모드로 실행하는 과정은 서로 다릅니다.\n\n로컬 개발(`next dev`)에서는 개발 편의성을 위해 핫 리로딩, 소스맵 제공, 다양한 검사 기능들이 활성화되어 있어요. 그래서 빌드가 좀 더 느릴 수밖에 없죠. 반면 프로덕션 빌드(`next build`)는 최적화를 최대한 해서 빠른 페이지 로딩과 작은 번들 크기를 목표로 합니다.\n\n여기서 중요한 점! 로컬 개발 속도가 너무 느리다면, 단순히 production 빌드 환경으로 바꿔서 해결하려고 하기보다는, 개발 중에만 발생하는 문제들이 없는지 한번 점검해 보는 게 좋아요.\n\n---\n\n추가로! Next.js 13부터는 새로운 앱 디렉터리와 React Server Components가 도입되면서 빌드와 컴파일 패턴이 조금 달라졌어요. 그래서 앱 디렉터리를 사용하는 경우에도 성능 최적화 방법이 약간 다를 수 있다는 점, 참고해주세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js 개발할 때 'next dev' 명령어를 쓰면, 애플리케이션의 각 라우트를 실제로 열거나 이동할 때 그 라우트를 컴파일해요. 덕분에 처음 'next dev' 서버를 켤 때 모든 라우트를 한꺼번에 빌드하느라 오래 기다릴 필요가 없죠. 이것도 훨씬 빠르고, 메모리도 덜 먹으니 좋고요.\n\n반면 프로덕션 빌드(운영용 빌드)는 파일 압축(minify)이나 콘텐츠 해시 생성 같은 최적화 작업들이 추가로 들어가서, 개발환경보다는 시간이 더 걸리고 무겁습니다. 그래서 로컬 개발할 때는 'next dev'를 쓰는 게 훨씬 효율적이죠.\n\n---\n\n## 로컬 개발 속도 높이는 방법\n\n### 1. 내 컴퓨터의 백신 프로그램, 체크해봤나요?\n\n의외로 많은 사람들이 간과하는 포인트인데요, 백신 프로그램이 파일 접근 속도를 확 느리게 할 수 있답니다. 개발 도중 수시로 파일을 읽고 쓰는데, 백신이 실시간 감시한다고 생각해보세요. 파일 입출력(I/O) 작업이 지연되니 개발 속도에도 영향이 가는 건 당연하죠.\n\n아래 팁들 참고해보세요:\n\n- 개발 폴더를 백신 검사 제외 대상으로 등록하기  \n- 혹은 백신을 잠시 꺼두고 개발하기 (안전한 환경이라면)  \n- 백신을 경량화하거나 개발 환경에 맞는 설정을 찾아보기  \n\n간단하면서도 효과 볼 수 있는 방법이니 꼭 테스트해보시길 바랍니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프로젝트 폴더를 안티바이러스 예외 목록에 추가해보세요. 보통 윈도우 환경에서 많이 하는 방법이지만, 안티바이러스가 설치된 모든 시스템에서 추천하는 팁입니다. 안티바이러스가 파일을 검사하면서 개발 서버 성능이 떨어질 수 있기 때문이에요.\n\n### 2. Next.js 업데이트 및 Turbopack 활성화\n\n최신 버전의 Next.js를 사용하고 있는지 확인해보세요. Next.js는 버전이 올라갈 때마다 성능 개선이 자주 포함된답니다.\n\n그리고 Turbopack이라는 새로운 번들러가 Next.js에 통합되었어요. Turbopack은 로컬 개발 환경에서 빌드와 번들링 속도를 크게 높여주는 역할을 하니 꼭 활용해보시길 추천합니다!\n\n> 참고로, Turbopack은 아직 완전히 안정화된 단계는 아니지만, 빠른 속도를 경험하고 싶다면 충분히 시도해볼 만해요. 설정 방법이나 지원하는 기능도 계속 업데이트 중이라 공식 문서를 수시로 확인하는 게 좋아요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```bash\nnpm install next@latest\nnpm run dev --turbopack\n```\n\nTurbopack에 대해 더 알고 싶다면 공식 문서와 업그레이드 가이드, 코드를 자동 변환해주는 codemods도 참고해보세요.\n\n### 3. import 구문 점검하기\n\n코드를 어떻게 import하느냐에 따라 컴파일 속도와 번들 크기에 큰 영향을 줄 수 있어요. 패키지 번들링 최적화 방법에 대해 배우고 싶다면 Dependency Cruiser, Madge 같은 도구도 한 번 사용해보시길 추천합니다. \n\n이런 도구들은 의존성 관계를 시각화하고 불필요한 중복 import를 찾는 데 도움을 줘서, 코드가 더 깔끔하고 빠르게 빌드되도록 도와줘요. 특히 큰 프로젝트에서는 이런 최적화가 빛을 발한답니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 아이콘 라이브러리 활용 팁\n\n@material-ui/icons나 react-icons 같은 라이브러리는 무려 수천 개의 아이콘을 한꺼번에 가져올 수 있어요. 그런데 실제로는 그중 몇 개만 쓸 때가 많죠. 이럴 때는 꼭 필요한 아이콘만 딱딱 가져오는 게 좋아요!\n\n```js\n// 이렇게 한꺼번에 불러오기보다는:\nimport { Icon1, Icon2 } from 'react-icons/md'\n\n// 이렇게 개별로 불러오는 게 더 효율적이에요:\nimport Icon1 from 'react-icons/md/Icon1'\nimport Icon2 from 'react-icons/md/Icon2'\n```\n\n이렇게 하면 불필요한 아이콘들이 번들에 포함되는 걸 막을 수 있어서 앱의 용량을 줄이고, 로딩 속도를 빠르게 할 수 있답니다.\n\n그리고 react-icons처럼 여러 아이콘 세트를 한 자리에서 제공하는 라이브러리는 한 가지 세트만 선택해서 통일감 있게 사용하는 걸 추천해요. 그러면 디자인도 깔끔해 보이고, 코드 관리도 훨씬 쉬워집니다!\n\n추가로, 만약 프로젝트가 커져서 아이콘이 많아지면 커스텀 아이콘 컴포넌트를 만들어서 재사용하는 것도 좋은 방법이에요. 작지만 효과적인 성능 최적화 팁 중 하나랍니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예를 들어, 만약 여러분의 애플리케이션에서 react-icons를 사용하면서 다음과 같이 여러 아이콘 세트에서 모두 다 임포트한다고 해볼게요:\n\n- pi (Phosphor Icons)\n- md (Material Design Icons)\n- tb (tabler-icons)\n- cg (cssgg)\n\n이렇게 하면, 실제로는 한 개씩 아이콘만 가져와서 사용하더라도, 컴파일러는 수만 개에 달하는 모듈을 처리해야 하거든요. 이게 빌드 시간은 물론 최종 번들 크기에도 꽤 큰 영향을 미쳐요.\n\n### Barrel files (배럴 파일)\n\n여기서 배럴 파일 개념을 활용할 수 있어요. 배럴 파일이란 여러 개의 모듈을 한 군데서 모아두는 일종의 '중간 집합' 파일인데, 이렇게 하면 필요한 아이콘만 깔끔하게 임포트할 수 있어요. 예를 들어, `icons/index.js` 같은 파일을 만들어서 자주 쓰는 아이콘들만 골라서 한군데 내보내기(export) 하는 거죠.\n\n```js\n// icons/index.js\nexport { PiSomeIcon } from 'react-icons/pi';\nexport { MdAnotherIcon } from 'react-icons/md';\nexport { TbSampleIcon } from 'react-icons/tb';\nexport { CgExampleIcon } from 'react-icons/cg';\n```\n\n그리고 실제 컴포넌트에서는 이렇게 쓰면 돼요:\n\n```js\nimport { PiSomeIcon, MdAnotherIcon } from './icons';\n```\n\n이렇게 하면 필요 없는 아이콘 모듈들은 빌드 과정에서 제외될 가능성이 높아지고, 코드 관리도 훨씬 수월해져요. \n\n뿐만 아니라, 이것 말고도 react-icons에서 지원하는 트리 쉐이킹(Tree shaking) 기능을 최대한 활용하는 방법도 고려해보면 좋아요. 예를 들어 아이콘을 직접 필요한 것만 개별 임포트하거나, 번들러 설정(Webpack, Vite 등)에서 최적화를 제대로 해줘야 하죠.\n\n정리하자면,\n\n| 문제점                    | 해결 방법               | 추가 팁                         |\n|---------------------------|------------------------|--------------------------------|\n| 수만 개 모듈 임포트       | 배럴 파일로 모듈 한데 묶기 | 트리쉐이킹 지원 활성화           |\n| 빌드 속도와 번들 크기 증가 | 필요 아이콘 개별 임포트   | 번들러 최적화 설정 함께 챙기기   |\n\n조금만 신경 써도 아이콘 사용이 훨씬 간편해지고 앱이 가벼워질 수 있으니 꼭 한 번 시도해 보시길 추천드려요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\"Barrel 파일\"이라는 개념 들어보셨나요? 간단히 말하면, 여러 개의 모듈이나 컴포넌트를 한 곳에서 한 번에 export해주는 파일을 뜻해요. 예를 들어, 여러 컴포넌트를 각각 import하지 않고, barrel 파일 하나만 import하면 편리하죠.\n\n하지만 이런 barrel 파일이 오히려 빌드 속도를 늦출 수 있어요. 그 이유는 컴파일러가 해당 파일을 파싱하면서 모듈 스코프 내에 부작용(side-effects)이 있는지 확인해야 하기 때문이거든요. 그래서 가능하면 각 컴포넌트나 모듈을 직접 import하는 게 좋아요.\n\nNext.js에서는 이런 barrel 파일과 관련된 최적화 기능도 제공하고 있으니 참고하시면 좋아요.\n\n---\n\n### 패키지 import 최적화하기\n\nNext.js는 특정 패키지들에 대해 자동으로 import 최적화를 해준답니다. 만약 barrel 파일 방식을 사용하는 패키지를 쓴다면, `next.config.js` 파일에 해당 패키지를 아래와 같이 추가해 주면 돼요:\n\n```js\n// next.config.js\nmodule.exports = {\n  experimental: {\n    optimizePackageImports: true,\n  },\n  optimizePackageImports: {\n    'some-package': {\n      transform: 'some-package/lib/{{member}}', // 실제 import 경로를 지정\n    },\n  },\n};\n```\n\n이렇게 설정해 놓으면 Next.js가 필요한 모듈만 쏙쏙 골라서 import하기 때문에 빌드 속도와 번들 크기 측면에서 이점이 생기죠.\n\n---\n\n### 추가 팁!\n\n만약 여러분이 직접 패키지를 만들거나 관리하는 입장이라면, 가능하면 barrel 파일 사용을 최소화하고, 패키지 내부에서 개별 모듈을 명확하게 export하는 방식을 추천해요. 그래야 사용자 입장에서도 임포트가 최적화되고, 빌드 속도도 빨라지니까요.\n\n또한, import할 때 필요 없는 항목까지 한꺼번에 가져오지 말고, 코드에서 실제 필요한 것만 골라 import하는 습관을 들이면 번들 크기를 작게 유지하는 데 큰 도움이 됩니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nmodule.exports = {\n  experimental: {\n    optimizePackageImports: ['package-name'],\n  },\n}\n```\n\n위 코드는 Turbopack에서 특정 패키지의 import를 최적화하려고 설정한 예시입니다. 하지만 Turbopack은 이미 자동으로 import를 분석하고 최적화해주기 때문에, 이 설정은 사실 필요 없습니다. 번거롭게 직접 설정하지 않아도 Turbopack이 알아서 똑똑하게 처리해줘요.\n\n---\n\n### 4. Tailwind CSS 설정 확인하기\n\n만약 Tailwind CSS를 사용 중이라면, 제대로 설정되어 있는지 꼭 확인해보세요. Tailwind는 써보면 정말 편리한 CSS 유틸리티 프레임워크인데, 설정이 조금만 틀리면 스타일이 제대로 적용되지 않을 수 있거든요.\n\n예를 들어, `tailwind.config.js`에서 콘텐츠 경로(`content` 또는 `purge`)에 프로젝트 내 사용하는 컴포넌트 경로나 파일이 모두 포함되어 있는지 확인해야 합니다. 빠뜨리면 Tailwind가 불필요한 CSS를 제거하면서 실제 필요한 스타일까지 지워버릴 수 있어요.\n\n또한 PostCSS나 Next.js 같은 빌드 도구 설정에서 Tailwind 플러그인이 정확히 추가되어 있는지도 체크해보세요. 잘못 연결되어 있으면 컴파일 오류나 스타일 적용 문제로 이어질 수 있답니다.\n\n혹시 Tailwind CSS 설정이 처음이라면 공식 문서 한 번 정독해보는 걸 추천드리고, 설정 한 번 끝내고 나면 CSS 작성이 훨씬 간결해지고 관리도 수월해질 거예요!\n\n---\n\n추가로 궁금한 점이나 설정 관련해서 더 도움 필요하면 언제든 말씀해 주세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nTailwind CSS 설정할 때 자주 하는 실수 중 하나가, content 배열에 node_modules 같은 불필요하게 큰 폴더들이 포함되어 빌드 속도를 느리게 만드는 경우예요.\n\nTailwind CSS 버전 3.4.8 이상부터는, 이런 설정이 빌드를 느리게 할 수 있다는 경고를 알려줘서 옵니다.\n\n### 주의할 점과 좋은 설정 예시\n\n- tailwind.config.js에서 어떤 파일을 스캔할지 구체적으로 명시하세요:\n\n```js\nmodule.exports = {\n  content: [\n    './src/**/*.{js,ts,jsx,tsx}', // 좋은 예시\n    // 아래 설정은 너무 범위가 넓어서 node_modules까지 포함될 수 있음\n    // '../../packages/**/*.{js,ts,jsx,tsx}',\n  ],\n}\n```\n\n- 불필요한 파일 스캔을 피하세요:\n\n```js\nmodule.exports = {\n  content: [\n    // 훨씬 좋은 방법 - 오직 src 폴더만 스캔합니다.\n    '../../packages/ui/src/**/*.{js,ts,jsx,tsx}',\n  ],\n}\n```\n\n이렇게 하면 Tailwind가 진짜 필요한 파일만 훑어보게 되어 빌드 시간이 확 줄어들고, 불필요한 경고나 오류도 줄어듭니다.\n\n---\n\n### 추가 팁!\n\n만약 프로젝트에 여러 패키지가 묶여있거나, 모노레포 구조라면 특히 어디를 포함시키고 어디를 제외할지 꼼꼼하게 체크해야 해요. node_modules, 빌드 결과물(dist), 그리고 테스트 결과물 같은 폴더는 꼭 제외하는 게 좋습니다.\n\n---\n\n### 다음 내용 살펴보기\n\n5. 커스텀 Webpack 설정 확인하기\n\nWebpack이나 다른 번들러와 함께 Tailwind를 쓸 때, 설정이 꼬이지 않았는지 꼭 한 번 확인하세요. 특히 경로나 플러그인 충돌을 점검하면 빌드 문제를 미리 예방할 수 있습니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약에 여러분이 커스텀 웹팩 설정을 추가했다면, 그 설정 때문에 컴파일 속도가 느려질 수도 있어요.\n\n로컬 개발 환경에서 정말 그 설정이 필요한지 한 번 생각해 보세요. 필요 없다면, 특정 툴이나 설정은 프로덕션 빌드 때만 포함시키는 걸 고려해 보는 것도 좋아요. 그리고 요즘은 Turbopack 같은 좀 더 빠른 빌드 도구도 많이 떠오르고 있으니 이런 새로운 도구와 로더(loader) 사용도 한번 조사해 보세요!\n\n### 6. 메모리 사용 최적화\n\n앱이 엄청 크다면, 메모리가 더 많이 필요할 수 있어요. 빌드나 실행 중 메모리 부족으로 속도가 느려지는 경우가 종종 있거든요. 개발 환경에서 메모리 설정을 늘리거나, 불필요한 모듈을 정리해서 메모리 사용량을 줄여보는 게 도움이 될 수 있습니다.\n\n---\n\n> 팁: Node.js를 쓰신다면, `--max-old-space-size` 옵션으로 메모리 제한을 늘려줄 수 있어요. 예를 들어 `node --max-old-space-size=4096`은 최대 힙 메모리를 4GB로 확장하니, 빌드가 훨씬 여유로워질 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n메모리 사용 최적화에 관한 공부를 계속해보면서, 이번에는 서버 컴포넌트와 데이터 패칭에 대해 이야기해볼게요.\n\n### 7. 서버 컴포넌트와 데이터 가져오기\n\n서버 컴포넌트가 변경되면 그 페이지 전체가 다시 렌더링돼요. 이 과정에서 해당 컴포넌트에 필요한 새로운 데이터를 다시 가져오게 되죠. 이게 로컬 개발 시에는 꽤 번거롭고, 자칫하면 불필요한 API 호출이 많아져 비용이 증가할 수 있어요.\n\n여기서 실험적으로 제공되는 옵션인 `serverComponentsHmrCache`를 활용하면, 서버 컴포넌트가 변경되어도 핫 모듈 교체(HMR) 과정 중에 fetch한 응답을 캐싱해둘 수 있어요. 즉, 다시 똑같은 데이터를 요청하지 않고 캐시된 데이터를 재사용함으로써, 훨씬 빠르게 페이지를 업데이트할 수 있고, API 호출 횟수도 줄일 수 있답니다.\n\n---\n\n사실 이런 캐싱 옵션을 잘 활용하면 개발 속도가 눈에 띄게 빨라지고, 특히 외부 API 호출에 비용이 붙는 상황에서는 큰 절약 효과를 볼 수 있어요. 다만, 이 기능이 아직 실험 단계라는 점은 참고하세요. 즉, 실제 운영 환경에서는 예상치 못한 이슈가 발생할 수 있으니 로컬 개발용으로만 활용하는 걸 추천합니다.\n\n추가로, 서버 컴포넌트에서 데이터 패칭을 최적화할 때는 캐시 적중률을 높이도록 데이터 요청을 일관성 있게 만드는 것도 중요해요. 예를 들어, 쿼리 파라미터를 변동 없이 사용하거나, 필요한 데이터만 정확히 요청하면 캐싱 효율이 확 올라갑니다.\n\n---\n\n요약해서 핵심 내용만 짚어드리면 아래 표처럼 정리할 수 있어요.\n\n| 개념                          | 설명                                               | 장점                                                     | 주의사항                      |\n|-----------------------------|--------------------------------------------------|--------------------------------------------------------|----------------------------|\n| 서버 컴포넌트 렌더링 변경           | 컴포넌트 변경 시 페이지 전체가 다시 렌더링되고 데이터 재요청 발생       | 최신 데이터를 반영하는 깨끗한 렌더링                            | 과도한 API 호출 발생 가능           |\n| serverComponentsHmrCache 옵션 | HMR 동안 서버 컴포넌트 데이터 fetch 결과를 캐싱                     | 빠른 반응 속도, API 호출 비용 절감                              | 아직 실험 기능, 로컬 개발용 추천       |\n\n앞으로도 메모리뿐 아니라 개발 효율과 비용 절감에 도움되는 이런 팁들을 계속 소개할게요. 혹시 서버 컴포넌트 관련해서 더 궁금한 점 있으면 알려주세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n실험적인 옵션에 대해 더 알아보기\n\n## 문제를 찾는 데 도움이 되는 도구들\n\n### 자세한 fetch 로그 기록\n\n개발 중에 무슨 일이 일어나고 있는지 더 자세히 보고 싶을 때는 이 명령어를 사용해 보세요:\n\n```bash\nFETCH_LOG_LEVEL=debug npm start\n```\n\n(예: FETCH_LOG_LEVEL 환경 변수를 debug로 설정하고 앱을 실행하는 방법)\n\n이렇게 하면 fetch 요청과 응답에 관련된 상세한 정보가 로그로 출력돼서, 네트워크 문제나 데이터 처리 과정에서 무슨 일이 일어나는지 더 쉽게 파악할 수 있어요.\n\n---\n\n추가로, 개발할 때 이런 로그를 꼼꼼히 살펴보는 습관을 들이면 문제를 빨리 찾고 해결하는 데 큰 도움이 됩니다. 특히 API 호출이 많거나 비동기 처리 로직이 복잡한 프로젝트일수록요.\n\n그리고 fetch 관련 로그뿐만 아니라, 다른 요청이나 상태 변화를 추적할 수 있는 도구(예: 브라우저의 개발자 도구 네트워크 탭, Redux DevTools 등)도 같이 활용하면 문제 파악이 훨씬 수월합니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```bash\nnext dev --verbose\n```\n\n## Turbopack 추적 기능 활용하기\n\nTurbopack tracing은 로컬 개발 중에 애플리케이션의 성능을 분석하는 데 도움을 주는 도구예요. 각 모듈이 컴파일되는 데 걸리는 시간과 모듈 간의 연관성을 자세히 보여주기 때문에, 느린 부분이나 문제점을 찾아내는 데 유용하답니다.\n\n### Turbopack 추적을 시작하는 방법\n\n1. **Next.js 최신 버전 확인**  \n   Turbopack tracing은 최신 Next.js 버전에서 제대로 동작하니, 먼저 `next` 패키지가 최신인지 확인해주세요.\n\n2. **추적 파일 생성하기**  \n   다음 명령어를 통해 개발 서버를 켜면서 추적을 활성화할 수 있어요:\n\n   bash\n   NEXT_TURBOPACK_TRACING=1 npm run dev\n   \n   \n   개발하면서 페이지를 이동하거나 파일을 수정하면서 문제를 재현해 보세요.\n\n3. **서버 종료 후 추적 파일 확인**  \n   개발 서버를 끄면 `.next` 폴더 안에 `trace-turbopack`이라는 추적 파일이 생성됩니다.\n\n4. **추적 파일 해석하기**  \n   생성된 파일을 분석하려면 아래 커맨드를 실행하세요:\n\n   bash\n   next internal trace .next/trace-turbopack\n   \n\n   만약 `trace` 명령어가 없으면, 구버전에서는 `turbo-trace-server`라는 이름이었으니 아래 명령어를 써보시면 돼요:\n\n   bash\n   next internal turbo-trace-server .next/trace-turbopack\n   \n\n5. **웹에서 추적 결과 보기**  \n   명령어를 실행해 추적 서버가 켜지면, 브라우저에서 [https://trace.nextjs.org/](https://trace.nextjs.org/)로 접속해 결과를 확인할 수 있습니다.\n\n### 추가 팁 - 타이밍 정보 보는 법\n\n기본적으로 추적 뷰어는 타이밍을 집계해서 보여주는데요, 전체 타이밍 뿐 아니라 각 작업별 상세 타이밍을 보고 싶을 땐 오른쪽 위에서 \"Aggregated in order\"를 \"Spans in order\"로 변경해 주세요. 그러면 모듈별 구체적인 컴파일 시간을 살펴볼 수 있답니다.\n\n---\n\nTurbopack tracing은 복잡한 의존성이나 느린 모듈 문제를 잡을 때 정말 강력한 도구예요. 특히 대규모 프로젝트를 다룰 때 성능 병목을 쉽게 발견할 수 있어 개발 생산성을 크게 높여주죠. Next.js를 사용하면서 느려짐을 체감한다면 꼭 한 번 활용해 보시길 추천드립니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 아직 문제 해결이 안 되셨나요?\n\nTurbopack 트레이싱 섹션에서 생성된 트레이스 파일을 공유해 주세요.  \n그 파일을 GitHub Discussions나 Discord에 올리면 더 빠르게 도움을 받을 수 있어요!\n\n추가 팁을 드리자면, 트레이스 파일에는 실행 흐름에 대한 정보가 담겨 있어서 문제를 분석하는 데 큰 도움이 됩니다.  \n그러니 가능하면 문제 상황을 최대한 자세히 적어 함께 올려 주세요. 그러면 개발자나 커뮤니티 멤버들이 더 정확하게 도움을 줄 수 있답니다!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":16},{"title":"Next.js 15에서 패키지 번들링 최적화하는 방법","description":"","date":"2025-04-22 02:04","slug":"2025-04-22-OptimizingPackageBundling","content":"\n\n# 패키지 번들링 최적화하기\n\n외부 패키지를 번들링하면 애플리케이션의 성능을 크게 향상시킬 수 있어요. Next.js에서는 기본적으로 Server Components와 Route Handlers 안에서 임포트한 패키지들을 자동으로 번들링해줍니다. 이번 글에서는 패키지 번들링을 어떻게 분석하고, 더 최적화할 수 있는지 알려드릴게요.\n\n## 자바스크립트 번들 분석하기\n\n`@next/bundle-analyzer`는 Next.js에서 사용 가능한 플러그인으로, 애플리케이션 번들의 크기를 관리하는 데 도움을 줍니다. 이 플러그인은 각 패키지와 그 의존성들의 크기를 시각적으로 보여주는 리포트를 만들어줘서, 큰 크기의 패키지를 찾아내거나 코드 스플리팅, 혹은 지연 로딩(lazy loading)을 적용하는 데 활용할 수 있죠.\n\n### 추가 팁!\n\n- 번들 크기가 예상보다 크다면, 대체할 수 있는 가벼운 라이브러리가 있는지 찾아보세요.\n- 필요하지 않은 패키지는 과감히 삭제하는 것도 중요합니다.\n- 코드 스플리팅을 활용해 페이지별로 필요한 코드만 로드하는 것도 좋은 방법이에요.\n\n필요하다면 `package.json`에 아래 명령어를 추가해서 쉽게 번들 분석을 실행할 수 있습니다.\n\n```json\n\"scripts\": {\n  \"analyze\": \"cross-env ANALYZE=true next build\"\n}\n```\n\n그리고 터미널에서 `npm run analyze` 또는 `yarn analyze` 명령어를 실행하면, 번들 분석 리포트가 뜹니다.\n\n패키지 번들 사이즈를 잘 관리하면 로딩 속도가 빨라지고 사용자 경험이 훨씬 좋아지니 꼭 신경 써보세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 설치 방법\n\n플러그인을 설치하려면 아래 명령어 중 하나를 터미널에 입력하세요:\n\n```bash\nnpm i @next/bundle-analyzer\n# 또는\nyarn add @next/bundle-analyzer\n# 또는\npnpm add @next/bundle-analyzer\n```\n\n그다음, `next.config.js` 파일에 번들 분석기 설정을 추가해주면 됩니다.\n\n---\n\n참고로, `@next/bundle-analyzer`는 Next.js 프로젝트에서 번들 크기를 시각적으로 확인할 수 있게 도와줘서, 최적화 작업할 때 정말 유용한 도구예요. 어떤 파일이 용량이 큰지, 어디에 리소스를 많이 쓰는지 쉽게 파악할 수 있거든요.\n\n`next.config.js`에 설정하는 예시는 다음과 같아요:\n\n```js\nconst withBundleAnalyzer = require('@next/bundle-analyzer')({\n  enabled: process.env.ANALYZE === 'true',\n});\n\nmodule.exports = withBundleAnalyzer({\n  // 기존 Next.js 설정들...\n});\n```\n\n실행할 때 `ANALYZE=true` 환경 변수를 주면 번들 분석기가 활성화되고, 그렇지 않으면 비활성화되어 평상시에는 빌드 속도에 영향을 주지 않아요.\n\n이를 통해 필요할 때만 번들 분석기를 켜고, 평상시에는 쾌적한 개발 환경을 유지할 수 있습니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이번에는 Next.js 프로젝트에서 번들 사이즈를 쉽게 분석할 수 있는 방법을 알려드릴게요. 번들러 분석기를 붙여서, 빌드 결과물을 시각적으로 확인할 수 있게 해주는 도구인데요. 다음과 같이 `@next/bundle-analyzer` 패키지를 활용하면 됩니다.\n\n먼저, `next.config.js` 파일에 아래처럼 설정을 추가해 주세요:\n\n```js\n/** @type {import('next').NextConfig} */\nconst nextConfig = {}\n\nconst withBundleAnalyzer = require('@next/bundle-analyzer')({\n  enabled: process.env.ANALYZE === 'true',\n})\n\nmodule.exports = withBundleAnalyzer(nextConfig)\n```\n\n여기서 핵심은 `ANALYZE` 환경 변수를 `true`로 설정해서, 번들 분석 기능을 켜는 거예요. 실제 빌드를 할 때만 분석기가 동작하도록 설정해서, 평소에는 성능에 영향이 없도록 해 줍니다.\n\n분석 보고서를 보려면, 아래 명령어 중 하나를 내리면 끝!\n\n```bash\nANALYZE=true npm run build\n# or\nANALYZE=true yarn build\n# or\nANALYZE=true pnpm build\n```\n\n이렇게 하면, 빌드가 완료된 후에 `.next` 폴더 안에 번들 분석 리포트가 생성되는데요, 기본적으로는 브라우저에서 시각적인 트리맵 형태를 확인할 수 있어요.\n\n---\n\n### 조금 더 팁!\n\n- 번들 분석기를 쓰는 이유는 무엇일까요? 프로젝트가 커질수록 예상치 못한 패키지가 번들에 포함되거나, 너무 큰 라이브러리가 들어가서 페이지 로딩 속도가 느려질 수 있어요. 이걸 시각적으로 확인하고 최적화 방향을 잡을 수 있답니다.\n- `withBundleAnalyzer`처럼 Next.js는 여러가지 플러그인 형태의 설정을 감싸서 사용할 수 있어요. 만약 다른 기능을 같이 쓰는 중이라면 `compose` 형태로 합쳐주는 방법도 찾을 수 있습니다.\n- 만약 자동으로 보고서를 열고 싶다면, 추가 설정을 주거나 별도의 스크립트를 작성해도 좋습니다.\n\n이제 내 프로젝트 번들이 얼마나 크고, 어디에 무거운 부분이 있는지 손쉽게 분석해 보세요! 개발할 때 정말 큰 도움이 될 거예요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n보고서는 브라우저에서 세 개의 새 탭을 열어서 확인할 수 있어요. 이렇게 주기적으로 애플리케이션의 번들 파일을 평가하는 습관은 시간이 지나도 앱 성능을 잘 유지하는 데 큰 도움이 된답니다.\n\n## 패키지 임포트 최적화하기\n\n예를 들어 아이콘 라이브러리 같은 패키지는 수백 개의 모듈을 한꺼번에 내보내서, 개발 환경이나 실제 서비스 환경 모두에서 성능 저하를 일으킬 수 있어요.\n\n그럴 때는 next.config.js 파일에 `optimizePackageImports` 옵션을 추가해보세요. 이 설정을 하면 실제로 사용하는 모듈만 로딩해서 불필요한 코드가 빠져나가거든요. 게다가 여전히 여러 개의 네임드 익스포트를 사용하는 것처럼 깔끔하게 import 문을 작성할 수 있어서, 개발할 때도 편리하답니다.\n\n---\n\n추가로, 이 방법은 번들 크기를 줄여 로딩 속도를 개선할 뿐 아니라, 특히 대형 프로젝트에서 빌드 시간도 단축시켜주니까 꼭 적용해보길 권해요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js 설정에서 `optimizePackageImports`와 `serverExternalPackages` 옵션에 대해 알아볼게요.\n\n---\n\n```js\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  experimental: {\n    optimizePackageImports: ['icon-library'],\n  },\n}\n\nmodule.exports = nextConfig\n```\n\n위 코드는 `experimental.optimizePackageImports`에 `'icon-library'`라는 특정 라이브러리를 넣어둔 모습인데요, 이 옵션은 Next.js가 이 라이브러리를 임포트할 때 최적화하도록 지시하는 역할을 해요.\n\n### 자동 최적화되는 라이브러리가 있다?!  \n사실 Next.js는 기본적으로 자주 쓰이는 몇몇 라이브러리들을 알아서 최적화해주고 있어서, 모든 라이브러리를 `optimizePackageImports`에 적어줄 필요는 없답니다. 예를 들어 React, lodash 등 자주 쓰이는 라이브러리는 이미 최적화 대상에 포함되어 있어서 따로 추가 안 해도 된다구요.  \n> [Next.js 공식 문서](https://nextjs.org/docs/pages/building-your-application/configuring/optimizing-packages#opt-in-to-automatic-package-import-optimization)에서 최적화 대상 라이브러리 ‘풀 리스트’를 확인할 수 있어요. \n\n### 서버 사이드에서 번들링 제외하기  \n\nNext.js에서는 **서버 컴포넌트(Server Components)** 와 **라우트 핸들러(Route Handlers)** 내부에서 임포트한 패키지들은 기본적으로 번들링되어 배포돼요. 근데 가끔씩은, 특정 패키지를 번들링 대상에서 제외하고 싶을 때가 있습니다. 이럴 때는 `serverExternalPackages` 옵션을 사용하면 되는데요! 예를 들면 이렇게요:\n\n```js\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  experimental: {\n    serverExternalPackages: ['some-server-only-package'],\n  },\n}\n\nmodule.exports = nextConfig\n```\n\n`serverExternalPackages`에 등록한 패키지는 서버 번들에서 제외되고, 런타임에 직접 Node.js 환경에서 불러와 사용하게 됩니다. 이러면 서버 번들 크기를 좀 더 가볍게 유지하거나, 예를 들어 네이티브 모듈이나 빌드 시점에 번들링 불가능한 라이브러리를 다룰 때 도움이 돼요.\n\n---\n\n### 정리하자면  \n\n| 설정 옵션               | 역할                                                         |\n|------------------------|------------------------------------------------------------|\n| `experimental.optimizePackageImports` | 특정 클라이언트 라이브러리를 import 최적화하도록 설정        |\n| `experimental.serverExternalPackages` | 서버 컴포넌트, 라우트 핸들러 번들에서 제외할 패키지를 지정함   |\n\n이 옵션들은 `experimental`이 붙어있는걸로 보아 아직 완전히 안정화된 기능은 아니지만, 프로젝트에 맞게 적절히 활용하면 번들 크기 최적화에 꽤 도움이 될 수 있어요.\n\n---\n\nNext.js로 개발하면서 번들 최적화에 관심이 많다면 꼭 참고해보시고, 직접 적용해서 번들 크기 변화를 한 번 살펴보세요! 최적화가 잘 되면 페이지 로딩 속도와 사용자 경험이 훨씬 개선될 거예요. :)\n\n필요하면 더 자세한 설정법이나 실전 예제도 공유해드릴게요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안녕하세요 여러분! 오늘은 Next.js에서 `serverExternalPackages` 옵션에 대해 간단히 이야기해보려고 해요. \n\n```js\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  serverExternalPackages: ['package-name'],\n}\n\nmodule.exports = nextConfig\n```\n\n위 코드처럼 `next.config.js`에 `serverExternalPackages`에 외부 패키지 이름을 명시해주면, Next.js 서버 쪽에서 해당 패키지를 외부 모듈로 처리하도록 설정할 수 있어요. \n\n이 옵션은 서버에서만 사용하는 패키지나, Next.js가 기본적으로 번들링하지 않는 패키지를 명시할 때 유용합니다. 특히 서버 사이드에서 동작하는 Node.js 패키지를 사용할 때 문제가 발생할 수 있는데, 이때 `serverExternalPackages`에 해당 패키지를 추가해주면 해결되곤 하죠.\n\n> 참고로 Next.js가 이미 호환성을 검증하고 자동으로 제외 처리하는 인기 패키지 목록이 따로 있어요. 여러분이 직접 추가하기 전에 [Next.js 공식 문서](https://nextjs.org/docs)에서 지원하는 패키지 리스트를 확인해보는 게 좋아요. 이렇게 하면 중복 설정을 줄일 수 있거든요!\n\n---\n추가로 팁을 드리자면, 서버 외부 패키지를 추가할 때는 버전 호환성도 꼭 체크하세요. Next.js가 업데이트되면서 패키지 호환성도 변화할 수 있습니다. 그리고 외부 패키지를 너무 많이 추가하면 번들링 최적화가 어려워질 수 있으니 꼭 필요한 패키지만 추가하는 걸 추천해드려요.\n\n필요하면 Next.js의 Webpack 설정을 커스텀해서 좀 더 세밀한 번들링 조정도 가능합니다. 나중에 기회되면 Webpack 설정과 함께 리뷰해볼게요!\n\n궁금한 점 있으면 댓글 남겨주세요~ 개발 재미있게 함께 해봐요! 🚀","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":8},{"title":"Next.js 15에서 부분 프리렌더링(Partial Prerendering) 활용하는 방법","description":"","date":"2025-04-22 02:03","slug":"2025-04-22-PartialPrerendering","content":"\n# 부분 프리렌더링 (Partial Prerendering)\n\n> 참고: 부분 프리렌더링은 아직 실험적인 기능으로, Next.js의 캐나리 버전에서만 사용 가능하며 추후 변경될 수 있습니다. 아직 프로덕션용으로는 적합하지 않아요.\n\n부분 프리렌더링은 한 경로(Route) 내에서 정적인 컴포넌트와 동적인 컴포넌트를 동시에 사용할 수 있게 해 주는 기능입니다.\n\n어떻게 동작하냐면, 빌드 타임에 Next.js가 가능한 한 경로의 내용을 미리 렌더링해줍니다. 그런데 만약 동적 코드를 발견했다면(예를 들면, 들어오는 요청에서 데이터를 읽는다거나 할 때), 그 부분을 React Suspense 경계로 감싸줄 수 있어요. 이렇게 Suspense로 감싸진 컴포넌트는 빌드 시점에 실제 동적 데이터 대신 'fallback' UI가 미리 렌더링된 HTML로 포함됩니다.\n\n즉, 정적인 부분은 그대로 미리 렌더링하고, 동적인 부분은 사용자가 페이지를 요청할 때 불러오는 방식을 섞어 쓸 수 있는 거죠.\n\n---\n\n### 조금 더 쉽게 이야기하면?\n\n보통 Next.js의 정적 페이지는 모든 내용을 빌드할 때 미리 만들어 놓아요. 그런데 동적인 데이터가 있으면 빌드할 때 알 수 없으니 SSR(서버 사이드 렌더링) 방식으로 페이지를 채우죠. Partial Prerendering은 이 두 가지 방식을 한 페이지에서 섞어 쓸 수 있게 해 줍니다.\n\nReact Suspense를 잘 활용할 줄 안다면, 특정 컴포넌트에서 데이터를 읽는 부분만 동적으로 처리하고, 나머지는 미리 만들어진 HTML로 빠르게 보여줄 수 있다는 뜻입니다.\n\n---\n\n### 참고로 알아두면 좋은 점\n\n- 현재는 실험적인 기능이니 코드에 적용할 때는 주의하세요.\n- Suspense fallback UI가 어떻게 보일지 신경 써야 합니다. 너무 단순하면 사용자 경험이 떨어질 수 있어요.\n- Next.js가 이 기능을 점점 개선할 예정이기 때문에 공식 문서나 릴리즈 노트를 꾸준히 확인하는 게 좋아요.\n\n이런 기능 덕분에 더 빠르고 유연한 렌더링 경험을 제공하는 것이 앞으로의 목표입니다!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/TIL/assets/img/2025-04-22-PartialPrerendering_0.png\" alt=\"Partial Prerendering illustration\" />\n\n> 🎥 영상: PPR이 뭔지, 어떻게 동작하는지 궁금하다면 → YouTube에서 10분짜리 동영상으로 확인해보세요!\n\n---\n\n## 배경 이야기\n\nPartial Prerendering (부분 사전 렌더링, 이하 PPR)은 Next.js 서버가 미리 렌더링된 콘텐츠를 즉시 클라이언트에 전달할 수 있도록 도와주는 기술이에요.\n\n사실, 웹 페이지를 렌더링할 때 서버가 완전히 렌더링을 마치지 않았는데도 이미 사용자에게 콘텐츠를 보여줄 수 있으면, 빠른 첫 화면 로딩을 경험할 수 있죠. PPR은 그걸 가능하게 합니다.\n\n실제로 개발해보면, 전체 페이지를 미리 렌더링하는 것보다 특정 중요한 부분만 미리 렌더링하고, 나머지는 필요할 때 로드하게끔 하는 전략이 성능 최적화에 엄청 효과적이라는 걸 알 수 있어요.\n\n필요한 부분만 빠르게 보여주고, 나머지는 나중에 채우는 이 방법! 여러분 프로젝트에도 적용해보시면 사용자 체감 속도가 확 올라간답니다. 다음 글에서는 PPR을 Next.js에 적용하는 구체적인 방법을 소개할게요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n클라이언트에서 서버로 이어지는 워터폴 문제를 막기 위해, 동적 컴포넌트들은 초기 프리렌더링과 함께 서버에서 병렬로 스트리밍되기 시작합니다. 이렇게 하면 클라이언트의 자바스크립트가 브라우저에 완전히 로드되기 전에 동적 컴포넌트가 렌더링을 시작할 수 있어 사용자 경험이 훨씬 부드러워집니다.\n\n또한, 각각의 동적 컴포넌트마다 HTTP 요청을 여러 번 보내는 것을 막기 위해 부분 프리렌더링(Partial Prerendering, PPR)은 정적 프리렌더와 동적 컴포넌트를 하나의 HTTP 요청으로 합칠 수 있습니다. 이 덕분에 동적 컴포넌트마다 네트워크 왕복(roundtrip)이 발생하지 않고, 전체적인 로딩 속도가 크게 개선돼요.\n\n## 부분 프리렌더링(Partial Prerendering) 사용법\n\n### 점진적 도입 (버전 15 캐나리 버전 기준)\n\n---\n\n추가로, 이런 방식은 특히 대규모 애플리케이션에서 효과적이에요. 서버에서 먼저 준비된 콘텐츠를 빠르게 보여주면서도, 필요한 부분은 필요한 시점에만 동적으로 로딩하니 네트워크 자원도 효율적으로 사용할 수 있죠.\n\n또한, 만약 여러분이 React나 Next.js 같은 프레임워크를 쓴다면, 이 Partial Prerendering 기능을 잘 활용하면 SEO 측면에서도 유리하고 초기 렌더링 퍼포먼스도 개선할 수 있어요. 초기 페이지 로딩 후 바로 상호작용할 수 있게 만드는 ‘경량화’ 전략이라고 생각하면 이해가 쉬울 거예요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js 15 최신 캐나리(canary) 버전에서 'Partial Prerendering(PPR)' 기능이 실험적으로 도입되었어요. 아쉽게도 아직 안정화 버전에는 포함되어 있지 않습니다. 혹시나 미리 사용해보고 싶다면 캐나리 버전을 설치해야 하는데요, 아래 명령어를 터미널에 입력하면 됩니다.\n\n```bash\nnpm install next@canary\n```\n\n설치 후에는 프로젝트의 `next.config.js` 파일을 열어서 `ppr` 옵션을 `'incremental'`로 설정해 주세요. 그리고 다음과 같이 `experimental` 설정 안에 넣어주면 되는데요:\n\n```js\nimport type { NextConfig } from \"next\";\n\nconst nextConfig: NextConfig = {\n  experimental: {\n    ppr: \"incremental\",\n  },\n};\n\nexport default nextConfig;\n```\n\n그리고 페이지나 레이아웃 파일 상단에서 `experimental_ppr` 라우트 구성 옵션을 내보내면 부분 프리렌더링을 점진적으로 적용할 수 있어요.\n\n> 참고로, Partial Prerendering은 렌더링되지 않은 부분만 클라이언트에서 처리하면서도, 전체 페이지는 정적으로 일부 미리 렌더링하는 기술이에요. 그래서 초기 로딩은 빠르게 하면서도 일부 동적 변경이 가능한 유연한 페이지 구성이 가능하답니다.\n\n다만, 아직 실험 단계기 때문에 사용하면서 생길 수 있는 문제에 대비해 꼭 테스트 환경에서 충분히 점검하는 걸 추천드려요. 안정 버전이 나오면 더 많은 업데이트와 공식 문서가 함께 제공될 테니 주목해 주세요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n리액트(Next.js)에서 실험적 기능인 `experimental_ppr`(Partial Prerendering)를 활용하는 코드와 관련하여 알아두면 좋은 내용들을 정리해볼게요. 조금 쉽게 설명해볼게요!\n\n먼저, 제공된 코드를 보면 이렇게 생겼어요:\n\n```js\nimport { Suspense } from \"react\";\nimport { StaticComponent, DynamicComponent, Fallback } from \"@/app/ui\";\n\nexport const experimental_ppr = true;\n\nexport default function Page() {\n  return (\n    <>\n      <StaticComponent />\n      <Suspense fallback={<Fallback />}>\n        <DynamicComponent />\n      </Suspense>\n    </>\n  );\n}\n```\n\n---\n\n## 핵심 포인트! `experimental_ppr`란?\n\n- Next.js에서는 각 라우트별로 부분 프리렌더링을 할 수 있어요. (PPR)\n- **PPR(Partial Prerendering)**를 활용하려면, 라우트 최상위에 `export const experimental_ppr = true`를 반드시 선언해야 해요.\n- 만약 선언하지 않으면, 기본값은 `false`로 설정되어서 **프리렌더링이 되지 않아요**.\n- 이 설정은 해당 라우트뿐만 아니라, 그 아래 자식 라우트나 레이아웃까지 적용돼요.\n- 자식 라우트에서 PPR을 끄고 싶으면 자식 라우트에 `experimental_ppr = false`를 설정하면 됩니다.\n\n즉, `experimental_ppr` 옵션은 라우트 트리에서 상위(루트) 영역에만 넣으면 자식까지 적용이 돼서 여러 파일에 일일이 선언할 필요 없어요.\n\n---\n\n## Suspense와 dynamic components (동적 컴포넌트) 이야기\n\nPPR을 사용하는 라우트에서, Next.js 빌드 시에 반드시 동적 API 호출을 포함하는 컴포넌트는 `React.Suspense`로 감싸줘야 해요.\n\n- `Suspense`가 없다면 자동 프리렌더링이 제대로 작동하지 않아요.\n- `Suspense fallback`은 프리렌더된 페이지에서 **유저가 로딩 중일 때 보여질 UI**를 담당해줘요.\n- 위 코드에서는 `<Fallback />` 컴포넌트를 로딩 중임을 보여주기 위해 넣었죠!\n\n---\n\n## 추가로 알아두면 좋은 것들\n\n### 1. 왜 PPR을 쓰는 걸까?\n\n전통적인 SSR은 모든 데이터를 서버에서 다 받아와서 렌더링해버려서, 느린 API나 복잡한 로직이 있으면 전체 페이지 로딩 시간이 느려질 수 있어요.\n\nPPR은 정적 생성(Static Generation)과 SSR의 중간 느낌으로, \"정적 프리렌더링 중 동적 컴포넌트만 나중에 클라이언트 쪽에서 로딩\"하는 방식이에요.\n\n덕분에:\n\n- 페이지 첫 로딩은 빠르면서도,\n- 자주 바뀌는 동적인 부분은 필요한 시점에만 로딩 가능해요.\n\n### 2. `export const experimental_ppr = true`는 실험 기능!\n\n현재는 아직 실험 단계라서 문서나 API가 조금씩 바뀔 수 있어요. 프로덕션 서비스라면 주의해서 사용해야 하죠.\n\n---\n\n## 요약해서 정리한 표!\n\n| 내용                 | 설명                                                               |\n| -------------------- | ------------------------------------------------------------------ |\n| `experimental_ppr`   | 라우트(또는 세그먼트)에 프리렌더링을 활성화하는 플래그             |\n| 기본값               | false                                                              |\n| 적용범위             | 상위 세그먼트에만 선언하면 하위(자식 라우트, 레이아웃)에도 적용됨  |\n| 동적 컴포넌트 감싸기 | 동적 로딩 컴포넌트는 React Suspense로 감싸야 하며 fallback UI 필요 |\n| fallback UI          | 로딩 중 보여줄 UI. 보통 스피너나 텍스트 형태의 임시 UI를 넣음      |\n| 사용 목적            | 빠른 페이지 로딩 & 프리랜더링과 동적 API 호출의 적절한 조화        |\n| 주의점               | 아직 실험 기능이므로 버전 업에 따라 동작 변경 가능                 |\n\n---\n\n이렇게 `experimental_ppr`와 Suspense를 잘 활용하면 Next.js 앱에서 빠르고 유연한 프리렌더링을 경험할 수 있어요!\n\n필요하면 더 자세한 예제나, 로딩 UI 디자인 팁도 공유할 수 있으니, 언제든 요청해 주세요. 😊\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예를 들어 쿠키나 헤더 같은 함수들을 사용할 때는 이렇게 하게 돼요:\n\n```js\nimport { cookies } from \"next/headers\";\n\nexport async function User() {\n  const session = (await cookies()).get(\"session\")?.value;\n  return \"...\";\n}\n```\n\n위 코드에서 `User` 컴포넌트는 들어오는 요청(request)을 보고 쿠키를 읽어야 해서, 이 컴포넌트를 PPR(Pre-Rendering with React)로 사용하려면 Suspense로 감싸줘야 합니다.\n\nVue에서는 Suspense가 없지만, React에선 비동기 처리를 하면서도 사용자 경험을 끊기지 않게 해주는 좋은 기능이에요. 예를 들면 이렇게요:\n\n```js\nimport { Suspense } from \"react\";\nimport { User, AvatarSkeleton } from \"./user\";\n\nexport const experimental_ppr = true;\n\nexport default function Page() {\n  return (\n    <section>\n      <h1>This will be prerendered</h1>\n      <Suspense fallback={<AvatarSkeleton />}>\n        <User />\n      </Suspense>\n    </section>\n  );\n}\n```\n\n여기서 핵심은 `Suspense`의 `fallback` 프로퍼티에 로딩 상태에서 보여줄 UI를 넣어준다는 점이에요. 예시에서는 `AvatarSkeleton`이 그 역할을 하죠. 즉, `User` 컴포넌트가 쿠키를 읽어 세션 정보를 가져올 때까지 사용자에게 깜빡이며 로딩 중임을 알려주고, 완료되면 실제 UI를 렌더링하는 거죠.\n\n이렇게 하면 서버에서 미리 렌더링하는 부분과, 클라이언트에서 비동기적으로 받아와야 할 데이터가 함께 있어도 깔끔하게 처리할 수 있습니다. 특히 Next.js 최신 버전에서 SSR과 클라이언트 사이드 데이터 fetching을 조합할 때 정말 유용해요.\n\n추가 팁을 드리자면:\n\n- `cookies()` 같은 함수는 서버 측에서만 호출 가능해요. 클라이언트 컴포넌트에선 사용할 수 없으니 주의하세요.\n- Suspense를 활용하면서 데이터 fetching이 비동기임을 명확히 해줘야 하므로, 해당 컴포넌트는 async 함수로 작성하고 반드시 프로미스를 반환해야 해요.\n- PPR을 실험적으로 사용한다면, 나중에 정식 지원 상태를 꼼꼼히 확인하는 게 좋습니다. API가 변할 수도 있으니까요!\n\n요약하자면, 서버에서 요청별로 쿠키를 읽어야 하면, 해당 컴포넌트를 Suspense로 감싸서 로딩 상태를 관리하며 안전하게 렌더링하는 패턴! Next.js에서 점점 더 퍼져나가는 최신 트렌드랍니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n리액트 컴포넌트가 언제 '동적 렌더링(dynamic rendering)'을 하게 될까요? 바로 컴포넌트 내부에서 특정 값을 실제로 사용할 때입니다.\n\n예를 들어, Next.js 페이지에서 `searchParams`를 받아 이를 자식 컴포넌트에 prop으로 넘긴 상황을 생각해볼게요:\n\n```js\nimport { Table } from \"./table\";\n\nexport default function Page({ searchParams }: { searchParams: Promise<{ sort: string }> }) {\n  return (\n    <section>\n      <h1>This will be prerendered</h1>\n      <Table searchParams={searchParams} />\n    </section>\n  );\n}\n```\n\n위 코드에서 `Page` 컴포넌트는 `searchParams`를 받아서 내부 `Table` 컴포넌트로 전달하고 있는데요. 중요한 점은, 이 `Page` 컴포넌트 자체는 프리렌더링(정적 생성)이 되지만, `Table` 컴포넌트 안에서 이 `searchParams` 값을 실제로 읽으면, `Table`만 동적 렌더링 상태로 전환됩니다.\n\n즉, 부모는 정적으로 렌더링 되다가, 자식에서 비동기 값을 접근하는 순간 그 자식 컴포넌트는 실시간으로 렌더링되는 거죠. 이런 방식으로 불필요한 동적 렌더링을 방지하면서, 꼭 필요한 부분만 동적으로 처리할 수 있는 효율적인 구조가 완성됩니다.\n\n---\n\n추가로, 만약 `searchParams`를 여러 군데서 반복해서 사용한다면, 값을 미리 받아서 context에 저장하거나 캐싱하는 방법도 좋아요. 그래야 여러 컴포넌트에서 같은 값을 비동기로 반복 요청하는 부담을 줄일 수 있죠. 개발하면서 이런 패턴을 잘 활용하면 렌더링 성능과 사용자 경험이 꽤 좋아질 거예요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안녕하세요! 오늘은 React 컴포넌트에서 `searchParams`를 비동기 함수로 받아올 때 주의할 점에 대해 같이 살펴볼게요.\n\n아래 예제를 보실까요?\n\n```js\nexport async function Table({ searchParams }: { searchParams: Promise<{ sort: string }> }) {\n  const sort = (await searchParams).sort === \"true\";\n  return \"...\";\n}\n```\n\n여기서 `searchParams`가 `{ sort: string }` 객체를 반환하는 Promise네요. 그래서 컴포넌트 함수 앞에 `async` 키워드를 붙이고, `await`로 값을 받아옵니다.\n\n하지만 React 컴포넌트에서 이렇게 `async` 함수를 직접 쓰는 게 늘 좋은 방식은 아니에요. 왜냐하면 컴포넌트 자체가 렌더링 시 동기적으로 작동하는 걸 기대하기 때문에, 여기에 비동기 처리를 넣으면 의도치 않은 동작이나 렌더링 지연이 발생할 수 있거든요.\n\n그래서 보통은 이런 식으로:\n\n- `getServerSideProps` (Next.js) 같은 서버사이드 데이터 로딩 함수에서 데이터를 먼저 받고,\n- 데이터를 props로 내려받아 컴포넌트는 동기적으로 렌더링하는 게 깔끔해요.\n\n만약 Next.js의 **App Router**를 사용중이라면, 페이지나 UI 컴포넌트에서 `searchParams`는 이미 동기적인 객체로 제공됩니다. 그래서 이렇게 쓸 수 있죠:\n\n```tsx\ntype TableProps = {\n  searchParams: { sort?: string };\n};\n\nexport default function Table({ searchParams }: TableProps) {\n  const sort = searchParams.sort === \"true\";\n  return <div>정렬 상태: {sort ? \"활성화\" : \"비활성화\"}</div>;\n}\n```\n\n마지막으로 `sort` 값을 단순히 문자열 `\"true\"`와 비교했는데, 혹시 `\"true\"`나 `\"false\"` 외에 다양한 값이 올 수도 있으니 `Boolean` 변환이나 다른 검증 로직도 상황에 맞게 활용해보세요!\n\n---\n\n### 짧은 요약\n\n| 문제점                                           | 해결법                                                                  |\n| ------------------------------------------------ | ----------------------------------------------------------------------- |\n| 컴포넌트를 `async` 함수로 만들어 비동기 받아오기 | 서버사이드 또는 별도 데이터 fetching 함수로 데이터 받고, props로 넘기기 |\n| `searchParams` Promise 형태 사용                 | Next.js App Router에서는 동기 객체로 바로 받아 사용 가능                |\n\n이렇게 살짝만 더 신경 쓰면 깔끔하고 버그 없이 데이터를 다룰 수 있어서 추천드립니다! 필요하면 더 깊게 React와 Next.js의 데이터 흐름도 알려드릴게요~ 행복한 개발 되세요! 🚀\n","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":12},{"title":"Next.js 15에서 Incremental Static Regeneration(ISR)로 정적 웹사이트 업데이트 하기","description":"","date":"2025-04-22 02:01","slug":"2025-04-22-IncrementalStaticRegenerationISR","content":"\n\n# Incremental Static Regeneration (ISR)이란?\n\n안녕하세요! 오늘은 **Incremental Static Regeneration (ISR)**에 대해 쉽고 간단하게 이야기해보려고 해요. ISR은 특히 Next.js 같은 프레임워크에서 자주 쓰이는 개념인데, 기본적으로 정적 페이지를 효율적으로 업데이트할 수 있게 해주는 방법이에요.\n\n---\n\n## ISR이 왜 좋을까?\n\n- **전체 사이트를 다시 빌드하지 않아도 돼요!**  \n  기존에 정적으로 생성된 페이지들을 모두 다시 생성하는 대신, 바뀐 페이지만 업데이트할 수 있답니다.\n\n- **서버 부하가 줄어들어요.**  \n  거의 대부분의 요청에 대해 이미 만들어진 정적 페이지를 바로 보여주기 때문에 서버가 한결 가벼워져요.\n\n- **cache-control 헤더가 자동으로 달려요.**  \n  페이지마다 적절한 캐시 정책이 적용되어서, 사용자에게 빠른 경험을 제공할 수 있어요.\n\n- **콘텐츠가 많은 사이트도 걱정 끝!**  \n  많은 페이지를 가진 사이트도 빌드 시간이 너무 길어지는 걸 피할 수 있어요.\n\n---\n\n## 간단한 예시\n\n다음은 ISR을 활용한 아주 기본적인 Next.js의 `getStaticProps` 예시입니다.\n\n```jsx\nexport async function getStaticProps() {\n  const data = await fetchDataSomehow();\n\n  return {\n    props: {\n      data,\n    },\n    // 페이지가 60초마다 다시 생성되도록 설정\n    revalidate: 60,\n  };\n}\n```\n\n위에서 핵심은 `revalidate` 키예요. 여기서 60초를 지정했으니, 사용자가 페이지에 접속할 때마다 적어도 60초가 지난 후에는 새로 데이터를 가져와서 페이지를 다시 만들어줘요. \n\n즉, \"최소 60초 주기로 페이지를 갱신한다\" 라고 이해하면 돼요.\n\n---\n\n## 좀 더 알려드리는 팁!\n\n- `revalidate`에 너무 짧은 시간을 설정하면, 서버 부하가 다시 올라갈 수 있으니 적당한 값을 찾는 게 중요해요.\n- 현재 Next.js는 ISR을 사용하면서 자동으로 incremental cache를 관리해줍니다. 덕분에 개발자가 별도로 캐싱 로직을 신경 쓸 필요가 줄어듭니다.\n- 빌드 후 데이터가 자주 변경되는 뉴스, 블로그, 마켓플레이스 같은 서비스에서 굉장히 빛을 발합니다.\n\n---\n\n자, 오늘은 ISR에 대해서 간단히 알아봤는데요. 정적 사이트의 장점과 동적인 데이터 갱신을 함께 누리고 싶은 분들에게 정말 추천드리는 기술이에요. 더 궁금한 점이나 실제 예제 궁금하면 언제든지 댓글 달아주세요! 😊\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여러분, Next.js에서 동적 라우팅과 ISR(Incremental Static Regeneration)을 활용하는 예제를 하나 같이 살펴볼게요! 위에 작성된 코드를 바탕으로 우리 블로그 포스트 페이지를 만든다고 가정해봅시다.\n\n### 이 코드가 뭘 하는 거냐면요\n\n- `generateStaticParams` 함수 안에서 `https://api.vercel.app/blog` API를 호출해, 빌드 시점에 미리 25개의 블로그 포스트 경로를 생성해요.\n- 이렇게 미리 생성된 페이지들은 사용자 요청 시 즉시 로드되고 캐시되죠.\n- `revalidate = 60` 설정 덕분에, 60초마다 페이지가 백그라운드에서 다시 생성됩니다. 즉, 오래된 페이지를 보여주더라도 동시에 최신 페이지를 서버에서 준비시키는 거예요.\n- 만약 아직 생성하지 않은 새로운 블로그 포스트 URL이 들어오면, `dynamicParams = true` 설정 때문에 404 대신 서버에서 해당 페이지를 “on-demand”로 생성해줍니다.\n\n한 마디로, 정적 생성과 서버 사이드 렌더링의 장점을 적절히 섞어 어떤 페이지는 미리 생성해 빠르게 제공하고, 새 페이지는 요청이 들어올 때 만들어서 서비스하는 똑똑한 방식인 거죠!\n\n---\n\n### 조금 더 풀어서 설명해볼게요!\n\n| 설정                     | 설명                                                        |\n|-------------------------|-------------------------------------------------------------|\n| `revalidate = 60`       | 한번 캐싱한 페이지는 60초간 다시 생성하지 않고 캐시를 사용함. 60초 후 첫 요청 때 백그라운드로 새 페이지를 생성함. |\n| `dynamicParams = true`  | `generateStaticParams`에 없는 경로가 요청되면 404가 아닌 동적으로 페이지를 생성함. |\n| `generateStaticParams`  | 빌드 타임에 미리 생성할 동적 경로 목록을 반환함. 이 예제는 모든 블로그 포스트 ID가 여기 포함됨. |\n| `Page` 컴포넌트          | 요청된 `id` 파라미터로부터 해당 포스트를 API에서 받아와서 렌더링함. |\n\n---\n\n### 추가적으로 알아두면 좋은 점!\n\n- 이 방식은 데이터가 자주 변하지 않는 콘텐츠에 딱 맞아요. 아주 빠른 실시간 업데이트는 어렵지만, 몇 분 단위 변경이라면 사용자 경험을 살릴 수 있습니다.\n- 만약 완전 최신 데이터가 필요하면 `revalidate`를 0으로 두고 매 요청마다 서버 렌더링(SSR)을 할 수도 있어요. 하지만 속도는 느려질 수 있죠.\n- Next.js 13버전 이상에서 도입된 이 방식은 ISR과 동적 라우팅을 동시에 처리할 때 좋은 선택이니, 블로그나 뉴스 사이트 같은 프로젝트에 활용해보세요!\n\n---\n\n필요하면 제가 이 코드를 기반으로 직접 해볼 수 있는 샘플 프로젝트도 만들어서 공유해드릴게요. 혹시 관련해서 궁금한 점, 더 깊게 알고 싶은 부분 있으면 편하게 물어봐 주세요!\n\n참고로 공식 문서도 정말 잘 정리되어 있으니 한 번 쭉 읽어보시면 큰 도움이 됩니다.\n\n---\n\n## 참고 자료\n\n- [Next.js Dynamic Routes & ISR 공식 문서](https://nextjs.org/docs/app/building-your-application/routing/dynamic-routes#incremental-static-regeneration)\n- [Next.js 13 App Router 소개](https://nextjs.org/docs/getting-started/upgrade-guide#app-router)\n\n다음에도 쓸모 있는 Next.js 팁으로 찾아올게요! :)\n\n---\n\n> 혹시 이 내용을 마크다운 문서로 쓰거나 블로그에 올리고 싶다면 추가 설명과 코드는 댓글로도 언제든 요청해 주세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 라우트 세그먼트 설정(Route segment config)\n\n라우트를 잘 관리하려면 설정할 수 있는 옵션들이 몇 가지 있는데요, 대표적으로 `revalidate`와 `dynamicParams`가 있어요.\n\n| 옵션 이름       | 설명                                                         |\n|----------------|--------------------------------------------------------------|\n| revalidate     | 해당 라우트 데이터를 다시 검증하는 주기(초 단위)를 설정해요. 이걸 설정하면 데이터를 자동으로 갱신해서 최신 상태를 유지할 수 있답니다.  |\n| dynamicParams  | 라우트에서 동적 파라미터를 사용할지 여부를 결정해요. 동적 파라미터란 URL 경로 내에서 변하는 값들을 말하죠(예: `/post/[id]`의 `id`). 이 옵션으로 다루는 방식을 설정할 수 있어요. |\n\n---\n\n### 함수 소개(Functions)\n\n`revalidate`와 연관해서 사용할 수 있는 함수들도 있어요! 주로 캐시를 새로고침하거나 특정 경로를 다시 유효화하는 용도로 쓰이는데요.\n\n| 함수 이름       | 설명                                                                                          |\n|----------------|-----------------------------------------------------------------------------------------------|\n| revalidatePath  | 특정 경로(path)에 대해 데이터를 재검증하도록 요청하는 함수예요. 예를 들어, 어떤 글을 수정한 후 그 경로를 갱신할 때 사용하죠.  |\n| revalidateTag   | 태그(tag)를 이용해 어느 그룹에 속한 데이터들을 한 번에 다시 검증하도록 할 수 있어요. 여러 경로를 묶어서 관리할 때 유용해요.       |\n\n---\n\n### 덧붙여서\n\nNext.js 같은 최신 웹 프레임워크들에서 이런 revalidation 시스템을 잘 활용하면, 서버의 부담을 크게 줄이면서도 사용자에게 항상 최신 데이터를 보여줄 수 있어요. 예를 들어, 자주 변하지 않는 페이지는 캐시를 오래 유지하고, 실시간으로 변하는 페이지는 자주 재검증해서 최적 성능을 유지할 수 있죠.\n\n또한, `dynamicParams` 옵션을 올바르게 설정하면, 빌드 시에 미리 생성할 경로나 런타임에 처리할 경로를 적절하게 나눌 수 있어서 프로젝트 구조를 깔끔하게 유지하는데 큰 도움이 돼요.\n\n이런 설정과 함수들을 잘 이해하고 활용해보시면, 더욱 빠르고 효율적인 웹앱을 만들 수 있답니다. 궁금하신 점 있으면 언제든 질문 주세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 예시\n\n### 시간 기반 리밸리데이션(Time-based Revalidation)\n\n이 예시는 `/blog` 경로에서 블로그 글 목록을 불러와 보여주는 방법이에요. 그리고 중요한 점은 페이지에 캐시된 데이터가 1시간마다 새로 고쳐진다는 거죠. \n\n어떻게 동작하냐면, 첫 방문 시 데이터를 불러와서 캐시에 저장합니다. 그 후 1시간이 지나 다음에 페이지를 방문하면, 기존 캐시를 바로 버리고 다시 가져오는 게 아니라, 사용자에게는 기존 페이지를 보여주면서 백그라운드에선 새로운 글 목록으로 페이지를 다시 생성해 캐시를 업데이트해요. 덕분에 사용자는 항상 빠르고 끊김 없는 경험을, 백엔드는 최신 데이터를 보장할 수 있답니다.\n\n```js\ninterface Post {\n  id: string\n  title: string\n  content: string\n}\n \nexport const revalidate = 3600 // 3600초 = 1시간마다 캐시 무효화\n \nexport default async function Page() {\n  const data = await fetch('https://api.vercel.app/blog')\n  const posts: Post[] = await data.json()\n  return (\n    <main>\n      <h1>Blog Posts</h1>\n      <ul>\n        {posts.map((post) => (\n          <li key={post.id}>{post.title}</li>\n        ))}\n      </ul>\n    </main>\n  )\n}\n```\n\n---\n\n### 추가 팁!\n\n- 여기서 `revalidate` 값에 넣는 숫자는 초(seconds) 단위예요. 3600은 1시간을 의미하니까, 10분마다 갱신하려면 600으로 바꾸면 되겠죠?\n- 이렇게 시간 기반 갱신은 자주 변하지 않는 데이터에 딱이에요. 예를 들어 뉴스 헤드라인이나 프로필 정보처럼 자주 고쳐질 필요 없는 데이터를 캐시에 담기로 적합하죠.\n- 만약 데이터가 수시로 업데이트되어 즉각 반영이 필요하면 `revalidate`를 사용하지 않고 서버 사이드 렌더링(SSR) 또는 클라이언트 측 데이터 패칭을 고려해보세요.\n- `Next.js` 같은 최신 프레임워크를 쓰면 이런 캐시 전략을 아주 간편하게 구현할 수 있으니, 프로젝트에 따라 적절히 활용해보세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n재검증(revalidation) 시간을 길게 설정하는 걸 추천해요. 예를 들어, 1초 대신 1시간으로 말이죠. 만약 더 세밀한 데이터 갱신이 필요하다면 on-demand revalidation(필요할 때만 재검증)를 고려해보세요. 그리고 실시간 데이터가 꼭 필요하다면, 동적 렌더링(dynamic rendering)으로 전환하는 것도 좋은 방법입니다.\n\n### 필요할 때만 재검증: revalidatePath 활용법\n\n좀 더 정확하게 데이터 재검증을 하고 싶다면, revalidatePath 함수를 써서 페이지를 필요할 때만 무효화시키는 방법이 있어요.\n\n예를 들어, 새로운 게시글을 추가한 후에 이 Server Action을 호출하면, Server Component에서 fetch를 쓰든 DB에 직접 연결하든 상관없이 해당 경로(route)의 캐시를 지우고, Server Component가 새로운 데이터를 가져오도록 할 수 있습니다.\n\n이렇게 하면 불필요한 데이터 갱신을 줄이면서도 필요한 순간에 최신 데이터를 보여줄 수 있어서 성능과 사용자 경험 두 마리 토끼를 잡을 수 있답니다. \n\n간단하게 요약하면:\n\n| 상황                  | 추천 방법                         |\n|---------------------|------------------------------|\n| 데이터 갱신이 1초 단위로 자주 필요하다면 | on-demand revalidation 사용       |\n| 실시간 데이터가 꼭 필요하다면        | 동적 렌더링(dynamic rendering) 고려 |\n| 갱신 주기가 길어도 무방하다면       | 긴 revalidation 시간(예: 1시간) 설정 | \n\n이렇게 상황에 맞게 적절한 방법을 선택하는 게 중요해요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여러분, Next.js에서 서버 측 캐시를 관리할 때 `revalidatePath` 함수만큼 유용한 게 없어요. 위 코드처럼 `/posts` 경로의 캐시를 무효화하고 싶을 때 아주 간단하게 쓸 수 있거든요.\n\n```js\n'use server'\n \nimport { revalidatePath } from 'next/cache'\n \nexport async function createPost() {\n  // /posts 경로 캐시를 무효화하기\n  revalidatePath('/posts')\n}\n```\n\n이렇게 하면 새로운 게시글을 추가하고 나서 바로 `/posts`를 방문했을 때 최신 글 목록을 볼 수 있죠.\n\n### 근데, 만약 경로 단위가 아니라 더 세밀한 캐시 무효화가 필요하다면?\n\n바로 `revalidateTag`라는 기능을 써볼 수 있어요. 이건 fetch 요청에 태그를 달아서, 특정 태그가 붙은 데이터만 골라서 다시 불러오게 하는 방법이에요. 예를 들어, 게시글 하나하나에 태그를 붙여서 수정된 글만 빠르게 반영하도록 할 수 있죠.\n\n#### 간단 예시\n\n```js\n'use server'\n\nimport { revalidateTag } from 'next/cache'\n\nexport async function updatePost(id) {\n  // 특정 게시글에 붙은 태그를 기반으로 캐시를 무효화하기\n  revalidateTag(`post-${id}`)\n}\n```\n\nfetch를 할 때도 태그를 붙여줘야 하는데요,\n\n```js\nconst post = await fetch(`/api/posts/${id}`, {\n  next: { tags: [`post-${id}`] },\n}).then(res => res.json())\n```\n\n이렇게 하면 이 게시글은 `post-123` 같은 식으로 태그가 붙고, 해당 게시글이 업데이트될 때만 캐시가 무효화되어 더 효과적으로 리소스를 관리할 수 있답니다.\n\n---\n\n### 정리\n\n| 함수명           | 역할                           | 사용 케이스                               |\n|----------------|------------------------------|----------------------------------------|\n| `revalidatePath` | 경로 단위 캐시 무효화                | 페이지 전체를 새로 고쳐야 할 때                      |\n| `revalidateTag` | 태그 단위 캐시 무효화                | 데이터 단위로 세밀하게 캐시를 관리하고 싶을 때          |\n\n---\n\n이렇게 `revalidateTag`를 활용하면, 대용량 데이터나 자주 변경되는 목록이 있을 때 정말 도움 많이 돼요. 오늘 바로 적용해보시고 캐시 전략 더 똑똑하게 짜보세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서 데이터를 효율적으로 캐싱하고 다시 불러오는 방법에 대해 알아볼게요! 특히 `fetch` 함수와 ORM을 이용할 때, 그리고 캐시를 자동으로 재검증하는 방법까지 다뤄보겠습니다.\n\n---\n\n### 1. fetch 함수에 `next` 옵션으로 태그 지정하기\n\n```js\nexport default async function Page() {\n  const data = await fetch('https://api.vercel.app/blog', {\n    next: { tags: ['posts'] }, // 여기에 태그를 넣어 캐시를 관리할 수 있어요\n  })\n  const posts = await data.json()\n  // 이제 posts를 화면에 렌더링\n}\n```\n\n- `next: { tags: ['posts'] }` 옵션을 주면, 이 요청이 `'posts'`라는 태그와 연결돼서 관리돼요.\n- 나중에 `'posts'` 태그가 변경됐을 때 캐시를 재검증 할 수 있답니다.\n\n---\n\n### 2. ORM이나 DB 연결 시 `unstable_cache` 사용하기\n\n```js\nimport { unstable_cache } from 'next/cache'\nimport { db, posts } from '@/lib/db'\n \nconst getCachedPosts = unstable_cache(\n  async () => {\n    return await db.select().from(posts)  // 데이터베이스에서 포스트를 조회\n  },\n  ['posts'],                   // 캐시 관련 태그\n  { revalidate: 3600, tags: ['posts'] }  // 3600초(1시간)마다 재검증, tags와 연결\n)\n \nexport default async function Page() {\n  const posts = getCachedPosts()  // 캐시된 데이터를 불러옴\n  // ...\n}\n```\n\n- `unstable_cache` 함수는 캐시된 결과를 기억하며 해당 데이터를 재활용해요.\n- `revalidate` 옵션으로 몇 초마다 다시 데이터를 불러올지 설정할 수 있어요.\n- 태그를 사용해서 데이터를 더욱 세밀하게 관리 가능!\n\n---\n\n### 3. 캐시가 무효화되었을 때 재검증하기 - `revalidateTag` 활용\n\n서버 액션(Server Actions)이나 라우트 핸들러(Route Handler) 안에서 다음과 같이 캐시 태그를 재검증할 수 있습니다:\n\n```js\nimport { revalidateTag } from 'next/cache'\n\nexport async function POST(request) {\n  // 예를 들어 데이터를 변경하는 로직\n  // ...\n  \n  // 변경 후 'posts' 태그 관련 캐시를 재검증해서 최신 데이터 사용하도록 유도\n  revalidateTag('posts')\n\n  return new Response('Updated and cache revalidated')\n}\n```\n\n- 업데이트가 발생하면 캐시 무효화를 하면서 관련된 태그를 재검증합니다.\n- 이렇게 하면 데이터가 바뀌었을 때 페이지가 최신 상태로 렌더링돼요.\n\n---\n\n## 조금 더!\n\n- 이 태그 기반 캐시 전략은 여러 페이지에서 같은 API 데이터를 공유할 때 정말 유용해요.\n- `unstable_cache`는 아직 `unstable` 단계이니, 공식 문서나 업데이트 내용을 주의 깊게 지켜보는 게 좋아요.\n- `fetch` 함수의 `next` 옵션 중에 `revalidate` 값을 직접 지정할 수도 있고, `tags`와 혼합해서 사용하면 훨씬 강력한 캐싱 전략을 구성할 수 있습니다.\n\n잘 활용하면 페이지 성능과 데이터 일관성을 높일 수 있으니 여유 있을 때 한번 적용해보세요! 도움이 되셨으면 좋겠네요. 😊\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이번에는 Next.js에서 서버 측 캐시를 다루는 방법 중에서, revalidateTag 함수를 사용하는 간단한 예제를 살펴보고, 오류 처리와 캐시 위치 커스터마이징에 대해 알아볼게요.\n\n```js\n'use server'\n \nimport { revalidateTag } from 'next/cache'\n \nexport async function createPost() {\n  // 'posts'라는 태그가 붙은 모든 캐시 데이터를 무효화합니다.\n  revalidateTag('posts')\n}\n```\n\n위 코드에서 `revalidateTag('posts')`를 호출하면, 캐시에 'posts'라는 태그로 분류된 데이터가 모두 무효화되어 다음 요청 시 새로운 데이터를 다시 가져오도록 만듭니다. 이렇게 하면 게시글 리스트나 관련 콘텐츠가 업데이트될 때, 서버 캐시를 손쉽게 갱신할 수 있죠.\n\n### 예기치 않은 예외 처리 (Handling uncaught exceptions)\n\n만약 데이터 재검증 중에 에러가 발생한다면, Next.js는 바로 새로운 데이터 요청을 실패하더라도 이전에 성공적으로 생성된 데이터를 계속해서 캐시에서 제공합니다. 즉, 사용자에게는 데이터가 갑자기 사라지거나 오류가 노출되지 않고 안정적으로 서비스가 유지됩니다. 그리고 다음 요청 시점에 다시 재검증을 시도하니, 일시적인 문제라도 금방 해결됩니다.\n\n이 부분이 꽤나 유용한데, 서버 오류로 인한 서비스 중단 없이도 캐시가 안정적으로 유지되고 복구되기 때문이죠.\n\n### 캐시 위치 커스터마이징하기\n\nNext.js 내장 캐시는 기본적으로 프로젝트 내 `.next/cache` 폴더에 저장됩니다. 하지만 상황에 따라 캐시 위치를 바꾸고 싶을 때가 있죠. 예를 들어, CI/CD 환경에서 캐시를 공유하거나 특정 디스크 경로에 캐시를 두고 싶을 때가 그렇답니다.\n\nNext.js에서는 `next.config.js` 파일에서 `experimental` 설정 아래 `serverActions`와 같은 옵션을 다루듯, 캐시 관련 설정도 향후 업데이트를 기대할 수 있는데, 현재 공식 문서에서는 구체적인 캐시 위치 변경 방법은 제한적입니다. 그래도 곧 더 다양한 설정 옵션들이 추가될 예정이라서, 공식 문서를 꾸준히 확인하는 걸 추천드려요.\n\n---\n\n마지막으로 Next.js의 캐시 전략은 점점 발전 중이라서, 개발자가 직접 캐시 태그를 관리하며 성능을 최적화할 수 있는 부분이 늘고 있어요. 보다 유연하고 빠른 데이터 페칭을 위한 중요한 기능이니, 꼭 한번 직접 써보시면서 익혀두시면 좋을 것 같아요! 혹시 서비스 로딩 속도가 느리거나 데이터 최신화에 문제가 있을 때, 캐시 무효화 전략부터 점검해보세요 :)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서 페이지를 캐싱하고 재검증하는 기능인 Incremental Static Regeneration(ISR)은 동일한 캐시를 공유해서 사용해요. \n\n만약 Vercel에 배포한다면, ISR 캐시는 자동으로 안정적인 저장소에 저장되어서 데이터가 안전하게 보존되죠. 그런데 직접 서버를 운영(셀프 호스팅)할 때는 ISR 캐시가 Next.js 서버 내의 파일 시스템(디스크)에 저장돼요. Pages Router와 App Router 둘 다 셀프 호스팅할 때 이 방식이 자동으로 적용됩니다.\n\n또한 필요에 따라 Next.js 캐시 위치를 직접 설정할 수도 있어요. 이렇게 하면 캐시된 페이지와 데이터를 더 영속적인 저장소에 보관할 수 있고, 여러 컨테이너나 인스턴스에서 캐시를 공유하는 것도 가능해집니다. 더 자세한 설정 방법은 공식 문서를 참고해 보세요.\n\n---\n\n### 간단히 말해서!\n- **Vercel 배포:** 캐시 자동 저장(내구성 있는 저장소)\n- **셀프 호스팅:** 캐시가 서버 디스크에 저장\n- **캐시 위치 변경 가능:** 여러 서버 간 캐시 공유 및 데이터 보존 용도\n\n만약 캐시 문제가 발생하거나 페이지가 예상대로 재검증되지 않는다면 캐시 설정을 점검해 보는 게 좋겠죠? 다음번에는 흔한 이슈와 해결법도 함께 소개할게요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 로컬 개발 환경에서 캐시된 데이터 디버깅하기\n\nfetch API를 사용할 때, 어떤 요청이 캐시된 것인지, 혹은 캐시되지 않은 것인지 확인하고 싶다면 추가적인 로깅(logging) 설정을 해보는 게 좋아요. 이렇게 하면 네트워크 요청이 실제로 어떻게 처리되는지 한눈에 파악할 수 있답니다. \n\n예를 들어, 아래처럼 `logging` 옵션을 설정하면 모든 fetch 호출의 전체 URL(fullUrl)을 로그로 남길 수 있어요.\n\n```js\nmodule.exports = {\n  logging: {\n    fetches: {\n      fullUrl: true,\n    },\n  },\n}\n```\n\n이 설정을 통해 \"아, 이 요청은 캐시에서 바로 가져왔구나\", \"이 요청은 서버에 직접 다녀왔구나\" 같은 정보를 쉽게 알 수 있게 됩니다. 특히 복잡한 캐싱 로직을 다룰 때, 문제를 빠르게 찾아내는 데 정말 유용하죠.\n\n또한, 브라우저 개발자 도구(Network 탭)를 열어 보거나, 서버에서 캐시 헤더(Cache-Control, ETag 등)를 확인하는 것도 도움이 됩니다. 이런 방법들을 병행하면 캐시 동작을 더 명확히 이해할 수 있어요.\n\n### 프로덕션 환경에서의 올바른 동작 확인하기\n\n로컬 환경에서 잘 작동한다고 해도, 프로덕션 환경에서는 다른 조건들이 작용할 수 있어요. 그렇기 때문에 실제 운영 서버에서 캐시가 제대로 동작하는지 반드시 확인해야 합니다. 다음과 같은 점들을 체크해 보세요.\n\n- **실제 네트워크 요청 확인**: 운영 중인 서버의 로그 혹은 브라우저 개발자 도구를 통해 매 요청마다 캐시가 제대로 적용되는지 봅니다.\n- **HTTP 캐시 헤더 점검**: 서버가 올바른 캐시 정책을 설정했는지 확인해 보세요. 캐시 만료시간, 재검증(ETag, Last-Modified) 관련 헤더들이 적절히 사용되는지 중요합니다.\n- **캐시 무효화 전략 검토**: 업데이트가 필요한 데이터가 있을 때 캐시가 제대로 초기화(unset)되는지 테스트해 보아야 합니다.\n- **콘텐츠 배포 네트워크(CDN) 설정**: 만약 CDN을 사용한다면 CDN 캐시 정책도 함께 고려해야 하니, CDN 로그나 설정도 꼭 살펴보세요.\n\n이처럼 디버깅할 때 로컬 개발 환경뿐 아니라 프로덕션 환경에서의 케이스까지 살펴보면, 예상치 못한 캐싱 문제를 미리 차단할 수 있어서 안정적인 서비스를 운영할 수 있답니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프로덕션 환경에서 페이지가 제대로 캐시되고 재검증되는지 확인하려면, 로컬에서 직접 테스트해보는 게 좋아요. 방법은 간단해요!\n\n1. 먼저 `next build` 명령어로 프로젝트를 빌드합니다.\n2. 그리고 `next start`로 프로덕션용 Next.js 서버를 실행해보세요.\n\n이렇게 하면 ISR(Incremental Static Regeneration) 동작을 실제 프로덕션 환경처럼 경험할 수 있어요. \n\n그리고 개발하는 동안 캐시 동작을 좀 더 자세히 보고 싶다면, 프로젝트 루트에 있는 `.env` 파일에 아래 환경 변수를 추가해보세요.\n\n```js\nNEXT_PRIVATE_DEBUG_CACHE=1\n```\n\n이걸 넣으면 Next.js 서버 콘솔에서 ISR 캐시 히트(hit)와 미스(miss) 정보를 출력해줍니다. 덕분에 빌드 과정에서 생성된 페이지들과, 사용자 요청에 따라 어떤 경로들이 새롭게 생성되는지 세세하게 확인할 수 있죠.\n\n---\n\n추가로 팁 하나! 서버 로그를 보면서 페이지가 갱신되는 타이밍을 체크하면, 재검증 설정(`revalidate` 옵션)과 실제 동작이 잘 맞는지 쉽게 디버깅할 수 있어요. 혹시 ISR이 잘 작동하지 않는다고 느껴지면, 이 환경 변수 설정과 로그 확인부터 해보시길 추천합니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 주의할 점 (Caveats)\n\n- ISR(Incremental Static Regeneration)은 기본적으로 Node.js 런타임 환경에서만 지원돼요.\n- Static Export 방식으로 프로젝트를 만들 때는 ISR을 사용할 수 없답니다.\n- 정적으로 렌더링된 경로에서 여러 개의 fetch 요청을 하고 각각 다른 revalidate 주기를 설정했다면, 가장 짧은 시간이 ISR에 적용돼요. 하지만 Data Cache에서는 각각 설정한 재검증 주기가 따로 지켜진답니다.\n- 만약 경로 내 fetch 요청 중에 revalidate 시간이 0이거나 명시적으로 no-store가 설정되어 있다면, 그 경로는 동적으로 렌더링돼요.\n- 미들웨어(Middleware)는 on-demand ISR 요청에는 실행되지 않아요. 즉, 경로 재작성(path rewrites)이나 미들웨어 내 로직이 적용되지 않으니, 재검증할 때는 꼭 정확한 경로를 지정해야 해요. 예를 들어, /post-1로 rewrite된 경로가 아니라 /post/1과 같이 실제 경로를 사용해야 합니다.\n\n---\n\n## 버전 히스토리 (Version history)\n\n| 버전       | 변경 사항                                      |\n|------------|--------------------------------------------|\n| v14.1.0    | 커스텀 `cacheHandler`가 안정화되었어요.          |\n| v13.0.0    | App Router가 도입되었답니다.                      |\n| v12.2.0    | Pages Router에서 On-Demand ISR이 안정화됐어요.    |\n| v12.0.0    | Pages Router에 [Bot-aware ISR fallback](https://nextjs.org/blog/next-12#bot-aware-isr-fallback)이 추가되었죠. |\n| v9.5.0     | Pages Router에 [안정화된 ISR](https://nextjs.org/blog/next-9-5)이 도입되었어요. |\n\n---\n\n이번 내용에서는 Next.js에서 ISR을 사용할 때 주의해야 할 점들과 버전별 주요 업데이트 소식을 함께 정리했는데요, 보통 ISR을 잘 활용하면 성능과 SEO 모두 잡을 수 있어 굉장히 유용해요. 다만 위에서 언급한 몇 가지 제한사항들을 꼭 숙지해서 개발 중 예상치 못한 문제가 생기지 않도록 하는 게 중요해요.\n\n또한, 버전업이 자주 되기 때문에 새로운 기능이나 안정화된 기능들은 공식 블로그나 문서를 꾸준히 체크하는 걸 추천드려요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":19}],"page":"13","totalPageCount":50,"totalPageGroupCount":3,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}