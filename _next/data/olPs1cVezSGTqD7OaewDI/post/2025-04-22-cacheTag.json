{"pageProps":{"post":{"title":"Next.js 15에서 cacheTag 사용해서 효율적으로 캐시 관리하는 방법","description":"","date":"2025-04-22 02:59","slug":"2025-04-22-cacheTag","content":"\n# cacheTag\n\ncacheTag 함수는 캐시된 데이터를 태그로 관리해서 필요한 순간에만 캐시를 지우거나 갱신할 수 있게 도와줘요. 태그를 캐시 항목에 붙여두면, 전체 캐시를 지우는 대신 특정 태그가 붙은 데이터만 골라서 재검증하거나 삭제할 수 있답니다. 이 기능 덕분에 캐시 관리가 훨씬 스마트해지고 효율적이죠!\n\n## 사용 방법\n\ncacheTag를 사용하려면, 먼저 프로젝트의 `next.config.js` 파일에서 `dynamicIO` 플래그를 활성화해야 해요. 이렇게요:\n\n```js\n// next.config.js\nmodule.exports = {\n  experimental: {\n    dynamicIO: true,\n  },\n};\n```\n\n> `dynamicIO` 옵션은 아직 실험적인 기능이라, 안정성이 필요한 프로젝트에서는 신중하게 적용하는 게 좋아요.\n\n이 설정을 한 다음, 원하는 캐시 데이터에 태그를 달아서 관리할 수 있습니다.\n\n---\n\n### 참고로 더!\n\n- 태그 관리 덕분에 특정 부분만 업데이트해야 할 때, 서버 성능과 사용자 경험이 크게 개선됩니다.\n- 이 기능은 특히 데이터가 자주 바뀌면서도 전체를 다시 로드하는 건 비효율적인 서비스(예: 뉴스 피드, 실시간 데이터 보여주는 앱 등)에 유용해요.\n- `cacheTag`를 사용하면서 동시에 어떻게 캐시 무효화 전략을 세울지 고민해보면 프로젝트의 퍼포먼스 최적화에 큰 도움이 됩니다.\n\n필요하면 다음에 캐시 사용 예제에 대해서도 알려줄게요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서 새롭게 제공하는 캐시 태그(cacheTag) 기능을 재미있게 활용해볼까요? 이번에 소개할 코드는 캐시를 더 세밀하게 관리할 수 있게 도와주는 설정과 함수예요.\n\n### 1. next.config.js 설정\n\n먼저 `next.config.js` 파일에서 실험적 기능인 `dynamicIO`를 활성화해야 해요. 이 옵션을 켜면 Next.js가 새로운 캐시 태그 기능을 사용할 수 있도록 준비된답니다.\n\n```js\nimport type { NextConfig } from \"next\";\n\nconst nextConfig: NextConfig = {\n  experimental: {\n    dynamicIO: true,\n  },\n};\n\nexport default nextConfig;\n```\n\n여기서 `dynamicIO`는 아직 완전히 안정화된 기능은 아니지만, 캐시 제어나 데이터 페칭에 좀 더 유연한 방식으로 접근할 수 있게 해줘요.\n\n---\n\n### 2. 캐시 태그 지정하기 - `cacheTag`\n\n이제 함수 안에서 `cacheTag` 함수를 써보죠! 이 함수는 하나의 문자열 태그, 혹은 문자열 배열로 캐시 태그를 지정할 수 있어요.\n\n```js\nimport { unstable_cacheTag as cacheTag } from \"next/cache\";\n\nexport async function getData() {\n  \"use cache\";\n  cacheTag(\"my-data\");\n  const data = await fetch(\"/api/data\");\n  return data;\n}\n```\n\n- 먼저 함수 최상단 `'use cache'` 디렉티브를 호출해 캐시 기능을 활성화해줍니다.\n- `cacheTag('my-data')`로 해당 함수가 사용하는 캐시 태그를 지정하죠.\n- 이렇게 하면 `my-data`라는 태그를 기준으로 캐싱되고, 이 태그만 선택적으로 무효화할 수 있습니다.\n\n이게 뭐가 좋느냐면, 데이터를 전체 페이지가 아니라 세부 단위별로 새로고침할 수 있다는 점이에요. 예를 들어, 특정 API 데이터를 업데이트해야 할 때 전체 페이지를 빌드할 필요 없이 해당 데이터만 캐시를 지우고 재생성할 수 있게 되는 거죠.\n\n---\n\n### 3. 캐시 무효화 (Cache Purge) - `revalidateTag`\n\n캐시가 오래되었거나, 데이터를 리프레시하려면 태그 단위로 캐시를 무효화하는 게 중요한데요. Next.js는 `revalidateTag` API로 이걸 쉽게 지원합니다.\n\n```js\nimport { revalidateTag } from \"next/cache\";\n\nexport async function POST() {\n  // 예: API 라우트에서 데이터가 변경될 때 해당 캐시 태그를 무효화\n  await doDataUpdate();\n  revalidateTag(\"my-data\");\n  return new Response('Cache cleared for \"my-data\" tag');\n}\n```\n\n- 위 예시처럼, 서버측 함수에서 데이터 수정 후 `revalidateTag('my-data')`를 호출하면 `'my-data'` 관련된 캐시가 모두 무효화됩니다.\n- 그러면 다음 요청 시점에 다시 최신 데이터를 받아서 캐쉬를 갱신하게 되죠.\n\n---\n\n## 요약\n\n| 기능                     | 설명                                                       |\n| ------------------------ | ---------------------------------------------------------- |\n| `experimental.dynamicIO` | Next.js에서 캐시 태그 사용을 위한 실험적 설정              |\n| `cacheTag`               | 함수 내에서 캐시 태그를 지정, 데이터 단위별 캐시 제어 가능 |\n| `revalidateTag`          | 특정 태그에 해당하는 캐시를 서버에서 강제로 무효화         |\n\n---\n\n## 한마디\n\n이번에 소개한 캐시 태그 기능은 특히 데이터가 자주 업데이트되는 상황에서 유용해요. API 응답이나 UI 컴포넌트의 일부를 효과적으로 갱신할 수 있으니, 무조건 페이지 전체를 다시 빌드하는 구조에서 벗어나고 싶다면 한 번 꼭 시도해보세요. 실험적이라 공식 문서와 버전이 바뀌는지는 꾸준히 체크하는 것도 잊지 마시고요!\n\n더 궁금한 점 있으면 언제든 댓글로 남겨주세요. 같이 공부해봐요! 😊\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위 코드는 Next.js의 서버 컴포넌트에서 캐시를 제어할 때 사용하는 예제입니다. 여기서 핵심은 revalidateTag라는 함수로 특정 캐시 태그를 재검증(revalidate)해서, 데이터가 바뀌었을 때 최신 상태로 유지하게 만드는 거예요.\n\n```js\n\"use server\";\n\nimport { revalidateTag } from \"next/cache\";\n\nexport default async function submit() {\n  await addPost(); // 새로운 포스트를 추가하는 비동기 함수\n  revalidateTag(\"my-data\"); // 'my-data'라는 태그가 붙은 캐시를 재검증해서 최신으로 업데이트\n}\n```\n\n위 코드에서 addPost()가 끝나면, 'my-data'라는 태그를 가진 캐시는 재검증돼서 이전 데이터가 아닌 새 데이터를 가져오도록 만드는 역할이에요.\n\n---\n\n## 알아두면 좋은 팁\n\n| 내용            | 설명                                                                               |\n| --------------- | ---------------------------------------------------------------------------------- |\n| Idempotent Tags | 동일한 태그를 여러 번 적용해도 추가적인 효과가 없어요. 중복 적용해도 무방해요.     |\n| Multiple Tags   | 한 캐시 엔트리에 여러 태그를 붙일 수 있어요. 배열 형태로 태그들을 넘겨주면 됩니다. |\n\n예를 들어 이렇게 사용해요:\n\n```js\ncacheTag(\"tag-one\", \"tag-two\");\n```\n\n위와 같이 여러 태그를 한 번에 붙이면, 이 캐시 항목이 두 가지 태그에 묶여서 둘 중 하나라도 변경될 경우 재검증됩니다.\n\n---\n\n### 개인적으로 추가로 알려드릴 점!\n\n캐시 태그를 이렇게 사용하면 무조건 캐시 무효화(invalidation)를 하느니, 필요한 부분만 선별적으로 업데이트하는 '스마트 캐싱' 전략을 세우기 좋아요. 데이터가 자주 변하는 서비스에서는 서버 성능과 유저 경험을 둘 다 잡기 위해 꼭 익혀야 하는 기능입니다.\n\nNext.js 13+ 버전에서 제공하는 이 기능을 잘 활용하면, SSR(Server Side Rendering) 혹은 ISR(Incremental Static Regeneration) 환경에서도 원하는 타이밍에 효율적으로 데이터를 업데이트할 수 있어요. 번거로운 캐시 조작을 줄이고, 최신 데이터도 놓치지 않게 해주는 아주 쓸모 있는 기능이죠!\n\n필요하시면 addPost() 같은 함수 내부 구현도 같이 다뤄볼테니, 언제든 질문 주세요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 예제\n\n### 컴포넌트나 함수에 태그 달기\n\n캐시된 함수나 컴포넌트 안에서 `cacheTag`를 호출해서 캐시 데이터를 태그할 수 있어요. 이렇게 하면 캐시 관리가 좀 더 편리해지고, 특정 태그를 기준으로 캐시를 재검증하거나 삭제할 수 있답니다.\n\n```js\nimport { unstable_cacheTag as cacheTag } from \"next/cache\";\n\ninterface BookingsProps {\n  type: string;\n}\n\nexport async function Bookings({ type = \"haircut\" }: BookingsProps) {\n  \"use cache\";\n  cacheTag(\"bookings-data\");\n\n  async function getBookingsData() {\n    const data = await fetch(`/api/bookings?type=${encodeURIComponent(type)}`);\n    return data;\n  }\n\n  return; //...\n}\n```\n\n---\n\n여기서 중요한 포인트는 `'use cache'`라는 디렉티브를 함수 최상단에 써서 이 함수가 캐싱 기능을 사용할 거라고 알려준다는 점이에요. 그리고 `cacheTag('bookings-data')`를 호출해서 이 함수가 반환하는 데이터에 `bookings-data`라는 태그를 붙이는 거죠.\n\n이렇게 태그를 달아두면, 나중에 `bookings-data` 태그가 붙은 캐시들을 한꺼번에 무효화하거나 업데이트할 때 훨씬 편리해져요.\n\n또한 참고할 점은, 이 기능이 아직 불안정(`unstable`)한 API이므로, 앞으로 변경될 가능성이 있다는 점이에요. 그래도 Next.js 같은 최신 프레임워크에서 제공하는 기능을 미리 써보면서 경험해보는 것도 좋겠죠?\n\n추가로, 만약 다양한 타입의 예약 데이터를 관리해야 한다면 태그 이름을 `bookings-data:${type}` 같은 식으로 동적으로 생성하는 것도 좋은 방법이에요. 이렇게 하면 특정 타입만 골라서 캐시를 제어할 수 있거든요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 외부 데이터로부터 태그 만들기\n\n비동기 함수(async function)에서 반환된 데이터를 이용해서 캐시 항목에 태그를 붙일 수 있어요.\n\n```js\nimport { unstable_cacheTag as cacheTag } from \"next/cache\";\n\ninterface BookingsProps {\n  type: string;\n}\n\nexport async function Bookings({ type = \"haircut\" }: BookingsProps) {\n  async function getBookingsData() {\n    \"use cache\"; // 캐시 활용을 위한 지시어\n    const data = await fetch(`/api/bookings?type=${encodeURIComponent(type)}`);\n    cacheTag(\"bookings-data\", data.id); // 받은 데이터의 id를 태그값으로 지정\n    return data;\n  }\n  return; //...\n}\n```\n\n여기서 중요한 포인트는 `cacheTag`를 사용해 데이터를 태그함으로써 특정 조건에 따라 캐시를 더 정밀하게 관리할 수 있다는 거예요. 예를 들어, 예약 타입별로 캐시를 구분하거나 데이터 ID별로 캐시 무효화를 쉽게 할 수 있죠.\n\n그리고 `use cache`라는 키워드가 보이죠? 이건 Next.js가 이 함수 결과를 캐싱하도록 알려주는 역할을 합니다. 실제 프로젝트에서는 이렇게 재사용 가능한 데이터를 효율적으로 다룰 때 꼭 활용해보세요!\n\n### 태그된 캐시 무효화하기\n\n작성한 태그를 기반으로 캐시를 무효화해 특정 데이터가 변경되었을 때 최신 상태를 유지할 수 있어요.\n\n```js\nimport { unstable_invalidateCacheTag as invalidateCacheTag } from \"next/cache\";\n\nexport async function invalidateBookingCache(id: string) {\n  // 'bookings-data'라는 태그에 id 값으로 붙인 캐시를 무효화합니다.\n  invalidateCacheTag(\"bookings-data\", id);\n}\n```\n\n이렇게 태그 단위로 캐시를 무효화하면, 불필요한 전체 캐시 초기화 없이 원하는 부분만 갱신 가능해져서 효율적이에요. 만약 데이터 변경 이벤트가 발생하면 이 함수를 호출해 관련 캐시를 리프레시하는 방식으로 활용하면 됩니다.\n\n캐시 태그 활용법은 Next.js 13버전 이후의 캐시 전략에서 굉장히 강력한 기능 중 하나이니 꼭 익혀두세요! 개발하며 때때로 캐시 데이터가 꼬일 때 이 방법으로 깔끔하게 관리할 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n'revalidateTag'를 사용하면 필요한 시점에 특정 태그의 캐시를 무효화해서 최신 데이터를 반영할 수 있어요. 예를 들어, 아래 코드처럼 'bookings-data'라는 태그에 달려있는 캐시를 갱신해줄 수 있죠.\n\n```js\n\"use server\";\n\nimport { revalidateTag } from \"next/cache\";\n\nexport async function updateBookings() {\n  await updateBookingData();\n  revalidateTag(\"bookings-data\");\n}\n```\n\n간단히 말해, updateBookingData() 함수가 예약 데이터를 업데이트한 뒤에 revalidateTag('bookings-data')를 호출하면, Next.js가 그 태그에 연결된 캐시를 무효화해서 사용자들에게 최신 정보를 보여주게 됩니다.\n\n여기서 중요한 점은, 캐시 무효화를 태그 단위로 관리할 수 있다는 거예요. 덕분에 전체 페이지 캐시를 다 날리지 않고도, 특정 데이터 부분만 신속하게 업데이트할 수 있으니 효율적이죠!\n\n추가로, revalidateTag는 서버 컴포넌트나 API 라우트 등 서버 측 코드에서만 사용 가능하다는 점도 기억해 주세요. 클라이언트 측에서는 사용할 수 없고, 반드시 'use server' directive가 있어야 합니다.\n","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":9},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<h1>cacheTag</h1>\n<p>cacheTag 함수는 캐시된 데이터를 태그로 관리해서 필요한 순간에만 캐시를 지우거나 갱신할 수 있게 도와줘요. 태그를 캐시 항목에 붙여두면, 전체 캐시를 지우는 대신 특정 태그가 붙은 데이터만 골라서 재검증하거나 삭제할 수 있답니다. 이 기능 덕분에 캐시 관리가 훨씬 스마트해지고 효율적이죠!</p>\n<h2>사용 방법</h2>\n<p>cacheTag를 사용하려면, 먼저 프로젝트의 <code>next.config.js</code> 파일에서 <code>dynamicIO</code> 플래그를 활성화해야 해요. 이렇게요:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// next.config.js</span>\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n  <span class=\"hljs-attr\">experimental</span>: {\n    <span class=\"hljs-attr\">dynamicIO</span>: <span class=\"hljs-literal\">true</span>,\n  },\n};\n</code></pre>\n<blockquote>\n<p><code>dynamicIO</code> 옵션은 아직 실험적인 기능이라, 안정성이 필요한 프로젝트에서는 신중하게 적용하는 게 좋아요.</p>\n</blockquote>\n<p>이 설정을 한 다음, 원하는 캐시 데이터에 태그를 달아서 관리할 수 있습니다.</p>\n<hr>\n<h3>참고로 더!</h3>\n<ul>\n<li>태그 관리 덕분에 특정 부분만 업데이트해야 할 때, 서버 성능과 사용자 경험이 크게 개선됩니다.</li>\n<li>이 기능은 특히 데이터가 자주 바뀌면서도 전체를 다시 로드하는 건 비효율적인 서비스(예: 뉴스 피드, 실시간 데이터 보여주는 앱 등)에 유용해요.</li>\n<li><code>cacheTag</code>를 사용하면서 동시에 어떻게 캐시 무효화 전략을 세울지 고민해보면 프로젝트의 퍼포먼스 최적화에 큰 도움이 됩니다.</li>\n</ul>\n<p>필요하면 다음에 캐시 사용 예제에 대해서도 알려줄게요!</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>Next.js에서 새롭게 제공하는 캐시 태그(cacheTag) 기능을 재미있게 활용해볼까요? 이번에 소개할 코드는 캐시를 더 세밀하게 관리할 수 있게 도와주는 설정과 함수예요.</p>\n<h3>1. next.config.js 설정</h3>\n<p>먼저 <code>next.config.js</code> 파일에서 실험적 기능인 <code>dynamicIO</code>를 활성화해야 해요. 이 옵션을 켜면 Next.js가 새로운 캐시 태그 기능을 사용할 수 있도록 준비된답니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> type { <span class=\"hljs-title class_\">NextConfig</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"next\"</span>;\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">nextConfig</span>: <span class=\"hljs-title class_\">NextConfig</span> = {\n  <span class=\"hljs-attr\">experimental</span>: {\n    <span class=\"hljs-attr\">dynamicIO</span>: <span class=\"hljs-literal\">true</span>,\n  },\n};\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> nextConfig;\n</code></pre>\n<p>여기서 <code>dynamicIO</code>는 아직 완전히 안정화된 기능은 아니지만, 캐시 제어나 데이터 페칭에 좀 더 유연한 방식으로 접근할 수 있게 해줘요.</p>\n<hr>\n<h3>2. 캐시 태그 지정하기 - <code>cacheTag</code></h3>\n<p>이제 함수 안에서 <code>cacheTag</code> 함수를 써보죠! 이 함수는 하나의 문자열 태그, 혹은 문자열 배열로 캐시 태그를 지정할 수 있어요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { unstable_cacheTag <span class=\"hljs-keyword\">as</span> cacheTag } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"next/cache\"</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getData</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-string\">\"use cache\"</span>;\n  <span class=\"hljs-title function_\">cacheTag</span>(<span class=\"hljs-string\">\"my-data\"</span>);\n  <span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">\"/api/data\"</span>);\n  <span class=\"hljs-keyword\">return</span> data;\n}\n</code></pre>\n<ul>\n<li>먼저 함수 최상단 <code>'use cache'</code> 디렉티브를 호출해 캐시 기능을 활성화해줍니다.</li>\n<li><code>cacheTag('my-data')</code>로 해당 함수가 사용하는 캐시 태그를 지정하죠.</li>\n<li>이렇게 하면 <code>my-data</code>라는 태그를 기준으로 캐싱되고, 이 태그만 선택적으로 무효화할 수 있습니다.</li>\n</ul>\n<p>이게 뭐가 좋느냐면, 데이터를 전체 페이지가 아니라 세부 단위별로 새로고침할 수 있다는 점이에요. 예를 들어, 특정 API 데이터를 업데이트해야 할 때 전체 페이지를 빌드할 필요 없이 해당 데이터만 캐시를 지우고 재생성할 수 있게 되는 거죠.</p>\n<hr>\n<h3>3. 캐시 무효화 (Cache Purge) - <code>revalidateTag</code></h3>\n<p>캐시가 오래되었거나, 데이터를 리프레시하려면 태그 단위로 캐시를 무효화하는 게 중요한데요. Next.js는 <code>revalidateTag</code> API로 이걸 쉽게 지원합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { revalidateTag } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"next/cache\"</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">POST</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-comment\">// 예: API 라우트에서 데이터가 변경될 때 해당 캐시 태그를 무효화</span>\n  <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">doDataUpdate</span>();\n  <span class=\"hljs-title function_\">revalidateTag</span>(<span class=\"hljs-string\">\"my-data\"</span>);\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Response</span>(<span class=\"hljs-string\">'Cache cleared for \"my-data\" tag'</span>);\n}\n</code></pre>\n<ul>\n<li>위 예시처럼, 서버측 함수에서 데이터 수정 후 <code>revalidateTag('my-data')</code>를 호출하면 <code>'my-data'</code> 관련된 캐시가 모두 무효화됩니다.</li>\n<li>그러면 다음 요청 시점에 다시 최신 데이터를 받아서 캐쉬를 갱신하게 되죠.</li>\n</ul>\n<hr>\n<h2>요약</h2>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>기능</th><th>설명</th></tr></thead><tbody><tr><td><code>experimental.dynamicIO</code></td><td>Next.js에서 캐시 태그 사용을 위한 실험적 설정</td></tr><tr><td><code>cacheTag</code></td><td>함수 내에서 캐시 태그를 지정, 데이터 단위별 캐시 제어 가능</td></tr><tr><td><code>revalidateTag</code></td><td>특정 태그에 해당하는 캐시를 서버에서 강제로 무효화</td></tr></tbody></table>\n<hr>\n<h2>한마디</h2>\n<p>이번에 소개한 캐시 태그 기능은 특히 데이터가 자주 업데이트되는 상황에서 유용해요. API 응답이나 UI 컴포넌트의 일부를 효과적으로 갱신할 수 있으니, 무조건 페이지 전체를 다시 빌드하는 구조에서 벗어나고 싶다면 한 번 꼭 시도해보세요. 실험적이라 공식 문서와 버전이 바뀌는지는 꾸준히 체크하는 것도 잊지 마시고요!</p>\n<p>더 궁금한 점 있으면 언제든 댓글로 남겨주세요. 같이 공부해봐요! 😊</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>위 코드는 Next.js의 서버 컴포넌트에서 캐시를 제어할 때 사용하는 예제입니다. 여기서 핵심은 revalidateTag라는 함수로 특정 캐시 태그를 재검증(revalidate)해서, 데이터가 바뀌었을 때 최신 상태로 유지하게 만드는 거예요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-string\">\"use server\"</span>;\n\n<span class=\"hljs-keyword\">import</span> { revalidateTag } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"next/cache\"</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">submit</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">addPost</span>(); <span class=\"hljs-comment\">// 새로운 포스트를 추가하는 비동기 함수</span>\n  <span class=\"hljs-title function_\">revalidateTag</span>(<span class=\"hljs-string\">\"my-data\"</span>); <span class=\"hljs-comment\">// 'my-data'라는 태그가 붙은 캐시를 재검증해서 최신으로 업데이트</span>\n}\n</code></pre>\n<p>위 코드에서 addPost()가 끝나면, 'my-data'라는 태그를 가진 캐시는 재검증돼서 이전 데이터가 아닌 새 데이터를 가져오도록 만드는 역할이에요.</p>\n<hr>\n<h2>알아두면 좋은 팁</h2>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>내용</th><th>설명</th></tr></thead><tbody><tr><td>Idempotent Tags</td><td>동일한 태그를 여러 번 적용해도 추가적인 효과가 없어요. 중복 적용해도 무방해요.</td></tr><tr><td>Multiple Tags</td><td>한 캐시 엔트리에 여러 태그를 붙일 수 있어요. 배열 형태로 태그들을 넘겨주면 됩니다.</td></tr></tbody></table>\n<p>예를 들어 이렇게 사용해요:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">cacheTag</span>(<span class=\"hljs-string\">\"tag-one\"</span>, <span class=\"hljs-string\">\"tag-two\"</span>);\n</code></pre>\n<p>위와 같이 여러 태그를 한 번에 붙이면, 이 캐시 항목이 두 가지 태그에 묶여서 둘 중 하나라도 변경될 경우 재검증됩니다.</p>\n<hr>\n<h3>개인적으로 추가로 알려드릴 점!</h3>\n<p>캐시 태그를 이렇게 사용하면 무조건 캐시 무효화(invalidation)를 하느니, 필요한 부분만 선별적으로 업데이트하는 '스마트 캐싱' 전략을 세우기 좋아요. 데이터가 자주 변하는 서비스에서는 서버 성능과 유저 경험을 둘 다 잡기 위해 꼭 익혀야 하는 기능입니다.</p>\n<p>Next.js 13+ 버전에서 제공하는 이 기능을 잘 활용하면, SSR(Server Side Rendering) 혹은 ISR(Incremental Static Regeneration) 환경에서도 원하는 타이밍에 효율적으로 데이터를 업데이트할 수 있어요. 번거로운 캐시 조작을 줄이고, 최신 데이터도 놓치지 않게 해주는 아주 쓸모 있는 기능이죠!</p>\n<p>필요하시면 addPost() 같은 함수 내부 구현도 같이 다뤄볼테니, 언제든 질문 주세요!</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h2>예제</h2>\n<h3>컴포넌트나 함수에 태그 달기</h3>\n<p>캐시된 함수나 컴포넌트 안에서 <code>cacheTag</code>를 호출해서 캐시 데이터를 태그할 수 있어요. 이렇게 하면 캐시 관리가 좀 더 편리해지고, 특정 태그를 기준으로 캐시를 재검증하거나 삭제할 수 있답니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { unstable_cacheTag <span class=\"hljs-keyword\">as</span> cacheTag } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"next/cache\"</span>;\n\ninterface <span class=\"hljs-title class_\">BookingsProps</span> {\n  <span class=\"hljs-attr\">type</span>: string;\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Bookings</span>(<span class=\"hljs-params\">{ type = <span class=\"hljs-string\">\"haircut\"</span> }: BookingsProps</span>) {\n  <span class=\"hljs-string\">\"use cache\"</span>;\n  <span class=\"hljs-title function_\">cacheTag</span>(<span class=\"hljs-string\">\"bookings-data\"</span>);\n\n  <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getBookingsData</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">`/api/bookings?type=<span class=\"hljs-subst\">${<span class=\"hljs-built_in\">encodeURIComponent</span>(type)}</span>`</span>);\n    <span class=\"hljs-keyword\">return</span> data;\n  }\n\n  <span class=\"hljs-keyword\">return</span>; <span class=\"hljs-comment\">//...</span>\n}\n</code></pre>\n<hr>\n<p>여기서 중요한 포인트는 <code>'use cache'</code>라는 디렉티브를 함수 최상단에 써서 이 함수가 캐싱 기능을 사용할 거라고 알려준다는 점이에요. 그리고 <code>cacheTag('bookings-data')</code>를 호출해서 이 함수가 반환하는 데이터에 <code>bookings-data</code>라는 태그를 붙이는 거죠.</p>\n<p>이렇게 태그를 달아두면, 나중에 <code>bookings-data</code> 태그가 붙은 캐시들을 한꺼번에 무효화하거나 업데이트할 때 훨씬 편리해져요.</p>\n<p>또한 참고할 점은, 이 기능이 아직 불안정(<code>unstable</code>)한 API이므로, 앞으로 변경될 가능성이 있다는 점이에요. 그래도 Next.js 같은 최신 프레임워크에서 제공하는 기능을 미리 써보면서 경험해보는 것도 좋겠죠?</p>\n<p>추가로, 만약 다양한 타입의 예약 데이터를 관리해야 한다면 태그 이름을 <code>bookings-data:${type}</code> 같은 식으로 동적으로 생성하는 것도 좋은 방법이에요. 이렇게 하면 특정 타입만 골라서 캐시를 제어할 수 있거든요!</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h3>외부 데이터로부터 태그 만들기</h3>\n<p>비동기 함수(async function)에서 반환된 데이터를 이용해서 캐시 항목에 태그를 붙일 수 있어요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { unstable_cacheTag <span class=\"hljs-keyword\">as</span> cacheTag } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"next/cache\"</span>;\n\ninterface <span class=\"hljs-title class_\">BookingsProps</span> {\n  <span class=\"hljs-attr\">type</span>: string;\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Bookings</span>(<span class=\"hljs-params\">{ type = <span class=\"hljs-string\">\"haircut\"</span> }: BookingsProps</span>) {\n  <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getBookingsData</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-string\">\"use cache\"</span>; <span class=\"hljs-comment\">// 캐시 활용을 위한 지시어</span>\n    <span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">`/api/bookings?type=<span class=\"hljs-subst\">${<span class=\"hljs-built_in\">encodeURIComponent</span>(type)}</span>`</span>);\n    <span class=\"hljs-title function_\">cacheTag</span>(<span class=\"hljs-string\">\"bookings-data\"</span>, data.<span class=\"hljs-property\">id</span>); <span class=\"hljs-comment\">// 받은 데이터의 id를 태그값으로 지정</span>\n    <span class=\"hljs-keyword\">return</span> data;\n  }\n  <span class=\"hljs-keyword\">return</span>; <span class=\"hljs-comment\">//...</span>\n}\n</code></pre>\n<p>여기서 중요한 포인트는 <code>cacheTag</code>를 사용해 데이터를 태그함으로써 특정 조건에 따라 캐시를 더 정밀하게 관리할 수 있다는 거예요. 예를 들어, 예약 타입별로 캐시를 구분하거나 데이터 ID별로 캐시 무효화를 쉽게 할 수 있죠.</p>\n<p>그리고 <code>use cache</code>라는 키워드가 보이죠? 이건 Next.js가 이 함수 결과를 캐싱하도록 알려주는 역할을 합니다. 실제 프로젝트에서는 이렇게 재사용 가능한 데이터를 효율적으로 다룰 때 꼭 활용해보세요!</p>\n<h3>태그된 캐시 무효화하기</h3>\n<p>작성한 태그를 기반으로 캐시를 무효화해 특정 데이터가 변경되었을 때 최신 상태를 유지할 수 있어요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { unstable_invalidateCacheTag <span class=\"hljs-keyword\">as</span> invalidateCacheTag } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"next/cache\"</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">invalidateBookingCache</span>(<span class=\"hljs-params\">id: string</span>) {\n  <span class=\"hljs-comment\">// 'bookings-data'라는 태그에 id 값으로 붙인 캐시를 무효화합니다.</span>\n  <span class=\"hljs-title function_\">invalidateCacheTag</span>(<span class=\"hljs-string\">\"bookings-data\"</span>, id);\n}\n</code></pre>\n<p>이렇게 태그 단위로 캐시를 무효화하면, 불필요한 전체 캐시 초기화 없이 원하는 부분만 갱신 가능해져서 효율적이에요. 만약 데이터 변경 이벤트가 발생하면 이 함수를 호출해 관련 캐시를 리프레시하는 방식으로 활용하면 됩니다.</p>\n<p>캐시 태그 활용법은 Next.js 13버전 이후의 캐시 전략에서 굉장히 강력한 기능 중 하나이니 꼭 익혀두세요! 개발하며 때때로 캐시 데이터가 꼬일 때 이 방법으로 깔끔하게 관리할 수 있습니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>'revalidateTag'를 사용하면 필요한 시점에 특정 태그의 캐시를 무효화해서 최신 데이터를 반영할 수 있어요. 예를 들어, 아래 코드처럼 'bookings-data'라는 태그에 달려있는 캐시를 갱신해줄 수 있죠.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-string\">\"use server\"</span>;\n\n<span class=\"hljs-keyword\">import</span> { revalidateTag } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"next/cache\"</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">updateBookings</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">updateBookingData</span>();\n  <span class=\"hljs-title function_\">revalidateTag</span>(<span class=\"hljs-string\">\"bookings-data\"</span>);\n}\n</code></pre>\n<p>간단히 말해, updateBookingData() 함수가 예약 데이터를 업데이트한 뒤에 revalidateTag('bookings-data')를 호출하면, Next.js가 그 태그에 연결된 캐시를 무효화해서 사용자들에게 최신 정보를 보여주게 됩니다.</p>\n<p>여기서 중요한 점은, 캐시 무효화를 태그 단위로 관리할 수 있다는 거예요. 덕분에 전체 페이지 캐시를 다 날리지 않고도, 특정 데이터 부분만 신속하게 업데이트할 수 있으니 효율적이죠!</p>\n<p>추가로, revalidateTag는 서버 컴포넌트나 API 라우트 등 서버 측 코드에서만 사용 가능하다는 점도 기억해 주세요. 클라이언트 측에서는 사용할 수 없고, 반드시 'use server' directive가 있어야 합니다.</p>\n</body>\n</html>\n"},"__N_SSG":true}