{"pageProps":{"posts":[{"title":"파이썬과 트랜스포머로 생성형 AI 챗봇 만들기 방법","description":"","date":"2024-07-09 19:40","slug":"2024-07-09-CreatingaGenerativeAIChatbotwithPythonandTransformers","content":"\n요즘의 디지털 시대에, 챗봇은 간단한 자동응답 도구에서 복잡하고 맥락을 이해하는 대화를 수행할 수 있는 가상 보조로 진화했습니다. 이 글에서는 파이썬과 허깅페이스의 트랜스포머 라이브러리를 사용하여 생성 모델인 GPT-2와 같은 고급 모델을 활용해 AI 챗봇을 구축하는 방법을 살펴보겠습니다.\n\n# 생성식 AI 챗봇 소개\n\n생성식 AI 챗봇은 인공 지능의 중요한 발전을 나타내며, 기업이 고객 지원을 자동화하고 사용자-시스템 상호작용을 향상시키는 데 기여합니다. 미리 정의된 응답에 제한된 규칙 기반 챗봇과는 달리, 생성식 챗봇은 자연어를 이해하고 생성하는 더 현실적인 대화를 할 수 있습니다.\n\n# 사용된 도구 및 라이브러리\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 프로젝트에서는 다음 도구 및 라이브러리를 활용할 예정입니다:\n\n- Python: 다재다능하고 배우기 쉬운 프로그래밍 언어.\n- Transformers: 사전 학습된 언어 모델 구현을 제공하는 허깅페이스 라이브러리.\n- Flask: Python으로 웹 응용 프로그램을 구축하기 위한 가볍고 효율적인 웹 프레임워크.\n- PyTorch: 인공지능 모델을 훈련하고 평가하는 데 사용되는 머신러닝 라이브러리.\n\n# 단계 1: 환경 설정\n\n시작하기 전에 시스템에 Python과 pip이 설치되어 있는지 확인하세요. 그런 다음 터미널에서 다음 명령을 실행하여 필요한 라이브러리를 설치하세요:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![2024-07-09-CreatingaGenerativeAIChatbotwithPythonandTransformers_0.png](/TIL/assets/img/2024-07-09-CreatingaGenerativeAIChatbotwithPythonandTransformers_0.png)\n\n# Step 2: Loading GPT-2 Model and Tokenizer\n\nTo begin, import the required libraries and load the pretrained GPT-2 model and its corresponding tokenizer:\n\n![2024-07-09-CreatingaGenerativeAIChatbotwithPythonandTransformers_1.png](/TIL/assets/img/2024-07-09-CreatingaGenerativeAIChatbotwithPythonandTransformers_1.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 단계 3: 응답 함수 생성\n\n사용자 입력을 가져와 인코딩하고 GPT-2 모델을 사용하여 응답을 생성하는 함수를 정의하세요:\n\n![image](/TIL/assets/img/2024-07-09-CreatingaGenerativeAIChatbotwithPythonandTransformers_2.png)\n\n# 단계 4: Flask 어플리케이션 설정\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음으로 웹 요청을 처리하고 챗봇을 위한 직관적 인터페이스를 제공하기 위해 Flask 애플리케이션을 설정하세요:\n\n![image1](/TIL/assets/img/2024-07-09-CreatingaGenerativeAIChatbotwithPythonandTransformers_3.png)\n\n![image2](/TIL/assets/img/2024-07-09-CreatingaGenerativeAIChatbotwithPythonandTransformers_4.png)\n\n![image3](/TIL/assets/img/2024-07-09-CreatingaGenerativeAIChatbotwithPythonandTransformers_5.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![사진](/TIL/assets/img/2024-07-09-CreatingaGenerativeAIChatbotwithPythonandTransformers_6.png)\n\n# 단계 5: Flask 앱 실행 및 상호 작용\n\n챗봇 애플리케이션을 실행하려면:\n\n- 위의 Python 코드를 파일에 저장하세요. 예를 들어, chatbot_app.py로 저장합니다.\n- 터미널이나 명령 프롬프트를 엽니다.\n- chatbot_app.py 파일이 위치한 디렉토리로 이동합니다.\n- Flask 애플리케이션을 시작하려면 다음 명령을 실행하세요:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Image](/TIL/assets/img/2024-07-09-CreatingaGenerativeAIChatbotwithPythonandTransformers_7.png)\n\n- 어플리케이션이 시작되면 웹 브라우저를 열고 챗봇과 상호 작용하기 위해 http://127.0.0.1:5000/ 로 이동하세요.\n\n![Image](/TIL/assets/img/2024-07-09-CreatingaGenerativeAIChatbotwithPythonandTransformers_8.png)\n\n![Image](/TIL/assets/img/2024-07-09-CreatingaGenerativeAIChatbotwithPythonandTransformers_9.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결론\n\n생성형 AI 챗봇은 기업과 사용자가 상호 작용하는 방식을 혁신하고 있습니다. Hugging Face의 Transformers와 같은 고급 도구를 활용하면 자연스럽고 맥락 있는 대화를 이어나갈 수 있는 챗봇을 만들 수 있으며, 이는 사용자 경험을 크게 향상시킵니다.\n","ogImage":{"url":"/assets/img/2024-07-09-CreatingaGenerativeAIChatbotwithPythonandTransformers_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-CreatingaGenerativeAIChatbotwithPythonandTransformers_0.png","tag":["Tech"],"readingTime":5},{"title":"진정한 인공지능의 벽에 부딪힌 AGI의 발전 현황","description":"","date":"2024-07-09 19:38","slug":"2024-07-09-ProgresstowardstrueArtificialGeneralIntelligenceAGIhashitawall","content":"\n![image](/TIL/assets/img/2024-07-09-ProgresstowardstrueArtificialGeneralIntelligenceAGIhashitawall_0.png)\n\n인공 일반 지능(AGI)을 향한 탐구는 몇십 년 동안 연구 커뮤니티의 관심을 사로 잡아 왔습니다.\n\nAGI는 인간이 하는 것과 비슷하게 프로그래밍되지 않은 상태에서도 다양한 작업을 수행할 수 있는 AI 시스템의 능력을 나타냅니다. 이는 우리가 학습, 추론 및 새로운 상황에 적응할 수 있는 능력을 갖춘 시스템을 찾고 있다는 것을 의미합니다.\n\n그러나 분야에서 중요한 발전이 있었음에도 불구하고, 대부분의 AI 시스템은 아직도 좁은 작업과 영역에 제한되어 있어 AGI는 여전히 애매한 목표로 남아 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n`<table>`태그를 Markdown 형식으로 변경해 주세요.\n\n그 이유가 무엇인가요?\n\n# 인공지능이 잘하지 못하는 것\n\nAGI에 대한 주요 장애물 중 하나는 현대 인공지능 시스템이 추론보다는 기억에 의존하고 있다는 것입니다. 우리가 모두 아는 이 시스템들인 Language Large Models (LLMs)는 학습 데이터의 패턴을 암기하고 인접한 맥락에서 적용하는 데 능숙합니다.\n\n하지만 새로운 경우를 바탕으로한 새로운 추론을 생성하는 능력이 부족합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nLLM은 독창적이거나 혁신적인 상황에 기반한 새로운 추론을 생성할 수 없으며 기억에 의존한다는 제한이 있습니다.\n\n또 다른 문제는 AI 시스템이 학습 데이터를 넘어서 일반화할 수 없는 점입니다. 예를 들어, 체스를 하는 방법을 학습한 AI 시스템은 사람들보다 더 잘 체스를 둘 수 있지만, 체커 또는 바둑과 같은 다른 보드 게임에 해당 지식을 전이시키는 것은 불가능합니다.\n\n이러한 일반화 실패는 AGI를 달성하는 데 중요한 장애물이며, 시스템이 새로운 상황에 지식을 적용하는 능력을 제한합니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*_LbxAoOCs7Ed8ThxzsC_eQ.gif)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 새로운 패러다임과 새로운 기준\n\n2019년, Keras의 창시자 인 프랑수아 쇌레(François Chollet)는 2.5백만 명 이상의 개발자가 채택한 오픈 소스 딥 러닝 라이브러리인 Keras의 창시자이자 Google의 소프트웨어 엔지니어 및 AI 연구원으로서, 영향력 있는 논문 \"지능의 측정에 관하여\"을 발표했습니다. 이 논문에서 그는 알려지지 않은 작업에 대한 AI 기술 습득의 효율을 측정하기 위한 기준인 추상화 및 추론 코퍼스(ARC-AGI)를 소개했습니다.\n\n마침내, 모든 좋은 과학이 해야 할 것처럼, 우리는 정의로부터 시작해야 합니다. AGI에 대한 일반적인 합의는 \"경제적 가치가 있는 작업의 대부분을 자동화할 수 있는 시스템\"으로 정의된다는 것입니다. 이것이 유용한 목표로 간주될 수 있지만... 이것은 지능의 부정확한 측정입니다.\n\n보다 지능적이고 인간과 유사한 시스템을 위한 고의적인 진보를 이루기 위해, 우리는 적절한 피드백 신호를 따라야 합니다: 우리는 지능을 정의하고 평가해야 합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 기술, 암기 및 지능\n\n기술은 이전 지식과 경험에 크게 영향을 받습니다. 무제한의 사전 지식이나 무제한의 교육 데이터는 개발자들에게 시스템의 기술 수준을 \"구매\"할 수 있는 기회를 제공합니다. 이것은 시스템 자체의 일반화 능력을 가리게 합니다.\n\n현대 인공지능 (LLM)은 뛰어난 암기 엔진으로 입증되었습니다. 그들은 훈련 데이터에서 고차원의 패턴을 기억하고 해당 패턴을 인접한 문맥에 적용할 수 있습니다.\n\n이것은 그들의 겉보기 추론 능력이 작동하는 방식입니다. LLM은 실제로 추론하지 않습니다. 대신, 그들은 추론 패턴을 암기하고 해당 추론 패턴을 인접한 문맥에 적용합니다. 그러나 그들은 새로운 상황에 기반한 새로운 추론을 만들어 내지 못합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지능은 넓거나 일반적인 능력에 있습니다; 훈련 데이터 외에도 새로운 기술을 효율적으로 습득할 수 있는 시스템으로 AGI를 정의하는 방식을 조정해야 합니다. 아니, 더 나아가...\n\n![이미지](/TIL/assets/img/2024-07-09-ProgresstowardstrueArtificialGeneralIntelligenceAGIhashitawall_1.png)\n\n# 이러한 종류의 지능을 어떻게 측정할 수 있을까요?\n\n대부분의 AI 벤치마크는 기술을 측정합니다. 하지만 기술은 지능이 아니라는 것을 방금 보았죠?\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2019년 같은 연구에서 탄생한 **인공 일반 지능(AGI)**을 위한 추상화 및 추론 말뭉치 (ARC-AGI)는 AGI의 유일한 공식 벤치마크로 여겨집니다.\n\n**추상화 및 추론 말뭉치(ARC)**는 AI 시스템의 작업 범위에 걸쳐 습득 능률을 테스트하도록 특별히 설계된 벤치마크입니다.\n\n![이미지](/TIL/assets/img/2024-07-09-ProgresstowardstrueArtificialGeneralIntelligenceAGIhashitawall_2.png)\n\n이는 추론과 추상화가 필요한 이미지 작업들을 포함한 과제 모음처럼 보입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기에는 명확한 의도가 있습니다. 즉, AI 시스템이 예시로부터 학습하고 그 지식을 새로운, 보지 못한 문제를 해결하는 데 적용할 수 있는 능력을 검증하는 것입니다. 이는 인간과 유사한 지능의 중요한 측면으로, 종종 \"유동적 지능\"이라고 합니다.\n\nARC 벤치마크는 중요한 이유가 있습니다.\n\n- 이는 이러한 추상적 추론을 필요로 하는 작업에 어려움을 겪는 현재의 기계 학습 방법에 도전합니다.\n- 이것은 연구자들이 인간 수준의 지능을 달성하기에 더 가까운 AI 시스템을 개발하는 데 도움이 됩니다.\n\n![이미지](/TIL/assets/img/2024-07-09-ProgresstowardstrueArtificialGeneralIntelligenceAGIhashitawall_3.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 다분야 접근\n\n인공 일반 지능(AGI)으로 나아가는 진전이 멈춰있습니다. 엄청나게 방대한 양의 데이터로 훈련된 LLM은 그럼에도 불구하고, 훈련받지 않은 간단한 문제에 적응하거나 새로운 발명을 할 수 없는 상황입니다.\n\nChollet이 만든 2019년 Abstraction and Reasoning Corpus for Artificial General Intelligence (ARC-AGI)는 AGI의 유일한 공식적인 벤치마크입니다.\n\n최근 NYU 교수이자 Meta의 최고 AI 과학자인 야얀 르쿤은 AGI 분야에서 진전하려면 LLM에 집중해서는 안된다고 공개적으로 언급했습니다...\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/TIL/assets/img/2024-07-09-ProgresstowardstrueArtificialGeneralIntelligenceAGIhashitawall_4.png)\n\n저는 이 도발을 좋아하고, 모든 AI 연구자가 이 도전에 대해 잘 알고 있다고 믿습니다. 대학 연구자들이 이 분야에서 몇 발자국 앞서 나가야 한다고 생각합니다. 학계는 보통 문제에 대해 다학제적 접근에 숙달되어 있지만, 그들은 자금과 컴퓨팅 파워 등 자원이 부족합니다.\n\n그러나 현재 AI 연구의 추세는 소스코드를 공개하지 않는 연구 방향으로 이동하고 있어서 아이디어와 지식의 공유를 제한하고 있습니다. 이 추세는 \"스케일만 있으면 충분하다\"는 믿음과 경쟁 우위를 보호하려는 욕심에서 나온 것이죠. 이 방식은 혁신을 억불하며 AGI로의 진전속도를 제한합니다.\n\n언제나 예외는 있습니다...\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n오픈 소스 연구는 협력과 지식 공유를 촉진하여 AGI로의 진전 속도를 가속화합니다. 연구를 공개로 접근 가능하게 함으로써 전 세계의 연구자들이 더 지능적인 AI 시스템의 개발에 기여할 수 있으며, 다양한 시각에서 새로운 아이디어와 혁신이 탄생할 수 있습니다.\n\nAI 연구에서의 투명성 부족과 협력은 AGI가 임박했다는 오도된 인식에 기여하고 있으며, 이는 AI 규제 환경에 영향을 미치고 있습니다. 규제 당국은 AGI가 임박했다는 잘못된 가정 하에 길잡이 AI 연구에 대한 장애물을 고려하고 있습니다.\n\n오픈 소스 연구는 더 지능적인 AI 시스템의 개발을 이끌어주고 일반 지능의 더 정확한 측정 지표를 제공할 수 있습니다.\n\nARC Challenge는 대규모 경쟁을 진행하는 역사가 있으며, 2020년 Kaggle에서 시작된 첫 번째 ARC-AGI 대회를 시작으로 2022년과 2023년에는 ARCathon이 열렸으며, 가장 최근에는 상금 총액이 1.1백만달러가 넘는 ARC Prize 2024가 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![2024-07-09-ProgresstowardstrueArtificialGeneralIntelligenceAGIhashitawall_5.png](/TIL/assets/img/2024-07-09-ProgresstowardstrueArtificialGeneralIntelligenceAGIhashitawall_5.png)\n\n# 결론…\n\nAGI를 위한 탐험은 복잡하고 도전적인 목표이지만 불가능한 것은 아닙니다.\n\n현대 AI의 제한을 극복하고 AGI를 준비하기 위해, 우리는 오픈소스 연구의 적극적 지지자가 되어야 합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 그보다 중요한 것은 우리가 어떤 지적인 것이란 것에 대한 오픈 토론의 일부가 되어야 한다는 것입니다. 다양한 분야의 시각에서 바라봤을 때 어떤 지능인지에 대한 토론을 펼쳐야 합니다.\n\n그렇게 함으로써 누구라도 프로그래밍 전문가가 아니더라도 더 지적인 AI 시스템의 개발에 기여할 수 있게 되어 AGI로의 발전속도를 높일 수 있습니다.\n\n만약 이 이야기가 가치있었다면 조금이라도 지원을 보여주고 싶다면 다음과 같은 방법을 사용할 수 있습니다:\n\n- 이 이야기에 대해 많이 박수를 치기\n- 기억하기에 더 중요한 부분을 강조하기 (나중에 그것들을 찾는 데 더 편리하고 나에게는 더 나은 기사를 쓸 수 있습니다)\n- '자체 AI 구축하기' 시작하는 방법 배우기, 무료 eBook 다운로드하기\n- 저를 Medium에서 팔로우하기\n- 내 최신 기사 읽기 https://medium.com/@fabio.matricardi\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n자료 및 참고 자료:\n\n![Generative AI](/TIL/assets/img/2024-07-09-ProgresstowardstrueArtificialGeneralIntelligenceAGIhashitawall_6.png)\n\n이 이야기는 Generative AI에서 게시되었습니다. LinkedIn에서 저희와 연락을 유지하고 최신 AI 이야기에 대해 최신 정보를 얻으려면 Zeniteq를 팔로우하세요.\n\n저희의 뉴스레터를 구독하여 generative AI의 최신 뉴스와 업데이트를 받아보세요. 함께 AI의 미래를 함께 만들어가요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Image](/TIL/assets/img/2024-07-09-ProgresstowardstrueArtificialGeneralIntelligenceAGIhashitawall_7.png)\n","ogImage":{"url":"/assets/img/2024-07-09-ProgresstowardstrueArtificialGeneralIntelligenceAGIhashitawall_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-ProgresstowardstrueArtificialGeneralIntelligenceAGIhashitawall_0.png","tag":["Tech"],"readingTime":10},{"title":"여러 기간의 시계열 확률 예측을 위한 XGB, LightGBM, CatBoost 모델 비교 분석","description":"","date":"2024-07-09 19:34","slug":"2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting","content":"\n![Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting](/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_0.png)\n\nSample eBook chapters (free): [https://github.com/dataman-git/modern-time-series/blob/main/20240522beauty_TOC.pdf](https://github.com/dataman-git/modern-time-series/blob/main/20240522beauty_TOC.pdf)\n\neBook on Teachable.com: $22.50 [https://drdataman.teachable.com/p/home](https://drdataman.teachable.com/p/home)\n\nThe print edition on Amazon.com: $65 [https://a.co/d/25FVsMx](https://a.co/d/25FVsMx)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 텍스트를 친근하게 번역하면 아래와 같습니다.\n\n챕터 제목은 \"확률 예측\", \"다기간\", \"트리 기반\" 세 가지 중요한 개념을 다룹니다. 첫 번째로 \"확률 예측\"이 있습니다. 많은 실세계 응용 프로그램에서는 자원 계획이나 이상 징후 감지를 위해 예측 구간을 요청하며, 이는 1장에서 언급한 것과 같습니다. 이 책의 Part 2에서 언급한 네 가지 해결책 중 하나는 분위수 회귀입니다. 분위 예측은 예측 값을 매우 가능성이 높은 50 번째 백분위 값이거나 상위 90 번째 백분위 값과 같이 매우 낮은 가능성을 보여줍니다 (A) 그림에서 확인할 수 있습니다.\n\n<img src=\"/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_1.png\" />\n\n제목에서 두 번째 개념은 다기간 예측입니다. 우리는 일일 예측이 아닌 여러 기간을 위한 예측이 필요한 경우가 많습니다. 한 주간 휴가를 계획할 때, 한 날이 아닌 5일간의 날씨 예보가 필요합니다. 그러나 선형 회귀 또는 트리 기반 알고리즘은 일반적으로 점 추정만 제공합니다. 이러한 경우 어떻게 예측 프로세스를 설계하여 다기간을 제공할 수 있을까요? 직관적으로, 다음 기간을 예측하면 동일한 모델의 입력으로 사용하여 다다음 기간을 예측할 수도 있지 않을까요? 이 해결책은 인기가 있으며 (B) 그림에서 보이는 것과 같이 재귀적 예측 전략이라고 합니다. 재귀적 예측 전략은 모델의 예측을 후속 예측의 입력으로 사용합니다. 전략은 모델이 1 단계 앞으로 예측하기 위해 yt에서 yt-k까지의 과거 값을 사용합니다. 그런 다음 yt+1을 통합하고 다른 입력을 업데이트하여 yt+2를 예측합니다. 이 프로세스를 반복하여 모든 후속 시간 단계를 예측합니다. Darts 라이브러리에서도 이 전략을 할당할 수 있습니다.\n\n<img src=\"/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_2.png\" />\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n새로운 시각으로 생각해보는 건 어때요? n 기간을 예측하는 것이 목표인 경우, 왜 n 개의 모델을 따로 구축하지 않을까요? 각 모델은 각각의 다음 n 기간을 예측할 것입니다. 이는 직접 예측 전략이라고 불립니다. Darts 라이브러리의 기본 전략이며, 라이브러리에 포함된 모든 모델에 대해 적용됩니다.\n\n![이미지](/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_3.png)\n\n마지막으로, 장 제목에 있는 \"tree-based\"에 대해 논의해보겠습니다. Tree-based 알고리즘들은 지도 학습 알고리즘입니다. 샘플을 행으로, 피처를 열로 갖는 데이터 프레임이 필요합니다. 단변량 시계열 데이터를 데이터 프레임으로 어떻게 변환할까요? 기본 아이디어는 단변량 시계열 데이터에서 샘플을 생성하는 것입니다. 이렇게 함으로써, 모델링을 위해 단변량 시계열 데이터를 데이터 프레임으로 재구성하고, 원하는 경우 단변량 시계열 데이터에서 피처를 생성할 수도 있습니다.\n\n이번 장에서는 세 가지 tree-based 모델인 XGBoost (2016), LightGBM (2017), CatBoost (2018)에 대해 세 부분으로 소개하고, 각 알고리즘에 대해 간단히 설명할 것입니다. 세 모델 간의 차이점에 대해 궁금하다면, Figure (C)에 각 세 그래디언트 부스팅 기반 알고리즘의 특징을 강조한 표를 만들었습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_4.png)\n\n이번 장에서는 Darts 라이브러리를 사용할 것입니다. 시계열 모델링은 많은 기능과 데이터를 저장해야 하므로 Darts 라이브러리는 자체 데이터 형식을 갖추고 있습니다. 시간 순서에 풍부한 정보를 담을 수 있는 다양한 데이터 형식의 장점을 설명하기 위해 본 책은 '10장: 시계열 데이터 형식 쉽게 만들기'를 별도로 마련했습니다. 마지막으로, 이 장은 '11장: 다기간 확률 예측을 위한 자기회귀 선형 회귀'와 함께 읽을 수 있습니다. 두 장은 프로젝트에 적합한 모델을 선택하기 위해 선형 회귀 및 트리 기반 모델을 구축하는 데 도움이 됩니다.\n\n이 장의 구조는 다음과 같습니다:\n\n- 필요한 소프트웨어 요구 사항\n- 판다스 데이터를 Darts 데이터 형식으로 변환하는 방법\n- XGB\n- LightGBM\n- CatBoost\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파이썬 노트북은 이 Github 링크를 통해 다운로드할 수 있어요.\n\n소프트웨어 요구 사항\n\n기본 Darts 패키지는 Prophet, CatBoost, 그리고 LightGBM 종속성을 설치하지 않습니다. 0.25.0 버전을 기준으로 해서요. 직접 Prophet, CatBoost, 그리고 LightGBM 패키지를 설치해야 해요.\n\n- CatBoostModel: CatBoost 설치 가이드를 사용하여 catboost 패키지(버전 1.0.6 이상)를 설치합니다.\n- LightGBMModel: LightGBM 설치 가이드를 사용하여 lightgbm 패키지(버전 3.2.0 이상)를 설치합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n!pip install pandas numpy matplotlib darts lightgbm catboost\n```\n\n다음으로, 동일한 Walmart 매장 판매 데이터를 로드할 것입니다.\n\n데이터\n\n저는 Kaggle.com에 있는 Walmart 데이터셋을 사용할 것입니다. 이 데이터셋은 2010년 2월 5일부터 2012년 11월 1일까지의 주간 매장 매출 정보를 포함하고 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Date - 판매 주차\n- Store - 상점 번호\n- 주간 매출 - 상점의 매출\n- 휴일 플래그 - 주가 특별 휴일 주인지 여부 1 - 휴일 주 0 - 비 휴일 주\n- 온도 - 판매일 온도\n- 연료 가격 - 지역의 연료 비용\n\n소매 판매에 영향을 미칠 수있는 두 가지 거시경제 지표 : 소비자 물가지수와 실업률. 데이터 세트는 Pandas 데이터 프레임으로로드됩니다.\n\n```js\n%matplotlib inline\nimport pandas as pd\nimport numpy as np\nfrom matplotlib import pyplot as plt\n\n# Google Colab\nfrom google.colab import drive\ndrive.mount('/content/gdrive')\npath = '/content/gdrive/My Drive/data/time_series'\n# https://www.kaggle.com/datasets/yasserh/walmart-dataset\n\n# 데이터 로드\ndata = pd.read_csv(path + '/walmart.csv', delimiter=\",\")\ndata['ds'] = pd.to_datetime(data['Date'], format='%d-%m-%Y')\ndata.index = data['ds']\ndata = data.drop('Date', axis=1)\ndata.head()\n```\n\n<img src=\"/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_5.png\" />\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n제 10 장에서 쉽게 만들어진 Darts의 시계열 데이터 형식에 대해 배웠어요. Darts의 주요 데이터 클래스는 \"TimeSeries\" 클래스입니다. Darts는 값들을 다음과 같은 배열 모양으로 저장해요 (시간, 차원, 샘플):\n\n- 시간: 위 예시에서처럼 143 주와 같은 시간 인덱스\n- 차원: 다변량 시계열의 \"열\"\n- 샘플: 기간에 대한 값들. 10 번째, 50 번째 백분위수와 90 번째 백분위수에 대한 그림 (A)에서처럼 확률론적 예측이라면 3개의 샘플이 있을 거예요.\n\n저희는 월마트 매장 판매량을 불러오기 위해 .from_group_dataframe() 함수를 사용할 거예요. 그룹 ID는 \"Store\"예요. 따라서 group_cols 매개변수는 \"Store\"가 될 거예요. 시간 인덱스는 \"ds\" 열이에요.\n\n```js\nfrom darts import TimeSeries\ndarts_group_df = TimeSeries.from_group_dataframe(data, group_cols='Store', time_col='ds')\nprint(\"그룹/매장의 수는:\", len(darts_group_df))\nprint(\"시간 기간의 수는: \", len(darts_group_df[0]))\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 그룹/상점 수: 45\n- 기간 수: 143\n\n다음과 같이 컬럼을 나열할 수 있습니다. components 함수를 사용해봅시다:\n\n```js\ndarts_group_df[0].components;\n```\n\nIndex(['Weekly_Sales', 'Holiday_Flag', 'Temperature', 'Fuel_Price', 'CPI', 'Unemployment'], dtype='object', name='component')\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nStore 1 매출 모델을 구축하기 위해 Store 1 데이터만 사용할 겁니다. \"darts_group_df[0]\"에 해당합니다. 이를 훈련 데이터와 테스트 데이터로 나눌 겁니다.\n\n```js\nstore1 = darts_group_df[0]\ntrain = store1[:130]\ntest = store1[130:]\nlen(train), len(test) # (130, 13)\n```\n\n우리의 목표 시리즈는 \"Weekly_Sales\"입니다. 다른 공선변수를 포함할 수도 있습니다. 시계열에서는 과거 공선변수와 미래 공선변수 두 종류가 있습니다. Darts 라이브러리는 동일한 용어를 사용합니다. 과거 공선변수는 연구 현재 시간까지의 변수입니다. 미래 공선변수는 미래에 관측 가능한 변수입니다. 미래 값을 어떻게 알 수 있는지 궁금할 수도 있습니다. 첫 번째 이유는 미래 휴일과 같이 결정론적 값이기 때문입니다. 두 번째 이유는 날씨 예측과 같은 다른 소스에서 예측된 값이기 때문입니다. 우리의 경우 \"Fuel_price\"와 \"CPI\"를 과거 공선변수로, \"Holiday_flag\"를 미래 공선변수로 포함할 것입니다. 훈련 데이터에서의 목표와 과거 공선변수는 130개의 데이터 포인트가 있습니다. 하지만 미래 공선변수는 실제로 미래까지 확장되어 143개의 데이터 포인트를 갖습니다.\n\n```js\ntarget = train['Weekly_Sales']\npast_cov = train[['Fuel_Price','CPI']]\nfuture_cov = store1['Holiday_Flag'][:143]\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우니바리에이트 데이터부터 시작해보겠습니다.\n\nXGB\n\nXGBoost (Extreme Gradient Boosting)은 분류 및 회귀와 같은 지도 학습 작업에 널리 사용되며 효율성, 확장성 및 정확도로 알려져 있습니다. 가장 주목할 만한 기능은 오버피팅을 방지하기 위해 L1 및 L2 규제 기술이 포함되어 있다는 점입니다. 규제 패널티는 트리의 가중치, 리프 노드 값, 특성 중요도 점수에 적용되어 일반화 성능을 향상시키는 데 도움을 줍니다. 또 다른 기능으로는 병렬 및 분산 컴퓨팅을 지원하며 멀티코어 CPU 및 Apache Spark 및 Dask와 같은 분산 컴퓨팅 프레임워크에서 효율적인 학습이 가능합니다. 이 확장성은 대규모 데이터 처리에 적합하게 만듭니다. 그 외에도 이전 모델이 실수한 오류를 수정하기 위해 각 트리가 순차적으로 훈련되는 경사 부스팅 프레임워크를 계승했습니다. 전체적인 목표는 특정 손실 함수를 최소화하는 것입니다.\n\n다음 코드는 Darts의 표준 모델링 구문입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nfrom darts.models import XGBModel\nn = 12\nchunk_length = n\nmodel = XGBModel(\n    lags=12,\n    lags_past_covariates=12,\n    lags_future_covariates=[0,1,2,3,4,5],\n    output_chunk_length=12,\n    Multi_models = True # optional\n    verbose=-1\n)\nmodel.fit(target, past_covariates=past_cov, future_covariates=future_cov)\npred = model.predict(n)\npred\n```\n\nfit() 함수의 \"target\"은 모델링을 위한 대상 시리즈입니다. 모델은 yt, yt-1, yt-2, ..., yt-12까지의 지연된 값들에 대한 \"lags\"를 필요로 합니다. 또한 다른 공변량을 지정할 수도 있습니다. 시계열 모델링에서 과거 공변량과 미래 공변량이라는 두 가지 넓은 유형의 공변량이 있습니다. Darts는 이 규칙을 따릅니다. lags_past_covariates는 xt, xt-1, ..., xt-12와 같이 지연된 과거 공변량을 나타냅니다. 약간 혼동스러운 lags_future_covariates 이름은 미래 공변량을 의미합니다. \"미래 공변량\"은 미래 시간 단계에서의 이러한 공변량의 값들을 의미하며, \"지연된\" 값들은 이전 시간 단계에서의 미래 공변량을 의미합니다. 이는 미래 t + n 단계에 대해 모델이 t부터 t + (n-1)까지의 공변량의 값을 고려한다는 것을 의미합니다.\n\nmulti_models 매개변수가 True로 설정된 것에 주목해주세요. 이는 모델에게 다중 기간 예측을 위한 직접 예측 전략 또는 재귀적 예측 전략을 사용할지 알려줍니다. 기본값은 True이며, 이는 직접 예측 전략을 사용한다는 것을 의미합니다.\n\n입력 청크 길이와 출력 청크 길이에 관한 한 가지 추가적인 매개변수가 있습니다. 이는 단변량 시리즈에서 샘플을 생성하는 것과 관련이 있습니다. 그림 (F)는 y0에서 y15까지의 시리즈에서 생성된 샘플을 보여줍니다. 각 샘플에는 입력 청크와 출력 청크가 포함되어 있습니다. 입력 청크 길이가 5이고 출력 청크 길이가 2인 것을 가정해보세요. 첫 번째 샘플은 입력 청크로 y0 - y4를, 출력 청크로 y5, y6를 가지고 있습니다. 창이 시리즈를 따라 이동하여 샘플을 만들며, 이를 시리즈의 끝까지 반복합니다. 출력 청크 길이는 예측할 수 있는 가장 긴 길이를 정의합니다. 이를 12로 지정했습니다. 12 이상을 예측하려고 하면 오류 메시지가 출력됩니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Dart data array](/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_6.png)\n\nThe outputs are stored in the Dart data array:\n\n![Dart data array](/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_7.png)\n\nWe will plot the actual and the predicted values. We make this in a function for repeating use.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\ndef plotit():\n  import matplotlib.pyplot as plt\n  target.plot(label='train')\n  pred.plot(label='prediction')\n  test['Weekly_Sales'][:n].plot(label='actual')\n\n  from darts.metrics.metrics import mae, mape\n  print(\"Mean Absolute Error:\", mae(test['Weekly_Sales'][:n], pred))\n  print(\"Mean Absolute Percentage Error\", mape(test['Weekly_Sales'][:n], pred))\n\nplotit()\n```\n\nMAPE 값은 10.55% 입니다.\n\n![이미지](/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_8.png)\n\n이제 분위수 예측을 추가해보겠습니다. 모델에게 5개의 분위수를 생성해 달라고 요청하겠습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nfrom darts.models import XGBModel\nn = 12\nchunk_length = n\nmodel = XGBModel(\n    lags=12,\n    lags_past_covariates=12,\n    lags_future_covariates=[0,1,2,3,4,5,6,7,8,9,10,11,12],\n    output_chunk_length=chunk_length,\n    likelihood = 'quantile', # 'quantile' 또는 'poisson'으로 설정 가능합니다.\n    # 'quantile'로 설정하면 sklearn.linear_model.QuantileRegressor가 사용됩니다.\n    # 'poisson'으로 설정하면 sklearn.linear_model.PoissonRegressor가 사용됩니다.\n    quantiles=[0.01, 0.05, 0.50, 0.95, 0.99]\n)\nmodel.fit(target, past_covariates=past_cov, future_covariates=future_cov)\npred = model.predict(n, num_samples=5)\npred\n```\n\n각 예측에는 5개의 샘플이 있습니다. 이는 5개의 분위 수치 값을 생성했기 때문입니다.\n\n![](/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_9.png)\n\n실제 값과 분위 예측을 시각화할 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ndef plotQuantile():\n    import matplotlib.pyplot as plt\n    target.plot(label = 'train')\n    pred.plot(label = 'prediction')\n    test['Weekly_Sales'][:n].plot(label = 'actual')\n\nplotQuantile()\n```\n\n양자 예측은 다음과 같습니다:\n\n![그림](/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_10.png)\n\n모델을 구축하고 예측을 제공하는 것이 매우 쉽다는 것을 발견할 수 있을 것 입니다. 계속해서 LightGBM 모델을 구축해 봅시다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nLightGBM\n\n\"제 12장: Tree-based Time Series Models의 Feature Engineering\"에서 lightGBM 모델을 구축한 적이 있지 않았나요? 정말이죠! 다른 점은 여기서는 Darts 라이브러리를 사용하여 lightGBM 모델을 구축할 것이라는 점입니다. 이전 장에서의 데이터 형식은 Pandas 데이터 프레임이었지만, 여기서는 Darts 데이터 object입니다. 그럼에도 불구하고 LightGBM이 무엇인지 설명해보겠습니다.\n\nLightGBM (Light Gradient Boosting Machine)은 gradient-boosting 결정 트리 모델의 효율적이고 확장 가능한 학습을 위해 설계되었습니다. LightGBM은 빠른 속도, 메모리 효율성, 정확성으로 인해 인기를 얻었습니다. 그 중요한 특징은 다른 gradient-boosting 구현에서 사용되는 전통적인 수준별 전략이 아니라 잎별 성장 전략을 채택한다는 것입니다. 이 전략은 손실을 가장 효과적으로 최소화할 잎 노드를 선택하여 더 빠른 학습 시간을 제공합니다. 그 외에도 그래디언트 부스팅 알고리즘을 여전히 구현합니다.\n\n```js\nfrom darts.models import LightGBMModel\nn = 12\nmodel = LightGBMModel(\n    lags=12,\n    lags_past_covariates=12,\n    lags_future_covariates=[0,1,2,3,4,5],\n    output_chunk_length=12,\n    verbose=-1\n)\nmodel.fit(target, past_covariates=past_cov, future_covariates=future_cov)\npred = model.predict(n)\npred.values()\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 코드는 XGB와 유사하여 더 이상 강조하지 않겠습니다. 그래프를 그려 성능 메트릭을 살펴봅시다:\n\n```js\nplotit();\n```\n\nMAPE는 5.09%입니다.\n\n![이미지](/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_11.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 분위 예측을 포함해 봅시다.\n\n```js\nn = 12\nchunk_length = n\nmodel = LightGBMModel(\n    lags=12,\n    lags_past_covariates=12,\n    lags_future_covariates=[0,1,2,3,4,5,6,7,8,9,10,11,12],\n    output_chunk_length=chunk_length,\n    likelihood = 'quantile', # quantile 또는 poisson 으로 설정할 수 있습니다.\n    # quantile로 설정하면 sklearn.linear_model.QuantileRegressor가 사용됩니다.\n    # poisson으로 설정하면 sklearn.linear_model.PoissonRegressor가 사용됩니다.\n    quantiles=[0.01, 0.05, 0.50, 0.95, 0.99]\n)\nmodel.fit(target, past_covariates=past_cov, future_covariates=future_cov)\npred = model.predict(n, num_samples=5)\npred\n```\n\n분위 예측을 그래프로 확인해볼 수 있습니다.\n\n```js\nplotQuantile();\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n양자수치 예측값은:\n\n![image](/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_12.png)\n\n좋아요. 이미 두 개의 모델이 구축되었습니다. 이제 CatBoost 모델을 구축해봅시다.\n\nCatBoost\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nCatBoost은 \"Category Boosting\"의 약자입니다. 범주형 기능을 효율적으로 처리할 수 있도록 특별히 설계되었으므로 다양한 분류 및 회귀 작업에 적합합니다. 이는 원-핫 인코딩과 같은 전처리가 필요 없이 범주형 기능을 직접 처리할 수 있습니다. CatBoost는 카테고리별 통계 속성에 기초하여 최적 분할점을 찾아 효율적으로 범주형 변수를 처리하는 Ordered Boosting이라는 새로운 알고리즘을 사용합니다. 이외에도 결정 트리 앙상블을 구축하기 위해 그래디언트 부스팅의 구현을 상속받습니다. 각 트리는 이전 모델의 오류를 최소화하도록 학습됩니다. 최적 매개변수를 찾기 위해 그래디언트 강하 최적화 알고리즘을 사용합니다.\n\n```js\nfrom darts.models import CatBoostModel\nn = 12\nchunk_length = n\nmodel = CatBoostModel(\n    lags=12,\n    lags_past_covariates=12,\n    lags_future_covariates=[0,1,2,3,4,5],\n    output_chunk_length=12,\n    verbose=-1\n)\nmodel.fit(target, past_covariates=past_cov, future_covariates=future_cov)\npred = model.predict(n)\npred\n```\n\n위 코드에 CatBoostModel을 삽입하여 내용을 그대로 유지하시면 됩니다.\n\n결과를 그래프로 출력해보겠습니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nplotit();\n```\n\nMAPE는 5.96% 입니다.\n\n![이미지](/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_13.png)\n\n모델에 분위 예측을 포함해 봅시다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nn = 12\nchunk_length = n\nmodel = CatBoostModel(\n    lags=12,\n    lags_past_covariates=12,\n    lags_future_covariates=[0,1,2,3,4,5,6,7,8,9,10,11,12],\n    output_chunk_length=chunk_length,\n    likelihood = 'quantile', # 'quantile' 또는 'poisson'으로 설정할 수 있습니다.\n    # 'quantile'로 설정하면 sklearn.linear_model.QuantileRegressor가 사용됩니다.\n    # 'poisson'으로 설정하면 sklearn.linear_model.PoissonRegressor가 사용됩니다.\n    quantiles=[0.01, 0.05, 0.50, 0.95,0.99]\n)\nmodel.fit(target, past_covariates=past_cov, future_covariates=future_cov)\npred = model.predict(n, num_samples=5)\npred\n```\n\n양자화 예측값을 그릴 수 있습니다.\n\n```js\nplotQuantile();\n```\n\n이 차트는 다음과 같습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Tree-based Models](/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_14.png)\n\n결론\n\n이 장에서는 Darts 라이브러리를 사용하여 세 가지 인기있는 트리 기반 시계열 모델을 구축했습니다. 우리는 다기간 예측 및 예측 불확실성의 사용 사례에 중점을 두었습니다. 다음에 시계열 모델을 구축하여 다기간 예측 및 예측 불확실성을 제공해야 할 때, 세 가지 트리 기반 모델과 다기간 확률적 예측을 위한 자동 회귀 선형 회귀 모델을 함께 생성하는 것을 권장합니다. 우승 모델을 찾기 위해 11 장에서 선형 회귀 모델과 결합하여 사용할 수 있습니다.\n\n이 장은 트리 기반 시계열 모델에 대한 현대적 기법 시리즈를 마무리합니다. 다음 장에서는 딥러닝 기반 시계열 모델에 대한 시리즈를 시작할 것입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 시계열 모델링 기법의 진화\n- RNN/LSTM용 DeepAR\n- 응용 - 주식 가격에 대한 확률 예측\n\n참고문헌\n\n- (XGB) Chen, T., & Guestrin, C. (2016). XGBoost: A Scalable Tree Boosting System. In Proceedings of the 22nd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining (pp. 785–794). ACM. [링크](https://dl.acm.org/doi/10.1145/2939672.2939785)\n- (LightGBM) Ke, G., Meng, Q., Finley, T., Wang, T., Chen, W., Ma, W., … & Li, Q. (2017). LightGBM: A Highly Efficient Gradient Boosting Decision Tree. In Advances in Neural Information Processing Systems (pp. 3146–3154). [링크](https://proceedings.neurips.cc/paper/2017/file/6449f44a102fde848669bdd9eb6b76fa-Paper.pdf)\n- (CatBoost) Prokhorenkova, L., Gusev, G., Vorobev, A., Dorogush, A. V., & Gulin, A. (2018). CatBoost: unbiased boosting with categorical features. In Advances in Neural Information Processing Systems (pp. 6638–6648). [링크](https://proceedings.neurips.cc/paper/2018/file/0d4724e4525b451dae9f6cb39983e6cd-Paper.pdf)\n\n샘플 eBook 챕터 (무료): [링크](https://github.com/dataman-git/modern-time-series/blob/main/20240522beauty_TOC.pdf)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- The Innovation Press, LLC의 직원들께서 아름다운 형식으로 책을 재구성해 주어 즐거운 독서 경험을 선사했습니다. 전 세계 독자들에게 복잡한 유지보수비 없이 eBook을 배포하기 위해 Teachable 플랫폼을 선택했습니다. 신용카드 거래는 Teachable.com에 의해 기밀리에 안전하게 관리됩니다.\n\nTeachable.com에서의 eBook: $22.50\nhttps://drdataman.teachable.com/p/home\n\nAmazon.com에서의 인쇄판: $65 https://a.co/d/25FVsMx\n\n- 인쇄판은 윤광 표지, 컬러 인쇄, 아름다운 Springer 글꼴과 레이아웃을 사용하여 즐거운 독서를 위해 디자인되었습니다. 7.5 x 9.25 인치의 크기는 책장의 대부분 책들과 잘 어울립니다.\n- “이 책은 과거 시계열 분석 및 예측 분석, 이상 징후 탐지 등의 응용에 대한 깊은 이해력을 갖춘 쿠오의 증명서입니다. 이 책은 독자들에게 실세계의 도전 과제에 대처하는 데 필요한 기술을 제공합니다. 데이터 과학으로의 전직을 고려하는 분들에게 특히 가치 있습니다. 쿠오는 전통적이고 최첨단 기술 모두에 대해 상세히 탐구합니다. 쿠오는 신경망 및 다른 고급 알고리즘에 대한 토론을 통합하여 최신 동향과 발전을 반영합니다. 이는 독자들이 확립된 방법뿐만 아니라 데이터 과학 분야의 가장 최신이며 혁신적인 기술과 상호작용할 수 있도록 준비되어 있다는 것을 보장합니다. 쿠오의 생동감 넘치는 글쓰기 스타일로 이 책의 명확함과 접근성이 향상되었습니다. 그는 복잡한 수학적 및 통계적 개념을 실용적으로 만들어내며 엄격함을 희생하지 않고 다가갈 수 있게 만듭니다.”\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 현대 시계열 예측: 예측 분석과 이상 감지\n\n제로 장: 서문\n\n1장: 소개\n\n2장: 비즈니스 예측을 위한 예언자\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### Chapter 3: 튜토리얼 1 - 추세 + 계절성 + 휴일 및 이벤트\n\n### Chapter 4: 튜토리얼 2 - 추세 + 계절성 + 휴일 및 이벤트 + 자기회귀(AR) + 지연 회귀 변수 + 미래 회귀 변수\n\n### Chapter 5: 시계열의 변화점 탐지\n\n### Chapter 6: 시계열 확률 예측을 위한 몬테카를로 시뮬레이션\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n제목 7: 시계열 확률 예측을 위한 분위 회귀\n\n제목 8: 시계열 확률 예측을 위한 적응형 예측\n\n제목 9: 시계열 확률 예측을 위한 적응형 분위 회귀\n\n제목 10: 자동 ARIMA!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\"Chapter 11: 시계열 데이터 형식을 쉽게 만들어보기\n\nChapter 12: 다기간 확률 예측을 위한 선형 회귀\n\nChapter 13: 트리 기반 시계열 모델을 위한 피처 엔지니어링\n\nChapter 14: 다기간 시계열 예측을 위한 두 가지 주요 전략\"\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 15장: Tree 기반 XGB, LightGBM 및 CatBoost 모델을 활용한 다기간 시계열 확률 예측\n\n# 16장: 시계열 모델링 기법의 진화\n\n# 17장: Deep Learning 기반 DeepAR을 활용한 시계열 확률 예측\n\n# 18장: 응용 - 주식 가격에 대한 확률적 예측\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 19장: RNN에서 Transformer 기반 시계열 모델로\n\n# 20장: 해석 가능한 시계열 예측을 위한 Temporal Fusion Transformer\n\n# 21장: 시계열 예측을 위한 오픈소스 Lag-Llama 튜토리얼\n","ogImage":{"url":"/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_0.png","tag":["Tech"],"readingTime":26},{"title":"알아두었으면 좋았을 Python 리스트 방법 12가지","description":"","date":"2024-07-09 19:32","slug":"2024-07-09-12PythonListThingsIRegretNotKnowingEarlier","content":"\n![이미지](/TIL/assets/img/2024-07-09-12PythonListThingsIRegretNotKnowingEarlier_0.png)\n\n파이썬 여행을 하면서 몇 가지를 좀 늦게 알게 되었는데, 아마 당신이 이것들을 더 빨리 배울 수 있을 거에요.\n\n### 1) 리스트를 결합하기 위해 \\* 사용하기\n\n리스트 앞에 \\*을 추가하면 언팩합니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\na = [1, 2]\nb = [3, 4]\n\nc = [*a, *b, 5]\n\nprint(c) # [1, 2, 3, 4, 5]\n```\n\n- 첫 번째 \\*는 a의 요소를 c에 풀어 헤친다\n- 두 번째 \\*는 b의 요소를 c에 풀어 헤친다\n- 이것이 왜 1, 2, 3, 4, 5가 동일한 목록 c에 들어 있는지 이유입니다\n\n```js\na = [1, 2]\nb = [3, 4]\nc = [5, 6]\nd = [7, 8]\n\nx = [*a, b, *c, d]\n\nprint(x) # [1, 2, [3,4], 5, 6, [7, 8]]\n```\n\n^ \\*이 붙은 리스트(a와 c)만 풀어 헤쳐진다는 것을 주목해 주세요. b와 d는 일반 요소처럼 처리됩니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 2) \\*를 사용하여 리스트 언패킹하기\n\n리스트를 언패킹할 때, 우리는 \\*를 변수 앞에 사용하여 즉시 사용하지 않을 초과 요소를 받을 수 있습니다.\n\n```js\nmylist = ['apple', 'orange', 'pear', 'pineapple', 'durian']\n\na, b, *others = mylist\n\nprint(a)       # apple\nprint(b)       # orange\nprint(others)  # ['pear', 'pineapple', 'durian']\n```\n\n- a는 mylist의 첫 번째 요소에 할당됩니다.\n- b는 mylist의 두 번째 요소에 할당됩니다.\n- others는 mylist의 모든 다른 요소를 받는 리스트에 할당됩니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n노트 - a와 b가 반드시 가장 앞에 있을 필요는 없습니다.\n\n```js\nmylist = ['apple', 'orange', 'pear', 'pineapple', 'durian']\n\na, *others, b = mylist\n\nprint(a)       # apple\nprint(b)       # durian\nprint(others)  # ['orange', 'pear', 'pineapple']\n```\n\n- a는 mylist의 첫 번째 요소에 할당됩니다.\n- b는 mylist의 마지막 요소에 할당됩니다.\n- others는 mylist 사이에 모든 다른 요소를 캐치하는 리스트에 할당됩니다.\n\n# 3) 리스트를 함수 인수로 언패킹하는 방법\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n함수 이름, 나이, 성별을 받는 test 함수가 있다고 가정해보죠. 이 함수를 사용하려면 test(이름, 나이, 성별)와 같이 전달해주어야 합니다.\n\n```js\ndef test(name, age, gender):\n    print(name, age, gender)\n\ntest('rocky', 5, 'male') # rocky 5 male\n```\n\n만약 올바른 함수 인수를 포함하는 리스트 x = ['rocky', 5, 'male']가 있다면, \\*를 사용하여 해당 인수를 함수에 전달할 수 있습니다.\n\n```js\nx = ['rocky', 5, 'male']\n\ntest(*x) # rocky 5 male\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위 내용은 다음과 같습니다:\n\n```js\ntest(\"rocky\", 5, \"male\");\n```\n\n# 4) 리스트 컴프리헨션\n\n어떤 이유로 인해 나는 리스트 컴프리헨션에 대해 상대적으로 늦게 배웠다 (자료 구조와 알고리즘에 대해서 배운 후에야).\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 우리가 [1, 2, 3, 4, 5]라는 리스트가 있고, 각 요소를 10씩 곱해서 [10, 20, 30, 40, 50] 리스트를 만들고 싶다면, 리스트 컴프리헨션 없이는 어떻게 할 수 있을까요:\n\n```js\nnumbers = [1, 2, 3, 4, 5]\n\nnewlist = []\nfor number in numbers:\n    newlist.append(number * 10)\n\nprint(newlist)  # [10, 20, 30, 40, 50]\n```\n\n리스트 컴프리헨션을 사용하여 훨씬 더 우아하게 할 수 있는 방법은 다음과 같습니다:\n\n```js\nnumbers = [1, 2, 3, 4, 5]\n\nnewlist = [n * 10 for n in numbers]\n\nprint(newlist)  # [10, 20, 30, 40, 50]\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 5) 중첩된 리스트에 대한 리스트 컴프리헨션\n\n하지만 중첩된 for 루프는 어떻게 할까요? 걱정하지 마세요. 리스트 컴프리헨션은 이를 쉽게 처리할 수 있습니다. 리스트 컴프리헨션을 사용하지 않은 예시를 통해 살펴보겠습니다:\n\n```js\nnewlist = []\n\nfor i in [1, 2]:\n    for j in [3, 4]:\n        t = (i, j)\n        newlist.append(t)\n\nprint(newlist) # [(1, 3), (1, 4), (2, 3), (2, 4)]\n```\n\n리스트 컴프리헨션을 사용하여 정확히 동일한 작업을 수행할 수 있습니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nnewlist = [(i,j) for i in [1,2] for j in [3,4]]\n\nprint(newlist) # [(1, 3), (1, 4), (2, 3), (2, 4)]\n```\n\n^ 중첩된 for 루프를 리스트 내포로 변환할 때는 외부 for 루프가 먼저 오고, 그 다음에 내부 for 루프가 옵니다.\n\n# 6) 튜플 대 리스트\n\n비기너였을 때 저는 꽤 오랫동안 튜플을 무시했습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n튜플은 그냥 변경할 수 없는 목록입니다. 변경할 수 없다는 것은 튜플을 만든 후에는 변경할 수 없다는 것을 의미합니다.\n\n```js\n# 리스트는 변경할 수 있습니다. .append를 사용하여 만든 후에도 요소를 추가할 수 있습니다.\n\nmylist = [1, 2, 3]\n\nmylist.append(4)\nprint(mylist)      # [1, 2, 3, 4]\n```\n\n```js\n# 튜플은 변경할 수 없습니다. 만든 후에는 아무것도 추가할 수 없습니다\n\nmytuple = (1, 2, 3)\n\nmytuple.append(4) # ERROR\n```\n\n그래서 튜플은 목록의 안 좋은 버전으로 보입니다. 왜 튜플을 사용해야 할까요?\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n튜플의 불변성의 가장 큰 장점은 해시 가능하다는 것입니다.\n\n- 리스트는 사전 키가 될 수 없지만 튜플은 될 수 있습니다\n- 리스트는 집합에 추가할 수 없지만 튜플은 추가할 수 있습니다\n\n```js\n# 리스트는 1) 사전 키로 사용할 수 없으며 2) 집합에 추가할 수 없음\n\nd = {\n    [1, 2, 3]: 4,\n    [5, 6, 7]: 8\n}\n\n# ERROR\n```\n\n```js\n# 하지만 튜플은 가능합니다\n\nd = {\n    (1, 2, 3): 4,\n    (5, 6, 7): 8\n}\n\n# OK\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 7) .insert()을 사용하여 특정 인덱스에 새 요소를 삽입합니다.\n\n.append()은 리스트의 뒷부분에만 새 요소를 추가할 수 있습니다.\n\n하지만 .insert()을 사용하면 새 요소를 어떤 인덱스에든 추가할 수 있습니다.\n\n```js\nmylist = [1, 2, 3]\n\n# 새 값 100을 인덱스 0에 추가\nmylist.insert(0, 100)\n\nprint(mylist) # [100, 1, 2, 3]\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n^ 기존 요소가 모두 오른쪽으로 이동해야 하므로 이 작업은 O(n) 시간이 걸립니다.\n\n```js\nmylist = [1, 2, 3]\n\n# 인덱스 2에 새로운 요소 150 추가\nmylist.insert(2, 150)\n\nprint(mylist) # [1, 2, 150, 3]\n```\n\n^ 1과 2는 그대로 있지만, 3은 오른쪽으로 이동해야 합니다.\n\n# 8) .pop()을 사용하여 요소 제거\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n.pop() 메소드를 사용하면 2가지 작업을 동시에 할 수 있습니다:\n\n- 리스트의 마지막 요소를 삭제합니다.\n- 삭제된 이 요소를 반환합니다.\n\n```js\nmylist = [1, 2, 3]\n\n# 마지막 요소 제거하고 x에 할당\nx = mylist.pop()\n\nprint(x)      # 3\nprint(mylist) # [1, 2]\n```\n\n.pop()에 인덱스를 전달하면 해당 인덱스의 요소를 제거할 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n내목록 = [1, 2, 3]\n\n# 인덱스 0의 요소를 제거하고 x에 할당\nx = 내목록.pop(0)\n\nprint(x)       # 1\nprint(내목록)  # [2, 3]\n```\n\n.pop(n)은 모두 n 이후에 위치한 인데스의 요소를 좌측으로 이동해야 하므로 O(n) 시간이 걸린다는 것을 알아두세요. 이것은 우리 목록이 매우 큰 경우 비효율적일 수 있다는 것을 의미합니다.\n\n# 9) .extend()를 사용하여 목록 결합\n\n.extend()는 한 목록의 모든 요소를 다른 목록에 추가할 수 있게 해줍니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\na = [1, 2, 3]\nb = [4, 5, 6]\n\n# b의 모든 요소를 a에 추가합니다.\na.extend(b)\n\nprint(a)  # [1, 2, 3, 4, 5, 6]\nprint(b)  # [4, 5, 6]\n```\n\n^ b가 변경되지 않았음에 유의해주세요\n\n# 10) sort() vs sorted()\n\n- `.sort()`은 리스트 자체를 정렬합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nmylist = [1, 3, 2]\n\nmylist.sort()\n\nprint(mylist) # [1, 2, 3]\n```\n\nsorted() 함수는 리스트를 정렬한 복사본을 생성합니다. 원본 리스트는 그대로 유지됩니다. 원본 리스트의 순서를 보존하고 싶을 때 이것을 사용합니다.\n\n```js\nmylist = [1, 3, 2]\n\nnewlist = sorted(mylist)\n\nprint(newlist)  # [1, 2, 3]\nprint(mylist)   # [1, 3, 2]\n```\n\n# 11) 사용자 정의 조건으로 .sort()하기\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n**참고— 이것은 .sort()와 sorted()에 대해 동일하게 작동합니다.**\n\n기본 .sort()는 문자열을 알파벳 순서대로 정렬합니다:\n\n```js\nfruits = ['orange', 'apple', 'pear']\n\nfruits.sort()\n\nprint(fruits) # ['apple', 'orange', 'pear']\n```\n\n우리는 .sort()에서 key 인자에 함수를 전달하여 사용자 정의 정렬 조건을 정의할 수 있습니다. 예: list.sort(key=your_function)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 함수는 전체 요소를 가져와서\n- 우리가 정렬하려는 값을 반환합니다.\n\n문자열 내의 p의 개수로 정렬하고 싶다고 가정해 봅시다.\n\n- 따라서 사용자 정의 함수는 여전히 전체 요소를 가져와서\n- p 문자의 개수를 반환합니다.\n\n```js\ndef your_condition(element: str) -> int:\n    return element.count('p')\n\nfruits = ['orange', 'apple', 'pear']\n\nfruits.sort(key=your_condition)\n\nprint(fruits) # ['orange', 'pear', 'apple']\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테이블 태그를 Markdown 형식으로 변경하세요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n노트 - 이 코드는 .sort()와 sorted() 모두에 작동합니다.\n\n학생을 나타내는 각각의 사전이 포함된 목록이 있다고 가정해 봅시다.\n\n```js\nstudents = [\n  { name: \"A\", math: 100, science: 81 },\n  { name: \"B\", math: 100, science: 71 },\n  { name: \"C\", math: 100, science: 91 },\n  { name: \"D\", math: 80, science: 91 },\n  { name: \"E\", math: 80, science: 93 },\n  { name: \"F\", math: 80, science: 92 },\n];\n```\n\n그리고 그들의 수학 점수에 따라 정렬한다고 가정합시다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nstudents.sort(key=lambda x:x['math'])\n\nprint(students)\n\n'''\n[\n  {'name': 'D', 'math': 80, 'science': 91},\n  {'name': 'E', 'math': 80, 'science': 93},\n  {'name': 'F', 'math': 80, 'science': 92},\n  {'name': 'A', 'math': 100, 'science': 81},\n  {'name': 'B', 'math': 100, 'science': 71},\n  {'name': 'C', 'math': 100, 'science': 91}\n]\n'''\n\n^ math=80 at the front, math=100 at the back. But notice that their science score is not sorted.\n\nAnd what if we want to sort by math first, then science?\n\n- first sort by math score\n- for students with the same math score, sort by science score\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이를 수행하기 위해서는 우리의 주요 함수는 단순히 튜플 (첫 번째 조건, 두 번째 조건)을 반환하면 됩니다. 이 경우에는 (수학 점수, 과학 점수)가 될 것입니다.\n\n```js\nstudents.sort(key=lambda x:(x['math'], x['science']) )\n\nprint(students)\n\n'''\n[\n  {'name': 'D', 'math': 80, 'science': 91},\n  {'name': 'F', 'math': 80, 'science': 92},\n  {'name': 'E', 'math': 80, 'science': 93},\n  {'name': 'B', 'math': 100, 'science': 71},\n  {'name': 'A', 'math': 100, 'science': 81},\n  {'name': 'C', 'math': 100, 'science': 91}\n]\n'''\n```\n\n그리고 여기서, 수학 점수가 동일한 학생들은 과학 점수에 의해 정렬됨을 주목해 보세요.\n\n참고 — 3가지 조건에 따라 정렬하려면, 단순히 (첫 번째 조건, 두 번째 조건, 세 번째 조건)의 튜플을 반환하면 됩니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결론\n\n이 내용이 명확하고 이해하기 쉬웠으면 좋겠어요!\n\n# 친구들을 위한 Python 농담\n\n# 만약에 제작자로서 저를 지원하고 싶다면\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 제 책을 구입해 주세요! — 101 Things I Never Knew About Python\n- 확인할 수 있는 곳: [여기](https://payhip.com/b/vywcf)\n- 이 이야기를 위해 50번 클랩을 해주세요\n- 댓글로 당신의 생각을 남겨주세요\n- 이야기 중 가장 좋아하는 부분을 강조해주세요\n\n감사합니다! 이런 작은 행동이 큰 도움이 되고, 정말 감사드립니다!\n\nYouTube: [여기](https://www.youtube.com/@zlliu246)\n\nLinkedIn: [여기](https://www.linkedin.com/in/zlliu/)\n","ogImage":{"url":"/assets/img/2024-07-09-12PythonListThingsIRegretNotKnowingEarlier_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-12PythonListThingsIRegretNotKnowingEarlier_0.png","tag":["Tech"],"readingTime":15},{"title":"다중 기간 확률 예측을 위한 선형 모델 이해하기","description":"","date":"2024-07-09 19:30","slug":"2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting","content":"\n<img src=\"/TIL/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_0.png\" />\n\n샘플 eBook 장(chapters) (무료): [여기](https://github.com/dataman-git/modern-time-series/blob/main/20240522beauty_TOC.pdf)\n\nTeachable.com에서 eBook: $22.50 [여기](https://drdataman.teachable.com/p/home)\n\nAmazon.com에서 인쇄본: $65 [여기](https://a.co/d/25FVsMx)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n선형 회귀 모델은 시계열에 대한 점 추정을 당연히 할 수 있습니다. 선형 회귀 모델은 빠르고 해석하기 쉽며 쉽게 배포할 수 있는 장점이 있습니다. 많은 기관에서 여전히 좋은 선택입니다. 선형 회귀의 일반적인 유형은 자기회귀 모델로, 9장인 \"자동 ARIMA\"에서 나와 있습니다. 그러나 많은 실제 사용 사례에서는 다음 두 가지를 제공해야 합니다: (1) 확률적 예측(또는 예측 구간 또는 예측 불확실성이라고도 함)과 (2) 다기간 예측. 선형 회귀를 어떻게 확장하여 이 두 결과를 수행할 수 있을까요?\n\n(1)에 대한 해결책은 분위 회귀를 사용하여 예측 불확실성을 제공하는 것입니다. (A) 그림은 분위 예측을 보여줍니다. 미래의 시간 t에 대해 10번째, 50번째 및 90번째 백분위수를 기반으로 예측 샘플을 반환합니다. 필요하다면 더 많은 분위 샘플을 생성할 수 있습니다. 이에 대해서는 \"6장: 예측 불확실성을 위한 분위 회귀\"를 참조해주세요.\n\n![quantile forecasts](/TIL/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_1.png)\n\n(2)는 어떻게 해결할까요? 선형 회귀는 점 예측을 생성하지만, 다기간 예측을 어떻게 만들까요? 한 가지 방법은 동일한 모델을 재귀적으로 사용하는 것일 수 있습니다. 한 기간 예측을 모델로부터 얻어 다음 기간을 예측하는 데 입력으로 사용합니다. 그런 다음 두 번째 기간을 예측하기 위해 두 번째 기간의 예측을 입력으로 사용합니다. 이전 기간의 예측을 사용하여 모든 기간을 반복할 수 있습니다. 이것이 재귀 예측 또는 반복적 예측 전략이 하는 일입니다. (B) 그림은 모델이 먼저 yt+1을 생성하고, 그런 다음 같은 모델이 yt+1을 사용하여 yt+2를 생성하는 것을 보여줍니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 마크다운 형식의 테이블입니다.\n\n또 다른 전략은 n개의 별도 모델을 구축하는 것입니다. 각 모델은 n개의 기간에 대한 예측을 생성합니다. 10개 기간을 예측하려면 10개의 모델을 교육하고 각 모델을 특정 단계를 예측하도록 설정합니다. 이를 직접 예측 전략이라고 합니다. 이 전략은 그림 (C)에 나와 있습니다. 두 가지 전략을 학습하려면 13장인 \"다중 기간 시계열 예측을 위한 두 가지 주요 전략\"으로 이동하세요.\n\n선형 회귀를 단변량 시계열로 제한할 이유는 명백히 없습니다. 다른 변수인 공변량이라고 불리는 변수도 추가할 수 있습니다. 그림 (D)에는 다른 공변량 xt와 과거 p개 항목이 포함되어 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![그림](/TIL/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_4.png)\n\n선형 모델은 Figure (A)에 표시된 분위수 예측 및 Figure (D)에 표시된 직접 예측을 수행해야 할 때 복잡해 보입니다. 다행히 Python 시계열 라이브러리인 Darts에서 이러한 프로세스가 구현되었습니다. Darts 라이브러리는 \"scikit-learn\" 함수를 많이 포함하고 있어 \"scikit-learn\"의 기능을 활용할 수 있습니다. 이 중에는 sklearn의 분위수 회귀기능도 포함되어 있습니다. 따라서 우리는 Darts 라이브러리에 초점을 맞출 수 있습니다.\n\n우리는 다음 단계로 진행할 것입니다:\n\n- 단변량 데이터로 시작하기\n- 다른 공변럇값 포함하기, 그리고\n- 분위수 예측 포함하기.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nDarts 라이브러리는 시계열 데이터를 위한 특별한 데이터 형식을 가지고 있어요. 10장: 시계열 데이터 형식을 쉽게 다루는 내용은 Darts의 데이터 구조에 대해 소개하고 있어요. 이 장의 파이썬 노트북은 이 Github 링크를 통해 확인할 수 있어요.\n\n우선 데이터를 불러와 볼까요?\n\n데이터 불러오기\n\n이번에는 Kaggle.com의 Walmart 데이터셋을 사용해 보겠어요. 이 데이터셋은 2010년 2월 5일부터 2012년 11월 1일까지의 매장 주간 매출 데이터를 포함하고 있어요:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 날짜 — 판매 주의 주\n- 상점 — 상점 번호\n- 주간 판매 — 상점의 매출\n- 공휴일 플래그 — 특별 공휴일 주 인지 여부 1 — 공휴일 주 0 — 비공휴일 주\n- 온도 — 판매일의 온도\n- 연료 가격 — 지역의 연료 비용\n\n또한 소매 매출에 영향을 미칠 수 있는 두 가지 거시 경제 지표가 있습니다: 소비자물가지수 및 실업률. 데이터 집합은 먼저 Pandas 데이터 프레임으로로드됩니다.\n\n```js\n%matplotlib inline\nimport pandas as pd\nimport numpy as np\nfrom matplotlib import pyplot as plt\n\nfrom google.colab import drive\ndrive.mount('/content/gdrive')\npath = '/content/gdrive/My Drive/data/time_series'\ndata = pd.read_csv(path + '/walmart.csv', delimiter=\",\")\ndata['ds'] = pd.to_datetime(data['Date'], format='%d-%m-%Y')\ndata.index = data['ds']\ndata = data.drop('Date', axis=1)\ndata.head()\n```\n\n<img src=\"/TIL/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_5.png\" />\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n데이터 준비를 위한 Darts의 주요 Python 클래스는 TimeSeries 클래스입니다. Darts는 값들을 다차원 배열로 저장하는데, 이 배열들은 다음과 같은 형태를 가지고 있어요 (시간, 차원, 샘플):\n\n- 시간: 예를 들어 위 예시에서처럼 143주와 같은 시간 색인을 말해요.\n- 차원: 다변량 시리즈의 \"열\"들을 나타냅니다.\n- 샘플: 기간에 대한 값들을 의미합니다. 만약 10번째, 50번째, 90번째 백분위수에 대한 세 개의 샘플과 같이 확률론적 예측이라면, 세 개의 샘플이 존재하게 됩니다.\n\nWalmart 상점 매출을 불러오기 위해 .from_group_dataframe() 함수를 사용할 거에요. 그룹 ID는 \"Store\"이며, 따라서 group_cols 매개변수는 \"Store\"여야 해요. 시간 색인은 \"ds\" 열이에요.\n\n```js\nfrom darts import TimeSeries\ndarts_group_df = TimeSeries.from_group_dataframe(data, group_cols='Store', time_col='ds')\nprint(\"상점/그룹 수는:\", len(darts_group_df))\nprint(\"시간 기간의 수는: \", len(darts_group_df[0]))\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그룹/스토어의 수는 45개입니다.\n기간의 수는 143개입니다.\n\n.columns 함수를 사용하여 열을 나열할 수 있습니다:\n\n```js\ndarts_group_df[0].components;\n```\n\n열 이름은:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n인덱스(['주간_매출', '휴일_플래그', '온도', '유종_가격', '소비자_물가_지수', '실업률'], dtype='object', name='구성요소')\n\n로컬 모델 구축하기\n\n시계열 예측에서는 두 가지 주요 유형의 모델이 있습니다: 로컬 모델과 글로벌 모델이 있습니다. 로컬 모델은 단일 시계열 또는 단변량 시계열에 사용되며 해당 시리즈에서 고유한 패턴과 트렌드를 포착하도록 설계되었습니다. 반면 글로벌 모델은 여러 시계열을 사용하여 개발되며 매개변수가 모든 시계열 전체에서 공유됩니다. 이를 통해 모델은 시계열 간에 일반적인 패턴과 관계를 포착하여 보다 정확한 예측을 할 수 있습니다.\n\n각 가게에 대해 로컬 모델을 구축할 것입니다. 가게 1 판매를 위한 모델을 구축하기 위해 가게 1의 데이터인 \"darts_group_df[0]\"를 사용할 것입니다. 이를 훈련 및 테스트 데이터로 분할할 것입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nstore1 = darts_group_df[0]\ntrain = store1[:130]\ntest = store1[130:]\nlen(train), len(test) # (130, 13)\n```\n\n타겟 변수와 공변량을 정의해 봅시다.\n\n타겟 및 과거, 미래 공변량\n\n저희의 타겟 시리즈는 \"Weekly_Sales\"입니다. 다른 공변량도 포함할 수 있습니다. 시계열에서는 과거 공변량과 미래 공변량 두 가지 유형의 공변량이 있습니다. 과거 공변량은 현재 연구 시점까지의 변수입니다. 그리고 미래 공변량은 미래에서 관찰 가능한 변수입니다. 미래 값을 어떻게 알 수 있는지 궁금할 수도 있습니다. 우리는 미래 값을 알 수 있는 이유가 두 가지 있습니다. 첫 번째 이유는 그들이 달력 일수, 공휴일 또는 정기 프로모션과 같은 결정론적 값이기 때문입니다. 두 번째 이유는 날씨 예보와 같은 외부 소스의 예측 값입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리 경우에는 \"Fuel_price\"와 \"CPI\"를 과거 공선변수로 포함하고 \"Holiday_flag\"를 미래 공선변수로 포함할 것입니다. 훈련 데이터에서 목표 및 과거 공선변수는 130개의 데이터 포인트를 가지고 있습니다. 그러나 미래 공선변수는 미래로 확장되어야 하며, 테스트 데이터의 기간을 커버하기 위해 추가 13개의 데이터 포인트를 가지고 있어야 합니다.\n\n```js\ntarget = train['Weekly_Sales']  #130 주\npast_cov = train[['Fuel_Price', 'CPI']]  # 130 주\nfuture_cov = store1['Holiday_Flag'][:143]  #143 주\n```\n\n기본 구문을 보여주기 위해 공선변수 없이 시작해봅시다.\n\n(1) 유변량 데이터만, 공선변수 없음\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래 코드는 Darts의 LinearRegressionMode 클래스의 공식입니다.\n\n```js\nfrom darts.models import LinearRegressionModel\nn = 11\nmodel = LinearRegressionModel(\n    lags=12,\n    multi_models = True  # 기본값\n)\n```\n\n주요 입력 매개변수는 다음과 같습니다:\n\n- lags: 지연된 항목의 수\n- multi_models: 이 하이퍼 매개변수는 다기간 예측 전략을 식별합니다. \"True\"이면 직접 예측 전략을 적용하고, 그렇지 않으면 재귀적 예측 전략을 적용합니다. 기본값은 \"True\"입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\"우리는 단변량 시리즈 'target'을 사용하여 모델을 훈련하고 다음 n 기간을 예측할 것입니다.\n\n```js\nmodel.fit(target)\npred = model.predict(n)\npred.values()\"\n```\n\n결과는 다음 n 기간을 예측한 것입니다. 위의 코드가 이미 직접 예측 전략을 실행했음을 주목하세요.\n\n![image](/TIL/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_6.png)\"\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n훈련 데이터, 예측 값 및 실제 값들을 함께 시각화해 보겠습니다:\n\n```js\nimport matplotlib.pyplot as plt\ntarget.plot(label='훈련 데이터')\npred.plot(label='예측값')\ntest['Weekly_Sales'][:n].plot(label='실제값')\n```\n\n그림 (G)은 위의 플롯을 보여줍니다.\n\n<img src=\"/TIL/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_7.png\" />\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모델의 성능은 어떤가요? 평균 절대 오차 또는 평균 절대 백분율 오차를 사용해보는 것이 좋을 것 같아요.\n\n```js\nfrom darts.metrics.metrics import mae, mape\nprint(\"평균 절대 오차:\", mae(test['Weekly_Sales'][:n], pred))\nprint(\"평균 절대 백분율 오차:\", mape(test['Weekly_Sales'][:n], pred))\n```\n\nMAPE는 4.07% 입니다:\n\n- 평균 절대 오차: 63404.82928050449\n- 평균 절대 백분율 오차: 4.070126403190025\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 다른 공석요인을 추가해 봅시다.\n\n과거 및 미래 공석요인 추가하기\n\n공석요인은 추가 입력 변수입니다. Darts는 모델링을 위해 두 가지 유형의 공석요인을 취합니다. 하나는 과거 공석요인(lags_past_covariates)으로 된 지연된(lagged) 과거 공석요인이며, 다른 하나는 다소 혼란스러운 이름을 가진 미래 공석요인(lags_future_covariates)입니다. \"미래 공석요인\"은 이러한 공석요인의 미래 시간 단계에서의 값을 가리킵니다. 그리고 \"지연된\" 값은 이전 시간 단계의 미래 공석요인을 나타냅니다. 따라서 미래에서 t + n 단계에 해당하는 시간에 모델은 t부터 t + (n-1) 기능의 공석요인 값을 고려합니다.\n\n```js\nfrom darts.models import LinearRegressionModel\nn = 12\nmodel = LinearRegressionModel(\n    lags=12,\n    lags_past_covariates=12,\n    lags_future_covariates=[0,1,2,3,4,5,6,7,8,9,10,11,12],\n    output_chunk_length=12,\n)\nmodel.fit(target, past_covariates=past_cov, future_covariates=future_cov)\npred = model.predict(n)\npred.values()\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n상기된 매개변수 output_chunk_length에 대해 자세한 설명이 필요합니다. 이는 단변량 시리즈에서 샘플을 생성하는 데 관한 것입니다. Figure (H)에서는 y0부터 y15까지의 시리즈에서 생성된 샘플을 보여줍니다. 각 샘플은 입력 청크와 출력 청크를 포함합니다. 입력 청크의 길이가 5이고 출력 청크의 길이가 2인 것으로 가정해 봅시다. 첫 번째 샘플은 입력 청크로 y0부터 y4를, 출력 청크로 y5, y6을 가집니다. 창이 시리즈를 따라 이동하여 시리즈의 끝까지 샘플을 만듭니다.\n\n![이미지](/TIL/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_8.png)\n\n출력 청크의 길이는 예측 가능한 최대 길이를 정의합니다. 이를 12로 지정했습니다. 12보다 더 많이 예측하고자 한다면 에러 메시지를 받게 될 것입니다.\n\n다음으로 하이퍼파라미터 multi_models=True는 다중 기간에 대한 확률적 예측을 위한 직접적인 전략을 정의합니다. 이는 각 미래 n 기간을 위해 별도의 n개 모델을 구축하는 전략을 의미합니다. 이는 기본 값이기 때문에 별도로 명시할 필요가 없습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/TIL/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_9.png)\n\n모델링과 예측을 한 뒤에는 실제 값과 예측값을 플롯에 함께 표시해보겠습니다.\n\n```js\nimport matplotlib.pyplot as plt\ntarget.plot(label='훈련 데이터')\npred.plot(label='예측값')\ntest['Weekly_Sales'][:n].plot(label='실제값')\n```\n\n(J) 그림은 결과를 플롯한 것입니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Image](/TIL/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_10.png)\n\n성능을 측정해 봅시다.\n\n```js\nprint(\"평균 절대 오차:\", mae(test['Weekly_Sales'][:n], pred))\nprint(\"평균 절대 백분율 오차:\", mape(test['Weekly_Sales'][:n], pred))\n```\n\n- 평균 절대 오차: 119866.3976798996\n- 평균 절대 백분율 오차: 7.738643655822244\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nMAPE는 7.73%로 이전 모델보다 낮습니다. 이전 모델을 선택할 수도 있었을 텐데요. 그 다음으로는 분위 예측을 생성하는 방법을 배워보겠습니다.\n\n(3) 분위 예측\n\n앞서 언급한대로 quantiles=[0.01,0.05,0.50,0.95,0.99]을 추가합니다. 샘플이 5개 있기 때문에 .predict()에서 num_samples=5를 지정할 것입니다.\n\n```js\nfrom darts.models import LinearRegressionModel\nn = 12\nchunk_length = n\nmodel = LinearRegressionModel(\n    lags=12,\n    lags_past_covariates=12,\n    lags_future_covariates=[0,1,2,3,4,5,6,7,8,9,10,11,12],\n    output_chunk_length=chunk_length,\n    likelihood = 'quantile', # 'quantile' 또는 'poisson'으로 설정할 수 있습니다.\n    # 'quantile'로 설정할 경우, sklearn.linear_model.QuantileRegressor가 사용됩니다.\n    # 'poisson'으로 설정할 경우, sklearn.linear_model.PoissonRegressor가 사용됩니다.\n    quantiles=[0.01, 0.05, 0.50, 0.95,0.99]\n)\nmodel.fit(target, past_covariates=past_cov, future_covariates=future_cov)\npred = model.predict(n, num_samples=5)\npred\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n각 기간에 대한 예측은 한 샘플 대신 5개의 샘플이 될 것입니다. (그래서 Darts의 데이터 형식을 \"샘플\"이라고 부릅니다.)\n\n![이미지](/TIL/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_11.png)\n\n실제 값과 확률 예측을 그래플에 플로팅할 것입니다.\n\n```js\nimport matplotlib.pyplot as plt\ntarget.plot(label='train')\npred.plot(label='prediction')\ntest['Weekly_Sales'][:n].plot(label='actual')\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![위 예측은 확률적 예측을 위한 연한 파란색 영역을 포함합니다.](/TIL/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_12.png)\n\n결론\n\n이 장에서는 Darts 라이브러리를 사용하여 선형 회귀 모델 클래스를 배웠습니다. 이를 통해 여러 기간의 확률적 예측을 위한 선형 모델을 구축할 수 있습니다. 과거 및 미래 공변량을 포함한 구문 및 다기간 앞쪽 예측을 위한 직접 또는 재귀적 예측 전략의 옵션을 배웠습니다. 또한 모델을 분위수 확률적 예측을 위해 설정하는 방법도 배웠습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 장에서는 최신 회귀 기반 시계열 기법을 마무리합니다:\n\n- 자동 ARIMA!\n- 쉬운 시계열 데이터 형식\n- 다기간 확률 예측을 위한 선형 회귀\n\n다음 단원에서는 트리 기반 모델링 기법을 공부할 예정입니다:\n\n- 트리 기반 시계열 예측에 대한 튜토리얼\n- 다기간 시계열 예측에 대한 튜토리얼\n- 다기간 시계열 확률 예측을 위한 트리 기반 XGB, LightGBM 및 CatBoost 모델\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n샘플 eBook 챕터(무료): [여기](https://github.com/dataman-git/modern-time-series/blob/main/20240522beauty_TOC.pdf)\n\n- The Innovation Press, LLC의 스태프 여러분께 감사드립니다. 아름다운 형식으로 책을 재현하여 즐거운 독서 경험을 선사해 주셨습니다. 저희는 Teachable 플랫폼을 선택하여 eBook을 전 세계 독자에게 분배하며 무거운 오버헤드 없이 알찬 서비스를 제공합니다. 결제 거래는 Teachable.com에서 신뢰성 있고 안전하게 처리됩니다.\n\nTeachable.com에서의 eBook: $22.50\n[여기에서 확인하세요](https://drdataman.teachable.com/p/home)\n\nAmazon.com에서의 인쇄판: $65 [여기서 확인하세요](https://a.co/d/25FVsMx)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 인쇄판은 광택이 도는 표지, 컬러 프린트, 아름다운 Springer 폰트와 레이아웃이 매력적인 읽기를 위해 채택되었습니다. 7.5 x 9.25인치의 포털 크기로 대부분의 책장에 적합합니다.\n- \"이 책은 Kuo의 시계열 분석에 대한 심층적인 이해와 예측 분석 및 이상 탐지에 대한 응용을 입증하는 것입니다. 이 책은 독자들이 현실 세계의 도전 과제에 대처하는 데 필요한 기술을 제공합니다. 데이터 과학으로의 직업 전환을 추구하는 사람들에게 특히 가치 있는 자료입니다. Kuo는 전통적인 기법과 최신 기법을 자세히 탐구했습니다. Kuo는 신경망 및 다른 고급 알고리즘에 대한 논의를 통합함으로써, 분야의 최신 동향과 발전을 반영했습니다. 이것은 독자가 확립된 방법뿐만 아니라 데이터 과학 분야의 가장 최신이며 혁신적인 기법과 상호 작용할 준비가 되어 있는 것을 보장합니다. Kuo의 유쾌한 글쓰기 스타일로 책의 알기 쉽고 접근성이 향상되었습니다. 그는 복잡한 수학적 및 통계적 개념을 낯설지 않게 만들어 손실되지 않도록 했습니다.\"\n\n# 모던 시계열 예측: 예측 분석과 이상 탐지를 위한\n\nChapter 0: 서문\n\nChapter 1: 소개\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 장 2: 비즈니스 예측용 선지자\n\n## 장 3: 튜토리얼 I: 추세 + 계절성 + 휴일 및 이벤트\n\n## 장 4: 튜토리얼 II: 추세 + 계절성 + 휴일 및 이벤트 + 자기회귀(AR) + 지연 회귀자 + 미래 회귀자\n\n## 장 5: 시계열에서의 변화점 탐지\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n6장: 시계열 확률 예측을 위한 몬테카를로 시뮬레이션\n\n7장: 시계열 확률 예측을 위한 분위수 회귀\n\n8장: 시계열 확률 예측을 위한 일치 예측\n\n9장: 시계열 확률 예측을 위한 일치화된 분위수 회귀\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 제 10 장: 자동 ARIMA!\n\n### 제 11 장: 시계열 데이터 형식 쉽게 만들기\n\n### 제 12 장: 다기간 확률 예측을 위한 선형 회귀\n\n### 제 13 장: 트리 기반 시계열 모델용 피처 엔지니어링\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nChapter 14: 다기간 시계열 예측을 위한 두 가지 주요 전략\n\nChapter 15: Tree 기반 XGB, LightGBM 및 CatBoost 모델에 대한 다기간 시계열 확률적 예측\n\nChapter 16: 시계열 모델링 기술의 진화\n\nChapter 17: 시계열 확률적 예측을 위한 Deep Learning 기반 DeepAR\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Chapter 18: 주식 가격을 위한 확률론적 예측 애플리케이션\n\n# Chapter 19: RNN에서 Transformer 기반 시계열 모델로\n\n# Chapter 20: 해석 가능한 시계열 예측을 위한 Temporal Fusion Transformer\n\n# Chapter 21: 시계열 예측을 위한 오픈 소스 Lag-Llama 튜토리얼\n","ogImage":{"url":"/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_0.png","tag":["Tech"],"readingTime":21},{"title":"파이썬 고급 문자열 조작 기법들","description":"","date":"2024-07-09 19:28","slug":"2024-07-09-AdvancedStringManipulationsinPython","content":"\n![Advanced String Manipulations in Python](/TIL/assets/img/2024-07-09-AdvancedStringManipulationsinPython_0.png)\n\n파이썬에서 문자열은 기본적이며 거의 모든 파이썬 애플리케이션에서 널리 사용됩니다. 연결 및 슬라이싱과 같은 기본적인 문자열 작업은 간단하지만, 파이썬은 코드를 보다 효율적이고 가독성 있게 만들어주는 다양한 고급 문자열 조작 기술을 제공합니다. 이 기사는 파이썬에서의 고급 문자열 조작에 대해 자세히 설명하고 있으며, 중급 개발자들이 문자열 처리 능력을 향상할 수 있도록 예제와 함께 제공합니다.\n\n# 문자열 포매팅\n\n## format() 사용하기\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n`format()` 메서드는 더 다양한 문자열 포맷팅을 가능하게 합니다.\n\n```js\nname = \"Alice\";\nage = 30;\nformatted_string = \"Name: {}, Age: {}\".format(name, age);\nprint(formatted_string);\n```\n\n결과:\n\n```js\nName: Alice, Age: 30\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 방법은 다양한 형식 요구에 유연하게 대응할 수 있도록 위치 및 키워드 인수를 포함할 수 있습니다.\n\n## f-Strings 사용하기\n\nPython 3.6에서 소개된 f-strings는 문자열 리터럴 내부에 표현식을 잘 포함하는 간결한 방법을 제공합니다.\n\n```js\nname = \"Alice\"\nage = 30\nformatted_string = f\"Name: {name}, Age: {age}\"\nprint(formatted_string)\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n결과:\n\n```js\n이름: Alice, 나이: 30\n```\n\nf-Strings는 format()보다 읽기 쉬우면서 더 빠릅니다.\n\n# 문자열 메서드\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## join()\n\njoin() 메서드는 지정된 구분자로 문자열의 이터러블을 연결하는 데 사용됩니다.\n\n```js\nwords = [\"Python\", \"is\", \"awesome\"];\nsentence = \" \".join(words);\nprint(sentence);\n```\n\n결과:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n파이썬은 멋지다\n```\n\n이 방법은 루프에서 + 연산자를 사용하는 것보다 효율적입니다.\n\n## split()\n\nsplit() 메서드는 지정된 구분기호를 사용하여 문자열을 리스트로 분할합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nsentence = \"Python is awesome\";\nwords = sentence.split(\" \");\nprint(words);\n```\n\n결과:\n\n```js\n[\"Python\", \"is\", \"awesome\"];\n```\n\n기본적으로 split()은 모든 공백을 구분자로 사용합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 문자열 변환\n\n## replace()\n\nreplace() 메서드는 문자열에서 지정된 부분 문자열을 다른 부분 문자열로 대체합니다.\n\n```js\ntext = \"Hello, world!\";\nnew_text = text.replace(\"world\", \"Python\");\nprint(new_text);\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n결과:\n\n```js\n안녕하세요, 파이썬!\n```\n\n이 방법은 원본 문자열에서 부분 문자열의 모든 발생을 대체할 수 있습니다.\n\n## translate()\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n더 복잡한 대체 작업을 위해서는 str.maketrans()와 결합된 translate()가 강력합니다.\n\n```python\ntranslation_table = str.maketrans(\"aeiou\", \"12345\")\ntext = \"Hello, world!\"\ntranslated_text = text.translate(translation_table)\nprint(translated_text)\n```\n\n결과:\n\n```python\nH2ll4, w4rld!\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 방법은 한 번의 패스로 여러 문자를 교체하는 데 유용합니다.\n\n# 고급 패턴 매칭\n\n## startswith() 및 endswith() 사용\n\n이러한 메서드는 문자열이 지정된 부분 문자열로 시작하거나 끝나는지 확인합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n텍스트 = \"Python 프로그래밍\";\nprint(텍스트.startswith(\"Python\"));\nprint(텍스트.endswith(\"프로그래밍\"));\n```\n\n결과:\n\n```js\nTrue;\nTrue;\n```\n\n이 메서드들은 간단한 패턴 매칭에 정규식을 사용하는 것보다 더 빠릅니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 문자열 정렬\n\n## ljust(), rjust(), center() 사용하기\n\n이러한 메서드들은 지정된 너비 내에서 문자열을 정렬합니다.\n\n```js\ntext = \"Python\";\nprint(text.ljust(10, \"-\"));\nprint(text.rjust(10, \"-\"));\nprint(text.center(10, \"-\"));\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n결과:\n\n```js\nPython----\n----Python\n--Python--\n```\n\n이 방법들은 텍스트 기반 UI나 보고서에서 서식이 있는 출력을 만드는 데 유용합니다.\n\n# 원치 않는 문자 제거\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## strip(), lstrip(), 그리고 rstrip()\n\n이 메서드들은 선행하거나 후행에 있는 문자들을 제거합니다.\n\n```js\ntext = \"   Python   \";\nprint(text.strip());\nprint(text.lstrip());\nprint(text.rstrip());\n```\n\n결과:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nPython;\nPython;\nPython;\n```\n\n기본적으로 이러한 메소드들은 공백을 제거하지만, 다른 문자를 지정할 수도 있어요.\n\n# 대소문자 변환\n\n## upper(), lower(), title(), capitalize()\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 메서드들은 문자열의 대소문자를 변경합니다.\n\n```js\ntext = \"python programming\";\nprint(text.upper());\nprint(text.lower());\nprint(text.title());\nprint(text.capitalize());\n```\n\n결과:\n\n```js\nPYTHON PROGRAMMING\npython programming\nPython Programming\nPython programming\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이러한 방법들은 텍스트 데이터를 정규화하는 데 유용합니다.\n\nPython에서 고급 문자열 조작을 숙달하면 텍스트를 더 효율적이고 우아하게 처리할 수 있습니다. 문자열 포맷, 메소드 및 변환을 활용하여 더 깨끗하고 강력한 Python 코드를 작성할 수 있습니다. 이 글에서 다룬 기술은 중급 Python 개발자가 익숙해져야 하는 기본 도구로, 더 복잡한 텍스트 처리 작업에 대비할 수 있는 견고한 기반을 제공합니다.\n","ogImage":{"url":"/assets/img/2024-07-09-AdvancedStringManipulationsinPython_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-AdvancedStringManipulationsinPython_0.png","tag":["Tech"],"readingTime":9},{"title":"Python 리스트 내포 List Comprehension 문법의 진정한 강점 단순한 문법 설탕이 아님","description":"","date":"2024-07-09 19:26","slug":"2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar","content":"\n아마 수많은 기사들을 보면, 파이썬에서 for-loop 대신 리스트 컴프리헨션을 사용하는 것을 권장하는 내용이 많다는 것을 이미 알아차렸을 것 같아요. 저도 많이 봤어요. 그런데 놀랍게도 그 이유에 대해 설명한 기사는 거의 찾아보기 힘들었죠.\n\n\"파이썬 다운\"이라거나 \"가독성\"과 같은 이유들만으로는 제가 같은 사람들을 쉽게 설득할 수 없을 거에요. 이런 \"이유\"들은 실제로는 파이썬 초보자들에게 잘못된 인상을 줄 수 있어요. 즉, 파이썬 리스트 컴프리헨션이 단순히 문법적 설탕에 불과하다는 거죠.\n\n사실, 리스트 컴프리헨션은 파이썬에서 큰 최적화 중 하나에요. 이 기사에서는 이러한 메커니즘에 대해 심층적으로 살펴볼 거에요. 아래 질문들에 대한 답을 얻을 수 있습니다.\n\n- 파이썬의 리스트 컴프리헨션은 무엇인가요?\n- 왜 리스트 컴프리헨션의 성능이 일반적으로 for-loop보다 우수한가요?\n- 언제 리스트 컴프리헨션을 사용해서는 안 되나요?\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 1. 간단한 성능 비교\n\n![image](/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_0.png)\n\n우리는 간단한 프로그램을 작성할 것이다. 먼저 for 루프와 리스트 컴프리헨션을 사용한 방법으로 각각의 성능을 비교해보자.\n\n```js\nfactor = 2\nresults = []\n\nfor i in range(100):\n    results.append(i * factor)\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위 코드는 100번 실행되는 for 루프를 정의합니다. range(100) 함수는 100개의 정수를 생성하고 각각은 요소와 곱해집니다. 이전에 정의된 요소는 2입니다.\n\n이제 리스트 컴프리헨션 버전을 살펴봅시다.\n\n```js\nfactor = 2\nresults = [i * factor for i in range(100)]\n```\n\n이 예제에서는 훨씬 더 쉽고 가독성이 좋습니다. 이 두 개의 동일한 코드 스니펫을 실행해보고 성능을 비교해봅시다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_1.png)\n\n결과는 리스트 컴프리헨션이 일반 for-loop보다 거의 2배 빠르다는 것을 보여줬어.\n\n놀라운 건 아무것도 없어, 많은 기사들이 이미 말해줬던 내용이야. 하지만, 이 기사에서는 리스트 컴프리헨션이 왜 더 빠른지에 대해 집중적으로 다루고 있고, 내부에서 어떤 주요 차이가 있는지에 대해 논의할 거야.\n\n이 기사의 나머지 내용을 설명할 수 있는 모든 설명의 근거와 기준을 얻기 위해, 위의 두 구현, 즉 for-loop와 리스트 컴프리헨션의 bytecode를 얻기 위해 Python 내장 dis 모듈을 사용해보자.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport dis\n\ndis.dis(\"\"\"\nfactor = 2\nresults = []\n\nfor i in range(100):\n    results.append(i * factor)\n\"\"\")\n\ndis.dis(\"\"\"\nfactor = 2\nresults = [i * 2 for i in range(100)]\n\"\"\")\n```\n\n실행 결과는 다음과 같습니다. 바이트 코드를 이해할 필요는 없습니다. 단지 바이트 코드의 \"작업\"은 \"운영 코드\" 또는 간단히 \"opcode\"라고 불립니다. 나중에 해당 내용을 참조하겠습니다.\n\n![Python List Comprehension](/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_2.png)\n\n![Python List Comprehension](/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_3.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 2. 전역 변수 대 로컬 변수\n\n![이미지](/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_4.png)\n\n가장 큰 차이점은 변수의 범위입니다. 위의 바이트 코드에서 다음과 같이 나타납니다.\n\n- for 루프의 LOAD_NAME 대 리스트 함축의 LOAD_FAST\n- for 루프의 STORE_NAME 대 리스트 함축의 STORE_FAST\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n확실하게 말씀드리자면, for-loop 버전의 변수 i는 전역 범위에 있지만, 리스트 컴프리헨션의 변수 i는 지역 범위에 있어 실행 중에만 존재합니다.\n\n## 변수의 범위(scopes)를 어떻게 확인할까요?\n\nPython, Jupyter 또는 Google Colab과 같은 노트북 환경에서 이를 쉽게 확인할 수 있습니다. 새로운 세션을 시작한 후에 for-loop 버전을 실행한 다음 %whos 매직 명령어를 실행하면 현재 세션에 정의된 모든 사용자 변수가 나열됩니다.\n\n```python\nfactor = 2\nresults = []\n\nfor i in range(100):\n    results.append(i * factor)\n```\n\n```python\n%whos\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_5.png)\n\n여기에는 for 루프가 끝난 후에도 변수 i가 여전히 남아 있는 것을 보여줍니다. 지금 global() 메소드를 실행하면 거기에도 변수 i를 찾을 수 있습니다.\n\n그러나 세션을 재시작하고 리스트 내포를 실행하면 변수 i가 표시되지 않습니다.\n\n![이미지](/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_6.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이는 변수 i가 리스트 내포 구현에서 로컬 변수임을 증명했습니다.\n\n## 왜 성능이 다를까요?\n\n작업이 전역 네임스페이스에 있는 변수에 액세스해야 할 때, 전역 네임스페이스의 모든 객체 목록을 통과해야 합니다. 전역 네임스페이스에 무엇이 있는지 궁금하다면 세션에서 globals() 메서드를 실행해 보세요.\n\n![이미지](/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_7.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n내 경우에는 Google Colab에서 새 세션을 시작했습니다. for 루프를 실행한 후 전역 네임스페이스 사전에 이미 26개의 객체가 있습니다. 더 복잡한 Python 애플리케이션을 실행한다고 상상해보면, 성능이 더 나빠질 수도 있습니다.\n\n반면에 \"로컬 변수\"는 어떤가요?\n\n안타깝게도, 리스트 내포에서 로컬 변수를 실행 중에 보여주는 것은 쉽지 않습니다. 따라서 간단한 함수를 사용하여 설명해보겠습니다. 함수 내부에 print() 메서드를 추가할 수 있기 때문이죠.\n\n```js\ndef my_function(x, y):\n    z = x + y\n    print(\"로컬 변수:\", locals())\n    return z\n\nmy_function(1, 2)\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래 예시에서 x, y 및 z는 지역 변수입니다. 컴파일 시간에는 모든 지역 변수를 보유할 배열이 생성되며 각 변수에 고정된 인덱스가 지정됩니다. 개념적으로, 지역 변수 배열은 다음과 같이 나타낼 수 있습니다:\n\n- x는 인덱스 0에 있음\n- y는 인덱스 1에 있음\n- z는 인덱스 2에 있음\n\n따라서 함수(리스트 컴프리헨션)가 지역 변수에 액세스해야 할 때는 해당 인덱스를 사용합니다. 따라서 전역 네임스페이스에서 검색하는 것과 비교했을 때 훨씬 효율적입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 변수 대비 상수\n\n변수 i를 제외하고 또 하나의 최적화는 로컬 변수 때문에 발생하고 있습니다.\n\n변수 요소에 주의해주세요. 실제로, 요소 변수를 리스트 내포 밖에서 정의했지만, 그것은 로컬 상수로 리스트 내포에 로드될 것입니다.\n\n![이미지](/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_9.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 바이트 코드에서. 변수 factor를 모든 루프에서 전역 변수로 로드해야 합니다.\n\n![image](/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_10.png)\n\n그러나 리스트 컴프리헨션에서는 컴파일러가 factor의 값을 변경할 수 없는 상수로 로드하고 지역 범위에 유지해도 충분히 안전합니다. 따라서 전역 네임스페이스에서 변수를 검색할 필요가 없습니다.\n\n물론, 이것은 리스트 컴프리헨션의 성능에 기여하는 다른 요소입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 3. 일반 메소드 vs 최적화된 메소드\n\n![image](/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_11.png)\n\n또 다른 주요한 차이점은 append() 메소드에서 나타납니다. 두 가지 구현 방법의 단계를 보여드리겠습니다.\n\nfor 루프 버전에서:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- LOAD_METHOD은 리스트 객체 결과에서 append() 메서드를 로드합니다.\n- LOAD_NAME은 변수 i를 로드합니다.\n- LOAD_NAME은 변수 factor를 로드합니다.\n- BINARY_MULTIPLY는 수학 연산을 수행합니다.\n- CALL_METHOD은 append() 메서드를 호출하여 실행하고, 즉 결과를 결과 목록에 추가합니다.\n\n리스트 컴프리헨션 버전에서:\n\n- LOAD_FAST는 로컬 변수에서 변수 i를 로드합니다.\n- LOAD_CONST는 변수 factor의 값인 상수 2를 로드합니다.\n- BINARY_MULTIPLY는 수학 연산을 수행합니다.\n- LIST_APPEND는 결과를 로컬 변수에서도 있는 목록에 추가합니다.\n\n리스트 컴프리헨션 버전의 성능이 더 우수한 이유는 단순히 한 단계가 덜 있기 때문만이 아니라 내부적인 메커니즘 때문입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## LOAD_METHOD과 LIST_APPEND가 왜 다른가요?\n\n우리는 결과 목록에서 append() 메서드를 호출합니다. 즉, results.append(...)입니다. 이를 실행할 때 Python 런타임은 List 객체 공간에서 메서드를 찾아야 합니다. 이는 객체에 대해 dir() 메서드를 호출하는 것과 거의 동일합니다.\n\n```js\nprint(dir(results));\n```\n\n<img src=\"/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_12.png\" />\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n당연히 이 \"검색\" 작업은 모든 루프에서 발생할 것입니다.\n\n그러나 리스트 내포 버전에서 결과 리스트도 로컬 변수입니다. 이 메커니즘은 리스트가 생성될 것이고, 리스트 내포 실행과 함께 만들어진다는 것입니다.\n\n비유를 들어보겠습니다. 작은 항목을 큰 컨테이너에 정리하는 것으로 상상해 보겠습니다.\n\nfor 루프 버전은 append() 메서드를 사용하는 것이 매번 우리가 항목과 상자를 다른 사람에게 주고, 이 사람이 항목을 넣은 후에 우리에게 컨테이너를 다시 돌려주는 것처럼합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n리스트 내포 버전을 사용하면 다른 사람의 도움 없이 항목을 컨테이너에 넣을 수 있어요. 따라서 성능도 훨씬 좋아요.\n\n# 4. 리스트 내포를 사용해서는 안 되는 경우\n\n![Python List Comprehension](/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_13.png)\n\n물론, 리스트 내포는 남용해서는 안 돼요. 다시 말해, 사용은 가능하지만 특정 상황에서는 사용해서는 안 되는 경우가 있어요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n한 가지 전형적인 시나리오는 필터 조건이 너무 복잡하다는 것입니다. 다음 예를 고려해보세요. 학생들의 이름과 시험 점수가 들어있는 튜플 목록이 있습니다.\n\n```js\nstudents = [(\"Alice\", 85), (\"Bob\", 95), (\"Cindy\", 100), (\"David\", 65), (\"Eva\", 70)];\n```\n\n그런 다음, 특정 조건에 따라 이름을 필터링하려고 합니다. 점수는 80보다 커야하고, 이름은 \"A\" 또는 \"C\"로 시작해야 합니다. 아래는 for 루프 구현입니다.\n\n```js\nfiltered_names = []\n\nfor name, score in students:\n    if score > 80 and name.startswith((\"A\", \"C\")):\n        filtered_names.append(name)\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기에 리스트 컴프리헨션 구현방법이 있습니다.\n\n```js\nfiltered_names = [name for name, score in students if score > 80 and name.startswith((\"A\", \"C\"))]\n```\n\n<img src=\"/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_14.png\" />\n\n음, 리스트 컴프리헨션의 성능은 여전히 for 루프보다 조금 더 나은 편이에요. 그러나 복잡한 조건 때문에 리스트 컴프리헨션은 가독성이 많이 떨어지기 시작했다고 말씀드려야 할 것 같아요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n가독성과 디버깅 유연성을 희생해서 성능을 조금 향상시키는 것이 매우 주관적일 수 있습니다. 결정은 여러분에게 맡기겠습니다. :)\n\n# 요약\n\n![이미지](/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_15.png)\n\n이 글에서는 리스트 컴프리헨션의 성능이 일반 for-loop보다 우수한 이유에 대해 소개했습니다. 그것이 단순히 구문적인 설탕이 아니라 성능 최적화임을 증명했습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n두 구현의 바이트 코드를 표시하여 증거가 발굴되었습니다. 주요 차이점은 지역 vs. 전역 네임스페이스와 일반 메서드 vs. 최적화된 메서드입니다.\n\n물론, 모든 시나리오에서 리스트 내포를 사용하는 것이 권장되지는 않습니다. 예를 들어, 조건이 매우 많은 계층과 보다 복잡한 조건을 갖는 경우입니다. 여전히 리스트 내포를 사용할 가치가 있는지 고려해야 합니다.\n","ogImage":{"url":"/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_0.png","tag":["Tech"],"readingTime":14},{"title":"파이썬 코드로 알아보는 제품-시장 적합성 계량 분석 방법","description":"","date":"2024-07-09 19:23","slug":"2024-07-09-AQuantitativeApproachtoProductMarketFitPythonCode","content":"\n어느 때는 씨앗 벤처 투자 회사의 데이터 부서에서 일한 적이 있었어요. 저는 VC 펀드에서 일한 적이 있었는데, 그 중 하나는 창업가들과 그들의 비즈니스에서 제품-시장 적합성의 지표에 대해 논의하는 것이었습니다. Andrew Chen의 제품 시장 적합성에 대한 정량적 접근을 적용했었죠. 처음에 우리는 창업가들과 제품 시장 적합성의 지표에 대해 논의하고 그들의 사용자들의 원시 데이터를 요청했어요. 그런 다음 데이터를 분석해서 서로 다른 사용자들과 그들의 행동이 시간에 따라 어떻게 변하는지 파악했어요.\n\n그 정량적 방법론에는 주로 두 가지 유형의 표현이 있습니다: 성장 회계 및 코호트 분석입니다. 창업기업에서는 원시 데이터가 보통 엉망이기 때문에 데이터를 맞추기 위해 모든 것을 다시 코딩해야 했어요. 그렇지만 몇 주 전에 옛 노트북을 먼지 털었어요. 시간이 흘러고 관점이 바뀌면서 해당 프레임워크를 일반화하고 사용하기 쉬운 Python 객체를 만들기로 결정했어요. 그렇게 하면 데이터를 정리하고 준비하는 일만 남을 거예요. 시각화는 이미 완료된 상태예요!\n\n두 가지 객체를 코딩했어요: 성장 회계용 하나와 코호트용 하나요. 이 두 객체는 기계 학습 스타일로 구축되었기 때문에 매개변수를 설정하고 데이터로 객체를 적합시킨 다음 결과 및 시각화를 요청할 수 있어요. 제품-시장 적합성 프레임워크의 분산은 구축되지 않았는데, 단순화에는 도움이 되지 않을 것 같아요.\n\n본 기사에서는 Spot the Lion 앱의 두 데이터셋을 사용하여 코드를 설명할 거예요. 이는 설명 목적으로 만든 가상 앱이에요. 더 많은 정보는 여기에서 확인할 수 있어요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모든 이미지는 별도로 언급되지 않는 한 저자가 만들었습니다. 또한 제가 사용할 두 개의 데이터 세트가 있습니다. 이 유즈 케이스, 참고문헌 및 두 데이터 세트가 포함된 코드 저장소는 여기에 있습니다.\n\n# 먼저 해야 할 일\n\n간편하게 하기 위해 제품 시장 적합성을 PMF로 줄여 쓰고, PMF 단위를 측정하려는 사용자의 활동을 의미하는 것으로 부르겠습니다.\n\n예를 들어, 앱을 사용하는 사용자의 행동을 평가하려면 PMF 단위는 총 상호작용 (사용자별)이 될 것이며, 앱의 각 상호작용을 포함하는 데이터 세트가 필요합니다. 즉, 각 행에는 사용자 및 날짜가 포함되어야 합니다. 이 유형의 PMF 단위는 간단하다고 부르는데, PMF 단위를 숫자로 측정하기 때문입니다 (상호작용의 수를 세는 것). 그래서 오브젝트는 날짜와 해당 작업을 실행한 사용자의 ID 두 개의 열만 필요합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다른 PMF 유닛으로는 사용자가 소비한 금액이 될 수 있습니다. 이 경우 앱에서 모든 결제가 포함된 데이터셋이 필요합니다. 사용자, 날짜 및 수량이 포함되어야 합니다. 수량을 합산할 Quantity 열이 필요하기 때문에 이 유형의 PMF 유닛은 간단하지 않습니다.\n\n이러한 정의는 Andrew Chen이 제시한 PMF의 양적 접근에서 프레임워크를 일반화하여 선택된 PMF 유닌과 관련된 개념을 자유롭게 다룰 수 있게 해줍니다. 성장 회계 및 코호트 두 프레임워크 모두 이러한 일반화를 활용합니다.\n\n코드는 세 개의 파일로 구성되어 있습니다:\n\n- aux.py: 날짜 처리 함수를 포함합니다.\n- growth_accounting_pmf.py: GrowthAccounting 객체가 포함되어 있습니다.\n- cohorts_pmf.py: Cohorts 객체와 일부 보조 함수가 포함되어 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n라이브러리로는 copy, datetime, numpy, pandas, matplotlib.pyplot 및 seaborn을 사용하여 구성되었어요.\n\n```js\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport datetime as dt\nimport numpy as np\nimport seaborn as sns\n\nfrom growth_accounting_pmf import GrowthAccounting\nfrom cohorts_pmf import Cohorts\n```\n\n이 객체의 구현과 작동 방식에 대한 모든 내용은 그들의 독스트링에 있어요. (독스트링을 좋아해서, 통찰력이 있는 독스트링을 만드는 데 많은 시간을 보냈어요! 도움이 되면 좋겠어요!).\n\n# 성장 회계\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n성장 회계 프레임워크는 사용자를 PMF 유단위 행동으로 태깅한 다음 그 진화를 살펴보는 것을 목표로 합니다.\n\n태그는 비즈니스에 부정적일 수 있습니다: 이탈, 축소; 비즈니스에 유리한 경우: 신규, 부활; 또는 비즈니스에 긍정적인 경우: 유지, 확장. 이러한 태그의 시간 분석을 통해 PMF 유단위의 행동을 이해할 수 있습니다. 이 분석은 B2B 또는 계약 비즈니스의 수익을 위한 것이 일반적이지만, 일반화를 통해 앱의 모든 작업에 대한 진화를 분석하는 데도 사용할 수 있습니다.\n\nGrowthAccounting은 두 개의 매개변수로 구성되어 있습니다:\n\n- period: 'Q', 'q', 'M', 'm', '28D', '28d', '7D', '7d', 'D', 'd' 중 하나입니다. 데이터를 분할할 기간을 나타내는 문자입니다. 기본값: 월간.\n- simple: bool. PMF 유닛이 간단한지 여부를 나타내는 불리언 값이며, 이는 상호 작용을 단순히 계산해야 하는지(simple) 아니면 수량 열이 필요한지(not simple) 여부를 말합니다. 기본값: simple.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그럼 데이터를 담고 있는 객체를 맞춰야 해요:\n\n- data: 각 행이 PMF 유당의 작업을 나타내는 판다스 데이터프레임입니다. 적어도 사용자 ID를 나타내는 열과 작업 날짜를 나타내는 다른 열이 있어야 합니다. 간단한 PMF 유당이 아닌 경우 양을 나타내는 열이 하나 더 필요합니다.\n- column_date: 문자열. 데이터에서 날짜를 나타내는 열의 이름입니다. 날짜 형식이어야 합니다.\n- column_id: 문자열. 데이터에서 사용자 ID를 나타내는 열의 이름입니다.\n- column_input: 문자열. 데이터에서 양을 나타내는 열의 이름입니다. 기본값은 없습니다.\n\n데이터로 맞춘 후에 객체는 (주어진 PMF 유당 및 기간에 대해) 새로운, 총계, 부활, 확장, 축소, 유지 및 탈당 사용자를 계산합니다. 또한 이러한 특성의 비율, 성장률, 총 보유율, 빠른 비율 및 순 탈당도를 계산합니다.\n\n객체를 맞춘 후에는 데이터 및 시각화를 요청하기만 하면 됩니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- df: 판다 데이터프레임입니다. 위에서 계산한 모든 열이 포함되어 있습니다.\n- plot: Accounting for Growth 시각화를 플롯합니다.\n- plot_compound_growth(period): 복리 성장을 계산하기 위해 기간이 필요하며 그 후 시각화를 플롯합니다.\n\n알겠습니다. 이 방법이 조금 어려운 것 같네요. 두 가지 예제를 살펴보겠습니다.\n\n## 간단한 PMF 단위의 Accounting for Growth 예시: 총 사용자 상호 작용\n\nspot_the_lion_user_activity_2023.csv 데이터 세트를 사용하겠습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nimport pandas as pd\nactivity = pd.read_csv('spot_the_lion_user_activity_2023.csv')\nactivity['date'] = pd.to_datetime(activity['date'])\nactivity.head()\n```\n\n![Python Code](/TIL/assets/img/2024-07-09-AQuantitativeApproachtoProductMarketFitPythonCode_0.png)\n\nWe have three columns: date, user_id, and action. However, to count total interactions, we only need the date and the user_id. Also, we choose a monthly period.\n\n```python\nuser_growth = GrowthAccounting(period='M')\nuser_growth.fit(activity, 'date', 'user_id')\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n적절한 시간은 데이터 양에 따라 다릅니다. 그럼 데이터프레임을 확인할 수 있습니다 (테이블 전체를 보려면 Jupyter Notebook으로 이동하세요).\n\n```js\nuser_growth.df;\n```\n\n이제 그래프를 그릴 수 있습니다.\n\n```js\nuser_growth.plot();\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/TIL/assets/img/2024-07-09-AQuantitativeApproachtoProductMarketFitPythonCode_1.png\" />\n\n```js\nuser_growth.plot_compound_growth(3);\n```\n\n그게 다에요!\n\n## 단순하지 않은 PMF 단위의 성장 고려: 사용자별 수익\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 경우, 앱 내 각 지불을 포함하는 다른 데이터셋을 사용할 것입니다. 이 데이터셋은 spot_the_lion_revenue_2023.csv입니다.\n\n```python\nrevenue=pd.read_csv('spot_the_lion_revenue_2023.csv')\nrevenue['date']=pd.to_datetime(revenue['date'])\nrevenue.head()\n```\n\n![이미지](/TIL/assets/img/2024-07-09-AQuantitativeApproachtoProductMarketFitPythonCode_2.png)\n\n여기에는 세 개의 열이 있으며 모두 필요합니다: date, user_id 및 revenue. 또한, 이 분석이 매월 이루어지고 간단하지 않다고 지정해야 합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nrev_growth = GrowthAccounting((period = \"M\"), (simple = False));\nrev_growth.fit(revenue, \"date\", \"user_id\", \"revenue\");\n```\n\n한번 그려보세요.\n\n```js\nrev_growth.plot();\n```\n\n<img src=\"/TIL/assets/img/2024-07-09-AQuantitativeApproachtoProductMarketFitPythonCode_3.png\" />\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nrev_growth.plot_compound_growth(3);\n```\n\n이것들은 기본 분석입니다. 그러나 선택한 PMF 단위(및 데이터 품질에 따라)에 따라 다양한 정보를 얻을 수 있습니다. 이 예시에서는 앱에서 사자를 확인한 사용자들을 대상으로 성장 회계(Growth Accounting)를 살펴볼 수 있습니다 (모든 상호작용이 아닌). 또한 데이터 세트를 id로 병합하고 앱과 두 번 상호작용하는 사용자별로 세분화된 수익을 찾을 수도 있습니다 (모르겠지만, 이제 당신의 차례입니다!).\n\n만약 여전히 이 차트들이 무엇인지 모르거나 축소, 확장, 이탈 등을 들어본 적이 없다면... 시간을 낭비하지 말고 먼저 Andrew Chen의 Quantitative Approach to Product Market Fit를 읽으세요!\n\n# 코호트(Cohorts)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nCohort Framework은 제품과 상호 작용하기 시작한 시점에 따라 사용자를 그룹화한 후 시간에 따른 PMF 단위의 진화를 볼 수 있는 목표를 가지고 있어요.\n\n많은 사람들이 코호트 분석이 복잡하다고 생각하는데요. 이 기회를 주시면 좋겠어요. 코호트 분석을 통해 사용자들의 PMF 단위의 진화를 병행 분석할 수 있어요. 제품 코호트가 20% 감소한다면 참여도가 없다는 것이라고 하더라고요! 사용자를 잃고 있는 거예요!\n\n코호트 객체는 두 개의 매개변수로도 구축됩니다:\n\n- 기간: '‘Q’, ’q’, ’M’, ’m’, ’28D’, ’28d’, ’7D’, ’7d’, ’D’, ’d’'. 데이터를 나눌 기간을 나타내는 문자입니다. 기본값: 월별.\n- 간단함: 부울. PMF 단위가 간단한지 여부를 나타내며, 상호 작용을 단순히 계산해야하는지 (간단) 또는 값을 합산해야하는 열이 필요한지 (복잡하지 않음)를 나타냅니다. 기본값: 간단함.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러면 Accounting for Growth와 동일한 내용을 포함하도록 데이터가 있는 객체를 맞춰야 합니다. 다만, 종류가 있는 코호트를 명시해야 합니다.\n\n- data: 각 행이 PMU 단위의 작업을 나타내는 판다 데이터프레임. 적어도 사용자 ID를 나타내는 열과 날짜를 나타내는 열이 있어야 합니다. 간단한 PMF 단위가 아닌 경우, 수량을 나타내는 열도 필요합니다.\n- column_date: 문자열. 데이터에서 날짜를 나타내는 열의 이름. 날짜 형식은 datetime이어야 합니다.\n- column_id: 문자열. 데이터에서 사용자 ID를 나타내는 열의 이름.\n- column_input: 문자열. 데이터에서 수량을 나타내는 열의 이름. 기본값은 없음입니다.\n- how: 문자열 목록. '‘total’, ’churn_total’, ’unique_users’, ‘churn_unique_users’, ’accum’, ‘per_user’ 중 하나 이상을 포함해야 합니다. 'Total'은 코호트의 모든 PMF 단위를 계산하는 것을 의미합니다. 'Churn total'은 Total의 음수입니다. 'Unique users'는 제품과 상호작용하는 모든 고유 사용자 수를 계산하는 것을 의미합니다. 'Churn unique users'는 Unique users의 음수입니다. 'Accum'은 시간에 따라 누적 PMF 단위를 계산합니다. 수명 가치에 사용하기 위해 고안되었습니다. 'Per user'는 사용자별로 PMF 단위의 평균을 계산합니다.\n\n객체를 맞춘 후 코호트를 시각화하기 위해 계산된 모든 값이 있습니다. 두 가지 클래식 시각화가 있습니다: 숫자로만 표시되는 것과 백분율로 표시되는 것입니다. 따라서 how 매개변수에 지정된 값은 숫자와 백분율 둘 다 계산됩니다.\n\n그럼 이제 데이터와 시각화를 요청하기만 하면 됩니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- df_cohorts: 데이터프레임. 코호트를 시각화하는 데 필요한 모든 열을 포함합니다.\n- plot_heatmap(label, title, way): 일반적인 코호트 히트맵을 그립니다. 열과 차트 제목, 방법이 필요합니다. 방법은 \"period\" 또는 \"period_num\"일 수 있습니다. \"period\"의 경우 코호트를 기간에 맞추고, \"period_num\"의 경우 모든 코호트의 첫 번째 기간을 정렬한 후 두 번째, 그리고 그 이후로 이어집니다.\n- plot_trend(label, title, way): 각 코호트에 대한 선 그래프를 그립니다. 히트맵과 동일한 매개변수를 사용합니다.\n\n알겠어요, 알겠어요. 예제 없이는 모두 조금 어렵죠. 하지만 진행하기 전에, PMF 유닛의 다양성을 측정하고 싶다면 자체 유형의 코호트를 생성하는 함수도 만들었어요.\n\n- apply_personalized(df_cohorts, column_label): \"df_cohorts\"는 self.df_cohorts와 동일한 구조를 가진 데이터프레임입니다. \"기간\"과 \"코호트\"를 위한 열이 있어야 합니다. 그런 다음 새로운 코호트의 \"column_label\"입니다.\n\n두 가지 예제를 살펴보겠습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 간단한 PMF 단위의 사용자 상호 작용을 위한 코호트\n\n우리는 데이터 집합 spot_the_lion_user_activity_2023.csv을 다시 사용할 것입니다.\n\n```js\nactivity = pd.read_csv(\"spot_the_lion_user_activity_2023.csv\");\nactivity[\"date\"] = pd.to_datetime(activity[\"date\"]);\n```\n\n본 분석에서는 월 단위로 기간을 설정하고 \"accum\" 이외의 모든 코호트 유형과 맞출 것입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nusers_cohort=Cohorts(period='M')\nusers_cohort.fit(activity,'date','user_id',how=['total','churn_total','unique_users','churn_unique_users','per_user'])\n```\n\nThe dataframe generated is as follows.\n\n```python\nusers_cohort.df_cohorts.head()\n```\n\nHere, you can see that every column has a “perc” column with the percentage. Now, we can plot two heatmaps and a trend chart for every type of cohort.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n총 상호 작용.\n\n```js\nusers_cohort.plot_heatmap(\"total\", \"총 상호 작용\", (way = \"period\"));\nusers_cohort.plot_heatmap(\"perc_total\", \"총 상호 작용\", (way = \"period_num\"));\nusers_cohort.plot_trends(\"perc_total\", \"활동 유지\", (way = \"period_num\"));\n```\n\n고유 사용자.\n\n```js\nusers_cohort.plot_heatmap(\"unique_users\", \"사용자\", (way = \"period\"));\nusers_cohort.plot_heatmap(\"perc_unique_users\", \"사용자\", (way = \"period_num\"));\nusers_cohort.plot_trends(\"perc_unique_users\", \"로고 유지\", (way = \"period_num\"));\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n사용자 이탈.\n\n```js\nusers_cohort.plot_heatmap(\"churn_unique\", \"사용자 이탈\", (way = \"period\"));\nusers_cohort.plot_heatmap(\"perc_churn_unique\", \"사용자 이탈\", (way = \"period_num\"));\n```\n\n사용자별 상호작용.\n\n```js\nusers_cohort.plot_heatmap(\"per_user\", \"월별 사용자별 상호작용\", (way = \"period\"));\nusers_cohort.plot_heatmap(\"perc_per_user\", \"월별 사용자별 상호작용\", (way = \"period_num\"));\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위에서 보듯이 나는 일반 숫자 코호트에는 period 방식을 항상 사용하고 백분율에는 period_num 방식을 사용합니다. 또한 트렌드에 대해서는 일반적으로 백분율과 period_num 방식을 사용합니다. 다른 시각화 방법을 시도해볼 수도 있지만, 그것들은 실제로 통찰력이 부족한 것 같아요.\n\n우리만의 메트릭을 준비해봅시다: 다양성.\n\n먼저, 호환되는 데이터셋을 준비해야합니다.\n\n```js\nnew_df = users_cohort.df_period_cohort;\nnew_df[\"cohort\"] = pd.to_datetime(new_df[\"cohort\"]);\nnew_df[\"period\"] = pd.to_datetime(new_df[\"period\"]);\nnew_df = new_df\n  .groupby([\"cohort\", \"period\", \"user_id\"])\n  [[\"action\"]].nunique()\n  .rename((columns = { action: \"variety\" }));\nnew_df = new_df.reset_index().groupby([\"cohort\", \"period\"])[[\"variety\"]].mean().reset_index();\nnew_df.head();\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/TIL/assets/img/2024-07-09-AQuantitativeApproachtoProductMarketFitPythonCode_4.png\" />\n\n그러면 이제 코호트를 적용하고 시각화할 수 있어요.\n\n```js\nusers_cohort.apply_personalized(new_df, \"variety\");\nusers_cohort.plot_heatmap(\"variety\", \"사용자별 상호작용 다양성\", (way = \"period\"));\n```\n\n<img src=\"/TIL/assets/img/2024-07-09-AQuantitativeApproachtoProductMarketFitPythonCode_5.png\" />\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 소득에 대한 비닝심플 PMF 유닛의 코호트\n\n우리는 spot_the_lion_revenue_2023.csv 데이터셋을 사용할 것입니다.\n\n```python\nrevenue=pd.read_csv('spot_the_lion_revenue_2023.csv')\nrevenue['date']=pd.to_datetime(revenue['date'])\n```\n\n이 분석에서 우리는 월간 기간과 단순하지 않은 매개변수를 사용할 것입니다. 그런 다음 \"unique_users\"를 제외한 모든 코호트 유형과 적합합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nrevenue_cohort=Cohorts(period='M',simple=False)\nrevenue_cohort.fit(revenue,'date','user_id','revenue',how=['total','churn_total','accum','per_user'])\n```\n\n이제 각각의 코호트 유형에 대해 두 개의 히트맵과 추이 차트를 그릴 수 있습니다.\n\n총 수익.\n\n```python\nrevenue_cohort.plot_heatmap('total','총 수익','way='period')\nrevenue_cohort.plot_heatmap('perc_total','총 수익','way='period_num')\nrevenue_cohort.plot_trends('perc_total','수익 유지율','way='period_num')\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n한 명당 수익.\n\n```js\nrevenue_cohort.plot_heatmap(\"per_user\", \"한 명당 수익\", (way = \"period\"));\nrevenue_cohort.plot_heatmap(\"perc_per_user\", \"한 명당 수익\", (way = \"period_num\"));\n```\n\n코호트별 수명 가치.\n\n```js\nrevenue_cohort.plot_heatmap(\"accum\", \"코호트 LTV\", (way = \"period\"));\nrevenue_cohort.plot_trends(\"accum\", \"코호트 LTV\", (way = \"period_num\"));\nrevenue_cohort.plot_trends(\"accum\", \"코호트 LTV\", (way = \"age\"));\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 경우의 마지막 차트는 조금 특별합니다. 연령대별로 플롯을 그릴 때는 각 날짜별 코호트의 주기 수에 따라 그룹화됩니다. 파란 선은 앱에서의 코호트의 첫 번째 기간에 누적된 총계를 나타냅니다. 주황색 선은 코호트가 두 번째 기간에 누적한 총계를 나타내고... 이어서 나갑니다.\n\n# 개요\n\n스타트업에서 제품-마켓 적합성을 평가하는 것은 쉬운 일이 아닙니다. 몇 년 전에 투자가인 앤드류 첸은 사용자 행동을 더 잘 이해하기 위해 사용할 수 있는 양적 접근 방식을 제안했습니다. 그는 대부분 B2B 스타트업의 매출을 사용했지만, 어떤 유형의 스타트업에도 일반화될 수 있다고 생각합니다. 최적 지표를 선택하기만 하면 됩니다.\n\n제품-마켓 적합성은 여러분의 앱에서 실제로 사용자들이 여러분의 앱을 사용한다는 것을 의미합니다. 레시피 공유를 위한 C2C 마켓플레이스인 경우 사용자별 상호작용이 많을수록 기울어지게 됩니다. 업로드된 레시피, 댓글이 달린 레시피, 공유된 레시피 등이 지표가 될 수 있습니다. 이를 PMF(제품-마켓 적합성) 단위라고 부르며, 저가 구축한 Python 객체로 평가할 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파이썬을 선택한 이유는 주피터 노트북과 그의 다양성 때문이에요. 머신러닝 스타일로 만들어져서 데이터를 맞추고 결과와 시각화를 요청하기만 하면 되기 때문이죠. 위의 예시가 프레임워크를 더 잘 이해하도록 도움이 되기를 바라요.\n\n의견을 남겨주세요. 유용하게 사용하고 있는지 저에게 말씀해주세요. 개선에 열정적으로 참여하겠어요!\n\n# 진행할 단계\n\n- Andrew Chen의 제품 시장 적합성에 대한 정량적 접근서를 읽어보세요.\n- 제 깃허브에서 코드를 다운로드하세요.\n- 주피터 노트북의 사용 사례를 실험해보세요.\n- PMF(unit)를 결정하고 데이터셋을 준비하여 자신의 목적에 활용하세요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마크다운 형식으로 테이블 태그를 변경해보세요! ;)\n","ogImage":{"url":"/assets/img/2024-07-09-AQuantitativeApproachtoProductMarketFitPythonCode_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-AQuantitativeApproachtoProductMarketFitPythonCode_0.png","tag":["Tech"],"readingTime":20},{"title":"iTransformer 최신 시계열 예측 기법 대공개","description":"","date":"2024-07-09 19:21","slug":"2024-07-09-iTransformerTheLatestBreakthroughinTimeSeriesForecasting","content":"\n![2024-07-09-iTransformerTheLatestBreakthroughinTimeSeriesForecasting](/TIL/assets/img/2024-07-09-iTransformerTheLatestBreakthroughinTimeSeriesForecasting_0.png)\n\n예측 분야에서는 Lag-LLaMA, Time-LLM, Chronos, Moirai와 같은 모델들이 2024년 초부터 제안되어 기초 모델 분야에서 많은 활동을 보이고 있습니다.\n\n그러나 이러한 모델들의 성능은 조금 아쉬운 면이 있습니다 ([재현 가능한 벤치마크를 보려면 여기를 참조하십시오](여기)) 그리고 저는 데이터 특화 모델이 여전히 현재 최적의 해결책이라고 믿습니다.\n\n이에 따라 Transformer 아키텍처가 다양한 형태로 시계열 예측에 적용되어왔으며, PatchTST는 장기 예측에서 최고 수준의 성능을 달성하였습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n도전적인 PatchTST에 이어 2024년 3월에 제안된 iTransformer 모델이 등장했습니다. 논문 \"iTransformer: Inverted Transformers Are Effective for Time Series Forecasting\"에서 소개되었습니다.\n\n이 기사에서는 iTransformer의 놀라운 간단한 개념을 발견하고 그 아키텍처를 탐구합니다. 그런 다음 해당 모델을 소규모 실험에 적용하고 그 성능을 TSMixer, N-HiTS 및 PatchTST와 비교합니다.\n\n더 자세한 내용은 원본 논문을 읽어보세요.\n\n시작해봅시다!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# iTransformer 탐색\n\niTransformer의 아이디어는 바닐라 Transformer 모델이 시간 토큰을 사용한다는 깨달음에서 나왔어요.\n\n이것은 모델이 단일 시간 단계에서 모든 특징을 살펴본다는 것을 의미합니다. 그래서 모델이 한 번에 한 시간 단계씩 살펴볼 때 시간 의존성을 학습하는 것이 어려울 수 있어요.\n\n그 문제에 대한 해결책은 PatchTST 모델과 함께 제안된 패칭이에요. 패칭을 사용하면 토큰화하고 임베딩하기 전에 시간 지점을 단순히 그룹화할 수 있어요. 아래에서 보여준 것처럼요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![iTransformer image 1](/TIL/assets/img/2024-07-09-iTransformerTheLatestBreakthroughinTimeSeriesForecasting_1.png)\n\nIn iTransformer, we push patching to the extreme by simply applying the model on the inverted dimensions.\n\n![iTransformer image 2](/TIL/assets/img/2024-07-09-iTransformerTheLatestBreakthroughinTimeSeriesForecasting_2.png)\n\nIn the figure above, we can see how the iTransformer differs from the vanilla Transformer. Instead of looking at all features at one time step, it looks at one feature across many time steps. This is done simply by inverting the shape of the input.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이렇게하면 어텐션 레이어가 다변량 상관 관계를 학습하고 피드포워드 네트워크가 전체 입력 시퀀스의 표현을 인코딩합니다.\n\niTransformer의 일반 아이디어를 이해했으니, 이제 더 자세히 살펴보겠습니다.\n\n## iTransformer의 아키텍처\n\niTransformer는 2017년에 Attention Is All You Need에서 처음으로 제안된 임베딩, 프로젝션 및 트랜스포머 블록을 사용한 바닐라 인코더-디코더 아키텍처를 채택합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 그림에서 건물 블록들은 동일하지만 기능은 완전히 다르다는 것을 볼 수 있습니다. 좀 더 자세히 살펴보겠습니다.\n\n임베딩 레이어\n\n먼저, 입력 시리즈는 독립적으로 토큰으로 임베딩됩니다. 다시 말해서, 이는 입력의 서브시퀀스를 토큰화하는 대신, 모델이 전체 입력 시퀀스를 토큰화하는 극단적인 경우와 같습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다변량 주의력\n\n그런 다음, 임베딩은 주의층으로 전송되어 다변량 상관 맵을 학습할 것입니다.\n\n이는 역전 모델이 각 특징을 독립된 프로세스로 간주하기 때문에 가능합니다. 이러한 결과로 주의 메커니즘은 특징들 사이의 상관 관계를 학습하게 되며, 이로써 iTransformer는 특히 다변량 예측 작업에 적합합니다.\n\n층 정규화\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n어텐션 레이어의 출력은 정규화 레이어로 전송됩니다.\n\n전통적인 트랜스포머 아키텍처에서는 정규화가 모든 특성에 대해 고정된 타임스탬프에서 이루어집니다. 이는 모델이 쓸모없는 관계를 학습하게 될 수 있는 상호작용 소음을 도입할 수 있습니다. 또한, 지나치게 매끄러운 신호를 초래할 수 있습니다.\n\n반면, iTransformer는 차원을 뒤집으므로 정규화가 타임스탬프를 횡단하여 이루어집니다. 이는 모델이 비정상적인 시계열에 대처하도록 도와주며, 시계열의 소음을 줄여줍니다.\n\n피드포워드 네트워크\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마지막으로, 피드 포워드 네트워크(FFN)는 들어오는 토큰의 깊은 표현을 학습합니다.\n\n다시 말해서, 모양이 반전되어 있기 때문에 다층 퍼셉트론(MLP)은 주기성이나 진폭과 같은 다른 시계열 속성을 학습할 수 있습니다. 이는 MLP 기반 모델(N-BEATS, N-HiTS, TSMixer 등)의 능력을 모방합니다.\n\n프로젝션\n\n여기서 간단히 많은 블록을 쌓는 것으로 이루어진 단계입니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 주의 층\n- 계층 정규화\n- 피드포워드 네트워크\n- 계층 정규화\n\n각 블록은 입력 시리즈의 다른 표현을 학습합니다. 그런 다음, 블록 스택의 출력은 최종 예측을 얻기 위해 선형 투사 단계를 거쳐 전송됩니다.\n\n요약하자면, iTransformer는 새로운 아키텍처가 아니며 Transformer를 새롭게 만들어내지는 않습니다. 단순히 입력의 역된 차원에 Transformer를 적용하여 모델이 다변량 상관 관계를 학습하고 시간적 특성을 포착할 수 있도록 합니다.\n\n이제 iTransformer 모델에 대한 깊은 이해를 갖고 작은 예측 실험에서 적용해 보겠습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# iTransformer를 사용한 예측\n\n이 작은 실험에서는 Creative Commons 라이선스로 공개된 전기 변압기 데이터셋에 iTransformer 모델을 적용합니다.\n\n중국 한 성의 두 지역에서 전기 변압기의 오일 온도를 추적하는 인기 있는 벤치마크 데이터셋입니다. 두 지역 모두 1시간마다 샘플링된 데이터셋을 가지고 있으며, 15분마다 샘플링된 데이터셋이 있어 총 네 개의 데이터셋이 있습니다.\n\niTransformer는 근본적으로 다변량 모델이지만, 우리는 96개의 시간 단계에 걸친 일변량 예측 능력을 테스트합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 실험에 대한 코드는 GitHub에서 확인할 수 있어요.\n\n자, 시작해봅시다!\n\n초기 설정\n\n이 실험에서는 neuralforecast라는 라이브러리를 사용하는데, 이 라이브러리가 딥러닝 방법의 가장 빠르고 직관적인 사용 가능한 구현을 제공한다고 믿습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfrom datasetsforecast.long_horizon import LongHorizon\n\nfrom neuralforecast.core import NeuralForecast\nfrom neuralforecast.models import NHITS, PatchTST, iTransformer, TSMixer\n```\n\n본 글을 작성하는 시점에서 iTransformer가 아직 neuralforecast의 공개 릴리스에 포함되지 않았음을 참고하세요. 즉시 해당 모델에 액세스하려면 다음을 실행하세요:\n\n```js\npip install git+https://github.com/Nixtla/neuralforecast.git\n```\n\n이제 ETT 데이터셋을로드하고, 검증 크기, 테스트 크기, 그리고 주기를 포함하는 함수를 작성해봅시다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ndef load_data(name):\n    if name == \"ettm1\":\n        Y_df, *_ = LongHorizon.load(directory='./', group='ETTm1')\n        Y_df = Y_df[Y_df['unique_id'] == 'OT']\n        Y_df['ds'] = pd.to_datetime(Y_df['ds'])\n        val_size = 11520\n        test_size = 11520\n        freq = '15T'\n    elif name == \"ettm2\":\n        Y_df, *_ = LongHorizon.load(directory='./', group='ETTm2')\n        Y_df = Y_df[Y_df['unique_id'] == 'OT']\n        Y_df['ds'] = pd.to_datetime(Y_df['ds'])\n        val_size = 11520\n        test_size = 11520\n        freq = '15T'\n    elif name == 'etth1':\n        Y_df, *_ = LongHorizon.load(directory='./', group='ETTh1')\n        Y_df['ds'] = pd.to_datetime(Y_df['ds'])\n        val_size = 2880\n        test_size = 2880\n        freq = 'H'\n    elif name == \"etth2\":\n        Y_df, *_ = LongHorizon.load(directory='./', group='ETTh2')\n        Y_df['ds'] = pd.to_datetime(Y_df['ds'])\n        val_size = 2880\n        test_size = 2880\n        freq = 'H'\n\n    return Y_df, val_size, test_size, freq\n```\n\nThe above function conveniently loads the data in the required format for neuralforecast. It includes a unique_id column to identify time series, a ds column for timestamps, and a y column for series values.\n\nPlease note that the validation and test sizes align with standards in the scientific community for publishing research papers.\n\nWe are all set to start training the models.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 훈련 및 예측\n\niTransformer 모델을 훈련시키기 위해서는 단순히 다음을 지정해주면 됩니다:\n\n- 예측 기간\n- 입력 크기\n- 시리즈 수\n\niTransformer가 본질적으로 다변량 모델이기 때문에 모델을 적합할 때 시리즈 수를 지정해야 합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n단변량 시나리오이므로 n_series=1입니다.\n\n```js\niTransformer(\n  (h = horizon),\n  (input_size = 3 * horizon),\n  (n_series = 1),\n  (max_steps = 1000),\n  (early_stop_patience_steps = 3)\n);\n```\n\n위의 코드 블록에서는 최대 학습 단계 수를 지정하고, 과적합을 방지하기 위해 조기 중지를 3번 반복으로 설정합니다.\n\n나머지 모델들에 대해 같은 작업을 수행한 후, 리스트에 넣어줍니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nhorizon = 96;\n\nmodels = [\n  iTransformer(\n    (h = horizon),\n    (input_size = 3 * horizon),\n    (n_series = 1),\n    (max_steps = 1000),\n    (early_stop_patience_steps = 3)\n  ),\n  TSMixer(\n    (h = horizon),\n    (input_size = 3 * horizon),\n    (n_series = 1),\n    (max_steps = 1000),\n    (early_stop_patience_steps = 3)\n  ),\n  NHITS((h = horizon), (input_size = 3 * horizon), (max_steps = 1000), (early_stop_patience_steps = 3)),\n  PatchTST((h = horizon), (input_size = 3 * horizon), (max_steps = 1000), (early_stop_patience_steps = 3)),\n];\n```\n\n좋아요! 이제 우리는 단순히 NeuralForecast 객체를 초기화하면 되는데, 이 객체는 학습, 교차 검증 및 예측을 위한 메서드에 액세스할 수 있게 해줍니다.\n\n```js\nnf = NeuralForecast((models = models), (freq = freq));\nnf_preds = nf.cross_validation((df = Y_df), (val_size = val_size), (test_size = test_size), (n_windows = None));\n```\n\n마지막으로, 우리는 각 모델의 성능을 utilsforecast 라이브러리를 사용하여 평가합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nfrom utilsforecast.losses import mae, mse\nfrom utilsforecast.evaluation import evaluate\n\nettm1_evaluation = evaluate(df=nf_preds, metrics=[mae, mse], models=['iTransformer', 'TSMixer', 'NHITS', 'PatchTST'])\nettm1_evaluation.to_csv('ettm1_results.csv', index=False, header=True)\n```\n\n이 단계는 모든 데이터셋에 대해 반복됩니다. 이 실험을 실행하는 완전한 함수는 아래에 표시됩니다.\n\n```js\nfrom utilsforecast.losses import mae, mse\nfrom utilsforecast.evaluation import evaluate\n\ndatasets = ['ettm1', 'ettm2', 'etth1', 'etth2']\n\nfor dataset in datasets:\n\n    Y_df, val_size, test_size, freq = load_data(dataset)\n\n    horizon = 96\n\n    models = [\n        iTransformer(h=horizon, input_size=3*horizon, n_series=1, max_steps=1000, early_stop_patience_steps=3),\n        TSMixer(h=horizon, input_size=3*horizon, n_series=1, max_steps=1000, early_stop_patience_steps=3),\n        NHITS(h=horizon, input_size=3*horizon, max_steps=1000, early_stop_patience_steps=3),\n        PatchTST(h=horizon, input_size=3*horizon, max_steps=1000, early_stop_patience_steps=3)\n    ]\n\n    nf = NeuralForecast(models=models, freq=freq)\n    nf_preds = nf.cross_validation(df=Y_df, val_size=val_size, test_size=test_size, n_windows=None)\n    nf_preds = nf_preds.reset_index()\n\n    evaluation = evaluate(df=nf_preds, metrics=[mae, mse], models=['iTransformer', 'TSMixer', 'NHITS', 'PatchTST'])\n    evaluation.to_csv(f'{dataset}_results.csv', index=False, header=True)\n```\n\n이 작업을 완료하면 모든 데이터셋에 대해 모든 모델의 예측이 있게 됩니다. 그런 다음 평가로 넘어갈 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 성능 평가\n\n성능 지표를 모두 CSV 파일에 저장했으므로, pandas를 사용하여 이를 읽고 각 모델의 각 데이터셋에 대한 성능을 그릴 수 있습니다.\n\n```python\nfiles = ['etth1_results.csv', 'etth2_results.csv', 'ettm1_results.csv', 'ettm2_results.csv']\ndatasets = ['etth1', 'etth2', 'ettm1', 'ettm2']\n\ndataframes = []\n\nfor file, dataset in zip(files, datasets):\n    df = pd.read_csv(file)\n    df['dataset'] = dataset\n\n    dataframes.append(df)\n\nfull_df = pd.concat(dataframes, ignore_index=True)\nfull_df = full_df.drop(['unique_id'], axis=1)\n```\n\n이후, 지표를 그래프로 그리려면:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndataset_names = full_df['dataset'].unique()\nmodel_names = ['iTransformer', 'TSMixer', 'NHITS', 'PatchTST']\n\nfig, axs = plt.subplots(2, 2, figsize=(15, 15))\nbar_width = 0.35\n\naxs = axs.flatten()\n\nfor i, dataset_name in enumerate(dataset_names):\n    df_subset = full_df[(full_df['dataset'] == dataset_name) & (full_df['metric'] == 'mae')]\n    mae_vals = df_subset[model_names].values.flatten()\n    df_subset = full_df[(full_df['dataset'] == dataset_name) & (full_df['metric'] == 'mse')]\n    mse_vals = df_subset[model_names].values.flatten()\n\n    indices = np.arange(len(model_names))\n\n    bars_mae = axs[i].bar(indices - bar_width / 2, mae_vals, bar_width, color='skyblue', label='MAE')\n    bars_mse = axs[i].bar(indices + bar_width / 2, mse_vals, bar_width, color='orange', label='MSE')\n\n    for bars in [bars_mae, bars_mse]:\n        for bar in bars:\n            height = bar.get_height()\n            axs[i].annotate(f'{height:.2f}',\n                            xy=(bar.get_x() + bar.get_width() / 2, height),\n                            xytext=(0, 3),\n                            textcoords=\"offset points\",\n                            ha='center', va='bottom')\n\n    axs[i].set_xticks(indices)\n    axs[i].set_xticklabels(model_names, rotation=45)\n    axs[i].set_title(dataset_name)\n    axs[i].legend(loc='best')\n\nplt.tight_layout()\n```\n\n![Image](/TIL/assets/img/2024-07-09-iTransformerTheLatestBreakthroughinTimeSeriesForecasting_4.png)\n\nFrom the figure above, we can see that the iTransformer performs fairly well on all datasets, but TSMixer is overall slightly better than iTransformer, and PatchTST is the overall champion model in this experiment.\n\nOf course, keep in mind that we did not leverage the multivariate capabilities of iTransformer, and we only tested on a single forecast horizon. Therefore, it is not a complete assessment of the iTransformer’s performance.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그럼에도 불구하고, 모델이 PatchTST와 매우 유사하게 수행되는 것을 볼 때, Transformer를 사용한 시계열 예측에서 새로운 성능에 도달하는 데 그룹화 시간 단계를 토큰화하기 전에 묶는 아이디어를 더 지원하는 점이 흥미로운 부분입니다.\n\n# 결론\n\niTransformer는 베이닐라 Transformer 아키텍처를 적용한 뒤 입력 시리즈의 역방향 모양으로 그냥 적용합니다.\n\n이렇게 하면 전체 시리즈가 토큰화되고 PatchTST에서 제안한 것과 같이 극단적인 케이스를 모방합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모델이 주의 매커니즘을 사용하여 다변량 상관 관계를 학습하고, 피드포워드 네트워크가 시계열의 시간적 특성을 학습합니다.\n\niTransformer는 많은 벤치마크 데이터셋에서 장기 예측에 대한 최신 기술을 보여주었으며, 우리의 한정된 실험에서는 PatchTST가 전반적으로 가장 우수한 성과를 보였습니다.\n\n모든 문제는 고유한 해결책이 필요하다고 단언합니다. 이제 iTransformer를 도구 상자에 추가하고 여러분의 프로젝트에 적용할 수 있습니다.\n\n읽어 주셔서 감사합니다! 즐겁게 읽으셨기를 바라며 새로운 지식을 얻으셨기를 기대합니다!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만나서 반가워요 🌟\n\n# 저를 지원해주세요\n\n제 작업을 즐기고 계신가요? Buy me a coffee로 제게 지원을 표현해주세요. 여러분의 응원을 받으면 저는 커피 한 잔을 즐길 수 있어요! 만약 그렇게 느끼신다면, 아래 버튼을 클릭해주세요 👇\n\n![Image](/TIL/assets/img/2024-07-09-iTransformerTheLatestBreakthroughinTimeSeriesForecasting_5.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 참고 자료\n\niTransformer: Inverted Transformers Are Effective for Time Series Forecasting by Yong Liu, Tengge Hu, Haoran Zhang, Haixu Wu, Shiyu Wang, Lintao Ma, Mingsheng Long\n","ogImage":{"url":"/assets/img/2024-07-09-iTransformerTheLatestBreakthroughinTimeSeriesForecasting_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-iTransformerTheLatestBreakthroughinTimeSeriesForecasting_0.png","tag":["Tech"],"readingTime":19},{"title":"FastAPI에서 Celery와 RabbitMQ 사용 방법","description":"","date":"2024-07-09 19:19","slug":"2024-07-09-UsingCeleryRabbitMQWithFastAPI","content":"\n![표](/TIL/assets/img/2024-07-09-UsingCeleryRabbitMQWithFastAPI_0.png)\n\n안녕하세요, 우주 여러분! 오늘은 Celery + RabbitMQ와 FastAPI를 사용한 최근 경험을 공유하려고 합니다. 최근에 오디오 분석 관련 프로젝트를 하고 있었어요. 이 프로젝트에서 일부 작업은 완료하는 데 조금 시간이 걸렸어요. 따라서 클라이언트가 서버에 요청을 보내면 이러한 작업 때문에 서버가 잠시 바쁠 거예요. 그래서 클라이언트 요청에 대한 응답을 보내는 데 상당한 시간이 소요되었죠. 이 상황을 방지하기 위해 백그라운드에서 작업을 실행하는 방법을 찾았어요. 결국 해결책인 Celery — 분산 작업 큐를 찾았고, 이 글에서는 어떻게 Celery를 사용해 목표를 이루었는지 설명할 거예요.\n\nCelery는 실시간 처리를 지원하는 작업 큐이며 작업 스케줄링도 지원해요. 간단히 말해, 서버가 시간이 오래 걸리는 작업에 대한 요청을 받으면 해당 작업을 Celery 작업 큐에 추가하고 백그라운드에서 실행될 거예요. Celery는 작업의 상태를 유지하는데, 대기 중인지, 시작된 상태인지, 성공적인지 등을 확인할 수 있어요. Celery에는 메시지 브로커 서비스가 필요해요. 서버(주 어플리케이션)가 작업을 위해 요청을 받으면, celery 워커가 이용 가능할 때까지 작업은 작업 큐에 있어야 해요. 워커가 사용 가능하면 메시지 큐에서 작업을 실행할 거예요. RabbitMQ는 celery의 기본 메시지 브로커인데, Redis, Amazon SQS, Apache Kafka와 같은 다른 솔루션이 있어요. 저는 이를 가장 간단하게 하고자 RabbitMQ를 사용했어요. 이 애니메이션 동영상에서 이 작업이 어떻게 이루어지는지 설명합니다.\n\n# 구현\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n먼저 RabbitMQ를 설정해 봅시다. 프로젝트를 개발하는 환경은 Windows를 사용하고 있어요. RabbitMQ를 설정하기 위해서 Docker 이미지를 사용하고 있어요. 원하신다면 Docker 대신에 RabbitMQ를 설치할 수도 있어요.\n\n```js\ndocker run -p 15672:15672 -p 5672:5672 rabbitmq:3-management\n```\n\nDocker 컨테이너가 시작되면, 브라우저를 통해 127.0.0.1:5672로 RabbitMQ 대시보드에 로그인할 수 있어요. 사용자 이름과 비밀번호는 모두 'guest'에요.\n\n<img src=\"/TIL/assets/img/2024-07-09-UsingCeleryRabbitMQWithFastAPI_1.png\" />\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 Celery를 설치하고 설정해 봅시다. 다음 라이브러리를 설치하세요. 저는 python-dotenv 라이브러리를 사용하여 .env 파일에서 보안 정보를 관리합니다.\n\n```js\npip install celery python-dotenv\n```\n\n내 FastAPI 프로젝트는 이와 유사한 폴더 구조를 가지고 있어요.\n\n```js\napp/\n├── config/\n│   ├── __init__.py\n│   └── celery_config.py\n├── tasks/\n│   ├── __init__.py\n│   └── celery_tasks.py\n├── __init__.py\n├── main.py\n├── .env\n└── requirements.txt\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n먼저, .env 파일에서 환경 변수를 만들어봅시다. Celery에는 두 가지가 필요합니다. 첫 번째는 메시지 브로커 URL입니다. 제 경우에는 RabbitMQ 서버 URL입니다. (`USERNAME`, `PASSWORD`를 교체하여 사용자명과 비밀번호를 입력해주세요. 기본값은 guest입니다.) 두 번째는 결과 백엔드입니다. Celery가 작업 실행 결과를 저장하는 곳으로, 작업을 완료한 후에 이 결과를 검색할 수 있습니다.\n\n```js\nCELERY_BROKER_URL=amqp://<USERNAME>:<PASSWORD>@localhost:5672//\nCELERY_RESULT_BACKEND=rpc://\n```\n\n좋아요. 이제 Celery 앱을 생성하고 구성해봅시다. 이를 위해 celery_config.py 파일을 만들겠습니다.\n\n```js\n# celery_config.py\n# 별도의 파일에서 celery 작업을 정의하기 위한 구성.\nimport os\nfrom celery import Celery\nfrom dotenv import load_dotenv\n\nload_dotenv() # 환경 변수를 불러오기 위한 코드\n\ncelery_app = Celery(__name__, broker=os.getenv(\"CELERY_BROKER_URL\"), backend=os.getenv(\"CELERY_RESULT_BACKEND\"))\n\ncelery_app.conf.update(\n    imports=['app.tasks.celery_tasks'], # celery 작업 파일 경로\n    broker_connection_retry_on_startup=True,\n    task_track_started=True\n)\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n분리된 파일을 만들어 Celery 작업을 정의했어요. 하지만 그건 꼭 필요하지 않아요. 이 파일 안에 작업들을 정의할 수 있어요. 만약 이 파일 안에 작업을 정의한다면, imports=['app.tasks.celery_tasks'] 라인을 추가할 필요가 없어요. 따라서, 당신의 구성은 이런 식이에요.\n\n```js\n# celery_config.py\n# 이 파일 안에 Celery 작업을 정의하기 위한 구성.\nimport os\nfrom celery import Celery\nfrom dotenv import load_dotenv\n\nload_dotenv() # 환경 변수 로드\n\ncelery_app = Celery(__name__, broker=os.getenv(\"CELERY_BROKER_URL\"), backend=os.getenv(\"CELERY_RESULT_BACKEND\"))\n\ncelery_app.conf.update(\n    broker_connection_retry_on_startup=True,\n    task_track_started=True\n)\n```\n\n이제 Celery 작업을 만들어봐요. celery_tasks.py 파일을 만들고 그 안에 작업들을 정의했어요. Celery 작업을 정의하기 위해 데코레이터를 사용해요.\n\n```js\n# celery_tasks.py\nimport asyncio\nfrom app.config.celery_config import celery_app\n\n\n@celery_app.task\ndef my_task(x, y):\n    ans = x + y\n    print(ans)\n    return ans\n\n\nasync def my_async_task(x, y):\n    await asyncio.sleep(3)\n    ans = x + y\n    print(ans)\n    return ans\n\n\n@celery_app.task\ndef my_second_task(x, y):\n    result = asyncio.run(my_async_task(x, y))\n    return result\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n별도의 파일 대신 이러한 방식으로 구성 파일 내에서 작업을 정의할 수 있어요.\n\n```python\n# celery_config.py\n# 이 파일 안에서 Celery 작업을 정의하는 설정입니다.\nimport os\nimport asyncio\nfrom celery import Celery\nfrom dotenv import load_dotenv\n\nload_dotenv() # 환경 변수를 불러오기\n\ncelery_app = Celery(__name__, broker=os.getenv(\"CELERY_BROKER_URL\"), backend=os.getenv(\"CELERY_RESULT_BACKEND\"))\n\ncelery_app.conf.update(\n    broker_connection_retry_on_startup=True,\n    task_track_started=True\n)\n\n@celery_app.task\ndef my_task(x, y):\n   ans = x + y\n   print(ans)\n   return ans\n\nasync def my_async_task(x, y):\n   await asyncio.sleep(3)\n   ans = x + y\n   print(ans)\n   return ans\n\n@celery_app.task\ndef my_second_task(x, y):\n   result = asyncio.run(my_async_task(x, y))\n   return result\n```\n\n이제 라우트 핸들러에서 이러한 작업을 사용할 수 있어요. 아래는 예시 라우트 핸들러입니다. 여기서 GET 엔드포인트를 만들었어요. 이 엔드포인트 핸들러 내부에서 Celery 작업을 사용해요.\n\n```python\nfrom fastapi import FastAPI\n\nfrom app.tasks.celery_tasks import my_task\n\napp = FastAPI()\n\n@app.get(\"/run\")\ndef handle_run():\n   task_response = my_task.delay(5, 6)\n   return {\"message\": \"작업 실행이 시작됐어요!\"}\n\nif __name__ == '__main__':\n    uvicorn.run(app, port=8080)\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n알겠어요. 코딩 부분은 끝났습니다. 이제 세럴리 워커를 실행해봅시다. 이 세럴리 워커는 RabbitMQ의 메시지 대기열에 있는 작업을 실행할 것입니다. 만약 RabbitMQ 서버를 시작하지 않았다면, 세럴리 워커를 시작하기 전에 RabbitMQ를 시작해주세요.\n\n```js\ncelery --app app.config.celery_config.celery_app worker --loglevel=info --pool=solo\n```\n\n만약 세럴리가 어떠한 오류 없이 실행된다면, 터미널에서 다음과 유사한 출력을 확인할 수 있습니다.\n\n<img src=\"/TIL/assets/img/2024-07-09-UsingCeleryRabbitMQWithFastAPI_2.png\" />\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위 이미지에서 [작업] 섹션 아래에서 celery_tasks.py 파일에 정의한 celery 작업을 볼 수 있습니다. 작업 대기열이 새 작업을 받으면 celery가 해당 작업을 실행합니다. 이제 FastAPI 서버를 실행해 봅시다.\n\n```js\nuvicorn app.main:app --port 8000\n```\n\nSwagger 문서 페이지에서 엔드포인트를 시도해 봅시다. 엔드포인트에 요청을 보낸 후 celery 터미널을 확인하면 다음과 같은 출력을 볼 수 있습니다.\n\n<img src=\"/TIL/assets/img/2024-07-09-UsingCeleryRabbitMQWithFastAPI_3.png\" />\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n작업을 받았고, 작업을 실행하기 시작했습니다. 그리고 실행이 완료된 후에는 작업이 성공했다고 합니다. 이는 우리의 작업이 FastAPI 서버에 의해 실행되는 것이 아닌 celery 워커에 의해 실행된다는 것을 의미합니다.\n\n## 작업 모니터링\n\nCelery 작업과 워커를 모니터링하기 위해 Flower를 사용할 수 있습니다. Flower를 설치해보겠습니다.\n\n```js\npip install flower\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n로컬 머신에서 flower를 실행하세요.\n\n```js\ncelery flower --app app.config.celery_config.celery_app --broker:amqp://localhost//\n```\n\n웹 브라우저에서 flower 모니터링 도구를 확인할 수 있습니다. http://localhost:5555/ 으로 이동하세요.\n\n![Flower Monitoring Tool](/TIL/assets/img/2024-07-09-UsingCeleryRabbitMQWithFastAPI_4.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n요즘 FastAPI 프로젝트에서 Celery + RabbitMQ를 사용하는 방법을 소개했어. 여기서 어떤 일이 벌어지는지 이해할 수 있을 거야. 이건 이 작업을 수행하는 가장 간단한 방법이야. 나는 기본 작업 대기열을 사용했어. 원한다면 더 많은 작업 대기열을 생성할 수도 있어. 그리고 더 많은 구성 가능한 사항들도 있어. 그들의 설명서를 확인해봐. 작업 완료 상태를 클라이언트에게 알리기 위해 WebSocket을 사용할 수도 있어. 이게 전부야. 다음 블로그에서 만나자. 즐거운 코딩이 되길!\n\n# Stackademic 🎓\n\n끝까지 읽어주셔서 감사해요. 떠나시기 전에 이런 점 유의해주세요:\n\n- 박수를 치고 작가를 팔로우해주시면 감사하겠어요! 👏\n- 저희를 팔로우해주세요 X | LinkedIn | YouTube | Discord\n- 다른 플랫폼도 방문해보세요: In Plain English | CoFeed | Differ\n- Stackademic.com에서 더 많은 콘텐츠를 만나보세요\n","ogImage":{"url":"/assets/img/2024-07-09-UsingCeleryRabbitMQWithFastAPI_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-UsingCeleryRabbitMQWithFastAPI_0.png","tag":["Tech"],"readingTime":10}],"page":"20","totalPageCount":35,"totalPageGroupCount":2,"lastPageGroup":15,"currentPageGroup":1},"__N_SSG":true}