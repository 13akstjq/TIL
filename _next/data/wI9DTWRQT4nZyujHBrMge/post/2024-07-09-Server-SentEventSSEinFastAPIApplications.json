{"pageProps":{"post":{"title":"FastAPI 애플리케이션에서 Server-Sent EventSSE 사용 방법","description":"","date":"2024-07-09 09:22","slug":"2024-07-09-Server-SentEventSSEinFastAPIApplications","content":"\n\n서버 전송 이벤트(Server-Sent Events, SSE)는 서버가 싱글 HTTP 연결을 통해 웹 클라이언트에 실시간 업데이트를 푸시할 수 있는 서버 푸시 기술입니다. 대시보드, 알림 또는 실시간 분석과 같이 실시간 업데이트가 필요한 애플리케이션에 특히 유용합니다.\n\n![SSE](/assets/img/2024-07-09-Server-SentEventSSEinFastAPIApplications_0.png)\n\n## SSE 소개\n\n- SSE는 서버가 초기 클라이언트 연결을 설정하자마자 브라우저 클라이언트로 데이터 전송을 시작할 수 있는 표준입니다.\n- 웹소켓과 달리 SSE는 양방향 통신이 아닌 단방향이며, 서버에서 클라이언트로 데이터가 흐릅니다.\n- 이로써 SSE는 서버가 클라이언트로 업데이트를 푸시해야 하는 경우에 더 간단한 대안이 됩니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 왜 SSE를 사용해야 하나요?\n\nSSE는 다음과 같은 시나리오에서 유용합니다:\n\n- 실시간 업데이트: 실시간 업데이트를 클라이언트에 푸시해야 하는 애플리케이션들, 예를 들어 실시간 스포츠 점수, 주식 시장 업데이트, 또는 채팅 애플리케이션 등.\n- 서버 모니터링 및 대시보드: 실시간 모니터링 대시보드는 SSE를 활용하여 클라이언트가 서버를 계속 폴링할 필요 없이 메트릭 및 상태를 업데이트할 수 있습니다.\n- 알림: 서버에서 보내는 알림을 SSE로 효율적으로 관리할 수 있어서, 클라이언트 측에서 지속적으로 폴링할 필요가 줄어듭니다.\n- 스트리밍 데이터: 대용량 데이터 세트나 로그를 실시간으로 스트리밍하는 것을 SSE로 간단하게 구현할 수 있습니다.\n\n# FastAPI에서 SSE 구현하기\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nFastAPI은 속도와 사용 편의성으로 유명하며, sse-starlette 라이브러리와 통합하여 SSE를 구현하는 데 잘 작동합니다. 다음은 설정 방법입니다.\n\n# 예제 구현\n\n## 단계 1: 필요한 라이브러리 설치\n\n먼저, FastAPI와 sse-starlette를 설치하세요:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\r\npip install fastapi sse-starlette\r\n```\n\n## Step 2: FastAPI 애플리케이션 생성\n\n```js\r\nfrom fastapi import FastAPI\nfrom sse_starlette.sse import EventSourceResponse\nimport asyncio\n\napp = FastAPI()\nasync def event_generator():\n    while True:\n        await asyncio.sleep(1)\n        yield {\"data\": \"This is a server-sent event!\"}\n@app.get(\"/events\")\nasync def sse_endpoint():\n    return EventSourceResponse(event_generator())\r\n```\n\n이 예시에서 event_generator는 매 초마다 새 이벤트를 생성하는 비동기 생성자입니다. sse_endpoint 엔드포인트는 EventSourceResponse를 사용하여 SSE 연결을 처리합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## FastAPI에서 SSE 사용 사례\n\n- 대시보드용 실시간 업데이트:\n\n  - SSE는 모니터링 시스템이나 실시간 분석 대시보드와 같은 실시간 메트릭을 표시하는 애플리케이션에 복잡한 WebSocket 관리 없이 업데이트를 푸시하는 간단한 방법을 제공합니다.\n\n- 실시간 알림:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 사용자에게 이벤트 알림이 필요한 애플리케이션(메신저 앱이나 알림 시스템과 같은)은 SSE를 사용하여 이러한 업데이트를 신속하게 전달할 수 있습니다.\n\n- 스트리밍 로그:\n\n- SSE는 실시간 로그나 기타 스트리밍 데이터를 표시해야 하는 애플리케이션에 잘 맞는 가벼운 솔루션입니다.\n\n## SSE의 장점:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 간편함: SSE는 웹소켓에 비해 구현과 관리가 간단합니다.\n- 자동 재연결: 브라우저가 자동으로 재연결을 처리하여 SSE가 실시간 업데이트에 강력합니다.\n- HTTP 호환성: SSE는 표준 HTTP/2 연결을 통해 작동하므로 기존 인프라와 작업하기 쉽습니다.\n\n## SSE 대안:\n\n- 웹소켓:\n\n- 양방향 통신: 양방향 통신이 필요한 경우 웹소켓을 선호합니다.\n- 낮은 지연 시간: 웹소켓은 SSE보다 낮은 지연 시간을 제공하여 온라인 게임과 같이 매우 상호작용적인 애플리케이션에 적합합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Long Polling:\n\n- 호환성: Long polling은 오래된 브라우저와 호환되며 WebSockets이나 SSE를 지원하지 않는 경우에 사용할 수 있습니다.\n- 오버헤드: 반복된 요청으로 인해 SSE나 WebSockets에 비해 더 많은 오버헤드를 도입합니다.\n\n# SSE의 현실 세계에서의 사용 사례\n\n서버-전송 이벤트 (SSE)는 실시간 업데이트를 필요로하는 현실 세계 애플리케이션에서 널리 사용되고 있습니다. 여기에 몇 가지 주목할 만한 예시가 있습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 라이브 스포츠 스코어\n- 주식 시장 및 금융 데이터\n- 소셜 미디어 플랫폼 등등..\n\n우리는 ESPN이나 BBC Sports와 같이 제공되는 라이브 스포츠 스코어 업데이트 애플리케이션의 예시를 더 자세히 살펴보겠습니다.\n\n진행 중인 축구 경기에 대한 실시간 업데이트를 제공하는 라이브 스포츠 스코어 애플리케이션을 상상해보세요. 이 애플리케이션은 골 득점 및 경기 통계와 같은 업데이트를 제공해야 합니다. 이곳이 [GitHub 링크](GitHub Link). \n\n## SSE 구현\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 서버 측 구현:\n\n아래 파일은 경기 개요를 포함하고 있습니다.\n\n```js\n// scores.py\n\n[\n    {\n        \"time\": \"00:01\",\n        \"scores\":\"1:0\",\n        \"event\": \"Goal! Team A scores!\"\n    },\n    {\n        \"time\": \"00:05\",\n        \"scores\":\"1:1\",\n        \"event\": \"Goal! Team B scores!\"\n    },\n    {\n        \"time\": \"00:10\",\n        \"scores\":\"2:1\",\n        \"event\": \"Goal! Team A scores again!\"\n    }\n]\n```\n\n- 서버는 경기 데이터의 실시간 피드를 유지하며 SSE를 사용하여 연결된 클라이언트에게 전송합니다.\n- 어떤 이벤트(골, 교체 등)가 발생할 때마다, 서버는 이 업데이트를 모든 연결된 클라이언트에게 푸시합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n# main.py\n\nfrom fastapi import FastAPI\nfrom sse_starlette.sse import EventSourceResponse\nimport asyncio\nimport json\n\napp = FastAPI()\n\nasync def event_generator():\n    with open(\"scores.json\", \"r\") as file:\n        scores = json.load(file)\n    for score in scores:\n        await asyncio.sleep(5)  \n        yield f\"Match Summary: {json.dumps(score)}\\n\\n\"\n\n@app.get(\"/live-scores\")\nasync def live_scores_endpoint():\n    return EventSourceResponse(event_generator())\n\n# Adding CORS middleware\nfrom fastapi.middleware.cors import CORSMiddleware\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n\nClient-Side Implementation:\n\n- 웹 응용 프로그램인 클라이언트는 서버와 SSE 연결을 설정하고 업데이트를 수신합니다.\n\n```html\n<!-- index.html -->\n\n<!DOCTYPE html>\n<html>\n<head>\n    <title>Live Sports Scores</title>\n</head>\n<body>\n    <h1>Live Football Scores</h1>\n    <div id=\"score-updates\"></div>\n\n    <script>\n        const eventSource = new EventSource(\"http://127.0.0.1:8000/live-scores\");\n\n        eventSource.onmessage = function(event) {\n            const newElement = document.createElement(\"div\");\n            newElement.innerHTML = event.data;\n            document.getElementById(\"score-updates\").appendChild(newElement);\n        };\n\n        eventSource.onerror = function(event) {\n            console.error(\"EventSource failed:\", event);\n            eventSource.close();\n        };\n    </script>\n</body>\n</html>\n``` \n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 참고\n\n- https://fastapi.tiangolo.com/\n- https://pypi.org/project/sse-starlette/\n\n# 결론\n\nsse-starlette를 사용하면 FastAPI 애플리케이션에 SSE를 통합하는 것이 간편하고 효율적입니다. 실시간 대시보드, 알림 시스템 또는 데이터 스트리밍 애플리케이션을 개발 중이든, SSE는 견고하고 간편한 해결책을 제공합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n읽어 주셔서 감사합니다! 만일 어떠한 오류를 발견하시거나 개선 제안이 있으시다면 아래 댓글에 공유해 주세요.\n\n이 글이 마음에 들었다면 👏 버튼을 눌러 다른 사람들이 발견할 수 있도록 도와주세요. GitHub에서 제 프로필을 팔로우하고 LinkedIn에서 저와 연결해도 괜찮아요.","ogImage":{"url":"/assets/img/2024-07-09-Server-SentEventSSEinFastAPIApplications_0.png"},"coverImage":"/assets/img/2024-07-09-Server-SentEventSSEinFastAPIApplications_0.png","tag":["Tech"],"readingTime":9},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>서버 전송 이벤트(Server-Sent Events, SSE)는 서버가 싱글 HTTP 연결을 통해 웹 클라이언트에 실시간 업데이트를 푸시할 수 있는 서버 푸시 기술입니다. 대시보드, 알림 또는 실시간 분석과 같이 실시간 업데이트가 필요한 애플리케이션에 특히 유용합니다.</p>\n<p><img src=\"/assets/img/2024-07-09-Server-SentEventSSEinFastAPIApplications_0.png\" alt=\"SSE\"></p>\n<h2>SSE 소개</h2>\n<ul>\n<li>SSE는 서버가 초기 클라이언트 연결을 설정하자마자 브라우저 클라이언트로 데이터 전송을 시작할 수 있는 표준입니다.</li>\n<li>웹소켓과 달리 SSE는 양방향 통신이 아닌 단방향이며, 서버에서 클라이언트로 데이터가 흐릅니다.</li>\n<li>이로써 SSE는 서버가 클라이언트로 업데이트를 푸시해야 하는 경우에 더 간단한 대안이 됩니다.</li>\n</ul>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h2>왜 SSE를 사용해야 하나요?</h2>\n<p>SSE는 다음과 같은 시나리오에서 유용합니다:</p>\n<ul>\n<li>실시간 업데이트: 실시간 업데이트를 클라이언트에 푸시해야 하는 애플리케이션들, 예를 들어 실시간 스포츠 점수, 주식 시장 업데이트, 또는 채팅 애플리케이션 등.</li>\n<li>서버 모니터링 및 대시보드: 실시간 모니터링 대시보드는 SSE를 활용하여 클라이언트가 서버를 계속 폴링할 필요 없이 메트릭 및 상태를 업데이트할 수 있습니다.</li>\n<li>알림: 서버에서 보내는 알림을 SSE로 효율적으로 관리할 수 있어서, 클라이언트 측에서 지속적으로 폴링할 필요가 줄어듭니다.</li>\n<li>스트리밍 데이터: 대용량 데이터 세트나 로그를 실시간으로 스트리밍하는 것을 SSE로 간단하게 구현할 수 있습니다.</li>\n</ul>\n<h1>FastAPI에서 SSE 구현하기</h1>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>FastAPI은 속도와 사용 편의성으로 유명하며, sse-starlette 라이브러리와 통합하여 SSE를 구현하는 데 잘 작동합니다. 다음은 설정 방법입니다.</p>\n<h1>예제 구현</h1>\n<h2>단계 1: 필요한 라이브러리 설치</h2>\n<p>먼저, FastAPI와 sse-starlette를 설치하세요:</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\">pip install fastapi sse-starlette\n</code></pre>\n<h2>Step 2: FastAPI 애플리케이션 생성</h2>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">from</span> fastapi <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">FastAPI</span>\n<span class=\"hljs-keyword\">from</span> sse_starlette.<span class=\"hljs-property\">sse</span> <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">EventSourceResponse</span>\n<span class=\"hljs-keyword\">import</span> asyncio\n\napp = <span class=\"hljs-title class_\">FastAPI</span>()\n<span class=\"hljs-keyword\">async</span> def <span class=\"hljs-title function_\">event_generator</span>():\n    <span class=\"hljs-keyword\">while</span> <span class=\"hljs-title class_\">True</span>:\n        <span class=\"hljs-keyword\">await</span> asyncio.<span class=\"hljs-title function_\">sleep</span>(<span class=\"hljs-number\">1</span>)\n        <span class=\"hljs-keyword\">yield</span> {<span class=\"hljs-string\">\"data\"</span>: <span class=\"hljs-string\">\"This is a server-sent event!\"</span>}\n@app.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">\"/events\"</span>)\n<span class=\"hljs-keyword\">async</span> def <span class=\"hljs-title function_\">sse_endpoint</span>():\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">EventSourceResponse</span>(<span class=\"hljs-title function_\">event_generator</span>())\n</code></pre>\n<p>이 예시에서 event_generator는 매 초마다 새 이벤트를 생성하는 비동기 생성자입니다. sse_endpoint 엔드포인트는 EventSourceResponse를 사용하여 SSE 연결을 처리합니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h2>FastAPI에서 SSE 사용 사례</h2>\n<ul>\n<li>\n<p>대시보드용 실시간 업데이트:</p>\n<ul>\n<li>SSE는 모니터링 시스템이나 실시간 분석 대시보드와 같은 실시간 메트릭을 표시하는 애플리케이션에 복잡한 WebSocket 관리 없이 업데이트를 푸시하는 간단한 방법을 제공합니다.</li>\n</ul>\n</li>\n<li>\n<p>실시간 알림:</p>\n</li>\n</ul>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>\n<p>사용자에게 이벤트 알림이 필요한 애플리케이션(메신저 앱이나 알림 시스템과 같은)은 SSE를 사용하여 이러한 업데이트를 신속하게 전달할 수 있습니다.</p>\n</li>\n<li>\n<p>스트리밍 로그:</p>\n</li>\n<li>\n<p>SSE는 실시간 로그나 기타 스트리밍 데이터를 표시해야 하는 애플리케이션에 잘 맞는 가벼운 솔루션입니다.</p>\n</li>\n</ul>\n<h2>SSE의 장점:</h2>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>간편함: SSE는 웹소켓에 비해 구현과 관리가 간단합니다.</li>\n<li>자동 재연결: 브라우저가 자동으로 재연결을 처리하여 SSE가 실시간 업데이트에 강력합니다.</li>\n<li>HTTP 호환성: SSE는 표준 HTTP/2 연결을 통해 작동하므로 기존 인프라와 작업하기 쉽습니다.</li>\n</ul>\n<h2>SSE 대안:</h2>\n<ul>\n<li>\n<p>웹소켓:</p>\n</li>\n<li>\n<p>양방향 통신: 양방향 통신이 필요한 경우 웹소켓을 선호합니다.</p>\n</li>\n<li>\n<p>낮은 지연 시간: 웹소켓은 SSE보다 낮은 지연 시간을 제공하여 온라인 게임과 같이 매우 상호작용적인 애플리케이션에 적합합니다.</p>\n</li>\n</ul>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>\n<p>Long Polling:</p>\n</li>\n<li>\n<p>호환성: Long polling은 오래된 브라우저와 호환되며 WebSockets이나 SSE를 지원하지 않는 경우에 사용할 수 있습니다.</p>\n</li>\n<li>\n<p>오버헤드: 반복된 요청으로 인해 SSE나 WebSockets에 비해 더 많은 오버헤드를 도입합니다.</p>\n</li>\n</ul>\n<h1>SSE의 현실 세계에서의 사용 사례</h1>\n<p>서버-전송 이벤트 (SSE)는 실시간 업데이트를 필요로하는 현실 세계 애플리케이션에서 널리 사용되고 있습니다. 여기에 몇 가지 주목할 만한 예시가 있습니다:</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>라이브 스포츠 스코어</li>\n<li>주식 시장 및 금융 데이터</li>\n<li>소셜 미디어 플랫폼 등등..</li>\n</ul>\n<p>우리는 ESPN이나 BBC Sports와 같이 제공되는 라이브 스포츠 스코어 업데이트 애플리케이션의 예시를 더 자세히 살펴보겠습니다.</p>\n<p>진행 중인 축구 경기에 대한 실시간 업데이트를 제공하는 라이브 스포츠 스코어 애플리케이션을 상상해보세요. 이 애플리케이션은 골 득점 및 경기 통계와 같은 업데이트를 제공해야 합니다. 이곳이 [GitHub 링크](GitHub Link).</p>\n<h2>SSE 구현</h2>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>서버 측 구현:</li>\n</ul>\n<p>아래 파일은 경기 개요를 포함하고 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// scores.py</span>\n\n[\n    {\n        <span class=\"hljs-string\">\"time\"</span>: <span class=\"hljs-string\">\"00:01\"</span>,\n        <span class=\"hljs-string\">\"scores\"</span>:<span class=\"hljs-string\">\"1:0\"</span>,\n        <span class=\"hljs-string\">\"event\"</span>: <span class=\"hljs-string\">\"Goal! Team A scores!\"</span>\n    },\n    {\n        <span class=\"hljs-string\">\"time\"</span>: <span class=\"hljs-string\">\"00:05\"</span>,\n        <span class=\"hljs-string\">\"scores\"</span>:<span class=\"hljs-string\">\"1:1\"</span>,\n        <span class=\"hljs-string\">\"event\"</span>: <span class=\"hljs-string\">\"Goal! Team B scores!\"</span>\n    },\n    {\n        <span class=\"hljs-string\">\"time\"</span>: <span class=\"hljs-string\">\"00:10\"</span>,\n        <span class=\"hljs-string\">\"scores\"</span>:<span class=\"hljs-string\">\"2:1\"</span>,\n        <span class=\"hljs-string\">\"event\"</span>: <span class=\"hljs-string\">\"Goal! Team A scores again!\"</span>\n    }\n]\n</code></pre>\n<ul>\n<li>서버는 경기 데이터의 실시간 피드를 유지하며 SSE를 사용하여 연결된 클라이언트에게 전송합니다.</li>\n<li>어떤 이벤트(골, 교체 등)가 발생할 때마다, 서버는 이 업데이트를 모든 연결된 클라이언트에게 푸시합니다.</li>\n</ul>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h1>main.py</h1>\n<p>from fastapi import FastAPI\nfrom sse_starlette.sse import EventSourceResponse\nimport asyncio\nimport json</p>\n<p>app = FastAPI()</p>\n<p>async def event_generator():\nwith open(\"scores.json\", \"r\") as file:\nscores = json.load(file)\nfor score in scores:\nawait asyncio.sleep(5)<br>\nyield f\"Match Summary: {json.dumps(score)}\\n\\n\"</p>\n<p>@app.get(\"/live-scores\")\nasync def live_scores_endpoint():\nreturn EventSourceResponse(event_generator())</p>\n<h1>Adding CORS middleware</h1>\n<p>from fastapi.middleware.cors import CORSMiddleware</p>\n<p>app.add_middleware(\nCORSMiddleware,\nallow_origins=[\"<em>\"],\nallow_credentials=True,\nallow_methods=[\"</em>\"],\nallow_headers=[\"*\"],\n)</p>\n<p>Client-Side Implementation:</p>\n<ul>\n<li>웹 응용 프로그램인 클라이언트는 서버와 SSE 연결을 설정하고 업데이트를 수신합니다.</li>\n</ul>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-comment\">&#x3C;!-- index.html --></span>\n\n<span class=\"hljs-meta\">&#x3C;!DOCTYPE <span class=\"hljs-keyword\">html</span>></span>\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">html</span>></span>\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">head</span>></span>\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">title</span>></span>Live Sports Scores<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">title</span>></span>\n<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">head</span>></span>\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">body</span>></span>\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">h1</span>></span>Live Football Scores<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">h1</span>></span>\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"score-updates\"</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">script</span>></span><span class=\"javascript\">\n        <span class=\"hljs-keyword\">const</span> eventSource = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">EventSource</span>(<span class=\"hljs-string\">\"http://127.0.0.1:8000/live-scores\"</span>);\n\n        eventSource.<span class=\"hljs-property\">onmessage</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">event</span>) {\n            <span class=\"hljs-keyword\">const</span> newElement = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">createElement</span>(<span class=\"hljs-string\">\"div\"</span>);\n            newElement.<span class=\"hljs-property\">innerHTML</span> = event.<span class=\"hljs-property\">data</span>;\n            <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">\"score-updates\"</span>).<span class=\"hljs-title function_\">appendChild</span>(newElement);\n        };\n\n        eventSource.<span class=\"hljs-property\">onerror</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">event</span>) {\n            <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">\"EventSource failed:\"</span>, event);\n            eventSource.<span class=\"hljs-title function_\">close</span>();\n        };\n    </span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">script</span>></span>\n<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">body</span>></span>\n<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">html</span>></span>\n</code></pre>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h2>참고</h2>\n<ul>\n<li><a href=\"https://fastapi.tiangolo.com/\" rel=\"nofollow\" target=\"_blank\">https://fastapi.tiangolo.com/</a></li>\n<li><a href=\"https://pypi.org/project/sse-starlette/\" rel=\"nofollow\" target=\"_blank\">https://pypi.org/project/sse-starlette/</a></li>\n</ul>\n<h1>결론</h1>\n<p>sse-starlette를 사용하면 FastAPI 애플리케이션에 SSE를 통합하는 것이 간편하고 효율적입니다. 실시간 대시보드, 알림 시스템 또는 데이터 스트리밍 애플리케이션을 개발 중이든, SSE는 견고하고 간편한 해결책을 제공합니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>읽어 주셔서 감사합니다! 만일 어떠한 오류를 발견하시거나 개선 제안이 있으시다면 아래 댓글에 공유해 주세요.</p>\n<p>이 글이 마음에 들었다면 👏 버튼을 눌러 다른 사람들이 발견할 수 있도록 도와주세요. GitHub에서 제 프로필을 팔로우하고 LinkedIn에서 저와 연결해도 괜찮아요.</p>\n</body>\n</html>\n"},"__N_SSG":true}