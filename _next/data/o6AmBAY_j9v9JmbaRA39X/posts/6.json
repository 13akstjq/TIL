{"pageProps":{"posts":[{"title":"Next.js 15 프로덕션 최적화 완벽 가이드","description":"","date":"2025-04-22 01:36","slug":"2025-04-22-HowtooptimizeyourNextjsapplicationforproduction","content":"\n\n# Next.js 애플리케이션을 프로덕션에 최적화하는 방법\n\nNext.js 애플리케이션을 프로덕션 환경에 배포하기 전에 사용자 경험, 성능, 그리고 보안을 위해 꼭 고려해야 할 최적화 방법과 좋은 패턴들이 있어요.\n\n이 글에서는 애플리케이션을 만들 때, 배포 전에, 그리고 배포 후에 참고할 수 있는 실전 팁들과 Next.js가 자동으로 제공하는 최적화 기능들을 함께 소개할게요. 개발하면서 한 번쯤 꼭 확인해보면 좋아요!\n\n## 자동 최적화 기능들\n\nNext.js는 기본적으로 많은 부분을 자동으로 최적화해줘요. 그래서 우리가 따로 신경 쓰지 않아도 괜찮은 부분들이 있죠. 예를 들어:\n\n| 최적화 요소            | 설명                                                         |\n|---------------------|------------------------------------------------------------|\n| 코드 분할(Code Splitting)    | 페이지 단위로 필요한 코드만 딱 불러와서 초기 로딩 속도를 빠르게 해줘요.              |\n| 정적 사이트 생성(Static Generation) | 빌드 시점에 HTML 파일로 미리 생성해서 서버 부담을 줄이고, 빠른 응답을 가능하게 해줍니다. |\n| 이미지 자동 최적화         | Next.js에서 제공하는 `<Image>` 컴포넌트로 이미지를 자동으로 최적화해서 로딩 속도를 개선합니다. |\n| 트리 쉐이킹(Tree Shaking)      | 사용하지 않는 코드를 제거해서 번들 용량을 줄여줍니다.                                  |\n| 프로덕션 빌드에서 압축       | JS와 CSS 파일을 압축하고 난독화해서 크기를 최소화합니다.                           |\n\n이런 자동화 덕분에 개발자는 기본적인 부분에 신경 쓰지 않고도 빠른 앱을 만들 수 있지만, 더 세밀한 최적화가 가능하다는 것도 잊지 마세요.\n\n다음에는 우리가 직접 적용할 수 있는 최적화 방법들을 살펴볼게요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서 기본으로 제공하는 최적화 기능들을 알려드릴게요! 별도의 설정 없이도 적용되니, 그냥 편하게 개발만 하시면 됩니다.\n\n- **서버 컴포넌트(Server Components)**: Next.js는 기본적으로 서버 컴포넌트를 사용합니다. 서버 컴포넌트는 서버에서만 실행되고, 클라이언트에는 자바스크립트를 전혀 보내지 않아요. 덕분에 클라이언트 사이드 자바스크립트 용량이 줄어들죠. 그리고 필요에 따라 인터랙티브한 부분만 클라이언트 컴포넌트(Client Components)로 만들어 사용하면 됩니다.\n- **코드 분할(Code-splitting)**: 서버 컴포넌트 덕분에 라우트 세그먼트별로 자동 코드 분할이 되어서, 필요한 부분만 내려받게 돼요. 여기에 더해서, 클라이언트 컴포넌트나 서드파티 라이브러리도 지연 로딩(lazy loading)하면 더 효율적입니다.\n- **프리패칭(Prefetching)**: 사용자가 어떤 링크를 화면에서 볼 때, Next.js가 그 라우트를 미리 백그라운드에서 받아오는데요, 덕분에 새로운 페이지로의 이동이 거의 순식간에 이루어진답니다. 상황에 따라 프리패칭을 끌 수도 있어요.\n- **정적 렌더링(Static Rendering)**: Next.js는 빌드 시점에 서버와 클라이언트 컴포넌트를 정적으로 렌더링해 결과를 캐싱하니까, 앱 성능이 좋아집니다. 필요하면 특정 경로에 대해 동적 렌더링(Dynamic Rendering)도 선택 가능합니다.\n- **캐싱(Caching)**: 서버 데이터 요청, 정적 렌더 결과, 정적 자산 등 여러 부분을 캐싱해서 서버나 DB, 백엔드에 가는 네트워크 요청 수를 줄여줍니다. 적절하다면 캐싱을 끄는 것도 가능해요.\n\n---\n\n이 최적화 기본값들은 앱 성능을 향상시키고, 네트워크 요청 때 쓰는 데이터 양과 비용을 줄여주는 효과가 있어요. \n\n---\n\n## 개발 중에는?\n\n다음 답변에서 개발 환경에서의 최적화 적용이나 주의할 점을 자세히 알려드릴게요! 혹시 Next.js 개발 중에 느린 점이나 의문 있으면 언제든 질문 주세요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n애플리케이션을 만들다 보면 성능과 사용자 경험을 최적화하는 게 중요하죠. 그래서 다음 기능들을 사용하는 걸 추천해요!\n\n### 라우팅과 렌더링\n\n- **레이아웃(Layouts)**: 여러 페이지에서 공통 UI를 공유할 수 있어서, 페이지 이동 시 일부만 새로고침하는 부분 렌더링이 가능해요. 덕분에 사용자 경험이 훨씬 매끄럽답니다.\n- **`Link` 컴포넌트**: 클라이언트 사이드 내비게이션할 때 꼭 써주세요. 미리 데이터를 가져오는(prefetch) 기능도 있어서 페이지 전환이 더 빨라져요.\n- **에러 처리(Error Handling)**: 404나 그 외 예기치 못한 오류도 사용자에게 부드럽게 알리려면, 커스텀 에러 페이지를 만들어 놓으세요. 프로덕션 환경에서 꼭 필요하답니다.\n- **컴포지션 패턴(Composition Patterns)**: 서버 컴포넌트와 클라이언트 컴포넌트를 어떻게 구성할지 정해진 패턴을 따르세요. 특히 `\"use client\"` 지시문을 어디에 붙이는지 신경 써야 클라이언트 번들 용량을 불필요하게 늘리지 않아요.\n- **동적 API(Dynamic APIs)**: 쿠키나 `searchParams` 같은 동적 API를 쓰면 그 경로 전체가 동적 렌더링 모드로 전환돼요. 만약 루트 레이아웃에서 쓰면 앱 전체가 그렇게 되니 주의가 필요해요. 꼭 필요한 부분에만 사용하고, 적절하면 `Suspense` 경계로 감싸서 성능 저하를 막으세요.\n\n> 참고: 현재 실험 중인 Partial Prerendering 기능을 사용하면, 라우트의 일부만 동적으로 처리하면서도 전체를 동적 렌더링으로 전환하지 않아도 돼요. 앞으로 더 편리해질 예정이니 기대해도 좋아요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 데이터 페칭과 캐싱에 대해 알아볼까요?\n\n웹 앱 개발할 때 데이터 가져오는 방식과 캐싱 전략이 굉장히 중요하죠. 여기에 몇 가지 팁을 나눠드릴게요.\n\n- **서버 컴포넌트(Server Components) 활용하기**  \n  데이터는 서버에서 가져오는 게 성능상 유리해요. 서버 컴포넌트를 이용하면 클라이언트로 보내기 전에 데이터를 미리 받아서 렌더링할 수 있어요.\n\n- **라우트 핸들러(Route Handlers) 사용법**  \n  클라이언트 컴포넌트에서 백엔드 API에 접근할 때 라우트 핸들러를 사용하세요. 그런데 서버 컴포넌트에서 라우트 핸들러를 호출하는 건 피하는 게 좋아요. 왜냐하면 그러면 서버가 다시 서버에 요청하는 꼴이라 불필요한 추가 요청이 생기거든요.\n\n- **스트리밍(Streaming)으로 사용자 경험 개선하기**  \n  데이터가 완전히 로드될 때까지 기다리지 말고, 로딩 UI와 React Suspense를 활용해 UI를 점진적으로 보여주면 사용자 경험이 훨씬 좋아져요. 페이지 전체가 멈추지 않거든요.\n\n- **병렬 데이터 페칭(Parallel Data Fetching) 활용하기**  \n  여러 데이터를 순차적으로 가져오면 네트워크 병목이 생길 수 있어요. 가능하면 여러 데이터 요청을 동시에 보내서 속도를 앞당겨 보세요. 또, 미리 데이터를 불러오는 프리로딩(preloading)도 고려해볼 만해요.\n\n- **데이터 캐싱(Cache)은 필수**  \n  데이터 요청이 캐싱되고 있는지 꼭 확인하세요. fetch를 사용하지 않는 요청도 캐싱되도록 설정해주면 반복되는 요청을 줄일 수 있답니다.\n\n- **정적 이미지 관리**  \n  애플리케이션에 사용되는 이미지 같은 정적 자산은 `public` 디렉토리에 넣으면 자동으로 캐싱이 돼서 빠르게 로딩돼요.\n\n---\n\n### UI와 접근성에 대해\n\n- **폼과 검증(Form & Validation) 처리하기**  \n  사용자가 폼을 제출할 때 서버 액션(Server Actions)을 이용해 서버에서 검증하고 에러도 처리하세요. 클라이언트에서 모든 검증을 하는 것보다 안정적이고 보안에 더 좋아요.\n\n---\n\n이런 팁들을 활용하면 데이터 흐름을 효과적으로 관리하면서 사용자에게 쾌적한 경험을 줄 수 있어요. 서버 컴포넌트와 라우트 핸들러, React Suspense가 서로 어떻게 시너지를 내는지도 한번 실험해보시고요! 다음에 또 쉽게 이해할 만한 개발 지식으로 찾아올게요 :)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n개발할 때 퍼포먼스와 보안을 신경 쓰는 건 정말 중요한데요, 이번에 제가 정리한 내용을 쉽게 설명해드릴게요.\n\n### 퍼포먼스 최적화 팁\n\n| 기능 | 설명 |\n|---|---|\n| Font Module | 폰트 모듈을 사용하면 폰트 파일을 다른 정적 자원들과 함께 자동으로 호스팅해서 외부 네트워크 요청을 줄이고, 레이아웃 이동(layout shift)도 감소시킬 수 있어요. |\n| `Image` 컴포넌트 | 이미지 컴포넌트는 이미지를 자동으로 최적화해주고, 레이아웃 이동 문제를 막아주며, WebP 같은 현대적인 이미지 포맷으로 제공해줘요. 웹에서 이미지가 빠르게 뜨는 건 사용자 경험 향상에 아주 큰 도움이 되죠. |\n| `Script` 컴포넌트 | 서드파티 스크립트를 최적화하는 데 유용해요. 자동으로 스크립트를 지연 실행(defer) 시켜서 메인 스레드를 막지 않도록 해주거든요. 덕분에 페이지가 더 부드럽고 빠르게 로딩됩니다! |\n| ESLint | 내장된 `eslint-plugin-jsx-a11y` 플러그인을 활용하면 접근성(accessibility) 이슈를 미리 잡아낼 수 있어서, 누구나 쉽게 이용할 수 있는 웹을 만드는 데 도움이 됩니다. |\n\n> 참고로, 레이아웃 시프트(layout shift)는 사용자 경험에 악영향을 주는 요소 중 하나라서 최대한 줄이는 게 좋아요.\n\n---\n\n### 보안 관련 팁\n\n| 기능 | 설명 |\n|---|---|\n| Tainting | 민감한 데이터가 클라이언트 쪽으로 노출되지 않도록 데이터를 '오염(tainting)' 시키는 방법이에요. 특정 값이나 데이터 객체를 표시해서 관리하는 방식이죠. |\n| Server Actions | 서버 액션을 호출할 때 사용자 권한이 꼭 확인되도록 하세요. 공식적으로 권장하는 보안 모범 사례를 정기적으로 리뷰하는 게 중요합니다. |\n| 환경 변수 | `.env.*` 파일은 `.gitignore`에 반드시 추가해서 깃에 올라가지 않게 해야 해요. 공개해야 하는 변수만 `NEXT_PUBLIC_` 접두사를 붙여서 노출 범위를 명확히 관리하는 게 좋습니다. |\n| Content Security Policy (CSP) | CSP는 교차 사이트 스크립팅(XSS), 클릭재킹(clickjacking), 코드 인젝션 같은 보안 위협으로부터 앱을 보호해주는 역할을 해요. 적절한 CSP 설정으로 좀 더 안전한 웹사이트를 만들 수 있습니다. |\n\n---\n\n여기서 한 가지 더! 보안에서 가장 기본적인 걸 깔끔하게 챙기는 게 중요해요. 예를 들어, 환경 변수 처리를 그냥 넘기지 말고, 꼭 `.gitignore`에 추가하는 습관은 실수로 중요한 정보가 유출되는 걸 예방할 수 있답니다. CSP도 조금 복잡해 보일 수 있는데, 보안 헤더 관련 툴이나 라이브러리를 활용하면 설정이 훨씬 수월해지니 참고하세요!\n\n요약하자면, 폰트나 이미지, 스크립트 같은 프론트엔드 자원을 적절히 최적화하고, 보안에서 기본적인 데이터 관리와 권한, 정책 설정을 잘 챙기면 개발 퀄리티가 훨씬 올라간답니다. 앞으로 개발할 때 꼭 한번씩 체크리스트 삼아 활용해보세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 메타데이터와 SEO\n\n- **메타데이터 API**: 메타데이터 API를 활용하면 페이지 제목(title), 설명(description) 등 SEO에 중요한 정보를 손쉽게 추가할 수 있어요. 이렇게 하면 구글 같은 검색 엔진이 내 웹사이트를 더 잘 이해하고, 검색 결과에 더 잘 노출될 수 있답니다.\n- **Open Graph(OG) 이미지**: 페이스북, 트위터 같은 소셜미디어에서 내가 만든 페이지를 공유할 때 멋진 썸네일 이미지가 나오도록 OG 이미지를 만들어두는 게 좋아요. 시각적으로도 훨씬 매력적이니, 공유가 늘어나는 효과도 있답니다.\n- **사이트맵과 Robots 파일**: 사이트맵은 내 웹사이트에 어떤 페이지들이 있는지 검색 엔진에게 알려주는 역할을 해요. Robots.txt 파일은 검색 엔진이 어떤 페이지를 크롤링해도 되는지, 안 되는지를 지정해주는 친구입니다. 이 두 가지를 잘 설정하면 내 사이트가 검색 결과에 잘 노출되는 데 큰 도움이 돼요.\n\n### 타입 안전성(Type Safety)\n\n- **TypeScript와 TS 플러그인**: 자바스크립트는 유동적인 타입 때문에 때때로 예기치 못한 버그가 생기기 쉬운데요, TypeScript는 강력한 타입 시스템 덕분에 이런 문제를 미리 방지할 수 있도록 도와줘요. 게다가 VSCode 같은 개발 도구에서 타입 정보를 활용해서 자동완성도 되고, 에러도 빨리 발견할 수 있답니다. 그래서 요즘 웹 개발자라면 TypeScript를 꼭 배워두는 걸 추천해요!\n\n---\n\n개발하면서 SEO도 신경 쓰고, 코드 안정성도 챙기려면 위 내용들을 잘 활용해보세요. 작지만 이런 세심한 준비가 나중에 서비스 성공에 큰 차이를 만들어 줄 거예요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 배포 전에 꼭 확인해야 할 것들\n\n배포 전에 `next build` 명령어로 애플리케이션을 로컬에서 미리 빌드해보세요. 이렇게 하면 빌드 도중에 발생할 수 있는 오류들을 미리 잡아낼 수 있거든요. 다음으로 `next start`를 실행해서 실제 배포 환경과 비슷한 상황에서 애플리케이션의 성능을 측정해보는 것도 좋은 방법이에요.\n\n### Core Web Vitals\n\n- **Lighthouse**\n  - Lighthouse를 시크릿 모드(Incognito)로 실행해보세요. 이렇게 하면 실제 사용자들이 여러분의 사이트를 어떻게 경험할지 좀 더 정확하게 파악할 수 있어요. 그리고 개선이 필요한 부분도 쉽게 찾을 수 있죠.\n  - 다만 Lighthouse는 시뮬레이션 테스트이기 때문에, 실제 사용자 데이터를 같이 보는 것이 중요해요. 예를 들어, Core Web Vitals 같은 필드 데이터를 참고해서 성능을 좀 더 정확히 평가해보는 걸 추천합니다.\n\n> 추가 팁!\n> \n> Lighthouse 외에도 Chrome DevTools Performance 탭을 활용해서 사이트의 렌더링 과정이나 렌더링 차단 요소가 있는지 직접 분석해보는 것도 좋아요. 그리고 Core Web Vitals는 페이지 로딩 속도, 반응성, 시각적 안정성 등 사용자 경험에 직접적인 영향을 미치는 지표들이라 배포 전후로 꾸준히 모니터링하는 습관을 들이면 사이트 품질 관리에 큰 도움이 됩니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- useReportWebVitals 훅: 이 훅을 사용하면 Core Web Vitals 데이터를 애널리틱스 도구로 전송할 수 있어요. 사이트 성능을 측정하고 개선할 때 유용하답니다.\n\n### 번들 분석하기\n\n@next/bundle-analyzer 플러그인을 활용해 자바스크립트 번들의 크기를 분석해보세요. 어떤 모듈이나 의존성이 큰지 파악해서 성능에 영향을 주는 부분을 쉽게 찾을 수 있어요.\n\n또한, 새로운 의존성을 추가할 때 그 영향력을 알아보는 데 도움이 되는 도구들도 있어요. 이걸 잘 활용하면 불필요하게 무거운 라이브러리가 프로젝트에 들어오는 것을 막을 수 있죠. 대표적으로는 다음과 같은 툴들이 있으니 참고해 보세요:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Import Cost  \n- Package Phobia  \n- Bundle Phobia  \n- bundlejs\n\n## 배포 후\n\n어디에 애플리케이션을 배포하느냐에 따라, 성능을 모니터링하고 개선하는 데 도움이 되는 추가 도구나 통합 기능을 사용할 수 있어요.\n\n예를 들어, Vercel에 배포했다면 다음과 같은 도구들을 써보길 추천해요:\n\n- **Vercel Analytics**: 서버리스 환경에서 자동으로 트래픽과 성능 데이터를 수집해줘서, 별도의 설정 없이도 사용자 경험을 파악할 수 있어요.  \n- **Edge Functions 로그**: 엣지 함수 사용 시 로그를 통해 실행 시간을 모니터링하고 최적화 포인트를 쉽게 찾을 수 있고요.  \n- **Third-party 모니터링 도구 연동**: New Relic, Datadog 같은 도구들과 연동하면, 더 상세한 APM(애플리케이션 성능 관리)까지 할 수 있어요.  \n\n물론 이런 도구들이 꼭 Vercel에만 국한된 건 아니지만, 배포 플랫폼별로 특화된 기능을 잘 활용하면 성능 최적화 작업이 훨씬 수월해진답니다.  \n\n추가로, 배포 후에는 꼭 실시간 트래픽과 사용자 행동을 체크하면서 개선해나가는 걸 잊지 마세요! 이런 루틴이 결국 안정적이고 빠른 서비스 운영의 비결이에요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Analytics  \n: 내장된 분석 대시보드를 통해 애플리케이션의 트래픽을 쉽게 파악할 수 있어요. 예를 들어, 고유 방문자 수, 페이지 조회 수 등 다양한 지표를 확인할 수 있답니다.\n\n- Speed Insights  \n: 실제 방문자 데이터를 바탕으로 한 성능 인사이트를 제공해요. 이를 통해 웹사이트가 실제 환경에서 얼마나 잘 작동하는지 실질적인 성과를 확인할 수 있죠.\n\n- Logging  \n: 런타임 및 활동 로그를 통해 문제를 디버깅하고 프로덕션 환경에서 애플리케이션을 모니터링할 수 있어요. 필요하다면 타사 도구 및 서비스 목록은 통합 페이지에서 찾아볼 수 있습니다.\n\n> 알아두면 좋은 점:  \nVercel에서 프로덕션 배포 시 모범 사례를 종합적으로 이해하고 싶다면, [Vercel Production Checklist](https://vercel.com/docs/concepts/deployments/production-checklist)를 참고해 보세요. 웹사이트 성능 향상을 위한 다양한 전략과 자세한 내용이 담겨 있어서, 더 빠르고 안정적이며 안전한 애플리케이션을 만드는 데 큰 도움이 됩니다.\n\n덧붙여, 이런 도구들을 잘 활용하면 단순히 코드만 잘 짜는 것을 넘어서, 실제 사용자 경험을 개선하고 문제 발생 시 빠르게 대응할 수 있는 능력이 생기니 꼭 챙겨보시길 추천해요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":12},{"title":"Next.js와 Multi-Zones를 활용한 마이크로 프론트엔드 구축 방법 (2025 최신)","description":"","date":"2025-04-22 01:35","slug":"2025-04-22-Howtobuildmicro-frontendsusingmulti-zonesandNextjs","content":"\n# Multi-Zones와 Next.js로 마이크로 프론트엔드 만들기\n\n안녕하세요! 오늘은 'Multi-Zones'라는 개념을 활용해 Next.js로 마이크로 프론트엔드를 구축하는 방법에 대해 이야기해볼게요. '마이크로 프론트엔드'는 큰 애플리케이션을 여러 작은 애플리케이션으로 쪼개 관리하는 방법인데, Multi-Zones 방식은 특히 도메인 내에서 각기 다른 경로 집합(Path Set)별로 Next.js 애플리케이션을 분리하는 거랍니다.\n\n## Multi-Zones가 왜 필요할까요?\n\n대형 웹사이트를 운영하다보면, 서로 관련 없는 페이지들이 한 곳에 모여있을 때가 많아요. 예를 들어, 블로그 섹션과 로그인 후 대시보드, 그리고 일반 사용자용 페이지를 한 앱에서 모두 관리한다면, 빌드 시간이 길어지고 불필요한 코드도 함께 묶이게 됩니다. Multi-Zones를 적용하면 이런 문제를 이렇게 해결할 수 있어요:\n\n- 각 영역(Zone)별로 Next.js 앱을 따로 배포해 빌드 타임을 줄이고,\n- 각 앱에 필요한 코드만 포함해 번들 사이즈를 최소화하며,\n- 완전히 분리된 앱이므로 서로 다른 프레임워크도 혼용할 수 있습니다. 예를 들어, 메인 페이지는 Next.js, 블로그 섹션은 React SPA, 혹은 Vue.js 앱으로 분리할 수 있죠.\n\n## 예제를 들어볼까요?\n\n만약 다음과 같은 페이지 세트를 가지고 있다면:\n\n- `/blog/*` : 모든 블로그 포스트\n- `/dashboard/*` : 로그인 후 대시보드 관련 페이지\n- `/*` : 여기에 포함되지 않은 나머지 일반 페이지\n\n각각을 별도의 Next.js 애플리케이션으로 분리해서 관리하면, 훨씬 유연하고 관리하기 좋은 구조가 됩니다.\n\n---\n\n이렇게 분리된 애플리케이션들은 서로 독립적으로 개발 및 배포 가능하니, 팀별로 담당 영역 개발에 집중하기에도 좋고, 필요에 따라 기술 스택도 다르게 유지할 수 있는 점도 장점이에요.\n\n다음에는 이런 각각의 Zone을 설정하고 라우팅하는 방법, 그리고 배포 시 어떻게 연동하는지 자세한 설정법을 알아볼게요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nMulti-Zones 기능을 활용하면, 같은 도메인에서 서비스되면서 사용자 입장에서는 똑같이 보이는 세 개의 애플리케이션을 만들 수 있어요. 하지만 각 애플리케이션은 독립적으로 개발하고 배포할 수 있다는 점이 큰 장점이죠.\n\n![Multi-Zones 예시 이미지](/TIL/assets/img/2025-04-22-Howtobuildmicro-frontendsusingmulti-zonesandNextjs_0.png)\n\n여기서 재미있는 부분은 '존(zone)' 단위로 페이지 이동할 때의 동작이에요.\n\n- 같은 존 내에서 페이지를 이동하면 **소프트 네비게이션(soft navigation)**이 일어나는데, 이때는 페이지를 새로 고침하지 않고 빠르게 이동이 가능해요. 그림 예시에서 `/`에서 `/products`로 이동하는 경우가 바로 이 소프트 네비게이션에 해당하죠.\n- 반대로, 한 존에서 다른 존으로 이동할 때는 **하드 네비게이션(hard navigation)**이 발생해요. 즉, 현재 페이지의 리소스를 언로드(해제)하고 새로운 페이지 리소스를 다시 로드하는 작업이 이뤄지는 거죠. 예를 들어 `/`에서 `/dashboard`로 이동하는 경우가 여기에 포함돼요.\n\n이 점을 잘 활용하려면, 자주 함께 방문하는 페이지들을 같은 존에 배치하는 게 좋아요. 그래야 하드 네비게이션이 불필요하게 발생하지 않아 사용성도 높아지고, 로드 시간도 줄어들 테니까요.\n\n---\n\n추가로, 이런 Multi-Zones 구조는 마이크로 프론트엔드 아키텍처에 아주 적합해요. 즉, 대규모 애플리케이션을 여러 개의 작은 프론트엔드 애플리케이션으로 분할해서 팀별로 독립적 개발과 배포가 가능하게 만들어 주거든요. Next.js를 사용하면 이러한 Multi-Zones 지원을 비교적 쉽게 구현할 수 있으니, 관심 있는 분들은 공식 문서나 관련 튜토리얼도 함께 참고해보길 추천합니다!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 존(zone) 정의하는 방법\n\n존(zone)이란, 보통의 Next.js 애플리케이션과 비슷한데, 각 존마다 충돌을 방지하기 위해 `assetPrefix`라는 설정을 추가하는 걸 말해요. 이걸로 페이지나 정적 파일들이 다른 존과 겹치지 않게 관리할 수 있답니다.\n\n예를 들어, `assetPrefix`를 `/blog-static`으로 설정하면 이렇게 작성해요:\n\n```js\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  assetPrefix: \"/blog-static\",\n};\n```\n\n그럼 Next.js가 로드하는 JavaScript, CSS 같은 에셋들은 이 `assetPrefix`를 붙여서 `/blog-static/_next/...` 경로로 제공돼요. 이렇게 하면 여러 존에서 동일한 `_next` 폴더를 공유할 때 생길 수 있는 충돌 문제를 자연스럽게 해결할 수 있죠.\n\n### 참고로 알아두면 좋은 점!\n\n- `assetPrefix` 설정을 할 때는 실제로 배포 환경에서 이 경로가 올바르게 매핑되는지 꼭 확인하세요. 예를 들면, CDN이나 웹서버 설정이 `/blog-static` 경로의 요청을 제대로 처리해야 합니다.\n- 만약 로컬에서 개발할 때도 이 프리픽스를 쓰면 경로 이슈가 생길 수 있으니, 보통 개발 모드에선 `assetPrefix`를 빈 문자열로 두고, 프로덕션 빌드에서만 적용하는 방법도 있어요.\n\n이렇게 하면 한 서버 내 여러 개의 Next.js 서비스(존)를 안정적으로 운영할 수 있으니, 멀티 테넌트 환경이나 여러 애플리케이션을 한 곳에서 관리할 때 유용해요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서 기본 애플리케이션, 즉 다른 특정 zone으로 라우팅되지 않는 경로를 처리하는 애플리케이션은 따로 assetPrefix를 지정할 필요가 없어요.\n\n참고로, Next.js 15 버전 이전에는 정적 자산(static assets)을 제대로 처리하기 위해 추가적인 rewrites가 필요했었는데요, Next.js 15부터는 이런 작업이 더 이상 필요하지 않답니다.\n\n예를 들어, 아래처럼 assetPrefix를 지정하고, rewrites를 통해 정적 자산 경로를 다시 매핑해주는 코드가 있었어요.\n\n```js\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  assetPrefix: \"/blog-static\",\n  async rewrites() {\n    return {\n      beforeFiles: [\n        {\n          source: \"/blog-static/_next/:path+\",\n          destination: \"/_next/:path+\",\n        },\n      ],\n    };\n  },\n};\n```\n\n이렇게 하면 `/blog-static` 경로 아래의 `_next` 정적 파일들이 제대로 처리되도록 해줬죠.\n\n---\n\n### 요청을 올바른 zone으로 라우팅하는 방법\n\nNext.js를 여러 zone으로 나눠서 서비스할 때, 요청이 적절한 zone으로 잘 전달되도록 라우팅 설정이 필요해요. 이를 통해 각 zone별로 개별 Next.js 앱을 독립적으로 운영하면서도 마치 하나의 서비스처럼 보이게 할 수 있습니다.\n\n일반적으로 다음과 같은 방식으로 라우팅을 구현합니다:\n\n| 요청 경로 (Request Path) | 라우팅 대상 (Destination Zone)        | 비고                         |\n| ------------------------ | ------------------------------------- | ---------------------------- |\n| `/blog`, `/blog/*`       | 블로그 zone 애플리케이션              | blog 관련 콘텐츠 제공        |\n| `/shop`, `/shop/*`       | 쇼핑 zone 애플리케이션                | 쇼핑몰 서비스 제공           |\n| 기타                     | 기본 zone (기본 Next.js 애플리케이션) | 전체 서비스의 기본 응답 처리 |\n\n이때 각 zone 애플리케이션은 자신만의 assetPrefix를 가지고 있을 수 있고, 이전 Next.js 버전에서는 정적 자산 때문에 추가 rewrites 설정이 필요했지만, Next.js 15부터는 이런 설정 없이도 assetPrefix만으로 처리 가능해졌습니다.\n\n---\n\n#### 끝으로, 제가 경험해본 팁 하나!\n\nNext.js 앱을 멀티 zone으로 구성할 때는 배포와 라우팅 규칙을 명확히 정리하는 게 중요해요. 특히 CDN 캐싱 등과 연동할 때는 assetPrefix를 잘 활용해서 정적 자산들이 꼬이지 않도록 관리하는 걸 추천합니다. 그래야 배포 발란스도 맞고, 사용자 경험도 좋아진답니다!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nMulti Zone 환경에서는 각 경로(path)를 올바른 존(zone)으로 라우팅해줘야 해요. 왜냐하면 서로 다른 존은 각기 다른 애플리케이션에서 서비스되기 때문이죠. 보통 HTTP 프록시를 사용해서 이 작업을 하곤 하는데, Next.js 애플리케이션 중 하나를 이용해 도메인 전체의 요청을 라우팅하는 방법도 있어요.\n\n그럼 Next.js에서 어떻게 라우팅을 할 수 있을까요? 바로 rewrites 기능을 사용하는 거예요. 존마다 서비스하는 경로가 다르면, 그 경로를 해당 존의 도메인으로 보내는 rewrite 규칙을 추가해주면 됩니다. 예를 들어, `/blog` 경로는 블로그 존에서 처리한다면 아래처럼 쓸 수 있어요.\n\n```js\nasync rewrites() {\n  return [\n    {\n      source: '/blog',\n      destination: `${process.env.BLOG_DOMAIN}/blog`,\n    },\n    {\n      source: '/blog/:path+',\n      destination: `${process.env.BLOG_DOMAIN}/blog/:path+`,\n    }\n  ];\n}\n```\n\n여기서 중요한 건 `destination`이 실제 요청을 처리하는 존의 완전한 URL(스킴 + 도메인)을 포함해야 한다는 점이에요. 예를 들어 `https://blog.example.com/blog` 같은 주소가 될 거예요. 프로덕션 환경에선 당연히 존의 실제 도메인을 넣으면 되고, 로컬 개발 중일 땐 `http://localhost:3001/blog` 같은 식으로 로컬 주소로도 라우팅할 수 있습니다.\n\n추가로, rewrites는 클라이언트가 요청한 URL을 실제 내부적으로 다른 경로나 도메인으로 바꿔주는 기능이라서, 사용자가 URL을 바꾸지 않고도 다른 서비스에 요청을 보낼 수 있다는 장점이 있어요. 이런 방식으로 멀티 존 아키텍처를 구성하면 관리가 비교적 편하고, 각 존별로 독립된 애플리케이션을 운영하면서도 하나의 도메인 아래에서 자연스럽게 서비스할 수 있습니다.\n\n정리하면:\n\n| 역할        | 설명                                          |\n| ----------- | --------------------------------------------- |\n| source      | 사용자가 요청하는 경로                        |\n| destination | 실제 서비스하는 존의 URL (스킴 + 도메인 포함) |\n\n이렇게 쓰고, 필요한 경로마다 반복해서 추가해주면 돼요.\n\nNext.js 자체가 라우팅 기능이 뛰어나기는 한데, 멀티 존 환경에서는 이런 rewrite 기능을 활용하면 훨씬더 유연하게 운용할 수 있어서 꼭 한 번 적용해 보시길 추천드립니다!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n> 참고할 점: URL 경로는 각 존(zone)마다 고유해야 해요. 예를 들어, 두 존 모두 /blog 경로를 사용하려고 하면 라우팅 충돌이 발생할 수 있어요.\n\n### 미들웨어를 활용한 라우팅 요청 처리\n\n요청을 라우팅할 때 `rewrites`를 사용하는 게 지연 시간(latency)을 줄이는 데 추천되지만, 상황에 따라 동적으로 라우팅 결정을 해야 할 때는 미들웨어를 쓸 수도 있어요. 예를 들어, 마이그레이션 기간에 특정 경로의 라우팅을 기능 플래그(feature flag)로 제어하고 싶을 때 미들웨어가 아주 유용하답니다.\n\n아래는 그런 경우를 위한 간단한 미들웨어 예시예요:\n\n```js\nexport async function middleware(request) {\n  const { pathname, search } = request.nextUrl;\n  if (pathname === \"/your-path\" && myFeatureFlag.isEnabled()) {\n    return NextResponse.rewrite(`${rewriteDomain}${pathname}${search}`);\n  }\n}\n```\n\n여기서 `myFeatureFlag.isEnabled()`는 기능 플래그가 활성화됐는지 체크하는 함수고, 활성화되면 `/your-path` 경로로 들어오는 요청을 `rewriteDomain`으로 재작성(리라이트)해서 넘겨줘요.\n\n---\n\n추가로, 미들웨어를 너무 남발하면 오히려 성능 저하가 발생할 수 있으니, 꼭 필요한 경우에만 활용하는 게 좋아요. 그리고 미들웨어가 실행될 때는 서버에서 처리되므로, 요청 지연이 생길 수 있답니다. 따라서 단순 경로 변경이 목적이라면 rewrites 설정을 우선 고려해보세요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 존(zone) 간 링크 연결하기\n\n서로 다른 존에 있는 경로(path)로 연결할 때는 Next.js의 `Link` 컴포넌트 대신 일반 HTML의 `<a>` 태그를 사용하는 게 좋아요. 그 이유는 Next.js의 `Link` 컴포넌트는 상대 경로에 대해 사전에 데이터를 불러오고 부드럽게 페이지를 이동하는 동작(prefetch 및 soft navigation)을 시도하는데, 이 방식이 존을 넘나들 때는 제대로 작동하지 않거든요.\n\n즉, 존 간 이동은 그냥 `<a href=\"...\">` 태그를 써서 새로운 페이지를 불러오는 방식을 써야 버그 없이 쓸 수 있어요.\n\n---\n\n## 코드 공유하기\n\n여러 존을 구성하는 Next.js 애플리케이션들은 각기 다른 저장소(repository)에 있을 수도 있고, 한 저장소(monorepo)에 함께 모아 둘 수도 있어요. 개인적으로는 모노레포 구조가 코드 공유나 유지보수 면에서 훨씬 편리하다고 생각해요.\n\n만약 존이 각기 다른 레포에 흩어져 있다면, 공용(public) 또는 사설(private) NPM 패키지 형태로 코드를 공유하는 방법도 있어요. 예를 들어, 공통 유틸리티 함수나 컴포넌트들을 NPM 패키지로 만들어서 필요할 때마다 설치해서 사용하는 거죠.\n\n사실 개발하는 팀이나 프로젝트 규모에 따라 적합한 방식을 선택하면 되지만, 모노레포를 사용한다면 VSCode 같은 도구에서 한 번에 코드 검색도 되고, 빌드하고 테스트하기도 훨씬 수월해진다는 장점이 커요.\n\n---\n\n### 추가로 알아두면 좋은 팁\n\n- **모노레포 관리 툴**: `Nx`, `Turborepo`, `Lerna` 같은 도구를 활용하면 여러 애플리케이션과 패키지를 효과적으로 관리할 수 있어요.\n- **버전 관리**: 공유 NPM 패키지를 사용할 땐, 버전 관리를 잘 해야 하며, SemVer(유의적 버전관리)를 따르는 게 좋아요.\n- **빌드 속도**: 모노레포에서는 캐싱과 병렬 빌드를 적극 활용해서 빌드 속도를 개선할 수 있어요.\n\n이렇게 존 간 연동과 코드 공유를 잘 설계하면 여러 팀과 프로젝트가 협업하기 훨씬 수월해지니 한 번쯤은 이런 구조도 고민해보시길 추천드립니다!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n페이지들이 서로 다른 존(zone)에 걸쳐 있고 각각 출시되는 시기가 다를 수 있어서, 기능 플래그(feature flags)를 사용하면 다양한 존에서 기능을 동시에 켜거나 끌 때 굉장히 유용해요.\n\n특히 Vercel에서 Next.js 애플리케이션을 운영할 때는, 여러 존(zone)에 영향을 주는 코드를 한 번의 git 푸시로 배포하기 위해 모노레포(monorepo)를 사용하는 방법도 추천드려요. 이렇게 하면 관리가 훨씬 편해지고 배포 과정도 깔끔해집니다.\n\n---\n\n## 서버 액션(Server Actions)\n\nMulti-Zones 환경에서 서버 액션을 사용할 때는 사용자 앞단(origin)을 명시적으로 허용해줘야 해요. 왜냐하면 사용자 도메인이 여러 애플리케이션을 서빙할 수 있기 때문인데요. 이를 위해 `next.config.js` 파일에 다음과 같은 설정을 추가해주면 됩니다:\n\n```javascript\nmodule.exports = {\n  experimental: {\n    serverActions: true,\n  },\n  // 사용자 도메인을 명시적으로 허용합니다.\n  serverActions: {\n    allowedOrigins: [\"https://user-facing-domain.com\"],\n  },\n};\n```\n\n> 참고로, `allowedOrigins` 설정은 사용자의 브라우저에서 오는 요청이 신뢰할 수 있는 도메인에서 발생한 것인지 체크하는 역할을 합니다. 이걸 정확하게 설정해주지 않으면, 보안 문제가 발생할 수 있으니 꼭 필요한 도메인만 넣어주세요!\n\n이 외에도 multi-zone 환경에서 서버 액션을 제대로 활용하려면 CORS 설정이나 인증 관련 부분도 꼼꼼하게 챙기는 게 좋아요. 개발할 때 미리 여러 존의 도메인 구조를 파악해두면 배포와 운영이 훨씬 수월해질 거예요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서 `serverActions.allowedOrigins` 설정에 대해 알아볼게요!\n\n```js\nconst nextConfig = {\n  experimental: {\n    serverActions: {\n      allowedOrigins: [\"your-production-domain.com\"],\n    },\n  },\n};\n```\n\n이 설정은 Next.js가 실험적으로 도입한 Server Actions 기능과 관련돼요. Server Actions는 서버 쪽에서 실행되는 함수들을 클라이언트 사이드에서 직접 호출할 수 있게 해주는데, 이때 보안상 어디서 호출할 수 있는지를 제한하는 것이 중요해요. `allowedOrigins`는 그런 호출을 허용할 도메인 목록을 지정해 주는 역할을 해요.\n\n예를 들어, 위 코드에서 `your-production-domain.com` 도메인에서만 Server Actions가 허용되도록 설정한 거죠. 이렇게 하면, 다른 도메인에서 임의로 서버 액션을 호출하는 걸 막아서 보안이 강화돼요.\n\n### 추가로 알아두면 좋은 점\n\n- 이 기능은 아직 실험 단계(`experimental`)이기 때문에, 사용하려면 Next.js 버전과 문서를 수시로 체크하는 것이 좋아요.\n- 개발 환경에서는 `allowedOrigins`에 `localhost`도 넣어야 테스트가 가능해요.\n- 여러 도메인을 허용하고 싶다면 배열 안에 여러 도메인을 추가하면 됩니다.\n- 만약 CORS(Cross-Origin Resource Sharing)에 익숙하다면, 이 옵션이 CORS 정책과 유사하게 동작한다고 생각하면 쉬워요.\n\n```js\nconst nextConfig = {\n  experimental: {\n    serverActions: {\n      allowedOrigins: [\"your-production-domain.com\", \"localhost:3000\"],\n    },\n  },\n};\n```\n\n실제 배포할 때는 꼭 실제 서비스 도메인만 넣어두고, 테스트할 때 일시적으로 localhost를 추가하는 걸 추천해요!\n\n더 자세한 내용과 최신 정보는 공식 Next.js 문서에서 `serverActions.allowedOrigins` 항목을 참고하세요. 늘 변화가 빠른 Next.js에서 이런 실험적인 기능들을 잘 활용하면, 더 안전하고 효율적인 서버-클라이언트 통신이 가능해질 거예요!\n","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":13},{"title":"Vite에서 Next.js 15로 마이그레이션 하는 방법","description":"","date":"2025-04-22 01:30","slug":"2025-04-22-HowtomigratefromVitetoNextjs","content":"\n\n# Vite에서 Next.js로 마이그레이션하는 방법\n\n안녕하세요! 오늘은 Vite로 만들어진 기존 프로젝트를 Next.js로 옮기는 방법에 대해 이야기해볼게요. 요새 React 생태계에서 Next.js가 워낙 대세라서요, 프로젝트 확장성이나 SEO 같은 부분 때문에 넘어가는 분들이 많더라고요. \n\n## 왜 굳이 Next.js로 갈아타야 할까?\n\n사실 Vite도 빠르고 사용하기 편한 툴인데, Next.js로 갈아타는 몇 가지 이유가 있거든요.\n\n| 이유 | 설명 |\n|---|---|\n| **서버 사이드 렌더링(SSR)** | Next.js는 기본적으로 SSR을 지원해서 SEO에 훨씬 유리해요. Vite는 클라이언트 렌더링에 초점이 맞춰져 있죠. |\n| **파일 기반 라우팅** | Next.js는 폴더 구조만 잘 맞추면 라우팅 설정이 자동으로 되어 개발 속도가 빨라져요. Vite는 라우터 설정을 직접 해줘야 하죠. |\n| **API 라우트 지원** | Next.js 내에서 API 엔드포인트를 쉽게 만들 수 있어 백엔드 & 프론트엔드 통합이 편리해요. Vite는 보통 별도의 서버를 띄워야 해요. |\n| **강력한 커뮤니티와 플러그인** | Next.js는 많은 플러그인과 라이브러리가 있어서 생태계가 풍부하고, 지원도 활발해요. |\n\n사실 프로젝트 규모가 커지고, SEO가 중요해지고, 좀 더 안정적인 서버 사이드 렌더링이 필요하다면 Next.js는 거의 필수 선택지라고 할 수 있겠네요!\n\n다음 포스팅에서는 실제로 Vite 프로젝트를 어떻게 Next.js 프로젝트로 옮길지, 단계별로 자세히 알려드릴게요. 기대해주세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 느린 초기 페이지 로딩 시간\n\n만약 기본 Vite 플러그인으로 리액트 애플리케이션을 만들었다면, 여러분의 앱은 순수한 클라이언트 사이드 애플리케이션입니다. 이렇게 클라이언트 사이드에서만 앱을 실행하는 방식, 즉 흔히 싱글 페이지 애플리케이션(SPA)이라고 하죠. 이 방식은 보통 초기 페이지 로딩 속도가 느려지는 문제가 발생합니다. 왜 그런지 간단히 살펴볼게요.\n\n- 브라우저가 여러분의 리액트 코드와 전체 애플리케이션 번들을 내려받고 실행하기 전까지는 데이터 요청조차 시작할 수 없습니다.\n- 시간이 지나면서 기능이 추가되고 의존성도 늘어나면서 애플리케이션 코드가 점점 커져서 더 오래 걸리게 됩니다.\n\n즉, 초기 로딩에 필요한 코드가 한 번에 너무 많아서 브라우저가 버거워하는 상황인 거죠.\n\n### 자동 코드 분할이 없다면?\n\n자동 코드 분할이란 쉽게 말해, 필요한 코드만 쪼개서 나중에 불러오는 걸 의미해요. 하지만 기본 설정으로 만든 Vite + React 프로젝트엔 이 기능이 적용되어 있지 않습니다. 그래서 앱 전체 코드를 한 번에 내려받아야 하죠.\n\n자동 코드 분할이 없으면 다음과 같은 단점이 있어요.\n\n| 문제점              | 설명                                                                                     |\n|-----------------|----------------------------------------------------------------------------------------------|\n| 초기 로딩 느림      | 모든 코드가 한 번에 내려오니까 페이지가 뜨기까지 기다려야 하는 시간이 길어짐                                       |\n| 불필요한 코드 다운로드 | 현재 페이지에서 필요하지 않은 코드도 같이 받게 되어 네트워크 자원이 낭비됨                                                |\n| 사용자 경험 저하    | 로딩 시간이 길어지면 방문자가 페이지 이탈할 확률이 높아짐                                                         |\n\n자동 코드 분할을 도입하면 첫 페이지 로딩은 가볍게, 이후 필요한 기능은 필요한 순간에 불러올 수 있어 앱 속도가 체감상 빨라집니다.\n\n---\n\n### 추가 팁: 해결책으로 SSG/SSR 도입하기\n\n초기 로딩 속도를 확실히 개선하고 싶다면, 서버 사이드 렌더링(SSR)이나 정적 사이트 생성(SSG)을 도입하는 것도 좋은 방법입니다. Next.js 같은 프레임워크는 기본적으로 이 기능들을 지원해요. 요청 시 서버에서 미리 렌더링된 HTML을 보내면 브라우저가 JS 실행을 기다리지 않아도 빠르게 페이지를 보여줄 수 있죠.\n\n단, SSR/SSG는 설정이 좀 더 복잡할 수 있으니 상황과 요구에 맞게 도입하면 됩니다.\n\n---\n\n이처럼 리액트 앱 개발할 때 초기 로딩 속도 문제는 SPA의 흔한 고민이고, 자동 코드 분할 또는 SSR/SSG 같은 기술을 적절히 적용하면 훨씬 개선할 수 있어요. 앞으로 프로젝트에 적용해 보면서 체감 성능을 경험해보시길 바랍니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이전 글에서 언급한 느린 로딩 문제는 코드 스플리팅(code splitting)으로 어느 정도 해결할 수 있어요. 그런데 직접 수동으로 코드 스플리팅을 하려고 하면 오히려 성능이 더 안 좋아질 수도 있어요. 수동으로 코드를 나누다 보면 네트워크 워터폴(Network waterfalls, 요청이 순차적으로 쌓여서 느려지는 현상)이 쉽게 발생할 수 있거든요. 다행히 Next.js는 자체 라우터에 자동 코드 스플리팅 기능이 내장되어 있어서 이런 문제를 훨씬 간편하게 해결할 수 있어요.\n\n### 네트워크 워터폴(Network waterfalls)이란?\n\n네트워크 워터폴은 애플리케이션이 클라이언트와 서버 사이에서 순차적으로 여러 데이터를 요청할 때 발생하는 성능 저하 현상이에요. SPA(싱글 페이지 애플리케이션)에서 데이터를 받아올 때 주로, 처음에는 로딩용 자리 표시자(placeholder)를 렌더링하고, 컴포넌트가 마운트된 후에야 데이터를 받아오는 패턴이 많죠. 이 경우 하위 컴포넌트가 데이터를 요청하려면, 반드시 상위 컴포넌트가 자신의 데이터를 모두 받은 뒤여야 해서 대기시간이 길어질 수밖에 없습니다.\n\nNext.js는 클라이언트에서 데이터를 받아오는 것도 지원하지만, 데이터 페칭을 서버 사이드에서 처리하게끔 선택할 수도 있어요. 서버에서 데이터를 미리 받아서 렌더링하면 이런 클라이언트-서버 워터폴 현상을 완전히 없앨 수 있답니다.\n\n---\n\n마치면서 한 가지 팁!  \n서버 사이드 렌더링(SSR)이나 SSG(정적 사이트 생성)를 활용하면, 페이지 렌더링 전에 데이터를 미리 받아오기 때문에 사용자 입장에서 훨씬 빠른 초기 로딩을 경험할 수 있어요. Next.js의 `getServerSideProps`나 `getStaticProps` 같은 함수들이 그 역할을 하니, 꼭 활용해보세요!\n\n---\n\n| 개념          | 설명                                                                                  |\n|--------------|-------------------------------------------------------------------------------------|\n| 코드 스플리팅    | 자바스크립트 코드를 여러 덩어리로 나누어 필요한 부분만 불러와 초기 로딩 속도를 개선하는 방법                   |\n| 네트워크 워터폴 | 클라이언트와 서버가 요청을 연속적으로 주고받아서 응답시간이 길어지는 현상                                        |\n| Next.js 자동 코드 스플리팅 | Next.js의 라우터가 페이지별로 자동으로 코드 스플리팅을 해주어 성능 최적화를 돕는 기능                           |\n| 서버 사이드 데이터 페칭 | Next.js가 페이지 렌더링 전에 서버에서 데이터를 미리 받아와 클라이언트-서버 간 요청 지연 문제를 해결하는 방식          |\n\n필요하면 다음 글에서 Next.js의 데이터 페칭 방법과 활용법도 자세히 알려드릴게요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 빠르고 의도적인 로딩 상태 관리\n\nReact Suspense가 스트리밍을 기본적으로 지원하면서, 어떤 UI 부분을 먼저 로딩할지, 또 어떤 순서로 로딩할지 더 세심하게 설계할 수 있게 되었습니다. 덕분에 네트워크 워터폴(waterfall) 현상을 피할 수 있죠.\n\n네트워크 워터폴이란, 한 요청이 끝나야 다음 요청이 시작되는 상황을 말하는데, 이게 계속 쌓이면 로딩 속도가 느려져 사용자 경험이 떨어집니다. Suspense를 사용하면 여러 컴포넌트를 병렬로 로딩하면서도 사용자에게 매끄럽게 보여줄 수 있어서, 페이지 로딩 속도도 빨라지고 레이아웃이 불안정하게 변하는 문제(layout shift)도 줄일 수 있습니다.\n\n### 데이터 패칭(가져오기) 전략 선택하기\n\n내가 배운 바로는, 데이터 패칭 전략을 잘 선택하는 게 매우 중요해요. 예를 들어, 모든 데이터를 한 번에 가져오느냐, 필요한 데이터만 나눠서 가져오느냐에 따라 성능과 사용자 경험이 확 달라집니다.\n\n아래 표는 다양한 데이터 패칭 전략과 그 특징을 간단히 정리한 거예요.\n\n| 전략                   | 설명                                  | 장점                          | 단점                          |\n|----------------------|-------------------------------------|-----------------------------|-----------------------------|\n| 전체 데이터 한 번에 로드    | 페이지 로드 시 모든 데이터를 한꺼번에 요청           | 초기 로딩 후 빠른 탐색 가능           | 초기 로딩 시간 길어짐               |\n| 필요한 데이터만 나눠서 로드 | 필요한 부분만 요청, 점진적 로딩 지원                  | 빠른 초기 로딩, 네트워크 부하 분산       | 구현 복잡도 증가                    |\n| 캐싱 활용               | 요청한 데이터를 캐싱하여 재사용                        | 불필요한 중복 요청 방지                 | 데이터 최신성 관리 필요              |\n| 스트리밍                 | React Suspense와 함께 스트리밍 데이터 로딩 활용          | 사용자에게 빠르게 부분 렌더링 가능       | 서버 및 클라이언트 세팅 복잡           |\n\n특히 React Suspense와 같은 최신 기능들을 활용하면, 스트리밍 방식으로 데이터를 점진적으로 받아오면서 사용자에게 빠른 피드백을 줄 수 있어요. 개발자로서 이런 점들을 염두에 두면, 퍼포먼스 좋은 앱을 만드는 데 큰 도움이 됩니다.\n\n---\n\n궁금한 점 있으면 언제든 댓글로 남겨주세요! 앞으로도 이런 실용적인 개발 팁들을 계속 공유할게요 :)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js는 상황에 맞게 페이지나 컴포넌트 단위로 데이터 가져오기 전략을 선택할 수 있도록 유연성을 제공합니다. 예를 들어, 빌드 시점에 데이터를 가져와서 CMS에 있는 블로그 포스트를 렌더링하고, 이를 CDN에 캐시해서 빠르게 서비스할 수 있어요. 또는 서버 요청 시점이나 클라이언트에서 데이터를 받아서 동적으로 처리할 수도 있죠. 이렇게 상황에 따라 가장 적합한 방식을 선택할 수 있다는 게 Next.js의 큰 장점 중 하나랍니다.\n\n### 미들웨어 (Middleware)\n\nNext.js의 미들웨어는 서버에서 요청이 완료되기 전에 코드를 실행할 수 있도록 해줍니다. 예를 들어, 로그인해야 볼 수 있는 페이지에 사용자가 접근했을 때, 잠깐 인증이 안 된 페이지가 보이는 ‘깜빡임(flash)’ 현상을 막고 바로 로그인 페이지로 리다이렉트할 수 있어요. 이 외에도 새로운 기능을 실험해보거나, 다국어 지원 같은 국제화 작업에 아주 유용하죠. 미들웨어가 있다 보니 이런 작업들이 좀 더 자연스럽고 효율적으로 처리됩니다.\n\n### 내장 최적화 기능\n\nNext.js는 개발자가 따로 신경 쓰지 않아도 자동으로 여러 최적화를 수행합니다. 예를 들어, 이미지 최적화, 번들 크기 최소화, 코드 스플리팅, 그리고 사전 렌더링 같은 기능들이 모두 내장되어 있어요. 특히 이미지 최적화는 웹 페이지 로딩 속도를 크게 높여주니, 사용자 경험 개선에 큰 효과가 있답니다. 덕분에 복잡한 설정 없이도 빠르고 효율적인 웹사이트를 만들 수 있어요.\n\n---\n\nNext.js를 처음 접하는 분들은 이런 데이터 페칭과 미들웨어, 그리고 최적화 기능들이 어떻게 연결되는지 이해하는 게 중요해요. 다양한 상황에 맞게 전략을 골라 사용하면 사이트 성능을 최대로 끌어올릴 수 있으니까요! 만약 이 부분들이 더 궁금하다면 다음 포스트에서 각 전략별 예제와 함께 자세히 설명해볼게요 :)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이미지, 폰트, 그리고 서드파티 스크립트는 애플리케이션 성능에 꽤 큰 영향을 줘요. 다행히 Next.js에는 이런 요소들을 자동으로 최적화해주는 내장 컴포넌트들이 있어서 성능 관리를 훨씬 쉽게 해줍니다.\n\n---\n\n## 마이그레이션 단계\n\n이번 마이그레이션 목표는 최대한 빠르게 Next.js 기반의 작동하는 애플리케이션을 만드는 거예요. 그 후에 필요에 따라 Next.js의 여러 기능을 차근차근 적용해 나가면 돼요. 처음에는 기존 라우터를 그대로 두고, 순수 클라이언트 사이드 애플리케이션(SPA)으로만 유지하는 방식으로 진행할 거예요. 이렇게 하면 마이그레이션 중에 발생할 수 있는 문제나 병합 충돌을 최소화할 수 있습니다.\n\n---\n\n### 1단계: Next.js 의존성 설치하기\n\n마이그레이션의 첫걸음은 Next.js 패키지를 프로젝트에 추가하는 것부터 시작합니다. 이 부분은 기본 중의 기본이니까 꼼꼼하게 설치해 주세요! 다음 명령어를 터미널에 입력하면 됩니다:\n\n```bash\nnpm install next react react-dom\n```\n\n또는 yarn을 사용한다면,\n\n```bash\nyarn add next react react-dom\n```\n\n이렇게 하면 Next.js가 필요로 하는 핵심 라이브러리들이 프로젝트에 추가됩니다.\n\n> 참고로, Next.js는 React 기반 프레임워크라 React와 ReactDOM도 함께 설치해야 해요. 이미 설치되어 있다면 중복 설치가 되지 않으니 걱정하지 않아도 됩니다!\n\n설치가 완료됐으면, 다음 단계로 넘어가서 실제로 Next.js 프로젝트 구조에 맞게 파일들을 조금씩 정리해보도록 할게요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n먼저, Next.js를 사용하기 위해서는 프로젝트에 Next를 의존성으로 설치해야 해요:\n\n```bash\nnpm install next@latest\n```\n\n### 2단계: Next.js 설정 파일 만들기\n\n프로젝트 루트에 `next.config.mjs` 파일을 만들어주세요. 이 파일은 Next.js의 다양한 설정 옵션들을 담고 있어요.\n\n> 참고로 이 설정 파일은 JavaScript나 TypeScript 파일처럼 동작하지만, `.mjs` 확장자를 사용하면 ES 모듈 방식을 명확히 하게 돼서 최근 Next.js 프로젝트에서 권장되고 있답니다.  \n\n필요한 설정들을 여기서 자유롭게 추가해서 프로젝트 요구사항에 맞게 조절해보세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n자, 이번에는 Next.js 설정 파일을 조금 바꿔볼게요! 위 예제 코드는 `next.config.js` 파일에 들어갈 내용인데요. \n\n```js\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  output: 'export',    // 이 설정은 Next.js를 SPA(단일 페이지 애플리케이션)로 내보내도록 해줘요.\n  distDir: './dist',   // 빌드 결과물을 기본 폴더가 아닌 './dist' 폴더에 저장해요.\n}\n\nexport default nextConfig\n```\n\n> 참고로, Next.js 설정 파일은 `.js` 뿐만 아니라 `.mjs` 확장자를 써도 무방해요. 그래서 프로젝트 스타일에 맞게 골라 쓰시면 됩니다.\n\n그리고 이제 TypeScript를 쓰는 분들은 tsconfig.json 파일을 수정해줘야 해요! Next.js와 호환되게끔 일부 설정을 바꿔줘야 하거든요. 만약 TypeScript를 쓸 필요가 없다면 이 부분은 건너뛰셔도 되니까 부담 갖지 마세요.\n\n---\n\n### TypeScript 사용자라면 tsconfig.json 수정하는 팁!\n\nNext.js는 TypeScript를 공식 지원하지만, 기본 설정이 Next.js 빌드 시스템에 맞게끔 커스텀 필요가 있어요. 보통은 다음과 같이 `compilerOptions`와 같이 설정합니다:\n\n| 옵션               | 설명                                        |\n|--------------------|---------------------------------------------|\n| `jsx`              | React JSX 변환 설정 (예: `\"react-jsx\"`)      |\n| `module`           | 모듈 시스템 (주로 `\"esnext\"` 사용)            |\n| `target`           | 컴파일 타겟팅 자바스크립트 버전                |\n| `strict`           | 엄격한 타입 체크 설정                         |\n| `baseUrl`           | 절대 경로 기준 디렉토리                          |\n| `paths`            | 모듈 경로 별칭 설정                           |\n\n예를 들어, tsconfig.json에 다음처럼 넣으면 더 편리하답니다:\n\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"es5\",\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"allowJs\": true,\n    \"skipLibCheck\": true,\n    \"strict\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"noEmit\": true,\n    \"esModuleInterop\": true,\n    \"module\": \"esnext\",\n    \"moduleResolution\": \"node\",\n    \"resolveJsonModule\": true,\n    \"isolatedModules\": true,\n    \"jsx\": \"react-jsx\"\n  },\n  \"include\": [\"next-env.d.ts\", \"**/*.ts\", \"**/*.tsx\"],\n  \"exclude\": [\"node_modules\"]\n}\n```\n\n이렇게 하면 Next.js에서 TypeScript를 더 원활하게 사용할 수 있답니다. 더 궁금하면 언제든 물어봐 주세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nTypeScript 설정을 하면서 다음과 같은 변경사항을 적용해봤어요.\n\n- `tsconfig.node.json` 프로젝트 참조 제거\n- `include` 배열에 `./dist/types/**/*.ts` 와 `./next-env.d.ts` 추가\n- `exclude` 배열에 `./node_modules` 추가\n- `compilerOptions`의 `plugins` 배열에 `\"name\": \"next\"` 추가\n- `esModuleInterop`을 `true`로 설정\n- `jsx`를 `\"preserve\"`로 설정\n- `allowJs`를 `true`로 설정\n- `forceConsistentCasingInFileNames`를 `true`로 설정\n- `incremental`을 `true`로 설정\n\n아래는 이렇게 수정된 `tsconfig.json` 예시입니다:\n\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2020\",\n    \"useDefineForClassFields\": true,\n    \"lib\": [\"ES2020\", \"DOM\", \"DOM.Iterable\"],\n    \"module\": \"ESNext\",\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"moduleResolution\": \"bundler\",\n    \"allowImportingTsExtensions\": true,\n    \"resolveJsonModule\": true,\n    \"isolatedModules\": true,\n    \"noEmit\": true,\n    \"jsx\": \"preserve\",\n    \"strict\": true,\n    \"noUnusedLocals\": true,\n    \"noUnusedParameters\": true,\n    \"noFallthroughCasesInSwitch\": true,\n    \"allowJs\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"incremental\": true,\n    \"plugins\": [{ \"name\": \"next\" }]\n  },\n  \"include\": [\"./src\", \"./dist/types/**/*.ts\", \"./next-env.d.ts\"],\n  \"exclude\": [\"./node_modules\"]\n}\n```\n\n---\n\n조금 더 풀어 이야기하자면,\n\n- `esModuleInterop: true`는 CommonJS 모듈과 ES 모듈 간의 호환성을 좋게 해줍니다. 그래서 `import` 구문을 쓸 때 오류를 줄여줘요.\n- `jsx: \"preserve\"`는 JSX를 컴파일하지 않고 그대로 두라는 뜻인데, Next.js가 자체적으로 처리하기 때문에 이렇게 해주는게 일반적이에요.\n- `allowJs: true`를 켜면 자바스크립트 파일도 TS 빌드 대상에 포함할 수 있어서, 점진적으로 타입스크립트로 이전하려는 프로젝트에서 유용합니다.\n- `forceConsistentCasingInFileNames: true` 설정은 대소문자 차이로 생기는 파일 경로 문제를 예방해줍니다. 특히 OS마다 대소문자 구분이 다른 경우에 꼭 필요해요.\n- `incremental: true`는 빌드 속도를 향상시키기 위해 이전 빌드 정보를 캐싱해주는 기능입니다. 개발할 때 시간 절약에 큰 도움이 돼요.\n- 플러그인에 `\"name\": \"next\"`를 넣으면 Next.js에서 권장하는 타입스크립트 플러그인을 사용하게 됩니니다.\n\nNext.js 공식 문서에도 TypeScript 구성에 대한 좋은 안내가 있으니, 필요하면 꼭 참고해보세요.  \nhttps://nextjs.org/docs/basic-features/typescript\n\n이 설정을 기반으로 프로젝트를 구성하면 Next.js + TypeScript 환경에서 좀 더 편리하고 안정적으로 개발하실 수 있습니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 4단계: 루트 레이아웃 만들기\n\nNext.js의 App Router를 사용할 때는 루트 레이아웃(root layout) 파일이 꼭 필요해요. 이 파일은 React Server Component로, 여러분의 앱 안에 있는 모든 페이지를 감싸는 역할을 하죠. 그리고 이 파일은 `app` 디렉토리의 최상단에 위치해야 합니다.\n\n비슷한 개념을 Vite 앱에서 찾자면, 바로 `index.html` 파일이에요. 이 파일이 여러분의 HTML, head, body 태그를 포함하고 있어서, Next.js에서 말하는 루트 레이아웃과 가장 비슷한 역할을 하죠.\n\n이번 단계에서는 여러분의 `index.html` 파일을 Next.js의 루트 레이아웃 파일로 변환해볼 거예요. \n\n---\n\n여기서 꼭 짚고 넘어갈 점은 Next.js에서는 이 루트 레이아웃이 React 컴포넌트라는 거예요. 단순히 HTML 파일이 아니라 리액트 컴포넌트로 작성되니, 필요한 경우 React의 훅이나 다른 컴포넌트로 기능 확장이 훨씬 쉬워요. 즉, 더 동적이고 유연한 레이아웃 구성이 가능하다는 거죠.\n\n그럼 이제 `index.html`에서 어떤 부분을 어떻게 바꿔주면 될지 살펴볼게요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이번에는 Next.js 프로젝트에서 새로운 앱 디렉토리를 만들고, 레이아웃 설정을 하는 방법을 알려드릴게요. 특히 Next.js 13 버전에서 도입된 '새로운 app 디렉토리 구조'를 활용하는 예제인데요, 코드 설명도 곁들여서 천천히 같이 보시죠!\n\n---\n\n### 1. `src` 안에 `app` 디렉토리 만들기\n\n먼저, 프로젝트 폴더 안 `src` 디렉토리 안에 `app` 폴더를 새로 만들어줘요. 여기서부터 우리 앱의 페이지, 레이아웃 등이 관리될 거예요.\n\n\nsrc/\n  └── app/\n\n\n---\n\n### 2. `RootLayout` 컴포넌트 만들기 (`layout.tsx`)\n\n`app` 폴더 안에 `layout.tsx` 파일을 하나 새로 만들어요. 이 파일은 페이지들의 공통 레이아웃을 담당합니다.\n\n```tsx\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return '...'\n}\n```\n\n- `children`은 이 레이아웃 안에 렌더링될 페이지나 하위 컴포넌트들을 의미해요.\n- 중요! `layout.tsx` 같은 레이아웃 파일 확장자는 `.js`, `.jsx`, `.tsx` 중 원하시는 걸로 써도 된답니다.\n\n---\n\n### 3. 기존 `index.html` 내용을 `RootLayout` 안에 넣기\n\n보통 React 프로젝트에는 `public/index.html` 파일이 있는데요, 여기에는 `<body><div id=\"root\"></div></body>` 같은 구조가 있어요. 이것을 Next.js의 레이아웃 컴포넌트에 맞게 바꿔줘야 해요.\n\n- `body` 안의 `<div id=\"root\"></div>` 대신에 JSX 문법을 사용해서 `<div id=\"root\">{children}</div>` 식으로 바꿔줍니다.\n- `<script>` 태그나 직접적으로 body 바로 아래에 있는 태그들은 Next.js의 자동 렌더링 및 페이지 컴포넌트 구조에서 관리하니 제거하거나 옮겨줘야 해요.\n\n아래처럼 작성할 수 있겠죠?\n\n```tsx\nexport default function RootLayout({ children }: { children: React.ReactNode }) {\n  return (\n    <html>\n      <head>\n        {/* 여기에 메타 태그, 폰트 링크 등 head 요소를 넣어줄 수 있어요 */}\n      </head>\n      <body>\n        <div id=\"root\">{children}</div>\n      </body>\n    </html>\n  )\n}\n```\n\n---\n\n### 잠깐, 여기서 팁!\n\n- Next.js 13부터는 `app` 디렉토리 내에서 레이아웃 또는 페이지가 기본적으로 서버 컴포넌트(Server Component)로 동작해요.\n- 따라서 클라이언트 사이드 상태 관리 등이 필요하면 `'use client'`를 꼭 넣어줍니다.\n- 그리고 기존에 `<div id=\"root\">`를 React 엔트리포인트로만 사용했던 것과 달리, Next.js에서는 `app` 구조가 페이지마다 분리돼서 더 깔끔하고 모듈화된 방식으로 관리돼요.\n\n---\n\n요약하자면:  \n`src/app/layout.tsx`를 만들고, 기존 HTML 구조를 이 안에 JSX로 옮기면서 `<div id=\"root\">{children}</div>` 형태로 바꿔주면 이제 Next.js 13 스타일의 앱 레이아웃 설정이 끝! 앞으로 페이지 컴포넌트도 이 안에서 자연스럽게 렌더링 될 거예요.\n\n궁금한 점 있으면 편하게 물어봐 주세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js를 사용하다 보면, 기본적으로 `<head>`에 들어가는 `meta charset`이나 `meta viewport` 태그가 자동으로 포함되어 있다는 점을 알게 될 거예요. 그래서 직접 이런 태그들을 작성할 필요가 없답니다! 조금 더 깔끔하고 관리하기 편하게 아래처럼 수정할 수 있어요.\n\n```js\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <head>\n        <link rel=\"icon\" type=\"image/svg+xml\" href=\"/icon.svg\" />\n        <title>My App</title>\n        <meta name=\"description\" content=\"My App is a...\" />\n      </head>\n      <body>\n        <div id=\"root\">{children}</div>\n      </body>\n    </html>\n  )\n}\n```\n\n여기서 조금 더 팁을 드리자면, favicon.ico, icon.png, robots.txt 같은 메타데이터 파일들이 있다면, 이걸 직접 `<head>`에 `link` 태그로 명시하지 않아도 돼요. Next.js가 여러분의 앱 디렉토리 최상단에 이런 파일들이 있는지 자동으로 체크해서 `<head>`에 넣어주거든요.\n\n즉, 이런 작업 구조가 가능해요:\n\n| 위치                  | 역할                                          |\n|---------------------|---------------------------------------------|\n| `app/favicon.ico`    | 파비콘 자동 등록                              |\n| `app/robots.txt`    | 검색 엔진 크롤러에서 참고하는 robots 파일 자동 포함  |\n| `app/icon.svg`       | SVG 아이콘 자동 등록                            |\n\n따라서, 이런 파일들만 잘 관리해두면 `link` 태그를 따로 추가하거나 지저분하게 관리할 필요가 없답니다.\n\n---\n\n> 🚀 **한가지 알아두면 좋은 점!**  \n> Next.js의 이런 자동화 덕분에 앱 구조가 훨씬 깔끔하고 유지보수가 편해져요. 그리고 혹시 이런 메타데이터를 동적으로 변경하고 싶다면 Next.js 13부터 도입된 `metadata` API도 활용해보세요! 훨씬 더 편리하게 SEO 최적화가 가능합니다.\n\n궁금한 게 있으면 언제든지 물어봐 주세요! 😊\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서 head 태그를 관리하는 새로운 방법, Metadata API에 대해 이야기해볼게요. 원래는 아래처럼 직접 `<head>` 태그 안에 title이나 meta를 적었었죠.\n\n```jsx\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <head>\n        <title>My App</title>\n        <meta name=\"description\" content=\"My App is a...\" />\n      </head>\n      <body>\n        <div id=\"root\">{children}</div>\n      </body>\n    </html>\n  )\n}\n```\n\n그런데 Next.js는 이제 Metadata API라는 깔끔한 방식을 제공합니다. 이걸 쓰면 메타데이터를 컴포넌트 바깥에 `export const metadata`로 분리할 수 있어요. 코드가 더 간결해지고, SEO 최적화나 공유할 때 이점도 커지죠:\n\n```tsx\nimport type { Metadata } from 'next'\n\nexport const metadata: Metadata = {\n  title: 'My App',\n  description: 'My App is a...',\n}\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <body>\n        <div id=\"root\">{children}</div>\n      </body>\n    </html>\n  )\n}\n```\n\n이렇게 바꾸면 `head` 태그 자체는 선언하지 않고도 메타데이터가 Next.js에 의해 자동으로 관리되니까 훨씬 깔끔하고 유지보수도 쉽습니다. 그리고 나중에 동적으로 제목이나 설명을 바꾸고 싶을 때도 이 Metadata API가 더 편리해요.\n\n참고로, 이 방식은 `/app` 디렉토리를 사용하는 Next.js 13 이상에서 권장되는 최신 방법이라는 점 꼭 기억하세요! 만약 아직 `pages` 디렉토리를 쓰고 있다면 다음 업그레이드 때 도입해 보시면 좋을 것 같아요.\n\n요약하자면, Metadata API는 다음과 같은 장점이 있어요:\n\n| 장점            | 설명                                                         |\n|-----------------|--------------------------------------------------------------|\n| 코드 분리       | 메타데이터를 컴포넌트 코드에서 분리해 관리가 편리해짐          |\n| 자동 관리       | Next.js가 head 태그를 자동으로 처리해 실수를 줄임             |\n| SEO & 공유 최적화 | SEO 관련 메타 정보와 소셜 미디어 공유 정보까지 쉽게 설정 가능  |\n| 타입 지원       | 타입스크립트 Metadata 타입 제공으로 안정성 증가               |\n\n이렇게 공식 문서를 따라가면 Next.js 프로젝트가 한층 더 체계적이고 깔끔해질 거예요! 꼭 한번 써보세요 :)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 5단계: 진입점 페이지 만들기\n\nNext.js에서는 앱의 진입점을 만들 때 `page.tsx` 파일을 작성하는 식으로 선언해요. 이걸 Vite로 치환하면, 보통 `main.tsx` 파일이 진입점 역할을 하게 됩니다. 이번 단계에서는 여러분 앱의 진입점(첫 시작점)을 설정해볼 거예요.\n\n- `app` 디렉토리 안에 `[[...slug]]`라는 이름의 폴더를 생성하세요.\n\n여기서 잠깐! 우리가 이번 가이드에서 Next.js를 SPA(싱글 페이지 애플리케이션)처럼 사용하려고 하거든요. 그러려면 앱의 첫 페이지가 모든 가능한 경로를 받아서 처리해야 합니다. 그래서 `app` 디렉토리에 `[[...slug]]`라는 폴더를 만들어서, 어떤 경로든 이 폴더가 잡아내서 라우팅할 수 있도록 하는 거죠.\n\n---\n\n추가로 설명을 좀 하자면, Next.js에서는 `[[...slug]]`와 같은 경로 패턴이 \"캐치올(catch-all)\" 라우팅 기능을 의미해요. 쉽게 말해서, URL에 뭘 붙여도 다 여기서 받겠다는 뜻이죠. 그래서 SPA를 구현할 때 정말 유용합니다. Vite 같은 도구에서는 이런 라우팅을 직접 구현하거나 라이브러리를 붙여야 하는데, Next.js가 너무 잘해주는 부분이죠!\n\n---\n\n혹시 React Router를 써서 SPA를 만든다면, 이런 \"모든 경로를 캐치하는\" 룰을 `<Route path=\"*\">` 같은 식으로 걸어줄 수 있다는 점도 기억해 두세요. SPA의 핵심은 결국 한 페이지에서 모든 라우팅을 내부에서 다 처리하는 거니까요.\n\n---\n\n정리하자면:\n\n- `[[...slug]]` 폴더 생성 → Next.js의 캐치올 라우팅\n- SPA처럼 모든 경로를 한 페이지에서 처리\n- Vite는 `main.tsx`가 진입점\n\n이렇게 세팅하면 여러분 앱이 다양한 경로에서 잘 반응하는 싱글 페이지 앱이 되겠죠? 다음 단계도 같이 기대해 주세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서는 폴더 구조가 라우트를 정의하는 중요한 역할을 해요. 여기서 소개한 `app/[[...slug]]` 디렉토리는 '옵셔널 캐치-올(optional catch-all)' 라우트 세그먼트라고 불려요. 쉽게 말하면, 이 폴더 안에 있는 페이지가 애플리케이션의 모든 경로를 잡아주도록 설정하는 거죠.\n\n### 직접 해보기\n`app/[[...slug]]` 안에 `page.tsx` 파일을 새로 만들고, 아래 내용을 넣어보세요:\n\n```tsx\nimport '../../index.css'\n\nexport function generateStaticParams() {\n  return [{ slug: [''] }]\n}\n\nexport default function Page() {\n  return '...' // 나중에 업데이트할 예정이에요\n}\n```\n\n- 여기서 `generateStaticParams` 함수는 빌드 시에 미리 정적 페이지를 생성하기 위한 파라미터를 반환해요. 예제에선 빈 slug 배열을 반환해서 기본 경로를 세팅하고 있어요.\n- `Page` 컴포넌트는 현재 그냥 문자열을 반환하는 기본 상태인데, 이후에 이 부분을 다양한 경로에 맞게 확장할 수 있습니다.\n\n> 참고로, Next.js에서는 Page 컴포넌트 파일 이름에 `.js`, `.jsx`, `.tsx` 어떤 확장자든 사용할 수 있어요. 여러분이 편한 걸로 쓰면 됩니다!\n\n이렇게 설정하면, 어떤 URL로 접근하든 여기 있는 `page.tsx`가 먼저 실행되어서 복잡한 라우팅 처리를 중앙 집중화 할 때 유용해요. 예를 들어 블로그의 포스트 여러 개를 한 페이지 컴포넌트에서 처리한다든지 할 때 쓰이죠.\n\n---\n\n추가로 Tip!\n- `[...slug]`는 캐치-올 라우트(segment all)인데 필수로 하나 이상의 값이 있어야 합니다.\n- `[[...slug]]`는 옵셔널 캐치-올이라 slug가 없어도 이 라우트가 적용돼요.\n- 이렇게 라우트를 잡으면 동적 경로도 쉽게 만들 수 있어요.\n\nNext.js 라우팅 좀 더 편하게 하고 싶다면, 이런 옵셔널 캐치-올 라우트 구조를 꼭 알아두면 좋아요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 파일은 서버 컴포넌트(Server Component)예요. `next build` 명령어를 실행하면 이 파일은 미리 렌더링(prerendering)되어 정적인 자산(static asset)으로 만들어집니다. 즉, 동적 코드가 필요 없다는 뜻이죠.\n\n이 파일은 글로벌 CSS를 불러오고, `generateStaticParams` 함수에서는 오직 인덱스 경로인 `/` 하나만 정적으로 생성할 것이라고 알려줘요.\n\n그럼 이제 나머지 Vite 애플리케이션 부분을 클라이언트 전용(Client-only)으로 옮겨볼게요. 다음처럼 작성하면 Next.js에서 클라이언트 전용 컴포넌트를 쉽게 다룰 수 있어요.\n\n```jsx\n'use client'\n\nimport React from 'react'\nimport dynamic from 'next/dynamic'\n\nconst App = dynamic(() => import('../../App'), { ssr: false })\n\nexport function ClientOnly() {\n  return <App />\n}\n```\n\n여기서 핵심은 `dynamic` 함수를 쓰면서 `{ ssr: false }` 옵션을 넣는 부분이에요. 이걸 통해서 서버 사이드 렌더링(SSR)을 비활성화하고, 해당 컴포넌트를 클라이언트에서만 불러오도록 설정합니다. 보통 Vite처럼 클라이언트 전용 라이브러리를 사용할 때 이렇게 하면 에러 없이 잘 작동하죠.\n\n또, `'use client'` 디렉티브를 최상단에 넣는 것도 잊지 마세요. 이건 Next.js 13 버전부터 도입된 문법인데, 해당 파일이 클라이언트 컴포넌트임을 명시해줍니다.\n\n---\n\n**TIP**: 클라이언트 컴포넌트를 이렇게 분리해서 관리하면 서버 컴포넌트와 클라이언트 컴포넌트의 역할 분담이 명확해져서 유지보수도 훨씬 쉬워져요. 또한, 초기 페이지 로딩 속도도 더 좋아질 수 있으니 적극 추천합니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 파일은 `use client` 지시어로 정의된 클라이언트 컴포넌트입니다. 클라이언트 컴포넌트라도 Next.js에서는 처음에 서버에서 HTML로 프리렌더링한 후 클라이언트에 전달해요.\n\n하지만 클라이언트에서만 동작하는 애플리케이션을 만들고 싶다면, App 컴포넌트부터 시작해서 전체적으로 프리렌더링을 비활성화할 수 있어요. 이렇게 하면 서버에서는 HTML을 만들지 않고, 클라이언트에서만 렌더링하게 됩니다.\n\n```js\nconst App = dynamic(() => import('../../App'), { ssr: false })\n```\n\n위 코드에서 `dynamic`을 사용하여 App 컴포넌트를 불러오면서 `{ ssr: false }` 옵션을 줬는데요, 이 옵션이 서버 사이드 렌더링을 끄는 역할을 해요.\n\n그 다음에는 진입점(entrypoint) 페이지를 이제 이 동적으로 불러온 `App` 컴포넌트로 교체해주면 됩니다!\n\n> 참고로, 클라이언트 전용 애플리케이션을 만들 때는 서버에서 처리할 필요가 없으니 이렇게 `ssr: false`를 설정하는 게 퍼포먼스 향상에도 도움이 돼요. 하지만 SEO가 중요한 페이지라면 신중하게 사용해야겠죠.  \n\n필요하면 아래처럼 진입점 페이지에서 바로 사용해보세요.\n\n```js\nimport dynamic from 'next/dynamic'\n\nconst App = dynamic(() => import('../../App'), { ssr: false })\n\nexport default function Page() {\n  return <App />\n}\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js와 Vite에서 정적 이미지(import) 다루는 방법이 조금 달라요. Vite에서는 이미지를 import 하면, 프로덕션 빌드 시 이미지의 URL 문자열이 반환돼서 바로 img 태그의 src에 쓸 수 있죠.\n\n```js\nimport image from './img.png' // 빌드 후에는 '/assets/img.2d8efhg.png' 같은 URL이 됨\n\nexport default function App() {\n  return <img src={image} />\n}\n```\n\n근데 Next.js는 이런 식으로 바로 이미지 URL을 가져오는 게 아니라, `next/image` 컴포넌트를 이용해서 이미지 최적화 기능을 활용하도록 권장해요. 만약 그냥 정적 파일처럼 사용하고 싶으면 Next.js의 `public` 폴더에 이미지를 넣고 URL로 접근하는 게 가장 깔끔하답니다.\n\n예를 들어, `public/img.png`에 이미지를 넣었다면:\n\n```jsx\nexport default function App() {\n  return <img src=\"/img.png\" alt=\"example\" />\n}\n```\n\n아니면 Next.js의 Image 컴포넌트를 써서 자동으로 크기 조정, 최적화 기능을 쓰는 것도 좋아요:\n\n```jsx\nimport Image from 'next/image'\nimport img from '../public/img.png'\n\nexport default function App() {\n  return <Image src={img} alt=\"example\" />\n}\n```\n\n이렇게 하면 이미지가 자동으로 최적화되고 레이지 로딩도 적용돼서 퍼포먼스에 유리해요.\n\n---\n\n> **Tip!**  \n> Next.js에서 이미지를 정적으로 import 하려면 `next.config.js`에서 `images` 설정을 잘 해줘야 하는 경우도 있어요. 그리고 외부 URL의 이미지를 쓰려면 도메인을 허용해줘야 하죠.  \n> 이미지 최적화나 로딩 속도가 신경 쓰인다면 `next/image` 컴포넌트를 적극 활용해보세요!\n\n---\n\n결론적으로 Vite처럼 이미지 import 해서 바로 URL 받는 방식은 Next.js에선 조금 다르게 다뤄진다고 생각하면 돼요. 상황에 따라 `public` 폴더에 넣거나, `next/image`를 쓰는 두 가지 방법 중 선택하면 됩니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서 이미지 파일을 정적으로 import하면, 이미지가 객체(object)로 반환돼요. 이 객체는 Next.js의 `Image` 컴포넌트에서 바로 사용할 수도 있고, 기존에 쓰던 `img` 태그에서는 이 객체의 `src` 속성만 꺼내서 쓸 수도 있답니다.\n\n`Image` 컴포넌트의 장점은 자동 이미지 최적화가 된다는 것! 그리고 이미지의 실제 크기를 기반으로 `width`, `height` 속성을 자동으로 넣어줘서 이미지가 로딩될 때 레이아웃이 갑자기 바뀌는 문제(layout shift)를 막아줘요. 다만 주의할 점은 이미지의 한 쪽 치수만 스타일링하고 다른 쪽은 auto로 두지 않으면, 그 치수가 `img` 태그에 자동으로 들어간 크기로 고정돼서 이미지가 왜곡될 수 있다는 거예요.\n\n그래서 기존 `img` 태그를 유지하면 코드 변경량도 줄일 수 있고, 위 문제도 피할 수 있죠. 나중에 필요하면 `Image` 컴포넌트로 단계별 마이그레이션을 할 수 있어요. 이때 직접 로더(loader)를 설정하거나, Next.js 기본 서버를 사용하면 자동 이미지 최적화를 편리하게 활용할 수 있답니다.\n\n끝으로 `/public` 폴더에서 절대경로로 이미지를 import했다면, 상대경로로 바꾸는 것도 잊지 마세요. 이렇게 하면 관리도 더 편해지고 빌드 과정에서 문제도 줄일 수 있어요!\n\n---\n\n### 정리\n\n| 방법                         | 장점                             | 주의 사항                              |\n|----------------------------|--------------------------------|-----------------------------------|\n| `Image` 컴포넌트 사용          | 자동 이미지 최적화, 레이아웃 안정성 확보     | 한쪽 치수만 스타일링 시 이미지 왜곡 가능성         |\n| 기존 `img` 태그 유지           | 코드 변경 최소화, 왜곡 문제 없음           | 이미지 최적화 기능은 직접 구현해야 함           |\n| `/public`에서 이미지 경로 변경  | 경로 관리 용이, 빌드 시 문제 감소         | 절대경로 -> 상대경로 수정 필요               |\n\n---\n\n### 추가 팁: 이미지 최적화 옵션\nNext.js의 `Image` 컴포넌트는 기본적으로 자동 최적화를 지원하지만, 필요하면 `loader`를 정의해 좀 더 세밀한 설정도 가능해요. 예를 들어 외부 이미지 호스팅 서비스를 함께 쓸 때 유용하죠. 혹은 next.config.js에서 domains 옵션에 외부 도메인을 추가해주면, 더 다양한 이미지를 `Image` 컴포넌트로 불러올 수 있습니다.\n\n---\n\n필요에 따라 `Image` 컴포넌트의 장점과 한계를 잘 고려해서 사용하면, 퍼포먼스도 챙기고 개발도 부드럽게 할 수 있어요! 궁금한 점 있으면 언제든 질문 주세요~\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n자바스크립트 코드에서 이미지 파일을 불러올 때 경로나 방식이 조금 바뀌면서 주의할 점들을 정리해봤어요.\n\n---\n\n### 1. 이미지 파일 import 경로 변경하기\n\n```js\n// 이전 방식\nimport logo from '/logo.png'\n\n// 변경된 방식\nimport logo from '../public/logo.png'\n```\n\n이전에는 루트부터 바로 경로를 지정했다면, 이제는 public 폴더를 기준으로 상대 경로를 명확히 써주는 게 좋아요. 그렇지 않으면 이미지가 제대로 불러와지지 않을 수도 있어요.\n\n---\n\n### 2. `img` 태그에 `src` 속성 넘길 때 주의하기\n\n```js\n// 이전 방식\n<img src={logo} />\n\n// 변경된 방식\n<img src={logo.src} />\n```\n\nimport 한 이미지 객체 전체를 `src`에 넘기면 안 되고, 그 안에 실제 URL이 담긴 `.src` 값을 넘겨줘야 이미지가 화면에 제대로 뜹니다.\n\n---\n\n### 3. 대안: 직접 public 폴더 경로 지정하기\n\n이미지 파일이 `public/logo.png`에 있다면, 그냥 `src=\"/logo.png\"`로 바로 작성해도 됩니다.\n\n```js\n<img src=\"/logo.png\" />\n```\n\n이렇게 작성하면 이미지가 `public` 폴더 안에서 찾아지게 되는데, 간단하게 이미지 경로를 관리할 수 있는 방법이기도 해요. 다만, 이 경우 import 없이 스트링 경로를 직접 넣는 형태라는 점 참고하세요.\n\n---\n\n### 추가 팁\n\n- 만약 프로젝트가 Next.js 같은 프레임워크라면 `public` 폴더의 파일은 빌드 시 그대로 공개 경로로 복사돼서 `/이미지이름`으로 접근 가능합니다.\n- 자주 사용하는 공용 이미지들은 `public` 폴더에 모아두는 게 관리도 편하고, 빌드에도 영향을 덜 주는 편이에요.\n- 상대 경로 작성 시 `..` 여러 개를 써야 할 때 헷갈리기 쉬우니, VS Code 같은 편집기의 경로 자동완성기능을 적극 활용하면 좋아요.\n\n---\n\n이제 이미지를 불러올 때 경로 문제로 에러 뜨는 일은 조금 줄어들 거예요! 자~ 다음 프로젝트 때 적용해 보세요. :)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n> 경고: 만약 TypeScript를 사용 중이라면 src 속성에 접근할 때 타입 에러가 발생할 수 있어요. 지금은 무시해도 괜찮고, 이 가이드를 마칠 즈음에는 모두 해결될 테니 걱정 마세요.\n\n### 7단계: 환경 변수 마이그레이션하기\n\nNext.js도 Vite처럼 `.env` 파일을 통해 환경 변수를 관리할 수 있어요. 그런데 크게 차이나는 부분이 하나 있는데, 바로 클라이언트 쪽에서 노출되는 환경 변수에 붙는 접두사(prefix)에요.\n\n| Vite                  | Next.js              |\n|-----------------------|----------------------|\n| `VITE_` (접두사)       | `NEXT_PUBLIC_` (접두사) |\n\n즉, Vite에서 `VITE_`로 시작하는 환경 변수들은 Next.js에서는 `NEXT_PUBLIC_`로 바꿔줘야 클라이언트 사이드 코드에서 접근할 수 있어요. 예를 들어:\n\n```js\n# Vite 환경 변수\nVITE_API_URL=https://api.example.com\n```\n\n위 변수는 Next.js로 옮길 때 이렇게 바꿔줘야 해요:\n\n```js\n# Next.js 환경 변수\nNEXT_PUBLIC_API_URL=https://api.example.com\n```\n\n이걸 꼭 지켜야 클라이언트에서 `process.env.NEXT_PUBLIC_API_URL`로 안전하게 접근할 수 있어요. 만약 접두사를 안 바꾸면 클라이언트 쪽에 변수가 노출되지 않아서 참조할 수 없게 돼요.\n\n---\n\n**추가 팁!**  \n환경 변수를 사용할 때 중요한 건, 민감한 정보(ex: API 키, 비밀번호 등)는 절대 클라이언트에 노출시키면 안 돼요. `NEXT_PUBLIC_` 붙은 변수는 클라이언트에서 볼 수 있기 때문에, 민감 데이터를 담기엔 적합하지 않답니다. 서버 전용 변수는 접두사 없이 그냥 `process.env`에서 바로 사용하세요.\n\n---\n\n앞으로 계속 환경 변수를 변경하면서도, 변수 이름을 이렇게 맞춰주는 게 Next.js와 Vite를 함께 쓰거나 Next.js로 이전할 때 발생하는 흔한 실수 중 하나예요. 신경 써서 관리하면 빌드 문제나 런타임 오류를 줄일 수 있어요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nVite에서는 특별한 import.meta.env 객체를 통해 몇 가지 내장 환경 변수를 제공하는데, Next.js는 이 부분을 지원하지 않아요. 그래서 Vite에서 쓰던 환경 변수들을 Next.js에 맞게 이렇게 바꿔줘야 해요.\n\n| Vite (import.meta.env)       | Next.js (process.env)                  |\n|-----------------------------|--------------------------------------|\n| import.meta.env.MODE         | process.env.NODE_ENV                  |\n| import.meta.env.PROD         | process.env.NODE_ENV === 'production'|\n| import.meta.env.DEV          | process.env.NODE_ENV !== 'production'|\n| import.meta.env.SSR          | typeof window === 'undefined'        |\n\n여기서 살짝 팁을 드리자면, import.meta.env.SSR 은 서버 사이드 렌더링 여부를 체크하기 위한 변수인데, Next.js에서는 window 객체가 없으면 서버 환경으로 인식할 수 있으니 `typeof window === 'undefined'` 로 체크해주면 됩니다.\n\n그리고 한 가지 더! Next.js는 기본적으로 Vite에 있는 BASE_URL 같은 환경 변수를 제공하지 않아요. 하지만 직접 환경 변수를 만들어서 쓸 수는 있답니다. 방법은 간단해요, 프로젝트 루트에 `.env` 파일을 만들고 아래처럼 추가해주시면 됩니다.\n\n```js\nNEXT_PUBLIC_BASE_URL=https://your-domain.com\n```\n\n여기서 NEXT_PUBLIC_ 접두어는 Next.js에서 브라우저 코드에서도 접근할 수 있는 환경 변수를 의미해요. 만약 서버에서만 쓸 거라면 접두어 없이 그냥 선언하면 되고요.\n\n이렇게 하면 코드에서 `process.env.NEXT_PUBLIC_BASE_URL` 로 접근해서 사용할 수 있어요. 예를 들어 API 엔드포인트를 설정할 때 유용하답니다.\n\n정리하자면, Vite에서 Next.js로 넘어올 때 환경 변수 관련 코드를 이렇게 바꿔주시고, 필요한 환경 변수들은 직접 `.env` 파일에 추가해서 관리하시면 됩니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서 기본 경로(basePath)를 환경 변수로 설정하는 방법에 대해 공유할게요. 프로젝트를 하다 보면 `basePath`를 동적으로 설정해야 할 경우가 있는데, 예를 들어 CDN이나 특정 경로에 배포할 때 유용하죠.\n\n### 1. `.env` 파일에 환경 변수 설정하기\n\n```js\nNEXT_PUBLIC_BASE_PATH=\"/some-base-path\"\n```\n\n여기서 중요한 점! `NEXT_PUBLIC_` 접두어로 시작해야 클라이언트 쪽에서도 접근 가능해요.\n\n### 2. `next.config.mjs` 파일에서 basePath 설정하기\n\n다음과 같이 `next.config.mjs`에 `basePath`를 환경 변수로 불러와 세팅해 주세요.\n\n```js\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  output: 'export',      // SPA 형태로 빌드\n  distDir: './dist',     // 빌드 결과물을 'dist' 폴더로 변경\n  basePath: process.env.NEXT_PUBLIC_BASE_PATH,   // env 변수를 basePath로 설정!\n}\n\nexport default nextConfig\n```\n\n> TIP: `next.config.mjs`에서 import.meta.env 대신 `process.env`를 사용해야 하는 점 잊지 마세요. Next.js는 빌드 타임에 `process.env`로 환경 변수값을 주입합니다.\n\n### 3. 코드 내에서 `import.meta.env.BASE_URL` -> `process.env.NEXT_PUBLIC_BASE_PATH`로 변경\n\n기존에 `import.meta.env.BASE_URL` 을 사용하던 부분이 있다면, `process.env.NEXT_PUBLIC_BASE_PATH`로 바꿔줘야 합니다. 이 부분은 Vite 등 다른 빌드 시스템과 차이가 있어요.\n\n```js\nconst basePath = process.env.NEXT_PUBLIC_BASE_PATH || ''\n\n// 사용 예\nconst fullUrl = `${basePath}/some-resource`\n```\n\n### 정리하자면\n\n| 단계               | 설명                                 |\n|-------------------|------------------------------------|\n| 1. env 파일 만들기    | `NEXT_PUBLIC_BASE_PATH` 설정          |\n| 2. next.config.mjs 수정 | `basePath`에 `process.env.NEXT_PUBLIC_BASE_PATH` 지정 |\n| 3. 코드 수정           | `import.meta.env.BASE_URL` → `process.env.NEXT_PUBLIC_BASE_PATH` |\n\n---\n\n이렇게 하면 빌드할 때마다 환경 변수로 기본 경로를 바꾸는 게 가능해져서 다양한 배포 환경에 유연하게 대응할 수 있습니다. Next.js 프로젝트 하면서 경로 문제에 한 번쯤 고민해보셨다면 참고하세요~! 필요하면 basePath 외에도 `assetPrefix`도 같이 고려하는 게 좋아요. 그럼 즐코딩~! 🚀\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 8단계: package.json 스크립트 업데이트하기\n\n이제 Next.js로 마이그레이션을 잘 했는지 확인하기 위해 애플리케이션을 실행해볼 수 있어요. 그런데 그 전에 package.json 안의 스크립트를 Next.js에 맞게 살짝 바꿔줘야 합니다. \n\n기존에 있던 start나 build 명령어 대신 Next.js 명령어를 넣어주면 되는데요:\n\n```json\n{\n  \"scripts\": {\n    \"dev\": \"next dev\",\n    \"build\": \"next build\",\n    \"start\": \"next start\"\n  }\n}\n```\n\n- `\"dev\"`: 개발 모드로 로컬 서버를 띄울 때 사용해요 (hot reload도 지원해서 개발할 때 편리해요)\n- `\"build\"`: 배포 전, 프로덕션용으로 최적화된 빌드를 생성할 때 쓰입니다.\n- `\"start\"`: 빌드된 결과물을 실제 서비스 환경에서 실행할 때 사용하죠.\n\n그리고 Git 관리할 때 필요 없는 파일들을 깃에서 제외하기 위하여 `.gitignore` 파일에도 다음 내용을 추가해주세요:\n\n\n.next\nnext-env.d.ts\ndist\n\n\n- `.next` 폴더는 Next.js가 빌드하면서 생성하는 임시파일들이라 보통 Git에 올리지 않아요.\n- `next-env.d.ts`는 Next.js 타입 지원을 위한 선언 파일로, 자동 생성되므로 따로 관리하지 않습니다.\n- `dist`는 프로젝트마다 다르지만, 빌드 후 결과를 담고 있는 폴더라면 역시 빼는 게 좋습니다.\n\n참고로, `.gitignore`에 이런 빌드 결과 파일들을 미리 넣어두면 협업할 때 불필요한 충돌도 줄일 수 있어요. 다음 단계에서는 이렇게 설정한 상태에서 실제로 `npm run dev` 명령어로 개발 서버를 실행해보면서 잘 작동하는지 확인해보세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 터미널에서 `npm run dev` 명령어를 실행하고, http://localhost:3000 에 접속해 보세요. 그러면 당신의 Next.js 애플리케이션이 잘 실행되고 있는 모습을 확인할 수 있을 거예요.\n\n> 참고로, Vite로 만들어진 애플리케이션을 Next.js로 마이그레이션한 실제 예제를 보고 싶다면 이 [Pull Request](https://github.com/vercel/next.js/pull/####)를 확인해 보세요. (원문에 링크가 있다면 여기에 넣어주세요.)\n\n### 9단계: 정리하기\n\n이제 Vite 관련 파일들이나 설정들은 모두 정리할 차례입니다. 프로젝트에서 Vite와 관련된 불필요한 것들을 깔끔하게 제거해서 코드베이스를 정돈해 주세요!\n\n예를 들어, 다음과 같은 것들을 확인하시면 좋아요:\n\n| 제거 대상                     | 설명                              |\n|------------------------------|----------------------------------|\n| `vite.config.js`              | Vite 설정 파일                   |\n| `index.html`                  | Vite에서 사용했던 진입 HTML 파일 |\n| `package.json`의 Vite 관련 의존성 | `vite`, `@vitejs/plugin-react` 등 |\n| 기타 Vite 전용 스크립트       | 빌드 스크립트나 개발 서버 관련 설정 |\n\n이렇게 정리하고 나면 Next.js만 사용하는 깔끔한 환경을 만들 수 있습니다.\n\n---\n\n만약 다음 단계가 궁금하다면, Next.js의 배포나 최적화 방법 등을 함께 알아보는 것도 추천합니다. Next.js는 기본적으로 SSR(서버 사이드 렌더링)과 SSG(정적 사이트 생성), 그리고 CSR(클라이언트 사이드 렌더링)을 유연하게 사용할 수 있어서 애플리케이션을 더 빠르고 SEO 친화적으로 만들어 주거든요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- main.tsx 삭제  \n- index.html 삭제  \n- vite-env.d.ts 삭제  \n- tsconfig.node.json 삭제  \n- vite.config.ts 삭제  \n- Vite 관련 의존성 제거  \n\n## 다음 단계\n\n만약 지금까지 작업이 잘 됐다면, 이제 Next.js를 기반으로 동작하는 싱글 페이지 애플리케이션을 갖게 된 거예요. 하지만 아직 Next.js가 제공하는 많은 장점들을 완전히 활용하고 있진 않은 상태입니다. 이제부터 점진적으로 개선하면서 Next.js의 진가를 맛보실 수 있는데요, 다음 단계로 고려해볼 만한 사항들을 소개할게요:\n\n| 다음 단계 | 설명 |\n| --- | --- |\n| React Router에서 Next.js App Router로 마이그레이션 | - 자동 코드 분할로 초기 로딩 속도 개선<br>- 스트리밍 서버 사이드 렌더링 지원<br>- React 서버 컴포넌트 활용 가능 |\n| 이미지 최적화 | Next.js `Image` 컴포넌트로 자동 최적화된 이미지 제공 |\n| 폰트 최적화 | `next/font`를 활용해 폰트 로딩 속도 및 성능 개선 가능 |\n| 서드파티 스크립트 최적화 | Next.js `Script` 컴포넌트로 외부 스크립트 로딩 최적화 |\n| ESLint 설정 업데이트 | Next.js 규칙을 지원하도록 ESLint를 구성하여 코드 품질 유지 |\n\n---\n\n여기서 한 가지 팁을 추가하자면, Next.js의 App Router는 전통적인 React Router보다 많은 부분에서 성능과 개발 경험을 향상시키는데요. 특히 서버 컴포넌트(Server Components)를 적극 활용하면 클라이언트에서 불필요한 자바스크립트가 줄어들어 사용자 경험이 좋아집니다. 그리고 이미지나 폰트 최적화는 SEO와 사용자 경험에 직접적인 영향을 주기 때문에 꼭 챙겨보시길 추천드립니다!\n\n조금씩 바꾸면서 Next.js 애플리케이션의 진정한 잠재력을 느껴보세요. 궁금한 점이 있으면 언제든 질문해 주세요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":39},{"title":"Create React App에서 Next.js 15로 마이그레이션하는 과정 정리","description":"","date":"2025-04-22 01:26","slug":"2025-04-22-HowtomigratefromCreateReactApptoNextjs","content":"\n\n# Create React App에서 Next.js로 마이그레이션하는 방법\n\n안녕하세요! 오늘은 여러분이 기존에 만들었던 Create React App(CRA) 프로젝트를 Next.js로 옮기는 과정을 쉽게 도와드리려고 해요. React로 만든 프로젝트를 좀 더 강력하고 효율적으로 운영하고 싶다면 Next.js를 고려해볼 만한데요, 그 이유부터 살펴볼게요.\n\n## 왜 Next.js로 갈아탈까?\n\nCreate React App도 충분히 좋은 툴이지만, Next.js가 제공하는 몇 가지 장점 때문에 많은 분들이 이동하고 있어요:\n\n| 이유 | 설명 |\n|---|---|\n| **서버 사이드 렌더링(SSR)** | Next.js는 서버에서 미리 페이지를 렌더링해서 SEO 최적화와 초기 로딩 속도를 개선해줍니다. 단순히 SPA보다 빠르고 검색 엔진 친화적이에요. |\n| **파일 기반 라우팅** | 별도의 라우팅 설정 없이 `pages` 폴더 내 파일 이름만으로 라우팅이 자동 설정돼서 개발이 훨씬 수월해요. |\n| **정적 사이트 생성(SSG)** | 빌드 시 HTML 페이지를 미리 생성해두고 빠르게 서빙할 수 있어요. 블로그나 홍보 사이트에 딱이죠. |\n| **API 라우트 내장** | 백엔드 API도 Next.js 안에서 바로 만들 수 있어, 풀스택 개발까지 한 번에! |\n| **이미지 최적화** | Next.js 에서 제공하는 `<Image />` 컴포넌트로 자동 이미지 최적화 기능을 쓸 수 있어요. |\n\n이 외에도 커뮤니티 지원, 최신 React 기능과 완벽 연동 등 다양한 이유가 있지만, 대략 이대로만 알아도 충분히 넘어갈 동기부여가 되죠?\n\n다음에는 본격적으로 CRA 프로젝트를 Next.js로 옮기는 구체적인 단계를 천천히 살펴볼게요. \n\n궁금한 점 있으면 댓글로 알려주세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 느린 초기 페이지 로딩 시간\n\nCreate React App은 순수하게 클라이언트 사이드 React를 사용해요. 이렇게 클라이언트 사이드에서만 동작하는 앱, 즉 싱글 페이지 애플리케이션(SPA)은 초기 페이지 로딩이 느려질 때가 많답니다. 왜 그런지 간단히 살펴볼게요.\n\n- 브라우저가 React 코드와 여러분의 애플리케이션 전체 번들을 다 다운로드하고 실행해야만, 데이터 요청을 보낼 수 있어요.\n- 그리고 새로운 기능이나 라이브러리를 추가할수록 애플리케이션 코드가 점점 커지고요.\n\n이런 이유들 때문에 처음 앱을 켤 때 로딩 속도가 느려질 수 있죠.\n\n---\n\n### 자동 코드 분할(Automatic Code Splitting)이 없어요\n\nCreate React App은 기본적으로 자동 코드 분할 기능을 제공하지 않아요. 자동 코드 분할이란, 사용자가 필요로 하는 코드만 그때그때 불러오는 기술을 말하는데요, 이렇게 하면 초기 다운로드 크기를 줄여서 빠르게 화면을 보여줄 수 있습니다.\n\n하지만 Create React App에서는 이런 기능이 자동으로 적용되지 않다 보니, 모든 코드가 한꺼번에 번들링되어 초기 로딩 시간이 길어지는 문제가 생기죠.\n\n---\n\n#### 추가 팁! 빠른 로딩을 위한 대안\n\n- **React.lazy와 Suspense 활용하기:** 수동으로 코드 분할을 적용해 볼 수 있어요. 페이지나 컴포넌트를 동적으로 불러와 초기 로딩 시간을 줄일 수 있답니다.\n- **서버 사이드 렌더링(SSR) 도입:** Next.js 같은 프레임워크를 사용하면 서버에서 미리 HTML을 만들어 보내주기 때문에, 사용자는 빠르게 콘텐츠를 볼 수 있어요.\n- **번들 사이즈 최적화:** 사용하지 않는 라이브러리를 제거하거나, 필요한 부분만 가져오는 트리 쉐이킹(tree shaking)을 신경 써서 코드 크기를 줄여보세요.\n\n---\n\n이렇게 SPA에서 초기 로딩 시간이 느린 원인과 해결 방안을 알아봤는데, 여러분의 프로젝트 상황에 맞게 적절한 방법을 골라 적용해 보세요. 웹 앱 사용성 개선에 큰 도움이 될 거예요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이전 글에서 언급한 느린 로딩 문제는 코드 분할(code splitting)로 어느 정도 해결할 수 있어요. 하지만 직접 수동으로 코드 분할을 하려고 하면 오히려 네트워크 워터폴(network waterfall) 같은 비효율적인 요청 흐름이 생길 수 있습니다. 다행히 Next.js는 라우터와 빌드 파이프라인에 자동 코드 분할과 트리 쉐이킹(tree shaking)을 기본으로 지원해서 이런 문제를 덜어줍니다.\n\n### 네트워크 워터폴(Network waterfalls)이란?\n\n네트워크 워터폴은 앱이 클라이언트와 서버 사이에 연속적으로 요청을 보내면서 성능이 저하되는 상황을 말해요. SPA에서 흔히 볼 수 있는 패턴 중 하나는, 컴포넌트가 먼저 플레이스홀더(자리 표시자)를 렌더링하고, 그 후에 데이터를 가져오는 식이죠. 그런데 문제는, 자식 컴포넌트가 데이터를 가져오기 시작하려면 부모 컴포넌트가 자기 데이터를 다 받아야 하니까 여러 요청이 순차적으로 이어지면서 딜레이가 예상보다 커지는 거에요. 이게 바로 '워터폴'이에요.\n\nNext.js는 클라이언트 사이드에서 데이터 패칭을 지원하지만, 더욱 중요한 점은 서버 사이드로 데이터 패칭을 옮길 수 있게 해 준다는 겁니다. 이렇게 서버에서 미리 데이터를 받아오면, 클라이언트-서버 간의 여러 번의 연속 요청이 아예 없어지거나 크게 줄어들어 워터폴 문제가 대부분 해결되죠.\n\n덧붙여서, Next.js의 getServerSideProps나 getStaticProps 같은 서버 데이터 페칭 메서드를 이용하면 SEO에도 유리하고, 사용자 입장에서도 초기 페이지 로딩 속도가 확실히 좋아지는 걸 체감할 수 있으니 꼭 활용해보시길 추천해요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 빠르고 의도적인 로딩 상태 관리\n\nReact Suspense 덕분에 스트리밍 기능이 내장되어 있어서, UI의 어떤 부분을 먼저 로드할지 그리고 어떤 순서로 로드할지 직접 정할 수 있어요. 덕분에 네트워크 병목 현상을 줄이고, 페이지가 훨씬 빠르게 로딩되도록 만들 수 있죠.\n\n또한 이렇게 하면 화면이 갑자기 바뀌는 레이아웃 시프트(layout shift)를 최소화해서 사용자 경험을 한층 더 부드럽게 만들 수 있답니다.\n\n### 데이터 가져오기 전략 선택하기\n\n여러분이 데이터를 어떻게 가져올지, 즉 데이터 패칭 전략(data fetching strategy)을 선택하는 것도 중요한 부분이에요. API 호출을 어디서, 어떻게 할지 결정하면 성능과 사용자 경험 모두에 큰 영향을 끼치거든요.\n\n예를 들어, 서버 사이드 렌더링(SSR), 정적 사이트 생성(SSG), 클라이언트 사이드 렌더링(CSR) 같은 다양한 패턴 중 상황에 맞는 방법을 선택해서 사용하는 것이죠.\n\n---\n\n만약 React Suspense와 데이터 패칭 방법에 대해 더 궁금하시다면, 이 두 가지를 조합해서 어떻게 더욱 빠르고 안정적인 웹 앱을 만드는지 사례와 함께 설명해 드릴게요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js는 필요에 따라 페이지나 컴포넌트 단위로 데이터 가져오기 방식을 선택할 수 있게 해줘요. 예를 들어, CMS에서 데이터를 가져와 빌드 시점에 블로그 글을 렌더링하는 방식을 사용할 수 있는데, 이걸 SSG(Static Site Generation)라고 부르고요. 이렇게 하면 페이지 로딩 속도가 훨씬 빨라집니다. 반면, 사용자 요청 시점에 데이터를 가져오는 SSR(Server Side Rendering)을 써야 할 경우도 있죠. 이건 예를 들어, 사용자마다 다른 데이터를 보여줘야 할 때 유용해요.\n\n### 미들웨어 (Middleware)\n\nNext.js의 미들웨어는 서버에서 요청이 완성되기 전에 코드를 실행할 수 있게 해줘요. 예를 들어보면, 로그인한 사용자만 볼 수 있는 페이지에서 비로그인 상태의 사용자가 접근하려 할 때, 미들웨어에서 로그인 페이지로 바로 리다이렉트 시켜 ‘비인증 콘텐츠가 잠깐 보이는 현상(플래시)’을 막을 수 있죠. 이외에도 A/B 테스트, 실험 기능, 다국어 지원 등에도 활용할 수 있어요.\n\n### 내장 최적화 기능 (Built-in Optimizations)\n\nNext.js는 기본적으로 다양한 최적화 기능들이 내장돼 있어요. 예를 들어, 이미지를 자동으로 최적화하거나, 코드 분할을 통해 불필요한 코드가 로드되지 않게 하죠. 이런 최적화 덕분에 개발자는 성능에 크게 신경 쓰지 않아도 훌륭한 사용자 경험을 제공할 수 있습니다.\n\n> 개인적으로는 미들웨어를 적극적으로 활용하는 걸 추천해요. 미들웨어 덕분에 서버 단에서 많은 제어가 가능해지고, 보안이나 UX 향상에 큰 도움이 되니까요.\n\n추가로 궁금한 점 있으면 언제든 질문해 주세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이미지, 폰트, 그리고 서드파티(3rd-party) 스크립트는 애플리케이션 성능에 큰 영향을 미칠 수 있어요. 다행히 Next.js에는 이런 리소스들을 자동으로 최적화해주는 특화된 컴포넌트와 API들이 내장되어 있답니다.\n\n## 마이그레이션 단계\n\n우리 목표는 최대한 빠르게 동작하는 Next.js 애플리케이션을 만드는 거예요. 그렇게 하면 Next.js의 여러 기능을 한꺼번에 도입하는 대신, 단계적으로 천천히 적용해 나갈 수 있답니다. 처음에는 기존 라우터를 바로 바꾸지 않고, 순수 클라이언트 사이드 애플리케이션(SPA)처럼 다루면서 시작할 거예요. 이렇게 하면 복잡함도 줄어들고, 코드 머지할 때 충돌도 최소화할 수 있죠.\n\n> 참고: 만약 CRA(Create React App)에서 package.json의 커스텀 홈페이지 설정, 서비스 워커, 또는 Babel/webpack 세부 조정 같은 고급 설정을 사용 중이라면, 이 가이드 맨 마지막 ‘추가 고려사항’ 섹션을 꼭 확인해 보세요. Next.js로 넘어갈 때 이런 설정들을 어떻게 비슷하게 구현하거나 다르게 적용할지 도움이 될 거예요.\n\n---\n\n그리고 한 가지 덧붙이자면, Next.js의 이미지 최적화 컴포넌트(next/image)는 기본적으로 레이지 로딩(lazy loading)을 지원해서 초기 로드 시간을 줄여주고, 폰트 최적화(next/font)는 폰트 로딩 방식도 개선해 줘서 사용자 경험 향상에도 한 몫 한답니다. 그러니 마이그레이션하면서 자연스럽게 퍼포먼스도 같이 챙길 수 있다는 점, 꼭 기억하세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### Step 1: Next.js 설치하기\n\n기존 프로젝트에 Next.js를 설치하려면 터미널에 아래 명령어를 입력하세요:\n\n```bash\nnpm install next@latest\n```\n\n여기서 `next@latest`는 최신 버전의 Next.js를 설치한다는 의미예요. Next.js는 React 기반의 프레임워크로, 서버 사이드 렌더링(SSR)과 정적 사이트 생성(SSG)을 지원해서 빠르고 SEO 친화적인 웹사이트를 만들 때 유용하답니다.\n\n### Step 2: Next.js 설정 파일 만들기\n\nNext.js를 제대로 활용하려면 프로젝트 루트에 `next.config.js` 파일을 만들어서 필요한 설정을 추가해야 해요. 예를 들어, 커스텀 환경변수나 빌드 옵션을 설정할 때 이 파일을 사용하죠.\n\n```js\n// next.config.js\nmodule.exports = {\n  reactStrictMode: true, // React의 엄격 모드 활성화\n  // 여기서 추가 설정을 해보세요!\n};\n```\n\n처음에는 간단하게 `reactStrictMode`만 설정해도 충분해요. 개발 중에 React의 잠재적인 문제를 알려주기 때문에 디버깅할 때 도움이 많이 된답니다.\n\n> 참고로, Next.js에서는 `pages` 폴더 안에 React 컴포넌트를 파일로 작성하면 자동으로 라우팅이 설정되니까, 라우팅 관련 설정은 따로 안 해도 돼요.\n\n다음 단계에서는 페이지를 만들어서 직접 Next.js의 구조를 체험해보면 좋아요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프로젝트 루트 폴더(보통 package.json 파일과 같은 위치)에 `next.config.ts` 파일을 만들어 주세요. 이 파일은 Next.js의 설정 옵션을 담는 곳이에요.\n\n```ts\nimport type { NextConfig } from 'next'\n\nconst nextConfig: NextConfig = {\n  output: 'export', // SPA(Single-Page Application)로 결과물을 내보내겠다는 뜻이에요.\n  distDir: 'build',   // 빌드 결과물이 저장되는 폴더를 기본 '.next' 대신 'build'로 바꿔줘요.\n}\n\nexport default nextConfig\n```\n\n> 참고! 여기서 `output: 'export'`를 설정하면, 정적 사이트로 내보내는 거예요. 그래서 서버사이드 렌더링(SSR)이나 API 같은 서버 기능은 사용할 수 없답니다. 만약 이런 기능들이 필요하면 이 줄을 삭제해 주세요.\n\n---\n\n다음 단계로 루트 레이아웃 파일을 만드는 작업이 이어집니다! 필요하면 알려드릴게요 :)\n\n---\n\n추가 팁!\n\n- `distDir` 옵션을 바꾸면 빌드 폴더 이름이 바뀌어서, 배포 시 원하는 구조로 폴더를 관리하기 좋습니다.\n- Next.js에서 보통 SSR을 쓰냐 정적 export를 쓰냐는 프로젝트 성격에 따라 다르니, `output: 'export'` 설정 전에 어느 방식을 쓸지 고민해보시는 걸 추천해요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js 앱 라우터에서 꼭 필요한 게 바로 루트 레이아웃 파일이에요. 이 파일은 React Server Component 형태로 되어 있고, 앱의 모든 페이지를 감싸는 역할을 하죠.\n\n만약 CRA(Create React App) 환경에서 작업해보셨다면, 이 루트 레이아웃과 가장 비슷한 게 `public/index.html` 파일이에요. 기본적인 `html`, `head`, `body` 태그를 포함하고 있어서 앱의 뼈대를 담당하죠.\n\n그럼 Next.js에서 어떻게 만들면 될지 한번 볼게요!\n\n1. 우선 프로젝트 루트(또는 `src` 폴더 안)에 `app` 이라는 새 디렉터리를 만들어 주세요.\n\n2. 그 안에 `layout.tsx` 혹은 `layout.js` 파일을 만들고, 아래처럼 작성하면 돼요:\n\n```tsx\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"ko\">\n      <head>\n        <title>내 Next.js 앱</title>\n      </head>\n      <body>\n        {children}\n      </body>\n    </html>\n  )\n}\n```\n\n여기서 중요한 점은, 이 루트 레이아웃이 실제로 여러분의 페이지들을 감싸주는 최상위 레이아웃이라는 거예요. 그리고 `children`은 자식 컴포넌트, 즉 각 페이지들의 내용을 의미하죠.\n\n추가로, Next.js 13 App Router에서는 이 레이아웃이 서버에서 렌더링되는 ‘서버 컴포넌트’ 형태라서 SEO 최적화나 초기 렌더링 성능에 유리하답니다.\n\n**팁!**  \n`<head>` 태그 안에는 메타태그, 폰트 로드, SEO 설정 등도 함께 넣을 수 있으니 필요에 따라 꼭 활용해 보세요!  \n그리고 다국어 지원을 하려면 `<html lang=\"en\">` 처럼 `lang` 속성에도 신경 써주시면 좋고요.\n\n한마디로, Next.js 13 App Router의 `app/layout.tsx`는 옛날에 `index.html`이 맡았던 역할을 React 방식으로 훨씬 깔끔하고 유연하게 대체했다고 보면 됩니다.  \n이제 뼈대부터 잘 잡고 멋진 Next.js 프로젝트 시작해봐요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 예전의 index.html 내용을 이 `RootLayout` 컴포넌트로 옮겨보세요. 특히 body 태그 안에 있던 `div#root`와 `noscript` 부분은 다음처럼 `div id=\"root\"` 안에 `children`을 넣는 형태로 바꾸면 됩니다.\n\n```tsx\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <head>\n        <meta charSet=\"UTF-8\" />\n        <link rel=\"icon\" href=\"%PUBLIC_URL%/favicon.ico\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n        <title>React App</title>\n        <meta name=\"description\" content=\"Web site created...\" />\n      </head>\n      <body>\n        <div id=\"root\">{children}</div>\n      </body>\n    </html>\n  )\n}\n```\n\n> 참고: Next.js는 기본적으로 CRA(Create React App)의 `public/manifest.json`, 추가 아이콘들, 그리고 테스트 설정을 무시해요. 만약 이런 것들이 필요하다면, Next.js가 제공하는 Metadata API나 테스트 설정 기능을 활용해 설정할 수 있습니다.\n\n---\n\n### Step 4: Metadata\n\n다음은 메타데이터 설정 단계입니다. Next.js에서는 메타데이터를 효과적으로 관리할 수 있도록 도와주는 API가 있으니, 이를 활용하면 SEO나 웹사이트 정보 관리가 더 편리해집니다.\n\n> 추가 팁: `RootLayout` 같은 전역 레이아웃에서 메타태그를 관리하면 페이지마다 일일이 설정하지 않아도 되고, 일관성 유지에도 좋아요.\n\n필요하면 제가 메타데이터 설정 방법도 따로 정리해 드릴게요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js를 사용하다 보면, `<head>` 태그 안에 `<meta charset=\"UTF-8\" />`나 `<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />` 같은 태그들을 직접 넣지 않아도 자동으로 포함된다는 점을 알게 될 거예요. 그래서 불필요하게 중복되니까, 이런 태그들은 제거해도 OK입니다.\n\n예를 들어, 처음에는 이렇게 작성할 수도 있죠:\n\n```jsx\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <head>\n        <link rel=\"icon\" href=\"%PUBLIC_URL%/favicon.ico\" />\n        <title>React App</title>\n        <meta name=\"description\" content=\"Web site created...\" />\n      </head>\n      <body>\n        <div id=\"root\">{children}</div>\n      </body>\n    </html>\n  )\n}\n```\n\n근데 사실 favicon.ico나 icon.png, robots.txt 같은 메타데이터 파일들을 `app` 디렉토리 최상단에 넣어두면, Next.js가 자동으로 `<head>` 태그에 넣어줘요. 그러니 직접 `<link>` 태그로 선언할 필요가 없습니다.\n\n실제로 앱 디렉토리 내에 이런 파일들을 위치시키고 나서는, `<link rel=\"icon\" ... />` 부분도 지워서 훨씬 깔끔하게 만들 수 있죠:\n\n```jsx\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <head>\n        <title>React App</title>\n        <meta name=\"description\" content=\"Web site created...\" />\n      </head>\n      <body>\n        <div id=\"root\">{children}</div>\n      </body>\n    </html>\n  )\n}\n```\n\n----\n\n### 요점 정리\n\n| 항목                            | 설명                                                         |\n|-------------------------------|------------------------------------------------------------|\n| charset, viewport 메타 태그     | Next.js가 자동으로 포함해 주므로 직접 넣지 않아도 된다.                  |\n| favicon.ico, icon.png, robots.txt 등 | `app` 디렉토리 최상단에 넣어두면 자동으로 `<head>`에 추가됨. 직접 `<link>` 태그 불필요. |\n| `title`, `meta description`   | 직접 넣어야 하며, 앱에 맞게 커스터마이징 가능하다.                        |\n\n이런 자동화 덕분에 `<head>` 태그 관리가 더 쉬워지고 코드도 깔끔해지니, 꼭 활용해보세요! 😊\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마지막으로, Next.js에서는 Metadata API를 활용해서 `head` 태그를 관리할 수 있어요. 즉, 최종 메타데이터 정보를 `export`된 `metadata` 객체로 옮기면 된답니다.\n\n```js\nimport type { Metadata } from 'next'\n\nexport const metadata: Metadata = {\n  title: 'React App',\n  description: 'Web site created with Next.js.',\n}\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <body>\n        <div id=\"root\">{children}</div>\n      </body>\n    </html>\n  )\n}\n```\n\n위 코드처럼, 예전에는 `index.html` 안에서 직접 모든 메타데이터를 선언했지만, 이제는 Next.js의 프레임워크 내장 기능인 **Metadata API**를 이용하는 방식으로 전환했어요. 이 방법 덕분에 SEO(검색 엔진 최적화)와 웹 페이지 공유 시 필요한 메타 정보 관리가 훨씬 간편해집니다.\n\n> 참고로, Metadata API는 페이지 단위로 메타데이터를 설정할 수 있어서, 각 페이지마다 다른 title이나 description을 쉽게 적용할 수 있다는 점도 큰 장점이에요. 또 오픈 그래프(Open Graph) 같은 소셜 미디어 공유 정보를 추가하는 것도 수월해요!\n\n---\n\n### Step 5: Styles\n\n이제 다음 단계는 스타일을 적용하는 것이에요. Next.js에서는 CSS 모듈, 글로벌 CSS, 혹은 Tailwind CSS 같은 유틸리티 퍼스트 프레임워크 등 다양한 스타일링 방법도 지원하니, 여러분 프로젝트에 맞게 골라서 적용하면 됩니다. 앞으로 스타일을 입히는 방법도 차근차근 소개할게요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nCRA(Create React App)처럼 Next.js도 CSS Modules를 기본적으로 지원해요. 그리고 전역으로 적용되는 CSS 파일도 쉽게 불러올 수 있답니다.\n\n만약에 전역 스타일을 관리하는 CSS 파일이 있다면, 보통 `app/layout.tsx` 파일에 이렇게 불러와요:\n\n```tsx\nimport '../index.css'\n\nexport const metadata = {\n  title: 'React App',\n  description: 'Web site created with Next.js.',\n}\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <body>\n        <div id=\"root\">{children}</div>\n      </body>\n    </html>\n  )\n}\n```\n\n여기서 중요한 점은 Next.js는 CSS를 모듈 방식으로도, 전역 스타일로도 사용할 수 있어서 스타일 관리가 훨씬 자유롭다는 거예요. 예를 들어 컴포넌트 단위로 스타일을 캡슐화하고 싶으면 CSS Modules를, 전체 사이트에 공통되는 스타일은 전역 CSS 파일로 관리하면 되죠.\n\n그리고 만약 Tailwind CSS를 쓰고 싶다면, Next.js 공식 문서에서 설치 방법이 자세히 안내되어 있으니 꼭 참고하세요. Tailwind와 Next.js는 사실 찰떡궁합이라서, 빠르게 스타일링을 시작하기에 아주 좋아요!\n\n개발하면서 CSS가 헷갈릴 때는 언제든 이렇게 전역과 모듈 스타일을 적절히 섞어가며 사용해보시길 추천드려요. 그럼 스타일 관리가 훨씬 편해질 거예요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 6단계: 진입점 페이지 만들기\n\nCreate React App에서는 `src/index.tsx`(또는 `index.js`)가 진입점(entry point)이었죠. 근데 Next.js(App Router)에서는 `app` 폴더 안에 있는 각 폴더가 각각의 라우트(경로)가 되고, 그 폴더마다 `page.tsx` 파일이 꼭 있어야 해요.\n\n여기서 우리 목표는 일단 앱을 SPA(싱글 페이지 애플리케이션)처럼 유지하면서 모든 라우트를 한 곳에서 가로채고 싶어요. 그래서 Next.js의 **optional catch-all route**를 사용할 거예요.\n\n즉, `app` 폴더 안에 `[[...slug]]`라는 폴더를 새로 만들어주세요.\n\n---\n\n> **optional catch-all route** 쉽게 설명하자면?  \n> URL 경로가 어떤 형태든 전부 이 곳으로 몰아넣겠다는 뜻이에요. 예를 들어 `/about`, `/posts/123` 같은 경로도 모두 이 `[[...slug]]` 폴더가 담당하게 되죠. 이렇게 하면 SPA처럼 라우팅 처리가 편해집니다.\n\n추가로, Next.js에서 `app/[[...slug]]/page.tsx`를 만들면, 전체 경로를 하나로 묶어 관리하는 훌륭한 방법이 될 수 있답니다! 이 부분 잘 활용하면 복잡한 라우팅도 깔끔하게 처리할 수 있어요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서 `app` 디렉토리 구조를 이렇게 구성하고 있다고 가정해볼게요:\n\n\napp\n ┣ [[...slug]]\n ┃ ┗ page.tsx\n ┣ layout.tsx\n\n\n여기에서 `page.tsx`에 다음과 같은 내용을 추가하는 걸 보셨죠?\n\n```js\nexport function generateStaticParams() {\n  return [{ slug: [''] }]\n}\n\nexport default function Page() {\n  return '...' // 나중에 업데이트 예정\n}\n```\n\n### 이 코드는 대체 무슨 뜻일까요?\n\n- `generateStaticParams` 함수는 Next.js에게 어떤 경로들을 정적으로 생성할지 알려주는 역할을 해요.\n- 여기서 `[{ slug: [''] }]`라는 배열을 반환해서 빈 문자열, 즉 루트 경로 `/`만 정적으로 생성한다는 뜻이죠.\n- `[[...slug]]` 이건 *catch-all* 라우팅을 의미해요. 즉, `/`, `/about`, `/posts/1` 등 어떤 경로든 모두 이 페이지로 매핑됩니다.\n- 하지만 이 상태에선 실제로 정적 경로는 빈 배열 `slug: ['']`만 있으니 루트 경로 하나만 빌드 타임에 정적으로 생성되고, 나머지는 동적으로 처리되는 구조입니다.\n\n### 추가 팁!\n\n- 이 파일(`page.tsx`)은 Server Component이므로, 빌드 타임에 HTML로 미리 렌더링 됩니다. 덕분에 SEO에 유리하고 초기 로딩 속도가 빠르죠.\n- 만약 모든 경로를 정적으로 생성하려면 `generateStaticParams`에서 각각 필요한 `slug`를 다 반환해주면 됩니다. 하지만 그게 무척 많거나 동적이라면 이처럼 빈 경로로 제한하는 게 성능이나 빌드 시간에 유리할 수 있어요.\n\n### 간단 정리\n\n| 함수명                | 역할                                 |\n|--------------------|----------------------------------|\n| `generateStaticParams`   | Next.js가 정적으로 생성할 경로 목록 반환          |\n| `export default Page`    | 해당 경로들에 대해서 보여줄 페이지 컴포넌트           |\n| `[[...slug]]`            | 모든 경로를 한 페이지로 처리하는 catch-all 라우팅   |\n\n이 구조를 이해하고 나면 Next.js의 앱 라우팅과 정적 생성을 훨씬 잘 활용할 수 있답니다! 앞으로는 이 베이스 위에 실제 UI나 데이터를 넣어서 페이지를 만들어보세요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 7단계: 클라이언트 전용 엔트리포인트 추가하기\n\n이번엔 CRA(Create React App)의 루트 App 컴포넌트를 Next.js의 클라이언트 컴포넌트 안에 넣어볼 거예요. 이렇게 하면 모든 로직이 클라이언트 사이드에서만 실행되도록 할 수 있답니다.\n\nNext.js 경험이 처음이라면 참고할 점! 클라이언트 컴포넌트라고 해서 무조건 클라이언트에서만 렌더링되는 건 아니에요. 기본적으로 Next.js는 클라이언트 컴포넌트도 서버에서 미리 렌더링(prerendered)해둡니다. 다만, 클라이언트 컴포넌트는 서버-rendering에 추가해서 클라이언트 자바스크립트를 실행할 수 있는 특징이 있죠.\n\n자, 그럼 `app/[[...slug]]/` 폴더 안에 `client.tsx` (또는 `.js`) 파일을 만들어주세요.\n\n```tsx\n'use client'\n\nimport dynamic from 'next/dynamic'\n\nconst App = dynamic(() => import('../../App'), { ssr: false })\n\nexport function ClientOnly() {\n  return <App />\n}\n```\n\n여기서 중요한 점!  \n`dynamic`의 `ssr: false` 옵션을 줘서 서버 사이드 렌더링(SSR)을 완전히 끄고 클라이언트에서만 렌더링하도록 설정했어요. 이렇게 하면 서버에서는 아예 렌더링 과정이 스킵되니, 오직 브라우저에서만 `App`이 실행되겠죠.\n\n이 방식은 특히 CRA에서 작성한 컴포넌트를 Next.js로 옮길 때 유용해요. CRA는 기본적으로 클라이언트 사이드 앱이라 SSR을 고려하지 않거든요. 이처럼 Next.js의 클라이언트 컴포넌트를 활용하면 기존 코드를 수정하지 않고도 Next.js 프로젝트에 자연스럽게 통합할 수 있습니다.\n\n추가 팁!  \n만약 클라이언트 전용 컴포넌트가 많아지면, 이런 클라이언트 전용 래퍼 컴포넌트를 만들어 재사용하는 것도 좋은 방법이에요. 그래야 중복 코드도 줄이고 유지보수도 편해지니까요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- `use client` 지시어는 해당 파일을 클라이언트 컴포넌트로 만들어 줍니다.\n- `dynamic` import에서 `ssr: false`를 설정하면 해당 컴포넌트는 서버 사이드 렌더링이 되지 않고 완전한 클라이언트 전용 컴포넌트(SPA)로 작동하게 됩니다.\n\n이제 이 내용을 반영해서 `page.tsx` (또는 `page.js`)를 다음처럼 업데이트해보세요:\n\n```js\nimport { ClientOnly } from './client'\n \nexport function generateStaticParams() {\n  return [{ slug: [''] }]\n}\n \nexport default function Page() {\n  return <ClientOnly />\n}\n```\n\n---\n\n### 8단계: Static Image Import 업데이트하기\n\n이제 정적 이미지 import를 업데이트할 차례입니다. Next.js에서는 이미지 최적화를 위해 `next/image` 컴포넌트를 많이 사용하는데요, 이 과정에서 이미지 import 방식을 다르게 해야 할 수도 있어요.\n\n예를 들어, 기존에 이렇게 이미지 파일을 바로 import 했다면:\n\n```js\nimport img from '../public/example.png'\n```\n\nNext.js에서는 이미지를 `next/image` 컴포넌트와 함께 쓰는 게 더 좋은데, 이렇게 바꿔볼 수 있답니다:\n\n```js\nimport Image from 'next/image'\n\nexport default function MyComponent() {\n  return (\n    <Image\n      src=\"/example.png\"\n      alt=\"예시 이미지\"\n      width={500}\n      height={300}\n    />\n  )\n}\n```\n\n이렇게 하면 기본적인 최적화(예: 레이지 로딩, 웹포맷 변환 등)를 자동으로 적용 받을 수 있어요.\n\n---\n\n추가 팁!  \n이미지가 자주 변경되지 않는다면 `next.config.js`에서도 이미지 도메인 설정을 확인해보세요. 외부에서 이미지를 불러온다면 CORS 문제도 방지할 수 있답니다.\n\n끝으로, 이미지 import와 관련해서 더 궁금한 게 있거나 실제 프로젝트에 적용해보고 싶다면 편하게 질문 주세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nCRA(Create React App)와 Next.js에서 이미지 파일을 다루는 방식의 차이를 한번 살펴볼게요.\n\n---\n\n### CRA에서 이미지 import하기\n\nCRA에서는 이미지 파일을 import 하면 이미지의 **공개 URL(문자열)**을 반환해요. 그래서 일반 `<img>` 태그의 `src` 속성에 바로 넣을 수 있죠.\n\n```jsx\nimport image from './img.png';\n\nexport default function App() {\n  return <img src={image} alt=\"example\" />;\n}\n```\n\n이 경우는 아주 직관적이고 사용하기 편해요. 이미지는 빌드 과정에서 public 경로로 복사되고, 이 URL이 변수에 저장됩니다.\n\n---\n\n### Next.js에서 이미지 import하기\n\n반면 Next.js에서는 이미지 import 시 **객체**를 반환해요. 이 객체는 이미지의 여러 메타데이터(예: `src`, `height`, `width`)를 가지고 있죠. 그래서 Next.js의 `Image` 컴포넌트와 같이 쓸 수 있어요.\n\n```jsx\nimport image from './img.png';\nimport Image from 'next/image';\n\nexport default function App() {\n  return <Image src={image} alt=\"example\" />;\n}\n```\n\n만약 기존에 사용하던 `<img>` 태그를 그대로 쓰고 싶으면 `image.src`처럼 객체에서 `src` 속성만 꺼내서 쓸 수도 있어요.\n\n```jsx\nimport image from './img.png';\n\nexport default function App() {\n  return <img src={image.src} alt=\"example\" />;\n}\n```\n\n---\n\n### Next.js `Image` 컴포넌트가 좋은 이유\n\n- **자동 이미지 최적화**: 이미지를 자동으로 최적화해서 브라우저에 적합한 형태로 보여줘요.\n- **너비와 높이 자동 설정**: 이미지 원본 크기 기반으로 `width`, `height` 속성을 자동으로 넣어줍니다. 그래서 이미지 로딩 시 레이아웃이 흔들리는 현상(Cumulative Layout Shift)을 줄여줘요.\n- **반응형 및 로딩 지연 기능**: 화면 크기에 맞춰 크기를 조절하거나, 이미지 로딩을 지연시키는 기능도 내장되어 있습니다.\n\n---\n\n### 알아두면 좋은 팁: styled 이미지와 레이아웃 이슈\n\n`Image` 컴포넌트가 자동으로 `width`와 `height` 속성을 넣어주는 덕분에 레이아웃 안정성이 좋아지지만, **이미지 스타일링에 주의해야 해요**.\n\n- 예를 들어 너비만 고정하고(가로 크기만 지정), 높이는 CSS에서 자동(`auto`)으로 두지 않으면,\n- 그 높이는 원본 이미지 크기가 아닌 `Image` 컴포넌트가 자동으로 지정한 높이 값으로 설정되면서,\n- 이미지가 찌그러지거나 늘어져 보일 수 있어요.\n\n그럴 때는 `height`도 `auto`로 설정하거나, 둘 다 명확한 값을 주도록 CSS를 조절하는 게 좋습니다.\n\n---\n\n### 간단 비교 표\n\n| 구분                    | CRA                        | Next.js                       |\n|-------------------------|----------------------------|-------------------------------|\n| 이미지 import 결과      | 문자열(URL)                 | 객체({ src, width, height })  |\n| 이미지 태그             | `<img src={image} />`       | `<Image src={image} />` or `<img src={image.src} />` |\n| 이미지 최적화           | 별도 설정 필요               | 자동 제공                       |\n| 너비/높이 속성 자동 지정 | X                          | O                              |\n| 레이아웃 흔들림 방지      | 브라우저 기본 영향           | 자동 설정으로 방지 가능         |\n\n---\n\n요약하자면, Next.js는 이미지 최적화와 레이아웃 안정성에 초점을 맞춘 방식이에요. 기존 CRA 방식에 익숙해도 Next.js 방식으로 넘어오면 이런 점들을 기억하면 좋겠죠?  \n\n그럼 다음에도 개발에 꿀팁들로 찾아올게요! 😊\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이미지를 다룰 때 `img` 태그를 계속 사용하면 애플리케이션에 변경 사항을 최소화할 수 있어서 예상치 못한 문제를 줄일 수 있어요. 나중에 여유가 된다면 `Image` 컴포넌트로 천천히 옮겨가면서, 이미지 최적화를 위한 로더 설정을 하거나 Next.js 기본 서버에서 제공하는 자동 이미지 최적화 기능을 활용할 수 있답니다.\n\n그리고 `/public` 폴더에서 이미지를 가져올 때 절대 경로 대신 상대 경로를 쓰는 게 좋아요. 이렇게 하면 경로 문제가 훨씬 덜 생기고, 프로젝트 구조가 좀 더 명확해지거든요:\n\n```js\n// Before\nimport logo from '/logo.png'\n\n// After\nimport logo from '../public/logo.png'\n```\n\n또한, `img` 태그에 이미지를 넘겨줄 땐 이미지 객체 전체를 넘기지 말고, **`src` 속성에 이미지 경로만 넘기는 것**이 좋습니다. 이렇게 하면 불필요한 데이터가 전달되는 걸 막을 수 있거든요.\n\n예를 들어:\n\n```jsx\n// Bad\n<img {...logo} alt=\"logo\" />\n\n// Good\n<img src={logo.src} alt=\"logo\" />\n```\n\n추가로, Next.js의 `Image` 컴포넌트를 쓰면 이미지 로딩 최적화, 레이지 로딩, 적절한 크기 조절 등이 자동으로 처리돼서 퍼포먼스에 큰 도움이 돼요. 처음에는 조금 복잡해 보일 수 있지만, 한두 번 써보면 금방 익숙해질 거예요. 필요에 따라서 점진적으로 바꿔가면서 적용해보세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n앞서 예제로 보여준 이미지 태그 변경 방식에 대해 조금 더 풀어서 설명해볼게요.\n\n```jsx\n// Before\n<img src={logo} />\n\n// After\n<img src={logo.src} />\n```\n\n보통 Next.js나 modern 프레임워크에서 이미지를 다룰 때, 그냥 `logo`만 넘기면 문제가 생길 수 있어요. 그래서 실제 이미지 URL을 가리키는 `logo.src`를 명시해줘야 하죠.\n\n또 다른 방법으로는, 이미지 자산을 `public` 폴더에 넣어서 사용하는 거예요. 예를 들어 `public/logo.png`파일을 두면, HTML에 `<img src=\"/logo.png\" />`처럼 경로를 쓸 수 있고, 이 경우 코드에서는 `src=\"/logo.png\"`라고 작성하면 돼요.\n\n---\n\n### 타입스크립트를 쓴다면 주의할 점!\n\n이미지 객체에서 `.src`프로퍼티를 사용하면 타입 에러가 뜰 수 있어요. 이럴 땐 `tsconfig.json` 파일에 `next-env.d.ts`를 포함시켜줘야 하는데요,\n\n```json\n// tsconfig.json 일부 예시\n{\n  \"include\": [\n    \"next-env.d.ts\",\n    \"**/*.ts\",\n    \"**/*.tsx\"\n  ]\n}\n```\n\n`next-env.d.ts` 파일은 Next.js가 자동으로 생성해주니까, 앱을 한번 실행하면 생성돼요.\n\n---\n\n### 참고로, Step 9: 환경변수 마이그레이션\n\n이제 다음 단계인 9단계는 환경 변수 마이그레이션이에요. 환경 변수는 API 키나 시크릿 같이 숨겨야 하는 정보를 관리할 때 꼭 필요한데, 마이그레이션하면서 설정법이 약간 달라질 수 있으니 꼼꼼히 확인하세요.\n\n---\n\n### 팁!\n\n- Next.js에서 `public` 폴더를 쓰면, 이 폴더에 있는 파일은 경로 그대로 접근할 수 있으니 간단하게 이미지나 favicon 같은 정적 자산을 관리하기 좋아요.\n- 만약 이미지를 import해서 쓰고 싶으면, Next.js Image 컴포넌트(`<Image />`)를 사용하는 것도 성능 최적화에 도움이 됩니다.\n\n이렇게 하면 쉽게 이미지 경로 문제와 타입스크립트 오류를 해결 할 수 있어요. 다음 포스팅에서는 환경변수 마이그레이션에 대해 차근차근 알려드릴게요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서 환경변수 사용법은 Create React App(CRA)과 비슷한데, 브라우저에서 노출하려는 변수에는 반드시 `NEXT_PUBLIC_` 접두사를 붙여야 해요.\n\n여기서 가장 큰 차이는 클라이언트 쪽에 노출할 환경변수에 어떤 접두사를 쓰느냐입니다. CRA에서는 `REACT_APP_` 을 사용했지만, Next.js에서는 이걸 전부 `NEXT_PUBLIC_` 으로 바꿔줘야 해요.\n\n---\n\n### Step 10: package.json 스크립트 업데이트하기\n\n`package.json` 안의 스크립트도 Next.js에 맞게 수정해줘야 합니다. 그리고 `.next` 폴더랑 `next-env.d.ts` 파일은 깃에 커밋할 필요가 없으니 `.gitignore`에 꼭 추가해 주세요.\n\n---\n\n아래는 예시로 바꿔줄 수 있는 문법입니다:\n\n| 기존 (CRA)                            | 변경 후 (Next.js)                             |\n|-------------------------------------|---------------------------------------------|\n| `REACT_APP_API_URL=http://localhost`| `NEXT_PUBLIC_API_URL=http://localhost`      |\n| `npm start`                         | `next start`                                |\n| `npm run build`                    | `next build`                                |\n| `npm run dev`                      | `next dev`                                  |\n\n---\n\n`.gitignore`에 다음 내용 추가하기:\n\n\n.next/\nnext-env.d.ts\n\n\n---\n\n**참고로**  \nNext.js는 서버 사이드 렌더링(SSR)도 지원하기 때문에, 서버에서만 사용할 환경변수와 클라이언트에서도 필요한 환경변수를 구분해서 관리하면 더 효율적입니다. 예를 들어, DB 비밀번호같은 민감한 정보는 `NEXT_PUBLIC_` 없이 관리해서 클라이언트로 노출되지 않도록 하세요.\n\n그럼 다음 단계에서는 Next.js 프로젝트에서 환경변수를 어떻게 효율적으로 사용하는지, 그리고 SSR과의 연계 방법도 살펴보겠습니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안녕하세요! 오늘은 Next.js 프로젝트에서 자주 볼 수 있는 스크립트 설정과 관련된 내용을 간단히 정리해볼게요.\n\n먼저 `package.json` 파일에 다음과 같은 스크립트가 있어요:\n\n```json\n{\n  \"scripts\": {\n    \"dev\": \"next dev --turbopack\",\n    \"build\": \"next build\",\n    \"start\": \"npx serve@latest ./build\"\n  }\n}\n```\n\n### 스크립트 설명\n- `dev`: 개발 모드로 실행하는 스크립트예요. `next dev --turbopack` 명령어는 Next.js 개발 서버를 Turbopack 빌드러로 실행하게 해주는데, Turbopack은 Webpack보다 훨씬 빠른 빌드 속도를 자랑하는 차세대 번들러입니다. 아직 완전한 안정화 단계는 아니지만, 속도가 매우 빠르니 한 번 써보시는 걸 추천해요!\n- `build`: 프로젝트를 빌드합니다. 실제 서비스용으로 준비할 때 사용해요.\n- `start`: 빌드된 결과물을 실행하는 명령어인데, 여기선 `serve` 라는 간단한 HTTP 서버를 실행해서 `./build` 폴더 내부를 서비스하도록 되어 있어요. 이 부분은 간단한 정적 서버를 실행하고 싶을 때 유용해요.\n\n---\n\n그 다음, 프로젝트 폴더 안에는 다음과 같은 파일 or 폴더가 있을 텐데요:\n\n```js\n.next\nnext-env.d.ts\n```\n\n- `.next` 폴더는 Next.js가 빌드하면서 자동으로 생성하는 캐시 및 빌드 결과물 폴더입니다. 이 폴더는 직접 수정하지 않는 게 좋아요.\n- `next-env.d.ts`는 TypeScript를 사용할 때 Next.js에서 자동으로 생성하는 환경 설정 파일이에요. typings 관련 설정이 들어있죠.\n\n---\n\n### 실행 방법\n모든 셋팅이 끝나면, 터미널에서 아래 명령어로 개발 서버를 켤 수 있어요:\n\n```bash\nnpm run dev\n```\n\n이 명령어가 실행되면, `localhost:3000`(기본값)에서 Next.js 애플리케이션을 확인할 수 있습니다!\n\n---\n\n### 추가 팁!\n\n1. **Turbopack 사용 시 주의점**  \n   아직 Turbopack은 실험 단계이므로 일부 패키지나 기능이 제대로 동작하지 않을 수 있어요. 안정적인 개발 환경을 원한다면 `next dev` 명령어를 그냥 쓰거나, 옵션 없이 실행하는 것도 고려해보세요.\n\n2. **`start` 스크립트 변경하기**  \n   `npx serve`는 설치없이 바로 사용할 수 있어 편리하지만, 실제 프로덕션 서버에서는 [PM2](https://pm2.keymetrics.io/) 같은 프로세스 매니저를 쓰거나, Next.js가 자체적으로 제공하는 `next start` 명령어(서버 사이드 렌더링 가능)를 사용하는 게 더 적합합니다.\n\n3. **환경 설정**  \n   Next.js를 본격적으로 다룰 때는 `.env.local` 같은 환경 변수 파일을 사용해 API 키나 민감한 정보를 관리하는 것도 중요해요.\n\n오늘은 Next.js 프로젝트에서 자주 쓰이는 기본 스크립트와 환경을 정리해봤어요. 다음에 더 재밌는 내용으로 찾아올게요! :)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nhttp://localhost:3000 에 접속해보세요. 그러면 Next.js로 실행 중인 여러분의 애플리케이션이 (SPA 모드로) 잘 돌아가는 걸 확인할 수 있을 거예요.\n\n### 11단계: 정리 작업하기\n\n이제 Create React App에서 사용하던 것들을 정리할 차례입니다. Next.js로 완전히 넘어왔으니 불필요한 파일과 설정들을 깔끔하게 치워주면 좋아요.\n\n다음 항목들을 프로젝트에서 제거해 주세요:\n\n| 제거해야 할 항목                        | 설명                                                 |\n|-------------------------------------|----------------------------------------------------|\n| `public/index.html`                  | CRA의 루트 HTML 파일로, Next.js에선 필요 없어요           |\n| `src/index.tsx`                     | CRA의 진입점 파일, Next.js에선 `pages` 폴더가 담당해요 |\n| `src/react-app-env.d.ts`             | CRA 사용 시 타입스크립트 환경설정용 파일                  |\n| reportWebVitals 관련 설정               | 퍼포먼스 측정을 위한 CRA 전용 설정, 필요 없어요                |\n| `react-scripts` 의존성 제거          | `package.json`에서 CRA를 위한 스크립트 의존성도 삭제하세요    |\n\n이렇게 정리하면 프로젝트가 훨씬 깔끔해지고, Next.js에 맞는 환경으로 잘 정돈됩니다. 여기서 더 나아가, 만약 CRA에서 사용하던 스타일링이나 기타 라이브러리가 Next.js와 충돌난다면 버전이나 설정도 한 번 점검해 보세요.\n\n정리 과정에서 궁금한 점 있으면 언제든 물어봐 주세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 추가로 알아두면 좋은 점\n\n### CRA에서 커스텀 홈페이지 경로 사용하기\n\n만약 CRA(Create React App)에서 package.json의 `homepage` 필드를 이용해 앱을 특정 서브 경로(예: `/my-subpath`)에 배포했다면, Next.js에서도 비슷하게 설정할 수 있어요. Next.js는 `next.config.ts`에서 `basePath` 설정을 통해 이 기능을 제공한답니다!\n\n예를 들어, 아래처럼 작성하면 `/my-subpath` 하위 경로에 앱을 서빙할 수 있어요:\n\n```typescript\nimport { NextConfig } from 'next'\n\nconst nextConfig: NextConfig = {\n  basePath: '/my-subpath',\n  // 추가 설정들..\n}\n\nexport default nextConfig\n```\n\n이렇게 설정하면 모든 페이지 경로가 `/my-subpath`를 기준으로 동작하게 돼요. 예를 들어, `/about` 페이지는 실제로 `/my-subpath/about`로 접근하는 식이죠.\n\n> 참고로, `basePath`를 사용하면 정적 자원(css, 이미지 등) 경로도 함께 신경 써야 해요. 보통 Next.js가 알아서 처리하지만, 직접 경로를 지정할 때는 `basePath`를 붙여주는 걸 잊지 마세요!\n\n---\n\n### 추가 팁\n\n- **환경별 경로 분기**: 개발 환경에선 `basePath`를 빈값으로 두고, 배포 환경에선 서브 경로를 지정하는 경우가 많아요. 이 경우 `next.config.ts`에서 환경변수로 분기 처리하는 걸 추천합니다.\n- **Rewrite, Redirect와 함께 쓰기**: `basePath`는 URL 기본 경로를 바꾸는 설정이라, 리라이트나 리다이렉트를 할 때 함께 고려하면 UX를 향상시킬 수 있어요.\n- **Custom 서버 없이 사용 가능**: CRA처럼 별도의 서버 설정 없이도 Next.js가 자체적으로 `basePath` 처리를 해주기 때문에 편리해요.\n\nNext.js로 이전하면서 서브 경로 관련 설정 고민이라면, `basePath`를 꼭 살펴보세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 커스텀 서비스 워커 다루기\n\n만약에 Create React App(CRA)에서 제공하는 serviceWorker.js를 사용했다면, Next.js로 Progressive Web Application(PWA)을 만드는 방법도 알아두면 좋아요. CRA와 Next.js는 서비스 워커를 다루는 방식이 조금 다르지만, Next.js에서는 커스텀 서비스 워커를 직접 등록하고 관리할 수 있기 때문에 더 유연하게 사용할 수 있답니다.\n\n예를 들어, CRA에서는 서비스 워커가 기본적으로 제공되면서 간단하게 PWA를 만들 수 있는 반면, Next.js에서는 `public` 폴더에 직접 서비스 워커 파일을 넣고, `_app.js` 혹은 커스텀된 `_document.js`에서 직접 등록 스크립트를 추가하는 형태로 작업해요. 그래서 더 맞춤형 접근이 가능하고 필요에 따라 기능을 확장하기 편하죠.\n\n참고로, Next.js 공식 문서에도 PWA를 위한 별도 플러그인(next-pwa) 사용법이 소개되어 있는데, 이걸 활용하면 서비스 워커 등록과 캐시 관리가 더 쉬워져요. 관심 있다면 한번 살펴보시는 걸 추천드립니다!\n\n---\n\n### API 요청 프록시 처리하기\n\nCRA에서 `package.json`에 `\"proxy\"` 필드를 넣어 API 요청을 백엔드 서버로 바로 보내는 방식 많이 써봤을 텐데요. Next.js에서는 이 역할을 `next.config.ts` 파일의 `rewrites`로 손쉽게 대체할 수 있어요.\n\n아래는 예시인데요, 앞에 `/api`로 들어오는 요청을 실제 백엔드 API 서버 주소로 '재작성'해주는 역할을 합니다.\n\n```ts\n// next.config.ts\nimport { NextConfig } from 'next'\n\nconst nextConfig: NextConfig = {\n  async rewrites() {\n    return [\n      {\n        source: '/api/:path*', // Next.js 앱에서 /api/** 요청 감지\n        destination: 'https://backend.example.com/api/:path*', // 실제 백엔드 서버 주소로 포워딩\n      },\n    ]\n  },\n}\n\nexport default nextConfig\n```\n\n이렇게 설정하면 클라이언트 쪽에서는 별다른 변경 없이 `/api/`로 요청을 보내면 되고, Next.js가 알아서 백엔드 서버랑 연결해 주니까 개발이 훨씬 편해져요.\n\n> 그리고 한 가지 팁! 만약 배포 환경별로 백엔드 주소가 다르다면, 환경변수를 활용해 `destination` 값을 불러오는 방식을 추천해요. 이렇게 하면 개발/운영 환경을 쉽게 분리해서 관리할 수 있습니다.\n\n---\n\n이상으로 CRA에서 Next.js로 넘어오면서 서비스 워커와 API 프록시 처리를 어떻게 할 수 있는지 간단하게 정리해봤어요. 직접 해보면서 궁금한 점 있으면 언제든 물어봐 주세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서 설정을 확장하거나 API 경로 리라이트를 적용하는 방법에 대해 알려드릴게요. CRA(Create React App)에서 custom webpack이나 Babel 설정을 하셨다면, Next.js에서는 next.config.ts 파일을 통해 비슷한 작업을 할 수 있습니다.\n\n### API 요청 리라이트 설정하기\n\n예를 들어, 프론트엔드에서 `/api/`로 시작하는 경로를 실제 백엔드 서버인 `https://your-backend.com`으로 리다이렉션하고 싶다면, 다음과 같이 `rewrites()` 함수를 사용하면 됩니다.\n\n```ts\nimport { NextConfig } from 'next'\n\nconst nextConfig: NextConfig = {\n  async rewrites() {\n    return [\n      {\n        source: '/api/:path*',\n        destination: 'https://your-backend.com/:path*',\n      },\n    ]\n  },\n}\n\nexport default nextConfig\n```\n\n**간단 설명:**\n\n- `source`: 클라이언트에서 요청하는 경로 패턴입니다.\n- `destination`: 실제 처리할 백엔드 서버 주소로, 여기서 `:path*`는 와일드카드 역할을 해서 `/api` 뒤의 경로가 그대로 유지됩니다.\n\n이렇게 설정하면 서버와 클라이언트 도메인이 달라도 CORS 문제 없이 API 호출이 가능하답니다.\n\n### 커스텀 Webpack 또는 Babel 설정 적용하기\n\nCRA에서는 `webpack.config.js`나 `babel.config.js`를 직접 고치지만, Next.js에서 그런 설정을 건드리고 싶으면 `next.config.ts`에 `webpack` 설정을 추가하세요.\n\n```ts\nimport { NextConfig } from 'next'\n\nconst nextConfig: NextConfig = {\n  webpack: (config, { isServer }) => {\n    // 여기에 커스텀 webpack 설정 작성하기\n    // 예: 특정 플러그인 추가하거나 로더 수정 가능\n    return config\n  },\n}\n\nexport default nextConfig\n```\n\n#### 추가 팁\n\n- `config`는 기본 Next.js가 제공하는 webpack 설정 객체입니다.\n- `isServer`는 해당 설정이 서버용인지 클라이언트용인지를 알려줘요.\n- 필요에 따라 `config.plugins.push()`나 `config.module.rules.push()` 같은 방식으로 원하는 로더, 플러그인을 추가할 수 있습니다.\n\n---\n\nNext.js 설정은 이렇게 하면 되는데, 만약 Babel 설정도 손대고 싶다면 `babel.config.js` 혹은 `.babelrc` 파일을 루트에 만들어서 관리하는 게 좋아요. Next.js는 기본적으로 내장된 Babel 설정을 사용하지만, 커스텀하게 플러그인이나 프리셋을 추가하고 싶을 때는 별도로 설정 가능합니다.\n\nNext.js로 마이그레이션하거나 커스텀 빌드 환경을 조절할 때, 이 부분만 잘 이해하면 성공적인 프로젝트 세팅에 많은 도움이 될 거예요! 혹시 더 궁금한 점 있으면 언제든 물어보세요. 🙂\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n> 참고: 이 작업을 하려면 dev 스크립트에서 --turbopack 옵션을 제거해서 Turbopack을 비활성화해야 합니다.\n\n### TypeScript 설정하기\n\nNext.js는 프로젝트에 tsconfig.json 파일이 있으면 자동으로 TypeScript 환경을 설정해줍니다. 이때 tsconfig.json 파일 내에서 `next-env.d.ts`가 반드시 include 배열에 포함되어야 하는데요, 이렇게 해줘야 Next.js가 타입 정보를 제대로 인식할 수 있어요. 아래처럼 설정하면 됩니다:\n\n```json\n{\n  \"include\": [\"next-env.d.ts\", \"app/**/*\", \"src/**/*\"]\n}\n```\n\n여기서 `next-env.d.ts` 파일은 Next.js가 자동 생성해주는 타입 선언 파일로, 꼭 포함되어 있어야 타입 체크가 정상적으로 작동해요. 만약 이 부분을 빼먹으면 간헐적으로 타입 에러가 발생할 수 있으니 꼭 확인하세요!\n\n추가로, 앱 구조에 따라 `app/**/*`이나 `src/**/*` 대신 다른 폴더 경로를 넣어주셔도 되고, 프로젝트에 맞게 수정하시면 됩니다. 이처럼 include 배열 안에 TypeScript로 작성될 소스 파일 위치들을 모두 포함시켜야 빌드 시 누락 없이 타입 검사가 진행돼요.\n\nTypeScript를 적용하면 코드 안정성도 높아지고, 자동완성 및 인텔리센스 지원도 좋아져서 개발이 훨씬 편해집니다. Next.js에서는 기본적으로 환경 세팅을 많이 도와주니 크게 신경 쓰지 않아도 되지만, 꼼꼼히 한 번 확인만 해주시면 되겠습니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 번들러 호환성\n\nCreate React App과 Next.js는 기본적으로 웹팩(webpack)을 번들러로 사용해요. 다만, Next.js는 로컬 개발을 더 빠르게 할 수 있게 도와주는 새로운 번들러인 Turbopack도 지원하는데요, 이렇게 실행할 수 있어요:\n\n```bash\nnext dev --turbopack\n```\n\n이게 바로 Next.js에서 Turbopack을 활성화하는 명령어입니다. Turbopack은 웹팩보다 훨씬 빠른 빌드 속도를 자랑해서, 특히 개발할 때 생산성을 높여줘요.\n\n하지만 기존에 Create React App에서 쌓아온 웹팩 설정 같은 고급 설정을 그대로 옮기고 싶다면, Next.js에서도 커스텀 웹팩 설정을 적용할 수 있으니 걱정하지 마세요. 개발 환경에 따라 필요에 맞게 유연하게 쓸 수 있다는 점이 장점입니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 다음 단계 (Next Steps)\n\n잘 따라왔다면, 이제 Next.js 애플리케이션이 단일 페이지 애플리케이션(SPA)으로 제대로 동작하고 있을 거예요. 지금은 Next.js의 강력한 기능들, 예를 들어 서버 사이드 렌더링(SSR)이나 파일 기반 라우팅 같은 것을 활용하지 않은 상태인데요. 이제부터 천천히 하나씩 적용해나가면 됩니다!\n\n### 앞으로 해볼 만한 것들\n\n| 작업 | 설명 |\n|---|---|\n| React Router에서 Next.js App Router로 마이그레이션 | Next.js가 제공하는 **자동 코드 분할**, **스트리밍 서버 렌더링**, **React Server Components**를 활용할 수 있어요. |\n| 이미지 최적화 | `Image` 컴포넌트를 사용하면 웹 성능 향상에 크게 도움이 됩니다. |\n| 폰트 최적화 | `next/font`를 활용해 폰트를 최적화하면 페이지 로딩 속도가 더 빨라져요. |\n| 서드파티 스크립트 최적화 | `Script` 컴포넌트를 사용해 외부 스크립트를 효율적으로 로딩하세요. |\n| ESLint 활성화 | `npx next lint`를 실행해 Next.js 추천 규칙으로 ESLint를 설정하고, 프로젝트에 맞게 커스터마이징하면 코드 품질 유지에 좋습니다. |\n\n### 참고 사항\n\n> 지금 만약 `next.config.ts`에서 **출력 형식을 static export (output: `export`)**로 설정했다면, `useParams` 훅이나 다른 서버 사이드 기능들은 사용할 수 없어요. Next.js의 모든 기능을 활용하려면 `output: 'export'` 설정을 삭제하는 게 좋아요.\n\n---\n\n### 추가로 알려드리고 싶은 팁!\n\n- **App Router와 Server Components**: Next.js 13부터 도입된 App Router와 React Server Components는 UI를 효율적으로 렌더링하고 데이터 페칭을 더 직관적으로 처리할 수 있게 해줍니다. 새 프로젝트라면 꼭 도입을 고려해보세요!\n- **이미지 최적화**: 일반 `<img>` 태그 대신 `next/image`를 쓰면 이미지 사이즈에 맞춰 자동 최적화되고, Lazy loading도 기본으로 됩니다. 성능 향상에 크게 기여하죠.\n- **ESLint 도입은 꼭 하자!** Next.js가 기본으로 권장하는 ESLint 규칙은 최신 React 및 Next.js 코딩 스타일에 맞춰져 있으니 꼭 설정해 두시길 권장해요. 초기부터 코드 품질을 잘 관리하면 나중에 유지보수도 한결 쉬워집니다.\n\n이제 Next.js의 진짜 힘을 경험할 준비가 됐네요! 궁금한 점 있으면 언제든 찾아주세요. 같이 멋진 웹 앱 만들어봐요! 🚀","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":40},{"title":"Nextjs 13에서 Pages에서 App Router로 마이그레이션하는 방법 완벽 가이드","description":"","date":"2025-04-22 01:20","slug":"2025-04-22-HowtomigratefromPagestotheAppRouter","content":"\n\n# Pages에서 App Router로 마이그레이션하는 법\n\n이번 글에서는 Next.js 12에서 13으로 업데이트하면서, 기존의 pages 디렉토리 기반 애플리케이션을 app 디렉토리 기반으로 점진적으로 옮기는 방법을 알려드릴게요. 뿐만 아니라 pages와 app 디렉토리 양쪽에서 모두 작동하는 업그레이드 팁도 함께 다룹니다.\n\n## 업그레이드하기\n\n(이하 본문이 계속 이어지겠죠)\n\n---\n\nNext.js 13은 app 디렉토리로 라우팅 방식을 대대적으로 바꾸면서 더 유연하고 강력해졌어요. 하지만 갑작스럽게 모두 바꾸기엔 부담스러우니, 페이지 단위로 조금씩 옮길 수 있도록 설계된 점도 매력 포인트입니다.\n\n특히 기존에 pages 기반으로 만들어둔 큰 프로젝트라면, 한 번에 바꾸기보단 섹션별로 앱 디렉토리 구조를 도입하면서 자연스럽게 최신 기능들을 써볼 수 있어요.\n\n예를 들어 `pages/about.js`는 아직 냅두고, 새로 만들거나 자주 바꾸는 부분부터 app 폴더 내부의 컴포넌트 및 레이아웃으로 점차 변경해보는 걸 추천합니다.\n\n---\n\n뒤에서 더 자세히 살펴볼게요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### Node.js 버전\n\n최소 Node.js 버전이 이제 v18.17로 올라갔어요. 자세한 내용은 [Node.js 공식 문서](https://nodejs.org/en/docs/)에서 확인할 수 있으니 참고해 보세요.\n\n### Next.js 버전\n\nNext.js를 13버전으로 업데이트하려면, 아래 명령어를 사용하는 패키지 매니저에 맞춰 실행하면 됩니다:\n\n```bash\n# npm 사용 시\nnpm install next@13\n\n# yarn 사용 시\nyarn add next@13\n\n# pnpm 사용 시\npnpm add next@13\n```\n\n---\n\n> 여기서 잠깐!  \n> Next.js 13은 여러 신기능과 성능 개선이 함께 들어왔어요. 예를 들어, 새로운 App Router가 도입되어 페이지 라우팅이 더 유연해졌고, React Server Components도 지원하죠. 업데이트 전에 꼭 [Next.js 13 공식 문서](https://nextjs.org/blog/next-13)를 한 번 살펴보시면 도움이 될 거예요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```bash\nnpm install next@latest react@latest react-dom@latest\n```\n\n### ESLint 버전 업데이트\n\n만약 ESLint를 사용하고 있다면, ESLint 버전도 함께 업그레이드해주는 게 좋아요!\n\n```bash\nnpm install -D eslint-config-next@latest\n```\n\n> 참고로 ESLint 설정 파일(.eslintrc.js 등)에서 `eslint-config-next`를 베이스로 사용한다면, 버전이 맞지 않으면 Next.js와 충돌이 날 수 있어서 꼭 같이 업데이트 해주세요.\n\n그리고 혹시 ESLint가 처음이라면, Next.js에서 기본적으로 권장하는 ESLint 설정을 따라서 쓰는 걸 추천해요. 코딩 컨벤션을 맞추고 코드 품질을 높이는 데 도움 되니까요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n알아두면 좋은 팁: ESLint 설정을 변경한 후에는 VS Code에서 ESLint 서버를 재시작해줘야 변경 사항이 제대로 반영될 수 있어요. 재시작 방법은 간단해요! Mac에서는 cmd+shift+p, Windows에서는 ctrl+shift+p를 눌러 커맨드 팔레트를 열고 'ESLint: Restart ESLint Server'를 검색해서 실행하면 됩니다.\n\n---\n\n## 다음 단계\n\n업데이트를 마쳤다면 아래 섹션들을 참고해서 다음 과정을 진행해보세요:\n\n- **새로운 기능 업그레이드하기**: 향상된 Image 컴포넌트와 Link 컴포넌트를 비롯한 새로운 기능들로 업그레이드하는 방법을 알려주는 가이드입니다.  \n- **pages 디렉터리에서 app 디렉터리로 마이그레이션하기**: 기존의 pages 디렉터리에서 점진적으로 app 디렉터리로 전환하는 단계별 가이드로, 프로젝트 구조를 최신 방식으로 바꾸는 데 도움을 줍니다.\n\n---\n\n+ 팁을 한 가지 더 드리자면, ESLint 서버 재시작은 설정 변경 후 바로바로 효과를 보고 싶을 때 꼭 해주는 게 좋아요. 가끔은 VS Code를 전체 종료하고 다시 여는 것보다 훨씬 빠른 해결책이 될 때가 많답니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## Next.js 13에서 새 기능 업그레이드하기\n\nNext.js 13에서는 새로운 App Router가 도입되면서 여러 가지 기능과 컨벤션들이 추가됐어요. 이 새로운 라우터는 `app` 디렉토리 안에서 사용 가능하고, 기존의 `pages` 디렉토리와도 함께 공존할 수 있답니다.\n\n중요한 점은, Next.js 13으로 업그레이드한다고 해서 반드시 App Router를 바로 사용해야 하는 건 아니에요! 기존에 쓰던 `pages` 디렉토리 기반 라우팅도 계속 쓸 수 있고, 두 디렉토리 모두에서 동작하는 최신 기능들도 사용할 수 있다는 점이죠. 예를 들면, 업데이트된 `Image` 컴포넌트, `Link` 컴포넌트, `Script` 컴포넌트, 그리고 폰트 최적화 같은 기능들이 그런 것들이에요.\n\n### `Image` 컴포넌트\n\nNext.js 13에서 `Image` 컴포넌트가 훨씬 더 좋아졌어요! 이전 버전에 비해서 성능과 사용성이 많이 개선됐고, 이제부터는 자동으로 이미지 최적화가 더 강화되었답니다.\n\n#### 주요 특징\n- **자동 사이즈 조절**: 이미지 크기를 코드에 명시하지 않아도, Layout을 통해 적절히 크기를 잡아줘요.\n- **새로운 레이아웃 옵션들**: `fill`, `fixed`, `intrinsic` 등 다양한 레이아웃 옵션이 추가되어 원하는 스타일에 맞게 조절 가능해요.\n- **새로운 `priority` 옵션**: 중요한 이미지를 먼저 불러올 수 있게끔 설정할 수 있어요.\n- **향상된 WebP 변환**: 웹 최적화를 위해 자동으로 WebP 포맷 변환을 지원하고 있어요.\n\n저는 개인적으로 Next.js 13의 `Image` 컴포넌트를 사용하면서 페이지 로딩 속도가 확실히 빨라진 느낌이에요. 그리고 개발자가 직접 신경 써야 하는 부분이 줄어들어서, 더욱 편리하게 이미지를 다룰 수 있다는 점이 너무 좋더라고요.\n\n---\n\n참고로, Next.js 새 기능은 공식 문서가 정말 잘 되어 있으니, 새로운 App Router를 천천히 공부해보고 싶다면 [Next.js 공식 문서](https://nextjs.org/docs)에서 자세한 내용을 꼭 확인해 보시길 추천드릴게요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js 12 버전에서 Image 컴포넌트에 새로운 개선사항이 도입되었는데, 임시로 next/future/image에서 불러오는 방식이었어요. 이 개선사항에는 클라이언트 쪽 자바스크립트가 줄어들고, 이미지 확장과 스타일링이 더 쉬워졌으며, 접근성도 좋아졌고 네이티브 브라우저의 지연 로딩(lazy loading) 기능도 지원되었답니다.\n\n그런데 Next.js 13 버전에서는 이 새로운 동작 방식이 next/image의 기본값으로 완전히 자리잡았어요!\n\n기존 프로젝트에서 이 새로운 Image 컴포넌트로 쉽게 마이그레이션할 수 있도록 두 가지 코드를 변환해주는 'codemod' 스크립트를 제공합니다:\n\n| 코덱모드 이름                     | 설명                                                                                           | 주의사항                                                 |\n|-----------------------------|----------------------------------------------------------------------------------------------|------------------------------------------------------|\n| next-image-to-legacy-image   | next/image로 임포트한 부분을 자동으로 next/legacy/image로 안전하게 이름 변경해줌. 기존 컴포넌트의 동작이 그대로 유지됨. | 이 변환은 안전해서 바로 적용 가능.                         |\n| next-image-experimental      | 인라인 스타일을 과감하게 추가하고, 사용되지 않는 props를 제거함. 기존 컴포넌트 동작이 바뀌어 새로운 기본 동작을 따라가게 됨. | 사용하려면 먼저 next-image-to-legacy-image codemod를 실행해야 함. 변경점이 꽤 크니까 테스트 철저히 할 것! |\n\n마이그레이션할 때 참고해 보세요!\n\n추가로, Image 컴포넌트의 변경덕분에 SEO 최적화, 페이지 렌더링 속도 개선과 같은 장점도 누릴 수 있답니다. 특히 lazy loading은 이미지가 화면에 보일 때만 로드되니 초기 로딩 속도가 확실히 빨라지고, 불필요한 데이터 낭비도 줄어들어요. Next.js 13으로 업데이트 하면서 Image 컴포넌트도 꼭 점검해보세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### `Link` 컴포넌트 변화 소개\n\n안녕하세요! 오늘은 Next.js의 `Link` 컴포넌트 사용법이 어떻게 바뀌었는지 쉽게 알려드릴게요.\n\n옛날 버전인 Next.js 12까지는 `Link`를 사용할 때, 내부에 꼭 `<a>` 태그를 직접 감싸줘야 했어요. 예를 들어, 이렇게요:\n\n```js\n<Link href=\"/about\">\n  <a>About</a>\n</Link>\n```\n\n만약 `<a>`를 안 쓰면 제대로 작동하지 않았죠. 그런데 12.2버전부터는 이게 실험적인 기능으로 바뀌었고, Next.js 13에서는 아예 기본 동작이 바뀌었답니다. 이제는 `<Link>` 자체가 내부적으로 `<a>` 태그를 자동으로 렌더링해줘서, 우리가 굳이 `<a>` 태그를 감싸줄 필요가 없어요!\n\n즉, 이렇게 간단하게 써도 됩니다:\n\n```js\n<Link href=\"/about\">\n  About\n</Link>\n```\n\n이렇게 하면 Next.js가 내부적으로 `<a>` 태그를 알아서 처리해주니까 훨씬 편하죠.\n\n---\n\n> 개인적으로 느낀 점은, 개발할 때 코드가 깔끔해지고, 실수로 `<a>`를 빼먹는 실수도 방지할 수 있다는 점이 좋았어요. 그리고 스타일링도 `Link` 컴포넌트에 바로 props를 넘겨서 할 수 있으니 편리하답니다!\n\n---\n\n요약하자면:  \n- Next.js 12까지는 `<Link>` 안에 직접 `<a>` 태그를 넣어야 했어요.  \n- Next.js 13부터는 `<Link>`가 자동으로 `<a>` 태그를 렌더링합니다.  \n- 코드가 더 깔끔해지고 사용하기 편해졌답니다!\n\n이렇게 간단하지만 개발자 경험을 꽤 개선한 부분이라 꼭 알아두세요~!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js 13로 링크를 업그레이드하려면 `new-link` 코덱모드(codemod)를 활용할 수 있어요. 이건 자동으로 코드를 바꿔주니까 한 번 활용해보면 편리하답니다.\n\n### `Script` 컴포넌트\n\nNext.js 13에서 `next/script`의 동작 방식이 업데이트되면서, pages와 app 디렉토리 양쪽을 지원하지만, 원활하게 마이그레이션 하려면 몇 가지 주의할 점이 있어요.\n\n| 변경 사항 | 설명 |\n| --------- | ----- |\n| beforeInteractive 스크립트 이동 | 기존에 `_document.js`에 넣었던 `beforeInteractive` 스크립트는 `app/layout.tsx` 루트 레이아웃 파일로 옮겨야 해요. 그래야 Next.js 13의 새로운 앱 구조에서 제대로 작동해요. |\n| experimental worker strategy 제한 | `experimental`로 설정된 워커 전략은 아직 `app` 디렉토리에서 완전히 지원되지 않습니다. 따라서 이 전략을 사용 중이라면 삭제하거나, `lazyOnload` 같은 다른 전략으로 바꿔야 해요. |\n| 이벤트 핸들러(onLoad, onReady, onError) | Server Component에서는 이벤트 핸들러가 동작하지 않아요. 따라서 이런 핸들러들은 반드시 Client Component로 옮기거나 아니면 삭제해야 합니다. |\n\n추가 팁으로, 만약 여러분의 프로젝트가 아직 완전히 앱 디렉토리 구조로 전환되지 않았다면, 이 변경 사항들을 적용하기 전에 꼭 백업을 해놓고 점진적으로 바꾸는 것을 추천해요. \n\n그리고 이 `Script` 컴포넌트는 외부 스크립트를 다룰 때 굉장히 유용한데, 적절하게 전략을 변경하면 페이지 렌더링 성능도 훨씬 좋아질 수 있어요. Next.js 13을 더 잘 활용하는 데 있어서 중요한 부분이니 꼭 체크해보세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 폰트 최적화(Font Optimization)\n\n예전에는 Next.js가 폰트 CSS를 인라인(inline) 방식으로 넣어주는 방식으로 폰트를 최적화해줬어요. 그런데 Next.js 13부터는 완전히 새롭게 설계된 **next/font** 모듈이 등장했습니다. 이 모듈을 사용하면 폰트 로딩 방식을 더 세밀하게 조절할 수 있으면서도, 여전히 빠른 성능과 개인정보 보호까지 챙길 수 있답니다.\n\n특히 next/font는 기존의 pages 디렉토리 뿐만 아니라 새로운 app 디렉토리 환경에서도 모두 지원된다는 점이 큰 장점이에요.\n\n예전처럼 CSS를 인라인으로 넣는 방식은 pages에서는 여전히 작동하지만, app에서는 작동하지 않으니 앞으로는 꼭 next/font 모듈을 써야 해요.\n\n더 자세한 사용법은 Next.js 공식 문서의 [Font Optimization](https://nextjs.org/docs/basic-features/font-optimization) 페이지를 참고하면 되고, 직접 써보면 적용도 쉽고 효과도 확실히 느껴질 거예요!\n\n---\n\n> **추가 팁!**  \n> next/font는 구글 폰트뿐 아니라 로컬 폰트도 쉽게 불러올 수 있어서, 사용자 맞춤 폰트를 쓸 때도 아주 유용해요. 그리고 폰트를 가져올 때 불필요한 파일을 제외하고 필요한 글자나 변형만 포함시켜서, 번들 크기가 훨씬 줄어드는 효과까지 있답니다. 실 서비스에 적용하면 조금 더 쾌적한 웹 경험을 제공할 수 있어요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## pages에서 app으로 마이그레이션하기\n\n> 🎥 영상 보기: App Router 점진적 도입 방법 배우기 → YouTube (16분)\n\nApp Router로 이동하는 건 Next.js가 기반으로 삼고 있는 React 기능들, 예를 들어 서버 컴포넌트(Server Components), 서스펜스(Suspense) 등을 처음 사용해보는 경험일 수 있어요. 여기에 Next.js의 새로운 기능들, 예를 들어 특수 파일(special files)과 레이아웃(layouts) 등이 더해지면서 마이그레이션은 새로운 개념, 사고방식, 그리고 동작 방식까지 익혀야 하는 일이 됩니다.\n\n그래서 저희는 이 모든 변화를 한꺼번에 적용하기보다는, 마이그레이션 과정을 작게 쪼개서 단계별로 진행할 것을 추천해요. app 디렉토리는 pages 디렉토리와 동시에 작동하도록 의도적으로 설계되어 있어서, 페이지 단위로 점진적 마이그레이션이 가능하답니다.\n\n---\n\n### 조금 더 풀어 보면\n\n- **서버 컴포넌트(Server Components)**: 서버 쪽에서 렌더링되기 때문에 성능 향상과 번들 크기 감축에 도움이 돼요.\n- **서스펜스(Suspense)**: 데이터가 준비될 때까지 UI를 잠시 멈춰놓고 로딩 상태를 보여주는 React 기능입니다.\n- **레이아웃(Layouts)**: 앱 전반에 걸친 공통 UI를 쉽게 관리할 수 있게 해줍니다.\n\n마이그레이션 중에도 기존 pages 구조를 완전히 버리지 않고, 신규 app 구조와 병행해가며 일부분씩 바꿔나갈 수 있어서 부담이 적죠. \n\n즉, 한번에 다 바꾸려 하지 말고, '한 페이지씩, 한 기능씩' 천천히 옮겨가면서 적응하는 게 가장 좋은 방법이에요. 나중에 완전히 app 디렉토리 기반으로 옮겼을 때도 안정적이고 원활한 전환이 될 테니까요. \n\n이렇게 점진적으로 배우면서 바꾸는 과정, 생각보다 덜 어렵고 훨씬 효율적일 거예요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js의 최신 버전(13.4 이상)부터는 앱 디렉토리(app directory)를 활용한 새로운 방식으로 라우팅과 레이아웃 구성이 가능해졌어요. 이번 포스트에서는 앱 디렉토리를 이용한 Nested Routes(중첩 라우트)와 Layouts(레이아웃) 사용법을 한번 쉽게 정리해볼게요!\n\n---\n\n### 1. 앱 디렉토리는 Nested Routes와 Layouts를 지원해요.\n\n- 폴더 안에 또 폴더를 만들어 중첩 라우트를 정의할 수 있어요.\n- 각 폴더 내에 특별한 파일 `page.js`를 두면 그 경로가 실제 라우트 URL이 돼요.\n- 예를 들어 `app/blog/page.js`는 `/blog` 경로, `app/blog/post/page.js`는 `/blog/post` 경로가 되는 식입니다.\n\n### 2. 특수 파일 규칙\n\n| 파일명         | 역할                                  | 비고                          |\n| ------------- | ----------------------------------- | ----------------------------- |\n| `page.js`     | 해당 경로 고유의 UI를 정의             | 라우트마다 고유 UI 구성 가능   |\n| `layout.js`   | 여러 라우트에서 공유하는 UI를 정의      | 중첩 레이아웃 구성 가능       |\n\n`page.js`와 `layout.js`는 `.js`, `.jsx`, `.tsx` 확장자를 사용할 수 있어요. 즉, TypeScript도 문제없답니다!\n\n### 3. 공통 레이아웃과 개별 페이지 UI 구분!\n\n- `layout.js`는 자식 경로 여러 개에 공통적으로 적용되는 레이아웃을 담당해요.\n- `page.js`는 그 경로 하나만의 UI를 책임져요.\n\n이런 구조 덕분에, 공통 헤더, 사이드바 등은 `layout.js`에 넣고, 경로별 고유한 내용은 `page.js`로 깔끔하게 분리할 수 있어요.\n\n### 4. 앱 폴더 안에 컴포넌트, 스타일, 테스트 파일도 한 곳에!\n\n- `app` 폴더 내에 컴포넌트, 스타일 파일, 테스트, 심지어 헬퍼 함수도 같이 두고 관리할 수 있어요.\n- 덕분에 프로젝트 구조가 훨씬 직관적이고 깔끔해진답니다.\n\n### 5. 데이터 패칭 방식 변화\n\n- 기존 `getServerSideProps`, `getStaticProps`는 `app` 디렉토리에서는 새로운 API로 대체되었어요.\n- `getStaticPaths`도 이제 `generateStaticParams`로 교체되었죠.\n- 서버 사이드 렌더링 및 정적 생성 로직을 훨씬 모던한 방식으로 작성할 수 있어요.\n\n### 6. 페이지 기반 특수 파일들 대체\n\n| 기존 파일                       | 대체 파일                          |\n| ----------------------------- | -------------------------------- |\n| `pages/_app.js`, `pages/_document.js` | `app/layout.js` (루트 레이아웃)     |\n| `pages/_error.js`              | 경로별 `error.js` (더 세밀한 에러처리)|\n| `pages/404.js`                 | `not-found.js`                   |\n| `pages/api/*` (API Routes)     | `route.js` (Route Handler)       |\n\n---\n\n### [Step 1] app 디렉토리 만들고 Next.js 버전 최신화하기\n\n앱 디렉토리를 써보려면 Next.js 13.4 이상이 필요하니 최신 버전으로 업데이트하는 것부터 시작해 볼게요!\n\n```bash\nnpm install next@latest\n```\n\n---\n\n### 추가 꿀팁!\n\n- 중첩 라우트 구조때문에 URL 구조가 더 명확해져서 SEO에도 긍정적이에요.\n- 레이아웃을 여러 겹으로 쌓을 수 있어서 복잡한 UI도 깔끔하게 설계 가능!\n- 이제 `_app.js`나 `_document.js` 없이 루트 레이아웃 하나로 전역 설정 관리할 수 있으니 유지보수가 훨씬 편해졌어요.\n\n---\n\n한번 직접 `app` 폴더를 만들어서 중첩 라우트와 레이아웃을 적용해보는 걸 추천해요. 부담없이 프로젝트에 도입해보면 Next.js의 새로운 매력을 확실히 체감할 수 있을 거예요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프로젝트 루트(또는 src/ 디렉토리)에 새로 app 디렉토리를 만들어주세요.\n\n### 2단계: 루트 레이아웃 만들기\n\n이번에는 app 디렉토리 안에 app/layout.tsx 파일을 생성할 거예요. 이 파일은 app 안에 있는 모든 라우트에 적용되는 루트 레이아웃 역할을 합니다.\n\n```tsx\nexport default function RootLayout({\n  // 레이아웃은 children prop을 반드시 받아야 해요.\n  // 이 children에는 중첩된 레이아웃이나 페이지들이 들어가게 됩니다.\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <body>{children}</body>\n    </html>\n  )\n}\n```\n\n여기서 살짝 중요한 팁을 드리자면, 이 RootLayout은 Next.js의 `app` 디렉토리 구조에서 가장 기본 뼈대가 되기 때문에, 페이지마다 공통적으로 들어가는 요소들(예: `<head>`, 네비게이션 바, 푸터 등)을 이 안에 넣으면 유지보수가 훨씬 편해져요.\n\n그리고 `<html lang=\"en\">` 부분은 사이트의 기본 언어를 설정하는 거라, 한국어 사이트라면 `lang=\"ko\"`로 바꾸는 게 좋아요!\n\n조금 더 완성도를 높이고 싶다면 `<head>` 태그도 커스터마이징해서 메타데이터나 폰트 링크, 파비콘 등을 넣어주는 것도 추천드려요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js의 새로운 app 디렉토리 구조를 사용할 때 알아두면 좋은 몇 가지 핵심 포인트를 정리해봤어요!\n\n---\n\n### 1. app 디렉토리에 **루트 레이아웃(root layout)** 필수!\n\n- `app` 폴더 안에는 반드시 루트 레이아웃 파일이 있어야 해요.\n- 이 루트 레이아웃은 `html`, `body` 태그를 직접 정의해야 해요. Next.js가 자동으로 만들어주지 않거든요.\n- 기존에는 `pages/_app.tsx`와 `pages/_document.tsx`를 사용해서 전체 앱의 구조나 문서 태그를 조절했지만, 이제는 루트 레이아웃이 그 역할을 대신해요.\n- 레이아웃 파일 확장자는 `.js`, `.jsx`, `.tsx` 중 자유롭게 선택할 수 있어요.\n\n---\n\n### 2. SEO 관련 `head` 태그 관리도 간편해요!\n\n- `head` 태그 안에 들어가는 메타정보(예: `title`, `description`)를 관리할 땐 Next.js가 제공하는 내장 SEO 지원을 활용하면 좋아요.\n- 아래처럼 `metadata` 객체를 내보내기(export) 하면 페이지별로 메타정보가 자동으로 적용돼요.\n\n```ts\nimport type { Metadata } from 'next'\n\nexport const metadata: Metadata = {\n  title: 'Home',\n  description: 'Welcome to Next.js',\n}\n```\n\n---\n\n### 3. 기존 `_app.js`와 `_document.js` 마이그레이션\n\n- app 디렉토리를 사용할 때는 이 두 파일이 필요 없어요. 이 둘이 제공하던 기능 대부분이 루트 레이아웃으로 통합되었기 때문입니다.\n- 만약 이전에 작성해둔 커스텀 `_document.js`나 `_app.js`가 있다면, 꼭 app 라우팅 구조에 맞춰 루트 레이아웃으로 다시 작성해주는 게 좋아요.\n\n---\n\n### 개인적인 팁 한마디!\n\n- 루트 레이아웃 내에서 글로벌 CSS나 공통 UI 컴포넌트를 한번만 감싸주면 되니까, 코드가 훨씬 깔끔해지고 유지보수도 쉬워졌어요.\n- 또, `metadata` 덕분에 SEO 설정이 페이지마다 편하게 분리되어서 관리가 편해졌답니다.\n- 다만, `html`과 `body`를 직접 선언해야 하니 꼭 잊지 말고 작성해주세요!\n\n---\n\n다음 포스트에서는 app 디렉토리 구조를 활용하는 구체적인 예제와 함께 useRouter 훅 대신 사용할 새로운 라우팅 방법도 소개할게요. 기대해주세요! 😊\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 기존에 _app이나 _document 파일이 있다면, 그 안에 있던 내용들(예: 전역 스타일들)을 새로 만든 루트 레이아웃(app/layout.tsx)으로 옮길 수 있어요. 그런데 중요한 점은, app/layout.tsx에 있는 스타일은 pages/* 경로에 적용되지 않는다는 거예요. 그래서 마이그레이션하는 동안에는 기존 _app과 _document 파일을 유지하는 게 좋습니다. 그래야 pages/* 경로들이 갑자기 깨지지 않거든요. 모든 마이그레이션이 완전히 끝난 후에야 이 두 파일을 안전하게 지울 수 있답니다.\n\n또 하나, 만약 React Context 프로바이더를 사용 중이라면, 이걸 Client Component로 옮겨야 해요. Next.js의 새로운 앱 디렉토리 구조에서는 서버 컴포넌트와 클라이언트 컴포넌트를 명확하게 구분해서 관리하거든요.\n\n#### getLayout() 패턴에서 Layouts로 마이그레이션하기 (선택 사항)\n\n기존 pages 디렉토리에서는 페이지별로 레이아웃을 적용하기 위해 Page 컴포넌트에 getLayout()이라는 프로퍼티를 붙이는 방식을 많이 썼어요. 하지만 app 디렉토리에서는 **중첩 레이아웃(nested layouts)**을 네이티브로 지원하기 때문에 이 패턴이 불필요해요. 즉, 페이지별로 다른 레이아웃을 적용하고 싶으면, 레이아웃 파일들을 계층적으로 분리해서 구조화하면 된답니다. 훨씬 깔끔하고 유지보수도 쉬워지죠.\n\n---\n\n이제 이런 방식으로 코드를 새롭게 정리하다 보면, 각 페이지에서 레이아웃을 직접 관리할 필요 없이 폴더 구조만으로도 레이아웃이 매끄럽게 연결되는 걸 경험할 수 있을 거예요. Next.js 13부터 도입된 app 디렉토리 방식이 가져다주는 가장 큰 장점 중 하나입니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 3단계: next/head 마이그레이션하기\n\nNext.js의 `pages` 디렉토리에서는 `next/head` 컴포넌트를 이용해서 HTML 문서의 `<head>` 부분, 예를 들어 `title`이나 `meta` 태그를 관리하죠. 그런데 `app` 디렉토리로 넘어오면 `next/head` 대신 새로운 내장 SEO 지원 기능을 사용해야 해요.\n\n기존에는 이렇게 썼었죠:\n\n```js\nimport Head from 'next/head'\n \nexport default function Page() {\n  return (\n    <>\n      <Head>\n        <title>My page title</title>\n      </Head>\n    </>\n  )\n}\n```\n\n---\n\n새로운 `app` 디렉토리에서는 `head` 관리가 훨씬 간편해졌어요. 이제는 페이지 컴포넌트 내에서 별도로 `<Head>` 컴포넌트를 쓸 필요 없이, `metadata`라는 방식을 사용해 `title` 같은 SEO 관련 정보를 설정할 수 있어요.\n\n아래는 간단한 예시입니다:\n\n```js\nexport const metadata = {\n  title: 'My page title',\n  description: '페이지 설명을 여기에 작성하세요',\n}\n\nexport default function Page() {\n  return (\n    <div>\n      {/* 페이지 콘텐츠 */}\n    </div>\n  )\n}\n```\n\n이렇게 `metadata`를 export 하면 Next.js가 알아서 `<head>`에 적절한 태그들을 넣어줘요. 덕분에 코드도 훨씬 깔끔해지고, SEO 관리도 편해집니다.\n\n> 참고로 `metadata`에서 지원하는 옵션은 `title`, `description`, `openGraph`, `twitter` 등 굉장히 다양하니 필요에 맞게 활용해보세요.\n\n---\n\n요약하자면,\n\n| 이전 방식 (`pages` 폴더)        | 새로운 방식 (`app` 폴더)                   |\n|---------------------------|------------------------------------|\n| `import Head from 'next/head'` 사용 | `metadata` 객체 export로 설정             |\n| JSX 안에 `<Head>...</Head>` 작성    | 컴포넌트 밖에 `export const metadata = {...}` 작성 |\n\n이제부터는 `head` 요소를 직접 다루기보단, `metadata`를 통해 쉽고 깔끔하게 SEO를 관리하는 방법에 적응해 보세요! 이는 Next.js가 미래 지향적으로 제공하는 공식적인 추천 방식이기도 합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n자, 위 코드는 Next.js에서 메타데이터를 설정하는 아주 기본적인 예시예요.\n\n```js\nimport type { Metadata } from 'next'\n\nexport const metadata: Metadata = {\n  title: 'My Page Title',\n}\n\nexport default function Page() {\n  return '...'\n}\n```\n\n여기서 `metadata` 객체를 통해 페이지의 타이틀을 설정하고 있어요. 이 방식은 Next.js 13 이상에서 메타데이터를 좀 더 체계적으로 관리할 수 있게 해주는 방법 중 하나랍니다.\n\n---\n\n### 메타데이터 옵션 리스트\n\nNext.js에서 지원하는 메타데이터 옵션은 상당히 다양해요. 예를 들면:\n\n| 옵션 이름          | 설명                       |\n|-----------------|--------------------------|\n| title           | 페이지의 제목 설정               |\n| description     | 페이지 설명(SEO에 중요)         |\n| keywords        | 검색 최적화를 위한 키워드 배열      |\n| openGraph       | 오픈그래프 태그 설정 (SNS 공유 시) |\n| twitter         | 트위터 카드 정보 설정           |\n| robots          | 크롤러를 위한 접근 제어 설정       |\n| manifest       | PWA용 웹앱 매니페스트 연결         |\n\n이 외에도 다양한 옵션들이 있으니 공식 문서를 참고하면 좋아요.\n\n---\n\n### Step 4: 페이지 마이그레이션하기\n\nNext.js 프로젝트를 새 버전으로 옮기면서 기존 페이지들을 어떻게 마이그레이션해야 하는지 고민되시죠? 가장 중요한 건 메타데이터를 더 이상 `head` 태그나 `next/head` 컴포넌트로 관리하지 않고, 위처럼 `metadata` 객체로 관리하는 방식으로 바꾸는 거예요.\n\n또한, 서버 컴포넌트(Server Component)를 적극 활용해서 페이지 성능과 유지보수성을 높일 수 있어요. 예를 들어, 데이터 페칭도 페이지 바로 위에서 처리하고 UI는 순수하게 렌더링만 하도록 분리할 수 있답니다.\n\n마이그레이션할 때는 아래 포인트를 기억하면 좋아요:\n- **메타데이터:** 기존 `Head` 대신 `metadata` 객체 활용\n- **서버 컴포넌트:** 서버에서 데이터 처리하고 UI는 클라이언트 컴포넌트와 분리 가능\n- **라우팅:** app 폴더 기반 라우팅을 잘 이해하고 기존 pages 폴더 구조와 맞게 조정\n- **스타일링:** 글로벌 스타일, CSS 모듈, Tailwind 등 스타일링 방법은 동일하지만 적용 위치에 따라 차이가 있을 수 있음\n\n마이그레이션 전후로 빌드 및 렌더링 결과를 꼭 확인하며 진행하는 게 좋아요!\n\n필요하면 마이그레이션 사례도 따로 정리해볼 테니 궁금한 점 있으면 언제든지 질문해 주세요. 😊\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안녕하세요 여러분! 오늘은 Next.js의 새로운 `app` 디렉토리에 대해 이야기해볼게요. 기존 `pages` 디렉토리와 비교하면서 어떤 점이 달라졌는지, 그리고 마이그레이션하는 가장 쉬운 방법도 함께 소개해드릴게요.\n\n---\n\n### 1. 기본 컴포넌트 유형의 변화\n\n- `app` 디렉토리 내의 페이지들은 **기본적으로 Server Components**로 작동해요.\n- 반면, 기존 `pages` 디렉토리의 페이지들은 **Client Components**가 기본이었죠.\n\n쉽게 말해, `app` 디렉토리는 서버에서 렌더링하는 컴포넌트를 기본으로 하되 필요하면 클라이언트 컴포넌트를 따로 만들어서 사용한다는 점에서 차이가 있어요.\n\n---\n\n### 2. 데이터 패칭 방식 변화\n\n기존 `pages` 디렉토리에서는 `getServerSideProps`, `getStaticProps`, `getInitialProps` 같은 함수들을 사용했는데요, `app` 디렉토리는 이 복잡한 API들을 **더 간단한 API로 교체**했답니다. 데이터를 가져오는 방법이 훨씬 깔끔해졌죠.\n\n---\n\n### 3. 라우팅 방식과 파일 구조\n\n`app` 디렉토리는 중첩 폴더 구조를 이용해 라우트를 정의하고, 각 폴더 안에 `page.js` 파일을 만들어서 해당 경로를 외부에서 접근할 수 있게 해요.\n\n예를 들어, 기존 `pages`와 `app` 디렉토리 라우팅 비교는 다음과 같아요:\n\n| pages 디렉토리       | app 디렉토리             | 라우트 경로       |\n|---------------------|-------------------------|------------------|\n| index.js            | page.js                 | /                |\n| about.js            | about/page.js           | /about           |\n| blog/[slug].js      | blog/[slug]/page.js     | /blog/post-1     |\n\n---\n\n### 4. 마이그레이션 가이드: 가장 쉬운 방법\n\n`pages`에서 `app`으로 옮길 때, 저희가 추천하는 방법은 크게 두 단계예요.\n\n1. **Step 1**: 기존에 기본 내보내기(default export)했던 페이지 컴포넌트를 **새로운 클라이언트 컴포넌트로 옮기기**  \n   - 이 때 `use client` 지시어를 추가하는 걸 잊지 마세요! 클라이언트 전용 컴포넌트임을 명시하는 거죠.\n\n2. **Step 2**: `app` 디렉토리 내에 새로운 `page.js` 파일을 만들고, 거기에 이 클라이언트 컴포넌트를 임포트해서 사용하기\n\n---\n\n### 덧붙여서: 왜 이렇게 하는 게 좋을까?\n\n이 방식이 가장 **`pages` 디렉토리와 비슷한 동작을 보장하기 때문에** 마이그레이션이 가장 쉽고 안정적이에요. 급진적으로 구조를 바꾸지 않고도 기존의 방식을 최대한 유지하면서 새로운 `app` 디렉토리의 장점도 누릴 수 있거든요.\n\n---\n\n이상으로 Next.js의 `app` 디렉토리 기본 사항과 마이그레이션 방법에 대해 간단히 정리해봤어요. 새로워진 Next.js를 활용해서 더 깔끔하고 효율적인 프로젝트를 만들어보세요!\n\n궁금한 점 있으면 댓글로 알려주세요~\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n자, 이제 Next.js 앱에서 'Client Component'를 만들어보는 방법에 대해 설명해볼게요. 너무 딱딱하지 않게 쉽게 풀어서 이야기할게요!\n\n---\n\n## Step 1: 새로운 Client Component 만들기\n\n먼저, `app` 디렉터리 안에 새로운 파일을 만들어줘요. 예를 들면 `app/home-page.tsx` 같은 파일이죠. 이 파일에서 Client Component를 정의하려면, 파일 맨 위에 `'use client'`라는 지시어를 꼭 추가해야 해요. 이건 컴포넌트를 클라이언트 쪽에서 실행하겠다는 뜻이에요.\n\n매우 중요한 점! `pages` 디렉토리에서 작업할 때처럼, Next.js가 초기 페이지 로드 때 이 Client Component를 정적 HTML로 미리 렌더링(prerender)하는 최적화 과정이 있답니다.\n\n기존에 `pages/index.js`에 있던 기본 페이지 컴포넌트를 이제 `app/home-page.tsx`로 옮겨주세요.\n\n다음은 간단한 예시 코드에요:\n\n```js\n'use client'\n\n// 이 컴포넌트는 클라이언트 컴포넌트예요.\n// props로 데이터를 받고, state와 useEffect 같은 훅을 쓸 수 있죠.\n// 그리고 초기 페이지 로드 시 서버에서 미리 렌더링 돼요.\nexport default function HomePage({ recentPosts }) {\n  return (\n    <div>\n      {recentPosts.map((post) => (\n        <div key={post.id}>{post.title}</div>\n      ))}\n    </div>\n  )\n}\n```\n\n---\n\n같은 내용을 조금 더 쉽게 설명하자면: \n\n- `'use client'`를 붙이면 Next.js가 \"아, 이건 브라우저에서 실행될 컴포넌트구나\"라고 인식해요.\n- 클라이언트 컴포넌트 안에서는 **State 관리, 이벤트, useEffect** 같은 React 훅을 활용할 수 있어서 인터랙티브한 UI를 만들기 좋아요.\n- 하지만 Next.js 최적화 덕분에, 초기 화면은 서버에서 미리 렌더링해서 빠르게 띄워줍니다!\n\n---\n\n## Step 2: 새로운 페이지 만들기\n\n이 부분은 다음 메시지에 더 자세히 다룰게요!\n\n---\n\n필요하면 더 궁금한 점이나 코딩 팁도 많이 얘기해 줄게요. Next.js 앱 구조, Client/Server Components 개념이 처음이면 조금 헷갈릴 수 있는데, 천천히 익히면 아주 강력한 UI를 만들 수 있어요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n자, 이번에는 Next.js의 app 디렉토리에서 페이지와 라우팅을 설정하는 방법을 한번 알아볼게요. 기존 pages 디렉토리에서 하던 방식과 비교하면서 쉽게 이해할 수 있도록 설명해볼게요.\n\n---\n\n### 1. app/page.tsx 만들기 (Server Component)\n\n먼저, `app` 폴더 안에 `page.tsx` 파일을 하나 만들어주세요. 여기서 중요한 점은 **app 디렉토리 내 파일들은 기본적으로 서버 컴포넌트(Server Component)**라는 거예요. 서버 컴포넌트는 서버에서 데이터를 직접 받아오고 렌더링을 담당해서 클라이언트보다 효율적이고 느린 데이터 요청에도 영향이 적답니다.\n\n```tsx\n// app/page.tsx\n\n// client 컴포넌트인 홈 페이지를 import 해줘요\nimport HomePage from './home-page'\n\nasync function getPosts() {\n  const res = await fetch('https://...')\n  const posts = await res.json()\n  return posts\n}\n\nexport default async function Page() {\n  // 서버 컴포넌트 안에서 데이터를 바로 fetch해요\n  const recentPosts = await getPosts()\n  \n  // 받아온 데이터를 client 컴포넌트에 넘겨줍니다\n  return <HomePage recentPosts={recentPosts} />\n}\n```\n\n> TIP: `fetch` 작업을 서버 컴포넌트에서 하면 클라이언트가 데이터를 기다리는 상황이 줄어든다는 장점이 있어요.\n\n---\n\n### 2. pages/index.js의 데이터 fetching 로직 옮기기\n\n기존에 `pages/index.js`에서 데이터를 fetch 했던 로직, 그대로 `app/page.tsx`에 옮겨오면 됩니다. 그리고 페이지 컴포넌트가 async 함수로 정의되어 있어야 데이터를 await로 처리할 수 있어요.\n\n---\n\n### 3. 클라이언트 컴포넌트 가져오기\n\n위 코드에서 `HomePage`는 클라이언트 컴포넌트라면 `app/home-page.tsx` 같은 위치에 작성되어 있어야 해요. `useState`, `useEffect` 같은 클라이언트 전용 훅들을 사용하는 컴포넌트라면 `use client` 지시어를 최상단에 적어줘야 합니다.\n\n```tsx\n// app/home-page.tsx\n'use client'\n\nimport React from 'react'\n\nexport default function HomePage({ recentPosts }) {\n  return (\n    <div>\n      <h1>최근 게시물</h1>\n      <ul>\n        {recentPosts.map(post => (\n          <li key={post.id}>{post.title}</li>\n        ))}\n      </ul>\n    </div>\n  )\n}\n```\n\n---\n\n### 4. 새로운 라우팅 훅 사용하기\n\n예전 `pages` 폴더 대비 `app` 디렉토리에서는 routing도 조금 달라졌어요. `useRouter`를 비롯한 라우팅 관련 훅들이 `next/navigation`에서 새롭게 제공됩니다.\n\n```tsx\nimport { useRouter, usePathname, useSearchParams } from 'next/navigation'\n\nexport default function MyComponent() {\n  const router = useRouter()\n  const pathname = usePathname()\n  const searchParams = useSearchParams()\n\n  // 라우팅 변경, 현재 경로, 쿼리 파라미터 읽기 등에 사용 가능\n}\n```\n\n기존 `next/router` 대신 이 훅들을 꼭 사용해주세요!\n\n---\n\n### 5. 개발 서버 실행하고 확인하기\n\n이제 모두 마쳤으면 개발 서버를 실행해 봅시다.\n\n```bash\nnpm run dev\n```\n\n또는\n\n```bash\nyarn dev\n```\n\n그리고 브라우저에서 `http://localhost:3000`에 접속하면, 기존 index 페이지가 `app/page.tsx`를 통해 렌더링 되는 걸 볼 수 있을 거예요.\n\n---\n\n## 정리!\n\n| 단계 | 설명 |\n|---|---|\n| 1 | `app/page.tsx` 생성하여 Server Component로 페이지 작성하기 |\n| 2 | 기존 pages의 데이터 fetching 로직을 서버 컴포넌트 내에서 처리하도록 옮기기 |\n| 3 | 클라이언트 컴포넌트는 `use client` 지시어 붙이고, 데이터 props로 받기 |\n| 4 | `next/navigation`의 새로운 routing 훅(`useRouter`, `usePathname`, `useSearchParams`) 사용하기 |\n| 5 | 개발 서버 돌려서 잘 되는지 확인하기 |\n\n---\n\nNext.js의 `app` 디렉토리는 서버와 클라이언트 컴포넌트가 명확히 구분되고, React의 최신 기능들(Suspense, Server Components 등)을 활용할 수 있어서 성능도 좋아지고 개발도 편해졌어요. 처음 접하면 헷갈릴 수 있으니 차근차근 바꾸면서 적응해보세요!\n\n궁금한 점 있으면 언제든 질문해 주세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서 `useRouter` 훅에 큰 변화가 있었어요! 특히 `app` 디렉터리에서는 이전에 쓰던 `next/router`에서 가져오는 `useRouter`가 지원되지 않고, 대신 `next/navigation`에서 가져오는 새로운 훅을 써야 해요.\n\n---\n\n### 핵심 정리\n\n| 이전(useRouter from next/router) | 최신(useRouter from next/navigation) |\n|---|---|\n| `pages` 디렉터리에서만 사용 가능 | `app` 디렉터리에서 사용 가능 (pages에서는 기존 걸 계속 사용 가능) |\n| `pathname` 문자열 반환 | 반환하지 않음. 대신 `usePathname()` 사용 |\n| `query` 객체 반환 (검색 파라미터 + 동적 라우팅 파라미터 섞여 있음) | 반환하지 않음. 대신 `useSearchParams()`와 `useParams()`를 각각 사용 |\n| `isFallback`, `locale`, `basePath`, `asPath`, `isReady`, `route` 등 여러 프로퍼티 존재 | 여러 속성이 제거됨 (예: `isFallback` 사라짐, `locale` 관련 제거 등) |\n| 서버 및 클라이언트 컴포넌트에서 사용 가능 | 오로지 클라이언트 컴포넌트에서만 사용 가능 |\n\n---\n\n### 새로운 훅 사용법 예시\n\n```jsx\n'use client'\n\nimport { useRouter, usePathname, useSearchParams } from 'next/navigation'\n\nexport default function ExampleClientComponent() {\n  const router = useRouter()\n  const pathname = usePathname()\n  const searchParams = useSearchParams()\n\n  // 예시: 쿼리 파라미터 'id' 값 가져오기\n  const id = searchParams.get('id')\n\n  const goHome = () => {\n    router.push('/')\n  }\n\n  return (\n    <div>\n      <p>현재 경로: {pathname}</p>\n      <p>id 파라미터: {id}</p>\n      <button onClick={goHome}>홈으로 이동</button>\n    </div>\n  )\n}\n```\n\n---\n\n### 조금 더 알아볼 점\n\n- `useSearchParams`는 브라우저 URL의 쿼리스트링 부분을 다룰 때 쓰고,\n- `useParams`는 `[slug]` 같은 동적 세그먼트 파라미터 값을 가져올 때 사용해요.\n- `usePathname`은 현재 경로를 문자열로 알려줍니다.\n\n이 훅들만 조합하면 이전 `useRouter`가 했던 거의 모든 일을 하실 수 있답니다.\n\n---\n\n### 몇 가지 팁\n\n1. **클라이언트 컴포넌트에서만 사용 가능!**  \n   서버 컴포넌트에서는 작동하지 않으니, 위 예시에선 `'use client'` 지시어가 필요한 이유예요.\n\n2. **라우팅 이벤트 감지는?**  \n   `usePathname`과 `useSearchParams`를 조합해서 경로 변경을 감지하세요. 예전처럼 `router.events`는 지원되지 않아요.\n\n3. **국제화(i18n) 지원 변화**  \n   `locale`, `locales` 등 국제화 관련 속성이 사라진 점 참고하세요. `app` 디렉토리에서는 다르게 i18n을 다뤄야 합니다.\n\n4. **`isReady` 사라짐**  \n   예전엔 라우터가 초기화될 때까지 기다리는 상태였는데, 이제는 클라이언트 렌더링 단계에서 알아서 처리합니다.\n\n---\n\n새로운 `useRouter`가 구조가 더 깔끔해졌지만, 그만큼 `usePathname`, `useSearchParams`, `useParams` 같은 훅들을 같이 잘 활용해야 하는 점 기억하세요! Next.js 앱 디렉터리 기반 라우팅을 공부 중이라면 이 변화는 꼭 알아두시고 작업하세요~\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nuseRouter() API 참고하기\n\n#### 페이지와 앱 사이에서 컴포넌트 공유하기\n\nNext.js에서 페이지 라우터와 앱 라우터를 동시에 지원하는 컴포넌트를 만들려면, `next/compat/router`에서 제공하는 `useRouter` 훅을 사용하는 게 좋아요. 이 훅은 페이지 디렉토리에서 쓰이는 `useRouter`와 같지만, 두 라우터 환경 사이에서 컴포넌트를 공유할 때 호환성을 유지하도록 설계되어 있답니다.\n\n그리고 언젠가 앱 라우터만 사용하게 될 시점이 오면, 그때는 `next/navigation`에서 제공하는 최신 `useRouter`로 바꾸는 걸 권장해요. 이렇게 하면 더 깔끔하고 최신 패턴에 맞는 코드가 되니까요!\n\n---\n\n### 6단계: 데이터 가져오기 방법 마이그레이션하기\n\n다음 단계에서는 데이터 패칭 관련 메서드를 어떻게 마이그레이션하는지 살펴볼 거예요. Next.js 13부터는 새롭게 도입된 앱 라우터 환경에 맞춰 데이터 가져오는 방법도 많이 바뀌었으니, 꼭 참고해서 업데이트해보시길 바랍니다.\n\n---\n\n**덧붙여서!**  \n만약 여러분이 컴포넌트를 여러 라우터 환경에서 쓸 일이 많다면, `next/compat/router` 쪽 `useRouter` 훅을 사용하는 게 당분간은 가장 안정적인 방법이에요. 나중에 앱 라우터만 쓰게 되면, `next/navigation`에서 `useRouter`가 훨씬 더 가볍고 빠른 API를 제공하니 그때 갈아타는 걸 추천드립니다!\n\n추가로, `useRouter`를 통해 라우팅 정보를 얻는 법뿐 아니라, 프로그램적으로 라우팅을 제어하는 방법도 익히면 개발 효율이 훨씬 올라가요. 필요하면 언제든 더 자세히 공유할게요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서 데이터 패칭 방식을 다루는 걸 보면, 전통적으로 pages 디렉토리에서는 getServerSideProps와 getStaticProps를 많이 사용해왔어요. 그런데 app 디렉토리에서는 이 패턴이 조금 바뀌어서, fetch()와 React Server Components를 기반으로 더 간단하게 데이터를 가져올 수 있도록 바뀌었답니다.\n\n---\n\n## app 디렉토리의 데이터 패칭 방식\n\n```js\nexport default async function Page() {\n  // 이 요청은 수동으로 무효화될 때까지 캐시됩니다.\n  // getStaticProps와 비슷한 역할.\n  // 'force-cache'가 기본값이라 생략 가능해요.\n  const staticData = await fetch(`https://...`, { cache: 'force-cache' })\n \n  // 이 요청은 매 요청마다 다시 불러옵니다.\n  // getServerSideProps와 비슷하죠.\n  const dynamicData = await fetch(`https://...`, { cache: 'no-store' })\n \n  // 이 요청은 10초 동안만 캐시되고 재검증됩니다.\n  // getStaticProps의 revalidate 옵션과 유사해요.\n  const revalidatedData = await fetch(`https://...`, {\n    next: { revalidate: 10 },\n  })\n \n  return <div>...</div>\n}\n```\n\n여기서 중요한 점은, 이제 더 이상 별도의 데이터 패칭 함수들을 페이지 밖에서 선언할 필요 없이 컴포넌트 내부에서 일반적인 async 함수처럼 fetch를 호출할 수 있다는 점이에요. 그리고 fetch 옵션을 통해 원하는 캐싱 전략을 직접 지정할 수 있죠.\n\n---\n\n## pages 디렉토리의 getServerSideProps\n\npages 디렉토리에서는 getServerSideProps가 서버에서 데이터를 가져와서 props로 넘겨주고, 그 데이터를 기반으로 초기 HTML을 렌더링해요. 이렇게 서버에서 미리 렌더링된 페이지가 클라이언트에서 \"hydrating\" 되어 인터랙티브해집니다.\n\n간단히 말해서:\n\n- **getServerSideProps:** 서버에서 매 요청마다 실행\n- **getStaticProps:** 빌드 시점에 한번 실행, 필요시 revalidate 옵션으로 주기적 재생성\n\n---\n\n## 한마디 정리!\n\n- app 디렉토리에서는 React Server Components와 fetch의 cache 옵션을 이용해 데이터 패칭을 직접 관리.\n- pages 디렉토리에서는 기존처럼 getServerSideProps, getStaticProps를 통해 데이터를 패칭.\n- 앞으로 Next.js를 사용하면서 app 디렉토리를 많이 쓰게 되면 더 선언적이고 코드가 직관적인 fetch 기반 방식을 자주 보게 될 거예요.\n\n---\n\n### 추가 팁\n\n- `cache: 'force-cache'`는 기본값이니, 특별히 동적 데이터를 자주 변경시키지 않는다면 생략해도 무방해요.\n- 반대로 `cache: 'no-store'`를 사용하면 실제로 서버에서만 데이터를 요청하고 클라이언트나 중간 캐시는 전혀 사용하지 않으니 주의하세요.\n- `next: { revalidate: 10 }`를 활용하면 10초마다 캐시를 재검증해서 최신 데이터를 일정 주기로 반영할 수 있어요.\n\n이제 Next.js 데이터 패칭 방식이 훨씬 유연하고 직관적으로 변해서 개발할 때 훨씬 편해질 거예요! 궁금한 점 있으면 언제든 물어봐 주세요~\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js의 pages 디렉토리 방식과 App Router (app 디렉토리) 방식에서 서버 사이드 데이터 패칭을 어떻게 하는지 비교해볼게요.\n\n---\n\n### pages 디렉토리 방식 (기존 방식)\n\n```js\nexport async function getServerSideProps() {\n  const res = await fetch(`https://...`)\n  const projects = await res.json()\n\n  return { props: { projects } }\n}\n\nexport default function Dashboard({ projects }) {\n  return (\n    <ul>\n      {projects.map((project) => (\n        <li key={project.id}>{project.name}</li>\n      ))}\n    </ul>\n  )\n}\n```\n\n- `getServerSideProps`는 페이지 요청 시마다 서버에서 데이터 패칭 후 HTML을 렌더링해서 클라이언트에 보냅니다.\n- 장점: 최신 데이터를 항상 보여줌\n- 단점: 페이지 요청마다 데이터 패칭, 클라이언트로 전송되는 자바스크립트 번들에는 데이터 패칭 코드가 없음\n\n---\n\n### App Router 방식 (app 디렉토리)\n\n```js\n// 이 함수 이름은 자유롭게 지어도 됩니다\nasync function getProjects() {\n  const res = await fetch(`https://...`, { cache: 'no-store' })\n  const projects = await res.json()\n\n  return projects\n}\n\nexport default async function Dashboard() {\n  const projects = await getProjects()\n\n  return (\n    <ul>\n      {projects.map((project) => (\n        <li key={project.id}>{project.name}</li>\n      ))}\n    </ul>\n  )\n}\n```\n\n- React 서버 컴포넌트(Server Components) 내에서 바로 비동기 함수로 데이터를 패칭할 수 있어요.\n- `{ cache: 'no-store' }` 옵션을 주면 `getServerSideProps`처럼 매 요청마다 항상 최신 데이터를 받아옵니다.\n- 클라이언트에 불필요한 자바스크립트가 덜 전달되므로 초기 로딩이 더 빠릅니다.\n- 서버에서 렌더링된 HTML이 바로 클라이언트에 전달되어 SEO에도 좋습니다.\n\n---\n\n### 추가 팁!\n\n- `cache` 옵션에는 `'force-cache'`(기본값, ISR 적용 가능)나 `'no-store'` 외에도 다양한 값이 있어요. 상황에 따라 적절히 선택해 주세요.\n- 서버 컴포넌트 명령문 안에서는 클라이언트 전용 훅 같은 것들을 사용할 수 없으니 주의!\n- 점점 Next.js가 React Server Components 방식을 중심으로 발전하고 있으니 새 프로젝트에서는 app 디렉토리 방식을 고려해보세요.\n\n---\n\nNext.js에서도 이렇게 진화한 서버사이드 데이터 패칭 방식을 활용하면 성능과 개발 경험 모두 잡을 수 있답니다! 궁금한 점 있으면 언제든 물어보세요~\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n#### Request 객체 접근하기\n\nNext.js의 `pages` 디렉토리에서는 Node.js의 HTTP API를 바탕으로 요청(request) 관련 데이터를 쉽게 가져올 수 있어요.\n\n예를 들어, `getServerSideProps` 함수에서 `req` 객체를 받아서 요청의 쿠키나 헤더 정보를 조회할 수 있답니다. 이렇게 하면 서버 사이드에서 특정 쿠키 값이나 인증 헤더 등을 읽어서 조건에 따라 페이지 렌더링을 다르게 처리할 수 있죠.\n\n아래 예시를 보시죠:\n\n```js\n// pages 디렉토리 내에서\n\nexport async function getServerSideProps({ req, query }) {\n  const authHeader = req.getHeaders()['authorization']; // 요청 헤더에서 'authorization' 정보 가져오기\n  const theme = req.cookies['theme']; // 요청 쿠키에서 'theme' 값 가져오기\n\n  return { props: { authHeader, theme } } // props로 페이지 컴포넌트에 전달\n}\n\nexport default function Page(props) {\n  return (\n    <div>\n      <p>Authorization Header: {props.authHeader}</p>\n      <p>Theme from Cookie: {props.theme}</p>\n    </div>\n  )\n}\n```\n\n### 여기서 한 가지 팁!\n- `req.cookies`를 쓰려면 쿠키 파서를 따로 설치하거나 설정해야 할 수도 있어요. 보통 Next.js에서는 내장된 API가 자동으로 쿠키를 파싱해주긴 하지만, 커스텀 미들웨어를 사용할 때 주의해야 합니다.\n- 헤더 이름은 대소문자를 구분하지 않지만, 보통 `authorization`처럼 소문자로 접근하는 게 편해요.\n\n이처럼 서버 사이드에서 요청 관련 데이터를 활용하면 인증, 테마 설정, 사용자 맞춤 데이터 처리 등 다양한 기능을 구현할 수 있어서 강력하답니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이번에는 Next.js의 app 디렉토리에서 제공하는 새로운 읽기 전용 함수인 headers와 cookies에 대해 알려드릴게요. 이 둘은 서버 컴포넌트(Server Components) 내에서 요청(request) 데이터를 쉽게 가져올 수 있게 도와줘요.\n\n---\n\n### headers 와 cookies 함수란?\n\n- **headers**: Web Headers API를 기반으로 만들어졌으며, 서버 컴포넌트 안에서 요청 헤더 정보를 가져올 때 사용해요.\n- **cookies**: Web Cookies API를 기반으로 하며, 서버 컴포넌트에서 쿠키 정보를 가져올 수 있어요.\n\n즉, 클라이언트가 보낸 요청 헤더와 쿠키 값을 서버 컴포넌트 내에서 간편하게 읽을 수 있도록 Next.js에서 제공하는 기능이죠.\n\n---\n\n### 간단한 코드 예시\n\n```jsx\n// app 디렉토리 예시\nimport { cookies, headers } from 'next/headers'\n\nasync function getData() {\n  const authHeader = (await headers()).get('authorization')\n  \n  return '...'\n}\n\nexport default async function Page() {\n  // 직접 Server Components 내부나 데이터 요청 함수에서 cookies, headers 사용 가능\n  const theme = (await cookies()).get('theme')\n  const data = await getData()\n  return '...'\n}\n```\n\n위 예시처럼 `headers()`와 `cookies()` 함수는 async 함수로, 호출하면 각각 헤더와 쿠키 객체를 반환해요. 그리고 그 객체에서 `.get('키 이름')`으로 내가 원하는 값을 꺼낼 수 있죠.\n\n---\n\n### 좀 더 알면 좋은 점\n\n- **읽기 전용임을 기억하세요**: 이 함수들은 요청 시 전달된 헤더나 쿠키를 읽기만 할 수 있어요. 수정이나 생성 기능은 없답니다.\n- **클라이언트 컴포넌트에서는 사용 불가**: 이 함수들은 서버 컴포넌트에서만 사용할 수 있기 때문에 클라이언트 컴포넌트에서 호출하려면 다른 방법을 써야 해요.\n- **getStaticProps 대신 사용 가능**: 기존에 `getStaticProps`로 서버에서 요청 데이터를 다뤘던 부분을 app 디렉토리 기반 서버 컴포넌트에서 훨씬 간단하게 처리할 수 있게 된 거죠.\n\n---\n\n### 마무리\n\nNext.js의 app 디렉토리에서 headers와 cookies 함수는 요청 데이터를 안전하고 간편하게 다룰 수 있도록 해줘서, 서버 컴포넌트를 작성할 때 진짜 편리하답니다. 이제 상태 관리나 요청 처리 로직에 대해 걱정 없이, 필요한 헤더나 쿠키를 바로바로 읽어와서 활용해보세요!\n\n필요하다면 더 깊게 활용하는 방법도 알려드릴게요. 언제든 질문해주세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이번 글에서는 Next.js에서 페이지를 미리 렌더링하고 데이터를 가져오는 방법을 비교해볼게요. 특히 pages 디렉터리와 app 디렉터리에서 각각 어떻게 데이터 페칭을 하는지 살펴보겠습니다.\n\n---\n\n## pages 디렉터리: getStaticProps로 빌드 시 데이터 가져오기\n\npages 디렉터리에서는 `getStaticProps` 함수로 빌드 시점에 데이터를 가져와 페이지를 미리 렌더링해요. 외부 API나 데이터베이스에서 필요한 데이터를 가져와서 페이지 컴포넌트에 props로 넘겨줄 수 있죠.\n\n```js\n// pages/index.js\n\nexport async function getStaticProps() {\n  const res = await fetch(`https://...`)\n  const projects = await res.json()\n\n  return { props: { projects } }\n}\n\nexport default function Index({ projects }) {\n  return projects.map((project) => <div key={project.id}>{project.name}</div>)\n}\n```\n\n- 여기서 `getStaticProps`는 빌드 타임에서만 실행되고, HTML을 미리 만들어두기 때문에 빠른 초기 로딩이 장점이에요.\n- 단, 빌드 후에 데이터 변경사항이 있으면 다시 빌드해야합니다.\n- `project` 리스트를 렌더링할 때는 React의 key prop 챙기는 걸 잊지 마세요!\n\n---\n\n## app 디렉터리: fetch() 사용 시 기본 캐시 전략\n\napp 디렉터리에서는 서버 컴포넌트 내부에서 `fetch()`를 직접 사용해서 데이터를 가져올 수 있는데요, 이때 기본 옵션이 `cache: 'force-cache'`라서 기본적으로 데이터를 캐싱해요. 즉, 빌드 시 캐싱된 값을 계속 사용하다가 수동으로 캐시를 무효화할 때까지 재요청하지 않습니다.\n\n```js\n// app/page.js\n\n// 함수 이름은 자유롭게 지어도 됩니다.\nasync function getProjects() {\n  const res = await fetch(`https://...`)\n  const projects = await res.json()\n\n  return projects\n}\n\nexport default async function Index() {\n  const projects = await getProjects()\n\n  return projects.map((project) => <div key={project.id}>{project.name}</div>)\n}\n```\n\n- 서버 컴포넌트는 async 함수로 작성 가능해서 데이터를 서버에서 바로 받아올 수 있어요.\n- `fetch`의 기본 캐싱 정책 덕분에 getStaticProps와 유사하게 캐시된 데이터를 재사용할 수 있답니다.\n- 물론 필요하면 `fetch` 옵션으로 `cache: 'no-store'` 또는 `revalidate` 값을 조정해서 데이터 최신화 정책을 관리할 수도 있어요.\n\n---\n\n## 요약\n\n| 특징                   | pages 디렉터리 (getStaticProps)               | app 디렉터리 (fetch 기본 캐시)                    |\n|-----------------------|----------------------------------------------|---------------------------------------------------|\n| 데이터 페칭 시점         | 빌드 타임                                     | 서버 컴포넌트 실행 시 (기본 캐시 포함)                |\n| 데이터 캐싱 정책          | 빌드 후에는 고정, 다시 빌드해야 업데이트           | 기본 `force-cache` (캐시 수동 무효화 가능)               |\n| 사용법                  | `getStaticProps` 함수 별도 선언               | 서버 컴포넌트 안에서 바로 fetch                      |\n| 서버 컴포넌트 지원 여부    | 없음                                         | 지원                                            |\n\n---\n\nNext.js 13 버전부터는 app 디렉터리를 점점 더 권장하기 때문에, 기존 pages 디렉터리에서 했던 데이터 페칭 로직을 점차 바꾸는 것도 좋은 방법이에요. 단, 프로젝트 상황에 따라 필요한 캐싱 전략이나 데이터 최신화 정책을 잘 고민해서 적용하는 게 중요합니다.\n\n추가로, app 디렉터리에서는 React Server Components를 활용해서 클라이언트 측 JavaScript를 최소화하는 장점도 있어요. 다음에 React Server Components에 대해서도 한번 같이 살펴볼게요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n#### 다이나믹 경로 (getStaticPaths)\n\nNext.js에서 **pages** 디렉토리에선 `getStaticPaths` 함수를 사용해서 미리 빌드 타임에 생성할 동적 경로들을 정의해줍니다. 예를 들어, 게시글(id가 1, 2인 글)을 미리 만들어두고 싶을 때 이렇게 설정할 수 있죠.\n\n```js\n// pages 디렉토리 예시\nimport PostLayout from '@/components/post-layout'\n \nexport async function getStaticPaths() {\n  return {\n    paths: [{ params: { id: '1' } }, { params: { id: '2' } }],\n  }\n}\n \nexport async function getStaticProps({ params }) {\n  const res = await fetch(`https://.../posts/${params.id}`)\n  const post = await res.json()\n \n  return { props: { post } }\n}\n \nexport default function Post({ post }) {\n  return <PostLayout post={post} />\n}\n```\n\n- `getStaticPaths`는 어떤 경로를 정적 페이지로 미리 만들어둘지 알려주는 역할을 해요.\n- `params` 객체 안에 있는 `id`는 동적 라우트 이름과 일치해야 합니다. 예를 들어 `[id].js` 라면 `id`가 되어야 하죠.\n- 그런 다음 `getStaticProps`에서 `params`를 받아와서 실제 데이터를 불러와 페이지에 props로 넘깁니다.\n\n---\n\n그런데 **Next.js 13부터는 app 디렉토리 구조를 쓸 때는 `getStaticPaths`가 아니라** `generateStaticParams`라는 함수로 바뀌었어요. \n\n`generateStaticParams` 함수가 하는 역할은 거의 비슷하지만, 요즘엔 app 디렉토리에서는 이걸 더 권장하고 있어요. 다음과 같이 쓸 수 있습니다.\n\n```js\nexport async function generateStaticParams() {\n  return [{ id: '1' }, { id: '2' }]\n}\n```\n\n그리고 컴포넌트 쪽에선 `props` 대신에 동적 세그먼트를 바로 받아올 수도 있죠.\n\n---\n\n### 참고로!\n\n- `getStaticPaths` 혹은 `generateStaticParams` 둘 다 빌드 시점에 호출돼서 어떤 경로를 미리 만들어야 할지 결정합니다. 그래서 데이터가 바뀔 가능성이 잦다면 빌드 후에도 데이터가 반영되는 `ISR(Incremental Static Regeneration)` 옵션을 함께 사용하는 게 좋아요.\n- `generateStaticParams`는 app 디렉토리의 새로운 “서버 컴포넌트” 개념과도 맞닿아 있어서, 페이지를 더 쉽게 설계할 수 있게 만들어줍니다. Next.js 13 이상부터는 무조건 `generateStaticParams`를 쓰는 게 트렌드라고 생각하면 편해요.\n\n---\n\n저도 처음에 pages → app 디렉토리 쪽으로 옮겼을 때 좀 헷갈렸는데, 이 부분만 잘 쓰면 Next.js 13의 동적 라우팅도 확실히 깔끔하게 관리할 수 있으니 꼭 써보시길 추천드립니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여러분, Next.js의 `generateStaticParams` 함수에 대해 들어보셨나요? 기존에 많이 쓰이던 `getStaticPaths`와 비슷한 역할을 하지만, API가 훨씬 단순해지고 레이아웃 안에서도 사용할 수 있게 진화했습니다. 여기선 어떤 점이 좋은지, 그리고 어떻게 사용하면 좋은지 쉽게 알려드릴게요!\n\n일단, `generateStaticParams`는 반환 형식이 조금 다른데요. 예전 `getStaticPaths`처럼 중첩된 파라미터 객체 배열이나 경로 문자열 배열 대신, 그냥 각 세그먼트가 담긴 객체 배열을 반환하면 됩니다. 예를 들어:\n\n```js\n// `app` 디렉토리 안에서\nimport PostLayout from '@/components/post-layout'\n\nexport async function generateStaticParams() {\n  return [{ id: '1' }, { id: '2' }]\n}\n\nasync function getPost(params) {\n  const res = await fetch(`https://.../posts/${params.id}`)\n  const post = await res.json()\n\n  return post\n}\n\nexport default async function Post({ params }) {\n  const post = await getPost(params)\n\n  return <PostLayout post={post} />\n}\n```\n\n위 예시는 포스트 ID별로 미리 페이지를 생성할 때 사용되죠. `params` 객체를 받아서 필요한 데이터를 가져오고, 그걸 레이아웃 컴포넌트에 넘겨주는 방식이에요.\n\n---\n\n### 네이밍도 훨씬 직관적으로!\n기존에 `getStaticPaths`라고 하면 \"뭔가 'get' 하는 느낌인데, 정적 경로 정보가 필요한 거지?\" 싶은 이름이었죠. 하지만 요즘은 `generateStaticParams`처럼 \"생성(generate)\"이라는 단어가 들어가서, 실제로 경로를 만드는 과정임을 더 명확히 나타냅니다.\n\n또한, `Paths` 대신 `Params`를 쓰는 것도 큰 변화입니다. 왜냐하면 요즘 Next.js의 라우팅은 중첩 라우팅이나 여러 동적 세그먼트를 사용할 때가 많아서, 경로(path)보다 세그먼트별 파라미터(params)를 잘 표현해 주는 이름이 더 적합하거든요.\n\n---\n\n### `fallback` 속성은 이제 어떻게?\n기존에 `getStaticPaths`에서는 `fallback`이라는 옵션으로 \"경로가 미리 생성되지 않은 경우 처리 방법\"을 지정했죠. 그런데 `generateStaticParams` 사용 시에는 이런 옵션이 더 이상 필요하지 않습니다. 왜냐하면 `app` 디렉토리 기반의 새로운 라우팅 모델이 페이지 생성 자체를 더 선언적이고 유연하게 다루기 때문이에요.\n\n---\n\n### 마치며\n- `generateStaticParams`는 더 간단하고 명확한 API를 제공해요.\n- 레이아웃 레벨에서도 쉽게 경로 파라미터를 생성할 수 있답니다.\n- 네이밍도 훨씬 직관적이고, `fallback` 설정 또한 사라져서 사용법이 깔끔해졌어요.\n\nNext.js의 최신 `app` 디렉토리에서 동적 라우팅과 정적 생성 기능을 쓸 때 꼭 기억하세요! 앞으로 더 많은 기능이 나오면 또 소개해 드릴게요. 궁금한 점 있으면 댓글로 남겨주세요~\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서 페이지를 정적으로 생성할 때, `getStaticPaths`와 `fallback` 옵션이 어떻게 작동하는지 한 번 살펴볼게요. 보통 `pages` 디렉토리에서 많이 쓰는데, 여기에선 특정 페이지를 빌드 타임에 미리 생성하지 않고 상황에 따라 다르게 처리하는 방식을 알려줍니다.\n\n---\n\n### pages 디렉토리에서 fallback 옵션\n\n`getStaticPaths` 함수는 어떤 경로들을 미리 만들어둘지 알려주는 역할을 하고, `fallback` 옵션이 빌드 시 미리 생성되지 않은 경로에 대해서 어떻게 동작할지 결정해요.\n\n- `fallback: true`  \n  빌드 때 없는 페이지라도, 요청 시점에 페이지를 생성하면서 \"로딩 중\" 같은 fallback UI를 보여줄 수 있어요.\n- `fallback: false`  \n  빌드에 없는 페이지는 무조건 404 페이지를 반환해요.\n- `fallback: 'blocking'`  \n  요청이 들어오면 서버에서 페이지 완성까지 기다렸다가 완성된 페이지를 보여줘요. 로딩 중 UI 없이 자연스럽게 보여주는 느낌!\n\n예시 코드:\n\n```js\n// `pages` 디렉토리 예시\n\nexport async function getStaticPaths() {\n  return {\n    paths: [], // 미리 생성할 경로를 정의\n    fallback: 'blocking' // 요청 시 페이지가 없으면 바로 생성 후 반환\n  };\n}\n\nexport async function getStaticProps({ params }) {\n  // params를 활용해 데이터 패칭\n  ...\n}\n\nexport default function Post({ post }) {\n  return (\n    // 데이터 기반 컴포넌트 렌더링\n    ...\n  );\n}\n```\n\n---\n\n### app 디렉토리에서는 어떻게 다를까?\n\nNext.js 새로운 앱 디렉토리 방식에서는 `generateStaticParams`라는 함수로 미리 생성할 경로들을 정의하고, `config.dynamicParams` 옵션이 새롭게 등장했어요. 이 옵션은 `generateStaticParams`에 포함되지 않은 동적 경로들을 어떻게 처리할지 결정합니다.\n\n| config.dynamicParams | 동작 방식                                     |\n|----------------------|---------------------------------------------|\n| true (기본값)         | 미리 없던 경로라도 요청 시 생성 (on demand)  |\n| false                | generateStaticParams에 없는 경로는 404 반환 |\n\n이렇게 바뀌면서 페이지의 유연성이 좀 더 좋아졌고, 앱 디렉토리에선 빌드 방식과 동작 흐름이 좀 더 명확해졌어요. 기존 `fallback`과 역할은 비슷하지만, 옵션 이름과 적용되는 방식이 달라졌으니 참고하세요!\n\n---\n\n### 정리하며\n\n- `pages` 디렉토리에서는 `getStaticPaths`의 `fallback` 옵션이 동적 경로에 대응.\n- `app` 디렉토리에서는 `generateStaticParams` + `config.dynamicParams`로 대응.\n- `fallback: 'blocking'` 같은 옵션은, 사용자에게 매끄럽게 완성된 페이지를 보여주고 싶을 때 유용.\n- 새롭게 앱 디렉토리를 사용한다면 `config.dynamicParams`의 기본값이 true임을 기억!\n\n이 내용 참고해서 Next.js에서 동적 경로를 더 잘 다뤄보세요. 혹시 페이지 생성 타이밍이나 방법에 대해 더 궁금한 부분 있으면 언제든 물어봐 주세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js의 새로운 App 디렉토리에서, 기존 `pages` 디렉토리에서 사용하던 `getStaticPaths`의 `fallback: true | false | 'blocking'` 옵션을 대체하는 방식이 도입되었어요. \n\n특히 `fallback: 'blocking'` 옵션은 이제 `dynamicParams`에서는 제외됐는데, 그 이유는 `'blocking'`과 `true`가 스트리밍 환경에서는 거의 차이가 없기 때문입니다.\n\n아래 예제를 볼까요?\n\n```js\n// app 디렉토리 내 예제\n\nexport const dynamicParams = true;\n\nexport async function generateStaticParams() {\n  return [ /* 미리 생성할 경로들 반환 */ ];\n}\n\nasync function getPost(params) {\n  // params를 기반으로 포스트 데이터 조회\n  ...\n}\n\nexport default async function Post({ params }) {\n  const post = await getPost(params);\n\n  return (\n    // 포스트 데이터를 바탕으로 렌더링\n    ...\n  );\n}\n```\n\n위 코드를 보면 `dynamicParams`가 `true(기본값)`으로 설정돼 있어요. 이 경우, 만약 미리 생성된 경로가 아니라면, 해당 경로 요청 시 서버에서 렌더링 후 결과를 캐시합니다. 쉽게 말해, 없는 페이지를 처음 요청하면 서버가 페이지를 바로 만들어서 보여주고, 이후에는 저장해둔 결과를 빠르게 보여주는 방식이죠.\n\n---\n\n### Incremental Static Regeneration (ISR) (예전 getStaticProps + revalidate 개념)\n\n이 부분은 예전 `pages` 디렉토리에서 `getStaticProps`를 쓸 때 `revalidate` 옵션을 주는 것과 비슷해요. ISR은 빌드 타임에 미리 페이지를 만들어 놓고, 일정 시간이 지나면 다시 서버에서 페이지를 재생성하는 방식이죠. 이렇게 하면 매우 최신 상태의 페이지를 사용자에게 제공하면서도 정적인 페이지의 이점을 유지할 수 있어요.\n\nApp 디렉토리에서도 이런 개념이 비슷하게 적용되고 있으니, `generateStaticParams`와 `dynamicParams`를 적절히 활용해보면 성능과 최신성, 유지보수성을 모두 잡을 수 있습니다.\n\n---\n\n### 정리하자면!\n\n| 옵션             | 설명                                                                     |\n|----------------|------------------------------------------------------------------------|\n| `dynamicParams = true`  | 없는 경로 요청 시 서버에서 바로 생성 후 캐싱. 기본값.                                  |\n| `generateStaticParams()` | 미리 생성할 경로 목록을 지정. 주로 빌드 타임에 호출됨.                                    |\n| `fallback: 'blocking'` (pages) | 앱 디렉토리에선 적용 안 함. 스트리밍 환경에서는 `true`와 비슷한 역할을 하므로 제거됨.      |\n\nNext.js가 이런 식으로 SSR, SSG, ISR 방식을 더 자연스럽고 유연하게 지원하고 있어서, 개발자가 상황에 맞게 잘 선택해서 쓰기 좋아졌답니다.  \n\n필요하면 더 자세한 예제나 활용법도 알려줄게요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서 페이지를 자동으로 재생성하는 방법, `pages` 디렉토리와 `app` 디렉토리 각각에서 어떻게 다르게 동작하는지 알아볼게요.\n\n---\n\n### `pages` 디렉토리에서 `getStaticProps`의 `revalidate`\n\n`pages` 디렉토리에서는 `getStaticProps` 함수 안에 `revalidate` 필드를 넣으면 됩니다. 이 값은 몇 초마다 페이지를 다시 생성할지 정하는 거예요. 예를 들어 `revalidate: 60`이면, 처음 빌드 후 60초가 지나면 페이지가 다시 백그라운드에서 생성됩니다.\n\n```js\nexport async function getStaticProps() {\n  const res = await fetch(`https://.../posts`)\n  const posts = await res.json()\n \n  return {\n    props: { posts },\n    revalidate: 60, // 여기서 60초마다 재생성을 설정\n  }\n}\n \nexport default function Index({ posts }) {\n  return (\n    <Layout>\n      <PostList posts={posts} />\n    </Layout>\n  )\n}\n```\n\n- 이 방식은 페이지 단위로 작동해요.\n- 페이지 전체가 정적으로 빌드되고, 60초마다 업데이트된 내용을 반영해 새로 빌드됩니다.\n- 사용자가 방문할 때마다 항상 최신 데이터가 나오진 않지만, 정해진 시간 간격으로 최신 상태를 유지할 수 있어요.\n\n---\n\n### `app` 디렉토리에서 `fetch`의 `revalidate` 옵션\n\n`app` 디렉토리(Next.js 13의 새로운 앱 라우터 사용 시)에서는 데이터 패칭을 할 때 `fetch` 함수에 `{ next: { revalidate: 60 } }` 옵션을 붙여주면, 이 요청 결과를 60초 동안 캐싱합니다.\n\n```js\nasync function getPosts() {\n  const res = await fetch(`https://.../posts`, { next: { revalidate: 60 } })\n  const data = await res.json()\n \n  return data.posts\n}\n \nexport default async function PostList() {\n  const posts = await getPosts()\n \n  return posts.map((post) => <div>{post.name}</div>)\n}\n```\n\n- 여기서는 데이터 페칭 단위에서 재검증 시간을 설정하는 차이점이 있어요.\n- `fetch` 캐시는 60초 동안 유지되고, 그 사이 다시 요청하면 캐시된 데이터를 바로 씁니다.\n- 60초가 지나면 최신 데이터를 받아오고 캐시를 새로 만듭니다.\n- 이걸 합치면 부분 부분 데이터를 정적으로 캐싱하면서도 페이지 전체는 서버 컴포넌트로 동작하게 할 수 있어요.\n\n---\n\n### 요약하자면\n\n| 특징             | `pages` 디렉토리 (`getStaticProps`) | `app` 디렉토리 (`fetch`의 revalidate)  |\n|----------------|-----------------------------|------------------------------|\n| 동작 단위         | 페이지 단위                      | 데이터 요청 단위                   |\n| 재생성 주기 설정 방식 | `revalidate` 필드로 설정             | `fetch` 메서드 옵션으로 설정         |\n| 정적 생성 방식     | ISR(Incremental Static Regeneration) | 서버 컴포넌트 + 캐시 재검증             |\n| 업데이트 시점      | 방문 시점 기준 60초마다 백그라운드 생성    | 60초 간 캐시 사용 후 다음 요청 시 재검증   |\n\n---\n\n### 팁!\n\n- 만약 `app` 디렉토리에서 `fetch`에 `next: { revalidate: 0 }`를 넣으면 항상 최신 데이터를 가져오게 돼요.\n- 반대로 `next: { revalidate: false }`는 캐시를 아예 하지 않는 뜻이니, 기본 행동과 다르니 주의하세요.\n- `pages`에서 ISR 쓰던 것보다 `app` 디렉토리의 캐시 제어가 훨씬 세밀하고 유연해서 최신 데이터 처리에 더 좋은 편입니다.\n\n---\n\nNext.js 13 이후로는 `app` 디렉토리를 적극 활용하는 걸 추천해요. 서버 컴포넌트이면서도 유연한 캐싱 전략을 쓸 수 있기 때문에 앱 성능, 사용자 경험 면에서 더 나은 결과를 기대할 수 있답니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n#### API 라우트 (API Routes)\n\nNext.js에서 API 라우트는 여전히 `pages/api` 디렉토리에서 그대로 동작해요. 기존 방식과 달라진 점 없이 예전처럼 사용 가능합니다. 그런데 요즘에는 `app` 디렉토리 안에서 **Route Handlers**라는 더 발전된 방식을 많이 씁니다.\n\nRoute Handlers는 Web 표준의 Request와 Response API를 활용해서, 특정 경로에 대한 요청을 더 세밀하게 제어할 수 있게 해줘요. 예를 들어, `GET` 요청을 처리하는 함수를 이렇게 작성할 수 있죠:\n\n```js\nexport async function GET(request: Request) {\n  // 여기에 요청 처리 로직 작성\n}\n```\n\n즉, 함수 하나로 HTTP 메서드별 요청 핸들러를 만들 수 있다는 이야기인데요. 덕분에 서버 코드를 더 깔끔하고 명확하게 관리할 수 있어요.\n\n참고로, Route Handlers를 활용하면 응답 헤더 설정이나 쿠키 다루기 같은 것도 표준 API를 통해 자연스럽게 할 수 있으니, Next.js로 풀스택 개발할 때 아주 편리합니다.\n\n---\n\n### 간단 정리\n\n| 구분           | 설명                                             |\n|----------------|--------------------------------------------------|\n| API Routes     | `pages/api`에서 전통적으로 사용, 변경 없이 동작  |\n| Route Handlers | `app` 디렉토리에서 새롭게 지원, Web Request/Response API 사용 |\n\n작업하는 프로젝트가 최신 버전이고 `app` 디렉토리를 쓴다면 Route Handlers를 적극 활용해보세요! 기존 `pages/api`도 당분간 지원하니 상황에 맞게 선택하시면 됩니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n> 참고할 점: 이전에 클라이언트에서 외부 API를 호출하기 위해 API 라우트를 사용했다면, 이제는 서버 컴포넌트를 활용해 더 안전하게 데이터를 가져올 수 있어요. 데이터 fetching에 대해 더 자세히 알고 싶다면 공식 문서를 참고해보세요.\n\n#### 싱글 페이지 애플리케이션 (SPA)\n\n만약 동시에 SPA에서 Next.js로 마이그레이션하고 있다면, 관련된 문서를 꼭 확인해 보세요. 마이그레이션 과정에서 좋은 팁과 가이드가 포함되어 있으니 도움이 될 거예요.\n\n### 7단계: 스타일링\n\nNext.js로 옮겨오면서 스타일링도 신경 써줘야 해요. CSS, Sass, 또는 CSS-in-JS 등 다양한 스타일링 방법을 사용할 수 있는데, Next.js가 공식적으로 지원하는 방법들을 활용하면 깔끔하고 유지보수 쉬운 스타일링을 할 수 있답니다. 스타일링 관련해서는 따로 정리한 내용도 있으니 필요하면 알려드릴게요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n페이지 디렉토리에서는 글로벌 스타일시트가 오직 pages/_app.js에서만 적용되도록 제한되어 있었어요. 그런데 이제 app 디렉토리에서는 이 제한이 풀려서, 글로벌 스타일을 레이아웃(layout), 페이지, 컴포넌트 어디서든 자유롭게 추가할 수 있게 되었답니다.\n\n여기서 스타일을 다룰 수 있는 방법들을 간단히 정리하면 다음과 같아요:\n\n| 스타일 종류          | 설명                                    |\n|-------------------|---------------------------------------|\n| CSS Modules       | 각 컴포넌트에 scoped된 CSS를 적용하는 방법               |\n| Tailwind CSS      | 유틸리티 클래스 기반의 빠른 스타일링 프레임워크               |\n| Global Styles     | 전체 애플리케이션에 적용하는 전역 스타일                   |\n| CSS-in-JS         | 자바스크립트 파일 내에서 직접 스타일을 작성하는 방식         |\n| External Stylesheets | 외부 CSS 파일을 불러와 사용하는 방법                       |\n| Sass              | CSS 전처리기 중 하나로, 변수나 중첩 같은 기능을 지원           |\n\n---\n\n### Tailwind CSS\n\n만약 Tailwind CSS를 사용 중이라면, app 디렉토리를 tailwind.config.js에 추가해줘야 해요. 이렇게 하면 Next.js의 새 구조와 Tailwind가 잘 연동되어 스타일이 제대로 적용됩니다.\n\n예를 들어, tailwind.config.js 파일에서 아래처럼 설정해봅시다:\n\n```js\nmodule.exports = {\n  content: [\n    \"./app/**/*.{js,ts,jsx,tsx}\", // app 디렉토리에 있는 모든 파일을 대상으로 설정\n    \"./pages/**/*.{js,ts,jsx,tsx}\",\n    \"./components/**/*.{js,ts,jsx,tsx}\",\n  ],\n  theme: {\n    extend: {},\n  },\n  plugins: [],\n}\n```\n\n이렇게 해두면 app 디렉토리 내에 있는 모든 컴포넌트, 페이지, 레이아웃 파일에서 Tailwind 클래스를 제대로 인식하고 스타일이 적용될 거예요.\n\n---\n\n추가로, app 디렉토리 구조에 익숙하지 않은 분들을 위해 한 가지 팁을 알려드리면, app 디렉토리 안에서는 기본적으로 서버 컴포넌트가 활성화되어 있어요. 서버 컴포넌트에서는 CSS나 스타일을 다루는 방식에 약간 제한이 있을 수 있으니, 스타일이 꼭 필요한 클라이언트 컴포넌트는 `'use client'` 지시어를 붙여서 명확하게 구분해주는 게 좋습니다.\n\n궁금한 점 있으면 언제든 질문해 주세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이번 시간에는 Next.js 앱에서 Tailwind CSS를 설정하는 간단한 방법을 공유할게요! Tailwind CSS는 요즘 프론트엔드에서 가장 인기 있는 유틸리티 퍼스트 CSS 프레임워크 중 하나인데, 클래스만 붙여서 빠르게 스타일을 만들 수 있어서 개발 속도가 확실히 빨라집니다.\n\n먼저, Tailwind가 어디서 스타일을 찾아야 하는지 알려주는 설정파일(tailwind.config.js)을 수정해야 해요. 여러분이 만든 컴포넌트나 페이지에 있는 모든 파일을 지정해야 Tailwind가 정확히 필요한 스타일만 뽑아낼 수 있거든요.\n\n```js\nmodule.exports = {\n  content: [\n    './app/**/*.{js,ts,jsx,tsx,mdx}', // 여기에 Next.js app 폴더의 모든 JS/TS/MDX 파일 포함\n    './pages/**/*.{js,ts,jsx,tsx,mdx}', // pages 폴더도 포함\n    './components/**/*.{js,ts,jsx,tsx,mdx}', // 컴포넌트 폴더도 잊지 말고 넣기\n  ],\n}\n```\n\n이렇게 지정해주면, Tailwind가 여러분 프로젝트 안의 모든 화면과 컴포넌트에서 사용된 클래스를 잘 찾아낼 수 있어요.\n\n다음은 글로벌 CSS를 프로젝트에 불러와야 해요. Next.js 13버전부터 app 디렉토리를 사용하는 경우는 app/layout.js에 아래처럼 임포트해주면 된답니다.\n\n```js\nimport '../styles/globals.css'\n\nexport default function RootLayout({ children }) {\n  return (\n    <html lang=\"en\">\n      <body>{children}</body>\n    </html>\n  )\n}\n```\n\ntailwind가 들어간 globals.css 안에 기본 Tailwind 지시어(@tailwind base, @tailwind components, @tailwind utilities)가 들어있다고 가정한 거에요. 그래야 Tailwind 스타일이 전역에서 적용되어요.\n\n---\n\n### 여기서 잠깐!\n\n- `content` 배열에 프로젝트 내 Tailwind 클래스를 사용하는 모든 파일 경로를 넣어야 최적화된 CSS가 만들어져요. 안 넣으면, 실제 쓸 CSS가 빠지거나(디자인 깨짐), 쓰지 않는 CSS가 포함되어 파일 용량이 커져요.\n- Next.js 13버전부터는 `app/layout.js`가 없어도 `app/page.js` 같은 파일에 `import '../styles/globals.css'`를 하는 방식을 간혹 쓰기도 하는데, 공식 문서는 layout에서 임포트하는 걸 권장해요.\n- 만약 `mdx` 파일을 사용 중이라면 `.mdx` 확장자도 꼭 포함시켜야 Tailwind가 MDX 컨텐츠 내 스타일도 인식해요.\n\nTailwind CSS와 Next.js 조합으로 스타일 작업 할 때는, 꼭 위 내용을 체크해보시고 세팅하시면 더 편하고, 빠른 개발이 가능하답니다. 궁금한 점 있으면 언제든 댓글이나 DM 주세요!\n\n더 자세한 Tailwind CSS 활용법은 [공식 Tailwind 문서](https://tailwindcss.com/docs/guides/nextjs)에서 확인할 수 있어요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## App Router와 Pages Router 함께 사용하기\n\nNext.js에서는 App Router와 Pages Router라는 두 가지 라우팅 방식을 지원하는데요. 이 둘을 동시에 사용할 때는 조금 주의해야 할 점이 있습니다.\n\n서로 다른 라우터가 관리하는 경로 간 이동할 때, 기본적으로 하드 네비게이션(페이지 전체를 다시 로드하는 방식)이 발생해요. 그래서 next/link 컴포넌트가 제공하는 자동 링크 프리패칭 기능도 서로 다른 라우터 간에는 동작하지 않습니다.\n\n그렇다고 해서 두 라우터를 함께 쓸 수 없는 건 아니에요! 적절히 최적화하면 App Router와 Pages Router 사이에서도 빠르고 부드러운 페이지 전환을 경험할 수 있습니다. 조금 더 깊게 들어가면 각각의 라우팅 방식을 이해하고, 프리패칭 동작을 직접 구현하거나, 상태를 공유해서 사용자 경험을 개선할 수 있어요.\n\n### 추가 팁으로\n- 앱 규모가 크고, 점진적으로 App Router로 마이그레이션할 때 이 부분을 신경 쓰면 좋아요.\n- 필요하다면, 두 라우터 간 공유 가능한 글로벌 상태 관리 라이브러리(Recoil, Zustand, Redux 등)를 활용해 UI 일관성을 유지할 수 있어요.\n- 공식 문서나 커뮤니티에서 제공하는 팁들을 참고하면서 점진적으로 적용해 보세요.\n\n필요하면 어디서든 추가로 질문해 주세요. 함께 고민해봅시다!\n\n---\n\n## Codemods\n\nNext.js에서 라우팅 구조를 변경하거나 코드 스타일을 바꿀 때 도움을 주는 자동 수정 도구인 Codemods도 알아두시면 좋아요.\n\n설명과 함께 다음 포스트에서 자세히 다뤄볼게요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서는 기능이 더 이상 사용되지 않을 때 코드를 쉽게 업그레이드할 수 있도록 도와주는 Codemod 변환 도구를 제공합니다. Codemod는 자동으로 코드를 변경해 주기 때문에, 직접 하나하나 고치느라 시간을 낭비할 필요가 없어서 정말 편리하답니다.\n\n더 자세한 내용과 사용법은 [Codemods 공식 문서](https://nextjs.org/docs/codemods)를 참고해 보세요. 작업 전에는 꼭 코드 백업이나 버전 관리(Git)를 활용해서 안전하게 변경하는 걸 추천할게요! 혹시 Codemod를 처음 사용한다면, 간단한 테스트 파일부터 적용해보는 것도 좋은 방법입니다.\n\n이런 도구들을 활용하면, Deprecated된 기능 때문에 스트레스 받지 않고 손쉽게 최신 버전으로 코드를 유지할 수 있으니 꼭 한 번 써보시길 바랍니다!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":59},{"title":"Next.js 최신버전으로 업그레이드 하는 방법","description":"","date":"2025-04-22 01:20","slug":"2025-04-22-HowtoupgradeyourNextjsapp","content":"\n\n# Next.js 앱 업그레이드 쉽게 하는 방법\n\n## 최신 버전으로 업데이트하기\n\nNext.js 앱을 최신 버전으로 업그레이드하고 싶다면, 공식에서 제공하는 업그레이드 코드를 이용하면 정말 간단해요! 터미널에서 아래 명령어만 쓱 실행하면 끝납니다:\n\n```bash\nnpx @next/codemod@canary upgrade latest\n```\n\n이 명령어는 현재 프로젝트에 설치된 Next.js 버전을 자동으로 최신 버전으로 바꿔주고, 코드에 필요한 변경점들도 함께 처리해줘서 편리하답니다.\n\n---\n\n### 팁 하나 더!\n\n- 위 명령어는 `npx`를 이용해서 바로 실행하는 거라, 별도의 패키지 설치 없이도 사용 가능합니다.\n- 혹시 직접 `package.json`에서 버전을 수정하고 싶다면, `\"next\"` 버전을 최신 버전으로 바꾸고 `npm install` 또는 `yarn`을 실행해도 돼요.\n- 새로운 버전에서 변경된 주요 기능이나 deprecated된 부분이 있을 수 있으니, [Next.js 공식 릴리즈 노트](https://nextjs.org/blog)도 한 번 살펴보세요. 예상치 못한 버그 방지에 큰 도움이 된답니다!\n\nNext.js 덕분에 React 기반 SSR(서버사이드 렌더링)이 훨씬 쉬워졌는데, 꾸준히 업데이트하면서 최신 기능도 맛보고 앱도 더 빠르게 만들어봐요~!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 수동으로 업그레이드하는 걸 선호한다면, 최신 버전의 Next.js와 React를 이렇게 설치할 수 있어요:\n\n```bash\nnpm i next@latest react@latest react-dom@latest eslint-config-next@latest\n```\n\n---\n\n## 캐나리(Canary) 버전\n\n최신 캐나리 버전으로 업데이트하고 싶다면, 먼저 Next.js가 최신 버전인지 확인하고 현재 프로젝트가 정상적으로 작동하는지 테스트하는 게 중요해요. 안정적인 상태를 확인한 다음, 아래 명령어를 실행하면 됩니다:\n\n```bash\nnpm i next@canary react@canary react-dom@canary eslint-config-next@canary\n```\n\n캐나리 버전은 아직 테스트 중인 기능들이 포함되어 있어서, 최신 기능을 미리 써보고 싶거나 버그를 발견해서 직접 피드백하고 싶을 때 유용해요. 그러나 안정성은 정식 버전보다 떨어질 수 있으니, 중요 프로젝트라면 충분히 테스트한 뒤에 도입하는 걸 추천드려요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n```bash\nnpm i next@canary\n```\n\n### 캔버리 버전에서 사용할 수 있는 기능들\n\n현재 캔버리 버전에서 제공되는 주요 기능들을 살펴볼게요!\n\n- **캐싱(Caching)** :  \n  성능 향상을 위해 콘텐츠를 효율적으로 저장하고 재사용하는 기능이에요. 이 기능 덕분에 페이지 로딩 속도가 빨라지고 서버 부담도 줄일 수 있답니다.\n\n캔버리 버전은 보통 최신 기능을 먼저 접해보고 싶을 때 추천드려요. 안정성은 정식 버전보다 조금 떨어질 수 있으니 중요한 프로젝트엔 주의가 필요해요 :)\n\n만약 캐싱 기능 외에도 어떤 기능들이 있는지 더 궁금하다면, 다음에 또 자세히 다뤄보도록 할게요!\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이번에는 개발하면서 자주 만날 수 있는 몇 가지 키워드와 용어들을 정리해볼게요. 각각 어떤 의미인지, 그리고 어떻게 활용할 수 있는지 함께 살펴보자고요!\n\n| 키워드         | 설명                                                                                 |\n|----------------|--------------------------------------------------------------------------------------|\n| use cache      | 캐시를 사용하는 옵션이나 설정. 서버나 클라이언트에서 자주 요청되는 데이터를 임시로 저장해서 빠르게 응답할 수 있게 도와줘요. |\n| cacheLife      | 캐시가 유지되는 시간. 즉, 캐시 데이터를 얼마 동안 유효하게 쓸지 결정하는 값이에요. 예를 들어, 10분 동안 캐시 유지라면 10분 뒤엔 새로운 데이터를 가져오죠. |\n| cacheTag       | 캐시를 식별하거나 그룹핑하기 위한 태그. 이를 통해 특정 태그가 붙은 캐시만 선택적으로 삭제하거나 갱신할 수 있어요. |\n| dynamicIO      | 동적으로 입출력을 처리하는 기능. 예를 들어, 사용자 입력이나 요청에 따라 실행되는 코드가 동적으로 바뀔 때 쓰여요. 서버와의 실시간 데이터 교환 같은 곳에서 중요해요. |\n\n이제 인증(Authentication) 관련된 용어들도 살펴볼까요? 인증 로직을 짤 때 자주 접하게 되니까 알아두면 좋아요.\n\n| 키워드           | 설명                                                                                  |\n|------------------|---------------------------------------------------------------------------------------|\n| forbidden        | 접근 권한이 없는 자원에 대해 서버가 요청을 거부할 때 사용하는 상태. 보통 HTTP 403 에 해당해요. |\n| unauthorized     | 인증이 필요한 자원에 대해 인증이 안 된 상태에서 접근하려고 할 때 사용하는 상태. HTTP 401과 연결돼요. |\n| forbidden.js     | 접근 금지(403) 관련 로직을 처리하는 자바스크립트 파일일 가능성이 높아요. 예외 처리를 담당하거나 사용자에게 알림을 줄 때 사용하겠죠? |\n| unauthorized.js  | 인증되지 않은 상태(401)를 처리하는 자바스크립트 파일. 로그인 페이지로 리다이렉트하거나 경고 메시지를 띄우는 용도로 쓰일 수 있어요. |\n| authInterrupts   | 인증과 관련된 작업 도중에 흐름을 중단시키거나 인터셉트(가로채기) 하는 기능. 예를 들어, 인증 실패 시 다른 동작을 막고 로그인 화면으로 보내는 등 제어할 때 유용하답니다. |\n\n---\n\n### 덧붙여서\n\n캐시 관련 개념들은 개발 성능 최적화에서 정말 중요해요. 예를 들어, 대규모 서비스에서는 무한정 캐시 데이터를 유지하면 메모리가 부족해질 수 있으니까 `cacheLife` 값을 적절히 조정하는 게 중요하죠. 또한, 만약 여러 캐시 데이터를 그룹화해야 한다면 `cacheTag`를 활용해서 필요한 부분만 빠르게 업데이트할 수 있답니다.\n\n그리고 인증 처리 로직은 보안에 직결되니, 상태 코드(403, 401)를 클라이언트에 명확하게 알려주는 게 중요해요. 그리고 인증 실패나 권한 부족 상황에서 사용자에게 적절한 피드백을 주는 것도 잊지 마시고요.\n\n혹시 실제 코드 구현과 관련해서 추가로 궁금한 점 있으면 언제든 말해 주세요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":5},{"title":"Next.js 15 웹사이트 배포하는 5가지 방법","description":"","date":"2025-04-22 01:19","slug":"2025-04-22-HowtodeployyourNextjsapplication","content":"\n\n# Next.js 애플리케이션 배포하는 방법\n\nNext.js 앱 개발을 끝내고 배포할 준비가 됐다면, 크게 두 가지 방법이 있어요. 하나는 관리형 인프라 제공업체(Managed Infrastructure Provider)를 이용하는 거고, 다른 하나는 직접 서버를 세팅해서 호스팅하는 방법이죠.\n\n## 관리형 인프라 제공업체 이용하기\n\n관리형 플랫폼은 Next.js 앱 배포할 때 꽤 편리한 선택이에요. 이 업체들은 호스팅부터 서버 설정, 스케일링(트래픽에 맞춰 서버 용량 자동 조절)까지 알아서 해주기 때문에 개발자는 코드에만 집중할 수 있거든요.\n\n예를 들어, Vercel, Netlify, AWS Amplify 같은 곳이 대표적이에요. 특히 Next.js를 만든 회사가 운영하는 Vercel은 Next.js 최적화가 잘 돼 있어서 배포가 아주 간편하죠.\n\n관리형 플랫폼의 장점은:\n\n- 별도의 서버 관리 없이 빠른 배포 가능\n- 트래픽 변화에 따라 자동으로 스케일링\n- HTTPS, CDN 등 보안과 퍼포먼스도 기본 제공  \n- CI/CD (코드 변경 시 자동 배포)도 쉽게 설정할 수 있어요\n\n사실 초보자나 소규모 프로젝트에는 관리형 플랫폼이 가장 추천되는 방법입니다. 물론 비용은 트래픽과 사용량에 따라 달라지니 참고하세요!\n\n---\n\n다음은 직접 서버를 세팅해서 호스팅하는 방법도 있는데, 그 부분도 궁금하면 알려드릴게요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nVercel은 Next.js의 제작자이자 유지 관리자이며, 별도의 설정 없이도 풀 기능을 지원하는 애플리케이션 배포를 할 수 있게 도와줍니다.\n\n- Vercel에서 Next.js에 대해 더 알아보기  \n- Vercel에서 템플릿을 배포해 Next.js를 직접 사용해보기  \n\n그리고 커뮤니티에서 관리하는 배포 템플릿도 준비되어 있는데요, 다음 플랫폼들을 지원합니다:\n\n| 플랫폼 이름    | 설명                   |\n|---------------|------------------------|\n| Deno          | 최신 자바스크립트와 타임스크립트 런타임 |\n| Flightcontrol | 서버리스 배포 관리 도구 |\n| Railway       | 간편한 클라우드 인프라 서비스 |\n| Render        | 풀 매니지드 클라우드 플랫폼 |\n| SST           | 서버리스 스택 개발 프레임워크 |\n\nVercel을 이용하면 복잡한 설정 없이도 Next.js 앱뿐만 아니라, 다양한 환경에서 쉽게 배포할 수 있어서 개발 생산성이 쑥쑥 올라가요. 특히 요즘처럼 빠르게 웹 애플리케이션을 배포하고 테스트해야 할 때는 정말 유용하니 한 번 써보시길 추천합니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js를 사용할 때, 각 클라우드 제공업체마다 지원하는 기능들이 조금씩 다르니 꼭 해당 업체의 문서를 참고하는 게 좋아요.\n\n## 직접 호스팅(Self-Hosting)이란?\n\n직접 호스팅은 서버를 직접 준비하고, 컨테이너를 관리하며, 트래픽에 맞춰 확장하는 모든 걸 직접 책임져야 한다는 뜻이에요. 직접 호스팅하는 방법은 크게 세 가지가 있어요:\n\n| 직접 호스팅 방식        | 설명                                           |\n|------------------|----------------------------------------------|\n| Node.js 서버       | Next.js 앱을 직접 Node.js 서버에서 실행해요.        |\n| Docker 컨테이너    | Next.js 앱을 Docker 컨테이너 안에서 실행해 관리해요.    |\n| 정적 내보내기(Static Export) | Next.js를 정적 사이트로 빌드해, 서버 없이도 배포해요.     |\n\n이 중에서 어떤 방식을 선택하느냐는 프로젝트의 필요와 리소스에 따라 달라져요. 예를 들어, 실시간 데이터 처리나 서버 사이드 렌더링이 필요하면 Node.js 서버나 Docker를 사용하는 게 좋고, 콘텐츠가 주로 정적인 경우라면 정적 내보내기를 고려해볼 수 있겠죠.\n\n참고로 Docker를 사용하면 배포가 좀 더 일관되고, 확장하거나 환경을 맞추기도 쉬워서 최근 많이 선호되는 편이에요. 혹시 직접 서버 세팅이 부담된다면, 서버리스(서버 없는) 플랫폼들도 있으니 다음에 다뤄볼게요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n커뮤니티에서 관리하는 다양한 셀프 호스팅 예제들이 있어요. 아래는 대표적인 셀프 호스팅 제공업체들이에요:\n\n- DigitalOcean\n- Fly.io\n- GitHub Pages\n- Google Cloud Run\n\n그리고 참고할 만한 영상도 추천해드릴게요! Next.js를 셀프 호스팅하는 방법을 45분 동안 자세히 알려주는 유튜브 영상이에요. 직접 셀프 호스팅에 도전해보고 싶다면 꼭 한번 보세요! 🎥\n\n---\n셀프 호스팅을 하면서 각 플랫폼마다 특징이 조금씩 달라요. 예를 들어, DigitalOcean은 가상 서버를 직접 관리하는 느낌이고, Fly.io는 글로벌 엣지 네트워크를 활용할 수 있어서 빠른 응답 속도를 자랑합니다. GitHub Pages는 정적 사이트 배포에 딱 좋고, Google Cloud Run은 컨테이너 기반 서비스라 자동 확장에 유리하답니다.\n\n혹시 셀프 호스팅이 처음이라면, 본인이 원하는 서비스 규모와 관리 난이도에 맞는 플랫폼 선택이 중요해요. 또, 배포 자동화를 위해 GitHub Actions나 CI/CD 도구들을 같이 사용하는 것도 좋은 팁이니 참고해보세요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":4},{"title":"Next.js 15에서 메타데이터 추가 및 OG 이미지 생성하는 방법","description":"","date":"2025-04-22 01:18","slug":"2025-04-22-HowtoaddmetadataandcreateOGimages","content":"\n# 메타데이터 추가와 OG 이미지 만들기 방법\n\n웹 개발하다 보면 SEO(검색 엔진 최적화)나 SNS 공유 시 내 페이지가 더 멋지게 보이도록 메타데이터와 OG(Open Graph) 이미지를 설정하는 게 정말 중요하죠. Next.js에서는 이런 걸 엄청 쉽게 할 수 있도록 메타데이터용 API들을 제공해요.\n\n예를 들면,\n\n- **정적 메타데이터 객체(static metadata object)**\n- **동적으로 메타데이터를 생성하는 함수(generateMetadata)**\n- 그리고 정적 혹은 동적으로 생성되는 파비콘(favicon)이나 OG 이미지를 넣기 위한 특별한 파일 규칙\n\n이런 옵션들을 사용해서, Next.js가 알아서 해당 페이지에 필요한 `<head>` 태그를 생성해줘요. 그래서 개발자 도구에서 살펴보면 자동으로 쭉 생성된 걸 확인할 수 있답니다.\n\n---\n\n## 좀 더 자세히 설명해볼게요!\n\n### 1. 정적 메타데이터 객체 (Static Metadata)\n\n간단하게 `metadata`라는 객체를 만들고, 그 안에 title, description, og:image 같은 정보를 딱 고정시켜 넣을 수 있어요.\n\n```js\nexport const metadata = {\n  title: \"내 Awesome 페이지\",\n  description: \"여기는 내 멋진 Next.js 앱이에요.\",\n  openGraph: {\n    images: [\"/og-image.png\"],\n  },\n};\n```\n\n이렇게 해놓으면 해당 정보가 자동으로 `<head>` 안에 들어가서 SEO 효과도 보고, 페이스북이나 트위터에 공유할 때 예쁜 카드로 나와요.\n\n### 2. 동적 메타데이터 생성 (Dynamic generateMetadata)\n\n예를 들어, 블로그 포스트마다 제목이나 설명이 다를 때, 함수 형태로 만들면 요청할 때마다 데이터를 받아서 메타데이터를 바꿔줄 수 있어요.\n\n```js\nexport async function generateMetadata({ params }) {\n  const post = await getPostData(params.id);\n\n  return {\n    title: post.title,\n    description: post.summary,\n    openGraph: {\n      images: [post.ogImage],\n    },\n  };\n}\n```\n\n이렇게 하면 매번 해당 글에 맞는 메타데이터가 동적으로 들어가니까, SEO랑 SNS 공유가 훨씬 좋아지죠.\n\n### 3. 파비콘과 OG 이미지 자동설정\n\nNext.js에서는 `favicon.ico` 같은 파일을 프로젝트 루트에 두거나, OG 이미지를 특정 경로에 두면 자동으로 인식해줘요.\n\n특히, OG 이미지는 요즘 꼭 넣어야 하는데, 일부러 직접 `<meta property=\"og:image\" ...>` 태그 안 넣어도 Next.js가 알아서 해주는 점이 편리해요.\n\n---\n\n## 함께 알아두면 좋은 팁\n\n- **OG 이미지 사이즈**: 일반적으로 1200x630 픽셀 정도가 적당해요. 너무 작으면 카드가 깔끔하게 안 나오고, 너무 크면 로딩에 부담이 돼요.\n- **SEO와 UX도 같이 챙기자**: 메타데이터는 검색 결과뿐만 아니라, 실제 사용자가 공유 링크를 클릭하는 경험에도 영향을 줘요. 좋은 제목과 설명, 이미지가 방문자 증가로 이어질 수 있어요.\n- **Next.js 문서 참고**: Next.js 공식 문서에 메타데이터 관련 가이드가 아주 잘 정리되어 있으니, 실습해보면서 익히면 더 도움이 될 거예요.\n\n---\n\n메타데이터와 OG 이미지를 신경 쓰면, 우리 앱이나 웹사이트가 한층 더 프로페셔널하고, 사용자에게 친숙하게 다가갈 수 있으니 꼭 적용해보세요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 기본 필드 (Default fields)\n\n웹사이트를 만들 때, 라우트(route)에 메타데이터(metadata)를 따로 정의하지 않아도 자동으로 추가되는 기본 메타 태그(meta tag)가 두 가지 있어요. 이 두 가지는 웹 페이지가 제대로 보이고 작동하는 데 꼭 필요한 친구들입니다.\n\n- **`<meta charset=\"utf-8\" />`**\n  - 이 태그는 웹페이지에서 사용되는 문자 인코딩을 UTF-8로 설정해줘요.\n  - UTF-8은 한글, 영어, 이모지 등 다양한 문자를 모두 지원하기 때문에 대부분의 웹사이트에서 기본으로 사용하고 있답니다.\n- **`<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />`**\n  - 스마트폰이나 태블릿 같은 다양한 디바이스에서 화면 크기와 초기 확대 비율(scale)을 조절해주는 태그예요.\n  - 만약 이 태그가 없다면, 모바일 화면에서 회원가입 폼이나 메뉴가 너무 작게 보이거나, 반대로 너무 커져서 사용하기 어려워질 수 있어요.\n\n```html\n<meta charset=\"utf-8\" /> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n```\n\n> 참고로, 다양한 메타 태그들이 있지만 이 두 개는 모든 HTML 문서에 꼭 넣어줘야 하는 기본 중의 기본입니다. 덕분에 사용자들이 어느 디바이스로 접속해도 글자가 깨지지 않고, 화면도 적절하게 보여서 사용자 경험(UX)이 좋아지죠!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n메타데이터(metadata)를 다룰 때, 정적인 메타데이터(static metadata)와 동적으로 생성되는 메타데이터(generated metadata)를 정의하는 방법이 있어요. 정적인 메타데이터는 정해진 값 그대로 사용하고, 동적인 메타데이터는 컴포넌트 내 함수로 데이터를 생성해서 설정할 수 있죠.\n\n---\n\n## 정적 메타데이터 (Static Metadata)\n\n정적 메타데이터를 만들고 싶다면, `layout.js`나 `page.js` 같은 정적인 파일에서 `Metadata` 객체를 `export` 하면 됩니다. 예를 들어, 블로그 페이지에 제목과 설명을 추가하고 싶을 때 코드는 이렇게 작성할 수 있어요:\n\n```js\nimport type { Metadata } from \"next\";\n\nexport const metadata: Metadata = {\n  title: \"My Blog\",\n  description: \"...\",\n};\n\nexport default function Page() {}\n```\n\n위 코드를 보면 `metadata`라는 이름으로 메타데이터를 내보내고 있고, 타입도 명확히 `Metadata`로 지정해줬습니다. 이렇게 하면 Next.js가 해당 페이지를 렌더링할 때 이 메타데이터를 자동으로 인식해서 `<head>` 태그에 적절한 메타 정보를 넣어주죠.\n\n---\n\n### 추가 팁!\n\n- `title`은 화면의 탭 제목으로도 노출되니, 페이지별로 명확하고 간결하게 작성하는 게 좋아요.\n- `description`은 SEO에 중요한 역할을 하니까, 페이지 내용과 맞는 적절한 설명을 넣어줘야 합니다.\n- 메타데이터는 페이지가 최초로 로드될 때만 적용되므로, 자주 바뀌는 값은 동적 메타데이터 방식을 사용하세요.\n\n정리하자면, 페이지마다 변하지 않는 고정된 정보(예: 사이트 이름, 정적 설명)를 넣을 땐 `metadata` 객체를 이용하는 것이 가장 손쉽고 직관적입니다. 다음에는 동적으로 메타데이터를 생성하는 방법도 알려드릴게요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\ngenerateMetadata 함수로 동적인 메타데이터를 쉽게 가져올 수 있어요. 예를 들어 특정 블로그 포스트의 제목과 설명을 API에서 받아오고 싶다면 이렇게 작성하면 됩니다:\n\n```js\nimport type { Metadata, ResolvingMetadata } from 'next'\n\ntype Props = {\n  params: Promise<{ id: string }>\n  searchParams: Promise<{ [key: string]: string | string[] | undefined }>\n}\n\nexport async function generateMetadata(\n  { params, searchParams }: Props,\n  parent: ResolvingMetadata\n): Promise<Metadata> {\n  const slug = (await params).slug\n\n  // API에서 포스트 정보 가져오기\n  const post = await fetch(`https://api.vercel.app/blog/${slug}`).then(res =>\n    res.json()\n  )\n\n  return {\n    title: post.title,\n    description: post.description,\n  }\n}\n\nexport default function Page({ params, searchParams }: Props) {}\n```\n\n### 여기서 조금 더 알려드리자면\n\n- `generateMetadata`는 Next.js에서 페이지에 필요한 메타 정보를 서버사이드에서 미리 가져와서 SEO에 유리하게 사용할 수 있게 해줘요.\n- `params`와 `searchParams`는 라우팅 정보와 쿼리 스트링 정보를 Promise 형태로 받아오는데, 이걸 `await` 해서 실제 값을 꺼내 써야 합니다.\n- 메타데이터엔 `title`, `description` 외에도 `openGraph`, `twitter` 같은 소셜 미디어용 메타 정보도 포함할 수 있어요.\n- 만약 API가 느리거나, 자주 바뀌지 않는 경우엔 캐싱 전략도 고민해보세요. 서버 부담도 줄이면서 사용자 경험을 더 좋게 만들 수 있답니다.\n\n이렇게 `generateMetadata`를 잘 활용하면 각 페이지마다 동적인 메타데이터를 쉽게 관리할 수 있어서 SEO 최적화에 큰 도움이 돼요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js 내부에서는 메타데이터를 UI와 별도로 스트리밍하고, 메타데이터가 준비되는 대로 HTML에 바로 주입하는 방식으로 동작해요. 덕분에 사용자에게 더 빠르게 정보를 보여줄 수 있답니다.\n\n### 데이터 요청 memoization (메모이제이션)\n\n메타데이터를 렌더링할 때와 페이지를 렌더링할 때 동일한 데이터를 여러 번 요청해야 하는 상황이 생길 수 있어요. 이럴 때 매번 중복해서 데이터를 요청하면 비효율적이죠. 그래서 React의 `cache` 함수를 활용해 데이터를 한번만 가져오고 결과를 메모이제이션해서 재사용할 수 있어요.\n\n예를 들어, 블로그 포스트 정보를 메타데이터 생성과 페이지 렌더링에 모두 사용해야 할 때 이렇게 작성할 수 있습니다:\n\n```js\nimport { cache } from \"react\";\nimport { db } from \"@/app/lib/db\";\n\n// getPost 함수는 두 번 호출되지만, 실제로는 한 번만 실행돼요\nconst getPost = cache(async (slug) => {\n  const res = await db.query.posts.findFirst({ where: eq(posts.slug, slug) });\n  return res;\n});\n```\n\n이렇게 하면 같은 `slug`에 대해 여러 번 호출해도 데이터베이스 쿼리는 한 번만 실행되니까 성능이 쑥~ 좋아지죠.\n\n---\n\n추가로, Next.js 13 이상부터 데이터 패칭에서 이런 memoization을 자주 활용할 텐데, 이 기능 덕분에 서버 측 렌더링 시 효율적으로 데이터를 관리할 수 있어요. 만약 `getPost`를 여러 컴포넌트에서 공유하고 싶다면 별도의 유틸 파일에 묶어두고 재사용하는 것도 좋은 패턴입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n자, 이번에는 Next.js에서 동적으로 메타데이터를 생성하는 방법과 함께 파비콘(Favicon)을 추가하는 기본적인 방법에 대해 살펴보려고 해요.\n\n---\n\n## 1. 동적 메타데이터 생성하기\n\n```tsx\nimport { getPost } from \"@/app/lib/data\";\n\nexport async function generateMetadata({ params }: { params: { slug: string } }) {\n  // URL 파라미터(slug)를 이용해서 해당 게시글 데이터를 가져와요\n  const post = await getPost(params.slug);\n  return {\n    title: post.title, // 동적으로 페이지 타이틀 설정\n    description: post.description, // 동적으로 메타 설명 설정\n  };\n}\n\nexport default async function Page({ params }: { params: { slug: string } }) {\n  const post = await getPost(params.slug);\n  return <div>{post.title}</div>;\n}\n```\n\n위 코드는 Next.js 13의 새로운 라우팅 방식에서 메타 태그를 동적으로 생성하는 대표적인 예시예요. `params.slug`를 통해 URL에 맞는 글 내용을 서버 사이드에서 불러온 다음, 해당 글 제목과 설명을 메타 태그에 넣어 주는 방식이죠.\n\n> 🔥 참고: `generateMetadata` 함수는 페이지 렌더링 전에 호출되므로, SEO 최적화에 아주 유리합니다.\n\n---\n\n## 2. 파비콘(Favicon) 추가하기\n\n파비콘은 웹 브라우저 탭이나 북마크에 표시되는 작은 아이콘이에요. 사이트의 아이덴티티를 표현하는 데 아주 중요한 역할을 하죠. 간단하게 적용하는 방법을 알려드릴게요.\n\n### 방법\n\n- `favicon.ico` 파일을 프로젝트의 **루트 폴더 (`app` 폴더)**에 넣어주세요.\n- Next.js는 기본적으로 루트에 있는 `favicon.ico`를 자동으로 인식해서 `<head>`에 추가해 줍니다.\n\n만약 `favicon.ico` 대신 PNG 등 다른 형식을 쓴다면, `app/head.tsx` 혹은 `app/layout.tsx` 내에서 직접 설정해야 해요.\n\n```tsx\n// app/head.tsx 예시\nexport default function Head() {\n  return (\n    <>\n      <link rel=\"icon\" href=\"/favicon.ico\" />\n      {/* 다른 메타 태그들도 여기에 추가 가능 */}\n    </>\n  );\n}\n```\n\n---\n\n## 추가 팁!\n\n- 파비콘을 만드는 데 어려움을 겪는다면 [favicon.io](https://favicon.io/) 같은 온라인 툴을 써서 쉽게 만들 수 있어요.\n- 요즘에는 다양한 해상도(16x16, 32x32, 48x48, 64x64 등)로 미리 준비하는 것이 좋고, 모바일 앱 아이콘이나 Apple 터치 아이콘용으로 별도 이미지를 준비하는 경우도 많답니다.\n\n---\n\n## 요약\n\n| 내용                 | 설명                                                                   |\n| -------------------- | ---------------------------------------------------------------------- |\n| 동적 메타데이터 생성 | `generateMetadata` 함수로 SEO 최적화와 동적 페이지 제목/설명 설정 가능 |\n| 파비콘 추가          | `favicon.ico`를 `app` 폴더에 추가하거나 `<head>`에서 직접 링크를 명시  |\n\n---\n\n![파비콘 설정 이미지](/TIL/img/2025-04-22-HowtoaddmetadataandcreateOGimages_0.png)\n\n파비콘과 메타데이터를 제대로 설정하면 SEO뿐 아니라 사용자 경험도 훨씬 좋아지니 꼭 챙겨보시길 바랄게요!  \n필요하면 댓글로 질문 남겨 주세요! 😊\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n> 프로그래밍으로도 파비콘(favicon)을 자동 생성할 수 있어요. 더 자세한 내용은 파비콘 관련 문서를 참고해 보세요.\n\n## 정적 Open Graph 이미지 만들기\n\nOpen Graph(OG) 이미지는 SNS에서 내 사이트를 대표하는 이미지예요. 내 앱에 정적인 OG 이미지를 추가하려면, 앱 폴더(root 디렉토리)에 `opengraph-image.png` 파일을 넣으면 돼요.\n\n예를 들어 이렇게 생긴 이미지가 해당 파일일 수 있겠죠:\n\n| ![Open Graph 이미지 예시](https://your-site.com/assets/img/2025-04-22-HowtoaddmetadataandcreateOGimages_1.png) |\n| :------------------------------------------------------------------------------------------------------------: |\n|                                            _Open Graph 이미지 예시_                                            |\n\n이렇게 OG 이미지를 설정해 두면, 페이스북이나 트위터 같은 SNS에 내 웹사이트 링크를 공유할 때 예쁜 썸네일로 보여줘서 사용자 경험을 훨씬 더 좋게 만들 수 있답니다.\n\n추가로, OG 이미지는 보통 1200x630 픽셀 정도 크기를 권장해요. 그래야 각 SNS에서 최적화되어 잘 보이거든요. 또한, 만약 동적인 OG 이미지를 만들고 싶다면, 코드로 이미지를 생성하는 방법도 있으니, 나중에 활용해 보시면 좋겠네요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n특정 경로에 대해 OG 이미지를 추가하고 싶다면, 해당 경로 폴더 안에 opengraph-image.png 파일을 만들어주면 돼요. 예를 들어, /blog 경로에 맞는 OG 이미지를 추가하고 싶다면 blog 폴더 안에 opengraph-image.jpg 파일을 넣으면 됩니다.\n\n<img src=\"/TIL/assets/img/2025-04-22-HowtoaddmetadataandcreateOGimages_2.png\" />\n\n폴더 구조에서 더 깊숙한 경로에 있는 이미지가 우선해서 적용된다는 점, 기억하세요!\n\n> 참고로 jpeg, png, webp 같은 다른 이미지 포맷도 지원되니까 상황에 맞게 사용하면 됩니다. 더 자세한 내용은 Open Graph Image 문서를 참고해 보세요.\n\n추가로 팁을 드리자면, 여러 경로에 공통으로 쓰이는 기본 OG 이미지를 루트 폴더에 넣고, 그 이미지를 기본값처럼 설정해놓으면 관리가 훨씬 수월해요. 필요한 특정 페이지에는 별도의 이미지를 넣어서 덮어쓰면 되고요. 이렇게 하면 SEO 최적화와 SNS 공유 시 더 세련된 미리보기 이미지를 보여줄 수 있답니다!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 동적으로 생성하는 오픈 그래프(Open Graph) 이미지 만들기\n\nOpen Graph 이미지는 페이스북, 트위터 같은 소셜 미디어에 링크를 공유할 때 보이는 미리보기 이미지라고 생각하면 편해요. 이 이미지를 글마다 다르게 자동 생성하면 훨씬 프로페셔널해 보이죠? Next.js의 `ImageResponse` 생성자를 사용하면 JSX와 CSS로 동적인 이미지를 쉽게 만들 수 있어요.\n\n### 사용법 예시\n\n아래 코드는 블로그 포스트마다 고유한 OG 이미지를 생성하는 방법입니다. 블로그 폴더 내에 `opengraph-image.ts` 파일을 만들고, `next/og`에서 `ImageResponse`를 불러와 사용해요.\n\n```js\nimport { ImageResponse } from \"next/og\";\nimport { getPost } from \"@/app/lib/data\";\n\n// 이미지 메타 정보\nexport const size = {\n  width: 1200,\n  height: 630,\n};\n\nexport const contentType = \"image/png\";\n\n// 이미지 생성 함수\nexport default async function Image({ params }: { params: { slug: string } }) {\n  const post = await getPost(params.slug);\n\n  return new ImageResponse(\n    (\n      // ImageResponse에서 그릴 JSX 요소\n      <div\n        style={{\n          fontSize: 128,\n          background: \"white\",\n          width: \"100%\",\n          height: \"100%\",\n          display: \"flex\",\n          alignItems: \"center\",\n          justifyContent: \"center\",\n        }}\n      >\n        {post.title}\n      </div>\n    )\n  );\n}\n```\n\n### 코드 설명\n\n| 항목          | 설명                                                                        |\n| ------------- | --------------------------------------------------------------------------- |\n| `size`        | 생성할 이미지 크기 설정 (픽셀 단위)                                         |\n| `contentType` | 이미지 포맷 (ex. 'image/png')                                               |\n| `Image` 함수  | 요청 파라미터로 슬러그를 받아 포스트 데이터 조회 후, 제목을 이미지로 렌더링 |\n\n### 더 알아두면 좋은 팁들\n\n- **CSS 스타일링 자유자재**  \n  위 예제에선 아주 간단하게 이미지를 그렸지만, `ImageResponse`로는 거의 대부분의 CSS 스타일을 적용할 수 있어요. 배경 색상, 폰트, 레이아웃, 심지어 그림자효과나 그라디언트도 가능하죠.\n\n- **더 정교한 디자인을 원한다면?**  \n  외부 폰트를 사용하거나 SVG 아이콘, 이미지 등을 조합하고 싶다면, `next/og`에서 지원하는 한도 내에서 최대한 활용해보세요. 단, 웹 폰트 로딩 시에는 약간의 설정이 필요할 수 있습니다.\n\n- **이미지 캐싱 고려하기**  \n  동적으로 이미지가 생성되다 보니, 잘못 설정하면 성능이나 비용 측면에서 문제가 될 수 있어요. Next.js의 Incremental Static Regeneration이나 Cache-Control 헤더 등을 적절히 활용해 캐싱 전략을 짜는 걸 추천합니다.\n\n이렇게 동적으로 생성하는 Open Graph 이미지로 SNS에 공유될 때 더 눈에 띄는 내 컨텐츠를 만들어 보세요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nImageResponse는 flexbox, 절대 위치 지정(absolute positioning), 커스텀 폰트, 텍스트 줄바꿈, 텍스트 중앙 정렬, 중첩 이미지 같은 일반적인 CSS 속성을 지원해요. 어떤 CSS 속성들이 지원되는지 전체 목록도 확인할 수 있으니 필요할 때 참고하면 좋습니다.\n\n> 참고할 점:\n> Vercel OG Playground에서 다양한 예제를 직접 확인해볼 수 있어요.\n\n내부적으로 ImageResponse는 @vercel/og, Satori, 그리고 Resvg 라이브러리를 사용해서 HTML과 CSS를 PNG 이미지로 변환합니다. 다만, flexbox와 일부 CSS 속성만 지원하기 때문에 display: grid 같은 고급 레이아웃은 작동하지 않는다는 점 기억하세요.\n\n쉽게 말해, 복잡한 레이아웃보다는 깔끔하게 정리된 flexbox 기반 레이아웃에 더 적합하다고 보면 됩니다. 만약 이미지 생성에 관심 있다면 Vercel OG Playground에서 실습해보며 감을 잡는 걸 추천해요!\n","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":15},{"title":"TypeScript와 ReactJS에서 에러 처리하는 5가지 방법","description":"","date":"2025-04-22 01:16","slug":"2025-04-22-Howtohandleerrors","content":"\n# 에러 처리하는 법\n\n에러는 크게 두 가지로 나눌 수 있어요: 예상 가능한 에러와 잡히지 않은 예외(uncaught exceptions)죠. 이번 글에서는 Next.js 앱에서 이런 에러들을 어떻게 다룰 수 있는지 쉽게 알려드릴게요.\n\n## 예상 가능한 에러 처리하기\n\n예상 가능한 에러는 앱이 정상적으로 작동하는 중에 발생할 수 있는 에러예요. 예를 들어 서버 쪽 폼 검증에서 실패할 때나, API 요청이 실패하는 경우죠. 이런 에러들은 명확하게 처리해서 클라이언트한테 적절하게 전달해줘야 해요.\n\n사실 이런 에러들은 사용자 경험에도 영향을 많이 주기 때문에, 단순히 ‘문제가 발생했습니다’라고 하는 것보단, 어떤 문제가 있는지 구체적으로 알려주는 게 중요해요. 예를 들어, 폼에서 이메일 형식이 맞지 않으면 \"이메일 형식이 올바르지 않습니다\"라고 바로 알려주면 사용자가 수정할 수 있잖아요?\n\nNext.js에서는 서버 사이드 코드에서 이런 에러들을 try-catch 문으로 잡아서, 적절한 HTTP 상태 코드와 메시지로 응답을 줄 수 있어요. 클라이언트 쪽에서는 그 응답을 받아서 UI에 에러 메시지를 띄우거나, 특정 행동을 유도하도록 하면 됩니다.\n\n혹시 에러를 다루는 게 처음이라면, ‘에러 핸들링 레이어’를 따로 만들어서 코드를 깔끔하게 관리하는 것도 추천해요. 그래야 에러 처리 로직이 여러 군데 흩어지지 않고, 수정도 편리해요.\n\n다음에는 잡히지 않은 예외, 즉 예기치 않은 오류가 발생했을 때 어떻게 대처하는지도 알려드릴게요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 서버 함수에서 예상 에러 처리하기\n\n서버 함수(Server Functions)를 작성할 때, 예상되는 에러를 다루는 방법에 대해 이야기해볼게요. 보통 자바스크립트에서 에러가 발생하면 try/catch로 잡거나 `throw`를 해서 에러를 던지죠? 그런데 서버 함수에서는 이런 방식보다는 **예상 가능한 에러를 반환값(return value)**으로 모델링하는 게 좋아요.\n\n예를 들어, 아래와 같이 `createPost`라는 서버 함수를 만들었을 때, API 호출이 실패하는 경우를 생각해볼게요.\n\n```js\n\"use server\";\n\nexport async function createPost(prevState: any, formData: FormData) {\n  const title = formData.get(\"title\");\n  const content = formData.get(\"content\");\n\n  const res = await fetch(\"https://api.vercel.app/posts\", {\n    method: \"POST\",\n    body: { title, content },\n  });\n  const json = await res.json();\n\n  if (!res.ok) {\n    return { message: \"Failed to create post\" };\n  }\n}\n```\n\n여기서 실패하면 그냥 `throw` 대신 `{ message: 'Failed to create post' }`라는 객체를 반환하고 있죠? 이렇게 하면 클라이언트 쪽에서 이 반환값을 이용해 에러 메시지를 쉽게 표시할 수 있어요.\n\n#### 팁!\n\n- 서버에서 에러를 `throw`하면 클라이언트 입장에선 뭘 잘못했는지 알기 어려울 수 있어요. 그래서 예상 가능한 에러들은 명확하게 데이터로 내려주는 게 UX에도 더 좋아요.\n- 반대로, 정말 예상하지 못한 시스템 에러는 그대로 `throw`해서 호출 스택에서 잡히게 하는 게 관리하기 편합니다.\n- 그리고, `useActionState` 훅을 사용하면 이런 반환값을 쉽게 받아서 처리할 수 있으니 한번 써보세요!\n\n이런 스타일은 점점 더 많은 React 서버 컴포넌트 기반 환경에서 권장되는 패턴이니, 앞으로 서버 함수 작성할 때 참고하면 좋아요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이번 시간에는 React의 `useActionState` 훅을 이용해서 폼 제출 시 발생할 수 있는 에러 메시지를 화면에 표시하는 방법을 함께 알아보겠습니다.\n\n기본적으로 `useActionState`는 액션(action)의 상태를 추적할 수 있도록 도와줘서, 성공 여부나 에러 발생 시 상태를 쉽게 관리할 수 있답니다.\n\n---\n\n## 예제 코드 살펴보기\n\n```jsx\n\"use client\";\n\nimport { useActionState } from \"react\";\nimport { createPost } from \"@/app/actions\";\n\nconst initialState = {\n  message: \"\",\n};\n\nexport function Form() {\n  // useActionState 훅 호출, createPost 액션을 인자로 전달\n  const { state, pending } = useActionState(createPost);\n\n  return (\n    <form action={createPost}>\n      <label htmlFor=\"title\">Title</label>\n      <input type=\"text\" id=\"title\" name=\"title\" required />\n\n      <label htmlFor=\"content\">Content</label>\n      <textarea id=\"content\" name=\"content\" required />\n\n      <button disabled={pending}>Create Post</button>\n\n      {/* 에러 메시지가 있다면 화면에 표시 */}\n      {state?.message && <p style={{ color: \"red\" }}>{state.message}</p>}\n    </form>\n  );\n}\n```\n\n- `useActionState(createPost)`를 호출하면 액션의 현재 상태(`state`)와 제출 진행 중 여부(`pending`)를 반환해줍니다.\n- `state.message`에 에러 메시지가 담겨 있다면, 이를 사용자에게 보여줄 수 있죠.\n- `button`은 제출하는 동안 중복 전송을 방지하기 위해 `disabled` 처리됩니다.\n\n---\n\n## Server Component에서 에러 핸들링\n\n서버 컴포넌트에서 데이터를 불러올 때도 에러 처리는 중요하죠! 거기서는 서버에서 받은 응답을 활용해 조건부 렌더링을 하거나, 필요시 리다이렉션을 할 수 있습니다.\n\n예를 들어:\n\n```jsx\nexport default async function Page() {\n  try {\n    const data = await fetchData(); // 서버에서 데이터 가져오기\n    return <DisplayData data={data} />;\n  } catch (error) {\n    // 에러 발생 시 에러 메시지 또는 리다이렉션 처리\n    return <p>데이터를 불러오는 중 오류가 발생했습니다.</p>;\n  }\n}\n```\n\n이처럼 서버 컴포넌트 내부에서 `try-catch` 문으로 에러를 잡아서 사용자에게 피드백을 줄 수 있습니다.\n\n---\n\n## 정리하자면\n\n- **useActionState** 훅을 활용하면 클라이언트 컴포넌트 내에서 액션 상태를 쉽게 관리하고, 에러 메시지를 화면에 표시할 수 있습니다.\n- 제출 버튼에 진행 상태를 반영해 사용자 경험도 개선할 수 있죠.\n- **서버 컴포넌트**에서는 데이터를 비동기로 가져올 때 에러를 잡아서 적절히 처리해야 하며, 이때 사용자에게 친절하게 에러를 알리는 UI를 만드는 게 중요합니다.\n\n---\n\n혹시 더 자세한 액션 상태 관리나 서버-클라이언트 간 에러 핸들링에 관해 궁금한 점이 있으면 언제든지 물어보세요! 여러분이 더 쉽게 React와 Next.js를 활용할 수 있도록 돕겠습니다 :)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n자, 이번에는 Next.js에서 데이터를 가져오고, 만약 데이터가 없다면 404 페이지를 띄우는 방법에 대해 이야기해볼게요.\n\n먼저, fetch API를 사용해서 데이터를 비동기로 가져오는 기본 예제부터 봅시다.\n\n```js\nexport default async function Page() {\n  const res = await fetch(`https://...`);\n  const data = await res.json();\n\n  if (!res.ok) {\n    return \"There was an error.\"; // 에러 발생 시 간단한 메시지 반환\n  }\n\n  return \"...\"; // 데이터를 성공적으로 받아오면 원하는 UI 반환\n}\n```\n\n여기서 핵심은 서버 API를 호출하고, 응답이 제대로 오지 않으면 에러 메시지를 보여주는 거예요. 그런데, 만약 해당 페이지나 데이터가 없을 때는 ‘404 페이지’를 보여주는 방법도 필요하겠죠?\n\nNext.js에서는 `notFound()` 함수를 이용해서 이런 상황을 처리할 수 있어요. 예를 들어, 블로그 포스트를 주소로 찾는 상황을 가정해보죠.\n\n```js\nimport { notFound } from \"next/navigation\";\nimport { getPostBySlug } from \"@/lib/posts\";\n\nexport default async function Page({ params }: { params: { slug: string } }) {\n  const { slug } = params;\n  const post = getPostBySlug(slug);\n\n  if (!post) {\n    notFound(); // 데이터가 없으면 404 페이지로 이동\n  }\n\n  return <div>{post.title}</div>; // 포스트 타이틀 출력\n}\n```\n\n여기서 중요한 점 몇 가지 짚고 넘어가면:\n\n| 항목            | 설명                                                                                                                                         |\n| --------------- | -------------------------------------------------------------------------------------------------------------------------------------------- |\n| `notFound()`    | Next.js가 제공하는 내장 함수로, 호출 시 해당 페이지 대신 404 UI를 보여줘요. 그냥 반환하는 게 아니라 실제로 404 상태로 페이지가 렌더링됩니다. |\n| `getPostBySlug` | 여긴 예시로 작성한 함수인데, 실제로는 슬러그(게시물 주소)를 기준으로 데이터를 찾아오는 로직입니다. 만약 없으면 `undefined` 혹은 `null` 반환  |\n| `params`        | 동적 라우팅에서 URL 파라미터를 받을 때 사용해요. 예를 들어 `/posts/hello-world` 라면 slug는 `hello-world` 가 되겠죠                          |\n\n추가로, `not-found.js` 또는 `not-found.tsx` 파일을 프로젝트에 만들어서 404 페이지의 UI를 커스터마이징 할 수도 있어요.\n\n```jsx\nexport default function NotFound() {\n  return (\n    <div>\n      <h1>페이지를 찾을 수 없어요 ㅠㅠ</h1>\n      <p>요청하신 페이지가 존재하지 않거나 삭제되었습니다.</p>\n    </div>\n  );\n}\n```\n\n이렇게 하면 프로젝트 전반에서 공통으로 쓰이는 404 페이지가 알아서 뜹니다.\n\n정리해보면, 데이터가 없거나 잘못된 URL을 요청했을 때 사용자에게 잘못된 접근임을 알려주는 방법으로 `notFound()` 호출과 맞춤형 404 페이지를 함께 사용하면 훨씬 깔끔한 사용자 경험을 만들 수 있다는 점! 꼭 기억하세요~\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```jsx\nexport default function NotFound() {\n  return <div>404 - Page Not Found</div>;\n}\n```\n\n## 처리하지 않은 예외(uncaught exceptions) 다루기\n\n처리하지 않은 예외란, 애플리케이션의 정상적인 흐름에서는 발생하지 말아야 할 예상치 못한 오류를 뜻해요. 이런 예외들은 보통 에러를 던져서(error throwing) 처리하는데, 이 에러를 '에러 바운더리(Error Boundary)'에서 잡아내서 적절히 대응해주는 방식이 일반적입니다.\n\n에러 바운더리는 리액트 컴포넌트에서 흔히 사용되는데, UI가 깨지지 않고 사용자에게 친절한 에러 메시지를 보여주거나, 로그를 남기거나, 대체 UI로 전환하는 데 활용할 수 있답니다.\n\n### 중첩된 에러 바운더리(Nested error boundaries)\n\n에러 바운더리를 한 군데만 두는 것보다, 애플리케이션 구조에 따라 여러 단계로 중첩시켜서 중요한 UI 부분별로 별도의 에러 처리 영역을 만드는 게 좋아요. 예를 들어, 페이지 전체를 감싸는 바운더리가 있고, 그 안에 각각의 위젯이나 컴포넌트 단위로 또 다른 바운더리가 존재하면, 특정 위젯에서 문제가 생겨도 페이지 전체가 깨지지 않고 해당 위젯 부분만 에러 UI로 교체할 수 있거든요.\n\n이렇게 하면 사용자 경험도 개선되고, 디버깅할 때도 어떤 컴포넌트에서 문제가 발생했는지를 좀 더 명확히 파악할 수 있습니다.\n\n---\n\n참고로, 리액트에서 에러 바운더리를 구현할 때는 다음과 같은 라이프사이클 메서드를 활용해요:\n\n- `static getDerivedStateFromError(error)`: 에러가 발생했을 때 상태를 업데이트하여 대체 UI를 렌더할 준비를 함\n- `componentDidCatch(error, info)`: 에러 로깅 등 부가 작업 수행\n\n그리고 함수형 컴포넌트만 쓴다면 `Error Boundary`는 아직 클래스 컴포넌트로 작성해야 한다는 점 기억하세요!  \n리액트가 앞으로 훅 기반 에러 바운더리를 지원하면 훨씬 편리해지겠죠?\n\n필요하면 에러 바운더리 예제도 공유해 드릴게요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서는 에러 바운더리(Error Boundaries)를 이용해 예기치 못한 에러를 잡아냅니다. 에러 바운더리는 자식 컴포넌트에서 발생한 오류를 잡아내서, 부러진 컴포넌트 트리 대신에 대체 UI(일종의 에러 화면)를 보여주게 해주죠.\n\n이걸 구현하려면, 라우트 세그먼트(route segment) 안에 `error.js` 파일을 만들고 React 컴포넌트를 내보내면 됩니다. 예시는 아래와 같아요:\n\n```js\n'use client' // 에러 바운더리는 클라이언트 컴포넌트여야 합니다\n\nimport { useEffect } from 'react'\n\nexport default function Error({\n  error,\n  reset,\n}: {\n  error: Error & { digest?: string }\n  reset: () => void\n}) {\n  useEffect(() => {\n    // 에러 리포팅 서비스에 로그를 보낸다고 생각해보세요\n    console.error(error)\n  }, [error])\n\n  return (\n    <div>\n      <h2>문제가 발생했어요!</h2>\n      <button\n        onClick={\n          // 다시 렌더링 시도해서 복구를 노립니다\n          () => reset()\n        }\n      >\n        다시 시도\n      </button>\n    </div>\n  )\n}\n```\n\n여기서 핵심은 `reset` 함수예요. 이 버튼을 누르면 해당 세그먼트를 다시 렌더링하면서 문제가 해결됐는지 재시도합니다.\n\n그리고 재미있는 점! 에러는 가장 가까운 상위 에러 바운더리로 올라가서 처리돼요. 덕분에, 라우트 트리 계층별로 `error.js`를 여러 개 둬서 세밀하게 에러 처리를 할 수 있습니다. 예를 들어, 특정 페이지에서만 보여줄 맞춤형 에러 화면도 가능하다는 뜻이죠.\n\n---\n\n추가로 알려드리자면, Next.js에서는 페이지나 레이아웃 단위로 에러를 다룰 수 있어서 사용자 경험을 더 세련되게 만드는 데 큰 도움이 됩니당. 단, 에러 바운더리는 무조건 클라이언트 컴포넌트여야 하는 점은 꼭 기억해주세요!\n\n꼭 한 가지 깜빡하지 말아야 할 팁은, 에러 바운더리 안에서도 에러는 다시 던져지지 않으니, 중요한 로그나 오류 추적(예: Sentry 같은 도구 활용)은 `useEffect` 같은 곳에서 해주는 게 베스트입니다.\n\n필요할 때마다 `error.js` 만들어서 우아한 에러 처리를 해보세요! 사용자도, 개발자도 모두 행복해질 거예요 :)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/TIL/assets/img/2025-04-22-Howtohandleerrors_0.png\" />\n\n### 전역 에러 처리하기 (Global errors)\n\n에러 처리하면 보통 각 컴포넌트 단위에서 하게 되지만, root 레이아웃 단계에서 전역적으로 에러를 잡고 싶을 때가 있어요. 이런 경우에는 `app` 루트 디렉터리에 `global-error.js` 파일을 만들어서 처리할 수 있습니다. 특히 다국어 지원 같은 국제화(i18n)를 적용해도 똑같이 쓸 수 있다는 점도 참고하세요.\n\n이 전역 에러 UI 컴포넌트는 root 레이아웃이나 템플릿을 완전히 대체하는 역할을 하기 때문에, 직접 `html`과 `body` 태그를 포함해야 해요. 없으면 브라우저가 제대로 렌더링하지 않기 때문에 꼭 넣어줘야 합니다.\n\n```js\n'use client' // 에러 바운더리는 클라이언트 컴포넌트여야 합니다\n\nexport default function GlobalError({\n  error,\n  reset,\n}: {\n  error: Error & { digest?: string }\n  reset: () => void\n}) {\n  return (\n    <html>\n      <body>\n        <h2>문제가 발생했어요!</h2>\n        <button onClick={() => reset()}>다시 시도</button>\n      </body>\n    </html>\n  )\n}\n```\n\n### 핵심 포인트\n\n- `'use client'` 선언으로 클라이언트 컴포넌트로 만들어야 에러 경계(Error Boundaries)가 정상 동작해요.\n- 에러를 화면에 보여주고, 사용자가 다시 시도할 수 있도록 reset 함수도 전달받아 꼭 활용하세요.\n- 전역 에러 UI는 root 레이아웃을 완전히 대체하므로 `html, body` 태그를 반드시 포함!\n\n### 살짝 더!\n\n만약 이 전역 에러 화면에 스타일을 입히고 싶다면, 전역 CSS를 불러오거나 `style` 태그를 넣는 방법이 있어요. 그리고 모던 웹 앱에서는 에러가 발생했을 때 단순히 메시지 보여주는 것 말고, 사용자 피드백을 받아 서버로 리포트 하거나, 자동 리프레시 기능을 추가하는 것도 생각해볼 만합니다.\n\n즉, 전역 에러 처리는 앱 안정성을 향상시키는 훌륭한 도구니 적극 활용해보세요!\n","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":12},{"title":"nextjs 15 서버 컴포넌트에서 데이터 업데이트 하는 방법 ","description":"","date":"2025-04-22 01:15","slug":"2025-04-22-Howtoupdatedata","content":"\n\n# 데이터 업데이트하는 방법\n\nNext.js에서 데이터를 업데이트할 때는 React의 Server Functions를 활용할 수 있어요. 이번 글에서는 Server Functions를 어떻게 만들고, 호출하는지 쉽고 간단하게 살펴볼게요.\n\n## Server Functions 만들기\n\nServer Function은 `use server`라는 지시어(directive)를 사용해서 정의할 수 있어요. `async` 함수 맨 위에 `use server`를 적으면 그 함수가 Server Function으로 인식돼요. 또는 파일 맨 위에 `use server`를 적으면, 그 파일이 내보내는(export) 모든 함수들이 Server Function으로 동작하게 돼요.\n\n---\n\n> 예를 들어, 아래처럼 쓸 수 있습니다.\n\n```js\n'use server'\n\nexport async function updateData() {\n  // 서버에서 실행할 로직\n}\n```\n\n---\n\n이렇게 하면 프론트엔드에서 API를 호출하는 느낌 대신, 마치 서버 안에서 직접 호출하는 것처럼 데이터를 처리할 수 있어요. 서버에서 실행되기 때문에 보안이나 성능 측면에서도 이점이 크고, 코드도 깔끔해집니다.\n\n혹시 여기서 `use server`가 뭔지 궁금할 수도 있는데, 이건 Next.js 13 이후에 도입된 기능으로, React 컴포넌트 내에서 서버 전용 함수를 만드는데 사용하는 문법이에요. 쉽게 말해 서버에서만 실행되는 함수임을 표시하는 태그라고 생각하면 됩니다.\n\n다음엔 이 Server Function을 실제 컴포넌트에서 어떻게 호출하는지도 보여드릴게요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이번 글에서는 Next.js 13부터 새롭게 도입된 Server Actions, 즉 서버에서 직접 실행되는 함수 작성법에 대해 살펴볼게요. 특히, Server Functions를 어떻게 작성하고, 이걸 Server Component 안에 어떻게 쉽게 넣을 수 있는지 가볍게 정리해봤습니다.\n\n---\n\n### Server Functions 기본 작성법\n\n예를 들어, 게시글을 생성하거나 삭제하는 함수를 작성할 때 아래처럼 `FormData`를 받아서 처리할 수 있어요.\n\n```js\nexport async function createPost(formData: FormData) {\n  'use server'   // 여기가 포인트! 이 지시어로 서버에서 실행됨을 명시\n  const title = formData.get('title')\n  const content = formData.get('content')\n\n  // 여기서 데이터베이스에 글 저장하거나,\n  // 혹은 캐시를 재검증(revalidate)하는 작업을 할 수 있죠\n}\n\nexport async function deletePost(formData: FormData) {\n  'use server'\n  const id = formData.get('id')\n\n  // 삭제 처리 및 캐시 갱신\n}\n```\n\n`'use server'`를 함수 맨 위에 적으면, 이 함수가 클라이언트가 아닌 서버에서 실행될 함수임을 명확히 하게 됩니다. 이게 Next.js가 Server Actions를 인식하고 별도로 처리하게 만들어주죠.\n\n---\n\n### Server Functions를 Server Component 안에 작성하기\n\n서버 컴포넌트 내부에 이런 Server Action 함수를 바로 써도 OK인데요, 이런 식으로 함수 위에 `'use server'` 지시어를 붙이면 됩니다.\n\n```js\nexport default function Page() {\n  // 서버에서 실행될 함수 (Server Action)\n  async function createPost(formData: FormData) {\n    'use server'\n    // ...게시글 생성 로직\n  }\n\n  return <></>\n}\n```\n\n이렇게 하면 해당 함수를 컴포넌트 바깥으로 따로 빼지 않아도 되고, 컴포넌트와 함수의 관계를 내비치기 좋아요.\n\n---\n\n### 알아두면 좋은 팁\n\n- Server Actions로 넘겨받는 `formData`는 `<form>`에서 전송한 데이터를 쉽게 받아서 쓸 수 있어서, API 엔드포인트 없이도 폼 제출을 깔끔하게 처리할 수 있어요.\n- 서버 함수는 클라이언트 코드에 포함되지 않으니, 보안상 민감한 작업을 하기에 좋아요.\n- 데이터 변경 후에는 꼭 필요한 경우 `revalidatePath()` 같은 Next.js의 캐시 재검증 함수를 호출해 UI에 최신 상태가 반영되게 만들어야 해요.\n\n---\n\n다음 포스팅에서는 Server Actions를 실제 폼과 연동해서 구현하는 간단한 예시도 준비해볼게요. 서버와 클라이언트 경계를 넘나드는 작업이 점점 더 좋아지고 있어 기대해 주세요! 😊\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 클라이언트 컴포넌트(Client Components)\n\n서버 함수(Server Functions)는 클라이언트 컴포넌트 안에서 직접 정의할 수는 없어요. 하지만 서버 함수가 담긴 파일에 `'use server'`라는 지시어를 맨 위에 붙여서 내보내면, 클라이언트 컴포넌트에서 이 함수를 불러와서 실행할 수 있답니다!\n\n예를 들어, 이런 식으로 서버 함수가 정의되어 있어요:\n\n```js\n'use server'\n\nexport async function createPost() {\n  // 서버에서 처리할 로직\n}\n```\n\n그리고 클라이언트 컴포넌트에서는 이렇게 import해서 사용할 수 있죠:\n\n```js\n'use client'\n\nimport { createPost } from '@/app/actions'\n\nexport function Button() {\n  return <button formAction={createPost}>Create</button>\n}\n```\n\n여기서 핵심은, `createPost` 같은 함수는 실제로는 서버에서 작동하지만, 클라이언트 컴포넌트가 그 함수를 호출하는 이벤트를 연결해준다는 점이에요. 덕분에 UI는 클라이언트에서 매끄럽게 돌아가면서도, 중요한 데이터 처리나 DB 작업 등은 안전하게 서버에서 수행할 수 있죠.\n\n추가로 알아두면 좋은 점!\n- `'use server'` 디렉티브가 있는 파일은 Next.js가 서버 전용이라는 걸 인지해서 클라이언트 번들에서 제외해줘서 코드가 더 깔끔해져요.\n- `formAction` prop을 사용하면 폼 제출 시 서버 함수를 바로 트리거할 수 있어서 React의 상태 관리 없이도 서버와 통신하기 편해요.\n- 이렇게 Server Function을 클라이언트 컴포넌트에서 활용하면, 복잡한 API 라우트 없이도 양방향 데이터 흐름을 간단히 구현할 수 있습니다.\n\n이 방식 덕분에 Next.js에서 서버/클라이언트 코드 구분이 더 명확하고, 개발자는 로직을 더 효율적으로 나눌 수 있답니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 서버 함수 호출하기\n\n서버 함수를 호출하는 방법은 크게 두 가지가 있어요:\n\n- 서버 컴포넌트와 클라이언트 컴포넌트에서의 폼(form) 사용\n- 클라이언트 컴포넌트에서 이벤트 핸들러 사용\n\n### 폼(Form)이용하기\n\n폼 태그는 HTML에서 서버와 데이터를 주고받을 때 가장 기본적인 방법 중 하나인데요, Next.js 같은 프레임워크에서 서버 컴포넌트나 클라이언트 컴포넌트 내에서 쉽게 사용할 수 있어요. 폼이 제출되면 지정한 서버 함수가 호출되고, 그 서버 함수 안에서 데이터를 처리할 수 있죠.\n\n예를 들어, 간단한 로그인 폼을 만들어 서버 함수로 데이터를 보내는 경우를 생각해보면 이해가 쉬워요. 폼 안에 input 필드를 넣고, submit 버튼을 누르면 서버 함수가 자동으로 실행되는 거죠.\n\n또한, 요즘은 fetch API나 axios 같은 클라이언트 사이드 호출 방식을 많이 쓰긴 하지만, 폼을 이용한 방법은 여전히 직관적이고 간단하게 서버에 데이터를 보내는 좋은 방법이에요. 특히 서버 컴포넌트가 지원되는 환경에서는 폼을 통해 자연스럽게 서버 함수를 호출할 수 있다는 점 꼭 기억하세요!\n\n필요하면 다음에 폼 예제 코드를 공유할게요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nReact에서 `form` 태그를 확장해서 Server Function을 HTML `action` 속성으로 바로 호출할 수 있다는 사실, 알고 계셨나요?\n\n보통 우리가 폼을 제출할 때는 프론트엔드에서 이벤트 핸들러를 따로 만들어서 처리하곤 하죠. 하지만 React에서는 폼의 `action` 속성에 서버에서 실행할 함수를 직접 연결할 수 있어요. 이 함수는 폼 제출 시 자동으로 `FormData` 객체를 받아서 안에 담긴 값들을 쉽게 꺼내 쓸 수 있답니다.\n\n예를 들어, 아래처럼 `createPost`라는 서버 함수를 `action`에 할당하면, 폼이 제출될 때 자동으로 `createPost`가 호출되면서 제출한 데이터가 `FormData` 형태로 전달돼요.\n\n```jsx\nimport { createPost } from '@/app/actions'\n\nexport function Form() {\n  return (\n    <form action={createPost}>\n      <input type=\"text\" name=\"title\" />\n      <input type=\"text\" name=\"content\" />\n      <button type=\"submit\">Create</button>\n    </form>\n  )\n}\n```\n\n서버 함수는 이렇게 작성할 수 있습니다:\n\n```js\n'use server'\n\nexport async function createPost(formData: FormData) {\n  const title = formData.get('title')\n  const content = formData.get('content')\n\n  // 여기서 DB에 저장하거나, 캐시를 재검증하는 작업을 할 수 있어요.\n}\n```\n\n### 조금 더 알아두면 좋은 팁!\n\n- `FormData.get()` 메서드는 반환값이 `FormDataEntryValue | null`이기 때문에, 실제 값이 문자열인지 확인하거나 기본값을 설정하는 게 좋습니다.\n- 서버 함수 내에서는 서버 전용 코드(ex. 데이터베이스 쿼리, 파일 시스템 접근)를 자유롭게 사용할 수 있어요.\n- 클라이언트에서 별도의 API 호출 없이도 서버로 데이터를 보낼 수 있어서 코드가 더 깔끔해지고 유지보수가 쉬워집니다.\n- 물론, 복잡한 폼 유효성 검사나 사용자가 바로 피드백을 받아야 하는 경우엔 클라이언트 측에서 미리 체크하는 걸 추천합니다.\n\n이 방식은 특히 Next.js 같은 React 기반 프레임워크에서 유용하게 쓰이는데요, 서버 함수와 폼을 연동하는 새로운 흐름을 경험해보고 싶다면 한 번 시도해보세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n> 참고할 점: action prop에 전달될 때 Server Functions는 Server Actions라고도 불러요.\n\n### 이벤트 핸들러(Event Handlers)\n\n클라이언트 컴포넌트에서 서버 기능(Server Function)을 호출할 때는 onClick 같은 이벤트 핸들러를 활용할 수 있어요. 예를 들어, 좋아요 버튼을 만들고 클릭할 때마다 서버에 좋아요 수를 업데이트하는 기능을 구현해볼게요.\n\n```jsx\n'use client'\n\nimport { incrementLike } from './actions'\nimport { useState } from 'react'\n\nexport default function LikeButton({ initialLikes }: { initialLikes: number }) {\n  const [likes, setLikes] = useState(initialLikes)\n\n  return (\n    <>\n      <p>Total Likes: {likes}</p>\n      <button\n        onClick={async () => {\n          // 서버에 좋아요 증가 요청을 보내고, 업데이트 된 좋아요 수를 받아서 상태를 갱신해요\n          const updatedLikes = await incrementLike()\n          setLikes(updatedLikes)\n        }}\n      >\n        Like\n      </button>\n    </>\n  )\n}\n```\n\n여기서 중요한 점은, 클라이언트 컴포넌트 내부에서 직접 서버 사이드 코드를 호출할 수 없기 때문에, `incrementLike` 같은 서버 기능을 `actions`라는 별도의 파일에서 정의해두고 import해서 사용한다는 거예요. 그리고 비동기 처리를 위해 `async/await`를 활용한 점도 기억해두면 좋아요.\n\n또한, 이렇게 서버 함수 호출 시 상태를 업데이트하는 패턴은 사용자 인터랙션에 실시간 피드백을 주는 데 아주 유용합니다. 만약 서버 함수 호출 중에 로딩 상태 표시가 필요하다면, `useState`로 로딩 상태를 관리해서 버튼을 비활성화하거나 스피너를 보여주는 것도 좋은 UX를 위한 팁이에요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 예시\n\n### 대기 상태 표시하기\n\n서버 함수를 실행하는 동안, React의 `useActionState` 훅을 사용해서 로딩 인디케이터를 보여줄 수 있어요. 이 훅은 `pending`이라는 불리언 값을 반환하는데, 이 값이 `true`일 때는 작업이 진행 중임을 뜻하죠.\n\n예를 들어, 게시글 생성 버튼을 눌렀을 때 로딩 스피너를 보여주는 컴포넌트 코드는 아래와 같습니다:\n\n```js\n'use client'\n\nimport { useActionState } from 'react'\nimport { createPost } from '@/app/actions'\nimport { LoadingSpinner } from '@/app/ui/loading-spinner'\n\nexport function Button() {\n  const [state, action, pending] = useActionState(createPost, false)\n\n  return (\n    <button onClick={async () => action()}>\n      {pending ? <LoadingSpinner /> : 'Create Post'}\n    </button>\n  )\n}\n```\n\n여기서 중요한 점은 `pending` 값 덕분에 사용자에게 작업이 진행 중이라는 피드백을 줄 수 있다는 거예요. 보통 서버와의 통신이 느릴 때는 이렇게 대기 상태를 표시해주는 게 UX 측면에서 정말 중요하답니다.\n\n또 한 가지 팁을 드리자면, 이 훅은 작업이 끝난 후 결과값이나 에러 상태도 함께 관리할 수 있어서, 로딩뿐만 아니라 성공, 실패 상태에 따른 UI 업데이트도 함께 처리할 수 있어요. 필요에 따라 `state`를 활용해보세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 캐시 재검증하기\n\n데이터를 업데이트한 뒤, Next.js 캐시를 재검증(revalidate)해서 최신 데이터를 보여주고 싶을 때가 있죠? 그럴 땐 Server Function 내부에서 `revalidatePath`나 `revalidateTag` 함수를 사용하면 간편하게 해결할 수 있어요.\n\n```js\nimport { revalidatePath } from 'next/cache'\n\nexport async function createPost(formData: FormData) {\n  'use server'\n  \n  // 데이터 업데이트 작업 수행\n  // ...\n  \n  // 특정 경로에 대한 캐시를 재검증해서 최신 데이터 반영\n  revalidatePath('/posts')\n}\n```\n\n위 예제처럼, 글을 새로 만들거나 수정한 뒤 `/posts` 경로의 캐시를 재검증하면 사용자에게 항상 최신 게시물 목록을 보여줄 수 있답니다.\n\n> 추가 팁!  \n> 비슷하게 `revalidateTag`를 사용하면 태그 단위로 캐시를 재검증할 수도 있는데, 이 방법은 특정 데이터 그룹을 관리할 때 유용해요. 상황에 맞게 선택해서 사용해보세요.\n\n### 리다이렉트하기\n\n서버 함수에서 작업을 마친 후 사용자를 다른 페이지로 이동시키고 싶을 때는 어떻게 할까요? Next.js에서는 `redirect` 함수를 활용하면 쉽게 처리할 수 있답니다.\n\n예를 들어, 글 작성 후 게시물 목록 페이지로 이동시키고 싶을 때:\n\n```js\nimport { redirect } from 'next/navigation'\n\nexport async function createPost(formData: FormData) {\n  'use server'\n  \n  // 데이터 생성 로직\n  // ...\n  \n  // 작업 후 /posts 페이지로 리다이렉트\n  redirect('/posts')\n}\n```\n\n`redirect` 함수를 호출하면, 클라이언트가 자동으로 지정한 경로로 이동하게 됩니다. 이 방법 덕분에 별도의 클라이언트 사이드 코드 없이도 깔끔한 흐름 제어가 가능해요.\n\n---\n\n이처럼 Next.js의 Server Function 내에서 캐시 재검증과 리다이렉트를 함께 활용하면, 데이터 일관성을 유지하면서 사용자 경험도 한층 좋아지니 꼭 알아두세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n업데이트 작업을 수행한 후에 사용자를 다른 페이지로 이동시키고 싶을 때가 있죠? 그럴 때는 Next.js의 Server Function 안에서 `redirect` 함수를 사용할 수 있어요.\n\n아래 예시 코드를 한 번 볼게요!\n\n```js\n'use server'\n\nimport { redirect } from 'next/navigation'\n\nexport async function createPost(formData: FormData) {\n  // 데이터 업데이트 작업 수행\n  // ...\n  \n  // 업데이트 후 /posts 페이지로 리디렉션\n  redirect('/posts')\n}\n```\n\n여기서 포인트는, `redirect`가 호출되면 그 즉시 클라이언트에게 지정한 URL로 이동하라고 지시한다는 점이에요. 그래서 서버 함수 내에서 업데이트가 끝난 뒤에 자연스럽게 다른 페이지로 사용자를 안내할 수 있죠.\n\n또 한 가지 팁! `redirect`를 사용할 때, 이 함수는 호출과 동시에 훅을 멈추고 이동을 처리하기 때문에 그 이후 코드는 실행되지 않는다는 점 기억해주세요. 만약 안전하게 특정 조건에서만 리디렉션을 하고 싶다면, 조건문 안에 넣어서 사용하면 돼요.\n\n요약하자면, Next.js 13 이상의 서버 함수에서 업데이트 후 바로 페이지 전환을 원할 땐 `redirect`를 활용해보세요. 페이지 새로고침 없이 부드럽게 이동할 수 있어서 사용자 경험도 좋아진답니다!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":12}],"page":"6","totalPageCount":41,"totalPageGroupCount":3,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}