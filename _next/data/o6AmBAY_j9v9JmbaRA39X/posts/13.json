{"pageProps":{"posts":[{"title":"이미지 분할의 혁명 U-Net 아키텍처 탐구","description":"","date":"2024-07-14 19:55","slug":"2024-07-14-TheRevolutionofImageSegmentationExploringU-NetArchitecture","content":"\n\n# 요약\n\n배경: 이미지 세그멘테이션은 특히 생체 의료 이미징 분야에서 정확성과 효율성을 요구하여 정밀한 분석이 필요합니다. Olaf Ronneberger 등에 의해 소개된 U-Net 아키텍처는 이러한 작업에 대한 중요한 해결책으로 부상하였습니다.\n\n문제: 기존 이미지 세그멘테이션 기술은 고해상도 공간 세부 정보와 맥락적 이해 사이의 균형을 맞추는 데 도움이 필요하여 세그멘테이션 성능이 최적화되지 않을 수 있습니다.\n\n접근 방식: 본 글에서는 합성 데이터셋을 활용한 U-Net 아키텍처의 구현을 탐구합니다. 특성 엔지니어링, 하이퍼파라미터 튜닝, 교차 검증을 포함한 포괄적인 프로세스를 통해 모델을 교육 및 평가합니다. U-Net 모델의 성능은 표준 메트릭과 시각화를 사용하여 평가됩니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n결과: U-Net 모델은 합성 데이터셋에서 높은 정확도(99.03%), 정밀도(99.07%), 재현율(98.99%), 그리고 F1 점수(99.03%)를 달성했습니다. 손실 및 정확도 플롯은 효과적인 학습과 과적합이 적음을 시사하며, 실제 및 예측된 마스크의 시각적 비교는 모델의 분할 능력을 보여줍니다.\n\n결론: U-Net 아키텍처는 이미지 분할 작업에 매우 효과적이며, 우수한 성능 지표와 시각적 결과를 달성합니다. 고해상도 공간 세부 정보를 맥락적 이해와 결합할 수 있는 능력은 특히 생체 의료 이미지 분석과 같이 정밀한 이미지 분석이 필요한 분야에서 가치가 있습니다.\n\n키워드: U-Net 아키텍처; 이미지 분할; 생체 의료 이미징; 딥 러닝; 신경망.\n\n# 소개\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n의료 영상 이미지를 정밀하게 분석하여 이상을 식별하는 방사선 전문의로 상상해 보세요. 이 작업에는 예민한 시각과 몇 시간에 걸친 집중력이 필요합니다. 만약 이 프로세스를 자동화하여 작업량을 줄이고 정확성을 높일 방법이 있다면 어떨까요? U-Net [1]이 그 해결책으로 등장합니다. 이 건물주택은 의료 영상 분할에서 혁명을 일으킨 아키텍처의 놀라운 예다.\n\n![이미지](/TIL/assets/img/2024-07-14-TheRevolutionofImageSegmentationExploringU-NetArchitecture_0.png)\n\n# U-Net의 탄생\n\nU-Net은 2015년에 Olaf Ronneberger와 그 동료들에 의해 소개되었으며 주로 생체 의료 이미지 분할을 위해 설계되었습니다. U자 모양을 띤 이 아키텍처는 맥락을 포착하는 수축 경로와 정확한 지역화를 가능케 하는 대칭확장 경로로 구성되어 있습니다. 이 이중 경로 접근법은 특히 정확성이 중요한 분야에서 U-Net을 게임 체인저로 만들었습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 아키텍처 분석\n\n## 1. 인코더: 맥락 캡처\n\n인코더 또는 저차원화 경로는 3x3 콘볼루셔널 계층 두 개(패딩이 없는 콘볼루션)을 반복적으로 적용한 후 각각 ReLU 및 2x2 맥스 풀링 연산을 적용하여 다운샘플링하는 과정으로 구성됩니다. 이 경로는 이미지의 주요 특징을 캡처하면서 공간적인 차원을 줄여 입력 데이터의 맥락을 이해할 수 있도록 합니다.\n\n## 2. 병목 계층: 다리\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n네트워크의 핵심에서 병목 계층은 인코더와 디코더 사이의 다리 역할을 합니다. 이 계층은 데이터를 더 처리하며 분할에 중요한 가장 추상적인 특징을 포착하는 합성곱 계층으로 구성되어 있습니다.\n\n## 3. 디코더: 정확한 위치 지정\n\n디코더 또는 확장 경로는 특성 맵의 업샘플링을 수행한 후 2x2 컨볼루션(\"업-컨볼루션\")이 이어지는 반으로 특성 채널의 수를 절반으로 줄이는 작업을 수행합니다. 이 경로는 인코더에 의해 포착된 맥락을 수축 경로의 해당 계층에서의 고해상도 특징과 skip 연결을 통해 결합합니다. 이러한 skip 연결은 네트워크가 다운샘플링 중에 상실된 공간 정보를 보존하도록 도와주기 때문에 정확한 위치 지정을 보장합니다.\n\n## 4. 출력 계층: 분할 맵\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n최종 레이어는 각 피처 벡터를 원하는 클래스 수에 매핑하는 1x1 컨볼루션입니다. 일반적으로 이어서 소프트맥스 활성화 함수가 사용됩니다. 그 결과는 입력 이미지의 관심 영역을 강조하는 분할된 출력입니다.\n\n# 건너뛰기 연결의 힘\n\nU-Net의 가장 혁신적인 기능 중 하나는 건너뛰기 연결의 사용입니다. 이러한 연결은 인코더와 디코더 경로의 해당 레이어를 연결하여 네트워크가 일반적으로 대략적이고 추상적인 피처를 세밀하고 상세한 정보와 결합하도록 하는 데 기여합니다. 이 설계 선택은 U-Net이 상대적으로 작은 데이터셋에서 훈련되었을 때라도 높은 정확도를 달성하도록 허용하여 분할 작업에서 뛰어난 성능을 발휘하게 만듭니다.\n\n# 실제 응용 사례\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nU-Net이 처음에는 의료 이미지 분할을 위해 개발되었지만, 그 응용 분야는 훨씬 넓어집니다. 농업 분야에서는 위성 이미지를 분할하여 작물 건강을 모니터링하는 데 사용됩니다. 자율 주행에서는 U-Net이 도로 장면을 분할하여 차선, 차량 및 보행자를 식별하는 데 도움이 됩니다. U-Net의 다양성은 이미지 분할이 중요한 여러 영역에서 가치있는 도구로 만들어줍니다.\n\n# 실제 예시\n\n아래에는 합성 데이터셋에서 U-Net 아키텍처를 시연하는 완전한 코드 예시가 있습니다. 이 예시에는 특성 특성화, 특성 공학, 하이퍼파라미터 튜닝, 교차 검증, 예측, 평가 메트릭 및 결과 시각화가 포함되어 있습니다.\n\n```js\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn.model_selection import train_test_split, KFold\nfrom sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score\nimport tensorflow as tf\nfrom tensorflow.keras import layers, models as keras_models\nfrom tensorflow.keras.optimizers import Adam\n\n# 합성 데이터셋 생성\ndef create_synthetic_data(num_samples=1000, img_size=128):\n    X = np.random.rand(num_samples, img_size, img_size, 1)\n    Y = (X > 0.5).astype(np.float32)\n    return X, Y\n\nX, Y = create_synthetic_data()\n\n# 데이터 분할\nX_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2, random_state=42)\n\n# U-Net 모델\ndef unet_model(input_size=(128, 128, 1)):\n    inputs = layers.Input(input_size)\n\n    # 중략\n\n# 모델 컴파일 및 훈련\ndef compile_and_train_model(X_train, Y_train, X_val, Y_val, epochs=50, batch_size=32, learning_rate=1e-4):\n\n    # 중략\n\n# 하이퍼파라미터 튜닝 및 교차 검증\nkf = KFold(n_splits=5)\nhistories = []\ntrained_models = []\n\n# 중략\n\n# 테스트 세트에서 최종 모델 평가\nbest_model = trained_models[0]\n\n# 중략\n\n# 평가 메트릭\naccuracy = accuracy_score(Y_test.flatten(), test_predictions_binary.flatten())\nprecision = precision_score(Y_test.flatten(), test_predictions_binary.flatten())\nrecall = recall_score(Y_test.flatten(), test_predictions_binary.flatten())\nf1 = f1_score(Y_test.flatten(), test_predictions_binary.flatten())\n\nprint(f\"정확도: {accuracy:.4f}\")\nprint(f\"정밀도: {precision:.4f}\")\nprint(f\"재현율: {recall:.4f}\")\nprint(f\"F1 점수: {f1:.4f}\")\n\n# 훈련 이력 시각화\nplt.figure(figsize=(12, 4))\n\n# 중략\n\n# 예측 시각화\ndef visualize_predictions(X_test, Y_test, predictions, num_samples=5):\n    plt.figure(figsize=(15, 5))\n\n    # 중략\n\nvisualize_predictions(X_test, Y_test, test_predictions_binary)\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 코드 설명\n\n- 가상 데이터셋 생성: 무작위 이미지와 이에 대응하는 이진 마스크로 가상 데이터셋을 생성합니다.\n- 데이터 분할: 데이터셋을 학습 및 테스트 세트로 나눕니다.\n- U-Net 모델 정의: U-Net 아키텍처를 인코더, 병목, 디코더 블록으로 정의합니다.\n- 모델 컴파일 및 학습: 모델을 Adam 옵티마이저와 이진 크로스 엔트로피 손실 함수로 컴파일합니다. 학습 및 검증 데이터로 모델을 학습시킵니다.\n- 하이퍼파라미터 튜닝 및 교차 검증: K-Fold 교차 검증을 사용하여 여러 모델을 학습하고 학습 히스토리를 기록합니다. \n- 평가: 최적 모델을 정확도, 정밀도, 재현율 및 F1 점수를 사용하여 테스트 세트에서 평가합니다.\n- 학습 히스토리 그래프: 모델의 성능을 시각화하기 위해 학습과 검증 손실 및 정확도를 플롯합니다.\n- 예측 시각화: 테스트 세트에서 몇 가지 샘플을 시각화하여 입력 이미지, 실제 마스크 및 예측된 마스크를 비교합니다.\n\n이 코드는 가상 데이터셋을 사용하여 U-Net 모델을 구현하고 평가하는 포괄적인 예제를 제공하며, 모델 학습부터 성능 평가 및 시각화까지 모든 중요한 측면을 다룹니다.\n\n![이미지](/TIL/assets/img/2024-07-14-TheRevolutionofImageSegmentationExploringU-NetArchitecture_1.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nU-Net 모델이 합성 데이터 세트에서의 성능이 시각적 및 양적으로 평가되었습니다. 결과를 자세히 해석해 봅시다.\n\n## 손실 및 정확도 그래프\n\n손실 그래프\n\n- 훈련 손실 및 검증 손실: 둘 다 초기에 빠르게 감소한 후 낮은 값 주변에 안정화되며, 끝에 약간의 상승이 나타납니다. 훈련 및 검증 손실이 유사한 추세를 따르므로, 모델이 과적합이 없이 효과적으로 학습하고 있음을 나타냅니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n정확도 그래프\n\n- 훈련 정확도 및 검증 정확도: 두 정확도 지표 모두 빠르게 증가하고 약 0.99 정도에서 안정화됩니다. 훈련 및 검증 정확도 곡선의 밀접한 일치는 잘 일반화된 모델을 나타냅니다.\n\n## 성능 메트릭\n\n- 정확도: 0.9903: 모델이 픽셀 중 약 99.03%를 올바르게 식별합니다.\n- 정밀도: 0.9907: 마스크 일부로 예측된 픽셀 중 약 99.07%가 올바릅니다. 이 높은 정밀도는 모델이 거의 잘못된 양성 오류를 만들지 않음을 나타냅니다.\n- 재현율: 0.9899: 모델이 실제 마스크 픽셀 중 약 98.99%를 올바르게 식별합니다. 이 높은 재현율은 모델이 거의 잘못된 해로운 오류를 만들지 않음을 시사합니다.\n- F1 점수: 0.9903: 정밀도와 재현율의 조화 평균으로, 두 지표 사이의 견고한 균형을 나타냅니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 Markdown 형식으로 변환된 내용입니다.\n\n![예측 시각화](/TIL/assets/img/2024-07-14-TheRevolutionofImageSegmentationExploringU-NetArchitecture_2.png)\n\n## 예측 시각화\n\n- 입력 이미지, 실제 마스크, 예측된 마스크: 이 시각화는 입력 이미지와 이에 해당하는 실제 및 예측된 마스크를 보여줍니다. 예측된 마스크는 실제 마스크와 매우 유사하여, 합성 데이터셋을 분할하는 모델의 효과를 보여줍니다.\n\n## 해석\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nU-Net 모델은 합성 데이터셋에서 뛰어난 성능을 보여주었습니다. 높은 정확도, 정밀도, 재현율 및 F1 점수를 기록했죠. 훈련 및 검증 지표 간의 밀접한 일치는 모델이 잘 일반화되었고 균형있게 설정되었음을 시사합니다. 시각화 결과도 모델이 이미지를 정확하게 분할하고 실제 마스크와 근접하게 일치하는 것을 확인합니다.\n\n이 예시는 이미지 세그멘테이션 작업에 U-Net의 힘을 잘 보여줍니다. 높은 성능 지표와 정확한 분할을 시각적으로 확인함으로써, 심지어 합성 데이터셋에서도 U-Net의 효과를 명확히 확인할 수 있습니다. 이는 정밀한 세그멘테이션이 필요한 생체 의료 영상과 같은 분야에서 U-Net의 응용에 대한 신뢰감을 제공합니다.\n\n# 결론\n\nU-Net은 이미지 세그멘테이션 분야에서 새로운 표준을 세웠습니다. 복잡한 세부사항을 포착하고 정확한 지역화를 제공하는 능력은 다양한 산업에서 필수품이 되었습니다. 기술이 발전함에 따라 U-Net의 원칙은 더욱 정교한 아키텍처를 영감으로 삼아 이미지 분석의 가능성을 확장시킬 것으로 기대됩니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n정밀도가 모든 차이를 만들 수 있는 세상에서 혁신적인 신경망 설계의 힘을 증명하는 U-Net은 복잡한 분할 도전 과제에 접근하고 해결하는 방법을 변화시키고 있습니다.\n\nU-Net 아키텍처 탐험을 통해 유익한 정보를 얻으셨기를 바랍니다. U-Net 모델이 이미지 분할의 미래에 어떻게 영향을 미칠 것으로 보십니까? 아래 댓글란에 여러분의 생각과 경험을 공유해주세요! 만약 이 글이 마음에 들었다면 꼭 여러분의 네트워크와 공유하지 않으시기 바랍니다.\n\n# 참고문헌","ogImage":{"url":"/TIL/assets/img/2024-07-14-TheRevolutionofImageSegmentationExploringU-NetArchitecture_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-TheRevolutionofImageSegmentationExploringU-NetArchitecture_0.png","tag":["Tech"],"readingTime":11},{"title":"__init__py 파일 제대로 이해하고 사용하기","description":"","date":"2024-07-14 19:53","slug":"2024-07-14-CanYouEven__init__py","content":"\n\n다른 폴더에서 코드를 가져올 때 항상 빈 __init__.py 파일을 넣습니다. 이것은 대부분의 파이썬 개발자들에게 거의 반복적인 습관이 되었습니다 - 초보자든 마법사든. 그러나 우리는 __init__.py에 대해 정말로 알고 있을까요?\n\n이 블로그 포스트에서는 __init__.py가 어떻게 작동하는지와 비어있지 않은 __init__.py가 우리 파이썬 개발자로서 어떻게 도움이 되는지 세 가지 방법을 살펴보겠습니다.\n\n## __init__.py란 무엇인가요?\n\n__init__.py는 폴더를 패키지로 취급해야 한다는 것을 파이썬 해석기에 알려주는 파이썬 파일입니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n컴파일된 언어인 C 및 C++과 달리, Python의 인터프리터는 필요한 종속성을 실시간으로 가져옵니다. Python에게 코드를 다른 곳에서 사용할 것이라고 신호를 보내려면 폴더에 __init__.py를 넣으면 됩니다.\n\n그래서 __init__.py를 게이트키퍼로 생각해보세요. 이 파일은 폴더를 가져올 수 있는 Python 패키지로 변환시켜줍니다.\n\n![이미지](/TIL/assets/img/2024-07-14-CanYouEven__init__py_0.png)\n\n하지만 __init__.py는 그 이상입니다. Python에서 클래스를 만들 때 종종 __init__ 함수를 생성해야합니다. 이 함수는 객체가 어떻게 구성되어야 하는지를 정의하며 클래스의 객체가 생성될 때 가장 먼저 실행됩니다. 같은 방식으로, __init__.py는 Python 패키지의 생성자입니다. 패키지가 가져올 때마다 먼저 실행됩니다. 빈 __init__.py는 Python 패키지의 빈 __init__ 생성자 메서드를 의미합니다. 괜찮지만 더 많은 일을 할 수 없다는 뜻은 아닙니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## __init__.py 주의해서 사용하기\n\n__init__.py는 파이썬 패키지의 생성자이므로, __init__.py를 어디에 두는지에 대해 신중해야 합니다.\n\n날짜 형식을 처리하는 몇 가지 사용자 정의 유틸리티 함수가 있는 datetime이라는 폴더가 있다고 가정해봅시다:\n\n```python\n# ./datetime/utils.py\n\ndef increment_date(date: int, increment: int) -> int:\n    \"\"\"밀리초 단위로 타임스탬프 증가\"\"\"\n    return date + increment\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리는 그런 다음 __init__.py를 추가해서 main.py에서 코드를 가져올 수 있도록합니다:\n\n```js\nmyfolder\n│\n├── datetime\n│   ├── __init__.py\n│   └── utils.py\n└── main.py\n```\n\n```js\n# main.py\n\nfrom datetime.utils import increment_date\nfrom datetime import datetime\n\ndef main():\n    timestamp = datetime.timestamp(datetime(2024, 2, 27))\n    print(increment_date(timestamp, increment=10))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n만약 main.py를 실행하면 무엇이 일어날까요?\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nImportError: `datetime` 모듈에서 `datetime`을 가져올 수 없습니다.\n\n보통, Python 인터프리터는 패키지 발견 과정을 (1) 로컬 디렉토리, (2) 표준 라이브러리, 그리고 (3) 설치된 Python 모듈의 순서로 우선시합니다.\n\ndatetime이라는 이름의 폴더에 __init__.py를 넣음으로써, 우리는 datetime이라는 파이썬 표준 라이브러리를 재정의했기 때문에 datetime.datetime을 가져오는 명령문이 실패했습니다.\n\n이 문제를 피하려면 매우 간단한 수정이 필요합니다: 다른 Python 표준 라이브러리나 설치된 Python 모듈과 동일한 이름을 가진 폴더 아래에 __init__.py를 넣지 않도록 항상 주의하십시오.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n__init__.py가 어떻게 작동하는지 이해하면, 이것을 활용하여 할 수 있는 좀 더 멋진 것들을 살펴보겠습니다!\n\n## 1. 패키지 레벨 설정 정의하기\n\n만약 코드 내 모든 Python 파일이 유사한 설정을 공유한다면 어떨까요? 로깅 레벨, 상수, 환경 변수 등. 당신의 패키지 내 모든 Python 파일 상단에 설정을 지정하는 대신, 이를 모두 __init__.py에 포함시킬 수 있습니다.\n\n```python\n# myfolder/__init__.py\n\nimport os\nimport logging\n\n# 패키지 전체의 환경 변수를 로드합니다.\nOPENAI_API_KEY = os.getenv(\"OPENAI_API_KEY\", None)\n\n# 패키지 레벨 상수를 설정합니다.\nMODEL = \"gpt-4\"\n\n# 로깅 구성을 설정할 수도 있습니다.\nlogging.basicConfig(level=logging.INFO)\n\n# 패키지 내에서 편리하게 재사용할 수 있는 사용자 지정 데코레이터를 추가하세요.\ndef foo(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        logging.info(f\"함수 호출 중: {func.__name__}\")\n        result = func(*args, **kwargs)\n        logging.info(f\"함수 {func.__name__} 실행 완료\")\n        return result\n    return wrapper\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n당신의 코드베이스에서는 다음과 같이 할 수 있습니다:\n\n```js\n# myfolder/bar.py\n\n# 패키지 __init__.py에서 상대적인 임포트\nfrom . import OPENAI_API_KEY, MODEL, foo\n\nfrom openai import OpenAI\nfrom typing import Optional\n\nclient = OpenAI()\n\n@foo\ndef chat_with_openai(prompt: str, llm: Optional[str] = None) -> Any:\n    \"\"\"Prompt를 LLM에 보내고 응답을 반환합니다\"\"\"\n    llm = llm or MODEL\n    \n    return client.chat.completions.create(\n              model=llm,\n              messages=[\n                {\"role\": \"system\", \"content\": \"You are a helpful assistant.\"},\n                {\"role\": \"user\", \"content\": prompt}\n              ]\n            )\n```\n\n위 내용에 추가하여 다음과 같은 작업도 가능합니다:\n\n- 기능 플래깅\n- 고급 로거 구성 (예: 모든 로그를 폴더에 저장)\n- 기본 매개변수 설정 (예: 출력 디렉토리가 제공되지 않은 경우 X에 저장)\n- 사용 모니터링 (예: 모든 함수 호출을 클라우드 인스턴스로 보내는 사용자 지정 데코레이터)\n- 테마 사용자 정의/정의 (예: 언어 로캘, 라이트/다크 테마)\n- 사용자 정의 데코레이터로 오류 처리 중앙화\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 2. 패키지 가져오기 단순화\n\n코드베이스가 복잡해지면 더 많은 클래스와 함수를 추가하게 될 것입니다. 코드를 응집된 단위로 분리하는 원칙에 따라, 아래와 같은 구조가 생길 수 있습니다:\n\n```js\nfoo\n│\n├── llm_email_responder\n│   ├── __init__.py\n│   ├── base_email_responder.py\n│   ├── mail_chimp_responder.py\n│   ├── zoho_mail_responder.py\n│   └── send_grid_responder.py\n└── __init__.py\n```\n\nMailChimp에 대한 LLM 이메일 응답기를 사용하려면 다음이 필요합니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nfrom foo.llm_email_responder.mail_chimp_responder import MailChimpResponder\n```\n\n곧 여러 줄의 비슷한 import 문이 생겨나게 되어 코드베이스의 내부 구조를 기억하기 어렵게 만들 수 있습니다. \n\n__init__.py는 import를 정리하고 코드베이스의 더 낮은 수준의 부분을 보호하면서 개발 경험을 단순화하는 데 사용할 수 있습니다.\n\n```js\n# ./foo/llm_email_responder/__init__.py\n\n# 사용자가 더 높은 수준의 구현만큼 자주 사용하지 않을 것으로 예상되므로\n# 가장 낮은 수준의 이메일 응답기는 건너뜁니다.\nfrom .mail_chimp_responder import MailChimpResponder\nfrom .zoho_mail_responder import ZohoResponder\nfrom .send_grid_responder import SendGridResponder\n\n__all__ = [\n    \"MailChimpResponder\",\n    \"ZohoResponder\",\n    \"SendGridResponder\",\n]\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 __init__.py와 함께, 이제 다음과 같이 응답기에 액세스할 수 있습니다:\n\n```js\nfrom foo.llm_email_responder import MailChimpResponder\n```\n\n이것은 개발자 친화적 인터페이스에서 하위 수준의 코드를 노출하는 편리한 방법이지만, 하위 수준 코드베이스에 대한 변경은 반드시 __init__.py의 변경과 일치해야 함으로 유지 보수 노력이 증가할 것입니다. 또한 하위 수준의 코드 베이스를 노출하는 것이 일관된 아키텍처를 형성하는지 여부를 평가해야 합니다.\n\n## 싱글톤 패턴\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n싱글톤 디자인 패턴을 적용하려면 __init__.py를 사용할 수도 있어요. 이렇게 하면 패키지 전체가 __init__.py에서 인스턴스화한 동일한 인스턴스를 사용하도록 강제됩니다.\n\n만약 패키지가 원격 서비스에 연결을 설정하거나 대규모 데이터셋을로드하거나, 무거운 작업을 요구하는 어떤 전제조건이 필요하다면, 이 방법이 아주 편리할 거예요.\n\n예를 들어 금융 보고서를 조작하는 LLM 필요를 처리하기 위해 Gemini Pro에 연결해야 한다고 해보죠.\n\n```js\nfoo\n│\n├── report_analyser\n│   ├── __init__.py\n│   ├── outline_extraction.py\n│   └── entity_extraction.py\n└── __init__.py\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n# .foo/report_analyser/outline_extraction\nfrom langchain_google_vertexai import VertexAI\n\ndef extract_outline(page: str, **kwargs) -> str:\n    llm = VertexAI(\n        model_name=\"gemini-pro\", location=\"europe-west2\", **kwargs\n    )\n    prompt_template = \"\"\"...<Your prompt template here>...\"\"\"\n    prompt = prompt_template.format_prompt(page=page)\n    return llm.invoke(prompt)\n\n\n\n# .foo/report_analyser/entity_extraction\nfrom langchain_google_vertexai import VertexAI\n\ndef extract_entities(page: str, **kwargs) -> str:\n    llm = VertexAI(\n        model_name=\"gemini-pro\", location=\"europe-west2\", **kwargs\n    )\n    prompt_template = \"\"\"...<Your prompt template here>...\"\"\"\n    prompt = prompt_template.format_prompt(page=page)\n    return llm.invoke(prompt)\n\n\n\n# .foo/report_analyser/entity_extraction\nfrom foo.report_analyser.outline_extraction import extract_outline\nfrom foo.report_analyser.entity_extraction import extract_entities\n\ndef main():\n    page = \"Long page of document here\"\n\n    # A connection to VertexAI will be created for\n    # extracting outline\n    outline = extract_outline(page, temperature=0.2)\n\n    # Another connection to VertexAI will be created\n    # for extracting entities\n    entities = extract_entities(page, temperature=0.2)\n\n\n각 작업을 실행할 때마다 코드베이스가 VertexAI와 새로운 연결을 생성하여 불필요한 네트워크 오버헤드가 발생합니다. 만약 Gemini Pro에 대해 동일한 구성을 사용할 계획이라면, 대신 다음을 수행할 수 있습니다:\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# .foo/report_analyser/__init__.py\nfrom langchain_google_vertexai import VertexAI\n\nDEFAULT_LLM = VertexAI(\n    model_name=\"gemini-pro\",\n    location=\"europe-west2\",\n    temperature=0.2,\n)\n```\n\n```js\n# .foo/report_analyser/outline_extraction\nfrom . import DEFAULT_LLM\n\nfrom typing import Dict\n\ndef extract_outline(\n    page: str,\n    custom_llm_parameters: Optional[Dict] = None\n) -> str:\n    \n    if custom_llm_parameters is None:\n        llm = DEFAULT_LLM\n    else:\n        llm = VertexAI(\n            model_name=\"gemini-pro\",\n            location=\"europe-west2\",\n            **custom_llm_parameters\n        )\n    prompt_template = \"\"\"...<Your prompt template here>...\"\"\"\n    prompt = prompt_template.format_prompt(page=page)\n    return llm.invoke(prompt)\n```\n\n코드를 개선하려면, __init__.py에서 LLM 연결을 생성하는 부분을 분리하여 별도의 파일로 만들어 LLM 연결 관리자를 만들 수 있습니다. @lru_cache와 결합하면 사용자 정의 구성을 더 효율적으로 처리하고 있는 것을 알 수 있을 것입니다.\n\n__init__.py에 대해 무엇인지 배우고 더 잘 활용하는 방법에 대한 아이디어를 얻었기를 바랍니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파이썬에 대해 더 알고 싶다면, 파이썬에 관한 다른 블로그를 확인해보세요!\n\n다음에 또 만나요, Louis입니다.","ogImage":{"url":"/TIL/assets/img/2024-07-14-CanYouEven__init__py_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-CanYouEven__init__py_0.png","tag":["Tech"],"readingTime":12},{"title":"삼체 문제의 트리플 별 직렬 현상 물리학 실제로 사람이 행성에서 끌려갈 수 있을까","description":"","date":"2024-07-14 19:52","slug":"2024-07-14-PhysicsoftheTri-SolarSyzygyfromThe3BodyProblemCouldPeopleReallyBePulledOffaPlanet","content":"\n\n\n![Tri-Solar Syzygy](/TIL/assets/img/2024-07-14-PhysicsoftheTri-SolarSyzygyfromThe3BodyProblemCouldPeopleReallyBePulledOffaPlanet_0.png)\n\n영화 예고편에 있는 내용이라면 스포일러가 아닙니다. 제가 말하고 싶은 것은 Trisolaris 행성 주민들이 표면에서 끌려 내려가는 장면을 언급한 것입니다.\n\n여기 중요한 사항들만 알려 드릴게요. Trisolaris라는 행성이 세 개의 태양이 있는 천체계에 있다는 점입니다 (그래서 3-체 문제라고 불립니다). 어느 순간, 사람들 (실제로는 사람이 아니죠)이 행성 표면에서 끌려올라가는 장면이 있는데요. 책에서 이렇게 이야기하고 있어요.\n\n이 부분이 플롯의 현실적인 면에서 옳은지 여부는 사실 중요하지 않아요 — 이겈 이야기이고, 때로는 이야기가 물리 법칙을 따르지 않기도 해요. 그래서 더 재미있는 거죠. 하지만 여전히 이 Tri-Solar Syzygy의 물리학을 살펴볼 거에요 (실은 '시지지'가 무엇인지는 잘 모르겠어요. 이제 물어보기도 부끄러워집니다).\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 3체 문제\n\n만약에 중력 상호작용이 일어나는 두 물체가 있다면 (이렇게 해서 이진 별계에 있는 두 별이 될 수 있어요), 해석적으로 운동 방정식을 풀어낼 수 있어요. 초기 조건을 알고 있다면 두 물체의 미래 위치와 속도를 찾을 수 있는 식을 얻을 수 있어요. 놀랍게도, 이를 2체 문제라고 부를 수 있어요. 만일 더 자세한 유도를 원한다면, 제가 도와드릴 수 있어요.\n\n하지만 만약 서로 상호작용하는 세 물체를 갖고 있다면 어떨까요? 예를 들어, 세 개의 별이 있다고 해 봅시다: 별 1, 별 2, 별 3. 이 경우에는 별 1과 2 사이의 상호작용, 2와 3 사이의 상호작용, 그리고 1과 3 사이의 상호작용이 존재할 거에요. 이는 2체 문제의 좀 더 복잡한 버전일 것 같지만, 이 시스템을 위한 해석적인 해결책은 없어요. (적어도 우리가 아는 바로는) 이를 방정식 형태로 풀 수 있는 방법은 불가능해요.\n\n3체 문제 같은 문제를 해결할 수 있는 한 가지 방법이 있어요 - 수치적인 해법입니다. 아이디어는 운동을 짧은 시간 간격으로 나누는 것이에요. 이 간격 각각에 우리는 모든 중력 힘을 계산하고, 그 짧은 시간 동안에는 이들이 일정하다고 가정할 수 있어요. 일정한 힘을 가질 때, 세 개의 별의 운동량과 위치가 어떻게 변하는지 알 수 있어요. 그 후에는 그냥 다음 시간 간격에 대해 이 프로세스를 반복하기만 하면 돼요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n각 시간 간격 동안의 계산은 비교적 간단합니다 — 하지만 그만큼 많은 계산을 해야 합니다. 누구나 그 모든 계산을 하고 싶어하진 않으니까, 컴퓨터에게 맡기는 게 편합니다 (그나저나 컴퓨터는 크게 불평하지 않아요 — 적어도 지금까진요).\n\n여기 저의 매우 상세한 3체 문제의 수치해법입니다.\n\n# 안정적인 3체 해법\n\n일반적으로, 세 개체의 움직임을 결정하기 위해서는 수치 계산이 필요합니다. 그러나 세 별의 해법을 얻을 수 있는 특별한 상황도 있습니다. 몇 가지 중요한 물리 개념이 있으니, 그 부분부터 알아봅시다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n두 질량 간의 중력 상호작용을 다음 방정식으로 모델링할 수 있습니다:\n\n![equation1](/TIL/assets/img/2024-07-14-PhysicsoftheTri-SolarSyzygyfromThe3BodyProblemCouldPeopleReallyBePulledOffaPlanet_1.png)\n\n여기서 M1과 m2는 벡터 r로 구분된 두 질량입니다. G는 만유인력상수이고 r-hat은 힘이 벡터가 되도록 하는 단위 벡터입니다. 그렇다면 두 개 이상의 질량이 있다면 어떻게 될까요? 그 경우, 총 힘은 각 질량에서 오는 힘의 벡터 합일 뿐입니다.\n\n![equation2](/TIL/assets/img/2024-07-14-PhysicsoftheTri-SolarSyzygyfromThe3BodyProblemCouldPeopleReallyBePulledOffaPlanet_2.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 우리는 원운동에 대해 생각해야 합니다. 삼성계의 가장 간단한 움직임은 원을 그리는 것이겠죠. 물체가 원 안에서 움직이고 있다면, 원의 중심을 향하는 가속도가 발생하며 그 크기는 다음과 같습니다:\n\n![원운동 가속도](/TIL/assets/img/2024-07-14-PhysicsoftheTri-SolarSyzygyfromThe3BodyProblemCouldPeopleReallyBePulledOffaPlanet_3.png)\n\n원운동의 반지름은 r이고 속도는 v입니다. 각속도(ω)의 운동가속도를 계산하는 것도 가능합니다.\n\n자, 이제 우리는 안정된 움직임을 준비했습니다. 세 개의 별이 같은 질량을 가지고 있으며 한 별이 고정되어 있고 다른 두 별이 그 고정된 별 주위를 공전하는 것으로 가정합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![image1](/TIL/assets/img/2024-07-14-PhysicsoftheTri-SolarSyzygyfromThe3BodyProblemCouldPeopleReallyBePulledOffaPlanet_4.png)\n\n중간에 있는 별 1에는 두 개의 중력이 작용함을 알 수 있습니다. 그러나 대칭이라면, 별 2와 별 3이 반대 방향으로 같은 힘으로 작용하여 별 1이 정지 상태에 있을 수 있도록 하지요.\n\n별 2를 보면, 왼쪽으로 두 개의 중력이 작용합니다 - 별 1과 별 3에서. 이 순방향 힘은 별 2가 왼쪽으로 가속화되도록 합니다. 이 순방향 힘이 별 2가 원운동 할 수 있도록 만드는 속도(v)를 계산할 수 있게 됩니다. 별 1은 별 2에서 거리 r 떨어져 있지만, 별 3는 2r의 거리에 있습니다.\n\n![image2](/TIL/assets/img/2024-07-14-PhysicsoftheTri-SolarSyzygyfromThe3BodyProblemCouldPeopleReallyBePulledOffaPlanet_5.png)\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n태양의 크기 (r)를 알고 있다고 가정해 봅시다. 그러면 별 2의 속도를 구할 수 있습니다 (이는 별 3의 속도가 될 것입니다).\n\n![image](/TIL/assets/img/2024-07-14-PhysicsoftheTri-SolarSyzygyfromThe3BodyProblemCouldPeopleReallyBePulledOffaPlanet_6.png)\n\n이게 실제로 작동할까요? 한 번 시도해 볼 수 있습니다. 세 개의 같은 질량을 가진 태양으로 수치 계산을 해보겠습니다. 중간에 있는 별은 정지 상태에서 시작하고, 나머지 두 개의 별은 계산된 속도로 시작합니다. 그런 다음, 별의 움직임을 모델링하기 위해 수치 계산 방법을 사용할 수 있습니다. 전체 Web VPython 코드는 여기에서 확인할 수 있습니다. 애니메이션은 다음과 같이 보입니다:\n\n![animation](https://miro.medium.com/v2/resize:fit:960/1*RA24sRZkOic5eOCj7FBVzg.gif)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n물론, 중요한 점은 삼합성 시스템이 안정한 궤도에 있지 않다는 것입니다 — 이것이 바로 삼합성의 거주자들이 마주한 문제 중 하나입니다. 그러나 이 책에서는 별들이 어떻게 이러한 배열에 도달하는지 알 수 있습니다.\n\n# 삼합성 행성의 궤도\n\n이제 행성을 추가해보죠. 이로 인해 \"네 체 문제\"가 되지는 않을 것입니다. 행성의 질량은 별들에 비해 매우 작다고 가정할 수 있기 때문입니다. 이는 행성이 별 세 개에게 발생시키는 중력 힘이 그들의 움직임에 별다른 영향을 미치지 않을 것을 뜻합니다. 물론, 4개의 서로 작용하는 물체의 움직임을 쉽게 모델링할 수 있겠지만, 이 가정은 설정을 더 쉽게 만들 것입니다.\n\n행성의 관점에서 볼 때, 세 별은 일직선으로 유지되어야 합니다. 이것은 삼합성이 두 별과 같은 각속도를 가지고 있을 때(가운데 별이 고정일 때) 발생합니다. 다음은 다이어그램입니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![image](/TIL/assets/img/2024-07-14-PhysicsoftheTri-SolarSyzygyfromThe3BodyProblemCouldPeopleReallyBePulledOffaPlanet_7.png)\n\n당연히 이것은 실제 크기로 표현된 것이 아닙니다 (작은 행성은 볼 수 없겠죠). 이 행성에는 세 개의 중력 작용이 있습니다 (세 개의 별로 인한 것입니다). 그에 따라 행성의 가속은 각속도(ω)와 궤도 거리(r_p)에 따라 달라집니다.\n\n이 위치에서 모든 중력은 가속과 같은 방향에 있으므로, 뉴턴의 제2 법칙에 대한 다음 방정식을 작성할 수 있습니다 (참고: 각 별의 질량은 M이고 행성의 질량은 m입니다).\n\n![image](/TIL/assets/img/2024-07-14-PhysicsoftheTri-SolarSyzygyfromThe3BodyProblemCouldPeopleReallyBePulledOffaPlanet_8.png)\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n행성의 각 운동 속도는 외부 별 중 하나의 각 운동 속도에서 구할 수 있습니다.\n\n![image](/TIL/assets/img/2024-07-14-PhysicsoftheTri-SolarSyzygyfromThe3BodyProblemCouldPeopleReallyBePulledOffaPlanet_9.png)\n\n이제 행성 트리솔라리스의 공전 거리 (r_p)를 구하는 것은 여전히 어려운 방정식으로 보입니다. 괜찮아요. 실제로 이 방정식을 풀 필요는 없어요. 숫자적 해법을 찾을 수 있으며, r_p의 다른 값에 대해 방정식의 좌변과 우변의 값을 구하여 해의 값을 찾을 수 있어요. 이 두 변을 그래프로 그리면 교차하는 지점이 해를 주는 r_p의 숫자 값이 될 거에요. 한 번 확인해보세요.\n\n![image](/TIL/assets/img/2024-07-14-PhysicsoftheTri-SolarSyzygyfromThe3BodyProblemCouldPeopleReallyBePulledOffaPlanet_10.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n스케일 조정을 해 보면서, 행성 공전 거리를 0.21065 AU로 결정했어요. 그럼, 그걸로 테스트해 볼게요. 여기 4번째 객체를 넣은 3체 문제 계산 결과입니다.\n\n![image](https://miro.medium.com/v2/resize:fit:1000/1*EHiES60H5-45wmU7IZpYDQ.gif)\n\n별의 회전 운동과 대부분 일치하면서 행성이 이동하는 모습을 보실 수 있어요. 애니메이션 끝 쪽에 조금씩 벗어나는데요 — 근데 괜찮아요. 이 삼중태양 허물기는 어차피 영원히 지속되지 않거든요.\n\n# 삼중태양 허물기 모델링\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n사람들이 행성 표면에서 당겨지는 이유가 무엇일까요? 첫 번째 아이디어는 세 개의 별로부터의 중력 힘의 합이 사람들을 당겨내는 중력 힘보다 크다는 것입니다. 이미지를 보세요!\n\n![image](/TIL/assets/img/2024-07-14-PhysicsoftheTri-SolarSyzygyfromThe3BodyProblemCouldPeopleReallyBePulledOffaPlanet_11.png)\n\n좋아요. 우리는 이러한 힘들을 계산할 수 있어요 (일부 가정을 가지고). 지구와 똑같은 행성이라고 가정해 봅시다 (왜냐하면요). 이것은 즉, 사람을 행성으로 당기는 중력 힘이 1킬로그램당 9.8 뉴턴이 될 것이라는 것을 의미해요. 세 개의 별로 인한 순박한 힘으로 인한 순박한 힘의 경우, 1.5 N/kg 정도일 것입니다 - 9.8 N/kg 보다 작아요. 네, 이것이 삼합운 돌아가는 내 특정 값에 대한 값이에요.\n\n그런데 기다려 주세요! 중력 힘의 이 차이로 실제로는 당신이 트리솔라리스의 표면에서 더 가벼워진다는 느낌을 받지 못할 거예요. 왜냐하면요? 그것은 행성이 정지해 있지 않기 때문에 그렇습니다 - 사실 행성은 이미 원형 운동으로 움직이고 있기 때문에 별들 쪽으로 가속하고 있어요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n걱정하지 마세요, 선이 3개인 라인의 누적 효과를 계산할 수 있어요. 하지만 약간의 잡수작을 필요로 할 거예요. 3개의 별과 중력 상호작용은 행성에 힘을 가해 가속시키는데, 이는 행성의 중심에서의 가속임을 명심해야 해요. 표면에 있는 비인간은 행성 중심에서의 가속도 값을 가질 것인데, 별들에 더 가까운 지점에서의 중력 힘을 받게 될 거예요. 네, 조금 복잡한 일이죠.\n\n트리솔라리스 표면의 겉으로 보이는 중력 힘은 행성의 중심에서의 중력장과 표면에서의 차이로 나타날 거예요. 행성의 반지름이 6.3 x 10⁶ 미터인 것으로 가정해봅시다 (지구와 같다 가정). 그 경우, 별들에서 오는 유효한 힘은 1kg 당 0.00074 뉴턴을 향해 당겨주게 될 거예요.\n\n그러니까, 질량이 70kg인 생명체는 보통 686 뉴턴의 무게를 느낄 수 있을 텐데요 — 그러나 세 개의 별이 일렬로 위치할 때 그들은 685.99 뉴턴만 느낄 거예요. 만약 숫자에 좀 미숙하다면, 그것은 무게 차이가 크지 않다는 거죠.\n\n이제 맞추세요! 만약 한 사람 (실제 사람이 아닌)이 행성의 반대편에 있다면, 그들도 역시 겉으로 보이는 무게가 더 낮게 느껴질 거예요. 이 경우에 별들로부터의 중력 힘은 조금 더 낮아지겠지만, 행성의 중심의 가속도는 그들에게 지속적으로 멀어지는 것처럼 보일 거예요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이야기 한 번 더 들려줄게요. 정확히 여러분이 지구에 두 개의 조수가 있는 이유입니다. 그 이유는 달로부터 오는 중력에 의한 가속이 지구의 중심에서 발생하기 때문입니다. 지구의 중심에서의 가속은 지구 표면에서의 달로부터 오는 중력과는 다릅니다. 이러한 차이로 인해 물이 두 군데에서 풍겨져 두 개의 물 축적이 발생하는 것이죠. 여기 지구의 표면 가속과 실제 중력장 사이의 차이를 시각화한 그림이 있어요.\n\n![Earth Visualization](/TIL/assets/img/2024-07-14-PhysicsoftheTri-SolarSyzygyfromThe3BodyProblemCouldPeopleReallyBePulledOffaPlanet_12.png)\n\n만약 이 이미지를 생성하는 과정의 자세한 내용을 보고 싶다면, 전부 제공해 드리겠습니다.\n\n그러면, 여기 주의! \"3체 문제\"는 넷플릭스 쇼로 제작된 책일 뿐이에요. 실제로는 존재하지 않습니다. 물리학이 완벽하진 않아도 괜찮아요. 물론, 행성의 크기나 궤도를 변경하면 효과적인 힘을 더 크게 얻을 수도 있겠지만, 제가 설정한 값들이 합리적으로 보인다고 생각해요.","ogImage":{"url":"/TIL/assets/img/2024-07-14-PhysicsoftheTri-SolarSyzygyfromThe3BodyProblemCouldPeopleReallyBePulledOffaPlanet_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-PhysicsoftheTri-SolarSyzygyfromThe3BodyProblemCouldPeopleReallyBePulledOffaPlanet_0.png","tag":["Tech"],"readingTime":11},{"title":"자동 ARIMA 모델 사용 방법","description":"","date":"2024-07-14 19:49","slug":"2024-07-14-AutomaticARIMA","content":"\n\n자동 모델 선택 및 다단계 예측\n\n![이미지](/TIL/assets/img/2024-07-14-AutomaticARIMA_0.png)\n\nARIMA (AutoRegressive Integrated Moving Average)은 시계열 예측 및 분석에 사용되는 통계 모델입니다. ARIMA의 기원은 1900년대 초반으로 거슬러 올라가며 자기회귀(AR) 모델과 이동평균 (MA) 모델이 별도로 발전됐습니다. 두 모델 모두 현실 시계열 데이터의 복잡한 역학을 포착하기에는 충분하지 않은 것으로 나타납니다. 1960년대에 세 통계학자인 조지 E. P. 박스, 그윌림 M. 젠킨스, 그리고 그레고리 C. 레인절이 \"시계열 분석: 예측과 제어\"라는 책에서 AR과 MA 모델을 공식적으로 통합하여 ARIMA를 만들었습니다.\n\nARIMA는 아마도 가장 잘 알려진 패러다임이지만, 왜 이 \"현대적인\" 시계열 서적에 포함시키는 걸까요? 주된 이유는 AR과 MA가 현대적인 시계열 기술에서 많은 흔적을 남겨주었기 때문입니다. ARIMA에 대한 기본 이해는 다른 복잡한 모델에 걸쳐 활용할 수 있게 해줍니다. 예를 들어, NeuralProphet의 4장에서 AR 모듈을 보았고, 12장과 13장에서는 AR 항목을 감독 학습 모델에서 특징으로 볼 것입니다. 이 책에 ARIMA를 포함한 두 번째 이유는 최근의 코드 개발로 자동 모델 선택과 다단계 예측이 가능해졌기 때문입니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 챕터 4: \"튜토리얼 II: 트렌드 + 계절성 + 휴일 및 이벤트 + 자기 회귀(AR) + 지연 회귀자 + 미래 회귀자.\"\n- 챕터 12: \"트리 기반 시계열 예측에 대한 튜토리얼\"\n- 챕터 13: \"다단계 시계열 예측에 대한 튜토리얼.\"\n\n오늘날의 코드 라이브러리를 사용하면 최적의 ARIMA 모델을 선택할 수 있습니다. 표준 ARIMA 학파에서 교육을 받은 경우, 최적의 AR 및 MA 순서를 선택하기위한 규정화된 지침을 외우고 있는 사람도 있을 것입니다. 모델 사양을 결정하기 위해 자동 상관 함수(ACF) 및 부분 자동 상관 함수(PACF)를 사용해야 합니다. 그러나 나는 그런 규정화된 지침을 잊어버리고 그냥 여러 순서의 후보 모델을 만들어 최적의 모델을 선택합니다. 왜 최상의 모델을 선택하기 위해 많은 모델을 생성하지 않을까요? 이러한 이유로, Python의 \"pmdarima\"와 같은 편리한 라이브러리가 있어 최적 사양을 자동화하는 데 도움이 됩니다. 이 장을 \"자동 ARIMA\"라고 제목 지어 이 이점을 강조하고자 합니다. 그래도 이 챕터에서는 차이, ACF 및 PACF의 개념을 다룰 것입니다.\n\n\"statsmodels\"와 \"pmdarima\"와 같은 현대의 코드 라이브러리는 단기 예측이 아닌 다단계 예측을 가능하게 합니다. 이를 수행하기 위해 모델을 재귀적으로 적용하여 예측을 생성하는 방법에 대해 배우게 될 것입니다. 일반적으로 다단계 예측을 생성하는 두 가지 기본 전략이 있습니다: 재귀적 방법과 직접 방법. 우리는 챕터 13 \"다단계 시계열 예측에 대한 튜토리얼\"에서 이를 배울 것입니다. 두 전략은 ARIMA와 lightGBM 또는 XGB와 같은 트리 기반 모델에 채택되어 다단계 예측을 생성합니다.\n\n마지막으로, 많은 사용 사례에서 우리는 점 추정치에 만족하지 않고 예측 구간을 필요로 합니다. 잠재적 불확실성을 평가하기 위해 가능한 값의 범위가 필요합니다. \"pmdarima\"와 \"statsmodels\"는 신뢰 구간을 반환합니다. 반면에, Part II \"확률적 예측을 얻기\"의 5부터 8 챕터에서 예측 구간을 위한 더 많은 기술을 배웠습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 제 5장: 시계열 확률 예측을 위한 몬테카를로 시뮬레이션\n- 제 6장: 시계열 확률 예측을 위한 분위 회귀\n- 제 7장: 시계열 확률 예측을 위한 형식 예측\n- 제 8장: 시계열 확률 예측을 위한 형식화된 분위 회귀\n\n이 글에서는 이론과 실무를 포괄적으로 설명하겠습니다. 실제 데이터를 사용하여 모델 구축과 예측을 안내할 예정이에요. 이미 알고 계신 부분은 건너뛰셔도 괜찮아요. Python 노트북은 여기서 다운로드할 수 있어요. 다룰 주제들은 다음과 같아요:\n\n- ARIMA 모델\n- 차분\n- ACF 사용하여 MA의 차수 제안\n- PACF 사용하여 AR의 차수 제안\n- pmdarima 라이브러리 사용하여 최적 모델 자동 탐색\n- 다단계 예측\n- statsmodels 사용하여 모델을 반복적으로 업데이트\n- SARIMA 모델\n\n먼저 데이터를 불러오겠습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n데이터 전처리\n\n카글의 아보카도 판매 데이터를 사용할 것입니다.\n\n```js\n%matplotlib inline\nfrom matplotlib import pyplot as plt\nimport pandas as pd\nimport numpy as np\n\nfrom google.colab import drive\ndrive.mount('/content/gdrive')\n\npath = '/content/gdrive/My Drive/data/time_series'\ndata = pd.read_csv(path + '/avocado_monthly.csv', index_col='Date')\ndata.sort_values(by='Total Volume', ascending=False)\n```\n\n(A) 그림은 이 데이터셋의 일부를 보여줍니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![그림](/TIL/assets/img/2024-07-14-AutomaticARIMA_1.png)\n\n이 데이터 세트에서는 하나의 일변량 시계열만 사용할 것입니다.\n\n```js\n# '유기농' 및 'TotalUS' 지역인 하나의 시계열만 사용합니다.\ndf = data[(data['type']=='organic') & (data['region']=='TotalUS')].copy()\ndf = df['Total Volume']\ndf.columns = ['y']\ndf = df[pd.to_datetime(df.index)<=pd.to_datetime('2018-02-01')]\n\n# 일변량 시계열 그래프 그리기\nplt.figure(figsize=(10,4))\nplt.plot(df)\nplt.xlabel(\"날짜\")\nplt.ylabel(\"볼륨\")\nplt.show()\n```\n\n그림 (B)는 일변량 시계열 그래프를 보여줍니다.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![그림](/TIL/assets/img/2024-07-14-AutomaticARIMA_2.png)\n\n이후에는 80%를 인-타임 훈련 데이터로 사용하고 나머지 20%는 아웃-오브-타임 테스트 데이터로 사용합니다.\n\n```js\n# Train-test-split\ntrain_len = int(df.shape[0] * 0.8)\ntest_len = df.shape[0] - train_len\ntrain, test = df[:train_len], df[train_len:]\nprint(f\"{train_len}개의 훈련 샘플\")\nprint(f\"{df.shape[0] - train_len}개의 테스트 샘플\")\n```\n\n좋아요. 이제 우리는 정의부터 시작합시다.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nARIMA 모델들\n\nARIMA는 단변량 시계열 데이터를 사용하여 미래 값을 예측하는 모델 클래스입니다. 이 모델들은 시계열 데이터의 과거 또는 이전 값, 즉 자기 회귀(AR) 항목과 이동 평균(MA) 항목인 이동 예측 오차의 지연된 값들을 사용하여 미래 값을 예측합니다. ARIMA이란 \"자기 회귀-통합-이동 평균\"의 약자로, \"AR\", \"I\", \"MA\"로 구성됩니다. 여기서 ARIMA의 \"I\"는 \"통합(integrated)\"을 의미하며, 이는 시계열 데이터가 안정성을 달성하기 위해 차분된 것을 나타냅니다. 안정적인 시계열 데이터는 시간이 지나도 평균, 분산 및 자기 상관이 일정하므로 모델링하기 쉽습니다. ARIMA(p,d,q) 모델로 수학적으로 표현하면 다음과 같습니다:\n\nMarkdown 형식으로 테이블 태그를 변경하십시오.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![AutomaticARIMA_3](/TIL/assets/img/2024-07-14-AutomaticARIMA_3.png)\n\nARIMA 표기법에 친숙해지기 위해 위 식을 적용해 봅시다.\n\n![AutomaticARIMA_4](/TIL/assets/img/2024-07-14-AutomaticARIMA_4.png)\n\n일반적으로 AR만 또는 MA만, 또는 p와 q가 모두 4 미만이기 때문에 우변에 많은 항이 없습니다.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n차이화\n\n차이화의 목표는 시계열을 안정적으로 만드는 것입니다. 시계열에서 안정성이란 값의 평균이 시간에 따라 일정하다는 것을 의미합니다. 다시 말해, 안정적인 시계열은 일정한 평균을 갖습니다. 이전 코드는 원래 시계열, 1차 차이화(한 번 차이화), 그리고 2차 차이화(두 번 차이화)를 플롯합니다.\n\n```js\nimport numpy as np, pandas as pd\nfrom statsmodels.graphics.tsaplots import plot_acf, plot_pacf\nfrom statsmodels.tsa.stattools import adfuller\nimport matplotlib.pyplot as plt\nplt.rcParams.update({'figure.figsize':(10,6), 'figure.dpi':100})\nlag_len = 15\nfig, axes = plt.subplots(3, 1, sharex=True)\n\n# Original Series\naxes[0].plot(train.values); axes[0].set_title('Original Series')\n\n# 1st Differencing\naxes[1].plot(train.diff()); axes[1].set_title('1st Order Differencing')\n\n\n# 2nd Differencing\naxes[2].plot(train.diff().diff()); axes[2].set_title('2nd Order Differencing')\n\naxes[0].xaxis.set_major_locator(MultipleLocator(30))\n\nplt.show()\n```\n\n도 (C)는 학습 데이터의 원래 시계열, 1차 차이화, 그리고 2차 차이화에 대한 플롯을 보여줍니다. 1차 및 2차 차이화된 시계열은 안정적입니다. 즉, 모델은 최소한 한 번은 차이화되어야 합니다. 일반적으로 1차 차이화만으로 충분합니다. 안정적인 시계열에 대한 차이화는 여전히 안정적일 것입니다. 1차 차이화가 이미 안정적이라면 2차 차이화를 얻기 위해 과도하게 차이화할 필요가 없습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/TIL/assets/img/2024-07-14-AutomaticARIMA_5.png\" />\n\n이제 ACF를 사용하여 MA(order)를 얻는 방법에 대해 이해해 봅시다.\n\nACF를 사용하여 MA(order)를 제안합니다.\n\n이미 두 변수 간의 상관 계수에 익숙하실 것입니다. 이는 그들의 관계를 측정합니다. -1과 1 사이의 값을 갖습니다. 양의/음의 상관 계수는 두 변수 간에 양의/음의 관계가 있음을 의미합니다. 상관 계수가 1일 경우 완벽한 양의 선형 관계를, 0.0일 경우 변수 간의 선형 관계가 없음을 나타냅니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nACF는 자기상관함수(Autocorrelation Function)의 약자입니다. 이것은 시계열과 그 지연된 버전 간의 상관관계를 측정합니다. ACF는 시계열의 시간 t와 시간 t-k에서의 값들 간의 상관관계로 계산됩니다. 여기서 k는 래그(지연) 번호를 나타냅니다. ACF(k)는 래그 k에서의 자기상관을 나타냅니다. 자기상관을 시각화해봅시다.\n\n```python\nfrom statsmodels.graphics.tsaplots import plot_acf\nplt.rcParams.update({'figure.figsize':(10,6), 'figure.dpi':100})\nlag_len = 15\nfig, axes = plt.subplots(3, 1, sharex=True)\n\n# 원 데이터\nplot_acf(train.values[0:lag_len], ax=axes[0], title = 'ACF - 원 데이터')\n\n# 1차 차분\nplot_acf(train.diff().dropna()[0:lag_len], ax=axes[1], title = 'ACF - 1차 차분')\n\n# 2차 차분\nplot_acf(train.diff().diff().dropna()[0:lag_len], ax=axes[2], title = 'ACF - 2차 차분')\n\nplt.show()\n```\n\n(D) 그림은 자기상관을 보여줍니다. 첫 번째 막대의 상관 계수는 1.0인데, 이는 y_t와 그 자신의 상관관계를 나타냅니다. 파란 영역은 유의수준을 의미합니다. 유의수준을 넘는 막대는 통계적으로 유의미하다는 것을 의미합니다. 보시다시피, 1차 차분 라인에서의 래그 1은 유의미합니다. 이는 모델이 래그 1 항을 포함하고 있으며 1차 차분이 있다는 것을 의미합니다.\n\n<img src=\"/TIL/assets/img/2024-07-14-AutomaticARIMA_6.png\" />\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 PACF를 배워 봅시다.\n\nPACF를 사용하여 AR의 순서를 제안하세요.\n\nACF는 시계열과 그 이전 시간 단계의 관련성을 측정합니다. 현재 시계열 값이 과거 값들과 얼마나 연관이 있는지를 알려줍니다. 반면 PACF는 시계열과 그 이전 시간 단계의 부분 상관 관계를 측정하며, 해당 시간 단계 이전의 모든 이전 시간 단계 값을 고려한 후의 영향을 고려합니다. 이는 현재 시계열 값과 특정 시간 지연 값 사이의 직접적인 관계가 있는지 여부를 결정하는 데 도움이 됩니다. 특히 (E) 그림에서 PACF 지연 1이 중요하다고 합니다. 이는 유의 수준을 넘어섰기 때문입니다. 지연 2도 중요하다고 판명되었는데, 약간의 노력으로 유의 선을 넘었습니다(파란색 영역).\n\n```python\nfrom statsmodels.graphics.tsaplots import plot_pacf\nplt.rcParams.update({'figure.figsize':(10,6), 'figure.dpi':100})\nlag_len = 15\nfig, axes = plt.subplots(3, 1, sharex=True)\n\n# Original Series\nplot_pacf(train.values[0:lag_len], ax=axes[0], title = 'PACF - Original series')\n\n# 1st Differencing\nplot_pacf(train.diff().dropna()[0:lag_len], ax=axes[1], title = 'PACF - 1st differencing')\n\n# 2nd Differencing\nplot_pacf(train.diff().diff().dropna()[0:lag_len], ax=axes[2], title = 'PACF - 2nd differencing')\n\nplt.show()\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n(E) 그림은 PACF 플롯을 보여줍니다.\n\n![PACF 그림](/TIL/assets/img/2024-07-14-AutomaticARIMA_7.png)\n\n그림 (C), (D), (E)의 차이, ACF 및 PACF는 ARIMA(1, 1, 1)을 제안합니다. 만약 이 진단을 알지 못한다고 가정하더라도, 여전히 auto_ARIMA()를 사용하여 모델 사양의 범위를 찾을 수 있습니다.\n\nauto_ARIMA() 사용하여 최적 모델을 자동으로 탐색하는 방법\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nimport pmdarima as pm\nmodel = pm.auto_arima(train,\n                      d=None,\n                      seasonal=False,\n                      stepwise=True,\n                      suppress_warnings=True,\n                      error_action=\"ignore\",\n                      max_p=None,\n                      max_order=None,\n                      trace=True)\n```\n\n![Automatic ARIMA](/TIL/assets/img/2024-07-14-AutomaticARIMA_8.png)\n\n아카이케 정보 기준(Akaike Information Criterion, AIC) 값은 모델 성능 지표입니다. 이 값은 2 * 모델 파라미터 수 - 2 * 최대 우도(L)입니다. 값이 작을수록 모델이 더 잘 맞는 것을 나타냅니다.\n\n![Automatic ARIMA](/TIL/assets/img/2024-07-14-AutomaticARIMA_9.png)\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nFigure(F)에서 가장 낮은 AIC 값은 3,301.526입니다. ARIMA(1, 1, 1)(0, 0, 0)입니다. 계절성 구성요소는 (0, 0, 0)입니다. 계절 차분이 없기 때문에 \"seasonal=False\"로 하이퍼파라미터를 끔 처리했습니다. 나중에 ARIMA에서 다시 활성화할 것입니다.\n\n다중 기간 예측\n\n\"pmdarima\"의 \"predict\" 함수를 사용하면 미래 시점의 기간 수를 지정할 수 있습니다. 미래 시점을 테스트 데이터의 길이로 설정합니다. 그리고 \"return_conf_int = True\"와 \"alpha = 0.05\"로 설정하여 95% 신뢰 수준의 신뢰 구간을 반환합니다.\n\n```js\n# test_len의 길이에 대한 다중 기간 예측 생성\nfcast = model.predict(n_periods=test_len, return_conf_int=True, alpha=0.05)\nforecasts = fcast[0]\nconfidence_intervals = fcast[1]\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모델의 성능을 평가해 봅시다.\n\n```python\nfrom sklearn.metrics import mean_squared_error, mean_absolute_percentage_error\nprint(f\"MAPE: {mean_absolute_percentage_error(test, forecasts)}\")\n```\n\n평균 절대 백분율 오차는 0.1490595592393948 또는 14.9% 입니다. 다음으로 실제 값과 예측값을 그래프로 그려보겠습니다.\n\n```python\ndef plot_it():\n    fig, ax = plt.subplots(figsize=(12,4))\n\n    # 실제 vs. 예측\n    ax.plot(train, color='blue', label='Training data')\n    ax.plot(test.index, forecasts, color='red', marker='o',\n                label='Predicted')\n    ax.plot(test.index, test, color='green', label='Test data')\n    ax.set_title('아보카도 판매량')\n    ax.set_xlabel('날짜')\n    ax.set_ylabel('양')\n    conf_int = np.asarray(confidence_intervals)\n\n    # 신뢰 구간\n    ax.fill_between(test.index,\n                        conf_int[:, 0], conf_int[:, 1],\n                        alpha=0.9, color='orange',\n                        label=\"신뢰 구간\")\n    # 주요 눈금이 20의 배수인 플롯 생성\n    ax.legend()\n    ax.xaxis.set_major_locator(MultipleLocator(20))\n    plt.show()\n\nplot_it()\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n표 (G)는 학습, 테스트 데이터, 예측값 및 신뢰 구간의 시계열을 제공합니다.\n\n![Figure G](/TIL/assets/img/2024-07-14-AutomaticARIMA_10.png)\n\n표 (G)의 예측 값은 일정 기간 이후에 고정값에 수렴하며 예측 가능성이 있습니다. 인상적으로 보이지 않습니다. 각 반복에서 모델을 업데이트하여 개선할 수 있습니다.\n\n각 반복에서 모델을 업데이트해보세요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n각 예측은 예측 시계열에 새로운 관측치를 추가합니다. 모델이 정적인 경우, 예측된 시계열은 최종적으로 직선이 되어 그래프(G)에 표시됩니다. 각 반복에서 추가된 관측치로 모델을 업데이트할 수 있습니다.\n\n우리는 시간 외 시험 기간의 각 반복에서 한 기간을 예측한 후, 새로운 예측을 모델을 업데이트하는 데 사용할 것입니다. \"return_conf_int = True\" 및 \"alpha= 5%\"를 지정하여 95% 신뢰 수준의 예측 구간을 추가할 수 있습니다.\n\n```js\n# https://alkaline-ml.com/pmdarima/modules/generated/pmdarima.arima.ARIMA.html#pmdarima.arima.ARIMA.update\ndef one_period_forecast():\n    fcast = model.predict(n_periods=1, return_conf_int=True, alpha=0.05)\n    # fcast는 두 개의 리스트로 구성됩니다.\n    # 첫 번째 리스트는 예측입니다.\n    forecasts = fcast[0].tolist()\n    # 두 번째 리스트는 신뢰 구간입니다.\n    confidence_intervals = fcast[1]\n    return ( forecasts, \n             np.asarray(confidence_intervals).tolist()[0])\n\nforecasts = []\nconfidence_intervals = []\n\nfor add_obs in test:\n    fc, conf = one_period_forecast()\n    forecasts.append(fc)\n    confidence_intervals.append(conf)\n    # 기존 모델 업데이트\n    model.update(add_obs)\n\nplot_it()\n```\n\n그림 (H)은 예측값이 테스트 값과 더 잘 일치함을 보여줍니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/TIL/assets/img/2024-07-14-AutomaticARIMA_11.png\" />\n\n모델 성능은 어떤가요?\n\n```js\nprint(f\"MAPE: {mean_absolute_percentage_error(test, forecasts)}\")\n```\n\nMAPE는 0.11766234388644323으로, 약 11.7%보다 약간 향상되었습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리 연구를 위한 데이터는 여러 해에 걸친 시계열 데이터이기 때문에 강력한 계절성을 갖고 있다고 의심됩니다. 우리는 Seasonal ARIMA를 사용하여 모델을 완화할 것입니다.\n\nSARIMA 모델\n\nSARIMA 모델은 계절적 시계열 데이터를 다루는 데 특히 설계되었습니다. ARIMA 모델의 비계절적 구성요소 (AR, I 및 MA)에 추가로 SARIMA 모델에는 데이터의 계절적 패턴을 포착하는 계절적 구성요소 (SAR, SI 및 SMA)가 포함되어 있습니다. SARIMA 모델의 SAR 구성요소는 ARIMA 모델의 AR 구성요소와 유사하지만 시계열의 계절적 지연된 값에 작용합니다. SI 구성요소는 ARIMA 모델의 I 구성요소와 유사하지만 시계열의 계절적 차이에 적용됩니다. 마지막으로, SMA 구성요소는 ARIMA 모델의 MA 구성요소와 유사하지만 시계열의 계절적 지연된 오차에 작용합니다.\n\n요약하자면, SARIMA는 단순히 계절 급변을 적용합니다. 계절적 급변은 일반적인 급변과 유사합니다. 연이은 용어를 빼는 대신, 계절적 급변은 이전 계절의 값에서 값을 뺍니다. SARIMA 모델은 일반적으로 SARIMA(p,d,q)(P,D,Q)[S]로 표기됩니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- p은 계절적 자기회귀항의 차수를 나타냅니다.\n- q는 계절적 이동평균항의 차수를 나타냅니다.\n- Q는 계절적 차분의 차수를 나타냅니다.\n- S는 12개월과 같은 계절 사이클을 나타냅니다.\n\n계절 ARIMA 모델은 데이터의 계절 패턴을 포착하기 위해 추가 매개변수를 통합합니다. 다음 구성 요소를 추가합니다:\n\n- 계절적 AR 항: 이러한 항목은 현재 관측치와 계절 간격의 특정 차이 관측치 사이의 관계를 나타냅니다. 데이터의 계절적 패턴을 캡처합니다.\n- 계절적 MA 항: 이러한 항목은 현재 관측치와 계절 간격의 특정 기간의 선행 예측 오류 사이의 관계를 나타냅니다. 데이터의 계절적 변동성을 캡처합니다.\n\nSARIMA 모델링은 매우 쉽습니다. 해야 할 일은 하이퍼파라미터 \"seasonal\"을 \"True\"로 변경하는 것뿐입니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nimport pmdarima as pm\nmodel = pm.auto_arima(train,\n                      # You just need to turn the seasonal to \"True\"\n                      seasonal=True,\n                      start_P=1,\n                      start_q=1,\n                      max_p=None,\n                      max_q=None,\n                      m=12,\n                      d=1,\n                      D=1,\n                      trace=True,\n                      error_action='ignore',\n                      suppress_warnings=True,\n                      stepwise=True)\nmodel.summary()\r\n```\n\n한 가지 모델을 만들었어요. 그림 (I)은 최적의 모델이 ARIMA(0,1,1)(0,1,1)[12]임을 보여줍니다.\n\n<img src=\"/TIL/assets/img/2024-07-14-AutomaticARIMA_12.png\" />\n\n결과를 그래픽으로 표시하고 각 반복마다 모델 업데이트를 활성화해봅시다. 그림 (J)에 플롯이 표시됩니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nforecasts = []\nconfidence_intervals = []\n\nfor add_obs in test:\n    fc, conf = one_period_forecast()\n    forecasts.append(fc)\n    confidence_intervals.append(conf)\n    # Updates the existing model\n    model.update(add_obs)\n\n# Plot the results\nplot_it()\n\n# Calculate MAPE\nprint(f\"MAPE: {mean_absolute_percentage_error(test, forecasts)}\")\n```\n\nMAPE는 0.11918293096560012 또는 11.9%입니다. 이것은 위의 ARIMA 모델에 비해 뚜렷한 개선이 없어 보입니다. 모델의 간결성 원칙에 따라, 우리는 SARIMA 대신 ARIMA 모델을 사용할 것입니다.\n\n![이미지](/TIL/assets/img/2024-07-14-AutomaticARIMA_13.png)\n\n결론\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 게시물에서는 고전적인 ARIMA 및 SARIMA 모델 사양을 검토했습니다. 최적 모델을 자동으로 검색하기 위해 pmdarima 라이브러리의 사용법을 배웠습니다. 또한 ARIMA 및 SARIMA에 대한 다기간 예측 생성 방법을 배웠습니다.\n\n우리는 복잡성이 증가하는 시계열 데이터를 모델링할 것입니다. 여러 Python 라이브러리가 복잡한 데이터 구조에 대한 해결책을 제공합니다. 우리는 이러한 데이터 솔루션을 10장에서 배울 것입니다: 시계열 데이터 형식 변환의 비밀.\n\n참고문헌\n\n- [1] Box, G. E. P., Jenkins, G. M., and Reinsel, G. C. (2015). 시계열 분석: 예측 및 제어 (5판). John Wiley & Sons.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n샘플 eBook 챕터(무료): [여기](https://github.com/dataman-git/modern-time-series/blob/main/20240522beauty_TOC.pdf)\n\n- 아름다운 형식으로 책을 재현하고 즐거운 독서 경험을 제공하기 위해 The Innovation Press, LLC 직원 여러분께 감사드립니다. 우리는 Teachable 플랫폼을 선택하여 전 세계 독자들에게 번거로운 과부하 없이 eBook을 유통합니다. 신용 카드 거래는 Teachable.com이 안전하고 기밀리에 처리합니다.\n\nTeachable.com의 eBook: $22.50\n[여기](https://drdataman.teachable.com/p/home)\n\nAmazon.com에서 인쇄판: $65 [링크](https://a.co/d/25FVsMx)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 프린트 버전은 윤광 처리 커버, 컬러 인쇄, 아름다운 스프링어 글꼴 및 레이아웃을 채택하여 즐거운 독서 경험을 제공합니다. 7.5 x 9.25인치의 품격 높은 크기는 서재에 있는 대부분의 책과 어울립니다.\n- \"이 책은 Kuo의 시계열 분석에 대한 깊은 이해와 예측 분석 및 이상 탐지에 대한 응용을 증명하는 것입니다. 이 책은 독자들이 실제 세계의 문제에 대처하기 위한 필수적인 기술을 제공합니다. 데이터 과학 분야로의 직업 전환을 고려하는 사람들에게 특히 가치 있는 자료입니다. Kuo는 전통적인 기술 뿐만 아니라 최신 기술에 대해 자세히 탐구합니다. Kuo는 신경망 및 다른 고급 알고리즘에 대한 논의를 통합하여, 분야의 최신 동향과 발전을 반영합니다. 이는 독자가 확립된 방법뿐만 아니라 데이터 과학 분야에서 가장 현재이고 혁신적인 기술을 다루는 데 대비할 수 있도록 보장합니다. Kuo의 생생한 글쓰기 스타일로 책의 명료함과 접근성은 높아졌습니다. 그는 복잡한 수학 및 통계 개념을 신비롭지 않게 만들면서도 엄격성을 희생하지 않았습니다.\"\n\n# 현대적인 시계열 예측: 예측 분석 및 이상 탐지를 위한\n\n제로 장: 서문\n\n1장: 소개\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 장 2: 비즈니스 예측을 위한 선지자\n\n# 장 3: 튜토리얼 I: 트렌드 + 계절성 + 휴일 및 이벤트\n\n# 장 4: 튜토리얼 II: 트렌드 + 계절성 + 휴일 및 이벤트 + 자기회귀(AR) + 지연 회귀자 + 미래 회귀자\n\n# 장 5: 시계열 데이터의 변화점 탐지\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nChapter 6: 시계열 확률 예측을 위한 몬테카를로 시뮬레이션\n\nChapter 7: 시계열 확률 예측을 위한 분위 회귀\n\nChapter 8: 시계열 확률 예측을 위한 일치 예측\n\nChapter 9: 시계열 확률 예측을 위한 일치화된 분위 회귀\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 제 10장: 자동 ARIMA!\n\n# 제 11장: 시계열 데이터 형식 쉽게 만들기\n\n# 제 12장: 다기간 확률 예측을 위한 선형 회귀\n\n# 제 13장: 트리 기반 시계열 모델을 위한 피처 엔지니어링\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 14장: 다기간 시계열 예측을 위한 두 가지 기본 전략\n\n# 15장: 다기간 시계열 확률적 예측을 위한 Tree 기반 XGB, LightGBM 및 CatBoost 모델\n\n# 16장: 시계열 모델링 기술의 진화\n\n# 17장: 시계열 확률적 예측을 위한 Deep Learning 기반 DeepAR\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nChapter 18: 주가에 대한 확률적 예측을 위한 응용\n\nChapter 19: RNN부터 Transformer 기반 시계열 모델까지\n\nChapter 20: 해석 가능한 시계열 예측을 위한 Temporal Fusion Transformer\n\nChapter 21: 시계열 예측을 위한 오픈소스 Lag-Llama 튜토리얼","ogImage":{"url":"/TIL/assets/img/2024-07-14-AutomaticARIMA_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-AutomaticARIMA_0.png","tag":["Tech"],"readingTime":25},{"title":"시니어 개발자들이 프로그래밍 도전을 해결하는 방법 비밀 코드 정복기","description":"","date":"2024-07-14 19:47","slug":"2024-07-14-CrackingtheCodeHowSeniorDevsTackleProgrammingChallenges","content":"\n\n\n![Image](/TIL/assets/img/2024-07-14-CrackingtheCodeHowSeniorDevsTackleProgrammingChallenges_0.png)\n\n프로그래밍은 대단히 어려운 작업이며, 특정 사람들에게는 당연한 것처럼 보일 수 있습니다. 의심하는 사람들이 \"아니, 프로그래밍이 어렵다고? 다음은 뭔가, 하늘은 파란색이라고?\"\n\n이 비꼼은 경험 많은 개발자에게 프로그래밍의 어려움이 자명함을 강조합니다. 그러나 초보자들은 종종 프로그래밍이 쉽다고 생각합니다.\n\n# 프로그래밍의 현실\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n놀랍게도, 코딩을 하는 것이 프로그래밍 중에서 가장 어려운 부분은 아닙니다. 표면적으로 보면 프로그래밍은 간단해 보일 수 있지만, 컴퓨터가 이해할 수 있는 코드를 작성하는 것이랍니다.\n\n하지만, 현실은 훨씬 더 복잡해요. 프로그래밍은 논리적 사고, 문제 해결 능력, 그리고 다루고 있는 문제와 도구에 대한 심층적인 이해를 필요로 합니다.\n\n# 프로그래밍 마인드셋의 중요성\n\n많은 초보자들은 프로그래밍의 핵심 부분을 배워야 합니다: 마인드셋입니다. 개발자처럼 생각하는 것이, 특히 초보자들에겐 프로그래밍을 어렵게 만드는 이유입니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n코드를 작성하는 것 뿐만 아니라 문제해결 방식에 대해서도 중요해요. 일주일만에 JavaScript를 배운다는 것은 가능해 보일 수 있지만, 내부에 숨어있는 사회불안증(imposter syndrome), 늦은 밤 코딩 세션, 포기하고 싶은 순간들은 언급되지 않죠.\n\n이러한 경험들은 튜토리얼이나 책에서 소개되는 것이 아니라, 실제로 체험해봐야 합니다.\n\n# 프로그래밍에서의 개발자 마인드셋\n\n# 요리 비유\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n개발자의 마인드셋을 이해하려면, 레시피를 암기해서 요리를 배우는 것을 상상해보세요. 케이크를 만들려면 밀가루, 설탕, 계란, 버터가 필요하다는 것을 알 수 있을 거예요.\n\n레시피를 따라하면 꽤 괜찮은 케이크를 굽을 수 있어요. 그런데 만약 재료가 부족하다면 어떻게 할까요? 또는 다른 무언가를 굽도록 요청받았을 때 어떡할까요? 왜냐하면 상대방이 케이크를 싫어한다고 하면 말이에요.\n\n레시피만 암기한 상태라면 해매일지도 모릅니다. 마찬가지로, Python이나 JavaScript와 같은 프로그래밍 언어를 알아간다는 것도 레시피를 암기하는 것과 비슷합니다.\n\n모든 문법을 알아도, 더 중요한 질문은: 어떻게 효과적으로 활용할 수 있는지 아는지인 거죠?\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 예시: 프로그래밍에서 평균 계산하기\n\n다음 예시를 살펴보세요: 변수, 반복문, 그리고 리스트가 어떻게 동작하는지 배웠습니다. 숫자들의 리스트를 생성하고 for 루프를 사용하여 각 숫자를 출력할 수 있습니다.\n\n이제 이 숫자들의 평균을 찾아야하지만 sum 함수를 사용하지 않습니다. 이를 위해서는 sum 함수가 하는 일을 이해해야 합니다: 모든 요소를 모두 더합니다.\n\n튜토리얼에서 얻는 기본 지식을 활용하여 for 루프를 사용하여 리스트를 순회하고 필요한 산술 연산을 수행할 수 있습니다. 이 예시는 튜토리얼이 기본을 가르쳐주지만 문제를 해결하기 위해 창의적으로 적용해야 함을 보여줍니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 프로그래밍의 진정한 도전\n\n# 프로그래밍에서의 문제 해결과 논리적 사고\n\n프로그래밍의 진정한 도전은 문제 해결과 논리적 사고에 있습니다. 코딩하는 법을 알기만 하는 것이 아니라 무엇을 코딩할지도 아는 것입니다.\n\n새로운 기능을 개발하거나 버그를 수정하려면 그것을 더 작고 관리하기 쉬운 조각들로 나누어 각 부분을 체계적으로 해결해야 합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 기술은 실제로 가르쳐 주기 어려울 뿐만 아니라 자신으로 찾아내야 합니다.\n\n# 프로그래밍의 고통\n\n![이미지](/TIL/assets/img/2024-07-14-CrackingtheCodeHowSeniorDevsTackleProgrammingChallenges_1.png)\n\n많은 사람들이 '튜토리얼 지옥'에 갇혀 계속해서 튜토리얼을 보고 수많은 예시를 따라하지만 새롭고 독특한 문제를 해결하지 못하는 상황에 빠지곤 합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프로그래밍의 학습 곡선은 가파릅니다. 튜토리얼과 실무 경험을 균형있게 조합해야하기 때문이죠. 튜토리얼은 자전거 지지 바와 같아요. 결국 필요 없어질 거예요.\n\n진정한 학습은 배운 것을 다양한 상황에 적용하기 시작할 때 시작됩니다.\n\n# 프로그래머의 마인드셋을 갖추는 팁\n\n# 1. 프로그래밍 문제 분해하기\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프로그래밍 문제를 작은 관리 가능한 작업으로 나누어 시작해보세요. 이 방법을 사용하면 가장 어려운 문제조차 접근 가능해 보이고 명확한 시작점을 제공받게 될 거예요.\n\n예를 들어, 리스트에서 가장 많이 나타나는 상위 세 개의 단어를 추적하고 표시하는 프로그램을 작성해야 한다면 다음과 같이 나눠보세요:\n\n- 먼저, 리스트를 살펴보세요.\n- 그 다음, 각 단어의 빈도수를 세어보세요.\n- 마지막으로, 상위 세 개의 가장 많이 나타나는 단어를 결정하세요.\n\n# 2. 프로젝트 기반 학습에서의 프로그래밍\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프로그래밍의 프로젝트 기반 학습(PBL)은 기술 향상과 문제 해결 능력 향상에 중요합니다.\n\n실전 프로젝트를 통해 이론적 지식을 실제 응용에 적용하여 심층적인 이해와 실무 전문성을 키울 수 있습니다. 이 반복적인 과정은 프로그래밍 능력을 향상시키는 것뿐만 아니라 개발자에게 필수적인 비판적 사고와 창의성을 육성하는 데 도움이 됩니다.\n\n각 완료된 프로젝트는 포트폴리오에 기여하여 여러분의 역량을 과시하고 잠재적인 고용주들에게 매력을 늘려줍니다.\n\n이 접근 방식은 여러분의 기술을 향상시키는 것뿐만 아니라 취업 기회를 열어줍니다. 왜냐하면 고용주들은 실무 경험을 입증한 후보자와 성공적인 프로젝트 완료 이력이 있는 지원자를 가치 있게 여기기 때문입니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 3. 프로그래밍을 위한 파인만 기법\n\n이 기법은 당신이 개념을 정말로 이해했다고 할 수 있는 것은 그것을 간단한 용어로 설명할 수 있는 경우에만 가능하다는 아이디어에 기반을 두고 있습니다.\n\n이 기법은 복잡한 프로그래밍 개념을 기초적인 부분으로 나누어야 한다는 것을 강요하여 당신이 이해한 것과 더 많은 공부가 필요한 부분을 드러내게 합니다.\n\n어떤 사람에게 개념을 가르치거나 설명하거나, 혹은 혼자 소리 내어 스스로에게 설명하는 것은 당신의 이해를 확고하게 하고 보다 더 기억력을 향상시킵니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 4. 프로그래밍에서 실패를 수용하세요\n\n프로그래밍에서는 실패를 학습 과정의 일부로 받아들이는 것이 중요합니다. 만난 모든 오류와 버그는 소중한 교훈을 제공하며 문제 해결 능력을 향상시키고 이해를 깊이 있게 합니다.\n\n이러한 저하를 수용함으로써 탄력성을 육성하고 개선에 대한 적극적인 접근 방식을 취할 수 있습니다.\n\n실패를 분석함으로써 개발자들은 코딩 관행을 개선하고 향후 동일한 문제가 발생하는 것을 방지하는 통찰을 얻을 수 있습니다. 이러한 마음가짐 변화는 프로그래밍 노력에서 지속적인 성장과 혁신을 촉진합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 5. 프로그래밍을 꾸준히 연습하세요\n\n연습을 꾸준히 이어나가세요. 한 번에 1시간 이상 같은 주제나 프로젝트에 집중하는 것이 좋습니다. 짧은 연습 시간은 작은 문제에 유용할 수 있지만, 보다 깊은 이해를 위해서는 더 오래 집중해야 합니다.\n\n# 6. 다른 사람과 자신을 비교하지 마세요\n\n자신을 비교해야 하는 유일한 상대는 바로 여러분 자신입니다. 작은 성과라도 축하하세요. 한 가지 자습서를 완료했거나 버그를 해결했다면 축하해야 합니다. 각자가 자신의 속도로 진전하기 때문에, 특히 여러 해의 경험을 가진 사람들과 비교하는 것은 역효과적입니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 팁을 따라가고 계속 도전함으로써, 당신은 성공한 프로그래머가 되기 위해 필요한 마인드를 개발할 수 있을 것입니다. 앞으로 나아가며 계속 배우고, 필요할 때 프로그래밍 커뮤니티에서 도움을 요청하는 것을 주저하지 마세요. 즐거운 코딩하세요!\n\n이 글이 마음에 들었다면 👏 를 클릭해주세요! 제 계정을 팔로우해주시면 감사하겠습니다! 즐겨 보는 부분을 강조하셔도 됩니다. 여러분의 참여가 제 영감입니다!","ogImage":{"url":"/TIL/assets/img/2024-07-14-CrackingtheCodeHowSeniorDevsTackleProgrammingChallenges_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-CrackingtheCodeHowSeniorDevsTackleProgrammingChallenges_0.png","tag":["Tech"],"readingTime":8},{"title":"소비자용 그래픽 카드 하나로 LLMs 미세 조정하는 방법","description":"","date":"2024-07-14 19:45","slug":"2024-07-14-FineTuningLLMsonaSingleConsumerGraphicCard","content":"\n\n## 생성적 AI\n\n![이미지](/TIL/assets/img/2024-07-14-FineTuningLLMsonaSingleConsumerGraphicCard_0.png)\n\n# 배경\n\n대형 언어 모델 또는 다른 생성 모델을 생각할 때, 먼저 떠오르는 하드웨어는 GPU입니다. GPU 없이는 생성적 AI, 기계 학습, 심층 학습, 데이터 과학 등의 많은 발전이 불가능했을 것입니다. 15년 전, 게이머들이 최신 GPU 기술에 열광했다면, 오늘날 데이터 과학자와 기계 학습 엔지니어들도 이 분야의 소식을 따라가며 함께 관심을 가지고 있습니다. 보통 게이머들과 기계 학습 사용자는 서로 다른 종류의 GPU와 그래픽 카드를 사용한다고 볼 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n게임 사용자들은 일반적으로 소비자용 그래픽 카드(예: NVIDIA GeForce RTX 시리즈 GPU)를 사용하고, ML 및 AI 개발자들은 주로 데이터 센터 및 클라우드 컴퓨팅 GPU(예: V100, A100 또는 H100)에 대한 뉴스를 따릅니다. 게임 그래픽 카드는 일반적으로 GPU 메모리가 훨씬 적습니다(2024년 1월 기준 최대 24GB). 반면 데이터 센터 GPU는 일반적으로 40GB에서 80GB 정도의 범위에 있습니다. 또한 가격도 다른 중요한 차이점입니다. 대부분의 소비자용 그래픽 카드의 가격이 최대 3000달러가 될 수 있는 반면, 대부분의 데이터 센터 그래픽 카드는 그 가격부터 시작하여 수십만 달러까지 쉽게 올라갈 수 있습니다.\n\n저를 포함한 많은 사람들이 그래픽 카드를 게임이나 일상적인 용도로 사용할 수 있기 때문에, 같은 그래픽 카드를 사용하여 LLM 모델의 학습, 미세 조정 또는 추론에 사용할 수 있는지 궁금할 수 있습니다. 2020년에 저는 소비자용 그래픽 카드를 데이터 과학 프로젝트에 사용할 수 있는지에 대해 포괄적인 기사를 썼습니다. 당시에는 대부분 작은 ML이나 딥 러닝 모델이었고, 6GB 메모리를 가진 그래픽 카드라도 많은 학습 프로젝트를 처리할 수 있었습니다. 그러나 본 기사에서는 수십억 개의 매개변수를 가진 대형 언어 모델에 이러한 그래픽 카드를 사용할 것입니다.\n\n본 기사에서는 24GB GPU 메모리를 가진 GeForce 3090 RTX 카드를 사용했습니다. 참고로, A100 및 H100과 같은 데이터 센터 그래픽 카드는 각각 40GB 및 80GB의 메모리를 가지고 있습니다. 또한 전형적인 AWS EC2 p4d.24xlarge 인스턴스는 총 320GB의 GPU 메모리를 가진 8개의 GPU(V100)를 가지고 있습니다. 간단한 소비자용 GPU와 전형적인 클라우드 ML 인스턴스 간의 차이가 상당히 크다는 것을 보실 수 있습니다. 그러나 질문은, 우리가 단일 소비자용 그래픽 카드에서 대형 모델을 학습할 수 있는지 여부인데요? 가능하다면, 팁과 교훈은 무엇인가요? 이 기사의 나머지 부분을 읽어보세요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아무런 LLM 모델이나 교육 데이터 집합을로드하기 전에 그러한 프로세스에 필요한 하드웨어 및 소프트웨어를 찾아야합니다.\n\n언급한 바와 같이, 나는 소비자 GPU 중에서도 가장 높은 메모리(24GB) 중 하나를 갖고 있는 NVIDIA GeForce RTX 3090 GPU를 사용했습니다(참고로, 4090 모델도 동일한 메모리 크기를 가지고 있습니다). 이 GPU는 유명한 A100 GPU에 있는 것과 동일한 Ampere 아키텍처를 기반으로 하고 있습니다. GeForce RTX 3090 GPU 사양에 대해 더 자세히 알아볼 수 있습니다.\n\n모든 테스트를 거친 후, 24GB가 10억 개의 매개변수를 갖는 LLM과 작업을 수행하는 데 필요한 최소한의 GPU 메모리라고 생각합니다.\n\n<img src=\"/TIL/assets/img/2024-07-14-FineTuningLLMsonaSingleConsumerGraphicCard_1.png\" />\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그래픽 카드 외에도 PC의 좋은 환기 시스템이 필요합니다. 세밀한 조정 중에 GPU의 온도가 쉽게 올라가고 팬으로는 충분히 식힐 수 없는 경우가 있습니다. 높은 GPU 온도는 GPU 성능을 낮출 수 있고, 처리 시간이 더 오래 걸릴 수 있습니다.\n\n하드웨어 외에도 여기서 언급해야 할 몇 가지 소프트웨어 고려 사항이 있습니다. 먼저, Windows 사용자라면 안타깝게도 나쁜 소식이 있어요. 일부 라이브러리와 도구는 Linux에서만 작동합니다. 특히, 모델 양자화에 자주 사용되는 bitsandbytes는 Windows 친화적이지 않습니다. 어떤 사람들은 Windows용 래퍼를 만들었지만 (예를 들어 여기), 그들은 장단점이 있어요. 그래서 제 추천은 WSL에 Linux를 설치하거나 저와 같이 듀얼 부팅 시스템을 사용하여 LLM 작업 중에 완전히 Linux로 전환하는 것입니다.\n\n또한, PyTorch와 호환되는 CUDA 버전을 설치해야 합니다. 제 추천은 CUDA 12.3을 설치하는 것입니다 (링크). 그런 다음 이 페이지로 이동하여 시스템, CUDA 버전 및 패키지 관리자 시스템에 따라 올바른 PyTorch를 다운로드하고 설치해야 합니다 (https://pytorch.org/).\n\n```js\nexport BNB_CUDA_VERSION=123\nexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/<YOUR-USER-DIR>/local/cuda-12.3\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마지막으로 시스템에 다음 패키지를 설치해야 합니다. 충돌을 피하기 위해 시스템에 이미 설치된 다른 패키지와 충돌을 피하기 위해 새 가상 환경(venv)을 만드는 것을 권장합니다. 또한, 아래는 제가 성공적으로 사용한 패키지 버전들입니다:\n\n```js\ntorch==2.1.2\ntransformers==4.36.2\ndatasests==2.16.1\nbitsandbytes==0.42.0\npeft==0.7.1\n```\n\n# 기술적 배경\n\n이제 시스템에서 LLMs를 사용하기 위해 모든 하드웨어와 소프트웨어를 준비했으니, 다음 섹션에서 마주할 기술적 개념에 대해 매우 간단히 검토하는 것이 좋습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n대형 언어 모델은 수백만 또는 수십억 개의 매개변수로 구성됩니다. 일반적으로 수십억 또는 때로는 수조의 토큰으로 훈련된 사전 훈련된 모델을 사용하는데 굉장히 긴 훈련 과정과 수백만 달러가 들었습니다. 이러한 모델 매개변수 각각은 32비트(4바이트)의 메모리를 차지하고 로드하기 위해 필요합니다. 일반적으로 10억 개의 매개변수당 약 4GB의 메모리가 필요하다고 생각할 수 있습니다. 로드(및 이후 추론 또는 후속 모델 훈련)를 위해 메모리 사용량을 줄이는 한 가지 기술은 \"양자화\"입니다. 이 기술에서는 모델 가중치의 정밀도를 32비트의 완전 정밀도에서 16비트(fp16 또는 bfloat16), 8비트(int8) 또는 그 이하로 줄입니다.\n\n모델 가중치의 정밀도를 줄이면 제한적인 메모리에 더 큰 모델을 로드할 수 있지만 모델 성능을 희생해야 합니다. 그러나 일부 연구에서는 fp32와 bfloat16 간의 모델 성능 차이가 중요하지 않다고 제안하며, 많은 유명한 모델(Llama2 포함)이 bfloat16로 사전 훈련되었습니다.\n\n양자화는 단일 GPU에서 메모리가 24GB인 대형 언어 모델을 세밀하게 조정하거나 추론할 때 반드시 사용해야 하는 기술입니다. 나중에 볼 것처럼 bitsandbytes 라이브러리를 사용하여 모델 양자화를 구현할 수 있습니다.\n\n가장 엄격한 양자화 기술을 사용하더라도 수십억 개의 매개변수를 가진 작은 크기의 LLM 모델을 사전 훈련할 수 없습니다. 크리스 프레글리 등은 최근 발표된 'AWS에서의 생성적 AI' 도서에서 모델 훈련에 필요한 메모리에 대한 좋은 규칙을 설명했습니다. 그들은 모델의 10억 개의 매개변수당 16비트 반 정밀도에서 6GB의 메모리가 필요하다고 설명했죠.\n\n기억해야 할 것은 메모리 크기가 훈련 이야기의 일부일 뿐이라는 점입니다. 사전 훈련을 완료하는 데 필요한 시간도 또 하나의 중요한 측면입니다. 예를 들어 가장 작은 Llama2 모델인 Llama2 7B는 70억 개의 매개변수를 가지고 훈련을 완료하는 데 184320 GPU 시간이 걸렸습니다.\n\n그래서 대부분의 사람들(상당한 하드웨어 자원과 예산을 갖춘 사람들도)는 특정 사용 사례에 맞게 사전 훈련된 모델을 사용하고 세밀하게 조정하려는 경향이 있습니다. 그러나 한정된 자원(예: 단일 GPU)으로 완전한 세밀 조정을 수행하는 것은 다소 어려울 수 있습니다. 이에 따라 모델 매개변수의 한정된 부분만 업데이트하는 \"효율적인 매개 조정\" (PEFT) 이 보다 현실적으로 보입니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다양한 PEFT 기술 중에서, LoRA (Low Ranking Adaption)는 그 계산 효율성으로 매우 인기가 높습니다. 이 기술에서는 원래 모델의 가중치를 모두 고정시키고 대신 Transformer 아키텍처의 특정 레이어에 추가할 수 있는 저랭크 행렬을 학습합니다. LLM을 세세히 조정할 때 LoRA를 사용하는 경우, 모델 가중치의 0.5%를 업데이트합니다.\n\nQLoRA는 저랭크 행렬 LoRA에 우리가 설명한 양자화 개념을 결합한 변형입니다. 특히, QLoRA 구현에서는 모델을 세세히 조정하기 위해 nf4 또는 Normal Float 4를 사용할 것입니다. QLoRA는 단일 소비자 GPU로 대규모 모델을 세세히 조정하는 경우 연구 사례에서 매우 유용합니다.\n\n# 코딩 타임\n\n마지막으로, 이제 코딩할 시간입니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n내 GitHub 리포지토리에서 작동하는 주피터 노트북을 찾을 수 있어요. 이 코드의 많은 부분은 Mathieu Busquet의 깔끔한 글에서 영감을 받아 따랐어요.\n\n코드를 한 줄씩 설명하지는 않겠지만, 단일 GPU에서 대규모 모델을 세밀하게 조정하는 데 중요한 부분을 강조할 거에요.\n\n## 트랜스포머 모델\n\n우선, 이 테스트에 Mistral 7B 모델(mistralai/Mistral-7B-v0.1)을 선택했어요. Mistral AI가 개발한 Mistral 7B 모델은 2023년 9월에 공개된 오픈 소스 LLM이에요 (논문 링크). 많은 측면에서 이 모델은 Llama2와 같은 유명한 모델들을 능가해요 (다음 차트를 참고하세요).\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/TIL/assets/img/2024-07-14-FineTuningLLMsonaSingleConsumerGraphicCard_2.png\" />\n\n## 데이터셋\n\n또한, 저는 fine-tuning을 위해 Databricks databricks-dolly-15k dataset를 사용했어요 (CC BY-SA 3.0 라이선스하에 제공됨). fine-tuning 시간을 줄이기 위해 이 데이터의 작은 부분(1000행)을 사용했고 컨셉을 증명했어요.\n\n## 구성 요소\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모델 로딩 시, GPU 메모리 제한을 극복하기 위해 다음과 같은 양자화 구성을 사용했어요.\n\n```js\nquantization_config = BitsAndBytesConfig(\n    load_in_4bit=True,\n    bnb_4bit_use_double_quant=True,\n    bnb_4bit_quant_type=\"nf4\",\n    bnb_4bit_compute_dtype=torch.bfloat16,\n)\n```\n\n이 양자화 구성은 bfloat16 계산 데이터 유형과 nf4(4비트 Normal Float)인 저정밀 스토리지 데이터 유형을 가지고 있기 때문에 단일 GPU에서 모델 세밀 조정에 매우 중요해요. 실제로는 QLORA 가중치 텐서가 사용될 때, 텐서를 bfloat16로 비양자화하고 16비트에서 행렬 곱셈을 수행하게 됩니다(자세한 내용은 원본 논문 참조).\n\n또한 이전에 언급한 대로, 양자화와 함께 LoRA를 사용하여 메모리 제한을 극복하기 위한 QLoRA를 사용 중이에요. 여기 LoRA를 위한 제 설정입니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nlora_config = LoraConfig(\n    r=16,\n    lora_alpha=64,\n    target_modules=[\"q_proj\", \"k_proj\", \"v_proj\", \"o_proj\", \"gate_proj\"],\n    bias=\"none\",\n    lora_dropout=0.05,\n    task_type=\"CAUSAL_LM\",\n)\n```\n\n제 LoRA 구성에는 랭크로 16을 사용했어요. 4부터 16 사이의 랭크로 설정하는 것이 학습 가능한 매개변수의 수를 줄이고 모델 성능 사이의 적절한 균형을 얻기 위해 권장됩니다. 마지막으로, Mistral 7B 트랜스포머 모델의 일부 선형 계층에 LoRA를 적용했습니다.\n\n# 학습 및 모니터링\n\n제 개인적인 그래픽 카드를 사용하여 4 에포크 (1000 단계)의 학습을 완료할 수 있었어요. 지역 GPU에서 LLM을 학습하는 이러한 테스트 중 하나의 목적은 어떠한 제한 없이 하드웨어 리소스를 모니터링하는 것이에요. 학습 중 GPU를 모니터링하는 가장 간단한 도구 중 하나는 Nvidia 시스템 관리 인터페이스 (SMI)입니다. 단순히 터미널을 열고 명령줄에 다음을 입력하세요:\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nnvidia-smi\n```\n\n또는 지속적인 모니터링과 업데이트를 위해 다음을 사용하세요 (1초마다 새로고침):\n\n```js\nnvidia-smi -l 1\n```\n\n이렇게 하면 GPU에서 각 프로세스의 메모리 사용량을 확인할 수 있습니다. 다음 SMI 보기에서 저는 모델을 불러왔고 약 5GB의 메모리를 사용했습니다 (양자화 덕분에). 또한 Anaconda3 Python (Jupyter 노트북) 프로세스로 모델이 불러와진 것을 확인할 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n+---------------------------------------------------------------------------------------+\n| NVIDIA-SMI 545.23.08              Driver Version: 545.23.08    CUDA Version: 12.3     |\n|-----------------------------------------+----------------------+----------------------+\n| GPU  Name                 Persistence-M | Bus-Id        Disp.A | Volatile Uncorr. ECC |\n| Fan  Temp   Perf          Pwr:Usage/Cap |         Memory-Usage | GPU-Util  Compute M. |\n|                                         |                      |               MIG M. |\n|=========================================+======================+======================|\n|   0  NVIDIA GeForce RTX 3090        On  | 00000000:29:00.0  On |                  N/A |\n| 30%   37C    P8              33W / 350W |   5346MiB / 24576MiB |      5%      Default |\n|                                         |                      |                  N/A |\n+-----------------------------------------+----------------------+----------------------+\n                                                                                         \n+---------------------------------------------------------------------------------------+\n| Processes:                                                                            |\n|  GPU   GI   CI        PID   Type   Process name                            GPU Memory |\n|        ID   ID                                                             Usage      |\n|=======================================================================================|\n|    0   N/A  N/A      1610      G   /usr/lib/xorg/Xorg                          179MiB |\n|    0   N/A  N/A      1820      G   /usr/bin/gnome-shell                         41MiB |\n|    0   N/A  N/A    108004      G   ...2023.3.3/host-linux-x64/nsys-ui.bin        8MiB |\n|    0   N/A  N/A    168032      G   ...seed-version=20240110-180219.406000      117MiB |\n|    0   N/A  N/A    327503      C   /home/***/anaconda3/bin/python             4880MiB |\n+---------------------------------------------------------------------------------------+\n```\n\n그리고 이곳은 훈련 과정 중 약 30단계 이후의 메모리 상태입니다. 보시다시피, 사용 중인 GPU 메모리는 현재 약 15GB입니다.\n\n```js\n+---------------------------------------------------------------------------------------+\n| NVIDIA-SMI 545.23.08              Driver Version: 545.23.08    CUDA Version: 12.3     |\n|-----------------------------------------+----------------------+----------------------+\n| GPU  Name                 Persistence-M | Bus-Id        Disp.A | Volatile Uncorr. ECC |\n| Fan  Temp   Perf          Pwr:Usage/Cap |         Memory-Usage | GPU-Util  Compute M. |\n|                                         |                      |               MIG M. |\n|=========================================+======================+======================|\n|   0  NVIDIA GeForce RTX 3090        On  | 00000000:29:00.0  On |                  N/A |\n| 30%   57C    P2             341W / 350W |  15054MiB / 24576MiB |    100%      Default |\n|                                         |                      |                  N/A |\n+-----------------------------------------+----------------------+----------------------+\n                                                                                         \n+---------------------------------------------------------------------------------------+\n| Processes:                                                                            |\n|  GPU   GI   CI        PID   Type   Process name                            GPU Memory |\n|        ID   ID                                                             Usage      |\n|=======================================================================================|\n|    0   N/A  N/A      1610      G   /usr/lib/xorg/Xorg                          179MiB |\n|    0   N/A  N/A      1820      G   /usr/bin/gnome-shell                         40MiB |\n|    0   N/A  N/A    108004      G   ...2023.3.3/host-linux-x64/nsys-ui.bin        8MiB |\n|    0   N/A  N/A    168032      G   ...seed-version=20240110-180219.406000      182MiB |\n|    0   N/A  N/A    327503      C   /home/***/anaconda3/bin/python            14524MiB |\n+---------------------------------------------------------------------------------------+\n```\n\nSMI는 GPU 메모리 사용량을 모니터링하는 간단한 도구이지만, 더 자세한 정보를 제공하는 고급 모니터링 도구들도 몇 가지 있습니다. 그 중 하나가 PyTorch Memory Snapshot인데, 이에 관해 더 읽어볼 수 있는 흥미로운 기사가 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 개요\n\n본 문서에서는 Mistral 7B와 같은 대규모 언어 모델을 단일 24GB GPU(예: NVIDIA GeForce RTX 3090 GPU)에서 세밀하게 조정할 수 있는 것을 보여드렸습니다. 그러나 자세히 설명한 대로 QLoRA와 같은 특별한 PEFT 기술이 필요합니다. 또한 모델의 배치 크기가 중요하며, 한정된 자원 때문에 보다 오랜 시간의 훈련이 필요할 수 있습니다.","ogImage":{"url":"/TIL/assets/img/2024-07-14-FineTuningLLMsonaSingleConsumerGraphicCard_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-FineTuningLLMsonaSingleConsumerGraphicCard_0.png","tag":["Tech"],"readingTime":15},{"title":"데이터 사이언티스트 인터뷰 꼭 알아야 할 10가지 질문과 답변","description":"","date":"2024-07-14 19:44","slug":"2024-07-14-DataScientistInterview10EssentialQuestionsandAnswers","content":"\n\n데이터 과학자 인터뷰 준비는 어려운 작업일 수 있습니다. 데이터 과학은 프로그래밍, 통계, 데이터 분석 및 도메인 지식을 결합한 다학제적 분야입니다. 다음 데이터 과학자 인터뷰에서 성공하도록 도와 드리기 위해 핵심 개념 및 기술을 평가하는 이러한 인터뷰에서 일반적으로 평가되는 10가지 중요 질문과 답변 목록을 작성했습니다.\n\n![이미지](/TIL/assets/img/2024-07-14-DataScientistInterview10EssentialQuestionsandAnswers_0.png)\n\n# 질문 1: 데이터 과학, 데이터 분석 및 기계 학습과 어떻게 다른가요?\n\n답변: 데이터 과학은 다양한 기술과 도구를 사용하여 데이터에서 가치 있는 통찰과 지식을 추출하는 분야입니다. 데이터 분석과 기계 학습을 포함하지만 그 이상을 다룹니다. 데이터 분석은 데이터를 탐색하고 요약하는 데 중점을 두는 반면, 기계 학습은 예측 모델을 구축하는 데 관심이 있습니다. 데이터 과학은 데이터 수집 및 정리부터 분석, 모델링 및 배포에 이르기까지 전체 데이터 수명주기를 포함합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 질문 2: 데이터 과학 과정을 설명해주세요.\n\n답변: 데이터 과학 과정은 일반적으로 다음 단계를 포함합니다:\n\n- 문제 정의: 해결하고자 하는 문제를 명확히 정의합니다.\n- 데이터 수집: 다양한 소스에서 관련 데이터를 수집합니다.\n- 데이터 정제 및 전처리: 데이터를 정리, 형식화하고 분석을 위해 준비합니다.\n- 탐색적 데이터 분석 (EDA): 데이터를 탐색하여 특성을 이해합니다.\n- 피처 엔지니어링: 모델 성능을 개선하기 위해 새로운 기능을 만들거나 기존 기능을 변환합니다.\n- 모델링: 머신 러닝 모델을 구축하고 훈련합니다.\n- 평가: 적절한 지표를 사용하여 모델 성능을 평가합니다.\n- 배포: 모델을 실제 제품에 적용합니다.\n- 모니터링 및 유지보수: 모델의 성능을 지속적으로 모니터링하고 필요한 경우 업데이트합니다.\n\n# 질문 3: 과적합(Overfitting)은 무엇이며, 어떻게 예방할 수 있나요?\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n답변: 과적합은 기계 학습 모델이 훈련 데이터에서는 잘 수행하지만 보이지 않는 데이터(테스트 데이터)에서는 성능이 저하되는 현상을 말합니다. 과적합을 방지하기 위해 다음을 시도할 수 있습니다:\n\n- 더 많은 훈련 데이터 사용하기.\n- 모델을 간단하게 만들기 (예: 복잡성 줄이기).\n- L1 또는 L2 정규화와 같은 정규화 기법 사용.\n- 모델 성능 평가를 위해 교차 검증 사용.\n- 랜덤 포레스트나 그레디언트 부스팅과 같은 앙상블 방법을 사용하여 과적합 완화 가능.\n\n# 질문 4: 군집화에서 사용되는 일반적인 거리 측정 방법은 무엇인가요?\n\n답변: 군집화에서 사용되는 일반적인 거리 측정 방법에는 다음이 있습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 유클리드 거리: 데이터 포인트 사이의 직선 거리를 측정합니다.\n- 맨해튼 거리: 좌표 사이의 절대 차이의 합을 계산합니다.\n- 코사인 유사도: 두 벡터 사이의 각도의 코사인을 측정합니다.\n- 자카드 유사도: 두 집합의 교집합 크기를 두 집합의 합집합 크기로 나누어 계산합니다.\n- 마할라노비스 거리: 데이터 내의 상관 관계를 고려합니다.\n- 해밍 거리: 이진 데이터에 사용되며 다른 비트를 계산합니다.\n\n# 질문 5: 편향-분산 균형을 설명해주세요.\n\n답변: 편향-분산 균형은 기계 학습에서 근본적인 개념입니다. 이는 모델이 훈련 데이터를 잘 맞추는 능력(낮은 편향)과 보이지 않는 데이터에 일반화하는 능력(낮은 분산) 사이의 균형을 의미합니다.\n\n- 높은 편향: 모델이 높은 편향을 가지면 데이터를 잘 적합하지 못해 기본적인 패턴을 파악하지 못합니다.\n- 높은 분산: 모델이 높은 분산을 가지면 과도하게 복잡하며 데이터의 잡음을 적합하게 되어 부적절한 일반화로 이어집니다. 편향과 분산 사이의 적절한 균형을 찾는 것은 훈련 및 테스트 데이터 모두에서 잘 수행하는 모델을 구축하는 데 중요합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 질문 6: 교차 검증이 무엇이며 왜 중요한가요?\n\n답변: 교차 검증은 모델의 성능을 평가하는 데 사용되는 기술입니다. 데이터를 여러 하위 집합(폴드)으로 나누고 각각의 하위 집합에서 모델을 학습하고 나머지 데이터에서 모델을 평가하는 것을 포함합니다. 교차 검증은 모델의 성능에 대한 보다 견고한 추정을 제공하여 오버피팅과 같은 문제를 감지하는 데 도움이 됩니다. 일반적인 교차 검증 유형에는 k-겹 교차 검증과 LOOCV(leave-one-out cross-validation)가 있습니다.\n\n# 질문 7: 일부 특성 선택 기술은 무엇인가요?\n\n답변: 특성 선택은 모델 성능을 향상시키고 차원을 축소하기 위해 관련 특성의 하위 집합을 선택하는 프로세스입니다. 기술에는 다음이 포함됩니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 필터 방법: 모델과 독립적으로 기능을 평가합니다 (예: 카이제곱 테스트).\n- 래퍼 방법: 특정 모델을 사용하여 기능 부분집합을 평가합니다 (예: 재귀적 기능 제거).\n- 임베디드 방법: 기능 선택이 모델 학습 과정에 통합됩니다 (예: L1 정규화).\n\n## 질문 8: A/B 테스트란 무엇이며 결과를 어떻게 분석하나요?\n\n답변: A/B 테스트는 두 가지 버전(A 및 B)의 웹페이지, 앱 또는 제품을 비교하여 어떤 것이 더 나은 성능을 발휘하는지 결정하는 방법입니다. 결과를 분석하기 위해 일반적으로 t-검정이나 카이제곱 검정과 같은 통계적 가설 검정을 사용하여 관찰된 차이가 통계적으로 유의한지 평가합니다. 또한 실용적인 중요성과 샘플 크기, 테스트 기간과 같은 요인을 고려합니다.\n\n## 질문 9: 머신러닝에서 정규화 개념을 설명해주세요.  \n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n답변: Regularization은 오버피팅을 방지하기 위해 모델의 손실 함수에 패널티 항을 추가하는 기술입니다. 두 가지 일반적인 유형은 L1 정규화(Lasso)와 L2 정규화(Ridge)입니다. L1 정규화는 계수의 절대값을 손실에 추가하여 희소한 해를 장려합니다. L2 정규화는 계수의 제곱을 추가하여 극단적인 값이 나오지 않도록 합니다. 정규화는 모델 복잡성을 제한하는 데 도움이 됩니다.\n\n# 질문 10: 파이썬에서 일반적인 데이터 시각화 라이브러리는 무엇입니까?\n\n답변: 파이썬에서 일반적인 데이터 시각화 라이브러리로는 Matplotlib, Seaborn, Plotly 및 Bokeh가 있으며 정적 및 대화식 플롯을 지원합니다. 특수한 시각화를 위해 NetworkX(네트워크 그래프용) 및 Folium(대화식 지도용)과 같은 라이브러리도 사용됩니다.\n\n마지막으로, 이러한 질문과 답변은 데이터 과학과 기계 학습의 기본 주제를 다루며 일반적으로 면접에서 탐구됩니다. 이러한 질문에 대비하여 준비를 하면 면접에서 잘할 뿐만 아니라 데이터 과학의 중요한 개념에 대한 이해를 더욱 깊게 할 수 있습니다. 기술 면접에 코딩 문제도 자주 포함되므로 코딩과 문제 해결 능력에 대한 연습도 중요합니다. 데이터 과학자 면접 준비를 잘 하시기 바랍니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 파이썬 기초\n\n시간 내어 관심 가져 주셔서 감사합니다! 🚀\n더 많은 콘텐츠는 Python Fundamentals에서 찾을 수 있어요 💫","ogImage":{"url":"/TIL/assets/img/2024-07-14-DataScientistInterview10EssentialQuestionsandAnswers_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-DataScientistInterview10EssentialQuestionsandAnswers_0.png","tag":["Tech"],"readingTime":6},{"title":"지리 공간 빅 데이터를 활용한 짧은 영상 제작을 위한 긴 Python 스크립트","description":"","date":"2024-07-14 19:43","slug":"2024-07-14-ALongPythonScripttoMakeaShortVideoUsingGeospatialBigData","content":"\n\n\n![이미지](/TIL/assets/img/2024-07-14-ALongPythonScripttoMakeaShortVideoUsingGeospatialBigData_0.png)\n\n# 목차\n\n- 🌟 소개\n- 🔍 설정: 설치 및 라이브러리 임포트\n- ⏳ \"NetCDF\" 파일의 쿼리 및 처리\n- 🗺️ 캘리포니아 지역 및 NDVI 지도 플로팅을 위한 이미지 클리핑\n- 🎥 NDVI 지도를 비디오로 내보내기\n- 📝 결론\n- 📚 참고 자료\n\n## 🌟 소개\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n원하는 곳에서 매일 또는 매주 촬영된 위성 이미지를 기반으로 동영상과 애니메이션을 만드는 것을 즐기며 대규모 지리 공간 데이터를 시각화하는 일에 깊은 열정을 갖고 있습니다. 그러나 이 많은 양의 이미지를 처리하는 것은 다운로드, 클리핑, 위성 이미지 표시 등의 단계를 거치기 때문에 시간이 많이 걸립니다. 이 과정에는 API, 코딩, 지리 데이터에 대한 심도 있는 이해, 데이터 시각화에 대한 뛰어난 기술이 필요합니다. 이 이야기는 '위에 언급된 모든' 기술의 조합에 관한 것입니다.\n\n다른 게시물에서 Sentinel-2 및 Sentinel-3 이미지의 시각화에 대해 작성하던 중, 이 중 하나의 위성이 특정 위치 위에서 촬영한 모든 이미지를 모아 애니메이션으로 제시하는 아이디어에 주목했습니다. 오늘은 이 비전을 실현하고 2023년 캘리포니아 위에서 캡처된 Sentinel-3의 NDVI 맵을 탐색해보는 날입니다!\n\n이 이야기에서는 이러한 NDVI 맵을 처리, 시각화하고 애니메이션을 만들기 위해 Google Colab에서 강력한 Python 스크립트를 작성할 것입니다. 여기서는 이미지 다운로드 부분을 다루지 않습니다. 이미 별도의 이야기에서 자세히 다루었기 때문에 해당 링크에서 확인할 수 있습니다:\n\n## 🔍 설정: 설치 및 라이브러리 가져오기\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n첫 번째 단계는 다음 폴더를 생성하는 것입니다: NetCDF, Geotiff, Geotiff_reproj, Geotiff_reproj_clipped, Shapefile, JPEG 및 Animation. 다음과 같이 수행할 수 있습니다:\n\n```js\nimport os\n\n# 폴더 이름 정의\nfolders = ['NetCDF', 'Geotiff', 'Geotiff_reproj', 'Geotiff_reproj_clipped', 'Shapefile', 'JPEG', 'Animation']\n\n# 폴더 생성\nfor folder in folders:\n    if not os.path.exists(folder):\n        os.makedirs(folder)\n\n# 확인 메시지 출력\nprint('폴더가 성공적으로 생성되었습니다!')\n```\n\n<img src=\"/TIL/assets/img/2024-07-14-ALongPythonScripttoMakeaShortVideoUsingGeospatialBigData_1.png\" />\n\nNetCDF 폴더는 Sentinel-3 NDVI의 raw 데이터를 저장합니다. 추가로, Geotiff, Geotiff_reproj, Geotiff_reproj_clipped 폴더는 래스터 파일, 재투영된 래스터 파일 및 래스터 파일 클립을 GeoTIFF 형식으로 저장하기 위해 생성됩니다 (모두 NetCDF 파일에서 변환된 형식). Shapefile 폴더에는 캘리포니아 형태 파일(우리의 관심 영역(AOI)로 Sentinel-3 이미지 클리핑을 위해)이 포함되어 있습니다. JPEG 폴더는 NDVI 맵을 \".jpg\" 형식으로 저장하기 위해 생성되며, Animation 폴더는 최종 비디오를 저장하기 위해 특별히 생성되었습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n또한, Google Colab에 몇 가지 라이브러리를 설치하고 가져와야 합니다.\n\n```js\npip install pandas rasterio netCDF4 rioxarray\n```\n\n```js\nimport os\nimport re\nimport sys\nimport random\nfrom pathlib import Path\n\nimport requests\nimport json\nimport xml.etree.ElementTree as ET\nimport certifi\n\nimport pandas as pd\nimport numpy as np\n\nimport rasterio\nimport matplotlib.pyplot as plt\nimport matplotlib.image\nfrom rasterio.windows import Window\n\nimport netCDF4 as nc\n\nimport rioxarray\n\nfrom rasterio.control import GroundControlPoint\n```\n\n## ⏳ \"NetCDF\" 파일의 쿼리 및 처리\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 단계는 쿼리를 제출하고 시작 날짜, 종료 날짜 및 AOI를 지정하는 것입니다. NDVI 지도는 토양 표면 온도 수준의 부수 데이터이므로, 여전히 레벨 변수로 \"LST\"를 사용할 수 있습니다. 미국의 다른 주에 대한 애니메이션을 만들고 싶다면, AOI 지점이나 폴리곤을 해당하도록 수정하세요. 또한, 시작 날짜와 종료 날짜로 2023년 5월 1일 및 8월 1일을 고려해보세요. 다음과 같은 줄로 이 작업을 수행할 수 있습니다:\n\n```js\nurl_dataspace = \"https://catalogue.dataspace.copernicus.eu/odata/v1\"\n\n# 필터링\nsatellite = \"SENTINEL-3\"\nlevel= \"LST\"\n\naoi_point =\"POINT(-121.669668 38.372428)\"\n#aoi_polygon = \"POLYGON ((-121.0616 37.6391, -120.966 37.6391, -120.966 37.6987, -121.0616 37.6987, -121.0616 37.6391))\"\n\nstart_date = \"2023-05-01\"\nend_date = \"2023-08-01\"\nstart_date_full =start_date+\"T00:00:00.000Z\"\nend_date_full = end_date +\"T00:00:00.000Z\"\n```\n\n이 정보를 통해 쿼리를 제출할 준비가 되었습니다. 데이터베이스에서 사용 가능한 이미지 목록을 내보내야 하므로, 쿼리 끝에 \"&$top=1000&$expand=Attributes\"를 포함해야 합니다. 이는 데이터베이스에서 이미지 내보내기의 기본 수가 20이며, 2023년에 Sentinel-3가 촬영한 이미지 수가 20을 초과하기 때문에 필요합니다:\n\n```js\nquery = f\"{url_dataspace}/Products?$filter=Collection/Name eq '{satellite}' and Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'productType' and att/OData.CSC.StringAttribute/Value eq '{level}') and OData.CSC.Intersects(area=geography'SRID=4326;{aoi_point}') and ContentDate/Start gt {start_date_full} and ContentDate/Start lt {end_date_full}&$top=1000&$expand=Attributes\"\nresponse = requests.get(query).json()\nresult = pd.DataFrame.from_dict(response[\"value\"])\n\n# 'Online' 열이 True인 레코드 필터링\nresult = result[result['Online'] == True]\n\n# 처음 10개 결과 출력\nresult.head(10)\n\nresult.to_csv('result_LST.csv', index=False)\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 단계에서는 온라인에서 사용 가능한 이미지 목록을 필터링하여 정오쯤 촬영된 이미지에 특히 주목할 것입니다. 파일의 감지 시간은 UTM을 기준으로 하기 때문에 18:00:00은 태평양 표준시 (캘리포니아 시간) 기준으로 대략 12:00:00 오후에 해당합니다:\n\n```js\nfiltered_df = result[result[\"Name\"].str.split(\"_\").str[8].str.contains(\"T18\") & result[\"Name\"].str.split(\"_\").str[14].str.contains(\"PS2\") & result[\"Name\"].str.split(\"_\").str[16].str.contains(\"NT\")]\n\nfiltered_df = filtered_df.reset_index(drop=True)\n\nprint(filtered_df['Name'])\n```\n\n```js\nfiltered_df.to_csv('result_LST_Filtered.csv', index=False)\n```\n\n필터링된 데이터프레임을 기반으로, 2023년 5월 1일부터 8월 1일까지 캘리포니아 상공에서 촬영된 Sentinel-3의 53장의 이미지가 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/TIL/assets/img/2024-07-14-ALongPythonScripttoMakeaShortVideoUsingGeospatialBigData_2.png\" />\n\n이미지가 흐릿할 수 있다는 점을 기억하세요. 센티넬-3 이미지를 구름 덮개로 걸러내는 것을 제어할 수 없기 때문입니다.\n\n다음 단계는 필터링된 목록의 제품 ID를 사용하여 NetCDF 파일을 다운로드하는 것을 포함합니다. 이 부분은 이미 다음 포스트의 섹션들(📥 \"NetCDF\" 파일 다운로드 및 🛠️ Geotiff로 변환)에서 설명된 자료의 중복을 피하기 위해 건너뛰었습니다:\n\n## 🗺️ 캘리포니아를 위한 이미지 클리핑과 NDVI 지도 플로팅\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 단계를 자세히 설명하기 전에 다음 패키지를 설치하고 로드해주세요:\n\n```js\npip install matplotlib-scalebar\n```\n\n```js\nimport os\nimport matplotlib.pyplot as plt\nfrom matplotlib import colors\nfrom mpl_toolkits.axes_grid1 import make_axes_locatable\nfrom mpl_toolkits.axes_grid1.inset_locator import inset_axes\nfrom matplotlib_scalebar.scalebar import ScaleBar\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom datetime import datetime\nimport rasterio.plot\n```\n\n이 단계에서는 Geotiff_reproj 폴더에 저장된 53개의 래스터 파일 각각을 읽어올 것입니다. 캘리포니아 쉐이프파일 투영과 래스터 파일 간의 일관성을 확인할 것입니다. 필요한 경우 쉐이프파일을 재투영할 것입니다. 그런 다음, 래스터 파일을 캘리포니아의 경계에 맞게 자릅니다. 해당 플롯을 플로팅하고 JPEG 폴더에 저장할 것입니다. 캘리포니아 쉐이프파일을 다운로드하려면 다음 URL을 방문하여 \"California State Boundry\"를 다운로드하고 Shapefile 폴더에 업로드해주세요:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n[California Geographic Boundaries](https://data.ca.gov/dataset/ca-geographic-boundaries)\n\n![Image](/TIL/assets/img/2024-07-14-ALongPythonScripttoMakeaShortVideoUsingGeospatialBigData_3.png)\n\nThe following code also requires an image for the north arrow symbol. You can either download one from the internet or, like me, draw it in PowerPoint, save it, and upload it to your main folder.\n\n![Image](/TIL/assets/img/2024-07-14-ALongPythonScripttoMakeaShortVideoUsingGeospatialBigData_4.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n맵에 이 아이콘이 표시되는 것은 완전히 선택 사항입니다. 맵에 북쪽 화살표를 표시하고 싶지 않다면 해당 섹션을 주석 처리할 수 있습니다:\n\n```js\n# 디렉토리 경로 설정\ndirectory = '/content/Geotiff_reproj_clipped/'\n\n\n# 디렉토리 내 모든 파일 목록 가져오기\nfiles = os.listdir(directory)\n\n# NDVI TIF 파일만 포함하는 목록 필터링\nndvi_files = [f for f in files if f.endswith('.tif')]\n\n\n# 색상 한계 설정\nvmin = 0\nvmax = 1\nndvi_norm = colors.Normalize(vmin, vmax)\nndvi_cmap = plt.cm.RdYlGn\nndvi_cmap.set_bad(color='white')\n\n# 각각의 NDVI 파일을 루프하여 플롯하기\nfor ndvi_file in ndvi_files:\n    print(ndvi_file)\n    date_str = ndvi_file.split('_')[0]\n    date_obj = datetime.strptime(date_str, \"%Y%m%d\")\n    formatted_date_str = date_obj.strftime(\"%Y/%-m/%-d\")\n\n    # NDVI 래스터 열기\n    with rasterio.open(f\"/content/Geotiff_reproj_clipped/{ndvi_file}\") as ndvi:\n      # shapefile 읽기\n      california_shapefile = gpd.read_file('/content/Shapefile/CA_State_TIGER2016.shp')\n\n      ndvi_data = ndvi.read(1).astype(float)\n      ndvi_data[ndvi_data<=-1]=np.nan\n      ndvi_crs = ndvi.crs\n      extent = rasterio.plot.plotting_extent(ndvi)\n\n      # shapefile을 래스터의 투영과 일치하도록 재투영\n      california_shapefile = california_shapefile.to_crs(ndvi_crs)\n\n\n    # 플롯 생성\n    fig, ax = plt.subplots(figsize=(10, 6))\n\n    \n    image= rasterio.plot.show(ndvi_data, ax=ax, extent=extent, alpha=1, cmap=ndvi_cmap,norm=ndvi_norm,)\n    im = image.get_images()[0]  # 컬러바에 대한 트릭 (rasterio.plot.show와 호환되지 않음)\n    fig.colorbar(im, ax=ax)\n   \n\n    ax.set_title(formatted_date_str, fontsize=16,fontweight='bold')\n    california_shapefile.boundary.plot(ax=ax, color='k', linewidth=1)\n\n    ax.set_xticklabels([])\n    ax.set_yticklabels([])\n\n    # 북쪽 화살표 추가\n    north_arrow_image = plt.imread('North_sign.png')\n    imagebox = OffsetImage(north_arrow_image, zoom=0.25)\n    ab = AnnotationBbox(imagebox, (0.8, 0.99), xycoords='axes fraction', box_alignment=(0, 1), frameon=False)\n    ax.add_artist(ab)\n\n    # 스케일 바 추가\n    scalebar = ScaleBar(1000, 'm', length_fraction=0.2, location='lower right', font_properties={'size':12})\n    ax.add_artist(scalebar)\n\n    # 맵 주변에 네모 상자 끄기\n    ax.axis('off')\n\n    # 플롯을 JPEG 파일로 저장\n    plt.savefig(os.path.join('/content/JPEG', ndvi_file.split('_')[0] + '.jpg'), dpi=300, bbox_inches='tight')\n\n    # 메모리 해제를 위해 플롯 닫기\n    plt.close(fig)\r\n```\n\n이 단계를 완료하면 \"JPEG\" 폴더에 센싱 날짜를 기준으로 저장된 53개의 NDVI 지도가 있게 될 것입니다:\n\n<img src=\"/TIL/assets/img/2024-07-14-ALongPythonScripttoMakeaShortVideoUsingGeospatialBigData_5.png\" />\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 🎥 NDVI 지도를 비디오로 내보내기\n\n3개월 동안 센티넬-3에 의해 촬영된 53개의 NDVI 지도(대략 매 2일마다 1장씩)를 사용하여, 2023년 캘리포니아 지역 전체의 NDVI 패턴과 변화를 보여주는 애니메이션을 만들 수 있습니다. 이 비디오를 생성하려면, 다음 스크립트를 실행하세요:\n\n```js\npip install pillow\n```\n\n```js\nfrom PIL import Image\nimport os\nimport glob\n\n# 'path/to/folder'를 여러분의 jpg 이미지가 저장된 폴더 경로로 교체하세요\nfolder_path = '/content/JPEG'\noutput_gif = os.path.join('/content/Animation', 'NDVI_animation.gif')\n\n# 폴더 내 모든 jpg 파일의 정렬된 목록을 가져옵니다\nfile_list = sorted(glob.glob(os.path.join(folder_path, '*.jpg')))\n\n# 이미지의 원하는 크기를 설정합니다\nwidth, height = 1000, 1000\n\n# 이미지를 읽어서 리스트에 저장합니다\nframes = []\nfor file in file_list:\n    frame = Image.open(file)\n\n    # 이미지 크기 조정\n    frame = frame.resize((width, height), Image.ANTIALIAS)\n\n    # 이미지에 흰색 배경 추가\n    background = Image.new('RGB', frame.size, (255, 255, 255))\n    background.paste(frame)\n    frame = background.convert('RGB')\n\n    # 이미지를 P 모드로 변환하고 전역 색상 테이블을 사용합니다\n    frame = frame.convert('P', palette=Image.ADAPTIVE, colors=256)\n    frames.append(frame)\n\n# 애니메이션 GIF로 프레임을 저장합니다\nif frames:\n    frames[0].save(\n        output_gif,\n        save_all=True,\n        append_images=frames[1:],\n        duration=500,  # 프레임 간 지속 시간(밀리초)을 설정합니다\n        loop=0,  # 루프 횟수를 설정합니다 (0은 무한을 의미합니다)\n        optimize=True,\n    )\nelse:\n    print(\"jpg 파일을 찾을 수 없습니다.\")\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n작업이 완료되면 화면에서 만들어진 지퍼 영상을 다운로드하여 시청할 수 있어요!\n\n![이미지](https://miro.medium.com/v2/resize:fit:1000/1*B8CQ1b8hgqEPrGj33oxrzQ.gif)\n\n구름이 가려져 있기 때문에 지도 내 몇 군데는 흰색 영역으로 표시됩니다. 또한 특정 날짜에 캘리포니아의 모든 영역을 커버하지 않아 일부 이미지가 잘려 나와 있을 수 있습니다. 프레임이 너무 빨리 변경되는 것 같다면, 각 프레임 간의 지속 시간을 조절할 수 있어요. 긴 스크립트를 작성한 후에는 이 아름다운 짧은 애니메이션을 즐기시기 바랍니다.\n\n## 📝 결론\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n요약하자면, 상상력을 데이터 시각화와 코딩을 통해 현실화하는 것은 때로는 꽤 많은 시간을 소요할 수 있습니다. 이 이야기에서는 50초짜리 비디오를 만들기 위해 300줄 이상의 코드를 작성했습니다. 상당한 시간 투자에도 불구하고, 그 노력은 가치가 있다고 믿습니다. 지도의 순차적인 표현은 숨겨진 패턴과 동적 변화를 드러내며 더 많은 탐구를 유도할 수 있습니다. 예를 들어, 이 이야기에서는 6월 이전의 NDVI 변동성 관측과 6월 중순부터 7월까지 안정화된 모습이 우리에게 추가적인 질문을 던지며 더 많은 조사와 답을 발견하도록 동기부여합니다.\n\n## 📚 참고 자료\n\nhttps://documentation.dataspace.copernicus.eu/APIs/OData.html\n\n- 📱 더 많은 상호작용이 있는 콘텐츠를 위해 다른 플랫폼에서 저와 연결하세요! LinkedIn, ResearchGate, Github, 그리고 Twitter.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n해당 링크를 통해 관련 게시물을 확인할 수 있습니다:","ogImage":{"url":"/TIL/assets/img/2024-07-14-ALongPythonScripttoMakeaShortVideoUsingGeospatialBigData_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-ALongPythonScripttoMakeaShortVideoUsingGeospatialBigData_0.png","tag":["Tech"],"readingTime":15},{"title":"상호작용 Python Plotly GIS 지도 제작을 위한 더 나은 GPT-4 프롬프트 작성 방법","description":"","date":"2024-07-14 19:41","slug":"2024-07-14-BetterGPT-4PromptingForInteractivePythonPlotlyGISMaps","content":"\n\n\n![TIL image 0](/TIL/assets/img/2024-07-14-BetterGPT-4PromptingForInteractivePythonPlotlyGISMaps_0.png)\n\n인터넷에는 역사적인 난파선 데이터를 포함한 데이터 세트에 대한 멋진 자료가 많이 있습니다.\n\n사용 가능한 데이터 세트에 대한 나의 지식 확장의 일환으로 매주 업데이트를 받는 소스 중 하나로 Data is Plural이 있습니다:\n\n![TIL image 1](/TIL/assets/img/2024-07-14-BetterGPT-4PromptingForInteractivePythonPlotlyGISMaps_1.png)\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 사이트는 흥미로운 데이터 세트에 관한 주간 뉴스레터를 제공합니다.\n\n가장 최근 버전 (2024년 7월 10일)에는 하버드 대학교에서 가져온 고대 바다 난파선에 관한 데이터 세트가 있습니다. 이 데이터 세트에는 기원전 1500년부터 기원후 1500년까지의 기록이 포함되어 있으며 지중해와 북유럽을 중심으로 하고 있습니다. 정말 멋져요!\n\n저는 이 데이터 세트를 GPT-4에 업로드하여 각 포인트 데이터를 지도에 배치하는 Python 코드를 생성할 수 있는지 궁금했습니다.\n\n답변은? 네, 가능합니다. 다만 주의해서 프롬프트를 할 필요가 있습니다. 여기서 저가 거친 단계를 안내해 드리겠습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 제네릭 GPT-4 프롬프트로 시작하기\n\n우선, GPT-4가 데이터 세트를 의미있는 방식으로 해석할 수 있는지 확인해보고 싶었습니다. GIS 지도 코드를 생성할 수 있는지 보기 위한 일반적인 프롬프트입니다.\n\nGPT-4에 대한 프롬프트: 첨부된 데이터 세트를 사용하여, 각 난파선을 지도상의 점으로 표시하는 전역 지도의 파이썬 코드를 제공해주세요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/TIL/assets/img/2024-07-14-BetterGPT-4PromptingForInteractivePythonPlotlyGISMaps_2.png)\n\n이거 그래프네요! 신기하게도 각 포인트들이 정확해요. 아래에 지도 레이어를 넣으면 정확하게 매칭돼요. 그런데, 이건 우리가 원하는 게 아니에요.\n\n첫 번째 제네릭 프롬프가 반 성공했어요. 여기서 더 구체적으로 알아보아야 해요.\n\nGPT-4에게 프롬프트를 보내면: \"이건 지도가 아니에요. 각 포인트를 실제 지도에 표시하는 파이썬 코드를 생성해 주세요.\"\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이번에는 GPT-4가 matplotlib 및 shapely 라이브러리를 사용하여 Python 코드를 생성했습니다. 결과는 다음과 같습니다:\n\n![이미지](/TIL/assets/img/2024-07-14-BetterGPT-4PromptingForInteractivePythonPlotlyGISMaps_3.png)\n\n이제 지도를 가지고 있지만, 이 지도는 완전히 정적입니다. 확대 및 축소가 불가능하며 상호 작용할 수 없습니다.\n\n또한 각 개별 점을 해석하기가 매우 어렵습니다. 점들이 주로 유럽에 있다는 것을 알 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 대화식 매핑을 위한 안내\n\n더 세부적으로 알아보고 GPT-4에게 상호작용 옵션을 요청해 봅시다.\n\nGPT-4에게 제시할 프롬프트: 저는 상호작용이 필요해요. 지도를 확대해서 볼 수 있고 각 데이터 포인트 위에 마우스를 올려 선박 이름과 화물을 표시할 수 있기를 원합니다.\n\nGPT-4는 툴팁을 사용하여 folium 지도를 만드는 파이썬 코드를 생성합니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/TIL/assets/img/2024-07-14-BetterGPT-4PromptingForInteractivePythonPlotlyGISMaps_4.png)\n\n와, 여기에는 더 많은 세부 정보가 있네요. 개별 난파선을 식별하는 데이터 포인트를 더 명확하게 볼 수 있습니다. 아쉽게도, 이 지도는 HTML 파일로 생성되어 있어 이상적이지는 않습니다. 보기에는 매우 멋지지만 약간 어색한 방법입니다. GPT-4가 필요한 것은 더 엄격한 안내입니다.\n\nGPT-4에게 알려줄 것: 이 방법은 좋아보이지 않아요. 이를 수행하는 데 왜 Plotly를 사용하지 않을까요?\n\nGPT-4의 응답: 정말 좋은 아이디어네요! 더 나은 상호 작용을 위해 Plotly를 사용하여 코드를 다시 작성합시다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport pandas as pd\nimport plotly.express as px\n\n# 데이터셋 불러오기\nfile_path = 'Geodatabase of Shipwrecks Hardard.csv'\nshipwreck_data = pd.read_csv(file_path)\n# 컬럼 헤더 수정\nshipwreck_data.columns = shipwreck_data.iloc[0]\nshipwreck_data = shipwreck_data.drop(0)\n# 유효한 좌표가 없는 행 제외\nshipwreck_data = shipwreck_data.dropna(subset=['Latitude', 'Longitude'])\n# 위도와 경도를 숫자로 변환\nshipwreck_data['Latitude'] = pd.to_numeric(shipwreck_data['Latitude'], errors='coerce')\nshipwreck_data['Longitude'] = pd.to_numeric(shipwreck_data['Longitude'], errors='coerce')\n# 변환 후 유효하지 않은 좌표가 있는 행 제외\nshipwreck_data = shipwreck_data.dropna(subset=['Latitude', 'Longitude'])\n# Plotly와 Mapbox를 사용하여 인터랙티브 맵 생성\nfig = px.scatter_mapbox(shipwreck_data,\n                        lat='Latitude',\n                        lon='Longitude',\n                        hover_name='NAME',\n                        hover_data={'Longitude': False, 'Latitude': False, 'Cargo_1': True},\n                        title='Global Map of Shipwrecks',\n                        mapbox_style='carto-positron')  # Using mapbox\n# 더 나은 모양을 위해 레이아웃 업데이트\nfig.update_traces(marker=dict(color='red', size=10))  # 색상 및 크기 지정\nfig.update_layout(\n    mapbox=dict(\n        accesstoken='your_mapbox_access_token', \n        center={'lat': 44, 'lon': 18},  # 유럽 지도 중심으로 설정\n        zoom=4\n    ),\n    margin=dict(l=0, r=0, t=0, b=0),\n    title_font_size=24,\n    font=dict(size=14)\n)\n# 인터랙티브 맵 표시\nfig.show()\n```\n\n그리고 이 코드는 정말 잘 작동합니다.\n\n결과:\n\n<img src=\"/TIL/assets/img/2024-07-14-BetterGPT-4PromptingForInteractivePythonPlotlyGISMaps_5.png\" />\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n멋지네요, 이제 조금씩 진행 중이네요. 그리고 각 지점 데이터 위에 마우스를 올려서 난파선 이름과 수송품 정보(알려진 경우)를 찾을 수 있어요:\n\n![image](/TIL/assets/img/2024-07-14-BetterGPT-4PromptingForInteractivePythonPlotlyGISMaps_6.png)\n\nGPT-4는 실제로 지도에 GIS 지점 데이터를 표시하는 Python 코드를 효과적으로 생성하는 데 활용될 수 있어요.\n\n이 예제에서 원하는 결과를 생성하도록 GPT-4에 제공해야 하는 정보는 다음과 같아요:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 데이터 세트를로드하고 열 헤더를 수정하십시오.\n- 유효한 좌표가없는 행을 필터링하십시오.\n- 위도와 경도를 숫자 값으로 변환하십시오.\n- Plotly의 scatter_mapbox 함수를 사용하여 대화 형 지도를 만듭니다.\n- 각 포인트의 색상을 빨간색으로 설정하고 크기를 5픽셀로 설정하십시오.\n- 지중해로 확대 된지도를 표시하십시오.\n- Mapbox 타일에 'carto-positron' 스타일을 사용하십시오.\n- 위도 34 및 경도 18을 중심으로하고 줌 레벨이 4 인 맵을 센터에 배치하십시오.\n- 코드의 적절한 위치에 Mapbox 액세스 토큰을 추가하십시오.\n\n모두입니다.\n\n# 요약\n\nGPT-4는 Python 코드를 간단한 CSV 파일에서 GIS 포인트 데이터를지도에 표시하는데 쉽게 생성할 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이거 조심해서 잘 만들어야 해. 이 LLM을 최적화하려면 좋은 결과를 얻을 때까지 여러 번 시도해야 할 수도 있어.\n\nGPT-4를 광범위하게 활용하면서, 최적의 결과를 찾기 전에 여러 가지 방법을 고려할 수 있음을 알았어. GPT-4에게 가능한 접근법을 묻는 것이 좋을 뿐 아니라 (이런 예시처럼) 더 나은 방법을 알고 있다면, GPT-4에게 사용하도록 명확하게 요청해.\n\n그리고 LLM 프롬프팅 작업을 할 때 중요한 점은, GPT-4는 결과물에 변화를 주는 방식으로 설계되었기 때문에, 당신이 프롬프트로 받는 코드가 여기서 보여주는 것과 정확히 일치하지 않을 수 있다는 거야.\n\n코멘트를 남겨서 프롬프팅이 어떻게 진행되었는지 알려줘!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 이 유형의 이야기가 당신의 취향이고 저를 작가로 지원하고 싶다면, 제 Substack에 가입해주세요.\n\nSubstack에서는 매주 두 번 뉴스레터와 다른 플랫폼에서는 찾을 수 없는 기사들을 발행하고 있어요.","ogImage":{"url":"/TIL/assets/img/2024-07-14-BetterGPT-4PromptingForInteractivePythonPlotlyGISMaps_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-BetterGPT-4PromptingForInteractivePythonPlotlyGISMaps_0.png","tag":["Tech"],"readingTime":8},{"title":"튜토리얼 그만 이렇게 프로그래밍을 배워보세요","description":"","date":"2024-07-14 19:40","slug":"2024-07-14-StopDoingTutorialsLearnProgrammingLikeThis","content":"\n\n마크다운 형식으로 테이블 태그를 변경해주세요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그럭저럭요. 처음 프로그래밍 시험을 볼 때, 제가 코딩하는 방법을 모른다는 것을 깨달았어요. 컴퓨터를 바라보며 처음 몇 줄을 어떻게 작성할지 고민했죠.\n\n이게 요즘의 학습 과정을 현실적으로 알렸다는 거야.\n\n그래서 제 경험처럼 하지 마세요. 대신 이렇게 해보세요.\n\n# 코딩을 효과적으로 배우는 방법?\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n효과적으로 학습한다는 것이 무엇을 의미하는지부터 시작해 봅시다.\n\n학습은 단기 기억에서 장기 기억으로 정보를 연결하는 것입니다. 예를 들어 다시 읽거나 다시 시청하는 것은 공부하는 개념에 대한 어느 정도의 숙련도를 제공하지만, 해당 정보를 단기 기억(작동 중인 기억)에 \"보관\"합니다.\n\n이것이 당신이 아직 배우지 않은 것을 배운 것으로 생각하는 이유입니다.\n\n이것은 무언가를 배우는 비효과적인 방법입니다. 반면, 예를 들어 코딩을 효과적으로 배우기 위해서는 공부하는 정보를 회상해야 합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다시 말해, 스스로를 시험하고 배운 것을 적용해야 합니다.\n\n- 악기를 배우고 싶다면 악기를 연습하십시오.\n- 축구를 배우고 싶다면 축구를 연습하세요.\n- 차를 운전하는 법을 배우고 싶다면 차를 운전해 보세요.\n- 프로그래밍을 배우고 싶다면 코딩하세요.\n\n# 운전을 배우는 것은 코딩을 배우는 것과 같다\n\n몇 주 전, 처음으로 차를 운전하는 법을 익혔습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n첫 수업 전에는 몇 개의 비디오를 보고 자동차가 어떻게 작동하는지 및 운전하는 방법에 대한 기본을 읽었어요. 물론, 실제 차와 연습하지 않으면 아무 소용이 없었죠.\n\n악기를 배울 때도 동일한 원리가 적용돼요.\n\n기타를 치는 법, 음계, 음표 등 기술적인 내용을 배울 수 있어요. 기본을 습득한 후 쉬운 즐겨듣는 노래 몇 곡을 배워봐요. 그 순간, 당신은 기억에 접목하는 중이에요.\n\n이것이 효과적인 학습이에요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 예시들은 까부러운 것 같지만, 이렇게 학습하는 많은 학생을 만난 적이 있어요. 그들은 앉아서 강의를 보며, 다시 보며, 어떻게든지 프로그래밍을 배워나가죠.\n\n여기서 배울 점은 코딩 없이는 프로그래밍을 배울 수 없다는 것이에요.\n\n## 초보자를 위한 몇 가지 프로젝트\n\n- 퀴즈 코드 작성하기.\n- 뱀 게임 코드 작성하기.\n- 데스크탑 정리 프로그램.\n- Streamlit을 이용한 데이터 분석 앱.\n- 호텔 데이터 웹 스크래핑 (고급).\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n주말에 보호하 실력을 동기화할 수 있는 5가지 파이썬 프로젝트를 확인해보세요 :)\n\n마지막으로, 정보 회수 실력을 연습하는 몇 가지 팁을 공유하겠습니다. 당신이 공부하는 어떤 주제에든지 이 팁을 적용해보세요 :)\n\n## 팁 1: 자유 회상\n\n- 책을 닫거나 창을 변경하세요.\n- 지금까지 배운 내용을 회상하세요(책을 보지 않고).\n- 옳은 답변에 대한 피드백을 받으세요.\n- 자신이 알고 있는 것과 모르는 것을 확인하세요.\n- 반복하세요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 팁 2: 플래시카드\n\n- 당신의 자료로부터 플래시카드를 만드세요.\n- 정답을 보지 않고 질문에 솔직하게 대답하세요.\n- 스스로를 테스트하고 피드백을 받으세요.\n- 알고 있는 것과 모르는 것을 확인하세요.\n- 반복하세요.\n\n프로젝트가 학습에 중요하긴 하지만, 알고리즘이나 논리적 사고와 같은 기술적인 것을 소홀히하지 마세요.\n\n그것이 또 다른 내 실수였어요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n학습 여정에서 행운을 빕니다!\n\n# 도와드릴 수 있는 방법:\n\n- 내 새로운 무료 뉴스레터 'The Super Learning Lab'을 구독하세요.\n- 곧 나올 무료 학습 전자책과 이메일 코스를 기대해 주세요!\n\n![image](/TIL/assets/img/2024-07-14-StopDoingTutorialsLearnProgrammingLikeThis_1.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 내 최고의 학습 기사:\n\n- Ultralearning으로 모든 것 배우기\n- 초간단 정리: 9가지 울트라러닝 원칙\n- 울트라러닝으로 무료로 2개월만에 독일어 배우는 법\n- 학습을 당신의 슈퍼파워로 만드세요\n- 이렇게 하지 않고 책을 읽는 것을 그만하세요\n\n안녕,\n\nAxel","ogImage":{"url":"/TIL/assets/img/2024-07-14-StopDoingTutorialsLearnProgrammingLikeThis_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-StopDoingTutorialsLearnProgrammingLikeThis_0.png","tag":["Tech"],"readingTime":5}],"page":"13","totalPageCount":41,"totalPageGroupCount":3,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}