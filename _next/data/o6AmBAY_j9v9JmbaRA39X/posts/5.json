{"pageProps":{"posts":[{"title":"Next.js 15 디버깅 가이드 - 오류 추적과 해결 방법","description":"","date":"2025-04-22 02:08","slug":"2025-04-22-Debugging","content":"\n# 디버깅하기\n\n이번 글에서는 Next.js 애플리케이션의 프론트엔드와 백엔드 코드를 어떻게 디버깅할 수 있는지 알려드릴게요. 특히 소스맵(source maps) 지원을 완벽하게 활용해서, VS Code 디버거, 크롬 개발자 도구, 파이어폭스 개발자 도구 같은 도구로 손쉽게 디버깅하는 방법을 다룹니다.\n\n사실 Node.js에 붙일 수 있는 디버거라면 Next.js 앱 디버깅에도 다 쓸 수 있어요. 더 자세한 내용은 [Node.js 디버깅 가이드](https://nodejs.org/en/docs/guides/debugging-getting-started)를 참고해 보시면 큰 도움이 됩니다.\n\n---\n\n## VS Code로 디버깅하기\n\nVS Code는 웹 개발자들 사이에서 가장 많이 쓰는 에디터 중 하나인데요, Next.js 개발 환경에서도 디버거와 연동이 정말 편리해요. 혹시 아직 VS Code에 디버거 익스텐션 설치가 안 되어 있다면, 꼭 설치해두세요!\n\nVS Code에서 Next.js 앱을 디버깅하기 위한 기본적인 설정은 `launch.json` 파일에 디버깅 구성을 추가하는 거예요. 이 파일은 `.vscode` 폴더 안에 위치해 있습니다.\n\n```json\n{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"type\": \"node\",\n      \"request\": \"launch\",\n      \"name\": \"Next.js: Launch Server\",\n      \"runtimeExecutable\": \"npm\",\n      \"runtimeArgs\": [\"run\", \"dev\"],\n      \"port\": 9229,\n      \"console\": \"integratedTerminal\",\n      \"cwd\": \"${workspaceFolder}\"\n    },\n    {\n      \"type\": \"chrome\",\n      \"request\": \"launch\",\n      \"name\": \"Next.js: Debug Frontend\",\n      \"url\": \"http://localhost:3000\",\n      \"webRoot\": \"${workspaceFolder}\",\n      \"sourceMaps\": true,\n      \"sourceMapPathOverrides\": {\n        \"webpack:///./*\": \"${workspaceFolder}/*\"\n      }\n    }\n  ]\n}\n```\n\n- 첫 번째 구성은 Next.js 개발 서버를 디버깅 모드로 실행하는 설정이에요. `npm run dev` 명령어를 디버깅 모드로 실행하며, 백엔드 서버에 연결할 수 있도록 포트 9229를 엽니다.\n- 두 번째 구성은 크롬 브라우저를 띄워서 프론트엔드 코드를 디버깅하는 설정이에요. 로컬호스트 3000번 포트(Next.js 기본 포트)에 접속하고, 소스맵을 활용해서 실제 작성한 코드를 보고 디버깅할 수 있도록 해줍니다.\n\n> **팁!** 디버깅을 하다 보면 브레이크포인트가 제대로 안 걸리거나, 소스맵 때문에 헤매는 경우가 있는데요. 위 설정에서 `sourceMapPathOverrides` 부분이 실제 코드 파일 위치와 소스맵 경로를 잘 연결해주니까 꼭 확인하세요.\n\n---\n\n추가로, VS Code는 디버깅할 때 Call Stack, 변수, 워치(Watch), 콘솔 등 유용한 도구들을 한 화면에서 보여주니 디버깅 경험이 훨씬 쾌적해집니다. 특히 서버와 클라이언트 코드가 섞여 있을 때 각각 따로 디버깅할 수 있어서 편리합니다.\n\n다음에는 크롬 개발자 도구나 파이어폭스 개발자 도구로 디버깅하는 방법도 알려드릴게요! 질문이 있으면 댓글에 남겨주세요. 😊\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프로젝트 루트에 `.vscode/launch.json` 파일을 만들어서 다음 내용을 넣어주세요!\n\n```json\n{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"name\": \"Next.js: debug server-side\",\n      \"type\": \"node-terminal\",\n      \"request\": \"launch\",\n      \"command\": \"npm run dev\"\n    },\n    {\n      \"name\": \"Next.js: debug client-side\",\n      \"type\": \"chrome\",\n      \"request\": \"launch\",\n      \"url\": \"http://localhost:3000\"\n    },\n    {\n      \"name\": \"Next.js: debug client-side (Firefox)\",\n      \"type\": \"firefox\",\n      \"request\": \"launch\",\n      \"url\": \"http://localhost:3000\",\n      \"reAttach\": true,\n      \"pathMappings\": [\n        {\n          \"url\": \"webpack://_N_E\",\n          \"path\": \"${workspaceFolder}\"\n        }\n      ]\n    },\n    {\n      \"name\": \"Next.js: debug full stack\",\n      \"type\": \"node\",\n      \"request\": \"launch\",\n      \"program\": \"${workspaceFolder}/node_modules/.bin/next\",\n      \"runtimeArgs\": [\"--inspect\"],\n      \"skipFiles\": [\"<node_internals>/**\"],\n      \"serverReadyAction\": {\n        \"action\": \"debugWithEdge\",\n        \"killOnServerStop\": true,\n        \"pattern\": \"- Local:.+(https?://.+)\",\n        \"uriFormat\": \"%s\",\n        \"webRoot\": \"${workspaceFolder}\"\n      }\n    }\n  ]\n}\n```\n\n> 참고로, VS Code에서 Firefox로 디버깅하려면 `Firefox Debugger` 확장 프로그램을 꼭 설치해야 해요!\n\n그리고 `npm run dev` 명령어는 사용하는 패키지 매니저에 따라 바꿔서 써도 돼요.  \n예를 들어 Yarn을 쓴다면 `yarn dev`, pnpm을 쓴다면 `pnpm dev`로 변경하면 됩니다.\n\n---\n\n### 조금 더 팁을 드리자면!\n\n- **서버 사이드 디버깅**: `\"Next.js: debug server-side\"` 설정은 Next.js 서버 쪽 코드를 디버깅할 때 좋아요. 코드를 수정하고 바로 디버깅할 수 있죠.\n- **클라이언트 사이드 디버깅**: `\"Next.js: debug client-side\"`와 Firefox 버전은 브라우저에서 실행되는 React 컴포넌트 쪽 문제를 잡는 데 유용해요.\n- **풀스택 디버깅**: `\"Next.js: debug full stack\"`은 서버와 클라이언트를 동시에 디버깅 하고 싶을 때 최적이에요. 특히 복잡한 버그를 추적할 때 아주 도움이 됩니다.\n\nVS Code 디버그 설정을 잘 해두면, 브레이크포인트도 걸고 변수도 바로바로 보면서 개발할 수 있어서 디버깅 생산성을 확 올릴 수 있으니 꼭 활용해보세요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\"Next.js: debug full stack\" 설정에서 serverReadyAction.action은 서버가 준비됐을 때 어떤 브라우저를 열지 지정해줘요. 예를 들어 debugWithEdge는 Edge 브라우저를 실행하겠다는 뜻이고, 만약 Chrome을 쓰신다면 이 값을 debugWithChrome으로 바꿔주면 됩니다.\n\n또, 애플리케이션이 시작하는 포트 번호를 바꾸셨다면 http://localhost:3000 중 3000을 새로 쓰는 포트 번호로 교체해 주세요.\n\n그리고 Next.js를 루트 디렉터리가 아닌 다른 경로에서 실행 중이라면(예를 들어 Turborepo를 사용하는 경우), 서버 쪽과 full stack 디버깅 작업에 cwd 옵션도 꼭 추가해야 해요. 예를 들면 이렇게요: `\"cwd\": \"${workspaceFolder}/apps/web\"`.\n\n마지막으로 디버그 패널(Windows/Linux는 Ctrl+Shift+D, macOS는 ⇧+⌘+D)로 가서 실행할 launch 구성을 선택한 뒤, F5를 누르거나 커맨드 팔레트에서 Debug: Start Debugging을 선택하면 디버깅 세션이 시작됩니다.\n\n---\n\n### 추가 팁!\n\n- `cwd` 설정은 현재 작업 디렉토리를 지정하는 건데요, 이게 없으면 디버거가 소스 파일을 제대로 찾지 못해서 오류가 날 수 있으니 꼭 신경 써주세요.\n- 혹시 브라우저가 자동으로 열리지 않는다면, 브라우저 쪽 설정과 VSCode의 디버깅 콘솔 로그를 한 번씩 확인해보는 게 좋아요.\n- 만약 다른 브라우저(예: Firefox)를 쓰고 싶다면, 그에 맞는 `debugWithFirefox` 같은 값이 있는지 플러그인 문서나 설정 참고해보세요.\n\n작게 하나 더! VSCode에서 Next.js 디버깅할 때는 `launch.json` 파일에 이런 설정이 들어가 있어야 하는데, 이를 잘 만들어 놓으면 매번 복잡한 명령어 없이도 쉽게 디버깅할 수 있어요. 초반에 설정이 좀 귀찮긴 하지만, 한 번 해두면 앞으로 엄청 편합니다!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## JetBrains WebStorm에서 디버거 사용하기\n\nWebStorm에서 디버깅을 시작하려면, 먼저 실행 구성(runtime configuration) 드롭다운 메뉴를 클릭하고, **Edit Configurations...**를 선택하세요. 여기서 JavaScript Debug 구성 하나를 새로 만듭니다. URL은 보통 `http://localhost:3000` 같은 로컬 서버 주소로 설정해주고, 필요에 따라 디버깅할 브라우저 종류도 선택할 수 있어요. 또, 이 설정을 프로젝트 파일로 저장할지 여부도 결정할 수 있습니다. 구성 설정이 끝나면 **OK**를 눌러 저장하세요.\n\n이제 이 디버깅 구성을 실행하면, WebStorm이 자동으로 선택한 브라우저를 열어줍니다. 이 상태에서 두 앱이 디버깅 모드로 실행 중입니다: 하나는 Next.js가 실행되는 Node.js 백엔드 애플리케이션, 그리고 다른 하나는 클라이언트 쪽(브라우저) 애플리케이션이죠.\n\n이렇게 하면 백엔드와 프론트엔드를 한곳에서 편리하게 디버깅할 수 있어서, 문제를 더 빠르게 잡아낼 수 있습니다.\n\n---\n\n## 브라우저 개발자 도구(DevTools)를 활용한 디버깅\n\n### 클라이언트 사이드 코드\n\n브라우저 내장 개발자 도구는 여러분이 가장 쉽게 접할 수 있는 디버깅 도구 중 하나예요. WebStorm의 디버그 세션과 함께 사용하면 훨씬 강력하죠.\n\n예를 들어, React 같은 클라이언트 프레임워크를 사용한다면, 개발자 도구에서 `Sources` 탭을 통해 코드에 대한 중단점(breakpoint)을 직접 걸 수 있고, 상태 변수나 호출 스택(call stack)을 살펴볼 수 있습니다. 또한, 콘솔(Console) 탭을 활용해 `console.log` 이상의 상호작용을 하면서, 변수를 실시간으로 확인하거나 함수 실행 결과를 테스트할 수도 있어요.\n\n한 가지 팁을 드리자면, 브라우저의 개발자 도구에서 네트워크(Network) 탭을 통해 API 요청과 응답을 모니터링하면, 백엔드와 클라이언트 간 통신 문제를 빠르게 진단할 수 있습니다. 예를 들어, 요청이 제대로 보내졌는지, 응답 시간이 지연되거나 에러는 없는지 등을 실시간으로 확인할 수 있죠.\n\n또한, React 개발자라면 Chrome 확장 프로그램인 React Developer Tools를 설치해서 컴포넌트 트리 상태를 직접 들여다보는 것도 추천합니다.\n\n---\n\n### 정리하자면\n\n- WebStorm 내에서 JavaScript Debug 구성을 만들어 사용하면, 브라우저를 자동으로 열면서 코드를 단계별로 실행해볼 수 있어서 편리합니다.\n- 동시에 백엔드와 프론트엔드 모두를 디버깅해야 하는 환경에 매우 적합하죠.\n- 브라우저 개발자 도구는 클라이언트 쪽 코드를 빠르게 점검하고 문제를 분석하는 데 필수 도구입니다.\n- 네트워크 요청 모니터링과 다양한 콘솔 기능도 적극 활용해보세요.\n\n다음에는 Next.js 백엔드 코드나 프론트엔드 코드에 실제로 중단점을 걸고, 어떤 방식으로 디버깅하면 좋은지 더 자세히 파헤쳐볼게요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n개발 서버를 시작할 때는 보통 next dev, npm run dev, 혹은 yarn dev 명령어를 사용하면 돼요. 서버가 켜지면 http://localhost:3000 (혹은 설정한 다른 URL)을 브라우저에서 열어보세요.\n\n크롬(Chrome)을 사용할 때는 이렇게 하면 됩니다:\n\n- 크롬 개발자 도구 열기 (윈도우/리눅스: Ctrl+Shift+J, macOS: ⌥+⌘+I)\n- 상단 탭에서 Sources 탭 클릭\n\n파이어폭스(Firefox)를 사용할 때도 비슷한 방식이에요. 다음에 이어서 설명할게요!  \n(필요하면 알려주세요.)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파이어폭스 개발자 도구 열기 (Windows/Linux는 Ctrl+Shift+I, macOS는 ⌥+⌘+I)  \n그리고 나서 디버거(Debugger) 탭으로 이동하세요.\n\n여기서 중요한 팁! 클라이언트 쪽 코드에 `debugger` 문이 나오면 코드 실행이 잠시 멈추고, 그 파일이 디버그 영역에 나타납니다. 직접 브레이크포인트를 설정하고 싶을 때는 파일을 검색해서 찾으면 되는데요.\n\n- 크롬에서는 Windows/Linux는 Ctrl+P, macOS는 ⌘+P를 누르면 돼요.\n- 파이어폭스에서는 같은 단축키로 검색하거나 왼쪽 패널에 있는 파일 트리를 이용해도 됩니다.\n\n참고로, 파일을 검색할 때 소스 파일 경로가 `webpack://_N_E/./`로 시작하는 경우가 많으니 이 점 명심하세요.\n\n추가로, 디버깅할 때 이 파일 경로가 조금 헷갈릴 수 있는데, 이 경로는 웹팩이 번들링하면서 붙인 경로입니다. 만약 소스맵(Source Maps)이 잘 연결되어 있다면, 실제 당신이 작성한 원본 코드 위치로 바로 이동할 수 있으니 소스맵 설정도 미리 확인해 두는 게 좋아요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 서버 사이드 코드 디버깅하기\n\nNext.js로 서버 사이드 코드를 디버깅할 때, 브라우저 개발자 도구를 사용하려면 Node.js 프로세스에 `--inspect` 플래그를 전달해줘야 해요. 간단하게 이렇게 실행하면 됩니다:\n\n```bash\nNODE_OPTIONS='--inspect' next dev\n```\n\n이렇게 하면 서버 코드가 디버깅 모드로 실행되면서, 크롬 같은 브라우저 개발자 도구에서 디버깅이 가능해져요.\n\n> 참고로, 만약 도커 같은 환경에서 로컬호스트가 아닌 외부에서 디버깅 접근을 하려면, 플래그를 조금 바꿔야 해요:\n>\n> bash\n> NODE_OPTIONS='--inspect=0.0.0.0' next dev\n>\n> 이렇게 하면 외부 IP에서도 디버깅 포트에 접속할 수 있어서 원격 디버깅이 가능해집니다. 개발할 때 정말 유용하니 기억해두세요!\n\n덧붙여, 디버깅을 좀 더 효율적으로 하려면 VSCode 같은 에디터의 디버깅 기능과도 연동해서 사용해보는 걸 추천해요. `launch.json` 설정을 통해서 바로 디버깅 세션을 시작할 수 있거든요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약에 `npm run dev` 또는 `yarn dev`로 개발 서버를 실행하고 있다면, package.json 안에 dev 스크립트를 이렇게 수정해줘야 해요:\n\n```json\n{\n  \"scripts\": {\n    \"dev\": \"NODE_OPTIONS='--inspect' next dev\"\n  }\n}\n```\n\n이렇게 하면 Next.js 개발 서버를 띄울 때 `--inspect` 옵션도 같이 붙어서 디버깅이 가능해집니다. 실행하면 터미널에 이런 메시지가 나올 거예요:\n\nDebugger listening on ws://127.0.0.1:9229/0cf90313-350d-4466-a748-cd60f4e47c95\nFor help, see: https://nodejs.org/en/docs/inspector\nready - started server on 0.0.0.0:3000, url: http://localhost:3000\n\n이 메시지는 Node.js의 디버깅 프로토콜이 활성화돼서 디버거가 연결 대기 중이라는 뜻이에요. 크롬 개발자 도구나 VSCode 같은 에디터에서 이 포트를 연결해서 코드를 단계별로 디버깅할 수 있답니다!\n\n추가로, 윈도우 환경에서는 `NODE_OPTIONS='--inspect'` 부분을 이렇게 바꿔줘야 할 수도 있어요:\n\n```json\n\"dev\": \"set NODE_OPTIONS=--inspect&& next dev\"\n```\n\n운영체제별로 환경 변수 설정법이 다르니 참고하세요! 이렇게 하면 Next.js 개발할 때 버그 찾기가 훨씬 편해져요. 기억해두시면 좋겠죠?\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n크롬(Chrome)에서 디버깅하기:\n\n1. 새 탭을 열고 `chrome://inspect`로 이동하세요.\n2. 오른쪽 상단의 **Configure...** 버튼을 클릭해 디버깅 포트가 제대로 등록되어 있는지 확인합니다.\n3. `localhost:9229`와 `localhost:9230`이 목록에 없다면 추가해 주세요.\n4. **Remote Target** 섹션에서 여러분의 Next.js 애플리케이션을 찾습니다.\n5. **Inspect** 버튼을 클릭하면 별도의 DevTools 창이 열립니다.\n6. **Sources** 탭으로 이동해 코드를 살펴보면서 디버깅을 시작하세요.\n\nFirefox에서 디버깅하기:\n\n1. 새 탭을 열고 `about:debugging` 페이지로 이동합니다.\n2. 왼쪽 사이드바에서 **This Firefox**를 클릭합니다.\n3. **Remote Targets** 아래에서 Next.js 애플리케이션을 찾습니다.\n4. **Inspect** 버튼을 눌러 디버거 창을 엽니다.\n5. **Debugger** 탭으로 가서 디버깅할 코드를 확인해 보세요.\n\n---\n\n추가 팁!\n\n- Next.js 앱을 디버깅할 때 Node.js 서버 쪽 디버깅도 중요해요. 보통 `nodemon --inspect` 같은 옵션으로 서버를 실행한 뒤 위에서 설명한 포트를 확인하면 됩니다.\n- 크롬과 파이어폭스 둘 다, 디버깅 포트가 다르면 각각 추가해야 하니 꼭 확인하세요.\n- DevTools에서는 브라우저에서 실행되는 클라이언트 사이드 코드 뿐 아니라, 서버 사이드 렌더링 함수들도 디버깅할 수 있어 아주 유용해요.\n- 혹시 Next.js에서 제공하는 기본 디버깅 툴 외에 더 전문적인 도구를 찾는다면 VS Code의 디버거도 추천합니다. 요즘은 VS Code가 Next.js와 Node.js 디버깅 모두 잘 지원해줘서 편리하게 사용할 수 있어요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n서버 사이드 코드를 디버깅하는 방법은 클라이언트 사이드 디버깅과 굉장히 비슷해요. 예를 들어 파일을 검색할 때 (Ctrl+P 또는 ⌘+P) 소스 파일 경로가 webpack://'application-name'/./ 로 시작하는 걸 볼 수 있는데, 여기서 'application-name'은 package.json에 설정한 여러분의 애플리케이션 이름으로 자동으로 바뀌어요.\n\n### 브라우저 개발자 도구로 서버 에러 살펴보기\n\n에러가 발생했을 때, 소스 코드를 직접 확인하면 원인 찾기가 훨씬 수월해요. Next.js에서는 에러 화면에 Node.js 아이콘이 Next.js 버전 표시 아래에 나타납니다. 이 아이콘을 클릭하면 개발자 도구(DevTools) URL이 클립보드에 복사돼요. 이 URL을 새 탭에 붙여넣으면 Next.js 서버 프로세스를 직접 들여다볼 수 있답니다.\n\n참고로, 이렇게 서버 프로세스를 브라우저에서 디버깅할 수 있다는 점이 정말 편리한데요, 예전에는 터미널에서만 로그를 보거나 복잡한 디버깅 과정을 거쳐야 했거든요. 이 기능 덕분에 코드 흐름을 한눈에 확인하고, 오류 위치를 빨리 찾아낼 수 있어 개발 속도가 확실히 빨라진답니다. 혹시 더 깊이 있는 디버깅이 필요하면, Node.js 전용 디버거(예: VSCode의 디버깅 툴)와 병행해서 사용해보는 것도 추천해요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### Windows에서 디버깅하기\n\nWindows에서 개발하다 보면 `NODE_OPTIONS='--inspect'` 이런 식으로 설정할 때 문제가 생길 수 있어요. 윈도우는 이 문법을 그대로 지원하지 않거든요. 그래서 윈도우, 맥, 리눅스 어디서든 똑같이 작동하도록 하려면 `cross-env`라는 패키지를 활용하는 걸 추천해요.\n\n`cross-env`는 다양한 운영체제 환경에 맞게 환경 변수를 설정해주는 역할을 하는데요, 덕분에 같은 설정으로 모든 플랫폼에서 디버깅이 가능해집니다.\n\n먼저, `cross-env`를 개발 의존성으로 설치해줍니다:\n\n```bash\nnpm install -D cross-env\n# 혹은\nyarn add -D cross-env\n```\n\n그 다음 `package.json`의 `dev` 스크립트를 이렇게 바꿔주세요:\n\n```json\n{\n  \"scripts\": {\n    \"dev\": \"cross-env NODE_OPTIONS='--inspect' next dev\"\n  }\n}\n```\n\n이렇게 설정하면 이제 `npm run dev` 또는 `yarn dev`로 실행할 때 디버거가 잘 붙을 거예요.\n\n> **추가 팁!**  \n> 만약 Windows PowerShell에서 터미널을 사용한다면, `'--inspect'` 대신 `\"--inspect\"`로 바꿔서 실행할 수도 있으니 환경에 따라 테스트해보세요.\n\n개발 환경을 맞추는 건 가끔 깔끔하지 않을 때가 많은데요, `cross-env` 같은 도구를 잘 활용하면 이런 골치 아픈 부분을 많이 덜 수 있어서 강력 추천합니다!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n> 참고하세요: Windows Defender를 내 컴퓨터에서 꼭 비활성화하세요. 이 외부 서비스는 읽는 모든 파일을 검사하는데, 이로 인해 Next.js 개발 시 Fast Refresh 속도가 크게 느려질 수 있다고 알려져 있어요. 이 문제는 Next.js 자체와 관련된 게 아니지만, 개발 환경에는 영향을 미치니까 꼭 체크해두는 게 좋아요.\n\n## 추가 정보\n\n자바스크립트 디버거를 어떻게 사용하는지 더 배우고 싶다면, 아래 문서들을 참고해보세요:\n\n- VS Code에서 Node.js 디버깅: Breakpoints\n- Chrome DevTools: 자바스크립트 디버깅\n- Firefox DevTools: 디버거\n\n디버깅 기능을 잘 활용하면 개발할 때 훨씬 편리하고 효율적으로 오류를 잡을 수 있으니, 시간이 날 때 꼭 한번 익혀보는 걸 추천합니다!\n","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":15},{"title":"Next.js 15 커스텀 서버 구축하는 방법","description":"","date":"2025-04-22 02:07","slug":"2025-04-22-CustomServer","content":"\n# 커스텀 서버(Custom Server) 이해하기\n\nNext.js를 사용하면 기본적으로 `next start` 명령어로 내장된 서버가 바로 실행돼요. 그런데 만약 이미 백엔드 서버가 따로 있다면, 그걸 그대로 유지하면서 Next.js와 함께 사용할 수도 있답니다. 이 경우를 ‘커스텀 서버(Custom Server)’라고 부르지 않아요.\n\n커스텀 Next.js 서버는 필요에 따라 내 프로그램에서 직접 서버를 띄우면서 라우팅이나 요청 처리 방식을 자유롭게 바꾸고 싶을 때 사용해요. 하지만 대부분의 경우에는 Next.js가 제공하는 기본 라우터만으로도 충분하기 때문에 굳이 커스텀 서버를 만들 필요가 없어요.\n\n> **여기서 주의!**\n>\n> - 커스텀 서버는 Next.js의 자동 정적 최적화(Automatic Static Optimization) 같은 중요한 성능 개선 기능들을 포기하는 대가를 치러야 해요.\n> - 그리고 Vercel 같은 Next.js 공식 배포 플랫폼에서는 커스텀 서버를 사용할 수 없어요.\n> - `standalone` 출력 모드를 사용할 때는 커스텀 서버 파일을 함께 추적하지 않고, 대신 최소한의 `server.js` 파일만 따로 만들어내요. 그래서 둘을 동시에 사용할 수도 없으니 주의가 필요해요.\n\n아래는 커스텀 서버의 간단한 예시를 보여드릴게요. 예전에는 Express.js 같은 외부 서버 라이브러리와 함께 Next.js를 이렇게 쓰는 경우가 많았는데, 최근 Next.js가 점점 더 자체 기능을 강화하면서 점차 필요성이 줄고 있죠.\n\n```js\nconst express = require(\"express\");\nconst next = require(\"next\");\n\nconst port = 3000;\nconst app = next({ dev: false });\nconst handle = app.getRequestHandler();\n\napp.prepare().then(() => {\n  const server = express();\n\n  // 커스텀 라우트 예시\n  server.get(\"/p/:id\", (req, res) => {\n    const actualPage = \"/post\";\n    const queryParams = { id: req.params.id };\n    app.render(req, res, actualPage, queryParams);\n  });\n\n  // 나머지는 Next.js 기본 처리\n  server.all(\"*\", (req, res) => {\n    return handle(req, res);\n  });\n\n  server.listen(port, (err) => {\n    if (err) throw err;\n    console.log(`> Ready on http://localhost:${port}`);\n  });\n});\n```\n\n---\n\n### 꼭 알아두면 좋은 팁\n\n- 커스텀 서버는 정말 필요할 때에만 써요! 기본 Next.js 라우팅으로 충분하면 굳이 복잡하게 서버를 직접 관리할 필요 없어요.\n- Vercel 배포에서는 사용 불가라는 점, 잊지 마세요.\n- 서버 없는 환경(serverless)이나 요즘 많이 쓰는 ISR(Incremental Static Regeneration) 기능이랑도 잘 맞지 않아요.\n- 많이 쓰이는 기능은 공식 Next.js 라우터 기능이나 API 라우트를 활용하는 게 더 깔끔하고 이후 유지보수도 편해요.\n\n만약 커스텀 서버와 관련해서 더 궁금한 점 있으면 언제든 질문해 주세요! 혹은 Next.js 기본 라우터들의 여러 팁도 공유해 드릴게요. 😊\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js 프로젝트에서 커스텀 서버를 직접 만들고 싶을 때, 보통 `server.js` 파일을 만들어서 Node.js의 HTTP 서버를 활용하곤 해요. 오늘은 간단한 커스텀 서버 예제와, 이걸 어떻게 실행할지 package.json에 스크립트를 어떻게 추가하는지 알려드릴게요.\n\n먼저, 이 코드를 보시면 서버를 직접 생성하고 Next.js 앱을 `next()` 함수로 감싼 뒤에 준비가 끝나면 HTTP 서버를 띄우는 구조예요.\n\n```js\nimport { createServer } from 'http'\nimport { parse } from 'url'\nimport next from 'next'\n\nconst port = parseInt(process.env.PORT || '3000', 10)\nconst dev = process.env.NODE_ENV !== 'production'\nconst app = next({ dev })\nconst handle = app.getRequestHandler()\n\napp.prepare().then(() => {\n  createServer((req, res) => {\n    const parsedUrl = parse(req.url!, true)\n    handle(req, res, parsedUrl)\n  }).listen(port)\n\n  console.log(\n    `> Server listening at http://localhost:${port} as ${\n      dev ? 'development' : process.env.NODE_ENV\n    }`\n  )\n})\n```\n\n이 코드에서 핵심은 `app.prepare()`가 끝나면 HTTP 서버를 열며, 들어오는 요청을 `handle` 함수로 넘겨서 Next.js가 페이지를 렌더링하도록 한다는 점이에요.\n\n### 그런데 여기서 중요한 점!\n\n`server.js`는 Next.js 컴파일러를 거치지 않고 그냥 Node.js에서 직접 실행되기 때문에, 최신 문법(예: ES 모듈 `import` 구문)을 쓸 때 Node.js 버전과 호환되는지 반드시 확인해야 합니다. 만약 호환 안 되면 직접 `require()`로 바꾸거나, Babel 같은 트랜스파일러 사용을 고려해야 해요.\n\n---\n\n### package.json에 커스텀 서버 실행 스크립트 추가하기\n\n커스텀 서버를 실행하려면 `package.json`의 `scripts`를 이렇게 바꿔줘야 해요.\n\n```json\n{\n  \"scripts\": {\n    \"dev\": \"node server.js\",\n    \"build\": \"next build\",\n    \"start\": \"NODE_ENV=production node server.js\"\n  }\n}\n```\n\n- `dev`: 개발 모드에서 커스텀 서버 바로 실행\n- `build`: Next.js 빌드 수행\n- `start`: 프로덕션 환경에서 커스텀 서버 실행\n\n---\n\n### 덧붙여서…\n\n커스텀 서버를 만들면 유연하게 서버 로직 제어가 가능하지만, Next.js의 기본 서버 기능과 자동 최적화, 배포 플랫폼(예: Vercel) 지원을 덜 받게 돼요. 그러니 정말 필요한 경우가 아니라면 기본 Next.js 빌트인 서버를 쓰는 걸 권장합니다!\n\n그럼, 여러분만의 커스텀 서버 만들어서 원하는 기능 자유롭게 구현해보세요! 궁금한 점 있으면 언제든 질문 남겨주세요. 😄\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n대신에 nodemon을 설정해서 사용할 수도 있어요(예시 참고). 커스텀 서버는 Next.js 애플리케이션과 연결하기 위해 아래와 같은 import 문을 사용합니다:\n\n```js\nimport next from \"next\";\n\nconst app = next({});\n```\n\n여기서 next 함수는 옵션들을 담은 객체를 인자로 받는데요, 주요 옵션들은 다음과 같습니다:\n\n| 옵션         | 타입               | 설명                                                                                |\n| ------------ | ------------------ | ----------------------------------------------------------------------------------- |\n| `conf`       | `Object`           | `next.config.js` 에서 사용하는 설정 객체와 동일해요. 기본값은 `{}` 입니다.          |\n| `dev`        | `Boolean`          | (선택) Next.js를 개발 모드로 실행할지 여부입니다. 기본값은 `false` 입니다.          |\n| `dir`        | `String`           | (선택) Next.js 프로젝트 위치를 지정합니다. 기본값은 현재 폴더 `'.'` 입니다.         |\n| `quiet`      | `Boolean`          | (선택) 서버 정보가 포함된 에러 메시지를 숨길지 결정합니다. 기본값은 `false` 입니다. |\n| `hostname`   | `String`           | (선택) 서버가 실행되는 호스트 이름을 지정합니다.                                    |\n| `port`       | `Number`           | (선택) 서버가 실행되는 포트를 지정합니다.                                           |\n| `httpServer` | `node:http#Server` | (선택) Next.js가 작동 중인 HTTP 서버 객체를 넘겨줄 수 있습니다.                     |\n| `turbo`      | `Boolean`          | (선택) Turbopack을 활성화할지 여부입니다.                                           |\n\n---\n\n**간단 팁!**\n\n- 개발할 때 `dev` 옵션을 `true`로 주면 핫 리로딩도 잡아주고 디버깅이 편해져요.\n- 프로젝트 경로가 현재 폴더가 아니라면 `dir` 옵션으로 정확히 지정해주는 게 중요합니다.\n- `quiet` 옵션을 켜면 서버 에러 로그가 줄어들어 콘솔이 깔끔해져서 가끔 쓰면 좋아요.\n- 그리고 마지막으로 `turbo` 옵션은 Next.js의 차세대 번들러인 Turbopack을 활성화하는건데, 아직 실험적인 기능이라 프로젝트 특성에 따라 테스트해보시는 걸 추천해요.\n\n이렇게 다양한 옵션을 활용해서 커스텀 서버 환경을 자신의 필요에 맞게 세팅해보세요! 개발할 때 내 서버 환경을 좀 더 세밀하게 컨트롤할 수 있어서 편리합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n반환된 앱은 Next.js가 요청을 필요한 대로 처리할 수 있도록 사용하는 데 활용할 수 있어요.\n\n여기서 중요한 점은, Next.js가 기본적으로 서버 사이드 렌더링(SSR)과 정적 생성(SSG) 모두를 지원하기 때문에, 반환된 앱으로 다양한 요청 처리 방식을 유연하게 다룰 수 있다는 거예요.\n\n예를 들어, API 라우트나 커스텀 서버를 구축할 때 조금 더 세밀한 제어가 필요하면 이렇게 반환된 앱을 통해 요청을 직접 처리할 수 있고, 그렇지 않으면 Next.js의 기본 라우팅에 맡길 수도 있죠.\n\n이런 방식을 활용하면 복잡한 서버 로직을 구현할 때도 Next.js의 장점을 최대한 살리면서 개발할 수 있어요!\n","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":7},{"title":"Nextjs15에서 로컬 개발 환경 구축하는 방법","description":"","date":"2025-04-22 02:05","slug":"2025-04-22-LocalDevelopment","content":"\n\n# 로컬 개발 환경\n\nNext.js는 개발자 경험을 최우선으로 설계되었어요. 그런데 프로젝트가 커질수록 로컬에서 개발할 때 컴파일 속도가 느려지는 걸 경험할 수 있답니다. 그래서 이번 글에서는 자주 발생하는 컴파일 시간 지연 문제를 어떻게 발견하고 해결할 수 있는지 알려드릴게요.\n\n## 로컬 개발과 프로덕션 빌드의 차이\n\nNext.js에서 `next dev` 명령어로 로컬 개발을 할 때와, `next build` + `next start`로 프로덕션 모드로 실행하는 과정은 서로 다릅니다.\n\n로컬 개발(`next dev`)에서는 개발 편의성을 위해 핫 리로딩, 소스맵 제공, 다양한 검사 기능들이 활성화되어 있어요. 그래서 빌드가 좀 더 느릴 수밖에 없죠. 반면 프로덕션 빌드(`next build`)는 최적화를 최대한 해서 빠른 페이지 로딩과 작은 번들 크기를 목표로 합니다.\n\n여기서 중요한 점! 로컬 개발 속도가 너무 느리다면, 단순히 production 빌드 환경으로 바꿔서 해결하려고 하기보다는, 개발 중에만 발생하는 문제들이 없는지 한번 점검해 보는 게 좋아요.\n\n---\n\n추가로! Next.js 13부터는 새로운 앱 디렉터리와 React Server Components가 도입되면서 빌드와 컴파일 패턴이 조금 달라졌어요. 그래서 앱 디렉터리를 사용하는 경우에도 성능 최적화 방법이 약간 다를 수 있다는 점, 참고해주세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js 개발할 때 'next dev' 명령어를 쓰면, 애플리케이션의 각 라우트를 실제로 열거나 이동할 때 그 라우트를 컴파일해요. 덕분에 처음 'next dev' 서버를 켤 때 모든 라우트를 한꺼번에 빌드하느라 오래 기다릴 필요가 없죠. 이것도 훨씬 빠르고, 메모리도 덜 먹으니 좋고요.\n\n반면 프로덕션 빌드(운영용 빌드)는 파일 압축(minify)이나 콘텐츠 해시 생성 같은 최적화 작업들이 추가로 들어가서, 개발환경보다는 시간이 더 걸리고 무겁습니다. 그래서 로컬 개발할 때는 'next dev'를 쓰는 게 훨씬 효율적이죠.\n\n---\n\n## 로컬 개발 속도 높이는 방법\n\n### 1. 내 컴퓨터의 백신 프로그램, 체크해봤나요?\n\n의외로 많은 사람들이 간과하는 포인트인데요, 백신 프로그램이 파일 접근 속도를 확 느리게 할 수 있답니다. 개발 도중 수시로 파일을 읽고 쓰는데, 백신이 실시간 감시한다고 생각해보세요. 파일 입출력(I/O) 작업이 지연되니 개발 속도에도 영향이 가는 건 당연하죠.\n\n아래 팁들 참고해보세요:\n\n- 개발 폴더를 백신 검사 제외 대상으로 등록하기  \n- 혹은 백신을 잠시 꺼두고 개발하기 (안전한 환경이라면)  \n- 백신을 경량화하거나 개발 환경에 맞는 설정을 찾아보기  \n\n간단하면서도 효과 볼 수 있는 방법이니 꼭 테스트해보시길 바랍니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프로젝트 폴더를 안티바이러스 예외 목록에 추가해보세요. 보통 윈도우 환경에서 많이 하는 방법이지만, 안티바이러스가 설치된 모든 시스템에서 추천하는 팁입니다. 안티바이러스가 파일을 검사하면서 개발 서버 성능이 떨어질 수 있기 때문이에요.\n\n### 2. Next.js 업데이트 및 Turbopack 활성화\n\n최신 버전의 Next.js를 사용하고 있는지 확인해보세요. Next.js는 버전이 올라갈 때마다 성능 개선이 자주 포함된답니다.\n\n그리고 Turbopack이라는 새로운 번들러가 Next.js에 통합되었어요. Turbopack은 로컬 개발 환경에서 빌드와 번들링 속도를 크게 높여주는 역할을 하니 꼭 활용해보시길 추천합니다!\n\n> 참고로, Turbopack은 아직 완전히 안정화된 단계는 아니지만, 빠른 속도를 경험하고 싶다면 충분히 시도해볼 만해요. 설정 방법이나 지원하는 기능도 계속 업데이트 중이라 공식 문서를 수시로 확인하는 게 좋아요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```bash\nnpm install next@latest\nnpm run dev --turbopack\n```\n\nTurbopack에 대해 더 알고 싶다면 공식 문서와 업그레이드 가이드, 코드를 자동 변환해주는 codemods도 참고해보세요.\n\n### 3. import 구문 점검하기\n\n코드를 어떻게 import하느냐에 따라 컴파일 속도와 번들 크기에 큰 영향을 줄 수 있어요. 패키지 번들링 최적화 방법에 대해 배우고 싶다면 Dependency Cruiser, Madge 같은 도구도 한 번 사용해보시길 추천합니다. \n\n이런 도구들은 의존성 관계를 시각화하고 불필요한 중복 import를 찾는 데 도움을 줘서, 코드가 더 깔끔하고 빠르게 빌드되도록 도와줘요. 특히 큰 프로젝트에서는 이런 최적화가 빛을 발한답니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 아이콘 라이브러리 활용 팁\n\n@material-ui/icons나 react-icons 같은 라이브러리는 무려 수천 개의 아이콘을 한꺼번에 가져올 수 있어요. 그런데 실제로는 그중 몇 개만 쓸 때가 많죠. 이럴 때는 꼭 필요한 아이콘만 딱딱 가져오는 게 좋아요!\n\n```js\n// 이렇게 한꺼번에 불러오기보다는:\nimport { Icon1, Icon2 } from 'react-icons/md'\n\n// 이렇게 개별로 불러오는 게 더 효율적이에요:\nimport Icon1 from 'react-icons/md/Icon1'\nimport Icon2 from 'react-icons/md/Icon2'\n```\n\n이렇게 하면 불필요한 아이콘들이 번들에 포함되는 걸 막을 수 있어서 앱의 용량을 줄이고, 로딩 속도를 빠르게 할 수 있답니다.\n\n그리고 react-icons처럼 여러 아이콘 세트를 한 자리에서 제공하는 라이브러리는 한 가지 세트만 선택해서 통일감 있게 사용하는 걸 추천해요. 그러면 디자인도 깔끔해 보이고, 코드 관리도 훨씬 쉬워집니다!\n\n추가로, 만약 프로젝트가 커져서 아이콘이 많아지면 커스텀 아이콘 컴포넌트를 만들어서 재사용하는 것도 좋은 방법이에요. 작지만 효과적인 성능 최적화 팁 중 하나랍니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예를 들어, 만약 여러분의 애플리케이션에서 react-icons를 사용하면서 다음과 같이 여러 아이콘 세트에서 모두 다 임포트한다고 해볼게요:\n\n- pi (Phosphor Icons)\n- md (Material Design Icons)\n- tb (tabler-icons)\n- cg (cssgg)\n\n이렇게 하면, 실제로는 한 개씩 아이콘만 가져와서 사용하더라도, 컴파일러는 수만 개에 달하는 모듈을 처리해야 하거든요. 이게 빌드 시간은 물론 최종 번들 크기에도 꽤 큰 영향을 미쳐요.\n\n### Barrel files (배럴 파일)\n\n여기서 배럴 파일 개념을 활용할 수 있어요. 배럴 파일이란 여러 개의 모듈을 한 군데서 모아두는 일종의 '중간 집합' 파일인데, 이렇게 하면 필요한 아이콘만 깔끔하게 임포트할 수 있어요. 예를 들어, `icons/index.js` 같은 파일을 만들어서 자주 쓰는 아이콘들만 골라서 한군데 내보내기(export) 하는 거죠.\n\n```js\n// icons/index.js\nexport { PiSomeIcon } from 'react-icons/pi';\nexport { MdAnotherIcon } from 'react-icons/md';\nexport { TbSampleIcon } from 'react-icons/tb';\nexport { CgExampleIcon } from 'react-icons/cg';\n```\n\n그리고 실제 컴포넌트에서는 이렇게 쓰면 돼요:\n\n```js\nimport { PiSomeIcon, MdAnotherIcon } from './icons';\n```\n\n이렇게 하면 필요 없는 아이콘 모듈들은 빌드 과정에서 제외될 가능성이 높아지고, 코드 관리도 훨씬 수월해져요. \n\n뿐만 아니라, 이것 말고도 react-icons에서 지원하는 트리 쉐이킹(Tree shaking) 기능을 최대한 활용하는 방법도 고려해보면 좋아요. 예를 들어 아이콘을 직접 필요한 것만 개별 임포트하거나, 번들러 설정(Webpack, Vite 등)에서 최적화를 제대로 해줘야 하죠.\n\n정리하자면,\n\n| 문제점                    | 해결 방법               | 추가 팁                         |\n|---------------------------|------------------------|--------------------------------|\n| 수만 개 모듈 임포트       | 배럴 파일로 모듈 한데 묶기 | 트리쉐이킹 지원 활성화           |\n| 빌드 속도와 번들 크기 증가 | 필요 아이콘 개별 임포트   | 번들러 최적화 설정 함께 챙기기   |\n\n조금만 신경 써도 아이콘 사용이 훨씬 간편해지고 앱이 가벼워질 수 있으니 꼭 한 번 시도해 보시길 추천드려요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\"Barrel 파일\"이라는 개념 들어보셨나요? 간단히 말하면, 여러 개의 모듈이나 컴포넌트를 한 곳에서 한 번에 export해주는 파일을 뜻해요. 예를 들어, 여러 컴포넌트를 각각 import하지 않고, barrel 파일 하나만 import하면 편리하죠.\n\n하지만 이런 barrel 파일이 오히려 빌드 속도를 늦출 수 있어요. 그 이유는 컴파일러가 해당 파일을 파싱하면서 모듈 스코프 내에 부작용(side-effects)이 있는지 확인해야 하기 때문이거든요. 그래서 가능하면 각 컴포넌트나 모듈을 직접 import하는 게 좋아요.\n\nNext.js에서는 이런 barrel 파일과 관련된 최적화 기능도 제공하고 있으니 참고하시면 좋아요.\n\n---\n\n### 패키지 import 최적화하기\n\nNext.js는 특정 패키지들에 대해 자동으로 import 최적화를 해준답니다. 만약 barrel 파일 방식을 사용하는 패키지를 쓴다면, `next.config.js` 파일에 해당 패키지를 아래와 같이 추가해 주면 돼요:\n\n```js\n// next.config.js\nmodule.exports = {\n  experimental: {\n    optimizePackageImports: true,\n  },\n  optimizePackageImports: {\n    'some-package': {\n      transform: 'some-package/lib/{{member}}', // 실제 import 경로를 지정\n    },\n  },\n};\n```\n\n이렇게 설정해 놓으면 Next.js가 필요한 모듈만 쏙쏙 골라서 import하기 때문에 빌드 속도와 번들 크기 측면에서 이점이 생기죠.\n\n---\n\n### 추가 팁!\n\n만약 여러분이 직접 패키지를 만들거나 관리하는 입장이라면, 가능하면 barrel 파일 사용을 최소화하고, 패키지 내부에서 개별 모듈을 명확하게 export하는 방식을 추천해요. 그래야 사용자 입장에서도 임포트가 최적화되고, 빌드 속도도 빨라지니까요.\n\n또한, import할 때 필요 없는 항목까지 한꺼번에 가져오지 말고, 코드에서 실제 필요한 것만 골라 import하는 습관을 들이면 번들 크기를 작게 유지하는 데 큰 도움이 됩니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nmodule.exports = {\n  experimental: {\n    optimizePackageImports: ['package-name'],\n  },\n}\n```\n\n위 코드는 Turbopack에서 특정 패키지의 import를 최적화하려고 설정한 예시입니다. 하지만 Turbopack은 이미 자동으로 import를 분석하고 최적화해주기 때문에, 이 설정은 사실 필요 없습니다. 번거롭게 직접 설정하지 않아도 Turbopack이 알아서 똑똑하게 처리해줘요.\n\n---\n\n### 4. Tailwind CSS 설정 확인하기\n\n만약 Tailwind CSS를 사용 중이라면, 제대로 설정되어 있는지 꼭 확인해보세요. Tailwind는 써보면 정말 편리한 CSS 유틸리티 프레임워크인데, 설정이 조금만 틀리면 스타일이 제대로 적용되지 않을 수 있거든요.\n\n예를 들어, `tailwind.config.js`에서 콘텐츠 경로(`content` 또는 `purge`)에 프로젝트 내 사용하는 컴포넌트 경로나 파일이 모두 포함되어 있는지 확인해야 합니다. 빠뜨리면 Tailwind가 불필요한 CSS를 제거하면서 실제 필요한 스타일까지 지워버릴 수 있어요.\n\n또한 PostCSS나 Next.js 같은 빌드 도구 설정에서 Tailwind 플러그인이 정확히 추가되어 있는지도 체크해보세요. 잘못 연결되어 있으면 컴파일 오류나 스타일 적용 문제로 이어질 수 있답니다.\n\n혹시 Tailwind CSS 설정이 처음이라면 공식 문서 한 번 정독해보는 걸 추천드리고, 설정 한 번 끝내고 나면 CSS 작성이 훨씬 간결해지고 관리도 수월해질 거예요!\n\n---\n\n추가로 궁금한 점이나 설정 관련해서 더 도움 필요하면 언제든 말씀해 주세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nTailwind CSS 설정할 때 자주 하는 실수 중 하나가, content 배열에 node_modules 같은 불필요하게 큰 폴더들이 포함되어 빌드 속도를 느리게 만드는 경우예요.\n\nTailwind CSS 버전 3.4.8 이상부터는, 이런 설정이 빌드를 느리게 할 수 있다는 경고를 알려줘서 옵니다.\n\n### 주의할 점과 좋은 설정 예시\n\n- tailwind.config.js에서 어떤 파일을 스캔할지 구체적으로 명시하세요:\n\n```js\nmodule.exports = {\n  content: [\n    './src/**/*.{js,ts,jsx,tsx}', // 좋은 예시\n    // 아래 설정은 너무 범위가 넓어서 node_modules까지 포함될 수 있음\n    // '../../packages/**/*.{js,ts,jsx,tsx}',\n  ],\n}\n```\n\n- 불필요한 파일 스캔을 피하세요:\n\n```js\nmodule.exports = {\n  content: [\n    // 훨씬 좋은 방법 - 오직 src 폴더만 스캔합니다.\n    '../../packages/ui/src/**/*.{js,ts,jsx,tsx}',\n  ],\n}\n```\n\n이렇게 하면 Tailwind가 진짜 필요한 파일만 훑어보게 되어 빌드 시간이 확 줄어들고, 불필요한 경고나 오류도 줄어듭니다.\n\n---\n\n### 추가 팁!\n\n만약 프로젝트에 여러 패키지가 묶여있거나, 모노레포 구조라면 특히 어디를 포함시키고 어디를 제외할지 꼼꼼하게 체크해야 해요. node_modules, 빌드 결과물(dist), 그리고 테스트 결과물 같은 폴더는 꼭 제외하는 게 좋습니다.\n\n---\n\n### 다음 내용 살펴보기\n\n5. 커스텀 Webpack 설정 확인하기\n\nWebpack이나 다른 번들러와 함께 Tailwind를 쓸 때, 설정이 꼬이지 않았는지 꼭 한 번 확인하세요. 특히 경로나 플러그인 충돌을 점검하면 빌드 문제를 미리 예방할 수 있습니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약에 여러분이 커스텀 웹팩 설정을 추가했다면, 그 설정 때문에 컴파일 속도가 느려질 수도 있어요.\n\n로컬 개발 환경에서 정말 그 설정이 필요한지 한 번 생각해 보세요. 필요 없다면, 특정 툴이나 설정은 프로덕션 빌드 때만 포함시키는 걸 고려해 보는 것도 좋아요. 그리고 요즘은 Turbopack 같은 좀 더 빠른 빌드 도구도 많이 떠오르고 있으니 이런 새로운 도구와 로더(loader) 사용도 한번 조사해 보세요!\n\n### 6. 메모리 사용 최적화\n\n앱이 엄청 크다면, 메모리가 더 많이 필요할 수 있어요. 빌드나 실행 중 메모리 부족으로 속도가 느려지는 경우가 종종 있거든요. 개발 환경에서 메모리 설정을 늘리거나, 불필요한 모듈을 정리해서 메모리 사용량을 줄여보는 게 도움이 될 수 있습니다.\n\n---\n\n> 팁: Node.js를 쓰신다면, `--max-old-space-size` 옵션으로 메모리 제한을 늘려줄 수 있어요. 예를 들어 `node --max-old-space-size=4096`은 최대 힙 메모리를 4GB로 확장하니, 빌드가 훨씬 여유로워질 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n메모리 사용 최적화에 관한 공부를 계속해보면서, 이번에는 서버 컴포넌트와 데이터 패칭에 대해 이야기해볼게요.\n\n### 7. 서버 컴포넌트와 데이터 가져오기\n\n서버 컴포넌트가 변경되면 그 페이지 전체가 다시 렌더링돼요. 이 과정에서 해당 컴포넌트에 필요한 새로운 데이터를 다시 가져오게 되죠. 이게 로컬 개발 시에는 꽤 번거롭고, 자칫하면 불필요한 API 호출이 많아져 비용이 증가할 수 있어요.\n\n여기서 실험적으로 제공되는 옵션인 `serverComponentsHmrCache`를 활용하면, 서버 컴포넌트가 변경되어도 핫 모듈 교체(HMR) 과정 중에 fetch한 응답을 캐싱해둘 수 있어요. 즉, 다시 똑같은 데이터를 요청하지 않고 캐시된 데이터를 재사용함으로써, 훨씬 빠르게 페이지를 업데이트할 수 있고, API 호출 횟수도 줄일 수 있답니다.\n\n---\n\n사실 이런 캐싱 옵션을 잘 활용하면 개발 속도가 눈에 띄게 빨라지고, 특히 외부 API 호출에 비용이 붙는 상황에서는 큰 절약 효과를 볼 수 있어요. 다만, 이 기능이 아직 실험 단계라는 점은 참고하세요. 즉, 실제 운영 환경에서는 예상치 못한 이슈가 발생할 수 있으니 로컬 개발용으로만 활용하는 걸 추천합니다.\n\n추가로, 서버 컴포넌트에서 데이터 패칭을 최적화할 때는 캐시 적중률을 높이도록 데이터 요청을 일관성 있게 만드는 것도 중요해요. 예를 들어, 쿼리 파라미터를 변동 없이 사용하거나, 필요한 데이터만 정확히 요청하면 캐싱 효율이 확 올라갑니다.\n\n---\n\n요약해서 핵심 내용만 짚어드리면 아래 표처럼 정리할 수 있어요.\n\n| 개념                          | 설명                                               | 장점                                                     | 주의사항                      |\n|-----------------------------|--------------------------------------------------|--------------------------------------------------------|----------------------------|\n| 서버 컴포넌트 렌더링 변경           | 컴포넌트 변경 시 페이지 전체가 다시 렌더링되고 데이터 재요청 발생       | 최신 데이터를 반영하는 깨끗한 렌더링                            | 과도한 API 호출 발생 가능           |\n| serverComponentsHmrCache 옵션 | HMR 동안 서버 컴포넌트 데이터 fetch 결과를 캐싱                     | 빠른 반응 속도, API 호출 비용 절감                              | 아직 실험 기능, 로컬 개발용 추천       |\n\n앞으로도 메모리뿐 아니라 개발 효율과 비용 절감에 도움되는 이런 팁들을 계속 소개할게요. 혹시 서버 컴포넌트 관련해서 더 궁금한 점 있으면 알려주세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n실험적인 옵션에 대해 더 알아보기\n\n## 문제를 찾는 데 도움이 되는 도구들\n\n### 자세한 fetch 로그 기록\n\n개발 중에 무슨 일이 일어나고 있는지 더 자세히 보고 싶을 때는 이 명령어를 사용해 보세요:\n\n```bash\nFETCH_LOG_LEVEL=debug npm start\n```\n\n(예: FETCH_LOG_LEVEL 환경 변수를 debug로 설정하고 앱을 실행하는 방법)\n\n이렇게 하면 fetch 요청과 응답에 관련된 상세한 정보가 로그로 출력돼서, 네트워크 문제나 데이터 처리 과정에서 무슨 일이 일어나는지 더 쉽게 파악할 수 있어요.\n\n---\n\n추가로, 개발할 때 이런 로그를 꼼꼼히 살펴보는 습관을 들이면 문제를 빨리 찾고 해결하는 데 큰 도움이 됩니다. 특히 API 호출이 많거나 비동기 처리 로직이 복잡한 프로젝트일수록요.\n\n그리고 fetch 관련 로그뿐만 아니라, 다른 요청이나 상태 변화를 추적할 수 있는 도구(예: 브라우저의 개발자 도구 네트워크 탭, Redux DevTools 등)도 같이 활용하면 문제 파악이 훨씬 수월합니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```bash\nnext dev --verbose\n```\n\n## Turbopack 추적 기능 활용하기\n\nTurbopack tracing은 로컬 개발 중에 애플리케이션의 성능을 분석하는 데 도움을 주는 도구예요. 각 모듈이 컴파일되는 데 걸리는 시간과 모듈 간의 연관성을 자세히 보여주기 때문에, 느린 부분이나 문제점을 찾아내는 데 유용하답니다.\n\n### Turbopack 추적을 시작하는 방법\n\n1. **Next.js 최신 버전 확인**  \n   Turbopack tracing은 최신 Next.js 버전에서 제대로 동작하니, 먼저 `next` 패키지가 최신인지 확인해주세요.\n\n2. **추적 파일 생성하기**  \n   다음 명령어를 통해 개발 서버를 켜면서 추적을 활성화할 수 있어요:\n\n   bash\n   NEXT_TURBOPACK_TRACING=1 npm run dev\n   \n   \n   개발하면서 페이지를 이동하거나 파일을 수정하면서 문제를 재현해 보세요.\n\n3. **서버 종료 후 추적 파일 확인**  \n   개발 서버를 끄면 `.next` 폴더 안에 `trace-turbopack`이라는 추적 파일이 생성됩니다.\n\n4. **추적 파일 해석하기**  \n   생성된 파일을 분석하려면 아래 커맨드를 실행하세요:\n\n   bash\n   next internal trace .next/trace-turbopack\n   \n\n   만약 `trace` 명령어가 없으면, 구버전에서는 `turbo-trace-server`라는 이름이었으니 아래 명령어를 써보시면 돼요:\n\n   bash\n   next internal turbo-trace-server .next/trace-turbopack\n   \n\n5. **웹에서 추적 결과 보기**  \n   명령어를 실행해 추적 서버가 켜지면, 브라우저에서 [https://trace.nextjs.org/](https://trace.nextjs.org/)로 접속해 결과를 확인할 수 있습니다.\n\n### 추가 팁 - 타이밍 정보 보는 법\n\n기본적으로 추적 뷰어는 타이밍을 집계해서 보여주는데요, 전체 타이밍 뿐 아니라 각 작업별 상세 타이밍을 보고 싶을 땐 오른쪽 위에서 \"Aggregated in order\"를 \"Spans in order\"로 변경해 주세요. 그러면 모듈별 구체적인 컴파일 시간을 살펴볼 수 있답니다.\n\n---\n\nTurbopack tracing은 복잡한 의존성이나 느린 모듈 문제를 잡을 때 정말 강력한 도구예요. 특히 대규모 프로젝트를 다룰 때 성능 병목을 쉽게 발견할 수 있어 개발 생산성을 크게 높여주죠. Next.js를 사용하면서 느려짐을 체감한다면 꼭 한 번 활용해 보시길 추천드립니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 아직 문제 해결이 안 되셨나요?\n\nTurbopack 트레이싱 섹션에서 생성된 트레이스 파일을 공유해 주세요.  \n그 파일을 GitHub Discussions나 Discord에 올리면 더 빠르게 도움을 받을 수 있어요!\n\n추가 팁을 드리자면, 트레이스 파일에는 실행 흐름에 대한 정보가 담겨 있어서 문제를 분석하는 데 큰 도움이 됩니다.  \n그러니 가능하면 문제 상황을 최대한 자세히 적어 함께 올려 주세요. 그러면 개발자나 커뮤니티 멤버들이 더 정확하게 도움을 줄 수 있답니다!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":16},{"title":"Next.js 15에서 패키지 번들링 최적화하는 방법","description":"","date":"2025-04-22 02:04","slug":"2025-04-22-OptimizingPackageBundling","content":"\n\n# 패키지 번들링 최적화하기\n\n외부 패키지를 번들링하면 애플리케이션의 성능을 크게 향상시킬 수 있어요. Next.js에서는 기본적으로 Server Components와 Route Handlers 안에서 임포트한 패키지들을 자동으로 번들링해줍니다. 이번 글에서는 패키지 번들링을 어떻게 분석하고, 더 최적화할 수 있는지 알려드릴게요.\n\n## 자바스크립트 번들 분석하기\n\n`@next/bundle-analyzer`는 Next.js에서 사용 가능한 플러그인으로, 애플리케이션 번들의 크기를 관리하는 데 도움을 줍니다. 이 플러그인은 각 패키지와 그 의존성들의 크기를 시각적으로 보여주는 리포트를 만들어줘서, 큰 크기의 패키지를 찾아내거나 코드 스플리팅, 혹은 지연 로딩(lazy loading)을 적용하는 데 활용할 수 있죠.\n\n### 추가 팁!\n\n- 번들 크기가 예상보다 크다면, 대체할 수 있는 가벼운 라이브러리가 있는지 찾아보세요.\n- 필요하지 않은 패키지는 과감히 삭제하는 것도 중요합니다.\n- 코드 스플리팅을 활용해 페이지별로 필요한 코드만 로드하는 것도 좋은 방법이에요.\n\n필요하다면 `package.json`에 아래 명령어를 추가해서 쉽게 번들 분석을 실행할 수 있습니다.\n\n```json\n\"scripts\": {\n  \"analyze\": \"cross-env ANALYZE=true next build\"\n}\n```\n\n그리고 터미널에서 `npm run analyze` 또는 `yarn analyze` 명령어를 실행하면, 번들 분석 리포트가 뜹니다.\n\n패키지 번들 사이즈를 잘 관리하면 로딩 속도가 빨라지고 사용자 경험이 훨씬 좋아지니 꼭 신경 써보세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 설치 방법\n\n플러그인을 설치하려면 아래 명령어 중 하나를 터미널에 입력하세요:\n\n```bash\nnpm i @next/bundle-analyzer\n# 또는\nyarn add @next/bundle-analyzer\n# 또는\npnpm add @next/bundle-analyzer\n```\n\n그다음, `next.config.js` 파일에 번들 분석기 설정을 추가해주면 됩니다.\n\n---\n\n참고로, `@next/bundle-analyzer`는 Next.js 프로젝트에서 번들 크기를 시각적으로 확인할 수 있게 도와줘서, 최적화 작업할 때 정말 유용한 도구예요. 어떤 파일이 용량이 큰지, 어디에 리소스를 많이 쓰는지 쉽게 파악할 수 있거든요.\n\n`next.config.js`에 설정하는 예시는 다음과 같아요:\n\n```js\nconst withBundleAnalyzer = require('@next/bundle-analyzer')({\n  enabled: process.env.ANALYZE === 'true',\n});\n\nmodule.exports = withBundleAnalyzer({\n  // 기존 Next.js 설정들...\n});\n```\n\n실행할 때 `ANALYZE=true` 환경 변수를 주면 번들 분석기가 활성화되고, 그렇지 않으면 비활성화되어 평상시에는 빌드 속도에 영향을 주지 않아요.\n\n이를 통해 필요할 때만 번들 분석기를 켜고, 평상시에는 쾌적한 개발 환경을 유지할 수 있습니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이번에는 Next.js 프로젝트에서 번들 사이즈를 쉽게 분석할 수 있는 방법을 알려드릴게요. 번들러 분석기를 붙여서, 빌드 결과물을 시각적으로 확인할 수 있게 해주는 도구인데요. 다음과 같이 `@next/bundle-analyzer` 패키지를 활용하면 됩니다.\n\n먼저, `next.config.js` 파일에 아래처럼 설정을 추가해 주세요:\n\n```js\n/** @type {import('next').NextConfig} */\nconst nextConfig = {}\n\nconst withBundleAnalyzer = require('@next/bundle-analyzer')({\n  enabled: process.env.ANALYZE === 'true',\n})\n\nmodule.exports = withBundleAnalyzer(nextConfig)\n```\n\n여기서 핵심은 `ANALYZE` 환경 변수를 `true`로 설정해서, 번들 분석 기능을 켜는 거예요. 실제 빌드를 할 때만 분석기가 동작하도록 설정해서, 평소에는 성능에 영향이 없도록 해 줍니다.\n\n분석 보고서를 보려면, 아래 명령어 중 하나를 내리면 끝!\n\n```bash\nANALYZE=true npm run build\n# or\nANALYZE=true yarn build\n# or\nANALYZE=true pnpm build\n```\n\n이렇게 하면, 빌드가 완료된 후에 `.next` 폴더 안에 번들 분석 리포트가 생성되는데요, 기본적으로는 브라우저에서 시각적인 트리맵 형태를 확인할 수 있어요.\n\n---\n\n### 조금 더 팁!\n\n- 번들 분석기를 쓰는 이유는 무엇일까요? 프로젝트가 커질수록 예상치 못한 패키지가 번들에 포함되거나, 너무 큰 라이브러리가 들어가서 페이지 로딩 속도가 느려질 수 있어요. 이걸 시각적으로 확인하고 최적화 방향을 잡을 수 있답니다.\n- `withBundleAnalyzer`처럼 Next.js는 여러가지 플러그인 형태의 설정을 감싸서 사용할 수 있어요. 만약 다른 기능을 같이 쓰는 중이라면 `compose` 형태로 합쳐주는 방법도 찾을 수 있습니다.\n- 만약 자동으로 보고서를 열고 싶다면, 추가 설정을 주거나 별도의 스크립트를 작성해도 좋습니다.\n\n이제 내 프로젝트 번들이 얼마나 크고, 어디에 무거운 부분이 있는지 손쉽게 분석해 보세요! 개발할 때 정말 큰 도움이 될 거예요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n보고서는 브라우저에서 세 개의 새 탭을 열어서 확인할 수 있어요. 이렇게 주기적으로 애플리케이션의 번들 파일을 평가하는 습관은 시간이 지나도 앱 성능을 잘 유지하는 데 큰 도움이 된답니다.\n\n## 패키지 임포트 최적화하기\n\n예를 들어 아이콘 라이브러리 같은 패키지는 수백 개의 모듈을 한꺼번에 내보내서, 개발 환경이나 실제 서비스 환경 모두에서 성능 저하를 일으킬 수 있어요.\n\n그럴 때는 next.config.js 파일에 `optimizePackageImports` 옵션을 추가해보세요. 이 설정을 하면 실제로 사용하는 모듈만 로딩해서 불필요한 코드가 빠져나가거든요. 게다가 여전히 여러 개의 네임드 익스포트를 사용하는 것처럼 깔끔하게 import 문을 작성할 수 있어서, 개발할 때도 편리하답니다.\n\n---\n\n추가로, 이 방법은 번들 크기를 줄여 로딩 속도를 개선할 뿐 아니라, 특히 대형 프로젝트에서 빌드 시간도 단축시켜주니까 꼭 적용해보길 권해요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js 설정에서 `optimizePackageImports`와 `serverExternalPackages` 옵션에 대해 알아볼게요.\n\n---\n\n```js\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  experimental: {\n    optimizePackageImports: ['icon-library'],\n  },\n}\n\nmodule.exports = nextConfig\n```\n\n위 코드는 `experimental.optimizePackageImports`에 `'icon-library'`라는 특정 라이브러리를 넣어둔 모습인데요, 이 옵션은 Next.js가 이 라이브러리를 임포트할 때 최적화하도록 지시하는 역할을 해요.\n\n### 자동 최적화되는 라이브러리가 있다?!  \n사실 Next.js는 기본적으로 자주 쓰이는 몇몇 라이브러리들을 알아서 최적화해주고 있어서, 모든 라이브러리를 `optimizePackageImports`에 적어줄 필요는 없답니다. 예를 들어 React, lodash 등 자주 쓰이는 라이브러리는 이미 최적화 대상에 포함되어 있어서 따로 추가 안 해도 된다구요.  \n> [Next.js 공식 문서](https://nextjs.org/docs/pages/building-your-application/configuring/optimizing-packages#opt-in-to-automatic-package-import-optimization)에서 최적화 대상 라이브러리 ‘풀 리스트’를 확인할 수 있어요. \n\n### 서버 사이드에서 번들링 제외하기  \n\nNext.js에서는 **서버 컴포넌트(Server Components)** 와 **라우트 핸들러(Route Handlers)** 내부에서 임포트한 패키지들은 기본적으로 번들링되어 배포돼요. 근데 가끔씩은, 특정 패키지를 번들링 대상에서 제외하고 싶을 때가 있습니다. 이럴 때는 `serverExternalPackages` 옵션을 사용하면 되는데요! 예를 들면 이렇게요:\n\n```js\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  experimental: {\n    serverExternalPackages: ['some-server-only-package'],\n  },\n}\n\nmodule.exports = nextConfig\n```\n\n`serverExternalPackages`에 등록한 패키지는 서버 번들에서 제외되고, 런타임에 직접 Node.js 환경에서 불러와 사용하게 됩니다. 이러면 서버 번들 크기를 좀 더 가볍게 유지하거나, 예를 들어 네이티브 모듈이나 빌드 시점에 번들링 불가능한 라이브러리를 다룰 때 도움이 돼요.\n\n---\n\n### 정리하자면  \n\n| 설정 옵션               | 역할                                                         |\n|------------------------|------------------------------------------------------------|\n| `experimental.optimizePackageImports` | 특정 클라이언트 라이브러리를 import 최적화하도록 설정        |\n| `experimental.serverExternalPackages` | 서버 컴포넌트, 라우트 핸들러 번들에서 제외할 패키지를 지정함   |\n\n이 옵션들은 `experimental`이 붙어있는걸로 보아 아직 완전히 안정화된 기능은 아니지만, 프로젝트에 맞게 적절히 활용하면 번들 크기 최적화에 꽤 도움이 될 수 있어요.\n\n---\n\nNext.js로 개발하면서 번들 최적화에 관심이 많다면 꼭 참고해보시고, 직접 적용해서 번들 크기 변화를 한 번 살펴보세요! 최적화가 잘 되면 페이지 로딩 속도와 사용자 경험이 훨씬 개선될 거예요. :)\n\n필요하면 더 자세한 설정법이나 실전 예제도 공유해드릴게요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안녕하세요 여러분! 오늘은 Next.js에서 `serverExternalPackages` 옵션에 대해 간단히 이야기해보려고 해요. \n\n```js\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  serverExternalPackages: ['package-name'],\n}\n\nmodule.exports = nextConfig\n```\n\n위 코드처럼 `next.config.js`에 `serverExternalPackages`에 외부 패키지 이름을 명시해주면, Next.js 서버 쪽에서 해당 패키지를 외부 모듈로 처리하도록 설정할 수 있어요. \n\n이 옵션은 서버에서만 사용하는 패키지나, Next.js가 기본적으로 번들링하지 않는 패키지를 명시할 때 유용합니다. 특히 서버 사이드에서 동작하는 Node.js 패키지를 사용할 때 문제가 발생할 수 있는데, 이때 `serverExternalPackages`에 해당 패키지를 추가해주면 해결되곤 하죠.\n\n> 참고로 Next.js가 이미 호환성을 검증하고 자동으로 제외 처리하는 인기 패키지 목록이 따로 있어요. 여러분이 직접 추가하기 전에 [Next.js 공식 문서](https://nextjs.org/docs)에서 지원하는 패키지 리스트를 확인해보는 게 좋아요. 이렇게 하면 중복 설정을 줄일 수 있거든요!\n\n---\n추가로 팁을 드리자면, 서버 외부 패키지를 추가할 때는 버전 호환성도 꼭 체크하세요. Next.js가 업데이트되면서 패키지 호환성도 변화할 수 있습니다. 그리고 외부 패키지를 너무 많이 추가하면 번들링 최적화가 어려워질 수 있으니 꼭 필요한 패키지만 추가하는 걸 추천해드려요.\n\n필요하면 Next.js의 Webpack 설정을 커스텀해서 좀 더 세밀한 번들링 조정도 가능합니다. 나중에 기회되면 Webpack 설정과 함께 리뷰해볼게요!\n\n궁금한 점 있으면 댓글 남겨주세요~ 개발 재미있게 함께 해봐요! 🚀","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":8},{"title":"Next.js 15에서 부분 프리렌더링(Partial Prerendering) 활용하는 방법","description":"","date":"2025-04-22 02:03","slug":"2025-04-22-PartialPrerendering","content":"\n# 부분 프리렌더링 (Partial Prerendering)\n\n> 참고: 부분 프리렌더링은 아직 실험적인 기능으로, Next.js의 캐나리 버전에서만 사용 가능하며 추후 변경될 수 있습니다. 아직 프로덕션용으로는 적합하지 않아요.\n\n부분 프리렌더링은 한 경로(Route) 내에서 정적인 컴포넌트와 동적인 컴포넌트를 동시에 사용할 수 있게 해 주는 기능입니다.\n\n어떻게 동작하냐면, 빌드 타임에 Next.js가 가능한 한 경로의 내용을 미리 렌더링해줍니다. 그런데 만약 동적 코드를 발견했다면(예를 들면, 들어오는 요청에서 데이터를 읽는다거나 할 때), 그 부분을 React Suspense 경계로 감싸줄 수 있어요. 이렇게 Suspense로 감싸진 컴포넌트는 빌드 시점에 실제 동적 데이터 대신 'fallback' UI가 미리 렌더링된 HTML로 포함됩니다.\n\n즉, 정적인 부분은 그대로 미리 렌더링하고, 동적인 부분은 사용자가 페이지를 요청할 때 불러오는 방식을 섞어 쓸 수 있는 거죠.\n\n---\n\n### 조금 더 쉽게 이야기하면?\n\n보통 Next.js의 정적 페이지는 모든 내용을 빌드할 때 미리 만들어 놓아요. 그런데 동적인 데이터가 있으면 빌드할 때 알 수 없으니 SSR(서버 사이드 렌더링) 방식으로 페이지를 채우죠. Partial Prerendering은 이 두 가지 방식을 한 페이지에서 섞어 쓸 수 있게 해 줍니다.\n\nReact Suspense를 잘 활용할 줄 안다면, 특정 컴포넌트에서 데이터를 읽는 부분만 동적으로 처리하고, 나머지는 미리 만들어진 HTML로 빠르게 보여줄 수 있다는 뜻입니다.\n\n---\n\n### 참고로 알아두면 좋은 점\n\n- 현재는 실험적인 기능이니 코드에 적용할 때는 주의하세요.\n- Suspense fallback UI가 어떻게 보일지 신경 써야 합니다. 너무 단순하면 사용자 경험이 떨어질 수 있어요.\n- Next.js가 이 기능을 점점 개선할 예정이기 때문에 공식 문서나 릴리즈 노트를 꾸준히 확인하는 게 좋아요.\n\n이런 기능 덕분에 더 빠르고 유연한 렌더링 경험을 제공하는 것이 앞으로의 목표입니다!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/TIL/assets/img/2025-04-22-PartialPrerendering_0.png\" alt=\"Partial Prerendering illustration\" />\n\n> 🎥 영상: PPR이 뭔지, 어떻게 동작하는지 궁금하다면 → YouTube에서 10분짜리 동영상으로 확인해보세요!\n\n---\n\n## 배경 이야기\n\nPartial Prerendering (부분 사전 렌더링, 이하 PPR)은 Next.js 서버가 미리 렌더링된 콘텐츠를 즉시 클라이언트에 전달할 수 있도록 도와주는 기술이에요.\n\n사실, 웹 페이지를 렌더링할 때 서버가 완전히 렌더링을 마치지 않았는데도 이미 사용자에게 콘텐츠를 보여줄 수 있으면, 빠른 첫 화면 로딩을 경험할 수 있죠. PPR은 그걸 가능하게 합니다.\n\n실제로 개발해보면, 전체 페이지를 미리 렌더링하는 것보다 특정 중요한 부분만 미리 렌더링하고, 나머지는 필요할 때 로드하게끔 하는 전략이 성능 최적화에 엄청 효과적이라는 걸 알 수 있어요.\n\n필요한 부분만 빠르게 보여주고, 나머지는 나중에 채우는 이 방법! 여러분 프로젝트에도 적용해보시면 사용자 체감 속도가 확 올라간답니다. 다음 글에서는 PPR을 Next.js에 적용하는 구체적인 방법을 소개할게요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n클라이언트에서 서버로 이어지는 워터폴 문제를 막기 위해, 동적 컴포넌트들은 초기 프리렌더링과 함께 서버에서 병렬로 스트리밍되기 시작합니다. 이렇게 하면 클라이언트의 자바스크립트가 브라우저에 완전히 로드되기 전에 동적 컴포넌트가 렌더링을 시작할 수 있어 사용자 경험이 훨씬 부드러워집니다.\n\n또한, 각각의 동적 컴포넌트마다 HTTP 요청을 여러 번 보내는 것을 막기 위해 부분 프리렌더링(Partial Prerendering, PPR)은 정적 프리렌더와 동적 컴포넌트를 하나의 HTTP 요청으로 합칠 수 있습니다. 이 덕분에 동적 컴포넌트마다 네트워크 왕복(roundtrip)이 발생하지 않고, 전체적인 로딩 속도가 크게 개선돼요.\n\n## 부분 프리렌더링(Partial Prerendering) 사용법\n\n### 점진적 도입 (버전 15 캐나리 버전 기준)\n\n---\n\n추가로, 이런 방식은 특히 대규모 애플리케이션에서 효과적이에요. 서버에서 먼저 준비된 콘텐츠를 빠르게 보여주면서도, 필요한 부분은 필요한 시점에만 동적으로 로딩하니 네트워크 자원도 효율적으로 사용할 수 있죠.\n\n또한, 만약 여러분이 React나 Next.js 같은 프레임워크를 쓴다면, 이 Partial Prerendering 기능을 잘 활용하면 SEO 측면에서도 유리하고 초기 렌더링 퍼포먼스도 개선할 수 있어요. 초기 페이지 로딩 후 바로 상호작용할 수 있게 만드는 ‘경량화’ 전략이라고 생각하면 이해가 쉬울 거예요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js 15 최신 캐나리(canary) 버전에서 'Partial Prerendering(PPR)' 기능이 실험적으로 도입되었어요. 아쉽게도 아직 안정화 버전에는 포함되어 있지 않습니다. 혹시나 미리 사용해보고 싶다면 캐나리 버전을 설치해야 하는데요, 아래 명령어를 터미널에 입력하면 됩니다.\n\n```bash\nnpm install next@canary\n```\n\n설치 후에는 프로젝트의 `next.config.js` 파일을 열어서 `ppr` 옵션을 `'incremental'`로 설정해 주세요. 그리고 다음과 같이 `experimental` 설정 안에 넣어주면 되는데요:\n\n```js\nimport type { NextConfig } from \"next\";\n\nconst nextConfig: NextConfig = {\n  experimental: {\n    ppr: \"incremental\",\n  },\n};\n\nexport default nextConfig;\n```\n\n그리고 페이지나 레이아웃 파일 상단에서 `experimental_ppr` 라우트 구성 옵션을 내보내면 부분 프리렌더링을 점진적으로 적용할 수 있어요.\n\n> 참고로, Partial Prerendering은 렌더링되지 않은 부분만 클라이언트에서 처리하면서도, 전체 페이지는 정적으로 일부 미리 렌더링하는 기술이에요. 그래서 초기 로딩은 빠르게 하면서도 일부 동적 변경이 가능한 유연한 페이지 구성이 가능하답니다.\n\n다만, 아직 실험 단계기 때문에 사용하면서 생길 수 있는 문제에 대비해 꼭 테스트 환경에서 충분히 점검하는 걸 추천드려요. 안정 버전이 나오면 더 많은 업데이트와 공식 문서가 함께 제공될 테니 주목해 주세요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n리액트(Next.js)에서 실험적 기능인 `experimental_ppr`(Partial Prerendering)를 활용하는 코드와 관련하여 알아두면 좋은 내용들을 정리해볼게요. 조금 쉽게 설명해볼게요!\n\n먼저, 제공된 코드를 보면 이렇게 생겼어요:\n\n```js\nimport { Suspense } from \"react\";\nimport { StaticComponent, DynamicComponent, Fallback } from \"@/app/ui\";\n\nexport const experimental_ppr = true;\n\nexport default function Page() {\n  return (\n    <>\n      <StaticComponent />\n      <Suspense fallback={<Fallback />}>\n        <DynamicComponent />\n      </Suspense>\n    </>\n  );\n}\n```\n\n---\n\n## 핵심 포인트! `experimental_ppr`란?\n\n- Next.js에서는 각 라우트별로 부분 프리렌더링을 할 수 있어요. (PPR)\n- **PPR(Partial Prerendering)**를 활용하려면, 라우트 최상위에 `export const experimental_ppr = true`를 반드시 선언해야 해요.\n- 만약 선언하지 않으면, 기본값은 `false`로 설정되어서 **프리렌더링이 되지 않아요**.\n- 이 설정은 해당 라우트뿐만 아니라, 그 아래 자식 라우트나 레이아웃까지 적용돼요.\n- 자식 라우트에서 PPR을 끄고 싶으면 자식 라우트에 `experimental_ppr = false`를 설정하면 됩니다.\n\n즉, `experimental_ppr` 옵션은 라우트 트리에서 상위(루트) 영역에만 넣으면 자식까지 적용이 돼서 여러 파일에 일일이 선언할 필요 없어요.\n\n---\n\n## Suspense와 dynamic components (동적 컴포넌트) 이야기\n\nPPR을 사용하는 라우트에서, Next.js 빌드 시에 반드시 동적 API 호출을 포함하는 컴포넌트는 `React.Suspense`로 감싸줘야 해요.\n\n- `Suspense`가 없다면 자동 프리렌더링이 제대로 작동하지 않아요.\n- `Suspense fallback`은 프리렌더된 페이지에서 **유저가 로딩 중일 때 보여질 UI**를 담당해줘요.\n- 위 코드에서는 `<Fallback />` 컴포넌트를 로딩 중임을 보여주기 위해 넣었죠!\n\n---\n\n## 추가로 알아두면 좋은 것들\n\n### 1. 왜 PPR을 쓰는 걸까?\n\n전통적인 SSR은 모든 데이터를 서버에서 다 받아와서 렌더링해버려서, 느린 API나 복잡한 로직이 있으면 전체 페이지 로딩 시간이 느려질 수 있어요.\n\nPPR은 정적 생성(Static Generation)과 SSR의 중간 느낌으로, \"정적 프리렌더링 중 동적 컴포넌트만 나중에 클라이언트 쪽에서 로딩\"하는 방식이에요.\n\n덕분에:\n\n- 페이지 첫 로딩은 빠르면서도,\n- 자주 바뀌는 동적인 부분은 필요한 시점에만 로딩 가능해요.\n\n### 2. `export const experimental_ppr = true`는 실험 기능!\n\n현재는 아직 실험 단계라서 문서나 API가 조금씩 바뀔 수 있어요. 프로덕션 서비스라면 주의해서 사용해야 하죠.\n\n---\n\n## 요약해서 정리한 표!\n\n| 내용                 | 설명                                                               |\n| -------------------- | ------------------------------------------------------------------ |\n| `experimental_ppr`   | 라우트(또는 세그먼트)에 프리렌더링을 활성화하는 플래그             |\n| 기본값               | false                                                              |\n| 적용범위             | 상위 세그먼트에만 선언하면 하위(자식 라우트, 레이아웃)에도 적용됨  |\n| 동적 컴포넌트 감싸기 | 동적 로딩 컴포넌트는 React Suspense로 감싸야 하며 fallback UI 필요 |\n| fallback UI          | 로딩 중 보여줄 UI. 보통 스피너나 텍스트 형태의 임시 UI를 넣음      |\n| 사용 목적            | 빠른 페이지 로딩 & 프리랜더링과 동적 API 호출의 적절한 조화        |\n| 주의점               | 아직 실험 기능이므로 버전 업에 따라 동작 변경 가능                 |\n\n---\n\n이렇게 `experimental_ppr`와 Suspense를 잘 활용하면 Next.js 앱에서 빠르고 유연한 프리렌더링을 경험할 수 있어요!\n\n필요하면 더 자세한 예제나, 로딩 UI 디자인 팁도 공유할 수 있으니, 언제든 요청해 주세요. 😊\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예를 들어 쿠키나 헤더 같은 함수들을 사용할 때는 이렇게 하게 돼요:\n\n```js\nimport { cookies } from \"next/headers\";\n\nexport async function User() {\n  const session = (await cookies()).get(\"session\")?.value;\n  return \"...\";\n}\n```\n\n위 코드에서 `User` 컴포넌트는 들어오는 요청(request)을 보고 쿠키를 읽어야 해서, 이 컴포넌트를 PPR(Pre-Rendering with React)로 사용하려면 Suspense로 감싸줘야 합니다.\n\nVue에서는 Suspense가 없지만, React에선 비동기 처리를 하면서도 사용자 경험을 끊기지 않게 해주는 좋은 기능이에요. 예를 들면 이렇게요:\n\n```js\nimport { Suspense } from \"react\";\nimport { User, AvatarSkeleton } from \"./user\";\n\nexport const experimental_ppr = true;\n\nexport default function Page() {\n  return (\n    <section>\n      <h1>This will be prerendered</h1>\n      <Suspense fallback={<AvatarSkeleton />}>\n        <User />\n      </Suspense>\n    </section>\n  );\n}\n```\n\n여기서 핵심은 `Suspense`의 `fallback` 프로퍼티에 로딩 상태에서 보여줄 UI를 넣어준다는 점이에요. 예시에서는 `AvatarSkeleton`이 그 역할을 하죠. 즉, `User` 컴포넌트가 쿠키를 읽어 세션 정보를 가져올 때까지 사용자에게 깜빡이며 로딩 중임을 알려주고, 완료되면 실제 UI를 렌더링하는 거죠.\n\n이렇게 하면 서버에서 미리 렌더링하는 부분과, 클라이언트에서 비동기적으로 받아와야 할 데이터가 함께 있어도 깔끔하게 처리할 수 있습니다. 특히 Next.js 최신 버전에서 SSR과 클라이언트 사이드 데이터 fetching을 조합할 때 정말 유용해요.\n\n추가 팁을 드리자면:\n\n- `cookies()` 같은 함수는 서버 측에서만 호출 가능해요. 클라이언트 컴포넌트에선 사용할 수 없으니 주의하세요.\n- Suspense를 활용하면서 데이터 fetching이 비동기임을 명확히 해줘야 하므로, 해당 컴포넌트는 async 함수로 작성하고 반드시 프로미스를 반환해야 해요.\n- PPR을 실험적으로 사용한다면, 나중에 정식 지원 상태를 꼼꼼히 확인하는 게 좋습니다. API가 변할 수도 있으니까요!\n\n요약하자면, 서버에서 요청별로 쿠키를 읽어야 하면, 해당 컴포넌트를 Suspense로 감싸서 로딩 상태를 관리하며 안전하게 렌더링하는 패턴! Next.js에서 점점 더 퍼져나가는 최신 트렌드랍니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n리액트 컴포넌트가 언제 '동적 렌더링(dynamic rendering)'을 하게 될까요? 바로 컴포넌트 내부에서 특정 값을 실제로 사용할 때입니다.\n\n예를 들어, Next.js 페이지에서 `searchParams`를 받아 이를 자식 컴포넌트에 prop으로 넘긴 상황을 생각해볼게요:\n\n```js\nimport { Table } from \"./table\";\n\nexport default function Page({ searchParams }: { searchParams: Promise<{ sort: string }> }) {\n  return (\n    <section>\n      <h1>This will be prerendered</h1>\n      <Table searchParams={searchParams} />\n    </section>\n  );\n}\n```\n\n위 코드에서 `Page` 컴포넌트는 `searchParams`를 받아서 내부 `Table` 컴포넌트로 전달하고 있는데요. 중요한 점은, 이 `Page` 컴포넌트 자체는 프리렌더링(정적 생성)이 되지만, `Table` 컴포넌트 안에서 이 `searchParams` 값을 실제로 읽으면, `Table`만 동적 렌더링 상태로 전환됩니다.\n\n즉, 부모는 정적으로 렌더링 되다가, 자식에서 비동기 값을 접근하는 순간 그 자식 컴포넌트는 실시간으로 렌더링되는 거죠. 이런 방식으로 불필요한 동적 렌더링을 방지하면서, 꼭 필요한 부분만 동적으로 처리할 수 있는 효율적인 구조가 완성됩니다.\n\n---\n\n추가로, 만약 `searchParams`를 여러 군데서 반복해서 사용한다면, 값을 미리 받아서 context에 저장하거나 캐싱하는 방법도 좋아요. 그래야 여러 컴포넌트에서 같은 값을 비동기로 반복 요청하는 부담을 줄일 수 있죠. 개발하면서 이런 패턴을 잘 활용하면 렌더링 성능과 사용자 경험이 꽤 좋아질 거예요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안녕하세요! 오늘은 React 컴포넌트에서 `searchParams`를 비동기 함수로 받아올 때 주의할 점에 대해 같이 살펴볼게요.\n\n아래 예제를 보실까요?\n\n```js\nexport async function Table({ searchParams }: { searchParams: Promise<{ sort: string }> }) {\n  const sort = (await searchParams).sort === \"true\";\n  return \"...\";\n}\n```\n\n여기서 `searchParams`가 `{ sort: string }` 객체를 반환하는 Promise네요. 그래서 컴포넌트 함수 앞에 `async` 키워드를 붙이고, `await`로 값을 받아옵니다.\n\n하지만 React 컴포넌트에서 이렇게 `async` 함수를 직접 쓰는 게 늘 좋은 방식은 아니에요. 왜냐하면 컴포넌트 자체가 렌더링 시 동기적으로 작동하는 걸 기대하기 때문에, 여기에 비동기 처리를 넣으면 의도치 않은 동작이나 렌더링 지연이 발생할 수 있거든요.\n\n그래서 보통은 이런 식으로:\n\n- `getServerSideProps` (Next.js) 같은 서버사이드 데이터 로딩 함수에서 데이터를 먼저 받고,\n- 데이터를 props로 내려받아 컴포넌트는 동기적으로 렌더링하는 게 깔끔해요.\n\n만약 Next.js의 **App Router**를 사용중이라면, 페이지나 UI 컴포넌트에서 `searchParams`는 이미 동기적인 객체로 제공됩니다. 그래서 이렇게 쓸 수 있죠:\n\n```tsx\ntype TableProps = {\n  searchParams: { sort?: string };\n};\n\nexport default function Table({ searchParams }: TableProps) {\n  const sort = searchParams.sort === \"true\";\n  return <div>정렬 상태: {sort ? \"활성화\" : \"비활성화\"}</div>;\n}\n```\n\n마지막으로 `sort` 값을 단순히 문자열 `\"true\"`와 비교했는데, 혹시 `\"true\"`나 `\"false\"` 외에 다양한 값이 올 수도 있으니 `Boolean` 변환이나 다른 검증 로직도 상황에 맞게 활용해보세요!\n\n---\n\n### 짧은 요약\n\n| 문제점                                           | 해결법                                                                  |\n| ------------------------------------------------ | ----------------------------------------------------------------------- |\n| 컴포넌트를 `async` 함수로 만들어 비동기 받아오기 | 서버사이드 또는 별도 데이터 fetching 함수로 데이터 받고, props로 넘기기 |\n| `searchParams` Promise 형태 사용                 | Next.js App Router에서는 동기 객체로 바로 받아 사용 가능                |\n\n이렇게 살짝만 더 신경 쓰면 깔끔하고 버그 없이 데이터를 다룰 수 있어서 추천드립니다! 필요하면 더 깊게 React와 Next.js의 데이터 흐름도 알려드릴게요~ 행복한 개발 되세요! 🚀\n","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":12},{"title":"Next.js 15에서 Incremental Static Regeneration(ISR)로 정적 웹사이트 업데이트 하기","description":"","date":"2025-04-22 02:01","slug":"2025-04-22-IncrementalStaticRegenerationISR","content":"\n\n# Incremental Static Regeneration (ISR)이란?\n\n안녕하세요! 오늘은 **Incremental Static Regeneration (ISR)**에 대해 쉽고 간단하게 이야기해보려고 해요. ISR은 특히 Next.js 같은 프레임워크에서 자주 쓰이는 개념인데, 기본적으로 정적 페이지를 효율적으로 업데이트할 수 있게 해주는 방법이에요.\n\n---\n\n## ISR이 왜 좋을까?\n\n- **전체 사이트를 다시 빌드하지 않아도 돼요!**  \n  기존에 정적으로 생성된 페이지들을 모두 다시 생성하는 대신, 바뀐 페이지만 업데이트할 수 있답니다.\n\n- **서버 부하가 줄어들어요.**  \n  거의 대부분의 요청에 대해 이미 만들어진 정적 페이지를 바로 보여주기 때문에 서버가 한결 가벼워져요.\n\n- **cache-control 헤더가 자동으로 달려요.**  \n  페이지마다 적절한 캐시 정책이 적용되어서, 사용자에게 빠른 경험을 제공할 수 있어요.\n\n- **콘텐츠가 많은 사이트도 걱정 끝!**  \n  많은 페이지를 가진 사이트도 빌드 시간이 너무 길어지는 걸 피할 수 있어요.\n\n---\n\n## 간단한 예시\n\n다음은 ISR을 활용한 아주 기본적인 Next.js의 `getStaticProps` 예시입니다.\n\n```jsx\nexport async function getStaticProps() {\n  const data = await fetchDataSomehow();\n\n  return {\n    props: {\n      data,\n    },\n    // 페이지가 60초마다 다시 생성되도록 설정\n    revalidate: 60,\n  };\n}\n```\n\n위에서 핵심은 `revalidate` 키예요. 여기서 60초를 지정했으니, 사용자가 페이지에 접속할 때마다 적어도 60초가 지난 후에는 새로 데이터를 가져와서 페이지를 다시 만들어줘요. \n\n즉, \"최소 60초 주기로 페이지를 갱신한다\" 라고 이해하면 돼요.\n\n---\n\n## 좀 더 알려드리는 팁!\n\n- `revalidate`에 너무 짧은 시간을 설정하면, 서버 부하가 다시 올라갈 수 있으니 적당한 값을 찾는 게 중요해요.\n- 현재 Next.js는 ISR을 사용하면서 자동으로 incremental cache를 관리해줍니다. 덕분에 개발자가 별도로 캐싱 로직을 신경 쓸 필요가 줄어듭니다.\n- 빌드 후 데이터가 자주 변경되는 뉴스, 블로그, 마켓플레이스 같은 서비스에서 굉장히 빛을 발합니다.\n\n---\n\n자, 오늘은 ISR에 대해서 간단히 알아봤는데요. 정적 사이트의 장점과 동적인 데이터 갱신을 함께 누리고 싶은 분들에게 정말 추천드리는 기술이에요. 더 궁금한 점이나 실제 예제 궁금하면 언제든지 댓글 달아주세요! 😊\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여러분, Next.js에서 동적 라우팅과 ISR(Incremental Static Regeneration)을 활용하는 예제를 하나 같이 살펴볼게요! 위에 작성된 코드를 바탕으로 우리 블로그 포스트 페이지를 만든다고 가정해봅시다.\n\n### 이 코드가 뭘 하는 거냐면요\n\n- `generateStaticParams` 함수 안에서 `https://api.vercel.app/blog` API를 호출해, 빌드 시점에 미리 25개의 블로그 포스트 경로를 생성해요.\n- 이렇게 미리 생성된 페이지들은 사용자 요청 시 즉시 로드되고 캐시되죠.\n- `revalidate = 60` 설정 덕분에, 60초마다 페이지가 백그라운드에서 다시 생성됩니다. 즉, 오래된 페이지를 보여주더라도 동시에 최신 페이지를 서버에서 준비시키는 거예요.\n- 만약 아직 생성하지 않은 새로운 블로그 포스트 URL이 들어오면, `dynamicParams = true` 설정 때문에 404 대신 서버에서 해당 페이지를 “on-demand”로 생성해줍니다.\n\n한 마디로, 정적 생성과 서버 사이드 렌더링의 장점을 적절히 섞어 어떤 페이지는 미리 생성해 빠르게 제공하고, 새 페이지는 요청이 들어올 때 만들어서 서비스하는 똑똑한 방식인 거죠!\n\n---\n\n### 조금 더 풀어서 설명해볼게요!\n\n| 설정                     | 설명                                                        |\n|-------------------------|-------------------------------------------------------------|\n| `revalidate = 60`       | 한번 캐싱한 페이지는 60초간 다시 생성하지 않고 캐시를 사용함. 60초 후 첫 요청 때 백그라운드로 새 페이지를 생성함. |\n| `dynamicParams = true`  | `generateStaticParams`에 없는 경로가 요청되면 404가 아닌 동적으로 페이지를 생성함. |\n| `generateStaticParams`  | 빌드 타임에 미리 생성할 동적 경로 목록을 반환함. 이 예제는 모든 블로그 포스트 ID가 여기 포함됨. |\n| `Page` 컴포넌트          | 요청된 `id` 파라미터로부터 해당 포스트를 API에서 받아와서 렌더링함. |\n\n---\n\n### 추가적으로 알아두면 좋은 점!\n\n- 이 방식은 데이터가 자주 변하지 않는 콘텐츠에 딱 맞아요. 아주 빠른 실시간 업데이트는 어렵지만, 몇 분 단위 변경이라면 사용자 경험을 살릴 수 있습니다.\n- 만약 완전 최신 데이터가 필요하면 `revalidate`를 0으로 두고 매 요청마다 서버 렌더링(SSR)을 할 수도 있어요. 하지만 속도는 느려질 수 있죠.\n- Next.js 13버전 이상에서 도입된 이 방식은 ISR과 동적 라우팅을 동시에 처리할 때 좋은 선택이니, 블로그나 뉴스 사이트 같은 프로젝트에 활용해보세요!\n\n---\n\n필요하면 제가 이 코드를 기반으로 직접 해볼 수 있는 샘플 프로젝트도 만들어서 공유해드릴게요. 혹시 관련해서 궁금한 점, 더 깊게 알고 싶은 부분 있으면 편하게 물어봐 주세요!\n\n참고로 공식 문서도 정말 잘 정리되어 있으니 한 번 쭉 읽어보시면 큰 도움이 됩니다.\n\n---\n\n## 참고 자료\n\n- [Next.js Dynamic Routes & ISR 공식 문서](https://nextjs.org/docs/app/building-your-application/routing/dynamic-routes#incremental-static-regeneration)\n- [Next.js 13 App Router 소개](https://nextjs.org/docs/getting-started/upgrade-guide#app-router)\n\n다음에도 쓸모 있는 Next.js 팁으로 찾아올게요! :)\n\n---\n\n> 혹시 이 내용을 마크다운 문서로 쓰거나 블로그에 올리고 싶다면 추가 설명과 코드는 댓글로도 언제든 요청해 주세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 라우트 세그먼트 설정(Route segment config)\n\n라우트를 잘 관리하려면 설정할 수 있는 옵션들이 몇 가지 있는데요, 대표적으로 `revalidate`와 `dynamicParams`가 있어요.\n\n| 옵션 이름       | 설명                                                         |\n|----------------|--------------------------------------------------------------|\n| revalidate     | 해당 라우트 데이터를 다시 검증하는 주기(초 단위)를 설정해요. 이걸 설정하면 데이터를 자동으로 갱신해서 최신 상태를 유지할 수 있답니다.  |\n| dynamicParams  | 라우트에서 동적 파라미터를 사용할지 여부를 결정해요. 동적 파라미터란 URL 경로 내에서 변하는 값들을 말하죠(예: `/post/[id]`의 `id`). 이 옵션으로 다루는 방식을 설정할 수 있어요. |\n\n---\n\n### 함수 소개(Functions)\n\n`revalidate`와 연관해서 사용할 수 있는 함수들도 있어요! 주로 캐시를 새로고침하거나 특정 경로를 다시 유효화하는 용도로 쓰이는데요.\n\n| 함수 이름       | 설명                                                                                          |\n|----------------|-----------------------------------------------------------------------------------------------|\n| revalidatePath  | 특정 경로(path)에 대해 데이터를 재검증하도록 요청하는 함수예요. 예를 들어, 어떤 글을 수정한 후 그 경로를 갱신할 때 사용하죠.  |\n| revalidateTag   | 태그(tag)를 이용해 어느 그룹에 속한 데이터들을 한 번에 다시 검증하도록 할 수 있어요. 여러 경로를 묶어서 관리할 때 유용해요.       |\n\n---\n\n### 덧붙여서\n\nNext.js 같은 최신 웹 프레임워크들에서 이런 revalidation 시스템을 잘 활용하면, 서버의 부담을 크게 줄이면서도 사용자에게 항상 최신 데이터를 보여줄 수 있어요. 예를 들어, 자주 변하지 않는 페이지는 캐시를 오래 유지하고, 실시간으로 변하는 페이지는 자주 재검증해서 최적 성능을 유지할 수 있죠.\n\n또한, `dynamicParams` 옵션을 올바르게 설정하면, 빌드 시에 미리 생성할 경로나 런타임에 처리할 경로를 적절하게 나눌 수 있어서 프로젝트 구조를 깔끔하게 유지하는데 큰 도움이 돼요.\n\n이런 설정과 함수들을 잘 이해하고 활용해보시면, 더욱 빠르고 효율적인 웹앱을 만들 수 있답니다. 궁금하신 점 있으면 언제든 질문 주세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 예시\n\n### 시간 기반 리밸리데이션(Time-based Revalidation)\n\n이 예시는 `/blog` 경로에서 블로그 글 목록을 불러와 보여주는 방법이에요. 그리고 중요한 점은 페이지에 캐시된 데이터가 1시간마다 새로 고쳐진다는 거죠. \n\n어떻게 동작하냐면, 첫 방문 시 데이터를 불러와서 캐시에 저장합니다. 그 후 1시간이 지나 다음에 페이지를 방문하면, 기존 캐시를 바로 버리고 다시 가져오는 게 아니라, 사용자에게는 기존 페이지를 보여주면서 백그라운드에선 새로운 글 목록으로 페이지를 다시 생성해 캐시를 업데이트해요. 덕분에 사용자는 항상 빠르고 끊김 없는 경험을, 백엔드는 최신 데이터를 보장할 수 있답니다.\n\n```js\ninterface Post {\n  id: string\n  title: string\n  content: string\n}\n \nexport const revalidate = 3600 // 3600초 = 1시간마다 캐시 무효화\n \nexport default async function Page() {\n  const data = await fetch('https://api.vercel.app/blog')\n  const posts: Post[] = await data.json()\n  return (\n    <main>\n      <h1>Blog Posts</h1>\n      <ul>\n        {posts.map((post) => (\n          <li key={post.id}>{post.title}</li>\n        ))}\n      </ul>\n    </main>\n  )\n}\n```\n\n---\n\n### 추가 팁!\n\n- 여기서 `revalidate` 값에 넣는 숫자는 초(seconds) 단위예요. 3600은 1시간을 의미하니까, 10분마다 갱신하려면 600으로 바꾸면 되겠죠?\n- 이렇게 시간 기반 갱신은 자주 변하지 않는 데이터에 딱이에요. 예를 들어 뉴스 헤드라인이나 프로필 정보처럼 자주 고쳐질 필요 없는 데이터를 캐시에 담기로 적합하죠.\n- 만약 데이터가 수시로 업데이트되어 즉각 반영이 필요하면 `revalidate`를 사용하지 않고 서버 사이드 렌더링(SSR) 또는 클라이언트 측 데이터 패칭을 고려해보세요.\n- `Next.js` 같은 최신 프레임워크를 쓰면 이런 캐시 전략을 아주 간편하게 구현할 수 있으니, 프로젝트에 따라 적절히 활용해보세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n재검증(revalidation) 시간을 길게 설정하는 걸 추천해요. 예를 들어, 1초 대신 1시간으로 말이죠. 만약 더 세밀한 데이터 갱신이 필요하다면 on-demand revalidation(필요할 때만 재검증)를 고려해보세요. 그리고 실시간 데이터가 꼭 필요하다면, 동적 렌더링(dynamic rendering)으로 전환하는 것도 좋은 방법입니다.\n\n### 필요할 때만 재검증: revalidatePath 활용법\n\n좀 더 정확하게 데이터 재검증을 하고 싶다면, revalidatePath 함수를 써서 페이지를 필요할 때만 무효화시키는 방법이 있어요.\n\n예를 들어, 새로운 게시글을 추가한 후에 이 Server Action을 호출하면, Server Component에서 fetch를 쓰든 DB에 직접 연결하든 상관없이 해당 경로(route)의 캐시를 지우고, Server Component가 새로운 데이터를 가져오도록 할 수 있습니다.\n\n이렇게 하면 불필요한 데이터 갱신을 줄이면서도 필요한 순간에 최신 데이터를 보여줄 수 있어서 성능과 사용자 경험 두 마리 토끼를 잡을 수 있답니다. \n\n간단하게 요약하면:\n\n| 상황                  | 추천 방법                         |\n|---------------------|------------------------------|\n| 데이터 갱신이 1초 단위로 자주 필요하다면 | on-demand revalidation 사용       |\n| 실시간 데이터가 꼭 필요하다면        | 동적 렌더링(dynamic rendering) 고려 |\n| 갱신 주기가 길어도 무방하다면       | 긴 revalidation 시간(예: 1시간) 설정 | \n\n이렇게 상황에 맞게 적절한 방법을 선택하는 게 중요해요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여러분, Next.js에서 서버 측 캐시를 관리할 때 `revalidatePath` 함수만큼 유용한 게 없어요. 위 코드처럼 `/posts` 경로의 캐시를 무효화하고 싶을 때 아주 간단하게 쓸 수 있거든요.\n\n```js\n'use server'\n \nimport { revalidatePath } from 'next/cache'\n \nexport async function createPost() {\n  // /posts 경로 캐시를 무효화하기\n  revalidatePath('/posts')\n}\n```\n\n이렇게 하면 새로운 게시글을 추가하고 나서 바로 `/posts`를 방문했을 때 최신 글 목록을 볼 수 있죠.\n\n### 근데, 만약 경로 단위가 아니라 더 세밀한 캐시 무효화가 필요하다면?\n\n바로 `revalidateTag`라는 기능을 써볼 수 있어요. 이건 fetch 요청에 태그를 달아서, 특정 태그가 붙은 데이터만 골라서 다시 불러오게 하는 방법이에요. 예를 들어, 게시글 하나하나에 태그를 붙여서 수정된 글만 빠르게 반영하도록 할 수 있죠.\n\n#### 간단 예시\n\n```js\n'use server'\n\nimport { revalidateTag } from 'next/cache'\n\nexport async function updatePost(id) {\n  // 특정 게시글에 붙은 태그를 기반으로 캐시를 무효화하기\n  revalidateTag(`post-${id}`)\n}\n```\n\nfetch를 할 때도 태그를 붙여줘야 하는데요,\n\n```js\nconst post = await fetch(`/api/posts/${id}`, {\n  next: { tags: [`post-${id}`] },\n}).then(res => res.json())\n```\n\n이렇게 하면 이 게시글은 `post-123` 같은 식으로 태그가 붙고, 해당 게시글이 업데이트될 때만 캐시가 무효화되어 더 효과적으로 리소스를 관리할 수 있답니다.\n\n---\n\n### 정리\n\n| 함수명           | 역할                           | 사용 케이스                               |\n|----------------|------------------------------|----------------------------------------|\n| `revalidatePath` | 경로 단위 캐시 무효화                | 페이지 전체를 새로 고쳐야 할 때                      |\n| `revalidateTag` | 태그 단위 캐시 무효화                | 데이터 단위로 세밀하게 캐시를 관리하고 싶을 때          |\n\n---\n\n이렇게 `revalidateTag`를 활용하면, 대용량 데이터나 자주 변경되는 목록이 있을 때 정말 도움 많이 돼요. 오늘 바로 적용해보시고 캐시 전략 더 똑똑하게 짜보세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서 데이터를 효율적으로 캐싱하고 다시 불러오는 방법에 대해 알아볼게요! 특히 `fetch` 함수와 ORM을 이용할 때, 그리고 캐시를 자동으로 재검증하는 방법까지 다뤄보겠습니다.\n\n---\n\n### 1. fetch 함수에 `next` 옵션으로 태그 지정하기\n\n```js\nexport default async function Page() {\n  const data = await fetch('https://api.vercel.app/blog', {\n    next: { tags: ['posts'] }, // 여기에 태그를 넣어 캐시를 관리할 수 있어요\n  })\n  const posts = await data.json()\n  // 이제 posts를 화면에 렌더링\n}\n```\n\n- `next: { tags: ['posts'] }` 옵션을 주면, 이 요청이 `'posts'`라는 태그와 연결돼서 관리돼요.\n- 나중에 `'posts'` 태그가 변경됐을 때 캐시를 재검증 할 수 있답니다.\n\n---\n\n### 2. ORM이나 DB 연결 시 `unstable_cache` 사용하기\n\n```js\nimport { unstable_cache } from 'next/cache'\nimport { db, posts } from '@/lib/db'\n \nconst getCachedPosts = unstable_cache(\n  async () => {\n    return await db.select().from(posts)  // 데이터베이스에서 포스트를 조회\n  },\n  ['posts'],                   // 캐시 관련 태그\n  { revalidate: 3600, tags: ['posts'] }  // 3600초(1시간)마다 재검증, tags와 연결\n)\n \nexport default async function Page() {\n  const posts = getCachedPosts()  // 캐시된 데이터를 불러옴\n  // ...\n}\n```\n\n- `unstable_cache` 함수는 캐시된 결과를 기억하며 해당 데이터를 재활용해요.\n- `revalidate` 옵션으로 몇 초마다 다시 데이터를 불러올지 설정할 수 있어요.\n- 태그를 사용해서 데이터를 더욱 세밀하게 관리 가능!\n\n---\n\n### 3. 캐시가 무효화되었을 때 재검증하기 - `revalidateTag` 활용\n\n서버 액션(Server Actions)이나 라우트 핸들러(Route Handler) 안에서 다음과 같이 캐시 태그를 재검증할 수 있습니다:\n\n```js\nimport { revalidateTag } from 'next/cache'\n\nexport async function POST(request) {\n  // 예를 들어 데이터를 변경하는 로직\n  // ...\n  \n  // 변경 후 'posts' 태그 관련 캐시를 재검증해서 최신 데이터 사용하도록 유도\n  revalidateTag('posts')\n\n  return new Response('Updated and cache revalidated')\n}\n```\n\n- 업데이트가 발생하면 캐시 무효화를 하면서 관련된 태그를 재검증합니다.\n- 이렇게 하면 데이터가 바뀌었을 때 페이지가 최신 상태로 렌더링돼요.\n\n---\n\n## 조금 더!\n\n- 이 태그 기반 캐시 전략은 여러 페이지에서 같은 API 데이터를 공유할 때 정말 유용해요.\n- `unstable_cache`는 아직 `unstable` 단계이니, 공식 문서나 업데이트 내용을 주의 깊게 지켜보는 게 좋아요.\n- `fetch` 함수의 `next` 옵션 중에 `revalidate` 값을 직접 지정할 수도 있고, `tags`와 혼합해서 사용하면 훨씬 강력한 캐싱 전략을 구성할 수 있습니다.\n\n잘 활용하면 페이지 성능과 데이터 일관성을 높일 수 있으니 여유 있을 때 한번 적용해보세요! 도움이 되셨으면 좋겠네요. 😊\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이번에는 Next.js에서 서버 측 캐시를 다루는 방법 중에서, revalidateTag 함수를 사용하는 간단한 예제를 살펴보고, 오류 처리와 캐시 위치 커스터마이징에 대해 알아볼게요.\n\n```js\n'use server'\n \nimport { revalidateTag } from 'next/cache'\n \nexport async function createPost() {\n  // 'posts'라는 태그가 붙은 모든 캐시 데이터를 무효화합니다.\n  revalidateTag('posts')\n}\n```\n\n위 코드에서 `revalidateTag('posts')`를 호출하면, 캐시에 'posts'라는 태그로 분류된 데이터가 모두 무효화되어 다음 요청 시 새로운 데이터를 다시 가져오도록 만듭니다. 이렇게 하면 게시글 리스트나 관련 콘텐츠가 업데이트될 때, 서버 캐시를 손쉽게 갱신할 수 있죠.\n\n### 예기치 않은 예외 처리 (Handling uncaught exceptions)\n\n만약 데이터 재검증 중에 에러가 발생한다면, Next.js는 바로 새로운 데이터 요청을 실패하더라도 이전에 성공적으로 생성된 데이터를 계속해서 캐시에서 제공합니다. 즉, 사용자에게는 데이터가 갑자기 사라지거나 오류가 노출되지 않고 안정적으로 서비스가 유지됩니다. 그리고 다음 요청 시점에 다시 재검증을 시도하니, 일시적인 문제라도 금방 해결됩니다.\n\n이 부분이 꽤나 유용한데, 서버 오류로 인한 서비스 중단 없이도 캐시가 안정적으로 유지되고 복구되기 때문이죠.\n\n### 캐시 위치 커스터마이징하기\n\nNext.js 내장 캐시는 기본적으로 프로젝트 내 `.next/cache` 폴더에 저장됩니다. 하지만 상황에 따라 캐시 위치를 바꾸고 싶을 때가 있죠. 예를 들어, CI/CD 환경에서 캐시를 공유하거나 특정 디스크 경로에 캐시를 두고 싶을 때가 그렇답니다.\n\nNext.js에서는 `next.config.js` 파일에서 `experimental` 설정 아래 `serverActions`와 같은 옵션을 다루듯, 캐시 관련 설정도 향후 업데이트를 기대할 수 있는데, 현재 공식 문서에서는 구체적인 캐시 위치 변경 방법은 제한적입니다. 그래도 곧 더 다양한 설정 옵션들이 추가될 예정이라서, 공식 문서를 꾸준히 확인하는 걸 추천드려요.\n\n---\n\n마지막으로 Next.js의 캐시 전략은 점점 발전 중이라서, 개발자가 직접 캐시 태그를 관리하며 성능을 최적화할 수 있는 부분이 늘고 있어요. 보다 유연하고 빠른 데이터 페칭을 위한 중요한 기능이니, 꼭 한번 직접 써보시면서 익혀두시면 좋을 것 같아요! 혹시 서비스 로딩 속도가 느리거나 데이터 최신화에 문제가 있을 때, 캐시 무효화 전략부터 점검해보세요 :)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서 페이지를 캐싱하고 재검증하는 기능인 Incremental Static Regeneration(ISR)은 동일한 캐시를 공유해서 사용해요. \n\n만약 Vercel에 배포한다면, ISR 캐시는 자동으로 안정적인 저장소에 저장되어서 데이터가 안전하게 보존되죠. 그런데 직접 서버를 운영(셀프 호스팅)할 때는 ISR 캐시가 Next.js 서버 내의 파일 시스템(디스크)에 저장돼요. Pages Router와 App Router 둘 다 셀프 호스팅할 때 이 방식이 자동으로 적용됩니다.\n\n또한 필요에 따라 Next.js 캐시 위치를 직접 설정할 수도 있어요. 이렇게 하면 캐시된 페이지와 데이터를 더 영속적인 저장소에 보관할 수 있고, 여러 컨테이너나 인스턴스에서 캐시를 공유하는 것도 가능해집니다. 더 자세한 설정 방법은 공식 문서를 참고해 보세요.\n\n---\n\n### 간단히 말해서!\n- **Vercel 배포:** 캐시 자동 저장(내구성 있는 저장소)\n- **셀프 호스팅:** 캐시가 서버 디스크에 저장\n- **캐시 위치 변경 가능:** 여러 서버 간 캐시 공유 및 데이터 보존 용도\n\n만약 캐시 문제가 발생하거나 페이지가 예상대로 재검증되지 않는다면 캐시 설정을 점검해 보는 게 좋겠죠? 다음번에는 흔한 이슈와 해결법도 함께 소개할게요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 로컬 개발 환경에서 캐시된 데이터 디버깅하기\n\nfetch API를 사용할 때, 어떤 요청이 캐시된 것인지, 혹은 캐시되지 않은 것인지 확인하고 싶다면 추가적인 로깅(logging) 설정을 해보는 게 좋아요. 이렇게 하면 네트워크 요청이 실제로 어떻게 처리되는지 한눈에 파악할 수 있답니다. \n\n예를 들어, 아래처럼 `logging` 옵션을 설정하면 모든 fetch 호출의 전체 URL(fullUrl)을 로그로 남길 수 있어요.\n\n```js\nmodule.exports = {\n  logging: {\n    fetches: {\n      fullUrl: true,\n    },\n  },\n}\n```\n\n이 설정을 통해 \"아, 이 요청은 캐시에서 바로 가져왔구나\", \"이 요청은 서버에 직접 다녀왔구나\" 같은 정보를 쉽게 알 수 있게 됩니다. 특히 복잡한 캐싱 로직을 다룰 때, 문제를 빠르게 찾아내는 데 정말 유용하죠.\n\n또한, 브라우저 개발자 도구(Network 탭)를 열어 보거나, 서버에서 캐시 헤더(Cache-Control, ETag 등)를 확인하는 것도 도움이 됩니다. 이런 방법들을 병행하면 캐시 동작을 더 명확히 이해할 수 있어요.\n\n### 프로덕션 환경에서의 올바른 동작 확인하기\n\n로컬 환경에서 잘 작동한다고 해도, 프로덕션 환경에서는 다른 조건들이 작용할 수 있어요. 그렇기 때문에 실제 운영 서버에서 캐시가 제대로 동작하는지 반드시 확인해야 합니다. 다음과 같은 점들을 체크해 보세요.\n\n- **실제 네트워크 요청 확인**: 운영 중인 서버의 로그 혹은 브라우저 개발자 도구를 통해 매 요청마다 캐시가 제대로 적용되는지 봅니다.\n- **HTTP 캐시 헤더 점검**: 서버가 올바른 캐시 정책을 설정했는지 확인해 보세요. 캐시 만료시간, 재검증(ETag, Last-Modified) 관련 헤더들이 적절히 사용되는지 중요합니다.\n- **캐시 무효화 전략 검토**: 업데이트가 필요한 데이터가 있을 때 캐시가 제대로 초기화(unset)되는지 테스트해 보아야 합니다.\n- **콘텐츠 배포 네트워크(CDN) 설정**: 만약 CDN을 사용한다면 CDN 캐시 정책도 함께 고려해야 하니, CDN 로그나 설정도 꼭 살펴보세요.\n\n이처럼 디버깅할 때 로컬 개발 환경뿐 아니라 프로덕션 환경에서의 케이스까지 살펴보면, 예상치 못한 캐싱 문제를 미리 차단할 수 있어서 안정적인 서비스를 운영할 수 있답니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프로덕션 환경에서 페이지가 제대로 캐시되고 재검증되는지 확인하려면, 로컬에서 직접 테스트해보는 게 좋아요. 방법은 간단해요!\n\n1. 먼저 `next build` 명령어로 프로젝트를 빌드합니다.\n2. 그리고 `next start`로 프로덕션용 Next.js 서버를 실행해보세요.\n\n이렇게 하면 ISR(Incremental Static Regeneration) 동작을 실제 프로덕션 환경처럼 경험할 수 있어요. \n\n그리고 개발하는 동안 캐시 동작을 좀 더 자세히 보고 싶다면, 프로젝트 루트에 있는 `.env` 파일에 아래 환경 변수를 추가해보세요.\n\n```js\nNEXT_PRIVATE_DEBUG_CACHE=1\n```\n\n이걸 넣으면 Next.js 서버 콘솔에서 ISR 캐시 히트(hit)와 미스(miss) 정보를 출력해줍니다. 덕분에 빌드 과정에서 생성된 페이지들과, 사용자 요청에 따라 어떤 경로들이 새롭게 생성되는지 세세하게 확인할 수 있죠.\n\n---\n\n추가로 팁 하나! 서버 로그를 보면서 페이지가 갱신되는 타이밍을 체크하면, 재검증 설정(`revalidate` 옵션)과 실제 동작이 잘 맞는지 쉽게 디버깅할 수 있어요. 혹시 ISR이 잘 작동하지 않는다고 느껴지면, 이 환경 변수 설정과 로그 확인부터 해보시길 추천합니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 주의할 점 (Caveats)\n\n- ISR(Incremental Static Regeneration)은 기본적으로 Node.js 런타임 환경에서만 지원돼요.\n- Static Export 방식으로 프로젝트를 만들 때는 ISR을 사용할 수 없답니다.\n- 정적으로 렌더링된 경로에서 여러 개의 fetch 요청을 하고 각각 다른 revalidate 주기를 설정했다면, 가장 짧은 시간이 ISR에 적용돼요. 하지만 Data Cache에서는 각각 설정한 재검증 주기가 따로 지켜진답니다.\n- 만약 경로 내 fetch 요청 중에 revalidate 시간이 0이거나 명시적으로 no-store가 설정되어 있다면, 그 경로는 동적으로 렌더링돼요.\n- 미들웨어(Middleware)는 on-demand ISR 요청에는 실행되지 않아요. 즉, 경로 재작성(path rewrites)이나 미들웨어 내 로직이 적용되지 않으니, 재검증할 때는 꼭 정확한 경로를 지정해야 해요. 예를 들어, /post-1로 rewrite된 경로가 아니라 /post/1과 같이 실제 경로를 사용해야 합니다.\n\n---\n\n## 버전 히스토리 (Version history)\n\n| 버전       | 변경 사항                                      |\n|------------|--------------------------------------------|\n| v14.1.0    | 커스텀 `cacheHandler`가 안정화되었어요.          |\n| v13.0.0    | App Router가 도입되었답니다.                      |\n| v12.2.0    | Pages Router에서 On-Demand ISR이 안정화됐어요.    |\n| v12.0.0    | Pages Router에 [Bot-aware ISR fallback](https://nextjs.org/blog/next-12#bot-aware-isr-fallback)이 추가되었죠. |\n| v9.5.0     | Pages Router에 [안정화된 ISR](https://nextjs.org/blog/next-9-5)이 도입되었어요. |\n\n---\n\n이번 내용에서는 Next.js에서 ISR을 사용할 때 주의해야 할 점들과 버전별 주요 업데이트 소식을 함께 정리했는데요, 보통 ISR을 잘 활용하면 성능과 SEO 모두 잡을 수 있어 굉장히 유용해요. 다만 위에서 언급한 몇 가지 제한사항들을 꼭 숙지해서 개발 중 예상치 못한 문제가 생기지 않도록 하는 게 중요해요.\n\n또한, 버전업이 자주 되기 때문에 새로운 기능이나 안정화된 기능들은 공식 블로그나 문서를 꾸준히 체크하는 걸 추천드려요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":19},{"title":"Nextjs 15로 안전하게 업그레이드하는 방법 정리","description":"","date":"2025-04-22 01:45","slug":"2025-04-22-Howtoupgradetoversion15","content":"\n\n# 버전 15로 업그레이드하는 방법\n\n## 14 버전에서 15 버전으로 업그레이드하기\n\nNext.js 15 버전으로 업데이트하려면, 업그레이드용 codemod(codemod는 코드 자동 변경 도구)를 사용하면 편리해요. 터미널에서 아래 명령어를 입력하면 자동으로 코드에 필요한 변경사항을 반영해줍니다.\n\n```bash\nnpx @next/codemod@canary upgrade latest\n```\n\n이 명령어는 Next.js 최신 버전(15)으로 맞춰서 코드와 설정을 업데이트해주기 때문에, 직접 수동으로 하나하나 고치는 번거로움을 많이 줄여준답니다.\n\n---\n\n### 추가 팁\n\n- 항상 업그레이드 전에 현재 프로젝트를 백업하거나 Git에 커밋해 두세요. 혹시 모를 문제 발생 시 빠르게 되돌아갈 수 있어요.\n- 업그레이드 후에는 실제 프로젝트가 잘 돌아가는지 꼭 테스트해보세요. 버전 변경에 따라 작동 방식이 조금씩 바뀔 수 있으니까요.\n- Next.js의 공식 릴리즈 노트를 참고하면 새 버전에서 바뀐 점과 주의할 사항들을 한눈에 파악할 수 있어서 유용해요.\n\n업그레이드가 생각보다 간단하지만, 미리 대비만 잘 하면 훨씬 수월하게 최신 기능도 누리고 안정성도 챙길 수 있답니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n수동으로 설치하는 걸 선호한다면, 꼭 최신 버전의 Next와 React를 설치하는지 확인하세요:\n\n```bash\nnpm i next@latest react@latest react-dom@latest eslint-config-next@latest\n```\n\n> 참고할 점:\n설치 중에 peer dependencies 경고가 뜬다면, react와 react-dom을 권장 버전으로 업데이트해야 할 수도 있어요. 아니면 `--force` 혹은 `--legacy-peer-deps` 옵션을 사용해 경고를 무시할 수도 있습니다. 이 문제는 Next.js 15와 React 19가 안정화되면 자연스럽게 해결될 예정이에요.\n\n## React 19\n\nReact 19 버전에서는 성능 향상과 더불어 새롭게 도입된 기능들이 많이 있습니다. 예를 들어, 더 나은 서버 사이드 렌더링(SSR) 지원과 경량화된 빌드, 그리고 React 에코시스템 전반에 걸친 호환성 강화 등이 포함되어 있죠.\n\n참고로, React와 Next.js는 항상 같이 업데이트하는 게 가장 좋아요. 왜냐하면 Next.js가 React의 기능을 기반으로 동작하기 때문에 버전 불일치 시 예상치 못한 버그가 발생할 수도 있거든요.\n\n앞으로 Next.js 15와 React 19가 공식 안정 버전이 나오면, 더 쉽게 최신 기능을 누릴 수 있으니 그때까지는 위 방법대로 최신 버전으로 업데이트 해두는 걸 추천합니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안녕하세요 여러분! 오늘은 React 19 버전에서 바뀐 점들을 간단하게 정리해보려고 해요. 특히 기존에 사용하던 훅들이 어떻게 바뀌었는지, 그리고 비동기 API 관련 중요한 변경사항들을 다뤄볼게요.\n\n---\n\n### 주요 변경점 요약\n\n| 내용 | 설명 |\n|---|---|\n| React 최소 버전 | 이제 React와 React-DOM 최소 지원 버전이 19가 되었습니다. 기존 버전 사용자분들은 이번 기회에 업그레이드 해주세요! |\n| useFormState → useActionState | `useFormState` 훅은 React 19에서도 사용할 수 있지만 곧 사라질 예정이에요. 대신 `useActionState`를 쓰는 걸 권장합니다. `useActionState`는 대기(pending) 상태를 직접 읽을 수도 있고, 더 많은 프로퍼티를 제공합니다. 좀 더 자세한 내용은 공식 문서를 참고하세요. |\n| useFormStatus 업데이트 | `useFormStatus` 훅도 업데이트되면서 `data`, `method`, `action` 같은 추가 키가 생겼어요. React 19 버전이 아니면 `pending` 키만 사용할 수 있다는 점 꼭 기억하세요. |\n| TypeScript 사용자 주의 | TypeScript를 쓰는 분들은 `@types/react`와 `@types/react-dom` 역시 최신 버전으로 함께 업그레이드 해주세요. 타입 안정성을 위해 꼭 필요합니다! |\n\n---\n\n### 비동기 요청 API 관련 주요 변경사항 (Breaking Change)\n\n예전에는 런타임 정보를 기반으로 동작하는 동기 방식의 Dynamic API들이 있었는데요, 이제 이걸 전부 비동기 방식으로 변경했어요. 이 변화로 인해 비동기 요청을 처리하는 로직을 조금 다르게 써야 할 수도 있답니다.\n\n---\n\n### 추가 팁!\n\n- React 19로 넘어가면서 form 관련 훅들이 많이 바뀌었는데, 특히 서버 액션과 관련된 `useActionState` 같은 훅을 사용하는 게 앞으로 리액트 생태계에서 더 권장됩니다.\n- 새로운 API들이 추가되면서 동작 방식이 세밀해졌으니, 직접 애플리케이션에 적용해 보면서 어떤 점이 달라졌는지 꼭 확인해보세요.\n- 공식 React 19 업그레이드 가이드도 꼭 한 번 읽어보시길 추천합니다. 그 안에 더 자세한 마이그레이션 팁과 변경점들이 잘 정리되어 있으니까요!\n\n---\n\n더 궁금한 점이나 실사용하면서 겪는 문제 있으면 댓글로 알려주세요. 다음에도 유용한 개발 소식으로 찾아올게요! 😊\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- cookies  \n- headers  \n- draftMode  \n- params in layout.js, page.js, route.js, default.js, opengraph-image, twitter-image, icon, and apple-icon.  \n- searchParams in page.js  \n\n마이그레이션을 조금이라도 쉽게 하기 위해서, 자동으로 변환해주는 codemod 도구가 준비되어 있어요. 그리고 새로운 API들은 잠시 동안 동기(synchronous) 방식으로도 접근이 가능해서 천천히 전환할 수 있답니다.\n\n### cookies\n\n#### 권장하는 비동기 사용법 (Async Usage)\n\nNext.js 같은 최신 프레임워크에서는 cookie를 다룰 때도 비동기 방식을 추천하고 있어요. 예를 들어, `cookies()` 함수를 호출할 때 바로 데이터를 받을 수 있도록 `await`를 사용하는 겁니다. 이렇게 하면 네트워크 요청이나 복잡한 작업에 더 유연하게 대응할 수 있죠.\n\n```js\nimport { cookies } from 'next/headers';\n\nexport async function GET() {\n  const cookieStore = cookies();\n  const token = cookieStore.get('token')?.value;\n\n  // 비동기 작업 가능!\n  // 예: 토큰 검증, 다른 API 호출 등\n  if (!token) {\n    return new Response('Unauthorized', { status: 401 });\n  }\n\n  return new Response('Hello, authorized user!');\n}\n```\n\n이렇게 async/await 패턴으로 작성하면, 요청 중간에 필요한 정보를 쉽게 읽고 처리할 수 있어요.  \n\n---\n\n참고로, 만약 기존처럼 동기적으로 쓰고 싶다면 임시로 `cookies().get(...)` 같은 API를 이용할 수 있지만, 장기적으로는 꼭 비동기로 전환하는 게 추후 유지보수나 퍼포먼스 측면에서 좋아요.  \n\n필요하다면, 내가 직접 작성해 본 codemod 스크립트도 공유해줄 수 있으니, 댓글로 알려주세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js 13.4부터 `cookies()` 함수가 비동기 함수로 바뀌었어요. 그래서 예전처럼 동기적으로 `const cookieStore = cookies()` 이렇게 쓰면 안 되고, `await`를 붙여서 `const cookieStore = await cookies()` 이렇게 사용해야 합니다.\n\n```js\nimport { cookies } from 'next/headers'\n\n// 이전 방식\nconst cookieStore = cookies()\nconst token = cookieStore.get('token')\n\n// 변경된 방식\nconst cookieStore = await cookies()\nconst token = cookieStore.get('token')\n```\n\n하지만 아직 완전히 비동기 방식에 적응하지 못한 상황에서는, 아래처럼 타입 캐스팅을 해서 임시로 동기적으로 사용하는 방법도 있어요. 다만 이 방법은 개발 환경에서 경고 메시지가 뜰 수 있으니 참고하세요.\n\n```js\nimport { cookies, type UnsafeUnwrappedCookies } from 'next/headers'\n\n// 임시 동기 처리 방법\nconst cookieStore = cookies() as unknown as UnsafeUnwrappedCookies\nconst token = cookieStore.get('token')\n```\n\n---\n\n### headers 도 비슷해요!\n\n`headers()`도 내부적으로 비동기 방식으로 변경될 수 있으니, 비슷하게 `await`를 붙여주는 게 좋습니다. \n\n---\n\n### 참고로!\n\n- `cookies()`를 쓸 때는 꼭 서버 컴포넌트(server component)나 API Route 등 서버 환경에서만 사용해야 해요. 클라이언트 컴포넌트에서는 동작하지 않으니 주의하세요.\n- Next.js가 계속 발전하면서 내부 API도 조금씩 바뀌니까, 항상 공식 문서를 확인하고 업데이트 내역을 살펴보는 습관을 들여주세요.\n\n이렇게 하면 쿠키를 읽을 때 생기는 비동기 문제를 깔끔하게 해결할 수 있답니다! :)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 추천하는 비동기 사용법 (Async Usage)\n\n```js\nimport { headers } from 'next/headers'\n\n// 예전 방식\nconst headersList = headers()\nconst userAgent = headersList.get('user-agent')\n\n// 요즘 추천 방식 (await 사용)\nconst headersList = await headers()\nconst userAgent = headersList.get('user-agent')\n```\n\nNext.js에서 `headers()`를 사용할 때 이제는 비동기 함수처럼 `await`를 붙여서 호출하는 게 권장됩니다. 이유는 `headers()`가 내부적으로 비동기 작업을 할 수 있기 때문이에요. 이렇게 하면 코드가 더 안정적으로 동작하죠.\n\n---\n\n### 잠깐! 동기 방식 사용법 (Temporary Synchronous Usage)\n\n```js\nimport { headers, type UnsafeUnwrappedHeaders } from 'next/headers'\n\n// 예전 방식\nconst headersList = headers()\nconst userAgent = headersList.get('user-agent')\n\n// 동기 방식 그대로 쓰고 싶다면 (개발 중 경고 떠요)\nconst headersList = headers() as unknown as UnsafeUnwrappedHeaders\nconst userAgent = headersList.get('user-agent')\n```\n\n만약 코드를 당장 고치기 어려운 상황이라면 이렇게 타입을 강제로 변환해서 동기 방식으로 쓸 수는 있어요. 다만 개발 모드에서는 경고가 뜨니 나중에 꼭 비동기 방식으로 바꾸시는 걸 권장합니다.\n\n---\n\n### 추가 팁!\n\n- `headers()`를 비동기 호출로 바꾸려면, 호출하는 함수도 `async` 함수여야 합니다. 예를 들어 서버 컴포넌트나 API 라우트 함수에서 많이 쓰게 돼요.\n- 클라이언트 컴포넌트에서는 `next/headers`를 바로 사용할 수 없고, 서버에서 전달해줘야 한다는 점 꼭 기억하세요.\n- `headers()` 대신 `request.headers`를 직접 다룰 수도 있지만, Next.js에서는 제공하는 `headers()`가 버전업에 맞춰 최적화되어 있답니다.\n\n오늘 내용 참고해서 Next.js 최신 버전에 맞는 헤더 처리 스타일로 코딩해보세요! 개발할 때 헤더 정보를 안전하게 다루는 건 보안과도 직결되는 중요한 부분입니다. 😊\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### draftMode\n\n#### 비동기 방식 사용 추천\n\n```js\nimport { draftMode } from 'next/headers'\n\n// 예전 방식 (동기 방식)\nconst { isEnabled } = draftMode()\n\n// 최신 권장 방식 (비동기 방식)\nconst { isEnabled } = await draftMode()\n```\n\nNext.js에서 `draftMode`를 사용할 때, 요즘은 `await`를 붙여서 비동기적으로 사용하는 걸 추천해요. 왜냐하면 최신 Next.js 환경에서는 내부적으로 비동기 처리를 더 잘 지원하기 때문이죠. 덕분에 코드가 안정적이고 예측 가능하게 동작하게 됩니다.\n\n#### 임시로 동기 방식 사용하기\n\n만약 당장 async/await를 적용하기 어렵거나, 함수가 동기 컨텍스트 안에 있어서 비동기 코드를 쓸 수 없는 상황이라면 임시로 동기적으로 사용할 수 있지만, 가능한 빨리 비동기 방식으로 전환하는 게 좋아요. 동기적으로 쓸 경우 예상치 못한 문제가 생길 수 있거든요.\n\n---\n\n추가 팁: `draftMode`는 Next.js의 미리보기 모드(preview mode)와 비슷한 기능으로, 콘텐츠를 변경하거나 임시 상태를 확인하는 데 유용해요. 미리보기 모드를 쓴 적이 있다면 이해하기 쉬울 거예요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이번에 Next.js를 사용하면서 바뀐 부분들을 직접 공부해 보고 정리해봤어요. 혹시 Next.js에서 draftMode나 params 관련해서 헷갈렸던 부분이 있다면, 이 글이 도움이 될 거예요.\n\n---\n\n## draftMode 사용법 변경\n\n예전에는 이렇게 했죠?\n\n```ts\nconst { isEnabled } = draftMode()\n```\n\n그런데 이제는 이렇게 바뀌었어요.\n\n```ts\nconst { isEnabled } = draftMode() as unknown as UnsafeUnwrappedDraftMode\n```\n\n왜 이런 변경이 있을까요? 사실 개발환경(dev)에선 경고를 띄우기 위한 의도된 타입 캐스팅이에요. 타입스크립트가 더 엄격해지면서 아래와 같은 경고를 피하려고 이중 캐스팅(as unknown as ...)을 해주는 꼼수가 필요해졌죠.\n\n> 간단히 말하면, 공식 API가 안정화되기 전이라 타입 안전성 경고를 잡기 위해서 이렇게 사용한다는 점 참고하세요!\n\n---\n\n## params & searchParams - 비동기 Layout에서 바뀐 점\n\n예전에는 generateMetadata나 Layout에서 params가 바로 객체 형태였어요.\n\n| 구분         | 예전 코드                                | 변경된 코드                                |\n|--------------|----------------------------------------|------------------------------------------|\n| params 타입  | `{ slug: string }`                      | `Promise<{ slug: string }>`              |\n| 호출 시점    | `const { slug } = params`               | `const { slug } = await params`          |\n| 함수         | `function generateMetadata()`           | `async function generateMetadata()`      |\n| Layout 함수  | `function Layout()`                      | `async function Layout()`                 |\n\n직접 비교해보면,\n\n### 예전 코드\n\n```ts\ntype Params = { slug: string }\n\nexport function generateMetadata({ params }: { params: Params }) {\n  const { slug } = params\n}\n\nexport default function Layout({\n  children,\n  params,\n}: {\n  children: React.ReactNode\n  params: Params\n}) {\n  const { slug } = params\n  return <>{children}</>\n}\n```\n\n### 변경된 코드\n\n```ts\ntype Params = Promise<{ slug: string }>\n\nexport async function generateMetadata({ params }: { params: Params }) {\n  const { slug } = await params\n}\n\nexport default async function Layout({\n  children,\n  params,\n}: {\n  children: React.ReactNode\n  params: Params\n}) {\n  const { slug } = await params\n  return <>{children}</>\n}\n```\n\n---\n\n### 왜 params가 Promise로 바뀌었을까?\n\nNext.js 13+의 동적 라우팅에서는 더 좋은 성능과 유연성을 위해, `params`가 비동기적으로 처리되어야 할 경우가 많아요. 예를 들어 API 호출이나 데이터베이스 조회로 라우팅 정보를 가져올 때, `params`는 즉시 사용할 수 있는 값이 아니라 비동기 Promise가 될 수 있어요.\n\n그래서 이를 감안해서 `await`로 `params`를 받아온다는 점! 이 부분을 잊지 마세요.\n\n---\n\n## 정리하자면\n\n| 변경 포인트         | 예전 방식                       | 변경된 방식                             |\n|---------------------|--------------------------------|---------------------------------------|\n| `draftMode` 타입    | `const { isEnabled } = draftMode()` | `const { isEnabled } = draftMode() as unknown as UnsafeUnwrappedDraftMode` |\n| `params` 타입       | `{ slug: string }`              | `Promise<{ slug: string }>`            |\n| 함수 선언          | 동기 함수                      | `async` 함수로 변경                    |\n| params 사용법       | 바로 사용 (`const { slug } = params`) | `await` 처리해서 사용 (`const { slug } = await params`) |\n\n---\n\n## 추가 팁 - 실무에서 주의할 점\n\n- `await params`로 받는 부분에서 실수로 `await`를 빼먹지 않도록 조심하세요. 그러면 타입 오류가 생기거나 런타임 에러가 발생할 수 있어요.\n- `draftMode()`는 아직 공식 문서에도 \"experimental\" 표시가 있을 수 있어요. 실제 프로덕션에서 쓸 땐 신중 체크하시고, 시간이 지나면 정식 API가 나오면서 타입 경고도 사라질 가능성이 높아요.\n- Next.js의 새로운 앱 디렉토리 구조 + 점점 강화되는 타입스크립트 환경에 대응하려면 이런 변경 사항을 꼭 미리 알아두는 게 좋아요.\n\n---\n\n궁금한 점 있으면 댓글 달아주세요! Next.js 최신 기능, 더 재밌고 편리하게 같이 공부해봐요~ 😄✨\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이번에 React 컴포넌트에서 동기와 비동기 데이터를 다루는 방식을 조금 더 최신 방법으로 바꾸는 예제를 소개할게요. 쉬운 예시와 함께 변화한 코드를 설명하니까, 천천히 읽으면서 적용해보세요!\n\n---\n\n### 1. Synchronous Layout (동기 레이아웃)\n\n기존엔 `params`가 그냥 객체였는데, 이걸 `Promise`를 감싸서 비동기 데이터처럼 쓸 수 있도록 바꿨어요.\n\n```tsx\n// Before (예전 방식)\ntype Params = { slug: string }\n\nexport default function Layout({\n  children,\n  params,\n}: {\n  children: React.ReactNode\n  params: Params\n}) {\n  const { slug } = params\n}\n```\n\n```tsx\n// After (최신 방식)\nimport { use } from 'react'\n\ntype Params = Promise<{ slug: string }>\n\nexport default function Layout(props: {\n  children: React.ReactNode\n  params: Params\n}) {\n  const params = use(props.params) // 여기서 비동기 데이터를 바로 처리해버림\n  const slug = params.slug\n}\n```\n\n> 여기서 핵심은 바로 React의 `use` 훅을 활용해서 비동기 Promise 상태를 동기처럼 쓴다는 점이에요. `use`는 React 18에서 실험적으로 도입된 기능으로, Next.js 13같은 최신 프레임워크에서 지원하죠. 이렇게 하면 컴포넌트 내부가 훨씬 깔끔해지고, 비동기 데이터 처리가 자연스러워져요.\n\n---\n\n### 2. Asynchronous Page (비동기 페이지)\n\n페이지 컴포넌트와 `generateMetadata`에서 비동기 params, searchParams를 다루는 예시입니다.\n\n```tsx\n// Before (예전 방식)\ntype Params = { slug: string }\ntype SearchParams = { [key: string]: string | string[] | undefined }\n\nexport function generateMetadata({\n  params,\n  searchParams,\n}: {\n  params: Params\n  searchParams: SearchParams\n}) {\n  const { slug } = params\n  const { query } = searchParams\n}\n\nexport default async function Page({\n  params,\n  searchParams,\n}: {\n  params: Params\n  searchParams: SearchParams\n}) {\n  const { slug } = params\n  const { query } = searchParams\n}\n```\n\n```tsx\n// After (최신 방식)\ntype Params = Promise<{ slug: string }>\ntype SearchParams = Promise<{ [key: string]: string | string[] | undefined }>\n\nexport async function generateMetadata(props: {\n  params: Params\n  searchParams: SearchParams\n}) {\n  const params = await props.params\n  const searchParams = await props.searchParams\n  const slug = params.slug\n  const query = searchParams.query\n}\n\nexport default async function Page(props: {\n  params: Params\n  searchParams: SearchParams\n}) {\n  const params = await props.params\n  const searchParams = await props.searchParams\n  const slug = params.slug\n  const query = searchParams.query\n}\n```\n\n> 여기서는 `params`와 `searchParams`가 Promise로 감싸져서 넘어옵니다. 그래서 컴포넌트나 함수 내에서 `await`으로 값을 받아와 처리하는 거죠. 이렇게 하면 URL 파라미터나 쿼리 스트링이 비동기적으로 처리될 때도 문제없이 데이터를 다룰 수 있어요.\n\n---\n\n### 마무리 - 왜 이렇게 바꾸는 걸까?\n\n- **React 18, Next.js 13** 등 최신 도구들이 비동기를 더 자연스럽게 다루도록 발전하고 있기 때문이에요.\n- `use` 훅으로 비동기 데이터를 처리하면 렌더링 로직이 엄청 깔끔해지고 버그도 줄어듭니다.\n- Promise를 직접 받고 `await` 하면서 컴포넌트가 더 유연하게 변해요.\n\n---\n\n### 간단 요약\n\n| 이전 방식                       | 최신 방식                          |\n|------------------------------|---------------------------------|\n| `params`는 동기 객체              | `params`는 Promise로 감싸진 비동기 객체  |\n| 데이터 바로 사용                  | `use` 훅 (Layout) / `await` (Page) 이용 |\n| 함수 파라미터에 바로 받음           | Promise 감싸진 객체를 `await` 또는 `use`로 처리 |\n\n---\n\n이제 이런 패턴을 알았으니, Next.js 프로젝트나 React 앱에서 URL 파라미터 등을 더 깔끔하고 안전하게 처리해보세요! 필요하면 `use` 훅이 지원되는지, 환경이 맞는지 먼저 확인하는 것도 잊지 마시고요. 궁금한 점 있으면 또 알려드릴게요~!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 동기식 페이지 (Synchronous Page) 코드 전환하기\n\n안녕하세요! 오늘은 Next.js에서 동기식 페이지를 만드는 방법을 조금 더 최신 React 문법에 맞게 바꾸는 방법을 이야기해볼게요. 코드를 조금만 바꾸면 더 깔끔해지고, Promise를 직접 받아서 사용할 수 있게 되는 점이 포인트입니다.\n\n---\n\n#### 기존 코드 Before → 최신 코드 After\n\n##### Before (기존 방식)\n\n```tsx\n// 기존에는 params와 searchParams가 객체로 바로 들어왔어요\ntype Params = { slug: string }\ntype SearchParams = { [key: string]: string | string[] | undefined }\n\nexport default function Page({\n  params,\n  searchParams,\n}: {\n  params: Params\n  searchParams: SearchParams\n}) {\n  const { slug } = params\n  const { query } = searchParams\n}\n```\n\n##### After (업데이트된 방식)\n\n```tsx\nimport { use } from 'react'\n\n// 이제 params와 searchParams가 Promise로 들어옵니다\ntype Params = Promise<{ slug: string }>\ntype SearchParams = Promise<{ [key: string]: string | string[] | undefined }>\n\nexport default function Page(props: {\n  params: Params\n  searchParams: SearchParams\n}) {\n  // react의 use 훅을 써서 Promise를 바로 resolve합니다\n  const params = use(props.params)\n  const searchParams = use(props.searchParams)\n  const slug = params.slug\n  const query = searchParams.query\n}\n```\n\n---\n\n#### 심플 버전도 이렇게 바꿔요!\n\n```tsx\n// Before\nexport default function Page({ params, searchParams }) {\n  const { slug } = params\n  const { query } = searchParams\n}\n\n// After\nimport { use } from \"react\"\n\nexport default function Page(props) {\n  const params = use(props.params)\n  const searchParams = use(props.searchParams)\n  const slug = params.slug\n  const query = searchParams.query\n}\n```\n\n---\n\n### 여기서 잠깐!\n\n- `use` 훅은 React 18부터 도입된 실험적 API 중 하나로, Promise를 받아 바로 결과를 얻을 수 있어요.\n- Next.js의 새로운 데이터 페칭 방식과 잘 어울리는데, async/await를 쓰지 않고도 동기식처럼 코드를 작성할 수 있게 해 줍니다.\n- 물론 아직 안정화 단계이니 실제 프로젝트에 적용할 때는 주의가 필요해요. (React 릴리즈 노트를 꼭 확인해보세요!)\n\n---\n\n#### 마무리\n\n이처럼 Next.js에서 page 컴포넌트에 들어오는 params와 searchParams 타입이 Promise로 변경되었고, React의 `use` 훅을 사용해 데이터를 간편하게 사용할 수 있게 되었습니다. 개발자 경험이 점점 좋아지는 것 같아 기대됩니다!\n\n다음 글에서는 Route Handlers 관련 내용도 다뤄볼 예정이니까 기대해 주세요~\n\n---\n\n궁금한 점 있으면 언제든 댓글 주세요! 😊\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이번에 Next.js에서 `GET` 함수의 파라미터 `params` 타입과 처리 방식에 변화가 생겼어요. 기존에는 `params`가 동기적으로 바로 사용할 수 있는 객체였는데, 이제는 `params`가 `Promise`로 감싸져 비동기 처리를 해야 합니다. 간단히 말하면, `params`를 바로 쓰면 안 되고, `await`으로 비동기 값을 받아와야 한다는 거죠.\n\n아래 예시 코드를 보며 차이점을 살펴볼게요.\n\n```ts\n// Before\ntype Params = { slug: string }\n \nexport async function GET(request: Request, segmentData: { params: Params }) {\n  const params = segmentData.params        // 동기 처리\n  const slug = params.slug\n}\n \n// After\ntype Params = Promise<{ slug: string }>\n \nexport async function GET(request: Request, segmentData: { params: Params }) {\n  const params = await segmentData.params   // 비동기 처리 필수\n  const slug = params.slug\n}\n```\n\n이처럼 `params` 타입이 `Promise`로 변경되면서, `await` 없이는 `slug`를 바로 꺼낼 수 없어요. 이것은 Next.js가 내부 라우팅 파라미터를 더 유연하게 처리하기 위한 변경 사항으로 보입니다.\n\n또한 타입이 명시되어 있지 않은 코드에서도 마찬가지에요.\n\n```ts\n// Before\nexport async function GET(request, segmentData) {\n  const params = segmentData.params    // 동기 처리\n  const slug = params.slug\n}\n \n// After\nexport async function GET(request, segmentData) {\n  const params = await segmentData.params   // 비동기 처리 필수\n  const slug = params.slug\n}\n```\n\n이 부분은 간단하지만, 만약 기존 코드를 그대로 쓴다면 `slug`를 읽으려 할 때 `params`가 `Promise`니까 `undefined`가 나오거나 에러가 날 수 있어요. 따라서 반드시 `await` 키워드를 붙여주셔야 합니다.\n\n---\n\n## 런타임 설정 관련 깨알 변화! - Breaking change\n\n`runtime` 설정을 하실 때, 이전에는 `experimental-edge`와 `edge` 두 가지 옵션을 모두 쓸 수 있었어요. 그런데 이 둘은 사실 같은 걸 의미해요. 그래서 앞으로는 `experimental-edge`를 사용하면 에러가 납니다! 깔끔하게 `edge`로만 쓸 수 있도록 정리한 거죠.\n\n만약 예전에 `experimental-edge`로 설정해둔 게 있다면, 아래처럼 바꾸시면 됩니다.\n\n| Before           | After   |\n|------------------|---------|\n| `experimental-edge` | `edge`   |\n\n귀찮으시다면 자동으로 바꿔주는 코드모드(codemod)도 제공하고 있으니 참고하세요.\n\n---\n\n이 변경 사항들은 Next.js가 더 견고하고 명확한 API를 제공하려는 노력의 일환입니다. 여러분의 API 핸들러 코드를 수정할 때는 이번 `params` 비동기 처리 부분과 `runtime` 설정을 꼭 점검해 주세요. 특히 `await` 처리 누락은 의외로 찾기 힘든 버그가 될 수 있으니 조심하시고요!\n\n추가로, `params`가 이제 `Promise`라는 점은 Next.js가 내부에서 라우트 파람 해석을 비동기로 처리하거나, 더 복잡한 데이터 준비과정이 추가됐기 때문인데요. 앞으로 이런 패턴이 더 확산될 가능성이 높으니, 비동기 처리를 기본으로 생각하는 습관을 들이면 좋겠어요.\n\n필요하다면 `GET` 외에 다른 HTTP 메서드 핸들러(`POST`, `PUT` 등)도 동일하게 바뀌었을 가능성이 있기에 한번 점검해 보시길 권합니다.\n\n오늘 알려드린 내용, 작게는 한 줄 바꾸는 거지만, 다음 프로젝트에서 여러분 코드를 한층 안정적으로 만들어 줄 거예요! 잘 적용해보시길 바랍니다~\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## fetch 요청 캐싱 방식이 바뀌었어요!\n\n이번에 fetch 요청이 기본적으로 더 이상 자동으로 캐싱되지 않는다는 점, 알고 계셨나요? 이전에는 그냥 fetch 호출하면 브라우저가 알아서 캐싱해줬는데, 이제는 기본값이 캐싱 안 함으로 바뀌었답니다.\n\n그래서 만약 특정 fetch 요청을 꼭 캐싱하고 싶다면, fetch 함수에 옵션으로 `cache: 'force-cache'`를 명시해줘야 해요. 예를 들어 아래처럼요:\n\n```js\nexport default async function RootLayout() {\n  // 기본 fetch는 캐시 안 함\n  const a = await fetch('https://...')\n\n  // force-cache 옵션을 주면 캐시 사용!\n  const b = await fetch('https://...', { cache: 'force-cache' })\n  \n  // ...\n}\n```\n\n### 좀 더 알아두면 좋은 점\n- `cache` 옵션은 브라우저의 기본 캐시 정책보다 fetch 요청마다 세밀하게 제어할 수 있게 해줍니다.\n- `force-cache` 외에도 다양한 옵션이 있는데, 예를 들어 `no-cache`는 항상 네트워크에서 새로운 데이터를 가져오고 캐시는 무시하는 기능이에요.\n- 캐시를 적절히 활용하면 네트워크 비용과 로딩 속도를 크게 줄일 수 있으니까, 상황에 맞게 잘 조절해보세요!\n\n요즘은 SSR(서버 사이드 렌더링)이나 SSG(정적 사이트 생성)를 자주 사용하는데, fetch 캐싱 정책이 이런 환경과도 잘 맞게 바뀌었다고 보시면 됩니다. 꼭 최신 정책에 맞게 코드를 작성해보세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nfetch 요청을 페이지나 레이아웃 단위에서 한 번에 캐싱 처리하고 싶다면, `export const fetchCache = 'default-cache'` 설정을 사용하면 됩니다. 이 옵션을 추가하면, 해당 레이아웃이나 페이지 내의 모든 fetch 요청은 별도로 캐시 옵션을 지정하지 않는 이상 기본적으로 캐싱됩니다.\n\n```js\n// 이게 루트 레이아웃이라면, 앱 내 fetch 요청 중\n// 따로 캐시 옵션을 안 줬으면 전부 캐싱됩니다.\nexport const fetchCache = 'default-cache'\n\nexport default async function RootLayout() {\n  const a = await fetch('https://...') // 캐시됨\n  const b = await fetch('https://...', { cache: 'no-store' }) // 캐시 안됨\n\n  // ...\n}\n```\n\n여기서 중요한 점은, 개별 fetch 요청 쪽에서 `cache` 옵션을 직접 지정하면 그 설정이 우선 적용된다는 거예요. 따라서 전체적인 기본 캐싱 전략은 위 설정으로 하고, 특정 요청만 예외를 두고 싶은 경우 각 fetch에 `cache: 'no-store'` 같은 옵션을 직접 지정할 수 있죠.\n\n---\n\n### Route Handlers (라우트 핸들러)에서의 캐시 전략\n\n다음으로, Route Handlers에서 GET 메서드는 기본적으로는 캐싱되지 않아요. 그렇기 때문에 GET 요청을 캐싱하고 싶을 때는 라우트 핸들러 파일에 `export const dynamic = 'force-static'` 같은 설정을 추가해줘야 합니다.\n\n즉, `dynamic` 설정을 통해 해당 라우트의 리소스가 정적(static)으로 처리되어 캐시될 수 있도록 강제하는 거예요.\n\n---\n\n이 내용들을 잘 활용하면, 앱 내 네트워크 요청들을 효과적으로 관리할 수 있습니다. 특히 데이터가 자주 변경되지 않는 경우 캐시를 적극 활용하는 게 로딩 속도를 확실히 높이고 사용자 경험도 개선하니까요!\n\n추가로, Next.js에서 fetch의 `cache` 옵션으로는 'no-store' 외에도 'default', 'reload', 'force-cache' 등이 있는데, 각 옵션의 차이를 익혀두면 상황에 맞는 캐싱 정책을 세우기 좋습니다. 예를 들어:\n\n| 옵션        | 설명                                         |\n|-------------|---------------------------------------------|\n| default     | 기본값, 브라우저/런타임의 기본 캐싱 정책 사용     |\n| no-store    | 캐시하지 않고 항상 네트워크에서 새로 가져오기     |\n| reload      | 캐시 무시하고 항상 네트워크 요청하기             |\n| force-cache | 캐시된 데이터가 있으면 무조건 가져오기             |\n\n이런 차이점도 참고하세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nexport const dynamic = 'force-static';\n\nexport async function GET() {}\n```\n\n## 클라이언트 사이드 라우터 캐시\n\nNext.js 같은 프레임워크에서 `Link`나 `useRouter`를 통해 페이지를 이동할 때, 클라이언트 사이드 라우터 캐시에서 기존 페이지 세그먼트를 재사용하지 않아요. 대신 브라우저의 뒤로 가기, 앞으로 가기 버튼을 누를 때, 그리고 공통 레이아웃(shared layouts)을 사용할 때는 세그먼트를 재사용합니다.\n\n만약 페이지 세그먼트의 캐싱을 활성화하고 싶다면 `staleTimes` 설정 옵션을 활용할 수 있는데요, 이 옵션을 통해 특정 시간 동안 페이지 데이터를 캐시에 저장해 두고 재사용할 수 있어요.\n\n### 좀 더 쉽게 설명하자면!\n\n- **기본 동작:** `Link`나 `useRouter`를 이용한 페이지 이동 시, 매번 새로 데이터를 가져오고 새 페이지를 렌더링합니다.\n- **하지만:** 뒤로 가기 / 앞으로 가기 를 할 땐 캐시된 데이터를 씁니다.\n- **해결 방법:** `staleTimes`를 설정해 캐시된 데이터를 일정 시간 동안 유지할 수 있게 해요.\n\n이렇게 하면 네비게이션 시 유저 경험이 좀 더 부드러워지고, 불필요한 데이터 요청도 줄일 수 있습니다. 만약 대형 앱에서 사용자 인터렉션 빈도가 높다면 캐싱 매커니즘을 활용하는 것을 강력히 추천드려요!\n\n아래 표는 대표적인 `staleTimes` 설정 예시입니다:\n\n| 설정 값         | 설명                                |\n|----------------|-----------------------------------|\n| `staleTimes: 0` | 캐시 사용 안 함 (기본값)             |\n| `staleTimes: 60000` | 1분간 캐시 유지                       |\n| `staleTimes: 300000` | 5분간 캐시 유지                       |\n\n캐싱 시간은 앱의 특성이나 사용자 흐름에 따라 적절히 조절하면 됩니다.\n\n---\n\n필요하다면 다음에 `staleTimes`를 실제 코드에 적용하는 예시도 공유할게요! 언제든 질문 주세요. :)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안녕하세요! 오늘은 Next.js에서 최근에 업데이트된 부분 중 하나를 같이 살펴볼게요.\n\n먼저, 여러분이 보신 것처럼 `next.config.js`에 아래와 같은 설정이 들어갈 수 있습니다.\n\n```js\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  experimental: {\n    staleTimes: {\n      dynamic: 30,\n      static: 180,\n    },\n  },\n}\n\nmodule.exports = nextConfig\n```\n\n### 이 설정, 뭐 하는 거냐?\n\n`staleTimes` 설정은 Next.js에서 페이지를 캐싱하는 시간과 관련된 실험적 기능입니다. 여기서 'dynamic'은 동적 데이터가 있는 페이지에 대한 캐시 시간(초 단위), 'static'은 정적인 페이지에 대한 캐시 시간을 의미해요.\n\n- `dynamic: 30` → 동적 페이지는 30초 동안 캐시를 유지\n- `static: 180` → 정적 페이지는 180초 동안 캐시 유지\n\n이렇게 하면 방문자가 페이지를 빠르게 로드할 수 있게 되면서도, 너무 오래된 데이터가 보여지는 것을 어느 정도 방지할 수 있죠.\n\n하지만 중요한 점! 레이아웃(layouts)이나 로딩 상태(loading states)는 여전히 네비게이션할 때 캐시되고 재사용됩니다. 즉, 페이지 전체가 아닌 일부 컴포넌트의 상태 재사용은 유효하다는 거예요. 이 부분은 개발자가 미리 염두에 두면 사용자 경험을 개선하는 데 도움이 됩니다.\n\n---\n\n### next/font가 사라졌다고?\n\n예전 Next.js에서는 `@next/font`라는 패키지를 통해서 폰트를 쉽게 관리할 수 있었죠. 그런데 이제는 `next/font`가 빌트인 기능으로 통합되면서 별도의 패키지를 설치할 필요가 없게 됐어요.\n\n즉, 옛날 방식으로 `@next/font`에서 import 했다면, 이제는 그냥 `next/font`로 바꾸면 됩니다. 게다가, 이 작업을 안전하고 자동으로 해주는 **codemod** 도구가 제공되고 있으니, 큰 걱정 없이 업그레이드할 수 있습니다.\n\n---\n\n### 개발자로서 알아두면 좋은 팁!\n\n- 이런 실험적 기능들은 실제 프로덕션에 적용하기 전에 꼭 테스트를 해보세요. 자동 캐싱 때문에 데이터가 오래된 상태로 보여질 수 있으니, 데이터 신선도를 유지하는 전략을 같이 고민하는 게 중요합니다.\n- Next.js가 업데이트될 때마다 공식 문서, 마이그레이션 가이드, 그리고 codemod 도구를 적극 활용하면, 시간과 노력을 절약할 수 있어요.\n\nNext.js가 점점 더 사용하기 편리해지고 있어서 앞으로가 더욱 기대됩니다! 다음에도 새롭고 쓸만한 기능이나 팁 있으면 같이 나눠봐요~ 😄\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이번에 Next.js에서 바뀐 import 방식과 설정 옵션에 대해 알아볼게요. 코드를 보면서 쉽게 따라올 수 있도록 차근차근 설명해드릴게요.\n\n---\n\n### 1. 폰트 import 경로 변경\n\n```js\n// Before\nimport { Inter } from '@next/font/google'\n\n// After\nimport { Inter } from 'next/font/google'\n```\n\n예전에는 `@next/font/google` 경로에서 구글 폰트를 가져왔는데, 이제는 `next/font/google` 경로로 바뀌었어요. 굳이 `@next/`가 붙지 않아서 더 깔끔해졌죠.\n\n> 참고로, 이 변경으로 인해 폰트 관련 코드에서 오류가 발생한다면 경로를 꼭 확인해보세요!\n\n---\n\n### 2. 설정 옵션 이름 변경: `bundlePagesExternals` → `bundlePagesRouterDependencies`\n\n```js\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  // Before\n  experimental: {\n    bundlePagesExternals: true,\n  },\n\n  // After\n  bundlePagesRouterDependencies: true,\n}\n\nmodule.exports = nextConfig\n```\n\n기존엔 experimental(실험 기능) 중 하나로 쓰이던 `bundlePagesExternals`가 정식으로 자리 잡으면서 이름도 `bundlePagesRouterDependencies`로 바뀌었어요. 이제 `experimental` 안에 넣지 않고 바로 최상위 옵션으로 작성하면 됩니다.\n\n> 이 옵션은 페이지 라우터에서 의존성들을 묶어서 번들링하는 기능인데요. 페이지별로 필요한 모듈들을 효율적으로 관리할 때 도움되니, 대규모 프로젝트에서는 성능 최적화에 유용합니다.\n\n---\n\n### 요약\n\n| 변경 전                       | 변경 후                         | 설명                                    |\n|------------------------------|--------------------------------|----------------------------------------|\n| `import { Inter } from '@next/font/google'` | `import { Inter } from 'next/font/google'` | 구글 폰트 import 경로 변경                  |\n| `experimental.bundlePagesExternals`         | `bundlePagesRouterDependencies`           | 실험적 기능에서 정식 옵션으로 변경 및 위치 이동 |\n\n---\n\nNext.js는 꾸준히 발전하면서 더 깔끔하고 성능 좋은 설정 방법들을 제시해주니까 자주 공식 문서를 살펴보면서 최신 변화를 체크하는 게 좋아요. 필요하면 새 설정도 실험해보면서 최적화해 보시길 추천드립니다! 😊\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## serverExternalPackages\n\nNext.js에서 `experimental.serverComponentsExternalPackages`가 안정화되어 이제 `serverExternalPackages`로 이름이 변경되었어요.\n\n예전엔 `experimental` 안에 설정했지만, 이제는 그냥 바로 `serverExternalPackages`로 설정하면 됩니다.\n\n```js\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  // 예전 방식\n  experimental: {\n    serverComponentsExternalPackages: ['package-name'],\n  },\n \n  // 최신 방식\n  serverExternalPackages: ['package-name'],\n}\n\nmodule.exports = nextConfig\n```\n\n이 설정은 서버 컴포넌트에서 외부 패키지를 사용할 때 필요한 건데, 특히 기본적으로 서버 컴포넌트에 포함되지 않는 서드파티 패키지를 명시할 때 유용해요. 이렇게 하면 빌드 과정에서 오류를 방지하고, 필요한 패키지를 서버에서 올바르게 로드할 수 있습니다.\n\n추가로, `serverExternalPackages`를 잘 활용하면 서버 컴포넌트의 성능 최적화에 도움이 될 수 있어요. 왜냐하면, 서버쪽에서 필요한 패키지를 명확히 분리해서 로드하니까 클라이언트 번들 사이즈가 줄어들고 불필요한 코드가 포함되는 걸 막을 수 있거든요.\n\n## Speed Insights\n\nNext.js 같은 프레임워크를 쓰면서 성능에 대해 고민하는 건 정말 중요하죠! 구글의 Speed Insights 같은 도구를 통해 내 웹사이트가 얼마나 빠른지, 어느 부분에서 병목 현상이 일어나는지 확인해보는 걸 추천합니다.\n\nSpeed Insights는 페이지 로딩 시간, 사용자 경험, 접근성, SEO 등 다양한 지표를 점수로 보여주는데, 결과에 따라 개선할 수 있는 부분을 구체적으로 안내해줘요.\n\n저도 개발하면서 Speed Insights를 꾸준히 체크하면서 아래 부분들에 주로 신경써요:\n\n- 이미지 최적화 (이미지 사이즈 축소, next/image 컴포넌트 활용)\n- 코드 스플리팅 및 동적 import\n- 불필요한 자바스크립트 제거\n- 서버 쪽 렌더링 활용과 클라이언트에서의 첫 로딩 속도 최적화\n\nNext.js 최신 버전을 활용하는 것 자체가 이미 많은 최적화가 적용되어 있지만, `serverExternalPackages` 같이 서버 컴포넌트 관련 설정을 꼼꼼히 맞추는 것도 결국 Speed Insights 점수를 끌어올리는 데 도움이 됩니다.\n\n웹사이트 속도는 사용자 경험에도 큰 영향을 주니, 한번에 완벽하려고 하기보다 꾸준하게 모니터링하고 개선하는 습관을 들이는 게 가장 좋아요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js 15부터는 Speed Insights를 자동으로 연동해주는 기능이 제거되었어요.\n\n그래서 Speed Insights를 계속 사용하고 싶다면, Vercel에서 제공하는 Speed Insights Quickstart 가이드를 참고해서 직접 설정해줘야 합니다.\n\n---\n\n## NextRequest의 Geolocation 변경점\n\n이전 버전에서는 NextRequest 객체에서 `geo`와 `ip` 같은 지리 정보 관련 속성을 직접 제공했는데요, Next.js 15부터는 이 값들이 호스팅 제공자(예: Vercel)에서 직접 제공되기 때문에 해당 속성들이 제거되었어요.\n\n만약 프로젝트에서 이 부분을 사용하고 있다면, 자동으로 변경해주는 codemod(코드 변환 도구)가 있으니 이를 활용하면 편리하게 마이그레이션 할 수 있습니다.\n\n---\n\n### 덧붙여서\n\n- Speed Insights를 자동으로 처리해주던 기능이 빠진 만큼, 수동 설정 과정에서 분석된 데이터를 직접 확인하고 조작할 수 있다는 장점도 있어요.\n- hosting provider가 제공하는 geo 정보는 좀 더 정확하거나 세밀한 경우가 많으니 이를 활용해보는 것도 추천합니다.\n- Codemod는 CLI 기반 도구로, 프로젝트 루트에서 실행하면 자동으로 코드 패턴을 찾아서 새 구조에 맞게 바꿔줍니다. 사용법은 보통 공식 문서를 참고하면 되고, 큰 규모 프로젝트에서도 안정적으로 변경 가능해요.\n\n더 궁금한 점 있으면 알려주세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 Vercel을 사용하고 있다면, @vercel/functions 패키지에서 제공하는 geolocation과 ipAddress 함수를 활용할 수도 있어요. 이렇게 하면 클라이언트의 위치 정보나 IP 주소를 쉽게 가져올 수 있답니다.\n\n예를 들어, geolocation 함수는 요청 정보를 기반으로 위치 데이터를 반환해줘서, 미들웨어에서 바로 도시 이름(city) 같은 걸 뽑아 쓸 수 있어요:\n\n```js\nimport { geolocation } from '@vercel/functions'\nimport type { NextRequest } from 'next/server'\n \nexport function middleware(request: NextRequest) {\n  const { city } = geolocation(request)\n \n  // 여기서 city 정보를 활용할 수 있습니다.\n}\n```\n\n또한 ipAddress 함수는 요청에서 IP 주소만 딱 반환하기 때문에, IP 기반 처리나 인증 등에 쓸 때 편리해요:\n\n```js\nimport { ipAddress } from '@vercel/functions'\nimport type { NextRequest } from 'next/server'\n \nexport function middleware(request: NextRequest) {\n  const ip = ipAddress(request)\n \n  // ip를 활용하는 로직 작성\n}\n```\n\n참고로, 이 함수들을 쓰면 직접 클라이언트 IP를 헤더에서 뽑거나, 외부 API를 호출해서 위치를 확인하는 등의 번거로운 작업을 줄일 수 있어서 개발 속도가 훨씬 빨라질 거예요. 다만, Vercel 플랫폼에서만 동작하니 로컬이나 다른 환경에서는 호환성에 유의해 주세요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":32},{"title":"Next.js 14 버전으로 업그레이드하는 방법","description":"","date":"2025-04-22 01:44","slug":"2025-04-22-Howtoupgradetoversion14","content":"\n\n# Next.js 14 버전으로 업그레이드하는 방법\n\n## 13버전에서 14버전으로 업그레이드하기\n\nNext.js 14 버전으로 업데이트하려면 아래 명령어를 사용하면 돼요. 자신이 주로 사용하는 패키지 매니저에 맞춰 실행해 주세요!\n\n```bash\nnpm i next@next-14 react@18 react-dom@18 && npm i eslint-config-next@next-14 -D\n```\n\n이 명령어는 Next.js, React, React DOM을 각각 최신 버전(14 버전과 React 18)으로 업데이트해주고, 개발 환경에서 ESLint 설정도 맞게 업그레이드해 줍니다.\n\n> 참고로, Next.js는 React 최신 버전과 호환되도록 설계돼 있어서 React도 같이 업데이트해야 원활한 개발 가능해요.\n\nnpm 대신 yarn을 쓰는 분들은,\n\n```bash\nyarn add next@next-14 react@18 react-dom@18 && yarn add -D eslint-config-next@next-14\n```\n\n이렇게 하면 됩니다.\n\n---\n\n### 추가 팁\n\n- 버전 업그레이드 후에는 의존성 충돌이 없는지, 개발 서버가 정상 실행되는지 꼭 확인하세요.\n- Next.js 14 버전에서는 여러 가지 새로운 기능과 최적화가 들어갔는데, 공식 릴리즈 노트를 한 번 쭉 읽어보는 것도 좋아요.\n- 아무래도 메이저 버전 업그레이드이다 보니 기존 코드 일부는 수정이 필요할 수 있으니, 마이그레이션 문서나 changelog도 참고해 주세요.\n\n저도 최근에 Next.js 13에서 14로 넘어가면서 성능이 좀 더 좋아진 것 같고 깔끔한 API들도 마음에 들었어요. 한번 도전해 보시길 추천드릴게요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안녕하세요, 여러분! 오늘은 Next.js 14 버전과 React 18을 설치하는 방법을 소개해 드릴게요. 그리고 ESLint 설정도 최신 버전으로 맞추는 팁도 함께 알려드리겠습니다.\n\n사실 요즘에는 패키지 매니저가 여러 개 있어서 npm, yarn부터 pnpm, 심지어 bun까지 다양한 선택지가 있죠. 그래서 각 패키지 매니저별로 설치 명령어를 깔끔하게 정리해봤어요.\n\n| 패키지 매니저 | 설치 명령어 |\n|---------------|-------------|\n| yarn          | `yarn add next@next-14 react@18 react-dom@18 && yarn add eslint-config-next@next-14 -D` |\n| pnpm          | `pnpm i next@next-14 react@18 react-dom@18 && pnpm i eslint-config-next@next-14 -D` |\n| bun           | `bun add next@next-14 react@18 react-dom@18 && bun add eslint-config-next@next-14 -D` |\n\n여기서 `-D` 옵션은 ESLint 설정을 개발환경용 의존성(devDependencies)으로 설치하겠다는 의미입니다. ESLint는 코드 품질 유지에 필수적인 도구니까 꼭 함께 설치해 주세요!\n\n> **참고!** 만약 TypeScript를 사용 중이라면 `@types/react`와 `@types/react-dom` 타입 선언 패키지도 꼭 최신 버전으로 업그레이드 해주세요. 그래야 타입 오류 없이 쾌적하게 개발할 수 있답니다.\n\n```bash\nyarn add @types/react@latest @types/react-dom@latest -D\n# 또는\npnpm i @types/react@latest @types/react-dom@latest -D\n# bun은 현재 타입 선언 패키지 직접 설치가 조금 다를 수 있으니 공식 문서 참고하세요.\n```\n\n끝으로, Next.js 14 버전은 많은 성능 개선과 새로운 기능을 담고 있어서 이번 기회에 업그레이드 해보시면 정말 좋을 거예요! 혹시 설치 중 문제가 발생하거나, 관련해서 더 궁금한 점 있으면 언제든지 댓글로 질문 주세요. 즐거운 개발 되세요~ 🚀\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### Next.js v14 요약\n\n안녕하세요! 오늘은 Next.js 최신 버전인 v14의 주요 업데이트 내용을 쉽게 정리해볼게요. 버전 업 할 때 꼭 체크해야 할 부분들이니 한 번 살펴보시길 추천해요.\n\n| 주요 변경 사항 | 설명 |\n|---|---|\n| Node.js 최소 버전 상향 | 기존 16.14에서 18.17로 최소 버전이 올라갔어요. 16.x는 공식적으로 지원이 종료됐기 때문에 최신 환경에서 개발하려면 Node 버전을 꼭 업그레이드하세요. |\n| next export 명령어 삭제 | 기존에 사용하던 `next export` 커맨드가 없어지고, 대신 `output: 'export'` 설정으로 변경됐어요. 정적 사이트 생성 시 설정 방식이 조금 바뀌었으니 공식 문서를 참고해 주세요. |\n| ImageResponse import 경로 변경 | 이미지 생성용 `ImageResponse` 컴포넌트의 import 경로가 `next/server` 대신 `next/og`로 바뀌었습니다. 자동 변환 도구(codemod)가 제공되니 쉽게 적용 가능해요. |\n| @next/font 패키지 제거 | 커스텀 폰트 관련 패키지였던 `@next/font`가 완전히 사라지고, Next.js 내장 `next/font`로 통합됐습니다. 이 부분도 자동 변환 스크립트를 활용해보세요. |\n| next-swc WASM 타겟 제거 | 성능 향상에 사용되던 WebAssembly(WASM) 타겟이 제거됐습니다. 앞으로는 다른 방식으로 최적화가 이뤄질 예정이에요. |\n\n---\n\n#### 추가 팁!\n\n- Node.js 버전 업그레이드는 Next.js뿐 아니라 다른 최신 라이브러리들도 잘 지원하니, 개발 환경 개선을 위한 좋은 기회예요.\n- codemod라는 도구가 자동으로 코드 전반에 걸쳐 변경점을 적용해주니, 수동 작업에 따른 실수를 줄일 수 있어요. 명령어 몇 줄로 업데이트가 가능해서 큰 도움이 됩니다!\n- `next export` 설정 변경은 정적 사이트 생성(SSG) 프로젝트라면 꼭 확인해야 할 부분입니다. 기존 방식과 조금 달라서 배포 플로우에 영향이 있을 수 있으니 사전에 테스트해보세요.\n\n---\n\nNext.js가 계속 발전하면서 새로운 개발 패턴과 최적화가 도입되고 있어요. 빠르게 변경 사항을 따라가면 더 편리하고 안정적인 웹 앱 개발이 가능하니 꾸준히 최신 문서도 살펴보시길 권해드립니다! 도움이 되셨다면 좋아요와 구독도 잊지 마세요 😊","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":4},{"title":"2025년 React 개발자를 위한 codemods 사용법과 예시 정리","description":"","date":"2025-04-22 01:40","slug":"2025-04-22-Codemods","content":"\n# Codemods\n\nCodemods는 코드베이스에 대해 프로그램적으로 실행되는 변환 작업을 말해요. 쉽게 말해, 한 파일 한 파일 수작업으로 고치지 않아도, 많은 파일에 걸쳐 자동으로 코드를 변경할 수 있게 도와주는 도구입니다.\n\nNext.js에서는 API가 업데이트되거나 더 이상 지원되지 않을 때, 코드를 쉽게 업그레이드할 수 있도록 Codemod 변환 스크립트를 제공해요. 덕분에 버전 업그레이드가 한결 수월해지죠.\n\n## 사용법\n\n(이후에 사용법 내용이 이어질 텐데, 필요하면 언제든 알려주세요!)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n터미널에서 프로젝트 폴더로 이동(cd)한 후, 아래 명령어를 실행해보세요:\n\n```bash\nnpx @next/codemod <transform> <path>\n```\n\n여기서 `<transform>`과 `<path>`는 상황에 맞게 바꿔주시면 됩니다.\n\n| 옵션      | 설명                                          |\n| --------- | --------------------------------------------- |\n| transform | 적용할 변환(transform) 이름                   |\n| path      | 변환을 적용할 파일 또는 디렉토리 경로         |\n| --dry     | 실제 코드 변경 없이 시뮬레이션(드라이런) 실행 |\n| --print   | 변경된 결과를 화면에 출력해서 비교 가능       |\n\n---\n\n참고로, `@next/codemod`는 Next.js 프로젝트에서 코드 마이그레이션을 좀 더 쉽게 해주는 도구예요. 예를 들어, Next.js 버전을 업그레이드하면서 API가 변경된 부분을 한꺼번에 자동 변환할 때 자주 사용됩니다.\n\n`--dry` 옵션은 정말 유용해요. 코드를 직접 바꾸기 전에, 어떤 부분이 바뀔지 먼저 확인할 수 있으니까요. `--print` 옵션은 변경된 결과를 터미널에 출력해줘서, 기존 코드와 변경된 코드를 비교할 수 있게 도와줍니다.\n\n만약 여러 transform을 한꺼번에 실행하고 싶다면, 반복해서 실행하거나 스크립트를 만들어서 자동화할 수도 있습니다. 작업 전에 꼭 Git 등의 버전 관리에 커밋을 한 상태에서 진행하시길 추천드려요. 혹시 변환 결과가 마음에 안 들면 쉽게 되돌릴 수 있으니까요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## Codemods\n\n### 15.0 버전\n\n#### App Router Route Segment Config의 runtime 값을 experimental-edge에서 edge로 변경하기\n\n> 참고: 이 codemod는 App Router에만 해당됩니다.\n\n---\n\n여기서 말하는 codemod는 코드 자동 변환 스크립트를 의미해요. 개발하다 보면 API가 변경되거나 새로운 문법이 도입될 때 기존 코드를 한꺼번에 바꿔야 할 때가 많잖아요? 이런 작업을 수동으로 하면 시간도 많이 들고, 실수할 수도 있어서 codemod를 쓰면 편리하죠.\n\n이번 15.0 업데이트에서는 App Router를 사용하는 분들을 위해 route segment 설정에서 `experimental-edge`라는 runtime 값을 `edge`로 변경하는 작업이 필요해요. 기존에는 'experimental'이라는 접두어가 붙는 기능들이 많았는데, 점점 안정화되면서 접두어를 빼는 경우가 많습니다.\n\n만약 App Router를 쓰고 있고, route segment 설정에서 runtime을 직접 지정하셨다면 codemod를 돌려서 일괄적으로 변경해 주시길 추천드려요.\n\n아, 그리고 codemod를 돌리기 전에 반드시 코드 베이스를 백업하거나 Git에 커밋해두는 것 잊지 마세요! 자동 변환 과정에서 예상치 못한 문제가 생길 수도 있으니까요.\n\n궁금하신 점 있으면 언제든 말씀해 주세요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 코드는 Next.js 프로젝트에서 사용하는 codemod 명령어예요.\n\n```bash\nnpx @next/codemod@latest app-dir-runtime-config-experimental-edge .\n```\n\n이 명령어는 Next.js에서 Route Segment Config의 `runtime` 설정 중 `'experimental-edge'`로 되어 있는 값을 `'edge'`로 자동으로 변경해 줍니다.\n\n예를 들어, 기존에 이런 식으로 작성한 코드가 있다면:\n\n```js\nexport const runtime = \"experimental-edge\";\n```\n\n이 codemod를 실행하면 이렇게 바뀌게 되는 거죠:\n\n```js\nexport const runtime = \"edge\";\n```\n\n---\n\n### 왜 이런 변경이 필요할까?\n\nNext.js가 점점 발전하면서, `experimental-edge`라는 이름이 정식으로 `edge`로 바뀌었어요. 이름도 더 간결해지고 안정성이 더 높아졌다는 의미예요. 예전에는 엣지 런타임이 실험적인 단계라 'experimental'이 붙었지만, 이제는 본격적으로 지원하기 때문에 이름이 바뀐 거죠.\n\n그래서 프로젝트를 최신 상태로 유지하려면 이런 codemod를 한번 돌려주는 게 좋아요. 복잡한 파일들을 일일이 찾아 바꾸지 않아서 시간도 절약되고 실수할 위험도 줄어들고요.\n\n---\n\n### 참고로 알아두면 좋은 점\n\n- codemod는 \"코드 변환 도구\"를 뜻해요. 주로 대규모 코드 변경이 필요할 때 사용되며, Next.js뿐 아니라 React, TypeScript 등 여러 생태계에서도 자주 활용돼요.\n- `npx`를 쓰면 별도의 설치 없이 최신 버전의 패키지를 바로 실행할 수 있어서 편리하답니다.\n- 만약 프로젝트가 매우 크거나, 중요한 부분이라면 codemod를 돌리기 전에 git으로 꼭 커밋 해두기, 혹은 별도의 브랜치에서 작업하는 걸 추천해요. 혹시 문제가 생겨도 쉽게 되돌릴 수 있으니까요.\n\n필요하면 제가 codemod 활용법이나 Next.js 엣지 런타임에 관한 더 자세한 글도 써볼게요~!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음과 같이 바뀌었어요:\n\n```js\nexport const runtime = \"edge\";\n```\n\n### 비동기(dynamic) API로 마이그레이션하기\n\n기존에 동기 방식도 지원하던 동적 렌더링 API들이 이제는 완전히 비동기 방식으로 변경됐어요. 이 부분은 프로젝트에 꽤 큰 영향을 줄 수 있으니 [업그레이드 가이드](https://nextjs.org/docs/upgrading)를 꼭 참고해서 차근차근 적용하는 걸 추천드립니다.\n\n---\n\n추가로, 이 변화를 이해할 때 조금 도움이 될만한 점을 덧붙이면, '동적 API'는 요청이 들어올 때마다 서버에서 새로 데이터를 받아서 처리하는 방식인데요, 이전에는 동기 방식이라 처리 완료까지 기다렸다가 결과를 반환했어요. 하지만 비동기로 바뀌면서 처리 효율이 좋아지고 서버 자원 활용도 더 최적화됐답니다.\n\n마이그레이션 하실 때는 async/await 문법에 익숙해지는 게 중요하고, API 핸들러 함수도 `async` 함수로 선언해주셔야 해요! 만약 기존 코드가 동기식으로 작성돼 있다면, 바로 비동기 로직으로 전환하는 게 필수입니다. 코드가 길거나 복잡하다면 조금 시간이 걸릴 수 있지만, 장기적으로는 더 효율적인 서버 리소스 관리와 성능 향상을 기대할 수 있어요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이번에 Next.js에서 동적 API인 `cookies()`, `headers()`, 그리고 `draftMode()` 같은 함수들이 이제 비동기(async) 함수로 바뀌었어요. 이전에는 그냥 바로 호출해서 값을 썼지만, 이제는 `await` 하거나, React 컴포넌트 안에서는 `React.use()`로 감싸줘야 제대로 동작합니다.\n\n그래서 Next.js에서 제공하는 코드를 한번에 자동 변환해주는 codemod가 있는데, 명령어는 이렇게 써주세요:\n\n```bash\nnpx @next/codemod@latest next-async-request-api .\n```\n\n이 코드는 프로젝트 내의 파일들을 찾아서 `cookies()`, `headers()` 같은 비동기 API 호출을 올바르게 변환해줍니다. 예를 들어 TypeScript 파일이면 타입캐스트를 추가하고, 자동 변환이 어려운 부분은 주석으로 알려서 직접 점검하게 도와줘요.\n\n아래 예시 코드를 보면,\n\n```js\nimport { cookies, headers } from \"next/headers\";\n\nconst token = cookies().get(\"token\");\n\nfunction useToken() {\n  const token = cookies().get(\"token\");\n  return token;\n}\n\nexport default function Page() {\n  const name = cookies().get(\"name\");\n}\n\nfunction getHeader() {\n  return headers().get(\"x-foo\");\n}\n```\n\n이렇게 동기적으로 호출하는 부분을 전부 비동기 패턴으로 바꿔줘야 합니다. 즉, `await cookies()` 혹은 React 훅 내에선 `React.use(cookies())`처럼요.\n\n---\n\n### 추가 팁!\n\n- `cookies()`, `headers()`, `draftMode()`가 비동기가 되면서 서버 컴포넌트(React Server Component)에서 사용하는 경우엔 `await`를 달아줘야 하니 주의하세요.\n- 클라이언트 컴포넌트에서는 직접 호출하면 안되고, 서버나 API 라우트 쪽에서 비동기로 사용하거나, Suspense 같은 컴포넌트 내에서 처리해야 해요.\n- 만약 자동 변환이 안 된 부분이 있다면, codemod가 표시한 주석을 놓치지 말고 꼭 확인해서 수동으로 고쳐주세요!\n\n---\n\n요즘 Next.js 프로젝트를 업그레이드하거나, 최신 기능 적용 중이라면 이 codemod 꼭 활용해 보시고, 비동기 호출 방식에 익숙해지시면 좋아요~! React와 Next.js가 점점 더 현대적인 패턴으로 변하고 있답니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n먼저, 주어진 코드 예제를 살펴볼게요. Next.js에서 `cookies`와 `headers`를 가져와서 토큰(token)을 읽는 방식인데, 여기서 중요한 점은 **동기 함수에서 비동기 프로퍼티 접근을 자동으로 감지해서 해당 함수를 async 함수로 변환하거나, 클라이언트 컴포넌트라면 React의 `use` 훅을 사용하는 점**이에요.\n\n예를 들어 아래 코드를 보면:\n\n```js\nconst token = (cookies() as unknown as UnsafeUnwrappedCookies).get('token')\n```\n\n이 코드는 동기적으로 보이지만 사실 `cookies()`가 비동기로 작동할 수 있어서, Next.js는 페이지나 라우트 파일(`page.js`, `layout.js`, `route.js`, `default.js`) 내에서 이런 프로퍼티 접근을 발견하면 함수 선언부를 async로 바꾸고 `await`를 붙여줍니다.\n\n또, 만약 해당 컴포넌트가 클라이언트 컴포넌트라면 `await`을 사용할 수 없으니 `React.use` 훅으로 promise를 언랩핑하는 방식을 써요. 예를 들어:\n\n```js\nfunction useToken() {\n  const token = use(cookies()).get(\"token\");\n  return token;\n}\n```\n\n이렇게 `use` 훅을 써서 비동기 리소스를 처리하죠.\n\n---\n\n### 주요 포인트 정리\n\n| 내용                                    | 설명                                                                                                  |\n| --------------------------------------- | ----------------------------------------------------------------------------------------------------- |\n| 동기 함수에서 비동기 프로퍼티 접근 감지 | `params`나 `searchParams`의 프로퍼티를 조회할 때 해당 함수가 자동으로 `async` 변환되면서 `await` 처리 |\n| 클라이언트 컴포넌트 제한                | 클라이언트 컴포넌트는 async 함수가 될 수 없으므로, React `use` 훅으로 비동기 값을 처리                |\n| 대상 파일                               | `page.js`, `layout.js`, `route.js`, `default.js` 그리고 `generateMetadata`, `generateViewport` API    |\n| 안전하지 않은 타입 처리                 | 내부적으로 `UnsafeUnwrappedCookies`, `UnsafeUnwrappedHeaders` 타입으로 캐스팅해서 다룰 수도 있음      |\n\n---\n\n### 개인적인 팁\n\n- Next.js 13+ 앱 디렉터리에서 `cookies()` 같은 API를 쓸 때, 가끔 이 비동기 처리 꼼수가 꽤 편리해요. 직접 `async/await` 붙이는 수고를 덜어주니까요.\n- 다만 클라이언트 컴포넌트에서 `use(cookies())`처럼 React 훅을 사용하려면, React 18 이상의 환경이 필요하니 버전 확인 필수!\n- 이런 자동 변환 덕분에 페이지 렌더링 시 필요한 헤더값, 쿠키값 등을 간편하게 처리할 수 있어 개발 속도가 빨라집니다.\n\n---\n\n필요하면 Next.js 내부에서 어떻게 이 변환이 처리되는지 좀 더 깊게 살펴볼 수도 있고, 클라이언트/서버 컴포넌트 간 상태 전달 팁도 알려줄게요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n자, 여기서 Next.js 13에서 `page.tsx` 파일 안의 컴포넌트와 `generateMetadata` 함수가 어떻게 변경되는지 보여주는 예시가 있어요.\n\n### 원래 코드\n\n```js\n// page.tsx\nexport default function Page({\n  params,\n  searchParams,\n}: {\n  params: { slug: string }\n  searchParams: { [key: string]: string | string[] | undefined }\n}) {\n  const { value } = searchParams\n  if (value === 'foo') {\n    // ...\n  }\n}\n\nexport function generateMetadata({ params }: { params: { slug: string } }) {\n  const { slug } = params\n  return {\n    title: `My Page - ${slug}`,\n  }\n}\n```\n\n여기서 `Page` 컴포넌트는 `params`와 `searchParams`를 바로 받고 있고, `generateMetadata` 함수도 일반 함수처럼 파라미터에서 `params`를 받는 구조입니다.\n\n---\n\n### 변경된 코드\n\n```js\n// page.tsx\nexport default async function Page(props: {\n  params: Promise<{ slug: string }>\n  searchParams: Promise<{ [key: string]: string | string[] | undefined }>\n}) {\n  const searchParams = await props.searchParams\n  const { value } = searchParams\n  if (value === 'foo') {\n    // ...\n  }\n}\n\nexport async function generateMetadata(props: {\n  params: Promise<{ slug: string }>\n}) {\n  const params = await props.params\n  const { slug } = params\n  return {\n    title: `My Page - ${slug}`,\n  }\n}\n```\n\n변경점은 다음과 같아요:\n\n1. `Page` 함수가 `async` 함수가 되었고, `params`와 `searchParams`가 이제 Promise로 감싸져서 들어와요. 그래서 함수 안에서 `await`해야 값을 얻을 수 있습니다.\n2. `generateMetadata`도 이제 `async` 함수이고, 역시 `params`가 Promise로 전달되니 `await`를 써야 하죠.\n\n---\n\n### 왜 이렇게 바뀌었을까요?\n\nNext.js 13에선 데이터 및 메타데이터가 비동기로 처리되는 경우가 많아져서, 이런 형태가 표준화되었어요. 특히, 서버 컴포넌트 특성상 데이터 fetching이나 메타데이터 생성이 비동기 작업이 될 수 있기 때문이죠.\n\n즉, `async` 함수로 만들어주고, `await`로 받아서 데이터를 처리하는 패턴이 더 자연스러워졌어요.\n\n---\n\n### 추가로 알아두면 좋은 점\n\n- **@next/codemod 주석**: 만약 자동 변환 도구(codemod)가 정확한 변경을 파악하기 어려운 곳이 있으면 `@next/codemod` 주석을 코드에 붙이는데, 이걸 발견하면 수동으로 코드를 확인하고 수정해야 합니다. 빌드 에러가 날 수 있으니 꼭 확인하고 고쳐야 해요.\n- 타입스크립트에서 `Promise` 타입을 파라미터로 받는 상황이 낯설 수 있는데, 이제 이런 패턴이 Next.js의 최신 구조에선 흔하니 익숙해지는 게 좋아요.\n\n---\n\n### 요약\n\n| 이전                                           | 이후                                                                   |\n| ---------------------------------------------- | ---------------------------------------------------------------------- |\n| 동기 함수, 직접 `params`와 `searchParams` 받음 | `async` 함수, `params`와 `searchParams`가 `Promise`라서 `await`해야 함 |\n| `generateMetadata`는 일반 함수                 | `generateMetadata`도 `async` 함수가 되어 `await` 처리 필요             |\n\n---\n\n### 마무리\n\nNext.js 13부터는 데이터와 메타데이터 처리 방식이 좀 더 비동기적이고 유연해졌어요. 그래서 `Page` 컴포넌트나 `generateMetadata`에서 기대하는 props 타입과 함수 선언방식이 바뀌었죠. 처음엔 조금 헷갈릴 수 있지만, 패턴에 익숙해지면 훨씬 효과적으로 서버 컴포넌트와 메타데이터를 다룰 수 있습니다.\n\n궁금한 점 있으면 편하게 물어봐 주세요! 😄\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n#### NextRequest의 geo와 ip 속성을 @vercel/functions로 교체하기\n\nNext.js에서 `NextRequest` 객체의 `geo`와 `ip` 속성을 사용할 때, 이제는 `@vercel/functions` 패키지를 사용하는 방향으로 바뀌고 있어요. 이를 간단하게 자동 변경해주는 코드를 소개할게요.\n\n```bash\nnpx @next/codemod@latest next-request-geo-ip .\n```\n\n이 명령어는 `@vercel/functions`를 설치하고, 프로젝트 내의 `NextRequest` 코드에서 `geo`와 `ip` 관련 속성들을 자동으로 변환해 줍니다.\n\n예를 들어, 기존에 이렇게 쓰던 코드를:\n\n```js\nexport function middleware(request) {\n  const country = request.geo?.country || \"US\";\n  const ipAddress = request.ip;\n  // ...\n}\n```\n\n`@vercel/functions` 방식으로 이렇게 바꿔줘요:\n\n```js\nimport { headers } from \"@vercel/functions\";\n\nexport function middleware(request) {\n  const country = headers()[\"x-vercel-ip-country\"] || \"US\";\n  const ipAddress = headers()[\"x-vercel-ip\"];\n  // ...\n}\n```\n\n사실 `@vercel/functions`를 쓰면 클라우드 엣지 환경에서 제공하는 IP와 지리 정보가 HTTP 헤더 형태로 전달됩니다. 그래서 직접 `NextRequest` 객체에서 속성을 읽는 대신, 헤더를 통해 읽는 방식으로 변경이 필요하답니다.\n\n---\n\n#### 참고 팁!\n\n- 만약 프로젝트에서 IP나 지리 정보가 중요한 로직이라면, 헤더의 키 이름이 변경되거나 누락되는 경우를 대비해서 기본값 처리를 꼭 해주세요.\n- 로컬 개발 환경에서는 이런 헤더가 없을 수 있기 때문에, 로컬 전용 설정이나 예외 처리도 고려하는 게 좋아요.\n- 직접 속성에 접근하는 코드가 많을수록 이 변환 작업을 자동화하는 codemod 도구를 꼭 써보시길 추천합니다. 수작업으로 고치면 빼먹는 코드가 생길 수 있거든요!\n\n이렇게 하면 Vercel에서 더 안정적이고 최신 방식으로 IP와 지역 정보를 활용할 수 있답니다. 멋진 개발하시길! 🚀\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이번에 Next.js API Route에서 클라이언트의 지리 정보(Geo)와 IP 주소를 가져오는 방식에 변화가 생겼네요.\n\n기존에는 NextRequest 객체에서 바로 `geo`와 `ip` 속성을 가져왔는데요, 14.0 버전부터는 `@vercel/functions` 에서 제공하는 `geolocation()`과 `ipAddress()` 함수를 이용해야 합니다.\n\n```js\nimport type { NextRequest } from \"next/server\";\nimport { geolocation, ipAddress } from \"@vercel/functions\";\n\nexport function GET(req: NextRequest) {\n  const geo = geolocation(req);\n  const ip = ipAddress(req);\n}\n```\n\n이렇게 바뀌면서 좀 더 명확하고 함수화된 형태로 관리할 수 있게 됐어요.\n\n한 가지 참고할 점!  \n만약 서버 측에서 클라이언트 IP를 신뢰성 있게 얻고 싶다면, 프록시나 로드 밸런서가 있으면 헤더에서 가져오는 IP가 실제 클라이언트 IP와 다를 수 있으니 주의해야 해요. 이때 `@vercel/functions`에서 제공하는 함수들이 그런 부분을 깔끔하게 처리해주니까 편리하고요.\n\n또한, 국제화나 지역 기반 맞춤 콘텐츠를 제공하려 할 때 거주지 정보를 이렇게 쉽게 뽑아내면 유용하겠죠? 다만 개인정보보호 관련법도 신경 써서 데이터를 다루어야 하는 점도 잊지 마세요!\n\nNext.js 14 버전 업데이트 사항을 반영해서 프로젝트를 개선해보시면 좋을 것 같습니다. 도움이 되셨길!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n#### ImageResponse 임포트 경로 변경하기\n\n다음 명령어를 입력하면 자동으로 `next/server`에서 `next/og`로 임포트 경로를 바꿔줘요. 이 작업은 동적 OG 이미지 생성(Dynamic OG Image Generation)을 사용할 때 필요해요.\n\n```bash\nnpx @next/codemod@latest next-og-import .\n```\n\n즉, 기존에 이렇게 쓰던 코드를\n\n```js\nimport { ImageResponse } from \"next/server\";\n```\n\n이제 이렇게 바꿔줘야 해요.\n\n```js\nimport { ImageResponse } from \"next/og\";\n```\n\n이 변경 덕분에 Next.js가 최신 OG 이미지 생성 방식을 올바르게 인식해서 동적으로 이미지를 잘 만들어줍니다.  \n자동화 도구(codemod)를 사용하면 수동으로 일일이 바꾸지 않아도 돼서 정말 편하답니다!\n\n혹시 `codemod`가 익숙하지 않거나 처음 들어본 분들은, codemod가 코드베이스 내에 여러 파일을 대상으로 특정 패턴을 찾아 자동으로 변경해 주는 도구라고 생각하면 돼요. Next.js에서는 공식적으로 지원하는 codemod 툴이 많아서 버전 업이나 API 변경 시 활용하기 좋아요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nnext.js에서 Open Graph 이미지 생성을 할 때, `ImageResponse`를 임포트하는 경로가 바뀌었어요. 예전에는 `next/server`에서 가져왔는데, 지금은 `next/og`에서 가져와야 합니다.\n\n```js\nimport { ImageResponse } from \"next/og\";\n```\n\n이렇게 바꾸면 공식 문서와도 맞고, 최신 버전에서 문제없이 작동하죠.\n\n---\n\n### 그리고 추가 팁!\n\nOpen Graph 이미지를 만들 때 `viewport` 관련 설정도 꼭 확인해 주세요. 예를 들어, 이미지 사이즈나 화면 배율을 조절할 수 있는데, 이렇게 하면 다양한 디바이스에서 더 예쁘고 정확하게 표시됩니다.\n\n```js\nexport const runtime = \"edge\"; // edge runtime 권장\n\nexport const viewport = {\n  width: 1200,\n  height: 630,\n};\n```\n\n이렇게 하면 1200x630 크기의 이미지를 생성해서 소셜 미디어에서 표준 크기로 잘 보여져요.\n\n---\n\n### 정리\n\n| 항목                        | 이전(Deprecated) | 현재 사용법                  |\n| --------------------------- | ---------------- | ---------------------------- |\n| `ImageResponse` 임포트 위치 | `next/server`    | `next/og`                    |\n| 뷰포트 설정                 | 없음             | `export const viewport` 사용 |\n\n앞으로 next.js Open Graph 이미지 생성 시, 위 변경 사항 기억하시면 편리하게 작업하실 수 있을 거예요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nJS 개발자 중에 Next.js를 사용하는 분들이라면, `npx @next/codemod@latest metadata-to-viewport-export .` 명령어 한 번쯤 들어봤을 거예요.\n\n이 명령어는 **Next.js 메타데이터에서 특정 뷰포트 설정을 'viewport'라는 별도 export로 분리해 주는 자동 변환 도구(codemod)**예요.\n\n### 왜 필요한가?\n\nNext.js 13, 14 버전 넘어가면서 메타데이터 관리 방식이 조금 바뀌었는데, 뷰포트 설정 같은 경우는 기존에 `metadata` 객체 안에 넣어서 관리하다가 앞으로는 `viewport`라는 export로 분리하는 걸 권장하고 있어요. 이걸 손으로 일일이 바꾸기 귀찮으니까, 자동으로 바꿔주는 게 바로 이 codemod입니다.\n\n### 예시를 보면\n\n기존엔 이렇게 작성했었죠:\n\n```js\nexport const metadata = {\n  title: \"My App\",\n  themeColor: \"dark\",\n  viewport: {\n    width: 1,\n  },\n};\n```\n\n이걸 실행하면, `viewport` 부분을 따로 뽑아서 이렇게 바뀔 거예요:\n\n```js\nexport const metadata = {\n  title: \"My App\",\n  themeColor: \"dark\",\n};\n\nexport const viewport = {\n  width: 1,\n};\n```\n\n### 참고할 점\n\n- codemod는 **프로젝트 루트 폴더나 특정 폴더에 적용할 수 있어요.**\n- 실행 전 꼭 백업하거나 Git 커밋 상태로 만들어두는 걸 권장합니다. 자동 변환 과정에서 혹시 모를 문제를 대비하기 위해서죠.\n- 모든 뷰포트 설정이 변환 대상이니, 변환 후엔 `viewport` export한 걸 `next/head`나 다른 컴포넌트에 제대로 적용하는지 확인해주세요.\n\n이렇게 코드를 자동으로 깔끔하게 바꿔주는 도구 덕분에 개발 속도가 더 빨라지고, 공식 권장 방식에 맞출 수 있답니다! 필요하다면 프로젝트에 맞게 직접 변형도 가능하니까 한 번 꼭 써보세요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래 코드를 보면 React나 Next.js 같은 프레임워크에서 자주 볼 수 있는 `metadata`와 `viewport` 설정을 JavaScript 모듈 형식으로 작성한 예제예요.\n\n```js\nexport const metadata = {\n  title: \"My App\",\n};\n\nexport const viewport = {\n  width: 1,\n  themeColor: \"dark\",\n};\n```\n\n- `metadata` 객체는 페이지의 메타 정보를 담고 있어요. 여기서는 간단하게 타이틀만 'My App'으로 지정했네요.\n- `viewport` 객체는 화면 표시 방식과 관련된 설정인데, 보통 `width` 값으로는 'device-width' 같은 문자열이 들어가지만, 여기선 `1`이라는 숫자가 들어가 있어서 실제 환경에선 조금 더 구체적인 설정이 필요할 것 같아요.\n- `themeColor`를 'dark'로 설정해 어두운 테마임을 지정해주는 부분도 눈에 띄네요.\n\n---\n\n### 13.2\n\n#### 내장 폰트 사용하기 (Use Built-in Font)\n\n이제 내장된 시스템 폰트를 활용해보는 것에 관한 이야기예요. 웹에서 폰트를 사용할 때 구글 폰트 같은 외부 폰트를 불러오는 경우가 많지만, 페이지 로딩 시간이나 성능 최적화를 생각하면 운영체제 기본 폰트를 활용하는 것도 좋은 선택입니다.\n\n예를 들어 CSS에서 이렇게 시스템 폰트를 지정할 수 있어요.\n\n```css\nfont-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Oxygen, Ubuntu, Cantarell, \"Open Sans\",\n  \"Helvetica Neue\", sans-serif;\n```\n\n이렇게 지정하면 iOS, Android, Windows, Linux 등 각 플랫폼에 최적화된 기본 폰트가 자동으로 적용돼서 사용자 경험이 훨씬 자연스러워집니다.\n\nNext.js 13.2 버전부터는 내장 폰트를 쉽게 사용할 수 있도록 공식적으로 지원하는 API가 제공되는데, 이를 활용하면 폰트를 import해서 번거롭게 외부에서 불러오는 과정을 줄일 수 있습니다.\n\n예를 들어, Next.js에서 제공하는 내장 폰트를 사용하려면:\n\n```js\nimport { Roboto } from \"next/font/google\";\n\nconst roboto = Roboto({\n  weight: \"400\",\n  subsets: [\"latin\"],\n});\n\nexport default function MyApp() {\n  return <main className={roboto.className}>{/* 앱 내용 */}</main>;\n}\n```\n\n위처럼 하면 별도의 `link` 태그 없이도 해당 폰트를 프로젝트 내에서 쉽게 적용할 수 있습니다.\n\n하지만 내장 폰트가 아닌 운영체제 기본 폰트를 선택하고 싶으면, 스타일 시트에서 위에 언급한 시스템 폰트 스택을 사용하는 방법이 가장 좋습니다.\n\n---\n\n**덧붙여서!**\n\n- 내장 폰트 사용은 페이지 로딩 속도를 개선하는 데 도움을 줍니다.\n- 외부 폰트는 네트워크 이슈에 취약할 수 있지만, 내장 폰트는 그런 걱정이 적죠.\n- 디자인과 사용자 경험에 맞게 내장 폰트와 외부 폰트를 적절히 섞어 사용하는 전략도 고려해보세요!\n\n필요하면 내가 다음에 폰트 최적화 방법에 대해서도 소개해줄게요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안녕하세요! 오늘은 Next.js 프로젝트에서 `@next/font` 패키지를 내장된 `next/font`로 바꿔주는 Codemod를 한번 살펴볼게요.\n\n요즘 Next.js에서는 폰트 처리를 더 간편하게 하기 위해 `@next/font` 대신 내장된 `next/font`를 사용하도록 권장하고 있어요. 그래서 기존에 `@next/font`를 쓰던 코드들을 새 방식으로 자동 변환해주는 도구가 나왔답니다.\n\n사용 방법은 아주 간단해요! 터미널에서 아래 명령어만 실행하면 돼요.\n\n```bash\nnpx @next/codemod@latest built-in-next-font .\n```\n\n- `npx`를 사용해서 최신 버전의 codemod를 실행하고,\n- `built-in-next-font`라는 변환 스크립트,\n- 그리고 마지막 `.`는 현재 폴더를 뜻합니다. 프로젝트 최상위 폴더에서 돌리면 된다는 거죠.\n\n이 툴의 역할은?\n\n- 자동으로 `@next/font` 패키지를 프로젝트에서 제거하고,\n- 코드 안에서 `@next/font`로부터 임포트한 부분을 내장된 `next/font`로 바꿔줘요.\n\n예를 들어, 기존에 이런 코드가 있었다면:\n\n```js\nimport { Inter } from \"@next/font/google\";\n```\n\nCodemod를 돌리고 나면 이렇게 변해요:\n\n```js\nimport { Inter } from \"next/font/google\";\n```\n\n즉, `@next/font/google` → `next/font/google`로 바뀌는 거죠.\n\n---\n\n### 참고로 알아두면 좋은 점!\n\n- 이 변경은 Next.js 13 이상에서 원활하게 동작합니다. 만약 구버전 쓰신다면 잠깐 버전부터 확인해보시는 게 좋아요.\n- 폰트 관련 설정이 빌트인으로 옮겨지기 때문에 설정 파일도 한번 점검해 주세요.\n- Codemod 실행 전에 꼭 깃 커밋 같은 백업을 해놓는 걸 추천합니다. 혹시 모를 문제 상황에 대비해서요.\n\n---\n\n간편한 코드 변환 도구 덕분에 코드를 하나하나 찾아 바꾸는 번거로움에서 벗어날 수 있으니 꼭 활용해 보시길 바랄게요! 혹시 Next.js에서 폰트 관련 다른 팁이 궁금하면 언제든 알려주세요~\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js 13.0 버전에서 바뀐 점 중 하나는 이미지 관련 import 구문 변경입니다. 예전에는 이미지 관련 모듈을 불러올 때 이름이 조금 다르게 쓰였는데요, 최신 버전에서는 좀 더 명확해졌어요.\n\n예를 들어, 기존에는 이미지 관련 파일이나 컴포넌트를 이렇게 불러왔다면:\n\n```js\nimport Image from \"next/image\";\n```\n\n다른 컨텍스트에서는 구글 폰트 같은 걸 불러올 때 이런 식으로 했잖아요:\n\n```js\nimport { Inter } from \"next/font/google\";\n```\n\n이런 import 구문을 최신 Next.js 13.0에 맞게 변경하는 작업이 필요해요. 특히 이미지 관련 라이브러리나 폰트를 사용할 때 Import 경로나 이름들이 리네이밍되거나 경로가 조금 바뀌는 경우가 있거든요.\n\n혹시 프로젝트를 업그레이드 중이라면, 공식 문서를 꼭 참고해서 변경 사항을 맞춰주시는 걸 추천합니다. 또한, 만약 이미지 컴포넌트를 사용하는 경우, 새 방식에서는 추가적인 최적화 옵션이나 속성들이 생겨서 퍼포먼스가 더 좋아졌답니다.\n\n참고로, 구글 폰트 같은 경우 새롭게 제공되는 `next/font` API를 이용하면 CSS 파일 없이도 폰트를 로딩할 수 있어서 개발자 경험이 훨씬 좋아졌어요!\n\n간단 요약해보면:\n\n| 항목             | 변경 전                                    | 변경 후                                                                          |\n| ---------------- | ------------------------------------------ | -------------------------------------------------------------------------------- |\n| 구글 폰트 Import | `import { Inter } from 'next/font/google'` | 그대로 사용하지만 최신 버전 API 이용                                             |\n| 이미지 Import    | `import Image from 'next/image'`           | `import Image from 'next/image'` (유지) - 다만 사용하는 방식과 옵션은 업데이트됨 |\n\nNext.js 13로 업그레이드할 때 이미지와 폰트 import 관련 내용 꼼꼼히 챙기시면 한결 깔끔하고 최신 기능을 활용할 수 있습니다!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js 13으로 업그레이드하면서 이미지 처리 방식이 조금 바뀌었는데요, 기존에 Next.js 10, 11, 12에서 쓰던 `next/image`를 `next/legacy/image`로 변경해주는 작업이 필요해요. 직접 프로젝트를 수정하기 부담스럽다면, `@next/codemod`라는 도구를 활용하면 자동으로 바꿔줄 수 있답니다.\n\n예를 들어, 아래 명령어를 터미널에 입력하면 프로젝트 내 `next/image` import 코드를 `next/legacy/image`로 바꾸고, `next/future/image`는 `next/image`로 안전하게 변경해줘요.\n\n```bash\nnpx @next/codemod@latest next-image-to-legacy-image .\n```\n\n즉, 이런 코드가\n\n```js\nimport Image1 from \"next/image\";\nimport Image2 from \"next/future/image\";\n\nexport default function Home() {\n  return (\n    <div>\n      <Image1 src=\"/test.jpg\" width=\"200\" height=\"300\" />\n      <Image2 src=\"/test.png\" width=\"500\" height=\"400\" />\n    </div>\n  );\n}\n```\n\n자동으로 이렇게 바뀌는 거죠.\n\n```js\nimport Image1 from \"next/legacy/image\";\nimport Image2 from \"next/image\";\n\nexport default function Home() {\n  return (\n    <div>\n      <Image1 src=\"/test.jpg\" width=\"200\" height=\"300\" />\n      <Image2 src=\"/test.png\" width=\"500\" height=\"400\" />\n    </div>\n  );\n}\n```\n\n---\n\n### 왜 이런 변경이 필요할까요?\n\nNext.js 13부터 이미지 컴포넌트가 크게 개선되면서 새 API가 도입됐어요. 그런데 바로 기존 코드 전부 바꾸기엔 위험 부담이 있어, 기존 `next/image` 기능을 그대로 유지하고 싶으면 `next/legacy/image`를 써야 해요. 따라서 자동 도구를 이용해 한 번에 쉽게 바꾸는 게 편리하답니다.\n\n---\n\n### 참고로 알아두면 좋은 점\n\n- `npx`로 실행하면 별도 설치 없이 최신 버전의 codemod 스크립트를 쓸 수 있어요.\n- 소스코드가 많은 프로젝트라면 백업을 꼭 해두고, 변경 후 빌드와 테스트를 꼼꼼히 확인하세요.\n- codemod 외에도 직접 코드를 리팩토링하며 Next.js 13의 새로운 이미지 기능(`next/image`의 새로운 API)을 학습해보는 것도 좋아요.\n\n---\n\n필요하다면 다음에 Next.js 13의 새로운 이미지 컴포넌트 사용법도 정리해볼게요! 궁금한 점 있으면 언제든 질문해주세요 :)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래처럼 `next/image`를 'next/legacy/image'로 바꾸고, 'next/future/image'는 'next/image'로 바꾸는 예시 코드입니다.\n\n```js\n// 'next/image'는 'next/legacy/image'로 변경합니다\nimport Image1 from \"next/legacy/image\";\n// 'next/future/image'는 'next/image'로 변경합니다\nimport Image2 from \"next/image\";\n\nexport default function Home() {\n  return (\n    <div>\n      <Image1 src=\"/test.jpg\" width=\"200\" height=\"300\" />\n      <Image2 src=\"/test.png\" width=\"500\" height=\"400\" />\n    </div>\n  );\n}\n```\n\n그리고 이 작업을 좀 더 자동화하고 싶다면, Next.js에서 제공하는 코드 변환 도구(codemod)를 이용할 수 있는데요, 터미널에서 다음 커맨드만 실행하면 됩니다.\n\n```bash\nnpx @next/codemod@latest next-image-experimental .\n```\n\n이 명령어는 현재 디렉토리(.) 안의 파일들에 대해 'next/image' 관련 변환을 일괄적으로 적용해 줍니다.\n\n---\n\n**조금 더 팁을 드리자면,** Next.js 13부터 이미지 컴포넌트가 더 발전하면서 기존 방식에서 새로운 방식으로 전환하는 게 권장되고 있어요. 새로운 `next/image`는 향상된 성능과 더 편리한 사용성을 제공하기 때문에 가능하면 자동 변환 도구를 활용해서 마이그레이션을 해보시길 추천해요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서 이미지 컴포넌트를 옛날 방식인 `next/legacy/image`에서 새롭게 개선된 `next/image`로 마이그레이션할 때, 주의할 점들을 정리해볼게요. 단, 여기서 소개하는 방법은 스타일을 인라인으로 덧붙이고 필요 없는 props들은 아예 없애는 방식이라, 사용하면서 조금 더 세밀한 조정이 필요할 수 있다는 점 참고하세요.\n\n---\n\n### 1. `layout` prop 제거 후 `style`로 대체하기\n\n예전에는 `layout`이라는 prop로 이미지 크기와 위치를 조절했다면, 이제는 CSS 스타일을 직접 주는 형태로 바뀌었어요.  \n예를 들어,\n\n```jsx\n// 예전 방식\n<Image src=\"/example.png\" layout=\"fill\" />\n\n// 새로운 방식\n<Image src=\"/example.png\" style={{ width: '100%', height: '100%' }} />\n```\n\n---\n\n### 2. `objectFit` 함수 대체하기\n\n`objectFit`도 이제 스타일로 주는 게 기본이에요.\n\n```jsx\n// 예전 방식\n<Image src=\"/example.png\" objectFit=\"cover\" />\n\n// 새로운 방식\n<Image src=\"/example.png\" style={{ objectFit: 'cover' }} />\n```\n\n---\n\n### 3. `objectPosition`도 `style`로 옮기기\n\n위치 조정도 똑같이 스타일로 바꿔주세요.\n\n```jsx\n// 예전 방식\n<Image src=\"/example.png\" objectPosition=\"center center\" />\n\n// 새로운 방식\n<Image src=\"/example.png\" style={{ objectPosition: 'center center' }} />\n```\n\n---\n\n### 4. `lazyBoundary`와 `lazyRoot` 제거하기\n\n이제 `lazyBoundary`나 `lazyRoot` 프로퍼티는 쓰지 않아요. Next.js가 내부적으로 최적화해주기 때문인데요, 대신 Intersection Observer 같은 커스텀한 지연 로딩이 필요하면 별도로 구현해야 합니다.\n\n---\n\n### 5. Link 컴포넌트에서 `a` 태그 제거하기\n\nNext.js 13부터는 Link 컴포넌트 내부에 `a` 태그를 직접 넣을 필요가 없어졌어요.  \n자동으로 링크 역할을 하도록 개선돼서, 기존 코드에 이런 식으로 중복 `a` 태그가 있다면 정리해주는 코드를 실행해보세요.\n\n```bash\nnpx @next/codemod@latest new-link .\n```\n\n한 번 실행하면 프로젝트 전체에 걸쳐 자동으로 바뀝니다!\n\n---\n\n### 추가 팁!\n\n- **인라인 스타일 대신 CSS 클래스 사용**  \n  인라인 스타일이 너무 많이 들어가면 유지보수가 어렵고, 스타일 수정이 귀찮아질 수 있어요. 가능하면 CSS 모듈이나 styled-components 같은 CSS-in-JS를 활용하기도 해보세요.\n\n- **이미지 최적화 재확인**  \n  마이그레이션 후에는 반드시 이미지로드와 관련된 퍼포먼스, 반응형 처리, 레이지 로딩이 제대로 동작하는지 확인하는 게 좋아요.\n\n- **Next.js 버전 요구사항**  \n  새로운 `next/image` 기능은 Next.js 13 이상의 버전에서 확실히 안정적이니, 버전 업그레이드도 같이 고민해보길 추천해요.\n\n---\n\n마이그레이션은 한 번에 두려울 수 있지만, 잘 따라가면 성능과 유지보수 측면에서 분명 이점이 있으니 꼭 적용해보세요!  \n궁금한 점 있으면 언제든지 알려주세요~ :D\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서 `<Link>` 컴포넌트를 사용할 때, 내부에 `<a>` 태그를 중복으로 감싸는 패턴을 고쳐야 하는 경우가 생겼어요. 예전에는 이렇게 썼었죠:\n\n```jsx\n<Link href=\"/about\">\n  <a>About</a>\n</Link>\n```\n\n그런데 최신 Next.js 버전에서는 `<Link>`가 자동으로 `<a>` 태그 역할을 하니까, 불필요한 `<a>`를 제거해주는 게 좋아요. 위 코드는 이렇게 바뀌게 됩니다:\n\n```jsx\n<Link href=\"/about\">About</Link>\n```\n\n만약 `<a>` 태그에 클릭 이벤트 같은 특별한 핸들러를 달아놨다면? 이렇게 말이죠:\n\n```jsx\n<Link href=\"/about\">\n  <a onClick={() => console.log(\"clicked\")}>About</a>\n</Link>\n```\n\n이 경우에도 `<a>` 태그를 없애고, 대신 `<Link>` 컴포넌트에 이벤트를 옮겨줍니다:\n\n```jsx\n<Link href=\"/about\" onClick={() => console.log(\"clicked\")}>\n  About\n</Link>\n```\n\n근데, 모든 상황에서 자동으로 수정하는 게 안 되는 경우도 있어요. 이럴 때는 `legacyBehavior`라는 속성을 `<Link>`에 붙여주면, 기존 방식으로 동작하게 만들어서 문제없이 앱이 돌아가게 할 수 있습니다.\n\n쉽게 정리해 보면,\n\n| 상황                         | 처리 방법                          |\n| ---------------------------- | ---------------------------------- |\n| 일반적인 링크                | `<a>` 태그 제거 후 텍스트만 남기기 |\n| 이벤트 등 핸들러가 있는 경우 | 핸들러를 `<Link>`로 옮기기         |\n| 자동 수정 불가능한 경우      | `<Link legacyBehavior>` 사용       |\n\n### 추가 팁\n\n- 꼭 `<a>` 태그를 안 써야 좋은 것만은 아니에요! SEO나 스타일링 목적상 `<a>`가 필요한 상황도 있죠. 하지만 Next.js 13 이후로는 내부 `<a>` 없이 바로 `<Link>`만 써도 `<a>` 태그처럼 동작하기 때문에, 코드가 조금 더 깔끔해집니다.\n- 만약 프로젝트에 이미 `<a>`가 안고쳐져 있는 게 많다면 `legacyBehavior`를 우선 써두고, 점차 코드 리팩토링하면서 `<a>` 태그를 제거하는 방식을 추천드려요. 이렇게 하면 급작스러운 에러 없이 마이그레이션 할 수 있으니까요!\n\nNext.js 업데이트나 마이그레이션 할 때 자주 보게 되는 이슈니까, 위 내용 꼭 기억해 두세요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n자, 이번에는 Next.js에서 컴포넌트와 링크 처리 방식에 관한 내용을 살펴볼게요.\n\n```js\nconst Component = () => <a>About</a>\n\n<Link href=\"/about\">\n  <Component />\n</Link>\n// 이렇게 작성한 코드는\n<Link href=\"/about\" legacyBehavior>\n  <Component />\n</Link>\n```\n\n위 코드를 보면 `Link` 컴포넌트 안에 `<a>` 태그를 직접 포함한 `Component`를 넣었을 때, Next.js 13 등 최신 버전에서는 `legacyBehavior` 속성을 추가해줘야 한다고 알려줍니다.\n\n이게 왜 필요하냐면, Next.js가 이전 버전까지는 `Link` 내부에 `<a>` 태그를 감싸는 구조였어요. 그런데 최신 버전에서는 `Link` 자체가 `<a>` 태그 역할을 하도록 변경되었기 때문에, 기존 스타일의 링크를 유지하고 싶으면 `legacyBehavior`를 꼭 명시해줘야 한답니다.\n\n즉, 만약 기존에 `<Link><a>...</a></Link>` 구조를 쓰고 있었다면 그냥 넘어가지 말고, 다음처럼 바꾸는 게 좋겠죠?\n\n```jsx\n<Link href=\"/about\" legacyBehavior>\n  <Component />\n</Link>\n```\n\n이렇게 하면 빌드나 렌더링 시에 발생할 수 있는 문제를 방지할 수 있습니다!\n\n---\n\n### CRA(create-react-app)에서 Next.js로 마이그레이션할 때 참고할 점\n\n이 부분도 아주 유용해요. CRA에서 Next.js로 프로젝트를 옮기고 싶을 때, 직접 하나하나 이전하기는 번거로운데요. Next.js 공식에서 제공하는 codemod 툴을 활용하면 훨씬 수월해집니다.\n\n```bash\nnpx @next/codemod cra-to-next\n```\n\n이 명령어를 실행하면, CRA 스타일의 파일들을 Next.js가 이해하는 형식으로 자동 변환해줘요. 예를 들어, `index.js`를 `pages/index.js`로 옮기거나, 라우팅 관련 코드를 Next.js 스타일로 바꾸는 작업들이 포함됩니다.\n\n참고로, 이 도구는 완벽하지 않기 때문에 변환 후에는 반드시 결과물을 꼼꼼히 확인하고, 특히 커스텀 로직이나 특정 라이브러리 통합 부분은 수동으로 수정해줘야 해요!\n\n---\n\n### 개인적으로 한 마디\n\nNext.js가 계속 발전하면서 내부 구조가 조금씩 달라지고 있어요. 그래서 예전 코드를 최신 버전에 맞추려면 가끔 이런 변화를 이해하고 따라가는 게 중요합니다. 특히 라우팅, 링크 처리, 페이지 구조 등 기본 골격에 관련된 부분은 더더욱 그렇죠.\n\n그리고 마이그레이션은 시간도 많이 들고 까다로운 작업이니, 꼭 핵심 부분부터 단계별로 차근차근 접근해보세요. 항상 작은 단위로 테스트하면서 진행하는 게 실패 확률을 낮출 수 있는 비결입니다!\n\n혹시 이런 과정에서 궁금한 점이나 문제가 생기면, 꼭 커뮤니티나 공식 문서를 참고하고 질문하는 것도 좋은 방법입니다. 개발은 혼자가 아니라 같이 성장하는 과정이니까요. 화이팅! 🎉\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nCreate React App 프로젝트를 Next.js로 마이그레이션하면서, 기존 동작 방식을 유지하기 위해 Pages Router와 필요한 설정을 만들어줍니다. 초기에는 서버 사이드 렌더링(SSR) 시 window 객체 사용으로 인한 호환성 문제를 피하기 위해 클라이언트 사이드 렌더링만 사용하게끔 구현되어 있는데요. 이렇게 하면 Next.js의 고유 기능을 점진적으로 도입하기 쉽죠.\n\n이 과정에서 React import문을 추가하는 작업이 포함되어 있습니다. Next.js에서는 자동으로 React를 임포트하지 않으니, 컴포넌트 내에서 React 관련 내용을 쓸 때는 import문을 꼭 넣어줘야 해요.\n\n만약 이 변환 작업에 대해 의견이나 피드백이 있다면, 이 토론에서 자유롭게 나눠주세요!\n\n추가로, Next.js로 전환 시 `pages` 폴더 구조를 활용하는데, 이는 라우팅이 파일 시스템 기반으로 이루어져 관리가 편하고, 서버 사이드 렌더링, 정적 생성 등 다양한 렌더링 방식을 쉽게 적용할 수 있어요. 그리고 점차적으로 기존 CRA에서 벗어나 Next.js의 SSR, SSG 기능을 사용해 보면서 좀 더 최적화된 앱을 만들어 볼 수 있답니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이번에 소개할 명령어는 Next.js 프로젝트에서 React import 구문이 빠진 파일에 자동으로 import 구문을 추가해주는 `@next/codemod`의 `add-missing-react-import`입니다.\n\n```bash\nnpx @next/codemod add-missing-react-import\n```\n\n이 명령어를 실행하면, React를 import하지 않은 파일에 React import 구문이 추가됩니다. 이유는 최신 React JSX 변환 방식에서 명시적으로 React import가 필요하기 때문인데요, 예를 들어 아래와 같은 클래스 컴포넌트가 있다고 합시다:\n\n```js\nexport default class Home extends React.Component {\n  render() {\n    return <div>Hello World</div>;\n  }\n}\n```\n\n위 코드는 React를 import하지 않았기 때문에 컴파일 에러가 날 수 있어요. 이럴 때 `add-missing-react-import`를 돌리면 자동으로 다음과 같이 변환해줍니다:\n\n```js\nimport React from \"react\";\n\nexport default class Home extends React.Component {\n  render() {\n    return <div>Hello World</div>;\n  }\n}\n```\n\n요즘 Next.js와 React 17 이상의 JSX 변환 로직에서는 React를 import하지 않아도 되는 경우가 많지만, 레거시 코드나 일부 환경에서는 여전히 import 구문이 필요하거든요. 특히 클래스 컴포넌트처럼 React를 직접 참조하는 컴포넌트라면 꼭 import를 해줘야 합니다.\n\n한 가지 팁을 드리자면, `@next/codemod`에는 다른 유용한 코드 변환 도구들도 많으니 프로젝트 마이그레이션이나 정리할 때 사용해보면 좋습니다.\n\n요약하자면:\n\n| 명령어                                       | 설명                                 |\n| -------------------------------------------- | ------------------------------------ |\n| `npx @next/codemod add-missing-react-import` | React import가 없는 파일에 자동 추가 |\n\n이렇게 간단하게 대규모 코드에서 빠진 import를 일괄 처리할 수 있으니 꼭 알아두세요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여러분, 리액트 컴포넌트를 작성할 때 익명 컴포넌트(Anonymous Components)를 이름 있는 컴포넌트(Named Components)로 바꾸는 작업은 꽤 중요한 포인트예요. 코드의 가독성도 좋아지고, 디버깅할 때 스택 트레이스에서 컴포넌트 이름이 잘 보이니까 문제 추적이 훨씬 수월해지거든요.\n\n예를 들어, 아래처럼 익명 함수형 컴포넌트를 쓴다고 해봅시다.\n\n```jsx\nexport default () => <div>Hello World</div>;\n```\n\n이걸 이름 있는 함수형 컴포넌트로 바꿔주면\n\n```jsx\nconst Home = () => <div>Hello World</div>;\nexport default Home;\n```\n\n더 나아가, 클래스 컴포넌트도 익명 클래스를 이름 있는 클래스로 변환하는 게 좋아요. 처음에 주신 코드를 보면:\n\n```jsx\nimport React from \"react\";\n\nexport default class Home extends React.Component {\n  render() {\n    return <div>Hello World</div>;\n  }\n}\n```\n\n지금 이미 이름 있는 클래스 컴포넌트로 잘 작성된 상태죠? 이렇게 하면 나중에 개발자 도구에서도 'Home'이라는 이름이 뜨니까, 문제 생겼을 때 찾기 쉽고 유지보수하기도 편해집니다.\n\n실제로 익명으로 쓰면 이런 장점이 사라지니 꼭 이름 붙이시는 걸 추천드려요.\n\n---\n\n### 익명 컴포넌트 vs 이름 있는 컴포넌트 제일 중요한 차이점\n\n| 구분               | 익명 컴포넌트  | 이름 있는 컴포넌트 |\n| ------------------ | -------------- | ------------------ |\n| 디버깅 편의성      | 낮음           | 높음               |\n| 가독성             | 떨어짐         | 좋음               |\n| 재사용 및 유지보수 | 모호할 수 있음 | 명확함             |\n\n---\n\n마지막 팁 하나 더 드리자면, 컴포넌트를 이름 있게 만들고 `displayName` 속성을 직접 지정해주면 리액트 개발자 도구에서 더 명확한 이름으로 확인할 수 있어요. 함수형 컴포넌트에선 이렇게 하죠:\n\n```jsx\nconst Home = () => <div>Hello World</div>;\nHome.displayName = \"Home\";\nexport default Home;\n```\n\n이제 익명 컴포넌트 쓸 때보다 훨씬 편리하겠죠? 오늘은 이 정도로 정리할게요. 다음에 또 유용한 리액트 팁으로 찾아뵙겠습니다~\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안녕하세요! 오늘은 Next.js 9버전 이상부터 사용할 수 있는 아주 유용한 명령어에 대해 이야기해볼게요.\n\n```bash\nnpx @next/codemod name-default-component\n```\n\n이 명령어는 여러분이 작성한 익명(anonymous) 컴포넌트를 '이름 있는(named)' 컴포넌트로 자동 변환해줘요.\n\n왜 이게 중요하냐면?  \nNext.js 9부터 도입된 **Fast Refresh** 기능이 익명 컴포넌트와 잘 작동하지 않는 경우가 있거든요. Fast Refresh는 여러분이 코드를 수정했을 때 빠르게 변경 사항을 브라우저에 반영해주는 기능이에요. 만약 컴포넌트가 익명이면 이 기능이 제대로 동작하지 않을 수 있어요.\n\n그래서 이 codemod를 실행하면 모든 익명 컴포넌트들을 이름 있는 컴포넌트로 바꿔줘서 Fast Refresh가 안정적으로 작동하게 도와줍니다.\n\n### 간단한 예시\n\n```jsx\n// 변환 전 (익명 컴포넌트)\nexport default () => <div>Hello World</div>;\n\n// 변환 후 (이름 있는 컴포넌트)\nconst MyComponent = () => <div>Hello World</div>;\nexport default MyComponent;\n```\n\n이렇게 이름 붙여주면 어떤 컴포넌트인지 더 명확해지고, 디버깅도 조금 더 편해집니다.\n\n---\n\n### 추가 팁!\n\n- **Fast Refresh**를 제대로 활용하려면 JSX 코드가 명확한 컴포넌트 정의 방식을 따르는 게 좋아요.\n- 익명 함수 대신 꼭 이름이 있는 함수나 변수로 컴포넌트를 작성하는 습관을 들이면, 코드 관리가 더 수월해집니다.\n- 만약 여러분 프로젝트에 익명 컴포넌트가 많다면 위 codemod 실행 한번 해보세요. 자동으로 변환해줘서 시간을 많이 절약할 수 있습니다.\n\n오늘은 여기까지입니다! 다음에도 개발 관련 꿀팁 들고 올게요~ 😄\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nexport default function MyComponent() {\n  return <div>Hello World</div>;\n}\n```\n\n위 코드는 파일 이름을 참고해 컴포넌트 이름을 카멜케이스(camelCase) 형식으로 자동으로 붙여주는 변환 예시입니다. 함수형 컴포넌트에 이름이 없으면, React 개발 도구나 디버깅 시 컴포넌트 이름을 바로 확인하기 어렵기 때문에 이런 변환을 해주는 게 좋아요.\n\n또한, 이 방법은 화살표 함수(Arrow Function) 컴포넌트에도 동일하게 적용됩니다. 예를 들어:\n\n```js\nconst MyComponent = () => {\n  return <div>Hello World</div>;\n};\nexport default MyComponent;\n```\n\n위처럼 작성하면 함수 이름이 명확해져서 컴포넌트 관리가 훨씬 편해집니다. 혹시 파일명이 `my-component.jsx`라면, 보통 `MyComponent`처럼 변환하면 되고, 이런 자동화는 빌드 도구(예: Babel plugin)나 에디터 확장 기능을 통해 쉽게 할 수 있어요.\n\n요약하자면,\n\n- 무명 함수형 컴포넌트는 디버깅 시 불편하니 꼭 이름을 붙여주세요.\n- 이름은 파일 이름을 참고해서 카멜케이스로 자동 변환하는 게 일반적입니다.\n- 화살표 함수 컴포넌트에도 적용 가능해서 일관된 네이밍이 가능합니다.\n\n이렇게 하면 코드 품질과 유지보수성이 한층 좋아지니 꼭 기억해두세요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 8\n\n#### AMP HOC를 페이지 설정으로 변환하기\n\nNext.js에서 AMP 페이지를 만들 때 `withAmp` HOC(high-order component)를 사용하는 경우가 있는데요. Next.js 9부터는 이 방법 대신 페이지 설정을 통해 AMP를 지정할 수 있도록 업데이트되었어요.\n\n간단하게 커맨드 한 줄로 기존에 `withAmp`를 쓰던 코드를 페이지 설정으로 변환할 수 있습니다.\n\n```bash\nnpx @next/codemod withamp-to-config\n```\n\n이 명령어를 실행하면 자동으로 `withAmp` HOC를 제거하고 대신 `export const config = { amp: true }` 같은 페이지 설정으로 변환해 줍니다.\n\n---\n\n> 참고!  \n> AMP 페이지를 이렇게 설정하면 유지보수도 편해지고, 코드가 더 깔끔해져 장기적으로 좋습니다.  \n> 그리고 다음 Next.js 버전에서는 `withAmp` 지원이 줄어들 수 있으니 미리 적용해 두면 좋아요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 예시는 Next.js에서 AMP (Accelerated Mobile Pages) 페이지를 만드는 방식이 업데이트된 것을 보여주고 있어요.\n\n예전에는 `withAmp`라는 HOC(Higher-Order Component)를 사용해서 AMP 페이지를 만들었는데요, 이제는 이 방법을 대체하는 새로운 문법이 도입되었답니다.\n\n기존 코드는 이렇게 생겼었죠:\n\n```js\n// Before\nimport { withAmp } from \"next/amp\";\n\nfunction Home() {\n  return <h1>My AMP Page</h1>;\n}\n\nexport default withAmp(Home);\n```\n\n`withAmp`로 컴포넌트를 감싸 AMP 페이지임을 표시했어요.\n\n하지만 최신 Next.js 버전에서는 `withAmp` 대신에 함수형 컴포넌트 자체를 export하고, 별도로 `config` 객체에서 `amp: true` 설정을 해주면 됩니다:\n\n```js\n// After\nexport default function Home() {\n  return <h1>My AMP Page</h1>;\n}\n\nexport const config = {\n  amp: true,\n};\n```\n\n이렇게 바뀌면서 코드가 훨씬 깔끔해졌고, Next.js가 AMP 페이지를 더 명확하고 쉽게 인식할 수 있게 되었어요.\n\n---\n\n### AMP 페이지 만드는 법 간단 요약\n\n| 예전 방식 (before)                   | 최신 방식 (after)                          |\n| ------------------------------------ | ------------------------------------------ |\n| `import { withAmp } from 'next/amp'` | `export const config = { amp: true }` 선언 |\n| `export default withAmp(Component)`  | `export default function Component() {}`   |\n\n---\n\n### 덧붙여서\n\n- AMP 페이지는 모바일 최적화와 빠른 로딩을 위한 기술인데, Next.js는 AMP 페이지를 따로 지원해줘서 개발자들이 쉽게 구현할 수 있어요.\n- 다만 AMP에서는 자바스크립트 사용이 제한적이고, 일부 컴포넌트 사용이 제약되니 해당 부분도 확인해 주세요.\n- Next.js의 AMP 관련 설정은 점점 개선되는 추세라 업데이트된 공식 문서도 자주 확인하는 게 좋아요!\n\n그럼 오늘도 즐거운 코딩 하세요! 🚀\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n#### withRouter 사용하기\n\nNext.js에서 예전에는 페이지 컴포넌트에 자동으로 `url`이라는 프로퍼티가 주어졌었는데, 이게 이제는 deprecated(더 이상 권장되지 않는) 되었어요. 대신 `withRouter`라는 HOC(Higher-Order Component)를 사용해서 `router`라는 프로퍼티를 직접 주입받도록 바뀌었답니다.\n\n만약 기존 코드에 `url` 프로퍼티를 쓰고 있다면, 다음 명령어 한 방으로 자동 변환도 가능해요.\n\n```bash\nnpx @next/codemod url-to-withrouter\n```\n\n이 코맨드는 페이지 컴포넌트에서 `url`을 사용하는 코드를 찾아서 `withRouter`를 씌우고, `router` 프로퍼티를 받도록 바꿔줘요.\n\n이제 간단히 예를 들어볼게요!\n\n```js\n// Before (deprecated)\nfunction Page({ url }) {\n  return <div>Current path: {url.pathname}</div>;\n}\n\nexport default Page;\n```\n\n```js\n// After (withRouter 사용)\nimport { withRouter } from \"next/router\";\n\nfunction Page({ router }) {\n  return <div>Current path: {router.pathname}</div>;\n}\n\nexport default withRouter(Page);\n```\n\n`withRouter`를 쓰면 `router` 안에 현재 경로, 쿼리, asPath 등 다양한 라우팅 정보를 손쉽게 가져올 수 있어 활용도가 높답니다.\n\n자세한 내용은 Next.js 공식 문서에서 확인해봐요:  \nhttps://nextjs.org/docs/messages/url-deprecated\n\n그리고 만약 함수형 컴포넌트에서 훅을 선호한다면, Next.js가 제공하는 `useRouter` 훅도 같이 알아두시면 좋아요!\n\n```js\nimport { useRouter } from \"next/router\";\n\nfunction Page() {\n  const router = useRouter();\n\n  return <div>Current path: {router.pathname}</div>;\n}\n\nexport default Page;\n```\n\n`withRouter` 대신 `useRouter`를 쓰면 훨씬 깔끔하고 현대적인 코드 작성이 가능하니, 새 프로젝트나 리팩토링 시 참고하세요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이번에 React와 Next.js에서 라우팅 정보를 가져오는 방식을 비교해봤어요. 두 코드 예시 모두 현재 URL 경로(pathname)를 화면에 보여주는 간단한 컴포넌트인데, Next.js가 버전 업데이트하면서 props로 라우터 정보를 직접 주던 방식에서 HOC인 withRouter를 사용하는 방식으로 바뀐 걸 볼 수 있죠.\n\n### 첫 번째 코드\n\n```jsx\nimport React from \"react\";\n\nexport default class extends React.Component {\n  render() {\n    const { pathname } = this.props.url;\n    return <div>Current pathname: {pathname}</div>;\n  }\n}\n```\n\n이 코드는 Next.js 6 이하 버전에서 주로 쓰이던 방식이에요. `this.props.url`에서 pathname을 바로 받아서 사용하고 있죠.\n\n### 두 번째 코드\n\n```jsx\nimport React from \"react\";\nimport { withRouter } from \"next/router\";\n\nexport default withRouter(\n  class extends React.Component {\n    render() {\n      const { pathname } = this.props.router;\n      return <div>Current pathname: {pathname}</div>;\n    }\n  }\n);\n```\n\n이건 Next.js 7 이상에서 권장하는 방식으로, `withRouter`라는 고차 컴포넌트를 이용해서 `this.props.router` 안에 라우터 정보를 넣어줘요. 덕분에 함수형 컴포넌트에서도 `useRouter` 훅과 마찬가지로 쉽게 라우터 데이터를 접근할 수 있게 되었습니다.\n\n---\n\n사실 최신 Next.js 프로젝트를 한다면 함수형 컴포넌트와 `useRouter` 훅을 쓰는 걸 추천해요. 예를 들면 이렇게요:\n\n```jsx\nimport { useRouter } from \"next/router\";\n\nexport default function MyComponent() {\n  const router = useRouter();\n  return <div>Current pathname: {router.pathname}</div>;\n}\n```\n\n이렇게 하면 코드도 훨씬 간결해지고, React의 함수형 컴포넌트 철학에도 잘 맞거든요.\n\n---\n\n이 외에도 여러 사례들이 `__testfixtures__`라는 디렉토리에 모여 있다고 하니, Next.js 라우팅 관련 코드를 바꾸거나 참고할 때 아주 좋은 자료가 될 거예요. 저도 이런 예시들을 직접 보면서 공부했답니다.\n\n필요하면 저도 `__testfixtures__` 디렉토리에서 참고한 내용들 중심으로 더 설명해 드릴게요!\n","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":43},{"title":"Next.js 15로 싱글 페이지 애플리케이션(SPA) 쉽게 만드는 방법","description":"","date":"2025-04-22 01:38","slug":"2025-04-22-Howtobuildsingle-pageapplicationswithNextjs","content":"\n\n# Next.js로 싱글 페이지 애플리케이션(SPA) 만들기\n\nNext.js는 싱글 페이지 애플리케이션(SPA) 구축을 완벽하게 지원해요.\n\n빠른 라우트 전환을 위한 사전 페칭(prefetching), 클라이언트 쪽 데이터 가져오기, 브라우저 API 활용하기, 타사 클라이언트 라이브러리 연동, 정적 라우트 생성 등 다양한 기능이 다 포함되어 있죠.\n\n만약 이미 SPA를 가지고 있다면, Next.js로 마이그레이션할 때 코드에 큰 변화를 줄 필요 없이 진행할 수 있어요. 그리고 필요에 따라 서버 기능을 점진적으로 추가해 나갈 수 있다는 점도 큰 장점입니다.\n\n추가로, Next.js는 기본적으로 페이지 기반 라우팅 시스템을 제공해서, 라우트 관리를 훨씬 간편하게 할 수 있어요. React를 잘 다뤄왔다면 Next.js로 넘어오는 과정도 아주 자연스럽게 느껴질 거예요.\n\nSPA를 만들 때 자주 고민하는 SEO 문제도 Next.js가 서버 사이드 렌더링(SSR)이나 정적 사이트 생성(SSG)을 지원하기 때문에 훨씬 수월하게 해결할 수 있답니다. 그래서 성능과 UX, SEO 모두 신경 써야 하는 프로젝트에 정말 적합하죠!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## SPA(싱글 페이지 애플리케이션)이란?\n\n사실 SPA의 정의는 사람마다 조금씩 달라요. 여기서는 “엄격한 SPA” 기준으로 설명해볼게요.\n\n- **클라이언트 사이드 렌더링(CSR)**: 앱이 한 개의 HTML 파일(보통 index.html)로 제공돼요. 다른 페이지로 이동하거나, 화면 전환, 데이터 요청 등 모든 것이 브라우저 안에서 자바스크립트가 처리해요.\n- **전체 페이지 새로고침 없음**: 새로운 페이지를 서버에서 받아오는 대신, 현재 페이지의 DOM(문서 구조)를 자바스크립트가 바꿔주고, 필요한 데이터만 따로 받아와서 화면에 보여줘요.\n\n즉, SPA는 한 번 페이지가 로드되면, 이후에는 전체 페이지 리로드 없이 화면이 바뀌는 웹 앱이라고 보면 돼요.\n\n---\n\n### 그런데 왜 엄격한 SPA는 어려울까?\n\nSPA는 로딩 초반에 많은 자바스크립트를 한꺼번에 내려받아야 해서, 페이지가 제대로 인터랙티브해지기까지 시간이 걸릴 수 있어요. 그리고 클라이언트에서 데이터를 요청하는 순서, 즉 데이터 ‘워터폴’ 문제도 발생할 수 있는데, 이게 길어지면 사용자 경험이 좋지 않을 수 있죠.\n\n이런 문제들을 개선하고 싶다면 Next.js 같은 프레임워크를 써보는 걸 추천해요. Next.js는 서버 사이드 렌더링(SSR)과 CSR을 적절히 섞어서 빠르고 효율적인 웹 앱 개발을 도와주거든요.\n\n---\n\n참고로, 요즘은 SSR, CSR, 그리고 정적 사이트 생성(SSG)까지 적절히 활용하며 사용자 경험과 SEO를 모두 챙기려는 시도가 많아지고 있어요. SPA라고 무조건 자바스크립트만 쓰는 게 아니라는 점도 꼭 기억하세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 왜 Next.js를 사용해서 SPA를 만들까?\n\nNext.js는 여러분이 작성한 JavaScript 코드를 자동으로 쪼개서(bundle splitting) 각각의 라우트마다 필요한 코드만 불러올 수 있게 해줘요. 덕분에 클라이언트 쪽에서는 쓸데없는 자바스크립트 코드를 안 불러와서 번들 크기도 줄고, 페이지 로딩 속도도 훨씬 빨라집니다.\n\n또, Next.js의 `next/link` 컴포넌트는 라우트를 미리 불러오는(prefetch) 기능을 갖고 있어서, 딱딱 끊기지 않는 부드러운 SPA의 빠른 페이지 전환을 경험할 수 있어요. 그뿐만 아니라 URL이 앱의 상태를 계속 담고 있어서, 공유하거나 북마크하기도 편해지죠.\n\n흥미로운 점은, Next.js는 처음부터 정적인 사이트로 시작할 수도 있고, 아무 서버 기능 없이 클라이언트 사이드에서만 렌더링되는 순수 SPA로도 사용할 수 있다는 거예요. 그런데 프로젝트가 점점 커지고 기능이 복잡해지면, 필요한 만큼만 서버 기능(예를 들어 React Server Components나 Server Actions 같은)을 점진적으로 도입할 수도 있어서 유연하답니다.\n\n---\n\n### 한눈에 보는 Next.js의 SPA 장점\n\n| 장점                   | 설명                                                                                 |\n|----------------------|------------------------------------------------------------------------------------|\n| 자동 코드 분할           | 각 페이지별로 필요한 자바스크립트만 로딩해서 번들 크기를 줄이고, 로딩 속도를 높임                     |\n| 라우트 프리패칭          | `next/link`가 미리 라우트를 불러와서 페이지 전환이 빠르고 부드러움                                   |\n| URL 기반 상태 유지       | SPA처럼 빠르면서도 URL에 상태가 포함되어 공유와 북마크가 쉬움                                         |\n| 유연한 서버 렌더링 지원    | 초기엔 정적 사이트나 클라이언트 렌더링 SPA로 시작 가능, 필요하면 점진적으로 서버 기능 추가 가능                |\n\n---\n\n간단히 말해, Next.js는 SPA의 좋은 점과 SSR(server-side rendering)의 장점을 절묘하게 섞어놨어요. 그래서 좀 더 규모가 큰 프로젝트에서 SPA를 관리하기에 훨씬 편하답니다. \n\n이런 장점 덕분에 요즘 많은 개발자들이 Next.js를 선택해 SPAs를 만들고 있어요! 혹시 Next.js로 SPA를 고민하고 있다면, 꼭 한번 써보라고 추천드리고 싶네요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 예시\n\n이번에는 SPA(싱글 페이지 애플리케이션)를 만들 때 자주 사용되는 패턴들을 살펴보고, Next.js가 이 문제들을 어떻게 해결하는지 함께 알아보도록 할게요.\n\n### React의 use 훅을 Context Provider 내에서 사용하기\n\n저희는 데이터를 가져올 때 보통 상위 컴포넌트(또는 레이아웃)에서 데이터를 불러오고, 그 결과로 Promise를 반환한 뒤, 하위 클라이언트 컴포넌트에서 React의 use 훅으로 그 값을 해제하는 방식을 추천해요.\n\n이 방법이 좋은 이유는, 데이터를 한 곳에서 통합 관리할 수 있고 컴포넌트 간에 쉽게 공유가 가능해진다는 점이에요. 또한 Next.js가 제공하는 서버 컴포넌트와 클라이언트 컴포넌트의 장점을 살릴 수 있어서 성능 최적화에도 도움이 된답니다.\n\n여기서 중요한 점은, 서버에서 데이터를 미리 불러오고 그 상태를 클라이언트에서 재사용할 수 있게 하는 흐름 덕분에 불필요한 중복 요청을 줄일 수 있고, 사용자 경험이 자연스럽게 개선된다는 것! 다음에 실제 예제도 함께 볼게요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js는 서버에서 데이터를 미리 가져오는 작업을 빨리 시작할 수 있어요. 예를 들어, 이걸 루트 레이아웃(root layout)에서 한다고 생각해보면, 애플리케이션의 시작점에서 서버가 곧바로 클라이언트에게 응답을 스트리밍할 수 있다는 뜻이죠.\n\n여기서 “데이터 fetching을 루트 레이아웃으로 끌어올린다(hoisting)”는 말은, Next.js가 앱 내 다른 어떤 컴포넌트보다 먼저 서버에서 데이터를 요청하게 만든다는 의미예요. 덕분에 클라이언트에서 서버로 여러 번 왕복하는 ‘워터폴 문제’를 없애고, 네트워크 호출도 줄여주죠. 또, 서버가 보통 데이터베이스와 가까운 위치에 있기에 성능 향상에도 큰 도움이 됩니다.\n\n예를 들어, 다음과 같이 루트 레이아웃에서 getUser() 함수를 호출하지만, await 하지 않고 바로 Promise를 넘겨줄 수 있어요.\n\n```jsx\nimport { UserProvider } from './user-provider'\nimport { getUser } from './user' // 서버 사이드 함수\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  let userPromise = getUser() // 여기서 await 하지 않아요\n\n  return (\n    <html lang=\"en\">\n      <body>\n        <UserProvider userPromise={userPromise}>{children}</UserProvider>\n      </body>\n    </html>\n  )\n}\n```\n\n이렇게 하면 UserProvider 같은 하위 컴포넌트에서 Promise를 필요할 때까지 기다렸다가 데이터를 가져올 수 있죠. 이 패턴 덕분에 서버는 상황에 맞게 데이터를 빠르고 효율적으로 준비할 수 있어요.\n\n> 참고로, Next.js 13부터 도입된 이 ‘룻트 레이아웃에서 데이터 fetching 미리 시작’ 방식은 React의 Suspense와도 잘 맞아서, 사용자 경험 개선에 큰 도움이 됩니다. 실제로 서버와 클라이언트의 역할을 명확히 분리하고, 렌더링 대기 프로세스도 자연스럽게 최적화해준답니다.\n\n혹시 데이터 fetching 타이밍이나 React Suspense에 대해 더 궁금하면 알려주세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n리액트에서 Promise를 클라이언트 컴포넌트에 prop으로 넘겨주는 패턴이 있어요. 특히, React context provider와 함께 사용하면 더 편리해지는데요. 이렇게 하면 커스텀 훅을 통해 클라이언트 컴포넌트 어디서든 쉽게 Promise에 접근할 수 있거든요.\n\n예를 들어, User 정보를 담고 있는 Promise를 React context provider에 전달하는 코드를 한번 볼게요:\n\n```jsx\n'use client';\n\nimport { createContext, useContext, ReactNode } from 'react';\n\ntype User = any;\ntype UserContextType = {\n  userPromise: Promise<User | null>;\n};\n\nconst UserContext = createContext<UserContextType | null>(null);\n\nexport function useUser(): UserContextType {\n  const context = useContext(UserContext);\n  if (!context) {\n    throw new Error('useUser는 UserProvider 안에서만 사용해야 합니다.');\n  }\n  return context;\n}\n\nexport function UserProvider({\n  children,\n  userPromise\n}: {\n  children: ReactNode;\n  userPromise: Promise<User | null>;\n}) {\n  return (\n    <UserContext.Provider value={{ userPromise }}>\n      {children}\n    </UserContext.Provider>\n  );\n}\n```\n\n조금 더 설명을 덧붙이자면, UserProvider 컴포넌트는 userPromise를 받아서 context에 세팅해주고, useUser라는 커스텀 훅으로 이 Promise를 쉽게 사용할 수 있도록 도와줘요.\n\n마지막으로 클라이언트 컴포넌트 내에서 useUser 훅을 호출한 다음 Promise를 풀어내는 방식은 이렇습니다:\n\n```jsx\n'use client';\n\nimport { useEffect, useState } from 'react';\nimport { useUser } from './UserProvider';\n\nexport default function UserProfile() {\n  const { userPromise } = useUser();\n  const [user, setUser] = useState(null);\n\n  useEffect(() => {\n    userPromise.then(setUser);\n  }, [userPromise]);\n\n  if (!user) return <div>로딩 중...</div>;\n\n  return <div>안녕하세요, {user.name}님!</div>;\n}\n```\n\n여기서 핵심은, context를 통해 Promise를 전달받고 클라이언트 컴포넌트가 그 Promise를 풀어서 사용자 데이터를 받아온다는 점이에요. 이렇게 하면 데이터 fetching과 상태 관리가 깔끔하게 분리되면서 유지보수도 수월해집니다.\n\n추가 팁을 드리자면, 이 패턴은 서버에서 데이터를 미리 준비해서 클라이언트로 넘길 때도 유용해요. Next.js 같은 프레임워크에서 서버 컴포넌트가 데이터를 fetch하고 Promise를 클라이언트 컴포넌트로 넘기는 구조에 잘 어울립니다. 그러면 클라이언트에서는 loading 상태 관리나 데이터 fetching 코드를 간단히 처리할 수 있죠.\n\n요약하자면:\n\n| 장점 | 설명 |\n| --- | --- |\n| Context + Promise | 여러 컴포넌트에서 같은 Promise 접근 가능 |\n| 커스텀 훅 활용 | 사용하기 편하고, 오류 관리도 쉬움 |\n| 클라이언트 상태 관리 | Promise 풀어서 상태로 관리 가능 |\n| 서버 - 클라이언트 연동 | 서버에서 데이터 준비 → 클라이언트에서 깔끔하게 소비 |\n\n이 패턴을 프로젝트에 적용해보시면 데이터 흐름이 훨씬 명확해지는 걸 느끼실 거예요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여러분, 리액트에서 비동기 데이터를 다룰 때 `use` 훅을 사용해보셨나요? 예를 들어, 위 코드처럼 `userPromise`를 `use(userPromise)`로 바로 받아서 사용할 수 있는데요, 이렇게 하면 컴포넌트가 데이터를 받을 때까지 ‘서스펜스(suspense)’ 상태가 됩니다.\n\n이게 무슨 말이냐면, 리액트가 아직 데이터가 준비되지 않았을 때는 화면 일부를 잠시 렌더링하지 않고 기다렸다가, 데이터가 준비되면 그 부분만 다시 렌더링하는 ‘부분 하이드레이션(partial hydration)’을 할 수 있다는 거예요. 덕분에 페이지가 완전히 로드되기 전이라도 서버에서 미리 스트리밍한 HTML을 받아서 빠르게 화면을 보여주고, 나중에 자바스크립트가 로드되면 필요한 부분만 채워 넣는 거죠.\n\n---\n\n### SWR과 함께하는 SPA 데이터 패칭\n\n그리고 한편으론, SPA 환경에서 데이터를 불러오는 작업이 자주 필요하죠? 여기서 SWR이라는 React 라이브러리가 정말 많이 쓰입니다. SWR은 ‘stale-while-revalidate’의 약자로, 데이터를 캐시해두고 백그라운드에서 재검증하는 방식을 채택해 사용자 경험을 극대화해요.\n\n예를 들어, 여러분이 어떤 API를 호출해 데이터를 받으면, SWR은 기존 데이터를 먼저 보여주면서 동시에 최신 데이터를 받아 업데이트를 시도합니다. 이렇게 하면 화면이 번쩍이는 걸 막고, 항상 최신 데이터도 유지할 수 있죠. React의 최신 기능인 ‘서스펜스’와도 잘 어울려서, 점점 더 자연스럽게 비동기 데이터를 처리할 수 있게 되었습니다.\n\n---\n\n간단 정리하자면:\n\n| 기능              | 설명                                                      |\n|-------------------|---------------------------------------------------------|\n| `use` 훅           | Promise를 바로 받아서 처리, 컴포넌트 서스펜스 상태 관리          |\n| 부분 하이드레이션   | 서버에서 미리 렌더링한 HTML을 보여주고, 필요한 부분만 자바스크립트로 채우기 |\n| SWR               | 데이터 캐싱 & 백그라운드 갱신으로 빠르고 최신 데이터 제공             |\n\n앞으로 리액트에서 비동기와 데이터 페칭을 어떻게 효과적으로 다룰지 고민할 때, 이렇게 `use` 훅과 SWR 같은 도구들을 잘 활용하면 한결 수월해질 거예요! 궁금한 점 있으면 언제든 댓글로 알려주세요. :)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nSWR 2.3.0과 React 19+를 사용하면, 기존에 클라이언트에서 SWR로 데이터를 가져오던 코드를 점진적으로 서버 기능과 함께 사용해볼 수 있어요. 쉽게 말해, 위에서 말한 use() 패턴을 추상화한 거라고 보면 됩니다. 즉, 데이터 패칭을 클라이언트 쪽에서 하기도 하고 서버 쪽에서 하기도 하거나, 둘 다 섞어서 사용할 수 있다는 거죠!\n\n예를 들어,\n\n- 클라이언트 전용: `useSWR(key, fetcher)`  \n- 서버 전용: `useSWR(key)` + RSC(React Server Components)에서 제공하는 데이터  \n- 혼합 사용: `useSWR(key, fetcher)` + RSC 데이터  \n\n이렇게 다양하게 활용할 수 있습니다.\n\n실제 예제를 보면, 애플리케이션의 최상위 컴포넌트를 `SWRConfig` 컴포넌트로 감싸고 `fallback` 값을 넣어 서버에서 미리 데이터를 준비해두게 할 수 있어요.\n\n```jsx\nimport { SWRConfig } from 'swr'\nimport { getUser } from './user' // 서버 사이드 함수 예시\n\nexport default function RootLayout({ children }) {\n  return (\n    <SWRConfig\n      value={{\n        fallback: {\n          // 여기서 getUser() 결과를 바로 넘기는데,\n          // getUser()를 await 하지 않고 Promise 상태로 넘겨요.\n          // 그래야 실제로 이 데이터를 쓰는 컴포넌트가 렌더링될 때 suspend 하면서 데이터를 기다림\n          '/api/user': getUser(),\n        },\n      }}\n    >\n      {children}\n    </SWRConfig>\n  )\n}\n```\n\n여기서 중요한 포인트는 `getUser()`를 호출할 때 `await`를 하지 않는다는 점인데요. 이렇게 하면 컴포넌트에서 `useSWR('/api/user')`를 호출할 때, 서버에서 이미 준비된 Promise를 그대로 사용하게 되고, 해당 데이터가 준비될 때까지 React가 자동으로 대기(suspend)를 해줘요. 이게 React 19의 서버 컴포넌트와 SWR이 연동되는 굉장히 직관적이고 효율적인 방식입니다.\n\n---\n\n### SWR 2.3.0 & React 19+ 사용하는 팁!\n\n- 이 방식을 쓰면 서버 사이드 데이터 페칭과 클라이언트 사이드 리페칭을 자연스럽게 혼합 가능  \n- 클라이언트 캐시를 미리 서버에서 채우고 싶을 때 유용  \n- 서버 컴포넌트와 클라이언트 컴포넌트 혼합 환경에서 데이터 일관성 유지가 쉬워짐  \n- 성능 최적화에 큰 도움이 되며, 전체 페이지 로딩 UX 개선 가능!\n\n만약 SWR을 쓰고 있고 앞으로 React 19+ 서버 컴포넌트를 시도해보고 싶다면, 이번 버전부터 좀 더 매끄럽게 데이터 관리를 할 수 있으니 꼭 한번 시도해보세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n자, 이번에는 서버 컴포넌트와 클라이언트 컴포넌트 간에 데이터를 주고받을 때 SWR을 어떻게 깔끔하게 쓸 수 있는지 이야기해볼게요.\n\n---\n\n### 서버 컴포넌트에서 getUser() 함수 사용하기\n\n서버 컴포넌트에서는 `getUser()` 같은 함수를 이용해서 **쿠키, 헤더, DB 접근** 등을 안전하게 할 수 있어요. 이 말은 별도의 API 라우트를 만들 필요가 없다는 뜻이죠!\n\n즉, 서버에서 이미 사용자 데이터를 가져와서 그걸 클라이언트 컴포넌트에 바로 전달해줄 수 있다는 거예요.\n\n---\n\n### 클라이언트 컴포넌트에서 SWR로 데이터 재사용하기\n\n클라이언트 컴포넌트는 `SWRConfig` 하위에서 `useSWR()`을 호출할 때 이전에 서버에서 미리 받아온 사용자 데이터를 **fallback**으로 사용할 수 있어요. 이때 SWR를 쓰는 코드는 이전과 똑같이 쓸 수 있답니다.\n\n```js\n'use client'\n\nimport useSWR from 'swr'\n\nexport function Profile() {\n  const fetcher = (url) => fetch(url).then((res) => res.json())\n  // 기존에 쓰던 SWR 코드 그대로!\n  const { data, error } = useSWR('/api/user', fetcher)\n\n  return (\n    <div>\n      {error && <p>사용자 데이터를 불러오지 못했어요.</p>}\n      {!data ? <p>로딩중...</p> : <p>안녕하세요, {data.name}님!</p>}\n    </div>\n  )\n}\n```\n\n---\n\n### 미리 렌더링 된 fallback 데이터의 장점\n\n- 서버에서 데이터를 미리 받아서 **초기 HTML에 포함**시키기 때문에 화면이 빠르게 뜨고, SEO에도 유리해요.\n- 클라이언트에서 `useSWR`가 바로 이 fallback 데이터를 읽어서 재사용하고,\n- SWR의 **폴링, 재검증, 캐싱 기능**은 클라이언트 측에서 계속 잘 동작해 SPA 같은 인터랙티브한 경험을 제공해줘요.\n\n---\n\n### 번거로운 조건문은 이제 그만!\n\n이전에는 데이터를 가져오는 상태에 따라 `data === undefined`인지 체크하고 로딩 UI를 따로 처리해야 했지만, Next.js가 이제는 이런 fallback 데이터를 자동으로 관리해줘서 그런 조건문을 지워도 돼요.\n\n- 데이터가 로드되는 동안에는 가장 가까운 `Suspense` 경계가 알아서 작동해서 로딩 상태를 처리해주고,\n- 개발자는 UI 로직에만 집중할 수 있죠.\n\n---\n\n### 요약 정리\n\n| 항목                         | 설명                                                            |\n|----------------------------|---------------------------------------------------------------|\n| 서버 컴포넌트의 getUser() | 서버에서 안전하게 사용자 데이터를 가져와 바로 컴포넌트에 사용할 수 있음       |\n| 클라이언트 컴포넌트의 SWR | 서버에서 받은 데이터를 fallback으로 사용해 동일한 키로 데이터 재활용 가능      |\n| 초기 fallback 데이터         | 서버에서 미리 받아와 HTML에 포함 → 클라이언트가 즉시 활용, SEO & UX 모두 좋아짐 |\n| 개발 편의성                  | 데이터 undefined 체크 등 복잡한 로딩 처리 코드가 필요없음                    |\n\n---\n\n### 마지막 팁!\n\n몇 가지 참고하면 좋은 점들!\n\n- `SWRConfig`로 글로벌 설정을 해줄 때 `fallback` 데이터를 넘겨주면, 그 아래의 모든 컴포넌트에서 쉽게 같은 데이터를 쓸 수 있어요.\n- `Suspense`를 꽤 적극적으로 활용하면 로딩 상태 관리가 훨씬 깔끔해져요.\n- SWR은 기본적으로 클라이언트 전용이니, 서버에서 데이터를 미리 받아서 넘겨주는 형태가 매우 중요한 패턴이에요.\n\n---\n\n이렇게 서버와 클라이언트를 오가며 데이터를 매끄럽게 공유하면, 코드도 단순해지고 사용자에게 훨씬 부드러운 경험을 줄 수 있답니다. 다음 프로젝트에 꼭 적용해 보세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래 표는 SWR, RSC, 그리고 RSC + SWR 각각의 특징을 비교한 내용입니다. 체크 표시(✅)는 해당 기능을 지원한다는 의미이고, 엑스 표시(❌)는 지원하지 않음을 나타냅니다.\n\n| 기능                | SWR       | RSC       | RSC + SWR  |\n|---------------------|-----------|-----------|------------|\n| SSR 데이터           | ❌        | ✅        | ✅         |\n| SSR 중 스트리밍       | ❌        | ✅        | ✅         |\n| 요청 중복 제거        | ✅        | ✅        | ✅         |\n| 클라이언트 사이드 기능 | ✅        | ❌        | ✅         |\n\n- **SSR 데이터**: 서버 사이드 렌더링 시 미리 데이터를 가져와서 렌더링하는 기능입니다. RSC(리액트 서버 컴포넌트)는 SSR을 완벽히 지원하지만 SWR은 지원하지 않아요.\n- **SSR 중 스트리밍**: 서버 렌더링을 하면서 데이터를 조금씩 점진적으로 보내주는 기능으로, 사용자 경험을 향상시킵니다. RSC는 이를 지원하지만 SWR은 지원하지 않습니다.\n- **요청 중복 제거**: 동일한 요청을 중복해서 보내지 않고 하나로 통합해 서버 부담과 네트워크 낭비를 줄여줍니다. 세 방식 모두 지원합니다.\n- **클라이언트 사이드 기능**: 클라이언트 상태 관리, 캐싱, 리페칭 등 클라이언트 기반 작업을 의미합니다. SWR과 RSC+SWR에서는 가능하지만 RSC 단독으로는 지원 못 해요.\n\n---\n\n### React Query와 Next.js를 활용한 SPA 구현\n\nReact Query는 클라이언트와 서버 양쪽에서 모두 사용할 수 있어서 Next.js와 함께 엄청 유용해요. 덕분에 전통적인 싱글 페이지 애플리케이션(SPA)뿐 아니라 Next.js의 서버 기능도 활용하면서 데이터 요청과 상태 관리를 효율적으로 할 수 있습니다.\n\n예를 들어, 서버 측에서 프리페칭(pre-fetching)을 하거나 캐시된 데이터를 활용하고, 클라이언트에서는 동적인 데이터 갱신이나 리페칭(refetching) 기능을 부드럽게 처리할 수 있죠.\n\nReact Query 공식 문서에서 더 자세한 내용과 예제를 확인해 보세요!  \n(https://react-query.tanstack.com/)\n\n---\n\n> **추가 팁!**  \n> Next.js 13과 같은 최신 버전에서는 React Server Components(RSC)와 클라이언트 상태 관리 라이브러리들을 함께 조합하는 방식이 굉장히 각광받고 있어요. 상황에 맞게 SSR을 적극 활용하면서도 필요할 때는 클라이언트 단에서 쾌적한 UX를 제공할 수 있죠.  \n> 이 표를 참고해서 여러분의 프로젝트에 맞는 최적의 데이터 페칭 전략을 찾아보시길 추천드립니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 브라우저에서만 컴포넌트 렌더링하기\n\nNext.js에서 클라이언트 컴포넌트는 기본적으로 빌드 시점에 미리 렌더링(prerendering)됩니다. 하지만 어떤 컴포넌트를 **오직 브라우저 환경에서만** 렌더링하고 싶다면, 즉 서버에서는 렌더링을 하지 않고 클라이언트에서만 불러오고 싶을 때가 있죠. 이런 경우 `next/dynamic`을 활용하면 됩니다.\n\n```js\nimport dynamic from 'next/dynamic'\n\nconst ClientOnlyComponent = dynamic(() => import('./component'), {\n  ssr: false, // 서버사이드 렌더링 비활성화\n})\n```\n\n여기서 `ssr: false` 옵션이 핵심인데요, 이 옵션을 주면 해당 컴포넌트는 서버에서 렌더링하지 않고 클라이언트(브라우저)에서만 렌더링됩니다.\n\n---\n\n#### 왜 이런 방식이 필요할까요?\n\n예를 들어, 여러분이 `window`나 `document` 같은 브라우저 전용 API를 사용하는 서드파티 라이브러리를 쓸 때 문제가 됩니다. 서버는 이런 API가 없으니까 에러가 나죠. 그래서 클라이언트에서만 로딩하도록 강제하는 겁니다.\n\n또 다른 방법으로는 `useEffect` 훅 안에서 이런 브라우저 API가 있는지 체크하고, 없으면 `null`이나 로딩 컴포넌트를 반환해 미리 렌더링 상태를 조절하는 방식도 있습니다.\n\n```js\nimport { useEffect, useState } from 'react'\n\nfunction BrowserOnlyComponent() {\n  const [isClient, setIsClient] = useState(false)\n\n  useEffect(() => {\n    setIsClient(true)\n  }, [])\n\n  if (!isClient) {\n    return null // 서버나 렌더링 초기 상태에서는 아무것도 보여주지 않음\n  }\n\n  return <YourComponent />\n}\n```\n\n이렇게 하면 서버에서는 렌더링하지 않고, 클라이언트 환경이 됐을 때 컴포넌트가 나타나게 됩니다.\n\n---\n\n### 정리하자면\n\n- `next/dynamic`을 쓰면 SSR(Server Side Rendering)을 끄고 클라이언트에서만 컴포넌트를 불러올 수 있어요.\n- 브라우저 전용 API를 쓰는 라이브러리나 컴포넌트에 유용하죠.\n- 아니면 `useEffect`로 브라우저 여부를 체크해서 조건부 렌더링하는 방법도 있습니다.\n\n이 팁은 Next.js와 같은 SSR 프레임워크에서 개발할 때 자주 쓰게 되니 잘 기억해두세요! 😉\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 클라이언트에서의 Shallow Routing(얕은 라우팅) 이해하기\n\n만약 기존에 Create React App이나 Vite처럼 전통적인 SPA(싱글 페이지 애플리케이션)를 쓰다가 Next.js로 옮겨 오는 중이라면, 아마 URL 상태만 바꾸는 얕은 라우팅(shallow routing)을 사용한 코드가 있을 거예요. 이 방법은 Next.js의 기본 파일 시스템 기반 라우팅을 쓰지 않고도, 애플리케이션 내에서 뷰 전환을 직접 컨트롤할 때 꽤 유용합니다.\n\nNext.js에서는 브라우저의 페이지를 새로 고침하지 않고도 주소(URL) 상태를 업데이트할 수 있게, 네이티브 `window.history.pushState`와 `window.history.replaceState` 메서드를 사용할 수 있도록 지원해 주는데요.  \n이 두 메서드는 브라우저의 히스토리 스택을 수정해 주지만, 페이지 전환은 없고 URL만 바뀌고 싶을 때 아주 딱 맞아요.\n\n흥미로운 점은, Next.js 라우터가 이 `pushState`와 `replaceState` 호출을 잘 인식해서, 내부적으로 `usePathname`이나 `useSearchParams` 같은 훅으로 URL 상태를 동기화 할 수 있다는 겁니다. 그래서 여러분이 직접 `window.history`를 건드려도 Next.js 라우터 상태와 호환되니 걱정할 필요가 없어요.\n\n---\n\n#### 참고로 얕은 라우팅이란?\n- **일반 라우팅:** URL이 바뀌면 Next.js가 서버 혹은 클라이언트에서 완전한 페이지 변화를 처리해서 렌더링을 다시 해요.\n- **얕은 라우팅:** URL은 바뀌지만, 페이지 컴포넌트는 바뀌지 않고 특정 상태만 바꾸거나 부분적으로 업데이트할 때 쓰는 방식이에요.\n\n이 방법은 특히 검색, 필터 등 화면 내 상태 상태변경을 URL과 연동해서 반영할 때 유용하니 알아두면 좋습니다!\n\n---\n\n### 간단한 예시 코드\n\n```jsx\nimport { useRouter } from 'next/router';\n\nexport default function ShallowRoutingExample() {\n  const router = useRouter();\n\n  const handleClick = () => {\n    // URL 쿼리만 바꾸고 페이지는 다시 로드하지 않고 싶을 때\n    router.push('/mypage?tab=profile', undefined, { shallow: true });\n  };\n\n  return <button onClick={handleClick}>Change Tab</button>;\n}\n```\n\n- `shallow: true` 옵션을 주면 Next.js가 페이지 컴포넌트를 다시 렌더링하지 않고 URL만 바뀝니다.\n- 내부적으로 이 방법은 `window.history.pushState`를 사용하고 있어요.\n\n---\n\n### 덧붙여 알려주고 싶은 팁\n\n- **`window.history` 메서드 직접 쓰기:**  \n  직접 `window.history.pushState`를 호출해서 URL을 바꿔도 되지만, Next.js의 라우터 함수를 쓰는 게 유지보수와 리액티브 상태 관리에 더 유리해요.\n\n- **SEO 같은 측면**에서 URL이 바뀌는 것은 좋은데, 얕은 라우팅은 페이지가 완전히 새로고침되지 않으니 서버 기반 데이터 변경이 필요하다면 주의해야 합니다.\n\n- Next.js 13 이상부터는 App Directory와 같은 최신 기능들이 나오면서 라우팅 방식에 변화가 생겼는데, 얕은 라우팅 개념은 여전히 유용하니 필요할 때 잘 활용해보세요!\n\n---\n\n요약하면, Next.js에서 얕은 라우팅은 URL은 변경하면서 페이지를 리로드하지 않고 빠르게 상태 변화를 반영하는 좋은 방법입니다. 기존 SPA에서 익숙했던 히스토리 API를 활용하면서도 Next.js 라우터와 잘 연동되는 덕에, 여러분의 앱에 맞춰 유연하게 써먹으실 수 있어요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여러분, Next.js에서 클라이언트 컴포넌트 내에서 URL 쿼리 스트링을 다루는 간단한 방법을 공유해드릴게요. 위 예제 코드는 `useSearchParams` 훅을 이용해 현재 URL의 쿼리 파라미터를 조회하고, 버튼 클릭으로 정렬 상태(오름차순/내림차순)를 바꾸면서 URL을 업데이트하는 방법이에요.\n\n```jsx\n'use client'\n\nimport { useSearchParams } from 'next/navigation'\n\nexport default function SortProducts() {\n  const searchParams = useSearchParams()\n\n  function updateSorting(sortOrder: string) {\n    const urlSearchParams = new URLSearchParams(searchParams.toString())\n    urlSearchParams.set('sort', sortOrder)\n    window.history.pushState(null, '', `?${urlSearchParams.toString()}`)\n  }\n\n  return (\n    <>\n      <button onClick={() => updateSorting('asc')}>Sort Ascending</button>\n      <button onClick={() => updateSorting('desc')}>Sort Descending</button>\n    </>\n  )\n}\n```\n\n자, 여기서 핵심은 `useSearchParams`로 현재 URL 파라미터를 쉽게 가져오고, `window.history.pushState`를 이용해 페이지를 리로드하지 않고 주소창만 바꿔주는 점이에요. 이렇게 하면 페이지 상태는 유지하면서 URL 파라미터만 변경할 수 있죠. 사용자 경험이 훨씬 부드러워져요.\n\n---\n\n### Next.js 라우팅과 네비게이션 이해하기\n\nNext.js에서는 `useSearchParams`, `useRouter` 같은 훅을 통해 클라이언트 사이드에서 라우팅 정보에 접근하거나 조작하는 게 매우 편리해요. `useSearchParams`는 URL 쿼리값을 읽고 쓸 수 있도록 도와주고, `useRouter`는 `push`, `replace`, `back` 같은 네비게이션 메서드를 써서 라우팅을 제어할 수 있게 해주거든요.\n\n---\n\n### 클라이언트 컴포넌트에서 Server Actions 사용하기\n\nNext.js 13부터 도입된 Server Actions는 클라이언트 컴포넌트에서도 점진적으로 도입 가능해요. 예전에는 API 라우트를 호출하며 로딩 상태 관리, 에러 핸들링 같은 따로 처리해야 할 일이 많았는데 Server Actions로 간단해졌답니다.\n\nReact의 `useActionState` 같은 훅을 함께 쓰면, 로딩 중인지, 에러가 났는지 상태를 자동으로 알려줘서 UI 처리가 한결 쉬워져요. 그래서 클라이언트 컴포넌트 내에서도 서버 데이터를 바로 호출하고, 결과를 바로 반영하는 강력한 패턴으로 자리 잡고 있죠.\n\n---\n\n이런 기능들을 잘 활용하면 복잡한 상태 관리 없이도 매끄럽고 직관적인 사용자 인터페이스를 만들 수 있는데요, 특히 정렬, 필터링 같은 URL 기반 필터 기능 구축에 딱 맞습니다. 혹시 Next.js의 최신 라우팅이나 Server Actions에 대해 궁금한 점 있으면 또 공유할게요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이번에는 처음으로 Server Action을 만들어보는 예시를 들어볼게요!\n\n```js\n'use server'\n \nexport async function create() {}\n```\n\n위처럼 `create`라는 비동기 함수를 `server` 모드에서 정의할 수 있어요. 여기서 중요한 점은, 이 Server Action은 API 엔드포인트를 따로 만들 필요 없이 클라이언트 쪽에서 바로 호출할 수 있다는 거예요.\n\n클라이언트 쪽 컴포넌트에서 이렇게 사용할 수 있죠:\n\n```js\n'use client'\n \nimport { create } from './actions'\n \nexport function Button() {\n  return <button onClick={() => create()}>Create</button>\n}\n```\n\n버튼 클릭 시 `create()`라는 서버 함수가 호출돼요. 마치 일반 자바스크립트 함수를 호출하는 것처럼 간편하죠.\n\n---\n\n### 여기서 조금 더 알아두면 좋은 팁!\n\n- Server Actions 덕분에 클라이언트와 서버 사이의 데이터 통신이 훨씬 간단해졌어요.\n- 전통적인 REST API처럼 별도의 API 라우트 파일을 만들거나 fetch 요청을 직접 작성하지 않아도 돼서 빠르게 개발할 수 있답니다.\n- 물론, Server Action 내부에서 데이터베이스 작업, 인증 검증 등 서버 작업을 마음껏 할 수 있어요.\n- 그러나 이 함수는 클라이언트에서 직접 실행되는 게 아니라 서버에서 실행되며, 클라이언트에 노출되는 코드는 아니라는 점 기억하세요.\n\n이처럼 Server Actions를 활용하면 React 컴포넌트 내에서 서버 작업을 매우 쉽게 할 수 있으니, Next.js나 React Server Components를 사용할 때 꼭 활용해보세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n서버 액션(Server Actions)으로 데이터 변경하기에 대해 좀 더 알아보자!\n\n## 정적 내보내기 (선택 사항)\n\nNext.js는 완전한 정적 사이트를 생성하는 것도 지원해요. 이 방법은 일반적인 SPA(싱글 페이지 애플리케이션)보다 몇 가지 장점이 있답니다!\n\n- **자동 코드 분할**: 보통 SPA라면 하나의 index.html에 모든 코드가 모여서 클라이언트가 로딩하는 데 시간이 걸리는데, Next.js는 각 라우트마다 별도의 HTML 파일을 생성해줘요. 그래서 방문자가 페이지에 더 빨리 접근할 수 있죠.\n- **향상된 사용자 경험**: 모든 라우트에서 최소한의 스켈레톤 화면만 보여주는 대신, 각 라우트마다 완전히 렌더링된 페이지를 먼저 보내요. 클라이언트 사이드에서 이동할 때는 여전히 SPA처럼 부드럽고 즉각적인 전환을 할 수 있어서 사용자가 자연스럽게 느껴집니다.\n\n즉, Next.js의 정적 내보내기는 SEO 최적화도 되고, 초기 로딩 속도와 사용자 경험을 동시에 잡을 수 있는 훌륭한 기능이에요.\n\n추가로, 서버 액션을 활용하면 데이터 변경이 서버 측에서 직접 이루어지므로 보안이나 성능 면에서도 이점이 있어요. 클라이언트에서 불필요하게 데이터를 전달하거나 검증하는 단계가 줄어들거든요. Next.js를 사용한다면 이런 서버 액션과 정적 내보내기를 적절히 조합해서 깔끔하고 빠른 웹사이트를 만들어보세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서 정적 내보내기(Static Export)를 활성화하려면 설정 파일을 아래처럼 업데이트 해주면 돼요:\n\n```js\nimport type { NextConfig } from 'next'\n\nconst nextConfig: NextConfig = {\n  output: 'export',\n}\n\nexport default nextConfig\n```\n\n이렇게 설정하고 나서 `next build` 명령을 실행하면, Next.js가 `out` 폴더를 만들어서 HTML, CSS, JS 같은 정적 자산들을 그 안에 담아줍니다. 덕분에 별도의 서버 없이도 완전히 정적인 웹사이트를 배포할 수 있죠.\n\n---\n\n> 참고: 정적 내보내기를 사용할 경우, Next.js의 서버 사이드 기능들은 지원되지 않습니다. 예를 들어, API 라우트나 getServerSideProps 같은 기능은 쓸 수 없어요.  \n> 만약 서버 기능이 필요하면, 정적 내보내기 대신 ISR(Incremental Static Regeneration)이나 SSR(Server Side Rendering)을 고민해보는 게 좋아요.\n\n---\n\n추가로, 정적 내보내기는 간단한 블로그나 포트폴리오 사이트, 문서 페이지 등에 아주 적합해요. 만약 사용자 맞춤형 데이터나 실시간 정보가 적게 필요하고, 최대한 빠른 로딩이 목표라면 꼭 고려해보세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 기존 프로젝트를 Next.js로 점진적으로 마이그레이션하기\n\nNext.js로 완전히 갈아타기 부담스럽다고? 걱정 마세요! Next.js는 기존 프로젝트를 단계별로 천천히 옮길 수 있게 가이드가 잘 마련되어 있어요.\n\n- Create React App에서 마이그레이션하기\n- Vite에서 마이그레이션하기\n\n이미 SPA를 만들고 Pages Router를 사용 중이라면, App Router를 점진적으로 적용하는 방법도 배울 수 있답니다.\n\n---\n\n사실 큰 프로젝트를 한꺼번에 옮기려면 막막할 수 있잖아요. Next.js는 이런 점을 고려해서 '조각조각' 나눠서 적용할 수 있도록 설계되었거든요. 덕분에 기존 코드도 유지하면서 점차 Next.js의 장점들을 누려볼 수 있어요.\n\n그리고 App Router는 Next.js 최신 기능 중 하나인데, 기존 Pages Router 프로젝트에 조금씩 섞어 쓰다가 완전히 갈아타는 것도 가능해요. 그래서 기존에 만들어 놓은 SPA에 큰 변화 없이도 최신 패턴을 활용할 수 있다는 점, 참고하세요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":26}],"page":"5","totalPageCount":41,"totalPageGroupCount":3,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}