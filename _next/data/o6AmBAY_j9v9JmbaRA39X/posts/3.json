{"pageProps":{"posts":[{"title":"Next.js 15에서 not-found.js로 404 페이지 쉽게 만드는 방법","description":"","date":"2025-04-22 02:43","slug":"2025-04-22-not-foundjs","content":"\n\n# not-found.js 파일 사용법 - Next.js에서 404 페이지 만들기\n\n안녕하세요! 오늘은 Next.js에서 사용자 정의 404 페이지를 만드는 방법을 소개할게요. `not-found.js` 파일을 사용하면, 특정 라우트(segment)에서 `notFound` 함수가 호출되었을 때 보여질 UI를 쉽게 꾸밀 수 있답니다.\n\n## 기본 개념\n\n- `not-found.js`는 라우트 내에서 `notFound()` 함수가 호출되는 경우, 그에 대한 UI를 렌더링해줍니다.\n- 스트리밍 응답(response)인 경우에는 HTTP 상태 코드가 200으로 반환되지만, 스트리밍이 아닌 일반 응답은 404 상태 코드를 반환합니다.\n- 즉, 사용자에게 맞춤형 404 페이지를 쉽게 제공하면서 백엔드의 응답 코드는 상황에 맞게 처리해줍니다.\n\n## 예제 코드\n\n아래는 아주 기본적인 `not-found.js` 파일 예제입니다.\n\n```jsx\nimport Link from 'next/link'\n \nexport default function NotFound() {\n  return (\n    <div>\n      <h2>Not Found</h2>\n      <p>Could not find requested resource</p>\n      <Link href=\"/\">Return Home</Link>\n    </div>\n  )\n}\n```\n\n- `<h2>` 태그로 큰 제목을, `<p>`로 간단한 안내 문구를 넣었고요.\n- `next/link`의 `Link` 컴포넌트를 사용해서 홈으로 돌아갈 수 있는 링크도 만들었어요.\n\n요렇게 하면, 사용자 경험을 높이는 맞춤형 404 페이지를 아주 쉽게 만들 수 있죠!\n\n## 추가 팁!\n\n- `not-found.js`는 라우트 폴더 바로 아래에 위치해야 작동해요. 예: `app/products/not-found.js`\n- 더 멋진 UI를 위해 스타일링 라이브러리(Tailwind CSS 등)를 활용해도 좋습니다.\n- 404 페이지에서 로그를 남기고 싶다면 컴포넌트 내에서 간단한 클라이언트 또는 서버 사이드 코드 작성도 가능해요.\n- Next.js 13 버전 이상의 앱 라우터(App Router) 환경에서만 동작하니 참고하세요!\n\n---\n\n다음에 더 재미있고 유용한 Next.js 팁으로 찾아올게요! 필요하면 댓글로 질문 남겨주세요~ 🙌\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### Props\n\nnot-found.js 컴포넌트는 아무런 props도 받지 않습니다.\n\n> 알아두면 좋은 점: 예상되는 notFound() 오류를 잡아내는 것 외에도, 루트에 위치한 app/not-found.js 파일은 여러분 앱 전체에서 처리되지 않는 URL들도 다룹니다. 즉, 사용자가 여러분 앱 내에서 처리하지 않는 URL에 접속할 경우, app/not-found.js 파일에서 내보내는 UI가 보여지게 된다는 뜻이에요.\n\n## 예시\n\n(여기에는 실제 사용 예시나 코드가 들어가면 더 이해하기 좋겠죠? 만약 준비된 예시가 있다면 추가해보세요!) \n\n---\n\n이 부분을 보면 Next.js 13의 새로운 파일 기반 라우팅에서 404 페이지를 처리하는 방식을 알 수 있어요. 예전에는 별도의 error handling 코드를 많이 짰는데, 이제는 이처럼 not-found.js 파일 하나로 깔끔하게 처리할 수 있습니다. 그리고 루트 디렉토리의 app/not-found.js는 전체 앱에서 처리하지 못하는 URL에 대해서도 자동으로 404 페이지 역할을 하니까, 개발하면서 404 페이지를 따로 신경 쓰지 않아도 된다는 점이 정말 편리해요.\n\n더불어, 만약 특정 경로에서만 커스텀 404 페이지가 필요하다면 하위 폴더에 별도로 not-found.js를 만들어 적용할 수도 있다는 점, 알고 계시면 좋습니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 데이터 가져오기 (Data Fetching)\n\n기본적으로 `not-found` 컴포넌트는 서버 컴포넌트(Server Component)이에요. 하지만 이 컴포넌트를 `async`로 만들어 데이터를 받아오고 화면에 보여줄 수도 있답니다.\n\n아래 예시를 보면, `headers()`를 통해 요청 헤더에서 도메인 정보를 가져오고, 그 도메인에 맞는 데이터를 비동기로 받아와서 화면에 출력하는 모습이에요.\n\n```js\nimport Link from 'next/link'\nimport { headers } from 'next/headers'\n\nexport default async function NotFound() {\n  const headersList = await headers()\n  const domain = headersList.get('host')\n  const data = await getSiteData(domain)\n  return (\n    <div>\n      <h2>Not Found: {data.name}</h2>\n      <p>Could not find requested resource</p>\n      <p>\n        View <Link href=\"/blog\">all posts</Link>\n      </p>\n    </div>\n  )\n}\n```\n\n### 여기서 좀 더 알아두면 좋은 점!\n\n- `headers()` 함수는 서버에서 실행될 때만 사용할 수 있어요. 클라이언트에서 실행하면 동작하지 않으니 주의하세요.\n- 위 예시는 서버 컴포넌트에서 데이터를 가져오는 기본적인 패턴인데, 만약 `usePathname` 같은 클라이언트 훅을 써서 URL 경로에 따라 화면을 다르게 그리고 싶다면, 데이터를 클라이언트에서 가져와야 해요. 그러니까 클라이언트 컴포넌트로 만들어서 `useEffect` 같은 훅을 이용하는 거죠.\n- 서버 컴포넌트와 클라이언트 컴포넌트를 혼용할 때는 데이터를 어디서, 어떻게 가져올지 상황에 맞게 설계하는 게 중요합니다.\n\n즉, **비동기 데이터 페칭이 필요하다면 서버 컴포넌트에서 async 함수로 간단하게 처리할 수 있지만, 클라이언트 훅을 사용하고 싶다면 클라이언트 컴포넌트에서 처리하는 걸 기억하세요!**\n\n이해하기 어려운 부분이나 직접 써보고 싶은 팁 있으면 언제든 물어보세요 :)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 버전 히스토리\n\n| 버전        | 변경 사항                                   |\n|-------------|--------------------------------------------|\n| `v13.3.0`   | 루트 `app/not-found`가 전역에서 매칭되지 않는 URL들을 처리하도록 변경됨. |\n| `v13.0.0`   | `not-found` 기능이 도입됨.                   |\n\n---\n\n여기서 `not-found`는 사용자 경험을 위해 웹사이트에서 404 페이지 같은 '찾을 수 없음' 페이지를 쉽게 구현할 수 있게 도와주는 기능이에요. 특히 `v13.3.0`에서는 앱의 루트 경로에서 전역적으로 매칭되지 않는 URL을 처리하도록 확장돼서, 여러분이 앱 내에서 예상치 못한 경로로 접근할 때도 깔끔하게 안내 페이지를 띄울 수 있답니다.\n\n웹 개발하면서 이런 '404페이지' 처리 중요하죠? 사용자가 잘못된 URL로 들어왔을 때 그냥 에러 메시지 띄우는 것보다 친절한 안내 페이지를 보여주는 게 훨씬 UX 측면에서 좋아요. Next.js 최신 버전들을 사용한다면 이런 기능들을 잘 활용해보세요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":5},{"title":"Next.js 15 page.js로 페이지 구성하는 방법","description":"","date":"2025-04-22 02:43","slug":"2025-04-22-pagejs","content":"\n\n# page.js 파일 이해하기\n\n이번에는 Next.js에서 route(경로)마다 고유한 UI를 정의할 수 있는 `page.js` 파일에 대해 이야기해볼게요. 간단히 말해서, 특정 경로에 연결되는 페이지 컴포넌트를 만들고 싶으면, 해당 경로 폴더 안에 `page.js` 파일을 만들고 기본 내보내기(default export)로 컴포넌트를 작성하면 됩니다.\n\n예를 들어, 이렇게 작성할 수 있어요:\n\n```js\nexport default function Page({\n  params,\n  searchParams,\n}: {\n  params: Promise<{ slug: string }>\n  searchParams: Promise<{ [key: string]: string | string[] | undefined }>\n}) {\n  return <h1>My Page</h1>\n}\n```\n\n- **params**: URL 경로의 동적 세그먼트(예: `/post/[slug]`에서 `slug` 값)를 받을 때 사용돼요.\n- **searchParams**: 쿼리 스트링에 포함된 키-값 쌍을 객체 형태로 받을 수 있어요.\n\n하지만 위 예제에서는 params와 searchParams 타입을 `Promise`로 감싸고 있는데, 이는 Next.js 13+에서 서버 컴포넌트가 비동기 작업을 할 수 있어서 그런 경우가 많아요.\n\n---\n\n## 여기서 알아두면 좋은 점들\n\n| 내용                     | 설명                                                                                      |\n|--------------------------|-------------------------------------------------------------------------------------------|\n| 기본 내보내기 필수        | `page.js`에 기본으로 export된 React 컴포넌트가 있어야 Next.js가 해당 페이지를 인식해요.       |\n| 서버 컴포넌트 기본 적용    | Next.js 13부터는 기본적으로 `page.js`는 서버 컴포넌트라서, 클라이언트 상태 관리가 필요하면 별도 설정 필요해요.(예: `'use client'` 선언) |\n| 동적 라우팅 지원          | `params`를 통해 동적 경로 세그먼트를 쉽게 받아올 수 있어 동적인 페이지 구현이 편리해졌어요.       |\n| 쿼리 파라미터 사용법      | `searchParams`로 URL에 전달된 쿼리 파라미터를 받을 수 있어, 필터링이나 검색 기능 구현 가능해요.   |\n\n---\n\n### 추가 팁! \n\n- **`'use client'` 선언**  \n  만약 해당 `page.js` 안에서 `useState`, `useEffect` 같은 클라이언트 전용 API를 사용한다면, 파일 최상단에 `'use client'`를 꼭 작성해 줘야 해요. 그래야 Next.js가 클라이언트 컴포넌트로 취급합니다.\n\n- **비동기 컴포넌트**  \n  위 코드처럼 파라미터가 `Promise`로 되어 있다면, 컴포넌트를 `async` 함수로 만들어서 데이터를 서버에서 직접 fetch하거나 처리할 수도 있어요.\n\n- **파일 위치에 따른 라우팅**  \n  `app` 디렉터리 구조에 따라서 자동으로 URL 경로가 결정되니까, 폴더 이름과 파일 이름이 곧 URL이 된다고 생각하면 편합니다.\n\n---\n\n`page.js`를 활용하면 각 경로별로 독립적인 UI 및 데이터 처리가 매우 편리해져서, Next.js의 강력한 기능을 실제 프로젝트에 잘 녹여내는 데 큰 도움이 됩니다!\n\n한번 직접 만들어 보면서 익혀보시길 추천드려요 :)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이번 글에서는 Next.js에서 페이지 파일과 라우팅에 대해 간단하게 정리해볼게요. 주로 `.js`, `.jsx`, `.tsx` 확장자를 가진 파일들이 페이지로서 사용되는데, 이 부분부터 시작해봅시다.\n\n---\n\n### Next.js 페이지 파일 정리\n\n- **페이지 확장자**  \n  `.js`, `.jsx`, `.tsx` 확장자가 페이지 파일로 사용됩니다.  \n  즉, 이 파일들을 `pages` 디렉토리나 앱 디렉토리(route segment) 안에 넣으면 해당 파일이 하나의 페이지로 처리돼요.\n\n- **페이지가 항상 라우트 트리의 '리프(leaf)'이다**  \n  이 말은, 페이지가 최종적으로 도착하는 경로의 끝부분(리프 노드)이란 뜻입니다.  \n  중간 경로(segment)는 레이아웃이나 다른 로직을 담당하고, 실제 화면에 그려지는 페이지는 트리의 가장 끝에 있어요.\n\n- **라우트 세그먼트를 공개하려면 페이지 파일이 필수!**  \n  어떤 경로(segment)를 외부에서 접근 가능하게 만들려면 해당 위치에 페이지 파일이 꼭 필요합니다.  \n  페이지 파일이 없다면 그 경로는 사용자에게 보여지지 않아요.\n\n- **페이지는 기본적으로 서버 컴포넌트(Server Components)**  \n  Next.js 13부터는 페이지가 서버 컴포넌트로 기본 설정되어 있어 서버에서 렌더링됩니다.  \n  하지만 필요에 따라 클라이언트 컴포넌트(Client Component)로 설정할 수도 있어, 인터랙티브한 UI가 필요할 때는 클라이언트 컴포넌트로 바꿔주면 됩니다.\n\n---\n\n### 참고: Props 중 params\n\n페이지 컴포넌트에 전달되는 `params`는 선택 사항이며, 동적 라우팅에 많이 사용됩니다.  \nURL 경로에서 동적 세그먼트를 추출해 매개변수로 전달해주기 때문에, 예를 들어 블로그 글 ID 같은 값을 받아 처리할 때 유용하죠.\n\n---\n\n### 추가로 알아두면 좋은 점들\n\n- **서버 컴포넌트 vs 클라이언트 컴포넌트**  \n  - 서버 컴포넌트는 초기 렌더링 속도가 빠르고 SEO에 유리하며, 서버에서만 실행됩니다.  \n  - 클라이언트 컴포넌트는 사용자 인터랙션, 상태 관리, 이벤트 핸들러에 필요하지만, 번들 크기가 커질 수 있으니 꼭 필요한 곳에만 사용하세요.\n\n- **_app.js, _document.js 같은 특수 파일은 pages 디렉토리에서만 사용 가능하다?**  \n  Next.js의 앱 라우팅 시스템과 기존 pages 시스템은 약간 다르기 때문에 혼동될 수 있습니다. 만약 최신 앱 디렉토리를 사용하고 있다면, 그에 맞게 구조를 잡아야 해요.\n\n---\n\n다음에도 Next.js 라우팅이나 페이지 관련 정보를 더 쉽게 풀어서 알려드릴게요! 필요하면 댓글로 궁금한 점 주세요! 😊\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n루트 세그먼트부터 해당 페이지까지 전달되는 동적 라우트 파라미터들을 담고 있는 객체를 반환하는 Promise에 대해 살펴볼게요.\n\n```js\nexport default async function Page({\n  params,\n}: {\n  params: Promise<{ slug: string }>\n}) {\n  const { slug } = await params\n}\n```\n\n여기서 `params`는 Promise 형태로 넘어오기 때문에, 값을 얻어내려면 꼭 `async/await`을 써야 합니다. 혹은 React의 use 함수와 같은 방법을 써도 좋아요.\n\n아래는 동적 라우팅에 따른 `params` 값 예시입니다.\n\n| Example Route                      | URL        | params                          |\n|----------------------------------|------------|--------------------------------|\n| `app/shop/[slug]/page.js`         | `/shop/1`  | `Promise<{ slug: '1' }>`        |\n| `app/shop/[category]/[item]/page.js` | `/shop/1/2` | `Promise<{ category: '1', item: '2' }>` |\n| `app/shop/[...slug]/page.js`      | `/shop/1/2` | `Promise<{ slug: ['1', '2'] }>` |\n\n---\n\n참고로, Next.js 14버전까지는 `params`가 동기 프로퍼티였어요. 그래서 바로 접근 가능했죠. 근데 Next.js 15부터는 이게 Promise 형태가 됐습니다. 아직 15버전에서는 예전처럼 동기적으로 접근해도 동작하지만, 앞으로는 deprecated(사용 중단 예정)이 될 거니까 미리 `async/await` 패턴으로 바꾸는 게 좋아요.\n\n추가 팁을 드리자면, 동적 라우팅에서 여러 개의 파라미터가 있을 때는 `params` 객체에 그 이름대로 키가 잡히고, catch-all 라우트(`[...slug]`)처럼 경로의 여러 값을 배열로 받을 때도 있으니 구조 분해할 때 조심하세요.\n\n요약하자면,\n\n- Next.js 15부터 `params`는 Promise다.\n- `async/await`나 React의 use 함수로 값을 받아야 한다.\n- 기존 동기 접근은 당분간 유지되지만, 곧 없어질 예정이다.\n\n이 점만 기억하면 동적 라우팅을 다룰 때 좀 더 깔끔하고 미래에도 문제없는 코드를 작성할 수 있을 거예요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n#### searchParams (선택 사항)\n\n`searchParams`는 현재 URL의 쿼리 파라미터를 담고 있는 객체로, Promise 형태로 전달됩니다. 예를 들어, 이렇게 받아올 수 있죠:\n\n```js\nexport default async function Page({\n  searchParams,\n}: {\n  searchParams: Promise<{ [key: string]: string | string[] | undefined }>\n}) {\n  const filters = (await searchParams).filters;\n}\n```\n\n예를 들어 URL이 `/shop?a=1`이라면 `searchParams`는 `{ a: '1' }`라는 객체를 Promise로 감싸 전달합니다.\n\n| 예시 URL           | searchParams 타입              |\n|------------------|------------------------------|\n| `/shop?a=1`       | `Promise<{ a: '1' }>`         |\n| `/shop?a=1&b=2`   | `Promise<{ a: '1', b: '2' }>` |\n| `/shop?a=1&a=2`   | `Promise<{ a: ['1', '2'] }>`  |\n\n여기서 중요한 점은, 같은 키에 여러 값이 있을 때는 배열 형태로 받아온다는 거예요. (예: `?a=1&a=2`)\n\n---\n\n추가 팁을 하나 드리자면, 이 `searchParams`를 활용해 필터링 기능이나 페이징 같은 걸 페이지에서 직접 다룰 수 있어서, 서버에서 별도 처리를 하지 않고도 쿼리 기반 UI를 손쉽게 만들 수 있습니다. Next.js 13 이상 같은 최신 프레임워크에서 특히 유용한 패턴이니, 꼭 기억해두세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 내용은 Next.js의 `searchParams` prop 사용법에 관한 업데이트를 다루고 있는데요, 쉽게 말해서 `searchParams`가 이제는 Promise 형태라는 점을 기억해 두셔야 합니다. 예전(버전 14 이하)에는 동기적으로 바로 접근할 수 있었지만, 버전 15부터는 비동기적으로 값을 받아야 하므로 `async/await`이나 React의 비동기 훅을 꼭 써야 한다는 뜻이죠.\n\n---\n\n### 주요 포인트 정리\n\n| 내용 | 설명 |\n|-------|---------|\n| `searchParams`가 Promise 형태 | `searchParams`가 비동기 값이 되었어요. 따라서 값을 사용할 때 꼭 `await`를 사용하거나 비동기 훅을 사용하세요. |\n| 이전 버전과의 호환성 | Next.js 15에서는 이전처럼 동기적으로 접근 가능하지만, 앞으로는 지원이 끊깁니다. 지금부터는 비동기로 처리하는게 안전해요. |\n| 동적 API | `searchParams`는 동적인 API라서 해당 값을 미리 알 수 없고, 이를 쓰면 서버가 요청 시점에 페이지를 렌더링 합니다. 따라서 빌드 타임에 완전히 고정된 페이지는 아니게 돼요. |\n| 객체 형태 | `searchParams`는 `URLSearchParams` 인스턴스가 아니라 일반 자바스크립트 객체입니다. 즉, 메서드 같은 건 없고 단순 키-값 쌍이에요. |\n\n---\n\n### 좀 더 쉽게 이해할 수 있는 예시\n\n만약 URL에 `?category=books`라는 쿼리파라미터가 붙었다고 해볼게요. 기존에는 이렇게 바로 썼겠죠?\n\n```js\nfunction Page({ searchParams }) {\n  console.log(searchParams.category);\n  return <div>{searchParams.category}</div>;\n}\n```\n\n하지만 이제는 이렇게 바꿔야 합니다.\n\n```js\nasync function Page({ searchParams }) {\n  const params = await searchParams;\n  console.log(params.category);\n  return <div>{params.category}</div>;\n}\n```\n\n또는 React의 `useEffect`를 쓰는 컴포넌트 안이라면:\n\n```js\nfunction PageWrapper() {\n  const [category, setCategory] = React.useState(null);\n\n  React.useEffect(() => {\n    async function getParams() {\n      const params = await searchParams;\n      setCategory(params.category);\n    }\n    getParams();\n  }, []);\n\n  return <div>{category ? category : '로딩중...'}</div>;\n}\n```\n\n---\n\n### 정리하며\n\n- Next.js 15부터는 `searchParams`가 비동기로 바뀌었으니, `await` 안 쓰면 제대로 된 값 못 받아요.  \n- 이번 업데이트로 인해 약간의 코드 수정이 필요하지만, 동적 쿼리에 더 유연하게 대응할 수 있어져서 좋은 점도 많아요.  \n- 참고로, `searchParams`는 그냥 키-값 객체라서 `get()` 이런 메서드는 없습니다.\n\n---\n\n앞으로 쿼리파라미터를 다룰 때 이 점 꼭 기억하시고 미리 준비해두세요! 개발할 때 예상치 못한 비동기 문제에 걸려서 당황하는 일이 크게 줄어들 거예요. 혹시 동적 라우팅이나 쿼리 데이터 처리에 대해 더 궁금한 점 있으면 언제든지 알려주세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js의 새로운 app 폴더 구조에서는 페이지 컴포넌트에 `params`와 `searchParams`를 props로 전달할 수 있어요. 이걸 활용하면 동적 경로나 쿼리스트링을 쉽게 처리할 수 있답니다.\n\n먼저, `params`를 이용한 예제부터 볼게요. 아래 코드에서 `params`는 URL의 동적 세그먼트(예: `/blog/[slug]`의 slug)를 의미해요.\n\n```js\nexport default async function Page({\n  params,\n}: {\n  params: Promise<{ slug: string }>\n}) {\n  const { slug } = await params\n  return <h1>Blog Post: {slug}</h1>\n}\n```\n\n여기서 주목할 부분은 `params`가 Promise 형태라는 것! 그래서 `await`으로 먼저 값을 꺼내줘야해요. 이렇게 하면 URL에 따라 각기 다른 블로그 포스트를 보여줄 수 있죠.\n\n---\n\n다음은 `searchParams`를 이용해서 URL 쿼리스트링을 가져오는 방법이에요. 예를 들어, `?page=2&sort=desc&query=apple` 같은 쿼리가 있을 때 유용하죠.\n\n```js\nexport default async function Page({\n  searchParams,\n}: {\n  searchParams: Promise<{ [key: string]: string | string[] | undefined }>\n}) {\n  const { page = '1', sort = 'asc', query = '' } = await searchParams\n \n  return (\n    <div>\n      <h1>Product Listing</h1>\n      <p>Search query: {query}</p>\n      <p>Current page: {page}</p>\n      <p>Sort order: {sort}</p>\n    </div>\n  )\n}\n```\n\n`searchParams` 역시 Promise 형태라서 `await` 해준 뒤 각 파라미터를 디폴트값과 함께 받는 게 좋아요. 이렇게 하면 필터링, 페이지네이션, 정렬 같은 작업을 쉽게 처리할 수 있어요.\n\n---\n\n### 추가 팁\n\n- `params`는 동적 라우팅에서만 전달되고, `searchParams`는 URL의 쿼리스트링이 있을 때만 의미가 있습니다.\n\n- 쿼리파라미터가 배열 형태일 수도 있으니, 타입을 `{ [key: string]: string | string[] | undefined }` 같이 지정해주는 게 좋아요.\n\n- `await`을 꼭 사용해야 하는데, async 함수인 점을 잊지 마세요!\n\n- 실제로는 데이터를 서버에서 가져오는 코드와 결합해서 화면에 뿌리는 경우가 많아요. 이 부분만 분리해서 써도 Next.js의 라우팅과 데이터 패칭이 간단해집니다.\n\n이제 Next.js의 새 라우팅 방식으로 더 편리한 동적 페이지와 쿼리 처리 구현해보세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 클라이언트 컴포넌트에서 searchParams와 params 읽기\n\nNext.js 13의 앱 라우팅에서는 클라이언트 컴포넌트(Client Component)에서는 `async` 함수를 사용할 수 없기 때문에, `searchParams`와 `params`처럼 비동기 데이터를 직접 받아서 처리하는 데 약간의 꼼수가 필요합니다.\n\n바로 React 18에서 도입된 `use` 훅을 활용하면, 비동기 `Promise` 형태로 전달되는 `params`와 `searchParams`를 간단히 읽을 수 있어요.\n\n```jsx\n'use client'\n\nimport { use } from 'react'\n\nexport default function Page({\n  params,\n  searchParams,\n}: {\n  params: Promise<{ slug: string }>\n  searchParams: Promise<{ [key: string]: string | string[] | undefined }>\n}) {\n  const { slug } = use(params)\n  const { query } = use(searchParams)\n\n  // 이 시점에서는 slug와 query가 실제 데이터로 변환되어 사용 가능\n}\n```\n\n여기서 중요한 점은 `params`와 `searchParams`가 `Promise`로 전달된다는 것입니다. 그래서 이걸 바로 읽기 위해 `use(params)`, `use(searchParams)`를 사용하는 거죠. 이렇게 하면 동기적으로 사용할 수 있어서, 클라이언트 컴포넌트에서도 자연스럽게 데이터를 사용할 수 있습니다.\n\n> 참고로, `use` 훅은 아직 실험적인 기능이라서 프로젝트 환경이나 React 버전에 따라 다소 차이가 있을 수 있으니, 최신 공식 문서나 Next.js 업데이트를 꼭 확인하는 게 좋아요.\n\n---\n\n## 버전 히스토리\n\n| 버전  | 내용                                         |\n|-------|----------------------------------------------|\n| 13.4  | 클라이언트 컴포넌트에서 `use` 훅을 활용해 `params`와 `searchParams`를 쉽게 읽을 수 있는 기능 추가 |\n| -     | `use` 훅은 React 18의 실험적 기능으로서, 점차 안정화 중                  |\n\n---\n\n개발하면서 이런 작은 변화들이 실제 코드 작성 방식을 많이 바꾸는데요, 특히 Next.js처럼 SSR과 클라이언트 렌더링이 섞여 있는 환경에서는 비동기 데이터 처리 방법이 중요해집니다. 앞으로도 새로운 React 기능이나 Next.js 업데이트 소식 공유할게요! 도움이 되셨다면 댓글로 남겨주세요 :)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n| Version      | Changes                                                                                   |\n|--------------|-------------------------------------------------------------------------------------------|\n| `v15.0.0-RC` | `params`와 `searchParams`가 이제 Promise로 바뀌었어요. 관련해서 [codemod](https://nextjs.org/docs/app/guides/upgrading/codemods#150) 도 준비되어 있으니 참고하세요! |\n| `v13.0.0`    | `page`가 도입되었습니다.                                                                  |\n\n요즘 Next.js 업데이트 소식 전해드릴게요! 특히 `v15.0.0-RC`부터는 `params`와 `searchParams`가 비동기 처리 방식으로 바뀌어서, 기존 코드에선 약간의 수정이 필요해요. 다행히 공식에서 자동으로 코드를 바꿔주는 codemod 도구를 제공하고 있어서, 크게 어렵지 않게 적용할 수 있답니다.\n\n또, 좀 더 기본적인 부분으로 돌아가 보면 `v13.0.0`에서는 이제 `page`가 도입되었는데요, Next.js 사용하시면서 페이지 단위로 구조를 잡을 때 참고하시면 좋아요. 버전 바뀔 때마다 새로운 기능이 추가되니, 자주 공식 문서 한번씩 훑어보는 걸 추천드려요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":13},{"title":"Next.js 15 로딩 컴포넌트 만들기 (loading.js)","description":"","date":"2025-04-22 02:41","slug":"2025-04-22-loadingjs","content":"\n\n# loading.js 소개\n\n이번에는 React에서 사용할 수 있는 `loading.js` 파일에 대해 이야기해볼게요. 이 파일은 Suspense를 활용해서 **즉각적인 로딩 상태**를 만들어 주는 역할을 해요.\n\n기본적으로는 서버 컴포넌트(Server Component)로 작동하지만, 필요에 따라 `\"use client\"` 지시어를 붙여서 클라이언트 컴포넌트(Client Component)로도 쓸 수 있답니다.\n\n---\n\n## 예시 코드\n\n```js\nexport default function Loading() {\n  // 또는 내가 만든 커스텀 로딩 스켈레톤 컴포넌트를 넣어줄 수도 있어요\n  return <p>Loading...</p>;\n}\n```\n\n### 좀 더 쉽게 설명하자면?\n\n이 파일을 만들어 놓으면 페이지 혹은 컴포넌트가 로딩될 때, 사용자에게 “로딩 중입니다” 같은 상태를 바로 보여줄 수 있어 UX가 훨씬 좋아지죠. Suspense가 컴포넌트를 렌더링하는 동안 이 `Loading` 컴포넌트를 잠시 보여주는 식이에요.\n\n### 꿀팁: 커스텀 로딩 UI 만들기\n\n간단한 텍스트 대신에 애니메이션이 들어간 스켈레톤 UI나 뼈대 화면을 만들어서 넣으면 더 자연스럽고 프로답게 보일 수 있어요. React의 `react-loading-skeleton` 라이브러리를 사용해도 좋고, CSS 애니메이션으로 직접 꾸며줄 수도 있답니다.\n\n---\n\n그럼 다음에는 Suspense랑 함께 이 `loading.js`를 어떻게 더 멋지게 활용하는지도 같이 알아볼게요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n로딩 UI 컴포넌트는 어떤 파라미터도 받지 않는다는 점, 알아두면 좋아요.\n\n> 참고 팁:\n로딩 UI를 설계할 때 React Developer Tools를 이용하면 Suspense 경계(boundary)를 수동으로 토글해보면서 동작을 확인하는 데 큰 도움이 됩니다.\n\n## 버전 히스토리\n\n| 버전       | 변경 사항              |\n|------------|-----------------------|\n| `v13.0.0`  | `loading` 컴포넌트 도입 | \n\n추가로, 로딩 UI는 사용자 경험에서 정말 중요한 부분이에요. 너무 짧게 보여주면 깜빡이는 느낌이 들 수 있고, 너무 길면 지루한 느낌을 줄 수 있거든요. 그래서 React Suspense와 함께 사용할 때는 로딩 컴포넌트를 잘 활용해서 자연스러운 화면 전환 효과를 만드는 게 중요해요. React Developer Tools로 직접 토글해보면서 그런 느낌을 체험해 보세요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":2},{"title":"Next.js 15에서 mdx-components.js로 커스텀 MDX 컴포넌트 만드는 방법","description":"","date":"2025-04-22 02:41","slug":"2025-04-22-mdx-componentsjs","content":"\n\n# mdx-components.js (또는 .tsx) 파일 소개\n\nNext.js에서 `@next/mdx`와 App Router를 함께 사용할 때, `mdx-components.js` (또는 `mdx-components.tsx`) 파일은 꼭 필요한 친구예요. 이 파일이 없으면 MDX를 제대로 쓸 수 없거든요. 게다가 이 파일을 활용하면 MDX 내에서 사용하는 컴포넌트들의 스타일이나 동작을 커스터마이징할 수도 있답니다!\n\n---\n\n## 위치는 어디에?\n\n- 프로젝트 루트 바로 아래에 둬요.  \n- 예를 들어, `pages` 또는 `app` 폴더와 같은 레벨에 (또는 `src` 폴더 안에) 두면 좋아요.\n\n---\n\n## 기본적인 작성법\n\n```tsx\nimport type { MDXComponents } from 'mdx/types'\n\nexport function useMDXComponents(components: MDXComponents): MDXComponents {\n  return {\n    ...components,\n  }\n}\n```\n\n이 코드는 기본 설정으로 컴포넌트들을 그대로 반환하는 역할을 해요. 여기서 `components`에 우리가 직접 만든 커스텀 컴포넌트들을 덮어씌워서 스타일이나 기능을 내가 원하는 대로 바꿀 수 있죠.\n\n---\n\n## 실제로 커스텀 해보기\n\n예를 들어, MDX 안에서 `<h1>` 태그의 스타일을 바꾸고 싶다면 이렇게 작성할 수 있어요:\n\n```tsx\nimport type { MDXComponents } from 'mdx/types'\n\nconst MyH1 = (props) => <h1 style={{ color: 'tomato', fontSize: '2.5rem' }} {...props} />\n\nexport function useMDXComponents(components: MDXComponents): MDXComponents {\n  return {\n    h1: MyH1,\n    ...components,\n  }\n}\n```\n\n이렇게 하면 MDX 파일 내 `<h1>` 태그가 모두 토마토색 큰 글씨로 바뀌죠.\n\n---\n\n## 참고! 왜 이걸 쓰는 걸까?\n\nMDX 안에는 기본 HTML 태그뿐만 아니라, React 컴포넌트도 자유롭게 넣을 수 있어요. 예를 들어 버튼, 카드, 또는 특별한 레이아웃 컴포넌트 등이죠. 이걸 한 번에 관리하고 싶다면 이 `mdx-components` 파일을 활용해서 확장하거나 수정하는 게 가장 깔끔하답니다.\n\n---\n\n**정리하자면**, `mdx-components.js`(또는 `.tsx`)는 Next.js + MDX 환경에서 커스텀 컴포넌트를 선언하고 스타일을 조절하는 중요한 허브 역할을 하니 꼭 기억하세요! 프로젝트에서 MDX를 쓴다면 이 친구는 필수랍니다 :)\n\n---\n\n필요하면 나중에 커스텀 컴포넌트를 더 만드는 법도 알려드릴게요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## Exports\n\n### useMDXComponents 함수\n\n이 파일은 하나의 함수만 내보내야 해요. 기본 내보내기(default export)로 하거나 `useMDXComponents`라는 이름으로 내보낼 수 있죠.\n\n```js\nimport type { MDXComponents } from 'mdx/types'\n\nexport function useMDXComponents(components: MDXComponents): MDXComponents {\n  return {\n    ...components,\n  }\n}\n```\n\n> 여기서 `useMDXComponents` 함수는 MDX 컴포넌트를 커스터마이징할 때 유용해요. 예를 들어, 기본 제공되는 MDX 컴포넌트를 당신만의 스타일이나 새로운 컴포넌트로 대체하고 싶을 때 이 함수를 사용하죠.  \n> 그리고 `components` 객체를 받아 그대로 돌려주고 있는데, 필요하면 여기에 새로운 컴포넌트를 추가하거나 기존 컴포넌트를 덮어씌우는 작업도 할 수 있어요.  \n>\n> 간단한 예를 들어볼게요:  \n> js\n> export function useMDXComponents(components) {\n>   return {\n>     h1: (props) => <h1 style={{ color: 'tomato' }} {...props} />,\n>     ...components,\n>   }\n> }\n> \n> 이렇게 하면 MDX 내의 모든 `h1` 태그는 토마토색 글씨로 표시되겠죠!   \n>  \n> MDX로 콘텐츠 작업할 때 아주 많이 쓰이는 패턴입니다.  \n> 필요에 따라 잘 커스터마이징해보세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## Params\n\n### components\n\nMDX 컴포넌트를 정의할 때, export 함수는 단일 파라미터인 `components`를 받습니다. 이 `components`는 `MDXComponents` 타입의 인스턴스인데요.\n\n- **키(key)**는 대체하고자 하는 HTML 태그 이름을 의미합니다.  \n- **값(value)**은 해당 HTML 태그 대신 렌더링할 컴포넌트를 지정하는 거죠.\n\n즉, 기본 HTML 요소를 내 마음대로 바꾸고 싶을 때 유용하게 쓸 수 있습니다. 예를 들어, `<h1>` 태그를 나만의 스타일이 입혀진 헤딩 컴포넌트로 교체할 수도 있고, `<a>` 태그를 커스텀 링크 컴포넌트로 바꿔서 새 창 열기 같은 기능을 쉽게 추가할 수도 있답니다.\n\n이걸 활용하면 MDX 문서 내에서 일관된 UI를 손쉽게 유지할 수 있고, 스타일이나 동작도 프로젝트에 맞게 맞춤 설정할 수 있어요! 많이 써먹어보세요~\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n> 참고할 점: 오버라이드가 없는 다른 컴포넌트들도 모두 전달해주는 것(즉, ...components)을 잊지 마세요.\n\n## 버전 히스토리\n\n| Version     | Changes           |\n|-------------|-------------------|\n| `v13.1.2`   | MDX 컴포넌트 추가 | \n\n여기서 MDX 컴포넌트란, Markdown과 React 컴포넌트를 함께 쓸 수 있게 해주는 기능이에요. 프로젝트에서 문서나 블로그 작성할 때 훨씬 유용하게 쓰이니까 꼭 한 번 써보시길 추천합니다!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":4},{"title":"Next.js 15에서 Middleware.js로 서버 데이터 처리하는 방법","description":"","date":"2025-04-22 02:41","slug":"2025-04-22-middlewarejs","content":"\n\n# middleware.js란?\n\nmiddleware.js(또는 middleware.ts)는 서버에서 요청이 완료되기 전에 중간에 끼어들어 특정 코드를 실행할 수 있도록 도와주는 파일이에요. 즉, 클라이언트가 서버에 요청을 보내면, 해당 요청을 처리하기 전에 이 미들웨어가 먼저 동작하게 되죠.\n\n이걸 쓰면 어떻게 좋냐고요? 예를 들어, 들어오는 요청에 따라 응답을 바꾸거나 리다이렉트 시키거나, 요청이나 응답 헤더를 수정하는 일이 가능해요. 심지어는 바로 응답을 보내버릴 수도 있답니다!\n\n미들웨어는 라우트가 렌더링되기 전에 작동하기 때문에, 인증(auth) 처리, 로깅(logging), 그리고 복잡한 리다이렉트 같은 서버 사이드 로직을 구현할 때 아주 유용하게 쓰여요.\n\n보통 프로젝트 루트에 `middleware.ts` 또는 `middleware.js` 파일을 만들어서 정의합니다. 이 위치는 `app`이나 `pages` 폴더와 같은 수준이거나, `src` 폴더 안일 수도 있어요.\n\n---\n\n### 참고로!\n\n- 미들웨어에서는 **응답을 직접 반환**하면 그 뒤에 라우트 렌더링은 안 되고, 그냥 그 응답이 바로 전송돼요.\n- 요청을 **리라이트(rewrite)** 하면 내부 경로 변경이, **리다이렉트(redirect)** 하면 클라이언트에게 다른 주소로 이동하라고 지시하는 의미예요.\n- 요청이나 응답 헤더를 자유롭게 조작할 수 있으니, 예를 들어 사용자 에이전트(user-agent)를 검사하거나 쿠키 작업도 가능합니다.\n\n이러면 서버가 좀 더 똑똑해지고, 클라이언트에 맞춤형 응답을 줄 수 있어요!\n\n---\n\n필요하시다면 다음 글에서는 실제 코드 예제와 함께 미들웨어의 구체적인 사용법도 다뤄볼게요~!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서 middleware 작성할 때 기본적으로 export하는 함수는 단 하나여야 한다는 점, 알고 계셨나요? 오늘은 그 부분을 중심으로 간단하게 설명해 보려고 해요.\n\n```js\nimport { NextResponse, NextRequest } from 'next/server'\n \n// 이 함수는 요청을 가로채서 /about 경로 하위에 있는 모든 경로 요청을 /home 으로 리다이렉트 해줘요.\nexport function middleware(request: NextRequest) {\n  return NextResponse.redirect(new URL('/home', request.url))\n}\n \nexport const config = {\n  matcher: '/about/:path*',\n}\n```\n\n위 코드에서 핵심은 `middleware` 함수 하나만 export 하고 있다는 거예요. Next.js는 한 파일에서 여러 미들웨어 함수를 내보내는 것을 지원하지 않아요. 따라서 두 개 이상의 미들웨어가 필요한 경우엔 각각 따로 파일을 만들어야 하죠.\n\n그리고, `config` 객체의 `matcher` 속성은 어떤 경로에 이 미들웨어를 적용할지 정해주는 역할을 해요. 여기서는 `/about/` 경로 이하 모든 경로를 지정했죠. 참고로 `:path*` 부분은 와일드카드 같은 역할을 해서 하위 경로 전체를 포괄할 수 있어요.\n\n### 정리하면\n\n| 항목                 | 설명                                                  |\n|--------------------|-----------------------------------------------------|\n| 미들웨어 함수          | 꼭 하나만 export 해야 한다                               |\n| `matcher` 설정        | 어떤 URL 패턴에 대해 미들웨어를 실행할지 지정               |\n| 리다이렉션 처리         | `NextResponse.redirect` 로 요청을 원하는 경로로 보낼 수 있다  |\n\n이런 룰들은 Next.js 내부에서 미들웨어 처리 방식을 단순화하고, 성능 최적화를 위한 부분이에요. 프로젝트 설계 시 이 점 꼭 기억해 두시면 쓸데없는 에러를 예방할 수 있답니다.\n\n또한, 만약 복잡한 미들웨어 로직이 필요하다면 여러 파일로 분리하거나, 환경변수에 따라 미들웨어를 다르게 실행하도록 코드를 짜는 것도 좋은 전략이에요. \n\n다음에는 미들웨어에서 자주 쓰이는 다른 기능들도 한번 같이 살펴봐요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n// 기본 export 예제\nexport default function middleware(request) {\n  // 미들웨어 로직 작성\n}\n```\n\n### config 객체 (선택 사항)\n\n미들웨어 함수와 함께 config 객체를 export할 수도 있어요. 이 객체 안에는 `matcher`가 들어가는데, 이 matcher를 통해 미들웨어가 적용될 경로를 지정할 수 있습니다.\n\n#### matcher\n\nmatcher는 미들웨어가 실행될 URL 경로나 패턴을 지정하는 역할을 해요. 예를 들어, 특정 경로나 API 엔드포인트에만 미들웨어가 동작하도록 설정할 수 있죠.\n\n```js\nexport const config = {\n  matcher: ['/about/:path*', '/dashboard/:path*'],\n};\n```\n\n위 예시는 `/about`과 `/dashboard`로 시작하는 모든 하위 경로에 미들웨어가 적용된다는 뜻이에요.\n\n참고로, matcher에 지정할 수 있는 패턴은 Next.js의 라우팅 규칙과 비슷해서 익숙하시다면 편하게 쓸 수 있을 거예요.\n\n만약 더 세밀한 조건이 필요하다면, 직접 미들웨어 안에서 request 객체를 검사하는 방법도 있어요. 예를 들어, 쿠키나 헤더에 따라 동작을 조절할 수도 있죠.\n\n미들웨어 설정 시 알아두면 좋은 팁!\n- `matcher`를 구체적으로 지정하면 불필요한 미들웨어 실행을 줄여서 퍼포먼스를 개선할 수 있어요.\n- 여러 경로를 배열로 전달할 수 있으니 한꺼번에 관리하기 편합니다.\n- 잘못된 matcher 패턴은 미들웨어가 의도치 않게 작동하지 않을 수 있으니, 꼭 테스트해보세요!\n\n다음에는 미들웨어 내부에서 실제 request 요청을 다루는 법과 응답 처리 방법에 대해 이야기해볼게요. 그럼 같이 공부해봐요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n`matcher` 옵션은 Middleware가 특정 경로에서만 실행되도록 설정할 때 사용해요. 쉽게 말해, 이 옵션을 통해 ‘어떤 경로에 Middleware를 적용할지’를 정할 수 있다는 뜻이죠.\n\n그 방법은 크게 세 가지예요:\n\n- **단일 경로 지정:**  \n  그냥 문자열로 경로를 적으면 돼요. 예를 들어, `/about`이면 `/about` 경로에서만 Middleware가 실행됩니다.\n\n- **여러 경로 지정:**  \n  배열을 사용해서 여러 경로를 한 번에 지정할 수 있어요.  \n  예시) `matcher: ['/about', '/contact']` 이렇게 하면 `/about`과 `/contact` 두 경로 모두 적용됩니다.\n\n- **정규 표현식(Regex) 사용:**  \n  더 정교한 경로 필터링이 필요할 땐 정규식도 사용할 수 있어요.  \n  예를 들면,  \n  js\n  matcher: ['/((?!api|_next/static|_next/image|.*\\\\.png$).*)']\n  \n  이렇게 하면 `api`, `_next/static`, `_next/image` 폴더나 `.png` 파일 경로는 제외하고 나머지 경로에만 Middleware를 적용해요.  \n  정규 표현식의 부정형 전방탐색(negative lookahead)을 활용해 특정 경로나 파일 형식을 꼼꼼히 걸러낼 수 있답니다.\n\n그리고 `matcher` 옵션에는 배열 안에 객체 형식으로 경로를 더 세분화해서 지정할 수도 있는데, 이 객체에는 다음과 같은 키들이 있어요:\n\n| 키 이름      | 설명                                               |\n|--------------|----------------------------------------------------|\n| `src`        | 적용할 경로를 정의 (문자열 또는 정규식)             |\n| `methods`    | 적용할 HTTP 메소드 배열 (예: `['GET', 'POST']`)     |\n| `has`        | 요청에 특정 헤더, 쿠키, 쿼리 파라미터가 있는지 조건 지정 |\n| `missing`    | 요청에 특정 헤더, 쿠키, 쿼리 파라미터가 없는지 조건 지정 |\n\n이런 식으로 복잡한 조건을 걸 수 있어서, 예를 들어 `POST` 요청이고 특정 쿠키가 있을 때만 Middleware를 적용하는 것도 가능하답니다.\n\n---\n\n### 추가 팁  \nRouter 미들웨어를 효과적으로 사용하려면, 불필요하게 모든 경로에 Middleware가 실행되지 않도록 `matcher`를 잘 설정하는 게 좋아요. 안 그러면 성능에 영향이 있을 수 있거든요! 또한, Next.js에서 자주 쓰는 `_next/static` 같은 내부 리소스 경로들은 보통 Middleware 대상에서 제외하는 게 일반적이에요.\n\n이 정도만 잘 활용해도 경로별로 딱 맞는 Middleware 적용이 훨씬 수월해질 거예요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n요즘 웹 개발할 때, 특정 요청 경로에 맞춰서 로직을 처리하거나 미들웨어를 적용하는 경우가 많죠? 이번에 소개할 내용은 이런 요청 경로 매칭을 세밀하게 조정할 수 있는 설정 방법이에요.\n\n---\n\n### 주요 옵션 설명\n\n| 옵션명     | 설명                                                                                           |\n|------------|------------------------------------------------------------------------------------------------|\n| source     | 요청 경로를 매칭하는 경로 또는 패턴이에요. 문자열로 직접 지정하거나 복잡한 패턴을 지정할 수 있어요.             |\n| regexp     | 정규표현식으로 source를 세밀하게 조절할 수 있어요. 포함하거나 제외할 경로를 더욱 정확하게 조절할 때 쓸 수 있죠. |\n| locale     | 불리언 값인데, false로 하면 로케일(언어 설정 등)을 매칭에서 무시해요. 기본값은 true로 다루는 경우가 많습니다.  |\n| has        | 요청 헤더, 쿼리 파라미터, 쿠키 등의 특정 요소가 있을 때 조건을 걸고 싶을 때 사용해요.                            |\n| missing    | 반대로, 헤더나 쿠키 같은 특정 요소가 없을 때만 동작하도록 조건을 걸고 싶을 때 쓰면 좋아요.                         |\n\n---\n\n### 실제 예제\n\n```js\nexport const config = {\n  matcher: [\n    {\n      source: '/api/*',\n      regexp: '^/api/(.*)',\n      locale: false,\n      has: [\n        { type: 'header', key: 'Authorization', value: 'Bearer Token' },\n        { type: 'query', key: 'userId', value: '123' },\n      ],\n      missing: [{ type: 'cookie', key: 'session', value: 'active' }],\n    },\n  ],\n}\n```\n\n- `/api/*` 경로에 대해 매칭합니다.\n- `regexp`로 좀 더 정교하게 `/api/` 뒤에 어떤 값이 오든 매칭하도록 했어요.\n- 로케일 기반 매칭은 무시(`locale: false`)하고요.\n- 요청 헤더에 `Authorization`이 `'Bearer Token'` 이고, 쿼리 파라미터에 `userId=123` 이 있어야 합니다.\n- 그리고 `session` 쿠키가 없을 때만 이 설정이 적용되는 거죠.\n\n---\n\n### 참고로!\n\n- `has`와 `missing` 조건은 다중으로 걸 수 있으니, 복합 조건 처리도 편리하게 구성할 수 있습니다.\n- `regexp` 쓰면 경로를 한 층 더 정교하게 제어할 수 있어서, 간단한 경로나 특수 문자 포함 경로도 문제없이 처리 가능해요.\n- `locale` 설정은 멀티랭귀지 사이트 만들 때 유용하고, 단일 언어 사이트는 보통 false로 두고 쓰기도 합니다.\n\n이렇게 매칭 설정을 잘 사용하면, Next.js나 비슷한 프레임워크에서 요청 경로 조건에 맞는 미들웨어나 특정 API 처리 로직을 깔끔하게 관리할 수 있답니다.\n\n---\n\n다음 글에서는 이 설정을 실제 미들웨어에 어떻게 적용할 수 있는지, 그리고 성능 최적화 팁도 함께 다뤄볼게요! 궁금한 점 있으면 댓글로 남겨주세요~\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nMiddleware를 정의할 때 기본 내보내기 함수는 하나의 매개변수인 request를 받습니다. 이 request는 NextRequest의 인스턴스로, 들어온 HTTP 요청을 나타내죠.\n\n```js\nimport type { NextRequest } from 'next/server'\n\nexport function middleware(request: NextRequest) {\n  // 여기에 Middleware 로직을 작성하세요\n}\n```\n\n> 알아두면 좋은 점:\nNextRequest는 Next.js Middleware에서 들어오는 HTTP 요청을 나타내는 타입이에요. 반면에 NextResponse는 HTTP 응답을 조작하고 돌려보낼 때 사용하는 클래스로 구분되어 있습니다.\n\n## NextResponse\n\nNextResponse는 Middleware 안에서 주로 클라이언트에게 반환할 응답을 조작할 때 사용합니다. 예를 들어, 요청을 리다이렉트하거나 쿠키를 설정하는 등의 작업을 할 수 있죠.\n\n간단한 예시를 보면:\n\n```js\nimport { NextResponse } from 'next/server'\n\nexport function middleware(request) {\n  // 특정 경로로 리다이렉트하기\n  if (request.nextUrl.pathname === '/old-path') {\n    return NextResponse.redirect(new URL('/new-path', request.url))\n  }\n  return NextResponse.next()\n}\n```\n\n이렇게 요청된 경로가 `/old-path`라면 `/new-path`로 리다이렉트 시키고, 그렇지 않으면 다음 미들웨어나 라우터로 요청을 넘기게 됩니다.\n\n또한 NextResponse를 이용해 쿠키를 설정할 수도 있어요. 예를 들어:\n\n```js\nimport { NextResponse } from 'next/server'\n\nexport function middleware(request) {\n  const response = NextResponse.next()\n  response.cookies.set('my-cookie', 'my-value', { path: '/', maxAge: 60 * 60 * 24 }) // 1일간 유지되는 쿠키\n  return response\n}\n```\n\n위 예시에서는 응답에 'my-cookie'라는 이름의 쿠키를 추가하는 거죠.\n\nMiddleware에서 NextRequest와 NextResponse의 역할을 잘 구분해두면 효과적인 요청 처리 및 응답 제어가 가능하니 꼭 기억해두세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n미들웨어(Middleware)는 NextResponse 객체를 사용할 수 있는데, 이 객체는 Web Response API를 확장한 거예요. NextResponse 객체를 반환하면 쿠키를 직접 조작하거나, 헤더를 설정하고, 리다이렉트를 구현하거나, 경로를 다시 쓸 수 있어서 정말 유용하답니다.\n\n> 참고로 리다이렉트를 구현할 땐 NextResponse.redirect 대신 Response.redirect를 써도 된다는 점! 상황에 맞게 골라 쓰시면 돼요.\n\n## 실행 환경(Runtime)\n\n미들웨어는 Edge 런타임에서만 동작해요. 그래서 Node.js 런타임에서는 사용할 수 없다는 점, 꼭 기억해주세요.\n\n---\n\n### 미들웨어에서 NextResponse를 쓰면 좋은 점\n\n- 쿠키 설정/삭제가 편리해요.\n- 헤더를 자유자재로 조작할 수 있어서 보안이나 캐싱 정책 등을 설정할 때 유리하죠.\n- 경로 재작성(Rewrite) 기능으로 SEO 최적화나 사용자 맞춤 라우팅이 쉬워져요.\n\nEdge 런타임이라는 건, 쉽게 말해 요청이 사용자와 가까운 서버(Edge)에서 빠르게 처리된다는 뜻인데요. 그래서 미들웨어가 빠른 응답 속도에 도움을 줘서 좋은 사용자 경험을 만들 수 있답니다.\n\n필요할 때 미들웨어와 NextResponse를 적절히 활용해보세요! 개발할 때 꽤 큰 힘이 되어줄 거예요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 버전 히스토리 (Version History)\n\n| 버전       | 변경 사항                                                                                         |\n|------------|--------------------------------------------------------------------------------------------------|\n| `v13.1.0`  | 고급 미들웨어 플래그(Advanced Middleware flags) 추가                                           |\n| `v13.0.0`  | 미들웨어가 요청 헤더, 응답 헤더를 수정할 수 있고, 응답도 직접 보낼 수 있게 개선                  |\n| `v12.2.0`  | 미들웨어가 안정화됨. 자세한 업그레이드 가이드는 [여기](https://nextjs.org/docs/messages/middleware-upgrade-guide) 참고 |\n| `v12.0.9`  | Edge Runtime에서 절대 URL 강제 적용 ([관련 PR](https://github.com/vercel/next.js/pull/33410))                  |\n| `v12.0.0`  | 미들웨어(Beta) 기능 추가                                                                         |\n\n---\n\n*잠깐!*\n\n여기서 말하는 '미들웨어'는 Next.js에서 API 요청과 응답 사이에 원하는 로직을 끼워 넣을 수 있는 기능이에요. 예를 들어 로그인 검증, A/B 테스트, 사용자 맞춤 리디렉션 등을 처리할 때 아주 유용하답니다.\n\n그리고 `v13.0.0`부터는 요청과 응답 헤더를 수정하거나 직접 응답을 보내는 등 훨씬 더 강력한 제어가 가능해져서, 미들웨어를 활용하는 범위가 정말 넓어졌어요.\n\n버전이 올라가면서 미들웨어가 안정화되고 기능도 점점 확장되고 있으니, 현재 개발 중인 프로젝트에 맞춰 적절히 선택해서 쓰시면 좋겠네요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":12},{"title":"Nextjs 15 에서 레이아웃 잡는 방법 (layout.js)","description":"","date":"2025-04-22 02:39","slug":"2025-04-22-layoutjs","content":"\n\n# layout.js 이해하기\n\nNext.js에서 `layout.js` 파일은 애플리케이션의 **레이아웃(화면 구성 틀)**을 정의하는 데 사용돼요. 쉽게 말해, 여러 페이지에서 공통적으로 사용되는 UI 구조를 한 곳에 모아서 관리할 수 있게 해주죠.\n\n예를 들어, 아래 코드를 살펴볼게요:\n\n```js\nexport default function DashboardLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return <section>{children}</section>\n}\n```\n\n여기서 `DashboardLayout` 컴포넌트는 내부에 들어올 콘텐츠(여기서는 `children`)를 `<section>` 태그 안에 감싸서 렌더링해요. 이 의미는, `DashboardLayout` 위에 두고 싶거나 반복적으로 쓰이는 헤더, 사이드바 같은 요소를 여기에 추가하면 더 편하게 관리할 수 있다는 점이죠.\n\n---\n\n## 루트 레이아웃 (Root Layout)이란?\n\nNext.js 13버전부터는 앱 폴더 안에 `layout.js` 파일을 두는 게 많아졌는데, 그 중에서도 **루트 레이아웃**은 가장 최상단에 위치하는 레이아웃입니다. 이 루트 레이아웃은 앱 전체에 공통으로 적용할 `html`, `body` 태그를 정의하고 전역 스타일, 폰트, 메타데이터, 그리고 공통 UI(예: 네비게이션 바)를 배치할 때 사용돼요.\n\n예를 들어, 이렇게 작성할 수 있죠:\n\n```js\nexport default function RootLayout({ children }) {\n  return (\n    <html lang=\"ko\">\n      <body>\n        {/* 공통 헤더 */}\n        <header>\n          <nav>내 네비게이션 바</nav>\n        </header>\n        \n        {/* 페이지 컨텐츠 */}\n        <main>{children}</main>\n        \n        {/* 공통 푸터 */}\n        <footer>© 2024 내사이트</footer>\n      </body>\n    </html>\n  )\n}\n```\n\n이렇게 하면, 모든 페이지가 이 루트 레이아웃 안에서 렌더링되고, 중복되는 UI 코드를 매번 작성하지 않아도 돼서 유지보수가 훨씬 쉬워집니다.\n\n---\n\n## 추가로 알아두면 좋은 팁\n\n- **중첩 레이아웃(Nested Layout):** Next.js는 여러 개의 `layout.js` 파일을 각 폴더마다 만들 수 있어요. 예를 들어, `app/dashboard/layout.js`는 대시보드 구역에만 적용되는 레이아웃으로 설정할 수 있답니다.\n- **서버 컴포넌트:** 기본적으로 `layout.js`는 서버 컴포넌트로 동작해요. 그래서 클라이언트 전용 기능(이벤트 핸들러 등)은 `use client` 지시자를 따로 써서 클라이언트 컴포넌트로 만들어야 해요.\n- **스타일링:** 루트 레이아웃에 글로벌 CSS를 불러오거나, 구글 폰트 같은 외부 폰트를 적용하기 좋은 위치입니다.\n\n---\n\nNext.js의 레이아웃 시스템을 잘 활용하면 코드가 깔끔해지고, 프로젝트가 커져도 구조를 쉽게 관리할 수 있어요. 한 번 직접 만들어보고 중첩 레이아웃도 시험해보길 추천합니다! 😊\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n자, 이번에는 React 컴포넌트에서 자주 사용되는 RootLayout 예제를 살펴볼게요. 위 코드는 Next.js 13부터 도입된 새로운 app 디렉토리 구조에서 루트 레이아웃을 정의하는 기본적인 방법입니다.\n\n```tsx\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <body>{children}</body>\n    </html>\n  )\n}\n```\n\n이 컴포넌트는 부모 컴포넌트로부터 `children`이라는 prop을 받아서, 그 안에 어떤 하위 컴포넌트가 들어와도 감싸주는 역할을 합니다.\n\n## 주요 내용 정리\n\n| Props     | 타입                 | 설명                                   |\n| --------- | -------------------- | ------------------------------------ |\n| children  | React.ReactNode (필수) | 하위 컴포넌트나 JSX를 포함하는 prop   |\n\n### 추가로 알아두면 좋은 점!\n\n- `<html lang=\"en\">` 태그는 페이지 전체 언어 설정을 나타내서 SEO와 접근성 측면에서 매우 중요해요. 상황에 맞게 `lang` 속성을 적절히 바꿔주세요.\n- `RootLayout`은 모든 페이지에 공통적으로 적용되는 레이아웃이 들어가는 곳이에요. 예를 들어 네비게이션 바, 푸터, 글로벌 스타일 등을 넣을 수 있죠.\n- React에서 props 타입을 지정할 땐 보통 TypeScript를 사용해 이런 형태로 명시해 줍니다. 이를 통해 컴포넌트 사용 시 타입 안정성을 확보할 수 있어요.\n\n이 간단한 구조를 기반으로, 여러분만의 멋진 레이아웃을 만들어 보세요! 😊\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n레이아웃 컴포넌트는 children 프로퍼티를 받아야 하고, 이를 사용해서 렌더링해야 해요. 렌더링 시점에 children에는 현재 레이아웃이 감싸고 있는 라우트의 하위 세그먼트들이 들어오게 되죠. 주로 자식 레이아웃 컴포넌트(있다면)나 페이지 컴포넌트가 될 거예요. 그리고 상황에 따라 로딩(Loading)이나 에러(Error) 같은 특별한 파일들도 포함될 수 있답니다.\n\n---\n\n### params (선택사항)\n\nparams는 비동기적으로 동적 라우트 파라미터를 얻을 때 사용해요. 루트 세그먼트부터 현재 레이아웃까지의 경로에 해당하는 모든 동적 파라미터들을 객체 형태로 받아올 수 있죠.\n\n예를 들자면, 아래처럼 사용할 수 있어요:\n\n```js\nexport default async function Layout({\n  params,\n}: {\n  params: Promise<{ team: string }>\n}) {\n  const { team } = await params;\n  // 이제 team 변수를 사용해서 팀별 UI를 구성할 수 있어요\n}\n```\n\n---\n\n#### 여기서 알아두면 좋은 점!\n\n- Layout 컴포넌트가 children을 받아 렌더링하는 구조 덕분에 중첩된 레이아웃을 쉽게 다룰 수 있어요.\n- 비동기 params를 통해 페이지마다 필요한 데이터를 라우팅 단계에서 미리 받아와서, UI를 더 빠르게 그리고 사용자 맞춤형으로 보여줄 수 있답니다.\n- 이 방식을 사용하면 레이아웃별로 공통 요소(헤더, 사이드바 등)를 한 번만 선언하고, 그 안에 컨텐츠를 중첩해서 관리할 수 있어 유지보수가 훨씬 용이해져요.\n\n이런 구조를 이해하면, Next.js 같은 최신 프레임워크의 라우팅과 레이아웃 시스템을 훨씬 더 능숙하게 다룰 수 있게 됩니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 Next.js의 동적 라우팅 예시입니다. 각 경로에 해당하는 URL과 넘겨받는 params 값을 보여주고 있어요.\n\n| Example Route                    | URL             | params                       |\n| ------------------------------ | --------------- | ---------------------------- |\n| `app/dashboard/[team]/layout.js` | `/dashboard/1`  | `Promise<{ team: '1' }>`     |\n| `app/shop/[tag]/[item]/layout.js` | `/shop/1/2`    | `Promise<{ tag: '1', item: '2' }>` |\n| `app/blog/[...slug]/layout.js`   | `/blog/1/2`    | `Promise<{ slug: ['1', '2'] }>`    |\n\n여기서 중요한 점! `params`는 Promise 형태로 전달되기 때문에 async/await를 사용하거나 React의 `use` 함수 같은 비동기 핸들링이 필요합니다.  \nNext.js 버전 14 및 이전에서는 `params`가 동기적 prop이었는데, 버전 15부터는 비동기 형태로 바뀌었어요. 다만 아직 하위 호환성을 위해 동기식 접근도 가능하지만, 앞으로는 deprecated 될 예정이라 미리 비동기로 바꿔서 사용하는 게 좋습니다.\n\n---\n\n### 루트 레이아웃 (Root Layout)\n\nNext.js의 앱 디렉터리 구조에서는 반드시 최상위에 `app/layout.js` 파일이 있어야 합니다. 이 파일이 애플리케이션의 공통 레이아웃을 담당하며, 페이지 전반에 걸쳐 공통적으로 적용할 UI(헤더, 푸터, 네비게이션 등)를 넣는 곳이죠.\n\n---\n\n추가 팁!  \n라우터 파라미터를 Promise로 받는다는 점이 처음엔 헷갈릴 수 있지만, 이 덕분에 서버 사이드 렌더링 환경에서 비동기로 데이터를 받아와 처리하는데 유연성을 얻게 됩니다. `layout.js`뿐 아니라, 각 컴포넌트에서 비동기 작업을 자연스럽게 하도록 돕는 구조라는 걸 기억하세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서 Root Layout을 설정할 때 몇 가지 꼭 알아둬야 할 핵심 포인트들이 있어요. 제가 직접 코드를 보면서 정리해봤는데요, 실제로 개발할 때 참고하면 딱 좋을 것 같아서 공유합니다!\n\n```tsx\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html>\n      <body>{children}</body>\n    </html>\n  )\n}\n```\n\n### 1. `html`과 `body` 태그는 Root Layout에서 꼭 정의해야 해요\nRoot Layout은 애플리케이션 전체의 뼈대가 되기 때문에, `<html>`, `<body>` 태그를 직접 작성해줘야 합니다.  \n그런데 이 밖에 `head` 태그나 그 안에 들어가는 `title`, `meta` 같은 요소들은 직접 넣으면 안 된다는 점!  \n이걸 next.js에서 **Metadata API**라는 걸로 관리해줘서, 머리 정보들을 자동으로 스트리밍 처리하고 중복 제거까지 해준답니다. 이게 꽤 편하니까 꼭 활용해 보세요.\n\n### 2. `head` 태그는 **Metadata API** 사용하기\n직접 `head` 태그에 `title`, `meta` 이런 거 넣으면 안 되고, next.js가 제공하는 Metadata API를 써서 데이터 설정해야 해요.  \n예를 들어, layout이나 page에서 `export const metadata = { title: '홈페이지' }` 이렇게 지정할 수 있습니다.  \n이 방식 덕분에 로딩 속도는 빨라지고 SEO도 좋아지죠!\n\n### 3. 여러 Root Layout 만들기! (Route Groups)\nRoutes를 그룹으로 묶어서 각 그룹마다 Root Layout을 다르게 만들 수 있어요.  \n예를 들어, 쇼핑몰 영역과 블로그 영역이 각각 `app/(shop)/layout.js`와 `app/(marketing)/layout.js`를 쓴다고 하면,  \n이 두 구역 사이를 이동할 때는 완전한 페이지 리로드가 발생해요. (즉, 클라이언트 사이드 네비게이션이 아니라 서버에서 다시 불러오는 방식)  \n이 점은 여러 개의 Root Layout을 사용할 때 발생하는 특성입니다.\n\n---\n\n## 궁금증 해결 : Layout에서 Request 객체에 접근할 수 있나요?\n\nRoot Layout이나 Layout 컴포넌트에서 직접 HTTP Request 객체에 접근하는 건 불가능합니다.  \nNext.js 앱 디렉토리(app router)는 서버 컴포넌트 기반이고, 서버 컴포넌트에서는 요청 정보를 직접 다루는 게 제한돼 있거든요.\n\n만약 요청에 포함된 데이터(query, headers, cookies 등)를 사용하고 싶다면, `fetch` 함수나 서버 컴포넌트에서 사용할 수 있는 다양한 Next.js API를 활용해서 데이터를 미리 받아오는 패턴을 주로 사용합니다.\n\n예를 들어:\n\n```tsx\nexport default async function RootLayout({ children }) {\n  const res = await fetch('https://api.example.com/data');\n  const data = await res.json();\n\n  return (\n    <html>\n      <body>\n        {/* 여기서 data를 활용할 수 있어요 */}\n        {children}\n      </body>\n    </html>\n  );\n}\n```\n\n또한, 특정 요청 헤더나 쿠키 등이 필요하면 Next.js가 제공하는 `cookies()`나 `headers()` 함수를 사용할 수도 있으니 참고하세요.  \n\n---\n\nNext.js 13의 앱 라우터 구조가 처음엔 조금 낯설지만, 이런 Root Layout 기본 규칙을 이해하고 나면 훨씬 유연하게 프로젝트를 구성할 수 있답니다!  \n궁금한 점 있으면 언제든 말씀해 주세요. 개발 힘내시고 좋은 하루 보내세요~ 😊\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서 레이아웃(layout)은 원시 요청 객체(raw request object)에 직접 접근할 수 없도록 의도적으로 제한되어 있습니다. 대신, 서버 전용 함수(server-only functions)를 통해 헤더(headers)와 쿠키(cookies) 정보는 가져올 수 있어요.\n\n이유는 간단해요. 레이아웃은 페이지 간 이동 시 불필요한 연산을 줄이기 위해 한 번 렌더링된 뒤 재사용될 수 있도록 설계되어 있어요. 만약 레이아웃에서 매 요청마다 원시 요청 객체에 접근해 무거운 작업을 수행하게 된다면, 그만큼 성능에 악영향이 가기 때문이죠.\n\n또한, 이런 제한 덕분에 레이아웃이 여러 페이지에서 일관적이고 예측 가능한 방식으로 동작하도록 보장합니다. 개발자 입장에선 디버깅도 훨씬 간편해지는 장점이 있어요.\n\n### 참고로, 레이아웃은 searchParams(검색 파라미터)도 직접 받지 않습니다.\n\n이 부분 꼭 알아두시면 좋아요. 만약 query string 정보를 레이아웃에서 활용하고 싶다면, 서버 함수에서 받아서 헤더나 쿠키에 저장하거나, 페이지 컴포넌트 쪽에서 처리하는 방식을 생각해 볼 수 있습니다.\n\n---\n\n### 간단 정리 테이블\n\n| 제한 사항                    | 이유 및 설명                                                  |\n|-----------------------------|-----------------------------------------------------------|\n| 원시 요청 객체 접근 불가      | 렌더링 성능 최적화와 일관성 있는 레이아웃 동작 보장               |\n| 헤더와 쿠키는 서버 함수 통해 접근 가능 | 필요한 요청 정보만 안전하게 접근할 수 있도록                       |\n| 레이아웃은 검색 파라미터 수신 불가 | 검색 파라미터는 페이지에서 처리하거나 서버 함수로 받아야 함            |\n\n이런 구조를 이해하면 Next.js 레이아웃을 설계할 때 어디서 어떤 정보를 받아서 처리해야 하는지 명확해져서 개발이 훨씬 수월해집니다. 필요할 땐 서버 함수 잘 활용해서 헤더, 쿠키 같은 정보만 쏙쏙 뽑아 쓰세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nPages와 달리 Layout 컴포넌트는 searchParams props를 받지 않아요. 그 이유는, 공통 레이아웃(shared layout)은 페이지가 이동해도 재렌더링되지 않기 때문에, 만약 searchParams를 받는다면 이전 네비게이션의 값이 그대로 남아있어서 최신 상태가 아니게 될 수 있기 때문이죠.\n\nNext.js에서 클라이언트 사이드 네비게이션을 할 때, 공통 레이아웃 아래의 페이지 일부만 자동으로 렌더링해줘서, 예를 들어 아래와 같은 디렉터리 구조가 있다고 할 때:\n\n\ndashboard/\n  ├── layout.tsx\n  ├── settings.tsx\n  └── analytics.tsx\n\n\n`dashboard/layout.tsx`는 `/dashboard/settings`와 `/dashboard/analytics` 두 경로 모두에 걸친 공통 레이아웃으로 작동합니다. 이 말은, 사용자가 `/dashboard/settings`에서 `/dashboard/analytics`로 이동해도 `dashboard/layout.tsx`는 다시 렌더링되지 않는다는 거죠.\n\n즉, 공통 레이아웃은 한 번 렌더링한 뒤 유지되어서 불필요한 렌더링 부담이 줄어들고, 페이지 전환이 더 빠르게 느껴지게 돼요.\n\n---\n\n그리고 참고로, 만약 공통 레이아웃에서 현재 URL의 query(=searchParams)를 꼭 사용해야 한다면, 레이아웃 내부가 아니라 개별 페이지 컴포넌트 내에서 `useSearchParams()` 같은 React 훅을 활용하는 게 좋아요. 그쪽이 항상 최신 URL 상태를 반영할 수 있답니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\"/dashboard/settings\"에서 \"/dashboard/analytics\"로 이동할 때, \"/dashboard/analytics/page.tsx\"는 서버에서 다시 렌더링이 되지만, \"dashboard/layout.tsx\"는 두 경로에서 공통으로 사용하는 레이아웃 컴포넌트라서 다시 렌더링되지 않습니다.\n\n이런 최적화 덕분에, 공통 레이아웃을 공유하는 페이지 간 이동 시에는 전체 경로를 다시 그릴 필요 없이, 페이지 단위의 데이터 페칭과 렌더링만 수행되기 때문에 훨씬 빠른 네비게이션이 가능합니다. 즉, 레이아웃까지 포함한 전체 경로가 다시 렌더링되면 시간이 더 걸리지만, 공통 레이아웃이 그대로 유지되니 성능이 더 좋아지는 거죠.\n\n하지만 여기서 주의할 점! layout.tsx가 다시 렌더링되지 않으니, 이 레이아웃 컴포넌트에 있는 searchParams prop은 navigation 후에 구버전(stale)이 될 수 있습니다.\n\n그래서 검색 파라미터가 필요할 땐, 레이아웃에서 바로 쓰지 말고 아래 두 가지 방법 중 하나를 이용하는 걸 추천해요.\n\n1. Page 컴포넌트에서 전달받는 최신 searchParams prop을 사용하기\n2. 레이아웃 내 클라이언트 컴포넌트에서 useSearchParams 훅을 사용해서 최신값을 받아오기\n\n이렇게 하면 클라이언트에서 렌더링될 때 최신 searchParams를 쓸 수 있어 데이터가 꼬이는 문제를 예방할 수 있답니다.\n\n---\n\n**tip!**\n\n- 클라이언트 컴포넌트에서 `useSearchParams`를 쓸 때는 `\"use client\"` 지시어를 꼭 선언해야 해요.\n- 만약 레이아웃이 공통 상태나 데이터를 많이 관리한다면, 이런 최적화가 큰 차이를 만들어낼 수 있어요.\n- Next.js 앱 디렉토리 구조에서는 이런 레이아웃 재사용과 부분 렌더링 최적화가 핵심이니 꼭 이해해두시면 좋아요!\n\n더 궁금한 점 있으면 편하게 물어봐 주세요~\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 레이아웃(Layouts)에서 pathname에 접근할 수 없는 이유\n\nNext.js에서 레이아웃은 기본적으로 **서버 컴포넌트(Server Components)**로 동작하는데요, 이게 왜 문제가 되냐면 클라이언트 사이드 네비게이션(페이지 간 이동) 시에 레이아웃이 다시 렌더링되지 않아요.  \n즉, `pathname` 같은 네비게이션 상태가 바뀌더라도 레이아웃은 리렌더링하지 않기 때문에, `pathname` 정보가 실제와 다르게 **stale(오래된 정보)**가 될 수 있습니다.\n\n그렇다고 레이아웃을 매번 새로 서버에서 받아오면 캐싱의 이점도 날아가고, RSC(Server Components) 페이로드 크기도 커져서 비효율적이겠죠.\n\n---\n\n### 그럼 어떻게 해야 하나요?\n\n이럴 때는 `pathname`을 필요로 하는 부분의 로직을 **클라이언트 컴포넌트(Client Component)**로 분리하는 방법이 좋아요. 클라이언트 컴포넌트는 페이지가 네비게이션할 때마다 리렌더링 되지만, 서버에서 다시 받아오진 않기 때문에 최신의 `pathname` 값을 바로바로 사용할 수 있어요.\n\nNext.js는 `usePathname` 같은 훅도 제공해서 현재 경로를 쉽게 알 수 있게 해줍니다.\n\n---\n\n### 예제 코드\n\n```jsx\nimport { ClientComponent } from '@/app/ui/ClientComponent'\n\nexport default function Layout({ children }: { children: React.ReactNode }) {\n  return (\n    <>\n      <ClientComponent />\n      {/* 여기에 레이아웃의 다른 UI들 */}\n      <main>{children}</main>\n    </>\n  )\n}\n```\n\n`ClientComponent` 안에서는 이렇게 쓸 수 있겠죠:\n\n```jsx\n\"use client\"\nimport { usePathname } from 'next/navigation'\n\nexport function ClientComponent() {\n  const pathname = usePathname()\n\n  return <div>현재 경로: {pathname}</div>\n}\n```\n\n---\n\n### 정리하며 드리는 팁!\n\n- **레이아웃에서 서버 컴포넌트와 클라이언트 컴포넌트를 적절히 나누자**  \n  너무 많은 상태나 UI를 클라이언트 컴포넌트로 두면 서버 컴포넌트의 장점이 줄지만, 라우팅 상태처럼 자주 변하는 데이터는 클라이언트 컴포넌트가 적절해요.\n  \n- **`usePathname` 외에도 `useSearchParams`**, `useRouter` 같은 훅도 비슷한 이유로 클라이언트 컴포넌트에서 써야 해요.\n\n- **최신 Next.js는 서버 컴포넌트와 클라이언트 컴포넌트를 잘 섞어 쓰는 패턴을 권장**하니 이를 염두에 두고 컴포넌트를 설계하면 더 편하고 최적화된 앱을 만들 수 있습니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n경로 패턴을 다룰 때, 흔히 사용하는 방법 중 하나가 바로 params(props)를 활용하는 거예요.\n\n좀 더 구체적인 내용과 예시는 아래 'Examples' 섹션을 참고하면 도움이 될 거예요.\n\n## 예시\n\n### params를 이용해 콘텐츠를 보여주기\n\n이렇게 params를 활용하면 URL에서 특정 값을 파라미터로 받아서 동적으로 콘텐츠를 바꾸는 게 가능해져요. 예를 들어 사용자가 특정 아이템의 상세 페이지를 보게 할 때, URL에 ID를 넣고 그 ID에 맞는 정보를 렌더링할 수 있죠.\n\n기본적으로 params는 라우트에서 토큰화된 URL 조각들을 받아서 컴포넌트에 전달해주는 역할을 합니다. react-router 같은 라이브러리를 쓴다면 자연스럽게 사용할 수 있죠.\n\n다음 예시를 참고해볼게요:\n\n| URL | params | 설명 |\n|---|---|---|\n| /user/123 | { id: '123' } | 유저 아이디가 123인 페이지 보여주기 |\n| /product/456 | { productId: '456' } | 상품 상세 페이지를 productId에 맞게 보여주기 |\n\n이처럼 params를 잘 활용하면, 같은 컴포넌트가 다양한 경로 데이터를 받아 콘텐츠를 유동적으로 바꿔줄 수 있어서 프로젝트 관리하기 훨씬 편해진답니다. 필요하면 제가 더 실무 예제도 공유해드릴게요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n동적 라우트 세그먼트를 활용하면 params 프로퍼티를 통해 특정 콘텐츠를 보여주거나 가져올 수 있어요.\n\n```jsx\nexport default async function DashboardLayout({\n  children,\n  params,\n}: {\n  children: React.ReactNode\n  params: Promise<{ team: string }>\n}) {\n  const { team } = await params\n \n  return (\n    <section>\n      <header>\n        <h1>Welcome to {team}'s Dashboard</h1>\n      </header>\n      <main>{children}</main>\n    </section>\n  )\n}\n```\n\n위 예제는 Next.js에서 동적 세그먼트를 받고, 그 파라미터를 비동기(await)로 풀어서 사용하는 모습이에요. 여기서 `params`는 `{ team: string }` 형태라고 타입이 지정돼 있죠.\n\n---\n\n### 클라이언트 컴포넌트에서 params 읽기\n\n서버 컴포넌트에서는 async/await로 params를 다룰 수 있어요. 하지만 클라이언트 컴포넌트는 async 함수를 지원하지 않아서 직접 params를 await할 수 없죠. 이때는 React의 `use` 훅을 사용해서 Promise를 처리할 수 있는데, 다음과 같이 활용해요:\n\n```jsx\n'use client'\n\nimport { use } from 'react';\n\nexport default function Dashboard({ paramsPromise }: { paramsPromise: Promise<{ team: string }> }) {\n  const { team } = use(paramsPromise);\n\n  return <h1>Welcome to {team}'s Dashboard</h1>;\n}\n```\n\n여기서 `use` 훅은 React 18부터 실험적으로 지원하는 훅인데, Promise를 직접 커버할 수 있어서 비동기 데이터를 자연스럽게 렌더링할 수 있게 도와줍니다.\n\n---\n\n**추가 팁!**\n\n- Next.js 13의 `app` 디렉터리를 쓸 때는 동적 라우트를 만들면 자동으로 params가 들어오고, 그걸 서버 컴포넌트에서 바로 사용할 수 있어서 편리해요.\n- 클라이언트 컴포넌트에서 async 로직을 처리할 때는 보통 `useEffect`와 상태관리를 쓰지만, `use` 훅을 쓰면 좀 더 깔끔한 코드가 될 수 있어요.\n- 다만 `use` 훅은 아직 실험적 기능이라 프로젝트에 맞게 신중히 사용해야 합니다.\n\n이런 방식으로 동적 라우트를 활용해서 사용자 맞춤 대시보드나 상세 페이지를 쉽게 구현할 수 있답니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n'use client'\n\nimport { use } from 'react'\n\nexport default function Page({\n  params,\n}: {\n  params: Promise<{ slug: string }>\n}) {\n  const { slug } = use(params)\n}\n```\n\n## 버전 히스토리\n\n| 버전           | 변경 사항                                                                                  |\n| -------------- | ----------------------------------------------------------------------------------------- |\n| `v15.0.0-RC`   | `params`가 이제 Promise로 변경되었습니다. [codemod](https://nextjs.org/docs/app/guides/upgrading/codemods#150) 도 제공됩니다. |\n| `v13.0.0`      | `layout`이 새로 도입되었습니다.                                                            |\n\n---\n\n위 코드를 보면 `params`가 Promise 형태로 전달되고, React 18에서 도입된 `use` 훅을 사용해서 그 Promise를 직접 해결(resolve)하는 방식을 사용하고 있네요. \n\n이 방식은 서버 컴포넌트에서 비동기 데이터를 쉽게 처리할 수 있게 해줘서, 데이터 로딩 코드를 더 깔끔하게 작성할 수 있다는 장점이 있어요.\n\n참고로 `use` 훅은 아직 React 공식 API가 아니기 때문에, Next.js 같은 프레임워크에서 실험적으로 지원하는 기능이에요. 그러니 프로젝트에 적용할 때는 호환성을 꼭 확인하는 게 좋아요!\n\n그리고 `params`가 Promise로 바뀐 이유는 서버 컴포넌트가 비동기적으로 라우팅 파라미터를 처리할 수 있도록 하기 위해서인데요, 이를 통해 더 유연한 데이터 페칭과 페이지 렌더링이 가능해졌답니다. \n\n더 자세한 내용은 Next.js 공식 문서나 업그레이드 가이드를 참고해보세요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":18},{"title":"Next.js 15에서 instrumentation-client.js 로 웹사이트 분석 도구 사용하기","description":"","date":"2025-04-22 02:38","slug":"2025-04-22-instrumentation-clientjs","content":"\n\n# instrumentation-client.js\n\ninstrumentation-client.js|ts 파일은 여러분의 애플리케이션 프런트엔드 코드가 실행되기 전에 모니터링이나 분석 코드를 추가할 수 있게 해줍니다. 이를 통해 성능 추적, 오류 감지 같은 클라이언트 측 관찰성 도구들을 쉽고 빠르게 셋업할 수 있죠.\n\n사용 방법도 아주 간단해요! 파일을 애플리케이션 루트 폴더나 `src` 폴더 안에 넣기만 하면 준비 완료입니다.\n\n## 사용법\n\n(여기서부터 구체적인 사용법을 이어서 작성하면 됩니다.)  \n\n이렇게 미리 모니터링 코드를 두면, 현장에서 발생하는 문제를 더 빨리 발견할 수 있고, 서비스 품질을 높이는데 큰 도움이 되니 꼭 활용해보세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n서버 사이드 계측(instrumentation)과 달리, 클라이언트 쪽에서는 특정 함수를 따로 export할 필요가 없어요. 그냥 원하는 파일 안에 모니터링 코드를 바로 작성해주시면 됩니다.\n\n```js\n// 퍼포먼스 모니터링 시작 시점 찍기\nperformance.mark('app-init')\n \n// 애널리틱스 초기화\nconsole.log('Analytics initialized')\n \n// 에러 추적 세팅\nwindow.addEventListener('error', (event) => {\n  // 에러 추적 서비스로 에러 데이터 전송\n  reportError(event.error)\n})\n```\n\n이렇게 간단히 작성할 수 있죠. \n\n참고로 `performance.mark()`는 브라우저의 성능 측정 API로, 특정 시점에 표시를 찍어서 나중에 성능 분석 자료로 활용할 수 있어요. 그리고 `window.addEventListener('error', ...)`를 사용하면 페이지 내에서 발생하는 자바스크립트 에러를 잡아내서 별도의 추적 시스템에 전송할 수 있어서 디버깅에 매우 유용합니다.\n\n---\n\n## 버전 히스토리\n\n| Version | Changes                         |\n|---------|--------------------------------|\n| v15.3   | `instrumentation-client` 도입  |\n\n`instrumentation-client`를 도입하면서 클라이언트 쪽에서도 더 쉽게 모니터링 코드 작성이 가능해졌어요. 이 부분 활용하면 애플리케이션 상태를 실시간으로 추적하거나 성능 병목을 빠르게 찾는 데 큰 도움이 됩니다.","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":2},{"title":"instrumentation.js로 웹사이트 성능 측정 도구 만들기","description":"","date":"2025-04-22 02:38","slug":"2025-04-22-instrumentationjs","content":"\n\n# instrumentation.js\n\ninstrumentation.js|ts 파일은 애플리케이션에 관찰 가능성(Observability) 도구를 통합하는 용도로 사용돼요. 이를 통해 애플리케이션의 성능과 동작을 추적할 수 있고, 실제 서비스 중에 발생하는 문제를 더 효과적으로 디버깅할 수 있답니다.\n\n사용법도 간단해요! 프로젝트 루트 디렉토리에 파일을 두거나, 만약 src 폴더를 사용한다면 그 안에 넣으면 되죠.\n\n## 파일에서 제공하는 주요 기능 (Exports)\n\n(여기에 실제로 어떤 내용이 export 되는지 명시되어야 하는데요, 이어서 있으면 같이 정리해보겠습니다.)\n\n---\n\n### 조금 더 알아두면 좋은 점!\n\n- 관찰 가능성 도구에는 여러 가지가 있는데, 예를 들어 로그 수집, 메트릭 수집, 트레이싱 등이 있어요. instrumentation.js를 통해 이런 도구들을 한 곳에 모아 효율적으로 관리할 수 있어요.\n- 실제 운영 환경에서 문제가 발생했을 때, 미리 설정한 instrumentation 덕분에 원인을 빠르게 파악할 수 있으니 개발, 운영 모두에 큰 도움이 된답니다.\n- TypeScript를 사용한다면 .ts 확장자를 사용해 타입 안정성을 더할 수도 있어요.\n\n다음에는 instrumentation.js 안에 어떤 코드가 들어가는지, 구체적인 예시를 하나씩 살펴보도록 할게요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### register (선택 사항)\n\nNext.js 서버가 새로 시작될 때 한 번 호출되는 `register` 함수를 파일에서 export할 수 있어요. 이 함수는 async 함수여도 되고, 주로 초기 설정이나 라이브러리 등록 같은 작업에 사용되죠.\n\n예를 들어, 아래처럼 OpenTelemetry를 연동하는 작업을 할 수 있어요:\n\n```js\nimport { registerOTel } from '@vercel/otel'\n \nexport function register() {\n  registerOTel('next-app')\n}\n```\n\n위 코드에서 `registerOTel` 함수는 'next-app'이라는 이름으로 OpenTelemetry를 설정해주는 역할을 해요. 이 부분은 프로젝트에서 필요한 모니터링이나 트레이싱을 할 때 유용하답니다.\n\n### onRequestError (선택 사항)\n\n`onRequestError` 함수도 선택 사항인데요, 이 함수는 HTTP 요청 중 에러가 발생했을 때 실행되도록 만들어져 있어요. 만약 API 라우트나 서버 함수에서 에러 로그를 따로 남기거나 오류를 처리하고 싶을 때 이 함수를 정의해서 사용할 수 있답니다.\n\n---\n\n참고로, `register` 함수 같은 초기화 함수는 앱이 구동될 때 한 번만 실행되기 때문에 무거운 초기 작업이나 설정을 이곳에 모아두면 깔끔하게 관리할 수 있어요. Next.js를 활용할 때, 이런 선택적 함수들로 서버 사이드의 세밀한 로직을 다루는 팁을 꼭 알아두시면 좋아요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서 onRequestError라는 함수를 선택적으로 내보내서 서버 에러를 커스텀한 관측(Observability) 도구로 추적할 수 있어요.\n\n- 만약 onRequestError 안에서 비동기 작업을 한다면 꼭 `await` 해줘야 해요. 이 함수는 Next.js 서버가 에러를 포착할 때 실행되거든요.\n- 여기서 주의할 점! 에러 인스턴스가 실제로 던져진 원본 에러가 아닐 수도 있어요. 특히 Server Components 렌더링 도중 React가 처리한 에러라면 그럴 수 있는데, 이럴 때는 에러 객체의 `digest` 속성을 이용해서 실제 에러 타입을 확인할 수 있답니다.\n\n아래 코드를 보면 실제로 onRequestError에서 에러 정보를 외부 서버로 POST 요청을 보내서 보고하는 간단한 예시를 보여주고 있어요:\n\n```js\nimport { type Instrumentation } from 'next'\n \nexport const onRequestError: Instrumentation.onRequestError = async (\n  err,\n  request,\n  context\n) => {\n  await fetch('https://.../report-error', {\n    method: 'POST',\n    body: JSON.stringify({\n      message: err.message,\n      request,\n      context,\n    }),\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  })\n}\n```\n\n### onRequestError 함수 파라미터\n\n| 파라미터명  | 설명                                                   |\n|-------------|--------------------------------------------------------|\n| `err`       | 발생한 에러 객체입니다. React가 가공할 수도 있어요.            |\n| `request`   | 현재 요청 정보가 담긴 객체입니다.                             |\n| `context`   | 요청에 관련된 추가 컨텍스트 정보가 들어있습니다.                   |\n\n이걸 활용하면 서버 에러를 커스텀 로그 서버나 Sentry, Datadog 같은 외부 모니터링 서비스에 손쉽게 연결할 수 있어요. 특히 여러 비동기 작업을 할 때 `await`를 빠뜨리지 않도록 주의해주세요! 안 그러면 에러 추적이 중간에 끊길 수 있거든요.\n\n그리고 `digest` 프로퍼티를 써서 에러 타입을 확인하는 팁! React에서 처리된 에러는 내부적으론 변형될 수 있기 때문에, 원래 에러를 정확히 파악하려면 이걸 참고하면 좋아요.\n\n이 기능을 잘 쓰면 서버 안정성 모니터링에 훨씬 도움 돼서, 문제 발생 시 빠르게 대응 가능하니 꼭 한번 적용해보시길 추천드립니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이번에는 `onRequestError` 함수에 대해 알아볼게요. 이 함수는 에러가 발생했을 때 호출되며, 세 가지 매개변수를 받아요: `error`, `request`, 그리고 `context`입니다.\n\n```ts\nexport function onRequestError(\n  error: { digest: string } & Error,\n  request: {\n    path: string; // 리소스 경로, 예: /blog?name=foo\n    method: string; // 요청 메서드, 예: GET, POST 등\n    headers: { [key: string]: string };\n  },\n  context: {\n    routerKind: 'Pages Router' | 'App Router'; // 사용하는 라우터 종류\n    routePath: string; // 라우트 파일 경로, 예: /app/blog/[dynamic]\n    routeType: 'render' | 'route' | 'action' | 'middleware'; // 에러 발생 컨텍스트\n    renderSource:\n      | 'react-server-components'\n      | 'react-server-components-payload'\n      | 'server-rendering'; // 렌더링 소스\n    revalidateReason: 'on-demand' | 'stale' | undefined; // 재검증 사유, undefined 는 일반 요청 의미\n    renderType: 'dynamic' | 'dynamic-resume'; // 'dynamic-resume'은 PPR 사용 시\n  }\n): void | Promise<void>;\n```\n\n| 파라미터 | 설명                        |\n|----------|-----------------------------|\n| `error`  | 발생한 실제 에러, 고유 ID인 `digest` 포함 |\n| `request`| 에러와 관련된 요청 정보      |\n| `context`| 에러가 발생한 환경 정보를 담고 있음 |\n\n### 파라미터 자세히 살펴보기\n\n- `error`: 항상 Error 타입이며, 여기에 `digest`라는 고유 ID가 있어 에러를 추적하기 좋습니다. 예를 들어, 같은 에러가 여러 번 발생할 경우 이 ID로 쉽게 분류할 수 있죠.\n- `request`: 실제 요청 정보입니다. 어떤 경로(`path`)로, 어떤 메서드(`method`)가 쓰였고, 헤더에는 어떤 정보가 담겨있는지 확인할 수 있어요.\n- `context`: 어느 라우터에서 발생했는지(`routerKind`), 어떤 라우트 파일에서 발생했는지(`routePath`), 그리고 에러가 일어난 시점(`routeType`)을 알려줍니다. 렌더링 소스(`renderSource`)나 재검증 사유(`revalidateReason`)도 담겨있어, 상황별 대응에 유용해요.\n\n### 추가 팁: 왜 이렇게 복잡한 정보가 필요할까?\n\n에러 핸들링은 단순히 에러 메시지를 로그에 남기는 걸 넘어서, 상황에 맞게 대처하거나 사용자에게 정확한 안내를 해주는 데 중요해요. 예를 들어 `revalidateReason`이 `'stale'`이면 캐시된 데이터를 다시 불러오는 중 문제가 생긴 거고, 이를 활용하면 재시도 로직이나 사용자 안내 메시지를 다르게 할 수 있겠죠.\n\n최근 Next.js 같은 프레임워크가 여러 라우터 시스템과 다양한 렌더링 방식을 지원하면서, 이런 세분화된 정보가 꼭 필요해졌답니다.\n\n---\n\n다음에 이어서 `### Specifying the runtime` 부분도 한 번 살펴볼게요! 혹시 여기까지 궁금한 점 있으면 댓글로 물어봐 주세요 :)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\ninstrumentation.js 파일은 Node.js와 Edge 런타임 둘 다에서 동작하는데요, 만약 특정 런타임을 대상으로 하고 싶다면 process.env.NEXT_RUNTIME 값을 활용하면 됩니다.\n\n```js\nexport function register() {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    return require('./register.edge')\n  } else {\n    return require('./register.node')\n  }\n}\n\nexport function onRequestError() {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    return require('./on-request-error.edge')\n  } else {\n    return require('./on-request-error.node')\n  }\n}\n```\n\n여기서 중요한 점은 process.env.NEXT_RUNTIME이 'edge'인지 아닌지에 따라서 각각 다른 모듈을 require해서 사용하는 방식이에요. 이렇게 하면 동일한 코드베이스에서 런타임 환경에 맞게 동작 방식을 유연하게 바꿀 수 있어서 정말 편리합니다.\n\n---\n\n## 버전 히스토리\n\n| Version   | Changes                                    |\n|-----------|--------------------------------------------|\n| v15.0.0   | `onRequestError` 추가, `instrumentation` 안정화 |\n| v14.0.4   | `instrumentation`에 Turbopack 지원 추가        |\n| v13.2.0   | `instrumentation` 실험적 기능으로 처음 소개      |\n\n버전 히스토리를 보면 알 수 있듯, instrumentation 기능이 처음에는 실험적으로 도입됐다가 이후 안정화 되고, Turbopack 같은 최신 툴도 지원이 추가되면서 점점 완성도 있게 발전해온 걸 확인할 수 있어요.\n\n---\n\n개발할 때 runtime 환경 구분이 필요한 경우에는 이렇게 환경변수를 통해 동적으로 모듈을 분기하는 패턴을 자주 쓰게 되는데, Next.js 같은 프레임워크에서 공식적으로 지원하니까 훨씬 편하게 적용할 수 있는 것 같더라고요. 혹시 특정 런타임에서만 동작하는 코드를 작성하려고 하면 참고해보시면 좋을 것 같아요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":8},{"title":"nextjs 15 접근 금지 페이지 forbidden.js로 쉽게 만드는 방법","description":"","date":"2025-04-22 02:37","slug":"2025-04-22-forbiddenjs","content":"\n\n# forbidden.js 파일 설명\n\nNext.js에서 인증 과정 중 forbidden 함수가 호출될 때 표시되는 UI를 커스터마이징할 수 있는 파일이 바로 forbidden.js예요. 이 파일을 통해 사용자가 권한이 없을 때 어떤 화면을 보여줄지 자유롭게 디자인할 수 있답니다. 그리고 중요한 점은, 이 컴포넌트를 렌더링하면 Next.js가 자동으로 HTTP 상태 코드 403(Forbidden)을 반환한다는 거예요.\n\n예를 들어, 기본적인 forbidden.js는 아래처럼 작성할 수 있어요:\n\n```js\nimport Link from 'next/link'\n\nexport default function Forbidden() {\n  return (\n    <div>\n      <h2>Forbidden</h2>\n      <p>You are not authorized to access this resource.</p>\n      <Link href=\"/\">Return Home</Link>\n    </div>\n  )\n}\n```\n\n조금 더 친근하게 메시지를 바꾸거나, 추가적인 안내 문구를 넣어 사용자 경험을 개선할 수도 있겠죠? 예를 들어, 로그인이 필요한 경우라면 로그인 페이지로 바로 가는 버튼을 추가하는 것도 좋은 방법이에요.\n\n```js\nimport Link from 'next/link'\n\nexport default function Forbidden() {\n  return (\n    <div style={{ textAlign: 'center', margin: '2rem' }}>\n      <h2>접근 금지</h2>\n      <p>이 페이지에 접근할 권한이 없어요.</p>\n      <p>계속하려면 로그인이 필요합니다.</p>\n      <Link href=\"/login\">\n        <a style={{ color: 'blue', textDecoration: 'underline' }}>로그인 하러 가기</a>\n      </Link>\n      <br />\n      <Link href=\"/\">\n        <a style={{ color: 'gray', marginTop: '1rem', display: 'inline-block' }}>홈으로 돌아가기</a>\n      </Link>\n    </div>\n  )\n}\n```\n\n> 참고로, 이런 방식으로 UI를 커스텀하면 사용자에게 명확한 안내를 제공할 수 있고, 더 나은 사용자 경험(UX)을 만들 수 있다는 점 기억하세요!\n\n## 참고자료\n- Next.js 공식 문서: [Error Handling](https://nextjs.org/docs/advanced-features/custom-error-page)\n- HTTP 상태 코드 403: [MDN - 403 Forbidden](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/403)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### Props\n\nforbidden.js 컴포넌트는 어떤 props도 받지 않습니다.\n\n## 버전 히스토리\n\n| 버전       | 변경사항                   |\n|------------|---------------------------|\n| `v15.1.0`  | forbidden.js가 새로 추가됨 |\n\n버전 히스토리를 보면 forbidden.js는 v15.1.0에서 처음 등장했네요. 새로운 컴포넌트를 도입할 때는 이렇게 변경사항을 꼼꼼히 챙겨두면 나중에 관리할 때 정말 도움이 됩니다. 개발하면서 버전 관리는 꼭 습관처럼 하시길 추천드려요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":3},{"title":"Next.js 15에서 error.js 파일로 에러 처리하는 방법 정리","description":"","date":"2025-04-22 02:36","slug":"2025-04-22-errorjs","content":"\n\n# error.js 파일 이해하기: 예기치 않은 에러 처리하기\n\n프로그래밍 하다 보면 갑자기 예상하지 못한 에러가 발생할 때가 있어요. 이럴 때 사용자에게 깔끔한 ‘에러 메시지’를 보여주고, 앱이 갑자기 죽지 않도록 안전하게 처리하는 게 중요하죠. 이번에 소개할 `error.js` 파일은 그런 에러를 잡아내고 사용자에게 알림 UI(화면)를 보여주는 역할을 해요.\n\n---\n\n## 핵심 코드 정리\n\n```js\n'use client' // Error boundaries는 Client 측 컴포넌트여야 해요\n\nimport { useEffect } from 'react'\n\nexport default function Error({\n  error,\n  reset,\n}: {\n  error: Error & { digest?: string }\n  reset: () => void\n}) {\n  useEffect(() => {\n    // 에러가 발생하면 콘솔과 같은 에러 리포팅 서비스에 기록하세요\n    console.error(error)\n  }, [error])\n\n  return (\n    <div>\n      <h2>Something went wrong!</h2>\n      <button onClick={() => reset()}>\n        Try again\n      </button>\n    </div>\n  )\n}\n```\n\n---\n\n## 주요 포인트\n\n| 항목 | 설명 |\n|---|---|\n| `'use client'` | 에러 경계(Error Boundary)는 **클라이언트 컴포넌트**여야 한다는 점! 서버 컴포넌트에서는 에러 경계를 사용할 수 없어요. |\n| `useEffect` | 에러가 발생하면 로깅(log)하는 부분이에요. 보통 여기에 Sentry, LogRocket 같은 에러 수집 서비스 코드를 넣기도 하죠. |\n| `reset` 함수 | 사용자가 “Try again” 버튼을 누르면 이 `reset` 함수가 실행되면서, 문제가 발생한 부분을 다시 렌더링하는 시도를 합니다. |\n\n---\n\n## 제가 더 알려드리고 싶은 점!\n\n- **에러 경계란?**  \n  리액트에서는 ‘에러 경계’라는 개념이 있는데, 컴포넌트 트리 어느 한 부분에서 에러가 나더라도, 해당 부분만 격리해서 에러 UI를 보여주고 전체 앱이 멈추지 않도록 도와줍니다.\n\n- **에러 처리할 때 어디에 쓰면 좋을까?**  \n  보통 사용자가 조작하는 주요 화면 컴포넌트 주변에 적용하면 좋아요. 예를 들어, 특정 API 호출이 실패하거나, 컴포넌트 내부 상태가 꼬였을 때 앱이 멈추는 걸 방지하죠.\n\n- **추가 아이디어**  \n  에러 메시지를 조금 더 사용자 친화적으로 바꾸거나, 에러 상세 내용을 개발자용 로그에만 남기고 사용자는 간단하게 안내하는 것도 좋은 UX 방식입니다.\n\n- **실무 꿀팁!**  \n  에러 발생 시 단순히 console.error만 하기보단, 별도의 에러 모니터링 툴(Sentry, Bugsnag 등)과 연동해두면 실시간으로 문제를 감지하고 빠르게 대응할 수 있어서 정말 좋아요.\n\n---\n\n요약하면, `error.js` 파일은 “앱이 갑자기 멈추지 않고 사용자에게 안내 메시지를 띄우면서, 다시 시도할 수 있도록 도와주는 작은 안전망” 같은 역할을 하는 컴포넌트입니다. 다음 프로젝트에 적용해보면 에러 대응이 한결 수월해질 거예요! 😊\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nerror.js는 라우트 세그먼트와 그 안에 중첩된 자식들을 React의 에러 경계(Error Boundary)로 감싸주는 역할을 해요. 만약 이 경계 내에서 에러가 발생하면, 에러 컴포넌트가 대체 UI(fallback UI)로 보여지게 되죠.\n\n![Error Boundary 예시]( /assets/img/2025-04-22-errorjs_1.png )\n\n> 알아두면 좋은 팁!\n> React DevTools에서는 에러 경계를 토글해가며 실제 에러 상태를 테스트할 수 있어요.\n> 만약 하위 에러 경계에서 발생한 에러가 부모 에러 경계까지 전달되길 원한다면, 에러 컴포넌트 렌더링 시점에 에러를 다시 던지(throw)면 됩니다.\n\n에러 경계(Error Boundary)는 React에서 UI가 예기치 않게 깨지는 상황을 방지하고 사용자에게도 친절한 메시지를 보여줄 수 있는 좋은 방법인데요, React 16 버전부터 도입된 기능이랍니다. 에러 경계 안에서만 렌더링되는 컴포넌트가 문제가 생기면 그 부분만 대체 UI로 교체되고, 전체 앱이 다운되는 걸 막아줘요.\n\n만약 이 기능을 제대로 활용하고싶다면, 한번 직접 React DevTools에서 에러 경계 토글 기능을 사용해 보면서 에러 상태 테스트를 해보는 걸 추천드려요. 실제 서비스에서 에러 상황을 어떻게 커버할지 고민할 때 큰 도움이 될 거예요!\n\n필요하면 이걸로 사용자에게 에러 메시지를 커스텀하거나, 에러 로그를 서버로 보내는 등의 작업도 할 수 있으니 참고하시고요.\n\n## 참고 자료  \n- [React 공식 문서 - Error Boundaries](https://reactjs.org/docs/error-boundaries.html)  \n- [React DevTools](https://reactjs.org/blog/2019/08/15/new-react-devtools.html)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### Props\n\n#### error\n\n`error`는 `error.js` 클라이언트 컴포넌트로 전달되는 Error 객체의 인스턴스입니다.\n\n> 알아두면 좋은 점: 개발 환경에서는 클라이언트로 전달되는 Error 객체가 직렬화되어 원래 에러 메시지를 포함해 디버깅이 더 쉽도록 도와줍니다. 하지만 프로덕션 환경에서는 잠재적으로 민감한 정보가 클라이언트로 유출되는 것을 막기 위해 이 동작이 달라진다는 점 참고하세요.\n\n추가로, 이런 에러 핸들링 방식을 통해 개발할 때에는 에러 메시지를 좀 더 자유롭게 확인할 수 있지만, 실제 운영 환경에서는 안전을 최우선으로 생각하기 때문에 에러 내용이 제한적으로 전달된다는 점 기억해두시면 좋아요. 에러 관련 코드를 작성할 때는 이 점을 고려해 로깅이나 모니터링도 함께 신경 써주세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n#### error.message\n\n- 클라이언트 컴포넌트에서 전달된 에러는 원래의 에러 메시지를 그대로 보여줘요.\n- 반면, 서버 컴포넌트에서 온 에러는 예민한 정보를 노출하지 않기 위해 일반적인 메시지와 식별자(identifier)를 보여준답니다.  \n  이 식별자, 즉 `errors.digest` 값을 사용하면 서버 로그에서 해당 에러를 쉽게 찾아낼 수 있어요.\n\n#### error.digest\n\n이건 자동으로 생성된 에러 해시 값이에요.  \n서버 쪽 로그와 에러를 매칭할 때 아주 유용하죠.  \n즉, 사용자에게는 세세한 정보 대신 이 해시값만 보여주고, 개발자는 이 해시값을 통해 문제를 추적할 수 있는 거예요.\n\n---\n\n### 조금 더 알아볼까요?\n\n서버 컴포넌트에서 에러 메시지에 상세한 내용을 숨기는 이유는 보안 때문이에요.  \n만약 민감한 코드 구조나 데이터가 클라이언트에 노출되면 해커들이 공격에 악용할 수 있거든요.  \n그래서 '어떤 문제가 발생했는지'는 알려주되, '어떤 코드에서, 왜'에 관한 자세한 건 서버 쪽에만 기록해서 관리하는 거죠.\n\n이런 구조 덕분에 사용자 경험은 방해받지 않으면서, 개발자는 충분한 디버깅 정보를 확보할 수 있답니다.  \n\n혹시 서버 로그에서 에러를 찾으려면 `error.digest` 값을 복사해서 검색해보세요!  \n이게 생각보다 꽤 쏙쏙 잘 맞아 떨어진답니다. 🙂\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n#### 리셋 (reset)\n\n가끔 에러가 일시적인 경우가 있어요. 이런 경우에는 다시 시도하면 문제를 해결할 수 있죠.\n\n에러 컴포넌트에서는 `reset()` 함수를 사용해서 사용자에게 에러에서 복구할 기회를 줄 수 있어요. 이 함수가 호출되면, 에러 경계(error boundary)에 감싸져 있는 컴포넌트를 다시 렌더링하려고 시도합니다. 만약 다시 렌더링에 성공하면 기존의 에러 화면(fallback)이 정상 화면으로 바뀌게 되죠.\n\n사용법은 아주 간단해요. 예를 들어:\n\n```js\n'use client' // 에러 경계는 반드시 클라이언트 컴포넌트여야 합니다\n\nexport default function Error({\n  error,\n  reset,\n}: {\n  error: Error & { digest?: string }\n  reset: () => void\n}) {\n  return (\n    <div>\n      <h2>문제가 발생했습니다!</h2>\n      <button onClick={() => reset()}>다시 시도하기</button>\n    </div>\n  )\n}\n```\n\n위 예제에서 `reset()` 함수가 버튼 클릭 시 호출되고, 이로 인해 오류 상태가 초기화되어 정상 화면을 다시 시도하게 되는 거죠.\n\n---\n\n**추가 팁!**\n\n- `reset()`은 React의 에러 경계 기능과 연동되어 동작하기 때문에, Next.js 13의 `app` 디렉토리 기반에서 클라이언트 컴포넌트로 작성해야 합니다.\n- `reset()`을 사용할 땐 오류 발생 시 사용자에게 친절하게 안내하는 UI를 보여주는 게 좋아요. 예를 들어, 에러 내용과 함께 재시도 버튼을 제공하면 사용자 경험이 훨씬 좋아집니다.\n- 일시적인 네트워크 문제나 API 호출 실패 같은 상황에서 특히 유용하니, 네트워크 상태 변화 이벤트와도 같이 활용하면 효과적이에요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 예시\n\n### 전역 에러 처리(Global Error)\n\n전역 에러 처리는 조금 덜 흔하지만, 루트 앱 디렉토리에 `global-error.js` 파일을 만들어서 루트 레이아웃(root layout)이나 템플릿(root template)에서 발생하는 에러를 잡을 수 있어요. 특히 다국어 지원(i18n)을 사용할 때도 문제없이 동작합니다. 여기서 중요한 점! 전역 에러 UI는 반드시 `html`과 `body` 태그를 직접 정의해야 해요. 이 파일이 활성화되면 해당 루트 레이아웃이나 템플릿을 대체하게 된답니다.\n\n```jsx\n'use client' // 에러 바운더리는 클라이언트 컴포넌트여야 해요\n\nexport default function GlobalError({\n  error,\n  reset,\n}: {\n  error: Error & { digest?: string }\n  reset: () => void\n}) {\n  return (\n    <html>\n      <body>\n        <h2>문제가 발생했어요!</h2>\n        <button onClick={() => reset()}>다시 시도하기</button>\n      </body>\n    </html>\n  )\n}\n```\n\n### 추가 팁!\n\n- `reset` 함수는 에러 상태를 초기화해서 컴포넌트를 리프레시하는 역할을 해요. 사용자 경험을 위해 꼭 넣어주세요.\n- 전역 에러 컴포넌트가 활성화되면 기존의 레이아웃이나 템플릿이 완전히 대체되니, 디자인 요소나 공통 레이아웃을 포함시키고 싶으면 직접 만들어야 한다는 점 기억하세요.\n- **에러 경계(Error Boundaries)**는 클라이언트에서만 동작하기 때문에 꼭 `'use client'`를 선언해야 하는 점도 꼭 체크!  \n\n이렇게 전역에서 에러를 처리하면 예상치 못한 문제가 발생해도 깔끔하게 사용자에게 안내할 수 있어서 앱 안정성에 큰 도움이 됩니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 버전 히스토리\n\n| 버전         | 변경 사항                         |\n|--------------|----------------------------------|\n| `v15.2.0`    | 개발 환경에서 `global-error`도 표시되도록 변경됨. |\n| `v13.1.0`    | `global-error` 기능 추가됨.             |\n| `v13.0.0`    | `error` 기능 추가됨.                    |\n\n---\n\n여기서 잠깐!  \n\n- `global-error`는 전역적으로 발생하는 에러를 한눈에 확인할 수 있게 해주는 기능이에요. 특히 개발할 때 어디서 문제가 생겼는지 빠르게 파악할 수 있어서 무척 유용하죠.\n- 버전 히스토리를 잘 확인해두면 새로 추가된 기능이나 변경된 점을 놓치지 않을 수 있으니 개발하면서 꼭 참고하시길 추천해요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":8}],"page":"3","totalPageCount":41,"totalPageGroupCount":3,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}