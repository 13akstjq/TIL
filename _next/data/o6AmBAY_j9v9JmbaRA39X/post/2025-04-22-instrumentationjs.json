{"pageProps":{"post":{"title":"instrumentation.js로 웹사이트 성능 측정 도구 만들기","description":"","date":"2025-04-22 02:38","slug":"2025-04-22-instrumentationjs","content":"\n\n# instrumentation.js\n\ninstrumentation.js|ts 파일은 애플리케이션에 관찰 가능성(Observability) 도구를 통합하는 용도로 사용돼요. 이를 통해 애플리케이션의 성능과 동작을 추적할 수 있고, 실제 서비스 중에 발생하는 문제를 더 효과적으로 디버깅할 수 있답니다.\n\n사용법도 간단해요! 프로젝트 루트 디렉토리에 파일을 두거나, 만약 src 폴더를 사용한다면 그 안에 넣으면 되죠.\n\n## 파일에서 제공하는 주요 기능 (Exports)\n\n(여기에 실제로 어떤 내용이 export 되는지 명시되어야 하는데요, 이어서 있으면 같이 정리해보겠습니다.)\n\n---\n\n### 조금 더 알아두면 좋은 점!\n\n- 관찰 가능성 도구에는 여러 가지가 있는데, 예를 들어 로그 수집, 메트릭 수집, 트레이싱 등이 있어요. instrumentation.js를 통해 이런 도구들을 한 곳에 모아 효율적으로 관리할 수 있어요.\n- 실제 운영 환경에서 문제가 발생했을 때, 미리 설정한 instrumentation 덕분에 원인을 빠르게 파악할 수 있으니 개발, 운영 모두에 큰 도움이 된답니다.\n- TypeScript를 사용한다면 .ts 확장자를 사용해 타입 안정성을 더할 수도 있어요.\n\n다음에는 instrumentation.js 안에 어떤 코드가 들어가는지, 구체적인 예시를 하나씩 살펴보도록 할게요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### register (선택 사항)\n\nNext.js 서버가 새로 시작될 때 한 번 호출되는 `register` 함수를 파일에서 export할 수 있어요. 이 함수는 async 함수여도 되고, 주로 초기 설정이나 라이브러리 등록 같은 작업에 사용되죠.\n\n예를 들어, 아래처럼 OpenTelemetry를 연동하는 작업을 할 수 있어요:\n\n```js\nimport { registerOTel } from '@vercel/otel'\n \nexport function register() {\n  registerOTel('next-app')\n}\n```\n\n위 코드에서 `registerOTel` 함수는 'next-app'이라는 이름으로 OpenTelemetry를 설정해주는 역할을 해요. 이 부분은 프로젝트에서 필요한 모니터링이나 트레이싱을 할 때 유용하답니다.\n\n### onRequestError (선택 사항)\n\n`onRequestError` 함수도 선택 사항인데요, 이 함수는 HTTP 요청 중 에러가 발생했을 때 실행되도록 만들어져 있어요. 만약 API 라우트나 서버 함수에서 에러 로그를 따로 남기거나 오류를 처리하고 싶을 때 이 함수를 정의해서 사용할 수 있답니다.\n\n---\n\n참고로, `register` 함수 같은 초기화 함수는 앱이 구동될 때 한 번만 실행되기 때문에 무거운 초기 작업이나 설정을 이곳에 모아두면 깔끔하게 관리할 수 있어요. Next.js를 활용할 때, 이런 선택적 함수들로 서버 사이드의 세밀한 로직을 다루는 팁을 꼭 알아두시면 좋아요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서 onRequestError라는 함수를 선택적으로 내보내서 서버 에러를 커스텀한 관측(Observability) 도구로 추적할 수 있어요.\n\n- 만약 onRequestError 안에서 비동기 작업을 한다면 꼭 `await` 해줘야 해요. 이 함수는 Next.js 서버가 에러를 포착할 때 실행되거든요.\n- 여기서 주의할 점! 에러 인스턴스가 실제로 던져진 원본 에러가 아닐 수도 있어요. 특히 Server Components 렌더링 도중 React가 처리한 에러라면 그럴 수 있는데, 이럴 때는 에러 객체의 `digest` 속성을 이용해서 실제 에러 타입을 확인할 수 있답니다.\n\n아래 코드를 보면 실제로 onRequestError에서 에러 정보를 외부 서버로 POST 요청을 보내서 보고하는 간단한 예시를 보여주고 있어요:\n\n```js\nimport { type Instrumentation } from 'next'\n \nexport const onRequestError: Instrumentation.onRequestError = async (\n  err,\n  request,\n  context\n) => {\n  await fetch('https://.../report-error', {\n    method: 'POST',\n    body: JSON.stringify({\n      message: err.message,\n      request,\n      context,\n    }),\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  })\n}\n```\n\n### onRequestError 함수 파라미터\n\n| 파라미터명  | 설명                                                   |\n|-------------|--------------------------------------------------------|\n| `err`       | 발생한 에러 객체입니다. React가 가공할 수도 있어요.            |\n| `request`   | 현재 요청 정보가 담긴 객체입니다.                             |\n| `context`   | 요청에 관련된 추가 컨텍스트 정보가 들어있습니다.                   |\n\n이걸 활용하면 서버 에러를 커스텀 로그 서버나 Sentry, Datadog 같은 외부 모니터링 서비스에 손쉽게 연결할 수 있어요. 특히 여러 비동기 작업을 할 때 `await`를 빠뜨리지 않도록 주의해주세요! 안 그러면 에러 추적이 중간에 끊길 수 있거든요.\n\n그리고 `digest` 프로퍼티를 써서 에러 타입을 확인하는 팁! React에서 처리된 에러는 내부적으론 변형될 수 있기 때문에, 원래 에러를 정확히 파악하려면 이걸 참고하면 좋아요.\n\n이 기능을 잘 쓰면 서버 안정성 모니터링에 훨씬 도움 돼서, 문제 발생 시 빠르게 대응 가능하니 꼭 한번 적용해보시길 추천드립니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이번에는 `onRequestError` 함수에 대해 알아볼게요. 이 함수는 에러가 발생했을 때 호출되며, 세 가지 매개변수를 받아요: `error`, `request`, 그리고 `context`입니다.\n\n```ts\nexport function onRequestError(\n  error: { digest: string } & Error,\n  request: {\n    path: string; // 리소스 경로, 예: /blog?name=foo\n    method: string; // 요청 메서드, 예: GET, POST 등\n    headers: { [key: string]: string };\n  },\n  context: {\n    routerKind: 'Pages Router' | 'App Router'; // 사용하는 라우터 종류\n    routePath: string; // 라우트 파일 경로, 예: /app/blog/[dynamic]\n    routeType: 'render' | 'route' | 'action' | 'middleware'; // 에러 발생 컨텍스트\n    renderSource:\n      | 'react-server-components'\n      | 'react-server-components-payload'\n      | 'server-rendering'; // 렌더링 소스\n    revalidateReason: 'on-demand' | 'stale' | undefined; // 재검증 사유, undefined 는 일반 요청 의미\n    renderType: 'dynamic' | 'dynamic-resume'; // 'dynamic-resume'은 PPR 사용 시\n  }\n): void | Promise<void>;\n```\n\n| 파라미터 | 설명                        |\n|----------|-----------------------------|\n| `error`  | 발생한 실제 에러, 고유 ID인 `digest` 포함 |\n| `request`| 에러와 관련된 요청 정보      |\n| `context`| 에러가 발생한 환경 정보를 담고 있음 |\n\n### 파라미터 자세히 살펴보기\n\n- `error`: 항상 Error 타입이며, 여기에 `digest`라는 고유 ID가 있어 에러를 추적하기 좋습니다. 예를 들어, 같은 에러가 여러 번 발생할 경우 이 ID로 쉽게 분류할 수 있죠.\n- `request`: 실제 요청 정보입니다. 어떤 경로(`path`)로, 어떤 메서드(`method`)가 쓰였고, 헤더에는 어떤 정보가 담겨있는지 확인할 수 있어요.\n- `context`: 어느 라우터에서 발생했는지(`routerKind`), 어떤 라우트 파일에서 발생했는지(`routePath`), 그리고 에러가 일어난 시점(`routeType`)을 알려줍니다. 렌더링 소스(`renderSource`)나 재검증 사유(`revalidateReason`)도 담겨있어, 상황별 대응에 유용해요.\n\n### 추가 팁: 왜 이렇게 복잡한 정보가 필요할까?\n\n에러 핸들링은 단순히 에러 메시지를 로그에 남기는 걸 넘어서, 상황에 맞게 대처하거나 사용자에게 정확한 안내를 해주는 데 중요해요. 예를 들어 `revalidateReason`이 `'stale'`이면 캐시된 데이터를 다시 불러오는 중 문제가 생긴 거고, 이를 활용하면 재시도 로직이나 사용자 안내 메시지를 다르게 할 수 있겠죠.\n\n최근 Next.js 같은 프레임워크가 여러 라우터 시스템과 다양한 렌더링 방식을 지원하면서, 이런 세분화된 정보가 꼭 필요해졌답니다.\n\n---\n\n다음에 이어서 `### Specifying the runtime` 부분도 한 번 살펴볼게요! 혹시 여기까지 궁금한 점 있으면 댓글로 물어봐 주세요 :)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\ninstrumentation.js 파일은 Node.js와 Edge 런타임 둘 다에서 동작하는데요, 만약 특정 런타임을 대상으로 하고 싶다면 process.env.NEXT_RUNTIME 값을 활용하면 됩니다.\n\n```js\nexport function register() {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    return require('./register.edge')\n  } else {\n    return require('./register.node')\n  }\n}\n\nexport function onRequestError() {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    return require('./on-request-error.edge')\n  } else {\n    return require('./on-request-error.node')\n  }\n}\n```\n\n여기서 중요한 점은 process.env.NEXT_RUNTIME이 'edge'인지 아닌지에 따라서 각각 다른 모듈을 require해서 사용하는 방식이에요. 이렇게 하면 동일한 코드베이스에서 런타임 환경에 맞게 동작 방식을 유연하게 바꿀 수 있어서 정말 편리합니다.\n\n---\n\n## 버전 히스토리\n\n| Version   | Changes                                    |\n|-----------|--------------------------------------------|\n| v15.0.0   | `onRequestError` 추가, `instrumentation` 안정화 |\n| v14.0.4   | `instrumentation`에 Turbopack 지원 추가        |\n| v13.2.0   | `instrumentation` 실험적 기능으로 처음 소개      |\n\n버전 히스토리를 보면 알 수 있듯, instrumentation 기능이 처음에는 실험적으로 도입됐다가 이후 안정화 되고, Turbopack 같은 최신 툴도 지원이 추가되면서 점점 완성도 있게 발전해온 걸 확인할 수 있어요.\n\n---\n\n개발할 때 runtime 환경 구분이 필요한 경우에는 이렇게 환경변수를 통해 동적으로 모듈을 분기하는 패턴을 자주 쓰게 되는데, Next.js 같은 프레임워크에서 공식적으로 지원하니까 훨씬 편하게 적용할 수 있는 것 같더라고요. 혹시 특정 런타임에서만 동작하는 코드를 작성하려고 하면 참고해보시면 좋을 것 같아요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":8},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<h1>instrumentation.js</h1>\n<p>instrumentation.js|ts 파일은 애플리케이션에 관찰 가능성(Observability) 도구를 통합하는 용도로 사용돼요. 이를 통해 애플리케이션의 성능과 동작을 추적할 수 있고, 실제 서비스 중에 발생하는 문제를 더 효과적으로 디버깅할 수 있답니다.</p>\n<p>사용법도 간단해요! 프로젝트 루트 디렉토리에 파일을 두거나, 만약 src 폴더를 사용한다면 그 안에 넣으면 되죠.</p>\n<h2>파일에서 제공하는 주요 기능 (Exports)</h2>\n<p>(여기에 실제로 어떤 내용이 export 되는지 명시되어야 하는데요, 이어서 있으면 같이 정리해보겠습니다.)</p>\n<hr>\n<h3>조금 더 알아두면 좋은 점!</h3>\n<ul>\n<li>관찰 가능성 도구에는 여러 가지가 있는데, 예를 들어 로그 수집, 메트릭 수집, 트레이싱 등이 있어요. instrumentation.js를 통해 이런 도구들을 한 곳에 모아 효율적으로 관리할 수 있어요.</li>\n<li>실제 운영 환경에서 문제가 발생했을 때, 미리 설정한 instrumentation 덕분에 원인을 빠르게 파악할 수 있으니 개발, 운영 모두에 큰 도움이 된답니다.</li>\n<li>TypeScript를 사용한다면 .ts 확장자를 사용해 타입 안정성을 더할 수도 있어요.</li>\n</ul>\n<p>다음에는 instrumentation.js 안에 어떤 코드가 들어가는지, 구체적인 예시를 하나씩 살펴보도록 할게요!</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h3>register (선택 사항)</h3>\n<p>Next.js 서버가 새로 시작될 때 한 번 호출되는 <code>register</code> 함수를 파일에서 export할 수 있어요. 이 함수는 async 함수여도 되고, 주로 초기 설정이나 라이브러리 등록 같은 작업에 사용되죠.</p>\n<p>예를 들어, 아래처럼 OpenTelemetry를 연동하는 작업을 할 수 있어요:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { registerOTel } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@vercel/otel'</span>\n \n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">register</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-title function_\">registerOTel</span>(<span class=\"hljs-string\">'next-app'</span>)\n}\n</code></pre>\n<p>위 코드에서 <code>registerOTel</code> 함수는 'next-app'이라는 이름으로 OpenTelemetry를 설정해주는 역할을 해요. 이 부분은 프로젝트에서 필요한 모니터링이나 트레이싱을 할 때 유용하답니다.</p>\n<h3>onRequestError (선택 사항)</h3>\n<p><code>onRequestError</code> 함수도 선택 사항인데요, 이 함수는 HTTP 요청 중 에러가 발생했을 때 실행되도록 만들어져 있어요. 만약 API 라우트나 서버 함수에서 에러 로그를 따로 남기거나 오류를 처리하고 싶을 때 이 함수를 정의해서 사용할 수 있답니다.</p>\n<hr>\n<p>참고로, <code>register</code> 함수 같은 초기화 함수는 앱이 구동될 때 한 번만 실행되기 때문에 무거운 초기 작업이나 설정을 이곳에 모아두면 깔끔하게 관리할 수 있어요. Next.js를 활용할 때, 이런 선택적 함수들로 서버 사이드의 세밀한 로직을 다루는 팁을 꼭 알아두시면 좋아요!</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>Next.js에서 onRequestError라는 함수를 선택적으로 내보내서 서버 에러를 커스텀한 관측(Observability) 도구로 추적할 수 있어요.</p>\n<ul>\n<li>만약 onRequestError 안에서 비동기 작업을 한다면 꼭 <code>await</code> 해줘야 해요. 이 함수는 Next.js 서버가 에러를 포착할 때 실행되거든요.</li>\n<li>여기서 주의할 점! 에러 인스턴스가 실제로 던져진 원본 에러가 아닐 수도 있어요. 특히 Server Components 렌더링 도중 React가 처리한 에러라면 그럴 수 있는데, 이럴 때는 에러 객체의 <code>digest</code> 속성을 이용해서 실제 에러 타입을 확인할 수 있답니다.</li>\n</ul>\n<p>아래 코드를 보면 실제로 onRequestError에서 에러 정보를 외부 서버로 POST 요청을 보내서 보고하는 간단한 예시를 보여주고 있어요:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { type <span class=\"hljs-title class_\">Instrumentation</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'next'</span>\n \n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">onRequestError</span>: <span class=\"hljs-title class_\">Instrumentation</span>.<span class=\"hljs-property\">onRequestError</span> = <span class=\"hljs-keyword\">async</span> (\n  err,\n  request,\n  context\n) => {\n  <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">'https://.../report-error'</span>, {\n    <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">'POST'</span>,\n    <span class=\"hljs-attr\">body</span>: <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>({\n      <span class=\"hljs-attr\">message</span>: err.<span class=\"hljs-property\">message</span>,\n      request,\n      context,\n    }),\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">'Content-Type'</span>: <span class=\"hljs-string\">'application/json'</span>,\n    },\n  })\n}\n</code></pre>\n<h3>onRequestError 함수 파라미터</h3>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>파라미터명</th><th>설명</th></tr></thead><tbody><tr><td><code>err</code></td><td>발생한 에러 객체입니다. React가 가공할 수도 있어요.</td></tr><tr><td><code>request</code></td><td>현재 요청 정보가 담긴 객체입니다.</td></tr><tr><td><code>context</code></td><td>요청에 관련된 추가 컨텍스트 정보가 들어있습니다.</td></tr></tbody></table>\n<p>이걸 활용하면 서버 에러를 커스텀 로그 서버나 Sentry, Datadog 같은 외부 모니터링 서비스에 손쉽게 연결할 수 있어요. 특히 여러 비동기 작업을 할 때 <code>await</code>를 빠뜨리지 않도록 주의해주세요! 안 그러면 에러 추적이 중간에 끊길 수 있거든요.</p>\n<p>그리고 <code>digest</code> 프로퍼티를 써서 에러 타입을 확인하는 팁! React에서 처리된 에러는 내부적으론 변형될 수 있기 때문에, 원래 에러를 정확히 파악하려면 이걸 참고하면 좋아요.</p>\n<p>이 기능을 잘 쓰면 서버 안정성 모니터링에 훨씬 도움 돼서, 문제 발생 시 빠르게 대응 가능하니 꼭 한번 적용해보시길 추천드립니다!</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>이번에는 <code>onRequestError</code> 함수에 대해 알아볼게요. 이 함수는 에러가 발생했을 때 호출되며, 세 가지 매개변수를 받아요: <code>error</code>, <code>request</code>, 그리고 <code>context</code>입니다.</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">onRequestError</span>(<span class=\"hljs-params\">\n  error: { digest: <span class=\"hljs-built_in\">string</span> } &#x26; <span class=\"hljs-built_in\">Error</span>,\n  request: {\n    path: <span class=\"hljs-built_in\">string</span>; // 리소스 경로, 예: /blog?name=foo\n    method: <span class=\"hljs-built_in\">string</span>; // 요청 메서드, 예: GET, POST 등\n    headers: { [key: <span class=\"hljs-built_in\">string</span>]: <span class=\"hljs-built_in\">string</span> };\n  },\n  context: {\n    routerKind: <span class=\"hljs-string\">'Pages Router'</span> | <span class=\"hljs-string\">'App Router'</span>; // 사용하는 라우터 종류\n    routePath: <span class=\"hljs-built_in\">string</span>; // 라우트 파일 경로, 예: /app/blog/[dynamic]\n    routeType: <span class=\"hljs-string\">'render'</span> | <span class=\"hljs-string\">'route'</span> | <span class=\"hljs-string\">'action'</span> | <span class=\"hljs-string\">'middleware'</span>; // 에러 발생 컨텍스트\n    renderSource:\n      | <span class=\"hljs-string\">'react-server-components'</span>\n      | <span class=\"hljs-string\">'react-server-components-payload'</span>\n      | <span class=\"hljs-string\">'server-rendering'</span>; // 렌더링 소스\n    revalidateReason: <span class=\"hljs-string\">'on-demand'</span> | <span class=\"hljs-string\">'stale'</span> | <span class=\"hljs-literal\">undefined</span>; // 재검증 사유, <span class=\"hljs-literal\">undefined</span> 는 일반 요청 의미\n    renderType: <span class=\"hljs-string\">'dynamic'</span> | <span class=\"hljs-string\">'dynamic-resume'</span>; // <span class=\"hljs-string\">'dynamic-resume'</span>은 PPR 사용 시\n  }\n</span>): <span class=\"hljs-built_in\">void</span> | <span class=\"hljs-title class_\">Promise</span>&#x3C;<span class=\"hljs-built_in\">void</span>>;\n</code></pre>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>파라미터</th><th>설명</th></tr></thead><tbody><tr><td><code>error</code></td><td>발생한 실제 에러, 고유 ID인 <code>digest</code> 포함</td></tr><tr><td><code>request</code></td><td>에러와 관련된 요청 정보</td></tr><tr><td><code>context</code></td><td>에러가 발생한 환경 정보를 담고 있음</td></tr></tbody></table>\n<h3>파라미터 자세히 살펴보기</h3>\n<ul>\n<li><code>error</code>: 항상 Error 타입이며, 여기에 <code>digest</code>라는 고유 ID가 있어 에러를 추적하기 좋습니다. 예를 들어, 같은 에러가 여러 번 발생할 경우 이 ID로 쉽게 분류할 수 있죠.</li>\n<li><code>request</code>: 실제 요청 정보입니다. 어떤 경로(<code>path</code>)로, 어떤 메서드(<code>method</code>)가 쓰였고, 헤더에는 어떤 정보가 담겨있는지 확인할 수 있어요.</li>\n<li><code>context</code>: 어느 라우터에서 발생했는지(<code>routerKind</code>), 어떤 라우트 파일에서 발생했는지(<code>routePath</code>), 그리고 에러가 일어난 시점(<code>routeType</code>)을 알려줍니다. 렌더링 소스(<code>renderSource</code>)나 재검증 사유(<code>revalidateReason</code>)도 담겨있어, 상황별 대응에 유용해요.</li>\n</ul>\n<h3>추가 팁: 왜 이렇게 복잡한 정보가 필요할까?</h3>\n<p>에러 핸들링은 단순히 에러 메시지를 로그에 남기는 걸 넘어서, 상황에 맞게 대처하거나 사용자에게 정확한 안내를 해주는 데 중요해요. 예를 들어 <code>revalidateReason</code>이 <code>'stale'</code>이면 캐시된 데이터를 다시 불러오는 중 문제가 생긴 거고, 이를 활용하면 재시도 로직이나 사용자 안내 메시지를 다르게 할 수 있겠죠.</p>\n<p>최근 Next.js 같은 프레임워크가 여러 라우터 시스템과 다양한 렌더링 방식을 지원하면서, 이런 세분화된 정보가 꼭 필요해졌답니다.</p>\n<hr>\n<p>다음에 이어서 <code>### Specifying the runtime</code> 부분도 한 번 살펴볼게요! 혹시 여기까지 궁금한 점 있으면 댓글로 물어봐 주세요 :)</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>instrumentation.js 파일은 Node.js와 Edge 런타임 둘 다에서 동작하는데요, 만약 특정 런타임을 대상으로 하고 싶다면 process.env.NEXT_RUNTIME 값을 활용하면 됩니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">register</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">if</span> (process.<span class=\"hljs-property\">env</span>.<span class=\"hljs-property\">NEXT_RUNTIME</span> === <span class=\"hljs-string\">'edge'</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./register.edge'</span>)\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./register.node'</span>)\n  }\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">onRequestError</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">if</span> (process.<span class=\"hljs-property\">env</span>.<span class=\"hljs-property\">NEXT_RUNTIME</span> === <span class=\"hljs-string\">'edge'</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./on-request-error.edge'</span>)\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./on-request-error.node'</span>)\n  }\n}\n</code></pre>\n<p>여기서 중요한 점은 process.env.NEXT_RUNTIME이 'edge'인지 아닌지에 따라서 각각 다른 모듈을 require해서 사용하는 방식이에요. 이렇게 하면 동일한 코드베이스에서 런타임 환경에 맞게 동작 방식을 유연하게 바꿀 수 있어서 정말 편리합니다.</p>\n<hr>\n<h2>버전 히스토리</h2>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>Version</th><th>Changes</th></tr></thead><tbody><tr><td>v15.0.0</td><td><code>onRequestError</code> 추가, <code>instrumentation</code> 안정화</td></tr><tr><td>v14.0.4</td><td><code>instrumentation</code>에 Turbopack 지원 추가</td></tr><tr><td>v13.2.0</td><td><code>instrumentation</code> 실험적 기능으로 처음 소개</td></tr></tbody></table>\n<p>버전 히스토리를 보면 알 수 있듯, instrumentation 기능이 처음에는 실험적으로 도입됐다가 이후 안정화 되고, Turbopack 같은 최신 툴도 지원이 추가되면서 점점 완성도 있게 발전해온 걸 확인할 수 있어요.</p>\n<hr>\n<p>개발할 때 runtime 환경 구분이 필요한 경우에는 이렇게 환경변수를 통해 동적으로 모듈을 분기하는 패턴을 자주 쓰게 되는데, Next.js 같은 프레임워크에서 공식적으로 지원하니까 훨씬 편하게 적용할 수 있는 것 같더라고요. 혹시 특정 런타임에서만 동작하는 코드를 작성하려고 하면 참고해보시면 좋을 것 같아요!</p>\n</body>\n</html>\n"},"__N_SSG":true}