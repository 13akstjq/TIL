{"pageProps":{"posts":[{"title":"로그인 시 폼 유효성 검사가 작동하지 않는 이유는","description":"","date":"2024-07-07 19:18","slug":"2024-07-07-Whymyformvalidationwhilelogginginisnotworking","content":"\n\n내 ts 컴포넌트 파일:\n\n```js\nimport { Component, inject } from '@angular/core';\nimport { HeaderComponent } from \"../header/header.component\";\nimport { FormBuilder, Validators } from '@angular/forms';\nimport { timer } from 'rxjs';\nimport { Router, RouterModule } from '@angular/router';\nimport { AuthService } from '../../auth.service';\nimport { CommonModule } from '@angular/common';\nimport { ReactiveFormsModule } from '@angular/forms';\n@Component({\n    selector: 'app-login',\n    standalone: true,\n    templateUrl: './login.component.html',\n    styleUrl: './login.component.css',\n    imports: [HeaderComponent,CommonModule,ReactiveFormsModule]\n})\nexport class LoginComponent {\n  \n    isLoginInProgress: boolean | undefined;\n    errorMessage: string | null = null; \n    \n    form = this.fb.nonNullable.group({ \n      email: ['', Validators.required],\n      password: ['', Validators.required],\n    });\n    \n    constructor(\n      private fb: FormBuilder, \n      private authService: AuthService,\n      ) {\n      \n      const accessToken = localStorage.getItem('accessToken');\n      if (accessToken) {\n        window.history.back();\n      }\n    }\n     router = inject(Router);\n  \n    // fb = inject(FormBuilder);\n    // http = inject(HttpClient);\n    //  authService = inject(AuthService);\n    data: any[] = [];\n    \n    validateEmail(email: string): boolean {\n      if (!email) {\n        return true; // 이메일 필드가 비어있으면 유효한 것으로 간주합니다 (필요 시 조정)\n      }\n      const emailRegex = /^\\S+@\\S+\\.\\S+$/; \n      return emailRegex.test(email);\n    }\n    \n\n    noemail=false;\n    noform=false;\n    nopwd=false;\n    login=false;\n  \n    onSubmit(): void {\n      this.errorMessage = null;\n        this.noemail = false;\n        this.noform = false;\n        this.nopwd = false;\n        console.log('폼 제출됨');\n        const rawform = this.form.getRawValue();\n        const email = rawform.email.trim();\n        this.isLoginInProgress = true;\n        this.authService\n          .login(email, rawform.password.trim())\n          .subscribe({\n            next: (response) => {\n              console.log(response!.user!.uid);\n              const accessToken = response!.user!.accessToken;\n              const user_uid = response!.user!.uid;\n              localStorage.setItem('accessToken', accessToken);\n              localStorage.setItem('user_uid', user_uid);\n              this.router.navigateByUrl('/');\n              window.location.reload();\n              this.isLoginInProgress = false;\n            },\n            error: (err: any) => {\n              this.handleAuthError(err);\n              this.isLoginInProgress = false;\n            },\n          });\n        if (!email) {\n          this.noemail = true \n  \n          this.noform=false\n          // 이메일이 입력되지 않았습니다\n        } \n        if (!this.validateEmail(email)) {\n          this.noemail=false\n          this.nopwd=false\n          this.noform=true \n          // 유효하지 않은 이메일 형식입니다\n        }\n        else\n        {\n          \n          this.noform=false\n        }\n  \n        \n        const mdp=rawform.password.trim();\n        if(!mdp ) \n          {\n            this.nopwd=true\n          }  \n    }\n  \n    handleAuthError(err: any): void {\n      console.error('인증 오류:', err); \n      const rawform = this.form.getRawValue();// 검사를 위해 오류 객체 기록\n      const email = rawform.email.trim();\n      switch (err.code) {\n        case 'auth/invalid-credential':\n          this.errorMessage = '유효하지 않은 비밀번호 또는 이메일';\n          this.nopwd=false\n          this.noemail=false\n          this.noform=false\n          break;\n        case 'auth/invalid-email' :\n          if (email)\n            {\n              this.nopwd=false\n              \n            }\n          break;\n        case this.validateEmail(email)  :\n          this.noform=false\n          this.noemail=false\n          break; \n      }\n  \n    }\n  \n    isLoggedIn(): boolean {\n      const hasAccessToken = localStorage.getItem('accessToken') !== null;\n      \n      timer(1000);\n      if (hasAccessToken) {\n        return true;\n      } else {     \n        return false;\n      }\n    }\n   \n    \n}\r\n```\n\n내 html 컴포넌트 내용:\n\n```js\n<app-header style=\"background: linear-gradient(to left ,#032961,#4588ee);\"></app-header>\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <link href=\"/assets/css/styles.css\" rel=\"stylesheet\">\n  <link href=\"/assets/bootstrap/bootstrap.css\" rel=\"stylesheet\">\n  \n</head>\n<body class=\"form-v9\" style=\"background: linear-gradient(to left ,#032961,#4588ee); \">\n    <div class=\"page-content\">\n        <div class=\"form-v9-content\" >\n            <form [formGroup]=\"form\" (ngSubmit)=\"onSubmit()\" class=\"form-detail\" action=\"#\" method=\"post\">\n                <h2>로그인 양식</h2>\n                <div class=\"form-row-total\">\n                        \n                        <div *ngIf=\"login\" class=\"alert alert-success\" role=\"alert\">\n                            성공적으로 로그인했습니다\n                        </div>\n                    <div class=\"form-row\">\n                        <input type=\"text\" name=\"email\" id=\"email\" class=\"input-text\" placeholder=\"이메일 주소\" required pattern=\"[^@]+@[^@]+.[a-zA-Z]{2,6}\">\n                    </div>\n                    <div *ngIf=\"errorMessage\" class=\"alert alert-danger\" role=\"alert\">\n                        { errorMessage }\n                      </div>\n                          <div *ngIf=\"noemail \" class=\"alert alert-danger\" role=\"alert\">\n                              이메일을 입력하세요\n                          </div> \n                          <div *ngIf=\"noform\" class=\"alert alert-danger\" role=\"alert\">\n                              올바르지 않은 이메일 형식 \n                          </div>\n                </div>\n                <div class=\"form-row-total\">\n                    <div class=\"form-row\">\n                        <input type=\"password\" name=\"password\" id=\"password\" class=\"input-text\" placeholder=\"비밀번호\" required>\n                    </div>\n                    \n                    <div *ngIf=\"errorMessage\" class=\"alert alert-danger\" role=\"alert\" >\n                        { errorMessage }\n                      </div>\n                    <div *ngIf=\"nopwd\" class=\"alert alert-danger\" role=\"alert\"  style=\"margin-top: 90px;\">\n                        비밀번호를 입력하세요\n                    </div>\n                    \n                </div>\n                <div class=\"form-row-last\">\n                    <input type=\"submit\" name=\"register\" class=\"register\" value=\"로그인\" >\n                </div>\n            </form>\n        </div>\n    </div>\n</body>\r\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 로그인 버튼을 누를 때 (필드가 비어있든 아니든) 표시되는 메시지가 \"비밀번호를 입력하십시오\" 및 \"이메일을 입력하십시오\"인 것 같습니다 (즉, 변수 'nopwd' 및 'noemail'의 값은 항상 true인 것처럼 보입니다). 문제가 정확히 어디에 있을까요? 그리고 무엇을 변경해야 할까요?\n\n# 해결책\n\n입력란에 formControlName을 추가하는 것을 잊으신 것 같습니다.\n\n```js\n<input type=\"text\" formControlName=\"email\" name=\"email\" id=\"email\" class=\"input-text\" placeholder=\"이메일을 입력하세요\" required pattern=\"[^@]+@[^@]+.[a-zA-Z]{2,6}\">\n\n<input type=\"password\" formControlName=\"password\" name=\"password\" id=\"password\" class=\"input-text\" placeholder=\"비밀번호를 입력하세요\" required>\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n코드를 개선했습니다.\n\ncomponent.ts\n\n```js\nimport { ChangeDetectionStrategy, Component, inject, signal } from '@angular/core';\nimport { Router, RouterOutlet } from '@angular/router';\nimport { AuthService } from '../../auth.service';\nimport { Location } from '@angular/common';\nimport { FormControl, FormGroup, ReactiveFormsModule, Validators } from '@angular/forms';\nimport { CustomValidators } from './custom-validators';\nimport { catchError, of, take, tap } from 'rxjs';\nimport { HttpErrorResponse } from '@angular/common/http';\n\n@Component({\n  selector: 'app-login',\n  standalone: true,\n  templateUrl: './login.component.html',\n  styleUrl: './login.component.css',\n  imports: [RouterOutlet, ReactiveFormsModule],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class AppComponent {\n  private readonly _router = inject(Router);\n  private readonly _location = inject(Location);\n  private readonly _authService = inject(TestAuthService);\n\n  authError = signal<boolean>(false);\n  isLoginInProgress = signal<boolean>(false);\n\n  form = new FormGroup({\n    email: new FormControl<string>('', { nonNullable: true, validators: [Validators.required, CustomValidators.email] }),\n    password: new FormControl<string>('', { nonNullable: true, validators: [Validators.required] }),\n  });\n\n  login = false; // 항상 false입니다 O_o\n\n  constructor() {\n    const accessToken = localStorage.getItem('accessToken');\n    if (accessToken) this._location.back();\n  }\n\n  onSubmit(): void {\n    this.isLoginInProgress.set(true);\n    this._authService\n      .login(this.form.controls.email.value.trim(), this.form.controls.password.value.trim())\n      .pipe(\n        catchError((error: HttpErrorResponse) => {\n          this.handleAuthError(error);\n          return of(error);\n        }),\n        tap(response => this._handleLogin(response)),\n        finalize(() => this.isLoginInProgress.set(false))\n      )\n      .subscribe();\n  }\n\n  private _handleLogin(response: any): void {\n    if (!response?.user) return;\n\n    const accessToken = response.user.accessToken;\n    const user_uid = response.user.uid;\n    localStorage.setItem('accessToken', accessToken);\n    localStorage.setItem('user_uid', user_uid);\n    this._router.navigateByUrl('/');\n    window.location.reload();\n  }\n\n  handleAuthError(err: HttpErrorResponse): void {\n    if (!err.error.code) return;\n\n    this.authError.set(true);\n    this.form.valueChanges\n      .pipe(\n        take(1),\n        tap(() => this.authError.set(false))\n      )\n      .subscribe();\n  }\n\n  isLoggedIn(): boolean {\n    return localStorage.getItem('accessToken') !== null\n  }\n}\n```\n\ncomponent.html\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n```html\n<form [formGroup]=\"form\" (ngSubmit)=\"onSubmit()\" class=\"form-detail\">\n  <h2>Login Form</h2>\n  <div class=\"form-row-total\">\n\n    @if(login) {\n      <div class=\"alert alert-success\" role=\"alert\">\n        Login avec succès\n      </div>\n    }\n\n    <div class=\"form-row\">\n      <input type=\"text\" formControlName=\"email\" name=\"email\" id=\"email\" class=\"input-text\" placeholder=\"이메일\" required pattern=\"[^@]+@[^@]+\\.[a-zA-Z]{2,6}\">\n    </div>\n    @if (authError()) {\n      <div class=\"alert alert-danger\" role=\"alert\">\n        잘못된 비밀번호 또는 이메일\n      </div>\n    }\n    @if (form.controls.email.errors?.required) {\n      <div class=\"alert alert-danger\" role=\"alert\">\n        이메일을 입력해주세요\n      </div>\n    }\n    @if (form.controls.email.errors?.email) {\n      <div class=\"alert alert-danger\" role=\"alert\">\n        잘못된 이메일 형식입니다\n      </div>\n    }\n  </div>\n\n  <div class=\"form-row-total\">\n    <div class=\"form-row\">\n      <input type=\"password\" formControlName=\"password\" name=\"password\" id=\"password\" class=\"input-text\" placeholder=\"비밀번호\" required>\n    </div>\n\n    @if (authError()) {\n      <div class=\"alert alert-danger\" role=\"alert\" >\n        잘못된 비밀번호 또는 이메일\n      </div>\n    }\n\n    @if (form.controls.password.errors?.required) {\n      <div class=\"alert alert-danger\" role=\"alert\"  style=\"margin-top: 90px;\">\n        비밀번호를 입력해주세요\n      </div>\n    }\n\n  </div>\n  <div class=\"form-row-last\">\n    <input type=\"submit\" name=\"register\" class=\"register\" value=\"로그인\" [disabled]=\"!form.valid\" >\n  </div>\n</form>\n```\n\ncustom-validators.ts\n\n```js\nimport { AbstractControl, ValidationErrors } from '@angular/forms';\n\nexport class CustomValidators {\n  static email(control: AbstractControl<string>): ValidationErrors | null {\n    const emailRegex = new RegExp(/^\\S+@\\S+\\.\\S+$/);\n\n    if (!control.value) return null;\n    return emailRegex.test(control.value) ? null : { email: true };\n  }\n}\n``` \n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n답변 확인자 - Marie Seifert (수정 관리자)\n\n이 답변은 stackoverflow에서 수집되었으며 cc by-sa 2.5, cc by-sa 3.0 및 cc by-sa 4.0의 라이센스를 따릅니다.","ogImage":{"url":"/TIL/assets/no-image.jpg"},"coverImage":"/TIL/assets/no-image.jpg","tag":["Tech"],"readingTime":13},{"title":"Pytest로 소프트웨어 테스트하는 종합 가이드 2","description":"","date":"2024-07-07 19:17","slug":"2024-07-07-AComprehensiveGuidetoSoftwareTestingwithPytest2","content":"\n<img src=\"/TIL/assets/img/2024-07-07-AComprehensiveGuidetoSoftwareTestingwithPytest2_0.png\" />\n\n두 번째 부분에서는 소프트웨어 테스트의 원칙과 실천 방법에 대해 이야기하겠습니다. 또한 \"pytest가 이러한 원칙과 실천 방법을 구현하는 데 어떻게 도움이 되는지\"에 대한 질문에 대답할 것입니다.\n\n이전 게시물인 Pytest를 사용한 소프트웨어 테스트의 포괄적인 가이드 #1에서 이미 설명한 내용인데, 이것은 향후 테스트 구현 및 전략을 위한 중요한 기반 요소로 생각합니다. 이미 1부 게시물을 읽었다면 이 내용은 건너뛰셔도 됩니다.\n\n# 소프트웨어 테스트의 필요성은 무엇인가요?\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 소프트웨어 요구 사항 충족을 보장합니다.\n- 올바른 구성을 확인합니다.\n- 버그를 일찍 발견합니다.\n\n## 초기 테스트의 중요성\n\n- 시간 절약: 디버깅 및 재작업을 줄입니다.\n- 즉각적인 피드백: 빠르게 문제를 식별하고 해결합니다.\n- 생산성 향상: 집중된 개발을 장려합니다.\n- 주요 문제 예방: 안정성과 자신감을 보장합니다.\n\n## 소프트웨어 테스트 수명 주기 (STLC)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 요구 사항 분석: 요구 사항 명확화.\n- 테스트 계획: 목표, 범위, 및 자원 정의.\n- 테스트 케이스 설계: 자세한 테스트 케이스 작성.\n- 테스트 환경 설정: 환경 준비 및 테스트.\n- 테스트 실행: 테스트 실행, 결함 기록, 및 재테스트.\n- 테스트 마감: 테스트 완료, 서명 확인.\n\n## 소프트웨어 테스팅 유형\n\n- 기능 테스팅: 단위, 통합, 시스템, 회귀, 상호작용, 스모크, 및 수용 테스팅.\n- 비기능 테스팅: 성능, 로드, 스트레스, UI, 보안, 사용성, 및 호환성 테스팅.\n\n## 다양한 관행 및 개발자의 마인드셋\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n실무에서 테스트 코드를 작성할 때 아래의 사고/실천 프레임워크 중 하나 이상을 반드시 사용한다는 것을 발견했습니다, 특히 CI/CD 부분에서!\n\n- 테스트 주도 개발 (TDD):\n\n- TDD는 코드 작성 전에 테스트 코드를 작성하는 소프트웨어 개발 접근 방식입니다. 이 방법은 코드베이스가 지속적으로 테스트되도록 보장합니다. 이 과정은 실패하는 테스트를 작성하고, 테스트를 통과시키는 코드를 작성하고, 코드를 개선하기 위해 코드를 리팩터링하는 주기를 따릅니다. 이 접근 방식은 작은 증분적인 단계에 집중함으로써 코드 품질과 디자인을 향상시키는 데 기여한다.\n\n2. 행위 주도 개발 (BDD):\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- BDD는 테스트를 소프트웨어의 예상 동작을 설명하는 방식으로 작성하며, 자연어 구조를 사용하는 경우가 많습니다. 이를 통해 테스트가 비기술 관계자에게 더 잘 이해되어 개발자, 테스터 및 비즈니스 분석가 간의 협력을 촉진합니다.\n\n3. 지속적 통합 (CI):\n\n- CI는 코드 변경을 자주 공유 저장소에 통합한 후 자동 빌드 및 테스트를 수행하는 실천입니다. 이 실천은 개발 주기 초기에 문제를 감지하고 해결하는 데 도움을 주며, 소프트웨어 업데이트를 제공하는 데 걸리는 시간을 줄이고 품질을 향상시킵니다.\n\n4. 지속적 배포 (CD):\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- CD는 자동화된 테스트를 통과하자마자 코드를 프로덕션 환경에 자동으로 배포하여 CI를 확장합니다. 이 실천 방법은 새로운 기능 및 수정 사항이 빠르고 일관되게 사용자에게 제공되도록 보장하며, 수동 개입을 최소화하고 배포 문제의 위험을 줄입니다.\n\n# 그러니까, 테스트 케이스를 설계할 때 주의할 점은 무엇일까요?\n\n여기서, 이론을 일부 실용적인 코드 조각과 함께 보충하는 것이 좋을 것 같았습니다. 나중에 이 시리즈의 블로그에서 pytest에 대한 깊이 있는 소개와 설명을 작성할 예정입니다.\n\n## 테스트를 위한 최상의 실첵\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 명확하고 간결한 테스트 작성하기:\n\n- 각 테스트가 이해하기 쉽고 단일 기능에 집중되도록 보장합니다.\n- 예시: 이름대로, 두 숫자를 더하고 싶다면 해당 함수에 그 역할을 부여하는 것이 좋습니다.\n\n```js\ndef test_addition_function_adds_two_numbers_correctly():\n    assert addition(2, 3) == 5\n```\n\n2. 테스트 격리:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 테스트들은 서로에게 의존하지 않도록 해야합니다. 그렇지 않으면 잘못된 양성 또는 음성 결과가 발생할 수 있습니다.\n- 예시: 각 테스트는 자체 환경을 설정하고 해체해야 합니다. 즉, 각 데이터는 자체 데이터 입력 설정(예를 들어 fixtures를 통해)과 데이터 정리(해체) 로직을 가져야 합니다.\n\n```python\nimport pytest\n@pytest.fixture\ndef setup_environment():\n    # 설정 코드\n    yield\n    # 해체 코드\ndef test_example(setup_environment):\n    assert example_function() == expected_result\n```\n\n3. 설명적인 이름 사용하기:\n\n- 테스트 함수에 설명적인 이름을 지어서 무엇이 테스트되고 있는지 명확하게 표현하세요.\n- 예시: 만약 두 숫자를 더하는 test_function이라는 함수가 있다면, test_function 대신 test_addition_function_adds_two_numbers_correctly와 같이 명확한 이름을 사용하세요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\ndef test_addition_function_adds_two_numbers_correctly():\nassert addition(2, 3) == 5\n\n4. 자동화 테스트:\n\n- CI/CD 파이프라인에 테스트를 통합하여 각 코드 변경마다 자동으로 실행되도록 합니다.\n- 예시: Jenkins, Travis CI 또는 GitHub Actions를 사용하여 테스트 실행을 자동화합니다.\n- Pytest는 CI/CD 파이프라인에 쉽게 통합할 수 있습니다. 프로젝트에 구성 파일을 추가하여 테스트를 자동 실행합니다.\n- 예시: GitHub Actions를 위한 .github/workflows/python-app.yml을 사용합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n5. 테스트 검토 및 리팩터링:\n\n- 효율성과 효과를 향상시키기 위해 정기적으로 테스트를 검토합니다.\n- 예시: 중복되는 테스트를 제거하고 오래된 테스트를 업데이트하며, 모든 예외 케이스를 커버합니다.\n- 코드 커버리지 보고서를 생성하기 위해 pytest-cov와 같은 Pytest 플러그인을 사용하고, pytest-xdist를 사용하여 병렬 테스트를 실행합니다.\n\n```bash\npip install pytest-cov pytest-xdist\npytest --cov=my_package --cov-report=html\npytest -n 4  # 4개의 코어를 사용하여 테스트를 병렬로 실행합니다\n```\n\n# 참고 문헌\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Agile Alliance. \"테스트 주도 개발(TDD)란 무엇인가요?\" Agile Alliance\n- BrowserStack. \"테스트 주도 개발(TDD)란 무엇인가요?\" BrowserStack\n- Wikipedia. \"테스트 주도 개발\" Wikipedia\n- Built In. \"테스트 주도 개발(TDD)란 무엇인가요? 안내.\" Built In\n- Agile Alliance. \"행위 주도 개발(BDD)란 무엇인가요?\" Agile Alliance\n- Wikipedia. \"행위 주도 개발\" Wikipedia\n- LambdaTest. \"행위 주도 개발(BDD)란 무엇인가요? 전체 가이드.\" LambdaTest\n- BrowserStack. \"BDD가 뭔가요? (행위 주도 개발)\" BrowserStack\n","ogImage":{"url":"/assets/img/2024-07-07-AComprehensiveGuidetoSoftwareTestingwithPytest2_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-AComprehensiveGuidetoSoftwareTestingwithPytest2_0.png","tag":["Tech"],"readingTime":7},{"title":"Python 프로젝트 개선하기 두 번째 날, 첫 Python 프로젝트 개선 방법","description":"","date":"2024-07-07 19:16","slug":"2024-07-07-Day2ImprovingMyFirstPythonProject","content":"\n## 30-DAY CODING CHALLENGE\n\n![Day 2](/TIL/assets/img/2024-07-07-Day2ImprovingMyFirstPythonProject_0.png)\n\n안녕하세요! 저의 Day 2 보고서가 아주 늦게 나오고 있어요. 제 도시에 정전이 있었거든요. 어쨌든, 오늘 코딩을 시작하기 전에 어제 한 일을 간단히 공유할게요:\n\n파이썬을 처음 배울 때, 이게 가장 처음으로 한 실제적인 작업이었어요. GUI까지 디자인한 적은 없지만, input, if, elif, else, try, 그리고 except와 같은 기본 함수들을 사용했죠. 부지런히 코딩해보세요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 1.0 버전, 그것을 그렇게 부를게요, 켈빈과 섭씨 간 변환만 가능했어요. 다음처럼 보였답니다:\n\n그래서, 어제 나는 다시 처음부터 온도 변환기 코드를 작성했어요. 이번에는 화씨에 주의를 기울였지만, 내 랜덤 단어 생성기처럼 아직도 만족스럽지 않아요.\n\n세계와 나누기 전에 적절한 인터페이스를 디자인하고 싶어요.\n\n어쨌든, 시간이 지나면서 많은 결정을 내리는 편이기 때문에 마음을 바꿀 수도 있어요.\n","ogImage":{"url":"/assets/img/2024-07-07-Day2ImprovingMyFirstPythonProject_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-Day2ImprovingMyFirstPythonProject_0.png","tag":["Tech"],"readingTime":1},{"title":"코드 몇 줄로 40개의 머신러닝 모델 적용하는 방법","description":"","date":"2024-07-07 19:15","slug":"2024-07-07-Acouplelinesofcodetoapply40MLmodels","content":"\n<img src=\"/TIL/assets/img/2024-07-07-Acouplelinesofcodetoapply40MLmodels_0.png\" />\n\n이 글에서는 \"lazypredict\" 라이브러리를 소개하려고 합니다. 이 라이브러리를 사용하면 여러 개의 머신러닝 모델을 동시에 적용할 수 있습니다.\n\n이 라이브러리는 pip로 설치할 수 있습니다:\n\n<img src=\"/TIL/assets/img/2024-07-07-Acouplelinesofcodetoapply40MLmodels_1.png\" />\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기에서는 mal 고객 데이터 세트를 사용합니다: [링크](https://gist.githubusercontent.com/pravalliyaram/5c05f43d2351249927b8a3f3cc3e5ecf/raw/8bd6144a87988213693754baaa13fb204933282d/Mall_Customers.csv)\n\n데이터 세트의 처음을 살펴보겠습니다:\n\n```python\nimport pandas as pd\n\ndf = pd.read_csv('https://gist.githubusercontent.com/pravalliyaram/5c05f43d2351249927b8a3f3cc3e5ecf/raw/8bd6144a87988213693754baaa13fb204933282d/Mall_Customers.csv')\n\ndf.head()\n```\n\n![이미지](/TIL/assets/img/2024-07-07-Acouplelinesofcodetoapply40MLmodels_2.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n간단해요. \"지출 점수\"는 종속 변수 Y이고 다른 필드들은 X입니다.\n\n그런 다음, 데이터 집합을 훈련 세트와 테스트 세트로 분할하십시오:\n\n```js\nfrom sklearn.model_selection import train_test_split\n\nX = df.loc[:, df.columns != 'Spending Score (1-100)']\ny = df['Spending Score (1-100)']\n\nX_train, X_test, y_train, y_test =…\n```\n","ogImage":{"url":"/assets/img/2024-07-07-Acouplelinesofcodetoapply40MLmodels_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-Acouplelinesofcodetoapply40MLmodels_0.png","tag":["Tech"],"readingTime":2},{"title":"Python을 사용한 외환 시장에서 차익 거래 기회 발견하는 방법","description":"","date":"2024-07-07 19:15","slug":"2024-07-07-UncoveringArbitrageOpportunitiesinForeignExchangeMarketswithPython","content":"\n외환 시장에서의 차익거래 기회는 오랫동안 거래자와 투자자들의 관심사였습니다. 서로 다른 시장과 브로커들 간의 가격 차이를 이용하여 무위험 수익을 창출하는 개념은 매력적이지만, 이러한 기회를 식별하고 활용하기 위해서는 외환 시장에 대한 심층적인 이해와 대량 데이터를 신속하고 효율적으로 분석하고 처리할 수 있는 능력이 필요합니다. 여기서 파이썬이 등장합니다 — 거래자와 연구자 모두에게 필수 도구가 된 강력한 프로그래밍 언어입니다.\n\n![외환 시장에서의 차익거래 기회](/TIL/assets/img/2024-07-07-UncoveringArbitrageOpportunitiesinForeignExchangeMarketswithPython_0.png)\n\n목차\n\n- 1. 외환 시장 이해: 외환 시장, 통화 쌍 및 시장 구조에 대한 간단한 개요.\n- 2. 삼각 차익거래: 삼각 차익거래의 정의, 유형 및 수학적 공식과 예시에 대해 설명합니다.\n- 3. 차익거래 기회 식별: 서로 다른 시장과 브로커 간의 가격 차이를 통해 차익거래 기회를 식별하는 방법에 대한 논의.\n- 4. 데이터 수집 및 전처리: pandas, NumPy 및 requests와 같은 파이썬 라이브러리를 사용하여 다양한 출처에서 외환 데이터를 수집 및 전처리하는 방법에 대해 설명합니다.\n- 5. 차익거래 수익 계산: 삼각 차익거래를 구현하는 방법...\n","ogImage":{"url":"/assets/img/2024-07-07-UncoveringArbitrageOpportunitiesinForeignExchangeMarketswithPython_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-UncoveringArbitrageOpportunitiesinForeignExchangeMarketswithPython_0.png","tag":["Tech"],"readingTime":1},{"title":"Amazon Bedrock Agents 및 AI로 작업 자동화하는 방법","description":"","date":"2024-07-07 13:00","slug":"2024-07-07-AutomatingtasksusingAmazonBedrockAgentsandAI","content":"\n<img src=\"/TIL/assets/img/2024-07-07-AutomatingtasksusingAmazonBedrockAgentsandAI_0.png\" />\n\n## 서문\n\n👍 Amazon Bedrock Agents가 무엇인지 알아볼 거에요.\n👍 AWS 아키텍처를 자세히 살펴볼 거에요.\n👍 TypeScript 및 AWS CDK 코드를 살펴볼 거에요.\n👍 작동 방식을 보기 위해 몇 가지 테스트를 진행해 볼 거에요.\n\n# 소개 👋🏽\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAmazon Bedrock Agents은 당신이 회사 내에서 스스로 작업을 수행할 수 있는 자율 에이전트를 구축하고 사용자 정의할 수 있도록 도와줍니다. 이러한 에이전트는 기관 데이터와 사용자 입력을 활용하여 대화형 채팅과 AI를 이용해 작업을 수행하여 최종 사용자가 작업을 완료하는 데 도움을 줍니다.\n\n이들은 기본 모델, 데이터 소스, 지식베이스, 소프트웨어 응용 프로그램 및 사용자 대화 간의 상호작용을 관리하는 조정자 역할을 합니다. 추가로, 이들은 API 호출을 자동화하여 조치를 수행하고 이러한 조치와 관련된 정보를 풍부하게 하는 지식 베이스에 접근합니다.\n\n![Automating tasks using Amazon Bedrock Agents and AI](/TIL/assets/img/2024-07-07-AutomatingtasksusingAmazonBedrockAgentsandAI_1.png)\n\n본 문서에서는 가상의 호텔 및 스파 회사인 LJ Resorts를 다루어 AWS 구조와 코드를 살펴보겠습니다. 우리의 고객은 당사 애플리케이션을 사용하여 호텔 숙박, 골프 세션 및 스파 치료를 한꺼번에 예약하거나 이용 가능한 치료 및 할인, 영업 시간과 같은 회사 정보를 요청할 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Image 1](/TIL/assets/img/2024-07-07-AutomatingtasksusingAmazonBedrockAgentsandAI_2.png)\n\nThe full code repository can be found here:\n\n👇 Before we go any further — please connect with me on LinkedIn for future blog posts and Serverless news [Lee James Gilmore](https://www.linkedin.com/in/lee-james-gilmore/)\n\n![Image 2](/TIL/assets/img/2024-07-07-AutomatingtasksusingAmazonBedrockAgentsandAI_3.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 아마존 베드락 에이전트란 무엇인가요? 🤖\n\n이제 아마존 베드락 에이전트에 대해 이야기해보겠습니다. 어떤 일을 하는지 알아보면서 시작해봅시다. 먼저 중요한 약어 몇 가지를 이해해 봅시다.\n\n## 약어\n\n시작하기 전에 약어 몇 가지와 그 의미에 대해 알아봅시다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n✔️ FM - 기본 모델\n\n✔️ 액션 그룹\n\n✔️ 지침\n\n🤖 \"고객이 호텔 객실, 스파 세션, 그리고 골프 예약을 도와주시고, 해당하는 날짜와 예약 유형에 따라 특별 혜택을 제공해 주세요. 예약을 완료하기 전에 오프닝 타임이나 가격에 대해 고객에게 안내하고, 호텔 정책을 고려해 주세요.\"\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Automating tasks using Amazon Bedrock Agents and AI](/TIL/assets/img/2024-07-07-AutomatingtasksusingAmazonBedrockAgentsandAI_4.png)\n\n## Amazon Bedrock 에이전트는 어떻게 작동하나요? 🤖\n\n아래 다이어그램에서 볼 수 있듯이, 우리는 고객의 입력부터 시작합니다. 이 입력은 프롬프트 스토어로 증가되어 세션 스토어에서 가져온 이전 대화 내용과 함께 바탕 모델을 호출하여 보강됩니다.\n\n다음으로 Orchestration prompt는 응답을 구문 분석하고 우리의 OpenAPI 사양 문서에 정의된 작업에 따라 액션 그룹 람다를 호출하며 Bedrock Knowledge Base에서 필요한 추가 정보를 가져옵니다. Orchestration이 완료되면 결과가 고객에게 반환됩니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/TIL/assets/img/2024-07-07-AutomatingtasksusingAmazonBedrockAgentsandAI_5.png)\n\n다음 섹션에서는 본문에서 무엇을 구축 중인지 살펴보겠습니다. 그러면 코드를 살펴보고 응용 프로그램을 배포하고 테스트할 수 있습니다.\n\n# 무엇을 만들고 있을까요? 🛠️\n\n그래, 이제 Amazon Bedrock와 함께 에이전트에 대해 깊이 파고들었으며 이론적으로 작동 방식을 이해했으니, 이제 이 글에서 무엇을 만들고 있는지 살펴봅시다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/TIL/assets/img/2024-07-07-AutomatingtasksusingAmazonBedrockAgentsandAI_6.png\" />\n\n저희는 이전 글에서 Amazon Bedrock Knowledge Bases에 대해 다뤘었는데, 해당 글은 여기에서 찾아볼 수 있어요:\n\n위 다이어그램에서 볼 수 있는 것은 다음과 같아요:\n\n- 고객이 자신의 프롬프트로 Lambda 함수 URL을 탭합니다.\n- 이는 쿼리 Lambda 함수를 호출하며, 이 함수는 다시 Amazon Bedrock 에이전트를 호출합니다.\n- 에이전트는 특정 회사 데이터를 사용한 배포된 Knowledge Base와 S3 버킷에 있는 OpenAPI 사억을 기반으로 한 Lambda 함수를 사용하여 고객의 작업을 완료하기 위해 다른 내부 시스템에 경로를 지정합니다 (여러 호출을 우리를 대신하여 조정할 것입니다).\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 고수준 아키텍처를 논의했으니, 다음 섹션에서 예시 상호작용을 살펴봅시다.\n\n# 상호작용이 어떻게 보일까요? ⛳\n\n아래 예시 상호작용을 살펴보면 고객이 에이전트와 채팅하는 모습을 볼 수 있습니다. 사실, 이는 실제 프롬프트와 출력값을 사용하여 우리의 예시 솔루션을 통해 실행된 것입니다:\n\nCustomer: “Hi, what special deals do you have on at the moment for hotels?”\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n에이전트: \"현재 이용 가능한 호텔 특별 할인은 다음과 같습니다: - 월요일 스테이케이션 특가: 객실 요금 20% 할인 (월요일만) - 급행 투숙 특가: 당일 예약 시 15% 할인 (화요일만) - 연박 할인: 3박 숙박 20% 할인 (수요일만) - 스위트 업그레이드: 익스큐티브 스위트 무료 업그레이드 (목요일만) - 주말 여행 패키지: 2박 숙박 10% 할인 (금요일만)\"\n\n고객: \"2024년 02월 25일에 호텔 객실을 예약하고 싶어요, 현재 무엇이 가능한가요?\"\n\n에이전트: \"2024년 02월 25일 이용 가능한 객실은 다음과 같습니다: - 101호 객실(스탠다드, $100): 퀸 사이즈 침대가 있는 아늑한 표준 객실 - 102호 객실(스탠다드, $100): 두 개의 더블 침대가 있는 넓은 표준 객실 - 103호 객실(디럭스, $150): 킹 사이즈 침대와 전망이 있는 호화로운 디럭스 객실 - 104호 객실(스위트, $200): 별도의 거실 공간과 침실이 있는 우아한 스위트 - 105호 객실(스탠다드, $90): ..생략..\"\n\n고객: \"2024년 02월 25일에 디럭스 객실을 $160에 예약할 수 있나요?\"\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n에이전트: \"2024년 2월 25일에 109호 객실을 예약해드렸습니다. 이 객실은 명품 욕실이 있는 디럭스 객실이며, 160달러입니다. 필요한 것이 있으면 언제든지 알려주세요!\"\n\n고객: \"어떤 스파 시술이 가능한가요?\"\n\n에이전트: \"오늘 가능한 스파 시술 목록입니다: — 스웨디시 마사지: 긴장을 완화하고 이완을 촉진하는 전신 마사지. 가격: 80달러 — 페이셜: 피부를 재생하고 활기를 되찾는 깊은 클렌징 페이셜. 가격: 70달러 — 핫 스톤 마사지: 가열된 돌을 사용한 치료적인 마사지로 근육을 진정시키고 혈류를 향상시킵니다. 가격: 90달러 — 아로마테라피: 아로마 향기로 편안함과 웰빙을 높이는 섬세한 마사지. 가격: 85달러 — ….'간략히 하기 위해 나머지 제거됨'\"\n\n고객: \"핫 스톤 마사지를 예약할 수 있나요?\"\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAgent: \"네, 오늘 당신을 위해 핫 스톤 마사지를 예약했어요. 이 치료 마사지는 가열된 돌을 사용하여 근육을 진정시키고 혈액 순환이 향상됩니다. 비용은 $90이에요. 더 필요한 게 있으면 언제든지 말해주세요!\"\n\nCustomer: \"골프의 영업 시간은 어떻게 되나요?\"\n\nAgent: \"LJ 리조트의 골프 영업 시간은 다음과 같아요: 월요일부터 금요일까지: 오전 9시 — 오후 6시 토요일 및 일요일: 오전 7시 — 오후 7시\"\n\nCustomer: \"해당 날에도 아침에는 골프 세션도 있나요?\"\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n에이전트: \"오늘 가능한 골프 세션을 확인해보니 아침 세션 하나가 있네요: 아침 티 타임: 아침에 멋진 전망과 함께 골프를 즐기세요. 비용: $80 이 아침 골프 세션을 예약해 드릴까요?\"\n\n고객: \"제가 $80에 그 날 골프 세션을 예약할 수 있을까요?\"\n\n에이전트: \"네, $80에 아침 골프 세션을 오늘 예약해 드렸습니다. 이 세션에서는 아침에 멋진 경치를 감상하며 골프를 즐길 수 있을 거예요. 더 필요한 사항이 있으시면 언제든지 말해 주세요!\"\n\n고객: \"제 예약의 총 비용이 얼마인가요?\"\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n에이전트: \"대화 기록을 기반으로 하면, 핫 스톤 마사지를 90달러에 예약하셨고, 아침 골프 세션을 80달러에 예약하셨습니다. 예약 총 비용은 90달러 + 80달러 = 170달러입니다.\"\n\n이것은 베드락 에이전트가 얼마나 강력한지 보여줍니다. 이것은 사람이 여러 시스템에 액세스해 고객과 직접 대면해야 하는 작업을 대체한 것입니다. 인공지능이 전체 프로세스를 자동화하는 데 사용되었습니다.\n\n이제 고객과 에이전트 간에 발생할 수있는 상호 작용을 살펴 보았으니, 주요 코드를 살펴 보겠습니다.\n\n# 주요 코드 설명하기 👨‍💻\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n알겠어요, 우리는 이 기본 예제를 실제로 본 것이고, 이제 TypeScript 및 CDK 코드를 살펴보겠습니다. 전체 솔루션은 여기에서 찾으실 수 있습니다.\n\n## Stateful Stack\n\n먼저 상태 유지 스택부터 시작해봅시다. 여기서 먼저 에이전트 람다 함수를 생성합니다:\n\n```js\n// create the lambda for the agent - this is the lambda that determines\n// what the prompt looks like with regards to mapping to the schema\nconst actionGroupAgentLambda: nodeLambda.NodejsFunction = new nodeLambda.NodejsFunction(this, \"AgentLambda\", {\n  functionName: \"action-group-executor\",\n  runtime: lambda.Runtime.NODEJS_20_X,\n  entry: path.join(__dirname, \"./src/adapters/primary/action-group-executor/action-group-executor.adapter.ts\"),\n  memorySize: 1024,\n  handler: \"handler\",\n  timeout: cdk.Duration.minutes(5),\n  description: \"action group lambda function\",\n  architecture: lambda.Architecture.ARM_64,\n  tracing: lambda.Tracing.ACTIVE,\n  bundling: {\n    minify: true,\n  },\n  environment: {\n    ...lambdaConfig,\n  },\n});\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음은 아래에 표시된대로 우리의 Amazon Bedrock 에이전트를 생성합니다:\n\n```js\n// bedrock 에이전트 생성\nconst agent = new bedrock.Agent(this, \"BedrockAgent\", {\n  name: \"에이전트\",\n  description: \"호텔, 스파 및 골프 예약을 위한 에이전트입니다.\",\n  foundationModel: bedrock.BedrockFoundationModel.ANTHROPIC_CLAUDE_V2,\n  instruction:\n    \"고객이 호텔 객실, 스파 세션 및 골프 예약을 도와주셔서 감사하겠습니다. 그들에게 요일 및 예약 유형에 따라 특별 제공상품에 대해 알려주시고, 예약을 완료하기 전에 오픈 시간이나 가격을 안내해주시고, 또한 호텔 정책을 고려해주시기 바랍니다.\",\n  idleSessionTTL: cdk.Duration.minutes(10),\n  knowledgeBases: [kb],\n  shouldPrepareAgent: true,\n  aliasName: \"에이전트\",\n});\n```\n\n위의 코드에서 보듯이, 에이전트에게 세션 지속 시간, Amazon Bedrock 지식 베이스에 대한 링크, FM 유형(Claud V2) 및 이 에이전트가 수행해야 할 작업에 대한 지시 사항과 같은 주요 속성들을 지정합니다.\n\n다음으로, 아래와 같이 Action 그룹을 생성합니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n// 예약을 위한 동작 그룹을 추가합니다.\nnew bedrock.AgentActionGroup(this, \"AgentActionGroup\", {\n  actionGroupName: \"agent-action-group\",\n  description: \"예약을 위한 동작 그룹\",\n  agent: agent,\n  apiSchema: bedrock.S3ApiSchema.fromAsset(path.join(__dirname, \"./schema/api-schema.json\")),\n  actionGroupState: \"ENABLED\",\n  actionGroupExecutor: actionGroupAgentLambda,\n  shouldPrepareAgent: true,\n});\n```\n\n우리는 에이전트가 할 수 있는 것을 상세히 설명하는 Open API 스키마와 동작에 대한 프록시로 호출되는 람다 함수를 제공한다는 것을 알 수 있습니다. 이제 Open API 사양이 어떻게 보이는지 살펴보겠습니다:\n\n```js\n{\n  \"openapi\": \"3.0.0\",\n  \"info\": {\n    \"title\": \"LJ 리조트를 위한 호텔, 스파 및 골프 예약 API\",\n    \"version\": \"1.0.0\",\n    \"description\": \"고객의 호텔, 스파 및 골프 예약을 관리하기 위한 API입니다.\"\n  },\n  \"paths\": {\n    \"/rooms\": {\n      \"get\": {\n        \"summary\": \"이용 가능한 모든 객실 목록을 가져옵니다\",\n        \"description\": \"특정 날짜에 이용 가능한 모든 객실 목록을 가져옵니다\",\n        \"operationId\": \"getAllAvailableRooms\",\n        \"responses\": {\n          \"200\": {\n            \"description\": \"특정 날짜에 이용 가능한 모든 객실 목록을 가져옵니다\",\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"type\": \"array\",\n                  \"items\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"roomId\": {\n                        \"type\": \"string\",\n                        \"description\": \"객실의 고유 ID입니다.\"\n                      },\n                      \"roomType\": {\n                        \"type\": \"string\",\n                        \"description\": \"객실 유형입니다.\"\n                      },\n                      \"roomDescription\": {\n                        \"type\": \"string\",\n                        \"description\": \"객실 설명입니다.\"\n                      },\n                      \"date\": {\n                        \"type\": \"string\",\n                        \"description\": \"객실 예약 가능한 날짜입니다.\"\n                      },\n                      \"cost\": {\n                        \"type\": \"string\",\n                        \"description\": \"객실 비용(1박당)입니다.\"\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      },\n      \"post\": {\n        \"summary\": \"특정 날짜에 이용 가능한 객실을 예약합니다\",\n        \"description\": \"특정 날짜에 객실을 예약합니다\",\n        \"operationId\": \"bookRoom\",\n        \"requestBody\": {\n          \"required\": true,\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"type\": \"object\",\n                \"properties\": {\n                  \"roomId\": {\n                    \"type\": \"string\",\n                    \"description\": \"예약할 객실의 ID입니다\"\n                  },\n                  \"date\": {\n                    \"type\": \"string\",\n                    \"description\": \"객실 예약 날짜입니다\"\n                  }\n                },\n                \"required\": [\"roomId\", \"date\"]\n              }\n            }\n          }\n        },\n        \"responses\": {\n          \"200\": {\n            \"description\": \"객실 예약 성공\"\n          }\n        }\n      }\n    },\n    \"/spa-sessions\": {\n      ...\n    },\n    \"/golf-sessions\": {\n      ...\n    }\n  }\n}\n```\n\n모델이 수행해야 할 작업을 결정하는 중요한 부분은 설명, 경로, 메서드 및 작업 ID입니다. 예를 들어, 모든 호텔 객실을 나열하기 위해 사용하는 것은 다음과 같습니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n**Description** - \"특정 날짜에 대한 모든 이용 가능한 객실 목록을 가져옵니다\".\n**OperationId** - \"getAllAvailableRooms\".\n**Path** - ‘/rooms’.\n**Method** - ‘GET’.\n\n우리의 람다 함수가 호출되면 해당 세부 정보를 활용하여 호출해야 하는 다른 시스템을 결정합니다:\n\n```js\nimport { MetricUnits, Metrics, logMetrics } from \"@aws-lambda-powertools/metrics\";\nimport { Tracer, captureLambdaHandler } from \"@aws-lambda-powertools/tracer\";\nimport { golfSessions, rooms, spaTreatments } from \"stateful/src/data\";\n\nimport { injectLambdaContext } from \"@aws-lambda-powertools/logger\";\nimport middy from \"@middy/core\";\nimport { logger } from \"@shared/index\";\n\nconst tracer = new Tracer();\nconst metrics = new Metrics();\n\nexport const adapter = async ({\n  inputText,\n  apiPath,\n  httpMethod,\n  actionGroup,\n  messageVersion,\n  requestBody,\n  sessionAttributes,\n  promptSessionAttributes,\n}: Event): Promise<Response> => {\n  let body;\n  let httpStatusCode = 200;\n\n  try {\n    logger.info(`inputText: ${inputText}, apiPath: ${apiPath}, httpMethod: ${httpMethod}`);\n\n    // 참고: 실제로는 람다 FURLS 또는 다른 DB 또는 API/서비스를 호출할 것이지만,\n    // 작동 방식을 보여주기 위해 기사용 가짜 스텁 데이터를 사용합니다.\n    switch (apiPath) {\n      case \"/rooms\":\n        if (httpMethod === \"GET\") {\n          body = rooms;\n        } else if (httpMethod === \"POST\") {\n          body = rooms.find((room) => room.roomId === \"109\");\n        }\n        break;\n\n      case \"/spa-sessions\":\n        if (httpMethod === \"GET\") {\n          body = spaTreatments;\n        } else if (httpMethod === \"POST\") {\n          body = spaTreatments.find((treatment) => treatment.treatmentId === \"3\");\n        }\n        break;\n\n      case \"/golf-sessions\":\n        if (httpMethod === \"GET\") {\n          body = golfSessions;\n        } else if (httpMethod === \"POST\") {\n          body = golfSessions.find((session) => session.sessionId === \"1\");\n        }\n        break;\n\n      default:\n        httpStatusCode = 500;\n        body = \"Sorry, I am unable to help you with that. Please try asking the question in a different way perhaps.\";\n        break;\n    }\n\n    metrics.addMetric(\"SuccessfulActionGroupQuery\", MetricUnits.Count, 1);\n\n    return {\n      messageVersion,\n      response: {\n        apiPath,\n        actionGroup,\n        httpMethod,\n        httpStatusCode,\n        sessionAttributes,\n        promptSessionAttributes,\n        responseBody: {\n          \"application-json\": {\n            body: JSON.stringify(body),\n          },\n        },\n      },\n    };\n  } catch (error) {\n    let errorMessage = \"Unknown error\";\n    if (error instanceof Error) errorMessage = error.message;\n    logger.error(errorMessage);\n\n    metrics.addMetric(\"ActionGroupQueryError\", MetricUnits.Count, 1);\n\n    throw error;\n  }\n};\n\nexport const handler = middy(adapter)\n  .use(injectLambdaContext(logger))\n  .use(captureLambdaHandler(tracer))\n  .use(logMetrics(metrics));\n```\n\n위의 예제에서는 다른 시스템을 호출하는 대신 반환된 데이터를 간단히 하드코딩했음을 볼 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![스테이트리스 스택](/TIL/assets/img/2024-07-07-AutomatingtasksusingAmazonBedrockAgentsandAI_7.png)\n\n이제 우리 에이전트를 쿼리하는 스테이트리스 스택을 살펴보겠습니다.\n\n## 스테이트리스 스택\n\n먼저 스트리밍이 설정된 쿼리 람다 함수를 생성합니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n// 에이전트 쿼리를 위한 람다 함수를 생성합니다.\nconst queryModelLambda: nodeLambda.NodejsFunction = new nodeLambda.NodejsFunction(this, \"QueryModelLambda\", {\n  functionName: \"query-model-lambda\",\n  runtime: lambda.Runtime.NODEJS_20_X,\n  entry: path.join(__dirname, \"./src/adapters/primary/query-model/query-model.adapter.ts\"),\n  memorySize: 1024,\n  handler: \"handler\",\n  timeout: cdk.Duration.minutes(3),\n  description: \"쿼리 모델 람다 함수\",\n  architecture: lambda.Architecture.ARM_64,\n  tracing: lambda.Tracing.ACTIVE,\n  bundling: {\n    minify: true,\n  },\n  environment: {\n    AGENT_ID: agentId,\n    AGENT_ALIAS_ID: agentAliasId,\n    ...lambdaConfig,\n  },\n});\n\n// 쿼리 람다에 대한 함수 URL을 스트림 응답으로 추가합니다.\nconst queryModelLambdaUrl = queryModelLambda.addFunctionUrl({\n  authType: lambda.FunctionUrlAuthType.NONE,\n  invokeMode: lambda.InvokeMode.RESPONSE_STREAM,\n  cors: {\n    allowedOrigins: [\"*\"],\n  },\n});\n```\n\n그런 다음, 아래와 같이 에이전트 호출 권한을 부여합니다:\n\n```js\n// 쿼리 람다 함수가 모델/KB/에이전트를 쿼리할 수 있도록 허용합니다.\nqueryModelLambda.addToRolePolicy(\n  new iam.PolicyStatement({\n    actions: [\"bedrock:RetrieveAndGenerate\", \"bedrock:Retrieve\", \"bedrock:InvokeModel\", \"bedrock:InvokeAgent\"],\n    resources: [\"*\"],\n  })\n);\n```\n\n이제 사용자가 함수 URL을 통해 프롬프트를 제공하고 에이전트를 호출하는 Query Lambda 함수를 살펴보겠습니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport { MetricUnits, Metrics } from \"@aws-lambda-powertools/metrics\";\nimport {\n  BedrockAgentRuntimeClient,\n  InvokeAgentCommand,\n  InvokeAgentRequest,\n  InvokeAgentResponse,\n} from \"@aws-sdk/client-bedrock-agent-runtime\";\nimport { ResponseStream, streamifyResponse } from \"lambda-stream\";\n\nimport { config } from \"@config\";\nimport { ValidationError } from \"@errors/validation-error\";\nimport { logger } from \"@shared/index\";\nimport { APIGatewayProxyEventV2 } from \"aws-lambda\";\n\nconst metrics = new Metrics();\nconst client = new BedrockAgentRuntimeClient();\n\nconst agentId = config.get(\"agentId\");\nconst agentAliasId = config.get(\"agentAliasId\");\n\nfunction parseBase64(message: Uint8Array): string {\n  return Buffer.from(message).toString(\"utf-8\");\n}\n\nexport const queryModelAdapter = async (\n  { body }: APIGatewayProxyEventV2,\n  responseStream: ResponseStream\n): Promise<void> => {\n  try {\n    responseStream.setContentType(\"application/json\");\n\n    if (!body) throw new ValidationError(\"no payload body\");\n    const request = JSON.parse(body);\n\n    const { sessionAttributes, promptSessionAttributes, sessionId, prompt } = request;\n\n    const input: InvokeAgentRequest = {\n      sessionState: {\n        sessionAttributes,\n        promptSessionAttributes,\n      },\n      agentId,\n      agentAliasId,\n      sessionId,\n      inputText: prompt,\n    };\n\n    const command: InvokeAgentCommand = new InvokeAgentCommand(input);\n    const response: InvokeAgentResponse = await client.send(command);\n\n    const chunks = [];\n    const completion = response.completion || [];\n\n    for await (const chunk of completion) {\n      if (chunk.chunk && chunk.chunk.bytes) {\n        const parsed = parseBase64(chunk.chunk.bytes);\n\n        chunks.push(parsed);\n      }\n    }\n\n    const returnMessage = {\n      sessionId: response.sessionId,\n      contentType: response.contentType,\n      message: chunks.join(\" \"),\n    };\n\n    metrics.addMetric(\"SuccessfulQueryModel\", MetricUnits.Count, 1);\n\n    // Note: In the example we are not streaming, we are using the FURL request timeout feature\n    // but we could easily write the stream during the for loop if we wanted to\n    responseStream.write(returnMessage);\n    responseStream.end();\n  } catch (error) {\n    let errorMessage = \"Unknown error\";\n    if (error instanceof Error) errorMessage = error.message;\n    logger.error(errorMessage);\n\n    metrics.addMetric(\"QueryModelError\", MetricUnits.Count, 1);\n\n    responseStream.end();\n    throw error;\n  }\n  responseStream.end();\n};\n\nexport const handler = streamifyResponse(queryModelAdapter);\n```\n\n위의 코드에서는 에이전트로부터 반환된 응답을 'chunks'로 스트림으로 전송하고 있습니다. 그러나 이 예제에서는 사용자에게 실시간으로 업데이트를 제공하지 않고 완료될 때까지 기다린 후 JSON 객체로 응답합니다. 이제 다음 섹션에서 이를 테스트해보겠습니다!\n\n# 어플리케이션 테스트 🧪\n\n## Postman을 통한 테스트하기\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n당신은 postman/Bedrock Agents.postman_collection.json 파일을 사용하여 자신의 Lambda 함수 URL 정보로 테스트할 수 있습니다.\n\n다음과 같은 예시 JSON 페이로드를 사용하여 테스트할 수 있습니다:\n\n```js\n{\n  \"agentId\": \"agentId\",\n  \"agentAliasId\": \"agentAliasId\",\n  \"sessionId\": \"1f6aa00e-e585-49aa-aa2d-16adb64857c6\",\n  \"prompt\": \"Can I please book a morning golf session on 2024-02-25\"\n}\n```\n\n그리고 우리의 에이전트가 다음과 같이 응답하는 것을 확인할 수 있습니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리 에이전트는 여러 가지 작업을 조정했습니다. 첫 번째로 그날 이용할 수 있는 골프 세션을 확인하는 것이었습니다.\n\n에이전트는 먼저 '/golf-sessions/'에 'GET'을 실행해야 한다고 결정했는데, 이렇게 하면 그 날 이용 가능한 모든 골프 세션이 반환됩니다.\n\n그런 다음 예약을 하기 위해 '/golf-sessions/'에 두 번째 작업 'POST'를 연이어 실행했습니다.\n\n여기서 대화형 AI의 힘과 자율 에이전트의 역할을 볼 수 있습니다. 고객을 지원하기 위해 여러 가지 작업을 조합했습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/TIL/assets/img/2024-07-07-AutomatingtasksusingAmazonBedrockAgentsandAI_8.png)\n\n지금은 다른 시나리오에서도 이를 테스트할 수 있어요. 예를 들면 거래 확인, 스파 세션 예약 등등! 댓글에서 솔루션을 어떻게 찾았는지 알려주세요!\n\n# 마무리 인사 👋🏽\n\n이 글을 즐겨 읽어주셨기를 바랍니다. 만약 즐겁게 읽었다면 공유하고 피드백 주세요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n비슷한 콘텐츠를 위해 내 YouTube 채널을 구독해주세요!\n\n![Automating tasks using Amazon Bedrock Agents and AI](/TIL/assets/img/2024-07-07-AutomatingtasksusingAmazonBedrockAgentsandAI_9.png)\n\n아래의 링크를 통해 연락하고 싶어요:\n\n[LinkedIn - Lee James Gilmore](https://www.linkedin.com/in/lee-james-gilmore/)\n[Twitter - Lee James Gilmore](https://twitter.com/LeeJamesGilmore)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n게시물을 즐겁게 보셨다면 더 많은 게시물/시리즈를 보려면 내 프로필 Lee James Gilmore를 팔로우해주세요! 또한 인사를 건네고 Hi를 말하는 것을 잊지 마세요 👋\n\n게시물 하단의 '박수' 기능도 사용해보세요. 만약 게시물을 즐겼다면 '박수'를 또 클릭할 수 있습니다!!\n\n# 자기소개\n\n\"안녕하세요, 저는 영국을 기반으로 하는 AWS 커뮤니티 빌더, 블로거, AWS 인증 클라우드 아키텍트이자 기술 및 아키텍처 부문 글로벌 팀장 Lee입니다. 현재는 City Electrical Factors(UK) & City Electric Supply(US)에서 근무 중이며, 지난 6년 동안 주로 AWS 상에서 full-stack JavaScript로 작업해 왔습니다.\"\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저는 AWS를 사랑하는 서버리스 선구자라고 생각해요. 혁신, 소프트웨어 아키텍처, 그리고 기술에 대한 모든 것을 좋아해요.\n\n** 제공된 정보는 제 개인적인 견해이며, 해당 정보 사용에 대한 책임을 지지 않습니다. **\n\n아래 내용도 참고해보세요:\n","ogImage":{"url":"/assets/img/2024-07-07-AutomatingtasksusingAmazonBedrockAgentsandAI_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-AutomatingtasksusingAmazonBedrockAgentsandAI_0.png","tag":["Tech"],"readingTime":26},{"title":"드래그 앤 드롭 Nextjs 프로젝트에 커스텀 아이템 추가하는 방법","description":"","date":"2024-07-07 12:59","slug":"2024-07-07-AddingCustomDraggableItemsToDrag-And-DropNextJsProject","content":"\n## 이전 글의 연속입니다.\n\n만약 여러분이 Medium 회원이 아니라면, 이 기사를 여기서 읽을 수 있습니다. [niftylittleme.com](https://niftylittleme.com)로 이동하세요.\n\n참고: 이 기사는 Next.js 앱 라우터를 사용합니다.\n\n이전 글을 읽거나 살펴본 적이 있다면, 여러분의 프로젝트에 드래그 앤 드롭 기능이 있을 것입니다. 그러나 만약 작은 상자가 아닌 다른 것들을 드래그 앤 드롭하고 싶다면 어떻게 할까요? 실제로 엘리먼트를 드래그 앤 드롭하고 싶다면요? 뭔가 더 멋진 것을 원한다면, 이 튜토리얼은 여러분을 위한 것입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 시작하기 전에 여기서 정확히 무엇을 하는지 이해하려면 이전 기사를 읽어야 합니다. 그래서 그것을 확인하고 돌아와주세요. 여러분과 공유할 많은 코드가 있습니다. 그러니 함께 시작해봅시다!\n\n![이미지](/TIL/assets/img/2024-07-07-AddingCustomDraggableItemsToDrag-And-DropNextJsProject_0.png)\n\n# 이전 프로그래밍 팁에서\n\n드래그 앤 드롭 라이브러리와 킷들이 별로 구리다 보니, 우리는 Next.js 프로젝트에서 드래그 앤 드롭 기능을 처음부터 만들어야 했습니다. 드래그 가능한 항목들을 생성하고, 줌 인/아웃 기능이 있는 그리드 드롭 존을 만들었으며, 드래그 가능한 항목과 듭 존을 화면에 표시했습니다.\n","ogImage":{"url":"/assets/img/2024-07-07-AddingCustomDraggableItemsToDrag-And-DropNextJsProject_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-AddingCustomDraggableItemsToDrag-And-DropNextJsProject_0.png","tag":["Tech"],"readingTime":1},{"title":"Markdown에서 Angular 컴포넌트 렌더링 하는 방법","description":"","date":"2024-07-07 12:58","slug":"2024-07-07-RenderAngularComponentsinMarkdown","content":"\n먼저, `markdown-render` 컴포넌트를 설정하여 .md 파일을 렌더링할 것입니다. 그리고 Angular 컴포넌트를 렌더링하는 방법을 살펴볼 것입니다.\n\n# Markdown 렌더러\n\n필요한 종속성을 설치하세요:\n\n```js\nnpm i highlight.js marked marked-highlight\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 단계 1: markdown-renderer/highlight-code-block.ts 파일 생성\n\n이 함수는 마크다운 파일에서 코드를 강조 표시하는 데 사용됩니다.\n\n```js\nimport highlightJs from \"highlight.js\";\n\nexport function highlightCodeBlock(code: string, language: string | undefined) {\n  if (language) {\n    return highlightJs.highlight(code, {\n      language,\n    }).value;\n  }\n  return code;\n}\n```\n\n# 단계 2: markdown-renderer/transform-markdown.ts 파일 생성\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 기능은 Markdown을 HTML로 변환하는 데 사용될 것입니다.\n\n```js\nimport { marked } from \"marked\";\nimport { markedHighlight } from \"marked-highlight\";\nimport { highlightCodeBlock } from \"./highlight-code-block\";\n\nmarked.use(markedHighlight({ highlight: highlightCodeBlock }));\nexport const markdownToHtml = (content: string) => {\n  return marked(content);\n};\n```\n\n# 단계 3: markdown-renderer/markdown.service.ts 만들기\n\n이 서비스는 구성 요소에서 .md 파일을 로컬 또는 외부 위치에서 읽어 HTML로 변환하는 데 사용될 것입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport { HttpClient } from '@angular/common/http';\nimport { Injectable, inject } from '@angular/core';\nimport { map } from 'rxjs';\nimport { markdownToHtml } from './transform-markdown';\n@Injectable({\n  providedIn: 'root',\n})\nexport class MarkdownService {\n  private httpClient = inject(HttpClient);\n  htmlContent(src: string) {\n    return this.httpClient.get(src, { responseType: 'text' }).pipe(\n      map((markdownContent) => {\n        return markdownToHtml(markdownContent);\n      })\n    );\n  }\n}\n```\n\n# 단계 4: markdown-renderer/markdown-renderer.ts 파일 생성하기\n\n마지막으로, 마크다운 파일을 렌더링하는 데 사용할 수 있는 컴포넌트를 만듭니다.\n\n```js\nimport { Component, ElementRef, effect, inject, input } from '@angular/core';\nimport { MarkdownService } from './markdown.service';\nimport { take } from 'rxjs';\nimport highlightJs from 'highlight.js';\n\n@Component({\n  selector: 'markdown-renderer',\n  template: '문서 로딩 중...',\n  standalone: true,\n})\nexport class MarkdownRendererComponent {\n  src = input.required<string>();\n  textContent = '';\n  private _elementRef = inject<ElementRef>(ElementRef);\n  private markdownService = inject(MarkdownService);\n  constructor() {\n    effect(() => {\n      const src = this.src();\n      this.setDataFromSrc(src);\n    });\n  }\n  setDataFromSrc(src: string) {\n    this.markdownService\n      .htmlContent(src)\n      .pipe(take(1))\n      .subscribe((htmlContent) => {\n        this.updateDocument(htmlContent as string);\n      });\n  }\n  updateDocument(rawHTML: string) {\n    this._elementRef.nativeElement.innerHTML = rawHTML;\n    this.textContent = this._elementRef.nativeElement.textContent;\n    highlightJs.highlightAll();\n  }\n}\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 단계 5: HTTP 제공\n\n```js\nbootstrapApplication(App, {\n  providers: [provideHttpClient(withFetch())],\n});\n```\n\n# 단계 6: 사용법\n\n이제 어디에서든 markdown을 렌더링하고 싶을 때, 간단히 `markdown-renderer`를 사용하면 됩니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport { Component } from \"@angular/core\";\nimport { MarkdownRendererComponent } from \"./markdown-renderer/markdown-renderer\";\n@Component({\n  selector: \"article\",\n  standalone: true,\n  template: `<markdown-renderer src=\"/assets/article.md\"></markdown-renderer>`,\n  imports: [MarkdownRendererComponent],\n})\nexport class ArticleComponent {}\n```\n\n# 마크다운에 Angular 구성 요소 추가하기\n\n필요한 종속성 설치:\n\n```js\nnpm i @angular/elements\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 단계 1: custom-elements.service.ts 파일 만들기\n\n이 서비스는 Angular 구성 요소를 사용자 지정 요소로 변환하는 데 사용됩니다. 이렇게 하면 .md 파일에서 Angular 구성 요소를 쉽게 사용할 수 있습니다.\n\n```typescript\nimport { inject, Injectable, Injector } from \"@angular/core\";\nimport { createCustomElement } from \"@angular/elements\";\nimport { SubscribeComponent } from \"./components/subscribe\";\nimport { CounterComponent } from \"./components/counter\";\n\n@Injectable({ providedIn: \"root\" })\nexport class CustomElementsService {\n  private _injector = inject(Injector);\n\n  setupCustomElements() {\n    const subscribeElement = createCustomElement(SubscribeComponent, {\n      injector: this._injector,\n    });\n    customElements.define(\"subscribe-component\", subscribeElement);\n\n    const counterElement = createCustomElement(CounterComponent, {\n      injector: this._injector,\n    });\n    customElements.define(\"counter-component\", counterElement);\n  }\n}\n```\n\n# 단계 2: APP_INITIALIZER를 통해 setupCustomElements 호출하기\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n커스텀 요소를 초기화 단계에서부터 사용하고 싶기 때문에 APP_INITIALIZER를 사용할 것입니다.\n\n```js\nbootstrapApplication(App, {\n  providers: [\n    provideHttpClient(withFetch()),\n    {\n      provide: APP_INITIALIZER,\n      useFactory: initializeCustomElements,\n      multi: true,\n      deps: [CustomElementsService],\n    },\n  ],\n});\n```\n\n# 단계 3: 사용 방법\n\n마지막으로 파일에서 커스텀 요소를 사용하면 Angular 컴포넌트가 렌더링됩니다. 아래와 같이 간단히 사용할 수 있습니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n<subscribe-component></subscribe-component>\n<counter-component></counter-component>\n```\n\n# 코드\n\n# 자유 콘텐츠 생성 지원\n\n코스와 기사는 무료로 제공되지만, 최고 수준의 교육 콘텐츠를 전달하는 제 야망을 지원해 주시면 감사히 받아들일 것입니다. 기여를 결정하는 것은 계속해서 코스를 개선하고 추가 자료를 작성하며 이러한 자료에 대한 접근성을 유지하는 데 도움이 됩니다. 기여하고 의미 있는 변화를 만들어주시는 것에 감사드립니다!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Render Angular Components in Markdown](/TIL/assets/img/2024-07-07-RenderAngularComponentsinMarkdown_0.png)\n","ogImage":{"url":"/assets/img/2024-07-07-RenderAngularComponentsinMarkdown_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-RenderAngularComponentsinMarkdown_0.png","tag":["Tech"],"readingTime":8},{"title":"Nodejs 프로젝트에서 TypeScript 설정하는 방법","description":"","date":"2024-07-07 12:58","slug":"2024-07-07-TypeScriptsetupforNodejsproject","content":"\n![이미지](/TIL/assets/img/2024-07-07-TypeScriptsetupforNodejsproject_0.png)\n\n지난 몇 년 동안 저는 Angular를 사용하여 프런트엔드 애플리케이션을 작성해 왔는데, 이 기간 동안 TypeScript가 일반 JavaScript보다 강력함을 느꼈습니다. Svelte 앱을 구현할 때 Node.js 기반의 TypeScript를 사용하여 작은 백엔드 서비스도 개발했습니다. 이 작은 기사에서는 코딩 프로세스를 간소화하는 데 도움이 된 구성에 대해 설명하고 싶습니다.\n\n## 의존성\n\n### 빌드\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n개발할 때 잘 알려진 Express.js 프레임워크를 사용했어요. TypeScript와 함께 사용하려면 해당 타입 정의를 명시적으로 추가해야 하며 Node 자체에 대한 것도요. 그러면 어떤 Node.js 환경으로도 이식할 수 있는 JavaScript 번들 하나만 얻고 싶었어요. 모든 것을 하나의 파일로 묶기 위해 특별한 구성 없이 esbuild를 사용했어요. 이것만으로 애플리케이션을 빌드하는 데 필요한 것이 거의 다 준비된 거죠.\n\n## 개발\n\n개발 과정에서 몇 가지 요구 사항도 있었어요. 그중 하나는 파일이 변경될 때 애플리케이션을 다시 실행해야 한다는 점이에요. 프론트엔드 애플리케이션에서의 개발 서버에 익숙해져 있어서 그랬나 봐요. 또 다른 기능은 별칭을 사용하는 것이라 개발자로서 좀 더 편리하다고 생각해요.\n\nTypeScript로 작성된 Node.js 애플리케이션을 실행하려면 ts-node 실행 엔진이 필요해요. 코드가 변경된 후 애플리케이션을 다시 빌드하기 위해 nodemon이 필요해요. 물론 TypeScript도 설치해야 하고 별칭을 사용하려면 tsconfig-paths도 추가해야 해요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## package.json\n\n제 package.json에서 추출한 내용입니다:\n\n```js\n{\n  \"scripts\": {\n    \"start\": \"nodemon\",\n    \"build\": \"esbuild main.ts --bundle --platform=node --outfile=dist/app.js --analyze\"\n  },\n  \"dependencies\": {\n    \"express\": \"^4.18.2\"\n  },\n  \"devDependencies\": {\n    \"@types/express\": \"^4.17.17\",\n    \"@types/node\": \"^18.15.11\",\n    \"esbuild\": \"^0.17.16\",\n    \"nodemon\": \"^2.0.22\",\n    \"ts-node\": \"^10.9.1\",\n    \"tsconfig-paths\": \"^4.2.0\",\n    \"typescript\": \"^5.0.4\"\n  }\n}\n```\n\n의미 없는 부분은 건너뛰고 관련 있는 부분만 남겼습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 별칭 및 nodemon 설정\n\n## 구성\n\nTypeScript 컴파일러를 사용할 때는 tsconfig.json 파일에서 특정 디렉토리에 대한 별칭을 정의할 수 있습니다. 아래는 추출된 코드입니다:\n\n```js\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \"./\",\n  \"paths\": {\n    \"@app/*\": [\"src/*\"]\n    }\n  }\n}\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다른 컴파일러 옵션에 대해서는 대부분 기본값을 사용했습니다. 엔진 `ts-node`는 이 구성 파일을 사용하지만 별칭을 사용하려면 별칭을 관리하는 모듈을 명시적으로 로드하도록 Node.js에 알려주어야 합니다. 이는 다음과 같이 `tsconfig.json` 안에서 수행할 수 있습니다:\n\n```js\n{\n \"ts-node\": {\n   \"require\": [\"tsconfig-paths/register\"]\n }\n}\n```\n\n또는 명령 인수를 사용하여 다음과 같이 처리할 수도 있습니다:\n\n```js\nnode -r tsconfig-paths/register -r ts-node/register main.ts\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nts-node과 함께 사용된 nodemon이 더 명확해보였기 때문에 두 번째 변형을 사용하는 것이 더 나은 것 같았습니다. nodemon 구성에 추가할 수 있기 때문입니다. nodemon.config.json에서 추출한 내용은 다음과 같습니다:\n\n```js\n{\n  \"ignore\": [\"**/*.test.ts\", \"**/*.spec.ts\", \".git\", \"node_modules\"],\n  \"watch\": [\"src\", \".\"],\n  \"exec\": \"node -r tsconfig-paths/register -r ts-node/register main.ts\",\n  \"ext\": \"ts\"\n}\n```\n\n여기에서 TypeScript 파일에 대해서만 감시자를 설정하고 감시할 디렉토리 및 무시할 파일에 대한 규칙을 설정했습니다.\n\n## 어플리케이션을 초기화합니다\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nExpress.js 위에 몇 가지 래퍼를 구현해 두었어요. 애플리케이션을 초기화하기 위해서는 main.ts에서 해당 클래스를 사용할 수 있습니다:\n\n```js\nimport { App } from \"@app/app\";\n\nconst app: App = new App();\napp.listen(8080);\n```\n\n# 요약\n\nNode.js 프로젝트에 적용할 수 있는 기본 설정을 설명했습니다. 이 설정에는 애플리케이션 자동 재시작, 단일 파일 빌드를 위한 간단한 구성, TypeScript 별칭 사용이 포함되어 있어요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 기사에서는 Node.js 구성에 전념한 것으로 응용 프로그램 클래스 구현 설명을 생략했습니다. 또한 서로 다른 디렉터리에 매핑된 여러 별칭을 사용하고 JavaScript로 작성된 모듈을 지원할 수 있습니다.\n\n저의 저장소에 있는 응용 프로그램 예시: https://github.com/aleksei-golubev/article-full-stack-development-svelte-express/tree/main/backend.\n\nSvelte 사용에 대한 참고 사항: https://medium.com/@aleksei_golubev/angular-developer-trying-svelte-e54898ca986b.\n","ogImage":{"url":"/assets/img/2024-07-07-TypeScriptsetupforNodejsproject_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-TypeScriptsetupforNodejsproject_0.png","tag":["Tech"],"readingTime":6},{"title":"UV vs PIP 2024년에 Python 패키지 관리를 혁신하는 방법","description":"","date":"2024-07-07 12:57","slug":"2024-07-07-UVvsPIPRevolutionizingPythonPackageManagement","content":"\n파이썬은 단순한 자동화 스크립트부터 복잡한 머신 러닝 응용프로그램까지 모든 것에 선호되는 언어로 계속해서 주도하고 있습니다. 이에 효율적인 패키지 관리는 중요합니다. 과거에는 파이썬의 패키지 설치 관리자인 pip이 이 관리 시스템의 최전선에 있었습니다. 그러나 Rust로 작성된 현대적인 패키지 설치 관리자인 UV의 등장은 속도, 효율성, 신뢰성을 향상시켜 혁명적인 변화를 약속합니다. 이 블로그는 UV와 pip 사이의 성능, 기능 및 파이썬 개발에 미치는 전반적인 영향에 초점을 맞추어 차이점을 탐구합니다.\n\n![UV와 PIP를 비교하는 이미지](/TIL/assets/img/2024-07-07-UVvsPIPRevolutionizingPythonPackageManagement_0.png)\n\n# PIP 개요\n\nPip는 많은 해 동안 파이썬 패키지 관리의 기반이었습니다. 사용자들이 파이썬 패키지 인덱스(PyPI)에서 가져온 소프트웨어 패키지를 설치하고 관리할 수 있도록 합니다. pip의 전형적인 워크플로는 다음과 같습니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 패키지 설치 : `pip install packagename`과 같은 명령어를 실행합니다.\n- 요구 사항 관리 : `requirements.txt` 파일을 사용하여 프로젝트 종속성을 관리합니다.\n- 가상 환경 처리 : 가상 환경을 활용하여 서로 다른 프로젝트의 종속성을 격리하고 관리합니다.\n\n파이프는 매우 유용하지만 대형 종속성을 처리할 때 속도에 어려움을 겪거나 종속성 충돌 해결 및 디스크 공간 사용을 최적화하는 효율적인 메커니즘이 부족한 경우가 많습니다.\n\n# UV 소개\n\nUV는 파이프의 대체품으로 설계된 고성능 대안으로 등장합니다. Rust로 제작된 UV는 속도와 효율성을 중시하여 개발되었으며, 다양한 시나리오에서 pip와 비교했을 때 10-100배의 성능 향상을 자랑합니다. 주요 기능은 다음과 같습니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 속도: UV는 패키지 설치에 필요한 시간을 크게 줄입니다.\n- 디스크 공간 효율성: 종속성 중복을 방지하기 위해 전역 캐시를 구현합니다.\n- 고급 종속성 관리: 고급 해결 전략 및 최고 수준의 오류 메시지를 제공합니다.\n- 크로스 플랫폼 지원: macOS, Linux 및 Windows에서 실행되며 다양한 고급 pip 기능을 지원합니다.\n\n# 주요 차이점\n\n## 성능\n\nUV가 pip보다 가장 큰 장점을 가지고 있는 부분은 속도입니다. 벤치마크 결과 UV가 종속성 설치를 훨씬 빠르게 처리할 수 있다는 것을 보여주며, 시간과 자원이 중요한 환경에서 작업하는 개발자들에게 필수적인 도구로 작용합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 디스크 사용량\n\nUV는 pip과 달리 패키지 종속성을 중복으로 저장하지 않고 디스크 공간을 효율적으로 관리하는 전역 캐싱 메커니즘을 사용합니다. 이 기능은 같은 기계에서 여러 프로젝트를 다루는 개발자에게 매우 유용합니다.\n\n## 오류 처리 및 메시지\n\nUV는 향상된 오류 진단 기능을 제공하여 pip에서 자주 나타나는 암호화된 오류 메시지와 비교하여 의존성 문제의 디버깅을 훨씬 쉽게 만듭니다. 이 기능 하나만으로도 개발자가 수십 시간을 소비하는 문제 해결을 막아줄 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 실용적인 비교\n\n간단한 판다스 설치 예제를 사용하여 두 가지를 비교해보겠습니다.\n\n![이미지 1](/TIL/assets/img/2024-07-07-UVvsPIPRevolutionizingPythonPackageManagement_1.png)\n\n![이미지 2](/TIL/assets/img/2024-07-07-UVvsPIPRevolutionizingPythonPackageManagement_2.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 사용자 CPU 시간:\n\n  - pip: 1.61 초\n  - uv: 0.28 초\n  - 분석: UV는 사용자 CPU 시간을 현저히 적게 사용합니다. 이는 UV가 Python 수준 작업의 계산 및 처리를 더 효율적으로 수행한다는 것을 시사합니다.\n\n- 시스템 CPU 시간:\n\n  - pip: 0.18 초\n  - uv: 0.42 초\n  - 분석: UV는 더 높은 시스템 시간을 갖고 있는데, 이는 UV가 파일 I/O 또는 네트워크 작업을 더 적극적이거나 다르게 처리하기 때문일 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n3. CPU 사용률:\n\n- pip: 67%\n- uv: 58%\n- 분석: 두 도구 모두 CPU의 상당 부분을 활용하지만 UV가 더 효율적으로 작동하여 더 적은 CPU를 사용하여 전반적으로 빠른 완료를 달성합니다.\n\n4. 총 경과 시간:\n\n- pip: 총 2.624초\n- uv: 총 1.216초\n- 분석: UV가 pip보다 걸리는 시간의 거의 절반에 설치를 완료합니다. 이는 UV의 성능 우위를 현실 세계에서 강조하며, 속도가 중요한 환경에서 유용한 선택으로 만듭니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 주요 포인트:\n\n- 속도: UV는 동일한 패키지를 설치할 때 전체 경과 시간에서 pip보다 약 두 배 더 빠릅니다. 이 속도 향상은 여러 패키지를 자주 설치하고 업데이트하는 환경에서 작업하는 개발자들에게 중요합니다.\n- 효율성: UV는 특히 해결 및 패키지 설치 속도에서 전반적인 효율성이 더 좋습니다.\n- 자원 사용: UV가 시스템 리소스를 다르게 활용하는 방식(시스템 시간을 더 사용, 사용자 시간을 덜 사용)은 일반적으로 시스템 수준 작업에서 더 효율적인 Rust 기반 실행 때문에 낮은 수준에서 더 많은 작업을 수행할 수 있을 것으로 보입니다.\n\n# UV로 시작하기: Python 패키지 더 빠르게 관리하는 방법\n\n```js\n# macOS 및 Linux에서.\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# Windows에서.\npowershell -c \"irm https://astral.sh/uv/install.ps1 | iex\"\n\n# 특정 버전으로.\ncurl -LsSf https://astral.sh/uv/0.2.21/install.sh | sh\npowershell -c \"irm https://astral.sh/uv/0.2.21/install.ps1 | iex\"\n\n# pip로.\npip install uv\n\n# pipx로.\npipx install uv\n\n# Homebrew로.\nbrew install uv\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Python 패키지 관리의 미래\n\nUV는 단순한 패키지 설치 도구가 아닙니다. 더 넓은 비전의 일환으로서 \"Python용 Cargo\"를 만들기 위한 종합 도구입니다. UV의 개발 로드맵에는 환경 통합, 패키지 게시 도구, 심지어 Python 프로젝트를 관리하는 네이티브 GUI와 같은 강력한 기능이 포함될 예정입니다.\n\n# 결론\n\nUV는 Python 패키지 관리에서 큰 발전을 의미하며, pip의 오랜 논란이었던 여러 문제점을 해결하고 현대적인 개발 워크플로에 부합하는 고급 기능을 도입합니다. UV를 채택함으로써, 개발자들은 더 빠른 설치, 더 나은 자원 관리, 그리고 의존성을 보다 직관적으로 다룰 수 있는 혜택을 누릴 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 마지막으로\n\nUV를 개발한 창조자들에게 축하드립니다. 여러분의 노고와 혁신이 파이썬 커뮤니티에 진정으로 감사하게 생각합니다 👏👏.\n\nUV를 다음 파이썬 프로젝트에 사용해보세요. UV가 파이썬 개발 환경을 어떻게 변화시킬 것이라고 생각하시나요?\n","ogImage":{"url":"/assets/img/2024-07-07-UVvsPIPRevolutionizingPythonPackageManagement_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-UVvsPIPRevolutionizingPythonPackageManagement_0.png","tag":["Tech"],"readingTime":7}],"page":"14","totalPageCount":19,"totalPageGroupCount":1,"lastPageGroup":19,"currentPageGroup":0},"__N_SSG":true}