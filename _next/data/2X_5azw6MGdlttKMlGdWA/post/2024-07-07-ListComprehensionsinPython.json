{"pageProps":{"post":{"title":"파이썬 리스트 내포 쉽게 사용하는 방법","description":"","date":"2024-07-07 21:31","slug":"2024-07-07-ListComprehensionsinPython","content":"\n![이미지](/TIL/assets/img/2024-07-07-ListComprehensionsinPython_0.png)\n\n파이썬은 간결함과 가독성으로 유명하며, 그 중 가장 강력한 기능 중 하나는 리스트 컴프리헨션입니다. 리스트 컴프리헨션은 리스트를 생성하는 간결한 방법을 제공합니다. 이 글에서는 리스트 컴프리헨션을 자세히 살펴보고, 작동 방식을 설명하며, 사용 예시를 통해 그 활용을 설명할 것입니다.\n\n## 리스트 컴프리헨션이란?\n\n리스트 컴프리헨션은 기본적으로 반복문이나 다른 순회 가능한 것들을 작성하거나 표현하는 또 다른 방법입니다. 기존에 있는 리스트나 범위와 같은 순회 가능한 항목 각각에 표현식을 적용하여 새 리스트를 만들고 선택적으로 항목들을 필터링할 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n리스트 내포는 보통 for 루프의 \"구문 설탕\"이라고 생각할 수 있습니다. 그러나 어떤 경우에는 일반적인 루프보다 훨씬 우수한 성능을 발휘할 수 있습니다. 성능 부분에서 자세히 다루겠습니다.\n\n기본 구문:\n\n```js\n[표현식 for 항목 in 반복 가능 객체 if 조건]\n```\n\n구성 요소:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 표현: 각 항목에 적용되는 작업 또는 필요한 처리\n- 항목: 반복 가능한 요소 중 각 요소를 나타내는 변수. 예: i는 for i in range(xyz)에서 항목을 나타냅니다.\n- 반복 가능한 요소: 반복되는 항목의 모음 (예: 목록 또는 범위).\n- 조건(선택 사항): 특정 항목만 처리하도록 허용하는 필터.\n\n# 기본 예제\n\n## 1. 다른 목록에서 목록 생성\n\n전통적인 For 루프:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nnumbers = [1, 2, 3, 4, 5]\nsquared_numbers = []\nfor n in numbers:\n    # 숫자를 제곱합니다\n    squared_numbers.append(n ** 2)\nprint(squared_numbers)\n# 출력: [1, 4, 9, 16, 25]\n```\n\n리스트 컴프리헨션:\n\n```js\nnumbers = [1, 2, 3, 4, 5]\nsquared_numbers = [n ** 2 for n in numbers]\nprint(squared_numbers)\n# 출력: [1, 4, 9, 16, 25]\n```\n\n이 예제에서 두 가지 방법 모두 동일한 결과를 얻지만, 리스트 컴프리헨션은 보다 간결합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 2. 아이템 필터링\n\n전통적인 for 루프를 사용한 필터링:\n\n```js\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\neven_numbers = []\nfor n in numbers:\n    if n % 2 == 0:\n        even_numbers.append(n)\nprint(even_numbers)\n# 출력: [2, 4, 6, 8, 10]\n```\n\n필터링을 사용한 List Comprehension:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\neven_numbers = [n for n in numbers if n % 2 == 0]\nprint(even_numbers)\n# Output: [2, 4, 6, 8, 10]\n```\n\n여기서 리스트 컴프리헨션은 짝수만 필터링하는 조건을 포함하고 있습니다.\n\n# 고급 예제\n\n## 1. 중첩된 반복문\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n리스트 컴프리헨션이 중첩된 루프를 포함할 수 있습니다. 중첩된 for 루프처럼 동작합니다.\n\n전통적인 중첩된 For 룹:\n\n```js\nmatrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\nflattened = []\nfor row in matrix:\n    for item in row:\n        flattened.append(item)\nprint(flattened)\n# Output: [1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n\n중첩된 루프를 사용한 리스트 컴프리헨션:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nmatrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\nflattened = [item for row in matrix for item in row]\nprint(flattened)\n# Output: [1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n\n이 리스트 컴프리헨션은 2차원 리스트(리스트의 리스트)를 하나의 리스트로 평탄화합니다.\n\n## 2. List Comprehensions에서 함수 사용하기\n\n리스트 컴프리헨션의 식 부분에서 함수를 호출할 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예시:\n\n```js\ndef square(x):\n    return x ** 2\nnumbers = [1, 2, 3, 4, 5]\nsquared_numbers = [square(n) for n in numbers]\nprint(squared_numbers)\n# 출력: [1, 4, 9, 16, 25]\n```\n\n이 예시는 리스트 컴프리헨션 내에서 사용자 정의 함수를 호출하는 방법을 보여줍니다.\n\n# 성능 비교: 리스트 컴프리헨션 대 반복문\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n컴프리헨션은 동등한 루프보다 최적화된 구현으로 인해 종종 Python에서 더 빠릅니다.\n\n성능 비교 예시:\n\n```python\nimport time\n# 숫자 리스트\nnumbers = list(range(1000000))\n\n# for 루프 사용\nstart_time = time.time()\nsquared_numbers_loop = []\nfor n in numbers:\n    squared_numbers_loop.append(n ** 2)\nend_time = time.time()\nprint(\"For 루프 시간:\", end_time - start_time)\n\n# 리스트 컴프리헨션 사용\nstart_time = time.time()\nsquared_numbers_comprehension = [n ** 2 for n in numbers]\nend_time = time.time()\nprint(\"리스트 컴프리헨션 시간:\", end_time - start_time)\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nFor 루프 시간: 0.2 초\n리스트 내장 시간: 0.1 초\n```\n\n이 예에서 리스트 내장은 for 루프보다 훨씬 빠르며 효율성을 입증합니다.\n\n# 리스트 내포의 내부 작동 방식\n\n우리가 알다시피, Python은 기본 C 위에 구축된 해석형 언어입니다. 리스트 내장을 사용할 때 Python은 이를 반복 및 리스트 구성을 효율적으로 처리하는 일련의 바이트 코드 명령으로 변환합니다. append를 반복적으로 호출하는 대신, 리스트 내포는 리스트에 요소를 더하는 작업을 더욱 효율적으로 처리하는 특수화된 바이트 코드를 사용합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 내부 메커니즘\n\n여기서 뜰 속에서 무슨 일이 벌어지는지를 단계별로 설명해 드리겠습니다:\n\n- 바이트 코드 컴파일: 리스트 내포는 바이트 코드로 컴파일되며, 이는 리스트를 생성하고 채우는 특수한 일련의 명령어를 포함합니다.\n- 리스트 생성: Python은 빈 리스트를 생성합니다.\n- 요소 추가: iterable이 횡단될 때 최적화된 C 함수를 직접 사용하여 append를 호출하는 대신 리스트에 요소를 추가합니다.\n- 반복 제어: 루프 제어(다음 항목 가져오고 루프를 계속해야 하는지 확인하는 것)가 이 특수화된 바이트 코드 내에서 효율적으로 처리됩니다.\n\n# 예시 해체\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n차이를 보려면 dis 모듈을 사용하여 전통적인 for 루프와 리스트 내포의 바이트코드를 분해할 수 있습니다.\n\nFor Loop Example:\n\n```python\nimport dis\ndef for_loop_example():\n    numbers = [1, 2, 3, 4, 5]\n    squared_numbers = []\n    for n in numbers:\n        squared_numbers.append(n ** 2)\ndis.dis(for_loop_example)\n```\n\nFor Loop Bytecode Output:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n  2           0 LOAD_CONST               1 (1)\n              2 LOAD_CONST               2 (2)\n              4 LOAD_CONST               3 (3)\n              6 LOAD_CONST               4 (4)\n              8 LOAD_CONST               5 (5)\n             10 BUILD_LIST               5\n             12 STORE_FAST               0 (numbers)\n  3          14 BUILD_LIST               0\n             16 STORE_FAST               1 (squared_numbers)\n  4          18 LOAD_FAST                0 (numbers)\n             20 GET_ITER\n        >>   22 FOR_ITER                12 (to 36)\n             24 STORE_FAST               2 (n)\n  5          26 LOAD_FAST                1 (squared_numbers)\n             28 LOAD_METHOD              0 (append)\n             30 LOAD_FAST                2 (n)\n             32 LOAD_CONST               6 (2)\n             34 BINARY_POWER\n             36 CALL_METHOD              1\n             38 POP_TOP\n             40 JUMP_ABSOLUTE           22\n        >>   42 LOAD_CONST               0 (None)\n             44 RETURN_VALUE\n```\n\n리스트 컴프리헨션 예제:\n\n```js\nimport dis\ndef list_comprehension_example():\n    numbers = [1, 2, 3, 4, 5]\n    squared_numbers = [n ** 2 for n in numbers]\ndis.dis(list_comprehension_example)\n```\n\n리스트 컴프리헨션 바이트코드 출력:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n특수화된 C 함수\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n효율성은 파이썬 인터프리터 내에서 전문화된 C 함수를 사용함으로써 얻어집니다. 이러한 함수들은 목록 구성과 같은 일반적인 작업을 처리하는 데 등가하는 파이썬 코드보다 훨씬 빠르게 설계되었습니다. 리스트 컴프리헨션을 작성할 때, 파이썬의 바이트코드 컴파일러는 이러한 함수들을 사용하여 메모리 내의 리스트를 직접 조작하여, 메서드 호출 및 루프 제어에 따른 오버헤드를 피할 수 있습니다.\n\n# 리스트 컴프리헨션이 왜 더 빠를까요??\n\n- 오버헤드 감소:\n\n- for 루프: 각 for 루프 반복은 append 메서드와 루프 제어 작업에 따른 반복 호출로 인한 오버헤드가 발생합니다.\n- 리스트 컴프리헨션: 반복적인 오버헤드를 피하고 연속된 단일 작업으로 리스트를 구성합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2. 최적화된 바이트 코드:\n\nPython 코드가 실행될 때, 먼저 바이트 코드로 컴파일됩니다. 이는 소스 코드의 더 낮은 수준이며 플랫폼에 독립적인 표현입니다. Python 인터프리터(C로 작성됨)가 이 바이트 코드를 실행합니다.\n\n- For 루프: for 루프의 각 반복은 다음 항목을 가져오는 작업, 루프 조건을 확인하는 작업, append 메서드를 반복적으로 호출하는 등 여러 바이트 코드 명령으로 이루어집니다.\n- List Comprehensions: 전체 리스트 컴프리헨션은 더 효율적인 일련의 바이트 코드 명령으로 컴파일됩니다. 이러한 명령들은 오버헤드를 최소화하기 위해 최적화되어 있습니다.\n\n3. 인플레이스 생성:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 리스트 컴프리헨션은 리스트를 직접 메모리에 생성하는 반면에 일반 루프는 메소드 호출과 변수 할당과 같은 추가 단계가 필요할 수 있습니다.\n\n## 요약\n\n파이썬의 리스트 컴프리헨션은 리스트를 생성하는 간결하고 가독성이 높으며 효율적인 방법을 제공합니다. 이는 데이터 변환 및 필터링을 포함한 많은 사용 사례에서 전통적인 for 루프를 대체할 수 있습니다. 리스트 컴프리헨션을 효과적으로 이해하고 사용하면 더 우아하고 성능이 좋은 코드를 작성할 수 있습니다.\n\n## 기억해야 할 중요한 사항\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 문법: [조건식 for 요소 in 반복가능객체 if 조건문]\n- 효율성: 리스트 컴프리헨션은 동등한 for 루프보다 종종 더 빠릅니다.\n- 가독성: 코드를 더 간결하고 읽기 쉽게 만듭니다.\n- 사용 예: 간단한 변형 및 필터링에 이상적이지만 복잡한 로직의 경우 가독성을 위해 전통적인 루프가 더 적합할 수 있습니다.\n\n리스트 컴프리헨션을 숙달함으로써 더 깔끔하고 빠르며 파이썬다운 코드를 작성할 수 있습니다.\n\n즐거운 코딩 하세요!\n","ogImage":{"url":"/assets/img/2024-07-07-ListComprehensionsinPython_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-ListComprehensionsinPython_0.png","tag":["Tech"],"readingTime":12},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/TIL/assets/img/2024-07-07-ListComprehensionsinPython_0.png\" alt=\"이미지\"></p>\n<p>파이썬은 간결함과 가독성으로 유명하며, 그 중 가장 강력한 기능 중 하나는 리스트 컴프리헨션입니다. 리스트 컴프리헨션은 리스트를 생성하는 간결한 방법을 제공합니다. 이 글에서는 리스트 컴프리헨션을 자세히 살펴보고, 작동 방식을 설명하며, 사용 예시를 통해 그 활용을 설명할 것입니다.</p>\n<h2>리스트 컴프리헨션이란?</h2>\n<p>리스트 컴프리헨션은 기본적으로 반복문이나 다른 순회 가능한 것들을 작성하거나 표현하는 또 다른 방법입니다. 기존에 있는 리스트나 범위와 같은 순회 가능한 항목 각각에 표현식을 적용하여 새 리스트를 만들고 선택적으로 항목들을 필터링할 수 있습니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>리스트 내포는 보통 for 루프의 \"구문 설탕\"이라고 생각할 수 있습니다. 그러나 어떤 경우에는 일반적인 루프보다 훨씬 우수한 성능을 발휘할 수 있습니다. 성능 부분에서 자세히 다루겠습니다.</p>\n<p>기본 구문:</p>\n<pre><code class=\"hljs language-js\">[표현식 <span class=\"hljs-keyword\">for</span> 항목 <span class=\"hljs-keyword\">in</span> 반복 가능 객체 <span class=\"hljs-keyword\">if</span> 조건]\n</code></pre>\n<p>구성 요소:</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>표현: 각 항목에 적용되는 작업 또는 필요한 처리</li>\n<li>항목: 반복 가능한 요소 중 각 요소를 나타내는 변수. 예: i는 for i in range(xyz)에서 항목을 나타냅니다.</li>\n<li>반복 가능한 요소: 반복되는 항목의 모음 (예: 목록 또는 범위).</li>\n<li>조건(선택 사항): 특정 항목만 처리하도록 허용하는 필터.</li>\n</ul>\n<h1>기본 예제</h1>\n<h2>1. 다른 목록에서 목록 생성</h2>\n<p>전통적인 For 루프:</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\">numbers = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>]\nsquared_numbers = []\n<span class=\"hljs-keyword\">for</span> n <span class=\"hljs-keyword\">in</span> <span class=\"hljs-attr\">numbers</span>:\n    # 숫자를 제곱합니다\n    squared_numbers.<span class=\"hljs-title function_\">append</span>(n ** <span class=\"hljs-number\">2</span>)\n<span class=\"hljs-title function_\">print</span>(squared_numbers)\n# 출력: [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">16</span>, <span class=\"hljs-number\">25</span>]\n</code></pre>\n<p>리스트 컴프리헨션:</p>\n<pre><code class=\"hljs language-js\">numbers = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>]\nsquared_numbers = [n ** <span class=\"hljs-number\">2</span> <span class=\"hljs-keyword\">for</span> n <span class=\"hljs-keyword\">in</span> numbers]\n<span class=\"hljs-title function_\">print</span>(squared_numbers)\n# 출력: [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">16</span>, <span class=\"hljs-number\">25</span>]\n</code></pre>\n<p>이 예제에서 두 가지 방법 모두 동일한 결과를 얻지만, 리스트 컴프리헨션은 보다 간결합니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h2>2. 아이템 필터링</h2>\n<p>전통적인 for 루프를 사용한 필터링:</p>\n<pre><code class=\"hljs language-js\">numbers = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">10</span>]\neven_numbers = []\n<span class=\"hljs-keyword\">for</span> n <span class=\"hljs-keyword\">in</span> <span class=\"hljs-attr\">numbers</span>:\n    <span class=\"hljs-keyword\">if</span> n % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>:\n        even_numbers.<span class=\"hljs-title function_\">append</span>(n)\n<span class=\"hljs-title function_\">print</span>(even_numbers)\n# 출력: [<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">10</span>]\n</code></pre>\n<p>필터링을 사용한 List Comprehension:</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\">numbers = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">10</span>]\neven_numbers = [n <span class=\"hljs-keyword\">for</span> n <span class=\"hljs-keyword\">in</span> numbers <span class=\"hljs-keyword\">if</span> n % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>]\n<span class=\"hljs-title function_\">print</span>(even_numbers)\n# <span class=\"hljs-title class_\">Output</span>: [<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">10</span>]\n</code></pre>\n<p>여기서 리스트 컴프리헨션은 짝수만 필터링하는 조건을 포함하고 있습니다.</p>\n<h1>고급 예제</h1>\n<h2>1. 중첩된 반복문</h2>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>리스트 컴프리헨션이 중첩된 루프를 포함할 수 있습니다. 중첩된 for 루프처럼 동작합니다.</p>\n<p>전통적인 중첩된 For 룹:</p>\n<pre><code class=\"hljs language-js\">matrix = [\n    [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>],\n    [<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>],\n    [<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">9</span>]\n]\nflattened = []\n<span class=\"hljs-keyword\">for</span> row <span class=\"hljs-keyword\">in</span> <span class=\"hljs-attr\">matrix</span>:\n    <span class=\"hljs-keyword\">for</span> item <span class=\"hljs-keyword\">in</span> <span class=\"hljs-attr\">row</span>:\n        flattened.<span class=\"hljs-title function_\">append</span>(item)\n<span class=\"hljs-title function_\">print</span>(flattened)\n# <span class=\"hljs-title class_\">Output</span>: [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">9</span>]\n</code></pre>\n<p>중첩된 루프를 사용한 리스트 컴프리헨션:</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\">matrix = [\n    [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>],\n    [<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>],\n    [<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">9</span>]\n]\nflattened = [item <span class=\"hljs-keyword\">for</span> row <span class=\"hljs-keyword\">in</span> matrix <span class=\"hljs-keyword\">for</span> item <span class=\"hljs-keyword\">in</span> row]\n<span class=\"hljs-title function_\">print</span>(flattened)\n# <span class=\"hljs-title class_\">Output</span>: [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">9</span>]\n</code></pre>\n<p>이 리스트 컴프리헨션은 2차원 리스트(리스트의 리스트)를 하나의 리스트로 평탄화합니다.</p>\n<h2>2. List Comprehensions에서 함수 사용하기</h2>\n<p>리스트 컴프리헨션의 식 부분에서 함수를 호출할 수 있습니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>예시:</p>\n<pre><code class=\"hljs language-js\">def <span class=\"hljs-title function_\">square</span>(x):\n    <span class=\"hljs-keyword\">return</span> x ** <span class=\"hljs-number\">2</span>\nnumbers = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>]\nsquared_numbers = [<span class=\"hljs-title function_\">square</span>(n) <span class=\"hljs-keyword\">for</span> n <span class=\"hljs-keyword\">in</span> numbers]\n<span class=\"hljs-title function_\">print</span>(squared_numbers)\n# 출력: [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">16</span>, <span class=\"hljs-number\">25</span>]\n</code></pre>\n<p>이 예시는 리스트 컴프리헨션 내에서 사용자 정의 함수를 호출하는 방법을 보여줍니다.</p>\n<h1>성능 비교: 리스트 컴프리헨션 대 반복문</h1>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>컴프리헨션은 동등한 루프보다 최적화된 구현으로 인해 종종 Python에서 더 빠릅니다.</p>\n<p>성능 비교 예시:</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">import</span> time\n<span class=\"hljs-comment\"># 숫자 리스트</span>\nnumbers = <span class=\"hljs-built_in\">list</span>(<span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">1000000</span>))\n\n<span class=\"hljs-comment\"># for 루프 사용</span>\nstart_time = time.time()\nsquared_numbers_loop = []\n<span class=\"hljs-keyword\">for</span> n <span class=\"hljs-keyword\">in</span> numbers:\n    squared_numbers_loop.append(n ** <span class=\"hljs-number\">2</span>)\nend_time = time.time()\n<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"For 루프 시간:\"</span>, end_time - start_time)\n\n<span class=\"hljs-comment\"># 리스트 컴프리헨션 사용</span>\nstart_time = time.time()\nsquared_numbers_comprehension = [n ** <span class=\"hljs-number\">2</span> <span class=\"hljs-keyword\">for</span> n <span class=\"hljs-keyword\">in</span> numbers]\nend_time = time.time()\n<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"리스트 컴프리헨션 시간:\"</span>, end_time - start_time)\n</code></pre>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">For</span> 루프 시간: <span class=\"hljs-number\">0.2</span> 초\n리스트 내장 시간: <span class=\"hljs-number\">0.1</span> 초\n</code></pre>\n<p>이 예에서 리스트 내장은 for 루프보다 훨씬 빠르며 효율성을 입증합니다.</p>\n<h1>리스트 내포의 내부 작동 방식</h1>\n<p>우리가 알다시피, Python은 기본 C 위에 구축된 해석형 언어입니다. 리스트 내장을 사용할 때 Python은 이를 반복 및 리스트 구성을 효율적으로 처리하는 일련의 바이트 코드 명령으로 변환합니다. append를 반복적으로 호출하는 대신, 리스트 내포는 리스트에 요소를 더하는 작업을 더욱 효율적으로 처리하는 특수화된 바이트 코드를 사용합니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h1>내부 메커니즘</h1>\n<p>여기서 뜰 속에서 무슨 일이 벌어지는지를 단계별로 설명해 드리겠습니다:</p>\n<ul>\n<li>바이트 코드 컴파일: 리스트 내포는 바이트 코드로 컴파일되며, 이는 리스트를 생성하고 채우는 특수한 일련의 명령어를 포함합니다.</li>\n<li>리스트 생성: Python은 빈 리스트를 생성합니다.</li>\n<li>요소 추가: iterable이 횡단될 때 최적화된 C 함수를 직접 사용하여 append를 호출하는 대신 리스트에 요소를 추가합니다.</li>\n<li>반복 제어: 루프 제어(다음 항목 가져오고 루프를 계속해야 하는지 확인하는 것)가 이 특수화된 바이트 코드 내에서 효율적으로 처리됩니다.</li>\n</ul>\n<h1>예시 해체</h1>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>차이를 보려면 dis 모듈을 사용하여 전통적인 for 루프와 리스트 내포의 바이트코드를 분해할 수 있습니다.</p>\n<p>For Loop Example:</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">import</span> dis\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">for_loop_example</span>():\n    numbers = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>]\n    squared_numbers = []\n    <span class=\"hljs-keyword\">for</span> n <span class=\"hljs-keyword\">in</span> numbers:\n        squared_numbers.append(n ** <span class=\"hljs-number\">2</span>)\ndis.dis(for_loop_example)\n</code></pre>\n<p>For Loop Bytecode Output:</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\">  <span class=\"hljs-number\">2</span>           <span class=\"hljs-number\">0</span> <span class=\"hljs-variable constant_\">LOAD_CONST</span>               <span class=\"hljs-number\">1</span> (<span class=\"hljs-number\">1</span>)\n              <span class=\"hljs-number\">2</span> <span class=\"hljs-variable constant_\">LOAD_CONST</span>               <span class=\"hljs-number\">2</span> (<span class=\"hljs-number\">2</span>)\n              <span class=\"hljs-number\">4</span> <span class=\"hljs-variable constant_\">LOAD_CONST</span>               <span class=\"hljs-number\">3</span> (<span class=\"hljs-number\">3</span>)\n              <span class=\"hljs-number\">6</span> <span class=\"hljs-variable constant_\">LOAD_CONST</span>               <span class=\"hljs-number\">4</span> (<span class=\"hljs-number\">4</span>)\n              <span class=\"hljs-number\">8</span> <span class=\"hljs-variable constant_\">LOAD_CONST</span>               <span class=\"hljs-number\">5</span> (<span class=\"hljs-number\">5</span>)\n             <span class=\"hljs-number\">10</span> <span class=\"hljs-variable constant_\">BUILD_LIST</span>               <span class=\"hljs-number\">5</span>\n             <span class=\"hljs-number\">12</span> <span class=\"hljs-variable constant_\">STORE_FAST</span>               <span class=\"hljs-number\">0</span> (numbers)\n  <span class=\"hljs-number\">3</span>          <span class=\"hljs-number\">14</span> <span class=\"hljs-variable constant_\">BUILD_LIST</span>               <span class=\"hljs-number\">0</span>\n             <span class=\"hljs-number\">16</span> <span class=\"hljs-variable constant_\">STORE_FAST</span>               <span class=\"hljs-number\">1</span> (squared_numbers)\n  <span class=\"hljs-number\">4</span>          <span class=\"hljs-number\">18</span> <span class=\"hljs-variable constant_\">LOAD_FAST</span>                <span class=\"hljs-number\">0</span> (numbers)\n             <span class=\"hljs-number\">20</span> <span class=\"hljs-variable constant_\">GET_ITER</span>\n        >>   <span class=\"hljs-number\">22</span> <span class=\"hljs-variable constant_\">FOR_ITER</span>                <span class=\"hljs-number\">12</span> (to <span class=\"hljs-number\">36</span>)\n             <span class=\"hljs-number\">24</span> <span class=\"hljs-variable constant_\">STORE_FAST</span>               <span class=\"hljs-number\">2</span> (n)\n  <span class=\"hljs-number\">5</span>          <span class=\"hljs-number\">26</span> <span class=\"hljs-variable constant_\">LOAD_FAST</span>                <span class=\"hljs-number\">1</span> (squared_numbers)\n             <span class=\"hljs-number\">28</span> <span class=\"hljs-variable constant_\">LOAD_METHOD</span>              <span class=\"hljs-number\">0</span> (append)\n             <span class=\"hljs-number\">30</span> <span class=\"hljs-variable constant_\">LOAD_FAST</span>                <span class=\"hljs-number\">2</span> (n)\n             <span class=\"hljs-number\">32</span> <span class=\"hljs-variable constant_\">LOAD_CONST</span>               <span class=\"hljs-number\">6</span> (<span class=\"hljs-number\">2</span>)\n             <span class=\"hljs-number\">34</span> <span class=\"hljs-variable constant_\">BINARY_POWER</span>\n             <span class=\"hljs-number\">36</span> <span class=\"hljs-variable constant_\">CALL_METHOD</span>              <span class=\"hljs-number\">1</span>\n             <span class=\"hljs-number\">38</span> <span class=\"hljs-variable constant_\">POP_TOP</span>\n             <span class=\"hljs-number\">40</span> <span class=\"hljs-variable constant_\">JUMP_ABSOLUTE</span>           <span class=\"hljs-number\">22</span>\n        >>   <span class=\"hljs-number\">42</span> <span class=\"hljs-variable constant_\">LOAD_CONST</span>               <span class=\"hljs-number\">0</span> (<span class=\"hljs-title class_\">None</span>)\n             <span class=\"hljs-number\">44</span> <span class=\"hljs-variable constant_\">RETURN_VALUE</span>\n</code></pre>\n<p>리스트 컴프리헨션 예제:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> dis\ndef <span class=\"hljs-title function_\">list_comprehension_example</span>():\n    numbers = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>]\n    squared_numbers = [n ** <span class=\"hljs-number\">2</span> <span class=\"hljs-keyword\">for</span> n <span class=\"hljs-keyword\">in</span> numbers]\ndis.<span class=\"hljs-title function_\">dis</span>(list_comprehension_example)\n</code></pre>\n<p>리스트 컴프리헨션 바이트코드 출력:</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\">특수화된 C 함수\n</code></pre>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>효율성은 파이썬 인터프리터 내에서 전문화된 C 함수를 사용함으로써 얻어집니다. 이러한 함수들은 목록 구성과 같은 일반적인 작업을 처리하는 데 등가하는 파이썬 코드보다 훨씬 빠르게 설계되었습니다. 리스트 컴프리헨션을 작성할 때, 파이썬의 바이트코드 컴파일러는 이러한 함수들을 사용하여 메모리 내의 리스트를 직접 조작하여, 메서드 호출 및 루프 제어에 따른 오버헤드를 피할 수 있습니다.</p>\n<h1>리스트 컴프리헨션이 왜 더 빠를까요??</h1>\n<ul>\n<li>\n<p>오버헤드 감소:</p>\n</li>\n<li>\n<p>for 루프: 각 for 루프 반복은 append 메서드와 루프 제어 작업에 따른 반복 호출로 인한 오버헤드가 발생합니다.</p>\n</li>\n<li>\n<p>리스트 컴프리헨션: 반복적인 오버헤드를 피하고 연속된 단일 작업으로 리스트를 구성합니다.</p>\n</li>\n</ul>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ol start=\"2\">\n<li>최적화된 바이트 코드:</li>\n</ol>\n<p>Python 코드가 실행될 때, 먼저 바이트 코드로 컴파일됩니다. 이는 소스 코드의 더 낮은 수준이며 플랫폼에 독립적인 표현입니다. Python 인터프리터(C로 작성됨)가 이 바이트 코드를 실행합니다.</p>\n<ul>\n<li>For 루프: for 루프의 각 반복은 다음 항목을 가져오는 작업, 루프 조건을 확인하는 작업, append 메서드를 반복적으로 호출하는 등 여러 바이트 코드 명령으로 이루어집니다.</li>\n<li>List Comprehensions: 전체 리스트 컴프리헨션은 더 효율적인 일련의 바이트 코드 명령으로 컴파일됩니다. 이러한 명령들은 오버헤드를 최소화하기 위해 최적화되어 있습니다.</li>\n</ul>\n<ol start=\"3\">\n<li>인플레이스 생성:</li>\n</ol>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>리스트 컴프리헨션은 리스트를 직접 메모리에 생성하는 반면에 일반 루프는 메소드 호출과 변수 할당과 같은 추가 단계가 필요할 수 있습니다.</li>\n</ul>\n<h2>요약</h2>\n<p>파이썬의 리스트 컴프리헨션은 리스트를 생성하는 간결하고 가독성이 높으며 효율적인 방법을 제공합니다. 이는 데이터 변환 및 필터링을 포함한 많은 사용 사례에서 전통적인 for 루프를 대체할 수 있습니다. 리스트 컴프리헨션을 효과적으로 이해하고 사용하면 더 우아하고 성능이 좋은 코드를 작성할 수 있습니다.</p>\n<h2>기억해야 할 중요한 사항</h2>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>문법: [조건식 for 요소 in 반복가능객체 if 조건문]</li>\n<li>효율성: 리스트 컴프리헨션은 동등한 for 루프보다 종종 더 빠릅니다.</li>\n<li>가독성: 코드를 더 간결하고 읽기 쉽게 만듭니다.</li>\n<li>사용 예: 간단한 변형 및 필터링에 이상적이지만 복잡한 로직의 경우 가독성을 위해 전통적인 루프가 더 적합할 수 있습니다.</li>\n</ul>\n<p>리스트 컴프리헨션을 숙달함으로써 더 깔끔하고 빠르며 파이썬다운 코드를 작성할 수 있습니다.</p>\n<p>즐거운 코딩 하세요!</p>\n</body>\n</html>\n"},"__N_SSG":true}