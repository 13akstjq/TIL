{"pageProps":{"post":{"title":"FastAPI에서 Pydantic 직렬화 단계별 가이드","description":"","date":"2024-07-07 12:56","slug":"2024-07-07-PydanticserializationstepbystepsforFastAPI","content":"\n\n\n![이미지](/assets/img/2024-07-07-PydanticserializationstepbystepsforFastAPI_0.png)\n\nFastAPI 프레임워크를 사용하여 API를 구축하려면 pydantic에 대해 알아야 합니다. 'post' 요청은 본문 매개변수만 허용하기 때문입니다. 본문 매개변수를 읽으려면 pydantic 모델을 구현해야 합니다.\n\n그러나 문제는 이 pydantic 모델의 데이터를 사용할 때, 원본 pydantic보다 쉬운 데이터 유형(파이썬 사전 또는 JSON일 수 있음)으로 변환해야 한다는 것입니다. 이 데이터 유형으로 작업하는 것이 원본 pydantic보다 쉽기 때문입니다.\n\n이 프로세스를 직렬화라고 합니다. 이름에서 알 수 있듯, 이 문제에 대해 심각하게 생각할 필요가 없습니다. 이 주제에 대해 알아야 할 모든 것을 단순화할 것입니다.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nFastAPI에서 데이터를 반환할 때 pydantic 모델과 정확히 동일한 데이터를 반환하고 싶다면 직렬화 방법을 사용할 필요가 없습니다. FastAPI가 이를 자동으로 처리하기 때문입니다. 그러나 pydantic 데이터 출력을 사용자 정의하려면 (적어도 새 필드를 추가하거나 기존 필드를 제거하는) pydantic에서 어떤 종류의 직렬화 방법을 사용하는 것이 좋습니다. model_dump(), dict() 및 model_dump_json()과 같은 방법이 있습니다.\n\n먼저 어떻게 무조건적으로 pydantic 모델과 동일한 데이터를 반환하는지 알아보겠습니다.\n\n```python\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\nclass University(BaseModel):\n    name : str\n    place : str\n@app.post('/create')\nasync def addUniversity(university : University):\n    # 업무 로직을 수행한 후\n    # pydantic 모델 그대로 반환합니다\n    return university\n```\n\n그리고 위의 pydantic 모델을 수정하여 (다른 필드를 추가하는 간단한 예) 직렬화 방법을 사용하지 않고 반환하는 방법을 살펴보겠습니다. 이것은 어려운 주제가 아닙니다. 그저 새로운 사전을 만들고 출력으로 반환하는 것뿐입니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\nclass University(BaseModel):\n    name : str\n    place : str\n@app.post('/create')\nasync def addUniversity(university : University):\n    newUniversity = {\n        'name' : university.name,\n        'place' : university.place,\n        'contactNum' : +1234678\n    }\n    return newUniversity\n```\n\n만약 직렬화(serialization)에 대해 익숙하지 않다면, 위와 같은 방법으로 해야 한다고 생각할 수 있습니다. 하지만 이제 직렬화 메서드를 적용하는 방법을 살펴본 후, 우리의 작업을 더 쉽게 할 수 있는 방법을 알아보겠습니다.\n\n```python\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\nclass University(BaseModel):\n    name : str\n    place : str\n@app.post('/create')\nasync def addUniversity(university : University):\n    # 새로운 대학 변수를 정의하고 직렬화된 데이터를 할당합니다.\n    newUniversity = university.model_dump()\n    # 새 데이터 추가\n    newUniversity['contactNum'] = 12345678\n    # 값을 반환합니다.\n    return newUniversity\n```\n\n따라서 직렬화를 사용할 수 있는 유용한 방법 중 하나를 보여드렸습니다. 이 주제에 대해 더 자세히 알아보고 싶다면, 직렬화에 대해 알아야 할 모든 것을 간단하게 설명해드리겠습니다.\npydantic에는 세 가지 주요 기본 직렬화 메서드가 있습니다.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## model_dump( )\n\n이 함수는 Pydantic 모델을 사전으로 변환하는 데 사용됩니다. 사전으로 변환한 후에는 아래와 같이 출력을 사용자 지정하는 여러 옵션이 있습니다.\n\n```js\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel, Field\n\napp = FastAPI()\nclass University(BaseModel):\n    name : str\n    place : str = Field(alias='location place')\n    rank : int\n    specialize : int = Field(default=1)\n@app.post('/create')\nasync def addUniversity(university : University):\n    newUniversity = university.model_dump(exclude='rank', include=['name', 'place', 'specialize'], mode='python', by_alias=True, exclude_defaults=True)\n    # 비즈니스 로직 구현\n    # 데이터베이스에 저장\n    # 결과 반환\n    return newUniversity\n```\n\n코드 설명\naddUniversity()가 데이터베이스에 새로운 대학을 추가하는 엔드포인트로 상상해 봅시다. 사용자가 프론트엔드에서 데이터를 제출하면 이 API 엔드포인트는 데이터를 받아서 Pydantic 모델에 전달합니다. addUniversity() 함수 내에서 University 데이터 모델을 model_bump() 메서드를 사용하여 직렬화하는 새로운 변수 newUniversity를 선언합니다. 여기에서 우리는 Pydantic 모델의 출력을 원하는 대로 사용자 정의할 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\"exclude\": 이 옵션을 사용하여 Pydantic 모델에서 가져온 필드를 제거할 수 있습니다.\n\n\"include\": 여기서 함수 내에서 계산에 필요한 필드를 지정할 수 있습니다.\n\n\"by_alias\": Pydantic 모델의 각 필드에 대한 대체 이름을 이미 정의했다면, by_alias는 사용 여부에 대한 옵션을 제공합니다.\n\n\"exclude_default\": Pydantic 모델의 특정 필드에 대한 기본값을 정의했기 때문에, 기본값과 같은 값을 가진 필드를 제외하려면 이 옵션을 사용할 수 있습니다. 이 옵션은 그 목적을 위해 사용됩니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 다른 옵션들을 더 탐색하고 싶다면,  `API documentation`  Pydantic 문서 `Base model` `model_dump` 를 확인해보세요.\n\n## dict()\n\n여기서 제공하는 것 또한 `model_dump()` 메서드와 비슷합니다. 왜냐하면 이 역시 파이썬 딕셔너리를 반환하기 때문입니다. 하지만 다른 점은 customize our pydantic model을 위해 사용할 수 있는 몇 가지 옵션이 있다는 것입니다.\n\n## model_dump_json()\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 JSON 출력 또는 직렬화 출력을 JSON 형식으로 받고 싶다면 `model_dump_json()`을 사용하세요. `model_dump` 메서드에서 사용 가능한 모든 옵션들을 여기에도 사용할 수 있습니다.\n\n# 다른 직렬화 옵션들은 무엇이 있을까요\n\n## @field_serializer\n\n예를 들어 Pydantic 모델에서 특정 필드를 커스텀하고자 할 때, 함수나 엔드포인트로 Pydantic 모델 데이터를 가져오기 전에 그 필드를 수정하고 싶을 수 있습니다. 다시 말해 Pydantic 모델을 호출한 후 일부 필드를 수정해 해당 데이터를 함수나 엔드포인트로 반환하고자 하는 경우가 있을 수 있습니다. 이런 경우 `@field_serializer`를 사용해야합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel, field_serializer\n\napp = FastAPI()\nclass University(BaseModel):\n    name: str\n    place: str \n    rank: str\n    specialize: int \n    \n    @field_serializer('rank', when_used='always')\n    def rank_serialize(rank: str):\n        rank = 'world rank - ' + rank \n        return rank\n        \n@app.post('/create')\nasync def addUniversity(university: University):\n    return university\n```\n\n**코드 설명**\n\nUniversity pydantic 모델은 name, place, specialize와 함께 rank와 같은 여러 필드를 허용합니다. 이 모델에 데이터를 전달할 때 rank 필드의 값은 문자열입니다. 그러나 이 코드 외부에서 데이터를 전달할 때 rank의 값으로 숫자만 받습니다. \"01\", \"02\"와 같은 링크를 사용하지만 이 pydantic 모델 외부에서 데이터를 전달할 때 rank의 값을 \"world rank - 01\"과 같이 바꾸고 싶습니다. 간단히 말해 출력은 다음과 같아야 합니다.\n\n```python\n{\n  \"name\": \"string\",\n  \"place\": \"string\",\n  \"rank\": \"world rank - 01\",\n  \"specialize\": 0\n}\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\njs\n{\n  \"name\": \"string\",\n  \"place\": \"string\",\n  \"rank\": \"01\",\n  \"specialize\": 0\n}\n\n\n단일 필드만 직렬화하려면 Pydantic 모델 내에서 새로운 함수를 선언해야 합니다. 이 함수에는 '@field_serializer' 데코레이터를 사용해야 합니다. 하지만 먼저 해당 데코레이터를 Pydantic 모델에서 import해야 합니다. 여러 매개변수를 받을 수 있지만, 여기서는 두 가지만 언급합니다. 첫 번째는 어떤 필드를 직렬화할지를 나타내는 것입니다. 여기서는 'rank' 필드를 사용했습니다. 두 번째는 'when_use'입니다. 이곳에서 언제 이 필드 직렬화기를 사용할지 알려주어야 합니다. 이 예시에서는 'always'를 사용합니다.\n\n그런 다음 해당 함수 내에서 원하는 작업을 수행하고, 마지막으로 반환하면 됩니다. 그게 전부입니다. 간단하지요?\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## @model_serializer\n\n이 메서드에서는 엔드포인트나 함수로 반환하기 전에 원하는대로 pydantic 모델을 직렬화할 수 있습니다. 이는 field_serializer와 매우 유사합니다. 더 잘 이해하기 위해 예제를 살펴봅시다.\n\n```js\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel, model_serializer\n\napp = FastAPI()\nclass University(BaseModel):\n    name : str\n    place : str  \n    @model_serializer()\n    def rank_serialize(self):\n        return {\n        'name' : 'the ' + self.name,\n        'place' : self.place + ', sri lanka'\n        }\n@app.post('/create')\nasync def addUniversity(university : University):\n    return university\r\n```\n\n이렇게 출력을 얻고 싶습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n{\n  \"name\": \"콜롬보 대학\",\n  \"place\": \"스리랑카 콜롬보\"\n}\n```\n\n대신에 모델 시리얼라이저를 사용해보세요.\n\n```js\n{\n  \"name\": \"콜롬보 대학\",\n  \"place\": \"콜롬보\"\n}\n```\n\n첫 번째로 해야 할 일은 pydantic 모델에서 model_serializer를 import하는 것입니다. 그런 다음 모델 내부에서 '@model_serializer' 데코레이터가 달린 함수를 선언하고 원하는 방식으로 출력을 구성하십시오. 마지막으로 반환하십시오. 더 자세한 내용은 pydantic 문서 `API Documentation`의 `Functional serializer` 섹션을 참조하십시오.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그냥 간단하게 Pydantic에서 serializer를 사용하는 방법이야. 더 자세한 내용을 원한다면 문서를 확인하고 이해를 돕기 위해 뭔가를 구현해보세요...\n\n코딩 즐겁게 하시고 또 다른 FastAPI 주제에서 만나요...","ogImage":{"url":"/assets/img/2024-07-07-PydanticserializationstepbystepsforFastAPI_0.png"},"coverImage":"/assets/img/2024-07-07-PydanticserializationstepbystepsforFastAPI_0.png","tag":["Tech"],"readingTime":10},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-07-07-PydanticserializationstepbystepsforFastAPI_0.png\" alt=\"이미지\"></p>\n<p>FastAPI 프레임워크를 사용하여 API를 구축하려면 pydantic에 대해 알아야 합니다. 'post' 요청은 본문 매개변수만 허용하기 때문입니다. 본문 매개변수를 읽으려면 pydantic 모델을 구현해야 합니다.</p>\n<p>그러나 문제는 이 pydantic 모델의 데이터를 사용할 때, 원본 pydantic보다 쉬운 데이터 유형(파이썬 사전 또는 JSON일 수 있음)으로 변환해야 한다는 것입니다. 이 데이터 유형으로 작업하는 것이 원본 pydantic보다 쉽기 때문입니다.</p>\n<p>이 프로세스를 직렬화라고 합니다. 이름에서 알 수 있듯, 이 문제에 대해 심각하게 생각할 필요가 없습니다. 이 주제에 대해 알아야 할 모든 것을 단순화할 것입니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>FastAPI에서 데이터를 반환할 때 pydantic 모델과 정확히 동일한 데이터를 반환하고 싶다면 직렬화 방법을 사용할 필요가 없습니다. FastAPI가 이를 자동으로 처리하기 때문입니다. 그러나 pydantic 데이터 출력을 사용자 정의하려면 (적어도 새 필드를 추가하거나 기존 필드를 제거하는) pydantic에서 어떤 종류의 직렬화 방법을 사용하는 것이 좋습니다. model_dump(), dict() 및 model_dump_json()과 같은 방법이 있습니다.</p>\n<p>먼저 어떻게 무조건적으로 pydantic 모델과 동일한 데이터를 반환하는지 알아보겠습니다.</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">from</span> fastapi <span class=\"hljs-keyword\">import</span> FastAPI\n<span class=\"hljs-keyword\">from</span> pydantic <span class=\"hljs-keyword\">import</span> BaseModel\n\napp = FastAPI()\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">University</span>(<span class=\"hljs-title class_ inherited__\">BaseModel</span>):\n    name : <span class=\"hljs-built_in\">str</span>\n    place : <span class=\"hljs-built_in\">str</span>\n<span class=\"hljs-meta\">@app.post(<span class=\"hljs-params\"><span class=\"hljs-string\">'/create'</span></span>)</span>\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">addUniversity</span>(<span class=\"hljs-params\">university : University</span>):\n    <span class=\"hljs-comment\"># 업무 로직을 수행한 후</span>\n    <span class=\"hljs-comment\"># pydantic 모델 그대로 반환합니다</span>\n    <span class=\"hljs-keyword\">return</span> university\n</code></pre>\n<p>그리고 위의 pydantic 모델을 수정하여 (다른 필드를 추가하는 간단한 예) 직렬화 방법을 사용하지 않고 반환하는 방법을 살펴보겠습니다. 이것은 어려운 주제가 아닙니다. 그저 새로운 사전을 만들고 출력으로 반환하는 것뿐입니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">from</span> fastapi <span class=\"hljs-keyword\">import</span> FastAPI\n<span class=\"hljs-keyword\">from</span> pydantic <span class=\"hljs-keyword\">import</span> BaseModel\n\napp = FastAPI()\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">University</span>(<span class=\"hljs-title class_ inherited__\">BaseModel</span>):\n    name : <span class=\"hljs-built_in\">str</span>\n    place : <span class=\"hljs-built_in\">str</span>\n<span class=\"hljs-meta\">@app.post(<span class=\"hljs-params\"><span class=\"hljs-string\">'/create'</span></span>)</span>\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">addUniversity</span>(<span class=\"hljs-params\">university : University</span>):\n    newUniversity = {\n        <span class=\"hljs-string\">'name'</span> : university.name,\n        <span class=\"hljs-string\">'place'</span> : university.place,\n        <span class=\"hljs-string\">'contactNum'</span> : +<span class=\"hljs-number\">1234678</span>\n    }\n    <span class=\"hljs-keyword\">return</span> newUniversity\n</code></pre>\n<p>만약 직렬화(serialization)에 대해 익숙하지 않다면, 위와 같은 방법으로 해야 한다고 생각할 수 있습니다. 하지만 이제 직렬화 메서드를 적용하는 방법을 살펴본 후, 우리의 작업을 더 쉽게 할 수 있는 방법을 알아보겠습니다.</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">from</span> fastapi <span class=\"hljs-keyword\">import</span> FastAPI\n<span class=\"hljs-keyword\">from</span> pydantic <span class=\"hljs-keyword\">import</span> BaseModel\n\napp = FastAPI()\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">University</span>(<span class=\"hljs-title class_ inherited__\">BaseModel</span>):\n    name : <span class=\"hljs-built_in\">str</span>\n    place : <span class=\"hljs-built_in\">str</span>\n<span class=\"hljs-meta\">@app.post(<span class=\"hljs-params\"><span class=\"hljs-string\">'/create'</span></span>)</span>\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">addUniversity</span>(<span class=\"hljs-params\">university : University</span>):\n    <span class=\"hljs-comment\"># 새로운 대학 변수를 정의하고 직렬화된 데이터를 할당합니다.</span>\n    newUniversity = university.model_dump()\n    <span class=\"hljs-comment\"># 새 데이터 추가</span>\n    newUniversity[<span class=\"hljs-string\">'contactNum'</span>] = <span class=\"hljs-number\">12345678</span>\n    <span class=\"hljs-comment\"># 값을 반환합니다.</span>\n    <span class=\"hljs-keyword\">return</span> newUniversity\n</code></pre>\n<p>따라서 직렬화를 사용할 수 있는 유용한 방법 중 하나를 보여드렸습니다. 이 주제에 대해 더 자세히 알아보고 싶다면, 직렬화에 대해 알아야 할 모든 것을 간단하게 설명해드리겠습니다.\npydantic에는 세 가지 주요 기본 직렬화 메서드가 있습니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h2>model_dump( )</h2>\n<p>이 함수는 Pydantic 모델을 사전으로 변환하는 데 사용됩니다. 사전으로 변환한 후에는 아래와 같이 출력을 사용자 지정하는 여러 옵션이 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">from</span> fastapi <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">FastAPI</span>\n<span class=\"hljs-keyword\">from</span> pydantic <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">BaseModel</span>, <span class=\"hljs-title class_\">Field</span>\n\napp = <span class=\"hljs-title class_\">FastAPI</span>()\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">University</span>(<span class=\"hljs-title class_\">BaseModel</span>):\n    name : str\n    place : str = <span class=\"hljs-title class_\">Field</span>(alias=<span class=\"hljs-string\">'location place'</span>)\n    rank : int\n    specialize : int = <span class=\"hljs-title class_\">Field</span>(<span class=\"hljs-keyword\">default</span>=<span class=\"hljs-number\">1</span>)\n@app.<span class=\"hljs-title function_\">post</span>(<span class=\"hljs-string\">'/create'</span>)\n<span class=\"hljs-keyword\">async</span> def <span class=\"hljs-title function_\">addUniversity</span>(university : <span class=\"hljs-title class_\">University</span>):\n    newUniversity = university.<span class=\"hljs-title function_\">model_dump</span>(exclude=<span class=\"hljs-string\">'rank'</span>, include=[<span class=\"hljs-string\">'name'</span>, <span class=\"hljs-string\">'place'</span>, <span class=\"hljs-string\">'specialize'</span>], mode=<span class=\"hljs-string\">'python'</span>, by_alias=<span class=\"hljs-title class_\">True</span>, exclude_defaults=<span class=\"hljs-title class_\">True</span>)\n    # 비즈니스 로직 구현\n    # 데이터베이스에 저장\n    # 결과 반환\n    <span class=\"hljs-keyword\">return</span> newUniversity\n</code></pre>\n<p>코드 설명\naddUniversity()가 데이터베이스에 새로운 대학을 추가하는 엔드포인트로 상상해 봅시다. 사용자가 프론트엔드에서 데이터를 제출하면 이 API 엔드포인트는 데이터를 받아서 Pydantic 모델에 전달합니다. addUniversity() 함수 내에서 University 데이터 모델을 model_bump() 메서드를 사용하여 직렬화하는 새로운 변수 newUniversity를 선언합니다. 여기에서 우리는 Pydantic 모델의 출력을 원하는 대로 사용자 정의할 수 있습니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>\"exclude\": 이 옵션을 사용하여 Pydantic 모델에서 가져온 필드를 제거할 수 있습니다.</p>\n<p>\"include\": 여기서 함수 내에서 계산에 필요한 필드를 지정할 수 있습니다.</p>\n<p>\"by_alias\": Pydantic 모델의 각 필드에 대한 대체 이름을 이미 정의했다면, by_alias는 사용 여부에 대한 옵션을 제공합니다.</p>\n<p>\"exclude_default\": Pydantic 모델의 특정 필드에 대한 기본값을 정의했기 때문에, 기본값과 같은 값을 가진 필드를 제외하려면 이 옵션을 사용할 수 있습니다. 이 옵션은 그 목적을 위해 사용됩니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>만약 다른 옵션들을 더 탐색하고 싶다면,  <code>API documentation</code>  Pydantic 문서 <code>Base model</code> <code>model_dump</code> 를 확인해보세요.</p>\n<h2>dict()</h2>\n<p>여기서 제공하는 것 또한 <code>model_dump()</code> 메서드와 비슷합니다. 왜냐하면 이 역시 파이썬 딕셔너리를 반환하기 때문입니다. 하지만 다른 점은 customize our pydantic model을 위해 사용할 수 있는 몇 가지 옵션이 있다는 것입니다.</p>\n<h2>model_dump_json()</h2>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>만약 JSON 출력 또는 직렬화 출력을 JSON 형식으로 받고 싶다면 <code>model_dump_json()</code>을 사용하세요. <code>model_dump</code> 메서드에서 사용 가능한 모든 옵션들을 여기에도 사용할 수 있습니다.</p>\n<h1>다른 직렬화 옵션들은 무엇이 있을까요</h1>\n<h2>@field_serializer</h2>\n<p>예를 들어 Pydantic 모델에서 특정 필드를 커스텀하고자 할 때, 함수나 엔드포인트로 Pydantic 모델 데이터를 가져오기 전에 그 필드를 수정하고 싶을 수 있습니다. 다시 말해 Pydantic 모델을 호출한 후 일부 필드를 수정해 해당 데이터를 함수나 엔드포인트로 반환하고자 하는 경우가 있을 수 있습니다. 이런 경우 <code>@field_serializer</code>를 사용해야합니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">from</span> fastapi <span class=\"hljs-keyword\">import</span> FastAPI\n<span class=\"hljs-keyword\">from</span> pydantic <span class=\"hljs-keyword\">import</span> BaseModel, field_serializer\n\napp = FastAPI()\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">University</span>(<span class=\"hljs-title class_ inherited__\">BaseModel</span>):\n    name: <span class=\"hljs-built_in\">str</span>\n    place: <span class=\"hljs-built_in\">str</span> \n    rank: <span class=\"hljs-built_in\">str</span>\n    specialize: <span class=\"hljs-built_in\">int</span> \n    \n<span class=\"hljs-meta\">    @field_serializer(<span class=\"hljs-params\"><span class=\"hljs-string\">'rank'</span>, when_used=<span class=\"hljs-string\">'always'</span></span>)</span>\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">rank_serialize</span>(<span class=\"hljs-params\">rank: <span class=\"hljs-built_in\">str</span></span>):\n        rank = <span class=\"hljs-string\">'world rank - '</span> + rank \n        <span class=\"hljs-keyword\">return</span> rank\n        \n<span class=\"hljs-meta\">@app.post(<span class=\"hljs-params\"><span class=\"hljs-string\">'/create'</span></span>)</span>\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">addUniversity</span>(<span class=\"hljs-params\">university: University</span>):\n    <span class=\"hljs-keyword\">return</span> university\n</code></pre>\n<p><strong>코드 설명</strong></p>\n<p>University pydantic 모델은 name, place, specialize와 함께 rank와 같은 여러 필드를 허용합니다. 이 모델에 데이터를 전달할 때 rank 필드의 값은 문자열입니다. 그러나 이 코드 외부에서 데이터를 전달할 때 rank의 값으로 숫자만 받습니다. \"01\", \"02\"와 같은 링크를 사용하지만 이 pydantic 모델 외부에서 데이터를 전달할 때 rank의 값을 \"world rank - 01\"과 같이 바꾸고 싶습니다. 간단히 말해 출력은 다음과 같아야 합니다.</p>\n<pre><code class=\"hljs language-python\">{\n  <span class=\"hljs-string\">\"name\"</span>: <span class=\"hljs-string\">\"string\"</span>,\n  <span class=\"hljs-string\">\"place\"</span>: <span class=\"hljs-string\">\"string\"</span>,\n  <span class=\"hljs-string\">\"rank\"</span>: <span class=\"hljs-string\">\"world rank - 01\"</span>,\n  <span class=\"hljs-string\">\"specialize\"</span>: <span class=\"hljs-number\">0</span>\n}\n</code></pre>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>js\n{\n\"name\": \"string\",\n\"place\": \"string\",\n\"rank\": \"01\",\n\"specialize\": 0\n}</p>\n<p>단일 필드만 직렬화하려면 Pydantic 모델 내에서 새로운 함수를 선언해야 합니다. 이 함수에는 '@field_serializer' 데코레이터를 사용해야 합니다. 하지만 먼저 해당 데코레이터를 Pydantic 모델에서 import해야 합니다. 여러 매개변수를 받을 수 있지만, 여기서는 두 가지만 언급합니다. 첫 번째는 어떤 필드를 직렬화할지를 나타내는 것입니다. 여기서는 'rank' 필드를 사용했습니다. 두 번째는 'when_use'입니다. 이곳에서 언제 이 필드 직렬화기를 사용할지 알려주어야 합니다. 이 예시에서는 'always'를 사용합니다.</p>\n<p>그런 다음 해당 함수 내에서 원하는 작업을 수행하고, 마지막으로 반환하면 됩니다. 그게 전부입니다. 간단하지요?</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h2>@model_serializer</h2>\n<p>이 메서드에서는 엔드포인트나 함수로 반환하기 전에 원하는대로 pydantic 모델을 직렬화할 수 있습니다. 이는 field_serializer와 매우 유사합니다. 더 잘 이해하기 위해 예제를 살펴봅시다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">from</span> fastapi <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">FastAPI</span>\n<span class=\"hljs-keyword\">from</span> pydantic <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">BaseModel</span>, model_serializer\n\napp = <span class=\"hljs-title class_\">FastAPI</span>()\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">University</span>(<span class=\"hljs-title class_\">BaseModel</span>):\n    name : str\n    place : str  \n    @<span class=\"hljs-title function_\">model_serializer</span>()\n    def <span class=\"hljs-title function_\">rank_serialize</span>(self):\n        <span class=\"hljs-keyword\">return</span> {\n        <span class=\"hljs-string\">'name'</span> : <span class=\"hljs-string\">'the '</span> + self.<span class=\"hljs-property\">name</span>,\n        <span class=\"hljs-string\">'place'</span> : self.<span class=\"hljs-property\">place</span> + <span class=\"hljs-string\">', sri lanka'</span>\n        }\n@app.<span class=\"hljs-title function_\">post</span>(<span class=\"hljs-string\">'/create'</span>)\n<span class=\"hljs-keyword\">async</span> def <span class=\"hljs-title function_\">addUniversity</span>(university : <span class=\"hljs-title class_\">University</span>):\n    <span class=\"hljs-keyword\">return</span> university\n</code></pre>\n<p>이렇게 출력을 얻고 싶습니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\">{\n  <span class=\"hljs-string\">\"name\"</span>: <span class=\"hljs-string\">\"콜롬보 대학\"</span>,\n  <span class=\"hljs-string\">\"place\"</span>: <span class=\"hljs-string\">\"스리랑카 콜롬보\"</span>\n}\n</code></pre>\n<p>대신에 모델 시리얼라이저를 사용해보세요.</p>\n<pre><code class=\"hljs language-js\">{\n  <span class=\"hljs-string\">\"name\"</span>: <span class=\"hljs-string\">\"콜롬보 대학\"</span>,\n  <span class=\"hljs-string\">\"place\"</span>: <span class=\"hljs-string\">\"콜롬보\"</span>\n}\n</code></pre>\n<p>첫 번째로 해야 할 일은 pydantic 모델에서 model_serializer를 import하는 것입니다. 그런 다음 모델 내부에서 '@model_serializer' 데코레이터가 달린 함수를 선언하고 원하는 방식으로 출력을 구성하십시오. 마지막으로 반환하십시오. 더 자세한 내용은 pydantic 문서 <code>API Documentation</code>의 <code>Functional serializer</code> 섹션을 참조하십시오.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>그냥 간단하게 Pydantic에서 serializer를 사용하는 방법이야. 더 자세한 내용을 원한다면 문서를 확인하고 이해를 돕기 위해 뭔가를 구현해보세요...</p>\n<p>코딩 즐겁게 하시고 또 다른 FastAPI 주제에서 만나요...</p>\n</body>\n</html>\n"},"__N_SSG":true}