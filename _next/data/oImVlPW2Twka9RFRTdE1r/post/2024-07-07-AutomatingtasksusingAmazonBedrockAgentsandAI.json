{"pageProps":{"post":{"title":"Amazon Bedrock Agents 및 AI로 작업 자동화하는 방법","description":"","date":"2024-07-07 13:00","slug":"2024-07-07-AutomatingtasksusingAmazonBedrockAgentsandAI","content":"\n\n<img src=\"/assets/img/2024-07-07-AutomatingtasksusingAmazonBedrockAgentsandAI_0.png\" />\n\n## 서문\n\n👍 Amazon Bedrock Agents가 무엇인지 알아볼 거에요.\n👍 AWS 아키텍처를 자세히 살펴볼 거에요.\n👍 TypeScript 및 AWS CDK 코드를 살펴볼 거에요.\n👍 작동 방식을 보기 위해 몇 가지 테스트를 진행해 볼 거에요.\n\n# 소개 👋🏽\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAmazon Bedrock Agents은 당신이 회사 내에서 스스로 작업을 수행할 수 있는 자율 에이전트를 구축하고 사용자 정의할 수 있도록 도와줍니다. 이러한 에이전트는 기관 데이터와 사용자 입력을 활용하여 대화형 채팅과 AI를 이용해 작업을 수행하여 최종 사용자가 작업을 완료하는 데 도움을 줍니다.\n\n이들은 기본 모델, 데이터 소스, 지식베이스, 소프트웨어 응용 프로그램 및 사용자 대화 간의 상호작용을 관리하는 조정자 역할을 합니다. 추가로, 이들은 API 호출을 자동화하여 조치를 수행하고 이러한 조치와 관련된 정보를 풍부하게 하는 지식 베이스에 접근합니다.\n\n![Automating tasks using Amazon Bedrock Agents and AI](/assets/img/2024-07-07-AutomatingtasksusingAmazonBedrockAgentsandAI_1.png)\n\n본 문서에서는 가상의 호텔 및 스파 회사인 LJ Resorts를 다루어 AWS 구조와 코드를 살펴보겠습니다. 우리의 고객은 당사 애플리케이션을 사용하여 호텔 숙박, 골프 세션 및 스파 치료를 한꺼번에 예약하거나 이용 가능한 치료 및 할인, 영업 시간과 같은 회사 정보를 요청할 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![Image 1](/assets/img/2024-07-07-AutomatingtasksusingAmazonBedrockAgentsandAI_2.png)\n\nThe full code repository can be found here:\n\n👇 Before we go any further — please connect with me on LinkedIn for future blog posts and Serverless news [Lee James Gilmore](https://www.linkedin.com/in/lee-james-gilmore/)\n\n\n![Image 2](/assets/img/2024-07-07-AutomatingtasksusingAmazonBedrockAgentsandAI_3.png)\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 아마존 베드락 에이전트란 무엇인가요? 🤖\n\n이제 아마존 베드락 에이전트에 대해 이야기해보겠습니다. 어떤 일을 하는지 알아보면서 시작해봅시다. 먼저 중요한 약어 몇 가지를 이해해 봅시다.\n\n## 약어\n\n시작하기 전에 약어 몇 가지와 그 의미에 대해 알아봅시다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n✔️ FM - 기본 모델\n\n✔️ 액션 그룹\n\n✔️ 지침\n\n🤖 \"고객이 호텔 객실, 스파 세션, 그리고 골프 예약을 도와주시고, 해당하는 날짜와 예약 유형에 따라 특별 혜택을 제공해 주세요. 예약을 완료하기 전에 오프닝 타임이나 가격에 대해 고객에게 안내하고, 호텔 정책을 고려해 주세요.\"\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Automating tasks using Amazon Bedrock Agents and AI](/assets/img/2024-07-07-AutomatingtasksusingAmazonBedrockAgentsandAI_4.png)\n\n## Amazon Bedrock 에이전트는 어떻게 작동하나요? 🤖\n\n아래 다이어그램에서 볼 수 있듯이, 우리는 고객의 입력부터 시작합니다. 이 입력은 프롬프트 스토어로 증가되어 세션 스토어에서 가져온 이전 대화 내용과 함께 바탕 모델을 호출하여 보강됩니다.\n\n다음으로 Orchestration prompt는 응답을 구문 분석하고 우리의 OpenAPI 사양 문서에 정의된 작업에 따라 액션 그룹 람다를 호출하며 Bedrock Knowledge Base에서 필요한 추가 정보를 가져옵니다. Orchestration이 완료되면 결과가 고객에게 반환됩니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-07-07-AutomatingtasksusingAmazonBedrockAgentsandAI_5.png)\n\n다음 섹션에서는 본문에서 무엇을 구축 중인지 살펴보겠습니다. 그러면 코드를 살펴보고 응용 프로그램을 배포하고 테스트할 수 있습니다.\n\n# 무엇을 만들고 있을까요? 🛠️\n\n그래, 이제 Amazon Bedrock와 함께 에이전트에 대해 깊이 파고들었으며 이론적으로 작동 방식을 이해했으니, 이제 이 글에서 무엇을 만들고 있는지 살펴봅시다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-07-07-AutomatingtasksusingAmazonBedrockAgentsandAI_6.png\" />\n\n저희는 이전 글에서 Amazon Bedrock Knowledge Bases에 대해 다뤘었는데, 해당 글은 여기에서 찾아볼 수 있어요:\n\n위 다이어그램에서 볼 수 있는 것은 다음과 같아요:\n\n- 고객이 자신의 프롬프트로 Lambda 함수 URL을 탭합니다.\n- 이는 쿼리 Lambda 함수를 호출하며, 이 함수는 다시 Amazon Bedrock 에이전트를 호출합니다.\n- 에이전트는 특정 회사 데이터를 사용한 배포된 Knowledge Base와 S3 버킷에 있는 OpenAPI 사억을 기반으로 한 Lambda 함수를 사용하여 고객의 작업을 완료하기 위해 다른 내부 시스템에 경로를 지정합니다 (여러 호출을 우리를 대신하여 조정할 것입니다).\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 고수준 아키텍처를 논의했으니, 다음 섹션에서 예시 상호작용을 살펴봅시다.\n\n# 상호작용이 어떻게 보일까요? ⛳\n\n아래 예시 상호작용을 살펴보면 고객이 에이전트와 채팅하는 모습을 볼 수 있습니다. 사실, 이는 실제 프롬프트와 출력값을 사용하여 우리의 예시 솔루션을 통해 실행된 것입니다:\n\nCustomer: “Hi, what special deals do you have on at the moment for hotels?”\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n에이전트: \"현재 이용 가능한 호텔 특별 할인은 다음과 같습니다: - 월요일 스테이케이션 특가: 객실 요금 20% 할인 (월요일만) - 급행 투숙 특가: 당일 예약 시 15% 할인 (화요일만) - 연박 할인: 3박 숙박 20% 할인 (수요일만) - 스위트 업그레이드: 익스큐티브 스위트 무료 업그레이드 (목요일만) - 주말 여행 패키지: 2박 숙박 10% 할인 (금요일만)\"\n\n고객: \"2024년 02월 25일에 호텔 객실을 예약하고 싶어요, 현재 무엇이 가능한가요?\"\n\n에이전트: \"2024년 02월 25일 이용 가능한 객실은 다음과 같습니다: - 101호 객실(스탠다드, $100): 퀸 사이즈 침대가 있는 아늑한 표준 객실 - 102호 객실(스탠다드, $100): 두 개의 더블 침대가 있는 넓은 표준 객실 - 103호 객실(디럭스, $150): 킹 사이즈 침대와 전망이 있는 호화로운 디럭스 객실 - 104호 객실(스위트, $200): 별도의 거실 공간과 침실이 있는 우아한 스위트 - 105호 객실(스탠다드, $90): ..생략..\"\n\n고객: \"2024년 02월 25일에 디럭스 객실을 $160에 예약할 수 있나요?\"\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n에이전트: \"2024년 2월 25일에 109호 객실을 예약해드렸습니다. 이 객실은 명품 욕실이 있는 디럭스 객실이며, 160달러입니다. 필요한 것이 있으면 언제든지 알려주세요!\"\n\n고객: \"어떤 스파 시술이 가능한가요?\"\n\n에이전트: \"오늘 가능한 스파 시술 목록입니다: — 스웨디시 마사지: 긴장을 완화하고 이완을 촉진하는 전신 마사지. 가격: 80달러 — 페이셜: 피부를 재생하고 활기를 되찾는 깊은 클렌징 페이셜. 가격: 70달러 — 핫 스톤 마사지: 가열된 돌을 사용한 치료적인 마사지로 근육을 진정시키고 혈류를 향상시킵니다. 가격: 90달러 — 아로마테라피: 아로마 향기로 편안함과 웰빙을 높이는 섬세한 마사지. 가격: 85달러 — ….'간략히 하기 위해 나머지 제거됨'\"\n\n고객: \"핫 스톤 마사지를 예약할 수 있나요?\"\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAgent: \"네, 오늘 당신을 위해 핫 스톤 마사지를 예약했어요. 이 치료 마사지는 가열된 돌을 사용하여 근육을 진정시키고 혈액 순환이 향상됩니다. 비용은 $90이에요. 더 필요한 게 있으면 언제든지 말해주세요!\"\n\nCustomer: \"골프의 영업 시간은 어떻게 되나요?\"\n\nAgent: \"LJ 리조트의 골프 영업 시간은 다음과 같아요: 월요일부터 금요일까지: 오전 9시 — 오후 6시 토요일 및 일요일: 오전 7시 — 오후 7시\"\n\nCustomer: \"해당 날에도 아침에는 골프 세션도 있나요?\"\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n에이전트: \"오늘 가능한 골프 세션을 확인해보니 아침 세션 하나가 있네요: 아침 티 타임: 아침에 멋진 전망과 함께 골프를 즐기세요. 비용: $80 이 아침 골프 세션을 예약해 드릴까요?\"\n\n고객: \"제가 $80에 그 날 골프 세션을 예약할 수 있을까요?\"\n\n에이전트: \"네, $80에 아침 골프 세션을 오늘 예약해 드렸습니다. 이 세션에서는 아침에 멋진 경치를 감상하며 골프를 즐길 수 있을 거예요. 더 필요한 사항이 있으시면 언제든지 말해 주세요!\"\n\n고객: \"제 예약의 총 비용이 얼마인가요?\"\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n에이전트: \"대화 기록을 기반으로 하면, 핫 스톤 마사지를 90달러에 예약하셨고, 아침 골프 세션을 80달러에 예약하셨습니다. 예약 총 비용은 90달러 + 80달러 = 170달러입니다.\"\n\n이것은 베드락 에이전트가 얼마나 강력한지 보여줍니다. 이것은 사람이 여러 시스템에 액세스해 고객과 직접 대면해야 하는 작업을 대체한 것입니다. 인공지능이 전체 프로세스를 자동화하는 데 사용되었습니다.\n\n이제 고객과 에이전트 간에 발생할 수있는 상호 작용을 살펴 보았으니, 주요 코드를 살펴 보겠습니다.\n\n# 주요 코드 설명하기 👨‍💻\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n알겠어요, 우리는 이 기본 예제를 실제로 본 것이고, 이제 TypeScript 및 CDK 코드를 살펴보겠습니다. 전체 솔루션은 여기에서 찾으실 수 있습니다.\n\n## Stateful Stack\n\n먼저 상태 유지 스택부터 시작해봅시다. 여기서 먼저 에이전트 람다 함수를 생성합니다:\n\n```js\n// create the lambda for the agent - this is the lambda that determines\n// what the prompt looks like with regards to mapping to the schema\nconst actionGroupAgentLambda: nodeLambda.NodejsFunction =\n  new nodeLambda.NodejsFunction(this, 'AgentLambda', {\n    functionName: 'action-group-executor',\n    runtime: lambda.Runtime.NODEJS_20_X,\n    entry: path.join(\n      __dirname,\n      './src/adapters/primary/action-group-executor/action-group-executor.adapter.ts'\n    ),\n    memorySize: 1024,\n    handler: 'handler',\n    timeout: cdk.Duration.minutes(5),\n    description: 'action group lambda function',\n    architecture: lambda.Architecture.ARM_64,\n    tracing: lambda.Tracing.ACTIVE,\n    bundling: {\n      minify: true,\n    },\n    environment: {\n      ...lambdaConfig,\n    },\n  });\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음은 아래에 표시된대로 우리의 Amazon Bedrock 에이전트를 생성합니다:\n\n```js\n// bedrock 에이전트 생성\nconst agent = new bedrock.Agent(this, 'BedrockAgent', {\n  name: '에이전트',\n  description: '호텔, 스파 및 골프 예약을 위한 에이전트입니다.',\n  foundationModel: bedrock.BedrockFoundationModel.ANTHROPIC_CLAUDE_V2,\n  instruction:\n    '고객이 호텔 객실, 스파 세션 및 골프 예약을 도와주셔서 감사하겠습니다. 그들에게 요일 및 예약 유형에 따라 특별 제공상품에 대해 알려주시고, 예약을 완료하기 전에 오픈 시간이나 가격을 안내해주시고, 또한 호텔 정책을 고려해주시기 바랍니다.',\n  idleSessionTTL: cdk.Duration.minutes(10),\n  knowledgeBases: [kb],\n  shouldPrepareAgent: true,\n  aliasName: '에이전트',\n});\n```\n\n위의 코드에서 보듯이, 에이전트에게 세션 지속 시간, Amazon Bedrock 지식 베이스에 대한 링크, FM 유형(Claud V2) 및 이 에이전트가 수행해야 할 작업에 대한 지시 사항과 같은 주요 속성들을 지정합니다.\n\n다음으로, 아래와 같이 Action 그룹을 생성합니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n// 예약을 위한 동작 그룹을 추가합니다.\nnew bedrock.AgentActionGroup(this, 'AgentActionGroup', {\n  actionGroupName: 'agent-action-group',\n  description: '예약을 위한 동작 그룹',\n  agent: agent,\n  apiSchema: bedrock.S3ApiSchema.fromAsset(\n    path.join(__dirname, './schema/api-schema.json')\n  ),\n  actionGroupState: 'ENABLED',\n  actionGroupExecutor: actionGroupAgentLambda,\n  shouldPrepareAgent: true,\n});\n```\n\n우리는 에이전트가 할 수 있는 것을 상세히 설명하는 Open API 스키마와 동작에 대한 프록시로 호출되는 람다 함수를 제공한다는 것을 알 수 있습니다. 이제 Open API 사양이 어떻게 보이는지 살펴보겠습니다:\n\n```js\n{\n  \"openapi\": \"3.0.0\",\n  \"info\": {\n    \"title\": \"LJ 리조트를 위한 호텔, 스파 및 골프 예약 API\",\n    \"version\": \"1.0.0\",\n    \"description\": \"고객의 호텔, 스파 및 골프 예약을 관리하기 위한 API입니다.\"\n  },\n  \"paths\": {\n    \"/rooms\": {\n      \"get\": {\n        \"summary\": \"이용 가능한 모든 객실 목록을 가져옵니다\",\n        \"description\": \"특정 날짜에 이용 가능한 모든 객실 목록을 가져옵니다\",\n        \"operationId\": \"getAllAvailableRooms\",\n        \"responses\": {\n          \"200\": {\n            \"description\": \"특정 날짜에 이용 가능한 모든 객실 목록을 가져옵니다\",\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"type\": \"array\",\n                  \"items\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"roomId\": {\n                        \"type\": \"string\",\n                        \"description\": \"객실의 고유 ID입니다.\"\n                      },\n                      \"roomType\": {\n                        \"type\": \"string\",\n                        \"description\": \"객실 유형입니다.\"\n                      },\n                      \"roomDescription\": {\n                        \"type\": \"string\",\n                        \"description\": \"객실 설명입니다.\"\n                      },\n                      \"date\": {\n                        \"type\": \"string\",\n                        \"description\": \"객실 예약 가능한 날짜입니다.\"\n                      },\n                      \"cost\": {\n                        \"type\": \"string\",\n                        \"description\": \"객실 비용(1박당)입니다.\"\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      },\n      \"post\": {\n        \"summary\": \"특정 날짜에 이용 가능한 객실을 예약합니다\",\n        \"description\": \"특정 날짜에 객실을 예약합니다\",\n        \"operationId\": \"bookRoom\",\n        \"requestBody\": {\n          \"required\": true,\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"type\": \"object\",\n                \"properties\": {\n                  \"roomId\": {\n                    \"type\": \"string\",\n                    \"description\": \"예약할 객실의 ID입니다\"\n                  },\n                  \"date\": {\n                    \"type\": \"string\",\n                    \"description\": \"객실 예약 날짜입니다\"\n                  }\n                },\n                \"required\": [\"roomId\", \"date\"]\n              }\n            }\n          }\n        },\n        \"responses\": {\n          \"200\": {\n            \"description\": \"객실 예약 성공\"\n          }\n        }\n      }\n    },\n    \"/spa-sessions\": {\n      ...\n    },\n    \"/golf-sessions\": {\n      ...\n    }\n  }\n}\n```\n\n모델이 수행해야 할 작업을 결정하는 중요한 부분은 설명, 경로, 메서드 및 작업 ID입니다. 예를 들어, 모든 호텔 객실을 나열하기 위해 사용하는 것은 다음과 같습니다:\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n**Description** - \"특정 날짜에 대한 모든 이용 가능한 객실 목록을 가져옵니다\".\n**OperationId** - \"getAllAvailableRooms\".\n**Path** - ‘/rooms’.\n**Method** - ‘GET’.\n\n우리의 람다 함수가 호출되면 해당 세부 정보를 활용하여 호출해야 하는 다른 시스템을 결정합니다:\n\n```js\nimport {\n  MetricUnits,\n  Metrics,\n  logMetrics,\n} from '@aws-lambda-powertools/metrics';\nimport { Tracer, captureLambdaHandler } from '@aws-lambda-powertools/tracer';\nimport { golfSessions, rooms, spaTreatments } from 'stateful/src/data';\n\nimport { injectLambdaContext } from '@aws-lambda-powertools/logger';\nimport middy from '@middy/core';\nimport { logger } from '@shared/index';\n\nconst tracer = new Tracer();\nconst metrics = new Metrics();\n\nexport const adapter = async ({\n  inputText,\n  apiPath,\n  httpMethod,\n  actionGroup,\n  messageVersion,\n  requestBody,\n  sessionAttributes,\n  promptSessionAttributes,\n}: Event): Promise<Response> => {\n  let body;\n  let httpStatusCode = 200;\n\n  try {\n    logger.info(\n      `inputText: ${inputText}, apiPath: ${apiPath}, httpMethod: ${httpMethod}`\n    );\n\n    // 참고: 실제로는 람다 FURLS 또는 다른 DB 또는 API/서비스를 호출할 것이지만,\n    // 작동 방식을 보여주기 위해 기사용 가짜 스텁 데이터를 사용합니다.\n    switch (apiPath) {\n      case '/rooms':\n        if (httpMethod === 'GET') {\n          body = rooms;\n        } else if (httpMethod === 'POST') {\n          body = rooms.find((room) => room.roomId === '109');\n        }\n        break;\n\n      case '/spa-sessions':\n        if (httpMethod === 'GET') {\n          body = spaTreatments;\n        } else if (httpMethod === 'POST') {\n          body = spaTreatments.find(\n            (treatment) => treatment.treatmentId === '3'\n          );\n        }\n        break;\n\n      case '/golf-sessions':\n        if (httpMethod === 'GET') {\n          body = golfSessions;\n        } else if (httpMethod === 'POST') {\n          body = golfSessions.find((session) => session.sessionId === '1');\n        }\n        break;\n\n      default:\n        httpStatusCode = 500;\n        body =\n          'Sorry, I am unable to help you with that. Please try asking the question in a different way perhaps.';\n        break;\n    }\n\n    metrics.addMetric('SuccessfulActionGroupQuery', MetricUnits.Count, 1);\n\n    return {\n      messageVersion,\n      response: {\n        apiPath,\n        actionGroup,\n        httpMethod,\n        httpStatusCode,\n        sessionAttributes,\n        promptSessionAttributes,\n        responseBody: {\n          'application-json': {\n            body: JSON.stringify(body),\n          },\n        },\n      },\n    };\n  } catch (error) {\n    let errorMessage = 'Unknown error';\n    if (error instanceof Error) errorMessage = error.message;\n    logger.error(errorMessage);\n\n    metrics.addMetric('ActionGroupQueryError', MetricUnits.Count, 1);\n\n    throw error;\n  }\n};\n\nexport const handler = middy(adapter)\n  .use(injectLambdaContext(logger))\n  .use(captureLambdaHandler(tracer))\n  .use(logMetrics(metrics));\n```\n\n위의 예제에서는 다른 시스템을 호출하는 대신 반환된 데이터를 간단히 하드코딩했음을 볼 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![스테이트리스 스택](/assets/img/2024-07-07-AutomatingtasksusingAmazonBedrockAgentsandAI_7.png)\n\n이제 우리 에이전트를 쿼리하는 스테이트리스 스택을 살펴보겠습니다.\n\n## 스테이트리스 스택\n\n먼저 스트리밍이 설정된 쿼리 람다 함수를 생성합니다:\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\r\n// 에이전트 쿼리를 위한 람다 함수를 생성합니다.\nconst queryModelLambda: nodeLambda.NodejsFunction =\n  new nodeLambda.NodejsFunction(this, 'QueryModelLambda', {\n    functionName: 'query-model-lambda',\n    runtime: lambda.Runtime.NODEJS_20_X,\n    entry: path.join(\n      __dirname,\n      './src/adapters/primary/query-model/query-model.adapter.ts'\n    ),\n    memorySize: 1024,\n    handler: 'handler',\n    timeout: cdk.Duration.minutes(3),\n    description: '쿼리 모델 람다 함수',\n    architecture: lambda.Architecture.ARM_64,\n    tracing: lambda.Tracing.ACTIVE,\n    bundling: {\n      minify: true,\n    },\n    environment: {\n      AGENT_ID: agentId,\n      AGENT_ALIAS_ID: agentAliasId,\n      ...lambdaConfig,\n    },\n  });\n\n// 쿼리 람다에 대한 함수 URL을 스트림 응답으로 추가합니다.\nconst queryModelLambdaUrl = queryModelLambda.addFunctionUrl({\n  authType: lambda.FunctionUrlAuthType.NONE,\n  invokeMode: lambda.InvokeMode.RESPONSE_STREAM,\n  cors: {\n    allowedOrigins: ['*'],\n  },\n});\r\n```\n\n그런 다음, 아래와 같이 에이전트 호출 권한을 부여합니다:\n\n```js\r\n// 쿼리 람다 함수가 모델/KB/에이전트를 쿼리할 수 있도록 허용합니다.\nqueryModelLambda.addToRolePolicy(\n  new iam.PolicyStatement({\n    actions: [\n      'bedrock:RetrieveAndGenerate',\n      'bedrock:Retrieve',\n      'bedrock:InvokeModel',\n      'bedrock:InvokeAgent',\n    ],\n    resources: ['*'],\n  })\n);\r\n```\n\n이제 사용자가 함수 URL을 통해 프롬프트를 제공하고 에이전트를 호출하는 Query Lambda 함수를 살펴보겠습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\r\nimport { MetricUnits, Metrics } from '@aws-lambda-powertools/metrics';\r\nimport {\r\n  BedrockAgentRuntimeClient,\r\n  InvokeAgentCommand,\r\n  InvokeAgentRequest,\r\n  InvokeAgentResponse,\r\n} from '@aws-sdk/client-bedrock-agent-runtime';\r\nimport { ResponseStream, streamifyResponse } from 'lambda-stream';\r\n\r\nimport { config } from '@config';\r\nimport { ValidationError } from '@errors/validation-error';\r\nimport { logger } from '@shared/index';\r\nimport { APIGatewayProxyEventV2 } from 'aws-lambda';\r\n\r\nconst metrics = new Metrics();\r\nconst client = new BedrockAgentRuntimeClient();\r\n\r\nconst agentId = config.get('agentId');\r\nconst agentAliasId = config.get('agentAliasId');\r\n\r\nfunction parseBase64(message: Uint8Array): string {\r\n  return Buffer.from(message).toString('utf-8');\r\n}\r\n\r\nexport const queryModelAdapter = async (\r\n  { body }: APIGatewayProxyEventV2,\r\n  responseStream: ResponseStream\r\n): Promise<void> => {\r\n  try {\r\n    responseStream.setContentType('application/json');\r\n\r\n    if (!body) throw new ValidationError('no payload body');\r\n    const request = JSON.parse(body);\r\n\r\n    const { sessionAttributes, promptSessionAttributes, sessionId, prompt } =\r\n      request;\r\n\r\n    const input: InvokeAgentRequest = {\r\n      sessionState: {\r\n        sessionAttributes,\r\n        promptSessionAttributes,\r\n      },\r\n      agentId,\r\n      agentAliasId,\r\n      sessionId,\r\n      inputText: prompt,\r\n    };\r\n\r\n    const command: InvokeAgentCommand = new InvokeAgentCommand(input);\r\n    const response: InvokeAgentResponse = await client.send(command);\r\n\r\n    const chunks = [];\r\n    const completion = response.completion || [];\r\n\r\n    for await (const chunk of completion) {\r\n      if (chunk.chunk && chunk.chunk.bytes) {\r\n        const parsed = parseBase64(chunk.chunk.bytes);\r\n\r\n        chunks.push(parsed);\r\n      }\r\n    }\r\n\r\n    const returnMessage = {\r\n      sessionId: response.sessionId,\r\n      contentType: response.contentType,\r\n      message: chunks.join(' '),\r\n    };\r\n\r\n    metrics.addMetric('SuccessfulQueryModel', MetricUnits.Count, 1);\r\n\r\n    // Note: In the example we are not streaming, we are using the FURL request timeout feature\r\n    // but we could easily write the stream during the for loop if we wanted to\r\n    responseStream.write(returnMessage);\r\n    responseStream.end();\r\n  } catch (error) {\r\n    let errorMessage = 'Unknown error';\r\n    if (error instanceof Error) errorMessage = error.message;\r\n    logger.error(errorMessage);\r\n\r\n    metrics.addMetric('QueryModelError', MetricUnits.Count, 1);\r\n\r\n    responseStream.end();\r\n    throw error;\r\n  }\r\n  responseStream.end();\r\n};\r\n\r\nexport const handler = streamifyResponse(queryModelAdapter);\r\n```\r\n\r\n위의 코드에서는 에이전트로부터 반환된 응답을 'chunks'로 스트림으로 전송하고 있습니다. 그러나 이 예제에서는 사용자에게 실시간으로 업데이트를 제공하지 않고 완료될 때까지 기다린 후 JSON 객체로 응답합니다. 이제 다음 섹션에서 이를 테스트해보겠습니다!\r\n\r\n# 어플리케이션 테스트 🧪\r\n\r\n## Postman을 통한 테스트하기\r\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n당신은 postman/Bedrock Agents.postman_collection.json 파일을 사용하여 자신의 Lambda 함수 URL 정보로 테스트할 수 있습니다.\n\n다음과 같은 예시 JSON 페이로드를 사용하여 테스트할 수 있습니다:\n\n```js\n{\n  \"agentId\": \"agentId\",\n  \"agentAliasId\": \"agentAliasId\",\n  \"sessionId\": \"1f6aa00e-e585-49aa-aa2d-16adb64857c6\",\n  \"prompt\": \"Can I please book a morning golf session on 2024-02-25\"\n}\n```\n\n그리고 우리의 에이전트가 다음과 같이 응답하는 것을 확인할 수 있습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리 에이전트는 여러 가지 작업을 조정했습니다. 첫 번째로 그날 이용할 수 있는 골프 세션을 확인하는 것이었습니다.\n\n에이전트는 먼저 '/golf-sessions/'에 'GET'을 실행해야 한다고 결정했는데, 이렇게 하면 그 날 이용 가능한 모든 골프 세션이 반환됩니다.\n\n그런 다음 예약을 하기 위해 '/golf-sessions/'에 두 번째 작업 'POST'를 연이어 실행했습니다.\n\n여기서 대화형 AI의 힘과 자율 에이전트의 역할을 볼 수 있습니다. 고객을 지원하기 위해 여러 가지 작업을 조합했습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-07-07-AutomatingtasksusingAmazonBedrockAgentsandAI_8.png)\n\n지금은 다른 시나리오에서도 이를 테스트할 수 있어요. 예를 들면 거래 확인, 스파 세션 예약 등등! 댓글에서 솔루션을 어떻게 찾았는지 알려주세요!\n\n# 마무리 인사 👋🏽\n\n이 글을 즐겨 읽어주셨기를 바랍니다. 만약 즐겁게 읽었다면 공유하고 피드백 주세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n비슷한 콘텐츠를 위해 내 YouTube 채널을 구독해주세요!\n\n![Automating tasks using Amazon Bedrock Agents and AI](/assets/img/2024-07-07-AutomatingtasksusingAmazonBedrockAgentsandAI_9.png)\n\n아래의 링크를 통해 연락하고 싶어요:\n\n[LinkedIn - Lee James Gilmore](https://www.linkedin.com/in/lee-james-gilmore/)\n[Twitter - Lee James Gilmore](https://twitter.com/LeeJamesGilmore)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n게시물을 즐겁게 보셨다면 더 많은 게시물/시리즈를 보려면 내 프로필 Lee James Gilmore를 팔로우해주세요! 또한 인사를 건네고 Hi를 말하는 것을 잊지 마세요 👋\n\n게시물 하단의 '박수' 기능도 사용해보세요. 만약 게시물을 즐겼다면 '박수'를 또 클릭할 수 있습니다!!\n\n# 자기소개\n\n\"안녕하세요, 저는 영국을 기반으로 하는 AWS 커뮤니티 빌더, 블로거, AWS 인증 클라우드 아키텍트이자 기술 및 아키텍처 부문 글로벌 팀장 Lee입니다. 현재는 City Electrical Factors(UK) & City Electric Supply(US)에서 근무 중이며, 지난 6년 동안 주로 AWS 상에서 full-stack JavaScript로 작업해 왔습니다.\"\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저는 AWS를 사랑하는 서버리스 선구자라고 생각해요. 혁신, 소프트웨어 아키텍처, 그리고 기술에 대한 모든 것을 좋아해요. \n\n** 제공된 정보는 제 개인적인 견해이며, 해당 정보 사용에 대한 책임을 지지 않습니다. **\n\n아래 내용도 참고해보세요:","ogImage":{"url":"/assets/img/2024-07-07-AutomatingtasksusingAmazonBedrockAgentsandAI_0.png"},"coverImage":"/assets/img/2024-07-07-AutomatingtasksusingAmazonBedrockAgentsandAI_0.png","tag":["Tech"],"readingTime":27},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<img src=\"/assets/img/2024-07-07-AutomatingtasksusingAmazonBedrockAgentsandAI_0.png\">\n<h2>서문</h2>\n<p>👍 Amazon Bedrock Agents가 무엇인지 알아볼 거에요.\n👍 AWS 아키텍처를 자세히 살펴볼 거에요.\n👍 TypeScript 및 AWS CDK 코드를 살펴볼 거에요.\n👍 작동 방식을 보기 위해 몇 가지 테스트를 진행해 볼 거에요.</p>\n<h1>소개 👋🏽</h1>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>Amazon Bedrock Agents은 당신이 회사 내에서 스스로 작업을 수행할 수 있는 자율 에이전트를 구축하고 사용자 정의할 수 있도록 도와줍니다. 이러한 에이전트는 기관 데이터와 사용자 입력을 활용하여 대화형 채팅과 AI를 이용해 작업을 수행하여 최종 사용자가 작업을 완료하는 데 도움을 줍니다.</p>\n<p>이들은 기본 모델, 데이터 소스, 지식베이스, 소프트웨어 응용 프로그램 및 사용자 대화 간의 상호작용을 관리하는 조정자 역할을 합니다. 추가로, 이들은 API 호출을 자동화하여 조치를 수행하고 이러한 조치와 관련된 정보를 풍부하게 하는 지식 베이스에 접근합니다.</p>\n<p><img src=\"/assets/img/2024-07-07-AutomatingtasksusingAmazonBedrockAgentsandAI_1.png\" alt=\"Automating tasks using Amazon Bedrock Agents and AI\"></p>\n<p>본 문서에서는 가상의 호텔 및 스파 회사인 LJ Resorts를 다루어 AWS 구조와 코드를 살펴보겠습니다. 우리의 고객은 당사 애플리케이션을 사용하여 호텔 숙박, 골프 세션 및 스파 치료를 한꺼번에 예약하거나 이용 가능한 치료 및 할인, 영업 시간과 같은 회사 정보를 요청할 수 있습니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p><img src=\"/assets/img/2024-07-07-AutomatingtasksusingAmazonBedrockAgentsandAI_2.png\" alt=\"Image 1\"></p>\n<p>The full code repository can be found here:</p>\n<p>👇 Before we go any further — please connect with me on LinkedIn for future blog posts and Serverless news <a href=\"https://www.linkedin.com/in/lee-james-gilmore/\" rel=\"nofollow\" target=\"_blank\">Lee James Gilmore</a></p>\n<p><img src=\"/assets/img/2024-07-07-AutomatingtasksusingAmazonBedrockAgentsandAI_3.png\" alt=\"Image 2\"></p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h1>아마존 베드락 에이전트란 무엇인가요? 🤖</h1>\n<p>이제 아마존 베드락 에이전트에 대해 이야기해보겠습니다. 어떤 일을 하는지 알아보면서 시작해봅시다. 먼저 중요한 약어 몇 가지를 이해해 봅시다.</p>\n<h2>약어</h2>\n<p>시작하기 전에 약어 몇 가지와 그 의미에 대해 알아봅시다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>✔️ FM - 기본 모델</p>\n<p>✔️ 액션 그룹</p>\n<p>✔️ 지침</p>\n<p>🤖 \"고객이 호텔 객실, 스파 세션, 그리고 골프 예약을 도와주시고, 해당하는 날짜와 예약 유형에 따라 특별 혜택을 제공해 주세요. 예약을 완료하기 전에 오프닝 타임이나 가격에 대해 고객에게 안내하고, 호텔 정책을 고려해 주세요.\"</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p><img src=\"/assets/img/2024-07-07-AutomatingtasksusingAmazonBedrockAgentsandAI_4.png\" alt=\"Automating tasks using Amazon Bedrock Agents and AI\"></p>\n<h2>Amazon Bedrock 에이전트는 어떻게 작동하나요? 🤖</h2>\n<p>아래 다이어그램에서 볼 수 있듯이, 우리는 고객의 입력부터 시작합니다. 이 입력은 프롬프트 스토어로 증가되어 세션 스토어에서 가져온 이전 대화 내용과 함께 바탕 모델을 호출하여 보강됩니다.</p>\n<p>다음으로 Orchestration prompt는 응답을 구문 분석하고 우리의 OpenAPI 사양 문서에 정의된 작업에 따라 액션 그룹 람다를 호출하며 Bedrock Knowledge Base에서 필요한 추가 정보를 가져옵니다. Orchestration이 완료되면 결과가 고객에게 반환됩니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p><img src=\"/assets/img/2024-07-07-AutomatingtasksusingAmazonBedrockAgentsandAI_5.png\" alt=\"이미지\"></p>\n<p>다음 섹션에서는 본문에서 무엇을 구축 중인지 살펴보겠습니다. 그러면 코드를 살펴보고 응용 프로그램을 배포하고 테스트할 수 있습니다.</p>\n<h1>무엇을 만들고 있을까요? 🛠️</h1>\n<p>그래, 이제 Amazon Bedrock와 함께 에이전트에 대해 깊이 파고들었으며 이론적으로 작동 방식을 이해했으니, 이제 이 글에서 무엇을 만들고 있는지 살펴봅시다:</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<img src=\"/assets/img/2024-07-07-AutomatingtasksusingAmazonBedrockAgentsandAI_6.png\">\n<p>저희는 이전 글에서 Amazon Bedrock Knowledge Bases에 대해 다뤘었는데, 해당 글은 여기에서 찾아볼 수 있어요:</p>\n<p>위 다이어그램에서 볼 수 있는 것은 다음과 같아요:</p>\n<ul>\n<li>고객이 자신의 프롬프트로 Lambda 함수 URL을 탭합니다.</li>\n<li>이는 쿼리 Lambda 함수를 호출하며, 이 함수는 다시 Amazon Bedrock 에이전트를 호출합니다.</li>\n<li>에이전트는 특정 회사 데이터를 사용한 배포된 Knowledge Base와 S3 버킷에 있는 OpenAPI 사억을 기반으로 한 Lambda 함수를 사용하여 고객의 작업을 완료하기 위해 다른 내부 시스템에 경로를 지정합니다 (여러 호출을 우리를 대신하여 조정할 것입니다).</li>\n</ul>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>이제 고수준 아키텍처를 논의했으니, 다음 섹션에서 예시 상호작용을 살펴봅시다.</p>\n<h1>상호작용이 어떻게 보일까요? ⛳</h1>\n<p>아래 예시 상호작용을 살펴보면 고객이 에이전트와 채팅하는 모습을 볼 수 있습니다. 사실, 이는 실제 프롬프트와 출력값을 사용하여 우리의 예시 솔루션을 통해 실행된 것입니다:</p>\n<p>Customer: “Hi, what special deals do you have on at the moment for hotels?”</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>에이전트: \"현재 이용 가능한 호텔 특별 할인은 다음과 같습니다: - 월요일 스테이케이션 특가: 객실 요금 20% 할인 (월요일만) - 급행 투숙 특가: 당일 예약 시 15% 할인 (화요일만) - 연박 할인: 3박 숙박 20% 할인 (수요일만) - 스위트 업그레이드: 익스큐티브 스위트 무료 업그레이드 (목요일만) - 주말 여행 패키지: 2박 숙박 10% 할인 (금요일만)\"</p>\n<p>고객: \"2024년 02월 25일에 호텔 객실을 예약하고 싶어요, 현재 무엇이 가능한가요?\"</p>\n<p>에이전트: \"2024년 02월 25일 이용 가능한 객실은 다음과 같습니다: - 101호 객실(스탠다드, $100): 퀸 사이즈 침대가 있는 아늑한 표준 객실 - 102호 객실(스탠다드, $100): 두 개의 더블 침대가 있는 넓은 표준 객실 - 103호 객실(디럭스, $150): 킹 사이즈 침대와 전망이 있는 호화로운 디럭스 객실 - 104호 객실(스위트, $200): 별도의 거실 공간과 침실이 있는 우아한 스위트 - 105호 객실(스탠다드, $90): ..생략..\"</p>\n<p>고객: \"2024년 02월 25일에 디럭스 객실을 $160에 예약할 수 있나요?\"</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>에이전트: \"2024년 2월 25일에 109호 객실을 예약해드렸습니다. 이 객실은 명품 욕실이 있는 디럭스 객실이며, 160달러입니다. 필요한 것이 있으면 언제든지 알려주세요!\"</p>\n<p>고객: \"어떤 스파 시술이 가능한가요?\"</p>\n<p>에이전트: \"오늘 가능한 스파 시술 목록입니다: — 스웨디시 마사지: 긴장을 완화하고 이완을 촉진하는 전신 마사지. 가격: 80달러 — 페이셜: 피부를 재생하고 활기를 되찾는 깊은 클렌징 페이셜. 가격: 70달러 — 핫 스톤 마사지: 가열된 돌을 사용한 치료적인 마사지로 근육을 진정시키고 혈류를 향상시킵니다. 가격: 90달러 — 아로마테라피: 아로마 향기로 편안함과 웰빙을 높이는 섬세한 마사지. 가격: 85달러 — ….'간략히 하기 위해 나머지 제거됨'\"</p>\n<p>고객: \"핫 스톤 마사지를 예약할 수 있나요?\"</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>Agent: \"네, 오늘 당신을 위해 핫 스톤 마사지를 예약했어요. 이 치료 마사지는 가열된 돌을 사용하여 근육을 진정시키고 혈액 순환이 향상됩니다. 비용은 $90이에요. 더 필요한 게 있으면 언제든지 말해주세요!\"</p>\n<p>Customer: \"골프의 영업 시간은 어떻게 되나요?\"</p>\n<p>Agent: \"LJ 리조트의 골프 영업 시간은 다음과 같아요: 월요일부터 금요일까지: 오전 9시 — 오후 6시 토요일 및 일요일: 오전 7시 — 오후 7시\"</p>\n<p>Customer: \"해당 날에도 아침에는 골프 세션도 있나요?\"</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>에이전트: \"오늘 가능한 골프 세션을 확인해보니 아침 세션 하나가 있네요: 아침 티 타임: 아침에 멋진 전망과 함께 골프를 즐기세요. 비용: $80 이 아침 골프 세션을 예약해 드릴까요?\"</p>\n<p>고객: \"제가 $80에 그 날 골프 세션을 예약할 수 있을까요?\"</p>\n<p>에이전트: \"네, $80에 아침 골프 세션을 오늘 예약해 드렸습니다. 이 세션에서는 아침에 멋진 경치를 감상하며 골프를 즐길 수 있을 거예요. 더 필요한 사항이 있으시면 언제든지 말해 주세요!\"</p>\n<p>고객: \"제 예약의 총 비용이 얼마인가요?\"</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>에이전트: \"대화 기록을 기반으로 하면, 핫 스톤 마사지를 90달러에 예약하셨고, 아침 골프 세션을 80달러에 예약하셨습니다. 예약 총 비용은 90달러 + 80달러 = 170달러입니다.\"</p>\n<p>이것은 베드락 에이전트가 얼마나 강력한지 보여줍니다. 이것은 사람이 여러 시스템에 액세스해 고객과 직접 대면해야 하는 작업을 대체한 것입니다. 인공지능이 전체 프로세스를 자동화하는 데 사용되었습니다.</p>\n<p>이제 고객과 에이전트 간에 발생할 수있는 상호 작용을 살펴 보았으니, 주요 코드를 살펴 보겠습니다.</p>\n<h1>주요 코드 설명하기 👨‍💻</h1>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>알겠어요, 우리는 이 기본 예제를 실제로 본 것이고, 이제 TypeScript 및 CDK 코드를 살펴보겠습니다. 전체 솔루션은 여기에서 찾으실 수 있습니다.</p>\n<h2>Stateful Stack</h2>\n<p>먼저 상태 유지 스택부터 시작해봅시다. 여기서 먼저 에이전트 람다 함수를 생성합니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// create the lambda for the agent - this is the lambda that determines</span>\n<span class=\"hljs-comment\">// what the prompt looks like with regards to mapping to the schema</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">actionGroupAgentLambda</span>: nodeLambda.<span class=\"hljs-property\">NodejsFunction</span> =\n  <span class=\"hljs-keyword\">new</span> nodeLambda.<span class=\"hljs-title class_\">NodejsFunction</span>(<span class=\"hljs-variable language_\">this</span>, <span class=\"hljs-string\">'AgentLambda'</span>, {\n    <span class=\"hljs-attr\">functionName</span>: <span class=\"hljs-string\">'action-group-executor'</span>,\n    <span class=\"hljs-attr\">runtime</span>: lambda.<span class=\"hljs-property\">Runtime</span>.<span class=\"hljs-property\">NODEJS_20_X</span>,\n    <span class=\"hljs-attr\">entry</span>: path.<span class=\"hljs-title function_\">join</span>(\n      __dirname,\n      <span class=\"hljs-string\">'./src/adapters/primary/action-group-executor/action-group-executor.adapter.ts'</span>\n    ),\n    <span class=\"hljs-attr\">memorySize</span>: <span class=\"hljs-number\">1024</span>,\n    <span class=\"hljs-attr\">handler</span>: <span class=\"hljs-string\">'handler'</span>,\n    <span class=\"hljs-attr\">timeout</span>: cdk.<span class=\"hljs-property\">Duration</span>.<span class=\"hljs-title function_\">minutes</span>(<span class=\"hljs-number\">5</span>),\n    <span class=\"hljs-attr\">description</span>: <span class=\"hljs-string\">'action group lambda function'</span>,\n    <span class=\"hljs-attr\">architecture</span>: lambda.<span class=\"hljs-property\">Architecture</span>.<span class=\"hljs-property\">ARM_64</span>,\n    <span class=\"hljs-attr\">tracing</span>: lambda.<span class=\"hljs-property\">Tracing</span>.<span class=\"hljs-property\">ACTIVE</span>,\n    <span class=\"hljs-attr\">bundling</span>: {\n      <span class=\"hljs-attr\">minify</span>: <span class=\"hljs-literal\">true</span>,\n    },\n    <span class=\"hljs-attr\">environment</span>: {\n      ...lambdaConfig,\n    },\n  });\n</code></pre>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>다음은 아래에 표시된대로 우리의 Amazon Bedrock 에이전트를 생성합니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// bedrock 에이전트 생성</span>\n<span class=\"hljs-keyword\">const</span> agent = <span class=\"hljs-keyword\">new</span> bedrock.<span class=\"hljs-title class_\">Agent</span>(<span class=\"hljs-variable language_\">this</span>, <span class=\"hljs-string\">'BedrockAgent'</span>, {\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'에이전트'</span>,\n  <span class=\"hljs-attr\">description</span>: <span class=\"hljs-string\">'호텔, 스파 및 골프 예약을 위한 에이전트입니다.'</span>,\n  <span class=\"hljs-attr\">foundationModel</span>: bedrock.<span class=\"hljs-property\">BedrockFoundationModel</span>.<span class=\"hljs-property\">ANTHROPIC_CLAUDE_V2</span>,\n  <span class=\"hljs-attr\">instruction</span>:\n    <span class=\"hljs-string\">'고객이 호텔 객실, 스파 세션 및 골프 예약을 도와주셔서 감사하겠습니다. 그들에게 요일 및 예약 유형에 따라 특별 제공상품에 대해 알려주시고, 예약을 완료하기 전에 오픈 시간이나 가격을 안내해주시고, 또한 호텔 정책을 고려해주시기 바랍니다.'</span>,\n  <span class=\"hljs-attr\">idleSessionTTL</span>: cdk.<span class=\"hljs-property\">Duration</span>.<span class=\"hljs-title function_\">minutes</span>(<span class=\"hljs-number\">10</span>),\n  <span class=\"hljs-attr\">knowledgeBases</span>: [kb],\n  <span class=\"hljs-attr\">shouldPrepareAgent</span>: <span class=\"hljs-literal\">true</span>,\n  <span class=\"hljs-attr\">aliasName</span>: <span class=\"hljs-string\">'에이전트'</span>,\n});\n</code></pre>\n<p>위의 코드에서 보듯이, 에이전트에게 세션 지속 시간, Amazon Bedrock 지식 베이스에 대한 링크, FM 유형(Claud V2) 및 이 에이전트가 수행해야 할 작업에 대한 지시 사항과 같은 주요 속성들을 지정합니다.</p>\n<p>다음으로, 아래와 같이 Action 그룹을 생성합니다:</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 예약을 위한 동작 그룹을 추가합니다.</span>\n<span class=\"hljs-keyword\">new</span> bedrock.<span class=\"hljs-title class_\">AgentActionGroup</span>(<span class=\"hljs-variable language_\">this</span>, <span class=\"hljs-string\">'AgentActionGroup'</span>, {\n  <span class=\"hljs-attr\">actionGroupName</span>: <span class=\"hljs-string\">'agent-action-group'</span>,\n  <span class=\"hljs-attr\">description</span>: <span class=\"hljs-string\">'예약을 위한 동작 그룹'</span>,\n  <span class=\"hljs-attr\">agent</span>: agent,\n  <span class=\"hljs-attr\">apiSchema</span>: bedrock.<span class=\"hljs-property\">S3ApiSchema</span>.<span class=\"hljs-title function_\">fromAsset</span>(\n    path.<span class=\"hljs-title function_\">join</span>(__dirname, <span class=\"hljs-string\">'./schema/api-schema.json'</span>)\n  ),\n  <span class=\"hljs-attr\">actionGroupState</span>: <span class=\"hljs-string\">'ENABLED'</span>,\n  <span class=\"hljs-attr\">actionGroupExecutor</span>: actionGroupAgentLambda,\n  <span class=\"hljs-attr\">shouldPrepareAgent</span>: <span class=\"hljs-literal\">true</span>,\n});\n</code></pre>\n<p>우리는 에이전트가 할 수 있는 것을 상세히 설명하는 Open API 스키마와 동작에 대한 프록시로 호출되는 람다 함수를 제공한다는 것을 알 수 있습니다. 이제 Open API 사양이 어떻게 보이는지 살펴보겠습니다:</p>\n<pre><code class=\"hljs language-js\">{\n  <span class=\"hljs-string\">\"openapi\"</span>: <span class=\"hljs-string\">\"3.0.0\"</span>,\n  <span class=\"hljs-string\">\"info\"</span>: {\n    <span class=\"hljs-string\">\"title\"</span>: <span class=\"hljs-string\">\"LJ 리조트를 위한 호텔, 스파 및 골프 예약 API\"</span>,\n    <span class=\"hljs-string\">\"version\"</span>: <span class=\"hljs-string\">\"1.0.0\"</span>,\n    <span class=\"hljs-string\">\"description\"</span>: <span class=\"hljs-string\">\"고객의 호텔, 스파 및 골프 예약을 관리하기 위한 API입니다.\"</span>\n  },\n  <span class=\"hljs-string\">\"paths\"</span>: {\n    <span class=\"hljs-string\">\"/rooms\"</span>: {\n      <span class=\"hljs-string\">\"get\"</span>: {\n        <span class=\"hljs-string\">\"summary\"</span>: <span class=\"hljs-string\">\"이용 가능한 모든 객실 목록을 가져옵니다\"</span>,\n        <span class=\"hljs-string\">\"description\"</span>: <span class=\"hljs-string\">\"특정 날짜에 이용 가능한 모든 객실 목록을 가져옵니다\"</span>,\n        <span class=\"hljs-string\">\"operationId\"</span>: <span class=\"hljs-string\">\"getAllAvailableRooms\"</span>,\n        <span class=\"hljs-string\">\"responses\"</span>: {\n          <span class=\"hljs-string\">\"200\"</span>: {\n            <span class=\"hljs-string\">\"description\"</span>: <span class=\"hljs-string\">\"특정 날짜에 이용 가능한 모든 객실 목록을 가져옵니다\"</span>,\n            <span class=\"hljs-string\">\"content\"</span>: {\n              <span class=\"hljs-string\">\"application/json\"</span>: {\n                <span class=\"hljs-string\">\"schema\"</span>: {\n                  <span class=\"hljs-string\">\"type\"</span>: <span class=\"hljs-string\">\"array\"</span>,\n                  <span class=\"hljs-string\">\"items\"</span>: {\n                    <span class=\"hljs-string\">\"type\"</span>: <span class=\"hljs-string\">\"object\"</span>,\n                    <span class=\"hljs-string\">\"properties\"</span>: {\n                      <span class=\"hljs-string\">\"roomId\"</span>: {\n                        <span class=\"hljs-string\">\"type\"</span>: <span class=\"hljs-string\">\"string\"</span>,\n                        <span class=\"hljs-string\">\"description\"</span>: <span class=\"hljs-string\">\"객실의 고유 ID입니다.\"</span>\n                      },\n                      <span class=\"hljs-string\">\"roomType\"</span>: {\n                        <span class=\"hljs-string\">\"type\"</span>: <span class=\"hljs-string\">\"string\"</span>,\n                        <span class=\"hljs-string\">\"description\"</span>: <span class=\"hljs-string\">\"객실 유형입니다.\"</span>\n                      },\n                      <span class=\"hljs-string\">\"roomDescription\"</span>: {\n                        <span class=\"hljs-string\">\"type\"</span>: <span class=\"hljs-string\">\"string\"</span>,\n                        <span class=\"hljs-string\">\"description\"</span>: <span class=\"hljs-string\">\"객실 설명입니다.\"</span>\n                      },\n                      <span class=\"hljs-string\">\"date\"</span>: {\n                        <span class=\"hljs-string\">\"type\"</span>: <span class=\"hljs-string\">\"string\"</span>,\n                        <span class=\"hljs-string\">\"description\"</span>: <span class=\"hljs-string\">\"객실 예약 가능한 날짜입니다.\"</span>\n                      },\n                      <span class=\"hljs-string\">\"cost\"</span>: {\n                        <span class=\"hljs-string\">\"type\"</span>: <span class=\"hljs-string\">\"string\"</span>,\n                        <span class=\"hljs-string\">\"description\"</span>: <span class=\"hljs-string\">\"객실 비용(1박당)입니다.\"</span>\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      },\n      <span class=\"hljs-string\">\"post\"</span>: {\n        <span class=\"hljs-string\">\"summary\"</span>: <span class=\"hljs-string\">\"특정 날짜에 이용 가능한 객실을 예약합니다\"</span>,\n        <span class=\"hljs-string\">\"description\"</span>: <span class=\"hljs-string\">\"특정 날짜에 객실을 예약합니다\"</span>,\n        <span class=\"hljs-string\">\"operationId\"</span>: <span class=\"hljs-string\">\"bookRoom\"</span>,\n        <span class=\"hljs-string\">\"requestBody\"</span>: {\n          <span class=\"hljs-string\">\"required\"</span>: <span class=\"hljs-literal\">true</span>,\n          <span class=\"hljs-string\">\"content\"</span>: {\n            <span class=\"hljs-string\">\"application/json\"</span>: {\n              <span class=\"hljs-string\">\"schema\"</span>: {\n                <span class=\"hljs-string\">\"type\"</span>: <span class=\"hljs-string\">\"object\"</span>,\n                <span class=\"hljs-string\">\"properties\"</span>: {\n                  <span class=\"hljs-string\">\"roomId\"</span>: {\n                    <span class=\"hljs-string\">\"type\"</span>: <span class=\"hljs-string\">\"string\"</span>,\n                    <span class=\"hljs-string\">\"description\"</span>: <span class=\"hljs-string\">\"예약할 객실의 ID입니다\"</span>\n                  },\n                  <span class=\"hljs-string\">\"date\"</span>: {\n                    <span class=\"hljs-string\">\"type\"</span>: <span class=\"hljs-string\">\"string\"</span>,\n                    <span class=\"hljs-string\">\"description\"</span>: <span class=\"hljs-string\">\"객실 예약 날짜입니다\"</span>\n                  }\n                },\n                <span class=\"hljs-string\">\"required\"</span>: [<span class=\"hljs-string\">\"roomId\"</span>, <span class=\"hljs-string\">\"date\"</span>]\n              }\n            }\n          }\n        },\n        <span class=\"hljs-string\">\"responses\"</span>: {\n          <span class=\"hljs-string\">\"200\"</span>: {\n            <span class=\"hljs-string\">\"description\"</span>: <span class=\"hljs-string\">\"객실 예약 성공\"</span>\n          }\n        }\n      }\n    },\n    <span class=\"hljs-string\">\"/spa-sessions\"</span>: {\n      ...\n    },\n    <span class=\"hljs-string\">\"/golf-sessions\"</span>: {\n      ...\n    }\n  }\n}\n</code></pre>\n<p>모델이 수행해야 할 작업을 결정하는 중요한 부분은 설명, 경로, 메서드 및 작업 ID입니다. 예를 들어, 모든 호텔 객실을 나열하기 위해 사용하는 것은 다음과 같습니다:</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p><strong>Description</strong> - \"특정 날짜에 대한 모든 이용 가능한 객실 목록을 가져옵니다\".\n<strong>OperationId</strong> - \"getAllAvailableRooms\".\n<strong>Path</strong> - ‘/rooms’.\n<strong>Method</strong> - ‘GET’.</p>\n<p>우리의 람다 함수가 호출되면 해당 세부 정보를 활용하여 호출해야 하는 다른 시스템을 결정합니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> {\n  <span class=\"hljs-title class_\">MetricUnits</span>,\n  <span class=\"hljs-title class_\">Metrics</span>,\n  logMetrics,\n} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@aws-lambda-powertools/metrics'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Tracer</span>, captureLambdaHandler } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@aws-lambda-powertools/tracer'</span>;\n<span class=\"hljs-keyword\">import</span> { golfSessions, rooms, spaTreatments } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'stateful/src/data'</span>;\n\n<span class=\"hljs-keyword\">import</span> { injectLambdaContext } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@aws-lambda-powertools/logger'</span>;\n<span class=\"hljs-keyword\">import</span> middy <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@middy/core'</span>;\n<span class=\"hljs-keyword\">import</span> { logger } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@shared/index'</span>;\n\n<span class=\"hljs-keyword\">const</span> tracer = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Tracer</span>();\n<span class=\"hljs-keyword\">const</span> metrics = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Metrics</span>();\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> adapter = <span class=\"hljs-keyword\">async</span> ({\n  inputText,\n  apiPath,\n  httpMethod,\n  actionGroup,\n  messageVersion,\n  requestBody,\n  sessionAttributes,\n  promptSessionAttributes,\n}: <span class=\"hljs-title class_\">Event</span>): <span class=\"hljs-title class_\">Promise</span>&#x3C;<span class=\"hljs-title class_\">Response</span>> => {\n  <span class=\"hljs-keyword\">let</span> body;\n  <span class=\"hljs-keyword\">let</span> httpStatusCode = <span class=\"hljs-number\">200</span>;\n\n  <span class=\"hljs-keyword\">try</span> {\n    logger.<span class=\"hljs-title function_\">info</span>(\n      <span class=\"hljs-string\">`inputText: <span class=\"hljs-subst\">${inputText}</span>, apiPath: <span class=\"hljs-subst\">${apiPath}</span>, httpMethod: <span class=\"hljs-subst\">${httpMethod}</span>`</span>\n    );\n\n    <span class=\"hljs-comment\">// 참고: 실제로는 람다 FURLS 또는 다른 DB 또는 API/서비스를 호출할 것이지만,</span>\n    <span class=\"hljs-comment\">// 작동 방식을 보여주기 위해 기사용 가짜 스텁 데이터를 사용합니다.</span>\n    <span class=\"hljs-keyword\">switch</span> (apiPath) {\n      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'/rooms'</span>:\n        <span class=\"hljs-keyword\">if</span> (httpMethod === <span class=\"hljs-string\">'GET'</span>) {\n          body = rooms;\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (httpMethod === <span class=\"hljs-string\">'POST'</span>) {\n          body = rooms.<span class=\"hljs-title function_\">find</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">room</span>) =></span> room.<span class=\"hljs-property\">roomId</span> === <span class=\"hljs-string\">'109'</span>);\n        }\n        <span class=\"hljs-keyword\">break</span>;\n\n      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'/spa-sessions'</span>:\n        <span class=\"hljs-keyword\">if</span> (httpMethod === <span class=\"hljs-string\">'GET'</span>) {\n          body = spaTreatments;\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (httpMethod === <span class=\"hljs-string\">'POST'</span>) {\n          body = spaTreatments.<span class=\"hljs-title function_\">find</span>(\n            <span class=\"hljs-function\">(<span class=\"hljs-params\">treatment</span>) =></span> treatment.<span class=\"hljs-property\">treatmentId</span> === <span class=\"hljs-string\">'3'</span>\n          );\n        }\n        <span class=\"hljs-keyword\">break</span>;\n\n      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'/golf-sessions'</span>:\n        <span class=\"hljs-keyword\">if</span> (httpMethod === <span class=\"hljs-string\">'GET'</span>) {\n          body = golfSessions;\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (httpMethod === <span class=\"hljs-string\">'POST'</span>) {\n          body = golfSessions.<span class=\"hljs-title function_\">find</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">session</span>) =></span> session.<span class=\"hljs-property\">sessionId</span> === <span class=\"hljs-string\">'1'</span>);\n        }\n        <span class=\"hljs-keyword\">break</span>;\n\n      <span class=\"hljs-attr\">default</span>:\n        httpStatusCode = <span class=\"hljs-number\">500</span>;\n        body =\n          <span class=\"hljs-string\">'Sorry, I am unable to help you with that. Please try asking the question in a different way perhaps.'</span>;\n        <span class=\"hljs-keyword\">break</span>;\n    }\n\n    metrics.<span class=\"hljs-title function_\">addMetric</span>(<span class=\"hljs-string\">'SuccessfulActionGroupQuery'</span>, <span class=\"hljs-title class_\">MetricUnits</span>.<span class=\"hljs-property\">Count</span>, <span class=\"hljs-number\">1</span>);\n\n    <span class=\"hljs-keyword\">return</span> {\n      messageVersion,\n      <span class=\"hljs-attr\">response</span>: {\n        apiPath,\n        actionGroup,\n        httpMethod,\n        httpStatusCode,\n        sessionAttributes,\n        promptSessionAttributes,\n        <span class=\"hljs-attr\">responseBody</span>: {\n          <span class=\"hljs-string\">'application-json'</span>: {\n            <span class=\"hljs-attr\">body</span>: <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(body),\n          },\n        },\n      },\n    };\n  } <span class=\"hljs-keyword\">catch</span> (error) {\n    <span class=\"hljs-keyword\">let</span> errorMessage = <span class=\"hljs-string\">'Unknown error'</span>;\n    <span class=\"hljs-keyword\">if</span> (error <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Error</span>) errorMessage = error.<span class=\"hljs-property\">message</span>;\n    logger.<span class=\"hljs-title function_\">error</span>(errorMessage);\n\n    metrics.<span class=\"hljs-title function_\">addMetric</span>(<span class=\"hljs-string\">'ActionGroupQueryError'</span>, <span class=\"hljs-title class_\">MetricUnits</span>.<span class=\"hljs-property\">Count</span>, <span class=\"hljs-number\">1</span>);\n\n    <span class=\"hljs-keyword\">throw</span> error;\n  }\n};\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> handler = <span class=\"hljs-title function_\">middy</span>(adapter)\n  .<span class=\"hljs-title function_\">use</span>(<span class=\"hljs-title function_\">injectLambdaContext</span>(logger))\n  .<span class=\"hljs-title function_\">use</span>(<span class=\"hljs-title function_\">captureLambdaHandler</span>(tracer))\n  .<span class=\"hljs-title function_\">use</span>(<span class=\"hljs-title function_\">logMetrics</span>(metrics));\n</code></pre>\n<p>위의 예제에서는 다른 시스템을 호출하는 대신 반환된 데이터를 간단히 하드코딩했음을 볼 수 있습니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p><img src=\"/assets/img/2024-07-07-AutomatingtasksusingAmazonBedrockAgentsandAI_7.png\" alt=\"스테이트리스 스택\"></p>\n<p>이제 우리 에이전트를 쿼리하는 스테이트리스 스택을 살펴보겠습니다.</p>\n<h2>스테이트리스 스택</h2>\n<p>먼저 스트리밍이 설정된 쿼리 람다 함수를 생성합니다:</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 에이전트 쿼리를 위한 람다 함수를 생성합니다.</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">queryModelLambda</span>: nodeLambda.<span class=\"hljs-property\">NodejsFunction</span> =\n  <span class=\"hljs-keyword\">new</span> nodeLambda.<span class=\"hljs-title class_\">NodejsFunction</span>(<span class=\"hljs-variable language_\">this</span>, <span class=\"hljs-string\">'QueryModelLambda'</span>, {\n    <span class=\"hljs-attr\">functionName</span>: <span class=\"hljs-string\">'query-model-lambda'</span>,\n    <span class=\"hljs-attr\">runtime</span>: lambda.<span class=\"hljs-property\">Runtime</span>.<span class=\"hljs-property\">NODEJS_20_X</span>,\n    <span class=\"hljs-attr\">entry</span>: path.<span class=\"hljs-title function_\">join</span>(\n      __dirname,\n      <span class=\"hljs-string\">'./src/adapters/primary/query-model/query-model.adapter.ts'</span>\n    ),\n    <span class=\"hljs-attr\">memorySize</span>: <span class=\"hljs-number\">1024</span>,\n    <span class=\"hljs-attr\">handler</span>: <span class=\"hljs-string\">'handler'</span>,\n    <span class=\"hljs-attr\">timeout</span>: cdk.<span class=\"hljs-property\">Duration</span>.<span class=\"hljs-title function_\">minutes</span>(<span class=\"hljs-number\">3</span>),\n    <span class=\"hljs-attr\">description</span>: <span class=\"hljs-string\">'쿼리 모델 람다 함수'</span>,\n    <span class=\"hljs-attr\">architecture</span>: lambda.<span class=\"hljs-property\">Architecture</span>.<span class=\"hljs-property\">ARM_64</span>,\n    <span class=\"hljs-attr\">tracing</span>: lambda.<span class=\"hljs-property\">Tracing</span>.<span class=\"hljs-property\">ACTIVE</span>,\n    <span class=\"hljs-attr\">bundling</span>: {\n      <span class=\"hljs-attr\">minify</span>: <span class=\"hljs-literal\">true</span>,\n    },\n    <span class=\"hljs-attr\">environment</span>: {\n      <span class=\"hljs-attr\">AGENT_ID</span>: agentId,\n      <span class=\"hljs-attr\">AGENT_ALIAS_ID</span>: agentAliasId,\n      ...lambdaConfig,\n    },\n  });\n\n<span class=\"hljs-comment\">// 쿼리 람다에 대한 함수 URL을 스트림 응답으로 추가합니다.</span>\n<span class=\"hljs-keyword\">const</span> queryModelLambdaUrl = queryModelLambda.<span class=\"hljs-title function_\">addFunctionUrl</span>({\n  <span class=\"hljs-attr\">authType</span>: lambda.<span class=\"hljs-property\">FunctionUrlAuthType</span>.<span class=\"hljs-property\">NONE</span>,\n  <span class=\"hljs-attr\">invokeMode</span>: lambda.<span class=\"hljs-property\">InvokeMode</span>.<span class=\"hljs-property\">RESPONSE_STREAM</span>,\n  <span class=\"hljs-attr\">cors</span>: {\n    <span class=\"hljs-attr\">allowedOrigins</span>: [<span class=\"hljs-string\">'*'</span>],\n  },\n});\n</code></pre>\n<p>그런 다음, 아래와 같이 에이전트 호출 권한을 부여합니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 쿼리 람다 함수가 모델/KB/에이전트를 쿼리할 수 있도록 허용합니다.</span>\nqueryModelLambda.<span class=\"hljs-title function_\">addToRolePolicy</span>(\n  <span class=\"hljs-keyword\">new</span> iam.<span class=\"hljs-title class_\">PolicyStatement</span>({\n    <span class=\"hljs-attr\">actions</span>: [\n      <span class=\"hljs-string\">'bedrock:RetrieveAndGenerate'</span>,\n      <span class=\"hljs-string\">'bedrock:Retrieve'</span>,\n      <span class=\"hljs-string\">'bedrock:InvokeModel'</span>,\n      <span class=\"hljs-string\">'bedrock:InvokeAgent'</span>,\n    ],\n    <span class=\"hljs-attr\">resources</span>: [<span class=\"hljs-string\">'*'</span>],\n  })\n);\n</code></pre>\n<p>이제 사용자가 함수 URL을 통해 프롬프트를 제공하고 에이전트를 호출하는 Query Lambda 함수를 살펴보겠습니다:</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">MetricUnits</span>, <span class=\"hljs-title class_\">Metrics</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@aws-lambda-powertools/metrics'</span>;\r\n<span class=\"hljs-keyword\">import</span> {\r\n  <span class=\"hljs-title class_\">BedrockAgentRuntimeClient</span>,\r\n  <span class=\"hljs-title class_\">InvokeAgentCommand</span>,\r\n  <span class=\"hljs-title class_\">InvokeAgentRequest</span>,\r\n  <span class=\"hljs-title class_\">InvokeAgentResponse</span>,\r\n} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@aws-sdk/client-bedrock-agent-runtime'</span>;\r\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">ResponseStream</span>, streamifyResponse } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'lambda-stream'</span>;\r\n\r\n<span class=\"hljs-keyword\">import</span> { config } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@config'</span>;\r\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">ValidationError</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@errors/validation-error'</span>;\r\n<span class=\"hljs-keyword\">import</span> { logger } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@shared/index'</span>;\r\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">APIGatewayProxyEventV</span>2 } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'aws-lambda'</span>;\r\n\r\n<span class=\"hljs-keyword\">const</span> metrics = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Metrics</span>();\r\n<span class=\"hljs-keyword\">const</span> client = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BedrockAgentRuntimeClient</span>();\r\n\r\n<span class=\"hljs-keyword\">const</span> agentId = config.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">'agentId'</span>);\r\n<span class=\"hljs-keyword\">const</span> agentAliasId = config.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">'agentAliasId'</span>);\r\n\r\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">parseBase64</span>(<span class=\"hljs-params\">message: <span class=\"hljs-built_in\">Uint8Array</span></span>): string {\r\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Buffer</span>.<span class=\"hljs-title function_\">from</span>(message).<span class=\"hljs-title function_\">toString</span>(<span class=\"hljs-string\">'utf-8'</span>);\r\n}\r\n\r\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> queryModelAdapter = <span class=\"hljs-keyword\">async</span> (\r\n  { body }: <span class=\"hljs-title class_\">APIGatewayProxyEventV</span>2,\r\n  <span class=\"hljs-attr\">responseStream</span>: <span class=\"hljs-title class_\">ResponseStream</span>\r\n): <span class=\"hljs-title class_\">Promise</span>&#x3C;<span class=\"hljs-keyword\">void</span>> => {\r\n  <span class=\"hljs-keyword\">try</span> {\r\n    responseStream.<span class=\"hljs-title function_\">setContentType</span>(<span class=\"hljs-string\">'application/json'</span>);\r\n\r\n    <span class=\"hljs-keyword\">if</span> (!body) <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ValidationError</span>(<span class=\"hljs-string\">'no payload body'</span>);\r\n    <span class=\"hljs-keyword\">const</span> request = <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">parse</span>(body);\r\n\r\n    <span class=\"hljs-keyword\">const</span> { sessionAttributes, promptSessionAttributes, sessionId, prompt } =\r\n      request;\r\n\r\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">input</span>: <span class=\"hljs-title class_\">InvokeAgentRequest</span> = {\r\n      <span class=\"hljs-attr\">sessionState</span>: {\r\n        sessionAttributes,\r\n        promptSessionAttributes,\r\n      },\r\n      agentId,\r\n      agentAliasId,\r\n      sessionId,\r\n      <span class=\"hljs-attr\">inputText</span>: prompt,\r\n    };\r\n\r\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">command</span>: <span class=\"hljs-title class_\">InvokeAgentCommand</span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InvokeAgentCommand</span>(input);\r\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">response</span>: <span class=\"hljs-title class_\">InvokeAgentResponse</span> = <span class=\"hljs-keyword\">await</span> client.<span class=\"hljs-title function_\">send</span>(command);\r\n\r\n    <span class=\"hljs-keyword\">const</span> chunks = [];\r\n    <span class=\"hljs-keyword\">const</span> completion = response.<span class=\"hljs-property\">completion</span> || [];\r\n\r\n    <span class=\"hljs-keyword\">for</span> <span class=\"hljs-keyword\">await</span> (<span class=\"hljs-keyword\">const</span> chunk <span class=\"hljs-keyword\">of</span> completion) {\r\n      <span class=\"hljs-keyword\">if</span> (chunk.<span class=\"hljs-property\">chunk</span> &#x26;&#x26; chunk.<span class=\"hljs-property\">chunk</span>.<span class=\"hljs-property\">bytes</span>) {\r\n        <span class=\"hljs-keyword\">const</span> parsed = <span class=\"hljs-title function_\">parseBase64</span>(chunk.<span class=\"hljs-property\">chunk</span>.<span class=\"hljs-property\">bytes</span>);\r\n\r\n        chunks.<span class=\"hljs-title function_\">push</span>(parsed);\r\n      }\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">const</span> returnMessage = {\r\n      <span class=\"hljs-attr\">sessionId</span>: response.<span class=\"hljs-property\">sessionId</span>,\r\n      <span class=\"hljs-attr\">contentType</span>: response.<span class=\"hljs-property\">contentType</span>,\r\n      <span class=\"hljs-attr\">message</span>: chunks.<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">' '</span>),\r\n    };\r\n\r\n    metrics.<span class=\"hljs-title function_\">addMetric</span>(<span class=\"hljs-string\">'SuccessfulQueryModel'</span>, <span class=\"hljs-title class_\">MetricUnits</span>.<span class=\"hljs-property\">Count</span>, <span class=\"hljs-number\">1</span>);\r\n\r\n    <span class=\"hljs-comment\">// Note: In the example we are not streaming, we are using the FURL request timeout feature</span>\r\n    <span class=\"hljs-comment\">// but we could easily write the stream during the for loop if we wanted to</span>\r\n    responseStream.<span class=\"hljs-title function_\">write</span>(returnMessage);\r\n    responseStream.<span class=\"hljs-title function_\">end</span>();\r\n  } <span class=\"hljs-keyword\">catch</span> (error) {\r\n    <span class=\"hljs-keyword\">let</span> errorMessage = <span class=\"hljs-string\">'Unknown error'</span>;\r\n    <span class=\"hljs-keyword\">if</span> (error <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Error</span>) errorMessage = error.<span class=\"hljs-property\">message</span>;\r\n    logger.<span class=\"hljs-title function_\">error</span>(errorMessage);\r\n\r\n    metrics.<span class=\"hljs-title function_\">addMetric</span>(<span class=\"hljs-string\">'QueryModelError'</span>, <span class=\"hljs-title class_\">MetricUnits</span>.<span class=\"hljs-property\">Count</span>, <span class=\"hljs-number\">1</span>);\r\n\r\n    responseStream.<span class=\"hljs-title function_\">end</span>();\r\n    <span class=\"hljs-keyword\">throw</span> error;\r\n  }\r\n  responseStream.<span class=\"hljs-title function_\">end</span>();\r\n};\r\n\r\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> handler = <span class=\"hljs-title function_\">streamifyResponse</span>(queryModelAdapter);\n</code></pre>\n<p>위의 코드에서는 에이전트로부터 반환된 응답을 'chunks'로 스트림으로 전송하고 있습니다. 그러나 이 예제에서는 사용자에게 실시간으로 업데이트를 제공하지 않고 완료될 때까지 기다린 후 JSON 객체로 응답합니다. 이제 다음 섹션에서 이를 테스트해보겠습니다!</p>\n<h1>어플리케이션 테스트 🧪</h1>\n<h2>Postman을 통한 테스트하기</h2>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>당신은 postman/Bedrock Agents.postman_collection.json 파일을 사용하여 자신의 Lambda 함수 URL 정보로 테스트할 수 있습니다.</p>\n<p>다음과 같은 예시 JSON 페이로드를 사용하여 테스트할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\">{\n  <span class=\"hljs-string\">\"agentId\"</span>: <span class=\"hljs-string\">\"agentId\"</span>,\n  <span class=\"hljs-string\">\"agentAliasId\"</span>: <span class=\"hljs-string\">\"agentAliasId\"</span>,\n  <span class=\"hljs-string\">\"sessionId\"</span>: <span class=\"hljs-string\">\"1f6aa00e-e585-49aa-aa2d-16adb64857c6\"</span>,\n  <span class=\"hljs-string\">\"prompt\"</span>: <span class=\"hljs-string\">\"Can I please book a morning golf session on 2024-02-25\"</span>\n}\n</code></pre>\n<p>그리고 우리의 에이전트가 다음과 같이 응답하는 것을 확인할 수 있습니다:</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>우리 에이전트는 여러 가지 작업을 조정했습니다. 첫 번째로 그날 이용할 수 있는 골프 세션을 확인하는 것이었습니다.</p>\n<p>에이전트는 먼저 '/golf-sessions/'에 'GET'을 실행해야 한다고 결정했는데, 이렇게 하면 그 날 이용 가능한 모든 골프 세션이 반환됩니다.</p>\n<p>그런 다음 예약을 하기 위해 '/golf-sessions/'에 두 번째 작업 'POST'를 연이어 실행했습니다.</p>\n<p>여기서 대화형 AI의 힘과 자율 에이전트의 역할을 볼 수 있습니다. 고객을 지원하기 위해 여러 가지 작업을 조합했습니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p><img src=\"/assets/img/2024-07-07-AutomatingtasksusingAmazonBedrockAgentsandAI_8.png\" alt=\"이미지\"></p>\n<p>지금은 다른 시나리오에서도 이를 테스트할 수 있어요. 예를 들면 거래 확인, 스파 세션 예약 등등! 댓글에서 솔루션을 어떻게 찾았는지 알려주세요!</p>\n<h1>마무리 인사 👋🏽</h1>\n<p>이 글을 즐겨 읽어주셨기를 바랍니다. 만약 즐겁게 읽었다면 공유하고 피드백 주세요!</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>비슷한 콘텐츠를 위해 내 YouTube 채널을 구독해주세요!</p>\n<p><img src=\"/assets/img/2024-07-07-AutomatingtasksusingAmazonBedrockAgentsandAI_9.png\" alt=\"Automating tasks using Amazon Bedrock Agents and AI\"></p>\n<p>아래의 링크를 통해 연락하고 싶어요:</p>\n<p><a href=\"https://www.linkedin.com/in/lee-james-gilmore/\" rel=\"nofollow\" target=\"_blank\">LinkedIn - Lee James Gilmore</a>\n<a href=\"https://twitter.com/LeeJamesGilmore\" rel=\"nofollow\" target=\"_blank\">Twitter - Lee James Gilmore</a></p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>게시물을 즐겁게 보셨다면 더 많은 게시물/시리즈를 보려면 내 프로필 Lee James Gilmore를 팔로우해주세요! 또한 인사를 건네고 Hi를 말하는 것을 잊지 마세요 👋</p>\n<p>게시물 하단의 '박수' 기능도 사용해보세요. 만약 게시물을 즐겼다면 '박수'를 또 클릭할 수 있습니다!!</p>\n<h1>자기소개</h1>\n<p>\"안녕하세요, 저는 영국을 기반으로 하는 AWS 커뮤니티 빌더, 블로거, AWS 인증 클라우드 아키텍트이자 기술 및 아키텍처 부문 글로벌 팀장 Lee입니다. 현재는 City Electrical Factors(UK) &#x26; City Electric Supply(US)에서 근무 중이며, 지난 6년 동안 주로 AWS 상에서 full-stack JavaScript로 작업해 왔습니다.\"</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>저는 AWS를 사랑하는 서버리스 선구자라고 생각해요. 혁신, 소프트웨어 아키텍처, 그리고 기술에 대한 모든 것을 좋아해요.</p>\n<p>** 제공된 정보는 제 개인적인 견해이며, 해당 정보 사용에 대한 책임을 지지 않습니다. **</p>\n<p>아래 내용도 참고해보세요:</p>\n</body>\n</html>\n"},"__N_SSG":true}