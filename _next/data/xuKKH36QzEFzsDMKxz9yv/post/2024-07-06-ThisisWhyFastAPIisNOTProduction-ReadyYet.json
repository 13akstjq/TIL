{"pageProps":{"post":{"title":"아직 FastAPI를 프로덕션에 사용하면 안 되는 이유","description":"","date":"2024-07-06 10:24","slug":"2024-07-06-ThisisWhyFastAPIisNOTProduction-ReadyYet","content":"\n\n# 요약\n\n현대 웹 개발에서 효율적으로 종속 항목을 관리하는 것이 확장 가능하고 유지 관리 가능한 애플리케이션을 만드는 데 중요합니다. 의존성 주입(Dependency Injection, DI) 및 제어의 역전(Inversion of Control, IoC)은 이 요구를 해결하는 두 가지 디자인 원칙입니다. 본 문서에서는 DI와 IoC가 두 가지 인기 있는 Python 프레임워크인 FastAPI 및 PyNest에서 어떻게 구현되는지 알아봅니다. 우리는 두 프레임워크를 소개하고, DI에 대한 접근 방식을 자세히 살펴보며, 다음 프로젝트에 최적인 선택을 도와줄 종합적인 비교를 제공할 것입니다.\n\n/assets/img/2024-07-06-ThisisWhyFastAPIisNOTProduction-ReadyYet_0.png\n\n# FastAPI 소개\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nFastAPI은 표준 Python 타입 힌트를 기반으로 하는 Python 3.7+용 현대적이고 빠른 웹 프레임워크입니다. OpenAPI와 JSON Schema의 자동 생성 기능을 제공하여 API를 빠르고 효율적으로 만드는 데 매우 편리합니다. FastAPI의 DI(Dependency Injection) 접근 방식은 내장되어 있으며, Python의 타입 힌트를 활용하여 의존성을 원활하게 주입합니다.\n\n# FastAPI의 DI(Dependency Injection) 접근 방식\n\nFastAPI에서는 의존성 주입이 함수 시그니처 내의 Depends 키워드를 사용하여 처리됩니다. 이는 FastAPI에게 의존성 함수를 호출하도록 지시하고 해당 매개변수의 인수 값으로 결과를 사용하도록 합니다.\n\n## 예시: FastAPI 의존성 주입\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nfrom fastapi import Depends, FastAPI\n\napp = FastAPI()\n\n# 의존성 함수\nasync def common_parameters(q: str = None, skip: int = 0, limit: int = 100):\n    return {\"q\": q, \"skip\": skip, \"limit\": limit}\n\n# 해당 의존성을 사용하는 라우트\n@app.get(\"/items/\")\nasync def read_items(commons: dict = Depends(common_parameters)):\n    return commons\n```\n\n이 예에서 `common_parameters`은 `/items/` 라우트에 접근할 때마다 실행되는 의존성 함수입니다.\n\n## 의존성 주입에서의 중복성\n\nFastAPI는 각 라우트의 함수 수준에서 의존성이 주입되어야 합니다. 여러 라우트가 동일한 의존성을 필요로 하는 경우 각 라우트 핸들러 함수에 별도로 주입해야 합니다. 특히 많은 수의 라우트와 공유 의존성이 있는 응용 프로그램에서 반복적이고 장황한 코드로 이어질 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 예제\n\n```js\nfrom fastapi import Depends, FastAPI\n\napp = FastAPI()\n\n# 의존성\nclass Logger:\n    def __init__(self):\n        print(\"로거 시작\")\n        time.sleep(2)\n        print(f\"로거 시작됨 - {self}\")\n\n    def log(self, message):\n        print(f\"로깅 - {message}\")\n\n\n# 동일한 의존성을 주입하는 여러 라우트\n@app.get(\"/items/\")\nasync def read_items(logger: Annotated[Logger, Depends(Logger)]):\n    logger.log(\"아이템 목록\")\n    return {\"message\": \"아이템\"}\n\n@app.post(\"/items/\")\nasync def create_item(logger: Annotated[Logger, Depends(Logger)]):\n    logger.log(\"아이템 생성 중\")\n    return {\"message\": \"아이템 생성됨\"}\n```\n\n새로운 DB가 필요한 모든 새로운 라우트에서 우리는 DB를 명시적으로 주입해야 합니다. 약간 크게 확장해보면 모든 라우트가 공유된 로거, 공유된 설정, 그리고 DB 연결을 주입해야 한다고 상상해보면, 같은 코드를 계속 반복해서 작성해야 하는 상황이 생길 것입니다.\n\n# FastAPI에서 클래스 의존성 주입하기\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nFastAPI 루트에서 단일 및 여러 종속성을 주입하고 모든 호출마다 객체를 재설정하는 문제를 탐색해 보는 시나리오를 살펴봅시다.\n\n단일 종속성 주입 - 이 예시에서는 API 루트로 주입될 Logger 객체를 만듭니다.\n\n```python\nfrom fastapi import FastAPI, Depends\nimport time\n\napp = FastAPI()\n\nclass Logger:\n    def __init__(self):\n        print(\"Logger Starting\")\n        time.sleep(2)\n        print(f\"Logger Started at - {self}\")\n        self.params = {}\n\n    def log(self, message):\n        print(f\"Logging - {message}\")\n\n@app.get(\"/\")\ndef get(logger: Logger = Depends(Logger)):\n    logger.log(\"Endpoint hit\")\n    return \"Logger works\"\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n```\n\n출력:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n로그 출력 시작\n로그 출력 시작 위치 - <main.Logger object at 0x102f3ddf0>\n로그 - 엔드포인트 요청\n정보: 127.0.0.1:64670 - \"GET / HTTP/1.1\" 200 OK\n\n로그 출력 시작\n로그 출력 시작 위치 - <main.Logger object at 0x102f3dbe0>\n로그 - 엔드포인트 요청\n정보: 127.0.0.1:64670 - \"GET / HTTP/1.1\" 200 OK\n\n로그 출력 시작\n로그 출력 시작 위치 - <main.Logger object at 0x102f3dbb0>\n로그 - 엔드포인트 요청\n정보: 127.0.0.1:64670 - \"GET / HTTP/1.1\" 200 OK\n\n\n위의 결과를 살펴보겠습니다. 애플리케이션의 루트 경로에 접속하려고 할 때, 로거 객체가 초기화되고 \"0x102f3ddf0\" 위치로 설정되었음을 볼 수 있습니다. 그런 다음 두 번째로 동일한 경로에 액세스하면 로거 객체가 다시 초기화됩니다. 이 때는 다른 메모리 위치에 설정됩니다. 루트 경로를 호출할 때마다 로거 초기화에 2초의 대기 시간이 소요됩니다.\n\n그렇다면 로거에 의존하는 서비스가 필요한 경우 어떻게 될까요?\n\nfrom fastapi import FastAPI, Depends\nimport time\nimport random\n\nclass Logger:\n    def __init__(self):\n        print(\"로그 출력 시작\")\n        time.sleep(2)\n        print(f\"로그 출력 시작 위치 - {self}\")\n\n    def log(self, message):\n        print(f\"로그 - {message}\")\n\nclass Service:\n    def __init__(self, logger: Logger = Depends(Logger)):\n        self.logger = logger\n        print(\"서비스 시작\")\n        time.sleep(1)\n        print(f\"서비스 시작 위치 - {self}\")\n\n    def 실행(self):\n        self.logger.log(\"어떤 작업을 수행 중\")\n        return f\"작업 수행, {random.random()}\"\n\napp = FastAPI()\n\n@app.get(\"/\")\ndef get(service: Service = Depends(Service)):\n    return f\"{service.실행()}\"\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n당연히요! FastAPI 및 IOC 컨테이너에서의 지원 부족은 이 엔드포인트를 호출할 때마다 이미 초기화된 객체들을 초기화하기 위해 3초의 지연 시간을 지불해야 한다는 주된 이유입니다. 이 패턴은 진정한 안티-패턴이며, FastAPI의 약점을 드러낼 수도 있습니다.\n\n이 문제를 해결하려고 수십 시간을 낭비한 후, FastAPI 자체가 그러한 기능을 제공하지 못하며, 새롭고 더 통합적인 접근이 필요하다는 것을 이해했습니다. 그래서 저는 PyNest를 만들게 되었습니다. 이는 의존성 주입과 모듈성에 중점을 둔 Python 메타-프레임워크입니다.\n\n# PyNest: 모듈식 DI 접근 방식\n\nPyNest의 DI 시스템은 반복적인 코드를 줄이고 대규모 애플리케이션에 특히 유용한 개발 프로세스를 간소화하는 데에 디자인되었습니다. PyNest는 의존성이 한 번에 한 번씩 주입되는 구조화된 DI 시스템을 제공하며, 대체로 컨트롤러 클래스 수준에서 이루어집니다. 이 구조는 한 번 의존성이 컨트롤러에 주입되면 더 이상 주입이 필요하지 않고 코드가 재사용되며 DRY 원칙을 준수할 수 있음을 의미합니다. 이 구조를 통해 한 번 의존성이 컨트롤러에 주입되면 더 이상의 주입이 필요 없이 해당 컨트롤러의 모든 경로 메서드에서 사용될 수 있으므로 코드베이스를 간소화할 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n/assets/img/2024-07-06-ThisisWhyFastAPIisNOTProduction-ReadyYet_1.png\n\n# 한 번 주입하고 여러 번 사용하기\n\nPyNest의 모듈화된 아키텍처를 사용하면 컨트롤러 클래스의 생성자에 종속성을 주입할 수 있어서 매번 모든 라우트에 종속성을 반복해서 주입할 필요 없이 모든 라우트에서 이 종속성을 사용할 수 있습니다.\n\n예시 —\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nfrom nest.core import Injectable, Controller, Get, Post\n\n@Injectable\nclass Logger:\n    def __init__(self):\n        print(\"Logger Starting\")\n        time.sleep(2)\n        print(f\"Logger Started at - {self}\")\n\n    def log(self, message):\n        print(f\"Logging - {message}\")\n\n\n@Controller(\"items\")\nclass ItemsController:\n\n  # Inject Once\n  def __init__(self, logger: Logger):\n      self.logger = logger\n\n\n  # Use Many\n  @Get(\"/\")\n  async def read_items(self):\n      self.logger.log(\"list of items\")\n      return {\"message\": \"Items\"}\n\n  @Post(\"/{item}\")\n  async def create_item(self, item: str):\n      self.logger.log(\"creating item\")\n      return {\"message\": f\"Item created - {item}\"}\r\n```\n\n이 모듈화된 접근 방식을 통해 컨트롤러 생성자에 필요한 만큼의 의존성을 주입하고 이러한 의존성을 클래스 메서드에서 액세스할 수 있습니다. 이 결과로 코드가 훨씬 더 깔끔해지며 코드를 다시 작성하거나 복잡하게 만들 필요가 없어집니다.\n\n# 싱글턴 패턴의 힘을 받아들이세요\n\n이전에 논의한 바와 같이, FastAPI의 DI 매커니즘의 가장 큰 단점은 종속성을 관리하기 위해 싱글턴 패턴을 사용하지 않는 것입니다. 우리는 종속성이 모든 들어오는 요청마다 초기화되어야 한다는 것을 관찰했습니다.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nPyNest에서는 현역에서 \"injector\" 라이브러리를 활용합니다. 이 라이브러리는 현대적인 Python 애플리케이션에서 종속성을 관리하기 위한 패키지입니다. injector은 싱글톤 패턴과 멀티 바인딩을 지원합니다. 클래스가 Injectable로 표시되어 종속성으로 등록되면, injector는 해당 클래스의 인스턴스를 생성하고 그 참조를 저장합니다. 이 injectable 객체에 대한 모든 호출은 injector를 통해 이루어지며, injectable 객체의 싱글톤 인스턴스를 반환합니다.\n\n## 코드로 살펴보기\n\n먼저, PyNest에서 모든 관련 import문을 정리해 봅시다\n\n```python\nimport logging\nimport os\n\nfrom nest.core import (\n    Controller,\n    Delete,\n    Get,\n    Injectable,\n    Module,\n    Post,\n    Put,\n    PyNestFactory,\n)\nimport time\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음으로 주입하려는 두 개의 제공자와 로직 레이어를 포함하는 주요 서비스를 선언할 것입니다.\n\n```js\n# 구성 제공자\n@Injectable()\nclass ConfigService:\n    def __init__(self):\n        time.sleep(2)\n        print(f\"ConfigService 시작 - {self}\")\n        self.config = os.environ\n\n    def get(self, key: str):\n        return self.config.get(key)\n\n# 로거 제공자\n@Injectable()\nclass Logger:\n    def __init__(self, config_service: ConfigService):\n        time.sleep(2)\n        print(f\"로거 시작 - {self}\")\n        self.config_service = config_service\n        self.log = logging.getLogger(__name__)\n\n# 주요 서비스\n@Injectable()\nclass ItemService:\n    def __init__(self, logger: Logger):\n        time.sleep(2)\n        print(f\"ItemService 시작 - {self}\")\n        self.logger = logger\n        self.items = [{\"item_name\": \"Foo\"}, {\"item_name\": \"Bar\"}, {\"item_name\": \"Baz\"}]\n\n    def get(self):\n        self.logger.log.info(\"엔드포인트 호출됨\")\n        return self.items\n\n    def post(self, item: dict):\n        self.items.append(item)\n        return self.items\n\n    def put(self, item: dict):\n        self.items.append(item)\n        return self.items\n\n    def delete(self, item: dict):\n        self.items.remove(item)\n        return self.items\n```\n\n이제 Controller를 생성하고 서비스에 주입합니다 —\n\n```js\n@Controller(\"items\")\nclass ItemController:\n    def __init__(self, item_service: ItemService):\n        print(\"ItemController 시작 - {self}\")\n        self.item_service = item_service\n\n    @Get(\"/\")\n    def get(self):\n        return self.item_service.get()\n\n    @Post(\"/\")\n    def post(self, item: dict):\n        return self.item_service.post(item)\n\n    @Put(\"/\")\n    def put(self, item: dict):\n        return self.item_service.put(item)\n\n    @Delete(\"/\")\n    def delete(self, item: dict):\n        return self.item_service.delete(item)\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n대단해요, 거의 다 왔어요. 이제 앱 모듈을 정의하고 애플리케이션을 실행해 봅시다 -\n\n```js\n@Module(\n    controllers=[ItemController],\n    providers=[Logger],\n)\nclass AppModule:\n    pass\n\n\napp = PyNestFactory.create(AppModule)\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app.http_server, host=\"0.0.0.0\", port=8623)\n```\n\n결과 —\n\n```js\nConfigService starting - <__main__.ConfigService object at 0x10444d580>\nLogger Starting - <__main__.Logger object at 0x10444daf0>\nItemService starting - <__main__.ItemService object at 0x10444d190>\n\nINFO:     Started server process [64770]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\nINFO:     Uvicorn running on http://0.0.0.0:8623 (Press CTRL+C to quit)\n\n\nINFO:     127.0.0.1:63810 - \"GET /items/ HTTP/1.1\" 200 OK\nINFO:     127.0.0.1:63824 - \"PUT /items/ HTTP/1.1\" 200 OK\nINFO:     127.0.0.1:63840 - \"POST /items/ HTTP/1.1\" 200 OK\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n와우! 정말 멋지네요. 우리는 Injectables 객체를 한 번만 초기화하고, 그 이후로는 컨테이너가 해당 객체들의 인스턴스를 관리한다는 것을 알 수 있어요.\n\n/assets/img/2024-07-06-ThisisWhyFastAPIisNOTProduction-ReadyYet_2.png\n\n# PyNest DI 매니페스트\n\n## 주입 가능한 객체\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Injectable-to-Injectable Injection: Injectable 객체는 다른 Injectable 객체를 주입할 수 있어서 일관성 있고 통합된 종속성 계층을 만들 수 있습니다.\n\n## Controllers\n\n- Controller Injection: 컨트롤러는 Injectable 객체를 주입할 수 있어서 필요에 따라 서비스와 리포지토리에 책임을 위임할 수 있습니다.\n\n## Dependency Graph\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 비순환 의존성 그래프: 의존성은 유향 비순환 그래프 (DAG)를 형성해야 합니다. 순환 의존성이 없어야 하며, 이를 통해 처리 가능한 의존성 해결 및 런타임 오류나 무한 루프를 방지할 수 있습니다.\n\n## 의존성 해결과 관리\n\n- 애플리케이션 초기화 과정에서 IoC 컨테이너는 모든 의존성을 해결하고, 아직 등록되지 않은 개체의 인스턴스를 생성하며, 이러한 인스턴스를 관리하여 주입하는 위치에서 제공될 수 있도록 합니다.\n\n## 제공자(Providers) 내보내기\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 모듈은 제공자를 내보낼 수 있으며, 이는 응용 프로그램 내의 다른 모듈에서 사용되거나 주입될 수 있습니다.\n\n## 모듈 간 제공자 주입\n\n- 다른 모듈에서 제공자를 주입하려면 해당 원하는 제공자를 포함하는 모듈을 명시적으로 가져와야 합니다.\n\n## 인스턴스 참조 및 재사용\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 애플리케이션이 삽입된 공급자를 호출하면 이미 초기화된 인스턴스를 참조하여 재사용합니다. 이렇게 함으로써 필요 없는 공급자 인스턴스의 생성을 방지하고 필요할 때 싱글톤과 같은 패턴을 준수합니다.\n\n# 결론: DI에 있어 PyNest가 선호되는 이유\n\nPyNest의 DI 접근 방식은 코드 조직화와 유지 보수 측면에서 명확한 장점을 제공하며, 특히 모듈화 및 반복을 피하는 것이 중요한 대규모 프로젝트에 적합합니다. 응용 프로그램 구조 내에서 더 높은 수준에서 의존성을 주입할 수 있도록 함으로써, PyNest는 보다 DRY(반복하지 마라) 코드베이스를 용이하게 만들어 줌으로써 오류 가능성을 줄이고 리팩터링 및 테스트 프로세스를 간소화합니다.\n\n반면에 FastAPI의 DI 시스템은 각자의 강점을 갖고 있지만, 함수 수준에서의 주입 요구는 불필요하고 중복적인 요소를 도입할 수 있으며, 웹 애플리케이션이 복잡성을 더해감에 따라 유지 보수 및 확장성에서 오히려 역효과를 낼 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 자원\n\n- 비동기 마법: PyNest와 SQLAlchemy 2.0이 파이썬 앱 성능을 25% 향상시킵니다.\n- FastAPI 이상: PyNest를 이용한 2024년 파이썬 마이크로서비스의 진화\n- 의존성 주입 101 - PyNest를 이용한 파이썬 웹 앱의 의존성 주입 단순화\n- PyNest PyPI: https://pypi.org/project/pynest-api\n- 공식 문서: https://pythonnest.github.io/PyNest/\n- GitHub 저장소: https://github.com/PythonNest/PyNest\n\n# 간단하게 설명하기 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 계속하시기 전에:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 글쓴이를 클랩하고 팔로우해주세요! 👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문하기: CoFeed | Differ\n- 더 많은 콘텐츠: PlainEnglish.io","ogImage":{"url":"/assets/img/2024-07-06-ThisisWhyFastAPIisNOTProduction-ReadyYet_0.png"},"coverImage":"/assets/img/2024-07-06-ThisisWhyFastAPIisNOTProduction-ReadyYet_0.png","tag":["Tech"],"readingTime":17},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<h1>요약</h1>\n<p>현대 웹 개발에서 효율적으로 종속 항목을 관리하는 것이 확장 가능하고 유지 관리 가능한 애플리케이션을 만드는 데 중요합니다. 의존성 주입(Dependency Injection, DI) 및 제어의 역전(Inversion of Control, IoC)은 이 요구를 해결하는 두 가지 디자인 원칙입니다. 본 문서에서는 DI와 IoC가 두 가지 인기 있는 Python 프레임워크인 FastAPI 및 PyNest에서 어떻게 구현되는지 알아봅니다. 우리는 두 프레임워크를 소개하고, DI에 대한 접근 방식을 자세히 살펴보며, 다음 프로젝트에 최적인 선택을 도와줄 종합적인 비교를 제공할 것입니다.</p>\n<p>/assets/img/2024-07-06-ThisisWhyFastAPIisNOTProduction-ReadyYet_0.png</p>\n<h1>FastAPI 소개</h1>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>FastAPI은 표준 Python 타입 힌트를 기반으로 하는 Python 3.7+용 현대적이고 빠른 웹 프레임워크입니다. OpenAPI와 JSON Schema의 자동 생성 기능을 제공하여 API를 빠르고 효율적으로 만드는 데 매우 편리합니다. FastAPI의 DI(Dependency Injection) 접근 방식은 내장되어 있으며, Python의 타입 힌트를 활용하여 의존성을 원활하게 주입합니다.</p>\n<h1>FastAPI의 DI(Dependency Injection) 접근 방식</h1>\n<p>FastAPI에서는 의존성 주입이 함수 시그니처 내의 Depends 키워드를 사용하여 처리됩니다. 이는 FastAPI에게 의존성 함수를 호출하도록 지시하고 해당 매개변수의 인수 값으로 결과를 사용하도록 합니다.</p>\n<h2>예시: FastAPI 의존성 주입</h2>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">from</span> fastapi <span class=\"hljs-keyword\">import</span> Depends, FastAPI\n\napp = FastAPI()\n\n<span class=\"hljs-comment\"># 의존성 함수</span>\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">common_parameters</span>(<span class=\"hljs-params\">q: <span class=\"hljs-built_in\">str</span> = <span class=\"hljs-literal\">None</span>, skip: <span class=\"hljs-built_in\">int</span> = <span class=\"hljs-number\">0</span>, limit: <span class=\"hljs-built_in\">int</span> = <span class=\"hljs-number\">100</span></span>):\n    <span class=\"hljs-keyword\">return</span> {<span class=\"hljs-string\">\"q\"</span>: q, <span class=\"hljs-string\">\"skip\"</span>: skip, <span class=\"hljs-string\">\"limit\"</span>: limit}\n\n<span class=\"hljs-comment\"># 해당 의존성을 사용하는 라우트</span>\n<span class=\"hljs-meta\">@app.get(<span class=\"hljs-params\"><span class=\"hljs-string\">\"/items/\"</span></span>)</span>\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">read_items</span>(<span class=\"hljs-params\">commons: <span class=\"hljs-built_in\">dict</span> = Depends(<span class=\"hljs-params\">common_parameters</span>)</span>):\n    <span class=\"hljs-keyword\">return</span> commons\n</code></pre>\n<p>이 예에서 <code>common_parameters</code>은 <code>/items/</code> 라우트에 접근할 때마다 실행되는 의존성 함수입니다.</p>\n<h2>의존성 주입에서의 중복성</h2>\n<p>FastAPI는 각 라우트의 함수 수준에서 의존성이 주입되어야 합니다. 여러 라우트가 동일한 의존성을 필요로 하는 경우 각 라우트 핸들러 함수에 별도로 주입해야 합니다. 특히 많은 수의 라우트와 공유 의존성이 있는 응용 프로그램에서 반복적이고 장황한 코드로 이어질 수 있습니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h2>예제</h2>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">from</span> fastapi <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Depends</span>, <span class=\"hljs-title class_\">FastAPI</span>\n\napp = <span class=\"hljs-title class_\">FastAPI</span>()\n\n# 의존성\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Logger</span>:\n    def <span class=\"hljs-title function_\">__init__</span>(self):\n        <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"로거 시작\"</span>)\n        time.<span class=\"hljs-title function_\">sleep</span>(<span class=\"hljs-number\">2</span>)\n        <span class=\"hljs-title function_\">print</span>(f<span class=\"hljs-string\">\"로거 시작됨 - {self}\"</span>)\n\n    def <span class=\"hljs-title function_\">log</span>(self, message):\n        <span class=\"hljs-title function_\">print</span>(f<span class=\"hljs-string\">\"로깅 - {message}\"</span>)\n\n\n# 동일한 의존성을 주입하는 여러 라우트\n@app.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">\"/items/\"</span>)\n<span class=\"hljs-keyword\">async</span> def <span class=\"hljs-title function_\">read_items</span>(<span class=\"hljs-attr\">logger</span>: <span class=\"hljs-title class_\">Annotated</span>[<span class=\"hljs-title class_\">Logger</span>, <span class=\"hljs-title class_\">Depends</span>(<span class=\"hljs-title class_\">Logger</span>)]):\n    logger.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"아이템 목록\"</span>)\n    <span class=\"hljs-keyword\">return</span> {<span class=\"hljs-string\">\"message\"</span>: <span class=\"hljs-string\">\"아이템\"</span>}\n\n@app.<span class=\"hljs-title function_\">post</span>(<span class=\"hljs-string\">\"/items/\"</span>)\n<span class=\"hljs-keyword\">async</span> def <span class=\"hljs-title function_\">create_item</span>(<span class=\"hljs-attr\">logger</span>: <span class=\"hljs-title class_\">Annotated</span>[<span class=\"hljs-title class_\">Logger</span>, <span class=\"hljs-title class_\">Depends</span>(<span class=\"hljs-title class_\">Logger</span>)]):\n    logger.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"아이템 생성 중\"</span>)\n    <span class=\"hljs-keyword\">return</span> {<span class=\"hljs-string\">\"message\"</span>: <span class=\"hljs-string\">\"아이템 생성됨\"</span>}\n</code></pre>\n<p>새로운 DB가 필요한 모든 새로운 라우트에서 우리는 DB를 명시적으로 주입해야 합니다. 약간 크게 확장해보면 모든 라우트가 공유된 로거, 공유된 설정, 그리고 DB 연결을 주입해야 한다고 상상해보면, 같은 코드를 계속 반복해서 작성해야 하는 상황이 생길 것입니다.</p>\n<h1>FastAPI에서 클래스 의존성 주입하기</h1>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>FastAPI 루트에서 단일 및 여러 종속성을 주입하고 모든 호출마다 객체를 재설정하는 문제를 탐색해 보는 시나리오를 살펴봅시다.</p>\n<p>단일 종속성 주입 - 이 예시에서는 API 루트로 주입될 Logger 객체를 만듭니다.</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">from</span> fastapi <span class=\"hljs-keyword\">import</span> FastAPI, Depends\n<span class=\"hljs-keyword\">import</span> time\n\napp = FastAPI()\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Logger</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self</span>):\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Logger Starting\"</span>)\n        time.sleep(<span class=\"hljs-number\">2</span>)\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f\"Logger Started at - <span class=\"hljs-subst\">{self}</span>\"</span>)\n        self.params = {}\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">log</span>(<span class=\"hljs-params\">self, message</span>):\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f\"Logging - <span class=\"hljs-subst\">{message}</span>\"</span>)\n\n<span class=\"hljs-meta\">@app.get(<span class=\"hljs-params\"><span class=\"hljs-string\">\"/\"</span></span>)</span>\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">get</span>(<span class=\"hljs-params\">logger: Logger = Depends(<span class=\"hljs-params\">Logger</span>)</span>):\n    logger.log(<span class=\"hljs-string\">\"Endpoint hit\"</span>)\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"Logger works\"</span>\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">\"__main__\"</span>:\n    <span class=\"hljs-keyword\">import</span> uvicorn\n    uvicorn.run(app, host=<span class=\"hljs-string\">\"0.0.0.0\"</span>, port=<span class=\"hljs-number\">8000</span>)\n</code></pre>\n<p>출력:</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>로그 출력 시작\n로그 출력 시작 위치 - &#x3C;main.Logger object at 0x102f3ddf0>\n로그 - 엔드포인트 요청\n정보: 127.0.0.1:64670 - \"GET / HTTP/1.1\" 200 OK</p>\n<p>로그 출력 시작\n로그 출력 시작 위치 - &#x3C;main.Logger object at 0x102f3dbe0>\n로그 - 엔드포인트 요청\n정보: 127.0.0.1:64670 - \"GET / HTTP/1.1\" 200 OK</p>\n<p>로그 출력 시작\n로그 출력 시작 위치 - &#x3C;main.Logger object at 0x102f3dbb0>\n로그 - 엔드포인트 요청\n정보: 127.0.0.1:64670 - \"GET / HTTP/1.1\" 200 OK</p>\n<p>위의 결과를 살펴보겠습니다. 애플리케이션의 루트 경로에 접속하려고 할 때, 로거 객체가 초기화되고 \"0x102f3ddf0\" 위치로 설정되었음을 볼 수 있습니다. 그런 다음 두 번째로 동일한 경로에 액세스하면 로거 객체가 다시 초기화됩니다. 이 때는 다른 메모리 위치에 설정됩니다. 루트 경로를 호출할 때마다 로거 초기화에 2초의 대기 시간이 소요됩니다.</p>\n<p>그렇다면 로거에 의존하는 서비스가 필요한 경우 어떻게 될까요?</p>\n<p>from fastapi import FastAPI, Depends\nimport time\nimport random</p>\n<p>class Logger:\ndef <strong>init</strong>(self):\nprint(\"로그 출력 시작\")\ntime.sleep(2)\nprint(f\"로그 출력 시작 위치 - {self}\")</p>\n<pre><code>def log(self, message):\n    print(f\"로그 - {message}\")\n</code></pre>\n<p>class Service:\ndef <strong>init</strong>(self, logger: Logger = Depends(Logger)):\nself.logger = logger\nprint(\"서비스 시작\")\ntime.sleep(1)\nprint(f\"서비스 시작 위치 - {self}\")</p>\n<pre><code>def 실행(self):\n    self.logger.log(\"어떤 작업을 수행 중\")\n    return f\"작업 수행, {random.random()}\"\n</code></pre>\n<p>app = FastAPI()</p>\n<p>@app.get(\"/\")\ndef get(service: Service = Depends(Service)):\nreturn f\"{service.실행()}\"</p>\n<p>if <strong>name</strong> == \"<strong>main</strong>\":\nimport uvicorn\nuvicorn.run(app, host=\"0.0.0.0\", port=8000)</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>당연히요! FastAPI 및 IOC 컨테이너에서의 지원 부족은 이 엔드포인트를 호출할 때마다 이미 초기화된 객체들을 초기화하기 위해 3초의 지연 시간을 지불해야 한다는 주된 이유입니다. 이 패턴은 진정한 안티-패턴이며, FastAPI의 약점을 드러낼 수도 있습니다.</p>\n<p>이 문제를 해결하려고 수십 시간을 낭비한 후, FastAPI 자체가 그러한 기능을 제공하지 못하며, 새롭고 더 통합적인 접근이 필요하다는 것을 이해했습니다. 그래서 저는 PyNest를 만들게 되었습니다. 이는 의존성 주입과 모듈성에 중점을 둔 Python 메타-프레임워크입니다.</p>\n<h1>PyNest: 모듈식 DI 접근 방식</h1>\n<p>PyNest의 DI 시스템은 반복적인 코드를 줄이고 대규모 애플리케이션에 특히 유용한 개발 프로세스를 간소화하는 데에 디자인되었습니다. PyNest는 의존성이 한 번에 한 번씩 주입되는 구조화된 DI 시스템을 제공하며, 대체로 컨트롤러 클래스 수준에서 이루어집니다. 이 구조는 한 번 의존성이 컨트롤러에 주입되면 더 이상 주입이 필요하지 않고 코드가 재사용되며 DRY 원칙을 준수할 수 있음을 의미합니다. 이 구조를 통해 한 번 의존성이 컨트롤러에 주입되면 더 이상의 주입이 필요 없이 해당 컨트롤러의 모든 경로 메서드에서 사용될 수 있으므로 코드베이스를 간소화할 수 있습니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>/assets/img/2024-07-06-ThisisWhyFastAPIisNOTProduction-ReadyYet_1.png</p>\n<h1>한 번 주입하고 여러 번 사용하기</h1>\n<p>PyNest의 모듈화된 아키텍처를 사용하면 컨트롤러 클래스의 생성자에 종속성을 주입할 수 있어서 매번 모든 라우트에 종속성을 반복해서 주입할 필요 없이 모든 라우트에서 이 종속성을 사용할 수 있습니다.</p>\n<p>예시 —</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">from</span> nest.core <span class=\"hljs-keyword\">import</span> Injectable, Controller, Get, Post\n\n<span class=\"hljs-meta\">@Injectable</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Logger</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self</span>):\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Logger Starting\"</span>)\n        time.sleep(<span class=\"hljs-number\">2</span>)\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f\"Logger Started at - <span class=\"hljs-subst\">{self}</span>\"</span>)\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">log</span>(<span class=\"hljs-params\">self, message</span>):\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f\"Logging - <span class=\"hljs-subst\">{message}</span>\"</span>)\n\n\n<span class=\"hljs-meta\">@Controller(<span class=\"hljs-params\"><span class=\"hljs-string\">\"items\"</span></span>)</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ItemsController</span>:\n\n  <span class=\"hljs-comment\"># Inject Once</span>\n  <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, logger: Logger</span>):\n      self.logger = logger\n\n\n  <span class=\"hljs-comment\"># Use Many</span>\n<span class=\"hljs-meta\">  @Get(<span class=\"hljs-params\"><span class=\"hljs-string\">\"/\"</span></span>)</span>\n  <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">read_items</span>(<span class=\"hljs-params\">self</span>):\n      self.logger.log(<span class=\"hljs-string\">\"list of items\"</span>)\n      <span class=\"hljs-keyword\">return</span> {<span class=\"hljs-string\">\"message\"</span>: <span class=\"hljs-string\">\"Items\"</span>}\n\n<span class=\"hljs-meta\">  @Post(<span class=\"hljs-params\"><span class=\"hljs-string\">\"/{item}\"</span></span>)</span>\n  <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">create_item</span>(<span class=\"hljs-params\">self, item: <span class=\"hljs-built_in\">str</span></span>):\n      self.logger.log(<span class=\"hljs-string\">\"creating item\"</span>)\n      <span class=\"hljs-keyword\">return</span> {<span class=\"hljs-string\">\"message\"</span>: <span class=\"hljs-string\">f\"Item created - <span class=\"hljs-subst\">{item}</span>\"</span>}\n</code></pre>\n<p>이 모듈화된 접근 방식을 통해 컨트롤러 생성자에 필요한 만큼의 의존성을 주입하고 이러한 의존성을 클래스 메서드에서 액세스할 수 있습니다. 이 결과로 코드가 훨씬 더 깔끔해지며 코드를 다시 작성하거나 복잡하게 만들 필요가 없어집니다.</p>\n<h1>싱글턴 패턴의 힘을 받아들이세요</h1>\n<p>이전에 논의한 바와 같이, FastAPI의 DI 매커니즘의 가장 큰 단점은 종속성을 관리하기 위해 싱글턴 패턴을 사용하지 않는 것입니다. 우리는 종속성이 모든 들어오는 요청마다 초기화되어야 한다는 것을 관찰했습니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>PyNest에서는 현역에서 \"injector\" 라이브러리를 활용합니다. 이 라이브러리는 현대적인 Python 애플리케이션에서 종속성을 관리하기 위한 패키지입니다. injector은 싱글톤 패턴과 멀티 바인딩을 지원합니다. 클래스가 Injectable로 표시되어 종속성으로 등록되면, injector는 해당 클래스의 인스턴스를 생성하고 그 참조를 저장합니다. 이 injectable 객체에 대한 모든 호출은 injector를 통해 이루어지며, injectable 객체의 싱글톤 인스턴스를 반환합니다.</p>\n<h2>코드로 살펴보기</h2>\n<p>먼저, PyNest에서 모든 관련 import문을 정리해 봅시다</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">import</span> logging\n<span class=\"hljs-keyword\">import</span> os\n\n<span class=\"hljs-keyword\">from</span> nest.core <span class=\"hljs-keyword\">import</span> (\n    Controller,\n    Delete,\n    Get,\n    Injectable,\n    Module,\n    Post,\n    Put,\n    PyNestFactory,\n)\n<span class=\"hljs-keyword\">import</span> time\n</code></pre>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>다음으로 주입하려는 두 개의 제공자와 로직 레이어를 포함하는 주요 서비스를 선언할 것입니다.</p>\n<pre><code class=\"hljs language-js\"># 구성 제공자\n@<span class=\"hljs-title class_\">Injectable</span>()\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ConfigService</span>:\n    def <span class=\"hljs-title function_\">__init__</span>(self):\n        time.<span class=\"hljs-title function_\">sleep</span>(<span class=\"hljs-number\">2</span>)\n        <span class=\"hljs-title function_\">print</span>(f<span class=\"hljs-string\">\"ConfigService 시작 - {self}\"</span>)\n        self.<span class=\"hljs-property\">config</span> = os.<span class=\"hljs-property\">environ</span>\n\n    def <span class=\"hljs-title function_\">get</span>(self, <span class=\"hljs-attr\">key</span>: str):\n        <span class=\"hljs-keyword\">return</span> self.<span class=\"hljs-property\">config</span>.<span class=\"hljs-title function_\">get</span>(key)\n\n# 로거 제공자\n@<span class=\"hljs-title class_\">Injectable</span>()\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Logger</span>:\n    def <span class=\"hljs-title function_\">__init__</span>(self, <span class=\"hljs-attr\">config_service</span>: <span class=\"hljs-title class_\">ConfigService</span>):\n        time.<span class=\"hljs-title function_\">sleep</span>(<span class=\"hljs-number\">2</span>)\n        <span class=\"hljs-title function_\">print</span>(f<span class=\"hljs-string\">\"로거 시작 - {self}\"</span>)\n        self.<span class=\"hljs-property\">config_service</span> = config_service\n        self.<span class=\"hljs-property\">log</span> = logging.<span class=\"hljs-title function_\">getLogger</span>(__name__)\n\n# 주요 서비스\n@<span class=\"hljs-title class_\">Injectable</span>()\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ItemService</span>:\n    def <span class=\"hljs-title function_\">__init__</span>(self, <span class=\"hljs-attr\">logger</span>: <span class=\"hljs-title class_\">Logger</span>):\n        time.<span class=\"hljs-title function_\">sleep</span>(<span class=\"hljs-number\">2</span>)\n        <span class=\"hljs-title function_\">print</span>(f<span class=\"hljs-string\">\"ItemService 시작 - {self}\"</span>)\n        self.<span class=\"hljs-property\">logger</span> = logger\n        self.<span class=\"hljs-property\">items</span> = [{<span class=\"hljs-string\">\"item_name\"</span>: <span class=\"hljs-string\">\"Foo\"</span>}, {<span class=\"hljs-string\">\"item_name\"</span>: <span class=\"hljs-string\">\"Bar\"</span>}, {<span class=\"hljs-string\">\"item_name\"</span>: <span class=\"hljs-string\">\"Baz\"</span>}]\n\n    def <span class=\"hljs-title function_\">get</span>(self):\n        self.<span class=\"hljs-property\">logger</span>.<span class=\"hljs-property\">log</span>.<span class=\"hljs-title function_\">info</span>(<span class=\"hljs-string\">\"엔드포인트 호출됨\"</span>)\n        <span class=\"hljs-keyword\">return</span> self.<span class=\"hljs-property\">items</span>\n\n    def <span class=\"hljs-title function_\">post</span>(self, <span class=\"hljs-attr\">item</span>: dict):\n        self.<span class=\"hljs-property\">items</span>.<span class=\"hljs-title function_\">append</span>(item)\n        <span class=\"hljs-keyword\">return</span> self.<span class=\"hljs-property\">items</span>\n\n    def <span class=\"hljs-title function_\">put</span>(self, <span class=\"hljs-attr\">item</span>: dict):\n        self.<span class=\"hljs-property\">items</span>.<span class=\"hljs-title function_\">append</span>(item)\n        <span class=\"hljs-keyword\">return</span> self.<span class=\"hljs-property\">items</span>\n\n    def <span class=\"hljs-title function_\">delete</span>(self, <span class=\"hljs-attr\">item</span>: dict):\n        self.<span class=\"hljs-property\">items</span>.<span class=\"hljs-title function_\">remove</span>(item)\n        <span class=\"hljs-keyword\">return</span> self.<span class=\"hljs-property\">items</span>\n</code></pre>\n<p>이제 Controller를 생성하고 서비스에 주입합니다 —</p>\n<pre><code class=\"hljs language-js\">@<span class=\"hljs-title class_\">Controller</span>(<span class=\"hljs-string\">\"items\"</span>)\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ItemController</span>:\n    def <span class=\"hljs-title function_\">__init__</span>(self, <span class=\"hljs-attr\">item_service</span>: <span class=\"hljs-title class_\">ItemService</span>):\n        <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"ItemController 시작 - {self}\"</span>)\n        self.<span class=\"hljs-property\">item_service</span> = item_service\n\n    @<span class=\"hljs-title class_\">Get</span>(<span class=\"hljs-string\">\"/\"</span>)\n    def <span class=\"hljs-title function_\">get</span>(self):\n        <span class=\"hljs-keyword\">return</span> self.<span class=\"hljs-property\">item_service</span>.<span class=\"hljs-title function_\">get</span>()\n\n    @<span class=\"hljs-title class_\">Post</span>(<span class=\"hljs-string\">\"/\"</span>)\n    def <span class=\"hljs-title function_\">post</span>(self, <span class=\"hljs-attr\">item</span>: dict):\n        <span class=\"hljs-keyword\">return</span> self.<span class=\"hljs-property\">item_service</span>.<span class=\"hljs-title function_\">post</span>(item)\n\n    @<span class=\"hljs-title class_\">Put</span>(<span class=\"hljs-string\">\"/\"</span>)\n    def <span class=\"hljs-title function_\">put</span>(self, <span class=\"hljs-attr\">item</span>: dict):\n        <span class=\"hljs-keyword\">return</span> self.<span class=\"hljs-property\">item_service</span>.<span class=\"hljs-title function_\">put</span>(item)\n\n    @<span class=\"hljs-title class_\">Delete</span>(<span class=\"hljs-string\">\"/\"</span>)\n    def <span class=\"hljs-title function_\">delete</span>(self, <span class=\"hljs-attr\">item</span>: dict):\n        <span class=\"hljs-keyword\">return</span> self.<span class=\"hljs-property\">item_service</span>.<span class=\"hljs-title function_\">delete</span>(item)\n</code></pre>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>대단해요, 거의 다 왔어요. 이제 앱 모듈을 정의하고 애플리케이션을 실행해 봅시다 -</p>\n<pre><code class=\"hljs language-js\">@<span class=\"hljs-title class_\">Module</span>(\n    controllers=[<span class=\"hljs-title class_\">ItemController</span>],\n    providers=[<span class=\"hljs-title class_\">Logger</span>],\n)\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AppModule</span>:\n    pass\n\n\napp = <span class=\"hljs-title class_\">PyNestFactory</span>.<span class=\"hljs-title function_\">create</span>(<span class=\"hljs-title class_\">AppModule</span>)\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">\"__main__\"</span>:\n    <span class=\"hljs-keyword\">import</span> uvicorn\n\n    uvicorn.<span class=\"hljs-title function_\">run</span>(app.<span class=\"hljs-property\">http_server</span>, host=<span class=\"hljs-string\">\"0.0.0.0\"</span>, port=<span class=\"hljs-number\">8623</span>)\n</code></pre>\n<p>결과 —</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">ConfigService</span> starting - &#x3C;__main__.ConfigService object at 0x10444d580>\nLogger Starting - &#x3C;__main__.Logger object at 0x10444daf0>\nItemService starting - &#x3C;__main__.ItemService object at 0x10444d190>\n\nINFO:     Started server process [64770]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\nINFO:     Uvicorn running on http://0.0.0.0:8623 (Press CTRL+C to quit)\n\n\nINFO:     127.0.0.1:63810 - \"GET /items/ HTTP/1.1\" 200 OK\nINFO:     127.0.0.1:63824 - \"PUT /items/ HTTP/1.1\" 200 OK\nINFO:     127.0.0.1:63840 - \"POST /items/ HTTP/1.1\" 200 OK\n</code></pre>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>와우! 정말 멋지네요. 우리는 Injectables 객체를 한 번만 초기화하고, 그 이후로는 컨테이너가 해당 객체들의 인스턴스를 관리한다는 것을 알 수 있어요.</p>\n<p>/assets/img/2024-07-06-ThisisWhyFastAPIisNOTProduction-ReadyYet_2.png</p>\n<h1>PyNest DI 매니페스트</h1>\n<h2>주입 가능한 객체</h2>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>Injectable-to-Injectable Injection: Injectable 객체는 다른 Injectable 객체를 주입할 수 있어서 일관성 있고 통합된 종속성 계층을 만들 수 있습니다.</li>\n</ul>\n<h2>Controllers</h2>\n<ul>\n<li>Controller Injection: 컨트롤러는 Injectable 객체를 주입할 수 있어서 필요에 따라 서비스와 리포지토리에 책임을 위임할 수 있습니다.</li>\n</ul>\n<h2>Dependency Graph</h2>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>비순환 의존성 그래프: 의존성은 유향 비순환 그래프 (DAG)를 형성해야 합니다. 순환 의존성이 없어야 하며, 이를 통해 처리 가능한 의존성 해결 및 런타임 오류나 무한 루프를 방지할 수 있습니다.</li>\n</ul>\n<h2>의존성 해결과 관리</h2>\n<ul>\n<li>애플리케이션 초기화 과정에서 IoC 컨테이너는 모든 의존성을 해결하고, 아직 등록되지 않은 개체의 인스턴스를 생성하며, 이러한 인스턴스를 관리하여 주입하는 위치에서 제공될 수 있도록 합니다.</li>\n</ul>\n<h2>제공자(Providers) 내보내기</h2>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>모듈은 제공자를 내보낼 수 있으며, 이는 응용 프로그램 내의 다른 모듈에서 사용되거나 주입될 수 있습니다.</li>\n</ul>\n<h2>모듈 간 제공자 주입</h2>\n<ul>\n<li>다른 모듈에서 제공자를 주입하려면 해당 원하는 제공자를 포함하는 모듈을 명시적으로 가져와야 합니다.</li>\n</ul>\n<h2>인스턴스 참조 및 재사용</h2>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>애플리케이션이 삽입된 공급자를 호출하면 이미 초기화된 인스턴스를 참조하여 재사용합니다. 이렇게 함으로써 필요 없는 공급자 인스턴스의 생성을 방지하고 필요할 때 싱글톤과 같은 패턴을 준수합니다.</li>\n</ul>\n<h1>결론: DI에 있어 PyNest가 선호되는 이유</h1>\n<p>PyNest의 DI 접근 방식은 코드 조직화와 유지 보수 측면에서 명확한 장점을 제공하며, 특히 모듈화 및 반복을 피하는 것이 중요한 대규모 프로젝트에 적합합니다. 응용 프로그램 구조 내에서 더 높은 수준에서 의존성을 주입할 수 있도록 함으로써, PyNest는 보다 DRY(반복하지 마라) 코드베이스를 용이하게 만들어 줌으로써 오류 가능성을 줄이고 리팩터링 및 테스트 프로세스를 간소화합니다.</p>\n<p>반면에 FastAPI의 DI 시스템은 각자의 강점을 갖고 있지만, 함수 수준에서의 주입 요구는 불필요하고 중복적인 요소를 도입할 수 있으며, 웹 애플리케이션이 복잡성을 더해감에 따라 유지 보수 및 확장성에서 오히려 역효과를 낼 수 있습니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h1>자원</h1>\n<ul>\n<li>비동기 마법: PyNest와 SQLAlchemy 2.0이 파이썬 앱 성능을 25% 향상시킵니다.</li>\n<li>FastAPI 이상: PyNest를 이용한 2024년 파이썬 마이크로서비스의 진화</li>\n<li>의존성 주입 101 - PyNest를 이용한 파이썬 웹 앱의 의존성 주입 단순화</li>\n<li>PyNest PyPI: <a href=\"https://pypi.org/project/pynest-api\" rel=\"nofollow\" target=\"_blank\">https://pypi.org/project/pynest-api</a></li>\n<li>공식 문서: <a href=\"https://pythonnest.github.io/PyNest/\" rel=\"nofollow\" target=\"_blank\">https://pythonnest.github.io/PyNest/</a></li>\n<li>GitHub 저장소: <a href=\"https://github.com/PythonNest/PyNest\" rel=\"nofollow\" target=\"_blank\">https://github.com/PythonNest/PyNest</a></li>\n</ul>\n<h1>간단하게 설명하기 🚀</h1>\n<p>In Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 계속하시기 전에:</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>글쓴이를 클랩하고 팔로우해주세요! 👏️️</li>\n<li>팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터</li>\n<li>다른 플랫폼 방문하기: CoFeed | Differ</li>\n<li>더 많은 콘텐츠: PlainEnglish.io</li>\n</ul>\n</body>\n</html>\n"},"__N_SSG":true}