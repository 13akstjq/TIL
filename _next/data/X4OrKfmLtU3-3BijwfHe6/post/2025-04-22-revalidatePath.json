{"pageProps":{"post":{"title":"Next.js 15에서 revalidatePath를 활용해 데이터 재검증하는 방법","description":"","date":"2025-04-22 12:45","slug":"2025-04-22-revalidatePath","content":"\n\n# revalidatePath 정리해보기\n\nrevalidatePath는 특정 경로에 대해 캐시된 데이터를 즉시 갱신(무효화)할 수 있게 해주는 함수예요.\n\n> 참고하면 좋은 점:\nrevalidatePath는 해당 경로를 다시 방문할 때 캐시를 무효화시켜줘요. 즉, 함수 호출 후 바로 캐시가 갈아엎어지는 게 아니라, 다음에 그 경로에 접근할 때 무효화가 적용된다는 뜻이죠. 동적 경로 세그먼트로 호출해도 한꺼번에 여러 경로가 즉시 무효화되는 게 아니라 '다음 방문 시점'부터 적용돼요.\n\n현재는 서버 액션 내에서 revalidatePath를 쓰면, 클라이언트 사이드 라우터 캐시에 있는 모든 경로가 무효화되는 임시 동작을 하고 있어요. 이 부분은 향후 개선되어서 특정 경로에만 적용되도록 바뀔 거랍니다.\n\n한편 서버 사이드 라우트 캐시에서는 특정 경로만 무효화하는 걸로 동작해요.\n\n---\n\n## 파라미터\n\n(여기에 파라미터 관련 내용이 따라올 예정인데, 현재는 정보가 없네요.)\n\n---\n\n### 팁 하나 덧붙이자면요\n\n이 기능은 예를 들어 게시글을 수정했을 때 수정된 내용이 바로 캐시에 반영되도록 강제로 갱신하고 싶을 때 많이 쓰이죠. 단, 재방문 시에 무효화가 되니까 페이지를 사용자에게 리다이렉트하거나, 클라이언트에서 다시 방문하게 만들어야 캐시 갱신 효과를 바로 볼 수 있다는 점 잊지 마세요! \n\n무효화를 즉시 반영해주는 것과는 조금 다르니까, 상황에 따라 적절히 활용해보세요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```ts\nrevalidatePath(path: string, type?: 'page' | 'layout'): void;\n```\n\n- **path**: 다시 유효성 검사를 하고 싶은 데이터와 연결된 파일 시스템 경로 문자열입니다. 예를 들어, `/product/[slug]/page`처럼 동적 세그먼트를 포함할 수 있고, 혹은 `/product/123` 같은 실제 라우트 경로를 쓸 수도 있어요. 1024자 미만이어야 하고, 대소문자를 구분합니다.\n- **type**: (선택적) `'page'` 또는 `'layout'` 문자열로, 재유효성 검사를 할 경로 유형을 정하는 거예요. 경로에 동적 세그먼트가 있다면 반드시 이 파라미터를 넣어야 합니다. 반대로, 동적 페이지 경로의 실제 라우트 예시(`/product/1`)를 줄 때는 넣지 않아야 합니다.\n\n## 반환값\n\n`revalidatePath` 함수는 값을 반환하지 않습니다. 즉, `void` 타입이에요.\n\n---\n\n### 한 마디 더!\n\n`revalidatePath`는 Next.js에서 ISR(Incremental Static Regeneration)을 쓸 때, 특정 경로나 레이아웃을 수동으로 재검증하고 싶을 때 유용합니다. 페이지를 변경했을 때 빌드 전체를 다시 할 필요 없이 부분적으로 빠르게 리프레시하는 느낌이라 생각하면 편해요.\n\n예를 들어, 어떤 상품 디테일 페이지 내용을 업데이트했을 때 해당 상품 페이지의 캐시만 재검증해서 최신 상태로 만들 수 있죠. 동적 경로가 섞인 경우에는 `type`을 꼭 신경 써서 넣어줘야 원하는 경로가 제대로 갱신됩니다.\n\n개발 중에는 이 함수를 잘 활용하면 페이지 리빌드 시간을 크게 단축시킬 수 있으니 꼭 기억해두세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 예시\n\n### 특정 URL 재검증하기\n\n```js\nimport { revalidatePath } from 'next/cache'\n\nrevalidatePath('/blog/post-1')\n```\n\n위 코드는 `/blog/post-1` 경로를 다음 페이지 방문 시 재검증하도록 설정하는 방법이에요. 즉, 사용자가 해당 URL에 접속하면 콘텐츠가 최신 상태인지 Next.js가 다시 확인해서 캐시를 갱신하게 되는 거죠.\n\n추가로, revalidatePath는 아주 유용한 함수인데요, 페이지 빌드 후에 데이터가 바뀌었을 때 해당 페이지를 다시 유효성 검사해서 최신 내용을 보여주고 싶을 때 자주 사용됩니다. 예를 들어, 블로그 글을 수정하는 CMS 관리 페이지에서 이 함수를 호출하면 변경된 글이 사용자에게 바로 반영되게 할 수 있어요.\n\n그리고 한 가지 팁을 더 드리자면, revalidatePath 외에도 revalidateTag 같은 함수도 있는데, 여러 페이지에서 공통으로 쓰이는 데이터(예: 헤더, 푸터 정보)를 태그 단위로 재검증할 때 편리합니다. 상황에 맞게 잘 활용해보세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 페이지 경로 재검증 (Revalidating A Page Path)\n\n```js\nimport { revalidatePath } from 'next/cache'\n\nrevalidatePath('/blog/[slug]', 'page')\n// 또는 라우트 그룹을 사용할 때\nrevalidatePath('/(main)/blog/[slug]', 'page')\n```\n\n이 코드는 특정 페이지 파일과 일치하는 URL이 다음에 방문할 때 다시 검증하도록 만들어줍니다. 쉽게 말해, 해당 경로에 있는 페이지가 업데이트되었을 때, 다음 방문부터 최신 내용이 반영되도록 하는 기능이에요.\n\n단, 중요한 점은 이 함수가 딱 지정한 경로에만 유효하다는 거예요. 예를 들어 `/blog/[slug]`를 재검증한다고 해서 `/blog/[slug]/[author]` 같은 하위 경로까지 자동으로 재검증되지 않습니다. 필요할 경우 하위 경로도 별도로 재검증해줘야 해요.\n\n---\n\n### 재검증에 대해 한마디 더!\n\n이 기능은 SSR(서버 사이드 렌더링)이나 ISR(Incremental Static Regeneration)을 활용하는 프로젝트에서 자주 쓰입니다. 예를 들어, 블로그 글을 수정했을 때, 방문자가 새로 페이지를 요청하면 최신 버전을 보여주고 싶을 때 유용하죠.\n\n하지만 너무 많은 경로에 대해 자주 재검증을 걸면 서버 부하가 늘 수 있으니, 꼭 필요한 경로에만 적절히 활용하는 게 좋습니다.\n\n---\n\n### 재검증 레이아웃 경로 (Revalidating A Layout Path)\n\n(다음 섹션에서 계속 이어서 작성할게요!)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서 제공하는 revalidatePath 함수에 대해 간단히 이야기해볼게요. 이 함수는 특정 경로와 그 경로에 연결된 레이아웃을 기준으로 페이지를 다시 검증(리빌드)하는 작업을 해줍니다.\n\n```js\nimport { revalidatePath } from 'next/cache'\n\nrevalidatePath('/blog/[slug]', 'layout')\n// 또는 경로 그룹 사용 시\nrevalidatePath('/(main)/post/[slug]', 'layout')\n```\n\n위 코드는 `/blog/[slug]`에 해당하는 레이아웃 파일을 기준으로, 해당 경로뿐만 아니라 그 경로 하위에 있는 다른 페이지들도 다음 방문 시 자동으로 다시 리빌드되게 해줍니다. 예를 들어 `/blog/[slug]/[another]` 같은 하위 경로도 포함되겠죠.\n\n### 모든 데이터를 재검증 하는 방법\n\n```js\nimport { revalidatePath } from 'next/cache'\n\nrevalidatePath('/', 'layout')\n```\n\n위처럼 루트 경로(`/`)에 대해 revalidatePath를 호출하면, 루트 레이아웃 아래에 속한 모든 페이지들이 다음 방문 시 다시 검증되어 최신 상태로 업데이트됩니다.\n\n---\n\n### 추가 팁!\n\n- `revalidatePath`가 유용한 시점: 서버에서 어떤 데이터를 업데이트했는데 클라이언트 페이지에서 바로 최신 데이터가 반영되길 원할 때 써보세요.\n- \"layout\" 옵션은 선택사항인데, 해당 경로의 레이아웃이 바뀌었을 때 그 변경 사항을 반영하기 위해 추가하는 경우가 많습니다.\n- Next.js의 ISR(Incremental Static Regeneration)과 비슷한 개념이지만, 이 함수로 좀 더 세밀하게 특정 경로를 재검증할 수 있어서 편리해요.\n\n실제로 프로젝트에서 데이터 변경이 잦거나 특정 유저 액션 후 페이지를 새로 고침 시 최신 데이터를 보여주고 싶다면 적극 활용해보시길 바랍니다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n클라이언트 사이드 라우터 캐시를 지우고, 다음에 페이지를 방문할 때 데이터 캐시를 다시 검증하는 작업에 대해 이야기해볼게요.\n\n### 서버 액션(Server Action)\n\n```js\n'use server'\n\nimport { revalidatePath } from 'next/cache'\n\nexport default async function submit() {\n  await submitForm()\n  revalidatePath('/')\n}\n```\n\n위 코드는 간단하게 설명하면, 폼 제출 같은 서버 액션이 일어난 후에 특정 경로('/')의 캐시를 강제로 다시 검증(revalidate)하도록 해요. 이렇게 하면 클라이언트 쪽에 저장된 라우터 캐시를 초기화하고, 데이터가 최신 상태인지 확인할 수 있어서 사용자에게 더 정확한 정보를 제공할 수 있답니다.\n\n**조금 더 풀어서 설명하자면**, `revalidatePath()` 함수는 Next.js의 서버 캐시를 특정 경로 기준으로 새로 고치는 역할을 해요. 이 덕분에, 예를 들어 데이터가 업데이트된 페이지를 구독하고 있는 사용자가, 다음 번 방문 때 반드시 최신 내용이 보여지도록 할 수 있죠.\n\n### Route Handler\n\n아래는 Route Handler에서 비슷한 맥락으로 쓰이는 코드의 예시입니다.\n\n```js\nimport { revalidatePath } from 'next/cache'\n\nexport async function POST(request) {\n  const data = await request.json()\n  // 데이터 저장 로직 등 처리\n  await saveData(data)\n\n  // '/' 경로 캐시 재검증\n  revalidatePath('/')\n\n  return new Response('Success', { status: 200 })\n}\n```\n\nRoute Handler에서도 POST 요청 처리 후에 동일하게 `revalidatePath`를 호출해서 특정 경로의 캐시를 새로고침할 수 있어요.\n\n---\n\n> **TIP!**\n>\n> Next.js 13부터 새로운 데이터 패칭 방식과 서버 액션이 도입되면서, 이런 재검증 로직이 더 간편해졌어요. 특히 ISR(Incremental Static Regeneration)을 활용해 캐시를 누적하고, 필요한 순간에만 갱신하는 전략 덕분에 성능과 UX가 훨씬 좋아졌답니다. 적절한 타이밍에 `revalidatePath`를 호출하는 것이 핵심이에요!\n\n필요하면 댓글이나 DM으로 질문 주세요. 더 친절하게 설명해드릴게요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n요즘 Next.js에서 ISR(Incremental Static Regeneration)을 활용할 일이 많아지면서, 특정 경로를 서버 사이드에서 동적으로 다시 빌드(재검증) 하는 방법에 대한 궁금증이 많아졌어요. 위에 코드가 그런 상황에서 유용한 예시라서 좀 쉽게 풀어서 설명해 드릴게요.\n\n```js\nimport { revalidatePath } from 'next/cache'\nimport type { NextRequest } from 'next/server'\n\nexport async function GET(request: NextRequest) {\n  // URL 쿼리에서 'path' 파라미터를 받아온다\n  const path = request.nextUrl.searchParams.get('path')\n\n  if (path) {\n    // 해당 path를 Next.js에서 다시 빌드하도록 요청\n    revalidatePath(path)\n    return Response.json({ revalidated: true, now: Date.now() })\n  }\n\n  // path 파라미터가 없으면 에러 메시지 반환\n  return Response.json({\n    revalidated: false,\n    now: Date.now(),\n    message: 'Missing path to revalidate',\n  })\n}\n```\n\n### 코드 설명\n\n- `revalidatePath`: Next.js 13에서 도입된 function으로, ISR에서 특정 경로를 다시 빌드하도록 시그널을 넣어줍니다.\n- 이 API는 `GET` 요청을 받아서, 쿼리스트링에 `?path=/some-route` 형식으로 재검증할 경로를 전달하면 동작해요.\n- 만약 `path`가 없으면 재검증을 할 수 없으니, 메시지를 되돌려주는 안전장치가 있죠.\n\n---\n\n### 여기서 더 알아두시면 좋은 점!\n\n- `revalidatePath`는 내부적으로 Next.js의 캐시를 무효화해서, 다음에 해당 경로로 접근할 때 최신 버전의 페이지가 보여지게 만들어 줍니다.\n- 재검증 요청을 API route처럼 만들어 두면, 관리자 페이지에서 \"컨텐츠 업데이트\" 버튼을 눌러 해당 페이지를 동적으로 최신화할 수 있어요.\n- 주의할 점은, `path` 값은 Next.js 안에서 존재하는 페이지 경로여야 제대로 동작합니다. 없는 경로를 넣으면 에러는 안 나지만, 의미가 없겠죠.\n\n---\n\n### 보너스: 서버 컴포넌트라면 이런 식으로 쓰기도\n\nNext.js 13 앱 디렉토리의 서버 컴포넌트에서는 이런 API route 없이 `revalidatePath`를 쓸 수 있습니다. 예를 들어, 폼 제출 후 해당 경로를 다시 검증하고 싶은 경우 이렇게요:\n\n```ts\nimport { revalidatePath } from 'next/cache';\n\nexport async function updatePost(data: FormData) {\n  // 글 업데이트 로직 수행\n  const postId = data.get('postId') as string;\n\n  // 포스트 페이지 재검증 요청\n  revalidatePath(`/posts/${postId}`);\n}\n```\n\n---\n\n요약하자면, 오늘 보여드린 코드는 Next.js에서 특정 경로의 ISR 캐시를 수동으로 갱신하고 싶을 때 참 잘 쓰이는 방법입니다. 참고하시고, 필요할 때 활용해 보세요~!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":9},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<h1>revalidatePath 정리해보기</h1>\n<p>revalidatePath는 특정 경로에 대해 캐시된 데이터를 즉시 갱신(무효화)할 수 있게 해주는 함수예요.</p>\n<blockquote>\n<p>참고하면 좋은 점:\nrevalidatePath는 해당 경로를 다시 방문할 때 캐시를 무효화시켜줘요. 즉, 함수 호출 후 바로 캐시가 갈아엎어지는 게 아니라, 다음에 그 경로에 접근할 때 무효화가 적용된다는 뜻이죠. 동적 경로 세그먼트로 호출해도 한꺼번에 여러 경로가 즉시 무효화되는 게 아니라 '다음 방문 시점'부터 적용돼요.</p>\n</blockquote>\n<p>현재는 서버 액션 내에서 revalidatePath를 쓰면, 클라이언트 사이드 라우터 캐시에 있는 모든 경로가 무효화되는 임시 동작을 하고 있어요. 이 부분은 향후 개선되어서 특정 경로에만 적용되도록 바뀔 거랍니다.</p>\n<p>한편 서버 사이드 라우트 캐시에서는 특정 경로만 무효화하는 걸로 동작해요.</p>\n<hr>\n<h2>파라미터</h2>\n<p>(여기에 파라미터 관련 내용이 따라올 예정인데, 현재는 정보가 없네요.)</p>\n<hr>\n<h3>팁 하나 덧붙이자면요</h3>\n<p>이 기능은 예를 들어 게시글을 수정했을 때 수정된 내용이 바로 캐시에 반영되도록 강제로 갱신하고 싶을 때 많이 쓰이죠. 단, 재방문 시에 무효화가 되니까 페이지를 사용자에게 리다이렉트하거나, 클라이언트에서 다시 방문하게 만들어야 캐시 갱신 효과를 바로 볼 수 있다는 점 잊지 마세요!</p>\n<p>무효화를 즉시 반영해주는 것과는 조금 다르니까, 상황에 따라 적절히 활용해보세요.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-title function_\">revalidatePath</span>(<span class=\"hljs-attr\">path</span>: <span class=\"hljs-built_in\">string</span>, <span class=\"hljs-keyword\">type</span>?: <span class=\"hljs-string\">'page'</span> | <span class=\"hljs-string\">'layout'</span>): <span class=\"hljs-built_in\">void</span>;\n</code></pre>\n<ul>\n<li><strong>path</strong>: 다시 유효성 검사를 하고 싶은 데이터와 연결된 파일 시스템 경로 문자열입니다. 예를 들어, <code>/product/[slug]/page</code>처럼 동적 세그먼트를 포함할 수 있고, 혹은 <code>/product/123</code> 같은 실제 라우트 경로를 쓸 수도 있어요. 1024자 미만이어야 하고, 대소문자를 구분합니다.</li>\n<li><strong>type</strong>: (선택적) <code>'page'</code> 또는 <code>'layout'</code> 문자열로, 재유효성 검사를 할 경로 유형을 정하는 거예요. 경로에 동적 세그먼트가 있다면 반드시 이 파라미터를 넣어야 합니다. 반대로, 동적 페이지 경로의 실제 라우트 예시(<code>/product/1</code>)를 줄 때는 넣지 않아야 합니다.</li>\n</ul>\n<h2>반환값</h2>\n<p><code>revalidatePath</code> 함수는 값을 반환하지 않습니다. 즉, <code>void</code> 타입이에요.</p>\n<hr>\n<h3>한 마디 더!</h3>\n<p><code>revalidatePath</code>는 Next.js에서 ISR(Incremental Static Regeneration)을 쓸 때, 특정 경로나 레이아웃을 수동으로 재검증하고 싶을 때 유용합니다. 페이지를 변경했을 때 빌드 전체를 다시 할 필요 없이 부분적으로 빠르게 리프레시하는 느낌이라 생각하면 편해요.</p>\n<p>예를 들어, 어떤 상품 디테일 페이지 내용을 업데이트했을 때 해당 상품 페이지의 캐시만 재검증해서 최신 상태로 만들 수 있죠. 동적 경로가 섞인 경우에는 <code>type</code>을 꼭 신경 써서 넣어줘야 원하는 경로가 제대로 갱신됩니다.</p>\n<p>개발 중에는 이 함수를 잘 활용하면 페이지 리빌드 시간을 크게 단축시킬 수 있으니 꼭 기억해두세요!</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h2>예시</h2>\n<h3>특정 URL 재검증하기</h3>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { revalidatePath } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'next/cache'</span>\n\n<span class=\"hljs-title function_\">revalidatePath</span>(<span class=\"hljs-string\">'/blog/post-1'</span>)\n</code></pre>\n<p>위 코드는 <code>/blog/post-1</code> 경로를 다음 페이지 방문 시 재검증하도록 설정하는 방법이에요. 즉, 사용자가 해당 URL에 접속하면 콘텐츠가 최신 상태인지 Next.js가 다시 확인해서 캐시를 갱신하게 되는 거죠.</p>\n<p>추가로, revalidatePath는 아주 유용한 함수인데요, 페이지 빌드 후에 데이터가 바뀌었을 때 해당 페이지를 다시 유효성 검사해서 최신 내용을 보여주고 싶을 때 자주 사용됩니다. 예를 들어, 블로그 글을 수정하는 CMS 관리 페이지에서 이 함수를 호출하면 변경된 글이 사용자에게 바로 반영되게 할 수 있어요.</p>\n<p>그리고 한 가지 팁을 더 드리자면, revalidatePath 외에도 revalidateTag 같은 함수도 있는데, 여러 페이지에서 공통으로 쓰이는 데이터(예: 헤더, 푸터 정보)를 태그 단위로 재검증할 때 편리합니다. 상황에 맞게 잘 활용해보세요!</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h3>페이지 경로 재검증 (Revalidating A Page Path)</h3>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { revalidatePath } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'next/cache'</span>\n\n<span class=\"hljs-title function_\">revalidatePath</span>(<span class=\"hljs-string\">'/blog/[slug]'</span>, <span class=\"hljs-string\">'page'</span>)\n<span class=\"hljs-comment\">// 또는 라우트 그룹을 사용할 때</span>\n<span class=\"hljs-title function_\">revalidatePath</span>(<span class=\"hljs-string\">'/(main)/blog/[slug]'</span>, <span class=\"hljs-string\">'page'</span>)\n</code></pre>\n<p>이 코드는 특정 페이지 파일과 일치하는 URL이 다음에 방문할 때 다시 검증하도록 만들어줍니다. 쉽게 말해, 해당 경로에 있는 페이지가 업데이트되었을 때, 다음 방문부터 최신 내용이 반영되도록 하는 기능이에요.</p>\n<p>단, 중요한 점은 이 함수가 딱 지정한 경로에만 유효하다는 거예요. 예를 들어 <code>/blog/[slug]</code>를 재검증한다고 해서 <code>/blog/[slug]/[author]</code> 같은 하위 경로까지 자동으로 재검증되지 않습니다. 필요할 경우 하위 경로도 별도로 재검증해줘야 해요.</p>\n<hr>\n<h3>재검증에 대해 한마디 더!</h3>\n<p>이 기능은 SSR(서버 사이드 렌더링)이나 ISR(Incremental Static Regeneration)을 활용하는 프로젝트에서 자주 쓰입니다. 예를 들어, 블로그 글을 수정했을 때, 방문자가 새로 페이지를 요청하면 최신 버전을 보여주고 싶을 때 유용하죠.</p>\n<p>하지만 너무 많은 경로에 대해 자주 재검증을 걸면 서버 부하가 늘 수 있으니, 꼭 필요한 경로에만 적절히 활용하는 게 좋습니다.</p>\n<hr>\n<h3>재검증 레이아웃 경로 (Revalidating A Layout Path)</h3>\n<p>(다음 섹션에서 계속 이어서 작성할게요!)</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>Next.js에서 제공하는 revalidatePath 함수에 대해 간단히 이야기해볼게요. 이 함수는 특정 경로와 그 경로에 연결된 레이아웃을 기준으로 페이지를 다시 검증(리빌드)하는 작업을 해줍니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { revalidatePath } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'next/cache'</span>\n\n<span class=\"hljs-title function_\">revalidatePath</span>(<span class=\"hljs-string\">'/blog/[slug]'</span>, <span class=\"hljs-string\">'layout'</span>)\n<span class=\"hljs-comment\">// 또는 경로 그룹 사용 시</span>\n<span class=\"hljs-title function_\">revalidatePath</span>(<span class=\"hljs-string\">'/(main)/post/[slug]'</span>, <span class=\"hljs-string\">'layout'</span>)\n</code></pre>\n<p>위 코드는 <code>/blog/[slug]</code>에 해당하는 레이아웃 파일을 기준으로, 해당 경로뿐만 아니라 그 경로 하위에 있는 다른 페이지들도 다음 방문 시 자동으로 다시 리빌드되게 해줍니다. 예를 들어 <code>/blog/[slug]/[another]</code> 같은 하위 경로도 포함되겠죠.</p>\n<h3>모든 데이터를 재검증 하는 방법</h3>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { revalidatePath } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'next/cache'</span>\n\n<span class=\"hljs-title function_\">revalidatePath</span>(<span class=\"hljs-string\">'/'</span>, <span class=\"hljs-string\">'layout'</span>)\n</code></pre>\n<p>위처럼 루트 경로(<code>/</code>)에 대해 revalidatePath를 호출하면, 루트 레이아웃 아래에 속한 모든 페이지들이 다음 방문 시 다시 검증되어 최신 상태로 업데이트됩니다.</p>\n<hr>\n<h3>추가 팁!</h3>\n<ul>\n<li><code>revalidatePath</code>가 유용한 시점: 서버에서 어떤 데이터를 업데이트했는데 클라이언트 페이지에서 바로 최신 데이터가 반영되길 원할 때 써보세요.</li>\n<li>\"layout\" 옵션은 선택사항인데, 해당 경로의 레이아웃이 바뀌었을 때 그 변경 사항을 반영하기 위해 추가하는 경우가 많습니다.</li>\n<li>Next.js의 ISR(Incremental Static Regeneration)과 비슷한 개념이지만, 이 함수로 좀 더 세밀하게 특정 경로를 재검증할 수 있어서 편리해요.</li>\n</ul>\n<p>실제로 프로젝트에서 데이터 변경이 잦거나 특정 유저 액션 후 페이지를 새로 고침 시 최신 데이터를 보여주고 싶다면 적극 활용해보시길 바랍니다!</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>클라이언트 사이드 라우터 캐시를 지우고, 다음에 페이지를 방문할 때 데이터 캐시를 다시 검증하는 작업에 대해 이야기해볼게요.</p>\n<h3>서버 액션(Server Action)</h3>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-string\">'use server'</span>\n\n<span class=\"hljs-keyword\">import</span> { revalidatePath } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'next/cache'</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">submit</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">submitForm</span>()\n  <span class=\"hljs-title function_\">revalidatePath</span>(<span class=\"hljs-string\">'/'</span>)\n}\n</code></pre>\n<p>위 코드는 간단하게 설명하면, 폼 제출 같은 서버 액션이 일어난 후에 특정 경로('/')의 캐시를 강제로 다시 검증(revalidate)하도록 해요. 이렇게 하면 클라이언트 쪽에 저장된 라우터 캐시를 초기화하고, 데이터가 최신 상태인지 확인할 수 있어서 사용자에게 더 정확한 정보를 제공할 수 있답니다.</p>\n<p><strong>조금 더 풀어서 설명하자면</strong>, <code>revalidatePath()</code> 함수는 Next.js의 서버 캐시를 특정 경로 기준으로 새로 고치는 역할을 해요. 이 덕분에, 예를 들어 데이터가 업데이트된 페이지를 구독하고 있는 사용자가, 다음 번 방문 때 반드시 최신 내용이 보여지도록 할 수 있죠.</p>\n<h3>Route Handler</h3>\n<p>아래는 Route Handler에서 비슷한 맥락으로 쓰이는 코드의 예시입니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { revalidatePath } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'next/cache'</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">POST</span>(<span class=\"hljs-params\">request</span>) {\n  <span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-keyword\">await</span> request.<span class=\"hljs-title function_\">json</span>()\n  <span class=\"hljs-comment\">// 데이터 저장 로직 등 처리</span>\n  <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">saveData</span>(data)\n\n  <span class=\"hljs-comment\">// '/' 경로 캐시 재검증</span>\n  <span class=\"hljs-title function_\">revalidatePath</span>(<span class=\"hljs-string\">'/'</span>)\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Response</span>(<span class=\"hljs-string\">'Success'</span>, { <span class=\"hljs-attr\">status</span>: <span class=\"hljs-number\">200</span> })\n}\n</code></pre>\n<p>Route Handler에서도 POST 요청 처리 후에 동일하게 <code>revalidatePath</code>를 호출해서 특정 경로의 캐시를 새로고침할 수 있어요.</p>\n<hr>\n<blockquote>\n<p><strong>TIP!</strong></p>\n<p>Next.js 13부터 새로운 데이터 패칭 방식과 서버 액션이 도입되면서, 이런 재검증 로직이 더 간편해졌어요. 특히 ISR(Incremental Static Regeneration)을 활용해 캐시를 누적하고, 필요한 순간에만 갱신하는 전략 덕분에 성능과 UX가 훨씬 좋아졌답니다. 적절한 타이밍에 <code>revalidatePath</code>를 호출하는 것이 핵심이에요!</p>\n</blockquote>\n<p>필요하면 댓글이나 DM으로 질문 주세요. 더 친절하게 설명해드릴게요!</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>요즘 Next.js에서 ISR(Incremental Static Regeneration)을 활용할 일이 많아지면서, 특정 경로를 서버 사이드에서 동적으로 다시 빌드(재검증) 하는 방법에 대한 궁금증이 많아졌어요. 위에 코드가 그런 상황에서 유용한 예시라서 좀 쉽게 풀어서 설명해 드릴게요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { revalidatePath } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'next/cache'</span>\n<span class=\"hljs-keyword\">import</span> type { <span class=\"hljs-title class_\">NextRequest</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'next/server'</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">GET</span>(<span class=\"hljs-params\">request: NextRequest</span>) {\n  <span class=\"hljs-comment\">// URL 쿼리에서 'path' 파라미터를 받아온다</span>\n  <span class=\"hljs-keyword\">const</span> path = request.<span class=\"hljs-property\">nextUrl</span>.<span class=\"hljs-property\">searchParams</span>.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">'path'</span>)\n\n  <span class=\"hljs-keyword\">if</span> (path) {\n    <span class=\"hljs-comment\">// 해당 path를 Next.js에서 다시 빌드하도록 요청</span>\n    <span class=\"hljs-title function_\">revalidatePath</span>(path)\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Response</span>.<span class=\"hljs-title function_\">json</span>({ <span class=\"hljs-attr\">revalidated</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-attr\">now</span>: <span class=\"hljs-title class_\">Date</span>.<span class=\"hljs-title function_\">now</span>() })\n  }\n\n  <span class=\"hljs-comment\">// path 파라미터가 없으면 에러 메시지 반환</span>\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Response</span>.<span class=\"hljs-title function_\">json</span>({\n    <span class=\"hljs-attr\">revalidated</span>: <span class=\"hljs-literal\">false</span>,\n    <span class=\"hljs-attr\">now</span>: <span class=\"hljs-title class_\">Date</span>.<span class=\"hljs-title function_\">now</span>(),\n    <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">'Missing path to revalidate'</span>,\n  })\n}\n</code></pre>\n<h3>코드 설명</h3>\n<ul>\n<li><code>revalidatePath</code>: Next.js 13에서 도입된 function으로, ISR에서 특정 경로를 다시 빌드하도록 시그널을 넣어줍니다.</li>\n<li>이 API는 <code>GET</code> 요청을 받아서, 쿼리스트링에 <code>?path=/some-route</code> 형식으로 재검증할 경로를 전달하면 동작해요.</li>\n<li>만약 <code>path</code>가 없으면 재검증을 할 수 없으니, 메시지를 되돌려주는 안전장치가 있죠.</li>\n</ul>\n<hr>\n<h3>여기서 더 알아두시면 좋은 점!</h3>\n<ul>\n<li><code>revalidatePath</code>는 내부적으로 Next.js의 캐시를 무효화해서, 다음에 해당 경로로 접근할 때 최신 버전의 페이지가 보여지게 만들어 줍니다.</li>\n<li>재검증 요청을 API route처럼 만들어 두면, 관리자 페이지에서 \"컨텐츠 업데이트\" 버튼을 눌러 해당 페이지를 동적으로 최신화할 수 있어요.</li>\n<li>주의할 점은, <code>path</code> 값은 Next.js 안에서 존재하는 페이지 경로여야 제대로 동작합니다. 없는 경로를 넣으면 에러는 안 나지만, 의미가 없겠죠.</li>\n</ul>\n<hr>\n<h3>보너스: 서버 컴포넌트라면 이런 식으로 쓰기도</h3>\n<p>Next.js 13 앱 디렉토리의 서버 컴포넌트에서는 이런 API route 없이 <code>revalidatePath</code>를 쓸 수 있습니다. 예를 들어, 폼 제출 후 해당 경로를 다시 검증하고 싶은 경우 이렇게요:</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">import</span> { revalidatePath } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'next/cache'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">updatePost</span>(<span class=\"hljs-params\">data: FormData</span>) {\n  <span class=\"hljs-comment\">// 글 업데이트 로직 수행</span>\n  <span class=\"hljs-keyword\">const</span> postId = data.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">'postId'</span>) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">string</span>;\n\n  <span class=\"hljs-comment\">// 포스트 페이지 재검증 요청</span>\n  <span class=\"hljs-title function_\">revalidatePath</span>(<span class=\"hljs-string\">`/posts/<span class=\"hljs-subst\">${postId}</span>`</span>);\n}\n</code></pre>\n<hr>\n<p>요약하자면, 오늘 보여드린 코드는 Next.js에서 특정 경로의 ISR 캐시를 수동으로 갱신하고 싶을 때 참 잘 쓰이는 방법입니다. 참고하시고, 필요할 때 활용해 보세요~!</p>\n</body>\n</html>\n"},"__N_SSG":true}