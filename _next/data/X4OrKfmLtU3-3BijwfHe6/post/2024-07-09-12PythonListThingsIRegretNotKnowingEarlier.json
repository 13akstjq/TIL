{"pageProps":{"post":{"title":"알아두었으면 좋았을 Python 리스트 방법 12가지","description":"","date":"2024-07-09 19:32","slug":"2024-07-09-12PythonListThingsIRegretNotKnowingEarlier","content":"\n![이미지](/TIL/assets/img/2024-07-09-12PythonListThingsIRegretNotKnowingEarlier_0.png)\n\n파이썬 여행을 하면서 몇 가지를 좀 늦게 알게 되었는데, 아마 당신이 이것들을 더 빨리 배울 수 있을 거에요.\n\n### 1) 리스트를 결합하기 위해 \\* 사용하기\n\n리스트 앞에 \\*을 추가하면 언팩합니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\na = [1, 2]\nb = [3, 4]\n\nc = [*a, *b, 5]\n\nprint(c) # [1, 2, 3, 4, 5]\n```\n\n- 첫 번째 \\*는 a의 요소를 c에 풀어 헤친다\n- 두 번째 \\*는 b의 요소를 c에 풀어 헤친다\n- 이것이 왜 1, 2, 3, 4, 5가 동일한 목록 c에 들어 있는지 이유입니다\n\n```js\na = [1, 2]\nb = [3, 4]\nc = [5, 6]\nd = [7, 8]\n\nx = [*a, b, *c, d]\n\nprint(x) # [1, 2, [3,4], 5, 6, [7, 8]]\n```\n\n^ \\*이 붙은 리스트(a와 c)만 풀어 헤쳐진다는 것을 주목해 주세요. b와 d는 일반 요소처럼 처리됩니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 2) \\*를 사용하여 리스트 언패킹하기\n\n리스트를 언패킹할 때, 우리는 \\*를 변수 앞에 사용하여 즉시 사용하지 않을 초과 요소를 받을 수 있습니다.\n\n```js\nmylist = ['apple', 'orange', 'pear', 'pineapple', 'durian']\n\na, b, *others = mylist\n\nprint(a)       # apple\nprint(b)       # orange\nprint(others)  # ['pear', 'pineapple', 'durian']\n```\n\n- a는 mylist의 첫 번째 요소에 할당됩니다.\n- b는 mylist의 두 번째 요소에 할당됩니다.\n- others는 mylist의 모든 다른 요소를 받는 리스트에 할당됩니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n노트 - a와 b가 반드시 가장 앞에 있을 필요는 없습니다.\n\n```js\nmylist = ['apple', 'orange', 'pear', 'pineapple', 'durian']\n\na, *others, b = mylist\n\nprint(a)       # apple\nprint(b)       # durian\nprint(others)  # ['orange', 'pear', 'pineapple']\n```\n\n- a는 mylist의 첫 번째 요소에 할당됩니다.\n- b는 mylist의 마지막 요소에 할당됩니다.\n- others는 mylist 사이에 모든 다른 요소를 캐치하는 리스트에 할당됩니다.\n\n# 3) 리스트를 함수 인수로 언패킹하는 방법\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n함수 이름, 나이, 성별을 받는 test 함수가 있다고 가정해보죠. 이 함수를 사용하려면 test(이름, 나이, 성별)와 같이 전달해주어야 합니다.\n\n```js\ndef test(name, age, gender):\n    print(name, age, gender)\n\ntest('rocky', 5, 'male') # rocky 5 male\n```\n\n만약 올바른 함수 인수를 포함하는 리스트 x = ['rocky', 5, 'male']가 있다면, \\*를 사용하여 해당 인수를 함수에 전달할 수 있습니다.\n\n```js\nx = ['rocky', 5, 'male']\n\ntest(*x) # rocky 5 male\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위 내용은 다음과 같습니다:\n\n```js\ntest(\"rocky\", 5, \"male\");\n```\n\n# 4) 리스트 컴프리헨션\n\n어떤 이유로 인해 나는 리스트 컴프리헨션에 대해 상대적으로 늦게 배웠다 (자료 구조와 알고리즘에 대해서 배운 후에야).\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 우리가 [1, 2, 3, 4, 5]라는 리스트가 있고, 각 요소를 10씩 곱해서 [10, 20, 30, 40, 50] 리스트를 만들고 싶다면, 리스트 컴프리헨션 없이는 어떻게 할 수 있을까요:\n\n```js\nnumbers = [1, 2, 3, 4, 5]\n\nnewlist = []\nfor number in numbers:\n    newlist.append(number * 10)\n\nprint(newlist)  # [10, 20, 30, 40, 50]\n```\n\n리스트 컴프리헨션을 사용하여 훨씬 더 우아하게 할 수 있는 방법은 다음과 같습니다:\n\n```js\nnumbers = [1, 2, 3, 4, 5]\n\nnewlist = [n * 10 for n in numbers]\n\nprint(newlist)  # [10, 20, 30, 40, 50]\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 5) 중첩된 리스트에 대한 리스트 컴프리헨션\n\n하지만 중첩된 for 루프는 어떻게 할까요? 걱정하지 마세요. 리스트 컴프리헨션은 이를 쉽게 처리할 수 있습니다. 리스트 컴프리헨션을 사용하지 않은 예시를 통해 살펴보겠습니다:\n\n```js\nnewlist = []\n\nfor i in [1, 2]:\n    for j in [3, 4]:\n        t = (i, j)\n        newlist.append(t)\n\nprint(newlist) # [(1, 3), (1, 4), (2, 3), (2, 4)]\n```\n\n리스트 컴프리헨션을 사용하여 정확히 동일한 작업을 수행할 수 있습니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nnewlist = [(i,j) for i in [1,2] for j in [3,4]]\n\nprint(newlist) # [(1, 3), (1, 4), (2, 3), (2, 4)]\n```\n\n^ 중첩된 for 루프를 리스트 내포로 변환할 때는 외부 for 루프가 먼저 오고, 그 다음에 내부 for 루프가 옵니다.\n\n# 6) 튜플 대 리스트\n\n비기너였을 때 저는 꽤 오랫동안 튜플을 무시했습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n튜플은 그냥 변경할 수 없는 목록입니다. 변경할 수 없다는 것은 튜플을 만든 후에는 변경할 수 없다는 것을 의미합니다.\n\n```js\n# 리스트는 변경할 수 있습니다. .append를 사용하여 만든 후에도 요소를 추가할 수 있습니다.\n\nmylist = [1, 2, 3]\n\nmylist.append(4)\nprint(mylist)      # [1, 2, 3, 4]\n```\n\n```js\n# 튜플은 변경할 수 없습니다. 만든 후에는 아무것도 추가할 수 없습니다\n\nmytuple = (1, 2, 3)\n\nmytuple.append(4) # ERROR\n```\n\n그래서 튜플은 목록의 안 좋은 버전으로 보입니다. 왜 튜플을 사용해야 할까요?\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n튜플의 불변성의 가장 큰 장점은 해시 가능하다는 것입니다.\n\n- 리스트는 사전 키가 될 수 없지만 튜플은 될 수 있습니다\n- 리스트는 집합에 추가할 수 없지만 튜플은 추가할 수 있습니다\n\n```js\n# 리스트는 1) 사전 키로 사용할 수 없으며 2) 집합에 추가할 수 없음\n\nd = {\n    [1, 2, 3]: 4,\n    [5, 6, 7]: 8\n}\n\n# ERROR\n```\n\n```js\n# 하지만 튜플은 가능합니다\n\nd = {\n    (1, 2, 3): 4,\n    (5, 6, 7): 8\n}\n\n# OK\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 7) .insert()을 사용하여 특정 인덱스에 새 요소를 삽입합니다.\n\n.append()은 리스트의 뒷부분에만 새 요소를 추가할 수 있습니다.\n\n하지만 .insert()을 사용하면 새 요소를 어떤 인덱스에든 추가할 수 있습니다.\n\n```js\nmylist = [1, 2, 3]\n\n# 새 값 100을 인덱스 0에 추가\nmylist.insert(0, 100)\n\nprint(mylist) # [100, 1, 2, 3]\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n^ 기존 요소가 모두 오른쪽으로 이동해야 하므로 이 작업은 O(n) 시간이 걸립니다.\n\n```js\nmylist = [1, 2, 3]\n\n# 인덱스 2에 새로운 요소 150 추가\nmylist.insert(2, 150)\n\nprint(mylist) # [1, 2, 150, 3]\n```\n\n^ 1과 2는 그대로 있지만, 3은 오른쪽으로 이동해야 합니다.\n\n# 8) .pop()을 사용하여 요소 제거\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n.pop() 메소드를 사용하면 2가지 작업을 동시에 할 수 있습니다:\n\n- 리스트의 마지막 요소를 삭제합니다.\n- 삭제된 이 요소를 반환합니다.\n\n```js\nmylist = [1, 2, 3]\n\n# 마지막 요소 제거하고 x에 할당\nx = mylist.pop()\n\nprint(x)      # 3\nprint(mylist) # [1, 2]\n```\n\n.pop()에 인덱스를 전달하면 해당 인덱스의 요소를 제거할 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n내목록 = [1, 2, 3]\n\n# 인덱스 0의 요소를 제거하고 x에 할당\nx = 내목록.pop(0)\n\nprint(x)       # 1\nprint(내목록)  # [2, 3]\n```\n\n.pop(n)은 모두 n 이후에 위치한 인데스의 요소를 좌측으로 이동해야 하므로 O(n) 시간이 걸린다는 것을 알아두세요. 이것은 우리 목록이 매우 큰 경우 비효율적일 수 있다는 것을 의미합니다.\n\n# 9) .extend()를 사용하여 목록 결합\n\n.extend()는 한 목록의 모든 요소를 다른 목록에 추가할 수 있게 해줍니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\na = [1, 2, 3]\nb = [4, 5, 6]\n\n# b의 모든 요소를 a에 추가합니다.\na.extend(b)\n\nprint(a)  # [1, 2, 3, 4, 5, 6]\nprint(b)  # [4, 5, 6]\n```\n\n^ b가 변경되지 않았음에 유의해주세요\n\n# 10) sort() vs sorted()\n\n- `.sort()`은 리스트 자체를 정렬합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nmylist = [1, 3, 2]\n\nmylist.sort()\n\nprint(mylist) # [1, 2, 3]\n```\n\nsorted() 함수는 리스트를 정렬한 복사본을 생성합니다. 원본 리스트는 그대로 유지됩니다. 원본 리스트의 순서를 보존하고 싶을 때 이것을 사용합니다.\n\n```js\nmylist = [1, 3, 2]\n\nnewlist = sorted(mylist)\n\nprint(newlist)  # [1, 2, 3]\nprint(mylist)   # [1, 3, 2]\n```\n\n# 11) 사용자 정의 조건으로 .sort()하기\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n**참고— 이것은 .sort()와 sorted()에 대해 동일하게 작동합니다.**\n\n기본 .sort()는 문자열을 알파벳 순서대로 정렬합니다:\n\n```js\nfruits = ['orange', 'apple', 'pear']\n\nfruits.sort()\n\nprint(fruits) # ['apple', 'orange', 'pear']\n```\n\n우리는 .sort()에서 key 인자에 함수를 전달하여 사용자 정의 정렬 조건을 정의할 수 있습니다. 예: list.sort(key=your_function)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 함수는 전체 요소를 가져와서\n- 우리가 정렬하려는 값을 반환합니다.\n\n문자열 내의 p의 개수로 정렬하고 싶다고 가정해 봅시다.\n\n- 따라서 사용자 정의 함수는 여전히 전체 요소를 가져와서\n- p 문자의 개수를 반환합니다.\n\n```js\ndef your_condition(element: str) -> int:\n    return element.count('p')\n\nfruits = ['orange', 'apple', 'pear']\n\nfruits.sort(key=your_condition)\n\nprint(fruits) # ['orange', 'pear', 'apple']\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테이블 태그를 Markdown 형식으로 변경하세요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n노트 - 이 코드는 .sort()와 sorted() 모두에 작동합니다.\n\n학생을 나타내는 각각의 사전이 포함된 목록이 있다고 가정해 봅시다.\n\n```js\nstudents = [\n  { name: \"A\", math: 100, science: 81 },\n  { name: \"B\", math: 100, science: 71 },\n  { name: \"C\", math: 100, science: 91 },\n  { name: \"D\", math: 80, science: 91 },\n  { name: \"E\", math: 80, science: 93 },\n  { name: \"F\", math: 80, science: 92 },\n];\n```\n\n그리고 그들의 수학 점수에 따라 정렬한다고 가정합시다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nstudents.sort(key=lambda x:x['math'])\n\nprint(students)\n\n'''\n[\n  {'name': 'D', 'math': 80, 'science': 91},\n  {'name': 'E', 'math': 80, 'science': 93},\n  {'name': 'F', 'math': 80, 'science': 92},\n  {'name': 'A', 'math': 100, 'science': 81},\n  {'name': 'B', 'math': 100, 'science': 71},\n  {'name': 'C', 'math': 100, 'science': 91}\n]\n'''\n\n^ math=80 at the front, math=100 at the back. But notice that their science score is not sorted.\n\nAnd what if we want to sort by math first, then science?\n\n- first sort by math score\n- for students with the same math score, sort by science score\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이를 수행하기 위해서는 우리의 주요 함수는 단순히 튜플 (첫 번째 조건, 두 번째 조건)을 반환하면 됩니다. 이 경우에는 (수학 점수, 과학 점수)가 될 것입니다.\n\n```js\nstudents.sort(key=lambda x:(x['math'], x['science']) )\n\nprint(students)\n\n'''\n[\n  {'name': 'D', 'math': 80, 'science': 91},\n  {'name': 'F', 'math': 80, 'science': 92},\n  {'name': 'E', 'math': 80, 'science': 93},\n  {'name': 'B', 'math': 100, 'science': 71},\n  {'name': 'A', 'math': 100, 'science': 81},\n  {'name': 'C', 'math': 100, 'science': 91}\n]\n'''\n```\n\n그리고 여기서, 수학 점수가 동일한 학생들은 과학 점수에 의해 정렬됨을 주목해 보세요.\n\n참고 — 3가지 조건에 따라 정렬하려면, 단순히 (첫 번째 조건, 두 번째 조건, 세 번째 조건)의 튜플을 반환하면 됩니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결론\n\n이 내용이 명확하고 이해하기 쉬웠으면 좋겠어요!\n\n# 친구들을 위한 Python 농담\n\n# 만약에 제작자로서 저를 지원하고 싶다면\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 제 책을 구입해 주세요! — 101 Things I Never Knew About Python\n- 확인할 수 있는 곳: [여기](https://payhip.com/b/vywcf)\n- 이 이야기를 위해 50번 클랩을 해주세요\n- 댓글로 당신의 생각을 남겨주세요\n- 이야기 중 가장 좋아하는 부분을 강조해주세요\n\n감사합니다! 이런 작은 행동이 큰 도움이 되고, 정말 감사드립니다!\n\nYouTube: [여기](https://www.youtube.com/@zlliu246)\n\nLinkedIn: [여기](https://www.linkedin.com/in/zlliu/)\n","ogImage":{"url":"/assets/img/2024-07-09-12PythonListThingsIRegretNotKnowingEarlier_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-12PythonListThingsIRegretNotKnowingEarlier_0.png","tag":["Tech"],"readingTime":15},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/TIL/assets/img/2024-07-09-12PythonListThingsIRegretNotKnowingEarlier_0.png\" alt=\"이미지\"></p>\n<p>파이썬 여행을 하면서 몇 가지를 좀 늦게 알게 되었는데, 아마 당신이 이것들을 더 빨리 배울 수 있을 거에요.</p>\n<h3>1) 리스트를 결합하기 위해 * 사용하기</h3>\n<p>리스트 앞에 *을 추가하면 언팩합니다:</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\">a = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>]\nb = [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>]\n\nc = [*a, *b, <span class=\"hljs-number\">5</span>]\n\n<span class=\"hljs-title function_\">print</span>(c) # [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>]\n</code></pre>\n<ul>\n<li>첫 번째 *는 a의 요소를 c에 풀어 헤친다</li>\n<li>두 번째 *는 b의 요소를 c에 풀어 헤친다</li>\n<li>이것이 왜 1, 2, 3, 4, 5가 동일한 목록 c에 들어 있는지 이유입니다</li>\n</ul>\n<pre><code class=\"hljs language-js\">a = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>]\nb = [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>]\nc = [<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>]\nd = [<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>]\n\nx = [*a, b, *c, d]\n\n<span class=\"hljs-title function_\">print</span>(x) # [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, [<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>], <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, [<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>]]\n</code></pre>\n<p>^ *이 붙은 리스트(a와 c)만 풀어 헤쳐진다는 것을 주목해 주세요. b와 d는 일반 요소처럼 처리됩니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h1>2) *를 사용하여 리스트 언패킹하기</h1>\n<p>리스트를 언패킹할 때, 우리는 *를 변수 앞에 사용하여 즉시 사용하지 않을 초과 요소를 받을 수 있습니다.</p>\n<pre><code class=\"hljs language-js\">mylist = [<span class=\"hljs-string\">'apple'</span>, <span class=\"hljs-string\">'orange'</span>, <span class=\"hljs-string\">'pear'</span>, <span class=\"hljs-string\">'pineapple'</span>, <span class=\"hljs-string\">'durian'</span>]\n\na, b, *others = mylist\n\n<span class=\"hljs-title function_\">print</span>(a)       # apple\n<span class=\"hljs-title function_\">print</span>(b)       # orange\n<span class=\"hljs-title function_\">print</span>(others)  # [<span class=\"hljs-string\">'pear'</span>, <span class=\"hljs-string\">'pineapple'</span>, <span class=\"hljs-string\">'durian'</span>]\n</code></pre>\n<ul>\n<li>a는 mylist의 첫 번째 요소에 할당됩니다.</li>\n<li>b는 mylist의 두 번째 요소에 할당됩니다.</li>\n<li>others는 mylist의 모든 다른 요소를 받는 리스트에 할당됩니다.</li>\n</ul>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>노트 - a와 b가 반드시 가장 앞에 있을 필요는 없습니다.</p>\n<pre><code class=\"hljs language-js\">mylist = [<span class=\"hljs-string\">'apple'</span>, <span class=\"hljs-string\">'orange'</span>, <span class=\"hljs-string\">'pear'</span>, <span class=\"hljs-string\">'pineapple'</span>, <span class=\"hljs-string\">'durian'</span>]\n\na, *others, b = mylist\n\n<span class=\"hljs-title function_\">print</span>(a)       # apple\n<span class=\"hljs-title function_\">print</span>(b)       # durian\n<span class=\"hljs-title function_\">print</span>(others)  # [<span class=\"hljs-string\">'orange'</span>, <span class=\"hljs-string\">'pear'</span>, <span class=\"hljs-string\">'pineapple'</span>]\n</code></pre>\n<ul>\n<li>a는 mylist의 첫 번째 요소에 할당됩니다.</li>\n<li>b는 mylist의 마지막 요소에 할당됩니다.</li>\n<li>others는 mylist 사이에 모든 다른 요소를 캐치하는 리스트에 할당됩니다.</li>\n</ul>\n<h1>3) 리스트를 함수 인수로 언패킹하는 방법</h1>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>함수 이름, 나이, 성별을 받는 test 함수가 있다고 가정해보죠. 이 함수를 사용하려면 test(이름, 나이, 성별)와 같이 전달해주어야 합니다.</p>\n<pre><code class=\"hljs language-js\">def <span class=\"hljs-title function_\">test</span>(name, age, gender):\n    <span class=\"hljs-title function_\">print</span>(name, age, gender)\n\n<span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">'rocky'</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-string\">'male'</span>) # rocky <span class=\"hljs-number\">5</span> male\n</code></pre>\n<p>만약 올바른 함수 인수를 포함하는 리스트 x = ['rocky', 5, 'male']가 있다면, *를 사용하여 해당 인수를 함수에 전달할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\">x = [<span class=\"hljs-string\">'rocky'</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-string\">'male'</span>]\n\n<span class=\"hljs-title function_\">test</span>(*x) # rocky <span class=\"hljs-number\">5</span> male\n</code></pre>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>위 내용은 다음과 같습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">\"rocky\"</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-string\">\"male\"</span>);\n</code></pre>\n<h1>4) 리스트 컴프리헨션</h1>\n<p>어떤 이유로 인해 나는 리스트 컴프리헨션에 대해 상대적으로 늦게 배웠다 (자료 구조와 알고리즘에 대해서 배운 후에야).</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>만약 우리가 [1, 2, 3, 4, 5]라는 리스트가 있고, 각 요소를 10씩 곱해서 [10, 20, 30, 40, 50] 리스트를 만들고 싶다면, 리스트 컴프리헨션 없이는 어떻게 할 수 있을까요:</p>\n<pre><code class=\"hljs language-js\">numbers = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>]\n\nnewlist = []\n<span class=\"hljs-keyword\">for</span> number <span class=\"hljs-keyword\">in</span> <span class=\"hljs-attr\">numbers</span>:\n    newlist.<span class=\"hljs-title function_\">append</span>(number * <span class=\"hljs-number\">10</span>)\n\n<span class=\"hljs-title function_\">print</span>(newlist)  # [<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">30</span>, <span class=\"hljs-number\">40</span>, <span class=\"hljs-number\">50</span>]\n</code></pre>\n<p>리스트 컴프리헨션을 사용하여 훨씬 더 우아하게 할 수 있는 방법은 다음과 같습니다:</p>\n<pre><code class=\"hljs language-js\">numbers = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>]\n\nnewlist = [n * <span class=\"hljs-number\">10</span> <span class=\"hljs-keyword\">for</span> n <span class=\"hljs-keyword\">in</span> numbers]\n\n<span class=\"hljs-title function_\">print</span>(newlist)  # [<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">30</span>, <span class=\"hljs-number\">40</span>, <span class=\"hljs-number\">50</span>]\n</code></pre>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h1>5) 중첩된 리스트에 대한 리스트 컴프리헨션</h1>\n<p>하지만 중첩된 for 루프는 어떻게 할까요? 걱정하지 마세요. 리스트 컴프리헨션은 이를 쉽게 처리할 수 있습니다. 리스트 컴프리헨션을 사용하지 않은 예시를 통해 살펴보겠습니다:</p>\n<pre><code class=\"hljs language-js\">newlist = []\n\n<span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>]:\n    <span class=\"hljs-keyword\">for</span> j <span class=\"hljs-keyword\">in</span> [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>]:\n        t = (i, j)\n        newlist.<span class=\"hljs-title function_\">append</span>(t)\n\n<span class=\"hljs-title function_\">print</span>(newlist) # [(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>), (<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">4</span>), (<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>), (<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>)]\n</code></pre>\n<p>리스트 컴프리헨션을 사용하여 정확히 동일한 작업을 수행할 수 있습니다:</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-python\">newlist = [(i,j) <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>] <span class=\"hljs-keyword\">for</span> j <span class=\"hljs-keyword\">in</span> [<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>]]\n\n<span class=\"hljs-built_in\">print</span>(newlist) <span class=\"hljs-comment\"># [(1, 3), (1, 4), (2, 3), (2, 4)]</span>\n</code></pre>\n<p>^ 중첩된 for 루프를 리스트 내포로 변환할 때는 외부 for 루프가 먼저 오고, 그 다음에 내부 for 루프가 옵니다.</p>\n<h1>6) 튜플 대 리스트</h1>\n<p>비기너였을 때 저는 꽤 오랫동안 튜플을 무시했습니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>튜플은 그냥 변경할 수 없는 목록입니다. 변경할 수 없다는 것은 튜플을 만든 후에는 변경할 수 없다는 것을 의미합니다.</p>\n<pre><code class=\"hljs language-js\"># 리스트는 변경할 수 있습니다. .<span class=\"hljs-property\">append</span>를 사용하여 만든 후에도 요소를 추가할 수 있습니다.\n\nmylist = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]\n\nmylist.<span class=\"hljs-title function_\">append</span>(<span class=\"hljs-number\">4</span>)\n<span class=\"hljs-title function_\">print</span>(mylist)      # [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>]\n</code></pre>\n<pre><code class=\"hljs language-js\"># 튜플은 변경할 수 없습니다. 만든 후에는 아무것도 추가할 수 없습니다\n\nmytuple = (<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>)\n\nmytuple.<span class=\"hljs-title function_\">append</span>(<span class=\"hljs-number\">4</span>) # <span class=\"hljs-variable constant_\">ERROR</span>\n</code></pre>\n<p>그래서 튜플은 목록의 안 좋은 버전으로 보입니다. 왜 튜플을 사용해야 할까요?</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>튜플의 불변성의 가장 큰 장점은 해시 가능하다는 것입니다.</p>\n<ul>\n<li>리스트는 사전 키가 될 수 없지만 튜플은 될 수 있습니다</li>\n<li>리스트는 집합에 추가할 수 없지만 튜플은 추가할 수 있습니다</li>\n</ul>\n<pre><code class=\"hljs language-js\"># 리스트는 <span class=\"hljs-number\">1</span>) 사전 키로 사용할 수 없으며 <span class=\"hljs-number\">2</span>) 집합에 추가할 수 없음\n\nd = {\n    [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]: <span class=\"hljs-number\">4</span>,\n    [<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>]: <span class=\"hljs-number\">8</span>\n}\n\n# <span class=\"hljs-variable constant_\">ERROR</span>\n</code></pre>\n<pre><code class=\"hljs language-js\"># 하지만 튜플은 가능합니다\n\nd = {\n    (<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>): <span class=\"hljs-number\">4</span>,\n    (<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>): <span class=\"hljs-number\">8</span>\n}\n\n# <span class=\"hljs-variable constant_\">OK</span>\n</code></pre>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h1>7) .insert()을 사용하여 특정 인덱스에 새 요소를 삽입합니다.</h1>\n<p>.append()은 리스트의 뒷부분에만 새 요소를 추가할 수 있습니다.</p>\n<p>하지만 .insert()을 사용하면 새 요소를 어떤 인덱스에든 추가할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\">mylist = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]\n\n# 새 값 <span class=\"hljs-number\">100</span>을 인덱스 <span class=\"hljs-number\">0</span>에 추가\nmylist.<span class=\"hljs-title function_\">insert</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">100</span>)\n\n<span class=\"hljs-title function_\">print</span>(mylist) # [<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]\n</code></pre>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>^ 기존 요소가 모두 오른쪽으로 이동해야 하므로 이 작업은 O(n) 시간이 걸립니다.</p>\n<pre><code class=\"hljs language-js\">mylist = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]\n\n# 인덱스 <span class=\"hljs-number\">2</span>에 새로운 요소 <span class=\"hljs-number\">150</span> 추가\nmylist.<span class=\"hljs-title function_\">insert</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">150</span>)\n\n<span class=\"hljs-title function_\">print</span>(mylist) # [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">150</span>, <span class=\"hljs-number\">3</span>]\n</code></pre>\n<p>^ 1과 2는 그대로 있지만, 3은 오른쪽으로 이동해야 합니다.</p>\n<h1>8) .pop()을 사용하여 요소 제거</h1>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>.pop() 메소드를 사용하면 2가지 작업을 동시에 할 수 있습니다:</p>\n<ul>\n<li>리스트의 마지막 요소를 삭제합니다.</li>\n<li>삭제된 이 요소를 반환합니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\">mylist = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]\n\n# 마지막 요소 제거하고 x에 할당\nx = mylist.<span class=\"hljs-title function_\">pop</span>()\n\n<span class=\"hljs-title function_\">print</span>(x)      # <span class=\"hljs-number\">3</span>\n<span class=\"hljs-title function_\">print</span>(mylist) # [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>]\n</code></pre>\n<p>.pop()에 인덱스를 전달하면 해당 인덱스의 요소를 제거할 수 있습니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\">내목록 = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]\n\n# 인덱스 <span class=\"hljs-number\">0</span>의 요소를 제거하고 x에 할당\nx = 내목록.<span class=\"hljs-title function_\">pop</span>(<span class=\"hljs-number\">0</span>)\n\n<span class=\"hljs-title function_\">print</span>(x)       # <span class=\"hljs-number\">1</span>\n<span class=\"hljs-title function_\">print</span>(내목록)  # [<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]\n</code></pre>\n<p>.pop(n)은 모두 n 이후에 위치한 인데스의 요소를 좌측으로 이동해야 하므로 O(n) 시간이 걸린다는 것을 알아두세요. 이것은 우리 목록이 매우 큰 경우 비효율적일 수 있다는 것을 의미합니다.</p>\n<h1>9) .extend()를 사용하여 목록 결합</h1>\n<p>.extend()는 한 목록의 모든 요소를 다른 목록에 추가할 수 있게 해줍니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\">a = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]\nb = [<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>]\n\n# b의 모든 요소를 a에 추가합니다.\na.<span class=\"hljs-title function_\">extend</span>(b)\n\n<span class=\"hljs-title function_\">print</span>(a)  # [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>]\n<span class=\"hljs-title function_\">print</span>(b)  # [<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>]\n</code></pre>\n<p>^ b가 변경되지 않았음에 유의해주세요</p>\n<h1>10) sort() vs sorted()</h1>\n<ul>\n<li><code>.sort()</code>은 리스트 자체를 정렬합니다.</li>\n</ul>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\">mylist = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>]\n\nmylist.<span class=\"hljs-title function_\">sort</span>()\n\n<span class=\"hljs-title function_\">print</span>(mylist) # [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]\n</code></pre>\n<p>sorted() 함수는 리스트를 정렬한 복사본을 생성합니다. 원본 리스트는 그대로 유지됩니다. 원본 리스트의 순서를 보존하고 싶을 때 이것을 사용합니다.</p>\n<pre><code class=\"hljs language-js\">mylist = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>]\n\nnewlist = <span class=\"hljs-title function_\">sorted</span>(mylist)\n\n<span class=\"hljs-title function_\">print</span>(newlist)  # [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]\n<span class=\"hljs-title function_\">print</span>(mylist)   # [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>]\n</code></pre>\n<h1>11) 사용자 정의 조건으로 .sort()하기</h1>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p><strong>참고— 이것은 .sort()와 sorted()에 대해 동일하게 작동합니다.</strong></p>\n<p>기본 .sort()는 문자열을 알파벳 순서대로 정렬합니다:</p>\n<pre><code class=\"hljs language-js\">fruits = [<span class=\"hljs-string\">'orange'</span>, <span class=\"hljs-string\">'apple'</span>, <span class=\"hljs-string\">'pear'</span>]\n\nfruits.<span class=\"hljs-title function_\">sort</span>()\n\n<span class=\"hljs-title function_\">print</span>(fruits) # [<span class=\"hljs-string\">'apple'</span>, <span class=\"hljs-string\">'orange'</span>, <span class=\"hljs-string\">'pear'</span>]\n</code></pre>\n<p>우리는 .sort()에서 key 인자에 함수를 전달하여 사용자 정의 정렬 조건을 정의할 수 있습니다. 예: list.sort(key=your_function)</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>함수는 전체 요소를 가져와서</li>\n<li>우리가 정렬하려는 값을 반환합니다.</li>\n</ul>\n<p>문자열 내의 p의 개수로 정렬하고 싶다고 가정해 봅시다.</p>\n<ul>\n<li>따라서 사용자 정의 함수는 여전히 전체 요소를 가져와서</li>\n<li>p 문자의 개수를 반환합니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\">def <span class=\"hljs-title function_\">your_condition</span>(<span class=\"hljs-attr\">element</span>: str) -> <span class=\"hljs-attr\">int</span>:\n    <span class=\"hljs-keyword\">return</span> element.<span class=\"hljs-title function_\">count</span>(<span class=\"hljs-string\">'p'</span>)\n\nfruits = [<span class=\"hljs-string\">'orange'</span>, <span class=\"hljs-string\">'apple'</span>, <span class=\"hljs-string\">'pear'</span>]\n\nfruits.<span class=\"hljs-title function_\">sort</span>(key=your_condition)\n\n<span class=\"hljs-title function_\">print</span>(fruits) # [<span class=\"hljs-string\">'orange'</span>, <span class=\"hljs-string\">'pear'</span>, <span class=\"hljs-string\">'apple'</span>]\n</code></pre>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>테이블 태그를 Markdown 형식으로 변경하세요.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>노트 - 이 코드는 .sort()와 sorted() 모두에 작동합니다.</p>\n<p>학생을 나타내는 각각의 사전이 포함된 목록이 있다고 가정해 봅시다.</p>\n<pre><code class=\"hljs language-js\">students = [\n  { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"A\"</span>, <span class=\"hljs-attr\">math</span>: <span class=\"hljs-number\">100</span>, <span class=\"hljs-attr\">science</span>: <span class=\"hljs-number\">81</span> },\n  { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"B\"</span>, <span class=\"hljs-attr\">math</span>: <span class=\"hljs-number\">100</span>, <span class=\"hljs-attr\">science</span>: <span class=\"hljs-number\">71</span> },\n  { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"C\"</span>, <span class=\"hljs-attr\">math</span>: <span class=\"hljs-number\">100</span>, <span class=\"hljs-attr\">science</span>: <span class=\"hljs-number\">91</span> },\n  { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"D\"</span>, <span class=\"hljs-attr\">math</span>: <span class=\"hljs-number\">80</span>, <span class=\"hljs-attr\">science</span>: <span class=\"hljs-number\">91</span> },\n  { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"E\"</span>, <span class=\"hljs-attr\">math</span>: <span class=\"hljs-number\">80</span>, <span class=\"hljs-attr\">science</span>: <span class=\"hljs-number\">93</span> },\n  { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"F\"</span>, <span class=\"hljs-attr\">math</span>: <span class=\"hljs-number\">80</span>, <span class=\"hljs-attr\">science</span>: <span class=\"hljs-number\">92</span> },\n];\n</code></pre>\n<p>그리고 그들의 수학 점수에 따라 정렬한다고 가정합시다:</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-python\">students.sort(key=<span class=\"hljs-keyword\">lambda</span> x:x[<span class=\"hljs-string\">'math'</span>])\n\n<span class=\"hljs-built_in\">print</span>(students)\n\n<span class=\"hljs-string\">'''\n[\n  {'name': 'D', 'math': 80, 'science': 91},\n  {'name': 'E', 'math': 80, 'science': 93},\n  {'name': 'F', 'math': 80, 'science': 92},\n  {'name': 'A', 'math': 100, 'science': 81},\n  {'name': 'B', 'math': 100, 'science': 71},\n  {'name': 'C', 'math': 100, 'science': 91}\n]\n'''</span>\n\n^ math=<span class=\"hljs-number\">80</span> at the front, math=<span class=\"hljs-number\">100</span> at the back. But notice that their science score <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-built_in\">sorted</span>.\n\nAnd what <span class=\"hljs-keyword\">if</span> we want to sort by math first, then science?\n\n- first sort by math score\n- <span class=\"hljs-keyword\">for</span> students <span class=\"hljs-keyword\">with</span> the same math score, sort by science score\n</code></pre>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>이를 수행하기 위해서는 우리의 주요 함수는 단순히 튜플 (첫 번째 조건, 두 번째 조건)을 반환하면 됩니다. 이 경우에는 (수학 점수, 과학 점수)가 될 것입니다.</p>\n<pre><code class=\"hljs language-js\">students.<span class=\"hljs-title function_\">sort</span>(key=lambda <span class=\"hljs-attr\">x</span>:(x[<span class=\"hljs-string\">'math'</span>], x[<span class=\"hljs-string\">'science'</span>]) )\n\n<span class=\"hljs-title function_\">print</span>(students)\n\n<span class=\"hljs-string\">''</span><span class=\"hljs-string\">'\n[\n  {'</span>name<span class=\"hljs-string\">': '</span>D<span class=\"hljs-string\">', '</span>math<span class=\"hljs-string\">': 80, '</span>science<span class=\"hljs-string\">': 91},\n  {'</span>name<span class=\"hljs-string\">': '</span>F<span class=\"hljs-string\">', '</span>math<span class=\"hljs-string\">': 80, '</span>science<span class=\"hljs-string\">': 92},\n  {'</span>name<span class=\"hljs-string\">': '</span>E<span class=\"hljs-string\">', '</span>math<span class=\"hljs-string\">': 80, '</span>science<span class=\"hljs-string\">': 93},\n  {'</span>name<span class=\"hljs-string\">': '</span>B<span class=\"hljs-string\">', '</span>math<span class=\"hljs-string\">': 100, '</span>science<span class=\"hljs-string\">': 71},\n  {'</span>name<span class=\"hljs-string\">': '</span>A<span class=\"hljs-string\">', '</span>math<span class=\"hljs-string\">': 100, '</span>science<span class=\"hljs-string\">': 81},\n  {'</span>name<span class=\"hljs-string\">': '</span>C<span class=\"hljs-string\">', '</span>math<span class=\"hljs-string\">': 100, '</span>science<span class=\"hljs-string\">': 91}\n]\n'</span><span class=\"hljs-string\">''</span>\n</code></pre>\n<p>그리고 여기서, 수학 점수가 동일한 학생들은 과학 점수에 의해 정렬됨을 주목해 보세요.</p>\n<p>참고 — 3가지 조건에 따라 정렬하려면, 단순히 (첫 번째 조건, 두 번째 조건, 세 번째 조건)의 튜플을 반환하면 됩니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h1>결론</h1>\n<p>이 내용이 명확하고 이해하기 쉬웠으면 좋겠어요!</p>\n<h1>친구들을 위한 Python 농담</h1>\n<h1>만약에 제작자로서 저를 지원하고 싶다면</h1>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>제 책을 구입해 주세요! — 101 Things I Never Knew About Python</li>\n<li>확인할 수 있는 곳: <a href=\"https://payhip.com/b/vywcf\" rel=\"nofollow\" target=\"_blank\">여기</a></li>\n<li>이 이야기를 위해 50번 클랩을 해주세요</li>\n<li>댓글로 당신의 생각을 남겨주세요</li>\n<li>이야기 중 가장 좋아하는 부분을 강조해주세요</li>\n</ul>\n<p>감사합니다! 이런 작은 행동이 큰 도움이 되고, 정말 감사드립니다!</p>\n<p>YouTube: <a href=\"https://www.youtube.com/@zlliu246\" rel=\"nofollow\" target=\"_blank\">여기</a></p>\n<p>LinkedIn: <a href=\"https://www.linkedin.com/in/zlliu/\" rel=\"nofollow\" target=\"_blank\">여기</a></p>\n</body>\n</html>\n"},"__N_SSG":true}