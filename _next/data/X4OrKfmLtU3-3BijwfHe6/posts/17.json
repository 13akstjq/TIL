{"pageProps":{"posts":[{"title":"파이썬 API를 사용한 주식 순위를 위한 기본적 분석 방법","description":"","date":"2024-07-14 23:59","slug":"2024-07-14-FundamentalAnalysisforrankingStockswithPythonAPI","content":"\n\n이 기사에서는 기초 및 주식 세부 정보에 따라 주식을 순위로 나열할 것입니다. 이 접근 방식은 기존 기사 \"Python API를 사용한 기초 주식 분석\"에서 주식 그룹의 평균과 표준 편차를 기반으로 비율에 대한 점수 방법을 적용합니다.\n\n면책 조항: 여기서 제공된 정보는 정보 목적으로만 제공되며 개인 재정, 투자 또는 기타 조언을 의도한 것이 아닙니다.\n\n이 기사에서 사용되는 주요 비율은 다음과 같습니다:\n\n- EPS (주당순이익) — 회사 이익 중 각 주식에 할당된 부분\n- PE (주가 수익 비율) — 회사의 주가와 주당 순이익 간 관계. 투자자가 해당 섹터의 다른 종목에 비해 주식이 저평가되었는지 또는 고평가되었는지 판단하는 데 도움이 됩니다.\n- PEG (예상 이익 성장률) — 주식의 P/E를 예상된 12개월 수익 성장률로 나눈 것. 일반적으로 1보다 낮은 PEG는 좋은 신호이며, 2보다 높은 PEG는 주식이 과도 가격화될 수 있음을 나타냅니다.\n- PB (주가순자산가치비율) — 1의 비율은 회사의 주식이 순자산가치에 준하는 가격에 거래되고 있음을 나타냅니다. 1보다 높은 P/B는 회사가 순자산가치에 프리미엄을 지불하고 있음을 시사하며, 1보다 낮은 비율은 회사 자산에 비해 저평가된 주식을 나타낼 수 있습니다.\n- ROE (자기자본이익률) — 회사가 자산을 이용하여 이익을 창출하는 데 효과적으로 활용하는 방법을 투자자에게 제공합니다. 더 높은 ROE는 주주 자본을 더 효과적으로 활용하고 주식 수요 증가 및 미래 이익 증가, 그리고 주가 상승으로 이어질 수 있음을 나타냅니다.\n- ROCE (총 자본 대지수이익률) — 모든 자본을 기준으로 회사의 수익성을 측정합니다.\n- FCFY (재무건전도 비율) — 회사가 주당 기대하는 영업현금흐름과 주당 시장가치를 비교하는 지표. 낮은 비율은 덜 매력적인 투자 기회를 나타냅니다.\n- D2E (부채대자본비) — 회사의 총부채를 자기자본과 비교합니다.\n- CR (유동비율) — 회사가 유동자산(1년 이내 지급 예정 금액)으로 현재 부채를 갚을 수 있는 능력을 측정합니다. 비율이 높을수록 회사의 유동성이 더 좋습니다.\n- QR (당좌비율) — 회사가 재고를 판매하거나 추가 자금을 조달하지 않고 현재 부채를 갚을 수 있는 능력을 측정합니다.\n- 자산TO (자산회전율) — 회사 자산이 매출이나 수익을 생성하는 효율성을 측정합니다.\n- DY (배당수익률) — 회사가 매년 배당으로 지급하는 금액을 주가에 상대적으로 측정한 비율. 이는 주식 투자의 배당수익률을 추정한 지표입니다.\n- 베타 — 주식의 시장 전체 대비 변동성을 측정하는 지표. 시장보다 더 많이 변동하는 주식은 1.0보다 높은 베타를 가집니다. 시장보다 변동성이 낮은 주식은 1.0보다 낮은 베타를 가집니다.\n- 52주 범위 — 52주 저점에 가까운 주식과 52주 고점에 가까운 주식을 나타내는 시각화 지표. 예를 들어, 90%는 현재 가격이 52주 고점에 매우 가깝다는 것을 나타냅니다.\n- 점수 — 각 주식의 비율 점수 합계\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 데이터 접근\n\n우리는 yfinance API를 활용하여 Yahoo Finance에서 데이터를 수집할 것입니다. 티커의 info 구성 요소는 여러 구성 요소 중 하나인 (예: 손익 계산서, 현금 흐름 등) 가장 많은 비율들을 제공할 것입니다.\n\n우리는 finviz screener를 웹 스크레이핑하여 관련 주식 심볼 목록을 얻을 것입니다. 연구가 동일 산업의 이상적으로 비슷한 주식 그룹에서 수행되어야 합니다.\n\n코드는 GitHub의 Jupyter 노트북으로 사용 가능합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## Python 라이브러리\n\n다음은 필수 Python 라이브러리입니다:\n\n- yfinance — 금융 시장 데이터에 접근하기 위함\n- pandas — 데이터 프레임\n- numpy — np.nan을 사용함\n- requests — http 요청을 만들기 위함\n- BeautifulSoup — 웹 스크래핑에 사용됨\n- statistics — 표준편차와 평균을 계산하기 위함\n\n## 라이브러리 가져오기\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\n# 주식 정보 읽기\nimport yfinance as yf\n\n# DataFrame을 위해\nimport pandas as pd\nimport numpy as np\n\n# finviz를 파싱하기 위해\nimport requests\nfrom bs4 import BeautifulSoup\n\n# 표준 편차와 평균을 계산하기 위해\nimport statistics\n```\n\n## 비율 카테고리\n\n비율은 두 그룹으로 나뉩니다: 카테고리 1에는 낮은 값을 선호하는 비율들이 포함되고, 카테고리 2에는 높은 값을 선호하는 비율들이 포함됩니다. 주가 이익비율 (P/E)은 카테고리 1의 예시 비율입니다. 낮은 P/E 비율은 회사가 저렴하거나 역사적 패턴과 비교하여 잘 수행하고 있다는 것을 시사할 수 있습니다. 현금비율 (CR)은 카테고리 2의 예시로, 높은 CR 점수가 바람직합니다. 우리는 거래가 덜 변동적인 회사에 더 관심이 있으므로 베타 점수는 카테고리 1에 속합니다. 그러나 만약 높은 변동성을 가진 회사에 더 관심이 있다면 카테고리 2로 이동할 수 있습니다.\n\n```python\n# 카테고리 1 비율 점수 - 낮을수록 더 좋음\nCAT1_RATIOS = ['D2E', 'PEG', 'PE fwd', 'PB', 'Beta']\n\n# 카테고리 2 비율 점수 - 높을수록 더 좋음\nCAT2_RATIOS = ['ROCE', 'ROE', 'FCFY', 'CR', 'QR', 'Asset TR', 'EPS fwd']\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 주식 심볼\n\n이전에 언급한대로, 관련 주식 심볼 목록을 얻기 위해 finviz 스크리너를 사용할 것입니다. 아래 코드는 예를 들어, 시가총액이 20억 달러 이상인 \"관리되는 가스\" 산업의 \"유틸리티\" 섹터 기업을 위한 필터를 활용하는 것입니다. 요청 매개변수 \"f\"에는 아래와 같이 필터 값을 받습니다.\n\n```js\ndef get_symbols():\n    req = requests.get('https://finviz.com/screener.ashx',\n        params={\n            'v': '111',\n            'f': 'cap_midover,ind_utilitiesregulatedgas',\n            'o': 'company',\n        },\n        headers={\n            'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',\n        })\n    # BeautifulSoup 객체 생성\n    soup = BeautifulSoup(req.text, 'html.parser')\n    \n    # 관심 있는 테이블\n    table = soup.find('table', class_='styled-table-new is-rounded is-tabular-nums w-full screener_table')\n    # 심볼 수집 배열\n    symbols = []\n    for i, row in enumerate(table.find_all('tr')):\n        # 헤더 행은 건너뛰기\n        if i != 0:\n            # 행에서 반복\n            for j, td in enumerate(row.find_all('td')):\n                # 심볼은 두 번째 열에 있음\n                if j == 1:\n                    symbols.append(td.text.strip())\n                    break\n    return symbols\n```\n\n## 주식 심볼 가져오기\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 유틸리티 메소드를 호출하여 symbols 변수를 채우세요.\n\n```js\nsymbols = get_symbols()\n```\n\nget_symbols 함수를 사용하지 않고 이미 주식 심볼 집합을 알 경우 symbols 변수를 초기화할 수도 있습니다. 아래와 같이 표시됩니다:\n\n```js\nsymbols = ['ATO', 'NI', ]\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n## 비율 계산하기\n\n먼저 유틸리티를 정의하여 yfinance API의 info 메서드를 활용하여 비율을 계산하고 채워넣습니다.\n\n```python\ndef populate_with_info(data, stock_info):\n    # print(stock_info)\n    data['Symbol'].append(stock_info['symbol'])\n    data['Name'].append(stock_info['longName'])\n    \n    # 숫자를 가독성 좋은 형식으로 변환합니다\n    data['Market Cap'].append(human_format(stock_info['marketCap']))\n    data['Price'].append(stock_info['currentPrice'])\n\n    # 사용 가능한 지표가 없을 수도 있습니다; 그런 경우 NaN을 사용합니다\n    \n    # 가치 평가 비율\n    \n    if 'priceToBook' in stock_info:\n        data['PB'].append(stock_info['priceToBook'])\n    else:\n        data['PB'].append(np.nan)\n    \n    if 'forwardEps' in stock_info:\n        data['EPS fwd'].append(stock_info['forwardEps'])\n    else:\n        data['EPS fwd'].append(np.nan)\n        \n    if 'forwardPE' in stock_info:\n        data['PE fwd'].append(stock_info['forwardPE'])\n    else:\n        data['PE fwd'].append(np.nan)\n        \n    if 'pegRatio' in stock_info:\n        data['PEG'].append(stock_info['pegRatio'])\n    else:\n        data['PEG'].append(np.nan)\n        \n    # 신뢰성 재무 비율\n    \n    if 'debtToEquity' in stock_info:\n        data['D2E'].append(stock_info['debtToEquity'])\n    else:\n        data['D2E'].append(np.nan)\n\n    # 수익성 비율\n    \n    if 'returnOnEquity' in stock_info:\n        data['ROE'].append(stock_info['returnOnEquity'])\n    else:\n        data['ROE'].append(np.nan)\n    \n    if ('freeCashflow' in stock_info) and ('marketCap' in stock_info):\n        fcfy = (stock_info['freeCashflow']/stock_info['marketCap']) * 100\n        data['FCFY'].append(round(fcfy, 2))\n    else:\n        data['FCFY'].append(np.nan)\n\n    # 유동성 비율\n    \n    if 'currentRatio' in stock_info:\n        data['CR'].append(stock_info['currentRatio'])\n    else:\n        data['CR'].append(np.nan)\n\n    if 'quickRatio' in stock_info:\n        data['QR'].append(stock_info['quickRatio'])\n    else:\n        data['CR'].append(np.nan)\n\n    # 기타 정보 (비 비율)\n    \n    if 'dividendYield' in stock_info:\n        data['DY'].append(stock_info['dividendYield']*100)\n    else:\n        data['DY'].append(0.0)\n\n    if 'beta' in stock_info:\n        data['Beta'].append(stock_info['beta'])\n    else:\n        data['Beta'].append(np.nan)\n\n    if 'fiftyTwoWeekLow' in stock_info:\n        data['52w Low'].append(stock_info['fiftyTwoWeekLow'])\n    else:\n        data['52w Low'].append(np.nan)\n        \n    if 'fiftyTwoWeekHigh' in stock_info:    \n        data['52w High'].append(stock_info['fiftyTwoWeekHigh'])\n    else:\n        data['52w High'].append(np.nan)\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n비율을 찾을 수 없는 경우, NaN으로 사전에 추가됩니다. 비율이 NaN으로 설정된 주식은 제거됩니다. 또한 이 방법은 숫자를 사람이 읽을 수 있는 형식으로 변환하는 유틸리티 메서드를 활용합니다. 예를 들어, 5B(십억), 5M(백만) 등으로 표시됩니다.\n\n```js\ndef human_format(num):\n    num = float('{:.3g}'.format(num))\n    magnitude = 0\n    while abs(num) >= 1000:\n        magnitude += 1\n        num /= 1000.0\n    return '{}{}'.format('{:f}'.format(num).rstrip('0.'), ['', 'K', 'M', 'B', 'T'][magnitude])\n```\n\n마지막으로, 재무상태표와 손익계산서를 사용하여 비율을 계산하는 추가 기법 집합이 있습니다.\n\n```js\ndef roce(ticker):\n    income_stm = ticker.income_stmt\n    ebit = income_stm.loc['EBIT'].iloc[0]\n    bs = ticker.balance_sheet\n    return ebit/(bs.loc['Total Assets'].iloc[0]-bs.loc['Current Liabilities'].iloc[0])\n\ndef asset_turnover_ratio(ticker):\n    df_bs = ticker.balance_sheet\n    y0, y1 = df_bs.loc['Total Assets'].iloc[0], df_bs.loc['Total Assets'].iloc[1]\n    avg_asset = (y0 + y1)/2\n    tot_rvn_y0 = ticker.income_stmt.loc['Total Revenue'].iloc[0]/avg_asset\n    return tot_rvn_y0\n\ndef investory_turnover_ratio(ticker):\n    df_bs = ticker.balance_sheet\n    y0, y1 = df_bs.loc['Inventory'].iloc[0], df_bs.loc['Inventory'].iloc[1]\n    avg_inventory = (y0 + y1)/2\n    return ticker.income_stmt.loc['Cost Of Revenue'].iloc[0]/avg_inventory\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 지표 수집\n\n주식 심볼에 대한 각 지표를 딕셔너리에 추가해 보겠습니다.\n\n```js\n# 나중에 DF를 만들기 위한 데이터 수집 딕셔너리\ndata = {\n    'Symbol': [],\n    'Name': [],\n    'Market Cap': [],\n    'EPS fwd': [],\n    'PE fwd': [],\n    'PEG': [],\n    'PB': [],\n    'ROE' : [],\n    'ROCE' : [],\n    'FCFY' : [],\n    'D2E' : [],\n    'CR' : [],\n    'QR' : [],\n    'Asset TR': [],\n    'DY' : [],\n    'Beta': [],\n    'Price': [],\n    '52w Low': [],\n    '52w High': []\n    }\nindustry = ''\n\nfor symbol in symbols:\n    ticker = yf.Ticker(symbol)\n    if not industry:\n        industry = ticker.info['industry']\n    else:\n        industry_current = ticker.info['industry'] \n        if industry_current != industry:\n            print(f'다른 산업 {industry_current}을(를) 만났습니다, 이전 산업 {industry}입니다. 중단합니다.')\n            break        \n    populate_with_info(data, ticker.info)\n    data['ROCE'].append(roce(ticker))\n    data['Asset TR'].append(asset_turnover_ratio(ticker))\n```\n\n이전에 언급한대로, 이 방법에는 현재 주식의 산업이 이전 주식의 산업과 다른지 간단히 확인하는 절차가 포함되어 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## DataFrame 생성하기\n\n```js\n# 사전을 사용하여 DF 생성\ndf = pd.DataFrame(data)\n\n# NaN 값을 가진 주식 저장\ndf_exceptions = df[df.isna().any(axis=1)]\n\n# NaN 값을 가진 주식 제거\ndf = df.dropna()\n\n# NaN 값을 가진 행을 삭제한 후 인덱스 재설정\ndf.reset_index(drop=True, inplace=True)\n\n# 52주간 가격 범위 추가\ndf['52주 범위'] = ((df['가격'] - df['52주 최저가']) / (df['52주 최고가'] - df['52주 최저가'])) * 100\n\ndf_exceptions\n```\n\nNaN으로 설정된 비율이 있는 주식은 제거되고, 예외 DataFrame에 저장됩니다. 마지막으로 52주 가격 범위가 포함될 것입니다.\n\n<img src=\"/TIL/assets/img/2024-07-14-FundamentalAnalysisforrankingStockswithPythonAPI_0.png\" />\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\"그리고 비예외 주식에 대한 결과는:\n\n![Fundamental Analysis](/TIL/assets/img/2024-07-14-FundamentalAnalysisforrankingStockswithPythonAPI_1.png)\n\n## 점수\n\n다음 단계는 원시 데이터에 점수를 적용하는 것입니다.\"\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ndef score(values, value, cat) -> int:\n    '''\n    카테고리에 따라 표준 편차와 평균을 기반으로 점수를 계산합니다. 낮은 값을 선호하는 PE와 같은 비율의 경우, 다음과 같이 점수가 계산됩니다:\n    1. 주어진 PE가 -1 표준 편차와 평균 사이에 있는 경우 1점 반환\n    2. 주어진 PE가 -2 표준 편차와 -1 표준 편차 사이에 있는 경우 2점 반환\n    3. PE가 -2 표준 편차를 벗어나는 경우 3점 반환\n    4. 주어진 PE가 1 표준 편차와 평균 사이에 있는 경우 -1점 반환\n    5. 주어진 PE가 +1 표준 편차와 +2 표준 편차 사이에 있는 경우 -2점 반환\n    6. 주어진 PE가 +2 표준 편차를 벗어나는 경우 -3점 반환\n\n    높은 값을 선호하는 ROE와 같은 비율의 경우, 다음과 같이 점수가 계산됩니다:\n    1. 주어진 ROE가 평균과 +1 표준 편차 사이에 있는 경우 1점 반환\n    2. 주어진 ROE가 +1 표준 편차와 +2 표준 편차 사이에 있는 경우 2점 반환\n    3. ROE가 +2 표준 편차를 벗어나는 경우 3점 반환\n    4. 주어진 ROE가 -1 표준 편차와 평균 사이에 있는 경우 -1점 반환\n    5. 주어진 ROE가 -1 표준 편차와 -2 표준 편차 사이에 있는 경우 -2점 반환\n    6. 주어진 ROE가 -2 표준 편차를 벗어나는 경우 -3점 반환\n\n    Parameters\n    ----------\n    values : 값들의 목록\n    value: 평균, 1 표준 편차, -1 표준 편차, 2 표준 편차 또는 -2 표준 편차 내에 있는지 확인할 값\n    cat: 카테고리 유형, 유효한 값은 1 또는 2입니다.\n        \n    Returns\n    -------\n    score: 주어진 'value'에 대한 점수\n    '''\n    \n    std = statistics.stdev(values)\n    mean = statistics.mean(values)\n\n    if cat == 1:\n        if (mean + (-1 * std)) < value <= mean:\n            return 1\n        elif (mean + (-2 * std)) < value <= (mean + (-1 * std)):\n            return 2\n        elif value <= (mean + (-2 * std)):\n            return 3\n        elif mean < value <= (mean + (1 * std)):\n            return -1\n        elif (mean + (1 * std)) < value <= (mean + (2 * std)):\n            return -2\n        else:\n            return -3\n    else:\n        if mean <= value < (mean + (1 * std)):\n            return 1\n        elif (mean + (1 * std)) <= value < (mean + (2 * std)):\n            return 2\n        elif value >= (mean + (2 * std)):\n            return 3\n        elif (mean + (-1 * std)) <= value < mean:\n            return -1\n        elif (mean + (-2 * std)) <= value < (mean + (-1 * std)):\n            return -2\n        else:\n            return -3\n```\n\n요약하면 다음과 같이 카테고리 1의 비율에 제공되는 값에 대해 다음 점수가 반환됩니다: (평균 - 1 * 표준 편차)과 평균 사이에 비율이 있는 경우 1; (평균 - 2 * 표준 편차)와 (평균 - 1 * 표준 편차) 사이에 비율이 있는 경우 2; (평균 - 2 * 표준 편차)보다 작은 경우 3; 그 반대 경우에는 음수 값이 반환됩니다. 카테고리 2도 비슷한 절차를 따르지만 반대 방향으로 작동합니다. 이러한 점수는 어느 정도 임의적이며, 이상값은 최대 또는 최소 점수를 받습니다. 이상값으로 인한 편향을 제거하려면, 이상값에 대한 점수를 조정하여, 예를 들어 평균 - 2 * 표준 편차보다 낮은 비율의 경우 0을 반환하는 등의 조치를 취할 수 있습니다.\n\n점수 부여를 적용하고, 두 카테고리에 대해 제공된 각 비율에 대한 점수를 합산하는 열을 추가합니다.\n\n```js\ndf_score = df.copy()\n\nfor col in CAT1_RATIOS:\n    for index, value in df[col].items():\n        # print(f'{col} - {index} - {value}')\n        df_score.loc[index, col] = score(df[col], value, 1)\n\nfor col in CAT2_RATIOS:\n    for index, value in df[col].items():\n        # print(f'{col} - {index} - {value}')\n        df_score.loc[index, col] = score(df[col], value, 2)\n\n# 총점을 얻기 위해 순위 점수를 추가\ndf_score['Score'] = df_score[CAT1_RATIOS+CAT2_RATIOS].sum(axis=1)\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ndef make_pretty(styler):\n    # 열 형식 지정\n    styler.format({'EPS fwd': '{:.0f}', 'PE fwd': '{:.0f}', 'PEG': '{:.0f}', 'FCFY': '{:.0f}', 'PB': '{:.0f}', 'ROE': '{:.0f}',\n                   'ROCE': '{:.0f}', 'D2E': '{:.0f}', 'CR': '{:.0f}', 'QR': '{:.0f}', 'Asset TR': '{:.0f}', 'DY': '{:.2f}%',\n                   'Beta': '{:.0f}', '52w Low': '${:.2f}', 'Price': '${:.2f}', '52w High': '${:.2f}', '52w Range': '{:.2f}%', 'Score': '{:.0f}'\n                  })\n\n    # 바 시각화 설정\n    styler.bar(subset=['52w Range'], align=\"mid\", color=[\"salmon\", \"cornflowerblue\"])\n\n    # 그리드\n    styler.set_properties(**{'border': '0.1px solid black'})\n\n    # 배경 그라데이션 설정\n    for ratio in CAT1_RATIOS:\n        styler.background_gradient(subset=[ratio], cmap='RdYlGn', gmap=-df[ratio])\n    for ratio in CAT2_RATIOS:\n        styler.background_gradient(subset=[ratio], cmap='RdYlGn')\n    styler.background_gradient(subset=['Score'], cmap='PiYG')\n    \n    # 인덱스 숨기기\n    styler.hide(axis='index')\n\n    # 일부 열에 대해 왼쪽 텍스트 정렬\n    styler.set_properties(subset=['Symbol', 'Name'], **{'text-align': 'left'})\n    styler.set_properties(subset=CAT1_RATIOS + CAT2_RATIOS + ['Market Cap', 'Score'], **{'text-align': 'center'})\n\n    return styler\n```\n\n마지막으로, DataFrame에 스타일을 추가합니다:\n\n```js\n# DF에 테이블 캡션 및 스타일 추가\ndf_score.style.pipe(make_pretty).set_caption(f'{industry} 주식 스크리너').set_table_styles(\n    [{'selector': 'th.col_heading', 'props': 'text-align: center'},\n     {'selector': 'caption', 'props': [('text-align', 'center'),\n                                       ('font-size', '11pt'), ('font-weight', 'bold')]}])\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/TIL/assets/img/2024-07-14-FundamentalAnalysisforrankingStockswithPythonAPI_2.png)\n\n시가총액이 20억 달러 이상인 ATO와 SR은 “Regulated Gas” 산업 중 모든 주식 중에서 가장 높은 점수를 받은 두 가지 유틸리티 섹터 주식입니다. 그러나 ATO의 가격은 현재 52주 최고가에 더 가깝고, SR의 가격은 52주 최저가에 더 가깝습니다.\n\n여러 비율이 현재 주식 가격에 의존하기 때문에 결과는 노트북을 호출하는 시점에 따라 변할 수 있습니다.\n\n## 결론\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 기사에서는 기초 분석 기반의 주식 순위 결정 방법을 설명하며, 이 방법은 주식 그룹의 평균과 표준 편차를 기반으로 각 비율에 점수를 할당합니다.\n\n분석 목적상, 대부분의 비율은 비슷한 주식 그룹 내에서만 의미가 있는 경우가 많으므로 관련된 주식 그룹을 선택하는 것이 중요합니다.\n\n평가 시스템이 임의적이지만, 이 포스트가 가중 점수와 같은 다른 점수 시스템을 탐구하는 기초를 제시한다고 생각합니다.\n\n정보가 유익하게 느껴졌길 바라며, 피드백을 소중히 여깁니다.","ogImage":{"url":"/TIL/assets/img/2024-07-14-FundamentalAnalysisforrankingStockswithPythonAPI_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-FundamentalAnalysisforrankingStockswithPythonAPI_0.png","tag":["Tech"],"readingTime":19},{"title":"현재 핫한 GitHub 프로젝트 11선","description":"","date":"2024-07-14 23:58","slug":"2024-07-14-11TrendingGithubProjects","content":"\n\n오픈 소스 프로젝트는 현대 소프트웨어 생태계의 중요한 부분입니다. 이러한 이니셔티브는 소스 코드를 자유롭게 볼 수 있고 수정하고 배포할 수 있는 곳으로, 기술 산업 전반에 걸쳐 혁신과 협력을 촉진합니다.\n\n오픈 소스는 유용할 뿐만 아니라 필수적입니다. 이는 투명성을 촉진하여 동료 검토와 보안 취약성의 신속한 식별을 가능하게 합니다. 오픈 소스는 공유 지식의 문화를 조성하여 개발자들이 서로의 작업에서 배우고 발전할 수 있도록 돕습니다.\n\n## 추가로 읽어볼 내용:\n\n기본 기술 습득\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n6월 말을 위한 8가지 GitHub 프로젝트\n\n새롭고 인기 있는 엘릭서 저장소들\n\n인기있는 9가지 GitHub 프로젝트\n\n그리고 구독이 무료인 AI 뉴스레터 BrainScriblr도 운영 중이에요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저가 작성한 AI 노트 앱을 다룬 포스트가 있어요.\n\n## Graphrag\n\nMicrosoft Research에서 개발한 GraphRAG는 대규모 언어 모델(LLM)의 검색 및 생성 능력을 향상시키는 고급 검색-증강 생성(RAG) 기술입니다. 이는 지식 그래프를 활용하여 생성된 응답의 품질과 관련성을 개선합니다.\n\n벡터 데이터베이스에만 의존하는 대신, GraphRAG는 구조화된 지식 그래프를 활용하여 생성된 응답의 품질과 관련성을 개선합니다. 이는 텍스트 추출, 네트워크 분석, LLM 프롬프팅 및 요약을 통합한 단일 시스템으로, 복잡한 데이터 분석 및 자연어 처리 애플리케이션에 강력한 도구로 작용합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nGraphRAG의 중요한 기능 중 하나는 텍스트에서 계층적 지식 그래프를 구축하는 것이며, Leiden 알고리즘과 같은 계층적 클러스터링 기술을 사용하여 정보를 요약하며, 질의 시간에 LLM에게 환경적으로 풍부하고 관련성 높은 정보를 제공하는 향상된 검색 기능이 있습니다.\n\n이 접근 방식은 기본 RAG에 비해 상당한 장점을 제공합니다. 개선된 환경 이해력, 응답에 대한 증거 출처, 전체 데이터 질병 추론 수행 능력 등이 있습니다. 이는 비공개 데이터 집합을 분석하고 복잡한 질문을 처리하는 데 유용하며, 고급 챗봇, 가상 어시스턴트 및 상세한 데이터 분석 도구에 적합합니다.\n\n## Claude 엔지니어\n\nClaude 엔지니어는 Anthropic의 Claude-3.5-Sonnet 모델을 활용하는 명령줄 인터페이스(CLI)로, 소프트웨어 개발 작업을 보조합니다. Anthropic에 의해 개발되었으며, 상호작용형 채팅, 파일 시스템 작업, 웹 검색, 구문 강조, 프로젝트 구조 관리 및 코드 분석과 같은 기능이 통합되어 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nClaude Engineer는 다양한 기능을 강력한 CLI로 통합하여 작업 흐름을 최적화하고 생산성을 향상시키며 전반적인 소프트웨어 개발 경험을 개선합니다.\n\n## TorToiSe\n\nTortoise TTS는 neonbjb에 의해 개발된 오픈 소스 텍스트 음성 변환(TTS) 시스템입니다. 이 도구는 강력한 다중 음성 기능을 갖추어 매우 현실적이고 표현력이 풍부한 음성 합성을 생성하도록 설계되었습니다.\n\n이 시스템은 자동 회귀 및 확산 모델의 조합을 활용하여 텍스트를 자연스러운 음성으로 변환하며, 다양한 억양과 억양에 중점을 두고 있습니다. 또한 Tortoise TTS는 여러 언어를 지원하며 각각의 언어에 대해 많은 훈련 데이터가 필요하지 않고도 다양한 목소리를 모방할 수 있어 다양한 응용 프로그램에 유연하게 활용할 수 있는 도구입니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nTortoise TTS의 주요 기능은 제로샷 다중 음성 기능, 현실적인 프로소디와 억양, 몇 가지 예시를 기반으로 한 음성 클론 등이 있습니다. 또한 프로젝트 구조의 생성 및 관리를 지원하여 이 도구의 다재다능성을 향상시킵니다. Tortoise TTS는 높은 품질의 음성 합성으로 알려져 있지만, 처리 파이프라인이 복잡하기 때문에 병렬 TTS 모델에 비해 비교적 느립니다.\n\n## Omniparse\n\nOmniparse는 비구조적 데이터를 구조화된 형식으로 변환하여 AI 응용 프로그램에 최적화된 오픈 소스 플랫폼입니다.\n\n중요한 기능:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 다양한 데이터 유형 (문서, 이미지, 오디오, 비디오, 웹 페이지) 처리합니다.\n- 데이터 개인 정보 보호를 위해 로컬에서 작동합니다.\n- Docker 및 Skypilot을 통해 배포할 수 있습니다.\n- 사용자 친화적인 Gradio 인터페이스를 제공합니다.\n- OCR, 레이아웃 감지 및 전사용 고급 모델을 사용합니다.\n\n기능에는 테이블 추출, 이미지 캡션, 오디오/비디오 전사, 웹 크롤링, 스키마 기반 변환이 포함됩니다. 문서 처리, 미디어 분석, 웹 데이터 추출 및 AI 모델 준비에 이상적입니다.\n\nOmniparse는 Linux 시스템에 설치하고 Docker를 사용하여 실행할 수 있습니다. 생성적 AI 및 대규모 언어 모델이 포함된 응용 프로그램에 특히 유용합니다.\n\n![이미지](/TIL/assets/img/2024-07-14-11TrendingGithubProjects_0.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## OmniParser\n\n안녕하세요! OmniParser는 다양한 데이터 형식을 처리하기 위한 Go 언어의 오픈 소스 ETL 라이브러리입니다.\n\n중요한 기능:\n\n- 다양한 입력 형식 지원 (CSV, XML, EDI, JSON 등)\n- 성능을 위한 원시 Go 구현\n- 효율적인 처리를 위한 스트리밍 파서\n- 스키마 기반 변환\n- 복잡한 변환을 위한 사용자 정의 함수\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아주 유용한 내용이에요! 데이터 통합, ETL 프로세스, 데이터 정리, 그리고 API 데이터 처리에 활용할 수 있어요.\n\n이 프로젝트는 포괄적인 문서와 커뮤니티 기여를 환영해요.\n\n## Autogroq\n\nAutoGroq은 Autogen 및 CrewAI와 호환되는 플랫폼을 위해 AI 에이전트를 생성하고 관리할 수 있는 오픈 소스 도구에요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n시스템은 문제 분석 및 에이전트 생성을 위해 자연어 처리를 활용합니다. 다양한 언어 모델 및 내보내기 형식을 쉽게 통합할 수 있는 모듈식 아키텍처를 채택했습니다.\n\nAutoGroq는 온라인 데모(autogroq.streamlit.app)와 로컬 설치용 GitHub 저장소로 제공됩니다. 작동을 위해서 Groq 개발자 API 키가 필요합니다.\n\n이 도구의 아키텍처는 빠른 프로토타이핑, 워크플로 최적화 및 특화된 에이전트 생성을 용이하게 합니다. AI 기반 프로젝트 개발 및 테스트에 가치가 있는 도구입니다.\n\n![이미지](/TIL/assets/img/2024-07-14-11TrendingGithubProjects_1.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## OpenAGI\n\n오픈AGI는 자유로운 소스 플랫폼으로, 자율적 AI 에이전트의 개발과 배포를 진보시키기 위해 설계되었으며, 특히 대형 언어 모델 (LLMs)과 도메인 특화 전문 모델을 통합하는 데 중점을 두고 있습니다.\n\n오픈AGI는 LLMs의 기능과 계획, 추론, 자립적 행동이 가능한 자율 에이전트에 대한 필요 사이의 간극을 줄이려고 노력하고 있습니다. 이는 실제 세계 상황에서 복잡한 다단계 작업을 처리할 수 있는 AI 에이전트의 생성을 용이하게 하는 데 목표를 두고 있습니다.\n\n여기에는 OpenAGI의 작동 방식을 설명하는 논문이 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## Vanna\n\nVanna는 자연어를 사용하여 SQL 쿼리를 생성하는 오픈 소스 Python 프레임워크입니다. RAG(retrieval-augmented generation)를 사용하여 복잡한 데이터 세트에서 높은 정확도를 제공하며 데이터 프라이버시를 유지하고 다양한 SQL 데이터베이스를 지원합니다. Vanna는 데이터베이스 스키마와 샘플 쿼리를 학습하는 RAG 모델을 통해 자연어 질문에서 SQL을 생성합니다.\n\n이 프레임워크는 pip를 통해 쉽게 설치할 수 있으며 다양한 LLMs 및 벡터 데이터베이스와 함께 사용할 수 있습니다. Jupyter 노트북 및 Streamlit 앱을 포함한 여러 사용자 인터페이스 옵션을 제공합니다. Vanna는 LLMs나 벡터 데이터베이스의 사용자 지정 구현을 허용하도록 설계되어 확장 가능합니다.\n\nVanna는 활발한 커뮤니티 개발과 포괄적인 문서화를 통해 비기술적 사용자를 위한 데이터베이스 쿼리 작업을 간소화하고 신속한 프로토 타이핑을 용이하게 하며 데이터 분석 워크플로우를 향상시키는 것을 목표로 합니다. 데이터베이스 상호 작용을 보다 접근 가능하게 만드는 중요한 단계를 나타냅니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![image](/TIL/assets/img/2024-07-14-11TrendingGithubProjects_2.png)\n\n## Fine-tuning llama 3\n\nThis is a concept and not an open source project, but it is important to know this if you are building your own LLMs.\n\nFine-tuning Llama 3:\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 8B 및 70B 매개변수 버전으로 사용 가능\n- MMLU 및 HumanEval과 같은 벤치마크에서 높은 성능\n- 파인튜닝 방법: Full Parameter, LoRA, QLoRA\n- 도구: Unsloth, PyTorch FSDP, TRL\n- 과제: 베이스 모델 문제, 프롬프트 민감도\n- 권장 사항: LoRA/QLoRA부터 시작하고, 학습률과 배치 크기 최적화\n- 응용: 고객 지원 자동화, 의도 분류\n- 자원: Hugging Face, Unsloth, YouTube에서 제공하는 튜토리얼\n- 배포 시 윤리적 고려 사항 중요\n\nLlama 3의 파인튜닝은 과업별 모델의 가능성을 제공하지만, 적절한 하드웨어 및 방법 선택과 적절한 데이터 준비가 필요합니다.\n\n## TensorRT\n\nTensorRT는 NVIDIA가 개발한 오픈소스 딥러닝 추론 최적화 및 런타임 도구입니다. NVIDIA GPU에서 성능을 향상시키도록 설계되었으며, ONNX 및 TensorFlow SavedModel과 같은 다양한 입력 형식을 지원합니다. 이 소프트웨어는 레이어 퓨전 및 정밀도 보정과 같은 최적화 기술을 제공하며, C++ 및 Python API를 모두 지원합니다. 별도의 프로젝트인 TensorRT-LLM은 대규모 언어 모델의 최적화에 초점을 맞춥니다. 최신 버전인 TensorRT 10.1.0에는 파서, 플러그인 및 샘플 업데이트가 포함되어 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n커뮤니티 프로젝트들이 TensorRT의 기능을 확장하여 PyTorch와 같은 프레임워크와 통합했습니다. TensorRT 자체는 프로프리어터리이지만, 오픈 소스 구성 요소는 다양한 라이선스로 제공됩니다. NVIDIA 하드웨어에서 딥 러닝 추론을 최적화하려는 개발자들에게 TensorRT는 강력한 해결책을 제공하며, 강력한 커뮤니티 지원과 지속적인 개발을 제공합니다.\n\n## 홈 어시스턴트 코어\n\n홈 어시스턴트 코어는 홈 어시스턴트 생태계의 기반이되는 오픈 소스 홈 자동화 플랫폼으로서, 로컬 제어 및 개인 정보 보호에 중점을 두고 있습니다.\n\n다양한 운영 체제에서 스마트 홈 기기를 추적, 제어 및 자동화하는 Python 기반 프로그램입니다. 홈 어시스턴트 코어는 로컬 작동, 다양한 기기 지원, 자동화 기능 및 사용자 정의 대시보드를 제공합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n사용자들은 홈 어시스턴트 코어를 홈 어시스턴트 운영 시스템, 컨테이너 기반 설치, 지도된 설치, 또는 Python 가상 환경을 사용한 수동 설정과 같은 다양한 방법으로 설치할 수 있습니다. 해당 프로젝트는 강력한 커뮤니티를 가지고 있으며, GitHub에서 소스 코드를 제공하고 정기적으로 업데이트됩니다.\n\n오픈 소스 프로젝트는 소프트웨어 산업에서 계속해서 주요 동력이 되고 있습니다. 이들은 협업, 투명성, 혁신이라는 기본적인 원칙을 구현하며 기술 발전을 위해 필수적인 가치를 내포하고 있습니다.\n\n다양한 프로젝트들을 통해 확인할 수 있듯이, 오픈 소스 솔루션은 종종 품질, 보안, 기능 면에서 사유 소스 제품을 능가하거나 맞먹습니다.\n\n오픈 소스 모델은 개인 개발자와 기업 뿐만 아니라 기술 커뮤니티와 사회 전반에도 이익을 제공합니다. 강력한 도구와 기술에 대한 접근성을 둘려주며, 모든 규모의 개인 및 조직들이 혁신하고 경쟁할 수 있는 수준 playing field에서 수행할 수 있도록 합니다.","ogImage":{"url":"/TIL/assets/img/2024-07-14-11TrendingGithubProjects_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-11TrendingGithubProjects_0.png","tag":["Tech"],"readingTime":11},{"title":"퀀트를 위한 블랙-숄즈 모델 완벽 가이드","description":"","date":"2024-07-14 23:55","slug":"2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants","content":"\n\n\n![Black-Scholes Model for Options Pricing](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_0.png)\n\n백만 달러의 방정식: 옵션 가격에 대한 블랙-숄즈 모델입니다. 금융 분야에서 일하거나 공부한 적이 있다면, 아마도 이 이름을 듣거나 귀띔해 본 적이 있을 것입니다. 전문화 수준에 따라 옵션의 가격을 근사하거나, 투자 결정을 내리는 데 직접 사용했을 수도 있습니다. 다음과 같은 방정식 중에서 가장 익숙한 것은 다음과 같을 것입니다:\n\n![Equation 1](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_1.png)\n\n![Equation 2](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_2.png)\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n비록 다소 복잡한 방정식으로 보일 수 있지만, 원칙적으로는 실제로 사용하기 굉장히 간단합니다: 플러그 앤 플레이 방식이죠. 매개변수를 알고 있거나 추정할 수 있다면, 방정식에 그 값들을 넣어서 콜옵션이나 풋옵션의 해당 가격을 얻을 수 있습니다. 그리고 이 정보를 활용해서 시장 가격과 비교하거나, 다양한 매개변수로 다양한 투자 시나리오를 시뮬레이션하고, 떠오르는 모든 아이디어들을 실행할 수 있습니다.\n\n그렇지만 만약 저처럼 좀 호기심 많은 사람이거나, 양자 분야에 관심이 있거나, 양자 세계에 진출하고 싶다면 한 가지 의문을 품고 계셨을 것입니다: 이 방정식은 어째서 나왔는 걸까요?\n\n본 문서에서는 양자의 시각에서 블랙-숄즈 모델에 대한 깊은 탐구를 할 것입니다. 주의: 앞으로 많은 수학이 나옵니다! 만약 실용적인 투자 기술을 찾고 있다면, 유감스럽지만 이 글은 아닙니다. 그러나 양자 인터뷰를 준비하고 있거나, 양자금융에 관심이 있으며 주제에 대한 깊은 이해를 원한다면 당신을 위한 이야기가 될 것입니다. 확률 미적분 및 금융 수학에 대한 일정 수준의 지식이 필요합니다. 함께 시작해봐요!\n\n## 블랙-숄즈 SDE\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n옵션 가격 측정에 들어가기 전에, Black-Scholes 모델에서 가정된 기초 자산 가격 프로세스의 확률적 동역학을 먼저 살펴봅시다:\n\n![이미지1](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_3.png)\n\n![이미지2](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_4.png)\n\n이 확률적 미분 방정식(SDE)을 이해하는 방법은 다음과 같습니다: 기초 자산 S의 가격(LHS)의 연속적인 변화는 결정적 시간 구성요소(드리프트)와 확률적 구성 요소(확산)에 의존합니다. 이 가격 모델은 기하 브라운 운동(GBM)으로도 알려져 있습니다. 비교적 간단하지만 올바르게 사용할 때 시장에서 관측되는 가격과 유사한 확률 과정을 근사화해줍니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_5.png)\n\n특정 시간 t에서의 가격에 대한 명시적 공식을 유도할 수 있다는 사실을 알 수 있습니다:\n\n![image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_6.png)\n\n이 형태에서 브라운 운동의 특성을 기반으로 분포를 추론할 수 있습니다. 그러나 이 공식을 어떻게 얻을 수 있을까요? 여기서 우리의 친구인 확률 미적분학의 이토 레마가 도움이 됩니다.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## Black-Scholes SDE 해결하기\n\nSDE를 해결하기 위해서 가장 사용하기 좋은 도구는 보통 이토의 렘마입니다. 이토 프로세스를 고려해 봅시다:\n\n![image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_7.png)\n\n이전과 매우 유사한 가격 역학을 보여주지 않나요? 이토의 렘마는 다음과 같이 규정합니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![이미지](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_8.png)\n\n따라서 우리가 연속적이고 두 번 미분 가능한 함수 f의 올바른 선택을 찾을 수 있다면 S_t에 대한 식을 구할 수 있습니다. 이전의 SDE를 한 번 더 살펴봅시다:\n\n![이미지](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_9.png)\n\n![이미지](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_10.png)\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nIto의 보조정리를 적용하면 f(s) = ln(s)일 때,\n\n![image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_11.png)\n\n에서 우리가 사용해야 하는 도함수들이 있습니다. 이를 공식에 대입하고 간소화하면 다음과 같은 해답이 도출됩니다:\n\n![image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_12.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이곳에서 하는 일은 모든 용어를 매칭하고 미분을 대체하는 것입니다. 세 번째 줄에서는 어디에나 적분을 한 다음 남은 적분을 해결합니다. 브라운 운동에 대한 적분은 W_u에 의존하지 않습니다. 따라서 그 자체로 B.M.이 됩니다. 확률적 적분 및 미분에 익숙하지 않다면 Quantstart의 멋진 글을 읽어보세요.\n\n결과적인 가격의 중요한 특성 중 하나는 로그-정규 분포를 따른다는 것이며, S_t의 로그가 정규 분포를 따른다는 것으로 나타낼 수 있습니다:\n\n![image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_13.png)\n\n추신으로, 로그 수익도 정규 분포를 따릅니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_14.png)\n\nAlthough I won’t go through the derivations here, this will be important in deriving the actual Black-Scholes pricing formulas that we saw at the beginning.\n\nRisk-Neutral Stochastic Dynamics\n\nWhen pricing derivatives, financial mathematics and stochastic calculus tell us that we can assume that all assets grow and can be discounted at the risk-free rate, giving a “fair price”. To understand how this works from a practical point of view, I recommend reading this article. From a theoretical perspective, this corresponds to the The First Fundamental Theorem of Asset Pricing. Thus, in order to price anything, we need to transform our price model to the risk-neutral world.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n두 가지 주요 개념을 기억해 봅시다: Radon-Nykodym 도함수 과정과 Girsanov의 정리.\n\n![image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_15.png)\n\nMeasure 변경 정리는 위의 속성을 가진 확률 변수가 존재하여 실제 확률 측도 P를 기반으로 한 확률 측도 Q(\"리스크 중립\" 측도)를 구성할 수 있다는 것을 말해줍니다. 그러나 이것을 일반적인 확률 과정에 확장하는 방법은 어떻게 될까요? 다음 정리는 Radon-Nykodym 도함수를 기반으로 한 과정의 존재를 알려줍니다:\n\n![image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_16.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n본 정의는 각 시간 단계 t에서 Radon-Nykodym 도함수가 적용되며, 더 나아가 이 도함수는 항상 마팅게일입니다.\n\n그래서 이제 위험 중립적 측도로 전환하기 위해 이러한 확률과정이 존재한다는 걸 알게 되었는데, 정확히 어떻게 이 변화를 수행해야 할까요? Girsanov의 정리는 이 구성을 제공하고 결과적인 과정이 여전히 유효한 마틴게일임을 보장합니다. 이는 금융 수학 분야의 여러 응용프로그램에 필수적인 조건으로, 특히 이 연구와 같은 위험 중립 파생상품 가격 산출에 적용됩니다.\n\n![image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_17.png)\n\n이제 우리의 문제에 이를 어떻게 적용하는지 살펴봅시다. 원래의 실세계 측도 P 하에서의 원래 동역학을 상기해보세요:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![Image 1](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_18.png)\n\n![Image 2](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_19.png)\n\n![Image 3](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_20.png)\n\nTo achieve this, we set\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![Image 1](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_21.png)\n\nBy plugging this into the measure and with some simple manipulations, the dynamics of S_t under the risk-neutral measure Q become:\n\n![Image 2](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_22.png)\n\nAlso, we have by Girsanov’s that\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_23.png)\n\n![image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_24.png)\n\n따라서, Girsanov의 정리는 위험 중립 측도 Q 하에서 할인된 프로세스가 Martingale임을 보장합니다. 이로부터 금융 수학의 여러 정리와 결과를 통해 위험 중립 동역학 하에서 파생상품을 가격 지정할 때 \"공정 가격\"을 찾을 수 있다.\n\n## 옵션 프로세스의 블랙-숄즈 모델 도출\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_25.png)\n\nThe idea is pretty clear: if we want to price a derivative say, at inception (t=0) it’s value should be the potential (expected) payoff we should get from it at maturity, adjusted via the risk-free rate today.\n\nThus, for an European Call and Put option at time t from inception respectively is given by:\n\n![image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_26.png)\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 표를 다음과 같이 마크다운 형식으로 변경해주세요.\n\n\nNotice that the expectation is taken under the risk-neutral measure. In order to solve this expectation, let’s revisit the stochastic dynamics and distribution for S(T):\n\n![equation 27](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_27.png)\n\nwhich implies that\n\n![equation 28](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_28.png)\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위에서 W_T에 물결표시(~)가 있는 경우, 그것은 위험중립 측도 아래의 브라운 운동입니다.\n\n이제 위험중립 측도 아래 콜 옵션의 페이오프의 기대값은 다음과 같습니다:\n\n![image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_29.png)\n\n여기서 함수 phi(z)는 표준 정규 분포의 확률밀도함수입니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 호출 옵션이 가치를 가지는 경우는 있음을 주목해 주세요.\n\n![image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_30.png)\n\n이 조건은 다음과 같이 번역됩니다.\n\n![image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_31.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n따라서, 적분에서 값의 오른쪽 위 부분만 0이 아닙니다:\n\n![image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_32.png)\n\n다음으로, 적분을 두 부분으로 나눌 수 있다는 것에 유의하세요:\n\n![image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_33.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![Image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_34.png)\n\nCombining the both parts and applying the discount factor we obtain:\n\n![Image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_35.png)\n\n, where\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_36.png)\n\n, 이것은 잘 알려진 Black-Scholes 공식입니다. Put에 대한 유도는 유사하지만, Put-Call Parity가 항상 성립한다는 것을 기억하세요, 즉:\n\n![](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_37.png)\n\nBlack-Scholes PDE\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리가 블랙-숄즈 모델에 대한 수학적 분석을 완료한 것은 아직이에요. 위키백과의 글을 확인하면 다음과 같은 방정식을 만나게 될 거에요:\n\n![블랙-숄즈 모델 방정식](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_38.png)\n\n이 방정식이 의미하는 바를 이해하고 해석하는 방법을 이해하려면, 재무 해석을 통해 확률 해석을 통한 유도를 살펴보는 게 좋아요:\n\n![블랙-숄즈 모델 유도](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_39.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래와 같이 도함수(derivatives)가 제공됩니다:\n\n![image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_40.png)\n\n따라서:\n\n![image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_41.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n, 세 번째 단계는 다음 사실에서 나온다.\n\n![image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_42.png)\n\n포트폴리오가 자율자금화되어 있으며(즉, 초기 자본 외에는 자본을 투입하지 않는다) 무위험이어야 하므로(어떠한 황폐도도 없음), 포트폴리오 가치의 변화는 무위험 이자율에 초기 포트폴리오 가치를 곱한 것이어야 한다:\n\n![image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_43.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제, 기억하시나요?\n\n![Equation 44](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_44.png)\n\n이전 방정식에 대체하면,\n\n![Equation 45](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_45.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 블랙-숄즈 PDE의 정확한 수식입니다. 따라서, 우리는 우리가 가정한 확률 동역학과 무위험 및 위험 중립 원칙에서 완전히 유도된 이 방정식을 명확히 볼 수 있습니다.\n\n## 블랙-숄즈 가격 표면\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n보너스로 블랙-숄즈 가격 결정 표면을 시각화할 수 있습니다. 이것은 글의 시작 부분에서 보았던 것입니다. 아래는 그림을 생성하는 코드입니다:\n\n![Source](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_48.png)\n\n그리스\n\n블랙-숄즈 편미분 방정식에서 중요한 파생 변수 몇 가지를 분석할 수 있습니다. 이는 일반적으로 그리스(Greeks)라고 알려진 것들입니다. 그리스는 블랙-숄즈 방정식에서 직접 취할 수 있거나 유래된 구성 요소들로, 옵션 가격 공식의 도함수는 옵션 가격 및 다른 것들이 다른 매개변수가 변할 때(나머지는 일정한 상태에서) 어떻게 변하는지 알려줍니다. 이것은 별도의 주제이므로, 오늘은 델타, 감마, 세타 및 베가에 대한 개요, 그리고 옵션 포트폴리오에서 처음 두 가지를 헷징하는 방법에 대해서만 다룰 것입니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래 내용을 따를 때 Black-Scholes 옵션 가격 산식을 상기해 봅시다:\n\n![Image 1](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_49.png)\n\n![Image 2](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_50.png)\n\n옵션의 델타는 옵션 가격이 기초 자산 가격의 변화에 대해 변하는 속도를 측정합니다. 수학적으로, 다음과 같이 쉽게 볼 수 있습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![Image description](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_51.png)\n\nAs a side note, for a portfolio of options, the delta of the portfolio is simply the aggregated deltas in that porfolio:\n\n![Image description](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_52.png)\n\nThe question is: what do we do with this information?\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n델타 헷지\n\n![이미지](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_53.png)\n\n이제 이에 대한 구체적인 예시를 살펴보겠습니다:\n\n![이미지](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_54.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n헷지를 적용하면 포트폴리오 가치가 대부분 일정하게 유지되는 것을 확인할 수 있어요! 헷지 없이는, 옵션의 변동폭이 0.04달러가 아닌 0.56달러가 될 거예요!\n\n파이썬 예제로 설명해볼게요:\n\n```js\n시나리오 1 (S_new = 50):\n  델타 헷지 없이 포트폴리오 가치: 2.769931697559578\n  델타 헷지를 취한 포트폴리오 가치: 5.377939867417446\n\n시나리오 2 (S_new = 52):\n  델타 헷지 없이 포트폴리오 가치: 9.230279902656218\n  델타 헷지를 취한 포트폴리오 가치: 17.05430441222985\n```\n\n<img src=\"/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_55.png\" />\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nΓ는 Δ가 기초 자산 가격 S의 변동에 민감하게 반응하는 정도를 측정하는 지표입니다. 수학적으로는:\n\n![equation1](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_56.png)\n\n여기서\n\n![equation2](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_57.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n일부 특성:\n\n![Image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_58.png)\n\n![Image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_59.png)\n\n포트폴리오의 전체 감마가 제로가 되도록 가중치 w_'T_1'를 선택합니다 (이를 연습으로 확인할 수 있습니다). 그러나 결과적인 포트폴리오가 델타-중립성을 유지하는 것은 아닐 수도 있습니다. 추가된 요소로 델타 중립성이 해칠 수 있습니다! 다행히도 이를 상대적으로 간단하게 해결할 수 있습니다. 추기하는 방법으로 델타 중립성의 불일치를 다시 조정함으로써.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![Image 1](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_60.png)\n\nunits of the underlying, that is:\n\n![Image 2](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_61.png)\n\nLet’s see a worked out example for illustration:\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![Image 1](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_62.png)\n\n![Image 2](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_63.png)\n\n![Image 3](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_64.png)\n\nJust as before, let’s illustrate this with a Python example:\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n초기 값:\n  콜 옵션 가격 (C): 2.4004610869656666\n  델타 (Δ): 0.5216016339715761\n  감마 (Γ): 0.06554537725247868\n  헷지용 콜 옵션 가격 (C1): 2.87445202228551\n  헷지용 감마 (Γ1): 0.05725608663849005\n  헷지 가중치 (w_T1): 1.1447757103332348\n\n주식 가격 변화: 1\n헷지가 없는 포트폴리오 가치: -0.5539863395119156\n델타-감마 헷지 적용 후 포트폴리오 가치: -0.0642348870027587\n```\n\n이 예시를 통해 델타와 감마의 변화로 인한 큰 손실을 피하도록 도와준 델타-감마 헷지로 인해 손실을 줄일 수 있음을 확인할 수 있습니다.\n\n![image](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_65.png)\n\n세타는 다른 요인들이 일정한 상황에서 만기가 줄어들 때 옵션 가치가 얼마나 줄어드는지를 나타냅니다. 이는 종종 옵션의 \"시간 감소\"로 불리며 수학적으로 다음과 같이 표현됩니다:\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![Theta for a call and a put](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_67.png)\n![Theta for a put option on a non-dividend-paying stock](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_68.png)\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n일부 특성:\n\n- 장기 포지션의 경우 세타는 보통 음수입니다. 다른 모든 요인이 일정하다면 시간이 흐름에 따라 옵션의 가치가 감소하기 때문입니다.\n- 단기 포지션의 경우 세타는 양수이며, 시간이 지남에 따라 가치가 증가함을 반영합니다.\n- 세타는 대체로 ATM(행사가격과 현재 주가가 동일한) 옵션에 대해 높으며, ITM(행사가격보다 주가가 높은) 및 OTM(행사가격보다 주가가 낮은) 옵션에 대해 감소합니다.\n- 만기가 다가올수록 ATM 옵션의 경우 세타가 증가하여 시간 가치의 가속화된 감쇠를 반영합니다.\n\n예시를 살펴봅시다. 다음과 같은 매개변수를 갖는 유러피언 콜 옵션이 있다고 가정해봅시다:\n\n[옵션 파라미터 이미지](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_69.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![Image 1](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_70.png)\n\n이 예는 시간이 중요한 전략인 캘린더 스프레드 또는 시간 퇴조 전략과 같이 Theta가 유용한 정보를 제공하는 방식을 보여줍니다.\n\n![Image 2](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_71.png)\n\n이 기사에서 제시된 중요한 그리스 중 마지막으로 소개된 것은 Vega입니다. Vega는 기초 자산의 내재 변동성이 1% 변할 때 옵션 가격이 얼마나 변화하는지를 정량화하여, 다른 모든 요소가 일정하다고 가정합니다. 수학적으로:\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n<img src=\"/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_72.png\" />\n\nFor both call and put options, Vega can be expressed using the Black-Scholes formula as:\n\n<img src=\"/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_73.png\" />\n\nSome characteristics:\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 베가는 항상 양수입니다. 변동성이 증가하면 콜 옵션과 풋 옵션의 가치가 모두 증가합니다.\n- 베가는 동일가격에서 가장 높으며, 이후 옵션이 더 많이 더 옵션으로 변화될수록 감소합니다.\n- 만기일이 다가감에 따라 베가도 증가하며, 장기적인 옵션에 대한 변동성의 영향이 더 크게 나타납니다.\n\n이와 유사하게, 예시를 살펴봅시다:\n\n![Example](/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_74.png)\n\n콜 옵션의 베가는 대략 6.825이며, 기초 자산의 변동성이 1% 증가한다면 (30%에서 31%로), 모든 조건이 동일한 상태에서 콜 옵션의 가격이 대략 $6.825 증가할 것으로 예상됩니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 결론\n\n블랙-숄즈 모델은 실제로는 상당히 간단한 근사치이지만, 해당 모델의 연구를 통해 옵션 가격 측정의 여러 동역학과 함의를 수학적으로 이해할 수 있으며, 이러한 것들이 어떻게 유용하고 통찰력 있는 특성들과 관련이 있는지 알 수 있습니다. 이 글에서는 블랙-숄즈 모델에서 가정된 위험 자산의 기초 가격 모델을 다루었으며, 확률적 미적분학과 금융 수학을 사용하여 블랙-숄즈 SDE 및 PDE의 유도를 연구했으며, 가장 중요한 그리스 부분을 다루고 이러한 부분들이 SDE 및 PDE 방정식과 어떻게 관련되는지 살펴보았습니다. 여기서 다루지 않은 많은 내용 (다른 그리스 부분, 내재 변동성 등)이 있지만, 이 글이 해당 모델에 대한 여러 관점을 하나의 글에서 소개할 것이라고 기대합니다.\n\n즐거운 학습되시길 바랍니다!\n\n## Follow me at\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- [LinkedIn](https://www.linkedin.com/in/hair-parra-526ba19b/)\n- [GitHub](https://github.com/JairParra)\n- [Medium](https://medium.com/@hair.parra)","ogImage":{"url":"/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-ACompleteIntroductiontotheBlack-ScholesModelForQuants_0.png","tag":["Tech"],"readingTime":28},{"title":"Python, C, Rust로 직접 만들어보는 ReLU 활성화 함수 단계별 가이드","description":"","date":"2024-07-14 23:51","slug":"2024-07-14-CreatingaReLUActivationFunctionfromScratchAStep-by-StepGuideinPythonCandRust","content":"\n\n\n![image](/TIL/assets/img/2024-07-14-CreatingaReLUActivationFunctionfromScratchAStep-by-StepGuideinPythonCandRust_0.png)\n\n# 소개\n\n신경망 세계에서 활성화 함수는 모델의 출력을 결정하는 데 중요한 역할을 합니다. 가장 인기 있는 활성화 함수 중 하나는 ReLU(렉티파이드 루 linear Unit)입니다. 간단함과 효과적임으로 유명한 ReLU는 많은 딥러닝 모델에서 표준 선택지가 되었습니다. 이 안내서에서는 Python, C 및 Rust 세 가지 다른 프로그래밍 언어로부터 ReLU 활성화 함수를 처음부터 만드는 과정을 안내합니다. 이를 통해 다양한 플랫폼에서의 구현과 이점에 대한 명확한 이해를 제공할 것입니다.\n\n# ReLU란 무엇인가요?\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nReLU은 Rectified Linear Unit의 약자입니다. 이는 입력 값을 반환하는 활성화 함수로 정의됩니다:\n\n![ReLU Activation Function](/TIL/assets/img/2024-07-14-CreatingaReLUActivationFunctionfromScratchAStep-by-StepGuideinPythonCandRust_1.png)\n\n더 간단히 말하면, 입력 값이 양수인 경우 입력 값을 반환하고, 그렇지 않으면 0을 반환합니다. ReLU 함수는 수학적으로 다음과 같이 표현됩니다:\n\n![ReLU Formula](/TIL/assets/img/2024-07-14-CreatingaReLUActivationFunctionfromScratchAStep-by-StepGuideinPythonCandRust_2.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# ReLU를 사용하는 이유?\n\n- 단순성: ReLU 함수는 0을 기준으로 한 간단한 임계값 처리를 포함하기 때문에 계산 효율적입니다.\n- 비선형성: 선형 함수처럼 보이지만 ReLU는 비선형성을 도입하여 복잡한 패턴을 학습하는 데 필수적입니다.\n- 희소 활성화: ReLU는 희소한 활성화를 생성하는 경향이 있어서 (많은 뉴런이 0을 출력) 네트워크를 더 효율적으로 만듭니다.\n\n# Python에서 ReLU 및 신경망 레이어 구현하기\n\n파이썬에서 ReLU 활성화 함수와 간단한 신경망 레이어를 구현해보겠습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 파이썬 구현\n\n## 단계 1: ReLU 함수 정의\n\n먼저, 간단한 파이썬 함수를 사용하여 ReLU 함수를 정의해 보겠습니다.\n\n```python\ndef relu(x):\n    return max(0, x)\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 단계 2: 배열에 ReLU 적용하기\n\n우리는 NumPy를 사용하여 배열을 처리할 수 있는 ReLU 함수를 확장할 것입니다.\n\n```python\nimport numpy as np\n\ndef relu_array(arr):\n    return np.maximum(0, arr)\n```\n\n## 단계 3: 간단한 신경 계층 정의하기\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n자, 이제 간단한 신경망 레이어 클래스를 만들어봅시다.\n\n```js\nclass SimpleNeuralLayer:\n    def __init__(self, input_size, output_size):\n        self.weights = np.random.randn(input_size, output_size)\n        self.biases = np.zeros(output_size)\n\n    def forward(self, inputs):\n        z = np.dot(inputs, self.weights) + self.biases\n        return relu_array(z)\n```\n\n## 단계 4: 신경망 레이어 테스트\n\n```js\n# 예제 사용법\nlayer = SimpleNeuralLayer(3, 2)\ninputs = np.array([1, 2, -1])\noutput = layer.forward(inputs)\nprint(output)\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# C에서 ReLU 및 신경 계층 구현\n\n이제 C에서 ReLU 함수와 간단한 신경망 계층을 구현해 보겠습니다.\n\n# C 구현\n\n## 단계 1: ReLU 함수 정의\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n#include <stdio.h>\n\ndouble relu(double x) {\n    return x > 0 ? x : 0;\n}\n```\n\n## 단계 2: 배열에 ReLU 적용하기\n\n```js\n#include <stdio.h>\n\nvoid relu_array(double* arr, int size) {\n    for (int i = 0; i < size; i++) {\n        arr[i] = arr[i] > 0 ? arr[i] : 0;\n    }\n}\n```\n\n## 단계 3: 간단한 신경망 레이어 정의하기\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n## 단계 4: 신경망 레이어 테스트\n\n```js\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nint main() {\n    srand(time(NULL));\n    SimpleNeuralLayer layer = create_layer(3, 2);\n    double inputs[] = {1, 2, -1};\n    double output[2];\n    forward(layer, inputs, output);\n    printf(\"Output: %f %f\\n\", output[0], output[1]);\n    free(layer.weights);\n    free(layer.biases);\n    return 0;\n}\n```\n\n# ReLU 및 신경망 레이어 구현하기\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마침내, ReLU 함수와 간단한 신경망 레이어를 Rust로 구현해 봅시다.\n\n# Rust 구현\n\n## 단계 1: ReLU 함수 정의\n\n```rust\nfn relu(x: f64) -> f64 {\n    if x > 0.0 { x } else { 0.0 }\n}\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 단계 2: 배열에 ReLU 적용하기\n\n```js\nfn relu_array(arr: &mut [f64]) {\n    for x in arr.iter_mut() {\n        *x = if *x > 0.0 { *x } else { 0.0 };\n    }\n}\n```\n\n## 단계 3: 간단한 신경망 계층 정의\n\n```js\nuse rand::Rng;\n\nstruct SimpleNeuralLayer {\n    weights: Vec<Vec<f64>>,\n    biases: Vec<f64>,\n}\n\nimpl SimpleNeuralLayer {\n    fn new(input_size: usize, output_size: usize) -> Self {\n        let mut rng = rand::thread_rng();\n        let weights = (0..input_size)\n            .map(|_| (0..output_size).map(|_| rng.gen_range(-1.0..1.0)).collect())\n            .collect();\n        let biases = vec![0.0; output_size];\n        \n        SimpleNeuralLayer { weights, biases }\n    }\n\n    fn forward(&self, inputs: &[f64]) -> Vec<f64> {\n        let mut output = vec![0.0; self.biases.len()];\n        \n        for (i, &bias) in self.biases.iter().enumerate() {\n            output[i] = inputs.iter()\n                .zip(&self.weights)\n                .map(|(&input, weight_row)| input * weight_row[i])\n                .sum::<f64>() + bias;\n            output[i] = relu(output[i]);\n        }\n        output\n    }\n}\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 단계 4: 신경 계층 테스트\n\n```js\nfn main() {\n    let layer = SimpleNeuralLayer::new(3, 2);\n    let inputs = [1.0, 2.0, -1.0];\n    let output = layer.forward(&inputs);\n    \n    for value in output {\n        print!(\"{} \", value);\n    }\n    // 출력: 0 0\n}\n```\n\n# 결론\n\nReLU 활성화 함수를 만들고 간단한 신경망 계층에 통합하는 것은 신경망 작업에 대한 기본 개념을 강조합니다. Python, C 및 Rust에서 ReLU를 구현함으로써, 여러 플랫폼에서 딥러닝 모델의 성공을 이끌어내는 주요 구성 요소 중 하나에 대한 통찰을 얻을 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n기계 학습 초보자이거나 경험이 풍부한 실무자이든 ReLU와 같은 활성화 함수의 내부 작업을 이해하는 것이 중요합니다. 이 지식을 통해 다양한 응용 프로그램을 위해 신경망을 더 잘 설계, 디버그 및 최적화할 수 있습니다.\n\n좋은 코딩되세요!\n\n![image](/TIL/assets/img/2024-07-14-CreatingaReLUActivationFunctionfromScratchAStep-by-StepGuideinPythonCandRust_3.png)","ogImage":{"url":"/TIL/assets/img/2024-07-14-CreatingaReLUActivationFunctionfromScratchAStep-by-StepGuideinPythonCandRust_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-CreatingaReLUActivationFunctionfromScratchAStep-by-StepGuideinPythonCandRust_0.png","tag":["Tech"],"readingTime":9},{"title":"배포 후 머신러닝 모델을 관리해야 하는 이유","description":"","date":"2024-07-14 23:49","slug":"2024-07-14-WhyyouneedtobabysitMLmodelsafterdeployment","content":"\n\n![TIL](/TIL/assets/img/2024-07-14-WhyyouneedtobabysitMLmodelsafterdeployment_0.png)\n\n머신 러닝 모델을 배포한 후 모니터링을 중요시하는 이유가 궁금했던 적이 있나요? 매주 매출 예측을 통해 소매점에서 포스트-배포 모델 모니터링 개념을 탐구하는 흥미로운 이야기를 살펴보겠습니다.\n\n이 이야기를 따라가면 실제 월마트 매출 데이터 세트를 사용해볼 것입니다. 매출 예측 모델을 구축하고 이 머신 러닝 모델의 성능을 운영 중에 모니터링할 것입니다. Google Colab 노트북 내에서 운영 환경을 직접 모방하여 간단히 따라할 수 있을 것입니다.\n\n우리는 실제 세계의 변화로 인해 시간이 지남에 따라 머신 러닝 모델이 악화되는 방법과 모니터링 부족이 상당한 재정 손실로 이어질 수 있는 이유를 발견할 것입니다. 그리고 ML 모델의 성능 모니터링에 nannyML을 사용하는 방법과 nannyML에 의해 발명된 확률적 모델이 필요한 이유를 알아볼 것입니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 댄니 씨의 소매점\n\n![댄니 씨의 소매점](/TIL/assets/img/2024-07-14-WhyyouneedtobabysitMLmodelsafterdeployment_1.png)\n\n댄니 씨가 대형 소매점을 열면서 월마트와 유사한 상점이 열립니다. 상점이 성장함에 따라 주간 매출을 예측하고자 합니다. 따라서 댄니 씨는 데이터 과학자를 고용하여 주간 매출을 예측할 수 있는 기계 학습 모델을 구현하고자 합니다. 이를 통해 미래의 트렌드와 매출을 예측하여 재고와 수요를 미리 계획할 수 있습니다.\n\n데이터 과학자는 댄니 씨의 주간 매출을 예측하는 인상적인 모델을 개발하여 테스트 데이터에서 97%의 정확도를 달성했습니다. 이 모델을 배포한 후, 데이터 과학자는 작별 인사를 남기고 갔습니다. :*)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n<img src=\"/TIL/assets/img/2024-07-14-WhyyouneedtobabysitMLmodelsafterdeployment_2.png\" />\n\nMr. Danny initially used the model in production. However, after some time, he noticed the model began to fail and gave incorrect predictions. He incurred a financial loss. Can you guess why the model performance degraded⁉️\n\nMr. Danny, who had limited technical knowledge, hired an ML Engineer. He identified the cause of the previous model failure as data drift. Simply put, data drift happens when real-world data changes in ways the model wasn’t trained for, leading to a decline in model performance.\n\nThe ML Engineer provided two possible reasons for the decline in model performance:\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 단변량 드리프트: 생산 중에 온도 패턴이 갑자기 변하여 쇼핑 패턴이 변경되었습니다. 예를 들어, 자외선 차단제와 탄산음료의 판매량이 증가했습니다.\n- 다변량 드리프트: 고용률, 경기 침체 및 온도 변화가 모두 판매 패턴과 소비자 행동에 영향을 미쳤습니다. 이러한 요인들 사이의 복잡한 관계가 변화함에 따라 다변량 드리프트가 발생했습니다.\n\n자세히 알아보려면 [Hypothesis Testing를 사용한 데이터 드리프트 감지 방법](https://nannyml.com)을 방문해보세요.\n\nML 엔지니어는 모니터링 솔루션의 중심에 데이터 드리프트를 두는 것을 주장했습니다. Danny씨는 이 아이디어를 수용하고 모델 성능 모니터링을 시작했습니다. 그 결과, 그는 매일 모델로부터 다수의 경고를 받았습니다. 이는 그에게 상당한 정신적 스트레스를 야기했습니다.\n\n그러나 Danny씨가 실제 '주간 매출'값 (해당 주의 실제 매장 판매액)을 받자, 대부분의 경고가 잘못되었음을 알게 되었습니다. 경고 중 90% 이상이 잘못되었고, 모델 성능 하락을 올바르게 표시한 경고는 10% 미만이었습니다. 결과적으로, 중앙 모니터링 전략으로 데이터 드리프트에 집중하는 것은 실패로 끝나게 되었습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![이미지](/TIL/assets/img/2024-07-14-WhyyouneedtobabysitMLmodelsafterdeployment_3.png)\n\n마침내 Mr. Danny는 nannyML이라는 라이브러리를 발견했습니다. 이 도구는 그의 ML 모델을 간병하는 역할을 할 수 있어서 지속적으로 성능을 모니터링하고 거짓 경보를 생성하지 않습니다. 그는 정답 데이터에 액세스하지 않고 ML 모델의 성능을 추정하고 데이터 드리프트를 감지할 수 있도록 했습니다.\n\n![이미지](/TIL/assets/img/2024-07-14-WhyyouneedtobabysitMLmodelsafterdeployment_4.png)\n\n![이미지](/TIL/assets/img/2024-07-14-WhyyouneedtobabysitMLmodelsafterdeployment_5.png)\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음으로, 우리는 Kaggle에서 사용할 수 있는 인기 있는 Walmart 판매 데이터 세트를 사용할 것입니다. 댄니 씨가 그의 가게를 위한 유사한 데이터를 가지고 있다고 가정해 봅시다. 우리는 NannyML을 사용하여 모델 모니터링 및 모델 성능 평가 방법을 탐색할 것입니다.\n\n![이미지](/TIL/assets/img/2024-07-14-WhyyouneedtobabysitMLmodelsafterdeployment_6.png)\n\n이것은 2010년 2월 5일부터 2012년 11월 1일까지의 판매를 다루는 기록 데이터입니다. 미국 전역에 위치한 여러 Walmart 매장에서 얻은 데이터가 포함되어 있습니다.\n\n![이미지](/TIL/assets/img/2024-07-14-WhyyouneedtobabysitMLmodelsafterdeployment_7.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 🤖nannyML의 모델 배포 후 모니터링을 위한 사용\n\n우리가 할 일:\n\n- 이 데이터를 사용하여 매장 수요를 예측하여 주간 매출을 예측합니다.\n- 이 데이터에 nannyML 도구를 적용하여 모델 배포 후 모니터링을 결정합니다.\n- 왜 댄니씨의 경우 대부분의 알람이 잘못 트리거되었는지 조사합니다.\n\n# 주간 매출 데이터 소개\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![Image](/TIL/assets/img/2024-07-14-WhyyouneedtobabysitMLmodelsafterdeployment_8.png)\n\n우리는 캐글에서 접근 가능한 널리 사용되는 월마트 판매 데이터셋을 활용할 것입니다. 이 데이터셋은 미국 전역에 위치한 여러 월마트 매장의 과거 판매 데이터를 포함하고 있습니다. 우리의 목표는 소매 수요 예측을 수행하고 주간 판매를 예측하는 것입니다.\n\n![Image](/TIL/assets/img/2024-07-14-WhyyouneedtobabysitMLmodelsafterdeployment_9.png)\n\n이 데이터는 2010년 2월 5일부터 2012년 11월 1일까지의 판매를 다루는 과거 데이터입니다:\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 기능 설명\n\n- Store - 상점 번호\n- Date - 판매 주\n- 주간 판매 - 해당 상점의 매출\n- 휴일 플래그 - 주가 특별한 휴일 주인지 여부 1 - 휴일 주 0 - 비휴일 주\n- 온도 - 판매 일의 온도\n- 연료 가격 - 지역의 연료 비용\n- 소비자 물가 지수 - 현행 소비자 물가 지수\n- 실업률 - 현행 실업률\n- 월, 년, 계절 - 시간 관련 특성\n\n# EDA 및 전처리\n\n일부 기본적인 탐색적 데이터 분석을 수행하고 일부 특성의 분포를 분석해보겠습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![Image 1](/TIL/assets/img/2024-07-14-WhyyouneedtobabysitMLmodelsafterdeployment_10.png)\n\n- CPI와 Fuel_Price는 이중분포를 가지고 있으며, Temperature와 Unemployment는 정규분포를 가지고 있습니다.\n\n![Image 2](/TIL/assets/img/2024-07-14-WhyyouneedtobabysitMLmodelsafterdeployment_11.png)\n\n- Weekly_Sales 분포는 우측으로 치우쳐져 있으며, 이상치가 있습니다.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![image](/TIL/assets/img/2024-07-14-WhyyouneedtobabysitMLmodelsafterdeployment_12.png)\n\n- 겨울 및 휴일에는 주간 매출이 특히 11월과 12월에 높음\n\n![image](/TIL/assets/img/2024-07-14-WhyyouneedtobabysitMLmodelsafterdeployment_13.png)\n\n- 모든 특성의 상관 관계 히트맵은 각 입력 특성 간의 흥미로운 관계를 보여줍니다.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 데이터 전처리 및 이상치 제거\n\n```js\n#이상치 제거\nnum_features = ['Temperature', 'Fuel_Price', 'CPI', 'Unemployment', 'Weekly_Sales']\nfor feature in num_features:\n    q1 = df[feature].quantile(0.25)\n    q3 = df[feature].quantile(0.75)\n    iqr = q3 - q1\n    lower = q1 - 1.5 * iqr\n    upper = q3 + 1.5 * iqr\n    df = df[(df[feature] >= lower) & (df[feature] <= upper)]\n\n# 숫자형 변수 정규화\nsc = StandardScaler()\ndf[num_features] = sc.fit_transform(df[num_features])\ncategoric_columns = ['Store', 'Season']\n# 범주형 특성 인코딩\ndf[categoric_columns] = df[categoric_columns].astype('category')\nencoder = BinaryEncoder(cols=categoric_columns)\ndf = encoder.fit_transform(df)\n```\n\n# 데이터를 nannyML에 맞게 분할 및 처리\n\n일반적으로 데이터는 학습, 검증 및 테스트 세트로 나누지만, nannyML에서는 데이터를 네 부분으로 나눕니다. 모델 모니터링 워크플로우는 제품 데이터를 모방하는 또 다른 세트를 필요로 합니다. 이는 시스템이 성능 하락을 올바르게 감지하고 올바른 알고리즘을 사용하여 어떤 문제가 발생했는지 보고하기 위함입니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![이미지](/TIL/assets/img/2024-07-14-WhyyouneedtobabysitMLmodelsafterdeployment_14.png)\n\n이 삽화는 데이터 분할에 관한 모든 것을 설명합니다. 깊이 이해하려면 코드를 읽어보세요.\n\n참조 세트는 모델 모니터링 문맥에서 사용되는 테스트 세트의 다른 이름입니다. NannyML은 테스트 세트에서 모델의 성능을 기준으로 생산 성능을 측정합니다.\n\n분석 세트는 모델에 의해 생성된 예측을 포함하는 생산 데이터이며 여기서는 실제 값(우리의 경우에는 미래 주의 소매점 매출)은 사용할 수 없습니다.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# 참고 - 여기서는 유효성 데이터를 생성하지 않습니다.\n# 코드 이해를 돕기 위해 위 이미지를 참고하세요.\n\n# 데이터 파티션 생성\ndf['partition'] = pd.cut(\n    df['Date'],\n    bins=[pd.to_datetime('2010-02-12'),\n          pd.to_datetime('2012-02-12'),\n          pd.to_datetime('2012-06-12'),\n          pd.to_datetime('2012-10-26')],\n    right=False,\n    labels=['train', 'test', 'prod']\n)\n# 타겟과 특성 설정\ntarget = 'Weekly_Sales'\nfeatures = [col for col in df.columns if col not in [target, 'Date', 'partition']]\n# 데이터 분할\nX_train = df.loc[df['partition'] == 'train', features]\ny_train = df.loc[df['partition'] == 'train', target]\nX_test = df.loc[df['partition'] == 'test', features]\ny_test = df.loc[df['partition'] == 'test', target]\nX_prod = df.loc[df['partition'] == 'prod', features]\ny_prod = df.loc[df['partition'] == 'prod', target]\r\n```\n\n따라서 최종 데이터 분포 분할은 다음과 같습니다: \n\n- X_train 및 y_train: 2010-02-12 이후 데이터 (4725개)\n- X_test 및 y_test: 2012-02-12 이후 데이터 (945개)\n- X_prod 및 y_prod: 2012-06-12 이후 데이터 (675개)\n\n# 기계 학습 모델 훈련하기\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 LightGBM 회귀 모델을 훈련 데이터에 맞추어, 모델 예측과 기준 예측의 평균 절대 오차(MAE)를 계산하고 훈련 및 테스트 세트에 대한 예측을 수행할 것입니다.\n\n```js\n#모델 훈련\nmodel = LGBMRegressor(random_state=111)\nmodel.fit(X_train, y_train)\n\n# 예측 수행\ny_pred_train = model.predict(X_train)\ny_pred_test = model.predict(X_test)\n# 기준 예측 수행\ny_pred_train_baseline = np.ones_like(y_train) * y_train.mean()\ny_pred_test_baseline = np.ones_like(y_test) * y_train.mean()\n# 훈련, 테스트 및 기준 성능 측정\nmae_train = mean_absolute_error(y_train, y_pred_train).round(4)\nmae_test = mean_absolute_error(y_test, y_pred_test).round(4)\nmae_train_baseline = mean_absolute_error(y_train, y_pred_train_baseline).round(4)\nmae_test_baseline = mean_absolute_error(y_test, y_pred_test_baseline).round(4)\n```\n\n모델을 평가하기 위해, 모델의 훈련 및 테스트 MAE(Mean Absolute Error)를 주간_매출 열의 평균으로 지속적으로 예측하는 기준 모델과 비교할 것입니다.\n\n<img src=\"/TIL/assets/img/2024-07-14-WhyyouneedtobabysitMLmodelsafterdeployment_15.png\" />\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![Training and Testing Data Scatter Plots](/TIL/assets/img/2024-07-14-WhyyouneedtobabysitMLmodelsafterdeployment_16.png)\n\n우리는 두 개의 산점도를 그렸습니다. 하나는 훈련용으로 실제와 예측값을, 또 다른 하나는 테스트 데이터에 대한 예측값을 표현한 것입니다. 두 경우 모두 평균 절대 오차가 비교적 낮은 수준으로 나타났습니다. 이는 모델이 이용 사례에 대해 충분히 잘 작동함을 의미합니다.\n\n![Feature Importance](/TIL/assets/img/2024-07-14-WhyyouneedtobabysitMLmodelsafterdeployment_17.png)\n\n또한 우리는 특성 중요도를 계산했는데, 그 결과로 위 세 가지 중요한 특성은 소비자 물가 지수 (CPI), 실업률, 그리고 연료 가격임을 알게 되었습니다.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# nannyML에서 성능 측정 예측\n\nnannyML은 회귀 및 분류 모델의 성능을 추정하는 데 두 가지 주요 알고리즘을 제공합니다:\n\n우리는 회귀 작업에 대한 직접 손실 추정 알고리즘(DLE)을 사용할 것입니다. DLE는 생성 모델의 성능을 그라운드 트루스 없이 측정하고 RMSE, RMSLE, MAE 등과 같은 다양한 회귀 유사 메트릭을 보고할 수 있습니다.\n\n```js\ny_pred_prod = model.predict(X_prod) #생산 데이터에 대한 주간 매출 예측\n\nreference_df = X_test.copy() # 참조용 테스트 세트\nreference_df['y_pred'] = y_pred_test # 참조 예측\nreference_df['Weekly_Sales'] = y_test # 그라운드 트루스(올바른 타겟)\nreference_df = reference_df.join(df['Date']) # 날짜\nanalysis_df = X_prod.copy() # 특성\nanalysis_df['y_pred'] = y_pred_prod #생산 예측\nanalysis_df = analysis_df.join(df['Date']) # 날짜\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nDLE를 사용하기 위해서는 먼저 기준 성능을 설정하기 위한 참조값을 맞춰야 합니다.\n\n<img src=\"/TIL/assets/img/2024-07-14-WhyyouneedtobabysitMLmodelsafterdeployment_18.png\" />\n\n```js\ndle = nml.DLE(\n    metrics=['mae'],\n    y_true='Weekly_Sales',\n    y_pred='y_pred',\n    feature_column_names=features,\n    timestamp_column_name='Date',\n    chunk_period='w'\n)\n\ndle.fit(reference_df) # 참조(테스트) 데이터에 fit\nestimated_performance = dle.estimate(analysis_df) # 제품 데이터에 대한 추정값\n```\n\n성능 문제가 감지되지 않았으며, 추정된 성능이 임계값 내에 있음을 관찰했습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n미스터 댄니는 미래 주간 판매액에 대한 실제 데이터를 가지고 있지 않지만, 거짓 경고 없이 철저한 모델 성능 보고서를 받고 있습니다.\n\n몇 일 후에 댄니씨가 Weekly_Sales(목표값이 사용 가능해지면) 실제 모델 성능을 계산할 수 있습니다. 이것을 제작 데이터의 실제 성능이라고도 합니다. 아래 셀에서는 실제 성능을 계산하고 이를 nannyML의 추정치와 비교합니다.\n\n```js\ncalculator = nml.PerformanceCalculator(\nproblem_type=\"regression\",\ny_true='Weekly_Sales',\ny_pred=\"y_pred\",\nmetrics=[\"mae\"],\ntimestamp_column_name='Date',\nchunk_period='w'\n)\ncalculator.fit(reference_df)\nrealized_performance = calculator.calculate(analysis_df.assign(Weekly_Sales = y_prod)\n```\n\n<img src=\"/TIL/assets/img/2024-07-14-WhyyouneedtobabysitMLmodelsafterdeployment_19.png\" />\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 위 그림에서 추정 성능이 실제 성능과 밀접하게 일치하여, DLE의 추정이 정확했음을 나타냅니다.\n\n# 왜 잘못된 경보가 발생하는 것일까요?\n\n이제 이 데이터에 대한 단변량 및 다변량 drift를 검토하고, 이것이 Danny씨의 경우에 실패한 이유를 설명하겠습니다.\n\n```js\ndrdc = nml.DataReconstructionDriftCalculator(\ncolumn_names=features,\ntimestamp_column_name='Date',\nchunk_period='d',\n)\n\ndrdc.fit(reference_df)\nmultivariate_data_drift = drdc.calculate(analysis_df)\nmultivariate_data_drift.plot()\n```  \n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![Image](/TIL/assets/img/2024-07-14-WhyyouneedtobabysitMLmodelsafterdeployment_20.png)\n\n다변량 이동 방법을 통해 분석 데이터에 대한 경고를 받았습니다. 이는 모델 성능에 영향을 미치지 않았기 때문에 잘못된 경고입니다.\n\n```js\nudc = nml.UnivariateDriftCalculator(\ncolumn_names=features,\ntimestamp_column_name='Date',\nchunk_period='w',\n)\n\nudc.fit(reference_df)\nunivariate_data_drift = udc.calculate(analysis_df)\nunivariate_data_drift.filter(period='all', metrics='jensen_shannon', column_names=['Unemployment']).plot(kind='distribution')\n```\n\n![Image](/TIL/assets/img/2024-07-14-WhyyouneedtobabysitMLmodelsafterdeployment_21.png)\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n비슷하게, 일변량 드리프트 방법은 우리에게 분석 데이터에 대한 경고를 주었습니다. 그것은 잘못된 경고였습니다. 왜냐하면 모델 성능에 영향을 미치지 않았기 때문입니다. 따라서 잘못된 경보가 발생했음을 보았습니다. 데이터 드리프트 방법이 모니터링 솔루션의 중심에 놓여 있었기 때문입니다.\n\n# 요약\n\n우리는 nannyML이 소매 판매 예측을 위해 실제 월마트 데이터에 적용되는 방법을 탐색했습니다. 소비자 행동과 시장 트렌드의 변화에 대한 도전을 극복했습니다.\n\n모델 모니터링의 중요성을 배웠지만, 효과적인 모니터링을 방해할 수있는 잘못된 경고 문제도 배웠습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기까지 오셨다면, NannyML의 문서를 살펴보시고 여러 사용 사례에서 어떻게 혜택을 받을 수 있는지 확인하는 것을 강력히 추천합니다. 더 많은 정보를 원하신다면 그들의 웹사이트도 방문해보세요.","ogImage":{"url":"/TIL/assets/img/2024-07-14-WhyyouneedtobabysitMLmodelsafterdeployment_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-WhyyouneedtobabysitMLmodelsafterdeployment_0.png","tag":["Tech"],"readingTime":18},{"title":"대기업 취업을 위한 필수 Python 면접 질문 10선","description":"","date":"2024-07-14 23:47","slug":"2024-07-14-10Must-KnowPythonInterviewQuestionsforTechGiants","content":"\n\n## TOP 10 PYTHON INTERVIEW QUESTIONS\n\n회사나 역할에 따라 자주 나오는 인터뷰 질문이 다양하지만, 일반적으로 큰 기술 회사의 인터뷰에서는 기본 지식, 알고리즘, 시스템 디자인 질문이 흔합니다. 이 블로그에서는 대형 기술 회사 인터뷰에서 자주 나오는 10가지 질문을 다루고 있습니다.\n\n# 1. Python의 특징은 무엇인가요?\n\n- 배우기 쉽다\n- 객체지향 프로그래밍\n- 해석형 언어\n- 강력한 표준 및 서드 파티 라이브러리\n- 크로스 플랫폼\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 2. Python 코드는 어떻게 실행되나요?\n\n- 해석기는 Python 코드를 읽고 구문 또는 형식 오류를 확인합니다.\n- 오류가 없다면 해석기는 코드를 바이트 코드로 변환합니다.\n- 이 바이트 코드는 Python 가상 머신에 실행을 위임합니다. 실행 중 오류가 발생하면 프로세스가 중단됩니다; 그렇지 않으면 결과가 표시됩니다.\n\n![](/TIL/assets/img/2024-07-14-10Must-KnowPythonInterviewQuestionsforTechGiants_0.png)\n\n# 3. 이터레이터와 제너레이터의 차이점은 무엇인가요?\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 반복자(Iterator): `next()` 작업을 지원하는 객체로, 일련의 요소를 포함합니다. `next()` 메서드는 요소를 하나씩 반환하고 모든 요소가 반환된 경우 `StopIteration`을 발생시킵니다. 반복자는 `__iter__()`와 `__next__()` 메서드를 구현합니다.\n- 생성자(Generator): `yield` 키워드를 사용하여 생성자 객체를 반환하는 함수입니다. 이 객체는 실행을 일시 중단하고 다시 시작할 수 있습니다. 생성자에서 `next()`를 호출하면 `yield` 문에 도달할 때까지 실행이 계속되며, 생성자는 요청 시 값을 생성하여 메모리를 절약하고 효율성을 높일 수 있습니다.\n- 차이점: 생성자는 함수 및 `yield` 키워드를 사용하여 정의된 특별한 반복자로, 내장 `iter()` 함수로 생성된 표준 반복자와 달리 호출 가능한 일반 함수이며 값들을 순차적으로 생성합니다.\n\n# 4. `yield`를 사용하는 방법\n\n- `yield`는 함수에서 생성자를 반환하는 Python 키워드입니다. 생성자는 모든 데이터를 한 번에 메모리에 저장하지 않기 때문에 대규모 데이터나 복잡한 구조에 유용한 지연 계산을 허용합니다.\n- `yield`를 포함하는 함수를 **생성자 함수(Generator function)**라고 합니다. 값의 시리즈를 생성하고 각 호출 시 이전 상태에서 실행을 계속합니다.\n\n```js\n# 원래 방법: 대형 목록은 많은 메모리를 사용합니다\ndef create_numbers(n):\n    num_list = []\n    for i in range(n):\n        num_list.append(i)\n    return num_list\n\n# yield 사용: 메모리를 효율적으로 사용하는 데이터 스트림 생성\ndef create_numbers(n):\n    for i in range(n):\n        yield i\n\nnums = create_numbers(5)\nfor num in nums:\n    print(num)\n```  \n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 5. 파이썬2와 파이썬3의 차이점은 무엇인가요?\n\n- 정수 타입: 파이썬2는 int와 long을 구분하지만, 파이썬3는 구분하지 않습니다.\n- 문자열 포매팅: 파이썬3는 포매팅을 위해 f-문자열을 도입했습니다.\n- 정수 나눗셈: 파이썬2는 정수 나눗셈을 수행하고, 파이썬3는 부동 소수점을 반환합니다.\n- 인코딩: 파이썬2는 기본적으로 ASCII를 사용하며, 파이썬3는 유니코드를 사용합니다.\n- 출력문: 파이썬2는 `print`를 사용하고, 파이썬3는 `print()`를 사용합니다.\n- `range()` 함수: 파이썬2는 리스트를 반환하지만, 파이썬3는 이터레이터를 반환합니다.\n- `input()`과 `raw_input()`: 파이썬2는 문자열에 대해 `raw_input()`을 사용하고, 파이썬3는 `input()`을 사용합니다.\n\n# 6. 파이썬은 어떻게 메모리를 관리하나요?\n\n참조 카운팅과 가비지 콜렉션:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 참조 카운팅은 객체 참조를 추적합니다. 카운트가 제로에 도달하면 객체가 삭제됩니다.\n- 가비지 컬렉션은 순환 참조를 처리하며, 객체를 수명에 따라 세대로 나누고 그에 따라 쓰레기를 수거합니다.\n\n이러한 메커니즘들은 Python이 메모리를 자동으로 관리할 수 있게 하며, 개발자들이 메모리 세부사항에 집중하는 대신 논리에 집중할 수 있게 합니다.\n\n# 7. 깊은 복사와 얕은 복사의 차이는 무엇인가요?\n\n- 얕은 복사: 객체의 외부 레이어 멤버(기본 데이터 유형 및 문자열)를 복사합니다. 내부 멤버(중첩된 객체 또는 참조)는 참조에 의해 복사되어 새로운 인스턴스를 생성하지 않습니다. 내부 멤버의 변경은 원본 및 복사된 객체 양쪽에 영향을 줍니다.\n- 깊은 복사: 전체 객체를 재귀적으로 복사하며, 모든 내부 멤버와 중첩된 객체를 포함한 새로운 메모리에 새 인스턴스를 생성합니다. 원본 객체의 내부 멤버를 변경해도 복사된 객체에 영향을 미치지 않습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 8. 클로저란 무엇인가요?\n\n클로저는 내부 함수가 외부 함수의 변수에 의존하고, 외부 함수가 내부 함수를 반환할 때 생성됩니다. 이는 외부 함수가 실행을 마친 후에도 내부 함수가 이러한 변수에 액세스를 유지할 수 있게 합니다.\n\n```js\ndef out_function(y):\n    def in_function(x):\n        return x + y\n    return in_function\n\nf = out_function(5)\nprint(f(3))  # 8\n```\n\n# 9. `is not`과 `!=`의 차이점은 무엇인가요?\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- `!=`: 두 객체가 서로 다른 값을 가지는지 확인합니다.\n- `is not`: 두 객체가 메모리에서 서로 다른지 확인합니다.\n\n# 10. 람다 함수란 무엇인가요?\n\n람다 함수 또는 익명 함수는 이름이 없는 한 줄짜리 함수입니다. 여러 매개변수를 가질 수 있지만 표현식은 하나뿐입니다.\n\n최신 AI 이야기를 탑재하려면 Substack에서 저희와 연락을 유지하세요. 함께 AI의 미래를 함께 만들어 봅시다!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파이썬 이야기를 업데이트 받으려면 Substack에서 우리와 함께하세요. 함께 파이썬을 배워봐요!","ogImage":{"url":"/TIL/assets/img/2024-07-14-10Must-KnowPythonInterviewQuestionsforTechGiants_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-10Must-KnowPythonInterviewQuestionsforTechGiants_0.png","tag":["Tech"],"readingTime":6},{"title":"Sentinel 2 데이터를 이용한 Python으로 EVI 지도 생성하는 방법","description":"","date":"2024-07-14 23:46","slug":"2024-07-14-ProduceEVImapswithPythonSentinel2Data","content":"\n\n# TL;TR\n\n증강 식물 지수 (EVI)는 원격 감지에서 널리 사용되는 분광 지수로, 위성 영상을 통해 식물 건강 및 영역을 평가하는 데 사용됩니다. 일반화된 차이 식물 지수 (NDVI)를 개선하여 대기 영향을 최소화하고 수관 구조 변화 및 밀집 식물 지역에 대한 민감도를 향상시켰습니다.\n\n## EVI의 주요 특징:\n\n- 식물에 대한 민감도: EVI는 대기 영향을 최소화하고 수관 특성에 대한 민감도를 증가시킴으로써 특히 밀집 식물 지역에서 효과적으로 작동하도록 설계되었습니다.\n- 공식: EVI 공식은 빨강, 근적외선 (NIR), 파랑 분광대를 포함하여 식물에 대한 민감도를 개선합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/TIL/assets/img/2024-07-14-ProduceEVImapswithPythonSentinel2Data_0.png\" />\n\n여기서:\n\n- NIR은 근적외선 대역의 반사율입니다.\n- Red는 빨간 대역의 반사율입니다.\n- Blue는 파란 대역의 반사율입니다.\n- G는 이득 요소입니다 (기본값: 2.5).\n- C1 및 C2는 대기의 영향을 최소화하기 위한 계수입니다 (기본값: 각각 6 및 7.5).\n- L은 수관 배경 조정 요소입니다 (기본값: 1).\n\n값의 범위: EVI 값은 일반적으로 -1에서 1 사이의 범위를 갖습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 높은 값은 밀도가 높은 식물을 나타냅니다.\n- 0 또는 음수에 가까운 값은 비식물 또는 희소식물이 자리 잡은 지역을 나타냅니다.\n\n## 응용:\n\n- 식물 모니터링: EVI는 식물 동태를 모니터링하는 데 널리 사용되며 성장 패턴, 건강 평가, 그리고 환경 요소 또는 인간 활동으로 인한 변화 감지에 도움이 됩니다.\n- 토지 이용 및 토지 피복 매핑: 특히 식물로 지배되는 토지 이용 유형을 매핑하고 분류하는 데 도움이 됩니다.\n- 생태학 연구: 식물 분포를 분석하는 데 유용하며, 생물 다양성 평가 및 서식지 매핑에 활용됩니다.\n\n## 장점:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 민감도 향상: NDVI와 비교하여 밀집 식물 지역의 변화에 대한 감도를 향상시켰습니다.\n- 대기 보정: 대기 간섭을 줄이기 위한 계수를 포함하여 대기 보정을 통해 전 세계 및 지역 규모의 응용 프로그램에 더 견고하게 만들었습니다.\n\n## 고려 사항:\n\n- 데이터 요구 사항: 일반적으로 중고해상도 위성 플랫폼에서 널리 사용되는 빨강, NIR 및 파랑 밴드를 갖춘 다중 스펙트럼 위성 영상이 필요합니다.\n- 매개변수 민감도: 계수 G, C1, C2 및 L의 선택에 민감하며 특정 환경 조건 및 연구 목표에 따라 조정이 필요할 수 있습니다.\n\n## 선행 조건:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 여정에서는 다음을 설치해야 합니다:\n\n- Python 3.10+\n- 시각화를 위한 QGIS 3.X.X +\n\n또한 다음이 필요합니다:\n\n- Copernicus 사이트에서 다운로드할 데이터 세트. 2024년 2월 27일 센티넬 2 2A 이미지로 작업할 예정입니다 (이미지 참조: T36QUL_20240227T082911).\n- Copernicus 플랫폼에서 다운로드할 수 있습니다; 데이터 다운로드에 대한 문서를 확인할 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Sentinel-2 데이터를 활용한 실제 적용:\n\n## 1. 저장소 복제\n\n분류 스크립트 및 학습 샘플을 가져오세요:\n\n```js\ngit clone https://github.com/kokatic/remote_sensing\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이렇게 작성하시면 됩니다 :\n\n\n<img src=\"/TIL/assets/img/2024-07-14-ProduceEVImapswithPythonSentinel2Data_1.png\" />\n\n내 레포지토리(/data/)에 데이터 폴더를 추가했습니다. 이 폴더에는 2024년 4월 30일 에르 우에드 지역의 Sentinel-2 데이터가 포함되어 있습니다. 기준 이미지는 T32SKC_20240430T102021이며, 밴드 4와 8을 포함하고 있습니다.\n\n## 2. 가상 환경 생성 및 필수 모듈 설치\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n현재 작업 폴더 디렉토리에서 명령 줄 인터페이스를 엽니다:\n\n```js\npython -m venv venv\n```\n\n그런 다음 가상 환경을 활성화합니다:\n\nWindows용 (CMD)에서:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\nvenv\\Scripts\\activate # Linux의 경우: source venv/bin/activate\n\n\n필요한 패키지 설치 후:\n\n\npip install -r requirements.txt\n\n\n## 3. 스크립트 실행\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n동일한 폴더에서 스크립트를 실행하려면 터미널 또는 명령 프롬프트를 열고 스크립트가 있는 폴더로 이동한 다음 다음 명령을 실행하세요:\n\n```js\nimport rasterio\nimport numpy as np\n\ndef calculate_evi(red_band_path, nir_band_path, blue_band_path, output_path):\n    try:\n        # rasterio 데이터셋으로 빨간색, NIR, 파란색 밴드 열기\n        with rasterio.open(red_band_path) as red_dataset, \\\n             rasterio.open(nir_band_path) as nir_dataset, \\\n             rasterio.open(blue_band_path) as blue_dataset:\n\n            # rasterio 데이터셋에서 데이터 읽기\n            red = red_dataset.read(1, masked=True).astype('float32')\n            nir = nir_dataset.read(1, masked=True).astype('float32')\n            blue = blue_dataset.read(1, masked=True).astype('float32')\n\n            # EVI 계산\n            G = 2.5\n            C1 = 6\n            C2 = 7.5\n            L = 1\n            epsilon = 1e-6  # 0으로 나누기를 피하기 위한 작은 엡실론 값\n            denominator = nir + C1 * red - C2 * blue + L\n            evi = np.where(denominator != 0, G * ((nir - red) / denominator), np.nan)\n\n            # EVI 값을 [-1, 1] 범위로 클리핑\n            evi = np.clip(evi, -1, 1)\n\n            # EVI 출력을 위한 프로필 업데이트\n            profile = red_dataset.profile\n            profile.update(dtype=rasterio.float32, count=1, compress='lzw')\n\n            # 새 GeoTIFF 파일에 EVI 결과 작성\n            with rasterio.open(output_path, 'w', **profile) as dst:\n                dst.write(evi.astype(np.float32), 1)\n\n    except Exception as e:\n        print(f\"오류가 발생했습니다: {e}\")\n\n# 예시 파일 경로\nred_band_path = 'data/Toshka/S2A_MSIL2A_20240227T082911/T36QUL_20240227T082911_B04_10m.jp2'  # 빨간색 밴드\nnir_band_path = 'data/Toshka/S2A_MSIL2A_20240227T082911/T36QUL_20240227T082911_B08_10m.jp2'  # 근적외선 밴드\nblue_band_path = 'data/Toshka/S2A_MSIL2A_20240227T082911/T36QUL_20240227T082911_B02_10m.jp2'  # 파란색 밴드\noutput_path = 'output/evi.tif'  # EVI 출력 파일\n\ncalculate_evi(red_band_path, nir_band_path, blue_band_path, output_path)\n```\n\n스크립트를 실행한 후 output/ 폴더에 EVI 출력물을 찾을 수 있습니다:\n\n![EVI 출력물](/TIL/assets/img/2024-07-14-ProduceEVImapswithPythonSentinel2Data_2.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n3- 결과 확인: 시각화와 분석\n\n- EVI 출력 파일 (evi.tif)을 QGIS에 로드합니다.\n- 더 밀집한 식물 상층을 나타내는 더 높은 EVI 값의 시각화를 위해 적합한 컬러 팔레트를 적용합니다.\n- EVI 값에 기반하여 관심 영역을 강조하기 위해 시각화 설정을 조정하여 식물 건강 평가 및 토지 피복 맵핑을 지원합니다.\n\n![이미지1](/TIL/assets/img/2024-07-14-ProduceEVImapswithPythonSentinel2Data_3.png)\n\n![이미지2](/TIL/assets/img/2024-07-14-ProduceEVImapswithPythonSentinel2Data_4.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결론\n\n요약하자면, 향상된 식물지수(EVI)는 원격 감지 응용 프로그램에 강력한 도구로, 식물 역학 및 건강 평가에 대한 감도를 향상시켜줍니다. Sentinel-2 위성 이미지와 Python 및 QGIS와 같은 컴퓨터 도구를 활용하여 연구원 및 실무자는 효과적으로 식물 변화를 모니터링하고 토지 피복 유형을 분류하며 생태학 연구 및 환경 관리에 기여할 수 있습니다. 더 자세한 내용이나 문의 사항이 있으시면 언제든지 댓글을 남기거나 직접 연락해주세요.\n\n# 팔로우\n\n- 내 랜딩 페이지\n- 내 Youtube 채널\n- 내 SaaS 서비스\n- 내 GitHub","ogImage":{"url":"/TIL/assets/img/2024-07-14-ProduceEVImapswithPythonSentinel2Data_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-ProduceEVImapswithPythonSentinel2Data_0.png","tag":["Tech"],"readingTime":8},{"title":"코드 효율성을 높이는 7가지 파이썬 메모리 최적화 비법","description":"","date":"2024-07-14 23:44","slug":"2024-07-14-7PythonMemoryOptimizationTricksToEnhanceYourCodesEfficiency","content":"\n\n## 파이썬\n\n프로젝트가 점점 커지면서, 컴퓨팅 자원을 효율적으로 관리하는 것은 불가피한 요구사항입니다.\n\n안타깝게도, 특히 C나 C++과 같은 저수준 언어와 비교할 때 파이썬은 메모리 효율적이지 못한 것으로 보입니다.\n\n지금 프로그래밍 언어를 바꾸는 것이 좋을까요?\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n물론이죠.\n\n사실, 파이썬 프로그램의 메모리 사용량을 최적화하는 많은 방법이 있습니다. 훌륭한 모듈과 도구부터 고급 데이터 구조와 알고리즘까지 다양한 방법이 있어요.\n\n이 기사는 파이썬의 내장 메커니즘에 초점을 맞추고 7가지 기본적이지만 효과적인 메모리 최적화 요령을 소개할 거에요. 이들을 숙달하면 파이썬 프로그래밍 스킬이 상당히 향상될 거예요.\n\n# 1. 클래스 정의에서 __slots__ 사용하기\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파이썬은 동적 타이핑 언어로 객체 지향 프로그래밍에 있어 유연성을 가지고 있습니다. 좋은 예시로 파이썬 클래스에 런타임에서 추가적인 속성과 메서드를 넣는 기능이 있습니다.\n\n예를 들어, 아래 코드는 'Author'라는 클래스를 정의합니다. 원래 'name'과 'age'라는 두 속성이 있었지만 나중에 손쉽게 하나를 더 추가할 수 있습니다:\n\n```python\nclass Author:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\nme = Author('Yang Zhou', 30)\nme.job = 'Software Engineer'\nprint(me.job)\n# Software Engineer\n```\n\n그러나 동전에는 양면이 있다고 하죠. 이 유연성은 내부에서 더 많은 메모리를 낭비합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파이썬의 클래스의 모든 인스턴스는 인스턴스 변수를 저장하는 특별한 사전(__dict__)을 유지합니다. 이 사전은 해시 테이블 기반의 구현 때문에 메모리 효율이 좋지 않기 때문에 상당한 양의 메모리를 소비합니다.\n\n대부분의 경우에는 인스턴스의 변수나 메서드를 런타임에 변경할 필요가 없으며, 클래스 정의 이후에는 __dict__가 변경되지 않습니다. 따라서 __dict__ 사전을 유지하는 것을 피하는 것이 좋습니다.\n\n파이썬은 이를 위해 마법처럼 동작하는 속성을 제공합니다: __slots__.\n\n이는 클래스의 모든 유효한 속성 이름을 지정하여 화이트리스트로 작동합니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nclass Author:\n    __slots__ = ('name', 'age')\n\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\nme = Author('양주', 30)\nme.job = '소프트웨어 엔지니어'\nprint(me.job)\n# AttributeError: 'Author' object has no attribute 'job'\n```\n\n위의 코드에서 보듯이, 런타임 중에 job 속성을 더 이상 추가할 수 없습니다. 왜냐하면 __slots__ 화이트리스트에서는 name과 age 속성만을 정의했기 때문입니다.\n\n이론적으로 속성이 지금 고정되어 있기 때문에, Python은 더 이상 이를 위한 사전을 유지할 필요가 없습니다. __slots__에서 정의된 속성에 필요한 메모리 공간만 할당하면 됩니다.\n\n이것이 실제로 작동하는지 여부를 확인하기 위해 간단한 비교 프로그램을 작성해 봅시다:\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport sys\n\nclass Author:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\nclass AuthorWithSlots:\n    __slots__ = ['name', 'age']\n\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n# Creating instances\nme = Author('Yang', 30)\nme_with_slots = AuthorWithSlots('Yang', 30)\n\n# Comparing memory usage\nmemory_without_slots = sys.getsizeof(me) + sys.getsizeof(me.__dict__)\nmemory_with_slots = sys.getsizeof(me_with_slots)  # __slots__ classes don't have __dict__\n\nprint(memory_without_slots, memory_with_slots)\n# 152 48\nprint(me.__dict__)\n# {'name': 'Yang', 'age': 30}\nprint(me_with_slots.__dict__)\n# AttributeError: 'AuthorWithSlots' object has no attribute '__dict__'\n```\n\n위 코드에서 볼 수 있듯이, __slots__를 사용하기 때문에 me_with_slots 인스턴스는 __dict__ 사전이 없습니다. 이는 me 인스턴스와 비교하여 추가 사전을 유지해야 하는 리소스를 효과적으로 절약합니다.\n\n# 2. Generators 사용\n\nGenerators는 Python에서 리스트의 게으른 평가 버전입니다.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그들은 요소를 생성하는 공장처럼 작동합니다: 모든 항목을 한꺼번에 계산하는 대신 next() 메서드가 호출될 때마다 항목을 생성합니다.\n\n그렇기 때문에 대규모 데이터셋을 처리할 때 매우 메모리를 효율적으로 사용합니다.\n\n```js\ndef number_generator():\n    for i in range(100):\n        yield i\n\nnumbers = number_generator()\nprint(numbers)\n# <generator object number_generator at 0x104a57e40>\nprint(next(numbers))\n# 0\nprint(next(numbers))\n# 1\n```\n\n위 코드는 제너레이터를 작성하고 사용하는 기본적인 예제를 보여줍니다. yield 키워드가 제너레이터의 정의 핵심입니다. 이를 적용하면 항목 i는 next() 메서드가 호출될 때에만 생성됩니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 제너레이터와 리스트를 비교해보면 어떤 쪽이 더 메모리를 효율적으로 사용하는지 살펴봅시다:\n\n```python\nimport sys\n\nnumbers = []\nfor i in range(100):\n    numbers.append(i)\n\ndef number_generator():\n    for i in range(100):\n        yield i\n\nnumbers_generator = number_generator()\nprint(sys.getsizeof(numbers_generator))\n# 112\nprint(sys.getsizeof(numbers))\n# 920\n```\n\n위 프로그램의 결과는 제너레이터를 사용하면 메모리 사용량을 크게 절약할 수 있다는 사실을 입증합니다.\n\n그런데, 리스트 컴프리헨션의 대괄호를 괄호로 변환하면 제너레이터 표현식이 됩니다. 이것이 파이썬에서 제너레이터를 정의하는 더 간단한 방법입니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nimport sys\n\nnumbers = [i for i in range(100)]\nnumbers_generator = (i for i in range(100))\n\nprint(sys.getsizeof(numbers_generator))\n# 112\nprint(sys.getsizeof(numbers))\n# 920\n```\n\n# 3. 대용량 파일 처리를 위한 메모리 맵 파일 지원 활용\n\n메모리 맵 파일 I/O, 줄여서 \"mmap\"이라고도 불리는 것은 OS 수준의 최적화입니다.\n\n간단히 말해서, mmap 기술을 사용하여 파일을 메모리 맵핑하면 현재 프로세스의 가상 메모리 공간에 파일의 맵핑이 직접 생성되어 파일 전체를 메모리에 로드하는 대신 처리합니다.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테이블 태그를 Markdown 형식으로 변경할 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nimport mmap\n\nwith open('test.txt', \"r+b\") as f:\n    # 파일을 메모리 매핑하여 사용할 수 있습니다. 크기 0은 전체 파일을 의미합니다.\n    with mmap.mmap(f.fileno(), 0) as mm:\n        # 표준 파일 메서드를 사용하여 내용 읽기\n        print(mm.read())\n        # 슬라이스 표기법을 사용하여 내용 읽기\n        snippet = mm[0:10]\n        print(snippet.decode('utf-8'))\n```\n\n위에서 보여진 대로, Python은 메모리 매핑된 파일 I/O 기술의 사용을 편리하게 만듭니다. 우리가 해야 할 일은 단지 mmap.mmap() 메서드를 적용하고, 표준 파일 메서드나 슬라이싱 표기법을 통해 개방된 객체를 처리하는 것뿐입니다.\n\n# 4. 전역 변수 사용 최소화\n\n전역 변수는 글로벌 스코프를 갖기 때문에 프로그램이 실행되는 동안 메모리에 유지됩니다.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n전역 변수가 큰 데이터 구조를 보유하는 경우 프로그램 수명 전체 동안 메모리를 점유하므로 비효율적인 메모리 사용으로 이어질 수 있습니다.\n\n파이썬 코드에서 전역 변수 사용을 최소화해야 합니다.\n\n# 5. 논리 연산자의 단축 평가 활용\n\n이 꿀팁은 섬세해 보일 수 있지만, 스마트하게 사용하면 프로그램의 메모리 사용량을 중대하게 절약할 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예를 들어, 반환된 boolean 값에 따라 최종 결과를 얻는 간단한 코드 스니펫이 있습니다:\n\n```js\nresult_a = expensive_function_a()\nresult_b = expensive_function_b()\nresult = result_a if result_a else result_b\n```\n\n위의 코드는 동작하지만 실제로 두 가지 메모리 비효율적인 함수를 실행합니다.\n\n동일한 결과를 얻는 더 스마트한 방법은 다음과 같습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nresult = expensive_function1() or expensive_function2()\n```\n\n위 코드의 논리 연산자는 단락 평가 규칙을 따르기 때문에, expensive_function1()이 True 인 경우, 위 코드의 expensive_function2()는 실행되지 않습니다. 이는 불필요한 메모리 사용을 절약할 수 있습니다.\n\n# 6. 데이터 유형 신중히 선택하기\n\n고급 Python 개발자는 데이터 유형을 신중하고 정확하게 선택할 것입니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n특정 상황에서는 다른 데이터 유형을 사용하는 것이 다른 것보다 더 메모리를 효율적으로 사용합니다.\n\n## 튜플은 리스트보다 메모리를 효율적으로 사용합니다\n\n튜플은 변경할 수 없는(생성 후에 변경할 수 없음) 특성 때문에 Python은 메모리 할당 측면에서 최적화를 할 수 있습니다.\n\n하지만, 리스트는 변경 가능하기 때문에 잠재적인 수정 사항을 수용하기 위해 추가 공간이 필요합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport sys\n\nmy_tuple = (1, 2, 3, 4, 5)\nmy_list = [1, 2, 3, 4, 5]\n\nprint(sys.getsizeof(my_tuple))\n# 80\nprint(sys.getsizeof(my_list)) \n# 120\n```\n\n위 코드 조각에서 보듯이, 같은 요소를 포함하고 있어도 튜플인 my_tuple이 리스트보다 적은 메모리를 사용합니다.\n\n따라서, 데이터를 생성한 후에 변경할 필요가 없다면 리스트 대신 튜플을 사용하는 것이 좋습니다.\n\n## 배열은 리스트보다 메모리를 더 효율적으로 사용합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파이썬의 배열은 요소들이 동일한 데이터 유형이어야 합니다(예: 모두 정수 또는 모든 부동 소수점 수), 그러나 리스트는 다른 유형의 객체를 저장할 수 있기 때문에 더 많은 메모리가 필요합니다.\n\n따라서 배열을 사용하면 리스트 요소가 모두 동일한 유형인 경우 더 메모리 효율적입니다:\n\n```python\nimport sys\nimport array\n\nmy_list = [i for i in range(1000)]\n\nmy_array = array.array('i', [i for i in range(1000)])\n\nprint(sys.getsizeof(my_list))  \n# 8856\nprint(sys.getsizeof(my_array)) \n# 4064\n```\n\n## 우수한 데이터 과학 모듈이 내장 데이터 유형보다 효율적입니다\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파이썬은 데이터 과학의 주요 언어입니다. NumPy와 Pandas와 같은 강력한 타사 모듈과 도구들이 더 많은 데이터 유형을 제공합니다.\n\n만약 NumPy가 제공하는 많은 기능이 필요하지 않고 단순한 1차원 숫자 배열만 필요하다면, 파이썬의 내장 배열이 좋은 선택일 수 있습니다.\n\n하지만 복잡한 행렬 조작이 필요한 경우에는, NumPy가 제공하는 배열을 사용하는 것이 모든 데이터 과학자에게 첫 번째이자 아마도 최상의 선택일 것입니다.\n\n# 7. 동일한 문자열에 문자열 인터닝 기술을 적용\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n많은 개발자들을 혼란스럽게 만들 수 있는 코드는 다음과 같습니다:\n\n```js\na = 'Y'*4096\nb = 'Y'*4096\na is b\nTrue\nc = 'Y'*4097\nd = 'Y'*4097\nc is d\nFalse\n```\n\nis 연산자는 두 변수가 메모리에서 동일한 객체를 참조하는지 확인하는 데 사용됩니다. 이는 == 연산자와는 다릅니다. == 연산자는 두 객체의 값을 비교합니다.\n\n그래서 a is b는 True를 반환하지만, c is d는 False를 반환하는 이유는 무엇인가요?\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파이썬에는 숨겨진 보석이 있습니다 — 문자열 인터닝 기술이 그것입니다.\n\n값이 같은 몇 개의 작은 크기 문자열들이 있다면, 파이썬은 암묵적으로 그들을 인터닝하고 메모리에서 동일한 객체를 참조합니다.\n\n작은 문자열을 정의하는 마법 숫자는 4096입니다.\n\nc와 d의 길이가 4097이므로, 두 개의 객체가 메모리에 있기 때문에, 암묵적인 문자열 인터닝은 일어나지 않습니다. 따라서 c is d를 실행하면 False를 얻습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n문자열 인터닝은 메모리 사용량을 최적화하는 강력한 기술입니다. 명시적으로 수행하려면 sys.intern() 메서드를 활용해야 합니다:\n\n```js\n>>> import sys\n>>> c = sys.intern('Y'*4097)\n>>> d = sys.intern('Y'*4097)\n>>> c is d\nTrue\n```\n\n그리고, 문자열 인터닝 외에도 Python은 작은 정수에 대해서도 인터닝 기법을 적용합니다. 이를 메모리 최적화 목적으로 활용할 수도 있습니다.\n\n독서해 주셔서 감사합니다. ❤️ 마음에 드셨다면, 연결하고 싶습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nX | Linkedin | Medium \n\n파이썬 메모리 관리 메커니즘에 관한 인터뷰 질문:","ogImage":{"url":"/TIL/assets/no-image.jpg"},"coverImage":"/TIL/assets/no-image.jpg","tag":["Tech"],"readingTime":14},{"title":"Python에서 Factory Method 패턴 사용하는 방법","description":"","date":"2024-07-14 23:43","slug":"2024-07-14-FactoryMethodpatterninPython","content":"\n\n디자인 패턴은 미래에 이를 유지하는 것이 더 쉬운 방식으로 반복되는 여러 가지 문제를 해결할 수 있게 해줍니다.\n\n이를 감안할 때 각 디자인 패턴을 알아야 특정 문제를 해결할 때 더 큰 유연성을 가질 수 있습니다.\n\n내가 보는 문제는 보통 이 디자인 패턴 중 하나를 배우려고 할 때 실제로 직면한 문제를 알지 못한 채로 아주 긴 설명들을 마주하게 된다는 것입니다.\n\n이 이야기에서는 공장 메서드 패턴을 가능한 간단히 설명해 보겠습니다. 이렇게 함으로써 해당 패턴이 해결하고 있는 문제와 어떻게 구현되는지 이해할 수 있을 것입니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n<img src=\"/TIL/assets/img/2024-07-14-FactoryMethodpatterninPython_0.png\" />\n\n# Factory Method 패턴을 사용하지 않은 예제\n\n다른 종류의 문서인 이력서와 보고서를 가진 예제를 만들어 봅시다.\n\n이러한 문서 유형은 고유한 생성자를 가질 것입니다:\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nfrom abc import ABC, abstractmethod\n\n# 제품 인터페이스 정의\nclass Document(ABC):\n    @abstractmethod\n    def create(self):\n        pass\n\n# 구체적인 제품 생성\nclass Resume(Document):\n    def create(self):\n        return \"이력서 생성됨\"\n\nclass Report(Document):\n    def create(self):\n        return \"보고서 생성됨\"\n```\n\n이후에는 이 유형의 문서를 선택하는 함수가 있을 것입니다:\n\n```js\ndef create_document(document_type: str) -> Document:\n    if document_type == \"resume\":\n        return Resume()\n    elif document_type == \"report\":\n        return Report()\n    else:\n        raise ValueError(f\"알 수 없는 문서 유형: {document_type}\")\n```\n\n이후 팩토리 메서드 패턴을 통해 이 함수의 구현을 개선할 수 있음을 나중에 확인하게 될 것입니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n나머지 코드는 문서 유형을 사용하는 방법을 보여줍니다:\n\n```js\ndef client_code(document_type: str):\n    document = create_document(document_type)\n    print(document.create())\n\nif __name__ == \"__main__\":\n    print(\"이력서 생성:\")\n    client_code(\"resume\")\n    \n    print(\"\\n보고서 생성:\")\n    client_code(\"report\")\n```\n\n# 팩토리 메서드 사용\n\n리팩토링에서는 여전히 각 객체의 생성자가 있습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nfrom abc import ABC, abstractmethod\n\n# 제품 인터페이스 정의\nclass Document(ABC):\n    @abstractmethod\n    def create(self):\n        pass\n\n# 구체적인 제품 생성\nclass Resume(Document):\n    def create(self):\n        return \"이력서 생성됨\"\n\nclass Report(Document):\n    def create(self):\n        return \"보고서 생성됨\"\n```\n\n그러나 이제 각 유형의 문서 생성을 탈 중앙화했습니다:\n\n```python\n# 팩토리 메서드를 사용하여 생성자 클래스 정의\nclass DocumentCreator(ABC):\n    @abstractmethod\n    def factory_method(self):\n        pass\n\n    def create_document(self):\n        # 제품을 얻기 위해 팩토리 메서드 호출\n        document = self.factory_method()\n        return document.create()\n\n# 구체적인 생성자 구현\nclass ResumeCreator(DocumentCreator):\n    def factory_method(self):\n        return Resume()\n\nclass ReportCreator(DocumentCreator):\n    def factory_method(self):\n        return Report()\n```\n\n새로운 문서 유형을 추가하는 것은 새로운 구체적인 생성자 클래스를 만드는 것만큼 간단합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n나머지 코드는 문서 유형을 사용하는 방법을 보여줍니다:\n\n```js\ndef client_code(creator: DocumentCreator):\n    print(creator.create_document())\n\nif __name__ == \"__main__\":\n    print(\"이력서 생성 중:\")\n    resume_creator = ResumeCreator()\n    client_code(resume_creator)\n    \n    print(\"\\n보고서 생성 중:\")\n    report_creator = ReportCreator()\n    client_code(report_creator)\n```\n\n# 차이점 설명\n\n주요 차이점은 팩토리 메서드 패턴을 사용하지 않을 때, 객체를 프로그램 로직을 정의하는 곳과 동일한 위치에서 생성한다는 것입니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\ndef create_document(document_type: str) -> Document:\n    if document_type == \"resume\":\n        return Resume()\n    elif document_type == \"report\":\n        return Report()\n    else:\n        raise ValueError(f\"Unknown document type: {document_type}\")\n```\n\n위의 예제는 매우 간단합니다. 새로운 문서 유형을 추가하거나 삭제할 때 이 논리를 변경하는 것은 비교적 쉬우지만, 더 복잡한 경우에는 더 비용이 많이 들 수 있습니다.\n\n게다가, 이것에는 훌륭한 논리가 없습니다. 각 if/else 이후에 일련의 동작이 수행된다고 상상해보세요.\n\n## 비교\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 팩토리 메소드 없이: 문서 생성 로직은 create_document 함수에 중앙 집중화되어 있습니다. 이는 더 간단하지만 코드를 유연하게 만들고 유지하기 어렵게 만듭니다. 새로운 유형의 문서를 추가하려면 create_document 함수를 수정해야 하며, 이로 인해 버그가 발생할 수 있고 전체 함수의 로직을 이해해야 합니다.\n- 팩토리 메소드 사용: 생성 로직이 분산됩니다. 각 구체적인 생성자는 자체 유형의 문서를 생성하는 방법을 알고 있습니다. 새로운 유형의 문서를 추가하는 것은 새로운 구체적인 생성자 클래스를 만드는 것만큼 간답습니다. 이 접근 방식은 개방/폐쇄 원칙을 준수하며 코드를 보다 모듈식으로 만들고 확장하기 쉽게 만듭니다.\n\n![Factory Method Pattern](/TIL/assets/img/2024-07-14-FactoryMethodpatterninPython_1.png)\n\n# 어떻게 인식할까요?\n\n이 패턴을 사용해야 하는 시점은 로직 일부가 서로 다른 객체 유형을 생성하는 if/else if/else를 사용하고 있을 때 가장 쉽게 인식할 수 있습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n# 예시\ndef mainfuntion():\n    if option==1:\n        Object1=Object_constructor()\n        action1()\n        action2()\n    elif option==2:\n        Object2=Object_constructor2()\n        action3()\n        action4()\n    else:\n        Object3=Object_constructor3()\n        action5()\n        action6()\n\n\n우리는 보듯이, 이 논리는 사용된 객체의 유형에 매우 의존합니다. 다른 유형의 객체를 사용해야 한다면 프로그램의 논리를 바꿀 필요가 있습니다.\n\n이러한 패턴을 보게 되면, 팩토리 메서드를 사용하여 개선을 고려할 수 있습니다.\n\n# 결론\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n인터넷에서 찾을 수 있는 것들과는 조금 다른 방식으로 이 디자인 패턴을 설명해 보았어요. 가능한 가장 간단한 방법으로 설명해 보았답니다.\n\n저는 이러한 패턴에 대해 다양한 정보원에서 배우는 것이 이상적이라고 생각해요. 각각의 예시를 보면서 개념을 더 깊이 이해할 수 있을 거예요.\n\n이야기가 마음에 들기를 바랍니다.\n\n관심 가져 주셔서 정말 감사합니다!","ogImage":{"url":"/TIL/assets/img/2024-07-14-FactoryMethodpatterninPython_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-FactoryMethodpatterninPython_0.png","tag":["Tech"],"readingTime":7},{"title":"주가 분석 종합 데이터 사이언스 접근 방법","description":"","date":"2024-07-14 23:41","slug":"2024-07-14-StockPriceAnalysisAComprehensiveDataScienceApproach","content":"\n\n고급 데이터 과학과 금융 통찰력을 통합하여 전략적 투자 결정을 내리기\n\n![Stock Price Analysis](/TIL/assets/img/2024-07-14-StockPriceAnalysisAComprehensiveDataScienceApproach_0.png)\n\n소개\n\n본 글에서는 주식 가격을 더 정확하게 예측하기 위해 데이터 과학과 금융 분석을 결합한 방법을 소개합니다. 이번 방법에 대한 간단한 소개입니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n트렌드 발견하기: 우리는 주식 시세를 부드럽게 만들어 트렌드를 파악하는데, cubic spline interpolation이라는 기술을 사용합니다.\n\n주식 그룹화: 비슷한 주식들은 이러한 트렌드를 기반으로 그룹화되어, 그들을 집단으로 분석하기가 더 쉽습니다.\n\n모델 만들기: 한 그룹을 선택하면, 우리는 미래 주식 수익을 예측하는 모델을 만듭니다.\n\n주요 요인 설명: 우리는 SHAP 값들을 사용하여 예측에 가장 영향을 많이 주는 요인을 이해합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n최적 주식 선택: Response Surface Methodology (RSM)을 통해 잠재력이 높은 주식을 식별합니다.\n\n게다가, 이 방법은 핵심 재무 개념에 대한 새로운 통찰력을 제공합니다:\n\n시계열 한계 해결: 이 방법은 효율적 시장 가설을 고려한 안정적이고 신뢰할 수 있는 대안을 제공하여 시계열 분석의 복잡성을 탐색합니다.\n\n샤프 비율 새로이 상상하기: 우리는 수익률 대 위험을 측정하는 방식을 개선하는 샤프 비율의 향상된 버전을 탐구합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n제 목표는 깊은 분석과 판단 전략을 결합하여 주식 가격을 예측하는 철저하고 효과적인 시스템을 만드는 것입니다.\n\n데이터 수집 및 초기 정리\n\n우선 Python을 통해 시장 데이터에 직접 액세스하기 위해 yfinance 라이브러리를 설치하세요:\n\n```js\npip install yfinance --upgrade\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n설치 후 yfinance를 사용하면 선택한 기간 동안 다양한 티커에 대한 일일 주식 가격 및 거래량을 조회할 수 있습니다:\n\n```js\nimport pandas as pd\nimport yfinance as yf\n\ndef get_data_by_day(ticker_list, start, end):\n    interval = '1d'\n    # 루프에서 데이터를 추가하는 것을 피하기 위해 DataFrame을 위한 열들을 미리 정의합니다\n    columns = ['Date', 'Open', 'High', 'Low', 'Close', 'Volume', 'ticker']\n    data_list = []\n    for ticker in ticker_list:\n        df = yf.download(ticker, start=start, end=end, interval=interval)\n        if not df.empty:\n            df['ticker'] = ticker\n            data_list.append(df)\n    download_data = pd.concat(data_list).reset_index()\n    download_data = download_data[columns]  # 열 재정렬 및 관련 열 선택\n    \n    unique_dates = download_data['Date'].drop_duplicates().sort_values(ascending=False).reset_index(drop=True)\n    date_map = pd.Series(range(1, len(unique_dates) + 1), index=unique_dates)\n    download_data['dayseq'] = download_data['Date'].map(date_map)\n    download_data = download_data.sort_values(['ticker', 'Date'], ascending=[False, False])\n    return download_data\n```\n\n데이터 수집 후: 극히 낮은 가격 또는 거래량을 가진 주식 및 음수 값으로 데이터의 정확성을 보장하기 위해 필터링하여 분석을 왜곡할 수 있는 가능성이 있는 에러를 제거합니다:\n\n```js\n# 일관성을 위해 열 이름 조정\ndf = df[['ticker', 'date_dt', 'Close', 'Volume']].rename(columns={'date_dt': 'date', 'Close': 'price', 'Volume': 'Volume'})\n# $1 미만의 주가를 가진 주식 제거\nmin_prices = df.groupby('ticker')['price'].min().reset_index()\ndf = df[~df.ticker.isin(min_prices[min_prices.price < 1].ticker)]\n# 비양수 거래량을 갖는 주식 제거\nmin_volumes = df.groupby('ticker')['Volume'].min().reset_index()\ndf = df[~df.ticker.isin(min_volumes[min_volumes.Volume < 1].ticker)]\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n분석 작업을 위해 2022년 6월 7일부터 2023년 6월 7일까지 384개의 신중히 선정된 주식에 대한 데이터가 편성되었습니다. 선정 기준은 무작위가 아니며, 다양한 부문, 자산 규모, 가격 대 역까지 다양한 요소를 고려해 종합적인 시장 전체를 포착하려는 것입니다. 이 다양성을 통해 분석 결과가 전체 시장 역학을 반영할 수 있을 것으로 기대합니다.\n\n원활한 데이터 기능을 활용한 분석 강화\n\n분석을 개선하고 보다 정확한 예측 모델을 개발하기 위해 일일 원시 데이터 대신 원활화된 데이터를 선택했습니다. 이 방법론은 여러 가지 장점에 기반해 있습니다:\n\n- 시장 소음 최소화: 금융 시장의 빈번한 가격 흔들림이 분석을 방해할 수 있습니다. 원활화는 이러한 변동성을 완화시켜 더 명확한 그림을 제공합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n· 패턴 발견: 주식 가격에 영향을 미치는 기본적인 추세를 발견하고 연구하는 것이 더 간단해집니다.\n\n· 더 나은 군집화: 부드러운 데이터를 사용하면 유사한 가격 추세를 가지는 주식을 더 정확하게 그룹화할 수 있습니다.\n\n· 향상된 모델링: 부드럽게 처리된 특징을 사용하면 예측 모델의 초점이 좀 더 선명해지며 효과를 증대시킬 수 있습니다.\n\n파이썬을 사용하여 금융 데이터에 부드럽게 처리 기술을 적용하는 단계를 요약하면 다음과 같습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 데이터 분리 및 정렬: 주식 데이터를 분리하고 날짜별로 정렬합니다.\n\n- X 값 설정: 각 데이터 포인트를 인덱싱하기 위한 정수 시퀀스를 생성합니다.\n\n- Cubic Spline 적용: 가격 및 거래량 데이터에 3을 사용하여 부드러운 cubic spline interpolation을 적용하여 부드러운 곡선을 생성합니다.\n\n- 주요 지점 선택: 이러한 곡선에서 균일 간격으로 30개의 지점을 선택하여 데이터셋을 간단화합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n감사합니다. 아래는 주식 데이터를 스무딩하는 파이썬 코드입니다:\n\n```python\n# 부드럽게 정리된 데이터 저장\n부드럽게 정리된 데이터를 참조할 수 있는 인덱스 열을 포함한 DataFrame에 저장합니다.\n\n# 데이터 통합\n개별 DataFrame을 통합된 데이터 세트로 병합하여 추가 분석을 수행합니다.\n\n최종 데이터 세트는 원래 250개의 일일 데이터 포인트에서 간격이 8개의 거래일을 두고 30개의 가격 노드로 축소되었습니다.\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nimport pandas as pd\nimport numpy as np\nfrom scipy.interpolate import make_interp_spline\n\n# 'df'이 데이터프레임으로, ['ticker', 'date', 'price', 'Volume'] 열을 가지고 있다고 가정합니다.\nresult_df = pd.DataFrame()\n\nfor ticker in df['ticker'].unique():\n    df_ticker = df[df['ticker'] == ticker].sort_values(by='date')\n    # x 값 생성 후 가격과 거래량에 대해 cubic spline interpolation 적용합니다.\n    x_vals = np.arange(len(df_ticker))\n    spline_price = make_interp_spline(x_vals, df_ticker['price'], k=3)(np.linspace(x_vals.min(), x_vals.max(), 300))\n    spline_volume = make_interp_spline(x_vals, df_ticker['Volume'], k=3)(np.linspace(x_vals.min(), x_vals.max(), 300))\n\n    # 부드러운 곡선에서 30개의 등간격 포인트를 선택합니다.\n    indices = np.linspace(0, 299, 30, dtype=int)\n    # 해당 종목의 부드럽게 처리된 데이터를 위한 DataFrame을 준비합니다.\n    df_smooth = pd.DataFrame({\n        'ticker': ticker,\n        'smooth_price': spline_price[indices],\n        'smooth_volume': spline_volume[indices],\n        'seq': np.arange(30, 0, -1)  # 30부터 1까지 역순으로 순번을 부여합니다.\n    })\n\n    # 부드럽게 처리된 데이터를 추가합니다.\n    result_df = pd.concat([result_df, df_smooth], ignore_index=True)\n```\n\n여기에 AAPL을 예시로 한 부드럽게 처리된 데이터가 표시되어 있습니다:\n\n![AAPL Smoothed Data](/TIL/assets/img/2024-07-14-StockPriceAnalysisAComprehensiveDataScienceApproach_1.png)\n\n주식 군집을 통해 금융 모델을 향상시킬 수 있습니다.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n시계열 모델의 도전:\n\nARIMA와 같은 모델로 주가를 예측하는 것은 효율적 시장 가설로 인한 도전에 직면합니다. 이 이론은 현재 주가가 모든 기존 정보를 반영하고 있어서, 시장 가격이 새로운 정보에 예측할 수 없이 반응함에 따라 예측이 랜덤 워크를 모방하게 됨을 시사합니다.\n\n다양한 데이터의 한계:\n\n여러 주식을 함께 모델링하는 것은 페어 트레이딩에서 사용되는 것처럼 유용한 상관 관계를 발견할 수 있습니다. 그러나 서로 다른 주식들 간의 독특한 패턴과 추세(예: AAPL 대 TSLA)는 일관된 모델 개발을 방해합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n전략적 접근 - 클러스터링:\n\n주식을 행동 또는 추세의 유사성을 기반으로 클러스터로 그룹화하면 더 정확하고 그룹별 모델링이 가능해져 예측의 정확도가 향상됩니다.\n\nKMeans를 사용한 주식 클러스터링:\n\n- 데이터 구조화: 스무딩된 주식 데이터를 중심 가격 30개와 일치시켜야 합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n· 정규화: 데이터에 표준화를 적용하여 일관된 KMeans 분할을 실시합니다.\n\n· 클러스터 최적화: KMeans 및 Elbow Method를 사용하여 이상적인 클러스터 수를 결정하고 WCSS에 초점을 맞춥니다.\n\n· 클러스터링 평가: KMeans를 사용하여 주식을 그룹화하고 실루엣 점수를 통해 효과를 평가합니다.\n\n여기에는 파이썬 코드가 포함되어 있습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.cluster import KMeans\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom sklearn import metrics\n\n# 데이터 피벗\nresult_df_pivoted = result_df.pivot(index='ticker', columns='seq', values=['smooth_price', 'smooth_volume'])\nresult_df_pivoted.columns = [f'{val}_{i}' for val, i in result_df_pivoted.columns]\nresult_df_pivoted.reset_index(inplace=True)\n# 데이터 표준화\nscaler = StandardScaler()\nprice_columns = [col for col in result_df_pivoted.columns if 'smooth_price' in col]\nresult_df_pivoted[price_columns] = scaler.fit_transform(result_df_pivoted[price_columns])\nresult_df_std = result_df_pivoted[['ticker'] + price_columns]\n\n# 최적 클러스터 수 결정\nK = range(1, 10)\nsum_of_squared_distances = []\nfor k in K:\n    kmeans = KMeans(n_clusters=k).fit(result_df_std.drop('ticker', axis=1))\n    sum_of_squared_distances.append(kmeans.inertia_)\nplt.plot(K, sum_of_squared_distances, 'bx-')\nplt.xlabel('K values')\nplt.ylabel('Sum of Squared Distances')\nplt.title('Elbow Method for Optimal K')\nplt.show()\n```\n\n![Stock Price Analysis Image](/TIL/assets/img/2024-07-14-StockPriceAnalysisAComprehensiveDataScienceApproach_2.png)\n\nWCSS 곡선 분석 결과, 명확한 팔꿈치 지점으로 4가 최적 클러스터 수로 나타났습니다.\n\n4개 클러스터로 진행하여, 실루엣 지수를 통해 각 클러스터의 품질을 평가합니다.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nkmeans = KMeans(n_clusters=4)\nresult_df_std['cluster'] = kmeans.fit_predict(result_df_std.drop('ticker', axis=1))\n# 성능 평가\nsilhouette_score = metrics.silhouette_score(result_df_std.drop(['ticker', 'cluster'], axis=1), result_df_std['cluster'])\nprint(f'실루엣 점수: {silhouette_score}')\n```\n\n실루엣 지수가 0.594로, 클러스터링 구조는 상당히 좋은 것으로 보여져 적절하게 구분된 그룹을 나타냅니다.\n\n클러스터 분포를 시각화하기 위해 주성분 분석(PCA)를 적용하여 차원을 축소합니다:\n\n```python\nfrom sklearn.decomposition import PCA\n\n# PCA 초기화 및 X를 두 가지 구성 요소로 축소\npca = PCA(n_components=2)\nX_pca = pca.fit_transform(result_df_std[cols])\n\n# 분할별로 색칠된 PCA 변환 기능 표시\nplt.figure(figsize=(10, 6))\nscatter = plt.scatter(X_pca[:, 0], X_pca[:, 1], c=labels, cmap='viridis', alpha=0.75, s=7)\nplt.title('주식 티커의 주성분 분석')\nplt.xlabel('첫 번째 주성분')\nplt.ylabel('두 번째 주성분')\nplt.colorbar(scatter, label='분할')\nplt.show()\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/TIL/assets/img/2024-07-14-StockPriceAnalysisAComprehensiveDataScienceApproach_3.png\" />\n\n주식 가격의 동일한 행동 양식을 강조하여 주식의 명확한 그룹화를 보여주는 그림입니다.\n\n주식 수익률 예측을 단순화하기 위한 목표 개요\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n목표는 식별된 클러스터 내 주식 수익률을 예측하는 모델을 개발하는 것입니다. 주요 준비 단계는 다음과 같습니다:\n\n- 피처 선택: 이 프로젝트의 범위 내에서 오버피팅의 약간의 위험을 갖고 있지만, 다수의 피처(smooth_price1 ~ smooth_price30)를 클러스터링에 활용합니다. 더 좁은 피처 세트(smooth_price1 ~ smooth_price20)를 사용하더라도 클러스터 무결성에 큰 영향을 미치지 않습니다.\n\n- 인구 밀집 클러스터에 집중: 모델링 노력을 인구 밀집된 클러스터에 집중하여 관찰된 패턴의 신뢰도와 일관성을 향상시키고 모델의 정밀도를 향상시킵니다.\n\n- 모델 결과 평가: 주요 영향요인 검토와 예측 성능 평가가 포함됩니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n샤프 지수 통합\n\n리스크-프리 자산에 대한 투자 성과를 평가하는 데 중요한 지표인 샤프 지수는 저희 방법론의 기반이 됩니다:\n\n![image](/TIL/assets/img/2024-07-14-StockPriceAnalysisAComprehensiveDataScienceApproach_4.png)\n\nWhere:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n표 태그를 다음과 같이 마크다운 형식으로 변경하세요.\n\n| S: 샤프 비율 |\n| E: 기대 자산 수익률과 기준 수익률의 차이 |\n| R: 자산 초과 수익의 표준 편차 |\n\n선형 회귀 포함: 우리는 샤프 비율 (S)을 선형 회귀 모형에서 계수로 통합하여 주식 성과를 클러스터 내에서 평가합니다. 더 높은 비율은 우수한 결과와 관련되어 있습니다. 응용 프로그램 목적을 위해, 우리는 R로 '위험' (주식 수익의 변동성 또는 수익의 표준 편차)을 대체하고 E로 실제 주식 수익을 대체합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/TIL/assets/img/2024-07-14-StockPriceAnalysisAComprehensiveDataScienceApproach_5.png\" />\n\n샤프 비율에 관한 맥락에서 중요한 점은 선형 회귀 모델이 예측 모델이 아닌 것을 알아야 합니다. 대신, 이 모델은 주식 수익과 위험 사이의 상관 관계를 동일한 시간 프레임 내에서 반영합니다. 더 나아가, 선형 회귀는 개별 주식의 특성에 속하는 샤프 비율을 유도하기 위해 다양한 주식 그룹에 대해 적용될 수 없습니다.\n\n그러나 이 회귀 접근법을 다양한 주식 클러스터에 적용함으로써, 이러한 클러스터의 성능을 평가하고 차별화하는 비교적인 샤프 비율과 비슷한 특성을 생성할 수 있습니다. 이 방법은 샤프 비율을 과거 지표로 활용하여, 어떻게 투자가 위험 조정 수익 측면에서 진행되었는지를 보여줍니다.\n\n주식 예측을 위한 샤프 비율 사용의 한계\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n종목 예측에 Sharpe Ratio에 의존하는 주요 과제는 다음과 같습니다:\n\n- 복잡한 상호 작용: Sharpe Ratio와 수익의 관계는 상이할 수 있으며, 일부 주식에 대해 양의 값을 가지는 반면, 다른 주식에 대해서는 음의 값을 가질 수 있어서 단일 관점으로 캡처할 수 없는 다양한 상호 작용을 나타낼 수 있습니다.\n\n- 불완전한 그림: 위험과 수익을 단일 측정 값으로 요약함으로써, 과거 수익 추세와 같은 중요한 요소를 놓치게 됩니다.\n\n- 단순한 관계: 미래 수익과 단일 측정 값 간의 선형 관계를 가정하는 것은 복잡하고 비선형적인 동력을 간과하며, 이는 이차식 관계와 같은 비선형 표현에 대한 모델을 개선하고 최적화하는 것을 어렵게 합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모델 강화 전략\n\n모델을 개선함에 있어 Sharpe Ratio 개념에서 영감을 받아 한계를 극복하기 위해 다음과 같은 전략을 사용합니다:\n\n- 향상된 피처 엔지니어링: 수익 변동성 및 과거 수익의 이차식과 같은 보다 다양한 변수를 포함하여 정밀도를 향상시킵니다.\n\n- 타겟 클러스터 트레이닝: 비슷한 주식 군집의 데이터를 활용하여 맞춤형 모델링을 수행합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 대상 변환: 미래 수익을 더 잘 예측하기 위해 대상 변수를 수정합니다.\n\n- GLM 활용: 일반화 선형 모델(GLM) 기법을 사용하여 연속적인 수익 예측에는 선형 회귀를, 범주형 예측에는 로지스틱 회귀를 적용합니다.\n\n- 선택적 특징 통합: 예측 성능을 향상시키기 위해 특징 선택 전략을 사용합니다.\n\n모델 형식은 다음과 같습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 Markdown 형식으로 표현한 내용입니다.\n\n![Stock Price Analysis](/TIL/assets/img/2024-07-14-StockPriceAnalysisAComprehensiveDataScienceApproach_6.png)\n\n주식 수익률(E)의 링크 함수:\n\n- 모델 1: Y = f(E) = E: 선형 회귀\n- 모델 2: Y = f(E) = (E`t) + 0: 이진 분류\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예측 기간 및 특성 생성:\n\n가장 최근 시점부터 10번째까지의 수익률을 예측하기 위해 다음과 같이 계산합니다:\n\n```js\ntrain_df['return'] = 100 * (train_df['smooth_price_1'] - train_df['smooth_price_10']) / train_df['smooth_price_10']\n```\n\n포함된 특성은 다음과 같습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n**수익률의 변동성:** 연속된 부드러운 가격 간 백분율 변동의 표준편차입니다.\n\n**과거 수익률 특징:** \"smooth_price11\"과 이후 가격 간 수익률 구간을 위한 9개의 새 열(past_return_1에서 past_return_9)입니다.\n\n**이차 상호 작용 항목:** 특성 선택 이후 선택된 것입니다.\n\n파이썬으로 구현된 특성 엔지니어링:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nfor i in range(24, 0, -1):\n    train_df[f'return_{i}'] = (train_df[f'smooth_price_{i}'] - train_df[f'smooth_price_{i+1}']) / train_df[f'smooth_price_{i+1}']\n\ntrain_df['risk_return'] = train_df[return_columns[0:15]].std(axis=1)\ntrain_df['risk_return_2'] = train_df['risk_return']**2\n```\n\nGeneralized Linear Models (GLM)을 사용한 모델링:\n\n특성 선택 후에, 중요한 특성들인 risk_return, 과거_return_2의 이차항, 그리고 이 둘의 상호작용을 사용하여 주식 수익률 예측을 위해 GLM을 적용합니다.\n\n```js\nimport statsmodels.api as sm\n\nX = sm.add_constant(train_df_clus0[['risk_return', 'past_return_2_squared', 'risk_past_interaction']])\ny = np.log(train_df_clus0['return'] + 1)  # 안정성을 위한 로그 변환\nmodel = sm.OLS(y, X).fit()\n\nprint(model.summary())\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 모델은 이 예제에서 다루지 않은 특징 선택 과정을 거친 후 선택된 특징을 사용합니다:\n\n![image](/TIL/assets/img/2024-07-14-StockPriceAnalysisAComprehensiveDataScienceApproach_7.png)\n\n모델의 수정된 R-제곱은 약 29%로, 주식 시장에서 정확한 수익률 예측에는 제한이 있음을 나타냅니다. 그러나 주식 선택에 대한 유용성은 주목할만 합니다. 중요한 예측 변수에는 risk_return, past_return_2의 이차항 및 risk_return과 past_return_2의 상호 작용 항이 포함되어 있으며, 이들이 분석에서의 관련성을 보여줍니다.\n\n이진 분류를 위한 로지스틱 회귀:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n특정 수익 임계값을 넘을지 예측하는 데 적합한 경우, 로지스틱 회귀 모델을 구축하였습니다:\n\n```python\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import roc_auc_score, roc_curve\n\nlogist_model = LogisticRegression().fit(X_train, y_train)\npred_probs = logist_model.predict_proba(X_test)[:, 1]\nauc = roc_auc_score(y_test, pred_probs)\n\nprint(f'AUC: {auc}, KS 통계량: {ks}')\n```\n\nAUC가 82%이고 KS 통계량이 61%인 경우, 로지스틱 모델은 테스트 데이터에서 주식 선택을 검증하는 데 강력한 성능을 보여줍니다. 이러한 메트릭은 해당 수익 임계값을 초과할 것으로 예상되는 주식을 구분하는 모델의 능력을 강조합니다.\n\nSHAP 값을 사용하여 주식 성과를 분석합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nSHAP 값은 개별 주식 영향을 깊이 이해하게 도와주며, 정확한 전략 개발을 가능케 합니다. 'std'와 같은 특정 원인을 강조함으로써, SHAP 값은 변동성이 수익 잠재력에 미치는 영향을 나타내며, 전반적인 특성 분석을 보완하면서 모델 정확도를 직접적으로 평가하지 않아도 됩니다.\n\n먼저 shap_values를 사용하여 모델의 모든 핵심 원인에 대한 전역 영향을 보여주는 막대 그래프를 생성합니다:\n\n```js\nmodel = sm.OLS(y, X[cols]).fit()\n# 모델의 p-값을 얻기 위해 모델 요약을 출력합니다\nexplainer = shap.Explainer(model.predict, X[cols])\n\n# SHAP 값을 계산합니다\nshap_values = explainer(X[cols])\nshap.plots.bar(shap_values)\n```\n\n<img src=\"/TIL/assets/img/2024-07-14-StockPriceAnalysisAComprehensiveDataScienceApproach_8.png\" />\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n과거 위험_수익 및 과거 수익과 상호 작용 항목이 중요하게 나타나는 것을 보여주며, 막대 플롯은 전체 효과를 시각화합니다.\n\n자세한 영향 분포를 보려면 bee swarm plot을 사용할 수 있습니다:\n\n```js\nshap.plots.beeswarm(shap_values)\n```\n\n<img src=\"/TIL/assets/img/2024-07-14-StockPriceAnalysisAComprehensiveDataScienceApproach_9.png\" />\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n상호 작용 변수 risk_past_interaction에는 값에 따라 다양한 기여도가 있음을 보여줍니다.\n\n'ORCL'과 같은 개별 주식에 중요한 주요 요인의 영향을 조사하려면 로컬 막대 플롯이 유용합니다:\n\n```js\nORCL_index = X[X['ticker'] == 'ORCL'].index\nORCL_shap_values = shap_values[ORCL_index[0]]\nshap.plots.bar(ORCL_shap_values)\n```\n\n<img src=\"/TIL/assets/img/2024-07-14-StockPriceAnalysisAComprehensiveDataScienceApproach_10.png\" />\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n클러스터 내 각 주식에 대한 주요 영향을 미치는 기능을 수집하는 것은 효과적인 거래 전략을 만드는 데 중요합니다. 아래는 이러한 주요 요인을 정확하게 파악하고 정리하기 위해 설계된 Python 코드입니다:\n\n```js\nimport pandas as pd\nimport numpy as np\n\n# 'tickers'를 'X'의 관측치와 맞춘다고 가정\ntickers = train_df_clus0['ticker'].values\n# 데이터를 수집하기 위한 딕셔너리 준비\ndata = {\n    'ticker': [],\n    'top_feature1': [], 'top_feature2': [], 'top_feature3': [],\n    'importance1': [], 'importance2': [], 'importance3': []}\n\n# 각 주식에 대해 상위 3개의 주요 영향 요소를 추출하기 위해 SHAP 값 순서대로 반복\nfor i, ticker in enumerate(tickers):\n    sorted_indices = np.argsort(-np.abs(shap_values.values[i]))[:3]\n    data['ticker'].append(ticker)\n    data['top_feature1'].append(cols[sorted_indices[0]])\n    data['top_feature2'].append(cols[sorted_indices[1]])\n    data['top_feature3'].append(cols[sorted_indices[2]])\n    data['importance1'].append(shap_values.values[i][sorted_indices[0]])\n    data['importance2'].append(shap_values.values[i][sorted_indices[1]])\n    data['importance3'].append(shap_values.values[i][sorted_indices[2]])\n\n# 수집한 데이터를 쉽게 분석하기 위해 DataFrame으로 변환\ndf_key_drivers = pd.DataFrame(data)\n```\n\n여기에는 각 주식의 상위 2개 기능 및 그 중요성을 보유한 결과 데이터 프레임이 있으며, 목표 주식 선택을 돕습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n주식 선정 최적화를 위한 응답 표면 방법론 (RSM)\n\n이 프로젝트는 RSM을 사용하여 주식 선택을 최적화하며, 과거 변동성과 성과 사이의 이차 관계를 활용하여 미래 수익을 예측합니다. 우리는 리스크_리턴(수익률 변동성)과 과거 수익을 포함하는 회귀 모델을 사용하여 재무 데이터의 비선형 경향과 변동성을 고려합니다.\n\n우리는 RSM을 적용하여 두 가지 주요 목표를 가지고 있습니다:\n\n- 과거 가격, 변동성 및 미래 수익 사이의 관계 모델링.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 예측된 미래 수익을 극대화하는 최적 조건을 찾기.\n\n다음은 응답 표면을 시각화하는 Python 코드입니다:\n\n```js\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\n\n# 모델 적합 및 응답 표면 데이터 생성\nX = sm.add_constant(train_df_clus0[['risk_return', 'past_return_2_squared', 'risk_past_interaction']])\nmodel = sm.OLS(y, X).fit()\nx_range = np.linspace(DF['past_return'].min(), DF['past_return'].max(), 100)\ny_range = np.linspace(DF['risk_return'].min(), DF['risk_return'].max(), 100)\nx_grid, y_grid = np.meshgrid(x_range, y_range)\nz_grid = model.params[0] + \\\n   model.params[1]*y_grid +  model.params[2]*x_grid**2 + \\\n   model.params[3]*x_grid*y_grid    \n\n# 응답 표면 플로팅\nfig = plt.figure()\nax = fig.add_subplot(111, projection='3d')\nax.plot_surface(x_grid, y_grid, z_grid, cmap='viridis')\nax.set_xlabel('x')\nax.set_ylabel('y')\nax.set_zlabel('z')\nplt.show()\n```\n\n![](/TIL/assets/img/2024-07-14-StockPriceAnalysisAComprehensiveDataScienceApproach_12.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n표면의 곡선은 이차 관계를 통합하는 모델의 용량을 확인합니다.\n\n최고 주식을 정확하게 찾기 위해 각 주식의 위치를 이상적인 지점과 비교하여, 거리 측정 기준에 따라 가장 가까운 다섯 개를 선택합니다:\n\n```js\n # 최적 지점까지의 거리 계산\nDF['distance'] = np.sqrt((DF['past_return'] - optimal_x)**2 + (DF['risk_return'] - optimal_y)**2)\n\n# 'distance' 열을 기준으로 DataFrame 정렬\nDF_sorted = DF.sort_values('distance')\n\n# 최적 지점에 가장 가까운 상위 10개의 주식 선택\ntop_10_stocks = DF_sorted.head(10)\n\nprint(\"최적 지점에 가장 가까운 상위 10개 주식:\")\nprint(top_10_stocks[['ticker', 'past_return', 'risk_return', 'distance']])\n```\n\n여기에 선택된 상위 10개 주식이 있습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 Markdown 형식으로 변경한 표입니다.\n\n\n![Stock Price Analysis](/TIL/assets/img/2024-07-14-StockPriceAnalysisAComprehensiveDataScienceApproach_13.png)\n\n우리는 최적 지점에 독점적으로 의존하지는 않지만, 그것은 이상적인 주식 조건에 대한 기준을 제공합니다. 이를 찾기 위해:\n\n```python\n# 미래 수익을 극대화하기 위한 최적 지점 찾기\noptimal_idx = np.argmax(z_grid)\noptimal_x = x_range[optimal_idx // 100]\noptimal_y = y_range[optimal_idx % 100]\noptimal_z = z_grid.flatten()[optimal_idx]\nprint(f\"최적 지점: 과거 수익 = {optimal_x}, 위험 수익 = {optimal_y}, 미래 수익 = {optimal_z}\")\n\n최적 지점: 과거 수익 = 0.544199942617375, 위험 수익 = 0.2085424594952841, 미래 수익 = 4.13061405635688\n```\n\nRSM을 활용하여 유망한 주식 선정을 신호하는 시장 조건을 전략적으로 식별할 수 있습니다.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n결론\n\n이 분석에서는 주식 가격 예측과 투자 전략 수립을 향상시키기 위해 데이터 과학 기술과 금융 통찰력을 결합했습니다. 추세 식별을 위한 데이터 평활화, 주식 분류를 통한 집중 조사, 예측 모델의 배치를 통해 주식 시장 흐름의 복잡성을 탐색했습니다.\n\n이 연구는 특정 시간대의 데이터를 기반으로 하고 있다는 점을 인지하는 것이 중요합니다. 시장 흐름(bull/bear phase), 이자율, 세계 경제 풍향, 산업 특정 트렌드를 포함한 다양한 변수에 민감한 금융 시장을 고려할 때, 우리 모델의 적용 가능성은 서로 다른 기간에 따라 다를 수 있습니다.\n\n이러한 한계에도 불구하고, 본 연구는 페어 트레이딩이나 예측 응답을 기반으로 한 선택적 주식 투자와 같은 실행 가능한 전략을 제시하여 전략적 사고를 강화하고자 합니다. 이러한 데이터 과학과 전통적인 금융 분석의 결합은 빠르고 예측할 수 없는 변화에 취약한 시장에서 투자자가 결정을 내리는 데 도움이 되는 도구를 제공하기 위한 것입니다.","ogImage":{"url":"/TIL/assets/img/2024-07-14-StockPriceAnalysisAComprehensiveDataScienceApproach_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-StockPriceAnalysisAComprehensiveDataScienceApproach_0.png","tag":["Tech"],"readingTime":28}],"page":"17","totalPageCount":50,"totalPageGroupCount":3,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}