{"pageProps":{"posts":[{"title":"TypeScript 제네릭 이해하기 쉽게 정리하기","description":"","date":"2024-07-07 21:53","slug":"2024-07-07-MakingsenseofTypeScriptgenerics","content":"\n<img src=\"/TIL/assets/img/2024-07-07-MakingsenseofTypeScriptgenerics_0.png\" />\n\nTypeScript는 JavaScript 개발을 혁신적으로 개선했습니다. 코드 신뢰성과 유지 보수성을 향상시키며 개발자들에게 더 적은 런타임 오류를 보장하고 생산성을 높여줍니다.\n\n하지만 TypeScript를 사용하기 시작하면 구문이 약간 압도적일 수 있습니다.\n\nTypeScript에서 가장 두려운 기능 중 하나는 \"제네릭\"입니다. 아래 예제를 보세요 🤯 두려워하지 않으시죠?\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/TIL/assets/img/2024-07-07-MakingsenseofTypeScriptgenerics_1.png\" />\n\n그러나 걱정하지 마세요. 단계별로 진행하겠습니다. 제네릭을 이해하면 얼마나 강력한지 알게 될 거예요.\n\n# 최적의 any 대안\n\n이 아주 간단한 JavaScript 함수를 상상해보세요. 이 함수는 배열의 첫 번째 요소를 반환합니다. (네, 제가 동의합니다. 이 함수는 그다지 유용하지 않지만 설명을 위해서입니다).\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/TIL/assets/img/2024-07-07-MakingsenseofTypeScriptgenerics_2.png\" />\n\n어떻게 타입을 지정할까요? 🤔 배열의 타입은 무엇이어야 할까요? 이 함수에서는 어떤 것이든 들어갈 수 있는 배열일 수 있습니다 (문자열, 숫자, 객체). 따라서 유혹받아 \"any\"라는 이름을 부를 수 없는 타입으로 지정하는 것이 유혹스러울 수 있습니다 😱\n\n<img src=\"/TIL/assets/img/2024-07-07-MakingsenseofTypeScriptgenerics_3.png\" />\n\n하지만 이는 매우 나쁜 타이핑입니다. 왜냐하면 TypeScript가 이 함수의 반환 타입을 올바르게 추론할 수 없기 때문입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/TIL/assets/img/2024-07-07-MakingsenseofTypeScriptgenerics_4.png)\n\n어쨌든, 우리가 가능한 모든 다른 유형들을 지정할 수 있을까요?\n\n![이미지](/TIL/assets/img/2024-07-07-MakingsenseofTypeScriptgenerics_5.png)\n\n좋은 생각이 아닙니다. 먼저, 이 함수에 대한 가능한 모든 유형의 큰 목록을 유지해야 한다는 점 때문입니다. 그리고 무엇보다 중요한 것은 이 추론 문제를 해결하지 못한다는 것입니다. TypeScript는 함수를 호출할 때 유형을 추측할 수 없을 만큼 똑똑하지 않습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그럼 TypeScript에서 as를 사용해 캐스팅하는 것을 도와줄 수 있을 것 같네요!\n\n![image](/TIL/assets/img/2024-07-07-MakingsenseofTypeScriptgenerics_6.png)\n\n하지만 그렇게 하는 건 이기적인 행동이에요! 이 타입 어설션으로 TypeScript에게 말하는 건, \"타입 검사를 멈추고 나를 믿어, 내가 뭐 하는 지 안다\"고 하는 거예요. 이렇게 하면 타입 안전성이 약화되고, TypeScript를 사용하는 핵심 목적이 퇴색됩니다.\n\n그렇게 하지 마세요! 이걸 타입하는 더 안전하고 깨끗한 방법이 있어요.\n이름이 뭐라고 생각하시나요? ✨ 제네릭스✨\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 제네릭 소개\n\n이전 예제를 계속해 봅시다.\n\n우리가 함수에 전달하고 싶은 내용은 \"파라미터로 '무엇인가'의 배열을 받고, '무엇인가' 요소를 반환할 것\"이라고 말하는 것입니다.\n\n그것이 바로 제네릭이란 것입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이렇게 보일 것입니다:\n\n<img src=\"/TIL/assets/img/2024-07-07-MakingsenseofTypeScriptgenerics_7.png\" />\n\n이 코드의 일부를 자세히 살펴보겠습니다:\n\n🟣 이전처럼 매개변수를 any[]로 입력하는 대신, 우리는 제네릭을 사용하여 매개변수를 정의합니다: 우리는 그것을 SomeType이라고 이름 짓겠습니다. 제네릭은 타입 자체가 아니라 타입 매개변수로, 함수가 호출될 때 지정될 타입을 나타내는 자리 표시자입니다. 당신은 원하는 대로 이름을 지을 수 있습니다(예약어나 이미 가져온 타입 이름이 아닌 경우). 우리는 종종 T와 같은 단일 문자를 제네릭으로 사용합니다. TypeScript에게 \"이 함수는 어떤 타입의 배열을 매개변수로 받을 것\"이라고 알립니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n🟢 이것은 함수의 반환 유형을 지정합니다. Typescript에게 \"함수가 매개 변수 배열의 요소와 동일한 유형의 요소를 반환할 것\"이라고 말하는 것입니다.\n\n🟡 함수 괄호 앞의 이 부분은 이 함수에서 사용할 일반적인 요소를 각괄호 안에 나열한 것입니다. 여기서는 하나의 일반적인 (SomeType)만 사용하게 될 것이지만, 나중에 여러 개의 일반적인을 사용할 수 있다는 것을 보여 드리겠습니다.\n\n우리가 일반적인을 사용하여 함수를 입력한 방식은 단지 \"매개 변수가 어떤 유형의 배열이며, 함수가 이와 동일한 유형으로 반환될 것\"이라는 뜻입니다.\n\n이 함수를 작성하는 더 일반적인 방법은 T를 사용하는 것입니다 (문법이 덜 복잡하게 보이도록).\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/TIL/assets/img/2024-07-07-MakingsenseofTypeScriptgenerics_8.png\" />\n\n이 소개가 제네릭의 본질을 이해하는 데 도움이 되기를 바랍니다.\n\n# 제네릭은 어디에나 있어요\n\n이미 TypeScript를 사용해 보셨다면, 모르는 사이에 제네릭을 사용해 본 적이 있을 겁니다. 예를 들어 DOM API의 querySelector 함수를 생각해 보세요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/TIL/assets/img/2024-07-07-MakingsenseofTypeScriptgenerics_9.png\" />\n\n이 예에서 querySelector는 반환된 요소가 HTMLElement 유형인지를 보장하기 위해 제네릭을 사용합니다. 이 유형 정보는 TypeScript가 반환된 요소에 대한 정확한 자동완성 및 유형 확인을 제공할 수 있도록 합니다. TypeScript에서 HTMLElement와 같은 네이티브 유형은 표준 라이브러리의 타입 선언인 lib.dom.d.ts에 의해 정의됩니다.\n\n제네릭을 사용하면 요소를 다음과 같이 처리할 수 있습니다:\n\n<img src=\"/TIL/assets/img/2024-07-07-MakingsenseofTypeScriptgenerics_10.png\" />\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이렇게 제네릭을 사용하지 않은 경우와의 차이는 다음과 같습니다:\n\n<img src=\"/TIL/assets/img/2024-07-07-MakingsenseofTypeScriptgenerics_11.png\" />\n\n제네릭 타입을 사용하지 않으면 TypeScript는 요소의 특정 타입을 알 수 없어서 도움이 되는 자동완성을 받을 수 없으며 오류가 발생할 수 있습니다 (캐스팅을 통해 수정 가능하지만 여전히 좋은 아이디어는 아닙니다).\n\n제네릭을 사용하면 TypeScript가 작업 중인 요소의 정확한 종류를 이해할 수 있기 때문에 더 나은 타입 안전성과 개발자 경험을 제공합니다. 따라서 제네릭이 네이티브 API 및 라이브러리에서 널리 사용되는 것은 놀라운 일이 아닙니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 제네릭을 더 깊게 파헤쳐보기\n\n제네릭은 단순한 함수에만 국한되지 않습니다. 더 유연하고 재사용 가능한 코드를 만들기 위해 다양한 방법으로 사용할 수 있습니다.\n\n심도 있는 예시를 살펴보겠습니다. 첫 번째 요소를 가져오는 것보다 실제 세계의 문제에 더 가까운 예제를 살펴보겠습니다. API 응답을 다루는 예시입니다.\n\n다음 코드를 살펴봅시다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/TIL/assets/img/2024-07-07-MakingsenseofTypeScriptgenerics_12.png)\n\nApiResponse 유형을 정의합니다. 이 유형은 항상 숫자 상태, 문자열 메시지 및 모든 유형의 데이터를 반환합니다.\n\n그러나 본문의 첫 부분에서 본 것처럼 any를 사용하는 것은 유형을 올바르게 추론하지 못하게 합니다.\n\n제네릭을 사용하여 그것을 개선해 봅시다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Image](/TIL/assets/img/2024-07-07-MakingsenseofTypeScriptgenerics_13.png)\n\n이 코드에 조금 더 가까이 들어가 봅시다.\n\n🟡 먼저, 여기서 새로운 구문을 볼 수 있습니다. 이것은 제네릭 형식입니다. 제네릭을 사용하는 유형을 정의하고 있습니다. 이전에 본 함수 예제와 비슷하게 작동합니다:\n\n- 꺽쇠 괄호 내에서 사용된 제네릭을 나열합니다.\n- 제네릭을 유형 정의 내에서 사용합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n🟣 이제는 이 타입을 사용할 때마다, T의 타입을 각괄호 안에 명확하게 지정해야 합니다. 이 fetch에 대한 API 응답 데이터가 ' name: string; age: number ' 타입임을 명시하고 있습니다. 이것은 타입 인자입니다.\n\n그리고 이제, fetchData 함수가 잘 타입화되었으므로 TypeScript가 해당 반환 타입을 올바르게 추론할 수 있습니다.\n\n# 일반화 제한하기\n\n가끔, 제네릭이 모든 타입을 허용하지 않고 더 많은 제약이 있는 상태로 제한하고 싶은 경우가 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAPI 응답의 예제를 계속 사용하면 데이터가 항상 객체여야하고 그 외의 것들이 들어가지 않아야 합니다.\n\n`extends` 키워드를 사용하여 가능합니다.\n\n![image](/TIL/assets/img/2024-07-07-MakingsenseofTypeScriptgenerics_14.png)\n\n만약 객체가 아닌 다른 것으로 함수를 호출하려고 하면 TypeScript에서 오류가 발생합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n특정 속성을 갖는 객체를 제약하는 방법도 있습니다. 예를 들어 API 데이터가 항상 id를 포함하는 객체여야 하는 경우:\n\n![이미지](/TIL/assets/img/2024-07-07-MakingsenseofTypeScriptgenerics_15.png)\n\n# 제네릭을 위한 기본 타입\n\n제네릭의 또 다른 멋진 기능은 기본 타입을 제공할 수 있다는 것입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지금까지 본 모든 예제에서 우리는 제네릭 타입을 사용할 때 type 인자를 명확히 지정해야 했습니다. 예를 들어: ApiResponse`' name: string; age: number '`.\n\n그러나 만약 당신이 자주 동일한 타입을 제네릭에 사용한다면, 타입 정의에서 =로 기본값을 지정할 수 있습니다.\n\n![image](/TIL/assets/img/2024-07-07-MakingsenseofTypeScriptgenerics_16.png)\n\n심지어 제약 조건과 함께 사용할 수도 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/TIL/assets/img/2024-07-07-MakingsenseofTypeScriptgenerics_17.png\" />\n\n# 여러 제네릭\n\n가끔은 한 가지 제네릭만으로는 부족하고 2개 이상이 필요할 때가 있습니다.\n\n꺽쇠 괄호 안에 제네릭을 콤마로 구분하여 나열하면 됩니다. 함수를 호출할 때도 타입 인자를 동일하게 나열해 주세요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n한 예시를 살펴보겠습니다:\n\n![generics](/TIL/assets/img/2024-07-07-MakingsenseofTypeScriptgenerics_18.png)\n\n제네릭은 처음에는 무서울 수 있지만, 이들이 어떻게 작동하는지 이해하면 그들의 힘을 빨리 깨닫고 TypeScript 생태계의 중심에 왜 있는지 이해하게 됩니다.\n\n함수와 컴포넌트가 다양한 유형으로 작동할 수 있도록 허용하면서도 강한 유형 안전성을 유지함으로써, TypeScript 제네릭은 견고하고 유지 관리가 용이한 코드를 작성하는 능력을 크게 향상시키며 개발자 경험을 놀라운 것으로 만들어 줍니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n행복한 코딩하세요!\n","ogImage":{"url":"/assets/img/2024-07-07-MakingsenseofTypeScriptgenerics_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-MakingsenseofTypeScriptgenerics_0.png","tag":["Tech"],"readingTime":12},{"title":"Angular의 inject 함수 사용으로 1000줄의 코드를 절약한 방법","description":"","date":"2024-07-07 21:51","slug":"2024-07-07-HowUsingAngularsinjectFunctionHasSavedMe1000LinesofCode","content":"\n# inject() 함수란 무엇인가요?\n\nAngular 14에서 소개된 inject() 함수는 서비스, 컴포넌트, 디렉티브 등에 종속성을 주입하는 데 사용됩니다. 클래스 생성자를 사용하여 종속성을 주입하는 대신 inject() 함수를 사용할 수 있습니다.\n\n![이미지](/TIL/assets/img/2024-07-07-HowUsingAngularsinjectFunctionHasSavedMe1000LinesofCode_0.png)\n\n## 생성자를 사용하여 종속성을 주입하는 예전 방식:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport { Component } from '@angular/core';\n\n@Component({ /* ... */ })\nexport class MyComponent {\n  constructor(\n    @Inject(SOME_TOKEN) private readonly someToken: string,\n    private readonly myService: MyService,\n    private readonly httpClient: HttpClient,\n  ) {}\n}\n```\n\n## inject() 함수를 사용한 의존성 주입의 새로운 방법:\n\n```js\nimport { Component, inject } from '@angular/core';\n\n@Component({ /* ... */ })\nexport class MyComponent {\n  private readonly someToken = inject(SOME_TOKEN);\n  private readonly myService = inject(MyService);\n  private readonly httpClient = inject(HttpClient);\n}\n```\n\n# inject() 사용의 장점 vs 생성자 사용하기\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n주목하신 대로, 생성자 대신 inject()을 사용하는 것에는 여러 가지 장점이 있습니다:\n\n- 코드를 더 깔끔하고 가독성이 좋고 일관성 있게 만듭니다 (토큰 vs 서비스 주입 시에도)\n- 타입이 자동으로 추론되어 수동으로 지정할 필요가 없습니다\n- 상속이 간편하고 덜 장황합니다 (자세한 내용은 아래에서 설명)\n\n# 더 나은 상속\n\n저는 상속과 관련된 경우 inject() 함수가 특히 유용하다고 생각합니다. 코드를 재사용하고 여러 자식 클래스에 의해 확장될 부모 서비스 추상 클래스가 있는 시나리오를 고려해 보세요:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nexport abstract class ParentService {\n  constructor(\n    protected readonly configKey: string,\n    protected readonly httpClient: HttpClient,\n    protected readonly helperService: HelperService,\n  ) {}\n\n  // ... some code here that will be reused in the children of ParentService\n}\n```\n\nParentService의 하위 클래스는 다음과 같이 확장됩니다:\n\n```js\n@Injectable({ providedIn: 'root' })\nexport class ChildService extends ParentService {\n  constructor(\n    protected readonly httpClient: HttpClient,\n    protected readonly helperService: HelperService,\n  ) {\n    super('my-config-key', httpClient, helperService);\n  }\n\n  // ... some child-specific code here\n}\n```\n\n보시다시피 많은 반복이 있습니다: 모든 자식 클래스들은 HttpClient와 HelperService를 가져와야 하는데 이는 ParentService의 생성자가 필요하기 때문입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\ninject() 함수 덕분에 이 불필요한 반복을 피할 수 있어요:\n\n```js\nexport abstract class ParentService {\n  protected abstract readonly configKey: string; // \"abstract\"을 사용하여 자식 클래스가 이 필드를 초기화하도록 강제합니다\n  protected readonly httpClient = inject(HttpClient);\n  protected readonly helperService = inject(HelperService);\n\n  // ... 부모 서비스의 자식에서 재사용될 코드가 있습니다 ...\n}\n\n@Injectable({ providedIn: 'root' })\nexport class ChildService extends ParentService {\n  protected readonly configKey = 'my-config-key';\n\n  // ... 자식에만 해당하는 코드가 있습니다\n}\n```\n\n결과적으로 코드가 훨씬 깔끔해지고 반복을 피할 수 있습니다: ParentService의 자식들은 HttpClient 및 HelperService를 가져와 부모에게 전달할 필요가 없지만, 필요한 경우에 this.httpClient 및 this.helperService에 액세스 할 수 있습니다.\n\n의존성이 많고 많은 자식이 기본 클래스를 확장하는 시나리오를 상상해보세요, inject()를 사용하면 많은 코드 라인을 절약할 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 실제 사용 사례 예\n\n2019년에 Angular을 사용하여 구축한 오래된 프로젝트를 리팩토링할 때 inject() 함수를 사용했습니다. 생성자를 없애거나 사용을 줄이는 것만으로 약 1000줄 이상의 코드를 제거할 수 있었습니다. 변경 내용은 이 커밋에서 확인할 수 있습니다.\n\n네, 무엇을 생각하고 계시는지 알겠어요. 상속 대신 구성을 고려해볼 수 있었다는 주장을 할 수 있겠지만, 이에 대한 논의는 이 글의 범위를 벗어납니다.\n\n# 결론\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- inject() 함수는 일반적으로 생성자를 사용하는 것보다 선호되는 의존성을 효율적이고 현대적인 방법으로 주입해주는 기능을 제공합니다.\n- inject()를 사용하도록 코드베이스를 마이그레이션하는 것이 쉽고, 특히 상속을 다루어야 할 때 유용할 것입니다.\n- 기존 레거시 프로젝트에서도 gradually(점진적으로) inject()를 채택할 수 있으며, 코드베이스를 한꺼번에 마이그레이션할 필요가 없습니다.\n","ogImage":{"url":"/assets/img/2024-07-07-HowUsingAngularsinjectFunctionHasSavedMe1000LinesofCode_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-HowUsingAngularsinjectFunctionHasSavedMe1000LinesofCode_0.png","tag":["Tech"],"readingTime":5},{"title":"서버리스 인증 자가 서비스 플랫폼 구축 방법","description":"","date":"2024-07-07 21:49","slug":"2024-07-07-ServerlessAuthSelf-ServePlatform","content":"\n<img src=\"/TIL/assets/img/2024-07-07-ServerlessAuthSelf-ServePlatform_0.png\" />\n\n## 서문\n\n🌟 Amazon Cognito 머신 간 인증 흐름이 무엇인지 다루고 있습니다.\n🌟 중앙 집중식 인증 플랫폼의 필요성을 살펴봅니다.\n🌟 기본 예제 프론트엔드 UI를 통해 진행합니다.\n🌟 전체적인 AWS 아키텍처에 대해 이야기합니다.\n🌟 TypeScript와 AWS CDK 코드를 통해 진행 과정을 설명합니다.\n\n# 소개 👋🏽\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n조직 내에서는 많은 다른 팀이 보안적으로 외부 시스템 및 제3자 API에 로드되어야 하는 경우가 거의 항상 발생합니다. 일반적으로 각 팀이 자체 인증 서버를 생성해야 하고 OAuth 2.0 클라이언트 자격 증명 흐름이 어떻게 작동하는지 파악해야 하는 작업이 진행됩니다.\n\n본 문서에서는 우리가 어떻게 중앙 회사 인증 서비스를 생성할 수 있는지에 대해 다룰 것입니다. Amazon Cognito를 기반으로 개발자가 스스로 서비스를 이용할 수 있는 포털을 가지고 있는 이 서비스를 통해 회사 내의 모든 팀이 자신들의 서드파티 소비자를 위한 액세스 토큰 구성을 빠르게 만들 수 있습니다.\n\n컨텐츠를 이해하기 쉽게 하기 위해, TypeScript 및 AWS CDK를 사용하여 가상의 'LJ Health Food' 회사의 완벽한 솔루션 코드 예제를 생성할 것입니다. 이 회사는 건강식품 배달 회사이지만 Uber Eats나 Just Eat과 같은 서드파티 통합을 통해 주문을 받을 수도 있습니다.\n\n![이미지](/TIL/assets/img/2024-07-07-ServerlessAuthSelf-ServePlatform_1.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기에서 완전한 솔루션 코드 예제를 찾을 수 있습니다:\n\n이 예제에서는 3rd party 서비스가 자사의 앱을 통해 주문을 배치하는 내용에 대해 리더십팀과 회의를 가졌습니다. 그들은 동의하고, 엔지니어링 팀은 통합 과정을 시작합니다.\n\n![image](/TIL/assets/img/2024-07-07-ServerlessAuthSelf-ServePlatform_2.png)\n\n이를 위해 우리는 그들을 신뢰할 수 있는 클라이언트로 설정하고, 다른 서비스가 주문을 배치할 수 있는 부분에만 액세스할 수 있도록 권한을 부여해야 합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Image](/TIL/assets/img/2024-07-07-ServerlessAuthSelf-ServePlatform_3.png)\n\n이 특정 인가 플로우를 통해 이 신뢰가 어떤 모습인지 살펴보겠습니다.\n\n👇 더 나아가기 전에 — 향후 블로그 포스트와 서버리스 뉴스에 대해 연결하려면 LinkedIn에서 저와 연락해주세요. https://www.linkedin.com/in/lee-james-gilmore/\n\n![Image](/TIL/assets/img/2024-07-07-ServerlessAuthSelf-ServePlatform_4.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 중앙 집중식 인증이 필요한 이유 🛡️\n\n더 진행하기 전에, 회사 내에서 자체 서비스 스타일 포털을 통해 인증을 중앙 집중화해야 하는 이유는 무엇일까요? 그렇지 않으면 일반적으로 다음과 같은 문제가 발생합니다:\n\n- 각 프로젝트/서비스에 대한 액세스 토큰을 위한 인증 서버를 설정해야 하는 팀들에게 높은 인지 부하가 발생합니다.\n- OAuth 2.0 클라이언트 인증 흐름이 어떻게 작동하는지 이해해야 하는 데 높은 인지 부하가 발생합니다 (이에 대해 나중에 더 다룰 것입니다).\n- Amazon Cognito의 UI는 매우 복잡하며 필요하지 않은 많은 기능이 포함되어 있습니다. 우리는 자체 UI에서 이것을 제거함으로써 이런 소음을 최소화할 수 있습니다 (필요한 기능만 표시).\n- 보안 팀이 처리해야 하는 포인트가 더 많아집니다.\n\n<img src=\"/TIL/assets/img/2024-07-07-ServerlessAuthSelf-ServePlatform_5.png\" />\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\"중앙 집중형 권한 부여가 우리에게 어떤 이점을 제공할까요?\n\n✔️ 셀프 서비스 포털에서 새로운 3rd 파티 클라이언트 및 서비스를 신속하게 추가할 수 있어요.\n\n✔️ 모든 클라이언트 및 토큰을 관리하는 팀이 한 팀에만 의지하지 않아도 되어 조직 내 병목 현상을 피할 수 있어요 (Team Topologies를 생각해보세요) - 이렇게 하면 팀원들이 AD를 통해 로그인하고 자체 구성을 관리할 수 있어요.\n\n✔️ 보안 팀은 한 솔루션의 디자인을 확인하고 팀과 함께 쉽게 모니터링할 수 있어요.\"\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n✔️ Auth0, Tyk 등의 서비스를 사용할 수도 있겠지만, Amazon Cognito보다 훨씬 비싸기 때문에 typ씨피 방법을 사용할 수 없습니다. 또한 일반적으로 제공하는 모든 기능이 필요하지 않을 수 있습니다. Amazon Cognito를 프록시하면 UI를 우리의 요구에 맞게 조정할 수 있기 때문에 구현을 자체적으로 사용 사례에 맞게 할 수도 있습니다.\n\n## 클라이언트 자격 증명 흐름이란? 🔐\n\n이제 중앙 인증 플랫폼의 필요성에 대해 논의했으니, 여태까지 여러 번 언급한 OAuth 2.0 클라이언트 자격 증명 흐름이 무엇인지 알아보겠습니다.\n\n간단한 용어 해설을 통해 이야기를 나눠보죠:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 클라이언트 — 클라이언트(클라이언트 웹 애플리케이션과 혼동되지 않도록 주의)는 API(리소스 서버)에서 리소스에 액세스하려는 백엔드 서비스, 데몬 또는 기기입니다.\n- 리소스 서버 — 리소스 서버는 하나 이상의 클라이언트가 인증된 요청을 보내려고 하는 API입니다. 리소스 서버는 클라이언트로부터 받은 엑세스 토큰을 발급한 클라이언트에게 토큰을 부여한 인가 서비스와 대조합니다.\n- 인가 서비스 — 인가 서비스는 클라이언트가 특정 리소스 서버를 위해 엑세스 토큰을 생성하는 방법으로, 토큰에는 범위가 포함될 수 있습니다.\n- 범위 — 범위는 클라이언트가 인가 서비스로부터 받은 엑세스 토큰에 청구하는 것으로, 리소스 서버에서 클라이언트에 노출되는 기능을 상세히 기술합니다.\n\n거의 모든 경우에 우리는 REST API를 사용하여 서로 동기적으로 통신하는 하나 이상의 서비스가 필요하며, 이러한 서비스들은 일반적으로 백엔드 서비스이므로 '사용자'가 아닌 '기기'로 인증해야 합니다.\n\n이 요구 사항이 있을 때, 우리는 \"m2m\" 플로우를 실행하여 산업 표준 OAuth 2.0 인증 플로우인 \"클라이언트 자격 증명 플로우\"를 수행합니다. 아래에 표시된 것과 같습니다:\n\n위 다이어그램에서 보듯이:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 3rd party 서비스는 주문을 배치하기 위해 저희의 리소스 서버(API)를 호출하기 위해 특히 인증 서버에서 액세스 토큰을 요청합니다.\n- 클라이언트 자격 증명(즉, 클라이언트 ID 및 클라이언트 비밀번호)가 올바른 경우, 인증 서버는 새로운 유효한 액세스 토큰을 반환합니다.\n- 3rd Party 서비스는 이제 요청 헤더의 'Authorization'에 액세스 토큰을 사용하여 리소스 서버 API를 호출합니다.\n- 리소스 서버는 이제 액세스 토큰을 인증 서버에 대조하여 a.) 유효한 토큰이고 b.) 호출 중인 API의 엔드포인트에 대한 올바른 스코프를 갖고 있는지 확인합니다.\n- 리소스 서버 API의 응답은 클라이언트에게 다시 전송됩니다.\n\n지금 우리가 높은 수준에서 이에 대해 이야기했으니, 우리의 자체 서비스 포털이 어떻게 생겼는지 살펴봅시다. 이를 통해 3rd Party 모바일 앱이 우리 주문 서비스를 이용하여 주문을 배치할 수 있도록 관리 세부 정보를 관리할 수 있는 것입니다.\n\n![이미지](/TIL/assets/img/2024-07-07-ServerlessAuthSelf-ServePlatform_6.png)\n\n# 저희 클라이언트 앱은 어떻게 생겼나요? 🎨\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 이 기사의 POC 스타일 구현에서 중앙 인증 플랫폼 응용 프로그램의 모습을 살펴봅시다.\n\n다만, 이것이 POC로서 제작 준비가 된 것이 아니라는 것을 명심해주세요!\n\n우리는 기존의 리소스 서버 및 클라이언트를 나열하는 메인 페이지에서 시작합니다.\n\n'새 리소스 서버 만들기' 버튼을 클릭하여 새 리소스 서버를 추가할 필요한 세부 정보를 추가하는 모달이 표시됩니다. 예를 들어, 우리의 리소스 서버에는 '주문하기' 및 '주문 목록'이라는 두 가지 스코프가 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n자원 서버를 설정했으니 이제 '새 클라이언트 생성' 버튼을 클릭할 수 있어요. 이 버튼을 클릭하면 아래에 표시된 것처럼 관련 클라이언트 세부 정보를 추가할 수 있는 모달이 나타나요. 이 예제에서는 클라이언트 이름과 스코프를 설정하고, 리소스 서버에서 새로운 주문을 할 수 있는 'lj-health-food/place-order'로 지정했어요. 이 예제에서 주문 목록을 나열할 수는 없도록 했어요.\n\n새 클라이언트를 만든 후 관련 세부 정보를 보여주려면 목록에서 새로 만든 클라이언트의 '보기' 버튼을 클릭하세요.\n\n자체 서비스 사용 인증 서비스가 필요한 이유, 클라이언트 자격 증명 흐름이 무엇인지, 그리고 자체 서비스 사용 플랫폼 프론트엔드가 어떻게 생겼는지에 대해 설명했으니 이제 전체 아키텍처에 대해 이야기해보겠어요.\n\n# 무엇을 만들고 있나요? 🛠️\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위에서 다룬 내용을 고려하면, 우리는 내부 플랫폼의 얇은 슬라이스를 구축할 것입니다. 이 플랫폼은 우리의 제3자 서비스를 인증하면서 팀이 쉽고 빠르게 새 고객(클라이언트)을 온보딩하고 사용 가능한 스코프를 설정하고 새로운 리소스 서버를 설정할 수 있게 합니다. 본질적으로, 세 가지 마이크로서비스가 있습니다.\n\n위 다이어그램에서 볼 수 있는 것은 다음과 같습니다:\n\n- 내부 팀은 Entra ID(Active Directory)를 통해 UI에 로그인하여 AD 그룹을 통해 포털에 액세스할 수 있는 특정 직원만 접근할 수 있습니다.\n- 내부 UI는 API 게이트웨이를 BFF(Backend-for-Frontend)로 호출하며, 이는 다양한 람다 함수를 사용하여 Amazon Cognito와 상호 작용하여 클라이언트, 리소스 서버 및 스코프를 설정합니다.\n- 모든 BFF 구성은 Amazon DynamoDB에 저장됩니다. 다만 이것은 매우 간단한 예제에서는 설정하지 않습니다.\n- Cognito 사용자 풀에 설정된 제3자 서비스는 머신 투 머신 토큰(client-credentials flow)을 생성하여 리소스 서버를 위해 생성된 액세스 토큰을 'Authorization' 헤더에 넣어 API 게이트웨이를 호출합니다.\n- 리소스 서버는 API 게이트웨이에 연결된 람다 인증기(라우터)를 사용하여 Cognito 사용자 풀에서 토큰을 유효성 검사하고 요청을 처리합니다.\n\n이제 주요 코드에 대해 이야기해 보겠습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 주요 코드로 이야기 나누기 👨‍💻\n\n저희의 GitHub 프로젝트는 세 가지 주요 솔루션으로 나누어져 있습니다:\n\n- 'shared-central-auth' 폴더에 중앙 Auth 서비스 및 UI가 있습니다.\n- 'resource-server-service' 폴더에는 리소스 서버가 있습니다.\n- 'client-service' 폴더에는 클라이언트 (3rd Party 서비스)가 있습니다.\n\n자, 각각의 중요 코드를 살펴보겠습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## ✔️ 공유된 중앙 인증\n\n먼저 CDK 앱에서 '무상태(Stateless)' 스택을 만들어서 Amazon Cognito 사용자 풀을 생성합니다:\n\n```js\nimport * as cdk from 'aws-cdk-lib';\nimport * as cognito from 'aws-cdk-lib/aws-cognito';\n\nimport { Construct } from 'constructs';\n\nexport class SharedCentralAuthStatefulStack extends cdk.Stack {\n  constructor(scope: Construct, id: string, props?: cdk.StackProps) {\n    super(scope, id, props);\n\n    // 클라이언트 자격 증명 플로우(m2m auth)를 위해 공유 Cognito 사용자 풀 생성\n    const authUserPool: cognito.UserPool = new cognito.UserPool(\n      this,\n      'SharedAuthUserPool',\n      {\n        userPoolName: 'SharedAuthUserPool',\n        removalPolicy: cdk.RemovalPolicy.DESTROY,\n      }\n    );\n\n    // Cognito에서 사용자 풀 도메인 생성\n    // (외부 서비스가 토큰을 요청할 수 있게 해줍니다)\n    const authUserPoolDomain: cognito.UserPoolDomain =\n      new cognito.UserPoolDomain(this, 'SharedAuthUserPoolDomain', {\n        userPool: authUserPool,\n        cognitoDomain: {\n          domainPrefix: 'lj-health-food-auth',\n        },\n      });\n\n    ...\n  }\n}\n```\n\n다음으로 사용자 풀과 상호 작용할 UI에 사용될 Amazon API Gateway를 생성합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```typescript\n// 우리의 경험 레이어 API를 생성합니다.\nconst api: apigw.RestApi = new apigw.RestApi(this, \"CentralAuthApi\", {\n  description: \"LJ Food Delivery - Central Auth Service\",\n  deploy: true,\n  defaultCorsPreflightOptions: {\n    allowOrigins: apigw.Cors.ALL_ORIGINS,\n  },\n  deployOptions: {\n    stageName: \"prod\",\n    loggingLevel: apigw.MethodLoggingLevel.INFO,\n  },\n});\n```\n\n이어서 ‘clients’와 ‘resource-servers’에 대한 리소스를 추가합니다.\n\n```typescript\n// API에서 리소스를 만듭니다.\nconst resourceServers: apigw.Resource = api.root.addResource(\"resource-servers\");\nconst clients: apigw.Resource = api.root.addResource(\"clients\");\nconst client: apigw.Resource = clients.addResource(\"{id}\");\nconst resourceServer: apigw.Resource = resourceServers.addResource(\"{id}\");\n```\n\n여러 Lambda 함수가 있으며 이 함수들은 클라이언트 목록 표시, 리소스 서버 생성, 클라이언트 삭제 등과 같은 기능을 위해 API Gateway 엔드포인트와 통합됩니다. 한 예시 함수를 살펴보겠습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n// 새로운 리소스 서버를 추가하는 람다 함수를 생성합니다\nconst createResourceServer: nodeLambda.NodejsFunction = new nodeLambda.NodejsFunction(this, \"CreateResourceServer\", {\n  functionName: \"create-resource-server\",\n  runtime: lambda.Runtime.NODEJS_20_X,\n  entry: path.join(__dirname, \"src/adapters/primary/create-resource-server/create-resource-server.adapter.ts\"),\n  memorySize: 1024,\n  handler: \"handler\",\n  tracing: Tracing.ACTIVE,\n  bundling: {\n    minify: true,\n  },\n  environment: {\n    ...lambdaPowerToolsConfig,\n    USER_POOL_ID: userPoolId,\n  },\n});\n```\n\nLambda 함수들은 우리의 Cognito 사용자 풀을 관리하기 위해 AWS SDK v3를 활용하므로, 각각에 필요한 관련 권한을 부여해야 합니다. 위의 'CreateResourceServer' 람다 함수의 경우, 아래와 같이 할 수 있습니다:\n\n```js\n// 람다 함수에 사용자 풀 액세스 권한 부여\ncreateResourceServer.addToRolePolicy(\n  new iam.PolicyStatement({\n    actions: [\"cognito-idp:CreateResourceServer\"],\n    resources: [userPool.userPoolArn],\n  })\n);\n```\n\n그런 다음 Lambda 함수 핸들러 유즈케이스(비즈니스 로직)는 Amazon Cognito와 통신하기 위해 보조 어댑터를 활용하며, 아래는 AWS SDK를 사용하여 리소스 서버를 생성하는 예시입니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nexport async function createCognitoResourceServer(\n  resourceServerName: string,\n  identifier: string,\n  scopes: ResourceServerScopeType[]\n): Promise<ResourceServerType> {\n  const params: CreateResourceServerCommandInput = {\n    UserPoolId: userPoolId,\n    Identifier: identifier,\n    Name: resourceServerName,\n    Scopes: scopes,\n  };\n\n  try {\n    const command = new CreateResourceServerCommand(params);\n    const response: CreateResourceServerCommandOutput = await client.send(command);\n\n    logger.info(\"resource server created: \", JSON.stringify(response.ResourceServer));\n    const resourceServer = response.ResourceServer;\n\n    if (!resourceServer) {\n      throw new Error(\"resource server could not be created\");\n    }\n\n    logger.info(\"resource server details: \", JSON.stringify(resourceServer));\n    return resourceServer;\n  } catch (error) {\n    logger.error(\"error creating resource server: \", JSON.stringify(error));\n    throw error;\n  }\n}\n```\n\n이 시점에서 Amazon API Gateway가 여러 람다 함수를 대리하며 AWS SDK v3를 사용하여 사용자 풀에서 클라이언트 및 리소스 서버를 관리하는 기능을 제공합니다. 이 기능을 UI를 통해 사용할 수 있습니다!\n\n## ✔️ 리소스 서버\n\n이 시점에서 UI로 이동하여 클라이언트가 사용할 주문 API를 위한 리소스 서버를 생성할 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마이크로서비스의 실제 Amazon API Gateway, Lambda 함수 및 DynamoDB 테이블에 대해서는 여기서 다루지 않겠습니다. 이 내용은 매우 기본적이며, 위의 대부분의 코드 예제를 다루었습니다. 그러나 우리가 여기서 다룰 것은 API Gateway에서의 Lambda Authorizer와 Lambda 핸들러의 내용입니다.\n\n위의 코드를 보면, 우리는 액세스 토큰을 확인하는 데 사용될 RequestAuthorizer를 만드는 것을 볼 수 있습니다. 이 토큰은 모든 클라이언트의 Authorization 헤더에 포함되어 있습니다. 그 다음, 아래에 표시된대로 이를 API Gateway에 추가합니다:\n\n```js\n// ensure that our lambda function is invoked through the api\n// and we have a request based lambda authorizer to validate the token\norders.addMethod(\n  \"POST\",\n  new apigw.LambdaIntegration(createOrder, {\n    proxy: true,\n  }),\n  {\n    authorizer: authoriser, // add our lambda authoriser\n    authorizationType: apigw.AuthorizationType.CUSTOM,\n  }\n);\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAPI 엔드포인트가 호출될 때마다 먼저 Lambda Authorizer를 호출하여 액세스 토큰을 유효성 검사합니다.\n\n그런 다음 아래의 Lambda 핸들러 내용을 확인할 수 있습니다. 여기에서는 Authorization 헤더의 액세스 토큰을 유효성 검사합니다:\n\n```js\nimport { APIGatewayAuthorizerResult } from \"aws-lambda/trigger/api-gateway-authorizer\";\nimport { CognitoJwtVerifier } from \"aws-jwt-verify\";\nimport { PolicyDocument } from \"aws-lambda\";\nimport { config } from \"@config\";\nimport { logger } from \"@shared\";\n\nconst cognitoJwtVerifier = CognitoJwtVerifier.create({\n  userPoolId: config.get(\"userPoolId\"),\n  clientId: [config.get(\"clientId\")], // 유효한 클라이언트 ID 배열\n  scope: [config.get(\"scopes\")], // 허용된 스코프\n  tokenUse: \"access\",\n});\n\nexport const handler = async function (event: any): Promise<APIGatewayAuthorizerResult> {\n  try {\n    // 클라이언트가 클라이언트 ID와 클라이언트 시크릿(스코프로)를 사용하여 받은\n    // 인증 토큰을 요청에서 가져옵니다. 이를 로그에만 표시합니다.\n    const authToken = event.headers[\"Authorization\"] || \"\";\n\n    logger.info(`Auth token: ${authToken}`);\n\n    // 토큰 검증\n    const decodedJWT = await cognitoJwtVerifier.verify(authToken);\n\n    // methodArn에 대한 허용 정책 생성\n    const policyDocument: PolicyDocument = {\n      Version: \"2012-10-17\",\n      Statement: [\n        {\n          Action: \"execute-api:Invoke\",\n          Effect: \"Allow\",\n          Resource: event[\"methodArn\"],\n        },\n      ],\n    };\n\n    // 컨텍스트에 클라이언트 ID를 전달합니다\n    const context = {\n      clientId: decodedJWT.sub,\n    };\n\n    const response: APIGatewayAuthorizerResult = {\n      principalId: decodedJWT.sub,\n      policyDocument,\n      context,\n    };\n\n    return response;\n  } catch (err) {\n    console.error(\"invalid auth token: \", err);\n    throw new Error(\"unauthorized\");\n  }\n};\n```\n\n위 코드에서 유효성 확인이 이루어지는 것을 확인할 수 있습니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 액세스 토큰의 만료 기간이 지나지 않았습니다.\n- 알려진 클라이언트 중 하나를 위해 생성되었습니다.\n- 예상대로 올바른 범위를 포함하고 있습니다.\n- 액세스 토큰은 우리의 Cognito UserPool에서 서명되었습니다.\n\n모든 작업은 `aws-jwt-verify` 패키지를 사용하여 수행되었습니다.\n\n## ✔️ 클라이언트 서비스\n\n그래서 이제 우리에게는 새로운 주문을 생성하는 리소스 서버 서비스가 있고, 중앙 인증 플랫폼에서 이를 위한 모든 구성 설정이 완료되었습니다. 이제 리소스 서버 API를 사용할 3rd party 서비스인 클라이언트를 생성해야 합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n새 주문을 만드는 비즈니스 로직인 사용 사례를 살펴보겠습니다. 아래에 표시된 대로, 우리의 서드파티 서비스에서 새 주문을 만드는 방법을 살펴보겠습니다.\n\n```js\nimport { CreateOrder, Order } from \"@dto/order\";\nimport { logger, schemaValidator } from \"@shared\";\n\nimport { createOrder } from \"@adapters/secondary/https-adapter\";\nimport { saveOrder } from \"@adapters/secondary/database-adapter\";\nimport { schema } from \"@schemas/order\";\n\nexport async function createOrderUseCase(order: CreateOrder): Promise<Order> {\n  logger.info(`주문이 접수되었습니다: ${JSON.stringify(order)}`);\n\n  // 인증 토큰과 함께 다른 서비스를 호출하여 주문을 생성합니다.\n  const createdOrder = await createOrder(order);\n\n  // 생성된 주문의 응답이 올바른 형태인지 확인합니다.\n  schemaValidator(schema, createdOrder);\n\n  // 주문 서비스로부터 반환된 주문을 DynamoDB에 저장합니다.\n  await saveOrder(createdOrder);\n\n  logger.info(`주문이 id와 함께 완료되었습니다: ${JSON.stringify(createdOrder.id)}`);\n\n  return createdOrder;\n}\n```\n\n우리는 보조 어댑터를 통해 주문을 생성하고, 이를 페이로드와 유효한 액세스 토큰을 사용해 리소스 서버 API를 호출합니다. 그리고 리턴된 주문 세부 정보를 우리 자체 DynamoDB 테이블에 저장합니다.\n\nHTTP 핸들러는 액세스 토큰을 생성하고 주문 요청을 리소스 서버 API로 보내는 데 관여합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport { CreateOrder, Order } from \"@dto/order\";\nimport { generateAccessToken, logger } from \"@shared\";\n\nimport axios from \"axios\";\nimport { config } from \"@config\";\nimport { decode } from \"jsonwebtoken\";\n\nexport async function createOrder(order: CreateOrder): Promise<Order> {\n  // 설정 가능한 세부 정보를 구성에서 가져옵니다\n  const clientId = config.get(\"clientId\");\n  const clientSecret = config.get(\"clientSecret\");\n  const url = config.get(\"authUrl\");\n  const resourceServerUrl = config.get(\"resourceServerUrl\");\n\n  // 주문 서비스를 이용하여 주문을 작성하기 위한 스코프\n  const scopes: string[] = [\"lj-health-food/place-order\"];\n\n  // 주문 서비스를 위한 액세스 토큰 생성\n  // 클라이언트 자격 증명으로 중앙 인증 서비스를 호출하여\n  const accessToken = await generateAccessToken(clientId, clientSecret, url, scopes);\n\n  // 참고: 접근 토큰은 절대로 로깅해서는 안 됩니다\n  // 그러나 이 예제에서는 디코딩된 내용을 살펴보겠습니다\n  const decoded = decode(accessToken, { complete: true });\n  logger.info(`디코딩된 토큰 : ${JSON.stringify(decoded)}`);\n\n  // 주문을 생성하기 위해 주문 API(리소스 서버)에 요청 보냄\n  // 헤더에 액세스 토큰을 전달합니다\n  const { data }: { data: Order } = await axios.request({\n    url: \"orders\",\n    method: \"post\",\n    baseURL: resourceServerUrl,\n    headers: {\n      Authorization: accessToken,\n    },\n    data: order,\n  });\n\n  return data;\n}\n```\n\n마지막으로, 실제로 generateAccessToken 함수를 사용하여 액세스 토큰을 생성하는 코드를 살펴봅시다:\n\n```js\nimport axios, { AxiosRequestConfig, AxiosResponse } from 'axios';\n\nimport { logger } from '@shared';\nimport { stringify } from 'querystring';\n\nexport async function generateAccessToken(\n  clientId: string,\n  clientSecret: string,\n  url: string,\n  scopes: string[] = []\n): Promise<string> {\n  try {\n    const payload = {\n      grant_type: 'client_credentials',\n      scope: scopes.length ? scopes.join(' ') : undefined,\n    };\n\n    const options: AxiosRequestConfig = {\n      method: 'post',\n      headers: { 'content-type': 'application/x-www-form-urlencoded' },\n      auth: {\n        username: clientId,\n        password: clientSecret,\n      },\n      data: stringify(payload),\n      url: '/oauth2/token',\n      baseURL: url,\n    };\n\n    const { data }: AxiosResponse<any> = await axios.request(options);\n\n    logger.info(`액세스 토큰 응답: ${data}`);\n\n    return data?.access_token as string;\n  } catch (error) {\n    throw error;\n  }\n}\n```\n\n위의 코드에서 알 수 있듯이, 이 코드는 클라이언트 ID, 시크릿 및 스코프를 사용하여 중앙 인증 서비스(Cognito 사용자 풀)의 토큰 엔드포인트에 POST 요청을 수행하여 유효하면 액세스 토큰을 반환합니다. 액세스 토큰은 이와 유사합니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n{\n  \"sub\": \"<your-client_id>\",\n  \"token_use\": \"access\",\n  \"scope\": \"lj-health-food/place-order\",\n  \"auth_time\": 1709980199,\n  \"iss\": \"https://cognito-idp.eu-west-1.amazonaws.com/eu-west-1_tyReqcsgR\",\n  \"exp\": 1709983799,\n  \"iat\": 1709980199,\n  \"version\": 2,\n  \"jti\": \"x9d6ggd3-8752-4b4f-1423-12x01bsd5b89\",\n  \"client_id\": \"<your-client_id>\"\n}\n```\n\nThe token의 주요 속성들은 다음과 같습니다:\n\n- sub: 이것은 토큰의 주체를 나타내며 일반적으로 클라이언트 ID를 가리킵니다.\n- token_use: 토큰의 목적을 나타냅니다. 이 경우 \"access\" 토큰으로, 특정 리소스나 서비스에 액세스를 부여하는 의미입니다.\n- scope: 토큰으로 부여된 특정 권한을 설명합니다. 이 예제에서 토큰은 \"lj-health-food/place-order\" 스코프에 액세스를 부여하므로, \"lj-health-food\" 서비스 내에서 주문을 할 수 있는 능력을 나타냅니다.\n- auth_time: 인증이 발생한 시간을 나타내며 유닉스 에포크를 기준으로 한 초 단위로 측정됩니다 (1970년 1월 1일 00:00:00 UTC부터의 초).\n- iss: \"발급자\"를 나타내며 토큰의 발급자를 지정합니다. 토큰을 발급한 ID 공급자의 URL입니다. 여기서는 Amazon Cognito ID 공급자입니다.\n- exp: 토큰의 만료 시간을 나타내며, 그 이후에는 유효하지 않다고 간주되어야 합니다. auth_time과 마찬가지로 유닉스 에포크를 기준으로 합니다.\n- jti: \"JWT ID\"를 의미하며 토큰의 고유 식별자입니다. 토큰 재생 공격을 방지하는 데 도움이 됩니다.\n- client_id: 토큰을 요청한 클라이언트 응용 프로그램의 ID를 나타냅니다.\n\n이제 코드를 확인하고 배포하고 UI를 탐험하여 여러분의 요구에 맞게 조정하세요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 마무리\n\n여기까지 읽어주셔서 감사합니다! 요약하면 다음과 같은 내용을 다루었습니다:\n\n✔️ Amazon Cognito 기계 대 기계 흐름이란 무엇인가.\n✔️ 중앙 집중식 인증 플랫폼이 필요한 이유를 살펴보았습니다.\n✔️ 기본 예제 프론트엔드 UI를 살펴보았습니다.\n✔️ 전체적인 AWS 아키텍처를 설명했습니다.\n✔️ TypeScript 및 AWS CDK 코드를 살펴보았습니다.\n\n# 마무리 인사 👋🏽\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 기사를 즐겨 보셨다면 공유하고 피드백 주시면 감사하겠습니다!\n\n유사한 콘텐츠를 원하신다면 제 유튜브 채널을 구독해주세요!\n\n![이미지](/TIL/assets/img/2024-07-07-ServerlessAuthSelf-ServePlatform_7.png)\n\n아래의 채널을 통해 저와 연결하고 싶습니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nhttps://www.linkedin.com/in/lee-james-gilmore/\nhttps://twitter.com/LeeJamesGilmore\n\n만약 게시물을 즐겼다면 추가로 게시물/시리즈를 보기 위해 제 프로필 Lee James Gilmore를 팔로우해주세요. 그리고 꼭 연결하고 안부를 물어보세요 👋\n\n그리고 게시물 하단에 있는 '박수' 기능도 사용해주세요. (한 번 이상 박수를 칠 수 있어요!!)\n\n# 나에 대해\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\"안녕하세요, 저는 영국에 거주하는 AWS 커뮤니티 빌더, 블로거, AWS 인증 클라우드 아키텍트이자 Global Head of Technology & Architecture인 Lee입니다. 현재 City Electrical Factors (UK) & City Electric Supply (US)에서 근무하고 있으며, 지난 6년 동안 AWS에서 전문적으로 풀 스택 JavaScript를 주로 다루고 있습니다.\n\n저는 서버리스를 지지하는 입장에서 모든 것에 대한 사랑, 혁신, 소프트웨어 아키텍처, 기술에 대한 관심을 가지고 있습니다.\"\n\n**_ 제공된 정보는 제 개인적인 견해이며 정보 사용에 대한 책임을 지지 않습니다. _**\n\n아래 내용도 참고하실 수 있습니다:\n","ogImage":{"url":"/assets/img/2024-07-07-ServerlessAuthSelf-ServePlatform_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-ServerlessAuthSelf-ServePlatform_0.png","tag":["Tech"],"readingTime":26},{"title":"알고 계셨나요  Python 내장 우선순위 큐 소개","description":"","date":"2024-07-07 21:48","slug":"2024-07-07-DidYouKnowPythonHasABuilt-inPriorityQueue","content":"\n<img src=\"/TIL/assets/img/2024-07-07-DidYouKnowPythonHasABuilt-inPriorityQueue_0.png\" />\n\n우선 순위 큐:\n\n- 요소들의 집합\n- 각 요소는 어떤 종류의 우선 순위가 할당되어 있음\n- 큐 내에서 가장 높은 우선 순위를 가진 요소가 먼저 처리됨\n- 요소를 큐에 넣는 순서는 중요하지 않음\n\n예를 들어, 이 숫자들이 포함된 우선 순위 큐가 있다고 가정해봅시다. 낮은 숫자가 높은 우선 순위를 의미합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\npq = [3, 7, 1, 6, 4, 5];\n```\n\n- 여기서 3이 먼저 삽입되고, 그 다음에 7, 그 다음에 1이 들어갑니다.\n- 그러나 3은 큐에서 제일 먼저 떠난 요소가 아닙니다.\n\n```js\n# 큐에서 팝\n1\n\n# 큐에서 팝\n3\n\n# 큐에서 팝\n4\n```\n\n- 1이 3보다 먼저 나가는 이유는 더 높은 우선순위를 가지고 있기 때문입니다.\n- 3은 1 다음으로 가장 높은 우선순위를 가지고 있기 때문에 다음에 나갑니다.\n- 4는 3 다음으로 가장 높은 우선순위를 가지고 있기 때문에 그 다음에 나갑니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 이런. 정렬만 하면 되잖아요?\n\n```js\npq = [3, 7, 1, 6, 4, 5]\npq.sort()\n\n# pq = [1, 3, 4, 5, 6, 7]\n```\n\n이제는 우선순위대로 1, 3, 4 순으로 pop할 수 있습니다. 네 할 수 있어요.\n\n하지만 문제는 이 목록에 새 숫자를 추가하려고 할 때 발생합니다.\n","ogImage":{"url":"/assets/img/2024-07-07-DidYouKnowPythonHasABuilt-inPriorityQueue_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-DidYouKnowPythonHasABuilt-inPriorityQueue_0.png","tag":["Tech"],"readingTime":2},{"title":"Python 기초 __init__py를 사용해야 하는 이유","description":"","date":"2024-07-07 21:47","slug":"2024-07-07-PythonBasicsWhyuse__init__py","content":"\n![Screenshot](/TIL/assets/img/2024-07-07-PythonBasicsWhyuse__init__py_0.png)\n\n안녕하세요! 오늘은 Python의 **init**.py에 대해 이해해보겠습니다. 아주 작지만 중요한 역할을 하는 파일이에요. 기술 용어 없이 쉽게 파악해봐요.\n\n## **init**.py란?\n\nPython 파일이 모인 디렉터리를 패키지로 취급하고 싶다면 **init**.py 파일을 넣어주면 됩니다. 그러면 Python이 그 디렉터리를 패키지로 인식해요. 코드와 Python 사이의 비밀 악수 같은 존재죠.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*vRslGzL6g4YZkmkF5DDX1g.gif)\n\n# 이 init.py 파일 안에는 무엇이 있을까요?\n\n파이썬의 **init**.py에 대해 궁금해 해보셨나요? 이 파일은 단순히 빈 파일일 수도 있고, 특별한 설정이 필요한 경우 일부 초기화 코드를 포함할 수도 있습니다. 하지만 대부분의 경우, 비어있는 **init**.py 파일만 있어도 충분합니다. **init**.py 파일을 패키지의 사용 준비가 되어 있다고 생각해보세요. 누군가 당신의 패키지를 사용하고자 할 때, 그들은 코드에서 그것을 import하고 Python은 그 마법같은 **init**.py를 찾아볼 것입니다.\n\n**init**.py가 없으면, Python은 당신의 디렉토리를 패키지로 인식하지 못하며 표준 \"import\" 문을 사용하여 해당 모듈을 가져올 수 없습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![](https://miro.medium.com/v2/resize:fit:1400/1*ICEW26oY5tK3yjpO267rHw.gif)\n\n# \\_\\_init\\_\\_.py 가 파이썬 패키지 생성에 어떻게 도움이 될까요?\n\n\\_\\_init\\_\\_.py 는 코드를 모듈화된 청크로 구성할 수 있게 해주어 모든 것을 매우 효율적으로 관리하고 재사용할 수 있습니다. 패키지의 청사진으로 상상해보세요 — \\_\\_init\\_\\_.py 에서 공통 함수, 변수를 정의하거나 다른 모듈을 import하여 패키지의 기능에 대한 기반을 설정할 수 있습니다.\n\n# 예제\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n간단한 패키지인 my_package를 생성해보겠습니다. my_package 디렉토리 내부에서 어떻게 **init**.py가 작동하는지 설명하기 위해 빈 **init**.py 파일을 만들고 greetings.py 파일을 생성하여 say_hello() 함수를 작성해봅시다. 이 함수는 “Hello, World!”를 출력합니다.\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*Bk3i_Yta7rGPZ9b_xap4KA.gif)\n\n```python\n# greetings.py\ndef say_hello():\n  print(\"Hello, World!\")\n```\n\n이제 my_package 디렉토리 외부의 어떤 파일에서든 greetings 모듈을 가져와 say_hello() 함수를 사용할 수 있습니다. 이 때 **init**.py 파일이 greetings 모듈을 my_package 네임스페이스 내에서 접근 가능하게 만들어주기 때문에 “Hello, World!”가 출력됩니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*fcHy0Fyq7xfaCafR3hcGHw.gif\" />\n\n# 결론\n\n**init**.py는 구조화되고 조직화된 Python 패키지를 만드는 데 중요한 기본 요소입니다. 코드를 함께 유지하는 보이지 않는 접착제처럼 동작하여 재사용하고 공유하기가 쉬워집니다. 간단히 말하면, **init**.py는 Python 프로젝트의 시작 선과도 같습니다.\n\n좋아요, 멋진 분들! 여기까지가 전부에요. **init**.py를 Python 프로젝트의 중요한 역할로 생각해보세요! 조용하게 존재하지만 모든 코드 조각들을 함께 모아 깔끔하게 정리하고 공유할 수 있게 도와줍니다. 언제나처럼, 즐거운 코딩하시고 여러분의 프로젝트가 항상 조직적이기를 바라겠습니다!\n","ogImage":{"url":"/assets/img/2024-07-07-PythonBasicsWhyuse__init__py_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-PythonBasicsWhyuse__init__py_0.png","tag":["Tech"],"readingTime":4},{"title":"SQLAlchemy ORM 시작하기  데이터 가져오기 버전 35","description":"","date":"2024-07-07 21:46","slug":"2024-07-07-GettingStartedwithSQLAlchemyORMDataFetching35","content":"\n![이미지](/TIL/assets/img/2024-07-07-GettingStartedwithSQLAlchemyORMDataFetching35_0.png)\n\nORM에서 Core와 동일하게 많은 것들이 작동합니다. 한 가지 다른 점은 연결 실행 방법 대신 세션을 사용한다는 것입니다.\n\n## ID로 가져오기\n\n만약 ID로 사용자를 가져오고 싶다면, 두 가지 옵션이 있습니다. session.query와 session.get을 사용할 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n세션에서 get 메서드를 직접 사용할 수 있으며, Todo 클래스와 기본 키를 전달해야 합니다.\n\n```python\nfrom sqlalchemy import create_engine, Column, Integer, Text\nfrom sqlalchemy.orm import Session, DeclarativeBase\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Todo(Base):\n    __tablename__ = \"todos\"\n\n    id = Column(Integer, primary_key=True)\n    label = Column(Text, nullable=False)\n    status = Column(Text, nullable=False)\n\n# Base.metadata.drop_all(engine)\n# Base.metadata.create_all(engine)\n\ntodos = [\n    Todo(label=\"Walk a dog\", status=\"doing\"),\n    Todo(label=\"Shopping\", status=\"in_progress\"),\n]\n\nwith Session(engine) as session:\n    # session.add_all(todos)\n    # session.commit()\n\n    result = (\n        session.get(Todo, 1)\n    )\n\n    print(result.id, result.label, result.status)  # 1 Walk a dog doing\n```\n\n기본 키를 사용하지 않거나 다른 열에서 검색하려는 경우 where 메서드를 사용할 수 있습니다. 이 경우에는 예를 들어서...\n","ogImage":{"url":"/assets/img/2024-07-07-GettingStartedwithSQLAlchemyORMDataFetching35_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-GettingStartedwithSQLAlchemyORMDataFetching35_0.png","tag":["Tech"],"readingTime":2},{"title":"Redis 대신 PostgreSQL을 사용해야 하는 이유","description":"","date":"2024-07-07 21:46","slug":"2024-07-07-WhoneedsRediswhenPostgreswilldo","content":"\n![이미지1](/TIL/assets/img/2024-07-07-WhoneedsRediswhenPostgreswilldo_0.png)\n\n레디스를 정말 좋아합니다. 토네이도 앱을 확장하고 실시간 업데이트를 지원할 수 있게 해줬죠. 토네이도는 nginx 뒤에서 실행하고 토네이도 앱의 여러 인스턴스를 가동하는 것을 권장합니다.\n\n![이미지2](/TIL/assets/img/2024-07-07-WhoneedsRediswhenPostgreswilldo_1.png)\n\n이제 클라이언트가 앱에 연결하고 모든 앱의 모든 클라이언트에게 방송이 전달되어야 합니다. 레디스는 여기서 나서서 모든 앱이 레디스 채널을 구독하고 작성 앱에서 publish를 호출하는 pub/sub(발행 및 구독) 패턴을 제공합니다. 이는 Heroku나 AWS에서 매우 잘 작동하는데, 누가 서버가 몇 개나 있는지 알 수 없는 환경에서 작동합니다. 그러나 단일 장애 지점을 도입하게 됩니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/TIL/assets/img/2024-07-07-WhoneedsRediswhenPostgreswilldo_2.png\" />\n\n그럼, Postgres는 어떤가요? 저의 지속성은 SQLAlchemy로 이뤄집니다. MySQL에서 Postgres로 가끔 전환해 보았는데, 장점이 있는지 살펴보기 위해서예요. MySQL은 인noDB 인터페이스를 통해 캐시를 업데이트할 수 있는데, 이는 인noDB 트랜잭션 내에서 기본 데이터를 업데이트하는 동시에 캐시를 업데이트할 수 있어요. 안타깝게도, MySQL의 개발자들은 이 확장 기능을 폐기하기로 결정했어요. 그래서 Postgres와 그들 자체의 연결 클래스를 살펴보았어요. 함께 살펴보죠...\n","ogImage":{"url":"/assets/img/2024-07-07-WhoneedsRediswhenPostgreswilldo_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-WhoneedsRediswhenPostgreswilldo_0.png","tag":["Tech"],"readingTime":2},{"title":"E-도서관 데이터베이스 설계, 핵심 요약","description":"","date":"2024-07-07 21:44","slug":"2024-07-07-E-LibraryDatabaseDesigninginaNutshell","content":"\n내가 이것을 쓰기 전에, 팝컬쳐 특히 원피스에 너무 많은 선호를 준 것에 대해 죄송합니다. 강조해야 할 특정한 것이 하나 있거든요. 오하라 섬과 그 도서관에 관한 것입니다.\n\n![이미지](/TIL/assets/img/2024-07-07-E-LibraryDatabaseDesigninginaNutshell_0.png)\n\n여기서 무슨 일이 있었는지에 대해 너무 많이 이야기하고 싶지 않겠습니다. 이 기사의 초점은 책에 있습니다. 어떻게 디자인하고 관리하며 관련 정보를 수집하는지 등의 것이요. 그러나 이 기사에서는 컴퓨터의 도움을 받아서 이 작업을 잘 할 겁니다. 여전히 책들과 다루긴 하지만, 지난 큰 도서관과의 추악한 역사처럼 이번에는 이 책들이 쉽게 태울 수 없어요. 그러니 시작해봅시다.\n\n내 첫 인상은, 책을 두려워하지 마세요. 책은 어디서나 있어요. 만나본 모든 사람이 다르지 않나요? 네, 우리는 생동하는 책 자체예요. 심지어 당신의 책도 만나본 수많은 사람들에게 빌려주면 수천 권의 책으로 번지더라구요. 모든 것이 아직 기계적이었던 옛날, 도서관에 가는 것은 세계 여행하는 것과 같았어요, 그러나 최대한 싼 방법으로요. 우리가 와서 자신의 ID를 만들고, 원하는 책을 고르고, 빌리고, 그 책을 돌려주고, 그리고 되풀이했죠. 하지만 요즘엔 그렇지 않아요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n현재의 디지턈 시대에는 젊은 세대를 중심으로 디지턈 도서관이 인기를 끌고 있어요. 이는 접근성과 유연성이 뛰어나기 때문입니다. 이제는 실제 도서관을 방문하지 않고도 다양한 정보, 책 및 학습 자료를 얻을 수 있어요. 전자책 같은 걸 들어봤나요?\n\n그래서 이 기사의 목적은 디지턈 도서관을 위한 데이터베이스 시스템을 설계하여 효율성을 향상시키고 잘 조직된 구조를 유지하는 데 도움을 주는 것이에요. 오하라 도서관처럼, 하지만 디지턈 버전으로 말이죠.\n\n데이터베이스를 설계할 때의 첫 번째 단계는 미션 명성을 결정하는 것이에요. 이 프로젝트의 미션 명성은 다음과 같아요:\n\n- 사용자는 도서관에 있는 책 제목을 살펴볼 수 있어요.\n- 사용자는 카테고리 또는 유형에 따라 책을 검색할 수 있어요.\n- 사용자는 각 책의 도서관 보유량을 알 수 있어요.\n- 사용자는 읽고 싶은 책을 대출하거나 예약할 수 있어요.\n- 사용자는 각 책의 가용성을 확인할 수 있어요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그럼에도 불구하고 이 프로젝트에는 몇 가지 주의할 점이 있습니다:\n\n- 기본 대출 기간은 2주입니다. 그러나 고객들은 책을 더 빨리 반납할 수 있고, 도서 대출 기간을 초과하면 책이 자동으로 반납됩니다.\n- 고객들은 동시에 최대 2권의 책을 대출할 수 있습니다.\n- 현재 이용 불가한 책을 예약할 수 있지만, 고객들은 한 번에 최대 2권만 예약할 수 있습니다.\n\n그리고 이후에 전자 도서관 시스템을 위한 표를 만들고, 주요 및 외래 키를 정의하여 그들의 관계를 확립할 수 있습니다. 아래 그림은 저가 만든 개체 관계 다이어그램(ERD)이며, 각 표에 대한 설명이 포함되어 있습니다. 전체로 10개의 표가 있습니다.\n\n![E-Library ERD](/TIL/assets/img/2024-07-07-E-LibraryDatabaseDesigninginaNutshell_1.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Image](/TIL/assets/img/2024-07-07-E-LibraryDatabaseDesigninginaNutshell_2.png)\n\nLibraries table\n\n- This table contains information about libraries, including the library_id of each library, its name, and address\n\nCategories table\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n---\n\n이 표는 각 카테고리의 ID와 이름을 포함한 카테고리 정보를 담고 있습니다.\n\n작가 테이블\n\n---\n\n이 표는 각 작가의 ID와 이름을 포함한 작가 정보를 담고 있습니다.\n\n출판사 테이블\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n— 이 테이블은 각 출판사의 ID와 이름을 포함한 출판사에 대한 정보가 포함되어 있습니다.\n\nBooks 테이블\n\n— 이 테이블은 책에 대한 정보를 포함하고 있으며, 주요 키로 책의 ID, 제목, 작가 ID, 카테고리 ID, 출판사 ID 및 책 유형이 포함되어 있습니다.\n\nLibrary Collections 테이블\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n특정 도서관에 소장된 책 정보가 담긴 이 테이블은 특정 컬렉션의 ID, 특정 도서관의 ID, 해당 도서관의 ID, 그리고 이용 가능한 수량을 포함하고 있습니다.\n\n회원 테이블\n\n— 특정 회원의 ID(주요 키), 이름, 주소, 이메일 정보를 포함하는 회원 정보가 담긴 테이블입니다.\n\n사용자 테이블\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n— 사용자 정보를 포함한 테이블이며 특정 사용자의 ID가 주요 키로 사용되고, 회원 ID, 비밀번호 및 전화 번호가 포함되어 있습니다.\n\nBorrow 테이블\n\n— 이 전자 도서관에서 대출 된 책에 대한 정보가 포함 된 테이블입니다. 각 대여 사례에 대해 ID가 주요 키로 사용됩니다. 대출 한 사용자의 ID, 대출 된 도서관 컬렉션 ID, 대출 된 책이 빌린 시간을 나타내는 borrow_date, 대출 날짜가 만료 된 도서의 due_date, 책이 반납 된 시간인 return_date, 그리고 책이 반납 되었는지 여부를 나타내는 return_status가 포함되어 있습니다.\n\nHolds 테이블\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n— 이 테이블은 전자 도서관에 보관되어 있는 컬렉션에 관한 정보를 포함하고 있습니다. 각 보유 케이스에는 id가 있습니다. 사용자 id, 보유한 도서관 컬렉션 id, 도서 보유가 시작된 시간에 대한 정보를 나타내는 hold_start, 도서 보유 날짜가 만료되는 시간을 나타내는 hold_end가 포함되어 있습니다.\n\n## 디자인 구현\n\n다음 단계에서는 PostgreSQL을 사용하여 데이터베이스 또는 ERD의 디자인을 구현할 수 있습니다. 테이블을 생성하고 관계를 정의하기 위해 데이터 정의 언어(DDL) 구문을 사용할 수 있습니다. 그리고 데이터베이스 디자인을 구현하는 단계는 다음과 같습니다:\n\n- PostgreSQL 데이터베이스에 연결\n- 데이터베이스 생성\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nCREATE TABLE library_collections\n(\nlibrary_collection_id SERIAL PRIMARY KEY,\nlibrary_id INTEGER NOT NULL,\nbooks_id INTEGER NOT NULL,\nquantity_available INTEGER NOT NULL CHECK(quantity_available >= 0),\nCONSTRAINT fk_library_collections_lib\nFOREIGN KEY(library_id)\nREFERENCES libraries(library_id),\nCONSTRAINT fk_library_collections_bk\nFOREIGN KEY(books_id)\nREFERENCES books(books_id)\n);\n\n위의 예시는 라이브러리 컬렉션 테이블 세트를 만드는 경우이며, 해당 외래 키로 제약 조건이 있는 테이블을 작성하는 방법을 보여줍니다. 각각의 외래 키는 자신이 참조하는 원본 테이블을 참조하며, 각 키는 자신이 참조하는 테이블의 기본 키입니다. 전체 문서에 대한 자세한 내용은 아래 링크를 클릭하십시오:\n\nhttps://github.com/ziadbwdn/E-LibraryRDB\n\n## 데이터베이스 생성\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n데이터베이스에서 데이터를 검색하기 위해 테이블 형식의 데이터가 필요합니다. 이 경우, 테이블을 수동으로 생성한 데이터와 Python 라이브러리 Faker를 결합하여 얻은 더미 데이터를 사용합니다. 아래에 이전 스크립트를 통해 생성된 코드 예제와 faker를 사용한 이후 스크립트를 살펴볼 수 있습니다:\n\n```js\n# 라이브러리 테이블 생성\ndef create_libraries(library_name, library_address):\n    \"\"\"\n    도서관에 대한 DataFrame 생성\n\n    Parameters:\n    - library_names (list): 도서관 이름 목록, 총 8개가 있습니다.\n    - library_address (list): 도서관 주소 목록, 총 8개가 있습니다.\n\n    Returns:\n    - pd.DataFrame: 도서관 ID 및 도서관 이름과 같은 정보를 포함하는 DataFrame\n    \"\"\"\n\n    libraries = {\n        \"library_id\": [i + 1 for i in range(len(library_name))],\n        \"library_name\": library_name,\n        \"library_address\": library_address\n    }\n\n    libraries_df = pd.DataFrame(libraries)\n    return libraries_df\n\nlibrary_name = [\"와칸다 도서관\",\n                \"푸스타카 코노하\",\n                \"포헨 펜게타후안 풀라우 오하라\",\n                \"마이크로 라이브러리 와락 카유\",\n                \"C2O 도서관\",\n                \"키네루쿠 도서관\",\n                \"바카 디 테벳\",\n                \"타만 바카 아민 페르푸스타카안 콘테이너\",\n                ]\n\nlibrary_address = [\"서라바야 자바 팀루 마르고무르 요 퍼마이 6-8 도메인 G 술라바야 자바 팀루\",\n                   \"자와 바랏 반둥 지엠 앙디리 34-38 번듕 자와 바랏\",\n                   \"자카르타 디케이 아일란트 자카르타 끄븽나가 라야 25 풀로 게방 라야 25 자카르타 DKI 자카르타\",\n                   \"메단 수마테라 우타라 마니아 라야 18-20 서라바야 자바 팀루\",\n                   \"주아 티음틸리스 라야 26 자카르타 DKI 자카르타\",\n                   \"레페트시부 올라야 16 자카르타 DKI 자카르타\",\n                   \"반두르 자와 바랏 H Juanda 377 반등 자와 바랏\",\n                   \"반두르 자와 바랏 H Juanda 377 반등 자와 바랏\"\n                  ]\nlibraries_table = create_libraries(library_name, library_address)\nlibraries_table\n```\n\n```js\n# 저자 테이블 생성\ndef create_authors(n_authors):\n    \"\"\"\n    저자 및 저자 이름과 저자 ID 사이의 매핑을 만드는 작업\n\n    Parameters:\n    - n_authors (int): 작성할 저자 정보의 수\n\n    Returns:\n    - pd.DataFrame: 저자 ID 및 저자 이름과 같은 정보를 포함하는 DataFrame\n    \"\"\"\n    authors = []\n    for a in range(n_authors):\n        authors.append({\n            'author_id': fake.unique.random_int(min=1, max=9999),\n            'author_name': fake.name()\n        })\n\n    authors_df = pd.DataFrame(authors)\n    return authors_df\n\n# 저자 DataFrame 및 매핑 생성\nauthors_table = create_authors(800)\nauthors_table\n```\n\n사용할 라이브러리를 가져오는 첫 번째 단계는 다음과 같습니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- pandas: Python에서 데이터 조작 및 분석에 사용됩니다.\n- Faker: 가짜 데이터를 생성하는 데 사용되는 라이브러리입니다.\n- random: 무작위 값을 생성하는 데 사용됩니다.\n- timedelta: 시간을 계산하는 데 사용됩니다.\n\n그리고 가짜 데이터를 얻기 위해 위치 설정을 인도네시아로 설정하세요. 이름, 주소 및 이메일과 같은 가짜 데이터를 얻을 수 있습니다.\n\n```js\n# 2단계: 인도네시아 또는 영어로 위치 설정\nfake = Faker('id_ID' or 'en_EN')\n```\n\n이후에는 PostgreSQL에 가져오기 전에 더미 데이터를 얻기 위해 필요한 데이터를 실행할 수 있습니다. 만든 테이블 데이터프레임을 성공적으로 저장하기 위해 먼저 csv로 저장해야 합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# CSV로 저장하기\nauthors_table.to_csv('authors.csv', index=False)\n\n# CSV로 저장하기\nlibrary_collections_table.to_csv('library_collections.csv', index=False)\n```\n\n전체 코드는 이 페이지에서 확인할 수 있습니다\n\nhttps://github.com/ziadbwdn/E-LibraryRDB\n\n이제 가져오기 프로세스에 필요한 모든 데이터가 있는 경우 예를 들어 SQL 쿼리 도구에서 계속할 수 있습니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nCOPY authors(author_id, author_name)\nFROM 'C:\\Program Files\\PostgreSQL\\16\\pgAdmin 4\\SQL Exercise 4\\authors.csv'\nDELIMITER ','\nCSV HEADER\n\nCOPY library_collections(library_collection_id, library_id, books_id, quantity_available)\nFROM 'C:\\Program Files\\PostgreSQL\\16\\pgAdmin 4\\SQL Exercise 4\\library_collections.csv'\nDELIMITER ','\nCSV HEADER\n```\n\n이 작업을 수행하기 전에, DDL 구문에서 만든 데이터와 파이썬에서 출력한 csv가 ERD 다이어그램 처럼 우리가 설계한 요구 사항을 충분히 준수하는지 확인하는 것이 중요합니다.\n\n## 사례 연구\n\n먼저, 각각의 도서관에서 가장 많고 가장 적은 책을 가지고 있는 도서관을 확인해보겠습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```sql\nSELECT\n l.library_name,\n COUNT (books_id) AS total_book_collections\nFROM library_collections AS lc\nJOIN libraries AS l ON lc.library_id = l.library_id\nGROUP BY library_name\nORDER BY total_book_collections DESC\n```\n\n그리고 아래는 결과입니다:\n\n![이미지](/TIL/assets/img/2024-07-07-E-LibraryDatabaseDesigninginaNutshell_3.png)\n\nBaca Di Tebet은 책 수집량을 기준으로 하면 가장 많이 모은 도서관이며, Taman Baca Amin은 가장 작은 책 모음을 가진 1196 대비 1304개를 수집했습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그리고 두 번째로, 우리는 가장 많은 책을 대출한 도서관 회원을 살펴보려고 해요.\n\n```js\nWITH frequent_borrower as (\n SELECT\n  br.user_id,\n  m.member_name,\n  count (br.borrow_id) as amount_of_borrow,\n  br.return_status\n\n FROM borrows as br\n join users as u on br.user_id = u.user_id\n join members as m on u.member_id = m.member_id\n WHERE return_status is true\n GROUP BY 1,2,4\n )\n\nSELECT * from frequent_borrower as fb\nwhere fb.amount_of_borrow > 2\norder by amount_of_borrow desc limit 10\n```\n\n그런 다음 우리가 결과물로 다음을 받았어요:\n\n<img src=\"/TIL/assets/img/2024-07-07-E-LibraryDatabaseDesigninginaNutshell_4.png\" />\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nHartika Narpati부터 Edward Prasetya까지는 도서 4권을 대출한 가장 빈번한 독자입니다.\n\n세 번째 단계에서는, 테이브이지를 다음과 같이 마크다운 형식으로 변경해주세요:\n\n| 책 제목    | 카테고리 이름 | 도서관 이름  | 이용 가능 수량     |\n| ---------- | ------------- | ------------ | ------------------ |\n| book_title | category_name | library_name | quantity_available |\n\n예를 들어, 청소년 자매가 로맨스 소설을 찾고 있어서 도와달라고 요청하며, 특정 도서관(예: Pustaka Konoha)를 찾고 있다면 어떨까요? 아래 PostgreSQL 쿼리를 사용해볼까요?\n\n```sql\nWITH konoha_books as (\n SELECT b.book_title,\n   c.category_name,\n   l.library_name,\n   lc.quantity_available\n FROM books as b\n join categories as c on b.category_id = c.category_id\n join library_collections as lc on b.books_id = lc.books_id\n join libraries as l on lc.library_id = l.library_id\n WHERE library_name = 'Pustaka Konoha'\n )\n\nSELECT * FROM konoha_books as kb\nWHERE category_name ilike '%Romance%'\nORDER BY kb.quantity_available DESC\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이후 다음이 결과로 나타납니다:\n\n![이미지](/TIL/assets/img/2024-07-07-E-LibraryDatabaseDesigninginaNutshell_5.png)\n\n푸스타카 코노하에는 카테고리 소설 - 로맨스에 속하는 131개의 컬렉션이 있습니다.\n\n성장을 위해 사회과학을 주전공으로 선택하셨고, 감독님으로부터 사회과학 주제의 참고 자료를 우선으로 찾아야 한다는 지시를 받았지만 수라바야에 있다는 한계가 있습니다. PostgreSQL 쿼리를 사용하십시오.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nWITH surabaya_books as (\n SELECT  b.book_title,\n   c.category_name,\n   l.library_name,\n   l.library_address,\n   lc.quantity_available\n FROM books as b\n join categories as c on b.category_id = c.category_id\n join library_collections as lc on b.books_id = lc.books_id\n join libraries as l on lc.library_id = l.library_id\n WHERE library_address ilike '%Surabaya%'\n )\n\nSELECT * FROM surabaya_books as sb\nWHERE category_name ilike '%Social%'\nORDER BY ab.quantity_available\n```\n\n위 쿼리를 실행한 결과는 아래와 같습니다:\n\n![이미지](/TIL/assets/img/2024-07-07-E-LibraryDatabaseDesigninginaNutshell_6.png)\n\n위 결과를 보면, 수라바야에서 볼 수 있는 사회과학 분야의 도서 총 174권이 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마지막으로, 빌린 날짜로부터 일반적으로 두 주 후인 만기일을 초과하는 반납으로 인해 벌금을 내야 할 수 있는 사람들이 있습니다. 그들이 누구인지 알아보세요!\n\n```js\nWITH duration_borrower as (\n SELECT\n  EXTRACT (DAY FROM br.borrow_date) as days_of_borrow,\n  EXTRACT (DAY FROM br.return_date) as days_of_return,\n  br.user_id,\n  br.borrow_id,\n  m.member_name,\n  count (br.borrow_id) as amount_of_borrow,\n  br.return_status\n\n FROM borrows as br\n join users as u on br.user_id = u.user_id\n join members as m on u.member_id = m.member_id\n GROUP BY 1,2,3,4,5,7\n )\n\nSELECT\n dur_b.borrow_id,\n dur_b.member_name,\n ABS(dur_b.days_of_return - dur_b.days_of_borrow) as interval_days,\n dur_b.return_status\n\nfrom duration_borrower as dur_b\nwhere return_status is false\ngroup by 1,2,3,4\norder by 3 desc\nlimit 10\n```\n\n그런 다음 다음을 결과로 받았습니다:\n\n<img src=\"/TIL/assets/img/2024-07-07-E-LibraryDatabaseDesigninginaNutshell_7.png\" />\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n현재 Farah Padmasari와 Latika Wasita가 이번 기회에 조금의 경고나 벌금을 받아야할 것 같아요.\n\n안팎을 다듬으면서 이런 것들의 내부 작동 방식을 조금씩 파악할 수 있기를 희망해요. 완벽하지는 않겠지만, 계속해서 발전할 여지가 많을 거에요.\n\n혹시 실제 책은 태울 수 있지만, 디지털 책은 그렇게 쉽게 태울 수 없지요. 오하라의 지식의 등대는 아직 살아있어요, 적어도 이제는 니코 로빈과 빨강머리 해적단의 손에 있어요. 감사합니다.\n\n참고자료:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- https://github.com/ziadbwdn/E-LibraryRDB\n- https://faker.readthedocs.io/en/master/\n- https://www.postgresql.org/docs/\n","ogImage":{"url":"/assets/img/2024-07-07-E-LibraryDatabaseDesigninginaNutshell_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-E-LibraryDatabaseDesigninginaNutshell_0.png","tag":["Tech"],"readingTime":18},{"title":"PySpark 완벽 가이드 DataFrame 생성과 데이터를 채우는 네 가지 방법","description":"","date":"2024-07-07 21:43","slug":"2024-07-07-PySparkExplainedFourWaystoCreateandPopulateDataFrames","content":"\n\n파이스파크를 사용할 때 특히 SQL에 백그라운드를 가지고 있다면, 처리할 데이터를 데이터프레임으로 가져오는 것이 처음으로 해야 할 일 중 하나일 것입니다. 데이터가 데이터프레임에 들어있으면, 데이터프레임에서 임시 뷰(또는 영구 테이블)를 쉽게 생성할 수 있습니다. 그 순간부터, PySpark SQL의 다양한 연산 명령이 데이터를 더 탐색하고 처리할 수 있도록 사용 가능해집니다.\n\n표준 SQL 기술이 PySpark SQL로 쉽게 전이 가능하기 때문에, 데이터를 처리 파이프라인에서 가능한 한 빠르게 PySpark SQL과 직접적으로 사용할 수 있도록 준비하는 것이 중요합니다. 효율적인 데이터 처리 및 분석을 위해 이 작업을 최우선 순위로 두어야 합니다.\n\n물론 이렇게 할 필요는 없습니다. PySpark SQL에서 뷰나 테이블을 사용할 수 있는 모든 작업은 API를 사용하여 데이터프레임에서도 직접 수행할 수 있습니다. 그렇지만, DataFrame API보다 SQL을 사용하는 것이 더 편한 사람으로써, 나의 스파크 사용 방법은 항상 다음과 같습니다.\n\n이 과정을 돕기 위해, 이 글에서는 파이프라인의 첫 단계인 데이터를 데이터프레임에 넣는 과정을 설명하여 네 가지를 한눈에 알려드릴 것입니다...","ogImage":{"url":"/TIL/assets/no-image.jpg"},"coverImage":"/TIL/assets/no-image.jpg","tag":["Tech"],"readingTime":1},{"title":"Python과 Boto3로 Redshift 자동화 효율적이고 비용 효과적인 클러스터 구축 가이드","description":"","date":"2024-07-07 21:41","slug":"2024-07-07-AutomatingRedshiftwithPythonandBoto3APlaybookforEfficientandCost-EffectiveClusters","content":"\n<img src=\"/TIL/assets/img/2024-07-07-AutomatingRedshiftwithPythonandBoto3APlaybookforEfficientandCost-EffectiveClusters_0.png\" />\n\n파이썬과 Boto3를 활용한 Amazon Redshift 클러스터 자동화에 관한 궁극의 안내서에 오신 것을 환영합니다! Redshift 관리 프로세스를 최적화하고 클러스터 및 스냅샷을 생성 및 관리하며 비용을 절감하고 효율성을 향상시키려면 올바른 곳에 왔습니다. 이 블로그에서는 환경 설정부터 Python을 사용한 고급 자동화 스크립트 구현까지 필수 단계를 안내합니다. 이 가이드를 마치면 실용적인 지식과 프로처럼 Redshift 클러스터를 처리할 준비가 된 코드 조각을 가지고 있을 것입니다. 시작해보죠! 💻📊\n\n# 준비 사항📋\n\nRedshift 자동화의 흥미로운 세계로 뛰어들기 전에 시작할 준비가 되어 있는지 확인해보겠습니다. 이 섹션에서는 AWS Redshift 환경 및 Python 설정에 필요한 필수 준비 사항을 안내해 드릴 것입니다. 🌐🐍\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- ☁️AWS 계정: Redshift를 사용해보기 위해 무료 체험을 신청해보세요.\n- 🐍 파이썬 설치: Redshift와 원할하게 대화하기 위해 공식 웹사이트에서 다운로드하세요.\n- 📦설치할 모듈: 터미널에서 pip install boto3를 사용하여 설치하세요. AWS 계정을 로컬 컴퓨터에 연결하는 방법에 대한 단계별 비주얼 가이드가 필요하다면, AWS 계정에 Boto3를 설정하는 비디오 자습서를 참고하세요.\n\n이러한 필수 사항이 갖춰지면, 클라우드 데이터베이스와 데이터 분석에 전문가처럼 뛰어들 준비가 되었습니다. ☁️📊\n\n# 목차 📚\n\n- 수동으로 Redshift 클러스터 생성하기 🎥\n- Python과 Boto3를 사용하여 클러스터 생성 자동화 🚀\n- 클러스터 일시 중지 및 재개 ⏸️▶️\n- 단일 작업으로 모든 Redshift 클러스터 일시 중지 ⏸️📊\n- 전문가처럼 클러스터 관리하기 🔍\n- 스냅샷: 데이터의 가장 친한 친구 📸\n- 효율적인 클러스터 관리 스크립트 📝\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 📚자료 섹션\n\n- 포괄적인 YouTube 비디오🎬: 이 YouTube 재생 목록에는 이 블로그의 코드 실행과 관련된 모든 비디오가 포함되어 있습니다.\n- GitHub 텍스트 파일 📄: 본 저장소에는 이 블로그에서 참조하는 모든 코드가 포함되어 있어, 프로젝트에 필요한 모든 스크립트와 도구에 액세스할 수 있습니다.\n\n# 수동으로 Redshift 클러스터 만들기 🎥\n\n시작해 볼까요? 여러분만의 Redshift 클러스터를 설정해 봅시다. 다음 단계를 따라 주세요:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- AWS Management Console에 로그인하세요: Redshift 서비스로 이동해주세요 🔍.\n- 클러스터 생성하기: '클러스터 생성'을 클릭하세요. 클러스터 식별자, 노드 유형, 데이터베이스 구성과 같은 세부 정보를 입력해주세요 🛠️.\n- 검토하고 시작하기: 설정을 확인하고 클러스터를 시작하세요. 이 과정은 몇 분이 소요될 수 있습니다⏳.\n- 보안 그룹 및 포트 구성: 보안 그룹을 편집하고 포트 번호를 5439로 설정해주세요.\n- 클러스터를 공개적으로 접속 가능하게 만들기: 작업으로 이동하여 공개적으로 접속 가능한 옵션을 활성화해주세요 🌐.\n\n레드시프트 클러스터 생성 방법에 대한 자세한 설명은 다음을 참고하세요:\n\n- 📺 이 비디오 튜토리얼 시청: 시각적인 학습자에게 완벽합니다!\n- 📄 이 블로그 포스트를 참조: 단계별 설명서를 선호하는 경우에 유용합니다.\n\n# Python 및 Boto3를 활용한 클러스터 생성 자동화 🚀\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 섹션에서는 Boto3와 Python을 사용하여 Redshift 클러스터를 생성하는 방법을 배우게 될 거에요. 이 안내서를 통해 상세한 코드 예제와 설명을 통해 과정을 안내할 거에요.\n\n## Redshift 클러스터 생성을 위한 코드 안내\n\n아래 이미지는 코드에서 수행되는 주요 단계를 보여줍니다:\n\n![Redshift Cluster Creation](/TIL/assets/img/2024-07-07-AutomatingRedshiftwithPythonandBoto3APlaybookforEfficientandCost-EffectiveClusters_1.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 Python 스크립트는 Boto3를 사용하여 Amazon Redshift 클러스터를 생성합니다. 특정 매개변수로 클러스터를 설정하고 클러스터의 상태를 지속적으로 확인하여 사용 가능해질 때까지 기다립니다. 클러스터를 사용할 수 있게 되면 확인 메시지를 출력합니다.\n\n## 비디오 자습서\n\n실제 코드 실행을 볼 수 있는 비디오 자습서를 확인해보세요:\n\n동일한 코드에 대한 링크 📎.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 가이드를 따라하면 Python과 Boto3를 사용하여 Redshift 클러스터를 효율적으로 생성할 수 있습니다. 다음 섹션에서는 클러스터 일시 중지 및 재개에 대해 배울 것입니다 ⏸️▶️\n\n# 클러스터 일시 중지 및 재개 ⏸️▶️\n\n이 섹션에서는 Boto3와 Python을 사용하여 Redshift 클러스터의 일시 중지 및 재개 프로세스를 자동화하는 방법을 배웁니다.\n\n# 1. 클러스터 재개하기 ▶️\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n클러스터를 다시 시작해보겠습니다. 아래는 코드 설명입니다:\n\n![code explanation](/TIL/assets/img/2024-07-07-AutomatingRedshiftwithPythonandBoto3APlaybookforEfficientandCost-EffectiveClusters_2.png)\n\n제공된 코드 스니펫은 Boto3를 사용하여 Redshift 클러스터를 재개하는 Redshift 클라이언트를 생성합니다. 클러스터가 성공적으로 재개되면 성공 메시지를 출력하고, 그렇지 않으면 발생하는 모든 오류를 잡아서 출력합니다.\n\n## 비디오 자습서\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위 코드가 어떻게 실행되는지 확인하려면 이 비디오 튜토리얼을 확인해보세요:\n\n동일한 코드에 대한 링크 📎.\n\n# 2. 클러스터 일시 중지 ⏸️\n\n다음으로 클러스터를 일시 중지하는 방법에 대해 배워봅시다. 여기 코드 설명이 있습니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Redshift Cluster Pause](/TIL/assets/img/2024-07-07-AutomatingRedshiftwithPythonandBoto3APlaybookforEfficientandCost-EffectiveClusters_3.png)\n\nThe code snippet creates a Redshift client using Boto3 to pause ⏸️ a Redshift cluster identified by cluster_identifier. If the cluster pauses successfully, it prints a success message; otherwise, it catches and prints any errors that occur during the process.\n\n## Video Tutorial\n\nCheck out this video tutorial to see the execution of the code in action:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 가이드를 따르면 Redshift 클러스터를 자동으로 다시 작동하고 일시 중지하는 프로세스를 효율적으로 관리할 수 있습니다. 이는 비용을 절약하고 클러스터가 필요할 때만 작동되도록 보장하는 데 도움이 될 수 있습니다.\n\n다음 섹션에서는 모든 클러스터를 일시 중지하는 방법을 보여주는 작은 프로젝트를 살펴볼 것입니다. 기대해 주세요! 🚀\n\n# 모든 Redshift 클러스터를 한 번에 일시 중지하기 ⏸️📊\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 섹션에서는 Python과 Boto3를 사용하여 모든 실행 중인 Redshift 클러스터를 자동으로 일시 중지하는 멋진 프로젝트를 살펴보겠습니다. 이 자동화는 비용을 절약하고 클러스터 관리를 간편화할 수 있습니다.\n\n![이미지](/TIL/assets/img/2024-07-07-AutomatingRedshiftwithPythonandBoto3APlaybookforEfficientandCost-EffectiveClusters_4.png)\n\n이 Python 스크립트는 Boto3를 사용하여 Amazon Redshift와 상호 작용하여 모든 클러스터를 설명하고 상태를 확인하고 사용 가능한 클러스터를 일시 중지합니다. 그렇게 하기 위해 Redshift 클라이언트의 describe_clusters 및 pause_cluster 함수를 활용하여 클러스터 상태와 일시 중지 시 클러스터 상태 및 성공 메시지를 출력합니다.\n\n## 비디오 자습서\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위 코드 실행을 보고 싶다면 이 비디오 튜토리얼을 확인해보세요:\n\n동일한 코드 링크 📎.\n\n# 실제 활용 사례 시나리오 ⏰🔄\n\n모든 클러스터 일시 중지 및 모든 클러스터 재개는 다양한 시나리오에서 매우 유익할 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 예정된 다운타임: AWS Lambda와 이벤트 트리거를 사용하여 클러스터가 사용되지 않을 때 오후 6시에 모든 클러스터를 일시 중지하는 스크립트를 자동으로 예약 할 수 있습니다.\n- 비용 관리: 필요한 시간인 아침 9시 전에 스크립트를 예약하여 모든 클러스터를 자동으로 다시 시작하면 효율적인 클러스터 이용과 비용 관리가 보장됩니다.\n\n파이썬과 Boto3를 사용하여 모든 Amazon Redshift 클러스터의 일시 중지를 자동화 함으로써 효율적인 비용 관리와 운영 제어를 보장할 수 있습니다. 🌟\n\n이 섹션에서는 파이썬과 Boto3를 사용하여 모든 Amazon Redshift 클러스터의 일시 중지를 자동화하여 비용 관리와 운영 제어를 효율적으로 보장했습니다. 다음으로 클러스터를 효과적으로 관리하는 몇 가지 기술을 탐색해 보겠습니다.\n\n# 전문가처럼 클러스터 관리하기 🔍\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 섹션에서는 Python 및 Boto3를 사용하여 Amazon Redshift 클러스터를 관리하는 내용을 살펴보겠습니다. 모든 클러스터를 볼 수 있는 방법과 특정 클러스터를 삭제하는 방법을 다룰 것입니다.\n\n# 1. 모든 클러스터 보기\n\n먼저, Redshift 클러스터를 모두 검색하고 표시해 봅시다:\n\n![image](/TIL/assets/img/2024-07-07-AutomatingRedshiftwithPythonandBoto3APlaybookforEfficientandCost-EffectiveClusters_5.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 코드는 Boto3를 사용하여 지정된 지역(us-east-1)의 AWS Redshift 서비스에 연결하고 모든 클러스터 식별자의 목록을 검색합니다. 이 목록은 당신의 필요에 따라 필터링 및 정렬과 같은 추가 작업에 유용할 수 있습니다.\n\n## 비디오 자습서\n\n코드 실행 과정을 확인하려면 이 비디오 자습서를 확인해보세요:\n\n동일한 코드에 대한 링크 📎.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 실제 활용:\n\n클러스터 필터링 및 정렬: 정규 표현식 (regex)을 사용하여 특정 기준에 따라 클러스터를 필터링하는 코드를 수정할 수 있습니다. 이를 통해 유지 관리 또는 삭제와 같은 특정 작업을 위해 클러스터를 대상으로할 수 있습니다.\n\n# 클러스터 삭제\n\n이제 Redshift 클러스터를 프로그래밍 방식으로 삭제하는 방법을 살펴보겠습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/TIL/assets/img/2024-07-07-AutomatingRedshiftwithPythonandBoto3APlaybookforEfficientandCost-EffectiveClusters_6.png)\n\n이 코드 조각은 Boto3를 사용하여 지정된 Redshift 클러스터 (myredshiftcluster)를 최종 스냅샷을 찍지 않고 삭제하는 방법을 보여줍니다. 삭제 프로세스의 현재 상태를 출력합니다.\n\n## 비디오 튜토리얼\n\n실제 코드 실행을 확인하려면 이 비디오 튜토리얼을 확인하세요:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n동일한 코드에 대한 링크 📎\n\n이제 클러스터를 관리하는 데 sol하게 이해했으니, Redshift 관리의 다음 중요한 측면인 스냅샷으로 넘어가 봅시다.\n\n# 스냅샷: 데이터의 베스트 프렌드 📸\n\n이 섹션에서는 Redshift 스냅샷의 세계에 대해 알아볼 것입니다. 데이터 백업 및 복구를위한 중요한 기능인 스냅샷을 다룰 것입니다. 포함될 내용은 다음과 같습니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- **스냅샷이란 무엇인가요?**\n- **스냅샷 목록을 위한 코드 Walkthrough**\n- **클러스터를 위한 스냅샷 생성**\n- **스냅샷 생성 및 삭제에 대한 코드 Walkthrough**\n\n**# 스냅샷이란 무엇인가요?**\n\nAmazon Redshift에서 스냅샷은 클러스터의 데이터와 메타데이터를 캡처하는 클러스터의 특정 시점 백업입니다. 스냅샷은 자동화되거나 수동으로 이루어질 수 있으며, 스냅샷이 촬영된 시점의 상태로 클러스터를 복원할 수 있도록 합니다. 이는 데이터 복구, 재해 복구 및 데이터 무결성 유지를 위해 중요합니다.\n\n**# 스냅샷 목록을 위한 코드 Walkthrough**\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nRedshift 스냅샷을 관리하기 위해, 특정 클러스터에 대한 모든 스냅샷을 나열하는 것부터 시작해보세요.\n\n![스냅샷](/TIL/assets/img/2024-07-07-AutomatingRedshiftwithPythonandBoto3APlaybookforEfficientandCost-EffectiveClusters_7.png)\n\n이 코드는 지정된 Redshift 클러스터의 스냅샷 목록을 가져와 표시합니다. Redshift 서비스와 상호 작용하기 위해 Boto3를 사용하여 스냅샷을 효율적으로 모니터링하고 관리할 수 있습니다.\n\n## 비디오 튜토리얼\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n해당 코드 실행 과정을 확인하려면 이 비디오 튜토리얼을 확인해보세요:\n\n해당 코드 링크는 여기 있습니다 📎.\n\n# 클러스터에 대한 스냅샷 만들기\n\n스냅샷을 만들면 클러스터의 현재 상태를 백업하여 필요 시 나중에 복원할 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/TIL/assets/img/2024-07-07-AutomatingRedshiftwithPythonandBoto3APlaybookforEfficientandCost-EffectiveClusters_8.png)\n\n이 코드는 지정된 Redshift 클러스터의 수동 스냅샷을 생성하고 스냅샷 상태가 'available'일 때까지 기다립니다. 이렇게 함으로써 스냅샷 생성 프로세스가 완료된 후 추가 작업을 진행할 수 있습니다.\n\n## 비디오 튜토리얼\n\n실행 중인 코드를 보려면 이 비디오 튜토리얼을 확인해보세요:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n동일한 코드에 대한 링크를 첨부합니다 📎.\n\n이 섹션에서는 데이터 백업 및 복구를 위해 Amazon Redshift의 스냅샷의 중요성을 탐색했습니다. 우리는 스냅샷이 무엇인지, 스냅샷 목록 및 생성을 위한 코드 안내, 그리고 데이터 무결성 유지에 대한 실제 응용 사례를 강조했습니다.\n\n다음 섹션에서는 효율적인 클러스터 관리에 대한 우리의 학습을 유기적으로 연결하는 실용적인 프로젝트를 살펴볼 것입니다.\n\n# 효율적인 클러스터 관리 스크립트 📝\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 프로젝트는 Redshift 클러스터를 관리하는 포괄적인 스크립트를 보여줍니다. 클러스터를 재개하거나 데이터베이스를 생성하고 스냅샷을 찍거나 클러스터를 일시 중지하는 등의 작업이 가능합니다.\n\n## 코드 안내\n\n아래 이미지는 코드에서 수행되는 주요 단계를 설명합니다:\n\n![워크스루](/TIL/assets/img/2024-07-07-AutomatingRedshiftwithPythonandBoto3APlaybookforEfficientandCost-EffectiveClusters_9.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/TIL/assets/img/2024-07-07-AutomatingRedshiftwithPythonandBoto3APlaybookforEfficientandCost-EffectiveClusters_10.png\" />\n\n이 스크립트는 Amazon Redshift 클러스터를 관리하는 여러 핵심 작업을 자동화합니다. 일시 중지된 클러스터를 다시 시작하고 사용 가능해질 때까지 대기합니다. 클러스터가 준비되면 redshift_connector를 사용하여 클러스터에 연결하고 새 데이터베이스를 만듭니다. 그 후 클러스터의 수동 스냅샷을 만들고 스냅샷이 사용 가능해질 때까지 대기합니다. 마지막으로 스크립트는 비용을 절약하기 위해 클러스터를 일시 중지합니다. 프로세스 전반에 걸쳐 스크립트는 오류 처리를 포함하고 데이터베이스 연결이 올바르게 닫혀 있는지 확인합니다. 이 포괄적인 방법은 효율적이고 자동화된 Redshift 클러스터 관리를 보장합니다.\n\n## 비디오 자습서\n\n실행 중인 코드를 확인하려면 이 비디오 자습서를 확인해보세요:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n링크를 마크다운 형식으로 변경하세요 📎.\n\n# 결론\n\n이 블로그에서는 Python과 Boto3를 사용하여 Amazon Redshift 클러스터를 관리하는 다양한 측면을 다루었습니다. 수동 및 프로그래밍 방식으로 클러스터를 생성하고, 비용 효율성을 위해 클러스터를 일시 중지하고 재개하며, 데이터 백업과 복구를 위해 스냅샷을 활용하는 등 Redshift 작업을 최적화하는 실용적이고 강력한 기술을 탐색했습니다.\n\n제공된 단계와 코드 예제를 따르면 Redshift 클러스터 관리를 자동화하여 최적의 성능과 비용 절감을 보장할 수 있습니다. 효율적인 Redshift 클러스터 관리는 비용을 절약할 뿐만 아니라 데이터 처리 능력을 향상시켜 데이터 작업을 더 견고하고 신뢰할 수 있게 만듭니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n더 많은 고급 기술과 프로젝트가 있는 것을 기대해 주세요. AWS 관리 기술을 더 향상시킬 수 있도록 도와 드리겠습니다. 자동화 작업을 즐기세요! 🚀💼\n\n![Automating Redshift with Python and Boto3](/TIL/assets/img/2024-07-07-AutomatingRedshiftwithPythonandBoto3APlaybookforEfficientandCost-EffectiveClusters_11.png)\n\n## 다음 단계\n\n이제 Redshift 클러스터를 관리하는 탄탄한 기초가 있으므로, 다음과 같은 고급 주제를 탐험해 볼 수 있습니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Redshift 클러스터에 대한 보안 모범 사례를 구현합니다.\n- Redshift를 다른 AWS 서비스와 통합하여 포괄적인 데이터 솔루션을 구축합니다.\n- Redshift 성능 및 쿼리 효율을 최적화합니다.\n\n이러한 개념들을 실험하고 발전시켜 Redshift 자동화 전문가로 성장해보세요. 행운을 빕니다! 💻🌐\n","ogImage":{"url":"/assets/img/2024-07-07-AutomatingRedshiftwithPythonandBoto3APlaybookforEfficientandCost-EffectiveClusters_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-AutomatingRedshiftwithPythonandBoto3APlaybookforEfficientandCost-EffectiveClusters_0.png","tag":["Tech"],"readingTime":18}],"page":"43","totalPageCount":50,"totalPageGroupCount":3,"lastPageGroup":10,"currentPageGroup":2},"__N_SSG":true}