{"pageProps":{"post":{"title":"파이썬 동시성 완벽 정복을 위한 12가지 필수 팁","description":"","date":"2024-07-13 19:35","slug":"2024-07-13-12EssentialTipsforMasteringPythonConcurrency","content":"\n\n<img src=\"/TIL/assets/img/2024-07-13-12EssentialTipsforMasteringPythonConcurrency_0.png\" />\n\n## 파이썬 동시성이 프로그래밍 병목 현상을 해결하는 방법\n\n오늘은 파이썬에서 동시성을 탐색할 거에요 — 프로그램을 더 빠르게 실행할 수 있는 마법 같은 열쇠!\n\n걱정하지 마세요, 초심자라도 동시성을 마스터할 수 있도록 단계별로 안내할게요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 1. 스레딩 소개: 멀티 스레딩 기초\n\n카페에서 이메일 처리, 채팅 및 코딩을 동시에 하는 상황을 상상해보세요 — 그것이 멀티 스레딩입니다.\n\nPython에서는 `threading` 모듈이 여러분의 유용한 도우미입니다.\n\n```python\nimport threading\nimport time\n\ndef say_hello(name):\n    print(f\"Hello, {name}!\")\n    time.sleep(2)  # 시간이 오래 걸리는 작업을 모방\n\n# 스레드 생성\nthread1 = threading.Thread(target=say_hello, args=(\"World\",))\nthread2 = threading.Thread(target=say_hello, args=(\"Python\",))\n\n# 스레드 시작\nthread1.start()\nthread2.start()\n\n# 모든 스레드가 완료될 때까지 대기\nthread1.join()\nthread2.join()\n\nprint(\"모든 작업 완료.\")\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 코드는 서로 다른 인사말을 인쇄하는 두 개의 스레드를 만들고, 그들이 완료될 때까지 기다립니다. `join()`을 기억하세요, 스레드가 완료될 때까지 기다립니다.\n\n# 2. 동시성 함정: 전역 인터프리터 잠금(GIL)\n\n멀티스레딩을 논의할 때, 파이썬의 GIL에 대해 언급해야 합니다. CPU 코어가 파이썬 바이트코드를 실행하는 것에 차례를 가져가도록 하는 것인데, 이는 CPU 바운드 작업에 대해 멀티스레딩이 항상 더 빠르지는 않다는 의미입니다. 하지만 걱정하지 마세요, I/O 바운드 작업의 경우에는 멀티스레딩이 여전히 유용합니다!\n\n# 3. 병렬 처리: GIL 우회\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다중 코어 CPU를 최대한 활용하려면 `multiprocessing` 모듈을 사용하세요. 이 모듈은 각 프로세스에 대해 별도의 Python 해석기를 생성하여 GIL을 우회합니다.\n\n```python\nfrom multiprocessing import Process\nimport time\n\ndef worker(num):\n    print(f'Worker: {num}')\n    time.sleep(2)\n\nif __name__ == '__main__':\n    processes = []\n    for i in range(4):\n        p = Process(target=worker, args=(i,))\n        processes.append(p)\n        p.start()\n```\n\n각 `Process`는 GIL과 독립적으로 실행됩니다.\n\n# 4. 동시성이 모든 문제를 해결해 주지는 않습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n동시성은 데이터 동기화 문제와 함께 복잡할 수 있습니다. 자원 충돌을 피하기 위해 잠금을 사용하면 마치 주방에서 하나의 전자 레인지를 공유하는 것처럼 자원 충돌을 피할 수 있습니다.\n\n```python\nfrom threading import Lock\n\nlock = Lock()\n\ndef safe_print(number):\n    with lock:\n        print(f'Safe print: {number}')\n\nsafe_print(1)\nsafe_print(2)\n```\n\n`with`를 사용하면 잠금을 자동으로 관리하여 안전을 보장합니다.\n\n# 5. 큐의 지혜: `queue.Queue`\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n편리하게 생각해보면 공장 조립 라인과 비슷한데, `Queue`는 스레드/프로세스 간 데이터 교환을 조율하는 조정자입니다.\n\n```python\nfrom queue import Queue\nfrom threading import Thread\n\ndef producer(queue):\n    queue.put('Product')\n\ndef consumer(queue):\n    print(queue.get())\n\nq = Queue()\nproducer_thread = Thread(target=producer, args=(q,))\nconsumer_thread = Thread(target=consumer, args=(q,))\n\nproducer_thread.start()\nconsumer_thread.start()\n\nproducer_thread.join()\nconsumer_thread.join()\n```\n\n큐는 혼란을 방지하고 안전한 데이터 전송을 보장합니다.\n\n# 6. 비동기의 마법: `asyncio`\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n기다리기 싫어요? `asyncio`가 `async`/`await`으로 비동기 프로그래밍 세계로 안내합니다. 당신의 코드를 날아다니게 만들어줍니다.\n\n```python\nimport asyncio\n\nasync def hello(i):\n    print(f'Hello {i}')\n    await asyncio.sleep(1)  # 비동기 대기\n\nasync def main():\n    tasks = [hello(i) for i in range(3)]\n    await asyncio.gather(*tasks)\n\n# Python 3.7+\nasyncio.run(main())\n```\n\n비동기 대기를 통해 다른 작업을 수행하면서 대기할 수 있어 효율성을 향상시킬 수 있어요.\n\n# 7. 비동기 프로그래밍에 대한 오해\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n`asyncio`는 강력하지만 하드웨어와 직접 상호 작용하는 저수준 API와 같은 모든 함수를 비동기적으로 실행할 수 없습니다. 올바른 방법을 선택하고 강제로 async를 적용하지 마세요.\n\n# 8. `concurrent.futures`: 간편한 Future 처리\n\n간단한 동시 작업의 경우, 동기적 또는 비동기적으로, `concurrent.futures`를 활용하세요.\n\n```js\nfrom concurrent.futures import ThreadPoolExecutor\n\ndef worker(n):\n    return n * n\n\nwith ThreadPoolExecutor() as executor:\n    results = executor.map(worker, range(5))\n    print(list(results))  # 제곱 출력\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n ThreadPoolExecutor를 사용하여 스레드 풀을 쉽게 관리할 수 있습니다. 이를 통해 작업 실행이 음식 주문하는 것만큼 간단해집니다.\n\n# 9. 오류 처리의 기술: 예외 gracefully 처리하기\n\n동시성에서 오류 처리는 중요합니다. 코드를 보호하기 위해 `try-except`를 사용하여 한 작업의 실패가 전체 프로그램에 영향을 미치지 않도록합니다.\n\n```js\ntry:\n    # 실패할 수도 있는 동시성 코드\nexcept Exception as e:\n    print(f\"예외를 잡았습니다: {e}\")\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n침착하게 유지하고 오류를 세련되게 처리하여 견고한 프로그램을 만들어봐요.\n\n# 10. 리소스 관리: 컨텍스트 관리자와 `with`\n\n`with` 문은 파일, 락과 같은 리소스가 올바르게 해제되어 경쟁 상태에서 리소스 누출을 방지해줘요.\n\n```js\nwith Lock():\n    # 공유 리소스를 안전하게 조작해요\n```  \n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n표 태그를 마크다운 형식으로 변경해 드릴게요.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n실제 예시를 통해 동시에 이미지를 다운로드하여 동시성의 힘을 느껴보는 연습을 해보세요.\n\n```python\nimport os\nimport requests\nfrom threading import Thread\n\ndef download_image(url, filename):\n    response = requests.get(url)\n    with open(filename, 'wb') as f:\n        f.write(response.content)\n    print(f'{filename} 다운로드 완료.')\n\nurls = ['img_url1', 'img_url2']  # 예시 URL\nthreads = []\n\nfor url in urls:\n    t = Thread(target=download_image, args=(url, os.path.basename(url)))\n    threads.append(t)\n    t.start()\n\nfor t in threads:\n    t.join()\n\nprint('모든 이미지 다운로드 완료.')\n```\n\n동시 다운로드는 프로세스를 크게 가속시킵니다!\n\n이 12가지 실용적인 팁으로 파이썬 동시성 능력을 향상시켰습니다. 진실을 확인하기 위해 연습해보세요. 프로그램을 실행시켜 빠르게 동작시켜 보세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nSubstack에서 최신 AI 이야기를 따라가며 연락을 유지해보세요. 함께 AI의 미래를 함께 만들어요!\n\nSubstack에서 Python 이야기를 최신 상태로 유지하기 위해 연락을 유지해보세요. 함께 Python을 배워봐요!","ogImage":{"url":"/TIL/assets/img/2024-07-13-12EssentialTipsforMasteringPythonConcurrency_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-12EssentialTipsforMasteringPythonConcurrency_0.png","tag":["Tech"],"readingTime":8},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<img src=\"/TIL/assets/img/2024-07-13-12EssentialTipsforMasteringPythonConcurrency_0.png\">\n<h2>파이썬 동시성이 프로그래밍 병목 현상을 해결하는 방법</h2>\n<p>오늘은 파이썬에서 동시성을 탐색할 거에요 — 프로그램을 더 빠르게 실행할 수 있는 마법 같은 열쇠!</p>\n<p>걱정하지 마세요, 초심자라도 동시성을 마스터할 수 있도록 단계별로 안내할게요.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h1>1. 스레딩 소개: 멀티 스레딩 기초</h1>\n<p>카페에서 이메일 처리, 채팅 및 코딩을 동시에 하는 상황을 상상해보세요 — 그것이 멀티 스레딩입니다.</p>\n<p>Python에서는 <code>threading</code> 모듈이 여러분의 유용한 도우미입니다.</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">import</span> threading\n<span class=\"hljs-keyword\">import</span> time\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">say_hello</span>(<span class=\"hljs-params\">name</span>):\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f\"Hello, <span class=\"hljs-subst\">{name}</span>!\"</span>)\n    time.sleep(<span class=\"hljs-number\">2</span>)  <span class=\"hljs-comment\"># 시간이 오래 걸리는 작업을 모방</span>\n\n<span class=\"hljs-comment\"># 스레드 생성</span>\nthread1 = threading.Thread(target=say_hello, args=(<span class=\"hljs-string\">\"World\"</span>,))\nthread2 = threading.Thread(target=say_hello, args=(<span class=\"hljs-string\">\"Python\"</span>,))\n\n<span class=\"hljs-comment\"># 스레드 시작</span>\nthread1.start()\nthread2.start()\n\n<span class=\"hljs-comment\"># 모든 스레드가 완료될 때까지 대기</span>\nthread1.join()\nthread2.join()\n\n<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"모든 작업 완료.\"</span>)\n</code></pre>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>이 코드는 서로 다른 인사말을 인쇄하는 두 개의 스레드를 만들고, 그들이 완료될 때까지 기다립니다. <code>join()</code>을 기억하세요, 스레드가 완료될 때까지 기다립니다.</p>\n<h1>2. 동시성 함정: 전역 인터프리터 잠금(GIL)</h1>\n<p>멀티스레딩을 논의할 때, 파이썬의 GIL에 대해 언급해야 합니다. CPU 코어가 파이썬 바이트코드를 실행하는 것에 차례를 가져가도록 하는 것인데, 이는 CPU 바운드 작업에 대해 멀티스레딩이 항상 더 빠르지는 않다는 의미입니다. 하지만 걱정하지 마세요, I/O 바운드 작업의 경우에는 멀티스레딩이 여전히 유용합니다!</p>\n<h1>3. 병렬 처리: GIL 우회</h1>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>다중 코어 CPU를 최대한 활용하려면 <code>multiprocessing</code> 모듈을 사용하세요. 이 모듈은 각 프로세스에 대해 별도의 Python 해석기를 생성하여 GIL을 우회합니다.</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">from</span> multiprocessing <span class=\"hljs-keyword\">import</span> Process\n<span class=\"hljs-keyword\">import</span> time\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">worker</span>(<span class=\"hljs-params\">num</span>):\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f'Worker: <span class=\"hljs-subst\">{num}</span>'</span>)\n    time.sleep(<span class=\"hljs-number\">2</span>)\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    processes = []\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">4</span>):\n        p = Process(target=worker, args=(i,))\n        processes.append(p)\n        p.start()\n</code></pre>\n<p>각 <code>Process</code>는 GIL과 독립적으로 실행됩니다.</p>\n<h1>4. 동시성이 모든 문제를 해결해 주지는 않습니다.</h1>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>동시성은 데이터 동기화 문제와 함께 복잡할 수 있습니다. 자원 충돌을 피하기 위해 잠금을 사용하면 마치 주방에서 하나의 전자 레인지를 공유하는 것처럼 자원 충돌을 피할 수 있습니다.</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">from</span> threading <span class=\"hljs-keyword\">import</span> Lock\n\nlock = Lock()\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">safe_print</span>(<span class=\"hljs-params\">number</span>):\n    <span class=\"hljs-keyword\">with</span> lock:\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f'Safe print: <span class=\"hljs-subst\">{number}</span>'</span>)\n\nsafe_print(<span class=\"hljs-number\">1</span>)\nsafe_print(<span class=\"hljs-number\">2</span>)\n</code></pre>\n<p><code>with</code>를 사용하면 잠금을 자동으로 관리하여 안전을 보장합니다.</p>\n<h1>5. 큐의 지혜: <code>queue.Queue</code></h1>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>편리하게 생각해보면 공장 조립 라인과 비슷한데, <code>Queue</code>는 스레드/프로세스 간 데이터 교환을 조율하는 조정자입니다.</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">from</span> queue <span class=\"hljs-keyword\">import</span> Queue\n<span class=\"hljs-keyword\">from</span> threading <span class=\"hljs-keyword\">import</span> Thread\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">producer</span>(<span class=\"hljs-params\">queue</span>):\n    queue.put(<span class=\"hljs-string\">'Product'</span>)\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">consumer</span>(<span class=\"hljs-params\">queue</span>):\n    <span class=\"hljs-built_in\">print</span>(queue.get())\n\nq = Queue()\nproducer_thread = Thread(target=producer, args=(q,))\nconsumer_thread = Thread(target=consumer, args=(q,))\n\nproducer_thread.start()\nconsumer_thread.start()\n\nproducer_thread.join()\nconsumer_thread.join()\n</code></pre>\n<p>큐는 혼란을 방지하고 안전한 데이터 전송을 보장합니다.</p>\n<h1>6. 비동기의 마법: <code>asyncio</code></h1>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>기다리기 싫어요? <code>asyncio</code>가 <code>async</code>/<code>await</code>으로 비동기 프로그래밍 세계로 안내합니다. 당신의 코드를 날아다니게 만들어줍니다.</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">import</span> asyncio\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">hello</span>(<span class=\"hljs-params\">i</span>):\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f'Hello <span class=\"hljs-subst\">{i}</span>'</span>)\n    <span class=\"hljs-keyword\">await</span> asyncio.sleep(<span class=\"hljs-number\">1</span>)  <span class=\"hljs-comment\"># 비동기 대기</span>\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">main</span>():\n    tasks = [hello(i) <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">3</span>)]\n    <span class=\"hljs-keyword\">await</span> asyncio.gather(*tasks)\n\n<span class=\"hljs-comment\"># Python 3.7+</span>\nasyncio.run(main())\n</code></pre>\n<p>비동기 대기를 통해 다른 작업을 수행하면서 대기할 수 있어 효율성을 향상시킬 수 있어요.</p>\n<h1>7. 비동기 프로그래밍에 대한 오해</h1>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p><code>asyncio</code>는 강력하지만 하드웨어와 직접 상호 작용하는 저수준 API와 같은 모든 함수를 비동기적으로 실행할 수 없습니다. 올바른 방법을 선택하고 강제로 async를 적용하지 마세요.</p>\n<h1>8. <code>concurrent.futures</code>: 간편한 Future 처리</h1>\n<p>간단한 동시 작업의 경우, 동기적 또는 비동기적으로, <code>concurrent.futures</code>를 활용하세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">from</span> concurrent.<span class=\"hljs-property\">futures</span> <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">ThreadPoolExecutor</span>\n\ndef <span class=\"hljs-title function_\">worker</span>(n):\n    <span class=\"hljs-keyword\">return</span> n * n\n\n<span class=\"hljs-keyword\">with</span> <span class=\"hljs-title class_\">ThreadPoolExecutor</span>() <span class=\"hljs-keyword\">as</span> <span class=\"hljs-attr\">executor</span>:\n    results = executor.<span class=\"hljs-title function_\">map</span>(worker, <span class=\"hljs-title function_\">range</span>(<span class=\"hljs-number\">5</span>))\n    <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-title function_\">list</span>(results))  # 제곱 출력\n</code></pre>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>ThreadPoolExecutor를 사용하여 스레드 풀을 쉽게 관리할 수 있습니다. 이를 통해 작업 실행이 음식 주문하는 것만큼 간단해집니다.</p>\n<h1>9. 오류 처리의 기술: 예외 gracefully 처리하기</h1>\n<p>동시성에서 오류 처리는 중요합니다. 코드를 보호하기 위해 <code>try-except</code>를 사용하여 한 작업의 실패가 전체 프로그램에 영향을 미치지 않도록합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-attr\">try</span>:\n    # 실패할 수도 있는 동시성 코드\nexcept <span class=\"hljs-title class_\">Exception</span> <span class=\"hljs-keyword\">as</span> <span class=\"hljs-attr\">e</span>:\n    <span class=\"hljs-title function_\">print</span>(f<span class=\"hljs-string\">\"예외를 잡았습니다: {e}\"</span>)\n</code></pre>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>침착하게 유지하고 오류를 세련되게 처리하여 견고한 프로그램을 만들어봐요.</p>\n<h1>10. 리소스 관리: 컨텍스트 관리자와 <code>with</code></h1>\n<p><code>with</code> 문은 파일, 락과 같은 리소스가 올바르게 해제되어 경쟁 상태에서 리소스 누출을 방지해줘요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">with</span> <span class=\"hljs-title class_\">Lock</span>():\n    # 공유 리소스를 안전하게 조작해요\n</code></pre>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>표 태그를 마크다운 형식으로 변경해 드릴게요.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>실제 예시를 통해 동시에 이미지를 다운로드하여 동시성의 힘을 느껴보는 연습을 해보세요.</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">import</span> os\n<span class=\"hljs-keyword\">import</span> requests\n<span class=\"hljs-keyword\">from</span> threading <span class=\"hljs-keyword\">import</span> Thread\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">download_image</span>(<span class=\"hljs-params\">url, filename</span>):\n    response = requests.get(url)\n    <span class=\"hljs-keyword\">with</span> <span class=\"hljs-built_in\">open</span>(filename, <span class=\"hljs-string\">'wb'</span>) <span class=\"hljs-keyword\">as</span> f:\n        f.write(response.content)\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f'<span class=\"hljs-subst\">{filename}</span> 다운로드 완료.'</span>)\n\nurls = [<span class=\"hljs-string\">'img_url1'</span>, <span class=\"hljs-string\">'img_url2'</span>]  <span class=\"hljs-comment\"># 예시 URL</span>\nthreads = []\n\n<span class=\"hljs-keyword\">for</span> url <span class=\"hljs-keyword\">in</span> urls:\n    t = Thread(target=download_image, args=(url, os.path.basename(url)))\n    threads.append(t)\n    t.start()\n\n<span class=\"hljs-keyword\">for</span> t <span class=\"hljs-keyword\">in</span> threads:\n    t.join()\n\n<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">'모든 이미지 다운로드 완료.'</span>)\n</code></pre>\n<p>동시 다운로드는 프로세스를 크게 가속시킵니다!</p>\n<p>이 12가지 실용적인 팁으로 파이썬 동시성 능력을 향상시켰습니다. 진실을 확인하기 위해 연습해보세요. 프로그램을 실행시켜 빠르게 동작시켜 보세요!</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>Substack에서 최신 AI 이야기를 따라가며 연락을 유지해보세요. 함께 AI의 미래를 함께 만들어요!</p>\n<p>Substack에서 Python 이야기를 최신 상태로 유지하기 위해 연락을 유지해보세요. 함께 Python을 배워봐요!</p>\n</body>\n</html>\n"},"__N_SSG":true}