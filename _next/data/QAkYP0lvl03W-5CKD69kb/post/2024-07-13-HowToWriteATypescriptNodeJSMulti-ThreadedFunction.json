{"pageProps":{"post":{"title":"TypeScript 네트워크 서버 구축법 Nodejs 멀티스레드 함수 작성하기","description":"","date":"2024-07-13 20:38","slug":"2024-07-13-HowToWriteATypescriptNodeJSMulti-ThreadedFunction","content":"\n\n\n![링크](/TIL/assets/img/2024-07-13-HowToWriteATypescriptNodeJSMulti-ThreadedFunction_0.png)\n\nTypeScript과 Node.js는 단일 스레드 및 이벤트 기반 모드에서 작동합니다. 그러나 Node.js에는 특정 시나리오를 위해 멀티 스레딩을 가능하게 하는 Worker Threads 모듈이 제공됩니다. Worker Threads 모듈을 사용하면 TypeScript 코드를 병렬로 실행하여 필요할 때 여러 스레드를 활용할 수 있습니다.\n\n# Node.js에서 멀티 스레딩\n\n단일 스레드 형식 — 기본적으로 Node.js는 TypeScript 코드를 실행하는 데 단일 스레드를 사용합니다. 이 설계는 여러 스레드를 관리하는 복잡성을 피하므로 비동기 작업을 간단하게 처리할 수 있습니다.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n워커 스레드 모듈 - 워커 스레드 모듈은 Node.js의 기능으로, 개발자가 메인 스레드와 별도로 추가 스레드를 생성할 수 있게 합니다. 이러한 워커 스레드는 TypeScript 코드를 독립적으로 실행하여 작업을 병렬로 처리할 수 있는 방법을 제공합니다.\n\n멀티 스레딩의 사용 사례 - 멀티 스레딩은 CPU 집중형 계산이나 병렬 비동기 작업과 같이 특정 작업을 분할하고 동시에 실행할 수 있는 시나리오에서 유용합니다. 이를 통해 여러 스레드의 처리 능력을 활용하여 응용 프로그램의 전반적인 성능을 향상시킬 수 있습니다.\n\n예제로 넘어가기 전에.... \n\n# 멀티 스레딩에 대한 추가 고려 사항\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n많은 이유로 멀티스레딩을 피하고 Node.js의 싱글 스레드 특성을 활용하는 것이 좋습니다. 전진하기 전에 고려해야 할 몇 가지 중요한 부분이 있습니다.\n\n스레드 관리 오버헤드: 멀티스레딩은 특정 시나리오에서 성능을 향상시킬 수 있지만, 스레드 관리와 관련된 오버헤드도 동반됩니다. 개발자들은 해당 상황에서 멀티스레딩의 이점이 해당 사용 사례에서의 오버헤드를 상회하는지 신중히 검토해야 합니다.\n\n동시성과 동기화: 여러 스레드로 작업할 때, 개발자들은 동시성과 동기화와 관련된 문제들을 다뤄야 합니다. 이는 공유 리소스를 관리하고 경쟁 조건을 방지하며 스레드 간 데이터 일관성을 보장하는 것을 포함합니다.\n\n확장성: 멀티스레딩은 멀티 코어 프로세서에서 사용 가능한 리소스를 효율적으로 활용할 수 있도록 해 확장성을 향상시킬 수 있습니다. 그러나 멀티스레드 애플리케이션을 확장하기 위해서는 부하 분산 및 리소스 경합과 같은 요소들을 신중히 고려하여 최적의 성능을 달성해야 합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n디버깅 복잡성: 멀티스레드 응용 프로그램을 디버깅하는 것은 단일 스레드 응용 프로그램보다 얽힌 스레드 상호작용과 잠재적 동시성 문제로 인해 더 도전적일 수 있습니다. 개발자는 쓰레딩 관련 문제를 효과적으로 진단하고 해결하기 위해 전문적인 디버깅 도구와 기술을 사용해야 할 수도 있습니다.\n\n자원 관리: 멀티스레드 응용 프로그램은 단일 스레드 응용 프로그램보다 더 많은 시스템 자원(예: 메모리 및 CPU)을 소비할 수 있습니다. 개발자는 성능 저하와 잠재적 병목 현상을 피하기 위해 자원 사용을 주의 깊게 관리해야 합니다.\n\n잠재적 함정: 멀티스레드로 인해 성능 이점을 얻을 수 있지만, 데드락, 라이브락 및 스레드 기아와 같은 잠재적 함정이 소개될 수도 있습니다. 개발자는 이러한 개념을 이해하고 응용 프로그램 신뢰도와 성능에 미치는 영향을 완화하기 위해 최선의 방법을 사용해야 합니다.\n\n다음은 Worker Threads를 사용한 TypeScript 예시를 제공하겠습니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```typescript\nimport { Worker, isMainThread, parentPort } from 'worker_threads';\n\nfunction runWorkerThread() {\n  if (isMainThread) {\n    // 이것은 메인 스레드입니다\n\n    // 새로운 워커 스레드를 생성합니다\n    const worker = new Worker(__filename);\n\n    // 워커 스레드로부터 메시지를 수신합니다\n    worker.on('message', (result: any) => {\n      console.log('워커로부터 결과:', result);\n    });\n\n    // 워커 스레드로 데이터를 보냅니다\n    worker.postMessage({ data: '메인 스레드로부터 안녕하세요!' });\n  } else {\n    // 이것은 워커 스레드입니다\n\n    // 메인 스레드로부터 메시지를 수신합니다\n    parentPort?.on('message', (message: any) => {\n      console.log('메인 스레드로부터 메시지:', message);\n\n      // 일부 무거운 계산을 수행합니다\n      const result = performHeavyComputation();\n\n      // 결과를 다시 메인 스레드로 보냅니다\n      parentPort?.postMessage(result);\n\n      // 워커 스레드를 종료합니다\n      parentPort?.close();\n    });\n\n    function performHeavyComputation() {\n      // 무거운 계산을 시뮬레이션합니다\n      let result = 0;\n      for (let i = 0; i < 1e9; i++) {\n        result += i;\n      }\n      return result;\n    }\n  }\n}\n\n// 워커 스레드 실행을 위해 함수를 호출합니다\nrunWorkerThread();\r\n```\n\n이 예시는 메인 스레드와 워커 스레드로 구성된 멀티 스레드 설정을 보여줍니다. 무거운 계산은 워커 스레드에서 수행되고, 그 결과가 메인 스레드로 보내집니다.\n\n워커 스레드를 생성하고 관리하는 로직은 runWorkerThread 함수 내에 캡슐화되어 있습니다. 워커 스레드를 시작하려면 이 함수를 필요할 때 호출할 수 있습니다.\n\n본 내용을 즐기셨고 이러한 노력을 지원하고 싶으시다면 다음 링크를 방문해주세요: [https://ko-fi.com/jacobmacinnis](https://ko-fi.com/jacobmacinnis)\n","ogImage":{"url":"/TIL/assets/img/2024-07-13-HowToWriteATypescriptNodeJSMulti-ThreadedFunction_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-HowToWriteATypescriptNodeJSMulti-ThreadedFunction_0.png","tag":["Tech"],"readingTime":5},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/TIL/assets/img/2024-07-13-HowToWriteATypescriptNodeJSMulti-ThreadedFunction_0.png\" alt=\"링크\"></p>\n<p>TypeScript과 Node.js는 단일 스레드 및 이벤트 기반 모드에서 작동합니다. 그러나 Node.js에는 특정 시나리오를 위해 멀티 스레딩을 가능하게 하는 Worker Threads 모듈이 제공됩니다. Worker Threads 모듈을 사용하면 TypeScript 코드를 병렬로 실행하여 필요할 때 여러 스레드를 활용할 수 있습니다.</p>\n<h1>Node.js에서 멀티 스레딩</h1>\n<p>단일 스레드 형식 — 기본적으로 Node.js는 TypeScript 코드를 실행하는 데 단일 스레드를 사용합니다. 이 설계는 여러 스레드를 관리하는 복잡성을 피하므로 비동기 작업을 간단하게 처리할 수 있습니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>워커 스레드 모듈 - 워커 스레드 모듈은 Node.js의 기능으로, 개발자가 메인 스레드와 별도로 추가 스레드를 생성할 수 있게 합니다. 이러한 워커 스레드는 TypeScript 코드를 독립적으로 실행하여 작업을 병렬로 처리할 수 있는 방법을 제공합니다.</p>\n<p>멀티 스레딩의 사용 사례 - 멀티 스레딩은 CPU 집중형 계산이나 병렬 비동기 작업과 같이 특정 작업을 분할하고 동시에 실행할 수 있는 시나리오에서 유용합니다. 이를 통해 여러 스레드의 처리 능력을 활용하여 응용 프로그램의 전반적인 성능을 향상시킬 수 있습니다.</p>\n<p>예제로 넘어가기 전에....</p>\n<h1>멀티 스레딩에 대한 추가 고려 사항</h1>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>많은 이유로 멀티스레딩을 피하고 Node.js의 싱글 스레드 특성을 활용하는 것이 좋습니다. 전진하기 전에 고려해야 할 몇 가지 중요한 부분이 있습니다.</p>\n<p>스레드 관리 오버헤드: 멀티스레딩은 특정 시나리오에서 성능을 향상시킬 수 있지만, 스레드 관리와 관련된 오버헤드도 동반됩니다. 개발자들은 해당 상황에서 멀티스레딩의 이점이 해당 사용 사례에서의 오버헤드를 상회하는지 신중히 검토해야 합니다.</p>\n<p>동시성과 동기화: 여러 스레드로 작업할 때, 개발자들은 동시성과 동기화와 관련된 문제들을 다뤄야 합니다. 이는 공유 리소스를 관리하고 경쟁 조건을 방지하며 스레드 간 데이터 일관성을 보장하는 것을 포함합니다.</p>\n<p>확장성: 멀티스레딩은 멀티 코어 프로세서에서 사용 가능한 리소스를 효율적으로 활용할 수 있도록 해 확장성을 향상시킬 수 있습니다. 그러나 멀티스레드 애플리케이션을 확장하기 위해서는 부하 분산 및 리소스 경합과 같은 요소들을 신중히 고려하여 최적의 성능을 달성해야 합니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>디버깅 복잡성: 멀티스레드 응용 프로그램을 디버깅하는 것은 단일 스레드 응용 프로그램보다 얽힌 스레드 상호작용과 잠재적 동시성 문제로 인해 더 도전적일 수 있습니다. 개발자는 쓰레딩 관련 문제를 효과적으로 진단하고 해결하기 위해 전문적인 디버깅 도구와 기술을 사용해야 할 수도 있습니다.</p>\n<p>자원 관리: 멀티스레드 응용 프로그램은 단일 스레드 응용 프로그램보다 더 많은 시스템 자원(예: 메모리 및 CPU)을 소비할 수 있습니다. 개발자는 성능 저하와 잠재적 병목 현상을 피하기 위해 자원 사용을 주의 깊게 관리해야 합니다.</p>\n<p>잠재적 함정: 멀티스레드로 인해 성능 이점을 얻을 수 있지만, 데드락, 라이브락 및 스레드 기아와 같은 잠재적 함정이 소개될 수도 있습니다. 개발자는 이러한 개념을 이해하고 응용 프로그램 신뢰도와 성능에 미치는 영향을 완화하기 위해 최선의 방법을 사용해야 합니다.</p>\n<p>다음은 Worker Threads를 사용한 TypeScript 예시를 제공하겠습니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Worker</span>, isMainThread, parentPort } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'worker_threads'</span>;\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">runWorkerThread</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">if</span> (isMainThread) {\n    <span class=\"hljs-comment\">// 이것은 메인 스레드입니다</span>\n\n    <span class=\"hljs-comment\">// 새로운 워커 스레드를 생성합니다</span>\n    <span class=\"hljs-keyword\">const</span> worker = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Worker</span>(__filename);\n\n    <span class=\"hljs-comment\">// 워커 스레드로부터 메시지를 수신합니다</span>\n    worker.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">'message'</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">result: <span class=\"hljs-built_in\">any</span></span>) =></span> {\n      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'워커로부터 결과:'</span>, result);\n    });\n\n    <span class=\"hljs-comment\">// 워커 스레드로 데이터를 보냅니다</span>\n    worker.<span class=\"hljs-title function_\">postMessage</span>({ <span class=\"hljs-attr\">data</span>: <span class=\"hljs-string\">'메인 스레드로부터 안녕하세요!'</span> });\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 이것은 워커 스레드입니다</span>\n\n    <span class=\"hljs-comment\">// 메인 스레드로부터 메시지를 수신합니다</span>\n    parentPort?.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">'message'</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">message: <span class=\"hljs-built_in\">any</span></span>) =></span> {\n      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'메인 스레드로부터 메시지:'</span>, message);\n\n      <span class=\"hljs-comment\">// 일부 무거운 계산을 수행합니다</span>\n      <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-title function_\">performHeavyComputation</span>();\n\n      <span class=\"hljs-comment\">// 결과를 다시 메인 스레드로 보냅니다</span>\n      parentPort?.<span class=\"hljs-title function_\">postMessage</span>(result);\n\n      <span class=\"hljs-comment\">// 워커 스레드를 종료합니다</span>\n      parentPort?.<span class=\"hljs-title function_\">close</span>();\n    });\n\n    <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">performHeavyComputation</span>(<span class=\"hljs-params\"></span>) {\n      <span class=\"hljs-comment\">// 무거운 계산을 시뮬레이션합니다</span>\n      <span class=\"hljs-keyword\">let</span> result = <span class=\"hljs-number\">0</span>;\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &#x3C; <span class=\"hljs-number\">1e9</span>; i++) {\n        result += i;\n      }\n      <span class=\"hljs-keyword\">return</span> result;\n    }\n  }\n}\n\n<span class=\"hljs-comment\">// 워커 스레드 실행을 위해 함수를 호출합니다</span>\n<span class=\"hljs-title function_\">runWorkerThread</span>();\n</code></pre>\n<p>이 예시는 메인 스레드와 워커 스레드로 구성된 멀티 스레드 설정을 보여줍니다. 무거운 계산은 워커 스레드에서 수행되고, 그 결과가 메인 스레드로 보내집니다.</p>\n<p>워커 스레드를 생성하고 관리하는 로직은 runWorkerThread 함수 내에 캡슐화되어 있습니다. 워커 스레드를 시작하려면 이 함수를 필요할 때 호출할 수 있습니다.</p>\n<p>본 내용을 즐기셨고 이러한 노력을 지원하고 싶으시다면 다음 링크를 방문해주세요: <a href=\"https://ko-fi.com/jacobmacinnis\" rel=\"nofollow\" target=\"_blank\">https://ko-fi.com/jacobmacinnis</a></p>\n</body>\n</html>\n"},"__N_SSG":true}