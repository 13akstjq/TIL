{"pageProps":{"posts":[{"title":"꿈의 직장을 잡기 위해 반드시 알아야 할 필수 Python 면접 질문 20개","description":"","date":"2024-07-09 14:52","slug":"2024-07-09-20EssentialPythonInterviewQuestionsYouMustKnowtoLandYourDreamJob","content":"\n\n## 파이썬 면접 질문\n\n보통 면접관들은 구직자가 이력서에 기재한 기술 스킬 및 관련 세부사항을 기반으로 질문을 할 것입니다. 주요 기업의 기술 역할에 대한 특별 제안을 받은 사람이 자신의 면접 경험을 공유했습니다. 이력서에 기재된 기술에 기반하여 면접관은 대략 다음과 같은 영역을 다루는 질문을 했습니다:\n\n- 다양한 데이터 유형 및 그들 사이의 차이점\n- 프로세스, 스레드 및 코루틴의 정의 및 차이점\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n• 얕은 복사와 깊은 복사의 차이점\n\n• 일반적인 개발 패턴\n\n• 함수형 프로그래밍 대 객체 지향 프로그래밍\n\n• 클로저와 데코레이터\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n• Garbage collection mechanisms\n\n• Common Linux commands, with examples\n\n이 분의 경험에 따르면 위 주제들이 면접 질문에서 자주 다루는 주제들이라고 해요. 대부분 이에 대해 대답할 수 있다면, 여러분이...","ogImage":{"url":"/TIL/assets/no-image.jpg"},"coverImage":"/TIL/assets/no-image.jpg","tag":["Tech"],"readingTime":2},{"title":"한 번의 클릭으로 LLMs가 현실이 되다 - 휴대 가능한 AI로 가는 길 두 번째 이야기","description":"","date":"2024-07-09 14:52","slug":"2024-07-09-One-clickLLMsarenowarealityRoadtoportableAIpart2","content":"\n두 가지 이전 기사에서는 특정 버전의 이식 가능한 Python을 만드는 방법과 LlamaFile을 사용하는 방법에 대해 알아보았어요.\n\n그런데 LlamaFile에는 GGUF 모델과 런타임을 함께 패키지로 묶는 것을 가능케 하는 몇 가지 특별한 기능이 있어요.\n\n이 기사에서는 Method 2를 사용하는 방법을 배워보려고 해요— 아주 작지만 매우 강력한 qwen-1.5-chat-0.5b의 .exe 파일을 생성하는 방법을 배울 거예요. Qwen05.exe를 실행하면 기존 애플리케이션에 대해 준비된 OpenAI 호환 API 서버가 시작돼요!\n\n![이미지](/TIL/assets/img/2024-07-09-One-clickLLMsarenowarealityRoadtoportableAIpart2_0.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기에서 다루게 될 내용입니다:\n\n```js\n사용 사례\n필요한 도구\nQwen05.exe 만들기 및 실행하기\n기존 파이썬 사용하여 실행하기\nStreamlit GUI?\n```\n\n# 사용 사례\n\n제가 LlamaFile을 파헤치기 시작한 이유는 회사에서 거의...\n","ogImage":{"url":"/assets/img/2024-07-09-One-clickLLMsarenowarealityRoadtoportableAIpart2_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-One-clickLLMsarenowarealityRoadtoportableAIpart2_0.png","tag":["Tech"],"readingTime":1},{"title":"제발, 제발 If-Else 문 사용하기, 아니면 후회할 거예요","description":"","date":"2024-07-09 14:51","slug":"2024-07-09-PleasePLEASEUseIf-ElseStatementsorIllFindYou","content":"\n![이미지](/TIL/assets/img/2024-07-09-PleasePLEASEUseIf-ElseStatementsorIllFindYou_0.png)\n\n프로그래밍 세계에서 명확한 조건문이 없는 코드는 미치도록 짜증이 납니다. 교통 부호 없는 도시를 운전하는 것과 같습니다. 난잡하고 혼란스럽고 정말 위험합니다. 그래서 논리적으로 생각한다면, if-else 문을 사용해주세요. 그렇지 않다면, 당신을 찾아가서 강제로 코드 리팩토링을 시킬지도 몰라요.\n\n# 조건문의 아름다움\n\nif-else 문은 프로그래밍에서 의사 결정을 하는 데 중추적인 역할을 합니다. 다양한 조건에 따라 코드가 가지를 치거나 다른 경로를 따라갈 수 있습니다. 이렇게 함으로써 코드가 유연하고 가독성이 좋아지며 유지보수하기 쉬워집니다. 간단한 예제로 설명해보겠습니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 온도가 30도를 넘으면:\nprint(\"뜨거운 날씨네요, 수분을 충분히 섭취하세요!\")\n그렇지 않으면:\nprint(\"날씨가 좋고 시원해요.\")\n\n이 구조를 사용하면 코드를 읽는 사람이 각 메시지가 출력되는 조건을 즉시 이해할 수 있습니다. 명확하고 간결하며 효율적입니다.\n\n# 중첩된 삼항 연산자의 공포\n\n이제 중첩된 삼항 연산자의 공포를 상상해보세요. 다음의 혼돈스러운 예제를 해독하려고 노력하는 것을 상상해보세요:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nmessage = \"기온이 30도를 넘는 더운 날씨네요! 수분을 충분히 섭취하세요.\" if temperature > 30 else \"날씨가 시원해서 좋네요.\"\n\n이것은 코드를 간결하게 줄이는 똑똑한 방법인 것 같지만, 조건이 더 복잡해지면 읽기가 굉장히 어려워집니다. 중첩된 삼항 연산자는 마침표가 없는 소설을 읽는 것과 같습니다. 뜻을 이해할 수는 있겠지만, 고통스러운 경험이 될 것입니다.\n\n# 명확성을 위한 이유\n\n명확한 코드는 예의뿐만 아니라 필수적입니다. 깨끗하고 이해하기 쉬운 코드를 작성할 때, 당신뿐만 아니라 미래에 프로젝트에 참여할 수 있는 모든 개발자들에게 도움이 됩니다. 복잡하고 따라가기 어려운 로직이 가득한 코드베이스를 상속받는 상황을 상상해보세요. 당신은 당혹스럽고 오류가 발생하기 쉬운 상황에 처할 것입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nif-else문을 사용하면 당신의 의도를 명확하게 전달할 수 있습니다. 코드를 읽는 사람에게 로드맵을 제공하여 디버깅, 수정 및 확장을 쉽게 만들 수 있습니다. 아래에는 차이를 보여주기 위한 더 복잡한 예제가 있습니다:\n\n# If-Else 방식\n\n```js\nif user.is_logged_in:\n    if user.has_permission(\"admin\"):\n        display_admin_panel()\n    else:\n        display_user_dashboard()\nelse:\n    prompt_login()\n```\n\n# Ternary 방식\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ndisplay_admin_panel() if user.is_logged_in and user.has_permission(\"admin\") else display_user_dashboard() if user.is_logged_in else prompt_login()\n```\n\n어떤 방법을 유지하시겠습니까?\n\n# 개발자들에게 호소\n\n저와 같은 개발자 여러분들에게 작은 부탁이 있습니다. 제 정신 건강과 여러분의 것을 위해, if-else 문을 사용해 주세요. 이것은 좋은 습관뿐만 아니라 생명줄이기도 합니다. 당신의 논리를 하나의 난해한 줄로 압축하려는 유혹이 들 때, 이 글을 기억해 주세요. 언젠가 여러분의 코드를 읽게 될 개발자가 여러분을 감사하며 명료함을 선택했음을 기억해 주세요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그게 만족스럽지 않다면, 기억해둬 — 내가 널 찾을 수 있는 곳을 알고 있다니까.\n","ogImage":{"url":"/assets/img/2024-07-09-PleasePLEASEUseIf-ElseStatementsorIllFindYou_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-PleasePLEASEUseIf-ElseStatementsorIllFindYou_0.png","tag":["Tech"],"readingTime":4},{"title":"Python으로 델타 뉴트럴 트레이딩 전략 백테스트 하는 방법","description":"","date":"2024-07-09 14:50","slug":"2024-07-09-Backtestadelta-neutraltradingstrategyinPython","content":"\n![image](/TIL/assets/img/2024-07-09-Backtestadelta-neutraltradingstrategyinPython_0.png)\n\n옵션의 가장 강력한 사용 방법 중 하나는 투자 포트폴리오를 기본 자산의 방향성 스윙으로부터 격리시키는 능력입니다.\n\nApple 주식을 매수하면 다음과 같은 상황이 발생합니다:\n\n- Apple 주식이 상승하면 가치가 증가합니다.\n- Apple 주식이 하락하면 가치가 감소합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/TIL/assets/img/2024-07-09-Backtestadelta-neutraltradingstrategyinPython_1.png\" />\n\n당신의 포지션은 방향성 노출이 있으며 델타가 1이라고 합니다.\n\n그냥 포지션을 유지하면 주식에서 미실현 이익과 손실에 노출됩니다.\n\n대부분의 소액 투자자들에게 작은 손실은 투자의 일부입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러나 대형 기관 투자자들은 특정 투자 규정(예: 미 실현 손실이 15%를 초과해서는 안 된다)에 따라, 미 실현 손실이 발생하는 것은 금물입니다.\n\n# 델타 제거하기\n\n다행히도, 우리가 보게 될 것처럼, 주식 보유량과 옵션을 조합하여 보유 위치에서 델타를 부분적/전적으로 제거하는 것이 가능합니다. 이를 적극적으로 관리하여 가능합니다.\n\n옵션 용어에서는 이를 델타 헷징이라고 합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 방향성 노출 조정하기\n\n현재 인벤토리에 주식 보유 중이라면, 방향성 노출을 조정하는 간편한 방법은 콜 옵션을 매수하거나 공매도하는 것입니다.\n\n![이미지1](/TIL/assets/img/2024-07-09-Backtestadelta-neutraltradingstrategyinPython_2.png)\n\n![이미지2](/TIL/assets/img/2024-07-09-Backtestadelta-neutraltradingstrategyinPython_3.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n특정 계약에서 콜의 델타는 0.77이며, 완전히 델타 중립이 되기 위해 주식 대 콜 옵션의 비율은 77:100이어야 합니다.\n\n많은 옵션 계약에서는 100단위의 주식/상품/자산을 표현합니다. 따라서, 각 콜 옵션을 판매할 때마다 77주를 구매/보유해야 합니다.\n\n보유 주식 수 = 매도한 콜 옵션 수 _ 100 _ 델타\n\n다음 날/주에 콜의 델타가 0.80으로 증가하면, 각 콜 당 추가로 3주를 더 매입해야 합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n엄밀히 말하면 역방향도 가능합니다. 매수하거나 빌림으로써 주식 보유량과 델타를 일치시킬 수 있습니다.\n\n그러나 콜 옵션은 100주의 주식을 나타내므로 델타의 정확한 가치를 제어할 수 있는 기회가 줄어듭니다. (예: 0.2개의 콜 옵션을 구매하여 20주의 델타를 확보할 수는 없습니다).\n\n# 델타 헷지 전략 테스트 중\n\n위의 비디오에서 사용된 예시는 John Hull의 다음 교과서에 나와 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/TIL/assets/img/2024-07-09-Backtestadelta-neutraltradingstrategyinPython_4.png)\n\n이 예제에서는 1000개의 숏 콜(short calls)을 시작으로 책이 시작됩니다. 이것은 10만 주의 가치가 있는 숏 포지션을 나타냅니다.\n\n이 연습의 목표는 콜의 델타에 기반하여 매주 포트폴리오를 리밸런싱하는 것입니다.\n\n![image](/TIL/assets/img/2024-07-09-Backtestadelta-neutraltradingstrategyinPython_5.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n통화물이 처음으로 주 0에 구입되었을 때, 해당 통화물의 델타는 0.522입니다. 따라서 모든 통화물의 델타 합은 52,200입니다.\n\n주식 한 주의 델타가 1이라면, 우리는 이를 완벽하게 균형을 이루기 위해 52,200주를 구입하거나 보유해야 합니다.\n\n이 과정은 이후의 모든 주에도 계속됩니다.\n\n## 주의\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n주식 가격이 1주차와 2주차에 하락하는 것을 관찰하실 수 있습니다.\n\n하지만, 우리는 주식을 판매하고 있습니다.\n\n이로 인해 주식 거래에서 손실이 발생합니다.\n\n그러나 우리의 숏 콜 포지션은 네거티브 델타를 가지고 있습니다. (주식 가격이 하락함에 따라 가치가 증가), 우리는 콜 옵션을 더 낮은 가격에 다시 매수하여 우리의 숏 포지션에서 이익을 실현할 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n네트 효과는 포트폴리오에서 발생하는 어떤 이익도 손실을 상쇄합니다.\n\n## 왜 필요할까요\n\n델타 헷징의 대부분 목표는 알 수 없는 방향 위험을 절연하는 것입니다.\n\n이러한 경우는 주로 선거나 정부 발표와 같은 이벤트가 예정되어 있는 경우에 발생합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n곰계의 소식이 나쁜 경우에는 포트폴리오 자산에 손실이 발생할 수 있지만, 옵션 거래에서의 수익은 그 손실을 일부 또는 전체로 상쇄시킬 것입니다.\n\n## Python 코드\n\nHull 교재에서는 델타 값과 가격들의 시리즈를 제공했습니다.\n\n델타 값은 양수로 표기되어 있으며, 공매도를 할 경우 해당 값을 음수로 바꿔야 합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ndelta_values = np.array(delta_values)\ndelta_values=list(-delta_values) if apple.long_short_option == 'Short'\nelse delta_values\n```\n\n```js\nimport numpy as np\nprices = [49, 48.12, 47.37, 50.25, 51.75, 53.12, 53, 49.88, 48.5,\n          49.88, 50.37, 52.13, 51.88, 52.87, 54.87, 54.62, 55.87, 57.25]\ndelta_values = [0.522, 0.458, 0.4, 0.596, 0.693, 0.774, 0.771, 0.706, 0.674, 0.787, 0.550,\n                0.413, 0.542, 0.591, 0.768, 0.759, 0.865, 0.978, 0.990, 1, 1]\n\ndelta_values = np.array(delta_values)\n\nclass Position:\n    def __init__(self, current_pos_delta,\n                 option_contracts,\n                 shares_held,\n                 cash,\n                 long_short_option,\n                 PnL\n                 ):\n        self.current_pos_delta = current_pos_delta\n        self.option_contracts = option_contracts\n        self.shares_held = shares_held\n        self.cash = cash\n        self.long_short_option = long_short_option\n        self.PnL = PnL\n        pass\n\napple = Position(0, 1000, 0, 0, 'Short', 0)\n\ndef buy_sell(long_short, price, quantity):\n    if long_short==\"Long\":\n        apple.cash -= price*quantity\n        pass\n\n    elif long_short=='Short/Sell':\n        apple.cash += price*quantity\n        pass\n\ndef delta_hedge(option_contracts,\n                option_delta,\n                shares_held,\n                price\n                ):\n    new_pos_delta = option_contracts*option_delta*100\n    delta_hedge = new_pos_delta - apple.current_pos_delta\n    long_short = \"Short/Sell\" if delta_hedge>0 else \"Long\"\n    shares_held += -new_pos_delta\n    holdings_value = shares_held*price\n\n    buy_sell(long_short=long_short, price=price, quantity=abs(int(delta_hedge)))\n    apple.PnL = holdings_value+apple.cash\n\n    print(\"|Delta to hedge: \", delta_hedge, \"|\",\n          \"Shares/Tokens to\" ,long_short,\": \" ,abs(int(delta_hedge)),\"|\",\n          \"Shares Held: \", int(shares_held), \"|\",\n          \"Value of Holdings: $\", holdings_value ,\"|\",\n          \"Cash holdings: $\", apple.cash, \"|\",\n          \"PnL: $\", apple.PnL, \"|\")\n    apple.current_pos_delta = new_pos_delta\n    pass\n\ndelta_values=list(-delta_values) if apple.long_short_option == 'Short' else delta_values\n\nfor (delta, price) in zip(delta_values, prices):\n    delta_hedge(option_contracts=apple.option_contracts,\n                option_delta=delta,\n                shares_held=apple.shares_held,\n                price=price)\n```\n\n위 코드를 실행하여 command line에서 출력되는 내용은 다음과 같습니다.\n","ogImage":{"url":"/assets/img/2024-07-09-Backtestadelta-neutraltradingstrategyinPython_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-Backtestadelta-neutraltradingstrategyinPython_0.png","tag":["Tech"],"readingTime":9},{"title":"파이썬으로 꼭 시도해볼 10가지 놀라운 자동화 스크립트","description":"","date":"2024-07-09 14:49","slug":"2024-07-09-10MindblowingAutomationScriptsYouNeedToTryUsingPython","content":"\n## 시도해볼 자동화 스크립트 — 파트 8\n\n![이미지](/TIL/assets/img/2024-07-09-10MindblowingAutomationScriptsYouNeedToTryUsingPython_0.png)\n\n자동화는 현대의 효율성을 뒷받침하는 핵심 요소로, Python은 다양한 해결책을 갖춘 언어로, 작업을 원활하게 최적화하는 데 이상적인 동반이 됩니다. 방대한 라이브러리 지원, 내장 함수, 그리고 번창하는 기여자 커뮤니티로 Python은 전례없이 업무를 단순화하는 데 최적 동반이라 할 수 있습니다. 본 블로그에서는 Python을 사용하여 시도해볼 10가지 놀라운 자동화 스크립트에 대해 살펴보겠습니다.\n\n# 1. 클립보드 관리자 📋\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n한 번쯤 복사한 텍스트들을 여러 개 동시에 다루다가 무엇을 복사했는지 헷갈리는 일이 있으셨나요? 하루 종일 복사한 모든 것을 추적할 수 있는 툴을 가지고 싶다고 생각해보신 적이 있으신가요?\n\n이 자동화 스크립트는 여러분이 복사한 모든 것을 감시하면서 각각의 복사한 텍스트를 세련된 그래픽 인터페이스 안에 매끄럽게 저장해줍니다. 그래서 끝도 없는 탭들을 뒤적이거나 중요한 정보를 잃어버릴 필요가 없어요.\n","ogImage":{"url":"/assets/img/2024-07-09-10MindblowingAutomationScriptsYouNeedToTryUsingPython_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-10MindblowingAutomationScriptsYouNeedToTryUsingPython_0.png","tag":["Tech"],"readingTime":1},{"title":"언어 모델의 성능을 극대화하기 위한 4가지 무료 CPU 활용 팁","description":"","date":"2024-07-09 14:48","slug":"2024-07-09-RevupthepowerofLanguageModels4CPUHacksforfree","content":"\n![이미지](/TIL/assets/img/2024-07-09-RevupthepowerofLanguageModels4CPUHacksforfree_0.png)\n\n매주 새로운 AI 모델이 출시됩니다.\n\n가끔은 LLM을 변경하는 것이 단순히 무의미할 수 있지만, 새로운 모델이 매력적으로 느껴진다면 테스트할 방법이 있습니다.\n\nLlama.CPP는 놀라운 라이브러리입니다. 50MB의 코드로 PC에서 매우 효율적인 AI 모델을 실행할 수 있습니다. 게다가 GPU도 필요하지 않습니다!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 문서에서는 llama-cpp-python을 사용하여 PC에서 GGUF(양자화된) 모델을 실행하는 네 가지 방법을 살펴보겠습니다. 놀랄만한 AI 애플리케이션을 만드는 동안 설계도로 생각해보세요.\n\n시작합시다.\n\n## 준비 사항\n\n시작하기 전에 약간의 환경 설정이 필요합니다. 다음 라이브러리가 각 방법에 필요합니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- langchain (langchain.LlamaCpp을 로드하고 추론을 실행하기 위한 라이브러리)\n- llama-cpp-python[server] (대부분의 메서드에 사용됨)\n","ogImage":{"url":"/assets/img/2024-07-09-RevupthepowerofLanguageModels4CPUHacksforfree_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-RevupthepowerofLanguageModels4CPUHacksforfree_0.png","tag":["Tech"],"readingTime":2},{"title":"TradingLab의 Insane 지표 모음 활용법","description":"","date":"2024-07-09 14:48","slug":"2024-07-09-TradingLabsInsaneIndicatorEnsemble","content":"\n<img src=\"/TIL/assets/img/2024-07-09-TradingLabsInsaneIndicatorEnsemble_0.png\" />\n\n여러분 안녕하세요! 또 다른 백테스트 결과로 돌아왔어요. TradingLab이 \"꼭 시도해봐야 할\"이라고 한 미친 듯한 지표 앙상블을 사용한 비디오를 올렸던데요. 여기서 비디오를 보실 수 있어요:\n\n하지만, 저는 그의 전략이 정말 그렇게 좋을지 궁금해졌어요. 그래서 테스트를 해보려고 해요. 함께 해요!\n\n# 어떤 지표를 사용할까요?\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nTradingLab은 TradingView에서 사용 가능한 두 지표에 중점을 둡니다:\n\n## 1) colinmck가 만든 EMA Trend Meter\n\n이 지표(또는 사용될 부분)은 단순히 종가를 기반으로 네 개의 EMA를 활용하고 모든 세 EMA가 기준선 EMA 위에 있는지 확인합니다. Python 코드는 다음과 같습니다:\n\n```js\nimport talib\n\ndef ema_trend_meter(close, len0=13, len1=21, len2=34, len3=55):\n    ema0 = talib.EMA(close, timeperiod=len0)\n    ema1 = talib.EMA(close, timeperiod=len1)\n    ema2 = talib.EMA(close, timeperiod=len2)\n    ema3 = talib.EMA(close…\n```\n","ogImage":{"url":"/assets/img/2024-07-09-TradingLabsInsaneIndicatorEnsemble_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-TradingLabsInsaneIndicatorEnsemble_0.png","tag":["Tech"],"readingTime":1},{"title":"더 나은 프로그래머가 되는 10가지 팁","description":"","date":"2024-07-09 14:47","slug":"2024-07-09-BecomeaBetterCoder10Tips","content":"\n위반 시 해고 조치를 받을 수 있습니다.\n\n![이미지](/TIL/assets/img/2024-07-09-BecomeaBetterCoder10Tips_0.png)\n\n수백 개, 아니면 수천 개의 Python 최상의 관례들이 있습니다. 누구든 물으면 약간 다른 버전의 관례를 듣게 될 것입니다.\n\n인터넷은 모든 사람이 의견을 표현할 권리를 주었습니다. 심지어 제게도요. 그러나 이 글에서는 절대로 변할 수 없는 20가지 Python 최상의 관례에 대해 다룰 것입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 팁 1: 함수는 매개변수와 반환 유형을 명시해야 합니다\n\n함수를 정의할 때, 매개변수의 유형과 함수의 결과가 반환하는 데이터 유형을 항상 명시하는 것이 좋습니다. 이렇게 하면 당신과 팀의 개발자들이 항상 시각적으로 이해를 얻기 위해 print 문을 사용하지 않고도 무엇을 기대해야 하는지 알 수 있습니다.\n\n좋은 예시:\n\n```js\ndef greet(name: str) -> None:\n  \"\"\"사용자를 이름으로 인사합니다.\"\"\"\n  print(f\"안녕, {name}!\")\n\ndef calculate_area(length: int, width: int) -> int:\n  \"\"\"사각형의 면적을 계산합니다.\"\"\"\n  area = length * width\n  return area\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n좋은 점:\n\n```python\ndef do_something():\n  print(\"이 함수는 어떤 일을 수행하지만 무엇을 하는 지 명확하지 않아요!\")\n\n# 함수 호출\ndo_something(\"이것은 실수입니다!\")  # 오류를 발생시킬 수 있어요\n```\n\n## 팁 2: 함수는 동일한 추상화 수준에 있어야 합니다\n\n함수가 동일한 추상화 수준에 있을 때, 우리는 함수가 단일하고 명확한 작업을 수행해야 한다는 것을 의미합니다. 해당 작업은 함수 내에서 일관된 추상화 수준이어야 합니다. 다시 말해, 함수는 특정 세부 수준이나 복잡성에 집중해야 하며, 모든 함수의 작업은 해당 동일한 수준에서 작동해야 합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n좋은 예시:\n\n```python\ndef calculate_average(numbers):\n    total = sum(numbers)\n    count = len(numbers)\n    average = total / count\n    return average\n```\n\n나쁜 예시:\n\n```python\ndef get_numbers():\n    numbers = [2, 3, 4, 1, 4, 1, 416, 6]\n    return numbers\n\ndef calculate_average():\n    numbers = get_numbers()\n    numbers_plus_30 = [num + 30 for num in numbers]\n\n    total = sum(numbers_plus_30)\n    count = len(numbers)\n    average = total / count\n    return average\n\ncalculate_average()\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 팁 3: 함수는 작게 작성하세요\n\n함수는 재사용 가능하도록 의도되었습니다. 그리고 함수가 커질수록 재사용 가능성이 줄어듭니다. 이는 함수가 하나의 일만 수행해야 하는 이유와도 관련이 있습니다. 함수가 하나의 일만 한다면, 그 함수가 작을 가능성이 높습니다.\n\n## 팁 4: 개방 폐쇄 원칙\n\n개방 폐쇄 원칙(Open Closed Principle, OCP)은 클래스, 메소드 또는 함수는 확장에 대해 열려 있어야 하지만 수정에 대해서는 닫혀 있어야 한다는 원칙입니다. 이는 정의된 클래스, 메소드 또는 함수가 코드를 변경하지 않고도 쉽게 재사용하거나 여러 인스턴스에 대해 확장할 수 있어야 한다는 것을 의미합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예를 들어, 주소라는 클래스가 있다고 가정해 봅시다.\n\n```js\nclass Address:\n    def __init__(self, country):\n        self.country = country\n\n    def get_capital(self):\n        if self.country == 'canada':\n            return \"ottawa\"\n        if self.country == 'america':\n            return \"Washington D.C\"\n        if self.country == 'united Kingdom':\n            return \"London\"\n\naddress = Address('united Kingdom')\nprint(address.get_capital())\n```\n\n이 코드는 OCP를 따르지 못합니다. 새로운 국가가 추가될 때마다 해당 국가에 대한 if 문을 새로 작성해야 합니다. 지금은 간단해 보일 수 있지만, 상상해 보세요. 100개 이상의 국가를 고려해야 한다면 어떻게 될까요?\n\n이것이 바로 OCP가 필요한 이유입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\ncapitals = {\n    'canada': \"Ottawa\",\n    'america': \"Washington D.C\",\n    'united Kingdom': \"London\"\n}\n\nclass Address:\n    def __init__(self, country):\n        self.country = country\n\n    def get_capital(self):\n        return capitals.get(self.country, \"Capital not found\")\n\naddress = Address('united Kingdom')\nprint(address.get_capital())\n```\n\n## 팁 5: 가능하면 주석을 피하세요\n\n주석은 가짜 진실의 모습을 취할 수 있습니다. 코드가 실제로 무엇을 하는지에서 다른 사람이 말한 것이 무엇인지로 독자의 마음을 벗어나게 합니다.\n\n시간이 흐르고 코드가 업데이트나 변경을 받는 경우에 매우 문제가 될 수 있습니다. 어느 순간 주석은 거짓이 되고 모두가 이제 모두가 거짓을 통해 진실을 관찰해야 합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n코멘트는 가능하면 피해야 합니다. 코멘트는 독자가 과거의 여러분의 사고를 상속하도록 강요합니다. 함수나 클래스가 변경된 경우, 대부분 코멘트는 함께 변경되지 않습니다. 대부분 코멘트는 독자가 앞으로 생각하는 것을 방해합니다.\n\n코멘트는 작성자가 명확하고 설명적인 클래스, 함수 또는 변수 이름을 제공할 능력이 부족했음을 의미합니다. 이는 프로그래머의 태도가 열악하다는 것을 드러내며, 팀이 그러한 태도를 상속하도록 강요합니다.\n\n## 팁 6: 매직 넘버를 피하세요\n\n매직 넘버는 나중에 변경될 수 있는 하드코딩된 값입니다. 그러나 이는 업데이트하기 어려울 수도 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예를 들어, \"Your Orders\" 개요 페이지에 표시되는 마지막 50개 주문이 있는 페이지가 있다고 가정해 보겠습니다. 여기서 50은 '매직 넘버'입니다. 즉, 표준 또는 관례를 통해 설정된 숫자가 아니라 규격에 명시된 이유에 따라 임의로 설정한 숫자입니다.\n\n이제 50이 다양한 위치에 있습니다 — SQL 스크립트( SELECT TOP 50 \\* FROM orders), 웹사이트(Your Last 50 Orders), 주문 로그인(for (i = 0; i < 50; i++)) 및 가능한 많은 다른 위치에 있습니다.\n\n좋은 방법:\n\n```js\nNUM_OF_ORDERS = 50\nSELECT TOP NUM_OF_ORDERS * FROM orders\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n좋지 않은 방법:\n\n```js\nSELECT TOP 50 * FROM orders\n```\n\n## 팁 7: 깊은 중첩 피하기\n\n루프, 조건문 또는 함수 내에서 중첩된 수준을 제한하여 가독성을 향상시키세요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n좋아요:\n\n```js\nif x and y:\n    do_something()\n```\n\n나쁘죠:\n\n```js\nif x:\n    if y:\n        do_something()\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 팁 8: 경로 하드코딩을 피하세요\n\n파일 경로나 URL을 하드코딩하는 것을 피하고, 대신 설정 파일이나 환경 변수를 사용하세요.\n\n좋은 예시:\n\n```js\nimport os\nfile_path = os.getenv(\"FILE_PATH\")\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n좋은 점 9: 클래스는 작아야 해요\n\n그렇다! 클래스도 가능한 작아야 해요. 함수처럼 말이죠.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n함수의 크기는 해당 함수의 라인 수에 의해 결정되지만, 클래스의 크기는 해당 클래스가 가진 책임의 수에 의해 결정됩니다.\n\n일반적으로, 클래스 이름은 해당 클래스가 가질 수 있는 책임의 종류를 나타냅니다. 그러나 이름이 모호하거나 너무 일반적일 때는 대부분 해당 클래스에 너무 많은 책임을 부여하고 있는 것입니다.\n\n이는 SRP (단일 책임 원칙)로 돌아가게 됩니다. 이 원칙에 따르면 클래스는 변경되어야 하는 이유 즉, 하나의 책임만 가져야 합니다.\n\n## 팁 10: 복잡한 삼항 표현식을 피하세요\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n너무 복잡한 삼항식 사용을 최대한 자제해주세요. 코드를 이해하기 쉽도록 가독성을 우선시하여 작성해주세요.\n\n좋은 예시:\n\n```js\nif number % 2 == 0:\n    result = \"even\"\nelif number % 3 == 0:\n    result = \"odd\"\nelse:\n    result = \"neither\"\n```\n\n나쁜 예시:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nresult = \"even\" if number % 2 == 0 else \"odd\" if number % 3 == 0 else \"neither\"\n```\n\n읽어 주셔서 감사합니다!✨ 만약 내 컨텐츠가 마음에 들고 나를 지원하고 싶다면, Patreon에서 나를 지원하는 가장 좋은 방법 —\n\n- 더 많은 컨텐츠는 DeepNexus에서 확인하기 🚀\n- 팔로우하기: LinkedIn | YouTube✅ | Github\n- 기계 학습 및 딥 러닝에서 도움이 필요하다면, 내 Fiverr ✔서비스를 확인하고 Upwork에서 연락해요!\n","ogImage":{"url":"/assets/img/2024-07-09-BecomeaBetterCoder10Tips_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-BecomeaBetterCoder10Tips_0.png","tag":["Tech"],"readingTime":10},{"title":"수학적 발견을 위한 Kolmogorov-Arnold 네트워크 소개","description":"","date":"2024-07-09 14:46","slug":"2024-07-09-Kolmogorov-ArnoldNetworksforMathematicalDiscovery","content":"\r\n<img src=\"/TIL/assets/img/2024-07-09-Kolmogorov-ArnoldNetworksforMathematicalDiscovery_0.png\"/>\r\n\r\n이전 논문인 Kolmogorov-Arnold Networks 해석에서 MIT에서 개발한 새로운 프레임워크인 KAN의 매커니즘을 소개했습니다. KAN 뒤에 있는 이론인 Kolmogorov-Arnold Representation Theorem을 면밀히 연구한 결과, KAN이 많은 수학 문제를 해결할 뿐만 아니라 발견을 할 수 있다는 것을 깨달았습니다.\r\n\r\nKAN의 한 가지 인상적인 특징은 데이터를 특정한 기호 형식(수학적 공식)으로 표현하는 상징적 회귀입니다. 이 도구는 회귀 공식을 기반으로 분류 문제에 사용되어 분할을 해석 가능하게 만들 수 있습니다. 그러나 실제 데이터에서 정확한 공식을 찾는 것은 어렵습니다. 데이터의 복잡성과 잡음 때문에 로그 및 지수 함수와 같은 매개 변수 형식을 사용해 설명하기 어려울 수 있습니다. 이를 개선하는 한 가지 방법은 더 좋은 공식을 제공할 수 있는 다층 KAN을 사용하는 것입니다. 그러나 이로 인해 수학 공식이 너무 복잡할 수 있어 분류를 해석하기 어렵게 만들 수 있습니다.\r\n\r\n데이터를 사용하여 수학을 연구하는 데 KAN을 사용하는 특히 그 상징적 회귀를 사용하는 것은 장점이 있을 수 있습니다. 수학 규칙이 존재한다면 KAN은 규정을 찾는 데 도움을 줄 수 있습니다.\r\n","ogImage":{"url":"/assets/img/2024-07-09-Kolmogorov-ArnoldNetworksforMathematicalDiscovery_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-Kolmogorov-ArnoldNetworksforMathematicalDiscovery_0.png","tag":["Tech"],"readingTime":1},{"title":"파이썬에서 SOLID 원칙 적용하는 방법","description":"","date":"2024-07-09 14:45","slug":"2024-07-09-SOLIDprinciplesinPython","content":"\n![SOLID principles in Python](/TIL/assets/img/2024-07-09-SOLIDprinciplesinPython_0.png)\n\n# SOLID이란 무엇인가요?\n\n객체 지향 프로그래밍은 모든 프로그래머의 도구 상자에서 매우 유용한 도구입니다. 그러나 사용할 때 대부분의 사람들이 빠지는 흔한 함정이 있습니다.\n\nSOLID 원칙은 이러한 함정을 피하고 깔끔하고 유지보수 가능한 코드를 작성하는 데 도움이 되는 일련의 지침입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\"SOLID\"은 다음을 나타내는 머리글자입니다:\n\n- 단일 책임 원칙 (SRP)\n- 개방/폐쇠 원칙 (OCP)\n- 리스코프 치환 원칙 (LSP)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 인터페이스 분리 원칙\n\n- 의존성 역전 원칙\n\n## 1. 단일 책임 원칙 (SRP)\n\n로버트 C. 마틴 (a.k.a 아저씨 밥)이 \"OOD의 원칙\"이라는 기사에서 만들어진 단일 책임 원칙은 다음과 같습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n한 클래스는 한 가지 책임만 가져야 합니다. 한 클래스가 여러 가지 일을 한다면, 여러 클래스로 분리해야 합니다.\n\n간단한 예를 통해 이를 설명해보겠습니다. 우리가 Google 드라이브 또는 Dropbox에서 객체를 읽고 쓰는 클래스가 있다고 가정해 봅시다.\n\n```js\nclass StorageClient:\n    _instance = None\n    _google_client = None\n    _dropbox_client = None\n\n    def __init__(self, google_credentials, dropbox_credentials) -> None:\n        self._google_client = \"Google 클라이언트\"\n        self._dropbox_client = \"Dropbox 클라이언트\"\n\n    @classmethod\n    def get_or_create_instance(cls, google_credentials, dropbox_credentials) -> \"StorageClient\":\n        if not cls._instance:\n            cls._instance = StorageClient(google_credentials, dropbox_credentials)\n\n        return cls._instance\n\n    def read_from_google(self, key):\n        ...\n\n    def upload_to_google(self, key, value):\n        ...\n\n    def read_from_dropbox(self, key):\n        ...\n\n    def upload_to_dropbox(self, key, value):\n        ...\n```\n\n이 클래스의 문제는 두 가지 책임을 가지고 있다는 점입니다. Google 드라이브 및 Dropbox에서 객체를 읽고 쓰는 데에 대한 별도의 로직을 구현해야 합니다. SRP를 준수하기 위해 이 클래스를 GoogleStorageClient와 DropboxStorageClient로 분리할 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nclass GoogleStorageClient:\n    _instance = None\n    _google_client = None\n\n    def __init__(self, google_credentials) -> None:\n        self._google_client = \"Google client\"\n\n    @classmethod\n    def get_or_create_instance(cls, google_credentials) -> \"GoogleStorageClient\":\n        if not cls._instance:\n            cls._instance = GoogleStorageClient(google_credentials)\n\n        return cls._instance\n\n    def read(self, key):\n        ...\n\n    def upload(self, key, value):\n        ...\n\n\nclass DropboxStorageClient:\n    _instance = None\n    _dropbox_client = None\n\n    def __init__(self, dropbox_credentials) -> None:\n        self._dropbox_client = \"Dropbox client\"\n\n    @classmethod\n    def get_or_create_instance(cls, dropbox_credentials) -> \"DropboxStorageClient\":\n        if not cls._instance:\n            cls._instance = DropboxStorageClient(dropbox_credentials)\n\n        return cls._instance\n\n    def read(self, key):\n        ...\n\n    def upload(self, key, value):\n        ...\n```\n\n조금 더 상세하게 작성하더라도, 두 클라이언트를 개별적으로 개발하고 코드를 더 유지보수하기 쉽게 만듭니다. 예를 들어 Google 클라이언트를 작업하는 사람은 Dropbox 클라이언트의 작동 방식을 알 필요가 없으며 그 반대도 마찬가지입니다.\n\n## 2. 개방/폐쇄 원칙 (OCP)\n\n버트랜드 메이어는 1988년 저술한 \"객체지향 소프트웨어 구성\"에서 개방-폐쇄 원칙을 처음 제안한 것으로 일반적으로 알려져 있습니다. 그러나 1990년대에 이 원칙은 언클 밥이 1996년에 발표한 \"개방-폐쇄 원칙\"으로 현재의 형태로 재정의되었습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n개방/폐쇄 원칙은 다음을 의미합니다:\n\n클래스에 새 기능을 추가할 수 있어야 하며 기존 코드를 변경하지 않아도 됩니다.\n\n예를 들어, 다음 클래스는 개방/폐쇄 원칙을 위반합니다:\n\n```js\nclass Vehicle:\n    def __init__(self, vehicle_type, **kwargs) -> None:\n        self.vehicle = vehicle_type\n        if self.vehicle_type == \"car\":\n            self.tires = kwargs[\"tires\"]\n            self.mode = kwargs[\"mode\"]\n        elif self.vehicle_type == \"boat\":\n            self.motors = kwargs[\"motors\"]\n            self.mode = kwargs[\"mode\"]\n\n    def get_specifications(self) -> str:\n        if self.vehicle_type == \"car\":\n            return f\"This {self.vehicle_type} has {self.tires} tires and can drive on {self.mode}.\"\n        elif self.vehicle_type == \"boat\":\n            return f\"This {self.vehicle_type} has {self.motors} motors and can float on {self.mode}.\"\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 클래스의 문제점은 새로운 차량, 예를 들어 비행기를 추가하려면 기존 클래스를 수정해야 한다는 것입니다.\n\n기존 코드를 수정하는 것은 위험할 수 있으며 버그를 도입할 수도 있고 유닛 테스트를 실패할 수도 있습니다.\n\n대신 추상 기본 클래스를 정의하고 상속을 사용하여 클래스가 개방/폐쇄 원칙을 따르도록 할 수 있습니다.\n\n```js\nfrom abc import ABC, abstractmethod\n\nclass Vehicle(ABC):\n    def __init__(self, mode) -> None:\n        self.mode = mode\n\n    @abstractmethod\n    def get_specifications(self) -> str:\n        ...\n\nclass Car(Vehicle):\n    def __init__(self, tires) -> None:\n        super().__init__(\"lane\")\n        self.tires = tires\n\n    def get_specifications(self) -> str:\n        return f\"This car has {self.tires} tires and can drive on {self.mode}.\"\n\nclass Boat(Vehicle):\n    def __init__(self, motors) -> None:\n        super().__init__(\"water\")\n        self.motors = motors\n\n    def get_specifications(self) -> str:\n        return f\"This boat has {self.motors} motors and can float on {self.mode}.\"\n\nclass Plane(Vehicle):\n    def __init__(self, engines) -> None:\n        super().__init__(\"air\")\n        self.engines = engines\n\n    def get_specifications(self) -> str:\n        return f\"This plane has {self.engines} engines and can fly through the {self.mode}.\"\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 새 차량을 추가하고 싶다면, 단순히 Vehicle 클래스를 상속하고 get_specifications 메서드를 구현하는 새 클래스를 생성하면 됩니다.\n\n## 3. 리스코프 치환 원칙 (LSP)\n\n리스코프 치환 원칙은 1987년 OOPSLA 컨퍼런스에서 Barbara Liskov에 의해 소개되었습니다. 이 원칙은 다음과 같습니다:\n\n다시 말해, 만약 `S`가 `T`의 서브 클래스라면, `T` 타입의 객체를 `S` 타입의 객체로 대체할 수 있어야 하며, 프로그램의 기능을 변경하지 않아야 합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예를 들어, 다음과 같은 클래스를 고려해보세요:\n\n```python\nclass Person:\n    def __init__(self, name, age) -> None:\n        self.name = name\n        self.age = age\n\n    def get_name(self) -> str:\n        return self.name\n\n    def vote(self, give_vote) -> int:\n        if give_vote:\n            return 1\n        return 0\n\nclass Child(Person):\n    def __init__(self, name, age) -> None:\n        super().__init__(name, age)\n\n    def vote(self) -> None:\n        raise NotImplementedError(\"어린이는 투표할 수 없습니다.\")\n```\n\n이 코드의 문제는 Child 클래스가 리스코프 치환 원칙을 위반한다는 것입니다. Person 타입의 객체를 Child 타입의 객체로 대체하려고 하면, 예를 들어 vote 메서드를 사용하려고 할 때 프로그램이 예상대로 동작하지 않을 것입니다.\n\n이 문제를 해결하기 위해서는 Person을 추상 기본 클래스로 변환하고, 그것을 상속하는 Child와 Adult 두 클래스를 만들면 됩니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nfrom abc import ABC, abstractmethod\n\nclass Person(ABC):\ndef **init**(self, name, age) -> None:\nself.name = name\nself.age = age\n\n    def get_name(self) -> str:\n        return self.name\n\nclass Child(Person):\ndef **init**(self, name, age) -> None:\nsuper().**init**(name, age)\n\n    def go_to_school(self) -> None:\n        print(f\"{self.name} is going to school.\")\n\nclass Adult(Person):\ndef **init**(self, name, age) -> None:\nsuper().**init**(name, age)\n\n    def vote(self) -> int:\n        return 1\n\n이제 프로그램의 정확성에 영향을 주지 않고 Person 유형의 객체를 Child 또는 Adult 유형의 객체로 대체할 수 있습니다.\n\n## 4. Interface Segregation Principle (ISP)\n\n인터페이스 분리 원칙(Interface Segregation Principle, ISP)은 Uncle Bob이 만들었습니다. 이 원칙은 다음과 같이 설명합니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n큰 인터페이스를 피해야 합니다. 이는 모든 클라이언트가 구현하는 인터페이스 메서드를 사용하지 않는 대규모 인터페이스를 의미합니다.\n\n예를 들어, 다음과 같은 인터페이스를 고려해 보세요:\n\n```python\nfrom abc import ABC, abstractmethod\n\nclass Printer(ABC):\n    def scan(self) -> None: ...\n\n    def fax(self) -> None: ...\n\n    def print(self) -> None: ...\n\n\nclass SimplePrinter(Printer):\n    def scan(self) -> None:\n        raise NotImplementedError(\"This printer cannot scan.\")\n\n    def fax(self) -> None:\n        raise NotImplementedError(\"This printer cannot fax.\")\n\n    def print(self) -> None:\n        print(\"Printing...\")\n\n\nclass AdvancedPrinter(Printer):\n    def scan(self) -> None:\n        print(\"Scanning...\")\n\n    def fax(self) -> None:\n        print(\"Faxing...\")\n\n    def print(self) -> None:\n        print(\"Printing...\")\n```\n\n이 경우, SimplePrinter 클래스는 scan 및 fax 메서드가 필요하지 않지만, Printer 인터페이스를 구현하므로 이들을 구현해야 합니다. 이는 인터페이스 격리 원칙을 위반하는 것입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그 대신, Printer 인터페이스를 Scanner, Fax 및 Printer 세 개의 별도의 인터페이스로 분리할 수 있습니다.\n\n```js\nfrom abc import ABC, abstractmethod\n\n\nclass Scanner(ABC):\n    @abstractmethod\n    def scan(self) -> None:\n        ...\n\n\nclass Fax(ABC):\n    @abstractmethod\n    def fax(self) -> None:\n        ...\n\n\nclass Printer(ABC):\n    @abstractmethod\n    def print(self) -> None:\n        ...\n\n\nclass SimplePrinter(Printer):\n    def print(self) -> None:\n        print(\"Printing...\")\n\n\nclass AdvancedPrinter(Scanner, Fax, Printer):\n    def scan(self) -> None:\n        print(\"Scanning...\")\n\n    def fax(self) -> None:\n        print(\"Faxing...\")\n\n    def print(self) -> None:\n        print(\"Printing...\")\n```\n\n이제 SimplePrinter 클래스는 Printer 인터페이스만 구현하면 되고, AdvancedPrinter 클래스는 세 인터페이스를 모두 구현할 수 있습니다.\n\n이 방식을 통해 코드를 이해하기 쉽게 만들고 SimplePrinter 클래스에 불필요한 메서드가 필요 없어졌습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 5. 의존성 역전 원칙\n\n언클 밥이 만든 의존성 역전 원칙은 다음과 같습니다:\n\n이 원칙은 고수준 모듈과 저수준 모듈을 결합을 느슨하게 하기 위해 그들 사이에 추상화 계층을 도입하는 것에 관한 것입니다. 이를 통해 결합이 적고 유연한 시스템을 만들 수 있습니다.\n\n다음은 의존성 역전 원칙을 위반하는 예시입니다. 고수준 모듈인 PaymentService가 저수준 모듈인 PaypalProcessor에 직접 의존하는 것입니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nclass PaypalProcessor:\n    def process_payment(self, amount):\n        print(f\"Processing payment of ${amount} via PayPal\")\n\n\nclass PaymentService:\n    def __init__(self) -> None:\n        self.payment_processor = PaypalProcessor()\n\n    def perform_payment(self, amount):\n        self.payment_processor.process_payment(amount)\n\n\npayment_service = PaymentService()\npayment_service.perform_payment(100)\n```\n\n만약 다른 결제 게이트웨이로 전환하고 싶다면, PaymentService 클래스를 수정해야 하는데 이는 개방-폐쇄 원칙을 위배합니다.\n\n대신, 우리가 결제를 처리하는 PaymentService 고수준 모듈과 PayPal, Stripe와 같은 다른 결제 게이트웨이와 상호 작용할 수 있는 추상 인터페이스인 PaymentProcessor가 있는 것으로 가정해 봅시다.\n\n```python\nfrom abc import ABC, abstractmethod\n\n\nclass PaymentProcessor(ABC):\n    @abstractmethod\n    def process_payment(self, amount):\n        pass\n\n\nclass PayPalPaymentProcessor(PaymentProcessor):\n    def process_payment(self, amount):\n        print(f\"Processing payment of ${amount} via PayPal\")\n\n\nclass StripePaymentProcessor(PaymentProcessor):\n    def process_payment(self, amount):\n        print(f\"Processing payment of ${amount} via Stripe\")\n\n\nclass PaymentService:\n    def __init__(self, payment_processor):\n        self.payment_processor = payment_processor\n\n    def perform_payment(self, amount):\n        self.payment_processor.process_payment(amount)\n\n\npaypal_processor = PayPalPaymentProcessor()\npayment_service = PaymentService(paypal_processor)\npayment_service.perform_payment(100)\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이렇게하면 PaymentService 클래스는 특정 결제 프로세서 구현에 의존하지 않습니다. 대신 PaymentProcessor 인터페이스에 의존하고 있어서 PaymentService 클래스를 수정하지 않고도 다양한 결제 프로세서 간에 전환할 수 있습니다.\n\n# 결론\n\nSOLID 원칙은 깨끗하고 유지보수 가능하며 유연한 코드를 작성하는 데 도움이 되는 일련의 지침입니다. 이러한 원칙을 따르면 이해하기 쉬우며 테스트하고 유지하기 쉬운 코드를 만들 수 있습니다. 이러한 원칙에 적응하는 데는 시간이 걸릴 수 있지만, 확실히 더 나은 프로그래머가 되고 더 나은 소프트웨어를 만들 수 있도록 도와줄 것입니다. 이들은 가이드라인이며 절대적인 규칙이 아니므로 현명하게 사용하고 특정 요구사항에 맞게 적용하십시오.\n","ogImage":{"url":"/assets/img/2024-07-09-SOLIDprinciplesinPython_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-SOLIDprinciplesinPython_0.png","tag":["Tech"],"readingTime":15}],"page":"17","totalPageCount":28,"totalPageGroupCount":2,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}