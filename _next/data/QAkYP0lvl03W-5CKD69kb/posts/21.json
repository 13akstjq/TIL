{"pageProps":{"posts":[{"title":"TypeScript 맵드 타입 알아보기 기초부터 고급까지 8가지 예제","description":"","date":"2024-07-07 22:01","slug":"2024-07-07-ExploringMappedTypesinTypeScript8ExamplesfromBasictoAdvanced","content":"\nMarkdown 형식의 표를 변경하실게요.\n\n![Mapped types in TypeScript](/TIL/assets/img/2024-07-07-ExploringMappedTypesinTypeScript8ExamplesfromBasictoAdvanced_0.png)\n\nTypeScript의 Mapped types은 한 타입의 속성을 다른 타입으로 변환하는 강력한 도구입니다. 이들은 map과 filter와 비슷한 배열 메서드와 유사하지만, 이러한 작업들은 타입에 대해 수행됩니다. 우리는 실용적인 예제를 통해 그들의 사용법을 이해할 것입니다. 다음으로, 우리는 기초부터 고급까지 총 8가지 Mapped 타입 예제를 차근차근 시연하면서, 여러분이 이 강력한 타입 변환 도구를 쉽게 마스터할 수 있도록 돕겠습니다.\n\n# I. 기초적인 타입 변환\n\nTypeScript에서는 때때로 한 타입의 속성을 다른 타입으로 변환해야 할 때가 있습니다. 이것은 Mapped types를 사용하여 쉽게 실현할 수 있습니다. 아래에서는 한 Product 타입의 속성을 문자열 타입으로 변환하는 방법을 구체적인 예제를 통해 시연하겠습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 1. 제품 유형 정의하기\n\n먼저, 세 가지 속성인 이름 (문자열 유형), 가격 (숫자 유형), 재고 여부 (부울린 유형)을 포함한 제품 유형을 정의합니다.\n\n```js\ntype Product = {\n  name: string,\n  price: number,\n  inStock: boolean,\n};\n```\n\n## 2. 제품을 문자열로 변환하는 유형 정의하기\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그 다음, 우리는 새로운 타입인 ProductToString을 정의합니다. 이 타입은 Product 타입의 모든 속성을 문자열 타입으로 변환합니다.\n\n```js\ntype…\n```\n","ogImage":{"url":"/assets/img/2024-07-07-ExploringMappedTypesinTypeScript8ExamplesfromBasictoAdvanced_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-ExploringMappedTypesinTypeScript8ExamplesfromBasictoAdvanced_0.png","tag":["Tech"],"readingTime":2},{"title":"shadcn-ui UI 코드베이스 분석 shadcn-ui CLI는 어떻게 작동하나요  27부","description":"","date":"2024-07-07 22:00","slug":"2024-07-07-shadcn-uiuicodebaseanalysisHowdoesshadcn-uiCLIworkPart27","content":"\nshadcn-ui CLI가 어떻게 작동하는지 알아보고 싶었어요. 이 글에서는 shadcn-ui/ui CLI를 구축하는 데 사용된 코드에 대해 이야기하고 있어요.\n\n2.6 부에서는 프로젝트의 ts-config.json 파일에서 사용되는 별칭을 반환하는 getTsConfigAliasPrefix 함수를 살펴봤어요.\n\n이제 다음 코드 라인으로 넘어가 봅시다.\n\n![이미지](/TIL/assets/img/2024-07-07-shadcn-uiuicodebaseanalysisHowdoesshadcn-uiCLIworkPart27_0.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nL84에서는 projectType 또는 tailwindCssFile 또는 tsConfigAliasPrefix 중 하나라도 존재하지 않는 경우 null을 반환하는 간단한 확인 작업입니다.\n\nisTypescriptProject(cwd)에 대해 더 알아보겠습니다.\n\n```js\nconst isTsx = await isTypeScriptProject(cwd);\n```\n\nisTypescriptProject는 ui/packages/cli/src/utils/get-project-info.ts로부터 가져온 함수이며, 이 함수는 현재 작업 디렉토리(cwd)에 tsconfig.json 파일이 있는지 확인합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nexport async function isTypeScriptProject(cwd: string) {\n  // cwd에 tsconfig.json 파일이 있는지 확인합니다.\n  return pathExists(path.resolve(cwd, \"tsconfig.json\"));\n}\n```\n\n# pathExists\n\npathExists는 fs-extra에서 가져온 함수입니다.\n\n```js\nimport fs, { pathExists } from \"fs-extra\";\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결론:\n\n프로젝트가 TypeScript를 사용하는지 확인하려면 shadcn-ui/ui CLI 패키지와 같은 작업을 수행할 수 있습니다. 즉, fs-extra에서 제공하는 pathExists 함수를 사용하여 지정된 cwd에 있는 tsconfig.json 경로가 있는지 확인하면 됩니다.\n\n# 나에 대해:\n\n웹사이트: [https://ramunarasinga.com/](https://ramunarasinga.com/)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nLinkedin: [링크드인](https://www.linkedin.com/in/ramu-narasinga-189361128/)\n\nGithub: [깃허브](https://github.com/Ramu-Narasinga)\n\n이메일: ramu.narasinga@gmail.com\n\nshadcn-ui/ui를 처음부터 만들기\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 참고 자료:\n\n- [shadcn-ui 프로젝트 정보 가져오기](https://github.com/shadcn-ui/ui/blob/main/packages/cli/src/utils/get-project-info.ts#L84C3-L88C47)\n- [shadcn-ui 프로젝트 정보 가져오기](https://github.com/shadcn-ui/ui/blob/main/packages/cli/src/utils/get-project-info.ts#L174)\n- [shadcn-ui 프로젝트 정보 가져오기](https://github.com/shadcn-ui/ui/blob/main/packages/cli/src/utils/get-project-info.ts#L10)\n- [fs-extra 패키지](https://www.npmjs.com/package/fs-extra)\n","ogImage":{"url":"/assets/img/2024-07-07-shadcn-uiuicodebaseanalysisHowdoesshadcn-uiCLIworkPart27_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-shadcn-uiuicodebaseanalysisHowdoesshadcn-uiCLIworkPart27_0.png","tag":["Tech"],"readingTime":4},{"title":"초보 부트스트래퍼를 위한 간단한 기술 스택 추천","description":"","date":"2024-07-07 21:59","slug":"2024-07-07-ASimpleTechStackforBeginnerBootstrappers","content":"\n최근에 테이블 화면 클립을 CSV 파일로 변환하는 도구를 만들어서 론칭했어요.\n\n이 도구는 이메일 인증과 Stripe를 이용한 실제 결제 기능을 갖춘 기능적인 앱이에요.\n\n여기에는 해당 도구를 구축하기 위해 사용한 기술 스택을 공유해봤어요. 입문자 루트 개발자들에게 완벽한 간단한 스택이라고 생각해요 (초보에서 중급 프로그래머들 😉).\n\n![image](/TIL/assets/img/2024-07-07-ASimpleTechStackforBeginnerBootstrappers_0.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 메인 애플리케이션 (Next.js)\n\n도구의 핵심은 Next.js 애플리케이션입니다. Next.js는 React로 구축된 풀스택 프레임워크입니다.\n\n웹 애플리케이션을 시작하는 데 Next.js를 사용하는 것을 좋아하는 몇 가지 이유가 있습니다:\n\n- JavaScript / TypeScript로 모든 것을 작성할 수 있는 풀스택 지원.\n- 현대적인 App Router 접근 방식을 통해 앱의 아키텍처를 쉽게 설계할 수 있습니다. 디렉토리와 페이지를 추가하면 라우팅이 자동으로 처리됩니다.\n- 문서는 초보자에게도 잘 구성되어 있고 쉽게 접근할 수 있습니다.\n- Vercel도 함께 사용하면 배포도 매우 쉽습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 미리 알았더라면 좋았을 것들\n\n## 서버 및 클라이언트 컴포넌트에 대해 문서를 읽는 데 시간을 보내세요.\n\n이 모델에 익숙해지는 데 시간이 걸립니다. 하지만 결국 직관적이 되어 이 현대 웹 애플리케이션의 방향이 왜 그런지 볼 수 있습니다.\n\n- 모든 컴포넌트는 기본적으로 서버 컴포넌트입니다. 이는 로딩 시간, 보안 및 SEO에 이점이 있습니다.\n- 클라이언트 컴포넌트는 가져와서 서버 컴포넌트에서 사용할 수 있습니다.\n- 서버 컴포넌트는 클라이언트 컴포넌트로 가져올 수 없습니다. 그러나 프롭스로 전달할 수 있습니다.\n- 그 결과로 클라이언트 컴포넌트는 인터랙티브한 기능이 필요한 곳으로 컴포넌트 트리 아래로 밀어 넣어야 합니다 (예: 폼 및 버튼).\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 컴포넌트가 어떻게 조합되는지를 잘 익히면 Next.js를 사용한 생산성이 크게 향상될 것입니다.\n\n## 컴포넌트를 어떻게 구성할지에 대한 초기 결정을 내리세요\n\n나는 세 가지 주요 방법이 있다고 생각해요.\n\n- 'page.tsx' 파일 옆의 라우트 디렉터리 내에 컴포넌트를 위치시킵니다.\n- 별도의 'components' 디렉터리에 컴포넌트를 위치시킵니다.\n- 방법 1과 2를 혼합해서 사용합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n내 도구를 개발할 때 여러 접근 방법을 시도해 보았고, 결국 2번째 방법으로 정착했습니다.\n\n라우트 디렉토리 내에서 구성 요소를 찾는 것은 금방 번거로워지는 반면, 한 디렉토리에 모든 것을 찾아야 했기 때문에 구성 요소의 재사용성에 대해 더 신중히 고민해야 했습니다.\n\n## 컴포넌트 라이브러리 사용\n\n컴포넌트 라이브러리를 사용하면 많은 시간을 절약할 수 있습니다. 하지만 그러면 다음 문제는 어떤 컴포넌트 라이브러리를 사용해야 할지입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저는 shadcn/ui를 좋아해요. CLI를 사용하면 컴포넌트의 전체 코드가 프로젝트에 자동으로 붙여지기 때문이에요.\n\n컴포넌트들은 합리적인 스타일링 기본 설정을 가지고 시작할 때 편리하며, 코드를 쉽게 검사할 수 있는 능력은 (제 경우처럼) 견고한 재사용 가능한 컴포넌트가 어떻게 만들어지는지 배우고자 하는 분들에겐 좋은 기회가 되요.\n\n# 유용한 링크\n\n- React 소개\n- Next.js 소개\n- ByteGrad에서 제공하는 Next.js 관련 멋진 튜토리얼 비디오\n- Next.js와 shadcn/ui 설정하는 방법\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 데이터베이스 (Supabase)\n\n데이터베이스로 Supabase를 사용했어요. 선택한 이유는 다음과 같아요:\n\n- Next.js 애플리케이션과 매우 잘 통합돼요.\n- 인증 제공자로 사용할 수 있어요.\n- 오픈 소스에요.\n- 문서가 매우 훌륭해요 ✨.\n\n# 미리 알았더라면 좋았을 것들\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## Next.js와 Supabase 스타터 프로젝트 사용하기\n\n어플리케이션을 처음부터 만들어가던 중 Next.js와 Supabase가 기본 인증이 구축된 스타터 프로젝트로 협업한 것을 발견했어요.\n\n내 제안은 이 스타터를 사용하되 코드를 익히면서 작동 방식을 배우는 거예요.\n\n스타터를 사용하면 Vercel 마법사를 사용해 설정하면 좋아요. 그러면 대부분의 배포 구성이 이미 완료된 프로젝트로 시작할 수 있어요 (아래 링크 참조).\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 유용한 링크\n\n- Next.js와 Supabase 시작 프로젝트 배포하기\n\n# 결제 (Stripe)\n\n제 알기로는 애플리케이션을 구축할 때 Stripe가 결제 분야의 사실상 표준이라고 생각됩니다 (다르게 생각하시면 말씀해주세요).\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nStripe 문서에는 시작하는 데 도움이되는 꽤 좋은 정보와 보일러플레이트 코드가 있습니다.\n\n# 처음에 알았으면 하는 것들\n\n## 결제 링크를 사용하여 체크아웃 세션을 시작하십시오\n\nStripe 결제 링크는 Stripe를 사용하여 결제를 받는 가장 쉬운 방법입니다. Stripe 대시 보드 내에서 코딩없이 구성할 수 있습니다. 그런 다음 앱 내의 버튼이나 다른 구성요소가 사용자를 결제 링크로 안내하면 됩니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 결제 링크로 클라이언트 참조를 전달할 수 있습니다.\n\n사용자를 결제 링크로 이동시킬 때 클라이언트 참조 ID를 전달할 수 있습니다. 인증된 Supabase 사용자 ID를 전달하면 결제가 완료된 후에 해당 사용자와 조정할 수 있습니다.\n\n## 사용자가 결제를 완료한 후 로직에 웹훅을 사용하세요\n\n사용자가 결제 프로세스를 진행할 때 Stripe는 결제 의도 설정이나 체크아웃 세션 완료와 같이 다양한 '이벤트'를 생성합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nStripe는 업데이트를 수신하는 앱을 알 수 있도록 해당 이벤트를 보낼 대상을 필요로 합니다. 이 대상을 웹훅의 형태로 제공합니다.\n\n당신의 앱의 웹훅은 Stripe 이벤트를 '청취'합니다. 그런 다음 통과하는 다양한 이벤트를 어떻게 처리할지 결정합니다.\n\n가장 중요한 이벤트는 'checkout.session.completed'로, 이는 결제 프로세스가 원활하게 완료되었음을 의미합니다.\n\n# 유용한 링크\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Stripe 결제링크 개요\n- 클라이언트 참조 ID를 결제 링크에 전달하는 방법\n- Next.js와 Stripe를 사용하는 Vercel 기사 - 이 기사는 stripe checkout 세션을 사용하는 방법에 대한 것이며 (결제링크보다 복잡함), Stripe 웹훅을 위한 유용한 보일러플레이트 코드도 포함되어 있습니다.\n\n# 이메일 제공업체 (재전송)\n\n대부분의 애플리케이션은 사용자에게 어느 시점에서라도 이메일을 보내야 할 필요가 있습니다. 예를 들어 사용자가 가입한 경우 이메일 주소를 확인하는 이메일로 이메일을 확인할 수 있습니다.\n\nResend는 Supabase의 권장사항 중 하나였습니다. 합리적인 무료 티어를 갖추고 있으며 통합이 매우 원활하다고 생각했습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 미리 알았더라면 좋았을 것들\n\n## Supabase 이메일 인증이 제한되어 있습니다\n\nSupabase 이메일 인증 설정은 간단한데, 제작용으로 설계되어 있지 않다는 점을 알아두세요. 애플리케이션을 배포할 때 당신을 위해 이메일을 보낼 수 있는 SMTP (Simple Mail Transfer Protocol) 제공업체가 필요합니다.\n\n# 유용한 링크\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Resend와 Next.js\n- Supabase에서 사용자 정의 SMTP 구성\n\n여기에 있습니다! 부트스트랩된 애플리케이션을 위한 로드맵과 간단한 기술 스택이에요. 만약 간단한 도구에 대한 아이디어가 있다면, 이 아키텍처를 사용하여 시작할 수 있어요. 저가 일찍 알았으면 하는 몇 가지를 공유해드려서 유용하고 프로세스를 가속화할 수 있기를 바랍니다.\n\n떠나실 때!\n\n만약 이 이야기를 즐겁게 읽었다면 몇 손가락 운동을 하셔서 이 게시물을 좋아요 👏🏻 를 눌러주시겠어요? 읽고 싶어하시는 내용을 쓰고 있는지를 알려주어서 도움이 돼요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n기술 활용과 온라인 존재감 구축에 관한 더 많은 이야기를 듣고 싶다면 저를 팔로우해주세요. (저는 막 시작한 입장이니, 함께 배우세요.)\n\n다음에 만나요! 감사합니다! 🙏🏻\n","ogImage":{"url":"/assets/img/2024-07-07-ASimpleTechStackforBeginnerBootstrappers_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-ASimpleTechStackforBeginnerBootstrappers_0.png","tag":["Tech"],"readingTime":9},{"title":"React와 TypeScript로 Google Analytics 사용 방법","description":"","date":"2024-07-07 21:58","slug":"2024-07-07-GoogleAnalyticsWithReactTypescript","content":"\n<img src=\"/TIL/assets/img/2024-07-07-GoogleAnalyticsWithReactTypescript_0.png\" />\n\n## GA 란?!!\n\nGoogle Analytics (GA)은 웹사이트 트래픽 및 사용자 행동을 추적하고 분석하는 강력한 도구입니다.\n\n다음은 그 동작 방식입니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n당신의 웹사이트에서 GA는 JavaScript 추적 코드를 사용하여 데이터를 수집합니다. 이 코드는 웹사이트 페이지에 삽입되어 방문자에 대한 정보를 수집하고 Google의 서버로 보내어 처리되며 다양한 보고서에서 제공됩니다.\n\n## 구현은 어떻게 작동하나요?\n\nuseGoogleAnalytics.ts는 GA와 통합하기 위한 기본 파일로 사용됩니다. 우리는 유연성과 미래 지향성을 위해 GA 통합을 처리하기 위해 객체를 사용하고 있습니다.\n\nGoogleAnalyticsProvider.tsx는 라우트를 감싸는 공급자 컴포넌트로 사용됩니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nApp.tsx 파일을 수정하여 GoogleAnalyticsProvider 컴포넌트를 추가해주세요.\n\n이 방법을 선택한 이유는?\n\n- 다양한 기능 지원: 페이지 뷰, 이벤트 추적 및 초기화 후 구성을 쉽게 관리할 수 있습니다.\n\n- 미래를 대비: ReactGA에서 다른 솔루션(예: 미래의 GA 버전)으로 전환하더라도 코드 베이스의 각 인스턴스를 모두 업데이트해야 하는 것이 아니라 이 객체만 업데이트하면 됩니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- React 방식: 이 방법은 React의 최상의 실천 방법을 따르며 부작용을 처리하기 위해 컴포넌트를 사용합니다.\n\n// 코드에 있는 주석들\n앱에서 이를 검색하여 로직을 이해하고 앱에서 구현을 더 잘 할 수 있도록 하는 것을 추천합니다: `// 추천:` 및 `// 설명:`\n\nGitHub 저장소: ‘google-analytics-react-ts’\n\nuseGoogleAnalytics.ts.tsx\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport { useEffect } from \"react\";\nimport ReactGA from \"react-ga4\";\n\n// 추천: 환경 변수를 사용하여 비밀로 유지하는 것이 좋습니다.\nexport const trackingId = \"GA_ID\";\nconst appVersion = \"APP_VERSION\";\n// 참고: 분석을 보다 나은 것으로 만들기 위해 앱에서 사용자 ID를 사용하십시오.\n// 추천: Redux로 구현하는 것이 좋습니다.\nconst id = \"user-id\";\n\nconst useGoogleAnalytics = () => {\n  useEffect(() => {\n    if (trackingId) {\n      try {\n        ReactGA.initialize([\n          {\n            trackingId,\n            gaOptions: {\n              anonymizeIp: true,\n              clientId: id,\n            },\n          },\n        ]);\n        ReactGA.set({ app_version: appVersion });\n      } catch (error) {\n        // 추천: 이 오류를 오류 추적 서비스에 보고하는 것이 좋습니다.\n        console.log(\"Google Analytics 초기화 오류\", { Error: error });\n      }\n    }\n  }, [id]);\n\n  const setOption = (key: string, value: unknown) => {\n    ReactGA.set({ [key]: value });\n  };\n\n  const setUserId = (userId: string | number) => {\n    setOption(\"userId\", userId);\n  };\n\n  const sendData = (type: string, data: Object) => {\n    ReactGA.send({ hitType: type, ...data });\n  };\n\n  const trackPageView = (pagePath?: string) => {\n    if (!pagePath) {\n      pagePath = location.href;\n    }\n\n    setOption(\"app_version\", appVersion);\n    sendData(\"pageview\", { page: pagePath });\n  };\n\n  const trackEvent = (category: string, action: string, label?: string, value?: number) => {\n    setOption(\"app_version\", appVersion);\n    ReactGA.event({ category, action, label, value });\n  };\n\n  return {\n    setOption,\n    setUserId,\n    trackPageView,\n    trackEvent,\n  };\n};\n\nexport default useGoogleAnalytics;\n```\n\nGoogleAnalyticsProvider.tsx\n\n```js\nimport React, { useEffect, PropsWithChildren } from \"react\";\nimport { useLocation } from \"react-router-dom\";\nimport useGoogleAnalytics, { trackingId } from \"../hooks/useGoogleAnalytics\";\n\nconst GoogleAnalyticsProvider: React.FC<PropsWithChildren<{}>> = ({ children }) => {\n  const { trackPageView } = useGoogleAnalytics();\n  const location = useLocation();\n\n  useEffect(() => {\n    if (trackingId) {\n      try {\n        trackPageView(location.pathname + location.search);\n      } catch (error) {\n        // 추천: 이 오류를 오류 추적 서비스에 보고하는 것이 좋습니다.\n        console.log(\"Google Analytics의 trackPageView 실행 오류\", { Error: error });\n      }\n    }\n  }, [location, trackPageView]);\n  // 참고: GoogleAnalyticsProvider가 UI에 영향을 미치지 않고 다른 컴포넌트를 감쌀 수 있도록 합니다.\n  return <>{children}</>;\n};\n\nexport default GoogleAnalyticsProvider;\n```\n\nApp.tsx\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport { BrowserRouter as Router, Route, Routes, useLocation } from 'react-router-dom';\nimport './App.css';\nimport GoogleAnalyticsProvider from './providers/GoogleAnalyticsProvider';\n\nconst App: React.FC = () => {\n\n  return (\n    // 참고: GoogleAnalyticsProvider를 어디에 배치할지 확인하여 최적의 위치를 지정-\n    // 모든 route 변경을 추적하기 위해 초기화를 최소화하고 오류를 캡처합니다 (오류 추적 서비스 사용 시)\n    <GoogleAnalyticsProvider>\n      <Routes>\n        <Route\n          path=\"/\"\n          element={\n            <div>\n              Google Analytics React TypeScript\n            </div>\n          }\n        />\n      </Routes>\n    </GoogleAnalyticsProvider >\n  );\n}\n\nexport default App;\nexport default App;\n```\n\n## 2가지 구현 방법\n\n1. 일반 추적 (현재 레포지토리) :sunglasses:\n\n장점:\n\n- 간단한 초기화: 설정을 통해 GAInitializer 컴포넌트가 마운트될 때 Google Analytics가 한 번만 초기화됩니다.\n- 페이지 뷰 추적: 페이지 뷰를 추적하는 방법을 제공하여 각 페이지 방문이 로그에 기록되도록 수동으로 처리할 수 있습니다.\n- 사용자 정의 이벤트: trackEventBuilder 메서드를 사용하면 다양한 사용자 상호작용을 추적하는 유연성을 제공합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n단점:\n\n- 수동 페이지 뷰 추적: App 컴포넌트만 래핑하고 각 route 변경을 래핑하지 않기 때문에 각 route 변경마다 trackPageView를 수동으로 호출해야 합니다. 안 할 경우 인간 에러가 발생할 수 있습니다.\n- route 변경 추적 부족: route 변경을 자동으로 추적하지 않기 때문에, 각 컴포넌트에서 명시적으로 trackPageView를 호출하지 않으면 일부 페이지 뷰 로깅을 놓칠 수 있습니다.\n- 제한된 사용자 컨텍스트: 기본 GA가 수집한 것 이상의 상세한 사용자 상호작용 또는 인구통계 데이터를 추적하지 않습니다.\n\n장점:\n\n- 이벤트 추적 기능을 모든 추적하고 싶은 이벤트에 추가\n- 세밀한 제어: 추적할 이벤트와 해당 라벨을 정확하게 제어할 수 있어 매우 상세하고 구체적인 분석 데이터를 얻을 수 있습니다.\n- 사용자 정의: 각 이벤트를 특정 범주, 동작, 라벨 및 값으로 사용자 정의할 수 있어 사용자의 행동과 상호작용에 대한 풍부한 통찰을 제공합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n단점:\n\n- 유지보수 부담 : 애플리케이션이 커지면 수많은 개별 추적 호출을 관리하는 것이 시간이 오래 걸리고 일관되게 유지하는 것이 어려워질 수 있습니다.\n- 코드 중복 : 여러 구성 요소나 함수에서 유사한 추적 코드를 반복해야 할 수 있으며, 결과적으로 DRY (Don't Repeat Yourself) 코드가 줄어들 수 있습니다.\n\n## 콘텐츠 보안 정책 (CSP)\n\nGA를 구현하기 위해 GA 스크립트를 웹 애플리케이션에 포함하고 코드에서 추적을 설정하세요. 'https://www.google-analytics.com`를 script-src 및 connect-src 지시문에 추가하여 GA 서버로의 연결을 허용하도록 CSP를 구성하세요. Google Tag Manager를 사용하는 경우 script-src 지시문에 ‘https://www.googletagmanager.com`도 포함하고 CSP 구성을 철저히 테스트하세요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 참고 자료\n\nMedium: ‘Google Analytics TypeScript로 React에 구현하기’\n\nYouTube: ‘React JS에 Google Analytics 추가하기’\n","ogImage":{"url":"/assets/img/2024-07-07-GoogleAnalyticsWithReactTypescript_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-GoogleAnalyticsWithReactTypescript_0.png","tag":["Tech"],"readingTime":8},{"title":"Nextjs 마스터하기 깔끔하고 확장 가능하며 타입 안전한 개발을 위한 모범 사례","description":"","date":"2024-07-07 21:56","slug":"2024-07-07-MasteringNextjsBestPracticesforCleanScalableandType-SafeDevelopment","content":"\n현대 웹 개발에서 Next.js는 견고하고 동적인 웹 애플리케이션을 구축하는 강력한 프레임워크로 떠오르고 있습니다. 그 유연성과 서버 측 렌더링(SSR) 및 정적 사이트 생성(SSG)과 같은 기능들로 인해, 개발자들이 고성능 웹 사이트를 만드는 데 선택하는 주요 도구가 되었습니다. 그러나 Next.js의 최대 잠재력을 활용하려면, 코드 품질, 유지 보수성 및 확장성을 보장하는 최상의 사례에 따라야 합니다. 본 문서에서는 SOLID 원칙, TypeScript 지침 및 Next.js 특화 전략을 아우르는 포괄적인 최상의 사례를 탐구하여, Next.js 프로젝트를 탁월한 수준으로 발전시킬 수 있도록 돕겠습니다.\n\n![이미지](/TIL/assets/img/2024-07-07-MasteringNextjsBestPracticesforCleanScalableandType-SafeDevelopment_0.png)\n\n## 제 1장: Next.js 개발에서 객체 지향 원칙\n\n객체 지향 프로그래밍(OOP)은 \"객체\"라는 개념을 기반으로 하는 프로그래밍 패러다임으로, 이 객체는 필드(속성 또는 프로퍼티)에 데이터와 프로시저(메서드 또는 함수)에 코드를 포함할 수 있습니다. OOP 원칙을 준수하면 소프트웨어 시스템을 모듈식, 유연하고 유지보수하기 쉽게 설계하고 구현할 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 캡슐화\n\n- 캡슐화는 데이터를 해당 데이터에 작용하는 메서드와 함께 묶거나, 객체의 일부 구성 요소에 대한 직접 액세스를 제한하는 것을 말합니다. 이는 객체의 내부 상태를 숨기고 상호 작용하는 데 제어된 인터페이스만 노출함으로써 도와줍니다.\n- 자물쇠가 있는 금고를 생각해보세요. 자물쇠는 금고 안의 보물을 캡슐화하여 키(메서드)를 가진 사람들만 액세스할 수 있도록 합니다. 이렇게 함으로써 보물이 무단으로 액세스되거나 수정되는 것을 방지할 수 있습니다.\n\n```js\nclass Post {\n  constructor(title, content) {\n    this._title = title; // 캡슐화된 속성\n    this._content = content; // 캡슐화된 속성\n  }\n\n  getTitle() {\n    return this._title; // 게터 메서드\n  }\n\n  setContent(content) {\n    this._content = content; // 세터 메서드\n  }\n\n  getContent() {\n    return this._content;\n  }\n}\n```\n\n## 추상화\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 추상화는 복잡한 구현 세부 사항을 숨기고 객체의 핵심 기능만 표시하는 과정입니다. 이는 객체가 무엇을 하는지에 초점을 맞춘 채 그것이 어떻게 하는지보다는 복잡성을 관리하는 데 도움이 됩니다.\n- 자동차 계기판을 생각해보십시오. 이는 차의 내부 메커니즘을 공개하지 않고 속력, 연료 수준 및 엔진 온도와 같은 중요한 정보를 운전자에게 제공합니다. 이 추상화로 인해 운전자는 불필요한 세부 정보에 압도되지 않고 운전에 집중할 수 있습니다.\n\n```js\nclass Post {\n  constructor(title, content) {\n    this.title = title;\n    this.content = content;\n  }\n\n  displayPost() {\n    console.log(`Title: ${this.title}`);\n    console.log(`Content: ${this.content}`);\n  }\n}\n```\n\n## 상속\n\n- 상속은 새 클래스가 기존 클래스로부터 속성과 메서드를 파생하는 메커니즘입니다. 이는 코드의 재사용성을 촉진하고 각 하위 클래스가 상위 클래스에서 속성과 동작을 상속받아 클래스 계층 구조를 생성하는 것을 허용합니다.\n- 이전 세대로부터 일부 특성과 특징을 상속받는 가족 계보를 상상해보십시오. 마찬가지로 OOP에서는 하위 클래스가 상위 클래스로부터 속성과 메서드를 상속받아 클래스 계층 구조를 형성합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nclass Person {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n\n  displayInfo() {\n    console.log(`Name: ${this.name}`);\n    console.log(`Age: ${this.age}`);\n  }\n}\n\nclass User extends Person {\n  constructor(name, age, email) {\n    super(name, age); // 상위 클래스 생성자 호출\n    this.email = email;\n  }\n\n  displayUser() {\n    super.displayInfo(); // 상위 클래스 메서드 호출\n    console.log(`Email: ${this.email}`);\n  }\n}\n```\n\n## 다형성\n\n- 다형성은 서로 다른 클래스의 객체를 공통 슈퍼클래스의 객체로 취급할 수 있게 합니다. 이는 메서드를 슈퍼클래스에서 정의하고 서브클래스에서 오버라이드할 수 있어 코드의 유연성과 확장성을 제공합니다.\n- “draw”라는 메서드를 가진 모양 클래스를 생각해보세요. 이 draw 메서드는 각 모양 서브클래스(e.g., 원, 사각형, 삼각형)마다 다르게 구현될 수 있어 각 모양이 고유한 방식으로 그려질 수 있으면서도 여전히 모양으로 처리될 수 있습니다.\n\n```js\nclass Admin extends User {\n  constructor(name, age, email, role) {\n    super(name, age, email);\n    this.role = role;\n  }\n\n  displayUser() {\n    super.displayUser();\n    console.log(`Role: ${this.role}`);\n  }\n}\n\nclass Guest extends User {\n  constructor(name, age, email, status) {\n    super(name, age, email);\n    this.status = status;\n  }\n\n  displayUser() {\n    super.displayUser();\n    console.log(`Status: ${this.status}`);\n  }\n}\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 옵젝트 지향 원칙들을 적용하여 Next.js 개발을 하면 모듈화되고 유연하며 유지보수가 용이한 코드를 디자인할 수 있어 애플리케이션을 구축하고 확장하기가 더 용이해집니다.\n\n# Chapter 2: SOLID 원칙\n\n## 단일 책임 원칙 (SRP)\n\n- SRP는 클래스가 변경될 이유가 하나여야 한다고 이야기합니다. 이것은 클래스가 하나의 책임이나 역할만을 가져야 한다는 것을 의미합니다. 이 원칙은 클래스를 보다 집중적으로 만들어 이해하기 쉽고 버그 발생 가능성을 줄이는 데 도움이 됩니다.\n- 예를 들어 빵을 굽는 일을 담당하는 제빵사가 있다고 상상해보세요. 만약 제빵사가 갑자기 빵을 굽는 일에 더해 고객에게 빵을 배달하는 책임도 맡는다면, 빵의 품질이 하락할 수 있습니다. 굽기에만 집중함으로써, 제빵사는 항상 완벽하게 빵을 굽을 수 있음을 보장할 수 있습니다.\n- 다음은 Next.js에서 SRP를 적용하는 예시입니다. Card 컴포넌트를 만들고 싶다고 가정해봅시다. Card 폴더를 만들어 컴포넌트 자체와 필요한 상수들이 포함되도록 합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 컴포넌트인 Card.tsx입니다.\n\n```js\nimport React from \"react\";\nimport { CardProps } from \"./constants\";\n\nconst Card: React.FC<CardProps> = ({ title, desc, color }) => {\n  return (\n    <div\n      data-testid=\"card\"\n      style={{ backgroundColor: `#${color}` }}\n      className=\"p-12 w-[348px] h-full lg:h-[438px] rounded-[30px] shadow-lg\"\n    >\n      <h2 className=\"text-lg font-bold mb-3\">{title}</h2>\n      <p>{desc}</p>\n    </div>\n  );\n};\n\nexport default Card;\n```\n\n2. 상수들을 저장하는 constants.ts.\n\n```js\nexport type CardProps = {\n  title: string,\n  desc: string,\n  color: string,\n};\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 두 가지를 분리함으로써 코드의 전반적인 가독성을 향상시킬 수 있습니다.\n\n## 개방/폐쇄 원칙 (OCP)\n\n- OCP는 소프트웨어 엔티티가 확장 가능하도록 열려 있지만 변경에는 폐쇄되어야 함을 명시합니다. 이는 기존 코드를 변경하지 않고 시스템에 새 기능을 추가할 수 있어야 함을 의미합니다.\n- 차량을 예로 들어보겠습니다. 켄버파블 로프 랙이나 스포일러와 같은 다양한 액세서리로 쉽게 사용자 정의할 수 있도록 설계된 차량을 고려해보세요. 차량의 디자인은 이러한 액세서리를 추가하거나 제거할 수 있도록 해줌으로써 차량의 핵심 구조를 수정할 필요가 없게 합니다.\n- Next.js에서 OCP를 구현하는 방법은 컴포넌트 확장의 사용입니다. 함수 컴포넌트를 확장하고 처음/기본 컴포넌트에 영향을 주지 않고 새 UI 컴포넌트를 추가할 수 있습니다. 이것이 각각 확장 가능하게 열려 있지만 수정에는 폐쇄된 구현입니다.\n\n```js\n# Card.tsx\ntype CardProps = {\n  title: string;\n  desc: string;\n}\n\nconst Card: React.FC<CardProps> = ({title, desc}) => {\n  return (\n    <div>\n      <h1>{title}</h1>\n      <p>{desc}</p>\n    </div>\n  )\n}\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# ExtendedCard.tsx\n타입 ExtendedCardProps = {\n  CardProps CardProps;\n  좋아요 갯수 number;\n}\n\nconst ExtendedCard: React.FC<ExtendedCardProps> = ({CardProps, 좋아요 갯수}) => {\n  return (\n    <div>\n      <Card 속성={...CardProps} />\n      <p>{좋아요 갯수}</p>\n    </div>\n  )\n}\n```\n\nExtendedCard 컴포넌트는 Card 컴포넌트에 새로운 요소를 추가하여 props 및 컴포넌트 자체를 확장합니다.\n\n## Liskov Substitution Principle (LSP)\n\n- LSP는 슈퍼클래스의 객체가 서브클래스의 객체로 대체될 수 있어야하며 프로그램의 정확성에 영향을 주지 않아야한다고 명시합니다. 즉, 서브클래스는 에러를 발생시키지 않고 기본 클래스를 대체할 수 있어야 합니다.\n- 리모컨 자동차를 생각해보세요. 서로 다른 종류의 배터리를 교체할 수 있는 경우를 말합니다. 배터리가 맞고 필요한 전원을 제공한다면 어떤 브랜드나 종류의 배터리든 자동차의 작동에 영향을주지 않고 사용할 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음은 Next.js 컴포넌트에서 LSP 구현 예제입니다. 이 예제에서는 DisabledButton 컴포넌트가 Button 컴포넌트의 하위 클래스입니다. DisabledButton 컴포넌트는 기본 Button 컴포넌트의 기능을 확장하여 disabled 속성을 추가합니다. 하위 클래스임에도 불구하고, DisabledButton 컴포넌트는 Button 컴포넌트와 심리스하게 교체할 수 있으며 애플리케이션의 동작에 영향을 주지 않기 때문에 LSP를 준수합니다.\n\n```js\n// components/Button.tsx\nimport React from \"react\";\n\ninterface ButtonProps {\n  onClick: () => void;\n}\n\nconst Button: React.FC<ButtonProps> = ({ onClick, children }) => {\n  return <button onClick={onClick}>{children}</button>;\n};\n\nexport default Button;\n```\n\n```js\n// components/DisabledButton.tsx\nimport React from \"react\";\nimport Button from \"./Button\";\n\ninterface DisabledButtonProps {\n  onClick: () => void;\n}\n\nconst DisabledButton: React.FC<DisabledButtonProps> = ({ onClick, children }) => {\n  return (\n    <Button onClick={onClick} disabled>\n      {children}\n    </Button>\n  );\n};\n\nexport default DisabledButton;\n```\n\n```js\n// pages/index.tsx\nimport React from \"react\";\nimport Button from \"../components/Button\";\nimport DisabledButton from \"../components/DisabledButton\";\n\nconst Home: React.FC = () => {\n  const handleClick = () => {\n    console.log(\"Button clicked!\");\n  };\n\n  return (\n    <div>\n      <h1>Hello, Next.js!</h1>\n      <Button onClick={handleClick}>Click me!</Button>\n      <DisabledButton onClick={handleClick}>Click me!</DisabledButton>\n    </div>\n  );\n};\n\nexport default Home;\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## Interface Segregation Principle (ISP)\n\n- ISP는 클라이언트가 사용하지 않는 인터페이스에 의존하지 않아야 한다는 원칙을 말합니다. 대신, 인터페이스는 클라이언트의 필요에 맞게 더 작고 더 집중된 인터페이스로 분리되어야 합니다.\n- 예를 들어 사전 설치된 다양한 앱이 함께 제공되는 스마트폰을 상상해보세요. 모든 일을 처리하는 하나의 앱이 아니라 각 앱은 메시지, 이메일 또는 지도와 같이 특정 작업을 위해 설계되어 있어 전화 사용이 더욱 효율적이고 쉬워집니다.\n\n이 예시에서 Card 구성 요소는 TextCardProps, ImageCardProps, VideoCardProps와 같은 필요한 인터페이스에만 의존하여 인터페이스 분리 원칙을 따르며, 애플리케이션에서 유지 보수 및 유연성이 향상됩니다.\n\n```js\n// Card/constants.ts\ninterface TextCardProps {\n  type: \"text\";\n  text: string;\n}\n\ninterface ImageCardProps {\n  type: \"image\";\n  imageUrl: string;\n}\n\ninterface VideoCardProps {\n  type: \"video\";\n  videoUrl: string;\n}\n\ntype CardProps = TextCardProps | ImageCardProps | VideoCardProps;\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n// Card/Card.tsx\nimport React from \"react\";\nimport { CardProps } from \"../interfaces\";\n\nconst Card: React.FC<CardProps> = ({ type, ...props }) => {\n  switch (type) {\n    case \"text\":\n      return <div>{(props as TextCardProps).text}</div>;\n    case \"image\":\n      return <img src={(props as ImageCardProps).imageUrl} alt=\"Card\" />;\n    case \"video\":\n      return <video src={(props as VideoCardProps).videoUrl} controls />;\n    default:\n      return null;\n  }\n};\n\nexport default Card;\n```\n\n```js\n// pages/Home.tsx\nimport React from \"react\";\nimport Card from \"../components/Card\";\n\nconst Home: React.FC = () => {\n  return (\n    <div>\n      <h1>Cards</h1>\n      <Card type=\"text\" text=\"This is a text card\" />\n      <Card type=\"image\" imageUrl=\"https://example.com/image.jpg\" />\n      <Card type=\"video\" videoUrl=\"https://example.com/video.mp4\" />\n    </div>\n  );\n};\n\nexport default Home;\n```\n\n## 의존 역전 원칙 (DIP)\n\n- DIP(Dependency Inversion Principle)은 고수준 모듈이 저수준 모듈에 의존하지 않아야 한다는 것을 말합니다. 그 대신 둘 다 추상화에 의존해야 합니다. 이는 모듈들을 분리하여 재사용 가능하고 테스트하기 쉽게 만들어줍니다.\n- 벽돌로 지어진 집을 생각해보세요. 각 벽돌이 아래 벽돌에 의존하는 대신, 모든 벽돌이 기초에 의존합니다. 기초가 튼튼하면 개별 벽돌을 교체해도 집은 안정적으로 유지됩니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js에서는 React의 Context API 또는 의존성 주입을 사용하여 의존성 역전 원칙(Dependency Inversion Principle, DIP)을 구현할 수 있습니다. 여기서 StoreProvider 컴포넌트는 나머지 애플리케이션에 Redux 스토어를 제공하는 역할을 합니다. 이를 통해 스토어의 생성을 사용하는 컴포넌트와 분리하여 테스트와 재사용성을 촉진합니다.\n\n```js\n// providers/StoreProvider.tsx\n\"use client\";\n\nimport React, { useRef } from \"react\";\nimport { Provider } from \"react-redux\";\nimport { makeStore, AppStore } from \"../context/hamburgerContext/store\";\n\nexport default function StoreProvider({ children }: { children: React.ReactNode }) {\n const storeRef = useRef<AppStore>();\n if (!storeRef.current) {\n  // 처음 렌더링될 때 스토어 인스턴스를 생성합니다.\n  storeRef.current = makeStore();\n  storeRef.current.dispatch({ type: \"INITIALIZE_HAMBURGER\" });\n }\n\n return <Provider store={storeRef.current}>{children}</Provider>;\n}\n```\n\n```js\n// pages/_app.tsx\nimport \"@/styles/globals.css\";\nimport \"@/styles/carousel.style.css\";\nimport type { AppProps } from \"next/app\";\nimport TranslateProvider from \"../providers/TranslateProvider\";\nimport BaseLayout from \"../components/elements/layout/BaseLayout\";\nimport StoreProvider from \"../providers/StoreProvider\";\n\nexport default function App({ Component, pageProps }: AppProps) {\n  return (\n    <TranslateProvider>\n      <StoreProvider>\n        <BaseLayout>\n          <Component {...pageProps} />\n        </BaseLayout>\n      </StoreProvider>\n    </TranslateProvider>\n  );\n}\n```\n\n## SOLID 원칙의 구현 장점\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNext.js 프로젝트에서 SOLID 원칙을 적용하면 여러 가지 이점을 누릴 수 있어요.\n\n- 향상된 코드 품질: SOLID 원칙을 따르면 더 깨끗하고 조직화된 코드를 작성할 수 있어요. 이는 이해하기 쉽고 유지보수하기 쉬운 코드로 이어지며 버그가 적어지고 개발 주기가 빨라집니다.\n- 더 나은 확장성: SOLID 원칙은 모듈화된 설계를 촉진하여 새로운 기능을 추가하거나 애플리케이션을 확장할 때 쉬워집니다. 기존 기능을 수정하지 않고 기능을 확장할 수 있어요. 이는 코드 재사용을 촉진하고 버그 발생 가능성을 줄입니다.\n- 향상된 유지보수성: SOLID 원칙을 적용하면 각 구성 요소가 단일 책임을 가지게 되어 문제가 발생했을 때 이를 분리하고 수정하기 쉬워집니다. 이는 새로운 개발자가 코드베이스에 익숙해지고 이해하기 쉽게 만들어 줘요.\n- 더 큰 유연성: SOLID 원칙을 따르면 Next.js 애플리케이션의 동작을 쉽게 변경하거나 확장할 수 있습니다. 이 유연성은 요구 사항의 변화에 적응하거나 새로운 기능을 통합하는 데 중요합니다.\n- 쉬운 테스트: SOLID 원칙은 격리된 환경에서 테스트하기 쉬운 코드를 촉진합니다. 이는 신뢰할 수 있는 테스트와 코드 정확성에 대한 더 높은 수준의 신뢰를 보장해 줍니다. 특히 Next.js 프로젝트에서는 구성 요소간 복잡한 상호작용으로 인해 테스트가 어려울 수 있습니다.\n\n요약하자면, Next.js 프로젝트에서 SOLID 원칙을 적용하면 더 견고하고 유지보수하기 쉬운 확장 가능한 애플리케이션으로 이끌어줍니다. 이는 개발 경험과 최종 제품의 품질을 향상시킵니다.\n\n# 제 3장: Next.js 및 Typescript Best Practices\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 장에서는 Next.js와 TypeScript를 사용하는 최상의 방법에 대해 알아보겠습니다. 이는 강력한 React 프레임워크의 장점과 정적 타이핑의 안전성 및 명확성을 결합한 것입니다. TypeScript가 어떻게 Next.js에서 개발 경험을 향상시키는지에 대해 살펴보겠습니다. 프로젝트 설정부터 컴포넌트 구조화 및 데이터 처리까지! 함께 알아봅시다!\n\n1. `Avoid any and type everything`. 항상 any가 아닌 다른 타입으로 변수 또는 상수를 선언해야 합니다. TypeScript에서 타입 없이 변수나 상수를 선언할 때, 변수/상수의 타입은 할당된 값에 따라 추론됩니다. 새 프로젝트에서는 모든 엄격한 타입 확인 옵션을 활성화하기 위해 tsconfig.json 파일에서 strict:true를 설정하는 것이 좋습니다.\n\n```json\n{\n  \"compilerOptions\": {\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"allowJs\": true,\n    \"skipLibCheck\": true,\n    \"strict\": true,\n    \"noEmit\": true,\n    \"esModuleInterop\": true,\n    \"module\": \"esnext\",\n    \"moduleResolution\": \"node\",\n    \"resolveJsonModule\": true,\n    \"isolatedModules\": true,\n    \"jsx\": \"preserve\",\n    \"incremental\": true,\n    \"paths\": {\n      \"@/*\": [\"./src/*\"]\n    }\n  },\n  \"include\": [\"next-env.d.ts\", \"**/*.ts\", \"**/*.tsx\"],\n  \"exclude\": [\"node_modules\"]\n}\n```\n\n2. `Type Annotations for Props and State`. Next.js에서 TypeScript를 사용할 때, 컴포넌트의 props와 state에 대한 유형 주석을 제공하는 것이 중요합니다. 이는 컴포넌트로 흐르는 데이터의 올바른 유형을 보장하여 런타임 오류의 가능성을 줄입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Mastering Next.js: Best Practices for Clean, Scalable, and Type-Safe Development](/TIL/assets/img/2024-07-07-MasteringNextjsBestPracticesforCleanScalableandType-SafeDevelopment_1.png)\n\n![Mastering Next.js: Best Practices for Clean, Scalable, and Type-Safe Development](/TIL/assets/img/2024-07-07-MasteringNextjsBestPracticesforCleanScalableandType-SafeDevelopment_2.png)\n\n3. Leverage Functional Components and React Hooks. Functional components and React hooks are a powerful combination in Next.js. Functional components are easier to read and maintain, while hooks like useState and useEffect provide a cleaner way to manage state and side effects.\n\n![Mastering Next.js: Best Practices for Clean, Scalable, and Type-Safe Development](/TIL/assets/img/2024-07-07-MasteringNextjsBestPracticesforCleanScalableandType-SafeDevelopment_3.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n4. TypeScript 유틸리티 타입(Partial, Required, Omit) 사용하기. Partial, Required, Omit과 같은 TypeScript 유틸리티 타입을 활용하면 더 정확한 타입 정의를 만들 수 있습니다. Partial을 사용하면 타입의 모든 속성을 옵션으로 만들 수 있고, Required는 타입의 모든 속성이 필수임을 보장하며, Omit은 기존 타입에서 특정 속성을 제외한 새로운 타입을 생성합니다.\n\n5. ESLint로 코드 서식 일관성 유지 설정하기. ESLint는 코드 서식 지원 도구로 프로젝트 전체에서 일관된 코드 스타일을 유지하는 데 도움을 줍니다. Next.js 프로젝트에 설정하면 코드가 일관되게 서식이 맞춰져 가독성과 유지보수가 쉬워집니다.\n\n![이미지](/TIL/assets/img/2024-07-07-MasteringNextjsBestPracticesforCleanScalableandType-SafeDevelopment_4.png)\n\n6. \"?\"로 옵션으로 지정하기. TypeScript에서는 타입 정의에서 속성 이름 뒤에 \"?\"를 추가하여 속성을 옵션으로 표시할 수 있습니다. 이는 가끔 필요하지 않은 프롭스나 상태 속성이 있는 경우 유용합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n7. 조건부 렌더링. 조건부 렌더링은 특정 조건에 따라 다른 컴포넌트나 요소를 렌더링할 수 있습니다. 이를 위해 일반 JavaScript if 문이나 삼항 연산자를 JSX 코드 내에서 사용할 수 있습니다.\n\n8. Redux를 사용하여 전역 상태 관리 활성화하기. Redux는 React 및 Next.js 애플리케이션에 많이 사용되는 상태 관리 라이브러리입니다. Redux를 사용하면 전역 상태를 유지할 수 있어 어떤 컴포넌트에서든 액세스할 수 있으며, 컴포넌트 트리의 여러 수준을 통해 props를 전달할 필요가 없습니다 (state drilling).\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/TIL/assets/img/2024-07-07-MasteringNextjsBestPracticesforCleanScalableandType-SafeDevelopment_7.png)\n\n9. 타입 정의, 인터페이스 및 상수를 하나의 파일로 분리하세요. 타입 정의, 인터페이스 및 상수를 하나의 파일에 유지하면 깔끔하고 조직적인 프로젝트 구조를 유지할 수 있습니다. 이렇게 하면 프로젝트가 성장함에 따라 타입 정의를 찾고 관리하는 것이 쉬워집니다.\n\n![이미지](/TIL/assets/img/2024-07-07-MasteringNextjsBestPracticesforCleanScalableandType-SafeDevelopment_8.png)\n\n10. 항목 목록을 만들고 배열을 반복하여 컴포넌트 목록을 만드세요. Next.js에서 항목 목록을 렌더링할 때 map 함수를 사용하여 배열을 반복하고 각 항목에 대해 컴포넌트를 렌더링할 수 있습니다. 이를 통해 기본 데이터가 변경될 때 자동으로 업데이트되는 동적 목록을 만들 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/TIL/assets/img/2024-07-07-MasteringNextjsBestPracticesforCleanScalableandType-SafeDevelopment_9.png)\n\n## Next.js의 장점 - TypeScript Best Practice\n\nNext.js와 TypeScript를 결합하면 강력한 유형 시스템을 제공하여 코드 가독성과 유지 관리성을 향상시킬 수 있습니다. 이는 개발 중에 오류를 잡는 데 도움이 되며 이 조합은 더 견고하고 신뢰할 수 있는 애플리케이션을 만드는 데 기여할 수 있습니다. 또한 Next.js에서 TypeScript를 사용하면 더 나은 코드 구성 및 확장성을 구현할 수 있어 더 큰 코드베이스를 관리하고 개발팀 간 협업을 더 쉽게 할 수 있습니다.\n\n참고문헌\n","ogImage":{"url":"/assets/img/2024-07-07-MasteringNextjsBestPracticesforCleanScalableandType-SafeDevelopment_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-MasteringNextjsBestPracticesforCleanScalableandType-SafeDevelopment_0.png","tag":["Tech"],"readingTime":20},{"title":"프로그래밍 언어를 만드는 데 얼마나 많은 작업이 필요할까","description":"","date":"2024-07-07 21:54","slug":"2024-07-07-HowMuchWorkDoesItTaketoBuildaProgrammingLanguage","content":"\n## 언어 생성을 시도해보세요! 왜냐하면 왜 안되겠어요\n\n\"이 책은 고전입니다. 존중하며 다루세요\".\n\n15년 전, 어린 시절 컴파일러를 만들게 된 이래팀의 구조 설계자가 나에게 드래곤 북을 건넬 때 이렇게 말했다. 아쉽게도 그 책을 읽다가 밤에 잠이 들어 바닥에 넘어뜨리고 말았다. 반납할 때 표지에 작은 흠이 살짝 들어간 것을 발견하지 않길 바라며.\n\n![이미지](/TIL/assets/img/2024-07-07-HowMuchWorkDoesItTaketoBuildaProgrammingLanguage_0.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저는 1986년에 쓰인 책을 읽었어요. 당시 컴파일러 만들기는 굉장히 어려웠고, 컴퓨터 과학과 프로그래밍 기술을 많이 담았습니다. 거의 4십 년 후인 지금, 다시 일에 착수하려고 해요. 요즘에는 어떨까요? 언어를 만드는 데 필요한 것들과 현대 도구들이 얼마나 단순해졌는지 살펴보도록 하죠.\n\n# 대상 언어\n\n모든 것을 납득시키기 위해 구체적인 언어가 필요해요. 아주 작은 기능 세트만을 사용해서 보여주기 위해, ZenStack에서 개발 중인 ZModel 언어를 예시로 사용할 거에요. 이 언어는 데이터베이스 테이블과 접근 제어 규칙을 모델링하는 데 사용되는 DSL입니다. 글을 짧게 유지하기 위해 다음 코드 조각만 사용하여 예시를 보여줄 거에요.\n\n```js\nmodel User {\n  id Int\n  name String\n  posts Post[]\n}\n\nmodel Post {\n  id Int\n  title String\n  author User\n  published Boolean\n\n  @@allow('read', published == true)\n}\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n간단한 메모:\n\n- 모델 구문은 데이터베이스 테이블을 나타냅니다. 그 필드는 테이블 열에 매핑됩니다.\n- 모델은 서로를 참조하여 관계를 형성할 수 있습니다. 위의 예시에서 User 및 Post 모델은 일대다 관계를 형성합니다.\n- @@allow 구문은 액세스 제어 규칙을 나타냅니다. 두 가지 인수를 전달합니다: 하나는 액세스 유형(\"create\", \"read\", \"update\", \"delete\" 또는 \"all\"), 다른 하나는 해당 액세스를 허용해야 하는지를 나타내는 부울 식입니다.\n\n여기까지입니다. 자, 소매 소매한 작업할 시간입니다!\n\n# 여섯 단계로 언어 만들기\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 단계 1: 텍스트에서 구문 트리로\n\n컴파일러를 구축하는 일반적인 단계는 몇 년 동안 크게 변하지 않았어요. 먼저 텍스트를 \"토큰\"으로 쪼개는 렉서(lexer)가 필요하고, 그런 다음 파서(parser)가 토큰의 스트림을 \"구문 분석 트리\"로 구성해야 해요. 고수준 언어 구축 도구는 이 두 단계를 결합하고 텍스트에서 트리로 한 번에 전환할 수 있도록 해줘요.\n\n우리는 Langium OSS 툴킷을 사용하여 언어를 구축하는 데 도움을 받았어요. 이것은 TypeScript를 기반으로 한 훌륭한 언어 공학 도구로 전체적인 언어 구축 프로세스를 간소화해줘요. Langium은 렉싱 및 파싱 규칙을 정의하기 위한 직관적인 DSL을 제공해요.\n\n우리의 ZModel 언어 구문은 다음과 같이 형식화될 수 있어요:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n/*\nLangium 언어로 번역한 내용입니다.\n\nZModel 문법\n\n시작 스키마:\n    (모델+=모델)*;\n\n모델:\n    '모델' 이름=아이디 '{'\n        (필드+=필드)+\n        (규칙+=규칙)*\n    '}';\n\n필드:\n    이름=아이디 타입=(유형 | 모델참조) (배열?='[' ']')?;\n\n모델참조:\n    대상=[모델];\n\n유형 반환 문자열:\n    'Int' | 'String' | 'Boolean';\n\n규칙:\n    '@@허용' '('\n        접근유형=문자열 ',' 조건=조건\n    ')';\n\n조건:\n    필드=단순식 '==' 값=단순식;\n\n단순식:\n    필드참조 | 부울;\n\n필드참조:\n    대상=[필드];\n\n부울 반환 불리언:\n    'true' | 'false';\n\n숨겨진 종결 WS: /\\s+/;\n종결 아이디: /[_a-zA-Z][\\w_]*/;\n종결 문자열: /\"(\\\\.|[^\"\\\\])*\"|'(\\\\.|[^'\\\\])*'/;\n*/\n텍스트를 토큰으로 분할하는 렉싱 규칙이 있는 표입니다. 간단한 언어이므로 식별자(ID)와 문자열(STRING) 토큰만 있습니다. 공백은 무시됩니다.\n\n나머지 규칙은 구문 분석 규칙입니다. 토큰 스트림을 트리로 어떻게 구성해야 하는지를 결정합니다. 파서 규칙은 렉싱 프로세스에 참여하는 키워드(Int, @@허용 등)도 포함할 수 있습니다. 복잡한 언어의 경우 재귀적 구문 분석 규칙(예: 중첩된 표현)이 필요할 수 있지만 이 간단한 예제에는 그런 내용이 없습니다.\n\n언어 규칙이 준비되었으므로 Langium API를 사용하여 코드 스니펫을 다음 파스 트리로 변환할 수 있습니다.\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/TIL/assets/img/2024-07-07-HowMuchWorkDoesItTaketoBuildaProgrammingLanguage_1.png\" />\n\n## 단계 2: 구문 트리에서 링크드 트리로\n\n파스 트리는 소스 파일의 의미론을 이해하는 데 매우 도움이 됩니다. 그러나 종종 더 완전하게 만들기 위해 한 단계를 더 진행해야 합니다.\n\n우리의 ZModel 언어는 \"교참조\"를 허용합니다. 예를 들어, User 모델의 posts 필드는 Post 모델을 참조합니다. 그리고 Post 모델은 다시 author 필드를 통해 참조를 합니다. 파스 트리를 탐색할 때, ModelReference 노드에 도달하면 \"Post\"라는 이름을 참조하는 것을 볼 수 있지만 그 의미를 직접 알 수 없습니다. 일치하는 이름의 모델을 찾기 위해 즉석 조회를 할 수 있지만, 보다 체계적인 접근법은 \"링킹\" 패스를 수행하여 모든 이러한 참조를 해결하고 해당 노드에 링크하는 것입니다. 이러한 링킹이 완료되면, 우리의 파스 트리는 다음과 같이 보입니다 (간략함을 위해 일부 트리만 표시됨):\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Image](/TIL/assets/img/2024-07-07-HowMuchWorkDoesItTaketoBuildaProgrammingLanguage_2.png)\n\n기술적으로 말하면 그것은 트리가 아닌 그래프이지만, 관례상 파스 트리라고 계속 부르겠습니다.\n\nLangium의 장점 중 하나는 대부분의 경우 도구가 링킹 패스를 자동으로 수행한다는 것입니다. 파싱된 노드의 중첩 계층 구조를 따라서 이름을 해결하고 적절한 대상 노드에 링크할 때 사용합니다. 복잡한 언어의 경우 특별한 해결 동작이 필요한 경우가 있을 수 있습니다. Langium은 여러 서비스를 사용자 정의로 구현하여 링킹 프로세스에 연결할 수 있도록 해 줌으로써 이를 쉽게 만들어 줍니다.\n\n## 단계 3. 연결된 트리에서 의미론적 정확성으로\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n컴파일러는 입력 소스 파일에 렉서 또는 파서 오류가 포함되어 있으면 오류를 보고하고 중단합니다.\n\n```js\nmodel {\n  id\n  title String\n}\n```\n\n```js\n'ID' 유형의 토큰을 예상했지만 `{`를 발견했습니다. [Ln1, Col7]\n```\n\n그러나 이러한 오류가 없어도 코드가 의미론적으로 올바르다는 뜻은 아닙니다. 예를 들어, 아래 내용은 구문적으로 유효하지만 의미론적으로 잘못되었습니다. title을 true와 비교하는 것은 말이 되지 않습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n모델 Post {\n  id Int\n  title String\n  author User\n  published Boolean\n\n  @@allow('read', title == true) // <- 비교가 잘못되었습니다\n}\n```\n\n의미론적 규칙은 보통 언어별로 다르며, 도구들은 거의 자동적으로 아무것도 할 수 없습니다. Langium이 이를 처리하는 방법은 다양한 노드 유형을 유효성 검증할 수 있는 후크를 제공하는 것입니다.\n\n```js\nexport function registerValidationChecks(services: ZModelServices) {\n  const registry = services.validation.ValidationRegistry;\n  const validator = services.validation.ZModelValidator;\n  const checks: ValidationChecks<ZModelAstType> = {\n    SimpleExpression: validator.checkExpression,\n  };\n  registry.register(checks, validator);\n}\n\nexport class ZModelValidator {\n  checkExpression(expr: SimpleExpression, accept: ValidationAcceptor) {\n    if (isFieldReference(expr) && expr.target.ref?.type !== \"Boolean\") {\n      accept(\"error\", \"Only boolean fields are allowed in conditions\", {\n        node: expr,\n      });\n    }\n  }\n}\n```\n\n이제 의미론적 문제에 대한 좋은 오류를 얻을 수 있습니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n오직 불리언 필드만 조건문에서 허용됩니다 [Ln 7, Col 19]\n\n렉싱, 파싱, 링킹과는 달리, 의미 체크 프로세스는 매우 선언적이거나 체계적이지 않습니다. 복잡한 언어의 경우, 명령적 코드로 많은 규칙을 작성하게 될 것입니다.\n\n![Programming Language](/TIL/assets/img/2024-07-07-HowMuchWorkDoesItTaketoBuildaProgrammingLanguage_3.png)\n\n## 4단계. 개발자 경험 향상\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n요즘에는 개발 도구를 만드는 데 기준이 높습니다. 혁신은 탁월하게 작동할 뿐만 아니라 탁월한 느낌을 주어야 번창할 수 있어요. 언어와 컴파일러 관점에서, DX는 주로 세 가지로 이루어져 있어요:\n\n- IDE 지원\n  좋은 IDE 지원 — 구문 강조, 서식 지정, 자동 완성 등 — 은 학습 곡선을 크게 낮추고 개발자의 삶의 질을 향상시킵니다. Langium에 대해 좋아하는 점 중 하나는 Language Server Protocol을 내장 지원한다는 것이에요. 구문 분석 규칙과 유효성 검사가 자동으로 적절한 기본 LSP 구현이 되어서 VSCode와 최신 JetBrains IDE와 직접 작동합니다(일부 제한 사항이 있을 수 있습니다). 그러나 탁월한 IDE 경험을 제공하기 위해서는 Langium에 의한 LSP 관련 서비스의 기본 구현을 많이 수정하여 광택을 내야 할 필요가 있습니다.\n\n![이미지](/TIL/assets/img/2024-07-07-HowMuchWorkDoesItTaketoBuildaProgrammingLanguage_4.png)\n\n- 오류 보고\n  귀하의 유효성 검사 로직은 많은 경우 오류 메시지를 생성할 것이며, 이 메시지의 정확성과 유용성은 개발자가 얼마나 빨리 이해하고 이를 수정할 수 있는지를 크게 결정할 것입니다.\n- 디버깅\n  귀하의 언어가 \"작동\"하는 경우(더 자세한 내용은 다음 섹션을 참조하세요), 디버깅 경험이 필수적입니다. 디버깅이란 어떤 것을 의미하는지는 언어의 성격에 따라 다릅니다. 그것이 명령문과 제어 흐름을 포함하는 명령형 언어면 단계별 진행 및 상태 검사가 필요할 것입니다. 또는 선언적 언어인 경우, 디버깅은 복잡성(규칙, 표현식 등)을 해결하는 데 도움이 되는 시각화를 의미할 것입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 단계 5. 유용하게 만들기\n\n결정된 오류가 없는 파스 트리를 도출하는 것은 상당히 멋지지만, 그 자체로는 그리 유용하지 않습니다. 여러 가지 방법을 사용하여 추후 진행하고 실제 값으로 생성할 수 있습니다:\n\n- 여기서 그만 두기\n  여기서 멈출 수도 있고, 파스 트리를 결과물로 선언하고 사용자가 이를 어떻게 사용할지 결정하도록 할 수도 있습니다.\n- 다른 언어로 변환하기\n  언어는 종종 파스 트리를 하위 수준의 언어로 변환하는 \"백엔드\"를 갖습니다. 예를 들어, Java 컴파일러의 백엔드는 JVM 바이트 코드를 생성합니다. TypeScript의 백엔드는 Javascript 코드를 생성합니다. ZenStack에서는 ZModel을 Prisma 스키마 언어로 변환합니다. 그런 다음 대상 언어의 도구/런타임이 이를 입력으로 사용할 수 있게 됩니다.\n- 플러그 가능한 변환 메커니즘 구현하기\n  언어 사용자가 자체 백엔드 변환을 제공할 수 있도록 플러그인 메커니즘을 구현할 수도 있습니다. 이것은 #1을 수행하는 보다 구조화된 방법입니다.\n- 파스 트리를 실행하는 런타임 구축하기\n  언어를 구축하는 가장 \"완전한\" 루트입니다. 구문 분석된 코드를 \"실행\"하는 인터프리터를 구현할 수 있습니다. \"실행\"이 의미하는 바는 완전히 사용자에게 달려있습니다. ZenStack에서는 ZModel을 Prisma 스키마 언어로 변환하는 것 외에도 데이터 액세스 중에 접근 제어 규칙을 강제하는 런타임이 있습니다.\n\n## 단계 6. 사용하기 좋게 만들기\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n축하합니다! 이제 자신을 칭찬해도 좋습니다. 왜냐하면 새로운 언어를 만드는 일의 20%를 완료했기 때문이죠. 혁신은 대부분 사람들에게 판매하는 것이 가장 어려운 부분이라는 것을 잊지 마세요. 심지어 무료일 때도요. 언어를 개발한 건 개인적으로나 팀 내부에서만 사용할 예정이라면 그만두는 것도 좋지만, 대중을 대상으로 한다면 열심히 마케팅해야 합니다. 그것이 나머지 80%의 작업을 차지하죠 😄.\n\n# 마지막으로\n\n컴파일러 구축은 소프트웨어 엔지니어링이 지난 몇 십 년 동안 빠르게 발전했기 때문에 고대 예술처럼 느껴집니다. 그럼에도 불구하고, 진지한 개발자가 독특한 경험을 쌓기 위해 시도해볼 만한 분야라고 생각합니다. 프로그래밍의 이중성을 아주 잘 반영하죠 — 미학과 실용주의. 훌륭한 소프트웨어 시스템은 일반적으로 우아한 개념 모델을 갖추고 있지만, 표면 아래에서 그다지 예쁘지 않은 다양한 개선 사항을 찾을 수도 있습니다.\n\n왜냐면 언어를 만들어보는 것이 어떨까요? 😊\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![ZenStack](/TIL/assets/img/2024-07-07-HowMuchWorkDoesItTaketoBuildaProgrammingLanguage_5.png)\n\nZenStack를 개발 중입니다. 이 툴킷은 Prisma ORM을 강력한 엑세스 제어 계층과 함께 사용하여 풀스택 개발을 위한 최대한의 잠재력을 발휘합니다. 만약 이 프로젝트가 흥미로우시다면 읽어 주셨던 분들 중 별을 눌러 주시면 더 많은 분들이 찾아볼 수 있도록 도와주세요!\n","ogImage":{"url":"/assets/img/2024-07-07-HowMuchWorkDoesItTaketoBuildaProgrammingLanguage_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-HowMuchWorkDoesItTaketoBuildaProgrammingLanguage_0.png","tag":["Tech"],"readingTime":11},{"title":"TypeScript 제네릭 이해하기 쉽게 정리하기","description":"","date":"2024-07-07 21:53","slug":"2024-07-07-MakingsenseofTypeScriptgenerics","content":"\n<img src=\"/TIL/assets/img/2024-07-07-MakingsenseofTypeScriptgenerics_0.png\" />\n\nTypeScript는 JavaScript 개발을 혁신적으로 개선했습니다. 코드 신뢰성과 유지 보수성을 향상시키며 개발자들에게 더 적은 런타임 오류를 보장하고 생산성을 높여줍니다.\n\n하지만 TypeScript를 사용하기 시작하면 구문이 약간 압도적일 수 있습니다.\n\nTypeScript에서 가장 두려운 기능 중 하나는 \"제네릭\"입니다. 아래 예제를 보세요 🤯 두려워하지 않으시죠?\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/TIL/assets/img/2024-07-07-MakingsenseofTypeScriptgenerics_1.png\" />\n\n그러나 걱정하지 마세요. 단계별로 진행하겠습니다. 제네릭을 이해하면 얼마나 강력한지 알게 될 거예요.\n\n# 최적의 any 대안\n\n이 아주 간단한 JavaScript 함수를 상상해보세요. 이 함수는 배열의 첫 번째 요소를 반환합니다. (네, 제가 동의합니다. 이 함수는 그다지 유용하지 않지만 설명을 위해서입니다).\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/TIL/assets/img/2024-07-07-MakingsenseofTypeScriptgenerics_2.png\" />\n\n어떻게 타입을 지정할까요? 🤔 배열의 타입은 무엇이어야 할까요? 이 함수에서는 어떤 것이든 들어갈 수 있는 배열일 수 있습니다 (문자열, 숫자, 객체). 따라서 유혹받아 \"any\"라는 이름을 부를 수 없는 타입으로 지정하는 것이 유혹스러울 수 있습니다 😱\n\n<img src=\"/TIL/assets/img/2024-07-07-MakingsenseofTypeScriptgenerics_3.png\" />\n\n하지만 이는 매우 나쁜 타이핑입니다. 왜냐하면 TypeScript가 이 함수의 반환 타입을 올바르게 추론할 수 없기 때문입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/TIL/assets/img/2024-07-07-MakingsenseofTypeScriptgenerics_4.png)\n\n어쨌든, 우리가 가능한 모든 다른 유형들을 지정할 수 있을까요?\n\n![이미지](/TIL/assets/img/2024-07-07-MakingsenseofTypeScriptgenerics_5.png)\n\n좋은 생각이 아닙니다. 먼저, 이 함수에 대한 가능한 모든 유형의 큰 목록을 유지해야 한다는 점 때문입니다. 그리고 무엇보다 중요한 것은 이 추론 문제를 해결하지 못한다는 것입니다. TypeScript는 함수를 호출할 때 유형을 추측할 수 없을 만큼 똑똑하지 않습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그럼 TypeScript에서 as를 사용해 캐스팅하는 것을 도와줄 수 있을 것 같네요!\n\n![image](/TIL/assets/img/2024-07-07-MakingsenseofTypeScriptgenerics_6.png)\n\n하지만 그렇게 하는 건 이기적인 행동이에요! 이 타입 어설션으로 TypeScript에게 말하는 건, \"타입 검사를 멈추고 나를 믿어, 내가 뭐 하는 지 안다\"고 하는 거예요. 이렇게 하면 타입 안전성이 약화되고, TypeScript를 사용하는 핵심 목적이 퇴색됩니다.\n\n그렇게 하지 마세요! 이걸 타입하는 더 안전하고 깨끗한 방법이 있어요.\n이름이 뭐라고 생각하시나요? ✨ 제네릭스✨\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 제네릭 소개\n\n이전 예제를 계속해 봅시다.\n\n우리가 함수에 전달하고 싶은 내용은 \"파라미터로 '무엇인가'의 배열을 받고, '무엇인가' 요소를 반환할 것\"이라고 말하는 것입니다.\n\n그것이 바로 제네릭이란 것입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이렇게 보일 것입니다:\n\n<img src=\"/TIL/assets/img/2024-07-07-MakingsenseofTypeScriptgenerics_7.png\" />\n\n이 코드의 일부를 자세히 살펴보겠습니다:\n\n🟣 이전처럼 매개변수를 any[]로 입력하는 대신, 우리는 제네릭을 사용하여 매개변수를 정의합니다: 우리는 그것을 SomeType이라고 이름 짓겠습니다. 제네릭은 타입 자체가 아니라 타입 매개변수로, 함수가 호출될 때 지정될 타입을 나타내는 자리 표시자입니다. 당신은 원하는 대로 이름을 지을 수 있습니다(예약어나 이미 가져온 타입 이름이 아닌 경우). 우리는 종종 T와 같은 단일 문자를 제네릭으로 사용합니다. TypeScript에게 \"이 함수는 어떤 타입의 배열을 매개변수로 받을 것\"이라고 알립니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n🟢 이것은 함수의 반환 유형을 지정합니다. Typescript에게 \"함수가 매개 변수 배열의 요소와 동일한 유형의 요소를 반환할 것\"이라고 말하는 것입니다.\n\n🟡 함수 괄호 앞의 이 부분은 이 함수에서 사용할 일반적인 요소를 각괄호 안에 나열한 것입니다. 여기서는 하나의 일반적인 (SomeType)만 사용하게 될 것이지만, 나중에 여러 개의 일반적인을 사용할 수 있다는 것을 보여 드리겠습니다.\n\n우리가 일반적인을 사용하여 함수를 입력한 방식은 단지 \"매개 변수가 어떤 유형의 배열이며, 함수가 이와 동일한 유형으로 반환될 것\"이라는 뜻입니다.\n\n이 함수를 작성하는 더 일반적인 방법은 T를 사용하는 것입니다 (문법이 덜 복잡하게 보이도록).\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/TIL/assets/img/2024-07-07-MakingsenseofTypeScriptgenerics_8.png\" />\n\n이 소개가 제네릭의 본질을 이해하는 데 도움이 되기를 바랍니다.\n\n# 제네릭은 어디에나 있어요\n\n이미 TypeScript를 사용해 보셨다면, 모르는 사이에 제네릭을 사용해 본 적이 있을 겁니다. 예를 들어 DOM API의 querySelector 함수를 생각해 보세요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/TIL/assets/img/2024-07-07-MakingsenseofTypeScriptgenerics_9.png\" />\n\n이 예에서 querySelector는 반환된 요소가 HTMLElement 유형인지를 보장하기 위해 제네릭을 사용합니다. 이 유형 정보는 TypeScript가 반환된 요소에 대한 정확한 자동완성 및 유형 확인을 제공할 수 있도록 합니다. TypeScript에서 HTMLElement와 같은 네이티브 유형은 표준 라이브러리의 타입 선언인 lib.dom.d.ts에 의해 정의됩니다.\n\n제네릭을 사용하면 요소를 다음과 같이 처리할 수 있습니다:\n\n<img src=\"/TIL/assets/img/2024-07-07-MakingsenseofTypeScriptgenerics_10.png\" />\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이렇게 제네릭을 사용하지 않은 경우와의 차이는 다음과 같습니다:\n\n<img src=\"/TIL/assets/img/2024-07-07-MakingsenseofTypeScriptgenerics_11.png\" />\n\n제네릭 타입을 사용하지 않으면 TypeScript는 요소의 특정 타입을 알 수 없어서 도움이 되는 자동완성을 받을 수 없으며 오류가 발생할 수 있습니다 (캐스팅을 통해 수정 가능하지만 여전히 좋은 아이디어는 아닙니다).\n\n제네릭을 사용하면 TypeScript가 작업 중인 요소의 정확한 종류를 이해할 수 있기 때문에 더 나은 타입 안전성과 개발자 경험을 제공합니다. 따라서 제네릭이 네이티브 API 및 라이브러리에서 널리 사용되는 것은 놀라운 일이 아닙니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 제네릭을 더 깊게 파헤쳐보기\n\n제네릭은 단순한 함수에만 국한되지 않습니다. 더 유연하고 재사용 가능한 코드를 만들기 위해 다양한 방법으로 사용할 수 있습니다.\n\n심도 있는 예시를 살펴보겠습니다. 첫 번째 요소를 가져오는 것보다 실제 세계의 문제에 더 가까운 예제를 살펴보겠습니다. API 응답을 다루는 예시입니다.\n\n다음 코드를 살펴봅시다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/TIL/assets/img/2024-07-07-MakingsenseofTypeScriptgenerics_12.png)\n\nApiResponse 유형을 정의합니다. 이 유형은 항상 숫자 상태, 문자열 메시지 및 모든 유형의 데이터를 반환합니다.\n\n그러나 본문의 첫 부분에서 본 것처럼 any를 사용하는 것은 유형을 올바르게 추론하지 못하게 합니다.\n\n제네릭을 사용하여 그것을 개선해 봅시다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Image](/TIL/assets/img/2024-07-07-MakingsenseofTypeScriptgenerics_13.png)\n\n이 코드에 조금 더 가까이 들어가 봅시다.\n\n🟡 먼저, 여기서 새로운 구문을 볼 수 있습니다. 이것은 제네릭 형식입니다. 제네릭을 사용하는 유형을 정의하고 있습니다. 이전에 본 함수 예제와 비슷하게 작동합니다:\n\n- 꺽쇠 괄호 내에서 사용된 제네릭을 나열합니다.\n- 제네릭을 유형 정의 내에서 사용합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n🟣 이제는 이 타입을 사용할 때마다, T의 타입을 각괄호 안에 명확하게 지정해야 합니다. 이 fetch에 대한 API 응답 데이터가 ' name: string; age: number ' 타입임을 명시하고 있습니다. 이것은 타입 인자입니다.\n\n그리고 이제, fetchData 함수가 잘 타입화되었으므로 TypeScript가 해당 반환 타입을 올바르게 추론할 수 있습니다.\n\n# 일반화 제한하기\n\n가끔, 제네릭이 모든 타입을 허용하지 않고 더 많은 제약이 있는 상태로 제한하고 싶은 경우가 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAPI 응답의 예제를 계속 사용하면 데이터가 항상 객체여야하고 그 외의 것들이 들어가지 않아야 합니다.\n\n`extends` 키워드를 사용하여 가능합니다.\n\n![image](/TIL/assets/img/2024-07-07-MakingsenseofTypeScriptgenerics_14.png)\n\n만약 객체가 아닌 다른 것으로 함수를 호출하려고 하면 TypeScript에서 오류가 발생합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n특정 속성을 갖는 객체를 제약하는 방법도 있습니다. 예를 들어 API 데이터가 항상 id를 포함하는 객체여야 하는 경우:\n\n![이미지](/TIL/assets/img/2024-07-07-MakingsenseofTypeScriptgenerics_15.png)\n\n# 제네릭을 위한 기본 타입\n\n제네릭의 또 다른 멋진 기능은 기본 타입을 제공할 수 있다는 것입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지금까지 본 모든 예제에서 우리는 제네릭 타입을 사용할 때 type 인자를 명확히 지정해야 했습니다. 예를 들어: ApiResponse`' name: string; age: number '`.\n\n그러나 만약 당신이 자주 동일한 타입을 제네릭에 사용한다면, 타입 정의에서 =로 기본값을 지정할 수 있습니다.\n\n![image](/TIL/assets/img/2024-07-07-MakingsenseofTypeScriptgenerics_16.png)\n\n심지어 제약 조건과 함께 사용할 수도 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/TIL/assets/img/2024-07-07-MakingsenseofTypeScriptgenerics_17.png\" />\n\n# 여러 제네릭\n\n가끔은 한 가지 제네릭만으로는 부족하고 2개 이상이 필요할 때가 있습니다.\n\n꺽쇠 괄호 안에 제네릭을 콤마로 구분하여 나열하면 됩니다. 함수를 호출할 때도 타입 인자를 동일하게 나열해 주세요.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n한 예시를 살펴보겠습니다:\n\n![generics](/TIL/assets/img/2024-07-07-MakingsenseofTypeScriptgenerics_18.png)\n\n제네릭은 처음에는 무서울 수 있지만, 이들이 어떻게 작동하는지 이해하면 그들의 힘을 빨리 깨닫고 TypeScript 생태계의 중심에 왜 있는지 이해하게 됩니다.\n\n함수와 컴포넌트가 다양한 유형으로 작동할 수 있도록 허용하면서도 강한 유형 안전성을 유지함으로써, TypeScript 제네릭은 견고하고 유지 관리가 용이한 코드를 작성하는 능력을 크게 향상시키며 개발자 경험을 놀라운 것으로 만들어 줍니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n행복한 코딩하세요!\n","ogImage":{"url":"/assets/img/2024-07-07-MakingsenseofTypeScriptgenerics_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-MakingsenseofTypeScriptgenerics_0.png","tag":["Tech"],"readingTime":12},{"title":"Angular의 inject 함수 사용으로 1000줄의 코드를 절약한 방법","description":"","date":"2024-07-07 21:51","slug":"2024-07-07-HowUsingAngularsinjectFunctionHasSavedMe1000LinesofCode","content":"\n# inject() 함수란 무엇인가요?\n\nAngular 14에서 소개된 inject() 함수는 서비스, 컴포넌트, 디렉티브 등에 종속성을 주입하는 데 사용됩니다. 클래스 생성자를 사용하여 종속성을 주입하는 대신 inject() 함수를 사용할 수 있습니다.\n\n![이미지](/TIL/assets/img/2024-07-07-HowUsingAngularsinjectFunctionHasSavedMe1000LinesofCode_0.png)\n\n## 생성자를 사용하여 종속성을 주입하는 예전 방식:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport { Component } from '@angular/core';\n\n@Component({ /* ... */ })\nexport class MyComponent {\n  constructor(\n    @Inject(SOME_TOKEN) private readonly someToken: string,\n    private readonly myService: MyService,\n    private readonly httpClient: HttpClient,\n  ) {}\n}\n```\n\n## inject() 함수를 사용한 의존성 주입의 새로운 방법:\n\n```js\nimport { Component, inject } from '@angular/core';\n\n@Component({ /* ... */ })\nexport class MyComponent {\n  private readonly someToken = inject(SOME_TOKEN);\n  private readonly myService = inject(MyService);\n  private readonly httpClient = inject(HttpClient);\n}\n```\n\n# inject() 사용의 장점 vs 생성자 사용하기\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n주목하신 대로, 생성자 대신 inject()을 사용하는 것에는 여러 가지 장점이 있습니다:\n\n- 코드를 더 깔끔하고 가독성이 좋고 일관성 있게 만듭니다 (토큰 vs 서비스 주입 시에도)\n- 타입이 자동으로 추론되어 수동으로 지정할 필요가 없습니다\n- 상속이 간편하고 덜 장황합니다 (자세한 내용은 아래에서 설명)\n\n# 더 나은 상속\n\n저는 상속과 관련된 경우 inject() 함수가 특히 유용하다고 생각합니다. 코드를 재사용하고 여러 자식 클래스에 의해 확장될 부모 서비스 추상 클래스가 있는 시나리오를 고려해 보세요:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nexport abstract class ParentService {\n  constructor(\n    protected readonly configKey: string,\n    protected readonly httpClient: HttpClient,\n    protected readonly helperService: HelperService,\n  ) {}\n\n  // ... some code here that will be reused in the children of ParentService\n}\n```\n\nParentService의 하위 클래스는 다음과 같이 확장됩니다:\n\n```js\n@Injectable({ providedIn: 'root' })\nexport class ChildService extends ParentService {\n  constructor(\n    protected readonly httpClient: HttpClient,\n    protected readonly helperService: HelperService,\n  ) {\n    super('my-config-key', httpClient, helperService);\n  }\n\n  // ... some child-specific code here\n}\n```\n\n보시다시피 많은 반복이 있습니다: 모든 자식 클래스들은 HttpClient와 HelperService를 가져와야 하는데 이는 ParentService의 생성자가 필요하기 때문입니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\ninject() 함수 덕분에 이 불필요한 반복을 피할 수 있어요:\n\n```js\nexport abstract class ParentService {\n  protected abstract readonly configKey: string; // \"abstract\"을 사용하여 자식 클래스가 이 필드를 초기화하도록 강제합니다\n  protected readonly httpClient = inject(HttpClient);\n  protected readonly helperService = inject(HelperService);\n\n  // ... 부모 서비스의 자식에서 재사용될 코드가 있습니다 ...\n}\n\n@Injectable({ providedIn: 'root' })\nexport class ChildService extends ParentService {\n  protected readonly configKey = 'my-config-key';\n\n  // ... 자식에만 해당하는 코드가 있습니다\n}\n```\n\n결과적으로 코드가 훨씬 깔끔해지고 반복을 피할 수 있습니다: ParentService의 자식들은 HttpClient 및 HelperService를 가져와 부모에게 전달할 필요가 없지만, 필요한 경우에 this.httpClient 및 this.helperService에 액세스 할 수 있습니다.\n\n의존성이 많고 많은 자식이 기본 클래스를 확장하는 시나리오를 상상해보세요, inject()를 사용하면 많은 코드 라인을 절약할 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 실제 사용 사례 예\n\n2019년에 Angular을 사용하여 구축한 오래된 프로젝트를 리팩토링할 때 inject() 함수를 사용했습니다. 생성자를 없애거나 사용을 줄이는 것만으로 약 1000줄 이상의 코드를 제거할 수 있었습니다. 변경 내용은 이 커밋에서 확인할 수 있습니다.\n\n네, 무엇을 생각하고 계시는지 알겠어요. 상속 대신 구성을 고려해볼 수 있었다는 주장을 할 수 있겠지만, 이에 대한 논의는 이 글의 범위를 벗어납니다.\n\n# 결론\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- inject() 함수는 일반적으로 생성자를 사용하는 것보다 선호되는 의존성을 효율적이고 현대적인 방법으로 주입해주는 기능을 제공합니다.\n- inject()를 사용하도록 코드베이스를 마이그레이션하는 것이 쉽고, 특히 상속을 다루어야 할 때 유용할 것입니다.\n- 기존 레거시 프로젝트에서도 gradually(점진적으로) inject()를 채택할 수 있으며, 코드베이스를 한꺼번에 마이그레이션할 필요가 없습니다.\n","ogImage":{"url":"/assets/img/2024-07-07-HowUsingAngularsinjectFunctionHasSavedMe1000LinesofCode_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-HowUsingAngularsinjectFunctionHasSavedMe1000LinesofCode_0.png","tag":["Tech"],"readingTime":5},{"title":"서버리스 인증 자가 서비스 플랫폼 구축 방법","description":"","date":"2024-07-07 21:49","slug":"2024-07-07-ServerlessAuthSelf-ServePlatform","content":"\n<img src=\"/TIL/assets/img/2024-07-07-ServerlessAuthSelf-ServePlatform_0.png\" />\n\n## 서문\n\n🌟 Amazon Cognito 머신 간 인증 흐름이 무엇인지 다루고 있습니다.\n🌟 중앙 집중식 인증 플랫폼의 필요성을 살펴봅니다.\n🌟 기본 예제 프론트엔드 UI를 통해 진행합니다.\n🌟 전체적인 AWS 아키텍처에 대해 이야기합니다.\n🌟 TypeScript와 AWS CDK 코드를 통해 진행 과정을 설명합니다.\n\n# 소개 👋🏽\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n조직 내에서는 많은 다른 팀이 보안적으로 외부 시스템 및 제3자 API에 로드되어야 하는 경우가 거의 항상 발생합니다. 일반적으로 각 팀이 자체 인증 서버를 생성해야 하고 OAuth 2.0 클라이언트 자격 증명 흐름이 어떻게 작동하는지 파악해야 하는 작업이 진행됩니다.\n\n본 문서에서는 우리가 어떻게 중앙 회사 인증 서비스를 생성할 수 있는지에 대해 다룰 것입니다. Amazon Cognito를 기반으로 개발자가 스스로 서비스를 이용할 수 있는 포털을 가지고 있는 이 서비스를 통해 회사 내의 모든 팀이 자신들의 서드파티 소비자를 위한 액세스 토큰 구성을 빠르게 만들 수 있습니다.\n\n컨텐츠를 이해하기 쉽게 하기 위해, TypeScript 및 AWS CDK를 사용하여 가상의 'LJ Health Food' 회사의 완벽한 솔루션 코드 예제를 생성할 것입니다. 이 회사는 건강식품 배달 회사이지만 Uber Eats나 Just Eat과 같은 서드파티 통합을 통해 주문을 받을 수도 있습니다.\n\n![이미지](/TIL/assets/img/2024-07-07-ServerlessAuthSelf-ServePlatform_1.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기에서 완전한 솔루션 코드 예제를 찾을 수 있습니다:\n\n이 예제에서는 3rd party 서비스가 자사의 앱을 통해 주문을 배치하는 내용에 대해 리더십팀과 회의를 가졌습니다. 그들은 동의하고, 엔지니어링 팀은 통합 과정을 시작합니다.\n\n![image](/TIL/assets/img/2024-07-07-ServerlessAuthSelf-ServePlatform_2.png)\n\n이를 위해 우리는 그들을 신뢰할 수 있는 클라이언트로 설정하고, 다른 서비스가 주문을 배치할 수 있는 부분에만 액세스할 수 있도록 권한을 부여해야 합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Image](/TIL/assets/img/2024-07-07-ServerlessAuthSelf-ServePlatform_3.png)\n\n이 특정 인가 플로우를 통해 이 신뢰가 어떤 모습인지 살펴보겠습니다.\n\n👇 더 나아가기 전에 — 향후 블로그 포스트와 서버리스 뉴스에 대해 연결하려면 LinkedIn에서 저와 연락해주세요. https://www.linkedin.com/in/lee-james-gilmore/\n\n![Image](/TIL/assets/img/2024-07-07-ServerlessAuthSelf-ServePlatform_4.png)\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 중앙 집중식 인증이 필요한 이유 🛡️\n\n더 진행하기 전에, 회사 내에서 자체 서비스 스타일 포털을 통해 인증을 중앙 집중화해야 하는 이유는 무엇일까요? 그렇지 않으면 일반적으로 다음과 같은 문제가 발생합니다:\n\n- 각 프로젝트/서비스에 대한 액세스 토큰을 위한 인증 서버를 설정해야 하는 팀들에게 높은 인지 부하가 발생합니다.\n- OAuth 2.0 클라이언트 인증 흐름이 어떻게 작동하는지 이해해야 하는 데 높은 인지 부하가 발생합니다 (이에 대해 나중에 더 다룰 것입니다).\n- Amazon Cognito의 UI는 매우 복잡하며 필요하지 않은 많은 기능이 포함되어 있습니다. 우리는 자체 UI에서 이것을 제거함으로써 이런 소음을 최소화할 수 있습니다 (필요한 기능만 표시).\n- 보안 팀이 처리해야 하는 포인트가 더 많아집니다.\n\n<img src=\"/TIL/assets/img/2024-07-07-ServerlessAuthSelf-ServePlatform_5.png\" />\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\"중앙 집중형 권한 부여가 우리에게 어떤 이점을 제공할까요?\n\n✔️ 셀프 서비스 포털에서 새로운 3rd 파티 클라이언트 및 서비스를 신속하게 추가할 수 있어요.\n\n✔️ 모든 클라이언트 및 토큰을 관리하는 팀이 한 팀에만 의지하지 않아도 되어 조직 내 병목 현상을 피할 수 있어요 (Team Topologies를 생각해보세요) - 이렇게 하면 팀원들이 AD를 통해 로그인하고 자체 구성을 관리할 수 있어요.\n\n✔️ 보안 팀은 한 솔루션의 디자인을 확인하고 팀과 함께 쉽게 모니터링할 수 있어요.\"\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n✔️ Auth0, Tyk 등의 서비스를 사용할 수도 있겠지만, Amazon Cognito보다 훨씬 비싸기 때문에 typ씨피 방법을 사용할 수 없습니다. 또한 일반적으로 제공하는 모든 기능이 필요하지 않을 수 있습니다. Amazon Cognito를 프록시하면 UI를 우리의 요구에 맞게 조정할 수 있기 때문에 구현을 자체적으로 사용 사례에 맞게 할 수도 있습니다.\n\n## 클라이언트 자격 증명 흐름이란? 🔐\n\n이제 중앙 인증 플랫폼의 필요성에 대해 논의했으니, 여태까지 여러 번 언급한 OAuth 2.0 클라이언트 자격 증명 흐름이 무엇인지 알아보겠습니다.\n\n간단한 용어 해설을 통해 이야기를 나눠보죠:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 클라이언트 — 클라이언트(클라이언트 웹 애플리케이션과 혼동되지 않도록 주의)는 API(리소스 서버)에서 리소스에 액세스하려는 백엔드 서비스, 데몬 또는 기기입니다.\n- 리소스 서버 — 리소스 서버는 하나 이상의 클라이언트가 인증된 요청을 보내려고 하는 API입니다. 리소스 서버는 클라이언트로부터 받은 엑세스 토큰을 발급한 클라이언트에게 토큰을 부여한 인가 서비스와 대조합니다.\n- 인가 서비스 — 인가 서비스는 클라이언트가 특정 리소스 서버를 위해 엑세스 토큰을 생성하는 방법으로, 토큰에는 범위가 포함될 수 있습니다.\n- 범위 — 범위는 클라이언트가 인가 서비스로부터 받은 엑세스 토큰에 청구하는 것으로, 리소스 서버에서 클라이언트에 노출되는 기능을 상세히 기술합니다.\n\n거의 모든 경우에 우리는 REST API를 사용하여 서로 동기적으로 통신하는 하나 이상의 서비스가 필요하며, 이러한 서비스들은 일반적으로 백엔드 서비스이므로 '사용자'가 아닌 '기기'로 인증해야 합니다.\n\n이 요구 사항이 있을 때, 우리는 \"m2m\" 플로우를 실행하여 산업 표준 OAuth 2.0 인증 플로우인 \"클라이언트 자격 증명 플로우\"를 수행합니다. 아래에 표시된 것과 같습니다:\n\n위 다이어그램에서 보듯이:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 3rd party 서비스는 주문을 배치하기 위해 저희의 리소스 서버(API)를 호출하기 위해 특히 인증 서버에서 액세스 토큰을 요청합니다.\n- 클라이언트 자격 증명(즉, 클라이언트 ID 및 클라이언트 비밀번호)가 올바른 경우, 인증 서버는 새로운 유효한 액세스 토큰을 반환합니다.\n- 3rd Party 서비스는 이제 요청 헤더의 'Authorization'에 액세스 토큰을 사용하여 리소스 서버 API를 호출합니다.\n- 리소스 서버는 이제 액세스 토큰을 인증 서버에 대조하여 a.) 유효한 토큰이고 b.) 호출 중인 API의 엔드포인트에 대한 올바른 스코프를 갖고 있는지 확인합니다.\n- 리소스 서버 API의 응답은 클라이언트에게 다시 전송됩니다.\n\n지금 우리가 높은 수준에서 이에 대해 이야기했으니, 우리의 자체 서비스 포털이 어떻게 생겼는지 살펴봅시다. 이를 통해 3rd Party 모바일 앱이 우리 주문 서비스를 이용하여 주문을 배치할 수 있도록 관리 세부 정보를 관리할 수 있는 것입니다.\n\n![이미지](/TIL/assets/img/2024-07-07-ServerlessAuthSelf-ServePlatform_6.png)\n\n# 저희 클라이언트 앱은 어떻게 생겼나요? 🎨\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 이 기사의 POC 스타일 구현에서 중앙 인증 플랫폼 응용 프로그램의 모습을 살펴봅시다.\n\n다만, 이것이 POC로서 제작 준비가 된 것이 아니라는 것을 명심해주세요!\n\n우리는 기존의 리소스 서버 및 클라이언트를 나열하는 메인 페이지에서 시작합니다.\n\n'새 리소스 서버 만들기' 버튼을 클릭하여 새 리소스 서버를 추가할 필요한 세부 정보를 추가하는 모달이 표시됩니다. 예를 들어, 우리의 리소스 서버에는 '주문하기' 및 '주문 목록'이라는 두 가지 스코프가 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n자원 서버를 설정했으니 이제 '새 클라이언트 생성' 버튼을 클릭할 수 있어요. 이 버튼을 클릭하면 아래에 표시된 것처럼 관련 클라이언트 세부 정보를 추가할 수 있는 모달이 나타나요. 이 예제에서는 클라이언트 이름과 스코프를 설정하고, 리소스 서버에서 새로운 주문을 할 수 있는 'lj-health-food/place-order'로 지정했어요. 이 예제에서 주문 목록을 나열할 수는 없도록 했어요.\n\n새 클라이언트를 만든 후 관련 세부 정보를 보여주려면 목록에서 새로 만든 클라이언트의 '보기' 버튼을 클릭하세요.\n\n자체 서비스 사용 인증 서비스가 필요한 이유, 클라이언트 자격 증명 흐름이 무엇인지, 그리고 자체 서비스 사용 플랫폼 프론트엔드가 어떻게 생겼는지에 대해 설명했으니 이제 전체 아키텍처에 대해 이야기해보겠어요.\n\n# 무엇을 만들고 있나요? 🛠️\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위에서 다룬 내용을 고려하면, 우리는 내부 플랫폼의 얇은 슬라이스를 구축할 것입니다. 이 플랫폼은 우리의 제3자 서비스를 인증하면서 팀이 쉽고 빠르게 새 고객(클라이언트)을 온보딩하고 사용 가능한 스코프를 설정하고 새로운 리소스 서버를 설정할 수 있게 합니다. 본질적으로, 세 가지 마이크로서비스가 있습니다.\n\n위 다이어그램에서 볼 수 있는 것은 다음과 같습니다:\n\n- 내부 팀은 Entra ID(Active Directory)를 통해 UI에 로그인하여 AD 그룹을 통해 포털에 액세스할 수 있는 특정 직원만 접근할 수 있습니다.\n- 내부 UI는 API 게이트웨이를 BFF(Backend-for-Frontend)로 호출하며, 이는 다양한 람다 함수를 사용하여 Amazon Cognito와 상호 작용하여 클라이언트, 리소스 서버 및 스코프를 설정합니다.\n- 모든 BFF 구성은 Amazon DynamoDB에 저장됩니다. 다만 이것은 매우 간단한 예제에서는 설정하지 않습니다.\n- Cognito 사용자 풀에 설정된 제3자 서비스는 머신 투 머신 토큰(client-credentials flow)을 생성하여 리소스 서버를 위해 생성된 액세스 토큰을 'Authorization' 헤더에 넣어 API 게이트웨이를 호출합니다.\n- 리소스 서버는 API 게이트웨이에 연결된 람다 인증기(라우터)를 사용하여 Cognito 사용자 풀에서 토큰을 유효성 검사하고 요청을 처리합니다.\n\n이제 주요 코드에 대해 이야기해 보겠습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 주요 코드로 이야기 나누기 👨‍💻\n\n저희의 GitHub 프로젝트는 세 가지 주요 솔루션으로 나누어져 있습니다:\n\n- 'shared-central-auth' 폴더에 중앙 Auth 서비스 및 UI가 있습니다.\n- 'resource-server-service' 폴더에는 리소스 서버가 있습니다.\n- 'client-service' 폴더에는 클라이언트 (3rd Party 서비스)가 있습니다.\n\n자, 각각의 중요 코드를 살펴보겠습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## ✔️ 공유된 중앙 인증\n\n먼저 CDK 앱에서 '무상태(Stateless)' 스택을 만들어서 Amazon Cognito 사용자 풀을 생성합니다:\n\n```js\nimport * as cdk from 'aws-cdk-lib';\nimport * as cognito from 'aws-cdk-lib/aws-cognito';\n\nimport { Construct } from 'constructs';\n\nexport class SharedCentralAuthStatefulStack extends cdk.Stack {\n  constructor(scope: Construct, id: string, props?: cdk.StackProps) {\n    super(scope, id, props);\n\n    // 클라이언트 자격 증명 플로우(m2m auth)를 위해 공유 Cognito 사용자 풀 생성\n    const authUserPool: cognito.UserPool = new cognito.UserPool(\n      this,\n      'SharedAuthUserPool',\n      {\n        userPoolName: 'SharedAuthUserPool',\n        removalPolicy: cdk.RemovalPolicy.DESTROY,\n      }\n    );\n\n    // Cognito에서 사용자 풀 도메인 생성\n    // (외부 서비스가 토큰을 요청할 수 있게 해줍니다)\n    const authUserPoolDomain: cognito.UserPoolDomain =\n      new cognito.UserPoolDomain(this, 'SharedAuthUserPoolDomain', {\n        userPool: authUserPool,\n        cognitoDomain: {\n          domainPrefix: 'lj-health-food-auth',\n        },\n      });\n\n    ...\n  }\n}\n```\n\n다음으로 사용자 풀과 상호 작용할 UI에 사용될 Amazon API Gateway를 생성합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```typescript\n// 우리의 경험 레이어 API를 생성합니다.\nconst api: apigw.RestApi = new apigw.RestApi(this, \"CentralAuthApi\", {\n  description: \"LJ Food Delivery - Central Auth Service\",\n  deploy: true,\n  defaultCorsPreflightOptions: {\n    allowOrigins: apigw.Cors.ALL_ORIGINS,\n  },\n  deployOptions: {\n    stageName: \"prod\",\n    loggingLevel: apigw.MethodLoggingLevel.INFO,\n  },\n});\n```\n\n이어서 ‘clients’와 ‘resource-servers’에 대한 리소스를 추가합니다.\n\n```typescript\n// API에서 리소스를 만듭니다.\nconst resourceServers: apigw.Resource = api.root.addResource(\"resource-servers\");\nconst clients: apigw.Resource = api.root.addResource(\"clients\");\nconst client: apigw.Resource = clients.addResource(\"{id}\");\nconst resourceServer: apigw.Resource = resourceServers.addResource(\"{id}\");\n```\n\n여러 Lambda 함수가 있으며 이 함수들은 클라이언트 목록 표시, 리소스 서버 생성, 클라이언트 삭제 등과 같은 기능을 위해 API Gateway 엔드포인트와 통합됩니다. 한 예시 함수를 살펴보겠습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n// 새로운 리소스 서버를 추가하는 람다 함수를 생성합니다\nconst createResourceServer: nodeLambda.NodejsFunction = new nodeLambda.NodejsFunction(this, \"CreateResourceServer\", {\n  functionName: \"create-resource-server\",\n  runtime: lambda.Runtime.NODEJS_20_X,\n  entry: path.join(__dirname, \"src/adapters/primary/create-resource-server/create-resource-server.adapter.ts\"),\n  memorySize: 1024,\n  handler: \"handler\",\n  tracing: Tracing.ACTIVE,\n  bundling: {\n    minify: true,\n  },\n  environment: {\n    ...lambdaPowerToolsConfig,\n    USER_POOL_ID: userPoolId,\n  },\n});\n```\n\nLambda 함수들은 우리의 Cognito 사용자 풀을 관리하기 위해 AWS SDK v3를 활용하므로, 각각에 필요한 관련 권한을 부여해야 합니다. 위의 'CreateResourceServer' 람다 함수의 경우, 아래와 같이 할 수 있습니다:\n\n```js\n// 람다 함수에 사용자 풀 액세스 권한 부여\ncreateResourceServer.addToRolePolicy(\n  new iam.PolicyStatement({\n    actions: [\"cognito-idp:CreateResourceServer\"],\n    resources: [userPool.userPoolArn],\n  })\n);\n```\n\n그런 다음 Lambda 함수 핸들러 유즈케이스(비즈니스 로직)는 Amazon Cognito와 통신하기 위해 보조 어댑터를 활용하며, 아래는 AWS SDK를 사용하여 리소스 서버를 생성하는 예시입니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nexport async function createCognitoResourceServer(\n  resourceServerName: string,\n  identifier: string,\n  scopes: ResourceServerScopeType[]\n): Promise<ResourceServerType> {\n  const params: CreateResourceServerCommandInput = {\n    UserPoolId: userPoolId,\n    Identifier: identifier,\n    Name: resourceServerName,\n    Scopes: scopes,\n  };\n\n  try {\n    const command = new CreateResourceServerCommand(params);\n    const response: CreateResourceServerCommandOutput = await client.send(command);\n\n    logger.info(\"resource server created: \", JSON.stringify(response.ResourceServer));\n    const resourceServer = response.ResourceServer;\n\n    if (!resourceServer) {\n      throw new Error(\"resource server could not be created\");\n    }\n\n    logger.info(\"resource server details: \", JSON.stringify(resourceServer));\n    return resourceServer;\n  } catch (error) {\n    logger.error(\"error creating resource server: \", JSON.stringify(error));\n    throw error;\n  }\n}\n```\n\n이 시점에서 Amazon API Gateway가 여러 람다 함수를 대리하며 AWS SDK v3를 사용하여 사용자 풀에서 클라이언트 및 리소스 서버를 관리하는 기능을 제공합니다. 이 기능을 UI를 통해 사용할 수 있습니다!\n\n## ✔️ 리소스 서버\n\n이 시점에서 UI로 이동하여 클라이언트가 사용할 주문 API를 위한 리소스 서버를 생성할 수 있습니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마이크로서비스의 실제 Amazon API Gateway, Lambda 함수 및 DynamoDB 테이블에 대해서는 여기서 다루지 않겠습니다. 이 내용은 매우 기본적이며, 위의 대부분의 코드 예제를 다루었습니다. 그러나 우리가 여기서 다룰 것은 API Gateway에서의 Lambda Authorizer와 Lambda 핸들러의 내용입니다.\n\n위의 코드를 보면, 우리는 액세스 토큰을 확인하는 데 사용될 RequestAuthorizer를 만드는 것을 볼 수 있습니다. 이 토큰은 모든 클라이언트의 Authorization 헤더에 포함되어 있습니다. 그 다음, 아래에 표시된대로 이를 API Gateway에 추가합니다:\n\n```js\n// ensure that our lambda function is invoked through the api\n// and we have a request based lambda authorizer to validate the token\norders.addMethod(\n  \"POST\",\n  new apigw.LambdaIntegration(createOrder, {\n    proxy: true,\n  }),\n  {\n    authorizer: authoriser, // add our lambda authoriser\n    authorizationType: apigw.AuthorizationType.CUSTOM,\n  }\n);\n```\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAPI 엔드포인트가 호출될 때마다 먼저 Lambda Authorizer를 호출하여 액세스 토큰을 유효성 검사합니다.\n\n그런 다음 아래의 Lambda 핸들러 내용을 확인할 수 있습니다. 여기에서는 Authorization 헤더의 액세스 토큰을 유효성 검사합니다:\n\n```js\nimport { APIGatewayAuthorizerResult } from \"aws-lambda/trigger/api-gateway-authorizer\";\nimport { CognitoJwtVerifier } from \"aws-jwt-verify\";\nimport { PolicyDocument } from \"aws-lambda\";\nimport { config } from \"@config\";\nimport { logger } from \"@shared\";\n\nconst cognitoJwtVerifier = CognitoJwtVerifier.create({\n  userPoolId: config.get(\"userPoolId\"),\n  clientId: [config.get(\"clientId\")], // 유효한 클라이언트 ID 배열\n  scope: [config.get(\"scopes\")], // 허용된 스코프\n  tokenUse: \"access\",\n});\n\nexport const handler = async function (event: any): Promise<APIGatewayAuthorizerResult> {\n  try {\n    // 클라이언트가 클라이언트 ID와 클라이언트 시크릿(스코프로)를 사용하여 받은\n    // 인증 토큰을 요청에서 가져옵니다. 이를 로그에만 표시합니다.\n    const authToken = event.headers[\"Authorization\"] || \"\";\n\n    logger.info(`Auth token: ${authToken}`);\n\n    // 토큰 검증\n    const decodedJWT = await cognitoJwtVerifier.verify(authToken);\n\n    // methodArn에 대한 허용 정책 생성\n    const policyDocument: PolicyDocument = {\n      Version: \"2012-10-17\",\n      Statement: [\n        {\n          Action: \"execute-api:Invoke\",\n          Effect: \"Allow\",\n          Resource: event[\"methodArn\"],\n        },\n      ],\n    };\n\n    // 컨텍스트에 클라이언트 ID를 전달합니다\n    const context = {\n      clientId: decodedJWT.sub,\n    };\n\n    const response: APIGatewayAuthorizerResult = {\n      principalId: decodedJWT.sub,\n      policyDocument,\n      context,\n    };\n\n    return response;\n  } catch (err) {\n    console.error(\"invalid auth token: \", err);\n    throw new Error(\"unauthorized\");\n  }\n};\n```\n\n위 코드에서 유효성 확인이 이루어지는 것을 확인할 수 있습니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 액세스 토큰의 만료 기간이 지나지 않았습니다.\n- 알려진 클라이언트 중 하나를 위해 생성되었습니다.\n- 예상대로 올바른 범위를 포함하고 있습니다.\n- 액세스 토큰은 우리의 Cognito UserPool에서 서명되었습니다.\n\n모든 작업은 `aws-jwt-verify` 패키지를 사용하여 수행되었습니다.\n\n## ✔️ 클라이언트 서비스\n\n그래서 이제 우리에게는 새로운 주문을 생성하는 리소스 서버 서비스가 있고, 중앙 인증 플랫폼에서 이를 위한 모든 구성 설정이 완료되었습니다. 이제 리소스 서버 API를 사용할 3rd party 서비스인 클라이언트를 생성해야 합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n새 주문을 만드는 비즈니스 로직인 사용 사례를 살펴보겠습니다. 아래에 표시된 대로, 우리의 서드파티 서비스에서 새 주문을 만드는 방법을 살펴보겠습니다.\n\n```js\nimport { CreateOrder, Order } from \"@dto/order\";\nimport { logger, schemaValidator } from \"@shared\";\n\nimport { createOrder } from \"@adapters/secondary/https-adapter\";\nimport { saveOrder } from \"@adapters/secondary/database-adapter\";\nimport { schema } from \"@schemas/order\";\n\nexport async function createOrderUseCase(order: CreateOrder): Promise<Order> {\n  logger.info(`주문이 접수되었습니다: ${JSON.stringify(order)}`);\n\n  // 인증 토큰과 함께 다른 서비스를 호출하여 주문을 생성합니다.\n  const createdOrder = await createOrder(order);\n\n  // 생성된 주문의 응답이 올바른 형태인지 확인합니다.\n  schemaValidator(schema, createdOrder);\n\n  // 주문 서비스로부터 반환된 주문을 DynamoDB에 저장합니다.\n  await saveOrder(createdOrder);\n\n  logger.info(`주문이 id와 함께 완료되었습니다: ${JSON.stringify(createdOrder.id)}`);\n\n  return createdOrder;\n}\n```\n\n우리는 보조 어댑터를 통해 주문을 생성하고, 이를 페이로드와 유효한 액세스 토큰을 사용해 리소스 서버 API를 호출합니다. 그리고 리턴된 주문 세부 정보를 우리 자체 DynamoDB 테이블에 저장합니다.\n\nHTTP 핸들러는 액세스 토큰을 생성하고 주문 요청을 리소스 서버 API로 보내는 데 관여합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport { CreateOrder, Order } from \"@dto/order\";\nimport { generateAccessToken, logger } from \"@shared\";\n\nimport axios from \"axios\";\nimport { config } from \"@config\";\nimport { decode } from \"jsonwebtoken\";\n\nexport async function createOrder(order: CreateOrder): Promise<Order> {\n  // 설정 가능한 세부 정보를 구성에서 가져옵니다\n  const clientId = config.get(\"clientId\");\n  const clientSecret = config.get(\"clientSecret\");\n  const url = config.get(\"authUrl\");\n  const resourceServerUrl = config.get(\"resourceServerUrl\");\n\n  // 주문 서비스를 이용하여 주문을 작성하기 위한 스코프\n  const scopes: string[] = [\"lj-health-food/place-order\"];\n\n  // 주문 서비스를 위한 액세스 토큰 생성\n  // 클라이언트 자격 증명으로 중앙 인증 서비스를 호출하여\n  const accessToken = await generateAccessToken(clientId, clientSecret, url, scopes);\n\n  // 참고: 접근 토큰은 절대로 로깅해서는 안 됩니다\n  // 그러나 이 예제에서는 디코딩된 내용을 살펴보겠습니다\n  const decoded = decode(accessToken, { complete: true });\n  logger.info(`디코딩된 토큰 : ${JSON.stringify(decoded)}`);\n\n  // 주문을 생성하기 위해 주문 API(리소스 서버)에 요청 보냄\n  // 헤더에 액세스 토큰을 전달합니다\n  const { data }: { data: Order } = await axios.request({\n    url: \"orders\",\n    method: \"post\",\n    baseURL: resourceServerUrl,\n    headers: {\n      Authorization: accessToken,\n    },\n    data: order,\n  });\n\n  return data;\n}\n```\n\n마지막으로, 실제로 generateAccessToken 함수를 사용하여 액세스 토큰을 생성하는 코드를 살펴봅시다:\n\n```js\nimport axios, { AxiosRequestConfig, AxiosResponse } from 'axios';\n\nimport { logger } from '@shared';\nimport { stringify } from 'querystring';\n\nexport async function generateAccessToken(\n  clientId: string,\n  clientSecret: string,\n  url: string,\n  scopes: string[] = []\n): Promise<string> {\n  try {\n    const payload = {\n      grant_type: 'client_credentials',\n      scope: scopes.length ? scopes.join(' ') : undefined,\n    };\n\n    const options: AxiosRequestConfig = {\n      method: 'post',\n      headers: { 'content-type': 'application/x-www-form-urlencoded' },\n      auth: {\n        username: clientId,\n        password: clientSecret,\n      },\n      data: stringify(payload),\n      url: '/oauth2/token',\n      baseURL: url,\n    };\n\n    const { data }: AxiosResponse<any> = await axios.request(options);\n\n    logger.info(`액세스 토큰 응답: ${data}`);\n\n    return data?.access_token as string;\n  } catch (error) {\n    throw error;\n  }\n}\n```\n\n위의 코드에서 알 수 있듯이, 이 코드는 클라이언트 ID, 시크릿 및 스코프를 사용하여 중앙 인증 서비스(Cognito 사용자 풀)의 토큰 엔드포인트에 POST 요청을 수행하여 유효하면 액세스 토큰을 반환합니다. 액세스 토큰은 이와 유사합니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n{\n  \"sub\": \"<your-client_id>\",\n  \"token_use\": \"access\",\n  \"scope\": \"lj-health-food/place-order\",\n  \"auth_time\": 1709980199,\n  \"iss\": \"https://cognito-idp.eu-west-1.amazonaws.com/eu-west-1_tyReqcsgR\",\n  \"exp\": 1709983799,\n  \"iat\": 1709980199,\n  \"version\": 2,\n  \"jti\": \"x9d6ggd3-8752-4b4f-1423-12x01bsd5b89\",\n  \"client_id\": \"<your-client_id>\"\n}\n```\n\nThe token의 주요 속성들은 다음과 같습니다:\n\n- sub: 이것은 토큰의 주체를 나타내며 일반적으로 클라이언트 ID를 가리킵니다.\n- token_use: 토큰의 목적을 나타냅니다. 이 경우 \"access\" 토큰으로, 특정 리소스나 서비스에 액세스를 부여하는 의미입니다.\n- scope: 토큰으로 부여된 특정 권한을 설명합니다. 이 예제에서 토큰은 \"lj-health-food/place-order\" 스코프에 액세스를 부여하므로, \"lj-health-food\" 서비스 내에서 주문을 할 수 있는 능력을 나타냅니다.\n- auth_time: 인증이 발생한 시간을 나타내며 유닉스 에포크를 기준으로 한 초 단위로 측정됩니다 (1970년 1월 1일 00:00:00 UTC부터의 초).\n- iss: \"발급자\"를 나타내며 토큰의 발급자를 지정합니다. 토큰을 발급한 ID 공급자의 URL입니다. 여기서는 Amazon Cognito ID 공급자입니다.\n- exp: 토큰의 만료 시간을 나타내며, 그 이후에는 유효하지 않다고 간주되어야 합니다. auth_time과 마찬가지로 유닉스 에포크를 기준으로 합니다.\n- jti: \"JWT ID\"를 의미하며 토큰의 고유 식별자입니다. 토큰 재생 공격을 방지하는 데 도움이 됩니다.\n- client_id: 토큰을 요청한 클라이언트 응용 프로그램의 ID를 나타냅니다.\n\n이제 코드를 확인하고 배포하고 UI를 탐험하여 여러분의 요구에 맞게 조정하세요!\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 마무리\n\n여기까지 읽어주셔서 감사합니다! 요약하면 다음과 같은 내용을 다루었습니다:\n\n✔️ Amazon Cognito 기계 대 기계 흐름이란 무엇인가.\n✔️ 중앙 집중식 인증 플랫폼이 필요한 이유를 살펴보았습니다.\n✔️ 기본 예제 프론트엔드 UI를 살펴보았습니다.\n✔️ 전체적인 AWS 아키텍처를 설명했습니다.\n✔️ TypeScript 및 AWS CDK 코드를 살펴보았습니다.\n\n# 마무리 인사 👋🏽\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 기사를 즐겨 보셨다면 공유하고 피드백 주시면 감사하겠습니다!\n\n유사한 콘텐츠를 원하신다면 제 유튜브 채널을 구독해주세요!\n\n![이미지](/TIL/assets/img/2024-07-07-ServerlessAuthSelf-ServePlatform_7.png)\n\n아래의 채널을 통해 저와 연결하고 싶습니다:\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nhttps://www.linkedin.com/in/lee-james-gilmore/\nhttps://twitter.com/LeeJamesGilmore\n\n만약 게시물을 즐겼다면 추가로 게시물/시리즈를 보기 위해 제 프로필 Lee James Gilmore를 팔로우해주세요. 그리고 꼭 연결하고 안부를 물어보세요 👋\n\n그리고 게시물 하단에 있는 '박수' 기능도 사용해주세요. (한 번 이상 박수를 칠 수 있어요!!)\n\n# 나에 대해\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\"안녕하세요, 저는 영국에 거주하는 AWS 커뮤니티 빌더, 블로거, AWS 인증 클라우드 아키텍트이자 Global Head of Technology & Architecture인 Lee입니다. 현재 City Electrical Factors (UK) & City Electric Supply (US)에서 근무하고 있으며, 지난 6년 동안 AWS에서 전문적으로 풀 스택 JavaScript를 주로 다루고 있습니다.\n\n저는 서버리스를 지지하는 입장에서 모든 것에 대한 사랑, 혁신, 소프트웨어 아키텍처, 기술에 대한 관심을 가지고 있습니다.\"\n\n**_ 제공된 정보는 제 개인적인 견해이며 정보 사용에 대한 책임을 지지 않습니다. _**\n\n아래 내용도 참고하실 수 있습니다:\n","ogImage":{"url":"/assets/img/2024-07-07-ServerlessAuthSelf-ServePlatform_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-ServerlessAuthSelf-ServePlatform_0.png","tag":["Tech"],"readingTime":26},{"title":"알고 계셨나요  Python 내장 우선순위 큐 소개","description":"","date":"2024-07-07 21:48","slug":"2024-07-07-DidYouKnowPythonHasABuilt-inPriorityQueue","content":"\n<img src=\"/TIL/assets/img/2024-07-07-DidYouKnowPythonHasABuilt-inPriorityQueue_0.png\" />\n\n우선 순위 큐:\n\n- 요소들의 집합\n- 각 요소는 어떤 종류의 우선 순위가 할당되어 있음\n- 큐 내에서 가장 높은 우선 순위를 가진 요소가 먼저 처리됨\n- 요소를 큐에 넣는 순서는 중요하지 않음\n\n예를 들어, 이 숫자들이 포함된 우선 순위 큐가 있다고 가정해봅시다. 낮은 숫자가 높은 우선 순위를 의미합니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\npq = [3, 7, 1, 6, 4, 5];\n```\n\n- 여기서 3이 먼저 삽입되고, 그 다음에 7, 그 다음에 1이 들어갑니다.\n- 그러나 3은 큐에서 제일 먼저 떠난 요소가 아닙니다.\n\n```js\n# 큐에서 팝\n1\n\n# 큐에서 팝\n3\n\n# 큐에서 팝\n4\n```\n\n- 1이 3보다 먼저 나가는 이유는 더 높은 우선순위를 가지고 있기 때문입니다.\n- 3은 1 다음으로 가장 높은 우선순위를 가지고 있기 때문에 다음에 나갑니다.\n- 4는 3 다음으로 가장 높은 우선순위를 가지고 있기 때문에 그 다음에 나갑니다.\n\n<!-- TIL 수평 -->\n\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 이런. 정렬만 하면 되잖아요?\n\n```js\npq = [3, 7, 1, 6, 4, 5]\npq.sort()\n\n# pq = [1, 3, 4, 5, 6, 7]\n```\n\n이제는 우선순위대로 1, 3, 4 순으로 pop할 수 있습니다. 네 할 수 있어요.\n\n하지만 문제는 이 목록에 새 숫자를 추가하려고 할 때 발생합니다.\n","ogImage":{"url":"/assets/img/2024-07-07-DidYouKnowPythonHasABuilt-inPriorityQueue_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-DidYouKnowPythonHasABuilt-inPriorityQueue_0.png","tag":["Tech"],"readingTime":2}],"page":"21","totalPageCount":28,"totalPageGroupCount":2,"lastPageGroup":8,"currentPageGroup":1},"__N_SSG":true}