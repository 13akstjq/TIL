{"pageProps":{"post":{"title":"프라이빗 데이터를 활용한 Amazon Bedrock 지식 베이스 구축 방법","description":"","date":"2024-07-07 19:23","slug":"2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData","content":"\n\n<img src=\"/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_0.png\" />\n\n## 서문\n\n✔️ 아마존 베드락 지식베이스에 대해 다루겠습니다.\n✔️ AWS 아키텍처를 설명합니다.\n✔️ TypeScript 및 AWS CDK 코드를 살펴봅니다.\n✔️ 작동 방식을 확인하기 위해 몇 가지 테스트를 수행합니다.\n\n# 소개 👋🏽\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 기사에서는 Amazon Bedrock Knowledge Bases에 대해 이야기하고, 최신 비공개 회사 정보로 AI 모델을 장착하는 방법에 대해 얘기할 것입니다. 이를 통해 사용자들이 자체 사용자 정의 데이터로 AI를 활용할 수 있게 됩니다. 우리는 코드 예제와 관련된 AWS 아키텍처에 대해 설명할 것입니다.\n\n![이미지](/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_1.png)\n\n우리의 예시에서는 'LJ Medical Center'라는 허구의 회사를 위한 사용 사례에 대해 이야기할 것입니다. 여기서 우리의 접수 직원들이 회사 정보를 질의하기 위해 AI 모델을 사용할 수 있습니다.\n\n![이미지](/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_2.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n접대 직원은 자연어를 사용하여 사설 데이터를 쿼리할 수 있습니다. 예를 들어, 의료 분야에서 지불 지연에 대한 정책이 무엇인지 묻는 것이 있습니다.\n\n![이미지](/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_3.png)\n\n아래에 TypeScript로 작성된 전체 코드 예제와 AWS CDK를 찾을 수 있습니다:\n\n👇 더 나아가기 전에 — LinkedIn에서 저와 연결해주세요. 미래의 블로그 게시물과 서버리스 뉴스를 만날 수 있습니다. https://www.linkedin.com/in/lee-james-gilmore/\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_4.png\" />\n\n# 아마존 베드락은 무엇인가요? 🤖\n\n이제 아마존 베드락이 무엇이고 어떻게 작동하는지 알아봅시다. 먼저 몇 가지 주요 약어를 이해하는 것부터 시작해보겠습니다.\n\n## 약어\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n시작하기 전에, 몇 가지 약어와 그 의미에 대해 알아보겠습니다:\n\n- FMs — Foundational Models.\n- RAG — Retrieval Augmented Generation.\n\n![이미지](/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_5.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## Bedrock Knowledge Bases란 무엇인가요? 🤖\n\n최신 및 사용자 정의 정보를 시설 관리자(FM)에게 제공하기 위해, 기업 및 비즈니스는 RAG(Retrieval Augmented Generation) 기법을 사용합니다. 이 기법은 회사 데이터 소스에서 데이터를 가져와 프롬프트를 보다 관련성 높고 정확한 응답을 제공하기 위해 풍부하게 합니다.\n\n지식 베이스는 사용자 쿼리에 대답하는 데뿐만 아니라 프롬프트에 맥락을 제공함으로써 기초 모델이 제공하는 프롬프트를 보강하는 데 사용될 수 있습니다.\n\n## 사용자 정의 데이터를 어디에 저장하나요? 🤖\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아마존 베드락 지식 베이스를 사용하면 데이터 수집부터 Amazon S3에서 데이터를 검색하고 프롬프트 추가까지 전체 RAG 워크플로우를 구현할 수 있습니다. 사용자는 데이터 소스에 맞춤 통합을 작성하거나 데이터 흐름을 관리할 필요 없이 쉽게 다중 대화를 지원할 수 있습니다.\n\n아마존 S3에서 사용자 정의 데이터를 가리킨 후, 아마존 베드락을 사용하면 데이터를 자동으로 가져와 텍스트 블록으로 나누고 이를 임베딩으로 변환하여 벡터 데이터베이스에 저장합니다. 이 기사에서는 임베딩을 아마존 오픈서치 서버리스 벡터에 저장할 것입니다.\n\n## 사용자 정의 데이터는 어떻게 저장되나요? 🤖\n\n벡터 임베딩에는 문서 내 텍스트 데이터의 숫자 표현이 포함됩니다. 각 임베딩은 데이터의 의미나 문맥적 의미를 포착하기 위해 노력합니다. 아마존 베드락은 벡터 저장소에서 임베딩을 생성, 저장, 관리 및 업데이트하며 데이터가 항상 벡터 저장소와 동기화되도록 보장합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n✔️ 전처리\n\n데이터 검색을 개선하기 위해 문서를 작은 세그먼트로 나누어 임베딩으로 변환한 후 벡터 인덱스에 저장하여 원본 문서와의 연결을 유지합니다. 이러한 임베딩은 데이터 원본에서 효율적인 쿼리 일치를 위한 의미 유사성 비교를 가능하게 합니다. 이 과정은 첨부된 이미지에 설명되어 있습니다.\n\n![image](/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_6.png)\n\n✔️ 런타임 실행\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n실시간으로 모델은 사용자의 쿼리를 벡터로 변환하고 의미적으로 유사한 청크를 찾기 위해 벡터 인덱스를 탐색합니다. 이러한 청크들은 사용자 프롬프트를 보강하는 데 사용되고, 그 후에 모델로 전송되어 응답을 생성합니다. 이 프로세스는 아래 이미지에서 RAG의 실행 중인 작업을 보여줍니다.\n\n![RAG의 실행 중인 작업](/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_7.png)\n\n✔️ 데이터 동기화\n\n우리의 Amazon S3 버킷에 새 문서를 업로드하면 지식 베이스 데이터 원본으로 사용하게 되는데, 이때 데이터를 주기적으로 동기화하여 색인 작업과 쿼리를 위해 지식 베이스와 동기화해야 합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n업데이트 동기화는 마지막 동기화 이후에 S3 버킷에 새로 추가되거나 수정된 객체들만을 처리하여 지식 베이스를 증분적으로 업데이트합니다.\n\n# 무엇을 만드는 중인가요? 🛠️\n\n자, 이제 Amazon Bedrock의 지식 베이스에 대해 심도있는 탐구를 했고, 이론적으로 어떻게 작동하는지 이해했으니, 이제 이 글에서 무엇을 만드는지 살펴보겠습니다:\n\n![Amazon Bedrock Knowledge Bases with Private Data](/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_8.png)\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위 다이어그램에서 알 수 있듯이:\n\n- 수신 직원 팀의 사용자는 그들의 응용 프로그램을 통해 Amazon API Gateway에 요청을 보냅니다.\n- Amazon API Gateway는 쿼리를 기반으로 한 POST 요청에 따라 람다 함수를 호출합니다.\n- 람다 함수는 사용자의 쿼리를 오픈서치 서버리스 벡터 저장소의 데이터로 보완하기 위해 Bedrock Knowledge Base를 호출합니다.\n- S3 버킷에서 객체가 수정, 작성 또는 삭제되면 Ingestion 람다를 호출합니다.\n- 람다 함수는 수정 사항이 있었기 때문에 Amazon S3 버킷의 데이터를 동기화하기 위해 Knowledge Base를 호출합니다.\n\n이제 우리가 전체 아키텍처를 토론했으니, 이를 실제로 보고 주요 코드를 설명해 보겠습니다.\n\n# 주요 코드 설명하기 👨‍💻\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n알겠어요. 우리는 이 기본 예제를 살펴보았으니 이제 TypeScript와 CDK 코드를 살펴보겠습니다. 전체 솔루션은 여기에서 찾을 수 있음을 기억해 주세요.\n\n## 상태를 가지는 스택\n\n먼저, 저희의 상태를 가지는 스택을 살펴봅시다. 아마존 베드락 지식베이스 및 데이터를 저장할 S3 버킷이 있는 스택입니다:\n\n```js\n// 베드락 지식베이스 생성\nconst kb = new bedrock.KnowledgeBase(this, 'BedrockKnowledgeBase', {\n  embeddingsModel: bedrock.BedrockFoundationModel.TITAN_EMBED_TEXT_V1,\n  instruction: `환자 기록에 대한 질문에 답변하는 데 사용할 지식베이스입니다.`,\n});\n\n// 환자 데이터를 저장하는 S3 버킷 생성 (베드락을 위한 소스)\nthis.bucket = new s3.Bucket(this, 'PatientRecordsBucket', {\n  bucketName: 'lj-medical-center-patient-records',\n  autoDeleteObjects: true,\n  removalPolicy: cdk.RemovalPolicy.DESTROY,\n});\n```\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 코드에서는 Titan Text V1 기본 모델을 사용하고 있음을 알 수 있습니다.\n\n다음으로, 첫 번째 배포 시에는 데이터 폴더에서 예제 문서를 S3 버킷으로 업로드해야 합니다:\n\n```js\n// cdk 배포의 일부로 데이터가 업로드되도록 보장\nnew s3deploy.BucketDeployment(this, 'ClientBucketDeployment', {\n  sources: [s3deploy.Source.asset(path.join(__dirname, '../../data/'))],\n  destinationBucket: this.bucket,\n});\n```\n\n마지막으로, 지식 베이스용 데이터 소스를 생성하며, 이는 우리의 S3 버킷을 가리킵니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n// knowledge base를 위한 s3 버킷의 데이터 소스 설정\nconst dataSource = new bedrock.S3DataSource(this, 'DataSource', {\n  bucket: this.bucket,\n  knowledgeBase: kb,\n  dataSourceName: 'patients',\n  chunkingStrategy: bedrock.ChunkingStrategy.DEFAULT,\n  maxTokens: 500,\n  overlapPercentage: 20,\n});\n```\n\nStateful 스택을 배포하려면 npm 스크립트 npm run deploy:stateful을 사용하고, 완료되면 콘솔에 로그인하여 '동기화'를 실행할 수 있습니다:\n\n## Stateless Stack\n\n이제 Stateless 스택을 살펴보겠습니다. 우선 S3 트리거를 추가하여 S3 버킷 내에서 변경 사항(새 파일, 수정, 삭제 등)이 발생할 때 Ingestion Lambda 함수를 호출하는 방법을 살펴보겠습니다:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n// 객체가 추가, 수정 또는 삭제될 때의 s3 이벤트 소스를 만듭니다\nbucket.addEventNotification(\n  s3.EventType.OBJECT_CREATED_PUT,\n  new s3n.LambdaDestination(ingestionLambda)\n);\nbucket.addEventNotification(\n  s3.EventType.OBJECT_REMOVED,\n  new s3n.LambdaDestination(ingestionLambda)\n);\n```\n\n그런 다음 Ingestion Lambda에는 데이터 소스를 동기화하기 위해 다음 코드를 실행하는 보조 어댑터가 있습니다:\n\n```js\nimport {\n  BedrockAgentClient,\n  StartIngestionJobCommand,\n  StartIngestionJobCommandInput,\n  StartIngestionJobCommandOutput,\n} from '@aws-sdk/client-bedrock-agent';\n\nimport { config } from '@config';\nimport { logger } from '@shared/logger';\nimport { v4 as uuid } from 'uuid';\n\nconst client = new BedrockAgentClient();\nconst knowledgeBaseId = config.get('knowledgeBaseId');\nconst dataSourceId = config.get('dataSourceId');\n\nexport async function ingestionProcess(): Promise<string> {\n  const input: StartIngestionJobCommandInput = {\n    knowledgeBaseId: knowledgeBaseId,\n    dataSourceId: dataSourceId,\n    clientToken: uuid(),\n  };\n  const command: StartIngestionJobCommand = new StartIngestionJobCommand(input);\n\n  const response: StartIngestionJobCommandOutput = await client.send(command);\n  logger.info(`response: ${response}`);\n\n  return JSON.stringify({\n    ingestionJob: response.ingestionJob,\n  });\n}\n```\n\n다음으로 Lambda 함수가 동기화 수행을 허용하기 위해 필요한 IAM 정책을 살펴보겠습니다:\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n // ensure that the lambda function can start a data ingestion job\ningestionLambda.addToRolePolicy(\n  new iam.PolicyStatement({\n    actions: ['bedrock:StartIngestionJob'],\n    resources: [knowledgeBaseArn],\n  })\n);\n```\n\n우리 쿼리 람다에 유사한 정책을 추가합니다. 이 정책에 따라 쿼리 람다가 Amazon Bedrock에 대해 작업을 수행할 수 있게 됩니다:\n\n```js\n// 쿼리 람다 함수가 모델을 쿼리할 수 있도록 허용합니다\nqueryModelLambda.addToRolePolicy(\n  new iam.PolicyStatement({\n    actions: [\n      'bedrock:RetrieveAndGenerate',\n      'bedrock:Retrieve',\n      'bedrock:InvokeModel',\n    ],\n    resources: ['*'],\n  })\n);\n```\n\n쿼리 람다의 두 번째 어댑터에 대한 코드가 아래에 표시되어 있습니다:\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport {\n  BedrockAgentRuntimeClient,\n  RetrieveAndGenerateCommand,\n  RetrieveAndGenerateCommandInput,\n  RetrieveAndGenerateCommandOutput,\n} from '@aws-sdk/client-bedrock-agent-runtime';\n\nimport { config } from '@config';\n\nconst client = new BedrockAgentRuntimeClient();\nconst knowledgeBaseId = config.get('knowledgeBaseId');\n\nexport async function queryModel(prompt: string): Promise<string> {\n  const input: RetrieveAndGenerateCommandInput = {\n    input: {\n      text: prompt,\n    },\n    retrieveAndGenerateConfiguration: {\n      type: 'KNOWLEDGE_BASE',\n      knowledgeBaseConfiguration: {\n        knowledgeBaseId: knowledgeBaseId,\n        // we are using Anthropic Claude v2 in us-east-1 in this example\n        modelArn: `arn:aws:bedrock:us-east-1::foundation-model/anthropic.claude-v2`,\n      },\n    },\n  };\n  const command: RetrieveAndGenerateCommand = new RetrieveAndGenerateCommand(\n    input\n  );\n  const response: RetrieveAndGenerateCommandOutput = await client.send(command);\n  return response.output?.text as string;\n}\n```\n\n마지막 단계는 우리의 Amazon API Gateway를 추가하고, /queries/ 리소스에 대해 Query Lambda 함수를 호출하도록 허용하는 것입니다.\n\n```js\n// 우리 수의원 앱에서 사용할 API를 생성합니다\nconst api: apigw.RestApi = new apigw.RestApi(this, 'Api', {\n  description: 'LJ Medical Center API',\n  restApiName: 'lj-medical-center-api',\n  deploy: true,\n  endpointTypes: [apigw.EndpointType.REGIONAL],\n  deployOptions: {\n    stageName: 'prod',\n    dataTraceEnabled: true,\n    loggingLevel: apigw.MethodLoggingLevel.INFO,\n    tracingEnabled: true,\n    metricsEnabled: true,\n  },\n});\n\n// API에 대한 쿼리 리소스 생성\nconst queries: apigw.Resource = api.root.addResource('queries');\n\n// 지식 베이스 쿼리 엔드포인트 추가 (POST) - prod/queries/\nqueries.addMethod(\n  'POST',\n  new apigw.LambdaIntegration(queryModelLambda, {\n    proxy: true,\n    allowTestInvoke: false,\n  })\n);\n```\n\n이제 npm 스크립트 npm run deploy:stateless로 무상태 스택을 배포하고 기능을 테스트할 수 있습니다.\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 앱 테스트 🧪\n\n## Postman을 통한 테스팅\n\npostman/Bedrock Knowledge Bases.postman_collection.json 파일을 사용하여 자신의 URL 정보로 테스트할 수 있습니다.\n\n늦은 지불에 관한 간단한 쿼리를 시작해보세요:\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 스크린샷에서 올바른 응답을 받았음을 확인할 수 있습니다:\n\n그런 다음 다음과 같은 쿼리를 요청할 수 있습니다:\n\n위의 쿼리에서 답변을 성공적으로 받았음을 확인할 수 있습니다:\n\n위의 예시는 우리 접수 직원이 모든 정책에서 필요한 정보를 빠르게 찾을 수 있는 두 가지 예시에 불과합니다.\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n어째서 이 기능을 사용해보지 않고 가상의 환자 기록을 추가해 보시겠어요? 솔루션을 배포하는 비용을 기억해 주세요!\n\n# 마무리 인사 👋🏽\n\n이 글을 즐겁게 읽어주셨으면 공유와 피드백도 부탁드립니다!\n\n제 유튜브 채널을 방문해 비슷한 콘텐츠를 구독해주세요!\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![이미지](/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_9.png)\n\n함께 소통하고 싶어요! 아래 링크에서 저와 연계해 주세요:\n\n[LinkedIn](https://www.linkedin.com/in/lee-james-gilmore/)\n[Twitter](https://twitter.com/LeeJamesGilmore)\n\n만약 글을 즐겼다면, 저의 프로필 Lee James Gilmore를 팔로우하여 더 많은 글/시리즈를 만나보세요. 그리고 연락하여 인사도 잊지 마세요! 👋\n\n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 나에 대해\n\n“안녕하세요, 저는 영국을 기반으로 하는 AWS 커뮤니티 빌더, 블로거, AWS 인증 클라우드 아키텍트이자 City Electrical Factors (UK) & City Electric Supply (US)에서 글로벌 기술 및 아키텍처 총괄을 맡고 있는 Lee입니다. 지난 6년간 주로 AWS에서 풀스택 JavaScript 개발을 하였습니다.\n\n저는 서버리스를 주장하는 사람으로, AWS, 혁신, 소프트웨어 아키텍처, 기술 전반에 관심을 가지고 있습니다.”\n클래프 기능을 사용하여 이 게시물이 마음에 드셨다면 반드시 박수를 눌러주세요! (여러 번 박수를 두드릴 수 있어요!!) \n\n<!-- TIL 수평 -->\n<ins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n*** 제공된 정보는 제 개인적인 의견이며 정보 사용에 대한 책임은 지지 않습니다. ***\n\n아래 정보도 참고하실만 합니다:","ogImage":{"url":"/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_0.png"},"coverImage":"/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_0.png","tag":["Tech"],"readingTime":17},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<img src=\"/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_0.png\">\n<h2>서문</h2>\n<p>✔️ 아마존 베드락 지식베이스에 대해 다루겠습니다.\n✔️ AWS 아키텍처를 설명합니다.\n✔️ TypeScript 및 AWS CDK 코드를 살펴봅니다.\n✔️ 작동 방식을 확인하기 위해 몇 가지 테스트를 수행합니다.</p>\n<h1>소개 👋🏽</h1>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>이 기사에서는 Amazon Bedrock Knowledge Bases에 대해 이야기하고, 최신 비공개 회사 정보로 AI 모델을 장착하는 방법에 대해 얘기할 것입니다. 이를 통해 사용자들이 자체 사용자 정의 데이터로 AI를 활용할 수 있게 됩니다. 우리는 코드 예제와 관련된 AWS 아키텍처에 대해 설명할 것입니다.</p>\n<p><img src=\"/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_1.png\" alt=\"이미지\"></p>\n<p>우리의 예시에서는 'LJ Medical Center'라는 허구의 회사를 위한 사용 사례에 대해 이야기할 것입니다. 여기서 우리의 접수 직원들이 회사 정보를 질의하기 위해 AI 모델을 사용할 수 있습니다.</p>\n<p><img src=\"/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_2.png\" alt=\"이미지\"></p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>접대 직원은 자연어를 사용하여 사설 데이터를 쿼리할 수 있습니다. 예를 들어, 의료 분야에서 지불 지연에 대한 정책이 무엇인지 묻는 것이 있습니다.</p>\n<p><img src=\"/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_3.png\" alt=\"이미지\"></p>\n<p>아래에 TypeScript로 작성된 전체 코드 예제와 AWS CDK를 찾을 수 있습니다:</p>\n<p>👇 더 나아가기 전에 — LinkedIn에서 저와 연결해주세요. 미래의 블로그 게시물과 서버리스 뉴스를 만날 수 있습니다. <a href=\"https://www.linkedin.com/in/lee-james-gilmore/\" rel=\"nofollow\" target=\"_blank\">https://www.linkedin.com/in/lee-james-gilmore/</a></p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<img src=\"/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_4.png\">\n<h1>아마존 베드락은 무엇인가요? 🤖</h1>\n<p>이제 아마존 베드락이 무엇이고 어떻게 작동하는지 알아봅시다. 먼저 몇 가지 주요 약어를 이해하는 것부터 시작해보겠습니다.</p>\n<h2>약어</h2>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>시작하기 전에, 몇 가지 약어와 그 의미에 대해 알아보겠습니다:</p>\n<ul>\n<li>FMs — Foundational Models.</li>\n<li>RAG — Retrieval Augmented Generation.</li>\n</ul>\n<p><img src=\"/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_5.png\" alt=\"이미지\"></p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h2>Bedrock Knowledge Bases란 무엇인가요? 🤖</h2>\n<p>최신 및 사용자 정의 정보를 시설 관리자(FM)에게 제공하기 위해, 기업 및 비즈니스는 RAG(Retrieval Augmented Generation) 기법을 사용합니다. 이 기법은 회사 데이터 소스에서 데이터를 가져와 프롬프트를 보다 관련성 높고 정확한 응답을 제공하기 위해 풍부하게 합니다.</p>\n<p>지식 베이스는 사용자 쿼리에 대답하는 데뿐만 아니라 프롬프트에 맥락을 제공함으로써 기초 모델이 제공하는 프롬프트를 보강하는 데 사용될 수 있습니다.</p>\n<h2>사용자 정의 데이터를 어디에 저장하나요? 🤖</h2>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>아마존 베드락 지식 베이스를 사용하면 데이터 수집부터 Amazon S3에서 데이터를 검색하고 프롬프트 추가까지 전체 RAG 워크플로우를 구현할 수 있습니다. 사용자는 데이터 소스에 맞춤 통합을 작성하거나 데이터 흐름을 관리할 필요 없이 쉽게 다중 대화를 지원할 수 있습니다.</p>\n<p>아마존 S3에서 사용자 정의 데이터를 가리킨 후, 아마존 베드락을 사용하면 데이터를 자동으로 가져와 텍스트 블록으로 나누고 이를 임베딩으로 변환하여 벡터 데이터베이스에 저장합니다. 이 기사에서는 임베딩을 아마존 오픈서치 서버리스 벡터에 저장할 것입니다.</p>\n<h2>사용자 정의 데이터는 어떻게 저장되나요? 🤖</h2>\n<p>벡터 임베딩에는 문서 내 텍스트 데이터의 숫자 표현이 포함됩니다. 각 임베딩은 데이터의 의미나 문맥적 의미를 포착하기 위해 노력합니다. 아마존 베드락은 벡터 저장소에서 임베딩을 생성, 저장, 관리 및 업데이트하며 데이터가 항상 벡터 저장소와 동기화되도록 보장합니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>✔️ 전처리</p>\n<p>데이터 검색을 개선하기 위해 문서를 작은 세그먼트로 나누어 임베딩으로 변환한 후 벡터 인덱스에 저장하여 원본 문서와의 연결을 유지합니다. 이러한 임베딩은 데이터 원본에서 효율적인 쿼리 일치를 위한 의미 유사성 비교를 가능하게 합니다. 이 과정은 첨부된 이미지에 설명되어 있습니다.</p>\n<p><img src=\"/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_6.png\" alt=\"image\"></p>\n<p>✔️ 런타임 실행</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>실시간으로 모델은 사용자의 쿼리를 벡터로 변환하고 의미적으로 유사한 청크를 찾기 위해 벡터 인덱스를 탐색합니다. 이러한 청크들은 사용자 프롬프트를 보강하는 데 사용되고, 그 후에 모델로 전송되어 응답을 생성합니다. 이 프로세스는 아래 이미지에서 RAG의 실행 중인 작업을 보여줍니다.</p>\n<p><img src=\"/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_7.png\" alt=\"RAG의 실행 중인 작업\"></p>\n<p>✔️ 데이터 동기화</p>\n<p>우리의 Amazon S3 버킷에 새 문서를 업로드하면 지식 베이스 데이터 원본으로 사용하게 되는데, 이때 데이터를 주기적으로 동기화하여 색인 작업과 쿼리를 위해 지식 베이스와 동기화해야 합니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>업데이트 동기화는 마지막 동기화 이후에 S3 버킷에 새로 추가되거나 수정된 객체들만을 처리하여 지식 베이스를 증분적으로 업데이트합니다.</p>\n<h1>무엇을 만드는 중인가요? 🛠️</h1>\n<p>자, 이제 Amazon Bedrock의 지식 베이스에 대해 심도있는 탐구를 했고, 이론적으로 어떻게 작동하는지 이해했으니, 이제 이 글에서 무엇을 만드는지 살펴보겠습니다:</p>\n<p><img src=\"/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_8.png\" alt=\"Amazon Bedrock Knowledge Bases with Private Data\"></p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>위 다이어그램에서 알 수 있듯이:</p>\n<ul>\n<li>수신 직원 팀의 사용자는 그들의 응용 프로그램을 통해 Amazon API Gateway에 요청을 보냅니다.</li>\n<li>Amazon API Gateway는 쿼리를 기반으로 한 POST 요청에 따라 람다 함수를 호출합니다.</li>\n<li>람다 함수는 사용자의 쿼리를 오픈서치 서버리스 벡터 저장소의 데이터로 보완하기 위해 Bedrock Knowledge Base를 호출합니다.</li>\n<li>S3 버킷에서 객체가 수정, 작성 또는 삭제되면 Ingestion 람다를 호출합니다.</li>\n<li>람다 함수는 수정 사항이 있었기 때문에 Amazon S3 버킷의 데이터를 동기화하기 위해 Knowledge Base를 호출합니다.</li>\n</ul>\n<p>이제 우리가 전체 아키텍처를 토론했으니, 이를 실제로 보고 주요 코드를 설명해 보겠습니다.</p>\n<h1>주요 코드 설명하기 👨‍💻</h1>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>알겠어요. 우리는 이 기본 예제를 살펴보았으니 이제 TypeScript와 CDK 코드를 살펴보겠습니다. 전체 솔루션은 여기에서 찾을 수 있음을 기억해 주세요.</p>\n<h2>상태를 가지는 스택</h2>\n<p>먼저, 저희의 상태를 가지는 스택을 살펴봅시다. 아마존 베드락 지식베이스 및 데이터를 저장할 S3 버킷이 있는 스택입니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 베드락 지식베이스 생성</span>\n<span class=\"hljs-keyword\">const</span> kb = <span class=\"hljs-keyword\">new</span> bedrock.<span class=\"hljs-title class_\">KnowledgeBase</span>(<span class=\"hljs-variable language_\">this</span>, <span class=\"hljs-string\">'BedrockKnowledgeBase'</span>, {\n  <span class=\"hljs-attr\">embeddingsModel</span>: bedrock.<span class=\"hljs-property\">BedrockFoundationModel</span>.<span class=\"hljs-property\">TITAN_EMBED_TEXT_V1</span>,\n  <span class=\"hljs-attr\">instruction</span>: <span class=\"hljs-string\">`환자 기록에 대한 질문에 답변하는 데 사용할 지식베이스입니다.`</span>,\n});\n\n<span class=\"hljs-comment\">// 환자 데이터를 저장하는 S3 버킷 생성 (베드락을 위한 소스)</span>\n<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">bucket</span> = <span class=\"hljs-keyword\">new</span> s3.<span class=\"hljs-title class_\">Bucket</span>(<span class=\"hljs-variable language_\">this</span>, <span class=\"hljs-string\">'PatientRecordsBucket'</span>, {\n  <span class=\"hljs-attr\">bucketName</span>: <span class=\"hljs-string\">'lj-medical-center-patient-records'</span>,\n  <span class=\"hljs-attr\">autoDeleteObjects</span>: <span class=\"hljs-literal\">true</span>,\n  <span class=\"hljs-attr\">removalPolicy</span>: cdk.<span class=\"hljs-property\">RemovalPolicy</span>.<span class=\"hljs-property\">DESTROY</span>,\n});\n</code></pre>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>위의 코드에서는 Titan Text V1 기본 모델을 사용하고 있음을 알 수 있습니다.</p>\n<p>다음으로, 첫 번째 배포 시에는 데이터 폴더에서 예제 문서를 S3 버킷으로 업로드해야 합니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// cdk 배포의 일부로 데이터가 업로드되도록 보장</span>\n<span class=\"hljs-keyword\">new</span> s3deploy.<span class=\"hljs-title class_\">BucketDeployment</span>(<span class=\"hljs-variable language_\">this</span>, <span class=\"hljs-string\">'ClientBucketDeployment'</span>, {\n  <span class=\"hljs-attr\">sources</span>: [s3deploy.<span class=\"hljs-property\">Source</span>.<span class=\"hljs-title function_\">asset</span>(path.<span class=\"hljs-title function_\">join</span>(__dirname, <span class=\"hljs-string\">'../../data/'</span>))],\n  <span class=\"hljs-attr\">destinationBucket</span>: <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">bucket</span>,\n});\n</code></pre>\n<p>마지막으로, 지식 베이스용 데이터 소스를 생성하며, 이는 우리의 S3 버킷을 가리킵니다:</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// knowledge base를 위한 s3 버킷의 데이터 소스 설정</span>\n<span class=\"hljs-keyword\">const</span> dataSource = <span class=\"hljs-keyword\">new</span> bedrock.<span class=\"hljs-title function_\">S3DataSource</span>(<span class=\"hljs-variable language_\">this</span>, <span class=\"hljs-string\">'DataSource'</span>, {\n  <span class=\"hljs-attr\">bucket</span>: <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">bucket</span>,\n  <span class=\"hljs-attr\">knowledgeBase</span>: kb,\n  <span class=\"hljs-attr\">dataSourceName</span>: <span class=\"hljs-string\">'patients'</span>,\n  <span class=\"hljs-attr\">chunkingStrategy</span>: bedrock.<span class=\"hljs-property\">ChunkingStrategy</span>.<span class=\"hljs-property\">DEFAULT</span>,\n  <span class=\"hljs-attr\">maxTokens</span>: <span class=\"hljs-number\">500</span>,\n  <span class=\"hljs-attr\">overlapPercentage</span>: <span class=\"hljs-number\">20</span>,\n});\n</code></pre>\n<p>Stateful 스택을 배포하려면 npm 스크립트 npm run deploy:stateful을 사용하고, 완료되면 콘솔에 로그인하여 '동기화'를 실행할 수 있습니다:</p>\n<h2>Stateless Stack</h2>\n<p>이제 Stateless 스택을 살펴보겠습니다. 우선 S3 트리거를 추가하여 S3 버킷 내에서 변경 사항(새 파일, 수정, 삭제 등)이 발생할 때 Ingestion Lambda 함수를 호출하는 방법을 살펴보겠습니다:</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 객체가 추가, 수정 또는 삭제될 때의 s3 이벤트 소스를 만듭니다</span>\nbucket.<span class=\"hljs-title function_\">addEventNotification</span>(\n  s3.<span class=\"hljs-property\">EventType</span>.<span class=\"hljs-property\">OBJECT_CREATED_PUT</span>,\n  <span class=\"hljs-keyword\">new</span> s3n.<span class=\"hljs-title class_\">LambdaDestination</span>(ingestionLambda)\n);\nbucket.<span class=\"hljs-title function_\">addEventNotification</span>(\n  s3.<span class=\"hljs-property\">EventType</span>.<span class=\"hljs-property\">OBJECT_REMOVED</span>,\n  <span class=\"hljs-keyword\">new</span> s3n.<span class=\"hljs-title class_\">LambdaDestination</span>(ingestionLambda)\n);\n</code></pre>\n<p>그런 다음 Ingestion Lambda에는 데이터 소스를 동기화하기 위해 다음 코드를 실행하는 보조 어댑터가 있습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> {\n  <span class=\"hljs-title class_\">BedrockAgentClient</span>,\n  <span class=\"hljs-title class_\">StartIngestionJobCommand</span>,\n  <span class=\"hljs-title class_\">StartIngestionJobCommandInput</span>,\n  <span class=\"hljs-title class_\">StartIngestionJobCommandOutput</span>,\n} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@aws-sdk/client-bedrock-agent'</span>;\n\n<span class=\"hljs-keyword\">import</span> { config } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@config'</span>;\n<span class=\"hljs-keyword\">import</span> { logger } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@shared/logger'</span>;\n<span class=\"hljs-keyword\">import</span> { v4 <span class=\"hljs-keyword\">as</span> uuid } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'uuid'</span>;\n\n<span class=\"hljs-keyword\">const</span> client = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BedrockAgentClient</span>();\n<span class=\"hljs-keyword\">const</span> knowledgeBaseId = config.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">'knowledgeBaseId'</span>);\n<span class=\"hljs-keyword\">const</span> dataSourceId = config.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">'dataSourceId'</span>);\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">ingestionProcess</span>(<span class=\"hljs-params\"></span>): <span class=\"hljs-title class_\">Promise</span>&#x3C;string> {\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">input</span>: <span class=\"hljs-title class_\">StartIngestionJobCommandInput</span> = {\n    <span class=\"hljs-attr\">knowledgeBaseId</span>: knowledgeBaseId,\n    <span class=\"hljs-attr\">dataSourceId</span>: dataSourceId,\n    <span class=\"hljs-attr\">clientToken</span>: <span class=\"hljs-title function_\">uuid</span>(),\n  };\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">command</span>: <span class=\"hljs-title class_\">StartIngestionJobCommand</span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StartIngestionJobCommand</span>(input);\n\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">response</span>: <span class=\"hljs-title class_\">StartIngestionJobCommandOutput</span> = <span class=\"hljs-keyword\">await</span> client.<span class=\"hljs-title function_\">send</span>(command);\n  logger.<span class=\"hljs-title function_\">info</span>(<span class=\"hljs-string\">`response: <span class=\"hljs-subst\">${response}</span>`</span>);\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>({\n    <span class=\"hljs-attr\">ingestionJob</span>: response.<span class=\"hljs-property\">ingestionJob</span>,\n  });\n}\n</code></pre>\n<p>다음으로 Lambda 함수가 동기화 수행을 허용하기 위해 필요한 IAM 정책을 살펴보겠습니다:</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\"> <span class=\"hljs-comment\">// ensure that the lambda function can start a data ingestion job</span>\ningestionLambda.<span class=\"hljs-title function_\">addToRolePolicy</span>(\n  <span class=\"hljs-keyword\">new</span> iam.<span class=\"hljs-title class_\">PolicyStatement</span>({\n    <span class=\"hljs-attr\">actions</span>: [<span class=\"hljs-string\">'bedrock:StartIngestionJob'</span>],\n    <span class=\"hljs-attr\">resources</span>: [knowledgeBaseArn],\n  })\n);\n</code></pre>\n<p>우리 쿼리 람다에 유사한 정책을 추가합니다. 이 정책에 따라 쿼리 람다가 Amazon Bedrock에 대해 작업을 수행할 수 있게 됩니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 쿼리 람다 함수가 모델을 쿼리할 수 있도록 허용합니다</span>\nqueryModelLambda.<span class=\"hljs-title function_\">addToRolePolicy</span>(\n  <span class=\"hljs-keyword\">new</span> iam.<span class=\"hljs-title class_\">PolicyStatement</span>({\n    <span class=\"hljs-attr\">actions</span>: [\n      <span class=\"hljs-string\">'bedrock:RetrieveAndGenerate'</span>,\n      <span class=\"hljs-string\">'bedrock:Retrieve'</span>,\n      <span class=\"hljs-string\">'bedrock:InvokeModel'</span>,\n    ],\n    <span class=\"hljs-attr\">resources</span>: [<span class=\"hljs-string\">'*'</span>],\n  })\n);\n</code></pre>\n<p>쿼리 람다의 두 번째 어댑터에 대한 코드가 아래에 표시되어 있습니다:</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> {\n  <span class=\"hljs-title class_\">BedrockAgentRuntimeClient</span>,\n  <span class=\"hljs-title class_\">RetrieveAndGenerateCommand</span>,\n  <span class=\"hljs-title class_\">RetrieveAndGenerateCommandInput</span>,\n  <span class=\"hljs-title class_\">RetrieveAndGenerateCommandOutput</span>,\n} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@aws-sdk/client-bedrock-agent-runtime'</span>;\n\n<span class=\"hljs-keyword\">import</span> { config } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@config'</span>;\n\n<span class=\"hljs-keyword\">const</span> client = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BedrockAgentRuntimeClient</span>();\n<span class=\"hljs-keyword\">const</span> knowledgeBaseId = config.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">'knowledgeBaseId'</span>);\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">queryModel</span>(<span class=\"hljs-params\">prompt: string</span>): <span class=\"hljs-title class_\">Promise</span>&#x3C;string> {\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">input</span>: <span class=\"hljs-title class_\">RetrieveAndGenerateCommandInput</span> = {\n    <span class=\"hljs-attr\">input</span>: {\n      <span class=\"hljs-attr\">text</span>: prompt,\n    },\n    <span class=\"hljs-attr\">retrieveAndGenerateConfiguration</span>: {\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'KNOWLEDGE_BASE'</span>,\n      <span class=\"hljs-attr\">knowledgeBaseConfiguration</span>: {\n        <span class=\"hljs-attr\">knowledgeBaseId</span>: knowledgeBaseId,\n        <span class=\"hljs-comment\">// we are using Anthropic Claude v2 in us-east-1 in this example</span>\n        <span class=\"hljs-attr\">modelArn</span>: <span class=\"hljs-string\">`arn:aws:bedrock:us-east-1::foundation-model/anthropic.claude-v2`</span>,\n      },\n    },\n  };\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">command</span>: <span class=\"hljs-title class_\">RetrieveAndGenerateCommand</span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RetrieveAndGenerateCommand</span>(\n    input\n  );\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">response</span>: <span class=\"hljs-title class_\">RetrieveAndGenerateCommandOutput</span> = <span class=\"hljs-keyword\">await</span> client.<span class=\"hljs-title function_\">send</span>(command);\n  <span class=\"hljs-keyword\">return</span> response.<span class=\"hljs-property\">output</span>?.<span class=\"hljs-property\">text</span> <span class=\"hljs-keyword\">as</span> string;\n}\n</code></pre>\n<p>마지막 단계는 우리의 Amazon API Gateway를 추가하고, /queries/ 리소스에 대해 Query Lambda 함수를 호출하도록 허용하는 것입니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 우리 수의원 앱에서 사용할 API를 생성합니다</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">api</span>: apigw.<span class=\"hljs-property\">RestApi</span> = <span class=\"hljs-keyword\">new</span> apigw.<span class=\"hljs-title class_\">RestApi</span>(<span class=\"hljs-variable language_\">this</span>, <span class=\"hljs-string\">'Api'</span>, {\n  <span class=\"hljs-attr\">description</span>: <span class=\"hljs-string\">'LJ Medical Center API'</span>,\n  <span class=\"hljs-attr\">restApiName</span>: <span class=\"hljs-string\">'lj-medical-center-api'</span>,\n  <span class=\"hljs-attr\">deploy</span>: <span class=\"hljs-literal\">true</span>,\n  <span class=\"hljs-attr\">endpointTypes</span>: [apigw.<span class=\"hljs-property\">EndpointType</span>.<span class=\"hljs-property\">REGIONAL</span>],\n  <span class=\"hljs-attr\">deployOptions</span>: {\n    <span class=\"hljs-attr\">stageName</span>: <span class=\"hljs-string\">'prod'</span>,\n    <span class=\"hljs-attr\">dataTraceEnabled</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">loggingLevel</span>: apigw.<span class=\"hljs-property\">MethodLoggingLevel</span>.<span class=\"hljs-property\">INFO</span>,\n    <span class=\"hljs-attr\">tracingEnabled</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">metricsEnabled</span>: <span class=\"hljs-literal\">true</span>,\n  },\n});\n\n<span class=\"hljs-comment\">// API에 대한 쿼리 리소스 생성</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">queries</span>: apigw.<span class=\"hljs-property\">Resource</span> = api.<span class=\"hljs-property\">root</span>.<span class=\"hljs-title function_\">addResource</span>(<span class=\"hljs-string\">'queries'</span>);\n\n<span class=\"hljs-comment\">// 지식 베이스 쿼리 엔드포인트 추가 (POST) - prod/queries/</span>\nqueries.<span class=\"hljs-title function_\">addMethod</span>(\n  <span class=\"hljs-string\">'POST'</span>,\n  <span class=\"hljs-keyword\">new</span> apigw.<span class=\"hljs-title class_\">LambdaIntegration</span>(queryModelLambda, {\n    <span class=\"hljs-attr\">proxy</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">allowTestInvoke</span>: <span class=\"hljs-literal\">false</span>,\n  })\n);\n</code></pre>\n<p>이제 npm 스크립트 npm run deploy:stateless로 무상태 스택을 배포하고 기능을 테스트할 수 있습니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h1>앱 테스트 🧪</h1>\n<h2>Postman을 통한 테스팅</h2>\n<p>postman/Bedrock Knowledge Bases.postman_collection.json 파일을 사용하여 자신의 URL 정보로 테스트할 수 있습니다.</p>\n<p>늦은 지불에 관한 간단한 쿼리를 시작해보세요:</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>위의 스크린샷에서 올바른 응답을 받았음을 확인할 수 있습니다:</p>\n<p>그런 다음 다음과 같은 쿼리를 요청할 수 있습니다:</p>\n<p>위의 쿼리에서 답변을 성공적으로 받았음을 확인할 수 있습니다:</p>\n<p>위의 예시는 우리 접수 직원이 모든 정책에서 필요한 정보를 빠르게 찾을 수 있는 두 가지 예시에 불과합니다.</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>어째서 이 기능을 사용해보지 않고 가상의 환자 기록을 추가해 보시겠어요? 솔루션을 배포하는 비용을 기억해 주세요!</p>\n<h1>마무리 인사 👋🏽</h1>\n<p>이 글을 즐겁게 읽어주셨으면 공유와 피드백도 부탁드립니다!</p>\n<p>제 유튜브 채널을 방문해 비슷한 콘텐츠를 구독해주세요!</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p><img src=\"/assets/img/2024-07-07-AmazonBedrockKnowledgeBaseswithPrivateData_9.png\" alt=\"이미지\"></p>\n<p>함께 소통하고 싶어요! 아래 링크에서 저와 연계해 주세요:</p>\n<p><a href=\"https://www.linkedin.com/in/lee-james-gilmore/\" rel=\"nofollow\" target=\"_blank\">LinkedIn</a>\n<a href=\"https://twitter.com/LeeJamesGilmore\" rel=\"nofollow\" target=\"_blank\">Twitter</a></p>\n<p>만약 글을 즐겼다면, 저의 프로필 Lee James Gilmore를 팔로우하여 더 많은 글/시리즈를 만나보세요. 그리고 연락하여 인사도 잊지 마세요! 👋</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h2>나에 대해</h2>\n<p>“안녕하세요, 저는 영국을 기반으로 하는 AWS 커뮤니티 빌더, 블로거, AWS 인증 클라우드 아키텍트이자 City Electrical Factors (UK) &#x26; City Electric Supply (US)에서 글로벌 기술 및 아키텍처 총괄을 맡고 있는 Lee입니다. 지난 6년간 주로 AWS에서 풀스택 JavaScript 개발을 하였습니다.</p>\n<p>저는 서버리스를 주장하는 사람으로, AWS, 혁신, 소프트웨어 아키텍처, 기술 전반에 관심을 가지고 있습니다.”\n클래프 기능을 사용하여 이 게시물이 마음에 드셨다면 반드시 박수를 눌러주세요! (여러 번 박수를 두드릴 수 있어요!!)</p>\n<!-- TIL 수평 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>*** 제공된 정보는 제 개인적인 의견이며 정보 사용에 대한 책임은 지지 않습니다. ***</p>\n<p>아래 정보도 참고하실만 합니다:</p>\n</body>\n</html>\n"},"__N_SSG":true}