<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Nextjs 15 웹사이트에서 userAgent 쉽게 확인하는 방법 | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-userAgent" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Nextjs 15 웹사이트에서 userAgent 쉽게 확인하는 방법 | TIL" data-gatsby-head="true"/><meta property="og:title" content="Nextjs 15 웹사이트에서 userAgent 쉽게 확인하는 방법 | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-userAgent" data-gatsby-head="true"/><meta name="twitter:title" content="Nextjs 15 웹사이트에서 userAgent 쉽게 확인하는 방법 | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2025-04-22 12:58" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/0eef537492fed77a.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/0eef537492fed77a.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/post/%5Bslug%5D-8ded8b979ba73586.js" defer=""></script><script src="/TIL/_next/static/M7pU9hOcx8u_ZIFMf95sd/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/M7pU9hOcx8u_ZIFMf95sd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Nextjs 15 웹사이트에서 userAgent 쉽게 확인하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Nextjs 15 웹사이트에서 userAgent 쉽게 확인하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Apr 22, 2025</span><span class="posts_reading_time__f7YPP">8<!-- --> min read</span></span></div></div></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h1>userAgent 사용하기</h1>
<p>Next.js에서 <code>userAgent</code> 헬퍼는 Web Request API를 확장해서, 들어오는 요청(request)에서 유저 에이전트(user agent) 정보를 쉽게 다룰 수 있도록 도와줘요. 예를 들어, 어떤 기기에서 접속했는지(device type)를 파악하는 데 아주 유용하죠.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">NextRequest</span>, <span class="hljs-title class_">NextResponse</span>, userAgent } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/server'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">middleware</span>(<span class="hljs-params">request: NextRequest</span>) {
  <span class="hljs-keyword">const</span> url = request.<span class="hljs-property">nextUrl</span>
  <span class="hljs-keyword">const</span> { device } = <span class="hljs-title function_">userAgent</span>(request)

  <span class="hljs-comment">// device.type에는 'mobile', 'tablet', 'console', 'smarttv',</span>
  <span class="hljs-comment">// 'wearable', 'embedded' 또는 'desktop'(undefined일 때) 같은 값이 들어와요.</span>
  <span class="hljs-keyword">const</span> viewport = device.<span class="hljs-property">type</span> || <span class="hljs-string">'desktop'</span>

  url.<span class="hljs-property">searchParams</span>.<span class="hljs-title function_">set</span>(<span class="hljs-string">'viewport'</span>, viewport)
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">NextResponse</span>.<span class="hljs-title function_">rewrite</span>(url)
}
</code></pre>
<p>위 코드에서는 미들웨어 안에서 요청 객체 <code>request</code>를 이용해 <code>userAgent(request)</code>를 호출하고, 그 결과로부터 기기 타입(<code>device.type</code>)을 얻고 있어요. 그리고 이 정보를 쿼리 파라미터로 추가해서 나중에 라우팅이나 렌더링 시 조건문으로 활용할 수 있도록 했답니다.</p>
<hr>
<h2>isBot 속성 활용하기</h2>
<p><code>userAgent</code> 헬퍼는 단순히 기기 타입뿐 아니라, 방문자가 봇(bot)인지 아닌지도 알려주는 <code>isBot</code> 속성도 제공해요. 이걸 활용하면, 봇이 방문할 때 SEO 최적화나 캐싱 전략을 다르게 적용하는 등의 스마트한 대응이 가능하죠.</p>
<p>예시를 들어볼게요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">NextRequest</span>, <span class="hljs-title class_">NextResponse</span>, userAgent } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/server'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">middleware</span>(<span class="hljs-params">request: NextRequest</span>) {
  <span class="hljs-keyword">const</span> { isBot } = <span class="hljs-title function_">userAgent</span>(request)

  <span class="hljs-keyword">if</span> (isBot) {
    <span class="hljs-comment">// 봇 방문자라면, 예를 들어, 캐싱을 더 강하게 적용하거나 </span>
    <span class="hljs-comment">// 특정 페이지로 리다이렉트 할 수도 있어요.</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'봇 방문 감지됨!'</span>)
  }

  <span class="hljs-keyword">return</span> <span class="hljs-title class_">NextResponse</span>.<span class="hljs-title function_">next</span>()
}
</code></pre>
<p>이처럼 <code>isBot</code>은 크롤러나 검색 엔진 봇 감지에 유용하니, SEO를 신경 쓰는 프로젝트라면 꼭 활용해보세요.</p>
<hr>
<h3>참고: device.type 예상 값 정리</h3>





































<table><thead><tr><th>device.type</th><th>설명</th></tr></thead><tbody><tr><td>mobile</td><td>모바일 기기 (스마트폰 등)</td></tr><tr><td>tablet</td><td>태블릿 기기</td></tr><tr><td>console</td><td>게임 콘솔</td></tr><tr><td>smarttv</td><td>스마트 TV</td></tr><tr><td>wearable</td><td>스마트 워치 같은 웨어러블 디바이스</td></tr><tr><td>embedded</td><td>내장형 디바이스</td></tr><tr><td>undefined</td><td>데스크탑 브라우저 (특별한 타입 없을 때)</td></tr></tbody></table>
<hr>
<p>마지막으로, <code>userAgent</code> 헬퍼는 사용자 단말 정보 기반 맞춤 UI나 미디어 쿼리 없이 기기 특성 판별이 필요한 상황에서 정말 강력한 도구니까, Next.js 프로젝트를 다룰 때 많이 활용해보면 좋습니다!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>요청이 알려진 봇(bot)인지 여부를 나타내는 불리언 값이 있어요.</p>
<h2>browser</h2>
<p>요청에 사용된 브라우저에 대한 정보를 담고 있는 객체입니다.</p>
<ul>
<li>name: 브라우저 이름을 나타내는 문자열이에요. 만약 식별이 불가능하면 undefined가 될 수 있습니다.</li>
<li>version: 브라우저 버전을 나타내는 문자열이며, 역시 알 수 없는 경우엔 undefined가 됩니다.</li>
</ul>
<hr>
<p>참고로, 클라이언트가 어떤 브라우저를 쓰는지 아는 건 다양한 이유에서 유용해요. 예를 들어, 특정 브라우저에서만 발생하는 버그를 파악하거나, 특정 버전에 맞게 기능을 조정하는 거죠.</p>
<p>또, 사용자 경험을 개선하기 위해서도 브라우저 정보는 중요해요. 만약 너무 오래된 버전을 쓰는 사용자가 많다면, 최신 기능 지원 여부를 알 수 있으니까요.</p>
<p>Markdown 방식으로 표로 정리해봤어요!</p>





























<table><thead><tr><th>속성명</th><th>설명</th><th>타입</th><th>비고</th></tr></thead><tbody><tr><td>isBot</td><td>요청이 알려진 봇인지 여부</td><td>Boolean</td><td>true 또는 false</td></tr><tr><td>name</td><td>브라우저 이름</td><td>String</td><td>식별 불가 시 undefined</td></tr><tr><td>version</td><td>브라우저 버전</td><td>String</td><td>식별 불가 시 undefined</td></tr></tbody></table>
<p>이렇게 정보를 잘 활용하면 API를 더 똑똑하게, 사용자에게 더 친절하게 만들 수 있답니다!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>device</h2>
<p>요청에 사용된 기기에 대한 정보를 담고 있는 객체입니다.</p>





















<table><thead><tr><th>속성명</th><th>설명</th></tr></thead><tbody><tr><td>model</td><td>기기의 모델명을 나타내는 문자열입니다. 값이 없을 경우 <code>undefined</code>일 수 있어요.</td></tr><tr><td>type</td><td>기기 종류를 나타내는 문자열로, <code>console</code>, <code>mobile</code>, <code>tablet</code>, <code>smarttv</code>, <code>wearable</code>, <code>embedded</code> 중 하나거나 <code>undefined</code>일 수 있어요.</td></tr><tr><td>vendor</td><td>기기 제조사명을 표시하는 문자열입니다. 없으면 <code>undefined</code>가 될 수 있어요.</td></tr></tbody></table>
<p>기기 정보를 활용하면 어떤 환경에서 접속했는지 파악하기 쉽기 때문에 UI나 기능을 그에 맞게 최적화하기 좋아요. 예를 들어 스마트 TV와 모바일은 화면 크기 차이가 크니, 그에 맞게 인터페이스를 조절할 수 있겠죠?</p>
<h2>engine</h2>
<p>다음은 <code>engine</code>에 대한 설명이 필요하다면 언제든 알려주세요! 기본적으로 <code>engine</code>은 브라우저나 플랫폼 동작의 핵심적인 렌더링 엔진 정보를 나타내는 경우가 많아요. 웹 개발 시엔 이 정보를 통해 브라우저 호환성을 체크하는 데 유용하죠.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>브라우저 엔진(engine)에 대한 정보를 담고 있는 객체에 대해 조금 쉽게 설명해볼게요.</p>
<h3>브라우저 엔진 정보 객체</h3>
<p>이 객체는 우리가 사용하는 브라우저가 어떤 엔진을 쓰고 있는지 알려줘요. 엔진이라는 건 쉽게 말해, 웹페이지를 해석하고 화면에 보여주는 소프트웨어 핵심 부분이에요.</p>
<ul>
<li><strong>name</strong>: 이건 엔진의 이름을 문자열로 알려줘요. 예를 들어 Amaya, Blink, EdgeHTML, Gecko, WebKit 등 꽤 다양한 엔진들이 있고, 어떤 브라우저가 어느 엔진을 쓰는지 판단할 수 있죠.</li>
<li><strong>version</strong>: 그리고 그 엔진의 버전도 문자열로 알려주고, 가끔은 undefined일 수도 있어요.</li>
</ul>
<p>브라우저 엔진을 알면, 웹 개발할 때 특정 엔진에서 잘못 표시되거나 동작하는 문제를 잡는데 도움이 돼요. 예를 들면, 구글 크롬은 Blink 엔진, 사파리는 WebKit 엔진을 쓰는 식이에요.</p>
<hr>
<h3>OS (운영체제) 정보 객체</h3>
<p>이 객체는 컴퓨터나 모바일 기기에서 어떤 운영체제를 쓰고 있는지 알려줘요. OS 정보는 웹사이트를 최적화하거나, 특정 OS에서만 작동하는 기능을 설정할 때 쓰이죠.</p>
<hr>
<p>표로 정리하면 이렇게 될 거예요.</p>





















<table><thead><tr><th>속성</th><th>설명</th></tr></thead><tbody><tr><td>name</td><td>브라우저 엔진 이름 (예: Amaya, Blink, EdgeHTML, Gecko, WebKit 등)</td></tr><tr><td>version</td><td>엔진 버전 문자열, 없으면 undefined</td></tr><tr><td>os</td><td>운영체제 정보 객체</td></tr></tbody></table>
<p>필요하면 OS 정보에 대해서도 더 자세히 다뤄볼게요. 실제로 개발할 때는 userAgent 라이브러리나 플랫폼 감지 API를 통해 이런 정보를 쉽게 얻을 수 있죠.</p>
<p>필요하면 내가 사용해본 라이브러리도 추천해줄게요. 혹시 궁금하면 말해주세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>자, 오늘은 운영체제(OS)와 CPU에 대한 정보를 담고 있는 데이터 구조에 대해 얘기해볼게요. 개발하면서 시스템 정보를 처리해야 할 때 종종 마주치는 내용인데, 이해하기 쉽게 정리해볼게요.</p>
<hr>
<h3>운영체제 정보 (OS)</h3>
<ul>
<li><code>name</code>: 운영체제의 이름을 문자열로 나타내요. 예를 들어, 'Windows', 'Linux', 'macOS' 같은 것들이죠. 만약 정보가 없으면 undefined일 수 있어요.</li>
<li><code>version</code>: 운영체제의 버전을 문자열로 나타내요. 예를 들어 '10.0.19042' 같은 숫자나 'Big Sur'처럼 이름 형태가 될 수도 있죠. 역시 없으면 undefined일 수도 있어요.</li>
</ul>
<p>이렇게 이름과 버전을 알면 해당 운영체제에 맞는 분기 처리를 하거나 업데이트 정보를 관리하는 데 유용하죠.</p>
<hr>
<h3>CPU 정보</h3>
<p>CPU 정보는 보통 CPU 아키텍처 <em>architecture</em>에 초점을 맞춥니다.</p>















<table><thead><tr><th>필드</th><th>설명</th><th>예시</th></tr></thead><tbody><tr><td>architecture</td><td>CPU 아키텍처를 나타내는 문자열입니다.</td><td>68k, amd64, arm, arm64, armhf, avr, ia32, ia64, mips 등</td></tr></tbody></table>
<p>여기서 가능한 아키텍처 값들은 꽤 다양합니다. 흔히 개발할 때 많이 듣는 건 <code>amd64</code> (x86-64), <code>arm64</code> (애플 M1/M2, 최신 모바일 기기), <code>ia32</code> (x86 32비트), 그리고 <code>arm</code> (주로 모바일용) 정도가 있죠.</p>
<hr>
<h4>추가 팁!</h4>
<ul>
<li>CPU 아키텍처와 OS 정보를 함께 알면, 예를 들어 어느 환경에서 특정 바이너리가 돌아가는지 정확히 파악할 수 있어요.</li>
<li>웹 개발할 때도 클라이언트나 서버의 환경을 파악해서 최적화 또는 디버깅하는 데 도움이 됩니다.</li>
<li>Node.js 환경에서는 <code>process.arch</code> (CPU 아키텍처)랑 <code>process.platform</code> (운영체제) 같은 내장 변수를 활용해 비슷한 정보를 얻을 수 있어요.</li>
</ul>
<hr>
<p>필요할 때 이 정보를 잘 활용해서 더 똑똑한 환경별 로직을 작성해 보세요. 그럼 오늘 내용은 여기까지!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Nextjs 15 웹사이트에서 userAgent 쉽게 확인하는 방법","description":"","date":"2025-04-22 12:58","slug":"2025-04-22-userAgent","content":"\n\n# userAgent 사용하기\n\nNext.js에서 `userAgent` 헬퍼는 Web Request API를 확장해서, 들어오는 요청(request)에서 유저 에이전트(user agent) 정보를 쉽게 다룰 수 있도록 도와줘요. 예를 들어, 어떤 기기에서 접속했는지(device type)를 파악하는 데 아주 유용하죠.\n\n```js\nimport { NextRequest, NextResponse, userAgent } from 'next/server'\n\nexport function middleware(request: NextRequest) {\n  const url = request.nextUrl\n  const { device } = userAgent(request)\n\n  // device.type에는 'mobile', 'tablet', 'console', 'smarttv',\n  // 'wearable', 'embedded' 또는 'desktop'(undefined일 때) 같은 값이 들어와요.\n  const viewport = device.type || 'desktop'\n\n  url.searchParams.set('viewport', viewport)\n  return NextResponse.rewrite(url)\n}\n```\n\n위 코드에서는 미들웨어 안에서 요청 객체 `request`를 이용해 `userAgent(request)`를 호출하고, 그 결과로부터 기기 타입(`device.type`)을 얻고 있어요. 그리고 이 정보를 쿼리 파라미터로 추가해서 나중에 라우팅이나 렌더링 시 조건문으로 활용할 수 있도록 했답니다.\n\n---\n\n## isBot 속성 활용하기\n\n`userAgent` 헬퍼는 단순히 기기 타입뿐 아니라, 방문자가 봇(bot)인지 아닌지도 알려주는 `isBot` 속성도 제공해요. 이걸 활용하면, 봇이 방문할 때 SEO 최적화나 캐싱 전략을 다르게 적용하는 등의 스마트한 대응이 가능하죠.\n\n예시를 들어볼게요:\n\n```js\nimport { NextRequest, NextResponse, userAgent } from 'next/server'\n\nexport function middleware(request: NextRequest) {\n  const { isBot } = userAgent(request)\n\n  if (isBot) {\n    // 봇 방문자라면, 예를 들어, 캐싱을 더 강하게 적용하거나 \n    // 특정 페이지로 리다이렉트 할 수도 있어요.\n    console.log('봇 방문 감지됨!')\n  }\n\n  return NextResponse.next()\n}\n```\n\n이처럼 `isBot`은 크롤러나 검색 엔진 봇 감지에 유용하니, SEO를 신경 쓰는 프로젝트라면 꼭 활용해보세요.\n\n---\n\n### 참고: device.type 예상 값 정리\n\n| device.type  | 설명                                      |\n|--------------|-------------------------------------------|\n| mobile       | 모바일 기기 (스마트폰 등)                 |\n| tablet       | 태블릿 기기                              |\n| console      | 게임 콘솔                                |\n| smarttv      | 스마트 TV                               |\n| wearable     | 스마트 워치 같은 웨어러블 디바이스       |\n| embedded     | 내장형 디바이스                          |\n| undefined    | 데스크탑 브라우저 (특별한 타입 없을 때) |\n\n---\n\n마지막으로, `userAgent` 헬퍼는 사용자 단말 정보 기반 맞춤 UI나 미디어 쿼리 없이 기기 특성 판별이 필요한 상황에서 정말 강력한 도구니까, Next.js 프로젝트를 다룰 때 많이 활용해보면 좋습니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n요청이 알려진 봇(bot)인지 여부를 나타내는 불리언 값이 있어요.\n\n## browser\n\n요청에 사용된 브라우저에 대한 정보를 담고 있는 객체입니다.\n\n- name: 브라우저 이름을 나타내는 문자열이에요. 만약 식별이 불가능하면 undefined가 될 수 있습니다.\n- version: 브라우저 버전을 나타내는 문자열이며, 역시 알 수 없는 경우엔 undefined가 됩니다.\n\n---\n\n참고로, 클라이언트가 어떤 브라우저를 쓰는지 아는 건 다양한 이유에서 유용해요. 예를 들어, 특정 브라우저에서만 발생하는 버그를 파악하거나, 특정 버전에 맞게 기능을 조정하는 거죠. \n\n또, 사용자 경험을 개선하기 위해서도 브라우저 정보는 중요해요. 만약 너무 오래된 버전을 쓰는 사용자가 많다면, 최신 기능 지원 여부를 알 수 있으니까요.\n\nMarkdown 방식으로 표로 정리해봤어요!\n\n| 속성명   | 설명                                 | 타입        | 비고                |\n|---------|------------------------------------|------------|---------------------|\n| isBot   | 요청이 알려진 봇인지 여부           | Boolean    | true 또는 false      |\n| name    | 브라우저 이름                      | String     | 식별 불가 시 undefined |\n| version | 브라우저 버전                      | String     | 식별 불가 시 undefined |\n\n이렇게 정보를 잘 활용하면 API를 더 똑똑하게, 사용자에게 더 친절하게 만들 수 있답니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## device\n\n요청에 사용된 기기에 대한 정보를 담고 있는 객체입니다.\n\n| 속성명  | 설명                                                                                   |\n|---------|----------------------------------------------------------------------------------------|\n| model   | 기기의 모델명을 나타내는 문자열입니다. 값이 없을 경우 `undefined`일 수 있어요.             |\n| type    | 기기 종류를 나타내는 문자열로, `console`, `mobile`, `tablet`, `smarttv`, `wearable`, `embedded` 중 하나거나 `undefined`일 수 있어요. |\n| vendor  | 기기 제조사명을 표시하는 문자열입니다. 없으면 `undefined`가 될 수 있어요.                   |\n\n기기 정보를 활용하면 어떤 환경에서 접속했는지 파악하기 쉽기 때문에 UI나 기능을 그에 맞게 최적화하기 좋아요. 예를 들어 스마트 TV와 모바일은 화면 크기 차이가 크니, 그에 맞게 인터페이스를 조절할 수 있겠죠?\n\n## engine\n\n다음은 `engine`에 대한 설명이 필요하다면 언제든 알려주세요! 기본적으로 `engine`은 브라우저나 플랫폼 동작의 핵심적인 렌더링 엔진 정보를 나타내는 경우가 많아요. 웹 개발 시엔 이 정보를 통해 브라우저 호환성을 체크하는 데 유용하죠.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n브라우저 엔진(engine)에 대한 정보를 담고 있는 객체에 대해 조금 쉽게 설명해볼게요.\n\n### 브라우저 엔진 정보 객체\n\n이 객체는 우리가 사용하는 브라우저가 어떤 엔진을 쓰고 있는지 알려줘요. 엔진이라는 건 쉽게 말해, 웹페이지를 해석하고 화면에 보여주는 소프트웨어 핵심 부분이에요.\n\n- **name**: 이건 엔진의 이름을 문자열로 알려줘요. 예를 들어 Amaya, Blink, EdgeHTML, Gecko, WebKit 등 꽤 다양한 엔진들이 있고, 어떤 브라우저가 어느 엔진을 쓰는지 판단할 수 있죠.\n- **version**: 그리고 그 엔진의 버전도 문자열로 알려주고, 가끔은 undefined일 수도 있어요.\n\n브라우저 엔진을 알면, 웹 개발할 때 특정 엔진에서 잘못 표시되거나 동작하는 문제를 잡는데 도움이 돼요. 예를 들면, 구글 크롬은 Blink 엔진, 사파리는 WebKit 엔진을 쓰는 식이에요.\n\n---\n\n### OS (운영체제) 정보 객체\n\n이 객체는 컴퓨터나 모바일 기기에서 어떤 운영체제를 쓰고 있는지 알려줘요. OS 정보는 웹사이트를 최적화하거나, 특정 OS에서만 작동하는 기능을 설정할 때 쓰이죠.\n\n---\n\n표로 정리하면 이렇게 될 거예요.\n\n| 속성    | 설명                                                                                                     |\n|---------|--------------------------------------------------------------------------------------------------------|\n| name    | 브라우저 엔진 이름 (예: Amaya, Blink, EdgeHTML, Gecko, WebKit 등)                                      |\n| version | 엔진 버전 문자열, 없으면 undefined                                                                     |\n| os      | 운영체제 정보 객체                                                                                      |\n\n필요하면 OS 정보에 대해서도 더 자세히 다뤄볼게요. 실제로 개발할 때는 userAgent 라이브러리나 플랫폼 감지 API를 통해 이런 정보를 쉽게 얻을 수 있죠.\n\n필요하면 내가 사용해본 라이브러리도 추천해줄게요. 혹시 궁금하면 말해주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자, 오늘은 운영체제(OS)와 CPU에 대한 정보를 담고 있는 데이터 구조에 대해 얘기해볼게요. 개발하면서 시스템 정보를 처리해야 할 때 종종 마주치는 내용인데, 이해하기 쉽게 정리해볼게요.\n\n---\n\n### 운영체제 정보 (OS)\n\n- `name`: 운영체제의 이름을 문자열로 나타내요. 예를 들어, 'Windows', 'Linux', 'macOS' 같은 것들이죠. 만약 정보가 없으면 undefined일 수 있어요.\n- `version`: 운영체제의 버전을 문자열로 나타내요. 예를 들어 '10.0.19042' 같은 숫자나 'Big Sur'처럼 이름 형태가 될 수도 있죠. 역시 없으면 undefined일 수도 있어요.\n\n이렇게 이름과 버전을 알면 해당 운영체제에 맞는 분기 처리를 하거나 업데이트 정보를 관리하는 데 유용하죠.\n\n---\n\n### CPU 정보\n\nCPU 정보는 보통 CPU 아키텍처 *architecture*에 초점을 맞춥니다. \n\n| 필드          | 설명                                   | 예시                                                   |\n|--------------|--------------------------------------|--------------------------------------------------------|\n| architecture | CPU 아키텍처를 나타내는 문자열입니다. | 68k, amd64, arm, arm64, armhf, avr, ia32, ia64, mips 등 |\n\n여기서 가능한 아키텍처 값들은 꽤 다양합니다. 흔히 개발할 때 많이 듣는 건 `amd64` (x86-64), `arm64` (애플 M1/M2, 최신 모바일 기기), `ia32` (x86 32비트), 그리고 `arm` (주로 모바일용) 정도가 있죠.\n\n---\n\n#### 추가 팁!\n\n- CPU 아키텍처와 OS 정보를 함께 알면, 예를 들어 어느 환경에서 특정 바이너리가 돌아가는지 정확히 파악할 수 있어요.\n- 웹 개발할 때도 클라이언트나 서버의 환경을 파악해서 최적화 또는 디버깅하는 데 도움이 됩니다.\n- Node.js 환경에서는 `process.arch` (CPU 아키텍처)랑 `process.platform` (운영체제) 같은 내장 변수를 활용해 비슷한 정보를 얻을 수 있어요.\n\n---\n\n필요할 때 이 정보를 잘 활용해서 더 똑똑한 환경별 로직을 작성해 보세요. 그럼 오늘 내용은 여기까지!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":8},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch1\u003euserAgent 사용하기\u003c/h1\u003e\n\u003cp\u003eNext.js에서 \u003ccode\u003euserAgent\u003c/code\u003e 헬퍼는 Web Request API를 확장해서, 들어오는 요청(request)에서 유저 에이전트(user agent) 정보를 쉽게 다룰 수 있도록 도와줘요. 예를 들어, 어떤 기기에서 접속했는지(device type)를 파악하는 데 아주 유용하죠.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eNextRequest\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eNextResponse\u003c/span\u003e, userAgent } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/server'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emiddleware\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003erequest: NextRequest\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e url = request.\u003cspan class=\"hljs-property\"\u003enextUrl\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { device } = \u003cspan class=\"hljs-title function_\"\u003euserAgent\u003c/span\u003e(request)\n\n  \u003cspan class=\"hljs-comment\"\u003e// device.type에는 'mobile', 'tablet', 'console', 'smarttv',\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// 'wearable', 'embedded' 또는 'desktop'(undefined일 때) 같은 값이 들어와요.\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e viewport = device.\u003cspan class=\"hljs-property\"\u003etype\u003c/span\u003e || \u003cspan class=\"hljs-string\"\u003e'desktop'\u003c/span\u003e\n\n  url.\u003cspan class=\"hljs-property\"\u003esearchParams\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eset\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'viewport'\u003c/span\u003e, viewport)\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNextResponse\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erewrite\u003c/span\u003e(url)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드에서는 미들웨어 안에서 요청 객체 \u003ccode\u003erequest\u003c/code\u003e를 이용해 \u003ccode\u003euserAgent(request)\u003c/code\u003e를 호출하고, 그 결과로부터 기기 타입(\u003ccode\u003edevice.type\u003c/code\u003e)을 얻고 있어요. 그리고 이 정보를 쿼리 파라미터로 추가해서 나중에 라우팅이나 렌더링 시 조건문으로 활용할 수 있도록 했답니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003eisBot 속성 활용하기\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003euserAgent\u003c/code\u003e 헬퍼는 단순히 기기 타입뿐 아니라, 방문자가 봇(bot)인지 아닌지도 알려주는 \u003ccode\u003eisBot\u003c/code\u003e 속성도 제공해요. 이걸 활용하면, 봇이 방문할 때 SEO 최적화나 캐싱 전략을 다르게 적용하는 등의 스마트한 대응이 가능하죠.\u003c/p\u003e\n\u003cp\u003e예시를 들어볼게요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eNextRequest\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eNextResponse\u003c/span\u003e, userAgent } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/server'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emiddleware\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003erequest: NextRequest\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { isBot } = \u003cspan class=\"hljs-title function_\"\u003euserAgent\u003c/span\u003e(request)\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (isBot) {\n    \u003cspan class=\"hljs-comment\"\u003e// 봇 방문자라면, 예를 들어, 캐싱을 더 강하게 적용하거나 \u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// 특정 페이지로 리다이렉트 할 수도 있어요.\u003c/span\u003e\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'봇 방문 감지됨!'\u003c/span\u003e)\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNextResponse\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e()\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이처럼 \u003ccode\u003eisBot\u003c/code\u003e은 크롤러나 검색 엔진 봇 감지에 유용하니, SEO를 신경 쓰는 프로젝트라면 꼭 활용해보세요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e참고: device.type 예상 값 정리\u003c/h3\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003edevice.type\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003emobile\u003c/td\u003e\u003ctd\u003e모바일 기기 (스마트폰 등)\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003etablet\u003c/td\u003e\u003ctd\u003e태블릿 기기\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003econsole\u003c/td\u003e\u003ctd\u003e게임 콘솔\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003esmarttv\u003c/td\u003e\u003ctd\u003e스마트 TV\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003ewearable\u003c/td\u003e\u003ctd\u003e스마트 워치 같은 웨어러블 디바이스\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eembedded\u003c/td\u003e\u003ctd\u003e내장형 디바이스\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eundefined\u003c/td\u003e\u003ctd\u003e데스크탑 브라우저 (특별한 타입 없을 때)\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003chr\u003e\n\u003cp\u003e마지막으로, \u003ccode\u003euserAgent\u003c/code\u003e 헬퍼는 사용자 단말 정보 기반 맞춤 UI나 미디어 쿼리 없이 기기 특성 판별이 필요한 상황에서 정말 강력한 도구니까, Next.js 프로젝트를 다룰 때 많이 활용해보면 좋습니다!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e요청이 알려진 봇(bot)인지 여부를 나타내는 불리언 값이 있어요.\u003c/p\u003e\n\u003ch2\u003ebrowser\u003c/h2\u003e\n\u003cp\u003e요청에 사용된 브라우저에 대한 정보를 담고 있는 객체입니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ename: 브라우저 이름을 나타내는 문자열이에요. 만약 식별이 불가능하면 undefined가 될 수 있습니다.\u003c/li\u003e\n\u003cli\u003eversion: 브라우저 버전을 나타내는 문자열이며, 역시 알 수 없는 경우엔 undefined가 됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e참고로, 클라이언트가 어떤 브라우저를 쓰는지 아는 건 다양한 이유에서 유용해요. 예를 들어, 특정 브라우저에서만 발생하는 버그를 파악하거나, 특정 버전에 맞게 기능을 조정하는 거죠.\u003c/p\u003e\n\u003cp\u003e또, 사용자 경험을 개선하기 위해서도 브라우저 정보는 중요해요. 만약 너무 오래된 버전을 쓰는 사용자가 많다면, 최신 기능 지원 여부를 알 수 있으니까요.\u003c/p\u003e\n\u003cp\u003eMarkdown 방식으로 표로 정리해봤어요!\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e속성명\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003cth\u003e타입\u003c/th\u003e\u003cth\u003e비고\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003eisBot\u003c/td\u003e\u003ctd\u003e요청이 알려진 봇인지 여부\u003c/td\u003e\u003ctd\u003eBoolean\u003c/td\u003e\u003ctd\u003etrue 또는 false\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003ename\u003c/td\u003e\u003ctd\u003e브라우저 이름\u003c/td\u003e\u003ctd\u003eString\u003c/td\u003e\u003ctd\u003e식별 불가 시 undefined\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eversion\u003c/td\u003e\u003ctd\u003e브라우저 버전\u003c/td\u003e\u003ctd\u003eString\u003c/td\u003e\u003ctd\u003e식별 불가 시 undefined\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e이렇게 정보를 잘 활용하면 API를 더 똑똑하게, 사용자에게 더 친절하게 만들 수 있답니다!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003edevice\u003c/h2\u003e\n\u003cp\u003e요청에 사용된 기기에 대한 정보를 담고 있는 객체입니다.\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e속성명\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003emodel\u003c/td\u003e\u003ctd\u003e기기의 모델명을 나타내는 문자열입니다. 값이 없을 경우 \u003ccode\u003eundefined\u003c/code\u003e일 수 있어요.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003etype\u003c/td\u003e\u003ctd\u003e기기 종류를 나타내는 문자열로, \u003ccode\u003econsole\u003c/code\u003e, \u003ccode\u003emobile\u003c/code\u003e, \u003ccode\u003etablet\u003c/code\u003e, \u003ccode\u003esmarttv\u003c/code\u003e, \u003ccode\u003ewearable\u003c/code\u003e, \u003ccode\u003eembedded\u003c/code\u003e 중 하나거나 \u003ccode\u003eundefined\u003c/code\u003e일 수 있어요.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003evendor\u003c/td\u003e\u003ctd\u003e기기 제조사명을 표시하는 문자열입니다. 없으면 \u003ccode\u003eundefined\u003c/code\u003e가 될 수 있어요.\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e기기 정보를 활용하면 어떤 환경에서 접속했는지 파악하기 쉽기 때문에 UI나 기능을 그에 맞게 최적화하기 좋아요. 예를 들어 스마트 TV와 모바일은 화면 크기 차이가 크니, 그에 맞게 인터페이스를 조절할 수 있겠죠?\u003c/p\u003e\n\u003ch2\u003eengine\u003c/h2\u003e\n\u003cp\u003e다음은 \u003ccode\u003eengine\u003c/code\u003e에 대한 설명이 필요하다면 언제든 알려주세요! 기본적으로 \u003ccode\u003eengine\u003c/code\u003e은 브라우저나 플랫폼 동작의 핵심적인 렌더링 엔진 정보를 나타내는 경우가 많아요. 웹 개발 시엔 이 정보를 통해 브라우저 호환성을 체크하는 데 유용하죠.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e브라우저 엔진(engine)에 대한 정보를 담고 있는 객체에 대해 조금 쉽게 설명해볼게요.\u003c/p\u003e\n\u003ch3\u003e브라우저 엔진 정보 객체\u003c/h3\u003e\n\u003cp\u003e이 객체는 우리가 사용하는 브라우저가 어떤 엔진을 쓰고 있는지 알려줘요. 엔진이라는 건 쉽게 말해, 웹페이지를 해석하고 화면에 보여주는 소프트웨어 핵심 부분이에요.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ename\u003c/strong\u003e: 이건 엔진의 이름을 문자열로 알려줘요. 예를 들어 Amaya, Blink, EdgeHTML, Gecko, WebKit 등 꽤 다양한 엔진들이 있고, 어떤 브라우저가 어느 엔진을 쓰는지 판단할 수 있죠.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eversion\u003c/strong\u003e: 그리고 그 엔진의 버전도 문자열로 알려주고, 가끔은 undefined일 수도 있어요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e브라우저 엔진을 알면, 웹 개발할 때 특정 엔진에서 잘못 표시되거나 동작하는 문제를 잡는데 도움이 돼요. 예를 들면, 구글 크롬은 Blink 엔진, 사파리는 WebKit 엔진을 쓰는 식이에요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003eOS (운영체제) 정보 객체\u003c/h3\u003e\n\u003cp\u003e이 객체는 컴퓨터나 모바일 기기에서 어떤 운영체제를 쓰고 있는지 알려줘요. OS 정보는 웹사이트를 최적화하거나, 특정 OS에서만 작동하는 기능을 설정할 때 쓰이죠.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e표로 정리하면 이렇게 될 거예요.\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e속성\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003ename\u003c/td\u003e\u003ctd\u003e브라우저 엔진 이름 (예: Amaya, Blink, EdgeHTML, Gecko, WebKit 등)\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eversion\u003c/td\u003e\u003ctd\u003e엔진 버전 문자열, 없으면 undefined\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eos\u003c/td\u003e\u003ctd\u003e운영체제 정보 객체\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e필요하면 OS 정보에 대해서도 더 자세히 다뤄볼게요. 실제로 개발할 때는 userAgent 라이브러리나 플랫폼 감지 API를 통해 이런 정보를 쉽게 얻을 수 있죠.\u003c/p\u003e\n\u003cp\u003e필요하면 내가 사용해본 라이브러리도 추천해줄게요. 혹시 궁금하면 말해주세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e자, 오늘은 운영체제(OS)와 CPU에 대한 정보를 담고 있는 데이터 구조에 대해 얘기해볼게요. 개발하면서 시스템 정보를 처리해야 할 때 종종 마주치는 내용인데, 이해하기 쉽게 정리해볼게요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e운영체제 정보 (OS)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ename\u003c/code\u003e: 운영체제의 이름을 문자열로 나타내요. 예를 들어, 'Windows', 'Linux', 'macOS' 같은 것들이죠. 만약 정보가 없으면 undefined일 수 있어요.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eversion\u003c/code\u003e: 운영체제의 버전을 문자열로 나타내요. 예를 들어 '10.0.19042' 같은 숫자나 'Big Sur'처럼 이름 형태가 될 수도 있죠. 역시 없으면 undefined일 수도 있어요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이렇게 이름과 버전을 알면 해당 운영체제에 맞는 분기 처리를 하거나 업데이트 정보를 관리하는 데 유용하죠.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003eCPU 정보\u003c/h3\u003e\n\u003cp\u003eCPU 정보는 보통 CPU 아키텍처 \u003cem\u003earchitecture\u003c/em\u003e에 초점을 맞춥니다.\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e필드\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003cth\u003e예시\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003earchitecture\u003c/td\u003e\u003ctd\u003eCPU 아키텍처를 나타내는 문자열입니다.\u003c/td\u003e\u003ctd\u003e68k, amd64, arm, arm64, armhf, avr, ia32, ia64, mips 등\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e여기서 가능한 아키텍처 값들은 꽤 다양합니다. 흔히 개발할 때 많이 듣는 건 \u003ccode\u003eamd64\u003c/code\u003e (x86-64), \u003ccode\u003earm64\u003c/code\u003e (애플 M1/M2, 최신 모바일 기기), \u003ccode\u003eia32\u003c/code\u003e (x86 32비트), 그리고 \u003ccode\u003earm\u003c/code\u003e (주로 모바일용) 정도가 있죠.\u003c/p\u003e\n\u003chr\u003e\n\u003ch4\u003e추가 팁!\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eCPU 아키텍처와 OS 정보를 함께 알면, 예를 들어 어느 환경에서 특정 바이너리가 돌아가는지 정확히 파악할 수 있어요.\u003c/li\u003e\n\u003cli\u003e웹 개발할 때도 클라이언트나 서버의 환경을 파악해서 최적화 또는 디버깅하는 데 도움이 됩니다.\u003c/li\u003e\n\u003cli\u003eNode.js 환경에서는 \u003ccode\u003eprocess.arch\u003c/code\u003e (CPU 아키텍처)랑 \u003ccode\u003eprocess.platform\u003c/code\u003e (운영체제) 같은 내장 변수를 활용해 비슷한 정보를 얻을 수 있어요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e필요할 때 이 정보를 잘 활용해서 더 똑똑한 환경별 로직을 작성해 보세요. 그럼 오늘 내용은 여기까지!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2025-04-22-userAgent"},"buildId":"M7pU9hOcx8u_ZIFMf95sd","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>