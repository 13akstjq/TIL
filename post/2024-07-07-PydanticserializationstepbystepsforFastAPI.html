<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>FastAPI에서 Pydantic 직렬화 단계별 가이드 | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2024-07-07-PydanticserializationstepbystepsforFastAPI" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="FastAPI에서 Pydantic 직렬화 단계별 가이드 | TIL" data-gatsby-head="true"/><meta property="og:title" content="FastAPI에서 Pydantic 직렬화 단계별 가이드 | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-07-07-PydanticserializationstepbystepsforFastAPI_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2024-07-07-PydanticserializationstepbystepsforFastAPI" data-gatsby-head="true"/><meta name="twitter:title" content="FastAPI에서 Pydantic 직렬화 단계별 가이드 | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-07-07-PydanticserializationstepbystepsforFastAPI_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2024-07-07 12:56" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/TIL/_next/static/chunks/463-925361deb4cec4b1.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/post/%5Bslug%5D-9d7ebbd29b9e08ce.js" defer=""></script><script src="/TIL/_next/static/FuXRqV9h16krA5Mvtd6Dn/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/FuXRqV9h16krA5Mvtd6Dn/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">FastAPI에서 Pydantic 직렬화 단계별 가이드</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="FastAPI에서 Pydantic 직렬화 단계별 가이드" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jul 7, 2024</span><span class="posts_reading_time__f7YPP">10<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-07-07-PydanticserializationstepbystepsforFastAPI&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/TIL/assets/img/2024-07-07-PydanticserializationstepbystepsforFastAPI_0.png" alt="이미지"></p>
<p>FastAPI 프레임워크를 사용하여 API를 구축하려면 pydantic에 대해 알아야 합니다. 'post' 요청은 본문 매개변수만 허용하기 때문입니다. 본문 매개변수를 읽으려면 pydantic 모델을 구현해야 합니다.</p>
<p>그러나 문제는 이 pydantic 모델의 데이터를 사용할 때, 원본 pydantic보다 쉬운 데이터 유형(파이썬 사전 또는 JSON일 수 있음)으로 변환해야 한다는 것입니다. 이 데이터 유형으로 작업하는 것이 원본 pydantic보다 쉽기 때문입니다.</p>
<p>이 프로세스를 직렬화라고 합니다. 이름에서 알 수 있듯, 이 문제에 대해 심각하게 생각할 필요가 없습니다. 이 주제에 대해 알아야 할 모든 것을 단순화할 것입니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>FastAPI에서 데이터를 반환할 때 pydantic 모델과 정확히 동일한 데이터를 반환하고 싶다면 직렬화 방법을 사용할 필요가 없습니다. FastAPI가 이를 자동으로 처리하기 때문입니다. 그러나 pydantic 데이터 출력을 사용자 정의하려면 (적어도 새 필드를 추가하거나 기존 필드를 제거하는) pydantic에서 어떤 종류의 직렬화 방법을 사용하는 것이 좋습니다. model_dump(), dict() 및 model_dump_json()과 같은 방법이 있습니다.</p>
<p>먼저 어떻게 무조건적으로 pydantic 모델과 동일한 데이터를 반환하는지 알아보겠습니다.</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI
<span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BaseModel

app = FastAPI()
<span class="hljs-keyword">class</span> <span class="hljs-title class_">University</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):
    name : <span class="hljs-built_in">str</span>
    place : <span class="hljs-built_in">str</span>
<span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">'/create'</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">addUniversity</span>(<span class="hljs-params">university : University</span>):
    <span class="hljs-comment"># 업무 로직을 수행한 후</span>
    <span class="hljs-comment"># pydantic 모델 그대로 반환합니다</span>
    <span class="hljs-keyword">return</span> university
</code></pre>
<p>그리고 위의 pydantic 모델을 수정하여 (다른 필드를 추가하는 간단한 예) 직렬화 방법을 사용하지 않고 반환하는 방법을 살펴보겠습니다. 이것은 어려운 주제가 아닙니다. 그저 새로운 사전을 만들고 출력으로 반환하는 것뿐입니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI
<span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BaseModel

app = FastAPI()
<span class="hljs-keyword">class</span> <span class="hljs-title class_">University</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):
    name : <span class="hljs-built_in">str</span>
    place : <span class="hljs-built_in">str</span>
<span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">'/create'</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">addUniversity</span>(<span class="hljs-params">university : University</span>):
    newUniversity = {
        <span class="hljs-string">'name'</span> : university.name,
        <span class="hljs-string">'place'</span> : university.place,
        <span class="hljs-string">'contactNum'</span> : +<span class="hljs-number">1234678</span>
    }
    <span class="hljs-keyword">return</span> newUniversity
</code></pre>
<p>만약 직렬화(serialization)에 대해 익숙하지 않다면, 위와 같은 방법으로 해야 한다고 생각할 수 있습니다. 하지만 이제 직렬화 메서드를 적용하는 방법을 살펴본 후, 우리의 작업을 더 쉽게 할 수 있는 방법을 알아보겠습니다.</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI
<span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BaseModel

app = FastAPI()
<span class="hljs-keyword">class</span> <span class="hljs-title class_">University</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):
    name : <span class="hljs-built_in">str</span>
    place : <span class="hljs-built_in">str</span>
<span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">'/create'</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">addUniversity</span>(<span class="hljs-params">university : University</span>):
    <span class="hljs-comment"># 새로운 대학 변수를 정의하고 직렬화된 데이터를 할당합니다.</span>
    newUniversity = university.model_dump()
    <span class="hljs-comment"># 새 데이터 추가</span>
    newUniversity[<span class="hljs-string">'contactNum'</span>] = <span class="hljs-number">12345678</span>
    <span class="hljs-comment"># 값을 반환합니다.</span>
    <span class="hljs-keyword">return</span> newUniversity
</code></pre>
<p>따라서 직렬화를 사용할 수 있는 유용한 방법 중 하나를 보여드렸습니다. 이 주제에 대해 더 자세히 알아보고 싶다면, 직렬화에 대해 알아야 할 모든 것을 간단하게 설명해드리겠습니다.
pydantic에는 세 가지 주요 기본 직렬화 메서드가 있습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>model_dump( )</h2>
<p>이 함수는 Pydantic 모델을 사전으로 변환하는 데 사용됩니다. 사전으로 변환한 후에는 아래와 같이 출력을 사용자 지정하는 여러 옵션이 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> <span class="hljs-title class_">FastAPI</span>
<span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> <span class="hljs-title class_">BaseModel</span>, <span class="hljs-title class_">Field</span>

app = <span class="hljs-title class_">FastAPI</span>()
<span class="hljs-keyword">class</span> <span class="hljs-title class_">University</span>(<span class="hljs-title class_">BaseModel</span>):
    name : str
    place : str = <span class="hljs-title class_">Field</span>(alias=<span class="hljs-string">'location place'</span>)
    rank : int
    specialize : int = <span class="hljs-title class_">Field</span>(<span class="hljs-keyword">default</span>=<span class="hljs-number">1</span>)
@app.<span class="hljs-title function_">post</span>(<span class="hljs-string">'/create'</span>)
<span class="hljs-keyword">async</span> def <span class="hljs-title function_">addUniversity</span>(university : <span class="hljs-title class_">University</span>):
    newUniversity = university.<span class="hljs-title function_">model_dump</span>(exclude=<span class="hljs-string">'rank'</span>, include=[<span class="hljs-string">'name'</span>, <span class="hljs-string">'place'</span>, <span class="hljs-string">'specialize'</span>], mode=<span class="hljs-string">'python'</span>, by_alias=<span class="hljs-title class_">True</span>, exclude_defaults=<span class="hljs-title class_">True</span>)
    # 비즈니스 로직 구현
    # 데이터베이스에 저장
    # 결과 반환
    <span class="hljs-keyword">return</span> newUniversity
</code></pre>
<p>코드 설명
addUniversity()가 데이터베이스에 새로운 대학을 추가하는 엔드포인트로 상상해 봅시다. 사용자가 프론트엔드에서 데이터를 제출하면 이 API 엔드포인트는 데이터를 받아서 Pydantic 모델에 전달합니다. addUniversity() 함수 내에서 University 데이터 모델을 model_bump() 메서드를 사용하여 직렬화하는 새로운 변수 newUniversity를 선언합니다. 여기에서 우리는 Pydantic 모델의 출력을 원하는 대로 사용자 정의할 수 있습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>"exclude": 이 옵션을 사용하여 Pydantic 모델에서 가져온 필드를 제거할 수 있습니다.</p>
<p>"include": 여기서 함수 내에서 계산에 필요한 필드를 지정할 수 있습니다.</p>
<p>"by_alias": Pydantic 모델의 각 필드에 대한 대체 이름을 이미 정의했다면, by_alias는 사용 여부에 대한 옵션을 제공합니다.</p>
<p>"exclude_default": Pydantic 모델의 특정 필드에 대한 기본값을 정의했기 때문에, 기본값과 같은 값을 가진 필드를 제외하려면 이 옵션을 사용할 수 있습니다. 이 옵션은 그 목적을 위해 사용됩니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>만약 다른 옵션들을 더 탐색하고 싶다면, <code>API documentation</code> Pydantic 문서 <code>Base model</code> <code>model_dump</code> 를 확인해보세요.</p>
<h2>dict()</h2>
<p>여기서 제공하는 것 또한 <code>model_dump()</code> 메서드와 비슷합니다. 왜냐하면 이 역시 파이썬 딕셔너리를 반환하기 때문입니다. 하지만 다른 점은 customize our pydantic model을 위해 사용할 수 있는 몇 가지 옵션이 있다는 것입니다.</p>
<h2>model_dump_json()</h2>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>만약 JSON 출력 또는 직렬화 출력을 JSON 형식으로 받고 싶다면 <code>model_dump_json()</code>을 사용하세요. <code>model_dump</code> 메서드에서 사용 가능한 모든 옵션들을 여기에도 사용할 수 있습니다.</p>
<h1>다른 직렬화 옵션들은 무엇이 있을까요</h1>
<h2>@field_serializer</h2>
<p>예를 들어 Pydantic 모델에서 특정 필드를 커스텀하고자 할 때, 함수나 엔드포인트로 Pydantic 모델 데이터를 가져오기 전에 그 필드를 수정하고 싶을 수 있습니다. 다시 말해 Pydantic 모델을 호출한 후 일부 필드를 수정해 해당 데이터를 함수나 엔드포인트로 반환하고자 하는 경우가 있을 수 있습니다. 이런 경우 <code>@field_serializer</code>를 사용해야합니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI
<span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BaseModel, field_serializer

app = FastAPI()
<span class="hljs-keyword">class</span> <span class="hljs-title class_">University</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):
    name: <span class="hljs-built_in">str</span>
    place: <span class="hljs-built_in">str</span>
    rank: <span class="hljs-built_in">str</span>
    specialize: <span class="hljs-built_in">int</span>

<span class="hljs-meta">    @field_serializer(<span class="hljs-params"><span class="hljs-string">'rank'</span>, when_used=<span class="hljs-string">'always'</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rank_serialize</span>(<span class="hljs-params">rank: <span class="hljs-built_in">str</span></span>):
        rank = <span class="hljs-string">'world rank - '</span> + rank
        <span class="hljs-keyword">return</span> rank

<span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">'/create'</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">addUniversity</span>(<span class="hljs-params">university: University</span>):
    <span class="hljs-keyword">return</span> university
</code></pre>
<p><strong>코드 설명</strong></p>
<p>University pydantic 모델은 name, place, specialize와 함께 rank와 같은 여러 필드를 허용합니다. 이 모델에 데이터를 전달할 때 rank 필드의 값은 문자열입니다. 그러나 이 코드 외부에서 데이터를 전달할 때 rank의 값으로 숫자만 받습니다. "01", "02"와 같은 링크를 사용하지만 이 pydantic 모델 외부에서 데이터를 전달할 때 rank의 값을 "world rank - 01"과 같이 바꾸고 싶습니다. 간단히 말해 출력은 다음과 같아야 합니다.</p>
<pre><code class="hljs language-python">{
  <span class="hljs-string">"name"</span>: <span class="hljs-string">"string"</span>,
  <span class="hljs-string">"place"</span>: <span class="hljs-string">"string"</span>,
  <span class="hljs-string">"rank"</span>: <span class="hljs-string">"world rank - 01"</span>,
  <span class="hljs-string">"specialize"</span>: <span class="hljs-number">0</span>
}
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>js
{
"name": "string",
"place": "string",
"rank": "01",
"specialize": 0
}</p>
<p>단일 필드만 직렬화하려면 Pydantic 모델 내에서 새로운 함수를 선언해야 합니다. 이 함수에는 '@field_serializer' 데코레이터를 사용해야 합니다. 하지만 먼저 해당 데코레이터를 Pydantic 모델에서 import해야 합니다. 여러 매개변수를 받을 수 있지만, 여기서는 두 가지만 언급합니다. 첫 번째는 어떤 필드를 직렬화할지를 나타내는 것입니다. 여기서는 'rank' 필드를 사용했습니다. 두 번째는 'when_use'입니다. 이곳에서 언제 이 필드 직렬화기를 사용할지 알려주어야 합니다. 이 예시에서는 'always'를 사용합니다.</p>
<p>그런 다음 해당 함수 내에서 원하는 작업을 수행하고, 마지막으로 반환하면 됩니다. 그게 전부입니다. 간단하지요?</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>@model_serializer</h2>
<p>이 메서드에서는 엔드포인트나 함수로 반환하기 전에 원하는대로 pydantic 모델을 직렬화할 수 있습니다. 이는 field_serializer와 매우 유사합니다. 더 잘 이해하기 위해 예제를 살펴봅시다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> <span class="hljs-title class_">FastAPI</span>
<span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> <span class="hljs-title class_">BaseModel</span>, model_serializer

app = <span class="hljs-title class_">FastAPI</span>()
<span class="hljs-keyword">class</span> <span class="hljs-title class_">University</span>(<span class="hljs-title class_">BaseModel</span>):
    name : str
    place : str
    @<span class="hljs-title function_">model_serializer</span>()
    def <span class="hljs-title function_">rank_serialize</span>(self):
        <span class="hljs-keyword">return</span> {
        <span class="hljs-string">'name'</span> : <span class="hljs-string">'the '</span> + self.<span class="hljs-property">name</span>,
        <span class="hljs-string">'place'</span> : self.<span class="hljs-property">place</span> + <span class="hljs-string">', sri lanka'</span>
        }
@app.<span class="hljs-title function_">post</span>(<span class="hljs-string">'/create'</span>)
<span class="hljs-keyword">async</span> def <span class="hljs-title function_">addUniversity</span>(university : <span class="hljs-title class_">University</span>):
    <span class="hljs-keyword">return</span> university
</code></pre>
<p>이렇게 출력을 얻고 싶습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">{
  <span class="hljs-string">"name"</span>: <span class="hljs-string">"콜롬보 대학"</span>,
  <span class="hljs-string">"place"</span>: <span class="hljs-string">"스리랑카 콜롬보"</span>
}
</code></pre>
<p>대신에 모델 시리얼라이저를 사용해보세요.</p>
<pre><code class="hljs language-js">{
  <span class="hljs-string">"name"</span>: <span class="hljs-string">"콜롬보 대학"</span>,
  <span class="hljs-string">"place"</span>: <span class="hljs-string">"콜롬보"</span>
}
</code></pre>
<p>첫 번째로 해야 할 일은 pydantic 모델에서 model_serializer를 import하는 것입니다. 그런 다음 모델 내부에서 '@model_serializer' 데코레이터가 달린 함수를 선언하고 원하는 방식으로 출력을 구성하십시오. 마지막으로 반환하십시오. 더 자세한 내용은 pydantic 문서 <code>API Documentation</code>의 <code>Functional serializer</code> 섹션을 참조하십시오.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>그냥 간단하게 Pydantic에서 serializer를 사용하는 방법이야. 더 자세한 내용을 원한다면 문서를 확인하고 이해를 돕기 위해 뭔가를 구현해보세요...</p>
<p>코딩 즐겁게 하시고 또 다른 FastAPI 주제에서 만나요...</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"FastAPI에서 Pydantic 직렬화 단계별 가이드","description":"","date":"2024-07-07 12:56","slug":"2024-07-07-PydanticserializationstepbystepsforFastAPI","content":"\n![이미지](/TIL/assets/img/2024-07-07-PydanticserializationstepbystepsforFastAPI_0.png)\n\nFastAPI 프레임워크를 사용하여 API를 구축하려면 pydantic에 대해 알아야 합니다. 'post' 요청은 본문 매개변수만 허용하기 때문입니다. 본문 매개변수를 읽으려면 pydantic 모델을 구현해야 합니다.\n\n그러나 문제는 이 pydantic 모델의 데이터를 사용할 때, 원본 pydantic보다 쉬운 데이터 유형(파이썬 사전 또는 JSON일 수 있음)으로 변환해야 한다는 것입니다. 이 데이터 유형으로 작업하는 것이 원본 pydantic보다 쉽기 때문입니다.\n\n이 프로세스를 직렬화라고 합니다. 이름에서 알 수 있듯, 이 문제에 대해 심각하게 생각할 필요가 없습니다. 이 주제에 대해 알아야 할 모든 것을 단순화할 것입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nFastAPI에서 데이터를 반환할 때 pydantic 모델과 정확히 동일한 데이터를 반환하고 싶다면 직렬화 방법을 사용할 필요가 없습니다. FastAPI가 이를 자동으로 처리하기 때문입니다. 그러나 pydantic 데이터 출력을 사용자 정의하려면 (적어도 새 필드를 추가하거나 기존 필드를 제거하는) pydantic에서 어떤 종류의 직렬화 방법을 사용하는 것이 좋습니다. model_dump(), dict() 및 model_dump_json()과 같은 방법이 있습니다.\n\n먼저 어떻게 무조건적으로 pydantic 모델과 동일한 데이터를 반환하는지 알아보겠습니다.\n\n```python\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\nclass University(BaseModel):\n    name : str\n    place : str\n@app.post('/create')\nasync def addUniversity(university : University):\n    # 업무 로직을 수행한 후\n    # pydantic 모델 그대로 반환합니다\n    return university\n```\n\n그리고 위의 pydantic 모델을 수정하여 (다른 필드를 추가하는 간단한 예) 직렬화 방법을 사용하지 않고 반환하는 방법을 살펴보겠습니다. 이것은 어려운 주제가 아닙니다. 그저 새로운 사전을 만들고 출력으로 반환하는 것뿐입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\nclass University(BaseModel):\n    name : str\n    place : str\n@app.post('/create')\nasync def addUniversity(university : University):\n    newUniversity = {\n        'name' : university.name,\n        'place' : university.place,\n        'contactNum' : +1234678\n    }\n    return newUniversity\n```\n\n만약 직렬화(serialization)에 대해 익숙하지 않다면, 위와 같은 방법으로 해야 한다고 생각할 수 있습니다. 하지만 이제 직렬화 메서드를 적용하는 방법을 살펴본 후, 우리의 작업을 더 쉽게 할 수 있는 방법을 알아보겠습니다.\n\n```python\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\nclass University(BaseModel):\n    name : str\n    place : str\n@app.post('/create')\nasync def addUniversity(university : University):\n    # 새로운 대학 변수를 정의하고 직렬화된 데이터를 할당합니다.\n    newUniversity = university.model_dump()\n    # 새 데이터 추가\n    newUniversity['contactNum'] = 12345678\n    # 값을 반환합니다.\n    return newUniversity\n```\n\n따라서 직렬화를 사용할 수 있는 유용한 방법 중 하나를 보여드렸습니다. 이 주제에 대해 더 자세히 알아보고 싶다면, 직렬화에 대해 알아야 할 모든 것을 간단하게 설명해드리겠습니다.\npydantic에는 세 가지 주요 기본 직렬화 메서드가 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## model_dump( )\n\n이 함수는 Pydantic 모델을 사전으로 변환하는 데 사용됩니다. 사전으로 변환한 후에는 아래와 같이 출력을 사용자 지정하는 여러 옵션이 있습니다.\n\n```js\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel, Field\n\napp = FastAPI()\nclass University(BaseModel):\n    name : str\n    place : str = Field(alias='location place')\n    rank : int\n    specialize : int = Field(default=1)\n@app.post('/create')\nasync def addUniversity(university : University):\n    newUniversity = university.model_dump(exclude='rank', include=['name', 'place', 'specialize'], mode='python', by_alias=True, exclude_defaults=True)\n    # 비즈니스 로직 구현\n    # 데이터베이스에 저장\n    # 결과 반환\n    return newUniversity\n```\n\n코드 설명\naddUniversity()가 데이터베이스에 새로운 대학을 추가하는 엔드포인트로 상상해 봅시다. 사용자가 프론트엔드에서 데이터를 제출하면 이 API 엔드포인트는 데이터를 받아서 Pydantic 모델에 전달합니다. addUniversity() 함수 내에서 University 데이터 모델을 model_bump() 메서드를 사용하여 직렬화하는 새로운 변수 newUniversity를 선언합니다. 여기에서 우리는 Pydantic 모델의 출력을 원하는 대로 사용자 정의할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\"exclude\": 이 옵션을 사용하여 Pydantic 모델에서 가져온 필드를 제거할 수 있습니다.\n\n\"include\": 여기서 함수 내에서 계산에 필요한 필드를 지정할 수 있습니다.\n\n\"by_alias\": Pydantic 모델의 각 필드에 대한 대체 이름을 이미 정의했다면, by_alias는 사용 여부에 대한 옵션을 제공합니다.\n\n\"exclude_default\": Pydantic 모델의 특정 필드에 대한 기본값을 정의했기 때문에, 기본값과 같은 값을 가진 필드를 제외하려면 이 옵션을 사용할 수 있습니다. 이 옵션은 그 목적을 위해 사용됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 다른 옵션들을 더 탐색하고 싶다면, `API documentation` Pydantic 문서 `Base model` `model_dump` 를 확인해보세요.\n\n## dict()\n\n여기서 제공하는 것 또한 `model_dump()` 메서드와 비슷합니다. 왜냐하면 이 역시 파이썬 딕셔너리를 반환하기 때문입니다. 하지만 다른 점은 customize our pydantic model을 위해 사용할 수 있는 몇 가지 옵션이 있다는 것입니다.\n\n## model_dump_json()\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 JSON 출력 또는 직렬화 출력을 JSON 형식으로 받고 싶다면 `model_dump_json()`을 사용하세요. `model_dump` 메서드에서 사용 가능한 모든 옵션들을 여기에도 사용할 수 있습니다.\n\n# 다른 직렬화 옵션들은 무엇이 있을까요\n\n## @field_serializer\n\n예를 들어 Pydantic 모델에서 특정 필드를 커스텀하고자 할 때, 함수나 엔드포인트로 Pydantic 모델 데이터를 가져오기 전에 그 필드를 수정하고 싶을 수 있습니다. 다시 말해 Pydantic 모델을 호출한 후 일부 필드를 수정해 해당 데이터를 함수나 엔드포인트로 반환하고자 하는 경우가 있을 수 있습니다. 이런 경우 `@field_serializer`를 사용해야합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel, field_serializer\n\napp = FastAPI()\nclass University(BaseModel):\n    name: str\n    place: str\n    rank: str\n    specialize: int\n\n    @field_serializer('rank', when_used='always')\n    def rank_serialize(rank: str):\n        rank = 'world rank - ' + rank\n        return rank\n\n@app.post('/create')\nasync def addUniversity(university: University):\n    return university\n```\n\n**코드 설명**\n\nUniversity pydantic 모델은 name, place, specialize와 함께 rank와 같은 여러 필드를 허용합니다. 이 모델에 데이터를 전달할 때 rank 필드의 값은 문자열입니다. 그러나 이 코드 외부에서 데이터를 전달할 때 rank의 값으로 숫자만 받습니다. \"01\", \"02\"와 같은 링크를 사용하지만 이 pydantic 모델 외부에서 데이터를 전달할 때 rank의 값을 \"world rank - 01\"과 같이 바꾸고 싶습니다. 간단히 말해 출력은 다음과 같아야 합니다.\n\n```python\n{\n  \"name\": \"string\",\n  \"place\": \"string\",\n  \"rank\": \"world rank - 01\",\n  \"specialize\": 0\n}\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\njs\n{\n\"name\": \"string\",\n\"place\": \"string\",\n\"rank\": \"01\",\n\"specialize\": 0\n}\n\n단일 필드만 직렬화하려면 Pydantic 모델 내에서 새로운 함수를 선언해야 합니다. 이 함수에는 '@field_serializer' 데코레이터를 사용해야 합니다. 하지만 먼저 해당 데코레이터를 Pydantic 모델에서 import해야 합니다. 여러 매개변수를 받을 수 있지만, 여기서는 두 가지만 언급합니다. 첫 번째는 어떤 필드를 직렬화할지를 나타내는 것입니다. 여기서는 'rank' 필드를 사용했습니다. 두 번째는 'when_use'입니다. 이곳에서 언제 이 필드 직렬화기를 사용할지 알려주어야 합니다. 이 예시에서는 'always'를 사용합니다.\n\n그런 다음 해당 함수 내에서 원하는 작업을 수행하고, 마지막으로 반환하면 됩니다. 그게 전부입니다. 간단하지요?\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## @model_serializer\n\n이 메서드에서는 엔드포인트나 함수로 반환하기 전에 원하는대로 pydantic 모델을 직렬화할 수 있습니다. 이는 field_serializer와 매우 유사합니다. 더 잘 이해하기 위해 예제를 살펴봅시다.\n\n```js\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel, model_serializer\n\napp = FastAPI()\nclass University(BaseModel):\n    name : str\n    place : str\n    @model_serializer()\n    def rank_serialize(self):\n        return {\n        'name' : 'the ' + self.name,\n        'place' : self.place + ', sri lanka'\n        }\n@app.post('/create')\nasync def addUniversity(university : University):\n    return university\n```\n\n이렇게 출력을 얻고 싶습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n{\n  \"name\": \"콜롬보 대학\",\n  \"place\": \"스리랑카 콜롬보\"\n}\n```\n\n대신에 모델 시리얼라이저를 사용해보세요.\n\n```js\n{\n  \"name\": \"콜롬보 대학\",\n  \"place\": \"콜롬보\"\n}\n```\n\n첫 번째로 해야 할 일은 pydantic 모델에서 model_serializer를 import하는 것입니다. 그런 다음 모델 내부에서 '@model_serializer' 데코레이터가 달린 함수를 선언하고 원하는 방식으로 출력을 구성하십시오. 마지막으로 반환하십시오. 더 자세한 내용은 pydantic 문서 `API Documentation`의 `Functional serializer` 섹션을 참조하십시오.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그냥 간단하게 Pydantic에서 serializer를 사용하는 방법이야. 더 자세한 내용을 원한다면 문서를 확인하고 이해를 돕기 위해 뭔가를 구현해보세요...\n\n코딩 즐겁게 하시고 또 다른 FastAPI 주제에서 만나요...\n","ogImage":{"url":"/assets/img/2024-07-07-PydanticserializationstepbystepsforFastAPI_0.png"},"coverImage":"/TIL/assets/img/2024-07-07-PydanticserializationstepbystepsforFastAPI_0.png","tag":["Tech"],"readingTime":10},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-07-PydanticserializationstepbystepsforFastAPI_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003eFastAPI 프레임워크를 사용하여 API를 구축하려면 pydantic에 대해 알아야 합니다. 'post' 요청은 본문 매개변수만 허용하기 때문입니다. 본문 매개변수를 읽으려면 pydantic 모델을 구현해야 합니다.\u003c/p\u003e\n\u003cp\u003e그러나 문제는 이 pydantic 모델의 데이터를 사용할 때, 원본 pydantic보다 쉬운 데이터 유형(파이썬 사전 또는 JSON일 수 있음)으로 변환해야 한다는 것입니다. 이 데이터 유형으로 작업하는 것이 원본 pydantic보다 쉽기 때문입니다.\u003c/p\u003e\n\u003cp\u003e이 프로세스를 직렬화라고 합니다. 이름에서 알 수 있듯, 이 문제에 대해 심각하게 생각할 필요가 없습니다. 이 주제에 대해 알아야 할 모든 것을 단순화할 것입니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eFastAPI에서 데이터를 반환할 때 pydantic 모델과 정확히 동일한 데이터를 반환하고 싶다면 직렬화 방법을 사용할 필요가 없습니다. FastAPI가 이를 자동으로 처리하기 때문입니다. 그러나 pydantic 데이터 출력을 사용자 정의하려면 (적어도 새 필드를 추가하거나 기존 필드를 제거하는) pydantic에서 어떤 종류의 직렬화 방법을 사용하는 것이 좋습니다. model_dump(), dict() 및 model_dump_json()과 같은 방법이 있습니다.\u003c/p\u003e\n\u003cp\u003e먼저 어떻게 무조건적으로 pydantic 모델과 동일한 데이터를 반환하는지 알아보겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e fastapi \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e FastAPI\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e pydantic \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e BaseModel\n\napp = FastAPI()\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUniversity\u003c/span\u003e(\u003cspan class=\"hljs-title class_ inherited__\"\u003eBaseModel\u003c/span\u003e):\n    name : \u003cspan class=\"hljs-built_in\"\u003estr\u003c/span\u003e\n    place : \u003cspan class=\"hljs-built_in\"\u003estr\u003c/span\u003e\n\u003cspan class=\"hljs-meta\"\u003e@app.post(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-string\"\u003e'/create'\u003c/span\u003e\u003c/span\u003e)\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eaddUniversity\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003euniversity : University\u003c/span\u003e):\n    \u003cspan class=\"hljs-comment\"\u003e# 업무 로직을 수행한 후\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e# pydantic 모델 그대로 반환합니다\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e university\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 위의 pydantic 모델을 수정하여 (다른 필드를 추가하는 간단한 예) 직렬화 방법을 사용하지 않고 반환하는 방법을 살펴보겠습니다. 이것은 어려운 주제가 아닙니다. 그저 새로운 사전을 만들고 출력으로 반환하는 것뿐입니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e fastapi \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e FastAPI\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e pydantic \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e BaseModel\n\napp = FastAPI()\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUniversity\u003c/span\u003e(\u003cspan class=\"hljs-title class_ inherited__\"\u003eBaseModel\u003c/span\u003e):\n    name : \u003cspan class=\"hljs-built_in\"\u003estr\u003c/span\u003e\n    place : \u003cspan class=\"hljs-built_in\"\u003estr\u003c/span\u003e\n\u003cspan class=\"hljs-meta\"\u003e@app.post(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-string\"\u003e'/create'\u003c/span\u003e\u003c/span\u003e)\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eaddUniversity\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003euniversity : University\u003c/span\u003e):\n    newUniversity = {\n        \u003cspan class=\"hljs-string\"\u003e'name'\u003c/span\u003e : university.name,\n        \u003cspan class=\"hljs-string\"\u003e'place'\u003c/span\u003e : university.place,\n        \u003cspan class=\"hljs-string\"\u003e'contactNum'\u003c/span\u003e : +\u003cspan class=\"hljs-number\"\u003e1234678\u003c/span\u003e\n    }\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e newUniversity\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e만약 직렬화(serialization)에 대해 익숙하지 않다면, 위와 같은 방법으로 해야 한다고 생각할 수 있습니다. 하지만 이제 직렬화 메서드를 적용하는 방법을 살펴본 후, 우리의 작업을 더 쉽게 할 수 있는 방법을 알아보겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e fastapi \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e FastAPI\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e pydantic \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e BaseModel\n\napp = FastAPI()\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUniversity\u003c/span\u003e(\u003cspan class=\"hljs-title class_ inherited__\"\u003eBaseModel\u003c/span\u003e):\n    name : \u003cspan class=\"hljs-built_in\"\u003estr\u003c/span\u003e\n    place : \u003cspan class=\"hljs-built_in\"\u003estr\u003c/span\u003e\n\u003cspan class=\"hljs-meta\"\u003e@app.post(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-string\"\u003e'/create'\u003c/span\u003e\u003c/span\u003e)\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eaddUniversity\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003euniversity : University\u003c/span\u003e):\n    \u003cspan class=\"hljs-comment\"\u003e# 새로운 대학 변수를 정의하고 직렬화된 데이터를 할당합니다.\u003c/span\u003e\n    newUniversity = university.model_dump()\n    \u003cspan class=\"hljs-comment\"\u003e# 새 데이터 추가\u003c/span\u003e\n    newUniversity[\u003cspan class=\"hljs-string\"\u003e'contactNum'\u003c/span\u003e] = \u003cspan class=\"hljs-number\"\u003e12345678\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e# 값을 반환합니다.\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e newUniversity\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e따라서 직렬화를 사용할 수 있는 유용한 방법 중 하나를 보여드렸습니다. 이 주제에 대해 더 자세히 알아보고 싶다면, 직렬화에 대해 알아야 할 모든 것을 간단하게 설명해드리겠습니다.\npydantic에는 세 가지 주요 기본 직렬화 메서드가 있습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003emodel_dump( )\u003c/h2\u003e\n\u003cp\u003e이 함수는 Pydantic 모델을 사전으로 변환하는 데 사용됩니다. 사전으로 변환한 후에는 아래와 같이 출력을 사용자 지정하는 여러 옵션이 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e fastapi \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFastAPI\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e pydantic \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBaseModel\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eField\u003c/span\u003e\n\napp = \u003cspan class=\"hljs-title class_\"\u003eFastAPI\u003c/span\u003e()\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUniversity\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eBaseModel\u003c/span\u003e):\n    name : str\n    place : str = \u003cspan class=\"hljs-title class_\"\u003eField\u003c/span\u003e(alias=\u003cspan class=\"hljs-string\"\u003e'location place'\u003c/span\u003e)\n    rank : int\n    specialize : int = \u003cspan class=\"hljs-title class_\"\u003eField\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e=\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\n@app.\u003cspan class=\"hljs-title function_\"\u003epost\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/create'\u003c/span\u003e)\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e def \u003cspan class=\"hljs-title function_\"\u003eaddUniversity\u003c/span\u003e(university : \u003cspan class=\"hljs-title class_\"\u003eUniversity\u003c/span\u003e):\n    newUniversity = university.\u003cspan class=\"hljs-title function_\"\u003emodel_dump\u003c/span\u003e(exclude=\u003cspan class=\"hljs-string\"\u003e'rank'\u003c/span\u003e, include=[\u003cspan class=\"hljs-string\"\u003e'name'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'place'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'specialize'\u003c/span\u003e], mode=\u003cspan class=\"hljs-string\"\u003e'python'\u003c/span\u003e, by_alias=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e, exclude_defaults=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e)\n    # 비즈니스 로직 구현\n    # 데이터베이스에 저장\n    # 결과 반환\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e newUniversity\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e코드 설명\naddUniversity()가 데이터베이스에 새로운 대학을 추가하는 엔드포인트로 상상해 봅시다. 사용자가 프론트엔드에서 데이터를 제출하면 이 API 엔드포인트는 데이터를 받아서 Pydantic 모델에 전달합니다. addUniversity() 함수 내에서 University 데이터 모델을 model_bump() 메서드를 사용하여 직렬화하는 새로운 변수 newUniversity를 선언합니다. 여기에서 우리는 Pydantic 모델의 출력을 원하는 대로 사용자 정의할 수 있습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\"exclude\": 이 옵션을 사용하여 Pydantic 모델에서 가져온 필드를 제거할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\"include\": 여기서 함수 내에서 계산에 필요한 필드를 지정할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\"by_alias\": Pydantic 모델의 각 필드에 대한 대체 이름을 이미 정의했다면, by_alias는 사용 여부에 대한 옵션을 제공합니다.\u003c/p\u003e\n\u003cp\u003e\"exclude_default\": Pydantic 모델의 특정 필드에 대한 기본값을 정의했기 때문에, 기본값과 같은 값을 가진 필드를 제외하려면 이 옵션을 사용할 수 있습니다. 이 옵션은 그 목적을 위해 사용됩니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e만약 다른 옵션들을 더 탐색하고 싶다면, \u003ccode\u003eAPI documentation\u003c/code\u003e Pydantic 문서 \u003ccode\u003eBase model\u003c/code\u003e \u003ccode\u003emodel_dump\u003c/code\u003e 를 확인해보세요.\u003c/p\u003e\n\u003ch2\u003edict()\u003c/h2\u003e\n\u003cp\u003e여기서 제공하는 것 또한 \u003ccode\u003emodel_dump()\u003c/code\u003e 메서드와 비슷합니다. 왜냐하면 이 역시 파이썬 딕셔너리를 반환하기 때문입니다. 하지만 다른 점은 customize our pydantic model을 위해 사용할 수 있는 몇 가지 옵션이 있다는 것입니다.\u003c/p\u003e\n\u003ch2\u003emodel_dump_json()\u003c/h2\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e만약 JSON 출력 또는 직렬화 출력을 JSON 형식으로 받고 싶다면 \u003ccode\u003emodel_dump_json()\u003c/code\u003e을 사용하세요. \u003ccode\u003emodel_dump\u003c/code\u003e 메서드에서 사용 가능한 모든 옵션들을 여기에도 사용할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e다른 직렬화 옵션들은 무엇이 있을까요\u003c/h1\u003e\n\u003ch2\u003e@field_serializer\u003c/h2\u003e\n\u003cp\u003e예를 들어 Pydantic 모델에서 특정 필드를 커스텀하고자 할 때, 함수나 엔드포인트로 Pydantic 모델 데이터를 가져오기 전에 그 필드를 수정하고 싶을 수 있습니다. 다시 말해 Pydantic 모델을 호출한 후 일부 필드를 수정해 해당 데이터를 함수나 엔드포인트로 반환하고자 하는 경우가 있을 수 있습니다. 이런 경우 \u003ccode\u003e@field_serializer\u003c/code\u003e를 사용해야합니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e fastapi \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e FastAPI\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e pydantic \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e BaseModel, field_serializer\n\napp = FastAPI()\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUniversity\u003c/span\u003e(\u003cspan class=\"hljs-title class_ inherited__\"\u003eBaseModel\u003c/span\u003e):\n    name: \u003cspan class=\"hljs-built_in\"\u003estr\u003c/span\u003e\n    place: \u003cspan class=\"hljs-built_in\"\u003estr\u003c/span\u003e\n    rank: \u003cspan class=\"hljs-built_in\"\u003estr\u003c/span\u003e\n    specialize: \u003cspan class=\"hljs-built_in\"\u003eint\u003c/span\u003e\n\n\u003cspan class=\"hljs-meta\"\u003e    @field_serializer(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-string\"\u003e'rank'\u003c/span\u003e, when_used=\u003cspan class=\"hljs-string\"\u003e'always'\u003c/span\u003e\u003c/span\u003e)\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erank_serialize\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003erank: \u003cspan class=\"hljs-built_in\"\u003estr\u003c/span\u003e\u003c/span\u003e):\n        rank = \u003cspan class=\"hljs-string\"\u003e'world rank - '\u003c/span\u003e + rank\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e rank\n\n\u003cspan class=\"hljs-meta\"\u003e@app.post(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-string\"\u003e'/create'\u003c/span\u003e\u003c/span\u003e)\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eaddUniversity\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003euniversity: University\u003c/span\u003e):\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e university\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e코드 설명\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eUniversity pydantic 모델은 name, place, specialize와 함께 rank와 같은 여러 필드를 허용합니다. 이 모델에 데이터를 전달할 때 rank 필드의 값은 문자열입니다. 그러나 이 코드 외부에서 데이터를 전달할 때 rank의 값으로 숫자만 받습니다. \"01\", \"02\"와 같은 링크를 사용하지만 이 pydantic 모델 외부에서 데이터를 전달할 때 rank의 값을 \"world rank - 01\"과 같이 바꾸고 싶습니다. 간단히 말해 출력은 다음과 같아야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e{\n  \u003cspan class=\"hljs-string\"\u003e\"name\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"string\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-string\"\u003e\"place\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"string\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-string\"\u003e\"rank\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"world rank - 01\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-string\"\u003e\"specialize\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003ejs\n{\n\"name\": \"string\",\n\"place\": \"string\",\n\"rank\": \"01\",\n\"specialize\": 0\n}\u003c/p\u003e\n\u003cp\u003e단일 필드만 직렬화하려면 Pydantic 모델 내에서 새로운 함수를 선언해야 합니다. 이 함수에는 '@field_serializer' 데코레이터를 사용해야 합니다. 하지만 먼저 해당 데코레이터를 Pydantic 모델에서 import해야 합니다. 여러 매개변수를 받을 수 있지만, 여기서는 두 가지만 언급합니다. 첫 번째는 어떤 필드를 직렬화할지를 나타내는 것입니다. 여기서는 'rank' 필드를 사용했습니다. 두 번째는 'when_use'입니다. 이곳에서 언제 이 필드 직렬화기를 사용할지 알려주어야 합니다. 이 예시에서는 'always'를 사용합니다.\u003c/p\u003e\n\u003cp\u003e그런 다음 해당 함수 내에서 원하는 작업을 수행하고, 마지막으로 반환하면 됩니다. 그게 전부입니다. 간단하지요?\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e@model_serializer\u003c/h2\u003e\n\u003cp\u003e이 메서드에서는 엔드포인트나 함수로 반환하기 전에 원하는대로 pydantic 모델을 직렬화할 수 있습니다. 이는 field_serializer와 매우 유사합니다. 더 잘 이해하기 위해 예제를 살펴봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e fastapi \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFastAPI\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e pydantic \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBaseModel\u003c/span\u003e, model_serializer\n\napp = \u003cspan class=\"hljs-title class_\"\u003eFastAPI\u003c/span\u003e()\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUniversity\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eBaseModel\u003c/span\u003e):\n    name : str\n    place : str\n    @\u003cspan class=\"hljs-title function_\"\u003emodel_serializer\u003c/span\u003e()\n    def \u003cspan class=\"hljs-title function_\"\u003erank_serialize\u003c/span\u003e(self):\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n        \u003cspan class=\"hljs-string\"\u003e'name'\u003c/span\u003e : \u003cspan class=\"hljs-string\"\u003e'the '\u003c/span\u003e + self.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e'place'\u003c/span\u003e : self.\u003cspan class=\"hljs-property\"\u003eplace\u003c/span\u003e + \u003cspan class=\"hljs-string\"\u003e', sri lanka'\u003c/span\u003e\n        }\n@app.\u003cspan class=\"hljs-title function_\"\u003epost\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/create'\u003c/span\u003e)\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e def \u003cspan class=\"hljs-title function_\"\u003eaddUniversity\u003c/span\u003e(university : \u003cspan class=\"hljs-title class_\"\u003eUniversity\u003c/span\u003e):\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e university\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 출력을 얻고 싶습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e{\n  \u003cspan class=\"hljs-string\"\u003e\"name\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"콜롬보 대학\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-string\"\u003e\"place\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"스리랑카 콜롬보\"\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e대신에 모델 시리얼라이저를 사용해보세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e{\n  \u003cspan class=\"hljs-string\"\u003e\"name\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"콜롬보 대학\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-string\"\u003e\"place\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"콜롬보\"\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e첫 번째로 해야 할 일은 pydantic 모델에서 model_serializer를 import하는 것입니다. 그런 다음 모델 내부에서 '@model_serializer' 데코레이터가 달린 함수를 선언하고 원하는 방식으로 출력을 구성하십시오. 마지막으로 반환하십시오. 더 자세한 내용은 pydantic 문서 \u003ccode\u003eAPI Documentation\u003c/code\u003e의 \u003ccode\u003eFunctional serializer\u003c/code\u003e 섹션을 참조하십시오.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e그냥 간단하게 Pydantic에서 serializer를 사용하는 방법이야. 더 자세한 내용을 원한다면 문서를 확인하고 이해를 돕기 위해 뭔가를 구현해보세요...\u003c/p\u003e\n\u003cp\u003e코딩 즐겁게 하시고 또 다른 FastAPI 주제에서 만나요...\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-07-07-PydanticserializationstepbystepsforFastAPI"},"buildId":"FuXRqV9h16krA5Mvtd6Dn","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>