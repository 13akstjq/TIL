<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Python 리스트 내포 List Comprehension 문법의 진정한 강점 단순한 문법 설탕이 아님 | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Python 리스트 내포 List Comprehension 문법의 진정한 강점 단순한 문법 설탕이 아님 | TIL" data-gatsby-head="true"/><meta property="og:title" content="Python 리스트 내포 List Comprehension 문법의 진정한 강점 단순한 문법 설탕이 아님 | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar" data-gatsby-head="true"/><meta name="twitter:title" content="Python 리스트 내포 List Comprehension 문법의 진정한 강점 단순한 문법 설탕이 아님 | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2024-07-09 19:26" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/TIL/_next/static/chunks/463-925361deb4cec4b1.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/post/%5Bslug%5D-9d7ebbd29b9e08ce.js" defer=""></script><script src="/TIL/_next/static/71zJMhK9mFbQV7s02rMGq/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/71zJMhK9mFbQV7s02rMGq/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Python 리스트 내포 List Comprehension 문법의 진정한 강점 단순한 문법 설탕이 아님</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Python 리스트 내포 List Comprehension 문법의 진정한 강점 단순한 문법 설탕이 아님" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jul 9, 2024</span><span class="posts_reading_time__f7YPP">14<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>아마 수많은 기사들을 보면, 파이썬에서 for-loop 대신 리스트 컴프리헨션을 사용하는 것을 권장하는 내용이 많다는 것을 이미 알아차렸을 것 같아요. 저도 많이 봤어요. 그런데 놀랍게도 그 이유에 대해 설명한 기사는 거의 찾아보기 힘들었죠.</p>
<p>"파이썬 다운"이라거나 "가독성"과 같은 이유들만으로는 제가 같은 사람들을 쉽게 설득할 수 없을 거에요. 이런 "이유"들은 실제로는 파이썬 초보자들에게 잘못된 인상을 줄 수 있어요. 즉, 파이썬 리스트 컴프리헨션이 단순히 문법적 설탕에 불과하다는 거죠.</p>
<p>사실, 리스트 컴프리헨션은 파이썬에서 큰 최적화 중 하나에요. 이 기사에서는 이러한 메커니즘에 대해 심층적으로 살펴볼 거에요. 아래 질문들에 대한 답을 얻을 수 있습니다.</p>
<ul>
<li>파이썬의 리스트 컴프리헨션은 무엇인가요?</li>
<li>왜 리스트 컴프리헨션의 성능이 일반적으로 for-loop보다 우수한가요?</li>
<li>언제 리스트 컴프리헨션을 사용해서는 안 되나요?</li>
</ul>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>1. 간단한 성능 비교</h1>
<p><img src="/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_0.png" alt="image"></p>
<p>우리는 간단한 프로그램을 작성할 것이다. 먼저 for 루프와 리스트 컴프리헨션을 사용한 방법으로 각각의 성능을 비교해보자.</p>
<pre><code class="hljs language-js">factor = <span class="hljs-number">2</span>
results = []

<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(<span class="hljs-number">100</span>):
    results.<span class="hljs-title function_">append</span>(i * factor)
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>위 코드는 100번 실행되는 for 루프를 정의합니다. range(100) 함수는 100개의 정수를 생성하고 각각은 요소와 곱해집니다. 이전에 정의된 요소는 2입니다.</p>
<p>이제 리스트 컴프리헨션 버전을 살펴봅시다.</p>
<pre><code class="hljs language-js">factor = <span class="hljs-number">2</span>
results = [i * factor <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(<span class="hljs-number">100</span>)]
</code></pre>
<p>이 예제에서는 훨씬 더 쉽고 가독성이 좋습니다. 이 두 개의 동일한 코드 스니펫을 실행해보고 성능을 비교해봅시다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_1.png" alt="image"></p>
<p>결과는 리스트 컴프리헨션이 일반 for-loop보다 거의 2배 빠르다는 것을 보여줬어.</p>
<p>놀라운 건 아무것도 없어, 많은 기사들이 이미 말해줬던 내용이야. 하지만, 이 기사에서는 리스트 컴프리헨션이 왜 더 빠른지에 대해 집중적으로 다루고 있고, 내부에서 어떤 주요 차이가 있는지에 대해 논의할 거야.</p>
<p>이 기사의 나머지 내용을 설명할 수 있는 모든 설명의 근거와 기준을 얻기 위해, 위의 두 구현, 즉 for-loop와 리스트 컴프리헨션의 bytecode를 얻기 위해 Python 내장 dis 모듈을 사용해보자.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> dis

dis.<span class="hljs-title function_">dis</span>(<span class="hljs-string">""</span><span class="hljs-string">"
factor = 2
results = []

for i in range(100):
    results.append(i * factor)
"</span><span class="hljs-string">""</span>)

dis.<span class="hljs-title function_">dis</span>(<span class="hljs-string">""</span><span class="hljs-string">"
factor = 2
results = [i * 2 for i in range(100)]
"</span><span class="hljs-string">""</span>)
</code></pre>
<p>실행 결과는 다음과 같습니다. 바이트 코드를 이해할 필요는 없습니다. 단지 바이트 코드의 "작업"은 "운영 코드" 또는 간단히 "opcode"라고 불립니다. 나중에 해당 내용을 참조하겠습니다.</p>
<p><img src="/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_2.png" alt="Python List Comprehension"></p>
<p><img src="/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_3.png" alt="Python List Comprehension"></p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>2. 전역 변수 대 로컬 변수</h1>
<p><img src="/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_4.png" alt="이미지"></p>
<p>가장 큰 차이점은 변수의 범위입니다. 위의 바이트 코드에서 다음과 같이 나타납니다.</p>
<ul>
<li>for 루프의 LOAD_NAME 대 리스트 함축의 LOAD_FAST</li>
<li>for 루프의 STORE_NAME 대 리스트 함축의 STORE_FAST</li>
</ul>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>확실하게 말씀드리자면, for-loop 버전의 변수 i는 전역 범위에 있지만, 리스트 컴프리헨션의 변수 i는 지역 범위에 있어 실행 중에만 존재합니다.</p>
<h2>변수의 범위(scopes)를 어떻게 확인할까요?</h2>
<p>Python, Jupyter 또는 Google Colab과 같은 노트북 환경에서 이를 쉽게 확인할 수 있습니다. 새로운 세션을 시작한 후에 for-loop 버전을 실행한 다음 %whos 매직 명령어를 실행하면 현재 세션에 정의된 모든 사용자 변수가 나열됩니다.</p>
<pre><code class="hljs language-python">factor = <span class="hljs-number">2</span>
results = []

<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):
    results.append(i * factor)
</code></pre>
<pre><code class="hljs language-python">%whos
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_5.png" alt="이미지"></p>
<p>여기에는 for 루프가 끝난 후에도 변수 i가 여전히 남아 있는 것을 보여줍니다. 지금 global() 메소드를 실행하면 거기에도 변수 i를 찾을 수 있습니다.</p>
<p>그러나 세션을 재시작하고 리스트 내포를 실행하면 변수 i가 표시되지 않습니다.</p>
<p><img src="/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_6.png" alt="이미지"></p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이는 변수 i가 리스트 내포 구현에서 로컬 변수임을 증명했습니다.</p>
<h2>왜 성능이 다를까요?</h2>
<p>작업이 전역 네임스페이스에 있는 변수에 액세스해야 할 때, 전역 네임스페이스의 모든 객체 목록을 통과해야 합니다. 전역 네임스페이스에 무엇이 있는지 궁금하다면 세션에서 globals() 메서드를 실행해 보세요.</p>
<p><img src="/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_7.png" alt="이미지"></p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>내 경우에는 Google Colab에서 새 세션을 시작했습니다. for 루프를 실행한 후 전역 네임스페이스 사전에 이미 26개의 객체가 있습니다. 더 복잡한 Python 애플리케이션을 실행한다고 상상해보면, 성능이 더 나빠질 수도 있습니다.</p>
<p>반면에 "로컬 변수"는 어떤가요?</p>
<p>안타깝게도, 리스트 내포에서 로컬 변수를 실행 중에 보여주는 것은 쉽지 않습니다. 따라서 간단한 함수를 사용하여 설명해보겠습니다. 함수 내부에 print() 메서드를 추가할 수 있기 때문이죠.</p>
<pre><code class="hljs language-js">def <span class="hljs-title function_">my_function</span>(x, y):
    z = x + y
    <span class="hljs-title function_">print</span>(<span class="hljs-string">"로컬 변수:"</span>, <span class="hljs-title function_">locals</span>())
    <span class="hljs-keyword">return</span> z

<span class="hljs-title function_">my_function</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>아래 예시에서 x, y 및 z는 지역 변수입니다. 컴파일 시간에는 모든 지역 변수를 보유할 배열이 생성되며 각 변수에 고정된 인덱스가 지정됩니다. 개념적으로, 지역 변수 배열은 다음과 같이 나타낼 수 있습니다:</p>
<ul>
<li>x는 인덱스 0에 있음</li>
<li>y는 인덱스 1에 있음</li>
<li>z는 인덱스 2에 있음</li>
</ul>
<p>따라서 함수(리스트 컴프리헨션)가 지역 변수에 액세스해야 할 때는 해당 인덱스를 사용합니다. 따라서 전역 네임스페이스에서 검색하는 것과 비교했을 때 훨씬 효율적입니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>변수 대비 상수</h2>
<p>변수 i를 제외하고 또 하나의 최적화는 로컬 변수 때문에 발생하고 있습니다.</p>
<p>변수 요소에 주의해주세요. 실제로, 요소 변수를 리스트 내포 밖에서 정의했지만, 그것은 로컬 상수로 리스트 내포에 로드될 것입니다.</p>
<p><img src="/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_9.png" alt="이미지"></p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>위의 바이트 코드에서. 변수 factor를 모든 루프에서 전역 변수로 로드해야 합니다.</p>
<p><img src="/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_10.png" alt="image"></p>
<p>그러나 리스트 컴프리헨션에서는 컴파일러가 factor의 값을 변경할 수 없는 상수로 로드하고 지역 범위에 유지해도 충분히 안전합니다. 따라서 전역 네임스페이스에서 변수를 검색할 필요가 없습니다.</p>
<p>물론, 이것은 리스트 컴프리헨션의 성능에 기여하는 다른 요소입니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>3. 일반 메소드 vs 최적화된 메소드</h1>
<p><img src="/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_11.png" alt="image"></p>
<p>또 다른 주요한 차이점은 append() 메소드에서 나타납니다. 두 가지 구현 방법의 단계를 보여드리겠습니다.</p>
<p>for 루프 버전에서:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>LOAD_METHOD은 리스트 객체 결과에서 append() 메서드를 로드합니다.</li>
<li>LOAD_NAME은 변수 i를 로드합니다.</li>
<li>LOAD_NAME은 변수 factor를 로드합니다.</li>
<li>BINARY_MULTIPLY는 수학 연산을 수행합니다.</li>
<li>CALL_METHOD은 append() 메서드를 호출하여 실행하고, 즉 결과를 결과 목록에 추가합니다.</li>
</ul>
<p>리스트 컴프리헨션 버전에서:</p>
<ul>
<li>LOAD_FAST는 로컬 변수에서 변수 i를 로드합니다.</li>
<li>LOAD_CONST는 변수 factor의 값인 상수 2를 로드합니다.</li>
<li>BINARY_MULTIPLY는 수학 연산을 수행합니다.</li>
<li>LIST_APPEND는 결과를 로컬 변수에서도 있는 목록에 추가합니다.</li>
</ul>
<p>리스트 컴프리헨션 버전의 성능이 더 우수한 이유는 단순히 한 단계가 덜 있기 때문만이 아니라 내부적인 메커니즘 때문입니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>LOAD_METHOD과 LIST_APPEND가 왜 다른가요?</h2>
<p>우리는 결과 목록에서 append() 메서드를 호출합니다. 즉, results.append(...)입니다. 이를 실행할 때 Python 런타임은 List 객체 공간에서 메서드를 찾아야 합니다. 이는 객체에 대해 dir() 메서드를 호출하는 것과 거의 동일합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">print</span>(<span class="hljs-title function_">dir</span>(results));
</code></pre>
<img src="/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_12.png">
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>당연히 이 "검색" 작업은 모든 루프에서 발생할 것입니다.</p>
<p>그러나 리스트 내포 버전에서 결과 리스트도 로컬 변수입니다. 이 메커니즘은 리스트가 생성될 것이고, 리스트 내포 실행과 함께 만들어진다는 것입니다.</p>
<p>비유를 들어보겠습니다. 작은 항목을 큰 컨테이너에 정리하는 것으로 상상해 보겠습니다.</p>
<p>for 루프 버전은 append() 메서드를 사용하는 것이 매번 우리가 항목과 상자를 다른 사람에게 주고, 이 사람이 항목을 넣은 후에 우리에게 컨테이너를 다시 돌려주는 것처럼합니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>리스트 내포 버전을 사용하면 다른 사람의 도움 없이 항목을 컨테이너에 넣을 수 있어요. 따라서 성능도 훨씬 좋아요.</p>
<h1>4. 리스트 내포를 사용해서는 안 되는 경우</h1>
<p><img src="/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_13.png" alt="Python List Comprehension"></p>
<p>물론, 리스트 내포는 남용해서는 안 돼요. 다시 말해, 사용은 가능하지만 특정 상황에서는 사용해서는 안 되는 경우가 있어요.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>한 가지 전형적인 시나리오는 필터 조건이 너무 복잡하다는 것입니다. 다음 예를 고려해보세요. 학생들의 이름과 시험 점수가 들어있는 튜플 목록이 있습니다.</p>
<pre><code class="hljs language-js">students = [(<span class="hljs-string">"Alice"</span>, <span class="hljs-number">85</span>), (<span class="hljs-string">"Bob"</span>, <span class="hljs-number">95</span>), (<span class="hljs-string">"Cindy"</span>, <span class="hljs-number">100</span>), (<span class="hljs-string">"David"</span>, <span class="hljs-number">65</span>), (<span class="hljs-string">"Eva"</span>, <span class="hljs-number">70</span>)];
</code></pre>
<p>그런 다음, 특정 조건에 따라 이름을 필터링하려고 합니다. 점수는 80보다 커야하고, 이름은 "A" 또는 "C"로 시작해야 합니다. 아래는 for 루프 구현입니다.</p>
<pre><code class="hljs language-js">filtered_names = []

<span class="hljs-keyword">for</span> name, score <span class="hljs-keyword">in</span> <span class="hljs-attr">students</span>:
    <span class="hljs-keyword">if</span> score > <span class="hljs-number">80</span> and name.<span class="hljs-title function_">startswith</span>((<span class="hljs-string">"A"</span>, <span class="hljs-string">"C"</span>)):
        filtered_names.<span class="hljs-title function_">append</span>(name)
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>여기에 리스트 컴프리헨션 구현방법이 있습니다.</p>
<pre><code class="hljs language-js">filtered_names = [name <span class="hljs-keyword">for</span> name, score <span class="hljs-keyword">in</span> students <span class="hljs-keyword">if</span> score > <span class="hljs-number">80</span> and name.<span class="hljs-title function_">startswith</span>((<span class="hljs-string">"A"</span>, <span class="hljs-string">"C"</span>))]
</code></pre>
<img src="/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_14.png">
<p>음, 리스트 컴프리헨션의 성능은 여전히 for 루프보다 조금 더 나은 편이에요. 그러나 복잡한 조건 때문에 리스트 컴프리헨션은 가독성이 많이 떨어지기 시작했다고 말씀드려야 할 것 같아요.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>가독성과 디버깅 유연성을 희생해서 성능을 조금 향상시키는 것이 매우 주관적일 수 있습니다. 결정은 여러분에게 맡기겠습니다. :)</p>
<h1>요약</h1>
<p><img src="/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_15.png" alt="이미지"></p>
<p>이 글에서는 리스트 컴프리헨션의 성능이 일반 for-loop보다 우수한 이유에 대해 소개했습니다. 그것이 단순히 구문적인 설탕이 아니라 성능 최적화임을 증명했습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>두 구현의 바이트 코드를 표시하여 증거가 발굴되었습니다. 주요 차이점은 지역 vs. 전역 네임스페이스와 일반 메서드 vs. 최적화된 메서드입니다.</p>
<p>물론, 모든 시나리오에서 리스트 내포를 사용하는 것이 권장되지는 않습니다. 예를 들어, 조건이 매우 많은 계층과 보다 복잡한 조건을 갖는 경우입니다. 여전히 리스트 내포를 사용할 가치가 있는지 고려해야 합니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Python 리스트 내포 List Comprehension 문법의 진정한 강점 단순한 문법 설탕이 아님","description":"","date":"2024-07-09 19:26","slug":"2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar","content":"\n아마 수많은 기사들을 보면, 파이썬에서 for-loop 대신 리스트 컴프리헨션을 사용하는 것을 권장하는 내용이 많다는 것을 이미 알아차렸을 것 같아요. 저도 많이 봤어요. 그런데 놀랍게도 그 이유에 대해 설명한 기사는 거의 찾아보기 힘들었죠.\n\n\"파이썬 다운\"이라거나 \"가독성\"과 같은 이유들만으로는 제가 같은 사람들을 쉽게 설득할 수 없을 거에요. 이런 \"이유\"들은 실제로는 파이썬 초보자들에게 잘못된 인상을 줄 수 있어요. 즉, 파이썬 리스트 컴프리헨션이 단순히 문법적 설탕에 불과하다는 거죠.\n\n사실, 리스트 컴프리헨션은 파이썬에서 큰 최적화 중 하나에요. 이 기사에서는 이러한 메커니즘에 대해 심층적으로 살펴볼 거에요. 아래 질문들에 대한 답을 얻을 수 있습니다.\n\n- 파이썬의 리스트 컴프리헨션은 무엇인가요?\n- 왜 리스트 컴프리헨션의 성능이 일반적으로 for-loop보다 우수한가요?\n- 언제 리스트 컴프리헨션을 사용해서는 안 되나요?\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 1. 간단한 성능 비교\n\n![image](/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_0.png)\n\n우리는 간단한 프로그램을 작성할 것이다. 먼저 for 루프와 리스트 컴프리헨션을 사용한 방법으로 각각의 성능을 비교해보자.\n\n```js\nfactor = 2\nresults = []\n\nfor i in range(100):\n    results.append(i * factor)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위 코드는 100번 실행되는 for 루프를 정의합니다. range(100) 함수는 100개의 정수를 생성하고 각각은 요소와 곱해집니다. 이전에 정의된 요소는 2입니다.\n\n이제 리스트 컴프리헨션 버전을 살펴봅시다.\n\n```js\nfactor = 2\nresults = [i * factor for i in range(100)]\n```\n\n이 예제에서는 훨씬 더 쉽고 가독성이 좋습니다. 이 두 개의 동일한 코드 스니펫을 실행해보고 성능을 비교해봅시다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_1.png)\n\n결과는 리스트 컴프리헨션이 일반 for-loop보다 거의 2배 빠르다는 것을 보여줬어.\n\n놀라운 건 아무것도 없어, 많은 기사들이 이미 말해줬던 내용이야. 하지만, 이 기사에서는 리스트 컴프리헨션이 왜 더 빠른지에 대해 집중적으로 다루고 있고, 내부에서 어떤 주요 차이가 있는지에 대해 논의할 거야.\n\n이 기사의 나머지 내용을 설명할 수 있는 모든 설명의 근거와 기준을 얻기 위해, 위의 두 구현, 즉 for-loop와 리스트 컴프리헨션의 bytecode를 얻기 위해 Python 내장 dis 모듈을 사용해보자.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport dis\n\ndis.dis(\"\"\"\nfactor = 2\nresults = []\n\nfor i in range(100):\n    results.append(i * factor)\n\"\"\")\n\ndis.dis(\"\"\"\nfactor = 2\nresults = [i * 2 for i in range(100)]\n\"\"\")\n```\n\n실행 결과는 다음과 같습니다. 바이트 코드를 이해할 필요는 없습니다. 단지 바이트 코드의 \"작업\"은 \"운영 코드\" 또는 간단히 \"opcode\"라고 불립니다. 나중에 해당 내용을 참조하겠습니다.\n\n![Python List Comprehension](/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_2.png)\n\n![Python List Comprehension](/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_3.png)\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 2. 전역 변수 대 로컬 변수\n\n![이미지](/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_4.png)\n\n가장 큰 차이점은 변수의 범위입니다. 위의 바이트 코드에서 다음과 같이 나타납니다.\n\n- for 루프의 LOAD_NAME 대 리스트 함축의 LOAD_FAST\n- for 루프의 STORE_NAME 대 리스트 함축의 STORE_FAST\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n확실하게 말씀드리자면, for-loop 버전의 변수 i는 전역 범위에 있지만, 리스트 컴프리헨션의 변수 i는 지역 범위에 있어 실행 중에만 존재합니다.\n\n## 변수의 범위(scopes)를 어떻게 확인할까요?\n\nPython, Jupyter 또는 Google Colab과 같은 노트북 환경에서 이를 쉽게 확인할 수 있습니다. 새로운 세션을 시작한 후에 for-loop 버전을 실행한 다음 %whos 매직 명령어를 실행하면 현재 세션에 정의된 모든 사용자 변수가 나열됩니다.\n\n```python\nfactor = 2\nresults = []\n\nfor i in range(100):\n    results.append(i * factor)\n```\n\n```python\n%whos\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_5.png)\n\n여기에는 for 루프가 끝난 후에도 변수 i가 여전히 남아 있는 것을 보여줍니다. 지금 global() 메소드를 실행하면 거기에도 변수 i를 찾을 수 있습니다.\n\n그러나 세션을 재시작하고 리스트 내포를 실행하면 변수 i가 표시되지 않습니다.\n\n![이미지](/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_6.png)\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이는 변수 i가 리스트 내포 구현에서 로컬 변수임을 증명했습니다.\n\n## 왜 성능이 다를까요?\n\n작업이 전역 네임스페이스에 있는 변수에 액세스해야 할 때, 전역 네임스페이스의 모든 객체 목록을 통과해야 합니다. 전역 네임스페이스에 무엇이 있는지 궁금하다면 세션에서 globals() 메서드를 실행해 보세요.\n\n![이미지](/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_7.png)\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n내 경우에는 Google Colab에서 새 세션을 시작했습니다. for 루프를 실행한 후 전역 네임스페이스 사전에 이미 26개의 객체가 있습니다. 더 복잡한 Python 애플리케이션을 실행한다고 상상해보면, 성능이 더 나빠질 수도 있습니다.\n\n반면에 \"로컬 변수\"는 어떤가요?\n\n안타깝게도, 리스트 내포에서 로컬 변수를 실행 중에 보여주는 것은 쉽지 않습니다. 따라서 간단한 함수를 사용하여 설명해보겠습니다. 함수 내부에 print() 메서드를 추가할 수 있기 때문이죠.\n\n```js\ndef my_function(x, y):\n    z = x + y\n    print(\"로컬 변수:\", locals())\n    return z\n\nmy_function(1, 2)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 예시에서 x, y 및 z는 지역 변수입니다. 컴파일 시간에는 모든 지역 변수를 보유할 배열이 생성되며 각 변수에 고정된 인덱스가 지정됩니다. 개념적으로, 지역 변수 배열은 다음과 같이 나타낼 수 있습니다:\n\n- x는 인덱스 0에 있음\n- y는 인덱스 1에 있음\n- z는 인덱스 2에 있음\n\n따라서 함수(리스트 컴프리헨션)가 지역 변수에 액세스해야 할 때는 해당 인덱스를 사용합니다. 따라서 전역 네임스페이스에서 검색하는 것과 비교했을 때 훨씬 효율적입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 변수 대비 상수\n\n변수 i를 제외하고 또 하나의 최적화는 로컬 변수 때문에 발생하고 있습니다.\n\n변수 요소에 주의해주세요. 실제로, 요소 변수를 리스트 내포 밖에서 정의했지만, 그것은 로컬 상수로 리스트 내포에 로드될 것입니다.\n\n![이미지](/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_9.png)\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 바이트 코드에서. 변수 factor를 모든 루프에서 전역 변수로 로드해야 합니다.\n\n![image](/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_10.png)\n\n그러나 리스트 컴프리헨션에서는 컴파일러가 factor의 값을 변경할 수 없는 상수로 로드하고 지역 범위에 유지해도 충분히 안전합니다. 따라서 전역 네임스페이스에서 변수를 검색할 필요가 없습니다.\n\n물론, 이것은 리스트 컴프리헨션의 성능에 기여하는 다른 요소입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 3. 일반 메소드 vs 최적화된 메소드\n\n![image](/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_11.png)\n\n또 다른 주요한 차이점은 append() 메소드에서 나타납니다. 두 가지 구현 방법의 단계를 보여드리겠습니다.\n\nfor 루프 버전에서:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- LOAD_METHOD은 리스트 객체 결과에서 append() 메서드를 로드합니다.\n- LOAD_NAME은 변수 i를 로드합니다.\n- LOAD_NAME은 변수 factor를 로드합니다.\n- BINARY_MULTIPLY는 수학 연산을 수행합니다.\n- CALL_METHOD은 append() 메서드를 호출하여 실행하고, 즉 결과를 결과 목록에 추가합니다.\n\n리스트 컴프리헨션 버전에서:\n\n- LOAD_FAST는 로컬 변수에서 변수 i를 로드합니다.\n- LOAD_CONST는 변수 factor의 값인 상수 2를 로드합니다.\n- BINARY_MULTIPLY는 수학 연산을 수행합니다.\n- LIST_APPEND는 결과를 로컬 변수에서도 있는 목록에 추가합니다.\n\n리스트 컴프리헨션 버전의 성능이 더 우수한 이유는 단순히 한 단계가 덜 있기 때문만이 아니라 내부적인 메커니즘 때문입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## LOAD_METHOD과 LIST_APPEND가 왜 다른가요?\n\n우리는 결과 목록에서 append() 메서드를 호출합니다. 즉, results.append(...)입니다. 이를 실행할 때 Python 런타임은 List 객체 공간에서 메서드를 찾아야 합니다. 이는 객체에 대해 dir() 메서드를 호출하는 것과 거의 동일합니다.\n\n```js\nprint(dir(results));\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_12.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n당연히 이 \"검색\" 작업은 모든 루프에서 발생할 것입니다.\n\n그러나 리스트 내포 버전에서 결과 리스트도 로컬 변수입니다. 이 메커니즘은 리스트가 생성될 것이고, 리스트 내포 실행과 함께 만들어진다는 것입니다.\n\n비유를 들어보겠습니다. 작은 항목을 큰 컨테이너에 정리하는 것으로 상상해 보겠습니다.\n\nfor 루프 버전은 append() 메서드를 사용하는 것이 매번 우리가 항목과 상자를 다른 사람에게 주고, 이 사람이 항목을 넣은 후에 우리에게 컨테이너를 다시 돌려주는 것처럼합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n리스트 내포 버전을 사용하면 다른 사람의 도움 없이 항목을 컨테이너에 넣을 수 있어요. 따라서 성능도 훨씬 좋아요.\n\n# 4. 리스트 내포를 사용해서는 안 되는 경우\n\n![Python List Comprehension](/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_13.png)\n\n물론, 리스트 내포는 남용해서는 안 돼요. 다시 말해, 사용은 가능하지만 특정 상황에서는 사용해서는 안 되는 경우가 있어요.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n한 가지 전형적인 시나리오는 필터 조건이 너무 복잡하다는 것입니다. 다음 예를 고려해보세요. 학생들의 이름과 시험 점수가 들어있는 튜플 목록이 있습니다.\n\n```js\nstudents = [(\"Alice\", 85), (\"Bob\", 95), (\"Cindy\", 100), (\"David\", 65), (\"Eva\", 70)];\n```\n\n그런 다음, 특정 조건에 따라 이름을 필터링하려고 합니다. 점수는 80보다 커야하고, 이름은 \"A\" 또는 \"C\"로 시작해야 합니다. 아래는 for 루프 구현입니다.\n\n```js\nfiltered_names = []\n\nfor name, score in students:\n    if score \u003e 80 and name.startswith((\"A\", \"C\")):\n        filtered_names.append(name)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기에 리스트 컴프리헨션 구현방법이 있습니다.\n\n```js\nfiltered_names = [name for name, score in students if score \u003e 80 and name.startswith((\"A\", \"C\"))]\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_14.png\" /\u003e\n\n음, 리스트 컴프리헨션의 성능은 여전히 for 루프보다 조금 더 나은 편이에요. 그러나 복잡한 조건 때문에 리스트 컴프리헨션은 가독성이 많이 떨어지기 시작했다고 말씀드려야 할 것 같아요.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n가독성과 디버깅 유연성을 희생해서 성능을 조금 향상시키는 것이 매우 주관적일 수 있습니다. 결정은 여러분에게 맡기겠습니다. :)\n\n# 요약\n\n![이미지](/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_15.png)\n\n이 글에서는 리스트 컴프리헨션의 성능이 일반 for-loop보다 우수한 이유에 대해 소개했습니다. 그것이 단순히 구문적인 설탕이 아니라 성능 최적화임을 증명했습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n두 구현의 바이트 코드를 표시하여 증거가 발굴되었습니다. 주요 차이점은 지역 vs. 전역 네임스페이스와 일반 메서드 vs. 최적화된 메서드입니다.\n\n물론, 모든 시나리오에서 리스트 내포를 사용하는 것이 권장되지는 않습니다. 예를 들어, 조건이 매우 많은 계층과 보다 복잡한 조건을 갖는 경우입니다. 여전히 리스트 내포를 사용할 가치가 있는지 고려해야 합니다.\n","ogImage":{"url":"/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_0.png","tag":["Tech"],"readingTime":14},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e아마 수많은 기사들을 보면, 파이썬에서 for-loop 대신 리스트 컴프리헨션을 사용하는 것을 권장하는 내용이 많다는 것을 이미 알아차렸을 것 같아요. 저도 많이 봤어요. 그런데 놀랍게도 그 이유에 대해 설명한 기사는 거의 찾아보기 힘들었죠.\u003c/p\u003e\n\u003cp\u003e\"파이썬 다운\"이라거나 \"가독성\"과 같은 이유들만으로는 제가 같은 사람들을 쉽게 설득할 수 없을 거에요. 이런 \"이유\"들은 실제로는 파이썬 초보자들에게 잘못된 인상을 줄 수 있어요. 즉, 파이썬 리스트 컴프리헨션이 단순히 문법적 설탕에 불과하다는 거죠.\u003c/p\u003e\n\u003cp\u003e사실, 리스트 컴프리헨션은 파이썬에서 큰 최적화 중 하나에요. 이 기사에서는 이러한 메커니즘에 대해 심층적으로 살펴볼 거에요. 아래 질문들에 대한 답을 얻을 수 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e파이썬의 리스트 컴프리헨션은 무엇인가요?\u003c/li\u003e\n\u003cli\u003e왜 리스트 컴프리헨션의 성능이 일반적으로 for-loop보다 우수한가요?\u003c/li\u003e\n\u003cli\u003e언제 리스트 컴프리헨션을 사용해서는 안 되나요?\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e1. 간단한 성능 비교\u003c/h1\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_0.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e우리는 간단한 프로그램을 작성할 것이다. 먼저 for 루프와 리스트 컴프리헨션을 사용한 방법으로 각각의 성능을 비교해보자.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efactor = \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e\nresults = []\n\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e):\n    results.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e(i * factor)\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e위 코드는 100번 실행되는 for 루프를 정의합니다. range(100) 함수는 100개의 정수를 생성하고 각각은 요소와 곱해집니다. 이전에 정의된 요소는 2입니다.\u003c/p\u003e\n\u003cp\u003e이제 리스트 컴프리헨션 버전을 살펴봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efactor = \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e\nresults = [i * factor \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e)]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예제에서는 훨씬 더 쉽고 가독성이 좋습니다. 이 두 개의 동일한 코드 스니펫을 실행해보고 성능을 비교해봅시다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_1.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e결과는 리스트 컴프리헨션이 일반 for-loop보다 거의 2배 빠르다는 것을 보여줬어.\u003c/p\u003e\n\u003cp\u003e놀라운 건 아무것도 없어, 많은 기사들이 이미 말해줬던 내용이야. 하지만, 이 기사에서는 리스트 컴프리헨션이 왜 더 빠른지에 대해 집중적으로 다루고 있고, 내부에서 어떤 주요 차이가 있는지에 대해 논의할 거야.\u003c/p\u003e\n\u003cp\u003e이 기사의 나머지 내용을 설명할 수 있는 모든 설명의 근거와 기준을 얻기 위해, 위의 두 구현, 즉 for-loop와 리스트 컴프리헨션의 bytecode를 얻기 위해 Python 내장 dis 모듈을 사용해보자.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e dis\n\ndis.\u003cspan class=\"hljs-title function_\"\u003edis\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\nfactor = 2\nresults = []\n\nfor i in range(100):\n    results.append(i * factor)\n\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e)\n\ndis.\u003cspan class=\"hljs-title function_\"\u003edis\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\nfactor = 2\nresults = [i * 2 for i in range(100)]\n\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e실행 결과는 다음과 같습니다. 바이트 코드를 이해할 필요는 없습니다. 단지 바이트 코드의 \"작업\"은 \"운영 코드\" 또는 간단히 \"opcode\"라고 불립니다. 나중에 해당 내용을 참조하겠습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_2.png\" alt=\"Python List Comprehension\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_3.png\" alt=\"Python List Comprehension\"\u003e\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e2. 전역 변수 대 로컬 변수\u003c/h1\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_4.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e가장 큰 차이점은 변수의 범위입니다. 위의 바이트 코드에서 다음과 같이 나타납니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003efor 루프의 LOAD_NAME 대 리스트 함축의 LOAD_FAST\u003c/li\u003e\n\u003cli\u003efor 루프의 STORE_NAME 대 리스트 함축의 STORE_FAST\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e확실하게 말씀드리자면, for-loop 버전의 변수 i는 전역 범위에 있지만, 리스트 컴프리헨션의 변수 i는 지역 범위에 있어 실행 중에만 존재합니다.\u003c/p\u003e\n\u003ch2\u003e변수의 범위(scopes)를 어떻게 확인할까요?\u003c/h2\u003e\n\u003cp\u003ePython, Jupyter 또는 Google Colab과 같은 노트북 환경에서 이를 쉽게 확인할 수 있습니다. 새로운 세션을 시작한 후에 for-loop 버전을 실행한 다음 %whos 매직 명령어를 실행하면 현재 세션에 정의된 모든 사용자 변수가 나열됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003efactor = \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e\nresults = []\n\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003erange\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e):\n    results.append(i * factor)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e%whos\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_5.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e여기에는 for 루프가 끝난 후에도 변수 i가 여전히 남아 있는 것을 보여줍니다. 지금 global() 메소드를 실행하면 거기에도 변수 i를 찾을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e그러나 세션을 재시작하고 리스트 내포를 실행하면 변수 i가 표시되지 않습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_6.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이는 변수 i가 리스트 내포 구현에서 로컬 변수임을 증명했습니다.\u003c/p\u003e\n\u003ch2\u003e왜 성능이 다를까요?\u003c/h2\u003e\n\u003cp\u003e작업이 전역 네임스페이스에 있는 변수에 액세스해야 할 때, 전역 네임스페이스의 모든 객체 목록을 통과해야 합니다. 전역 네임스페이스에 무엇이 있는지 궁금하다면 세션에서 globals() 메서드를 실행해 보세요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_7.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e내 경우에는 Google Colab에서 새 세션을 시작했습니다. for 루프를 실행한 후 전역 네임스페이스 사전에 이미 26개의 객체가 있습니다. 더 복잡한 Python 애플리케이션을 실행한다고 상상해보면, 성능이 더 나빠질 수도 있습니다.\u003c/p\u003e\n\u003cp\u003e반면에 \"로컬 변수\"는 어떤가요?\u003c/p\u003e\n\u003cp\u003e안타깝게도, 리스트 내포에서 로컬 변수를 실행 중에 보여주는 것은 쉽지 않습니다. 따라서 간단한 함수를 사용하여 설명해보겠습니다. 함수 내부에 print() 메서드를 추가할 수 있기 때문이죠.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edef \u003cspan class=\"hljs-title function_\"\u003emy_function\u003c/span\u003e(x, y):\n    z = x + y\n    \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"로컬 변수:\"\u003c/span\u003e, \u003cspan class=\"hljs-title function_\"\u003elocals\u003c/span\u003e())\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e z\n\n\u003cspan class=\"hljs-title function_\"\u003emy_function\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e아래 예시에서 x, y 및 z는 지역 변수입니다. 컴파일 시간에는 모든 지역 변수를 보유할 배열이 생성되며 각 변수에 고정된 인덱스가 지정됩니다. 개념적으로, 지역 변수 배열은 다음과 같이 나타낼 수 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ex는 인덱스 0에 있음\u003c/li\u003e\n\u003cli\u003ey는 인덱스 1에 있음\u003c/li\u003e\n\u003cli\u003ez는 인덱스 2에 있음\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e따라서 함수(리스트 컴프리헨션)가 지역 변수에 액세스해야 할 때는 해당 인덱스를 사용합니다. 따라서 전역 네임스페이스에서 검색하는 것과 비교했을 때 훨씬 효율적입니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e변수 대비 상수\u003c/h2\u003e\n\u003cp\u003e변수 i를 제외하고 또 하나의 최적화는 로컬 변수 때문에 발생하고 있습니다.\u003c/p\u003e\n\u003cp\u003e변수 요소에 주의해주세요. 실제로, 요소 변수를 리스트 내포 밖에서 정의했지만, 그것은 로컬 상수로 리스트 내포에 로드될 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_9.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e위의 바이트 코드에서. 변수 factor를 모든 루프에서 전역 변수로 로드해야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_10.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e그러나 리스트 컴프리헨션에서는 컴파일러가 factor의 값을 변경할 수 없는 상수로 로드하고 지역 범위에 유지해도 충분히 안전합니다. 따라서 전역 네임스페이스에서 변수를 검색할 필요가 없습니다.\u003c/p\u003e\n\u003cp\u003e물론, 이것은 리스트 컴프리헨션의 성능에 기여하는 다른 요소입니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e3. 일반 메소드 vs 최적화된 메소드\u003c/h1\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_11.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e또 다른 주요한 차이점은 append() 메소드에서 나타납니다. 두 가지 구현 방법의 단계를 보여드리겠습니다.\u003c/p\u003e\n\u003cp\u003efor 루프 버전에서:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003eLOAD_METHOD은 리스트 객체 결과에서 append() 메서드를 로드합니다.\u003c/li\u003e\n\u003cli\u003eLOAD_NAME은 변수 i를 로드합니다.\u003c/li\u003e\n\u003cli\u003eLOAD_NAME은 변수 factor를 로드합니다.\u003c/li\u003e\n\u003cli\u003eBINARY_MULTIPLY는 수학 연산을 수행합니다.\u003c/li\u003e\n\u003cli\u003eCALL_METHOD은 append() 메서드를 호출하여 실행하고, 즉 결과를 결과 목록에 추가합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e리스트 컴프리헨션 버전에서:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eLOAD_FAST는 로컬 변수에서 변수 i를 로드합니다.\u003c/li\u003e\n\u003cli\u003eLOAD_CONST는 변수 factor의 값인 상수 2를 로드합니다.\u003c/li\u003e\n\u003cli\u003eBINARY_MULTIPLY는 수학 연산을 수행합니다.\u003c/li\u003e\n\u003cli\u003eLIST_APPEND는 결과를 로컬 변수에서도 있는 목록에 추가합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e리스트 컴프리헨션 버전의 성능이 더 우수한 이유는 단순히 한 단계가 덜 있기 때문만이 아니라 내부적인 메커니즘 때문입니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003eLOAD_METHOD과 LIST_APPEND가 왜 다른가요?\u003c/h2\u003e\n\u003cp\u003e우리는 결과 목록에서 append() 메서드를 호출합니다. 즉, results.append(...)입니다. 이를 실행할 때 Python 런타임은 List 객체 공간에서 메서드를 찾아야 합니다. 이는 객체에 대해 dir() 메서드를 호출하는 것과 거의 동일합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003edir\u003c/span\u003e(results));\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_12.png\"\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e당연히 이 \"검색\" 작업은 모든 루프에서 발생할 것입니다.\u003c/p\u003e\n\u003cp\u003e그러나 리스트 내포 버전에서 결과 리스트도 로컬 변수입니다. 이 메커니즘은 리스트가 생성될 것이고, 리스트 내포 실행과 함께 만들어진다는 것입니다.\u003c/p\u003e\n\u003cp\u003e비유를 들어보겠습니다. 작은 항목을 큰 컨테이너에 정리하는 것으로 상상해 보겠습니다.\u003c/p\u003e\n\u003cp\u003efor 루프 버전은 append() 메서드를 사용하는 것이 매번 우리가 항목과 상자를 다른 사람에게 주고, 이 사람이 항목을 넣은 후에 우리에게 컨테이너를 다시 돌려주는 것처럼합니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e리스트 내포 버전을 사용하면 다른 사람의 도움 없이 항목을 컨테이너에 넣을 수 있어요. 따라서 성능도 훨씬 좋아요.\u003c/p\u003e\n\u003ch1\u003e4. 리스트 내포를 사용해서는 안 되는 경우\u003c/h1\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_13.png\" alt=\"Python List Comprehension\"\u003e\u003c/p\u003e\n\u003cp\u003e물론, 리스트 내포는 남용해서는 안 돼요. 다시 말해, 사용은 가능하지만 특정 상황에서는 사용해서는 안 되는 경우가 있어요.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e한 가지 전형적인 시나리오는 필터 조건이 너무 복잡하다는 것입니다. 다음 예를 고려해보세요. 학생들의 이름과 시험 점수가 들어있는 튜플 목록이 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003estudents = [(\u003cspan class=\"hljs-string\"\u003e\"Alice\"\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e85\u003c/span\u003e), (\u003cspan class=\"hljs-string\"\u003e\"Bob\"\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e95\u003c/span\u003e), (\u003cspan class=\"hljs-string\"\u003e\"Cindy\"\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e), (\u003cspan class=\"hljs-string\"\u003e\"David\"\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e65\u003c/span\u003e), (\u003cspan class=\"hljs-string\"\u003e\"Eva\"\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e70\u003c/span\u003e)];\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그런 다음, 특정 조건에 따라 이름을 필터링하려고 합니다. 점수는 80보다 커야하고, 이름은 \"A\" 또는 \"C\"로 시작해야 합니다. 아래는 for 루프 구현입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efiltered_names = []\n\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e name, score \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estudents\u003c/span\u003e:\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e score \u003e \u003cspan class=\"hljs-number\"\u003e80\u003c/span\u003e and name.\u003cspan class=\"hljs-title function_\"\u003estartswith\u003c/span\u003e((\u003cspan class=\"hljs-string\"\u003e\"A\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"C\"\u003c/span\u003e)):\n        filtered_names.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e(name)\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e여기에 리스트 컴프리헨션 구현방법이 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efiltered_names = [name \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e name, score \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e students \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e score \u003e \u003cspan class=\"hljs-number\"\u003e80\u003c/span\u003e and name.\u003cspan class=\"hljs-title function_\"\u003estartswith\u003c/span\u003e((\u003cspan class=\"hljs-string\"\u003e\"A\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"C\"\u003c/span\u003e))]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_14.png\"\u003e\n\u003cp\u003e음, 리스트 컴프리헨션의 성능은 여전히 for 루프보다 조금 더 나은 편이에요. 그러나 복잡한 조건 때문에 리스트 컴프리헨션은 가독성이 많이 떨어지기 시작했다고 말씀드려야 할 것 같아요.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e가독성과 디버깅 유연성을 희생해서 성능을 조금 향상시키는 것이 매우 주관적일 수 있습니다. 결정은 여러분에게 맡기겠습니다. :)\u003c/p\u003e\n\u003ch1\u003e요약\u003c/h1\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar_15.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e이 글에서는 리스트 컴프리헨션의 성능이 일반 for-loop보다 우수한 이유에 대해 소개했습니다. 그것이 단순히 구문적인 설탕이 아니라 성능 최적화임을 증명했습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e두 구현의 바이트 코드를 표시하여 증거가 발굴되었습니다. 주요 차이점은 지역 vs. 전역 네임스페이스와 일반 메서드 vs. 최적화된 메서드입니다.\u003c/p\u003e\n\u003cp\u003e물론, 모든 시나리오에서 리스트 내포를 사용하는 것이 권장되지는 않습니다. 예를 들어, 조건이 매우 많은 계층과 보다 복잡한 조건을 갖는 경우입니다. 여전히 리스트 내포를 사용할 가치가 있는지 고려해야 합니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-07-09-PythonListComprehensionIsNotJustSyntacticSugar"},"buildId":"71zJMhK9mFbQV7s02rMGq","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>