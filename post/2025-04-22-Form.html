<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Next.js 15에서 폼(Form) 쉽게 만드는 방법 | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-Form" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Next.js 15에서 폼(Form) 쉽게 만드는 방법 | TIL" data-gatsby-head="true"/><meta property="og:title" content="Next.js 15에서 폼(Form) 쉽게 만드는 방법 | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-Form" data-gatsby-head="true"/><meta name="twitter:title" content="Next.js 15에서 폼(Form) 쉽게 만드는 방법 | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2025-04-22 02:18" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/0eef537492fed77a.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/0eef537492fed77a.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/post/%5Bslug%5D-8ded8b979ba73586.js" defer=""></script><script src="/TIL/_next/static/olPs1cVezSGTqD7OaewDI/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/olPs1cVezSGTqD7OaewDI/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Next.js 15에서 폼(Form) 쉽게 만드는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Next.js 15에서 폼(Form) 쉽게 만드는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Apr 22, 2025</span><span class="posts_reading_time__f7YPP">17<!-- --> min read</span></span></div></div></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h1>Form 컴포넌트 소개</h1>
<p><code>Form</code> 컴포넌트는 HTML의 기본 <code>form</code> 요소를 확장한 거예요. 이걸 사용하면 로딩 UI 미리 불러오기(prefetch), 제출 시 클라이언트 사이드에서 페이지 이동, 그리고 점진적 향상(progressive enhancement) 같은 기능을 쉽게 구현할 수 있답니다.</p>
<p>특히, URL 검색 파라미터(search params)를 업데이트하는 폼에서 유용해요. 기존에 이런 작업 하면서 번거롭게 작성하던 코드량을 훨씬 줄여주거든요.</p>
<p>간단한 기본 사용법은 다음과 같아요:</p>
<pre><code class="hljs language-jsx">&#x3C;<span class="hljs-title class_">Form</span> method=<span class="hljs-string">"get"</span> action=<span class="hljs-string">"/search"</span>>
  <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"query"</span> /></span></span>
  <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>></span>Search<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span></span>
&#x3C;/<span class="hljs-title class_">Form</span>>
</code></pre>
<hr>
<h3>덧붙일 내용 - 왜 점진적 향상인가?</h3>
<p>점진적 향상(Progressive Enhancement)이란 말 그대로 웹 기능을 기본 HTML에서도 사용 가능하면서, 자바스크립트를 지원하는 환경에서는 더 나은 경험을 제공하는 걸 의미해요.<br>
<code>Form</code> 컴포넌트를 쓰면 이렇게 기본 HTML 폼 기능을 유지하면서도, JavaScript가 활성화된 환경에서는 더 빠르고 매끄러운 네비게이션이 가능하죠.</p>
<p>또한, 네트워크 상태가 좋지 않은 경우에도 기본 폼 기능 덕분에 최소한의 작동은 보장되니, 사용자 경험을 꽤나 챙길 수 있어요.</p>
<p><code>Form</code>과 비슷한 개념으로는 React의 <code>react-router</code> 라이브러리나 Next.js의 <code>next/link</code> 같은 것들이 있는데, 이 컴포넌트는 좀 더 폼 제출에 특화되어 있다고 보면 됩니다!</p>
<p>필요한 상황에 맞게 잘 활용해 보세요. 폼 제출 시 사용자 경험을 한층 개선해 줄 거예요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이번 글에서는 Next.js의 <code>Form</code> 컴포넌트 사용법에 대해 다뤄볼게요. 예제를 보면서 설명할게요.</p>
<pre><code class="hljs language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Form</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'next/form'</span>
 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/search"</span>></span>
      {/* 제출 시, 입력값이 URL에 쿼리 파라미터로 붙어요. 예: /search?query=abc */}
      <span class="hljs-tag">&#x3C;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"query"</span> /></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>></span>Submit<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">Form</span>></span></span>
  )
}
</code></pre>
<h3>이 코드가 하는 일?</h3>
<p><code>Form</code> 컴포넌트에 <code>action="/search"</code> 처럼 문자열 형태로 <code>action</code>을 넘기면, 기본적으로 HTML 폼이 GET 방식으로 데이터를 보내는 방식과 유사해요. 사용자가 입력한 값(여기선 <code>query</code> input 값)이 URL 쿼리 스트링으로 추가되고, <code>/search?query=입력값</code> 형태로 이동하죠.</p>
<hr>
<h3>근데 여기서 Next.js가 특별한 점은?</h3>

















<table><thead><tr><th>특징</th><th>설명</th></tr></thead><tbody><tr><td>미리 불러오기(Prefetch)</td><td>폼이 화면에 나타나면 지정한 경로(<code>/search</code>)를 미리 불러와서 페이지 전환이 훨씬 빨라져요. 이때 레이아웃이나 로딩 컴포넌트 같은 공유 UI도 함께 미리 준비돼요.</td></tr><tr><td>클라이언트 사이드 내비게이션</td><td>폼을 제출했을 때, 페이지가 전체 새로고침 되지 않고 SPA처럼 클라이언트 사이드에서 경로가 바뀌어요. 덕분에 공유 UI가 유지되고, 유저 인터페이스가 더 부드럽게 느껴집니다.</td></tr></tbody></table>
<hr>
<h3>참고! <code>action</code>에 함수 넣으면?</h3>
<p><code>Form</code>의 <code>action</code> 프로퍼티에 서버 액션(Server Action) 함수를 전달하면, 제출 시 해당 함수가 실행돼요. 완전히 React 방식으로 동작하는 거죠. 서버에서 데이터를 처리하거나 검증하는 등의 작업을 손쉽게 구현할 수 있습니다.</p>
<hr>
<h3>추가 팁!</h3>
<ul>
<li>기존 HTML <code>&#x3C;form></code>과 거의 비슷하게 동작하니까, 폼을 처음 접하는 사람도 금방 적응할 수 있어요.</li>
<li>Next.js는 <code>Form</code>과 라우팅 시스템을 잘 조합해서 SPA와 SSR의 장점을 살렸답니다!</li>
<li>만약 POST 방식으로 데이터를 보내고 싶다면, <code>action</code>에 서버 함수를 사용하는 게 좋고, 더 복잡한 API 호출도 쉽게 처리 가능해요.</li>
</ul>
<hr>
<p>요약하자면, Next.js의 <code>Form</code> 컴포넌트를 이용하면 편하게 폼을 작성하면서도, 빠른 페이지 전환과 클라이언트 상태 유지를 누릴 수 있어요. 상황에 따라 <code>action</code>에 문자열 URL을 주거나 서버 함수로 처리하는 전략을 골라 쓰시면 됩니다!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h3>action (문자열) Props</h3>
<p><code>Form</code> 컴포넌트에서 <code>action</code>이 문자열일 때 지원하는 props를 살펴볼게요.</p>



































<table><thead><tr><th>Prop</th><th>예시</th><th>타입</th><th>필수 여부</th></tr></thead><tbody><tr><td><code>action</code></td><td><code>action="/search"</code></td><td><code>string</code> (URL 또는 상대 경로)</td><td>필수</td></tr><tr><td><code>replace</code></td><td><code>replace={false}</code></td><td><code>boolean</code></td><td>선택</td></tr><tr><td><code>scroll</code></td><td><code>scroll={true}</code></td><td><code>boolean</code></td><td>선택</td></tr><tr><td><code>prefetch</code></td><td><code>prefetch={true}</code></td><td><code>boolean</code></td><td>선택</td></tr></tbody></table>
<ul>
<li>
<p><strong>action</strong>: 폼이 제출됐을 때 이동할 URL 혹은 경로를 지정해줘요.<br>
만약 빈 문자열 <code>""</code>로 설정하면, 현재 경로에서 검색 파라미터만 업데이트해서 이동해요.<br>
예를 들어, 검색 기능이 있는 페이지에서 검색어만 바뀔 때 유용하겠죠?</p>
</li>
<li>
<p><strong>replace</strong>: 기본값은 <code>false</code>예요.<br>
브라우저의 기록(history) 스택에 새 항목을 추가할지 말지 결정하는데요,<br>
만약 <code>true</code>라면 기존 기록을 새 기록으로 <em>교체</em>합니다.<br>
뒤로 가기 버튼을 눌렀을 때 이전 페이지로 돌아가지 않게 하려면 이걸 켜면 돼요.</p>
</li>
<li>
<p><strong>scroll</strong>: 기본값은 <code>true</code>이고, 탐색 시 스크롤 동작을 조절해요.<br>
<code>true</code>면 새 페이지로 이동할 때 스크롤을 맨 위로 올리고, 뒤로/앞으로 가기 시에는 스크롤 위치를 유지해 줘요.<br>
만약 원하는 스크롤 위치가 있다면 <code>false</code>로 설정하고 직접 관리할 수도 있답니다.</p>
</li>
<li>
<p><strong>prefetch</strong>: 기본값은 <code>true</code>로,<br>
폼이 화면에 보이면 해당 경로를 미리 불러와서(pre-fetch) 빠르게 전환할 수 있게 도와줘요.<br>
네트워크 트래픽이나 자원 절약을 원한다면 이 옵션을 꺼도 됩니다.</p>
</li>
</ul>
<hr>
<p>이렇게 각 prop을 잘 활용하면, 단순한 폼 제출 이상의 사용자 경험을 만들 수 있어요.<br>
특히 SPA(싱글 페이지 애플리케이션) 개발 시, 이 props들은 라우팅과 렌더링 방식에 큰 영향을 줍니다.</p>
<p>추가 팁으로, <code>action=""</code>을 쓰면 URL 파라미터만 바꾸기 때문에<br>
검색 페이지나 필터링 기능 구현 시 유용하니 꼭 기억해 두세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h3>action (함수) Props</h3>
<p><code>action</code>이 함수일 때, <code>Form</code> 컴포넌트는 다음과 같은 prop을 지원합니다:</p>

















<table><thead><tr><th>Prop</th><th>예시</th><th>타입</th><th>필수 여부</th></tr></thead><tbody><tr><td>action</td><td><code>action={myAction}</code></td><td><code>function</code> (서버 액션 함수)</td><td>필수</td></tr></tbody></table>
<ul>
<li><strong>action</strong>: 사용자가 폼을 제출할 때 호출되는 서버 액션 함수입니다. React 문서를 참고하면 더 자세한 정보를 얻을 수 있어요.</li>
</ul>
<hr>
<p>여기서 잠깐! <code>action</code>이 서버 액션 함수라는 점에서 조금 독특한데요. 보통 폼 제출은 클라이언트 사이드에서 처리하거나, API 호출을 통해 이루어지곤 하죠. 그런데 React Server Components 환경에서는 서버에서 직접 실행되는 함수 형태로 액션을 정의할 수도 있답니다. 덕분에 클라이언트와 서버 간 데이터 처리 로직 구분이 깔끔해지고, 성능 최적화에도 도움이 돼요.</p>
<p>혹시 익숙하지 않은분은 "서버 액션"이 뭔지 한 번 찾아보고, React 공식 문서에서 관련 예제를 보면 이해가 금방 될 거예요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>좋은 정보 한 가지! action이 함수일 때는 replace와 scroll 속성들이 무시된다는 점 기억하세요.</p>
<h3>주의할 점들</h3>





























<table><thead><tr><th>항목</th><th>설명</th></tr></thead><tbody><tr><td><strong>formAction</strong></td><td><code>button</code>이나 <code>input type="submit"</code>에서 action 속성을 덮어쓸 수 있어요. Next.js는 클라이언트 사이드 네비게이션을 수행하지만, 이 방법은 prefetch(선불러오기)를 지원하지 않는다는 점 참고하세요. 그리고 basePath를 사용한다면 반드시 formAction 경로에 basePath를 포함시켜야 합니다. 예) <code>formAction="/base-path/search"</code></td></tr><tr><td><strong>key</strong></td><td>문자열 형태의 action에 key prop을 넘기는 건 지원되지 않습니다. 만약 리렌더링이나 뮤테이션을 트리거하고 싶으면 함수형 action을 사용하세요.</td></tr><tr><td><strong>onSubmit</strong></td><td>폼 제출 로직을 처리할 때 사용 가능하지만, 만약 <code>event.preventDefault()</code>를 호출하면 Next.js <code>Form</code>의 기본 동작(즉 URL로 네비게이션)이 무시됩니다.</td></tr><tr><td><strong>method, encType, target</strong></td><td>이 속성들은 <code>Form</code>의 기본 동작을 오버라이드하기 때문에 지원되지 않아요. 대신에 <code>formMethod</code>, <code>formEncType</code>, <code>formTarget</code> 속성을 써서 각각 method, encType, target을 덮어쓸 수 있긴 하지만 이 경우엔 네이티브 브라우저 동작으로 fallback됩니다. 이들 기능을 꼭 사용해야 한다면 Next.js <code>Form</code> 대신 HTML <code>form</code> 태그를 사용하는 게 좋아요.</td></tr><tr><td><strong>input type="file"</strong></td><td>action이 문자열일 때 이 타입의 input은 브라우저 동작과 동일하게 파일 객체 대신 파일명만 제출됩니다.</td></tr></tbody></table>
<hr>
<p>사실 Next.js의 <code>Form</code> 컴포넌트를 사용할 때 이런 제약사항들을 미리 알고 있으면 개발할 때 헷갈리는 부분이 줄어요. 특히 prefetch가 안 되거나, 리렌더링 이슈가 생겼을 때는 "혹시 action을 문자열로 쓰고 key를 넘긴 건 아닌가?" 하고 한번 점검해보세요.</p>
<p>더불어 파일 업로드 처리는 Next.js 내장 <code>Form</code> 컴포넌트로 하기엔 제약이 있으니, 이럴 땐 기존 HTML <code>form</code> 태그와 서버 API를 직접 연결하는 방식이 안전합니다.</p>
<p>이런 점들을 잘 기억해두시면 Next.js의 폼 처리 방식을 더욱 능숙하게 사용할 수 있을 거예요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>예제</h2>
<h3>검색 결과 페이지로 이동하는 검색 폼 만들기</h3>
<p>검색 결과 페이지로 이동하는 폼을 만들고 싶다면, <code>action</code> 속성에 결과 페이지 경로를 넣어주면 됩니다. 예를 들어, <code>/search</code> 경로로 이동하도록 설정하면 사용자가 폼을 제출할 때 검색어가 쿼리 파라미터로 붙어서 해당 페이지로 넘어가죠.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Form</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'next/form'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/search"</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"query"</span> /></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>></span>Submit<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">Form</span>></span></span>
  )
}
</code></pre>
<p>여기서 중요한 점은 <code>input</code>에 반드시 <code>name</code> 속성을 주어야 폼 데이터를 제대로 전달할 수 있다는 거예요. <code>name="query"</code>로 지정한 검색어가 <code>/search?query=검색어</code> 형태로 넘어가게 됩니다.</p>
<p>그리고, <code>Form</code> 컴포넌트는 Next.js의 새로운 폼 처리 방식을 따르는 컴포넌트인데요, 내부적으로 기본 HTML <code>&#x3C;form></code> 태그와 유사하게 동작하지만 Next.js 특성에 맞게 최적화되어 있어요. 만약 Next.js 버전에 따라 <code>Form</code> 컴포넌트가 제공되지 않는 경우에는 기본 <code>&#x3C;form></code> 태그를 사용하셔도 무방해요.</p>
<p>마지막으로 조금 더 사용자 친화적으로 만들고 싶다면, 입력 필드에 <code>placeholder</code>를 넣어주거나, 버튼에 좀 더 직관적인 텍스트를 넣는 것도 추천드려요!</p>
<pre><code class="hljs language-js">&#x3C;<span class="hljs-title class_">Form</span> action=<span class="hljs-string">"/search"</span>>
  <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"query"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"검색어를 입력하세요"</span> /></span></span>
  <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>></span>검색<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span></span>
&#x3C;/<span class="hljs-title class_">Form</span>>
</code></pre>
<p>이렇게 하면 검색 폼이 더 완성도 있게 보이겠죠? 간단하지만 기본적인 검색 기능을 구현할 때 유용한 방법입니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>사용자가 검색어 입력 필드에 값을 넣고 폼을 제출하면, 폼 데이터가 URL의 쿼리 파라미터로 인코딩돼서 <code>/search?query=abc</code> 같은 형식으로 이동하게 돼요.</p>
<blockquote>
<p>참고로, action 속성에 빈 문자열 <code>""</code>을 넣으면, 같은 경로로 이동하면서 쿼리 파라미터만 업데이트할 수 있다는 점도 알아두면 좋아요.</p>
</blockquote>
<p>검색 결과 페이지에서는 <code>searchParams</code>라는 <code>page.js</code>의 prop을 통해 쿼리 값을 받아올 수 있고, 이를 이용해 외부 API에서 데이터를 불러오는 식으로 활용할 수 있답니다.</p>
<p>아래 예제를 살펴볼게요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { getSearchResults } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/lib/search'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">SearchPage</span>(<span class="hljs-params">{
  searchParams,
}: {
  searchParams: <span class="hljs-built_in">Promise</span>&#x3C;{ [key: string]: string | string[] | <span class="hljs-literal">undefined</span> }>
}</span>) {
  <span class="hljs-comment">// searchParams는 Promise 형태라 await을 해줘야 쿼리 값을 받을 수 있어요</span>
  <span class="hljs-keyword">const</span> results = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getSearchResults</span>((<span class="hljs-keyword">await</span> searchParams).<span class="hljs-property">query</span>)

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>...<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
}
</code></pre>
<blockquote>
<p>여기서 한 가지 팁을 드리자면, <code>searchParams</code>가 Promise라는 점 때문에 async/await을 꼭 처리해줘야 해요. 깜빡하면 값이 제대로 안 들어와서 당황할 수 있답니다.</p>
</blockquote>
<p>정리하자면, 이 방법은 서버사이드 렌더링 환경에서 검색어에 따라 동적인 데이터를 불러오기 아주 편리한 방식이에요. React 컴포넌트에서 직접 URL 쿼리 파라미터를 읽어서 비동기 데이터 요청을 쉽게 처리할 수 있거든요.</p>
<p>만약 사용자가 계속 검색어를 바꾸면서 결과를 보고 싶다면, 이 패턴을 잘 응용하면 굉장히 깔끔한 페이지 구성이 가능하니 꼭 기억해두세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><code>Form</code>이 사용자의 화면에 보이기 시작하면, <code>/search</code> 페이지에 있는 공통 UI(예를 들어 layout.js나 loading.js) 리소스가 미리 불러와집니다(prefetch). 그리고 폼이 제출되면 바로 새로운 경로로 이동하면서, 결과가 로딩되는 동안에는 로딩 UI가 보여집니다. 이렇게 로딩 UI를 설계하려면 loading.js를 사용하면 되는데, 간단한 예시는 다음과 같아요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Loading</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>Loading...<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
}
</code></pre>
<p>그런데 여기서 한 가지 더 신경 써야 할 점은, 혹시 공통 UI가 아직 완전히 로드되지 않은 상태에서는 사용자가 답답함을 느낄 수 있다는 거예요. 이런 경우를 대비해서 <code>useFormStatus</code> 훅을 활용해서 즉각적인 피드백을 줄 수 있습니다.</p>
<p>자, 그러면 제출이 진행 중일 때 로딩 상태를 보여주는 컴포넌트를 하나 만들어볼게요. 이 컴포넌트는 사용자가 폼을 제출해서 결과를 기다릴 때 뭔가 진행 중임을 보여줘서 사용자 경험을 더 매끄럽게 만들어줍니다.</p>
<pre><code class="hljs language-js"><span class="hljs-string">'use client'</span>

<span class="hljs-keyword">import</span> { useFormStatus } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">FormProgress</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> { pending } = <span class="hljs-title function_">useFormStatus</span>()

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
      {pending ? '폼 제출 중...' : null}
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  )
}
</code></pre>
<p>여기서 <code>useFormStatus</code>는 React Server Components 환경에서 폼 제출 상태(예: 대기중인지 여부)를 추적할 수 있게 도와주는 훅이에요. <code>pending</code>이 <code>true</code>일 때는 폼이 제출 중임을 의미하죠.</p>
<hr>
<h3>추가 팁 - 이런 경우에 쓰면 좋아요!</h3>
<ul>
<li>사용자가 버튼을 여러 번 반복해서 누르는 걸 방지하고 싶을 때</li>
<li>네트워크가 느려서 서버 응답 시간이 긴 경우 진행 상태를 명확히 보여주고 싶을 때</li>
<li>전체 페이지가 아닌 일부 컴포넌트에만 로딩 표시를 제한하고 싶을 때</li>
</ul>
<hr>
<h3>요약</h3>
<ul>
<li><code>Form</code>이 화면에 보이면 <code>/search</code> 페이지의 공통 UI 리소스를 미리 받아서 빠르게 렌더링 가능</li>
<li>폼 제출 시 로딩 UI(loading.js)로 사용자 피드백 제공</li>
<li><code>useFormStatus</code> 훅을 이용해 폼 제출이 진행 중인 상태를 감지하고 즉각적으로 사용자에게 알려줄 수 있음</li>
</ul>
<p>이렇게 하면 사용자 경험이 훨씬 부드러워지고, 로딩중임을 확실히 인지시켜줘서 UX가 좋아지겠죠? 다음에도 이런 React Server Components 관련 내용 자주 알려드릴게요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이번에는 React(특히 Next.js)에서 서버 액션(Server Actions)을 활용한 폼과 버튼 구현 예제를 함께 살펴볼게요.</p>
<hr>
<p>먼저, <code>SearchButton</code> 컴포넌트를 보시면, <code>useFormStatus</code> 훅을 활용해서 폼이 제출 중인지 아닌지 상태를 확인하고 있죠.</p>
<pre><code class="hljs language-jsx"><span class="hljs-string">'use client'</span>
<span class="hljs-keyword">import</span> { useFormStatus } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>
 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">SearchButton</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> status = <span class="hljs-title function_">useFormStatus</span>()
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>></span>{status.pending ? 'Searching...' : 'Search'}<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span></span>
  )
}
</code></pre>
<ul>
<li><code>useFormStatus</code>는 폼 제출 상태를 받아와서, 제출이 진행 중일 때는 버튼 텍스트를 'Searching...'으로, 그렇지 않을 때는 'Search'로 바꾸어 줘요.</li>
<li>그리고 <code>use client</code> 지시자는 이 컴포넌트가 클라이언트 컴포넌트임을 Next.js에 알려줍니다. 서버 컴포넌트와 클라이언트 컴포넌트를 적절히 분리해서 사용하는 것이 Next.js 13에서 중요한 포인트입니다.</li>
</ul>
<hr>
<p>그 다음, 실제 검색 폼 페이지 코드를 보면 이렇게 돼있어요.</p>
<pre><code class="hljs language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Form</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'next/form'</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">SearchButton</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/ui/search-button'</span>
 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/search"</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"query"</span> /></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">SearchButton</span> /></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">Form</span>></span></span>
  )
}
</code></pre>
<ul>
<li>여기서는 <code>next/form</code> 라이브러리에서 가져온 <code>Form</code> 컴포넌트를 사용하고 있네요.</li>
<li><code>Form</code> 컴포넌트에 <code>action</code>으로 <code>/search</code>를 넘겨서, 제출하면 해당 서버 액션이 실행될 거예요.</li>
<li>그리고 <code>SearchButton</code>을 넣어서 폼 제출 시 상태가 표시되도록 했죠.</li>
</ul>
<hr>
<h3>Server Actions란?</h3>
<p>Next.js 13부터 도입된 서버 액션 기능은 클라이언트에서 서버 함수를 직접 호출하듯 코드를 작성할 수 있게 해 줍니다. 기존에는 API 라우트로 POST 요청 보내고 응답 받는 과정이 필요했다면, 서버 액션을 사용하면 그 과정을 훨씬 간편하게 만들 수 있죠.</p>
<p>이번 예제의 핵심은:</p>
<ul>
<li>클라이언트에서 폼 제출 시 <code>Form</code> 컴포넌트가 서버 액션을 호출한다.</li>
<li>서버 액션 실행 중일 때 버튼 상태(<code>Searching...</code>)를 통해 사용자가 인지할 수 있다.</li>
</ul>
<hr>
<h3>더 알아두면 좋은 팁들!</h3>

























<table><thead><tr><th>내용</th><th>설명</th></tr></thead><tbody><tr><td><code>useFormStatus</code></td><td>폼 제출 상태를 알 수 있어 UI에 반영하기 좋아요.</td></tr><tr><td>클라이언트 컴포넌트</td><td>상태를 관리할 버튼 등 인터랙티브한 부분은 클라이언트 컴포넌트로 작성해야 해요.</td></tr><tr><td><code>Form</code> 컴포넌트</td><td>기존 폼 태그를 대체하면서 서버 액션과 자연스럽게 연동됩니다.</td></tr><tr><td>서버 액션 개발</td><td>서버에서 실행되는 함수이므로 보안이 중요한 로직을 담기 좋아요.</td></tr></tbody></table>
<hr>
<h3>마치며</h3>
<p>이번에 소개한 <code>useFormStatus</code>와 <code>Form</code> 컴포넌트를 활용하면 서버 액션과 클라이언트 상태를 아주 깔끔하게 관리할 수 있어요. Next.js 13의 서버 액션 기능은 단순한 API 통신보다 훨씬 직관적이고 강력한 도구니 꼭 한번 적용해 보고, 더 넓은 가능성을 찾아보길 추천해요!</p>
<p>필요하면 서버 액션 만드는 방법과 연동하는 예제도 함께 공유할 테니, 관심 있으면 알려 주세요 :)</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이번에 Next.js에서 <code>Form</code> 태그를 활용하는 방법을 살펴봤어요. 그냥 <code>&#x3C;form></code> 태그 대신 <code>Form</code> 컴포넌트를 쓰면, mutation(데이터 변경 작업)을 할 때 간편하게 액션 함수를 넘겨줄 수 있답니다.</p>
<pre><code class="hljs language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Form</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'next/form'</span>
<span class="hljs-keyword">import</span> { createPost } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/posts/actions'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">{createPost}</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"title"</span> /></span>
      {/* ... */}
      <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>></span>Create Post<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">Form</span>></span></span>
  )
}
</code></pre>
<p>여기서 <code>createPost</code>는 서버 사이드에서 실행되는 함수로, 폼에 제출된 데이터를 받아 글을 생성하는 역할을 하죠. 이렇게 함수 형태로 액션을 넘기면, 폼 제출 시 자동으로 해당 함수가 호출됩니다.</p>
<p>그리고 글이 만들어지고 나서 보통 새 글 페이지로 리다이렉트 하고 싶은 경우가 많잖아요? 이럴 땐 Next.js의 <code>next/navigation</code> 모듈에 있는 <code>redirect</code> 함수를 사용하면 돼요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { redirect } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/navigation'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createPost</span>(<span class="hljs-params">formData</span>) {
  <span class="hljs-keyword">const</span> post = <span class="hljs-keyword">await</span> <span class="hljs-title function_">createPostInDB</span>(formData);
  <span class="hljs-title function_">redirect</span>(<span class="hljs-string">`/posts/<span class="hljs-subst">${post.id}</span>`</span>);
}
</code></pre>
<p>여기서 주의할 점은요, 폼이 제출된 후에 액션 함수가 실행되기 때문에, 이 때까지 어디로 리다이렉트할지 모릅니다. 그래서 <code>Form</code> 컴포넌트는 자동으로 어떤 UI를 미리 불러오거나(prefetch) 준비하는 기능이 없어요. 즉, 네비게이션이 동적인 상황이라 미리 준비하지 않는다는 뜻입니다.</p>
<hr>
<h3>참고로 알아두면 좋은 점</h3>
<ul>
<li><code>Form</code> 컴포넌트를 사용하면 서버 액션을 쉽고 깔끔하게 연결할 수 있어요.</li>
<li>꼭 <code>redirect</code>를 사용해서 리다이렉션을 처리해야 하고, 클라이언트에서 직접 네비게이션을 하지 않는 게 좋습니다.</li>
<li>서버 사이드 액션 함수 안에서는 보통 데이터베이스 작업이나 외부 API 호출 같은 일을 처리합니다.</li>
<li>사용자가 제출한 데이터는 <code>formData</code> 형태로 받게 되며, 이걸 활용해 원하는 작업을 하면 됩니다.</li>
</ul>
<p>Next.js 13 초기 버전과 비교하면 정말 좋아진 점 중 하나가 이런 서버 액션과 클라이언트가 자연스럽게 연동된다는 거예요. 개발할 때 훨씬 깔끔하고 안정적으로 만들어서 추천해요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>요즘 Next.js에서 서버 액션(Server Actions)을 활용하는 방법을 공부하고 있는데, 간단하게 정리해볼게요. 서버 액션을 쓰면 서버에서 데이터를 처리하고 그 결과에 따라 바로 리다이렉트도 쉽게 할 수 있어서 편리하답니다.</p>
<p>우선, 새 글을 만드는 <code>createPost</code> 서버 액션 함수부터 볼게요:</p>
<pre><code class="hljs language-js"><span class="hljs-string">'use server'</span>
<span class="hljs-keyword">import</span> { redirect } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/navigation'</span>
 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createPost</span>(<span class="hljs-params">formData: FormData</span>) {
  <span class="hljs-comment">// 새로운 글 생성 로직이 여기 들어가겠죠?</span>
  <span class="hljs-comment">// 예를 들어 DB에 저장하거나 API를 호출하고...</span>
 
  <span class="hljs-comment">// 새 글의 ID를 받아왔다고 가정</span>
  <span class="hljs-title function_">redirect</span>(<span class="hljs-string">`/posts/<span class="hljs-subst">${data.id}</span>`</span>)  <span class="hljs-comment">// 생성 완료 후 새 글 페이지로 이동</span>
}
</code></pre>
<p>여기서 'use server' 지시어는 이 함수가 서버에서만 실행된다는 뜻이고, <code>redirect</code> 함수로 새로운 글 페이지로 이동할 수 있어요. 클라이언트에서 별도의 처리 없이 서버에서 바로 리다이렉트되는 점이 신기하죠?</p>
<p>그리고 새 글 페이지 컴포넌트에서는 <code>params</code>를 받아서 해당 글 데이터를 불러옵니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { getPost } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/posts/data'</span>
 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">PostPage</span>(<span class="hljs-params">{
  params,
}: {
  params: <span class="hljs-built_in">Promise</span>&#x3C;{ id: string }>
}</span>) {
  <span class="hljs-keyword">const</span> { id } = <span class="hljs-keyword">await</span> params
  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getPost</span>(id) <span class="hljs-comment">// 서버에서 글 데이터 가져오기</span>
 
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">h1</span>></span>{data.title}<span class="hljs-tag">&#x3C;/<span class="hljs-name">h1</span>></span>
      {/* 글 내용이나 댓글 등 추가 정보 표시 가능 */}
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  )
}
</code></pre>
<p>여기서 <code>params</code>가 프로미스로 되어있는 게 좀 특이한데, 이게 Next.js의 새로운 동적 라우팅 방식 때문이에요. 비동기로 params를 받아서 바로 데이터를 fetch할 수 있답니다.</p>
<p>덧붙여서, Server Actions은 Next.js 13에서 소개된 기능이고, 기존에 API 라우트를 따로 만들지 않아도 서버 코드를 컴포넌트 안에서 선언해서 사용할 수 있어 개발 생산성을 높여줘요.</p>
<p>더 다양한 예제와 활용 팁은 <a href="https://nextjs.org/docs/app/building-your-application/routing/server-actions" rel="nofollow" target="_blank">서버 액션 공식 문서</a>에서 확인해보세요! 한번 익숙해지면 클라이언트-서버 데이터 흐름이 훨씬 깔끔해져서 추천합니다 :)</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Next.js 15에서 폼(Form) 쉽게 만드는 방법","description":"","date":"2025-04-22 02:18","slug":"2025-04-22-Form","content":"\n\n# Form 컴포넌트 소개\n\n`Form` 컴포넌트는 HTML의 기본 `form` 요소를 확장한 거예요. 이걸 사용하면 로딩 UI 미리 불러오기(prefetch), 제출 시 클라이언트 사이드에서 페이지 이동, 그리고 점진적 향상(progressive enhancement) 같은 기능을 쉽게 구현할 수 있답니다.\n\n특히, URL 검색 파라미터(search params)를 업데이트하는 폼에서 유용해요. 기존에 이런 작업 하면서 번거롭게 작성하던 코드량을 훨씬 줄여주거든요.\n\n간단한 기본 사용법은 다음과 같아요:  \n\n```jsx\n\u003cForm method=\"get\" action=\"/search\"\u003e\n  \u003cinput name=\"query\" /\u003e\n  \u003cbutton type=\"submit\"\u003eSearch\u003c/button\u003e\n\u003c/Form\u003e\n```\n\n---\n\n### 덧붙일 내용 - 왜 점진적 향상인가?\n\n점진적 향상(Progressive Enhancement)이란 말 그대로 웹 기능을 기본 HTML에서도 사용 가능하면서, 자바스크립트를 지원하는 환경에서는 더 나은 경험을 제공하는 걸 의미해요.  \n`Form` 컴포넌트를 쓰면 이렇게 기본 HTML 폼 기능을 유지하면서도, JavaScript가 활성화된 환경에서는 더 빠르고 매끄러운 네비게이션이 가능하죠.\n\n또한, 네트워크 상태가 좋지 않은 경우에도 기본 폼 기능 덕분에 최소한의 작동은 보장되니, 사용자 경험을 꽤나 챙길 수 있어요.  \n\n`Form`과 비슷한 개념으로는 React의 `react-router` 라이브러리나 Next.js의 `next/link` 같은 것들이 있는데, 이 컴포넌트는 좀 더 폼 제출에 특화되어 있다고 보면 됩니다!  \n\n필요한 상황에 맞게 잘 활용해 보세요. 폼 제출 시 사용자 경험을 한층 개선해 줄 거예요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번 글에서는 Next.js의 `Form` 컴포넌트 사용법에 대해 다뤄볼게요. 예제를 보면서 설명할게요.\n\n```jsx\nimport Form from 'next/form'\n \nexport default function Page() {\n  return (\n    \u003cForm action=\"/search\"\u003e\n      {/* 제출 시, 입력값이 URL에 쿼리 파라미터로 붙어요. 예: /search?query=abc */}\n      \u003cinput name=\"query\" /\u003e\n      \u003cbutton type=\"submit\"\u003eSubmit\u003c/button\u003e\n    \u003c/Form\u003e\n  )\n}\n```\n\n### 이 코드가 하는 일?\n\n`Form` 컴포넌트에 `action=\"/search\"` 처럼 문자열 형태로 `action`을 넘기면, 기본적으로 HTML 폼이 GET 방식으로 데이터를 보내는 방식과 유사해요. 사용자가 입력한 값(여기선 `query` input 값)이 URL 쿼리 스트링으로 추가되고, `/search?query=입력값` 형태로 이동하죠.\n\n---\n\n### 근데 여기서 Next.js가 특별한 점은?\n\n| 특징 | 설명 |\n| --- | --- |\n| 미리 불러오기(Prefetch) | 폼이 화면에 나타나면 지정한 경로(`/search`)를 미리 불러와서 페이지 전환이 훨씬 빨라져요. 이때 레이아웃이나 로딩 컴포넌트 같은 공유 UI도 함께 미리 준비돼요. |\n| 클라이언트 사이드 내비게이션 | 폼을 제출했을 때, 페이지가 전체 새로고침 되지 않고 SPA처럼 클라이언트 사이드에서 경로가 바뀌어요. 덕분에 공유 UI가 유지되고, 유저 인터페이스가 더 부드럽게 느껴집니다. |\n\n---\n\n### 참고! `action`에 함수 넣으면?\n\n`Form`의 `action` 프로퍼티에 서버 액션(Server Action) 함수를 전달하면, 제출 시 해당 함수가 실행돼요. 완전히 React 방식으로 동작하는 거죠. 서버에서 데이터를 처리하거나 검증하는 등의 작업을 손쉽게 구현할 수 있습니다.\n\n---\n\n### 추가 팁!\n\n- 기존 HTML `\u003cform\u003e`과 거의 비슷하게 동작하니까, 폼을 처음 접하는 사람도 금방 적응할 수 있어요.\n- Next.js는 `Form`과 라우팅 시스템을 잘 조합해서 SPA와 SSR의 장점을 살렸답니다!\n- 만약 POST 방식으로 데이터를 보내고 싶다면, `action`에 서버 함수를 사용하는 게 좋고, 더 복잡한 API 호출도 쉽게 처리 가능해요.\n\n---\n\n요약하자면, Next.js의 `Form` 컴포넌트를 이용하면 편하게 폼을 작성하면서도, 빠른 페이지 전환과 클라이언트 상태 유지를 누릴 수 있어요. 상황에 따라 `action`에 문자열 URL을 주거나 서버 함수로 처리하는 전략을 골라 쓰시면 됩니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### action (문자열) Props\n\n`Form` 컴포넌트에서 `action`이 문자열일 때 지원하는 props를 살펴볼게요.\n\n| Prop      | 예시                      | 타입                         | 필수 여부  |\n|-----------|---------------------------|------------------------------|------------|\n| `action`  | `action=\"/search\"`         | `string` (URL 또는 상대 경로) | 필수       |\n| `replace` | `replace={false}`          | `boolean`                    | 선택       |\n| `scroll`  | `scroll={true}`            | `boolean`                    | 선택       |\n| `prefetch`| `prefetch={true}`          | `boolean`                    | 선택       |\n\n- **action**: 폼이 제출됐을 때 이동할 URL 혹은 경로를 지정해줘요.  \n  만약 빈 문자열 `\"\"`로 설정하면, 현재 경로에서 검색 파라미터만 업데이트해서 이동해요.  \n  예를 들어, 검색 기능이 있는 페이지에서 검색어만 바뀔 때 유용하겠죠?\n  \n- **replace**: 기본값은 `false`예요.  \n  브라우저의 기록(history) 스택에 새 항목을 추가할지 말지 결정하는데요,  \n  만약 `true`라면 기존 기록을 새 기록으로 *교체*합니다.  \n  뒤로 가기 버튼을 눌렀을 때 이전 페이지로 돌아가지 않게 하려면 이걸 켜면 돼요.\n  \n- **scroll**: 기본값은 `true`이고, 탐색 시 스크롤 동작을 조절해요.  \n  `true`면 새 페이지로 이동할 때 스크롤을 맨 위로 올리고, 뒤로/앞으로 가기 시에는 스크롤 위치를 유지해 줘요.  \n  만약 원하는 스크롤 위치가 있다면 `false`로 설정하고 직접 관리할 수도 있답니다.\n  \n- **prefetch**: 기본값은 `true`로,  \n  폼이 화면에 보이면 해당 경로를 미리 불러와서(pre-fetch) 빠르게 전환할 수 있게 도와줘요.  \n  네트워크 트래픽이나 자원 절약을 원한다면 이 옵션을 꺼도 됩니다.\n\n---\n\n이렇게 각 prop을 잘 활용하면, 단순한 폼 제출 이상의 사용자 경험을 만들 수 있어요.  \n특히 SPA(싱글 페이지 애플리케이션) 개발 시, 이 props들은 라우팅과 렌더링 방식에 큰 영향을 줍니다.\n\n추가 팁으로, `action=\"\"`을 쓰면 URL 파라미터만 바꾸기 때문에  \n검색 페이지나 필터링 기능 구현 시 유용하니 꼭 기억해 두세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### action (함수) Props\n\n`action`이 함수일 때, `Form` 컴포넌트는 다음과 같은 prop을 지원합니다:\n\n| Prop    | 예시                  | 타입                          | 필수 여부 |\n|---------|-----------------------|-------------------------------|----------|\n| action  | `action={myAction}`   | `function` (서버 액션 함수)   | 필수      |\n\n- **action**: 사용자가 폼을 제출할 때 호출되는 서버 액션 함수입니다. React 문서를 참고하면 더 자세한 정보를 얻을 수 있어요.\n\n---\n\n여기서 잠깐! `action`이 서버 액션 함수라는 점에서 조금 독특한데요. 보통 폼 제출은 클라이언트 사이드에서 처리하거나, API 호출을 통해 이루어지곤 하죠. 그런데 React Server Components 환경에서는 서버에서 직접 실행되는 함수 형태로 액션을 정의할 수도 있답니다. 덕분에 클라이언트와 서버 간 데이터 처리 로직 구분이 깔끔해지고, 성능 최적화에도 도움이 돼요.\n\n혹시 익숙하지 않은분은 \"서버 액션\"이 뭔지 한 번 찾아보고, React 공식 문서에서 관련 예제를 보면 이해가 금방 될 거예요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n좋은 정보 한 가지! action이 함수일 때는 replace와 scroll 속성들이 무시된다는 점 기억하세요.\n\n### 주의할 점들\n\n| 항목 | 설명 |\n|---|---|\n| **formAction** | `button`이나 `input type=\"submit\"`에서 action 속성을 덮어쓸 수 있어요. Next.js는 클라이언트 사이드 네비게이션을 수행하지만, 이 방법은 prefetch(선불러오기)를 지원하지 않는다는 점 참고하세요. 그리고 basePath를 사용한다면 반드시 formAction 경로에 basePath를 포함시켜야 합니다. 예) `formAction=\"/base-path/search\"` |\n| **key** | 문자열 형태의 action에 key prop을 넘기는 건 지원되지 않습니다. 만약 리렌더링이나 뮤테이션을 트리거하고 싶으면 함수형 action을 사용하세요. |\n| **onSubmit** | 폼 제출 로직을 처리할 때 사용 가능하지만, 만약 `event.preventDefault()`를 호출하면 Next.js `Form`의 기본 동작(즉 URL로 네비게이션)이 무시됩니다. |\n| **method, encType, target** | 이 속성들은 `Form`의 기본 동작을 오버라이드하기 때문에 지원되지 않아요. 대신에 `formMethod`, `formEncType`, `formTarget` 속성을 써서 각각 method, encType, target을 덮어쓸 수 있긴 하지만 이 경우엔 네이티브 브라우저 동작으로 fallback됩니다. 이들 기능을 꼭 사용해야 한다면 Next.js `Form` 대신 HTML `form` 태그를 사용하는 게 좋아요. |\n| **input type=\"file\"** | action이 문자열일 때 이 타입의 input은 브라우저 동작과 동일하게 파일 객체 대신 파일명만 제출됩니다. |\n\n---\n\n사실 Next.js의 `Form` 컴포넌트를 사용할 때 이런 제약사항들을 미리 알고 있으면 개발할 때 헷갈리는 부분이 줄어요. 특히 prefetch가 안 되거나, 리렌더링 이슈가 생겼을 때는 \"혹시 action을 문자열로 쓰고 key를 넘긴 건 아닌가?\" 하고 한번 점검해보세요.\n\n더불어 파일 업로드 처리는 Next.js 내장 `Form` 컴포넌트로 하기엔 제약이 있으니, 이럴 땐 기존 HTML `form` 태그와 서버 API를 직접 연결하는 방식이 안전합니다.\n\n이런 점들을 잘 기억해두시면 Next.js의 폼 처리 방식을 더욱 능숙하게 사용할 수 있을 거예요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 예제\n\n### 검색 결과 페이지로 이동하는 검색 폼 만들기\n\n검색 결과 페이지로 이동하는 폼을 만들고 싶다면, `action` 속성에 결과 페이지 경로를 넣어주면 됩니다. 예를 들어, `/search` 경로로 이동하도록 설정하면 사용자가 폼을 제출할 때 검색어가 쿼리 파라미터로 붙어서 해당 페이지로 넘어가죠.\n\n```js\nimport Form from 'next/form'\n\nexport default function Page() {\n  return (\n    \u003cForm action=\"/search\"\u003e\n      \u003cinput name=\"query\" /\u003e\n      \u003cbutton type=\"submit\"\u003eSubmit\u003c/button\u003e\n    \u003c/Form\u003e\n  )\n}\n```\n\n여기서 중요한 점은 `input`에 반드시 `name` 속성을 주어야 폼 데이터를 제대로 전달할 수 있다는 거예요. `name=\"query\"`로 지정한 검색어가 `/search?query=검색어` 형태로 넘어가게 됩니다.\n\n그리고, `Form` 컴포넌트는 Next.js의 새로운 폼 처리 방식을 따르는 컴포넌트인데요, 내부적으로 기본 HTML `\u003cform\u003e` 태그와 유사하게 동작하지만 Next.js 특성에 맞게 최적화되어 있어요. 만약 Next.js 버전에 따라 `Form` 컴포넌트가 제공되지 않는 경우에는 기본 `\u003cform\u003e` 태그를 사용하셔도 무방해요.\n\n마지막으로 조금 더 사용자 친화적으로 만들고 싶다면, 입력 필드에 `placeholder`를 넣어주거나, 버튼에 좀 더 직관적인 텍스트를 넣는 것도 추천드려요!\n\n```js\n\u003cForm action=\"/search\"\u003e\n  \u003cinput name=\"query\" placeholder=\"검색어를 입력하세요\" /\u003e\n  \u003cbutton type=\"submit\"\u003e검색\u003c/button\u003e\n\u003c/Form\u003e\n```\n\n이렇게 하면 검색 폼이 더 완성도 있게 보이겠죠? 간단하지만 기본적인 검색 기능을 구현할 때 유용한 방법입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n사용자가 검색어 입력 필드에 값을 넣고 폼을 제출하면, 폼 데이터가 URL의 쿼리 파라미터로 인코딩돼서 `/search?query=abc` 같은 형식으로 이동하게 돼요.\n\n\u003e 참고로, action 속성에 빈 문자열 `\"\"`을 넣으면, 같은 경로로 이동하면서 쿼리 파라미터만 업데이트할 수 있다는 점도 알아두면 좋아요.\n\n검색 결과 페이지에서는 `searchParams`라는 `page.js`의 prop을 통해 쿼리 값을 받아올 수 있고, 이를 이용해 외부 API에서 데이터를 불러오는 식으로 활용할 수 있답니다.\n\n아래 예제를 살펴볼게요.\n\n```js\nimport { getSearchResults } from '@/lib/search'\n\nexport default async function SearchPage({\n  searchParams,\n}: {\n  searchParams: Promise\u003c{ [key: string]: string | string[] | undefined }\u003e\n}) {\n  // searchParams는 Promise 형태라 await을 해줘야 쿼리 값을 받을 수 있어요\n  const results = await getSearchResults((await searchParams).query)\n\n  return \u003cdiv\u003e...\u003c/div\u003e\n}\n```\n\n\u003e 여기서 한 가지 팁을 드리자면, `searchParams`가 Promise라는 점 때문에 async/await을 꼭 처리해줘야 해요. 깜빡하면 값이 제대로 안 들어와서 당황할 수 있답니다.\n\n정리하자면, 이 방법은 서버사이드 렌더링 환경에서 검색어에 따라 동적인 데이터를 불러오기 아주 편리한 방식이에요. React 컴포넌트에서 직접 URL 쿼리 파라미터를 읽어서 비동기 데이터 요청을 쉽게 처리할 수 있거든요.\n\n만약 사용자가 계속 검색어를 바꾸면서 결과를 보고 싶다면, 이 패턴을 잘 응용하면 굉장히 깔끔한 페이지 구성이 가능하니 꼭 기억해두세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n`Form`이 사용자의 화면에 보이기 시작하면, `/search` 페이지에 있는 공통 UI(예를 들어 layout.js나 loading.js) 리소스가 미리 불러와집니다(prefetch). 그리고 폼이 제출되면 바로 새로운 경로로 이동하면서, 결과가 로딩되는 동안에는 로딩 UI가 보여집니다. 이렇게 로딩 UI를 설계하려면 loading.js를 사용하면 되는데, 간단한 예시는 다음과 같아요:\n\n```js\nexport default function Loading() {\n  return \u003cdiv\u003eLoading...\u003c/div\u003e\n}\n```\n\n그런데 여기서 한 가지 더 신경 써야 할 점은, 혹시 공통 UI가 아직 완전히 로드되지 않은 상태에서는 사용자가 답답함을 느낄 수 있다는 거예요. 이런 경우를 대비해서 `useFormStatus` 훅을 활용해서 즉각적인 피드백을 줄 수 있습니다.\n\n자, 그러면 제출이 진행 중일 때 로딩 상태를 보여주는 컴포넌트를 하나 만들어볼게요. 이 컴포넌트는 사용자가 폼을 제출해서 결과를 기다릴 때 뭔가 진행 중임을 보여줘서 사용자 경험을 더 매끄럽게 만들어줍니다.\n\n```js\n'use client'\n\nimport { useFormStatus } from 'react-dom'\n\nexport default function FormProgress() {\n  const { pending } = useFormStatus()\n\n  return (\n    \u003cdiv\u003e\n      {pending ? '폼 제출 중...' : null}\n    \u003c/div\u003e\n  )\n}\n```\n\n여기서 `useFormStatus`는 React Server Components 환경에서 폼 제출 상태(예: 대기중인지 여부)를 추적할 수 있게 도와주는 훅이에요. `pending`이 `true`일 때는 폼이 제출 중임을 의미하죠.\n\n---\n\n### 추가 팁 - 이런 경우에 쓰면 좋아요!\n\n- 사용자가 버튼을 여러 번 반복해서 누르는 걸 방지하고 싶을 때\n- 네트워크가 느려서 서버 응답 시간이 긴 경우 진행 상태를 명확히 보여주고 싶을 때\n- 전체 페이지가 아닌 일부 컴포넌트에만 로딩 표시를 제한하고 싶을 때\n\n---\n\n### 요약\n- `Form`이 화면에 보이면 `/search` 페이지의 공통 UI 리소스를 미리 받아서 빠르게 렌더링 가능\n- 폼 제출 시 로딩 UI(loading.js)로 사용자 피드백 제공\n- `useFormStatus` 훅을 이용해 폼 제출이 진행 중인 상태를 감지하고 즉각적으로 사용자에게 알려줄 수 있음\n\n이렇게 하면 사용자 경험이 훨씬 부드러워지고, 로딩중임을 확실히 인지시켜줘서 UX가 좋아지겠죠? 다음에도 이런 React Server Components 관련 내용 자주 알려드릴게요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번에는 React(특히 Next.js)에서 서버 액션(Server Actions)을 활용한 폼과 버튼 구현 예제를 함께 살펴볼게요.\n\n---\n\n먼저, `SearchButton` 컴포넌트를 보시면, `useFormStatus` 훅을 활용해서 폼이 제출 중인지 아닌지 상태를 확인하고 있죠.\n\n```jsx\n'use client'\nimport { useFormStatus } from 'react-dom'\n \nexport default function SearchButton() {\n  const status = useFormStatus()\n  return (\n    \u003cbutton type=\"submit\"\u003e{status.pending ? 'Searching...' : 'Search'}\u003c/button\u003e\n  )\n}\n```\n\n- `useFormStatus`는 폼 제출 상태를 받아와서, 제출이 진행 중일 때는 버튼 텍스트를 'Searching...'으로, 그렇지 않을 때는 'Search'로 바꾸어 줘요.\n- 그리고 `use client` 지시자는 이 컴포넌트가 클라이언트 컴포넌트임을 Next.js에 알려줍니다. 서버 컴포넌트와 클라이언트 컴포넌트를 적절히 분리해서 사용하는 것이 Next.js 13에서 중요한 포인트입니다.\n\n---\n\n그 다음, 실제 검색 폼 페이지 코드를 보면 이렇게 돼있어요.\n\n```jsx\nimport Form from 'next/form'\nimport { SearchButton } from '@/ui/search-button'\n \nexport default function Page() {\n  return (\n    \u003cForm action=\"/search\"\u003e\n      \u003cinput name=\"query\" /\u003e\n      \u003cSearchButton /\u003e\n    \u003c/Form\u003e\n  )\n}\n```\n\n- 여기서는 `next/form` 라이브러리에서 가져온 `Form` 컴포넌트를 사용하고 있네요.\n- `Form` 컴포넌트에 `action`으로 `/search`를 넘겨서, 제출하면 해당 서버 액션이 실행될 거예요.\n- 그리고 `SearchButton`을 넣어서 폼 제출 시 상태가 표시되도록 했죠.\n\n---\n\n### Server Actions란?\n\nNext.js 13부터 도입된 서버 액션 기능은 클라이언트에서 서버 함수를 직접 호출하듯 코드를 작성할 수 있게 해 줍니다. 기존에는 API 라우트로 POST 요청 보내고 응답 받는 과정이 필요했다면, 서버 액션을 사용하면 그 과정을 훨씬 간편하게 만들 수 있죠.\n\n이번 예제의 핵심은:\n\n- 클라이언트에서 폼 제출 시 `Form` 컴포넌트가 서버 액션을 호출한다.\n- 서버 액션 실행 중일 때 버튼 상태(`Searching...`)를 통해 사용자가 인지할 수 있다.\n\n---\n\n### 더 알아두면 좋은 팁들!\n\n| 내용 | 설명 |\n| --- | --- |\n| `useFormStatus` | 폼 제출 상태를 알 수 있어 UI에 반영하기 좋아요. |\n| 클라이언트 컴포넌트 | 상태를 관리할 버튼 등 인터랙티브한 부분은 클라이언트 컴포넌트로 작성해야 해요. |\n| `Form` 컴포넌트 | 기존 폼 태그를 대체하면서 서버 액션과 자연스럽게 연동됩니다. |\n| 서버 액션 개발 | 서버에서 실행되는 함수이므로 보안이 중요한 로직을 담기 좋아요. |\n\n---\n\n### 마치며\n\n이번에 소개한 `useFormStatus`와 `Form` 컴포넌트를 활용하면 서버 액션과 클라이언트 상태를 아주 깔끔하게 관리할 수 있어요. Next.js 13의 서버 액션 기능은 단순한 API 통신보다 훨씬 직관적이고 강력한 도구니 꼭 한번 적용해 보고, 더 넓은 가능성을 찾아보길 추천해요!\n\n필요하면 서버 액션 만드는 방법과 연동하는 예제도 함께 공유할 테니, 관심 있으면 알려 주세요 :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번에 Next.js에서 `Form` 태그를 활용하는 방법을 살펴봤어요. 그냥 `\u003cform\u003e` 태그 대신 `Form` 컴포넌트를 쓰면, mutation(데이터 변경 작업)을 할 때 간편하게 액션 함수를 넘겨줄 수 있답니다.\n\n```jsx\nimport Form from 'next/form'\nimport { createPost } from '@/posts/actions'\n\nexport default function Page() {\n  return (\n    \u003cForm action={createPost}\u003e\n      \u003cinput name=\"title\" /\u003e\n      {/* ... */}\n      \u003cbutton type=\"submit\"\u003eCreate Post\u003c/button\u003e\n    \u003c/Form\u003e\n  )\n}\n```\n\n여기서 `createPost`는 서버 사이드에서 실행되는 함수로, 폼에 제출된 데이터를 받아 글을 생성하는 역할을 하죠. 이렇게 함수 형태로 액션을 넘기면, 폼 제출 시 자동으로 해당 함수가 호출됩니다.\n\n그리고 글이 만들어지고 나서 보통 새 글 페이지로 리다이렉트 하고 싶은 경우가 많잖아요? 이럴 땐 Next.js의 `next/navigation` 모듈에 있는 `redirect` 함수를 사용하면 돼요.\n\n```js\nimport { redirect } from 'next/navigation';\n\nexport async function createPost(formData) {\n  const post = await createPostInDB(formData);\n  redirect(`/posts/${post.id}`);\n}\n```\n\n여기서 주의할 점은요, 폼이 제출된 후에 액션 함수가 실행되기 때문에, 이 때까지 어디로 리다이렉트할지 모릅니다. 그래서 `Form` 컴포넌트는 자동으로 어떤 UI를 미리 불러오거나(prefetch) 준비하는 기능이 없어요. 즉, 네비게이션이 동적인 상황이라 미리 준비하지 않는다는 뜻입니다.\n\n---\n\n### 참고로 알아두면 좋은 점\n\n- `Form` 컴포넌트를 사용하면 서버 액션을 쉽고 깔끔하게 연결할 수 있어요.\n- 꼭 `redirect`를 사용해서 리다이렉션을 처리해야 하고, 클라이언트에서 직접 네비게이션을 하지 않는 게 좋습니다.\n- 서버 사이드 액션 함수 안에서는 보통 데이터베이스 작업이나 외부 API 호출 같은 일을 처리합니다.\n- 사용자가 제출한 데이터는 `formData` 형태로 받게 되며, 이걸 활용해 원하는 작업을 하면 됩니다.\n\nNext.js 13 초기 버전과 비교하면 정말 좋아진 점 중 하나가 이런 서버 액션과 클라이언트가 자연스럽게 연동된다는 거예요. 개발할 때 훨씬 깔끔하고 안정적으로 만들어서 추천해요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n요즘 Next.js에서 서버 액션(Server Actions)을 활용하는 방법을 공부하고 있는데, 간단하게 정리해볼게요. 서버 액션을 쓰면 서버에서 데이터를 처리하고 그 결과에 따라 바로 리다이렉트도 쉽게 할 수 있어서 편리하답니다.\n\n우선, 새 글을 만드는 `createPost` 서버 액션 함수부터 볼게요:\n\n```js\n'use server'\nimport { redirect } from 'next/navigation'\n \nexport async function createPost(formData: FormData) {\n  // 새로운 글 생성 로직이 여기 들어가겠죠?\n  // 예를 들어 DB에 저장하거나 API를 호출하고...\n \n  // 새 글의 ID를 받아왔다고 가정\n  redirect(`/posts/${data.id}`)  // 생성 완료 후 새 글 페이지로 이동\n}\n```\n\n여기서 'use server' 지시어는 이 함수가 서버에서만 실행된다는 뜻이고, `redirect` 함수로 새로운 글 페이지로 이동할 수 있어요. 클라이언트에서 별도의 처리 없이 서버에서 바로 리다이렉트되는 점이 신기하죠?\n\n그리고 새 글 페이지 컴포넌트에서는 `params`를 받아서 해당 글 데이터를 불러옵니다:\n\n```js\nimport { getPost } from '@/posts/data'\n \nexport default async function PostPage({\n  params,\n}: {\n  params: Promise\u003c{ id: string }\u003e\n}) {\n  const { id } = await params\n  const data = await getPost(id) // 서버에서 글 데이터 가져오기\n \n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003e{data.title}\u003c/h1\u003e\n      {/* 글 내용이나 댓글 등 추가 정보 표시 가능 */}\n    \u003c/div\u003e\n  )\n}\n```\n\n여기서 `params`가 프로미스로 되어있는 게 좀 특이한데, 이게 Next.js의 새로운 동적 라우팅 방식 때문이에요. 비동기로 params를 받아서 바로 데이터를 fetch할 수 있답니다.\n\n덧붙여서, Server Actions은 Next.js 13에서 소개된 기능이고, 기존에 API 라우트를 따로 만들지 않아도 서버 코드를 컴포넌트 안에서 선언해서 사용할 수 있어 개발 생산성을 높여줘요.\n\n더 다양한 예제와 활용 팁은 [서버 액션 공식 문서](https://nextjs.org/docs/app/building-your-application/routing/server-actions)에서 확인해보세요! 한번 익숙해지면 클라이언트-서버 데이터 흐름이 훨씬 깔끔해져서 추천합니다 :)","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":17},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch1\u003eForm 컴포넌트 소개\u003c/h1\u003e\n\u003cp\u003e\u003ccode\u003eForm\u003c/code\u003e 컴포넌트는 HTML의 기본 \u003ccode\u003eform\u003c/code\u003e 요소를 확장한 거예요. 이걸 사용하면 로딩 UI 미리 불러오기(prefetch), 제출 시 클라이언트 사이드에서 페이지 이동, 그리고 점진적 향상(progressive enhancement) 같은 기능을 쉽게 구현할 수 있답니다.\u003c/p\u003e\n\u003cp\u003e특히, URL 검색 파라미터(search params)를 업데이트하는 폼에서 유용해요. 기존에 이런 작업 하면서 번거롭게 작성하던 코드량을 훨씬 줄여주거든요.\u003c/p\u003e\n\u003cp\u003e간단한 기본 사용법은 다음과 같아요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eForm\u003c/span\u003e method=\u003cspan class=\"hljs-string\"\u003e\"get\"\u003c/span\u003e action=\u003cspan class=\"hljs-string\"\u003e\"/search\"\u003c/span\u003e\u003e\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003einput\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"query\"\u003c/span\u003e /\u003e\u003c/span\u003e\u003c/span\u003e\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"submit\"\u003c/span\u003e\u003e\u003c/span\u003eSearch\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u0026#x3C;/\u003cspan class=\"hljs-title class_\"\u003eForm\u003c/span\u003e\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch3\u003e덧붙일 내용 - 왜 점진적 향상인가?\u003c/h3\u003e\n\u003cp\u003e점진적 향상(Progressive Enhancement)이란 말 그대로 웹 기능을 기본 HTML에서도 사용 가능하면서, 자바스크립트를 지원하는 환경에서는 더 나은 경험을 제공하는 걸 의미해요.\u003cbr\u003e\n\u003ccode\u003eForm\u003c/code\u003e 컴포넌트를 쓰면 이렇게 기본 HTML 폼 기능을 유지하면서도, JavaScript가 활성화된 환경에서는 더 빠르고 매끄러운 네비게이션이 가능하죠.\u003c/p\u003e\n\u003cp\u003e또한, 네트워크 상태가 좋지 않은 경우에도 기본 폼 기능 덕분에 최소한의 작동은 보장되니, 사용자 경험을 꽤나 챙길 수 있어요.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eForm\u003c/code\u003e과 비슷한 개념으로는 React의 \u003ccode\u003ereact-router\u003c/code\u003e 라이브러리나 Next.js의 \u003ccode\u003enext/link\u003c/code\u003e 같은 것들이 있는데, 이 컴포넌트는 좀 더 폼 제출에 특화되어 있다고 보면 됩니다!\u003c/p\u003e\n\u003cp\u003e필요한 상황에 맞게 잘 활용해 보세요. 폼 제출 시 사용자 경험을 한층 개선해 줄 거예요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이번 글에서는 Next.js의 \u003ccode\u003eForm\u003c/code\u003e 컴포넌트 사용법에 대해 다뤄볼게요. 예제를 보면서 설명할게요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eForm\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/form'\u003c/span\u003e\n \n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eForm\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eaction\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"/search\"\u003c/span\u003e\u003e\u003c/span\u003e\n      {/* 제출 시, 입력값이 URL에 쿼리 파라미터로 붙어요. 예: /search?query=abc */}\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003einput\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"query\"\u003c/span\u003e /\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"submit\"\u003c/span\u003e\u003e\u003c/span\u003eSubmit\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eForm\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e이 코드가 하는 일?\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eForm\u003c/code\u003e 컴포넌트에 \u003ccode\u003eaction=\"/search\"\u003c/code\u003e 처럼 문자열 형태로 \u003ccode\u003eaction\u003c/code\u003e을 넘기면, 기본적으로 HTML 폼이 GET 방식으로 데이터를 보내는 방식과 유사해요. 사용자가 입력한 값(여기선 \u003ccode\u003equery\u003c/code\u003e input 값)이 URL 쿼리 스트링으로 추가되고, \u003ccode\u003e/search?query=입력값\u003c/code\u003e 형태로 이동하죠.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e근데 여기서 Next.js가 특별한 점은?\u003c/h3\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e특징\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e미리 불러오기(Prefetch)\u003c/td\u003e\u003ctd\u003e폼이 화면에 나타나면 지정한 경로(\u003ccode\u003e/search\u003c/code\u003e)를 미리 불러와서 페이지 전환이 훨씬 빨라져요. 이때 레이아웃이나 로딩 컴포넌트 같은 공유 UI도 함께 미리 준비돼요.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e클라이언트 사이드 내비게이션\u003c/td\u003e\u003ctd\u003e폼을 제출했을 때, 페이지가 전체 새로고침 되지 않고 SPA처럼 클라이언트 사이드에서 경로가 바뀌어요. 덕분에 공유 UI가 유지되고, 유저 인터페이스가 더 부드럽게 느껴집니다.\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003chr\u003e\n\u003ch3\u003e참고! \u003ccode\u003eaction\u003c/code\u003e에 함수 넣으면?\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eForm\u003c/code\u003e의 \u003ccode\u003eaction\u003c/code\u003e 프로퍼티에 서버 액션(Server Action) 함수를 전달하면, 제출 시 해당 함수가 실행돼요. 완전히 React 방식으로 동작하는 거죠. 서버에서 데이터를 처리하거나 검증하는 등의 작업을 손쉽게 구현할 수 있습니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e추가 팁!\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e기존 HTML \u003ccode\u003e\u0026#x3C;form\u003e\u003c/code\u003e과 거의 비슷하게 동작하니까, 폼을 처음 접하는 사람도 금방 적응할 수 있어요.\u003c/li\u003e\n\u003cli\u003eNext.js는 \u003ccode\u003eForm\u003c/code\u003e과 라우팅 시스템을 잘 조합해서 SPA와 SSR의 장점을 살렸답니다!\u003c/li\u003e\n\u003cli\u003e만약 POST 방식으로 데이터를 보내고 싶다면, \u003ccode\u003eaction\u003c/code\u003e에 서버 함수를 사용하는 게 좋고, 더 복잡한 API 호출도 쉽게 처리 가능해요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e요약하자면, Next.js의 \u003ccode\u003eForm\u003c/code\u003e 컴포넌트를 이용하면 편하게 폼을 작성하면서도, 빠른 페이지 전환과 클라이언트 상태 유지를 누릴 수 있어요. 상황에 따라 \u003ccode\u003eaction\u003c/code\u003e에 문자열 URL을 주거나 서버 함수로 처리하는 전략을 골라 쓰시면 됩니다!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch3\u003eaction (문자열) Props\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eForm\u003c/code\u003e 컴포넌트에서 \u003ccode\u003eaction\u003c/code\u003e이 문자열일 때 지원하는 props를 살펴볼게요.\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003eProp\u003c/th\u003e\u003cth\u003e예시\u003c/th\u003e\u003cth\u003e타입\u003c/th\u003e\u003cth\u003e필수 여부\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eaction\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eaction=\"/search\"\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003estring\u003c/code\u003e (URL 또는 상대 경로)\u003c/td\u003e\u003ctd\u003e필수\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ereplace\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003ereplace={false}\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eboolean\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e선택\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003escroll\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003escroll={true}\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eboolean\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e선택\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eprefetch\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eprefetch={true}\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eboolean\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e선택\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eaction\u003c/strong\u003e: 폼이 제출됐을 때 이동할 URL 혹은 경로를 지정해줘요.\u003cbr\u003e\n만약 빈 문자열 \u003ccode\u003e\"\"\u003c/code\u003e로 설정하면, 현재 경로에서 검색 파라미터만 업데이트해서 이동해요.\u003cbr\u003e\n예를 들어, 검색 기능이 있는 페이지에서 검색어만 바뀔 때 유용하겠죠?\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003ereplace\u003c/strong\u003e: 기본값은 \u003ccode\u003efalse\u003c/code\u003e예요.\u003cbr\u003e\n브라우저의 기록(history) 스택에 새 항목을 추가할지 말지 결정하는데요,\u003cbr\u003e\n만약 \u003ccode\u003etrue\u003c/code\u003e라면 기존 기록을 새 기록으로 \u003cem\u003e교체\u003c/em\u003e합니다.\u003cbr\u003e\n뒤로 가기 버튼을 눌렀을 때 이전 페이지로 돌아가지 않게 하려면 이걸 켜면 돼요.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003escroll\u003c/strong\u003e: 기본값은 \u003ccode\u003etrue\u003c/code\u003e이고, 탐색 시 스크롤 동작을 조절해요.\u003cbr\u003e\n\u003ccode\u003etrue\u003c/code\u003e면 새 페이지로 이동할 때 스크롤을 맨 위로 올리고, 뒤로/앞으로 가기 시에는 스크롤 위치를 유지해 줘요.\u003cbr\u003e\n만약 원하는 스크롤 위치가 있다면 \u003ccode\u003efalse\u003c/code\u003e로 설정하고 직접 관리할 수도 있답니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eprefetch\u003c/strong\u003e: 기본값은 \u003ccode\u003etrue\u003c/code\u003e로,\u003cbr\u003e\n폼이 화면에 보이면 해당 경로를 미리 불러와서(pre-fetch) 빠르게 전환할 수 있게 도와줘요.\u003cbr\u003e\n네트워크 트래픽이나 자원 절약을 원한다면 이 옵션을 꺼도 됩니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e이렇게 각 prop을 잘 활용하면, 단순한 폼 제출 이상의 사용자 경험을 만들 수 있어요.\u003cbr\u003e\n특히 SPA(싱글 페이지 애플리케이션) 개발 시, 이 props들은 라우팅과 렌더링 방식에 큰 영향을 줍니다.\u003c/p\u003e\n\u003cp\u003e추가 팁으로, \u003ccode\u003eaction=\"\"\u003c/code\u003e을 쓰면 URL 파라미터만 바꾸기 때문에\u003cbr\u003e\n검색 페이지나 필터링 기능 구현 시 유용하니 꼭 기억해 두세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch3\u003eaction (함수) Props\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eaction\u003c/code\u003e이 함수일 때, \u003ccode\u003eForm\u003c/code\u003e 컴포넌트는 다음과 같은 prop을 지원합니다:\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003eProp\u003c/th\u003e\u003cth\u003e예시\u003c/th\u003e\u003cth\u003e타입\u003c/th\u003e\u003cth\u003e필수 여부\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003eaction\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eaction={myAction}\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003efunction\u003c/code\u003e (서버 액션 함수)\u003c/td\u003e\u003ctd\u003e필수\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eaction\u003c/strong\u003e: 사용자가 폼을 제출할 때 호출되는 서버 액션 함수입니다. React 문서를 참고하면 더 자세한 정보를 얻을 수 있어요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e여기서 잠깐! \u003ccode\u003eaction\u003c/code\u003e이 서버 액션 함수라는 점에서 조금 독특한데요. 보통 폼 제출은 클라이언트 사이드에서 처리하거나, API 호출을 통해 이루어지곤 하죠. 그런데 React Server Components 환경에서는 서버에서 직접 실행되는 함수 형태로 액션을 정의할 수도 있답니다. 덕분에 클라이언트와 서버 간 데이터 처리 로직 구분이 깔끔해지고, 성능 최적화에도 도움이 돼요.\u003c/p\u003e\n\u003cp\u003e혹시 익숙하지 않은분은 \"서버 액션\"이 뭔지 한 번 찾아보고, React 공식 문서에서 관련 예제를 보면 이해가 금방 될 거예요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e좋은 정보 한 가지! action이 함수일 때는 replace와 scroll 속성들이 무시된다는 점 기억하세요.\u003c/p\u003e\n\u003ch3\u003e주의할 점들\u003c/h3\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e항목\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cstrong\u003eformAction\u003c/strong\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003ebutton\u003c/code\u003e이나 \u003ccode\u003einput type=\"submit\"\u003c/code\u003e에서 action 속성을 덮어쓸 수 있어요. Next.js는 클라이언트 사이드 네비게이션을 수행하지만, 이 방법은 prefetch(선불러오기)를 지원하지 않는다는 점 참고하세요. 그리고 basePath를 사용한다면 반드시 formAction 경로에 basePath를 포함시켜야 합니다. 예) \u003ccode\u003eformAction=\"/base-path/search\"\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003cstrong\u003ekey\u003c/strong\u003e\u003c/td\u003e\u003ctd\u003e문자열 형태의 action에 key prop을 넘기는 건 지원되지 않습니다. 만약 리렌더링이나 뮤테이션을 트리거하고 싶으면 함수형 action을 사용하세요.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003cstrong\u003eonSubmit\u003c/strong\u003e\u003c/td\u003e\u003ctd\u003e폼 제출 로직을 처리할 때 사용 가능하지만, 만약 \u003ccode\u003eevent.preventDefault()\u003c/code\u003e를 호출하면 Next.js \u003ccode\u003eForm\u003c/code\u003e의 기본 동작(즉 URL로 네비게이션)이 무시됩니다.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003cstrong\u003emethod, encType, target\u003c/strong\u003e\u003c/td\u003e\u003ctd\u003e이 속성들은 \u003ccode\u003eForm\u003c/code\u003e의 기본 동작을 오버라이드하기 때문에 지원되지 않아요. 대신에 \u003ccode\u003eformMethod\u003c/code\u003e, \u003ccode\u003eformEncType\u003c/code\u003e, \u003ccode\u003eformTarget\u003c/code\u003e 속성을 써서 각각 method, encType, target을 덮어쓸 수 있긴 하지만 이 경우엔 네이티브 브라우저 동작으로 fallback됩니다. 이들 기능을 꼭 사용해야 한다면 Next.js \u003ccode\u003eForm\u003c/code\u003e 대신 HTML \u003ccode\u003eform\u003c/code\u003e 태그를 사용하는 게 좋아요.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003cstrong\u003einput type=\"file\"\u003c/strong\u003e\u003c/td\u003e\u003ctd\u003eaction이 문자열일 때 이 타입의 input은 브라우저 동작과 동일하게 파일 객체 대신 파일명만 제출됩니다.\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003chr\u003e\n\u003cp\u003e사실 Next.js의 \u003ccode\u003eForm\u003c/code\u003e 컴포넌트를 사용할 때 이런 제약사항들을 미리 알고 있으면 개발할 때 헷갈리는 부분이 줄어요. 특히 prefetch가 안 되거나, 리렌더링 이슈가 생겼을 때는 \"혹시 action을 문자열로 쓰고 key를 넘긴 건 아닌가?\" 하고 한번 점검해보세요.\u003c/p\u003e\n\u003cp\u003e더불어 파일 업로드 처리는 Next.js 내장 \u003ccode\u003eForm\u003c/code\u003e 컴포넌트로 하기엔 제약이 있으니, 이럴 땐 기존 HTML \u003ccode\u003eform\u003c/code\u003e 태그와 서버 API를 직접 연결하는 방식이 안전합니다.\u003c/p\u003e\n\u003cp\u003e이런 점들을 잘 기억해두시면 Next.js의 폼 처리 방식을 더욱 능숙하게 사용할 수 있을 거예요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e예제\u003c/h2\u003e\n\u003ch3\u003e검색 결과 페이지로 이동하는 검색 폼 만들기\u003c/h3\u003e\n\u003cp\u003e검색 결과 페이지로 이동하는 폼을 만들고 싶다면, \u003ccode\u003eaction\u003c/code\u003e 속성에 결과 페이지 경로를 넣어주면 됩니다. 예를 들어, \u003ccode\u003e/search\u003c/code\u003e 경로로 이동하도록 설정하면 사용자가 폼을 제출할 때 검색어가 쿼리 파라미터로 붙어서 해당 페이지로 넘어가죠.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eForm\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/form'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eForm\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eaction\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"/search\"\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003einput\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"query\"\u003c/span\u003e /\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"submit\"\u003c/span\u003e\u003e\u003c/span\u003eSubmit\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eForm\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 중요한 점은 \u003ccode\u003einput\u003c/code\u003e에 반드시 \u003ccode\u003ename\u003c/code\u003e 속성을 주어야 폼 데이터를 제대로 전달할 수 있다는 거예요. \u003ccode\u003ename=\"query\"\u003c/code\u003e로 지정한 검색어가 \u003ccode\u003e/search?query=검색어\u003c/code\u003e 형태로 넘어가게 됩니다.\u003c/p\u003e\n\u003cp\u003e그리고, \u003ccode\u003eForm\u003c/code\u003e 컴포넌트는 Next.js의 새로운 폼 처리 방식을 따르는 컴포넌트인데요, 내부적으로 기본 HTML \u003ccode\u003e\u0026#x3C;form\u003e\u003c/code\u003e 태그와 유사하게 동작하지만 Next.js 특성에 맞게 최적화되어 있어요. 만약 Next.js 버전에 따라 \u003ccode\u003eForm\u003c/code\u003e 컴포넌트가 제공되지 않는 경우에는 기본 \u003ccode\u003e\u0026#x3C;form\u003e\u003c/code\u003e 태그를 사용하셔도 무방해요.\u003c/p\u003e\n\u003cp\u003e마지막으로 조금 더 사용자 친화적으로 만들고 싶다면, 입력 필드에 \u003ccode\u003eplaceholder\u003c/code\u003e를 넣어주거나, 버튼에 좀 더 직관적인 텍스트를 넣는 것도 추천드려요!\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eForm\u003c/span\u003e action=\u003cspan class=\"hljs-string\"\u003e\"/search\"\u003c/span\u003e\u003e\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003einput\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"query\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eplaceholder\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"검색어를 입력하세요\"\u003c/span\u003e /\u003e\u003c/span\u003e\u003c/span\u003e\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"submit\"\u003c/span\u003e\u003e\u003c/span\u003e검색\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u0026#x3C;/\u003cspan class=\"hljs-title class_\"\u003eForm\u003c/span\u003e\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 하면 검색 폼이 더 완성도 있게 보이겠죠? 간단하지만 기본적인 검색 기능을 구현할 때 유용한 방법입니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e사용자가 검색어 입력 필드에 값을 넣고 폼을 제출하면, 폼 데이터가 URL의 쿼리 파라미터로 인코딩돼서 \u003ccode\u003e/search?query=abc\u003c/code\u003e 같은 형식으로 이동하게 돼요.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e참고로, action 속성에 빈 문자열 \u003ccode\u003e\"\"\u003c/code\u003e을 넣으면, 같은 경로로 이동하면서 쿼리 파라미터만 업데이트할 수 있다는 점도 알아두면 좋아요.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e검색 결과 페이지에서는 \u003ccode\u003esearchParams\u003c/code\u003e라는 \u003ccode\u003epage.js\u003c/code\u003e의 prop을 통해 쿼리 값을 받아올 수 있고, 이를 이용해 외부 API에서 데이터를 불러오는 식으로 활용할 수 있답니다.\u003c/p\u003e\n\u003cp\u003e아래 예제를 살펴볼게요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { getSearchResults } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@/lib/search'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eSearchPage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{\n  searchParams,\n}: {\n  searchParams: \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e\u0026#x3C;{ [key: string]: string | string[] | \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e }\u003e\n}\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// searchParams는 Promise 형태라 await을 해줘야 쿼리 값을 받을 수 있어요\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e results = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetSearchResults\u003c/span\u003e((\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e searchParams).\u003cspan class=\"hljs-property\"\u003equery\u003c/span\u003e)\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e...\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e여기서 한 가지 팁을 드리자면, \u003ccode\u003esearchParams\u003c/code\u003e가 Promise라는 점 때문에 async/await을 꼭 처리해줘야 해요. 깜빡하면 값이 제대로 안 들어와서 당황할 수 있답니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e정리하자면, 이 방법은 서버사이드 렌더링 환경에서 검색어에 따라 동적인 데이터를 불러오기 아주 편리한 방식이에요. React 컴포넌트에서 직접 URL 쿼리 파라미터를 읽어서 비동기 데이터 요청을 쉽게 처리할 수 있거든요.\u003c/p\u003e\n\u003cp\u003e만약 사용자가 계속 검색어를 바꾸면서 결과를 보고 싶다면, 이 패턴을 잘 응용하면 굉장히 깔끔한 페이지 구성이 가능하니 꼭 기억해두세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003ccode\u003eForm\u003c/code\u003e이 사용자의 화면에 보이기 시작하면, \u003ccode\u003e/search\u003c/code\u003e 페이지에 있는 공통 UI(예를 들어 layout.js나 loading.js) 리소스가 미리 불러와집니다(prefetch). 그리고 폼이 제출되면 바로 새로운 경로로 이동하면서, 결과가 로딩되는 동안에는 로딩 UI가 보여집니다. 이렇게 로딩 UI를 설계하려면 loading.js를 사용하면 되는데, 간단한 예시는 다음과 같아요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eLoading\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003eLoading...\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그런데 여기서 한 가지 더 신경 써야 할 점은, 혹시 공통 UI가 아직 완전히 로드되지 않은 상태에서는 사용자가 답답함을 느낄 수 있다는 거예요. 이런 경우를 대비해서 \u003ccode\u003euseFormStatus\u003c/code\u003e 훅을 활용해서 즉각적인 피드백을 줄 수 있습니다.\u003c/p\u003e\n\u003cp\u003e자, 그러면 제출이 진행 중일 때 로딩 상태를 보여주는 컴포넌트를 하나 만들어볼게요. 이 컴포넌트는 사용자가 폼을 제출해서 결과를 기다릴 때 뭔가 진행 중임을 보여줘서 사용자 경험을 더 매끄럽게 만들어줍니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e'use client'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { useFormStatus } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react-dom'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eFormProgress\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { pending } = \u003cspan class=\"hljs-title function_\"\u003euseFormStatus\u003c/span\u003e()\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      {pending ? '폼 제출 중...' : null}\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 \u003ccode\u003euseFormStatus\u003c/code\u003e는 React Server Components 환경에서 폼 제출 상태(예: 대기중인지 여부)를 추적할 수 있게 도와주는 훅이에요. \u003ccode\u003epending\u003c/code\u003e이 \u003ccode\u003etrue\u003c/code\u003e일 때는 폼이 제출 중임을 의미하죠.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e추가 팁 - 이런 경우에 쓰면 좋아요!\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e사용자가 버튼을 여러 번 반복해서 누르는 걸 방지하고 싶을 때\u003c/li\u003e\n\u003cli\u003e네트워크가 느려서 서버 응답 시간이 긴 경우 진행 상태를 명확히 보여주고 싶을 때\u003c/li\u003e\n\u003cli\u003e전체 페이지가 아닌 일부 컴포넌트에만 로딩 표시를 제한하고 싶을 때\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3\u003e요약\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eForm\u003c/code\u003e이 화면에 보이면 \u003ccode\u003e/search\u003c/code\u003e 페이지의 공통 UI 리소스를 미리 받아서 빠르게 렌더링 가능\u003c/li\u003e\n\u003cli\u003e폼 제출 시 로딩 UI(loading.js)로 사용자 피드백 제공\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003euseFormStatus\u003c/code\u003e 훅을 이용해 폼 제출이 진행 중인 상태를 감지하고 즉각적으로 사용자에게 알려줄 수 있음\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이렇게 하면 사용자 경험이 훨씬 부드러워지고, 로딩중임을 확실히 인지시켜줘서 UX가 좋아지겠죠? 다음에도 이런 React Server Components 관련 내용 자주 알려드릴게요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이번에는 React(특히 Next.js)에서 서버 액션(Server Actions)을 활용한 폼과 버튼 구현 예제를 함께 살펴볼게요.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e먼저, \u003ccode\u003eSearchButton\u003c/code\u003e 컴포넌트를 보시면, \u003ccode\u003euseFormStatus\u003c/code\u003e 훅을 활용해서 폼이 제출 중인지 아닌지 상태를 확인하고 있죠.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-string\"\u003e'use client'\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { useFormStatus } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react-dom'\u003c/span\u003e\n \n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eSearchButton\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e status = \u003cspan class=\"hljs-title function_\"\u003euseFormStatus\u003c/span\u003e()\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"submit\"\u003c/span\u003e\u003e\u003c/span\u003e{status.pending ? 'Searching...' : 'Search'}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003euseFormStatus\u003c/code\u003e는 폼 제출 상태를 받아와서, 제출이 진행 중일 때는 버튼 텍스트를 'Searching...'으로, 그렇지 않을 때는 'Search'로 바꾸어 줘요.\u003c/li\u003e\n\u003cli\u003e그리고 \u003ccode\u003euse client\u003c/code\u003e 지시자는 이 컴포넌트가 클라이언트 컴포넌트임을 Next.js에 알려줍니다. 서버 컴포넌트와 클라이언트 컴포넌트를 적절히 분리해서 사용하는 것이 Next.js 13에서 중요한 포인트입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e그 다음, 실제 검색 폼 페이지 코드를 보면 이렇게 돼있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eForm\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/form'\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eSearchButton\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@/ui/search-button'\u003c/span\u003e\n \n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eForm\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eaction\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"/search\"\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003einput\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"query\"\u003c/span\u003e /\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eSearchButton\u003c/span\u003e /\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eForm\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e여기서는 \u003ccode\u003enext/form\u003c/code\u003e 라이브러리에서 가져온 \u003ccode\u003eForm\u003c/code\u003e 컴포넌트를 사용하고 있네요.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eForm\u003c/code\u003e 컴포넌트에 \u003ccode\u003eaction\u003c/code\u003e으로 \u003ccode\u003e/search\u003c/code\u003e를 넘겨서, 제출하면 해당 서버 액션이 실행될 거예요.\u003c/li\u003e\n\u003cli\u003e그리고 \u003ccode\u003eSearchButton\u003c/code\u003e을 넣어서 폼 제출 시 상태가 표시되도록 했죠.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3\u003eServer Actions란?\u003c/h3\u003e\n\u003cp\u003eNext.js 13부터 도입된 서버 액션 기능은 클라이언트에서 서버 함수를 직접 호출하듯 코드를 작성할 수 있게 해 줍니다. 기존에는 API 라우트로 POST 요청 보내고 응답 받는 과정이 필요했다면, 서버 액션을 사용하면 그 과정을 훨씬 간편하게 만들 수 있죠.\u003c/p\u003e\n\u003cp\u003e이번 예제의 핵심은:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e클라이언트에서 폼 제출 시 \u003ccode\u003eForm\u003c/code\u003e 컴포넌트가 서버 액션을 호출한다.\u003c/li\u003e\n\u003cli\u003e서버 액션 실행 중일 때 버튼 상태(\u003ccode\u003eSearching...\u003c/code\u003e)를 통해 사용자가 인지할 수 있다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3\u003e더 알아두면 좋은 팁들!\u003c/h3\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e내용\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003euseFormStatus\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e폼 제출 상태를 알 수 있어 UI에 반영하기 좋아요.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e클라이언트 컴포넌트\u003c/td\u003e\u003ctd\u003e상태를 관리할 버튼 등 인터랙티브한 부분은 클라이언트 컴포넌트로 작성해야 해요.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eForm\u003c/code\u003e 컴포넌트\u003c/td\u003e\u003ctd\u003e기존 폼 태그를 대체하면서 서버 액션과 자연스럽게 연동됩니다.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e서버 액션 개발\u003c/td\u003e\u003ctd\u003e서버에서 실행되는 함수이므로 보안이 중요한 로직을 담기 좋아요.\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003chr\u003e\n\u003ch3\u003e마치며\u003c/h3\u003e\n\u003cp\u003e이번에 소개한 \u003ccode\u003euseFormStatus\u003c/code\u003e와 \u003ccode\u003eForm\u003c/code\u003e 컴포넌트를 활용하면 서버 액션과 클라이언트 상태를 아주 깔끔하게 관리할 수 있어요. Next.js 13의 서버 액션 기능은 단순한 API 통신보다 훨씬 직관적이고 강력한 도구니 꼭 한번 적용해 보고, 더 넓은 가능성을 찾아보길 추천해요!\u003c/p\u003e\n\u003cp\u003e필요하면 서버 액션 만드는 방법과 연동하는 예제도 함께 공유할 테니, 관심 있으면 알려 주세요 :)\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이번에 Next.js에서 \u003ccode\u003eForm\u003c/code\u003e 태그를 활용하는 방법을 살펴봤어요. 그냥 \u003ccode\u003e\u0026#x3C;form\u003e\u003c/code\u003e 태그 대신 \u003ccode\u003eForm\u003c/code\u003e 컴포넌트를 쓰면, mutation(데이터 변경 작업)을 할 때 간편하게 액션 함수를 넘겨줄 수 있답니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eForm\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/form'\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { createPost } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@/posts/actions'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eForm\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eaction\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{createPost}\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003einput\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"title\"\u003c/span\u003e /\u003e\u003c/span\u003e\n      {/* ... */}\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"submit\"\u003c/span\u003e\u003e\u003c/span\u003eCreate Post\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eForm\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 \u003ccode\u003ecreatePost\u003c/code\u003e는 서버 사이드에서 실행되는 함수로, 폼에 제출된 데이터를 받아 글을 생성하는 역할을 하죠. 이렇게 함수 형태로 액션을 넘기면, 폼 제출 시 자동으로 해당 함수가 호출됩니다.\u003c/p\u003e\n\u003cp\u003e그리고 글이 만들어지고 나서 보통 새 글 페이지로 리다이렉트 하고 싶은 경우가 많잖아요? 이럴 땐 Next.js의 \u003ccode\u003enext/navigation\u003c/code\u003e 모듈에 있는 \u003ccode\u003eredirect\u003c/code\u003e 함수를 사용하면 돼요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { redirect } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/navigation'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecreatePost\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eformData\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e post = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecreatePostInDB\u003c/span\u003e(formData);\n  \u003cspan class=\"hljs-title function_\"\u003eredirect\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`/posts/\u003cspan class=\"hljs-subst\"\u003e${post.id}\u003c/span\u003e`\u003c/span\u003e);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 주의할 점은요, 폼이 제출된 후에 액션 함수가 실행되기 때문에, 이 때까지 어디로 리다이렉트할지 모릅니다. 그래서 \u003ccode\u003eForm\u003c/code\u003e 컴포넌트는 자동으로 어떤 UI를 미리 불러오거나(prefetch) 준비하는 기능이 없어요. 즉, 네비게이션이 동적인 상황이라 미리 준비하지 않는다는 뜻입니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e참고로 알아두면 좋은 점\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eForm\u003c/code\u003e 컴포넌트를 사용하면 서버 액션을 쉽고 깔끔하게 연결할 수 있어요.\u003c/li\u003e\n\u003cli\u003e꼭 \u003ccode\u003eredirect\u003c/code\u003e를 사용해서 리다이렉션을 처리해야 하고, 클라이언트에서 직접 네비게이션을 하지 않는 게 좋습니다.\u003c/li\u003e\n\u003cli\u003e서버 사이드 액션 함수 안에서는 보통 데이터베이스 작업이나 외부 API 호출 같은 일을 처리합니다.\u003c/li\u003e\n\u003cli\u003e사용자가 제출한 데이터는 \u003ccode\u003eformData\u003c/code\u003e 형태로 받게 되며, 이걸 활용해 원하는 작업을 하면 됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eNext.js 13 초기 버전과 비교하면 정말 좋아진 점 중 하나가 이런 서버 액션과 클라이언트가 자연스럽게 연동된다는 거예요. 개발할 때 훨씬 깔끔하고 안정적으로 만들어서 추천해요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e요즘 Next.js에서 서버 액션(Server Actions)을 활용하는 방법을 공부하고 있는데, 간단하게 정리해볼게요. 서버 액션을 쓰면 서버에서 데이터를 처리하고 그 결과에 따라 바로 리다이렉트도 쉽게 할 수 있어서 편리하답니다.\u003c/p\u003e\n\u003cp\u003e우선, 새 글을 만드는 \u003ccode\u003ecreatePost\u003c/code\u003e 서버 액션 함수부터 볼게요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e'use server'\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { redirect } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/navigation'\u003c/span\u003e\n \n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecreatePost\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eformData: FormData\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 새로운 글 생성 로직이 여기 들어가겠죠?\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// 예를 들어 DB에 저장하거나 API를 호출하고...\u003c/span\u003e\n \n  \u003cspan class=\"hljs-comment\"\u003e// 새 글의 ID를 받아왔다고 가정\u003c/span\u003e\n  \u003cspan class=\"hljs-title function_\"\u003eredirect\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`/posts/\u003cspan class=\"hljs-subst\"\u003e${data.id}\u003c/span\u003e`\u003c/span\u003e)  \u003cspan class=\"hljs-comment\"\u003e// 생성 완료 후 새 글 페이지로 이동\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 'use server' 지시어는 이 함수가 서버에서만 실행된다는 뜻이고, \u003ccode\u003eredirect\u003c/code\u003e 함수로 새로운 글 페이지로 이동할 수 있어요. 클라이언트에서 별도의 처리 없이 서버에서 바로 리다이렉트되는 점이 신기하죠?\u003c/p\u003e\n\u003cp\u003e그리고 새 글 페이지 컴포넌트에서는 \u003ccode\u003eparams\u003c/code\u003e를 받아서 해당 글 데이터를 불러옵니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { getPost } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@/posts/data'\u003c/span\u003e\n \n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePostPage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{\n  params,\n}: {\n  params: \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e\u0026#x3C;{ id: string }\u003e\n}\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { id } = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e params\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e data = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetPost\u003c/span\u003e(id) \u003cspan class=\"hljs-comment\"\u003e// 서버에서 글 데이터 가져오기\u003c/span\u003e\n \n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e{data.title}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e\n      {/* 글 내용이나 댓글 등 추가 정보 표시 가능 */}\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 \u003ccode\u003eparams\u003c/code\u003e가 프로미스로 되어있는 게 좀 특이한데, 이게 Next.js의 새로운 동적 라우팅 방식 때문이에요. 비동기로 params를 받아서 바로 데이터를 fetch할 수 있답니다.\u003c/p\u003e\n\u003cp\u003e덧붙여서, Server Actions은 Next.js 13에서 소개된 기능이고, 기존에 API 라우트를 따로 만들지 않아도 서버 코드를 컴포넌트 안에서 선언해서 사용할 수 있어 개발 생산성을 높여줘요.\u003c/p\u003e\n\u003cp\u003e더 다양한 예제와 활용 팁은 \u003ca href=\"https://nextjs.org/docs/app/building-your-application/routing/server-actions\" rel=\"nofollow\" target=\"_blank\"\u003e서버 액션 공식 문서\u003c/a\u003e에서 확인해보세요! 한번 익숙해지면 클라이언트-서버 데이터 흐름이 훨씬 깔끔해져서 추천합니다 :)\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2025-04-22-Form"},"buildId":"olPs1cVezSGTqD7OaewDI","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>