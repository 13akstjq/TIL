<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>TypeScript와 함께 작업할 때 정직이 최선의 정책인 이유  거짓말의 대가 | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="TypeScript와 함께 작업할 때 정직이 최선의 정책인 이유  거짓말의 대가 | TIL" data-gatsby-head="true"/><meta property="og:title" content="TypeScript와 함께 작업할 때 정직이 최선의 정책인 이유  거짓말의 대가 | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/TIL/assets/img/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript" data-gatsby-head="true"/><meta name="twitter:title" content="TypeScript와 함께 작업할 때 정직이 최선의 정책인 이유  거짓말의 대가 | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/assets/img/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2024-07-02 21:49" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/post/%5Bslug%5D-5ecfd58aae5a7e3d.js" defer=""></script><script src="/TIL/_next/static/gbGPtKGWbTgygZJ0X0J0x/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/gbGPtKGWbTgygZJ0X0J0x/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">TypeScript와 함께 작업할 때 정직이 최선의 정책인 이유  거짓말의 대가</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="TypeScript와 함께 작업할 때 정직이 최선의 정책인 이유  거짓말의 대가" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jul 2, 2024</span><span class="posts_reading_time__f7YPP">19<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/TIL/assets/img/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript_0.png" alt="이미지"></p>
<h1>서문</h1>
<p>코드베이스로 새로운 풀 리퀘스트 '라이브러리 A 마이너 업데이트'를 받았다고 상상해보세요. 변경 사항을 검토하고 모든 것이 좋아 보입니다: 유닛 테스트를 통과했고, 통합 테스트가 성공했으며, 수동 테스트에서는 문제가 발견되지 않았습니다. 자신감을 갖고 PR을 프로덕션에 병합합니다. 성공적인 배포 후, 한 잠깐 쉬어도 좋을 것 같은 시간에 복어 잇님 모님 캆시 닦고 동료들과 이야기를 나눕니다. 정말 좋은 하루가 되고 있습니다.</p>
<p>그러나 당신이 책상에 돌아가 앉은 순간, 예상치 못한 광경이 당신을 반격합니다: 슬랙 인박스에 99개의 읽지 않은 메시지가 있는 것입니다. 무엇이 잘못되었을까요?</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/TIL/assets/img/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript_1.png" alt="이미지"></p>
<p>코드 세계에서 거짓말은 현실 세계에서와 마찬가지로 치명적일 수 있습니다. TypeScript 컴파일러를 속이면 전체 응용 프로그램의 무결성이 위험에 빠집니다. 모든 X와 같이 알 수 없는 것은 시간이 지남에 따라 증가할 수 있는 가격이 따릅니다.</p>
<p>이 기사는 다음 측면을 밝히는 데 목표를 두고 있습니다:</p>
<ul>
<li>코드베이스로 속임수를 도입하는 메커니즘</li>
<li>이러한 실천으로 이어지는 근본적인 이유들</li>
<li>기만의 사이클에서 벗어나 보다 투명한 코딩 접근 방식을 채택하는 전략</li>
</ul>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>Chapter 1: 속임수의 기술</h1>
<p>우선, "거짓말"의 정의부터 시작해 봅시다:</p>
<p>하지만 거짓말은 프로그래밍과 무슨 공통점이 있는 걸까요 🤔? 실은 상당히 많은 부분이 비슷합니다.</p>
<p><img src="/TIL/assets/img/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript_2.png" alt="이미지"></p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이제 거짓의 정의를 이해했으니, 우리에게 한 가지 질문을 해 보겠습니다:</p>
<p>그럼, 한 가지 더 물어볼게요: 코드로 무언가를 수행하려고 하는 상황에서 TypeScript가 너무 엄격하거나 필요한 유연성을 제공하지 않는 상황에 처했던 적이 있나요? 혹시 '유형 단언'이나 명시적 형 변환을 시도해 보았는데, 컴파일러를 속이는 방법으로 기술적으로 올바르지만 예상과 맞지 않는 코드를 수용하도록 했던 적이 있나요?</p>
<p>TypeScript는 우리 코드의 유형을 추론하는 데 탁월한 성과를 거두고 있습니다. 예를 들어, 이 스니펫에서 애완동물의 유형을 완벽하게 포착해냅니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> pets = [<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bird</span>()];
<span class="hljs-keyword">let</span> <span class="hljs-attr">pets</span>: (<span class="hljs-title class_">Dog</span> | <span class="hljs-title class_">Cat</span> | <span class="hljs-title class_">Bird</span>)[];
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>실제 코딩은 종종 예상과는 다르게 복잡할 때가 많아요!</p>
<p>개발자 생활에서 아래와 같은 경우를 만날 수도 있습니다:</p>
<h2>사례 1.</h2>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> params = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">location</span>).<span class="hljs-property">searchParams</span>;
<span class="hljs-keyword">const</span> name = params.<span class="hljs-title function_">get</span>(<span class="hljs-string">"name"</span>);

<span class="hljs-keyword">const</span> hello = <span class="hljs-string">`Welcome <span class="hljs-subst">${name!}</span>`</span>;
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>Case 2.</h2>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">ColorsEnum</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'happy-lib/colors'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">LocalColorsEnum</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'../enums/color'</span>;
...

<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleColorChange</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">colorToUpdate: LocalColorsEnum</span>) => {
    <span class="hljs-keyword">await</span> <span class="hljs-title function_">callImaginaryApi</span>(<span class="hljs-string">'/colors'</span>, {
        <span class="hljs-attr">color</span>: colorToUpdate <span class="hljs-keyword">as</span> unknown <span class="hljs-keyword">as</span> <span class="hljs-title class_">ColorsEnum</span>
    })
}
</code></pre>
<h2>Case 3.</h2>
<pre><code class="hljs language-js">type <span class="hljs-title class_">UserType</span> = <span class="hljs-string">'admin'</span> | <span class="hljs-string">'superadmin'</span> | <span class="hljs-string">'user'</span>
type <span class="hljs-title class_">SpecialUsers</span> = <span class="hljs-title class_">Extract</span>&#x3C;<span class="hljs-title class_">UserType</span>, <span class="hljs-string">'admin'</span> | <span class="hljs-string">'superadmin'</span>>

<span class="hljs-keyword">const</span> allowList = [<span class="hljs-string">'admin'</span>, <span class="hljs-string">'superadmin'</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span> satisfies <span class="hljs-title class_">SpecialUsers</span>[];

<span class="hljs-keyword">const</span> <span class="hljs-title function_">doAdminStuff</span> = (<span class="hljs-params">userType: SpecialUsers</span>) => {
  <span class="hljs-comment">// magic</span>
}

<span class="hljs-keyword">const</span> <span class="hljs-title function_">checkIfAllowed</span> = (<span class="hljs-params">userType: UserType</span>) => {
  <span class="hljs-keyword">if</span> (allowList.<span class="hljs-title function_">includes</span>(userType)) {
    <span class="hljs-title function_">doAdminStuff</span>(userType <span class="hljs-keyword">as</span> <span class="hljs-title class_">SpecialUsers</span>)
  }
}
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이제 한 발자국 물러나서 이 경우들을 다시 살펴보고 "거짓말"을 찾아보세요.</p>
<p><img src="/TIL/assets/img/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript_3.png" alt="이미지"></p>
<p>찾았나요? 네, 아니오? (혹시라도? 모르겠어요). 네라면, 축하해요 🎉 찾지 못했다면 걱정마시고 계속해서 읽어보세요.</p>
<p>우리 함께 모든 경우를 해결해 낼 거에요 💪.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>케이스 1</h2>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> params = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">location</span>).<span class="hljs-property">searchParams</span>;
<span class="hljs-keyword">const</span> name = params.<span class="hljs-title function_">get</span>(<span class="hljs-string">"name"</span>);

<span class="hljs-keyword">const</span> hello = <span class="hljs-string">`환영합니다, <span class="hljs-subst">${name}</span>님!`</span>;
</code></pre>
<p>여기에는 URL에서 검색 매개변수를 구문 분석하는 클래식 프론트엔드 사례가 있습니다. 이름 매개변수를 검색하고 환영 메시지를 반환하려고 합니다. 안타깝게도, 이 코드는 거짓말을 하고 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> hello = <span class="hljs-string">`환영합니다, <span class="hljs-subst">${name}</span>님!`</span>;
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>당신이 왜 이것을 문제로 생각하는지 궁금할 수도 있습니다. URL에 이름 매개변수가 없는 경우, "이름이 정의되지 않은 상태에서 '안녕하세요'가 표시됩니다. 코드에는 TypeScript에게 모든 것이 괜찮다고 확신하는! - non-null assertion operator가 포함되어 있습니다. (여기서는 사실이 아닙니다 😠). 우리에게 다행히, 해결책은 간단합니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> params = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">location</span>).<span class="hljs-property">searchParams</span>;
<span class="hljs-keyword">const</span> name = params.<span class="hljs-title function_">get</span>(<span class="hljs-string">"name"</span>);

<span class="hljs-keyword">if</span> (!name) {
  <span class="hljs-comment">// 오류 케이스를 좀 더 세련되게 처리</span>
}

<span class="hljs-keyword">const</span> hello = <span class="hljs-string">`환영합니다 <span class="hljs-subst">${name}</span>`</span>;
</code></pre>
<p>TypeScript를 사용하여 narrowing을 하고, 오래된 if 문의 도움으로 이제 if 블록 바깥에서 name을 사용할 때 항상 값이 있다고 확신할 수 있습니다. 잠재적인 오류를 숨겨도 오류가 사라질 것이라는 보장은 없다는 것을 기억하는 것이 매우 중요합니다.</p>
<h2>케이스 2</h2>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">ColorsEnum</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'happy-lib/colors'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">LocalColorsEnum</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'../enums/color'</span>;
...

<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleColorChange</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">colorToUpdate: LocalColorsEnum</span>) => {
    <span class="hljs-keyword">await</span> <span class="hljs-title function_">callImaginaryApi</span>(<span class="hljs-string">'/colors'</span>, {
        <span class="hljs-attr">color</span>: colorToUpdate <span class="hljs-keyword">as</span> unknown <span class="hljs-keyword">as</span> <span class="hljs-title class_">ColorsEnum</span>
    })
}
</code></pre>
<p>여기서 볼 수 있는 것은 상상 속의 API를 사용하여 색상을 업데이트하는 간단한 경우입니다. 현재 코드가 어떻게 보이는지에 따라 모든 것이 괜찮아 보입니다. 수동으로 작동을 테스트하고 유닛 테스트를 추가했습니다. 네, colorToUpdate을 다른 열거형으로 수용하지만, 값이 동일하고 변경되지 않을 것을 알고 있습니다.</p>
<p>불행하게도, 위의 줄은 거짓말이 들어 있으며 찾기 어려운 것입니다.</p>
<p>아래 줄에 집중해보겠습니다:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">...
<span class="hljs-attr">color</span>: colorToUpdate <span class="hljs-keyword">as</span> unknown <span class="hljs-keyword">as</span> <span class="hljs-title class_">ColorsEnum</span>
...
</code></pre>
<p>이 코드는 TypeScript에게 다음을 알려줍니다:</p>
<p>happy-lib/colors 패키지가 주요 패치를 받을 경우를 가정해 봅시다. 알 수없는 이유로 ColorsEnum이 변경되어 열거형의 키 케이싱이 바뀝니다. 이러한 열거형은 더 이상 동일한 값을 보유하지 않습니다. TypeScript 컴파일러는 이러한 사항에 대해 경고하지 않고 단위 테스트에서는 문제를 포착하지 못할 것입니다. 이 문제를 포착하는 것은 수동 또는 엔드투엔드 테스트에 달려 있습니다. 그러나 이럴 필요는 없습니다.</p>
<p>우리는 진실을 이야기하기 위해 이 코드를 다시 작성해보겠습니다. 이 연습의 목적을 위해 colorToUpdate 유형을 변경할 수 없으며, 이 작업을 함수 내부에서 처리해야 합니다. TypeScript(또는 JavaScript)에서 열거형을 비교하는 것은 어렵습니다. 우리가 할 수 있는 것은 번역기를 작성하거나(또는 사전을 사용하는 것)하는 것입니다:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">transformColorEnum</span>(<span class="hljs-params">localColor: LocalColorsEnum</span>): <span class="hljs-title class_">ColorsEnum</span> | <span class="hljs-literal">null</span> {
  <span class="hljs-keyword">switch</span> (localColor.<span class="hljs-title function_">toString</span>()) {
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">LocalColorsEnum</span>.<span class="hljs-property">Red</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">ColorsEnum</span>.<span class="hljs-property">Red</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">LocalColorsEnum</span>.<span class="hljs-property">Green</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">ColorsEnum</span>.<span class="hljs-property">Green</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">LocalColorsEnum</span>.<span class="hljs-property">Blue</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">ColorsEnum</span>.<span class="hljs-property">Blue</span>;
    <span class="hljs-attr">default</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
}

<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleColorChange</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">colorToUpdate: LocalColorsEnum</span>) => {
  <span class="hljs-keyword">const</span> translatedColor = <span class="hljs-title function_">transformColorEnum</span>(colorToUpdate);

  <span class="hljs-keyword">if</span> (!translatedColor) {
    <span class="hljs-comment">// 에러 케이스를 처리하세요</span>
  }

  <span class="hljs-keyword">await</span> <span class="hljs-title function_">callImaginaryApi</span>(<span class="hljs-string">"/colors"</span>, {
    <span class="hljs-attr">color</span>: colorToUpdate,
  });
};
</code></pre>
<p>여기서 우리는 무엇을 달성했을까요? 이제 API 변경으로 인해 잘못된 값이 전송되는 경우를 방지할 수 있게 되었습니다.</p>
<p>맞아요. 이 코드를 개선할 다양한 방법이 있습니다(어떤 라이브러리도 사용하지 않고도), 하지만 이번에는 Zod 라이브러리를 사용하여 이를 처리하는 방법을 보여드리고 싶었어요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> z <span class="hljs-keyword">from</span> <span class="hljs-string">"zod"</span>;

<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleColorChange</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">colorToUpdate: LocalColorsEnum</span>) => {
  <span class="hljs-keyword">const</span> translatedColor = z.<span class="hljs-title function_">nativeEnum</span>(<span class="hljs-title class_">ColorsEnum</span>).<span class="hljs-title function_">safeParse</span>(colorToUpdate);

  <span class="hljs-keyword">if</span> (!translatedColor.<span class="hljs-property">success</span>) {
    <span class="hljs-comment">// 에러 케이스를 처리하세요</span>
  }

  <span class="hljs-keyword">await</span> <span class="hljs-title function_">callImaginaryApi</span>(<span class="hljs-string">"/colors"</span>, {
    <span class="hljs-attr">color</span>: colorToUpdate,
  });
};
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>케이스 3</h2>
<pre><code class="hljs language-js">type <span class="hljs-title class_">UserType</span> = <span class="hljs-string">'admin'</span> | <span class="hljs-string">'superadmin'</span> | <span class="hljs-string">'user'</span>
type <span class="hljs-title class_">SpecialUsers</span> = <span class="hljs-title class_">Extract</span>&#x3C;<span class="hljs-title class_">UserType</span>, <span class="hljs-string">'admin'</span> | <span class="hljs-string">'superadmin'</span>>

<span class="hljs-keyword">const</span> allowList = [<span class="hljs-string">'admin'</span>, <span class="hljs-string">'superadmin'</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span> satisfies <span class="hljs-title class_">SpecialUsers</span>[];

<span class="hljs-keyword">const</span> <span class="hljs-title function_">doAdminStuff</span> = (<span class="hljs-params">userType: SpecialUsers</span>) => {
  <span class="hljs-comment">// magic</span>
}

<span class="hljs-keyword">const</span> <span class="hljs-title function_">checkIfAllowed</span> = (<span class="hljs-params">userType: UserType</span>) => {
  <span class="hljs-keyword">if</span> (allowList.<span class="hljs-title function_">includes</span>(userType)) {
    <span class="hljs-title function_">doAdminStuff</span>(userType <span class="hljs-keyword">as</span> <span class="hljs-title class_">SpecialUsers</span>)
  }
}
</code></pre>
<p>이미 1과 2번 케이스를 해결했다면, 여기서 형 변환을 하고 있다는 것을 빠르게 지적할 수 있을 것입니다. 그리고 당신은 맞을 것입니다! 다행히 이번에는 상황이 심각하지는 않습니다. 사용자가 권한 배열에 포함되어 있는지 확인하기 때문에 안전합니다. 그러나 우리는 가져야 할 정보 유형을 잃어버렸습니다. 거의 동일한 로직을 유지하면서 정보 유형을 복구해 봅시다.</p>
<pre><code class="hljs language-js">type <span class="hljs-title class_">UserType</span> = <span class="hljs-string">'admin'</span> | <span class="hljs-string">'superadmin'</span> | <span class="hljs-string">'user'</span>;
type <span class="hljs-title class_">SpecialUsers</span> = <span class="hljs-title class_">Extract</span>&#x3C;<span class="hljs-title class_">UserType</span>, <span class="hljs-string">'admin'</span> | <span class="hljs-string">'superadmin'</span>>;

<span class="hljs-keyword">const</span> allowList = [<span class="hljs-string">'admin'</span>, <span class="hljs-string">'superadmin'</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span> satisfies <span class="hljs-title class_">SpecialUsers</span>[];

<span class="hljs-keyword">const</span> <span class="hljs-title function_">doAdminStuff</span> = (<span class="hljs-params">userType: SpecialUsers</span>) => {
  <span class="hljs-comment">// magic</span>
};

<span class="hljs-keyword">const</span> isSpecialUser = (<span class="hljs-attr">userType</span>: <span class="hljs-title class_">UserType</span>): userType is <span class="hljs-title class_">SpecialUsers</span> => {
  <span class="hljs-keyword">return</span> allowList.<span class="hljs-title function_">includes</span>(userType <span class="hljs-keyword">as</span> <span class="hljs-title class_">SpecialUsers</span>);
};

<span class="hljs-keyword">const</span> <span class="hljs-title function_">checkIfAllowed</span> = (<span class="hljs-params">userType: UserType</span>) => {
  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isSpecialUser</span>(userType)) {
    <span class="hljs-title function_">doAdminStuff</span>(userType);
  }
};
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 형변환(casting)이 안전한 이유는 <code>isSpecialUser</code> 유형 가드 함수 내부에서 사용하기 때문입니다. TypeScript는 includes 확인이 통과되면 <code>userType</code>이 <code>SpecialUsers</code> 유형이어야 한다는 것을 이해합니다. 따라서 형변환은 안전하며 유형 안전성을 위반하지 않습니다. 이렇게 하면 <code>userType</code> 변수는 if 블록의 범위 내에서 <code>SpecialUsers</code> 유형을 유지합니다.</p>
<p><img src="/TIL/assets/img/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript_4.png" alt="이미지"></p>
<p>3/3 사건 마무리 수사관 - 훌륭한 일했어요.</p>
<h1>2장: 거짓말의 해부학.</h1>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>저희 코드에서 문제점을 파악했습니다. 이제는 그 문제들이 처음에 발생한 이유를 이해해야 합니다.</p>
<p>코딩 세계에서는 종종 특정 목표를 이루기 위해 의도적으로 유형이나 데이터 구조를 조작하는 상황에 처합니다. 실생활에서 무언가에 대해 확신이 없거나 단축키를 사용하길 원할 때 사람들이 진실을 왜곡하는 것과 비슷한 상황이죠.</p>
<h2>알 수 없는 데이터</h2>
<p>가장 일반적으로 '거짓말'을 하는 경우는 데이터가 불확실한 출처에서 올 때입니다. 예를 들어, 이 코드 조각을 살펴보죠:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-comment">// API에서 사용자 데이터를 가져옵니다</span>
<span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getUsers</span>();
<span class="hljs-keyword">const</span> users = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();
</code></pre>
<p>사용자가 특정 유형임을 정확히 알 수 있을까요? 대부분, 다음과 같은 것을 볼 수 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-attr">users</span>: <span class="hljs-title class_">Users</span> = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>() <span class="hljs-keyword">as</span> <span class="hljs-title class_">Users</span>;
</code></pre>
<p>대부분의 경우에는 잘 작동합니다. 그러나 이 코드는 실제로 안전하지 않습니다. 우리가 호출하는 엔드포인트가 지정된 형식의 데이터를 반환하는지 알 방법이 없습니다. 유형 단언(as Users)을 사용하여 사실상 코드에 거짓말을 하고 원하는 것이 맞다고 코드에 알려주는 것입니다. 하지만 이러한 "소백한 거짓말"은 종종 미래 문제의 근본 원인이 되며 오류 케이스를 무시합니다. getUsers가 반환하는 유형이 변경되면 어떻게 될까요? TypeScript에 모든 것이 괜찮고 특정 유형(e.g., Users)이 반환될 것이 확실하다고 확신할 수 있지만, 실제로는 코드가 예기치 않은 유형을 처리할 준비가 되어 있지 않습니다. 이는 프로덕션 코드를 망가뜨릴 수 있는 런타임 오류로 이어질 수 있습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<img src="/TIL/assets/img/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript_5.png">
<h2>게으름 (좋은겁니다 😎)</h2>
<p>가끔은 사소해 보이지만 디버깅하기 어려울 수 있는 거짓말도 있어요.</p>
<p>예를 들어 단위 테스트에서 대량의 모의 객체가 있는 경우를 생각해봅시다. 특정 속성만 신경 쓰지만 자동완성과 타입 안전성의 이점을 원한다면, 이런 식의 코드가 될 수 있습니다:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-attr">veryBigObjectMock</span>: <span class="hljs-title class_">BigObjectType</span> = {
    ...{} <span class="hljs-keyword">as</span> <span class="hljs-title class_">BigObjectType</span>,
    <span class="hljs-attr">keyIWantToMock</span>: <span class="hljs-string">'myMock'</span>
};
</code></pre>
<p>컴파일러가 만족하고 테스트가 의도대로 실행됩니다...지금까지는요. 그러나 어느 날 테스트가 실패하면서 데이터 구조가 변경되었다는 것을 알고 있음에도 TypeScript의 타입 체커(tsc)가 문제를 보고하지 않는 것을 발견할 수 있습니다. 아마도 당신이 로직을 잘못 이해한 것인지 생각해 볼지도 모르겠죠.</p>
<p>무엇이 잘못되었는지 알아내려고 몇 시간을 낭비한 후, 오래된 키 이름을 가진 잊혀진 목 객체를 기억낼 수 있습니다. 시간을 낭비한 셈이죠.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>준비되지 않은 데이터 사용</h2>
<p>준비되지 않은 데이터를 사용하는 것은 일반적인 함정일 수 있습니다. 우리는 밑바닥 데이터를 안전하게 사용할 수 있는지 확인하지 않고 속성이나 메서드에 액세스하려는 유혹을 느낄 수 있습니다.</p>
<p>예를 살펴봅시다. 비동기적으로 가져온 할 일 항목을 표시하는 TodoList 컴포넌트가 있다고 가정해 봅시다. 이 할 일 항목은 리덕스의 useSelector 훅을 통해 반환됩니다 (물론 다른 상태 관리 라이브러리일 수도 있습니다):</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> { useSelector } <span class="hljs-keyword">from</span> <span class="hljs-string">"react-redux"</span>;

type <span class="hljs-title class_">Todo</span> = { <span class="hljs-attr">id</span>: string, <span class="hljs-attr">name</span>: string };

<span class="hljs-keyword">const</span> <span class="hljs-title function_">TodoList</span> = (<span class="hljs-params"></span>) => {
  <span class="hljs-keyword">const</span> <span class="hljs-attr">todos</span>: <span class="hljs-title class_">Todo</span>[] | <span class="hljs-literal">null</span> = <span class="hljs-title function_">useSelector</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =></span> state.<span class="hljs-property">todos</span>);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">ul</span>></span>
      {todos?.map((todo) => (
        <span class="hljs-tag">&#x3C;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{todo.id}</span>></span>{todo.name}<span class="hljs-tag">&#x3C;/<span class="hljs-name">li</span>></span>
      ))}
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">ul</span>></span></span>
  );
};
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">TodoList</span>;
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 컴포넌트를 사용할 때는 잘 렌더링됩니다. 그러나 주의 깊게 관찰하거나 인터넷 연결이 느린 경우에는 1초 미만의 깜빡임이 발생할 수도 있습니다. 하지만 받는 데 시간이 걸리는 경우나 애플리케이션에서 할 일 항목에 대한 실시간 업데이트를 보여주려는 경우에는 어떨까요? 이 순진한 방법을 사용하면 사용자 경험이 좋지 않을 수 있습니다. TypeScript는 할 일 항목이 비어 있을 수 있다고 알려줬는데도 우리는 그 경고를 무시하기로 결정했습니다.</p>
<h1>제 3장: 진실의 힘.</h1>
<p><img src="/TIL/assets/img/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript_6.png" alt="이미지"></p>
<p>지금까지 코드에서 거짓이 어떻게 보이는지와 그 코드베이스에 나타난 이유에 중점을 두었습니다. 그러나 우리는 진실을 말할 수 있는 방법이 무엇이며 어떻게 거짓을 멈출 수 있을까요?</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>다행히도, 쉬운 일은 아니지만 우리 삶을 많이 개선해 줄 것입니다.</p>
<p><strong>Typescript을 믿으세요.</strong></p>
<p>Typescript는 당신을 위해 최선을 다해줍니다. 당신에게 경고를 주고 실수를 예방해줍니다. 코드에서 보이는 오류와 경고에는 그 이유가 있습니다.</p>
<p><strong>엄격한 eslint 및 tsconfig 규칙을 추가하세요.</strong></p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>자동화할 수 있는 것은 자동화하고 엄격한 @typescript-eslint 구성을 사용하세요. 이는 오류를 보여주는 것뿐만 아니라 미래 실수를 방지하는 데 도움이 될 수 있습니다. 최상의 관행과 권장 사항을 사용하여 tsconfig를 설정하세요 (예: <a href="https://www.totaltypescript.com/tsconfig-cheat-sheet" rel="nofollow" target="_blank">https://www.totaltypescript.com/tsconfig-cheat-sheet</a>). 이렇게 하면 올바른 방향으로 유지될 수 있습니다. 수동으로 확인할 필요가 줄수록 더 좋습니다.</p>
<h2>TypeScript에게 일을 시키세요.</h2>
<p>if-else 조건문 및 switch 문과 같은 흐름 제어문을 사용하면 TypeScript가 변수 유형에 대한 이해를 더욱 정확하게 할 수 있습니다. 다음과 같이 할 수 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-attr">optionalValue</span>: string | <span class="hljs-literal">null</span> = <span class="hljs-title function_">getOptionalValue</span>();

<span class="hljs-keyword">if</span> (!optionalValue) {
  <span class="hljs-keyword">return</span>;
} <span class="hljs-keyword">else</span> {
  <span class="hljs-comment">// 코드의 나머지 부분</span>
}
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>optionalValue에 값이 항상 있으므로 else 본문에서 수동 타입 체크가 필요하지 않습니다.</p>
<h2>확실히 움직이세요.</h2>
<p>값이 undefined 또는 null일 가능성이 있는 경우, 그러한 경우가 발생할 가능성이 높으므로 이에 대비하고 정상적으로 처리하세요. 입력 유효성 검사, 방어적 프로그래밍 및 타입 체크를 통해 가능성을 좁힙니다. 기본값 제공, 오류 처리 구현, 그리고 작업 전에 이러한 경우를 확인하고 처리하는 방어적 코드 작성과 같은 전략을 활용하세요.</p>
<h2>런타임에서 유효성 검사하세요.</h2>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>예방 조치인 입력 유효성 검사와 유형 검사와 같은 것들은 중요하지만, 알려지지 않거나 신뢰할 수 없는 객체를 다룰 때는 런타임에 데이터를 유효성 검사하는 것이 매우 중요합니다. 이를 달성하는 강력한 도구 중 하나는 zod입니다. TypeScript를 기반으로 한 스키마 유효성 검사 라이브러리로 데이터의 예상 형태와 유형을 정의하는 엄격한 스키마를 설정할 수 있습니다. 데이터 구조물의 청사진과 같은 개념입니다! Zod를 사용하면 런타임에서 잘못된 또는 예기치 않은 데이터에 대해 경고를 내어주는 강력한 스키마를 만들 수 있습니다. 예를 들어, 외부 API나 사용자 입력에서 데이터를 받는 경우, 해당 데이터의 예상 구조를 나타내는 Zod 스키마를 정의하고 해당 스키마를 사용하여 들어오는 데이터를 유효성 검사할 수 있습니다. 이를 통해 지정된 유형, 형태 및 제약 조건을 준수하는지 확인할 수 있습니다. 데이터가 이러한 기대에 미치지 않는 경우, Zod는 유용한 오류를 발생시켜 이 문제를 세련되게 처리할 수 있게 도와줍니다. 또한, 유형 가드나 어서션 함수와 같은 기술을 구현하는 자체 파서를 작성할 수도 있습니다.</p>
<h1>Chapter 4: 마무리.</h1>
<p>TypeScript의 타입 어설션을 사용하면 값의 유형에 대해 컴파일러에게 거짓 정보를 전달할 수 있습니다. 유효한 사용 사례가 제한적이지만 자주 남용되며, 정적 유형 확인 목적을 해치는 잔인한 유형 오류를 초래할 수 있습니다.</p>
<p>완벽한 세상에서는 사용하는 라이브러리에서 모든 타이핑을 처리할 수 있고 가능한 한 순수 JavaScript에 가까운 코드만 작성할 수 있을 것입니다. 불행하게도, 이것은 현실적으로 어렵고, 타입을 어떻게 구조화할지에 대해 신중해야 합니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>TypeScript는 개발자가 오류를 잡고 코드 품질을 향상시키는 데 도움을 주도록 설계되었지만, 마법같은 해결책은 아닙니다. 여전히 그 아래에는 옛날의 JavaScript가 있다는 것을 기억해야 합니다. TypeScript는 정적 유형 검사를 위한 강력한 도구를 제공하지만 모든 잠재적인 런타임 오류를 제거할 수는 없습니다.</p>
<p>이 글을 처음부터 끝까지 함께 읽어주셔서 감사합니다. 그리고 기억하세요:</p>
<p>거짓말 하지 마세요.</p>
<p><img src="/TIL/assets/img/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript_7.png" alt="이미지"></p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"TypeScript와 함께 작업할 때 정직이 최선의 정책인 이유  거짓말의 대가","description":"","date":"2024-07-02 21:49","slug":"2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript","content":"\n![이미지](/TIL/assets/img/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript_0.png)\n\n# 서문\n\n코드베이스로 새로운 풀 리퀘스트 '라이브러리 A 마이너 업데이트'를 받았다고 상상해보세요. 변경 사항을 검토하고 모든 것이 좋아 보입니다: 유닛 테스트를 통과했고, 통합 테스트가 성공했으며, 수동 테스트에서는 문제가 발견되지 않았습니다. 자신감을 갖고 PR을 프로덕션에 병합합니다. 성공적인 배포 후, 한 잠깐 쉬어도 좋을 것 같은 시간에 복어 잇님 모님 캆시 닦고 동료들과 이야기를 나눕니다. 정말 좋은 하루가 되고 있습니다.\n\n그러나 당신이 책상에 돌아가 앉은 순간, 예상치 못한 광경이 당신을 반격합니다: 슬랙 인박스에 99개의 읽지 않은 메시지가 있는 것입니다. 무엇이 잘못되었을까요?\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/TIL/assets/img/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript_1.png)\n\n코드 세계에서 거짓말은 현실 세계에서와 마찬가지로 치명적일 수 있습니다. TypeScript 컴파일러를 속이면 전체 응용 프로그램의 무결성이 위험에 빠집니다. 모든 X와 같이 알 수 없는 것은 시간이 지남에 따라 증가할 수 있는 가격이 따릅니다.\n\n이 기사는 다음 측면을 밝히는 데 목표를 두고 있습니다:\n\n- 코드베이스로 속임수를 도입하는 메커니즘\n- 이러한 실천으로 이어지는 근본적인 이유들\n- 기만의 사이클에서 벗어나 보다 투명한 코딩 접근 방식을 채택하는 전략\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Chapter 1: 속임수의 기술\n\n우선, \"거짓말\"의 정의부터 시작해 봅시다:\n\n하지만 거짓말은 프로그래밍과 무슨 공통점이 있는 걸까요 🤔? 실은 상당히 많은 부분이 비슷합니다.\n\n![이미지](/TIL/assets/img/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript_2.png)\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 거짓의 정의를 이해했으니, 우리에게 한 가지 질문을 해 보겠습니다:\n\n그럼, 한 가지 더 물어볼게요: 코드로 무언가를 수행하려고 하는 상황에서 TypeScript가 너무 엄격하거나 필요한 유연성을 제공하지 않는 상황에 처했던 적이 있나요? 혹시 '유형 단언'이나 명시적 형 변환을 시도해 보았는데, 컴파일러를 속이는 방법으로 기술적으로 올바르지만 예상과 맞지 않는 코드를 수용하도록 했던 적이 있나요?\n\nTypeScript는 우리 코드의 유형을 추론하는 데 탁월한 성과를 거두고 있습니다. 예를 들어, 이 스니펫에서 애완동물의 유형을 완벽하게 포착해냅니다:\n\n```js\nlet pets = [new Dog(), new Cat(), new Bird()];\nlet pets: (Dog | Cat | Bird)[];\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n실제 코딩은 종종 예상과는 다르게 복잡할 때가 많아요!\n\n개발자 생활에서 아래와 같은 경우를 만날 수도 있습니다:\n\n## 사례 1.\n\n```javascript\nconst params = new URL(document.location).searchParams;\nconst name = params.get(\"name\");\n\nconst hello = `Welcome ${name!}`;\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Case 2.\n\n```js\nimport { ColorsEnum } from 'happy-lib/colors';\nimport { LocalColorsEnum } from '../enums/color';\n...\n\nconst handleColorChange = async (colorToUpdate: LocalColorsEnum) =\u003e {\n    await callImaginaryApi('/colors', {\n        color: colorToUpdate as unknown as ColorsEnum\n    })\n}\n```\n\n## Case 3.\n\n```js\ntype UserType = 'admin' | 'superadmin' | 'user'\ntype SpecialUsers = Extract\u003cUserType, 'admin' | 'superadmin'\u003e\n\nconst allowList = ['admin', 'superadmin'] as const satisfies SpecialUsers[];\n\nconst doAdminStuff = (userType: SpecialUsers) =\u003e {\n  // magic\n}\n\nconst checkIfAllowed = (userType: UserType) =\u003e {\n  if (allowList.includes(userType)) {\n    doAdminStuff(userType as SpecialUsers)\n  }\n}\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 한 발자국 물러나서 이 경우들을 다시 살펴보고 \"거짓말\"을 찾아보세요.\n\n![이미지](/TIL/assets/img/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript_3.png)\n\n찾았나요? 네, 아니오? (혹시라도? 모르겠어요). 네라면, 축하해요 🎉 찾지 못했다면 걱정마시고 계속해서 읽어보세요.\n\n우리 함께 모든 경우를 해결해 낼 거에요 💪.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 케이스 1\n\n```js\nconst params = new URL(document.location).searchParams;\nconst name = params.get(\"name\");\n\nconst hello = `환영합니다, ${name}님!`;\n```\n\n여기에는 URL에서 검색 매개변수를 구문 분석하는 클래식 프론트엔드 사례가 있습니다. 이름 매개변수를 검색하고 환영 메시지를 반환하려고 합니다. 안타깝게도, 이 코드는 거짓말을 하고 있습니다.\n\n```js\nconst hello = `환영합니다, ${name}님!`;\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n당신이 왜 이것을 문제로 생각하는지 궁금할 수도 있습니다. URL에 이름 매개변수가 없는 경우, \"이름이 정의되지 않은 상태에서 '안녕하세요'가 표시됩니다. 코드에는 TypeScript에게 모든 것이 괜찮다고 확신하는! - non-null assertion operator가 포함되어 있습니다. (여기서는 사실이 아닙니다 😠). 우리에게 다행히, 해결책은 간단합니다:\n\n```js\nconst params = new URL(document.location).searchParams;\nconst name = params.get(\"name\");\n\nif (!name) {\n  // 오류 케이스를 좀 더 세련되게 처리\n}\n\nconst hello = `환영합니다 ${name}`;\n```\n\nTypeScript를 사용하여 narrowing을 하고, 오래된 if 문의 도움으로 이제 if 블록 바깥에서 name을 사용할 때 항상 값이 있다고 확신할 수 있습니다. 잠재적인 오류를 숨겨도 오류가 사라질 것이라는 보장은 없다는 것을 기억하는 것이 매우 중요합니다.\n\n## 케이스 2\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport { ColorsEnum } from 'happy-lib/colors';\nimport { LocalColorsEnum } from '../enums/color';\n...\n\nconst handleColorChange = async (colorToUpdate: LocalColorsEnum) =\u003e {\n    await callImaginaryApi('/colors', {\n        color: colorToUpdate as unknown as ColorsEnum\n    })\n}\n```\n\n여기서 볼 수 있는 것은 상상 속의 API를 사용하여 색상을 업데이트하는 간단한 경우입니다. 현재 코드가 어떻게 보이는지에 따라 모든 것이 괜찮아 보입니다. 수동으로 작동을 테스트하고 유닛 테스트를 추가했습니다. 네, colorToUpdate을 다른 열거형으로 수용하지만, 값이 동일하고 변경되지 않을 것을 알고 있습니다.\n\n불행하게도, 위의 줄은 거짓말이 들어 있으며 찾기 어려운 것입니다.\n\n아래 줄에 집중해보겠습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n...\ncolor: colorToUpdate as unknown as ColorsEnum\n...\n```\n\n이 코드는 TypeScript에게 다음을 알려줍니다:\n\nhappy-lib/colors 패키지가 주요 패치를 받을 경우를 가정해 봅시다. 알 수없는 이유로 ColorsEnum이 변경되어 열거형의 키 케이싱이 바뀝니다. 이러한 열거형은 더 이상 동일한 값을 보유하지 않습니다. TypeScript 컴파일러는 이러한 사항에 대해 경고하지 않고 단위 테스트에서는 문제를 포착하지 못할 것입니다. 이 문제를 포착하는 것은 수동 또는 엔드투엔드 테스트에 달려 있습니다. 그러나 이럴 필요는 없습니다.\n\n우리는 진실을 이야기하기 위해 이 코드를 다시 작성해보겠습니다. 이 연습의 목적을 위해 colorToUpdate 유형을 변경할 수 없으며, 이 작업을 함수 내부에서 처리해야 합니다. TypeScript(또는 JavaScript)에서 열거형을 비교하는 것은 어렵습니다. 우리가 할 수 있는 것은 번역기를 작성하거나(또는 사전을 사용하는 것)하는 것입니다:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nfunction transformColorEnum(localColor: LocalColorsEnum): ColorsEnum | null {\n  switch (localColor.toString()) {\n    case LocalColorsEnum.Red:\n      return ColorsEnum.Red;\n    case LocalColorsEnum.Green:\n      return ColorsEnum.Green;\n    case LocalColorsEnum.Blue:\n      return ColorsEnum.Blue;\n    default:\n      return null;\n  }\n}\n\nconst handleColorChange = async (colorToUpdate: LocalColorsEnum) =\u003e {\n  const translatedColor = transformColorEnum(colorToUpdate);\n\n  if (!translatedColor) {\n    // 에러 케이스를 처리하세요\n  }\n\n  await callImaginaryApi(\"/colors\", {\n    color: colorToUpdate,\n  });\n};\n```\n\n여기서 우리는 무엇을 달성했을까요? 이제 API 변경으로 인해 잘못된 값이 전송되는 경우를 방지할 수 있게 되었습니다.\n\n맞아요. 이 코드를 개선할 다양한 방법이 있습니다(어떤 라이브러리도 사용하지 않고도), 하지만 이번에는 Zod 라이브러리를 사용하여 이를 처리하는 방법을 보여드리고 싶었어요:\n\n```js\nimport z from \"zod\";\n\nconst handleColorChange = async (colorToUpdate: LocalColorsEnum) =\u003e {\n  const translatedColor = z.nativeEnum(ColorsEnum).safeParse(colorToUpdate);\n\n  if (!translatedColor.success) {\n    // 에러 케이스를 처리하세요\n  }\n\n  await callImaginaryApi(\"/colors\", {\n    color: colorToUpdate,\n  });\n};\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 케이스 3\n\n```js\ntype UserType = 'admin' | 'superadmin' | 'user'\ntype SpecialUsers = Extract\u003cUserType, 'admin' | 'superadmin'\u003e\n\nconst allowList = ['admin', 'superadmin'] as const satisfies SpecialUsers[];\n\nconst doAdminStuff = (userType: SpecialUsers) =\u003e {\n  // magic\n}\n\nconst checkIfAllowed = (userType: UserType) =\u003e {\n  if (allowList.includes(userType)) {\n    doAdminStuff(userType as SpecialUsers)\n  }\n}\n```\n\n이미 1과 2번 케이스를 해결했다면, 여기서 형 변환을 하고 있다는 것을 빠르게 지적할 수 있을 것입니다. 그리고 당신은 맞을 것입니다! 다행히 이번에는 상황이 심각하지는 않습니다. 사용자가 권한 배열에 포함되어 있는지 확인하기 때문에 안전합니다. 그러나 우리는 가져야 할 정보 유형을 잃어버렸습니다. 거의 동일한 로직을 유지하면서 정보 유형을 복구해 봅시다.\n\n```js\ntype UserType = 'admin' | 'superadmin' | 'user';\ntype SpecialUsers = Extract\u003cUserType, 'admin' | 'superadmin'\u003e;\n\nconst allowList = ['admin', 'superadmin'] as const satisfies SpecialUsers[];\n\nconst doAdminStuff = (userType: SpecialUsers) =\u003e {\n  // magic\n};\n\nconst isSpecialUser = (userType: UserType): userType is SpecialUsers =\u003e {\n  return allowList.includes(userType as SpecialUsers);\n};\n\nconst checkIfAllowed = (userType: UserType) =\u003e {\n  if (isSpecialUser(userType)) {\n    doAdminStuff(userType);\n  }\n};\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 형변환(casting)이 안전한 이유는 `isSpecialUser` 유형 가드 함수 내부에서 사용하기 때문입니다. TypeScript는 includes 확인이 통과되면 `userType`이 `SpecialUsers` 유형이어야 한다는 것을 이해합니다. 따라서 형변환은 안전하며 유형 안전성을 위반하지 않습니다. 이렇게 하면 `userType` 변수는 if 블록의 범위 내에서 `SpecialUsers` 유형을 유지합니다.\n\n![이미지](/TIL/assets/img/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript_4.png)\n\n3/3 사건 마무리 수사관 - 훌륭한 일했어요.\n\n# 2장: 거짓말의 해부학.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저희 코드에서 문제점을 파악했습니다. 이제는 그 문제들이 처음에 발생한 이유를 이해해야 합니다.\n\n코딩 세계에서는 종종 특정 목표를 이루기 위해 의도적으로 유형이나 데이터 구조를 조작하는 상황에 처합니다. 실생활에서 무언가에 대해 확신이 없거나 단축키를 사용하길 원할 때 사람들이 진실을 왜곡하는 것과 비슷한 상황이죠.\n\n## 알 수 없는 데이터\n\n가장 일반적으로 '거짓말'을 하는 경우는 데이터가 불확실한 출처에서 올 때입니다. 예를 들어, 이 코드 조각을 살펴보죠:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n// API에서 사용자 데이터를 가져옵니다\nconst response = await getUsers();\nconst users = await response.json();\n```\n\n사용자가 특정 유형임을 정확히 알 수 있을까요? 대부분, 다음과 같은 것을 볼 수 있습니다:\n\n```js\nconst users: Users = await response.json() as Users;\n```\n\n대부분의 경우에는 잘 작동합니다. 그러나 이 코드는 실제로 안전하지 않습니다. 우리가 호출하는 엔드포인트가 지정된 형식의 데이터를 반환하는지 알 방법이 없습니다. 유형 단언(as Users)을 사용하여 사실상 코드에 거짓말을 하고 원하는 것이 맞다고 코드에 알려주는 것입니다. 하지만 이러한 \"소백한 거짓말\"은 종종 미래 문제의 근본 원인이 되며 오류 케이스를 무시합니다. getUsers가 반환하는 유형이 변경되면 어떻게 될까요? TypeScript에 모든 것이 괜찮고 특정 유형(e.g., Users)이 반환될 것이 확실하다고 확신할 수 있지만, 실제로는 코드가 예기치 않은 유형을 처리할 준비가 되어 있지 않습니다. 이는 프로덕션 코드를 망가뜨릴 수 있는 런타임 오류로 이어질 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript_5.png\" /\u003e\n\n## 게으름 (좋은겁니다 😎)\n\n가끔은 사소해 보이지만 디버깅하기 어려울 수 있는 거짓말도 있어요.\n\n예를 들어 단위 테스트에서 대량의 모의 객체가 있는 경우를 생각해봅시다. 특정 속성만 신경 쓰지만 자동완성과 타입 안전성의 이점을 원한다면, 이런 식의 코드가 될 수 있습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nconst veryBigObjectMock: BigObjectType = {\n    ...{} as BigObjectType,\n    keyIWantToMock: 'myMock'\n};\n```\n\n컴파일러가 만족하고 테스트가 의도대로 실행됩니다...지금까지는요. 그러나 어느 날 테스트가 실패하면서 데이터 구조가 변경되었다는 것을 알고 있음에도 TypeScript의 타입 체커(tsc)가 문제를 보고하지 않는 것을 발견할 수 있습니다. 아마도 당신이 로직을 잘못 이해한 것인지 생각해 볼지도 모르겠죠.\n\n무엇이 잘못되었는지 알아내려고 몇 시간을 낭비한 후, 오래된 키 이름을 가진 잊혀진 목 객체를 기억낼 수 있습니다. 시간을 낭비한 셈이죠.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 준비되지 않은 데이터 사용\n\n준비되지 않은 데이터를 사용하는 것은 일반적인 함정일 수 있습니다. 우리는 밑바닥 데이터를 안전하게 사용할 수 있는지 확인하지 않고 속성이나 메서드에 액세스하려는 유혹을 느낄 수 있습니다.\n\n예를 살펴봅시다. 비동기적으로 가져온 할 일 항목을 표시하는 TodoList 컴포넌트가 있다고 가정해 봅시다. 이 할 일 항목은 리덕스의 useSelector 훅을 통해 반환됩니다 (물론 다른 상태 관리 라이브러리일 수도 있습니다):\n\n```js\nimport * as React from \"react\";\nimport { useSelector } from \"react-redux\";\n\ntype Todo = { id: string, name: string };\n\nconst TodoList = () =\u003e {\n  const todos: Todo[] | null = useSelector((state) =\u003e state.todos);\n\n  return (\n    \u003cul\u003e\n      {todos?.map((todo) =\u003e (\n        \u003cli key={todo.id}\u003e{todo.name}\u003c/li\u003e\n      ))}\n    \u003c/ul\u003e\n  );\n};\nexport default TodoList;\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 컴포넌트를 사용할 때는 잘 렌더링됩니다. 그러나 주의 깊게 관찰하거나 인터넷 연결이 느린 경우에는 1초 미만의 깜빡임이 발생할 수도 있습니다. 하지만 받는 데 시간이 걸리는 경우나 애플리케이션에서 할 일 항목에 대한 실시간 업데이트를 보여주려는 경우에는 어떨까요? 이 순진한 방법을 사용하면 사용자 경험이 좋지 않을 수 있습니다. TypeScript는 할 일 항목이 비어 있을 수 있다고 알려줬는데도 우리는 그 경고를 무시하기로 결정했습니다.\n\n# 제 3장: 진실의 힘.\n\n![이미지](/TIL/assets/img/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript_6.png)\n\n지금까지 코드에서 거짓이 어떻게 보이는지와 그 코드베이스에 나타난 이유에 중점을 두었습니다. 그러나 우리는 진실을 말할 수 있는 방법이 무엇이며 어떻게 거짓을 멈출 수 있을까요?\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다행히도, 쉬운 일은 아니지만 우리 삶을 많이 개선해 줄 것입니다.\n\n**Typescript을 믿으세요.**\n\nTypescript는 당신을 위해 최선을 다해줍니다. 당신에게 경고를 주고 실수를 예방해줍니다. 코드에서 보이는 오류와 경고에는 그 이유가 있습니다.\n\n**엄격한 eslint 및 tsconfig 규칙을 추가하세요.**\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자동화할 수 있는 것은 자동화하고 엄격한 @typescript-eslint 구성을 사용하세요. 이는 오류를 보여주는 것뿐만 아니라 미래 실수를 방지하는 데 도움이 될 수 있습니다. 최상의 관행과 권장 사항을 사용하여 tsconfig를 설정하세요 (예: https://www.totaltypescript.com/tsconfig-cheat-sheet). 이렇게 하면 올바른 방향으로 유지될 수 있습니다. 수동으로 확인할 필요가 줄수록 더 좋습니다.\n\n## TypeScript에게 일을 시키세요.\n\nif-else 조건문 및 switch 문과 같은 흐름 제어문을 사용하면 TypeScript가 변수 유형에 대한 이해를 더욱 정확하게 할 수 있습니다. 다음과 같이 할 수 있습니다:\n\n```js\nconst optionalValue: string | null = getOptionalValue();\n\nif (!optionalValue) {\n  return;\n} else {\n  // 코드의 나머지 부분\n}\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\noptionalValue에 값이 항상 있으므로 else 본문에서 수동 타입 체크가 필요하지 않습니다.\n\n## 확실히 움직이세요.\n\n값이 undefined 또는 null일 가능성이 있는 경우, 그러한 경우가 발생할 가능성이 높으므로 이에 대비하고 정상적으로 처리하세요. 입력 유효성 검사, 방어적 프로그래밍 및 타입 체크를 통해 가능성을 좁힙니다. 기본값 제공, 오류 처리 구현, 그리고 작업 전에 이러한 경우를 확인하고 처리하는 방어적 코드 작성과 같은 전략을 활용하세요.\n\n## 런타임에서 유효성 검사하세요.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예방 조치인 입력 유효성 검사와 유형 검사와 같은 것들은 중요하지만, 알려지지 않거나 신뢰할 수 없는 객체를 다룰 때는 런타임에 데이터를 유효성 검사하는 것이 매우 중요합니다. 이를 달성하는 강력한 도구 중 하나는 zod입니다. TypeScript를 기반으로 한 스키마 유효성 검사 라이브러리로 데이터의 예상 형태와 유형을 정의하는 엄격한 스키마를 설정할 수 있습니다. 데이터 구조물의 청사진과 같은 개념입니다! Zod를 사용하면 런타임에서 잘못된 또는 예기치 않은 데이터에 대해 경고를 내어주는 강력한 스키마를 만들 수 있습니다. 예를 들어, 외부 API나 사용자 입력에서 데이터를 받는 경우, 해당 데이터의 예상 구조를 나타내는 Zod 스키마를 정의하고 해당 스키마를 사용하여 들어오는 데이터를 유효성 검사할 수 있습니다. 이를 통해 지정된 유형, 형태 및 제약 조건을 준수하는지 확인할 수 있습니다. 데이터가 이러한 기대에 미치지 않는 경우, Zod는 유용한 오류를 발생시켜 이 문제를 세련되게 처리할 수 있게 도와줍니다. 또한, 유형 가드나 어서션 함수와 같은 기술을 구현하는 자체 파서를 작성할 수도 있습니다.\n\n# Chapter 4: 마무리.\n\nTypeScript의 타입 어설션을 사용하면 값의 유형에 대해 컴파일러에게 거짓 정보를 전달할 수 있습니다. 유효한 사용 사례가 제한적이지만 자주 남용되며, 정적 유형 확인 목적을 해치는 잔인한 유형 오류를 초래할 수 있습니다.\n\n완벽한 세상에서는 사용하는 라이브러리에서 모든 타이핑을 처리할 수 있고 가능한 한 순수 JavaScript에 가까운 코드만 작성할 수 있을 것입니다. 불행하게도, 이것은 현실적으로 어렵고, 타입을 어떻게 구조화할지에 대해 신중해야 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nTypeScript는 개발자가 오류를 잡고 코드 품질을 향상시키는 데 도움을 주도록 설계되었지만, 마법같은 해결책은 아닙니다. 여전히 그 아래에는 옛날의 JavaScript가 있다는 것을 기억해야 합니다. TypeScript는 정적 유형 검사를 위한 강력한 도구를 제공하지만 모든 잠재적인 런타임 오류를 제거할 수는 없습니다.\n\n이 글을 처음부터 끝까지 함께 읽어주셔서 감사합니다. 그리고 기억하세요:\n\n거짓말 하지 마세요.\n\n![이미지](/TIL/assets/img/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript_7.png)\n","ogImage":{"url":"/TIL/assets/img/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript_0.png"},"coverImage":"/TIL/assets/img/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript_0.png","tag":["Tech"],"readingTime":19},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch1\u003e서문\u003c/h1\u003e\n\u003cp\u003e코드베이스로 새로운 풀 리퀘스트 '라이브러리 A 마이너 업데이트'를 받았다고 상상해보세요. 변경 사항을 검토하고 모든 것이 좋아 보입니다: 유닛 테스트를 통과했고, 통합 테스트가 성공했으며, 수동 테스트에서는 문제가 발견되지 않았습니다. 자신감을 갖고 PR을 프로덕션에 병합합니다. 성공적인 배포 후, 한 잠깐 쉬어도 좋을 것 같은 시간에 복어 잇님 모님 캆시 닦고 동료들과 이야기를 나눕니다. 정말 좋은 하루가 되고 있습니다.\u003c/p\u003e\n\u003cp\u003e그러나 당신이 책상에 돌아가 앉은 순간, 예상치 못한 광경이 당신을 반격합니다: 슬랙 인박스에 99개의 읽지 않은 메시지가 있는 것입니다. 무엇이 잘못되었을까요?\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e코드 세계에서 거짓말은 현실 세계에서와 마찬가지로 치명적일 수 있습니다. TypeScript 컴파일러를 속이면 전체 응용 프로그램의 무결성이 위험에 빠집니다. 모든 X와 같이 알 수 없는 것은 시간이 지남에 따라 증가할 수 있는 가격이 따릅니다.\u003c/p\u003e\n\u003cp\u003e이 기사는 다음 측면을 밝히는 데 목표를 두고 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e코드베이스로 속임수를 도입하는 메커니즘\u003c/li\u003e\n\u003cli\u003e이러한 실천으로 이어지는 근본적인 이유들\u003c/li\u003e\n\u003cli\u003e기만의 사이클에서 벗어나 보다 투명한 코딩 접근 방식을 채택하는 전략\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003eChapter 1: 속임수의 기술\u003c/h1\u003e\n\u003cp\u003e우선, \"거짓말\"의 정의부터 시작해 봅시다:\u003c/p\u003e\n\u003cp\u003e하지만 거짓말은 프로그래밍과 무슨 공통점이 있는 걸까요 🤔? 실은 상당히 많은 부분이 비슷합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript_2.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이제 거짓의 정의를 이해했으니, 우리에게 한 가지 질문을 해 보겠습니다:\u003c/p\u003e\n\u003cp\u003e그럼, 한 가지 더 물어볼게요: 코드로 무언가를 수행하려고 하는 상황에서 TypeScript가 너무 엄격하거나 필요한 유연성을 제공하지 않는 상황에 처했던 적이 있나요? 혹시 '유형 단언'이나 명시적 형 변환을 시도해 보았는데, 컴파일러를 속이는 방법으로 기술적으로 올바르지만 예상과 맞지 않는 코드를 수용하도록 했던 적이 있나요?\u003c/p\u003e\n\u003cp\u003eTypeScript는 우리 코드의 유형을 추론하는 데 탁월한 성과를 거두고 있습니다. 예를 들어, 이 스니펫에서 애완동물의 유형을 완벽하게 포착해냅니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e pets = [\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDog\u003c/span\u003e(), \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCat\u003c/span\u003e(), \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBird\u003c/span\u003e()];\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003epets\u003c/span\u003e: (\u003cspan class=\"hljs-title class_\"\u003eDog\u003c/span\u003e | \u003cspan class=\"hljs-title class_\"\u003eCat\u003c/span\u003e | \u003cspan class=\"hljs-title class_\"\u003eBird\u003c/span\u003e)[];\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e실제 코딩은 종종 예상과는 다르게 복잡할 때가 많아요!\u003c/p\u003e\n\u003cp\u003e개발자 생활에서 아래와 같은 경우를 만날 수도 있습니다:\u003c/p\u003e\n\u003ch2\u003e사례 1.\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e params = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eURL\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003elocation\u003c/span\u003e).\u003cspan class=\"hljs-property\"\u003esearchParams\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e name = params.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"name\"\u003c/span\u003e);\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e hello = \u003cspan class=\"hljs-string\"\u003e`Welcome \u003cspan class=\"hljs-subst\"\u003e${name!}\u003c/span\u003e`\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003eCase 2.\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eColorsEnum\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'happy-lib/colors'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eLocalColorsEnum\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'../enums/color'\u003c/span\u003e;\n...\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehandleColorChange\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003ecolorToUpdate: LocalColorsEnum\u003c/span\u003e) =\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecallImaginaryApi\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/colors'\u003c/span\u003e, {\n        \u003cspan class=\"hljs-attr\"\u003ecolor\u003c/span\u003e: colorToUpdate \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e unknown \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eColorsEnum\u003c/span\u003e\n    })\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eCase 3.\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003etype \u003cspan class=\"hljs-title class_\"\u003eUserType\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e'admin'\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e'superadmin'\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e'user'\u003c/span\u003e\ntype \u003cspan class=\"hljs-title class_\"\u003eSpecialUsers\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eExtract\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eUserType\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'admin'\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e'superadmin'\u003c/span\u003e\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e allowList = [\u003cspan class=\"hljs-string\"\u003e'admin'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'superadmin'\u003c/span\u003e] \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e satisfies \u003cspan class=\"hljs-title class_\"\u003eSpecialUsers\u003c/span\u003e[];\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edoAdminStuff\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003euserType: SpecialUsers\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e// magic\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003echeckIfAllowed\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003euserType: UserType\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (allowList.\u003cspan class=\"hljs-title function_\"\u003eincludes\u003c/span\u003e(userType)) {\n    \u003cspan class=\"hljs-title function_\"\u003edoAdminStuff\u003c/span\u003e(userType \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSpecialUsers\u003c/span\u003e)\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이제 한 발자국 물러나서 이 경우들을 다시 살펴보고 \"거짓말\"을 찾아보세요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript_3.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e찾았나요? 네, 아니오? (혹시라도? 모르겠어요). 네라면, 축하해요 🎉 찾지 못했다면 걱정마시고 계속해서 읽어보세요.\u003c/p\u003e\n\u003cp\u003e우리 함께 모든 경우를 해결해 낼 거에요 💪.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e케이스 1\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e params = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eURL\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003elocation\u003c/span\u003e).\u003cspan class=\"hljs-property\"\u003esearchParams\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e name = params.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"name\"\u003c/span\u003e);\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e hello = \u003cspan class=\"hljs-string\"\u003e`환영합니다, \u003cspan class=\"hljs-subst\"\u003e${name}\u003c/span\u003e님!`\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기에는 URL에서 검색 매개변수를 구문 분석하는 클래식 프론트엔드 사례가 있습니다. 이름 매개변수를 검색하고 환영 메시지를 반환하려고 합니다. 안타깝게도, 이 코드는 거짓말을 하고 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e hello = \u003cspan class=\"hljs-string\"\u003e`환영합니다, \u003cspan class=\"hljs-subst\"\u003e${name}\u003c/span\u003e님!`\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e당신이 왜 이것을 문제로 생각하는지 궁금할 수도 있습니다. URL에 이름 매개변수가 없는 경우, \"이름이 정의되지 않은 상태에서 '안녕하세요'가 표시됩니다. 코드에는 TypeScript에게 모든 것이 괜찮다고 확신하는! - non-null assertion operator가 포함되어 있습니다. (여기서는 사실이 아닙니다 😠). 우리에게 다행히, 해결책은 간단합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e params = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eURL\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003elocation\u003c/span\u003e).\u003cspan class=\"hljs-property\"\u003esearchParams\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e name = params.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"name\"\u003c/span\u003e);\n\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!name) {\n  \u003cspan class=\"hljs-comment\"\u003e// 오류 케이스를 좀 더 세련되게 처리\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e hello = \u003cspan class=\"hljs-string\"\u003e`환영합니다 \u003cspan class=\"hljs-subst\"\u003e${name}\u003c/span\u003e`\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTypeScript를 사용하여 narrowing을 하고, 오래된 if 문의 도움으로 이제 if 블록 바깥에서 name을 사용할 때 항상 값이 있다고 확신할 수 있습니다. 잠재적인 오류를 숨겨도 오류가 사라질 것이라는 보장은 없다는 것을 기억하는 것이 매우 중요합니다.\u003c/p\u003e\n\u003ch2\u003e케이스 2\u003c/h2\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eColorsEnum\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'happy-lib/colors'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eLocalColorsEnum\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'../enums/color'\u003c/span\u003e;\n...\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehandleColorChange\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003ecolorToUpdate: LocalColorsEnum\u003c/span\u003e) =\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecallImaginaryApi\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/colors'\u003c/span\u003e, {\n        \u003cspan class=\"hljs-attr\"\u003ecolor\u003c/span\u003e: colorToUpdate \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e unknown \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eColorsEnum\u003c/span\u003e\n    })\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 볼 수 있는 것은 상상 속의 API를 사용하여 색상을 업데이트하는 간단한 경우입니다. 현재 코드가 어떻게 보이는지에 따라 모든 것이 괜찮아 보입니다. 수동으로 작동을 테스트하고 유닛 테스트를 추가했습니다. 네, colorToUpdate을 다른 열거형으로 수용하지만, 값이 동일하고 변경되지 않을 것을 알고 있습니다.\u003c/p\u003e\n\u003cp\u003e불행하게도, 위의 줄은 거짓말이 들어 있으며 찾기 어려운 것입니다.\u003c/p\u003e\n\u003cp\u003e아래 줄에 집중해보겠습니다:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e...\n\u003cspan class=\"hljs-attr\"\u003ecolor\u003c/span\u003e: colorToUpdate \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e unknown \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eColorsEnum\u003c/span\u003e\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 코드는 TypeScript에게 다음을 알려줍니다:\u003c/p\u003e\n\u003cp\u003ehappy-lib/colors 패키지가 주요 패치를 받을 경우를 가정해 봅시다. 알 수없는 이유로 ColorsEnum이 변경되어 열거형의 키 케이싱이 바뀝니다. 이러한 열거형은 더 이상 동일한 값을 보유하지 않습니다. TypeScript 컴파일러는 이러한 사항에 대해 경고하지 않고 단위 테스트에서는 문제를 포착하지 못할 것입니다. 이 문제를 포착하는 것은 수동 또는 엔드투엔드 테스트에 달려 있습니다. 그러나 이럴 필요는 없습니다.\u003c/p\u003e\n\u003cp\u003e우리는 진실을 이야기하기 위해 이 코드를 다시 작성해보겠습니다. 이 연습의 목적을 위해 colorToUpdate 유형을 변경할 수 없으며, 이 작업을 함수 내부에서 처리해야 합니다. TypeScript(또는 JavaScript)에서 열거형을 비교하는 것은 어렵습니다. 우리가 할 수 있는 것은 번역기를 작성하거나(또는 사전을 사용하는 것)하는 것입니다:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003etransformColorEnum\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003elocalColor: LocalColorsEnum\u003c/span\u003e): \u003cspan class=\"hljs-title class_\"\u003eColorsEnum\u003c/span\u003e | \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e (localColor.\u003cspan class=\"hljs-title function_\"\u003etoString\u003c/span\u003e()) {\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eLocalColorsEnum\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eRed\u003c/span\u003e:\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eColorsEnum\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eRed\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eLocalColorsEnum\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eGreen\u003c/span\u003e:\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eColorsEnum\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eGreen\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eLocalColorsEnum\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eBlue\u003c/span\u003e:\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eColorsEnum\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eBlue\u003c/span\u003e;\n    \u003cspan class=\"hljs-attr\"\u003edefault\u003c/span\u003e:\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehandleColorChange\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003ecolorToUpdate: LocalColorsEnum\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e translatedColor = \u003cspan class=\"hljs-title function_\"\u003etransformColorEnum\u003c/span\u003e(colorToUpdate);\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!translatedColor) {\n    \u003cspan class=\"hljs-comment\"\u003e// 에러 케이스를 처리하세요\u003c/span\u003e\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecallImaginaryApi\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"/colors\"\u003c/span\u003e, {\n    \u003cspan class=\"hljs-attr\"\u003ecolor\u003c/span\u003e: colorToUpdate,\n  });\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 우리는 무엇을 달성했을까요? 이제 API 변경으로 인해 잘못된 값이 전송되는 경우를 방지할 수 있게 되었습니다.\u003c/p\u003e\n\u003cp\u003e맞아요. 이 코드를 개선할 다양한 방법이 있습니다(어떤 라이브러리도 사용하지 않고도), 하지만 이번에는 Zod 라이브러리를 사용하여 이를 처리하는 방법을 보여드리고 싶었어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e z \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"zod\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehandleColorChange\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003ecolorToUpdate: LocalColorsEnum\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e translatedColor = z.\u003cspan class=\"hljs-title function_\"\u003enativeEnum\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eColorsEnum\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003esafeParse\u003c/span\u003e(colorToUpdate);\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!translatedColor.\u003cspan class=\"hljs-property\"\u003esuccess\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// 에러 케이스를 처리하세요\u003c/span\u003e\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecallImaginaryApi\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"/colors\"\u003c/span\u003e, {\n    \u003cspan class=\"hljs-attr\"\u003ecolor\u003c/span\u003e: colorToUpdate,\n  });\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e케이스 3\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003etype \u003cspan class=\"hljs-title class_\"\u003eUserType\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e'admin'\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e'superadmin'\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e'user'\u003c/span\u003e\ntype \u003cspan class=\"hljs-title class_\"\u003eSpecialUsers\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eExtract\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eUserType\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'admin'\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e'superadmin'\u003c/span\u003e\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e allowList = [\u003cspan class=\"hljs-string\"\u003e'admin'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'superadmin'\u003c/span\u003e] \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e satisfies \u003cspan class=\"hljs-title class_\"\u003eSpecialUsers\u003c/span\u003e[];\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edoAdminStuff\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003euserType: SpecialUsers\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e// magic\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003echeckIfAllowed\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003euserType: UserType\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (allowList.\u003cspan class=\"hljs-title function_\"\u003eincludes\u003c/span\u003e(userType)) {\n    \u003cspan class=\"hljs-title function_\"\u003edoAdminStuff\u003c/span\u003e(userType \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSpecialUsers\u003c/span\u003e)\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이미 1과 2번 케이스를 해결했다면, 여기서 형 변환을 하고 있다는 것을 빠르게 지적할 수 있을 것입니다. 그리고 당신은 맞을 것입니다! 다행히 이번에는 상황이 심각하지는 않습니다. 사용자가 권한 배열에 포함되어 있는지 확인하기 때문에 안전합니다. 그러나 우리는 가져야 할 정보 유형을 잃어버렸습니다. 거의 동일한 로직을 유지하면서 정보 유형을 복구해 봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003etype \u003cspan class=\"hljs-title class_\"\u003eUserType\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e'admin'\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e'superadmin'\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e'user'\u003c/span\u003e;\ntype \u003cspan class=\"hljs-title class_\"\u003eSpecialUsers\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eExtract\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eUserType\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'admin'\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e'superadmin'\u003c/span\u003e\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e allowList = [\u003cspan class=\"hljs-string\"\u003e'admin'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'superadmin'\u003c/span\u003e] \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e satisfies \u003cspan class=\"hljs-title class_\"\u003eSpecialUsers\u003c/span\u003e[];\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edoAdminStuff\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003euserType: SpecialUsers\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e// magic\u003c/span\u003e\n};\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e isSpecialUser = (\u003cspan class=\"hljs-attr\"\u003euserType\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eUserType\u003c/span\u003e): userType is \u003cspan class=\"hljs-title class_\"\u003eSpecialUsers\u003c/span\u003e =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e allowList.\u003cspan class=\"hljs-title function_\"\u003eincludes\u003c/span\u003e(userType \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSpecialUsers\u003c/span\u003e);\n};\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003echeckIfAllowed\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003euserType: UserType\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-title function_\"\u003eisSpecialUser\u003c/span\u003e(userType)) {\n    \u003cspan class=\"hljs-title function_\"\u003edoAdminStuff\u003c/span\u003e(userType);\n  }\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 형변환(casting)이 안전한 이유는 \u003ccode\u003eisSpecialUser\u003c/code\u003e 유형 가드 함수 내부에서 사용하기 때문입니다. TypeScript는 includes 확인이 통과되면 \u003ccode\u003euserType\u003c/code\u003e이 \u003ccode\u003eSpecialUsers\u003c/code\u003e 유형이어야 한다는 것을 이해합니다. 따라서 형변환은 안전하며 유형 안전성을 위반하지 않습니다. 이렇게 하면 \u003ccode\u003euserType\u003c/code\u003e 변수는 if 블록의 범위 내에서 \u003ccode\u003eSpecialUsers\u003c/code\u003e 유형을 유지합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript_4.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e3/3 사건 마무리 수사관 - 훌륭한 일했어요.\u003c/p\u003e\n\u003ch1\u003e2장: 거짓말의 해부학.\u003c/h1\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e저희 코드에서 문제점을 파악했습니다. 이제는 그 문제들이 처음에 발생한 이유를 이해해야 합니다.\u003c/p\u003e\n\u003cp\u003e코딩 세계에서는 종종 특정 목표를 이루기 위해 의도적으로 유형이나 데이터 구조를 조작하는 상황에 처합니다. 실생활에서 무언가에 대해 확신이 없거나 단축키를 사용하길 원할 때 사람들이 진실을 왜곡하는 것과 비슷한 상황이죠.\u003c/p\u003e\n\u003ch2\u003e알 수 없는 데이터\u003c/h2\u003e\n\u003cp\u003e가장 일반적으로 '거짓말'을 하는 경우는 데이터가 불확실한 출처에서 올 때입니다. 예를 들어, 이 코드 조각을 살펴보죠:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// API에서 사용자 데이터를 가져옵니다\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e response = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetUsers\u003c/span\u003e();\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e users = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e response.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e사용자가 특정 유형임을 정확히 알 수 있을까요? 대부분, 다음과 같은 것을 볼 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eusers\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eUsers\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e response.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e() \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUsers\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e대부분의 경우에는 잘 작동합니다. 그러나 이 코드는 실제로 안전하지 않습니다. 우리가 호출하는 엔드포인트가 지정된 형식의 데이터를 반환하는지 알 방법이 없습니다. 유형 단언(as Users)을 사용하여 사실상 코드에 거짓말을 하고 원하는 것이 맞다고 코드에 알려주는 것입니다. 하지만 이러한 \"소백한 거짓말\"은 종종 미래 문제의 근본 원인이 되며 오류 케이스를 무시합니다. getUsers가 반환하는 유형이 변경되면 어떻게 될까요? TypeScript에 모든 것이 괜찮고 특정 유형(e.g., Users)이 반환될 것이 확실하다고 확신할 수 있지만, 실제로는 코드가 예기치 않은 유형을 처리할 준비가 되어 있지 않습니다. 이는 프로덕션 코드를 망가뜨릴 수 있는 런타임 오류로 이어질 수 있습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript_5.png\"\u003e\n\u003ch2\u003e게으름 (좋은겁니다 😎)\u003c/h2\u003e\n\u003cp\u003e가끔은 사소해 보이지만 디버깅하기 어려울 수 있는 거짓말도 있어요.\u003c/p\u003e\n\u003cp\u003e예를 들어 단위 테스트에서 대량의 모의 객체가 있는 경우를 생각해봅시다. 특정 속성만 신경 쓰지만 자동완성과 타입 안전성의 이점을 원한다면, 이런 식의 코드가 될 수 있습니다:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003everyBigObjectMock\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eBigObjectType\u003c/span\u003e = {\n    ...{} \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBigObjectType\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003ekeyIWantToMock\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'myMock'\u003c/span\u003e\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e컴파일러가 만족하고 테스트가 의도대로 실행됩니다...지금까지는요. 그러나 어느 날 테스트가 실패하면서 데이터 구조가 변경되었다는 것을 알고 있음에도 TypeScript의 타입 체커(tsc)가 문제를 보고하지 않는 것을 발견할 수 있습니다. 아마도 당신이 로직을 잘못 이해한 것인지 생각해 볼지도 모르겠죠.\u003c/p\u003e\n\u003cp\u003e무엇이 잘못되었는지 알아내려고 몇 시간을 낭비한 후, 오래된 키 이름을 가진 잊혀진 목 객체를 기억낼 수 있습니다. 시간을 낭비한 셈이죠.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e준비되지 않은 데이터 사용\u003c/h2\u003e\n\u003cp\u003e준비되지 않은 데이터를 사용하는 것은 일반적인 함정일 수 있습니다. 우리는 밑바닥 데이터를 안전하게 사용할 수 있는지 확인하지 않고 속성이나 메서드에 액세스하려는 유혹을 느낄 수 있습니다.\u003c/p\u003e\n\u003cp\u003e예를 살펴봅시다. 비동기적으로 가져온 할 일 항목을 표시하는 TodoList 컴포넌트가 있다고 가정해 봅시다. 이 할 일 항목은 리덕스의 useSelector 훅을 통해 반환됩니다 (물론 다른 상태 관리 라이브러리일 수도 있습니다):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e * \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"react\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { useSelector } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"react-redux\"\u003c/span\u003e;\n\ntype \u003cspan class=\"hljs-title class_\"\u003eTodo\u003c/span\u003e = { \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: string, \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: string };\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eTodoList\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etodos\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eTodo\u003c/span\u003e[] | \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003euseSelector\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003estate\u003c/span\u003e) =\u003e\u003c/span\u003e state.\u003cspan class=\"hljs-property\"\u003etodos\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eul\u003c/span\u003e\u003e\u003c/span\u003e\n      {todos?.map((todo) =\u003e (\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eli\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{todo.id}\u003c/span\u003e\u003e\u003c/span\u003e{todo.name}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eli\u003c/span\u003e\u003e\u003c/span\u003e\n      ))}\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eul\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n};\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTodoList\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 컴포넌트를 사용할 때는 잘 렌더링됩니다. 그러나 주의 깊게 관찰하거나 인터넷 연결이 느린 경우에는 1초 미만의 깜빡임이 발생할 수도 있습니다. 하지만 받는 데 시간이 걸리는 경우나 애플리케이션에서 할 일 항목에 대한 실시간 업데이트를 보여주려는 경우에는 어떨까요? 이 순진한 방법을 사용하면 사용자 경험이 좋지 않을 수 있습니다. TypeScript는 할 일 항목이 비어 있을 수 있다고 알려줬는데도 우리는 그 경고를 무시하기로 결정했습니다.\u003c/p\u003e\n\u003ch1\u003e제 3장: 진실의 힘.\u003c/h1\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript_6.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e지금까지 코드에서 거짓이 어떻게 보이는지와 그 코드베이스에 나타난 이유에 중점을 두었습니다. 그러나 우리는 진실을 말할 수 있는 방법이 무엇이며 어떻게 거짓을 멈출 수 있을까요?\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e다행히도, 쉬운 일은 아니지만 우리 삶을 많이 개선해 줄 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eTypescript을 믿으세요.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eTypescript는 당신을 위해 최선을 다해줍니다. 당신에게 경고를 주고 실수를 예방해줍니다. 코드에서 보이는 오류와 경고에는 그 이유가 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e엄격한 eslint 및 tsconfig 규칙을 추가하세요.\u003c/strong\u003e\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e자동화할 수 있는 것은 자동화하고 엄격한 @typescript-eslint 구성을 사용하세요. 이는 오류를 보여주는 것뿐만 아니라 미래 실수를 방지하는 데 도움이 될 수 있습니다. 최상의 관행과 권장 사항을 사용하여 tsconfig를 설정하세요 (예: \u003ca href=\"https://www.totaltypescript.com/tsconfig-cheat-sheet\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://www.totaltypescript.com/tsconfig-cheat-sheet\u003c/a\u003e). 이렇게 하면 올바른 방향으로 유지될 수 있습니다. 수동으로 확인할 필요가 줄수록 더 좋습니다.\u003c/p\u003e\n\u003ch2\u003eTypeScript에게 일을 시키세요.\u003c/h2\u003e\n\u003cp\u003eif-else 조건문 및 switch 문과 같은 흐름 제어문을 사용하면 TypeScript가 변수 유형에 대한 이해를 더욱 정확하게 할 수 있습니다. 다음과 같이 할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eoptionalValue\u003c/span\u003e: string | \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003egetOptionalValue\u003c/span\u003e();\n\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!optionalValue) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n} \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e// 코드의 나머지 부분\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eoptionalValue에 값이 항상 있으므로 else 본문에서 수동 타입 체크가 필요하지 않습니다.\u003c/p\u003e\n\u003ch2\u003e확실히 움직이세요.\u003c/h2\u003e\n\u003cp\u003e값이 undefined 또는 null일 가능성이 있는 경우, 그러한 경우가 발생할 가능성이 높으므로 이에 대비하고 정상적으로 처리하세요. 입력 유효성 검사, 방어적 프로그래밍 및 타입 체크를 통해 가능성을 좁힙니다. 기본값 제공, 오류 처리 구현, 그리고 작업 전에 이러한 경우를 확인하고 처리하는 방어적 코드 작성과 같은 전략을 활용하세요.\u003c/p\u003e\n\u003ch2\u003e런타임에서 유효성 검사하세요.\u003c/h2\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e예방 조치인 입력 유효성 검사와 유형 검사와 같은 것들은 중요하지만, 알려지지 않거나 신뢰할 수 없는 객체를 다룰 때는 런타임에 데이터를 유효성 검사하는 것이 매우 중요합니다. 이를 달성하는 강력한 도구 중 하나는 zod입니다. TypeScript를 기반으로 한 스키마 유효성 검사 라이브러리로 데이터의 예상 형태와 유형을 정의하는 엄격한 스키마를 설정할 수 있습니다. 데이터 구조물의 청사진과 같은 개념입니다! Zod를 사용하면 런타임에서 잘못된 또는 예기치 않은 데이터에 대해 경고를 내어주는 강력한 스키마를 만들 수 있습니다. 예를 들어, 외부 API나 사용자 입력에서 데이터를 받는 경우, 해당 데이터의 예상 구조를 나타내는 Zod 스키마를 정의하고 해당 스키마를 사용하여 들어오는 데이터를 유효성 검사할 수 있습니다. 이를 통해 지정된 유형, 형태 및 제약 조건을 준수하는지 확인할 수 있습니다. 데이터가 이러한 기대에 미치지 않는 경우, Zod는 유용한 오류를 발생시켜 이 문제를 세련되게 처리할 수 있게 도와줍니다. 또한, 유형 가드나 어서션 함수와 같은 기술을 구현하는 자체 파서를 작성할 수도 있습니다.\u003c/p\u003e\n\u003ch1\u003eChapter 4: 마무리.\u003c/h1\u003e\n\u003cp\u003eTypeScript의 타입 어설션을 사용하면 값의 유형에 대해 컴파일러에게 거짓 정보를 전달할 수 있습니다. 유효한 사용 사례가 제한적이지만 자주 남용되며, 정적 유형 확인 목적을 해치는 잔인한 유형 오류를 초래할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e완벽한 세상에서는 사용하는 라이브러리에서 모든 타이핑을 처리할 수 있고 가능한 한 순수 JavaScript에 가까운 코드만 작성할 수 있을 것입니다. 불행하게도, 이것은 현실적으로 어렵고, 타입을 어떻게 구조화할지에 대해 신중해야 합니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eTypeScript는 개발자가 오류를 잡고 코드 품질을 향상시키는 데 도움을 주도록 설계되었지만, 마법같은 해결책은 아닙니다. 여전히 그 아래에는 옛날의 JavaScript가 있다는 것을 기억해야 합니다. TypeScript는 정적 유형 검사를 위한 강력한 도구를 제공하지만 모든 잠재적인 런타임 오류를 제거할 수는 없습니다.\u003c/p\u003e\n\u003cp\u003e이 글을 처음부터 끝까지 함께 읽어주셔서 감사합니다. 그리고 기억하세요:\u003c/p\u003e\n\u003cp\u003e거짓말 하지 마세요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript_7.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-07-02-ThecostofaliewhyhonestyisthebestpolicywhenworkingwithTypeScript"},"buildId":"gbGPtKGWbTgygZJ0X0J0x","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>