<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>PyTorch 입문  커스텀 데이터 사용 방법 | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2024-07-12-PyTorchIntroductionUsingCustomData" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="PyTorch 입문  커스텀 데이터 사용 방법 | TIL" data-gatsby-head="true"/><meta property="og:title" content="PyTorch 입문  커스텀 데이터 사용 방법 | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2024-07-12-PyTorchIntroductionUsingCustomData" data-gatsby-head="true"/><meta name="twitter:title" content="PyTorch 입문  커스텀 데이터 사용 방법 | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2024-07-12 20:17" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/TIL/_next/static/chunks/463-925361deb4cec4b1.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/post/%5Bslug%5D-9d7ebbd29b9e08ce.js" defer=""></script><script src="/TIL/_next/static/FuXRqV9h16krA5Mvtd6Dn/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/FuXRqV9h16krA5Mvtd6Dn/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">PyTorch 입문  커스텀 데이터 사용 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="PyTorch 입문  커스텀 데이터 사용 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jul 12, 2024</span><span class="posts_reading_time__f7YPP">19<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-07-12-PyTorchIntroductionUsingCustomData&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<img src="/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_0.png">
<p>파이토치는 현재 딥 러닝 분야에서 가장 핫한 라이브러리 중 하나입니다. ChatGPT가 출시된 이후 데이터 과학가와 머신 러닝 엔지니어들 사이에서 딥 러닝 라이브러리가 아마도 가장 많은 관심을 받고 있다고 볼 수 있습니다. 특히 이러한 라이브러리는 매우 빠르게 복잡한 다차원 계산을 수행하는 능력이 뛰어나며, 이러한 라이브러리는 우리가 신경망 모델을 훈련하는 방식을 바꾸었습니다. 특히 이러한 모델이 저장하고 최적화하는 많은 수의 가중치를 관리하는 데 매우 도움이 됩니다. TensorFlow(구글의 프레임워크)와 경쟁하며, PyTorch는 Meta의 오픈 소스 프레임워크로, 아주 멋지고 실용적인 문법을 사용하여 딥 러닝 모델을 훈련할 수 있는 기회를 제공합니다.</p>
<p>지금까지 이 PyTorch 시리즈에서 이 라이브러리를 사용하는 기본 개념을 배워왔습니다. 예를 들어:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>텐서에 대한 기본 사항을 배우기</li>
<li>PyTorch를 사용하여 처음 선형 모델(회귀)을 만드는 방법 이해하기</li>
<li>비선형 활성화 함수 및 비선형 문제 해결하는 방법 배우기</li>
</ul>
<p>저희는 예제와 이전 블로그 게시물에서 몇 가지 사용자 정의 데이터셋을 사용했습니다. 이 시리즈에서 딥 러닝 모델을 교육하는 방향으로 진행하면서, PyTorch의 맥락에서 다양한 데이터셋을 통합하는 방법을 이해하는 데 매우 도움이 됩니다. 이 블로그 게시물에서는 라이브러리에서 사용자 정의 데이터셋을 다루는 방법을 배우고, 특히 세 가지 다른 유형의 데이터를 통합하는 방법을 다룰 것입니다:</p>
<ul>
<li>CSV 파일</li>
<li>이미지 데이터</li>
<li>텍스트 데이터</li>
</ul>
<p>또한 데이터 배치의 개념에 대해 살펴보고, 이를 위해 PyTorch 사용자 정의 DataLoader를 사용하는 방법도 알아볼 것입니다. 이 블로그 게시물의 일부 영감은 Zero to Mastery Pytorch 무료 강좌에서 온 것입니다 — 많은 흥미로운 학습 예제가 있는 이 멋진 자료를 확인해보세요.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>시작해 봅시다!</p>
<h1>랜덤 데이터셋 생성</h1>
<p>먼저, Pytorch에서 랜덤 데이터셋을 생성하여 DataLoader를 어떻게 사용할 수 있는지 이해해 봅시다:</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">import</span> torch
<span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> Dataset, DataLoader

<span class="hljs-keyword">class</span> <span class="hljs-title class_">RandomIntDataset</span>(<span class="hljs-title class_ inherited__">Dataset</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, start, stop, x, y</span>):
        self.data = torch.randint(start, stop, (x,y))
        self.labels = torch.randint(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, (x,))

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.labels)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(torch.cat((self.data, self.labels.unsqueeze(<span class="hljs-number">1</span>)), <span class="hljs-number">1</span>))

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, i</span>):
        <span class="hljs-keyword">return</span> self.data[i], self.labels[i]
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>저희 RandomIntDataset은 랜덤한 torch 객체와 레이블을 생성합니다. 클래스에 던더 메서드를 도입하고 torch.utils.data.Dataset을 상속했음을 주목해주세요. (특히 데이터셋을 DataLoader와 결합할 때 유용하게 사용될 것입니다).</p>
<p>이전 클래스를 기반으로 첫 번째 데이터셋 객체를 생성해봅시다!</p>
<pre><code class="hljs language-js">dataset = <span class="hljs-title class_">RandomIntDataset</span>(<span class="hljs-number">100</span>, <span class="hljs-number">1000</span>, <span class="hljs-number">500</span>, <span class="hljs-number">10</span>)
</code></pre>
<p>다시 말씀드리지만, Pytorch의 기본 클래스를 상속받았기 때문에 DataLoader를 사용하여 좋은 이터러블을 생성할 수 있습니다:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">dataset_loader = <span class="hljs-title class_">DataLoader</span>(dataset, batch_size=<span class="hljs-number">10</span>, shuffle=<span class="hljs-title class_">True</span>)
</code></pre>
<p>신경망 내에서 데이터를 배치로 전달하는 것은 매우 흔한 일이며 DataLoader 생성자가 깔끔한 batch_size 인자를 통해 이를 처리합니다! dataset_loader는 반복 가능하므로 순차적인 데이터 배치를 얻기 위해 next 및 iter를 사용할 수 있습니다.</p>
<pre><code class="hljs language-js">data, labels = <span class="hljs-title function_">next</span>(<span class="hljs-title function_">iter</span>(dataset_loader))
data
</code></pre>
<img src="/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_1.png">
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>새로운 iteration을 실행하고 data_loader의 다음 배치가 어떻게 이동하는지 확인해보세요! 이를 통해 데이터 및 레이블 객체 내부의 다른 데이터가 표시됩니다.</p>
<p>물론, 이 무작위 데이터 세트는 실제로 "사용자 지정 데이터 세트"로 간주하기 어렵습니다. 무작위 생성된 데이터와 작업하려고 할 가능성은 매우 낮습니다. 그러나 배치 처리에 익숙해지는 데 도움이 되는 이 소개 후에 첫 번째 CSV 파일을 PyTorch 파이프라인에 포함하여 계속 진행할 준비가 되었습니다!</p>
<h1>DataLoader와 사용자 지정 데이터 세트 결합</h1>
<p>우리가 보았듯이, 무작위 데이터 세트 사용은 단순한 연습일 뿐입니다. 그러나 이제 DataLoader와 데이터 배치가 어떻게 작동하는지 알기 때문에 이 지식을 사용하여 새로운 클래스를 만들어 PyTorch 데이터 세트를 사용할 수 있습니다:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd

<span class="hljs-keyword">class</span> <span class="hljs-title class_">TaxiSample</span>(<span class="hljs-title class_ inherited__">Dataset</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">super</span>().__init__()
        df = pd.read_csv(<span class="hljs-string">'data/taxi_data_sample.csv'</span>)
        
        features = [<span class="hljs-string">'passenger_count'</span>,
                    <span class="hljs-string">'pickup_longitude'</span>,
                    <span class="hljs-string">'pickup_latitude'</span>,
                    <span class="hljs-string">'dropoff_longitude'</span>,
                    <span class="hljs-string">'dropoff_latitude'</span>]
        
        target = <span class="hljs-string">'trip_duration'</span>
        
        self.features = torch.tensor(df[features].values, 
                                     dtype=torch.float32)

        self.labels = torch.tensor(df[target].values, 
                                   dtype=torch.float32)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.labels)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, idx</span>):
        <span class="hljs-keyword">return</span> self.features[idx], self.labels[idx]
</code></pre>
<p>참고: 라이브러리를 게시물에서 지날 때까지 가져오고 있지만 모든 라이브러리는 스크립트의 처음에 가져와야 합니다!</p>
<p>우리가 사용하는 데이터셋은 Kaggle의 택시 여행 소요 시간 경쟁의 샘플 버전입니다. 여기서 csv를 init에 전달하고 있습니다 (이 기능을 더 다룰 수 있도록 인수로도 전달할 수 있습니다). DataLoader와 잘 어울리는지 확인해봅시다:</p>
<pre><code class="hljs language-python">data_taxi = TaxiSample()
dataset_loader = DataLoader(data_taxi, batch_size=<span class="hljs-number">20</span>, shuffle=<span class="hljs-literal">True</span>)
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>우리의 배치 크기가 20인 경우, 이 데이터셋에서 이터레이터를 만들 수 있습니다:</p>
<pre><code class="hljs language-js">data_iterator = <span class="hljs-title function_">iter</span>(dataset_loader)
data, labels = <span class="hljs-title function_">next</span>(data_iterator)
</code></pre>
<img src="/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_2.png">
<p>멋져요! 이것들은 데이터셋에서 무작위로 선택한 처음 20개의 예시입니다. 위 이미지에서는 피처와 해당 레이블을 확인할 수 있어요.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>있는 이미지 데이터를 사용 해보세요.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 블로그 게시물의 이 섹션에서는 이미지 데이터 처리 능력을 보여주기 위해 Microsoft Research Cats. vs Dogs. 데이터셋과 함께 Pytorch를 사용할 것입니다. 먼저 pathlib를 사용하여 경로를 정의해 보겠습니다:</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path
data_path = Path(“data/dogs_cats”)
</code></pre>
<p>폴더 안에는 강아지 이미지와 고양이 이미지가 있는 두 개의 폴더가 있습니다. 각 폴더에서 이미지 경로를 추출해 봅시다:</p>
<p><img src="/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_3.png" alt="이미지"></p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 섹션에서는 일반적인 컴퓨터 비전 변환 및 아키텍처를 제공하는 pytorch의 멋진 확장인 torchvision이 필요합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> datasets, transforms
</code></pre>
<p>다음으로 jpg 파일 이름을 읽어보겠습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">image_dogs_list = <span class="hljs-title function_">list</span>((data_path/<span class="hljs-string">'dogs'</span>).<span class="hljs-title function_">glob</span>(<span class="hljs-string">"*.jpg"</span>))
image_cats_list = <span class="hljs-title function_">list</span>((data_path/<span class="hljs-string">'cats'</span>).<span class="hljs-title function_">glob</span>(<span class="hljs-string">"*.jpg"</span>))
</code></pre>
<p>.. and combining our lists into a single object:</p>
<pre><code class="hljs language-js">image_paths = image_cats_list + image_dogs_list
</code></pre>
<p>Let’s see if everything is working fine by extracting a random image from our list:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-python"><span class="hljs-keyword">import</span> random
<span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image

random.seed(<span class="hljs-number">20</span>)

random_image_path = random.choice(image_paths)
image_class = random_image_path.parent.stem

img = Image.<span class="hljs-built_in">open</span>(random_image_path)

<span class="hljs-built_in">print</span>(<span class="hljs-string">f"Random image path: <span class="hljs-subst">{random_image_path}</span>"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"Image class: <span class="hljs-subst">{image_class}</span>"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"Image height: <span class="hljs-subst">{img.height}</span>"</span>) 
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"Image width: <span class="hljs-subst">{img.width}</span>"</span>)
img
</code></pre>
<p><img src="/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_5.png" alt="Cute little doggo!"></p>
<p>귀여운 강아지!</p>
<p>이미지를 텐서로 변환할 때 일반적인 단계 중 하나는 이미지를 일반적인 포맷으로 조정하는 것입니다. transforms 라이브러리를 사용하여 이미지 크기를 조정하고 첫 번째 비전 파이프라인을 설정할 수 있습니다!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-python">data_transform = transforms.Compose([
 <span class="hljs-comment"># 이미지 크기를 조정합니다</span>
 transforms.Resize(size=(<span class="hljs-number">64</span>, <span class="hljs-number">64</span>)),
 <span class="hljs-comment"># 이미지를 수평으로 무작위로 뒤집습니다 — 이는 데이터 증가를 위한 단계입니다</span>
 transforms.RandomHorizontalFlip(p=<span class="hljs-number">0.5</span>),
 transforms.ToTensor()])
</code></pre>
<p>위 transforms 파이프라인에서 우리는 다음을 수행합니다:</p>
<ul>
<li>이미지를 64x64 픽셀 크기로 크기 조정합니다.</li>
<li>무작위로 수평으로 이미지를 뒤집습니다 — 이는 데이터 증가를 위한 일반적인 단계입니다.</li>
<li>이미지를 텐서로 변환합니다.</li>
</ul>
<p>한 이미지와 해당 변환된 버전을 나란히 그래플로 표시합니다:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> matplotlib.<span class="hljs-property">pyplot</span> <span class="hljs-keyword">as</span> plt

def <span class="hljs-title function_">plot_transformed_images</span>(<span class="hljs-attr">image_paths</span>: list, 
                            <span class="hljs-attr">transform</span>: transforms.<span class="hljs-property">Compose</span>, 
                            n=<span class="hljs-number">3</span>, 
                            seed=<span class="hljs-number">100</span>):
    random.<span class="hljs-title function_">seed</span>(seed)
    random_image_paths = random.<span class="hljs-title function_">sample</span>(image_paths, k=n)
    <span class="hljs-keyword">for</span> image_path <span class="hljs-keyword">in</span> <span class="hljs-attr">random_image_paths</span>:
        <span class="hljs-keyword">with</span> <span class="hljs-title class_">Image</span>.<span class="hljs-title function_">open</span>(image_path) <span class="hljs-keyword">as</span> <span class="hljs-attr">f</span>:
            fig, ax = plt.<span class="hljs-title function_">subplots</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
            ax[<span class="hljs-number">0</span>].<span class="hljs-title function_">imshow</span>(f) 
            ax[<span class="hljs-number">0</span>].<span class="hljs-title function_">set_title</span>(f<span class="hljs-string">"Original Image \nSize: {f.size}"</span>)
            ax[<span class="hljs-number">0</span>].<span class="hljs-title function_">axis</span>(<span class="hljs-string">"off"</span>) 
            transformed_image = <span class="hljs-title function_">transform</span>(f).<span class="hljs-title function_">permute</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>) 
            ax[<span class="hljs-number">1</span>].<span class="hljs-title function_">imshow</span>(transformed_image) 
            ax[<span class="hljs-number">1</span>].<span class="hljs-title function_">set_title</span>(f<span class="hljs-string">"Transformed Image \nSize: {transformed_image.shape}"</span>)
            ax[<span class="hljs-number">1</span>].<span class="hljs-title function_">axis</span>(<span class="hljs-string">"off"</span>)
            fig.<span class="hljs-title function_">suptitle</span>(f<span class="hljs-string">"Class: {image_path.parent.stem}"</span>, fontsize=<span class="hljs-number">16</span>)
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-title function_">plot_transformed_images</span>(image_paths, 
 transform=data_transform, 
 n=<span class="hljs-number">1</span>)
</code></pre>
<img src="/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_6.png">
<p>저런! 변환을 통해 기본 텐서에 액세스하는 방법을 살펴보겠습니다. 예를 들어, 첫 번째 이미지의 경우:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">image_path = image_paths[<span class="hljs-number">0</span>]
<span class="hljs-title function_">data_transform</span>(<span class="hljs-title class_">Image</span>.<span class="hljs-title function_">open</span>(image_path))
</code></pre>
<p><img src="/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_7.png" alt="image"></p>
<p>데이터 변환은 RGB 채널이 3개이고 64x64 텐서를 생성했습니다!</p>
<p>우리가 넘어가기 전에 더해야 할 마지막 단계 하나가 있습니다. 빠르게 텐서와 레이블을 생성하는 대안이 있습니다. 우리는 ImageFolder를 사용하여 편리하게 훈련 데이터를 생성할 수 있습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">train_data = datasets.<span class="hljs-title class_">ImageFolder</span>(root=data_path, transform=data_transform, target_transform=<span class="hljs-title class_">None</span>)
</code></pre>
<p><code>datasets.ImageFolder</code>을 사용해요</p>
<pre><code class="hljs language-js">class_names = train_data.<span class="hljs-property">classes</span>
class_names
</code></pre>
<img src="/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_8.png">
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>class_names에는 현재 태그(폴더 이름에서 읽음)가 컴퓨터 비전 모델에 포함되어 있습니다. train_data에는 컴퓨터 비전 프로세스에 대한 중요한 메타데이터가 포함되어 있습니다:</p>
<p><img src="/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_9.png" alt="이미지"></p>
<p>그리고 이제 데이터 세트 ImageFolders를 DataLoaders로 변환하는 것은 매우 간단합니다:</p>
<pre><code class="hljs language-js">train_dataloader = <span class="hljs-title class_">DataLoader</span>(dataset=train_data, 
 batch_size=<span class="hljs-number">5</span>,
 num_workers=<span class="hljs-number">1</span>, 
 shuffle=<span class="hljs-title class_">True</span>)

train_dataloader
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>보면 이터러블이 있네요:</p>
<pre><code class="hljs language-python">img, label = <span class="hljs-built_in">next</span>(<span class="hljs-built_in">iter</span>(train_dataloader))
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"이미지 형태: <span class="hljs-subst">{img.shape}</span> -> [배치 크기, 색상 채널, 높이, 너비]"</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"레이블 형태: <span class="hljs-subst">{label.shape}</span>"</span>)
</code></pre>
<p><img src="/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_10.png" alt="image"></p>
<p>멋져요! 이 배치 크기가 5인 경우, 3채널(RGB)의 64x64 픽셀 이미지를 나타내는 3x64x64 텐서를 얻을 수 있습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이제 이 데이터 배치를 사용하여 강아지와 고양이 이미지를 인식하는 머신러닝 모델을 훈련할 수 있어요! (사실, 이 시리즈의 다음 블로그 게시물에서 이를 진행할 예정이에요!)</p>
<h1>텍스트 데이터 사용</h1>
<p>이 글의 마지막 부분에서는 sklearn.datasets의 fetch_20newsgroups를 사용하여 문자열과 정수 간 매핑을 생성할 거에요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">from</span> sklearn.<span class="hljs-property">datasets</span> <span class="hljs-keyword">import</span> fetch_20newsgroups
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>다음의 내용을 newsgroups에서 로드해 보겠습니다:</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> fetch_20newsgroups

categories = [
    <span class="hljs-string">'comp.os.ms-windows.misc'</span>,
    <span class="hljs-string">'rec.sport.baseball'</span>,
    <span class="hljs-string">'rec.sport.hockey'</span>,
]

dataset = fetch_20newsgroups(subset=<span class="hljs-string">'train'</span>, categories=categories, shuffle=<span class="hljs-literal">True</span>, remove=(<span class="hljs-string">'headers'</span>, <span class="hljs-string">'footers'</span>, <span class="hljs-string">'quotes'</span>))
corpus = [item <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> dataset[<span class="hljs-string">'data'</span>]]
</code></pre>
<p>다음 함수는 텍스트를 전처리할 것입니다:</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">import</span> nltk
<span class="hljs-keyword">import</span> re

<span class="hljs-keyword">def</span> <span class="hljs-title function_">preprocess_text</span>(<span class="hljs-params">text: <span class="hljs-built_in">str</span></span>) -> <span class="hljs-built_in">str</span>:
    <span class="hljs-string">'''
    입력 데이터에서 텍스트를 전처리하여 특수 문자와 숫자를 제거합니다.
    
    토큰 목록을 반환합니다.
    '''</span>
    <span class="hljs-comment"># 특수 문자 및 숫자 제거</span>
    text = re.sub(<span class="hljs-string">"[^A-Za-z]+"</span>, <span class="hljs-string">" "</span>, text)
    tokens = nltk.word_tokenize(text.lower())
    <span class="hljs-keyword">return</span> tokens
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>아래는 우리 어휘를 생성하는 함수입니다:</p>
<pre><code class="hljs language-js">def <span class="hljs-title function_">get_vocab</span>(training_corpus):
  # 특수 문자 추가
  # 패딩, 라인 끝, 알 수 없는 용어
  vocab = {<span class="hljs-string">'__PAD__'</span>: <span class="hljs-number">0</span>, <span class="hljs-string">'__&#x3C;/e>__'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'__UNK__'</span>: <span class="hljs-number">2</span>}
  <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> <span class="hljs-attr">training_corpus</span>: 
    processed_text = <span class="hljs-title function_">preprocess_text</span>(item)
    processed_text.<span class="hljs-title function_">sort</span>()
    <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> <span class="hljs-attr">processed_text</span>:
      <span class="hljs-keyword">if</span> word not <span class="hljs-keyword">in</span> <span class="hljs-attr">vocab</span>:
        vocab[word] = <span class="hljs-title function_">len</span>(vocab) 
  <span class="hljs-keyword">return</span> vocab  
</code></pre>
<p>전체 어휘 사이즈는 얼마인가요?</p>
<pre><code class="hljs language-js">vocab = <span class="hljs-title function_">get_vocab</span>(corpus)
<span class="hljs-title function_">len</span>(vocab)
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이미지 파일:</p>
<p><img src="/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_11.png" alt="이미지 파일"></p>
<p>단어장은 2만 6천 개가 조금 넘는 단어를 포함하고 있으며, 각 단어는 정수로 매핑되어 있습니다:</p>
<p>이미지 파일:</p>
<p><img src="/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_12.png" alt="이미지 파일"></p>
<p>이렇게 설정을 했으면, 문자를 정수로 변환하여 텐서로 변환하는 함수를 사용할 수 있습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">text_to_tensor</span>(<span class="hljs-params">text: <span class="hljs-built_in">str</span>, vocab_dict: <span class="hljs-built_in">dict</span></span>) -> torch.tensor:
    <span class="hljs-string">'''
    텍스트를 전처리하고 텐서 형식의 정수 매핑을 생성합니다.
    '''</span>   
    word_l = preprocess_text(text)
        
    <span class="hljs-comment"># 빈 텐서 초기화</span>
    tensor_l = [] 
    
    <span class="hljs-comment"># 단어 목록에서 __UNK__ 값을 가져옴</span>
    unk_ID = vocab_dict[<span class="hljs-string">'__UNK__'</span>]
            
    <span class="hljs-comment"># 각 단어에 대해:</span>
    <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> word_l:
        <span class="hljs-comment"># 인덱스 가져옴</span>
        <span class="hljs-comment"># 단어가 vocab_dict에 없으면 UNK로 할당</span>
        word_ID = vocab_dict.get(word, unk_ID)
        <span class="hljs-comment"># 텐서 목록에 추가</span>
        tensor_l.append(word_ID)

    <span class="hljs-keyword">return</span> torch.tensor(tensor_l)
</code></pre>
<p>이 함수가 텍스트를 텐서로 어떻게 변환하는지에 대한 예시는 아래와 같습니다. 첫 번째 텍스트의 처음 200 단어를 사용하여 검사합니다:</p>
<pre><code class="hljs language-python">snippet = corpus[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>:<span class="hljs-number">200</span>]
<span class="hljs-built_in">print</span>(<span class="hljs-string">'텍스트 "{}"는 다음과 같이 텐서로 표현됩니다: {}'</span>.<span class="hljs-built_in">format</span>(snippet, text_to_tensor(snippet, vocab)))
</code></pre>
<img src="/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_13.png">
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>테이블 태그를 마크다운 형식으로 변경해주세요.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 PyTorch 시리즈의 더 많은 포스트를 알아보려면 다음 링크를 확인해보세요:</p>
<ul>
<li>Tensor 소개;</li>
<li>선형 모델 만들기;</li>
<li>활성화 함수 및 비선형 문제;</li>
</ul>
<p>이 게시물의 자료:</p>
<ul>
<li>택시 여행 기간 — <a href="https://www.nyc.gov/site/tlc/about/tlc-trip-record-data.page" rel="nofollow" target="_blank">https://www.nyc.gov/site/tlc/about/tlc-trip-record-data.page</a></li>
<li>고양이와 개 이미지 인용: @Inproceedings (컨퍼런스)'asirra-a-captcha-that-exploits-interest-aligned-manual-image-categorization,
저자 = 'Elson, Jeremy 및 Douceur, John (JD) 및 Howell, Jon 및 Saul, Jared',
제목 = 'Asirra: A CAPTCHA that Exploits Interest-Aligned Manual Image Categorization',
책 제목 = 'Proceedings of 14th ACM Conference on Computer and Communications Security (CCS)',
연도 = '2007',
월 = '10월',
발행사 = 'Association for Computing Machinery, Inc.',
url = '<a href="https://www.microsoft.com/en-us/research/publication/asirra-a-captcha-that-exploits-interest-aligned-manual-image-categorization/" rel="nofollow" target="_blank">https://www.microsoft.com/en-us/research/publication/asirra-a-captcha-that-exploits-interest-aligned-manual-image-categorization/</a>',
판본 = 'Proceedings of 14th ACM Conference on Computer and Communications Security (CCS)',
'</li>
</ul>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"PyTorch 입문  커스텀 데이터 사용 방법","description":"","date":"2024-07-12 20:17","slug":"2024-07-12-PyTorchIntroductionUsingCustomData","content":"\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_0.png\" /\u003e\n\n파이토치는 현재 딥 러닝 분야에서 가장 핫한 라이브러리 중 하나입니다. ChatGPT가 출시된 이후 데이터 과학가와 머신 러닝 엔지니어들 사이에서 딥 러닝 라이브러리가 아마도 가장 많은 관심을 받고 있다고 볼 수 있습니다. 특히 이러한 라이브러리는 매우 빠르게 복잡한 다차원 계산을 수행하는 능력이 뛰어나며, 이러한 라이브러리는 우리가 신경망 모델을 훈련하는 방식을 바꾸었습니다. 특히 이러한 모델이 저장하고 최적화하는 많은 수의 가중치를 관리하는 데 매우 도움이 됩니다. TensorFlow(구글의 프레임워크)와 경쟁하며, PyTorch는 Meta의 오픈 소스 프레임워크로, 아주 멋지고 실용적인 문법을 사용하여 딥 러닝 모델을 훈련할 수 있는 기회를 제공합니다.\n\n지금까지 이 PyTorch 시리즈에서 이 라이브러리를 사용하는 기본 개념을 배워왔습니다. 예를 들어:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 텐서에 대한 기본 사항을 배우기\n- PyTorch를 사용하여 처음 선형 모델(회귀)을 만드는 방법 이해하기\n- 비선형 활성화 함수 및 비선형 문제 해결하는 방법 배우기\n\n저희는 예제와 이전 블로그 게시물에서 몇 가지 사용자 정의 데이터셋을 사용했습니다. 이 시리즈에서 딥 러닝 모델을 교육하는 방향으로 진행하면서, PyTorch의 맥락에서 다양한 데이터셋을 통합하는 방법을 이해하는 데 매우 도움이 됩니다. 이 블로그 게시물에서는 라이브러리에서 사용자 정의 데이터셋을 다루는 방법을 배우고, 특히 세 가지 다른 유형의 데이터를 통합하는 방법을 다룰 것입니다:\n\n- CSV 파일\n- 이미지 데이터\n- 텍스트 데이터\n\n또한 데이터 배치의 개념에 대해 살펴보고, 이를 위해 PyTorch 사용자 정의 DataLoader를 사용하는 방법도 알아볼 것입니다. 이 블로그 게시물의 일부 영감은 Zero to Mastery Pytorch 무료 강좌에서 온 것입니다 — 많은 흥미로운 학습 예제가 있는 이 멋진 자료를 확인해보세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n시작해 봅시다!\n\n# 랜덤 데이터셋 생성\n\n먼저, Pytorch에서 랜덤 데이터셋을 생성하여 DataLoader를 어떻게 사용할 수 있는지 이해해 봅시다:\n\n```python\nimport torch\nfrom torch.utils.data import Dataset, DataLoader\n\nclass RandomIntDataset(Dataset):\n    def __init__(self, start, stop, x, y):\n        self.data = torch.randint(start, stop, (x,y))\n        self.labels = torch.randint(0, 10, (x,))\n\n    def __len__(self):\n        return len(self.labels)\n\n    def __str__(self):\n        return str(torch.cat((self.data, self.labels.unsqueeze(1)), 1))\n\n    def __getitem__(self, i):\n        return self.data[i], self.labels[i]\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저희 RandomIntDataset은 랜덤한 torch 객체와 레이블을 생성합니다. 클래스에 던더 메서드를 도입하고 torch.utils.data.Dataset을 상속했음을 주목해주세요. (특히 데이터셋을 DataLoader와 결합할 때 유용하게 사용될 것입니다).\n\n이전 클래스를 기반으로 첫 번째 데이터셋 객체를 생성해봅시다!\n\n```js\ndataset = RandomIntDataset(100, 1000, 500, 10)\n```\n\n다시 말씀드리지만, Pytorch의 기본 클래스를 상속받았기 때문에 DataLoader를 사용하여 좋은 이터러블을 생성할 수 있습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\r\ndataset_loader = DataLoader(dataset, batch_size=10, shuffle=True)\r\n```\r\n\r\n신경망 내에서 데이터를 배치로 전달하는 것은 매우 흔한 일이며 DataLoader 생성자가 깔끔한 batch_size 인자를 통해 이를 처리합니다! dataset_loader는 반복 가능하므로 순차적인 데이터 배치를 얻기 위해 next 및 iter를 사용할 수 있습니다.\r\n\r\n```js\r\ndata, labels = next(iter(dataset_loader))\r\ndata\r\n```\r\n\r\n\u003cimg src=\"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_1.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n새로운 iteration을 실행하고 data_loader의 다음 배치가 어떻게 이동하는지 확인해보세요! 이를 통해 데이터 및 레이블 객체 내부의 다른 데이터가 표시됩니다.\n\n물론, 이 무작위 데이터 세트는 실제로 \"사용자 지정 데이터 세트\"로 간주하기 어렵습니다. 무작위 생성된 데이터와 작업하려고 할 가능성은 매우 낮습니다. 그러나 배치 처리에 익숙해지는 데 도움이 되는 이 소개 후에 첫 번째 CSV 파일을 PyTorch 파이프라인에 포함하여 계속 진행할 준비가 되었습니다!\n\n# DataLoader와 사용자 지정 데이터 세트 결합\n\n우리가 보았듯이, 무작위 데이터 세트 사용은 단순한 연습일 뿐입니다. 그러나 이제 DataLoader와 데이터 배치가 어떻게 작동하는지 알기 때문에 이 지식을 사용하여 새로운 클래스를 만들어 PyTorch 데이터 세트를 사용할 수 있습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nimport pandas as pd\n\nclass TaxiSample(Dataset):\n    def __init__(self):\n        super().__init__()\n        df = pd.read_csv('data/taxi_data_sample.csv')\n        \n        features = ['passenger_count',\n                    'pickup_longitude',\n                    'pickup_latitude',\n                    'dropoff_longitude',\n                    'dropoff_latitude']\n        \n        target = 'trip_duration'\n        \n        self.features = torch.tensor(df[features].values, \n                                     dtype=torch.float32)\n\n        self.labels = torch.tensor(df[target].values, \n                                   dtype=torch.float32)\n\n    def __len__(self):\n        return len(self.labels)\n\n    def __getitem__(self, idx):\n        return self.features[idx], self.labels[idx]\n```\n\n참고: 라이브러리를 게시물에서 지날 때까지 가져오고 있지만 모든 라이브러리는 스크립트의 처음에 가져와야 합니다!\n\n우리가 사용하는 데이터셋은 Kaggle의 택시 여행 소요 시간 경쟁의 샘플 버전입니다. 여기서 csv를 init에 전달하고 있습니다 (이 기능을 더 다룰 수 있도록 인수로도 전달할 수 있습니다). DataLoader와 잘 어울리는지 확인해봅시다:\n\n```python\ndata_taxi = TaxiSample()\ndataset_loader = DataLoader(data_taxi, batch_size=20, shuffle=True)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리의 배치 크기가 20인 경우, 이 데이터셋에서 이터레이터를 만들 수 있습니다:\n\n```js\ndata_iterator = iter(dataset_loader)\ndata, labels = next(data_iterator)\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_2.png\" /\u003e\n\n멋져요! 이것들은 데이터셋에서 무작위로 선택한 처음 20개의 예시입니다. 위 이미지에서는 피처와 해당 레이블을 확인할 수 있어요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n있는 이미지 데이터를 사용 해보세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 블로그 게시물의 이 섹션에서는 이미지 데이터 처리 능력을 보여주기 위해 Microsoft Research Cats. vs Dogs. 데이터셋과 함께 Pytorch를 사용할 것입니다. 먼저 pathlib를 사용하여 경로를 정의해 보겠습니다:\n\n```python\nfrom pathlib import Path\ndata_path = Path(“data/dogs_cats”)\n```\n\n폴더 안에는 강아지 이미지와 고양이 이미지가 있는 두 개의 폴더가 있습니다. 각 폴더에서 이미지 경로를 추출해 봅시다:\n\n![이미지](/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_3.png)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 섹션에서는 일반적인 컴퓨터 비전 변환 및 아키텍처를 제공하는 pytorch의 멋진 확장인 torchvision이 필요합니다.\n\n```js\nfrom torchvision import datasets, transforms\n```\n\n다음으로 jpg 파일 이름을 읽어보겠습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimage_dogs_list = list((data_path/'dogs').glob(\"*.jpg\"))\nimage_cats_list = list((data_path/'cats').glob(\"*.jpg\"))\n```\n\n.. and combining our lists into a single object:\n\n```js\nimage_paths = image_cats_list + image_dogs_list\n```\n\nLet’s see if everything is working fine by extracting a random image from our list:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nimport random\nfrom PIL import Image\n\nrandom.seed(20)\n\nrandom_image_path = random.choice(image_paths)\nimage_class = random_image_path.parent.stem\n\nimg = Image.open(random_image_path)\n\nprint(f\"Random image path: {random_image_path}\")\nprint(f\"Image class: {image_class}\")\nprint(f\"Image height: {img.height}\") \nprint(f\"Image width: {img.width}\")\nimg\n```\n\n![Cute little doggo!](/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_5.png)\n\n귀여운 강아지!\n\n이미지를 텐서로 변환할 때 일반적인 단계 중 하나는 이미지를 일반적인 포맷으로 조정하는 것입니다. transforms 라이브러리를 사용하여 이미지 크기를 조정하고 첫 번째 비전 파이프라인을 설정할 수 있습니다!\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\ndata_transform = transforms.Compose([\n # 이미지 크기를 조정합니다\n transforms.Resize(size=(64, 64)),\n # 이미지를 수평으로 무작위로 뒤집습니다 — 이는 데이터 증가를 위한 단계입니다\n transforms.RandomHorizontalFlip(p=0.5),\n transforms.ToTensor()])\n```\n\n위 transforms 파이프라인에서 우리는 다음을 수행합니다:\n\n- 이미지를 64x64 픽셀 크기로 크기 조정합니다.\n- 무작위로 수평으로 이미지를 뒤집습니다 — 이는 데이터 증가를 위한 일반적인 단계입니다.\n- 이미지를 텐서로 변환합니다.\n\n한 이미지와 해당 변환된 버전을 나란히 그래플로 표시합니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport matplotlib.pyplot as plt\n\ndef plot_transformed_images(image_paths: list, \n                            transform: transforms.Compose, \n                            n=3, \n                            seed=100):\n    random.seed(seed)\n    random_image_paths = random.sample(image_paths, k=n)\n    for image_path in random_image_paths:\n        with Image.open(image_path) as f:\n            fig, ax = plt.subplots(1, 2)\n            ax[0].imshow(f) \n            ax[0].set_title(f\"Original Image \\nSize: {f.size}\")\n            ax[0].axis(\"off\") \n            transformed_image = transform(f).permute(1, 2, 0) \n            ax[1].imshow(transformed_image) \n            ax[1].set_title(f\"Transformed Image \\nSize: {transformed_image.shape}\")\n            ax[1].axis(\"off\")\n            fig.suptitle(f\"Class: {image_path.parent.stem}\", fontsize=16)\n```\n\n```js\nplot_transformed_images(image_paths, \n transform=data_transform, \n n=1)\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_6.png\" /\u003e\n\n저런! 변환을 통해 기본 텐서에 액세스하는 방법을 살펴보겠습니다. 예를 들어, 첫 번째 이미지의 경우:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimage_path = image_paths[0]\ndata_transform(Image.open(image_path))\n```\n\n![image](/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_7.png)\n\n데이터 변환은 RGB 채널이 3개이고 64x64 텐서를 생성했습니다!\n\n우리가 넘어가기 전에 더해야 할 마지막 단계 하나가 있습니다. 빠르게 텐서와 레이블을 생성하는 대안이 있습니다. 우리는 ImageFolder를 사용하여 편리하게 훈련 데이터를 생성할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ntrain_data = datasets.ImageFolder(root=data_path, transform=data_transform, target_transform=None)\n```\n\n`datasets.ImageFolder`을 사용해요\n\n```js\nclass_names = train_data.classes\nclass_names\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_8.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nclass_names에는 현재 태그(폴더 이름에서 읽음)가 컴퓨터 비전 모델에 포함되어 있습니다. train_data에는 컴퓨터 비전 프로세스에 대한 중요한 메타데이터가 포함되어 있습니다:\n\n![이미지](/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_9.png)\n\n그리고 이제 데이터 세트 ImageFolders를 DataLoaders로 변환하는 것은 매우 간단합니다:\n\n```js\ntrain_dataloader = DataLoader(dataset=train_data, \n batch_size=5,\n num_workers=1, \n shuffle=True)\n\ntrain_dataloader\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n보면 이터러블이 있네요:\n\n```python\nimg, label = next(iter(train_dataloader))\nprint(f\"이미지 형태: {img.shape} -\u003e [배치 크기, 색상 채널, 높이, 너비]\")\nprint(f\"레이블 형태: {label.shape}\")\n```\n\n![image](/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_10.png)\n\n멋져요! 이 배치 크기가 5인 경우, 3채널(RGB)의 64x64 픽셀 이미지를 나타내는 3x64x64 텐서를 얻을 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 이 데이터 배치를 사용하여 강아지와 고양이 이미지를 인식하는 머신러닝 모델을 훈련할 수 있어요! (사실, 이 시리즈의 다음 블로그 게시물에서 이를 진행할 예정이에요!)\n\n# 텍스트 데이터 사용\n\n이 글의 마지막 부분에서는 sklearn.datasets의 fetch_20newsgroups를 사용하여 문자열과 정수 간 매핑을 생성할 거에요:\n\n```js\nfrom sklearn.datasets import fetch_20newsgroups\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음의 내용을 newsgroups에서 로드해 보겠습니다:\n\n```python\nfrom sklearn.datasets import fetch_20newsgroups\n\ncategories = [\n    'comp.os.ms-windows.misc',\n    'rec.sport.baseball',\n    'rec.sport.hockey',\n]\n\ndataset = fetch_20newsgroups(subset='train', categories=categories, shuffle=True, remove=('headers', 'footers', 'quotes'))\ncorpus = [item for item in dataset['data']]\n```\n\n다음 함수는 텍스트를 전처리할 것입니다:\n\n```python\nimport nltk\nimport re\n\ndef preprocess_text(text: str) -\u003e str:\n    '''\n    입력 데이터에서 텍스트를 전처리하여 특수 문자와 숫자를 제거합니다.\n    \n    토큰 목록을 반환합니다.\n    '''\n    # 특수 문자 및 숫자 제거\n    text = re.sub(\"[^A-Za-z]+\", \" \", text)\n    tokens = nltk.word_tokenize(text.lower())\n    return tokens\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 우리 어휘를 생성하는 함수입니다:\n\n```js\ndef get_vocab(training_corpus):\n  # 특수 문자 추가\n  # 패딩, 라인 끝, 알 수 없는 용어\n  vocab = {'__PAD__': 0, '__\u003c/e\u003e__': 1, '__UNK__': 2}\n  for item in training_corpus: \n    processed_text = preprocess_text(item)\n    processed_text.sort()\n    for word in processed_text:\n      if word not in vocab:\n        vocab[word] = len(vocab) \n  return vocab  \n```\n\n전체 어휘 사이즈는 얼마인가요?\n\n```js\nvocab = get_vocab(corpus)\nlen(vocab)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이미지 파일:\n\n![이미지 파일](/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_11.png)\n\n단어장은 2만 6천 개가 조금 넘는 단어를 포함하고 있으며, 각 단어는 정수로 매핑되어 있습니다:\n\n이미지 파일:\n\n![이미지 파일](/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_12.png)\n\n이렇게 설정을 했으면, 문자를 정수로 변환하여 텐서로 변환하는 함수를 사용할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\ndef text_to_tensor(text: str, vocab_dict: dict) -\u003e torch.tensor:\n    '''\n    텍스트를 전처리하고 텐서 형식의 정수 매핑을 생성합니다.\n    '''   \n    word_l = preprocess_text(text)\n        \n    # 빈 텐서 초기화\n    tensor_l = [] \n    \n    # 단어 목록에서 __UNK__ 값을 가져옴\n    unk_ID = vocab_dict['__UNK__']\n            \n    # 각 단어에 대해:\n    for word in word_l:\n        # 인덱스 가져옴\n        # 단어가 vocab_dict에 없으면 UNK로 할당\n        word_ID = vocab_dict.get(word, unk_ID)\n        # 텐서 목록에 추가\n        tensor_l.append(word_ID)\n\n    return torch.tensor(tensor_l)\n```\n\n이 함수가 텍스트를 텐서로 어떻게 변환하는지에 대한 예시는 아래와 같습니다. 첫 번째 텍스트의 처음 200 단어를 사용하여 검사합니다:\n\n```python\nsnippet = corpus[0][0:200]\nprint('텍스트 \"{}\"는 다음과 같이 텐서로 표현됩니다: {}'.format(snippet, text_to_tensor(snippet, vocab)))\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_13.png\" /\u003e\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테이블 태그를 마크다운 형식으로 변경해주세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 PyTorch 시리즈의 더 많은 포스트를 알아보려면 다음 링크를 확인해보세요:\n\n- Tensor 소개;\n- 선형 모델 만들기;\n- 활성화 함수 및 비선형 문제;\n\n이 게시물의 자료:\n\n- 택시 여행 기간 — https://www.nyc.gov/site/tlc/about/tlc-trip-record-data.page\n- 고양이와 개 이미지 인용: @Inproceedings (컨퍼런스)'asirra-a-captcha-that-exploits-interest-aligned-manual-image-categorization,\n저자 = 'Elson, Jeremy 및 Douceur, John (JD) 및 Howell, Jon 및 Saul, Jared',\n제목 = 'Asirra: A CAPTCHA that Exploits Interest-Aligned Manual Image Categorization',\n책 제목 = 'Proceedings of 14th ACM Conference on Computer and Communications Security (CCS)',\n연도 = '2007',\n월 = '10월',\n발행사 = 'Association for Computing Machinery, Inc.',\nurl = 'https://www.microsoft.com/en-us/research/publication/asirra-a-captcha-that-exploits-interest-aligned-manual-image-categorization/',\n판본 = 'Proceedings of 14th ACM Conference on Computer and Communications Security (CCS)',\n'","ogImage":{"url":"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_0.png","tag":["Tech"],"readingTime":19},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_0.png\"\u003e\n\u003cp\u003e파이토치는 현재 딥 러닝 분야에서 가장 핫한 라이브러리 중 하나입니다. ChatGPT가 출시된 이후 데이터 과학가와 머신 러닝 엔지니어들 사이에서 딥 러닝 라이브러리가 아마도 가장 많은 관심을 받고 있다고 볼 수 있습니다. 특히 이러한 라이브러리는 매우 빠르게 복잡한 다차원 계산을 수행하는 능력이 뛰어나며, 이러한 라이브러리는 우리가 신경망 모델을 훈련하는 방식을 바꾸었습니다. 특히 이러한 모델이 저장하고 최적화하는 많은 수의 가중치를 관리하는 데 매우 도움이 됩니다. TensorFlow(구글의 프레임워크)와 경쟁하며, PyTorch는 Meta의 오픈 소스 프레임워크로, 아주 멋지고 실용적인 문법을 사용하여 딥 러닝 모델을 훈련할 수 있는 기회를 제공합니다.\u003c/p\u003e\n\u003cp\u003e지금까지 이 PyTorch 시리즈에서 이 라이브러리를 사용하는 기본 개념을 배워왔습니다. 예를 들어:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e텐서에 대한 기본 사항을 배우기\u003c/li\u003e\n\u003cli\u003ePyTorch를 사용하여 처음 선형 모델(회귀)을 만드는 방법 이해하기\u003c/li\u003e\n\u003cli\u003e비선형 활성화 함수 및 비선형 문제 해결하는 방법 배우기\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e저희는 예제와 이전 블로그 게시물에서 몇 가지 사용자 정의 데이터셋을 사용했습니다. 이 시리즈에서 딥 러닝 모델을 교육하는 방향으로 진행하면서, PyTorch의 맥락에서 다양한 데이터셋을 통합하는 방법을 이해하는 데 매우 도움이 됩니다. 이 블로그 게시물에서는 라이브러리에서 사용자 정의 데이터셋을 다루는 방법을 배우고, 특히 세 가지 다른 유형의 데이터를 통합하는 방법을 다룰 것입니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCSV 파일\u003c/li\u003e\n\u003cli\u003e이미지 데이터\u003c/li\u003e\n\u003cli\u003e텍스트 데이터\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e또한 데이터 배치의 개념에 대해 살펴보고, 이를 위해 PyTorch 사용자 정의 DataLoader를 사용하는 방법도 알아볼 것입니다. 이 블로그 게시물의 일부 영감은 Zero to Mastery Pytorch 무료 강좌에서 온 것입니다 — 많은 흥미로운 학습 예제가 있는 이 멋진 자료를 확인해보세요.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e시작해 봅시다!\u003c/p\u003e\n\u003ch1\u003e랜덤 데이터셋 생성\u003c/h1\u003e\n\u003cp\u003e먼저, Pytorch에서 랜덤 데이터셋을 생성하여 DataLoader를 어떻게 사용할 수 있는지 이해해 봅시다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e torch\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e torch.utils.data \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e Dataset, DataLoader\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eRandomIntDataset\u003c/span\u003e(\u003cspan class=\"hljs-title class_ inherited__\"\u003eDataset\u003c/span\u003e):\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e__init__\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself, start, stop, x, y\u003c/span\u003e):\n        self.data = torch.randint(start, stop, (x,y))\n        self.labels = torch.randint(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e, (x,))\n\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e__len__\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself\u003c/span\u003e):\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(self.labels)\n\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e__str__\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself\u003c/span\u003e):\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003estr\u003c/span\u003e(torch.cat((self.data, self.labels.unsqueeze(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)), \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e))\n\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e__getitem__\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself, i\u003c/span\u003e):\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e self.data[i], self.labels[i]\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e저희 RandomIntDataset은 랜덤한 torch 객체와 레이블을 생성합니다. 클래스에 던더 메서드를 도입하고 torch.utils.data.Dataset을 상속했음을 주목해주세요. (특히 데이터셋을 DataLoader와 결합할 때 유용하게 사용될 것입니다).\u003c/p\u003e\n\u003cp\u003e이전 클래스를 기반으로 첫 번째 데이터셋 객체를 생성해봅시다!\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edataset = \u003cspan class=\"hljs-title class_\"\u003eRandomIntDataset\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e500\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다시 말씀드리지만, Pytorch의 기본 클래스를 상속받았기 때문에 DataLoader를 사용하여 좋은 이터러블을 생성할 수 있습니다:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edataset_loader = \u003cspan class=\"hljs-title class_\"\u003eDataLoader\u003c/span\u003e(dataset, batch_size=\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e, shuffle=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e신경망 내에서 데이터를 배치로 전달하는 것은 매우 흔한 일이며 DataLoader 생성자가 깔끔한 batch_size 인자를 통해 이를 처리합니다! dataset_loader는 반복 가능하므로 순차적인 데이터 배치를 얻기 위해 next 및 iter를 사용할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edata, labels = \u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eiter\u003c/span\u003e(dataset_loader))\r\ndata\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_1.png\"\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e새로운 iteration을 실행하고 data_loader의 다음 배치가 어떻게 이동하는지 확인해보세요! 이를 통해 데이터 및 레이블 객체 내부의 다른 데이터가 표시됩니다.\u003c/p\u003e\n\u003cp\u003e물론, 이 무작위 데이터 세트는 실제로 \"사용자 지정 데이터 세트\"로 간주하기 어렵습니다. 무작위 생성된 데이터와 작업하려고 할 가능성은 매우 낮습니다. 그러나 배치 처리에 익숙해지는 데 도움이 되는 이 소개 후에 첫 번째 CSV 파일을 PyTorch 파이프라인에 포함하여 계속 진행할 준비가 되었습니다!\u003c/p\u003e\n\u003ch1\u003eDataLoader와 사용자 지정 데이터 세트 결합\u003c/h1\u003e\n\u003cp\u003e우리가 보았듯이, 무작위 데이터 세트 사용은 단순한 연습일 뿐입니다. 그러나 이제 DataLoader와 데이터 배치가 어떻게 작동하는지 알기 때문에 이 지식을 사용하여 새로운 클래스를 만들어 PyTorch 데이터 세트를 사용할 수 있습니다:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e pandas \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e pd\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTaxiSample\u003c/span\u003e(\u003cspan class=\"hljs-title class_ inherited__\"\u003eDataset\u003c/span\u003e):\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e__init__\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself\u003c/span\u003e):\n        \u003cspan class=\"hljs-built_in\"\u003esuper\u003c/span\u003e().__init__()\n        df = pd.read_csv(\u003cspan class=\"hljs-string\"\u003e'data/taxi_data_sample.csv'\u003c/span\u003e)\n        \n        features = [\u003cspan class=\"hljs-string\"\u003e'passenger_count'\u003c/span\u003e,\n                    \u003cspan class=\"hljs-string\"\u003e'pickup_longitude'\u003c/span\u003e,\n                    \u003cspan class=\"hljs-string\"\u003e'pickup_latitude'\u003c/span\u003e,\n                    \u003cspan class=\"hljs-string\"\u003e'dropoff_longitude'\u003c/span\u003e,\n                    \u003cspan class=\"hljs-string\"\u003e'dropoff_latitude'\u003c/span\u003e]\n        \n        target = \u003cspan class=\"hljs-string\"\u003e'trip_duration'\u003c/span\u003e\n        \n        self.features = torch.tensor(df[features].values, \n                                     dtype=torch.float32)\n\n        self.labels = torch.tensor(df[target].values, \n                                   dtype=torch.float32)\n\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e__len__\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself\u003c/span\u003e):\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(self.labels)\n\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e__getitem__\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself, idx\u003c/span\u003e):\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e self.features[idx], self.labels[idx]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e참고: 라이브러리를 게시물에서 지날 때까지 가져오고 있지만 모든 라이브러리는 스크립트의 처음에 가져와야 합니다!\u003c/p\u003e\n\u003cp\u003e우리가 사용하는 데이터셋은 Kaggle의 택시 여행 소요 시간 경쟁의 샘플 버전입니다. 여기서 csv를 init에 전달하고 있습니다 (이 기능을 더 다룰 수 있도록 인수로도 전달할 수 있습니다). DataLoader와 잘 어울리는지 확인해봅시다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003edata_taxi = TaxiSample()\ndataset_loader = DataLoader(data_taxi, batch_size=\u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e, shuffle=\u003cspan class=\"hljs-literal\"\u003eTrue\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e우리의 배치 크기가 20인 경우, 이 데이터셋에서 이터레이터를 만들 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edata_iterator = \u003cspan class=\"hljs-title function_\"\u003eiter\u003c/span\u003e(dataset_loader)\ndata, labels = \u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e(data_iterator)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_2.png\"\u003e\n\u003cp\u003e멋져요! 이것들은 데이터셋에서 무작위로 선택한 처음 20개의 예시입니다. 위 이미지에서는 피처와 해당 레이블을 확인할 수 있어요.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e있는 이미지 데이터를 사용 해보세요.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 블로그 게시물의 이 섹션에서는 이미지 데이터 처리 능력을 보여주기 위해 Microsoft Research Cats. vs Dogs. 데이터셋과 함께 Pytorch를 사용할 것입니다. 먼저 pathlib를 사용하여 경로를 정의해 보겠습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e pathlib \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e Path\ndata_path = Path(“data/dogs_cats”)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e폴더 안에는 강아지 이미지와 고양이 이미지가 있는 두 개의 폴더가 있습니다. 각 폴더에서 이미지 경로를 추출해 봅시다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_3.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 섹션에서는 일반적인 컴퓨터 비전 변환 및 아키텍처를 제공하는 pytorch의 멋진 확장인 torchvision이 필요합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e torchvision \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e datasets, transforms\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음으로 jpg 파일 이름을 읽어보겠습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eimage_dogs_list = \u003cspan class=\"hljs-title function_\"\u003elist\u003c/span\u003e((data_path/\u003cspan class=\"hljs-string\"\u003e'dogs'\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003eglob\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"*.jpg\"\u003c/span\u003e))\nimage_cats_list = \u003cspan class=\"hljs-title function_\"\u003elist\u003c/span\u003e((data_path/\u003cspan class=\"hljs-string\"\u003e'cats'\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003eglob\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"*.jpg\"\u003c/span\u003e))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e.. and combining our lists into a single object:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eimage_paths = image_cats_list + image_dogs_list\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLet’s see if everything is working fine by extracting a random image from our list:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e random\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e PIL \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e Image\n\nrandom.seed(\u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e)\n\nrandom_image_path = random.choice(image_paths)\nimage_class = random_image_path.parent.stem\n\nimg = Image.\u003cspan class=\"hljs-built_in\"\u003eopen\u003c/span\u003e(random_image_path)\n\n\u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003ef\"Random image path: \u003cspan class=\"hljs-subst\"\u003e{random_image_path}\u003c/span\u003e\"\u003c/span\u003e)\n\u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003ef\"Image class: \u003cspan class=\"hljs-subst\"\u003e{image_class}\u003c/span\u003e\"\u003c/span\u003e)\n\u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003ef\"Image height: \u003cspan class=\"hljs-subst\"\u003e{img.height}\u003c/span\u003e\"\u003c/span\u003e) \n\u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003ef\"Image width: \u003cspan class=\"hljs-subst\"\u003e{img.width}\u003c/span\u003e\"\u003c/span\u003e)\nimg\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_5.png\" alt=\"Cute little doggo!\"\u003e\u003c/p\u003e\n\u003cp\u003e귀여운 강아지!\u003c/p\u003e\n\u003cp\u003e이미지를 텐서로 변환할 때 일반적인 단계 중 하나는 이미지를 일반적인 포맷으로 조정하는 것입니다. transforms 라이브러리를 사용하여 이미지 크기를 조정하고 첫 번째 비전 파이프라인을 설정할 수 있습니다!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003edata_transform = transforms.Compose([\n \u003cspan class=\"hljs-comment\"\u003e# 이미지 크기를 조정합니다\u003c/span\u003e\n transforms.Resize(size=(\u003cspan class=\"hljs-number\"\u003e64\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e64\u003c/span\u003e)),\n \u003cspan class=\"hljs-comment\"\u003e# 이미지를 수평으로 무작위로 뒤집습니다 — 이는 데이터 증가를 위한 단계입니다\u003c/span\u003e\n transforms.RandomHorizontalFlip(p=\u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e),\n transforms.ToTensor()])\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 transforms 파이프라인에서 우리는 다음을 수행합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e이미지를 64x64 픽셀 크기로 크기 조정합니다.\u003c/li\u003e\n\u003cli\u003e무작위로 수평으로 이미지를 뒤집습니다 — 이는 데이터 증가를 위한 일반적인 단계입니다.\u003c/li\u003e\n\u003cli\u003e이미지를 텐서로 변환합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e한 이미지와 해당 변환된 버전을 나란히 그래플로 표시합니다:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e matplotlib.\u003cspan class=\"hljs-property\"\u003epyplot\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e plt\n\ndef \u003cspan class=\"hljs-title function_\"\u003eplot_transformed_images\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eimage_paths\u003c/span\u003e: list, \n                            \u003cspan class=\"hljs-attr\"\u003etransform\u003c/span\u003e: transforms.\u003cspan class=\"hljs-property\"\u003eCompose\u003c/span\u003e, \n                            n=\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \n                            seed=\u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e):\n    random.\u003cspan class=\"hljs-title function_\"\u003eseed\u003c/span\u003e(seed)\n    random_image_paths = random.\u003cspan class=\"hljs-title function_\"\u003esample\u003c/span\u003e(image_paths, k=n)\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e image_path \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003erandom_image_paths\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eopen\u003c/span\u003e(image_path) \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ef\u003c/span\u003e:\n            fig, ax = plt.\u003cspan class=\"hljs-title function_\"\u003esubplots\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)\n            ax[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003eimshow\u003c/span\u003e(f) \n            ax[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003eset_title\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"Original Image \\nSize: {f.size}\"\u003c/span\u003e)\n            ax[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003eaxis\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"off\"\u003c/span\u003e) \n            transformed_image = \u003cspan class=\"hljs-title function_\"\u003etransform\u003c/span\u003e(f).\u003cspan class=\"hljs-title function_\"\u003epermute\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) \n            ax[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003eimshow\u003c/span\u003e(transformed_image) \n            ax[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003eset_title\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"Transformed Image \\nSize: {transformed_image.shape}\"\u003c/span\u003e)\n            ax[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003eaxis\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"off\"\u003c/span\u003e)\n            fig.\u003cspan class=\"hljs-title function_\"\u003esuptitle\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"Class: {image_path.parent.stem}\"\u003c/span\u003e, fontsize=\u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title function_\"\u003eplot_transformed_images\u003c/span\u003e(image_paths, \n transform=data_transform, \n n=\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_6.png\"\u003e\n\u003cp\u003e저런! 변환을 통해 기본 텐서에 액세스하는 방법을 살펴보겠습니다. 예를 들어, 첫 번째 이미지의 경우:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eimage_path = image_paths[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]\n\u003cspan class=\"hljs-title function_\"\u003edata_transform\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eopen\u003c/span\u003e(image_path))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_7.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e데이터 변환은 RGB 채널이 3개이고 64x64 텐서를 생성했습니다!\u003c/p\u003e\n\u003cp\u003e우리가 넘어가기 전에 더해야 할 마지막 단계 하나가 있습니다. 빠르게 텐서와 레이블을 생성하는 대안이 있습니다. 우리는 ImageFolder를 사용하여 편리하게 훈련 데이터를 생성할 수 있습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003etrain_data = datasets.\u003cspan class=\"hljs-title class_\"\u003eImageFolder\u003c/span\u003e(root=data_path, transform=data_transform, target_transform=\u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003edatasets.ImageFolder\u003c/code\u003e을 사용해요\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eclass_names = train_data.\u003cspan class=\"hljs-property\"\u003eclasses\u003c/span\u003e\nclass_names\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_8.png\"\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eclass_names에는 현재 태그(폴더 이름에서 읽음)가 컴퓨터 비전 모델에 포함되어 있습니다. train_data에는 컴퓨터 비전 프로세스에 대한 중요한 메타데이터가 포함되어 있습니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_9.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e그리고 이제 데이터 세트 ImageFolders를 DataLoaders로 변환하는 것은 매우 간단합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003etrain_dataloader = \u003cspan class=\"hljs-title class_\"\u003eDataLoader\u003c/span\u003e(dataset=train_data, \n batch_size=\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e,\n num_workers=\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \n shuffle=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e)\n\ntrain_dataloader\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e보면 이터러블이 있네요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003eimg, label = \u003cspan class=\"hljs-built_in\"\u003enext\u003c/span\u003e(\u003cspan class=\"hljs-built_in\"\u003eiter\u003c/span\u003e(train_dataloader))\n\u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003ef\"이미지 형태: \u003cspan class=\"hljs-subst\"\u003e{img.shape}\u003c/span\u003e -\u003e [배치 크기, 색상 채널, 높이, 너비]\"\u003c/span\u003e)\n\u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003ef\"레이블 형태: \u003cspan class=\"hljs-subst\"\u003e{label.shape}\u003c/span\u003e\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_10.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e멋져요! 이 배치 크기가 5인 경우, 3채널(RGB)의 64x64 픽셀 이미지를 나타내는 3x64x64 텐서를 얻을 수 있습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이제 이 데이터 배치를 사용하여 강아지와 고양이 이미지를 인식하는 머신러닝 모델을 훈련할 수 있어요! (사실, 이 시리즈의 다음 블로그 게시물에서 이를 진행할 예정이에요!)\u003c/p\u003e\n\u003ch1\u003e텍스트 데이터 사용\u003c/h1\u003e\n\u003cp\u003e이 글의 마지막 부분에서는 sklearn.datasets의 fetch_20newsgroups를 사용하여 문자열과 정수 간 매핑을 생성할 거에요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e sklearn.\u003cspan class=\"hljs-property\"\u003edatasets\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e fetch_20newsgroups\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e다음의 내용을 newsgroups에서 로드해 보겠습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e sklearn.datasets \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e fetch_20newsgroups\n\ncategories = [\n    \u003cspan class=\"hljs-string\"\u003e'comp.os.ms-windows.misc'\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e'rec.sport.baseball'\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e'rec.sport.hockey'\u003c/span\u003e,\n]\n\ndataset = fetch_20newsgroups(subset=\u003cspan class=\"hljs-string\"\u003e'train'\u003c/span\u003e, categories=categories, shuffle=\u003cspan class=\"hljs-literal\"\u003eTrue\u003c/span\u003e, remove=(\u003cspan class=\"hljs-string\"\u003e'headers'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'footers'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'quotes'\u003c/span\u003e))\ncorpus = [item \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e item \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e dataset[\u003cspan class=\"hljs-string\"\u003e'data'\u003c/span\u003e]]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음 함수는 텍스트를 전처리할 것입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e nltk\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e re\n\n\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003epreprocess_text\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003etext: \u003cspan class=\"hljs-built_in\"\u003estr\u003c/span\u003e\u003c/span\u003e) -\u003e \u003cspan class=\"hljs-built_in\"\u003estr\u003c/span\u003e:\n    \u003cspan class=\"hljs-string\"\u003e'''\n    입력 데이터에서 텍스트를 전처리하여 특수 문자와 숫자를 제거합니다.\n    \n    토큰 목록을 반환합니다.\n    '''\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e# 특수 문자 및 숫자 제거\u003c/span\u003e\n    text = re.sub(\u003cspan class=\"hljs-string\"\u003e\"[^A-Za-z]+\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\" \"\u003c/span\u003e, text)\n    tokens = nltk.word_tokenize(text.lower())\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e tokens\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e아래는 우리 어휘를 생성하는 함수입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edef \u003cspan class=\"hljs-title function_\"\u003eget_vocab\u003c/span\u003e(training_corpus):\n  # 특수 문자 추가\n  # 패딩, 라인 끝, 알 수 없는 용어\n  vocab = {\u003cspan class=\"hljs-string\"\u003e'__PAD__'\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'__\u0026#x3C;/e\u003e__'\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'__UNK__'\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e}\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e item \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etraining_corpus\u003c/span\u003e: \n    processed_text = \u003cspan class=\"hljs-title function_\"\u003epreprocess_text\u003c/span\u003e(item)\n    processed_text.\u003cspan class=\"hljs-title function_\"\u003esort\u003c/span\u003e()\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e word \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eprocessed_text\u003c/span\u003e:\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e word not \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003evocab\u003c/span\u003e:\n        vocab[word] = \u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(vocab) \n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e vocab  \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e전체 어휘 사이즈는 얼마인가요?\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003evocab = \u003cspan class=\"hljs-title function_\"\u003eget_vocab\u003c/span\u003e(corpus)\n\u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(vocab)\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이미지 파일:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_11.png\" alt=\"이미지 파일\"\u003e\u003c/p\u003e\n\u003cp\u003e단어장은 2만 6천 개가 조금 넘는 단어를 포함하고 있으며, 각 단어는 정수로 매핑되어 있습니다:\u003c/p\u003e\n\u003cp\u003e이미지 파일:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_12.png\" alt=\"이미지 파일\"\u003e\u003c/p\u003e\n\u003cp\u003e이렇게 설정을 했으면, 문자를 정수로 변환하여 텐서로 변환하는 함수를 사용할 수 있습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003etext_to_tensor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003etext: \u003cspan class=\"hljs-built_in\"\u003estr\u003c/span\u003e, vocab_dict: \u003cspan class=\"hljs-built_in\"\u003edict\u003c/span\u003e\u003c/span\u003e) -\u003e torch.tensor:\n    \u003cspan class=\"hljs-string\"\u003e'''\n    텍스트를 전처리하고 텐서 형식의 정수 매핑을 생성합니다.\n    '''\u003c/span\u003e   \n    word_l = preprocess_text(text)\n        \n    \u003cspan class=\"hljs-comment\"\u003e# 빈 텐서 초기화\u003c/span\u003e\n    tensor_l = [] \n    \n    \u003cspan class=\"hljs-comment\"\u003e# 단어 목록에서 __UNK__ 값을 가져옴\u003c/span\u003e\n    unk_ID = vocab_dict[\u003cspan class=\"hljs-string\"\u003e'__UNK__'\u003c/span\u003e]\n            \n    \u003cspan class=\"hljs-comment\"\u003e# 각 단어에 대해:\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e word \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e word_l:\n        \u003cspan class=\"hljs-comment\"\u003e# 인덱스 가져옴\u003c/span\u003e\n        \u003cspan class=\"hljs-comment\"\u003e# 단어가 vocab_dict에 없으면 UNK로 할당\u003c/span\u003e\n        word_ID = vocab_dict.get(word, unk_ID)\n        \u003cspan class=\"hljs-comment\"\u003e# 텐서 목록에 추가\u003c/span\u003e\n        tensor_l.append(word_ID)\n\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e torch.tensor(tensor_l)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 함수가 텍스트를 텐서로 어떻게 변환하는지에 대한 예시는 아래와 같습니다. 첫 번째 텍스트의 처음 200 단어를 사용하여 검사합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003esnippet = corpus[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e][\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e]\n\u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'텍스트 \"{}\"는 다음과 같이 텐서로 표현됩니다: {}'\u003c/span\u003e.\u003cspan class=\"hljs-built_in\"\u003eformat\u003c/span\u003e(snippet, text_to_tensor(snippet, vocab)))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-12-PyTorchIntroductionUsingCustomData_13.png\"\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e테이블 태그를 마크다운 형식으로 변경해주세요.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 PyTorch 시리즈의 더 많은 포스트를 알아보려면 다음 링크를 확인해보세요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTensor 소개;\u003c/li\u003e\n\u003cli\u003e선형 모델 만들기;\u003c/li\u003e\n\u003cli\u003e활성화 함수 및 비선형 문제;\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 게시물의 자료:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e택시 여행 기간 — \u003ca href=\"https://www.nyc.gov/site/tlc/about/tlc-trip-record-data.page\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://www.nyc.gov/site/tlc/about/tlc-trip-record-data.page\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e고양이와 개 이미지 인용: @Inproceedings (컨퍼런스)'asirra-a-captcha-that-exploits-interest-aligned-manual-image-categorization,\n저자 = 'Elson, Jeremy 및 Douceur, John (JD) 및 Howell, Jon 및 Saul, Jared',\n제목 = 'Asirra: A CAPTCHA that Exploits Interest-Aligned Manual Image Categorization',\n책 제목 = 'Proceedings of 14th ACM Conference on Computer and Communications Security (CCS)',\n연도 = '2007',\n월 = '10월',\n발행사 = 'Association for Computing Machinery, Inc.',\nurl = '\u003ca href=\"https://www.microsoft.com/en-us/research/publication/asirra-a-captcha-that-exploits-interest-aligned-manual-image-categorization/\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://www.microsoft.com/en-us/research/publication/asirra-a-captcha-that-exploits-interest-aligned-manual-image-categorization/\u003c/a\u003e',\n판본 = 'Proceedings of 14th ACM Conference on Computer and Communications Security (CCS)',\n'\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-07-12-PyTorchIntroductionUsingCustomData"},"buildId":"FuXRqV9h16krA5Mvtd6Dn","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>