<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>파이썬으로 AI를 사용해 과학 지식 자동으로 가져오는 방법 | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2024-07-12-AutomatingScientificKnowledgeRetrievalwithAIinPython" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="파이썬으로 AI를 사용해 과학 지식 자동으로 가져오는 방법 | TIL" data-gatsby-head="true"/><meta property="og:title" content="파이썬으로 AI를 사용해 과학 지식 자동으로 가져오는 방법 | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/TIL/assets/img/2024-07-12-AutomatingScientificKnowledgeRetrievalwithAIinPython_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2024-07-12-AutomatingScientificKnowledgeRetrievalwithAIinPython" data-gatsby-head="true"/><meta name="twitter:title" content="파이썬으로 AI를 사용해 과학 지식 자동으로 가져오는 방법 | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/assets/img/2024-07-12-AutomatingScientificKnowledgeRetrievalwithAIinPython_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2024-07-12 20:53" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/TIL/_next/static/chunks/463-925361deb4cec4b1.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/post/%5Bslug%5D-9d7ebbd29b9e08ce.js" defer=""></script><script src="/TIL/_next/static/QAkYP0lvl03W-5CKD69kb/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/QAkYP0lvl03W-5CKD69kb/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">파이썬으로 AI를 사용해 과학 지식 자동으로 가져오는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="파이썬으로 AI를 사용해 과학 지식 자동으로 가져오는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jul 12, 2024</span><span class="posts_reading_time__f7YPP">24<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-07-12-AutomatingScientificKnowledgeRetrievalwithAIinPython&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/TIL/assets/img/2024-07-12-AutomatingScientificKnowledgeRetrievalwithAIinPython_0.png" alt="Automating Scientific Knowledge Retrieval with AI in Python"></p>
<p>과학 논문, 데이터 집합 및 학술 논문의 거대한 양은 오늘날 연구원, 학자 및 전문가들에게 그들의 분야에서 최신 개발 동향을 따라가기 위한 어려움을 제기합니다.</p>
<p>이러한 도전은 과학적 지식 검색 프로세스를 효율적이고 효과적으로 만드는 혁신적인 접근 방식의 필요성을 강조합니다.</p>
<p>AI 및 의미 검색은 정보 접근 및 상호 작용 방식을 변혁하는 데 놀라운 가능성을 보여 주었습니다. 이러한 혁신의 선두에서는 OpenAI 함수의 응용이 있으며, 자연어 입력을 구조화된 출력이나 함수 호출로 변환합니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>예를 들어, 최신 재생 에너지 기술에 대한 질문을 처리해야 할 때 OpenAI의 모델은 최근 논문을 살펴보고 주요 논문과 결과물을 식별하여 연구 트렌드를 요약할 수 있습니다. 특정 키워드에 국한되지 않고 작동할 수 있어요.</p>
<p>이 능력은 연구 과정을 가속화할 뿐만 아니라, 전통적인 검색 방법으로는 즉시 발견하기 어렵거나 연결점과 통찰을 발견하는 데 도움이 됩니다.</p>
<p>이 기사의 목적은 OpenAI 기능과 arXiv API를 활용하여 학술 연구 결과물의 검색, 요약 및 제시를 간소화하는 데 사용할 수 있는 Python 코드를 제공하는 것입니다.</p>
<p>이 안내서의 구성은 다음과 같습니다:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>1. 솔루션 아키텍처</h1>
<p>연구 챗봇을 위한 솔루션 아키텍처는 사용자에게 과학적 지식을 처리하고 전달하기 위한 다층 접근 방식을 구체화합니다.</p>
<p>워크플로우는 복잡한 사용자 쿼리를 처리하고 외부 API와 상호작용하여 정보를 제공하는 데 설계되었습니다.</p>
<p>이 아키텍처는 초기 사용자 입력부터 최종 응답 전달까지의 정보 흐름을 용이하게 하는 다양한 구성 요소를 통합합니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*fjRg85xwRpokyLaOjM3USg.gif" alt="image"></p>
<ol>
<li>
<p>사용자 인터페이스 (UI): 사용자는 이 인터페이스를 통해 쿼리를 제출합니다. 이 경우 주피터 노트북에서 제출됩니다.</p>
</li>
<li>
<p>대화 관리: 이 모듈은 대화를 처리하여 사용자 상호작용 중에 문맥이 유지되도록 합니다.</p>
</li>
<li>
<p>쿼리 처리: 사용자의 쿼리는 이곳에서 해석되며, 의도를 이해하고 후속 조치를 위해 준비됩니다.</p>
</li>
</ol>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ol start="4">
<li>OpenAI API 통합 (임베딩 및 완성):</li>
</ol>
<ul>
<li>완성 부분은 일부 쿼리에 대해 즉시 응답을 생성하는 쿼리를 직접 처리합니다.</li>
<li>임베딩 요청은 학술 논문 검색이 필요한 쿼리에 사용되며 관련 문서를 찾기 위한 벡터를 생성합니다.</li>
</ul>
<ol start="5">
<li>
<p>외부 API (arXiv): 이 부분은 챗봇이 쿼리를 기반으로 arXiv와 같은 외부 데이터베이스와 상호작용하여 과학 논문을 가져오는 곳입니다.</p>
</li>
<li>
<p>기사 가져오기 &#x26; 요약: 이 기능은 기사를 검색한 후 쿼리의 맥락에 따라 요약할 기사를 우선순위로 설정하기 위해 임베딩을 사용합니다.</p>
</li>
</ol>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ol start="7">
<li>
<p>PDF 처리, 텍스트 추출 및 청킹: 자세한 정보가 필요한 경우, 시스템은 PDF를 처리하고 텍스트를 추출하여 작은 조각으로 나누어 요약 작업을 준비합니다.</p>
</li>
<li>
<p>응답 생성:</p>
<ul>
<li>OpenAI API Completion 서비스에서 응답을 통합합니다.</li>
<li>arXiv API에서 검색하고 처리된 논문 요약을 포함하며, 이는 이전에 생성된 임베딩을 기반으로 합니다.</li>
</ul>
</li>
<li>
<p>사용자에게 제공: AI가 생성한 답변과 논문 요약을 결합한 응집된 응답이 사용자에게 제공되는 마지막 단계입니다.</p>
</li>
</ol>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>2. Python 시작하기</h1>
<h2>2.1 필수 라이브러리 설치</h2>
<p>우리는 다양한 Python 라이브러리를 활용하며, 각각이 특정 기능을 제공하여 과학적 지식의 검색 및 처리를 용이하게 합니다. 각 라이브러리와 역할에 대한 개요는 다음과 같습니다:</p>
<ul>
<li>scipy: 과학 계산에 필수적이며, 최적화, 선형 대수, 적분 등을 위한 모듈을 제공합니다.</li>
<li>tenacity: 실패한 작업을 다시 시도하는 기능을 제공하며, 외부 API 또는 데이터베이스에 안정적으로 요청을 보내는 데 유용합니다.</li>
<li>token: OpenAI 모델과 함께 사용하기 위해 설계된 빠른 BPE 토크나이저로, GPT-4와 같은 AI 모델을 처리하기 위한 텍스트의 효율적인 토큰화를 용이하게 합니다.</li>
<li>termcolor: 컬러링된 터미널 출력을 가능하게 하여, 로그 메시지나 디버깅을 편하게 구분할 수 있습니다.</li>
<li>openai: GPT-3와 같은 OpenAI API와 상호 작용하기 위한 공식 라이브러리로, AI 모델 응답을 쿼리하고 수신하는 데 중요합니다.</li>
<li>requests: 웹 서비스 또는 API에 HTTP 요청을 보내기 위한 라이브러리로, 데이터 검색이나 과학 자원과의 상호 작용에 활용될 수 있습니다.</li>
<li>arxiv: arXiv.org의 과학 논문을 검색, 가져오기 및 관리를 간소화합니다.</li>
<li>pandas: 대용량 데이터 처리 및 분석에 중요한 역할을 하며, 대규모 데이터 세트를 처리하는 데 사용되는 구조 및 기능을 제공합니다.</li>
<li>PyPDF2: PDF 파일로부터 텍스트를 추출할 수 있도록 하며, PDF 형식의 과학 논문을 처리하는 데 필수적입니다.</li>
<li>tqdm: 루프나 장기 실행 프로세스에 대한 진행 표시 막대를 생성하여 사용자 경험을 향상시킵니다.</li>
</ul>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>2.2 환경 설정하기</h2>
<p>먼저 OpenAI 플랫폼에 계정을 만들고 계정 설정의 API 섹션에서 API 키를 얻어야 합니다.</p>
<pre><code class="hljs language-js">openai.<span class="hljs-property">api_key</span> = <span class="hljs-string">"API_KEY"</span>

<span class="hljs-variable constant_">GPT_MODEL</span> = <span class="hljs-string">"gpt-3.5-turbo-0613"</span>
<span class="hljs-variable constant_">EMBEDDING_MODEL</span> = <span class="hljs-string">"text-embedding-ada-002"</span>
</code></pre>
<h2>2.3 프로젝트 설정</h2>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>다운로드한 논문이나 데이터를 관리하기 위한 구조화된 디렉토리를 만드는 것은 조직화와 쉬운 접근성을 위해 매우 중요합니다. 필요한 디렉토리를 설정하는 방법을 알려드리겠습니다:</p>
<ul>
<li>디렉토리 구조 생성: 프로젝트의 필요에 맞는 구조를 결정하세요. 다운로드한 논문을 관리하기 위해 ./data/papers 디렉토리가 제안됩니다.</li>
<li>구현: Python의 os 라이브러리를 사용하여 이러한 디렉토리의 존재 여부를 확인하고 없는 경우 생성하세요:</li>
</ul>
<pre><code class="hljs language-python"><span class="hljs-keyword">import</span> os

directory = <span class="hljs-string">'./data/papers'</span>
<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(directory):
    os.makedirs(directory)
</code></pre>
<p>이 코드 조각을 통해 스크립트가 수동 디렉토리 설정 없이 모든 시스템에서 실행될 수 있도록 보장하여 프로젝트의 이식성과 사용자 친화성을 높일 수 있습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>3. 핵심 기능</h1>
<p>과학 지식 검색을 용이하게 하는 것을 목적으로 설계된 연구 챗봇은 여러 가지 핵심 기능을 통합하고 있습니다.</p>
<p>자연어 쿼리 처리, 학술 콘텐츠 검색 및 요약, 그리고 고급 NLP 기법을 활용하여 사용자 상호작용을 향상하는 것이 중심입니다.</p>
<p>아래에서는 이러한 기능들을 자세히 설명하며, 그 구현을 보여주는 구체적인 코드 조각을 강조하겠습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>3.1 임베딩 생성</h2>
<p>사용자 쿼리를 효과적으로 이해하고 처리하기 위해 챗봇은 임베딩을 활용합니다. 임베딩은 텍스트의 의미를 포착하는 수치적인 표현으로, 이는 과학 논문과 쿼리 간의 관련성을 결정하는 작업에 중요합니다.</p>
<pre><code class="hljs language-js">@<span class="hljs-title function_">retry</span>(wait=<span class="hljs-title function_">wait_random_exponential</span>(min=<span class="hljs-number">1</span>, max=<span class="hljs-number">40</span>), stop=<span class="hljs-title function_">stop_after_attempt</span>(<span class="hljs-number">3</span>))
def <span class="hljs-title function_">embedding_request</span>(text):
    response = openai.<span class="hljs-property">Embedding</span>.<span class="hljs-title function_">create</span>(input=text, model=<span class="hljs-variable constant_">EMBEDDING_MODEL</span>)
    <span class="hljs-keyword">return</span> response[<span class="hljs-string">'data'</span>][<span class="hljs-string">'embeddings'</span>]
</code></pre>
<p>이 함수는 재시도 메커니즘으로 OpenAI API에서 임베딩을 요청하며, 잠재적인 API 오류나 요청 한도에 대응하여 견고성을 보장합니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>3.2 학술 논문 검색</h2>
<p>쿼리를 이해한 후, 챗봇은 arXiv와 같은 외부 데이터베이스와 직접 통신하는 능력을 보여주며 관련 학술 논문을 가져옵니다.</p>
<pre><code class="hljs language-js"># arXiv에서 기사 가져오는 함수
def <span class="hljs-title function_">get_articles</span>(query, library=paper_dir_filepath, top_k=<span class="hljs-number">5</span>):
    <span class="hljs-string">""</span><span class="hljs-string">"
    사용자 쿼리와 관련 있는 상위 'k'개의 학술 논문을 arXiv 데이터베이스에서 검색하고 가져옵니다.
    이 함수는 arXiv API를 사용하여 논문을 검색하는데, 검색 기준은 사용자 쿼리이고 결과 수는 'top_k'로 제한됩니다.
    찾은 각 논문에는 제목, 요약, URL과 같은 관련 정보를 리스트에 저장합니다.
    또한 각 논문의 PDF를 다운로드하고, 제목, 다운로드 경로, 논문 제목의 임베딩을 포함한 참조를 'library'로 지정된 CSV 파일에 저장합니다.
    나중에 검색 및 분석을 위해 논문과 임베딩을 기록하는 데 유용합니다.
    이 함수는 read_article_and_summarize에서 사용됩니다.
    "</span><span class="hljs-string">""</span>
    search = arxiv.<span class="hljs-title class_">Search</span>(
        query=query, max_results=top_k, sort_by=arxiv.<span class="hljs-property">SortCriterion</span>.<span class="hljs-property">Relevance</span>
    )
    result_list = []
    <span class="hljs-keyword">for</span> result <span class="hljs-keyword">in</span> search.<span class="hljs-title function_">results</span>():
        result_dict = {}
        result_dict.<span class="hljs-title function_">update</span>({<span class="hljs-string">"title"</span>: result.<span class="hljs-property">title</span>})
        result_dict.<span class="hljs-title function_">update</span>({<span class="hljs-string">"summary"</span>: result.<span class="hljs-property">summary</span>})

        # 첫 번째로 제공된 <span class="hljs-variable constant_">URL</span> 사용
        result_dict.<span class="hljs-title function_">update</span>({<span class="hljs-string">"article_url"</span>: [x.<span class="hljs-property">href</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> result.<span class="hljs-property">links</span>][<span class="hljs-number">0</span>]})
        result_dict.<span class="hljs-title function_">update</span>({<span class="hljs-string">"pdf_url"</span>: [x.<span class="hljs-property">href</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> result.<span class="hljs-property">links</span>][<span class="hljs-number">1</span>]})
        result_list.<span class="hljs-title function_">append</span>(result_dict)

        # 참조를 라이브러리 파일에 저장
        response = <span class="hljs-title function_">embedding_request</span>(text=result.<span class="hljs-property">title</span>)
        file_reference = [
            result.<span class="hljs-property">title</span>,
            result.<span class="hljs-title function_">download_pdf</span>(data_dir),
            response[<span class="hljs-string">"data"</span>][<span class="hljs-number">0</span>][<span class="hljs-string">"embedding"</span>],
        ]

        # 파일에 기록
        <span class="hljs-keyword">with</span> <span class="hljs-title function_">open</span>(library, <span class="hljs-string">"a"</span>) <span class="hljs-keyword">as</span> <span class="hljs-attr">f_object</span>:
            writer_object = <span class="hljs-title function_">writer</span>(f_object)
            writer_object.<span class="hljs-title function_">writerow</span>(file_reference)
            f_object.<span class="hljs-title function_">close</span>()
    <span class="hljs-keyword">return</span> result_list
</code></pre>
<h2>3.3 순위 매기기 및 요약하기</h2>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>해당 논문을 손에 쥐고 있으면 시스템은 쿼리와 관련성에 따라 그들을 순위를 매기고 내용을 요약하여 사용자에게 간결하고 통찰력 있는 정보를 제공합니다.</p>
<pre><code class="hljs language-python"><span class="hljs-comment"># 쿼리 문자열과 관련성을 기준으로 문자열을 순위 매기는 함수</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">strings_ranked_by_relatedness</span>(<span class="hljs-params">
    query: <span class="hljs-built_in">str</span>,
    df: pd.DataFrame,
    relatedness_fn=<span class="hljs-keyword">lambda</span> x, y: <span class="hljs-number">1</span> - spatial.distance.cosine(<span class="hljs-params">x, y</span>),
    top_n: <span class="hljs-built_in">int</span> = <span class="hljs-number">100</span>,
</span>) -> <span class="hljs-built_in">list</span>[<span class="hljs-built_in">str</span>]:

    <span class="hljs-string">"""
    함수는 주어진 쿼리 문자열과 관련성을 기준으로 DataFrame에서 문자열 목록을 순위 매기고 반환합니다.
    함수는 먼저 쿼리 문자열에 대한 임베딩을 얻습니다. 그런 다음 DataFrame의 각 문자열과의 관련성을 계산합니다.
    여기서 제공된 'relatedness_fn'을 사용하여 쿼리와의 관련성을 계산하며, 기본값은 임베딩 간의 코사인 유사도를 계산합니다.
    이러한 문자열을 관련성에 따라 내림차순으로 정렬하여 상위 'n'개의 문자열을 반환합니다.
    """</span>
    query_embedding_response = embedding_request(query)
    query_embedding = query_embedding_response[<span class="hljs-string">"data"</span>][<span class="hljs-number">0</span>][<span class="hljs-string">"embedding"</span>]

    strings_and_relatednesses = [
        (row[<span class="hljs-string">"filepath"</span>], relatedness_fn(query_embedding, row[<span class="hljs-string">"embedding"</span>]))
        <span class="hljs-keyword">for</span> i, row <span class="hljs-keyword">in</span> df.iterrows()
    ]
    
    strings_and_relatednesses.sort(key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>], reverse=<span class="hljs-literal">True</span>)
    strings, relatednesses = <span class="hljs-built_in">zip</span>(*strings_and_relatednesses)
    <span class="hljs-keyword">return</span> strings[:top_n]
</code></pre>
<h2>3.4 학술 논문 요약</h2>
<p>관련 논문을 식별한 후, 챗봇은 과학 문서의 본질을 요약하는 과정을 사용합니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-python"><span class="hljs-comment"># 청크를 요약하고 종합 요약을 반환하는 함수</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">summarize_text</span>(<span class="hljs-params">query</span>):
    <span class="hljs-string">"""
    사용자 쿼리와 관련된 학술 논문을 요약하는 프로세스를 자동화합니다. 다음을 포함합니다:
    1. 데이터 읽기: 논문 및 임베딩 정보가 포함된 'arxiv_library.csv'를 읽습니다.
    2. 관련 논문 식별: 쿼리의 임베딩을 CSV 파일의 임베딩과 비교하여 가장 유사한 항목을 찾습니다.
    3. 텍스트 추출: 식별된 논문의 PDF를 읽어 내용을 문자열로 변환합니다.
    4. 텍스트 청킹: 효율적인 처리를 위해 추출된 텍스트를 관리 가능한 청크로 나눕니다.
    5. 청킹 요약: 각 텍스트 청크는 'extract_chunk' 함수를 사용하여 병렬로 요약됩니다.
    6. 요약 병합: 개별 요약을 최종 종합 요약으로 결합합니다.
    7. 요약 제공: 사용자 쿼리와 관련된 주요 통찰을 중점으로 한 논문의 간략한 개요를 제공합니다.
    """</span>

    <span class="hljs-comment"># 입력된 논문을 재귀적으로 요약하는 방법을 지시하는 메시지</span>
    summary_prompt = <span class="hljs-string">"""학술 논문의 텍스트를 요약하세요. 이유와 함께 중요한 요점을 추출하세요.\n\n내용:"""</span>

    <span class="hljs-comment"># 라이브러리가 비어 있는 경우(아직 검색된 항목이 없는 경우) 한 번 수행하고 결과를 다운로드합니다.</span>
    library_df = pd.read_csv(paper_dir_filepath).reset_index()
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(library_df) == <span class="hljs-number">0</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"아직 검색된 논문이 없습니다. 처음으로 다운로드합니다."</span>)
        get_articles(query)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"논문 다운로드 완료, 계속 진행합니다."</span>)
        library_df = pd.read_csv(paper_dir_filepath).reset_index()
    library_df.columns = [<span class="hljs-string">"title"</span>, <span class="hljs-string">"filepath"</span>, <span class="hljs-string">"embedding"</span>]
    library_df[<span class="hljs-string">"embedding"</span>] = library_df[<span class="hljs-string">"embedding"</span>].apply(ast.literal_eval)
    strings = strings_ranked_by_relatedness(query, library_df, top_n=<span class="hljs-number">1</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"논문에서 텍스트 청킹"</span>)
    pdf_text = read_pdf(strings[<span class="hljs-number">0</span>])

    <span class="hljs-comment"># 토크나이저 초기화</span>
    tokenizer = tiktoken.get_encoding(<span class="hljs-string">"cl100k_base"</span>)
    results = <span class="hljs-string">""</span>

    <span class="hljs-comment"># 문서를 1500 토큰 청크로 분할</span>
    chunks = create_chunks(pdf_text, <span class="hljs-number">1500</span>, tokenizer)
    text_chunks = [tokenizer.decode(chunk) <span class="hljs-keyword">for</span> chunk <span class="hljs-keyword">in</span> chunks]
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"각 텍스트 청크를 요약합니다."</span>)

    <span class="hljs-comment"># 요약을 병렬 처리합니다.</span>
    <span class="hljs-keyword">with</span> concurrent.futures.ThreadPoolExecutor(
        max_workers=<span class="hljs-built_in">len</span>(text_chunks)
    ) <span class="hljs-keyword">as</span> executor:
        futures = [
            executor.submit(extract_chunk, chunk, summary_prompt)
            <span class="hljs-keyword">for</span> chunk <span class="hljs-keyword">in</span> text_chunks
        ]
        <span class="hljs-keyword">with</span> tqdm(total=<span class="hljs-built_in">len</span>(text_chunks)) <span class="hljs-keyword">as</span> pbar:
            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> concurrent.futures.as_completed(futures):
                pbar.update(<span class="hljs-number">1</span>)
        <span class="hljs-keyword">for</span> future <span class="hljs-keyword">in</span> futures:
            data = future.result()
            results += data

    <span class="hljs-comment"># 최종 요약</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"전체 요약으로 요약합니다."</span>)
    response = openai.ChatCompletion.create(
        model=GPT_MODEL,
        messages=[
            {
                <span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>,
                <span class="hljs-string">"content"</span>: <span class="hljs-string">f"""학술 논문에서 추출한 주요 요점을 바탕으로 종합된 요약을 작성합니다.
                        요약은 핵심 주장, 결론 및 증거를 강조하고 사용자 쿼리에 답변해야 합니다.
                        사용자 쿼리: <span class="hljs-subst">{query}</span>
                        요약은 Core Argument, Evidence, 그리고 Conclusions의 제목을 따라 목록으로 구성되어야 합니다.
                        주요 요점:\n<span class="hljs-subst">{results}</span>\nSummary:\n"""</span>,
            }
        ],
        temperature=<span class="hljs-number">0</span>,
    )
    <span class="hljs-keyword">return</span> response
</code></pre>
<h2>3.5 OpenAI 함수의 통합과 사용</h2>
<p>연구용 챗봇은 OpenAI 함수를 활용하여 복잡한 쿼리를 처리하고 응답하기 위한 능력을 향상시킵니다.</p>
<p>이러한 함수들은 챗봇과 다양한 외부 데이터 소스 및 도구 간의 원활한 상호작용을 허용하여 사용자에게 자세하고 정확하며 맥락에 맞는 정보를 제공하여 사용자 경험을 크게 향상시킵니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>OpenAI 함수들은 외부 계산 또는 데이터 검색을 모델의 처리 과정에 직접 통합하여 OpenAI 모델의 기능을 확장하는 데 사용됩니다.</p>
<h3>3.5.1 사용자 정의 OpenAI 함수</h3>
<ul>
<li><strong>get_articles 함수</strong>: 사용자의 쿼리와 관련된 학술 논문을 arXiv 데이터베이스에서 검색하여, 챗봇이 외부 소스에서 실시간 데이터에 접근하는 능력을 보여줍니다.</li>
<li><strong>read_article_and_summarize 함수</strong>: 사용자의 쿼리와 관련된 학술 논문을 arXiv 데이터베이스에서 검색하여, 챗봇이 외부 소스에서 실시간 데이터에 접근하는 능력을 보여줍니다.</li>
</ul>
<p>구현:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"># <span class="hljs-title class_">Function</span> to initiate our get_articles and read_article_and_summarize functions
arxiv_functions = [
    {
        <span class="hljs-string">"name"</span>: <span class="hljs-string">"get_articles"</span>,
        <span class="hljs-string">"description"</span>: <span class="hljs-string">""</span><span class="hljs-string">"Use this function to get academic papers from arXiv to answer user questions."</span><span class="hljs-string">""</span>,
        <span class="hljs-string">"parameters"</span>: {
            <span class="hljs-string">"type"</span>: <span class="hljs-string">"object"</span>,
            <span class="hljs-string">"properties"</span>: {
                <span class="hljs-string">"query"</span>: {
                    <span class="hljs-string">"type"</span>: <span class="hljs-string">"string"</span>,
                    <span class="hljs-string">"description"</span>: f<span class="hljs-string">""</span><span class="hljs-string">"
                            User query in JSON. Responses should be summarized and should include the article URL reference
                            "</span><span class="hljs-string">""</span>,
                }
            },
            <span class="hljs-string">"required"</span>: [<span class="hljs-string">"query"</span>],
        },
    },
    {
        <span class="hljs-string">"name"</span>: <span class="hljs-string">"read_article_and_summarize"</span>,
        <span class="hljs-string">"description"</span>: <span class="hljs-string">""</span><span class="hljs-string">"Use this function to read whole papers and provide a summary for users.
        You should NEVER call this function before get_articles has been called in the conversation."</span><span class="hljs-string">""</span>,
        <span class="hljs-string">"parameters"</span>: {
            <span class="hljs-string">"type"</span>: <span class="hljs-string">"object"</span>,
            <span class="hljs-string">"properties"</span>: {
                <span class="hljs-string">"query"</span>: {
                    <span class="hljs-string">"type"</span>: <span class="hljs-string">"string"</span>,
                    <span class="hljs-string">"description"</span>: f<span class="hljs-string">""</span><span class="hljs-string">"
                            Description of the article in plain text based on the user's query
                            "</span><span class="hljs-string">""</span>,
                }
            },
            <span class="hljs-string">"required"</span>: [<span class="hljs-string">"query"</span>],
        },
    }
]
</code></pre>
<p>이러한 기능을 챗봇의 작업 흐름에 통합하면 OpenAI의 API의 고급 사용 사례를 보여줍니다. 여기서는 대화 컨텍스트에 따라 특정 작업(예: 학술 조사)에 맞게 맞춤형 함수가 실행됩니다.</p>
<h2>3.6 완전한 코드</h2>
<p>필요한 함수 및 대화형 챗봇 상호작용이 포함된 전체 코드를 참조하세요.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 프로젝트 유형뿐만 아니라 AI, 데이터 과학 및 기술 분야의 다양한 혁신적인 데이터 기반 이니셔티브에 대해 <a href="http://www.entreprenerdly.com%EC%9D%98" rel="nofollow" target="_blank">www.entreprenerdly.com의</a> 다양한 자원을 살펴보기를 권장합니다.</p>
<p><img src="/TIL/assets/img/2024-07-12-AutomatingScientificKnowledgeRetrievalwithAIinPython_1.png" alt="image"></p>
<h2>4. 연구 챗봇과 상호작용하기</h2>
<p>이 섹션에서는 사용자-시스템 상호작용 흐름을 설명하는 예제들과 함께 연구 챗봇의 구현과 기능에 대해 깊이 파고들어 논의합니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>4.1 구현 개요</h2>
<p>챗봇은 OpenAI API를 기반으로 구축되었으며, GPT-3 또는 GPT-4와 같은 모델을 활용하여 복잡한 쿼리를 이해하고 사람과 유사한 답변을 생성할 수 있습니다.</p>
<p>구현은 사용자가 쿼리를 입력할 수 있는 인터페이스(명령줄 인터페이스 또는 웹 기반 UI)를 설정하는 것을 포함합니다. 그런 다음 시스템은 이러한 쿼리를 처리하고 OpenAI API와 상호 작용하여 사용자에게 다시 응답을 제시합니다.</p>
<h2>4.2 기능</h2>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>연구 챗봇의 핵심 기능은 다음과 같습니다:</p>
<ul>
<li>질의 이해: 챗봇은 먼저 사용자의 질문을 해석하여 OpenAI 모델의 이해 능력을 활용하여 질문 뒤에 숨은 맥락과 의도를 파악합니다.</li>
<li>정보 검색: 챗봇은 질의에 따라 교육된 지식베이스를 활용하여 직접 답변을 생성하거나 관련 과학 논문과 문서를 가져와 응답을 작성할 수 있습니다.</li>
<li>응답 생성: 챗봇은 검색하거나 생성한 정보를 일관되고 간결한 답변으로 종합하여 사용자에게 제시합니다.</li>
</ul>
<h2>4.3 사용자-시스템 상호작용 흐름</h2>
<ul>
<li>사용자 질의 예시: 사용자가 “양자 컴퓨팅의 최신 발전은 무엇인가요?”라고 묻습니다. 질의 처리:</li>
</ul>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">response = openai.<span class="hljs-property">Completion</span>.<span class="hljs-title function_">create</span>(
  engine=<span class="hljs-string">"davinci"</span>,
  prompt=<span class="hljs-string">"양자 컴퓨팅의 최신 발전 사항은 무엇입니까?"</span>,
  max_tokens=<span class="hljs-number">100</span>
)
</code></pre>
<ul>
<li>답변 생성: 시스템은 답변을 구성하여 양자 컴퓨팅의 최근의 폭발적인 발전을 요약할 수 있습니다.</li>
<li>답변 제시: 챗봇은 사용자의 이해를 돕기 위해 합성된 정보를 출력합니다.</li>
</ul>
<h2>4.3.1 관련 논문 검색</h2>
<p>이 단계는 사용자가 챗봇에게 특정 주제에 대한 논문을 식별하고 검색하는 것을 포함합니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"># 시스템 메시지로 시작합니다
paper_system_message = <span class="hljs-string">""</span><span class="hljs-string">"안녕하세요, 저는 arXivGPT입니다. 사용자의 질문에 답변하기 위해 학술 논문을 가져오는 유용한 도우미입니다.
논문을 명확하게 요약하여 고객이 질문에 대한 답변을 얻기 위해 어떤 논문을 읽어야 하는지 결정할 수 있도록 도와드립니다.
사용자가 논문의 이름을 이해하고 액세스하려면 항상 article_url과 title을 제공합니다.
시작하세요!"</span><span class="hljs-string">""</span>
paper_conversation = <span class="hljs-title class_">Conversation</span>()
paper_conversation.<span class="hljs-title function_">add_message</span>(<span class="hljs-string">"system"</span>, paper_system_message)


# 사용자 메시지 추가
paper_conversation.<span class="hljs-title function_">add_message</span>(<span class="hljs-string">"user"</span>, <span class="hljs-string">"시장 효율성에 대한 최신 정보는 무엇인가요?"</span>) # <span class="hljs-variable constant_">PPO</span> 강화 학습은 어떻게 작동하나요?
chat_response = <span class="hljs-title function_">chat_completion_with_function_execution</span>(
    paper_conversation.<span class="hljs-property">conversation_history</span>, functions=arxiv_functions
)

assistant_message = chat_response[<span class="hljs-string">"choices"</span>][<span class="hljs-number">0</span>][<span class="hljs-string">"message"</span>][<span class="hljs-string">"content"</span>]
paper_conversation.<span class="hljs-title function_">add_message</span>(<span class="hljs-string">"assistant"</span>, assistant_message)
<span class="hljs-title function_">display</span>(<span class="hljs-title class_">Markdown</span>(assistant_message))
</code></pre>
<h2>4.3.2 논문 요약하기</h2>
<p>적절한 논문을 가져온 후, 챗봇은 사용자의 요청을 더 처리하여 특정 논문의 내용을 요약하여 제공함으로써 간결하고 통찰에 풍부한 요약을 제공하며 상호작용을 개선합니다.</p>
<pre><code class="hljs language-js"># 두 번째 도구를 사용하도록 시스템을 유도하기 위해 다른 사용자 메시지 추가
paper_conversation.<span class="hljs-title function_">add_message</span>(
    <span class="hljs-string">"user"</span>,
    <span class="hljs-string">"시장 효율적 교차 시장 추천을 위한 시장-인식 모델 논문을 읽고 요약을 제공해줄 수 있나요?"</span>,
)
updated_response = <span class="hljs-title function_">chat_completion_with_function_execution</span>(
    paper_conversation.<span class="hljs-property">conversation_history</span>, functions=arxiv_functions
)
<span class="hljs-title function_">display</span>(<span class="hljs-title class_">Markdown</span>(updated_response[<span class="hljs-string">"choices"</span>][<span class="hljs-number">0</span>][<span class="hljs-string">"message"</span>][<span class="hljs-string">"content"</span>]))
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>5. 도전과 솔루션</h1>
<h2>5.1 다양한 데이터 소스 통합</h2>
<ul>
<li>도전: 과학적 지식은 학술 저널부터 프리프린트 서버 및 기관 저장소까지 다양한 플랫폼과 형식으로 분산되어 있습니다.</li>
<li>솔루션: 여러 소스에서 데이터를 가져와 정규화하기 위해 다양한 API 및 웹 스크래핑 기술과 연결할 수 있는 모듈식 데이터 수집 프레임워크를 개발해야 합니다.</li>
</ul>
<h2>5.2 사용자-시스템 상호 작용 흐름</h2>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>도전: 특히 다단계 정보 검색 및 처리가 필요한 복잡한 쿼리에 대해 대화 플로우를 자연스럽고 매력적으로 유지하는 것이 도전입니다.</li>
<li>해결책: 사용자 경험을 향상시키기 위해, 챗봇이 사용자와 상호 작용하는 동안 정보 검색을 백그라운드에서 처리하면서 상호 작용적인 세션을 유지할 수 있는 멀티 스레드 요청 처리 시스템을 구현할 수 있습니다.</li>
</ul>
<h2>5.3 연속적인 학습과 개선 보장</h2>
<ul>
<li>도전: 챗봇이 사용자 상호작용에서 지속적으로 학습하고 개선하여 시간이 지남에 따라 정확도와 효과성을 향상시키는 것입니다.</li>
<li>해결책: 사용자가 챗봇의 응답의 relevance 및 정확도를 평가할 수 있는 피드백 루프 메커니즘을 구현합니다. 이 피드백은 모델을 세밀하게 조정하고 응답 품질을 향상시키는 데 사용됩니다.</li>
</ul>
<h2>5.4 실시간 데이터 동기화</h2>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>도전 과제: 챗봇의 데이터베이스를 실시간으로 최신 과학 논문과 동기화하는 것. 새로운 연구가 계속 발표되고 있기 때문에, 챗봇이 가장 최신 정보를 제공하는 것은 상당한 도전입니다.</li>
<li>해결책: 대형 과학 논문 데이터베이스의 웹훅과 RSS 피드를 사용하여 실시간 데이터 동기화 매커니즘을 구현할 수 있습니다. 이를 통해 새로운 논문이 제공되는 즉시 시스템이 자동으로 레포지토리를 업데이트할 수 있습니다.</li>
</ul>
<h2>6. 실용적 응용</h2>
<h3>6.1 학술 연구</h3>
<p>다양한 학문 분야의 연구자들은 이 시스템을 활용하여 문헌 검토 과정을 간소화하고 효율적으로 관련 연구를 찾을 수 있습니다. 연구 주제와 관련된 구체적인 쿼리를 입력함으로써, 시스템은 과학 논문을 신속히 검색하여 주요 결과, 방법론 및 결과를 식별하고 요약할 수 있습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>6.2 산업 연구 및 개발</h2>
<p>제약, 공학 및 기술 연구개발 부서의 빠른 환경에서는 최신 과학적 발견에 대한 최신 정보를 충분히 파악하는 것이 혁신과 경쟁 우위를 유지하는 데 중요합니다. 시스템은 이러한 산업에 최신 연구, 실험 결과 및 기술 발전을 신속하게 접근할 수 있는 강력한 도구를 제공합니다.</p>
<h2>6.3 교육</h2>
<p>교육자와 학생 모두 시스템을 활용하여 학습 경험을 풍부하게 하고 학업 연구를 지원할 수 있습니다. 교사들은 강의를 준비하기 위한 최신 정보를 찾아 수업 내용을 현재와 관련성 있게 전달할 수 있습니다. 마찬가지로 학생들은 에세이, 프로젝트 또는 논문을 위한 소스, 참고 자료 및 사례 연구를 찾기 위해 시스템을 활용할 수 있습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>6.4 데이터 과학 및 AI</h2>
<p>데이터 과학가와 AI 연구원들에게는 시스템이 데이터 세트를 확보하고 복잡한 알고리즘을 이해하며 기존 연구에 대한 벤치마킹을 제공하는 중요한 자원으로 작용합니다. 사용자들은 시스템에서 특정 프로젝트에 가장 최근이고 관련성 있는 데이터 세트를 쿼리할 수 있으며, 데이터 세트의 크기, 다양성 및 응용에 대한 자세한 정보를 얻을 수 있습니다.</p>
<h1>결론과 향후 작업</h1>
<p>이 연구 및 과학적 지식 검색 시스템의 개발과 구현은 인공지능의 변혁적 잠재력을 강조하며, 과학적 조사의 접근성과 효율성을 향상시키는 데 중요한 역할을 합니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>미래 작업은 AI 및 기계 학습의 최신 발전을 활용하여 식별된 과제에 대응하며, 시스템이 최첨단 기술 선두에 머무르고 다양한 사용자들의 요구를 계속 충족할 수 있도록 보장하는 데 초점을 맞추게 될 것입니다.</p>
<p>읽어 주셔서 감사합니다. 만약 이 글이 유익했다면 앞으로의 콘텐츠 지원을 위해 박수를 부탁드립니다. 👏</p>
<p>Entreprenerdly.com에는 행동 가능한 지식을 제공하기 위해 설계된 전체 자습서, 코드 및 전략이 제공됩니다.</p>
<p><img src="/TIL/assets/img/2024-07-12-AutomatingScientificKnowledgeRetrievalwithAIinPython_2.png" alt="2024-07-12-AutomatingScientificKnowledgeRetrievalwithAIinPython_2.png"></p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"파이썬으로 AI를 사용해 과학 지식 자동으로 가져오는 방법","description":"","date":"2024-07-12 20:53","slug":"2024-07-12-AutomatingScientificKnowledgeRetrievalwithAIinPython","content":"\n\n\n![Automating Scientific Knowledge Retrieval with AI in Python](/TIL/assets/img/2024-07-12-AutomatingScientificKnowledgeRetrievalwithAIinPython_0.png)\n\n과학 논문, 데이터 집합 및 학술 논문의 거대한 양은 오늘날 연구원, 학자 및 전문가들에게 그들의 분야에서 최신 개발 동향을 따라가기 위한 어려움을 제기합니다.\n\n이러한 도전은 과학적 지식 검색 프로세스를 효율적이고 효과적으로 만드는 혁신적인 접근 방식의 필요성을 강조합니다.\n\nAI 및 의미 검색은 정보 접근 및 상호 작용 방식을 변혁하는 데 놀라운 가능성을 보여 주었습니다. 이러한 혁신의 선두에서는 OpenAI 함수의 응용이 있으며, 자연어 입력을 구조화된 출력이나 함수 호출로 변환합니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예를 들어, 최신 재생 에너지 기술에 대한 질문을 처리해야 할 때 OpenAI의 모델은 최근 논문을 살펴보고 주요 논문과 결과물을 식별하여 연구 트렌드를 요약할 수 있습니다. 특정 키워드에 국한되지 않고 작동할 수 있어요.\n\n이 능력은 연구 과정을 가속화할 뿐만 아니라, 전통적인 검색 방법으로는 즉시 발견하기 어렵거나 연결점과 통찰을 발견하는 데 도움이 됩니다.\n\n이 기사의 목적은 OpenAI 기능과 arXiv API를 활용하여 학술 연구 결과물의 검색, 요약 및 제시를 간소화하는 데 사용할 수 있는 Python 코드를 제공하는 것입니다.\n\n이 안내서의 구성은 다음과 같습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 1. 솔루션 아키텍처\n\n연구 챗봇을 위한 솔루션 아키텍처는 사용자에게 과학적 지식을 처리하고 전달하기 위한 다층 접근 방식을 구체화합니다.\n\n워크플로우는 복잡한 사용자 쿼리를 처리하고 외부 API와 상호작용하여 정보를 제공하는 데 설계되었습니다.\n\n이 아키텍처는 초기 사용자 입력부터 최종 응답 전달까지의 정보 흐름을 용이하게 하는 다양한 구성 요소를 통합합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*fjRg85xwRpokyLaOjM3USg.gif)\n\n1. 사용자 인터페이스 (UI): 사용자는 이 인터페이스를 통해 쿼리를 제출합니다. 이 경우 주피터 노트북에서 제출됩니다.\n\n2. 대화 관리: 이 모듈은 대화를 처리하여 사용자 상호작용 중에 문맥이 유지되도록 합니다.\n\n3. 쿼리 처리: 사용자의 쿼리는 이곳에서 해석되며, 의도를 이해하고 후속 조치를 위해 준비됩니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n4. OpenAI API 통합 (임베딩 및 완성):\n\n- 완성 부분은 일부 쿼리에 대해 즉시 응답을 생성하는 쿼리를 직접 처리합니다.\n- 임베딩 요청은 학술 논문 검색이 필요한 쿼리에 사용되며 관련 문서를 찾기 위한 벡터를 생성합니다.\n\n5. 외부 API (arXiv): 이 부분은 챗봇이 쿼리를 기반으로 arXiv와 같은 외부 데이터베이스와 상호작용하여 과학 논문을 가져오는 곳입니다.\n\n6. 기사 가져오기 \u0026 요약: 이 기능은 기사를 검색한 후 쿼리의 맥락에 따라 요약할 기사를 우선순위로 설정하기 위해 임베딩을 사용합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n7. PDF 처리, 텍스트 추출 및 청킹: 자세한 정보가 필요한 경우, 시스템은 PDF를 처리하고 텍스트를 추출하여 작은 조각으로 나누어 요약 작업을 준비합니다.\n\n8. 응답 생성:\n   - OpenAI API Completion 서비스에서 응답을 통합합니다.\n   - arXiv API에서 검색하고 처리된 논문 요약을 포함하며, 이는 이전에 생성된 임베딩을 기반으로 합니다.\n\n9. 사용자에게 제공: AI가 생성한 답변과 논문 요약을 결합한 응집된 응답이 사용자에게 제공되는 마지막 단계입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 2. Python 시작하기\n\n## 2.1 필수 라이브러리 설치\n\n우리는 다양한 Python 라이브러리를 활용하며, 각각이 특정 기능을 제공하여 과학적 지식의 검색 및 처리를 용이하게 합니다. 각 라이브러리와 역할에 대한 개요는 다음과 같습니다:\n\n- scipy: 과학 계산에 필수적이며, 최적화, 선형 대수, 적분 등을 위한 모듈을 제공합니다.\n- tenacity: 실패한 작업을 다시 시도하는 기능을 제공하며, 외부 API 또는 데이터베이스에 안정적으로 요청을 보내는 데 유용합니다.\n- token: OpenAI 모델과 함께 사용하기 위해 설계된 빠른 BPE 토크나이저로, GPT-4와 같은 AI 모델을 처리하기 위한 텍스트의 효율적인 토큰화를 용이하게 합니다.\n- termcolor: 컬러링된 터미널 출력을 가능하게 하여, 로그 메시지나 디버깅을 편하게 구분할 수 있습니다.\n- openai: GPT-3와 같은 OpenAI API와 상호 작용하기 위한 공식 라이브러리로, AI 모델 응답을 쿼리하고 수신하는 데 중요합니다.\n- requests: 웹 서비스 또는 API에 HTTP 요청을 보내기 위한 라이브러리로, 데이터 검색이나 과학 자원과의 상호 작용에 활용될 수 있습니다.\n- arxiv: arXiv.org의 과학 논문을 검색, 가져오기 및 관리를 간소화합니다.\n- pandas: 대용량 데이터 처리 및 분석에 중요한 역할을 하며, 대규모 데이터 세트를 처리하는 데 사용되는 구조 및 기능을 제공합니다.\n- PyPDF2: PDF 파일로부터 텍스트를 추출할 수 있도록 하며, PDF 형식의 과학 논문을 처리하는 데 필수적입니다.\n- tqdm: 루프나 장기 실행 프로세스에 대한 진행 표시 막대를 생성하여 사용자 경험을 향상시킵니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 2.2 환경 설정하기\n\n먼저 OpenAI 플랫폼에 계정을 만들고 계정 설정의 API 섹션에서 API 키를 얻어야 합니다.\n\n```js\nopenai.api_key = \"API_KEY\"\n\nGPT_MODEL = \"gpt-3.5-turbo-0613\"\nEMBEDDING_MODEL = \"text-embedding-ada-002\"\n```\n\n## 2.3 프로젝트 설정\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다운로드한 논문이나 데이터를 관리하기 위한 구조화된 디렉토리를 만드는 것은 조직화와 쉬운 접근성을 위해 매우 중요합니다. 필요한 디렉토리를 설정하는 방법을 알려드리겠습니다:\n\n- 디렉토리 구조 생성: 프로젝트의 필요에 맞는 구조를 결정하세요. 다운로드한 논문을 관리하기 위해 ./data/papers 디렉토리가 제안됩니다.\n- 구현: Python의 os 라이브러리를 사용하여 이러한 디렉토리의 존재 여부를 확인하고 없는 경우 생성하세요:\n\n```python\nimport os\n\ndirectory = './data/papers'\nif not os.path.exists(directory):\n    os.makedirs(directory)\n```\n\n이 코드 조각을 통해 스크립트가 수동 디렉토리 설정 없이 모든 시스템에서 실행될 수 있도록 보장하여 프로젝트의 이식성과 사용자 친화성을 높일 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 3. 핵심 기능\n\n과학 지식 검색을 용이하게 하는 것을 목적으로 설계된 연구 챗봇은 여러 가지 핵심 기능을 통합하고 있습니다.\n\n자연어 쿼리 처리, 학술 콘텐츠 검색 및 요약, 그리고 고급 NLP 기법을 활용하여 사용자 상호작용을 향상하는 것이 중심입니다.\n\n아래에서는 이러한 기능들을 자세히 설명하며, 그 구현을 보여주는 구체적인 코드 조각을 강조하겠습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 3.1 임베딩 생성\n\n사용자 쿼리를 효과적으로 이해하고 처리하기 위해 챗봇은 임베딩을 활용합니다. 임베딩은 텍스트의 의미를 포착하는 수치적인 표현으로, 이는 과학 논문과 쿼리 간의 관련성을 결정하는 작업에 중요합니다.\n\n```js\n@retry(wait=wait_random_exponential(min=1, max=40), stop=stop_after_attempt(3))\ndef embedding_request(text):\n    response = openai.Embedding.create(input=text, model=EMBEDDING_MODEL)\n    return response['data']['embeddings']\n```\n\n이 함수는 재시도 메커니즘으로 OpenAI API에서 임베딩을 요청하며, 잠재적인 API 오류나 요청 한도에 대응하여 견고성을 보장합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 3.2 학술 논문 검색\n\n쿼리를 이해한 후, 챗봇은 arXiv와 같은 외부 데이터베이스와 직접 통신하는 능력을 보여주며 관련 학술 논문을 가져옵니다.\n\n```js\n# arXiv에서 기사 가져오는 함수\ndef get_articles(query, library=paper_dir_filepath, top_k=5):\n    \"\"\"\n    사용자 쿼리와 관련 있는 상위 'k'개의 학술 논문을 arXiv 데이터베이스에서 검색하고 가져옵니다.\n    이 함수는 arXiv API를 사용하여 논문을 검색하는데, 검색 기준은 사용자 쿼리이고 결과 수는 'top_k'로 제한됩니다.\n    찾은 각 논문에는 제목, 요약, URL과 같은 관련 정보를 리스트에 저장합니다.\n    또한 각 논문의 PDF를 다운로드하고, 제목, 다운로드 경로, 논문 제목의 임베딩을 포함한 참조를 'library'로 지정된 CSV 파일에 저장합니다.\n    나중에 검색 및 분석을 위해 논문과 임베딩을 기록하는 데 유용합니다.\n    이 함수는 read_article_and_summarize에서 사용됩니다.\n    \"\"\"\n    search = arxiv.Search(\n        query=query, max_results=top_k, sort_by=arxiv.SortCriterion.Relevance\n    )\n    result_list = []\n    for result in search.results():\n        result_dict = {}\n        result_dict.update({\"title\": result.title})\n        result_dict.update({\"summary\": result.summary})\n\n        # 첫 번째로 제공된 URL 사용\n        result_dict.update({\"article_url\": [x.href for x in result.links][0]})\n        result_dict.update({\"pdf_url\": [x.href for x in result.links][1]})\n        result_list.append(result_dict)\n\n        # 참조를 라이브러리 파일에 저장\n        response = embedding_request(text=result.title)\n        file_reference = [\n            result.title,\n            result.download_pdf(data_dir),\n            response[\"data\"][0][\"embedding\"],\n        ]\n\n        # 파일에 기록\n        with open(library, \"a\") as f_object:\n            writer_object = writer(f_object)\n            writer_object.writerow(file_reference)\n            f_object.close()\n    return result_list\n```\n\n## 3.3 순위 매기기 및 요약하기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n해당 논문을 손에 쥐고 있으면 시스템은 쿼리와 관련성에 따라 그들을 순위를 매기고 내용을 요약하여 사용자에게 간결하고 통찰력 있는 정보를 제공합니다.\n\n```python\n# 쿼리 문자열과 관련성을 기준으로 문자열을 순위 매기는 함수\ndef strings_ranked_by_relatedness(\n    query: str,\n    df: pd.DataFrame,\n    relatedness_fn=lambda x, y: 1 - spatial.distance.cosine(x, y),\n    top_n: int = 100,\n) -\u003e list[str]:\n\n    \"\"\"\n    함수는 주어진 쿼리 문자열과 관련성을 기준으로 DataFrame에서 문자열 목록을 순위 매기고 반환합니다.\n    함수는 먼저 쿼리 문자열에 대한 임베딩을 얻습니다. 그런 다음 DataFrame의 각 문자열과의 관련성을 계산합니다.\n    여기서 제공된 'relatedness_fn'을 사용하여 쿼리와의 관련성을 계산하며, 기본값은 임베딩 간의 코사인 유사도를 계산합니다.\n    이러한 문자열을 관련성에 따라 내림차순으로 정렬하여 상위 'n'개의 문자열을 반환합니다.\n    \"\"\"\n    query_embedding_response = embedding_request(query)\n    query_embedding = query_embedding_response[\"data\"][0][\"embedding\"]\n\n    strings_and_relatednesses = [\n        (row[\"filepath\"], relatedness_fn(query_embedding, row[\"embedding\"]))\n        for i, row in df.iterrows()\n    ]\n    \n    strings_and_relatednesses.sort(key=lambda x: x[1], reverse=True)\n    strings, relatednesses = zip(*strings_and_relatednesses)\n    return strings[:top_n]\n```\n\n## 3.4 학술 논문 요약\n\n관련 논문을 식별한 후, 챗봇은 과학 문서의 본질을 요약하는 과정을 사용합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\n# 청크를 요약하고 종합 요약을 반환하는 함수\ndef summarize_text(query):\n    \"\"\"\n    사용자 쿼리와 관련된 학술 논문을 요약하는 프로세스를 자동화합니다. 다음을 포함합니다:\n    1. 데이터 읽기: 논문 및 임베딩 정보가 포함된 'arxiv_library.csv'를 읽습니다.\n    2. 관련 논문 식별: 쿼리의 임베딩을 CSV 파일의 임베딩과 비교하여 가장 유사한 항목을 찾습니다.\n    3. 텍스트 추출: 식별된 논문의 PDF를 읽어 내용을 문자열로 변환합니다.\n    4. 텍스트 청킹: 효율적인 처리를 위해 추출된 텍스트를 관리 가능한 청크로 나눕니다.\n    5. 청킹 요약: 각 텍스트 청크는 'extract_chunk' 함수를 사용하여 병렬로 요약됩니다.\n    6. 요약 병합: 개별 요약을 최종 종합 요약으로 결합합니다.\n    7. 요약 제공: 사용자 쿼리와 관련된 주요 통찰을 중점으로 한 논문의 간략한 개요를 제공합니다.\n    \"\"\"\n\n    # 입력된 논문을 재귀적으로 요약하는 방법을 지시하는 메시지\n    summary_prompt = \"\"\"학술 논문의 텍스트를 요약하세요. 이유와 함께 중요한 요점을 추출하세요.\\n\\n내용:\"\"\"\n\n    # 라이브러리가 비어 있는 경우(아직 검색된 항목이 없는 경우) 한 번 수행하고 결과를 다운로드합니다.\n    library_df = pd.read_csv(paper_dir_filepath).reset_index()\n    if len(library_df) == 0:\n        print(\"아직 검색된 논문이 없습니다. 처음으로 다운로드합니다.\")\n        get_articles(query)\n        print(\"논문 다운로드 완료, 계속 진행합니다.\")\n        library_df = pd.read_csv(paper_dir_filepath).reset_index()\n    library_df.columns = [\"title\", \"filepath\", \"embedding\"]\n    library_df[\"embedding\"] = library_df[\"embedding\"].apply(ast.literal_eval)\n    strings = strings_ranked_by_relatedness(query, library_df, top_n=1)\n    print(\"논문에서 텍스트 청킹\")\n    pdf_text = read_pdf(strings[0])\n\n    # 토크나이저 초기화\n    tokenizer = tiktoken.get_encoding(\"cl100k_base\")\n    results = \"\"\n\n    # 문서를 1500 토큰 청크로 분할\n    chunks = create_chunks(pdf_text, 1500, tokenizer)\n    text_chunks = [tokenizer.decode(chunk) for chunk in chunks]\n    print(\"각 텍스트 청크를 요약합니다.\")\n\n    # 요약을 병렬 처리합니다.\n    with concurrent.futures.ThreadPoolExecutor(\n        max_workers=len(text_chunks)\n    ) as executor:\n        futures = [\n            executor.submit(extract_chunk, chunk, summary_prompt)\n            for chunk in text_chunks\n        ]\n        with tqdm(total=len(text_chunks)) as pbar:\n            for _ in concurrent.futures.as_completed(futures):\n                pbar.update(1)\n        for future in futures:\n            data = future.result()\n            results += data\n\n    # 최종 요약\n    print(\"전체 요약으로 요약합니다.\")\n    response = openai.ChatCompletion.create(\n        model=GPT_MODEL,\n        messages=[\n            {\n                \"role\": \"user\",\n                \"content\": f\"\"\"학술 논문에서 추출한 주요 요점을 바탕으로 종합된 요약을 작성합니다.\n                        요약은 핵심 주장, 결론 및 증거를 강조하고 사용자 쿼리에 답변해야 합니다.\n                        사용자 쿼리: {query}\n                        요약은 Core Argument, Evidence, 그리고 Conclusions의 제목을 따라 목록으로 구성되어야 합니다.\n                        주요 요점:\\n{results}\\nSummary:\\n\"\"\",\n            }\n        ],\n        temperature=0,\n    )\n    return response\n```\n\n## 3.5 OpenAI 함수의 통합과 사용\n\n연구용 챗봇은 OpenAI 함수를 활용하여 복잡한 쿼리를 처리하고 응답하기 위한 능력을 향상시킵니다.\n\n이러한 함수들은 챗봇과 다양한 외부 데이터 소스 및 도구 간의 원활한 상호작용을 허용하여 사용자에게 자세하고 정확하며 맥락에 맞는 정보를 제공하여 사용자 경험을 크게 향상시킵니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nOpenAI 함수들은 외부 계산 또는 데이터 검색을 모델의 처리 과정에 직접 통합하여 OpenAI 모델의 기능을 확장하는 데 사용됩니다.\n\n### 3.5.1 사용자 정의 OpenAI 함수\n\n- **get_articles 함수**: 사용자의 쿼리와 관련된 학술 논문을 arXiv 데이터베이스에서 검색하여, 챗봇이 외부 소스에서 실시간 데이터에 접근하는 능력을 보여줍니다.\n- **read_article_and_summarize 함수**: 사용자의 쿼리와 관련된 학술 논문을 arXiv 데이터베이스에서 검색하여, 챗봇이 외부 소스에서 실시간 데이터에 접근하는 능력을 보여줍니다.\n\n구현:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# Function to initiate our get_articles and read_article_and_summarize functions\narxiv_functions = [\n    {\n        \"name\": \"get_articles\",\n        \"description\": \"\"\"Use this function to get academic papers from arXiv to answer user questions.\"\"\",\n        \"parameters\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"query\": {\n                    \"type\": \"string\",\n                    \"description\": f\"\"\"\n                            User query in JSON. Responses should be summarized and should include the article URL reference\n                            \"\"\",\n                }\n            },\n            \"required\": [\"query\"],\n        },\n    },\n    {\n        \"name\": \"read_article_and_summarize\",\n        \"description\": \"\"\"Use this function to read whole papers and provide a summary for users.\n        You should NEVER call this function before get_articles has been called in the conversation.\"\"\",\n        \"parameters\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"query\": {\n                    \"type\": \"string\",\n                    \"description\": f\"\"\"\n                            Description of the article in plain text based on the user's query\n                            \"\"\",\n                }\n            },\n            \"required\": [\"query\"],\n        },\n    }\n]\r\n```\n\n이러한 기능을 챗봇의 작업 흐름에 통합하면 OpenAI의 API의 고급 사용 사례를 보여줍니다. 여기서는 대화 컨텍스트에 따라 특정 작업(예: 학술 조사)에 맞게 맞춤형 함수가 실행됩니다.\n\n## 3.6 완전한 코드\n\n필요한 함수 및 대화형 챗봇 상호작용이 포함된 전체 코드를 참조하세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 프로젝트 유형뿐만 아니라 AI, 데이터 과학 및 기술 분야의 다양한 혁신적인 데이터 기반 이니셔티브에 대해 www.entreprenerdly.com의 다양한 자원을 살펴보기를 권장합니다.\n\n![image](/TIL/assets/img/2024-07-12-AutomatingScientificKnowledgeRetrievalwithAIinPython_1.png)\n\n## 4. 연구 챗봇과 상호작용하기\n\n이 섹션에서는 사용자-시스템 상호작용 흐름을 설명하는 예제들과 함께 연구 챗봇의 구현과 기능에 대해 깊이 파고들어 논의합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 4.1 구현 개요\n\n챗봇은 OpenAI API를 기반으로 구축되었으며, GPT-3 또는 GPT-4와 같은 모델을 활용하여 복잡한 쿼리를 이해하고 사람과 유사한 답변을 생성할 수 있습니다.\n\n구현은 사용자가 쿼리를 입력할 수 있는 인터페이스(명령줄 인터페이스 또는 웹 기반 UI)를 설정하는 것을 포함합니다. 그런 다음 시스템은 이러한 쿼리를 처리하고 OpenAI API와 상호 작용하여 사용자에게 다시 응답을 제시합니다.\n\n## 4.2 기능\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n연구 챗봇의 핵심 기능은 다음과 같습니다:\n\n- 질의 이해: 챗봇은 먼저 사용자의 질문을 해석하여 OpenAI 모델의 이해 능력을 활용하여 질문 뒤에 숨은 맥락과 의도를 파악합니다.\n- 정보 검색: 챗봇은 질의에 따라 교육된 지식베이스를 활용하여 직접 답변을 생성하거나 관련 과학 논문과 문서를 가져와 응답을 작성할 수 있습니다.\n- 응답 생성: 챗봇은 검색하거나 생성한 정보를 일관되고 간결한 답변으로 종합하여 사용자에게 제시합니다.\n\n## 4.3 사용자-시스템 상호작용 흐름\n\n- 사용자 질의 예시: 사용자가 “양자 컴퓨팅의 최신 발전은 무엇인가요?”라고 묻습니다. 질의 처리:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nresponse = openai.Completion.create(\n  engine=\"davinci\",\n  prompt=\"양자 컴퓨팅의 최신 발전 사항은 무엇입니까?\",\n  max_tokens=100\n)\n```\n\n- 답변 생성: 시스템은 답변을 구성하여 양자 컴퓨팅의 최근의 폭발적인 발전을 요약할 수 있습니다.\n- 답변 제시: 챗봇은 사용자의 이해를 돕기 위해 합성된 정보를 출력합니다.\n\n## 4.3.1 관련 논문 검색\n\n이 단계는 사용자가 챗봇에게 특정 주제에 대한 논문을 식별하고 검색하는 것을 포함합니다.  \n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 시스템 메시지로 시작합니다\npaper_system_message = \"\"\"안녕하세요, 저는 arXivGPT입니다. 사용자의 질문에 답변하기 위해 학술 논문을 가져오는 유용한 도우미입니다.\n논문을 명확하게 요약하여 고객이 질문에 대한 답변을 얻기 위해 어떤 논문을 읽어야 하는지 결정할 수 있도록 도와드립니다.\n사용자가 논문의 이름을 이해하고 액세스하려면 항상 article_url과 title을 제공합니다.\n시작하세요!\"\"\"\npaper_conversation = Conversation()\npaper_conversation.add_message(\"system\", paper_system_message)\n\n\n# 사용자 메시지 추가\npaper_conversation.add_message(\"user\", \"시장 효율성에 대한 최신 정보는 무엇인가요?\") # PPO 강화 학습은 어떻게 작동하나요?\nchat_response = chat_completion_with_function_execution(\n    paper_conversation.conversation_history, functions=arxiv_functions\n)\n\nassistant_message = chat_response[\"choices\"][0][\"message\"][\"content\"]\npaper_conversation.add_message(\"assistant\", assistant_message)\ndisplay(Markdown(assistant_message))\n```\n\n## 4.3.2 논문 요약하기\n\n적절한 논문을 가져온 후, 챗봇은 사용자의 요청을 더 처리하여 특정 논문의 내용을 요약하여 제공함으로써 간결하고 통찰에 풍부한 요약을 제공하며 상호작용을 개선합니다.\n\n```js\n# 두 번째 도구를 사용하도록 시스템을 유도하기 위해 다른 사용자 메시지 추가\npaper_conversation.add_message(\n    \"user\",\n    \"시장 효율적 교차 시장 추천을 위한 시장-인식 모델 논문을 읽고 요약을 제공해줄 수 있나요?\",\n)\nupdated_response = chat_completion_with_function_execution(\n    paper_conversation.conversation_history, functions=arxiv_functions\n)\ndisplay(Markdown(updated_response[\"choices\"][0][\"message\"][\"content\"]))\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 5. 도전과 솔루션\n\n## 5.1 다양한 데이터 소스 통합\n\n- 도전: 과학적 지식은 학술 저널부터 프리프린트 서버 및 기관 저장소까지 다양한 플랫폼과 형식으로 분산되어 있습니다.\n- 솔루션: 여러 소스에서 데이터를 가져와 정규화하기 위해 다양한 API 및 웹 스크래핑 기술과 연결할 수 있는 모듈식 데이터 수집 프레임워크를 개발해야 합니다.\n\n## 5.2 사용자-시스템 상호 작용 흐름\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 도전: 특히 다단계 정보 검색 및 처리가 필요한 복잡한 쿼리에 대해 대화 플로우를 자연스럽고 매력적으로 유지하는 것이 도전입니다.\n- 해결책: 사용자 경험을 향상시키기 위해, 챗봇이 사용자와 상호 작용하는 동안 정보 검색을 백그라운드에서 처리하면서 상호 작용적인 세션을 유지할 수 있는 멀티 스레드 요청 처리 시스템을 구현할 수 있습니다.\n\n## 5.3 연속적인 학습과 개선 보장\n\n- 도전: 챗봇이 사용자 상호작용에서 지속적으로 학습하고 개선하여 시간이 지남에 따라 정확도와 효과성을 향상시키는 것입니다.\n- 해결책: 사용자가 챗봇의 응답의 relevance 및 정확도를 평가할 수 있는 피드백 루프 메커니즘을 구현합니다. 이 피드백은 모델을 세밀하게 조정하고 응답 품질을 향상시키는 데 사용됩니다.\n\n## 5.4 실시간 데이터 동기화\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 도전 과제: 챗봇의 데이터베이스를 실시간으로 최신 과학 논문과 동기화하는 것. 새로운 연구가 계속 발표되고 있기 때문에, 챗봇이 가장 최신 정보를 제공하는 것은 상당한 도전입니다.\n- 해결책: 대형 과학 논문 데이터베이스의 웹훅과 RSS 피드를 사용하여 실시간 데이터 동기화 매커니즘을 구현할 수 있습니다. 이를 통해 새로운 논문이 제공되는 즉시 시스템이 자동으로 레포지토리를 업데이트할 수 있습니다.\n\n## 6. 실용적 응용\n\n### 6.1 학술 연구\n\n다양한 학문 분야의 연구자들은 이 시스템을 활용하여 문헌 검토 과정을 간소화하고 효율적으로 관련 연구를 찾을 수 있습니다. 연구 주제와 관련된 구체적인 쿼리를 입력함으로써, 시스템은 과학 논문을 신속히 검색하여 주요 결과, 방법론 및 결과를 식별하고 요약할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 6.2 산업 연구 및 개발\n\n제약, 공학 및 기술 연구개발 부서의 빠른 환경에서는 최신 과학적 발견에 대한 최신 정보를 충분히 파악하는 것이 혁신과 경쟁 우위를 유지하는 데 중요합니다. 시스템은 이러한 산업에 최신 연구, 실험 결과 및 기술 발전을 신속하게 접근할 수 있는 강력한 도구를 제공합니다.\n\n## 6.3 교육\n\n교육자와 학생 모두 시스템을 활용하여 학습 경험을 풍부하게 하고 학업 연구를 지원할 수 있습니다. 교사들은 강의를 준비하기 위한 최신 정보를 찾아 수업 내용을 현재와 관련성 있게 전달할 수 있습니다. 마찬가지로 학생들은 에세이, 프로젝트 또는 논문을 위한 소스, 참고 자료 및 사례 연구를 찾기 위해 시스템을 활용할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 6.4 데이터 과학 및 AI\n\n데이터 과학가와 AI 연구원들에게는 시스템이 데이터 세트를 확보하고 복잡한 알고리즘을 이해하며 기존 연구에 대한 벤치마킹을 제공하는 중요한 자원으로 작용합니다. 사용자들은 시스템에서 특정 프로젝트에 가장 최근이고 관련성 있는 데이터 세트를 쿼리할 수 있으며, 데이터 세트의 크기, 다양성 및 응용에 대한 자세한 정보를 얻을 수 있습니다.\n\n# 결론과 향후 작업\n\n이 연구 및 과학적 지식 검색 시스템의 개발과 구현은 인공지능의 변혁적 잠재력을 강조하며, 과학적 조사의 접근성과 효율성을 향상시키는 데 중요한 역할을 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n미래 작업은 AI 및 기계 학습의 최신 발전을 활용하여 식별된 과제에 대응하며, 시스템이 최첨단 기술 선두에 머무르고 다양한 사용자들의 요구를 계속 충족할 수 있도록 보장하는 데 초점을 맞추게 될 것입니다.\n\n읽어 주셔서 감사합니다. 만약 이 글이 유익했다면 앞으로의 콘텐츠 지원을 위해 박수를 부탁드립니다. 👏\n\nEntreprenerdly.com에는 행동 가능한 지식을 제공하기 위해 설계된 전체 자습서, 코드 및 전략이 제공됩니다.\n\n![2024-07-12-AutomatingScientificKnowledgeRetrievalwithAIinPython_2.png](/TIL/assets/img/2024-07-12-AutomatingScientificKnowledgeRetrievalwithAIinPython_2.png)","ogImage":{"url":"/TIL/assets/img/2024-07-12-AutomatingScientificKnowledgeRetrievalwithAIinPython_0.png"},"coverImage":"/TIL/assets/img/2024-07-12-AutomatingScientificKnowledgeRetrievalwithAIinPython_0.png","tag":["Tech"],"readingTime":24},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-12-AutomatingScientificKnowledgeRetrievalwithAIinPython_0.png\" alt=\"Automating Scientific Knowledge Retrieval with AI in Python\"\u003e\u003c/p\u003e\n\u003cp\u003e과학 논문, 데이터 집합 및 학술 논문의 거대한 양은 오늘날 연구원, 학자 및 전문가들에게 그들의 분야에서 최신 개발 동향을 따라가기 위한 어려움을 제기합니다.\u003c/p\u003e\n\u003cp\u003e이러한 도전은 과학적 지식 검색 프로세스를 효율적이고 효과적으로 만드는 혁신적인 접근 방식의 필요성을 강조합니다.\u003c/p\u003e\n\u003cp\u003eAI 및 의미 검색은 정보 접근 및 상호 작용 방식을 변혁하는 데 놀라운 가능성을 보여 주었습니다. 이러한 혁신의 선두에서는 OpenAI 함수의 응용이 있으며, 자연어 입력을 구조화된 출력이나 함수 호출로 변환합니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e예를 들어, 최신 재생 에너지 기술에 대한 질문을 처리해야 할 때 OpenAI의 모델은 최근 논문을 살펴보고 주요 논문과 결과물을 식별하여 연구 트렌드를 요약할 수 있습니다. 특정 키워드에 국한되지 않고 작동할 수 있어요.\u003c/p\u003e\n\u003cp\u003e이 능력은 연구 과정을 가속화할 뿐만 아니라, 전통적인 검색 방법으로는 즉시 발견하기 어렵거나 연결점과 통찰을 발견하는 데 도움이 됩니다.\u003c/p\u003e\n\u003cp\u003e이 기사의 목적은 OpenAI 기능과 arXiv API를 활용하여 학술 연구 결과물의 검색, 요약 및 제시를 간소화하는 데 사용할 수 있는 Python 코드를 제공하는 것입니다.\u003c/p\u003e\n\u003cp\u003e이 안내서의 구성은 다음과 같습니다:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e1. 솔루션 아키텍처\u003c/h1\u003e\n\u003cp\u003e연구 챗봇을 위한 솔루션 아키텍처는 사용자에게 과학적 지식을 처리하고 전달하기 위한 다층 접근 방식을 구체화합니다.\u003c/p\u003e\n\u003cp\u003e워크플로우는 복잡한 사용자 쿼리를 처리하고 외부 API와 상호작용하여 정보를 제공하는 데 설계되었습니다.\u003c/p\u003e\n\u003cp\u003e이 아키텍처는 초기 사용자 입력부터 최종 응답 전달까지의 정보 흐름을 용이하게 하는 다양한 구성 요소를 통합합니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*fjRg85xwRpokyLaOjM3USg.gif\" alt=\"image\"\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e사용자 인터페이스 (UI): 사용자는 이 인터페이스를 통해 쿼리를 제출합니다. 이 경우 주피터 노트북에서 제출됩니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e대화 관리: 이 모듈은 대화를 처리하여 사용자 상호작용 중에 문맥이 유지되도록 합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e쿼리 처리: 사용자의 쿼리는 이곳에서 해석되며, 의도를 이해하고 후속 조치를 위해 준비됩니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003eOpenAI API 통합 (임베딩 및 완성):\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e완성 부분은 일부 쿼리에 대해 즉시 응답을 생성하는 쿼리를 직접 처리합니다.\u003c/li\u003e\n\u003cli\u003e임베딩 요청은 학술 논문 검색이 필요한 쿼리에 사용되며 관련 문서를 찾기 위한 벡터를 생성합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"5\"\u003e\n\u003cli\u003e\n\u003cp\u003e외부 API (arXiv): 이 부분은 챗봇이 쿼리를 기반으로 arXiv와 같은 외부 데이터베이스와 상호작용하여 과학 논문을 가져오는 곳입니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e기사 가져오기 \u0026#x26; 요약: 이 기능은 기사를 검색한 후 쿼리의 맥락에 따라 요약할 기사를 우선순위로 설정하기 위해 임베딩을 사용합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003col start=\"7\"\u003e\n\u003cli\u003e\n\u003cp\u003ePDF 처리, 텍스트 추출 및 청킹: 자세한 정보가 필요한 경우, 시스템은 PDF를 처리하고 텍스트를 추출하여 작은 조각으로 나누어 요약 작업을 준비합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e응답 생성:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eOpenAI API Completion 서비스에서 응답을 통합합니다.\u003c/li\u003e\n\u003cli\u003earXiv API에서 검색하고 처리된 논문 요약을 포함하며, 이는 이전에 생성된 임베딩을 기반으로 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e사용자에게 제공: AI가 생성한 답변과 논문 요약을 결합한 응집된 응답이 사용자에게 제공되는 마지막 단계입니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e2. Python 시작하기\u003c/h1\u003e\n\u003ch2\u003e2.1 필수 라이브러리 설치\u003c/h2\u003e\n\u003cp\u003e우리는 다양한 Python 라이브러리를 활용하며, 각각이 특정 기능을 제공하여 과학적 지식의 검색 및 처리를 용이하게 합니다. 각 라이브러리와 역할에 대한 개요는 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003escipy: 과학 계산에 필수적이며, 최적화, 선형 대수, 적분 등을 위한 모듈을 제공합니다.\u003c/li\u003e\n\u003cli\u003etenacity: 실패한 작업을 다시 시도하는 기능을 제공하며, 외부 API 또는 데이터베이스에 안정적으로 요청을 보내는 데 유용합니다.\u003c/li\u003e\n\u003cli\u003etoken: OpenAI 모델과 함께 사용하기 위해 설계된 빠른 BPE 토크나이저로, GPT-4와 같은 AI 모델을 처리하기 위한 텍스트의 효율적인 토큰화를 용이하게 합니다.\u003c/li\u003e\n\u003cli\u003etermcolor: 컬러링된 터미널 출력을 가능하게 하여, 로그 메시지나 디버깅을 편하게 구분할 수 있습니다.\u003c/li\u003e\n\u003cli\u003eopenai: GPT-3와 같은 OpenAI API와 상호 작용하기 위한 공식 라이브러리로, AI 모델 응답을 쿼리하고 수신하는 데 중요합니다.\u003c/li\u003e\n\u003cli\u003erequests: 웹 서비스 또는 API에 HTTP 요청을 보내기 위한 라이브러리로, 데이터 검색이나 과학 자원과의 상호 작용에 활용될 수 있습니다.\u003c/li\u003e\n\u003cli\u003earxiv: arXiv.org의 과학 논문을 검색, 가져오기 및 관리를 간소화합니다.\u003c/li\u003e\n\u003cli\u003epandas: 대용량 데이터 처리 및 분석에 중요한 역할을 하며, 대규모 데이터 세트를 처리하는 데 사용되는 구조 및 기능을 제공합니다.\u003c/li\u003e\n\u003cli\u003ePyPDF2: PDF 파일로부터 텍스트를 추출할 수 있도록 하며, PDF 형식의 과학 논문을 처리하는 데 필수적입니다.\u003c/li\u003e\n\u003cli\u003etqdm: 루프나 장기 실행 프로세스에 대한 진행 표시 막대를 생성하여 사용자 경험을 향상시킵니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e2.2 환경 설정하기\u003c/h2\u003e\n\u003cp\u003e먼저 OpenAI 플랫폼에 계정을 만들고 계정 설정의 API 섹션에서 API 키를 얻어야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eopenai.\u003cspan class=\"hljs-property\"\u003eapi_key\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"API_KEY\"\u003c/span\u003e\n\n\u003cspan class=\"hljs-variable constant_\"\u003eGPT_MODEL\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"gpt-3.5-turbo-0613\"\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eEMBEDDING_MODEL\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"text-embedding-ada-002\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e2.3 프로젝트 설정\u003c/h2\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e다운로드한 논문이나 데이터를 관리하기 위한 구조화된 디렉토리를 만드는 것은 조직화와 쉬운 접근성을 위해 매우 중요합니다. 필요한 디렉토리를 설정하는 방법을 알려드리겠습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e디렉토리 구조 생성: 프로젝트의 필요에 맞는 구조를 결정하세요. 다운로드한 논문을 관리하기 위해 ./data/papers 디렉토리가 제안됩니다.\u003c/li\u003e\n\u003cli\u003e구현: Python의 os 라이브러리를 사용하여 이러한 디렉토리의 존재 여부를 확인하고 없는 경우 생성하세요:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e os\n\ndirectory = \u003cspan class=\"hljs-string\"\u003e'./data/papers'\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enot\u003c/span\u003e os.path.exists(directory):\n    os.makedirs(directory)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 코드 조각을 통해 스크립트가 수동 디렉토리 설정 없이 모든 시스템에서 실행될 수 있도록 보장하여 프로젝트의 이식성과 사용자 친화성을 높일 수 있습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e3. 핵심 기능\u003c/h1\u003e\n\u003cp\u003e과학 지식 검색을 용이하게 하는 것을 목적으로 설계된 연구 챗봇은 여러 가지 핵심 기능을 통합하고 있습니다.\u003c/p\u003e\n\u003cp\u003e자연어 쿼리 처리, 학술 콘텐츠 검색 및 요약, 그리고 고급 NLP 기법을 활용하여 사용자 상호작용을 향상하는 것이 중심입니다.\u003c/p\u003e\n\u003cp\u003e아래에서는 이러한 기능들을 자세히 설명하며, 그 구현을 보여주는 구체적인 코드 조각을 강조하겠습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e3.1 임베딩 생성\u003c/h2\u003e\n\u003cp\u003e사용자 쿼리를 효과적으로 이해하고 처리하기 위해 챗봇은 임베딩을 활용합니다. 임베딩은 텍스트의 의미를 포착하는 수치적인 표현으로, 이는 과학 논문과 쿼리 간의 관련성을 결정하는 작업에 중요합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@\u003cspan class=\"hljs-title function_\"\u003eretry\u003c/span\u003e(wait=\u003cspan class=\"hljs-title function_\"\u003ewait_random_exponential\u003c/span\u003e(min=\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, max=\u003cspan class=\"hljs-number\"\u003e40\u003c/span\u003e), stop=\u003cspan class=\"hljs-title function_\"\u003estop_after_attempt\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e))\ndef \u003cspan class=\"hljs-title function_\"\u003eembedding_request\u003c/span\u003e(text):\n    response = openai.\u003cspan class=\"hljs-property\"\u003eEmbedding\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreate\u003c/span\u003e(input=text, model=\u003cspan class=\"hljs-variable constant_\"\u003eEMBEDDING_MODEL\u003c/span\u003e)\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e response[\u003cspan class=\"hljs-string\"\u003e'data'\u003c/span\u003e][\u003cspan class=\"hljs-string\"\u003e'embeddings'\u003c/span\u003e]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 함수는 재시도 메커니즘으로 OpenAI API에서 임베딩을 요청하며, 잠재적인 API 오류나 요청 한도에 대응하여 견고성을 보장합니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e3.2 학술 논문 검색\u003c/h2\u003e\n\u003cp\u003e쿼리를 이해한 후, 챗봇은 arXiv와 같은 외부 데이터베이스와 직접 통신하는 능력을 보여주며 관련 학술 논문을 가져옵니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# arXiv에서 기사 가져오는 함수\ndef \u003cspan class=\"hljs-title function_\"\u003eget_articles\u003c/span\u003e(query, library=paper_dir_filepath, top_k=\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e):\n    \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\n    사용자 쿼리와 관련 있는 상위 'k'개의 학술 논문을 arXiv 데이터베이스에서 검색하고 가져옵니다.\n    이 함수는 arXiv API를 사용하여 논문을 검색하는데, 검색 기준은 사용자 쿼리이고 결과 수는 'top_k'로 제한됩니다.\n    찾은 각 논문에는 제목, 요약, URL과 같은 관련 정보를 리스트에 저장합니다.\n    또한 각 논문의 PDF를 다운로드하고, 제목, 다운로드 경로, 논문 제목의 임베딩을 포함한 참조를 'library'로 지정된 CSV 파일에 저장합니다.\n    나중에 검색 및 분석을 위해 논문과 임베딩을 기록하는 데 유용합니다.\n    이 함수는 read_article_and_summarize에서 사용됩니다.\n    \"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    search = arxiv.\u003cspan class=\"hljs-title class_\"\u003eSearch\u003c/span\u003e(\n        query=query, max_results=top_k, sort_by=arxiv.\u003cspan class=\"hljs-property\"\u003eSortCriterion\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eRelevance\u003c/span\u003e\n    )\n    result_list = []\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e result \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e search.\u003cspan class=\"hljs-title function_\"\u003eresults\u003c/span\u003e():\n        result_dict = {}\n        result_dict.\u003cspan class=\"hljs-title function_\"\u003eupdate\u003c/span\u003e({\u003cspan class=\"hljs-string\"\u003e\"title\"\u003c/span\u003e: result.\u003cspan class=\"hljs-property\"\u003etitle\u003c/span\u003e})\n        result_dict.\u003cspan class=\"hljs-title function_\"\u003eupdate\u003c/span\u003e({\u003cspan class=\"hljs-string\"\u003e\"summary\"\u003c/span\u003e: result.\u003cspan class=\"hljs-property\"\u003esummary\u003c/span\u003e})\n\n        # 첫 번째로 제공된 \u003cspan class=\"hljs-variable constant_\"\u003eURL\u003c/span\u003e 사용\n        result_dict.\u003cspan class=\"hljs-title function_\"\u003eupdate\u003c/span\u003e({\u003cspan class=\"hljs-string\"\u003e\"article_url\"\u003c/span\u003e: [x.\u003cspan class=\"hljs-property\"\u003ehref\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e x \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e result.\u003cspan class=\"hljs-property\"\u003elinks\u003c/span\u003e][\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]})\n        result_dict.\u003cspan class=\"hljs-title function_\"\u003eupdate\u003c/span\u003e({\u003cspan class=\"hljs-string\"\u003e\"pdf_url\"\u003c/span\u003e: [x.\u003cspan class=\"hljs-property\"\u003ehref\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e x \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e result.\u003cspan class=\"hljs-property\"\u003elinks\u003c/span\u003e][\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]})\n        result_list.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e(result_dict)\n\n        # 참조를 라이브러리 파일에 저장\n        response = \u003cspan class=\"hljs-title function_\"\u003eembedding_request\u003c/span\u003e(text=result.\u003cspan class=\"hljs-property\"\u003etitle\u003c/span\u003e)\n        file_reference = [\n            result.\u003cspan class=\"hljs-property\"\u003etitle\u003c/span\u003e,\n            result.\u003cspan class=\"hljs-title function_\"\u003edownload_pdf\u003c/span\u003e(data_dir),\n            response[\u003cspan class=\"hljs-string\"\u003e\"data\"\u003c/span\u003e][\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e][\u003cspan class=\"hljs-string\"\u003e\"embedding\"\u003c/span\u003e],\n        ]\n\n        # 파일에 기록\n        \u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eopen\u003c/span\u003e(library, \u003cspan class=\"hljs-string\"\u003e\"a\"\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ef_object\u003c/span\u003e:\n            writer_object = \u003cspan class=\"hljs-title function_\"\u003ewriter\u003c/span\u003e(f_object)\n            writer_object.\u003cspan class=\"hljs-title function_\"\u003ewriterow\u003c/span\u003e(file_reference)\n            f_object.\u003cspan class=\"hljs-title function_\"\u003eclose\u003c/span\u003e()\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e result_list\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e3.3 순위 매기기 및 요약하기\u003c/h2\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e해당 논문을 손에 쥐고 있으면 시스템은 쿼리와 관련성에 따라 그들을 순위를 매기고 내용을 요약하여 사용자에게 간결하고 통찰력 있는 정보를 제공합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-comment\"\u003e# 쿼리 문자열과 관련성을 기준으로 문자열을 순위 매기는 함수\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003estrings_ranked_by_relatedness\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\n    query: \u003cspan class=\"hljs-built_in\"\u003estr\u003c/span\u003e,\n    df: pd.DataFrame,\n    relatedness_fn=\u003cspan class=\"hljs-keyword\"\u003elambda\u003c/span\u003e x, y: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e - spatial.distance.cosine(\u003cspan class=\"hljs-params\"\u003ex, y\u003c/span\u003e),\n    top_n: \u003cspan class=\"hljs-built_in\"\u003eint\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e,\n\u003c/span\u003e) -\u003e \u003cspan class=\"hljs-built_in\"\u003elist\u003c/span\u003e[\u003cspan class=\"hljs-built_in\"\u003estr\u003c/span\u003e]:\n\n    \u003cspan class=\"hljs-string\"\u003e\"\"\"\n    함수는 주어진 쿼리 문자열과 관련성을 기준으로 DataFrame에서 문자열 목록을 순위 매기고 반환합니다.\n    함수는 먼저 쿼리 문자열에 대한 임베딩을 얻습니다. 그런 다음 DataFrame의 각 문자열과의 관련성을 계산합니다.\n    여기서 제공된 'relatedness_fn'을 사용하여 쿼리와의 관련성을 계산하며, 기본값은 임베딩 간의 코사인 유사도를 계산합니다.\n    이러한 문자열을 관련성에 따라 내림차순으로 정렬하여 상위 'n'개의 문자열을 반환합니다.\n    \"\"\"\u003c/span\u003e\n    query_embedding_response = embedding_request(query)\n    query_embedding = query_embedding_response[\u003cspan class=\"hljs-string\"\u003e\"data\"\u003c/span\u003e][\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e][\u003cspan class=\"hljs-string\"\u003e\"embedding\"\u003c/span\u003e]\n\n    strings_and_relatednesses = [\n        (row[\u003cspan class=\"hljs-string\"\u003e\"filepath\"\u003c/span\u003e], relatedness_fn(query_embedding, row[\u003cspan class=\"hljs-string\"\u003e\"embedding\"\u003c/span\u003e]))\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i, row \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e df.iterrows()\n    ]\n    \n    strings_and_relatednesses.sort(key=\u003cspan class=\"hljs-keyword\"\u003elambda\u003c/span\u003e x: x[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e], reverse=\u003cspan class=\"hljs-literal\"\u003eTrue\u003c/span\u003e)\n    strings, relatednesses = \u003cspan class=\"hljs-built_in\"\u003ezip\u003c/span\u003e(*strings_and_relatednesses)\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e strings[:top_n]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e3.4 학술 논문 요약\u003c/h2\u003e\n\u003cp\u003e관련 논문을 식별한 후, 챗봇은 과학 문서의 본질을 요약하는 과정을 사용합니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-comment\"\u003e# 청크를 요약하고 종합 요약을 반환하는 함수\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esummarize_text\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003equery\u003c/span\u003e):\n    \u003cspan class=\"hljs-string\"\u003e\"\"\"\n    사용자 쿼리와 관련된 학술 논문을 요약하는 프로세스를 자동화합니다. 다음을 포함합니다:\n    1. 데이터 읽기: 논문 및 임베딩 정보가 포함된 'arxiv_library.csv'를 읽습니다.\n    2. 관련 논문 식별: 쿼리의 임베딩을 CSV 파일의 임베딩과 비교하여 가장 유사한 항목을 찾습니다.\n    3. 텍스트 추출: 식별된 논문의 PDF를 읽어 내용을 문자열로 변환합니다.\n    4. 텍스트 청킹: 효율적인 처리를 위해 추출된 텍스트를 관리 가능한 청크로 나눕니다.\n    5. 청킹 요약: 각 텍스트 청크는 'extract_chunk' 함수를 사용하여 병렬로 요약됩니다.\n    6. 요약 병합: 개별 요약을 최종 종합 요약으로 결합합니다.\n    7. 요약 제공: 사용자 쿼리와 관련된 주요 통찰을 중점으로 한 논문의 간략한 개요를 제공합니다.\n    \"\"\"\u003c/span\u003e\n\n    \u003cspan class=\"hljs-comment\"\u003e# 입력된 논문을 재귀적으로 요약하는 방법을 지시하는 메시지\u003c/span\u003e\n    summary_prompt = \u003cspan class=\"hljs-string\"\u003e\"\"\"학술 논문의 텍스트를 요약하세요. 이유와 함께 중요한 요점을 추출하세요.\\n\\n내용:\"\"\"\u003c/span\u003e\n\n    \u003cspan class=\"hljs-comment\"\u003e# 라이브러리가 비어 있는 경우(아직 검색된 항목이 없는 경우) 한 번 수행하고 결과를 다운로드합니다.\u003c/span\u003e\n    library_df = pd.read_csv(paper_dir_filepath).reset_index()\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(library_df) == \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e:\n        \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"아직 검색된 논문이 없습니다. 처음으로 다운로드합니다.\"\u003c/span\u003e)\n        get_articles(query)\n        \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"논문 다운로드 완료, 계속 진행합니다.\"\u003c/span\u003e)\n        library_df = pd.read_csv(paper_dir_filepath).reset_index()\n    library_df.columns = [\u003cspan class=\"hljs-string\"\u003e\"title\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"filepath\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"embedding\"\u003c/span\u003e]\n    library_df[\u003cspan class=\"hljs-string\"\u003e\"embedding\"\u003c/span\u003e] = library_df[\u003cspan class=\"hljs-string\"\u003e\"embedding\"\u003c/span\u003e].apply(ast.literal_eval)\n    strings = strings_ranked_by_relatedness(query, library_df, top_n=\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\n    \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"논문에서 텍스트 청킹\"\u003c/span\u003e)\n    pdf_text = read_pdf(strings[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e])\n\n    \u003cspan class=\"hljs-comment\"\u003e# 토크나이저 초기화\u003c/span\u003e\n    tokenizer = tiktoken.get_encoding(\u003cspan class=\"hljs-string\"\u003e\"cl100k_base\"\u003c/span\u003e)\n    results = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n\n    \u003cspan class=\"hljs-comment\"\u003e# 문서를 1500 토큰 청크로 분할\u003c/span\u003e\n    chunks = create_chunks(pdf_text, \u003cspan class=\"hljs-number\"\u003e1500\u003c/span\u003e, tokenizer)\n    text_chunks = [tokenizer.decode(chunk) \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e chunk \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e chunks]\n    \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"각 텍스트 청크를 요약합니다.\"\u003c/span\u003e)\n\n    \u003cspan class=\"hljs-comment\"\u003e# 요약을 병렬 처리합니다.\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e concurrent.futures.ThreadPoolExecutor(\n        max_workers=\u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(text_chunks)\n    ) \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e executor:\n        futures = [\n            executor.submit(extract_chunk, chunk, summary_prompt)\n            \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e chunk \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e text_chunks\n        ]\n        \u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e tqdm(total=\u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(text_chunks)) \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e pbar:\n            \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e _ \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e concurrent.futures.as_completed(futures):\n                pbar.update(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e future \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e futures:\n            data = future.result()\n            results += data\n\n    \u003cspan class=\"hljs-comment\"\u003e# 최종 요약\u003c/span\u003e\n    \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"전체 요약으로 요약합니다.\"\u003c/span\u003e)\n    response = openai.ChatCompletion.create(\n        model=GPT_MODEL,\n        messages=[\n            {\n                \u003cspan class=\"hljs-string\"\u003e\"role\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"user\"\u003c/span\u003e,\n                \u003cspan class=\"hljs-string\"\u003e\"content\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003ef\"\"\"학술 논문에서 추출한 주요 요점을 바탕으로 종합된 요약을 작성합니다.\n                        요약은 핵심 주장, 결론 및 증거를 강조하고 사용자 쿼리에 답변해야 합니다.\n                        사용자 쿼리: \u003cspan class=\"hljs-subst\"\u003e{query}\u003c/span\u003e\n                        요약은 Core Argument, Evidence, 그리고 Conclusions의 제목을 따라 목록으로 구성되어야 합니다.\n                        주요 요점:\\n\u003cspan class=\"hljs-subst\"\u003e{results}\u003c/span\u003e\\nSummary:\\n\"\"\"\u003c/span\u003e,\n            }\n        ],\n        temperature=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\n    )\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e response\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e3.5 OpenAI 함수의 통합과 사용\u003c/h2\u003e\n\u003cp\u003e연구용 챗봇은 OpenAI 함수를 활용하여 복잡한 쿼리를 처리하고 응답하기 위한 능력을 향상시킵니다.\u003c/p\u003e\n\u003cp\u003e이러한 함수들은 챗봇과 다양한 외부 데이터 소스 및 도구 간의 원활한 상호작용을 허용하여 사용자에게 자세하고 정확하며 맥락에 맞는 정보를 제공하여 사용자 경험을 크게 향상시킵니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eOpenAI 함수들은 외부 계산 또는 데이터 검색을 모델의 처리 과정에 직접 통합하여 OpenAI 모델의 기능을 확장하는 데 사용됩니다.\u003c/p\u003e\n\u003ch3\u003e3.5.1 사용자 정의 OpenAI 함수\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eget_articles 함수\u003c/strong\u003e: 사용자의 쿼리와 관련된 학술 논문을 arXiv 데이터베이스에서 검색하여, 챗봇이 외부 소스에서 실시간 데이터에 접근하는 능력을 보여줍니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eread_article_and_summarize 함수\u003c/strong\u003e: 사용자의 쿼리와 관련된 학술 논문을 arXiv 데이터베이스에서 검색하여, 챗봇이 외부 소스에서 실시간 데이터에 접근하는 능력을 보여줍니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e구현:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-title class_\"\u003eFunction\u003c/span\u003e to initiate our get_articles and read_article_and_summarize functions\narxiv_functions = [\n    {\n        \u003cspan class=\"hljs-string\"\u003e\"name\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"get_articles\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"description\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"Use this function to get academic papers from arXiv to answer user questions.\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"parameters\"\u003c/span\u003e: {\n            \u003cspan class=\"hljs-string\"\u003e\"type\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"object\"\u003c/span\u003e,\n            \u003cspan class=\"hljs-string\"\u003e\"properties\"\u003c/span\u003e: {\n                \u003cspan class=\"hljs-string\"\u003e\"query\"\u003c/span\u003e: {\n                    \u003cspan class=\"hljs-string\"\u003e\"type\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"string\"\u003c/span\u003e,\n                    \u003cspan class=\"hljs-string\"\u003e\"description\"\u003c/span\u003e: f\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\n                            User query in JSON. Responses should be summarized and should include the article URL reference\n                            \"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e,\n                }\n            },\n            \u003cspan class=\"hljs-string\"\u003e\"required\"\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e\"query\"\u003c/span\u003e],\n        },\n    },\n    {\n        \u003cspan class=\"hljs-string\"\u003e\"name\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"read_article_and_summarize\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"description\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"Use this function to read whole papers and provide a summary for users.\n        You should NEVER call this function before get_articles has been called in the conversation.\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"parameters\"\u003c/span\u003e: {\n            \u003cspan class=\"hljs-string\"\u003e\"type\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"object\"\u003c/span\u003e,\n            \u003cspan class=\"hljs-string\"\u003e\"properties\"\u003c/span\u003e: {\n                \u003cspan class=\"hljs-string\"\u003e\"query\"\u003c/span\u003e: {\n                    \u003cspan class=\"hljs-string\"\u003e\"type\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"string\"\u003c/span\u003e,\n                    \u003cspan class=\"hljs-string\"\u003e\"description\"\u003c/span\u003e: f\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\n                            Description of the article in plain text based on the user's query\n                            \"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e,\n                }\n            },\n            \u003cspan class=\"hljs-string\"\u003e\"required\"\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e\"query\"\u003c/span\u003e],\n        },\n    }\n]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이러한 기능을 챗봇의 작업 흐름에 통합하면 OpenAI의 API의 고급 사용 사례를 보여줍니다. 여기서는 대화 컨텍스트에 따라 특정 작업(예: 학술 조사)에 맞게 맞춤형 함수가 실행됩니다.\u003c/p\u003e\n\u003ch2\u003e3.6 완전한 코드\u003c/h2\u003e\n\u003cp\u003e필요한 함수 및 대화형 챗봇 상호작용이 포함된 전체 코드를 참조하세요.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 프로젝트 유형뿐만 아니라 AI, 데이터 과학 및 기술 분야의 다양한 혁신적인 데이터 기반 이니셔티브에 대해 \u003ca href=\"http://www.entreprenerdly.com%EC%9D%98\" rel=\"nofollow\" target=\"_blank\"\u003ewww.entreprenerdly.com의\u003c/a\u003e 다양한 자원을 살펴보기를 권장합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-12-AutomatingScientificKnowledgeRetrievalwithAIinPython_1.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ch2\u003e4. 연구 챗봇과 상호작용하기\u003c/h2\u003e\n\u003cp\u003e이 섹션에서는 사용자-시스템 상호작용 흐름을 설명하는 예제들과 함께 연구 챗봇의 구현과 기능에 대해 깊이 파고들어 논의합니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e4.1 구현 개요\u003c/h2\u003e\n\u003cp\u003e챗봇은 OpenAI API를 기반으로 구축되었으며, GPT-3 또는 GPT-4와 같은 모델을 활용하여 복잡한 쿼리를 이해하고 사람과 유사한 답변을 생성할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e구현은 사용자가 쿼리를 입력할 수 있는 인터페이스(명령줄 인터페이스 또는 웹 기반 UI)를 설정하는 것을 포함합니다. 그런 다음 시스템은 이러한 쿼리를 처리하고 OpenAI API와 상호 작용하여 사용자에게 다시 응답을 제시합니다.\u003c/p\u003e\n\u003ch2\u003e4.2 기능\u003c/h2\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e연구 챗봇의 핵심 기능은 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e질의 이해: 챗봇은 먼저 사용자의 질문을 해석하여 OpenAI 모델의 이해 능력을 활용하여 질문 뒤에 숨은 맥락과 의도를 파악합니다.\u003c/li\u003e\n\u003cli\u003e정보 검색: 챗봇은 질의에 따라 교육된 지식베이스를 활용하여 직접 답변을 생성하거나 관련 과학 논문과 문서를 가져와 응답을 작성할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e응답 생성: 챗봇은 검색하거나 생성한 정보를 일관되고 간결한 답변으로 종합하여 사용자에게 제시합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e4.3 사용자-시스템 상호작용 흐름\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e사용자 질의 예시: 사용자가 “양자 컴퓨팅의 최신 발전은 무엇인가요?”라고 묻습니다. 질의 처리:\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eresponse = openai.\u003cspan class=\"hljs-property\"\u003eCompletion\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreate\u003c/span\u003e(\n  engine=\u003cspan class=\"hljs-string\"\u003e\"davinci\"\u003c/span\u003e,\n  prompt=\u003cspan class=\"hljs-string\"\u003e\"양자 컴퓨팅의 최신 발전 사항은 무엇입니까?\"\u003c/span\u003e,\n  max_tokens=\u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e답변 생성: 시스템은 답변을 구성하여 양자 컴퓨팅의 최근의 폭발적인 발전을 요약할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e답변 제시: 챗봇은 사용자의 이해를 돕기 위해 합성된 정보를 출력합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e4.3.1 관련 논문 검색\u003c/h2\u003e\n\u003cp\u003e이 단계는 사용자가 챗봇에게 특정 주제에 대한 논문을 식별하고 검색하는 것을 포함합니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 시스템 메시지로 시작합니다\npaper_system_message = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"안녕하세요, 저는 arXivGPT입니다. 사용자의 질문에 답변하기 위해 학술 논문을 가져오는 유용한 도우미입니다.\n논문을 명확하게 요약하여 고객이 질문에 대한 답변을 얻기 위해 어떤 논문을 읽어야 하는지 결정할 수 있도록 도와드립니다.\n사용자가 논문의 이름을 이해하고 액세스하려면 항상 article_url과 title을 제공합니다.\n시작하세요!\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\npaper_conversation = \u003cspan class=\"hljs-title class_\"\u003eConversation\u003c/span\u003e()\npaper_conversation.\u003cspan class=\"hljs-title function_\"\u003eadd_message\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"system\"\u003c/span\u003e, paper_system_message)\n\n\n# 사용자 메시지 추가\npaper_conversation.\u003cspan class=\"hljs-title function_\"\u003eadd_message\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"user\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"시장 효율성에 대한 최신 정보는 무엇인가요?\"\u003c/span\u003e) # \u003cspan class=\"hljs-variable constant_\"\u003ePPO\u003c/span\u003e 강화 학습은 어떻게 작동하나요?\nchat_response = \u003cspan class=\"hljs-title function_\"\u003echat_completion_with_function_execution\u003c/span\u003e(\n    paper_conversation.\u003cspan class=\"hljs-property\"\u003econversation_history\u003c/span\u003e, functions=arxiv_functions\n)\n\nassistant_message = chat_response[\u003cspan class=\"hljs-string\"\u003e\"choices\"\u003c/span\u003e][\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e][\u003cspan class=\"hljs-string\"\u003e\"message\"\u003c/span\u003e][\u003cspan class=\"hljs-string\"\u003e\"content\"\u003c/span\u003e]\npaper_conversation.\u003cspan class=\"hljs-title function_\"\u003eadd_message\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"assistant\"\u003c/span\u003e, assistant_message)\n\u003cspan class=\"hljs-title function_\"\u003edisplay\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eMarkdown\u003c/span\u003e(assistant_message))\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e4.3.2 논문 요약하기\u003c/h2\u003e\n\u003cp\u003e적절한 논문을 가져온 후, 챗봇은 사용자의 요청을 더 처리하여 특정 논문의 내용을 요약하여 제공함으로써 간결하고 통찰에 풍부한 요약을 제공하며 상호작용을 개선합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 두 번째 도구를 사용하도록 시스템을 유도하기 위해 다른 사용자 메시지 추가\npaper_conversation.\u003cspan class=\"hljs-title function_\"\u003eadd_message\u003c/span\u003e(\n    \u003cspan class=\"hljs-string\"\u003e\"user\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"시장 효율적 교차 시장 추천을 위한 시장-인식 모델 논문을 읽고 요약을 제공해줄 수 있나요?\"\u003c/span\u003e,\n)\nupdated_response = \u003cspan class=\"hljs-title function_\"\u003echat_completion_with_function_execution\u003c/span\u003e(\n    paper_conversation.\u003cspan class=\"hljs-property\"\u003econversation_history\u003c/span\u003e, functions=arxiv_functions\n)\n\u003cspan class=\"hljs-title function_\"\u003edisplay\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eMarkdown\u003c/span\u003e(updated_response[\u003cspan class=\"hljs-string\"\u003e\"choices\"\u003c/span\u003e][\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e][\u003cspan class=\"hljs-string\"\u003e\"message\"\u003c/span\u003e][\u003cspan class=\"hljs-string\"\u003e\"content\"\u003c/span\u003e]))\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e5. 도전과 솔루션\u003c/h1\u003e\n\u003ch2\u003e5.1 다양한 데이터 소스 통합\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e도전: 과학적 지식은 학술 저널부터 프리프린트 서버 및 기관 저장소까지 다양한 플랫폼과 형식으로 분산되어 있습니다.\u003c/li\u003e\n\u003cli\u003e솔루션: 여러 소스에서 데이터를 가져와 정규화하기 위해 다양한 API 및 웹 스크래핑 기술과 연결할 수 있는 모듈식 데이터 수집 프레임워크를 개발해야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e5.2 사용자-시스템 상호 작용 흐름\u003c/h2\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e도전: 특히 다단계 정보 검색 및 처리가 필요한 복잡한 쿼리에 대해 대화 플로우를 자연스럽고 매력적으로 유지하는 것이 도전입니다.\u003c/li\u003e\n\u003cli\u003e해결책: 사용자 경험을 향상시키기 위해, 챗봇이 사용자와 상호 작용하는 동안 정보 검색을 백그라운드에서 처리하면서 상호 작용적인 세션을 유지할 수 있는 멀티 스레드 요청 처리 시스템을 구현할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e5.3 연속적인 학습과 개선 보장\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e도전: 챗봇이 사용자 상호작용에서 지속적으로 학습하고 개선하여 시간이 지남에 따라 정확도와 효과성을 향상시키는 것입니다.\u003c/li\u003e\n\u003cli\u003e해결책: 사용자가 챗봇의 응답의 relevance 및 정확도를 평가할 수 있는 피드백 루프 메커니즘을 구현합니다. 이 피드백은 모델을 세밀하게 조정하고 응답 품질을 향상시키는 데 사용됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e5.4 실시간 데이터 동기화\u003c/h2\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e도전 과제: 챗봇의 데이터베이스를 실시간으로 최신 과학 논문과 동기화하는 것. 새로운 연구가 계속 발표되고 있기 때문에, 챗봇이 가장 최신 정보를 제공하는 것은 상당한 도전입니다.\u003c/li\u003e\n\u003cli\u003e해결책: 대형 과학 논문 데이터베이스의 웹훅과 RSS 피드를 사용하여 실시간 데이터 동기화 매커니즘을 구현할 수 있습니다. 이를 통해 새로운 논문이 제공되는 즉시 시스템이 자동으로 레포지토리를 업데이트할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e6. 실용적 응용\u003c/h2\u003e\n\u003ch3\u003e6.1 학술 연구\u003c/h3\u003e\n\u003cp\u003e다양한 학문 분야의 연구자들은 이 시스템을 활용하여 문헌 검토 과정을 간소화하고 효율적으로 관련 연구를 찾을 수 있습니다. 연구 주제와 관련된 구체적인 쿼리를 입력함으로써, 시스템은 과학 논문을 신속히 검색하여 주요 결과, 방법론 및 결과를 식별하고 요약할 수 있습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e6.2 산업 연구 및 개발\u003c/h2\u003e\n\u003cp\u003e제약, 공학 및 기술 연구개발 부서의 빠른 환경에서는 최신 과학적 발견에 대한 최신 정보를 충분히 파악하는 것이 혁신과 경쟁 우위를 유지하는 데 중요합니다. 시스템은 이러한 산업에 최신 연구, 실험 결과 및 기술 발전을 신속하게 접근할 수 있는 강력한 도구를 제공합니다.\u003c/p\u003e\n\u003ch2\u003e6.3 교육\u003c/h2\u003e\n\u003cp\u003e교육자와 학생 모두 시스템을 활용하여 학습 경험을 풍부하게 하고 학업 연구를 지원할 수 있습니다. 교사들은 강의를 준비하기 위한 최신 정보를 찾아 수업 내용을 현재와 관련성 있게 전달할 수 있습니다. 마찬가지로 학생들은 에세이, 프로젝트 또는 논문을 위한 소스, 참고 자료 및 사례 연구를 찾기 위해 시스템을 활용할 수 있습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e6.4 데이터 과학 및 AI\u003c/h2\u003e\n\u003cp\u003e데이터 과학가와 AI 연구원들에게는 시스템이 데이터 세트를 확보하고 복잡한 알고리즘을 이해하며 기존 연구에 대한 벤치마킹을 제공하는 중요한 자원으로 작용합니다. 사용자들은 시스템에서 특정 프로젝트에 가장 최근이고 관련성 있는 데이터 세트를 쿼리할 수 있으며, 데이터 세트의 크기, 다양성 및 응용에 대한 자세한 정보를 얻을 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e결론과 향후 작업\u003c/h1\u003e\n\u003cp\u003e이 연구 및 과학적 지식 검색 시스템의 개발과 구현은 인공지능의 변혁적 잠재력을 강조하며, 과학적 조사의 접근성과 효율성을 향상시키는 데 중요한 역할을 합니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e미래 작업은 AI 및 기계 학습의 최신 발전을 활용하여 식별된 과제에 대응하며, 시스템이 최첨단 기술 선두에 머무르고 다양한 사용자들의 요구를 계속 충족할 수 있도록 보장하는 데 초점을 맞추게 될 것입니다.\u003c/p\u003e\n\u003cp\u003e읽어 주셔서 감사합니다. 만약 이 글이 유익했다면 앞으로의 콘텐츠 지원을 위해 박수를 부탁드립니다. 👏\u003c/p\u003e\n\u003cp\u003eEntreprenerdly.com에는 행동 가능한 지식을 제공하기 위해 설계된 전체 자습서, 코드 및 전략이 제공됩니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-12-AutomatingScientificKnowledgeRetrievalwithAIinPython_2.png\" alt=\"2024-07-12-AutomatingScientificKnowledgeRetrievalwithAIinPython_2.png\"\u003e\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-07-12-AutomatingScientificKnowledgeRetrievalwithAIinPython"},"buildId":"QAkYP0lvl03W-5CKD69kb","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>