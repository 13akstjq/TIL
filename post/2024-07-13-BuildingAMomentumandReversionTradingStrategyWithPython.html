<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>파이썬으로 모멘텀 및 되돌림 트레이딩 전략 구축 방법 | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2024-07-13-BuildingAMomentumandReversionTradingStrategyWithPython" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="파이썬으로 모멘텀 및 되돌림 트레이딩 전략 구축 방법 | TIL" data-gatsby-head="true"/><meta property="og:title" content="파이썬으로 모멘텀 및 되돌림 트레이딩 전략 구축 방법 | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/TIL/assets/img/2024-07-13-BuildingAMomentumandReversionTradingStrategyWithPython_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2024-07-13-BuildingAMomentumandReversionTradingStrategyWithPython" data-gatsby-head="true"/><meta name="twitter:title" content="파이썬으로 모멘텀 및 되돌림 트레이딩 전략 구축 방법 | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/assets/img/2024-07-13-BuildingAMomentumandReversionTradingStrategyWithPython_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2024-07-13 19:01" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/0eef537492fed77a.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/0eef537492fed77a.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/post/%5Bslug%5D-8ded8b979ba73586.js" defer=""></script><script src="/TIL/_next/static/olPs1cVezSGTqD7OaewDI/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/olPs1cVezSGTqD7OaewDI/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">파이썬으로 모멘텀 및 되돌림 트레이딩 전략 구축 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="파이썬으로 모멘텀 및 되돌림 트레이딩 전략 구축 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jul 13, 2024</span><span class="posts_reading_time__f7YPP">17<!-- --> min read</span></span></div></div></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>양적 거래에서는 금융 시장에서 우위를 차지하기 위해 다양한 전략이 사용됩니다. 모멘텀 및 추세 기반 전략은 인기가 많지만, 종종 중요한 알파를 창출하는 데 어려움을 겪습니다. 이들은 종종 유튜브에서 금융 강좌로 판매될 때만 알파를 창출하게 됩니다.</p>
<p>모멘텀 및 추세 접근법은 최근 가격 상승을 보이는 자산이 가까운 미래에 상승세를 이어갈 것이라는 아이디어를 활용하거나, 손실을 보이는 자산이 계속해서 하락할 것이라는 아이디어를 기반으로 합니다. 추세와 모멘텀을 구분하는 것이 중요합니다.</p>
<ul>
<li>추세 추종은 시장 베타를 분석하여 특정 방향의 절대 수익을 목표로 합니다.</li>
<li>반면에, 모멘텀 전략은 상대 수익에 초점을 맞추며, 분류나 섹터 내에서 교차부문 성능을 평가하여 시장 중립적 입장을 유지합니다.</li>
</ul>
<p>회귀 전략은 가격이 특정 기간 동안 평균 또는 다중 평균 값으로 되돌아갈 것이라는 믿음에 기반합니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 기사에서는 이러한 전략을 검토하고 해당 분석을 위한 Python 코드 구현을 제공할 것입니다. 우리는 페어 트레이딩을 포함한 더 세련된 전략과 분석을 진행할 것입니다.</p>
<p>우리의 분석은 최근의 시장 상황, 특히 팬데믹 이후의 주식 가격을 기준으로 살펴볼 것입니다. 모든 논의된 전략은 롱 온리이며 레버리지가 걸리지 않은 전략입니다.</p>
<p>시작하기 전에, 투자 커뮤니티에 가입하실 것을 초대합니다. 가입하시면 중요한 기사를 놓치지 않고 투자자로서 스킬을 향상시킬 수 있습니다.</p>
<p>Python 환경을 설정하는 것은 효율적으로 Python 코드를 작성, 실행 및 관리하기 위해 필요한 도구와 라이브러리를 갖추는 것을 포함합니다. Python 환경을 설정하는 자세한 안내서는 여기 있습니다:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>1. 파이썬 설치하기:</h1>
<p>만약 여러분의 컴퓨터에 아직 파이썬이 설치되어 있지 않다면, 공식 파이썬 웹사이트(<a href="https://www.python.org/" rel="nofollow" target="_blank">https://www.python.org/</a>)에서 다운로드하고 설치해주세요. 여러분의 운영 체제(Windows, macOS, 또는 Linux)에 맞는 올바른 버전을 선택해야 합니다. 가장 최신의 안정 버전을 설치하는 것이 좋습니다.</p>
<h1>2. 텍스트 편집기 또는 IDE 선택하기:</h1>
<p>파이썬으로 코딩할 때 텍스트 편집기나 통합 개발 환경(IDE)을 선택해주세요. 널리 사용되는 몇 가지 옵션으로는:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>Visual Studio Code: 내장된 Python 지원과 다양한 확장 기능을 갖춘 가벼운 사용자 정의 가능한 편집기입니다.</li>
<li>PyCharm: 코드 완성, 디버깅 및 버전 관리 시스템과 통합된 Python 개발을 위해 최적화된 견고한 IDE입니다.</li>
<li>Jupyter Notebook: 데이터 분석 및 시각화 작업에 이상적인 웹 브라우저에서 Python 코드를 작성하고 실행할 수 있는 인터랙티브 노트북 인터페이스입니다.</li>
</ul>
<h2>3. 가상 환경 설정하기 (선택 사항이지만 권장됨):</h2>
<p>가상 환경은 종속성을 관리하고 프로젝트 환경을 격리하는 데 유용합니다. 가상 환경을 만들려면 터미널이나 명령 프롬프트를 열고 프로젝트 디렉토리로 이동한 다음 다음 명령을 실행하십시오:</p>
<pre><code class="hljs language-js">python -m venv myenv
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>해당 명령어는 프로젝트 디렉토리에 <code>env</code>라는 가상 환경을 만듭니다. 가상 환경을 활성화하려면 다음 명령어를 사용하십시오 (사용하는 운영 체제에 따라 명령어가 다를 수 있습니다):</p>
<h2>Windows:</h2>
<pre><code class="hljs language-js">.\env\<span class="hljs-title class_">Scripts</span>\activate
</code></pre>
<h2>macOS/Linux:</h2>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">source env/bin/activate
</code></pre>
<p>활성화된 후에 <code>pip</code>를 사용하여 프로젝트별 종속성을 설치할 수 있습니다. 이 가상 환경 안에 이들이 포함되어 다른 프로젝트와의 충돌을 방지합니다.</p>
<h1>4. 필요한 패키지 설치:</h1>
<pre><code class="hljs language-js">python -m venv myenv
pip install numpy pandas matplotlib
pip install -r requirements.<span class="hljs-property">txt</span>
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>트렌드와 모멘텀 전략</h1>
<p>예를 들어 설명하자면, 만약 자산의 가격이 지난 일주일 동안 상승 추세를 보였다면, 그 자산은 같은 방향으로 계속 움직일 가능성이 높습니다. 이 전략은 미래 가격 변동이 과거 움직임의 패턴을 따르리라는 아이디어에 기반을 두고 있습니다. 월스트리트벳 커뮤니티가 자주 외친 것처럼, 주식은 주로 상승하는 경향이 있습니다.</p>
<p>비록 이 전략이 간단하긴 하지만, 다음과 같은 단점이 있습니다:</p>
<ul>
<li>시장 소음과 중요한 이벤트를 무시하여 중요한 변동을 완화할 수 있습니다.</li>
<li>빈번한 거래는 거래 수수료 누적으로 이어질 수 있습니다.</li>
<li>폭넓게 사용되기 때문에 이 전략을 활용하는 데 경쟁 우위가 제한적이거나 전혀 없을 수 있습니다.</li>
</ul>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>이동평균 교차 전략</h1>
<p>다음 코드는 이 전략을 구현합니다:</p>
<pre><code class="hljs language-js">def <span class="hljs-title function_">double_simple_moving_average_signals</span>(ticker_ts_df, short_window=<span class="hljs-number">5</span>, long_window=<span class="hljs-number">30</span>):
    <span class="hljs-string">""</span><span class="hljs-string">"
    이중 단순 이동평균 (SMA) 전략을 기반으로 거래 신호를 생성합니다.
    매개변수:
    - ticker_ts_df (pandas.DataFrame): 주식의 과거 데이터가 포함 된 DataFrame.
    - short_window (int): 단기 SMA의 창 크기.
    - long_window (int): 장기 SMA의 창 크기.
    반환값:
    - signals (pandas.DataFrame): 거래 신호를 포함하는 DataFrame.
    "</span><span class="hljs-string">""</span>
    signals = pd.<span class="hljs-title class_">DataFrame</span>(index=ticker_ts_df.<span class="hljs-property">index</span>)
    signals[<span class="hljs-string">'signal'</span>] = <span class="hljs-number">0.0</span>
    signals[<span class="hljs-string">'short_mavg'</span>] = ticker_ts_df[<span class="hljs-string">'Close'</span>].<span class="hljs-title function_">rolling</span>(<span class="hljs-variable language_">window</span>=short_window,
                                                          min_periods=<span class="hljs-number">1</span>,
                                                          center=<span class="hljs-title class_">False</span>).<span class="hljs-title function_">mean</span>()
    signals[<span class="hljs-string">'long_mavg'</span>] = ticker_ts_df[<span class="hljs-string">'Close'</span>].<span class="hljs-title function_">rolling</span>(<span class="hljs-variable language_">window</span>=long_window,
                                                         min_periods=<span class="hljs-number">1</span>,
                                                         center=<span class="hljs-title class_">False</span>).<span class="hljs-title function_">mean</span>()
    # <span class="hljs-title class_">SMAs</span>가 교차 되었을 때 신호 생성
    signals[<span class="hljs-string">'signal'</span>] = np.<span class="hljs-title function_">where</span>(
        signals[<span class="hljs-string">'short_mavg'</span>] > signals[<span class="hljs-string">'long_mavg'</span>], <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)
    signals[<span class="hljs-string">'orders'</span>] = signals[<span class="hljs-string">'signal'</span>].<span class="hljs-title function_">diff</span>()
    signals.<span class="hljs-property">loc</span>[signals[<span class="hljs-string">'orders'</span>] == <span class="hljs-number">0</span>, <span class="hljs-string">'orders'</span>] = <span class="hljs-title class_">None</span>
    <span class="hljs-keyword">return</span> signals
</code></pre>
<p>필요한 함수를 생성하기 위한 단계를 살펴보겠습니다:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>단기 및 장기 이동평균 값 계산: 단기(빠른) 및 장기(느린) 단순 이동평균(SMA)을 계산하는 함수를 생성하세요.</li>
<li>거래 신호 생성: 단기와 장기 이동평균 값을 비교하여 매수 및 매도 신호를 생성하는 함수를 개발하세요.</li>
<li>시간에 따른 자본 계산: 생성된 신호를 기반으로 자본을 계산하는 유틸리티 함수를 구현하세요.</li>
<li>결과 시각화: 주식의 시계열 데이터와 진입 및 퇴출 신호를 함께 그리는 함수를 작성하세요.</li>
</ul>
<pre><code class="hljs language-js">def <span class="hljs-title function_">load_ticker_time_series</span>(ticker, start_date, end_date):
    <span class="hljs-string">""</span><span class="hljs-string">"
    Yahoo Finance API에서 시간 시리즈 금융 데이터를 검색하고 캐시합니다.
    매개변수:
    - ticker (str): 주식 티커 심볼 (예: 애플의 경우 'AAPL').
    - start_date (str): 데이터 검색을 위한 'YYYY-MM-DD' 형식의 시작 날짜.
    - end_date (str): 데이터 검색을 위한 'YYYY-MM-DD' 형식의 종료 날짜.
    반환값:
    - df (pandas.DataFrame): 금융 시계열 데이터를 포함하는 DataFrame."</span><span class="hljs-string">""</span>
    dir_path = <span class="hljs-string">'./data'</span>
    cached_file_path = f<span class="hljs-string">'{dir_path}/{ticker}_{start_date}_{end_date}.pkl'</span>
    <span class="hljs-attr">try</span>:
        <span class="hljs-keyword">if</span> os.<span class="hljs-property">path</span>.<span class="hljs-title function_">exists</span>(cached_file_path):
            df = pd.<span class="hljs-title function_">read_pickle</span>(cached_file_path)
        <span class="hljs-attr">else</span>:
            df = yf.<span class="hljs-title function_">download</span>(ticker, start=start_date, end=end_date)
            <span class="hljs-keyword">if</span> not os.<span class="hljs-property">path</span>.<span class="hljs-title function_">exists</span>(dir_path):
                os.<span class="hljs-title function_">makedirs</span>(dir_path)
            df.<span class="hljs-title function_">to_pickle</span>(cached_file_path)
    except <span class="hljs-title class_">FileNotFoundError</span>:
        <span class="hljs-title function_">print</span>(
            f<span class="hljs-string">'주식: {ticker}에 대한 파일을 다운로드 및 캐시하는 중 오류가 발생했습니다.'</span>)
    <span class="hljs-keyword">return</span> df

def <span class="hljs-title function_">calculate_profit</span>(signals, prices):
    <span class="hljs-string">""</span><span class="hljs-string">"
    거래 신호와 주식 가격을 기반으로 누적 수익을 계산합니다.
    매개변수:
    - signals (pandas.DataFrame): 거래 신호를 포함하는 DataFrame (매수: 1, 매도: -1).
    - prices (pandas.Series): 신호 날짜에 해당하는 주식 가격을 포함하는 Series.
    반환값:
    - cum_profit (pandas.Series): 시간에 따른 누적 수익을 포함하는 Series.
    "</span><span class="hljs-string">""</span>
    profit = pd.<span class="hljs-title class_">DataFrame</span>(index=prices.<span class="hljs-property">index</span>)
    profit[<span class="hljs-string">'profit'</span>] = <span class="hljs-number">0.0</span>
    buys = signals[signals[<span class="hljs-string">'orders'</span>] == <span class="hljs-number">1</span>].<span class="hljs-property">index</span>
    sells = signals[signals[<span class="hljs-string">'orders'</span>] == -<span class="hljs-number">1</span>].<span class="hljs-property">index</span>
    <span class="hljs-keyword">while</span> sells[<span class="hljs-number">0</span>] &#x3C; buys[<span class="hljs-number">0</span>]:
        # 롱 포지션 전용 전략입니다. 판매로 시작할 수 없습니다.
        sells = sells[<span class="hljs-number">1</span>:]
    <span class="hljs-keyword">if</span> <span class="hljs-title function_">len</span>(buys) == <span class="hljs-number">0</span> or <span class="hljs-title function_">len</span>(sells) == <span class="hljs-number">0</span>:
        # 아무 조치도 취하지 않았습니다.
        <span class="hljs-keyword">return</span> profit
    <span class="hljs-keyword">if</span> <span class="hljs-title function_">len</span>(sells) &#x3C; <span class="hljs-title function_">len</span>(buys):
        # 마지막에 판매하는 것으로 가정합니다.
        sells = sells.<span class="hljs-title function_">append</span>(pd.<span class="hljs-title class_">Index</span>(prices.<span class="hljs-title function_">tail</span>(<span class="hljs-number">1</span>).<span class="hljs-property">index</span>))
    buy_prices = prices.<span class="hljs-property">loc</span>[buys]
    sell_prices = prices.<span class="hljs-property">loc</span>[sells]
    profit.<span class="hljs-property">loc</span>[sells, <span class="hljs-string">'profit'</span>] = sell_prices.<span class="hljs-property">values</span> - buy_prices.<span class="hljs-property">values</span>
    profit[<span class="hljs-string">'profit'</span>] = profit[<span class="hljs-string">'profit'</span>].<span class="hljs-title function_">fillna</span>(<span class="hljs-number">0</span>)
    # 누적 수익 생성
    profit[<span class="hljs-string">'cum_profit'</span>] = profit[<span class="hljs-string">'profit'</span>].<span class="hljs-title function_">cumsum</span>()
    <span class="hljs-keyword">return</span> profit[<span class="hljs-string">'cum_profit'</span>]

def <span class="hljs-title function_">plot_strategy</span>(prices_df, signal_df, profit):
    <span class="hljs-string">""</span><span class="hljs-string">"
    매수 및 매도 신호 및 누적 수익을 포함하는 거래 전략을 시각화합니다.
    매개변수:
    - prices (pandas.Series): 주식 가격을 포함하는 Series.
    - signals (pandas.DataFrame): 매수(1) 및 매도(-1) 신호를 포함하는 DataFrame.
    - profit (pandas.Series): 시간에 따른 누적 수익을 포함하는 Series.
    반환값:
    - ax1 (matplotlib.axes.Axes): 주식 가격과 신호를 표시하는 상단 서브플롯.
    - ax2 (matplotlib.axes.Axes): 누적 수익을 표시하는 하단 서브플롯.
    "</span><span class="hljs-string">""</span>
    fig, (ax1, ax2) = plt.<span class="hljs-title function_">subplots</span>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, gridspec_kw={<span class="hljs-string">'height_ratios'</span>: (<span class="hljs-number">3</span>, <span class="hljs-number">1</span>)},
                                   figsize=(<span class="hljs-number">18</span>, <span class="hljs-number">12</span>))
    ax1.<span class="hljs-title function_">set_xlabel</span>(<span class="hljs-string">'날짜'</span>)
    ax1.<span class="hljs-title function_">set_ylabel</span>(<span class="hljs-string">'달러 단위의 가격'</span>)
    ax1.<span class="hljs-title function_">plot</span>(prices_df.<span class="hljs-property">index</span>, prices_df, color=<span class="hljs-string">'g'</span>, lw=<span class="hljs-number">0.25</span>)
    # 매수 및 매도 신호를 플롯합니다.
    ax1.<span class="hljs-title function_">plot</span>(signal_df.<span class="hljs-property">loc</span>[signal_df.<span class="hljs-property">orders</span> == <span class="hljs-number">1.0</span>].<span class="hljs-property">index</span>,
             prices_df[signal_df.<span class="hljs-property">orders</span> == <span class="hljs-number">1.0</span>],
             <span class="hljs-string">'^'</span>, markersize=<span class="hljs-number">12</span>, color=<span class="hljs-string">'blue'</span>, label=<span class="hljs-string">'매수'</span>)
    ax1.<span class="hljs-title function_">plot</span>(signal_df.<span class="hljs-property">loc</span>[signal_df.<span class="hljs-property">orders</span> == -<span class="hljs-number">1.0</span>].<span class="hljs-property">index</span>,
             prices_df[signal_df.<span class="hljs-property">orders</span> == -<span class="hljs-number">1.0</span>],
             <span class="hljs-string">'v'</span>, markersize=<span class="hljs-number">12</span>, color=<span class="hljs-string">'red'</span>, label=<span class="hljs-string">'매도'</span>)
    ax2.<span class="hljs-title function_">plot</span>(profit.<span class="hljs-property">index</span>, profit, color=<span class="hljs-string">'b'</span>)
    ax2.<span class="hljs-title function_">set_ylabel</span>(<span class="hljs-string">'누적 수익 (%)'</span>)
    ax2.<span class="hljs-title function_">set_xlabel</span>(<span class="hljs-string">'날짜'</span>)
    <span class="hljs-keyword">return</span> ax1, ax2
</code></pre>
<p>모두를 결합합시다</p>
<pre><code class="hljs language-js">aapl_ts_df = <span class="hljs-title function_">load_ticker_ts_df</span>(<span class="hljs-string">'AAPL'</span>,
                               start_date=<span class="hljs-string">'2021-01-01'</span>,
                               end_date=<span class="hljs-string">'2023-01-01'</span>)
signal_df = <span class="hljs-title function_">double_simple_moving_average_signals</span>(aapl_ts_df, <span class="hljs-number">5</span>, <span class="hljs-number">30</span>)
profit_series = <span class="hljs-title function_">calculate_profit</span>(signal_df, aapl_ts_df[<span class="hljs-string">"Adj Close"</span>])
ax1, ax2 = <span class="hljs-title function_">plot_strategy</span>(aapl_ts_df[<span class="hljs-string">"Adj Close"</span>], signal_df, profit_series)

# 단기 및 장기 이동평균 추가
ax1.<span class="hljs-title function_">plot</span>(signal_df.<span class="hljs-property">index</span>, signal_df[<span class="hljs-string">'short_mavg'</span>],
         linestyle=<span class="hljs-string">'--'</span>, label=<span class="hljs-string">'빠른 SMA'</span>)
ax1.<span class="hljs-title function_">plot</span>(signal_df.<span class="hljs-property">index</span>, signal_df[<span class="hljs-string">'long_mavg'</span>],
         linestyle=<span class="hljs-string">'--'</span>, label=<span class="hljs-string">'느린 SMA'</span>)
ax1.<span class="hljs-title function_">legend</span>(loc=<span class="hljs-string">'upper left'</span>, fontsize=<span class="hljs-number">10</span>)
plt.<span class="hljs-title function_">show</span>()
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/TIL/assets/img/2024-07-13-BuildingAMomentumandReversionTradingStrategyWithPython_0.png" alt="Strategy"></p>
<p>지난 2년 동안 이 전략은 30%의 수익을 창출했습니다. 최근 S&#x26;P 500의 10%의 수익과 비교했을 때, 강력한 전략으로 보입니다.</p>
<h2>단순 관성 전략</h2>
<p>이 전략은 가격 상승 또는 하락의 빈도에 기초합니다. 연속된 일정 기간 동안 가격이 지속적으로 상승하면 매수 기회를, 하락하면 매도 기회로 간주합니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이전에 논의 된 간단한 이동 평균 (SMA) 전략에서 일부 유틸리티 함수를 재사용할 것입니다.</p>
<p>다음은이 전략의 기본 버전을 구현하는 코드입니다:</p>
<pre><code class="hljs language-js">def <span class="hljs-title function_">naive_momentum_signals</span>(ticker_ts_df, nb_conseq_days=<span class="hljs-number">2</span>):
    <span class="hljs-string">""</span><span class="hljs-string">"
    연이은 양수 또는 음수 가격 변동에 기반한 소박한 모멘텀 트레이딩 신호를 생성합니다.
    매개변수:
    - ticker_ts_df (pandas.DataFrame): 과거 주식 데이터가 포함 된 DataFrame입니다.
    - nb_conseq_days (int): 신호를 트리거 할 연속적 양수 또는 음수 일수입니다.
    반환 값:
    - signals (pandas.DataFrame): 구매 (1) 및 판매 (-1) 신호가 포함 된 'orders' 열이있는 DataFrame입니다.
    "</span><span class="hljs-string">""</span>
    signals = pd.<span class="hljs-title class_">DataFrame</span>(index=ticker_ts_df.<span class="hljs-property">index</span>)
    signals[<span class="hljs-string">'orders'</span>] = <span class="hljs-number">0</span>

    price = ticker_ts_df[<span class="hljs-string">'Adj Close'</span>]
    price_diff = price.<span class="hljs-title function_">diff</span>()
    signal = <span class="hljs-number">0</span>
    cons_day = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(<span class="hljs-number">1</span>, <span class="hljs-title function_">len</span>(ticker_ts_df)):
        <span class="hljs-keyword">if</span> price_diff[i] > <span class="hljs-number">0</span>:
            cons_day = cons_day + <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> price_diff[i] > <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>
            <span class="hljs-keyword">if</span> cons_day == nb_conseq_days and signal != <span class="hljs-number">1</span>:
                signals[<span class="hljs-string">'orders'</span>].<span class="hljs-property">iloc</span>[i] = <span class="hljs-number">1</span>
                signal = <span class="hljs-number">1</span>
        elif price_diff[i] &#x3C; <span class="hljs-number">0</span>:
            cons_day = cons_day - <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> price_diff[i] &#x3C; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>
            <span class="hljs-keyword">if</span> cons_day == -nb_conseq_days and signal != -<span class="hljs-number">1</span>:
                signals[<span class="hljs-string">'orders'</span>].<span class="hljs-property">iloc</span>[i] = -<span class="hljs-number">1</span>
                signal = -<span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> signals

signal_df = <span class="hljs-title function_">naive_momentum_signals</span>(aapl_ts_df)
profit_series = <span class="hljs-title function_">calculate_profit</span>(signal_df, aapl_ts_df[<span class="hljs-string">"Adj Close"</span>])
ax1, _ = <span class="hljs-title function_">plot_strategy</span>(aapl_ts_df[<span class="hljs-string">"Adj Close"</span>], signal_df, profit_series)
ax1.<span class="hljs-title function_">legend</span>(loc=<span class="hljs-string">'upper left'</span>, fontsize=<span class="hljs-number">10</span>)
plt.<span class="hljs-title function_">show</span>()
</code></pre>
<img src="/TIL/assets/img/2024-07-13-BuildingAMomentumandReversionTradingStrategyWithPython_1.png">
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>안타깝지만, 이 전략은 수익을 창출하지 않았고 수익을 얻지 못했습니다.</p>
<p>그러나 모델을 단순히 반전시킴으로써 더 나은 성과를 거둘 수도 있었을 것입니다 (이 기법은 WallStreetBets의 주식 분석에 많이 제안된 방법 중 하나입니다). 이를 위해 거래 신호를 -1로 곱하면 됩니다. 이 반전 접근법은 전략의 원래 신호가 효과적이지 않을 때 일반적으로 효과적입니다.</p>
<p>솔직히 말해서, 이 전략은 일반적으로 개별 상품이 아닌 더 넓은 시장에 적용되며 더 짧은 시간대에 구현됩니다.</p>
<h1>회귀 전략</h1>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>예를 들어, 일론 머스크가 테슬라에 블록체인을 통합할 것이라는 트윗을 올리면, 테슬라 주식에 과도한 매수 열풍이 불고 있을 것입니다. 그러나 다음 날에는 투자자들이 아무런 근본적인 변화가 없다는 것을 깨닫고 시장이 관심을 잃으면, 가격은 더 합리적인 수준으로 회귀할 것입니다.</p>
<p>따라서 어떤 상품이나 도구가 어느 방향으로든 표준 지수에서 너무 빠르게 벗어날 경우, 결국 오랜 기간에 걸쳐 표준 지수로 돌아가게 될 것입니다.</p>
<p>트렌드와 모멘텀 전략과 유사하게, 회귀 전략은 시장 역학을 간소화하고 시장 참가자들이 일반적으로 사용하는 전략입니다.</p>
<h1>평균 회귀</h1>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>평균 회귀 전략에서는 주식 가격이 시간이 지남에 따라 평균값 또는 평균값에 가까워질 것이라는 가정 하에 운영합니다.</p>
<p>아래는 이 전략을 구현하는 신호 코드입니다:</p>
<pre><code class="hljs language-js">def <span class="hljs-title function_">mean_reversion_signals</span>(ticker_ts_df, entry_threshold=<span class="hljs-number">1.0</span>, exit_threshold=<span class="hljs-number">0.5</span>):
    <span class="hljs-string">""</span><span class="hljs-string">"
    이동 평균과 임계값을 기반으로 한 평균 회귀 트레이딩 신호 생성.
    매개변수:
    - ticker_ts_df (pandas.DataFrame): 주식의 역사적 데이터가 포함된 DataFrame.
    - entry_threshold (float): 표준 편차의 배수로 표시된 진입 임계값.
    - exit_threshold (float): 표준 편차의 배수로 표시된 종료 임계값.
    반환:
    - signals (pandas.DataFrame): 'orders' 열을 포함한 Buy(1) 및 Sell(-1) 신호가 포함된 DataFrame.
    "</span><span class="hljs-string">""</span>
    signals = pd.<span class="hljs-title class_">DataFrame</span>(index=ticker_ts_df.<span class="hljs-property">index</span>)
    signals[<span class="hljs-string">'mean'</span>] = ticker_ts_df[<span class="hljs-string">'Adj Close'</span>].<span class="hljs-title function_">rolling</span>(
        <span class="hljs-variable language_">window</span>=<span class="hljs-number">20</span>).<span class="hljs-title function_">mean</span>()  # 필요한대로 창 크기 조정
    signals[<span class="hljs-string">'std'</span>] = ticker_ts_df[<span class="hljs-string">'Adj Close'</span>].<span class="hljs-title function_">rolling</span>(
        <span class="hljs-variable language_">window</span>=<span class="hljs-number">20</span>).<span class="hljs-title function_">std</span>()  # 필요한대로 창 크기 조정
    signals[<span class="hljs-string">'signal'</span>] = np.<span class="hljs-title function_">where</span>(ticker_ts_df[<span class="hljs-string">'Adj Close'</span>] > (
        signals[<span class="hljs-string">'mean'</span>] + entry_threshold * signals[<span class="hljs-string">'std'</span>]), <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)
    signals[<span class="hljs-string">'signal'</span>] = np.<span class="hljs-title function_">where</span>(ticker_ts_df[<span class="hljs-string">'Adj Close'</span>] &#x3C; (
        signals[<span class="hljs-string">'mean'</span>] - exit_threshold * signals[<span class="hljs-string">'std'</span>]), -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)
    signals[<span class="hljs-string">'orders'</span>] = signals[<span class="hljs-string">'signal'</span>].<span class="hljs-title function_">diff</span>()
    signals.<span class="hljs-property">loc</span>[signals[<span class="hljs-string">'orders'</span>] == <span class="hljs-number">0</span>, <span class="hljs-string">'orders'</span>] = <span class="hljs-title class_">None</span>

    <span class="hljs-keyword">return</span> signals
</code></pre>
<p>이 함수에서는 주식 가격 데이터의 표준 편차와 평균을 결정합니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>가격이 평균에서 일정 표준 편차 수로 벗어날 때 신호가 생성됩니다.</p>
<p>이전에 만든 함수를 사용하여 함께 테스트해보겠습니다:</p>
<pre><code class="hljs language-js">signal_df = <span class="hljs-title function_">mean_reversion_signals</span>(aapl_ts_df)
profit_series = <span class="hljs-title function_">calculate_profit</span>(signal_df, aapl_ts_df[<span class="hljs-string">"Adj Close"</span>])
ax1, _ = <span class="hljs-title function_">plot_strategy</span>(aapl_ts_df[<span class="hljs-string">"Adj Close"</span>], signal_df, profit_series)

ax1.<span class="hljs-title function_">plot</span>(signal_df.<span class="hljs-property">index</span>, signal_df[<span class="hljs-string">'mean'</span>], linestyle=<span class="hljs-string">'--'</span>, label=<span class="hljs-string">"평균"</span>)
ax1.<span class="hljs-title function_">plot</span>(signal_df.<span class="hljs-property">index</span>, signal_df[<span class="hljs-string">'mean'</span>] +
         signal_df[<span class="hljs-string">'std'</span>], linestyle=<span class="hljs-string">'--'</span>, label=<span class="hljs-string">"상한 표준편차"</span>)
ax1.<span class="hljs-title function_">plot</span>(signal_df.<span class="hljs-property">index</span>, signal_df[<span class="hljs-string">'mean'</span>] -
         signal_df[<span class="hljs-string">'std'</span>], linestyle=<span class="hljs-string">'--'</span>, label=<span class="hljs-string">"하한 표준편차"</span>)
ax1.<span class="hljs-title function_">legend</span>(loc=<span class="hljs-string">'upper left'</span>, fontsize=<span class="hljs-number">10</span>)
plt.<span class="hljs-title function_">show</span>()
</code></pre>
<img src="/TIL/assets/img/2024-07-13-BuildingAMomentumandReversionTradingStrategyWithPython_2.png">
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>종이 상으로 10%의 수익률은 만족스럽게 보일 수 있지만, 실제로는 넓은 S&#x26;P 500 지수 펀드에 투자함으로써 유사한 결과를 달성할 수 있습니다.</p>
<p>앞으로의 글에서는 Pair-Trading과 통계적 화폐 섹터에 속한 보다 정교한 형태의 복귀 전략을 탐구할 것입니다. 또한 전략 지표인 Sharpe 비율과 같은 전략 평가를 돕는 지표들을 살펴볼 것입니다. 이 분석을 통해 우리는 S&#x26;P 500 지수의 수익률에 맞게 하는 이 전략이 왜 약한 것으로 여겨지는지를 이해할 수 있을 것입니다.</p>
<p>저의 추천 링크를 통해 Tradingview 구독비를 최대 100% 할인받을 수 있습니다. 해당 링크에 접속하면 페이지 상단 왼쪽에 있는 Tradingview 아이콘을 클릭하여 원하는 무료 요금제로 이동하세요.</p>
<p>➡️여기에서 제 구독하기 ➡️ <a href="https://medium.com/@aamurtazin/subscribe" rel="nofollow" target="_blank">https://medium.com/@aamurtazin/subscribe</a></p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>내가 곧 올릴 블로그에서 많은 내용을 공유할 거야.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"파이썬으로 모멘텀 및 되돌림 트레이딩 전략 구축 방법","description":"","date":"2024-07-13 19:01","slug":"2024-07-13-BuildingAMomentumandReversionTradingStrategyWithPython","content":"\n\n양적 거래에서는 금융 시장에서 우위를 차지하기 위해 다양한 전략이 사용됩니다. 모멘텀 및 추세 기반 전략은 인기가 많지만, 종종 중요한 알파를 창출하는 데 어려움을 겪습니다. 이들은 종종 유튜브에서 금융 강좌로 판매될 때만 알파를 창출하게 됩니다.\n\n모멘텀 및 추세 접근법은 최근 가격 상승을 보이는 자산이 가까운 미래에 상승세를 이어갈 것이라는 아이디어를 활용하거나, 손실을 보이는 자산이 계속해서 하락할 것이라는 아이디어를 기반으로 합니다. 추세와 모멘텀을 구분하는 것이 중요합니다.\n\n- 추세 추종은 시장 베타를 분석하여 특정 방향의 절대 수익을 목표로 합니다.\n- 반면에, 모멘텀 전략은 상대 수익에 초점을 맞추며, 분류나 섹터 내에서 교차부문 성능을 평가하여 시장 중립적 입장을 유지합니다.\n\n회귀 전략은 가격이 특정 기간 동안 평균 또는 다중 평균 값으로 되돌아갈 것이라는 믿음에 기반합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 기사에서는 이러한 전략을 검토하고 해당 분석을 위한 Python 코드 구현을 제공할 것입니다. 우리는 페어 트레이딩을 포함한 더 세련된 전략과 분석을 진행할 것입니다.\n\n우리의 분석은 최근의 시장 상황, 특히 팬데믹 이후의 주식 가격을 기준으로 살펴볼 것입니다. 모든 논의된 전략은 롱 온리이며 레버리지가 걸리지 않은 전략입니다.\n\n시작하기 전에, 투자 커뮤니티에 가입하실 것을 초대합니다. 가입하시면 중요한 기사를 놓치지 않고 투자자로서 스킬을 향상시킬 수 있습니다.\n\nPython 환경을 설정하는 것은 효율적으로 Python 코드를 작성, 실행 및 관리하기 위해 필요한 도구와 라이브러리를 갖추는 것을 포함합니다. Python 환경을 설정하는 자세한 안내서는 여기 있습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 1. 파이썬 설치하기:\n\n만약 여러분의 컴퓨터에 아직 파이썬이 설치되어 있지 않다면, 공식 파이썬 웹사이트([https://www.python.org/](https://www.python.org/))에서 다운로드하고 설치해주세요. 여러분의 운영 체제(Windows, macOS, 또는 Linux)에 맞는 올바른 버전을 선택해야 합니다. 가장 최신의 안정 버전을 설치하는 것이 좋습니다.\n\n# 2. 텍스트 편집기 또는 IDE 선택하기:\n\n파이썬으로 코딩할 때 텍스트 편집기나 통합 개발 환경(IDE)을 선택해주세요. 널리 사용되는 몇 가지 옵션으로는:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Visual Studio Code: 내장된 Python 지원과 다양한 확장 기능을 갖춘 가벼운 사용자 정의 가능한 편집기입니다.\n- PyCharm: 코드 완성, 디버깅 및 버전 관리 시스템과 통합된 Python 개발을 위해 최적화된 견고한 IDE입니다.\n- Jupyter Notebook: 데이터 분석 및 시각화 작업에 이상적인 웹 브라우저에서 Python 코드를 작성하고 실행할 수 있는 인터랙티브 노트북 인터페이스입니다.\n\n## 3. 가상 환경 설정하기 (선택 사항이지만 권장됨):\n\n가상 환경은 종속성을 관리하고 프로젝트 환경을 격리하는 데 유용합니다. 가상 환경을 만들려면 터미널이나 명령 프롬프트를 열고 프로젝트 디렉토리로 이동한 다음 다음 명령을 실행하십시오:\n\n```js\npython -m venv myenv\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n해당 명령어는 프로젝트 디렉토리에 `env`라는 가상 환경을 만듭니다. 가상 환경을 활성화하려면 다음 명령어를 사용하십시오 (사용하는 운영 체제에 따라 명령어가 다를 수 있습니다):\n\n## Windows:\n\n```js\n.\\env\\Scripts\\activate\n```\n\n## macOS/Linux:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nsource env/bin/activate\n```\n\n활성화된 후에 `pip`를 사용하여 프로젝트별 종속성을 설치할 수 있습니다. 이 가상 환경 안에 이들이 포함되어 다른 프로젝트와의 충돌을 방지합니다.\n\n# 4. 필요한 패키지 설치:\n\n```js\npython -m venv myenv\npip install numpy pandas matplotlib\npip install -r requirements.txt\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 트렌드와 모멘텀 전략\n\n예를 들어 설명하자면, 만약 자산의 가격이 지난 일주일 동안 상승 추세를 보였다면, 그 자산은 같은 방향으로 계속 움직일 가능성이 높습니다. 이 전략은 미래 가격 변동이 과거 움직임의 패턴을 따르리라는 아이디어에 기반을 두고 있습니다. 월스트리트벳 커뮤니티가 자주 외친 것처럼, 주식은 주로 상승하는 경향이 있습니다.\n\n비록 이 전략이 간단하긴 하지만, 다음과 같은 단점이 있습니다:\n\n- 시장 소음과 중요한 이벤트를 무시하여 중요한 변동을 완화할 수 있습니다.\n- 빈번한 거래는 거래 수수료 누적으로 이어질 수 있습니다.\n- 폭넓게 사용되기 때문에 이 전략을 활용하는 데 경쟁 우위가 제한적이거나 전혀 없을 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 이동평균 교차 전략\n\n다음 코드는 이 전략을 구현합니다:\n\n```js\ndef double_simple_moving_average_signals(ticker_ts_df, short_window=5, long_window=30):\n    \"\"\"\n    이중 단순 이동평균 (SMA) 전략을 기반으로 거래 신호를 생성합니다.\n    매개변수:\n    - ticker_ts_df (pandas.DataFrame): 주식의 과거 데이터가 포함 된 DataFrame.\n    - short_window (int): 단기 SMA의 창 크기.\n    - long_window (int): 장기 SMA의 창 크기.\n    반환값:\n    - signals (pandas.DataFrame): 거래 신호를 포함하는 DataFrame.\n    \"\"\"\n    signals = pd.DataFrame(index=ticker_ts_df.index)\n    signals['signal'] = 0.0\n    signals['short_mavg'] = ticker_ts_df['Close'].rolling(window=short_window,\n                                                          min_periods=1,\n                                                          center=False).mean()\n    signals['long_mavg'] = ticker_ts_df['Close'].rolling(window=long_window,\n                                                         min_periods=1,\n                                                         center=False).mean()\n    # SMAs가 교차 되었을 때 신호 생성\n    signals['signal'] = np.where(\n        signals['short_mavg'] \u003e signals['long_mavg'], 1, 0)\n    signals['orders'] = signals['signal'].diff()\n    signals.loc[signals['orders'] == 0, 'orders'] = None\n    return signals\n```\n\n필요한 함수를 생성하기 위한 단계를 살펴보겠습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 단기 및 장기 이동평균 값 계산: 단기(빠른) 및 장기(느린) 단순 이동평균(SMA)을 계산하는 함수를 생성하세요.\n- 거래 신호 생성: 단기와 장기 이동평균 값을 비교하여 매수 및 매도 신호를 생성하는 함수를 개발하세요.\n- 시간에 따른 자본 계산: 생성된 신호를 기반으로 자본을 계산하는 유틸리티 함수를 구현하세요.\n- 결과 시각화: 주식의 시계열 데이터와 진입 및 퇴출 신호를 함께 그리는 함수를 작성하세요.\n\n```js\ndef load_ticker_time_series(ticker, start_date, end_date):\n    \"\"\"\n    Yahoo Finance API에서 시간 시리즈 금융 데이터를 검색하고 캐시합니다.\n    매개변수:\n    - ticker (str): 주식 티커 심볼 (예: 애플의 경우 'AAPL').\n    - start_date (str): 데이터 검색을 위한 'YYYY-MM-DD' 형식의 시작 날짜.\n    - end_date (str): 데이터 검색을 위한 'YYYY-MM-DD' 형식의 종료 날짜.\n    반환값:\n    - df (pandas.DataFrame): 금융 시계열 데이터를 포함하는 DataFrame.\"\"\"\n    dir_path = './data'\n    cached_file_path = f'{dir_path}/{ticker}_{start_date}_{end_date}.pkl'\n    try:\n        if os.path.exists(cached_file_path):\n            df = pd.read_pickle(cached_file_path)\n        else:\n            df = yf.download(ticker, start=start_date, end=end_date)\n            if not os.path.exists(dir_path):\n                os.makedirs(dir_path)\n            df.to_pickle(cached_file_path)\n    except FileNotFoundError:\n        print(\n            f'주식: {ticker}에 대한 파일을 다운로드 및 캐시하는 중 오류가 발생했습니다.')\n    return df\n\ndef calculate_profit(signals, prices):\n    \"\"\"\n    거래 신호와 주식 가격을 기반으로 누적 수익을 계산합니다.\n    매개변수:\n    - signals (pandas.DataFrame): 거래 신호를 포함하는 DataFrame (매수: 1, 매도: -1).\n    - prices (pandas.Series): 신호 날짜에 해당하는 주식 가격을 포함하는 Series.\n    반환값:\n    - cum_profit (pandas.Series): 시간에 따른 누적 수익을 포함하는 Series.\n    \"\"\"\n    profit = pd.DataFrame(index=prices.index)\n    profit['profit'] = 0.0\n    buys = signals[signals['orders'] == 1].index\n    sells = signals[signals['orders'] == -1].index\n    while sells[0] \u003c buys[0]:\n        # 롱 포지션 전용 전략입니다. 판매로 시작할 수 없습니다.\n        sells = sells[1:]\n    if len(buys) == 0 or len(sells) == 0:\n        # 아무 조치도 취하지 않았습니다.\n        return profit\n    if len(sells) \u003c len(buys):\n        # 마지막에 판매하는 것으로 가정합니다.\n        sells = sells.append(pd.Index(prices.tail(1).index))\n    buy_prices = prices.loc[buys]\n    sell_prices = prices.loc[sells]\n    profit.loc[sells, 'profit'] = sell_prices.values - buy_prices.values\n    profit['profit'] = profit['profit'].fillna(0)\n    # 누적 수익 생성\n    profit['cum_profit'] = profit['profit'].cumsum()\n    return profit['cum_profit']\n\ndef plot_strategy(prices_df, signal_df, profit):\n    \"\"\"\n    매수 및 매도 신호 및 누적 수익을 포함하는 거래 전략을 시각화합니다.\n    매개변수:\n    - prices (pandas.Series): 주식 가격을 포함하는 Series.\n    - signals (pandas.DataFrame): 매수(1) 및 매도(-1) 신호를 포함하는 DataFrame.\n    - profit (pandas.Series): 시간에 따른 누적 수익을 포함하는 Series.\n    반환값:\n    - ax1 (matplotlib.axes.Axes): 주식 가격과 신호를 표시하는 상단 서브플롯.\n    - ax2 (matplotlib.axes.Axes): 누적 수익을 표시하는 하단 서브플롯.\n    \"\"\"\n    fig, (ax1, ax2) = plt.subplots(2, 1, gridspec_kw={'height_ratios': (3, 1)},\n                                   figsize=(18, 12))\n    ax1.set_xlabel('날짜')\n    ax1.set_ylabel('달러 단위의 가격')\n    ax1.plot(prices_df.index, prices_df, color='g', lw=0.25)\n    # 매수 및 매도 신호를 플롯합니다.\n    ax1.plot(signal_df.loc[signal_df.orders == 1.0].index,\n             prices_df[signal_df.orders == 1.0],\n             '^', markersize=12, color='blue', label='매수')\n    ax1.plot(signal_df.loc[signal_df.orders == -1.0].index,\n             prices_df[signal_df.orders == -1.0],\n             'v', markersize=12, color='red', label='매도')\n    ax2.plot(profit.index, profit, color='b')\n    ax2.set_ylabel('누적 수익 (%)')\n    ax2.set_xlabel('날짜')\n    return ax1, ax2\n```\n\n모두를 결합합시다\n\n```js\naapl_ts_df = load_ticker_ts_df('AAPL',\n                               start_date='2021-01-01',\n                               end_date='2023-01-01')\nsignal_df = double_simple_moving_average_signals(aapl_ts_df, 5, 30)\nprofit_series = calculate_profit(signal_df, aapl_ts_df[\"Adj Close\"])\nax1, ax2 = plot_strategy(aapl_ts_df[\"Adj Close\"], signal_df, profit_series)\n\n# 단기 및 장기 이동평균 추가\nax1.plot(signal_df.index, signal_df['short_mavg'],\n         linestyle='--', label='빠른 SMA')\nax1.plot(signal_df.index, signal_df['long_mavg'],\n         linestyle='--', label='느린 SMA')\nax1.legend(loc='upper left', fontsize=10)\nplt.show()\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![Strategy](/TIL/assets/img/2024-07-13-BuildingAMomentumandReversionTradingStrategyWithPython_0.png)\n\n지난 2년 동안 이 전략은 30%의 수익을 창출했습니다. 최근 S\u0026P 500의 10%의 수익과 비교했을 때, 강력한 전략으로 보입니다.\n\n## 단순 관성 전략\n\n이 전략은 가격 상승 또는 하락의 빈도에 기초합니다. 연속된 일정 기간 동안 가격이 지속적으로 상승하면 매수 기회를, 하락하면 매도 기회로 간주합니다.\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이전에 논의 된 간단한 이동 평균 (SMA) 전략에서 일부 유틸리티 함수를 재사용할 것입니다.\n\n다음은이 전략의 기본 버전을 구현하는 코드입니다:\n\n```js\ndef naive_momentum_signals(ticker_ts_df, nb_conseq_days=2):\n    \"\"\"\n    연이은 양수 또는 음수 가격 변동에 기반한 소박한 모멘텀 트레이딩 신호를 생성합니다.\n    매개변수:\n    - ticker_ts_df (pandas.DataFrame): 과거 주식 데이터가 포함 된 DataFrame입니다.\n    - nb_conseq_days (int): 신호를 트리거 할 연속적 양수 또는 음수 일수입니다.\n    반환 값:\n    - signals (pandas.DataFrame): 구매 (1) 및 판매 (-1) 신호가 포함 된 'orders' 열이있는 DataFrame입니다.\n    \"\"\"\n    signals = pd.DataFrame(index=ticker_ts_df.index)\n    signals['orders'] = 0\n\n    price = ticker_ts_df['Adj Close']\n    price_diff = price.diff()\n    signal = 0\n    cons_day = 0\n    for i in range(1, len(ticker_ts_df)):\n        if price_diff[i] \u003e 0:\n            cons_day = cons_day + 1 if price_diff[i] \u003e 0 else 0\n            if cons_day == nb_conseq_days and signal != 1:\n                signals['orders'].iloc[i] = 1\n                signal = 1\n        elif price_diff[i] \u003c 0:\n            cons_day = cons_day - 1 if price_diff[i] \u003c 0 else 0\n            if cons_day == -nb_conseq_days and signal != -1:\n                signals['orders'].iloc[i] = -1\n                signal = -1\n    return signals\n\nsignal_df = naive_momentum_signals(aapl_ts_df)\nprofit_series = calculate_profit(signal_df, aapl_ts_df[\"Adj Close\"])\nax1, _ = plot_strategy(aapl_ts_df[\"Adj Close\"], signal_df, profit_series)\nax1.legend(loc='upper left', fontsize=10)\nplt.show()\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-BuildingAMomentumandReversionTradingStrategyWithPython_1.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안타깝지만, 이 전략은 수익을 창출하지 않았고 수익을 얻지 못했습니다.\n\n그러나 모델을 단순히 반전시킴으로써 더 나은 성과를 거둘 수도 있었을 것입니다 (이 기법은 WallStreetBets의 주식 분석에 많이 제안된 방법 중 하나입니다). 이를 위해 거래 신호를 -1로 곱하면 됩니다. 이 반전 접근법은 전략의 원래 신호가 효과적이지 않을 때 일반적으로 효과적입니다.\n\n솔직히 말해서, 이 전략은 일반적으로 개별 상품이 아닌 더 넓은 시장에 적용되며 더 짧은 시간대에 구현됩니다.\n\n# 회귀 전략\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예를 들어, 일론 머스크가 테슬라에 블록체인을 통합할 것이라는 트윗을 올리면, 테슬라 주식에 과도한 매수 열풍이 불고 있을 것입니다. 그러나 다음 날에는 투자자들이 아무런 근본적인 변화가 없다는 것을 깨닫고 시장이 관심을 잃으면, 가격은 더 합리적인 수준으로 회귀할 것입니다.\n\n따라서 어떤 상품이나 도구가 어느 방향으로든 표준 지수에서 너무 빠르게 벗어날 경우, 결국 오랜 기간에 걸쳐 표준 지수로 돌아가게 될 것입니다.\n\n트렌드와 모멘텀 전략과 유사하게, 회귀 전략은 시장 역학을 간소화하고 시장 참가자들이 일반적으로 사용하는 전략입니다.\n\n# 평균 회귀\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n평균 회귀 전략에서는 주식 가격이 시간이 지남에 따라 평균값 또는 평균값에 가까워질 것이라는 가정 하에 운영합니다.\n\n아래는 이 전략을 구현하는 신호 코드입니다:\n\n```js\ndef mean_reversion_signals(ticker_ts_df, entry_threshold=1.0, exit_threshold=0.5):\n    \"\"\"\n    이동 평균과 임계값을 기반으로 한 평균 회귀 트레이딩 신호 생성.\n    매개변수:\n    - ticker_ts_df (pandas.DataFrame): 주식의 역사적 데이터가 포함된 DataFrame.\n    - entry_threshold (float): 표준 편차의 배수로 표시된 진입 임계값.\n    - exit_threshold (float): 표준 편차의 배수로 표시된 종료 임계값.\n    반환:\n    - signals (pandas.DataFrame): 'orders' 열을 포함한 Buy(1) 및 Sell(-1) 신호가 포함된 DataFrame.\n    \"\"\"\n    signals = pd.DataFrame(index=ticker_ts_df.index)\n    signals['mean'] = ticker_ts_df['Adj Close'].rolling(\n        window=20).mean()  # 필요한대로 창 크기 조정\n    signals['std'] = ticker_ts_df['Adj Close'].rolling(\n        window=20).std()  # 필요한대로 창 크기 조정\n    signals['signal'] = np.where(ticker_ts_df['Adj Close'] \u003e (\n        signals['mean'] + entry_threshold * signals['std']), 1, 0)\n    signals['signal'] = np.where(ticker_ts_df['Adj Close'] \u003c (\n        signals['mean'] - exit_threshold * signals['std']), -1, 0)\n    signals['orders'] = signals['signal'].diff()\n    signals.loc[signals['orders'] == 0, 'orders'] = None\n\n    return signals\n```\n\n이 함수에서는 주식 가격 데이터의 표준 편차와 평균을 결정합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n가격이 평균에서 일정 표준 편차 수로 벗어날 때 신호가 생성됩니다.\n\n이전에 만든 함수를 사용하여 함께 테스트해보겠습니다:\n\n```js\nsignal_df = mean_reversion_signals(aapl_ts_df)\nprofit_series = calculate_profit(signal_df, aapl_ts_df[\"Adj Close\"])\nax1, _ = plot_strategy(aapl_ts_df[\"Adj Close\"], signal_df, profit_series)\n\nax1.plot(signal_df.index, signal_df['mean'], linestyle='--', label=\"평균\")\nax1.plot(signal_df.index, signal_df['mean'] +\n         signal_df['std'], linestyle='--', label=\"상한 표준편차\")\nax1.plot(signal_df.index, signal_df['mean'] -\n         signal_df['std'], linestyle='--', label=\"하한 표준편차\")\nax1.legend(loc='upper left', fontsize=10)\nplt.show()\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-13-BuildingAMomentumandReversionTradingStrategyWithPython_2.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n종이 상으로 10%의 수익률은 만족스럽게 보일 수 있지만, 실제로는 넓은 S\u0026P 500 지수 펀드에 투자함으로써 유사한 결과를 달성할 수 있습니다.\n\n앞으로의 글에서는 Pair-Trading과 통계적 화폐 섹터에 속한 보다 정교한 형태의 복귀 전략을 탐구할 것입니다. 또한 전략 지표인 Sharpe 비율과 같은 전략 평가를 돕는 지표들을 살펴볼 것입니다. 이 분석을 통해 우리는 S\u0026P 500 지수의 수익률에 맞게 하는 이 전략이 왜 약한 것으로 여겨지는지를 이해할 수 있을 것입니다.\n\n저의 추천 링크를 통해 Tradingview 구독비를 최대 100% 할인받을 수 있습니다. 해당 링크에 접속하면 페이지 상단 왼쪽에 있는 Tradingview 아이콘을 클릭하여 원하는 무료 요금제로 이동하세요.\n\n➡️여기에서 제 구독하기 ➡️ https://medium.com/@aamurtazin/subscribe\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n내가 곧 올릴 블로그에서 많은 내용을 공유할 거야.","ogImage":{"url":"/TIL/assets/img/2024-07-13-BuildingAMomentumandReversionTradingStrategyWithPython_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-BuildingAMomentumandReversionTradingStrategyWithPython_0.png","tag":["Tech"],"readingTime":17},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e양적 거래에서는 금융 시장에서 우위를 차지하기 위해 다양한 전략이 사용됩니다. 모멘텀 및 추세 기반 전략은 인기가 많지만, 종종 중요한 알파를 창출하는 데 어려움을 겪습니다. 이들은 종종 유튜브에서 금융 강좌로 판매될 때만 알파를 창출하게 됩니다.\u003c/p\u003e\n\u003cp\u003e모멘텀 및 추세 접근법은 최근 가격 상승을 보이는 자산이 가까운 미래에 상승세를 이어갈 것이라는 아이디어를 활용하거나, 손실을 보이는 자산이 계속해서 하락할 것이라는 아이디어를 기반으로 합니다. 추세와 모멘텀을 구분하는 것이 중요합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e추세 추종은 시장 베타를 분석하여 특정 방향의 절대 수익을 목표로 합니다.\u003c/li\u003e\n\u003cli\u003e반면에, 모멘텀 전략은 상대 수익에 초점을 맞추며, 분류나 섹터 내에서 교차부문 성능을 평가하여 시장 중립적 입장을 유지합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e회귀 전략은 가격이 특정 기간 동안 평균 또는 다중 평균 값으로 되돌아갈 것이라는 믿음에 기반합니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 기사에서는 이러한 전략을 검토하고 해당 분석을 위한 Python 코드 구현을 제공할 것입니다. 우리는 페어 트레이딩을 포함한 더 세련된 전략과 분석을 진행할 것입니다.\u003c/p\u003e\n\u003cp\u003e우리의 분석은 최근의 시장 상황, 특히 팬데믹 이후의 주식 가격을 기준으로 살펴볼 것입니다. 모든 논의된 전략은 롱 온리이며 레버리지가 걸리지 않은 전략입니다.\u003c/p\u003e\n\u003cp\u003e시작하기 전에, 투자 커뮤니티에 가입하실 것을 초대합니다. 가입하시면 중요한 기사를 놓치지 않고 투자자로서 스킬을 향상시킬 수 있습니다.\u003c/p\u003e\n\u003cp\u003ePython 환경을 설정하는 것은 효율적으로 Python 코드를 작성, 실행 및 관리하기 위해 필요한 도구와 라이브러리를 갖추는 것을 포함합니다. Python 환경을 설정하는 자세한 안내서는 여기 있습니다:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e1. 파이썬 설치하기:\u003c/h1\u003e\n\u003cp\u003e만약 여러분의 컴퓨터에 아직 파이썬이 설치되어 있지 않다면, 공식 파이썬 웹사이트(\u003ca href=\"https://www.python.org/\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://www.python.org/\u003c/a\u003e)에서 다운로드하고 설치해주세요. 여러분의 운영 체제(Windows, macOS, 또는 Linux)에 맞는 올바른 버전을 선택해야 합니다. 가장 최신의 안정 버전을 설치하는 것이 좋습니다.\u003c/p\u003e\n\u003ch1\u003e2. 텍스트 편집기 또는 IDE 선택하기:\u003c/h1\u003e\n\u003cp\u003e파이썬으로 코딩할 때 텍스트 편집기나 통합 개발 환경(IDE)을 선택해주세요. 널리 사용되는 몇 가지 옵션으로는:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003eVisual Studio Code: 내장된 Python 지원과 다양한 확장 기능을 갖춘 가벼운 사용자 정의 가능한 편집기입니다.\u003c/li\u003e\n\u003cli\u003ePyCharm: 코드 완성, 디버깅 및 버전 관리 시스템과 통합된 Python 개발을 위해 최적화된 견고한 IDE입니다.\u003c/li\u003e\n\u003cli\u003eJupyter Notebook: 데이터 분석 및 시각화 작업에 이상적인 웹 브라우저에서 Python 코드를 작성하고 실행할 수 있는 인터랙티브 노트북 인터페이스입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e3. 가상 환경 설정하기 (선택 사항이지만 권장됨):\u003c/h2\u003e\n\u003cp\u003e가상 환경은 종속성을 관리하고 프로젝트 환경을 격리하는 데 유용합니다. 가상 환경을 만들려면 터미널이나 명령 프롬프트를 열고 프로젝트 디렉토리로 이동한 다음 다음 명령을 실행하십시오:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003epython -m venv myenv\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e해당 명령어는 프로젝트 디렉토리에 \u003ccode\u003eenv\u003c/code\u003e라는 가상 환경을 만듭니다. 가상 환경을 활성화하려면 다음 명령어를 사용하십시오 (사용하는 운영 체제에 따라 명령어가 다를 수 있습니다):\u003c/p\u003e\n\u003ch2\u003eWindows:\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e.\\env\\\u003cspan class=\"hljs-title class_\"\u003eScripts\u003c/span\u003e\\activate\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003emacOS/Linux:\u003c/h2\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003esource env/bin/activate\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e활성화된 후에 \u003ccode\u003epip\u003c/code\u003e를 사용하여 프로젝트별 종속성을 설치할 수 있습니다. 이 가상 환경 안에 이들이 포함되어 다른 프로젝트와의 충돌을 방지합니다.\u003c/p\u003e\n\u003ch1\u003e4. 필요한 패키지 설치:\u003c/h1\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003epython -m venv myenv\npip install numpy pandas matplotlib\npip install -r requirements.\u003cspan class=\"hljs-property\"\u003etxt\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e트렌드와 모멘텀 전략\u003c/h1\u003e\n\u003cp\u003e예를 들어 설명하자면, 만약 자산의 가격이 지난 일주일 동안 상승 추세를 보였다면, 그 자산은 같은 방향으로 계속 움직일 가능성이 높습니다. 이 전략은 미래 가격 변동이 과거 움직임의 패턴을 따르리라는 아이디어에 기반을 두고 있습니다. 월스트리트벳 커뮤니티가 자주 외친 것처럼, 주식은 주로 상승하는 경향이 있습니다.\u003c/p\u003e\n\u003cp\u003e비록 이 전략이 간단하긴 하지만, 다음과 같은 단점이 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e시장 소음과 중요한 이벤트를 무시하여 중요한 변동을 완화할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e빈번한 거래는 거래 수수료 누적으로 이어질 수 있습니다.\u003c/li\u003e\n\u003cli\u003e폭넓게 사용되기 때문에 이 전략을 활용하는 데 경쟁 우위가 제한적이거나 전혀 없을 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e이동평균 교차 전략\u003c/h1\u003e\n\u003cp\u003e다음 코드는 이 전략을 구현합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edef \u003cspan class=\"hljs-title function_\"\u003edouble_simple_moving_average_signals\u003c/span\u003e(ticker_ts_df, short_window=\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, long_window=\u003cspan class=\"hljs-number\"\u003e30\u003c/span\u003e):\n    \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\n    이중 단순 이동평균 (SMA) 전략을 기반으로 거래 신호를 생성합니다.\n    매개변수:\n    - ticker_ts_df (pandas.DataFrame): 주식의 과거 데이터가 포함 된 DataFrame.\n    - short_window (int): 단기 SMA의 창 크기.\n    - long_window (int): 장기 SMA의 창 크기.\n    반환값:\n    - signals (pandas.DataFrame): 거래 신호를 포함하는 DataFrame.\n    \"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    signals = pd.\u003cspan class=\"hljs-title class_\"\u003eDataFrame\u003c/span\u003e(index=ticker_ts_df.\u003cspan class=\"hljs-property\"\u003eindex\u003c/span\u003e)\n    signals[\u003cspan class=\"hljs-string\"\u003e'signal'\u003c/span\u003e] = \u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e\n    signals[\u003cspan class=\"hljs-string\"\u003e'short_mavg'\u003c/span\u003e] = ticker_ts_df[\u003cspan class=\"hljs-string\"\u003e'Close'\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003erolling\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e=short_window,\n                                                          min_periods=\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\n                                                          center=\u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003emean\u003c/span\u003e()\n    signals[\u003cspan class=\"hljs-string\"\u003e'long_mavg'\u003c/span\u003e] = ticker_ts_df[\u003cspan class=\"hljs-string\"\u003e'Close'\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003erolling\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e=long_window,\n                                                         min_periods=\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\n                                                         center=\u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003emean\u003c/span\u003e()\n    # \u003cspan class=\"hljs-title class_\"\u003eSMAs\u003c/span\u003e가 교차 되었을 때 신호 생성\n    signals[\u003cspan class=\"hljs-string\"\u003e'signal'\u003c/span\u003e] = np.\u003cspan class=\"hljs-title function_\"\u003ewhere\u003c/span\u003e(\n        signals[\u003cspan class=\"hljs-string\"\u003e'short_mavg'\u003c/span\u003e] \u003e signals[\u003cspan class=\"hljs-string\"\u003e'long_mavg'\u003c/span\u003e], \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\n    signals[\u003cspan class=\"hljs-string\"\u003e'orders'\u003c/span\u003e] = signals[\u003cspan class=\"hljs-string\"\u003e'signal'\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003ediff\u003c/span\u003e()\n    signals.\u003cspan class=\"hljs-property\"\u003eloc\u003c/span\u003e[signals[\u003cspan class=\"hljs-string\"\u003e'orders'\u003c/span\u003e] == \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'orders'\u003c/span\u003e] = \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e signals\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e필요한 함수를 생성하기 위한 단계를 살펴보겠습니다:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e단기 및 장기 이동평균 값 계산: 단기(빠른) 및 장기(느린) 단순 이동평균(SMA)을 계산하는 함수를 생성하세요.\u003c/li\u003e\n\u003cli\u003e거래 신호 생성: 단기와 장기 이동평균 값을 비교하여 매수 및 매도 신호를 생성하는 함수를 개발하세요.\u003c/li\u003e\n\u003cli\u003e시간에 따른 자본 계산: 생성된 신호를 기반으로 자본을 계산하는 유틸리티 함수를 구현하세요.\u003c/li\u003e\n\u003cli\u003e결과 시각화: 주식의 시계열 데이터와 진입 및 퇴출 신호를 함께 그리는 함수를 작성하세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edef \u003cspan class=\"hljs-title function_\"\u003eload_ticker_time_series\u003c/span\u003e(ticker, start_date, end_date):\n    \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\n    Yahoo Finance API에서 시간 시리즈 금융 데이터를 검색하고 캐시합니다.\n    매개변수:\n    - ticker (str): 주식 티커 심볼 (예: 애플의 경우 'AAPL').\n    - start_date (str): 데이터 검색을 위한 'YYYY-MM-DD' 형식의 시작 날짜.\n    - end_date (str): 데이터 검색을 위한 'YYYY-MM-DD' 형식의 종료 날짜.\n    반환값:\n    - df (pandas.DataFrame): 금융 시계열 데이터를 포함하는 DataFrame.\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    dir_path = \u003cspan class=\"hljs-string\"\u003e'./data'\u003c/span\u003e\n    cached_file_path = f\u003cspan class=\"hljs-string\"\u003e'{dir_path}/{ticker}_{start_date}_{end_date}.pkl'\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003etry\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e os.\u003cspan class=\"hljs-property\"\u003epath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eexists\u003c/span\u003e(cached_file_path):\n            df = pd.\u003cspan class=\"hljs-title function_\"\u003eread_pickle\u003c/span\u003e(cached_file_path)\n        \u003cspan class=\"hljs-attr\"\u003eelse\u003c/span\u003e:\n            df = yf.\u003cspan class=\"hljs-title function_\"\u003edownload\u003c/span\u003e(ticker, start=start_date, end=end_date)\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e not os.\u003cspan class=\"hljs-property\"\u003epath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eexists\u003c/span\u003e(dir_path):\n                os.\u003cspan class=\"hljs-title function_\"\u003emakedirs\u003c/span\u003e(dir_path)\n            df.\u003cspan class=\"hljs-title function_\"\u003eto_pickle\u003c/span\u003e(cached_file_path)\n    except \u003cspan class=\"hljs-title class_\"\u003eFileNotFoundError\u003c/span\u003e:\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\n            f\u003cspan class=\"hljs-string\"\u003e'주식: {ticker}에 대한 파일을 다운로드 및 캐시하는 중 오류가 발생했습니다.'\u003c/span\u003e)\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e df\n\ndef \u003cspan class=\"hljs-title function_\"\u003ecalculate_profit\u003c/span\u003e(signals, prices):\n    \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\n    거래 신호와 주식 가격을 기반으로 누적 수익을 계산합니다.\n    매개변수:\n    - signals (pandas.DataFrame): 거래 신호를 포함하는 DataFrame (매수: 1, 매도: -1).\n    - prices (pandas.Series): 신호 날짜에 해당하는 주식 가격을 포함하는 Series.\n    반환값:\n    - cum_profit (pandas.Series): 시간에 따른 누적 수익을 포함하는 Series.\n    \"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    profit = pd.\u003cspan class=\"hljs-title class_\"\u003eDataFrame\u003c/span\u003e(index=prices.\u003cspan class=\"hljs-property\"\u003eindex\u003c/span\u003e)\n    profit[\u003cspan class=\"hljs-string\"\u003e'profit'\u003c/span\u003e] = \u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e\n    buys = signals[signals[\u003cspan class=\"hljs-string\"\u003e'orders'\u003c/span\u003e] == \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e].\u003cspan class=\"hljs-property\"\u003eindex\u003c/span\u003e\n    sells = signals[signals[\u003cspan class=\"hljs-string\"\u003e'orders'\u003c/span\u003e] == -\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e].\u003cspan class=\"hljs-property\"\u003eindex\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e sells[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e] \u0026#x3C; buys[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]:\n        # 롱 포지션 전용 전략입니다. 판매로 시작할 수 없습니다.\n        sells = sells[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e:]\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(buys) == \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e or \u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(sells) == \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e:\n        # 아무 조치도 취하지 않았습니다.\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e profit\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(sells) \u0026#x3C; \u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(buys):\n        # 마지막에 판매하는 것으로 가정합니다.\n        sells = sells.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e(pd.\u003cspan class=\"hljs-title class_\"\u003eIndex\u003c/span\u003e(prices.\u003cspan class=\"hljs-title function_\"\u003etail\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e).\u003cspan class=\"hljs-property\"\u003eindex\u003c/span\u003e))\n    buy_prices = prices.\u003cspan class=\"hljs-property\"\u003eloc\u003c/span\u003e[buys]\n    sell_prices = prices.\u003cspan class=\"hljs-property\"\u003eloc\u003c/span\u003e[sells]\n    profit.\u003cspan class=\"hljs-property\"\u003eloc\u003c/span\u003e[sells, \u003cspan class=\"hljs-string\"\u003e'profit'\u003c/span\u003e] = sell_prices.\u003cspan class=\"hljs-property\"\u003evalues\u003c/span\u003e - buy_prices.\u003cspan class=\"hljs-property\"\u003evalues\u003c/span\u003e\n    profit[\u003cspan class=\"hljs-string\"\u003e'profit'\u003c/span\u003e] = profit[\u003cspan class=\"hljs-string\"\u003e'profit'\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003efillna\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\n    # 누적 수익 생성\n    profit[\u003cspan class=\"hljs-string\"\u003e'cum_profit'\u003c/span\u003e] = profit[\u003cspan class=\"hljs-string\"\u003e'profit'\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003ecumsum\u003c/span\u003e()\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e profit[\u003cspan class=\"hljs-string\"\u003e'cum_profit'\u003c/span\u003e]\n\ndef \u003cspan class=\"hljs-title function_\"\u003eplot_strategy\u003c/span\u003e(prices_df, signal_df, profit):\n    \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\n    매수 및 매도 신호 및 누적 수익을 포함하는 거래 전략을 시각화합니다.\n    매개변수:\n    - prices (pandas.Series): 주식 가격을 포함하는 Series.\n    - signals (pandas.DataFrame): 매수(1) 및 매도(-1) 신호를 포함하는 DataFrame.\n    - profit (pandas.Series): 시간에 따른 누적 수익을 포함하는 Series.\n    반환값:\n    - ax1 (matplotlib.axes.Axes): 주식 가격과 신호를 표시하는 상단 서브플롯.\n    - ax2 (matplotlib.axes.Axes): 누적 수익을 표시하는 하단 서브플롯.\n    \"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    fig, (ax1, ax2) = plt.\u003cspan class=\"hljs-title function_\"\u003esubplots\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, gridspec_kw={\u003cspan class=\"hljs-string\"\u003e'height_ratios'\u003c/span\u003e: (\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)},\n                                   figsize=(\u003cspan class=\"hljs-number\"\u003e18\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e))\n    ax1.\u003cspan class=\"hljs-title function_\"\u003eset_xlabel\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'날짜'\u003c/span\u003e)\n    ax1.\u003cspan class=\"hljs-title function_\"\u003eset_ylabel\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'달러 단위의 가격'\u003c/span\u003e)\n    ax1.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(prices_df.\u003cspan class=\"hljs-property\"\u003eindex\u003c/span\u003e, prices_df, color=\u003cspan class=\"hljs-string\"\u003e'g'\u003c/span\u003e, lw=\u003cspan class=\"hljs-number\"\u003e0.25\u003c/span\u003e)\n    # 매수 및 매도 신호를 플롯합니다.\n    ax1.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(signal_df.\u003cspan class=\"hljs-property\"\u003eloc\u003c/span\u003e[signal_df.\u003cspan class=\"hljs-property\"\u003eorders\u003c/span\u003e == \u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e].\u003cspan class=\"hljs-property\"\u003eindex\u003c/span\u003e,\n             prices_df[signal_df.\u003cspan class=\"hljs-property\"\u003eorders\u003c/span\u003e == \u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e],\n             \u003cspan class=\"hljs-string\"\u003e'^'\u003c/span\u003e, markersize=\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e, color=\u003cspan class=\"hljs-string\"\u003e'blue'\u003c/span\u003e, label=\u003cspan class=\"hljs-string\"\u003e'매수'\u003c/span\u003e)\n    ax1.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(signal_df.\u003cspan class=\"hljs-property\"\u003eloc\u003c/span\u003e[signal_df.\u003cspan class=\"hljs-property\"\u003eorders\u003c/span\u003e == -\u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e].\u003cspan class=\"hljs-property\"\u003eindex\u003c/span\u003e,\n             prices_df[signal_df.\u003cspan class=\"hljs-property\"\u003eorders\u003c/span\u003e == -\u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e],\n             \u003cspan class=\"hljs-string\"\u003e'v'\u003c/span\u003e, markersize=\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e, color=\u003cspan class=\"hljs-string\"\u003e'red'\u003c/span\u003e, label=\u003cspan class=\"hljs-string\"\u003e'매도'\u003c/span\u003e)\n    ax2.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(profit.\u003cspan class=\"hljs-property\"\u003eindex\u003c/span\u003e, profit, color=\u003cspan class=\"hljs-string\"\u003e'b'\u003c/span\u003e)\n    ax2.\u003cspan class=\"hljs-title function_\"\u003eset_ylabel\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'누적 수익 (%)'\u003c/span\u003e)\n    ax2.\u003cspan class=\"hljs-title function_\"\u003eset_xlabel\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'날짜'\u003c/span\u003e)\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e ax1, ax2\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e모두를 결합합시다\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eaapl_ts_df = \u003cspan class=\"hljs-title function_\"\u003eload_ticker_ts_df\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'AAPL'\u003c/span\u003e,\n                               start_date=\u003cspan class=\"hljs-string\"\u003e'2021-01-01'\u003c/span\u003e,\n                               end_date=\u003cspan class=\"hljs-string\"\u003e'2023-01-01'\u003c/span\u003e)\nsignal_df = \u003cspan class=\"hljs-title function_\"\u003edouble_simple_moving_average_signals\u003c/span\u003e(aapl_ts_df, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e30\u003c/span\u003e)\nprofit_series = \u003cspan class=\"hljs-title function_\"\u003ecalculate_profit\u003c/span\u003e(signal_df, aapl_ts_df[\u003cspan class=\"hljs-string\"\u003e\"Adj Close\"\u003c/span\u003e])\nax1, ax2 = \u003cspan class=\"hljs-title function_\"\u003eplot_strategy\u003c/span\u003e(aapl_ts_df[\u003cspan class=\"hljs-string\"\u003e\"Adj Close\"\u003c/span\u003e], signal_df, profit_series)\n\n# 단기 및 장기 이동평균 추가\nax1.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(signal_df.\u003cspan class=\"hljs-property\"\u003eindex\u003c/span\u003e, signal_df[\u003cspan class=\"hljs-string\"\u003e'short_mavg'\u003c/span\u003e],\n         linestyle=\u003cspan class=\"hljs-string\"\u003e'--'\u003c/span\u003e, label=\u003cspan class=\"hljs-string\"\u003e'빠른 SMA'\u003c/span\u003e)\nax1.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(signal_df.\u003cspan class=\"hljs-property\"\u003eindex\u003c/span\u003e, signal_df[\u003cspan class=\"hljs-string\"\u003e'long_mavg'\u003c/span\u003e],\n         linestyle=\u003cspan class=\"hljs-string\"\u003e'--'\u003c/span\u003e, label=\u003cspan class=\"hljs-string\"\u003e'느린 SMA'\u003c/span\u003e)\nax1.\u003cspan class=\"hljs-title function_\"\u003elegend\u003c/span\u003e(loc=\u003cspan class=\"hljs-string\"\u003e'upper left'\u003c/span\u003e, fontsize=\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003eshow\u003c/span\u003e()\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-13-BuildingAMomentumandReversionTradingStrategyWithPython_0.png\" alt=\"Strategy\"\u003e\u003c/p\u003e\n\u003cp\u003e지난 2년 동안 이 전략은 30%의 수익을 창출했습니다. 최근 S\u0026#x26;P 500의 10%의 수익과 비교했을 때, 강력한 전략으로 보입니다.\u003c/p\u003e\n\u003ch2\u003e단순 관성 전략\u003c/h2\u003e\n\u003cp\u003e이 전략은 가격 상승 또는 하락의 빈도에 기초합니다. 연속된 일정 기간 동안 가격이 지속적으로 상승하면 매수 기회를, 하락하면 매도 기회로 간주합니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이전에 논의 된 간단한 이동 평균 (SMA) 전략에서 일부 유틸리티 함수를 재사용할 것입니다.\u003c/p\u003e\n\u003cp\u003e다음은이 전략의 기본 버전을 구현하는 코드입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edef \u003cspan class=\"hljs-title function_\"\u003enaive_momentum_signals\u003c/span\u003e(ticker_ts_df, nb_conseq_days=\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e):\n    \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\n    연이은 양수 또는 음수 가격 변동에 기반한 소박한 모멘텀 트레이딩 신호를 생성합니다.\n    매개변수:\n    - ticker_ts_df (pandas.DataFrame): 과거 주식 데이터가 포함 된 DataFrame입니다.\n    - nb_conseq_days (int): 신호를 트리거 할 연속적 양수 또는 음수 일수입니다.\n    반환 값:\n    - signals (pandas.DataFrame): 구매 (1) 및 판매 (-1) 신호가 포함 된 'orders' 열이있는 DataFrame입니다.\n    \"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    signals = pd.\u003cspan class=\"hljs-title class_\"\u003eDataFrame\u003c/span\u003e(index=ticker_ts_df.\u003cspan class=\"hljs-property\"\u003eindex\u003c/span\u003e)\n    signals[\u003cspan class=\"hljs-string\"\u003e'orders'\u003c/span\u003e] = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n\n    price = ticker_ts_df[\u003cspan class=\"hljs-string\"\u003e'Adj Close'\u003c/span\u003e]\n    price_diff = price.\u003cspan class=\"hljs-title function_\"\u003ediff\u003c/span\u003e()\n    signal = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n    cons_day = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(ticker_ts_df)):\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e price_diff[i] \u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e:\n            cons_day = cons_day + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e price_diff[i] \u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e cons_day == nb_conseq_days and signal != \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e:\n                signals[\u003cspan class=\"hljs-string\"\u003e'orders'\u003c/span\u003e].\u003cspan class=\"hljs-property\"\u003eiloc\u003c/span\u003e[i] = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n                signal = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n        elif price_diff[i] \u0026#x3C; \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e:\n            cons_day = cons_day - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e price_diff[i] \u0026#x3C; \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e cons_day == -nb_conseq_days and signal != -\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e:\n                signals[\u003cspan class=\"hljs-string\"\u003e'orders'\u003c/span\u003e].\u003cspan class=\"hljs-property\"\u003eiloc\u003c/span\u003e[i] = -\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n                signal = -\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e signals\n\nsignal_df = \u003cspan class=\"hljs-title function_\"\u003enaive_momentum_signals\u003c/span\u003e(aapl_ts_df)\nprofit_series = \u003cspan class=\"hljs-title function_\"\u003ecalculate_profit\u003c/span\u003e(signal_df, aapl_ts_df[\u003cspan class=\"hljs-string\"\u003e\"Adj Close\"\u003c/span\u003e])\nax1, _ = \u003cspan class=\"hljs-title function_\"\u003eplot_strategy\u003c/span\u003e(aapl_ts_df[\u003cspan class=\"hljs-string\"\u003e\"Adj Close\"\u003c/span\u003e], signal_df, profit_series)\nax1.\u003cspan class=\"hljs-title function_\"\u003elegend\u003c/span\u003e(loc=\u003cspan class=\"hljs-string\"\u003e'upper left'\u003c/span\u003e, fontsize=\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003eshow\u003c/span\u003e()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-13-BuildingAMomentumandReversionTradingStrategyWithPython_1.png\"\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e안타깝지만, 이 전략은 수익을 창출하지 않았고 수익을 얻지 못했습니다.\u003c/p\u003e\n\u003cp\u003e그러나 모델을 단순히 반전시킴으로써 더 나은 성과를 거둘 수도 있었을 것입니다 (이 기법은 WallStreetBets의 주식 분석에 많이 제안된 방법 중 하나입니다). 이를 위해 거래 신호를 -1로 곱하면 됩니다. 이 반전 접근법은 전략의 원래 신호가 효과적이지 않을 때 일반적으로 효과적입니다.\u003c/p\u003e\n\u003cp\u003e솔직히 말해서, 이 전략은 일반적으로 개별 상품이 아닌 더 넓은 시장에 적용되며 더 짧은 시간대에 구현됩니다.\u003c/p\u003e\n\u003ch1\u003e회귀 전략\u003c/h1\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e예를 들어, 일론 머스크가 테슬라에 블록체인을 통합할 것이라는 트윗을 올리면, 테슬라 주식에 과도한 매수 열풍이 불고 있을 것입니다. 그러나 다음 날에는 투자자들이 아무런 근본적인 변화가 없다는 것을 깨닫고 시장이 관심을 잃으면, 가격은 더 합리적인 수준으로 회귀할 것입니다.\u003c/p\u003e\n\u003cp\u003e따라서 어떤 상품이나 도구가 어느 방향으로든 표준 지수에서 너무 빠르게 벗어날 경우, 결국 오랜 기간에 걸쳐 표준 지수로 돌아가게 될 것입니다.\u003c/p\u003e\n\u003cp\u003e트렌드와 모멘텀 전략과 유사하게, 회귀 전략은 시장 역학을 간소화하고 시장 참가자들이 일반적으로 사용하는 전략입니다.\u003c/p\u003e\n\u003ch1\u003e평균 회귀\u003c/h1\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e평균 회귀 전략에서는 주식 가격이 시간이 지남에 따라 평균값 또는 평균값에 가까워질 것이라는 가정 하에 운영합니다.\u003c/p\u003e\n\u003cp\u003e아래는 이 전략을 구현하는 신호 코드입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edef \u003cspan class=\"hljs-title function_\"\u003emean_reversion_signals\u003c/span\u003e(ticker_ts_df, entry_threshold=\u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e, exit_threshold=\u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e):\n    \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\n    이동 평균과 임계값을 기반으로 한 평균 회귀 트레이딩 신호 생성.\n    매개변수:\n    - ticker_ts_df (pandas.DataFrame): 주식의 역사적 데이터가 포함된 DataFrame.\n    - entry_threshold (float): 표준 편차의 배수로 표시된 진입 임계값.\n    - exit_threshold (float): 표준 편차의 배수로 표시된 종료 임계값.\n    반환:\n    - signals (pandas.DataFrame): 'orders' 열을 포함한 Buy(1) 및 Sell(-1) 신호가 포함된 DataFrame.\n    \"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    signals = pd.\u003cspan class=\"hljs-title class_\"\u003eDataFrame\u003c/span\u003e(index=ticker_ts_df.\u003cspan class=\"hljs-property\"\u003eindex\u003c/span\u003e)\n    signals[\u003cspan class=\"hljs-string\"\u003e'mean'\u003c/span\u003e] = ticker_ts_df[\u003cspan class=\"hljs-string\"\u003e'Adj Close'\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003erolling\u003c/span\u003e(\n        \u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e=\u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003emean\u003c/span\u003e()  # 필요한대로 창 크기 조정\n    signals[\u003cspan class=\"hljs-string\"\u003e'std'\u003c/span\u003e] = ticker_ts_df[\u003cspan class=\"hljs-string\"\u003e'Adj Close'\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003erolling\u003c/span\u003e(\n        \u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e=\u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003estd\u003c/span\u003e()  # 필요한대로 창 크기 조정\n    signals[\u003cspan class=\"hljs-string\"\u003e'signal'\u003c/span\u003e] = np.\u003cspan class=\"hljs-title function_\"\u003ewhere\u003c/span\u003e(ticker_ts_df[\u003cspan class=\"hljs-string\"\u003e'Adj Close'\u003c/span\u003e] \u003e (\n        signals[\u003cspan class=\"hljs-string\"\u003e'mean'\u003c/span\u003e] + entry_threshold * signals[\u003cspan class=\"hljs-string\"\u003e'std'\u003c/span\u003e]), \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\n    signals[\u003cspan class=\"hljs-string\"\u003e'signal'\u003c/span\u003e] = np.\u003cspan class=\"hljs-title function_\"\u003ewhere\u003c/span\u003e(ticker_ts_df[\u003cspan class=\"hljs-string\"\u003e'Adj Close'\u003c/span\u003e] \u0026#x3C; (\n        signals[\u003cspan class=\"hljs-string\"\u003e'mean'\u003c/span\u003e] - exit_threshold * signals[\u003cspan class=\"hljs-string\"\u003e'std'\u003c/span\u003e]), -\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\n    signals[\u003cspan class=\"hljs-string\"\u003e'orders'\u003c/span\u003e] = signals[\u003cspan class=\"hljs-string\"\u003e'signal'\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003ediff\u003c/span\u003e()\n    signals.\u003cspan class=\"hljs-property\"\u003eloc\u003c/span\u003e[signals[\u003cspan class=\"hljs-string\"\u003e'orders'\u003c/span\u003e] == \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'orders'\u003c/span\u003e] = \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e\n\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e signals\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 함수에서는 주식 가격 데이터의 표준 편차와 평균을 결정합니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e가격이 평균에서 일정 표준 편차 수로 벗어날 때 신호가 생성됩니다.\u003c/p\u003e\n\u003cp\u003e이전에 만든 함수를 사용하여 함께 테스트해보겠습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003esignal_df = \u003cspan class=\"hljs-title function_\"\u003emean_reversion_signals\u003c/span\u003e(aapl_ts_df)\nprofit_series = \u003cspan class=\"hljs-title function_\"\u003ecalculate_profit\u003c/span\u003e(signal_df, aapl_ts_df[\u003cspan class=\"hljs-string\"\u003e\"Adj Close\"\u003c/span\u003e])\nax1, _ = \u003cspan class=\"hljs-title function_\"\u003eplot_strategy\u003c/span\u003e(aapl_ts_df[\u003cspan class=\"hljs-string\"\u003e\"Adj Close\"\u003c/span\u003e], signal_df, profit_series)\n\nax1.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(signal_df.\u003cspan class=\"hljs-property\"\u003eindex\u003c/span\u003e, signal_df[\u003cspan class=\"hljs-string\"\u003e'mean'\u003c/span\u003e], linestyle=\u003cspan class=\"hljs-string\"\u003e'--'\u003c/span\u003e, label=\u003cspan class=\"hljs-string\"\u003e\"평균\"\u003c/span\u003e)\nax1.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(signal_df.\u003cspan class=\"hljs-property\"\u003eindex\u003c/span\u003e, signal_df[\u003cspan class=\"hljs-string\"\u003e'mean'\u003c/span\u003e] +\n         signal_df[\u003cspan class=\"hljs-string\"\u003e'std'\u003c/span\u003e], linestyle=\u003cspan class=\"hljs-string\"\u003e'--'\u003c/span\u003e, label=\u003cspan class=\"hljs-string\"\u003e\"상한 표준편차\"\u003c/span\u003e)\nax1.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(signal_df.\u003cspan class=\"hljs-property\"\u003eindex\u003c/span\u003e, signal_df[\u003cspan class=\"hljs-string\"\u003e'mean'\u003c/span\u003e] -\n         signal_df[\u003cspan class=\"hljs-string\"\u003e'std'\u003c/span\u003e], linestyle=\u003cspan class=\"hljs-string\"\u003e'--'\u003c/span\u003e, label=\u003cspan class=\"hljs-string\"\u003e\"하한 표준편차\"\u003c/span\u003e)\nax1.\u003cspan class=\"hljs-title function_\"\u003elegend\u003c/span\u003e(loc=\u003cspan class=\"hljs-string\"\u003e'upper left'\u003c/span\u003e, fontsize=\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003eshow\u003c/span\u003e()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-13-BuildingAMomentumandReversionTradingStrategyWithPython_2.png\"\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e종이 상으로 10%의 수익률은 만족스럽게 보일 수 있지만, 실제로는 넓은 S\u0026#x26;P 500 지수 펀드에 투자함으로써 유사한 결과를 달성할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e앞으로의 글에서는 Pair-Trading과 통계적 화폐 섹터에 속한 보다 정교한 형태의 복귀 전략을 탐구할 것입니다. 또한 전략 지표인 Sharpe 비율과 같은 전략 평가를 돕는 지표들을 살펴볼 것입니다. 이 분석을 통해 우리는 S\u0026#x26;P 500 지수의 수익률에 맞게 하는 이 전략이 왜 약한 것으로 여겨지는지를 이해할 수 있을 것입니다.\u003c/p\u003e\n\u003cp\u003e저의 추천 링크를 통해 Tradingview 구독비를 최대 100% 할인받을 수 있습니다. 해당 링크에 접속하면 페이지 상단 왼쪽에 있는 Tradingview 아이콘을 클릭하여 원하는 무료 요금제로 이동하세요.\u003c/p\u003e\n\u003cp\u003e➡️여기에서 제 구독하기 ➡️ \u003ca href=\"https://medium.com/@aamurtazin/subscribe\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://medium.com/@aamurtazin/subscribe\u003c/a\u003e\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e내가 곧 올릴 블로그에서 많은 내용을 공유할 거야.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-07-13-BuildingAMomentumandReversionTradingStrategyWithPython"},"buildId":"olPs1cVezSGTqD7OaewDI","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>