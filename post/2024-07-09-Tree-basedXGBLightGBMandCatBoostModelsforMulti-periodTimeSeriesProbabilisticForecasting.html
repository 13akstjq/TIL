<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>여러 기간의 시계열 확률 예측을 위한 XGB, LightGBM, CatBoost 모델 비교 분석 | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="여러 기간의 시계열 확률 예측을 위한 XGB, LightGBM, CatBoost 모델 비교 분석 | TIL" data-gatsby-head="true"/><meta property="og:title" content="여러 기간의 시계열 확률 예측을 위한 XGB, LightGBM, CatBoost 모델 비교 분석 | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting" data-gatsby-head="true"/><meta name="twitter:title" content="여러 기간의 시계열 확률 예측을 위한 XGB, LightGBM, CatBoost 모델 비교 분석 | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2024-07-09 19:34" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/TIL/_next/static/chunks/463-925361deb4cec4b1.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/post/%5Bslug%5D-9d7ebbd29b9e08ce.js" defer=""></script><script src="/TIL/_next/static/xwOwpfNxF5xANgUpiyc2H/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/xwOwpfNxF5xANgUpiyc2H/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">여러 기간의 시계열 확률 예측을 위한 XGB, LightGBM, CatBoost 모델 비교 분석</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="여러 기간의 시계열 확률 예측을 위한 XGB, LightGBM, CatBoost 모델 비교 분석" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jul 9, 2024</span><span class="posts_reading_time__f7YPP">26<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_0.png" alt="Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting"></p>
<p>Sample eBook chapters (free): <a href="https://github.com/dataman-git/modern-time-series/blob/main/20240522beauty_TOC.pdf" rel="nofollow" target="_blank">https://github.com/dataman-git/modern-time-series/blob/main/20240522beauty_TOC.pdf</a></p>
<p>eBook on Teachable.com: $22.50 <a href="https://drdataman.teachable.com/p/home" rel="nofollow" target="_blank">https://drdataman.teachable.com/p/home</a></p>
<p>The print edition on Amazon.com: $65 <a href="https://a.co/d/25FVsMx" rel="nofollow" target="_blank">https://a.co/d/25FVsMx</a></p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>위의 텍스트를 친근하게 번역하면 아래와 같습니다.</p>
<p>챕터 제목은 "확률 예측", "다기간", "트리 기반" 세 가지 중요한 개념을 다룹니다. 첫 번째로 "확률 예측"이 있습니다. 많은 실세계 응용 프로그램에서는 자원 계획이나 이상 징후 감지를 위해 예측 구간을 요청하며, 이는 1장에서 언급한 것과 같습니다. 이 책의 Part 2에서 언급한 네 가지 해결책 중 하나는 분위수 회귀입니다. 분위 예측은 예측 값을 매우 가능성이 높은 50 번째 백분위 값이거나 상위 90 번째 백분위 값과 같이 매우 낮은 가능성을 보여줍니다 (A) 그림에서 확인할 수 있습니다.</p>
<img src="/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_1.png">
<p>제목에서 두 번째 개념은 다기간 예측입니다. 우리는 일일 예측이 아닌 여러 기간을 위한 예측이 필요한 경우가 많습니다. 한 주간 휴가를 계획할 때, 한 날이 아닌 5일간의 날씨 예보가 필요합니다. 그러나 선형 회귀 또는 트리 기반 알고리즘은 일반적으로 점 추정만 제공합니다. 이러한 경우 어떻게 예측 프로세스를 설계하여 다기간을 제공할 수 있을까요? 직관적으로, 다음 기간을 예측하면 동일한 모델의 입력으로 사용하여 다다음 기간을 예측할 수도 있지 않을까요? 이 해결책은 인기가 있으며 (B) 그림에서 보이는 것과 같이 재귀적 예측 전략이라고 합니다. 재귀적 예측 전략은 모델의 예측을 후속 예측의 입력으로 사용합니다. 전략은 모델이 1 단계 앞으로 예측하기 위해 yt에서 yt-k까지의 과거 값을 사용합니다. 그런 다음 yt+1을 통합하고 다른 입력을 업데이트하여 yt+2를 예측합니다. 이 프로세스를 반복하여 모든 후속 시간 단계를 예측합니다. Darts 라이브러리에서도 이 전략을 할당할 수 있습니다.</p>
<img src="/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_2.png">
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>새로운 시각으로 생각해보는 건 어때요? n 기간을 예측하는 것이 목표인 경우, 왜 n 개의 모델을 따로 구축하지 않을까요? 각 모델은 각각의 다음 n 기간을 예측할 것입니다. 이는 직접 예측 전략이라고 불립니다. Darts 라이브러리의 기본 전략이며, 라이브러리에 포함된 모든 모델에 대해 적용됩니다.</p>
<p><img src="/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_3.png" alt="이미지"></p>
<p>마지막으로, 장 제목에 있는 "tree-based"에 대해 논의해보겠습니다. Tree-based 알고리즘들은 지도 학습 알고리즘입니다. 샘플을 행으로, 피처를 열로 갖는 데이터 프레임이 필요합니다. 단변량 시계열 데이터를 데이터 프레임으로 어떻게 변환할까요? 기본 아이디어는 단변량 시계열 데이터에서 샘플을 생성하는 것입니다. 이렇게 함으로써, 모델링을 위해 단변량 시계열 데이터를 데이터 프레임으로 재구성하고, 원하는 경우 단변량 시계열 데이터에서 피처를 생성할 수도 있습니다.</p>
<p>이번 장에서는 세 가지 tree-based 모델인 XGBoost (2016), LightGBM (2017), CatBoost (2018)에 대해 세 부분으로 소개하고, 각 알고리즘에 대해 간단히 설명할 것입니다. 세 모델 간의 차이점에 대해 궁금하다면, Figure (C)에 각 세 그래디언트 부스팅 기반 알고리즘의 특징을 강조한 표를 만들었습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_4.png" alt="image"></p>
<p>이번 장에서는 Darts 라이브러리를 사용할 것입니다. 시계열 모델링은 많은 기능과 데이터를 저장해야 하므로 Darts 라이브러리는 자체 데이터 형식을 갖추고 있습니다. 시간 순서에 풍부한 정보를 담을 수 있는 다양한 데이터 형식의 장점을 설명하기 위해 본 책은 '10장: 시계열 데이터 형식 쉽게 만들기'를 별도로 마련했습니다. 마지막으로, 이 장은 '11장: 다기간 확률 예측을 위한 자기회귀 선형 회귀'와 함께 읽을 수 있습니다. 두 장은 프로젝트에 적합한 모델을 선택하기 위해 선형 회귀 및 트리 기반 모델을 구축하는 데 도움이 됩니다.</p>
<p>이 장의 구조는 다음과 같습니다:</p>
<ul>
<li>필요한 소프트웨어 요구 사항</li>
<li>판다스 데이터를 Darts 데이터 형식으로 변환하는 방법</li>
<li>XGB</li>
<li>LightGBM</li>
<li>CatBoost</li>
</ul>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>파이썬 노트북은 이 Github 링크를 통해 다운로드할 수 있어요.</p>
<p>소프트웨어 요구 사항</p>
<p>기본 Darts 패키지는 Prophet, CatBoost, 그리고 LightGBM 종속성을 설치하지 않습니다. 0.25.0 버전을 기준으로 해서요. 직접 Prophet, CatBoost, 그리고 LightGBM 패키지를 설치해야 해요.</p>
<ul>
<li>CatBoostModel: CatBoost 설치 가이드를 사용하여 catboost 패키지(버전 1.0.6 이상)를 설치합니다.</li>
<li>LightGBMModel: LightGBM 설치 가이드를 사용하여 lightgbm 패키지(버전 3.2.0 이상)를 설치합니다.</li>
</ul>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">!pip install pandas numpy matplotlib darts lightgbm catboost
</code></pre>
<p>다음으로, 동일한 Walmart 매장 판매 데이터를 로드할 것입니다.</p>
<p>데이터</p>
<p>저는 Kaggle.com에 있는 Walmart 데이터셋을 사용할 것입니다. 이 데이터셋은 2010년 2월 5일부터 2012년 11월 1일까지의 주간 매장 매출 정보를 포함하고 있습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>Date - 판매 주차</li>
<li>Store - 상점 번호</li>
<li>주간 매출 - 상점의 매출</li>
<li>휴일 플래그 - 주가 특별 휴일 주인지 여부 1 - 휴일 주 0 - 비 휴일 주</li>
<li>온도 - 판매일 온도</li>
<li>연료 가격 - 지역의 연료 비용</li>
</ul>
<p>소매 판매에 영향을 미칠 수있는 두 가지 거시경제 지표 : 소비자 물가지수와 실업률. 데이터 세트는 Pandas 데이터 프레임으로로드됩니다.</p>
<pre><code class="hljs language-js">%matplotlib inline
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt

# <span class="hljs-title class_">Google</span> <span class="hljs-title class_">Colab</span>
<span class="hljs-keyword">from</span> google.<span class="hljs-property">colab</span> <span class="hljs-keyword">import</span> drive
drive.<span class="hljs-title function_">mount</span>(<span class="hljs-string">'/content/gdrive'</span>)
path = <span class="hljs-string">'/content/gdrive/My Drive/data/time_series'</span>
# <span class="hljs-attr">https</span>:<span class="hljs-comment">//www.kaggle.com/datasets/yasserh/walmart-dataset</span>

# 데이터 로드
data = pd.<span class="hljs-title function_">read_csv</span>(path + <span class="hljs-string">'/walmart.csv'</span>, delimiter=<span class="hljs-string">","</span>)
data[<span class="hljs-string">'ds'</span>] = pd.<span class="hljs-title function_">to_datetime</span>(data[<span class="hljs-string">'Date'</span>], format=<span class="hljs-string">'%d-%m-%Y'</span>)
data.<span class="hljs-property">index</span> = data[<span class="hljs-string">'ds'</span>]
data = data.<span class="hljs-title function_">drop</span>(<span class="hljs-string">'Date'</span>, axis=<span class="hljs-number">1</span>)
data.<span class="hljs-title function_">head</span>()
</code></pre>
<img src="/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_5.png">
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>제 10 장에서 쉽게 만들어진 Darts의 시계열 데이터 형식에 대해 배웠어요. Darts의 주요 데이터 클래스는 "TimeSeries" 클래스입니다. Darts는 값들을 다음과 같은 배열 모양으로 저장해요 (시간, 차원, 샘플):</p>
<ul>
<li>시간: 위 예시에서처럼 143 주와 같은 시간 인덱스</li>
<li>차원: 다변량 시계열의 "열"</li>
<li>샘플: 기간에 대한 값들. 10 번째, 50 번째 백분위수와 90 번째 백분위수에 대한 그림 (A)에서처럼 확률론적 예측이라면 3개의 샘플이 있을 거예요.</li>
</ul>
<p>저희는 월마트 매장 판매량을 불러오기 위해 .from_group_dataframe() 함수를 사용할 거예요. 그룹 ID는 "Store"예요. 따라서 group_cols 매개변수는 "Store"가 될 거예요. 시간 인덱스는 "ds" 열이에요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">from</span> darts <span class="hljs-keyword">import</span> <span class="hljs-title class_">TimeSeries</span>
darts_group_df = <span class="hljs-title class_">TimeSeries</span>.<span class="hljs-title function_">from_group_dataframe</span>(data, group_cols=<span class="hljs-string">'Store'</span>, time_col=<span class="hljs-string">'ds'</span>)
<span class="hljs-title function_">print</span>(<span class="hljs-string">"그룹/매장의 수는:"</span>, <span class="hljs-title function_">len</span>(darts_group_df))
<span class="hljs-title function_">print</span>(<span class="hljs-string">"시간 기간의 수는: "</span>, <span class="hljs-title function_">len</span>(darts_group_df[<span class="hljs-number">0</span>]))
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>그룹/상점 수: 45</li>
<li>기간 수: 143</li>
</ul>
<p>다음과 같이 컬럼을 나열할 수 있습니다. components 함수를 사용해봅시다:</p>
<pre><code class="hljs language-js">darts_group_df[<span class="hljs-number">0</span>].<span class="hljs-property">components</span>;
</code></pre>
<p>Index(['Weekly_Sales', 'Holiday_Flag', 'Temperature', 'Fuel_Price', 'CPI', 'Unemployment'], dtype='object', name='component')</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Store 1 매출 모델을 구축하기 위해 Store 1 데이터만 사용할 겁니다. "darts_group_df[0]"에 해당합니다. 이를 훈련 데이터와 테스트 데이터로 나눌 겁니다.</p>
<pre><code class="hljs language-js">store1 = darts_group_df[<span class="hljs-number">0</span>]
train = store1[:<span class="hljs-number">130</span>]
test = store1[<span class="hljs-number">130</span>:]
<span class="hljs-title function_">len</span>(train), <span class="hljs-title function_">len</span>(test) # (<span class="hljs-number">130</span>, <span class="hljs-number">13</span>)
</code></pre>
<p>우리의 목표 시리즈는 "Weekly_Sales"입니다. 다른 공선변수를 포함할 수도 있습니다. 시계열에서는 과거 공선변수와 미래 공선변수 두 종류가 있습니다. Darts 라이브러리는 동일한 용어를 사용합니다. 과거 공선변수는 연구 현재 시간까지의 변수입니다. 미래 공선변수는 미래에 관측 가능한 변수입니다. 미래 값을 어떻게 알 수 있는지 궁금할 수도 있습니다. 첫 번째 이유는 미래 휴일과 같이 결정론적 값이기 때문입니다. 두 번째 이유는 날씨 예측과 같은 다른 소스에서 예측된 값이기 때문입니다. 우리의 경우 "Fuel_price"와 "CPI"를 과거 공선변수로, "Holiday_flag"를 미래 공선변수로 포함할 것입니다. 훈련 데이터에서의 목표와 과거 공선변수는 130개의 데이터 포인트가 있습니다. 하지만 미래 공선변수는 실제로 미래까지 확장되어 143개의 데이터 포인트를 갖습니다.</p>
<pre><code class="hljs language-js">target = train[<span class="hljs-string">'Weekly_Sales'</span>]
past_cov = train[[<span class="hljs-string">'Fuel_Price'</span>,<span class="hljs-string">'CPI'</span>]]
future_cov = store1[<span class="hljs-string">'Holiday_Flag'</span>][:<span class="hljs-number">143</span>]
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>우니바리에이트 데이터부터 시작해보겠습니다.</p>
<p>XGB</p>
<p>XGBoost (Extreme Gradient Boosting)은 분류 및 회귀와 같은 지도 학습 작업에 널리 사용되며 효율성, 확장성 및 정확도로 알려져 있습니다. 가장 주목할 만한 기능은 오버피팅을 방지하기 위해 L1 및 L2 규제 기술이 포함되어 있다는 점입니다. 규제 패널티는 트리의 가중치, 리프 노드 값, 특성 중요도 점수에 적용되어 일반화 성능을 향상시키는 데 도움을 줍니다. 또 다른 기능으로는 병렬 및 분산 컴퓨팅을 지원하며 멀티코어 CPU 및 Apache Spark 및 Dask와 같은 분산 컴퓨팅 프레임워크에서 효율적인 학습이 가능합니다. 이 확장성은 대규모 데이터 처리에 적합하게 만듭니다. 그 외에도 이전 모델이 실수한 오류를 수정하기 위해 각 트리가 순차적으로 훈련되는 경사 부스팅 프레임워크를 계승했습니다. 전체적인 목표는 특정 손실 함수를 최소화하는 것입니다.</p>
<p>다음 코드는 Darts의 표준 모델링 구문입니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-keyword">from</span> darts.<span class="hljs-property">models</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">XGBModel</span>
n = <span class="hljs-number">12</span>
chunk_length = n
model = <span class="hljs-title class_">XGBModel</span>(
    lags=<span class="hljs-number">12</span>,
    lags_past_covariates=<span class="hljs-number">12</span>,
    lags_future_covariates=[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],
    output_chunk_length=<span class="hljs-number">12</span>,
    <span class="hljs-title class_">Multi</span>_models = <span class="hljs-title class_">True</span> # optional
    verbose=-<span class="hljs-number">1</span>
)
model.<span class="hljs-title function_">fit</span>(target, past_covariates=past_cov, future_covariates=future_cov)
pred = model.<span class="hljs-title function_">predict</span>(n)
pred
</code></pre>
<p>fit() 함수의 "target"은 모델링을 위한 대상 시리즈입니다. 모델은 yt, yt-1, yt-2, ..., yt-12까지의 지연된 값들에 대한 "lags"를 필요로 합니다. 또한 다른 공변량을 지정할 수도 있습니다. 시계열 모델링에서 과거 공변량과 미래 공변량이라는 두 가지 넓은 유형의 공변량이 있습니다. Darts는 이 규칙을 따릅니다. lags_past_covariates는 xt, xt-1, ..., xt-12와 같이 지연된 과거 공변량을 나타냅니다. 약간 혼동스러운 lags_future_covariates 이름은 미래 공변량을 의미합니다. "미래 공변량"은 미래 시간 단계에서의 이러한 공변량의 값들을 의미하며, "지연된" 값들은 이전 시간 단계에서의 미래 공변량을 의미합니다. 이는 미래 t + n 단계에 대해 모델이 t부터 t + (n-1)까지의 공변량의 값을 고려한다는 것을 의미합니다.</p>
<p>multi_models 매개변수가 True로 설정된 것에 주목해주세요. 이는 모델에게 다중 기간 예측을 위한 직접 예측 전략 또는 재귀적 예측 전략을 사용할지 알려줍니다. 기본값은 True이며, 이는 직접 예측 전략을 사용한다는 것을 의미합니다.</p>
<p>입력 청크 길이와 출력 청크 길이에 관한 한 가지 추가적인 매개변수가 있습니다. 이는 단변량 시리즈에서 샘플을 생성하는 것과 관련이 있습니다. 그림 (F)는 y0에서 y15까지의 시리즈에서 생성된 샘플을 보여줍니다. 각 샘플에는 입력 청크와 출력 청크가 포함되어 있습니다. 입력 청크 길이가 5이고 출력 청크 길이가 2인 것을 가정해보세요. 첫 번째 샘플은 입력 청크로 y0 - y4를, 출력 청크로 y5, y6를 가지고 있습니다. 창이 시리즈를 따라 이동하여 샘플을 만들며, 이를 시리즈의 끝까지 반복합니다. 출력 청크 길이는 예측할 수 있는 가장 긴 길이를 정의합니다. 이를 12로 지정했습니다. 12 이상을 예측하려고 하면 오류 메시지가 출력됩니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_6.png" alt="Dart data array"></p>
<p>The outputs are stored in the Dart data array:</p>
<p><img src="/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_7.png" alt="Dart data array"></p>
<p>We will plot the actual and the predicted values. We make this in a function for repeating use.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">plotit</span>():
  <span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
  target.plot(label=<span class="hljs-string">'train'</span>)
  pred.plot(label=<span class="hljs-string">'prediction'</span>)
  test[<span class="hljs-string">'Weekly_Sales'</span>][:n].plot(label=<span class="hljs-string">'actual'</span>)

  <span class="hljs-keyword">from</span> darts.metrics.metrics <span class="hljs-keyword">import</span> mae, mape
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Mean Absolute Error:"</span>, mae(test[<span class="hljs-string">'Weekly_Sales'</span>][:n], pred))
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Mean Absolute Percentage Error"</span>, mape(test[<span class="hljs-string">'Weekly_Sales'</span>][:n], pred))

plotit()
</code></pre>
<p>MAPE 값은 10.55% 입니다.</p>
<p><img src="/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_8.png" alt="이미지"></p>
<p>이제 분위수 예측을 추가해보겠습니다. 모델에게 5개의 분위수를 생성해 달라고 요청하겠습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-keyword">from</span> darts.<span class="hljs-property">models</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">XGBModel</span>
n = <span class="hljs-number">12</span>
chunk_length = n
model = <span class="hljs-title class_">XGBModel</span>(
    lags=<span class="hljs-number">12</span>,
    lags_past_covariates=<span class="hljs-number">12</span>,
    lags_future_covariates=[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>],
    output_chunk_length=chunk_length,
    likelihood = <span class="hljs-string">'quantile'</span>, # <span class="hljs-string">'quantile'</span> 또는 <span class="hljs-string">'poisson'</span>으로 설정 가능합니다.
    # <span class="hljs-string">'quantile'</span>로 설정하면 sklearn.<span class="hljs-property">linear_model</span>.<span class="hljs-property">QuantileRegressor</span>가 사용됩니다.
    # <span class="hljs-string">'poisson'</span>으로 설정하면 sklearn.<span class="hljs-property">linear_model</span>.<span class="hljs-property">PoissonRegressor</span>가 사용됩니다.
    quantiles=[<span class="hljs-number">0.01</span>, <span class="hljs-number">0.05</span>, <span class="hljs-number">0.50</span>, <span class="hljs-number">0.95</span>, <span class="hljs-number">0.99</span>]
)
model.<span class="hljs-title function_">fit</span>(target, past_covariates=past_cov, future_covariates=future_cov)
pred = model.<span class="hljs-title function_">predict</span>(n, num_samples=<span class="hljs-number">5</span>)
pred
</code></pre>
<p>각 예측에는 5개의 샘플이 있습니다. 이는 5개의 분위 수치 값을 생성했기 때문입니다.</p>
<p><img src="/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_9.png" alt=""></p>
<p>실제 값과 분위 예측을 시각화할 수 있습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">def <span class="hljs-title function_">plotQuantile</span>():
    <span class="hljs-keyword">import</span> matplotlib.<span class="hljs-property">pyplot</span> <span class="hljs-keyword">as</span> plt
    target.<span class="hljs-title function_">plot</span>(label = <span class="hljs-string">'train'</span>)
    pred.<span class="hljs-title function_">plot</span>(label = <span class="hljs-string">'prediction'</span>)
    test[<span class="hljs-string">'Weekly_Sales'</span>][:n].<span class="hljs-title function_">plot</span>(label = <span class="hljs-string">'actual'</span>)

<span class="hljs-title function_">plotQuantile</span>()
</code></pre>
<p>양자 예측은 다음과 같습니다:</p>
<p><img src="/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_10.png" alt="그림"></p>
<p>모델을 구축하고 예측을 제공하는 것이 매우 쉽다는 것을 발견할 수 있을 것 입니다. 계속해서 LightGBM 모델을 구축해 봅시다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>LightGBM</p>
<p>"제 12장: Tree-based Time Series Models의 Feature Engineering"에서 lightGBM 모델을 구축한 적이 있지 않았나요? 정말이죠! 다른 점은 여기서는 Darts 라이브러리를 사용하여 lightGBM 모델을 구축할 것이라는 점입니다. 이전 장에서의 데이터 형식은 Pandas 데이터 프레임이었지만, 여기서는 Darts 데이터 object입니다. 그럼에도 불구하고 LightGBM이 무엇인지 설명해보겠습니다.</p>
<p>LightGBM (Light Gradient Boosting Machine)은 gradient-boosting 결정 트리 모델의 효율적이고 확장 가능한 학습을 위해 설계되었습니다. LightGBM은 빠른 속도, 메모리 효율성, 정확성으로 인해 인기를 얻었습니다. 그 중요한 특징은 다른 gradient-boosting 구현에서 사용되는 전통적인 수준별 전략이 아니라 잎별 성장 전략을 채택한다는 것입니다. 이 전략은 손실을 가장 효과적으로 최소화할 잎 노드를 선택하여 더 빠른 학습 시간을 제공합니다. 그 외에도 그래디언트 부스팅 알고리즘을 여전히 구현합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">from</span> darts.<span class="hljs-property">models</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">LightGBMModel</span>
n = <span class="hljs-number">12</span>
model = <span class="hljs-title class_">LightGBMModel</span>(
    lags=<span class="hljs-number">12</span>,
    lags_past_covariates=<span class="hljs-number">12</span>,
    lags_future_covariates=[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],
    output_chunk_length=<span class="hljs-number">12</span>,
    verbose=-<span class="hljs-number">1</span>
)
model.<span class="hljs-title function_">fit</span>(target, past_covariates=past_cov, future_covariates=future_cov)
pred = model.<span class="hljs-title function_">predict</span>(n)
pred.<span class="hljs-title function_">values</span>()
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>위의 코드는 XGB와 유사하여 더 이상 강조하지 않겠습니다. 그래프를 그려 성능 메트릭을 살펴봅시다:</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">plotit</span>();
</code></pre>
<p>MAPE는 5.09%입니다.</p>
<p><img src="/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_11.png" alt="이미지"></p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이제 분위 예측을 포함해 봅시다.</p>
<pre><code class="hljs language-js">n = <span class="hljs-number">12</span>
chunk_length = n
model = <span class="hljs-title class_">LightGBMModel</span>(
    lags=<span class="hljs-number">12</span>,
    lags_past_covariates=<span class="hljs-number">12</span>,
    lags_future_covariates=[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>],
    output_chunk_length=chunk_length,
    likelihood = <span class="hljs-string">'quantile'</span>, # quantile 또는 poisson 으로 설정할 수 있습니다.
    # quantile로 설정하면 sklearn.<span class="hljs-property">linear_model</span>.<span class="hljs-property">QuantileRegressor</span>가 사용됩니다.
    # poisson으로 설정하면 sklearn.<span class="hljs-property">linear_model</span>.<span class="hljs-property">PoissonRegressor</span>가 사용됩니다.
    quantiles=[<span class="hljs-number">0.01</span>, <span class="hljs-number">0.05</span>, <span class="hljs-number">0.50</span>, <span class="hljs-number">0.95</span>, <span class="hljs-number">0.99</span>]
)
model.<span class="hljs-title function_">fit</span>(target, past_covariates=past_cov, future_covariates=future_cov)
pred = model.<span class="hljs-title function_">predict</span>(n, num_samples=<span class="hljs-number">5</span>)
pred
</code></pre>
<p>분위 예측을 그래프로 확인해볼 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">plotQuantile</span>();
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>양자수치 예측값은:</p>
<p><img src="/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_12.png" alt="image"></p>
<p>좋아요. 이미 두 개의 모델이 구축되었습니다. 이제 CatBoost 모델을 구축해봅시다.</p>
<p>CatBoost</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>CatBoost은 "Category Boosting"의 약자입니다. 범주형 기능을 효율적으로 처리할 수 있도록 특별히 설계되었으므로 다양한 분류 및 회귀 작업에 적합합니다. 이는 원-핫 인코딩과 같은 전처리가 필요 없이 범주형 기능을 직접 처리할 수 있습니다. CatBoost는 카테고리별 통계 속성에 기초하여 최적 분할점을 찾아 효율적으로 범주형 변수를 처리하는 Ordered Boosting이라는 새로운 알고리즘을 사용합니다. 이외에도 결정 트리 앙상블을 구축하기 위해 그래디언트 부스팅의 구현을 상속받습니다. 각 트리는 이전 모델의 오류를 최소화하도록 학습됩니다. 최적 매개변수를 찾기 위해 그래디언트 강하 최적화 알고리즘을 사용합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">from</span> darts.<span class="hljs-property">models</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">CatBoostModel</span>
n = <span class="hljs-number">12</span>
chunk_length = n
model = <span class="hljs-title class_">CatBoostModel</span>(
    lags=<span class="hljs-number">12</span>,
    lags_past_covariates=<span class="hljs-number">12</span>,
    lags_future_covariates=[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],
    output_chunk_length=<span class="hljs-number">12</span>,
    verbose=-<span class="hljs-number">1</span>
)
model.<span class="hljs-title function_">fit</span>(target, past_covariates=past_cov, future_covariates=future_cov)
pred = model.<span class="hljs-title function_">predict</span>(n)
pred
</code></pre>
<p>위 코드에 CatBoostModel을 삽입하여 내용을 그대로 유지하시면 됩니다.</p>
<p>결과를 그래프로 출력해보겠습니다:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-title function_">plotit</span>();
</code></pre>
<p>MAPE는 5.96% 입니다.</p>
<p><img src="/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_13.png" alt="이미지"></p>
<p>모델에 분위 예측을 포함해 봅시다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">n = <span class="hljs-number">12</span>
chunk_length = n
model = <span class="hljs-title class_">CatBoostModel</span>(
    lags=<span class="hljs-number">12</span>,
    lags_past_covariates=<span class="hljs-number">12</span>,
    lags_future_covariates=[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>],
    output_chunk_length=chunk_length,
    likelihood = <span class="hljs-string">'quantile'</span>, # <span class="hljs-string">'quantile'</span> 또는 <span class="hljs-string">'poisson'</span>으로 설정할 수 있습니다.
    # <span class="hljs-string">'quantile'</span>로 설정하면 sklearn.<span class="hljs-property">linear_model</span>.<span class="hljs-property">QuantileRegressor</span>가 사용됩니다.
    # <span class="hljs-string">'poisson'</span>으로 설정하면 sklearn.<span class="hljs-property">linear_model</span>.<span class="hljs-property">PoissonRegressor</span>가 사용됩니다.
    quantiles=[<span class="hljs-number">0.01</span>, <span class="hljs-number">0.05</span>, <span class="hljs-number">0.50</span>, <span class="hljs-number">0.95</span>,<span class="hljs-number">0.99</span>]
)
model.<span class="hljs-title function_">fit</span>(target, past_covariates=past_cov, future_covariates=future_cov)
pred = model.<span class="hljs-title function_">predict</span>(n, num_samples=<span class="hljs-number">5</span>)
pred
</code></pre>
<p>양자화 예측값을 그릴 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">plotQuantile</span>();
</code></pre>
<p>이 차트는 다음과 같습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_14.png" alt="Tree-based Models"></p>
<p>결론</p>
<p>이 장에서는 Darts 라이브러리를 사용하여 세 가지 인기있는 트리 기반 시계열 모델을 구축했습니다. 우리는 다기간 예측 및 예측 불확실성의 사용 사례에 중점을 두었습니다. 다음에 시계열 모델을 구축하여 다기간 예측 및 예측 불확실성을 제공해야 할 때, 세 가지 트리 기반 모델과 다기간 확률적 예측을 위한 자동 회귀 선형 회귀 모델을 함께 생성하는 것을 권장합니다. 우승 모델을 찾기 위해 11 장에서 선형 회귀 모델과 결합하여 사용할 수 있습니다.</p>
<p>이 장은 트리 기반 시계열 모델에 대한 현대적 기법 시리즈를 마무리합니다. 다음 장에서는 딥러닝 기반 시계열 모델에 대한 시리즈를 시작할 것입니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>시계열 모델링 기법의 진화</li>
<li>RNN/LSTM용 DeepAR</li>
<li>응용 - 주식 가격에 대한 확률 예측</li>
</ul>
<p>참고문헌</p>
<ul>
<li>(XGB) Chen, T., &#x26; Guestrin, C. (2016). XGBoost: A Scalable Tree Boosting System. In Proceedings of the 22nd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining (pp. 785–794). ACM. <a href="https://dl.acm.org/doi/10.1145/2939672.2939785" rel="nofollow" target="_blank">링크</a></li>
<li>(LightGBM) Ke, G., Meng, Q., Finley, T., Wang, T., Chen, W., Ma, W., … &#x26; Li, Q. (2017). LightGBM: A Highly Efficient Gradient Boosting Decision Tree. In Advances in Neural Information Processing Systems (pp. 3146–3154). <a href="https://proceedings.neurips.cc/paper/2017/file/6449f44a102fde848669bdd9eb6b76fa-Paper.pdf" rel="nofollow" target="_blank">링크</a></li>
<li>(CatBoost) Prokhorenkova, L., Gusev, G., Vorobev, A., Dorogush, A. V., &#x26; Gulin, A. (2018). CatBoost: unbiased boosting with categorical features. In Advances in Neural Information Processing Systems (pp. 6638–6648). <a href="https://proceedings.neurips.cc/paper/2018/file/0d4724e4525b451dae9f6cb39983e6cd-Paper.pdf" rel="nofollow" target="_blank">링크</a></li>
</ul>
<p>샘플 eBook 챕터 (무료): <a href="https://github.com/dataman-git/modern-time-series/blob/main/20240522beauty_TOC.pdf" rel="nofollow" target="_blank">링크</a></p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>The Innovation Press, LLC의 직원들께서 아름다운 형식으로 책을 재구성해 주어 즐거운 독서 경험을 선사했습니다. 전 세계 독자들에게 복잡한 유지보수비 없이 eBook을 배포하기 위해 Teachable 플랫폼을 선택했습니다. 신용카드 거래는 Teachable.com에 의해 기밀리에 안전하게 관리됩니다.</li>
</ul>
<p>Teachable.com에서의 eBook: $22.50
<a href="https://drdataman.teachable.com/p/home" rel="nofollow" target="_blank">https://drdataman.teachable.com/p/home</a></p>
<p>Amazon.com에서의 인쇄판: $65 <a href="https://a.co/d/25FVsMx" rel="nofollow" target="_blank">https://a.co/d/25FVsMx</a></p>
<ul>
<li>인쇄판은 윤광 표지, 컬러 인쇄, 아름다운 Springer 글꼴과 레이아웃을 사용하여 즐거운 독서를 위해 디자인되었습니다. 7.5 x 9.25 인치의 크기는 책장의 대부분 책들과 잘 어울립니다.</li>
<li>“이 책은 과거 시계열 분석 및 예측 분석, 이상 징후 탐지 등의 응용에 대한 깊은 이해력을 갖춘 쿠오의 증명서입니다. 이 책은 독자들에게 실세계의 도전 과제에 대처하는 데 필요한 기술을 제공합니다. 데이터 과학으로의 전직을 고려하는 분들에게 특히 가치 있습니다. 쿠오는 전통적이고 최첨단 기술 모두에 대해 상세히 탐구합니다. 쿠오는 신경망 및 다른 고급 알고리즘에 대한 토론을 통합하여 최신 동향과 발전을 반영합니다. 이는 독자들이 확립된 방법뿐만 아니라 데이터 과학 분야의 가장 최신이며 혁신적인 기술과 상호작용할 수 있도록 준비되어 있다는 것을 보장합니다. 쿠오의 생동감 넘치는 글쓰기 스타일로 이 책의 명확함과 접근성이 향상되었습니다. 그는 복잡한 수학적 및 통계적 개념을 실용적으로 만들어내며 엄격함을 희생하지 않고 다가갈 수 있게 만듭니다.”</li>
</ul>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>현대 시계열 예측: 예측 분석과 이상 감지</h1>
<p>제로 장: 서문</p>
<p>1장: 소개</p>
<p>2장: 비즈니스 예측을 위한 예언자</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h3>Chapter 3: 튜토리얼 1 - 추세 + 계절성 + 휴일 및 이벤트</h3>
<h3>Chapter 4: 튜토리얼 2 - 추세 + 계절성 + 휴일 및 이벤트 + 자기회귀(AR) + 지연 회귀 변수 + 미래 회귀 변수</h3>
<h3>Chapter 5: 시계열의 변화점 탐지</h3>
<h3>Chapter 6: 시계열 확률 예측을 위한 몬테카를로 시뮬레이션</h3>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>제목 7: 시계열 확률 예측을 위한 분위 회귀</p>
<p>제목 8: 시계열 확률 예측을 위한 적응형 예측</p>
<p>제목 9: 시계열 확률 예측을 위한 적응형 분위 회귀</p>
<p>제목 10: 자동 ARIMA!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>"Chapter 11: 시계열 데이터 형식을 쉽게 만들어보기</p>
<p>Chapter 12: 다기간 확률 예측을 위한 선형 회귀</p>
<p>Chapter 13: 트리 기반 시계열 모델을 위한 피처 엔지니어링</p>
<p>Chapter 14: 다기간 시계열 예측을 위한 두 가지 주요 전략"</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>15장: Tree 기반 XGB, LightGBM 및 CatBoost 모델을 활용한 다기간 시계열 확률 예측</h1>
<h1>16장: 시계열 모델링 기법의 진화</h1>
<h1>17장: Deep Learning 기반 DeepAR을 활용한 시계열 확률 예측</h1>
<h1>18장: 응용 - 주식 가격에 대한 확률적 예측</h1>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>19장: RNN에서 Transformer 기반 시계열 모델로</h1>
<h1>20장: 해석 가능한 시계열 예측을 위한 Temporal Fusion Transformer</h1>
<h1>21장: 시계열 예측을 위한 오픈소스 Lag-Llama 튜토리얼</h1>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"여러 기간의 시계열 확률 예측을 위한 XGB, LightGBM, CatBoost 모델 비교 분석","description":"","date":"2024-07-09 19:34","slug":"2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting","content":"\n![Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting](/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_0.png)\n\nSample eBook chapters (free): [https://github.com/dataman-git/modern-time-series/blob/main/20240522beauty_TOC.pdf](https://github.com/dataman-git/modern-time-series/blob/main/20240522beauty_TOC.pdf)\n\neBook on Teachable.com: $22.50 [https://drdataman.teachable.com/p/home](https://drdataman.teachable.com/p/home)\n\nThe print edition on Amazon.com: $65 [https://a.co/d/25FVsMx](https://a.co/d/25FVsMx)\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 텍스트를 친근하게 번역하면 아래와 같습니다.\n\n챕터 제목은 \"확률 예측\", \"다기간\", \"트리 기반\" 세 가지 중요한 개념을 다룹니다. 첫 번째로 \"확률 예측\"이 있습니다. 많은 실세계 응용 프로그램에서는 자원 계획이나 이상 징후 감지를 위해 예측 구간을 요청하며, 이는 1장에서 언급한 것과 같습니다. 이 책의 Part 2에서 언급한 네 가지 해결책 중 하나는 분위수 회귀입니다. 분위 예측은 예측 값을 매우 가능성이 높은 50 번째 백분위 값이거나 상위 90 번째 백분위 값과 같이 매우 낮은 가능성을 보여줍니다 (A) 그림에서 확인할 수 있습니다.\n\n\u003cimg src=\"/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_1.png\" /\u003e\n\n제목에서 두 번째 개념은 다기간 예측입니다. 우리는 일일 예측이 아닌 여러 기간을 위한 예측이 필요한 경우가 많습니다. 한 주간 휴가를 계획할 때, 한 날이 아닌 5일간의 날씨 예보가 필요합니다. 그러나 선형 회귀 또는 트리 기반 알고리즘은 일반적으로 점 추정만 제공합니다. 이러한 경우 어떻게 예측 프로세스를 설계하여 다기간을 제공할 수 있을까요? 직관적으로, 다음 기간을 예측하면 동일한 모델의 입력으로 사용하여 다다음 기간을 예측할 수도 있지 않을까요? 이 해결책은 인기가 있으며 (B) 그림에서 보이는 것과 같이 재귀적 예측 전략이라고 합니다. 재귀적 예측 전략은 모델의 예측을 후속 예측의 입력으로 사용합니다. 전략은 모델이 1 단계 앞으로 예측하기 위해 yt에서 yt-k까지의 과거 값을 사용합니다. 그런 다음 yt+1을 통합하고 다른 입력을 업데이트하여 yt+2를 예측합니다. 이 프로세스를 반복하여 모든 후속 시간 단계를 예측합니다. Darts 라이브러리에서도 이 전략을 할당할 수 있습니다.\n\n\u003cimg src=\"/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_2.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n새로운 시각으로 생각해보는 건 어때요? n 기간을 예측하는 것이 목표인 경우, 왜 n 개의 모델을 따로 구축하지 않을까요? 각 모델은 각각의 다음 n 기간을 예측할 것입니다. 이는 직접 예측 전략이라고 불립니다. Darts 라이브러리의 기본 전략이며, 라이브러리에 포함된 모든 모델에 대해 적용됩니다.\n\n![이미지](/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_3.png)\n\n마지막으로, 장 제목에 있는 \"tree-based\"에 대해 논의해보겠습니다. Tree-based 알고리즘들은 지도 학습 알고리즘입니다. 샘플을 행으로, 피처를 열로 갖는 데이터 프레임이 필요합니다. 단변량 시계열 데이터를 데이터 프레임으로 어떻게 변환할까요? 기본 아이디어는 단변량 시계열 데이터에서 샘플을 생성하는 것입니다. 이렇게 함으로써, 모델링을 위해 단변량 시계열 데이터를 데이터 프레임으로 재구성하고, 원하는 경우 단변량 시계열 데이터에서 피처를 생성할 수도 있습니다.\n\n이번 장에서는 세 가지 tree-based 모델인 XGBoost (2016), LightGBM (2017), CatBoost (2018)에 대해 세 부분으로 소개하고, 각 알고리즘에 대해 간단히 설명할 것입니다. 세 모델 간의 차이점에 대해 궁금하다면, Figure (C)에 각 세 그래디언트 부스팅 기반 알고리즘의 특징을 강조한 표를 만들었습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_4.png)\n\n이번 장에서는 Darts 라이브러리를 사용할 것입니다. 시계열 모델링은 많은 기능과 데이터를 저장해야 하므로 Darts 라이브러리는 자체 데이터 형식을 갖추고 있습니다. 시간 순서에 풍부한 정보를 담을 수 있는 다양한 데이터 형식의 장점을 설명하기 위해 본 책은 '10장: 시계열 데이터 형식 쉽게 만들기'를 별도로 마련했습니다. 마지막으로, 이 장은 '11장: 다기간 확률 예측을 위한 자기회귀 선형 회귀'와 함께 읽을 수 있습니다. 두 장은 프로젝트에 적합한 모델을 선택하기 위해 선형 회귀 및 트리 기반 모델을 구축하는 데 도움이 됩니다.\n\n이 장의 구조는 다음과 같습니다:\n\n- 필요한 소프트웨어 요구 사항\n- 판다스 데이터를 Darts 데이터 형식으로 변환하는 방법\n- XGB\n- LightGBM\n- CatBoost\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파이썬 노트북은 이 Github 링크를 통해 다운로드할 수 있어요.\n\n소프트웨어 요구 사항\n\n기본 Darts 패키지는 Prophet, CatBoost, 그리고 LightGBM 종속성을 설치하지 않습니다. 0.25.0 버전을 기준으로 해서요. 직접 Prophet, CatBoost, 그리고 LightGBM 패키지를 설치해야 해요.\n\n- CatBoostModel: CatBoost 설치 가이드를 사용하여 catboost 패키지(버전 1.0.6 이상)를 설치합니다.\n- LightGBMModel: LightGBM 설치 가이드를 사용하여 lightgbm 패키지(버전 3.2.0 이상)를 설치합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n!pip install pandas numpy matplotlib darts lightgbm catboost\n```\n\n다음으로, 동일한 Walmart 매장 판매 데이터를 로드할 것입니다.\n\n데이터\n\n저는 Kaggle.com에 있는 Walmart 데이터셋을 사용할 것입니다. 이 데이터셋은 2010년 2월 5일부터 2012년 11월 1일까지의 주간 매장 매출 정보를 포함하고 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Date - 판매 주차\n- Store - 상점 번호\n- 주간 매출 - 상점의 매출\n- 휴일 플래그 - 주가 특별 휴일 주인지 여부 1 - 휴일 주 0 - 비 휴일 주\n- 온도 - 판매일 온도\n- 연료 가격 - 지역의 연료 비용\n\n소매 판매에 영향을 미칠 수있는 두 가지 거시경제 지표 : 소비자 물가지수와 실업률. 데이터 세트는 Pandas 데이터 프레임으로로드됩니다.\n\n```js\n%matplotlib inline\nimport pandas as pd\nimport numpy as np\nfrom matplotlib import pyplot as plt\n\n# Google Colab\nfrom google.colab import drive\ndrive.mount('/content/gdrive')\npath = '/content/gdrive/My Drive/data/time_series'\n# https://www.kaggle.com/datasets/yasserh/walmart-dataset\n\n# 데이터 로드\ndata = pd.read_csv(path + '/walmart.csv', delimiter=\",\")\ndata['ds'] = pd.to_datetime(data['Date'], format='%d-%m-%Y')\ndata.index = data['ds']\ndata = data.drop('Date', axis=1)\ndata.head()\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_5.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n제 10 장에서 쉽게 만들어진 Darts의 시계열 데이터 형식에 대해 배웠어요. Darts의 주요 데이터 클래스는 \"TimeSeries\" 클래스입니다. Darts는 값들을 다음과 같은 배열 모양으로 저장해요 (시간, 차원, 샘플):\n\n- 시간: 위 예시에서처럼 143 주와 같은 시간 인덱스\n- 차원: 다변량 시계열의 \"열\"\n- 샘플: 기간에 대한 값들. 10 번째, 50 번째 백분위수와 90 번째 백분위수에 대한 그림 (A)에서처럼 확률론적 예측이라면 3개의 샘플이 있을 거예요.\n\n저희는 월마트 매장 판매량을 불러오기 위해 .from_group_dataframe() 함수를 사용할 거예요. 그룹 ID는 \"Store\"예요. 따라서 group_cols 매개변수는 \"Store\"가 될 거예요. 시간 인덱스는 \"ds\" 열이에요.\n\n```js\nfrom darts import TimeSeries\ndarts_group_df = TimeSeries.from_group_dataframe(data, group_cols='Store', time_col='ds')\nprint(\"그룹/매장의 수는:\", len(darts_group_df))\nprint(\"시간 기간의 수는: \", len(darts_group_df[0]))\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 그룹/상점 수: 45\n- 기간 수: 143\n\n다음과 같이 컬럼을 나열할 수 있습니다. components 함수를 사용해봅시다:\n\n```js\ndarts_group_df[0].components;\n```\n\nIndex(['Weekly_Sales', 'Holiday_Flag', 'Temperature', 'Fuel_Price', 'CPI', 'Unemployment'], dtype='object', name='component')\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nStore 1 매출 모델을 구축하기 위해 Store 1 데이터만 사용할 겁니다. \"darts_group_df[0]\"에 해당합니다. 이를 훈련 데이터와 테스트 데이터로 나눌 겁니다.\n\n```js\nstore1 = darts_group_df[0]\ntrain = store1[:130]\ntest = store1[130:]\nlen(train), len(test) # (130, 13)\n```\n\n우리의 목표 시리즈는 \"Weekly_Sales\"입니다. 다른 공선변수를 포함할 수도 있습니다. 시계열에서는 과거 공선변수와 미래 공선변수 두 종류가 있습니다. Darts 라이브러리는 동일한 용어를 사용합니다. 과거 공선변수는 연구 현재 시간까지의 변수입니다. 미래 공선변수는 미래에 관측 가능한 변수입니다. 미래 값을 어떻게 알 수 있는지 궁금할 수도 있습니다. 첫 번째 이유는 미래 휴일과 같이 결정론적 값이기 때문입니다. 두 번째 이유는 날씨 예측과 같은 다른 소스에서 예측된 값이기 때문입니다. 우리의 경우 \"Fuel_price\"와 \"CPI\"를 과거 공선변수로, \"Holiday_flag\"를 미래 공선변수로 포함할 것입니다. 훈련 데이터에서의 목표와 과거 공선변수는 130개의 데이터 포인트가 있습니다. 하지만 미래 공선변수는 실제로 미래까지 확장되어 143개의 데이터 포인트를 갖습니다.\n\n```js\ntarget = train['Weekly_Sales']\npast_cov = train[['Fuel_Price','CPI']]\nfuture_cov = store1['Holiday_Flag'][:143]\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우니바리에이트 데이터부터 시작해보겠습니다.\n\nXGB\n\nXGBoost (Extreme Gradient Boosting)은 분류 및 회귀와 같은 지도 학습 작업에 널리 사용되며 효율성, 확장성 및 정확도로 알려져 있습니다. 가장 주목할 만한 기능은 오버피팅을 방지하기 위해 L1 및 L2 규제 기술이 포함되어 있다는 점입니다. 규제 패널티는 트리의 가중치, 리프 노드 값, 특성 중요도 점수에 적용되어 일반화 성능을 향상시키는 데 도움을 줍니다. 또 다른 기능으로는 병렬 및 분산 컴퓨팅을 지원하며 멀티코어 CPU 및 Apache Spark 및 Dask와 같은 분산 컴퓨팅 프레임워크에서 효율적인 학습이 가능합니다. 이 확장성은 대규모 데이터 처리에 적합하게 만듭니다. 그 외에도 이전 모델이 실수한 오류를 수정하기 위해 각 트리가 순차적으로 훈련되는 경사 부스팅 프레임워크를 계승했습니다. 전체적인 목표는 특정 손실 함수를 최소화하는 것입니다.\n\n다음 코드는 Darts의 표준 모델링 구문입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nfrom darts.models import XGBModel\nn = 12\nchunk_length = n\nmodel = XGBModel(\n    lags=12,\n    lags_past_covariates=12,\n    lags_future_covariates=[0,1,2,3,4,5],\n    output_chunk_length=12,\n    Multi_models = True # optional\n    verbose=-1\n)\nmodel.fit(target, past_covariates=past_cov, future_covariates=future_cov)\npred = model.predict(n)\npred\n```\n\nfit() 함수의 \"target\"은 모델링을 위한 대상 시리즈입니다. 모델은 yt, yt-1, yt-2, ..., yt-12까지의 지연된 값들에 대한 \"lags\"를 필요로 합니다. 또한 다른 공변량을 지정할 수도 있습니다. 시계열 모델링에서 과거 공변량과 미래 공변량이라는 두 가지 넓은 유형의 공변량이 있습니다. Darts는 이 규칙을 따릅니다. lags_past_covariates는 xt, xt-1, ..., xt-12와 같이 지연된 과거 공변량을 나타냅니다. 약간 혼동스러운 lags_future_covariates 이름은 미래 공변량을 의미합니다. \"미래 공변량\"은 미래 시간 단계에서의 이러한 공변량의 값들을 의미하며, \"지연된\" 값들은 이전 시간 단계에서의 미래 공변량을 의미합니다. 이는 미래 t + n 단계에 대해 모델이 t부터 t + (n-1)까지의 공변량의 값을 고려한다는 것을 의미합니다.\n\nmulti_models 매개변수가 True로 설정된 것에 주목해주세요. 이는 모델에게 다중 기간 예측을 위한 직접 예측 전략 또는 재귀적 예측 전략을 사용할지 알려줍니다. 기본값은 True이며, 이는 직접 예측 전략을 사용한다는 것을 의미합니다.\n\n입력 청크 길이와 출력 청크 길이에 관한 한 가지 추가적인 매개변수가 있습니다. 이는 단변량 시리즈에서 샘플을 생성하는 것과 관련이 있습니다. 그림 (F)는 y0에서 y15까지의 시리즈에서 생성된 샘플을 보여줍니다. 각 샘플에는 입력 청크와 출력 청크가 포함되어 있습니다. 입력 청크 길이가 5이고 출력 청크 길이가 2인 것을 가정해보세요. 첫 번째 샘플은 입력 청크로 y0 - y4를, 출력 청크로 y5, y6를 가지고 있습니다. 창이 시리즈를 따라 이동하여 샘플을 만들며, 이를 시리즈의 끝까지 반복합니다. 출력 청크 길이는 예측할 수 있는 가장 긴 길이를 정의합니다. 이를 12로 지정했습니다. 12 이상을 예측하려고 하면 오류 메시지가 출력됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Dart data array](/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_6.png)\n\nThe outputs are stored in the Dart data array:\n\n![Dart data array](/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_7.png)\n\nWe will plot the actual and the predicted values. We make this in a function for repeating use.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\ndef plotit():\n  import matplotlib.pyplot as plt\n  target.plot(label='train')\n  pred.plot(label='prediction')\n  test['Weekly_Sales'][:n].plot(label='actual')\n\n  from darts.metrics.metrics import mae, mape\n  print(\"Mean Absolute Error:\", mae(test['Weekly_Sales'][:n], pred))\n  print(\"Mean Absolute Percentage Error\", mape(test['Weekly_Sales'][:n], pred))\n\nplotit()\n```\n\nMAPE 값은 10.55% 입니다.\n\n![이미지](/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_8.png)\n\n이제 분위수 예측을 추가해보겠습니다. 모델에게 5개의 분위수를 생성해 달라고 요청하겠습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nfrom darts.models import XGBModel\nn = 12\nchunk_length = n\nmodel = XGBModel(\n    lags=12,\n    lags_past_covariates=12,\n    lags_future_covariates=[0,1,2,3,4,5,6,7,8,9,10,11,12],\n    output_chunk_length=chunk_length,\n    likelihood = 'quantile', # 'quantile' 또는 'poisson'으로 설정 가능합니다.\n    # 'quantile'로 설정하면 sklearn.linear_model.QuantileRegressor가 사용됩니다.\n    # 'poisson'으로 설정하면 sklearn.linear_model.PoissonRegressor가 사용됩니다.\n    quantiles=[0.01, 0.05, 0.50, 0.95, 0.99]\n)\nmodel.fit(target, past_covariates=past_cov, future_covariates=future_cov)\npred = model.predict(n, num_samples=5)\npred\n```\n\n각 예측에는 5개의 샘플이 있습니다. 이는 5개의 분위 수치 값을 생성했기 때문입니다.\n\n![](/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_9.png)\n\n실제 값과 분위 예측을 시각화할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ndef plotQuantile():\n    import matplotlib.pyplot as plt\n    target.plot(label = 'train')\n    pred.plot(label = 'prediction')\n    test['Weekly_Sales'][:n].plot(label = 'actual')\n\nplotQuantile()\n```\n\n양자 예측은 다음과 같습니다:\n\n![그림](/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_10.png)\n\n모델을 구축하고 예측을 제공하는 것이 매우 쉽다는 것을 발견할 수 있을 것 입니다. 계속해서 LightGBM 모델을 구축해 봅시다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nLightGBM\n\n\"제 12장: Tree-based Time Series Models의 Feature Engineering\"에서 lightGBM 모델을 구축한 적이 있지 않았나요? 정말이죠! 다른 점은 여기서는 Darts 라이브러리를 사용하여 lightGBM 모델을 구축할 것이라는 점입니다. 이전 장에서의 데이터 형식은 Pandas 데이터 프레임이었지만, 여기서는 Darts 데이터 object입니다. 그럼에도 불구하고 LightGBM이 무엇인지 설명해보겠습니다.\n\nLightGBM (Light Gradient Boosting Machine)은 gradient-boosting 결정 트리 모델의 효율적이고 확장 가능한 학습을 위해 설계되었습니다. LightGBM은 빠른 속도, 메모리 효율성, 정확성으로 인해 인기를 얻었습니다. 그 중요한 특징은 다른 gradient-boosting 구현에서 사용되는 전통적인 수준별 전략이 아니라 잎별 성장 전략을 채택한다는 것입니다. 이 전략은 손실을 가장 효과적으로 최소화할 잎 노드를 선택하여 더 빠른 학습 시간을 제공합니다. 그 외에도 그래디언트 부스팅 알고리즘을 여전히 구현합니다.\n\n```js\nfrom darts.models import LightGBMModel\nn = 12\nmodel = LightGBMModel(\n    lags=12,\n    lags_past_covariates=12,\n    lags_future_covariates=[0,1,2,3,4,5],\n    output_chunk_length=12,\n    verbose=-1\n)\nmodel.fit(target, past_covariates=past_cov, future_covariates=future_cov)\npred = model.predict(n)\npred.values()\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 코드는 XGB와 유사하여 더 이상 강조하지 않겠습니다. 그래프를 그려 성능 메트릭을 살펴봅시다:\n\n```js\nplotit();\n```\n\nMAPE는 5.09%입니다.\n\n![이미지](/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_11.png)\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 분위 예측을 포함해 봅시다.\n\n```js\nn = 12\nchunk_length = n\nmodel = LightGBMModel(\n    lags=12,\n    lags_past_covariates=12,\n    lags_future_covariates=[0,1,2,3,4,5,6,7,8,9,10,11,12],\n    output_chunk_length=chunk_length,\n    likelihood = 'quantile', # quantile 또는 poisson 으로 설정할 수 있습니다.\n    # quantile로 설정하면 sklearn.linear_model.QuantileRegressor가 사용됩니다.\n    # poisson으로 설정하면 sklearn.linear_model.PoissonRegressor가 사용됩니다.\n    quantiles=[0.01, 0.05, 0.50, 0.95, 0.99]\n)\nmodel.fit(target, past_covariates=past_cov, future_covariates=future_cov)\npred = model.predict(n, num_samples=5)\npred\n```\n\n분위 예측을 그래프로 확인해볼 수 있습니다.\n\n```js\nplotQuantile();\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n양자수치 예측값은:\n\n![image](/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_12.png)\n\n좋아요. 이미 두 개의 모델이 구축되었습니다. 이제 CatBoost 모델을 구축해봅시다.\n\nCatBoost\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nCatBoost은 \"Category Boosting\"의 약자입니다. 범주형 기능을 효율적으로 처리할 수 있도록 특별히 설계되었으므로 다양한 분류 및 회귀 작업에 적합합니다. 이는 원-핫 인코딩과 같은 전처리가 필요 없이 범주형 기능을 직접 처리할 수 있습니다. CatBoost는 카테고리별 통계 속성에 기초하여 최적 분할점을 찾아 효율적으로 범주형 변수를 처리하는 Ordered Boosting이라는 새로운 알고리즘을 사용합니다. 이외에도 결정 트리 앙상블을 구축하기 위해 그래디언트 부스팅의 구현을 상속받습니다. 각 트리는 이전 모델의 오류를 최소화하도록 학습됩니다. 최적 매개변수를 찾기 위해 그래디언트 강하 최적화 알고리즘을 사용합니다.\n\n```js\nfrom darts.models import CatBoostModel\nn = 12\nchunk_length = n\nmodel = CatBoostModel(\n    lags=12,\n    lags_past_covariates=12,\n    lags_future_covariates=[0,1,2,3,4,5],\n    output_chunk_length=12,\n    verbose=-1\n)\nmodel.fit(target, past_covariates=past_cov, future_covariates=future_cov)\npred = model.predict(n)\npred\n```\n\n위 코드에 CatBoostModel을 삽입하여 내용을 그대로 유지하시면 됩니다.\n\n결과를 그래프로 출력해보겠습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nplotit();\n```\n\nMAPE는 5.96% 입니다.\n\n![이미지](/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_13.png)\n\n모델에 분위 예측을 포함해 봅시다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nn = 12\nchunk_length = n\nmodel = CatBoostModel(\n    lags=12,\n    lags_past_covariates=12,\n    lags_future_covariates=[0,1,2,3,4,5,6,7,8,9,10,11,12],\n    output_chunk_length=chunk_length,\n    likelihood = 'quantile', # 'quantile' 또는 'poisson'으로 설정할 수 있습니다.\n    # 'quantile'로 설정하면 sklearn.linear_model.QuantileRegressor가 사용됩니다.\n    # 'poisson'으로 설정하면 sklearn.linear_model.PoissonRegressor가 사용됩니다.\n    quantiles=[0.01, 0.05, 0.50, 0.95,0.99]\n)\nmodel.fit(target, past_covariates=past_cov, future_covariates=future_cov)\npred = model.predict(n, num_samples=5)\npred\n```\n\n양자화 예측값을 그릴 수 있습니다.\n\n```js\nplotQuantile();\n```\n\n이 차트는 다음과 같습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Tree-based Models](/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_14.png)\n\n결론\n\n이 장에서는 Darts 라이브러리를 사용하여 세 가지 인기있는 트리 기반 시계열 모델을 구축했습니다. 우리는 다기간 예측 및 예측 불확실성의 사용 사례에 중점을 두었습니다. 다음에 시계열 모델을 구축하여 다기간 예측 및 예측 불확실성을 제공해야 할 때, 세 가지 트리 기반 모델과 다기간 확률적 예측을 위한 자동 회귀 선형 회귀 모델을 함께 생성하는 것을 권장합니다. 우승 모델을 찾기 위해 11 장에서 선형 회귀 모델과 결합하여 사용할 수 있습니다.\n\n이 장은 트리 기반 시계열 모델에 대한 현대적 기법 시리즈를 마무리합니다. 다음 장에서는 딥러닝 기반 시계열 모델에 대한 시리즈를 시작할 것입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 시계열 모델링 기법의 진화\n- RNN/LSTM용 DeepAR\n- 응용 - 주식 가격에 대한 확률 예측\n\n참고문헌\n\n- (XGB) Chen, T., \u0026 Guestrin, C. (2016). XGBoost: A Scalable Tree Boosting System. In Proceedings of the 22nd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining (pp. 785–794). ACM. [링크](https://dl.acm.org/doi/10.1145/2939672.2939785)\n- (LightGBM) Ke, G., Meng, Q., Finley, T., Wang, T., Chen, W., Ma, W., … \u0026 Li, Q. (2017). LightGBM: A Highly Efficient Gradient Boosting Decision Tree. In Advances in Neural Information Processing Systems (pp. 3146–3154). [링크](https://proceedings.neurips.cc/paper/2017/file/6449f44a102fde848669bdd9eb6b76fa-Paper.pdf)\n- (CatBoost) Prokhorenkova, L., Gusev, G., Vorobev, A., Dorogush, A. V., \u0026 Gulin, A. (2018). CatBoost: unbiased boosting with categorical features. In Advances in Neural Information Processing Systems (pp. 6638–6648). [링크](https://proceedings.neurips.cc/paper/2018/file/0d4724e4525b451dae9f6cb39983e6cd-Paper.pdf)\n\n샘플 eBook 챕터 (무료): [링크](https://github.com/dataman-git/modern-time-series/blob/main/20240522beauty_TOC.pdf)\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- The Innovation Press, LLC의 직원들께서 아름다운 형식으로 책을 재구성해 주어 즐거운 독서 경험을 선사했습니다. 전 세계 독자들에게 복잡한 유지보수비 없이 eBook을 배포하기 위해 Teachable 플랫폼을 선택했습니다. 신용카드 거래는 Teachable.com에 의해 기밀리에 안전하게 관리됩니다.\n\nTeachable.com에서의 eBook: $22.50\nhttps://drdataman.teachable.com/p/home\n\nAmazon.com에서의 인쇄판: $65 https://a.co/d/25FVsMx\n\n- 인쇄판은 윤광 표지, 컬러 인쇄, 아름다운 Springer 글꼴과 레이아웃을 사용하여 즐거운 독서를 위해 디자인되었습니다. 7.5 x 9.25 인치의 크기는 책장의 대부분 책들과 잘 어울립니다.\n- “이 책은 과거 시계열 분석 및 예측 분석, 이상 징후 탐지 등의 응용에 대한 깊은 이해력을 갖춘 쿠오의 증명서입니다. 이 책은 독자들에게 실세계의 도전 과제에 대처하는 데 필요한 기술을 제공합니다. 데이터 과학으로의 전직을 고려하는 분들에게 특히 가치 있습니다. 쿠오는 전통적이고 최첨단 기술 모두에 대해 상세히 탐구합니다. 쿠오는 신경망 및 다른 고급 알고리즘에 대한 토론을 통합하여 최신 동향과 발전을 반영합니다. 이는 독자들이 확립된 방법뿐만 아니라 데이터 과학 분야의 가장 최신이며 혁신적인 기술과 상호작용할 수 있도록 준비되어 있다는 것을 보장합니다. 쿠오의 생동감 넘치는 글쓰기 스타일로 이 책의 명확함과 접근성이 향상되었습니다. 그는 복잡한 수학적 및 통계적 개념을 실용적으로 만들어내며 엄격함을 희생하지 않고 다가갈 수 있게 만듭니다.”\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 현대 시계열 예측: 예측 분석과 이상 감지\n\n제로 장: 서문\n\n1장: 소개\n\n2장: 비즈니스 예측을 위한 예언자\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### Chapter 3: 튜토리얼 1 - 추세 + 계절성 + 휴일 및 이벤트\n\n### Chapter 4: 튜토리얼 2 - 추세 + 계절성 + 휴일 및 이벤트 + 자기회귀(AR) + 지연 회귀 변수 + 미래 회귀 변수\n\n### Chapter 5: 시계열의 변화점 탐지\n\n### Chapter 6: 시계열 확률 예측을 위한 몬테카를로 시뮬레이션\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n제목 7: 시계열 확률 예측을 위한 분위 회귀\n\n제목 8: 시계열 확률 예측을 위한 적응형 예측\n\n제목 9: 시계열 확률 예측을 위한 적응형 분위 회귀\n\n제목 10: 자동 ARIMA!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\"Chapter 11: 시계열 데이터 형식을 쉽게 만들어보기\n\nChapter 12: 다기간 확률 예측을 위한 선형 회귀\n\nChapter 13: 트리 기반 시계열 모델을 위한 피처 엔지니어링\n\nChapter 14: 다기간 시계열 예측을 위한 두 가지 주요 전략\"\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 15장: Tree 기반 XGB, LightGBM 및 CatBoost 모델을 활용한 다기간 시계열 확률 예측\n\n# 16장: 시계열 모델링 기법의 진화\n\n# 17장: Deep Learning 기반 DeepAR을 활용한 시계열 확률 예측\n\n# 18장: 응용 - 주식 가격에 대한 확률적 예측\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 19장: RNN에서 Transformer 기반 시계열 모델로\n\n# 20장: 해석 가능한 시계열 예측을 위한 Temporal Fusion Transformer\n\n# 21장: 시계열 예측을 위한 오픈소스 Lag-Llama 튜토리얼\n","ogImage":{"url":"/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_0.png","tag":["Tech"],"readingTime":26},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_0.png\" alt=\"Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting\"\u003e\u003c/p\u003e\n\u003cp\u003eSample eBook chapters (free): \u003ca href=\"https://github.com/dataman-git/modern-time-series/blob/main/20240522beauty_TOC.pdf\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://github.com/dataman-git/modern-time-series/blob/main/20240522beauty_TOC.pdf\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eeBook on Teachable.com: $22.50 \u003ca href=\"https://drdataman.teachable.com/p/home\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://drdataman.teachable.com/p/home\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eThe print edition on Amazon.com: $65 \u003ca href=\"https://a.co/d/25FVsMx\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://a.co/d/25FVsMx\u003c/a\u003e\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e위의 텍스트를 친근하게 번역하면 아래와 같습니다.\u003c/p\u003e\n\u003cp\u003e챕터 제목은 \"확률 예측\", \"다기간\", \"트리 기반\" 세 가지 중요한 개념을 다룹니다. 첫 번째로 \"확률 예측\"이 있습니다. 많은 실세계 응용 프로그램에서는 자원 계획이나 이상 징후 감지를 위해 예측 구간을 요청하며, 이는 1장에서 언급한 것과 같습니다. 이 책의 Part 2에서 언급한 네 가지 해결책 중 하나는 분위수 회귀입니다. 분위 예측은 예측 값을 매우 가능성이 높은 50 번째 백분위 값이거나 상위 90 번째 백분위 값과 같이 매우 낮은 가능성을 보여줍니다 (A) 그림에서 확인할 수 있습니다.\u003c/p\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_1.png\"\u003e\n\u003cp\u003e제목에서 두 번째 개념은 다기간 예측입니다. 우리는 일일 예측이 아닌 여러 기간을 위한 예측이 필요한 경우가 많습니다. 한 주간 휴가를 계획할 때, 한 날이 아닌 5일간의 날씨 예보가 필요합니다. 그러나 선형 회귀 또는 트리 기반 알고리즘은 일반적으로 점 추정만 제공합니다. 이러한 경우 어떻게 예측 프로세스를 설계하여 다기간을 제공할 수 있을까요? 직관적으로, 다음 기간을 예측하면 동일한 모델의 입력으로 사용하여 다다음 기간을 예측할 수도 있지 않을까요? 이 해결책은 인기가 있으며 (B) 그림에서 보이는 것과 같이 재귀적 예측 전략이라고 합니다. 재귀적 예측 전략은 모델의 예측을 후속 예측의 입력으로 사용합니다. 전략은 모델이 1 단계 앞으로 예측하기 위해 yt에서 yt-k까지의 과거 값을 사용합니다. 그런 다음 yt+1을 통합하고 다른 입력을 업데이트하여 yt+2를 예측합니다. 이 프로세스를 반복하여 모든 후속 시간 단계를 예측합니다. Darts 라이브러리에서도 이 전략을 할당할 수 있습니다.\u003c/p\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_2.png\"\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e새로운 시각으로 생각해보는 건 어때요? n 기간을 예측하는 것이 목표인 경우, 왜 n 개의 모델을 따로 구축하지 않을까요? 각 모델은 각각의 다음 n 기간을 예측할 것입니다. 이는 직접 예측 전략이라고 불립니다. Darts 라이브러리의 기본 전략이며, 라이브러리에 포함된 모든 모델에 대해 적용됩니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_3.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e마지막으로, 장 제목에 있는 \"tree-based\"에 대해 논의해보겠습니다. Tree-based 알고리즘들은 지도 학습 알고리즘입니다. 샘플을 행으로, 피처를 열로 갖는 데이터 프레임이 필요합니다. 단변량 시계열 데이터를 데이터 프레임으로 어떻게 변환할까요? 기본 아이디어는 단변량 시계열 데이터에서 샘플을 생성하는 것입니다. 이렇게 함으로써, 모델링을 위해 단변량 시계열 데이터를 데이터 프레임으로 재구성하고, 원하는 경우 단변량 시계열 데이터에서 피처를 생성할 수도 있습니다.\u003c/p\u003e\n\u003cp\u003e이번 장에서는 세 가지 tree-based 모델인 XGBoost (2016), LightGBM (2017), CatBoost (2018)에 대해 세 부분으로 소개하고, 각 알고리즘에 대해 간단히 설명할 것입니다. 세 모델 간의 차이점에 대해 궁금하다면, Figure (C)에 각 세 그래디언트 부스팅 기반 알고리즘의 특징을 강조한 표를 만들었습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_4.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e이번 장에서는 Darts 라이브러리를 사용할 것입니다. 시계열 모델링은 많은 기능과 데이터를 저장해야 하므로 Darts 라이브러리는 자체 데이터 형식을 갖추고 있습니다. 시간 순서에 풍부한 정보를 담을 수 있는 다양한 데이터 형식의 장점을 설명하기 위해 본 책은 '10장: 시계열 데이터 형식 쉽게 만들기'를 별도로 마련했습니다. 마지막으로, 이 장은 '11장: 다기간 확률 예측을 위한 자기회귀 선형 회귀'와 함께 읽을 수 있습니다. 두 장은 프로젝트에 적합한 모델을 선택하기 위해 선형 회귀 및 트리 기반 모델을 구축하는 데 도움이 됩니다.\u003c/p\u003e\n\u003cp\u003e이 장의 구조는 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e필요한 소프트웨어 요구 사항\u003c/li\u003e\n\u003cli\u003e판다스 데이터를 Darts 데이터 형식으로 변환하는 방법\u003c/li\u003e\n\u003cli\u003eXGB\u003c/li\u003e\n\u003cli\u003eLightGBM\u003c/li\u003e\n\u003cli\u003eCatBoost\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e파이썬 노트북은 이 Github 링크를 통해 다운로드할 수 있어요.\u003c/p\u003e\n\u003cp\u003e소프트웨어 요구 사항\u003c/p\u003e\n\u003cp\u003e기본 Darts 패키지는 Prophet, CatBoost, 그리고 LightGBM 종속성을 설치하지 않습니다. 0.25.0 버전을 기준으로 해서요. 직접 Prophet, CatBoost, 그리고 LightGBM 패키지를 설치해야 해요.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCatBoostModel: CatBoost 설치 가이드를 사용하여 catboost 패키지(버전 1.0.6 이상)를 설치합니다.\u003c/li\u003e\n\u003cli\u003eLightGBMModel: LightGBM 설치 가이드를 사용하여 lightgbm 패키지(버전 3.2.0 이상)를 설치합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e!pip install pandas numpy matplotlib darts lightgbm catboost\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음으로, 동일한 Walmart 매장 판매 데이터를 로드할 것입니다.\u003c/p\u003e\n\u003cp\u003e데이터\u003c/p\u003e\n\u003cp\u003e저는 Kaggle.com에 있는 Walmart 데이터셋을 사용할 것입니다. 이 데이터셋은 2010년 2월 5일부터 2012년 11월 1일까지의 주간 매장 매출 정보를 포함하고 있습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003eDate - 판매 주차\u003c/li\u003e\n\u003cli\u003eStore - 상점 번호\u003c/li\u003e\n\u003cli\u003e주간 매출 - 상점의 매출\u003c/li\u003e\n\u003cli\u003e휴일 플래그 - 주가 특별 휴일 주인지 여부 1 - 휴일 주 0 - 비 휴일 주\u003c/li\u003e\n\u003cli\u003e온도 - 판매일 온도\u003c/li\u003e\n\u003cli\u003e연료 가격 - 지역의 연료 비용\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e소매 판매에 영향을 미칠 수있는 두 가지 거시경제 지표 : 소비자 물가지수와 실업률. 데이터 세트는 Pandas 데이터 프레임으로로드됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e%matplotlib inline\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e pandas \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e pd\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e numpy \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e np\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e matplotlib \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e pyplot \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e plt\n\n# \u003cspan class=\"hljs-title class_\"\u003eGoogle\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eColab\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e google.\u003cspan class=\"hljs-property\"\u003ecolab\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e drive\ndrive.\u003cspan class=\"hljs-title function_\"\u003emount\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/content/gdrive'\u003c/span\u003e)\npath = \u003cspan class=\"hljs-string\"\u003e'/content/gdrive/My Drive/data/time_series'\u003c/span\u003e\n# \u003cspan class=\"hljs-attr\"\u003ehttps\u003c/span\u003e:\u003cspan class=\"hljs-comment\"\u003e//www.kaggle.com/datasets/yasserh/walmart-dataset\u003c/span\u003e\n\n# 데이터 로드\ndata = pd.\u003cspan class=\"hljs-title function_\"\u003eread_csv\u003c/span\u003e(path + \u003cspan class=\"hljs-string\"\u003e'/walmart.csv'\u003c/span\u003e, delimiter=\u003cspan class=\"hljs-string\"\u003e\",\"\u003c/span\u003e)\ndata[\u003cspan class=\"hljs-string\"\u003e'ds'\u003c/span\u003e] = pd.\u003cspan class=\"hljs-title function_\"\u003eto_datetime\u003c/span\u003e(data[\u003cspan class=\"hljs-string\"\u003e'Date'\u003c/span\u003e], format=\u003cspan class=\"hljs-string\"\u003e'%d-%m-%Y'\u003c/span\u003e)\ndata.\u003cspan class=\"hljs-property\"\u003eindex\u003c/span\u003e = data[\u003cspan class=\"hljs-string\"\u003e'ds'\u003c/span\u003e]\ndata = data.\u003cspan class=\"hljs-title function_\"\u003edrop\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Date'\u003c/span\u003e, axis=\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\ndata.\u003cspan class=\"hljs-title function_\"\u003ehead\u003c/span\u003e()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_5.png\"\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e제 10 장에서 쉽게 만들어진 Darts의 시계열 데이터 형식에 대해 배웠어요. Darts의 주요 데이터 클래스는 \"TimeSeries\" 클래스입니다. Darts는 값들을 다음과 같은 배열 모양으로 저장해요 (시간, 차원, 샘플):\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e시간: 위 예시에서처럼 143 주와 같은 시간 인덱스\u003c/li\u003e\n\u003cli\u003e차원: 다변량 시계열의 \"열\"\u003c/li\u003e\n\u003cli\u003e샘플: 기간에 대한 값들. 10 번째, 50 번째 백분위수와 90 번째 백분위수에 대한 그림 (A)에서처럼 확률론적 예측이라면 3개의 샘플이 있을 거예요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e저희는 월마트 매장 판매량을 불러오기 위해 .from_group_dataframe() 함수를 사용할 거예요. 그룹 ID는 \"Store\"예요. 따라서 group_cols 매개변수는 \"Store\"가 될 거예요. 시간 인덱스는 \"ds\" 열이에요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e darts \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTimeSeries\u003c/span\u003e\ndarts_group_df = \u003cspan class=\"hljs-title class_\"\u003eTimeSeries\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efrom_group_dataframe\u003c/span\u003e(data, group_cols=\u003cspan class=\"hljs-string\"\u003e'Store'\u003c/span\u003e, time_col=\u003cspan class=\"hljs-string\"\u003e'ds'\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"그룹/매장의 수는:\"\u003c/span\u003e, \u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(darts_group_df))\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"시간 기간의 수는: \"\u003c/span\u003e, \u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(darts_group_df[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]))\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e그룹/상점 수: 45\u003c/li\u003e\n\u003cli\u003e기간 수: 143\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e다음과 같이 컬럼을 나열할 수 있습니다. components 함수를 사용해봅시다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edarts_group_df[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e].\u003cspan class=\"hljs-property\"\u003ecomponents\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIndex(['Weekly_Sales', 'Holiday_Flag', 'Temperature', 'Fuel_Price', 'CPI', 'Unemployment'], dtype='object', name='component')\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eStore 1 매출 모델을 구축하기 위해 Store 1 데이터만 사용할 겁니다. \"darts_group_df[0]\"에 해당합니다. 이를 훈련 데이터와 테스트 데이터로 나눌 겁니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003estore1 = darts_group_df[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]\ntrain = store1[:\u003cspan class=\"hljs-number\"\u003e130\u003c/span\u003e]\ntest = store1[\u003cspan class=\"hljs-number\"\u003e130\u003c/span\u003e:]\n\u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(train), \u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(test) # (\u003cspan class=\"hljs-number\"\u003e130\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e13\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e우리의 목표 시리즈는 \"Weekly_Sales\"입니다. 다른 공선변수를 포함할 수도 있습니다. 시계열에서는 과거 공선변수와 미래 공선변수 두 종류가 있습니다. Darts 라이브러리는 동일한 용어를 사용합니다. 과거 공선변수는 연구 현재 시간까지의 변수입니다. 미래 공선변수는 미래에 관측 가능한 변수입니다. 미래 값을 어떻게 알 수 있는지 궁금할 수도 있습니다. 첫 번째 이유는 미래 휴일과 같이 결정론적 값이기 때문입니다. 두 번째 이유는 날씨 예측과 같은 다른 소스에서 예측된 값이기 때문입니다. 우리의 경우 \"Fuel_price\"와 \"CPI\"를 과거 공선변수로, \"Holiday_flag\"를 미래 공선변수로 포함할 것입니다. 훈련 데이터에서의 목표와 과거 공선변수는 130개의 데이터 포인트가 있습니다. 하지만 미래 공선변수는 실제로 미래까지 확장되어 143개의 데이터 포인트를 갖습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003etarget = train[\u003cspan class=\"hljs-string\"\u003e'Weekly_Sales'\u003c/span\u003e]\npast_cov = train[[\u003cspan class=\"hljs-string\"\u003e'Fuel_Price'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'CPI'\u003c/span\u003e]]\nfuture_cov = store1[\u003cspan class=\"hljs-string\"\u003e'Holiday_Flag'\u003c/span\u003e][:\u003cspan class=\"hljs-number\"\u003e143\u003c/span\u003e]\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e우니바리에이트 데이터부터 시작해보겠습니다.\u003c/p\u003e\n\u003cp\u003eXGB\u003c/p\u003e\n\u003cp\u003eXGBoost (Extreme Gradient Boosting)은 분류 및 회귀와 같은 지도 학습 작업에 널리 사용되며 효율성, 확장성 및 정확도로 알려져 있습니다. 가장 주목할 만한 기능은 오버피팅을 방지하기 위해 L1 및 L2 규제 기술이 포함되어 있다는 점입니다. 규제 패널티는 트리의 가중치, 리프 노드 값, 특성 중요도 점수에 적용되어 일반화 성능을 향상시키는 데 도움을 줍니다. 또 다른 기능으로는 병렬 및 분산 컴퓨팅을 지원하며 멀티코어 CPU 및 Apache Spark 및 Dask와 같은 분산 컴퓨팅 프레임워크에서 효율적인 학습이 가능합니다. 이 확장성은 대규모 데이터 처리에 적합하게 만듭니다. 그 외에도 이전 모델이 실수한 오류를 수정하기 위해 각 트리가 순차적으로 훈련되는 경사 부스팅 프레임워크를 계승했습니다. 전체적인 목표는 특정 손실 함수를 최소화하는 것입니다.\u003c/p\u003e\n\u003cp\u003e다음 코드는 Darts의 표준 모델링 구문입니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e darts.\u003cspan class=\"hljs-property\"\u003emodels\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eXGBModel\u003c/span\u003e\nn = \u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e\nchunk_length = n\nmodel = \u003cspan class=\"hljs-title class_\"\u003eXGBModel\u003c/span\u003e(\n    lags=\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e,\n    lags_past_covariates=\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e,\n    lags_future_covariates=[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e],\n    output_chunk_length=\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e,\n    \u003cspan class=\"hljs-title class_\"\u003eMulti\u003c/span\u003e_models = \u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e # optional\n    verbose=-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n)\nmodel.\u003cspan class=\"hljs-title function_\"\u003efit\u003c/span\u003e(target, past_covariates=past_cov, future_covariates=future_cov)\npred = model.\u003cspan class=\"hljs-title function_\"\u003epredict\u003c/span\u003e(n)\npred\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003efit() 함수의 \"target\"은 모델링을 위한 대상 시리즈입니다. 모델은 yt, yt-1, yt-2, ..., yt-12까지의 지연된 값들에 대한 \"lags\"를 필요로 합니다. 또한 다른 공변량을 지정할 수도 있습니다. 시계열 모델링에서 과거 공변량과 미래 공변량이라는 두 가지 넓은 유형의 공변량이 있습니다. Darts는 이 규칙을 따릅니다. lags_past_covariates는 xt, xt-1, ..., xt-12와 같이 지연된 과거 공변량을 나타냅니다. 약간 혼동스러운 lags_future_covariates 이름은 미래 공변량을 의미합니다. \"미래 공변량\"은 미래 시간 단계에서의 이러한 공변량의 값들을 의미하며, \"지연된\" 값들은 이전 시간 단계에서의 미래 공변량을 의미합니다. 이는 미래 t + n 단계에 대해 모델이 t부터 t + (n-1)까지의 공변량의 값을 고려한다는 것을 의미합니다.\u003c/p\u003e\n\u003cp\u003emulti_models 매개변수가 True로 설정된 것에 주목해주세요. 이는 모델에게 다중 기간 예측을 위한 직접 예측 전략 또는 재귀적 예측 전략을 사용할지 알려줍니다. 기본값은 True이며, 이는 직접 예측 전략을 사용한다는 것을 의미합니다.\u003c/p\u003e\n\u003cp\u003e입력 청크 길이와 출력 청크 길이에 관한 한 가지 추가적인 매개변수가 있습니다. 이는 단변량 시리즈에서 샘플을 생성하는 것과 관련이 있습니다. 그림 (F)는 y0에서 y15까지의 시리즈에서 생성된 샘플을 보여줍니다. 각 샘플에는 입력 청크와 출력 청크가 포함되어 있습니다. 입력 청크 길이가 5이고 출력 청크 길이가 2인 것을 가정해보세요. 첫 번째 샘플은 입력 청크로 y0 - y4를, 출력 청크로 y5, y6를 가지고 있습니다. 창이 시리즈를 따라 이동하여 샘플을 만들며, 이를 시리즈의 끝까지 반복합니다. 출력 청크 길이는 예측할 수 있는 가장 긴 길이를 정의합니다. 이를 12로 지정했습니다. 12 이상을 예측하려고 하면 오류 메시지가 출력됩니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_6.png\" alt=\"Dart data array\"\u003e\u003c/p\u003e\n\u003cp\u003eThe outputs are stored in the Dart data array:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_7.png\" alt=\"Dart data array\"\u003e\u003c/p\u003e\n\u003cp\u003eWe will plot the actual and the predicted values. We make this in a function for repeating use.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eplotit\u003c/span\u003e():\n  \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e matplotlib.pyplot \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e plt\n  target.plot(label=\u003cspan class=\"hljs-string\"\u003e'train'\u003c/span\u003e)\n  pred.plot(label=\u003cspan class=\"hljs-string\"\u003e'prediction'\u003c/span\u003e)\n  test[\u003cspan class=\"hljs-string\"\u003e'Weekly_Sales'\u003c/span\u003e][:n].plot(label=\u003cspan class=\"hljs-string\"\u003e'actual'\u003c/span\u003e)\n\n  \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e darts.metrics.metrics \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e mae, mape\n  \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Mean Absolute Error:\"\u003c/span\u003e, mae(test[\u003cspan class=\"hljs-string\"\u003e'Weekly_Sales'\u003c/span\u003e][:n], pred))\n  \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Mean Absolute Percentage Error\"\u003c/span\u003e, mape(test[\u003cspan class=\"hljs-string\"\u003e'Weekly_Sales'\u003c/span\u003e][:n], pred))\n\nplotit()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eMAPE 값은 10.55% 입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_8.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e이제 분위수 예측을 추가해보겠습니다. 모델에게 5개의 분위수를 생성해 달라고 요청하겠습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e darts.\u003cspan class=\"hljs-property\"\u003emodels\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eXGBModel\u003c/span\u003e\nn = \u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e\nchunk_length = n\nmodel = \u003cspan class=\"hljs-title class_\"\u003eXGBModel\u003c/span\u003e(\n    lags=\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e,\n    lags_past_covariates=\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e,\n    lags_future_covariates=[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e11\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e],\n    output_chunk_length=chunk_length,\n    likelihood = \u003cspan class=\"hljs-string\"\u003e'quantile'\u003c/span\u003e, # \u003cspan class=\"hljs-string\"\u003e'quantile'\u003c/span\u003e 또는 \u003cspan class=\"hljs-string\"\u003e'poisson'\u003c/span\u003e으로 설정 가능합니다.\n    # \u003cspan class=\"hljs-string\"\u003e'quantile'\u003c/span\u003e로 설정하면 sklearn.\u003cspan class=\"hljs-property\"\u003elinear_model\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eQuantileRegressor\u003c/span\u003e가 사용됩니다.\n    # \u003cspan class=\"hljs-string\"\u003e'poisson'\u003c/span\u003e으로 설정하면 sklearn.\u003cspan class=\"hljs-property\"\u003elinear_model\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ePoissonRegressor\u003c/span\u003e가 사용됩니다.\n    quantiles=[\u003cspan class=\"hljs-number\"\u003e0.01\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0.05\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0.50\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0.95\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0.99\u003c/span\u003e]\n)\nmodel.\u003cspan class=\"hljs-title function_\"\u003efit\u003c/span\u003e(target, past_covariates=past_cov, future_covariates=future_cov)\npred = model.\u003cspan class=\"hljs-title function_\"\u003epredict\u003c/span\u003e(n, num_samples=\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e)\npred\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e각 예측에는 5개의 샘플이 있습니다. 이는 5개의 분위 수치 값을 생성했기 때문입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_9.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e실제 값과 분위 예측을 시각화할 수 있습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edef \u003cspan class=\"hljs-title function_\"\u003eplotQuantile\u003c/span\u003e():\n    \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e matplotlib.\u003cspan class=\"hljs-property\"\u003epyplot\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e plt\n    target.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(label = \u003cspan class=\"hljs-string\"\u003e'train'\u003c/span\u003e)\n    pred.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(label = \u003cspan class=\"hljs-string\"\u003e'prediction'\u003c/span\u003e)\n    test[\u003cspan class=\"hljs-string\"\u003e'Weekly_Sales'\u003c/span\u003e][:n].\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(label = \u003cspan class=\"hljs-string\"\u003e'actual'\u003c/span\u003e)\n\n\u003cspan class=\"hljs-title function_\"\u003eplotQuantile\u003c/span\u003e()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e양자 예측은 다음과 같습니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_10.png\" alt=\"그림\"\u003e\u003c/p\u003e\n\u003cp\u003e모델을 구축하고 예측을 제공하는 것이 매우 쉽다는 것을 발견할 수 있을 것 입니다. 계속해서 LightGBM 모델을 구축해 봅시다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eLightGBM\u003c/p\u003e\n\u003cp\u003e\"제 12장: Tree-based Time Series Models의 Feature Engineering\"에서 lightGBM 모델을 구축한 적이 있지 않았나요? 정말이죠! 다른 점은 여기서는 Darts 라이브러리를 사용하여 lightGBM 모델을 구축할 것이라는 점입니다. 이전 장에서의 데이터 형식은 Pandas 데이터 프레임이었지만, 여기서는 Darts 데이터 object입니다. 그럼에도 불구하고 LightGBM이 무엇인지 설명해보겠습니다.\u003c/p\u003e\n\u003cp\u003eLightGBM (Light Gradient Boosting Machine)은 gradient-boosting 결정 트리 모델의 효율적이고 확장 가능한 학습을 위해 설계되었습니다. LightGBM은 빠른 속도, 메모리 효율성, 정확성으로 인해 인기를 얻었습니다. 그 중요한 특징은 다른 gradient-boosting 구현에서 사용되는 전통적인 수준별 전략이 아니라 잎별 성장 전략을 채택한다는 것입니다. 이 전략은 손실을 가장 효과적으로 최소화할 잎 노드를 선택하여 더 빠른 학습 시간을 제공합니다. 그 외에도 그래디언트 부스팅 알고리즘을 여전히 구현합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e darts.\u003cspan class=\"hljs-property\"\u003emodels\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eLightGBMModel\u003c/span\u003e\nn = \u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e\nmodel = \u003cspan class=\"hljs-title class_\"\u003eLightGBMModel\u003c/span\u003e(\n    lags=\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e,\n    lags_past_covariates=\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e,\n    lags_future_covariates=[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e],\n    output_chunk_length=\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e,\n    verbose=-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n)\nmodel.\u003cspan class=\"hljs-title function_\"\u003efit\u003c/span\u003e(target, past_covariates=past_cov, future_covariates=future_cov)\npred = model.\u003cspan class=\"hljs-title function_\"\u003epredict\u003c/span\u003e(n)\npred.\u003cspan class=\"hljs-title function_\"\u003evalues\u003c/span\u003e()\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e위의 코드는 XGB와 유사하여 더 이상 강조하지 않겠습니다. 그래프를 그려 성능 메트릭을 살펴봅시다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title function_\"\u003eplotit\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eMAPE는 5.09%입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_11.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이제 분위 예측을 포함해 봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003en = \u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e\nchunk_length = n\nmodel = \u003cspan class=\"hljs-title class_\"\u003eLightGBMModel\u003c/span\u003e(\n    lags=\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e,\n    lags_past_covariates=\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e,\n    lags_future_covariates=[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e11\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e],\n    output_chunk_length=chunk_length,\n    likelihood = \u003cspan class=\"hljs-string\"\u003e'quantile'\u003c/span\u003e, # quantile 또는 poisson 으로 설정할 수 있습니다.\n    # quantile로 설정하면 sklearn.\u003cspan class=\"hljs-property\"\u003elinear_model\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eQuantileRegressor\u003c/span\u003e가 사용됩니다.\n    # poisson으로 설정하면 sklearn.\u003cspan class=\"hljs-property\"\u003elinear_model\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ePoissonRegressor\u003c/span\u003e가 사용됩니다.\n    quantiles=[\u003cspan class=\"hljs-number\"\u003e0.01\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0.05\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0.50\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0.95\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0.99\u003c/span\u003e]\n)\nmodel.\u003cspan class=\"hljs-title function_\"\u003efit\u003c/span\u003e(target, past_covariates=past_cov, future_covariates=future_cov)\npred = model.\u003cspan class=\"hljs-title function_\"\u003epredict\u003c/span\u003e(n, num_samples=\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e)\npred\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e분위 예측을 그래프로 확인해볼 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title function_\"\u003eplotQuantile\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e양자수치 예측값은:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_12.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e좋아요. 이미 두 개의 모델이 구축되었습니다. 이제 CatBoost 모델을 구축해봅시다.\u003c/p\u003e\n\u003cp\u003eCatBoost\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eCatBoost은 \"Category Boosting\"의 약자입니다. 범주형 기능을 효율적으로 처리할 수 있도록 특별히 설계되었으므로 다양한 분류 및 회귀 작업에 적합합니다. 이는 원-핫 인코딩과 같은 전처리가 필요 없이 범주형 기능을 직접 처리할 수 있습니다. CatBoost는 카테고리별 통계 속성에 기초하여 최적 분할점을 찾아 효율적으로 범주형 변수를 처리하는 Ordered Boosting이라는 새로운 알고리즘을 사용합니다. 이외에도 결정 트리 앙상블을 구축하기 위해 그래디언트 부스팅의 구현을 상속받습니다. 각 트리는 이전 모델의 오류를 최소화하도록 학습됩니다. 최적 매개변수를 찾기 위해 그래디언트 강하 최적화 알고리즘을 사용합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e darts.\u003cspan class=\"hljs-property\"\u003emodels\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCatBoostModel\u003c/span\u003e\nn = \u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e\nchunk_length = n\nmodel = \u003cspan class=\"hljs-title class_\"\u003eCatBoostModel\u003c/span\u003e(\n    lags=\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e,\n    lags_past_covariates=\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e,\n    lags_future_covariates=[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e],\n    output_chunk_length=\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e,\n    verbose=-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n)\nmodel.\u003cspan class=\"hljs-title function_\"\u003efit\u003c/span\u003e(target, past_covariates=past_cov, future_covariates=future_cov)\npred = model.\u003cspan class=\"hljs-title function_\"\u003epredict\u003c/span\u003e(n)\npred\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드에 CatBoostModel을 삽입하여 내용을 그대로 유지하시면 됩니다.\u003c/p\u003e\n\u003cp\u003e결과를 그래프로 출력해보겠습니다:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title function_\"\u003eplotit\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eMAPE는 5.96% 입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_13.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e모델에 분위 예측을 포함해 봅시다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003en = \u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e\nchunk_length = n\nmodel = \u003cspan class=\"hljs-title class_\"\u003eCatBoostModel\u003c/span\u003e(\n    lags=\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e,\n    lags_past_covariates=\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e,\n    lags_future_covariates=[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e11\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e],\n    output_chunk_length=chunk_length,\n    likelihood = \u003cspan class=\"hljs-string\"\u003e'quantile'\u003c/span\u003e, # \u003cspan class=\"hljs-string\"\u003e'quantile'\u003c/span\u003e 또는 \u003cspan class=\"hljs-string\"\u003e'poisson'\u003c/span\u003e으로 설정할 수 있습니다.\n    # \u003cspan class=\"hljs-string\"\u003e'quantile'\u003c/span\u003e로 설정하면 sklearn.\u003cspan class=\"hljs-property\"\u003elinear_model\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eQuantileRegressor\u003c/span\u003e가 사용됩니다.\n    # \u003cspan class=\"hljs-string\"\u003e'poisson'\u003c/span\u003e으로 설정하면 sklearn.\u003cspan class=\"hljs-property\"\u003elinear_model\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ePoissonRegressor\u003c/span\u003e가 사용됩니다.\n    quantiles=[\u003cspan class=\"hljs-number\"\u003e0.01\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0.05\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0.50\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0.95\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e0.99\u003c/span\u003e]\n)\nmodel.\u003cspan class=\"hljs-title function_\"\u003efit\u003c/span\u003e(target, past_covariates=past_cov, future_covariates=future_cov)\npred = model.\u003cspan class=\"hljs-title function_\"\u003epredict\u003c/span\u003e(n, num_samples=\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e)\npred\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e양자화 예측값을 그릴 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title function_\"\u003eplotQuantile\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 차트는 다음과 같습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting_14.png\" alt=\"Tree-based Models\"\u003e\u003c/p\u003e\n\u003cp\u003e결론\u003c/p\u003e\n\u003cp\u003e이 장에서는 Darts 라이브러리를 사용하여 세 가지 인기있는 트리 기반 시계열 모델을 구축했습니다. 우리는 다기간 예측 및 예측 불확실성의 사용 사례에 중점을 두었습니다. 다음에 시계열 모델을 구축하여 다기간 예측 및 예측 불확실성을 제공해야 할 때, 세 가지 트리 기반 모델과 다기간 확률적 예측을 위한 자동 회귀 선형 회귀 모델을 함께 생성하는 것을 권장합니다. 우승 모델을 찾기 위해 11 장에서 선형 회귀 모델과 결합하여 사용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 장은 트리 기반 시계열 모델에 대한 현대적 기법 시리즈를 마무리합니다. 다음 장에서는 딥러닝 기반 시계열 모델에 대한 시리즈를 시작할 것입니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e시계열 모델링 기법의 진화\u003c/li\u003e\n\u003cli\u003eRNN/LSTM용 DeepAR\u003c/li\u003e\n\u003cli\u003e응용 - 주식 가격에 대한 확률 예측\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e참고문헌\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e(XGB) Chen, T., \u0026#x26; Guestrin, C. (2016). XGBoost: A Scalable Tree Boosting System. In Proceedings of the 22nd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining (pp. 785–794). ACM. \u003ca href=\"https://dl.acm.org/doi/10.1145/2939672.2939785\" rel=\"nofollow\" target=\"_blank\"\u003e링크\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e(LightGBM) Ke, G., Meng, Q., Finley, T., Wang, T., Chen, W., Ma, W., … \u0026#x26; Li, Q. (2017). LightGBM: A Highly Efficient Gradient Boosting Decision Tree. In Advances in Neural Information Processing Systems (pp. 3146–3154). \u003ca href=\"https://proceedings.neurips.cc/paper/2017/file/6449f44a102fde848669bdd9eb6b76fa-Paper.pdf\" rel=\"nofollow\" target=\"_blank\"\u003e링크\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e(CatBoost) Prokhorenkova, L., Gusev, G., Vorobev, A., Dorogush, A. V., \u0026#x26; Gulin, A. (2018). CatBoost: unbiased boosting with categorical features. In Advances in Neural Information Processing Systems (pp. 6638–6648). \u003ca href=\"https://proceedings.neurips.cc/paper/2018/file/0d4724e4525b451dae9f6cb39983e6cd-Paper.pdf\" rel=\"nofollow\" target=\"_blank\"\u003e링크\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e샘플 eBook 챕터 (무료): \u003ca href=\"https://github.com/dataman-git/modern-time-series/blob/main/20240522beauty_TOC.pdf\" rel=\"nofollow\" target=\"_blank\"\u003e링크\u003c/a\u003e\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003eThe Innovation Press, LLC의 직원들께서 아름다운 형식으로 책을 재구성해 주어 즐거운 독서 경험을 선사했습니다. 전 세계 독자들에게 복잡한 유지보수비 없이 eBook을 배포하기 위해 Teachable 플랫폼을 선택했습니다. 신용카드 거래는 Teachable.com에 의해 기밀리에 안전하게 관리됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eTeachable.com에서의 eBook: $22.50\n\u003ca href=\"https://drdataman.teachable.com/p/home\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://drdataman.teachable.com/p/home\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eAmazon.com에서의 인쇄판: $65 \u003ca href=\"https://a.co/d/25FVsMx\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://a.co/d/25FVsMx\u003c/a\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e인쇄판은 윤광 표지, 컬러 인쇄, 아름다운 Springer 글꼴과 레이아웃을 사용하여 즐거운 독서를 위해 디자인되었습니다. 7.5 x 9.25 인치의 크기는 책장의 대부분 책들과 잘 어울립니다.\u003c/li\u003e\n\u003cli\u003e“이 책은 과거 시계열 분석 및 예측 분석, 이상 징후 탐지 등의 응용에 대한 깊은 이해력을 갖춘 쿠오의 증명서입니다. 이 책은 독자들에게 실세계의 도전 과제에 대처하는 데 필요한 기술을 제공합니다. 데이터 과학으로의 전직을 고려하는 분들에게 특히 가치 있습니다. 쿠오는 전통적이고 최첨단 기술 모두에 대해 상세히 탐구합니다. 쿠오는 신경망 및 다른 고급 알고리즘에 대한 토론을 통합하여 최신 동향과 발전을 반영합니다. 이는 독자들이 확립된 방법뿐만 아니라 데이터 과학 분야의 가장 최신이며 혁신적인 기술과 상호작용할 수 있도록 준비되어 있다는 것을 보장합니다. 쿠오의 생동감 넘치는 글쓰기 스타일로 이 책의 명확함과 접근성이 향상되었습니다. 그는 복잡한 수학적 및 통계적 개념을 실용적으로 만들어내며 엄격함을 희생하지 않고 다가갈 수 있게 만듭니다.”\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e현대 시계열 예측: 예측 분석과 이상 감지\u003c/h1\u003e\n\u003cp\u003e제로 장: 서문\u003c/p\u003e\n\u003cp\u003e1장: 소개\u003c/p\u003e\n\u003cp\u003e2장: 비즈니스 예측을 위한 예언자\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch3\u003eChapter 3: 튜토리얼 1 - 추세 + 계절성 + 휴일 및 이벤트\u003c/h3\u003e\n\u003ch3\u003eChapter 4: 튜토리얼 2 - 추세 + 계절성 + 휴일 및 이벤트 + 자기회귀(AR) + 지연 회귀 변수 + 미래 회귀 변수\u003c/h3\u003e\n\u003ch3\u003eChapter 5: 시계열의 변화점 탐지\u003c/h3\u003e\n\u003ch3\u003eChapter 6: 시계열 확률 예측을 위한 몬테카를로 시뮬레이션\u003c/h3\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e제목 7: 시계열 확률 예측을 위한 분위 회귀\u003c/p\u003e\n\u003cp\u003e제목 8: 시계열 확률 예측을 위한 적응형 예측\u003c/p\u003e\n\u003cp\u003e제목 9: 시계열 확률 예측을 위한 적응형 분위 회귀\u003c/p\u003e\n\u003cp\u003e제목 10: 자동 ARIMA!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\"Chapter 11: 시계열 데이터 형식을 쉽게 만들어보기\u003c/p\u003e\n\u003cp\u003eChapter 12: 다기간 확률 예측을 위한 선형 회귀\u003c/p\u003e\n\u003cp\u003eChapter 13: 트리 기반 시계열 모델을 위한 피처 엔지니어링\u003c/p\u003e\n\u003cp\u003eChapter 14: 다기간 시계열 예측을 위한 두 가지 주요 전략\"\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e15장: Tree 기반 XGB, LightGBM 및 CatBoost 모델을 활용한 다기간 시계열 확률 예측\u003c/h1\u003e\n\u003ch1\u003e16장: 시계열 모델링 기법의 진화\u003c/h1\u003e\n\u003ch1\u003e17장: Deep Learning 기반 DeepAR을 활용한 시계열 확률 예측\u003c/h1\u003e\n\u003ch1\u003e18장: 응용 - 주식 가격에 대한 확률적 예측\u003c/h1\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e19장: RNN에서 Transformer 기반 시계열 모델로\u003c/h1\u003e\n\u003ch1\u003e20장: 해석 가능한 시계열 예측을 위한 Temporal Fusion Transformer\u003c/h1\u003e\n\u003ch1\u003e21장: 시계열 예측을 위한 오픈소스 Lag-Llama 튜토리얼\u003c/h1\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-07-09-Tree-basedXGBLightGBMandCatBoostModelsforMulti-periodTimeSeriesProbabilisticForecasting"},"buildId":"xwOwpfNxF5xANgUpiyc2H","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>