<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Python에서 Factory Method 패턴 사용하는 방법 | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2024-07-14-FactoryMethodpatterninPython" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Python에서 Factory Method 패턴 사용하는 방법 | TIL" data-gatsby-head="true"/><meta property="og:title" content="Python에서 Factory Method 패턴 사용하는 방법 | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/TIL/assets/img/2024-07-14-FactoryMethodpatterninPython_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2024-07-14-FactoryMethodpatterninPython" data-gatsby-head="true"/><meta name="twitter:title" content="Python에서 Factory Method 패턴 사용하는 방법 | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/assets/img/2024-07-14-FactoryMethodpatterninPython_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2024-07-14 23:43" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/0eef537492fed77a.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/0eef537492fed77a.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/post/%5Bslug%5D-8ded8b979ba73586.js" defer=""></script><script src="/TIL/_next/static/M7pU9hOcx8u_ZIFMf95sd/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/M7pU9hOcx8u_ZIFMf95sd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Python에서 Factory Method 패턴 사용하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Python에서 Factory Method 패턴 사용하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jul 14, 2024</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>디자인 패턴은 미래에 이를 유지하는 것이 더 쉬운 방식으로 반복되는 여러 가지 문제를 해결할 수 있게 해줍니다.</p>
<p>이를 감안할 때 각 디자인 패턴을 알아야 특정 문제를 해결할 때 더 큰 유연성을 가질 수 있습니다.</p>
<p>내가 보는 문제는 보통 이 디자인 패턴 중 하나를 배우려고 할 때 실제로 직면한 문제를 알지 못한 채로 아주 긴 설명들을 마주하게 된다는 것입니다.</p>
<p>이 이야기에서는 공장 메서드 패턴을 가능한 간단히 설명해 보겠습니다. 이렇게 함으로써 해당 패턴이 해결하고 있는 문제와 어떻게 구현되는지 이해할 수 있을 것입니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<img src="/TIL/assets/img/2024-07-14-FactoryMethodpatterninPython_0.png">
<h1>Factory Method 패턴을 사용하지 않은 예제</h1>
<p>다른 종류의 문서인 이력서와 보고서를 가진 예제를 만들어 봅시다.</p>
<p>이러한 문서 유형은 고유한 생성자를 가질 것입니다:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> <span class="hljs-variable constant_">ABC</span>, abstractmethod

# 제품 인터페이스 정의
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Document</span>(<span class="hljs-variable constant_">ABC</span>):
    @abstractmethod
    def <span class="hljs-title function_">create</span>(self):
        pass

# 구체적인 제품 생성
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Resume</span>(<span class="hljs-title class_">Document</span>):
    def <span class="hljs-title function_">create</span>(self):
        <span class="hljs-keyword">return</span> <span class="hljs-string">"이력서 생성됨"</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Report</span>(<span class="hljs-title class_">Document</span>):
    def <span class="hljs-title function_">create</span>(self):
        <span class="hljs-keyword">return</span> <span class="hljs-string">"보고서 생성됨"</span>
</code></pre>
<p>이후에는 이 유형의 문서를 선택하는 함수가 있을 것입니다:</p>
<pre><code class="hljs language-js">def <span class="hljs-title function_">create_document</span>(<span class="hljs-attr">document_type</span>: str) -> <span class="hljs-title class_">Document</span>:
    <span class="hljs-keyword">if</span> document_type == <span class="hljs-string">"resume"</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Resume</span>()
    elif document_type == <span class="hljs-string">"report"</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Report</span>()
    <span class="hljs-attr">else</span>:
        raise <span class="hljs-title class_">ValueError</span>(f<span class="hljs-string">"알 수 없는 문서 유형: {document_type}"</span>)
</code></pre>
<p>이후 팩토리 메서드 패턴을 통해 이 함수의 구현을 개선할 수 있음을 나중에 확인하게 될 것입니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>나머지 코드는 문서 유형을 사용하는 방법을 보여줍니다:</p>
<pre><code class="hljs language-js">def <span class="hljs-title function_">client_code</span>(<span class="hljs-attr">document_type</span>: str):
    <span class="hljs-variable language_">document</span> = <span class="hljs-title function_">create_document</span>(document_type)
    <span class="hljs-title function_">print</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">create</span>())

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    <span class="hljs-title function_">print</span>(<span class="hljs-string">"이력서 생성:"</span>)
    <span class="hljs-title function_">client_code</span>(<span class="hljs-string">"resume"</span>)
    
    <span class="hljs-title function_">print</span>(<span class="hljs-string">"\n보고서 생성:"</span>)
    <span class="hljs-title function_">client_code</span>(<span class="hljs-string">"report"</span>)
</code></pre>
<h1>팩토리 메서드 사용</h1>
<p>리팩토링에서는 여전히 각 객체의 생성자가 있습니다:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-python"><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABC, abstractmethod

<span class="hljs-comment"># 제품 인터페이스 정의</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Document</span>(<span class="hljs-title class_ inherited__">ABC</span>):
<span class="hljs-meta">    @abstractmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">create</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">pass</span>

<span class="hljs-comment"># 구체적인 제품 생성</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Resume</span>(<span class="hljs-title class_ inherited__">Document</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">create</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-string">"이력서 생성됨"</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Report</span>(<span class="hljs-title class_ inherited__">Document</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">create</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-string">"보고서 생성됨"</span>
</code></pre>
<p>그러나 이제 각 유형의 문서 생성을 탈 중앙화했습니다:</p>
<pre><code class="hljs language-python"><span class="hljs-comment"># 팩토리 메서드를 사용하여 생성자 클래스 정의</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">DocumentCreator</span>(<span class="hljs-title class_ inherited__">ABC</span>):
<span class="hljs-meta">    @abstractmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">factory_method</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">pass</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">create_document</span>(<span class="hljs-params">self</span>):
        <span class="hljs-comment"># 제품을 얻기 위해 팩토리 메서드 호출</span>
        document = self.factory_method()
        <span class="hljs-keyword">return</span> document.create()

<span class="hljs-comment"># 구체적인 생성자 구현</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ResumeCreator</span>(<span class="hljs-title class_ inherited__">DocumentCreator</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">factory_method</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> Resume()

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ReportCreator</span>(<span class="hljs-title class_ inherited__">DocumentCreator</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">factory_method</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> Report()
</code></pre>
<p>새로운 문서 유형을 추가하는 것은 새로운 구체적인 생성자 클래스를 만드는 것만큼 간단합니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>나머지 코드는 문서 유형을 사용하는 방법을 보여줍니다:</p>
<pre><code class="hljs language-js">def <span class="hljs-title function_">client_code</span>(<span class="hljs-attr">creator</span>: <span class="hljs-title class_">DocumentCreator</span>):
    <span class="hljs-title function_">print</span>(creator.<span class="hljs-title function_">create_document</span>())

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    <span class="hljs-title function_">print</span>(<span class="hljs-string">"이력서 생성 중:"</span>)
    resume_creator = <span class="hljs-title class_">ResumeCreator</span>()
    <span class="hljs-title function_">client_code</span>(resume_creator)
    
    <span class="hljs-title function_">print</span>(<span class="hljs-string">"\n보고서 생성 중:"</span>)
    report_creator = <span class="hljs-title class_">ReportCreator</span>()
    <span class="hljs-title function_">client_code</span>(report_creator)
</code></pre>
<h1>차이점 설명</h1>
<p>주요 차이점은 팩토리 메서드 패턴을 사용하지 않을 때, 객체를 프로그램 로직을 정의하는 곳과 동일한 위치에서 생성한다는 것입니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_document</span>(<span class="hljs-params">document_type: <span class="hljs-built_in">str</span></span>) -> Document:
    <span class="hljs-keyword">if</span> document_type == <span class="hljs-string">"resume"</span>:
        <span class="hljs-keyword">return</span> Resume()
    <span class="hljs-keyword">elif</span> document_type == <span class="hljs-string">"report"</span>:
        <span class="hljs-keyword">return</span> Report()
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f"Unknown document type: <span class="hljs-subst">{document_type}</span>"</span>)
</code></pre>
<p>위의 예제는 매우 간단합니다. 새로운 문서 유형을 추가하거나 삭제할 때 이 논리를 변경하는 것은 비교적 쉬우지만, 더 복잡한 경우에는 더 비용이 많이 들 수 있습니다.</p>
<p>게다가, 이것에는 훌륭한 논리가 없습니다. 각 if/else 이후에 일련의 동작이 수행된다고 상상해보세요.</p>
<h2>비교</h2>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>팩토리 메소드 없이: 문서 생성 로직은 create_document 함수에 중앙 집중화되어 있습니다. 이는 더 간단하지만 코드를 유연하게 만들고 유지하기 어렵게 만듭니다. 새로운 유형의 문서를 추가하려면 create_document 함수를 수정해야 하며, 이로 인해 버그가 발생할 수 있고 전체 함수의 로직을 이해해야 합니다.</li>
<li>팩토리 메소드 사용: 생성 로직이 분산됩니다. 각 구체적인 생성자는 자체 유형의 문서를 생성하는 방법을 알고 있습니다. 새로운 유형의 문서를 추가하는 것은 새로운 구체적인 생성자 클래스를 만드는 것만큼 간답습니다. 이 접근 방식은 개방/폐쇄 원칙을 준수하며 코드를 보다 모듈식으로 만들고 확장하기 쉽게 만듭니다.</li>
</ul>
<p><img src="/TIL/assets/img/2024-07-14-FactoryMethodpatterninPython_1.png" alt="Factory Method Pattern"></p>
<h1>어떻게 인식할까요?</h1>
<p>이 패턴을 사용해야 하는 시점은 로직 일부가 서로 다른 객체 유형을 생성하는 if/else if/else를 사용하고 있을 때 가장 쉽게 인식할 수 있습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>예시</h1>
<p>def mainfuntion():
if option==1:
Object1=Object_constructor()
action1()
action2()
elif option==2:
Object2=Object_constructor2()
action3()
action4()
else:
Object3=Object_constructor3()
action5()
action6()</p>
<p>우리는 보듯이, 이 논리는 사용된 객체의 유형에 매우 의존합니다. 다른 유형의 객체를 사용해야 한다면 프로그램의 논리를 바꿀 필요가 있습니다.</p>
<p>이러한 패턴을 보게 되면, 팩토리 메서드를 사용하여 개선을 고려할 수 있습니다.</p>
<h1>결론</h1>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>인터넷에서 찾을 수 있는 것들과는 조금 다른 방식으로 이 디자인 패턴을 설명해 보았어요. 가능한 가장 간단한 방법으로 설명해 보았답니다.</p>
<p>저는 이러한 패턴에 대해 다양한 정보원에서 배우는 것이 이상적이라고 생각해요. 각각의 예시를 보면서 개념을 더 깊이 이해할 수 있을 거예요.</p>
<p>이야기가 마음에 들기를 바랍니다.</p>
<p>관심 가져 주셔서 정말 감사합니다!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Python에서 Factory Method 패턴 사용하는 방법","description":"","date":"2024-07-14 23:43","slug":"2024-07-14-FactoryMethodpatterninPython","content":"\n\n디자인 패턴은 미래에 이를 유지하는 것이 더 쉬운 방식으로 반복되는 여러 가지 문제를 해결할 수 있게 해줍니다.\n\n이를 감안할 때 각 디자인 패턴을 알아야 특정 문제를 해결할 때 더 큰 유연성을 가질 수 있습니다.\n\n내가 보는 문제는 보통 이 디자인 패턴 중 하나를 배우려고 할 때 실제로 직면한 문제를 알지 못한 채로 아주 긴 설명들을 마주하게 된다는 것입니다.\n\n이 이야기에서는 공장 메서드 패턴을 가능한 간단히 설명해 보겠습니다. 이렇게 함으로써 해당 패턴이 해결하고 있는 문제와 어떻게 구현되는지 이해할 수 있을 것입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n\u003cimg src=\"/TIL/assets/img/2024-07-14-FactoryMethodpatterninPython_0.png\" /\u003e\n\n# Factory Method 패턴을 사용하지 않은 예제\n\n다른 종류의 문서인 이력서와 보고서를 가진 예제를 만들어 봅시다.\n\n이러한 문서 유형은 고유한 생성자를 가질 것입니다:\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nfrom abc import ABC, abstractmethod\n\n# 제품 인터페이스 정의\nclass Document(ABC):\n    @abstractmethod\n    def create(self):\n        pass\n\n# 구체적인 제품 생성\nclass Resume(Document):\n    def create(self):\n        return \"이력서 생성됨\"\n\nclass Report(Document):\n    def create(self):\n        return \"보고서 생성됨\"\n```\n\n이후에는 이 유형의 문서를 선택하는 함수가 있을 것입니다:\n\n```js\ndef create_document(document_type: str) -\u003e Document:\n    if document_type == \"resume\":\n        return Resume()\n    elif document_type == \"report\":\n        return Report()\n    else:\n        raise ValueError(f\"알 수 없는 문서 유형: {document_type}\")\n```\n\n이후 팩토리 메서드 패턴을 통해 이 함수의 구현을 개선할 수 있음을 나중에 확인하게 될 것입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n나머지 코드는 문서 유형을 사용하는 방법을 보여줍니다:\n\n```js\ndef client_code(document_type: str):\n    document = create_document(document_type)\n    print(document.create())\n\nif __name__ == \"__main__\":\n    print(\"이력서 생성:\")\n    client_code(\"resume\")\n    \n    print(\"\\n보고서 생성:\")\n    client_code(\"report\")\n```\n\n# 팩토리 메서드 사용\n\n리팩토링에서는 여전히 각 객체의 생성자가 있습니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nfrom abc import ABC, abstractmethod\n\n# 제품 인터페이스 정의\nclass Document(ABC):\n    @abstractmethod\n    def create(self):\n        pass\n\n# 구체적인 제품 생성\nclass Resume(Document):\n    def create(self):\n        return \"이력서 생성됨\"\n\nclass Report(Document):\n    def create(self):\n        return \"보고서 생성됨\"\n```\n\n그러나 이제 각 유형의 문서 생성을 탈 중앙화했습니다:\n\n```python\n# 팩토리 메서드를 사용하여 생성자 클래스 정의\nclass DocumentCreator(ABC):\n    @abstractmethod\n    def factory_method(self):\n        pass\n\n    def create_document(self):\n        # 제품을 얻기 위해 팩토리 메서드 호출\n        document = self.factory_method()\n        return document.create()\n\n# 구체적인 생성자 구현\nclass ResumeCreator(DocumentCreator):\n    def factory_method(self):\n        return Resume()\n\nclass ReportCreator(DocumentCreator):\n    def factory_method(self):\n        return Report()\n```\n\n새로운 문서 유형을 추가하는 것은 새로운 구체적인 생성자 클래스를 만드는 것만큼 간단합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n나머지 코드는 문서 유형을 사용하는 방법을 보여줍니다:\n\n```js\ndef client_code(creator: DocumentCreator):\n    print(creator.create_document())\n\nif __name__ == \"__main__\":\n    print(\"이력서 생성 중:\")\n    resume_creator = ResumeCreator()\n    client_code(resume_creator)\n    \n    print(\"\\n보고서 생성 중:\")\n    report_creator = ReportCreator()\n    client_code(report_creator)\n```\n\n# 차이점 설명\n\n주요 차이점은 팩토리 메서드 패턴을 사용하지 않을 때, 객체를 프로그램 로직을 정의하는 곳과 동일한 위치에서 생성한다는 것입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\ndef create_document(document_type: str) -\u003e Document:\n    if document_type == \"resume\":\n        return Resume()\n    elif document_type == \"report\":\n        return Report()\n    else:\n        raise ValueError(f\"Unknown document type: {document_type}\")\n```\n\n위의 예제는 매우 간단합니다. 새로운 문서 유형을 추가하거나 삭제할 때 이 논리를 변경하는 것은 비교적 쉬우지만, 더 복잡한 경우에는 더 비용이 많이 들 수 있습니다.\n\n게다가, 이것에는 훌륭한 논리가 없습니다. 각 if/else 이후에 일련의 동작이 수행된다고 상상해보세요.\n\n## 비교\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 팩토리 메소드 없이: 문서 생성 로직은 create_document 함수에 중앙 집중화되어 있습니다. 이는 더 간단하지만 코드를 유연하게 만들고 유지하기 어렵게 만듭니다. 새로운 유형의 문서를 추가하려면 create_document 함수를 수정해야 하며, 이로 인해 버그가 발생할 수 있고 전체 함수의 로직을 이해해야 합니다.\n- 팩토리 메소드 사용: 생성 로직이 분산됩니다. 각 구체적인 생성자는 자체 유형의 문서를 생성하는 방법을 알고 있습니다. 새로운 유형의 문서를 추가하는 것은 새로운 구체적인 생성자 클래스를 만드는 것만큼 간답습니다. 이 접근 방식은 개방/폐쇄 원칙을 준수하며 코드를 보다 모듈식으로 만들고 확장하기 쉽게 만듭니다.\n\n![Factory Method Pattern](/TIL/assets/img/2024-07-14-FactoryMethodpatterninPython_1.png)\n\n# 어떻게 인식할까요?\n\n이 패턴을 사용해야 하는 시점은 로직 일부가 서로 다른 객체 유형을 생성하는 if/else if/else를 사용하고 있을 때 가장 쉽게 인식할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n# 예시\ndef mainfuntion():\n    if option==1:\n        Object1=Object_constructor()\n        action1()\n        action2()\n    elif option==2:\n        Object2=Object_constructor2()\n        action3()\n        action4()\n    else:\n        Object3=Object_constructor3()\n        action5()\n        action6()\n\n\n우리는 보듯이, 이 논리는 사용된 객체의 유형에 매우 의존합니다. 다른 유형의 객체를 사용해야 한다면 프로그램의 논리를 바꿀 필요가 있습니다.\n\n이러한 패턴을 보게 되면, 팩토리 메서드를 사용하여 개선을 고려할 수 있습니다.\n\n# 결론\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n인터넷에서 찾을 수 있는 것들과는 조금 다른 방식으로 이 디자인 패턴을 설명해 보았어요. 가능한 가장 간단한 방법으로 설명해 보았답니다.\n\n저는 이러한 패턴에 대해 다양한 정보원에서 배우는 것이 이상적이라고 생각해요. 각각의 예시를 보면서 개념을 더 깊이 이해할 수 있을 거예요.\n\n이야기가 마음에 들기를 바랍니다.\n\n관심 가져 주셔서 정말 감사합니다!","ogImage":{"url":"/TIL/assets/img/2024-07-14-FactoryMethodpatterninPython_0.png"},"coverImage":"/TIL/assets/img/2024-07-14-FactoryMethodpatterninPython_0.png","tag":["Tech"],"readingTime":7},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e디자인 패턴은 미래에 이를 유지하는 것이 더 쉬운 방식으로 반복되는 여러 가지 문제를 해결할 수 있게 해줍니다.\u003c/p\u003e\n\u003cp\u003e이를 감안할 때 각 디자인 패턴을 알아야 특정 문제를 해결할 때 더 큰 유연성을 가질 수 있습니다.\u003c/p\u003e\n\u003cp\u003e내가 보는 문제는 보통 이 디자인 패턴 중 하나를 배우려고 할 때 실제로 직면한 문제를 알지 못한 채로 아주 긴 설명들을 마주하게 된다는 것입니다.\u003c/p\u003e\n\u003cp\u003e이 이야기에서는 공장 메서드 패턴을 가능한 간단히 설명해 보겠습니다. 이렇게 함으로써 해당 패턴이 해결하고 있는 문제와 어떻게 구현되는지 이해할 수 있을 것입니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-14-FactoryMethodpatterninPython_0.png\"\u003e\n\u003ch1\u003eFactory Method 패턴을 사용하지 않은 예제\u003c/h1\u003e\n\u003cp\u003e다른 종류의 문서인 이력서와 보고서를 가진 예제를 만들어 봅시다.\u003c/p\u003e\n\u003cp\u003e이러한 문서 유형은 고유한 생성자를 가질 것입니다:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e abc \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eABC\u003c/span\u003e, abstractmethod\n\n# 제품 인터페이스 정의\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDocument\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eABC\u003c/span\u003e):\n    @abstractmethod\n    def \u003cspan class=\"hljs-title function_\"\u003ecreate\u003c/span\u003e(self):\n        pass\n\n# 구체적인 제품 생성\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eResume\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eDocument\u003c/span\u003e):\n    def \u003cspan class=\"hljs-title function_\"\u003ecreate\u003c/span\u003e(self):\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"이력서 생성됨\"\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReport\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eDocument\u003c/span\u003e):\n    def \u003cspan class=\"hljs-title function_\"\u003ecreate\u003c/span\u003e(self):\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"보고서 생성됨\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이후에는 이 유형의 문서를 선택하는 함수가 있을 것입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edef \u003cspan class=\"hljs-title function_\"\u003ecreate_document\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003edocument_type\u003c/span\u003e: str) -\u003e \u003cspan class=\"hljs-title class_\"\u003eDocument\u003c/span\u003e:\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e document_type == \u003cspan class=\"hljs-string\"\u003e\"resume\"\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eResume\u003c/span\u003e()\n    elif document_type == \u003cspan class=\"hljs-string\"\u003e\"report\"\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReport\u003c/span\u003e()\n    \u003cspan class=\"hljs-attr\"\u003eelse\u003c/span\u003e:\n        raise \u003cspan class=\"hljs-title class_\"\u003eValueError\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"알 수 없는 문서 유형: {document_type}\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이후 팩토리 메서드 패턴을 통해 이 함수의 구현을 개선할 수 있음을 나중에 확인하게 될 것입니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e나머지 코드는 문서 유형을 사용하는 방법을 보여줍니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edef \u003cspan class=\"hljs-title function_\"\u003eclient_code\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003edocument_type\u003c/span\u003e: str):\n    \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003ecreate_document\u003c/span\u003e(document_type)\n    \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreate\u003c/span\u003e())\n\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e __name__ == \u003cspan class=\"hljs-string\"\u003e\"__main__\"\u003c/span\u003e:\n    \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"이력서 생성:\"\u003c/span\u003e)\n    \u003cspan class=\"hljs-title function_\"\u003eclient_code\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"resume\"\u003c/span\u003e)\n    \n    \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"\\n보고서 생성:\"\u003c/span\u003e)\n    \u003cspan class=\"hljs-title function_\"\u003eclient_code\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"report\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e팩토리 메서드 사용\u003c/h1\u003e\n\u003cp\u003e리팩토링에서는 여전히 각 객체의 생성자가 있습니다:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e abc \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e ABC, abstractmethod\n\n\u003cspan class=\"hljs-comment\"\u003e# 제품 인터페이스 정의\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDocument\u003c/span\u003e(\u003cspan class=\"hljs-title class_ inherited__\"\u003eABC\u003c/span\u003e):\n\u003cspan class=\"hljs-meta\"\u003e    @abstractmethod\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecreate\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself\u003c/span\u003e):\n        \u003cspan class=\"hljs-keyword\"\u003epass\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e# 구체적인 제품 생성\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eResume\u003c/span\u003e(\u003cspan class=\"hljs-title class_ inherited__\"\u003eDocument\u003c/span\u003e):\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecreate\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself\u003c/span\u003e):\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"이력서 생성됨\"\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReport\u003c/span\u003e(\u003cspan class=\"hljs-title class_ inherited__\"\u003eDocument\u003c/span\u003e):\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecreate\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself\u003c/span\u003e):\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"보고서 생성됨\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그러나 이제 각 유형의 문서 생성을 탈 중앙화했습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-comment\"\u003e# 팩토리 메서드를 사용하여 생성자 클래스 정의\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDocumentCreator\u003c/span\u003e(\u003cspan class=\"hljs-title class_ inherited__\"\u003eABC\u003c/span\u003e):\n\u003cspan class=\"hljs-meta\"\u003e    @abstractmethod\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efactory_method\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself\u003c/span\u003e):\n        \u003cspan class=\"hljs-keyword\"\u003epass\u003c/span\u003e\n\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecreate_document\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself\u003c/span\u003e):\n        \u003cspan class=\"hljs-comment\"\u003e# 제품을 얻기 위해 팩토리 메서드 호출\u003c/span\u003e\n        document = self.factory_method()\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e document.create()\n\n\u003cspan class=\"hljs-comment\"\u003e# 구체적인 생성자 구현\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eResumeCreator\u003c/span\u003e(\u003cspan class=\"hljs-title class_ inherited__\"\u003eDocumentCreator\u003c/span\u003e):\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efactory_method\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself\u003c/span\u003e):\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e Resume()\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReportCreator\u003c/span\u003e(\u003cspan class=\"hljs-title class_ inherited__\"\u003eDocumentCreator\u003c/span\u003e):\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efactory_method\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself\u003c/span\u003e):\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e Report()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e새로운 문서 유형을 추가하는 것은 새로운 구체적인 생성자 클래스를 만드는 것만큼 간단합니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e나머지 코드는 문서 유형을 사용하는 방법을 보여줍니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edef \u003cspan class=\"hljs-title function_\"\u003eclient_code\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ecreator\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDocumentCreator\u003c/span\u003e):\n    \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(creator.\u003cspan class=\"hljs-title function_\"\u003ecreate_document\u003c/span\u003e())\n\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e __name__ == \u003cspan class=\"hljs-string\"\u003e\"__main__\"\u003c/span\u003e:\n    \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"이력서 생성 중:\"\u003c/span\u003e)\n    resume_creator = \u003cspan class=\"hljs-title class_\"\u003eResumeCreator\u003c/span\u003e()\n    \u003cspan class=\"hljs-title function_\"\u003eclient_code\u003c/span\u003e(resume_creator)\n    \n    \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"\\n보고서 생성 중:\"\u003c/span\u003e)\n    report_creator = \u003cspan class=\"hljs-title class_\"\u003eReportCreator\u003c/span\u003e()\n    \u003cspan class=\"hljs-title function_\"\u003eclient_code\u003c/span\u003e(report_creator)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e차이점 설명\u003c/h1\u003e\n\u003cp\u003e주요 차이점은 팩토리 메서드 패턴을 사용하지 않을 때, 객체를 프로그램 로직을 정의하는 곳과 동일한 위치에서 생성한다는 것입니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecreate_document\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003edocument_type: \u003cspan class=\"hljs-built_in\"\u003estr\u003c/span\u003e\u003c/span\u003e) -\u003e Document:\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e document_type == \u003cspan class=\"hljs-string\"\u003e\"resume\"\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e Resume()\n    \u003cspan class=\"hljs-keyword\"\u003eelif\u003c/span\u003e document_type == \u003cspan class=\"hljs-string\"\u003e\"report\"\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e Report()\n    \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003eraise\u003c/span\u003e ValueError(\u003cspan class=\"hljs-string\"\u003ef\"Unknown document type: \u003cspan class=\"hljs-subst\"\u003e{document_type}\u003c/span\u003e\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위의 예제는 매우 간단합니다. 새로운 문서 유형을 추가하거나 삭제할 때 이 논리를 변경하는 것은 비교적 쉬우지만, 더 복잡한 경우에는 더 비용이 많이 들 수 있습니다.\u003c/p\u003e\n\u003cp\u003e게다가, 이것에는 훌륭한 논리가 없습니다. 각 if/else 이후에 일련의 동작이 수행된다고 상상해보세요.\u003c/p\u003e\n\u003ch2\u003e비교\u003c/h2\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e팩토리 메소드 없이: 문서 생성 로직은 create_document 함수에 중앙 집중화되어 있습니다. 이는 더 간단하지만 코드를 유연하게 만들고 유지하기 어렵게 만듭니다. 새로운 유형의 문서를 추가하려면 create_document 함수를 수정해야 하며, 이로 인해 버그가 발생할 수 있고 전체 함수의 로직을 이해해야 합니다.\u003c/li\u003e\n\u003cli\u003e팩토리 메소드 사용: 생성 로직이 분산됩니다. 각 구체적인 생성자는 자체 유형의 문서를 생성하는 방법을 알고 있습니다. 새로운 유형의 문서를 추가하는 것은 새로운 구체적인 생성자 클래스를 만드는 것만큼 간답습니다. 이 접근 방식은 개방/폐쇄 원칙을 준수하며 코드를 보다 모듈식으로 만들고 확장하기 쉽게 만듭니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-14-FactoryMethodpatterninPython_1.png\" alt=\"Factory Method Pattern\"\u003e\u003c/p\u003e\n\u003ch1\u003e어떻게 인식할까요?\u003c/h1\u003e\n\u003cp\u003e이 패턴을 사용해야 하는 시점은 로직 일부가 서로 다른 객체 유형을 생성하는 if/else if/else를 사용하고 있을 때 가장 쉽게 인식할 수 있습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003e예시\u003c/h1\u003e\n\u003cp\u003edef mainfuntion():\nif option==1:\nObject1=Object_constructor()\naction1()\naction2()\nelif option==2:\nObject2=Object_constructor2()\naction3()\naction4()\nelse:\nObject3=Object_constructor3()\naction5()\naction6()\u003c/p\u003e\n\u003cp\u003e우리는 보듯이, 이 논리는 사용된 객체의 유형에 매우 의존합니다. 다른 유형의 객체를 사용해야 한다면 프로그램의 논리를 바꿀 필요가 있습니다.\u003c/p\u003e\n\u003cp\u003e이러한 패턴을 보게 되면, 팩토리 메서드를 사용하여 개선을 고려할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e인터넷에서 찾을 수 있는 것들과는 조금 다른 방식으로 이 디자인 패턴을 설명해 보았어요. 가능한 가장 간단한 방법으로 설명해 보았답니다.\u003c/p\u003e\n\u003cp\u003e저는 이러한 패턴에 대해 다양한 정보원에서 배우는 것이 이상적이라고 생각해요. 각각의 예시를 보면서 개념을 더 깊이 이해할 수 있을 거예요.\u003c/p\u003e\n\u003cp\u003e이야기가 마음에 들기를 바랍니다.\u003c/p\u003e\n\u003cp\u003e관심 가져 주셔서 정말 감사합니다!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-07-14-FactoryMethodpatterninPython"},"buildId":"M7pU9hOcx8u_ZIFMf95sd","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>