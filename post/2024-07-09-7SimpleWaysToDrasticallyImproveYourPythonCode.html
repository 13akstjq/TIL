<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>당신의 Python 코드를 쉽게 개선할 수 있는 7가지 방법 | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2024-07-09-7SimpleWaysToDrasticallyImproveYourPythonCode" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="당신의 Python 코드를 쉽게 개선할 수 있는 7가지 방법 | TIL" data-gatsby-head="true"/><meta property="og:title" content="당신의 Python 코드를 쉽게 개선할 수 있는 7가지 방법 | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-07-09-7SimpleWaysToDrasticallyImproveYourPythonCode_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2024-07-09-7SimpleWaysToDrasticallyImproveYourPythonCode" data-gatsby-head="true"/><meta name="twitter:title" content="당신의 Python 코드를 쉽게 개선할 수 있는 7가지 방법 | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-07-09-7SimpleWaysToDrasticallyImproveYourPythonCode_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2024-07-09 19:45" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/post/%5Bslug%5D-5ecfd58aae5a7e3d.js" defer=""></script><script src="/TIL/_next/static/B2TETmJptwqhd4vJNGZoH/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/B2TETmJptwqhd4vJNGZoH/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">당신의 Python 코드를 쉽게 개선할 수 있는 7가지 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="당신의 Python 코드를 쉽게 개선할 수 있는 7가지 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jul 9, 2024</span><span class="posts_reading_time__f7YPP">15<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-07-09-7SimpleWaysToDrasticallyImproveYourPythonCode&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<img src="/TIL/assets/img/2024-07-09-7SimpleWaysToDrasticallyImproveYourPythonCode_0.png">
<h2>소개</h2>
<p>파이썬은 데이터 과학과 함께 올라와 프로그래밍 세계에서 인기를 얻었는데, 이에는 아주 좋은 이유가 있습니다. 이 언어에는 C와 밀접한 연계성과 다양한 문제를 원활하게 해결하기 위한 적절한 타입 및 함수 시스템을 포함한 여러 이점이 있습니다. 이러한 이점 중 하나는 파이썬이 작성, 학습 및 해독이 굉장히 쉬운 언어임에 틀림없습니다. 이로 인해 파이썬은 대부분의 기본 계산 작업에 대한 고수준 스크립팅 언어로 변모했습니다.</p>
<p>파이썬의 사용 편의성은 특히 데이터에 보다 집중하고 싶은 과학자들이나 구문에 덜 관심을 갖고 싶은 초보 프로그래머들을 위한 매력적인 선택지가 됩니다. 그러나 사용 편의성과 접근성과 함께 성능에 주목할 필요가 있습니다. 또한 파이썬 같은 스크립팅 언어는 일반적으로 방법을 잘못 사용하더라도 파악하지 못하거나 직면할 필요가 없는 공간을 훨씬 더 많이 제공하는 경향이 있습니다. 다행히도 새로운 파이썬 사용자들을 위해서 파이썬은 광범위한 기능을 도입하여 사용하기 쉽고 동적으로 타입이 지정된 스크립팅 언어의 단점을 완화할 수 있었습니다. 좋은 프로그래밍 관행과 함께 파이썬의 타입 시스템과 생태계를 효과적으로 활용함으로써 파이썬의 다양한 단점을 완화하고 해당 언어에서 훨씬 더 나은 코드를 작성할 수 있습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>추상화</h2>
<p>어떤 객체 지향 프로그래밍 언어에서 가장 먼저 이야기해야 하는 것은 추상화입니다. 추상화는 상속을 사용하여 훨씬 더 많은 기능을 더 적은 코드로 만들 수 있는 일반적인 프로그래밍 개념입니다. 상속은 추상화를 용이하게 하는 방법으로, 하위 클래스를 통해 기능을 전파하는 클래스 유형이 있는 방식입니다. 이것이 추상화 개념의 원래 출발점이자 객체 지향 프로그래밍 개념의 기반이 됩니다. 여기서 "메서드"는 해당 유형에 적합하게 설계된 클래스의 내부 함수를 의미합니다.</p>
<p>추상화는 많은 다른 유형과 함께 사용할 수 있는 일반적인 함수를 만들 수 있게 해줍니다. 이게 바로 계층적 하위 클래스를 사용하여 어떤 유형인지 결정할 수 있는 것입니다. 이것은 다형성이라고도 하며, 하나의 서브루틴으로 여러 유형의 데이터 구조를 '변형'할 수 있는 능력을 의미합니다. Python에서는 메서드와 속성이 클래스를 구성합니다. 그런 다음 이 클래스의 하위 클래스가 될 수 있으며, 속성과 메서드를 상속받을 수 있습니다. 이것이 상속이라고 하며, Simula 시뮬레이션 언어에서 공개된 추상화 개념의 원조입니다.</p>
<p>프로그래머로서 들을 수 있는 일반적인 조언 중 하나는 "일반적인 함수를 작성하라"는 것입니다. 이 조언은 의미가 있습니다. 함수가 보다 일반적일수록 프로젝트에 최종적으로 들어가는 코드가 적어집니다. 이는 또한 사물이 파괴될 기회가 적어지고, 파괴된 경우에는 해결책을 형성하기 위해 한 곳만 살펴보면 되는 것을 의미합니다. 그러나 이 조언에서 종종 빠지는 중요한 부분은 일반적인 함수를 계층적 추상화 수준으로 설계해야 한다는 것입니다. 다시 말해, 우리는 모든 차량을 위해 함수를 작성하고, 필요한 경우에만 트럭을 위한 함수를 작성해야 합니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이렇게 보면, 파이썬이 제공하는 기능과 메서드 기능도 자연스럽게 패턴이 있는 것 같아요. 함수는 매우 일반적인 호출에 사용하고, 메서드는 특정 유형의 호출에 더 적합하며 특히 상속을 원하는 경우 더 좋아요. Python에서 추상화 기법을 사용하려면, 우선 클래스를 만들어야 해요:</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, color: <span class="hljs-built_in">str</span></span>):
        self.name = name
        self.color = color
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">honk</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">print</span>(self.name + <span class="hljs-string">" has just honked at us in their "</span> + self.color + <span class="hljs-string">" car"</span>)
</code></pre>
<p>이 간단한 클래스에는 name 및 color 속성과 honk 메서드가 있습니다. 자동차를 만들고 honk 메서드를 호출하면 작은 메시지가 출력됩니다.</p>
<pre><code class="hljs language-python">mycar = Car(<span class="hljs-string">"the mystery machine"</span>, <span class="hljs-string">"green, flower-covered"</span>)
mycar.honk()

the mystery machine has just honked at us <span class="hljs-keyword">in</span> their green, flower-covered car
선택이 삭제됨
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이것은 좋아요. 하지만 저는 트럭도 가지고 있어요. 제가 시골 소녀니까요. 그래서 우리는 트럭을 만들어야 할 거예요. 괄호 안에 Car 클래스를 Truck 클래스에 제공해주면 Car의 모든 속성과 메소드를 상속받을 수 있어요. 데이터인 이름과 색깔은 같이 저장하지만, 우리의 honk 메소드는 Car의 버전이 차량이 Car임을 언급하기 때문에 변경되어야 해요. 따라서 이를 고려하여, 우리는 서브 클래스에 새로운 메소드를 작성함으로써 상속된 메소드를 오버로드할 수 있어요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Truck</span>(<span class="hljs-title class_">Car</span>):
    def <span class="hljs-title function_">honk</span>(self):
        <span class="hljs-title function_">print</span>(self.<span class="hljs-property">name</span> + <span class="hljs-string">" has just honked at us in their "</span> + self.<span class="hljs-property">color</span> + <span class="hljs-string">" truck"</span>)
</code></pre>
<p>추상화하지 않은 경우 이 코드는 다음과 같아요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Truck</span>(<span class="hljs-title class_">Car</span>):
    def <span class="hljs-title function_">__init__</span>(self, name, color : str):
        self.<span class="hljs-property">name</span> = name
        self.<span class="hljs-property">color</span> = color
    def <span class="hljs-title function_">honk</span>(self):
        <span class="hljs-title function_">print</span>(self.<span class="hljs-property">name</span> + <span class="hljs-string">" has just honked at us in their "</span> + self.<span class="hljs-property">color</span> + <span class="hljs-string">" truck"</span>)
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-python">mytruck = Truck(<span class="hljs-string">"my large truck"</span>, <span class="hljs-string">"red"</span>)
mytruck.honk()

my large truck가 빨간 트럭으로 우리에게 경적을 울렸어요
</code></pre>
<p>우리는 완전히 새로운 Car를 생성할 수도 있습니다. 여기서 중요한 점은 pass 키워드를 사용하여 Python의 들여쓰기 문법을 활용해 생성자를 이름만 정의하는 것입니다.</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sedan</span>(<span class="hljs-title class_ inherited__">Car</span>):
    <span class="hljs-keyword">pass</span>
</code></pre>
<p>훨씬 큰 사용 사례에서 추상화가 Python에서 훌륭한 코드를 작성하는 데 절대적으로 필요한 이유를 이해하기 쉽습니다. 다행히 이 기술은 사용하기 매우 쉽습니다, 그리고 제가 논의하고 싶은 다음 기술도 마찬가지입니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>표현식들</h2>
<p>파이썬과 유사한 많은 다양한 스크립팅 언어를 사용한 후에 얘기하지만, 표현식들이 이런 언어에서 작업할 때 가장 귀중한 자산 중 하나라는 걸 자신 있게 말씀드릴 수 있어요. 표현식들은 제너레이터, 리스트 및 기타 유형을 아주 간결하고 효과적으로 생성하는 방법입니다. 일반적으로 기존의 for 루프를 통해 작성되는 것과 같은 형태로 구성될 수 있는 요소들을 생성하는 방법입니다. 예를 들어, 1부터 30까지의 제곱을 생성하는 다음 예제를 고려해보세요:</p>
<pre><code class="hljs language-js">values = []
<span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">30</span>):
    values.<span class="hljs-title function_">append</span>(x ** <span class="hljs-number">2</span>)
</code></pre>
<p>이것은 for 루프 방식으로, 이는 파이썬에서 반복 가능한 요소와 함께 작업하는 핵심적인 방법입니다. 이 접근 방식의 for 루프 버전은 리스트를 초기화하고 각 반복에서 해당 리스트에 새 요소를 추가하는 것을 요구합니다. 이 방식은 효율적이지만, 요소를 생성하는 데 제너레이터를 사용하는 것만큼 효과적이지는 않습니다. 후자는 더 간결할 뿐만 아니라 성능도 더 나아집니다. 위 예제의 코드는 간단한 리스트 표현식으로 한 줄로 변환됩니다. 제너레이터를 생성하려면 사실상 역방향 for 루프를 작성하고 리스트 구분 기호로 둘러싸면 됩니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">values = [x ** <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">30</span>)]
</code></pre>
<p>위에 대한 설명은 지능 표현식 또는 생성기가 다음 반복 단계의 실행에 매핑된 반환을 만들기위한 함수를 만들어 냄을 의미합니다. 좀 더 간단한 용어로 설명하면, 생성기는 함수에서 반복자를 통해 반환을 만들기 위해 특별히 만들어지는 반면 for 루프는 더 개방적이며 단순히 반복자를 만듭니다. 이로 인해 Python에서 작업을 크게 빠르게 만들며 코드를 훨씬 더 간결하게 만듭니다. 그러나 각 요소에 대해 반환을 기대하지 않는 경우에는 다른 방법을 사용하는 것이 더 나을 수 있습니다.</p>
<h2>람다 및 맵</h2>
<p>Python 코드를 극적으로 개선하는 다음 간단한 기술은 iterable의 요소들을 횡단하여 함수를 호출하는 조합인 람다와 맵을 사용하는 것입니다. 현재 Python의 가장 일반적인 응용 분야가 과학 컴퓨팅이라는 점을 고려하면, 람다와 맵은 놀라울 만큼 많이 사용되는 Python 기능입니다. 둘의 다양성은 많은 다른 도메인에서 함께 기능을 통해 뛰어나기 때문에, 이 기술은 확실히 알아두어야 할 가치가 있습니다. 특히 데이터 과학을 위해 Python 언어를 사용하는 사람들뿐만 아니라요.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Lambda는 호출 가능한 함수 유형으로 신속하게 표현식을 작성하는 데 사용됩니다. 이를 통해 간단한 클로저 함수를 생성할 수 있습니다. 이 함수들은 인수로 제공되어 다양한 가능성을 제공할 수 있습니다. Python에서 람다를 사용하는 것은 비교적 간단합니다. 람다 키워드에 인수를 제공한 다음 콜론과 함수의 논리를 추가합니다.</p>
<pre><code class="hljs language-js">f = lambda <span class="hljs-attr">x</span>: x + <span class="hljs-number">5</span>
<span class="hljs-title function_">f</span>(<span class="hljs-number">5</span>)

<span class="hljs-number">10</span>
</code></pre>
<p>이 개념은 함수를 생성하는 능력 때문에 상당히 강력합니다. 그러나 이 기술이 빛나는 한 가지 맥락은 이러한 함수들을 반복 가능한 객체에 매핑하는 것입니다. 이를 통해 생성기와 연관된 생성 측면 없이 배열을 변경할 수 있습니다. 이 경우 함수는 몇 가지 차이점이 있는 생성기와 유사한 기능을 만들기 위해 요소를 직접 제공받습니다.</p>
<pre><code class="hljs language-js">f = lambda <span class="hljs-attr">x</span>: x ** <span class="hljs-number">2</span>

m = <span class="hljs-title function_">map</span>(f, values)
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>우리가 맵을 사용하여 함수를 값에 매핑하면 맵을 단순히 리스트로 캐스팅하여 제곱된 배열을 얻을 수 있습니다:</p>
<pre><code class="hljs language-js">squared = <span class="hljs-title function_">list</span>(m)
[<span class="hljs-number">6</span>,
 <span class="hljs-number">9</span>,
 <span class="hljs-number">14</span>,
 <span class="hljs-number">21</span>,
 <span class="hljs-number">30</span>,
 <span class="hljs-number">41</span>,
 <span class="hljs-number">54</span>,
 <span class="hljs-number">69</span>,
 <span class="hljs-number">86</span>,
 <span class="hljs-number">105</span>,
....
</code></pre>
<p>이 두 가지를 결합함으로써 코드를 압축하는 방법이 얼마나 쉬운지 알 수 있습니다!</p>
<h2>추출</h2>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>다음 소프트웨어를 개선하는 방법은 일반적으로 우수한 프로그래밍 조언입니다. 추출 기술은 대규모 하위 루틴에서 코드를 추출하여 작은 하위 루틴의 시리즈로 압축하는 실천 방법입니다. 전체 작업을 처리하는 하나의 함수를 작성하는 대신 해당 작업의 각 단계는 프로젝트 내의 다른 함수로 전달됩니다. 이 기술에 대해 중요성과 중요성을 노래한 몇 가지 기사를 작성했습니다. 위대한 소프트웨어 공학 프로젝트를 만들 때 매우 중요합니다.</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">quiz_user</span>():
    correct = []
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"이름은 뭐에요?"</span>)
    x = <span class="hljs-built_in">input</span>()
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"2 + 2는 뭐에요?"</span>)
    answer = <span class="hljs-built_in">input</span>()

    <span class="hljs-keyword">if</span> answer == <span class="hljs-string">"4"</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"정답"</span>)
        correct.append(<span class="hljs-literal">True</span>)
    <span class="hljs-keyword">else</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"틀렸어요."</span>)
        correct.append(<span class="hljs-literal">False</span>)

    <span class="hljs-built_in">print</span>(<span class="hljs-string">"하늘의 색깔은 뭐에요?"</span>)
    answer = <span class="hljs-built_in">input</span>()

    <span class="hljs-keyword">if</span> answer == <span class="hljs-string">"파란색"</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"정답"</span>)
        correct.append(<span class="hljs-literal">True</span>)
    <span class="hljs-keyword">else</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"틀렸어요."</span>)
        correct.append(<span class="hljs-literal">False</span>)

    <span class="hljs-keyword">return</span> correct
</code></pre>
<p>이 함수에는 여러 단계가 포함되어 있고 최종적으로 이름이 시행하는 것 이상을 수행합니다. 이는 이상적이지 않습니다. 각 함수가 직접적으로 작업을 수행하도록 원합니다. 그리고 목적 외 작은 작업은 함수 바깥에 두는 것이 좋습니다. 추출 프로세스는 몇 가지 핵심 단계로 수행됩니다. 첫 번째 단계에서 함수의 다른 부분과 입력 및 출력을 고려합니다. 함수를 그룹화한 후에는 함수를 함수 밖으로 추출하고 함수를 호출합니다. 이 특정 상황에서는 더 다재다능한 질문 요청 함수를 만드는 것이 더 적합할 수 있지만, 이 경우에는 각각의 출력이 알고리즘 과정의 새로운 단계인 것처럼 가정하여 함수의 반환을 생성합니다.</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">ask_name</span>():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"이름은 뭐에요?"</span>)
    x = <span class="hljs-built_in">input</span>()
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"안녕 "</span> + x)
    <span class="hljs-keyword">return</span> x

<span class="hljs-keyword">def</span> <span class="hljs-title function_">question1</span>():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"2 + 2는 뭐에요?"</span>)
    answer = <span class="hljs-built_in">input</span>()

    <span class="hljs-keyword">if</span> answer == <span class="hljs-string">"4"</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"정답"</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
    <span class="hljs-keyword">else</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"틀렸어요."</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">question2</span>():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"하늘의 색깔은 뭐에요?"</span>)
    answer = <span class="hljs-built_in">input</span>()

    <span class="hljs-keyword">if</span> answer == <span class="hljs-string">"파란색"</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"정답"</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
    <span class="hljs-keyword">else</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"틀렸어요."</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">quiz_user</span>():
    correct = []
    ask_name()
    correct = [f() <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> (question1, question2)]
    <span class="hljs-keyword">return</span> correct
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>추출 기술을 사용하면 코드를 다양한 방법으로 개선할 수 있어요. 먼저, 함수를 작성할 때 코드를 함수 내에서 재사용할 수 있어요. 특정 알고리즘을 더 큰 함수 내에 그대로 두면, 전혀 다른 목적을 가진 코드 일부에 액세스하지 못할 수도 있어요. 추출 사용의 또 다른 이점은 프로젝트가 훨씬 더 조직적으로 됩니다. 함수는 짧고 중첩을 최소화하는 것이 좋아요. 이 모든 것은 논리적인 코드를 고유한 범위로 가져오는 것이 종종 매우 좋은 선택이 될 수 있다는 것을 말해요.</p>
<h2>del</h2>
<p>다음으로 논의하고 싶은 파이썬 기능은 'del' 입니다. 이 키워드는 파이썬 객체를 메모리에서 제거하는 데 사용됩니다. 첫눈에는 그다지 중요하지 않아 보이지만, 파이썬이 사용하기 쉬운 스크립트 언어이기 때문에 가능한 한 자주 사용하고 싶은 파이썬 기능 중 하나에요. 'del'은 종종 간과되지만, 이 기능은 메모리를 보존하는 데 매우 도움이 될 수 있어요.</p>
<pre><code class="hljs language-js">del squared
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>파이썬과 같은 스크립트 언어에서는 메모리 및 성능 관리 방법이 더 제한적이기 때문에 계산 시간을 단축하고 메모리를 해제하는 데 도움이 되는 모든 것을 활용하고 싶을 것입니다. 파이썬은 사실 유사한 스크립트 언어들 중에서 적어도 힙에서 빠르게 무언가를 제거하고 가비지 수집하는 키워드 del 이 하나는 있어서 어느 정도 독특합니다. 그런 관점에서 이 기능을 확실히 활용하고 싶습니다.</p>
<h2>break 와 continue</h2>
<p>당신의 도구 상자에 꼭 있어야 할 또 다른 중요한 기술은 break 와 continue 키워드입니다. 이 두 키워드는 모두 반복적 루프 문맥에서 특히 사용되며, 반복적 루프를 더 최적화하기 위해 break 를 사용하여 반복을 중단하거나 continue 를 사용하여 다음 요소로 건너뛸 수 있습니다.</p>
<pre><code class="hljs language-js">mydata = [<span class="hljs-title class_">None</span>, <span class="hljs-title class_">None</span>, <span class="hljs-number">55</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>, <span class="hljs-title class_">None</span>, <span class="hljs-number">2</span>, <span class="hljs-title class_">None</span>, <span class="hljs-number">73</span>, <span class="hljs-number">22</span>, <span class="hljs-title class_">None</span>, <span class="hljs-title class_">None</span>, <span class="hljs-title class_">None</span>, <span class="hljs-number">36</span>, <span class="hljs-string">"stop here please"</span>, <span class="hljs-number">23</span>]
newvalues = []
<span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-attr">mydata</span>:
    <span class="hljs-keyword">if</span> x == <span class="hljs-title class_">None</span>:
        <span class="hljs-keyword">continue</span>
    elif x == <span class="hljs-string">"stop here please"</span>:
        <span class="hljs-keyword">break</span>
    newvalues.<span class="hljs-title function_">append</span>(x)

newvalues
[<span class="hljs-number">55</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>, <span class="hljs-number">2</span>, <span class="hljs-number">73</span>, <span class="hljs-number">22</span>, <span class="hljs-number">36</span>]
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>당연히, break와 continue는 각각 자신의 사용 사례를 가지고 있습니다. 예를 들어 조건부로 특정 요소에 대해 작업하고 싶을 때를 생각해보세요. 이러한 키워드에는 끝이 없는 사용 방법이 있으며, 여러분의 도구 상자에 이러한 간단한 도구들을 유지하는 것이 좋은 아이디어입니다.</p>
<h2>else는 최대한 사용을 줄입니다</h2>
<p>코드 개선에 관한 참고 사항으로 다룰 마지막 주제는 else를 최대한 줄이는 방법입니다. 저는 큰 else 문과 중첩된 조건문 같은 것은 가능한 한 피해야 한다고 생각합니다. else 자체가 서브루틴이라는 것을 이해해야 합니다. 이것은 우리 함수 아래에서 정의된 완전히 독립적인 스코프의 또 다른 레이어입니다. else 키워드를 사용하는 많은 경우가 있지만, 우리 코드를 더 읽기 쉽고 기능적으로 더 효율적으로 만들기 위해 사용하지 않아야 할 때도 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pump</span>:
    def <span class="hljs-title function_">__init__</span>(self):
        self.<span class="hljs-property">pumping</span> = <span class="hljs-title class_">False</span>

def <span class="hljs-title function_">activate_lights</span>():
    <span class="hljs-title function_">print</span>(<span class="hljs-string">"the lights are on"</span>)

mainvalve = <span class="hljs-title class_">Pump</span>()

def <span class="hljs-title function_">turn_on_pump</span>():
    mainvalve.<span class="hljs-property">pumping</span> = <span class="hljs-title class_">True</span>

def <span class="hljs-title function_">turn_switch</span>(<span class="hljs-attr">has_power</span>: bool):
    <span class="hljs-keyword">if</span> not <span class="hljs-attr">has_power</span>:
        <span class="hljs-title function_">print</span>(<span class="hljs-string">"there is no power"</span>)
    <span class="hljs-attr">else</span>:
        <span class="hljs-title function_">activate_lights</span>()
        <span class="hljs-title function_">turn_on_pump</span>()
        <span class="hljs-keyword">if</span> mainvalve.<span class="hljs-property">pumping</span> == <span class="hljs-title class_">False</span>:
            <span class="hljs-title function_">print</span>(<span class="hljs-string">"error turning on the pump"</span>)
        <span class="hljs-attr">else</span>:
            <span class="hljs-title function_">print</span>(<span class="hljs-string">"the pump is on!"</span>)
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 경우에는 기본적으로 else 아래에서 함수를 계속 진행합니다. 이 접근 방식에는 여러 가지 단점이 있습니다. 먼저, 똑같은 것을 두 번 프로그래밍할 가능성이 훨씬 커집니다. 이것은 이 글의 방법론 중 하나인데, 우리는 그렇게 하고 싶지 않습니다.</p>
<pre><code class="hljs language-js">def <span class="hljs-title function_">turn_switch</span>(<span class="hljs-attr">has_power</span>: bool):
    <span class="hljs-keyword">if</span> not <span class="hljs-attr">has_power</span>:
        <span class="hljs-title function_">print</span>(<span class="hljs-string">"전원이 없습니다"</span>)
    <span class="hljs-attr">else</span>:
        <span class="hljs-title function_">activate_lights</span>()
        <span class="hljs-title function_">turn_on_pump</span>()
        <span class="hljs-keyword">if</span> mainvalve.<span class="hljs-property">pumping</span> == <span class="hljs-title class_">False</span>:
            <span class="hljs-title function_">print</span>(<span class="hljs-string">"펌프 작동 오류"</span>)
        <span class="hljs-attr">else</span>:
            <span class="hljs-title function_">print</span>(<span class="hljs-string">"펌프가 작동 중입니다!"</span>)
</code></pre>
<pre><code class="hljs language-js">def <span class="hljs-title function_">turn_switch</span>(<span class="hljs-attr">has_power</span>: bool):
    <span class="hljs-keyword">if</span> not <span class="hljs-attr">has_power</span>:
        <span class="hljs-title function_">print</span>(<span class="hljs-string">"전원이 없습니다"</span>)
        <span class="hljs-keyword">return</span>
    <span class="hljs-title function_">activate_lights</span>()
    <span class="hljs-title function_">turn_on_pump</span>()
    <span class="hljs-keyword">if</span> mainvalve.<span class="hljs-property">pumping</span> == <span class="hljs-title class_">False</span>:
        <span class="hljs-title function_">print</span>(<span class="hljs-string">"펌프 작동 오류"</span>)
        <span class="hljs-keyword">return</span>
        <span class="hljs-title function_">print</span>(<span class="hljs-string">"펌프가 작동 중입니다!"</span>)
</code></pre>
<p>또한 위의 경우에는 언젠가는 조건부 내부에서 사용되는 변수를 할당해야 할 것입니다. 이 값은 조건부 외부에서 사용할 계획이 있다면 함수의 비공개 범위에 유지하는 것이 훨씬 더 합리적입니다. 조건부 내부에서 변수를 새로 할당할 수 없으며, 조건부는 루프와 마찬가지로 다른 렉시컬 범위를 추가합니다. 이러한 점을 고려하면 이러한 범위를 설정하고 데이터를 전달하는 데 시간이 걸립니다. 몇몇 부적절한 조건부는 큰 문제를 일으키지 않을 수 있지만, 추가적인 중첩 및 더 많은 호출은 항상 성능을 저하시킵니다. 최적의 성능은 Python과 같은 언어에서 더욱 중요합니다. 우리는 Python의 속도 신뢰성이 C와 같은 것에 비하면 그리 높지 않기 때문에 실제 작성한 대부분의 Python 코드가 가능한 최적화되도록 하려고 할 것입니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>다른 경우마다 else를 사용해서는 안 된다는 이유에도 불구하고, else에는 사용할 때의 이유가 있습니다. 특히 모든 조건문 뒤에 기본적으로 else를 사용하는 것은 일반적인 코딩 방식이기 때문에, 그 사용 사례가 else를 사용해야 하는 경우에 대해 명확하게 표현해야 합니다. 전자를 사용하는 것이 더 나은 점이 있다고 생각해요.</p>
<h2>결론</h2>
<p>파이썬의 성공은 확실히 사용 편의성과 접근성에 기인합니다. 다른 언어들처럼 단점이 없는 것은 아니지만, 파이썬이 인기를 얻은 이유를 쉽게 이해할 수 있습니다. 특히 파이썬을 주로 사용하는 분야를 고려하면 더 그렇습니다. 파이썬의 접근성 중 하나인 단점은, 사용자가 놓치기 쉬운 기능들이 있어서 입니다. 예를 들어, 누군가는 오랜 시간 동안 파이썬을 사용했지만 pipenv를 어떻게 사용해야 하는지 모르는 경우가 있을 수 있습니다.</p>
<p>다행히도 시간이 흘러가며 프로그래밍 실력은 향상되고 지식이 쌓입니다. 파이썬은 쉽게 시작할 수 있는 언어이지만, 정말 멋진 기능들을 발견하려면 조금의 연구가 필요합니다. 지속적인 발전을 위해 더 나은 코딩 습관을 습득하는 것은 좋은 생각입니다. 우리는 프로그래머로써 항상成長해야 하며, 우리는 삶을 살아가며 배우고 가르치고 원하는 것을 만드는 시간이 제한되어 있습니다. 우리가 원하는 것이 무엇이든 상관없이 배울 시간을 갖도록 하자는 것이 중요합니다. 우수한 프로그래머가 되는 가장 놀라운 점은 극적인 표현력으로 주변 모두에게 이익이 되는 것입니다. 마치 관객들이 모두 팬인 거리 공연자와 같이요. 오늘날 파이썬을 잘 배운 것은 극히 중요하기 때문에, 적어도 나의 프로그래밍에 대한 분명하고 구체적인 조언을 나눌 수 있어서 기쁩니다!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"당신의 Python 코드를 쉽게 개선할 수 있는 7가지 방법","description":"","date":"2024-07-09 19:45","slug":"2024-07-09-7SimpleWaysToDrasticallyImproveYourPythonCode","content":"\n\u003cimg src=\"/TIL/assets/img/2024-07-09-7SimpleWaysToDrasticallyImproveYourPythonCode_0.png\" /\u003e\n\n## 소개\n\n파이썬은 데이터 과학과 함께 올라와 프로그래밍 세계에서 인기를 얻었는데, 이에는 아주 좋은 이유가 있습니다. 이 언어에는 C와 밀접한 연계성과 다양한 문제를 원활하게 해결하기 위한 적절한 타입 및 함수 시스템을 포함한 여러 이점이 있습니다. 이러한 이점 중 하나는 파이썬이 작성, 학습 및 해독이 굉장히 쉬운 언어임에 틀림없습니다. 이로 인해 파이썬은 대부분의 기본 계산 작업에 대한 고수준 스크립팅 언어로 변모했습니다.\n\n파이썬의 사용 편의성은 특히 데이터에 보다 집중하고 싶은 과학자들이나 구문에 덜 관심을 갖고 싶은 초보 프로그래머들을 위한 매력적인 선택지가 됩니다. 그러나 사용 편의성과 접근성과 함께 성능에 주목할 필요가 있습니다. 또한 파이썬 같은 스크립팅 언어는 일반적으로 방법을 잘못 사용하더라도 파악하지 못하거나 직면할 필요가 없는 공간을 훨씬 더 많이 제공하는 경향이 있습니다. 다행히도 새로운 파이썬 사용자들을 위해서 파이썬은 광범위한 기능을 도입하여 사용하기 쉽고 동적으로 타입이 지정된 스크립팅 언어의 단점을 완화할 수 있었습니다. 좋은 프로그래밍 관행과 함께 파이썬의 타입 시스템과 생태계를 효과적으로 활용함으로써 파이썬의 다양한 단점을 완화하고 해당 언어에서 훨씬 더 나은 코드를 작성할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 추상화\n\n어떤 객체 지향 프로그래밍 언어에서 가장 먼저 이야기해야 하는 것은 추상화입니다. 추상화는 상속을 사용하여 훨씬 더 많은 기능을 더 적은 코드로 만들 수 있는 일반적인 프로그래밍 개념입니다. 상속은 추상화를 용이하게 하는 방법으로, 하위 클래스를 통해 기능을 전파하는 클래스 유형이 있는 방식입니다. 이것이 추상화 개념의 원래 출발점이자 객체 지향 프로그래밍 개념의 기반이 됩니다. 여기서 \"메서드\"는 해당 유형에 적합하게 설계된 클래스의 내부 함수를 의미합니다.\n\n추상화는 많은 다른 유형과 함께 사용할 수 있는 일반적인 함수를 만들 수 있게 해줍니다. 이게 바로 계층적 하위 클래스를 사용하여 어떤 유형인지 결정할 수 있는 것입니다. 이것은 다형성이라고도 하며, 하나의 서브루틴으로 여러 유형의 데이터 구조를 '변형'할 수 있는 능력을 의미합니다. Python에서는 메서드와 속성이 클래스를 구성합니다. 그런 다음 이 클래스의 하위 클래스가 될 수 있으며, 속성과 메서드를 상속받을 수 있습니다. 이것이 상속이라고 하며, Simula 시뮬레이션 언어에서 공개된 추상화 개념의 원조입니다.\n\n프로그래머로서 들을 수 있는 일반적인 조언 중 하나는 \"일반적인 함수를 작성하라\"는 것입니다. 이 조언은 의미가 있습니다. 함수가 보다 일반적일수록 프로젝트에 최종적으로 들어가는 코드가 적어집니다. 이는 또한 사물이 파괴될 기회가 적어지고, 파괴된 경우에는 해결책을 형성하기 위해 한 곳만 살펴보면 되는 것을 의미합니다. 그러나 이 조언에서 종종 빠지는 중요한 부분은 일반적인 함수를 계층적 추상화 수준으로 설계해야 한다는 것입니다. 다시 말해, 우리는 모든 차량을 위해 함수를 작성하고, 필요한 경우에만 트럭을 위한 함수를 작성해야 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이렇게 보면, 파이썬이 제공하는 기능과 메서드 기능도 자연스럽게 패턴이 있는 것 같아요. 함수는 매우 일반적인 호출에 사용하고, 메서드는 특정 유형의 호출에 더 적합하며 특히 상속을 원하는 경우 더 좋아요. Python에서 추상화 기법을 사용하려면, 우선 클래스를 만들어야 해요:\n\n```python\nclass Car:\n    def __init__(self, name, color: str):\n        self.name = name\n        self.color = color\n    def honk(self):\n        print(self.name + \" has just honked at us in their \" + self.color + \" car\")\n```\n\n이 간단한 클래스에는 name 및 color 속성과 honk 메서드가 있습니다. 자동차를 만들고 honk 메서드를 호출하면 작은 메시지가 출력됩니다.\n\n```python\nmycar = Car(\"the mystery machine\", \"green, flower-covered\")\nmycar.honk()\n\nthe mystery machine has just honked at us in their green, flower-covered car\n선택이 삭제됨\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이것은 좋아요. 하지만 저는 트럭도 가지고 있어요. 제가 시골 소녀니까요. 그래서 우리는 트럭을 만들어야 할 거예요. 괄호 안에 Car 클래스를 Truck 클래스에 제공해주면 Car의 모든 속성과 메소드를 상속받을 수 있어요. 데이터인 이름과 색깔은 같이 저장하지만, 우리의 honk 메소드는 Car의 버전이 차량이 Car임을 언급하기 때문에 변경되어야 해요. 따라서 이를 고려하여, 우리는 서브 클래스에 새로운 메소드를 작성함으로써 상속된 메소드를 오버로드할 수 있어요.\n\n```js\nclass Truck(Car):\n    def honk(self):\n        print(self.name + \" has just honked at us in their \" + self.color + \" truck\")\n```\n\n추상화하지 않은 경우 이 코드는 다음과 같아요:\n\n```js\nclass Truck(Car):\n    def __init__(self, name, color : str):\n        self.name = name\n        self.color = color\n    def honk(self):\n        print(self.name + \" has just honked at us in their \" + self.color + \" truck\")\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nmytruck = Truck(\"my large truck\", \"red\")\nmytruck.honk()\n\nmy large truck가 빨간 트럭으로 우리에게 경적을 울렸어요\n```\n\n우리는 완전히 새로운 Car를 생성할 수도 있습니다. 여기서 중요한 점은 pass 키워드를 사용하여 Python의 들여쓰기 문법을 활용해 생성자를 이름만 정의하는 것입니다.\n\n```python\nclass Sedan(Car):\n    pass\n```\n\n훨씬 큰 사용 사례에서 추상화가 Python에서 훌륭한 코드를 작성하는 데 절대적으로 필요한 이유를 이해하기 쉽습니다. 다행히 이 기술은 사용하기 매우 쉽습니다, 그리고 제가 논의하고 싶은 다음 기술도 마찬가지입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 표현식들\n\n파이썬과 유사한 많은 다양한 스크립팅 언어를 사용한 후에 얘기하지만, 표현식들이 이런 언어에서 작업할 때 가장 귀중한 자산 중 하나라는 걸 자신 있게 말씀드릴 수 있어요. 표현식들은 제너레이터, 리스트 및 기타 유형을 아주 간결하고 효과적으로 생성하는 방법입니다. 일반적으로 기존의 for 루프를 통해 작성되는 것과 같은 형태로 구성될 수 있는 요소들을 생성하는 방법입니다. 예를 들어, 1부터 30까지의 제곱을 생성하는 다음 예제를 고려해보세요:\n\n```js\nvalues = []\nfor x in range(1, 30):\n    values.append(x ** 2)\n```\n\n이것은 for 루프 방식으로, 이는 파이썬에서 반복 가능한 요소와 함께 작업하는 핵심적인 방법입니다. 이 접근 방식의 for 루프 버전은 리스트를 초기화하고 각 반복에서 해당 리스트에 새 요소를 추가하는 것을 요구합니다. 이 방식은 효율적이지만, 요소를 생성하는 데 제너레이터를 사용하는 것만큼 효과적이지는 않습니다. 후자는 더 간결할 뿐만 아니라 성능도 더 나아집니다. 위 예제의 코드는 간단한 리스트 표현식으로 한 줄로 변환됩니다. 제너레이터를 생성하려면 사실상 역방향 for 루프를 작성하고 리스트 구분 기호로 둘러싸면 됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nvalues = [x ** 2 for x in range(1, 30)]\n```\n\n위에 대한 설명은 지능 표현식 또는 생성기가 다음 반복 단계의 실행에 매핑된 반환을 만들기위한 함수를 만들어 냄을 의미합니다. 좀 더 간단한 용어로 설명하면, 생성기는 함수에서 반복자를 통해 반환을 만들기 위해 특별히 만들어지는 반면 for 루프는 더 개방적이며 단순히 반복자를 만듭니다. 이로 인해 Python에서 작업을 크게 빠르게 만들며 코드를 훨씬 더 간결하게 만듭니다. 그러나 각 요소에 대해 반환을 기대하지 않는 경우에는 다른 방법을 사용하는 것이 더 나을 수 있습니다.\n\n## 람다 및 맵\n\nPython 코드를 극적으로 개선하는 다음 간단한 기술은 iterable의 요소들을 횡단하여 함수를 호출하는 조합인 람다와 맵을 사용하는 것입니다. 현재 Python의 가장 일반적인 응용 분야가 과학 컴퓨팅이라는 점을 고려하면, 람다와 맵은 놀라울 만큼 많이 사용되는 Python 기능입니다. 둘의 다양성은 많은 다른 도메인에서 함께 기능을 통해 뛰어나기 때문에, 이 기술은 확실히 알아두어야 할 가치가 있습니다. 특히 데이터 과학을 위해 Python 언어를 사용하는 사람들뿐만 아니라요.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nLambda는 호출 가능한 함수 유형으로 신속하게 표현식을 작성하는 데 사용됩니다. 이를 통해 간단한 클로저 함수를 생성할 수 있습니다. 이 함수들은 인수로 제공되어 다양한 가능성을 제공할 수 있습니다. Python에서 람다를 사용하는 것은 비교적 간단합니다. 람다 키워드에 인수를 제공한 다음 콜론과 함수의 논리를 추가합니다.\n\n```js\nf = lambda x: x + 5\nf(5)\n\n10\n```\n\n이 개념은 함수를 생성하는 능력 때문에 상당히 강력합니다. 그러나 이 기술이 빛나는 한 가지 맥락은 이러한 함수들을 반복 가능한 객체에 매핑하는 것입니다. 이를 통해 생성기와 연관된 생성 측면 없이 배열을 변경할 수 있습니다. 이 경우 함수는 몇 가지 차이점이 있는 생성기와 유사한 기능을 만들기 위해 요소를 직접 제공받습니다.\n\n```js\nf = lambda x: x ** 2\n\nm = map(f, values)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리가 맵을 사용하여 함수를 값에 매핑하면 맵을 단순히 리스트로 캐스팅하여 제곱된 배열을 얻을 수 있습니다:\n\n```js\nsquared = list(m)\n[6,\n 9,\n 14,\n 21,\n 30,\n 41,\n 54,\n 69,\n 86,\n 105,\n....\n```\n\n이 두 가지를 결합함으로써 코드를 압축하는 방법이 얼마나 쉬운지 알 수 있습니다!\n\n## 추출\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음 소프트웨어를 개선하는 방법은 일반적으로 우수한 프로그래밍 조언입니다. 추출 기술은 대규모 하위 루틴에서 코드를 추출하여 작은 하위 루틴의 시리즈로 압축하는 실천 방법입니다. 전체 작업을 처리하는 하나의 함수를 작성하는 대신 해당 작업의 각 단계는 프로젝트 내의 다른 함수로 전달됩니다. 이 기술에 대해 중요성과 중요성을 노래한 몇 가지 기사를 작성했습니다. 위대한 소프트웨어 공학 프로젝트를 만들 때 매우 중요합니다.\n\n```python\ndef quiz_user():\n    correct = []\n    print(\"이름은 뭐에요?\")\n    x = input()\n    print(\"2 + 2는 뭐에요?\")\n    answer = input()\n\n    if answer == \"4\":\n        print(\"정답\")\n        correct.append(True)\n    else:\n        print(\"틀렸어요.\")\n        correct.append(False)\n\n    print(\"하늘의 색깔은 뭐에요?\")\n    answer = input()\n\n    if answer == \"파란색\":\n        print(\"정답\")\n        correct.append(True)\n    else:\n        print(\"틀렸어요.\")\n        correct.append(False)\n\n    return correct\n```\n\n이 함수에는 여러 단계가 포함되어 있고 최종적으로 이름이 시행하는 것 이상을 수행합니다. 이는 이상적이지 않습니다. 각 함수가 직접적으로 작업을 수행하도록 원합니다. 그리고 목적 외 작은 작업은 함수 바깥에 두는 것이 좋습니다. 추출 프로세스는 몇 가지 핵심 단계로 수행됩니다. 첫 번째 단계에서 함수의 다른 부분과 입력 및 출력을 고려합니다. 함수를 그룹화한 후에는 함수를 함수 밖으로 추출하고 함수를 호출합니다. 이 특정 상황에서는 더 다재다능한 질문 요청 함수를 만드는 것이 더 적합할 수 있지만, 이 경우에는 각각의 출력이 알고리즘 과정의 새로운 단계인 것처럼 가정하여 함수의 반환을 생성합니다.\n\n```python\ndef ask_name():\n    print(\"이름은 뭐에요?\")\n    x = input()\n    print(\"안녕 \" + x)\n    return x\n\ndef question1():\n    print(\"2 + 2는 뭐에요?\")\n    answer = input()\n\n    if answer == \"4\":\n        print(\"정답\")\n        return True\n    else:\n        print(\"틀렸어요.\")\n        return False\n\ndef question2():\n    print(\"하늘의 색깔은 뭐에요?\")\n    answer = input()\n\n    if answer == \"파란색\":\n        print(\"정답\")\n        return True\n    else:\n        print(\"틀렸어요.\")\n        return False\n\ndef quiz_user():\n    correct = []\n    ask_name()\n    correct = [f() for f in (question1, question2)]\n    return correct\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n추출 기술을 사용하면 코드를 다양한 방법으로 개선할 수 있어요. 먼저, 함수를 작성할 때 코드를 함수 내에서 재사용할 수 있어요. 특정 알고리즘을 더 큰 함수 내에 그대로 두면, 전혀 다른 목적을 가진 코드 일부에 액세스하지 못할 수도 있어요. 추출 사용의 또 다른 이점은 프로젝트가 훨씬 더 조직적으로 됩니다. 함수는 짧고 중첩을 최소화하는 것이 좋아요. 이 모든 것은 논리적인 코드를 고유한 범위로 가져오는 것이 종종 매우 좋은 선택이 될 수 있다는 것을 말해요.\n\n## del\n\n다음으로 논의하고 싶은 파이썬 기능은 'del' 입니다. 이 키워드는 파이썬 객체를 메모리에서 제거하는 데 사용됩니다. 첫눈에는 그다지 중요하지 않아 보이지만, 파이썬이 사용하기 쉬운 스크립트 언어이기 때문에 가능한 한 자주 사용하고 싶은 파이썬 기능 중 하나에요. 'del'은 종종 간과되지만, 이 기능은 메모리를 보존하는 데 매우 도움이 될 수 있어요.\n\n```js\ndel squared\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파이썬과 같은 스크립트 언어에서는 메모리 및 성능 관리 방법이 더 제한적이기 때문에 계산 시간을 단축하고 메모리를 해제하는 데 도움이 되는 모든 것을 활용하고 싶을 것입니다. 파이썬은 사실 유사한 스크립트 언어들 중에서 적어도 힙에서 빠르게 무언가를 제거하고 가비지 수집하는 키워드 del 이 하나는 있어서 어느 정도 독특합니다. 그런 관점에서 이 기능을 확실히 활용하고 싶습니다.\n\n## break 와 continue\n\n당신의 도구 상자에 꼭 있어야 할 또 다른 중요한 기술은 break 와 continue 키워드입니다. 이 두 키워드는 모두 반복적 루프 문맥에서 특히 사용되며, 반복적 루프를 더 최적화하기 위해 break 를 사용하여 반복을 중단하거나 continue 를 사용하여 다음 요소로 건너뛸 수 있습니다.\n\n```js\nmydata = [None, None, 55, 22, 33, 44, None, 2, None, 73, 22, None, None, None, 36, \"stop here please\", 23]\nnewvalues = []\nfor x in mydata:\n    if x == None:\n        continue\n    elif x == \"stop here please\":\n        break\n    newvalues.append(x)\n\nnewvalues\n[55, 22, 33, 44, 2, 73, 22, 36]\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n당연히, break와 continue는 각각 자신의 사용 사례를 가지고 있습니다. 예를 들어 조건부로 특정 요소에 대해 작업하고 싶을 때를 생각해보세요. 이러한 키워드에는 끝이 없는 사용 방법이 있으며, 여러분의 도구 상자에 이러한 간단한 도구들을 유지하는 것이 좋은 아이디어입니다.\n\n## else는 최대한 사용을 줄입니다\n\n코드 개선에 관한 참고 사항으로 다룰 마지막 주제는 else를 최대한 줄이는 방법입니다. 저는 큰 else 문과 중첩된 조건문 같은 것은 가능한 한 피해야 한다고 생각합니다. else 자체가 서브루틴이라는 것을 이해해야 합니다. 이것은 우리 함수 아래에서 정의된 완전히 독립적인 스코프의 또 다른 레이어입니다. else 키워드를 사용하는 많은 경우가 있지만, 우리 코드를 더 읽기 쉽고 기능적으로 더 효율적으로 만들기 위해 사용하지 않아야 할 때도 있습니다.\n\n```js\nclass Pump:\n    def __init__(self):\n        self.pumping = False\n\ndef activate_lights():\n    print(\"the lights are on\")\n\nmainvalve = Pump()\n\ndef turn_on_pump():\n    mainvalve.pumping = True\n\ndef turn_switch(has_power: bool):\n    if not has_power:\n        print(\"there is no power\")\n    else:\n        activate_lights()\n        turn_on_pump()\n        if mainvalve.pumping == False:\n            print(\"error turning on the pump\")\n        else:\n            print(\"the pump is on!\")\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 경우에는 기본적으로 else 아래에서 함수를 계속 진행합니다. 이 접근 방식에는 여러 가지 단점이 있습니다. 먼저, 똑같은 것을 두 번 프로그래밍할 가능성이 훨씬 커집니다. 이것은 이 글의 방법론 중 하나인데, 우리는 그렇게 하고 싶지 않습니다.\n\n```js\ndef turn_switch(has_power: bool):\n    if not has_power:\n        print(\"전원이 없습니다\")\n    else:\n        activate_lights()\n        turn_on_pump()\n        if mainvalve.pumping == False:\n            print(\"펌프 작동 오류\")\n        else:\n            print(\"펌프가 작동 중입니다!\")\n```\n\n```js\ndef turn_switch(has_power: bool):\n    if not has_power:\n        print(\"전원이 없습니다\")\n        return\n    activate_lights()\n    turn_on_pump()\n    if mainvalve.pumping == False:\n        print(\"펌프 작동 오류\")\n        return\n        print(\"펌프가 작동 중입니다!\")\n```\n\n또한 위의 경우에는 언젠가는 조건부 내부에서 사용되는 변수를 할당해야 할 것입니다. 이 값은 조건부 외부에서 사용할 계획이 있다면 함수의 비공개 범위에 유지하는 것이 훨씬 더 합리적입니다. 조건부 내부에서 변수를 새로 할당할 수 없으며, 조건부는 루프와 마찬가지로 다른 렉시컬 범위를 추가합니다. 이러한 점을 고려하면 이러한 범위를 설정하고 데이터를 전달하는 데 시간이 걸립니다. 몇몇 부적절한 조건부는 큰 문제를 일으키지 않을 수 있지만, 추가적인 중첩 및 더 많은 호출은 항상 성능을 저하시킵니다. 최적의 성능은 Python과 같은 언어에서 더욱 중요합니다. 우리는 Python의 속도 신뢰성이 C와 같은 것에 비하면 그리 높지 않기 때문에 실제 작성한 대부분의 Python 코드가 가능한 최적화되도록 하려고 할 것입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다른 경우마다 else를 사용해서는 안 된다는 이유에도 불구하고, else에는 사용할 때의 이유가 있습니다. 특히 모든 조건문 뒤에 기본적으로 else를 사용하는 것은 일반적인 코딩 방식이기 때문에, 그 사용 사례가 else를 사용해야 하는 경우에 대해 명확하게 표현해야 합니다. 전자를 사용하는 것이 더 나은 점이 있다고 생각해요.\n\n## 결론\n\n파이썬의 성공은 확실히 사용 편의성과 접근성에 기인합니다. 다른 언어들처럼 단점이 없는 것은 아니지만, 파이썬이 인기를 얻은 이유를 쉽게 이해할 수 있습니다. 특히 파이썬을 주로 사용하는 분야를 고려하면 더 그렇습니다. 파이썬의 접근성 중 하나인 단점은, 사용자가 놓치기 쉬운 기능들이 있어서 입니다. 예를 들어, 누군가는 오랜 시간 동안 파이썬을 사용했지만 pipenv를 어떻게 사용해야 하는지 모르는 경우가 있을 수 있습니다.\n\n다행히도 시간이 흘러가며 프로그래밍 실력은 향상되고 지식이 쌓입니다. 파이썬은 쉽게 시작할 수 있는 언어이지만, 정말 멋진 기능들을 발견하려면 조금의 연구가 필요합니다. 지속적인 발전을 위해 더 나은 코딩 습관을 습득하는 것은 좋은 생각입니다. 우리는 프로그래머로써 항상成長해야 하며, 우리는 삶을 살아가며 배우고 가르치고 원하는 것을 만드는 시간이 제한되어 있습니다. 우리가 원하는 것이 무엇이든 상관없이 배울 시간을 갖도록 하자는 것이 중요합니다. 우수한 프로그래머가 되는 가장 놀라운 점은 극적인 표현력으로 주변 모두에게 이익이 되는 것입니다. 마치 관객들이 모두 팬인 거리 공연자와 같이요. 오늘날 파이썬을 잘 배운 것은 극히 중요하기 때문에, 적어도 나의 프로그래밍에 대한 분명하고 구체적인 조언을 나눌 수 있어서 기쁩니다!\n","ogImage":{"url":"/assets/img/2024-07-09-7SimpleWaysToDrasticallyImproveYourPythonCode_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-7SimpleWaysToDrasticallyImproveYourPythonCode_0.png","tag":["Tech"],"readingTime":15},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-09-7SimpleWaysToDrasticallyImproveYourPythonCode_0.png\"\u003e\n\u003ch2\u003e소개\u003c/h2\u003e\n\u003cp\u003e파이썬은 데이터 과학과 함께 올라와 프로그래밍 세계에서 인기를 얻었는데, 이에는 아주 좋은 이유가 있습니다. 이 언어에는 C와 밀접한 연계성과 다양한 문제를 원활하게 해결하기 위한 적절한 타입 및 함수 시스템을 포함한 여러 이점이 있습니다. 이러한 이점 중 하나는 파이썬이 작성, 학습 및 해독이 굉장히 쉬운 언어임에 틀림없습니다. 이로 인해 파이썬은 대부분의 기본 계산 작업에 대한 고수준 스크립팅 언어로 변모했습니다.\u003c/p\u003e\n\u003cp\u003e파이썬의 사용 편의성은 특히 데이터에 보다 집중하고 싶은 과학자들이나 구문에 덜 관심을 갖고 싶은 초보 프로그래머들을 위한 매력적인 선택지가 됩니다. 그러나 사용 편의성과 접근성과 함께 성능에 주목할 필요가 있습니다. 또한 파이썬 같은 스크립팅 언어는 일반적으로 방법을 잘못 사용하더라도 파악하지 못하거나 직면할 필요가 없는 공간을 훨씬 더 많이 제공하는 경향이 있습니다. 다행히도 새로운 파이썬 사용자들을 위해서 파이썬은 광범위한 기능을 도입하여 사용하기 쉽고 동적으로 타입이 지정된 스크립팅 언어의 단점을 완화할 수 있었습니다. 좋은 프로그래밍 관행과 함께 파이썬의 타입 시스템과 생태계를 효과적으로 활용함으로써 파이썬의 다양한 단점을 완화하고 해당 언어에서 훨씬 더 나은 코드를 작성할 수 있습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e추상화\u003c/h2\u003e\n\u003cp\u003e어떤 객체 지향 프로그래밍 언어에서 가장 먼저 이야기해야 하는 것은 추상화입니다. 추상화는 상속을 사용하여 훨씬 더 많은 기능을 더 적은 코드로 만들 수 있는 일반적인 프로그래밍 개념입니다. 상속은 추상화를 용이하게 하는 방법으로, 하위 클래스를 통해 기능을 전파하는 클래스 유형이 있는 방식입니다. 이것이 추상화 개념의 원래 출발점이자 객체 지향 프로그래밍 개념의 기반이 됩니다. 여기서 \"메서드\"는 해당 유형에 적합하게 설계된 클래스의 내부 함수를 의미합니다.\u003c/p\u003e\n\u003cp\u003e추상화는 많은 다른 유형과 함께 사용할 수 있는 일반적인 함수를 만들 수 있게 해줍니다. 이게 바로 계층적 하위 클래스를 사용하여 어떤 유형인지 결정할 수 있는 것입니다. 이것은 다형성이라고도 하며, 하나의 서브루틴으로 여러 유형의 데이터 구조를 '변형'할 수 있는 능력을 의미합니다. Python에서는 메서드와 속성이 클래스를 구성합니다. 그런 다음 이 클래스의 하위 클래스가 될 수 있으며, 속성과 메서드를 상속받을 수 있습니다. 이것이 상속이라고 하며, Simula 시뮬레이션 언어에서 공개된 추상화 개념의 원조입니다.\u003c/p\u003e\n\u003cp\u003e프로그래머로서 들을 수 있는 일반적인 조언 중 하나는 \"일반적인 함수를 작성하라\"는 것입니다. 이 조언은 의미가 있습니다. 함수가 보다 일반적일수록 프로젝트에 최종적으로 들어가는 코드가 적어집니다. 이는 또한 사물이 파괴될 기회가 적어지고, 파괴된 경우에는 해결책을 형성하기 위해 한 곳만 살펴보면 되는 것을 의미합니다. 그러나 이 조언에서 종종 빠지는 중요한 부분은 일반적인 함수를 계층적 추상화 수준으로 설계해야 한다는 것입니다. 다시 말해, 우리는 모든 차량을 위해 함수를 작성하고, 필요한 경우에만 트럭을 위한 함수를 작성해야 합니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이렇게 보면, 파이썬이 제공하는 기능과 메서드 기능도 자연스럽게 패턴이 있는 것 같아요. 함수는 매우 일반적인 호출에 사용하고, 메서드는 특정 유형의 호출에 더 적합하며 특히 상속을 원하는 경우 더 좋아요. Python에서 추상화 기법을 사용하려면, 우선 클래스를 만들어야 해요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCar\u003c/span\u003e:\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e__init__\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself, name, color: \u003cspan class=\"hljs-built_in\"\u003estr\u003c/span\u003e\u003c/span\u003e):\n        self.name = name\n        self.color = color\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehonk\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself\u003c/span\u003e):\n        \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(self.name + \u003cspan class=\"hljs-string\"\u003e\" has just honked at us in their \"\u003c/span\u003e + self.color + \u003cspan class=\"hljs-string\"\u003e\" car\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 간단한 클래스에는 name 및 color 속성과 honk 메서드가 있습니다. 자동차를 만들고 honk 메서드를 호출하면 작은 메시지가 출력됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003emycar = Car(\u003cspan class=\"hljs-string\"\u003e\"the mystery machine\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"green, flower-covered\"\u003c/span\u003e)\nmycar.honk()\n\nthe mystery machine has just honked at us \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e their green, flower-covered car\n선택이 삭제됨\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이것은 좋아요. 하지만 저는 트럭도 가지고 있어요. 제가 시골 소녀니까요. 그래서 우리는 트럭을 만들어야 할 거예요. 괄호 안에 Car 클래스를 Truck 클래스에 제공해주면 Car의 모든 속성과 메소드를 상속받을 수 있어요. 데이터인 이름과 색깔은 같이 저장하지만, 우리의 honk 메소드는 Car의 버전이 차량이 Car임을 언급하기 때문에 변경되어야 해요. 따라서 이를 고려하여, 우리는 서브 클래스에 새로운 메소드를 작성함으로써 상속된 메소드를 오버로드할 수 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTruck\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eCar\u003c/span\u003e):\n    def \u003cspan class=\"hljs-title function_\"\u003ehonk\u003c/span\u003e(self):\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(self.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e + \u003cspan class=\"hljs-string\"\u003e\" has just honked at us in their \"\u003c/span\u003e + self.\u003cspan class=\"hljs-property\"\u003ecolor\u003c/span\u003e + \u003cspan class=\"hljs-string\"\u003e\" truck\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e추상화하지 않은 경우 이 코드는 다음과 같아요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTruck\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eCar\u003c/span\u003e):\n    def \u003cspan class=\"hljs-title function_\"\u003e__init__\u003c/span\u003e(self, name, color : str):\n        self.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e = name\n        self.\u003cspan class=\"hljs-property\"\u003ecolor\u003c/span\u003e = color\n    def \u003cspan class=\"hljs-title function_\"\u003ehonk\u003c/span\u003e(self):\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(self.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e + \u003cspan class=\"hljs-string\"\u003e\" has just honked at us in their \"\u003c/span\u003e + self.\u003cspan class=\"hljs-property\"\u003ecolor\u003c/span\u003e + \u003cspan class=\"hljs-string\"\u003e\" truck\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003emytruck = Truck(\u003cspan class=\"hljs-string\"\u003e\"my large truck\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"red\"\u003c/span\u003e)\nmytruck.honk()\n\nmy large truck가 빨간 트럭으로 우리에게 경적을 울렸어요\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e우리는 완전히 새로운 Car를 생성할 수도 있습니다. 여기서 중요한 점은 pass 키워드를 사용하여 Python의 들여쓰기 문법을 활용해 생성자를 이름만 정의하는 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSedan\u003c/span\u003e(\u003cspan class=\"hljs-title class_ inherited__\"\u003eCar\u003c/span\u003e):\n    \u003cspan class=\"hljs-keyword\"\u003epass\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e훨씬 큰 사용 사례에서 추상화가 Python에서 훌륭한 코드를 작성하는 데 절대적으로 필요한 이유를 이해하기 쉽습니다. 다행히 이 기술은 사용하기 매우 쉽습니다, 그리고 제가 논의하고 싶은 다음 기술도 마찬가지입니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e표현식들\u003c/h2\u003e\n\u003cp\u003e파이썬과 유사한 많은 다양한 스크립팅 언어를 사용한 후에 얘기하지만, 표현식들이 이런 언어에서 작업할 때 가장 귀중한 자산 중 하나라는 걸 자신 있게 말씀드릴 수 있어요. 표현식들은 제너레이터, 리스트 및 기타 유형을 아주 간결하고 효과적으로 생성하는 방법입니다. 일반적으로 기존의 for 루프를 통해 작성되는 것과 같은 형태로 구성될 수 있는 요소들을 생성하는 방법입니다. 예를 들어, 1부터 30까지의 제곱을 생성하는 다음 예제를 고려해보세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003evalues = []\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e x \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e30\u003c/span\u003e):\n    values.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e(x ** \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이것은 for 루프 방식으로, 이는 파이썬에서 반복 가능한 요소와 함께 작업하는 핵심적인 방법입니다. 이 접근 방식의 for 루프 버전은 리스트를 초기화하고 각 반복에서 해당 리스트에 새 요소를 추가하는 것을 요구합니다. 이 방식은 효율적이지만, 요소를 생성하는 데 제너레이터를 사용하는 것만큼 효과적이지는 않습니다. 후자는 더 간결할 뿐만 아니라 성능도 더 나아집니다. 위 예제의 코드는 간단한 리스트 표현식으로 한 줄로 변환됩니다. 제너레이터를 생성하려면 사실상 역방향 for 루프를 작성하고 리스트 구분 기호로 둘러싸면 됩니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003evalues = [x ** \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e x \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e30\u003c/span\u003e)]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위에 대한 설명은 지능 표현식 또는 생성기가 다음 반복 단계의 실행에 매핑된 반환을 만들기위한 함수를 만들어 냄을 의미합니다. 좀 더 간단한 용어로 설명하면, 생성기는 함수에서 반복자를 통해 반환을 만들기 위해 특별히 만들어지는 반면 for 루프는 더 개방적이며 단순히 반복자를 만듭니다. 이로 인해 Python에서 작업을 크게 빠르게 만들며 코드를 훨씬 더 간결하게 만듭니다. 그러나 각 요소에 대해 반환을 기대하지 않는 경우에는 다른 방법을 사용하는 것이 더 나을 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e람다 및 맵\u003c/h2\u003e\n\u003cp\u003ePython 코드를 극적으로 개선하는 다음 간단한 기술은 iterable의 요소들을 횡단하여 함수를 호출하는 조합인 람다와 맵을 사용하는 것입니다. 현재 Python의 가장 일반적인 응용 분야가 과학 컴퓨팅이라는 점을 고려하면, 람다와 맵은 놀라울 만큼 많이 사용되는 Python 기능입니다. 둘의 다양성은 많은 다른 도메인에서 함께 기능을 통해 뛰어나기 때문에, 이 기술은 확실히 알아두어야 할 가치가 있습니다. 특히 데이터 과학을 위해 Python 언어를 사용하는 사람들뿐만 아니라요.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eLambda는 호출 가능한 함수 유형으로 신속하게 표현식을 작성하는 데 사용됩니다. 이를 통해 간단한 클로저 함수를 생성할 수 있습니다. 이 함수들은 인수로 제공되어 다양한 가능성을 제공할 수 있습니다. Python에서 람다를 사용하는 것은 비교적 간단합니다. 람다 키워드에 인수를 제공한 다음 콜론과 함수의 논리를 추가합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ef = lambda \u003cspan class=\"hljs-attr\"\u003ex\u003c/span\u003e: x + \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003ef\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e)\n\n\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 개념은 함수를 생성하는 능력 때문에 상당히 강력합니다. 그러나 이 기술이 빛나는 한 가지 맥락은 이러한 함수들을 반복 가능한 객체에 매핑하는 것입니다. 이를 통해 생성기와 연관된 생성 측면 없이 배열을 변경할 수 있습니다. 이 경우 함수는 몇 가지 차이점이 있는 생성기와 유사한 기능을 만들기 위해 요소를 직접 제공받습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ef = lambda \u003cspan class=\"hljs-attr\"\u003ex\u003c/span\u003e: x ** \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e\n\nm = \u003cspan class=\"hljs-title function_\"\u003emap\u003c/span\u003e(f, values)\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e우리가 맵을 사용하여 함수를 값에 매핑하면 맵을 단순히 리스트로 캐스팅하여 제곱된 배열을 얻을 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003esquared = \u003cspan class=\"hljs-title function_\"\u003elist\u003c/span\u003e(m)\n[\u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e,\n \u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e,\n \u003cspan class=\"hljs-number\"\u003e14\u003c/span\u003e,\n \u003cspan class=\"hljs-number\"\u003e21\u003c/span\u003e,\n \u003cspan class=\"hljs-number\"\u003e30\u003c/span\u003e,\n \u003cspan class=\"hljs-number\"\u003e41\u003c/span\u003e,\n \u003cspan class=\"hljs-number\"\u003e54\u003c/span\u003e,\n \u003cspan class=\"hljs-number\"\u003e69\u003c/span\u003e,\n \u003cspan class=\"hljs-number\"\u003e86\u003c/span\u003e,\n \u003cspan class=\"hljs-number\"\u003e105\u003c/span\u003e,\n....\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 두 가지를 결합함으로써 코드를 압축하는 방법이 얼마나 쉬운지 알 수 있습니다!\u003c/p\u003e\n\u003ch2\u003e추출\u003c/h2\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e다음 소프트웨어를 개선하는 방법은 일반적으로 우수한 프로그래밍 조언입니다. 추출 기술은 대규모 하위 루틴에서 코드를 추출하여 작은 하위 루틴의 시리즈로 압축하는 실천 방법입니다. 전체 작업을 처리하는 하나의 함수를 작성하는 대신 해당 작업의 각 단계는 프로젝트 내의 다른 함수로 전달됩니다. 이 기술에 대해 중요성과 중요성을 노래한 몇 가지 기사를 작성했습니다. 위대한 소프트웨어 공학 프로젝트를 만들 때 매우 중요합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003equiz_user\u003c/span\u003e():\n    correct = []\n    \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"이름은 뭐에요?\"\u003c/span\u003e)\n    x = \u003cspan class=\"hljs-built_in\"\u003einput\u003c/span\u003e()\n    \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"2 + 2는 뭐에요?\"\u003c/span\u003e)\n    answer = \u003cspan class=\"hljs-built_in\"\u003einput\u003c/span\u003e()\n\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e answer == \u003cspan class=\"hljs-string\"\u003e\"4\"\u003c/span\u003e:\n        \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"정답\"\u003c/span\u003e)\n        correct.append(\u003cspan class=\"hljs-literal\"\u003eTrue\u003c/span\u003e)\n    \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e:\n        \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"틀렸어요.\"\u003c/span\u003e)\n        correct.append(\u003cspan class=\"hljs-literal\"\u003eFalse\u003c/span\u003e)\n\n    \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"하늘의 색깔은 뭐에요?\"\u003c/span\u003e)\n    answer = \u003cspan class=\"hljs-built_in\"\u003einput\u003c/span\u003e()\n\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e answer == \u003cspan class=\"hljs-string\"\u003e\"파란색\"\u003c/span\u003e:\n        \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"정답\"\u003c/span\u003e)\n        correct.append(\u003cspan class=\"hljs-literal\"\u003eTrue\u003c/span\u003e)\n    \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e:\n        \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"틀렸어요.\"\u003c/span\u003e)\n        correct.append(\u003cspan class=\"hljs-literal\"\u003eFalse\u003c/span\u003e)\n\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e correct\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 함수에는 여러 단계가 포함되어 있고 최종적으로 이름이 시행하는 것 이상을 수행합니다. 이는 이상적이지 않습니다. 각 함수가 직접적으로 작업을 수행하도록 원합니다. 그리고 목적 외 작은 작업은 함수 바깥에 두는 것이 좋습니다. 추출 프로세스는 몇 가지 핵심 단계로 수행됩니다. 첫 번째 단계에서 함수의 다른 부분과 입력 및 출력을 고려합니다. 함수를 그룹화한 후에는 함수를 함수 밖으로 추출하고 함수를 호출합니다. 이 특정 상황에서는 더 다재다능한 질문 요청 함수를 만드는 것이 더 적합할 수 있지만, 이 경우에는 각각의 출력이 알고리즘 과정의 새로운 단계인 것처럼 가정하여 함수의 반환을 생성합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eask_name\u003c/span\u003e():\n    \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"이름은 뭐에요?\"\u003c/span\u003e)\n    x = \u003cspan class=\"hljs-built_in\"\u003einput\u003c/span\u003e()\n    \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"안녕 \"\u003c/span\u003e + x)\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e x\n\n\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003equestion1\u003c/span\u003e():\n    \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"2 + 2는 뭐에요?\"\u003c/span\u003e)\n    answer = \u003cspan class=\"hljs-built_in\"\u003einput\u003c/span\u003e()\n\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e answer == \u003cspan class=\"hljs-string\"\u003e\"4\"\u003c/span\u003e:\n        \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"정답\"\u003c/span\u003e)\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003eTrue\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e:\n        \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"틀렸어요.\"\u003c/span\u003e)\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003eFalse\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003equestion2\u003c/span\u003e():\n    \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"하늘의 색깔은 뭐에요?\"\u003c/span\u003e)\n    answer = \u003cspan class=\"hljs-built_in\"\u003einput\u003c/span\u003e()\n\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e answer == \u003cspan class=\"hljs-string\"\u003e\"파란색\"\u003c/span\u003e:\n        \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"정답\"\u003c/span\u003e)\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003eTrue\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e:\n        \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"틀렸어요.\"\u003c/span\u003e)\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003eFalse\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003equiz_user\u003c/span\u003e():\n    correct = []\n    ask_name()\n    correct = [f() \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e f \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e (question1, question2)]\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e correct\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e추출 기술을 사용하면 코드를 다양한 방법으로 개선할 수 있어요. 먼저, 함수를 작성할 때 코드를 함수 내에서 재사용할 수 있어요. 특정 알고리즘을 더 큰 함수 내에 그대로 두면, 전혀 다른 목적을 가진 코드 일부에 액세스하지 못할 수도 있어요. 추출 사용의 또 다른 이점은 프로젝트가 훨씬 더 조직적으로 됩니다. 함수는 짧고 중첩을 최소화하는 것이 좋아요. 이 모든 것은 논리적인 코드를 고유한 범위로 가져오는 것이 종종 매우 좋은 선택이 될 수 있다는 것을 말해요.\u003c/p\u003e\n\u003ch2\u003edel\u003c/h2\u003e\n\u003cp\u003e다음으로 논의하고 싶은 파이썬 기능은 'del' 입니다. 이 키워드는 파이썬 객체를 메모리에서 제거하는 데 사용됩니다. 첫눈에는 그다지 중요하지 않아 보이지만, 파이썬이 사용하기 쉬운 스크립트 언어이기 때문에 가능한 한 자주 사용하고 싶은 파이썬 기능 중 하나에요. 'del'은 종종 간과되지만, 이 기능은 메모리를 보존하는 데 매우 도움이 될 수 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edel squared\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e파이썬과 같은 스크립트 언어에서는 메모리 및 성능 관리 방법이 더 제한적이기 때문에 계산 시간을 단축하고 메모리를 해제하는 데 도움이 되는 모든 것을 활용하고 싶을 것입니다. 파이썬은 사실 유사한 스크립트 언어들 중에서 적어도 힙에서 빠르게 무언가를 제거하고 가비지 수집하는 키워드 del 이 하나는 있어서 어느 정도 독특합니다. 그런 관점에서 이 기능을 확실히 활용하고 싶습니다.\u003c/p\u003e\n\u003ch2\u003ebreak 와 continue\u003c/h2\u003e\n\u003cp\u003e당신의 도구 상자에 꼭 있어야 할 또 다른 중요한 기술은 break 와 continue 키워드입니다. 이 두 키워드는 모두 반복적 루프 문맥에서 특히 사용되며, 반복적 루프를 더 최적화하기 위해 break 를 사용하여 반복을 중단하거나 continue 를 사용하여 다음 요소로 건너뛸 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003emydata = [\u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e55\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e22\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e33\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e44\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e73\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e22\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e36\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"stop here please\"\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e23\u003c/span\u003e]\nnewvalues = []\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e x \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003emydata\u003c/span\u003e:\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e x == \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003econtinue\u003c/span\u003e\n    elif x == \u003cspan class=\"hljs-string\"\u003e\"stop here please\"\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e\n    newvalues.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e(x)\n\nnewvalues\n[\u003cspan class=\"hljs-number\"\u003e55\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e22\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e33\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e44\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e73\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e22\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e36\u003c/span\u003e]\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e당연히, break와 continue는 각각 자신의 사용 사례를 가지고 있습니다. 예를 들어 조건부로 특정 요소에 대해 작업하고 싶을 때를 생각해보세요. 이러한 키워드에는 끝이 없는 사용 방법이 있으며, 여러분의 도구 상자에 이러한 간단한 도구들을 유지하는 것이 좋은 아이디어입니다.\u003c/p\u003e\n\u003ch2\u003eelse는 최대한 사용을 줄입니다\u003c/h2\u003e\n\u003cp\u003e코드 개선에 관한 참고 사항으로 다룰 마지막 주제는 else를 최대한 줄이는 방법입니다. 저는 큰 else 문과 중첩된 조건문 같은 것은 가능한 한 피해야 한다고 생각합니다. else 자체가 서브루틴이라는 것을 이해해야 합니다. 이것은 우리 함수 아래에서 정의된 완전히 독립적인 스코프의 또 다른 레이어입니다. else 키워드를 사용하는 많은 경우가 있지만, 우리 코드를 더 읽기 쉽고 기능적으로 더 효율적으로 만들기 위해 사용하지 않아야 할 때도 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePump\u003c/span\u003e:\n    def \u003cspan class=\"hljs-title function_\"\u003e__init__\u003c/span\u003e(self):\n        self.\u003cspan class=\"hljs-property\"\u003epumping\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e\n\ndef \u003cspan class=\"hljs-title function_\"\u003eactivate_lights\u003c/span\u003e():\n    \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"the lights are on\"\u003c/span\u003e)\n\nmainvalve = \u003cspan class=\"hljs-title class_\"\u003ePump\u003c/span\u003e()\n\ndef \u003cspan class=\"hljs-title function_\"\u003eturn_on_pump\u003c/span\u003e():\n    mainvalve.\u003cspan class=\"hljs-property\"\u003epumping\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e\n\ndef \u003cspan class=\"hljs-title function_\"\u003eturn_switch\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ehas_power\u003c/span\u003e: bool):\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e not \u003cspan class=\"hljs-attr\"\u003ehas_power\u003c/span\u003e:\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"there is no power\"\u003c/span\u003e)\n    \u003cspan class=\"hljs-attr\"\u003eelse\u003c/span\u003e:\n        \u003cspan class=\"hljs-title function_\"\u003eactivate_lights\u003c/span\u003e()\n        \u003cspan class=\"hljs-title function_\"\u003eturn_on_pump\u003c/span\u003e()\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e mainvalve.\u003cspan class=\"hljs-property\"\u003epumping\u003c/span\u003e == \u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e:\n            \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"error turning on the pump\"\u003c/span\u003e)\n        \u003cspan class=\"hljs-attr\"\u003eelse\u003c/span\u003e:\n            \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"the pump is on!\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 경우에는 기본적으로 else 아래에서 함수를 계속 진행합니다. 이 접근 방식에는 여러 가지 단점이 있습니다. 먼저, 똑같은 것을 두 번 프로그래밍할 가능성이 훨씬 커집니다. 이것은 이 글의 방법론 중 하나인데, 우리는 그렇게 하고 싶지 않습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edef \u003cspan class=\"hljs-title function_\"\u003eturn_switch\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ehas_power\u003c/span\u003e: bool):\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e not \u003cspan class=\"hljs-attr\"\u003ehas_power\u003c/span\u003e:\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"전원이 없습니다\"\u003c/span\u003e)\n    \u003cspan class=\"hljs-attr\"\u003eelse\u003c/span\u003e:\n        \u003cspan class=\"hljs-title function_\"\u003eactivate_lights\u003c/span\u003e()\n        \u003cspan class=\"hljs-title function_\"\u003eturn_on_pump\u003c/span\u003e()\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e mainvalve.\u003cspan class=\"hljs-property\"\u003epumping\u003c/span\u003e == \u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e:\n            \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"펌프 작동 오류\"\u003c/span\u003e)\n        \u003cspan class=\"hljs-attr\"\u003eelse\u003c/span\u003e:\n            \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"펌프가 작동 중입니다!\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edef \u003cspan class=\"hljs-title function_\"\u003eturn_switch\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ehas_power\u003c/span\u003e: bool):\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e not \u003cspan class=\"hljs-attr\"\u003ehas_power\u003c/span\u003e:\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"전원이 없습니다\"\u003c/span\u003e)\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e\n    \u003cspan class=\"hljs-title function_\"\u003eactivate_lights\u003c/span\u003e()\n    \u003cspan class=\"hljs-title function_\"\u003eturn_on_pump\u003c/span\u003e()\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e mainvalve.\u003cspan class=\"hljs-property\"\u003epumping\u003c/span\u003e == \u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e:\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"펌프 작동 오류\"\u003c/span\u003e)\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"펌프가 작동 중입니다!\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e또한 위의 경우에는 언젠가는 조건부 내부에서 사용되는 변수를 할당해야 할 것입니다. 이 값은 조건부 외부에서 사용할 계획이 있다면 함수의 비공개 범위에 유지하는 것이 훨씬 더 합리적입니다. 조건부 내부에서 변수를 새로 할당할 수 없으며, 조건부는 루프와 마찬가지로 다른 렉시컬 범위를 추가합니다. 이러한 점을 고려하면 이러한 범위를 설정하고 데이터를 전달하는 데 시간이 걸립니다. 몇몇 부적절한 조건부는 큰 문제를 일으키지 않을 수 있지만, 추가적인 중첩 및 더 많은 호출은 항상 성능을 저하시킵니다. 최적의 성능은 Python과 같은 언어에서 더욱 중요합니다. 우리는 Python의 속도 신뢰성이 C와 같은 것에 비하면 그리 높지 않기 때문에 실제 작성한 대부분의 Python 코드가 가능한 최적화되도록 하려고 할 것입니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e다른 경우마다 else를 사용해서는 안 된다는 이유에도 불구하고, else에는 사용할 때의 이유가 있습니다. 특히 모든 조건문 뒤에 기본적으로 else를 사용하는 것은 일반적인 코딩 방식이기 때문에, 그 사용 사례가 else를 사용해야 하는 경우에 대해 명확하게 표현해야 합니다. 전자를 사용하는 것이 더 나은 점이 있다고 생각해요.\u003c/p\u003e\n\u003ch2\u003e결론\u003c/h2\u003e\n\u003cp\u003e파이썬의 성공은 확실히 사용 편의성과 접근성에 기인합니다. 다른 언어들처럼 단점이 없는 것은 아니지만, 파이썬이 인기를 얻은 이유를 쉽게 이해할 수 있습니다. 특히 파이썬을 주로 사용하는 분야를 고려하면 더 그렇습니다. 파이썬의 접근성 중 하나인 단점은, 사용자가 놓치기 쉬운 기능들이 있어서 입니다. 예를 들어, 누군가는 오랜 시간 동안 파이썬을 사용했지만 pipenv를 어떻게 사용해야 하는지 모르는 경우가 있을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e다행히도 시간이 흘러가며 프로그래밍 실력은 향상되고 지식이 쌓입니다. 파이썬은 쉽게 시작할 수 있는 언어이지만, 정말 멋진 기능들을 발견하려면 조금의 연구가 필요합니다. 지속적인 발전을 위해 더 나은 코딩 습관을 습득하는 것은 좋은 생각입니다. 우리는 프로그래머로써 항상成長해야 하며, 우리는 삶을 살아가며 배우고 가르치고 원하는 것을 만드는 시간이 제한되어 있습니다. 우리가 원하는 것이 무엇이든 상관없이 배울 시간을 갖도록 하자는 것이 중요합니다. 우수한 프로그래머가 되는 가장 놀라운 점은 극적인 표현력으로 주변 모두에게 이익이 되는 것입니다. 마치 관객들이 모두 팬인 거리 공연자와 같이요. 오늘날 파이썬을 잘 배운 것은 극히 중요하기 때문에, 적어도 나의 프로그래밍에 대한 분명하고 구체적인 조언을 나눌 수 있어서 기쁩니다!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-07-09-7SimpleWaysToDrasticallyImproveYourPythonCode"},"buildId":"B2TETmJptwqhd4vJNGZoH","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>