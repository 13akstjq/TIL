<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>파이썬 코딩 멀티스레딩으로 for 루프 속도 10배 향상시키는 방법 | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2024-07-13-PythonCodingMakeForLoops10xFasterwithMultithreading" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="파이썬 코딩 멀티스레딩으로 for 루프 속도 10배 향상시키는 방법 | TIL" data-gatsby-head="true"/><meta property="og:title" content="파이썬 코딩 멀티스레딩으로 for 루프 속도 10배 향상시키는 방법 | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/TIL/assets/img/2024-07-13-PythonCodingMakeForLoops10xFasterwithMultithreading_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2024-07-13-PythonCodingMakeForLoops10xFasterwithMultithreading" data-gatsby-head="true"/><meta name="twitter:title" content="파이썬 코딩 멀티스레딩으로 for 루프 속도 10배 향상시키는 방법 | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/assets/img/2024-07-13-PythonCodingMakeForLoops10xFasterwithMultithreading_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2024-07-13 19:21" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-5ecfd58aae5a7e3d.js" defer=""></script><script src="/_next/static/xx51Gh_JNHDTBdDwrgykD/_buildManifest.js" defer=""></script><script src="/_next/static/xx51Gh_JNHDTBdDwrgykD/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">파이썬 코딩 멀티스레딩으로 for 루프 속도 10배 향상시키는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="파이썬 코딩 멀티스레딩으로 for 루프 속도 10배 향상시키는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jul 13, 2024</span><span class="posts_reading_time__f7YPP">8<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-07-13-PythonCodingMakeForLoops10xFasterwithMultithreading&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/TIL/assets/img/2024-07-13-PythonCodingMakeForLoops10xFasterwithMultithreading_0.png" alt="Python Coding Make For Loops 10x Faster with Multithreading"></p>
<p>For loops are essential in programming. They allow us to iterate over sequences efficiently. However, for time-consuming tasks, using threads can be more efficient. Learn when and how to use threads to optimize performance. You can check out code examples in my GIT repo. The link is in the footer.</p>
<p>Let's look at an example. We will simulate a time-consuming task by squaring numbers using a Python script with a for loop:</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">import</span> time

<span class="hljs-comment"># List of numbers to process</span>
numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>]

<span class="hljs-comment"># Function to square a number</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">square_number</span>(<span class="hljs-params">number</span>):
    time.sleep(<span class="hljs-number">1</span>)  <span class="hljs-comment"># Simulate a time-consuming task</span>
    <span class="hljs-keyword">return</span> number * number

<span class="hljs-comment"># Using a for loop to process each number</span>
squared_numbers = []
start_time = time.time()
<span class="hljs-keyword">for</span> number <span class="hljs-keyword">in</span> numbers:
    squared_numbers.append(square_number(number))

end_time = time.time()

<span class="hljs-built_in">print</span>(<span class="hljs-string">"Squared numbers:"</span>, squared_numbers)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"Time taken:"</span>, end_time - start_time, <span class="hljs-string">"seconds"</span>)
<span class="hljs-comment"># Time taken: 10.082990884780884 seconds</span>
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 스크립트는 square_number 함수 내의 time.sleep(1) 호출로 인해 각 숫자를 순차적으로 처리합니다. 전체 실행에는 10.1초가 소요됩니다.</p>
<h2>멀티스레딩으로 최적화</h2>
<p>다음으로, 처리 시간을 개선하기 위해 멀티스레딩 접근 방식으로 최적화할 것입니다. 멀티스레딩을 사용하여 위 예제를 최적화하려면 Python의 concurrent.futures 모듈을 사용할 수 있습니다. 이 모듈은 콜러블을 비동기적으로 실행하기 위한 고수준 인터페이스를 제공합니다.</p>
<p>다음은 스크립트를 멀티스레딩을 사용하도록 수정하는 방법입니다:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> time
<span class="hljs-keyword">from</span> concurrent.<span class="hljs-property">futures</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">ThreadPoolExecutor</span>

# 처리할 숫자의 목록
numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>]

# 숫자를 제곱하는 함수
def <span class="hljs-title function_">square_number</span>(number):
    time.<span class="hljs-title function_">sleep</span>(<span class="hljs-number">1</span>)  # 시간이 많이 소요되는 작업을 모방
    <span class="hljs-keyword">return</span> number * number

# 멀티스레딩을 위해 <span class="hljs-title class_">ThreadPoolExecutor</span> 사용
squared_numbers = []
start_time = time.<span class="hljs-title function_">time</span>()

<span class="hljs-keyword">with</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(max_workers=<span class="hljs-number">10</span>) <span class="hljs-keyword">as</span> <span class="hljs-attr">executor</span>:
    results = executor.<span class="hljs-title function_">map</span>(square_number, numbers)

# 결과 수집
squared_numbers = <span class="hljs-title function_">list</span>(results)

end_time = time.<span class="hljs-title function_">time</span>()

<span class="hljs-title function_">print</span>(<span class="hljs-string">"제곱된 숫자:"</span>, squared_numbers)
<span class="hljs-title function_">print</span>(<span class="hljs-string">"소요 시간:"</span>, end_time - start_time, <span class="hljs-string">"초"</span>)
# 소요 시간: <span class="hljs-number">2.0257720947265625</span> 초
</code></pre>
<p>이 최적화된 스크립트에서 우리는 ThreadPoolExecutor를 사용해 스레드 풀을 생성합니다. executor.map 함수는 숫자를 병렬로 처리하는 스레드에 square_number 함수를 분배합니다. max_workers를 5로 설정하여 최대 5개의 스레드가 동시에 실행되도록 하여 총 처리 시간을 크게 줄일 수 있습니다.</p>
<p>특정 사용 사례에 최적인 스레드 수를 찾으려면 max_workers 매개변수를 조정해보세요.</p>
<h1>멀티스레딩 사용 시기</h1>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>다중 스레딩은 다양한 시나리오에서 상당한 속도 향상을 제공할 수 있다는 것을 보셨을 것입니다. 그러나 모든 작업에 적합한 것은 아닙니다. 다음은 다중 스레딩이 특히 유익한 일반적인 사용 사례 몇 가지입니다:</p>
<h2>1. I/O-바운드 작업:</h2>
<ul>
<li>파일 I/O: 파일 읽기 및 쓰기, 특히 크거나 많은 파일을 다룰 때.</li>
<li>네트워크 I/O: 여러 네트워크 연결을 동시에 처리하는 경우, 예를 들어 웹 스크래핑, 파일 다운로드 또는 웹 서버의 요청 처리.</li>
<li>데이터베이스 작업: I/O 바운드인 데이터베이스 쿼리 수행, 대용량 데이터 세트를 가져오거나 업데이트하는 작업 등.</li>
</ul>
<h2>2. 동시 작업:</h2>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>실시간 데이터 처리: 여러 센서 또는 스트림에서 데이터를 실시간으로 처리하며, IoT 응용 프로그램에서 사용됩니다.</li>
<li>GUI 어플리케이션: 사용자 인터페이스를 반응적으로 유지하기 위해 시간이 많이 소요되는 작업을 백그라운드에서 실행합니다.</li>
</ul>
<h2>3. 독립적인 작업의 병렬 처리:</h2>
<ul>
<li>일괄 처리: 이미지 처리 또는 데이터 변환 작업과 같이 병렬로 실행할 수 있는 많은 독립적인 작업을 처리합니다.</li>
<li>시뮬레이션: 여러 시뮬레이션 또는 몬테카를로 실험을 동시에 실행합니다.</li>
</ul>
<h1>멀티스레딩을 사용하지 말아야 할 때:</h1>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>멀티스레딩은 상당한 속도 향상을 제공할 수 있지만 항상 모든 문제에 대한 최적의 해결책은 아닙니다. 멀티스레딩이 적합하지 않을 수 있는 몇 가지 시나리오는 다음과 같습니다:</p>
<ul>
<li>CPU 바운드 작업: 작업이 CPU에 많은 부하를 주고 순수한 수학 계산처럼 대기 시간이 거의 없는 경우, 별도의 프로세스를 생성하기 위해 multiprocessing 모듈을 사용하는 것이 더 효과적일 수 있습니다.</li>
<li>전역 인터프리터 잠금 (GIL): CPython에서 전역 인터프리터 잠금은 CPU 바운드 작업에 대한 멀티스레딩의 성능 향상을 제한할 수 있습니다. 이러한 경우에는 multiprocessing을 사용하거나 Jython이나 IronPython과 같은 GIL이 없는 구현을 사용하는 것이 효과적일 수 있습니다.</li>
<li>복잡한 공유 상태: 여러 스레드간의 복잡한 공유 상태를 관리하는 것은 경합 조건, 데드락 및 스레드 안전성과 관련된 문제와 버그를 도입할 수 있습니다.</li>
</ul>
<p>작업의 성격과 잠재적인 병목 현상을 이해함으로써 멀티스레딩이 응용 프로그램에 적합한 해결책인지 결정할 수 있습니다.</p>
<h1>전문 팁 - 데코레이터 사용하기</h1>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>데코레이터는 함수에 멀티스레딩을 더 우아하고 재사용 가능한 방식으로 추가할 수 있습니다. 데코레이터는 다른 함수를 받아들이고 그 동작을 명시적으로 수정하지 않고 확장하는 함수입니다.</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">import</span> time
<span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor, as_completed

<span class="hljs-comment"># 멀티스레딩을 추가하는 데코레이터</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">multithreaded</span>(<span class="hljs-params">max_workers=<span class="hljs-number">5</span></span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">func</span>):
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):
            <span class="hljs-keyword">with</span> ThreadPoolExecutor(max_workers=max_workers) <span class="hljs-keyword">as</span> executor:
                future_to_args = {executor.submit(func, arg): arg <span class="hljs-keyword">for</span> arg <span class="hljs-keyword">in</span> args[<span class="hljs-number">0</span>]}
                results = []
                <span class="hljs-keyword">for</span> future <span class="hljs-keyword">in</span> as_completed(future_to_args):
                    arg = future_to_args[future]
                    <span class="hljs-keyword">try</span>:
                        result = future.result()
                    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> exc:
                        <span class="hljs-built_in">print</span>(<span class="hljs-string">f'<span class="hljs-subst">{arg}</span>에서 예외가 발생했습니다: <span class="hljs-subst">{exc}</span>'</span>)
                    <span class="hljs-keyword">else</span>:
                        results.append(result)
                <span class="hljs-keyword">return</span> results
        <span class="hljs-keyword">return</span> wrapper
    <span class="hljs-keyword">return</span> decorator

<span class="hljs-comment"># 숫자를 제곱하는 함수</span>
<span class="hljs-meta">@multithreaded(<span class="hljs-params">max_workers=<span class="hljs-number">5</span></span>)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">square_number</span>(<span class="hljs-params">number</span>):
    time.sleep(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 시간이 오래 걸리는 작업 시뮬레이션</span>
    <span class="hljs-keyword">return</span> number * number

<span class="hljs-comment"># 처리할 숫자 목록</span>
numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>]

<span class="hljs-comment"># 데코레이터를 사용한 함수 실행</span>
start_time = time.time()
squared_numbers = square_number(numbers)
end_time = time.time()

<span class="hljs-built_in">print</span>(<span class="hljs-string">"제곱된 숫자:"</span>, squared_numbers)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"소요 시간:"</span>, end_time - start_time, <span class="hljs-string">"초"</span>)
</code></pre>
<p>데코레이터를 사용하여 멀티스레딩을 처리하면 코드가 단순해지는 것뿐만 아니라 재사용성이 높아지고 코드가 더 깔끔해집니다. @multithreaded 데코레이터를 쉽게 적용하여 Python 코드를 최적화하는 유연하고 강력한 방법을 제공하여 병렬로 실행해야 하는 모든 함수에 데코레이터를 쉽게 적용할 수 있습니다.</p>
<h1>결론</h1>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>멀티스레딩은 Python에서 루프를 최적화하는 강력한 도구입니다, 특히 I/O 바운드 및 동시성 작업에 대해. concurrent.futures 모듈을 활용하여 프로세스 시간을 크게 단축하고 프로그램의 효율성을 향상시킬 수 있습니다. 그러나 CPU 바운드 작업이나 복잡한 공유 상태를 다룰 때에는 멀티스레딩이 최선의 방법인지를 판단하기 위해 특정 사용 사례를 신중하게 평가하는 것이 중요합니다. 신중한 고려와 구현으로 멀티스레딩은 응용 프로그램의 성능을 크게 향상시킬 수 있습니다.</p>
<h1>연락하고 싶으시다구요?</h1>
<p>읽어 주셔서 감사합니다. 즐겁게 보셨기를 바라며 이 글에서 무언가를 얻을 수 있기를 바랍니다.</p>
<ul>
<li>만약 이 글이 마음에 드셨다면 아래에서 박수를 부탁드려요 👏👏👏...</li>
<li>더 많은 AI 정보를 얻기 위해 팔로우해 주세요 🤖🤖🤖...</li>
<li>LinkedIn에서 저를 찾아보세요</li>
<li>GitHub에서 코드를 확인해 보세요</li>
</ul>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>언제나 궁금한 점이나 아이디어, 추천 사항이 있으시면 언제든지 댓글로 질문해주세요.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"파이썬 코딩 멀티스레딩으로 for 루프 속도 10배 향상시키는 방법","description":"","date":"2024-07-13 19:21","slug":"2024-07-13-PythonCodingMakeForLoops10xFasterwithMultithreading","content":"\n\n\n![Python Coding Make For Loops 10x Faster with Multithreading](/TIL/assets/img/2024-07-13-PythonCodingMakeForLoops10xFasterwithMultithreading_0.png)\n\nFor loops are essential in programming. They allow us to iterate over sequences efficiently. However, for time-consuming tasks, using threads can be more efficient. Learn when and how to use threads to optimize performance. You can check out code examples in my GIT repo. The link is in the footer.\n\nLet's look at an example. We will simulate a time-consuming task by squaring numbers using a Python script with a for loop:\n\n```python\nimport time\n\n# List of numbers to process\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n# Function to square a number\ndef square_number(number):\n    time.sleep(1)  # Simulate a time-consuming task\n    return number * number\n\n# Using a for loop to process each number\nsquared_numbers = []\nstart_time = time.time()\nfor number in numbers:\n    squared_numbers.append(square_number(number))\n\nend_time = time.time()\n\nprint(\"Squared numbers:\", squared_numbers)\nprint(\"Time taken:\", end_time - start_time, \"seconds\")\n# Time taken: 10.082990884780884 seconds\n```\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 스크립트는 square_number 함수 내의 time.sleep(1) 호출로 인해 각 숫자를 순차적으로 처리합니다. 전체 실행에는 10.1초가 소요됩니다.\n\n## 멀티스레딩으로 최적화\n\n다음으로, 처리 시간을 개선하기 위해 멀티스레딩 접근 방식으로 최적화할 것입니다. 멀티스레딩을 사용하여 위 예제를 최적화하려면 Python의 concurrent.futures 모듈을 사용할 수 있습니다. 이 모듈은 콜러블을 비동기적으로 실행하기 위한 고수준 인터페이스를 제공합니다.\n\n다음은 스크립트를 멀티스레딩을 사용하도록 수정하는 방법입니다:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport time\nfrom concurrent.futures import ThreadPoolExecutor\n\n# 처리할 숫자의 목록\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n# 숫자를 제곱하는 함수\ndef square_number(number):\n    time.sleep(1)  # 시간이 많이 소요되는 작업을 모방\n    return number * number\n\n# 멀티스레딩을 위해 ThreadPoolExecutor 사용\nsquared_numbers = []\nstart_time = time.time()\n\nwith ThreadPoolExecutor(max_workers=10) as executor:\n    results = executor.map(square_number, numbers)\n\n# 결과 수집\nsquared_numbers = list(results)\n\nend_time = time.time()\n\nprint(\"제곱된 숫자:\", squared_numbers)\nprint(\"소요 시간:\", end_time - start_time, \"초\")\n# 소요 시간: 2.0257720947265625 초\n```\n\n이 최적화된 스크립트에서 우리는 ThreadPoolExecutor를 사용해 스레드 풀을 생성합니다. executor.map 함수는 숫자를 병렬로 처리하는 스레드에 square_number 함수를 분배합니다. max_workers를 5로 설정하여 최대 5개의 스레드가 동시에 실행되도록 하여 총 처리 시간을 크게 줄일 수 있습니다.\n\n특정 사용 사례에 최적인 스레드 수를 찾으려면 max_workers 매개변수를 조정해보세요.\n\n# 멀티스레딩 사용 시기\n\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다중 스레딩은 다양한 시나리오에서 상당한 속도 향상을 제공할 수 있다는 것을 보셨을 것입니다. 그러나 모든 작업에 적합한 것은 아닙니다. 다음은 다중 스레딩이 특히 유익한 일반적인 사용 사례 몇 가지입니다:\n\n## 1. I/O-바운드 작업:\n\n- 파일 I/O: 파일 읽기 및 쓰기, 특히 크거나 많은 파일을 다룰 때.\n- 네트워크 I/O: 여러 네트워크 연결을 동시에 처리하는 경우, 예를 들어 웹 스크래핑, 파일 다운로드 또는 웹 서버의 요청 처리.\n- 데이터베이스 작업: I/O 바운드인 데이터베이스 쿼리 수행, 대용량 데이터 세트를 가져오거나 업데이트하는 작업 등.\n\n## 2. 동시 작업:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 실시간 데이터 처리: 여러 센서 또는 스트림에서 데이터를 실시간으로 처리하며, IoT 응용 프로그램에서 사용됩니다.\n- GUI 어플리케이션: 사용자 인터페이스를 반응적으로 유지하기 위해 시간이 많이 소요되는 작업을 백그라운드에서 실행합니다.\n\n## 3. 독립적인 작업의 병렬 처리:\n\n- 일괄 처리: 이미지 처리 또는 데이터 변환 작업과 같이 병렬로 실행할 수 있는 많은 독립적인 작업을 처리합니다.\n- 시뮬레이션: 여러 시뮬레이션 또는 몬테카를로 실험을 동시에 실행합니다.\n\n# 멀티스레딩을 사용하지 말아야 할 때:\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n멀티스레딩은 상당한 속도 향상을 제공할 수 있지만 항상 모든 문제에 대한 최적의 해결책은 아닙니다. 멀티스레딩이 적합하지 않을 수 있는 몇 가지 시나리오는 다음과 같습니다:\n\n- CPU 바운드 작업: 작업이 CPU에 많은 부하를 주고 순수한 수학 계산처럼 대기 시간이 거의 없는 경우, 별도의 프로세스를 생성하기 위해 multiprocessing 모듈을 사용하는 것이 더 효과적일 수 있습니다.\n- 전역 인터프리터 잠금 (GIL): CPython에서 전역 인터프리터 잠금은 CPU 바운드 작업에 대한 멀티스레딩의 성능 향상을 제한할 수 있습니다. 이러한 경우에는 multiprocessing을 사용하거나 Jython이나 IronPython과 같은 GIL이 없는 구현을 사용하는 것이 효과적일 수 있습니다.\n- 복잡한 공유 상태: 여러 스레드간의 복잡한 공유 상태를 관리하는 것은 경합 조건, 데드락 및 스레드 안전성과 관련된 문제와 버그를 도입할 수 있습니다.\n\n작업의 성격과 잠재적인 병목 현상을 이해함으로써 멀티스레딩이 응용 프로그램에 적합한 해결책인지 결정할 수 있습니다.\n\n# 전문 팁 - 데코레이터 사용하기\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n데코레이터는 함수에 멀티스레딩을 더 우아하고 재사용 가능한 방식으로 추가할 수 있습니다. 데코레이터는 다른 함수를 받아들이고 그 동작을 명시적으로 수정하지 않고 확장하는 함수입니다.\n\n```python\nimport time\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\n\n# 멀티스레딩을 추가하는 데코레이터\ndef multithreaded(max_workers=5):\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            with ThreadPoolExecutor(max_workers=max_workers) as executor:\n                future_to_args = {executor.submit(func, arg): arg for arg in args[0]}\n                results = []\n                for future in as_completed(future_to_args):\n                    arg = future_to_args[future]\n                    try:\n                        result = future.result()\n                    except Exception as exc:\n                        print(f'{arg}에서 예외가 발생했습니다: {exc}')\n                    else:\n                        results.append(result)\n                return results\n        return wrapper\n    return decorator\n\n# 숫자를 제곱하는 함수\n@multithreaded(max_workers=5)\ndef square_number(number):\n    time.sleep(1)  # 시간이 오래 걸리는 작업 시뮬레이션\n    return number * number\n\n# 처리할 숫자 목록\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n# 데코레이터를 사용한 함수 실행\nstart_time = time.time()\nsquared_numbers = square_number(numbers)\nend_time = time.time()\n\nprint(\"제곱된 숫자:\", squared_numbers)\nprint(\"소요 시간:\", end_time - start_time, \"초\")\n```\n\n데코레이터를 사용하여 멀티스레딩을 처리하면 코드가 단순해지는 것뿐만 아니라 재사용성이 높아지고 코드가 더 깔끔해집니다. @multithreaded 데코레이터를 쉽게 적용하여 Python 코드를 최적화하는 유연하고 강력한 방법을 제공하여 병렬로 실행해야 하는 모든 함수에 데코레이터를 쉽게 적용할 수 있습니다.\n\n# 결론\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n멀티스레딩은 Python에서 루프를 최적화하는 강력한 도구입니다, 특히 I/O 바운드 및 동시성 작업에 대해. concurrent.futures 모듈을 활용하여 프로세스 시간을 크게 단축하고 프로그램의 효율성을 향상시킬 수 있습니다. 그러나 CPU 바운드 작업이나 복잡한 공유 상태를 다룰 때에는 멀티스레딩이 최선의 방법인지를 판단하기 위해 특정 사용 사례를 신중하게 평가하는 것이 중요합니다. 신중한 고려와 구현으로 멀티스레딩은 응용 프로그램의 성능을 크게 향상시킬 수 있습니다.\n\n# 연락하고 싶으시다구요?\n\n읽어 주셔서 감사합니다. 즐겁게 보셨기를 바라며 이 글에서 무언가를 얻을 수 있기를 바랍니다.\n\n- 만약 이 글이 마음에 드셨다면 아래에서 박수를 부탁드려요 👏👏👏...\n- 더 많은 AI 정보를 얻기 위해 팔로우해 주세요 🤖🤖🤖...\n- LinkedIn에서 저를 찾아보세요\n- GitHub에서 코드를 확인해 보세요\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n언제나 궁금한 점이나 아이디어, 추천 사항이 있으시면 언제든지 댓글로 질문해주세요.","ogImage":{"url":"/TIL/assets/img/2024-07-13-PythonCodingMakeForLoops10xFasterwithMultithreading_0.png"},"coverImage":"/TIL/assets/img/2024-07-13-PythonCodingMakeForLoops10xFasterwithMultithreading_0.png","tag":["Tech"],"readingTime":8},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-13-PythonCodingMakeForLoops10xFasterwithMultithreading_0.png\" alt=\"Python Coding Make For Loops 10x Faster with Multithreading\"\u003e\u003c/p\u003e\n\u003cp\u003eFor loops are essential in programming. They allow us to iterate over sequences efficiently. However, for time-consuming tasks, using threads can be more efficient. Learn when and how to use threads to optimize performance. You can check out code examples in my GIT repo. The link is in the footer.\u003c/p\u003e\n\u003cp\u003eLet's look at an example. We will simulate a time-consuming task by squaring numbers using a Python script with a for loop:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e time\n\n\u003cspan class=\"hljs-comment\"\u003e# List of numbers to process\u003c/span\u003e\nnumbers = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e]\n\n\u003cspan class=\"hljs-comment\"\u003e# Function to square a number\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esquare_number\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003enumber\u003c/span\u003e):\n    time.sleep(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)  \u003cspan class=\"hljs-comment\"\u003e# Simulate a time-consuming task\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e number * number\n\n\u003cspan class=\"hljs-comment\"\u003e# Using a for loop to process each number\u003c/span\u003e\nsquared_numbers = []\nstart_time = time.time()\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e number \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e numbers:\n    squared_numbers.append(square_number(number))\n\nend_time = time.time()\n\n\u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Squared numbers:\"\u003c/span\u003e, squared_numbers)\n\u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Time taken:\"\u003c/span\u003e, end_time - start_time, \u003cspan class=\"hljs-string\"\u003e\"seconds\"\u003c/span\u003e)\n\u003cspan class=\"hljs-comment\"\u003e# Time taken: 10.082990884780884 seconds\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 스크립트는 square_number 함수 내의 time.sleep(1) 호출로 인해 각 숫자를 순차적으로 처리합니다. 전체 실행에는 10.1초가 소요됩니다.\u003c/p\u003e\n\u003ch2\u003e멀티스레딩으로 최적화\u003c/h2\u003e\n\u003cp\u003e다음으로, 처리 시간을 개선하기 위해 멀티스레딩 접근 방식으로 최적화할 것입니다. 멀티스레딩을 사용하여 위 예제를 최적화하려면 Python의 concurrent.futures 모듈을 사용할 수 있습니다. 이 모듈은 콜러블을 비동기적으로 실행하기 위한 고수준 인터페이스를 제공합니다.\u003c/p\u003e\n\u003cp\u003e다음은 스크립트를 멀티스레딩을 사용하도록 수정하는 방법입니다:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e time\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e concurrent.\u003cspan class=\"hljs-property\"\u003efutures\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eThreadPoolExecutor\u003c/span\u003e\n\n# 처리할 숫자의 목록\nnumbers = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e]\n\n# 숫자를 제곱하는 함수\ndef \u003cspan class=\"hljs-title function_\"\u003esquare_number\u003c/span\u003e(number):\n    time.\u003cspan class=\"hljs-title function_\"\u003esleep\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)  # 시간이 많이 소요되는 작업을 모방\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e number * number\n\n# 멀티스레딩을 위해 \u003cspan class=\"hljs-title class_\"\u003eThreadPoolExecutor\u003c/span\u003e 사용\nsquared_numbers = []\nstart_time = time.\u003cspan class=\"hljs-title function_\"\u003etime\u003c/span\u003e()\n\n\u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eThreadPoolExecutor\u003c/span\u003e(max_workers=\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eexecutor\u003c/span\u003e:\n    results = executor.\u003cspan class=\"hljs-title function_\"\u003emap\u003c/span\u003e(square_number, numbers)\n\n# 결과 수집\nsquared_numbers = \u003cspan class=\"hljs-title function_\"\u003elist\u003c/span\u003e(results)\n\nend_time = time.\u003cspan class=\"hljs-title function_\"\u003etime\u003c/span\u003e()\n\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"제곱된 숫자:\"\u003c/span\u003e, squared_numbers)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"소요 시간:\"\u003c/span\u003e, end_time - start_time, \u003cspan class=\"hljs-string\"\u003e\"초\"\u003c/span\u003e)\n# 소요 시간: \u003cspan class=\"hljs-number\"\u003e2.0257720947265625\u003c/span\u003e 초\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 최적화된 스크립트에서 우리는 ThreadPoolExecutor를 사용해 스레드 풀을 생성합니다. executor.map 함수는 숫자를 병렬로 처리하는 스레드에 square_number 함수를 분배합니다. max_workers를 5로 설정하여 최대 5개의 스레드가 동시에 실행되도록 하여 총 처리 시간을 크게 줄일 수 있습니다.\u003c/p\u003e\n\u003cp\u003e특정 사용 사례에 최적인 스레드 수를 찾으려면 max_workers 매개변수를 조정해보세요.\u003c/p\u003e\n\u003ch1\u003e멀티스레딩 사용 시기\u003c/h1\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e다중 스레딩은 다양한 시나리오에서 상당한 속도 향상을 제공할 수 있다는 것을 보셨을 것입니다. 그러나 모든 작업에 적합한 것은 아닙니다. 다음은 다중 스레딩이 특히 유익한 일반적인 사용 사례 몇 가지입니다:\u003c/p\u003e\n\u003ch2\u003e1. I/O-바운드 작업:\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e파일 I/O: 파일 읽기 및 쓰기, 특히 크거나 많은 파일을 다룰 때.\u003c/li\u003e\n\u003cli\u003e네트워크 I/O: 여러 네트워크 연결을 동시에 처리하는 경우, 예를 들어 웹 스크래핑, 파일 다운로드 또는 웹 서버의 요청 처리.\u003c/li\u003e\n\u003cli\u003e데이터베이스 작업: I/O 바운드인 데이터베이스 쿼리 수행, 대용량 데이터 세트를 가져오거나 업데이트하는 작업 등.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e2. 동시 작업:\u003c/h2\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e실시간 데이터 처리: 여러 센서 또는 스트림에서 데이터를 실시간으로 처리하며, IoT 응용 프로그램에서 사용됩니다.\u003c/li\u003e\n\u003cli\u003eGUI 어플리케이션: 사용자 인터페이스를 반응적으로 유지하기 위해 시간이 많이 소요되는 작업을 백그라운드에서 실행합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e3. 독립적인 작업의 병렬 처리:\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e일괄 처리: 이미지 처리 또는 데이터 변환 작업과 같이 병렬로 실행할 수 있는 많은 독립적인 작업을 처리합니다.\u003c/li\u003e\n\u003cli\u003e시뮬레이션: 여러 시뮬레이션 또는 몬테카를로 실험을 동시에 실행합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e멀티스레딩을 사용하지 말아야 할 때:\u003c/h1\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e멀티스레딩은 상당한 속도 향상을 제공할 수 있지만 항상 모든 문제에 대한 최적의 해결책은 아닙니다. 멀티스레딩이 적합하지 않을 수 있는 몇 가지 시나리오는 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCPU 바운드 작업: 작업이 CPU에 많은 부하를 주고 순수한 수학 계산처럼 대기 시간이 거의 없는 경우, 별도의 프로세스를 생성하기 위해 multiprocessing 모듈을 사용하는 것이 더 효과적일 수 있습니다.\u003c/li\u003e\n\u003cli\u003e전역 인터프리터 잠금 (GIL): CPython에서 전역 인터프리터 잠금은 CPU 바운드 작업에 대한 멀티스레딩의 성능 향상을 제한할 수 있습니다. 이러한 경우에는 multiprocessing을 사용하거나 Jython이나 IronPython과 같은 GIL이 없는 구현을 사용하는 것이 효과적일 수 있습니다.\u003c/li\u003e\n\u003cli\u003e복잡한 공유 상태: 여러 스레드간의 복잡한 공유 상태를 관리하는 것은 경합 조건, 데드락 및 스레드 안전성과 관련된 문제와 버그를 도입할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e작업의 성격과 잠재적인 병목 현상을 이해함으로써 멀티스레딩이 응용 프로그램에 적합한 해결책인지 결정할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e전문 팁 - 데코레이터 사용하기\u003c/h1\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e데코레이터는 함수에 멀티스레딩을 더 우아하고 재사용 가능한 방식으로 추가할 수 있습니다. 데코레이터는 다른 함수를 받아들이고 그 동작을 명시적으로 수정하지 않고 확장하는 함수입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e time\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e concurrent.futures \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e ThreadPoolExecutor, as_completed\n\n\u003cspan class=\"hljs-comment\"\u003e# 멀티스레딩을 추가하는 데코레이터\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emultithreaded\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003emax_workers=\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e\u003c/span\u003e):\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edecorator\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003efunc\u003c/span\u003e):\n        \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ewrapper\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e*args, **kwargs\u003c/span\u003e):\n            \u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e ThreadPoolExecutor(max_workers=max_workers) \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e executor:\n                future_to_args = {executor.submit(func, arg): arg \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e arg \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e args[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]}\n                results = []\n                \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e future \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e as_completed(future_to_args):\n                    arg = future_to_args[future]\n                    \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e:\n                        result = future.result()\n                    \u003cspan class=\"hljs-keyword\"\u003eexcept\u003c/span\u003e Exception \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e exc:\n                        \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003ef'\u003cspan class=\"hljs-subst\"\u003e{arg}\u003c/span\u003e에서 예외가 발생했습니다: \u003cspan class=\"hljs-subst\"\u003e{exc}\u003c/span\u003e'\u003c/span\u003e)\n                    \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e:\n                        results.append(result)\n                \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e results\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e wrapper\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e decorator\n\n\u003cspan class=\"hljs-comment\"\u003e# 숫자를 제곱하는 함수\u003c/span\u003e\n\u003cspan class=\"hljs-meta\"\u003e@multithreaded(\u003cspan class=\"hljs-params\"\u003emax_workers=\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e\u003c/span\u003e)\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esquare_number\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003enumber\u003c/span\u003e):\n    time.sleep(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)  \u003cspan class=\"hljs-comment\"\u003e# 시간이 오래 걸리는 작업 시뮬레이션\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e number * number\n\n\u003cspan class=\"hljs-comment\"\u003e# 처리할 숫자 목록\u003c/span\u003e\nnumbers = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e]\n\n\u003cspan class=\"hljs-comment\"\u003e# 데코레이터를 사용한 함수 실행\u003c/span\u003e\nstart_time = time.time()\nsquared_numbers = square_number(numbers)\nend_time = time.time()\n\n\u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"제곱된 숫자:\"\u003c/span\u003e, squared_numbers)\n\u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"소요 시간:\"\u003c/span\u003e, end_time - start_time, \u003cspan class=\"hljs-string\"\u003e\"초\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e데코레이터를 사용하여 멀티스레딩을 처리하면 코드가 단순해지는 것뿐만 아니라 재사용성이 높아지고 코드가 더 깔끔해집니다. @multithreaded 데코레이터를 쉽게 적용하여 Python 코드를 최적화하는 유연하고 강력한 방법을 제공하여 병렬로 실행해야 하는 모든 함수에 데코레이터를 쉽게 적용할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e멀티스레딩은 Python에서 루프를 최적화하는 강력한 도구입니다, 특히 I/O 바운드 및 동시성 작업에 대해. concurrent.futures 모듈을 활용하여 프로세스 시간을 크게 단축하고 프로그램의 효율성을 향상시킬 수 있습니다. 그러나 CPU 바운드 작업이나 복잡한 공유 상태를 다룰 때에는 멀티스레딩이 최선의 방법인지를 판단하기 위해 특정 사용 사례를 신중하게 평가하는 것이 중요합니다. 신중한 고려와 구현으로 멀티스레딩은 응용 프로그램의 성능을 크게 향상시킬 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e연락하고 싶으시다구요?\u003c/h1\u003e\n\u003cp\u003e읽어 주셔서 감사합니다. 즐겁게 보셨기를 바라며 이 글에서 무언가를 얻을 수 있기를 바랍니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e만약 이 글이 마음에 드셨다면 아래에서 박수를 부탁드려요 👏👏👏...\u003c/li\u003e\n\u003cli\u003e더 많은 AI 정보를 얻기 위해 팔로우해 주세요 🤖🤖🤖...\u003c/li\u003e\n\u003cli\u003eLinkedIn에서 저를 찾아보세요\u003c/li\u003e\n\u003cli\u003eGitHub에서 코드를 확인해 보세요\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e언제나 궁금한 점이나 아이디어, 추천 사항이 있으시면 언제든지 댓글로 질문해주세요.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-07-13-PythonCodingMakeForLoops10xFasterwithMultithreading"},"buildId":"xx51Gh_JNHDTBdDwrgykD","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>