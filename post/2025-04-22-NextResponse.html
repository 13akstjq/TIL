<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Nextjs 15에서 응답 처리 쉽게 하는 방법(NextResponse) | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-NextResponse" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Nextjs 15에서 응답 처리 쉽게 하는 방법(NextResponse) | TIL" data-gatsby-head="true"/><meta property="og:title" content="Nextjs 15에서 응답 처리 쉽게 하는 방법(NextResponse) | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-NextResponse" data-gatsby-head="true"/><meta name="twitter:title" content="Nextjs 15에서 응답 처리 쉽게 하는 방법(NextResponse) | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2025-04-22 12:42" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/post/%5Bslug%5D-8ded8b979ba73586.js" defer=""></script><script src="/TIL/_next/static/X4OrKfmLtU3-3BijwfHe6/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/X4OrKfmLtU3-3BijwfHe6/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Nextjs 15에서 응답 처리 쉽게 하는 방법(NextResponse)</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Nextjs 15에서 응답 처리 쉽게 하는 방법(NextResponse)" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Apr 22, 2025</span><span class="posts_reading_time__f7YPP">12<!-- --> min read</span></span></div></div></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h1>NextResponse</h1>
<p>NextResponse는 Web Response API를 확장한 것으로, 좀 더 편리하게 사용할 수 있는 메서드들이 추가된 Response 객체입니다. 기존의 Response 객체보다 훨씬 직관적이고 유용한 기능들을 제공해서, 특히 서버 사이드에서 많이 활용됩니다.</p>
<h2>cookies</h2>
<p>NextResponse의 <code>cookies</code> 속성을 사용하면, 응답(Response)의 <code>Set-Cookie</code> 헤더를 읽거나 변경할 수 있어요. 즉, 클라이언트에게 보낼 쿠키를 쉽게 관리할 수 있다는 뜻이죠.</p>
<p>예를 들어, 서버에서 쿠키를 추가하거나 수정할 때 직접 헤더를 조작하는 것보다 훨씬 깔끔하게 쓸 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">NextResponse</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/server'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">middleware</span>(<span class="hljs-params">req</span>) {
  <span class="hljs-keyword">const</span> res = <span class="hljs-title class_">NextResponse</span>.<span class="hljs-title function_">next</span>();

  <span class="hljs-comment">// 쿠키 읽기</span>
  <span class="hljs-keyword">const</span> token = req.<span class="hljs-property">cookies</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">'token'</span>);

  <span class="hljs-comment">// 쿠키 설정하기</span>
  res.<span class="hljs-property">cookies</span>.<span class="hljs-title function_">set</span>(<span class="hljs-string">'loggedIn'</span>, <span class="hljs-string">'true'</span>, { <span class="hljs-attr">path</span>: <span class="hljs-string">'/'</span>, <span class="hljs-attr">httpOnly</span>: <span class="hljs-literal">true</span> });

  <span class="hljs-keyword">return</span> res;
}
</code></pre>
<p>이처럼 NextResponse의 <code>cookies</code> API를 쓰면 쿠키를 딱 한 줄로 읽고 쓸 수 있어서, 복잡한 헤더 조작 없이도 쉽게 작업할 수 있답니다.</p>
<p>추가로, <code>cookies.set()</code> 메서드는 옵션으로 <code>httpOnly</code>, <code>secure</code>, <code>maxAge</code> 같은 여러 속성들을 받아서 보안이나 유효기간 설정도 간편해요.<br>
또한, Next.js 13부터는 미들웨어나 API 라우트 등 서버 환경에서 이런 NextResponse API를 적극 활용해서 더 깔끔한 코드를 작성할 수 있으니, 꼭 한 번 써보시길 추천합니다!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h3>set(name, value)</h3>
<p>이 메서드는 이름(name)과 값(value)을 받아서 응답(response)에 쿠키를 설정해주는 역할을 해요.</p>
<p>예를 들어, 사용자가 어떤 배너를 다시 보지 않도록 설정하고 싶을 때 이렇게 활용할 수 있죠.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// /home 경로로 들어오는 요청이 있을 때</span>
<span class="hljs-keyword">let</span> response = <span class="hljs-title class_">NextResponse</span>.<span class="hljs-title function_">next</span>()
<span class="hljs-comment">// 'show-banner'라는 이름의 쿠키를 'false' 값으로 설정해서 배너 숨기기</span>
response.<span class="hljs-property">cookies</span>.<span class="hljs-title function_">set</span>(<span class="hljs-string">'show-banner'</span>, <span class="hljs-string">'false'</span>)
<span class="hljs-comment">// 이 응답에는 `Set-Cookie: show-banner=false; path=/home` 헤더가 포함되어 반환됩니다.</span>
<span class="hljs-keyword">return</span> response
</code></pre>
<p>여기서 중요한 점은 <code>response.cookies.set()</code>을 사용하면 쿠키가 응답 헤더에 <code>Set-Cookie</code> 형태로 추가된다는 거예요. 그리고 경로(path) 옵션은 기본적으로 요청된 경로와 동일하게 설정되기 때문에, 원하는 경로로 지정하려면 옵션을 명시해 주어야 해요.</p>
<pre><code class="hljs language-js">response.<span class="hljs-property">cookies</span>.<span class="hljs-title function_">set</span>(<span class="hljs-string">'user-preference'</span>, <span class="hljs-string">'dark-mode'</span>, { <span class="hljs-attr">path</span>: <span class="hljs-string">'/'</span> })
</code></pre>
<p>이렇게 하면 쿠키가 모든 경로에서 유효하게 설정됩니다.</p>
<hr>
<h3>get(name)</h3>
<p>쿠키 값을 읽을 때는 <code>get(name)</code> 메서드를 사용해요. 예를 들어 사용자가 이전에 설정한 배너 표시 여부를 확인하고 싶을 때 사용할 수 있겠죠.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> showBanner = request.<span class="hljs-property">cookies</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">'show-banner'</span>)
</code></pre>
<p>이렇게 하면 <code>showBanner</code> 변수에 쿠키의 값이 담겨 오고, 없으면 <code>undefined</code>가 반환됩니다.</p>
<hr>
<h3>참고로!</h3>
<ul>
<li>쿠키는 클라이언트와 서버 사이에서 상태를 유지하는 간단한 방법이에요. 특히 사용자의 선호나 로그인 상태 같은 정보를 저장할 때 자주 사용되죠.</li>
<li>Next.js 13부터는 <code>NextResponse</code> 객체를 통해 쿠키를 쉽게 다룰 수 있어서 편리해요.</li>
<li>보안 상 민감한 정보(예: 비밀번호, 토큰 등)는 절대 쿠키에 그냥 저장하면 안 되고 <code>HttpOnly</code>, <code>Secure</code> 옵션을 꼭 설정해야 해요.</li>
<li>또한 쿠키 용량 제한과 만료일 설정도 신경 써야 하고요.</li>
</ul>
<p>필요하면 쿠키 설정에 <code>expires</code>, <code>maxAge</code>, <code>secure</code>, <code>httpOnly</code> 등의 옵션도 함께 활용해 보세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>쿠키를 다룰 때 자주 쓰는 메서드인 <code>get()</code>과 <code>getAll()</code>에 대해 쉽게 설명해볼게요!</p>
<hr>
<h3><code>get()</code> 메서드</h3>
<ul>
<li><strong>기능:</strong> 쿠키 이름을 주면, 그 쿠키의 <strong>값(value)</strong> 을 가져와 줘요.</li>
<li><strong>예외 상황:</strong>
<ul>
<li>쿠키가 없다면 <code>undefined</code>를 반환해요.</li>
<li>만약 한 이름으로 여러 개의 쿠키가 있으면, 맨 처음 쿠키의 값을 반환합니다.</li>
</ul>
</li>
</ul>
<p>예를 들어, <code>/home</code> 경로에서 들어오는 요청이 있다고 하고,</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> response = <span class="hljs-title class_">NextResponse</span>.<span class="hljs-title function_">next</span>()
<span class="hljs-comment">// 쿠키 중 { name: 'show-banner', value: 'false', Path: '/home' } 가 있다고 가정하면,</span>
response.<span class="hljs-property">cookies</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">'show-banner'</span>) <span class="hljs-comment">// 'false' 반환</span>
</code></pre>
<p>첫 번째 일치하는 쿠키 값을 리턴하니 정말 간편하죠?</p>
<hr>
<h3><code>getAll()</code> 메서드</h3>
<ul>
<li><strong>기능:</strong>
<ul>
<li>쿠키 이름을 주면, 이름에 해당하는 모든 쿠키들을 배열로 받아요.</li>
<li>이름을 안 주면, <strong>현재 응답(response)에 포함된 모든 쿠키</strong>를 배열로 반환합니다.</li>
</ul>
</li>
</ul>
<p>이걸 활용하면 같은 이름으로 중복된 쿠키를 한꺼번에 다룰 수도 있고,
한번에 모든 쿠키를 살펴보기도 좋아요.</p>
<hr>
<h3>추가 꿀팁!</h3>
<ul>
<li>쿠키는 같은 이름이라도 경로나 도메인 범위가 다를 수 있다는 점 기억하세요! 그래서 중복된 이름의 쿠키가 있을 수 있거든요.</li>
<li><code>get()</code>는 첫 번째 쿠키만 가져오니까, 혹시 여러 개 있을 때 모두 확인하려면 <code>getAll()</code>을 쓰세요.</li>
<li>클라이언트에서 쿠키를 조작할 때는 보안 설정(예: HttpOnly, Secure)도 꼭 챙기는 게 좋아요.</li>
</ul>
<p>꾸준히 쿠키를 잘 다루면 로그인, 알림 설정 등 중요한 기능들을 매끄럽게 만들 수 있답니다!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>next.js에서 response.cookies 다룰 때, 쿠키를 삭제하는 방법에 대해 간단하게 알려줄게요.</p>
<p>보통 쿠키를 삭제할 땐 set-cookie 헤더를 통해 만료된 상태로 만들어 보내잖아요? next.js 13부터는 NextResponse 객체가 쿠키 API를 제공해서, <code>response.cookies.delete('쿠키명')</code> 이렇게 한 줄로 쉽게 삭제가 가능해요.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// /home 경로로 들어온 요청 처리 중</span>
<span class="hljs-keyword">let</span> response = <span class="hljs-title class_">NextResponse</span>.<span class="hljs-title function_">next</span>()
<span class="hljs-comment">// 'experiments'라는 이름의 쿠키가 있다면 삭제합니다.</span>
<span class="hljs-keyword">const</span> deleted = response.<span class="hljs-property">cookies</span>.<span class="hljs-title function_">delete</span>(<span class="hljs-string">'experiments'</span>) 
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(deleted) <span class="hljs-comment">// 쿠키를 삭제했으면 true, 없으면 false 반환</span>
</code></pre>
<p>여기서 <code>delete</code> 메서드는 실제 쿠키가 있으면 삭제 처리 후 <code>true</code>를 반환하고, 없으면 <code>false</code>를 반환해서 잘 삭제되었는지 확인할 수 있어요. 그리고 삭제할 때는 해당 쿠키의 path(경로)도 맞춰줘야 삭제가 제대로 되는데, 기본 path가 맞으면 굳이 지정 안 해도 돼요.</p>
<hr>
<p>추가로 알아두면 좋은 점!</p>
<ul>
<li><code>response.cookies.getAll()</code>로 response에 담긴 모든 쿠키를 배열로 쉽게 조회할 수 있어요.</li>
<li>쿠키 이름이 같으면, 여러 개의 쿠키가 배열로 반환됩니다. (<code>[{name, value, Path}, ...]</code>)</li>
<li>쿠키를 삭제할 때 특정 path나 domain도 설정해야 할 경우가 있으니, 필요하면 옵션도 같이 넘겨줄 수 있어요.</li>
</ul>
<hr>
<p>조금 더 쉽게 이해되도록 요약표를 만들었으니 참고하세요!</p>

























<table><thead><tr><th>메서드</th><th>설명</th><th>반환값</th></tr></thead><tbody><tr><td><code>response.cookies.getAll('쿠키명')</code></td><td>특정 이름의 모든 쿠키 조회</td><td>쿠키 배열</td></tr><tr><td><code>response.cookies.getAll()</code></td><td>모든 쿠키 조회</td><td>쿠키 배열</td></tr><tr><td><code>response.cookies.delete('쿠키명')</code></td><td>쿠키 삭제</td><td>삭제 성공 시: <code>true</code>, 실패 시: <code>false</code></td></tr></tbody></table>
<hr>
<p>사실 개발할 때 쿠키 관리가 깔끔해야 나중에 디버깅하기도 편한데, next.js의 <code>response.cookies</code> API가 이런 면에서 훨씬 편리하니 적극 활용해 보세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>json() 함수 사용하기</h2>
<p>Next.js에서 API 응답을 JSON 형태로 쉽게 만들어주는 <code>NextResponse.json()</code> 함수에 대해 알아볼게요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">NextResponse</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/server'</span>
 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">GET</span>(<span class="hljs-params">request: Request</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">NextResponse</span>.<span class="hljs-title function_">json</span>({ <span class="hljs-attr">error</span>: <span class="hljs-string">'Internal Server Error'</span> }, { <span class="hljs-attr">status</span>: <span class="hljs-number">500</span> })
}
</code></pre>
<p>위처럼 사용하면, 클라이언트에 <code>{ error: 'Internal Server Error' }</code>라는 JSON 데이터를 보내면서, HTTP 상태 코드를 500으로 설정할 수 있어요. 간단하죠?</p>
<p>참고로, <code>NextResponse.json()</code>은 내부적으로 <code>Content-Type</code> 헤더를 <code>application/json</code>으로 설정하니까, 따로 헤더 신경 쓸 필요가 없답니다.</p>
<hr>
<h2>redirect() 함수 소개</h2>
<p><code>redirect()</code> 함수는 원하는 URL로 클라이언트를 리다이렉트할 때 사용해요. 서버에서 특정 조건이 충족되면 다른 페이지로 보내고 싶을 때 참 유용하죠.</p>
<p>예를 들어, 다음처럼 쓸 수 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">NextResponse</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/server'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">GET</span>(<span class="hljs-params">request: Request</span>) {
  <span class="hljs-comment">// 로그인하지 않은 사용자라면, 로그인 페이지로 리다이렉트</span>
  <span class="hljs-keyword">const</span> isLoggedIn = <span class="hljs-literal">false</span> <span class="hljs-comment">// 예시용 변수</span>
  <span class="hljs-keyword">if</span> (!isLoggedIn) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">NextResponse</span>.<span class="hljs-title function_">redirect</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'/login'</span>, request.<span class="hljs-property">url</span>))
  }
  
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">NextResponse</span>.<span class="hljs-title function_">json</span>({ <span class="hljs-attr">message</span>: <span class="hljs-string">'Welcome back!'</span> })
}
</code></pre>
<p>위 코드에서는 사용자가 로그인하지 않았다면 <code>/login</code> 경로로 리다이렉트시키고, 로그인되어 있으면 JSON 메시지를 보내줘요.</p>
<hr>
<h3>추가 팁: HTTP 상태 코드 지정하기</h3>
<p><code>redirect()</code>는 기본적으로 307 Temporary Redirect 상태 코드를 사용하는데, 필요에 따라 다른 상태 코드를 지정할 수도 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">return</span> <span class="hljs-title class_">NextResponse</span>.<span class="hljs-title function_">redirect</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'/login'</span>, request.<span class="hljs-property">url</span>), <span class="hljs-number">302</span>)
</code></pre>
<p>여기서 <code>302</code>는 임시 리다이렉트를 의미해요. 상황에 맞게 301 (영구 리다이렉트) 같은 코드를 넣어도 됩니다.</p>
<hr>
<h3>정리하자면…</h3>




















<table><thead><tr><th>기능</th><th>예시 코드</th><th>설명</th></tr></thead><tbody><tr><td>JSON 응답</td><td><code>NextResponse.json({ key: 'value' }, { status: 200 })</code></td><td>JSON 데이터와 상태 코드 함께 보내기</td></tr><tr><td>리다이렉트</td><td><code>NextResponse.redirect(new URL('/path', request.url), 302)</code></td><td>클라이언트를 다른 URL로 리다이렉트하기</td></tr></tbody></table>
<p>이 두 함수만 잘 활용해도 Next.js API 라우트에서 훨씬 깔끔하고 명확한 응답 관리가 가능하니 꼭 익혀두세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Next.js에서 리다이렉션을 구현할 때는 <code>NextResponse.redirect()</code>를 사용하면 정말 편리해요. 간단히 말해, 원하는 URL로 사용자를 보내는 기능인데요, URL을 동적으로 만들거나 수정할 수도 있답니다.</p>
<p>예를 들어, 기본적인 리다이렉트는 이렇게 할 수 있어요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">NextResponse</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/server'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">middleware</span>(<span class="hljs-params">request</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">NextResponse</span>.<span class="hljs-title function_">redirect</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'/new'</span>, request.<span class="hljs-property">url</span>))
}
</code></pre>
<p>위 코드는 현재 요청된 URL을 기준으로 <code>/new</code> 경로로 사용자를 넘겨주는 동작이에요.</p>
<p>여기서 더 한 걸음 나아가면, 기존 URL 정보도 활용해서 쿼리 파라미터를 붙이는 것도 가능하답니다!</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">NextResponse</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/server'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">middleware</span>(<span class="hljs-params">request</span>) {
  <span class="hljs-comment">// 현재 요청 URL을 기준으로 /login 페이지를 만든다</span>
  <span class="hljs-keyword">const</span> loginUrl = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'/login'</span>, request.<span class="hljs-property">url</span>)
  <span class="hljs-comment">// query parameter로 from=/현재경로 정보를 추가</span>
  loginUrl.<span class="hljs-property">searchParams</span>.<span class="hljs-title function_">set</span>(<span class="hljs-string">'from'</span>, request.<span class="hljs-property">nextUrl</span>.<span class="hljs-property">pathname</span>)
  <span class="hljs-comment">// 그리고 리다이렉트!</span>
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">NextResponse</span>.<span class="hljs-title function_">redirect</span>(loginUrl)
}
</code></pre>
<p>이렇게 하면 <code>/login?from=/현재경로</code> 형태의 URL로 보내서, 로그인 후 다시 원래 페이지로 돌아가게 하는 UX도 구현할 수 있죠.</p>
<hr>
<p>참고로, <code>request.nextUrl</code>은 Next.js가 제공하는 편리한 속성으로, 요청 URL의 구성요소를 쉽게 읽고 수정할 수 있게 도와줘요. 그냥 <code>request.url</code>은 문자열인데, <code>nextUrl</code>은 URL 객체라서 더 편합니다.</p>
<p>또한, 미들웨어 안에서 리다이렉션을 사용할 때는 항상 올바른 상대경로나 절대경로를 사용해야 하며, 프로토콜이나 도메인이 바뀌는 리다이렉트는 미들웨어 환경에 따라 제한될 수 있으니 주의해주세요.</p>
<p>이런 방식으로 Next.js 미들웨어에서 동적인 리다이렉션을 만들면, 로그인 이동, 권한 체크, 리다이렉션 로직 등을 유연하게 처리할 수 있어요. 직접 써보면 생각보다 간단하니 한번 도전해 보세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>rewrite() 함수 살펴보기</h2>
<p>Next.js에서 <code>rewrite()</code> 함수는 원래의 URL은 그대로 유지하면서, 서버 내에서 요청을 다른 경로로 내부 재요청(proxing)할 때 유용해요. 쉽게 말해, 브라우저 주소창에 주소가 그대로 보이는데, 실제로는 다른 URL에서 처리를 하고 싶을 때 사용하죠.</p>
<p>예를 들어, 아래처럼 코드를 작성했다고 가정해볼게요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">NextResponse</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/server'</span>

<span class="hljs-comment">// 사용자가 /about 경로로 요청하지만 내부적으로는 /proxy로 재작성</span>
<span class="hljs-keyword">return</span> <span class="hljs-title class_">NextResponse</span>.<span class="hljs-title function_">rewrite</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'/proxy'</span>, request.<span class="hljs-property">url</span>))
</code></pre>
<ul>
<li><strong>브라우저 주소창</strong>: <code>/about</code> 그대로 유지</li>
<li><strong>실제 서버 처리 경로</strong>: <code>/proxy</code></li>
</ul>
<p>이렇게 하면 URL 구조를 깔끔하게 유지하면서 내부적으로 다른 핸들러나 API 라우트에 요청을 넘길 수 있어요.</p>
<hr>
<h2>next()는 무엇인가요?</h2>
<p><code>next()</code>는 미들웨어 체인에서 현재 미들웨어를 종료하고 다음 미들웨어로 제어를 넘겨주는 함수입니다. 만약 경로를 바꿔주지 않고 단순히 현재 요청을 그대로 처리하고 싶다면 <code>NextResponse.next()</code>를 호출해요.</p>
<p>예를 들어,</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">NextResponse</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/server'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">middleware</span>(<span class="hljs-params">request</span>) {
  <span class="hljs-comment">// 특정 조건에서만 재작성하고, 그렇지 않으면 그냥 다음 미들웨어로</span>
  <span class="hljs-keyword">if</span> (request.<span class="hljs-property">nextUrl</span>.<span class="hljs-property">pathname</span>.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">'/proxy'</span>)) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">NextResponse</span>.<span class="hljs-title function_">rewrite</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">'/api/proxy'</span>, request.<span class="hljs-property">url</span>))
  }
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">NextResponse</span>.<span class="hljs-title function_">next</span>()
}
</code></pre>
<p>위 코드는 <code>/proxy</code>로 시작하는 요청은 <code>/api/proxy</code>로 내부 요청을 재작성하지만, 그 외의 경로는 그냥 원래 경로대로 처리하라는 의미입니다.</p>
<hr>
<h3>정리하자면</h3>




















<table><thead><tr><th>함수</th><th>역할</th><th>브라우저 주소창 반영 여부</th></tr></thead><tbody><tr><td><code>NextResponse.rewrite()</code></td><td>요청 경로를 서버 쪽에서 내부적으로 변경함</td><td>아니요 (원래 경로 유지)</td></tr><tr><td><code>NextResponse.next()</code></td><td>다음 미들웨어 또는 원래 처리 로직으로 제어 넘김</td><td>해당 없음 (경로 변경 없음)</td></tr></tbody></table>
<hr>
<p>이 기능 덕분에 깔끔한 URL 설계도 가능하고, 복잡한 리버스 프록시(proxy) 역할도 손쉽게 만들 수 있어요. 특히 API 라우트와 페이지 라우트를 효율적으로 분리할 때 여간 편리한 게 아니랍니다!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>next() 메서드는 미들웨어에서 특히 유용해요. 이 메서드를 이용하면 지금 처리하던 작업을 조기에 종료하고, 다음 라우팅 단계로 자연스럽게 넘어갈 수 있거든요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">NextResponse</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/server'</span>

<span class="hljs-keyword">return</span> <span class="hljs-title class_">NextResponse</span>.<span class="hljs-title function_">next</span>()
</code></pre>
<p>그리고 응답을 만들 때 헤더를 그대로 전달하거나, 새로운 헤더를 추가해서 넘길 수도 있어요. 예를 들어, 클라이언트 요청의 헤더를 받아서 수정하거나 필요한 정보를 추가하고 싶을 때 이렇게 하면 됩니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">NextResponse</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/server'</span>

<span class="hljs-comment">// 들어온 요청을 기준으로 기존 헤더를 복사</span>
<span class="hljs-keyword">const</span> newHeaders = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Headers</span>(request.<span class="hljs-property">headers</span>)

<span class="hljs-comment">// 새 헤더 추가</span>
newHeaders.<span class="hljs-title function_">set</span>(<span class="hljs-string">'x-version'</span>, <span class="hljs-string">'123'</span>)

<span class="hljs-comment">// 수정된 헤더를 포함한 다음 단계 응답 반환</span>
<span class="hljs-keyword">return</span> <span class="hljs-title class_">NextResponse</span>.<span class="hljs-title function_">next</span>({
  <span class="hljs-attr">request</span>: {
    <span class="hljs-attr">headers</span>: newHeaders,
  },
})
</code></pre>
<p>헤더를 이렇게 다룰 수 있으면, 인증 토큰이나 사용자 맞춤 정보 등 다양한 데이터를 미들웨어에서 편리하게 관리할 수 있어서 미들웨어 로직 작성이 훨씬 유연해져요!</p>
<p>혹시 next()만 쓰다가 특정 상황에서는 다른 Response 객체를 직접 반환해야 한다면, <code>NextResponse.rewrite()</code>나 <code>NextResponse.redirect()</code> 같은 메서드들도 함께 알아두면 좋습니다. 이렇게 다양한 Response 객체를 활용하면 미들웨어에서 요청 흐름을 자유롭게 제어할 수 있답니다!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Nextjs 15에서 응답 처리 쉽게 하는 방법(NextResponse)","description":"","date":"2025-04-22 12:42","slug":"2025-04-22-NextResponse","content":"\n\n# NextResponse\n\nNextResponse는 Web Response API를 확장한 것으로, 좀 더 편리하게 사용할 수 있는 메서드들이 추가된 Response 객체입니다. 기존의 Response 객체보다 훨씬 직관적이고 유용한 기능들을 제공해서, 특히 서버 사이드에서 많이 활용됩니다.\n\n## cookies\n\nNextResponse의 `cookies` 속성을 사용하면, 응답(Response)의 `Set-Cookie` 헤더를 읽거나 변경할 수 있어요. 즉, 클라이언트에게 보낼 쿠키를 쉽게 관리할 수 있다는 뜻이죠.\n\n예를 들어, 서버에서 쿠키를 추가하거나 수정할 때 직접 헤더를 조작하는 것보다 훨씬 깔끔하게 쓸 수 있습니다.\n\n```js\nimport { NextResponse } from 'next/server';\n\nexport function middleware(req) {\n  const res = NextResponse.next();\n\n  // 쿠키 읽기\n  const token = req.cookies.get('token');\n\n  // 쿠키 설정하기\n  res.cookies.set('loggedIn', 'true', { path: '/', httpOnly: true });\n\n  return res;\n}\n```\n\n이처럼 NextResponse의 `cookies` API를 쓰면 쿠키를 딱 한 줄로 읽고 쓸 수 있어서, 복잡한 헤더 조작 없이도 쉽게 작업할 수 있답니다.\n\n추가로, `cookies.set()` 메서드는 옵션으로 `httpOnly`, `secure`, `maxAge` 같은 여러 속성들을 받아서 보안이나 유효기간 설정도 간편해요.  \n또한, Next.js 13부터는 미들웨어나 API 라우트 등 서버 환경에서 이런 NextResponse API를 적극 활용해서 더 깔끔한 코드를 작성할 수 있으니, 꼭 한 번 써보시길 추천합니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### set(name, value)\n\n이 메서드는 이름(name)과 값(value)을 받아서 응답(response)에 쿠키를 설정해주는 역할을 해요.\n\n예를 들어, 사용자가 어떤 배너를 다시 보지 않도록 설정하고 싶을 때 이렇게 활용할 수 있죠.\n\n```js\n// /home 경로로 들어오는 요청이 있을 때\nlet response = NextResponse.next()\n// 'show-banner'라는 이름의 쿠키를 'false' 값으로 설정해서 배너 숨기기\nresponse.cookies.set('show-banner', 'false')\n// 이 응답에는 `Set-Cookie: show-banner=false; path=/home` 헤더가 포함되어 반환됩니다.\nreturn response\n```\n\n여기서 중요한 점은 `response.cookies.set()`을 사용하면 쿠키가 응답 헤더에 `Set-Cookie` 형태로 추가된다는 거예요. 그리고 경로(path) 옵션은 기본적으로 요청된 경로와 동일하게 설정되기 때문에, 원하는 경로로 지정하려면 옵션을 명시해 주어야 해요.\n\n```js\nresponse.cookies.set('user-preference', 'dark-mode', { path: '/' })\n```\n\n이렇게 하면 쿠키가 모든 경로에서 유효하게 설정됩니다.\n\n---\n\n### get(name)\n\n쿠키 값을 읽을 때는 `get(name)` 메서드를 사용해요. 예를 들어 사용자가 이전에 설정한 배너 표시 여부를 확인하고 싶을 때 사용할 수 있겠죠.\n\n```js\nconst showBanner = request.cookies.get('show-banner')\n```\n\n이렇게 하면 `showBanner` 변수에 쿠키의 값이 담겨 오고, 없으면 `undefined`가 반환됩니다.\n\n---\n\n### 참고로!\n\n- 쿠키는 클라이언트와 서버 사이에서 상태를 유지하는 간단한 방법이에요. 특히 사용자의 선호나 로그인 상태 같은 정보를 저장할 때 자주 사용되죠.\n- Next.js 13부터는 `NextResponse` 객체를 통해 쿠키를 쉽게 다룰 수 있어서 편리해요.\n- 보안 상 민감한 정보(예: 비밀번호, 토큰 등)는 절대 쿠키에 그냥 저장하면 안 되고 `HttpOnly`, `Secure` 옵션을 꼭 설정해야 해요.\n- 또한 쿠키 용량 제한과 만료일 설정도 신경 써야 하고요.\n\n필요하면 쿠키 설정에 `expires`, `maxAge`, `secure`, `httpOnly` 등의 옵션도 함께 활용해 보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n쿠키를 다룰 때 자주 쓰는 메서드인 `get()`과 `getAll()`에 대해 쉽게 설명해볼게요!\n\n---\n\n### `get()` 메서드\n\n- **기능:** 쿠키 이름을 주면, 그 쿠키의 **값(value)** 을 가져와 줘요.\n- **예외 상황:** \n  - 쿠키가 없다면 `undefined`를 반환해요.\n  - 만약 한 이름으로 여러 개의 쿠키가 있으면, 맨 처음 쿠키의 값을 반환합니다.\n\n예를 들어, `/home` 경로에서 들어오는 요청이 있다고 하고, \n\n```js\nlet response = NextResponse.next()\n// 쿠키 중 { name: 'show-banner', value: 'false', Path: '/home' } 가 있다고 가정하면,\nresponse.cookies.get('show-banner') // 'false' 반환\n```\n\n첫 번째 일치하는 쿠키 값을 리턴하니 정말 간편하죠?\n\n---\n\n### `getAll()` 메서드\n\n- **기능:** \n  - 쿠키 이름을 주면, 이름에 해당하는 모든 쿠키들을 배열로 받아요.\n  - 이름을 안 주면, **현재 응답(response)에 포함된 모든 쿠키**를 배열로 반환합니다.\n\n이걸 활용하면 같은 이름으로 중복된 쿠키를 한꺼번에 다룰 수도 있고,\n한번에 모든 쿠키를 살펴보기도 좋아요.\n\n---\n\n### 추가 꿀팁!\n\n- 쿠키는 같은 이름이라도 경로나 도메인 범위가 다를 수 있다는 점 기억하세요! 그래서 중복된 이름의 쿠키가 있을 수 있거든요.\n- `get()`는 첫 번째 쿠키만 가져오니까, 혹시 여러 개 있을 때 모두 확인하려면 `getAll()`을 쓰세요.\n- 클라이언트에서 쿠키를 조작할 때는 보안 설정(예: HttpOnly, Secure)도 꼭 챙기는 게 좋아요.\n\n꾸준히 쿠키를 잘 다루면 로그인, 알림 설정 등 중요한 기능들을 매끄럽게 만들 수 있답니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nnext.js에서 response.cookies 다룰 때, 쿠키를 삭제하는 방법에 대해 간단하게 알려줄게요.\n\n보통 쿠키를 삭제할 땐 set-cookie 헤더를 통해 만료된 상태로 만들어 보내잖아요? next.js 13부터는 NextResponse 객체가 쿠키 API를 제공해서, `response.cookies.delete('쿠키명')` 이렇게 한 줄로 쉽게 삭제가 가능해요.\n\n```js\n// /home 경로로 들어온 요청 처리 중\nlet response = NextResponse.next()\n// 'experiments'라는 이름의 쿠키가 있다면 삭제합니다.\nconst deleted = response.cookies.delete('experiments') \nconsole.log(deleted) // 쿠키를 삭제했으면 true, 없으면 false 반환\n```\n\n여기서 `delete` 메서드는 실제 쿠키가 있으면 삭제 처리 후 `true`를 반환하고, 없으면 `false`를 반환해서 잘 삭제되었는지 확인할 수 있어요. 그리고 삭제할 때는 해당 쿠키의 path(경로)도 맞춰줘야 삭제가 제대로 되는데, 기본 path가 맞으면 굳이 지정 안 해도 돼요.\n\n---\n\n추가로 알아두면 좋은 점!\n\n- `response.cookies.getAll()`로 response에 담긴 모든 쿠키를 배열로 쉽게 조회할 수 있어요.\n- 쿠키 이름이 같으면, 여러 개의 쿠키가 배열로 반환됩니다. (`[{name, value, Path}, ...]`)\n- 쿠키를 삭제할 때 특정 path나 domain도 설정해야 할 경우가 있으니, 필요하면 옵션도 같이 넘겨줄 수 있어요.\n\n---\n\n조금 더 쉽게 이해되도록 요약표를 만들었으니 참고하세요!\n\n| 메서드                  | 설명                           | 반환값                |\n|----------------------|------------------------------|-------------------|\n| `response.cookies.getAll('쿠키명')` | 특정 이름의 모든 쿠키 조회           | 쿠키 배열               |\n| `response.cookies.getAll()`        | 모든 쿠키 조회                    | 쿠키 배열               |\n| `response.cookies.delete('쿠키명')` | 쿠키 삭제                       | 삭제 성공 시: `true`, 실패 시: `false` |\n\n---\n\n사실 개발할 때 쿠키 관리가 깔끔해야 나중에 디버깅하기도 편한데, next.js의 `response.cookies` API가 이런 면에서 훨씬 편리하니 적극 활용해 보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## json() 함수 사용하기\n\nNext.js에서 API 응답을 JSON 형태로 쉽게 만들어주는 `NextResponse.json()` 함수에 대해 알아볼게요.\n\n```js\nimport { NextResponse } from 'next/server'\n \nexport async function GET(request: Request) {\n  return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 })\n}\n```\n\n위처럼 사용하면, 클라이언트에 `{ error: 'Internal Server Error' }`라는 JSON 데이터를 보내면서, HTTP 상태 코드를 500으로 설정할 수 있어요. 간단하죠?\n\n참고로, `NextResponse.json()`은 내부적으로 `Content-Type` 헤더를 `application/json`으로 설정하니까, 따로 헤더 신경 쓸 필요가 없답니다.\n\n---\n\n## redirect() 함수 소개\n\n`redirect()` 함수는 원하는 URL로 클라이언트를 리다이렉트할 때 사용해요. 서버에서 특정 조건이 충족되면 다른 페이지로 보내고 싶을 때 참 유용하죠.\n\n예를 들어, 다음처럼 쓸 수 있습니다:\n\n```js\nimport { NextResponse } from 'next/server'\n\nexport async function GET(request: Request) {\n  // 로그인하지 않은 사용자라면, 로그인 페이지로 리다이렉트\n  const isLoggedIn = false // 예시용 변수\n  if (!isLoggedIn) {\n    return NextResponse.redirect(new URL('/login', request.url))\n  }\n  \n  return NextResponse.json({ message: 'Welcome back!' })\n}\n```\n\n위 코드에서는 사용자가 로그인하지 않았다면 `/login` 경로로 리다이렉트시키고, 로그인되어 있으면 JSON 메시지를 보내줘요.\n\n---\n\n### 추가 팁: HTTP 상태 코드 지정하기\n\n`redirect()`는 기본적으로 307 Temporary Redirect 상태 코드를 사용하는데, 필요에 따라 다른 상태 코드를 지정할 수도 있습니다.\n\n```js\nreturn NextResponse.redirect(new URL('/login', request.url), 302)\n```\n\n여기서 `302`는 임시 리다이렉트를 의미해요. 상황에 맞게 301 (영구 리다이렉트) 같은 코드를 넣어도 됩니다.\n\n---\n\n### 정리하자면…\n\n| 기능          | 예시 코드                                      | 설명                                               |\n|---------------|------------------------------------------------|----------------------------------------------------|\n| JSON 응답     | `NextResponse.json({ key: 'value' }, { status: 200 })` | JSON 데이터와 상태 코드 함께 보내기                   |\n| 리다이렉트    | `NextResponse.redirect(new URL('/path', request.url), 302)` | 클라이언트를 다른 URL로 리다이렉트하기                  |\n\n이 두 함수만 잘 활용해도 Next.js API 라우트에서 훨씬 깔끔하고 명확한 응답 관리가 가능하니 꼭 익혀두세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 리다이렉션을 구현할 때는 `NextResponse.redirect()`를 사용하면 정말 편리해요. 간단히 말해, 원하는 URL로 사용자를 보내는 기능인데요, URL을 동적으로 만들거나 수정할 수도 있답니다.\n\n예를 들어, 기본적인 리다이렉트는 이렇게 할 수 있어요:\n\n```js\nimport { NextResponse } from 'next/server'\n\nexport function middleware(request) {\n  return NextResponse.redirect(new URL('/new', request.url))\n}\n```\n\n위 코드는 현재 요청된 URL을 기준으로 `/new` 경로로 사용자를 넘겨주는 동작이에요.\n\n여기서 더 한 걸음 나아가면, 기존 URL 정보도 활용해서 쿼리 파라미터를 붙이는 것도 가능하답니다! \n\n```js\nimport { NextResponse } from 'next/server'\n\nexport function middleware(request) {\n  // 현재 요청 URL을 기준으로 /login 페이지를 만든다\n  const loginUrl = new URL('/login', request.url)\n  // query parameter로 from=/현재경로 정보를 추가\n  loginUrl.searchParams.set('from', request.nextUrl.pathname)\n  // 그리고 리다이렉트!\n  return NextResponse.redirect(loginUrl)\n}\n```\n\n이렇게 하면 `/login?from=/현재경로` 형태의 URL로 보내서, 로그인 후 다시 원래 페이지로 돌아가게 하는 UX도 구현할 수 있죠.\n\n---\n\n참고로, `request.nextUrl`은 Next.js가 제공하는 편리한 속성으로, 요청 URL의 구성요소를 쉽게 읽고 수정할 수 있게 도와줘요. 그냥 `request.url`은 문자열인데, `nextUrl`은 URL 객체라서 더 편합니다.\n\n또한, 미들웨어 안에서 리다이렉션을 사용할 때는 항상 올바른 상대경로나 절대경로를 사용해야 하며, 프로토콜이나 도메인이 바뀌는 리다이렉트는 미들웨어 환경에 따라 제한될 수 있으니 주의해주세요.\n\n이런 방식으로 Next.js 미들웨어에서 동적인 리다이렉션을 만들면, 로그인 이동, 권한 체크, 리다이렉션 로직 등을 유연하게 처리할 수 있어요. 직접 써보면 생각보다 간단하니 한번 도전해 보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## rewrite() 함수 살펴보기\n\nNext.js에서 `rewrite()` 함수는 원래의 URL은 그대로 유지하면서, 서버 내에서 요청을 다른 경로로 내부 재요청(proxing)할 때 유용해요. 쉽게 말해, 브라우저 주소창에 주소가 그대로 보이는데, 실제로는 다른 URL에서 처리를 하고 싶을 때 사용하죠.\n\n예를 들어, 아래처럼 코드를 작성했다고 가정해볼게요.\n\n```js\nimport { NextResponse } from 'next/server'\n\n// 사용자가 /about 경로로 요청하지만 내부적으로는 /proxy로 재작성\nreturn NextResponse.rewrite(new URL('/proxy', request.url))\n```\n\n- **브라우저 주소창**: `/about` 그대로 유지\n- **실제 서버 처리 경로**: `/proxy`\n\n이렇게 하면 URL 구조를 깔끔하게 유지하면서 내부적으로 다른 핸들러나 API 라우트에 요청을 넘길 수 있어요.\n\n---\n\n## next()는 무엇인가요?\n\n`next()`는 미들웨어 체인에서 현재 미들웨어를 종료하고 다음 미들웨어로 제어를 넘겨주는 함수입니다. 만약 경로를 바꿔주지 않고 단순히 현재 요청을 그대로 처리하고 싶다면 `NextResponse.next()`를 호출해요.\n\n예를 들어,\n\n```js\nimport { NextResponse } from 'next/server'\n\nexport function middleware(request) {\n  // 특정 조건에서만 재작성하고, 그렇지 않으면 그냥 다음 미들웨어로\n  if (request.nextUrl.pathname.startsWith('/proxy')) {\n    return NextResponse.rewrite(new URL('/api/proxy', request.url))\n  }\n  return NextResponse.next()\n}\n```\n\n위 코드는 `/proxy`로 시작하는 요청은 `/api/proxy`로 내부 요청을 재작성하지만, 그 외의 경로는 그냥 원래 경로대로 처리하라는 의미입니다.\n\n---\n\n### 정리하자면\n| 함수            | 역할                                     | 브라우저 주소창 반영 여부       |\n| --------------- | ---------------------------------------- | ----------------------- |\n| `NextResponse.rewrite()` | 요청 경로를 서버 쪽에서 내부적으로 변경함       | 아니요 (원래 경로 유지)      |\n| `NextResponse.next()`    | 다음 미들웨어 또는 원래 처리 로직으로 제어 넘김  | 해당 없음 (경로 변경 없음)   |\n\n---\n\n이 기능 덕분에 깔끔한 URL 설계도 가능하고, 복잡한 리버스 프록시(proxy) 역할도 손쉽게 만들 수 있어요. 특히 API 라우트와 페이지 라우트를 효율적으로 분리할 때 여간 편리한 게 아니랍니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nnext() 메서드는 미들웨어에서 특히 유용해요. 이 메서드를 이용하면 지금 처리하던 작업을 조기에 종료하고, 다음 라우팅 단계로 자연스럽게 넘어갈 수 있거든요.\n\n```js\nimport { NextResponse } from 'next/server'\n\nreturn NextResponse.next()\n```\n\n그리고 응답을 만들 때 헤더를 그대로 전달하거나, 새로운 헤더를 추가해서 넘길 수도 있어요. 예를 들어, 클라이언트 요청의 헤더를 받아서 수정하거나 필요한 정보를 추가하고 싶을 때 이렇게 하면 됩니다:\n\n```js\nimport { NextResponse } from 'next/server'\n\n// 들어온 요청을 기준으로 기존 헤더를 복사\nconst newHeaders = new Headers(request.headers)\n\n// 새 헤더 추가\nnewHeaders.set('x-version', '123')\n\n// 수정된 헤더를 포함한 다음 단계 응답 반환\nreturn NextResponse.next({\n  request: {\n    headers: newHeaders,\n  },\n})\n```\n\n헤더를 이렇게 다룰 수 있으면, 인증 토큰이나 사용자 맞춤 정보 등 다양한 데이터를 미들웨어에서 편리하게 관리할 수 있어서 미들웨어 로직 작성이 훨씬 유연해져요!\n\n혹시 next()만 쓰다가 특정 상황에서는 다른 Response 객체를 직접 반환해야 한다면, `NextResponse.rewrite()`나 `NextResponse.redirect()` 같은 메서드들도 함께 알아두면 좋습니다. 이렇게 다양한 Response 객체를 활용하면 미들웨어에서 요청 흐름을 자유롭게 제어할 수 있답니다!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":12},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch1\u003eNextResponse\u003c/h1\u003e\n\u003cp\u003eNextResponse는 Web Response API를 확장한 것으로, 좀 더 편리하게 사용할 수 있는 메서드들이 추가된 Response 객체입니다. 기존의 Response 객체보다 훨씬 직관적이고 유용한 기능들을 제공해서, 특히 서버 사이드에서 많이 활용됩니다.\u003c/p\u003e\n\u003ch2\u003ecookies\u003c/h2\u003e\n\u003cp\u003eNextResponse의 \u003ccode\u003ecookies\u003c/code\u003e 속성을 사용하면, 응답(Response)의 \u003ccode\u003eSet-Cookie\u003c/code\u003e 헤더를 읽거나 변경할 수 있어요. 즉, 클라이언트에게 보낼 쿠키를 쉽게 관리할 수 있다는 뜻이죠.\u003c/p\u003e\n\u003cp\u003e예를 들어, 서버에서 쿠키를 추가하거나 수정할 때 직접 헤더를 조작하는 것보다 훨씬 깔끔하게 쓸 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eNextResponse\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/server'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emiddleware\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ereq\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e res = \u003cspan class=\"hljs-title class_\"\u003eNextResponse\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e();\n\n  \u003cspan class=\"hljs-comment\"\u003e// 쿠키 읽기\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e token = req.\u003cspan class=\"hljs-property\"\u003ecookies\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'token'\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-comment\"\u003e// 쿠키 설정하기\u003c/span\u003e\n  res.\u003cspan class=\"hljs-property\"\u003ecookies\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eset\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'loggedIn'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'true'\u003c/span\u003e, { \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ehttpOnly\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e });\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e res;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이처럼 NextResponse의 \u003ccode\u003ecookies\u003c/code\u003e API를 쓰면 쿠키를 딱 한 줄로 읽고 쓸 수 있어서, 복잡한 헤더 조작 없이도 쉽게 작업할 수 있답니다.\u003c/p\u003e\n\u003cp\u003e추가로, \u003ccode\u003ecookies.set()\u003c/code\u003e 메서드는 옵션으로 \u003ccode\u003ehttpOnly\u003c/code\u003e, \u003ccode\u003esecure\u003c/code\u003e, \u003ccode\u003emaxAge\u003c/code\u003e 같은 여러 속성들을 받아서 보안이나 유효기간 설정도 간편해요.\u003cbr\u003e\n또한, Next.js 13부터는 미들웨어나 API 라우트 등 서버 환경에서 이런 NextResponse API를 적극 활용해서 더 깔끔한 코드를 작성할 수 있으니, 꼭 한 번 써보시길 추천합니다!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch3\u003eset(name, value)\u003c/h3\u003e\n\u003cp\u003e이 메서드는 이름(name)과 값(value)을 받아서 응답(response)에 쿠키를 설정해주는 역할을 해요.\u003c/p\u003e\n\u003cp\u003e예를 들어, 사용자가 어떤 배너를 다시 보지 않도록 설정하고 싶을 때 이렇게 활용할 수 있죠.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// /home 경로로 들어오는 요청이 있을 때\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e response = \u003cspan class=\"hljs-title class_\"\u003eNextResponse\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e()\n\u003cspan class=\"hljs-comment\"\u003e// 'show-banner'라는 이름의 쿠키를 'false' 값으로 설정해서 배너 숨기기\u003c/span\u003e\nresponse.\u003cspan class=\"hljs-property\"\u003ecookies\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eset\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'show-banner'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'false'\u003c/span\u003e)\n\u003cspan class=\"hljs-comment\"\u003e// 이 응답에는 `Set-Cookie: show-banner=false; path=/home` 헤더가 포함되어 반환됩니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e response\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 중요한 점은 \u003ccode\u003eresponse.cookies.set()\u003c/code\u003e을 사용하면 쿠키가 응답 헤더에 \u003ccode\u003eSet-Cookie\u003c/code\u003e 형태로 추가된다는 거예요. 그리고 경로(path) 옵션은 기본적으로 요청된 경로와 동일하게 설정되기 때문에, 원하는 경로로 지정하려면 옵션을 명시해 주어야 해요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eresponse.\u003cspan class=\"hljs-property\"\u003ecookies\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eset\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'user-preference'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'dark-mode'\u003c/span\u003e, { \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/'\u003c/span\u003e })\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 하면 쿠키가 모든 경로에서 유효하게 설정됩니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003eget(name)\u003c/h3\u003e\n\u003cp\u003e쿠키 값을 읽을 때는 \u003ccode\u003eget(name)\u003c/code\u003e 메서드를 사용해요. 예를 들어 사용자가 이전에 설정한 배너 표시 여부를 확인하고 싶을 때 사용할 수 있겠죠.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e showBanner = request.\u003cspan class=\"hljs-property\"\u003ecookies\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'show-banner'\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 하면 \u003ccode\u003eshowBanner\u003c/code\u003e 변수에 쿠키의 값이 담겨 오고, 없으면 \u003ccode\u003eundefined\u003c/code\u003e가 반환됩니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e참고로!\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e쿠키는 클라이언트와 서버 사이에서 상태를 유지하는 간단한 방법이에요. 특히 사용자의 선호나 로그인 상태 같은 정보를 저장할 때 자주 사용되죠.\u003c/li\u003e\n\u003cli\u003eNext.js 13부터는 \u003ccode\u003eNextResponse\u003c/code\u003e 객체를 통해 쿠키를 쉽게 다룰 수 있어서 편리해요.\u003c/li\u003e\n\u003cli\u003e보안 상 민감한 정보(예: 비밀번호, 토큰 등)는 절대 쿠키에 그냥 저장하면 안 되고 \u003ccode\u003eHttpOnly\u003c/code\u003e, \u003ccode\u003eSecure\u003c/code\u003e 옵션을 꼭 설정해야 해요.\u003c/li\u003e\n\u003cli\u003e또한 쿠키 용량 제한과 만료일 설정도 신경 써야 하고요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e필요하면 쿠키 설정에 \u003ccode\u003eexpires\u003c/code\u003e, \u003ccode\u003emaxAge\u003c/code\u003e, \u003ccode\u003esecure\u003c/code\u003e, \u003ccode\u003ehttpOnly\u003c/code\u003e 등의 옵션도 함께 활용해 보세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e쿠키를 다룰 때 자주 쓰는 메서드인 \u003ccode\u003eget()\u003c/code\u003e과 \u003ccode\u003egetAll()\u003c/code\u003e에 대해 쉽게 설명해볼게요!\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e\u003ccode\u003eget()\u003c/code\u003e 메서드\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e기능:\u003c/strong\u003e 쿠키 이름을 주면, 그 쿠키의 \u003cstrong\u003e값(value)\u003c/strong\u003e 을 가져와 줘요.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e예외 상황:\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e쿠키가 없다면 \u003ccode\u003eundefined\u003c/code\u003e를 반환해요.\u003c/li\u003e\n\u003cli\u003e만약 한 이름으로 여러 개의 쿠키가 있으면, 맨 처음 쿠키의 값을 반환합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e예를 들어, \u003ccode\u003e/home\u003c/code\u003e 경로에서 들어오는 요청이 있다고 하고,\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e response = \u003cspan class=\"hljs-title class_\"\u003eNextResponse\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e()\n\u003cspan class=\"hljs-comment\"\u003e// 쿠키 중 { name: 'show-banner', value: 'false', Path: '/home' } 가 있다고 가정하면,\u003c/span\u003e\nresponse.\u003cspan class=\"hljs-property\"\u003ecookies\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'show-banner'\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e// 'false' 반환\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e첫 번째 일치하는 쿠키 값을 리턴하니 정말 간편하죠?\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e\u003ccode\u003egetAll()\u003c/code\u003e 메서드\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e기능:\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e쿠키 이름을 주면, 이름에 해당하는 모든 쿠키들을 배열로 받아요.\u003c/li\u003e\n\u003cli\u003e이름을 안 주면, \u003cstrong\u003e현재 응답(response)에 포함된 모든 쿠키\u003c/strong\u003e를 배열로 반환합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이걸 활용하면 같은 이름으로 중복된 쿠키를 한꺼번에 다룰 수도 있고,\n한번에 모든 쿠키를 살펴보기도 좋아요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e추가 꿀팁!\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e쿠키는 같은 이름이라도 경로나 도메인 범위가 다를 수 있다는 점 기억하세요! 그래서 중복된 이름의 쿠키가 있을 수 있거든요.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eget()\u003c/code\u003e는 첫 번째 쿠키만 가져오니까, 혹시 여러 개 있을 때 모두 확인하려면 \u003ccode\u003egetAll()\u003c/code\u003e을 쓰세요.\u003c/li\u003e\n\u003cli\u003e클라이언트에서 쿠키를 조작할 때는 보안 설정(예: HttpOnly, Secure)도 꼭 챙기는 게 좋아요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e꾸준히 쿠키를 잘 다루면 로그인, 알림 설정 등 중요한 기능들을 매끄럽게 만들 수 있답니다!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003enext.js에서 response.cookies 다룰 때, 쿠키를 삭제하는 방법에 대해 간단하게 알려줄게요.\u003c/p\u003e\n\u003cp\u003e보통 쿠키를 삭제할 땐 set-cookie 헤더를 통해 만료된 상태로 만들어 보내잖아요? next.js 13부터는 NextResponse 객체가 쿠키 API를 제공해서, \u003ccode\u003eresponse.cookies.delete('쿠키명')\u003c/code\u003e 이렇게 한 줄로 쉽게 삭제가 가능해요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// /home 경로로 들어온 요청 처리 중\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e response = \u003cspan class=\"hljs-title class_\"\u003eNextResponse\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e()\n\u003cspan class=\"hljs-comment\"\u003e// 'experiments'라는 이름의 쿠키가 있다면 삭제합니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e deleted = response.\u003cspan class=\"hljs-property\"\u003ecookies\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003edelete\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'experiments'\u003c/span\u003e) \n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(deleted) \u003cspan class=\"hljs-comment\"\u003e// 쿠키를 삭제했으면 true, 없으면 false 반환\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 \u003ccode\u003edelete\u003c/code\u003e 메서드는 실제 쿠키가 있으면 삭제 처리 후 \u003ccode\u003etrue\u003c/code\u003e를 반환하고, 없으면 \u003ccode\u003efalse\u003c/code\u003e를 반환해서 잘 삭제되었는지 확인할 수 있어요. 그리고 삭제할 때는 해당 쿠키의 path(경로)도 맞춰줘야 삭제가 제대로 되는데, 기본 path가 맞으면 굳이 지정 안 해도 돼요.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e추가로 알아두면 좋은 점!\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eresponse.cookies.getAll()\u003c/code\u003e로 response에 담긴 모든 쿠키를 배열로 쉽게 조회할 수 있어요.\u003c/li\u003e\n\u003cli\u003e쿠키 이름이 같으면, 여러 개의 쿠키가 배열로 반환됩니다. (\u003ccode\u003e[{name, value, Path}, ...]\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e쿠키를 삭제할 때 특정 path나 domain도 설정해야 할 경우가 있으니, 필요하면 옵션도 같이 넘겨줄 수 있어요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e조금 더 쉽게 이해되도록 요약표를 만들었으니 참고하세요!\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e메서드\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003cth\u003e반환값\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eresponse.cookies.getAll('쿠키명')\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e특정 이름의 모든 쿠키 조회\u003c/td\u003e\u003ctd\u003e쿠키 배열\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eresponse.cookies.getAll()\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e모든 쿠키 조회\u003c/td\u003e\u003ctd\u003e쿠키 배열\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eresponse.cookies.delete('쿠키명')\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e쿠키 삭제\u003c/td\u003e\u003ctd\u003e삭제 성공 시: \u003ccode\u003etrue\u003c/code\u003e, 실패 시: \u003ccode\u003efalse\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003chr\u003e\n\u003cp\u003e사실 개발할 때 쿠키 관리가 깔끔해야 나중에 디버깅하기도 편한데, next.js의 \u003ccode\u003eresponse.cookies\u003c/code\u003e API가 이런 면에서 훨씬 편리하니 적극 활용해 보세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003ejson() 함수 사용하기\u003c/h2\u003e\n\u003cp\u003eNext.js에서 API 응답을 JSON 형태로 쉽게 만들어주는 \u003ccode\u003eNextResponse.json()\u003c/code\u003e 함수에 대해 알아볼게요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eNextResponse\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/server'\u003c/span\u003e\n \n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eGET\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003erequest: Request\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNextResponse\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e({ \u003cspan class=\"hljs-attr\"\u003eerror\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'Internal Server Error'\u003c/span\u003e }, { \u003cspan class=\"hljs-attr\"\u003estatus\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e500\u003c/span\u003e })\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위처럼 사용하면, 클라이언트에 \u003ccode\u003e{ error: 'Internal Server Error' }\u003c/code\u003e라는 JSON 데이터를 보내면서, HTTP 상태 코드를 500으로 설정할 수 있어요. 간단하죠?\u003c/p\u003e\n\u003cp\u003e참고로, \u003ccode\u003eNextResponse.json()\u003c/code\u003e은 내부적으로 \u003ccode\u003eContent-Type\u003c/code\u003e 헤더를 \u003ccode\u003eapplication/json\u003c/code\u003e으로 설정하니까, 따로 헤더 신경 쓸 필요가 없답니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003eredirect() 함수 소개\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eredirect()\u003c/code\u003e 함수는 원하는 URL로 클라이언트를 리다이렉트할 때 사용해요. 서버에서 특정 조건이 충족되면 다른 페이지로 보내고 싶을 때 참 유용하죠.\u003c/p\u003e\n\u003cp\u003e예를 들어, 다음처럼 쓸 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eNextResponse\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/server'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eGET\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003erequest: Request\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 로그인하지 않은 사용자라면, 로그인 페이지로 리다이렉트\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e isLoggedIn = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e// 예시용 변수\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!isLoggedIn) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNextResponse\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eredirect\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eURL\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/login'\u003c/span\u003e, request.\u003cspan class=\"hljs-property\"\u003eurl\u003c/span\u003e))\n  }\n  \n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNextResponse\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e({ \u003cspan class=\"hljs-attr\"\u003emessage\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'Welcome back!'\u003c/span\u003e })\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드에서는 사용자가 로그인하지 않았다면 \u003ccode\u003e/login\u003c/code\u003e 경로로 리다이렉트시키고, 로그인되어 있으면 JSON 메시지를 보내줘요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e추가 팁: HTTP 상태 코드 지정하기\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eredirect()\u003c/code\u003e는 기본적으로 307 Temporary Redirect 상태 코드를 사용하는데, 필요에 따라 다른 상태 코드를 지정할 수도 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNextResponse\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eredirect\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eURL\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/login'\u003c/span\u003e, request.\u003cspan class=\"hljs-property\"\u003eurl\u003c/span\u003e), \u003cspan class=\"hljs-number\"\u003e302\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 \u003ccode\u003e302\u003c/code\u003e는 임시 리다이렉트를 의미해요. 상황에 맞게 301 (영구 리다이렉트) 같은 코드를 넣어도 됩니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e정리하자면…\u003c/h3\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e기능\u003c/th\u003e\u003cth\u003e예시 코드\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003eJSON 응답\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eNextResponse.json({ key: 'value' }, { status: 200 })\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eJSON 데이터와 상태 코드 함께 보내기\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e리다이렉트\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eNextResponse.redirect(new URL('/path', request.url), 302)\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e클라이언트를 다른 URL로 리다이렉트하기\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e이 두 함수만 잘 활용해도 Next.js API 라우트에서 훨씬 깔끔하고 명확한 응답 관리가 가능하니 꼭 익혀두세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eNext.js에서 리다이렉션을 구현할 때는 \u003ccode\u003eNextResponse.redirect()\u003c/code\u003e를 사용하면 정말 편리해요. 간단히 말해, 원하는 URL로 사용자를 보내는 기능인데요, URL을 동적으로 만들거나 수정할 수도 있답니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, 기본적인 리다이렉트는 이렇게 할 수 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eNextResponse\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/server'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emiddleware\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003erequest\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNextResponse\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eredirect\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eURL\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/new'\u003c/span\u003e, request.\u003cspan class=\"hljs-property\"\u003eurl\u003c/span\u003e))\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드는 현재 요청된 URL을 기준으로 \u003ccode\u003e/new\u003c/code\u003e 경로로 사용자를 넘겨주는 동작이에요.\u003c/p\u003e\n\u003cp\u003e여기서 더 한 걸음 나아가면, 기존 URL 정보도 활용해서 쿼리 파라미터를 붙이는 것도 가능하답니다!\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eNextResponse\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/server'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emiddleware\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003erequest\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 현재 요청 URL을 기준으로 /login 페이지를 만든다\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e loginUrl = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eURL\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/login'\u003c/span\u003e, request.\u003cspan class=\"hljs-property\"\u003eurl\u003c/span\u003e)\n  \u003cspan class=\"hljs-comment\"\u003e// query parameter로 from=/현재경로 정보를 추가\u003c/span\u003e\n  loginUrl.\u003cspan class=\"hljs-property\"\u003esearchParams\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eset\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'from'\u003c/span\u003e, request.\u003cspan class=\"hljs-property\"\u003enextUrl\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003epathname\u003c/span\u003e)\n  \u003cspan class=\"hljs-comment\"\u003e// 그리고 리다이렉트!\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNextResponse\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eredirect\u003c/span\u003e(loginUrl)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 하면 \u003ccode\u003e/login?from=/현재경로\u003c/code\u003e 형태의 URL로 보내서, 로그인 후 다시 원래 페이지로 돌아가게 하는 UX도 구현할 수 있죠.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e참고로, \u003ccode\u003erequest.nextUrl\u003c/code\u003e은 Next.js가 제공하는 편리한 속성으로, 요청 URL의 구성요소를 쉽게 읽고 수정할 수 있게 도와줘요. 그냥 \u003ccode\u003erequest.url\u003c/code\u003e은 문자열인데, \u003ccode\u003enextUrl\u003c/code\u003e은 URL 객체라서 더 편합니다.\u003c/p\u003e\n\u003cp\u003e또한, 미들웨어 안에서 리다이렉션을 사용할 때는 항상 올바른 상대경로나 절대경로를 사용해야 하며, 프로토콜이나 도메인이 바뀌는 리다이렉트는 미들웨어 환경에 따라 제한될 수 있으니 주의해주세요.\u003c/p\u003e\n\u003cp\u003e이런 방식으로 Next.js 미들웨어에서 동적인 리다이렉션을 만들면, 로그인 이동, 권한 체크, 리다이렉션 로직 등을 유연하게 처리할 수 있어요. 직접 써보면 생각보다 간단하니 한번 도전해 보세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003erewrite() 함수 살펴보기\u003c/h2\u003e\n\u003cp\u003eNext.js에서 \u003ccode\u003erewrite()\u003c/code\u003e 함수는 원래의 URL은 그대로 유지하면서, 서버 내에서 요청을 다른 경로로 내부 재요청(proxing)할 때 유용해요. 쉽게 말해, 브라우저 주소창에 주소가 그대로 보이는데, 실제로는 다른 URL에서 처리를 하고 싶을 때 사용하죠.\u003c/p\u003e\n\u003cp\u003e예를 들어, 아래처럼 코드를 작성했다고 가정해볼게요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eNextResponse\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/server'\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 사용자가 /about 경로로 요청하지만 내부적으로는 /proxy로 재작성\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNextResponse\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erewrite\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eURL\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/proxy'\u003c/span\u003e, request.\u003cspan class=\"hljs-property\"\u003eurl\u003c/span\u003e))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e브라우저 주소창\u003c/strong\u003e: \u003ccode\u003e/about\u003c/code\u003e 그대로 유지\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e실제 서버 처리 경로\u003c/strong\u003e: \u003ccode\u003e/proxy\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이렇게 하면 URL 구조를 깔끔하게 유지하면서 내부적으로 다른 핸들러나 API 라우트에 요청을 넘길 수 있어요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003enext()는 무엇인가요?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003enext()\u003c/code\u003e는 미들웨어 체인에서 현재 미들웨어를 종료하고 다음 미들웨어로 제어를 넘겨주는 함수입니다. 만약 경로를 바꿔주지 않고 단순히 현재 요청을 그대로 처리하고 싶다면 \u003ccode\u003eNextResponse.next()\u003c/code\u003e를 호출해요.\u003c/p\u003e\n\u003cp\u003e예를 들어,\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eNextResponse\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/server'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emiddleware\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003erequest\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 특정 조건에서만 재작성하고, 그렇지 않으면 그냥 다음 미들웨어로\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (request.\u003cspan class=\"hljs-property\"\u003enextUrl\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003epathname\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003estartsWith\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/proxy'\u003c/span\u003e)) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNextResponse\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erewrite\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eURL\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/api/proxy'\u003c/span\u003e, request.\u003cspan class=\"hljs-property\"\u003eurl\u003c/span\u003e))\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNextResponse\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e()\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드는 \u003ccode\u003e/proxy\u003c/code\u003e로 시작하는 요청은 \u003ccode\u003e/api/proxy\u003c/code\u003e로 내부 요청을 재작성하지만, 그 외의 경로는 그냥 원래 경로대로 처리하라는 의미입니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e정리하자면\u003c/h3\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e함수\u003c/th\u003e\u003cth\u003e역할\u003c/th\u003e\u003cth\u003e브라우저 주소창 반영 여부\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eNextResponse.rewrite()\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e요청 경로를 서버 쪽에서 내부적으로 변경함\u003c/td\u003e\u003ctd\u003e아니요 (원래 경로 유지)\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eNextResponse.next()\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e다음 미들웨어 또는 원래 처리 로직으로 제어 넘김\u003c/td\u003e\u003ctd\u003e해당 없음 (경로 변경 없음)\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003chr\u003e\n\u003cp\u003e이 기능 덕분에 깔끔한 URL 설계도 가능하고, 복잡한 리버스 프록시(proxy) 역할도 손쉽게 만들 수 있어요. 특히 API 라우트와 페이지 라우트를 효율적으로 분리할 때 여간 편리한 게 아니랍니다!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003enext() 메서드는 미들웨어에서 특히 유용해요. 이 메서드를 이용하면 지금 처리하던 작업을 조기에 종료하고, 다음 라우팅 단계로 자연스럽게 넘어갈 수 있거든요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eNextResponse\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/server'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNextResponse\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 응답을 만들 때 헤더를 그대로 전달하거나, 새로운 헤더를 추가해서 넘길 수도 있어요. 예를 들어, 클라이언트 요청의 헤더를 받아서 수정하거나 필요한 정보를 추가하고 싶을 때 이렇게 하면 됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eNextResponse\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/server'\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 들어온 요청을 기준으로 기존 헤더를 복사\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e newHeaders = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHeaders\u003c/span\u003e(request.\u003cspan class=\"hljs-property\"\u003eheaders\u003c/span\u003e)\n\n\u003cspan class=\"hljs-comment\"\u003e// 새 헤더 추가\u003c/span\u003e\nnewHeaders.\u003cspan class=\"hljs-title function_\"\u003eset\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'x-version'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'123'\u003c/span\u003e)\n\n\u003cspan class=\"hljs-comment\"\u003e// 수정된 헤더를 포함한 다음 단계 응답 반환\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNextResponse\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003erequest\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003eheaders\u003c/span\u003e: newHeaders,\n  },\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e헤더를 이렇게 다룰 수 있으면, 인증 토큰이나 사용자 맞춤 정보 등 다양한 데이터를 미들웨어에서 편리하게 관리할 수 있어서 미들웨어 로직 작성이 훨씬 유연해져요!\u003c/p\u003e\n\u003cp\u003e혹시 next()만 쓰다가 특정 상황에서는 다른 Response 객체를 직접 반환해야 한다면, \u003ccode\u003eNextResponse.rewrite()\u003c/code\u003e나 \u003ccode\u003eNextResponse.redirect()\u003c/code\u003e 같은 메서드들도 함께 알아두면 좋습니다. 이렇게 다양한 Response 객체를 활용하면 미들웨어에서 요청 흐름을 자유롭게 제어할 수 있답니다!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2025-04-22-NextResponse"},"buildId":"X4OrKfmLtU3-3BijwfHe6","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>