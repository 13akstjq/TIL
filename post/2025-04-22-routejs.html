<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Next.js 15에서 route.js 파일 설정하는 방법 | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-routejs" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Next.js 15에서 route.js 파일 설정하는 방법 | TIL" data-gatsby-head="true"/><meta property="og:title" content="Next.js 15에서 route.js 파일 설정하는 방법 | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-routejs" data-gatsby-head="true"/><meta name="twitter:title" content="Next.js 15에서 route.js 파일 설정하는 방법 | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2025-04-22 02:44" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/post/%5Bslug%5D-8ded8b979ba73586.js" defer=""></script><script src="/TIL/_next/static/X4OrKfmLtU3-3BijwfHe6/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/X4OrKfmLtU3-3BijwfHe6/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Next.js 15에서 route.js 파일 설정하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Next.js 15에서 route.js 파일 설정하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Apr 22, 2025</span><span class="posts_reading_time__f7YPP">8<!-- --> min read</span></span></div></div></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h1>route.js</h1>
<p>Route Handlers는 특정 경로(route)에 대해 커스텀 요청 처리기를 만들 수 있게 해주는 기능이에요. 즉, 내가 원하는 경로에 맞춰서 요청(Request)과 응답(Response)을 직접 다룰 수 있게 해주죠. 이때 Web Request와 Response API를 활용해요.</p>
<p>예를 들어, 아래처럼 GET 요청을 받았을 때 JSON 형태로 간단한 메시지를 응답하는 코드를 작성할 수 있어요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">GET</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Response</span>.<span class="hljs-title function_">json</span>({ <span class="hljs-attr">message</span>: <span class="hljs-string">'Hello World'</span> });
}
</code></pre>
<p>이 코드는 "/route" 같은 경로로 GET 요청이 들어오면 <code>{ message: 'Hello World' }</code>라는 JSON 데이터를 클라이언트에게 보내주는 역할을 해요.</p>
<p>추가로 알아두면 좋은 점 몇 가지 알려드릴게요!</p>
<ul>
<li><strong>Method별 함수 지원</strong>: GET뿐 아니라 POST, PUT, DELETE 등 HTTP 메서드에 맞춰서 함수들을 만들 수 있어요.</li>
<li><strong>내장 Response 객체 활용</strong>: 위 예시처럼 <code>Response.json()</code> 메서드는 JSON 응답을 쉽게 만들어 주기 때문에 정말 편리해요.</li>
<li><strong>비동기 처리 가능</strong>: 데이터베이스 조회나 외부 API 호출처럼 비동기가 필요한 작업도 <code>async/await</code> 패턴으로 자연스럽게 처리할 수 있어요.</li>
<li><strong>라우팅과 별개로 작동</strong>: Next.js 같은 프레임워크에서는 보통 페이지 라우팅과 별개로 API 응답을 여기서 따로 관리할 수 있답니다!</li>
</ul>
<p>만약 좀 더 복잡한 요청 처리(예: 요청 본문 읽기, 헤더 조작 등)를 하고 싶다면, Request 객체를 받아 쓰면 됩니다. 예를 들어:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">POST</span>(<span class="hljs-params">request</span>) {
  <span class="hljs-keyword">const</span> body = <span class="hljs-keyword">await</span> request.<span class="hljs-title function_">json</span>();
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Response</span>.<span class="hljs-title function_">json</span>({ <span class="hljs-attr">youSent</span>: body });
}
</code></pre>
<p>이렇게 하면 클라이언트가 보낸 데이터를 받아서 다시 돌려주는 간단한 POST 처리도 가능해요.</p>
<hr>
<h2>참고 자료</h2>
<ul>
<li>공식 MDN 문서 - <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request" rel="nofollow" target="_blank">Web Request and Response APIs</a></li>
<li>Next.js API Routes 공식 문서 (비슷한 개념으로 활용 가능)</li>
<li>Response 객체 관련 문서: JSON 응답 생성 등 다양한 메서드 지원</li>
</ul>
<hr>
<p>간단하지만 강력한 route.js의 Route Handlers, 여러분의 서버 로직 구현에 꼭 활용해보세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h3>HTTP 메서드</h3>
<p>라우트 파일에서는 특정 경로(route)에 대해 커스텀 요청 핸들러를 만들 수 있어요. 즉, 클라이언트가 어떤 요청을 했는지에 따라 다르게 동작하도록 코드를 작성할 수 있다는 뜻이죠. 여기서 지원하는 HTTP 메서드는 GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS 이렇게 총 7가지에요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">GET</span>(<span class="hljs-params">request: Request</span>) {}
 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">HEAD</span>(<span class="hljs-params">request: Request</span>) {}
 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">POST</span>(<span class="hljs-params">request: Request</span>) {}
 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">PUT</span>(<span class="hljs-params">request: Request</span>) {}
 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">DELETE</span>(<span class="hljs-params">request: Request</span>) {}
 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">PATCH</span>(<span class="hljs-params">request: Request</span>) {}
 
<span class="hljs-comment">// 만약 `OPTIONS` 메서드를 직접 정의하지 않으면,</span>
<span class="hljs-comment">// Next.js가 자동으로 `OPTIONS` 메서드를 구현해주고,</span>
<span class="hljs-comment">// Route Handler에 정의된 다른 메서드들을 기준으로 `Allow` 헤더를 설정해줍니다.</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">OPTIONS</span>(<span class="hljs-params">request: Request</span>) {}
</code></pre>
<p>각 함수는 <code>Request</code> 객체를 받아서 비동기적으로 처리할 수 있는 함수예요. <code>Request</code> 객체를 통해 요청과 관련된 다양한 정보를 얻을 수 있답니다.</p>
<h4>간단히 정리한 HTTP 메서드 역할</h4>





































<table><thead><tr><th>메서드</th><th>설명</th></tr></thead><tbody><tr><td>GET</td><td>서버에서 데이터를 읽어올 때 사용해요. 가장 기본적인 요청이죠.</td></tr><tr><td>POST</td><td>서버에 데이터를 새로 생성할 때 쓰여요. 예를 들어 회원가입 같은 요청이죠.</td></tr><tr><td>PUT</td><td>데이터를 통째로 수정할 때 사용해요. 기존 데이터를 전부 교체할 때 유용합니다.</td></tr><tr><td>PATCH</td><td>데이터의 일부만 수정할 때 사용해요. 수정할 부분만 보내면 되어서 효율적이죠.</td></tr><tr><td>DELETE</td><td>서버에서 데이터를 삭제할 때 쓰여요.</td></tr><tr><td>HEAD</td><td>GET 요청과 비슷하지만 응답 본문(body)은 안 내려줘서 응답 헤더만 받고 싶을 때 유용해요.</td></tr><tr><td>OPTIONS</td><td>클라이언트가 해당 경로에서 어떤 메서드를 사용할 수 있는지 미리 물어볼 때 사용합니다.</td></tr></tbody></table>
<blockquote>
<p><strong>팁!</strong> 실제 API 설계할 때는 각 메서드가 어떤 동작을 하는지 명확하게 구분해서 사용하는 게 좋아요. 그래야 클라이언트가 어떤 요청을 보내야 할지 헷갈리지 않고, 유지보수도 훨씬 쉬워집니다.</p>
</blockquote>
<p>다음에는 <code>Parameters</code>(매개변수) 부분에 대해 자세히 알아볼게요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h3>Next.js에서 NextRequest 활용하기 (feat. request 객체 이해하기)</h3>
<p>Next.js에서 API 라우트나 미들웨어를 만들 때, <code>request</code> 객체를 자주 다루게 되죠. 그런데 그냥 기본 Web Request API와는 조금 다른, Next.js만의 확장판인 <code>NextRequest</code>라는 객체가 있다고 해요.</p>
<h4>NextRequest란?</h4>
<p><code>NextRequest</code>는 기본 Web Request 객체를 상속해서, 더 쉽고 편하게 쓸 수 있게 만든 Next.js 전용 객체입니다. 예를 들어, 쿠키를 꺼내거나, URL 정보를 다룰 때 훨씬 직관적이고 편리해요. <code>nextUrl</code>이라는 확장된 URL 객체가 포함되어 있어서, 이걸 활용하면 URL 조작도 손쉽답니다.</p>
<h4>간단한 예제</h4>
<pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> { <span class="hljs-title class_">NextRequest</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/server'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">GET</span>(<span class="hljs-params">request: NextRequest</span>) {
  <span class="hljs-comment">// nextUrl을 통해 URL을 쉽게 접근 가능</span>
  <span class="hljs-keyword">const</span> url = request.<span class="hljs-property">nextUrl</span>

  <span class="hljs-comment">// 예: 쿼리 파라미터 출력해보기</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(url.<span class="hljs-property">searchParams</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">'id'</span>))

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(<span class="hljs-string">'Hello World'</span>)
}
</code></pre>
<p>위 코드에서 <code>request.nextUrl</code>을 이용하면 URL 전체를 분석할 수 있고, <code>searchParams</code>로 쿼리도 쉽게 읽을 수 있어요. 만약 그냥 <code>request.url</code>을 쓰면 문자열 형태라, 직접 파싱을 해야 하니까 귀찮죠.</p>
<h4>NextRequest만의 꿀팁!</h4>
<ul>
<li><strong>쿠키 꺼내기</strong>: <code>request.cookies.get('cookieName')</code>으로 바로 쿠키 값 꺼낼 수 있어요.</li>
<li><strong>헤더 접근</strong>: <code>request.headers.get('headerName')</code> 작성법은 동일하지만, 실제로 다루기 더 깔끔해요.</li>
<li><strong>POST Body 읽기</strong>: 비동기로 <code>request.json()</code> 같은 메서드를 사용해 JSON 본문을 바로 파싱할 수 있습니다.</li>
</ul>
<h4>마무리</h4>
<p>Next.js 13부터 등장한 이 <code>NextRequest</code> 객체는 서버 컴포넌트나 API 라우트, 미들웨어를 작성할 때 훨씬 편리하고 강력한 도구입니다. 기존의 Web Request 객체보다 기능이 많고, 특히 URL이나 쿠키 처리에 도움을 주니 꼭 활용해 보세요!</p>
<p>궁금하면 Next.js 공식 문서에서 <a href="https://nextjs.org/docs/api-reference/edge-runtime#nextrequest" rel="nofollow" target="_blank"><code>NextRequest</code></a>도 참고해보시면 좋습니다.</p>
<hr>
<p>필요하다면 다음에는 <code>NextResponse</code> 활용법도 소개할게요. 이걸로 응답을 쉽게 제어할 수 있답니다!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>아래는 Next.js의 동적 라우트에서 <code>params</code>가 어떻게 사용되는지 보여주는 코드 예제입니다. 이 때 <code>params</code>는 현재 라우트의 동적 경로 파라미터들을 담은 객체를 비동기적으로 반환하는 Promise입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">GET</span>(<span class="hljs-params">
  request: Request,
  { params }: { params: <span class="hljs-built_in">Promise</span>&#x3C;{ team: string }> }
</span>) {
  <span class="hljs-keyword">const</span> { team } = <span class="hljs-keyword">await</span> params
  <span class="hljs-comment">// 이제 team 변수에 URL에서 전달된 동적 경로 파라미터가 들어있어요.</span>
}
</code></pre>
<p>예를 들어, 다음과 같은 라우트 구조와 URL 요청이 있을 때 <code>params</code>는 이렇게 들어옵니다:</p>

























<table><thead><tr><th>Example</th><th>URL</th><th>params</th></tr></thead><tbody><tr><td><code>app/dashboard/[team]/route.js</code></td><td><code>/dashboard/1</code></td><td><code>Promise&#x3C;{ team: '1' }></code></td></tr><tr><td><code>app/shop/[tag]/[item]/route.js</code></td><td><code>/shop/1/2</code></td><td><code>Promise&#x3C;{ tag: '1', item: '2' }></code></td></tr><tr><td><code>app/blog/[...slug]/route.js</code></td><td><code>/blog/1/2</code></td><td><code>Promise&#x3C;{ slug: ['1', '2'] }></code></td></tr></tbody></table>
<p>여기서 <code>[team]</code>, <code>[tag]</code>, <code>[item]</code> 같은 부분이 동적 경로 파라미터를 나타내고, <code>[...,slug]</code>는 여러 경로 세그먼트를 배열 형태로 받을 때 사용합니다.</p>
<h3>덧붙여서</h3>
<ul>
<li><code>params</code>가 Promise인 이유는 Next.js가 라우트의 데이터 패칭 시점에 비동기 처리를 하기 때문이에요. 그래서 항상 <code>await</code>을 사용해 값을 꺼내주어야 해요.</li>
<li>동적 라우트를 사용할 땐, <code>params</code>에서 기대하는 속성명이 URL 안 동적 경로 이름과 정확히 일치하는지 꼭 확인해야 합니다.</li>
<li>여러 개의 동적 파라미터가 있다면, 그 만큼 프로퍼티를 비동기로 받아서 처리할 수 있어요.</li>
<li>다중 세그먼트 캡쳐(<code>[...slug]</code>)는 블로그 포스트나 검색 결과처럼 URL 계층이 다양하게 바뀌는 경우에 유용합니다.</li>
</ul>
<p>이런 기본 개념만 잘 이해하면 Next.js의 동적 라우트는 크게 어렵지 않으니, 직접 여러가지 라우트를 만들어보면서 경험을 쌓아보세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h3>쿠키 다루기</h3>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { cookies } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/headers'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">GET</span>(<span class="hljs-params">request: NextRequest</span>) {
  <span class="hljs-keyword">const</span> cookieStore = <span class="hljs-keyword">await</span> <span class="hljs-title function_">cookies</span>()

  <span class="hljs-keyword">const</span> a = cookieStore.<span class="hljs-title function_">get</span>(<span class="hljs-string">'a'</span>)       <span class="hljs-comment">// 쿠키 'a' 값을 가져오기</span>
  <span class="hljs-keyword">const</span> b = cookieStore.<span class="hljs-title function_">set</span>(<span class="hljs-string">'b'</span>, <span class="hljs-string">'1'</span>)  <span class="hljs-comment">// 쿠키 'b'를 '1'로 설정하기</span>
  <span class="hljs-keyword">const</span> c = cookieStore.<span class="hljs-title function_">delete</span>(<span class="hljs-string">'c'</span>)    <span class="hljs-comment">// 쿠키 'c' 삭제하기</span>
}
</code></pre>
<p>Next.js의 <code>cookies()</code> 함수로 쉽게 쿠키를 가져오고 설정하고 삭제할 수 있어요. 여기서 중요한 건 <code>cookies()</code>가 비동기 함수라는 점인데, 그래서 <code>await</code>를 붙여줘야 제대로 값을 받을 수 있답니다.</p>
<p><code>cookieStore.get()</code>은 해당 이름의 쿠키 정보를 객체 형태로 줘요. 없으면 <code>undefined</code>를 반환하고요. <code>cookieStore.set()</code>은 새로운 쿠키를 추가하거나 기존 쿠키를 덮어씁니다. <code>cookieStore.delete()</code>는 지정한 쿠키를 삭제할 때 씁니다.</p>
<p>클라이언트와 서버 모두 쿠키를 다루지만, Next.js API Route 혹은 Route Handler에서는 이렇게 <code>next/headers</code>에서 제공하는 함수를 활용하면 훨씬 간단해져서 좋아요!</p>
<hr>
<h2>버전 히스토리</h2>





















<table><thead><tr><th>Version</th><th>Changes</th></tr></thead><tbody><tr><td><code>v15.0.0-RC</code></td><td><code>context.params</code>가 이제 프로미스 형태로 바뀌었어요. <a href="https://nextjs.org/docs/app/guides/upgrading/codemods#150" rel="nofollow" target="_blank">codemod</a> 도 제공됩니다.</td></tr><tr><td><code>v15.0.0-RC</code></td><td><code>GET</code> 핸들러의 기본 캐싱 정책이 static에서 dynamic으로 변경됐습니다.</td></tr><tr><td><code>v13.2.0</code></td><td>Route Handlers가 처음 소개되었습니다.</td></tr></tbody></table>
<p>Next.js는 계속 발전 중이라 버전마다 큰 변화가 있는데, 특히 Route Handler와 쿠키, 캐시 다루는 방식도 바뀌니 공식 문서를 챙겨보시는 걸 추천해요! 혹시 기존 코드를 15버전 이상으로 올리려면 codemod를 꼭 활용해보세요. 작업할 때 시간 많이 절약됩니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Next.js 15에서 route.js 파일 설정하는 방법","description":"","date":"2025-04-22 02:44","slug":"2025-04-22-routejs","content":"\n\n# route.js\n\nRoute Handlers는 특정 경로(route)에 대해 커스텀 요청 처리기를 만들 수 있게 해주는 기능이에요. 즉, 내가 원하는 경로에 맞춰서 요청(Request)과 응답(Response)을 직접 다룰 수 있게 해주죠. 이때 Web Request와 Response API를 활용해요.\n\n예를 들어, 아래처럼 GET 요청을 받았을 때 JSON 형태로 간단한 메시지를 응답하는 코드를 작성할 수 있어요:\n\n```js\nexport async function GET() {\n  return Response.json({ message: 'Hello World' });\n}\n```\n\n이 코드는 \"/route\" 같은 경로로 GET 요청이 들어오면 `{ message: 'Hello World' }`라는 JSON 데이터를 클라이언트에게 보내주는 역할을 해요. \n\n추가로 알아두면 좋은 점 몇 가지 알려드릴게요!\n\n- **Method별 함수 지원**: GET뿐 아니라 POST, PUT, DELETE 등 HTTP 메서드에 맞춰서 함수들을 만들 수 있어요.  \n- **내장 Response 객체 활용**: 위 예시처럼 `Response.json()` 메서드는 JSON 응답을 쉽게 만들어 주기 때문에 정말 편리해요.\n- **비동기 처리 가능**: 데이터베이스 조회나 외부 API 호출처럼 비동기가 필요한 작업도 `async/await` 패턴으로 자연스럽게 처리할 수 있어요.\n- **라우팅과 별개로 작동**: Next.js 같은 프레임워크에서는 보통 페이지 라우팅과 별개로 API 응답을 여기서 따로 관리할 수 있답니다!\n\n만약 좀 더 복잡한 요청 처리(예: 요청 본문 읽기, 헤더 조작 등)를 하고 싶다면, Request 객체를 받아 쓰면 됩니다. 예를 들어:\n\n```js\nexport async function POST(request) {\n  const body = await request.json();\n  return Response.json({ youSent: body });\n}\n```\n\n이렇게 하면 클라이언트가 보낸 데이터를 받아서 다시 돌려주는 간단한 POST 처리도 가능해요.\n\n---\n\n## 참고 자료\n\n- 공식 MDN 문서 - [Web Request and Response APIs](https://developer.mozilla.org/en-US/docs/Web/API/Request)\n- Next.js API Routes 공식 문서 (비슷한 개념으로 활용 가능)  \n- Response 객체 관련 문서: JSON 응답 생성 등 다양한 메서드 지원\n\n---\n\n간단하지만 강력한 route.js의 Route Handlers, 여러분의 서버 로직 구현에 꼭 활용해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### HTTP 메서드\n\n라우트 파일에서는 특정 경로(route)에 대해 커스텀 요청 핸들러를 만들 수 있어요. 즉, 클라이언트가 어떤 요청을 했는지에 따라 다르게 동작하도록 코드를 작성할 수 있다는 뜻이죠. 여기서 지원하는 HTTP 메서드는 GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS 이렇게 총 7가지에요.\n\n```js\nexport async function GET(request: Request) {}\n \nexport async function HEAD(request: Request) {}\n \nexport async function POST(request: Request) {}\n \nexport async function PUT(request: Request) {}\n \nexport async function DELETE(request: Request) {}\n \nexport async function PATCH(request: Request) {}\n \n// 만약 `OPTIONS` 메서드를 직접 정의하지 않으면,\n// Next.js가 자동으로 `OPTIONS` 메서드를 구현해주고,\n// Route Handler에 정의된 다른 메서드들을 기준으로 `Allow` 헤더를 설정해줍니다.\nexport async function OPTIONS(request: Request) {}\n```\n\n각 함수는 `Request` 객체를 받아서 비동기적으로 처리할 수 있는 함수예요. `Request` 객체를 통해 요청과 관련된 다양한 정보를 얻을 수 있답니다.\n\n#### 간단히 정리한 HTTP 메서드 역할\n\n| 메서드 | 설명 |\n|---|---|\n| GET | 서버에서 데이터를 읽어올 때 사용해요. 가장 기본적인 요청이죠. |\n| POST | 서버에 데이터를 새로 생성할 때 쓰여요. 예를 들어 회원가입 같은 요청이죠. |\n| PUT | 데이터를 통째로 수정할 때 사용해요. 기존 데이터를 전부 교체할 때 유용합니다. |\n| PATCH | 데이터의 일부만 수정할 때 사용해요. 수정할 부분만 보내면 되어서 효율적이죠. |\n| DELETE | 서버에서 데이터를 삭제할 때 쓰여요. |\n| HEAD | GET 요청과 비슷하지만 응답 본문(body)은 안 내려줘서 응답 헤더만 받고 싶을 때 유용해요. |\n| OPTIONS | 클라이언트가 해당 경로에서 어떤 메서드를 사용할 수 있는지 미리 물어볼 때 사용합니다. |\n\n\u003e **팁!** 실제 API 설계할 때는 각 메서드가 어떤 동작을 하는지 명확하게 구분해서 사용하는 게 좋아요. 그래야 클라이언트가 어떤 요청을 보내야 할지 헷갈리지 않고, 유지보수도 훨씬 쉬워집니다.\n\n다음에는 `Parameters`(매개변수) 부분에 대해 자세히 알아볼게요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### Next.js에서 NextRequest 활용하기 (feat. request 객체 이해하기)\n\nNext.js에서 API 라우트나 미들웨어를 만들 때, `request` 객체를 자주 다루게 되죠. 그런데 그냥 기본 Web Request API와는 조금 다른, Next.js만의 확장판인 `NextRequest`라는 객체가 있다고 해요.\n\n#### NextRequest란?\n\n`NextRequest`는 기본 Web Request 객체를 상속해서, 더 쉽고 편하게 쓸 수 있게 만든 Next.js 전용 객체입니다. 예를 들어, 쿠키를 꺼내거나, URL 정보를 다룰 때 훨씬 직관적이고 편리해요. `nextUrl`이라는 확장된 URL 객체가 포함되어 있어서, 이걸 활용하면 URL 조작도 손쉽답니다.\n\n#### 간단한 예제\n\n```ts\nimport type { NextRequest } from 'next/server'\n\nexport async function GET(request: NextRequest) {\n  // nextUrl을 통해 URL을 쉽게 접근 가능\n  const url = request.nextUrl\n\n  // 예: 쿼리 파라미터 출력해보기\n  console.log(url.searchParams.get('id'))\n\n  return new Response('Hello World')\n}\n```\n\n위 코드에서 `request.nextUrl`을 이용하면 URL 전체를 분석할 수 있고, `searchParams`로 쿼리도 쉽게 읽을 수 있어요. 만약 그냥 `request.url`을 쓰면 문자열 형태라, 직접 파싱을 해야 하니까 귀찮죠.\n\n#### NextRequest만의 꿀팁!\n\n- **쿠키 꺼내기**: `request.cookies.get('cookieName')`으로 바로 쿠키 값 꺼낼 수 있어요.\n- **헤더 접근**: `request.headers.get('headerName')` 작성법은 동일하지만, 실제로 다루기 더 깔끔해요.\n- **POST Body 읽기**: 비동기로 `request.json()` 같은 메서드를 사용해 JSON 본문을 바로 파싱할 수 있습니다.\n\n#### 마무리\n\nNext.js 13부터 등장한 이 `NextRequest` 객체는 서버 컴포넌트나 API 라우트, 미들웨어를 작성할 때 훨씬 편리하고 강력한 도구입니다. 기존의 Web Request 객체보다 기능이 많고, 특히 URL이나 쿠키 처리에 도움을 주니 꼭 활용해 보세요!\n\n궁금하면 Next.js 공식 문서에서 [`NextRequest`](https://nextjs.org/docs/api-reference/edge-runtime#nextrequest)도 참고해보시면 좋습니다.\n\n---\n\n필요하다면 다음에는 `NextResponse` 활용법도 소개할게요. 이걸로 응답을 쉽게 제어할 수 있답니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 Next.js의 동적 라우트에서 `params`가 어떻게 사용되는지 보여주는 코드 예제입니다. 이 때 `params`는 현재 라우트의 동적 경로 파라미터들을 담은 객체를 비동기적으로 반환하는 Promise입니다.\n\n```js\nexport async function GET(\n  request: Request,\n  { params }: { params: Promise\u003c{ team: string }\u003e }\n) {\n  const { team } = await params\n  // 이제 team 변수에 URL에서 전달된 동적 경로 파라미터가 들어있어요.\n}\n```\n\n예를 들어, 다음과 같은 라우트 구조와 URL 요청이 있을 때 `params`는 이렇게 들어옵니다:\n\n| Example                        | URL           | params                             |\n|-------------------------------|---------------|----------------------------------|\n| `app/dashboard/[team]/route.js` | `/dashboard/1` | `Promise\u003c{ team: '1' }\u003e`          |\n| `app/shop/[tag]/[item]/route.js` | `/shop/1/2`   | `Promise\u003c{ tag: '1', item: '2' }\u003e` |\n| `app/blog/[...slug]/route.js`    | `/blog/1/2`   | `Promise\u003c{ slug: ['1', '2'] }\u003e`    |\n\n여기서 `[team]`, `[tag]`, `[item]` 같은 부분이 동적 경로 파라미터를 나타내고, `[...,slug]`는 여러 경로 세그먼트를 배열 형태로 받을 때 사용합니다.\n\n### 덧붙여서\n\n- `params`가 Promise인 이유는 Next.js가 라우트의 데이터 패칭 시점에 비동기 처리를 하기 때문이에요. 그래서 항상 `await`을 사용해 값을 꺼내주어야 해요.\n- 동적 라우트를 사용할 땐, `params`에서 기대하는 속성명이 URL 안 동적 경로 이름과 정확히 일치하는지 꼭 확인해야 합니다.\n- 여러 개의 동적 파라미터가 있다면, 그 만큼 프로퍼티를 비동기로 받아서 처리할 수 있어요.  \n- 다중 세그먼트 캡쳐(`[...slug]`)는 블로그 포스트나 검색 결과처럼 URL 계층이 다양하게 바뀌는 경우에 유용합니다.\n\n이런 기본 개념만 잘 이해하면 Next.js의 동적 라우트는 크게 어렵지 않으니, 직접 여러가지 라우트를 만들어보면서 경험을 쌓아보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 쿠키 다루기\n\n```js\nimport { cookies } from 'next/headers'\n\nexport async function GET(request: NextRequest) {\n  const cookieStore = await cookies()\n\n  const a = cookieStore.get('a')       // 쿠키 'a' 값을 가져오기\n  const b = cookieStore.set('b', '1')  // 쿠키 'b'를 '1'로 설정하기\n  const c = cookieStore.delete('c')    // 쿠키 'c' 삭제하기\n}\n```\n\nNext.js의 `cookies()` 함수로 쉽게 쿠키를 가져오고 설정하고 삭제할 수 있어요. 여기서 중요한 건 `cookies()`가 비동기 함수라는 점인데, 그래서 `await`를 붙여줘야 제대로 값을 받을 수 있답니다.\n\n`cookieStore.get()`은 해당 이름의 쿠키 정보를 객체 형태로 줘요. 없으면 `undefined`를 반환하고요. `cookieStore.set()`은 새로운 쿠키를 추가하거나 기존 쿠키를 덮어씁니다. `cookieStore.delete()`는 지정한 쿠키를 삭제할 때 씁니다.\n\n클라이언트와 서버 모두 쿠키를 다루지만, Next.js API Route 혹은 Route Handler에서는 이렇게 `next/headers`에서 제공하는 함수를 활용하면 훨씬 간단해져서 좋아요!\n\n---\n\n## 버전 히스토리\n\n| Version         | Changes                                                                  |\n|-----------------|--------------------------------------------------------------------------|\n| `v15.0.0-RC`    | `context.params`가 이제 프로미스 형태로 바뀌었어요. [codemod](https://nextjs.org/docs/app/guides/upgrading/codemods#150) 도 제공됩니다. |\n| `v15.0.0-RC`    | `GET` 핸들러의 기본 캐싱 정책이 static에서 dynamic으로 변경됐습니다.          |\n| `v13.2.0`       | Route Handlers가 처음 소개되었습니다.                                     |\n\nNext.js는 계속 발전 중이라 버전마다 큰 변화가 있는데, 특히 Route Handler와 쿠키, 캐시 다루는 방식도 바뀌니 공식 문서를 챙겨보시는 걸 추천해요! 혹시 기존 코드를 15버전 이상으로 올리려면 codemod를 꼭 활용해보세요. 작업할 때 시간 많이 절약됩니다.","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":8},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch1\u003eroute.js\u003c/h1\u003e\n\u003cp\u003eRoute Handlers는 특정 경로(route)에 대해 커스텀 요청 처리기를 만들 수 있게 해주는 기능이에요. 즉, 내가 원하는 경로에 맞춰서 요청(Request)과 응답(Response)을 직접 다룰 수 있게 해주죠. 이때 Web Request와 Response API를 활용해요.\u003c/p\u003e\n\u003cp\u003e예를 들어, 아래처럼 GET 요청을 받았을 때 JSON 형태로 간단한 메시지를 응답하는 코드를 작성할 수 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eGET\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eResponse\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e({ \u003cspan class=\"hljs-attr\"\u003emessage\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'Hello World'\u003c/span\u003e });\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 코드는 \"/route\" 같은 경로로 GET 요청이 들어오면 \u003ccode\u003e{ message: 'Hello World' }\u003c/code\u003e라는 JSON 데이터를 클라이언트에게 보내주는 역할을 해요.\u003c/p\u003e\n\u003cp\u003e추가로 알아두면 좋은 점 몇 가지 알려드릴게요!\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eMethod별 함수 지원\u003c/strong\u003e: GET뿐 아니라 POST, PUT, DELETE 등 HTTP 메서드에 맞춰서 함수들을 만들 수 있어요.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e내장 Response 객체 활용\u003c/strong\u003e: 위 예시처럼 \u003ccode\u003eResponse.json()\u003c/code\u003e 메서드는 JSON 응답을 쉽게 만들어 주기 때문에 정말 편리해요.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e비동기 처리 가능\u003c/strong\u003e: 데이터베이스 조회나 외부 API 호출처럼 비동기가 필요한 작업도 \u003ccode\u003easync/await\u003c/code\u003e 패턴으로 자연스럽게 처리할 수 있어요.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e라우팅과 별개로 작동\u003c/strong\u003e: Next.js 같은 프레임워크에서는 보통 페이지 라우팅과 별개로 API 응답을 여기서 따로 관리할 수 있답니다!\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e만약 좀 더 복잡한 요청 처리(예: 요청 본문 읽기, 헤더 조작 등)를 하고 싶다면, Request 객체를 받아 쓰면 됩니다. 예를 들어:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePOST\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003erequest\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e body = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e request.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e();\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eResponse\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e({ \u003cspan class=\"hljs-attr\"\u003eyouSent\u003c/span\u003e: body });\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 하면 클라이언트가 보낸 데이터를 받아서 다시 돌려주는 간단한 POST 처리도 가능해요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003e참고 자료\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e공식 MDN 문서 - \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/API/Request\" rel=\"nofollow\" target=\"_blank\"\u003eWeb Request and Response APIs\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eNext.js API Routes 공식 문서 (비슷한 개념으로 활용 가능)\u003c/li\u003e\n\u003cli\u003eResponse 객체 관련 문서: JSON 응답 생성 등 다양한 메서드 지원\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e간단하지만 강력한 route.js의 Route Handlers, 여러분의 서버 로직 구현에 꼭 활용해보세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch3\u003eHTTP 메서드\u003c/h3\u003e\n\u003cp\u003e라우트 파일에서는 특정 경로(route)에 대해 커스텀 요청 핸들러를 만들 수 있어요. 즉, 클라이언트가 어떤 요청을 했는지에 따라 다르게 동작하도록 코드를 작성할 수 있다는 뜻이죠. 여기서 지원하는 HTTP 메서드는 GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS 이렇게 총 7가지에요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eGET\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003erequest: Request\u003c/span\u003e) {}\n \n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eHEAD\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003erequest: Request\u003c/span\u003e) {}\n \n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePOST\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003erequest: Request\u003c/span\u003e) {}\n \n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePUT\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003erequest: Request\u003c/span\u003e) {}\n \n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eDELETE\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003erequest: Request\u003c/span\u003e) {}\n \n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePATCH\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003erequest: Request\u003c/span\u003e) {}\n \n\u003cspan class=\"hljs-comment\"\u003e// 만약 `OPTIONS` 메서드를 직접 정의하지 않으면,\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// Next.js가 자동으로 `OPTIONS` 메서드를 구현해주고,\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// Route Handler에 정의된 다른 메서드들을 기준으로 `Allow` 헤더를 설정해줍니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eOPTIONS\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003erequest: Request\u003c/span\u003e) {}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e각 함수는 \u003ccode\u003eRequest\u003c/code\u003e 객체를 받아서 비동기적으로 처리할 수 있는 함수예요. \u003ccode\u003eRequest\u003c/code\u003e 객체를 통해 요청과 관련된 다양한 정보를 얻을 수 있답니다.\u003c/p\u003e\n\u003ch4\u003e간단히 정리한 HTTP 메서드 역할\u003c/h4\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e메서드\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003eGET\u003c/td\u003e\u003ctd\u003e서버에서 데이터를 읽어올 때 사용해요. 가장 기본적인 요청이죠.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003ePOST\u003c/td\u003e\u003ctd\u003e서버에 데이터를 새로 생성할 때 쓰여요. 예를 들어 회원가입 같은 요청이죠.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003ePUT\u003c/td\u003e\u003ctd\u003e데이터를 통째로 수정할 때 사용해요. 기존 데이터를 전부 교체할 때 유용합니다.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003ePATCH\u003c/td\u003e\u003ctd\u003e데이터의 일부만 수정할 때 사용해요. 수정할 부분만 보내면 되어서 효율적이죠.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eDELETE\u003c/td\u003e\u003ctd\u003e서버에서 데이터를 삭제할 때 쓰여요.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eHEAD\u003c/td\u003e\u003ctd\u003eGET 요청과 비슷하지만 응답 본문(body)은 안 내려줘서 응답 헤더만 받고 싶을 때 유용해요.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eOPTIONS\u003c/td\u003e\u003ctd\u003e클라이언트가 해당 경로에서 어떤 메서드를 사용할 수 있는지 미리 물어볼 때 사용합니다.\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e팁!\u003c/strong\u003e 실제 API 설계할 때는 각 메서드가 어떤 동작을 하는지 명확하게 구분해서 사용하는 게 좋아요. 그래야 클라이언트가 어떤 요청을 보내야 할지 헷갈리지 않고, 유지보수도 훨씬 쉬워집니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e다음에는 \u003ccode\u003eParameters\u003c/code\u003e(매개변수) 부분에 대해 자세히 알아볼게요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch3\u003eNext.js에서 NextRequest 활용하기 (feat. request 객체 이해하기)\u003c/h3\u003e\n\u003cp\u003eNext.js에서 API 라우트나 미들웨어를 만들 때, \u003ccode\u003erequest\u003c/code\u003e 객체를 자주 다루게 되죠. 그런데 그냥 기본 Web Request API와는 조금 다른, Next.js만의 확장판인 \u003ccode\u003eNextRequest\u003c/code\u003e라는 객체가 있다고 해요.\u003c/p\u003e\n\u003ch4\u003eNextRequest란?\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003eNextRequest\u003c/code\u003e는 기본 Web Request 객체를 상속해서, 더 쉽고 편하게 쓸 수 있게 만든 Next.js 전용 객체입니다. 예를 들어, 쿠키를 꺼내거나, URL 정보를 다룰 때 훨씬 직관적이고 편리해요. \u003ccode\u003enextUrl\u003c/code\u003e이라는 확장된 URL 객체가 포함되어 있어서, 이걸 활용하면 URL 조작도 손쉽답니다.\u003c/p\u003e\n\u003ch4\u003e간단한 예제\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-ts\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eNextRequest\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/server'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eGET\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003erequest: NextRequest\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// nextUrl을 통해 URL을 쉽게 접근 가능\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e url = request.\u003cspan class=\"hljs-property\"\u003enextUrl\u003c/span\u003e\n\n  \u003cspan class=\"hljs-comment\"\u003e// 예: 쿼리 파라미터 출력해보기\u003c/span\u003e\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(url.\u003cspan class=\"hljs-property\"\u003esearchParams\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'id'\u003c/span\u003e))\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eResponse\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Hello World'\u003c/span\u003e)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드에서 \u003ccode\u003erequest.nextUrl\u003c/code\u003e을 이용하면 URL 전체를 분석할 수 있고, \u003ccode\u003esearchParams\u003c/code\u003e로 쿼리도 쉽게 읽을 수 있어요. 만약 그냥 \u003ccode\u003erequest.url\u003c/code\u003e을 쓰면 문자열 형태라, 직접 파싱을 해야 하니까 귀찮죠.\u003c/p\u003e\n\u003ch4\u003eNextRequest만의 꿀팁!\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e쿠키 꺼내기\u003c/strong\u003e: \u003ccode\u003erequest.cookies.get('cookieName')\u003c/code\u003e으로 바로 쿠키 값 꺼낼 수 있어요.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e헤더 접근\u003c/strong\u003e: \u003ccode\u003erequest.headers.get('headerName')\u003c/code\u003e 작성법은 동일하지만, 실제로 다루기 더 깔끔해요.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePOST Body 읽기\u003c/strong\u003e: 비동기로 \u003ccode\u003erequest.json()\u003c/code\u003e 같은 메서드를 사용해 JSON 본문을 바로 파싱할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e마무리\u003c/h4\u003e\n\u003cp\u003eNext.js 13부터 등장한 이 \u003ccode\u003eNextRequest\u003c/code\u003e 객체는 서버 컴포넌트나 API 라우트, 미들웨어를 작성할 때 훨씬 편리하고 강력한 도구입니다. 기존의 Web Request 객체보다 기능이 많고, 특히 URL이나 쿠키 처리에 도움을 주니 꼭 활용해 보세요!\u003c/p\u003e\n\u003cp\u003e궁금하면 Next.js 공식 문서에서 \u003ca href=\"https://nextjs.org/docs/api-reference/edge-runtime#nextrequest\" rel=\"nofollow\" target=\"_blank\"\u003e\u003ccode\u003eNextRequest\u003c/code\u003e\u003c/a\u003e도 참고해보시면 좋습니다.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e필요하다면 다음에는 \u003ccode\u003eNextResponse\u003c/code\u003e 활용법도 소개할게요. 이걸로 응답을 쉽게 제어할 수 있답니다!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e아래는 Next.js의 동적 라우트에서 \u003ccode\u003eparams\u003c/code\u003e가 어떻게 사용되는지 보여주는 코드 예제입니다. 이 때 \u003ccode\u003eparams\u003c/code\u003e는 현재 라우트의 동적 경로 파라미터들을 담은 객체를 비동기적으로 반환하는 Promise입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eGET\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\n  request: Request,\n  { params }: { params: \u003cspan class=\"hljs-built_in\"\u003ePromise\u003c/span\u003e\u0026#x3C;{ team: string }\u003e }\n\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { team } = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e params\n  \u003cspan class=\"hljs-comment\"\u003e// 이제 team 변수에 URL에서 전달된 동적 경로 파라미터가 들어있어요.\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e예를 들어, 다음과 같은 라우트 구조와 URL 요청이 있을 때 \u003ccode\u003eparams\u003c/code\u003e는 이렇게 들어옵니다:\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003eExample\u003c/th\u003e\u003cth\u003eURL\u003c/th\u003e\u003cth\u003eparams\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eapp/dashboard/[team]/route.js\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e/dashboard/1\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003ePromise\u0026#x3C;{ team: '1' }\u003e\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eapp/shop/[tag]/[item]/route.js\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e/shop/1/2\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003ePromise\u0026#x3C;{ tag: '1', item: '2' }\u003e\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eapp/blog/[...slug]/route.js\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003e/blog/1/2\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003ePromise\u0026#x3C;{ slug: ['1', '2'] }\u003e\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e여기서 \u003ccode\u003e[team]\u003c/code\u003e, \u003ccode\u003e[tag]\u003c/code\u003e, \u003ccode\u003e[item]\u003c/code\u003e 같은 부분이 동적 경로 파라미터를 나타내고, \u003ccode\u003e[...,slug]\u003c/code\u003e는 여러 경로 세그먼트를 배열 형태로 받을 때 사용합니다.\u003c/p\u003e\n\u003ch3\u003e덧붙여서\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eparams\u003c/code\u003e가 Promise인 이유는 Next.js가 라우트의 데이터 패칭 시점에 비동기 처리를 하기 때문이에요. 그래서 항상 \u003ccode\u003eawait\u003c/code\u003e을 사용해 값을 꺼내주어야 해요.\u003c/li\u003e\n\u003cli\u003e동적 라우트를 사용할 땐, \u003ccode\u003eparams\u003c/code\u003e에서 기대하는 속성명이 URL 안 동적 경로 이름과 정확히 일치하는지 꼭 확인해야 합니다.\u003c/li\u003e\n\u003cli\u003e여러 개의 동적 파라미터가 있다면, 그 만큼 프로퍼티를 비동기로 받아서 처리할 수 있어요.\u003c/li\u003e\n\u003cli\u003e다중 세그먼트 캡쳐(\u003ccode\u003e[...slug]\u003c/code\u003e)는 블로그 포스트나 검색 결과처럼 URL 계층이 다양하게 바뀌는 경우에 유용합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이런 기본 개념만 잘 이해하면 Next.js의 동적 라우트는 크게 어렵지 않으니, 직접 여러가지 라우트를 만들어보면서 경험을 쌓아보세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch3\u003e쿠키 다루기\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { cookies } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/headers'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eGET\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003erequest: NextRequest\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e cookieStore = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecookies\u003c/span\u003e()\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e a = cookieStore.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'a'\u003c/span\u003e)       \u003cspan class=\"hljs-comment\"\u003e// 쿠키 'a' 값을 가져오기\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e b = cookieStore.\u003cspan class=\"hljs-title function_\"\u003eset\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'b'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'1'\u003c/span\u003e)  \u003cspan class=\"hljs-comment\"\u003e// 쿠키 'b'를 '1'로 설정하기\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e c = cookieStore.\u003cspan class=\"hljs-title function_\"\u003edelete\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'c'\u003c/span\u003e)    \u003cspan class=\"hljs-comment\"\u003e// 쿠키 'c' 삭제하기\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNext.js의 \u003ccode\u003ecookies()\u003c/code\u003e 함수로 쉽게 쿠키를 가져오고 설정하고 삭제할 수 있어요. 여기서 중요한 건 \u003ccode\u003ecookies()\u003c/code\u003e가 비동기 함수라는 점인데, 그래서 \u003ccode\u003eawait\u003c/code\u003e를 붙여줘야 제대로 값을 받을 수 있답니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ecookieStore.get()\u003c/code\u003e은 해당 이름의 쿠키 정보를 객체 형태로 줘요. 없으면 \u003ccode\u003eundefined\u003c/code\u003e를 반환하고요. \u003ccode\u003ecookieStore.set()\u003c/code\u003e은 새로운 쿠키를 추가하거나 기존 쿠키를 덮어씁니다. \u003ccode\u003ecookieStore.delete()\u003c/code\u003e는 지정한 쿠키를 삭제할 때 씁니다.\u003c/p\u003e\n\u003cp\u003e클라이언트와 서버 모두 쿠키를 다루지만, Next.js API Route 혹은 Route Handler에서는 이렇게 \u003ccode\u003enext/headers\u003c/code\u003e에서 제공하는 함수를 활용하면 훨씬 간단해져서 좋아요!\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003e버전 히스토리\u003c/h2\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003eVersion\u003c/th\u003e\u003cth\u003eChanges\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ev15.0.0-RC\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003econtext.params\u003c/code\u003e가 이제 프로미스 형태로 바뀌었어요. \u003ca href=\"https://nextjs.org/docs/app/guides/upgrading/codemods#150\" rel=\"nofollow\" target=\"_blank\"\u003ecodemod\u003c/a\u003e 도 제공됩니다.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ev15.0.0-RC\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eGET\u003c/code\u003e 핸들러의 기본 캐싱 정책이 static에서 dynamic으로 변경됐습니다.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ev13.2.0\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eRoute Handlers가 처음 소개되었습니다.\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003eNext.js는 계속 발전 중이라 버전마다 큰 변화가 있는데, 특히 Route Handler와 쿠키, 캐시 다루는 방식도 바뀌니 공식 문서를 챙겨보시는 걸 추천해요! 혹시 기존 코드를 15버전 이상으로 올리려면 codemod를 꼭 활용해보세요. 작업할 때 시간 많이 절약됩니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2025-04-22-routejs"},"buildId":"X4OrKfmLtU3-3BijwfHe6","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>