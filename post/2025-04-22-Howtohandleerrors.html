<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>TypeScript와 ReactJS에서 에러 처리하는 5가지 방법 | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-Howtohandleerrors" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="TypeScript와 ReactJS에서 에러 처리하는 5가지 방법 | TIL" data-gatsby-head="true"/><meta property="og:title" content="TypeScript와 ReactJS에서 에러 처리하는 5가지 방법 | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-Howtohandleerrors" data-gatsby-head="true"/><meta name="twitter:title" content="TypeScript와 ReactJS에서 에러 처리하는 5가지 방법 | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2025-04-22 01:16" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/post/%5Bslug%5D-8ded8b979ba73586.js" defer=""></script><script src="/TIL/_next/static/X4OrKfmLtU3-3BijwfHe6/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/X4OrKfmLtU3-3BijwfHe6/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">TypeScript와 ReactJS에서 에러 처리하는 5가지 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="TypeScript와 ReactJS에서 에러 처리하는 5가지 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Apr 22, 2025</span><span class="posts_reading_time__f7YPP">12<!-- --> min read</span></span></div></div></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h1>에러 처리하는 법</h1>
<p>에러는 크게 두 가지로 나눌 수 있어요: 예상 가능한 에러와 잡히지 않은 예외(uncaught exceptions)죠. 이번 글에서는 Next.js 앱에서 이런 에러들을 어떻게 다룰 수 있는지 쉽게 알려드릴게요.</p>
<h2>예상 가능한 에러 처리하기</h2>
<p>예상 가능한 에러는 앱이 정상적으로 작동하는 중에 발생할 수 있는 에러예요. 예를 들어 서버 쪽 폼 검증에서 실패할 때나, API 요청이 실패하는 경우죠. 이런 에러들은 명확하게 처리해서 클라이언트한테 적절하게 전달해줘야 해요.</p>
<p>사실 이런 에러들은 사용자 경험에도 영향을 많이 주기 때문에, 단순히 ‘문제가 발생했습니다’라고 하는 것보단, 어떤 문제가 있는지 구체적으로 알려주는 게 중요해요. 예를 들어, 폼에서 이메일 형식이 맞지 않으면 "이메일 형식이 올바르지 않습니다"라고 바로 알려주면 사용자가 수정할 수 있잖아요?</p>
<p>Next.js에서는 서버 사이드 코드에서 이런 에러들을 try-catch 문으로 잡아서, 적절한 HTTP 상태 코드와 메시지로 응답을 줄 수 있어요. 클라이언트 쪽에서는 그 응답을 받아서 UI에 에러 메시지를 띄우거나, 특정 행동을 유도하도록 하면 됩니다.</p>
<p>혹시 에러를 다루는 게 처음이라면, ‘에러 핸들링 레이어’를 따로 만들어서 코드를 깔끔하게 관리하는 것도 추천해요. 그래야 에러 처리 로직이 여러 군데 흩어지지 않고, 수정도 편리해요.</p>
<p>다음에는 잡히지 않은 예외, 즉 예기치 않은 오류가 발생했을 때 어떻게 대처하는지도 알려드릴게요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h3>서버 함수에서 예상 에러 처리하기</h3>
<p>서버 함수(Server Functions)를 작성할 때, 예상되는 에러를 다루는 방법에 대해 이야기해볼게요. 보통 자바스크립트에서 에러가 발생하면 try/catch로 잡거나 <code>throw</code>를 해서 에러를 던지죠? 그런데 서버 함수에서는 이런 방식보다는 **예상 가능한 에러를 반환값(return value)**으로 모델링하는 게 좋아요.</p>
<p>예를 들어, 아래와 같이 <code>createPost</code>라는 서버 함수를 만들었을 때, API 호출이 실패하는 경우를 생각해볼게요.</p>
<pre><code class="hljs language-js"><span class="hljs-string">"use server"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createPost</span>(<span class="hljs-params">prevState: any, formData: FormData</span>) {
  <span class="hljs-keyword">const</span> title = formData.<span class="hljs-title function_">get</span>(<span class="hljs-string">"title"</span>);
  <span class="hljs-keyword">const</span> content = formData.<span class="hljs-title function_">get</span>(<span class="hljs-string">"content"</span>);

  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">"https://api.vercel.app/posts"</span>, {
    <span class="hljs-attr">method</span>: <span class="hljs-string">"POST"</span>,
    <span class="hljs-attr">body</span>: { title, content },
  });
  <span class="hljs-keyword">const</span> json = <span class="hljs-keyword">await</span> res.<span class="hljs-title function_">json</span>();

  <span class="hljs-keyword">if</span> (!res.<span class="hljs-property">ok</span>) {
    <span class="hljs-keyword">return</span> { <span class="hljs-attr">message</span>: <span class="hljs-string">"Failed to create post"</span> };
  }
}
</code></pre>
<p>여기서 실패하면 그냥 <code>throw</code> 대신 <code>{ message: 'Failed to create post' }</code>라는 객체를 반환하고 있죠? 이렇게 하면 클라이언트 쪽에서 이 반환값을 이용해 에러 메시지를 쉽게 표시할 수 있어요.</p>
<h4>팁!</h4>
<ul>
<li>서버에서 에러를 <code>throw</code>하면 클라이언트 입장에선 뭘 잘못했는지 알기 어려울 수 있어요. 그래서 예상 가능한 에러들은 명확하게 데이터로 내려주는 게 UX에도 더 좋아요.</li>
<li>반대로, 정말 예상하지 못한 시스템 에러는 그대로 <code>throw</code>해서 호출 스택에서 잡히게 하는 게 관리하기 편합니다.</li>
<li>그리고, <code>useActionState</code> 훅을 사용하면 이런 반환값을 쉽게 받아서 처리할 수 있으니 한번 써보세요!</li>
</ul>
<p>이런 스타일은 점점 더 많은 React 서버 컴포넌트 기반 환경에서 권장되는 패턴이니, 앞으로 서버 함수 작성할 때 참고하면 좋아요.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이번 시간에는 React의 <code>useActionState</code> 훅을 이용해서 폼 제출 시 발생할 수 있는 에러 메시지를 화면에 표시하는 방법을 함께 알아보겠습니다.</p>
<p>기본적으로 <code>useActionState</code>는 액션(action)의 상태를 추적할 수 있도록 도와줘서, 성공 여부나 에러 발생 시 상태를 쉽게 관리할 수 있답니다.</p>
<hr>
<h2>예제 코드 살펴보기</h2>
<pre><code class="hljs language-jsx"><span class="hljs-string">"use client"</span>;

<span class="hljs-keyword">import</span> { useActionState } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> { createPost } <span class="hljs-keyword">from</span> <span class="hljs-string">"@/app/actions"</span>;

<span class="hljs-keyword">const</span> initialState = {
  <span class="hljs-attr">message</span>: <span class="hljs-string">""</span>,
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Form</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// useActionState 훅 호출, createPost 액션을 인자로 전달</span>
  <span class="hljs-keyword">const</span> { state, pending } = <span class="hljs-title function_">useActionState</span>(createPost);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">{createPost}</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">label</span> <span class="hljs-attr">htmlFor</span>=<span class="hljs-string">"title"</span>></span>Title<span class="hljs-tag">&#x3C;/<span class="hljs-name">label</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"title"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"title"</span> <span class="hljs-attr">required</span> /></span>

      <span class="hljs-tag">&#x3C;<span class="hljs-name">label</span> <span class="hljs-attr">htmlFor</span>=<span class="hljs-string">"content"</span>></span>Content<span class="hljs-tag">&#x3C;/<span class="hljs-name">label</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">textarea</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"content"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"content"</span> <span class="hljs-attr">required</span> /></span>

      <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">disabled</span>=<span class="hljs-string">{pending}</span>></span>Create Post<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>

      {/* 에러 메시지가 있다면 화면에 표시 */}
      {state?.message &#x26;&#x26; <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">color:</span> "<span class="hljs-attr">red</span>" }}></span>{state.message}<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>}
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">form</span>></span></span>
  );
}
</code></pre>
<ul>
<li><code>useActionState(createPost)</code>를 호출하면 액션의 현재 상태(<code>state</code>)와 제출 진행 중 여부(<code>pending</code>)를 반환해줍니다.</li>
<li><code>state.message</code>에 에러 메시지가 담겨 있다면, 이를 사용자에게 보여줄 수 있죠.</li>
<li><code>button</code>은 제출하는 동안 중복 전송을 방지하기 위해 <code>disabled</code> 처리됩니다.</li>
</ul>
<hr>
<h2>Server Component에서 에러 핸들링</h2>
<p>서버 컴포넌트에서 데이터를 불러올 때도 에러 처리는 중요하죠! 거기서는 서버에서 받은 응답을 활용해 조건부 렌더링을 하거나, 필요시 리다이렉션을 할 수 있습니다.</p>
<p>예를 들어:</p>
<pre><code class="hljs language-jsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchData</span>(); <span class="hljs-comment">// 서버에서 데이터 가져오기</span>
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">DisplayData</span> <span class="hljs-attr">data</span>=<span class="hljs-string">{data}</span> /></span></span>;
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-comment">// 에러 발생 시 에러 메시지 또는 리다이렉션 처리</span>
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>데이터를 불러오는 중 오류가 발생했습니다.<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span></span>;
  }
}
</code></pre>
<p>이처럼 서버 컴포넌트 내부에서 <code>try-catch</code> 문으로 에러를 잡아서 사용자에게 피드백을 줄 수 있습니다.</p>
<hr>
<h2>정리하자면</h2>
<ul>
<li><strong>useActionState</strong> 훅을 활용하면 클라이언트 컴포넌트 내에서 액션 상태를 쉽게 관리하고, 에러 메시지를 화면에 표시할 수 있습니다.</li>
<li>제출 버튼에 진행 상태를 반영해 사용자 경험도 개선할 수 있죠.</li>
<li><strong>서버 컴포넌트</strong>에서는 데이터를 비동기로 가져올 때 에러를 잡아서 적절히 처리해야 하며, 이때 사용자에게 친절하게 에러를 알리는 UI를 만드는 게 중요합니다.</li>
</ul>
<hr>
<p>혹시 더 자세한 액션 상태 관리나 서버-클라이언트 간 에러 핸들링에 관해 궁금한 점이 있으면 언제든지 물어보세요! 여러분이 더 쉽게 React와 Next.js를 활용할 수 있도록 돕겠습니다 :)</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>자, 이번에는 Next.js에서 데이터를 가져오고, 만약 데이터가 없다면 404 페이지를 띄우는 방법에 대해 이야기해볼게요.</p>
<p>먼저, fetch API를 사용해서 데이터를 비동기로 가져오는 기본 예제부터 봅시다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`https://...`</span>);
  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> res.<span class="hljs-title function_">json</span>();

  <span class="hljs-keyword">if</span> (!res.<span class="hljs-property">ok</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"There was an error."</span>; <span class="hljs-comment">// 에러 발생 시 간단한 메시지 반환</span>
  }

  <span class="hljs-keyword">return</span> <span class="hljs-string">"..."</span>; <span class="hljs-comment">// 데이터를 성공적으로 받아오면 원하는 UI 반환</span>
}
</code></pre>
<p>여기서 핵심은 서버 API를 호출하고, 응답이 제대로 오지 않으면 에러 메시지를 보여주는 거예요. 그런데, 만약 해당 페이지나 데이터가 없을 때는 ‘404 페이지’를 보여주는 방법도 필요하겠죠?</p>
<p>Next.js에서는 <code>notFound()</code> 함수를 이용해서 이런 상황을 처리할 수 있어요. 예를 들어, 블로그 포스트를 주소로 찾는 상황을 가정해보죠.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { notFound } <span class="hljs-keyword">from</span> <span class="hljs-string">"next/navigation"</span>;
<span class="hljs-keyword">import</span> { getPostBySlug } <span class="hljs-keyword">from</span> <span class="hljs-string">"@/lib/posts"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params">{ params }: { params: { slug: string } }</span>) {
  <span class="hljs-keyword">const</span> { slug } = params;
  <span class="hljs-keyword">const</span> post = <span class="hljs-title function_">getPostBySlug</span>(slug);

  <span class="hljs-keyword">if</span> (!post) {
    <span class="hljs-title function_">notFound</span>(); <span class="hljs-comment">// 데이터가 없으면 404 페이지로 이동</span>
  }

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>{post.title}<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>; <span class="hljs-comment">// 포스트 타이틀 출력</span>
}
</code></pre>
<p>여기서 중요한 점 몇 가지 짚고 넘어가면:</p>





















<table><thead><tr><th>항목</th><th>설명</th></tr></thead><tbody><tr><td><code>notFound()</code></td><td>Next.js가 제공하는 내장 함수로, 호출 시 해당 페이지 대신 404 UI를 보여줘요. 그냥 반환하는 게 아니라 실제로 404 상태로 페이지가 렌더링됩니다.</td></tr><tr><td><code>getPostBySlug</code></td><td>여긴 예시로 작성한 함수인데, 실제로는 슬러그(게시물 주소)를 기준으로 데이터를 찾아오는 로직입니다. 만약 없으면 <code>undefined</code> 혹은 <code>null</code> 반환</td></tr><tr><td><code>params</code></td><td>동적 라우팅에서 URL 파라미터를 받을 때 사용해요. 예를 들어 <code>/posts/hello-world</code> 라면 slug는 <code>hello-world</code> 가 되겠죠</td></tr></tbody></table>
<p>추가로, <code>not-found.js</code> 또는 <code>not-found.tsx</code> 파일을 프로젝트에 만들어서 404 페이지의 UI를 커스터마이징 할 수도 있어요.</p>
<pre><code class="hljs language-jsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">NotFound</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">h1</span>></span>페이지를 찾을 수 없어요 ㅠㅠ<span class="hljs-tag">&#x3C;/<span class="hljs-name">h1</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>요청하신 페이지가 존재하지 않거나 삭제되었습니다.<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  );
}
</code></pre>
<p>이렇게 하면 프로젝트 전반에서 공통으로 쓰이는 404 페이지가 알아서 뜹니다.</p>
<p>정리해보면, 데이터가 없거나 잘못된 URL을 요청했을 때 사용자에게 잘못된 접근임을 알려주는 방법으로 <code>notFound()</code> 호출과 맞춤형 404 페이지를 함께 사용하면 훨씬 깔끔한 사용자 경험을 만들 수 있다는 점! 꼭 기억하세요~</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-jsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">NotFound</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>404 - Page Not Found<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>;
}
</code></pre>
<h2>처리하지 않은 예외(uncaught exceptions) 다루기</h2>
<p>처리하지 않은 예외란, 애플리케이션의 정상적인 흐름에서는 발생하지 말아야 할 예상치 못한 오류를 뜻해요. 이런 예외들은 보통 에러를 던져서(error throwing) 처리하는데, 이 에러를 '에러 바운더리(Error Boundary)'에서 잡아내서 적절히 대응해주는 방식이 일반적입니다.</p>
<p>에러 바운더리는 리액트 컴포넌트에서 흔히 사용되는데, UI가 깨지지 않고 사용자에게 친절한 에러 메시지를 보여주거나, 로그를 남기거나, 대체 UI로 전환하는 데 활용할 수 있답니다.</p>
<h3>중첩된 에러 바운더리(Nested error boundaries)</h3>
<p>에러 바운더리를 한 군데만 두는 것보다, 애플리케이션 구조에 따라 여러 단계로 중첩시켜서 중요한 UI 부분별로 별도의 에러 처리 영역을 만드는 게 좋아요. 예를 들어, 페이지 전체를 감싸는 바운더리가 있고, 그 안에 각각의 위젯이나 컴포넌트 단위로 또 다른 바운더리가 존재하면, 특정 위젯에서 문제가 생겨도 페이지 전체가 깨지지 않고 해당 위젯 부분만 에러 UI로 교체할 수 있거든요.</p>
<p>이렇게 하면 사용자 경험도 개선되고, 디버깅할 때도 어떤 컴포넌트에서 문제가 발생했는지를 좀 더 명확히 파악할 수 있습니다.</p>
<hr>
<p>참고로, 리액트에서 에러 바운더리를 구현할 때는 다음과 같은 라이프사이클 메서드를 활용해요:</p>
<ul>
<li><code>static getDerivedStateFromError(error)</code>: 에러가 발생했을 때 상태를 업데이트하여 대체 UI를 렌더할 준비를 함</li>
<li><code>componentDidCatch(error, info)</code>: 에러 로깅 등 부가 작업 수행</li>
</ul>
<p>그리고 함수형 컴포넌트만 쓴다면 <code>Error Boundary</code>는 아직 클래스 컴포넌트로 작성해야 한다는 점 기억하세요!<br>
리액트가 앞으로 훅 기반 에러 바운더리를 지원하면 훨씬 편리해지겠죠?</p>
<p>필요하면 에러 바운더리 예제도 공유해 드릴게요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Next.js에서는 에러 바운더리(Error Boundaries)를 이용해 예기치 못한 에러를 잡아냅니다. 에러 바운더리는 자식 컴포넌트에서 발생한 오류를 잡아내서, 부러진 컴포넌트 트리 대신에 대체 UI(일종의 에러 화면)를 보여주게 해주죠.</p>
<p>이걸 구현하려면, 라우트 세그먼트(route segment) 안에 <code>error.js</code> 파일을 만들고 React 컴포넌트를 내보내면 됩니다. 예시는 아래와 같아요:</p>
<pre><code class="hljs language-js"><span class="hljs-string">'use client'</span> <span class="hljs-comment">// 에러 바운더리는 클라이언트 컴포넌트여야 합니다</span>

<span class="hljs-keyword">import</span> { useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Error</span>(<span class="hljs-params">{
  error,
  reset,
}: {
  error: <span class="hljs-built_in">Error</span> &#x26; { digest?: string }
  reset: () => <span class="hljs-keyword">void</span>
}</span>) {
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-comment">// 에러 리포팅 서비스에 로그를 보낸다고 생각해보세요</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error)
  }, [error])

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">h2</span>></span>문제가 발생했어요!<span class="hljs-tag">&#x3C;/<span class="hljs-name">h2</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span>
        <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span>
          // <span class="hljs-attr">다시</span> <span class="hljs-attr">렌더링</span> <span class="hljs-attr">시도해서</span> <span class="hljs-attr">복구를</span> <span class="hljs-attr">노립니다</span>
          () =></span> reset()
        }
      >
        다시 시도
      <span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  )
}
</code></pre>
<p>여기서 핵심은 <code>reset</code> 함수예요. 이 버튼을 누르면 해당 세그먼트를 다시 렌더링하면서 문제가 해결됐는지 재시도합니다.</p>
<p>그리고 재미있는 점! 에러는 가장 가까운 상위 에러 바운더리로 올라가서 처리돼요. 덕분에, 라우트 트리 계층별로 <code>error.js</code>를 여러 개 둬서 세밀하게 에러 처리를 할 수 있습니다. 예를 들어, 특정 페이지에서만 보여줄 맞춤형 에러 화면도 가능하다는 뜻이죠.</p>
<hr>
<p>추가로 알려드리자면, Next.js에서는 페이지나 레이아웃 단위로 에러를 다룰 수 있어서 사용자 경험을 더 세련되게 만드는 데 큰 도움이 됩니당. 단, 에러 바운더리는 무조건 클라이언트 컴포넌트여야 하는 점은 꼭 기억해주세요!</p>
<p>꼭 한 가지 깜빡하지 말아야 할 팁은, 에러 바운더리 안에서도 에러는 다시 던져지지 않으니, 중요한 로그나 오류 추적(예: Sentry 같은 도구 활용)은 <code>useEffect</code> 같은 곳에서 해주는 게 베스트입니다.</p>
<p>필요할 때마다 <code>error.js</code> 만들어서 우아한 에러 처리를 해보세요! 사용자도, 개발자도 모두 행복해질 거예요 :)</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<img src="/TIL/assets/img/2025-04-22-Howtohandleerrors_0.png">
<h3>전역 에러 처리하기 (Global errors)</h3>
<p>에러 처리하면 보통 각 컴포넌트 단위에서 하게 되지만, root 레이아웃 단계에서 전역적으로 에러를 잡고 싶을 때가 있어요. 이런 경우에는 <code>app</code> 루트 디렉터리에 <code>global-error.js</code> 파일을 만들어서 처리할 수 있습니다. 특히 다국어 지원 같은 국제화(i18n)를 적용해도 똑같이 쓸 수 있다는 점도 참고하세요.</p>
<p>이 전역 에러 UI 컴포넌트는 root 레이아웃이나 템플릿을 완전히 대체하는 역할을 하기 때문에, 직접 <code>html</code>과 <code>body</code> 태그를 포함해야 해요. 없으면 브라우저가 제대로 렌더링하지 않기 때문에 꼭 넣어줘야 합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-string">'use client'</span> <span class="hljs-comment">// 에러 바운더리는 클라이언트 컴포넌트여야 합니다</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">GlobalError</span>(<span class="hljs-params">{
  error,
  reset,
}: {
  error: <span class="hljs-built_in">Error</span> &#x26; { digest?: string }
  reset: () => <span class="hljs-keyword">void</span>
}</span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">html</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">body</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">h2</span>></span>문제가 발생했어요!<span class="hljs-tag">&#x3C;/<span class="hljs-name">h2</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =></span> reset()}>다시 시도<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
      <span class="hljs-tag">&#x3C;/<span class="hljs-name">body</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">html</span>></span></span>
  )
}
</code></pre>
<h3>핵심 포인트</h3>
<ul>
<li><code>'use client'</code> 선언으로 클라이언트 컴포넌트로 만들어야 에러 경계(Error Boundaries)가 정상 동작해요.</li>
<li>에러를 화면에 보여주고, 사용자가 다시 시도할 수 있도록 reset 함수도 전달받아 꼭 활용하세요.</li>
<li>전역 에러 UI는 root 레이아웃을 완전히 대체하므로 <code>html, body</code> 태그를 반드시 포함!</li>
</ul>
<h3>살짝 더!</h3>
<p>만약 이 전역 에러 화면에 스타일을 입히고 싶다면, 전역 CSS를 불러오거나 <code>style</code> 태그를 넣는 방법이 있어요. 그리고 모던 웹 앱에서는 에러가 발생했을 때 단순히 메시지 보여주는 것 말고, 사용자 피드백을 받아 서버로 리포트 하거나, 자동 리프레시 기능을 추가하는 것도 생각해볼 만합니다.</p>
<p>즉, 전역 에러 처리는 앱 안정성을 향상시키는 훌륭한 도구니 적극 활용해보세요!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"TypeScript와 ReactJS에서 에러 처리하는 5가지 방법","description":"","date":"2025-04-22 01:16","slug":"2025-04-22-Howtohandleerrors","content":"\n# 에러 처리하는 법\n\n에러는 크게 두 가지로 나눌 수 있어요: 예상 가능한 에러와 잡히지 않은 예외(uncaught exceptions)죠. 이번 글에서는 Next.js 앱에서 이런 에러들을 어떻게 다룰 수 있는지 쉽게 알려드릴게요.\n\n## 예상 가능한 에러 처리하기\n\n예상 가능한 에러는 앱이 정상적으로 작동하는 중에 발생할 수 있는 에러예요. 예를 들어 서버 쪽 폼 검증에서 실패할 때나, API 요청이 실패하는 경우죠. 이런 에러들은 명확하게 처리해서 클라이언트한테 적절하게 전달해줘야 해요.\n\n사실 이런 에러들은 사용자 경험에도 영향을 많이 주기 때문에, 단순히 ‘문제가 발생했습니다’라고 하는 것보단, 어떤 문제가 있는지 구체적으로 알려주는 게 중요해요. 예를 들어, 폼에서 이메일 형식이 맞지 않으면 \"이메일 형식이 올바르지 않습니다\"라고 바로 알려주면 사용자가 수정할 수 있잖아요?\n\nNext.js에서는 서버 사이드 코드에서 이런 에러들을 try-catch 문으로 잡아서, 적절한 HTTP 상태 코드와 메시지로 응답을 줄 수 있어요. 클라이언트 쪽에서는 그 응답을 받아서 UI에 에러 메시지를 띄우거나, 특정 행동을 유도하도록 하면 됩니다.\n\n혹시 에러를 다루는 게 처음이라면, ‘에러 핸들링 레이어’를 따로 만들어서 코드를 깔끔하게 관리하는 것도 추천해요. 그래야 에러 처리 로직이 여러 군데 흩어지지 않고, 수정도 편리해요.\n\n다음에는 잡히지 않은 예외, 즉 예기치 않은 오류가 발생했을 때 어떻게 대처하는지도 알려드릴게요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 서버 함수에서 예상 에러 처리하기\n\n서버 함수(Server Functions)를 작성할 때, 예상되는 에러를 다루는 방법에 대해 이야기해볼게요. 보통 자바스크립트에서 에러가 발생하면 try/catch로 잡거나 `throw`를 해서 에러를 던지죠? 그런데 서버 함수에서는 이런 방식보다는 **예상 가능한 에러를 반환값(return value)**으로 모델링하는 게 좋아요.\n\n예를 들어, 아래와 같이 `createPost`라는 서버 함수를 만들었을 때, API 호출이 실패하는 경우를 생각해볼게요.\n\n```js\n\"use server\";\n\nexport async function createPost(prevState: any, formData: FormData) {\n  const title = formData.get(\"title\");\n  const content = formData.get(\"content\");\n\n  const res = await fetch(\"https://api.vercel.app/posts\", {\n    method: \"POST\",\n    body: { title, content },\n  });\n  const json = await res.json();\n\n  if (!res.ok) {\n    return { message: \"Failed to create post\" };\n  }\n}\n```\n\n여기서 실패하면 그냥 `throw` 대신 `{ message: 'Failed to create post' }`라는 객체를 반환하고 있죠? 이렇게 하면 클라이언트 쪽에서 이 반환값을 이용해 에러 메시지를 쉽게 표시할 수 있어요.\n\n#### 팁!\n\n- 서버에서 에러를 `throw`하면 클라이언트 입장에선 뭘 잘못했는지 알기 어려울 수 있어요. 그래서 예상 가능한 에러들은 명확하게 데이터로 내려주는 게 UX에도 더 좋아요.\n- 반대로, 정말 예상하지 못한 시스템 에러는 그대로 `throw`해서 호출 스택에서 잡히게 하는 게 관리하기 편합니다.\n- 그리고, `useActionState` 훅을 사용하면 이런 반환값을 쉽게 받아서 처리할 수 있으니 한번 써보세요!\n\n이런 스타일은 점점 더 많은 React 서버 컴포넌트 기반 환경에서 권장되는 패턴이니, 앞으로 서버 함수 작성할 때 참고하면 좋아요.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번 시간에는 React의 `useActionState` 훅을 이용해서 폼 제출 시 발생할 수 있는 에러 메시지를 화면에 표시하는 방법을 함께 알아보겠습니다.\n\n기본적으로 `useActionState`는 액션(action)의 상태를 추적할 수 있도록 도와줘서, 성공 여부나 에러 발생 시 상태를 쉽게 관리할 수 있답니다.\n\n---\n\n## 예제 코드 살펴보기\n\n```jsx\n\"use client\";\n\nimport { useActionState } from \"react\";\nimport { createPost } from \"@/app/actions\";\n\nconst initialState = {\n  message: \"\",\n};\n\nexport function Form() {\n  // useActionState 훅 호출, createPost 액션을 인자로 전달\n  const { state, pending } = useActionState(createPost);\n\n  return (\n    \u003cform action={createPost}\u003e\n      \u003clabel htmlFor=\"title\"\u003eTitle\u003c/label\u003e\n      \u003cinput type=\"text\" id=\"title\" name=\"title\" required /\u003e\n\n      \u003clabel htmlFor=\"content\"\u003eContent\u003c/label\u003e\n      \u003ctextarea id=\"content\" name=\"content\" required /\u003e\n\n      \u003cbutton disabled={pending}\u003eCreate Post\u003c/button\u003e\n\n      {/* 에러 메시지가 있다면 화면에 표시 */}\n      {state?.message \u0026\u0026 \u003cp style={{ color: \"red\" }}\u003e{state.message}\u003c/p\u003e}\n    \u003c/form\u003e\n  );\n}\n```\n\n- `useActionState(createPost)`를 호출하면 액션의 현재 상태(`state`)와 제출 진행 중 여부(`pending`)를 반환해줍니다.\n- `state.message`에 에러 메시지가 담겨 있다면, 이를 사용자에게 보여줄 수 있죠.\n- `button`은 제출하는 동안 중복 전송을 방지하기 위해 `disabled` 처리됩니다.\n\n---\n\n## Server Component에서 에러 핸들링\n\n서버 컴포넌트에서 데이터를 불러올 때도 에러 처리는 중요하죠! 거기서는 서버에서 받은 응답을 활용해 조건부 렌더링을 하거나, 필요시 리다이렉션을 할 수 있습니다.\n\n예를 들어:\n\n```jsx\nexport default async function Page() {\n  try {\n    const data = await fetchData(); // 서버에서 데이터 가져오기\n    return \u003cDisplayData data={data} /\u003e;\n  } catch (error) {\n    // 에러 발생 시 에러 메시지 또는 리다이렉션 처리\n    return \u003cp\u003e데이터를 불러오는 중 오류가 발생했습니다.\u003c/p\u003e;\n  }\n}\n```\n\n이처럼 서버 컴포넌트 내부에서 `try-catch` 문으로 에러를 잡아서 사용자에게 피드백을 줄 수 있습니다.\n\n---\n\n## 정리하자면\n\n- **useActionState** 훅을 활용하면 클라이언트 컴포넌트 내에서 액션 상태를 쉽게 관리하고, 에러 메시지를 화면에 표시할 수 있습니다.\n- 제출 버튼에 진행 상태를 반영해 사용자 경험도 개선할 수 있죠.\n- **서버 컴포넌트**에서는 데이터를 비동기로 가져올 때 에러를 잡아서 적절히 처리해야 하며, 이때 사용자에게 친절하게 에러를 알리는 UI를 만드는 게 중요합니다.\n\n---\n\n혹시 더 자세한 액션 상태 관리나 서버-클라이언트 간 에러 핸들링에 관해 궁금한 점이 있으면 언제든지 물어보세요! 여러분이 더 쉽게 React와 Next.js를 활용할 수 있도록 돕겠습니다 :)\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자, 이번에는 Next.js에서 데이터를 가져오고, 만약 데이터가 없다면 404 페이지를 띄우는 방법에 대해 이야기해볼게요.\n\n먼저, fetch API를 사용해서 데이터를 비동기로 가져오는 기본 예제부터 봅시다.\n\n```js\nexport default async function Page() {\n  const res = await fetch(`https://...`);\n  const data = await res.json();\n\n  if (!res.ok) {\n    return \"There was an error.\"; // 에러 발생 시 간단한 메시지 반환\n  }\n\n  return \"...\"; // 데이터를 성공적으로 받아오면 원하는 UI 반환\n}\n```\n\n여기서 핵심은 서버 API를 호출하고, 응답이 제대로 오지 않으면 에러 메시지를 보여주는 거예요. 그런데, 만약 해당 페이지나 데이터가 없을 때는 ‘404 페이지’를 보여주는 방법도 필요하겠죠?\n\nNext.js에서는 `notFound()` 함수를 이용해서 이런 상황을 처리할 수 있어요. 예를 들어, 블로그 포스트를 주소로 찾는 상황을 가정해보죠.\n\n```js\nimport { notFound } from \"next/navigation\";\nimport { getPostBySlug } from \"@/lib/posts\";\n\nexport default async function Page({ params }: { params: { slug: string } }) {\n  const { slug } = params;\n  const post = getPostBySlug(slug);\n\n  if (!post) {\n    notFound(); // 데이터가 없으면 404 페이지로 이동\n  }\n\n  return \u003cdiv\u003e{post.title}\u003c/div\u003e; // 포스트 타이틀 출력\n}\n```\n\n여기서 중요한 점 몇 가지 짚고 넘어가면:\n\n| 항목            | 설명                                                                                                                                         |\n| --------------- | -------------------------------------------------------------------------------------------------------------------------------------------- |\n| `notFound()`    | Next.js가 제공하는 내장 함수로, 호출 시 해당 페이지 대신 404 UI를 보여줘요. 그냥 반환하는 게 아니라 실제로 404 상태로 페이지가 렌더링됩니다. |\n| `getPostBySlug` | 여긴 예시로 작성한 함수인데, 실제로는 슬러그(게시물 주소)를 기준으로 데이터를 찾아오는 로직입니다. 만약 없으면 `undefined` 혹은 `null` 반환  |\n| `params`        | 동적 라우팅에서 URL 파라미터를 받을 때 사용해요. 예를 들어 `/posts/hello-world` 라면 slug는 `hello-world` 가 되겠죠                          |\n\n추가로, `not-found.js` 또는 `not-found.tsx` 파일을 프로젝트에 만들어서 404 페이지의 UI를 커스터마이징 할 수도 있어요.\n\n```jsx\nexport default function NotFound() {\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003e페이지를 찾을 수 없어요 ㅠㅠ\u003c/h1\u003e\n      \u003cp\u003e요청하신 페이지가 존재하지 않거나 삭제되었습니다.\u003c/p\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n이렇게 하면 프로젝트 전반에서 공통으로 쓰이는 404 페이지가 알아서 뜹니다.\n\n정리해보면, 데이터가 없거나 잘못된 URL을 요청했을 때 사용자에게 잘못된 접근임을 알려주는 방법으로 `notFound()` 호출과 맞춤형 404 페이지를 함께 사용하면 훨씬 깔끔한 사용자 경험을 만들 수 있다는 점! 꼭 기억하세요~\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```jsx\nexport default function NotFound() {\n  return \u003cdiv\u003e404 - Page Not Found\u003c/div\u003e;\n}\n```\n\n## 처리하지 않은 예외(uncaught exceptions) 다루기\n\n처리하지 않은 예외란, 애플리케이션의 정상적인 흐름에서는 발생하지 말아야 할 예상치 못한 오류를 뜻해요. 이런 예외들은 보통 에러를 던져서(error throwing) 처리하는데, 이 에러를 '에러 바운더리(Error Boundary)'에서 잡아내서 적절히 대응해주는 방식이 일반적입니다.\n\n에러 바운더리는 리액트 컴포넌트에서 흔히 사용되는데, UI가 깨지지 않고 사용자에게 친절한 에러 메시지를 보여주거나, 로그를 남기거나, 대체 UI로 전환하는 데 활용할 수 있답니다.\n\n### 중첩된 에러 바운더리(Nested error boundaries)\n\n에러 바운더리를 한 군데만 두는 것보다, 애플리케이션 구조에 따라 여러 단계로 중첩시켜서 중요한 UI 부분별로 별도의 에러 처리 영역을 만드는 게 좋아요. 예를 들어, 페이지 전체를 감싸는 바운더리가 있고, 그 안에 각각의 위젯이나 컴포넌트 단위로 또 다른 바운더리가 존재하면, 특정 위젯에서 문제가 생겨도 페이지 전체가 깨지지 않고 해당 위젯 부분만 에러 UI로 교체할 수 있거든요.\n\n이렇게 하면 사용자 경험도 개선되고, 디버깅할 때도 어떤 컴포넌트에서 문제가 발생했는지를 좀 더 명확히 파악할 수 있습니다.\n\n---\n\n참고로, 리액트에서 에러 바운더리를 구현할 때는 다음과 같은 라이프사이클 메서드를 활용해요:\n\n- `static getDerivedStateFromError(error)`: 에러가 발생했을 때 상태를 업데이트하여 대체 UI를 렌더할 준비를 함\n- `componentDidCatch(error, info)`: 에러 로깅 등 부가 작업 수행\n\n그리고 함수형 컴포넌트만 쓴다면 `Error Boundary`는 아직 클래스 컴포넌트로 작성해야 한다는 점 기억하세요!  \n리액트가 앞으로 훅 기반 에러 바운더리를 지원하면 훨씬 편리해지겠죠?\n\n필요하면 에러 바운더리 예제도 공유해 드릴게요!\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서는 에러 바운더리(Error Boundaries)를 이용해 예기치 못한 에러를 잡아냅니다. 에러 바운더리는 자식 컴포넌트에서 발생한 오류를 잡아내서, 부러진 컴포넌트 트리 대신에 대체 UI(일종의 에러 화면)를 보여주게 해주죠.\n\n이걸 구현하려면, 라우트 세그먼트(route segment) 안에 `error.js` 파일을 만들고 React 컴포넌트를 내보내면 됩니다. 예시는 아래와 같아요:\n\n```js\n'use client' // 에러 바운더리는 클라이언트 컴포넌트여야 합니다\n\nimport { useEffect } from 'react'\n\nexport default function Error({\n  error,\n  reset,\n}: {\n  error: Error \u0026 { digest?: string }\n  reset: () =\u003e void\n}) {\n  useEffect(() =\u003e {\n    // 에러 리포팅 서비스에 로그를 보낸다고 생각해보세요\n    console.error(error)\n  }, [error])\n\n  return (\n    \u003cdiv\u003e\n      \u003ch2\u003e문제가 발생했어요!\u003c/h2\u003e\n      \u003cbutton\n        onClick={\n          // 다시 렌더링 시도해서 복구를 노립니다\n          () =\u003e reset()\n        }\n      \u003e\n        다시 시도\n      \u003c/button\u003e\n    \u003c/div\u003e\n  )\n}\n```\n\n여기서 핵심은 `reset` 함수예요. 이 버튼을 누르면 해당 세그먼트를 다시 렌더링하면서 문제가 해결됐는지 재시도합니다.\n\n그리고 재미있는 점! 에러는 가장 가까운 상위 에러 바운더리로 올라가서 처리돼요. 덕분에, 라우트 트리 계층별로 `error.js`를 여러 개 둬서 세밀하게 에러 처리를 할 수 있습니다. 예를 들어, 특정 페이지에서만 보여줄 맞춤형 에러 화면도 가능하다는 뜻이죠.\n\n---\n\n추가로 알려드리자면, Next.js에서는 페이지나 레이아웃 단위로 에러를 다룰 수 있어서 사용자 경험을 더 세련되게 만드는 데 큰 도움이 됩니당. 단, 에러 바운더리는 무조건 클라이언트 컴포넌트여야 하는 점은 꼭 기억해주세요!\n\n꼭 한 가지 깜빡하지 말아야 할 팁은, 에러 바운더리 안에서도 에러는 다시 던져지지 않으니, 중요한 로그나 오류 추적(예: Sentry 같은 도구 활용)은 `useEffect` 같은 곳에서 해주는 게 베스트입니다.\n\n필요할 때마다 `error.js` 만들어서 우아한 에러 처리를 해보세요! 사용자도, 개발자도 모두 행복해질 거예요 :)\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/TIL/assets/img/2025-04-22-Howtohandleerrors_0.png\" /\u003e\n\n### 전역 에러 처리하기 (Global errors)\n\n에러 처리하면 보통 각 컴포넌트 단위에서 하게 되지만, root 레이아웃 단계에서 전역적으로 에러를 잡고 싶을 때가 있어요. 이런 경우에는 `app` 루트 디렉터리에 `global-error.js` 파일을 만들어서 처리할 수 있습니다. 특히 다국어 지원 같은 국제화(i18n)를 적용해도 똑같이 쓸 수 있다는 점도 참고하세요.\n\n이 전역 에러 UI 컴포넌트는 root 레이아웃이나 템플릿을 완전히 대체하는 역할을 하기 때문에, 직접 `html`과 `body` 태그를 포함해야 해요. 없으면 브라우저가 제대로 렌더링하지 않기 때문에 꼭 넣어줘야 합니다.\n\n```js\n'use client' // 에러 바운더리는 클라이언트 컴포넌트여야 합니다\n\nexport default function GlobalError({\n  error,\n  reset,\n}: {\n  error: Error \u0026 { digest?: string }\n  reset: () =\u003e void\n}) {\n  return (\n    \u003chtml\u003e\n      \u003cbody\u003e\n        \u003ch2\u003e문제가 발생했어요!\u003c/h2\u003e\n        \u003cbutton onClick={() =\u003e reset()}\u003e다시 시도\u003c/button\u003e\n      \u003c/body\u003e\n    \u003c/html\u003e\n  )\n}\n```\n\n### 핵심 포인트\n\n- `'use client'` 선언으로 클라이언트 컴포넌트로 만들어야 에러 경계(Error Boundaries)가 정상 동작해요.\n- 에러를 화면에 보여주고, 사용자가 다시 시도할 수 있도록 reset 함수도 전달받아 꼭 활용하세요.\n- 전역 에러 UI는 root 레이아웃을 완전히 대체하므로 `html, body` 태그를 반드시 포함!\n\n### 살짝 더!\n\n만약 이 전역 에러 화면에 스타일을 입히고 싶다면, 전역 CSS를 불러오거나 `style` 태그를 넣는 방법이 있어요. 그리고 모던 웹 앱에서는 에러가 발생했을 때 단순히 메시지 보여주는 것 말고, 사용자 피드백을 받아 서버로 리포트 하거나, 자동 리프레시 기능을 추가하는 것도 생각해볼 만합니다.\n\n즉, 전역 에러 처리는 앱 안정성을 향상시키는 훌륭한 도구니 적극 활용해보세요!\n","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":12},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch1\u003e에러 처리하는 법\u003c/h1\u003e\n\u003cp\u003e에러는 크게 두 가지로 나눌 수 있어요: 예상 가능한 에러와 잡히지 않은 예외(uncaught exceptions)죠. 이번 글에서는 Next.js 앱에서 이런 에러들을 어떻게 다룰 수 있는지 쉽게 알려드릴게요.\u003c/p\u003e\n\u003ch2\u003e예상 가능한 에러 처리하기\u003c/h2\u003e\n\u003cp\u003e예상 가능한 에러는 앱이 정상적으로 작동하는 중에 발생할 수 있는 에러예요. 예를 들어 서버 쪽 폼 검증에서 실패할 때나, API 요청이 실패하는 경우죠. 이런 에러들은 명확하게 처리해서 클라이언트한테 적절하게 전달해줘야 해요.\u003c/p\u003e\n\u003cp\u003e사실 이런 에러들은 사용자 경험에도 영향을 많이 주기 때문에, 단순히 ‘문제가 발생했습니다’라고 하는 것보단, 어떤 문제가 있는지 구체적으로 알려주는 게 중요해요. 예를 들어, 폼에서 이메일 형식이 맞지 않으면 \"이메일 형식이 올바르지 않습니다\"라고 바로 알려주면 사용자가 수정할 수 있잖아요?\u003c/p\u003e\n\u003cp\u003eNext.js에서는 서버 사이드 코드에서 이런 에러들을 try-catch 문으로 잡아서, 적절한 HTTP 상태 코드와 메시지로 응답을 줄 수 있어요. 클라이언트 쪽에서는 그 응답을 받아서 UI에 에러 메시지를 띄우거나, 특정 행동을 유도하도록 하면 됩니다.\u003c/p\u003e\n\u003cp\u003e혹시 에러를 다루는 게 처음이라면, ‘에러 핸들링 레이어’를 따로 만들어서 코드를 깔끔하게 관리하는 것도 추천해요. 그래야 에러 처리 로직이 여러 군데 흩어지지 않고, 수정도 편리해요.\u003c/p\u003e\n\u003cp\u003e다음에는 잡히지 않은 예외, 즉 예기치 않은 오류가 발생했을 때 어떻게 대처하는지도 알려드릴게요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch3\u003e서버 함수에서 예상 에러 처리하기\u003c/h3\u003e\n\u003cp\u003e서버 함수(Server Functions)를 작성할 때, 예상되는 에러를 다루는 방법에 대해 이야기해볼게요. 보통 자바스크립트에서 에러가 발생하면 try/catch로 잡거나 \u003ccode\u003ethrow\u003c/code\u003e를 해서 에러를 던지죠? 그런데 서버 함수에서는 이런 방식보다는 **예상 가능한 에러를 반환값(return value)**으로 모델링하는 게 좋아요.\u003c/p\u003e\n\u003cp\u003e예를 들어, 아래와 같이 \u003ccode\u003ecreatePost\u003c/code\u003e라는 서버 함수를 만들었을 때, API 호출이 실패하는 경우를 생각해볼게요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e\"use server\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecreatePost\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eprevState: any, formData: FormData\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e title = formData.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"title\"\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e content = formData.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"content\"\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e res = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"https://api.vercel.app/posts\"\u003c/span\u003e, {\n    \u003cspan class=\"hljs-attr\"\u003emethod\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"POST\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: { title, content },\n  });\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e json = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e res.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e();\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!res.\u003cspan class=\"hljs-property\"\u003eok\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e { \u003cspan class=\"hljs-attr\"\u003emessage\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Failed to create post\"\u003c/span\u003e };\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 실패하면 그냥 \u003ccode\u003ethrow\u003c/code\u003e 대신 \u003ccode\u003e{ message: 'Failed to create post' }\u003c/code\u003e라는 객체를 반환하고 있죠? 이렇게 하면 클라이언트 쪽에서 이 반환값을 이용해 에러 메시지를 쉽게 표시할 수 있어요.\u003c/p\u003e\n\u003ch4\u003e팁!\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e서버에서 에러를 \u003ccode\u003ethrow\u003c/code\u003e하면 클라이언트 입장에선 뭘 잘못했는지 알기 어려울 수 있어요. 그래서 예상 가능한 에러들은 명확하게 데이터로 내려주는 게 UX에도 더 좋아요.\u003c/li\u003e\n\u003cli\u003e반대로, 정말 예상하지 못한 시스템 에러는 그대로 \u003ccode\u003ethrow\u003c/code\u003e해서 호출 스택에서 잡히게 하는 게 관리하기 편합니다.\u003c/li\u003e\n\u003cli\u003e그리고, \u003ccode\u003euseActionState\u003c/code\u003e 훅을 사용하면 이런 반환값을 쉽게 받아서 처리할 수 있으니 한번 써보세요!\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이런 스타일은 점점 더 많은 React 서버 컴포넌트 기반 환경에서 권장되는 패턴이니, 앞으로 서버 함수 작성할 때 참고하면 좋아요.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이번 시간에는 React의 \u003ccode\u003euseActionState\u003c/code\u003e 훅을 이용해서 폼 제출 시 발생할 수 있는 에러 메시지를 화면에 표시하는 방법을 함께 알아보겠습니다.\u003c/p\u003e\n\u003cp\u003e기본적으로 \u003ccode\u003euseActionState\u003c/code\u003e는 액션(action)의 상태를 추적할 수 있도록 도와줘서, 성공 여부나 에러 발생 시 상태를 쉽게 관리할 수 있답니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003e예제 코드 살펴보기\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-string\"\u003e\"use client\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { useActionState } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"react\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { createPost } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"@/app/actions\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e initialState = {\n  \u003cspan class=\"hljs-attr\"\u003emessage\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e,\n};\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eForm\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// useActionState 훅 호출, createPost 액션을 인자로 전달\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { state, pending } = \u003cspan class=\"hljs-title function_\"\u003euseActionState\u003c/span\u003e(createPost);\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eform\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eaction\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{createPost}\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003elabel\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ehtmlFor\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"title\"\u003c/span\u003e\u003e\u003c/span\u003eTitle\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003elabel\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003einput\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"text\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"title\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"title\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003erequired\u003c/span\u003e /\u003e\u003c/span\u003e\n\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003elabel\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ehtmlFor\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"content\"\u003c/span\u003e\u003e\u003c/span\u003eContent\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003elabel\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003etextarea\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"content\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"content\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003erequired\u003c/span\u003e /\u003e\u003c/span\u003e\n\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003edisabled\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{pending}\u003c/span\u003e\u003e\u003c/span\u003eCreate Post\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u003e\u003c/span\u003e\n\n      {/* 에러 메시지가 있다면 화면에 표시 */}\n      {state?.message \u0026#x26;\u0026#x26; \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{{\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ecolor:\u003c/span\u003e \"\u003cspan class=\"hljs-attr\"\u003ered\u003c/span\u003e\" }}\u003e\u003c/span\u003e{state.message}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e}\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eform\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003euseActionState(createPost)\u003c/code\u003e를 호출하면 액션의 현재 상태(\u003ccode\u003estate\u003c/code\u003e)와 제출 진행 중 여부(\u003ccode\u003epending\u003c/code\u003e)를 반환해줍니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003estate.message\u003c/code\u003e에 에러 메시지가 담겨 있다면, 이를 사용자에게 보여줄 수 있죠.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ebutton\u003c/code\u003e은 제출하는 동안 중복 전송을 방지하기 위해 \u003ccode\u003edisabled\u003c/code\u003e 처리됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2\u003eServer Component에서 에러 핸들링\u003c/h2\u003e\n\u003cp\u003e서버 컴포넌트에서 데이터를 불러올 때도 에러 처리는 중요하죠! 거기서는 서버에서 받은 응답을 활용해 조건부 렌더링을 하거나, 필요시 리다이렉션을 할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e예를 들어:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e data = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetchData\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// 서버에서 데이터 가져오기\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eDisplayData\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{data}\u003c/span\u003e /\u003e\u003c/span\u003e\u003c/span\u003e;\n  } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (error) {\n    \u003cspan class=\"hljs-comment\"\u003e// 에러 발생 시 에러 메시지 또는 리다이렉션 처리\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e데이터를 불러오는 중 오류가 발생했습니다.\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이처럼 서버 컴포넌트 내부에서 \u003ccode\u003etry-catch\u003c/code\u003e 문으로 에러를 잡아서 사용자에게 피드백을 줄 수 있습니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003e정리하자면\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003euseActionState\u003c/strong\u003e 훅을 활용하면 클라이언트 컴포넌트 내에서 액션 상태를 쉽게 관리하고, 에러 메시지를 화면에 표시할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e제출 버튼에 진행 상태를 반영해 사용자 경험도 개선할 수 있죠.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e서버 컴포넌트\u003c/strong\u003e에서는 데이터를 비동기로 가져올 때 에러를 잡아서 적절히 처리해야 하며, 이때 사용자에게 친절하게 에러를 알리는 UI를 만드는 게 중요합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e혹시 더 자세한 액션 상태 관리나 서버-클라이언트 간 에러 핸들링에 관해 궁금한 점이 있으면 언제든지 물어보세요! 여러분이 더 쉽게 React와 Next.js를 활용할 수 있도록 돕겠습니다 :)\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e자, 이번에는 Next.js에서 데이터를 가져오고, 만약 데이터가 없다면 404 페이지를 띄우는 방법에 대해 이야기해볼게요.\u003c/p\u003e\n\u003cp\u003e먼저, fetch API를 사용해서 데이터를 비동기로 가져오는 기본 예제부터 봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e res = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`https://...`\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e data = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e res.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e();\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!res.\u003cspan class=\"hljs-property\"\u003eok\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"There was an error.\"\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 에러 발생 시 간단한 메시지 반환\u003c/span\u003e\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 데이터를 성공적으로 받아오면 원하는 UI 반환\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 핵심은 서버 API를 호출하고, 응답이 제대로 오지 않으면 에러 메시지를 보여주는 거예요. 그런데, 만약 해당 페이지나 데이터가 없을 때는 ‘404 페이지’를 보여주는 방법도 필요하겠죠?\u003c/p\u003e\n\u003cp\u003eNext.js에서는 \u003ccode\u003enotFound()\u003c/code\u003e 함수를 이용해서 이런 상황을 처리할 수 있어요. 예를 들어, 블로그 포스트를 주소로 찾는 상황을 가정해보죠.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { notFound } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"next/navigation\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { getPostBySlug } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"@/lib/posts\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{ params }: { params: { slug: string } }\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { slug } = params;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e post = \u003cspan class=\"hljs-title function_\"\u003egetPostBySlug\u003c/span\u003e(slug);\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!post) {\n    \u003cspan class=\"hljs-title function_\"\u003enotFound\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// 데이터가 없으면 404 페이지로 이동\u003c/span\u003e\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e{post.title}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 포스트 타이틀 출력\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 중요한 점 몇 가지 짚고 넘어가면:\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e항목\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003enotFound()\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eNext.js가 제공하는 내장 함수로, 호출 시 해당 페이지 대신 404 UI를 보여줘요. 그냥 반환하는 게 아니라 실제로 404 상태로 페이지가 렌더링됩니다.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003egetPostBySlug\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e여긴 예시로 작성한 함수인데, 실제로는 슬러그(게시물 주소)를 기준으로 데이터를 찾아오는 로직입니다. 만약 없으면 \u003ccode\u003eundefined\u003c/code\u003e 혹은 \u003ccode\u003enull\u003c/code\u003e 반환\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eparams\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e동적 라우팅에서 URL 파라미터를 받을 때 사용해요. 예를 들어 \u003ccode\u003e/posts/hello-world\u003c/code\u003e 라면 slug는 \u003ccode\u003ehello-world\u003c/code\u003e 가 되겠죠\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e추가로, \u003ccode\u003enot-found.js\u003c/code\u003e 또는 \u003ccode\u003enot-found.tsx\u003c/code\u003e 파일을 프로젝트에 만들어서 404 페이지의 UI를 커스터마이징 할 수도 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eNotFound\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e페이지를 찾을 수 없어요 ㅠㅠ\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e요청하신 페이지가 존재하지 않거나 삭제되었습니다.\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 하면 프로젝트 전반에서 공통으로 쓰이는 404 페이지가 알아서 뜹니다.\u003c/p\u003e\n\u003cp\u003e정리해보면, 데이터가 없거나 잘못된 URL을 요청했을 때 사용자에게 잘못된 접근임을 알려주는 방법으로 \u003ccode\u003enotFound()\u003c/code\u003e 호출과 맞춤형 404 페이지를 함께 사용하면 훨씬 깔끔한 사용자 경험을 만들 수 있다는 점! 꼭 기억하세요~\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eNotFound\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e404 - Page Not Found\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e처리하지 않은 예외(uncaught exceptions) 다루기\u003c/h2\u003e\n\u003cp\u003e처리하지 않은 예외란, 애플리케이션의 정상적인 흐름에서는 발생하지 말아야 할 예상치 못한 오류를 뜻해요. 이런 예외들은 보통 에러를 던져서(error throwing) 처리하는데, 이 에러를 '에러 바운더리(Error Boundary)'에서 잡아내서 적절히 대응해주는 방식이 일반적입니다.\u003c/p\u003e\n\u003cp\u003e에러 바운더리는 리액트 컴포넌트에서 흔히 사용되는데, UI가 깨지지 않고 사용자에게 친절한 에러 메시지를 보여주거나, 로그를 남기거나, 대체 UI로 전환하는 데 활용할 수 있답니다.\u003c/p\u003e\n\u003ch3\u003e중첩된 에러 바운더리(Nested error boundaries)\u003c/h3\u003e\n\u003cp\u003e에러 바운더리를 한 군데만 두는 것보다, 애플리케이션 구조에 따라 여러 단계로 중첩시켜서 중요한 UI 부분별로 별도의 에러 처리 영역을 만드는 게 좋아요. 예를 들어, 페이지 전체를 감싸는 바운더리가 있고, 그 안에 각각의 위젯이나 컴포넌트 단위로 또 다른 바운더리가 존재하면, 특정 위젯에서 문제가 생겨도 페이지 전체가 깨지지 않고 해당 위젯 부분만 에러 UI로 교체할 수 있거든요.\u003c/p\u003e\n\u003cp\u003e이렇게 하면 사용자 경험도 개선되고, 디버깅할 때도 어떤 컴포넌트에서 문제가 발생했는지를 좀 더 명확히 파악할 수 있습니다.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e참고로, 리액트에서 에러 바운더리를 구현할 때는 다음과 같은 라이프사이클 메서드를 활용해요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003estatic getDerivedStateFromError(error)\u003c/code\u003e: 에러가 발생했을 때 상태를 업데이트하여 대체 UI를 렌더할 준비를 함\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ecomponentDidCatch(error, info)\u003c/code\u003e: 에러 로깅 등 부가 작업 수행\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e그리고 함수형 컴포넌트만 쓴다면 \u003ccode\u003eError Boundary\u003c/code\u003e는 아직 클래스 컴포넌트로 작성해야 한다는 점 기억하세요!\u003cbr\u003e\n리액트가 앞으로 훅 기반 에러 바운더리를 지원하면 훨씬 편리해지겠죠?\u003c/p\u003e\n\u003cp\u003e필요하면 에러 바운더리 예제도 공유해 드릴게요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eNext.js에서는 에러 바운더리(Error Boundaries)를 이용해 예기치 못한 에러를 잡아냅니다. 에러 바운더리는 자식 컴포넌트에서 발생한 오류를 잡아내서, 부러진 컴포넌트 트리 대신에 대체 UI(일종의 에러 화면)를 보여주게 해주죠.\u003c/p\u003e\n\u003cp\u003e이걸 구현하려면, 라우트 세그먼트(route segment) 안에 \u003ccode\u003eerror.js\u003c/code\u003e 파일을 만들고 React 컴포넌트를 내보내면 됩니다. 예시는 아래와 같아요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e'use client'\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e// 에러 바운더리는 클라이언트 컴포넌트여야 합니다\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { useEffect } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eError\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{\n  error,\n  reset,\n}: {\n  error: \u003cspan class=\"hljs-built_in\"\u003eError\u003c/span\u003e \u0026#x26; { digest?: string }\n  reset: () =\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e\n}\u003c/span\u003e) {\n  \u003cspan class=\"hljs-title function_\"\u003euseEffect\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// 에러 리포팅 서비스에 로그를 보낸다고 생각해보세요\u003c/span\u003e\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eerror\u003c/span\u003e(error)\n  }, [error])\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eh2\u003c/span\u003e\u003e\u003c/span\u003e문제가 발생했어요!\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eh2\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003eonClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{\u003c/span\u003e\n          // \u003cspan class=\"hljs-attr\"\u003e다시\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e렌더링\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e시도해서\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e복구를\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e노립니다\u003c/span\u003e\n          () =\u003e\u003c/span\u003e reset()\n        }\n      \u003e\n        다시 시도\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 핵심은 \u003ccode\u003ereset\u003c/code\u003e 함수예요. 이 버튼을 누르면 해당 세그먼트를 다시 렌더링하면서 문제가 해결됐는지 재시도합니다.\u003c/p\u003e\n\u003cp\u003e그리고 재미있는 점! 에러는 가장 가까운 상위 에러 바운더리로 올라가서 처리돼요. 덕분에, 라우트 트리 계층별로 \u003ccode\u003eerror.js\u003c/code\u003e를 여러 개 둬서 세밀하게 에러 처리를 할 수 있습니다. 예를 들어, 특정 페이지에서만 보여줄 맞춤형 에러 화면도 가능하다는 뜻이죠.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e추가로 알려드리자면, Next.js에서는 페이지나 레이아웃 단위로 에러를 다룰 수 있어서 사용자 경험을 더 세련되게 만드는 데 큰 도움이 됩니당. 단, 에러 바운더리는 무조건 클라이언트 컴포넌트여야 하는 점은 꼭 기억해주세요!\u003c/p\u003e\n\u003cp\u003e꼭 한 가지 깜빡하지 말아야 할 팁은, 에러 바운더리 안에서도 에러는 다시 던져지지 않으니, 중요한 로그나 오류 추적(예: Sentry 같은 도구 활용)은 \u003ccode\u003euseEffect\u003c/code\u003e 같은 곳에서 해주는 게 베스트입니다.\u003c/p\u003e\n\u003cp\u003e필요할 때마다 \u003ccode\u003eerror.js\u003c/code\u003e 만들어서 우아한 에러 처리를 해보세요! 사용자도, 개발자도 모두 행복해질 거예요 :)\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cimg src=\"/TIL/assets/img/2025-04-22-Howtohandleerrors_0.png\"\u003e\n\u003ch3\u003e전역 에러 처리하기 (Global errors)\u003c/h3\u003e\n\u003cp\u003e에러 처리하면 보통 각 컴포넌트 단위에서 하게 되지만, root 레이아웃 단계에서 전역적으로 에러를 잡고 싶을 때가 있어요. 이런 경우에는 \u003ccode\u003eapp\u003c/code\u003e 루트 디렉터리에 \u003ccode\u003eglobal-error.js\u003c/code\u003e 파일을 만들어서 처리할 수 있습니다. 특히 다국어 지원 같은 국제화(i18n)를 적용해도 똑같이 쓸 수 있다는 점도 참고하세요.\u003c/p\u003e\n\u003cp\u003e이 전역 에러 UI 컴포넌트는 root 레이아웃이나 템플릿을 완전히 대체하는 역할을 하기 때문에, 직접 \u003ccode\u003ehtml\u003c/code\u003e과 \u003ccode\u003ebody\u003c/code\u003e 태그를 포함해야 해요. 없으면 브라우저가 제대로 렌더링하지 않기 때문에 꼭 넣어줘야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e'use client'\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e// 에러 바운더리는 클라이언트 컴포넌트여야 합니다\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eGlobalError\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{\n  error,\n  reset,\n}: {\n  error: \u003cspan class=\"hljs-built_in\"\u003eError\u003c/span\u003e \u0026#x26; { digest?: string }\n  reset: () =\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e\n}\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ehtml\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebody\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eh2\u003c/span\u003e\u003e\u003c/span\u003e문제가 발생했어요!\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eh2\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{()\u003c/span\u003e =\u003e\u003c/span\u003e reset()}\u003e다시 시도\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebody\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ehtml\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e핵심 포인트\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e'use client'\u003c/code\u003e 선언으로 클라이언트 컴포넌트로 만들어야 에러 경계(Error Boundaries)가 정상 동작해요.\u003c/li\u003e\n\u003cli\u003e에러를 화면에 보여주고, 사용자가 다시 시도할 수 있도록 reset 함수도 전달받아 꼭 활용하세요.\u003c/li\u003e\n\u003cli\u003e전역 에러 UI는 root 레이아웃을 완전히 대체하므로 \u003ccode\u003ehtml, body\u003c/code\u003e 태그를 반드시 포함!\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e살짝 더!\u003c/h3\u003e\n\u003cp\u003e만약 이 전역 에러 화면에 스타일을 입히고 싶다면, 전역 CSS를 불러오거나 \u003ccode\u003estyle\u003c/code\u003e 태그를 넣는 방법이 있어요. 그리고 모던 웹 앱에서는 에러가 발생했을 때 단순히 메시지 보여주는 것 말고, 사용자 피드백을 받아 서버로 리포트 하거나, 자동 리프레시 기능을 추가하는 것도 생각해볼 만합니다.\u003c/p\u003e\n\u003cp\u003e즉, 전역 에러 처리는 앱 안정성을 향상시키는 훌륭한 도구니 적극 활용해보세요!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2025-04-22-Howtohandleerrors"},"buildId":"X4OrKfmLtU3-3BijwfHe6","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>