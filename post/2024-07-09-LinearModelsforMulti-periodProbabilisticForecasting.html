<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>다중 기간 확률 예측을 위한 선형 모델 이해하기 | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="다중 기간 확률 예측을 위한 선형 모델 이해하기 | TIL" data-gatsby-head="true"/><meta property="og:title" content="다중 기간 확률 예측을 위한 선형 모델 이해하기 | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting" data-gatsby-head="true"/><meta name="twitter:title" content="다중 기간 확률 예측을 위한 선형 모델 이해하기 | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2024-07-09 19:30" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/TIL/_next/static/chunks/463-925361deb4cec4b1.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/post/%5Bslug%5D-9d7ebbd29b9e08ce.js" defer=""></script><script src="/TIL/_next/static/QAkYP0lvl03W-5CKD69kb/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/QAkYP0lvl03W-5CKD69kb/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">다중 기간 확률 예측을 위한 선형 모델 이해하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="다중 기간 확률 예측을 위한 선형 모델 이해하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jul 9, 2024</span><span class="posts_reading_time__f7YPP">21<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<img src="/TIL/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_0.png">
<p>샘플 eBook 장(chapters) (무료): <a href="https://github.com/dataman-git/modern-time-series/blob/main/20240522beauty_TOC.pdf" rel="nofollow" target="_blank">여기</a></p>
<p>Teachable.com에서 eBook: $22.50 <a href="https://drdataman.teachable.com/p/home" rel="nofollow" target="_blank">여기</a></p>
<p>Amazon.com에서 인쇄본: $65 <a href="https://a.co/d/25FVsMx" rel="nofollow" target="_blank">여기</a></p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>선형 회귀 모델은 시계열에 대한 점 추정을 당연히 할 수 있습니다. 선형 회귀 모델은 빠르고 해석하기 쉽며 쉽게 배포할 수 있는 장점이 있습니다. 많은 기관에서 여전히 좋은 선택입니다. 선형 회귀의 일반적인 유형은 자기회귀 모델로, 9장인 "자동 ARIMA"에서 나와 있습니다. 그러나 많은 실제 사용 사례에서는 다음 두 가지를 제공해야 합니다: (1) 확률적 예측(또는 예측 구간 또는 예측 불확실성이라고도 함)과 (2) 다기간 예측. 선형 회귀를 어떻게 확장하여 이 두 결과를 수행할 수 있을까요?</p>
<p>(1)에 대한 해결책은 분위 회귀를 사용하여 예측 불확실성을 제공하는 것입니다. (A) 그림은 분위 예측을 보여줍니다. 미래의 시간 t에 대해 10번째, 50번째 및 90번째 백분위수를 기반으로 예측 샘플을 반환합니다. 필요하다면 더 많은 분위 샘플을 생성할 수 있습니다. 이에 대해서는 "6장: 예측 불확실성을 위한 분위 회귀"를 참조해주세요.</p>
<p><img src="/TIL/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_1.png" alt="quantile forecasts"></p>
<p>(2)는 어떻게 해결할까요? 선형 회귀는 점 예측을 생성하지만, 다기간 예측을 어떻게 만들까요? 한 가지 방법은 동일한 모델을 재귀적으로 사용하는 것일 수 있습니다. 한 기간 예측을 모델로부터 얻어 다음 기간을 예측하는 데 입력으로 사용합니다. 그런 다음 두 번째 기간을 예측하기 위해 두 번째 기간의 예측을 입력으로 사용합니다. 이전 기간의 예측을 사용하여 모든 기간을 반복할 수 있습니다. 이것이 재귀 예측 또는 반복적 예측 전략이 하는 일입니다. (B) 그림은 모델이 먼저 yt+1을 생성하고, 그런 다음 같은 모델이 yt+1을 사용하여 yt+2를 생성하는 것을 보여줍니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>아래는 마크다운 형식의 테이블입니다.</p>
<p>또 다른 전략은 n개의 별도 모델을 구축하는 것입니다. 각 모델은 n개의 기간에 대한 예측을 생성합니다. 10개 기간을 예측하려면 10개의 모델을 교육하고 각 모델을 특정 단계를 예측하도록 설정합니다. 이를 직접 예측 전략이라고 합니다. 이 전략은 그림 (C)에 나와 있습니다. 두 가지 전략을 학습하려면 13장인 "다중 기간 시계열 예측을 위한 두 가지 주요 전략"으로 이동하세요.</p>
<p>선형 회귀를 단변량 시계열로 제한할 이유는 명백히 없습니다. 다른 변수인 공변량이라고 불리는 변수도 추가할 수 있습니다. 그림 (D)에는 다른 공변량 xt와 과거 p개 항목이 포함되어 있습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/TIL/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_4.png" alt="그림"></p>
<p>선형 모델은 Figure (A)에 표시된 분위수 예측 및 Figure (D)에 표시된 직접 예측을 수행해야 할 때 복잡해 보입니다. 다행히 Python 시계열 라이브러리인 Darts에서 이러한 프로세스가 구현되었습니다. Darts 라이브러리는 "scikit-learn" 함수를 많이 포함하고 있어 "scikit-learn"의 기능을 활용할 수 있습니다. 이 중에는 sklearn의 분위수 회귀기능도 포함되어 있습니다. 따라서 우리는 Darts 라이브러리에 초점을 맞출 수 있습니다.</p>
<p>우리는 다음 단계로 진행할 것입니다:</p>
<ul>
<li>단변량 데이터로 시작하기</li>
<li>다른 공변럇값 포함하기, 그리고</li>
<li>분위수 예측 포함하기.</li>
</ul>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Darts 라이브러리는 시계열 데이터를 위한 특별한 데이터 형식을 가지고 있어요. 10장: 시계열 데이터 형식을 쉽게 다루는 내용은 Darts의 데이터 구조에 대해 소개하고 있어요. 이 장의 파이썬 노트북은 이 Github 링크를 통해 확인할 수 있어요.</p>
<p>우선 데이터를 불러와 볼까요?</p>
<p>데이터 불러오기</p>
<p>이번에는 Kaggle.com의 Walmart 데이터셋을 사용해 보겠어요. 이 데이터셋은 2010년 2월 5일부터 2012년 11월 1일까지의 매장 주간 매출 데이터를 포함하고 있어요:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>날짜 — 판매 주의 주</li>
<li>상점 — 상점 번호</li>
<li>주간 판매 — 상점의 매출</li>
<li>공휴일 플래그 — 특별 공휴일 주 인지 여부 1 — 공휴일 주 0 — 비공휴일 주</li>
<li>온도 — 판매일의 온도</li>
<li>연료 가격 — 지역의 연료 비용</li>
</ul>
<p>또한 소매 매출에 영향을 미칠 수 있는 두 가지 거시 경제 지표가 있습니다: 소비자물가지수 및 실업률. 데이터 집합은 먼저 Pandas 데이터 프레임으로로드됩니다.</p>
<pre><code class="hljs language-js">%matplotlib inline
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt

<span class="hljs-keyword">from</span> google.<span class="hljs-property">colab</span> <span class="hljs-keyword">import</span> drive
drive.<span class="hljs-title function_">mount</span>(<span class="hljs-string">'/content/gdrive'</span>)
path = <span class="hljs-string">'/content/gdrive/My Drive/data/time_series'</span>
data = pd.<span class="hljs-title function_">read_csv</span>(path + <span class="hljs-string">'/walmart.csv'</span>, delimiter=<span class="hljs-string">","</span>)
data[<span class="hljs-string">'ds'</span>] = pd.<span class="hljs-title function_">to_datetime</span>(data[<span class="hljs-string">'Date'</span>], format=<span class="hljs-string">'%d-%m-%Y'</span>)
data.<span class="hljs-property">index</span> = data[<span class="hljs-string">'ds'</span>]
data = data.<span class="hljs-title function_">drop</span>(<span class="hljs-string">'Date'</span>, axis=<span class="hljs-number">1</span>)
data.<span class="hljs-title function_">head</span>()
</code></pre>
<img src="/TIL/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_5.png">
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>데이터 준비를 위한 Darts의 주요 Python 클래스는 TimeSeries 클래스입니다. Darts는 값들을 다차원 배열로 저장하는데, 이 배열들은 다음과 같은 형태를 가지고 있어요 (시간, 차원, 샘플):</p>
<ul>
<li>시간: 예를 들어 위 예시에서처럼 143주와 같은 시간 색인을 말해요.</li>
<li>차원: 다변량 시리즈의 "열"들을 나타냅니다.</li>
<li>샘플: 기간에 대한 값들을 의미합니다. 만약 10번째, 50번째, 90번째 백분위수에 대한 세 개의 샘플과 같이 확률론적 예측이라면, 세 개의 샘플이 존재하게 됩니다.</li>
</ul>
<p>Walmart 상점 매출을 불러오기 위해 .from_group_dataframe() 함수를 사용할 거에요. 그룹 ID는 "Store"이며, 따라서 group_cols 매개변수는 "Store"여야 해요. 시간 색인은 "ds" 열이에요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">from</span> darts <span class="hljs-keyword">import</span> <span class="hljs-title class_">TimeSeries</span>
darts_group_df = <span class="hljs-title class_">TimeSeries</span>.<span class="hljs-title function_">from_group_dataframe</span>(data, group_cols=<span class="hljs-string">'Store'</span>, time_col=<span class="hljs-string">'ds'</span>)
<span class="hljs-title function_">print</span>(<span class="hljs-string">"상점/그룹 수는:"</span>, <span class="hljs-title function_">len</span>(darts_group_df))
<span class="hljs-title function_">print</span>(<span class="hljs-string">"시간 기간의 수는: "</span>, <span class="hljs-title function_">len</span>(darts_group_df[<span class="hljs-number">0</span>]))
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>그룹/스토어의 수는 45개입니다.
기간의 수는 143개입니다.</p>
<p>.columns 함수를 사용하여 열을 나열할 수 있습니다:</p>
<pre><code class="hljs language-js">darts_group_df[<span class="hljs-number">0</span>].<span class="hljs-property">components</span>;
</code></pre>
<p>열 이름은:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>인덱스(['주간_매출', '휴일_플래그', '온도', '유종_가격', '소비자_물가_지수', '실업률'], dtype='object', name='구성요소')</p>
<p>로컬 모델 구축하기</p>
<p>시계열 예측에서는 두 가지 주요 유형의 모델이 있습니다: 로컬 모델과 글로벌 모델이 있습니다. 로컬 모델은 단일 시계열 또는 단변량 시계열에 사용되며 해당 시리즈에서 고유한 패턴과 트렌드를 포착하도록 설계되었습니다. 반면 글로벌 모델은 여러 시계열을 사용하여 개발되며 매개변수가 모든 시계열 전체에서 공유됩니다. 이를 통해 모델은 시계열 간에 일반적인 패턴과 관계를 포착하여 보다 정확한 예측을 할 수 있습니다.</p>
<p>각 가게에 대해 로컬 모델을 구축할 것입니다. 가게 1 판매를 위한 모델을 구축하기 위해 가게 1의 데이터인 "darts_group_df[0]"를 사용할 것입니다. 이를 훈련 및 테스트 데이터로 분할할 것입니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js">store1 = darts_group_df[<span class="hljs-number">0</span>]
train = store1[:<span class="hljs-number">130</span>]
test = store1[<span class="hljs-number">130</span>:]
<span class="hljs-title function_">len</span>(train), <span class="hljs-title function_">len</span>(test) # (<span class="hljs-number">130</span>, <span class="hljs-number">13</span>)
</code></pre>
<p>타겟 변수와 공변량을 정의해 봅시다.</p>
<p>타겟 및 과거, 미래 공변량</p>
<p>저희의 타겟 시리즈는 "Weekly_Sales"입니다. 다른 공변량도 포함할 수 있습니다. 시계열에서는 과거 공변량과 미래 공변량 두 가지 유형의 공변량이 있습니다. 과거 공변량은 현재 연구 시점까지의 변수입니다. 그리고 미래 공변량은 미래에서 관찰 가능한 변수입니다. 미래 값을 어떻게 알 수 있는지 궁금할 수도 있습니다. 우리는 미래 값을 알 수 있는 이유가 두 가지 있습니다. 첫 번째 이유는 그들이 달력 일수, 공휴일 또는 정기 프로모션과 같은 결정론적 값이기 때문입니다. 두 번째 이유는 날씨 예보와 같은 외부 소스의 예측 값입니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>우리 경우에는 "Fuel_price"와 "CPI"를 과거 공선변수로 포함하고 "Holiday_flag"를 미래 공선변수로 포함할 것입니다. 훈련 데이터에서 목표 및 과거 공선변수는 130개의 데이터 포인트를 가지고 있습니다. 그러나 미래 공선변수는 미래로 확장되어야 하며, 테스트 데이터의 기간을 커버하기 위해 추가 13개의 데이터 포인트를 가지고 있어야 합니다.</p>
<pre><code class="hljs language-js">target = train[<span class="hljs-string">'Weekly_Sales'</span>]  #<span class="hljs-number">130</span> 주
past_cov = train[[<span class="hljs-string">'Fuel_Price'</span>, <span class="hljs-string">'CPI'</span>]]  # <span class="hljs-number">130</span> 주
future_cov = store1[<span class="hljs-string">'Holiday_Flag'</span>][:<span class="hljs-number">143</span>]  #<span class="hljs-number">143</span> 주
</code></pre>
<p>기본 구문을 보여주기 위해 공선변수 없이 시작해봅시다.</p>
<p>(1) 유변량 데이터만, 공선변수 없음</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>아래 코드는 Darts의 LinearRegressionMode 클래스의 공식입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">from</span> darts.<span class="hljs-property">models</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">LinearRegressionModel</span>
n = <span class="hljs-number">11</span>
model = <span class="hljs-title class_">LinearRegressionModel</span>(
    lags=<span class="hljs-number">12</span>,
    multi_models = <span class="hljs-title class_">True</span>  # 기본값
)
</code></pre>
<p>주요 입력 매개변수는 다음과 같습니다:</p>
<ul>
<li>lags: 지연된 항목의 수</li>
<li>multi_models: 이 하이퍼 매개변수는 다기간 예측 전략을 식별합니다. "True"이면 직접 예측 전략을 적용하고, 그렇지 않으면 재귀적 예측 전략을 적용합니다. 기본값은 "True"입니다.</li>
</ul>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>"우리는 단변량 시리즈 'target'을 사용하여 모델을 훈련하고 다음 n 기간을 예측할 것입니다.</p>
<pre><code class="hljs language-js">model.<span class="hljs-title function_">fit</span>(target)
pred = model.<span class="hljs-title function_">predict</span>(n)
pred.<span class="hljs-title function_">values</span>()<span class="hljs-string">"
</span></code></pre>
<p>결과는 다음 n 기간을 예측한 것입니다. 위의 코드가 이미 직접 예측 전략을 실행했음을 주목하세요.</p>
<p><img src="/TIL/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_6.png" alt="image">"</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>훈련 데이터, 예측 값 및 실제 값들을 함께 시각화해 보겠습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> matplotlib.<span class="hljs-property">pyplot</span> <span class="hljs-keyword">as</span> plt
target.<span class="hljs-title function_">plot</span>(label=<span class="hljs-string">'훈련 데이터'</span>)
pred.<span class="hljs-title function_">plot</span>(label=<span class="hljs-string">'예측값'</span>)
test[<span class="hljs-string">'Weekly_Sales'</span>][:n].<span class="hljs-title function_">plot</span>(label=<span class="hljs-string">'실제값'</span>)
</code></pre>
<p>그림 (G)은 위의 플롯을 보여줍니다.</p>
<img src="/TIL/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_7.png">
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>모델의 성능은 어떤가요? 평균 절대 오차 또는 평균 절대 백분율 오차를 사용해보는 것이 좋을 것 같아요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">from</span> darts.<span class="hljs-property">metrics</span>.<span class="hljs-property">metrics</span> <span class="hljs-keyword">import</span> mae, mape
<span class="hljs-title function_">print</span>(<span class="hljs-string">"평균 절대 오차:"</span>, <span class="hljs-title function_">mae</span>(test[<span class="hljs-string">'Weekly_Sales'</span>][:n], pred))
<span class="hljs-title function_">print</span>(<span class="hljs-string">"평균 절대 백분율 오차:"</span>, <span class="hljs-title function_">mape</span>(test[<span class="hljs-string">'Weekly_Sales'</span>][:n], pred))
</code></pre>
<p>MAPE는 4.07% 입니다:</p>
<ul>
<li>평균 절대 오차: 63404.82928050449</li>
<li>평균 절대 백분율 오차: 4.070126403190025</li>
</ul>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이제 다른 공석요인을 추가해 봅시다.</p>
<p>과거 및 미래 공석요인 추가하기</p>
<p>공석요인은 추가 입력 변수입니다. Darts는 모델링을 위해 두 가지 유형의 공석요인을 취합니다. 하나는 과거 공석요인(lags_past_covariates)으로 된 지연된(lagged) 과거 공석요인이며, 다른 하나는 다소 혼란스러운 이름을 가진 미래 공석요인(lags_future_covariates)입니다. "미래 공석요인"은 이러한 공석요인의 미래 시간 단계에서의 값을 가리킵니다. 그리고 "지연된" 값은 이전 시간 단계의 미래 공석요인을 나타냅니다. 따라서 미래에서 t + n 단계에 해당하는 시간에 모델은 t부터 t + (n-1) 기능의 공석요인 값을 고려합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">from</span> darts.<span class="hljs-property">models</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">LinearRegressionModel</span>
n = <span class="hljs-number">12</span>
model = <span class="hljs-title class_">LinearRegressionModel</span>(
    lags=<span class="hljs-number">12</span>,
    lags_past_covariates=<span class="hljs-number">12</span>,
    lags_future_covariates=[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>],
    output_chunk_length=<span class="hljs-number">12</span>,
)
model.<span class="hljs-title function_">fit</span>(target, past_covariates=past_cov, future_covariates=future_cov)
pred = model.<span class="hljs-title function_">predict</span>(n)
pred.<span class="hljs-title function_">values</span>()
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>상기된 매개변수 output_chunk_length에 대해 자세한 설명이 필요합니다. 이는 단변량 시리즈에서 샘플을 생성하는 데 관한 것입니다. Figure (H)에서는 y0부터 y15까지의 시리즈에서 생성된 샘플을 보여줍니다. 각 샘플은 입력 청크와 출력 청크를 포함합니다. 입력 청크의 길이가 5이고 출력 청크의 길이가 2인 것으로 가정해 봅시다. 첫 번째 샘플은 입력 청크로 y0부터 y4를, 출력 청크로 y5, y6을 가집니다. 창이 시리즈를 따라 이동하여 시리즈의 끝까지 샘플을 만듭니다.</p>
<p><img src="/TIL/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_8.png" alt="이미지"></p>
<p>출력 청크의 길이는 예측 가능한 최대 길이를 정의합니다. 이를 12로 지정했습니다. 12보다 더 많이 예측하고자 한다면 에러 메시지를 받게 될 것입니다.</p>
<p>다음으로 하이퍼파라미터 multi_models=True는 다중 기간에 대한 확률적 예측을 위한 직접적인 전략을 정의합니다. 이는 각 미래 n 기간을 위해 별도의 n개 모델을 구축하는 전략을 의미합니다. 이는 기본 값이기 때문에 별도로 명시할 필요가 없습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/TIL/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_9.png" alt="image"></p>
<p>모델링과 예측을 한 뒤에는 실제 값과 예측값을 플롯에 함께 표시해보겠습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> matplotlib.<span class="hljs-property">pyplot</span> <span class="hljs-keyword">as</span> plt
target.<span class="hljs-title function_">plot</span>(label=<span class="hljs-string">'훈련 데이터'</span>)
pred.<span class="hljs-title function_">plot</span>(label=<span class="hljs-string">'예측값'</span>)
test[<span class="hljs-string">'Weekly_Sales'</span>][:n].<span class="hljs-title function_">plot</span>(label=<span class="hljs-string">'실제값'</span>)
</code></pre>
<p>(J) 그림은 결과를 플롯한 것입니다:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/TIL/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_10.png" alt="Image"></p>
<p>성능을 측정해 봅시다.</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">print</span>(<span class="hljs-string">"평균 절대 오차:"</span>, <span class="hljs-title function_">mae</span>(test[<span class="hljs-string">'Weekly_Sales'</span>][:n], pred))
<span class="hljs-title function_">print</span>(<span class="hljs-string">"평균 절대 백분율 오차:"</span>, <span class="hljs-title function_">mape</span>(test[<span class="hljs-string">'Weekly_Sales'</span>][:n], pred))
</code></pre>
<ul>
<li>평균 절대 오차: 119866.3976798996</li>
<li>평균 절대 백분율 오차: 7.738643655822244</li>
</ul>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>MAPE는 7.73%로 이전 모델보다 낮습니다. 이전 모델을 선택할 수도 있었을 텐데요. 그 다음으로는 분위 예측을 생성하는 방법을 배워보겠습니다.</p>
<p>(3) 분위 예측</p>
<p>앞서 언급한대로 quantiles=[0.01,0.05,0.50,0.95,0.99]을 추가합니다. 샘플이 5개 있기 때문에 .predict()에서 num_samples=5를 지정할 것입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">from</span> darts.<span class="hljs-property">models</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">LinearRegressionModel</span>
n = <span class="hljs-number">12</span>
chunk_length = n
model = <span class="hljs-title class_">LinearRegressionModel</span>(
    lags=<span class="hljs-number">12</span>,
    lags_past_covariates=<span class="hljs-number">12</span>,
    lags_future_covariates=[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>],
    output_chunk_length=chunk_length,
    likelihood = <span class="hljs-string">'quantile'</span>, # <span class="hljs-string">'quantile'</span> 또는 <span class="hljs-string">'poisson'</span>으로 설정할 수 있습니다.
    # <span class="hljs-string">'quantile'</span>로 설정할 경우, sklearn.<span class="hljs-property">linear_model</span>.<span class="hljs-property">QuantileRegressor</span>가 사용됩니다.
    # <span class="hljs-string">'poisson'</span>으로 설정할 경우, sklearn.<span class="hljs-property">linear_model</span>.<span class="hljs-property">PoissonRegressor</span>가 사용됩니다.
    quantiles=[<span class="hljs-number">0.01</span>, <span class="hljs-number">0.05</span>, <span class="hljs-number">0.50</span>, <span class="hljs-number">0.95</span>,<span class="hljs-number">0.99</span>]
)
model.<span class="hljs-title function_">fit</span>(target, past_covariates=past_cov, future_covariates=future_cov)
pred = model.<span class="hljs-title function_">predict</span>(n, num_samples=<span class="hljs-number">5</span>)
pred
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>각 기간에 대한 예측은 한 샘플 대신 5개의 샘플이 될 것입니다. (그래서 Darts의 데이터 형식을 "샘플"이라고 부릅니다.)</p>
<p><img src="/TIL/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_11.png" alt="이미지"></p>
<p>실제 값과 확률 예측을 그래플에 플로팅할 것입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> matplotlib.<span class="hljs-property">pyplot</span> <span class="hljs-keyword">as</span> plt
target.<span class="hljs-title function_">plot</span>(label=<span class="hljs-string">'train'</span>)
pred.<span class="hljs-title function_">plot</span>(label=<span class="hljs-string">'prediction'</span>)
test[<span class="hljs-string">'Weekly_Sales'</span>][:n].<span class="hljs-title function_">plot</span>(label=<span class="hljs-string">'actual'</span>)
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p><img src="/TIL/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_12.png" alt="위 예측은 확률적 예측을 위한 연한 파란색 영역을 포함합니다."></p>
<p>결론</p>
<p>이 장에서는 Darts 라이브러리를 사용하여 선형 회귀 모델 클래스를 배웠습니다. 이를 통해 여러 기간의 확률적 예측을 위한 선형 모델을 구축할 수 있습니다. 과거 및 미래 공변량을 포함한 구문 및 다기간 앞쪽 예측을 위한 직접 또는 재귀적 예측 전략의 옵션을 배웠습니다. 또한 모델을 분위수 확률적 예측을 위해 설정하는 방법도 배웠습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 장에서는 최신 회귀 기반 시계열 기법을 마무리합니다:</p>
<ul>
<li>자동 ARIMA!</li>
<li>쉬운 시계열 데이터 형식</li>
<li>다기간 확률 예측을 위한 선형 회귀</li>
</ul>
<p>다음 단원에서는 트리 기반 모델링 기법을 공부할 예정입니다:</p>
<ul>
<li>트리 기반 시계열 예측에 대한 튜토리얼</li>
<li>다기간 시계열 예측에 대한 튜토리얼</li>
<li>다기간 시계열 확률 예측을 위한 트리 기반 XGB, LightGBM 및 CatBoost 모델</li>
</ul>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>샘플 eBook 챕터(무료): <a href="https://github.com/dataman-git/modern-time-series/blob/main/20240522beauty_TOC.pdf" rel="nofollow" target="_blank">여기</a></p>
<ul>
<li>The Innovation Press, LLC의 스태프 여러분께 감사드립니다. 아름다운 형식으로 책을 재현하여 즐거운 독서 경험을 선사해 주셨습니다. 저희는 Teachable 플랫폼을 선택하여 eBook을 전 세계 독자에게 분배하며 무거운 오버헤드 없이 알찬 서비스를 제공합니다. 결제 거래는 Teachable.com에서 신뢰성 있고 안전하게 처리됩니다.</li>
</ul>
<p>Teachable.com에서의 eBook: $22.50
<a href="https://drdataman.teachable.com/p/home" rel="nofollow" target="_blank">여기에서 확인하세요</a></p>
<p>Amazon.com에서의 인쇄판: $65 <a href="https://a.co/d/25FVsMx" rel="nofollow" target="_blank">여기서 확인하세요</a></p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>인쇄판은 광택이 도는 표지, 컬러 프린트, 아름다운 Springer 폰트와 레이아웃이 매력적인 읽기를 위해 채택되었습니다. 7.5 x 9.25인치의 포털 크기로 대부분의 책장에 적합합니다.</li>
<li>"이 책은 Kuo의 시계열 분석에 대한 심층적인 이해와 예측 분석 및 이상 탐지에 대한 응용을 입증하는 것입니다. 이 책은 독자들이 현실 세계의 도전 과제에 대처하는 데 필요한 기술을 제공합니다. 데이터 과학으로의 직업 전환을 추구하는 사람들에게 특히 가치 있는 자료입니다. Kuo는 전통적인 기법과 최신 기법을 자세히 탐구했습니다. Kuo는 신경망 및 다른 고급 알고리즘에 대한 논의를 통합함으로써, 분야의 최신 동향과 발전을 반영했습니다. 이것은 독자가 확립된 방법뿐만 아니라 데이터 과학 분야의 가장 최신이며 혁신적인 기법과 상호 작용할 준비가 되어 있는 것을 보장합니다. Kuo의 유쾌한 글쓰기 스타일로 책의 알기 쉽고 접근성이 향상되었습니다. 그는 복잡한 수학적 및 통계적 개념을 낯설지 않게 만들어 손실되지 않도록 했습니다."</li>
</ul>
<h1>모던 시계열 예측: 예측 분석과 이상 탐지를 위한</h1>
<p>Chapter 0: 서문</p>
<p>Chapter 1: 소개</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>장 2: 비즈니스 예측용 선지자</h2>
<h2>장 3: 튜토리얼 I: 추세 + 계절성 + 휴일 및 이벤트</h2>
<h2>장 4: 튜토리얼 II: 추세 + 계절성 + 휴일 및 이벤트 + 자기회귀(AR) + 지연 회귀자 + 미래 회귀자</h2>
<h2>장 5: 시계열에서의 변화점 탐지</h2>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>6장: 시계열 확률 예측을 위한 몬테카를로 시뮬레이션</p>
<p>7장: 시계열 확률 예측을 위한 분위수 회귀</p>
<p>8장: 시계열 확률 예측을 위한 일치 예측</p>
<p>9장: 시계열 확률 예측을 위한 일치화된 분위수 회귀</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h3>제 10 장: 자동 ARIMA!</h3>
<h3>제 11 장: 시계열 데이터 형식 쉽게 만들기</h3>
<h3>제 12 장: 다기간 확률 예측을 위한 선형 회귀</h3>
<h3>제 13 장: 트리 기반 시계열 모델용 피처 엔지니어링</h3>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Chapter 14: 다기간 시계열 예측을 위한 두 가지 주요 전략</p>
<p>Chapter 15: Tree 기반 XGB, LightGBM 및 CatBoost 모델에 대한 다기간 시계열 확률적 예측</p>
<p>Chapter 16: 시계열 모델링 기술의 진화</p>
<p>Chapter 17: 시계열 확률적 예측을 위한 Deep Learning 기반 DeepAR</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>Chapter 18: 주식 가격을 위한 확률론적 예측 애플리케이션</h1>
<h1>Chapter 19: RNN에서 Transformer 기반 시계열 모델로</h1>
<h1>Chapter 20: 해석 가능한 시계열 예측을 위한 Temporal Fusion Transformer</h1>
<h1>Chapter 21: 시계열 예측을 위한 오픈 소스 Lag-Llama 튜토리얼</h1>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"다중 기간 확률 예측을 위한 선형 모델 이해하기","description":"","date":"2024-07-09 19:30","slug":"2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting","content":"\n\u003cimg src=\"/TIL/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_0.png\" /\u003e\n\n샘플 eBook 장(chapters) (무료): [여기](https://github.com/dataman-git/modern-time-series/blob/main/20240522beauty_TOC.pdf)\n\nTeachable.com에서 eBook: $22.50 [여기](https://drdataman.teachable.com/p/home)\n\nAmazon.com에서 인쇄본: $65 [여기](https://a.co/d/25FVsMx)\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n선형 회귀 모델은 시계열에 대한 점 추정을 당연히 할 수 있습니다. 선형 회귀 모델은 빠르고 해석하기 쉽며 쉽게 배포할 수 있는 장점이 있습니다. 많은 기관에서 여전히 좋은 선택입니다. 선형 회귀의 일반적인 유형은 자기회귀 모델로, 9장인 \"자동 ARIMA\"에서 나와 있습니다. 그러나 많은 실제 사용 사례에서는 다음 두 가지를 제공해야 합니다: (1) 확률적 예측(또는 예측 구간 또는 예측 불확실성이라고도 함)과 (2) 다기간 예측. 선형 회귀를 어떻게 확장하여 이 두 결과를 수행할 수 있을까요?\n\n(1)에 대한 해결책은 분위 회귀를 사용하여 예측 불확실성을 제공하는 것입니다. (A) 그림은 분위 예측을 보여줍니다. 미래의 시간 t에 대해 10번째, 50번째 및 90번째 백분위수를 기반으로 예측 샘플을 반환합니다. 필요하다면 더 많은 분위 샘플을 생성할 수 있습니다. 이에 대해서는 \"6장: 예측 불확실성을 위한 분위 회귀\"를 참조해주세요.\n\n![quantile forecasts](/TIL/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_1.png)\n\n(2)는 어떻게 해결할까요? 선형 회귀는 점 예측을 생성하지만, 다기간 예측을 어떻게 만들까요? 한 가지 방법은 동일한 모델을 재귀적으로 사용하는 것일 수 있습니다. 한 기간 예측을 모델로부터 얻어 다음 기간을 예측하는 데 입력으로 사용합니다. 그런 다음 두 번째 기간을 예측하기 위해 두 번째 기간의 예측을 입력으로 사용합니다. 이전 기간의 예측을 사용하여 모든 기간을 반복할 수 있습니다. 이것이 재귀 예측 또는 반복적 예측 전략이 하는 일입니다. (B) 그림은 모델이 먼저 yt+1을 생성하고, 그런 다음 같은 모델이 yt+1을 사용하여 yt+2를 생성하는 것을 보여줍니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 마크다운 형식의 테이블입니다.\n\n또 다른 전략은 n개의 별도 모델을 구축하는 것입니다. 각 모델은 n개의 기간에 대한 예측을 생성합니다. 10개 기간을 예측하려면 10개의 모델을 교육하고 각 모델을 특정 단계를 예측하도록 설정합니다. 이를 직접 예측 전략이라고 합니다. 이 전략은 그림 (C)에 나와 있습니다. 두 가지 전략을 학습하려면 13장인 \"다중 기간 시계열 예측을 위한 두 가지 주요 전략\"으로 이동하세요.\n\n선형 회귀를 단변량 시계열로 제한할 이유는 명백히 없습니다. 다른 변수인 공변량이라고 불리는 변수도 추가할 수 있습니다. 그림 (D)에는 다른 공변량 xt와 과거 p개 항목이 포함되어 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![그림](/TIL/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_4.png)\n\n선형 모델은 Figure (A)에 표시된 분위수 예측 및 Figure (D)에 표시된 직접 예측을 수행해야 할 때 복잡해 보입니다. 다행히 Python 시계열 라이브러리인 Darts에서 이러한 프로세스가 구현되었습니다. Darts 라이브러리는 \"scikit-learn\" 함수를 많이 포함하고 있어 \"scikit-learn\"의 기능을 활용할 수 있습니다. 이 중에는 sklearn의 분위수 회귀기능도 포함되어 있습니다. 따라서 우리는 Darts 라이브러리에 초점을 맞출 수 있습니다.\n\n우리는 다음 단계로 진행할 것입니다:\n\n- 단변량 데이터로 시작하기\n- 다른 공변럇값 포함하기, 그리고\n- 분위수 예측 포함하기.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nDarts 라이브러리는 시계열 데이터를 위한 특별한 데이터 형식을 가지고 있어요. 10장: 시계열 데이터 형식을 쉽게 다루는 내용은 Darts의 데이터 구조에 대해 소개하고 있어요. 이 장의 파이썬 노트북은 이 Github 링크를 통해 확인할 수 있어요.\n\n우선 데이터를 불러와 볼까요?\n\n데이터 불러오기\n\n이번에는 Kaggle.com의 Walmart 데이터셋을 사용해 보겠어요. 이 데이터셋은 2010년 2월 5일부터 2012년 11월 1일까지의 매장 주간 매출 데이터를 포함하고 있어요:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 날짜 — 판매 주의 주\n- 상점 — 상점 번호\n- 주간 판매 — 상점의 매출\n- 공휴일 플래그 — 특별 공휴일 주 인지 여부 1 — 공휴일 주 0 — 비공휴일 주\n- 온도 — 판매일의 온도\n- 연료 가격 — 지역의 연료 비용\n\n또한 소매 매출에 영향을 미칠 수 있는 두 가지 거시 경제 지표가 있습니다: 소비자물가지수 및 실업률. 데이터 집합은 먼저 Pandas 데이터 프레임으로로드됩니다.\n\n```js\n%matplotlib inline\nimport pandas as pd\nimport numpy as np\nfrom matplotlib import pyplot as plt\n\nfrom google.colab import drive\ndrive.mount('/content/gdrive')\npath = '/content/gdrive/My Drive/data/time_series'\ndata = pd.read_csv(path + '/walmart.csv', delimiter=\",\")\ndata['ds'] = pd.to_datetime(data['Date'], format='%d-%m-%Y')\ndata.index = data['ds']\ndata = data.drop('Date', axis=1)\ndata.head()\n```\n\n\u003cimg src=\"/TIL/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_5.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n데이터 준비를 위한 Darts의 주요 Python 클래스는 TimeSeries 클래스입니다. Darts는 값들을 다차원 배열로 저장하는데, 이 배열들은 다음과 같은 형태를 가지고 있어요 (시간, 차원, 샘플):\n\n- 시간: 예를 들어 위 예시에서처럼 143주와 같은 시간 색인을 말해요.\n- 차원: 다변량 시리즈의 \"열\"들을 나타냅니다.\n- 샘플: 기간에 대한 값들을 의미합니다. 만약 10번째, 50번째, 90번째 백분위수에 대한 세 개의 샘플과 같이 확률론적 예측이라면, 세 개의 샘플이 존재하게 됩니다.\n\nWalmart 상점 매출을 불러오기 위해 .from_group_dataframe() 함수를 사용할 거에요. 그룹 ID는 \"Store\"이며, 따라서 group_cols 매개변수는 \"Store\"여야 해요. 시간 색인은 \"ds\" 열이에요.\n\n```js\nfrom darts import TimeSeries\ndarts_group_df = TimeSeries.from_group_dataframe(data, group_cols='Store', time_col='ds')\nprint(\"상점/그룹 수는:\", len(darts_group_df))\nprint(\"시간 기간의 수는: \", len(darts_group_df[0]))\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그룹/스토어의 수는 45개입니다.\n기간의 수는 143개입니다.\n\n.columns 함수를 사용하여 열을 나열할 수 있습니다:\n\n```js\ndarts_group_df[0].components;\n```\n\n열 이름은:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n인덱스(['주간_매출', '휴일_플래그', '온도', '유종_가격', '소비자_물가_지수', '실업률'], dtype='object', name='구성요소')\n\n로컬 모델 구축하기\n\n시계열 예측에서는 두 가지 주요 유형의 모델이 있습니다: 로컬 모델과 글로벌 모델이 있습니다. 로컬 모델은 단일 시계열 또는 단변량 시계열에 사용되며 해당 시리즈에서 고유한 패턴과 트렌드를 포착하도록 설계되었습니다. 반면 글로벌 모델은 여러 시계열을 사용하여 개발되며 매개변수가 모든 시계열 전체에서 공유됩니다. 이를 통해 모델은 시계열 간에 일반적인 패턴과 관계를 포착하여 보다 정확한 예측을 할 수 있습니다.\n\n각 가게에 대해 로컬 모델을 구축할 것입니다. 가게 1 판매를 위한 모델을 구축하기 위해 가게 1의 데이터인 \"darts_group_df[0]\"를 사용할 것입니다. 이를 훈련 및 테스트 데이터로 분할할 것입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nstore1 = darts_group_df[0]\ntrain = store1[:130]\ntest = store1[130:]\nlen(train), len(test) # (130, 13)\n```\n\n타겟 변수와 공변량을 정의해 봅시다.\n\n타겟 및 과거, 미래 공변량\n\n저희의 타겟 시리즈는 \"Weekly_Sales\"입니다. 다른 공변량도 포함할 수 있습니다. 시계열에서는 과거 공변량과 미래 공변량 두 가지 유형의 공변량이 있습니다. 과거 공변량은 현재 연구 시점까지의 변수입니다. 그리고 미래 공변량은 미래에서 관찰 가능한 변수입니다. 미래 값을 어떻게 알 수 있는지 궁금할 수도 있습니다. 우리는 미래 값을 알 수 있는 이유가 두 가지 있습니다. 첫 번째 이유는 그들이 달력 일수, 공휴일 또는 정기 프로모션과 같은 결정론적 값이기 때문입니다. 두 번째 이유는 날씨 예보와 같은 외부 소스의 예측 값입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리 경우에는 \"Fuel_price\"와 \"CPI\"를 과거 공선변수로 포함하고 \"Holiday_flag\"를 미래 공선변수로 포함할 것입니다. 훈련 데이터에서 목표 및 과거 공선변수는 130개의 데이터 포인트를 가지고 있습니다. 그러나 미래 공선변수는 미래로 확장되어야 하며, 테스트 데이터의 기간을 커버하기 위해 추가 13개의 데이터 포인트를 가지고 있어야 합니다.\n\n```js\ntarget = train['Weekly_Sales']  #130 주\npast_cov = train[['Fuel_Price', 'CPI']]  # 130 주\nfuture_cov = store1['Holiday_Flag'][:143]  #143 주\n```\n\n기본 구문을 보여주기 위해 공선변수 없이 시작해봅시다.\n\n(1) 유변량 데이터만, 공선변수 없음\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 코드는 Darts의 LinearRegressionMode 클래스의 공식입니다.\n\n```js\nfrom darts.models import LinearRegressionModel\nn = 11\nmodel = LinearRegressionModel(\n    lags=12,\n    multi_models = True  # 기본값\n)\n```\n\n주요 입력 매개변수는 다음과 같습니다:\n\n- lags: 지연된 항목의 수\n- multi_models: 이 하이퍼 매개변수는 다기간 예측 전략을 식별합니다. \"True\"이면 직접 예측 전략을 적용하고, 그렇지 않으면 재귀적 예측 전략을 적용합니다. 기본값은 \"True\"입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\"우리는 단변량 시리즈 'target'을 사용하여 모델을 훈련하고 다음 n 기간을 예측할 것입니다.\n\n```js\nmodel.fit(target)\npred = model.predict(n)\npred.values()\"\n```\n\n결과는 다음 n 기간을 예측한 것입니다. 위의 코드가 이미 직접 예측 전략을 실행했음을 주목하세요.\n\n![image](/TIL/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_6.png)\"\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n훈련 데이터, 예측 값 및 실제 값들을 함께 시각화해 보겠습니다:\n\n```js\nimport matplotlib.pyplot as plt\ntarget.plot(label='훈련 데이터')\npred.plot(label='예측값')\ntest['Weekly_Sales'][:n].plot(label='실제값')\n```\n\n그림 (G)은 위의 플롯을 보여줍니다.\n\n\u003cimg src=\"/TIL/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_7.png\" /\u003e\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n모델의 성능은 어떤가요? 평균 절대 오차 또는 평균 절대 백분율 오차를 사용해보는 것이 좋을 것 같아요.\n\n```js\nfrom darts.metrics.metrics import mae, mape\nprint(\"평균 절대 오차:\", mae(test['Weekly_Sales'][:n], pred))\nprint(\"평균 절대 백분율 오차:\", mape(test['Weekly_Sales'][:n], pred))\n```\n\nMAPE는 4.07% 입니다:\n\n- 평균 절대 오차: 63404.82928050449\n- 평균 절대 백분율 오차: 4.070126403190025\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 다른 공석요인을 추가해 봅시다.\n\n과거 및 미래 공석요인 추가하기\n\n공석요인은 추가 입력 변수입니다. Darts는 모델링을 위해 두 가지 유형의 공석요인을 취합니다. 하나는 과거 공석요인(lags_past_covariates)으로 된 지연된(lagged) 과거 공석요인이며, 다른 하나는 다소 혼란스러운 이름을 가진 미래 공석요인(lags_future_covariates)입니다. \"미래 공석요인\"은 이러한 공석요인의 미래 시간 단계에서의 값을 가리킵니다. 그리고 \"지연된\" 값은 이전 시간 단계의 미래 공석요인을 나타냅니다. 따라서 미래에서 t + n 단계에 해당하는 시간에 모델은 t부터 t + (n-1) 기능의 공석요인 값을 고려합니다.\n\n```js\nfrom darts.models import LinearRegressionModel\nn = 12\nmodel = LinearRegressionModel(\n    lags=12,\n    lags_past_covariates=12,\n    lags_future_covariates=[0,1,2,3,4,5,6,7,8,9,10,11,12],\n    output_chunk_length=12,\n)\nmodel.fit(target, past_covariates=past_cov, future_covariates=future_cov)\npred = model.predict(n)\npred.values()\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n상기된 매개변수 output_chunk_length에 대해 자세한 설명이 필요합니다. 이는 단변량 시리즈에서 샘플을 생성하는 데 관한 것입니다. Figure (H)에서는 y0부터 y15까지의 시리즈에서 생성된 샘플을 보여줍니다. 각 샘플은 입력 청크와 출력 청크를 포함합니다. 입력 청크의 길이가 5이고 출력 청크의 길이가 2인 것으로 가정해 봅시다. 첫 번째 샘플은 입력 청크로 y0부터 y4를, 출력 청크로 y5, y6을 가집니다. 창이 시리즈를 따라 이동하여 시리즈의 끝까지 샘플을 만듭니다.\n\n![이미지](/TIL/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_8.png)\n\n출력 청크의 길이는 예측 가능한 최대 길이를 정의합니다. 이를 12로 지정했습니다. 12보다 더 많이 예측하고자 한다면 에러 메시지를 받게 될 것입니다.\n\n다음으로 하이퍼파라미터 multi_models=True는 다중 기간에 대한 확률적 예측을 위한 직접적인 전략을 정의합니다. 이는 각 미래 n 기간을 위해 별도의 n개 모델을 구축하는 전략을 의미합니다. 이는 기본 값이기 때문에 별도로 명시할 필요가 없습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/TIL/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_9.png)\n\n모델링과 예측을 한 뒤에는 실제 값과 예측값을 플롯에 함께 표시해보겠습니다.\n\n```js\nimport matplotlib.pyplot as plt\ntarget.plot(label='훈련 데이터')\npred.plot(label='예측값')\ntest['Weekly_Sales'][:n].plot(label='실제값')\n```\n\n(J) 그림은 결과를 플롯한 것입니다:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Image](/TIL/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_10.png)\n\n성능을 측정해 봅시다.\n\n```js\nprint(\"평균 절대 오차:\", mae(test['Weekly_Sales'][:n], pred))\nprint(\"평균 절대 백분율 오차:\", mape(test['Weekly_Sales'][:n], pred))\n```\n\n- 평균 절대 오차: 119866.3976798996\n- 평균 절대 백분율 오차: 7.738643655822244\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nMAPE는 7.73%로 이전 모델보다 낮습니다. 이전 모델을 선택할 수도 있었을 텐데요. 그 다음으로는 분위 예측을 생성하는 방법을 배워보겠습니다.\n\n(3) 분위 예측\n\n앞서 언급한대로 quantiles=[0.01,0.05,0.50,0.95,0.99]을 추가합니다. 샘플이 5개 있기 때문에 .predict()에서 num_samples=5를 지정할 것입니다.\n\n```js\nfrom darts.models import LinearRegressionModel\nn = 12\nchunk_length = n\nmodel = LinearRegressionModel(\n    lags=12,\n    lags_past_covariates=12,\n    lags_future_covariates=[0,1,2,3,4,5,6,7,8,9,10,11,12],\n    output_chunk_length=chunk_length,\n    likelihood = 'quantile', # 'quantile' 또는 'poisson'으로 설정할 수 있습니다.\n    # 'quantile'로 설정할 경우, sklearn.linear_model.QuantileRegressor가 사용됩니다.\n    # 'poisson'으로 설정할 경우, sklearn.linear_model.PoissonRegressor가 사용됩니다.\n    quantiles=[0.01, 0.05, 0.50, 0.95,0.99]\n)\nmodel.fit(target, past_covariates=past_cov, future_covariates=future_cov)\npred = model.predict(n, num_samples=5)\npred\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n각 기간에 대한 예측은 한 샘플 대신 5개의 샘플이 될 것입니다. (그래서 Darts의 데이터 형식을 \"샘플\"이라고 부릅니다.)\n\n![이미지](/TIL/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_11.png)\n\n실제 값과 확률 예측을 그래플에 플로팅할 것입니다.\n\n```js\nimport matplotlib.pyplot as plt\ntarget.plot(label='train')\npred.plot(label='prediction')\ntest['Weekly_Sales'][:n].plot(label='actual')\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![위 예측은 확률적 예측을 위한 연한 파란색 영역을 포함합니다.](/TIL/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_12.png)\n\n결론\n\n이 장에서는 Darts 라이브러리를 사용하여 선형 회귀 모델 클래스를 배웠습니다. 이를 통해 여러 기간의 확률적 예측을 위한 선형 모델을 구축할 수 있습니다. 과거 및 미래 공변량을 포함한 구문 및 다기간 앞쪽 예측을 위한 직접 또는 재귀적 예측 전략의 옵션을 배웠습니다. 또한 모델을 분위수 확률적 예측을 위해 설정하는 방법도 배웠습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 장에서는 최신 회귀 기반 시계열 기법을 마무리합니다:\n\n- 자동 ARIMA!\n- 쉬운 시계열 데이터 형식\n- 다기간 확률 예측을 위한 선형 회귀\n\n다음 단원에서는 트리 기반 모델링 기법을 공부할 예정입니다:\n\n- 트리 기반 시계열 예측에 대한 튜토리얼\n- 다기간 시계열 예측에 대한 튜토리얼\n- 다기간 시계열 확률 예측을 위한 트리 기반 XGB, LightGBM 및 CatBoost 모델\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n샘플 eBook 챕터(무료): [여기](https://github.com/dataman-git/modern-time-series/blob/main/20240522beauty_TOC.pdf)\n\n- The Innovation Press, LLC의 스태프 여러분께 감사드립니다. 아름다운 형식으로 책을 재현하여 즐거운 독서 경험을 선사해 주셨습니다. 저희는 Teachable 플랫폼을 선택하여 eBook을 전 세계 독자에게 분배하며 무거운 오버헤드 없이 알찬 서비스를 제공합니다. 결제 거래는 Teachable.com에서 신뢰성 있고 안전하게 처리됩니다.\n\nTeachable.com에서의 eBook: $22.50\n[여기에서 확인하세요](https://drdataman.teachable.com/p/home)\n\nAmazon.com에서의 인쇄판: $65 [여기서 확인하세요](https://a.co/d/25FVsMx)\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 인쇄판은 광택이 도는 표지, 컬러 프린트, 아름다운 Springer 폰트와 레이아웃이 매력적인 읽기를 위해 채택되었습니다. 7.5 x 9.25인치의 포털 크기로 대부분의 책장에 적합합니다.\n- \"이 책은 Kuo의 시계열 분석에 대한 심층적인 이해와 예측 분석 및 이상 탐지에 대한 응용을 입증하는 것입니다. 이 책은 독자들이 현실 세계의 도전 과제에 대처하는 데 필요한 기술을 제공합니다. 데이터 과학으로의 직업 전환을 추구하는 사람들에게 특히 가치 있는 자료입니다. Kuo는 전통적인 기법과 최신 기법을 자세히 탐구했습니다. Kuo는 신경망 및 다른 고급 알고리즘에 대한 논의를 통합함으로써, 분야의 최신 동향과 발전을 반영했습니다. 이것은 독자가 확립된 방법뿐만 아니라 데이터 과학 분야의 가장 최신이며 혁신적인 기법과 상호 작용할 준비가 되어 있는 것을 보장합니다. Kuo의 유쾌한 글쓰기 스타일로 책의 알기 쉽고 접근성이 향상되었습니다. 그는 복잡한 수학적 및 통계적 개념을 낯설지 않게 만들어 손실되지 않도록 했습니다.\"\n\n# 모던 시계열 예측: 예측 분석과 이상 탐지를 위한\n\nChapter 0: 서문\n\nChapter 1: 소개\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 장 2: 비즈니스 예측용 선지자\n\n## 장 3: 튜토리얼 I: 추세 + 계절성 + 휴일 및 이벤트\n\n## 장 4: 튜토리얼 II: 추세 + 계절성 + 휴일 및 이벤트 + 자기회귀(AR) + 지연 회귀자 + 미래 회귀자\n\n## 장 5: 시계열에서의 변화점 탐지\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n6장: 시계열 확률 예측을 위한 몬테카를로 시뮬레이션\n\n7장: 시계열 확률 예측을 위한 분위수 회귀\n\n8장: 시계열 확률 예측을 위한 일치 예측\n\n9장: 시계열 확률 예측을 위한 일치화된 분위수 회귀\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 제 10 장: 자동 ARIMA!\n\n### 제 11 장: 시계열 데이터 형식 쉽게 만들기\n\n### 제 12 장: 다기간 확률 예측을 위한 선형 회귀\n\n### 제 13 장: 트리 기반 시계열 모델용 피처 엔지니어링\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nChapter 14: 다기간 시계열 예측을 위한 두 가지 주요 전략\n\nChapter 15: Tree 기반 XGB, LightGBM 및 CatBoost 모델에 대한 다기간 시계열 확률적 예측\n\nChapter 16: 시계열 모델링 기술의 진화\n\nChapter 17: 시계열 확률적 예측을 위한 Deep Learning 기반 DeepAR\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Chapter 18: 주식 가격을 위한 확률론적 예측 애플리케이션\n\n# Chapter 19: RNN에서 Transformer 기반 시계열 모델로\n\n# Chapter 20: 해석 가능한 시계열 예측을 위한 Temporal Fusion Transformer\n\n# Chapter 21: 시계열 예측을 위한 오픈 소스 Lag-Llama 튜토리얼\n","ogImage":{"url":"/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_0.png","tag":["Tech"],"readingTime":21},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_0.png\"\u003e\n\u003cp\u003e샘플 eBook 장(chapters) (무료): \u003ca href=\"https://github.com/dataman-git/modern-time-series/blob/main/20240522beauty_TOC.pdf\" rel=\"nofollow\" target=\"_blank\"\u003e여기\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eTeachable.com에서 eBook: $22.50 \u003ca href=\"https://drdataman.teachable.com/p/home\" rel=\"nofollow\" target=\"_blank\"\u003e여기\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eAmazon.com에서 인쇄본: $65 \u003ca href=\"https://a.co/d/25FVsMx\" rel=\"nofollow\" target=\"_blank\"\u003e여기\u003c/a\u003e\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e선형 회귀 모델은 시계열에 대한 점 추정을 당연히 할 수 있습니다. 선형 회귀 모델은 빠르고 해석하기 쉽며 쉽게 배포할 수 있는 장점이 있습니다. 많은 기관에서 여전히 좋은 선택입니다. 선형 회귀의 일반적인 유형은 자기회귀 모델로, 9장인 \"자동 ARIMA\"에서 나와 있습니다. 그러나 많은 실제 사용 사례에서는 다음 두 가지를 제공해야 합니다: (1) 확률적 예측(또는 예측 구간 또는 예측 불확실성이라고도 함)과 (2) 다기간 예측. 선형 회귀를 어떻게 확장하여 이 두 결과를 수행할 수 있을까요?\u003c/p\u003e\n\u003cp\u003e(1)에 대한 해결책은 분위 회귀를 사용하여 예측 불확실성을 제공하는 것입니다. (A) 그림은 분위 예측을 보여줍니다. 미래의 시간 t에 대해 10번째, 50번째 및 90번째 백분위수를 기반으로 예측 샘플을 반환합니다. 필요하다면 더 많은 분위 샘플을 생성할 수 있습니다. 이에 대해서는 \"6장: 예측 불확실성을 위한 분위 회귀\"를 참조해주세요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_1.png\" alt=\"quantile forecasts\"\u003e\u003c/p\u003e\n\u003cp\u003e(2)는 어떻게 해결할까요? 선형 회귀는 점 예측을 생성하지만, 다기간 예측을 어떻게 만들까요? 한 가지 방법은 동일한 모델을 재귀적으로 사용하는 것일 수 있습니다. 한 기간 예측을 모델로부터 얻어 다음 기간을 예측하는 데 입력으로 사용합니다. 그런 다음 두 번째 기간을 예측하기 위해 두 번째 기간의 예측을 입력으로 사용합니다. 이전 기간의 예측을 사용하여 모든 기간을 반복할 수 있습니다. 이것이 재귀 예측 또는 반복적 예측 전략이 하는 일입니다. (B) 그림은 모델이 먼저 yt+1을 생성하고, 그런 다음 같은 모델이 yt+1을 사용하여 yt+2를 생성하는 것을 보여줍니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e아래는 마크다운 형식의 테이블입니다.\u003c/p\u003e\n\u003cp\u003e또 다른 전략은 n개의 별도 모델을 구축하는 것입니다. 각 모델은 n개의 기간에 대한 예측을 생성합니다. 10개 기간을 예측하려면 10개의 모델을 교육하고 각 모델을 특정 단계를 예측하도록 설정합니다. 이를 직접 예측 전략이라고 합니다. 이 전략은 그림 (C)에 나와 있습니다. 두 가지 전략을 학습하려면 13장인 \"다중 기간 시계열 예측을 위한 두 가지 주요 전략\"으로 이동하세요.\u003c/p\u003e\n\u003cp\u003e선형 회귀를 단변량 시계열로 제한할 이유는 명백히 없습니다. 다른 변수인 공변량이라고 불리는 변수도 추가할 수 있습니다. 그림 (D)에는 다른 공변량 xt와 과거 p개 항목이 포함되어 있습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_4.png\" alt=\"그림\"\u003e\u003c/p\u003e\n\u003cp\u003e선형 모델은 Figure (A)에 표시된 분위수 예측 및 Figure (D)에 표시된 직접 예측을 수행해야 할 때 복잡해 보입니다. 다행히 Python 시계열 라이브러리인 Darts에서 이러한 프로세스가 구현되었습니다. Darts 라이브러리는 \"scikit-learn\" 함수를 많이 포함하고 있어 \"scikit-learn\"의 기능을 활용할 수 있습니다. 이 중에는 sklearn의 분위수 회귀기능도 포함되어 있습니다. 따라서 우리는 Darts 라이브러리에 초점을 맞출 수 있습니다.\u003c/p\u003e\n\u003cp\u003e우리는 다음 단계로 진행할 것입니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e단변량 데이터로 시작하기\u003c/li\u003e\n\u003cli\u003e다른 공변럇값 포함하기, 그리고\u003c/li\u003e\n\u003cli\u003e분위수 예측 포함하기.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eDarts 라이브러리는 시계열 데이터를 위한 특별한 데이터 형식을 가지고 있어요. 10장: 시계열 데이터 형식을 쉽게 다루는 내용은 Darts의 데이터 구조에 대해 소개하고 있어요. 이 장의 파이썬 노트북은 이 Github 링크를 통해 확인할 수 있어요.\u003c/p\u003e\n\u003cp\u003e우선 데이터를 불러와 볼까요?\u003c/p\u003e\n\u003cp\u003e데이터 불러오기\u003c/p\u003e\n\u003cp\u003e이번에는 Kaggle.com의 Walmart 데이터셋을 사용해 보겠어요. 이 데이터셋은 2010년 2월 5일부터 2012년 11월 1일까지의 매장 주간 매출 데이터를 포함하고 있어요:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e날짜 — 판매 주의 주\u003c/li\u003e\n\u003cli\u003e상점 — 상점 번호\u003c/li\u003e\n\u003cli\u003e주간 판매 — 상점의 매출\u003c/li\u003e\n\u003cli\u003e공휴일 플래그 — 특별 공휴일 주 인지 여부 1 — 공휴일 주 0 — 비공휴일 주\u003c/li\u003e\n\u003cli\u003e온도 — 판매일의 온도\u003c/li\u003e\n\u003cli\u003e연료 가격 — 지역의 연료 비용\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e또한 소매 매출에 영향을 미칠 수 있는 두 가지 거시 경제 지표가 있습니다: 소비자물가지수 및 실업률. 데이터 집합은 먼저 Pandas 데이터 프레임으로로드됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e%matplotlib inline\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e pandas \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e pd\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e numpy \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e np\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e matplotlib \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e pyplot \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e plt\n\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e google.\u003cspan class=\"hljs-property\"\u003ecolab\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e drive\ndrive.\u003cspan class=\"hljs-title function_\"\u003emount\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/content/gdrive'\u003c/span\u003e)\npath = \u003cspan class=\"hljs-string\"\u003e'/content/gdrive/My Drive/data/time_series'\u003c/span\u003e\ndata = pd.\u003cspan class=\"hljs-title function_\"\u003eread_csv\u003c/span\u003e(path + \u003cspan class=\"hljs-string\"\u003e'/walmart.csv'\u003c/span\u003e, delimiter=\u003cspan class=\"hljs-string\"\u003e\",\"\u003c/span\u003e)\ndata[\u003cspan class=\"hljs-string\"\u003e'ds'\u003c/span\u003e] = pd.\u003cspan class=\"hljs-title function_\"\u003eto_datetime\u003c/span\u003e(data[\u003cspan class=\"hljs-string\"\u003e'Date'\u003c/span\u003e], format=\u003cspan class=\"hljs-string\"\u003e'%d-%m-%Y'\u003c/span\u003e)\ndata.\u003cspan class=\"hljs-property\"\u003eindex\u003c/span\u003e = data[\u003cspan class=\"hljs-string\"\u003e'ds'\u003c/span\u003e]\ndata = data.\u003cspan class=\"hljs-title function_\"\u003edrop\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Date'\u003c/span\u003e, axis=\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\ndata.\u003cspan class=\"hljs-title function_\"\u003ehead\u003c/span\u003e()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_5.png\"\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e데이터 준비를 위한 Darts의 주요 Python 클래스는 TimeSeries 클래스입니다. Darts는 값들을 다차원 배열로 저장하는데, 이 배열들은 다음과 같은 형태를 가지고 있어요 (시간, 차원, 샘플):\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e시간: 예를 들어 위 예시에서처럼 143주와 같은 시간 색인을 말해요.\u003c/li\u003e\n\u003cli\u003e차원: 다변량 시리즈의 \"열\"들을 나타냅니다.\u003c/li\u003e\n\u003cli\u003e샘플: 기간에 대한 값들을 의미합니다. 만약 10번째, 50번째, 90번째 백분위수에 대한 세 개의 샘플과 같이 확률론적 예측이라면, 세 개의 샘플이 존재하게 됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWalmart 상점 매출을 불러오기 위해 .from_group_dataframe() 함수를 사용할 거에요. 그룹 ID는 \"Store\"이며, 따라서 group_cols 매개변수는 \"Store\"여야 해요. 시간 색인은 \"ds\" 열이에요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e darts \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTimeSeries\u003c/span\u003e\ndarts_group_df = \u003cspan class=\"hljs-title class_\"\u003eTimeSeries\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efrom_group_dataframe\u003c/span\u003e(data, group_cols=\u003cspan class=\"hljs-string\"\u003e'Store'\u003c/span\u003e, time_col=\u003cspan class=\"hljs-string\"\u003e'ds'\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"상점/그룹 수는:\"\u003c/span\u003e, \u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(darts_group_df))\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"시간 기간의 수는: \"\u003c/span\u003e, \u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(darts_group_df[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]))\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e그룹/스토어의 수는 45개입니다.\n기간의 수는 143개입니다.\u003c/p\u003e\n\u003cp\u003e.columns 함수를 사용하여 열을 나열할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edarts_group_df[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e].\u003cspan class=\"hljs-property\"\u003ecomponents\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e열 이름은:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e인덱스(['주간_매출', '휴일_플래그', '온도', '유종_가격', '소비자_물가_지수', '실업률'], dtype='object', name='구성요소')\u003c/p\u003e\n\u003cp\u003e로컬 모델 구축하기\u003c/p\u003e\n\u003cp\u003e시계열 예측에서는 두 가지 주요 유형의 모델이 있습니다: 로컬 모델과 글로벌 모델이 있습니다. 로컬 모델은 단일 시계열 또는 단변량 시계열에 사용되며 해당 시리즈에서 고유한 패턴과 트렌드를 포착하도록 설계되었습니다. 반면 글로벌 모델은 여러 시계열을 사용하여 개발되며 매개변수가 모든 시계열 전체에서 공유됩니다. 이를 통해 모델은 시계열 간에 일반적인 패턴과 관계를 포착하여 보다 정확한 예측을 할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e각 가게에 대해 로컬 모델을 구축할 것입니다. 가게 1 판매를 위한 모델을 구축하기 위해 가게 1의 데이터인 \"darts_group_df[0]\"를 사용할 것입니다. 이를 훈련 및 테스트 데이터로 분할할 것입니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003estore1 = darts_group_df[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]\ntrain = store1[:\u003cspan class=\"hljs-number\"\u003e130\u003c/span\u003e]\ntest = store1[\u003cspan class=\"hljs-number\"\u003e130\u003c/span\u003e:]\n\u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(train), \u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(test) # (\u003cspan class=\"hljs-number\"\u003e130\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e13\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e타겟 변수와 공변량을 정의해 봅시다.\u003c/p\u003e\n\u003cp\u003e타겟 및 과거, 미래 공변량\u003c/p\u003e\n\u003cp\u003e저희의 타겟 시리즈는 \"Weekly_Sales\"입니다. 다른 공변량도 포함할 수 있습니다. 시계열에서는 과거 공변량과 미래 공변량 두 가지 유형의 공변량이 있습니다. 과거 공변량은 현재 연구 시점까지의 변수입니다. 그리고 미래 공변량은 미래에서 관찰 가능한 변수입니다. 미래 값을 어떻게 알 수 있는지 궁금할 수도 있습니다. 우리는 미래 값을 알 수 있는 이유가 두 가지 있습니다. 첫 번째 이유는 그들이 달력 일수, 공휴일 또는 정기 프로모션과 같은 결정론적 값이기 때문입니다. 두 번째 이유는 날씨 예보와 같은 외부 소스의 예측 값입니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e우리 경우에는 \"Fuel_price\"와 \"CPI\"를 과거 공선변수로 포함하고 \"Holiday_flag\"를 미래 공선변수로 포함할 것입니다. 훈련 데이터에서 목표 및 과거 공선변수는 130개의 데이터 포인트를 가지고 있습니다. 그러나 미래 공선변수는 미래로 확장되어야 하며, 테스트 데이터의 기간을 커버하기 위해 추가 13개의 데이터 포인트를 가지고 있어야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003etarget = train[\u003cspan class=\"hljs-string\"\u003e'Weekly_Sales'\u003c/span\u003e]  #\u003cspan class=\"hljs-number\"\u003e130\u003c/span\u003e 주\npast_cov = train[[\u003cspan class=\"hljs-string\"\u003e'Fuel_Price'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'CPI'\u003c/span\u003e]]  # \u003cspan class=\"hljs-number\"\u003e130\u003c/span\u003e 주\nfuture_cov = store1[\u003cspan class=\"hljs-string\"\u003e'Holiday_Flag'\u003c/span\u003e][:\u003cspan class=\"hljs-number\"\u003e143\u003c/span\u003e]  #\u003cspan class=\"hljs-number\"\u003e143\u003c/span\u003e 주\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e기본 구문을 보여주기 위해 공선변수 없이 시작해봅시다.\u003c/p\u003e\n\u003cp\u003e(1) 유변량 데이터만, 공선변수 없음\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e아래 코드는 Darts의 LinearRegressionMode 클래스의 공식입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e darts.\u003cspan class=\"hljs-property\"\u003emodels\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eLinearRegressionModel\u003c/span\u003e\nn = \u003cspan class=\"hljs-number\"\u003e11\u003c/span\u003e\nmodel = \u003cspan class=\"hljs-title class_\"\u003eLinearRegressionModel\u003c/span\u003e(\n    lags=\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e,\n    multi_models = \u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e  # 기본값\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e주요 입력 매개변수는 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003elags: 지연된 항목의 수\u003c/li\u003e\n\u003cli\u003emulti_models: 이 하이퍼 매개변수는 다기간 예측 전략을 식별합니다. \"True\"이면 직접 예측 전략을 적용하고, 그렇지 않으면 재귀적 예측 전략을 적용합니다. 기본값은 \"True\"입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\"우리는 단변량 시리즈 'target'을 사용하여 모델을 훈련하고 다음 n 기간을 예측할 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003emodel.\u003cspan class=\"hljs-title function_\"\u003efit\u003c/span\u003e(target)\npred = model.\u003cspan class=\"hljs-title function_\"\u003epredict\u003c/span\u003e(n)\npred.\u003cspan class=\"hljs-title function_\"\u003evalues\u003c/span\u003e()\u003cspan class=\"hljs-string\"\u003e\"\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e결과는 다음 n 기간을 예측한 것입니다. 위의 코드가 이미 직접 예측 전략을 실행했음을 주목하세요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_6.png\" alt=\"image\"\u003e\"\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e훈련 데이터, 예측 값 및 실제 값들을 함께 시각화해 보겠습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e matplotlib.\u003cspan class=\"hljs-property\"\u003epyplot\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e plt\ntarget.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(label=\u003cspan class=\"hljs-string\"\u003e'훈련 데이터'\u003c/span\u003e)\npred.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(label=\u003cspan class=\"hljs-string\"\u003e'예측값'\u003c/span\u003e)\ntest[\u003cspan class=\"hljs-string\"\u003e'Weekly_Sales'\u003c/span\u003e][:n].\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(label=\u003cspan class=\"hljs-string\"\u003e'실제값'\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그림 (G)은 위의 플롯을 보여줍니다.\u003c/p\u003e\n\u003cimg src=\"/TIL/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_7.png\"\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e모델의 성능은 어떤가요? 평균 절대 오차 또는 평균 절대 백분율 오차를 사용해보는 것이 좋을 것 같아요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e darts.\u003cspan class=\"hljs-property\"\u003emetrics\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emetrics\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e mae, mape\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"평균 절대 오차:\"\u003c/span\u003e, \u003cspan class=\"hljs-title function_\"\u003emae\u003c/span\u003e(test[\u003cspan class=\"hljs-string\"\u003e'Weekly_Sales'\u003c/span\u003e][:n], pred))\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"평균 절대 백분율 오차:\"\u003c/span\u003e, \u003cspan class=\"hljs-title function_\"\u003emape\u003c/span\u003e(test[\u003cspan class=\"hljs-string\"\u003e'Weekly_Sales'\u003c/span\u003e][:n], pred))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eMAPE는 4.07% 입니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e평균 절대 오차: 63404.82928050449\u003c/li\u003e\n\u003cli\u003e평균 절대 백분율 오차: 4.070126403190025\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이제 다른 공석요인을 추가해 봅시다.\u003c/p\u003e\n\u003cp\u003e과거 및 미래 공석요인 추가하기\u003c/p\u003e\n\u003cp\u003e공석요인은 추가 입력 변수입니다. Darts는 모델링을 위해 두 가지 유형의 공석요인을 취합니다. 하나는 과거 공석요인(lags_past_covariates)으로 된 지연된(lagged) 과거 공석요인이며, 다른 하나는 다소 혼란스러운 이름을 가진 미래 공석요인(lags_future_covariates)입니다. \"미래 공석요인\"은 이러한 공석요인의 미래 시간 단계에서의 값을 가리킵니다. 그리고 \"지연된\" 값은 이전 시간 단계의 미래 공석요인을 나타냅니다. 따라서 미래에서 t + n 단계에 해당하는 시간에 모델은 t부터 t + (n-1) 기능의 공석요인 값을 고려합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e darts.\u003cspan class=\"hljs-property\"\u003emodels\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eLinearRegressionModel\u003c/span\u003e\nn = \u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e\nmodel = \u003cspan class=\"hljs-title class_\"\u003eLinearRegressionModel\u003c/span\u003e(\n    lags=\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e,\n    lags_past_covariates=\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e,\n    lags_future_covariates=[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e11\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e],\n    output_chunk_length=\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e,\n)\nmodel.\u003cspan class=\"hljs-title function_\"\u003efit\u003c/span\u003e(target, past_covariates=past_cov, future_covariates=future_cov)\npred = model.\u003cspan class=\"hljs-title function_\"\u003epredict\u003c/span\u003e(n)\npred.\u003cspan class=\"hljs-title function_\"\u003evalues\u003c/span\u003e()\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e상기된 매개변수 output_chunk_length에 대해 자세한 설명이 필요합니다. 이는 단변량 시리즈에서 샘플을 생성하는 데 관한 것입니다. Figure (H)에서는 y0부터 y15까지의 시리즈에서 생성된 샘플을 보여줍니다. 각 샘플은 입력 청크와 출력 청크를 포함합니다. 입력 청크의 길이가 5이고 출력 청크의 길이가 2인 것으로 가정해 봅시다. 첫 번째 샘플은 입력 청크로 y0부터 y4를, 출력 청크로 y5, y6을 가집니다. 창이 시리즈를 따라 이동하여 시리즈의 끝까지 샘플을 만듭니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_8.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e출력 청크의 길이는 예측 가능한 최대 길이를 정의합니다. 이를 12로 지정했습니다. 12보다 더 많이 예측하고자 한다면 에러 메시지를 받게 될 것입니다.\u003c/p\u003e\n\u003cp\u003e다음으로 하이퍼파라미터 multi_models=True는 다중 기간에 대한 확률적 예측을 위한 직접적인 전략을 정의합니다. 이는 각 미래 n 기간을 위해 별도의 n개 모델을 구축하는 전략을 의미합니다. 이는 기본 값이기 때문에 별도로 명시할 필요가 없습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_9.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e모델링과 예측을 한 뒤에는 실제 값과 예측값을 플롯에 함께 표시해보겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e matplotlib.\u003cspan class=\"hljs-property\"\u003epyplot\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e plt\ntarget.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(label=\u003cspan class=\"hljs-string\"\u003e'훈련 데이터'\u003c/span\u003e)\npred.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(label=\u003cspan class=\"hljs-string\"\u003e'예측값'\u003c/span\u003e)\ntest[\u003cspan class=\"hljs-string\"\u003e'Weekly_Sales'\u003c/span\u003e][:n].\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(label=\u003cspan class=\"hljs-string\"\u003e'실제값'\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(J) 그림은 결과를 플롯한 것입니다:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_10.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003cp\u003e성능을 측정해 봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"평균 절대 오차:\"\u003c/span\u003e, \u003cspan class=\"hljs-title function_\"\u003emae\u003c/span\u003e(test[\u003cspan class=\"hljs-string\"\u003e'Weekly_Sales'\u003c/span\u003e][:n], pred))\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"평균 절대 백분율 오차:\"\u003c/span\u003e, \u003cspan class=\"hljs-title function_\"\u003emape\u003c/span\u003e(test[\u003cspan class=\"hljs-string\"\u003e'Weekly_Sales'\u003c/span\u003e][:n], pred))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e평균 절대 오차: 119866.3976798996\u003c/li\u003e\n\u003cli\u003e평균 절대 백분율 오차: 7.738643655822244\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eMAPE는 7.73%로 이전 모델보다 낮습니다. 이전 모델을 선택할 수도 있었을 텐데요. 그 다음으로는 분위 예측을 생성하는 방법을 배워보겠습니다.\u003c/p\u003e\n\u003cp\u003e(3) 분위 예측\u003c/p\u003e\n\u003cp\u003e앞서 언급한대로 quantiles=[0.01,0.05,0.50,0.95,0.99]을 추가합니다. 샘플이 5개 있기 때문에 .predict()에서 num_samples=5를 지정할 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e darts.\u003cspan class=\"hljs-property\"\u003emodels\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eLinearRegressionModel\u003c/span\u003e\nn = \u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e\nchunk_length = n\nmodel = \u003cspan class=\"hljs-title class_\"\u003eLinearRegressionModel\u003c/span\u003e(\n    lags=\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e,\n    lags_past_covariates=\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e,\n    lags_future_covariates=[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e11\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e],\n    output_chunk_length=chunk_length,\n    likelihood = \u003cspan class=\"hljs-string\"\u003e'quantile'\u003c/span\u003e, # \u003cspan class=\"hljs-string\"\u003e'quantile'\u003c/span\u003e 또는 \u003cspan class=\"hljs-string\"\u003e'poisson'\u003c/span\u003e으로 설정할 수 있습니다.\n    # \u003cspan class=\"hljs-string\"\u003e'quantile'\u003c/span\u003e로 설정할 경우, sklearn.\u003cspan class=\"hljs-property\"\u003elinear_model\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eQuantileRegressor\u003c/span\u003e가 사용됩니다.\n    # \u003cspan class=\"hljs-string\"\u003e'poisson'\u003c/span\u003e으로 설정할 경우, sklearn.\u003cspan class=\"hljs-property\"\u003elinear_model\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ePoissonRegressor\u003c/span\u003e가 사용됩니다.\n    quantiles=[\u003cspan class=\"hljs-number\"\u003e0.01\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0.05\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0.50\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0.95\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e0.99\u003c/span\u003e]\n)\nmodel.\u003cspan class=\"hljs-title function_\"\u003efit\u003c/span\u003e(target, past_covariates=past_cov, future_covariates=future_cov)\npred = model.\u003cspan class=\"hljs-title function_\"\u003epredict\u003c/span\u003e(n, num_samples=\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e)\npred\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e각 기간에 대한 예측은 한 샘플 대신 5개의 샘플이 될 것입니다. (그래서 Darts의 데이터 형식을 \"샘플\"이라고 부릅니다.)\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_11.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e실제 값과 확률 예측을 그래플에 플로팅할 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e matplotlib.\u003cspan class=\"hljs-property\"\u003epyplot\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e plt\ntarget.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(label=\u003cspan class=\"hljs-string\"\u003e'train'\u003c/span\u003e)\npred.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(label=\u003cspan class=\"hljs-string\"\u003e'prediction'\u003c/span\u003e)\ntest[\u003cspan class=\"hljs-string\"\u003e'Weekly_Sales'\u003c/span\u003e][:n].\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(label=\u003cspan class=\"hljs-string\"\u003e'actual'\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting_12.png\" alt=\"위 예측은 확률적 예측을 위한 연한 파란색 영역을 포함합니다.\"\u003e\u003c/p\u003e\n\u003cp\u003e결론\u003c/p\u003e\n\u003cp\u003e이 장에서는 Darts 라이브러리를 사용하여 선형 회귀 모델 클래스를 배웠습니다. 이를 통해 여러 기간의 확률적 예측을 위한 선형 모델을 구축할 수 있습니다. 과거 및 미래 공변량을 포함한 구문 및 다기간 앞쪽 예측을 위한 직접 또는 재귀적 예측 전략의 옵션을 배웠습니다. 또한 모델을 분위수 확률적 예측을 위해 설정하는 방법도 배웠습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 장에서는 최신 회귀 기반 시계열 기법을 마무리합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e자동 ARIMA!\u003c/li\u003e\n\u003cli\u003e쉬운 시계열 데이터 형식\u003c/li\u003e\n\u003cli\u003e다기간 확률 예측을 위한 선형 회귀\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e다음 단원에서는 트리 기반 모델링 기법을 공부할 예정입니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e트리 기반 시계열 예측에 대한 튜토리얼\u003c/li\u003e\n\u003cli\u003e다기간 시계열 예측에 대한 튜토리얼\u003c/li\u003e\n\u003cli\u003e다기간 시계열 확률 예측을 위한 트리 기반 XGB, LightGBM 및 CatBoost 모델\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e샘플 eBook 챕터(무료): \u003ca href=\"https://github.com/dataman-git/modern-time-series/blob/main/20240522beauty_TOC.pdf\" rel=\"nofollow\" target=\"_blank\"\u003e여기\u003c/a\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe Innovation Press, LLC의 스태프 여러분께 감사드립니다. 아름다운 형식으로 책을 재현하여 즐거운 독서 경험을 선사해 주셨습니다. 저희는 Teachable 플랫폼을 선택하여 eBook을 전 세계 독자에게 분배하며 무거운 오버헤드 없이 알찬 서비스를 제공합니다. 결제 거래는 Teachable.com에서 신뢰성 있고 안전하게 처리됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eTeachable.com에서의 eBook: $22.50\n\u003ca href=\"https://drdataman.teachable.com/p/home\" rel=\"nofollow\" target=\"_blank\"\u003e여기에서 확인하세요\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eAmazon.com에서의 인쇄판: $65 \u003ca href=\"https://a.co/d/25FVsMx\" rel=\"nofollow\" target=\"_blank\"\u003e여기서 확인하세요\u003c/a\u003e\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e인쇄판은 광택이 도는 표지, 컬러 프린트, 아름다운 Springer 폰트와 레이아웃이 매력적인 읽기를 위해 채택되었습니다. 7.5 x 9.25인치의 포털 크기로 대부분의 책장에 적합합니다.\u003c/li\u003e\n\u003cli\u003e\"이 책은 Kuo의 시계열 분석에 대한 심층적인 이해와 예측 분석 및 이상 탐지에 대한 응용을 입증하는 것입니다. 이 책은 독자들이 현실 세계의 도전 과제에 대처하는 데 필요한 기술을 제공합니다. 데이터 과학으로의 직업 전환을 추구하는 사람들에게 특히 가치 있는 자료입니다. Kuo는 전통적인 기법과 최신 기법을 자세히 탐구했습니다. Kuo는 신경망 및 다른 고급 알고리즘에 대한 논의를 통합함으로써, 분야의 최신 동향과 발전을 반영했습니다. 이것은 독자가 확립된 방법뿐만 아니라 데이터 과학 분야의 가장 최신이며 혁신적인 기법과 상호 작용할 준비가 되어 있는 것을 보장합니다. Kuo의 유쾌한 글쓰기 스타일로 책의 알기 쉽고 접근성이 향상되었습니다. 그는 복잡한 수학적 및 통계적 개념을 낯설지 않게 만들어 손실되지 않도록 했습니다.\"\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e모던 시계열 예측: 예측 분석과 이상 탐지를 위한\u003c/h1\u003e\n\u003cp\u003eChapter 0: 서문\u003c/p\u003e\n\u003cp\u003eChapter 1: 소개\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e장 2: 비즈니스 예측용 선지자\u003c/h2\u003e\n\u003ch2\u003e장 3: 튜토리얼 I: 추세 + 계절성 + 휴일 및 이벤트\u003c/h2\u003e\n\u003ch2\u003e장 4: 튜토리얼 II: 추세 + 계절성 + 휴일 및 이벤트 + 자기회귀(AR) + 지연 회귀자 + 미래 회귀자\u003c/h2\u003e\n\u003ch2\u003e장 5: 시계열에서의 변화점 탐지\u003c/h2\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e6장: 시계열 확률 예측을 위한 몬테카를로 시뮬레이션\u003c/p\u003e\n\u003cp\u003e7장: 시계열 확률 예측을 위한 분위수 회귀\u003c/p\u003e\n\u003cp\u003e8장: 시계열 확률 예측을 위한 일치 예측\u003c/p\u003e\n\u003cp\u003e9장: 시계열 확률 예측을 위한 일치화된 분위수 회귀\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch3\u003e제 10 장: 자동 ARIMA!\u003c/h3\u003e\n\u003ch3\u003e제 11 장: 시계열 데이터 형식 쉽게 만들기\u003c/h3\u003e\n\u003ch3\u003e제 12 장: 다기간 확률 예측을 위한 선형 회귀\u003c/h3\u003e\n\u003ch3\u003e제 13 장: 트리 기반 시계열 모델용 피처 엔지니어링\u003c/h3\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eChapter 14: 다기간 시계열 예측을 위한 두 가지 주요 전략\u003c/p\u003e\n\u003cp\u003eChapter 15: Tree 기반 XGB, LightGBM 및 CatBoost 모델에 대한 다기간 시계열 확률적 예측\u003c/p\u003e\n\u003cp\u003eChapter 16: 시계열 모델링 기술의 진화\u003c/p\u003e\n\u003cp\u003eChapter 17: 시계열 확률적 예측을 위한 Deep Learning 기반 DeepAR\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch1\u003eChapter 18: 주식 가격을 위한 확률론적 예측 애플리케이션\u003c/h1\u003e\n\u003ch1\u003eChapter 19: RNN에서 Transformer 기반 시계열 모델로\u003c/h1\u003e\n\u003ch1\u003eChapter 20: 해석 가능한 시계열 예측을 위한 Temporal Fusion Transformer\u003c/h1\u003e\n\u003ch1\u003eChapter 21: 시계열 예측을 위한 오픈 소스 Lag-Llama 튜토리얼\u003c/h1\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-07-09-LinearModelsforMulti-periodProbabilisticForecasting"},"buildId":"QAkYP0lvl03W-5CKD69kb","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>