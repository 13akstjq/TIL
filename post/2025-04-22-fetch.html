<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Next.js 15에서 fetch API 활용하는 최신 방법 | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-fetch" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Next.js 15에서 fetch API 활용하는 최신 방법 | TIL" data-gatsby-head="true"/><meta property="og:title" content="Next.js 15에서 fetch API 활용하는 최신 방법 | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-fetch" data-gatsby-head="true"/><meta name="twitter:title" content="Next.js 15에서 fetch API 활용하는 최신 방법 | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2025-04-22 03:02" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/0eef537492fed77a.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/0eef537492fed77a.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/post/%5Bslug%5D-8ded8b979ba73586.js" defer=""></script><script src="/TIL/_next/static/olPs1cVezSGTqD7OaewDI/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/olPs1cVezSGTqD7OaewDI/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Next.js 15에서 fetch API 활용하는 최신 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Next.js 15에서 fetch API 활용하는 최신 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Apr 22, 2025</span><span class="posts_reading_time__f7YPP">10<!-- --> min read</span></span></div></div></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h1>fetch</h1>
<p>Next.js에서는 기본 웹 fetch() API를 확장해서, 서버에서 각 요청마다 고유한 지속 캐싱(persistent caching)과 재검증(revalidation) 규칙을 설정할 수 있도록 했어요.</p>
<p>브라우저에서는 fetch 요청 시 cache 옵션이 브라우저 HTTP 캐시와 어떻게 상호작용할지를 지정하잖아요? 그런데 Next.js의 확장된 fetch에서는 서버 사이드에서 할 때 이 cache 옵션이 프레임워크가 관리하는 지속 데이터 캐시(persistent Data Cache)와 어떻게 상호작용할지를 결정해줘요.</p>
<p>즉, 서버 컴포넌트 안에서 async/await와 함께 그냥 fetch를 호출해도, 이 캐시 전략들이 작동하면서 성능 향상 및 데이터 최신성을 관리해준다는 뜻이에요.</p>
<hr>
<h3>추가 설명</h3>
<ul>
<li>
<p><strong>지속 데이터 캐시란?</strong><br>
서버에서 한 번 가져온 데이터를 일정 시간 동안 저장해서, 같은 데이터를 재요청할 때 네트워크 호출을 줄여주는 역할을 해요. 그래서 유저 입장에선 페이지가 더 빨리 로드되고, 서버 부담도 줄어들죠.</p>
</li>
<li>
<p><strong>재검증(revalidation)이 뭐예요?</strong><br>
캐시된 데이터가 오래되었는지 주기적으로 체크해서, 최신 데이터가 필요하면 다시 fetch를 하는 거예요.</p>
</li>
<li>
<p><strong>서버 컴포넌트에서 fetch를 쓴다?</strong><br>
Next.js 13부터 도입된 서버 컴포넌트 덕분에, 서버에서 비동기적으로 데이터를 패칭하고 바로 렌더링할 수 있어요. 클라이언트에서 데이터 로딩 처리하는 걸 줄일 수 있죠.</p>
</li>
</ul>
<hr>
<h3>예시 코드</h3>
<pre><code class="hljs language-jsx"><span class="hljs-comment">// 서버 컴포넌트 내에서 fetch 사용</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://api.example.com/data'</span>, {
    <span class="hljs-attr">cache</span>: <span class="hljs-string">'force-cache'</span>  <span class="hljs-comment">// 고정된 캐시 전략 적용</span>
  });
  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> res.<span class="hljs-title function_">json</span>();

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">h1</span>></span>서버에서 가져온 데이터<span class="hljs-tag">&#x3C;/<span class="hljs-name">h1</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">pre</span>></span>{JSON.stringify(data, null, 2)}<span class="hljs-tag">&#x3C;/<span class="hljs-name">pre</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  )
}
</code></pre>
<p>Next.js의 fetch API 확장 덕분에 서버 쪽 데이터 요청을 더 똑똑하게 관리할 수 있으니, 다음 프로젝트에 꼭 활용해보세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>여러분, Next.js에서 데이터를 불러오는 방법에 대해 이야기해볼게요. 위에 있는 코드를 보시면, <code>fetch</code> 함수로 외부 API에서 데이터를 받아와서 화면에 포스트 리스트를 렌더링하는 아주 기본적인 예제입니다.</p>
<pre><code class="hljs language-jsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">let</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://api.vercel.app/blog'</span>)
  <span class="hljs-keyword">let</span> posts = <span class="hljs-keyword">await</span> data.<span class="hljs-title function_">json</span>()
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">ul</span>></span>
      {posts.map((post) => (
        <span class="hljs-tag">&#x3C;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{post.id}</span>></span>{post.title}<span class="hljs-tag">&#x3C;/<span class="hljs-name">li</span>></span>
      ))}
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">ul</span>></span></span>
  )
}
</code></pre>
<h3>Next.js의 fetch() API 활용</h3>
<p>Next.js는 기본적으로 웹의 <code>fetch()</code> API를 확장해서 제공하는데요, 그래서 우리가 익숙한 <code>fetch</code> 옵션들을 그대로 사용할 수 있다는 점이 편리해요. 이번에 살펴볼 옵션 중 하나가 <code>cache</code> 옵션입니다.</p>
<h3><code>options.cache</code></h3>
<p><code>cache</code> 옵션은 데이터를 어떻게 캐싱할지를 결정하는 역할을 해요. 예를 들어, 기본적으로는 서버 컴포넌트에서 데이터를 패칭할 때 <code>cache</code>가 적용되어, 다음에 같은 요청이 오면 캐시된 데이터를 바로 사용할 수 있도록 돼 있죠. 이걸 조절하면, 실시간 데이터가 중요하거나, 너무 자주 데이터를 갱신할 필요가 있을 때 유용해요.</p>
<ul>
<li><code>"default"</code>: 기본 캐싱 정책을 따릅니다.</li>
<li><code>"no-cache"</code>: 매번 네트워크에서 새 데이터를 받아옵니다.</li>
<li><code>"force-cache"</code>: 캐시된 데이터만 사용하고 네트워크 요청은 안 합니다.</li>
<li><code>"only-if-cached"</code>: 캐시된 데이터가 없으면 실패합니다.</li>
</ul>
<p>예를 들어, 이렇게 쓸 수 있어요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://api.vercel.app/blog'</span>, { <span class="hljs-attr">cache</span>: <span class="hljs-string">'no-cache'</span> })
</code></pre>
<p>이렇게 하면 무조건 최신 데이터를 받아오기 때문에, 실시간 뉴스나 가격 정보처럼 자주 업데이트되는 데이터에 적합합니다.</p>
<hr>
<h3>한 가지 꿀팁!</h3>
<p>Next.js 13부터는 <code>fetch</code>에 <code>next</code> 옵션도 함께 쓸 수 있는데요, 굉장히 강력합니다. 예를 들어 <code>next: { revalidate: 10 }</code> 옵션을 넣으면, 데이터를 받아와서 10초마다 캐시를 리프레시하도록 할 수 있어요. 이렇게 하면 서버 부하도 줄이고, 사용자는 어느 정도 최신 데이터를 볼 수 있죠.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://api.vercel.app/blog'</span>, {
  <span class="hljs-attr">next</span>: { <span class="hljs-attr">revalidate</span>: <span class="hljs-number">10</span> }
})
</code></pre>
<p>한마디로, 여러분 프로젝트 상황에 맞게 캐시 전략을 유연하게 조절해 보세요. 그럼 데이터 패칭도 똑똑하게 할 수 있답니다!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Next.js에서 요청이 데이터 캐시와 어떻게 상호작용할지 설정하는 방법에 대해 설명해드릴게요.</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">`https://...`</span>, { <span class="hljs-attr">cache</span>: <span class="hljs-string">'force-cache'</span> | <span class="hljs-string">'no-store'</span> })
</code></pre>
<p>여기서 cache 옵션은 세 가지 주요 상태가 있어요:</p>





















<table><thead><tr><th>옵션</th><th>동작 설명</th></tr></thead><tbody><tr><td>auto (기본값)</td><td>개발 환경에서는 매 요청마다 원격 서버에서 데이터를 가져와요. 하지만 빌드 시점에 페이지가 정적으로 사전 렌더링되면 그때 한 번만 가져와요. 그리고 동적 API가 감지되면 매 요청마다 데이터를 가져오죠.</td></tr><tr><td>no-store</td><td>동적 API 여부와 상관없이 항상 매 요청마다 원격 서버에서 데이터를 가져와요. 캐시를 사용하지 않는 느낌이에요.</td></tr><tr><td>force-cache</td><td>Next.js의 데이터 캐시에서 일치하는 요청이 있는지 찾아요. ‘신선한’ 캐시가 있으면 캐시에서 바로 반환하고, 없거나 오래된 캐시라면 원격 서버에서 새로 데이터를 받아와 캐시를 업데이트해요.</td></tr></tbody></table>
<h3>추가 꿀팁!</h3>
<ul>
<li>캐시가 ‘신선한(fresh)’하다는 말은 캐시된 데이터가 아직 유효하다는 뜻이에요. 이를 판단하는 기준은 Next.js 내부 정책이나 <code>revalidate</code> 옵션에 따라 달라집니다.</li>
<li><code>force-cache</code>를 사용하면 빌드 시점의 데이터를 최대한 활용하면서도, 변경사항이 있을 때만 서버에서 최신 데이터를 받을 수 있어서 효율적이에요.</li>
<li>개발 중에는 기본 <code>auto</code> 모드가 편리하지만, 프로덕션 환경에서는 상황에 맞게 <code>no-store</code> (실시간 업데이트 필요 시)나 <code>force-cache</code> (최소한의 요청으로 성능 최적화 시)를 선택하는 게 좋아요.</li>
</ul>
<h3>options.next.revalidate</h3>
<p>이 옵션은 캐시를 갱신하는 주기를 설정할 때 쓰입니다. 예를 들어,</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://...'</span>, { <span class="hljs-attr">next</span>: { <span class="hljs-attr">revalidate</span>: <span class="hljs-number">60</span> } })
</code></pre>
<p>이렇게 설정하면, 캐시된 데이터가 60초가 지나면 다음 요청 때 새로 갱신해요. 다시 말해, 1분마다 데이터를 새로고침하는 것과 같죠.</p>
<p>이걸 적절히 활용하면 새로 고침의 빈도와 SEO 최적화를 균형 있게 맞출 수 있습니다.</p>
<hr>
<p>Next.js의 데이터 캐시는 페이지 성능과 사용자 경험에 큰 영향을 주니, 개발 환경과 서비스 특성에 맞게 잘 설정해 보세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>fetch 함수에 <code>next: { revalidate: ... }</code> 옵션을 주면 리소스의 캐시 수명을 초 단위로 설정할 수 있어요. 쉽게 말해, 캐시가 얼마 동안 유지될지 정하는 거죠. 이 옵션에 따라 캐싱 동작이 달라집니다.</p>





















<table><thead><tr><th>revalidate 값</th><th>의미</th></tr></thead><tbody><tr><td>false</td><td>리소스를 무한정 캐시해요. (사실상 revalidate: Infinity와 같아요.) HTTP 캐시는 오랫동안 쓰다가 오래된 캐시를 지울 순 있지만, 기본적으로 무제한으로 저장합니다.</td></tr><tr><td>0</td><td>캐시를 절대 하지 않아요. 항상 리소스를 새롭게 받아옵니다.</td></tr><tr><td>number</td><td>숫자(초)만큼 캐시 생명주기를 정해요. 예를 들어 60이면 60초간 캐시 유지.</td></tr></tbody></table>
<h3>좀 더 알아두면 좋은 점</h3>
<ul>
<li>특정 fetch 요청에서 설정한 <code>revalidate</code> 값이 라우트(route) 기본 값보다 작으면, 라우트 전체의 리밸리데이트 간격도 그만큼 줄어듭니다.</li>
<li>같은 URL을 가진 두 개의 fetch 요청이 각각 다른 <code>revalidate</code> 값을 가지고 있다면, 더 짧은 시간(낮은 값)이 적용됩니다.</li>
<li><code>revalidate</code>를 숫자로 주면 따로 <code>cache</code> 옵션을 설정하지 않아도 돼요.</li>
<li><code>revalidate</code>와 <code>cache</code> 옵션이 모순되는 설정(예: <code>revalidate: 3600</code>인데 <code>cache: 'no-store'</code>)을 하면 에러가 발생해요.</li>
</ul>
<h3>참고로,</h3>
<p>이 옵션은 Next.js에서 제공하는 기능으로, 서버 측 데이터 패칭 시 자동으로 ISR(Incremental Static Regeneration)을 조절하는데 유용합니다. 개발할 때 캐시 정책을 유연하게 조절하면, 페이지 성능과 최신성 사이에서 좋은 균형을 맞출 수 있어요.</p>
<p>혹시 어떻게 쓰는지 구체적인 예시가 궁금하다면 알려주세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h3>options.next.tags</h3>
<pre><code class="hljs language-js"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">`https://...`</span>, { <span class="hljs-attr">next</span>: { <span class="hljs-attr">tags</span>: [<span class="hljs-string">'collection'</span>] } })
</code></pre>
<p><code>options.next.tags</code>는 요청에 캐시 태그(cache tags)를 설정하는 옵션이에요. 캐시 태그를 지정해두면, 나중에 <code>revalidateTag</code> API를 사용해서 해당 태그가 붙은 데이터만 선택적으로 갱신할 수 있답니다. 이렇게 하면 불필요하게 전체 데이터를 다시 받아오지 않아도 되니까 성능 최적화에 큰 도움이 되죠.</p>
<ul>
<li><strong>태그 길이 제한</strong>: 각 태그는 최대 256자까지만 작성할 수 있어요.</li>
<li><strong>태그 개수 제한</strong>: 한 요청당 최대 128개의 태그를 설정할 수 있어요.</li>
</ul>
<hr>
<h3>추가 팁!</h3>
<p><code>revalidateTag</code>를 사용하면 페이지나 일부 컴포넌트에서 특정 태그를 기반으로 데이터를 갱신할 수 있어서 리얼타임 데이터 반영이나, 변경이 잦은 부분만 업데이트할 때 매우 유용해요.</p>
<p>예를 들어, 쇼핑몰에서 ‘상품 컬렉션(collection)’ 태그를 붙인 데이터만 따로 갱신하고 싶을 때 편리하겠죠? 커스텀 태그를 잘 활용해서 앱 성능과 사용자 경험을 한층 개선해 보세요!</p>
<hr>
<h2>문제 해결 (Troubleshooting)</h2>

























<table><thead><tr><th>문제 상황</th><th>해결 방법</th></tr></thead><tbody><tr><td>태그가 너무 길 때</td><td>태그 길이를 256자 이내로 줄이세요.</td></tr><tr><td>태그 개수가 128개를 초과할 때</td><td>필요 없는 태그를 제거하거나 그룹화하세요.</td></tr><tr><td>데이터가 갱신되지 않을 때</td><td><code>revalidateTag</code>가 올바르게 호출되었는지 확인하세요.</td></tr><tr><td>캐시가 정상 동작하지 않을 때</td><td>fetch 옵션과 캐시 정책을 다시 점검해보세요.</td></tr></tbody></table>
<p>혹시 캐시 관련해서 더 궁금한 점이나, 특정 상황에서 어떻게 활용하면 좋은지 알고 싶다면 언제든 질문해 주세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h3>Fetch 기본 자동 no-store와 캐시: <code>no-store</code>가 개발 환경에서 최신 데이터를 보여주지 않는 이유</h3>
<p>Next.js에서 개발할 때, 특히 <strong>Server Components</strong>를 사용할 때 조금 특이한 캐싱 동작이 있어요. 바로 HMR(Hot Module Replacement) 과정에서 fetch 응답을 캐시에 저장한다는 점입니다. 이 덕분에 빠른 응답 속도와 함께, API 호출 비용도 아낄 수 있죠.</p>
<p>그런데 여기서 중요한 점! HMR 캐시는 기본적으로 모든 fetch 요청에 적용되는데, 심지어 <code>cache: 'no-store'</code> 옵션을 넣어도 마찬가지라는 거예요. 즉, 기본값인 <code>no-cache</code>나 <code>cache: 'no-store'</code>를 사용해도 HMR 중에는 캐시가 유지되어서 <strong>최신 데이터가 바로바로 안 보일 수 있습니다</strong>.</p>
<p>하지만 실제로 페이지를 새로고침하거나 다른 경로로 이동할 때는 캐시가 깨져서 다시 최신 데이터를 가져오게 돼요.</p>
<p>이게 개발할 때 가끔 데이터를 바로바로 바꿔서 테스트하는 과정에서 헷갈리게 할 수 있으니 주의해야 합니다.</p>
<p>추가로 궁금하다면 <a href="https://nextjs.org/docs/advanced-features/react-18/server-components#hot-module-replacement-cache" rel="nofollow" target="_blank">serverComponentsHmrCache 문서</a>도 확인해보세요!</p>
<hr>
<h3>참고로 알아두면 좋은 점</h3>
<ul>
<li><code>cache: 'no-store'</code> 옵션은 <strong>프로덕션 환경에선 실제로 캐시를 안 해서 무조건 최신 데이터를 가져오지만</strong>,</li>
<li>개발 모드에서만 HMR 캐시가 이를 덮어씌웁니다.</li>
<li>이 때문에 개발 중에는 <strong>fetch 요청이 예상과 다르게 동작할 수 있으니 주의</strong>해야 해요.</li>
<li>만약 진짜 최신 데이터를 계속 보고 싶다면, <a href="https://nextjs.org/docs/basic-features/data-fetching#refreshing-data-on-client-navigation" rel="nofollow" target="_blank">페이지를 새로고침하거나 다른 경로로 이동하는 방법</a>을 쓰는 게 좋습니다.</li>
</ul>
<p>이런 Next.js 내부 동작 방식을 살펴보는 건 개발 생산성을 높이고, 예상치 못한 버그를 막는 데 큰 도움이 됩니다!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>버전 히스토리</h2>













<table><thead><tr><th>버전</th><th>변경 사항</th></tr></thead><tbody><tr><td><code>v13.0.0</code></td><td><code>fetch</code> 기능 추가됨</td></tr></tbody></table>
<p>여기서 <code>fetch</code>는 데이터를 서버에서 가져올 때 자주 사용하는 기능인데, 이 버전부터 공식적으로 도입됐다는 뜻이에요. 개발할 때 API 호출이 필요하면 이 기능을 활용해보세요. 예전에는 XMLHttpRequest나 다른 라이브러리를 많이 썼는데, <code>fetch</code>는 Promise 기반이라 비동기 처리가 훨씬 깔끔해져서 요즘은 표준처럼 쓰이고 있답니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Next.js 15에서 fetch API 활용하는 최신 방법","description":"","date":"2025-04-22 03:02","slug":"2025-04-22-fetch","content":"\n\n# fetch\n\nNext.js에서는 기본 웹 fetch() API를 확장해서, 서버에서 각 요청마다 고유한 지속 캐싱(persistent caching)과 재검증(revalidation) 규칙을 설정할 수 있도록 했어요.\n\n브라우저에서는 fetch 요청 시 cache 옵션이 브라우저 HTTP 캐시와 어떻게 상호작용할지를 지정하잖아요? 그런데 Next.js의 확장된 fetch에서는 서버 사이드에서 할 때 이 cache 옵션이 프레임워크가 관리하는 지속 데이터 캐시(persistent Data Cache)와 어떻게 상호작용할지를 결정해줘요.\n\n즉, 서버 컴포넌트 안에서 async/await와 함께 그냥 fetch를 호출해도, 이 캐시 전략들이 작동하면서 성능 향상 및 데이터 최신성을 관리해준다는 뜻이에요.\n\n---\n\n### 추가 설명\n\n- **지속 데이터 캐시란?**  \n  서버에서 한 번 가져온 데이터를 일정 시간 동안 저장해서, 같은 데이터를 재요청할 때 네트워크 호출을 줄여주는 역할을 해요. 그래서 유저 입장에선 페이지가 더 빨리 로드되고, 서버 부담도 줄어들죠.\n\n- **재검증(revalidation)이 뭐예요?**  \n  캐시된 데이터가 오래되었는지 주기적으로 체크해서, 최신 데이터가 필요하면 다시 fetch를 하는 거예요.\n\n- **서버 컴포넌트에서 fetch를 쓴다?**  \n  Next.js 13부터 도입된 서버 컴포넌트 덕분에, 서버에서 비동기적으로 데이터를 패칭하고 바로 렌더링할 수 있어요. 클라이언트에서 데이터 로딩 처리하는 걸 줄일 수 있죠.\n\n---\n\n### 예시 코드\n\n```jsx\n// 서버 컴포넌트 내에서 fetch 사용\nexport default async function Page() {\n  const res = await fetch('https://api.example.com/data', {\n    cache: 'force-cache'  // 고정된 캐시 전략 적용\n  });\n  const data = await res.json();\n\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003e서버에서 가져온 데이터\u003c/h1\u003e\n      \u003cpre\u003e{JSON.stringify(data, null, 2)}\u003c/pre\u003e\n    \u003c/div\u003e\n  )\n}\n```\n\nNext.js의 fetch API 확장 덕분에 서버 쪽 데이터 요청을 더 똑똑하게 관리할 수 있으니, 다음 프로젝트에 꼭 활용해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여러분, Next.js에서 데이터를 불러오는 방법에 대해 이야기해볼게요. 위에 있는 코드를 보시면, `fetch` 함수로 외부 API에서 데이터를 받아와서 화면에 포스트 리스트를 렌더링하는 아주 기본적인 예제입니다.\n\n```jsx\nexport default async function Page() {\n  let data = await fetch('https://api.vercel.app/blog')\n  let posts = await data.json()\n  return (\n    \u003cul\u003e\n      {posts.map((post) =\u003e (\n        \u003cli key={post.id}\u003e{post.title}\u003c/li\u003e\n      ))}\n    \u003c/ul\u003e\n  )\n}\n```\n\n### Next.js의 fetch() API 활용\n\nNext.js는 기본적으로 웹의 `fetch()` API를 확장해서 제공하는데요, 그래서 우리가 익숙한 `fetch` 옵션들을 그대로 사용할 수 있다는 점이 편리해요. 이번에 살펴볼 옵션 중 하나가 `cache` 옵션입니다.\n\n### `options.cache`\n\n`cache` 옵션은 데이터를 어떻게 캐싱할지를 결정하는 역할을 해요. 예를 들어, 기본적으로는 서버 컴포넌트에서 데이터를 패칭할 때 `cache`가 적용되어, 다음에 같은 요청이 오면 캐시된 데이터를 바로 사용할 수 있도록 돼 있죠. 이걸 조절하면, 실시간 데이터가 중요하거나, 너무 자주 데이터를 갱신할 필요가 있을 때 유용해요.\n\n- `\"default\"`: 기본 캐싱 정책을 따릅니다.\n- `\"no-cache\"`: 매번 네트워크에서 새 데이터를 받아옵니다.\n- `\"force-cache\"`: 캐시된 데이터만 사용하고 네트워크 요청은 안 합니다.\n- `\"only-if-cached\"`: 캐시된 데이터가 없으면 실패합니다.\n\n예를 들어, 이렇게 쓸 수 있어요:\n\n```js\nlet data = await fetch('https://api.vercel.app/blog', { cache: 'no-cache' })\n```\n\n이렇게 하면 무조건 최신 데이터를 받아오기 때문에, 실시간 뉴스나 가격 정보처럼 자주 업데이트되는 데이터에 적합합니다.\n\n---\n\n### 한 가지 꿀팁!\n\nNext.js 13부터는 `fetch`에 `next` 옵션도 함께 쓸 수 있는데요, 굉장히 강력합니다. 예를 들어 `next: { revalidate: 10 }` 옵션을 넣으면, 데이터를 받아와서 10초마다 캐시를 리프레시하도록 할 수 있어요. 이렇게 하면 서버 부하도 줄이고, 사용자는 어느 정도 최신 데이터를 볼 수 있죠.\n\n```js\nlet data = await fetch('https://api.vercel.app/blog', {\n  next: { revalidate: 10 }\n})\n```\n\n한마디로, 여러분 프로젝트 상황에 맞게 캐시 전략을 유연하게 조절해 보세요. 그럼 데이터 패칭도 똑똑하게 할 수 있답니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 요청이 데이터 캐시와 어떻게 상호작용할지 설정하는 방법에 대해 설명해드릴게요.\n\n```js\nfetch(`https://...`, { cache: 'force-cache' | 'no-store' })\n```\n\n여기서 cache 옵션은 세 가지 주요 상태가 있어요:\n\n| 옵션          | 동작 설명                                                                                           |\n|---------------|---------------------------------------------------------------------------------------------------|\n| auto (기본값) | 개발 환경에서는 매 요청마다 원격 서버에서 데이터를 가져와요. 하지만 빌드 시점에 페이지가 정적으로 사전 렌더링되면 그때 한 번만 가져와요. 그리고 동적 API가 감지되면 매 요청마다 데이터를 가져오죠. |\n| no-store      | 동적 API 여부와 상관없이 항상 매 요청마다 원격 서버에서 데이터를 가져와요. 캐시를 사용하지 않는 느낌이에요.                    |\n| force-cache   | Next.js의 데이터 캐시에서 일치하는 요청이 있는지 찾아요. ‘신선한’ 캐시가 있으면 캐시에서 바로 반환하고, 없거나 오래된 캐시라면 원격 서버에서 새로 데이터를 받아와 캐시를 업데이트해요.  |\n\n### 추가 꿀팁!\n\n- 캐시가 ‘신선한(fresh)’하다는 말은 캐시된 데이터가 아직 유효하다는 뜻이에요. 이를 판단하는 기준은 Next.js 내부 정책이나 `revalidate` 옵션에 따라 달라집니다.\n- `force-cache`를 사용하면 빌드 시점의 데이터를 최대한 활용하면서도, 변경사항이 있을 때만 서버에서 최신 데이터를 받을 수 있어서 효율적이에요.\n- 개발 중에는 기본 `auto` 모드가 편리하지만, 프로덕션 환경에서는 상황에 맞게 `no-store` (실시간 업데이트 필요 시)나 `force-cache` (최소한의 요청으로 성능 최적화 시)를 선택하는 게 좋아요.\n\n### options.next.revalidate\n\n이 옵션은 캐시를 갱신하는 주기를 설정할 때 쓰입니다. 예를 들어, \n\n```js\nfetch('https://...', { next: { revalidate: 60 } })\n```\n\n이렇게 설정하면, 캐시된 데이터가 60초가 지나면 다음 요청 때 새로 갱신해요. 다시 말해, 1분마다 데이터를 새로고침하는 것과 같죠.\n\n이걸 적절히 활용하면 새로 고침의 빈도와 SEO 최적화를 균형 있게 맞출 수 있습니다.\n\n---\n\nNext.js의 데이터 캐시는 페이지 성능과 사용자 경험에 큰 영향을 주니, 개발 환경과 서비스 특성에 맞게 잘 설정해 보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nfetch 함수에 `next: { revalidate: ... }` 옵션을 주면 리소스의 캐시 수명을 초 단위로 설정할 수 있어요. 쉽게 말해, 캐시가 얼마 동안 유지될지 정하는 거죠. 이 옵션에 따라 캐싱 동작이 달라집니다.\n\n| revalidate 값 | 의미                                                         |\n|---------------|--------------------------------------------------------------|\n| false         | 리소스를 무한정 캐시해요. (사실상 revalidate: Infinity와 같아요.) HTTP 캐시는 오랫동안 쓰다가 오래된 캐시를 지울 순 있지만, 기본적으로 무제한으로 저장합니다. |\n| 0             | 캐시를 절대 하지 않아요. 항상 리소스를 새롭게 받아옵니다.       |\n| number        | 숫자(초)만큼 캐시 생명주기를 정해요. 예를 들어 60이면 60초간 캐시 유지. |\n\n### 좀 더 알아두면 좋은 점\n\n- 특정 fetch 요청에서 설정한 `revalidate` 값이 라우트(route) 기본 값보다 작으면, 라우트 전체의 리밸리데이트 간격도 그만큼 줄어듭니다.\n- 같은 URL을 가진 두 개의 fetch 요청이 각각 다른 `revalidate` 값을 가지고 있다면, 더 짧은 시간(낮은 값)이 적용됩니다.\n- `revalidate`를 숫자로 주면 따로 `cache` 옵션을 설정하지 않아도 돼요.\n- `revalidate`와 `cache` 옵션이 모순되는 설정(예: `revalidate: 3600`인데 `cache: 'no-store'`)을 하면 에러가 발생해요.\n\n### 참고로,\n이 옵션은 Next.js에서 제공하는 기능으로, 서버 측 데이터 패칭 시 자동으로 ISR(Incremental Static Regeneration)을 조절하는데 유용합니다. 개발할 때 캐시 정책을 유연하게 조절하면, 페이지 성능과 최신성 사이에서 좋은 균형을 맞출 수 있어요.\n\n혹시 어떻게 쓰는지 구체적인 예시가 궁금하다면 알려주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### options.next.tags\n\n```js\nfetch(`https://...`, { next: { tags: ['collection'] } })\n```\n\n`options.next.tags`는 요청에 캐시 태그(cache tags)를 설정하는 옵션이에요. 캐시 태그를 지정해두면, 나중에 `revalidateTag` API를 사용해서 해당 태그가 붙은 데이터만 선택적으로 갱신할 수 있답니다. 이렇게 하면 불필요하게 전체 데이터를 다시 받아오지 않아도 되니까 성능 최적화에 큰 도움이 되죠.\n\n- **태그 길이 제한**: 각 태그는 최대 256자까지만 작성할 수 있어요.\n- **태그 개수 제한**: 한 요청당 최대 128개의 태그를 설정할 수 있어요.\n\n---\n\n### 추가 팁!\n\n`revalidateTag`를 사용하면 페이지나 일부 컴포넌트에서 특정 태그를 기반으로 데이터를 갱신할 수 있어서 리얼타임 데이터 반영이나, 변경이 잦은 부분만 업데이트할 때 매우 유용해요.\n\n예를 들어, 쇼핑몰에서 ‘상품 컬렉션(collection)’ 태그를 붙인 데이터만 따로 갱신하고 싶을 때 편리하겠죠? 커스텀 태그를 잘 활용해서 앱 성능과 사용자 경험을 한층 개선해 보세요! \n\n---\n\n## 문제 해결 (Troubleshooting)\n\n| 문제 상황                        | 해결 방법                                 |\n|-------------------------------|----------------------------------------|\n| 태그가 너무 길 때               | 태그 길이를 256자 이내로 줄이세요.        |\n| 태그 개수가 128개를 초과할 때   | 필요 없는 태그를 제거하거나 그룹화하세요. |\n| 데이터가 갱신되지 않을 때       | `revalidateTag`가 올바르게 호출되었는지 확인하세요. |\n| 캐시가 정상 동작하지 않을 때   | fetch 옵션과 캐시 정책을 다시 점검해보세요.   |\n\n혹시 캐시 관련해서 더 궁금한 점이나, 특정 상황에서 어떻게 활용하면 좋은지 알고 싶다면 언제든 질문해 주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### Fetch 기본 자동 no-store와 캐시: `no-store`가 개발 환경에서 최신 데이터를 보여주지 않는 이유\n\nNext.js에서 개발할 때, 특히 **Server Components**를 사용할 때 조금 특이한 캐싱 동작이 있어요. 바로 HMR(Hot Module Replacement) 과정에서 fetch 응답을 캐시에 저장한다는 점입니다. 이 덕분에 빠른 응답 속도와 함께, API 호출 비용도 아낄 수 있죠.\n\n그런데 여기서 중요한 점! HMR 캐시는 기본적으로 모든 fetch 요청에 적용되는데, 심지어 `cache: 'no-store'` 옵션을 넣어도 마찬가지라는 거예요. 즉, 기본값인 `no-cache`나 `cache: 'no-store'`를 사용해도 HMR 중에는 캐시가 유지되어서 **최신 데이터가 바로바로 안 보일 수 있습니다**. \n\n하지만 실제로 페이지를 새로고침하거나 다른 경로로 이동할 때는 캐시가 깨져서 다시 최신 데이터를 가져오게 돼요.\n\n이게 개발할 때 가끔 데이터를 바로바로 바꿔서 테스트하는 과정에서 헷갈리게 할 수 있으니 주의해야 합니다.\n\n추가로 궁금하다면 [serverComponentsHmrCache 문서](https://nextjs.org/docs/advanced-features/react-18/server-components#hot-module-replacement-cache)도 확인해보세요!\n\n---\n\n### 참고로 알아두면 좋은 점\n\n- `cache: 'no-store'` 옵션은 **프로덕션 환경에선 실제로 캐시를 안 해서 무조건 최신 데이터를 가져오지만**,\n- 개발 모드에서만 HMR 캐시가 이를 덮어씌웁니다.\n- 이 때문에 개발 중에는 **fetch 요청이 예상과 다르게 동작할 수 있으니 주의**해야 해요.\n- 만약 진짜 최신 데이터를 계속 보고 싶다면, [페이지를 새로고침하거나 다른 경로로 이동하는 방법](https://nextjs.org/docs/basic-features/data-fetching#refreshing-data-on-client-navigation)을 쓰는 게 좋습니다.\n\n이런 Next.js 내부 동작 방식을 살펴보는 건 개발 생산성을 높이고, 예상치 못한 버그를 막는 데 큰 도움이 됩니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 버전 히스토리\n\n| 버전       | 변경 사항           |\n|------------|---------------------|\n| `v13.0.0`  | `fetch` 기능 추가됨 |\n\n여기서 `fetch`는 데이터를 서버에서 가져올 때 자주 사용하는 기능인데, 이 버전부터 공식적으로 도입됐다는 뜻이에요. 개발할 때 API 호출이 필요하면 이 기능을 활용해보세요. 예전에는 XMLHttpRequest나 다른 라이브러리를 많이 썼는데, `fetch`는 Promise 기반이라 비동기 처리가 훨씬 깔끔해져서 요즘은 표준처럼 쓰이고 있답니다.","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":10},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch1\u003efetch\u003c/h1\u003e\n\u003cp\u003eNext.js에서는 기본 웹 fetch() API를 확장해서, 서버에서 각 요청마다 고유한 지속 캐싱(persistent caching)과 재검증(revalidation) 규칙을 설정할 수 있도록 했어요.\u003c/p\u003e\n\u003cp\u003e브라우저에서는 fetch 요청 시 cache 옵션이 브라우저 HTTP 캐시와 어떻게 상호작용할지를 지정하잖아요? 그런데 Next.js의 확장된 fetch에서는 서버 사이드에서 할 때 이 cache 옵션이 프레임워크가 관리하는 지속 데이터 캐시(persistent Data Cache)와 어떻게 상호작용할지를 결정해줘요.\u003c/p\u003e\n\u003cp\u003e즉, 서버 컴포넌트 안에서 async/await와 함께 그냥 fetch를 호출해도, 이 캐시 전략들이 작동하면서 성능 향상 및 데이터 최신성을 관리해준다는 뜻이에요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e추가 설명\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e지속 데이터 캐시란?\u003c/strong\u003e\u003cbr\u003e\n서버에서 한 번 가져온 데이터를 일정 시간 동안 저장해서, 같은 데이터를 재요청할 때 네트워크 호출을 줄여주는 역할을 해요. 그래서 유저 입장에선 페이지가 더 빨리 로드되고, 서버 부담도 줄어들죠.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e재검증(revalidation)이 뭐예요?\u003c/strong\u003e\u003cbr\u003e\n캐시된 데이터가 오래되었는지 주기적으로 체크해서, 최신 데이터가 필요하면 다시 fetch를 하는 거예요.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e서버 컴포넌트에서 fetch를 쓴다?\u003c/strong\u003e\u003cbr\u003e\nNext.js 13부터 도입된 서버 컴포넌트 덕분에, 서버에서 비동기적으로 데이터를 패칭하고 바로 렌더링할 수 있어요. 클라이언트에서 데이터 로딩 처리하는 걸 줄일 수 있죠.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3\u003e예시 코드\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 서버 컴포넌트 내에서 fetch 사용\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e res = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'https://api.example.com/data'\u003c/span\u003e, {\n    \u003cspan class=\"hljs-attr\"\u003ecache\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'force-cache'\u003c/span\u003e  \u003cspan class=\"hljs-comment\"\u003e// 고정된 캐시 전략 적용\u003c/span\u003e\n  });\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e data = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e res.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e();\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e서버에서 가져온 데이터\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003epre\u003c/span\u003e\u003e\u003c/span\u003e{JSON.stringify(data, null, 2)}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003epre\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNext.js의 fetch API 확장 덕분에 서버 쪽 데이터 요청을 더 똑똑하게 관리할 수 있으니, 다음 프로젝트에 꼭 활용해보세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e여러분, Next.js에서 데이터를 불러오는 방법에 대해 이야기해볼게요. 위에 있는 코드를 보시면, \u003ccode\u003efetch\u003c/code\u003e 함수로 외부 API에서 데이터를 받아와서 화면에 포스트 리스트를 렌더링하는 아주 기본적인 예제입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e data = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'https://api.vercel.app/blog'\u003c/span\u003e)\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e posts = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e data.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e()\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eul\u003c/span\u003e\u003e\u003c/span\u003e\n      {posts.map((post) =\u003e (\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eli\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{post.id}\u003c/span\u003e\u003e\u003c/span\u003e{post.title}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eli\u003c/span\u003e\u003e\u003c/span\u003e\n      ))}\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eul\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eNext.js의 fetch() API 활용\u003c/h3\u003e\n\u003cp\u003eNext.js는 기본적으로 웹의 \u003ccode\u003efetch()\u003c/code\u003e API를 확장해서 제공하는데요, 그래서 우리가 익숙한 \u003ccode\u003efetch\u003c/code\u003e 옵션들을 그대로 사용할 수 있다는 점이 편리해요. 이번에 살펴볼 옵션 중 하나가 \u003ccode\u003ecache\u003c/code\u003e 옵션입니다.\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003eoptions.cache\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003ecache\u003c/code\u003e 옵션은 데이터를 어떻게 캐싱할지를 결정하는 역할을 해요. 예를 들어, 기본적으로는 서버 컴포넌트에서 데이터를 패칭할 때 \u003ccode\u003ecache\u003c/code\u003e가 적용되어, 다음에 같은 요청이 오면 캐시된 데이터를 바로 사용할 수 있도록 돼 있죠. 이걸 조절하면, 실시간 데이터가 중요하거나, 너무 자주 데이터를 갱신할 필요가 있을 때 유용해요.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e\"default\"\u003c/code\u003e: 기본 캐싱 정책을 따릅니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\"no-cache\"\u003c/code\u003e: 매번 네트워크에서 새 데이터를 받아옵니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\"force-cache\"\u003c/code\u003e: 캐시된 데이터만 사용하고 네트워크 요청은 안 합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\"only-if-cached\"\u003c/code\u003e: 캐시된 데이터가 없으면 실패합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e예를 들어, 이렇게 쓸 수 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e data = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'https://api.vercel.app/blog'\u003c/span\u003e, { \u003cspan class=\"hljs-attr\"\u003ecache\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'no-cache'\u003c/span\u003e })\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 하면 무조건 최신 데이터를 받아오기 때문에, 실시간 뉴스나 가격 정보처럼 자주 업데이트되는 데이터에 적합합니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e한 가지 꿀팁!\u003c/h3\u003e\n\u003cp\u003eNext.js 13부터는 \u003ccode\u003efetch\u003c/code\u003e에 \u003ccode\u003enext\u003c/code\u003e 옵션도 함께 쓸 수 있는데요, 굉장히 강력합니다. 예를 들어 \u003ccode\u003enext: { revalidate: 10 }\u003c/code\u003e 옵션을 넣으면, 데이터를 받아와서 10초마다 캐시를 리프레시하도록 할 수 있어요. 이렇게 하면 서버 부하도 줄이고, 사용자는 어느 정도 최신 데이터를 볼 수 있죠.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e data = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'https://api.vercel.app/blog'\u003c/span\u003e, {\n  \u003cspan class=\"hljs-attr\"\u003enext\u003c/span\u003e: { \u003cspan class=\"hljs-attr\"\u003erevalidate\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e }\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e한마디로, 여러분 프로젝트 상황에 맞게 캐시 전략을 유연하게 조절해 보세요. 그럼 데이터 패칭도 똑똑하게 할 수 있답니다!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eNext.js에서 요청이 데이터 캐시와 어떻게 상호작용할지 설정하는 방법에 대해 설명해드릴게요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`https://...`\u003c/span\u003e, { \u003cspan class=\"hljs-attr\"\u003ecache\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'force-cache'\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e'no-store'\u003c/span\u003e })\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 cache 옵션은 세 가지 주요 상태가 있어요:\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e옵션\u003c/th\u003e\u003cth\u003e동작 설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003eauto (기본값)\u003c/td\u003e\u003ctd\u003e개발 환경에서는 매 요청마다 원격 서버에서 데이터를 가져와요. 하지만 빌드 시점에 페이지가 정적으로 사전 렌더링되면 그때 한 번만 가져와요. 그리고 동적 API가 감지되면 매 요청마다 데이터를 가져오죠.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eno-store\u003c/td\u003e\u003ctd\u003e동적 API 여부와 상관없이 항상 매 요청마다 원격 서버에서 데이터를 가져와요. 캐시를 사용하지 않는 느낌이에요.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eforce-cache\u003c/td\u003e\u003ctd\u003eNext.js의 데이터 캐시에서 일치하는 요청이 있는지 찾아요. ‘신선한’ 캐시가 있으면 캐시에서 바로 반환하고, 없거나 오래된 캐시라면 원격 서버에서 새로 데이터를 받아와 캐시를 업데이트해요.\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e추가 꿀팁!\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e캐시가 ‘신선한(fresh)’하다는 말은 캐시된 데이터가 아직 유효하다는 뜻이에요. 이를 판단하는 기준은 Next.js 내부 정책이나 \u003ccode\u003erevalidate\u003c/code\u003e 옵션에 따라 달라집니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eforce-cache\u003c/code\u003e를 사용하면 빌드 시점의 데이터를 최대한 활용하면서도, 변경사항이 있을 때만 서버에서 최신 데이터를 받을 수 있어서 효율적이에요.\u003c/li\u003e\n\u003cli\u003e개발 중에는 기본 \u003ccode\u003eauto\u003c/code\u003e 모드가 편리하지만, 프로덕션 환경에서는 상황에 맞게 \u003ccode\u003eno-store\u003c/code\u003e (실시간 업데이트 필요 시)나 \u003ccode\u003eforce-cache\u003c/code\u003e (최소한의 요청으로 성능 최적화 시)를 선택하는 게 좋아요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eoptions.next.revalidate\u003c/h3\u003e\n\u003cp\u003e이 옵션은 캐시를 갱신하는 주기를 설정할 때 쓰입니다. 예를 들어,\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'https://...'\u003c/span\u003e, { \u003cspan class=\"hljs-attr\"\u003enext\u003c/span\u003e: { \u003cspan class=\"hljs-attr\"\u003erevalidate\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e60\u003c/span\u003e } })\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 설정하면, 캐시된 데이터가 60초가 지나면 다음 요청 때 새로 갱신해요. 다시 말해, 1분마다 데이터를 새로고침하는 것과 같죠.\u003c/p\u003e\n\u003cp\u003e이걸 적절히 활용하면 새로 고침의 빈도와 SEO 최적화를 균형 있게 맞출 수 있습니다.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003eNext.js의 데이터 캐시는 페이지 성능과 사용자 경험에 큰 영향을 주니, 개발 환경과 서비스 특성에 맞게 잘 설정해 보세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003efetch 함수에 \u003ccode\u003enext: { revalidate: ... }\u003c/code\u003e 옵션을 주면 리소스의 캐시 수명을 초 단위로 설정할 수 있어요. 쉽게 말해, 캐시가 얼마 동안 유지될지 정하는 거죠. 이 옵션에 따라 캐싱 동작이 달라집니다.\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003erevalidate 값\u003c/th\u003e\u003cth\u003e의미\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003efalse\u003c/td\u003e\u003ctd\u003e리소스를 무한정 캐시해요. (사실상 revalidate: Infinity와 같아요.) HTTP 캐시는 오랫동안 쓰다가 오래된 캐시를 지울 순 있지만, 기본적으로 무제한으로 저장합니다.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e0\u003c/td\u003e\u003ctd\u003e캐시를 절대 하지 않아요. 항상 리소스를 새롭게 받아옵니다.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003enumber\u003c/td\u003e\u003ctd\u003e숫자(초)만큼 캐시 생명주기를 정해요. 예를 들어 60이면 60초간 캐시 유지.\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e좀 더 알아두면 좋은 점\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e특정 fetch 요청에서 설정한 \u003ccode\u003erevalidate\u003c/code\u003e 값이 라우트(route) 기본 값보다 작으면, 라우트 전체의 리밸리데이트 간격도 그만큼 줄어듭니다.\u003c/li\u003e\n\u003cli\u003e같은 URL을 가진 두 개의 fetch 요청이 각각 다른 \u003ccode\u003erevalidate\u003c/code\u003e 값을 가지고 있다면, 더 짧은 시간(낮은 값)이 적용됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003erevalidate\u003c/code\u003e를 숫자로 주면 따로 \u003ccode\u003ecache\u003c/code\u003e 옵션을 설정하지 않아도 돼요.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003erevalidate\u003c/code\u003e와 \u003ccode\u003ecache\u003c/code\u003e 옵션이 모순되는 설정(예: \u003ccode\u003erevalidate: 3600\u003c/code\u003e인데 \u003ccode\u003ecache: 'no-store'\u003c/code\u003e)을 하면 에러가 발생해요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e참고로,\u003c/h3\u003e\n\u003cp\u003e이 옵션은 Next.js에서 제공하는 기능으로, 서버 측 데이터 패칭 시 자동으로 ISR(Incremental Static Regeneration)을 조절하는데 유용합니다. 개발할 때 캐시 정책을 유연하게 조절하면, 페이지 성능과 최신성 사이에서 좋은 균형을 맞출 수 있어요.\u003c/p\u003e\n\u003cp\u003e혹시 어떻게 쓰는지 구체적인 예시가 궁금하다면 알려주세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch3\u003eoptions.next.tags\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`https://...`\u003c/span\u003e, { \u003cspan class=\"hljs-attr\"\u003enext\u003c/span\u003e: { \u003cspan class=\"hljs-attr\"\u003etags\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e'collection'\u003c/span\u003e] } })\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eoptions.next.tags\u003c/code\u003e는 요청에 캐시 태그(cache tags)를 설정하는 옵션이에요. 캐시 태그를 지정해두면, 나중에 \u003ccode\u003erevalidateTag\u003c/code\u003e API를 사용해서 해당 태그가 붙은 데이터만 선택적으로 갱신할 수 있답니다. 이렇게 하면 불필요하게 전체 데이터를 다시 받아오지 않아도 되니까 성능 최적화에 큰 도움이 되죠.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e태그 길이 제한\u003c/strong\u003e: 각 태그는 최대 256자까지만 작성할 수 있어요.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e태그 개수 제한\u003c/strong\u003e: 한 요청당 최대 128개의 태그를 설정할 수 있어요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3\u003e추가 팁!\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003erevalidateTag\u003c/code\u003e를 사용하면 페이지나 일부 컴포넌트에서 특정 태그를 기반으로 데이터를 갱신할 수 있어서 리얼타임 데이터 반영이나, 변경이 잦은 부분만 업데이트할 때 매우 유용해요.\u003c/p\u003e\n\u003cp\u003e예를 들어, 쇼핑몰에서 ‘상품 컬렉션(collection)’ 태그를 붙인 데이터만 따로 갱신하고 싶을 때 편리하겠죠? 커스텀 태그를 잘 활용해서 앱 성능과 사용자 경험을 한층 개선해 보세요!\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003e문제 해결 (Troubleshooting)\u003c/h2\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e문제 상황\u003c/th\u003e\u003cth\u003e해결 방법\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e태그가 너무 길 때\u003c/td\u003e\u003ctd\u003e태그 길이를 256자 이내로 줄이세요.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e태그 개수가 128개를 초과할 때\u003c/td\u003e\u003ctd\u003e필요 없는 태그를 제거하거나 그룹화하세요.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e데이터가 갱신되지 않을 때\u003c/td\u003e\u003ctd\u003e\u003ccode\u003erevalidateTag\u003c/code\u003e가 올바르게 호출되었는지 확인하세요.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e캐시가 정상 동작하지 않을 때\u003c/td\u003e\u003ctd\u003efetch 옵션과 캐시 정책을 다시 점검해보세요.\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e혹시 캐시 관련해서 더 궁금한 점이나, 특정 상황에서 어떻게 활용하면 좋은지 알고 싶다면 언제든 질문해 주세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch3\u003eFetch 기본 자동 no-store와 캐시: \u003ccode\u003eno-store\u003c/code\u003e가 개발 환경에서 최신 데이터를 보여주지 않는 이유\u003c/h3\u003e\n\u003cp\u003eNext.js에서 개발할 때, 특히 \u003cstrong\u003eServer Components\u003c/strong\u003e를 사용할 때 조금 특이한 캐싱 동작이 있어요. 바로 HMR(Hot Module Replacement) 과정에서 fetch 응답을 캐시에 저장한다는 점입니다. 이 덕분에 빠른 응답 속도와 함께, API 호출 비용도 아낄 수 있죠.\u003c/p\u003e\n\u003cp\u003e그런데 여기서 중요한 점! HMR 캐시는 기본적으로 모든 fetch 요청에 적용되는데, 심지어 \u003ccode\u003ecache: 'no-store'\u003c/code\u003e 옵션을 넣어도 마찬가지라는 거예요. 즉, 기본값인 \u003ccode\u003eno-cache\u003c/code\u003e나 \u003ccode\u003ecache: 'no-store'\u003c/code\u003e를 사용해도 HMR 중에는 캐시가 유지되어서 \u003cstrong\u003e최신 데이터가 바로바로 안 보일 수 있습니다\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003e하지만 실제로 페이지를 새로고침하거나 다른 경로로 이동할 때는 캐시가 깨져서 다시 최신 데이터를 가져오게 돼요.\u003c/p\u003e\n\u003cp\u003e이게 개발할 때 가끔 데이터를 바로바로 바꿔서 테스트하는 과정에서 헷갈리게 할 수 있으니 주의해야 합니다.\u003c/p\u003e\n\u003cp\u003e추가로 궁금하다면 \u003ca href=\"https://nextjs.org/docs/advanced-features/react-18/server-components#hot-module-replacement-cache\" rel=\"nofollow\" target=\"_blank\"\u003eserverComponentsHmrCache 문서\u003c/a\u003e도 확인해보세요!\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e참고로 알아두면 좋은 점\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ecache: 'no-store'\u003c/code\u003e 옵션은 \u003cstrong\u003e프로덕션 환경에선 실제로 캐시를 안 해서 무조건 최신 데이터를 가져오지만\u003c/strong\u003e,\u003c/li\u003e\n\u003cli\u003e개발 모드에서만 HMR 캐시가 이를 덮어씌웁니다.\u003c/li\u003e\n\u003cli\u003e이 때문에 개발 중에는 \u003cstrong\u003efetch 요청이 예상과 다르게 동작할 수 있으니 주의\u003c/strong\u003e해야 해요.\u003c/li\u003e\n\u003cli\u003e만약 진짜 최신 데이터를 계속 보고 싶다면, \u003ca href=\"https://nextjs.org/docs/basic-features/data-fetching#refreshing-data-on-client-navigation\" rel=\"nofollow\" target=\"_blank\"\u003e페이지를 새로고침하거나 다른 경로로 이동하는 방법\u003c/a\u003e을 쓰는 게 좋습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이런 Next.js 내부 동작 방식을 살펴보는 건 개발 생산성을 높이고, 예상치 못한 버그를 막는 데 큰 도움이 됩니다!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e버전 히스토리\u003c/h2\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e버전\u003c/th\u003e\u003cth\u003e변경 사항\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ev13.0.0\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003efetch\u003c/code\u003e 기능 추가됨\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e여기서 \u003ccode\u003efetch\u003c/code\u003e는 데이터를 서버에서 가져올 때 자주 사용하는 기능인데, 이 버전부터 공식적으로 도입됐다는 뜻이에요. 개발할 때 API 호출이 필요하면 이 기능을 활용해보세요. 예전에는 XMLHttpRequest나 다른 라이브러리를 많이 썼는데, \u003ccode\u003efetch\u003c/code\u003e는 Promise 기반이라 비동기 처리가 훨씬 깔끔해져서 요즘은 표준처럼 쓰이고 있답니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2025-04-22-fetch"},"buildId":"olPs1cVezSGTqD7OaewDI","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>