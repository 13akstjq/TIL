<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>파이썬에서 SOLID 원칙 적용하는 방법 | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2024-07-09-SOLIDprinciplesinPython" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="파이썬에서 SOLID 원칙 적용하는 방법 | TIL" data-gatsby-head="true"/><meta property="og:title" content="파이썬에서 SOLID 원칙 적용하는 방법 | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-07-09-SOLIDprinciplesinPython_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2024-07-09-SOLIDprinciplesinPython" data-gatsby-head="true"/><meta name="twitter:title" content="파이썬에서 SOLID 원칙 적용하는 방법 | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-07-09-SOLIDprinciplesinPython_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2024-07-09 14:45" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/0eef537492fed77a.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/0eef537492fed77a.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/post/%5Bslug%5D-8ded8b979ba73586.js" defer=""></script><script src="/TIL/_next/static/M7pU9hOcx8u_ZIFMf95sd/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/M7pU9hOcx8u_ZIFMf95sd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">파이썬에서 SOLID 원칙 적용하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="파이썬에서 SOLID 원칙 적용하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jul 9, 2024</span><span class="posts_reading_time__f7YPP">15<!-- --> min read</span></span></div></div></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/TIL/assets/img/2024-07-09-SOLIDprinciplesinPython_0.png" alt="SOLID principles in Python"></p>
<h1>SOLID이란 무엇인가요?</h1>
<p>객체 지향 프로그래밍은 모든 프로그래머의 도구 상자에서 매우 유용한 도구입니다. 그러나 사용할 때 대부분의 사람들이 빠지는 흔한 함정이 있습니다.</p>
<p>SOLID 원칙은 이러한 함정을 피하고 깔끔하고 유지보수 가능한 코드를 작성하는 데 도움이 되는 일련의 지침입니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>"SOLID"은 다음을 나타내는 머리글자입니다:</p>
<ul>
<li>단일 책임 원칙 (SRP)</li>
<li>개방/폐쇠 원칙 (OCP)</li>
<li>리스코프 치환 원칙 (LSP)</li>
</ul>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>
<p>인터페이스 분리 원칙</p>
</li>
<li>
<p>의존성 역전 원칙</p>
</li>
</ul>
<h2>1. 단일 책임 원칙 (SRP)</h2>
<p>로버트 C. 마틴 (a.k.a 아저씨 밥)이 "OOD의 원칙"이라는 기사에서 만들어진 단일 책임 원칙은 다음과 같습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>한 클래스는 한 가지 책임만 가져야 합니다. 한 클래스가 여러 가지 일을 한다면, 여러 클래스로 분리해야 합니다.</p>
<p>간단한 예를 통해 이를 설명해보겠습니다. 우리가 Google 드라이브 또는 Dropbox에서 객체를 읽고 쓰는 클래스가 있다고 가정해 봅시다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StorageClient</span>:
    _instance = <span class="hljs-title class_">None</span>
    _google_client = <span class="hljs-title class_">None</span>
    _dropbox_client = <span class="hljs-title class_">None</span>

    def <span class="hljs-title function_">__init__</span>(self, google_credentials, dropbox_credentials) -> <span class="hljs-title class_">None</span>:
        self.<span class="hljs-property">_google_client</span> = <span class="hljs-string">"Google 클라이언트"</span>
        self.<span class="hljs-property">_dropbox_client</span> = <span class="hljs-string">"Dropbox 클라이언트"</span>

    @classmethod
    def <span class="hljs-title function_">get_or_create_instance</span>(cls, google_credentials, dropbox_credentials) -> <span class="hljs-string">"StorageClient"</span>:
        <span class="hljs-keyword">if</span> not cls.<span class="hljs-property">_instance</span>:
            cls.<span class="hljs-property">_instance</span> = <span class="hljs-title class_">StorageClient</span>(google_credentials, dropbox_credentials)

        <span class="hljs-keyword">return</span> cls.<span class="hljs-property">_instance</span>

    def <span class="hljs-title function_">read_from_google</span>(self, key):
        ...

    def <span class="hljs-title function_">upload_to_google</span>(self, key, value):
        ...

    def <span class="hljs-title function_">read_from_dropbox</span>(self, key):
        ...

    def <span class="hljs-title function_">upload_to_dropbox</span>(self, key, value):
        ...
</code></pre>
<p>이 클래스의 문제는 두 가지 책임을 가지고 있다는 점입니다. Google 드라이브 및 Dropbox에서 객체를 읽고 쓰는 데에 대한 별도의 로직을 구현해야 합니다. SRP를 준수하기 위해 이 클래스를 GoogleStorageClient와 DropboxStorageClient로 분리할 수 있습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GoogleStorageClient</span>:
    _instance = <span class="hljs-title class_">None</span>
    _google_client = <span class="hljs-title class_">None</span>

    def <span class="hljs-title function_">__init__</span>(self, google_credentials) -> <span class="hljs-title class_">None</span>:
        self.<span class="hljs-property">_google_client</span> = <span class="hljs-string">"Google client"</span>

    @classmethod
    def <span class="hljs-title function_">get_or_create_instance</span>(cls, google_credentials) -> <span class="hljs-string">"GoogleStorageClient"</span>:
        <span class="hljs-keyword">if</span> not cls.<span class="hljs-property">_instance</span>:
            cls.<span class="hljs-property">_instance</span> = <span class="hljs-title class_">GoogleStorageClient</span>(google_credentials)

        <span class="hljs-keyword">return</span> cls.<span class="hljs-property">_instance</span>

    def <span class="hljs-title function_">read</span>(self, key):
        ...

    def <span class="hljs-title function_">upload</span>(self, key, value):
        ...


<span class="hljs-keyword">class</span> <span class="hljs-title class_">DropboxStorageClient</span>:
    _instance = <span class="hljs-title class_">None</span>
    _dropbox_client = <span class="hljs-title class_">None</span>

    def <span class="hljs-title function_">__init__</span>(self, dropbox_credentials) -> <span class="hljs-title class_">None</span>:
        self.<span class="hljs-property">_dropbox_client</span> = <span class="hljs-string">"Dropbox client"</span>

    @classmethod
    def <span class="hljs-title function_">get_or_create_instance</span>(cls, dropbox_credentials) -> <span class="hljs-string">"DropboxStorageClient"</span>:
        <span class="hljs-keyword">if</span> not cls.<span class="hljs-property">_instance</span>:
            cls.<span class="hljs-property">_instance</span> = <span class="hljs-title class_">DropboxStorageClient</span>(dropbox_credentials)

        <span class="hljs-keyword">return</span> cls.<span class="hljs-property">_instance</span>

    def <span class="hljs-title function_">read</span>(self, key):
        ...

    def <span class="hljs-title function_">upload</span>(self, key, value):
        ...
</code></pre>
<p>조금 더 상세하게 작성하더라도, 두 클라이언트를 개별적으로 개발하고 코드를 더 유지보수하기 쉽게 만듭니다. 예를 들어 Google 클라이언트를 작업하는 사람은 Dropbox 클라이언트의 작동 방식을 알 필요가 없으며 그 반대도 마찬가지입니다.</p>
<h2>2. 개방/폐쇄 원칙 (OCP)</h2>
<p>버트랜드 메이어는 1988년 저술한 "객체지향 소프트웨어 구성"에서 개방-폐쇄 원칙을 처음 제안한 것으로 일반적으로 알려져 있습니다. 그러나 1990년대에 이 원칙은 언클 밥이 1996년에 발표한 "개방-폐쇄 원칙"으로 현재의 형태로 재정의되었습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>개방/폐쇄 원칙은 다음을 의미합니다:</p>
<p>클래스에 새 기능을 추가할 수 있어야 하며 기존 코드를 변경하지 않아도 됩니다.</p>
<p>예를 들어, 다음 클래스는 개방/폐쇄 원칙을 위반합니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vehicle</span>:
    def <span class="hljs-title function_">__init__</span>(self, vehicle_type, **kwargs) -> <span class="hljs-title class_">None</span>:
        self.<span class="hljs-property">vehicle</span> = vehicle_type
        <span class="hljs-keyword">if</span> self.<span class="hljs-property">vehicle_type</span> == <span class="hljs-string">"car"</span>:
            self.<span class="hljs-property">tires</span> = kwargs[<span class="hljs-string">"tires"</span>]
            self.<span class="hljs-property">mode</span> = kwargs[<span class="hljs-string">"mode"</span>]
        elif self.<span class="hljs-property">vehicle_type</span> == <span class="hljs-string">"boat"</span>:
            self.<span class="hljs-property">motors</span> = kwargs[<span class="hljs-string">"motors"</span>]
            self.<span class="hljs-property">mode</span> = kwargs[<span class="hljs-string">"mode"</span>]

    def <span class="hljs-title function_">get_specifications</span>(self) -> <span class="hljs-attr">str</span>:
        <span class="hljs-keyword">if</span> self.<span class="hljs-property">vehicle_type</span> == <span class="hljs-string">"car"</span>:
            <span class="hljs-keyword">return</span> f<span class="hljs-string">"This {self.vehicle_type} has {self.tires} tires and can drive on {self.mode}."</span>
        elif self.<span class="hljs-property">vehicle_type</span> == <span class="hljs-string">"boat"</span>:
            <span class="hljs-keyword">return</span> f<span class="hljs-string">"This {self.vehicle_type} has {self.motors} motors and can float on {self.mode}."</span>
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 클래스의 문제점은 새로운 차량, 예를 들어 비행기를 추가하려면 기존 클래스를 수정해야 한다는 것입니다.</p>
<p>기존 코드를 수정하는 것은 위험할 수 있으며 버그를 도입할 수도 있고 유닛 테스트를 실패할 수도 있습니다.</p>
<p>대신 추상 기본 클래스를 정의하고 상속을 사용하여 클래스가 개방/폐쇄 원칙을 따르도록 할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> <span class="hljs-variable constant_">ABC</span>, abstractmethod

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Vehicle</span>(<span class="hljs-variable constant_">ABC</span>):
    def <span class="hljs-title function_">__init__</span>(self, mode) -> <span class="hljs-title class_">None</span>:
        self.<span class="hljs-property">mode</span> = mode

    @abstractmethod
    def <span class="hljs-title function_">get_specifications</span>(self) -> <span class="hljs-attr">str</span>:
        ...

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>(<span class="hljs-title class_">Vehicle</span>):
    def <span class="hljs-title function_">__init__</span>(self, tires) -> <span class="hljs-title class_">None</span>:
        <span class="hljs-variable language_">super</span>().<span class="hljs-title function_">__init__</span>(<span class="hljs-string">"lane"</span>)
        self.<span class="hljs-property">tires</span> = tires

    def <span class="hljs-title function_">get_specifications</span>(self) -> <span class="hljs-attr">str</span>:
        <span class="hljs-keyword">return</span> f<span class="hljs-string">"This car has {self.tires} tires and can drive on {self.mode}."</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Boat</span>(<span class="hljs-title class_">Vehicle</span>):
    def <span class="hljs-title function_">__init__</span>(self, motors) -> <span class="hljs-title class_">None</span>:
        <span class="hljs-variable language_">super</span>().<span class="hljs-title function_">__init__</span>(<span class="hljs-string">"water"</span>)
        self.<span class="hljs-property">motors</span> = motors

    def <span class="hljs-title function_">get_specifications</span>(self) -> <span class="hljs-attr">str</span>:
        <span class="hljs-keyword">return</span> f<span class="hljs-string">"This boat has {self.motors} motors and can float on {self.mode}."</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Plane</span>(<span class="hljs-title class_">Vehicle</span>):
    def <span class="hljs-title function_">__init__</span>(self, engines) -> <span class="hljs-title class_">None</span>:
        <span class="hljs-variable language_">super</span>().<span class="hljs-title function_">__init__</span>(<span class="hljs-string">"air"</span>)
        self.<span class="hljs-property">engines</span> = engines

    def <span class="hljs-title function_">get_specifications</span>(self) -> <span class="hljs-attr">str</span>:
        <span class="hljs-keyword">return</span> f<span class="hljs-string">"This plane has {self.engines} engines and can fly through the {self.mode}."</span>
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이제 새 차량을 추가하고 싶다면, 단순히 Vehicle 클래스를 상속하고 get_specifications 메서드를 구현하는 새 클래스를 생성하면 됩니다.</p>
<h2>3. 리스코프 치환 원칙 (LSP)</h2>
<p>리스코프 치환 원칙은 1987년 OOPSLA 컨퍼런스에서 Barbara Liskov에 의해 소개되었습니다. 이 원칙은 다음과 같습니다:</p>
<p>다시 말해, 만약 <code>S</code>가 <code>T</code>의 서브 클래스라면, <code>T</code> 타입의 객체를 <code>S</code> 타입의 객체로 대체할 수 있어야 하며, 프로그램의 기능을 변경하지 않아야 합니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>예를 들어, 다음과 같은 클래스를 고려해보세요:</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>) -> <span class="hljs-literal">None</span>:
        self.name = name
        self.age = age

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_name</span>(<span class="hljs-params">self</span>) -> <span class="hljs-built_in">str</span>:
        <span class="hljs-keyword">return</span> self.name

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">vote</span>(<span class="hljs-params">self, give_vote</span>) -> <span class="hljs-built_in">int</span>:
        <span class="hljs-keyword">if</span> give_vote:
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span>(<span class="hljs-title class_ inherited__">Person</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>) -> <span class="hljs-literal">None</span>:
        <span class="hljs-built_in">super</span>().__init__(name, age)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">vote</span>(<span class="hljs-params">self</span>) -> <span class="hljs-literal">None</span>:
        <span class="hljs-keyword">raise</span> NotImplementedError(<span class="hljs-string">"어린이는 투표할 수 없습니다."</span>)
</code></pre>
<p>이 코드의 문제는 Child 클래스가 리스코프 치환 원칙을 위반한다는 것입니다. Person 타입의 객체를 Child 타입의 객체로 대체하려고 하면, 예를 들어 vote 메서드를 사용하려고 할 때 프로그램이 예상대로 동작하지 않을 것입니다.</p>
<p>이 문제를 해결하기 위해서는 Person을 추상 기본 클래스로 변환하고, 그것을 상속하는 Child와 Adult 두 클래스를 만들면 됩니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>from abc import ABC, abstractmethod</p>
<p>class Person(ABC):
def <strong>init</strong>(self, name, age) -> None:
self.name = name
self.age = age</p>
<pre><code>def get_name(self) -> str:
    return self.name
</code></pre>
<p>class Child(Person):
def <strong>init</strong>(self, name, age) -> None:
super().<strong>init</strong>(name, age)</p>
<pre><code>def go_to_school(self) -> None:
    print(f"{self.name} is going to school.")
</code></pre>
<p>class Adult(Person):
def <strong>init</strong>(self, name, age) -> None:
super().<strong>init</strong>(name, age)</p>
<pre><code>def vote(self) -> int:
    return 1
</code></pre>
<p>이제 프로그램의 정확성에 영향을 주지 않고 Person 유형의 객체를 Child 또는 Adult 유형의 객체로 대체할 수 있습니다.</p>
<h2>4. Interface Segregation Principle (ISP)</h2>
<p>인터페이스 분리 원칙(Interface Segregation Principle, ISP)은 Uncle Bob이 만들었습니다. 이 원칙은 다음과 같이 설명합니다:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>큰 인터페이스를 피해야 합니다. 이는 모든 클라이언트가 구현하는 인터페이스 메서드를 사용하지 않는 대규모 인터페이스를 의미합니다.</p>
<p>예를 들어, 다음과 같은 인터페이스를 고려해 보세요:</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABC, abstractmethod

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Printer</span>(<span class="hljs-title class_ inherited__">ABC</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">scan</span>(<span class="hljs-params">self</span>) -> <span class="hljs-literal">None</span>: ...

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fax</span>(<span class="hljs-params">self</span>) -> <span class="hljs-literal">None</span>: ...

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">print</span>(<span class="hljs-params">self</span>) -> <span class="hljs-literal">None</span>: ...


<span class="hljs-keyword">class</span> <span class="hljs-title class_">SimplePrinter</span>(<span class="hljs-title class_ inherited__">Printer</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">scan</span>(<span class="hljs-params">self</span>) -> <span class="hljs-literal">None</span>:
        <span class="hljs-keyword">raise</span> NotImplementedError(<span class="hljs-string">"This printer cannot scan."</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fax</span>(<span class="hljs-params">self</span>) -> <span class="hljs-literal">None</span>:
        <span class="hljs-keyword">raise</span> NotImplementedError(<span class="hljs-string">"This printer cannot fax."</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">print</span>(<span class="hljs-params">self</span>) -> <span class="hljs-literal">None</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"Printing..."</span>)


<span class="hljs-keyword">class</span> <span class="hljs-title class_">AdvancedPrinter</span>(<span class="hljs-title class_ inherited__">Printer</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">scan</span>(<span class="hljs-params">self</span>) -> <span class="hljs-literal">None</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"Scanning..."</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fax</span>(<span class="hljs-params">self</span>) -> <span class="hljs-literal">None</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"Faxing..."</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">print</span>(<span class="hljs-params">self</span>) -> <span class="hljs-literal">None</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"Printing..."</span>)
</code></pre>
<p>이 경우, SimplePrinter 클래스는 scan 및 fax 메서드가 필요하지 않지만, Printer 인터페이스를 구현하므로 이들을 구현해야 합니다. 이는 인터페이스 격리 원칙을 위반하는 것입니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>그 대신, Printer 인터페이스를 Scanner, Fax 및 Printer 세 개의 별도의 인터페이스로 분리할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> <span class="hljs-variable constant_">ABC</span>, abstractmethod


<span class="hljs-keyword">class</span> <span class="hljs-title class_">Scanner</span>(<span class="hljs-variable constant_">ABC</span>):
    @abstractmethod
    def <span class="hljs-title function_">scan</span>(self) -> <span class="hljs-title class_">None</span>:
        ...


<span class="hljs-keyword">class</span> <span class="hljs-title class_">Fax</span>(<span class="hljs-variable constant_">ABC</span>):
    @abstractmethod
    def <span class="hljs-title function_">fax</span>(self) -> <span class="hljs-title class_">None</span>:
        ...


<span class="hljs-keyword">class</span> <span class="hljs-title class_">Printer</span>(<span class="hljs-variable constant_">ABC</span>):
    @abstractmethod
    def <span class="hljs-title function_">print</span>(self) -> <span class="hljs-title class_">None</span>:
        ...


<span class="hljs-keyword">class</span> <span class="hljs-title class_">SimplePrinter</span>(<span class="hljs-title class_">Printer</span>):
    def <span class="hljs-title function_">print</span>(self) -> <span class="hljs-title class_">None</span>:
        <span class="hljs-title function_">print</span>(<span class="hljs-string">"Printing..."</span>)


<span class="hljs-keyword">class</span> <span class="hljs-title class_">AdvancedPrinter</span>(<span class="hljs-title class_">Scanner</span>, <span class="hljs-title class_">Fax</span>, <span class="hljs-title class_">Printer</span>):
    def <span class="hljs-title function_">scan</span>(self) -> <span class="hljs-title class_">None</span>:
        <span class="hljs-title function_">print</span>(<span class="hljs-string">"Scanning..."</span>)

    def <span class="hljs-title function_">fax</span>(self) -> <span class="hljs-title class_">None</span>:
        <span class="hljs-title function_">print</span>(<span class="hljs-string">"Faxing..."</span>)

    def <span class="hljs-title function_">print</span>(self) -> <span class="hljs-title class_">None</span>:
        <span class="hljs-title function_">print</span>(<span class="hljs-string">"Printing..."</span>)
</code></pre>
<p>이제 SimplePrinter 클래스는 Printer 인터페이스만 구현하면 되고, AdvancedPrinter 클래스는 세 인터페이스를 모두 구현할 수 있습니다.</p>
<p>이 방식을 통해 코드를 이해하기 쉽게 만들고 SimplePrinter 클래스에 불필요한 메서드가 필요 없어졌습니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>5. 의존성 역전 원칙</h2>
<p>언클 밥이 만든 의존성 역전 원칙은 다음과 같습니다:</p>
<p>이 원칙은 고수준 모듈과 저수준 모듈을 결합을 느슨하게 하기 위해 그들 사이에 추상화 계층을 도입하는 것에 관한 것입니다. 이를 통해 결합이 적고 유연한 시스템을 만들 수 있습니다.</p>
<p>다음은 의존성 역전 원칙을 위반하는 예시입니다. 고수준 모듈인 PaymentService가 저수준 모듈인 PaypalProcessor에 직접 의존하는 것입니다:</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PaypalProcessor</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">process_payment</span>(<span class="hljs-params">self, amount</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"Processing payment of $<span class="hljs-subst">{amount}</span> via PayPal"</span>)


<span class="hljs-keyword">class</span> <span class="hljs-title class_">PaymentService</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>) -> <span class="hljs-literal">None</span>:
        self.payment_processor = PaypalProcessor()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">perform_payment</span>(<span class="hljs-params">self, amount</span>):
        self.payment_processor.process_payment(amount)


payment_service = PaymentService()
payment_service.perform_payment(<span class="hljs-number">100</span>)
</code></pre>
<p>만약 다른 결제 게이트웨이로 전환하고 싶다면, PaymentService 클래스를 수정해야 하는데 이는 개방-폐쇄 원칙을 위배합니다.</p>
<p>대신, 우리가 결제를 처리하는 PaymentService 고수준 모듈과 PayPal, Stripe와 같은 다른 결제 게이트웨이와 상호 작용할 수 있는 추상 인터페이스인 PaymentProcessor가 있는 것으로 가정해 봅시다.</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABC, abstractmethod


<span class="hljs-keyword">class</span> <span class="hljs-title class_">PaymentProcessor</span>(<span class="hljs-title class_ inherited__">ABC</span>):
<span class="hljs-meta">    @abstractmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">process_payment</span>(<span class="hljs-params">self, amount</span>):
        <span class="hljs-keyword">pass</span>


<span class="hljs-keyword">class</span> <span class="hljs-title class_">PayPalPaymentProcessor</span>(<span class="hljs-title class_ inherited__">PaymentProcessor</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">process_payment</span>(<span class="hljs-params">self, amount</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"Processing payment of $<span class="hljs-subst">{amount}</span> via PayPal"</span>)


<span class="hljs-keyword">class</span> <span class="hljs-title class_">StripePaymentProcessor</span>(<span class="hljs-title class_ inherited__">PaymentProcessor</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">process_payment</span>(<span class="hljs-params">self, amount</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"Processing payment of $<span class="hljs-subst">{amount}</span> via Stripe"</span>)


<span class="hljs-keyword">class</span> <span class="hljs-title class_">PaymentService</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, payment_processor</span>):
        self.payment_processor = payment_processor

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">perform_payment</span>(<span class="hljs-params">self, amount</span>):
        self.payment_processor.process_payment(amount)


paypal_processor = PayPalPaymentProcessor()
payment_service = PaymentService(paypal_processor)
payment_service.perform_payment(<span class="hljs-number">100</span>)
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이렇게하면 PaymentService 클래스는 특정 결제 프로세서 구현에 의존하지 않습니다. 대신 PaymentProcessor 인터페이스에 의존하고 있어서 PaymentService 클래스를 수정하지 않고도 다양한 결제 프로세서 간에 전환할 수 있습니다.</p>
<h1>결론</h1>
<p>SOLID 원칙은 깨끗하고 유지보수 가능하며 유연한 코드를 작성하는 데 도움이 되는 일련의 지침입니다. 이러한 원칙을 따르면 이해하기 쉬우며 테스트하고 유지하기 쉬운 코드를 만들 수 있습니다. 이러한 원칙에 적응하는 데는 시간이 걸릴 수 있지만, 확실히 더 나은 프로그래머가 되고 더 나은 소프트웨어를 만들 수 있도록 도와줄 것입니다. 이들은 가이드라인이며 절대적인 규칙이 아니므로 현명하게 사용하고 특정 요구사항에 맞게 적용하십시오.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"파이썬에서 SOLID 원칙 적용하는 방법","description":"","date":"2024-07-09 14:45","slug":"2024-07-09-SOLIDprinciplesinPython","content":"\n![SOLID principles in Python](/TIL/assets/img/2024-07-09-SOLIDprinciplesinPython_0.png)\n\n# SOLID이란 무엇인가요?\n\n객체 지향 프로그래밍은 모든 프로그래머의 도구 상자에서 매우 유용한 도구입니다. 그러나 사용할 때 대부분의 사람들이 빠지는 흔한 함정이 있습니다.\n\nSOLID 원칙은 이러한 함정을 피하고 깔끔하고 유지보수 가능한 코드를 작성하는 데 도움이 되는 일련의 지침입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\"SOLID\"은 다음을 나타내는 머리글자입니다:\n\n- 단일 책임 원칙 (SRP)\n- 개방/폐쇠 원칙 (OCP)\n- 리스코프 치환 원칙 (LSP)\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 인터페이스 분리 원칙\n\n- 의존성 역전 원칙\n\n## 1. 단일 책임 원칙 (SRP)\n\n로버트 C. 마틴 (a.k.a 아저씨 밥)이 \"OOD의 원칙\"이라는 기사에서 만들어진 단일 책임 원칙은 다음과 같습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n한 클래스는 한 가지 책임만 가져야 합니다. 한 클래스가 여러 가지 일을 한다면, 여러 클래스로 분리해야 합니다.\n\n간단한 예를 통해 이를 설명해보겠습니다. 우리가 Google 드라이브 또는 Dropbox에서 객체를 읽고 쓰는 클래스가 있다고 가정해 봅시다.\n\n```js\nclass StorageClient:\n    _instance = None\n    _google_client = None\n    _dropbox_client = None\n\n    def __init__(self, google_credentials, dropbox_credentials) -\u003e None:\n        self._google_client = \"Google 클라이언트\"\n        self._dropbox_client = \"Dropbox 클라이언트\"\n\n    @classmethod\n    def get_or_create_instance(cls, google_credentials, dropbox_credentials) -\u003e \"StorageClient\":\n        if not cls._instance:\n            cls._instance = StorageClient(google_credentials, dropbox_credentials)\n\n        return cls._instance\n\n    def read_from_google(self, key):\n        ...\n\n    def upload_to_google(self, key, value):\n        ...\n\n    def read_from_dropbox(self, key):\n        ...\n\n    def upload_to_dropbox(self, key, value):\n        ...\n```\n\n이 클래스의 문제는 두 가지 책임을 가지고 있다는 점입니다. Google 드라이브 및 Dropbox에서 객체를 읽고 쓰는 데에 대한 별도의 로직을 구현해야 합니다. SRP를 준수하기 위해 이 클래스를 GoogleStorageClient와 DropboxStorageClient로 분리할 수 있습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nclass GoogleStorageClient:\n    _instance = None\n    _google_client = None\n\n    def __init__(self, google_credentials) -\u003e None:\n        self._google_client = \"Google client\"\n\n    @classmethod\n    def get_or_create_instance(cls, google_credentials) -\u003e \"GoogleStorageClient\":\n        if not cls._instance:\n            cls._instance = GoogleStorageClient(google_credentials)\n\n        return cls._instance\n\n    def read(self, key):\n        ...\n\n    def upload(self, key, value):\n        ...\n\n\nclass DropboxStorageClient:\n    _instance = None\n    _dropbox_client = None\n\n    def __init__(self, dropbox_credentials) -\u003e None:\n        self._dropbox_client = \"Dropbox client\"\n\n    @classmethod\n    def get_or_create_instance(cls, dropbox_credentials) -\u003e \"DropboxStorageClient\":\n        if not cls._instance:\n            cls._instance = DropboxStorageClient(dropbox_credentials)\n\n        return cls._instance\n\n    def read(self, key):\n        ...\n\n    def upload(self, key, value):\n        ...\n```\n\n조금 더 상세하게 작성하더라도, 두 클라이언트를 개별적으로 개발하고 코드를 더 유지보수하기 쉽게 만듭니다. 예를 들어 Google 클라이언트를 작업하는 사람은 Dropbox 클라이언트의 작동 방식을 알 필요가 없으며 그 반대도 마찬가지입니다.\n\n## 2. 개방/폐쇄 원칙 (OCP)\n\n버트랜드 메이어는 1988년 저술한 \"객체지향 소프트웨어 구성\"에서 개방-폐쇄 원칙을 처음 제안한 것으로 일반적으로 알려져 있습니다. 그러나 1990년대에 이 원칙은 언클 밥이 1996년에 발표한 \"개방-폐쇄 원칙\"으로 현재의 형태로 재정의되었습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n개방/폐쇄 원칙은 다음을 의미합니다:\n\n클래스에 새 기능을 추가할 수 있어야 하며 기존 코드를 변경하지 않아도 됩니다.\n\n예를 들어, 다음 클래스는 개방/폐쇄 원칙을 위반합니다:\n\n```js\nclass Vehicle:\n    def __init__(self, vehicle_type, **kwargs) -\u003e None:\n        self.vehicle = vehicle_type\n        if self.vehicle_type == \"car\":\n            self.tires = kwargs[\"tires\"]\n            self.mode = kwargs[\"mode\"]\n        elif self.vehicle_type == \"boat\":\n            self.motors = kwargs[\"motors\"]\n            self.mode = kwargs[\"mode\"]\n\n    def get_specifications(self) -\u003e str:\n        if self.vehicle_type == \"car\":\n            return f\"This {self.vehicle_type} has {self.tires} tires and can drive on {self.mode}.\"\n        elif self.vehicle_type == \"boat\":\n            return f\"This {self.vehicle_type} has {self.motors} motors and can float on {self.mode}.\"\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 클래스의 문제점은 새로운 차량, 예를 들어 비행기를 추가하려면 기존 클래스를 수정해야 한다는 것입니다.\n\n기존 코드를 수정하는 것은 위험할 수 있으며 버그를 도입할 수도 있고 유닛 테스트를 실패할 수도 있습니다.\n\n대신 추상 기본 클래스를 정의하고 상속을 사용하여 클래스가 개방/폐쇄 원칙을 따르도록 할 수 있습니다.\n\n```js\nfrom abc import ABC, abstractmethod\n\nclass Vehicle(ABC):\n    def __init__(self, mode) -\u003e None:\n        self.mode = mode\n\n    @abstractmethod\n    def get_specifications(self) -\u003e str:\n        ...\n\nclass Car(Vehicle):\n    def __init__(self, tires) -\u003e None:\n        super().__init__(\"lane\")\n        self.tires = tires\n\n    def get_specifications(self) -\u003e str:\n        return f\"This car has {self.tires} tires and can drive on {self.mode}.\"\n\nclass Boat(Vehicle):\n    def __init__(self, motors) -\u003e None:\n        super().__init__(\"water\")\n        self.motors = motors\n\n    def get_specifications(self) -\u003e str:\n        return f\"This boat has {self.motors} motors and can float on {self.mode}.\"\n\nclass Plane(Vehicle):\n    def __init__(self, engines) -\u003e None:\n        super().__init__(\"air\")\n        self.engines = engines\n\n    def get_specifications(self) -\u003e str:\n        return f\"This plane has {self.engines} engines and can fly through the {self.mode}.\"\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 새 차량을 추가하고 싶다면, 단순히 Vehicle 클래스를 상속하고 get_specifications 메서드를 구현하는 새 클래스를 생성하면 됩니다.\n\n## 3. 리스코프 치환 원칙 (LSP)\n\n리스코프 치환 원칙은 1987년 OOPSLA 컨퍼런스에서 Barbara Liskov에 의해 소개되었습니다. 이 원칙은 다음과 같습니다:\n\n다시 말해, 만약 `S`가 `T`의 서브 클래스라면, `T` 타입의 객체를 `S` 타입의 객체로 대체할 수 있어야 하며, 프로그램의 기능을 변경하지 않아야 합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예를 들어, 다음과 같은 클래스를 고려해보세요:\n\n```python\nclass Person:\n    def __init__(self, name, age) -\u003e None:\n        self.name = name\n        self.age = age\n\n    def get_name(self) -\u003e str:\n        return self.name\n\n    def vote(self, give_vote) -\u003e int:\n        if give_vote:\n            return 1\n        return 0\n\nclass Child(Person):\n    def __init__(self, name, age) -\u003e None:\n        super().__init__(name, age)\n\n    def vote(self) -\u003e None:\n        raise NotImplementedError(\"어린이는 투표할 수 없습니다.\")\n```\n\n이 코드의 문제는 Child 클래스가 리스코프 치환 원칙을 위반한다는 것입니다. Person 타입의 객체를 Child 타입의 객체로 대체하려고 하면, 예를 들어 vote 메서드를 사용하려고 할 때 프로그램이 예상대로 동작하지 않을 것입니다.\n\n이 문제를 해결하기 위해서는 Person을 추상 기본 클래스로 변환하고, 그것을 상속하는 Child와 Adult 두 클래스를 만들면 됩니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nfrom abc import ABC, abstractmethod\n\nclass Person(ABC):\ndef **init**(self, name, age) -\u003e None:\nself.name = name\nself.age = age\n\n    def get_name(self) -\u003e str:\n        return self.name\n\nclass Child(Person):\ndef **init**(self, name, age) -\u003e None:\nsuper().**init**(name, age)\n\n    def go_to_school(self) -\u003e None:\n        print(f\"{self.name} is going to school.\")\n\nclass Adult(Person):\ndef **init**(self, name, age) -\u003e None:\nsuper().**init**(name, age)\n\n    def vote(self) -\u003e int:\n        return 1\n\n이제 프로그램의 정확성에 영향을 주지 않고 Person 유형의 객체를 Child 또는 Adult 유형의 객체로 대체할 수 있습니다.\n\n## 4. Interface Segregation Principle (ISP)\n\n인터페이스 분리 원칙(Interface Segregation Principle, ISP)은 Uncle Bob이 만들었습니다. 이 원칙은 다음과 같이 설명합니다:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n큰 인터페이스를 피해야 합니다. 이는 모든 클라이언트가 구현하는 인터페이스 메서드를 사용하지 않는 대규모 인터페이스를 의미합니다.\n\n예를 들어, 다음과 같은 인터페이스를 고려해 보세요:\n\n```python\nfrom abc import ABC, abstractmethod\n\nclass Printer(ABC):\n    def scan(self) -\u003e None: ...\n\n    def fax(self) -\u003e None: ...\n\n    def print(self) -\u003e None: ...\n\n\nclass SimplePrinter(Printer):\n    def scan(self) -\u003e None:\n        raise NotImplementedError(\"This printer cannot scan.\")\n\n    def fax(self) -\u003e None:\n        raise NotImplementedError(\"This printer cannot fax.\")\n\n    def print(self) -\u003e None:\n        print(\"Printing...\")\n\n\nclass AdvancedPrinter(Printer):\n    def scan(self) -\u003e None:\n        print(\"Scanning...\")\n\n    def fax(self) -\u003e None:\n        print(\"Faxing...\")\n\n    def print(self) -\u003e None:\n        print(\"Printing...\")\n```\n\n이 경우, SimplePrinter 클래스는 scan 및 fax 메서드가 필요하지 않지만, Printer 인터페이스를 구현하므로 이들을 구현해야 합니다. 이는 인터페이스 격리 원칙을 위반하는 것입니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그 대신, Printer 인터페이스를 Scanner, Fax 및 Printer 세 개의 별도의 인터페이스로 분리할 수 있습니다.\n\n```js\nfrom abc import ABC, abstractmethod\n\n\nclass Scanner(ABC):\n    @abstractmethod\n    def scan(self) -\u003e None:\n        ...\n\n\nclass Fax(ABC):\n    @abstractmethod\n    def fax(self) -\u003e None:\n        ...\n\n\nclass Printer(ABC):\n    @abstractmethod\n    def print(self) -\u003e None:\n        ...\n\n\nclass SimplePrinter(Printer):\n    def print(self) -\u003e None:\n        print(\"Printing...\")\n\n\nclass AdvancedPrinter(Scanner, Fax, Printer):\n    def scan(self) -\u003e None:\n        print(\"Scanning...\")\n\n    def fax(self) -\u003e None:\n        print(\"Faxing...\")\n\n    def print(self) -\u003e None:\n        print(\"Printing...\")\n```\n\n이제 SimplePrinter 클래스는 Printer 인터페이스만 구현하면 되고, AdvancedPrinter 클래스는 세 인터페이스를 모두 구현할 수 있습니다.\n\n이 방식을 통해 코드를 이해하기 쉽게 만들고 SimplePrinter 클래스에 불필요한 메서드가 필요 없어졌습니다.\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 5. 의존성 역전 원칙\n\n언클 밥이 만든 의존성 역전 원칙은 다음과 같습니다:\n\n이 원칙은 고수준 모듈과 저수준 모듈을 결합을 느슨하게 하기 위해 그들 사이에 추상화 계층을 도입하는 것에 관한 것입니다. 이를 통해 결합이 적고 유연한 시스템을 만들 수 있습니다.\n\n다음은 의존성 역전 원칙을 위반하는 예시입니다. 고수준 모듈인 PaymentService가 저수준 모듈인 PaypalProcessor에 직접 의존하는 것입니다:\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nclass PaypalProcessor:\n    def process_payment(self, amount):\n        print(f\"Processing payment of ${amount} via PayPal\")\n\n\nclass PaymentService:\n    def __init__(self) -\u003e None:\n        self.payment_processor = PaypalProcessor()\n\n    def perform_payment(self, amount):\n        self.payment_processor.process_payment(amount)\n\n\npayment_service = PaymentService()\npayment_service.perform_payment(100)\n```\n\n만약 다른 결제 게이트웨이로 전환하고 싶다면, PaymentService 클래스를 수정해야 하는데 이는 개방-폐쇄 원칙을 위배합니다.\n\n대신, 우리가 결제를 처리하는 PaymentService 고수준 모듈과 PayPal, Stripe와 같은 다른 결제 게이트웨이와 상호 작용할 수 있는 추상 인터페이스인 PaymentProcessor가 있는 것으로 가정해 봅시다.\n\n```python\nfrom abc import ABC, abstractmethod\n\n\nclass PaymentProcessor(ABC):\n    @abstractmethod\n    def process_payment(self, amount):\n        pass\n\n\nclass PayPalPaymentProcessor(PaymentProcessor):\n    def process_payment(self, amount):\n        print(f\"Processing payment of ${amount} via PayPal\")\n\n\nclass StripePaymentProcessor(PaymentProcessor):\n    def process_payment(self, amount):\n        print(f\"Processing payment of ${amount} via Stripe\")\n\n\nclass PaymentService:\n    def __init__(self, payment_processor):\n        self.payment_processor = payment_processor\n\n    def perform_payment(self, amount):\n        self.payment_processor.process_payment(amount)\n\n\npaypal_processor = PayPalPaymentProcessor()\npayment_service = PaymentService(paypal_processor)\npayment_service.perform_payment(100)\n```\n\n\u003c!-- TIL 수평 --\u003e\n\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이렇게하면 PaymentService 클래스는 특정 결제 프로세서 구현에 의존하지 않습니다. 대신 PaymentProcessor 인터페이스에 의존하고 있어서 PaymentService 클래스를 수정하지 않고도 다양한 결제 프로세서 간에 전환할 수 있습니다.\n\n# 결론\n\nSOLID 원칙은 깨끗하고 유지보수 가능하며 유연한 코드를 작성하는 데 도움이 되는 일련의 지침입니다. 이러한 원칙을 따르면 이해하기 쉬우며 테스트하고 유지하기 쉬운 코드를 만들 수 있습니다. 이러한 원칙에 적응하는 데는 시간이 걸릴 수 있지만, 확실히 더 나은 프로그래머가 되고 더 나은 소프트웨어를 만들 수 있도록 도와줄 것입니다. 이들은 가이드라인이며 절대적인 규칙이 아니므로 현명하게 사용하고 특정 요구사항에 맞게 적용하십시오.\n","ogImage":{"url":"/assets/img/2024-07-09-SOLIDprinciplesinPython_0.png"},"coverImage":"/TIL/assets/img/2024-07-09-SOLIDprinciplesinPython_0.png","tag":["Tech"],"readingTime":15},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/TIL/assets/img/2024-07-09-SOLIDprinciplesinPython_0.png\" alt=\"SOLID principles in Python\"\u003e\u003c/p\u003e\n\u003ch1\u003eSOLID이란 무엇인가요?\u003c/h1\u003e\n\u003cp\u003e객체 지향 프로그래밍은 모든 프로그래머의 도구 상자에서 매우 유용한 도구입니다. 그러나 사용할 때 대부분의 사람들이 빠지는 흔한 함정이 있습니다.\u003c/p\u003e\n\u003cp\u003eSOLID 원칙은 이러한 함정을 피하고 깔끔하고 유지보수 가능한 코드를 작성하는 데 도움이 되는 일련의 지침입니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e\"SOLID\"은 다음을 나타내는 머리글자입니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e단일 책임 원칙 (SRP)\u003c/li\u003e\n\u003cli\u003e개방/폐쇠 원칙 (OCP)\u003c/li\u003e\n\u003cli\u003e리스코프 치환 원칙 (LSP)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e인터페이스 분리 원칙\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e의존성 역전 원칙\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e1. 단일 책임 원칙 (SRP)\u003c/h2\u003e\n\u003cp\u003e로버트 C. 마틴 (a.k.a 아저씨 밥)이 \"OOD의 원칙\"이라는 기사에서 만들어진 단일 책임 원칙은 다음과 같습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e한 클래스는 한 가지 책임만 가져야 합니다. 한 클래스가 여러 가지 일을 한다면, 여러 클래스로 분리해야 합니다.\u003c/p\u003e\n\u003cp\u003e간단한 예를 통해 이를 설명해보겠습니다. 우리가 Google 드라이브 또는 Dropbox에서 객체를 읽고 쓰는 클래스가 있다고 가정해 봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eStorageClient\u003c/span\u003e:\n    _instance = \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e\n    _google_client = \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e\n    _dropbox_client = \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e\n\n    def \u003cspan class=\"hljs-title function_\"\u003e__init__\u003c/span\u003e(self, google_credentials, dropbox_credentials) -\u003e \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e:\n        self.\u003cspan class=\"hljs-property\"\u003e_google_client\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"Google 클라이언트\"\u003c/span\u003e\n        self.\u003cspan class=\"hljs-property\"\u003e_dropbox_client\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"Dropbox 클라이언트\"\u003c/span\u003e\n\n    @classmethod\n    def \u003cspan class=\"hljs-title function_\"\u003eget_or_create_instance\u003c/span\u003e(cls, google_credentials, dropbox_credentials) -\u003e \u003cspan class=\"hljs-string\"\u003e\"StorageClient\"\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e not cls.\u003cspan class=\"hljs-property\"\u003e_instance\u003c/span\u003e:\n            cls.\u003cspan class=\"hljs-property\"\u003e_instance\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eStorageClient\u003c/span\u003e(google_credentials, dropbox_credentials)\n\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e cls.\u003cspan class=\"hljs-property\"\u003e_instance\u003c/span\u003e\n\n    def \u003cspan class=\"hljs-title function_\"\u003eread_from_google\u003c/span\u003e(self, key):\n        ...\n\n    def \u003cspan class=\"hljs-title function_\"\u003eupload_to_google\u003c/span\u003e(self, key, value):\n        ...\n\n    def \u003cspan class=\"hljs-title function_\"\u003eread_from_dropbox\u003c/span\u003e(self, key):\n        ...\n\n    def \u003cspan class=\"hljs-title function_\"\u003eupload_to_dropbox\u003c/span\u003e(self, key, value):\n        ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 클래스의 문제는 두 가지 책임을 가지고 있다는 점입니다. Google 드라이브 및 Dropbox에서 객체를 읽고 쓰는 데에 대한 별도의 로직을 구현해야 합니다. SRP를 준수하기 위해 이 클래스를 GoogleStorageClient와 DropboxStorageClient로 분리할 수 있습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eGoogleStorageClient\u003c/span\u003e:\n    _instance = \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e\n    _google_client = \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e\n\n    def \u003cspan class=\"hljs-title function_\"\u003e__init__\u003c/span\u003e(self, google_credentials) -\u003e \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e:\n        self.\u003cspan class=\"hljs-property\"\u003e_google_client\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"Google client\"\u003c/span\u003e\n\n    @classmethod\n    def \u003cspan class=\"hljs-title function_\"\u003eget_or_create_instance\u003c/span\u003e(cls, google_credentials) -\u003e \u003cspan class=\"hljs-string\"\u003e\"GoogleStorageClient\"\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e not cls.\u003cspan class=\"hljs-property\"\u003e_instance\u003c/span\u003e:\n            cls.\u003cspan class=\"hljs-property\"\u003e_instance\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eGoogleStorageClient\u003c/span\u003e(google_credentials)\n\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e cls.\u003cspan class=\"hljs-property\"\u003e_instance\u003c/span\u003e\n\n    def \u003cspan class=\"hljs-title function_\"\u003eread\u003c/span\u003e(self, key):\n        ...\n\n    def \u003cspan class=\"hljs-title function_\"\u003eupload\u003c/span\u003e(self, key, value):\n        ...\n\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDropboxStorageClient\u003c/span\u003e:\n    _instance = \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e\n    _dropbox_client = \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e\n\n    def \u003cspan class=\"hljs-title function_\"\u003e__init__\u003c/span\u003e(self, dropbox_credentials) -\u003e \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e:\n        self.\u003cspan class=\"hljs-property\"\u003e_dropbox_client\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"Dropbox client\"\u003c/span\u003e\n\n    @classmethod\n    def \u003cspan class=\"hljs-title function_\"\u003eget_or_create_instance\u003c/span\u003e(cls, dropbox_credentials) -\u003e \u003cspan class=\"hljs-string\"\u003e\"DropboxStorageClient\"\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e not cls.\u003cspan class=\"hljs-property\"\u003e_instance\u003c/span\u003e:\n            cls.\u003cspan class=\"hljs-property\"\u003e_instance\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eDropboxStorageClient\u003c/span\u003e(dropbox_credentials)\n\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e cls.\u003cspan class=\"hljs-property\"\u003e_instance\u003c/span\u003e\n\n    def \u003cspan class=\"hljs-title function_\"\u003eread\u003c/span\u003e(self, key):\n        ...\n\n    def \u003cspan class=\"hljs-title function_\"\u003eupload\u003c/span\u003e(self, key, value):\n        ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e조금 더 상세하게 작성하더라도, 두 클라이언트를 개별적으로 개발하고 코드를 더 유지보수하기 쉽게 만듭니다. 예를 들어 Google 클라이언트를 작업하는 사람은 Dropbox 클라이언트의 작동 방식을 알 필요가 없으며 그 반대도 마찬가지입니다.\u003c/p\u003e\n\u003ch2\u003e2. 개방/폐쇄 원칙 (OCP)\u003c/h2\u003e\n\u003cp\u003e버트랜드 메이어는 1988년 저술한 \"객체지향 소프트웨어 구성\"에서 개방-폐쇄 원칙을 처음 제안한 것으로 일반적으로 알려져 있습니다. 그러나 1990년대에 이 원칙은 언클 밥이 1996년에 발표한 \"개방-폐쇄 원칙\"으로 현재의 형태로 재정의되었습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e개방/폐쇄 원칙은 다음을 의미합니다:\u003c/p\u003e\n\u003cp\u003e클래스에 새 기능을 추가할 수 있어야 하며 기존 코드를 변경하지 않아도 됩니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, 다음 클래스는 개방/폐쇄 원칙을 위반합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eVehicle\u003c/span\u003e:\n    def \u003cspan class=\"hljs-title function_\"\u003e__init__\u003c/span\u003e(self, vehicle_type, **kwargs) -\u003e \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e:\n        self.\u003cspan class=\"hljs-property\"\u003evehicle\u003c/span\u003e = vehicle_type\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e self.\u003cspan class=\"hljs-property\"\u003evehicle_type\u003c/span\u003e == \u003cspan class=\"hljs-string\"\u003e\"car\"\u003c/span\u003e:\n            self.\u003cspan class=\"hljs-property\"\u003etires\u003c/span\u003e = kwargs[\u003cspan class=\"hljs-string\"\u003e\"tires\"\u003c/span\u003e]\n            self.\u003cspan class=\"hljs-property\"\u003emode\u003c/span\u003e = kwargs[\u003cspan class=\"hljs-string\"\u003e\"mode\"\u003c/span\u003e]\n        elif self.\u003cspan class=\"hljs-property\"\u003evehicle_type\u003c/span\u003e == \u003cspan class=\"hljs-string\"\u003e\"boat\"\u003c/span\u003e:\n            self.\u003cspan class=\"hljs-property\"\u003emotors\u003c/span\u003e = kwargs[\u003cspan class=\"hljs-string\"\u003e\"motors\"\u003c/span\u003e]\n            self.\u003cspan class=\"hljs-property\"\u003emode\u003c/span\u003e = kwargs[\u003cspan class=\"hljs-string\"\u003e\"mode\"\u003c/span\u003e]\n\n    def \u003cspan class=\"hljs-title function_\"\u003eget_specifications\u003c/span\u003e(self) -\u003e \u003cspan class=\"hljs-attr\"\u003estr\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e self.\u003cspan class=\"hljs-property\"\u003evehicle_type\u003c/span\u003e == \u003cspan class=\"hljs-string\"\u003e\"car\"\u003c/span\u003e:\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e f\u003cspan class=\"hljs-string\"\u003e\"This {self.vehicle_type} has {self.tires} tires and can drive on {self.mode}.\"\u003c/span\u003e\n        elif self.\u003cspan class=\"hljs-property\"\u003evehicle_type\u003c/span\u003e == \u003cspan class=\"hljs-string\"\u003e\"boat\"\u003c/span\u003e:\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e f\u003cspan class=\"hljs-string\"\u003e\"This {self.vehicle_type} has {self.motors} motors and can float on {self.mode}.\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 클래스의 문제점은 새로운 차량, 예를 들어 비행기를 추가하려면 기존 클래스를 수정해야 한다는 것입니다.\u003c/p\u003e\n\u003cp\u003e기존 코드를 수정하는 것은 위험할 수 있으며 버그를 도입할 수도 있고 유닛 테스트를 실패할 수도 있습니다.\u003c/p\u003e\n\u003cp\u003e대신 추상 기본 클래스를 정의하고 상속을 사용하여 클래스가 개방/폐쇄 원칙을 따르도록 할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e abc \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eABC\u003c/span\u003e, abstractmethod\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eVehicle\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eABC\u003c/span\u003e):\n    def \u003cspan class=\"hljs-title function_\"\u003e__init__\u003c/span\u003e(self, mode) -\u003e \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e:\n        self.\u003cspan class=\"hljs-property\"\u003emode\u003c/span\u003e = mode\n\n    @abstractmethod\n    def \u003cspan class=\"hljs-title function_\"\u003eget_specifications\u003c/span\u003e(self) -\u003e \u003cspan class=\"hljs-attr\"\u003estr\u003c/span\u003e:\n        ...\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCar\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eVehicle\u003c/span\u003e):\n    def \u003cspan class=\"hljs-title function_\"\u003e__init__\u003c/span\u003e(self, tires) -\u003e \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e:\n        \u003cspan class=\"hljs-variable language_\"\u003esuper\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003e__init__\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"lane\"\u003c/span\u003e)\n        self.\u003cspan class=\"hljs-property\"\u003etires\u003c/span\u003e = tires\n\n    def \u003cspan class=\"hljs-title function_\"\u003eget_specifications\u003c/span\u003e(self) -\u003e \u003cspan class=\"hljs-attr\"\u003estr\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e f\u003cspan class=\"hljs-string\"\u003e\"This car has {self.tires} tires and can drive on {self.mode}.\"\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBoat\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eVehicle\u003c/span\u003e):\n    def \u003cspan class=\"hljs-title function_\"\u003e__init__\u003c/span\u003e(self, motors) -\u003e \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e:\n        \u003cspan class=\"hljs-variable language_\"\u003esuper\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003e__init__\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"water\"\u003c/span\u003e)\n        self.\u003cspan class=\"hljs-property\"\u003emotors\u003c/span\u003e = motors\n\n    def \u003cspan class=\"hljs-title function_\"\u003eget_specifications\u003c/span\u003e(self) -\u003e \u003cspan class=\"hljs-attr\"\u003estr\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e f\u003cspan class=\"hljs-string\"\u003e\"This boat has {self.motors} motors and can float on {self.mode}.\"\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePlane\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eVehicle\u003c/span\u003e):\n    def \u003cspan class=\"hljs-title function_\"\u003e__init__\u003c/span\u003e(self, engines) -\u003e \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e:\n        \u003cspan class=\"hljs-variable language_\"\u003esuper\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003e__init__\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"air\"\u003c/span\u003e)\n        self.\u003cspan class=\"hljs-property\"\u003eengines\u003c/span\u003e = engines\n\n    def \u003cspan class=\"hljs-title function_\"\u003eget_specifications\u003c/span\u003e(self) -\u003e \u003cspan class=\"hljs-attr\"\u003estr\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e f\u003cspan class=\"hljs-string\"\u003e\"This plane has {self.engines} engines and can fly through the {self.mode}.\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이제 새 차량을 추가하고 싶다면, 단순히 Vehicle 클래스를 상속하고 get_specifications 메서드를 구현하는 새 클래스를 생성하면 됩니다.\u003c/p\u003e\n\u003ch2\u003e3. 리스코프 치환 원칙 (LSP)\u003c/h2\u003e\n\u003cp\u003e리스코프 치환 원칙은 1987년 OOPSLA 컨퍼런스에서 Barbara Liskov에 의해 소개되었습니다. 이 원칙은 다음과 같습니다:\u003c/p\u003e\n\u003cp\u003e다시 말해, 만약 \u003ccode\u003eS\u003c/code\u003e가 \u003ccode\u003eT\u003c/code\u003e의 서브 클래스라면, \u003ccode\u003eT\u003c/code\u003e 타입의 객체를 \u003ccode\u003eS\u003c/code\u003e 타입의 객체로 대체할 수 있어야 하며, 프로그램의 기능을 변경하지 않아야 합니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e예를 들어, 다음과 같은 클래스를 고려해보세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePerson\u003c/span\u003e:\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e__init__\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself, name, age\u003c/span\u003e) -\u003e \u003cspan class=\"hljs-literal\"\u003eNone\u003c/span\u003e:\n        self.name = name\n        self.age = age\n\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eget_name\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself\u003c/span\u003e) -\u003e \u003cspan class=\"hljs-built_in\"\u003estr\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e self.name\n\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003evote\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself, give_vote\u003c/span\u003e) -\u003e \u003cspan class=\"hljs-built_in\"\u003eint\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e give_vote:\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eChild\u003c/span\u003e(\u003cspan class=\"hljs-title class_ inherited__\"\u003ePerson\u003c/span\u003e):\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e__init__\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself, name, age\u003c/span\u003e) -\u003e \u003cspan class=\"hljs-literal\"\u003eNone\u003c/span\u003e:\n        \u003cspan class=\"hljs-built_in\"\u003esuper\u003c/span\u003e().__init__(name, age)\n\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003evote\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself\u003c/span\u003e) -\u003e \u003cspan class=\"hljs-literal\"\u003eNone\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003eraise\u003c/span\u003e NotImplementedError(\u003cspan class=\"hljs-string\"\u003e\"어린이는 투표할 수 없습니다.\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 코드의 문제는 Child 클래스가 리스코프 치환 원칙을 위반한다는 것입니다. Person 타입의 객체를 Child 타입의 객체로 대체하려고 하면, 예를 들어 vote 메서드를 사용하려고 할 때 프로그램이 예상대로 동작하지 않을 것입니다.\u003c/p\u003e\n\u003cp\u003e이 문제를 해결하기 위해서는 Person을 추상 기본 클래스로 변환하고, 그것을 상속하는 Child와 Adult 두 클래스를 만들면 됩니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003efrom abc import ABC, abstractmethod\u003c/p\u003e\n\u003cp\u003eclass Person(ABC):\ndef \u003cstrong\u003einit\u003c/strong\u003e(self, name, age) -\u003e None:\nself.name = name\nself.age = age\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edef get_name(self) -\u003e str:\n    return self.name\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eclass Child(Person):\ndef \u003cstrong\u003einit\u003c/strong\u003e(self, name, age) -\u003e None:\nsuper().\u003cstrong\u003einit\u003c/strong\u003e(name, age)\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edef go_to_school(self) -\u003e None:\n    print(f\"{self.name} is going to school.\")\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eclass Adult(Person):\ndef \u003cstrong\u003einit\u003c/strong\u003e(self, name, age) -\u003e None:\nsuper().\u003cstrong\u003einit\u003c/strong\u003e(name, age)\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edef vote(self) -\u003e int:\n    return 1\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 프로그램의 정확성에 영향을 주지 않고 Person 유형의 객체를 Child 또는 Adult 유형의 객체로 대체할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e4. Interface Segregation Principle (ISP)\u003c/h2\u003e\n\u003cp\u003e인터페이스 분리 원칙(Interface Segregation Principle, ISP)은 Uncle Bob이 만들었습니다. 이 원칙은 다음과 같이 설명합니다:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e큰 인터페이스를 피해야 합니다. 이는 모든 클라이언트가 구현하는 인터페이스 메서드를 사용하지 않는 대규모 인터페이스를 의미합니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, 다음과 같은 인터페이스를 고려해 보세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e abc \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e ABC, abstractmethod\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePrinter\u003c/span\u003e(\u003cspan class=\"hljs-title class_ inherited__\"\u003eABC\u003c/span\u003e):\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003escan\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself\u003c/span\u003e) -\u003e \u003cspan class=\"hljs-literal\"\u003eNone\u003c/span\u003e: ...\n\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efax\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself\u003c/span\u003e) -\u003e \u003cspan class=\"hljs-literal\"\u003eNone\u003c/span\u003e: ...\n\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself\u003c/span\u003e) -\u003e \u003cspan class=\"hljs-literal\"\u003eNone\u003c/span\u003e: ...\n\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSimplePrinter\u003c/span\u003e(\u003cspan class=\"hljs-title class_ inherited__\"\u003ePrinter\u003c/span\u003e):\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003escan\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself\u003c/span\u003e) -\u003e \u003cspan class=\"hljs-literal\"\u003eNone\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003eraise\u003c/span\u003e NotImplementedError(\u003cspan class=\"hljs-string\"\u003e\"This printer cannot scan.\"\u003c/span\u003e)\n\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efax\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself\u003c/span\u003e) -\u003e \u003cspan class=\"hljs-literal\"\u003eNone\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003eraise\u003c/span\u003e NotImplementedError(\u003cspan class=\"hljs-string\"\u003e\"This printer cannot fax.\"\u003c/span\u003e)\n\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself\u003c/span\u003e) -\u003e \u003cspan class=\"hljs-literal\"\u003eNone\u003c/span\u003e:\n        \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Printing...\"\u003c/span\u003e)\n\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAdvancedPrinter\u003c/span\u003e(\u003cspan class=\"hljs-title class_ inherited__\"\u003ePrinter\u003c/span\u003e):\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003escan\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself\u003c/span\u003e) -\u003e \u003cspan class=\"hljs-literal\"\u003eNone\u003c/span\u003e:\n        \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Scanning...\"\u003c/span\u003e)\n\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efax\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself\u003c/span\u003e) -\u003e \u003cspan class=\"hljs-literal\"\u003eNone\u003c/span\u003e:\n        \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Faxing...\"\u003c/span\u003e)\n\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself\u003c/span\u003e) -\u003e \u003cspan class=\"hljs-literal\"\u003eNone\u003c/span\u003e:\n        \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Printing...\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 경우, SimplePrinter 클래스는 scan 및 fax 메서드가 필요하지 않지만, Printer 인터페이스를 구현하므로 이들을 구현해야 합니다. 이는 인터페이스 격리 원칙을 위반하는 것입니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e그 대신, Printer 인터페이스를 Scanner, Fax 및 Printer 세 개의 별도의 인터페이스로 분리할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e abc \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eABC\u003c/span\u003e, abstractmethod\n\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eScanner\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eABC\u003c/span\u003e):\n    @abstractmethod\n    def \u003cspan class=\"hljs-title function_\"\u003escan\u003c/span\u003e(self) -\u003e \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e:\n        ...\n\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFax\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eABC\u003c/span\u003e):\n    @abstractmethod\n    def \u003cspan class=\"hljs-title function_\"\u003efax\u003c/span\u003e(self) -\u003e \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e:\n        ...\n\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePrinter\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eABC\u003c/span\u003e):\n    @abstractmethod\n    def \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(self) -\u003e \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e:\n        ...\n\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSimplePrinter\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003ePrinter\u003c/span\u003e):\n    def \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(self) -\u003e \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e:\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Printing...\"\u003c/span\u003e)\n\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAdvancedPrinter\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eScanner\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eFax\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003ePrinter\u003c/span\u003e):\n    def \u003cspan class=\"hljs-title function_\"\u003escan\u003c/span\u003e(self) -\u003e \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e:\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Scanning...\"\u003c/span\u003e)\n\n    def \u003cspan class=\"hljs-title function_\"\u003efax\u003c/span\u003e(self) -\u003e \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e:\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Faxing...\"\u003c/span\u003e)\n\n    def \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(self) -\u003e \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e:\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Printing...\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 SimplePrinter 클래스는 Printer 인터페이스만 구현하면 되고, AdvancedPrinter 클래스는 세 인터페이스를 모두 구현할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 방식을 통해 코드를 이해하기 쉽게 만들고 SimplePrinter 클래스에 불필요한 메서드가 필요 없어졌습니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e5. 의존성 역전 원칙\u003c/h2\u003e\n\u003cp\u003e언클 밥이 만든 의존성 역전 원칙은 다음과 같습니다:\u003c/p\u003e\n\u003cp\u003e이 원칙은 고수준 모듈과 저수준 모듈을 결합을 느슨하게 하기 위해 그들 사이에 추상화 계층을 도입하는 것에 관한 것입니다. 이를 통해 결합이 적고 유연한 시스템을 만들 수 있습니다.\u003c/p\u003e\n\u003cp\u003e다음은 의존성 역전 원칙을 위반하는 예시입니다. 고수준 모듈인 PaymentService가 저수준 모듈인 PaypalProcessor에 직접 의존하는 것입니다:\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePaypalProcessor\u003c/span\u003e:\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eprocess_payment\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself, amount\u003c/span\u003e):\n        \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003ef\"Processing payment of $\u003cspan class=\"hljs-subst\"\u003e{amount}\u003c/span\u003e via PayPal\"\u003c/span\u003e)\n\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePaymentService\u003c/span\u003e:\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e__init__\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself\u003c/span\u003e) -\u003e \u003cspan class=\"hljs-literal\"\u003eNone\u003c/span\u003e:\n        self.payment_processor = PaypalProcessor()\n\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eperform_payment\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself, amount\u003c/span\u003e):\n        self.payment_processor.process_payment(amount)\n\n\npayment_service = PaymentService()\npayment_service.perform_payment(\u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e만약 다른 결제 게이트웨이로 전환하고 싶다면, PaymentService 클래스를 수정해야 하는데 이는 개방-폐쇄 원칙을 위배합니다.\u003c/p\u003e\n\u003cp\u003e대신, 우리가 결제를 처리하는 PaymentService 고수준 모듈과 PayPal, Stripe와 같은 다른 결제 게이트웨이와 상호 작용할 수 있는 추상 인터페이스인 PaymentProcessor가 있는 것으로 가정해 봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e abc \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e ABC, abstractmethod\n\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePaymentProcessor\u003c/span\u003e(\u003cspan class=\"hljs-title class_ inherited__\"\u003eABC\u003c/span\u003e):\n\u003cspan class=\"hljs-meta\"\u003e    @abstractmethod\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eprocess_payment\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself, amount\u003c/span\u003e):\n        \u003cspan class=\"hljs-keyword\"\u003epass\u003c/span\u003e\n\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePayPalPaymentProcessor\u003c/span\u003e(\u003cspan class=\"hljs-title class_ inherited__\"\u003ePaymentProcessor\u003c/span\u003e):\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eprocess_payment\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself, amount\u003c/span\u003e):\n        \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003ef\"Processing payment of $\u003cspan class=\"hljs-subst\"\u003e{amount}\u003c/span\u003e via PayPal\"\u003c/span\u003e)\n\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eStripePaymentProcessor\u003c/span\u003e(\u003cspan class=\"hljs-title class_ inherited__\"\u003ePaymentProcessor\u003c/span\u003e):\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eprocess_payment\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself, amount\u003c/span\u003e):\n        \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003ef\"Processing payment of $\u003cspan class=\"hljs-subst\"\u003e{amount}\u003c/span\u003e via Stripe\"\u003c/span\u003e)\n\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePaymentService\u003c/span\u003e:\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e__init__\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself, payment_processor\u003c/span\u003e):\n        self.payment_processor = payment_processor\n\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eperform_payment\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself, amount\u003c/span\u003e):\n        self.payment_processor.process_payment(amount)\n\n\npaypal_processor = PayPalPaymentProcessor()\npayment_service = PaymentService(paypal_processor)\npayment_service.perform_payment(\u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이렇게하면 PaymentService 클래스는 특정 결제 프로세서 구현에 의존하지 않습니다. 대신 PaymentProcessor 인터페이스에 의존하고 있어서 PaymentService 클래스를 수정하지 않고도 다양한 결제 프로세서 간에 전환할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003eSOLID 원칙은 깨끗하고 유지보수 가능하며 유연한 코드를 작성하는 데 도움이 되는 일련의 지침입니다. 이러한 원칙을 따르면 이해하기 쉬우며 테스트하고 유지하기 쉬운 코드를 만들 수 있습니다. 이러한 원칙에 적응하는 데는 시간이 걸릴 수 있지만, 확실히 더 나은 프로그래머가 되고 더 나은 소프트웨어를 만들 수 있도록 도와줄 것입니다. 이들은 가이드라인이며 절대적인 규칙이 아니므로 현명하게 사용하고 특정 요구사항에 맞게 적용하십시오.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-07-09-SOLIDprinciplesinPython"},"buildId":"M7pU9hOcx8u_ZIFMf95sd","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>