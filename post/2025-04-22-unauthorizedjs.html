<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Next.js 15에서 Unauthorized.js로 권한 없는 접근 처리하는 방법 | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-unauthorizedjs" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Next.js 15에서 Unauthorized.js로 권한 없는 접근 처리하는 방법 | TIL" data-gatsby-head="true"/><meta property="og:title" content="Next.js 15에서 Unauthorized.js로 권한 없는 접근 처리하는 방법 | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-unauthorizedjs" data-gatsby-head="true"/><meta name="twitter:title" content="Next.js 15에서 Unauthorized.js로 권한 없는 접근 처리하는 방법 | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2025-04-22 02:47" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/0eef537492fed77a.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/0eef537492fed77a.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/post/%5Bslug%5D-8ded8b979ba73586.js" defer=""></script><script src="/TIL/_next/static/KUC9M_yIlA1Ugo01xmkHL/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/KUC9M_yIlA1Ugo01xmkHL/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Next.js 15에서 Unauthorized.js로 권한 없는 접근 처리하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Next.js 15에서 Unauthorized.js로 권한 없는 접근 처리하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Apr 22, 2025</span><span class="posts_reading_time__f7YPP">5<!-- --> min read</span></span></div></div></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h1>unauthorized.js</h1>
<p><code>unauthorized.js</code> 파일은 인증 과정에서 <code>unauthorized</code> 함수가 호출될 때 보여줄 UI를 렌더링하는 역할을 해요. 이 파일을 통해 UI를 원하는 대로 꾸밀 수 있을 뿐만 아니라, Next.js가 자동으로 401 상태 코드를 반환해 준답니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Login</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'@/app/components/Login'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Unauthorized</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">main</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">h1</span>></span>401 - Unauthorized<span class="hljs-tag">&#x3C;/<span class="hljs-name">h1</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>Please log in to access this page.<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">Login</span> /></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">main</span>></span></span>
  )
}
</code></pre>
<p>위 코드를 보면, 기본적으로 "401 - Unauthorized"라는 제목과 함께 로그인을 요청하는 문구가 보이고, <code>Login</code> 컴포넌트를 렌더링해 실제 로그인 화면도 함께 표시하고 있어요.</p>
<h3>조금 더 알아보기</h3>
<ul>
<li>
<p><strong>401 상태 코드란?</strong><br>
401은 '인증이 필요함'을 나타내는 HTTP 상태 코드로, 사용자가 인증되지 않은 상태에서 접근 권한이 필요한 페이지에 접근할 때 서버가 보내요.</p>
</li>
<li>
<p><strong>Next.js에서의 활용 팁</strong><br>
이 파일을 커스터마이징하면 에러 페이지를 여러분의 서비스 스타일에 맞게 꾸밀 수 있답니다. 예를 들어, 로그인 버튼 대신 소셜 로그인이나 회원가입으로 유도하는 링크도 넣어볼 수 있겠죠?</p>
</li>
<li>
<p><strong>추가로 하면 좋은 것</strong><br>
사용자가 왜 인증이 필요한지 좀 더 자세한 안내나, 인증 절차에 도움이 될 만한 FAQ 링크를 같이 넣으면 UX가 더 좋아질 수 있어요.</p>
</li>
</ul>
<p>필요하면 한 번 직접 만들어보고, 여러분만의 인증 오류 페이지도 멋지게 만들어 보세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h3>Props</h3>
<p><code>unauthorized.js</code> 컴포넌트는 어떤 props도 받지 않습니다.</p>
<h2>예시</h2>
<h3>로그인하지 않은 사용자에게 로그인 UI 보여주기</h3>
<p>로그인하지 않은 사용자를 대상으로 로그인 화면을 보여주고 싶을 때, <code>unauthorized.js</code> 컴포넌트를 사용할 수 있어요. 참고로 이 컴포넌트는 추가 설정을 위해 props를 받지 않으니, 간단하게 기본 UI를 렌더링하는 용도로 쓴다는 점 기억하세요.</p>
<p>만약 내 서비스에서 로그인 여부에 따라 다른 화면을 보여줘야 한다면, 조건문으로 이 컴포넌트를 넣어주면 됩니다. 예를 들어:</p>
<pre><code class="hljs language-jsx">{ !userIsLoggedIn &#x26;&#x26; <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Unauthorized</span> /></span></span> }
</code></pre>
<p>이렇게 하면 인증되지 않은 사용자에게만 로그인 페이지가 표시되고, 이미 로그인한 사용자에겐 다른 화면이 보여지겠죠?</p>
<p>추가로, <code>unauthorized.js</code> 컴포넌트 내부를 수정해 나만의 로그인 UI로 커스터마이징해도 좋습니다. 그럴 땐 props 대신 내부 상태나 리덕스 등 상태관리 라이브러리를 이용해서 유연하게 UX를 조절해보세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>여러분 안녕하세요! 오늘은 Next.js 앱에서 인증이 필요한 페이지에 대해 'unauthorized' 함수를 이용해 인증되지 않은 사용자에게 로그인 UI를 보여주는 방법을 쉽게 설명해드릴게요.</p>
<p>먼저, <code>DashboardPage</code> 컴포넌트를 살펴봅시다. 여기서는 <code>verifySession()</code> 함수를 통해 사용자의 세션 정보를 확인하는데요, 이 함수는 비동기 함수라 <code>await</code>를 붙여 호출해주고 있어요.</p>
<pre><code class="hljs language-jsx"><span class="hljs-keyword">import</span> { verifySession } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/app/lib/dal'</span>
<span class="hljs-keyword">import</span> { unauthorized } <span class="hljs-keyword">from</span> <span class="hljs-string">'next/navigation'</span>
 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">DashboardPage</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> session = <span class="hljs-keyword">await</span> <span class="hljs-title function_">verifySession</span>()
 
  <span class="hljs-keyword">if</span> (!session) {
    <span class="hljs-title function_">unauthorized</span>()
  }
 
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>Dashboard<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
}
</code></pre>
<ul>
<li><code>verifySession()</code> 함수가 null 또는 undefined를 반환한다면 세션이 없는 것으로 간주하고, <code>unauthorized()</code> 함수를 호출해버립니다.</li>
<li>이 <code>unauthorized()</code> 함수는 내부적으로 Next.js에 내장된 기능으로, 렌더링을 멈추고 <code>unauthorized.js</code> 파일을 호출해서 401 페이지를 보여주게 해줍니다.</li>
</ul>
<p>그럼 그 <code>unauthorized.js</code> 파일에 어떤 컴포넌트가 있냐면,</p>
<pre><code class="hljs language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Login</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'@/app/components/Login'</span>
 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">UnauthorizedPage</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">main</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">h1</span>></span>401 - Unauthorized<span class="hljs-tag">&#x3C;/<span class="hljs-name">h1</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>Please log in to access this page.<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">Login</span> /></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">main</span>></span></span>
  )
}
</code></pre>
<p>이렇게 간단하게 로그인 UI를 포함한 페이지를 만들고 있어요. 화면에 “401 - Unauthorized” 메시지와 로그인 폼이 나타나게 되는 거죠.</p>
<hr>
<h3>한 번에 쉽게 인증 처리하기</h3>
<p>사실 여기서 중요한 점은, 이런 패턴을 쓰면 페이지 보호 로직이 깔끔해진다는 거예요. 개발자 입장에서 보면, 사용자가 로그인을 하지 않은 상태면 바로 401 페이지로 분기시키고, 그 화면에서 자연스럽게 로그인하도록 유도할 수 있죠.</p>
<ul>
<li>기존의 리다이렉트 방식이나, 클라이언트 사이드에서 상태를 확인하는 것보다 서버에서 바로 인증 상태를 확인하는 게 보안상 더 안전합니다.</li>
<li>물론 세션 검증 함수(<code>verifySession</code>)는 직접 구현해야 해요. 예를 들어 쿠키에 포함된 토큰을 해석하거나, 데이터베이스를 조회해서 유효성을 검사하게 됩니다.</li>
</ul>
<hr>
<h3>이해를 돕는 간단 다이어그램</h3>





























<table><thead><tr><th>동작 단계</th><th>설명</th></tr></thead><tbody><tr><td>1. 세션 확인</td><td><code>verifySession</code> 호출해서 로그인 여부 확인</td></tr><tr><td>2. 미인증 사용자 감지</td><td>세션이 없으면 <code>unauthorized()</code> 호출해서 401 페이지 렌더링</td></tr><tr><td>3. 401 페이지 렌더링</td><td><code>unauthorized.js</code>에 정의된 로그인 화면을 보여줌</td></tr><tr><td>4. 로그인 후 세션 생성</td><td>로그인 컴포넌트에서 정상 로그인이 되면 세션이 생성됨</td></tr><tr><td>5. 접근 허용</td><td>이후 대시보드 페이지 접속 가능</td></tr></tbody></table>
<hr>
<h3>마치며</h3>
<p>Next.js 앱에서 인증이 필요한 페이지를 다룰 때, ‘unauthorized’ 함수를 잘 활용하면 간단하고 체계적인 접근 제어를 구현할 수 있습니다. 보안도 높이고 UX도 좋으니 여러분께서도 꼭 한 번 써보시길 추천드려요.</p>
<p>추가로, 로그인 컴포넌트나 세션 검증 로직에 대해 궁금하신 점 있으면 댓글로 알려주세요. 다음에는 그 부분도 자세히 다뤄보겠습니다!</p>
<p>오늘도 즐거운 개발 되시길! 🚀</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>













<table><thead><tr><th>Version</th><th>Changes</th></tr></thead><tbody><tr><td><code>v15.1.0</code></td><td><code>unauthorized.js</code> 도입됨</td></tr></tbody></table>
<p>이번에 <code>v15.1.0</code> 버전에서 <code>unauthorized.js</code>라는 파일이 새롭게 추가됐어요. 보통 이런 파일 이름은 '허가되지 않은 접근'과 관련된 기능을 처리할 때 쓰이는데요, 예를 들어 로그인이 필요한 페이지에 비로그인 사용자가 접근하려 할 때 보여주는 에러 처리나 리다이렉트 등을 담당할 수도 있답니다.</p>
<p>이렇게 특정 상황에 맞는 자바스크립트 파일을 분리해서 관리하면 코드 유지보수도 편해지고, 필요한 경우에만 로드해서 성능 최적화도 할 수 있어요. 나중에 관련 기능을 더 자세히 살펴볼 기회가 있으면, <code>unauthorized.js</code>가 실제로 어떤 역할을 하는지 한번 분석해보는 것도 재밌겠네요!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Next.js 15에서 Unauthorized.js로 권한 없는 접근 처리하는 방법","description":"","date":"2025-04-22 02:47","slug":"2025-04-22-unauthorizedjs","content":"\n\n# unauthorized.js\n\n`unauthorized.js` 파일은 인증 과정에서 `unauthorized` 함수가 호출될 때 보여줄 UI를 렌더링하는 역할을 해요. 이 파일을 통해 UI를 원하는 대로 꾸밀 수 있을 뿐만 아니라, Next.js가 자동으로 401 상태 코드를 반환해 준답니다.\n\n```js\nimport Login from '@/app/components/Login'\n\nexport default function Unauthorized() {\n  return (\n    \u003cmain\u003e\n      \u003ch1\u003e401 - Unauthorized\u003c/h1\u003e\n      \u003cp\u003ePlease log in to access this page.\u003c/p\u003e\n      \u003cLogin /\u003e\n    \u003c/main\u003e\n  )\n}\n```\n\n위 코드를 보면, 기본적으로 \"401 - Unauthorized\"라는 제목과 함께 로그인을 요청하는 문구가 보이고, `Login` 컴포넌트를 렌더링해 실제 로그인 화면도 함께 표시하고 있어요.\n\n### 조금 더 알아보기\n\n- **401 상태 코드란?**  \n  401은 '인증이 필요함'을 나타내는 HTTP 상태 코드로, 사용자가 인증되지 않은 상태에서 접근 권한이 필요한 페이지에 접근할 때 서버가 보내요.\n\n- **Next.js에서의 활용 팁**  \n  이 파일을 커스터마이징하면 에러 페이지를 여러분의 서비스 스타일에 맞게 꾸밀 수 있답니다. 예를 들어, 로그인 버튼 대신 소셜 로그인이나 회원가입으로 유도하는 링크도 넣어볼 수 있겠죠?\n\n- **추가로 하면 좋은 것**  \n  사용자가 왜 인증이 필요한지 좀 더 자세한 안내나, 인증 절차에 도움이 될 만한 FAQ 링크를 같이 넣으면 UX가 더 좋아질 수 있어요.\n\n필요하면 한 번 직접 만들어보고, 여러분만의 인증 오류 페이지도 멋지게 만들어 보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### Props\n\n`unauthorized.js` 컴포넌트는 어떤 props도 받지 않습니다.\n\n## 예시\n\n### 로그인하지 않은 사용자에게 로그인 UI 보여주기\n\n로그인하지 않은 사용자를 대상으로 로그인 화면을 보여주고 싶을 때, `unauthorized.js` 컴포넌트를 사용할 수 있어요. 참고로 이 컴포넌트는 추가 설정을 위해 props를 받지 않으니, 간단하게 기본 UI를 렌더링하는 용도로 쓴다는 점 기억하세요.\n\n만약 내 서비스에서 로그인 여부에 따라 다른 화면을 보여줘야 한다면, 조건문으로 이 컴포넌트를 넣어주면 됩니다. 예를 들어:\n\n```jsx\n{ !userIsLoggedIn \u0026\u0026 \u003cUnauthorized /\u003e }\n```\n\n이렇게 하면 인증되지 않은 사용자에게만 로그인 페이지가 표시되고, 이미 로그인한 사용자에겐 다른 화면이 보여지겠죠?\n\n추가로, `unauthorized.js` 컴포넌트 내부를 수정해 나만의 로그인 UI로 커스터마이징해도 좋습니다. 그럴 땐 props 대신 내부 상태나 리덕스 등 상태관리 라이브러리를 이용해서 유연하게 UX를 조절해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여러분 안녕하세요! 오늘은 Next.js 앱에서 인증이 필요한 페이지에 대해 'unauthorized' 함수를 이용해 인증되지 않은 사용자에게 로그인 UI를 보여주는 방법을 쉽게 설명해드릴게요.\n\n먼저, `DashboardPage` 컴포넌트를 살펴봅시다. 여기서는 `verifySession()` 함수를 통해 사용자의 세션 정보를 확인하는데요, 이 함수는 비동기 함수라 `await`를 붙여 호출해주고 있어요.\n\n```jsx\nimport { verifySession } from '@/app/lib/dal'\nimport { unauthorized } from 'next/navigation'\n \nexport default async function DashboardPage() {\n  const session = await verifySession()\n \n  if (!session) {\n    unauthorized()\n  }\n \n  return \u003cdiv\u003eDashboard\u003c/div\u003e\n}\n```\n\n- `verifySession()` 함수가 null 또는 undefined를 반환한다면 세션이 없는 것으로 간주하고, `unauthorized()` 함수를 호출해버립니다.\n- 이 `unauthorized()` 함수는 내부적으로 Next.js에 내장된 기능으로, 렌더링을 멈추고 `unauthorized.js` 파일을 호출해서 401 페이지를 보여주게 해줍니다.\n\n그럼 그 `unauthorized.js` 파일에 어떤 컴포넌트가 있냐면,\n\n```jsx\nimport Login from '@/app/components/Login'\n \nexport default function UnauthorizedPage() {\n  return (\n    \u003cmain\u003e\n      \u003ch1\u003e401 - Unauthorized\u003c/h1\u003e\n      \u003cp\u003ePlease log in to access this page.\u003c/p\u003e\n      \u003cLogin /\u003e\n    \u003c/main\u003e\n  )\n}\n```\n\n이렇게 간단하게 로그인 UI를 포함한 페이지를 만들고 있어요. 화면에 “401 - Unauthorized” 메시지와 로그인 폼이 나타나게 되는 거죠.\n\n---\n\n### 한 번에 쉽게 인증 처리하기\n\n사실 여기서 중요한 점은, 이런 패턴을 쓰면 페이지 보호 로직이 깔끔해진다는 거예요. 개발자 입장에서 보면, 사용자가 로그인을 하지 않은 상태면 바로 401 페이지로 분기시키고, 그 화면에서 자연스럽게 로그인하도록 유도할 수 있죠.\n\n- 기존의 리다이렉트 방식이나, 클라이언트 사이드에서 상태를 확인하는 것보다 서버에서 바로 인증 상태를 확인하는 게 보안상 더 안전합니다.\n- 물론 세션 검증 함수(`verifySession`)는 직접 구현해야 해요. 예를 들어 쿠키에 포함된 토큰을 해석하거나, 데이터베이스를 조회해서 유효성을 검사하게 됩니다.\n\n---\n\n### 이해를 돕는 간단 다이어그램\n\n| 동작 단계             | 설명                                    |\n|-------------------|---------------------------------------|\n| 1. 세션 확인          | `verifySession` 호출해서 로그인 여부 확인          |\n| 2. 미인증 사용자 감지     | 세션이 없으면 `unauthorized()` 호출해서 401 페이지 렌더링   |\n| 3. 401 페이지 렌더링      | `unauthorized.js`에 정의된 로그인 화면을 보여줌            |\n| 4. 로그인 후 세션 생성     | 로그인 컴포넌트에서 정상 로그인이 되면 세션이 생성됨         |\n| 5. 접근 허용           | 이후 대시보드 페이지 접속 가능                           |\n\n---\n\n### 마치며\n\nNext.js 앱에서 인증이 필요한 페이지를 다룰 때, ‘unauthorized’ 함수를 잘 활용하면 간단하고 체계적인 접근 제어를 구현할 수 있습니다. 보안도 높이고 UX도 좋으니 여러분께서도 꼭 한 번 써보시길 추천드려요.\n\n추가로, 로그인 컴포넌트나 세션 검증 로직에 대해 궁금하신 점 있으면 댓글로 알려주세요. 다음에는 그 부분도 자세히 다뤄보겠습니다!\n\n오늘도 즐거운 개발 되시길! 🚀\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n| Version   | Changes                 |\n|-----------|-------------------------|\n| `v15.1.0` | `unauthorized.js` 도입됨 |\n\n이번에 `v15.1.0` 버전에서 `unauthorized.js`라는 파일이 새롭게 추가됐어요. 보통 이런 파일 이름은 '허가되지 않은 접근'과 관련된 기능을 처리할 때 쓰이는데요, 예를 들어 로그인이 필요한 페이지에 비로그인 사용자가 접근하려 할 때 보여주는 에러 처리나 리다이렉트 등을 담당할 수도 있답니다.\n\n이렇게 특정 상황에 맞는 자바스크립트 파일을 분리해서 관리하면 코드 유지보수도 편해지고, 필요한 경우에만 로드해서 성능 최적화도 할 수 있어요. 나중에 관련 기능을 더 자세히 살펴볼 기회가 있으면, `unauthorized.js`가 실제로 어떤 역할을 하는지 한번 분석해보는 것도 재밌겠네요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":5},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch1\u003eunauthorized.js\u003c/h1\u003e\n\u003cp\u003e\u003ccode\u003eunauthorized.js\u003c/code\u003e 파일은 인증 과정에서 \u003ccode\u003eunauthorized\u003c/code\u003e 함수가 호출될 때 보여줄 UI를 렌더링하는 역할을 해요. 이 파일을 통해 UI를 원하는 대로 꾸밀 수 있을 뿐만 아니라, Next.js가 자동으로 401 상태 코드를 반환해 준답니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eLogin\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@/app/components/Login'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eUnauthorized\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003emain\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e401 - Unauthorized\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003ePlease log in to access this page.\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eLogin\u003c/span\u003e /\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003emain\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드를 보면, 기본적으로 \"401 - Unauthorized\"라는 제목과 함께 로그인을 요청하는 문구가 보이고, \u003ccode\u003eLogin\u003c/code\u003e 컴포넌트를 렌더링해 실제 로그인 화면도 함께 표시하고 있어요.\u003c/p\u003e\n\u003ch3\u003e조금 더 알아보기\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e401 상태 코드란?\u003c/strong\u003e\u003cbr\u003e\n401은 '인증이 필요함'을 나타내는 HTTP 상태 코드로, 사용자가 인증되지 않은 상태에서 접근 권한이 필요한 페이지에 접근할 때 서버가 보내요.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eNext.js에서의 활용 팁\u003c/strong\u003e\u003cbr\u003e\n이 파일을 커스터마이징하면 에러 페이지를 여러분의 서비스 스타일에 맞게 꾸밀 수 있답니다. 예를 들어, 로그인 버튼 대신 소셜 로그인이나 회원가입으로 유도하는 링크도 넣어볼 수 있겠죠?\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e추가로 하면 좋은 것\u003c/strong\u003e\u003cbr\u003e\n사용자가 왜 인증이 필요한지 좀 더 자세한 안내나, 인증 절차에 도움이 될 만한 FAQ 링크를 같이 넣으면 UX가 더 좋아질 수 있어요.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e필요하면 한 번 직접 만들어보고, 여러분만의 인증 오류 페이지도 멋지게 만들어 보세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch3\u003eProps\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eunauthorized.js\u003c/code\u003e 컴포넌트는 어떤 props도 받지 않습니다.\u003c/p\u003e\n\u003ch2\u003e예시\u003c/h2\u003e\n\u003ch3\u003e로그인하지 않은 사용자에게 로그인 UI 보여주기\u003c/h3\u003e\n\u003cp\u003e로그인하지 않은 사용자를 대상으로 로그인 화면을 보여주고 싶을 때, \u003ccode\u003eunauthorized.js\u003c/code\u003e 컴포넌트를 사용할 수 있어요. 참고로 이 컴포넌트는 추가 설정을 위해 props를 받지 않으니, 간단하게 기본 UI를 렌더링하는 용도로 쓴다는 점 기억하세요.\u003c/p\u003e\n\u003cp\u003e만약 내 서비스에서 로그인 여부에 따라 다른 화면을 보여줘야 한다면, 조건문으로 이 컴포넌트를 넣어주면 됩니다. 예를 들어:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e{ !userIsLoggedIn \u0026#x26;\u0026#x26; \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eUnauthorized\u003c/span\u003e /\u003e\u003c/span\u003e\u003c/span\u003e }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 하면 인증되지 않은 사용자에게만 로그인 페이지가 표시되고, 이미 로그인한 사용자에겐 다른 화면이 보여지겠죠?\u003c/p\u003e\n\u003cp\u003e추가로, \u003ccode\u003eunauthorized.js\u003c/code\u003e 컴포넌트 내부를 수정해 나만의 로그인 UI로 커스터마이징해도 좋습니다. 그럴 땐 props 대신 내부 상태나 리덕스 등 상태관리 라이브러리를 이용해서 유연하게 UX를 조절해보세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e여러분 안녕하세요! 오늘은 Next.js 앱에서 인증이 필요한 페이지에 대해 'unauthorized' 함수를 이용해 인증되지 않은 사용자에게 로그인 UI를 보여주는 방법을 쉽게 설명해드릴게요.\u003c/p\u003e\n\u003cp\u003e먼저, \u003ccode\u003eDashboardPage\u003c/code\u003e 컴포넌트를 살펴봅시다. 여기서는 \u003ccode\u003everifySession()\u003c/code\u003e 함수를 통해 사용자의 세션 정보를 확인하는데요, 이 함수는 비동기 함수라 \u003ccode\u003eawait\u003c/code\u003e를 붙여 호출해주고 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { verifySession } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@/app/lib/dal'\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { unauthorized } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/navigation'\u003c/span\u003e\n \n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eDashboardPage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e session = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003everifySession\u003c/span\u003e()\n \n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!session) {\n    \u003cspan class=\"hljs-title function_\"\u003eunauthorized\u003c/span\u003e()\n  }\n \n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003eDashboard\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003everifySession()\u003c/code\u003e 함수가 null 또는 undefined를 반환한다면 세션이 없는 것으로 간주하고, \u003ccode\u003eunauthorized()\u003c/code\u003e 함수를 호출해버립니다.\u003c/li\u003e\n\u003cli\u003e이 \u003ccode\u003eunauthorized()\u003c/code\u003e 함수는 내부적으로 Next.js에 내장된 기능으로, 렌더링을 멈추고 \u003ccode\u003eunauthorized.js\u003c/code\u003e 파일을 호출해서 401 페이지를 보여주게 해줍니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e그럼 그 \u003ccode\u003eunauthorized.js\u003c/code\u003e 파일에 어떤 컴포넌트가 있냐면,\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eLogin\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@/app/components/Login'\u003c/span\u003e\n \n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eUnauthorizedPage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003emain\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e401 - Unauthorized\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003ePlease log in to access this page.\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eLogin\u003c/span\u003e /\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003emain\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 간단하게 로그인 UI를 포함한 페이지를 만들고 있어요. 화면에 “401 - Unauthorized” 메시지와 로그인 폼이 나타나게 되는 거죠.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e한 번에 쉽게 인증 처리하기\u003c/h3\u003e\n\u003cp\u003e사실 여기서 중요한 점은, 이런 패턴을 쓰면 페이지 보호 로직이 깔끔해진다는 거예요. 개발자 입장에서 보면, 사용자가 로그인을 하지 않은 상태면 바로 401 페이지로 분기시키고, 그 화면에서 자연스럽게 로그인하도록 유도할 수 있죠.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e기존의 리다이렉트 방식이나, 클라이언트 사이드에서 상태를 확인하는 것보다 서버에서 바로 인증 상태를 확인하는 게 보안상 더 안전합니다.\u003c/li\u003e\n\u003cli\u003e물론 세션 검증 함수(\u003ccode\u003everifySession\u003c/code\u003e)는 직접 구현해야 해요. 예를 들어 쿠키에 포함된 토큰을 해석하거나, 데이터베이스를 조회해서 유효성을 검사하게 됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3\u003e이해를 돕는 간단 다이어그램\u003c/h3\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e동작 단계\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e1. 세션 확인\u003c/td\u003e\u003ctd\u003e\u003ccode\u003everifySession\u003c/code\u003e 호출해서 로그인 여부 확인\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e2. 미인증 사용자 감지\u003c/td\u003e\u003ctd\u003e세션이 없으면 \u003ccode\u003eunauthorized()\u003c/code\u003e 호출해서 401 페이지 렌더링\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e3. 401 페이지 렌더링\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eunauthorized.js\u003c/code\u003e에 정의된 로그인 화면을 보여줌\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e4. 로그인 후 세션 생성\u003c/td\u003e\u003ctd\u003e로그인 컴포넌트에서 정상 로그인이 되면 세션이 생성됨\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e5. 접근 허용\u003c/td\u003e\u003ctd\u003e이후 대시보드 페이지 접속 가능\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003chr\u003e\n\u003ch3\u003e마치며\u003c/h3\u003e\n\u003cp\u003eNext.js 앱에서 인증이 필요한 페이지를 다룰 때, ‘unauthorized’ 함수를 잘 활용하면 간단하고 체계적인 접근 제어를 구현할 수 있습니다. 보안도 높이고 UX도 좋으니 여러분께서도 꼭 한 번 써보시길 추천드려요.\u003c/p\u003e\n\u003cp\u003e추가로, 로그인 컴포넌트나 세션 검증 로직에 대해 궁금하신 점 있으면 댓글로 알려주세요. 다음에는 그 부분도 자세히 다뤄보겠습니다!\u003c/p\u003e\n\u003cp\u003e오늘도 즐거운 개발 되시길! 🚀\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003eVersion\u003c/th\u003e\u003cth\u003eChanges\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ev15.1.0\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eunauthorized.js\u003c/code\u003e 도입됨\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e이번에 \u003ccode\u003ev15.1.0\u003c/code\u003e 버전에서 \u003ccode\u003eunauthorized.js\u003c/code\u003e라는 파일이 새롭게 추가됐어요. 보통 이런 파일 이름은 '허가되지 않은 접근'과 관련된 기능을 처리할 때 쓰이는데요, 예를 들어 로그인이 필요한 페이지에 비로그인 사용자가 접근하려 할 때 보여주는 에러 처리나 리다이렉트 등을 담당할 수도 있답니다.\u003c/p\u003e\n\u003cp\u003e이렇게 특정 상황에 맞는 자바스크립트 파일을 분리해서 관리하면 코드 유지보수도 편해지고, 필요한 경우에만 로드해서 성능 최적화도 할 수 있어요. 나중에 관련 기능을 더 자세히 살펴볼 기회가 있으면, \u003ccode\u003eunauthorized.js\u003c/code\u003e가 실제로 어떤 역할을 하는지 한번 분석해보는 것도 재밌겠네요!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2025-04-22-unauthorizedjs"},"buildId":"KUC9M_yIlA1Ugo01xmkHL","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>