<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Vite에서 Next.js 15로 마이그레이션 하는 방법 | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-HowtomigratefromVitetoNextjs" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Vite에서 Next.js 15로 마이그레이션 하는 방법 | TIL" data-gatsby-head="true"/><meta property="og:title" content="Vite에서 Next.js 15로 마이그레이션 하는 방법 | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-HowtomigratefromVitetoNextjs" data-gatsby-head="true"/><meta name="twitter:title" content="Vite에서 Next.js 15로 마이그레이션 하는 방법 | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2025-04-22 01:30" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/0eef537492fed77a.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/0eef537492fed77a.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/post/%5Bslug%5D-8ded8b979ba73586.js" defer=""></script><script src="/TIL/_next/static/olPs1cVezSGTqD7OaewDI/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/olPs1cVezSGTqD7OaewDI/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Vite에서 Next.js 15로 마이그레이션 하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Vite에서 Next.js 15로 마이그레이션 하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Apr 22, 2025</span><span class="posts_reading_time__f7YPP">39<!-- --> min read</span></span></div></div></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h1>Vite에서 Next.js로 마이그레이션하는 방법</h1>
<p>안녕하세요! 오늘은 Vite로 만들어진 기존 프로젝트를 Next.js로 옮기는 방법에 대해 이야기해볼게요. 요새 React 생태계에서 Next.js가 워낙 대세라서요, 프로젝트 확장성이나 SEO 같은 부분 때문에 넘어가는 분들이 많더라고요.</p>
<h2>왜 굳이 Next.js로 갈아타야 할까?</h2>
<p>사실 Vite도 빠르고 사용하기 편한 툴인데, Next.js로 갈아타는 몇 가지 이유가 있거든요.</p>

























<table><thead><tr><th>이유</th><th>설명</th></tr></thead><tbody><tr><td><strong>서버 사이드 렌더링(SSR)</strong></td><td>Next.js는 기본적으로 SSR을 지원해서 SEO에 훨씬 유리해요. Vite는 클라이언트 렌더링에 초점이 맞춰져 있죠.</td></tr><tr><td><strong>파일 기반 라우팅</strong></td><td>Next.js는 폴더 구조만 잘 맞추면 라우팅 설정이 자동으로 되어 개발 속도가 빨라져요. Vite는 라우터 설정을 직접 해줘야 하죠.</td></tr><tr><td><strong>API 라우트 지원</strong></td><td>Next.js 내에서 API 엔드포인트를 쉽게 만들 수 있어 백엔드 &#x26; 프론트엔드 통합이 편리해요. Vite는 보통 별도의 서버를 띄워야 해요.</td></tr><tr><td><strong>강력한 커뮤니티와 플러그인</strong></td><td>Next.js는 많은 플러그인과 라이브러리가 있어서 생태계가 풍부하고, 지원도 활발해요.</td></tr></tbody></table>
<p>사실 프로젝트 규모가 커지고, SEO가 중요해지고, 좀 더 안정적인 서버 사이드 렌더링이 필요하다면 Next.js는 거의 필수 선택지라고 할 수 있겠네요!</p>
<p>다음 포스팅에서는 실제로 Vite 프로젝트를 어떻게 Next.js 프로젝트로 옮길지, 단계별로 자세히 알려드릴게요. 기대해주세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h3>느린 초기 페이지 로딩 시간</h3>
<p>만약 기본 Vite 플러그인으로 리액트 애플리케이션을 만들었다면, 여러분의 앱은 순수한 클라이언트 사이드 애플리케이션입니다. 이렇게 클라이언트 사이드에서만 앱을 실행하는 방식, 즉 흔히 싱글 페이지 애플리케이션(SPA)이라고 하죠. 이 방식은 보통 초기 페이지 로딩 속도가 느려지는 문제가 발생합니다. 왜 그런지 간단히 살펴볼게요.</p>
<ul>
<li>브라우저가 여러분의 리액트 코드와 전체 애플리케이션 번들을 내려받고 실행하기 전까지는 데이터 요청조차 시작할 수 없습니다.</li>
<li>시간이 지나면서 기능이 추가되고 의존성도 늘어나면서 애플리케이션 코드가 점점 커져서 더 오래 걸리게 됩니다.</li>
</ul>
<p>즉, 초기 로딩에 필요한 코드가 한 번에 너무 많아서 브라우저가 버거워하는 상황인 거죠.</p>
<h3>자동 코드 분할이 없다면?</h3>
<p>자동 코드 분할이란 쉽게 말해, 필요한 코드만 쪼개서 나중에 불러오는 걸 의미해요. 하지만 기본 설정으로 만든 Vite + React 프로젝트엔 이 기능이 적용되어 있지 않습니다. 그래서 앱 전체 코드를 한 번에 내려받아야 하죠.</p>
<p>자동 코드 분할이 없으면 다음과 같은 단점이 있어요.</p>





















<table><thead><tr><th>문제점</th><th>설명</th></tr></thead><tbody><tr><td>초기 로딩 느림</td><td>모든 코드가 한 번에 내려오니까 페이지가 뜨기까지 기다려야 하는 시간이 길어짐</td></tr><tr><td>불필요한 코드 다운로드</td><td>현재 페이지에서 필요하지 않은 코드도 같이 받게 되어 네트워크 자원이 낭비됨</td></tr><tr><td>사용자 경험 저하</td><td>로딩 시간이 길어지면 방문자가 페이지 이탈할 확률이 높아짐</td></tr></tbody></table>
<p>자동 코드 분할을 도입하면 첫 페이지 로딩은 가볍게, 이후 필요한 기능은 필요한 순간에 불러올 수 있어 앱 속도가 체감상 빨라집니다.</p>
<hr>
<h3>추가 팁: 해결책으로 SSG/SSR 도입하기</h3>
<p>초기 로딩 속도를 확실히 개선하고 싶다면, 서버 사이드 렌더링(SSR)이나 정적 사이트 생성(SSG)을 도입하는 것도 좋은 방법입니다. Next.js 같은 프레임워크는 기본적으로 이 기능들을 지원해요. 요청 시 서버에서 미리 렌더링된 HTML을 보내면 브라우저가 JS 실행을 기다리지 않아도 빠르게 페이지를 보여줄 수 있죠.</p>
<p>단, SSR/SSG는 설정이 좀 더 복잡할 수 있으니 상황과 요구에 맞게 도입하면 됩니다.</p>
<hr>
<p>이처럼 리액트 앱 개발할 때 초기 로딩 속도 문제는 SPA의 흔한 고민이고, 자동 코드 분할 또는 SSR/SSG 같은 기술을 적절히 적용하면 훨씬 개선할 수 있어요. 앞으로 프로젝트에 적용해 보면서 체감 성능을 경험해보시길 바랍니다!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이전 글에서 언급한 느린 로딩 문제는 코드 스플리팅(code splitting)으로 어느 정도 해결할 수 있어요. 그런데 직접 수동으로 코드 스플리팅을 하려고 하면 오히려 성능이 더 안 좋아질 수도 있어요. 수동으로 코드를 나누다 보면 네트워크 워터폴(Network waterfalls, 요청이 순차적으로 쌓여서 느려지는 현상)이 쉽게 발생할 수 있거든요. 다행히 Next.js는 자체 라우터에 자동 코드 스플리팅 기능이 내장되어 있어서 이런 문제를 훨씬 간편하게 해결할 수 있어요.</p>
<h3>네트워크 워터폴(Network waterfalls)이란?</h3>
<p>네트워크 워터폴은 애플리케이션이 클라이언트와 서버 사이에서 순차적으로 여러 데이터를 요청할 때 발생하는 성능 저하 현상이에요. SPA(싱글 페이지 애플리케이션)에서 데이터를 받아올 때 주로, 처음에는 로딩용 자리 표시자(placeholder)를 렌더링하고, 컴포넌트가 마운트된 후에야 데이터를 받아오는 패턴이 많죠. 이 경우 하위 컴포넌트가 데이터를 요청하려면, 반드시 상위 컴포넌트가 자신의 데이터를 모두 받은 뒤여야 해서 대기시간이 길어질 수밖에 없습니다.</p>
<p>Next.js는 클라이언트에서 데이터를 받아오는 것도 지원하지만, 데이터 페칭을 서버 사이드에서 처리하게끔 선택할 수도 있어요. 서버에서 데이터를 미리 받아서 렌더링하면 이런 클라이언트-서버 워터폴 현상을 완전히 없앨 수 있답니다.</p>
<hr>
<p>마치면서 한 가지 팁!<br>
서버 사이드 렌더링(SSR)이나 SSG(정적 사이트 생성)를 활용하면, 페이지 렌더링 전에 데이터를 미리 받아오기 때문에 사용자 입장에서 훨씬 빠른 초기 로딩을 경험할 수 있어요. Next.js의 <code>getServerSideProps</code>나 <code>getStaticProps</code> 같은 함수들이 그 역할을 하니, 꼭 활용해보세요!</p>
<hr>

























<table><thead><tr><th>개념</th><th>설명</th></tr></thead><tbody><tr><td>코드 스플리팅</td><td>자바스크립트 코드를 여러 덩어리로 나누어 필요한 부분만 불러와 초기 로딩 속도를 개선하는 방법</td></tr><tr><td>네트워크 워터폴</td><td>클라이언트와 서버가 요청을 연속적으로 주고받아서 응답시간이 길어지는 현상</td></tr><tr><td>Next.js 자동 코드 스플리팅</td><td>Next.js의 라우터가 페이지별로 자동으로 코드 스플리팅을 해주어 성능 최적화를 돕는 기능</td></tr><tr><td>서버 사이드 데이터 페칭</td><td>Next.js가 페이지 렌더링 전에 서버에서 데이터를 미리 받아와 클라이언트-서버 간 요청 지연 문제를 해결하는 방식</td></tr></tbody></table>
<p>필요하면 다음 글에서 Next.js의 데이터 페칭 방법과 활용법도 자세히 알려드릴게요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h3>빠르고 의도적인 로딩 상태 관리</h3>
<p>React Suspense가 스트리밍을 기본적으로 지원하면서, 어떤 UI 부분을 먼저 로딩할지, 또 어떤 순서로 로딩할지 더 세심하게 설계할 수 있게 되었습니다. 덕분에 네트워크 워터폴(waterfall) 현상을 피할 수 있죠.</p>
<p>네트워크 워터폴이란, 한 요청이 끝나야 다음 요청이 시작되는 상황을 말하는데, 이게 계속 쌓이면 로딩 속도가 느려져 사용자 경험이 떨어집니다. Suspense를 사용하면 여러 컴포넌트를 병렬로 로딩하면서도 사용자에게 매끄럽게 보여줄 수 있어서, 페이지 로딩 속도도 빨라지고 레이아웃이 불안정하게 변하는 문제(layout shift)도 줄일 수 있습니다.</p>
<h3>데이터 패칭(가져오기) 전략 선택하기</h3>
<p>내가 배운 바로는, 데이터 패칭 전략을 잘 선택하는 게 매우 중요해요. 예를 들어, 모든 데이터를 한 번에 가져오느냐, 필요한 데이터만 나눠서 가져오느냐에 따라 성능과 사용자 경험이 확 달라집니다.</p>
<p>아래 표는 다양한 데이터 패칭 전략과 그 특징을 간단히 정리한 거예요.</p>



































<table><thead><tr><th>전략</th><th>설명</th><th>장점</th><th>단점</th></tr></thead><tbody><tr><td>전체 데이터 한 번에 로드</td><td>페이지 로드 시 모든 데이터를 한꺼번에 요청</td><td>초기 로딩 후 빠른 탐색 가능</td><td>초기 로딩 시간 길어짐</td></tr><tr><td>필요한 데이터만 나눠서 로드</td><td>필요한 부분만 요청, 점진적 로딩 지원</td><td>빠른 초기 로딩, 네트워크 부하 분산</td><td>구현 복잡도 증가</td></tr><tr><td>캐싱 활용</td><td>요청한 데이터를 캐싱하여 재사용</td><td>불필요한 중복 요청 방지</td><td>데이터 최신성 관리 필요</td></tr><tr><td>스트리밍</td><td>React Suspense와 함께 스트리밍 데이터 로딩 활용</td><td>사용자에게 빠르게 부분 렌더링 가능</td><td>서버 및 클라이언트 세팅 복잡</td></tr></tbody></table>
<p>특히 React Suspense와 같은 최신 기능들을 활용하면, 스트리밍 방식으로 데이터를 점진적으로 받아오면서 사용자에게 빠른 피드백을 줄 수 있어요. 개발자로서 이런 점들을 염두에 두면, 퍼포먼스 좋은 앱을 만드는 데 큰 도움이 됩니다.</p>
<hr>
<p>궁금한 점 있으면 언제든 댓글로 남겨주세요! 앞으로도 이런 실용적인 개발 팁들을 계속 공유할게요 :)</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Next.js는 상황에 맞게 페이지나 컴포넌트 단위로 데이터 가져오기 전략을 선택할 수 있도록 유연성을 제공합니다. 예를 들어, 빌드 시점에 데이터를 가져와서 CMS에 있는 블로그 포스트를 렌더링하고, 이를 CDN에 캐시해서 빠르게 서비스할 수 있어요. 또는 서버 요청 시점이나 클라이언트에서 데이터를 받아서 동적으로 처리할 수도 있죠. 이렇게 상황에 따라 가장 적합한 방식을 선택할 수 있다는 게 Next.js의 큰 장점 중 하나랍니다.</p>
<h3>미들웨어 (Middleware)</h3>
<p>Next.js의 미들웨어는 서버에서 요청이 완료되기 전에 코드를 실행할 수 있도록 해줍니다. 예를 들어, 로그인해야 볼 수 있는 페이지에 사용자가 접근했을 때, 잠깐 인증이 안 된 페이지가 보이는 ‘깜빡임(flash)’ 현상을 막고 바로 로그인 페이지로 리다이렉트할 수 있어요. 이 외에도 새로운 기능을 실험해보거나, 다국어 지원 같은 국제화 작업에 아주 유용하죠. 미들웨어가 있다 보니 이런 작업들이 좀 더 자연스럽고 효율적으로 처리됩니다.</p>
<h3>내장 최적화 기능</h3>
<p>Next.js는 개발자가 따로 신경 쓰지 않아도 자동으로 여러 최적화를 수행합니다. 예를 들어, 이미지 최적화, 번들 크기 최소화, 코드 스플리팅, 그리고 사전 렌더링 같은 기능들이 모두 내장되어 있어요. 특히 이미지 최적화는 웹 페이지 로딩 속도를 크게 높여주니, 사용자 경험 개선에 큰 효과가 있답니다. 덕분에 복잡한 설정 없이도 빠르고 효율적인 웹사이트를 만들 수 있어요.</p>
<hr>
<p>Next.js를 처음 접하는 분들은 이런 데이터 페칭과 미들웨어, 그리고 최적화 기능들이 어떻게 연결되는지 이해하는 게 중요해요. 다양한 상황에 맞게 전략을 골라 사용하면 사이트 성능을 최대로 끌어올릴 수 있으니까요! 만약 이 부분들이 더 궁금하다면 다음 포스트에서 각 전략별 예제와 함께 자세히 설명해볼게요 :)</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이미지, 폰트, 그리고 서드파티 스크립트는 애플리케이션 성능에 꽤 큰 영향을 줘요. 다행히 Next.js에는 이런 요소들을 자동으로 최적화해주는 내장 컴포넌트들이 있어서 성능 관리를 훨씬 쉽게 해줍니다.</p>
<hr>
<h2>마이그레이션 단계</h2>
<p>이번 마이그레이션 목표는 최대한 빠르게 Next.js 기반의 작동하는 애플리케이션을 만드는 거예요. 그 후에 필요에 따라 Next.js의 여러 기능을 차근차근 적용해 나가면 돼요. 처음에는 기존 라우터를 그대로 두고, 순수 클라이언트 사이드 애플리케이션(SPA)으로만 유지하는 방식으로 진행할 거예요. 이렇게 하면 마이그레이션 중에 발생할 수 있는 문제나 병합 충돌을 최소화할 수 있습니다.</p>
<hr>
<h3>1단계: Next.js 의존성 설치하기</h3>
<p>마이그레이션의 첫걸음은 Next.js 패키지를 프로젝트에 추가하는 것부터 시작합니다. 이 부분은 기본 중의 기본이니까 꼼꼼하게 설치해 주세요! 다음 명령어를 터미널에 입력하면 됩니다:</p>
<pre><code class="hljs language-bash">npm install next react react-dom
</code></pre>
<p>또는 yarn을 사용한다면,</p>
<pre><code class="hljs language-bash">yarn add next react react-dom
</code></pre>
<p>이렇게 하면 Next.js가 필요로 하는 핵심 라이브러리들이 프로젝트에 추가됩니다.</p>
<blockquote>
<p>참고로, Next.js는 React 기반 프레임워크라 React와 ReactDOM도 함께 설치해야 해요. 이미 설치되어 있다면 중복 설치가 되지 않으니 걱정하지 않아도 됩니다!</p>
</blockquote>
<p>설치가 완료됐으면, 다음 단계로 넘어가서 실제로 Next.js 프로젝트 구조에 맞게 파일들을 조금씩 정리해보도록 할게요.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>먼저, Next.js를 사용하기 위해서는 프로젝트에 Next를 의존성으로 설치해야 해요:</p>
<pre><code class="hljs language-bash">npm install next@latest
</code></pre>
<h3>2단계: Next.js 설정 파일 만들기</h3>
<p>프로젝트 루트에 <code>next.config.mjs</code> 파일을 만들어주세요. 이 파일은 Next.js의 다양한 설정 옵션들을 담고 있어요.</p>
<blockquote>
<p>참고로 이 설정 파일은 JavaScript나 TypeScript 파일처럼 동작하지만, <code>.mjs</code> 확장자를 사용하면 ES 모듈 방식을 명확히 하게 돼서 최근 Next.js 프로젝트에서 권장되고 있답니다.</p>
</blockquote>
<p>필요한 설정들을 여기서 자유롭게 추가해서 프로젝트 요구사항에 맞게 조절해보세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>자, 이번에는 Next.js 설정 파일을 조금 바꿔볼게요! 위 예제 코드는 <code>next.config.js</code> 파일에 들어갈 내용인데요.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">/** <span class="hljs-doctag">@type</span> {<span class="hljs-type">import('next').NextConfig</span>} */</span>
<span class="hljs-keyword">const</span> nextConfig = {
  <span class="hljs-attr">output</span>: <span class="hljs-string">'export'</span>,    <span class="hljs-comment">// 이 설정은 Next.js를 SPA(단일 페이지 애플리케이션)로 내보내도록 해줘요.</span>
  <span class="hljs-attr">distDir</span>: <span class="hljs-string">'./dist'</span>,   <span class="hljs-comment">// 빌드 결과물을 기본 폴더가 아닌 './dist' 폴더에 저장해요.</span>
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> nextConfig
</code></pre>
<blockquote>
<p>참고로, Next.js 설정 파일은 <code>.js</code> 뿐만 아니라 <code>.mjs</code> 확장자를 써도 무방해요. 그래서 프로젝트 스타일에 맞게 골라 쓰시면 됩니다.</p>
</blockquote>
<p>그리고 이제 TypeScript를 쓰는 분들은 tsconfig.json 파일을 수정해줘야 해요! Next.js와 호환되게끔 일부 설정을 바꿔줘야 하거든요. 만약 TypeScript를 쓸 필요가 없다면 이 부분은 건너뛰셔도 되니까 부담 갖지 마세요.</p>
<hr>
<h3>TypeScript 사용자라면 tsconfig.json 수정하는 팁!</h3>
<p>Next.js는 TypeScript를 공식 지원하지만, 기본 설정이 Next.js 빌드 시스템에 맞게끔 커스텀 필요가 있어요. 보통은 다음과 같이 <code>compilerOptions</code>와 같이 설정합니다:</p>

































<table><thead><tr><th>옵션</th><th>설명</th></tr></thead><tbody><tr><td><code>jsx</code></td><td>React JSX 변환 설정 (예: <code>"react-jsx"</code>)</td></tr><tr><td><code>module</code></td><td>모듈 시스템 (주로 <code>"esnext"</code> 사용)</td></tr><tr><td><code>target</code></td><td>컴파일 타겟팅 자바스크립트 버전</td></tr><tr><td><code>strict</code></td><td>엄격한 타입 체크 설정</td></tr><tr><td><code>baseUrl</code></td><td>절대 경로 기준 디렉토리</td></tr><tr><td><code>paths</code></td><td>모듈 경로 별칭 설정</td></tr></tbody></table>
<p>예를 들어, tsconfig.json에 다음처럼 넣으면 더 편리하답니다:</p>
<pre><code class="hljs language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"compilerOptions"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"target"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"es5"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"lib"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"dom"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"dom.iterable"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"esnext"</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"allowJs"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"skipLibCheck"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"strict"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"forceConsistentCasingInFileNames"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"noEmit"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"esModuleInterop"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"module"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"esnext"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"moduleResolution"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"node"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"resolveJsonModule"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"isolatedModules"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"jsx"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"react-jsx"</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"include"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"next-env.d.ts"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"**/*.ts"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"**/*.tsx"</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"exclude"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"node_modules"</span><span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>이렇게 하면 Next.js에서 TypeScript를 더 원활하게 사용할 수 있답니다. 더 궁금하면 언제든 물어봐 주세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>TypeScript 설정을 하면서 다음과 같은 변경사항을 적용해봤어요.</p>
<ul>
<li><code>tsconfig.node.json</code> 프로젝트 참조 제거</li>
<li><code>include</code> 배열에 <code>./dist/types/**/*.ts</code> 와 <code>./next-env.d.ts</code> 추가</li>
<li><code>exclude</code> 배열에 <code>./node_modules</code> 추가</li>
<li><code>compilerOptions</code>의 <code>plugins</code> 배열에 <code>"name": "next"</code> 추가</li>
<li><code>esModuleInterop</code>을 <code>true</code>로 설정</li>
<li><code>jsx</code>를 <code>"preserve"</code>로 설정</li>
<li><code>allowJs</code>를 <code>true</code>로 설정</li>
<li><code>forceConsistentCasingInFileNames</code>를 <code>true</code>로 설정</li>
<li><code>incremental</code>을 <code>true</code>로 설정</li>
</ul>
<p>아래는 이렇게 수정된 <code>tsconfig.json</code> 예시입니다:</p>
<pre><code class="hljs language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"compilerOptions"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"target"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"ES2020"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"useDefineForClassFields"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"lib"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"ES2020"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"DOM"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"DOM.Iterable"</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"module"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"ESNext"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"esModuleInterop"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"skipLibCheck"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"moduleResolution"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"bundler"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"allowImportingTsExtensions"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"resolveJsonModule"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"isolatedModules"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"noEmit"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"jsx"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"preserve"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"strict"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"noUnusedLocals"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"noUnusedParameters"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"noFallthroughCasesInSwitch"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"allowJs"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"forceConsistentCasingInFileNames"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"incremental"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"plugins"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">{</span> <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"next"</span> <span class="hljs-punctuation">}</span><span class="hljs-punctuation">]</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"include"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"./src"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"./dist/types/**/*.ts"</span><span class="hljs-punctuation">,</span> <span class="hljs-string">"./next-env.d.ts"</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"exclude"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"./node_modules"</span><span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<hr>
<p>조금 더 풀어 이야기하자면,</p>
<ul>
<li><code>esModuleInterop: true</code>는 CommonJS 모듈과 ES 모듈 간의 호환성을 좋게 해줍니다. 그래서 <code>import</code> 구문을 쓸 때 오류를 줄여줘요.</li>
<li><code>jsx: "preserve"</code>는 JSX를 컴파일하지 않고 그대로 두라는 뜻인데, Next.js가 자체적으로 처리하기 때문에 이렇게 해주는게 일반적이에요.</li>
<li><code>allowJs: true</code>를 켜면 자바스크립트 파일도 TS 빌드 대상에 포함할 수 있어서, 점진적으로 타입스크립트로 이전하려는 프로젝트에서 유용합니다.</li>
<li><code>forceConsistentCasingInFileNames: true</code> 설정은 대소문자 차이로 생기는 파일 경로 문제를 예방해줍니다. 특히 OS마다 대소문자 구분이 다른 경우에 꼭 필요해요.</li>
<li><code>incremental: true</code>는 빌드 속도를 향상시키기 위해 이전 빌드 정보를 캐싱해주는 기능입니다. 개발할 때 시간 절약에 큰 도움이 돼요.</li>
<li>플러그인에 <code>"name": "next"</code>를 넣으면 Next.js에서 권장하는 타입스크립트 플러그인을 사용하게 됩니니다.</li>
</ul>
<p>Next.js 공식 문서에도 TypeScript 구성에 대한 좋은 안내가 있으니, 필요하면 꼭 참고해보세요.<br>
<a href="https://nextjs.org/docs/basic-features/typescript" rel="nofollow" target="_blank">https://nextjs.org/docs/basic-features/typescript</a></p>
<p>이 설정을 기반으로 프로젝트를 구성하면 Next.js + TypeScript 환경에서 좀 더 편리하고 안정적으로 개발하실 수 있습니다!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h3>4단계: 루트 레이아웃 만들기</h3>
<p>Next.js의 App Router를 사용할 때는 루트 레이아웃(root layout) 파일이 꼭 필요해요. 이 파일은 React Server Component로, 여러분의 앱 안에 있는 모든 페이지를 감싸는 역할을 하죠. 그리고 이 파일은 <code>app</code> 디렉토리의 최상단에 위치해야 합니다.</p>
<p>비슷한 개념을 Vite 앱에서 찾자면, 바로 <code>index.html</code> 파일이에요. 이 파일이 여러분의 HTML, head, body 태그를 포함하고 있어서, Next.js에서 말하는 루트 레이아웃과 가장 비슷한 역할을 하죠.</p>
<p>이번 단계에서는 여러분의 <code>index.html</code> 파일을 Next.js의 루트 레이아웃 파일로 변환해볼 거예요.</p>
<hr>
<p>여기서 꼭 짚고 넘어갈 점은 Next.js에서는 이 루트 레이아웃이 React 컴포넌트라는 거예요. 단순히 HTML 파일이 아니라 리액트 컴포넌트로 작성되니, 필요한 경우 React의 훅이나 다른 컴포넌트로 기능 확장이 훨씬 쉬워요. 즉, 더 동적이고 유연한 레이아웃 구성이 가능하다는 거죠.</p>
<p>그럼 이제 <code>index.html</code>에서 어떤 부분을 어떻게 바꿔주면 될지 살펴볼게요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이번에는 Next.js 프로젝트에서 새로운 앱 디렉토리를 만들고, 레이아웃 설정을 하는 방법을 알려드릴게요. 특히 Next.js 13 버전에서 도입된 '새로운 app 디렉토리 구조'를 활용하는 예제인데요, 코드 설명도 곁들여서 천천히 같이 보시죠!</p>
<hr>
<h3>1. <code>src</code> 안에 <code>app</code> 디렉토리 만들기</h3>
<p>먼저, 프로젝트 폴더 안 <code>src</code> 디렉토리 안에 <code>app</code> 폴더를 새로 만들어줘요. 여기서부터 우리 앱의 페이지, 레이아웃 등이 관리될 거예요.</p>
<p>src/
└── app/</p>
<hr>
<h3>2. <code>RootLayout</code> 컴포넌트 만들기 (<code>layout.tsx</code>)</h3>
<p><code>app</code> 폴더 안에 <code>layout.tsx</code> 파일을 하나 새로 만들어요. 이 파일은 페이지들의 공통 레이아웃을 담당합니다.</p>
<pre><code class="hljs language-tsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">RootLayout</span>(<span class="hljs-params">{
  children,
}: {
  children: React.ReactNode
}</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-string">'...'</span>
}
</code></pre>
<ul>
<li><code>children</code>은 이 레이아웃 안에 렌더링될 페이지나 하위 컴포넌트들을 의미해요.</li>
<li>중요! <code>layout.tsx</code> 같은 레이아웃 파일 확장자는 <code>.js</code>, <code>.jsx</code>, <code>.tsx</code> 중 원하시는 걸로 써도 된답니다.</li>
</ul>
<hr>
<h3>3. 기존 <code>index.html</code> 내용을 <code>RootLayout</code> 안에 넣기</h3>
<p>보통 React 프로젝트에는 <code>public/index.html</code> 파일이 있는데요, 여기에는 <code>&#x3C;body>&#x3C;div id="root">&#x3C;/div>&#x3C;/body></code> 같은 구조가 있어요. 이것을 Next.js의 레이아웃 컴포넌트에 맞게 바꿔줘야 해요.</p>
<ul>
<li><code>body</code> 안의 <code>&#x3C;div id="root">&#x3C;/div></code> 대신에 JSX 문법을 사용해서 <code>&#x3C;div id="root">{children}&#x3C;/div></code> 식으로 바꿔줍니다.</li>
<li><code>&#x3C;script></code> 태그나 직접적으로 body 바로 아래에 있는 태그들은 Next.js의 자동 렌더링 및 페이지 컴포넌트 구조에서 관리하니 제거하거나 옮겨줘야 해요.</li>
</ul>
<p>아래처럼 작성할 수 있겠죠?</p>
<pre><code class="hljs language-tsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">RootLayout</span>(<span class="hljs-params">{ children }: { children: React.ReactNode }</span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">html</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">head</span>></span>
        {/* 여기에 메타 태그, 폰트 링크 등 head 요소를 넣어줄 수 있어요 */}
      <span class="hljs-tag">&#x3C;/<span class="hljs-name">head</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">body</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"root"</span>></span>{children}<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
      <span class="hljs-tag">&#x3C;/<span class="hljs-name">body</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">html</span>></span></span>
  )
}
</code></pre>
<hr>
<h3>잠깐, 여기서 팁!</h3>
<ul>
<li>Next.js 13부터는 <code>app</code> 디렉토리 내에서 레이아웃 또는 페이지가 기본적으로 서버 컴포넌트(Server Component)로 동작해요.</li>
<li>따라서 클라이언트 사이드 상태 관리 등이 필요하면 <code>'use client'</code>를 꼭 넣어줍니다.</li>
<li>그리고 기존에 <code>&#x3C;div id="root"></code>를 React 엔트리포인트로만 사용했던 것과 달리, Next.js에서는 <code>app</code> 구조가 페이지마다 분리돼서 더 깔끔하고 모듈화된 방식으로 관리돼요.</li>
</ul>
<hr>
<p>요약하자면:<br>
<code>src/app/layout.tsx</code>를 만들고, 기존 HTML 구조를 이 안에 JSX로 옮기면서 <code>&#x3C;div id="root">{children}&#x3C;/div></code> 형태로 바꿔주면 이제 Next.js 13 스타일의 앱 레이아웃 설정이 끝! 앞으로 페이지 컴포넌트도 이 안에서 자연스럽게 렌더링 될 거예요.</p>
<p>궁금한 점 있으면 편하게 물어봐 주세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Next.js를 사용하다 보면, 기본적으로 <code>&#x3C;head></code>에 들어가는 <code>meta charset</code>이나 <code>meta viewport</code> 태그가 자동으로 포함되어 있다는 점을 알게 될 거예요. 그래서 직접 이런 태그들을 작성할 필요가 없답니다! 조금 더 깔끔하고 관리하기 편하게 아래처럼 수정할 수 있어요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">RootLayout</span>(<span class="hljs-params">{
  children,
}: {
  children: React.ReactNode
}</span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">head</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"icon"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"image/svg+xml"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/icon.svg"</span> /></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">title</span>></span>My App<span class="hljs-tag">&#x3C;/<span class="hljs-name">title</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"description"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"My App is a..."</span> /></span>
      <span class="hljs-tag">&#x3C;/<span class="hljs-name">head</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">body</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"root"</span>></span>{children}<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
      <span class="hljs-tag">&#x3C;/<span class="hljs-name">body</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">html</span>></span></span>
  )
}
</code></pre>
<p>여기서 조금 더 팁을 드리자면, favicon.ico, icon.png, robots.txt 같은 메타데이터 파일들이 있다면, 이걸 직접 <code>&#x3C;head></code>에 <code>link</code> 태그로 명시하지 않아도 돼요. Next.js가 여러분의 앱 디렉토리 최상단에 이런 파일들이 있는지 자동으로 체크해서 <code>&#x3C;head></code>에 넣어주거든요.</p>
<p>즉, 이런 작업 구조가 가능해요:</p>





















<table><thead><tr><th>위치</th><th>역할</th></tr></thead><tbody><tr><td><code>app/favicon.ico</code></td><td>파비콘 자동 등록</td></tr><tr><td><code>app/robots.txt</code></td><td>검색 엔진 크롤러에서 참고하는 robots 파일 자동 포함</td></tr><tr><td><code>app/icon.svg</code></td><td>SVG 아이콘 자동 등록</td></tr></tbody></table>
<p>따라서, 이런 파일들만 잘 관리해두면 <code>link</code> 태그를 따로 추가하거나 지저분하게 관리할 필요가 없답니다.</p>
<hr>
<blockquote>
<p>🚀 <strong>한가지 알아두면 좋은 점!</strong><br>
Next.js의 이런 자동화 덕분에 앱 구조가 훨씬 깔끔하고 유지보수가 편해져요. 그리고 혹시 이런 메타데이터를 동적으로 변경하고 싶다면 Next.js 13부터 도입된 <code>metadata</code> API도 활용해보세요! 훨씬 더 편리하게 SEO 최적화가 가능합니다.</p>
</blockquote>
<p>궁금한 게 있으면 언제든지 물어봐 주세요! 😊</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Next.js에서 head 태그를 관리하는 새로운 방법, Metadata API에 대해 이야기해볼게요. 원래는 아래처럼 직접 <code>&#x3C;head></code> 태그 안에 title이나 meta를 적었었죠.</p>
<pre><code class="hljs language-jsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">RootLayout</span>(<span class="hljs-params">{
  children,
}: {
  children: React.ReactNode
}</span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">head</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">title</span>></span>My App<span class="hljs-tag">&#x3C;/<span class="hljs-name">title</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"description"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"My App is a..."</span> /></span>
      <span class="hljs-tag">&#x3C;/<span class="hljs-name">head</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">body</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"root"</span>></span>{children}<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
      <span class="hljs-tag">&#x3C;/<span class="hljs-name">body</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">html</span>></span></span>
  )
}
</code></pre>
<p>그런데 Next.js는 이제 Metadata API라는 깔끔한 방식을 제공합니다. 이걸 쓰면 메타데이터를 컴포넌트 바깥에 <code>export const metadata</code>로 분리할 수 있어요. 코드가 더 간결해지고, SEO 최적화나 공유할 때 이점도 커지죠:</p>
<pre><code class="hljs language-tsx"><span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> { <span class="hljs-title class_">Metadata</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'next'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">metadata</span>: <span class="hljs-title class_">Metadata</span> = {
  <span class="hljs-attr">title</span>: <span class="hljs-string">'My App'</span>,
  <span class="hljs-attr">description</span>: <span class="hljs-string">'My App is a...'</span>,
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">RootLayout</span>(<span class="hljs-params">{
  children,
}: {
  children: React.ReactNode
}</span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">body</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"root"</span>></span>{children}<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
      <span class="hljs-tag">&#x3C;/<span class="hljs-name">body</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">html</span>></span></span>
  )
}
</code></pre>
<p>이렇게 바꾸면 <code>head</code> 태그 자체는 선언하지 않고도 메타데이터가 Next.js에 의해 자동으로 관리되니까 훨씬 깔끔하고 유지보수도 쉽습니다. 그리고 나중에 동적으로 제목이나 설명을 바꾸고 싶을 때도 이 Metadata API가 더 편리해요.</p>
<p>참고로, 이 방식은 <code>/app</code> 디렉토리를 사용하는 Next.js 13 이상에서 권장되는 최신 방법이라는 점 꼭 기억하세요! 만약 아직 <code>pages</code> 디렉토리를 쓰고 있다면 다음 업그레이드 때 도입해 보시면 좋을 것 같아요.</p>
<p>요약하자면, Metadata API는 다음과 같은 장점이 있어요:</p>

























<table><thead><tr><th>장점</th><th>설명</th></tr></thead><tbody><tr><td>코드 분리</td><td>메타데이터를 컴포넌트 코드에서 분리해 관리가 편리해짐</td></tr><tr><td>자동 관리</td><td>Next.js가 head 태그를 자동으로 처리해 실수를 줄임</td></tr><tr><td>SEO &#x26; 공유 최적화</td><td>SEO 관련 메타 정보와 소셜 미디어 공유 정보까지 쉽게 설정 가능</td></tr><tr><td>타입 지원</td><td>타입스크립트 Metadata 타입 제공으로 안정성 증가</td></tr></tbody></table>
<p>이렇게 공식 문서를 따라가면 Next.js 프로젝트가 한층 더 체계적이고 깔끔해질 거예요! 꼭 한번 써보세요 :)</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h3>5단계: 진입점 페이지 만들기</h3>
<p>Next.js에서는 앱의 진입점을 만들 때 <code>page.tsx</code> 파일을 작성하는 식으로 선언해요. 이걸 Vite로 치환하면, 보통 <code>main.tsx</code> 파일이 진입점 역할을 하게 됩니다. 이번 단계에서는 여러분 앱의 진입점(첫 시작점)을 설정해볼 거예요.</p>
<ul>
<li><code>app</code> 디렉토리 안에 <code>[[...slug]]</code>라는 이름의 폴더를 생성하세요.</li>
</ul>
<p>여기서 잠깐! 우리가 이번 가이드에서 Next.js를 SPA(싱글 페이지 애플리케이션)처럼 사용하려고 하거든요. 그러려면 앱의 첫 페이지가 모든 가능한 경로를 받아서 처리해야 합니다. 그래서 <code>app</code> 디렉토리에 <code>[[...slug]]</code>라는 폴더를 만들어서, 어떤 경로든 이 폴더가 잡아내서 라우팅할 수 있도록 하는 거죠.</p>
<hr>
<p>추가로 설명을 좀 하자면, Next.js에서는 <code>[[...slug]]</code>와 같은 경로 패턴이 "캐치올(catch-all)" 라우팅 기능을 의미해요. 쉽게 말해서, URL에 뭘 붙여도 다 여기서 받겠다는 뜻이죠. 그래서 SPA를 구현할 때 정말 유용합니다. Vite 같은 도구에서는 이런 라우팅을 직접 구현하거나 라이브러리를 붙여야 하는데, Next.js가 너무 잘해주는 부분이죠!</p>
<hr>
<p>혹시 React Router를 써서 SPA를 만든다면, 이런 "모든 경로를 캐치하는" 룰을 <code>&#x3C;Route path="*"></code> 같은 식으로 걸어줄 수 있다는 점도 기억해 두세요. SPA의 핵심은 결국 한 페이지에서 모든 라우팅을 내부에서 다 처리하는 거니까요.</p>
<hr>
<p>정리하자면:</p>
<ul>
<li><code>[[...slug]]</code> 폴더 생성 → Next.js의 캐치올 라우팅</li>
<li>SPA처럼 모든 경로를 한 페이지에서 처리</li>
<li>Vite는 <code>main.tsx</code>가 진입점</li>
</ul>
<p>이렇게 세팅하면 여러분 앱이 다양한 경로에서 잘 반응하는 싱글 페이지 앱이 되겠죠? 다음 단계도 같이 기대해 주세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Next.js에서는 폴더 구조가 라우트를 정의하는 중요한 역할을 해요. 여기서 소개한 <code>app/[[...slug]]</code> 디렉토리는 '옵셔널 캐치-올(optional catch-all)' 라우트 세그먼트라고 불려요. 쉽게 말하면, 이 폴더 안에 있는 페이지가 애플리케이션의 모든 경로를 잡아주도록 설정하는 거죠.</p>
<h3>직접 해보기</h3>
<p><code>app/[[...slug]]</code> 안에 <code>page.tsx</code> 파일을 새로 만들고, 아래 내용을 넣어보세요:</p>
<pre><code class="hljs language-tsx"><span class="hljs-keyword">import</span> <span class="hljs-string">'../../index.css'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">generateStaticParams</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> [{ <span class="hljs-attr">slug</span>: [<span class="hljs-string">''</span>] }]
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-string">'...'</span> <span class="hljs-comment">// 나중에 업데이트할 예정이에요</span>
}
</code></pre>
<ul>
<li>여기서 <code>generateStaticParams</code> 함수는 빌드 시에 미리 정적 페이지를 생성하기 위한 파라미터를 반환해요. 예제에선 빈 slug 배열을 반환해서 기본 경로를 세팅하고 있어요.</li>
<li><code>Page</code> 컴포넌트는 현재 그냥 문자열을 반환하는 기본 상태인데, 이후에 이 부분을 다양한 경로에 맞게 확장할 수 있습니다.</li>
</ul>
<blockquote>
<p>참고로, Next.js에서는 Page 컴포넌트 파일 이름에 <code>.js</code>, <code>.jsx</code>, <code>.tsx</code> 어떤 확장자든 사용할 수 있어요. 여러분이 편한 걸로 쓰면 됩니다!</p>
</blockquote>
<p>이렇게 설정하면, 어떤 URL로 접근하든 여기 있는 <code>page.tsx</code>가 먼저 실행되어서 복잡한 라우팅 처리를 중앙 집중화 할 때 유용해요. 예를 들어 블로그의 포스트 여러 개를 한 페이지 컴포넌트에서 처리한다든지 할 때 쓰이죠.</p>
<hr>
<p>추가로 Tip!</p>
<ul>
<li><code>[...slug]</code>는 캐치-올 라우트(segment all)인데 필수로 하나 이상의 값이 있어야 합니다.</li>
<li><code>[[...slug]]</code>는 옵셔널 캐치-올이라 slug가 없어도 이 라우트가 적용돼요.</li>
<li>이렇게 라우트를 잡으면 동적 경로도 쉽게 만들 수 있어요.</li>
</ul>
<p>Next.js 라우팅 좀 더 편하게 하고 싶다면, 이런 옵셔널 캐치-올 라우트 구조를 꼭 알아두면 좋아요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 파일은 서버 컴포넌트(Server Component)예요. <code>next build</code> 명령어를 실행하면 이 파일은 미리 렌더링(prerendering)되어 정적인 자산(static asset)으로 만들어집니다. 즉, 동적 코드가 필요 없다는 뜻이죠.</p>
<p>이 파일은 글로벌 CSS를 불러오고, <code>generateStaticParams</code> 함수에서는 오직 인덱스 경로인 <code>/</code> 하나만 정적으로 생성할 것이라고 알려줘요.</p>
<p>그럼 이제 나머지 Vite 애플리케이션 부분을 클라이언트 전용(Client-only)으로 옮겨볼게요. 다음처럼 작성하면 Next.js에서 클라이언트 전용 컴포넌트를 쉽게 다룰 수 있어요.</p>
<pre><code class="hljs language-jsx"><span class="hljs-string">'use client'</span>

<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> dynamic <span class="hljs-keyword">from</span> <span class="hljs-string">'next/dynamic'</span>

<span class="hljs-keyword">const</span> <span class="hljs-title class_">App</span> = <span class="hljs-title function_">dynamic</span>(<span class="hljs-function">() =></span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'../../App'</span>), { <span class="hljs-attr">ssr</span>: <span class="hljs-literal">false</span> })

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ClientOnly</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">App</span> /></span></span>
}
</code></pre>
<p>여기서 핵심은 <code>dynamic</code> 함수를 쓰면서 <code>{ ssr: false }</code> 옵션을 넣는 부분이에요. 이걸 통해서 서버 사이드 렌더링(SSR)을 비활성화하고, 해당 컴포넌트를 클라이언트에서만 불러오도록 설정합니다. 보통 Vite처럼 클라이언트 전용 라이브러리를 사용할 때 이렇게 하면 에러 없이 잘 작동하죠.</p>
<p>또, <code>'use client'</code> 디렉티브를 최상단에 넣는 것도 잊지 마세요. 이건 Next.js 13 버전부터 도입된 문법인데, 해당 파일이 클라이언트 컴포넌트임을 명시해줍니다.</p>
<hr>
<p><strong>TIP</strong>: 클라이언트 컴포넌트를 이렇게 분리해서 관리하면 서버 컴포넌트와 클라이언트 컴포넌트의 역할 분담이 명확해져서 유지보수도 훨씬 쉬워져요. 또한, 초기 페이지 로딩 속도도 더 좋아질 수 있으니 적극 추천합니다!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이 파일은 <code>use client</code> 지시어로 정의된 클라이언트 컴포넌트입니다. 클라이언트 컴포넌트라도 Next.js에서는 처음에 서버에서 HTML로 프리렌더링한 후 클라이언트에 전달해요.</p>
<p>하지만 클라이언트에서만 동작하는 애플리케이션을 만들고 싶다면, App 컴포넌트부터 시작해서 전체적으로 프리렌더링을 비활성화할 수 있어요. 이렇게 하면 서버에서는 HTML을 만들지 않고, 클라이언트에서만 렌더링하게 됩니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">App</span> = <span class="hljs-title function_">dynamic</span>(<span class="hljs-function">() =></span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'../../App'</span>), { <span class="hljs-attr">ssr</span>: <span class="hljs-literal">false</span> })
</code></pre>
<p>위 코드에서 <code>dynamic</code>을 사용하여 App 컴포넌트를 불러오면서 <code>{ ssr: false }</code> 옵션을 줬는데요, 이 옵션이 서버 사이드 렌더링을 끄는 역할을 해요.</p>
<p>그 다음에는 진입점(entrypoint) 페이지를 이제 이 동적으로 불러온 <code>App</code> 컴포넌트로 교체해주면 됩니다!</p>
<blockquote>
<p>참고로, 클라이언트 전용 애플리케이션을 만들 때는 서버에서 처리할 필요가 없으니 이렇게 <code>ssr: false</code>를 설정하는 게 퍼포먼스 향상에도 도움이 돼요. 하지만 SEO가 중요한 페이지라면 신중하게 사용해야겠죠.</p>
</blockquote>
<p>필요하면 아래처럼 진입점 페이지에서 바로 사용해보세요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> dynamic <span class="hljs-keyword">from</span> <span class="hljs-string">'next/dynamic'</span>

<span class="hljs-keyword">const</span> <span class="hljs-title class_">App</span> = <span class="hljs-title function_">dynamic</span>(<span class="hljs-function">() =></span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'../../App'</span>), { <span class="hljs-attr">ssr</span>: <span class="hljs-literal">false</span> })

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">App</span> /></span></span>
}
</code></pre>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Next.js와 Vite에서 정적 이미지(import) 다루는 방법이 조금 달라요. Vite에서는 이미지를 import 하면, 프로덕션 빌드 시 이미지의 URL 문자열이 반환돼서 바로 img 태그의 src에 쓸 수 있죠.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> image <span class="hljs-keyword">from</span> <span class="hljs-string">'./img.png'</span> <span class="hljs-comment">// 빌드 후에는 '/assets/img.2d8efhg.png' 같은 URL이 됨</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">{image}</span> /></span></span>
}
</code></pre>
<p>근데 Next.js는 이런 식으로 바로 이미지 URL을 가져오는 게 아니라, <code>next/image</code> 컴포넌트를 이용해서 이미지 최적화 기능을 활용하도록 권장해요. 만약 그냥 정적 파일처럼 사용하고 싶으면 Next.js의 <code>public</code> 폴더에 이미지를 넣고 URL로 접근하는 게 가장 깔끔하답니다.</p>
<p>예를 들어, <code>public/img.png</code>에 이미지를 넣었다면:</p>
<pre><code class="hljs language-jsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/img.png"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"example"</span> /></span></span>
}
</code></pre>
<p>아니면 Next.js의 Image 컴포넌트를 써서 자동으로 크기 조정, 최적화 기능을 쓰는 것도 좋아요:</p>
<pre><code class="hljs language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Image</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'next/image'</span>
<span class="hljs-keyword">import</span> img <span class="hljs-keyword">from</span> <span class="hljs-string">'../public/img.png'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Image</span> <span class="hljs-attr">src</span>=<span class="hljs-string">{img}</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"example"</span> /></span></span>
}
</code></pre>
<p>이렇게 하면 이미지가 자동으로 최적화되고 레이지 로딩도 적용돼서 퍼포먼스에 유리해요.</p>
<hr>
<blockquote>
<p><strong>Tip!</strong><br>
Next.js에서 이미지를 정적으로 import 하려면 <code>next.config.js</code>에서 <code>images</code> 설정을 잘 해줘야 하는 경우도 있어요. 그리고 외부 URL의 이미지를 쓰려면 도메인을 허용해줘야 하죠.<br>
이미지 최적화나 로딩 속도가 신경 쓰인다면 <code>next/image</code> 컴포넌트를 적극 활용해보세요!</p>
</blockquote>
<hr>
<p>결론적으로 Vite처럼 이미지 import 해서 바로 URL 받는 방식은 Next.js에선 조금 다르게 다뤄진다고 생각하면 돼요. 상황에 따라 <code>public</code> 폴더에 넣거나, <code>next/image</code>를 쓰는 두 가지 방법 중 선택하면 됩니다!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Next.js에서 이미지 파일을 정적으로 import하면, 이미지가 객체(object)로 반환돼요. 이 객체는 Next.js의 <code>Image</code> 컴포넌트에서 바로 사용할 수도 있고, 기존에 쓰던 <code>img</code> 태그에서는 이 객체의 <code>src</code> 속성만 꺼내서 쓸 수도 있답니다.</p>
<p><code>Image</code> 컴포넌트의 장점은 자동 이미지 최적화가 된다는 것! 그리고 이미지의 실제 크기를 기반으로 <code>width</code>, <code>height</code> 속성을 자동으로 넣어줘서 이미지가 로딩될 때 레이아웃이 갑자기 바뀌는 문제(layout shift)를 막아줘요. 다만 주의할 점은 이미지의 한 쪽 치수만 스타일링하고 다른 쪽은 auto로 두지 않으면, 그 치수가 <code>img</code> 태그에 자동으로 들어간 크기로 고정돼서 이미지가 왜곡될 수 있다는 거예요.</p>
<p>그래서 기존 <code>img</code> 태그를 유지하면 코드 변경량도 줄일 수 있고, 위 문제도 피할 수 있죠. 나중에 필요하면 <code>Image</code> 컴포넌트로 단계별 마이그레이션을 할 수 있어요. 이때 직접 로더(loader)를 설정하거나, Next.js 기본 서버를 사용하면 자동 이미지 최적화를 편리하게 활용할 수 있답니다.</p>
<p>끝으로 <code>/public</code> 폴더에서 절대경로로 이미지를 import했다면, 상대경로로 바꾸는 것도 잊지 마세요. 이렇게 하면 관리도 더 편해지고 빌드 과정에서 문제도 줄일 수 있어요!</p>
<hr>
<h3>정리</h3>

























<table><thead><tr><th>방법</th><th>장점</th><th>주의 사항</th></tr></thead><tbody><tr><td><code>Image</code> 컴포넌트 사용</td><td>자동 이미지 최적화, 레이아웃 안정성 확보</td><td>한쪽 치수만 스타일링 시 이미지 왜곡 가능성</td></tr><tr><td>기존 <code>img</code> 태그 유지</td><td>코드 변경 최소화, 왜곡 문제 없음</td><td>이미지 최적화 기능은 직접 구현해야 함</td></tr><tr><td><code>/public</code>에서 이미지 경로 변경</td><td>경로 관리 용이, 빌드 시 문제 감소</td><td>절대경로 -> 상대경로 수정 필요</td></tr></tbody></table>
<hr>
<h3>추가 팁: 이미지 최적화 옵션</h3>
<p>Next.js의 <code>Image</code> 컴포넌트는 기본적으로 자동 최적화를 지원하지만, 필요하면 <code>loader</code>를 정의해 좀 더 세밀한 설정도 가능해요. 예를 들어 외부 이미지 호스팅 서비스를 함께 쓸 때 유용하죠. 혹은 next.config.js에서 domains 옵션에 외부 도메인을 추가해주면, 더 다양한 이미지를 <code>Image</code> 컴포넌트로 불러올 수 있습니다.</p>
<hr>
<p>필요에 따라 <code>Image</code> 컴포넌트의 장점과 한계를 잘 고려해서 사용하면, 퍼포먼스도 챙기고 개발도 부드럽게 할 수 있어요! 궁금한 점 있으면 언제든 질문 주세요~</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>자바스크립트 코드에서 이미지 파일을 불러올 때 경로나 방식이 조금 바뀌면서 주의할 점들을 정리해봤어요.</p>
<hr>
<h3>1. 이미지 파일 import 경로 변경하기</h3>
<pre><code class="hljs language-js"><span class="hljs-comment">// 이전 방식</span>
<span class="hljs-keyword">import</span> logo <span class="hljs-keyword">from</span> <span class="hljs-string">'/logo.png'</span>

<span class="hljs-comment">// 변경된 방식</span>
<span class="hljs-keyword">import</span> logo <span class="hljs-keyword">from</span> <span class="hljs-string">'../public/logo.png'</span>
</code></pre>
<p>이전에는 루트부터 바로 경로를 지정했다면, 이제는 public 폴더를 기준으로 상대 경로를 명확히 써주는 게 좋아요. 그렇지 않으면 이미지가 제대로 불러와지지 않을 수도 있어요.</p>
<hr>
<h3>2. <code>img</code> 태그에 <code>src</code> 속성 넘길 때 주의하기</h3>
<pre><code class="hljs language-js"><span class="hljs-comment">// 이전 방식</span>
&#x3C;img src={logo} />

<span class="hljs-comment">// 변경된 방식</span>
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">{logo.src}</span> /></span></span>
</code></pre>
<p>import 한 이미지 객체 전체를 <code>src</code>에 넘기면 안 되고, 그 안에 실제 URL이 담긴 <code>.src</code> 값을 넘겨줘야 이미지가 화면에 제대로 뜹니다.</p>
<hr>
<h3>3. 대안: 직접 public 폴더 경로 지정하기</h3>
<p>이미지 파일이 <code>public/logo.png</code>에 있다면, 그냥 <code>src="/logo.png"</code>로 바로 작성해도 됩니다.</p>
<pre><code class="hljs language-js">&#x3C;img src=<span class="hljs-string">"/logo.png"</span> />
</code></pre>
<p>이렇게 작성하면 이미지가 <code>public</code> 폴더 안에서 찾아지게 되는데, 간단하게 이미지 경로를 관리할 수 있는 방법이기도 해요. 다만, 이 경우 import 없이 스트링 경로를 직접 넣는 형태라는 점 참고하세요.</p>
<hr>
<h3>추가 팁</h3>
<ul>
<li>만약 프로젝트가 Next.js 같은 프레임워크라면 <code>public</code> 폴더의 파일은 빌드 시 그대로 공개 경로로 복사돼서 <code>/이미지이름</code>으로 접근 가능합니다.</li>
<li>자주 사용하는 공용 이미지들은 <code>public</code> 폴더에 모아두는 게 관리도 편하고, 빌드에도 영향을 덜 주는 편이에요.</li>
<li>상대 경로 작성 시 <code>..</code> 여러 개를 써야 할 때 헷갈리기 쉬우니, VS Code 같은 편집기의 경로 자동완성기능을 적극 활용하면 좋아요.</li>
</ul>
<hr>
<p>이제 이미지를 불러올 때 경로 문제로 에러 뜨는 일은 조금 줄어들 거예요! 자~ 다음 프로젝트 때 적용해 보세요. :)</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<blockquote>
<p>경고: 만약 TypeScript를 사용 중이라면 src 속성에 접근할 때 타입 에러가 발생할 수 있어요. 지금은 무시해도 괜찮고, 이 가이드를 마칠 즈음에는 모두 해결될 테니 걱정 마세요.</p>
</blockquote>
<h3>7단계: 환경 변수 마이그레이션하기</h3>
<p>Next.js도 Vite처럼 <code>.env</code> 파일을 통해 환경 변수를 관리할 수 있어요. 그런데 크게 차이나는 부분이 하나 있는데, 바로 클라이언트 쪽에서 노출되는 환경 변수에 붙는 접두사(prefix)에요.</p>













<table><thead><tr><th>Vite</th><th>Next.js</th></tr></thead><tbody><tr><td><code>VITE_</code> (접두사)</td><td><code>NEXT_PUBLIC_</code> (접두사)</td></tr></tbody></table>
<p>즉, Vite에서 <code>VITE_</code>로 시작하는 환경 변수들은 Next.js에서는 <code>NEXT_PUBLIC_</code>로 바꿔줘야 클라이언트 사이드 코드에서 접근할 수 있어요. 예를 들어:</p>
<pre><code class="hljs language-js"># <span class="hljs-title class_">Vite</span> 환경 변수
<span class="hljs-variable constant_">VITE_API_URL</span>=<span class="hljs-attr">https</span>:<span class="hljs-comment">//api.example.com</span>
</code></pre>
<p>위 변수는 Next.js로 옮길 때 이렇게 바꿔줘야 해요:</p>
<pre><code class="hljs language-js"># <span class="hljs-title class_">Next</span>.<span class="hljs-property">js</span> 환경 변수
<span class="hljs-variable constant_">NEXT_PUBLIC_API_URL</span>=<span class="hljs-attr">https</span>:<span class="hljs-comment">//api.example.com</span>
</code></pre>
<p>이걸 꼭 지켜야 클라이언트에서 <code>process.env.NEXT_PUBLIC_API_URL</code>로 안전하게 접근할 수 있어요. 만약 접두사를 안 바꾸면 클라이언트 쪽에 변수가 노출되지 않아서 참조할 수 없게 돼요.</p>
<hr>
<p><strong>추가 팁!</strong><br>
환경 변수를 사용할 때 중요한 건, 민감한 정보(ex: API 키, 비밀번호 등)는 절대 클라이언트에 노출시키면 안 돼요. <code>NEXT_PUBLIC_</code> 붙은 변수는 클라이언트에서 볼 수 있기 때문에, 민감 데이터를 담기엔 적합하지 않답니다. 서버 전용 변수는 접두사 없이 그냥 <code>process.env</code>에서 바로 사용하세요.</p>
<hr>
<p>앞으로 계속 환경 변수를 변경하면서도, 변수 이름을 이렇게 맞춰주는 게 Next.js와 Vite를 함께 쓰거나 Next.js로 이전할 때 발생하는 흔한 실수 중 하나예요. 신경 써서 관리하면 빌드 문제나 런타임 오류를 줄일 수 있어요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Vite에서는 특별한 import.meta.env 객체를 통해 몇 가지 내장 환경 변수를 제공하는데, Next.js는 이 부분을 지원하지 않아요. 그래서 Vite에서 쓰던 환경 변수들을 Next.js에 맞게 이렇게 바꿔줘야 해요.</p>

























<table><thead><tr><th>Vite (import.meta.env)</th><th>Next.js (process.env)</th></tr></thead><tbody><tr><td>import.meta.env.MODE</td><td>process.env.NODE_ENV</td></tr><tr><td>import.meta.env.PROD</td><td>process.env.NODE_ENV === 'production'</td></tr><tr><td>import.meta.env.DEV</td><td>process.env.NODE_ENV !== 'production'</td></tr><tr><td>import.meta.env.SSR</td><td>typeof window === 'undefined'</td></tr></tbody></table>
<p>여기서 살짝 팁을 드리자면, import.meta.env.SSR 은 서버 사이드 렌더링 여부를 체크하기 위한 변수인데, Next.js에서는 window 객체가 없으면 서버 환경으로 인식할 수 있으니 <code>typeof window === 'undefined'</code> 로 체크해주면 됩니다.</p>
<p>그리고 한 가지 더! Next.js는 기본적으로 Vite에 있는 BASE_URL 같은 환경 변수를 제공하지 않아요. 하지만 직접 환경 변수를 만들어서 쓸 수는 있답니다. 방법은 간단해요, 프로젝트 루트에 <code>.env</code> 파일을 만들고 아래처럼 추가해주시면 됩니다.</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">NEXT_PUBLIC_BASE_URL</span>=<span class="hljs-attr">https</span>:<span class="hljs-comment">//your-domain.com</span>
</code></pre>
<p>여기서 NEXT_PUBLIC_ 접두어는 Next.js에서 브라우저 코드에서도 접근할 수 있는 환경 변수를 의미해요. 만약 서버에서만 쓸 거라면 접두어 없이 그냥 선언하면 되고요.</p>
<p>이렇게 하면 코드에서 <code>process.env.NEXT_PUBLIC_BASE_URL</code> 로 접근해서 사용할 수 있어요. 예를 들어 API 엔드포인트를 설정할 때 유용하답니다.</p>
<p>정리하자면, Vite에서 Next.js로 넘어올 때 환경 변수 관련 코드를 이렇게 바꿔주시고, 필요한 환경 변수들은 직접 <code>.env</code> 파일에 추가해서 관리하시면 됩니다!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Next.js에서 기본 경로(basePath)를 환경 변수로 설정하는 방법에 대해 공유할게요. 프로젝트를 하다 보면 <code>basePath</code>를 동적으로 설정해야 할 경우가 있는데, 예를 들어 CDN이나 특정 경로에 배포할 때 유용하죠.</p>
<h3>1. <code>.env</code> 파일에 환경 변수 설정하기</h3>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">NEXT_PUBLIC_BASE_PATH</span>=<span class="hljs-string">"/some-base-path"</span>
</code></pre>
<p>여기서 중요한 점! <code>NEXT_PUBLIC_</code> 접두어로 시작해야 클라이언트 쪽에서도 접근 가능해요.</p>
<h3>2. <code>next.config.mjs</code> 파일에서 basePath 설정하기</h3>
<p>다음과 같이 <code>next.config.mjs</code>에 <code>basePath</code>를 환경 변수로 불러와 세팅해 주세요.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">/** <span class="hljs-doctag">@type</span> {<span class="hljs-type">import('next').NextConfig</span>} */</span>
<span class="hljs-keyword">const</span> nextConfig = {
  <span class="hljs-attr">output</span>: <span class="hljs-string">'export'</span>,      <span class="hljs-comment">// SPA 형태로 빌드</span>
  <span class="hljs-attr">distDir</span>: <span class="hljs-string">'./dist'</span>,     <span class="hljs-comment">// 빌드 결과물을 'dist' 폴더로 변경</span>
  <span class="hljs-attr">basePath</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">NEXT_PUBLIC_BASE_PATH</span>,   <span class="hljs-comment">// env 변수를 basePath로 설정!</span>
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> nextConfig
</code></pre>
<blockquote>
<p>TIP: <code>next.config.mjs</code>에서 import.meta.env 대신 <code>process.env</code>를 사용해야 하는 점 잊지 마세요. Next.js는 빌드 타임에 <code>process.env</code>로 환경 변수값을 주입합니다.</p>
</blockquote>
<h3>3. 코드 내에서 <code>import.meta.env.BASE_URL</code> -> <code>process.env.NEXT_PUBLIC_BASE_PATH</code>로 변경</h3>
<p>기존에 <code>import.meta.env.BASE_URL</code> 을 사용하던 부분이 있다면, <code>process.env.NEXT_PUBLIC_BASE_PATH</code>로 바꿔줘야 합니다. 이 부분은 Vite 등 다른 빌드 시스템과 차이가 있어요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> basePath = process.<span class="hljs-property">env</span>.<span class="hljs-property">NEXT_PUBLIC_BASE_PATH</span> || <span class="hljs-string">''</span>

<span class="hljs-comment">// 사용 예</span>
<span class="hljs-keyword">const</span> fullUrl = <span class="hljs-string">`<span class="hljs-subst">${basePath}</span>/some-resource`</span>
</code></pre>
<h3>정리하자면</h3>





















<table><thead><tr><th>단계</th><th>설명</th></tr></thead><tbody><tr><td>1. env 파일 만들기</td><td><code>NEXT_PUBLIC_BASE_PATH</code> 설정</td></tr><tr><td>2. next.config.mjs 수정</td><td><code>basePath</code>에 <code>process.env.NEXT_PUBLIC_BASE_PATH</code> 지정</td></tr><tr><td>3. 코드 수정</td><td><code>import.meta.env.BASE_URL</code> → <code>process.env.NEXT_PUBLIC_BASE_PATH</code></td></tr></tbody></table>
<hr>
<p>이렇게 하면 빌드할 때마다 환경 변수로 기본 경로를 바꾸는 게 가능해져서 다양한 배포 환경에 유연하게 대응할 수 있습니다. Next.js 프로젝트 하면서 경로 문제에 한 번쯤 고민해보셨다면 참고하세요~! 필요하면 basePath 외에도 <code>assetPrefix</code>도 같이 고려하는 게 좋아요. 그럼 즐코딩~! 🚀</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h3>8단계: package.json 스크립트 업데이트하기</h3>
<p>이제 Next.js로 마이그레이션을 잘 했는지 확인하기 위해 애플리케이션을 실행해볼 수 있어요. 그런데 그 전에 package.json 안의 스크립트를 Next.js에 맞게 살짝 바꿔줘야 합니다.</p>
<p>기존에 있던 start나 build 명령어 대신 Next.js 명령어를 넣어주면 되는데요:</p>
<pre><code class="hljs language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"scripts"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"dev"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"next dev"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"build"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"next build"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"start"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"next start"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<ul>
<li><code>"dev"</code>: 개발 모드로 로컬 서버를 띄울 때 사용해요 (hot reload도 지원해서 개발할 때 편리해요)</li>
<li><code>"build"</code>: 배포 전, 프로덕션용으로 최적화된 빌드를 생성할 때 쓰입니다.</li>
<li><code>"start"</code>: 빌드된 결과물을 실제 서비스 환경에서 실행할 때 사용하죠.</li>
</ul>
<p>그리고 Git 관리할 때 필요 없는 파일들을 깃에서 제외하기 위하여 <code>.gitignore</code> 파일에도 다음 내용을 추가해주세요:</p>
<p>.next
next-env.d.ts
dist</p>
<ul>
<li><code>.next</code> 폴더는 Next.js가 빌드하면서 생성하는 임시파일들이라 보통 Git에 올리지 않아요.</li>
<li><code>next-env.d.ts</code>는 Next.js 타입 지원을 위한 선언 파일로, 자동 생성되므로 따로 관리하지 않습니다.</li>
<li><code>dist</code>는 프로젝트마다 다르지만, 빌드 후 결과를 담고 있는 폴더라면 역시 빼는 게 좋습니다.</li>
</ul>
<p>참고로, <code>.gitignore</code>에 이런 빌드 결과 파일들을 미리 넣어두면 협업할 때 불필요한 충돌도 줄일 수 있어요. 다음 단계에서는 이렇게 설정한 상태에서 실제로 <code>npm run dev</code> 명령어로 개발 서버를 실행해보면서 잘 작동하는지 확인해보세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>이제 터미널에서 <code>npm run dev</code> 명령어를 실행하고, <a href="http://localhost:3000" rel="nofollow" target="_blank">http://localhost:3000</a> 에 접속해 보세요. 그러면 당신의 Next.js 애플리케이션이 잘 실행되고 있는 모습을 확인할 수 있을 거예요.</p>
<blockquote>
<p>참고로, Vite로 만들어진 애플리케이션을 Next.js로 마이그레이션한 실제 예제를 보고 싶다면 이 <a href="https://github.com/vercel/next.js/pull/####" rel="nofollow" target="_blank">Pull Request</a>를 확인해 보세요. (원문에 링크가 있다면 여기에 넣어주세요.)</p>
</blockquote>
<h3>9단계: 정리하기</h3>
<p>이제 Vite 관련 파일들이나 설정들은 모두 정리할 차례입니다. 프로젝트에서 Vite와 관련된 불필요한 것들을 깔끔하게 제거해서 코드베이스를 정돈해 주세요!</p>
<p>예를 들어, 다음과 같은 것들을 확인하시면 좋아요:</p>

























<table><thead><tr><th>제거 대상</th><th>설명</th></tr></thead><tbody><tr><td><code>vite.config.js</code></td><td>Vite 설정 파일</td></tr><tr><td><code>index.html</code></td><td>Vite에서 사용했던 진입 HTML 파일</td></tr><tr><td><code>package.json</code>의 Vite 관련 의존성</td><td><code>vite</code>, <code>@vitejs/plugin-react</code> 등</td></tr><tr><td>기타 Vite 전용 스크립트</td><td>빌드 스크립트나 개발 서버 관련 설정</td></tr></tbody></table>
<p>이렇게 정리하고 나면 Next.js만 사용하는 깔끔한 환경을 만들 수 있습니다.</p>
<hr>
<p>만약 다음 단계가 궁금하다면, Next.js의 배포나 최적화 방법 등을 함께 알아보는 것도 추천합니다. Next.js는 기본적으로 SSR(서버 사이드 렌더링)과 SSG(정적 사이트 생성), 그리고 CSR(클라이언트 사이드 렌더링)을 유연하게 사용할 수 있어서 애플리케이션을 더 빠르고 SEO 친화적으로 만들어 주거든요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<ul>
<li>main.tsx 삭제</li>
<li>index.html 삭제</li>
<li>vite-env.d.ts 삭제</li>
<li>tsconfig.node.json 삭제</li>
<li>vite.config.ts 삭제</li>
<li>Vite 관련 의존성 제거</li>
</ul>
<h2>다음 단계</h2>
<p>만약 지금까지 작업이 잘 됐다면, 이제 Next.js를 기반으로 동작하는 싱글 페이지 애플리케이션을 갖게 된 거예요. 하지만 아직 Next.js가 제공하는 많은 장점들을 완전히 활용하고 있진 않은 상태입니다. 이제부터 점진적으로 개선하면서 Next.js의 진가를 맛보실 수 있는데요, 다음 단계로 고려해볼 만한 사항들을 소개할게요:</p>





























<table><thead><tr><th>다음 단계</th><th>설명</th></tr></thead><tbody><tr><td>React Router에서 Next.js App Router로 마이그레이션</td><td>- 자동 코드 분할로 초기 로딩 속도 개선<br>- 스트리밍 서버 사이드 렌더링 지원<br>- React 서버 컴포넌트 활용 가능</td></tr><tr><td>이미지 최적화</td><td>Next.js <code>Image</code> 컴포넌트로 자동 최적화된 이미지 제공</td></tr><tr><td>폰트 최적화</td><td><code>next/font</code>를 활용해 폰트 로딩 속도 및 성능 개선 가능</td></tr><tr><td>서드파티 스크립트 최적화</td><td>Next.js <code>Script</code> 컴포넌트로 외부 스크립트 로딩 최적화</td></tr><tr><td>ESLint 설정 업데이트</td><td>Next.js 규칙을 지원하도록 ESLint를 구성하여 코드 품질 유지</td></tr></tbody></table>
<hr>
<p>여기서 한 가지 팁을 추가하자면, Next.js의 App Router는 전통적인 React Router보다 많은 부분에서 성능과 개발 경험을 향상시키는데요. 특히 서버 컴포넌트(Server Components)를 적극 활용하면 클라이언트에서 불필요한 자바스크립트가 줄어들어 사용자 경험이 좋아집니다. 그리고 이미지나 폰트 최적화는 SEO와 사용자 경험에 직접적인 영향을 주기 때문에 꼭 챙겨보시길 추천드립니다!</p>
<p>조금씩 바꾸면서 Next.js 애플리케이션의 진정한 잠재력을 느껴보세요. 궁금한 점이 있으면 언제든 질문해 주세요!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Vite에서 Next.js 15로 마이그레이션 하는 방법","description":"","date":"2025-04-22 01:30","slug":"2025-04-22-HowtomigratefromVitetoNextjs","content":"\n\n# Vite에서 Next.js로 마이그레이션하는 방법\n\n안녕하세요! 오늘은 Vite로 만들어진 기존 프로젝트를 Next.js로 옮기는 방법에 대해 이야기해볼게요. 요새 React 생태계에서 Next.js가 워낙 대세라서요, 프로젝트 확장성이나 SEO 같은 부분 때문에 넘어가는 분들이 많더라고요. \n\n## 왜 굳이 Next.js로 갈아타야 할까?\n\n사실 Vite도 빠르고 사용하기 편한 툴인데, Next.js로 갈아타는 몇 가지 이유가 있거든요.\n\n| 이유 | 설명 |\n|---|---|\n| **서버 사이드 렌더링(SSR)** | Next.js는 기본적으로 SSR을 지원해서 SEO에 훨씬 유리해요. Vite는 클라이언트 렌더링에 초점이 맞춰져 있죠. |\n| **파일 기반 라우팅** | Next.js는 폴더 구조만 잘 맞추면 라우팅 설정이 자동으로 되어 개발 속도가 빨라져요. Vite는 라우터 설정을 직접 해줘야 하죠. |\n| **API 라우트 지원** | Next.js 내에서 API 엔드포인트를 쉽게 만들 수 있어 백엔드 \u0026 프론트엔드 통합이 편리해요. Vite는 보통 별도의 서버를 띄워야 해요. |\n| **강력한 커뮤니티와 플러그인** | Next.js는 많은 플러그인과 라이브러리가 있어서 생태계가 풍부하고, 지원도 활발해요. |\n\n사실 프로젝트 규모가 커지고, SEO가 중요해지고, 좀 더 안정적인 서버 사이드 렌더링이 필요하다면 Next.js는 거의 필수 선택지라고 할 수 있겠네요!\n\n다음 포스팅에서는 실제로 Vite 프로젝트를 어떻게 Next.js 프로젝트로 옮길지, 단계별로 자세히 알려드릴게요. 기대해주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 느린 초기 페이지 로딩 시간\n\n만약 기본 Vite 플러그인으로 리액트 애플리케이션을 만들었다면, 여러분의 앱은 순수한 클라이언트 사이드 애플리케이션입니다. 이렇게 클라이언트 사이드에서만 앱을 실행하는 방식, 즉 흔히 싱글 페이지 애플리케이션(SPA)이라고 하죠. 이 방식은 보통 초기 페이지 로딩 속도가 느려지는 문제가 발생합니다. 왜 그런지 간단히 살펴볼게요.\n\n- 브라우저가 여러분의 리액트 코드와 전체 애플리케이션 번들을 내려받고 실행하기 전까지는 데이터 요청조차 시작할 수 없습니다.\n- 시간이 지나면서 기능이 추가되고 의존성도 늘어나면서 애플리케이션 코드가 점점 커져서 더 오래 걸리게 됩니다.\n\n즉, 초기 로딩에 필요한 코드가 한 번에 너무 많아서 브라우저가 버거워하는 상황인 거죠.\n\n### 자동 코드 분할이 없다면?\n\n자동 코드 분할이란 쉽게 말해, 필요한 코드만 쪼개서 나중에 불러오는 걸 의미해요. 하지만 기본 설정으로 만든 Vite + React 프로젝트엔 이 기능이 적용되어 있지 않습니다. 그래서 앱 전체 코드를 한 번에 내려받아야 하죠.\n\n자동 코드 분할이 없으면 다음과 같은 단점이 있어요.\n\n| 문제점              | 설명                                                                                     |\n|-----------------|----------------------------------------------------------------------------------------------|\n| 초기 로딩 느림      | 모든 코드가 한 번에 내려오니까 페이지가 뜨기까지 기다려야 하는 시간이 길어짐                                       |\n| 불필요한 코드 다운로드 | 현재 페이지에서 필요하지 않은 코드도 같이 받게 되어 네트워크 자원이 낭비됨                                                |\n| 사용자 경험 저하    | 로딩 시간이 길어지면 방문자가 페이지 이탈할 확률이 높아짐                                                         |\n\n자동 코드 분할을 도입하면 첫 페이지 로딩은 가볍게, 이후 필요한 기능은 필요한 순간에 불러올 수 있어 앱 속도가 체감상 빨라집니다.\n\n---\n\n### 추가 팁: 해결책으로 SSG/SSR 도입하기\n\n초기 로딩 속도를 확실히 개선하고 싶다면, 서버 사이드 렌더링(SSR)이나 정적 사이트 생성(SSG)을 도입하는 것도 좋은 방법입니다. Next.js 같은 프레임워크는 기본적으로 이 기능들을 지원해요. 요청 시 서버에서 미리 렌더링된 HTML을 보내면 브라우저가 JS 실행을 기다리지 않아도 빠르게 페이지를 보여줄 수 있죠.\n\n단, SSR/SSG는 설정이 좀 더 복잡할 수 있으니 상황과 요구에 맞게 도입하면 됩니다.\n\n---\n\n이처럼 리액트 앱 개발할 때 초기 로딩 속도 문제는 SPA의 흔한 고민이고, 자동 코드 분할 또는 SSR/SSG 같은 기술을 적절히 적용하면 훨씬 개선할 수 있어요. 앞으로 프로젝트에 적용해 보면서 체감 성능을 경험해보시길 바랍니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이전 글에서 언급한 느린 로딩 문제는 코드 스플리팅(code splitting)으로 어느 정도 해결할 수 있어요. 그런데 직접 수동으로 코드 스플리팅을 하려고 하면 오히려 성능이 더 안 좋아질 수도 있어요. 수동으로 코드를 나누다 보면 네트워크 워터폴(Network waterfalls, 요청이 순차적으로 쌓여서 느려지는 현상)이 쉽게 발생할 수 있거든요. 다행히 Next.js는 자체 라우터에 자동 코드 스플리팅 기능이 내장되어 있어서 이런 문제를 훨씬 간편하게 해결할 수 있어요.\n\n### 네트워크 워터폴(Network waterfalls)이란?\n\n네트워크 워터폴은 애플리케이션이 클라이언트와 서버 사이에서 순차적으로 여러 데이터를 요청할 때 발생하는 성능 저하 현상이에요. SPA(싱글 페이지 애플리케이션)에서 데이터를 받아올 때 주로, 처음에는 로딩용 자리 표시자(placeholder)를 렌더링하고, 컴포넌트가 마운트된 후에야 데이터를 받아오는 패턴이 많죠. 이 경우 하위 컴포넌트가 데이터를 요청하려면, 반드시 상위 컴포넌트가 자신의 데이터를 모두 받은 뒤여야 해서 대기시간이 길어질 수밖에 없습니다.\n\nNext.js는 클라이언트에서 데이터를 받아오는 것도 지원하지만, 데이터 페칭을 서버 사이드에서 처리하게끔 선택할 수도 있어요. 서버에서 데이터를 미리 받아서 렌더링하면 이런 클라이언트-서버 워터폴 현상을 완전히 없앨 수 있답니다.\n\n---\n\n마치면서 한 가지 팁!  \n서버 사이드 렌더링(SSR)이나 SSG(정적 사이트 생성)를 활용하면, 페이지 렌더링 전에 데이터를 미리 받아오기 때문에 사용자 입장에서 훨씬 빠른 초기 로딩을 경험할 수 있어요. Next.js의 `getServerSideProps`나 `getStaticProps` 같은 함수들이 그 역할을 하니, 꼭 활용해보세요!\n\n---\n\n| 개념          | 설명                                                                                  |\n|--------------|-------------------------------------------------------------------------------------|\n| 코드 스플리팅    | 자바스크립트 코드를 여러 덩어리로 나누어 필요한 부분만 불러와 초기 로딩 속도를 개선하는 방법                   |\n| 네트워크 워터폴 | 클라이언트와 서버가 요청을 연속적으로 주고받아서 응답시간이 길어지는 현상                                        |\n| Next.js 자동 코드 스플리팅 | Next.js의 라우터가 페이지별로 자동으로 코드 스플리팅을 해주어 성능 최적화를 돕는 기능                           |\n| 서버 사이드 데이터 페칭 | Next.js가 페이지 렌더링 전에 서버에서 데이터를 미리 받아와 클라이언트-서버 간 요청 지연 문제를 해결하는 방식          |\n\n필요하면 다음 글에서 Next.js의 데이터 페칭 방법과 활용법도 자세히 알려드릴게요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 빠르고 의도적인 로딩 상태 관리\n\nReact Suspense가 스트리밍을 기본적으로 지원하면서, 어떤 UI 부분을 먼저 로딩할지, 또 어떤 순서로 로딩할지 더 세심하게 설계할 수 있게 되었습니다. 덕분에 네트워크 워터폴(waterfall) 현상을 피할 수 있죠.\n\n네트워크 워터폴이란, 한 요청이 끝나야 다음 요청이 시작되는 상황을 말하는데, 이게 계속 쌓이면 로딩 속도가 느려져 사용자 경험이 떨어집니다. Suspense를 사용하면 여러 컴포넌트를 병렬로 로딩하면서도 사용자에게 매끄럽게 보여줄 수 있어서, 페이지 로딩 속도도 빨라지고 레이아웃이 불안정하게 변하는 문제(layout shift)도 줄일 수 있습니다.\n\n### 데이터 패칭(가져오기) 전략 선택하기\n\n내가 배운 바로는, 데이터 패칭 전략을 잘 선택하는 게 매우 중요해요. 예를 들어, 모든 데이터를 한 번에 가져오느냐, 필요한 데이터만 나눠서 가져오느냐에 따라 성능과 사용자 경험이 확 달라집니다.\n\n아래 표는 다양한 데이터 패칭 전략과 그 특징을 간단히 정리한 거예요.\n\n| 전략                   | 설명                                  | 장점                          | 단점                          |\n|----------------------|-------------------------------------|-----------------------------|-----------------------------|\n| 전체 데이터 한 번에 로드    | 페이지 로드 시 모든 데이터를 한꺼번에 요청           | 초기 로딩 후 빠른 탐색 가능           | 초기 로딩 시간 길어짐               |\n| 필요한 데이터만 나눠서 로드 | 필요한 부분만 요청, 점진적 로딩 지원                  | 빠른 초기 로딩, 네트워크 부하 분산       | 구현 복잡도 증가                    |\n| 캐싱 활용               | 요청한 데이터를 캐싱하여 재사용                        | 불필요한 중복 요청 방지                 | 데이터 최신성 관리 필요              |\n| 스트리밍                 | React Suspense와 함께 스트리밍 데이터 로딩 활용          | 사용자에게 빠르게 부분 렌더링 가능       | 서버 및 클라이언트 세팅 복잡           |\n\n특히 React Suspense와 같은 최신 기능들을 활용하면, 스트리밍 방식으로 데이터를 점진적으로 받아오면서 사용자에게 빠른 피드백을 줄 수 있어요. 개발자로서 이런 점들을 염두에 두면, 퍼포먼스 좋은 앱을 만드는 데 큰 도움이 됩니다.\n\n---\n\n궁금한 점 있으면 언제든 댓글로 남겨주세요! 앞으로도 이런 실용적인 개발 팁들을 계속 공유할게요 :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js는 상황에 맞게 페이지나 컴포넌트 단위로 데이터 가져오기 전략을 선택할 수 있도록 유연성을 제공합니다. 예를 들어, 빌드 시점에 데이터를 가져와서 CMS에 있는 블로그 포스트를 렌더링하고, 이를 CDN에 캐시해서 빠르게 서비스할 수 있어요. 또는 서버 요청 시점이나 클라이언트에서 데이터를 받아서 동적으로 처리할 수도 있죠. 이렇게 상황에 따라 가장 적합한 방식을 선택할 수 있다는 게 Next.js의 큰 장점 중 하나랍니다.\n\n### 미들웨어 (Middleware)\n\nNext.js의 미들웨어는 서버에서 요청이 완료되기 전에 코드를 실행할 수 있도록 해줍니다. 예를 들어, 로그인해야 볼 수 있는 페이지에 사용자가 접근했을 때, 잠깐 인증이 안 된 페이지가 보이는 ‘깜빡임(flash)’ 현상을 막고 바로 로그인 페이지로 리다이렉트할 수 있어요. 이 외에도 새로운 기능을 실험해보거나, 다국어 지원 같은 국제화 작업에 아주 유용하죠. 미들웨어가 있다 보니 이런 작업들이 좀 더 자연스럽고 효율적으로 처리됩니다.\n\n### 내장 최적화 기능\n\nNext.js는 개발자가 따로 신경 쓰지 않아도 자동으로 여러 최적화를 수행합니다. 예를 들어, 이미지 최적화, 번들 크기 최소화, 코드 스플리팅, 그리고 사전 렌더링 같은 기능들이 모두 내장되어 있어요. 특히 이미지 최적화는 웹 페이지 로딩 속도를 크게 높여주니, 사용자 경험 개선에 큰 효과가 있답니다. 덕분에 복잡한 설정 없이도 빠르고 효율적인 웹사이트를 만들 수 있어요.\n\n---\n\nNext.js를 처음 접하는 분들은 이런 데이터 페칭과 미들웨어, 그리고 최적화 기능들이 어떻게 연결되는지 이해하는 게 중요해요. 다양한 상황에 맞게 전략을 골라 사용하면 사이트 성능을 최대로 끌어올릴 수 있으니까요! 만약 이 부분들이 더 궁금하다면 다음 포스트에서 각 전략별 예제와 함께 자세히 설명해볼게요 :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이미지, 폰트, 그리고 서드파티 스크립트는 애플리케이션 성능에 꽤 큰 영향을 줘요. 다행히 Next.js에는 이런 요소들을 자동으로 최적화해주는 내장 컴포넌트들이 있어서 성능 관리를 훨씬 쉽게 해줍니다.\n\n---\n\n## 마이그레이션 단계\n\n이번 마이그레이션 목표는 최대한 빠르게 Next.js 기반의 작동하는 애플리케이션을 만드는 거예요. 그 후에 필요에 따라 Next.js의 여러 기능을 차근차근 적용해 나가면 돼요. 처음에는 기존 라우터를 그대로 두고, 순수 클라이언트 사이드 애플리케이션(SPA)으로만 유지하는 방식으로 진행할 거예요. 이렇게 하면 마이그레이션 중에 발생할 수 있는 문제나 병합 충돌을 최소화할 수 있습니다.\n\n---\n\n### 1단계: Next.js 의존성 설치하기\n\n마이그레이션의 첫걸음은 Next.js 패키지를 프로젝트에 추가하는 것부터 시작합니다. 이 부분은 기본 중의 기본이니까 꼼꼼하게 설치해 주세요! 다음 명령어를 터미널에 입력하면 됩니다:\n\n```bash\nnpm install next react react-dom\n```\n\n또는 yarn을 사용한다면,\n\n```bash\nyarn add next react react-dom\n```\n\n이렇게 하면 Next.js가 필요로 하는 핵심 라이브러리들이 프로젝트에 추가됩니다.\n\n\u003e 참고로, Next.js는 React 기반 프레임워크라 React와 ReactDOM도 함께 설치해야 해요. 이미 설치되어 있다면 중복 설치가 되지 않으니 걱정하지 않아도 됩니다!\n\n설치가 완료됐으면, 다음 단계로 넘어가서 실제로 Next.js 프로젝트 구조에 맞게 파일들을 조금씩 정리해보도록 할게요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n먼저, Next.js를 사용하기 위해서는 프로젝트에 Next를 의존성으로 설치해야 해요:\n\n```bash\nnpm install next@latest\n```\n\n### 2단계: Next.js 설정 파일 만들기\n\n프로젝트 루트에 `next.config.mjs` 파일을 만들어주세요. 이 파일은 Next.js의 다양한 설정 옵션들을 담고 있어요.\n\n\u003e 참고로 이 설정 파일은 JavaScript나 TypeScript 파일처럼 동작하지만, `.mjs` 확장자를 사용하면 ES 모듈 방식을 명확히 하게 돼서 최근 Next.js 프로젝트에서 권장되고 있답니다.  \n\n필요한 설정들을 여기서 자유롭게 추가해서 프로젝트 요구사항에 맞게 조절해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자, 이번에는 Next.js 설정 파일을 조금 바꿔볼게요! 위 예제 코드는 `next.config.js` 파일에 들어갈 내용인데요. \n\n```js\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  output: 'export',    // 이 설정은 Next.js를 SPA(단일 페이지 애플리케이션)로 내보내도록 해줘요.\n  distDir: './dist',   // 빌드 결과물을 기본 폴더가 아닌 './dist' 폴더에 저장해요.\n}\n\nexport default nextConfig\n```\n\n\u003e 참고로, Next.js 설정 파일은 `.js` 뿐만 아니라 `.mjs` 확장자를 써도 무방해요. 그래서 프로젝트 스타일에 맞게 골라 쓰시면 됩니다.\n\n그리고 이제 TypeScript를 쓰는 분들은 tsconfig.json 파일을 수정해줘야 해요! Next.js와 호환되게끔 일부 설정을 바꿔줘야 하거든요. 만약 TypeScript를 쓸 필요가 없다면 이 부분은 건너뛰셔도 되니까 부담 갖지 마세요.\n\n---\n\n### TypeScript 사용자라면 tsconfig.json 수정하는 팁!\n\nNext.js는 TypeScript를 공식 지원하지만, 기본 설정이 Next.js 빌드 시스템에 맞게끔 커스텀 필요가 있어요. 보통은 다음과 같이 `compilerOptions`와 같이 설정합니다:\n\n| 옵션               | 설명                                        |\n|--------------------|---------------------------------------------|\n| `jsx`              | React JSX 변환 설정 (예: `\"react-jsx\"`)      |\n| `module`           | 모듈 시스템 (주로 `\"esnext\"` 사용)            |\n| `target`           | 컴파일 타겟팅 자바스크립트 버전                |\n| `strict`           | 엄격한 타입 체크 설정                         |\n| `baseUrl`           | 절대 경로 기준 디렉토리                          |\n| `paths`            | 모듈 경로 별칭 설정                           |\n\n예를 들어, tsconfig.json에 다음처럼 넣으면 더 편리하답니다:\n\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"es5\",\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"allowJs\": true,\n    \"skipLibCheck\": true,\n    \"strict\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"noEmit\": true,\n    \"esModuleInterop\": true,\n    \"module\": \"esnext\",\n    \"moduleResolution\": \"node\",\n    \"resolveJsonModule\": true,\n    \"isolatedModules\": true,\n    \"jsx\": \"react-jsx\"\n  },\n  \"include\": [\"next-env.d.ts\", \"**/*.ts\", \"**/*.tsx\"],\n  \"exclude\": [\"node_modules\"]\n}\n```\n\n이렇게 하면 Next.js에서 TypeScript를 더 원활하게 사용할 수 있답니다. 더 궁금하면 언제든 물어봐 주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nTypeScript 설정을 하면서 다음과 같은 변경사항을 적용해봤어요.\n\n- `tsconfig.node.json` 프로젝트 참조 제거\n- `include` 배열에 `./dist/types/**/*.ts` 와 `./next-env.d.ts` 추가\n- `exclude` 배열에 `./node_modules` 추가\n- `compilerOptions`의 `plugins` 배열에 `\"name\": \"next\"` 추가\n- `esModuleInterop`을 `true`로 설정\n- `jsx`를 `\"preserve\"`로 설정\n- `allowJs`를 `true`로 설정\n- `forceConsistentCasingInFileNames`를 `true`로 설정\n- `incremental`을 `true`로 설정\n\n아래는 이렇게 수정된 `tsconfig.json` 예시입니다:\n\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2020\",\n    \"useDefineForClassFields\": true,\n    \"lib\": [\"ES2020\", \"DOM\", \"DOM.Iterable\"],\n    \"module\": \"ESNext\",\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"moduleResolution\": \"bundler\",\n    \"allowImportingTsExtensions\": true,\n    \"resolveJsonModule\": true,\n    \"isolatedModules\": true,\n    \"noEmit\": true,\n    \"jsx\": \"preserve\",\n    \"strict\": true,\n    \"noUnusedLocals\": true,\n    \"noUnusedParameters\": true,\n    \"noFallthroughCasesInSwitch\": true,\n    \"allowJs\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"incremental\": true,\n    \"plugins\": [{ \"name\": \"next\" }]\n  },\n  \"include\": [\"./src\", \"./dist/types/**/*.ts\", \"./next-env.d.ts\"],\n  \"exclude\": [\"./node_modules\"]\n}\n```\n\n---\n\n조금 더 풀어 이야기하자면,\n\n- `esModuleInterop: true`는 CommonJS 모듈과 ES 모듈 간의 호환성을 좋게 해줍니다. 그래서 `import` 구문을 쓸 때 오류를 줄여줘요.\n- `jsx: \"preserve\"`는 JSX를 컴파일하지 않고 그대로 두라는 뜻인데, Next.js가 자체적으로 처리하기 때문에 이렇게 해주는게 일반적이에요.\n- `allowJs: true`를 켜면 자바스크립트 파일도 TS 빌드 대상에 포함할 수 있어서, 점진적으로 타입스크립트로 이전하려는 프로젝트에서 유용합니다.\n- `forceConsistentCasingInFileNames: true` 설정은 대소문자 차이로 생기는 파일 경로 문제를 예방해줍니다. 특히 OS마다 대소문자 구분이 다른 경우에 꼭 필요해요.\n- `incremental: true`는 빌드 속도를 향상시키기 위해 이전 빌드 정보를 캐싱해주는 기능입니다. 개발할 때 시간 절약에 큰 도움이 돼요.\n- 플러그인에 `\"name\": \"next\"`를 넣으면 Next.js에서 권장하는 타입스크립트 플러그인을 사용하게 됩니니다.\n\nNext.js 공식 문서에도 TypeScript 구성에 대한 좋은 안내가 있으니, 필요하면 꼭 참고해보세요.  \nhttps://nextjs.org/docs/basic-features/typescript\n\n이 설정을 기반으로 프로젝트를 구성하면 Next.js + TypeScript 환경에서 좀 더 편리하고 안정적으로 개발하실 수 있습니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 4단계: 루트 레이아웃 만들기\n\nNext.js의 App Router를 사용할 때는 루트 레이아웃(root layout) 파일이 꼭 필요해요. 이 파일은 React Server Component로, 여러분의 앱 안에 있는 모든 페이지를 감싸는 역할을 하죠. 그리고 이 파일은 `app` 디렉토리의 최상단에 위치해야 합니다.\n\n비슷한 개념을 Vite 앱에서 찾자면, 바로 `index.html` 파일이에요. 이 파일이 여러분의 HTML, head, body 태그를 포함하고 있어서, Next.js에서 말하는 루트 레이아웃과 가장 비슷한 역할을 하죠.\n\n이번 단계에서는 여러분의 `index.html` 파일을 Next.js의 루트 레이아웃 파일로 변환해볼 거예요. \n\n---\n\n여기서 꼭 짚고 넘어갈 점은 Next.js에서는 이 루트 레이아웃이 React 컴포넌트라는 거예요. 단순히 HTML 파일이 아니라 리액트 컴포넌트로 작성되니, 필요한 경우 React의 훅이나 다른 컴포넌트로 기능 확장이 훨씬 쉬워요. 즉, 더 동적이고 유연한 레이아웃 구성이 가능하다는 거죠.\n\n그럼 이제 `index.html`에서 어떤 부분을 어떻게 바꿔주면 될지 살펴볼게요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번에는 Next.js 프로젝트에서 새로운 앱 디렉토리를 만들고, 레이아웃 설정을 하는 방법을 알려드릴게요. 특히 Next.js 13 버전에서 도입된 '새로운 app 디렉토리 구조'를 활용하는 예제인데요, 코드 설명도 곁들여서 천천히 같이 보시죠!\n\n---\n\n### 1. `src` 안에 `app` 디렉토리 만들기\n\n먼저, 프로젝트 폴더 안 `src` 디렉토리 안에 `app` 폴더를 새로 만들어줘요. 여기서부터 우리 앱의 페이지, 레이아웃 등이 관리될 거예요.\n\n\nsrc/\n  └── app/\n\n\n---\n\n### 2. `RootLayout` 컴포넌트 만들기 (`layout.tsx`)\n\n`app` 폴더 안에 `layout.tsx` 파일을 하나 새로 만들어요. 이 파일은 페이지들의 공통 레이아웃을 담당합니다.\n\n```tsx\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return '...'\n}\n```\n\n- `children`은 이 레이아웃 안에 렌더링될 페이지나 하위 컴포넌트들을 의미해요.\n- 중요! `layout.tsx` 같은 레이아웃 파일 확장자는 `.js`, `.jsx`, `.tsx` 중 원하시는 걸로 써도 된답니다.\n\n---\n\n### 3. 기존 `index.html` 내용을 `RootLayout` 안에 넣기\n\n보통 React 프로젝트에는 `public/index.html` 파일이 있는데요, 여기에는 `\u003cbody\u003e\u003cdiv id=\"root\"\u003e\u003c/div\u003e\u003c/body\u003e` 같은 구조가 있어요. 이것을 Next.js의 레이아웃 컴포넌트에 맞게 바꿔줘야 해요.\n\n- `body` 안의 `\u003cdiv id=\"root\"\u003e\u003c/div\u003e` 대신에 JSX 문법을 사용해서 `\u003cdiv id=\"root\"\u003e{children}\u003c/div\u003e` 식으로 바꿔줍니다.\n- `\u003cscript\u003e` 태그나 직접적으로 body 바로 아래에 있는 태그들은 Next.js의 자동 렌더링 및 페이지 컴포넌트 구조에서 관리하니 제거하거나 옮겨줘야 해요.\n\n아래처럼 작성할 수 있겠죠?\n\n```tsx\nexport default function RootLayout({ children }: { children: React.ReactNode }) {\n  return (\n    \u003chtml\u003e\n      \u003chead\u003e\n        {/* 여기에 메타 태그, 폰트 링크 등 head 요소를 넣어줄 수 있어요 */}\n      \u003c/head\u003e\n      \u003cbody\u003e\n        \u003cdiv id=\"root\"\u003e{children}\u003c/div\u003e\n      \u003c/body\u003e\n    \u003c/html\u003e\n  )\n}\n```\n\n---\n\n### 잠깐, 여기서 팁!\n\n- Next.js 13부터는 `app` 디렉토리 내에서 레이아웃 또는 페이지가 기본적으로 서버 컴포넌트(Server Component)로 동작해요.\n- 따라서 클라이언트 사이드 상태 관리 등이 필요하면 `'use client'`를 꼭 넣어줍니다.\n- 그리고 기존에 `\u003cdiv id=\"root\"\u003e`를 React 엔트리포인트로만 사용했던 것과 달리, Next.js에서는 `app` 구조가 페이지마다 분리돼서 더 깔끔하고 모듈화된 방식으로 관리돼요.\n\n---\n\n요약하자면:  \n`src/app/layout.tsx`를 만들고, 기존 HTML 구조를 이 안에 JSX로 옮기면서 `\u003cdiv id=\"root\"\u003e{children}\u003c/div\u003e` 형태로 바꿔주면 이제 Next.js 13 스타일의 앱 레이아웃 설정이 끝! 앞으로 페이지 컴포넌트도 이 안에서 자연스럽게 렌더링 될 거예요.\n\n궁금한 점 있으면 편하게 물어봐 주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js를 사용하다 보면, 기본적으로 `\u003chead\u003e`에 들어가는 `meta charset`이나 `meta viewport` 태그가 자동으로 포함되어 있다는 점을 알게 될 거예요. 그래서 직접 이런 태그들을 작성할 필요가 없답니다! 조금 더 깔끔하고 관리하기 편하게 아래처럼 수정할 수 있어요.\n\n```js\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    \u003chtml lang=\"en\"\u003e\n      \u003chead\u003e\n        \u003clink rel=\"icon\" type=\"image/svg+xml\" href=\"/icon.svg\" /\u003e\n        \u003ctitle\u003eMy App\u003c/title\u003e\n        \u003cmeta name=\"description\" content=\"My App is a...\" /\u003e\n      \u003c/head\u003e\n      \u003cbody\u003e\n        \u003cdiv id=\"root\"\u003e{children}\u003c/div\u003e\n      \u003c/body\u003e\n    \u003c/html\u003e\n  )\n}\n```\n\n여기서 조금 더 팁을 드리자면, favicon.ico, icon.png, robots.txt 같은 메타데이터 파일들이 있다면, 이걸 직접 `\u003chead\u003e`에 `link` 태그로 명시하지 않아도 돼요. Next.js가 여러분의 앱 디렉토리 최상단에 이런 파일들이 있는지 자동으로 체크해서 `\u003chead\u003e`에 넣어주거든요.\n\n즉, 이런 작업 구조가 가능해요:\n\n| 위치                  | 역할                                          |\n|---------------------|---------------------------------------------|\n| `app/favicon.ico`    | 파비콘 자동 등록                              |\n| `app/robots.txt`    | 검색 엔진 크롤러에서 참고하는 robots 파일 자동 포함  |\n| `app/icon.svg`       | SVG 아이콘 자동 등록                            |\n\n따라서, 이런 파일들만 잘 관리해두면 `link` 태그를 따로 추가하거나 지저분하게 관리할 필요가 없답니다.\n\n---\n\n\u003e 🚀 **한가지 알아두면 좋은 점!**  \n\u003e Next.js의 이런 자동화 덕분에 앱 구조가 훨씬 깔끔하고 유지보수가 편해져요. 그리고 혹시 이런 메타데이터를 동적으로 변경하고 싶다면 Next.js 13부터 도입된 `metadata` API도 활용해보세요! 훨씬 더 편리하게 SEO 최적화가 가능합니다.\n\n궁금한 게 있으면 언제든지 물어봐 주세요! 😊\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 head 태그를 관리하는 새로운 방법, Metadata API에 대해 이야기해볼게요. 원래는 아래처럼 직접 `\u003chead\u003e` 태그 안에 title이나 meta를 적었었죠.\n\n```jsx\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    \u003chtml lang=\"en\"\u003e\n      \u003chead\u003e\n        \u003ctitle\u003eMy App\u003c/title\u003e\n        \u003cmeta name=\"description\" content=\"My App is a...\" /\u003e\n      \u003c/head\u003e\n      \u003cbody\u003e\n        \u003cdiv id=\"root\"\u003e{children}\u003c/div\u003e\n      \u003c/body\u003e\n    \u003c/html\u003e\n  )\n}\n```\n\n그런데 Next.js는 이제 Metadata API라는 깔끔한 방식을 제공합니다. 이걸 쓰면 메타데이터를 컴포넌트 바깥에 `export const metadata`로 분리할 수 있어요. 코드가 더 간결해지고, SEO 최적화나 공유할 때 이점도 커지죠:\n\n```tsx\nimport type { Metadata } from 'next'\n\nexport const metadata: Metadata = {\n  title: 'My App',\n  description: 'My App is a...',\n}\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    \u003chtml lang=\"en\"\u003e\n      \u003cbody\u003e\n        \u003cdiv id=\"root\"\u003e{children}\u003c/div\u003e\n      \u003c/body\u003e\n    \u003c/html\u003e\n  )\n}\n```\n\n이렇게 바꾸면 `head` 태그 자체는 선언하지 않고도 메타데이터가 Next.js에 의해 자동으로 관리되니까 훨씬 깔끔하고 유지보수도 쉽습니다. 그리고 나중에 동적으로 제목이나 설명을 바꾸고 싶을 때도 이 Metadata API가 더 편리해요.\n\n참고로, 이 방식은 `/app` 디렉토리를 사용하는 Next.js 13 이상에서 권장되는 최신 방법이라는 점 꼭 기억하세요! 만약 아직 `pages` 디렉토리를 쓰고 있다면 다음 업그레이드 때 도입해 보시면 좋을 것 같아요.\n\n요약하자면, Metadata API는 다음과 같은 장점이 있어요:\n\n| 장점            | 설명                                                         |\n|-----------------|--------------------------------------------------------------|\n| 코드 분리       | 메타데이터를 컴포넌트 코드에서 분리해 관리가 편리해짐          |\n| 자동 관리       | Next.js가 head 태그를 자동으로 처리해 실수를 줄임             |\n| SEO \u0026 공유 최적화 | SEO 관련 메타 정보와 소셜 미디어 공유 정보까지 쉽게 설정 가능  |\n| 타입 지원       | 타입스크립트 Metadata 타입 제공으로 안정성 증가               |\n\n이렇게 공식 문서를 따라가면 Next.js 프로젝트가 한층 더 체계적이고 깔끔해질 거예요! 꼭 한번 써보세요 :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 5단계: 진입점 페이지 만들기\n\nNext.js에서는 앱의 진입점을 만들 때 `page.tsx` 파일을 작성하는 식으로 선언해요. 이걸 Vite로 치환하면, 보통 `main.tsx` 파일이 진입점 역할을 하게 됩니다. 이번 단계에서는 여러분 앱의 진입점(첫 시작점)을 설정해볼 거예요.\n\n- `app` 디렉토리 안에 `[[...slug]]`라는 이름의 폴더를 생성하세요.\n\n여기서 잠깐! 우리가 이번 가이드에서 Next.js를 SPA(싱글 페이지 애플리케이션)처럼 사용하려고 하거든요. 그러려면 앱의 첫 페이지가 모든 가능한 경로를 받아서 처리해야 합니다. 그래서 `app` 디렉토리에 `[[...slug]]`라는 폴더를 만들어서, 어떤 경로든 이 폴더가 잡아내서 라우팅할 수 있도록 하는 거죠.\n\n---\n\n추가로 설명을 좀 하자면, Next.js에서는 `[[...slug]]`와 같은 경로 패턴이 \"캐치올(catch-all)\" 라우팅 기능을 의미해요. 쉽게 말해서, URL에 뭘 붙여도 다 여기서 받겠다는 뜻이죠. 그래서 SPA를 구현할 때 정말 유용합니다. Vite 같은 도구에서는 이런 라우팅을 직접 구현하거나 라이브러리를 붙여야 하는데, Next.js가 너무 잘해주는 부분이죠!\n\n---\n\n혹시 React Router를 써서 SPA를 만든다면, 이런 \"모든 경로를 캐치하는\" 룰을 `\u003cRoute path=\"*\"\u003e` 같은 식으로 걸어줄 수 있다는 점도 기억해 두세요. SPA의 핵심은 결국 한 페이지에서 모든 라우팅을 내부에서 다 처리하는 거니까요.\n\n---\n\n정리하자면:\n\n- `[[...slug]]` 폴더 생성 → Next.js의 캐치올 라우팅\n- SPA처럼 모든 경로를 한 페이지에서 처리\n- Vite는 `main.tsx`가 진입점\n\n이렇게 세팅하면 여러분 앱이 다양한 경로에서 잘 반응하는 싱글 페이지 앱이 되겠죠? 다음 단계도 같이 기대해 주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서는 폴더 구조가 라우트를 정의하는 중요한 역할을 해요. 여기서 소개한 `app/[[...slug]]` 디렉토리는 '옵셔널 캐치-올(optional catch-all)' 라우트 세그먼트라고 불려요. 쉽게 말하면, 이 폴더 안에 있는 페이지가 애플리케이션의 모든 경로를 잡아주도록 설정하는 거죠.\n\n### 직접 해보기\n`app/[[...slug]]` 안에 `page.tsx` 파일을 새로 만들고, 아래 내용을 넣어보세요:\n\n```tsx\nimport '../../index.css'\n\nexport function generateStaticParams() {\n  return [{ slug: [''] }]\n}\n\nexport default function Page() {\n  return '...' // 나중에 업데이트할 예정이에요\n}\n```\n\n- 여기서 `generateStaticParams` 함수는 빌드 시에 미리 정적 페이지를 생성하기 위한 파라미터를 반환해요. 예제에선 빈 slug 배열을 반환해서 기본 경로를 세팅하고 있어요.\n- `Page` 컴포넌트는 현재 그냥 문자열을 반환하는 기본 상태인데, 이후에 이 부분을 다양한 경로에 맞게 확장할 수 있습니다.\n\n\u003e 참고로, Next.js에서는 Page 컴포넌트 파일 이름에 `.js`, `.jsx`, `.tsx` 어떤 확장자든 사용할 수 있어요. 여러분이 편한 걸로 쓰면 됩니다!\n\n이렇게 설정하면, 어떤 URL로 접근하든 여기 있는 `page.tsx`가 먼저 실행되어서 복잡한 라우팅 처리를 중앙 집중화 할 때 유용해요. 예를 들어 블로그의 포스트 여러 개를 한 페이지 컴포넌트에서 처리한다든지 할 때 쓰이죠.\n\n---\n\n추가로 Tip!\n- `[...slug]`는 캐치-올 라우트(segment all)인데 필수로 하나 이상의 값이 있어야 합니다.\n- `[[...slug]]`는 옵셔널 캐치-올이라 slug가 없어도 이 라우트가 적용돼요.\n- 이렇게 라우트를 잡으면 동적 경로도 쉽게 만들 수 있어요.\n\nNext.js 라우팅 좀 더 편하게 하고 싶다면, 이런 옵셔널 캐치-올 라우트 구조를 꼭 알아두면 좋아요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 파일은 서버 컴포넌트(Server Component)예요. `next build` 명령어를 실행하면 이 파일은 미리 렌더링(prerendering)되어 정적인 자산(static asset)으로 만들어집니다. 즉, 동적 코드가 필요 없다는 뜻이죠.\n\n이 파일은 글로벌 CSS를 불러오고, `generateStaticParams` 함수에서는 오직 인덱스 경로인 `/` 하나만 정적으로 생성할 것이라고 알려줘요.\n\n그럼 이제 나머지 Vite 애플리케이션 부분을 클라이언트 전용(Client-only)으로 옮겨볼게요. 다음처럼 작성하면 Next.js에서 클라이언트 전용 컴포넌트를 쉽게 다룰 수 있어요.\n\n```jsx\n'use client'\n\nimport React from 'react'\nimport dynamic from 'next/dynamic'\n\nconst App = dynamic(() =\u003e import('../../App'), { ssr: false })\n\nexport function ClientOnly() {\n  return \u003cApp /\u003e\n}\n```\n\n여기서 핵심은 `dynamic` 함수를 쓰면서 `{ ssr: false }` 옵션을 넣는 부분이에요. 이걸 통해서 서버 사이드 렌더링(SSR)을 비활성화하고, 해당 컴포넌트를 클라이언트에서만 불러오도록 설정합니다. 보통 Vite처럼 클라이언트 전용 라이브러리를 사용할 때 이렇게 하면 에러 없이 잘 작동하죠.\n\n또, `'use client'` 디렉티브를 최상단에 넣는 것도 잊지 마세요. 이건 Next.js 13 버전부터 도입된 문법인데, 해당 파일이 클라이언트 컴포넌트임을 명시해줍니다.\n\n---\n\n**TIP**: 클라이언트 컴포넌트를 이렇게 분리해서 관리하면 서버 컴포넌트와 클라이언트 컴포넌트의 역할 분담이 명확해져서 유지보수도 훨씬 쉬워져요. 또한, 초기 페이지 로딩 속도도 더 좋아질 수 있으니 적극 추천합니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 파일은 `use client` 지시어로 정의된 클라이언트 컴포넌트입니다. 클라이언트 컴포넌트라도 Next.js에서는 처음에 서버에서 HTML로 프리렌더링한 후 클라이언트에 전달해요.\n\n하지만 클라이언트에서만 동작하는 애플리케이션을 만들고 싶다면, App 컴포넌트부터 시작해서 전체적으로 프리렌더링을 비활성화할 수 있어요. 이렇게 하면 서버에서는 HTML을 만들지 않고, 클라이언트에서만 렌더링하게 됩니다.\n\n```js\nconst App = dynamic(() =\u003e import('../../App'), { ssr: false })\n```\n\n위 코드에서 `dynamic`을 사용하여 App 컴포넌트를 불러오면서 `{ ssr: false }` 옵션을 줬는데요, 이 옵션이 서버 사이드 렌더링을 끄는 역할을 해요.\n\n그 다음에는 진입점(entrypoint) 페이지를 이제 이 동적으로 불러온 `App` 컴포넌트로 교체해주면 됩니다!\n\n\u003e 참고로, 클라이언트 전용 애플리케이션을 만들 때는 서버에서 처리할 필요가 없으니 이렇게 `ssr: false`를 설정하는 게 퍼포먼스 향상에도 도움이 돼요. 하지만 SEO가 중요한 페이지라면 신중하게 사용해야겠죠.  \n\n필요하면 아래처럼 진입점 페이지에서 바로 사용해보세요.\n\n```js\nimport dynamic from 'next/dynamic'\n\nconst App = dynamic(() =\u003e import('../../App'), { ssr: false })\n\nexport default function Page() {\n  return \u003cApp /\u003e\n}\n```\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js와 Vite에서 정적 이미지(import) 다루는 방법이 조금 달라요. Vite에서는 이미지를 import 하면, 프로덕션 빌드 시 이미지의 URL 문자열이 반환돼서 바로 img 태그의 src에 쓸 수 있죠.\n\n```js\nimport image from './img.png' // 빌드 후에는 '/assets/img.2d8efhg.png' 같은 URL이 됨\n\nexport default function App() {\n  return \u003cimg src={image} /\u003e\n}\n```\n\n근데 Next.js는 이런 식으로 바로 이미지 URL을 가져오는 게 아니라, `next/image` 컴포넌트를 이용해서 이미지 최적화 기능을 활용하도록 권장해요. 만약 그냥 정적 파일처럼 사용하고 싶으면 Next.js의 `public` 폴더에 이미지를 넣고 URL로 접근하는 게 가장 깔끔하답니다.\n\n예를 들어, `public/img.png`에 이미지를 넣었다면:\n\n```jsx\nexport default function App() {\n  return \u003cimg src=\"/img.png\" alt=\"example\" /\u003e\n}\n```\n\n아니면 Next.js의 Image 컴포넌트를 써서 자동으로 크기 조정, 최적화 기능을 쓰는 것도 좋아요:\n\n```jsx\nimport Image from 'next/image'\nimport img from '../public/img.png'\n\nexport default function App() {\n  return \u003cImage src={img} alt=\"example\" /\u003e\n}\n```\n\n이렇게 하면 이미지가 자동으로 최적화되고 레이지 로딩도 적용돼서 퍼포먼스에 유리해요.\n\n---\n\n\u003e **Tip!**  \n\u003e Next.js에서 이미지를 정적으로 import 하려면 `next.config.js`에서 `images` 설정을 잘 해줘야 하는 경우도 있어요. 그리고 외부 URL의 이미지를 쓰려면 도메인을 허용해줘야 하죠.  \n\u003e 이미지 최적화나 로딩 속도가 신경 쓰인다면 `next/image` 컴포넌트를 적극 활용해보세요!\n\n---\n\n결론적으로 Vite처럼 이미지 import 해서 바로 URL 받는 방식은 Next.js에선 조금 다르게 다뤄진다고 생각하면 돼요. 상황에 따라 `public` 폴더에 넣거나, `next/image`를 쓰는 두 가지 방법 중 선택하면 됩니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 이미지 파일을 정적으로 import하면, 이미지가 객체(object)로 반환돼요. 이 객체는 Next.js의 `Image` 컴포넌트에서 바로 사용할 수도 있고, 기존에 쓰던 `img` 태그에서는 이 객체의 `src` 속성만 꺼내서 쓸 수도 있답니다.\n\n`Image` 컴포넌트의 장점은 자동 이미지 최적화가 된다는 것! 그리고 이미지의 실제 크기를 기반으로 `width`, `height` 속성을 자동으로 넣어줘서 이미지가 로딩될 때 레이아웃이 갑자기 바뀌는 문제(layout shift)를 막아줘요. 다만 주의할 점은 이미지의 한 쪽 치수만 스타일링하고 다른 쪽은 auto로 두지 않으면, 그 치수가 `img` 태그에 자동으로 들어간 크기로 고정돼서 이미지가 왜곡될 수 있다는 거예요.\n\n그래서 기존 `img` 태그를 유지하면 코드 변경량도 줄일 수 있고, 위 문제도 피할 수 있죠. 나중에 필요하면 `Image` 컴포넌트로 단계별 마이그레이션을 할 수 있어요. 이때 직접 로더(loader)를 설정하거나, Next.js 기본 서버를 사용하면 자동 이미지 최적화를 편리하게 활용할 수 있답니다.\n\n끝으로 `/public` 폴더에서 절대경로로 이미지를 import했다면, 상대경로로 바꾸는 것도 잊지 마세요. 이렇게 하면 관리도 더 편해지고 빌드 과정에서 문제도 줄일 수 있어요!\n\n---\n\n### 정리\n\n| 방법                         | 장점                             | 주의 사항                              |\n|----------------------------|--------------------------------|-----------------------------------|\n| `Image` 컴포넌트 사용          | 자동 이미지 최적화, 레이아웃 안정성 확보     | 한쪽 치수만 스타일링 시 이미지 왜곡 가능성         |\n| 기존 `img` 태그 유지           | 코드 변경 최소화, 왜곡 문제 없음           | 이미지 최적화 기능은 직접 구현해야 함           |\n| `/public`에서 이미지 경로 변경  | 경로 관리 용이, 빌드 시 문제 감소         | 절대경로 -\u003e 상대경로 수정 필요               |\n\n---\n\n### 추가 팁: 이미지 최적화 옵션\nNext.js의 `Image` 컴포넌트는 기본적으로 자동 최적화를 지원하지만, 필요하면 `loader`를 정의해 좀 더 세밀한 설정도 가능해요. 예를 들어 외부 이미지 호스팅 서비스를 함께 쓸 때 유용하죠. 혹은 next.config.js에서 domains 옵션에 외부 도메인을 추가해주면, 더 다양한 이미지를 `Image` 컴포넌트로 불러올 수 있습니다.\n\n---\n\n필요에 따라 `Image` 컴포넌트의 장점과 한계를 잘 고려해서 사용하면, 퍼포먼스도 챙기고 개발도 부드럽게 할 수 있어요! 궁금한 점 있으면 언제든 질문 주세요~\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자바스크립트 코드에서 이미지 파일을 불러올 때 경로나 방식이 조금 바뀌면서 주의할 점들을 정리해봤어요.\n\n---\n\n### 1. 이미지 파일 import 경로 변경하기\n\n```js\n// 이전 방식\nimport logo from '/logo.png'\n\n// 변경된 방식\nimport logo from '../public/logo.png'\n```\n\n이전에는 루트부터 바로 경로를 지정했다면, 이제는 public 폴더를 기준으로 상대 경로를 명확히 써주는 게 좋아요. 그렇지 않으면 이미지가 제대로 불러와지지 않을 수도 있어요.\n\n---\n\n### 2. `img` 태그에 `src` 속성 넘길 때 주의하기\n\n```js\n// 이전 방식\n\u003cimg src={logo} /\u003e\n\n// 변경된 방식\n\u003cimg src={logo.src} /\u003e\n```\n\nimport 한 이미지 객체 전체를 `src`에 넘기면 안 되고, 그 안에 실제 URL이 담긴 `.src` 값을 넘겨줘야 이미지가 화면에 제대로 뜹니다.\n\n---\n\n### 3. 대안: 직접 public 폴더 경로 지정하기\n\n이미지 파일이 `public/logo.png`에 있다면, 그냥 `src=\"/logo.png\"`로 바로 작성해도 됩니다.\n\n```js\n\u003cimg src=\"/logo.png\" /\u003e\n```\n\n이렇게 작성하면 이미지가 `public` 폴더 안에서 찾아지게 되는데, 간단하게 이미지 경로를 관리할 수 있는 방법이기도 해요. 다만, 이 경우 import 없이 스트링 경로를 직접 넣는 형태라는 점 참고하세요.\n\n---\n\n### 추가 팁\n\n- 만약 프로젝트가 Next.js 같은 프레임워크라면 `public` 폴더의 파일은 빌드 시 그대로 공개 경로로 복사돼서 `/이미지이름`으로 접근 가능합니다.\n- 자주 사용하는 공용 이미지들은 `public` 폴더에 모아두는 게 관리도 편하고, 빌드에도 영향을 덜 주는 편이에요.\n- 상대 경로 작성 시 `..` 여러 개를 써야 할 때 헷갈리기 쉬우니, VS Code 같은 편집기의 경로 자동완성기능을 적극 활용하면 좋아요.\n\n---\n\n이제 이미지를 불러올 때 경로 문제로 에러 뜨는 일은 조금 줄어들 거예요! 자~ 다음 프로젝트 때 적용해 보세요. :)\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003e 경고: 만약 TypeScript를 사용 중이라면 src 속성에 접근할 때 타입 에러가 발생할 수 있어요. 지금은 무시해도 괜찮고, 이 가이드를 마칠 즈음에는 모두 해결될 테니 걱정 마세요.\n\n### 7단계: 환경 변수 마이그레이션하기\n\nNext.js도 Vite처럼 `.env` 파일을 통해 환경 변수를 관리할 수 있어요. 그런데 크게 차이나는 부분이 하나 있는데, 바로 클라이언트 쪽에서 노출되는 환경 변수에 붙는 접두사(prefix)에요.\n\n| Vite                  | Next.js              |\n|-----------------------|----------------------|\n| `VITE_` (접두사)       | `NEXT_PUBLIC_` (접두사) |\n\n즉, Vite에서 `VITE_`로 시작하는 환경 변수들은 Next.js에서는 `NEXT_PUBLIC_`로 바꿔줘야 클라이언트 사이드 코드에서 접근할 수 있어요. 예를 들어:\n\n```js\n# Vite 환경 변수\nVITE_API_URL=https://api.example.com\n```\n\n위 변수는 Next.js로 옮길 때 이렇게 바꿔줘야 해요:\n\n```js\n# Next.js 환경 변수\nNEXT_PUBLIC_API_URL=https://api.example.com\n```\n\n이걸 꼭 지켜야 클라이언트에서 `process.env.NEXT_PUBLIC_API_URL`로 안전하게 접근할 수 있어요. 만약 접두사를 안 바꾸면 클라이언트 쪽에 변수가 노출되지 않아서 참조할 수 없게 돼요.\n\n---\n\n**추가 팁!**  \n환경 변수를 사용할 때 중요한 건, 민감한 정보(ex: API 키, 비밀번호 등)는 절대 클라이언트에 노출시키면 안 돼요. `NEXT_PUBLIC_` 붙은 변수는 클라이언트에서 볼 수 있기 때문에, 민감 데이터를 담기엔 적합하지 않답니다. 서버 전용 변수는 접두사 없이 그냥 `process.env`에서 바로 사용하세요.\n\n---\n\n앞으로 계속 환경 변수를 변경하면서도, 변수 이름을 이렇게 맞춰주는 게 Next.js와 Vite를 함께 쓰거나 Next.js로 이전할 때 발생하는 흔한 실수 중 하나예요. 신경 써서 관리하면 빌드 문제나 런타임 오류를 줄일 수 있어요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nVite에서는 특별한 import.meta.env 객체를 통해 몇 가지 내장 환경 변수를 제공하는데, Next.js는 이 부분을 지원하지 않아요. 그래서 Vite에서 쓰던 환경 변수들을 Next.js에 맞게 이렇게 바꿔줘야 해요.\n\n| Vite (import.meta.env)       | Next.js (process.env)                  |\n|-----------------------------|--------------------------------------|\n| import.meta.env.MODE         | process.env.NODE_ENV                  |\n| import.meta.env.PROD         | process.env.NODE_ENV === 'production'|\n| import.meta.env.DEV          | process.env.NODE_ENV !== 'production'|\n| import.meta.env.SSR          | typeof window === 'undefined'        |\n\n여기서 살짝 팁을 드리자면, import.meta.env.SSR 은 서버 사이드 렌더링 여부를 체크하기 위한 변수인데, Next.js에서는 window 객체가 없으면 서버 환경으로 인식할 수 있으니 `typeof window === 'undefined'` 로 체크해주면 됩니다.\n\n그리고 한 가지 더! Next.js는 기본적으로 Vite에 있는 BASE_URL 같은 환경 변수를 제공하지 않아요. 하지만 직접 환경 변수를 만들어서 쓸 수는 있답니다. 방법은 간단해요, 프로젝트 루트에 `.env` 파일을 만들고 아래처럼 추가해주시면 됩니다.\n\n```js\nNEXT_PUBLIC_BASE_URL=https://your-domain.com\n```\n\n여기서 NEXT_PUBLIC_ 접두어는 Next.js에서 브라우저 코드에서도 접근할 수 있는 환경 변수를 의미해요. 만약 서버에서만 쓸 거라면 접두어 없이 그냥 선언하면 되고요.\n\n이렇게 하면 코드에서 `process.env.NEXT_PUBLIC_BASE_URL` 로 접근해서 사용할 수 있어요. 예를 들어 API 엔드포인트를 설정할 때 유용하답니다.\n\n정리하자면, Vite에서 Next.js로 넘어올 때 환경 변수 관련 코드를 이렇게 바꿔주시고, 필요한 환경 변수들은 직접 `.env` 파일에 추가해서 관리하시면 됩니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 기본 경로(basePath)를 환경 변수로 설정하는 방법에 대해 공유할게요. 프로젝트를 하다 보면 `basePath`를 동적으로 설정해야 할 경우가 있는데, 예를 들어 CDN이나 특정 경로에 배포할 때 유용하죠.\n\n### 1. `.env` 파일에 환경 변수 설정하기\n\n```js\nNEXT_PUBLIC_BASE_PATH=\"/some-base-path\"\n```\n\n여기서 중요한 점! `NEXT_PUBLIC_` 접두어로 시작해야 클라이언트 쪽에서도 접근 가능해요.\n\n### 2. `next.config.mjs` 파일에서 basePath 설정하기\n\n다음과 같이 `next.config.mjs`에 `basePath`를 환경 변수로 불러와 세팅해 주세요.\n\n```js\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  output: 'export',      // SPA 형태로 빌드\n  distDir: './dist',     // 빌드 결과물을 'dist' 폴더로 변경\n  basePath: process.env.NEXT_PUBLIC_BASE_PATH,   // env 변수를 basePath로 설정!\n}\n\nexport default nextConfig\n```\n\n\u003e TIP: `next.config.mjs`에서 import.meta.env 대신 `process.env`를 사용해야 하는 점 잊지 마세요. Next.js는 빌드 타임에 `process.env`로 환경 변수값을 주입합니다.\n\n### 3. 코드 내에서 `import.meta.env.BASE_URL` -\u003e `process.env.NEXT_PUBLIC_BASE_PATH`로 변경\n\n기존에 `import.meta.env.BASE_URL` 을 사용하던 부분이 있다면, `process.env.NEXT_PUBLIC_BASE_PATH`로 바꿔줘야 합니다. 이 부분은 Vite 등 다른 빌드 시스템과 차이가 있어요.\n\n```js\nconst basePath = process.env.NEXT_PUBLIC_BASE_PATH || ''\n\n// 사용 예\nconst fullUrl = `${basePath}/some-resource`\n```\n\n### 정리하자면\n\n| 단계               | 설명                                 |\n|-------------------|------------------------------------|\n| 1. env 파일 만들기    | `NEXT_PUBLIC_BASE_PATH` 설정          |\n| 2. next.config.mjs 수정 | `basePath`에 `process.env.NEXT_PUBLIC_BASE_PATH` 지정 |\n| 3. 코드 수정           | `import.meta.env.BASE_URL` → `process.env.NEXT_PUBLIC_BASE_PATH` |\n\n---\n\n이렇게 하면 빌드할 때마다 환경 변수로 기본 경로를 바꾸는 게 가능해져서 다양한 배포 환경에 유연하게 대응할 수 있습니다. Next.js 프로젝트 하면서 경로 문제에 한 번쯤 고민해보셨다면 참고하세요~! 필요하면 basePath 외에도 `assetPrefix`도 같이 고려하는 게 좋아요. 그럼 즐코딩~! 🚀\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 8단계: package.json 스크립트 업데이트하기\n\n이제 Next.js로 마이그레이션을 잘 했는지 확인하기 위해 애플리케이션을 실행해볼 수 있어요. 그런데 그 전에 package.json 안의 스크립트를 Next.js에 맞게 살짝 바꿔줘야 합니다. \n\n기존에 있던 start나 build 명령어 대신 Next.js 명령어를 넣어주면 되는데요:\n\n```json\n{\n  \"scripts\": {\n    \"dev\": \"next dev\",\n    \"build\": \"next build\",\n    \"start\": \"next start\"\n  }\n}\n```\n\n- `\"dev\"`: 개발 모드로 로컬 서버를 띄울 때 사용해요 (hot reload도 지원해서 개발할 때 편리해요)\n- `\"build\"`: 배포 전, 프로덕션용으로 최적화된 빌드를 생성할 때 쓰입니다.\n- `\"start\"`: 빌드된 결과물을 실제 서비스 환경에서 실행할 때 사용하죠.\n\n그리고 Git 관리할 때 필요 없는 파일들을 깃에서 제외하기 위하여 `.gitignore` 파일에도 다음 내용을 추가해주세요:\n\n\n.next\nnext-env.d.ts\ndist\n\n\n- `.next` 폴더는 Next.js가 빌드하면서 생성하는 임시파일들이라 보통 Git에 올리지 않아요.\n- `next-env.d.ts`는 Next.js 타입 지원을 위한 선언 파일로, 자동 생성되므로 따로 관리하지 않습니다.\n- `dist`는 프로젝트마다 다르지만, 빌드 후 결과를 담고 있는 폴더라면 역시 빼는 게 좋습니다.\n\n참고로, `.gitignore`에 이런 빌드 결과 파일들을 미리 넣어두면 협업할 때 불필요한 충돌도 줄일 수 있어요. 다음 단계에서는 이렇게 설정한 상태에서 실제로 `npm run dev` 명령어로 개발 서버를 실행해보면서 잘 작동하는지 확인해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 터미널에서 `npm run dev` 명령어를 실행하고, http://localhost:3000 에 접속해 보세요. 그러면 당신의 Next.js 애플리케이션이 잘 실행되고 있는 모습을 확인할 수 있을 거예요.\n\n\u003e 참고로, Vite로 만들어진 애플리케이션을 Next.js로 마이그레이션한 실제 예제를 보고 싶다면 이 [Pull Request](https://github.com/vercel/next.js/pull/####)를 확인해 보세요. (원문에 링크가 있다면 여기에 넣어주세요.)\n\n### 9단계: 정리하기\n\n이제 Vite 관련 파일들이나 설정들은 모두 정리할 차례입니다. 프로젝트에서 Vite와 관련된 불필요한 것들을 깔끔하게 제거해서 코드베이스를 정돈해 주세요!\n\n예를 들어, 다음과 같은 것들을 확인하시면 좋아요:\n\n| 제거 대상                     | 설명                              |\n|------------------------------|----------------------------------|\n| `vite.config.js`              | Vite 설정 파일                   |\n| `index.html`                  | Vite에서 사용했던 진입 HTML 파일 |\n| `package.json`의 Vite 관련 의존성 | `vite`, `@vitejs/plugin-react` 등 |\n| 기타 Vite 전용 스크립트       | 빌드 스크립트나 개발 서버 관련 설정 |\n\n이렇게 정리하고 나면 Next.js만 사용하는 깔끔한 환경을 만들 수 있습니다.\n\n---\n\n만약 다음 단계가 궁금하다면, Next.js의 배포나 최적화 방법 등을 함께 알아보는 것도 추천합니다. Next.js는 기본적으로 SSR(서버 사이드 렌더링)과 SSG(정적 사이트 생성), 그리고 CSR(클라이언트 사이드 렌더링)을 유연하게 사용할 수 있어서 애플리케이션을 더 빠르고 SEO 친화적으로 만들어 주거든요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- main.tsx 삭제  \n- index.html 삭제  \n- vite-env.d.ts 삭제  \n- tsconfig.node.json 삭제  \n- vite.config.ts 삭제  \n- Vite 관련 의존성 제거  \n\n## 다음 단계\n\n만약 지금까지 작업이 잘 됐다면, 이제 Next.js를 기반으로 동작하는 싱글 페이지 애플리케이션을 갖게 된 거예요. 하지만 아직 Next.js가 제공하는 많은 장점들을 완전히 활용하고 있진 않은 상태입니다. 이제부터 점진적으로 개선하면서 Next.js의 진가를 맛보실 수 있는데요, 다음 단계로 고려해볼 만한 사항들을 소개할게요:\n\n| 다음 단계 | 설명 |\n| --- | --- |\n| React Router에서 Next.js App Router로 마이그레이션 | - 자동 코드 분할로 초기 로딩 속도 개선\u003cbr\u003e- 스트리밍 서버 사이드 렌더링 지원\u003cbr\u003e- React 서버 컴포넌트 활용 가능 |\n| 이미지 최적화 | Next.js `Image` 컴포넌트로 자동 최적화된 이미지 제공 |\n| 폰트 최적화 | `next/font`를 활용해 폰트 로딩 속도 및 성능 개선 가능 |\n| 서드파티 스크립트 최적화 | Next.js `Script` 컴포넌트로 외부 스크립트 로딩 최적화 |\n| ESLint 설정 업데이트 | Next.js 규칙을 지원하도록 ESLint를 구성하여 코드 품질 유지 |\n\n---\n\n여기서 한 가지 팁을 추가하자면, Next.js의 App Router는 전통적인 React Router보다 많은 부분에서 성능과 개발 경험을 향상시키는데요. 특히 서버 컴포넌트(Server Components)를 적극 활용하면 클라이언트에서 불필요한 자바스크립트가 줄어들어 사용자 경험이 좋아집니다. 그리고 이미지나 폰트 최적화는 SEO와 사용자 경험에 직접적인 영향을 주기 때문에 꼭 챙겨보시길 추천드립니다!\n\n조금씩 바꾸면서 Next.js 애플리케이션의 진정한 잠재력을 느껴보세요. 궁금한 점이 있으면 언제든 질문해 주세요!","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":39},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch1\u003eVite에서 Next.js로 마이그레이션하는 방법\u003c/h1\u003e\n\u003cp\u003e안녕하세요! 오늘은 Vite로 만들어진 기존 프로젝트를 Next.js로 옮기는 방법에 대해 이야기해볼게요. 요새 React 생태계에서 Next.js가 워낙 대세라서요, 프로젝트 확장성이나 SEO 같은 부분 때문에 넘어가는 분들이 많더라고요.\u003c/p\u003e\n\u003ch2\u003e왜 굳이 Next.js로 갈아타야 할까?\u003c/h2\u003e\n\u003cp\u003e사실 Vite도 빠르고 사용하기 편한 툴인데, Next.js로 갈아타는 몇 가지 이유가 있거든요.\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e이유\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cstrong\u003e서버 사이드 렌더링(SSR)\u003c/strong\u003e\u003c/td\u003e\u003ctd\u003eNext.js는 기본적으로 SSR을 지원해서 SEO에 훨씬 유리해요. Vite는 클라이언트 렌더링에 초점이 맞춰져 있죠.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003cstrong\u003e파일 기반 라우팅\u003c/strong\u003e\u003c/td\u003e\u003ctd\u003eNext.js는 폴더 구조만 잘 맞추면 라우팅 설정이 자동으로 되어 개발 속도가 빨라져요. Vite는 라우터 설정을 직접 해줘야 하죠.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003cstrong\u003eAPI 라우트 지원\u003c/strong\u003e\u003c/td\u003e\u003ctd\u003eNext.js 내에서 API 엔드포인트를 쉽게 만들 수 있어 백엔드 \u0026#x26; 프론트엔드 통합이 편리해요. Vite는 보통 별도의 서버를 띄워야 해요.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003cstrong\u003e강력한 커뮤니티와 플러그인\u003c/strong\u003e\u003c/td\u003e\u003ctd\u003eNext.js는 많은 플러그인과 라이브러리가 있어서 생태계가 풍부하고, 지원도 활발해요.\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e사실 프로젝트 규모가 커지고, SEO가 중요해지고, 좀 더 안정적인 서버 사이드 렌더링이 필요하다면 Next.js는 거의 필수 선택지라고 할 수 있겠네요!\u003c/p\u003e\n\u003cp\u003e다음 포스팅에서는 실제로 Vite 프로젝트를 어떻게 Next.js 프로젝트로 옮길지, 단계별로 자세히 알려드릴게요. 기대해주세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch3\u003e느린 초기 페이지 로딩 시간\u003c/h3\u003e\n\u003cp\u003e만약 기본 Vite 플러그인으로 리액트 애플리케이션을 만들었다면, 여러분의 앱은 순수한 클라이언트 사이드 애플리케이션입니다. 이렇게 클라이언트 사이드에서만 앱을 실행하는 방식, 즉 흔히 싱글 페이지 애플리케이션(SPA)이라고 하죠. 이 방식은 보통 초기 페이지 로딩 속도가 느려지는 문제가 발생합니다. 왜 그런지 간단히 살펴볼게요.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e브라우저가 여러분의 리액트 코드와 전체 애플리케이션 번들을 내려받고 실행하기 전까지는 데이터 요청조차 시작할 수 없습니다.\u003c/li\u003e\n\u003cli\u003e시간이 지나면서 기능이 추가되고 의존성도 늘어나면서 애플리케이션 코드가 점점 커져서 더 오래 걸리게 됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e즉, 초기 로딩에 필요한 코드가 한 번에 너무 많아서 브라우저가 버거워하는 상황인 거죠.\u003c/p\u003e\n\u003ch3\u003e자동 코드 분할이 없다면?\u003c/h3\u003e\n\u003cp\u003e자동 코드 분할이란 쉽게 말해, 필요한 코드만 쪼개서 나중에 불러오는 걸 의미해요. 하지만 기본 설정으로 만든 Vite + React 프로젝트엔 이 기능이 적용되어 있지 않습니다. 그래서 앱 전체 코드를 한 번에 내려받아야 하죠.\u003c/p\u003e\n\u003cp\u003e자동 코드 분할이 없으면 다음과 같은 단점이 있어요.\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e문제점\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e초기 로딩 느림\u003c/td\u003e\u003ctd\u003e모든 코드가 한 번에 내려오니까 페이지가 뜨기까지 기다려야 하는 시간이 길어짐\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e불필요한 코드 다운로드\u003c/td\u003e\u003ctd\u003e현재 페이지에서 필요하지 않은 코드도 같이 받게 되어 네트워크 자원이 낭비됨\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e사용자 경험 저하\u003c/td\u003e\u003ctd\u003e로딩 시간이 길어지면 방문자가 페이지 이탈할 확률이 높아짐\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e자동 코드 분할을 도입하면 첫 페이지 로딩은 가볍게, 이후 필요한 기능은 필요한 순간에 불러올 수 있어 앱 속도가 체감상 빨라집니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e추가 팁: 해결책으로 SSG/SSR 도입하기\u003c/h3\u003e\n\u003cp\u003e초기 로딩 속도를 확실히 개선하고 싶다면, 서버 사이드 렌더링(SSR)이나 정적 사이트 생성(SSG)을 도입하는 것도 좋은 방법입니다. Next.js 같은 프레임워크는 기본적으로 이 기능들을 지원해요. 요청 시 서버에서 미리 렌더링된 HTML을 보내면 브라우저가 JS 실행을 기다리지 않아도 빠르게 페이지를 보여줄 수 있죠.\u003c/p\u003e\n\u003cp\u003e단, SSR/SSG는 설정이 좀 더 복잡할 수 있으니 상황과 요구에 맞게 도입하면 됩니다.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e이처럼 리액트 앱 개발할 때 초기 로딩 속도 문제는 SPA의 흔한 고민이고, 자동 코드 분할 또는 SSR/SSG 같은 기술을 적절히 적용하면 훨씬 개선할 수 있어요. 앞으로 프로젝트에 적용해 보면서 체감 성능을 경험해보시길 바랍니다!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이전 글에서 언급한 느린 로딩 문제는 코드 스플리팅(code splitting)으로 어느 정도 해결할 수 있어요. 그런데 직접 수동으로 코드 스플리팅을 하려고 하면 오히려 성능이 더 안 좋아질 수도 있어요. 수동으로 코드를 나누다 보면 네트워크 워터폴(Network waterfalls, 요청이 순차적으로 쌓여서 느려지는 현상)이 쉽게 발생할 수 있거든요. 다행히 Next.js는 자체 라우터에 자동 코드 스플리팅 기능이 내장되어 있어서 이런 문제를 훨씬 간편하게 해결할 수 있어요.\u003c/p\u003e\n\u003ch3\u003e네트워크 워터폴(Network waterfalls)이란?\u003c/h3\u003e\n\u003cp\u003e네트워크 워터폴은 애플리케이션이 클라이언트와 서버 사이에서 순차적으로 여러 데이터를 요청할 때 발생하는 성능 저하 현상이에요. SPA(싱글 페이지 애플리케이션)에서 데이터를 받아올 때 주로, 처음에는 로딩용 자리 표시자(placeholder)를 렌더링하고, 컴포넌트가 마운트된 후에야 데이터를 받아오는 패턴이 많죠. 이 경우 하위 컴포넌트가 데이터를 요청하려면, 반드시 상위 컴포넌트가 자신의 데이터를 모두 받은 뒤여야 해서 대기시간이 길어질 수밖에 없습니다.\u003c/p\u003e\n\u003cp\u003eNext.js는 클라이언트에서 데이터를 받아오는 것도 지원하지만, 데이터 페칭을 서버 사이드에서 처리하게끔 선택할 수도 있어요. 서버에서 데이터를 미리 받아서 렌더링하면 이런 클라이언트-서버 워터폴 현상을 완전히 없앨 수 있답니다.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e마치면서 한 가지 팁!\u003cbr\u003e\n서버 사이드 렌더링(SSR)이나 SSG(정적 사이트 생성)를 활용하면, 페이지 렌더링 전에 데이터를 미리 받아오기 때문에 사용자 입장에서 훨씬 빠른 초기 로딩을 경험할 수 있어요. Next.js의 \u003ccode\u003egetServerSideProps\u003c/code\u003e나 \u003ccode\u003egetStaticProps\u003c/code\u003e 같은 함수들이 그 역할을 하니, 꼭 활용해보세요!\u003c/p\u003e\n\u003chr\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e개념\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e코드 스플리팅\u003c/td\u003e\u003ctd\u003e자바스크립트 코드를 여러 덩어리로 나누어 필요한 부분만 불러와 초기 로딩 속도를 개선하는 방법\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e네트워크 워터폴\u003c/td\u003e\u003ctd\u003e클라이언트와 서버가 요청을 연속적으로 주고받아서 응답시간이 길어지는 현상\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eNext.js 자동 코드 스플리팅\u003c/td\u003e\u003ctd\u003eNext.js의 라우터가 페이지별로 자동으로 코드 스플리팅을 해주어 성능 최적화를 돕는 기능\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e서버 사이드 데이터 페칭\u003c/td\u003e\u003ctd\u003eNext.js가 페이지 렌더링 전에 서버에서 데이터를 미리 받아와 클라이언트-서버 간 요청 지연 문제를 해결하는 방식\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e필요하면 다음 글에서 Next.js의 데이터 페칭 방법과 활용법도 자세히 알려드릴게요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch3\u003e빠르고 의도적인 로딩 상태 관리\u003c/h3\u003e\n\u003cp\u003eReact Suspense가 스트리밍을 기본적으로 지원하면서, 어떤 UI 부분을 먼저 로딩할지, 또 어떤 순서로 로딩할지 더 세심하게 설계할 수 있게 되었습니다. 덕분에 네트워크 워터폴(waterfall) 현상을 피할 수 있죠.\u003c/p\u003e\n\u003cp\u003e네트워크 워터폴이란, 한 요청이 끝나야 다음 요청이 시작되는 상황을 말하는데, 이게 계속 쌓이면 로딩 속도가 느려져 사용자 경험이 떨어집니다. Suspense를 사용하면 여러 컴포넌트를 병렬로 로딩하면서도 사용자에게 매끄럽게 보여줄 수 있어서, 페이지 로딩 속도도 빨라지고 레이아웃이 불안정하게 변하는 문제(layout shift)도 줄일 수 있습니다.\u003c/p\u003e\n\u003ch3\u003e데이터 패칭(가져오기) 전략 선택하기\u003c/h3\u003e\n\u003cp\u003e내가 배운 바로는, 데이터 패칭 전략을 잘 선택하는 게 매우 중요해요. 예를 들어, 모든 데이터를 한 번에 가져오느냐, 필요한 데이터만 나눠서 가져오느냐에 따라 성능과 사용자 경험이 확 달라집니다.\u003c/p\u003e\n\u003cp\u003e아래 표는 다양한 데이터 패칭 전략과 그 특징을 간단히 정리한 거예요.\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e전략\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003cth\u003e장점\u003c/th\u003e\u003cth\u003e단점\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e전체 데이터 한 번에 로드\u003c/td\u003e\u003ctd\u003e페이지 로드 시 모든 데이터를 한꺼번에 요청\u003c/td\u003e\u003ctd\u003e초기 로딩 후 빠른 탐색 가능\u003c/td\u003e\u003ctd\u003e초기 로딩 시간 길어짐\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e필요한 데이터만 나눠서 로드\u003c/td\u003e\u003ctd\u003e필요한 부분만 요청, 점진적 로딩 지원\u003c/td\u003e\u003ctd\u003e빠른 초기 로딩, 네트워크 부하 분산\u003c/td\u003e\u003ctd\u003e구현 복잡도 증가\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e캐싱 활용\u003c/td\u003e\u003ctd\u003e요청한 데이터를 캐싱하여 재사용\u003c/td\u003e\u003ctd\u003e불필요한 중복 요청 방지\u003c/td\u003e\u003ctd\u003e데이터 최신성 관리 필요\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e스트리밍\u003c/td\u003e\u003ctd\u003eReact Suspense와 함께 스트리밍 데이터 로딩 활용\u003c/td\u003e\u003ctd\u003e사용자에게 빠르게 부분 렌더링 가능\u003c/td\u003e\u003ctd\u003e서버 및 클라이언트 세팅 복잡\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e특히 React Suspense와 같은 최신 기능들을 활용하면, 스트리밍 방식으로 데이터를 점진적으로 받아오면서 사용자에게 빠른 피드백을 줄 수 있어요. 개발자로서 이런 점들을 염두에 두면, 퍼포먼스 좋은 앱을 만드는 데 큰 도움이 됩니다.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e궁금한 점 있으면 언제든 댓글로 남겨주세요! 앞으로도 이런 실용적인 개발 팁들을 계속 공유할게요 :)\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eNext.js는 상황에 맞게 페이지나 컴포넌트 단위로 데이터 가져오기 전략을 선택할 수 있도록 유연성을 제공합니다. 예를 들어, 빌드 시점에 데이터를 가져와서 CMS에 있는 블로그 포스트를 렌더링하고, 이를 CDN에 캐시해서 빠르게 서비스할 수 있어요. 또는 서버 요청 시점이나 클라이언트에서 데이터를 받아서 동적으로 처리할 수도 있죠. 이렇게 상황에 따라 가장 적합한 방식을 선택할 수 있다는 게 Next.js의 큰 장점 중 하나랍니다.\u003c/p\u003e\n\u003ch3\u003e미들웨어 (Middleware)\u003c/h3\u003e\n\u003cp\u003eNext.js의 미들웨어는 서버에서 요청이 완료되기 전에 코드를 실행할 수 있도록 해줍니다. 예를 들어, 로그인해야 볼 수 있는 페이지에 사용자가 접근했을 때, 잠깐 인증이 안 된 페이지가 보이는 ‘깜빡임(flash)’ 현상을 막고 바로 로그인 페이지로 리다이렉트할 수 있어요. 이 외에도 새로운 기능을 실험해보거나, 다국어 지원 같은 국제화 작업에 아주 유용하죠. 미들웨어가 있다 보니 이런 작업들이 좀 더 자연스럽고 효율적으로 처리됩니다.\u003c/p\u003e\n\u003ch3\u003e내장 최적화 기능\u003c/h3\u003e\n\u003cp\u003eNext.js는 개발자가 따로 신경 쓰지 않아도 자동으로 여러 최적화를 수행합니다. 예를 들어, 이미지 최적화, 번들 크기 최소화, 코드 스플리팅, 그리고 사전 렌더링 같은 기능들이 모두 내장되어 있어요. 특히 이미지 최적화는 웹 페이지 로딩 속도를 크게 높여주니, 사용자 경험 개선에 큰 효과가 있답니다. 덕분에 복잡한 설정 없이도 빠르고 효율적인 웹사이트를 만들 수 있어요.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003eNext.js를 처음 접하는 분들은 이런 데이터 페칭과 미들웨어, 그리고 최적화 기능들이 어떻게 연결되는지 이해하는 게 중요해요. 다양한 상황에 맞게 전략을 골라 사용하면 사이트 성능을 최대로 끌어올릴 수 있으니까요! 만약 이 부분들이 더 궁금하다면 다음 포스트에서 각 전략별 예제와 함께 자세히 설명해볼게요 :)\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이미지, 폰트, 그리고 서드파티 스크립트는 애플리케이션 성능에 꽤 큰 영향을 줘요. 다행히 Next.js에는 이런 요소들을 자동으로 최적화해주는 내장 컴포넌트들이 있어서 성능 관리를 훨씬 쉽게 해줍니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003e마이그레이션 단계\u003c/h2\u003e\n\u003cp\u003e이번 마이그레이션 목표는 최대한 빠르게 Next.js 기반의 작동하는 애플리케이션을 만드는 거예요. 그 후에 필요에 따라 Next.js의 여러 기능을 차근차근 적용해 나가면 돼요. 처음에는 기존 라우터를 그대로 두고, 순수 클라이언트 사이드 애플리케이션(SPA)으로만 유지하는 방식으로 진행할 거예요. 이렇게 하면 마이그레이션 중에 발생할 수 있는 문제나 병합 충돌을 최소화할 수 있습니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e1단계: Next.js 의존성 설치하기\u003c/h3\u003e\n\u003cp\u003e마이그레이션의 첫걸음은 Next.js 패키지를 프로젝트에 추가하는 것부터 시작합니다. 이 부분은 기본 중의 기본이니까 꼼꼼하게 설치해 주세요! 다음 명령어를 터미널에 입력하면 됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003enpm install next react react-dom\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e또는 yarn을 사용한다면,\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003eyarn add next react react-dom\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 하면 Next.js가 필요로 하는 핵심 라이브러리들이 프로젝트에 추가됩니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e참고로, Next.js는 React 기반 프레임워크라 React와 ReactDOM도 함께 설치해야 해요. 이미 설치되어 있다면 중복 설치가 되지 않으니 걱정하지 않아도 됩니다!\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e설치가 완료됐으면, 다음 단계로 넘어가서 실제로 Next.js 프로젝트 구조에 맞게 파일들을 조금씩 정리해보도록 할게요.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e먼저, Next.js를 사용하기 위해서는 프로젝트에 Next를 의존성으로 설치해야 해요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003enpm install next@latest\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e2단계: Next.js 설정 파일 만들기\u003c/h3\u003e\n\u003cp\u003e프로젝트 루트에 \u003ccode\u003enext.config.mjs\u003c/code\u003e 파일을 만들어주세요. 이 파일은 Next.js의 다양한 설정 옵션들을 담고 있어요.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e참고로 이 설정 파일은 JavaScript나 TypeScript 파일처럼 동작하지만, \u003ccode\u003e.mjs\u003c/code\u003e 확장자를 사용하면 ES 모듈 방식을 명확히 하게 돼서 최근 Next.js 프로젝트에서 권장되고 있답니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e필요한 설정들을 여기서 자유롭게 추가해서 프로젝트 요구사항에 맞게 조절해보세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e자, 이번에는 Next.js 설정 파일을 조금 바꿔볼게요! 위 예제 코드는 \u003ccode\u003enext.config.js\u003c/code\u003e 파일에 들어갈 내용인데요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e/** \u003cspan class=\"hljs-doctag\"\u003e@type\u003c/span\u003e {\u003cspan class=\"hljs-type\"\u003eimport('next').NextConfig\u003c/span\u003e} */\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e nextConfig = {\n  \u003cspan class=\"hljs-attr\"\u003eoutput\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'export'\u003c/span\u003e,    \u003cspan class=\"hljs-comment\"\u003e// 이 설정은 Next.js를 SPA(단일 페이지 애플리케이션)로 내보내도록 해줘요.\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003edistDir\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'./dist'\u003c/span\u003e,   \u003cspan class=\"hljs-comment\"\u003e// 빌드 결과물을 기본 폴더가 아닌 './dist' 폴더에 저장해요.\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e nextConfig\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e참고로, Next.js 설정 파일은 \u003ccode\u003e.js\u003c/code\u003e 뿐만 아니라 \u003ccode\u003e.mjs\u003c/code\u003e 확장자를 써도 무방해요. 그래서 프로젝트 스타일에 맞게 골라 쓰시면 됩니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e그리고 이제 TypeScript를 쓰는 분들은 tsconfig.json 파일을 수정해줘야 해요! Next.js와 호환되게끔 일부 설정을 바꿔줘야 하거든요. 만약 TypeScript를 쓸 필요가 없다면 이 부분은 건너뛰셔도 되니까 부담 갖지 마세요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003eTypeScript 사용자라면 tsconfig.json 수정하는 팁!\u003c/h3\u003e\n\u003cp\u003eNext.js는 TypeScript를 공식 지원하지만, 기본 설정이 Next.js 빌드 시스템에 맞게끔 커스텀 필요가 있어요. 보통은 다음과 같이 \u003ccode\u003ecompilerOptions\u003c/code\u003e와 같이 설정합니다:\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e옵션\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ejsx\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eReact JSX 변환 설정 (예: \u003ccode\u003e\"react-jsx\"\u003c/code\u003e)\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003emodule\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e모듈 시스템 (주로 \u003ccode\u003e\"esnext\"\u003c/code\u003e 사용)\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003etarget\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e컴파일 타겟팅 자바스크립트 버전\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003estrict\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e엄격한 타입 체크 설정\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ebaseUrl\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e절대 경로 기준 디렉토리\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003epaths\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e모듈 경로 별칭 설정\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e예를 들어, tsconfig.json에 다음처럼 넣으면 더 편리하답니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-json\"\u003e\u003cspan class=\"hljs-punctuation\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003e\"compilerOptions\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-punctuation\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003e\"target\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"es5\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003e\"lib\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-punctuation\"\u003e[\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"dom\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"dom.iterable\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"esnext\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e]\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003e\"allowJs\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003e\u003cspan class=\"hljs-keyword\"\u003etrue\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003e\"skipLibCheck\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003e\u003cspan class=\"hljs-keyword\"\u003etrue\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003e\"strict\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003e\u003cspan class=\"hljs-keyword\"\u003etrue\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003e\"forceConsistentCasingInFileNames\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003e\u003cspan class=\"hljs-keyword\"\u003etrue\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003e\"noEmit\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003e\u003cspan class=\"hljs-keyword\"\u003etrue\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003e\"esModuleInterop\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003e\u003cspan class=\"hljs-keyword\"\u003etrue\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003e\"module\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"esnext\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003e\"moduleResolution\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"node\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003e\"resolveJsonModule\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003e\u003cspan class=\"hljs-keyword\"\u003etrue\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003e\"isolatedModules\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003e\u003cspan class=\"hljs-keyword\"\u003etrue\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003e\"jsx\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"react-jsx\"\u003c/span\u003e\n  \u003cspan class=\"hljs-punctuation\"\u003e}\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003e\"include\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-punctuation\"\u003e[\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"next-env.d.ts\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"**/*.ts\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"**/*.tsx\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e]\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003e\"exclude\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-punctuation\"\u003e[\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"node_modules\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e]\u003c/span\u003e\n\u003cspan class=\"hljs-punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 하면 Next.js에서 TypeScript를 더 원활하게 사용할 수 있답니다. 더 궁금하면 언제든 물어봐 주세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eTypeScript 설정을 하면서 다음과 같은 변경사항을 적용해봤어요.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003etsconfig.node.json\u003c/code\u003e 프로젝트 참조 제거\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003einclude\u003c/code\u003e 배열에 \u003ccode\u003e./dist/types/**/*.ts\u003c/code\u003e 와 \u003ccode\u003e./next-env.d.ts\u003c/code\u003e 추가\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eexclude\u003c/code\u003e 배열에 \u003ccode\u003e./node_modules\u003c/code\u003e 추가\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ecompilerOptions\u003c/code\u003e의 \u003ccode\u003eplugins\u003c/code\u003e 배열에 \u003ccode\u003e\"name\": \"next\"\u003c/code\u003e 추가\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eesModuleInterop\u003c/code\u003e을 \u003ccode\u003etrue\u003c/code\u003e로 설정\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ejsx\u003c/code\u003e를 \u003ccode\u003e\"preserve\"\u003c/code\u003e로 설정\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eallowJs\u003c/code\u003e를 \u003ccode\u003etrue\u003c/code\u003e로 설정\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eforceConsistentCasingInFileNames\u003c/code\u003e를 \u003ccode\u003etrue\u003c/code\u003e로 설정\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eincremental\u003c/code\u003e을 \u003ccode\u003etrue\u003c/code\u003e로 설정\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e아래는 이렇게 수정된 \u003ccode\u003etsconfig.json\u003c/code\u003e 예시입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-json\"\u003e\u003cspan class=\"hljs-punctuation\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003e\"compilerOptions\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-punctuation\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003e\"target\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"ES2020\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003e\"useDefineForClassFields\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003e\u003cspan class=\"hljs-keyword\"\u003etrue\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003e\"lib\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-punctuation\"\u003e[\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"ES2020\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"DOM\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"DOM.Iterable\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e]\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003e\"module\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"ESNext\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003e\"esModuleInterop\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003e\u003cspan class=\"hljs-keyword\"\u003etrue\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003e\"skipLibCheck\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003e\u003cspan class=\"hljs-keyword\"\u003etrue\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003e\"moduleResolution\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"bundler\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003e\"allowImportingTsExtensions\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003e\u003cspan class=\"hljs-keyword\"\u003etrue\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003e\"resolveJsonModule\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003e\u003cspan class=\"hljs-keyword\"\u003etrue\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003e\"isolatedModules\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003e\u003cspan class=\"hljs-keyword\"\u003etrue\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003e\"noEmit\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003e\u003cspan class=\"hljs-keyword\"\u003etrue\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003e\"jsx\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"preserve\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003e\"strict\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003e\u003cspan class=\"hljs-keyword\"\u003etrue\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003e\"noUnusedLocals\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003e\u003cspan class=\"hljs-keyword\"\u003etrue\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003e\"noUnusedParameters\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003e\u003cspan class=\"hljs-keyword\"\u003etrue\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003e\"noFallthroughCasesInSwitch\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003e\u003cspan class=\"hljs-keyword\"\u003etrue\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003e\"allowJs\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003e\u003cspan class=\"hljs-keyword\"\u003etrue\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003e\"forceConsistentCasingInFileNames\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003e\u003cspan class=\"hljs-keyword\"\u003etrue\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003e\"incremental\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003e\u003cspan class=\"hljs-keyword\"\u003etrue\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003e\"plugins\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-punctuation\"\u003e[\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e{\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e\"name\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"next\"\u003c/span\u003e \u003cspan class=\"hljs-punctuation\"\u003e}\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e]\u003c/span\u003e\n  \u003cspan class=\"hljs-punctuation\"\u003e}\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003e\"include\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-punctuation\"\u003e[\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"./src\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"./dist/types/**/*.ts\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"./next-env.d.ts\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e]\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003e\"exclude\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-punctuation\"\u003e[\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"./node_modules\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e]\u003c/span\u003e\n\u003cspan class=\"hljs-punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003cp\u003e조금 더 풀어 이야기하자면,\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eesModuleInterop: true\u003c/code\u003e는 CommonJS 모듈과 ES 모듈 간의 호환성을 좋게 해줍니다. 그래서 \u003ccode\u003eimport\u003c/code\u003e 구문을 쓸 때 오류를 줄여줘요.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ejsx: \"preserve\"\u003c/code\u003e는 JSX를 컴파일하지 않고 그대로 두라는 뜻인데, Next.js가 자체적으로 처리하기 때문에 이렇게 해주는게 일반적이에요.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eallowJs: true\u003c/code\u003e를 켜면 자바스크립트 파일도 TS 빌드 대상에 포함할 수 있어서, 점진적으로 타입스크립트로 이전하려는 프로젝트에서 유용합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eforceConsistentCasingInFileNames: true\u003c/code\u003e 설정은 대소문자 차이로 생기는 파일 경로 문제를 예방해줍니다. 특히 OS마다 대소문자 구분이 다른 경우에 꼭 필요해요.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eincremental: true\u003c/code\u003e는 빌드 속도를 향상시키기 위해 이전 빌드 정보를 캐싱해주는 기능입니다. 개발할 때 시간 절약에 큰 도움이 돼요.\u003c/li\u003e\n\u003cli\u003e플러그인에 \u003ccode\u003e\"name\": \"next\"\u003c/code\u003e를 넣으면 Next.js에서 권장하는 타입스크립트 플러그인을 사용하게 됩니니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eNext.js 공식 문서에도 TypeScript 구성에 대한 좋은 안내가 있으니, 필요하면 꼭 참고해보세요.\u003cbr\u003e\n\u003ca href=\"https://nextjs.org/docs/basic-features/typescript\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://nextjs.org/docs/basic-features/typescript\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e이 설정을 기반으로 프로젝트를 구성하면 Next.js + TypeScript 환경에서 좀 더 편리하고 안정적으로 개발하실 수 있습니다!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch3\u003e4단계: 루트 레이아웃 만들기\u003c/h3\u003e\n\u003cp\u003eNext.js의 App Router를 사용할 때는 루트 레이아웃(root layout) 파일이 꼭 필요해요. 이 파일은 React Server Component로, 여러분의 앱 안에 있는 모든 페이지를 감싸는 역할을 하죠. 그리고 이 파일은 \u003ccode\u003eapp\u003c/code\u003e 디렉토리의 최상단에 위치해야 합니다.\u003c/p\u003e\n\u003cp\u003e비슷한 개념을 Vite 앱에서 찾자면, 바로 \u003ccode\u003eindex.html\u003c/code\u003e 파일이에요. 이 파일이 여러분의 HTML, head, body 태그를 포함하고 있어서, Next.js에서 말하는 루트 레이아웃과 가장 비슷한 역할을 하죠.\u003c/p\u003e\n\u003cp\u003e이번 단계에서는 여러분의 \u003ccode\u003eindex.html\u003c/code\u003e 파일을 Next.js의 루트 레이아웃 파일로 변환해볼 거예요.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e여기서 꼭 짚고 넘어갈 점은 Next.js에서는 이 루트 레이아웃이 React 컴포넌트라는 거예요. 단순히 HTML 파일이 아니라 리액트 컴포넌트로 작성되니, 필요한 경우 React의 훅이나 다른 컴포넌트로 기능 확장이 훨씬 쉬워요. 즉, 더 동적이고 유연한 레이아웃 구성이 가능하다는 거죠.\u003c/p\u003e\n\u003cp\u003e그럼 이제 \u003ccode\u003eindex.html\u003c/code\u003e에서 어떤 부분을 어떻게 바꿔주면 될지 살펴볼게요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이번에는 Next.js 프로젝트에서 새로운 앱 디렉토리를 만들고, 레이아웃 설정을 하는 방법을 알려드릴게요. 특히 Next.js 13 버전에서 도입된 '새로운 app 디렉토리 구조'를 활용하는 예제인데요, 코드 설명도 곁들여서 천천히 같이 보시죠!\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e1. \u003ccode\u003esrc\u003c/code\u003e 안에 \u003ccode\u003eapp\u003c/code\u003e 디렉토리 만들기\u003c/h3\u003e\n\u003cp\u003e먼저, 프로젝트 폴더 안 \u003ccode\u003esrc\u003c/code\u003e 디렉토리 안에 \u003ccode\u003eapp\u003c/code\u003e 폴더를 새로 만들어줘요. 여기서부터 우리 앱의 페이지, 레이아웃 등이 관리될 거예요.\u003c/p\u003e\n\u003cp\u003esrc/\n└── app/\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e2. \u003ccode\u003eRootLayout\u003c/code\u003e 컴포넌트 만들기 (\u003ccode\u003elayout.tsx\u003c/code\u003e)\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eapp\u003c/code\u003e 폴더 안에 \u003ccode\u003elayout.tsx\u003c/code\u003e 파일을 하나 새로 만들어요. 이 파일은 페이지들의 공통 레이아웃을 담당합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-tsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eRootLayout\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{\n  children,\n}: {\n  children: React.ReactNode\n}\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'...'\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003echildren\u003c/code\u003e은 이 레이아웃 안에 렌더링될 페이지나 하위 컴포넌트들을 의미해요.\u003c/li\u003e\n\u003cli\u003e중요! \u003ccode\u003elayout.tsx\u003c/code\u003e 같은 레이아웃 파일 확장자는 \u003ccode\u003e.js\u003c/code\u003e, \u003ccode\u003e.jsx\u003c/code\u003e, \u003ccode\u003e.tsx\u003c/code\u003e 중 원하시는 걸로 써도 된답니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3\u003e3. 기존 \u003ccode\u003eindex.html\u003c/code\u003e 내용을 \u003ccode\u003eRootLayout\u003c/code\u003e 안에 넣기\u003c/h3\u003e\n\u003cp\u003e보통 React 프로젝트에는 \u003ccode\u003epublic/index.html\u003c/code\u003e 파일이 있는데요, 여기에는 \u003ccode\u003e\u0026#x3C;body\u003e\u0026#x3C;div id=\"root\"\u003e\u0026#x3C;/div\u003e\u0026#x3C;/body\u003e\u003c/code\u003e 같은 구조가 있어요. 이것을 Next.js의 레이아웃 컴포넌트에 맞게 바꿔줘야 해요.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ebody\u003c/code\u003e 안의 \u003ccode\u003e\u0026#x3C;div id=\"root\"\u003e\u0026#x3C;/div\u003e\u003c/code\u003e 대신에 JSX 문법을 사용해서 \u003ccode\u003e\u0026#x3C;div id=\"root\"\u003e{children}\u0026#x3C;/div\u003e\u003c/code\u003e 식으로 바꿔줍니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026#x3C;script\u003e\u003c/code\u003e 태그나 직접적으로 body 바로 아래에 있는 태그들은 Next.js의 자동 렌더링 및 페이지 컴포넌트 구조에서 관리하니 제거하거나 옮겨줘야 해요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e아래처럼 작성할 수 있겠죠?\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-tsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eRootLayout\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{ children }: { children: React.ReactNode }\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ehtml\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ehead\u003c/span\u003e\u003e\u003c/span\u003e\n        {/* 여기에 메타 태그, 폰트 링크 등 head 요소를 넣어줄 수 있어요 */}\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ehead\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebody\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"root\"\u003c/span\u003e\u003e\u003c/span\u003e{children}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebody\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ehtml\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch3\u003e잠깐, 여기서 팁!\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eNext.js 13부터는 \u003ccode\u003eapp\u003c/code\u003e 디렉토리 내에서 레이아웃 또는 페이지가 기본적으로 서버 컴포넌트(Server Component)로 동작해요.\u003c/li\u003e\n\u003cli\u003e따라서 클라이언트 사이드 상태 관리 등이 필요하면 \u003ccode\u003e'use client'\u003c/code\u003e를 꼭 넣어줍니다.\u003c/li\u003e\n\u003cli\u003e그리고 기존에 \u003ccode\u003e\u0026#x3C;div id=\"root\"\u003e\u003c/code\u003e를 React 엔트리포인트로만 사용했던 것과 달리, Next.js에서는 \u003ccode\u003eapp\u003c/code\u003e 구조가 페이지마다 분리돼서 더 깔끔하고 모듈화된 방식으로 관리돼요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e요약하자면:\u003cbr\u003e\n\u003ccode\u003esrc/app/layout.tsx\u003c/code\u003e를 만들고, 기존 HTML 구조를 이 안에 JSX로 옮기면서 \u003ccode\u003e\u0026#x3C;div id=\"root\"\u003e{children}\u0026#x3C;/div\u003e\u003c/code\u003e 형태로 바꿔주면 이제 Next.js 13 스타일의 앱 레이아웃 설정이 끝! 앞으로 페이지 컴포넌트도 이 안에서 자연스럽게 렌더링 될 거예요.\u003c/p\u003e\n\u003cp\u003e궁금한 점 있으면 편하게 물어봐 주세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eNext.js를 사용하다 보면, 기본적으로 \u003ccode\u003e\u0026#x3C;head\u003e\u003c/code\u003e에 들어가는 \u003ccode\u003emeta charset\u003c/code\u003e이나 \u003ccode\u003emeta viewport\u003c/code\u003e 태그가 자동으로 포함되어 있다는 점을 알게 될 거예요. 그래서 직접 이런 태그들을 작성할 필요가 없답니다! 조금 더 깔끔하고 관리하기 편하게 아래처럼 수정할 수 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eRootLayout\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{\n  children,\n}: {\n  children: React.ReactNode\n}\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ehtml\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003elang\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"en\"\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ehead\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003elink\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003erel\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"icon\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"image/svg+xml\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ehref\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"/icon.svg\"\u003c/span\u003e /\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003etitle\u003c/span\u003e\u003e\u003c/span\u003eMy App\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003etitle\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003emeta\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"description\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003econtent\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"My App is a...\"\u003c/span\u003e /\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ehead\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebody\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"root\"\u003c/span\u003e\u003e\u003c/span\u003e{children}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebody\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ehtml\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 조금 더 팁을 드리자면, favicon.ico, icon.png, robots.txt 같은 메타데이터 파일들이 있다면, 이걸 직접 \u003ccode\u003e\u0026#x3C;head\u003e\u003c/code\u003e에 \u003ccode\u003elink\u003c/code\u003e 태그로 명시하지 않아도 돼요. Next.js가 여러분의 앱 디렉토리 최상단에 이런 파일들이 있는지 자동으로 체크해서 \u003ccode\u003e\u0026#x3C;head\u003e\u003c/code\u003e에 넣어주거든요.\u003c/p\u003e\n\u003cp\u003e즉, 이런 작업 구조가 가능해요:\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e위치\u003c/th\u003e\u003cth\u003e역할\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eapp/favicon.ico\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e파비콘 자동 등록\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eapp/robots.txt\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e검색 엔진 크롤러에서 참고하는 robots 파일 자동 포함\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eapp/icon.svg\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eSVG 아이콘 자동 등록\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e따라서, 이런 파일들만 잘 관리해두면 \u003ccode\u003elink\u003c/code\u003e 태그를 따로 추가하거나 지저분하게 관리할 필요가 없답니다.\u003c/p\u003e\n\u003chr\u003e\n\u003cblockquote\u003e\n\u003cp\u003e🚀 \u003cstrong\u003e한가지 알아두면 좋은 점!\u003c/strong\u003e\u003cbr\u003e\nNext.js의 이런 자동화 덕분에 앱 구조가 훨씬 깔끔하고 유지보수가 편해져요. 그리고 혹시 이런 메타데이터를 동적으로 변경하고 싶다면 Next.js 13부터 도입된 \u003ccode\u003emetadata\u003c/code\u003e API도 활용해보세요! 훨씬 더 편리하게 SEO 최적화가 가능합니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e궁금한 게 있으면 언제든지 물어봐 주세요! 😊\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eNext.js에서 head 태그를 관리하는 새로운 방법, Metadata API에 대해 이야기해볼게요. 원래는 아래처럼 직접 \u003ccode\u003e\u0026#x3C;head\u003e\u003c/code\u003e 태그 안에 title이나 meta를 적었었죠.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eRootLayout\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{\n  children,\n}: {\n  children: React.ReactNode\n}\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ehtml\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003elang\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"en\"\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ehead\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003etitle\u003c/span\u003e\u003e\u003c/span\u003eMy App\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003etitle\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003emeta\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"description\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003econtent\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"My App is a...\"\u003c/span\u003e /\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ehead\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebody\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"root\"\u003c/span\u003e\u003e\u003c/span\u003e{children}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebody\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ehtml\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그런데 Next.js는 이제 Metadata API라는 깔끔한 방식을 제공합니다. 이걸 쓰면 메타데이터를 컴포넌트 바깥에 \u003ccode\u003eexport const metadata\u003c/code\u003e로 분리할 수 있어요. 코드가 더 간결해지고, SEO 최적화나 공유할 때 이점도 커지죠:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-tsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eMetadata\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003emetadata\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eMetadata\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'My App'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003edescription\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'My App is a...'\u003c/span\u003e,\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eRootLayout\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{\n  children,\n}: {\n  children: React.ReactNode\n}\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ehtml\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003elang\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"en\"\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebody\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"root\"\u003c/span\u003e\u003e\u003c/span\u003e{children}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebody\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ehtml\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 바꾸면 \u003ccode\u003ehead\u003c/code\u003e 태그 자체는 선언하지 않고도 메타데이터가 Next.js에 의해 자동으로 관리되니까 훨씬 깔끔하고 유지보수도 쉽습니다. 그리고 나중에 동적으로 제목이나 설명을 바꾸고 싶을 때도 이 Metadata API가 더 편리해요.\u003c/p\u003e\n\u003cp\u003e참고로, 이 방식은 \u003ccode\u003e/app\u003c/code\u003e 디렉토리를 사용하는 Next.js 13 이상에서 권장되는 최신 방법이라는 점 꼭 기억하세요! 만약 아직 \u003ccode\u003epages\u003c/code\u003e 디렉토리를 쓰고 있다면 다음 업그레이드 때 도입해 보시면 좋을 것 같아요.\u003c/p\u003e\n\u003cp\u003e요약하자면, Metadata API는 다음과 같은 장점이 있어요:\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e장점\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e코드 분리\u003c/td\u003e\u003ctd\u003e메타데이터를 컴포넌트 코드에서 분리해 관리가 편리해짐\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e자동 관리\u003c/td\u003e\u003ctd\u003eNext.js가 head 태그를 자동으로 처리해 실수를 줄임\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSEO \u0026#x26; 공유 최적화\u003c/td\u003e\u003ctd\u003eSEO 관련 메타 정보와 소셜 미디어 공유 정보까지 쉽게 설정 가능\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e타입 지원\u003c/td\u003e\u003ctd\u003e타입스크립트 Metadata 타입 제공으로 안정성 증가\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e이렇게 공식 문서를 따라가면 Next.js 프로젝트가 한층 더 체계적이고 깔끔해질 거예요! 꼭 한번 써보세요 :)\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch3\u003e5단계: 진입점 페이지 만들기\u003c/h3\u003e\n\u003cp\u003eNext.js에서는 앱의 진입점을 만들 때 \u003ccode\u003epage.tsx\u003c/code\u003e 파일을 작성하는 식으로 선언해요. 이걸 Vite로 치환하면, 보통 \u003ccode\u003emain.tsx\u003c/code\u003e 파일이 진입점 역할을 하게 됩니다. 이번 단계에서는 여러분 앱의 진입점(첫 시작점)을 설정해볼 거예요.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eapp\u003c/code\u003e 디렉토리 안에 \u003ccode\u003e[[...slug]]\u003c/code\u003e라는 이름의 폴더를 생성하세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e여기서 잠깐! 우리가 이번 가이드에서 Next.js를 SPA(싱글 페이지 애플리케이션)처럼 사용하려고 하거든요. 그러려면 앱의 첫 페이지가 모든 가능한 경로를 받아서 처리해야 합니다. 그래서 \u003ccode\u003eapp\u003c/code\u003e 디렉토리에 \u003ccode\u003e[[...slug]]\u003c/code\u003e라는 폴더를 만들어서, 어떤 경로든 이 폴더가 잡아내서 라우팅할 수 있도록 하는 거죠.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e추가로 설명을 좀 하자면, Next.js에서는 \u003ccode\u003e[[...slug]]\u003c/code\u003e와 같은 경로 패턴이 \"캐치올(catch-all)\" 라우팅 기능을 의미해요. 쉽게 말해서, URL에 뭘 붙여도 다 여기서 받겠다는 뜻이죠. 그래서 SPA를 구현할 때 정말 유용합니다. Vite 같은 도구에서는 이런 라우팅을 직접 구현하거나 라이브러리를 붙여야 하는데, Next.js가 너무 잘해주는 부분이죠!\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e혹시 React Router를 써서 SPA를 만든다면, 이런 \"모든 경로를 캐치하는\" 룰을 \u003ccode\u003e\u0026#x3C;Route path=\"*\"\u003e\u003c/code\u003e 같은 식으로 걸어줄 수 있다는 점도 기억해 두세요. SPA의 핵심은 결국 한 페이지에서 모든 라우팅을 내부에서 다 처리하는 거니까요.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e정리하자면:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e[[...slug]]\u003c/code\u003e 폴더 생성 → Next.js의 캐치올 라우팅\u003c/li\u003e\n\u003cli\u003eSPA처럼 모든 경로를 한 페이지에서 처리\u003c/li\u003e\n\u003cli\u003eVite는 \u003ccode\u003emain.tsx\u003c/code\u003e가 진입점\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이렇게 세팅하면 여러분 앱이 다양한 경로에서 잘 반응하는 싱글 페이지 앱이 되겠죠? 다음 단계도 같이 기대해 주세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eNext.js에서는 폴더 구조가 라우트를 정의하는 중요한 역할을 해요. 여기서 소개한 \u003ccode\u003eapp/[[...slug]]\u003c/code\u003e 디렉토리는 '옵셔널 캐치-올(optional catch-all)' 라우트 세그먼트라고 불려요. 쉽게 말하면, 이 폴더 안에 있는 페이지가 애플리케이션의 모든 경로를 잡아주도록 설정하는 거죠.\u003c/p\u003e\n\u003ch3\u003e직접 해보기\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eapp/[[...slug]]\u003c/code\u003e 안에 \u003ccode\u003epage.tsx\u003c/code\u003e 파일을 새로 만들고, 아래 내용을 넣어보세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-tsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'../../index.css'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egenerateStaticParams\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e [{ \u003cspan class=\"hljs-attr\"\u003eslug\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e] }]\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'...'\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e// 나중에 업데이트할 예정이에요\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e여기서 \u003ccode\u003egenerateStaticParams\u003c/code\u003e 함수는 빌드 시에 미리 정적 페이지를 생성하기 위한 파라미터를 반환해요. 예제에선 빈 slug 배열을 반환해서 기본 경로를 세팅하고 있어요.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePage\u003c/code\u003e 컴포넌트는 현재 그냥 문자열을 반환하는 기본 상태인데, 이후에 이 부분을 다양한 경로에 맞게 확장할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e참고로, Next.js에서는 Page 컴포넌트 파일 이름에 \u003ccode\u003e.js\u003c/code\u003e, \u003ccode\u003e.jsx\u003c/code\u003e, \u003ccode\u003e.tsx\u003c/code\u003e 어떤 확장자든 사용할 수 있어요. 여러분이 편한 걸로 쓰면 됩니다!\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e이렇게 설정하면, 어떤 URL로 접근하든 여기 있는 \u003ccode\u003epage.tsx\u003c/code\u003e가 먼저 실행되어서 복잡한 라우팅 처리를 중앙 집중화 할 때 유용해요. 예를 들어 블로그의 포스트 여러 개를 한 페이지 컴포넌트에서 처리한다든지 할 때 쓰이죠.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e추가로 Tip!\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e[...slug]\u003c/code\u003e는 캐치-올 라우트(segment all)인데 필수로 하나 이상의 값이 있어야 합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e[[...slug]]\u003c/code\u003e는 옵셔널 캐치-올이라 slug가 없어도 이 라우트가 적용돼요.\u003c/li\u003e\n\u003cli\u003e이렇게 라우트를 잡으면 동적 경로도 쉽게 만들 수 있어요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eNext.js 라우팅 좀 더 편하게 하고 싶다면, 이런 옵셔널 캐치-올 라우트 구조를 꼭 알아두면 좋아요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 파일은 서버 컴포넌트(Server Component)예요. \u003ccode\u003enext build\u003c/code\u003e 명령어를 실행하면 이 파일은 미리 렌더링(prerendering)되어 정적인 자산(static asset)으로 만들어집니다. 즉, 동적 코드가 필요 없다는 뜻이죠.\u003c/p\u003e\n\u003cp\u003e이 파일은 글로벌 CSS를 불러오고, \u003ccode\u003egenerateStaticParams\u003c/code\u003e 함수에서는 오직 인덱스 경로인 \u003ccode\u003e/\u003c/code\u003e 하나만 정적으로 생성할 것이라고 알려줘요.\u003c/p\u003e\n\u003cp\u003e그럼 이제 나머지 Vite 애플리케이션 부분을 클라이언트 전용(Client-only)으로 옮겨볼게요. 다음처럼 작성하면 Next.js에서 클라이언트 전용 컴포넌트를 쉽게 다룰 수 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-string\"\u003e'use client'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e dynamic \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/dynamic'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eApp\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003edynamic\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'../../App'\u003c/span\u003e), { \u003cspan class=\"hljs-attr\"\u003essr\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e })\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eClientOnly\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eApp\u003c/span\u003e /\u003e\u003c/span\u003e\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 핵심은 \u003ccode\u003edynamic\u003c/code\u003e 함수를 쓰면서 \u003ccode\u003e{ ssr: false }\u003c/code\u003e 옵션을 넣는 부분이에요. 이걸 통해서 서버 사이드 렌더링(SSR)을 비활성화하고, 해당 컴포넌트를 클라이언트에서만 불러오도록 설정합니다. 보통 Vite처럼 클라이언트 전용 라이브러리를 사용할 때 이렇게 하면 에러 없이 잘 작동하죠.\u003c/p\u003e\n\u003cp\u003e또, \u003ccode\u003e'use client'\u003c/code\u003e 디렉티브를 최상단에 넣는 것도 잊지 마세요. 이건 Next.js 13 버전부터 도입된 문법인데, 해당 파일이 클라이언트 컴포넌트임을 명시해줍니다.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003eTIP\u003c/strong\u003e: 클라이언트 컴포넌트를 이렇게 분리해서 관리하면 서버 컴포넌트와 클라이언트 컴포넌트의 역할 분담이 명확해져서 유지보수도 훨씬 쉬워져요. 또한, 초기 페이지 로딩 속도도 더 좋아질 수 있으니 적극 추천합니다!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이 파일은 \u003ccode\u003euse client\u003c/code\u003e 지시어로 정의된 클라이언트 컴포넌트입니다. 클라이언트 컴포넌트라도 Next.js에서는 처음에 서버에서 HTML로 프리렌더링한 후 클라이언트에 전달해요.\u003c/p\u003e\n\u003cp\u003e하지만 클라이언트에서만 동작하는 애플리케이션을 만들고 싶다면, App 컴포넌트부터 시작해서 전체적으로 프리렌더링을 비활성화할 수 있어요. 이렇게 하면 서버에서는 HTML을 만들지 않고, 클라이언트에서만 렌더링하게 됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eApp\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003edynamic\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'../../App'\u003c/span\u003e), { \u003cspan class=\"hljs-attr\"\u003essr\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e })\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드에서 \u003ccode\u003edynamic\u003c/code\u003e을 사용하여 App 컴포넌트를 불러오면서 \u003ccode\u003e{ ssr: false }\u003c/code\u003e 옵션을 줬는데요, 이 옵션이 서버 사이드 렌더링을 끄는 역할을 해요.\u003c/p\u003e\n\u003cp\u003e그 다음에는 진입점(entrypoint) 페이지를 이제 이 동적으로 불러온 \u003ccode\u003eApp\u003c/code\u003e 컴포넌트로 교체해주면 됩니다!\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e참고로, 클라이언트 전용 애플리케이션을 만들 때는 서버에서 처리할 필요가 없으니 이렇게 \u003ccode\u003essr: false\u003c/code\u003e를 설정하는 게 퍼포먼스 향상에도 도움이 돼요. 하지만 SEO가 중요한 페이지라면 신중하게 사용해야겠죠.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e필요하면 아래처럼 진입점 페이지에서 바로 사용해보세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e dynamic \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/dynamic'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eApp\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003edynamic\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'../../App'\u003c/span\u003e), { \u003cspan class=\"hljs-attr\"\u003essr\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e })\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eApp\u003c/span\u003e /\u003e\u003c/span\u003e\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eNext.js와 Vite에서 정적 이미지(import) 다루는 방법이 조금 달라요. Vite에서는 이미지를 import 하면, 프로덕션 빌드 시 이미지의 URL 문자열이 반환돼서 바로 img 태그의 src에 쓸 수 있죠.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e image \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./img.png'\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e// 빌드 후에는 '/assets/img.2d8efhg.png' 같은 URL이 됨\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eApp\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eimg\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{image}\u003c/span\u003e /\u003e\u003c/span\u003e\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e근데 Next.js는 이런 식으로 바로 이미지 URL을 가져오는 게 아니라, \u003ccode\u003enext/image\u003c/code\u003e 컴포넌트를 이용해서 이미지 최적화 기능을 활용하도록 권장해요. 만약 그냥 정적 파일처럼 사용하고 싶으면 Next.js의 \u003ccode\u003epublic\u003c/code\u003e 폴더에 이미지를 넣고 URL로 접근하는 게 가장 깔끔하답니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, \u003ccode\u003epublic/img.png\u003c/code\u003e에 이미지를 넣었다면:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eApp\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eimg\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"/img.png\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ealt\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"example\"\u003c/span\u003e /\u003e\u003c/span\u003e\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e아니면 Next.js의 Image 컴포넌트를 써서 자동으로 크기 조정, 최적화 기능을 쓰는 것도 좋아요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'next/image'\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e img \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'../public/img.png'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eApp\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eImage\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{img}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ealt\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"example\"\u003c/span\u003e /\u003e\u003c/span\u003e\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 하면 이미지가 자동으로 최적화되고 레이지 로딩도 적용돼서 퍼포먼스에 유리해요.\u003c/p\u003e\n\u003chr\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eTip!\u003c/strong\u003e\u003cbr\u003e\nNext.js에서 이미지를 정적으로 import 하려면 \u003ccode\u003enext.config.js\u003c/code\u003e에서 \u003ccode\u003eimages\u003c/code\u003e 설정을 잘 해줘야 하는 경우도 있어요. 그리고 외부 URL의 이미지를 쓰려면 도메인을 허용해줘야 하죠.\u003cbr\u003e\n이미지 최적화나 로딩 속도가 신경 쓰인다면 \u003ccode\u003enext/image\u003c/code\u003e 컴포넌트를 적극 활용해보세요!\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003chr\u003e\n\u003cp\u003e결론적으로 Vite처럼 이미지 import 해서 바로 URL 받는 방식은 Next.js에선 조금 다르게 다뤄진다고 생각하면 돼요. 상황에 따라 \u003ccode\u003epublic\u003c/code\u003e 폴더에 넣거나, \u003ccode\u003enext/image\u003c/code\u003e를 쓰는 두 가지 방법 중 선택하면 됩니다!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eNext.js에서 이미지 파일을 정적으로 import하면, 이미지가 객체(object)로 반환돼요. 이 객체는 Next.js의 \u003ccode\u003eImage\u003c/code\u003e 컴포넌트에서 바로 사용할 수도 있고, 기존에 쓰던 \u003ccode\u003eimg\u003c/code\u003e 태그에서는 이 객체의 \u003ccode\u003esrc\u003c/code\u003e 속성만 꺼내서 쓸 수도 있답니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eImage\u003c/code\u003e 컴포넌트의 장점은 자동 이미지 최적화가 된다는 것! 그리고 이미지의 실제 크기를 기반으로 \u003ccode\u003ewidth\u003c/code\u003e, \u003ccode\u003eheight\u003c/code\u003e 속성을 자동으로 넣어줘서 이미지가 로딩될 때 레이아웃이 갑자기 바뀌는 문제(layout shift)를 막아줘요. 다만 주의할 점은 이미지의 한 쪽 치수만 스타일링하고 다른 쪽은 auto로 두지 않으면, 그 치수가 \u003ccode\u003eimg\u003c/code\u003e 태그에 자동으로 들어간 크기로 고정돼서 이미지가 왜곡될 수 있다는 거예요.\u003c/p\u003e\n\u003cp\u003e그래서 기존 \u003ccode\u003eimg\u003c/code\u003e 태그를 유지하면 코드 변경량도 줄일 수 있고, 위 문제도 피할 수 있죠. 나중에 필요하면 \u003ccode\u003eImage\u003c/code\u003e 컴포넌트로 단계별 마이그레이션을 할 수 있어요. 이때 직접 로더(loader)를 설정하거나, Next.js 기본 서버를 사용하면 자동 이미지 최적화를 편리하게 활용할 수 있답니다.\u003c/p\u003e\n\u003cp\u003e끝으로 \u003ccode\u003e/public\u003c/code\u003e 폴더에서 절대경로로 이미지를 import했다면, 상대경로로 바꾸는 것도 잊지 마세요. 이렇게 하면 관리도 더 편해지고 빌드 과정에서 문제도 줄일 수 있어요!\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e정리\u003c/h3\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e방법\u003c/th\u003e\u003cth\u003e장점\u003c/th\u003e\u003cth\u003e주의 사항\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eImage\u003c/code\u003e 컴포넌트 사용\u003c/td\u003e\u003ctd\u003e자동 이미지 최적화, 레이아웃 안정성 확보\u003c/td\u003e\u003ctd\u003e한쪽 치수만 스타일링 시 이미지 왜곡 가능성\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e기존 \u003ccode\u003eimg\u003c/code\u003e 태그 유지\u003c/td\u003e\u003ctd\u003e코드 변경 최소화, 왜곡 문제 없음\u003c/td\u003e\u003ctd\u003e이미지 최적화 기능은 직접 구현해야 함\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003e/public\u003c/code\u003e에서 이미지 경로 변경\u003c/td\u003e\u003ctd\u003e경로 관리 용이, 빌드 시 문제 감소\u003c/td\u003e\u003ctd\u003e절대경로 -\u003e 상대경로 수정 필요\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003chr\u003e\n\u003ch3\u003e추가 팁: 이미지 최적화 옵션\u003c/h3\u003e\n\u003cp\u003eNext.js의 \u003ccode\u003eImage\u003c/code\u003e 컴포넌트는 기본적으로 자동 최적화를 지원하지만, 필요하면 \u003ccode\u003eloader\u003c/code\u003e를 정의해 좀 더 세밀한 설정도 가능해요. 예를 들어 외부 이미지 호스팅 서비스를 함께 쓸 때 유용하죠. 혹은 next.config.js에서 domains 옵션에 외부 도메인을 추가해주면, 더 다양한 이미지를 \u003ccode\u003eImage\u003c/code\u003e 컴포넌트로 불러올 수 있습니다.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e필요에 따라 \u003ccode\u003eImage\u003c/code\u003e 컴포넌트의 장점과 한계를 잘 고려해서 사용하면, 퍼포먼스도 챙기고 개발도 부드럽게 할 수 있어요! 궁금한 점 있으면 언제든 질문 주세요~\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e자바스크립트 코드에서 이미지 파일을 불러올 때 경로나 방식이 조금 바뀌면서 주의할 점들을 정리해봤어요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e1. 이미지 파일 import 경로 변경하기\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 이전 방식\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e logo \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'/logo.png'\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 변경된 방식\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e logo \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'../public/logo.png'\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이전에는 루트부터 바로 경로를 지정했다면, 이제는 public 폴더를 기준으로 상대 경로를 명확히 써주는 게 좋아요. 그렇지 않으면 이미지가 제대로 불러와지지 않을 수도 있어요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e2. \u003ccode\u003eimg\u003c/code\u003e 태그에 \u003ccode\u003esrc\u003c/code\u003e 속성 넘길 때 주의하기\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 이전 방식\u003c/span\u003e\n\u0026#x3C;img src={logo} /\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 변경된 방식\u003c/span\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eimg\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{logo.src}\u003c/span\u003e /\u003e\u003c/span\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eimport 한 이미지 객체 전체를 \u003ccode\u003esrc\u003c/code\u003e에 넘기면 안 되고, 그 안에 실제 URL이 담긴 \u003ccode\u003e.src\u003c/code\u003e 값을 넘겨줘야 이미지가 화면에 제대로 뜹니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e3. 대안: 직접 public 폴더 경로 지정하기\u003c/h3\u003e\n\u003cp\u003e이미지 파일이 \u003ccode\u003epublic/logo.png\u003c/code\u003e에 있다면, 그냥 \u003ccode\u003esrc=\"/logo.png\"\u003c/code\u003e로 바로 작성해도 됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;img src=\u003cspan class=\"hljs-string\"\u003e\"/logo.png\"\u003c/span\u003e /\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 작성하면 이미지가 \u003ccode\u003epublic\u003c/code\u003e 폴더 안에서 찾아지게 되는데, 간단하게 이미지 경로를 관리할 수 있는 방법이기도 해요. 다만, 이 경우 import 없이 스트링 경로를 직접 넣는 형태라는 점 참고하세요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e추가 팁\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e만약 프로젝트가 Next.js 같은 프레임워크라면 \u003ccode\u003epublic\u003c/code\u003e 폴더의 파일은 빌드 시 그대로 공개 경로로 복사돼서 \u003ccode\u003e/이미지이름\u003c/code\u003e으로 접근 가능합니다.\u003c/li\u003e\n\u003cli\u003e자주 사용하는 공용 이미지들은 \u003ccode\u003epublic\u003c/code\u003e 폴더에 모아두는 게 관리도 편하고, 빌드에도 영향을 덜 주는 편이에요.\u003c/li\u003e\n\u003cli\u003e상대 경로 작성 시 \u003ccode\u003e..\u003c/code\u003e 여러 개를 써야 할 때 헷갈리기 쉬우니, VS Code 같은 편집기의 경로 자동완성기능을 적극 활용하면 좋아요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e이제 이미지를 불러올 때 경로 문제로 에러 뜨는 일은 조금 줄어들 거예요! 자~ 다음 프로젝트 때 적용해 보세요. :)\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cblockquote\u003e\n\u003cp\u003e경고: 만약 TypeScript를 사용 중이라면 src 속성에 접근할 때 타입 에러가 발생할 수 있어요. 지금은 무시해도 괜찮고, 이 가이드를 마칠 즈음에는 모두 해결될 테니 걱정 마세요.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3\u003e7단계: 환경 변수 마이그레이션하기\u003c/h3\u003e\n\u003cp\u003eNext.js도 Vite처럼 \u003ccode\u003e.env\u003c/code\u003e 파일을 통해 환경 변수를 관리할 수 있어요. 그런데 크게 차이나는 부분이 하나 있는데, 바로 클라이언트 쪽에서 노출되는 환경 변수에 붙는 접두사(prefix)에요.\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003eVite\u003c/th\u003e\u003cth\u003eNext.js\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eVITE_\u003c/code\u003e (접두사)\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eNEXT_PUBLIC_\u003c/code\u003e (접두사)\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e즉, Vite에서 \u003ccode\u003eVITE_\u003c/code\u003e로 시작하는 환경 변수들은 Next.js에서는 \u003ccode\u003eNEXT_PUBLIC_\u003c/code\u003e로 바꿔줘야 클라이언트 사이드 코드에서 접근할 수 있어요. 예를 들어:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-title class_\"\u003eVite\u003c/span\u003e 환경 변수\n\u003cspan class=\"hljs-variable constant_\"\u003eVITE_API_URL\u003c/span\u003e=\u003cspan class=\"hljs-attr\"\u003ehttps\u003c/span\u003e:\u003cspan class=\"hljs-comment\"\u003e//api.example.com\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 변수는 Next.js로 옮길 때 이렇게 바꿔줘야 해요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-title class_\"\u003eNext\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ejs\u003c/span\u003e 환경 변수\n\u003cspan class=\"hljs-variable constant_\"\u003eNEXT_PUBLIC_API_URL\u003c/span\u003e=\u003cspan class=\"hljs-attr\"\u003ehttps\u003c/span\u003e:\u003cspan class=\"hljs-comment\"\u003e//api.example.com\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이걸 꼭 지켜야 클라이언트에서 \u003ccode\u003eprocess.env.NEXT_PUBLIC_API_URL\u003c/code\u003e로 안전하게 접근할 수 있어요. 만약 접두사를 안 바꾸면 클라이언트 쪽에 변수가 노출되지 않아서 참조할 수 없게 돼요.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e추가 팁!\u003c/strong\u003e\u003cbr\u003e\n환경 변수를 사용할 때 중요한 건, 민감한 정보(ex: API 키, 비밀번호 등)는 절대 클라이언트에 노출시키면 안 돼요. \u003ccode\u003eNEXT_PUBLIC_\u003c/code\u003e 붙은 변수는 클라이언트에서 볼 수 있기 때문에, 민감 데이터를 담기엔 적합하지 않답니다. 서버 전용 변수는 접두사 없이 그냥 \u003ccode\u003eprocess.env\u003c/code\u003e에서 바로 사용하세요.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e앞으로 계속 환경 변수를 변경하면서도, 변수 이름을 이렇게 맞춰주는 게 Next.js와 Vite를 함께 쓰거나 Next.js로 이전할 때 발생하는 흔한 실수 중 하나예요. 신경 써서 관리하면 빌드 문제나 런타임 오류를 줄일 수 있어요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eVite에서는 특별한 import.meta.env 객체를 통해 몇 가지 내장 환경 변수를 제공하는데, Next.js는 이 부분을 지원하지 않아요. 그래서 Vite에서 쓰던 환경 변수들을 Next.js에 맞게 이렇게 바꿔줘야 해요.\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003eVite (import.meta.env)\u003c/th\u003e\u003cth\u003eNext.js (process.env)\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003eimport.meta.env.MODE\u003c/td\u003e\u003ctd\u003eprocess.env.NODE_ENV\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eimport.meta.env.PROD\u003c/td\u003e\u003ctd\u003eprocess.env.NODE_ENV === 'production'\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eimport.meta.env.DEV\u003c/td\u003e\u003ctd\u003eprocess.env.NODE_ENV !== 'production'\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eimport.meta.env.SSR\u003c/td\u003e\u003ctd\u003etypeof window === 'undefined'\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e여기서 살짝 팁을 드리자면, import.meta.env.SSR 은 서버 사이드 렌더링 여부를 체크하기 위한 변수인데, Next.js에서는 window 객체가 없으면 서버 환경으로 인식할 수 있으니 \u003ccode\u003etypeof window === 'undefined'\u003c/code\u003e 로 체크해주면 됩니다.\u003c/p\u003e\n\u003cp\u003e그리고 한 가지 더! Next.js는 기본적으로 Vite에 있는 BASE_URL 같은 환경 변수를 제공하지 않아요. 하지만 직접 환경 변수를 만들어서 쓸 수는 있답니다. 방법은 간단해요, 프로젝트 루트에 \u003ccode\u003e.env\u003c/code\u003e 파일을 만들고 아래처럼 추가해주시면 됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eNEXT_PUBLIC_BASE_URL\u003c/span\u003e=\u003cspan class=\"hljs-attr\"\u003ehttps\u003c/span\u003e:\u003cspan class=\"hljs-comment\"\u003e//your-domain.com\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 NEXT_PUBLIC_ 접두어는 Next.js에서 브라우저 코드에서도 접근할 수 있는 환경 변수를 의미해요. 만약 서버에서만 쓸 거라면 접두어 없이 그냥 선언하면 되고요.\u003c/p\u003e\n\u003cp\u003e이렇게 하면 코드에서 \u003ccode\u003eprocess.env.NEXT_PUBLIC_BASE_URL\u003c/code\u003e 로 접근해서 사용할 수 있어요. 예를 들어 API 엔드포인트를 설정할 때 유용하답니다.\u003c/p\u003e\n\u003cp\u003e정리하자면, Vite에서 Next.js로 넘어올 때 환경 변수 관련 코드를 이렇게 바꿔주시고, 필요한 환경 변수들은 직접 \u003ccode\u003e.env\u003c/code\u003e 파일에 추가해서 관리하시면 됩니다!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eNext.js에서 기본 경로(basePath)를 환경 변수로 설정하는 방법에 대해 공유할게요. 프로젝트를 하다 보면 \u003ccode\u003ebasePath\u003c/code\u003e를 동적으로 설정해야 할 경우가 있는데, 예를 들어 CDN이나 특정 경로에 배포할 때 유용하죠.\u003c/p\u003e\n\u003ch3\u003e1. \u003ccode\u003e.env\u003c/code\u003e 파일에 환경 변수 설정하기\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eNEXT_PUBLIC_BASE_PATH\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"/some-base-path\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 중요한 점! \u003ccode\u003eNEXT_PUBLIC_\u003c/code\u003e 접두어로 시작해야 클라이언트 쪽에서도 접근 가능해요.\u003c/p\u003e\n\u003ch3\u003e2. \u003ccode\u003enext.config.mjs\u003c/code\u003e 파일에서 basePath 설정하기\u003c/h3\u003e\n\u003cp\u003e다음과 같이 \u003ccode\u003enext.config.mjs\u003c/code\u003e에 \u003ccode\u003ebasePath\u003c/code\u003e를 환경 변수로 불러와 세팅해 주세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e/** \u003cspan class=\"hljs-doctag\"\u003e@type\u003c/span\u003e {\u003cspan class=\"hljs-type\"\u003eimport('next').NextConfig\u003c/span\u003e} */\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e nextConfig = {\n  \u003cspan class=\"hljs-attr\"\u003eoutput\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'export'\u003c/span\u003e,      \u003cspan class=\"hljs-comment\"\u003e// SPA 형태로 빌드\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003edistDir\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'./dist'\u003c/span\u003e,     \u003cspan class=\"hljs-comment\"\u003e// 빌드 결과물을 'dist' 폴더로 변경\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003ebasePath\u003c/span\u003e: process.\u003cspan class=\"hljs-property\"\u003eenv\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eNEXT_PUBLIC_BASE_PATH\u003c/span\u003e,   \u003cspan class=\"hljs-comment\"\u003e// env 변수를 basePath로 설정!\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e nextConfig\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003eTIP: \u003ccode\u003enext.config.mjs\u003c/code\u003e에서 import.meta.env 대신 \u003ccode\u003eprocess.env\u003c/code\u003e를 사용해야 하는 점 잊지 마세요. Next.js는 빌드 타임에 \u003ccode\u003eprocess.env\u003c/code\u003e로 환경 변수값을 주입합니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3\u003e3. 코드 내에서 \u003ccode\u003eimport.meta.env.BASE_URL\u003c/code\u003e -\u003e \u003ccode\u003eprocess.env.NEXT_PUBLIC_BASE_PATH\u003c/code\u003e로 변경\u003c/h3\u003e\n\u003cp\u003e기존에 \u003ccode\u003eimport.meta.env.BASE_URL\u003c/code\u003e 을 사용하던 부분이 있다면, \u003ccode\u003eprocess.env.NEXT_PUBLIC_BASE_PATH\u003c/code\u003e로 바꿔줘야 합니다. 이 부분은 Vite 등 다른 빌드 시스템과 차이가 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e basePath = process.\u003cspan class=\"hljs-property\"\u003eenv\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eNEXT_PUBLIC_BASE_PATH\u003c/span\u003e || \u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 사용 예\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e fullUrl = \u003cspan class=\"hljs-string\"\u003e`\u003cspan class=\"hljs-subst\"\u003e${basePath}\u003c/span\u003e/some-resource`\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e정리하자면\u003c/h3\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e단계\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e1. env 파일 만들기\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eNEXT_PUBLIC_BASE_PATH\u003c/code\u003e 설정\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e2. next.config.mjs 수정\u003c/td\u003e\u003ctd\u003e\u003ccode\u003ebasePath\u003c/code\u003e에 \u003ccode\u003eprocess.env.NEXT_PUBLIC_BASE_PATH\u003c/code\u003e 지정\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e3. 코드 수정\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eimport.meta.env.BASE_URL\u003c/code\u003e → \u003ccode\u003eprocess.env.NEXT_PUBLIC_BASE_PATH\u003c/code\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003chr\u003e\n\u003cp\u003e이렇게 하면 빌드할 때마다 환경 변수로 기본 경로를 바꾸는 게 가능해져서 다양한 배포 환경에 유연하게 대응할 수 있습니다. Next.js 프로젝트 하면서 경로 문제에 한 번쯤 고민해보셨다면 참고하세요~! 필요하면 basePath 외에도 \u003ccode\u003eassetPrefix\u003c/code\u003e도 같이 고려하는 게 좋아요. 그럼 즐코딩~! 🚀\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch3\u003e8단계: package.json 스크립트 업데이트하기\u003c/h3\u003e\n\u003cp\u003e이제 Next.js로 마이그레이션을 잘 했는지 확인하기 위해 애플리케이션을 실행해볼 수 있어요. 그런데 그 전에 package.json 안의 스크립트를 Next.js에 맞게 살짝 바꿔줘야 합니다.\u003c/p\u003e\n\u003cp\u003e기존에 있던 start나 build 명령어 대신 Next.js 명령어를 넣어주면 되는데요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-json\"\u003e\u003cspan class=\"hljs-punctuation\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003e\"scripts\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-punctuation\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003e\"dev\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"next dev\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003e\"build\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"next build\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003e\"start\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"next start\"\u003c/span\u003e\n  \u003cspan class=\"hljs-punctuation\"\u003e}\u003c/span\u003e\n\u003cspan class=\"hljs-punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e\"dev\"\u003c/code\u003e: 개발 모드로 로컬 서버를 띄울 때 사용해요 (hot reload도 지원해서 개발할 때 편리해요)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\"build\"\u003c/code\u003e: 배포 전, 프로덕션용으로 최적화된 빌드를 생성할 때 쓰입니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\"start\"\u003c/code\u003e: 빌드된 결과물을 실제 서비스 환경에서 실행할 때 사용하죠.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e그리고 Git 관리할 때 필요 없는 파일들을 깃에서 제외하기 위하여 \u003ccode\u003e.gitignore\u003c/code\u003e 파일에도 다음 내용을 추가해주세요:\u003c/p\u003e\n\u003cp\u003e.next\nnext-env.d.ts\ndist\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e.next\u003c/code\u003e 폴더는 Next.js가 빌드하면서 생성하는 임시파일들이라 보통 Git에 올리지 않아요.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003enext-env.d.ts\u003c/code\u003e는 Next.js 타입 지원을 위한 선언 파일로, 자동 생성되므로 따로 관리하지 않습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edist\u003c/code\u003e는 프로젝트마다 다르지만, 빌드 후 결과를 담고 있는 폴더라면 역시 빼는 게 좋습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e참고로, \u003ccode\u003e.gitignore\u003c/code\u003e에 이런 빌드 결과 파일들을 미리 넣어두면 협업할 때 불필요한 충돌도 줄일 수 있어요. 다음 단계에서는 이렇게 설정한 상태에서 실제로 \u003ccode\u003enpm run dev\u003c/code\u003e 명령어로 개발 서버를 실행해보면서 잘 작동하는지 확인해보세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e이제 터미널에서 \u003ccode\u003enpm run dev\u003c/code\u003e 명령어를 실행하고, \u003ca href=\"http://localhost:3000\" rel=\"nofollow\" target=\"_blank\"\u003ehttp://localhost:3000\u003c/a\u003e 에 접속해 보세요. 그러면 당신의 Next.js 애플리케이션이 잘 실행되고 있는 모습을 확인할 수 있을 거예요.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e참고로, Vite로 만들어진 애플리케이션을 Next.js로 마이그레이션한 실제 예제를 보고 싶다면 이 \u003ca href=\"https://github.com/vercel/next.js/pull/####\" rel=\"nofollow\" target=\"_blank\"\u003ePull Request\u003c/a\u003e를 확인해 보세요. (원문에 링크가 있다면 여기에 넣어주세요.)\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3\u003e9단계: 정리하기\u003c/h3\u003e\n\u003cp\u003e이제 Vite 관련 파일들이나 설정들은 모두 정리할 차례입니다. 프로젝트에서 Vite와 관련된 불필요한 것들을 깔끔하게 제거해서 코드베이스를 정돈해 주세요!\u003c/p\u003e\n\u003cp\u003e예를 들어, 다음과 같은 것들을 확인하시면 좋아요:\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e제거 대상\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003evite.config.js\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eVite 설정 파일\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eindex.html\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eVite에서 사용했던 진입 HTML 파일\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003epackage.json\u003c/code\u003e의 Vite 관련 의존성\u003c/td\u003e\u003ctd\u003e\u003ccode\u003evite\u003c/code\u003e, \u003ccode\u003e@vitejs/plugin-react\u003c/code\u003e 등\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e기타 Vite 전용 스크립트\u003c/td\u003e\u003ctd\u003e빌드 스크립트나 개발 서버 관련 설정\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e이렇게 정리하고 나면 Next.js만 사용하는 깔끔한 환경을 만들 수 있습니다.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e만약 다음 단계가 궁금하다면, Next.js의 배포나 최적화 방법 등을 함께 알아보는 것도 추천합니다. Next.js는 기본적으로 SSR(서버 사이드 렌더링)과 SSG(정적 사이트 생성), 그리고 CSR(클라이언트 사이드 렌더링)을 유연하게 사용할 수 있어서 애플리케이션을 더 빠르고 SEO 친화적으로 만들어 주거든요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cul\u003e\n\u003cli\u003emain.tsx 삭제\u003c/li\u003e\n\u003cli\u003eindex.html 삭제\u003c/li\u003e\n\u003cli\u003evite-env.d.ts 삭제\u003c/li\u003e\n\u003cli\u003etsconfig.node.json 삭제\u003c/li\u003e\n\u003cli\u003evite.config.ts 삭제\u003c/li\u003e\n\u003cli\u003eVite 관련 의존성 제거\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e다음 단계\u003c/h2\u003e\n\u003cp\u003e만약 지금까지 작업이 잘 됐다면, 이제 Next.js를 기반으로 동작하는 싱글 페이지 애플리케이션을 갖게 된 거예요. 하지만 아직 Next.js가 제공하는 많은 장점들을 완전히 활용하고 있진 않은 상태입니다. 이제부터 점진적으로 개선하면서 Next.js의 진가를 맛보실 수 있는데요, 다음 단계로 고려해볼 만한 사항들을 소개할게요:\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e다음 단계\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003eReact Router에서 Next.js App Router로 마이그레이션\u003c/td\u003e\u003ctd\u003e- 자동 코드 분할로 초기 로딩 속도 개선\u003cbr\u003e- 스트리밍 서버 사이드 렌더링 지원\u003cbr\u003e- React 서버 컴포넌트 활용 가능\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e이미지 최적화\u003c/td\u003e\u003ctd\u003eNext.js \u003ccode\u003eImage\u003c/code\u003e 컴포넌트로 자동 최적화된 이미지 제공\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e폰트 최적화\u003c/td\u003e\u003ctd\u003e\u003ccode\u003enext/font\u003c/code\u003e를 활용해 폰트 로딩 속도 및 성능 개선 가능\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e서드파티 스크립트 최적화\u003c/td\u003e\u003ctd\u003eNext.js \u003ccode\u003eScript\u003c/code\u003e 컴포넌트로 외부 스크립트 로딩 최적화\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eESLint 설정 업데이트\u003c/td\u003e\u003ctd\u003eNext.js 규칙을 지원하도록 ESLint를 구성하여 코드 품질 유지\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003chr\u003e\n\u003cp\u003e여기서 한 가지 팁을 추가하자면, Next.js의 App Router는 전통적인 React Router보다 많은 부분에서 성능과 개발 경험을 향상시키는데요. 특히 서버 컴포넌트(Server Components)를 적극 활용하면 클라이언트에서 불필요한 자바스크립트가 줄어들어 사용자 경험이 좋아집니다. 그리고 이미지나 폰트 최적화는 SEO와 사용자 경험에 직접적인 영향을 주기 때문에 꼭 챙겨보시길 추천드립니다!\u003c/p\u003e\n\u003cp\u003e조금씩 바꾸면서 Next.js 애플리케이션의 진정한 잠재력을 느껴보세요. 궁금한 점이 있으면 언제든 질문해 주세요!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2025-04-22-HowtomigratefromVitetoNextjs"},"buildId":"olPs1cVezSGTqD7OaewDI","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>