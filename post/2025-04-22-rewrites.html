<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Nextjs 15에서 웹페이지 이동한 것처럼 보이게 만들기 (rewrites) | TIL</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-rewrites" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Nextjs 15에서 웹페이지 이동한 것처럼 보이게 만들기 (rewrites) | TIL" data-gatsby-head="true"/><meta property="og:title" content="Nextjs 15에서 웹페이지 이동한 것처럼 보이게 만들기 (rewrites) | TIL" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://TIL.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://13akstjq.github.io/TIL//post/2025-04-22-rewrites" data-gatsby-head="true"/><meta name="twitter:title" content="Nextjs 15에서 웹페이지 이동한 것처럼 보이게 만들기 (rewrites) | TIL" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/TIL/assets/img/nextjs.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | TIL" data-gatsby-head="true"/><meta name="article:published_time" content="2025-04-22 13:21" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/TIL/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/TIL/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/TIL/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/TIL/favicons/favicon-96x96.png"/><link rel="icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/TIL/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/TIL/favicons/browserconfig.xml"/><link rel="preload" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/TIL/_next/static/css/0eef537492fed77a.css" as="style"/><link rel="stylesheet" href="/TIL/_next/static/css/0eef537492fed77a.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/TIL/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/TIL/_next/static/chunks/webpack-21ffe88bdca56cba.js" defer=""></script><script src="/TIL/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/TIL/_next/static/chunks/main-a5eeabb286676ce6.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/TIL/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/TIL/_next/static/chunks/348-02483b66b493dd81.js" defer=""></script><script src="/TIL/_next/static/chunks/pages/post/%5Bslug%5D-8ded8b979ba73586.js" defer=""></script><script src="/TIL/_next/static/olPs1cVezSGTqD7OaewDI/_buildManifest.js" defer=""></script><script src="/TIL/_next/static/olPs1cVezSGTqD7OaewDI/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/TIL">TIL</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/TIL/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Nextjs 15에서 웹페이지 이동한 것처럼 보이게 만들기 (rewrites)</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Nextjs 15에서 웹페이지 이동한 것처럼 보이게 만들기 (rewrites)" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/TIL/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">TIL</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Apr 22, 2025</span><span class="posts_reading_time__f7YPP">23<!-- --> min read</span></span></div></div></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h1>리라이트(rewrites)란?</h1>
<p>리라이트는 들어오는 요청 경로를 다른 목적지 경로로 바꿔주는 기능이에요.</p>
<p>이걸 간단히 말하면, 사용자가 웹사이트에서 이동한 것처럼 보이지만 실제로는 다른 경로에서 데이터를 가져오는 거예요. URL 자체는 바뀌지 않아서 '나는 여전히 같은 페이지에 있어!'라고 느껴지게 만드는 거죠. 이 점에서 리다이렉트와 큰 차이가 있어요. 리다이렉트는 말 그대로 URL이 바뀌면서 새 페이지로 이동하게 되거든요.</p>
<p>Next.js에서 리라이트를 사용하고 싶다면, <code>next.config.js</code> 파일 안에 <code>rewrites</code> 키를 활용하면 돼요.</p>
<p>예를 들어 이렇게 설정할 수 있어요:</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">rewrites</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> [
      {
        <span class="hljs-attr">source</span>: <span class="hljs-string">'/old-path/:slug*'</span>,
        <span class="hljs-attr">destination</span>: <span class="hljs-string">'/new-path/:slug*'</span>,
      },
    ];
  },
};
</code></pre>
<p>이렇게 하면 사용자가 <code>/old-path/anything</code> 으로 요청해도 실제 서버에선 <code>/new-path/anything</code> 을 처리하지만, 브라우저 주소창은 그대로 <code>/old-path/anything</code> 으로 유지돼요.</p>
<hr>
<h3>추가 팁!</h3>
<ul>
<li>리라이트는 특히 API 경로나 내부 구조를 바꾸고 싶을 때 유용해요. 예를 들어, API 버전을 변경할 때 외부에는 이전 API 경로를 그대로 노출하면서 내부에서는 새 버전을 쓸 수 있죠.</li>
<li>다만 리라이트가 작동하려면 Next.js가 해당 목적지 URL을 처리할 수 있어야 해요. 외부 도메인으로는 리라이트가 불가능하니 참고하세요.</li>
<li>만약 URL이 바뀌는 걸 원한다면, 리다이렉트를 사용해야 하는 점 기억하세요!</li>
</ul>
<p>리라이트를 잘 활용하면 사용자 경험을 훨씬 깔끔하게 유지하면서 서버 구조를 유연하게 바꿀 수 있답니다. 고민되는 부분 있으면 언제든 질문해 주세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Next.js에서 <code>rewrites</code> 설정을 쓰면 클라이언트 사이드 라우팅 시 URL 경로를 원하는 대로 바꿔서 보여줄 수 있어요. 예를 들어, 위 코드처럼 <code>/about</code> 경로를 <code>/</code> (홈 페이지)로 다시 매핑할 수 있죠.</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">rewrites</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> [
      {
        <span class="hljs-attr">source</span>: <span class="hljs-string">'/about'</span>,
        <span class="hljs-attr">destination</span>: <span class="hljs-string">'/'</span>,
      },
    ]
  },
}
</code></pre>
<p>이렇게 하면 코드 안에서 <code>&#x3C;Link href="/about"></code>을 사용해도 실제로는 <code>/</code> 경로로 라우팅 됩니다.</p>
<h3>rewrites 함수</h3>
<ul>
<li>async 함수로, 반환값은 <strong>객체 혹은 배열</strong> 형태입니다.</li>
<li>반환 값 안에는 <code>{ source, destination }</code> 객체들이 들어가죠.</li>
</ul>

































<table><thead><tr><th>속성명</th><th>설명</th></tr></thead><tbody><tr><td><code>source</code></td><td>들어오는 요청의 경로 패턴 (예: <code>/about</code>)</td></tr><tr><td><code>destination</code></td><td>실제로 라우팅할 경로</td></tr><tr><td><code>basePath</code></td><td><code>false</code> 혹은 <code>undefined</code> - <code>false</code>면 기본 <code>basePath</code>를 경로에서 제외 (외부 URL rewrite에 쓰임)</td></tr><tr><td><code>locale</code></td><td><code>false</code> 혹은 <code>undefined</code> - 지역화(locale) 경로 포함 여부 설정</td></tr><tr><td><code>has</code></td><td>조건 배열 - 특정 헤더, 쿠키, 쿼리 값 등이 있을 때만 rewrite 적용 가능</td></tr><tr><td><code>missing</code></td><td>조건 배열 - 특정 헤더, 쿠키, 쿼리 값이 없을 때만 rewrite 적용 가능</td></tr></tbody></table>
<hr>
<h3>추가 팁!</h3>
<ul>
<li><code>rewrites</code>는 URL을 '숨긴다'고 생각하면 쉬워요. 사용자가 <code>about</code> 페이지로 접속한 것 같지만 실제론 루트 페이지를 보여주니까요.</li>
<li>SEO에 영향을 안 주고 프론트엔드에서 URL만 바꾸고 싶을 때 유용해요.</li>
<li>복잡한 조건문으로 특정 쿠키가 있거나 쿼리 파라미터에 따라 경로를 다르게 바꾸고 싶다면 <code>has</code>나 <code>missing</code> 옵션을 이용해보세요.</li>
</ul>
<p>예를 들어:</p>
<pre><code class="hljs language-js"><span class="hljs-attr">rewrites</span>: <span class="hljs-keyword">async</span> () => [
  {
    <span class="hljs-attr">source</span>: <span class="hljs-string">'/dashboard'</span>,
    <span class="hljs-attr">has</span>: [
      { <span class="hljs-attr">type</span>: <span class="hljs-string">'cookie'</span>, <span class="hljs-attr">key</span>: <span class="hljs-string">'token'</span> }, <span class="hljs-comment">// 로그인 되어 있는 사람만 접근 가능하게 </span>
    ],
    <span class="hljs-attr">destination</span>: <span class="hljs-string">'/dashboard'</span>,
  },
  {
    <span class="hljs-attr">source</span>: <span class="hljs-string">'/dashboard'</span>,
    <span class="hljs-attr">missing</span>: [
      { <span class="hljs-attr">type</span>: <span class="hljs-string">'cookie'</span>, <span class="hljs-attr">key</span>: <span class="hljs-string">'token'</span> }, <span class="hljs-comment">// 로그인 안 되어 있으면 로그인 페이지로 </span>
    ],
    <span class="hljs-attr">destination</span>: <span class="hljs-string">'/login'</span>,
  },
],
</code></pre>
<p>이렇게 하면 사용자가 로그인이 되어 있는지 쿠키로 검사해 조건부 리다이렉트도 구현할 수 있어요.</p>
<hr>
<p>Next.js 공식 문서에서는 <code>rewrites</code> 외에도 <code>redirects</code>, <code>headers</code> 같은 유용한 설정들을 제공하니, 사이트 라우팅 컨트롤이 필요할 때 꼭 한 번 정독해보세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Next.js에서 rewrites 설정을 다룰 때, <code>rewrites</code> 함수가 배열을 반환하면, 이 리라이트(재작성) 규칙들은 파일 시스템(페이지와 /public 파일) 확인 후, 동적 라우트 검사 전에 적용돼요. 그런데 Next.js 10.1 버전부터는 <code>rewrites</code> 함수가 특정 구조의 객체 안에 배열들을 반환할 수 있는데요, 이 방식은 리라이트가 적용되는 타이밍을 좀 더 세밀하게 조정할 수 있게 해 줍니다.</p>
<p>아래 코드를 보면 각 배열이 어떤 역할을 하는지 쉽게 이해할 수 있어요:</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">rewrites</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">beforeFiles</span>: [
        <span class="hljs-comment">// headers/redirects 확인 후, 모든 파일 (예: _next/public 포함) 확인 전</span>
        <span class="hljs-comment">// 여기에 선언한 리라이트들은 페이지 파일들을 덮어쓸 수도 있어요</span>
        {
          <span class="hljs-attr">source</span>: <span class="hljs-string">'/some-page'</span>,
          <span class="hljs-attr">destination</span>: <span class="hljs-string">'/somewhere-else'</span>,
          <span class="hljs-attr">has</span>: [{ <span class="hljs-attr">type</span>: <span class="hljs-string">'query'</span>, <span class="hljs-attr">key</span>: <span class="hljs-string">'overrideMe'</span> }],
        },
      ],
      <span class="hljs-attr">afterFiles</span>: [
        <span class="hljs-comment">// 페이지와 public 파일 확인 후, 동적 라우트 검사 전</span>
        {
          <span class="hljs-attr">source</span>: <span class="hljs-string">'/non-existent'</span>,
          <span class="hljs-attr">destination</span>: <span class="hljs-string">'/somewhere-else'</span>,
        },
      ],
      <span class="hljs-attr">fallback</span>: [
        <span class="hljs-comment">// 페이지/public 파일과 동적 라우트 모두 확인 후</span>
        {
          <span class="hljs-attr">source</span>: <span class="hljs-string">'/:path*'</span>,
          <span class="hljs-attr">destination</span>: <span class="hljs-string">`https://my-old-site.com/:path*`</span>,
        },
      ],
    }
  },
}
</code></pre>
<h3>테이블로 정리하면 이렇게 볼 수 있어요</h3>

























<table><thead><tr><th>구분</th><th>적용 시점</th><th>특징 및 설명</th></tr></thead><tbody><tr><td><code>beforeFiles</code></td><td>headers/redirects 검사 후, 파일 시스템 검사(페이지, public) 전</td><td>페이지 파일 덮어쓰기 가능, 모든 <code>beforeFiles</code>가 확인될 때까지 계속 검사</td></tr><tr><td><code>afterFiles</code></td><td>페이지 및 public 파일 확인 후, 동적 라우트 확인 전</td><td>일반 파일은 없고 동적 라우트는 남아있을 때 사용</td></tr><tr><td><code>fallback</code></td><td>페이지/public 파일과 동적 라우트 검사 모두 완료 후</td><td>모든 검사 끝난 후 리라이트를 적용, 외부 사이트로 프록시 등 활용 가능</td></tr></tbody></table>
<hr>
<h3>좀 더 알려볼게요!</h3>
<ul>
<li>
<p><strong><code>beforeFiles</code> 내 리라이트는 매칭되더라도 모든 <code>beforeFiles</code> 배열의 규칙들을 다 검사해요.</strong> 즉, 첫번째 매치에서 멈추지 않고, 다음 규칙도 계속 확인하는 거죠. 이는 오버라이드나 여러 조건에 유리해요.</p>
</li>
<li>
<p>여러분이 리라이트를 통해 어떤 페이지를 완전히 다른 페이지로 교체하거나(예: A → B), 혹은 외부 URL로 프록시하려면 <code>fallback</code> 위치에 정의하는 게 적합해요.</p>
</li>
<li>
<p>동적 라우트(<code>/:id</code> 같은 경로)를 조작하고 싶다면 <code>afterFiles</code> 위치를 활용하면 되는데요, 이 영역은 기본 페이지, public 파일 검사를 마친 후에 처리됩니다.</p>
</li>
<li>
<p>파일 시스템 검사(실제로 그 경로에 맞는 파일이나 페이지가 있는지 확인)는 성능에도 영향을 끼치기 때문에, 필요한 경우에만 세밀하게 조절하는 게 중요해요.</p>
</li>
</ul>
<hr>
<h3>마무리</h3>
<p>Next.js의 rewrites 기능, 특히 v10.1 이후 객체 모양의 <code>rewrites</code> 반환은 라우팅 제어를 정말 유연하게 만들어줍니다. 상황에 맞게 <code>beforeFiles</code>, <code>afterFiles</code>, <code>fallback</code>을 잘 조합해서, 내가 원하는 대로 페이지 흐름을 완벽하게 관리해 보세요! 개발자의 상상력과 요구에 유연하게 대응할 수 있다는 점이 Next.js의 큰 장점 중 하나랍니다.</p>
<p>필요하면 다음에 <code>redirects</code>와 <code>headers</code> 설정에 대해서도 재미있고 쉽게 설명해 드릴게요! 😊</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Next.js에서 라우팅과 리다이렉트, 그리고 리라이트(rewrite)가 어떻게 작동하는지 한번 정리해볼게요. 개발할 때 이 흐름을 이해하고 있으면 문제 생겼을 때 원인 찾기가 훨씬 수월해져요.</p>
<hr>
<h3>Next.js 요청 처리 순서</h3>

































<table><thead><tr><th>순서</th><th>처리 내용</th></tr></thead><tbody><tr><td>1</td><td>헤더(headers) 체크 및 적용</td></tr><tr><td>2</td><td>리다이렉트(redirects) 체크 및 적용</td></tr><tr><td>3</td><td><code>beforeFiles</code> 리라이트(rewrites) 체크 및 적용</td></tr><tr><td>4</td><td>정적 파일(public 디렉토리, <code>_next/static</code> 파일)과 비동적(non-dynamic) 페이지를 체크 및 서빙</td></tr><tr><td>5</td><td><code>afterFiles</code> 리라이트 체크 및 적용 — 여기서 매칭되면 다이나믹 라우트나 정적 파일을 다시 체크</td></tr><tr><td>6</td><td>fallback 리라이트 체크 및 적용 — 404 페이지를 렌더링하기 전에, 다이나믹 라우트와 정적 자산 모두 체크한 뒤 수행. getStaticPaths에서 <code>fallback: true</code>나 <code>blocking</code>을 사용했다면 이 fallback 리라이트는 실행되지 않습니다.</td></tr></tbody></table>
<hr>
<h3>리라이트(rewrite)에서 파라미터 사용 시 참고</h3>
<p>리라이트 할 때 <strong>destination</strong> URL에 파라미터를 직접 사용하지 않으면, 자동으로 쿼리(query)로 전달돼요.</p>
<p>예를 들어,</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">rewrites</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> [
      {
        <span class="hljs-attr">source</span>: <span class="hljs-string">'/old-about/:path*'</span>,
        <span class="hljs-attr">destination</span>: <span class="hljs-string">'/about'</span>,  <span class="hljs-comment">// 여기서는 :path를 직접 쓰지 않았으니 쿼리로 전달됨</span>
      },
    ]
  },
}
</code></pre>
<p>위처럼 작성하면 <code>/old-about/some/page</code> 로 접속했을 때, <code>/about?path=some/page</code>로 처리되는 셈이에요.</p>
<p>만약 파라미터를 destination에 포함시키고 싶다면 이렇게 써야 해요:</p>
<pre><code class="hljs language-js"><span class="hljs-attr">destination</span>: <span class="hljs-string">'/about/:path*'</span>,
</code></pre>
<p>그러면 <code>/old-about/whatever</code>가 <code>/about/whatever</code>로 바로 바뀌죠.</p>
<hr>
<h3>이런 내용이 왜 중요하냐면?</h3>
<ul>
<li>리다이렉트는 URL을 완전히 바꿔서 클라이언트가 새 주소로 이동하도록 하는 반면</li>
<li>리라이트는 내부적으로 경로를 변경해서 유저는 주소가 변하지 않는 것처럼 유지하면서 다른 페이지나 리소스를 보여줄 수 있어요.</li>
</ul>
<p>그래서 이미지 요청이나 API 프록시, 특정 조건에서 페이지 렌더링 방식을 유연하게 제어할 때 리라이트를 많이 씁니다.</p>
<hr>
<p>혹시 Next.js 라우팅, 리다이렉트, 리라이트 중 어디에 더 궁금한 점 있으면 언제든 질문 주세요! 직접 써보고 경험한 팁도 더 알려드릴게요.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Next.js에서 <code>rewrites</code> 설정을 할 때, 이 부분이 살짝 헷갈릴 수 있는데요. 오늘은 <code>rewrites</code>에서 파라미터가 목적지(<code>destination</code>)에 어떻게 전달되는지, 그리고 자동으로 쿼리로 넘어가지 않는 경우를 함께 살펴볼게요.</p>
<hr>
<h3>파라미터가 목적지에 사용될 경우, 다른 파라미터는 쿼리에 자동으로 전달되지 않아요</h3>
<p>다음 코드를 보시면,</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">rewrites</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> [
      {
        <span class="hljs-attr">source</span>: <span class="hljs-string">'/docs/:path*'</span>,
        <span class="hljs-attr">destination</span>: <span class="hljs-string">'/:path*'</span>, <span class="hljs-comment">// :path 파라미터를 destination에서 이미 사용하고 있어요.</span>
      },
    ]
  },
}
</code></pre>
<p><code>source</code>에 <code>/docs/:path*</code>가 있는데, <code>destination</code>에서도 똑같이 <code>/:path*</code>를 사용 중이에요. 중요한 점은 이렇게 <code>destination</code>에서 이미 파라미터를 사용하면, 나머지 파라미터는 <strong>자동으로 쿼리 스트링에 전달되지 않는다</strong>는 것!</p>
<p>즉, 만약 다른 파라미터가 있었다면 자동으로 <code>?파라미터=값</code> 형태로 넘겨주지 않으니 주의해야 해요.</p>
<hr>
<h3>쿼리 파라미터를 직접 지정하면 수동으로 전달할 수 있어요</h3>
<p>필요해서 쿼리에도 파라미터를 넘기고 싶다면 이렇게 직접 명시해주면 됩니다.</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">rewrites</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> [
      {
        <span class="hljs-attr">source</span>: <span class="hljs-string">'/:first/:second'</span>,
        <span class="hljs-attr">destination</span>: <span class="hljs-string">'/:first?second=:second'</span>,
        <span class="hljs-comment">// :first는 destination 경로에서 이미 사용중이라,</span>
        <span class="hljs-comment">// :second는 자동 쿼리 전달이 안 되는데 직접 쿼리에 넣어줬어요.</span>
      },
    ]
  },
}
</code></pre>
<p><code>/:first/:second</code> 경로에서 <code>destination</code>이 <code>/:first?second=:second</code>이니, <code>first</code>는 경로에, <code>second</code>는 쿼리스트링에 직접 넣어주면서 목적지 URL을 생성합니다.</p>
<hr>
<h3>어떻게 활용하면 좋을까?</h3>
<ul>
<li>복잡한 URL 매핑 할 때 각 파라미터를 어떻게 쓸지 정리하기 편해요.</li>
<li>특정 파라미터를 경로에 반드시 넣어야 할 때, 나머지는 쿼리로 주고 싶다면 위처럼 수동 지정해야 합니다.</li>
<li>자동 쿼리 전달이 원치 않는 경우에도 활용할 수 있죠.</li>
</ul>
<hr>
<h3>참고: Next.js <code>rewrites</code> 공식 문서</h3>
<p><a href="https://nextjs.org/docs/api-reference/next.config.js/rewrites" rel="nofollow" target="_blank">Next.js Rewrites 공식 문서</a>에서 더 다양한 예시와 옵션을 확인할 수 있으니, 실제 프로젝트에 바로 적용하기 전에 한 번쯤 훑어보시길 추천드려요!</p>
<hr>
<p>재미있는 점은, 이런 기본 동작을 이해하면 라우팅을 더 유연하게 다룰 수 있다는 거예요. 다음에도 이런 실용적인 팁으로 찾아올게요. 궁금한 점 있으면 언제든 질문 환영입니다! 😄</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<blockquote>
<p>참고할 점: Automatic Static Optimization이나 rewrites에서 사용하는 prerendering 파라미터를 통해 생성된 정적 페이지들은 hydration 이후 클라이언트에서 파싱되고, 이 정보가 쿼리로 제공됩니다.</p>
</blockquote>
<h2>경로 매칭(Path Matching)</h2>
<p>Next.js에서 경로 매칭은 매우 유연하게 사용할 수 있는데요. 예를 들어 <code>/blog/:slug</code> 같은 패턴은 <code>/blog/hello-world</code> 같은 경로와 매칭됩니다. 여기서 <code>:slug</code>는 동적으로 변할 수 있는 부분입니다. 단, 중첩된 경로(예: <code>/blog/2023/03</code> 같은)는 매칭하지 않으니 참고하세요.</p>
<p>다음은 <code>rewrites</code> 설정 예시입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">rewrites</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> [
      {
        <span class="hljs-attr">source</span>: <span class="hljs-string">'/blog/:slug'</span>,
        <span class="hljs-attr">destination</span>: <span class="hljs-string">'/news/:slug'</span>, <span class="hljs-comment">// 매칭된 파라미터를 destination 경로에서도 사용할 수 있습니다.</span>
      },
    ]
  },
}
</code></pre>
<h3>좀 더 알아보기</h3>
<ul>
<li><code>rewrites</code>는 클라이언트가 요청한 URL을 내부적으로 다른 경로로 매핑해 주는 기능이라, 실제로 URL은 바뀌지 않으면서 다른 페이지의 콘텐츠를 보여줄 수 있습니다.</li>
<li>매개변수 <code>:slug</code> 같은 동적 세그먼트를 활용하면 더욱 깔끔하고 유연한 URL 구조를 만들 수 있죠.</li>
<li>중첩 경로나 와일드카드 사용이 필요하다면 Next.js의 다른 기능들(ex. catch-all routes)을 활용하는 것도 좋은 방법입니다.</li>
</ul>
<p>이 기능을 잘 활용하면 URL 디자인을 자유롭게 변경하면서도, 기존에 만들어 둔 페이지 컴포넌트 재사용이 가능해집니다!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h3>와일드카드 경로 매칭 (Wildcard Path Matching)</h3>
<p>Next.js에서 와일드카드 경로를 매칭하고 싶다면, 경로 매개변수 뒤에 <code>*</code>를 붙여주면 돼요. 예를 들어 <code>/blog/:slug*</code> 라고 쓰면 <code>/blog/a/b/c/d/hello-world</code> 같은 경로도 한 번에 매칭이 된답니다.</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">rewrites</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> [
      {
        <span class="hljs-attr">source</span>: <span class="hljs-string">'/blog/:slug*'</span>,
        <span class="hljs-attr">destination</span>: <span class="hljs-string">'/news/:slug*'</span>, <span class="hljs-comment">// 매칭된 파라미터를 목적지 경로에서도 사용할 수 있어요</span>
      },
    ]
  },
}
</code></pre>
<p>여기서 중요한 점!<br>
<code>:slug*</code>에서 <code>*</code>는 이 뒤에 어떤 경로가 와도 다 잡아준다는 의미에요. 즉, <code>/blog/a</code>도 되고, <code>/blog/a/b/c</code>도 다 같은 규칙으로 잡히는 거죠.</p>
<p>이걸 이용하면 블로그 포스트나 여러 단계로 깊은 경로를 리다이렉트할 때 아주 유용합니다.</p>
<hr>
<h3>정규식(Regex) 경로 매칭</h3>
<p>Next.js <code>rewrites</code> 설정에서 복잡한 경로 지정이 필요할 때는 정규식을 써서 더욱 세밀한 매칭도 가능해요.<br>
정규식은 보통 문자열 패턴 매칭에 강력한 무기인 만큼, 유연한 라우팅 구현에 큰 도움이 됩니다.</p>
<p>예를 들어, <code>/post/:id(\\d+)</code> 라는 경로는 숫자(id)가 들어가는 경로만 정확히 잡고 싶을 때 쓸 수 있어요.<br>
즉 <code>/post/123</code>는 매칭되고 <code>/post/abc</code>는 매칭 안되도록 하는 거죠.</p>
<hr>
<p>여기까지 와일드카드와 정규식 경로 매칭에 대해서 간단히 살펴봤는데요,<br>
다음에는 정규식을 써서 실제로 어떻게 경로를 재작성하는지 예제를 들어서 더 쉽게 알려드릴게요!<br>
궁금한 점 있으면 댓글로 남겨주세요.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>정규식(Regex)로 경로를 매칭하고 싶다면, 파라미터 뒤에 괄호() 안에 정규식을 감싸서 사용할 수 있어요. 예를 들어, <code>/blog/:slug(\\d{1,})</code>라고 하면 <code>/blog/123</code>처럼 숫자로만 된 경로는 매칭되고 <code>/blog/abc</code> 같은 문자는 매칭되지 않아요.</p>
<p>아래 예시를 볼게요:</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">rewrites</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> [
      {
        <span class="hljs-attr">source</span>: <span class="hljs-string">'/old-blog/:post(\\d{1,})'</span>,
        <span class="hljs-attr">destination</span>: <span class="hljs-string">'/blog/:post'</span>, <span class="hljs-comment">// 매칭된 파라미터를 목적지 경로에서 사용할 수 있어요</span>
      },
    ]
  },
}
</code></pre>
<p>위 코드에서 <code>:post(\\d{1,})</code>는 1자리 이상 숫자가 와야 매칭돼요. 그래서 <code>/old-blog/123</code>으로 요청하면 <code>/blog/123</code>으로 리다이렉트되는 거죠.</p>
<hr>
<p>추가로, 정규식에서 특수문자들인 <code>(</code>, <code>)</code>, <code>'</code>, <code> </code>, <code>[</code>, <code>]</code>, <code>|</code>, <code>\</code>, <code>^</code>, <code>.</code>, <code>:</code>, <code>*</code>, <code>+</code>, <code>-</code>, <code>?</code>, <code>$</code> 같은 문자는 그냥 쓰면 안 되고, 그냥 문자열로 매칭하고 싶으면 반드시 앞에 역슬래시(<code>\</code>)를 붙여서 이스케이프 해야 해요.</p>
<p>예를 들어, 경로에 괄호가 포함된 pattern을 매칭하고 싶을 때는 이렇게 작성하시면 됩니다:</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">rewrites</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> [
      {
        <span class="hljs-comment">// `/english(default)/something` 처럼 괄호가 포함된 경로를 매칭합니다</span>
        <span class="hljs-attr">source</span>: <span class="hljs-string">'/english\\(default\\)/:slug'</span>,
        <span class="hljs-attr">destination</span>: <span class="hljs-string">'/en-us/:slug'</span>,
      },
    ]
  },
}
</code></pre>
<p>이 경우 <code>/english(default)/page1</code>로 들어오는 요청은 <code>/en-us/page1</code>으로 리다이렉트되죠.</p>
<hr>
<p>정리하면, Next.js rewrites 등에서 경로 매칭 시 정규식을 사용할 때는</p>
<ul>
<li>파라미터 뒤에 괄호로 정규식을 감싸서 세부 매칭 조건을 줄 수 있고</li>
<li>특수문자는 <code>\\</code>로 꼭 이스케이프해서 사용하세요.</li>
</ul>
<p>그래야 원하는 경로를 정확히 매칭할 수 있고 의도치 않은 오류를 예방할 수 있습니다.</p>
<p>이 방식으로 유연하게 URL 경로 패턴을 조절해보세요! 개발할 때 알아두면 꽤 유용합니다.</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h2>헤더, 쿠키, 쿼리 매칭하기</h2>
<p>리라이트(rewrite)를 특정 조건에 맞출 때 헤더, 쿠키, 쿼리 값이 특정 값과 맞아야 하거나, 특정 값이 없어야 할 때도 있죠? 이럴 때 사용하는 게 바로 <code>has</code> 필드와 <code>missing</code> 필드입니다.</p>
<p>여기서 중요한 점은, 리라이트가 적용되려면 <strong>source</strong>와 <code>has</code>에 정의된 모든 항목이 일치해야 하고, 동시에 <code>missing</code>에 정의된 항목은 전부 일치하지 않아야 한다는 거예요. 쉽게 말해, 필요한 건 있어야 하고 없어야 할 건 없어야 한다는 뜻이죠.</p>
<h3>has와 missing에서 사용할 수 있는 항목들</h3>

























<table><thead><tr><th>필드 이름</th><th>타입</th><th>설명</th></tr></thead><tbody><tr><td>type</td><td>String</td><td><code>header</code>, <code>cookie</code>, <code>host</code>, <code>query</code> 중 하나로 요청의 어디를 검사할지 지정</td></tr><tr><td>key</td><td>String</td><td>검사하려는 항목의 키(이름), 예를 들어 헤더 이름이나 쿠키 이름 등</td></tr><tr><td>value</td><td>String 또는 undefined</td><td>검사할 값. 만약 <code>undefined</code>면 어떤 값이든 매치</td></tr></tbody></table>
<p>특히 <code>value</code>에는 정규표현식처럼 작동하는 문자열도 쓸 수 있어요. 예를 들어, <code>first-(?paramName.*)</code>라는 값을 쓰면, 실제 값 <code>first-second</code>에서 <code>second</code> 부분만 뽑아서 나중에 리라이트 목적지(destination)에서 <code>:paramName</code>라는 이름으로 활용할 수 있다는 점도 참신하죠?</p>
<hr>
<h3>조금 더 풀어보자면</h3>
<ul>
<li><code>has</code>는 “이것들이 있어야 한다”는 의미예요.</li>
<li><code>missing</code>은 “이것들이 없어야 한다”는 조건이죠.</li>
</ul>
<p>예를 들어,</p>
<ul>
<li><code>has</code>에 <code>{ type: 'header', key: 'x-user', value: 'admin' }</code>가 있으면, <code>x-user</code> 헤더가 <code>admin</code>이어야 리라이트됩니다.</li>
<li><code>missing</code>에 <code>{ type: 'cookie', key: 'session', value: undefined }</code>가 있으면, <code>session</code>이라는 쿠키가 없어야 리라이트가 적용됩니다.</li>
</ul>
<p>이런 조건들을 조합하면 꽤 상세하고 구체적인 요청 매칭을 할 수 있답니다!</p>
<hr>
<p>이 기능을 활용하면 더 똑똑하고 유연한 리라이트를 구현할 수 있어서, 특정 조건에 따라 페이지를 다르게 보여주거나 API 요청처리를 달리 할 때 정말 유용해요. 다음에 직접 예제도 만들어서 보여드릴게요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Next.js의 <code>rewrites</code> 기능을 사용하면 특정 요청에 대해 URL 경로를 내부 또는 외부 URL로 "재작성(rewrite)"할 수 있어요. 이 기능은 특히 점진적으로 Next.js를 도입하거나, 내부 URL을 사용자에게 숨기고 싶을 때 유용하게 쓰입니다.</p>
<h3>헤더, 쿼리, 쿠키, 호스트에 따른 rewrites 예시</h3>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">rewrites</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> [
      <span class="hljs-comment">// 1. 요청 헤더에 'x-rewrite-me'가 있으면 '/another-page'로 보낸다</span>
      {
        <span class="hljs-attr">source</span>: <span class="hljs-string">'/:path*'</span>,
        <span class="hljs-attr">has</span>: [
          { <span class="hljs-attr">type</span>: <span class="hljs-string">'header'</span>, <span class="hljs-attr">key</span>: <span class="hljs-string">'x-rewrite-me'</span> },
        ],
        <span class="hljs-attr">destination</span>: <span class="hljs-string">'/another-page'</span>,
      },
      <span class="hljs-comment">// 2. 요청 헤더에 'x-rewrite-me'가 없으면 '/another-page'로 보낸다</span>
      {
        <span class="hljs-attr">source</span>: <span class="hljs-string">'/:path*'</span>,
        <span class="hljs-attr">missing</span>: [
          { <span class="hljs-attr">type</span>: <span class="hljs-string">'header'</span>, <span class="hljs-attr">key</span>: <span class="hljs-string">'x-rewrite-me'</span> },
        ],
        <span class="hljs-attr">destination</span>: <span class="hljs-string">'/another-page'</span>,
      },
      <span class="hljs-comment">// 3. 쿼리 'page=home'이고 쿠키 'authorized=true'일 때 '/specific/:path*/home'으로 보낸다</span>
      {
        <span class="hljs-attr">source</span>: <span class="hljs-string">'/specific/:path*'</span>,
        <span class="hljs-attr">has</span>: [
          { <span class="hljs-attr">type</span>: <span class="hljs-string">'query'</span>, <span class="hljs-attr">key</span>: <span class="hljs-string">'page'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'home'</span> },
          { <span class="hljs-attr">type</span>: <span class="hljs-string">'cookie'</span>, <span class="hljs-attr">key</span>: <span class="hljs-string">'authorized'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'true'</span> },
        ],
        <span class="hljs-attr">destination</span>: <span class="hljs-string">'/:path*/home'</span>,
      },
      <span class="hljs-comment">// 4. 헤더 'x-authorized'에 'yes' 또는 'true'가 포함되어 있으면 '/home'에 쿼리로 authorized 값 붙이기</span>
      {
        <span class="hljs-attr">source</span>: <span class="hljs-string">'/:path*'</span>,
        <span class="hljs-attr">has</span>: [
          { <span class="hljs-attr">type</span>: <span class="hljs-string">'header'</span>, <span class="hljs-attr">key</span>: <span class="hljs-string">'x-authorized'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'(?&#x3C;authorized>yes|true)'</span> },
        ],
        <span class="hljs-attr">destination</span>: <span class="hljs-string">'/home?authorized=:authorized'</span>,
      },
      <span class="hljs-comment">// 5. 호스트가 'example.com'이면 '/another-page'로 보낸다</span>
      {
        <span class="hljs-attr">source</span>: <span class="hljs-string">'/:path*'</span>,
        <span class="hljs-attr">has</span>: [
          { <span class="hljs-attr">type</span>: <span class="hljs-string">'host'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'example.com'</span> },
        ],
        <span class="hljs-attr">destination</span>: <span class="hljs-string">'/another-page'</span>,
      },
    ]
  },
}
</code></pre>
<p>위 예시에서 볼 수 있듯이, 단순히 경로만 보고 리다이렉트하는 게 아니라 헤더, 쿠키, 쿼리 파라미터, 심지어 호스트까지 고려해서 경로를 바꿀 수 있습니다. 만약 조건에 맞는 헤더가 있으면 rewrite를 다르게 적용하는 식으로 세밀한 컨트롤이 가능해요.</p>
<hr>
<h2>외부 URL로도 리라이트가 가능합니다!</h2>
<p>재밌는 점은 내부 페이지뿐 아니라 외부 URL로도 갈 수 있다는거예요. 예를 들어, 기존 웹사이트의 특정 경로를 Next.js 안에서 재작성해서 외부 사이트로 연결하고 싶을 때 아주 유용하죠.</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">rewrites</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> [
      <span class="hljs-comment">// '/blog' 경로는 https://example.com/blog 로 이동</span>
      {
        <span class="hljs-attr">source</span>: <span class="hljs-string">'/blog'</span>,
        <span class="hljs-attr">destination</span>: <span class="hljs-string">'https://example.com/blog'</span>,
      },
      <span class="hljs-comment">// '/blog/:slug' 경로도 https://example.com/blog/:slug 로 매칭되는 대로 이동</span>
      {
        <span class="hljs-attr">source</span>: <span class="hljs-string">'/blog/:slug'</span>,
        <span class="hljs-attr">destination</span>: <span class="hljs-string">'https://example.com/blog/:slug'</span>,
      },
    ]
  },
}
</code></pre>
<p>이처럼 외부 URL도 <code>destination</code>에 바로 적으면 그쪽으로 요청을 보낼 수 있답니다. 특히 마이그레이션 기간에 기존 서비스와 신 서비스를 자연스럽게 연결할 때 매우 유용해요.</p>
<hr>
<h3>추가 팁!</h3>
<ul>
<li><strong>rewrites vs redirects:</strong> rewrites는 URL을 바꿔서 서버에서 다른 페이지를 보여주지만, 실제 사용자에게는 원래 URL이 유지돼요. 반면 redirects는 사용자를 다른 URL로 실제로 이동시키고 브라우저 주소창도 바뀝니다.</li>
<li><strong>조건이 많을 때는 꼭 주의:</strong> 너무 복잡한 조건을 걸면 관리하기 어려우니, 가독성을 고려해서 몇 개의 룰을 잘 분리해서 쓰는 게 좋아요.</li>
<li><strong>value를 안쓰거나 캡처 그룹을 쓰면 경로 파라미터 활용 가능:</strong> 위 예시처럼 <code>(??&#x3C;authorized>yes|true)</code> 처럼 정규표현식 캡처 그룹을 쓰면 재작성 대상 경로에 캡처된 값을 쉽게 쓸 수 있어요.</li>
</ul>
<p>이제 필요에 따라 세밀하게 페이지 경로를 조작해보세요! Next.js rewrites 기능은 생각보다 강력해서 몇 가지 응용만 알면 정말 다양한 케이스에 적용할 수 있답니다. 🙂</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>next.js에서 <code>trailingSlash: true</code> 설정을 사용할 때 꼭 알아둬야 할 점이 있어요. 바로 리다이렉트(rewrites) 설정할 때 <code>source</code> 경로 끝에도 꼭 슬래시(/)를 붙여줘야 한다는 거죠. 목적지(destination) URL도 마찬가지예요. 만약 원격 서버가 슬래시를 기대한다면 destination 경로 끝에도 슬래시를 붙여줘야 정상적으로 동작합니다.</p>
<p>예를 들어, 아래와 같이 설정하면 <code>/blog/</code> 또는 <code>/blog/</code> 하위 경로로 들어오는 요청을 정확히 리다이렉트할 수 있어요.</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">trailingSlash</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">rewrites</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> [
      {
        <span class="hljs-attr">source</span>: <span class="hljs-string">'/blog/'</span>,
        <span class="hljs-attr">destination</span>: <span class="hljs-string">'https://example.com/blog/'</span>,
      },
      {
        <span class="hljs-attr">source</span>: <span class="hljs-string">'/blog/:path*/'</span>,
        <span class="hljs-attr">destination</span>: <span class="hljs-string">'https://example.com/blog/:path*/'</span>,
      },
    ]
  },
}
</code></pre>
<p>여기서 <code>:path*</code>는 와일드카드처럼 동작해서 <code>/blog/anything/here/</code> 같은 하위 경로도 전부 포괄해줍니다.</p>
<hr>
<h3>Next.js 점진적 도입 (Incremental adoption)</h3>
<p>또 하나 재미있는 점은, 기존에 운영 중인 웹사이트가 있을 때 Next.js로 점진적으로 옮겨갈 수 있다는 거예요. Next.js가 먼저 자신의 라우트들을 검사한 후에 해당 경로가 없다면 기존 서버 쪽으로 프록시(proxy) 요청을 넘기는 방법이죠.</p>
<p>이 방식을 사용하면 한 번에 모든 페이지를 Next.js로 옮기지 않아도 되고, 조금씩 옮기면서 안정적으로 서비스를 개선할 수 있답니다.</p>
<hr>
<h4>추가 팁!</h4>
<ul>
<li><code>trailingSlash</code> 옵션을 켜면 빌드된 정적 파일들도 자동으로 폴더 형식으로 생성됩니다. 예를 들어 <code>/about</code>은 <code>/about/index.html</code>로 만들어지고, 브라우저에서는 <code>/about/</code> URL로 접근하게 되죠.</li>
<li>리다이렉트 설정에서 슬래시는 사소해 보여도, 이 부분이 틀리면 404 에러가 날 수 있으니 꼭 신경 써 주세요.</li>
<li>점진적 도입을 고려한다면, Next.js의 <code>rewrites</code>와 <code>fallback</code> 기능을 적극 활용해보세요. 개발할 때 훨씬 유연해질 거예요!</li>
</ul>
<p>다음에도 Next.js 관련해서 재미있고 쓸모 있는 팁 있으면 계속 공유할게요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<p>Next.js로 더 많은 페이지를 마이그레이션할 때, 리라이트(rewrites) 설정을 매번 바꿀 필요가 없도록 하는 방법을 알려 드릴게요.</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">rewrites</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">fallback</span>: [
        {
          <span class="hljs-attr">source</span>: <span class="hljs-string">'/:path*'</span>,
          <span class="hljs-attr">destination</span>: <span class="hljs-string">`https://custom-routes-proxying-endpoint.vercel.app/:path*`</span>,
        },
      ],
    }
  },
}
</code></pre>
<p>이렇게 하면 어떤 경로로 들어오든 <code>https://custom-routes-proxying-endpoint.vercel.app</code> 쪽으로 다 연결해주는 역할을 해요. 그래서 점진적으로 Next.js로 옮겨가는 중에도 기존 경로를 일일이 바꿀 필요 없이 한 번에 처리할 수 있죠.</p>
<hr>
<h3>basePath 지원하는 리라이트</h3>
<p>Next.js에서 <code>basePath</code>를 사용하면서 리라이트를 할 때는 <code>source</code>와 <code>destination</code> 양쪽 경로 모두 자동으로 <code>basePath</code>가 앞에 붙어요. 만약 어떤 리라이트에서 <code>basePath</code>를 붙이고 싶지 않으면, 아래처럼 <code>basePath: false</code>를 추가하면 됩니다.</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">rewrites</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">fallback</span>: [
        {
          <span class="hljs-attr">source</span>: <span class="hljs-string">'/custom-path/:path*'</span>,
          <span class="hljs-attr">destination</span>: <span class="hljs-string">'https://external-site.com/:path*'</span>,
          <span class="hljs-attr">basePath</span>: <span class="hljs-literal">false</span>,  <span class="hljs-comment">// basePath 자동 접두사 안붙임</span>
        },
      ],
    }
  },
}
</code></pre>
<p>이렇게 쓰면 <code>basePath</code>가 없는 그대로 외부 도메인 주소로 리다이렉션하게 돼요.</p>
<hr>
<p><strong>추가 팁!</strong></p>
<ol>
<li><code>rewrites</code>는 URL 경로를 클라이언트에게 그대로 보여주면서 내부적으로 다른 경로로 연결해주는 기능이에요. SEO나 UX에 민감한 상황에서 유용하죠.</li>
<li><code>fallback</code> 속성은 일치하는 리라이트 규칙이 없을 때 마지막으로 적용되는 규칙이라, 넓은 범위의 라우팅을 처리할 때 깔끔하게 쓸 수 있어요.</li>
<li>만약 API 요청 경로나 이미지 리퀘스트에 리라이트를 복잡하게 적용해야 한다면, 별도의 규칙으로 꼼꼼히 테스트해보세요.</li>
</ol>
<p>Next.js에서 라우팅을 다루는 게 어렵게 느껴질 수 있지만, 이런 설정들을 잘 활용하면 한결 유연하고 깔끔하게 관리할 수 있으니 꼭 한번 시도해보세요!</p>
<!-- TIL 수평 -->
<p><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4877378276818686" data-ad-slot="1549334788" data-ad-format="auto" data-full-width-responsive="true"></ins></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">basePath</span>: <span class="hljs-string">'/docs'</span>,

  <span class="hljs-keyword">async</span> <span class="hljs-title function_">rewrites</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> [
      {
        <span class="hljs-attr">source</span>: <span class="hljs-string">'/with-basePath'</span>, <span class="hljs-comment">// /docs/with-basePath로 자동 변환됨</span>
        <span class="hljs-attr">destination</span>: <span class="hljs-string">'/another'</span>,  <span class="hljs-comment">// /docs/another로 자동 변환됨</span>
      },
      {
        <span class="hljs-comment">// basePath: false가 설정되어 있어 /docs가 붙지 않음</span>
        <span class="hljs-comment">// 참고: 내부 리다이렉트(예: destination: '/another')에는 사용할 수 없음</span>
        <span class="hljs-attr">source</span>: <span class="hljs-string">'/without-basePath'</span>,
        <span class="hljs-attr">destination</span>: <span class="hljs-string">'https://example.com'</span>,
        <span class="hljs-attr">basePath</span>: <span class="hljs-literal">false</span>,
      },
    ]
  },
}
</code></pre>
<hr>
<h2>버전 히스토리</h2>





















<table><thead><tr><th>Version</th><th>Changes</th></tr></thead><tbody><tr><td><code>v13.3.0</code></td><td><code>missing</code> 추가됨</td></tr><tr><td><code>v10.2.0</code></td><td><code>has</code> 추가됨</td></tr><tr><td><code>v9.5.0</code></td><td>Headers 추가됨</td></tr></tbody></table>
<hr>
<h3>살짝 더 알려드려요!</h3>
<ul>
<li><strong>basePath</strong>는 Next.js에서 모든 경로 앞에 특정 기본 경로를 붙이고 싶을 때 사용해요. 예를 들어, 위 예제처럼 <code>basePath: '/docs'</code>를 설정하면, 모든 페이지와 API가 <code>/docs</code> 하위에 위치해요.</li>
<li><code>rewrites</code>는 요청 경로를 다른 경로나 외부 URL로 내부적으로 바꿔주는 역할을 하죠. 위 코드에서는 <code>/with-basePath</code> 요청이 <code>/docs/with-basePath</code>로, <code>/another</code> 경로로도 매핑되는 걸 볼 수 있어요.</li>
<li>그런데 <code>basePath: false</code> 옵션이 들어간 리라이트는 좀 특별해요. 이 옵션을 주면 기본 경로가 붙지 않고, 외부 URL(예: <code>https://example.com</code>)로 바로 연결할 수 있어요. 다만, 내부 경로 리라이트에선 사용할 수 없으니 주의하세요.</li>
<li>버전 히스토리를 보면 점차 기능이 추가되고 확장된 걸 알 수 있는데, 개발 중인 프로젝트에 필요한 기능이 어느 버전부터 생겼는지 참고하면 좋아요!</li>
</ul>
<p>다음에 또 재미있는 개발 팁 들고 올게요! 궁금한 점 있으면 언제든 물어봐 주세요~</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Nextjs 15에서 웹페이지 이동한 것처럼 보이게 만들기 (rewrites)","description":"","date":"2025-04-22 13:21","slug":"2025-04-22-rewrites","content":"\n\n# 리라이트(rewrites)란?\n\n리라이트는 들어오는 요청 경로를 다른 목적지 경로로 바꿔주는 기능이에요.\n\n이걸 간단히 말하면, 사용자가 웹사이트에서 이동한 것처럼 보이지만 실제로는 다른 경로에서 데이터를 가져오는 거예요. URL 자체는 바뀌지 않아서 '나는 여전히 같은 페이지에 있어!'라고 느껴지게 만드는 거죠. 이 점에서 리다이렉트와 큰 차이가 있어요. 리다이렉트는 말 그대로 URL이 바뀌면서 새 페이지로 이동하게 되거든요.\n\nNext.js에서 리라이트를 사용하고 싶다면, `next.config.js` 파일 안에 `rewrites` 키를 활용하면 돼요. \n\n예를 들어 이렇게 설정할 수 있어요:\n\n```js\nmodule.exports = {\n  async rewrites() {\n    return [\n      {\n        source: '/old-path/:slug*',\n        destination: '/new-path/:slug*',\n      },\n    ];\n  },\n};\n```\n\n이렇게 하면 사용자가 `/old-path/anything` 으로 요청해도 실제 서버에선 `/new-path/anything` 을 처리하지만, 브라우저 주소창은 그대로 `/old-path/anything` 으로 유지돼요.\n\n---\n\n### 추가 팁!\n\n- 리라이트는 특히 API 경로나 내부 구조를 바꾸고 싶을 때 유용해요. 예를 들어, API 버전을 변경할 때 외부에는 이전 API 경로를 그대로 노출하면서 내부에서는 새 버전을 쓸 수 있죠.\n- 다만 리라이트가 작동하려면 Next.js가 해당 목적지 URL을 처리할 수 있어야 해요. 외부 도메인으로는 리라이트가 불가능하니 참고하세요.\n- 만약 URL이 바뀌는 걸 원한다면, 리다이렉트를 사용해야 하는 점 기억하세요!\n\n리라이트를 잘 활용하면 사용자 경험을 훨씬 깔끔하게 유지하면서 서버 구조를 유연하게 바꿀 수 있답니다. 고민되는 부분 있으면 언제든 질문해 주세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 `rewrites` 설정을 쓰면 클라이언트 사이드 라우팅 시 URL 경로를 원하는 대로 바꿔서 보여줄 수 있어요. 예를 들어, 위 코드처럼 `/about` 경로를 `/` (홈 페이지)로 다시 매핑할 수 있죠.\n\n```js\nmodule.exports = {\n  async rewrites() {\n    return [\n      {\n        source: '/about',\n        destination: '/',\n      },\n    ]\n  },\n}\n```\n\n이렇게 하면 코드 안에서 `\u003cLink href=\"/about\"\u003e`을 사용해도 실제로는 `/` 경로로 라우팅 됩니다.  \n\n### rewrites 함수\n- async 함수로, 반환값은 **객체 혹은 배열** 형태입니다.  \n- 반환 값 안에는 `{ source, destination }` 객체들이 들어가죠.\n\n| 속성명       | 설명                                                                  |\n|--------------|-----------------------------------------------------------------------|\n| `source`     | 들어오는 요청의 경로 패턴 (예: `/about`)                              |\n| `destination`| 실제로 라우팅할 경로                                                 |\n| `basePath`   | `false` 혹은 `undefined` - `false`면 기본 `basePath`를 경로에서 제외 (외부 URL rewrite에 쓰임) |\n| `locale`     | `false` 혹은 `undefined` - 지역화(locale) 경로 포함 여부 설정          |\n| `has`        | 조건 배열 - 특정 헤더, 쿠키, 쿼리 값 등이 있을 때만 rewrite 적용 가능  |\n| `missing`    | 조건 배열 - 특정 헤더, 쿠키, 쿼리 값이 없을 때만 rewrite 적용 가능    |\n\n---\n\n### 추가 팁!\n\n- `rewrites`는 URL을 '숨긴다'고 생각하면 쉬워요. 사용자가 `about` 페이지로 접속한 것 같지만 실제론 루트 페이지를 보여주니까요.  \n- SEO에 영향을 안 주고 프론트엔드에서 URL만 바꾸고 싶을 때 유용해요.  \n- 복잡한 조건문으로 특정 쿠키가 있거나 쿼리 파라미터에 따라 경로를 다르게 바꾸고 싶다면 `has`나 `missing` 옵션을 이용해보세요.  \n\n예를 들어:\n\n```js\nrewrites: async () =\u003e [\n  {\n    source: '/dashboard',\n    has: [\n      { type: 'cookie', key: 'token' }, // 로그인 되어 있는 사람만 접근 가능하게 \n    ],\n    destination: '/dashboard',\n  },\n  {\n    source: '/dashboard',\n    missing: [\n      { type: 'cookie', key: 'token' }, // 로그인 안 되어 있으면 로그인 페이지로 \n    ],\n    destination: '/login',\n  },\n],\n```\n\n이렇게 하면 사용자가 로그인이 되어 있는지 쿠키로 검사해 조건부 리다이렉트도 구현할 수 있어요.\n\n---\n\nNext.js 공식 문서에서는 `rewrites` 외에도 `redirects`, `headers` 같은 유용한 설정들을 제공하니, 사이트 라우팅 컨트롤이 필요할 때 꼭 한 번 정독해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 rewrites 설정을 다룰 때, `rewrites` 함수가 배열을 반환하면, 이 리라이트(재작성) 규칙들은 파일 시스템(페이지와 /public 파일) 확인 후, 동적 라우트 검사 전에 적용돼요. 그런데 Next.js 10.1 버전부터는 `rewrites` 함수가 특정 구조의 객체 안에 배열들을 반환할 수 있는데요, 이 방식은 리라이트가 적용되는 타이밍을 좀 더 세밀하게 조정할 수 있게 해 줍니다.\n\n아래 코드를 보면 각 배열이 어떤 역할을 하는지 쉽게 이해할 수 있어요:\n\n```js\nmodule.exports = {\n  async rewrites() {\n    return {\n      beforeFiles: [\n        // headers/redirects 확인 후, 모든 파일 (예: _next/public 포함) 확인 전\n        // 여기에 선언한 리라이트들은 페이지 파일들을 덮어쓸 수도 있어요\n        {\n          source: '/some-page',\n          destination: '/somewhere-else',\n          has: [{ type: 'query', key: 'overrideMe' }],\n        },\n      ],\n      afterFiles: [\n        // 페이지와 public 파일 확인 후, 동적 라우트 검사 전\n        {\n          source: '/non-existent',\n          destination: '/somewhere-else',\n        },\n      ],\n      fallback: [\n        // 페이지/public 파일과 동적 라우트 모두 확인 후\n        {\n          source: '/:path*',\n          destination: `https://my-old-site.com/:path*`,\n        },\n      ],\n    }\n  },\n}\n```\n\n### 테이블로 정리하면 이렇게 볼 수 있어요\n\n| 구분           | 적용 시점                                                         | 특징 및 설명                                              |\n|----------------|------------------------------------------------------------------|-----------------------------------------------------------|\n| `beforeFiles`  | headers/redirects 검사 후, 파일 시스템 검사(페이지, public) 전    | 페이지 파일 덮어쓰기 가능, 모든 `beforeFiles`가 확인될 때까지 계속 검사 |\n| `afterFiles`   | 페이지 및 public 파일 확인 후, 동적 라우트 확인 전                | 일반 파일은 없고 동적 라우트는 남아있을 때 사용             |\n| `fallback`     | 페이지/public 파일과 동적 라우트 검사 모두 완료 후                | 모든 검사 끝난 후 리라이트를 적용, 외부 사이트로 프록시 등 활용 가능 |\n\n---\n\n### 좀 더 알려볼게요!\n\n- **`beforeFiles` 내 리라이트는 매칭되더라도 모든 `beforeFiles` 배열의 규칙들을 다 검사해요.** 즉, 첫번째 매치에서 멈추지 않고, 다음 규칙도 계속 확인하는 거죠. 이는 오버라이드나 여러 조건에 유리해요.\n\n- 여러분이 리라이트를 통해 어떤 페이지를 완전히 다른 페이지로 교체하거나(예: A → B), 혹은 외부 URL로 프록시하려면 `fallback` 위치에 정의하는 게 적합해요.\n\n- 동적 라우트(`/:id` 같은 경로)를 조작하고 싶다면 `afterFiles` 위치를 활용하면 되는데요, 이 영역은 기본 페이지, public 파일 검사를 마친 후에 처리됩니다.\n\n- 파일 시스템 검사(실제로 그 경로에 맞는 파일이나 페이지가 있는지 확인)는 성능에도 영향을 끼치기 때문에, 필요한 경우에만 세밀하게 조절하는 게 중요해요.\n\n---\n\n### 마무리\n\nNext.js의 rewrites 기능, 특히 v10.1 이후 객체 모양의 `rewrites` 반환은 라우팅 제어를 정말 유연하게 만들어줍니다. 상황에 맞게 `beforeFiles`, `afterFiles`, `fallback`을 잘 조합해서, 내가 원하는 대로 페이지 흐름을 완벽하게 관리해 보세요! 개발자의 상상력과 요구에 유연하게 대응할 수 있다는 점이 Next.js의 큰 장점 중 하나랍니다. \n\n필요하면 다음에 `redirects`와 `headers` 설정에 대해서도 재미있고 쉽게 설명해 드릴게요! 😊\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 라우팅과 리다이렉트, 그리고 리라이트(rewrite)가 어떻게 작동하는지 한번 정리해볼게요. 개발할 때 이 흐름을 이해하고 있으면 문제 생겼을 때 원인 찾기가 훨씬 수월해져요.\n\n---\n\n### Next.js 요청 처리 순서\n\n| 순서 | 처리 내용 |\n|-------|------------|\n| 1 | 헤더(headers) 체크 및 적용 |\n| 2 | 리다이렉트(redirects) 체크 및 적용 |\n| 3 | `beforeFiles` 리라이트(rewrites) 체크 및 적용 |\n| 4 | 정적 파일(public 디렉토리, `_next/static` 파일)과 비동적(non-dynamic) 페이지를 체크 및 서빙 |\n| 5 | `afterFiles` 리라이트 체크 및 적용 — 여기서 매칭되면 다이나믹 라우트나 정적 파일을 다시 체크 |\n| 6 | fallback 리라이트 체크 및 적용 — 404 페이지를 렌더링하기 전에, 다이나믹 라우트와 정적 자산 모두 체크한 뒤 수행. getStaticPaths에서 `fallback: true`나 `blocking`을 사용했다면 이 fallback 리라이트는 실행되지 않습니다. |\n\n---\n\n### 리라이트(rewrite)에서 파라미터 사용 시 참고\n\n리라이트 할 때 **destination** URL에 파라미터를 직접 사용하지 않으면, 자동으로 쿼리(query)로 전달돼요.\n\n예를 들어,\n\n```js\nmodule.exports = {\n  async rewrites() {\n    return [\n      {\n        source: '/old-about/:path*',\n        destination: '/about',  // 여기서는 :path를 직접 쓰지 않았으니 쿼리로 전달됨\n      },\n    ]\n  },\n}\n```\n\n위처럼 작성하면 `/old-about/some/page` 로 접속했을 때, `/about?path=some/page`로 처리되는 셈이에요.\n\n만약 파라미터를 destination에 포함시키고 싶다면 이렇게 써야 해요:\n\n```js\ndestination: '/about/:path*',\n```\n\n그러면 `/old-about/whatever`가 `/about/whatever`로 바로 바뀌죠.\n\n---\n\n### 이런 내용이 왜 중요하냐면?\n\n- 리다이렉트는 URL을 완전히 바꿔서 클라이언트가 새 주소로 이동하도록 하는 반면  \n- 리라이트는 내부적으로 경로를 변경해서 유저는 주소가 변하지 않는 것처럼 유지하면서 다른 페이지나 리소스를 보여줄 수 있어요.\n\n그래서 이미지 요청이나 API 프록시, 특정 조건에서 페이지 렌더링 방식을 유연하게 제어할 때 리라이트를 많이 씁니다.\n\n---\n\n혹시 Next.js 라우팅, 리다이렉트, 리라이트 중 어디에 더 궁금한 점 있으면 언제든 질문 주세요! 직접 써보고 경험한 팁도 더 알려드릴게요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js에서 `rewrites` 설정을 할 때, 이 부분이 살짝 헷갈릴 수 있는데요. 오늘은 `rewrites`에서 파라미터가 목적지(`destination`)에 어떻게 전달되는지, 그리고 자동으로 쿼리로 넘어가지 않는 경우를 함께 살펴볼게요.\n\n---\n\n### 파라미터가 목적지에 사용될 경우, 다른 파라미터는 쿼리에 자동으로 전달되지 않아요\n\n다음 코드를 보시면,\n\n```js\nmodule.exports = {\n  async rewrites() {\n    return [\n      {\n        source: '/docs/:path*',\n        destination: '/:path*', // :path 파라미터를 destination에서 이미 사용하고 있어요.\n      },\n    ]\n  },\n}\n```\n\n`source`에 `/docs/:path*`가 있는데, `destination`에서도 똑같이 `/:path*`를 사용 중이에요. 중요한 점은 이렇게 `destination`에서 이미 파라미터를 사용하면, 나머지 파라미터는 **자동으로 쿼리 스트링에 전달되지 않는다**는 것!\n\n즉, 만약 다른 파라미터가 있었다면 자동으로 `?파라미터=값` 형태로 넘겨주지 않으니 주의해야 해요.\n\n---\n\n### 쿼리 파라미터를 직접 지정하면 수동으로 전달할 수 있어요\n\n필요해서 쿼리에도 파라미터를 넘기고 싶다면 이렇게 직접 명시해주면 됩니다.\n\n```js\nmodule.exports = {\n  async rewrites() {\n    return [\n      {\n        source: '/:first/:second',\n        destination: '/:first?second=:second',\n        // :first는 destination 경로에서 이미 사용중이라,\n        // :second는 자동 쿼리 전달이 안 되는데 직접 쿼리에 넣어줬어요.\n      },\n    ]\n  },\n}\n```\n\n`/:first/:second` 경로에서 `destination`이 `/:first?second=:second`이니, `first`는 경로에, `second`는 쿼리스트링에 직접 넣어주면서 목적지 URL을 생성합니다.\n\n---\n\n### 어떻게 활용하면 좋을까?\n\n- 복잡한 URL 매핑 할 때 각 파라미터를 어떻게 쓸지 정리하기 편해요.\n- 특정 파라미터를 경로에 반드시 넣어야 할 때, 나머지는 쿼리로 주고 싶다면 위처럼 수동 지정해야 합니다.\n- 자동 쿼리 전달이 원치 않는 경우에도 활용할 수 있죠.\n\n---\n\n### 참고: Next.js `rewrites` 공식 문서\n\n[Next.js Rewrites 공식 문서](https://nextjs.org/docs/api-reference/next.config.js/rewrites)에서 더 다양한 예시와 옵션을 확인할 수 있으니, 실제 프로젝트에 바로 적용하기 전에 한 번쯤 훑어보시길 추천드려요!\n\n---\n\n재미있는 점은, 이런 기본 동작을 이해하면 라우팅을 더 유연하게 다룰 수 있다는 거예요. 다음에도 이런 실용적인 팁으로 찾아올게요. 궁금한 점 있으면 언제든 질문 환영입니다! 😄\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003e 참고할 점: Automatic Static Optimization이나 rewrites에서 사용하는 prerendering 파라미터를 통해 생성된 정적 페이지들은 hydration 이후 클라이언트에서 파싱되고, 이 정보가 쿼리로 제공됩니다.\n\n## 경로 매칭(Path Matching)\n\nNext.js에서 경로 매칭은 매우 유연하게 사용할 수 있는데요. 예를 들어 `/blog/:slug` 같은 패턴은 `/blog/hello-world` 같은 경로와 매칭됩니다. 여기서 `:slug`는 동적으로 변할 수 있는 부분입니다. 단, 중첩된 경로(예: `/blog/2023/03` 같은)는 매칭하지 않으니 참고하세요.\n\n다음은 `rewrites` 설정 예시입니다:\n\n```js\nmodule.exports = {\n  async rewrites() {\n    return [\n      {\n        source: '/blog/:slug',\n        destination: '/news/:slug', // 매칭된 파라미터를 destination 경로에서도 사용할 수 있습니다.\n      },\n    ]\n  },\n}\n```\n\n### 좀 더 알아보기\n\n- `rewrites`는 클라이언트가 요청한 URL을 내부적으로 다른 경로로 매핑해 주는 기능이라, 실제로 URL은 바뀌지 않으면서 다른 페이지의 콘텐츠를 보여줄 수 있습니다.\n- 매개변수 `:slug` 같은 동적 세그먼트를 활용하면 더욱 깔끔하고 유연한 URL 구조를 만들 수 있죠.\n- 중첩 경로나 와일드카드 사용이 필요하다면 Next.js의 다른 기능들(ex. catch-all routes)을 활용하는 것도 좋은 방법입니다.\n\n이 기능을 잘 활용하면 URL 디자인을 자유롭게 변경하면서도, 기존에 만들어 둔 페이지 컴포넌트 재사용이 가능해집니다!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 와일드카드 경로 매칭 (Wildcard Path Matching)\n\nNext.js에서 와일드카드 경로를 매칭하고 싶다면, 경로 매개변수 뒤에 `*`를 붙여주면 돼요. 예를 들어 `/blog/:slug*` 라고 쓰면 `/blog/a/b/c/d/hello-world` 같은 경로도 한 번에 매칭이 된답니다.\n\n```js\nmodule.exports = {\n  async rewrites() {\n    return [\n      {\n        source: '/blog/:slug*',\n        destination: '/news/:slug*', // 매칭된 파라미터를 목적지 경로에서도 사용할 수 있어요\n      },\n    ]\n  },\n}\n```\n\n여기서 중요한 점!  \n`:slug*`에서 `*`는 이 뒤에 어떤 경로가 와도 다 잡아준다는 의미에요. 즉, `/blog/a`도 되고, `/blog/a/b/c`도 다 같은 규칙으로 잡히는 거죠.\n\n이걸 이용하면 블로그 포스트나 여러 단계로 깊은 경로를 리다이렉트할 때 아주 유용합니다.\n\n---\n\n### 정규식(Regex) 경로 매칭\n\nNext.js `rewrites` 설정에서 복잡한 경로 지정이 필요할 때는 정규식을 써서 더욱 세밀한 매칭도 가능해요.  \n정규식은 보통 문자열 패턴 매칭에 강력한 무기인 만큼, 유연한 라우팅 구현에 큰 도움이 됩니다.\n\n예를 들어, `/post/:id(\\\\d+)` 라는 경로는 숫자(id)가 들어가는 경로만 정확히 잡고 싶을 때 쓸 수 있어요.  \n즉 `/post/123`는 매칭되고 `/post/abc`는 매칭 안되도록 하는 거죠.\n\n---\n\n여기까지 와일드카드와 정규식 경로 매칭에 대해서 간단히 살펴봤는데요,  \n다음에는 정규식을 써서 실제로 어떻게 경로를 재작성하는지 예제를 들어서 더 쉽게 알려드릴게요!  \n궁금한 점 있으면 댓글로 남겨주세요.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n정규식(Regex)로 경로를 매칭하고 싶다면, 파라미터 뒤에 괄호() 안에 정규식을 감싸서 사용할 수 있어요. 예를 들어, `/blog/:slug(\\\\d{1,})`라고 하면 `/blog/123`처럼 숫자로만 된 경로는 매칭되고 `/blog/abc` 같은 문자는 매칭되지 않아요.\n\n아래 예시를 볼게요:\n\n```js\nmodule.exports = {\n  async rewrites() {\n    return [\n      {\n        source: '/old-blog/:post(\\\\d{1,})',\n        destination: '/blog/:post', // 매칭된 파라미터를 목적지 경로에서 사용할 수 있어요\n      },\n    ]\n  },\n}\n```\n\n위 코드에서 `:post(\\\\d{1,})`는 1자리 이상 숫자가 와야 매칭돼요. 그래서 `/old-blog/123`으로 요청하면 `/blog/123`으로 리다이렉트되는 거죠.\n\n---\n\n추가로, 정규식에서 특수문자들인 `(`, `)`, `'`, ` `, `[`, `]`, `|`, `\\`, `^`, `.`, `:`, `*`, `+`, `-`, `?`, `$` 같은 문자는 그냥 쓰면 안 되고, 그냥 문자열로 매칭하고 싶으면 반드시 앞에 역슬래시(`\\`)를 붙여서 이스케이프 해야 해요.\n\n예를 들어, 경로에 괄호가 포함된 pattern을 매칭하고 싶을 때는 이렇게 작성하시면 됩니다:\n\n```js\nmodule.exports = {\n  async rewrites() {\n    return [\n      {\n        // `/english(default)/something` 처럼 괄호가 포함된 경로를 매칭합니다\n        source: '/english\\\\(default\\\\)/:slug',\n        destination: '/en-us/:slug',\n      },\n    ]\n  },\n}\n```\n\n이 경우 `/english(default)/page1`로 들어오는 요청은 `/en-us/page1`으로 리다이렉트되죠.\n\n---\n\n정리하면, Next.js rewrites 등에서 경로 매칭 시 정규식을 사용할 때는\n\n- 파라미터 뒤에 괄호로 정규식을 감싸서 세부 매칭 조건을 줄 수 있고\n- 특수문자는 `\\\\`로 꼭 이스케이프해서 사용하세요.\n\n그래야 원하는 경로를 정확히 매칭할 수 있고 의도치 않은 오류를 예방할 수 있습니다. \n\n이 방식으로 유연하게 URL 경로 패턴을 조절해보세요! 개발할 때 알아두면 꽤 유용합니다.\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 헤더, 쿠키, 쿼리 매칭하기\n\n리라이트(rewrite)를 특정 조건에 맞출 때 헤더, 쿠키, 쿼리 값이 특정 값과 맞아야 하거나, 특정 값이 없어야 할 때도 있죠? 이럴 때 사용하는 게 바로 `has` 필드와 `missing` 필드입니다. \n\n여기서 중요한 점은, 리라이트가 적용되려면 **source**와 `has`에 정의된 모든 항목이 일치해야 하고, 동시에 `missing`에 정의된 항목은 전부 일치하지 않아야 한다는 거예요. 쉽게 말해, 필요한 건 있어야 하고 없어야 할 건 없어야 한다는 뜻이죠.\n\n### has와 missing에서 사용할 수 있는 항목들\n\n| 필드 이름 | 타입 | 설명 |\n|---|---|---|\n| type | String | `header`, `cookie`, `host`, `query` 중 하나로 요청의 어디를 검사할지 지정 |\n| key | String | 검사하려는 항목의 키(이름), 예를 들어 헤더 이름이나 쿠키 이름 등 |\n| value | String 또는 undefined | 검사할 값. 만약 `undefined`면 어떤 값이든 매치 |  \n\n특히 `value`에는 정규표현식처럼 작동하는 문자열도 쓸 수 있어요. 예를 들어, `first-(?paramName.*)`라는 값을 쓰면, 실제 값 `first-second`에서 `second` 부분만 뽑아서 나중에 리라이트 목적지(destination)에서 `:paramName`라는 이름으로 활용할 수 있다는 점도 참신하죠?\n\n---\n\n### 조금 더 풀어보자면\n\n- `has`는 “이것들이 있어야 한다”는 의미예요.\n- `missing`은 “이것들이 없어야 한다”는 조건이죠.\n\n예를 들어,\n\n- `has`에 `{ type: 'header', key: 'x-user', value: 'admin' }`가 있으면, `x-user` 헤더가 `admin`이어야 리라이트됩니다.\n- `missing`에 `{ type: 'cookie', key: 'session', value: undefined }`가 있으면, `session`이라는 쿠키가 없어야 리라이트가 적용됩니다.\n\n이런 조건들을 조합하면 꽤 상세하고 구체적인 요청 매칭을 할 수 있답니다!\n\n---\n\n이 기능을 활용하면 더 똑똑하고 유연한 리라이트를 구현할 수 있어서, 특정 조건에 따라 페이지를 다르게 보여주거나 API 요청처리를 달리 할 때 정말 유용해요. 다음에 직접 예제도 만들어서 보여드릴게요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js의 `rewrites` 기능을 사용하면 특정 요청에 대해 URL 경로를 내부 또는 외부 URL로 \"재작성(rewrite)\"할 수 있어요. 이 기능은 특히 점진적으로 Next.js를 도입하거나, 내부 URL을 사용자에게 숨기고 싶을 때 유용하게 쓰입니다.\n\n### 헤더, 쿼리, 쿠키, 호스트에 따른 rewrites 예시\n\n```js\nmodule.exports = {\n  async rewrites() {\n    return [\n      // 1. 요청 헤더에 'x-rewrite-me'가 있으면 '/another-page'로 보낸다\n      {\n        source: '/:path*',\n        has: [\n          { type: 'header', key: 'x-rewrite-me' },\n        ],\n        destination: '/another-page',\n      },\n      // 2. 요청 헤더에 'x-rewrite-me'가 없으면 '/another-page'로 보낸다\n      {\n        source: '/:path*',\n        missing: [\n          { type: 'header', key: 'x-rewrite-me' },\n        ],\n        destination: '/another-page',\n      },\n      // 3. 쿼리 'page=home'이고 쿠키 'authorized=true'일 때 '/specific/:path*/home'으로 보낸다\n      {\n        source: '/specific/:path*',\n        has: [\n          { type: 'query', key: 'page', value: 'home' },\n          { type: 'cookie', key: 'authorized', value: 'true' },\n        ],\n        destination: '/:path*/home',\n      },\n      // 4. 헤더 'x-authorized'에 'yes' 또는 'true'가 포함되어 있으면 '/home'에 쿼리로 authorized 값 붙이기\n      {\n        source: '/:path*',\n        has: [\n          { type: 'header', key: 'x-authorized', value: '(?\u003cauthorized\u003eyes|true)' },\n        ],\n        destination: '/home?authorized=:authorized',\n      },\n      // 5. 호스트가 'example.com'이면 '/another-page'로 보낸다\n      {\n        source: '/:path*',\n        has: [\n          { type: 'host', value: 'example.com' },\n        ],\n        destination: '/another-page',\n      },\n    ]\n  },\n}\n```\n\n위 예시에서 볼 수 있듯이, 단순히 경로만 보고 리다이렉트하는 게 아니라 헤더, 쿠키, 쿼리 파라미터, 심지어 호스트까지 고려해서 경로를 바꿀 수 있습니다. 만약 조건에 맞는 헤더가 있으면 rewrite를 다르게 적용하는 식으로 세밀한 컨트롤이 가능해요.\n\n---\n\n## 외부 URL로도 리라이트가 가능합니다!\n\n재밌는 점은 내부 페이지뿐 아니라 외부 URL로도 갈 수 있다는거예요. 예를 들어, 기존 웹사이트의 특정 경로를 Next.js 안에서 재작성해서 외부 사이트로 연결하고 싶을 때 아주 유용하죠.\n\n```js\nmodule.exports = {\n  async rewrites() {\n    return [\n      // '/blog' 경로는 https://example.com/blog 로 이동\n      {\n        source: '/blog',\n        destination: 'https://example.com/blog',\n      },\n      // '/blog/:slug' 경로도 https://example.com/blog/:slug 로 매칭되는 대로 이동\n      {\n        source: '/blog/:slug',\n        destination: 'https://example.com/blog/:slug',\n      },\n    ]\n  },\n}\n```\n\n이처럼 외부 URL도 `destination`에 바로 적으면 그쪽으로 요청을 보낼 수 있답니다. 특히 마이그레이션 기간에 기존 서비스와 신 서비스를 자연스럽게 연결할 때 매우 유용해요.\n\n---\n\n### 추가 팁!\n\n- **rewrites vs redirects:** rewrites는 URL을 바꿔서 서버에서 다른 페이지를 보여주지만, 실제 사용자에게는 원래 URL이 유지돼요. 반면 redirects는 사용자를 다른 URL로 실제로 이동시키고 브라우저 주소창도 바뀝니다.\n- **조건이 많을 때는 꼭 주의:** 너무 복잡한 조건을 걸면 관리하기 어려우니, 가독성을 고려해서 몇 개의 룰을 잘 분리해서 쓰는 게 좋아요.\n- **value를 안쓰거나 캡처 그룹을 쓰면 경로 파라미터 활용 가능:** 위 예시처럼 `(??\u003cauthorized\u003eyes|true)` 처럼 정규표현식 캡처 그룹을 쓰면 재작성 대상 경로에 캡처된 값을 쉽게 쓸 수 있어요.\n\n이제 필요에 따라 세밀하게 페이지 경로를 조작해보세요! Next.js rewrites 기능은 생각보다 강력해서 몇 가지 응용만 알면 정말 다양한 케이스에 적용할 수 있답니다. 🙂\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nnext.js에서 `trailingSlash: true` 설정을 사용할 때 꼭 알아둬야 할 점이 있어요. 바로 리다이렉트(rewrites) 설정할 때 `source` 경로 끝에도 꼭 슬래시(/)를 붙여줘야 한다는 거죠. 목적지(destination) URL도 마찬가지예요. 만약 원격 서버가 슬래시를 기대한다면 destination 경로 끝에도 슬래시를 붙여줘야 정상적으로 동작합니다.\n\n예를 들어, 아래와 같이 설정하면 `/blog/` 또는 `/blog/` 하위 경로로 들어오는 요청을 정확히 리다이렉트할 수 있어요.\n\n```js\nmodule.exports = {\n  trailingSlash: true,\n  async rewrites() {\n    return [\n      {\n        source: '/blog/',\n        destination: 'https://example.com/blog/',\n      },\n      {\n        source: '/blog/:path*/',\n        destination: 'https://example.com/blog/:path*/',\n      },\n    ]\n  },\n}\n```\n\n여기서 `:path*`는 와일드카드처럼 동작해서 `/blog/anything/here/` 같은 하위 경로도 전부 포괄해줍니다.\n\n---\n\n### Next.js 점진적 도입 (Incremental adoption)\n\n또 하나 재미있는 점은, 기존에 운영 중인 웹사이트가 있을 때 Next.js로 점진적으로 옮겨갈 수 있다는 거예요. Next.js가 먼저 자신의 라우트들을 검사한 후에 해당 경로가 없다면 기존 서버 쪽으로 프록시(proxy) 요청을 넘기는 방법이죠.\n\n이 방식을 사용하면 한 번에 모든 페이지를 Next.js로 옮기지 않아도 되고, 조금씩 옮기면서 안정적으로 서비스를 개선할 수 있답니다.\n\n---\n\n#### 추가 팁!\n\n- `trailingSlash` 옵션을 켜면 빌드된 정적 파일들도 자동으로 폴더 형식으로 생성됩니다. 예를 들어 `/about`은 `/about/index.html`로 만들어지고, 브라우저에서는 `/about/` URL로 접근하게 되죠.\n- 리다이렉트 설정에서 슬래시는 사소해 보여도, 이 부분이 틀리면 404 에러가 날 수 있으니 꼭 신경 써 주세요.\n- 점진적 도입을 고려한다면, Next.js의 `rewrites`와 `fallback` 기능을 적극 활용해보세요. 개발할 때 훨씬 유연해질 거예요!\n\n다음에도 Next.js 관련해서 재미있고 쓸모 있는 팁 있으면 계속 공유할게요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNext.js로 더 많은 페이지를 마이그레이션할 때, 리라이트(rewrites) 설정을 매번 바꿀 필요가 없도록 하는 방법을 알려 드릴게요.\n\n```js\nmodule.exports = {\n  async rewrites() {\n    return {\n      fallback: [\n        {\n          source: '/:path*',\n          destination: `https://custom-routes-proxying-endpoint.vercel.app/:path*`,\n        },\n      ],\n    }\n  },\n}\n```\n\n이렇게 하면 어떤 경로로 들어오든 `https://custom-routes-proxying-endpoint.vercel.app` 쪽으로 다 연결해주는 역할을 해요. 그래서 점진적으로 Next.js로 옮겨가는 중에도 기존 경로를 일일이 바꿀 필요 없이 한 번에 처리할 수 있죠.\n\n---\n\n### basePath 지원하는 리라이트\n\nNext.js에서 `basePath`를 사용하면서 리라이트를 할 때는 `source`와 `destination` 양쪽 경로 모두 자동으로 `basePath`가 앞에 붙어요. 만약 어떤 리라이트에서 `basePath`를 붙이고 싶지 않으면, 아래처럼 `basePath: false`를 추가하면 됩니다.\n\n```js\nmodule.exports = {\n  async rewrites() {\n    return {\n      fallback: [\n        {\n          source: '/custom-path/:path*',\n          destination: 'https://external-site.com/:path*',\n          basePath: false,  // basePath 자동 접두사 안붙임\n        },\n      ],\n    }\n  },\n}\n```\n\n이렇게 쓰면 `basePath`가 없는 그대로 외부 도메인 주소로 리다이렉션하게 돼요. \n\n---\n\n**추가 팁!**\n\n1. `rewrites`는 URL 경로를 클라이언트에게 그대로 보여주면서 내부적으로 다른 경로로 연결해주는 기능이에요. SEO나 UX에 민감한 상황에서 유용하죠.\n2. `fallback` 속성은 일치하는 리라이트 규칙이 없을 때 마지막으로 적용되는 규칙이라, 넓은 범위의 라우팅을 처리할 때 깔끔하게 쓸 수 있어요.\n3. 만약 API 요청 경로나 이미지 리퀘스트에 리라이트를 복잡하게 적용해야 한다면, 별도의 규칙으로 꼼꼼히 테스트해보세요.\n\nNext.js에서 라우팅을 다루는 게 어렵게 느껴질 수 있지만, 이런 설정들을 잘 활용하면 한결 유연하고 깔끔하게 관리할 수 있으니 꼭 한번 시도해보세요!\n\n\u003c!-- TIL 수평 --\u003e\n\u003cins class=\"adsbygoogle\"\n     style=\"display:block\"\n     data-ad-client=\"ca-pub-4877378276818686\"\n     data-ad-slot=\"1549334788\"\n     data-ad-format=\"auto\"\n     data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nmodule.exports = {\n  basePath: '/docs',\n\n  async rewrites() {\n    return [\n      {\n        source: '/with-basePath', // /docs/with-basePath로 자동 변환됨\n        destination: '/another',  // /docs/another로 자동 변환됨\n      },\n      {\n        // basePath: false가 설정되어 있어 /docs가 붙지 않음\n        // 참고: 내부 리다이렉트(예: destination: '/another')에는 사용할 수 없음\n        source: '/without-basePath',\n        destination: 'https://example.com',\n        basePath: false,\n      },\n    ]\n  },\n}\n```\n\n---\n\n## 버전 히스토리\n\n| Version   | Changes           |\n|-----------|-------------------|\n| `v13.3.0` | `missing` 추가됨  |\n| `v10.2.0` | `has` 추가됨      |\n| `v9.5.0`  | Headers 추가됨    |\n\n---\n\n### 살짝 더 알려드려요!\n\n- **basePath**는 Next.js에서 모든 경로 앞에 특정 기본 경로를 붙이고 싶을 때 사용해요. 예를 들어, 위 예제처럼 `basePath: '/docs'`를 설정하면, 모든 페이지와 API가 `/docs` 하위에 위치해요.  \n- `rewrites`는 요청 경로를 다른 경로나 외부 URL로 내부적으로 바꿔주는 역할을 하죠. 위 코드에서는 `/with-basePath` 요청이 `/docs/with-basePath`로, `/another` 경로로도 매핑되는 걸 볼 수 있어요.\n- 그런데 `basePath: false` 옵션이 들어간 리라이트는 좀 특별해요. 이 옵션을 주면 기본 경로가 붙지 않고, 외부 URL(예: `https://example.com`)로 바로 연결할 수 있어요. 다만, 내부 경로 리라이트에선 사용할 수 없으니 주의하세요.\n- 버전 히스토리를 보면 점차 기능이 추가되고 확장된 걸 알 수 있는데, 개발 중인 프로젝트에 필요한 기능이 어느 버전부터 생겼는지 참고하면 좋아요!\n\n다음에 또 재미있는 개발 팁 들고 올게요! 궁금한 점 있으면 언제든 물어봐 주세요~","ogImage":{"url":"/TIL/assets/img/nextjs.png"},"coverImage":"/TIL/assets/img/nextjs.png","tag":["Tech"],"readingTime":23},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch1\u003e리라이트(rewrites)란?\u003c/h1\u003e\n\u003cp\u003e리라이트는 들어오는 요청 경로를 다른 목적지 경로로 바꿔주는 기능이에요.\u003c/p\u003e\n\u003cp\u003e이걸 간단히 말하면, 사용자가 웹사이트에서 이동한 것처럼 보이지만 실제로는 다른 경로에서 데이터를 가져오는 거예요. URL 자체는 바뀌지 않아서 '나는 여전히 같은 페이지에 있어!'라고 느껴지게 만드는 거죠. 이 점에서 리다이렉트와 큰 차이가 있어요. 리다이렉트는 말 그대로 URL이 바뀌면서 새 페이지로 이동하게 되거든요.\u003c/p\u003e\n\u003cp\u003eNext.js에서 리라이트를 사용하고 싶다면, \u003ccode\u003enext.config.js\u003c/code\u003e 파일 안에 \u003ccode\u003erewrites\u003c/code\u003e 키를 활용하면 돼요.\u003c/p\u003e\n\u003cp\u003e예를 들어 이렇게 설정할 수 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erewrites\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e [\n      {\n        \u003cspan class=\"hljs-attr\"\u003esource\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/old-path/:slug*'\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003edestination\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/new-path/:slug*'\u003c/span\u003e,\n      },\n    ];\n  },\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 하면 사용자가 \u003ccode\u003e/old-path/anything\u003c/code\u003e 으로 요청해도 실제 서버에선 \u003ccode\u003e/new-path/anything\u003c/code\u003e 을 처리하지만, 브라우저 주소창은 그대로 \u003ccode\u003e/old-path/anything\u003c/code\u003e 으로 유지돼요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e추가 팁!\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e리라이트는 특히 API 경로나 내부 구조를 바꾸고 싶을 때 유용해요. 예를 들어, API 버전을 변경할 때 외부에는 이전 API 경로를 그대로 노출하면서 내부에서는 새 버전을 쓸 수 있죠.\u003c/li\u003e\n\u003cli\u003e다만 리라이트가 작동하려면 Next.js가 해당 목적지 URL을 처리할 수 있어야 해요. 외부 도메인으로는 리라이트가 불가능하니 참고하세요.\u003c/li\u003e\n\u003cli\u003e만약 URL이 바뀌는 걸 원한다면, 리다이렉트를 사용해야 하는 점 기억하세요!\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e리라이트를 잘 활용하면 사용자 경험을 훨씬 깔끔하게 유지하면서 서버 구조를 유연하게 바꿀 수 있답니다. 고민되는 부분 있으면 언제든 질문해 주세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eNext.js에서 \u003ccode\u003erewrites\u003c/code\u003e 설정을 쓰면 클라이언트 사이드 라우팅 시 URL 경로를 원하는 대로 바꿔서 보여줄 수 있어요. 예를 들어, 위 코드처럼 \u003ccode\u003e/about\u003c/code\u003e 경로를 \u003ccode\u003e/\u003c/code\u003e (홈 페이지)로 다시 매핑할 수 있죠.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erewrites\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e [\n      {\n        \u003cspan class=\"hljs-attr\"\u003esource\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/about'\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003edestination\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/'\u003c/span\u003e,\n      },\n    ]\n  },\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 하면 코드 안에서 \u003ccode\u003e\u0026#x3C;Link href=\"/about\"\u003e\u003c/code\u003e을 사용해도 실제로는 \u003ccode\u003e/\u003c/code\u003e 경로로 라우팅 됩니다.\u003c/p\u003e\n\u003ch3\u003erewrites 함수\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003easync 함수로, 반환값은 \u003cstrong\u003e객체 혹은 배열\u003c/strong\u003e 형태입니다.\u003c/li\u003e\n\u003cli\u003e반환 값 안에는 \u003ccode\u003e{ source, destination }\u003c/code\u003e 객체들이 들어가죠.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e속성명\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003esource\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e들어오는 요청의 경로 패턴 (예: \u003ccode\u003e/about\u003c/code\u003e)\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003edestination\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e실제로 라우팅할 경로\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ebasePath\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003efalse\u003c/code\u003e 혹은 \u003ccode\u003eundefined\u003c/code\u003e - \u003ccode\u003efalse\u003c/code\u003e면 기본 \u003ccode\u003ebasePath\u003c/code\u003e를 경로에서 제외 (외부 URL rewrite에 쓰임)\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003elocale\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003efalse\u003c/code\u003e 혹은 \u003ccode\u003eundefined\u003c/code\u003e - 지역화(locale) 경로 포함 여부 설정\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ehas\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e조건 배열 - 특정 헤더, 쿠키, 쿼리 값 등이 있을 때만 rewrite 적용 가능\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003emissing\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e조건 배열 - 특정 헤더, 쿠키, 쿼리 값이 없을 때만 rewrite 적용 가능\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003chr\u003e\n\u003ch3\u003e추가 팁!\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003erewrites\u003c/code\u003e는 URL을 '숨긴다'고 생각하면 쉬워요. 사용자가 \u003ccode\u003eabout\u003c/code\u003e 페이지로 접속한 것 같지만 실제론 루트 페이지를 보여주니까요.\u003c/li\u003e\n\u003cli\u003eSEO에 영향을 안 주고 프론트엔드에서 URL만 바꾸고 싶을 때 유용해요.\u003c/li\u003e\n\u003cli\u003e복잡한 조건문으로 특정 쿠키가 있거나 쿼리 파라미터에 따라 경로를 다르게 바꾸고 싶다면 \u003ccode\u003ehas\u003c/code\u003e나 \u003ccode\u003emissing\u003c/code\u003e 옵션을 이용해보세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e예를 들어:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-attr\"\u003erewrites\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e () =\u003e [\n  {\n    \u003cspan class=\"hljs-attr\"\u003esource\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/dashboard'\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003ehas\u003c/span\u003e: [\n      { \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'cookie'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'token'\u003c/span\u003e }, \u003cspan class=\"hljs-comment\"\u003e// 로그인 되어 있는 사람만 접근 가능하게 \u003c/span\u003e\n    ],\n    \u003cspan class=\"hljs-attr\"\u003edestination\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/dashboard'\u003c/span\u003e,\n  },\n  {\n    \u003cspan class=\"hljs-attr\"\u003esource\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/dashboard'\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003emissing\u003c/span\u003e: [\n      { \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'cookie'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'token'\u003c/span\u003e }, \u003cspan class=\"hljs-comment\"\u003e// 로그인 안 되어 있으면 로그인 페이지로 \u003c/span\u003e\n    ],\n    \u003cspan class=\"hljs-attr\"\u003edestination\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/login'\u003c/span\u003e,\n  },\n],\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 하면 사용자가 로그인이 되어 있는지 쿠키로 검사해 조건부 리다이렉트도 구현할 수 있어요.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003eNext.js 공식 문서에서는 \u003ccode\u003erewrites\u003c/code\u003e 외에도 \u003ccode\u003eredirects\u003c/code\u003e, \u003ccode\u003eheaders\u003c/code\u003e 같은 유용한 설정들을 제공하니, 사이트 라우팅 컨트롤이 필요할 때 꼭 한 번 정독해보세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eNext.js에서 rewrites 설정을 다룰 때, \u003ccode\u003erewrites\u003c/code\u003e 함수가 배열을 반환하면, 이 리라이트(재작성) 규칙들은 파일 시스템(페이지와 /public 파일) 확인 후, 동적 라우트 검사 전에 적용돼요. 그런데 Next.js 10.1 버전부터는 \u003ccode\u003erewrites\u003c/code\u003e 함수가 특정 구조의 객체 안에 배열들을 반환할 수 있는데요, 이 방식은 리라이트가 적용되는 타이밍을 좀 더 세밀하게 조정할 수 있게 해 줍니다.\u003c/p\u003e\n\u003cp\u003e아래 코드를 보면 각 배열이 어떤 역할을 하는지 쉽게 이해할 수 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erewrites\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n      \u003cspan class=\"hljs-attr\"\u003ebeforeFiles\u003c/span\u003e: [\n        \u003cspan class=\"hljs-comment\"\u003e// headers/redirects 확인 후, 모든 파일 (예: _next/public 포함) 확인 전\u003c/span\u003e\n        \u003cspan class=\"hljs-comment\"\u003e// 여기에 선언한 리라이트들은 페이지 파일들을 덮어쓸 수도 있어요\u003c/span\u003e\n        {\n          \u003cspan class=\"hljs-attr\"\u003esource\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/some-page'\u003c/span\u003e,\n          \u003cspan class=\"hljs-attr\"\u003edestination\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/somewhere-else'\u003c/span\u003e,\n          \u003cspan class=\"hljs-attr\"\u003ehas\u003c/span\u003e: [{ \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'query'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'overrideMe'\u003c/span\u003e }],\n        },\n      ],\n      \u003cspan class=\"hljs-attr\"\u003eafterFiles\u003c/span\u003e: [\n        \u003cspan class=\"hljs-comment\"\u003e// 페이지와 public 파일 확인 후, 동적 라우트 검사 전\u003c/span\u003e\n        {\n          \u003cspan class=\"hljs-attr\"\u003esource\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/non-existent'\u003c/span\u003e,\n          \u003cspan class=\"hljs-attr\"\u003edestination\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/somewhere-else'\u003c/span\u003e,\n        },\n      ],\n      \u003cspan class=\"hljs-attr\"\u003efallback\u003c/span\u003e: [\n        \u003cspan class=\"hljs-comment\"\u003e// 페이지/public 파일과 동적 라우트 모두 확인 후\u003c/span\u003e\n        {\n          \u003cspan class=\"hljs-attr\"\u003esource\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/:path*'\u003c/span\u003e,\n          \u003cspan class=\"hljs-attr\"\u003edestination\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e`https://my-old-site.com/:path*`\u003c/span\u003e,\n        },\n      ],\n    }\n  },\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e테이블로 정리하면 이렇게 볼 수 있어요\u003c/h3\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e구분\u003c/th\u003e\u003cth\u003e적용 시점\u003c/th\u003e\u003cth\u003e특징 및 설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ebeforeFiles\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eheaders/redirects 검사 후, 파일 시스템 검사(페이지, public) 전\u003c/td\u003e\u003ctd\u003e페이지 파일 덮어쓰기 가능, 모든 \u003ccode\u003ebeforeFiles\u003c/code\u003e가 확인될 때까지 계속 검사\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003eafterFiles\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e페이지 및 public 파일 확인 후, 동적 라우트 확인 전\u003c/td\u003e\u003ctd\u003e일반 파일은 없고 동적 라우트는 남아있을 때 사용\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003efallback\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e페이지/public 파일과 동적 라우트 검사 모두 완료 후\u003c/td\u003e\u003ctd\u003e모든 검사 끝난 후 리라이트를 적용, 외부 사이트로 프록시 등 활용 가능\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003chr\u003e\n\u003ch3\u003e좀 더 알려볼게요!\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003ebeforeFiles\u003c/code\u003e 내 리라이트는 매칭되더라도 모든 \u003ccode\u003ebeforeFiles\u003c/code\u003e 배열의 규칙들을 다 검사해요.\u003c/strong\u003e 즉, 첫번째 매치에서 멈추지 않고, 다음 규칙도 계속 확인하는 거죠. 이는 오버라이드나 여러 조건에 유리해요.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e여러분이 리라이트를 통해 어떤 페이지를 완전히 다른 페이지로 교체하거나(예: A → B), 혹은 외부 URL로 프록시하려면 \u003ccode\u003efallback\u003c/code\u003e 위치에 정의하는 게 적합해요.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e동적 라우트(\u003ccode\u003e/:id\u003c/code\u003e 같은 경로)를 조작하고 싶다면 \u003ccode\u003eafterFiles\u003c/code\u003e 위치를 활용하면 되는데요, 이 영역은 기본 페이지, public 파일 검사를 마친 후에 처리됩니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e파일 시스템 검사(실제로 그 경로에 맞는 파일이나 페이지가 있는지 확인)는 성능에도 영향을 끼치기 때문에, 필요한 경우에만 세밀하게 조절하는 게 중요해요.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3\u003e마무리\u003c/h3\u003e\n\u003cp\u003eNext.js의 rewrites 기능, 특히 v10.1 이후 객체 모양의 \u003ccode\u003erewrites\u003c/code\u003e 반환은 라우팅 제어를 정말 유연하게 만들어줍니다. 상황에 맞게 \u003ccode\u003ebeforeFiles\u003c/code\u003e, \u003ccode\u003eafterFiles\u003c/code\u003e, \u003ccode\u003efallback\u003c/code\u003e을 잘 조합해서, 내가 원하는 대로 페이지 흐름을 완벽하게 관리해 보세요! 개발자의 상상력과 요구에 유연하게 대응할 수 있다는 점이 Next.js의 큰 장점 중 하나랍니다.\u003c/p\u003e\n\u003cp\u003e필요하면 다음에 \u003ccode\u003eredirects\u003c/code\u003e와 \u003ccode\u003eheaders\u003c/code\u003e 설정에 대해서도 재미있고 쉽게 설명해 드릴게요! 😊\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eNext.js에서 라우팅과 리다이렉트, 그리고 리라이트(rewrite)가 어떻게 작동하는지 한번 정리해볼게요. 개발할 때 이 흐름을 이해하고 있으면 문제 생겼을 때 원인 찾기가 훨씬 수월해져요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003eNext.js 요청 처리 순서\u003c/h3\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e순서\u003c/th\u003e\u003cth\u003e처리 내용\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e1\u003c/td\u003e\u003ctd\u003e헤더(headers) 체크 및 적용\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e2\u003c/td\u003e\u003ctd\u003e리다이렉트(redirects) 체크 및 적용\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e3\u003c/td\u003e\u003ctd\u003e\u003ccode\u003ebeforeFiles\u003c/code\u003e 리라이트(rewrites) 체크 및 적용\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e4\u003c/td\u003e\u003ctd\u003e정적 파일(public 디렉토리, \u003ccode\u003e_next/static\u003c/code\u003e 파일)과 비동적(non-dynamic) 페이지를 체크 및 서빙\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e5\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eafterFiles\u003c/code\u003e 리라이트 체크 및 적용 — 여기서 매칭되면 다이나믹 라우트나 정적 파일을 다시 체크\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e6\u003c/td\u003e\u003ctd\u003efallback 리라이트 체크 및 적용 — 404 페이지를 렌더링하기 전에, 다이나믹 라우트와 정적 자산 모두 체크한 뒤 수행. getStaticPaths에서 \u003ccode\u003efallback: true\u003c/code\u003e나 \u003ccode\u003eblocking\u003c/code\u003e을 사용했다면 이 fallback 리라이트는 실행되지 않습니다.\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003chr\u003e\n\u003ch3\u003e리라이트(rewrite)에서 파라미터 사용 시 참고\u003c/h3\u003e\n\u003cp\u003e리라이트 할 때 \u003cstrong\u003edestination\u003c/strong\u003e URL에 파라미터를 직접 사용하지 않으면, 자동으로 쿼리(query)로 전달돼요.\u003c/p\u003e\n\u003cp\u003e예를 들어,\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erewrites\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e [\n      {\n        \u003cspan class=\"hljs-attr\"\u003esource\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/old-about/:path*'\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003edestination\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/about'\u003c/span\u003e,  \u003cspan class=\"hljs-comment\"\u003e// 여기서는 :path를 직접 쓰지 않았으니 쿼리로 전달됨\u003c/span\u003e\n      },\n    ]\n  },\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위처럼 작성하면 \u003ccode\u003e/old-about/some/page\u003c/code\u003e 로 접속했을 때, \u003ccode\u003e/about?path=some/page\u003c/code\u003e로 처리되는 셈이에요.\u003c/p\u003e\n\u003cp\u003e만약 파라미터를 destination에 포함시키고 싶다면 이렇게 써야 해요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-attr\"\u003edestination\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/about/:path*'\u003c/span\u003e,\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그러면 \u003ccode\u003e/old-about/whatever\u003c/code\u003e가 \u003ccode\u003e/about/whatever\u003c/code\u003e로 바로 바뀌죠.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e이런 내용이 왜 중요하냐면?\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e리다이렉트는 URL을 완전히 바꿔서 클라이언트가 새 주소로 이동하도록 하는 반면\u003c/li\u003e\n\u003cli\u003e리라이트는 내부적으로 경로를 변경해서 유저는 주소가 변하지 않는 것처럼 유지하면서 다른 페이지나 리소스를 보여줄 수 있어요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e그래서 이미지 요청이나 API 프록시, 특정 조건에서 페이지 렌더링 방식을 유연하게 제어할 때 리라이트를 많이 씁니다.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e혹시 Next.js 라우팅, 리다이렉트, 리라이트 중 어디에 더 궁금한 점 있으면 언제든 질문 주세요! 직접 써보고 경험한 팁도 더 알려드릴게요.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eNext.js에서 \u003ccode\u003erewrites\u003c/code\u003e 설정을 할 때, 이 부분이 살짝 헷갈릴 수 있는데요. 오늘은 \u003ccode\u003erewrites\u003c/code\u003e에서 파라미터가 목적지(\u003ccode\u003edestination\u003c/code\u003e)에 어떻게 전달되는지, 그리고 자동으로 쿼리로 넘어가지 않는 경우를 함께 살펴볼게요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e파라미터가 목적지에 사용될 경우, 다른 파라미터는 쿼리에 자동으로 전달되지 않아요\u003c/h3\u003e\n\u003cp\u003e다음 코드를 보시면,\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erewrites\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e [\n      {\n        \u003cspan class=\"hljs-attr\"\u003esource\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/docs/:path*'\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003edestination\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/:path*'\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// :path 파라미터를 destination에서 이미 사용하고 있어요.\u003c/span\u003e\n      },\n    ]\n  },\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003esource\u003c/code\u003e에 \u003ccode\u003e/docs/:path*\u003c/code\u003e가 있는데, \u003ccode\u003edestination\u003c/code\u003e에서도 똑같이 \u003ccode\u003e/:path*\u003c/code\u003e를 사용 중이에요. 중요한 점은 이렇게 \u003ccode\u003edestination\u003c/code\u003e에서 이미 파라미터를 사용하면, 나머지 파라미터는 \u003cstrong\u003e자동으로 쿼리 스트링에 전달되지 않는다\u003c/strong\u003e는 것!\u003c/p\u003e\n\u003cp\u003e즉, 만약 다른 파라미터가 있었다면 자동으로 \u003ccode\u003e?파라미터=값\u003c/code\u003e 형태로 넘겨주지 않으니 주의해야 해요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e쿼리 파라미터를 직접 지정하면 수동으로 전달할 수 있어요\u003c/h3\u003e\n\u003cp\u003e필요해서 쿼리에도 파라미터를 넘기고 싶다면 이렇게 직접 명시해주면 됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erewrites\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e [\n      {\n        \u003cspan class=\"hljs-attr\"\u003esource\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/:first/:second'\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003edestination\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/:first?second=:second'\u003c/span\u003e,\n        \u003cspan class=\"hljs-comment\"\u003e// :first는 destination 경로에서 이미 사용중이라,\u003c/span\u003e\n        \u003cspan class=\"hljs-comment\"\u003e// :second는 자동 쿼리 전달이 안 되는데 직접 쿼리에 넣어줬어요.\u003c/span\u003e\n      },\n    ]\n  },\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003e/:first/:second\u003c/code\u003e 경로에서 \u003ccode\u003edestination\u003c/code\u003e이 \u003ccode\u003e/:first?second=:second\u003c/code\u003e이니, \u003ccode\u003efirst\u003c/code\u003e는 경로에, \u003ccode\u003esecond\u003c/code\u003e는 쿼리스트링에 직접 넣어주면서 목적지 URL을 생성합니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e어떻게 활용하면 좋을까?\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e복잡한 URL 매핑 할 때 각 파라미터를 어떻게 쓸지 정리하기 편해요.\u003c/li\u003e\n\u003cli\u003e특정 파라미터를 경로에 반드시 넣어야 할 때, 나머지는 쿼리로 주고 싶다면 위처럼 수동 지정해야 합니다.\u003c/li\u003e\n\u003cli\u003e자동 쿼리 전달이 원치 않는 경우에도 활용할 수 있죠.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3\u003e참고: Next.js \u003ccode\u003erewrites\u003c/code\u003e 공식 문서\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://nextjs.org/docs/api-reference/next.config.js/rewrites\" rel=\"nofollow\" target=\"_blank\"\u003eNext.js Rewrites 공식 문서\u003c/a\u003e에서 더 다양한 예시와 옵션을 확인할 수 있으니, 실제 프로젝트에 바로 적용하기 전에 한 번쯤 훑어보시길 추천드려요!\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e재미있는 점은, 이런 기본 동작을 이해하면 라우팅을 더 유연하게 다룰 수 있다는 거예요. 다음에도 이런 실용적인 팁으로 찾아올게요. 궁금한 점 있으면 언제든 질문 환영입니다! 😄\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cblockquote\u003e\n\u003cp\u003e참고할 점: Automatic Static Optimization이나 rewrites에서 사용하는 prerendering 파라미터를 통해 생성된 정적 페이지들은 hydration 이후 클라이언트에서 파싱되고, 이 정보가 쿼리로 제공됩니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003e경로 매칭(Path Matching)\u003c/h2\u003e\n\u003cp\u003eNext.js에서 경로 매칭은 매우 유연하게 사용할 수 있는데요. 예를 들어 \u003ccode\u003e/blog/:slug\u003c/code\u003e 같은 패턴은 \u003ccode\u003e/blog/hello-world\u003c/code\u003e 같은 경로와 매칭됩니다. 여기서 \u003ccode\u003e:slug\u003c/code\u003e는 동적으로 변할 수 있는 부분입니다. 단, 중첩된 경로(예: \u003ccode\u003e/blog/2023/03\u003c/code\u003e 같은)는 매칭하지 않으니 참고하세요.\u003c/p\u003e\n\u003cp\u003e다음은 \u003ccode\u003erewrites\u003c/code\u003e 설정 예시입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erewrites\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e [\n      {\n        \u003cspan class=\"hljs-attr\"\u003esource\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/blog/:slug'\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003edestination\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/news/:slug'\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 매칭된 파라미터를 destination 경로에서도 사용할 수 있습니다.\u003c/span\u003e\n      },\n    ]\n  },\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e좀 더 알아보기\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003erewrites\u003c/code\u003e는 클라이언트가 요청한 URL을 내부적으로 다른 경로로 매핑해 주는 기능이라, 실제로 URL은 바뀌지 않으면서 다른 페이지의 콘텐츠를 보여줄 수 있습니다.\u003c/li\u003e\n\u003cli\u003e매개변수 \u003ccode\u003e:slug\u003c/code\u003e 같은 동적 세그먼트를 활용하면 더욱 깔끔하고 유연한 URL 구조를 만들 수 있죠.\u003c/li\u003e\n\u003cli\u003e중첩 경로나 와일드카드 사용이 필요하다면 Next.js의 다른 기능들(ex. catch-all routes)을 활용하는 것도 좋은 방법입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 기능을 잘 활용하면 URL 디자인을 자유롭게 변경하면서도, 기존에 만들어 둔 페이지 컴포넌트 재사용이 가능해집니다!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch3\u003e와일드카드 경로 매칭 (Wildcard Path Matching)\u003c/h3\u003e\n\u003cp\u003eNext.js에서 와일드카드 경로를 매칭하고 싶다면, 경로 매개변수 뒤에 \u003ccode\u003e*\u003c/code\u003e를 붙여주면 돼요. 예를 들어 \u003ccode\u003e/blog/:slug*\u003c/code\u003e 라고 쓰면 \u003ccode\u003e/blog/a/b/c/d/hello-world\u003c/code\u003e 같은 경로도 한 번에 매칭이 된답니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erewrites\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e [\n      {\n        \u003cspan class=\"hljs-attr\"\u003esource\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/blog/:slug*'\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003edestination\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/news/:slug*'\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 매칭된 파라미터를 목적지 경로에서도 사용할 수 있어요\u003c/span\u003e\n      },\n    ]\n  },\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 중요한 점!\u003cbr\u003e\n\u003ccode\u003e:slug*\u003c/code\u003e에서 \u003ccode\u003e*\u003c/code\u003e는 이 뒤에 어떤 경로가 와도 다 잡아준다는 의미에요. 즉, \u003ccode\u003e/blog/a\u003c/code\u003e도 되고, \u003ccode\u003e/blog/a/b/c\u003c/code\u003e도 다 같은 규칙으로 잡히는 거죠.\u003c/p\u003e\n\u003cp\u003e이걸 이용하면 블로그 포스트나 여러 단계로 깊은 경로를 리다이렉트할 때 아주 유용합니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e정규식(Regex) 경로 매칭\u003c/h3\u003e\n\u003cp\u003eNext.js \u003ccode\u003erewrites\u003c/code\u003e 설정에서 복잡한 경로 지정이 필요할 때는 정규식을 써서 더욱 세밀한 매칭도 가능해요.\u003cbr\u003e\n정규식은 보통 문자열 패턴 매칭에 강력한 무기인 만큼, 유연한 라우팅 구현에 큰 도움이 됩니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, \u003ccode\u003e/post/:id(\\\\d+)\u003c/code\u003e 라는 경로는 숫자(id)가 들어가는 경로만 정확히 잡고 싶을 때 쓸 수 있어요.\u003cbr\u003e\n즉 \u003ccode\u003e/post/123\u003c/code\u003e는 매칭되고 \u003ccode\u003e/post/abc\u003c/code\u003e는 매칭 안되도록 하는 거죠.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e여기까지 와일드카드와 정규식 경로 매칭에 대해서 간단히 살펴봤는데요,\u003cbr\u003e\n다음에는 정규식을 써서 실제로 어떻게 경로를 재작성하는지 예제를 들어서 더 쉽게 알려드릴게요!\u003cbr\u003e\n궁금한 점 있으면 댓글로 남겨주세요.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003e정규식(Regex)로 경로를 매칭하고 싶다면, 파라미터 뒤에 괄호() 안에 정규식을 감싸서 사용할 수 있어요. 예를 들어, \u003ccode\u003e/blog/:slug(\\\\d{1,})\u003c/code\u003e라고 하면 \u003ccode\u003e/blog/123\u003c/code\u003e처럼 숫자로만 된 경로는 매칭되고 \u003ccode\u003e/blog/abc\u003c/code\u003e 같은 문자는 매칭되지 않아요.\u003c/p\u003e\n\u003cp\u003e아래 예시를 볼게요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erewrites\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e [\n      {\n        \u003cspan class=\"hljs-attr\"\u003esource\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/old-blog/:post(\\\\d{1,})'\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003edestination\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/blog/:post'\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 매칭된 파라미터를 목적지 경로에서 사용할 수 있어요\u003c/span\u003e\n      },\n    ]\n  },\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드에서 \u003ccode\u003e:post(\\\\d{1,})\u003c/code\u003e는 1자리 이상 숫자가 와야 매칭돼요. 그래서 \u003ccode\u003e/old-blog/123\u003c/code\u003e으로 요청하면 \u003ccode\u003e/blog/123\u003c/code\u003e으로 리다이렉트되는 거죠.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e추가로, 정규식에서 특수문자들인 \u003ccode\u003e(\u003c/code\u003e, \u003ccode\u003e)\u003c/code\u003e, \u003ccode\u003e'\u003c/code\u003e, \u003ccode\u003e \u003c/code\u003e, \u003ccode\u003e[\u003c/code\u003e, \u003ccode\u003e]\u003c/code\u003e, \u003ccode\u003e|\u003c/code\u003e, \u003ccode\u003e\\\u003c/code\u003e, \u003ccode\u003e^\u003c/code\u003e, \u003ccode\u003e.\u003c/code\u003e, \u003ccode\u003e:\u003c/code\u003e, \u003ccode\u003e*\u003c/code\u003e, \u003ccode\u003e+\u003c/code\u003e, \u003ccode\u003e-\u003c/code\u003e, \u003ccode\u003e?\u003c/code\u003e, \u003ccode\u003e$\u003c/code\u003e 같은 문자는 그냥 쓰면 안 되고, 그냥 문자열로 매칭하고 싶으면 반드시 앞에 역슬래시(\u003ccode\u003e\\\u003c/code\u003e)를 붙여서 이스케이프 해야 해요.\u003c/p\u003e\n\u003cp\u003e예를 들어, 경로에 괄호가 포함된 pattern을 매칭하고 싶을 때는 이렇게 작성하시면 됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erewrites\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e [\n      {\n        \u003cspan class=\"hljs-comment\"\u003e// `/english(default)/something` 처럼 괄호가 포함된 경로를 매칭합니다\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003esource\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/english\\\\(default\\\\)/:slug'\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003edestination\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/en-us/:slug'\u003c/span\u003e,\n      },\n    ]\n  },\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 경우 \u003ccode\u003e/english(default)/page1\u003c/code\u003e로 들어오는 요청은 \u003ccode\u003e/en-us/page1\u003c/code\u003e으로 리다이렉트되죠.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e정리하면, Next.js rewrites 등에서 경로 매칭 시 정규식을 사용할 때는\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e파라미터 뒤에 괄호로 정규식을 감싸서 세부 매칭 조건을 줄 수 있고\u003c/li\u003e\n\u003cli\u003e특수문자는 \u003ccode\u003e\\\\\u003c/code\u003e로 꼭 이스케이프해서 사용하세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e그래야 원하는 경로를 정확히 매칭할 수 있고 의도치 않은 오류를 예방할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 방식으로 유연하게 URL 경로 패턴을 조절해보세요! 개발할 때 알아두면 꽤 유용합니다.\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003ch2\u003e헤더, 쿠키, 쿼리 매칭하기\u003c/h2\u003e\n\u003cp\u003e리라이트(rewrite)를 특정 조건에 맞출 때 헤더, 쿠키, 쿼리 값이 특정 값과 맞아야 하거나, 특정 값이 없어야 할 때도 있죠? 이럴 때 사용하는 게 바로 \u003ccode\u003ehas\u003c/code\u003e 필드와 \u003ccode\u003emissing\u003c/code\u003e 필드입니다.\u003c/p\u003e\n\u003cp\u003e여기서 중요한 점은, 리라이트가 적용되려면 \u003cstrong\u003esource\u003c/strong\u003e와 \u003ccode\u003ehas\u003c/code\u003e에 정의된 모든 항목이 일치해야 하고, 동시에 \u003ccode\u003emissing\u003c/code\u003e에 정의된 항목은 전부 일치하지 않아야 한다는 거예요. 쉽게 말해, 필요한 건 있어야 하고 없어야 할 건 없어야 한다는 뜻이죠.\u003c/p\u003e\n\u003ch3\u003ehas와 missing에서 사용할 수 있는 항목들\u003c/h3\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e필드 이름\u003c/th\u003e\u003cth\u003e타입\u003c/th\u003e\u003cth\u003e설명\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003etype\u003c/td\u003e\u003ctd\u003eString\u003c/td\u003e\u003ctd\u003e\u003ccode\u003eheader\u003c/code\u003e, \u003ccode\u003ecookie\u003c/code\u003e, \u003ccode\u003ehost\u003c/code\u003e, \u003ccode\u003equery\u003c/code\u003e 중 하나로 요청의 어디를 검사할지 지정\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003ekey\u003c/td\u003e\u003ctd\u003eString\u003c/td\u003e\u003ctd\u003e검사하려는 항목의 키(이름), 예를 들어 헤더 이름이나 쿠키 이름 등\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003evalue\u003c/td\u003e\u003ctd\u003eString 또는 undefined\u003c/td\u003e\u003ctd\u003e검사할 값. 만약 \u003ccode\u003eundefined\u003c/code\u003e면 어떤 값이든 매치\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e특히 \u003ccode\u003evalue\u003c/code\u003e에는 정규표현식처럼 작동하는 문자열도 쓸 수 있어요. 예를 들어, \u003ccode\u003efirst-(?paramName.*)\u003c/code\u003e라는 값을 쓰면, 실제 값 \u003ccode\u003efirst-second\u003c/code\u003e에서 \u003ccode\u003esecond\u003c/code\u003e 부분만 뽑아서 나중에 리라이트 목적지(destination)에서 \u003ccode\u003e:paramName\u003c/code\u003e라는 이름으로 활용할 수 있다는 점도 참신하죠?\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e조금 더 풀어보자면\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ehas\u003c/code\u003e는 “이것들이 있어야 한다”는 의미예요.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emissing\u003c/code\u003e은 “이것들이 없어야 한다”는 조건이죠.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e예를 들어,\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ehas\u003c/code\u003e에 \u003ccode\u003e{ type: 'header', key: 'x-user', value: 'admin' }\u003c/code\u003e가 있으면, \u003ccode\u003ex-user\u003c/code\u003e 헤더가 \u003ccode\u003eadmin\u003c/code\u003e이어야 리라이트됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emissing\u003c/code\u003e에 \u003ccode\u003e{ type: 'cookie', key: 'session', value: undefined }\u003c/code\u003e가 있으면, \u003ccode\u003esession\u003c/code\u003e이라는 쿠키가 없어야 리라이트가 적용됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이런 조건들을 조합하면 꽤 상세하고 구체적인 요청 매칭을 할 수 있답니다!\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e이 기능을 활용하면 더 똑똑하고 유연한 리라이트를 구현할 수 있어서, 특정 조건에 따라 페이지를 다르게 보여주거나 API 요청처리를 달리 할 때 정말 유용해요. 다음에 직접 예제도 만들어서 보여드릴게요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eNext.js의 \u003ccode\u003erewrites\u003c/code\u003e 기능을 사용하면 특정 요청에 대해 URL 경로를 내부 또는 외부 URL로 \"재작성(rewrite)\"할 수 있어요. 이 기능은 특히 점진적으로 Next.js를 도입하거나, 내부 URL을 사용자에게 숨기고 싶을 때 유용하게 쓰입니다.\u003c/p\u003e\n\u003ch3\u003e헤더, 쿼리, 쿠키, 호스트에 따른 rewrites 예시\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erewrites\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e [\n      \u003cspan class=\"hljs-comment\"\u003e// 1. 요청 헤더에 'x-rewrite-me'가 있으면 '/another-page'로 보낸다\u003c/span\u003e\n      {\n        \u003cspan class=\"hljs-attr\"\u003esource\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/:path*'\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003ehas\u003c/span\u003e: [\n          { \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'header'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'x-rewrite-me'\u003c/span\u003e },\n        ],\n        \u003cspan class=\"hljs-attr\"\u003edestination\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/another-page'\u003c/span\u003e,\n      },\n      \u003cspan class=\"hljs-comment\"\u003e// 2. 요청 헤더에 'x-rewrite-me'가 없으면 '/another-page'로 보낸다\u003c/span\u003e\n      {\n        \u003cspan class=\"hljs-attr\"\u003esource\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/:path*'\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003emissing\u003c/span\u003e: [\n          { \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'header'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'x-rewrite-me'\u003c/span\u003e },\n        ],\n        \u003cspan class=\"hljs-attr\"\u003edestination\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/another-page'\u003c/span\u003e,\n      },\n      \u003cspan class=\"hljs-comment\"\u003e// 3. 쿼리 'page=home'이고 쿠키 'authorized=true'일 때 '/specific/:path*/home'으로 보낸다\u003c/span\u003e\n      {\n        \u003cspan class=\"hljs-attr\"\u003esource\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/specific/:path*'\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003ehas\u003c/span\u003e: [\n          { \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'query'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'page'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'home'\u003c/span\u003e },\n          { \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'cookie'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'authorized'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'true'\u003c/span\u003e },\n        ],\n        \u003cspan class=\"hljs-attr\"\u003edestination\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/:path*/home'\u003c/span\u003e,\n      },\n      \u003cspan class=\"hljs-comment\"\u003e// 4. 헤더 'x-authorized'에 'yes' 또는 'true'가 포함되어 있으면 '/home'에 쿼리로 authorized 값 붙이기\u003c/span\u003e\n      {\n        \u003cspan class=\"hljs-attr\"\u003esource\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/:path*'\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003ehas\u003c/span\u003e: [\n          { \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'header'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'x-authorized'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'(?\u0026#x3C;authorized\u003eyes|true)'\u003c/span\u003e },\n        ],\n        \u003cspan class=\"hljs-attr\"\u003edestination\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/home?authorized=:authorized'\u003c/span\u003e,\n      },\n      \u003cspan class=\"hljs-comment\"\u003e// 5. 호스트가 'example.com'이면 '/another-page'로 보낸다\u003c/span\u003e\n      {\n        \u003cspan class=\"hljs-attr\"\u003esource\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/:path*'\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003ehas\u003c/span\u003e: [\n          { \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'host'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'example.com'\u003c/span\u003e },\n        ],\n        \u003cspan class=\"hljs-attr\"\u003edestination\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/another-page'\u003c/span\u003e,\n      },\n    ]\n  },\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 예시에서 볼 수 있듯이, 단순히 경로만 보고 리다이렉트하는 게 아니라 헤더, 쿠키, 쿼리 파라미터, 심지어 호스트까지 고려해서 경로를 바꿀 수 있습니다. 만약 조건에 맞는 헤더가 있으면 rewrite를 다르게 적용하는 식으로 세밀한 컨트롤이 가능해요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003e외부 URL로도 리라이트가 가능합니다!\u003c/h2\u003e\n\u003cp\u003e재밌는 점은 내부 페이지뿐 아니라 외부 URL로도 갈 수 있다는거예요. 예를 들어, 기존 웹사이트의 특정 경로를 Next.js 안에서 재작성해서 외부 사이트로 연결하고 싶을 때 아주 유용하죠.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erewrites\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e [\n      \u003cspan class=\"hljs-comment\"\u003e// '/blog' 경로는 https://example.com/blog 로 이동\u003c/span\u003e\n      {\n        \u003cspan class=\"hljs-attr\"\u003esource\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/blog'\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003edestination\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'https://example.com/blog'\u003c/span\u003e,\n      },\n      \u003cspan class=\"hljs-comment\"\u003e// '/blog/:slug' 경로도 https://example.com/blog/:slug 로 매칭되는 대로 이동\u003c/span\u003e\n      {\n        \u003cspan class=\"hljs-attr\"\u003esource\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/blog/:slug'\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003edestination\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'https://example.com/blog/:slug'\u003c/span\u003e,\n      },\n    ]\n  },\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이처럼 외부 URL도 \u003ccode\u003edestination\u003c/code\u003e에 바로 적으면 그쪽으로 요청을 보낼 수 있답니다. 특히 마이그레이션 기간에 기존 서비스와 신 서비스를 자연스럽게 연결할 때 매우 유용해요.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003e추가 팁!\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003erewrites vs redirects:\u003c/strong\u003e rewrites는 URL을 바꿔서 서버에서 다른 페이지를 보여주지만, 실제 사용자에게는 원래 URL이 유지돼요. 반면 redirects는 사용자를 다른 URL로 실제로 이동시키고 브라우저 주소창도 바뀝니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e조건이 많을 때는 꼭 주의:\u003c/strong\u003e 너무 복잡한 조건을 걸면 관리하기 어려우니, 가독성을 고려해서 몇 개의 룰을 잘 분리해서 쓰는 게 좋아요.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003evalue를 안쓰거나 캡처 그룹을 쓰면 경로 파라미터 활용 가능:\u003c/strong\u003e 위 예시처럼 \u003ccode\u003e(??\u0026#x3C;authorized\u003eyes|true)\u003c/code\u003e 처럼 정규표현식 캡처 그룹을 쓰면 재작성 대상 경로에 캡처된 값을 쉽게 쓸 수 있어요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이제 필요에 따라 세밀하게 페이지 경로를 조작해보세요! Next.js rewrites 기능은 생각보다 강력해서 몇 가지 응용만 알면 정말 다양한 케이스에 적용할 수 있답니다. 🙂\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003enext.js에서 \u003ccode\u003etrailingSlash: true\u003c/code\u003e 설정을 사용할 때 꼭 알아둬야 할 점이 있어요. 바로 리다이렉트(rewrites) 설정할 때 \u003ccode\u003esource\u003c/code\u003e 경로 끝에도 꼭 슬래시(/)를 붙여줘야 한다는 거죠. 목적지(destination) URL도 마찬가지예요. 만약 원격 서버가 슬래시를 기대한다면 destination 경로 끝에도 슬래시를 붙여줘야 정상적으로 동작합니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, 아래와 같이 설정하면 \u003ccode\u003e/blog/\u003c/code\u003e 또는 \u003ccode\u003e/blog/\u003c/code\u003e 하위 경로로 들어오는 요청을 정확히 리다이렉트할 수 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003etrailingSlash\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n  \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erewrites\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e [\n      {\n        \u003cspan class=\"hljs-attr\"\u003esource\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/blog/'\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003edestination\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'https://example.com/blog/'\u003c/span\u003e,\n      },\n      {\n        \u003cspan class=\"hljs-attr\"\u003esource\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/blog/:path*/'\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003edestination\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'https://example.com/blog/:path*/'\u003c/span\u003e,\n      },\n    ]\n  },\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 \u003ccode\u003e:path*\u003c/code\u003e는 와일드카드처럼 동작해서 \u003ccode\u003e/blog/anything/here/\u003c/code\u003e 같은 하위 경로도 전부 포괄해줍니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003eNext.js 점진적 도입 (Incremental adoption)\u003c/h3\u003e\n\u003cp\u003e또 하나 재미있는 점은, 기존에 운영 중인 웹사이트가 있을 때 Next.js로 점진적으로 옮겨갈 수 있다는 거예요. Next.js가 먼저 자신의 라우트들을 검사한 후에 해당 경로가 없다면 기존 서버 쪽으로 프록시(proxy) 요청을 넘기는 방법이죠.\u003c/p\u003e\n\u003cp\u003e이 방식을 사용하면 한 번에 모든 페이지를 Next.js로 옮기지 않아도 되고, 조금씩 옮기면서 안정적으로 서비스를 개선할 수 있답니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch4\u003e추가 팁!\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003etrailingSlash\u003c/code\u003e 옵션을 켜면 빌드된 정적 파일들도 자동으로 폴더 형식으로 생성됩니다. 예를 들어 \u003ccode\u003e/about\u003c/code\u003e은 \u003ccode\u003e/about/index.html\u003c/code\u003e로 만들어지고, 브라우저에서는 \u003ccode\u003e/about/\u003c/code\u003e URL로 접근하게 되죠.\u003c/li\u003e\n\u003cli\u003e리다이렉트 설정에서 슬래시는 사소해 보여도, 이 부분이 틀리면 404 에러가 날 수 있으니 꼭 신경 써 주세요.\u003c/li\u003e\n\u003cli\u003e점진적 도입을 고려한다면, Next.js의 \u003ccode\u003erewrites\u003c/code\u003e와 \u003ccode\u003efallback\u003c/code\u003e 기능을 적극 활용해보세요. 개발할 때 훨씬 유연해질 거예요!\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e다음에도 Next.js 관련해서 재미있고 쓸모 있는 팁 있으면 계속 공유할게요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cp\u003eNext.js로 더 많은 페이지를 마이그레이션할 때, 리라이트(rewrites) 설정을 매번 바꿀 필요가 없도록 하는 방법을 알려 드릴게요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erewrites\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n      \u003cspan class=\"hljs-attr\"\u003efallback\u003c/span\u003e: [\n        {\n          \u003cspan class=\"hljs-attr\"\u003esource\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/:path*'\u003c/span\u003e,\n          \u003cspan class=\"hljs-attr\"\u003edestination\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e`https://custom-routes-proxying-endpoint.vercel.app/:path*`\u003c/span\u003e,\n        },\n      ],\n    }\n  },\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 하면 어떤 경로로 들어오든 \u003ccode\u003ehttps://custom-routes-proxying-endpoint.vercel.app\u003c/code\u003e 쪽으로 다 연결해주는 역할을 해요. 그래서 점진적으로 Next.js로 옮겨가는 중에도 기존 경로를 일일이 바꿀 필요 없이 한 번에 처리할 수 있죠.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003ebasePath 지원하는 리라이트\u003c/h3\u003e\n\u003cp\u003eNext.js에서 \u003ccode\u003ebasePath\u003c/code\u003e를 사용하면서 리라이트를 할 때는 \u003ccode\u003esource\u003c/code\u003e와 \u003ccode\u003edestination\u003c/code\u003e 양쪽 경로 모두 자동으로 \u003ccode\u003ebasePath\u003c/code\u003e가 앞에 붙어요. 만약 어떤 리라이트에서 \u003ccode\u003ebasePath\u003c/code\u003e를 붙이고 싶지 않으면, 아래처럼 \u003ccode\u003ebasePath: false\u003c/code\u003e를 추가하면 됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erewrites\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n      \u003cspan class=\"hljs-attr\"\u003efallback\u003c/span\u003e: [\n        {\n          \u003cspan class=\"hljs-attr\"\u003esource\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/custom-path/:path*'\u003c/span\u003e,\n          \u003cspan class=\"hljs-attr\"\u003edestination\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'https://external-site.com/:path*'\u003c/span\u003e,\n          \u003cspan class=\"hljs-attr\"\u003ebasePath\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e,  \u003cspan class=\"hljs-comment\"\u003e// basePath 자동 접두사 안붙임\u003c/span\u003e\n        },\n      ],\n    }\n  },\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 쓰면 \u003ccode\u003ebasePath\u003c/code\u003e가 없는 그대로 외부 도메인 주소로 리다이렉션하게 돼요.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e추가 팁!\u003c/strong\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003erewrites\u003c/code\u003e는 URL 경로를 클라이언트에게 그대로 보여주면서 내부적으로 다른 경로로 연결해주는 기능이에요. SEO나 UX에 민감한 상황에서 유용하죠.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efallback\u003c/code\u003e 속성은 일치하는 리라이트 규칙이 없을 때 마지막으로 적용되는 규칙이라, 넓은 범위의 라우팅을 처리할 때 깔끔하게 쓸 수 있어요.\u003c/li\u003e\n\u003cli\u003e만약 API 요청 경로나 이미지 리퀘스트에 리라이트를 복잡하게 적용해야 한다면, 별도의 규칙으로 꼼꼼히 테스트해보세요.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eNext.js에서 라우팅을 다루는 게 어렵게 느껴질 수 있지만, 이런 설정들을 잘 활용하면 한결 유연하고 깔끔하게 관리할 수 있으니 꼭 한번 시도해보세요!\u003c/p\u003e\n\u003c!-- TIL 수평 --\u003e\n\u003cp\u003e\u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"1549334788\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\u003c/p\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003ebasePath\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/docs'\u003c/span\u003e,\n\n  \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erewrites\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e [\n      {\n        \u003cspan class=\"hljs-attr\"\u003esource\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/with-basePath'\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// /docs/with-basePath로 자동 변환됨\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003edestination\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/another'\u003c/span\u003e,  \u003cspan class=\"hljs-comment\"\u003e// /docs/another로 자동 변환됨\u003c/span\u003e\n      },\n      {\n        \u003cspan class=\"hljs-comment\"\u003e// basePath: false가 설정되어 있어 /docs가 붙지 않음\u003c/span\u003e\n        \u003cspan class=\"hljs-comment\"\u003e// 참고: 내부 리다이렉트(예: destination: '/another')에는 사용할 수 없음\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003esource\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/without-basePath'\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003edestination\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'https://example.com'\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003ebasePath\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e,\n      },\n    ]\n  },\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e버전 히스토리\u003c/h2\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003eVersion\u003c/th\u003e\u003cth\u003eChanges\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ev13.3.0\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003emissing\u003c/code\u003e 추가됨\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ev10.2.0\u003c/code\u003e\u003c/td\u003e\u003ctd\u003e\u003ccode\u003ehas\u003c/code\u003e 추가됨\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ev9.5.0\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eHeaders 추가됨\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003chr\u003e\n\u003ch3\u003e살짝 더 알려드려요!\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ebasePath\u003c/strong\u003e는 Next.js에서 모든 경로 앞에 특정 기본 경로를 붙이고 싶을 때 사용해요. 예를 들어, 위 예제처럼 \u003ccode\u003ebasePath: '/docs'\u003c/code\u003e를 설정하면, 모든 페이지와 API가 \u003ccode\u003e/docs\u003c/code\u003e 하위에 위치해요.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003erewrites\u003c/code\u003e는 요청 경로를 다른 경로나 외부 URL로 내부적으로 바꿔주는 역할을 하죠. 위 코드에서는 \u003ccode\u003e/with-basePath\u003c/code\u003e 요청이 \u003ccode\u003e/docs/with-basePath\u003c/code\u003e로, \u003ccode\u003e/another\u003c/code\u003e 경로로도 매핑되는 걸 볼 수 있어요.\u003c/li\u003e\n\u003cli\u003e그런데 \u003ccode\u003ebasePath: false\u003c/code\u003e 옵션이 들어간 리라이트는 좀 특별해요. 이 옵션을 주면 기본 경로가 붙지 않고, 외부 URL(예: \u003ccode\u003ehttps://example.com\u003c/code\u003e)로 바로 연결할 수 있어요. 다만, 내부 경로 리라이트에선 사용할 수 없으니 주의하세요.\u003c/li\u003e\n\u003cli\u003e버전 히스토리를 보면 점차 기능이 추가되고 확장된 걸 알 수 있는데, 개발 중인 프로젝트에 필요한 기능이 어느 버전부터 생겼는지 참고하면 좋아요!\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e다음에 또 재미있는 개발 팁 들고 올게요! 궁금한 점 있으면 언제든 물어봐 주세요~\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2025-04-22-rewrites"},"buildId":"olPs1cVezSGTqD7OaewDI","assetPrefix":"/TIL","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>